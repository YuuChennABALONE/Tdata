
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API int IsInOutOn(const Point2& p, double tol)\t @return 1: in; 0: on; -1: out\n\t @param tol The tolerance of the point\n\t @param p The test point\n\t @brief Check a point is in or out of the polygon\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <common/PointT.hpp>\n#include <math/Classifier2d.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"case3: Classifier2d \", \"[math][Classifier2d][P1]\") {\n    std::vector<Point2> pts = {\n        Point2(2.0, 0.0),\n        Point2(1.0, 1.0),\n        Point2(2.0, 2.0),\n        Point2(3.0, 2.0)\n    }; \n    double tolU = 0.1;\n    double tolV = 0.1;\n    double uMin = 0.0;\n    double vMin = 0.0;\n    double uMax = 2.5;\n    double vMax = 1.5;\n    Classifier2d classifier(pts, tolU, tolV, uMin, vMin, uMax, vMax);\n\tSECTION(\"IsInOutOn Point normal set\") {\n        Point2 OutPoint(0.0, 0.0);\n        Point2 OnPoint(1.0, 1.0);\n        Point2 AnothOnPoint(2.0, 2.0);\n        Point2 InPoint(2.0, 1.0);\n        CHECK(classifier.IsInOutOn(OutPoint,0.0) == -1);\n        CHECK(classifier.IsInOutOn(OnPoint,0.0) != 0);\n        CHECK(classifier.IsInOutOn(OnPoint, 1.0) == 0);\n        CHECK(classifier.IsInOutOn(AnothOnPoint, 1.0) == 0); \n        CHECK(classifier.IsInOutOn(InPoint,0.0) == 1);\n    }}\n}\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API int IsInOut(const Point2& p)\t @return 1: in; 0: on; -1: out\n\t @param p The test point\n\t @brief Check a point is in or out of the polygon\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <common/PointT.hpp>\n#include <math/Classifier2d.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"case1: Classifier2d \", \"[math][Classifier2d][P1]\") {\n    std::vector<Point2> pts = {\n        Point2(2.0, 0.0),\n        Point2(1.0, 1.0),\n        Point2(2.0, 2.0),\n        Point2(3.0, 2.0)\n    }; \n    double tolU = 0.1;\n    double tolV = 0.1;\n    double uMin = 0.0;\n    double vMin = 0.0;\n    double uMax = 2.5;\n    double vMax = 1.5;\n    Classifier2d classifier(pts, tolU, tolV, uMin, vMin, uMax, vMax);\n\tSECTION(\"IsInOut Point normal set\") {\n        Point2 OutPoint(0.0, 0.0);\n        Point2 OnPoint(1.0, 1.0);\n        Point2 InPoint(2.0, 1.0);\n        CHECK(classifier.IsInOut(OutPoint) == -1);\n        CHECK(classifier.IsInOut(OnPoint) == 0);\n        CHECK(classifier.IsInOut(InPoint) == 1);\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API Classifier2d(const std::vector<Point2>& pts, double tolU, double tolV, double uMin, double vMin, double uMax, double vMax)\t @param vMax The upper bound of v\n\t @param uMax The upper bound of u\n\t @param vMin The lower bound of v\n\t @param uMin The lower bound of u\n\t @param tolV The tolerance of v bound\n\t @param tolU The tolerance of u bound\n\t @param pts The points of a 2D closed polygon, the last point does not required to repeat the first point\n\t @details Require uMax > uMin, vMax > vMin, and at least 3 points\n\t @brief Construct from a 2D polygon and uv-bounds\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <common/PointT.hpp>\n#include <math/Classifier2d.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"case1: Classifier2d \", \"[math][Classifier2d][P1]\") {\n    std::vector<Point2> pts = {\n        Point2(2.0, 0.0),\n        Point2(1.0, 1.0),\n        Point2(2.0, 2.0),\n        Point2(3.0, 2.0)\n    }; \n    double tolU = 0.1;\n    double tolV = 0.1;\n    double uMin = 0.0;\n    double vMin = 0.0;\n    double uMax = 2.5;\n    double vMax = 1.5;\n    Classifier2d classifier(pts, tolU, tolV, uMin, vMin, uMax, vMax);\n\tSECTION(\"IsInOut Point normal set\") {\n        Point2 OutPoint(0.0, 0.0);\n        Point2 OnPoint(1.0, 1.0);\n        Point2 InPoint(2.0, 1.0);\n        CHECK(classifier.IsInOut(OutPoint) == -1);\n        CHECK(classifier.IsInOut(OnPoint) == 0);\n        CHECK(classifier.IsInOut(InPoint) == 1);\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] LineS Rotated(const Axis3& axis, double angle)\t @return The rotated line\n\t @param angle The rotation angle\n\t @param axis The rotation axis\n\t @brief Get the line rotated around an axis with an angle in 3D\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <math/LineT.hpp>\n#include <math/Plane.hpp>\n#include <modeling/MakeFace.hpp>\n#include <modeling/MakeEdge.hpp>\nusing AMCAX::Line3;\nusing AMCAX::MakeEdge;\nusing AMCAX::MakeFace;\n#define ONE_RADIAN (M_PI / 180.)\n#define SQUARE(x) ((x) * (x))\nTEST_CASE(\"case1: Derived class interface unit testing\", \"[math][Line3][p1]\")\n{\n\tSECTION(\"Rotate\")\n\t{\n\t\tAxis3 axis(Point3(0., 0., 0.), Direction3(0., 1., 0.));\n\t\tLine3 line(Point3(0., 0., 0.), Direction3(1., 1., -1.));\n\t\tLine3 rotateLine = line.Rotated(axis, 90. * ONE_RADIAN);  \n\t\tTopoEdge edge1 = MakeEdge(line);\n\t\tTopoEdge edge2 = MakeEdge(rotateLine);\n\t\tTopoEdge edge3 = MakeEdge(Line3(axis));\n\t\tbool isWriteSuccess1 = AMCAX::OCCTIO::OCCTTool::Write(edge1, OUTPUT_PATH_PREFIX\"Line3_Rotate_line.brep\");\n\t\tbool isWriteSuccess2 = AMCAX::OCCTIO::OCCTTool::Write(edge2, OUTPUT_PATH_PREFIX\"Line3_Rotate_lineRotate.brep\");\n\t\tbool isWriteSuccess3 = AMCAX::OCCTIO::OCCTTool::Write(edge3, OUTPUT_PATH_PREFIX\"Line3_Rotate_axis.brep\");\n\t\tREQUIRE(isWriteSuccess1);\n\t\tREQUIRE(isWriteSuccess2);\n\t\tREQUIRE(isWriteSuccess3);\n\t\tauto pointToPoint = [](const Point3& p1, const Point3& p2) {\n\t\t\treturn std::sqrt(\n\t\t\t\tSQUARE(p1.X() - p2.X()) +\n\t\t\t\tSQUARE(p1.Y() - p2.Y()) +\n\t\t\t\tSQUARE(p1.Z() - p2.Z())\n\t\t\t);\n\t\t};\n\t\tCHECK(line.Distance(Line3(axis)) == Approx(rotateLine.Distance(Line3(axis))).margin(std::numeric_limits<double>::min()));\n\t\tCHECK(pointToPoint(line.Location(), Point3()) == Approx(pointToPoint(rotateLine.Location(), Point3())).margin(std::numeric_limits<double>::min()));\n\t\tPoint3 p(-1., 1., -1.);\n\t\tCHECK(rotateLine.Contains(p, 1e-6) == true);\n\t}\n}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "LineS& Mirror(const Frame3& frame)\t @return The reference to self\n\t @param frame The mirror frame\n\t @brief Mirror the line by a frame\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <math/LineT.hpp>\n#include <math/Plane.hpp>\n#include <modeling/MakeFace.hpp>\n#include <modeling/MakeEdge.hpp>\nusing AMCAX::Line3;\nusing AMCAX::MakeEdge;\nusing AMCAX::MakeFace;\n#define ONE_RADIAN (M_PI / 180.)\n#define SQUARE(x) ((x) * (x))\nTEST_CASE(\"case1: Derived class interface unit testing\", \"[math][Line3][p1]\")\n{\n\tSECTION(\"Mirror\")\n\t{\n\t\tLine3 line(Point3(1.0, 2.0, 3.0), Direction3(1.0, 0.0, 0.0));\n\t\tLine3 originalLine(Point3(1.0, 2.0, 3.0), Direction3(1.0, 0.0, 0.0));\n\t\tFrame3 frame(Point3(0.0, 0.0, 0.0), Direction3(0.0, 1.0, 0.0));\n\t\tline.Mirror(frame);\n\t\tCHECK(line.Distance(Point3(0.0, 0.0, 0.0)) == Approx(originalLine.Distance(Point3(0., 0., 0.))).margin(std::numeric_limits<double>::min()));\n\t\tDirection3 dir(originalLine.Location().X() - line.Location().X(),\n\t\t\t\t\t   originalLine.Location().Y() - line.Location().Y(),\n\t\t\t\t\t   originalLine.Location().Z() - line.Location().Z());\n\t\tCHECK(dir.IsParallel(Direction3(0.0, 1.0, 0.0), 1e-5 * ONE_RADIAN));\n\t\tLine3 line2(Point3(1.2, -4.6, 2.3), Direction3(1.8, 97.4, -12.8));\n\t\tFrame3 frame2(Point3(87.0, 2.3, 10.14), Direction3(-92.3, 2.6, 1.0));\n\t\tLine3 mirrorLine2 = line2.Mirrored(frame2);\n\t\tCHECK(line2.Distance(Point3(87.0, 2.3, 10.14)) == Approx(mirrorLine2.Distance(Point3(87.0, 2.3, 10.14))).margin(std::numeric_limits<double>::min()));\n\t\tDirection3 dir2(line2.Location().X() - mirrorLine2.Location().X(),\n\t\t\t\t\t    line2.Location().Y() - mirrorLine2.Location().Y(),\n\t\t\t\t\t    line2.Location().Z() - mirrorLine2.Location().Z());\n\t\tCHECK(dir2.IsParallel(Direction3(-92.3, 2.6, 1.0), 1e-5 * ONE_RADIAN));\n\t\tTopoFace face = MakeFace(Plane(frame2), 0., 4., 0., 4.);\n\t\tTopoEdge edgeLine2 = MakeEdge(line2, 0., 1.);\n\t\tTopoEdge edgeMirrorLine2 = MakeEdge(mirrorLine2, 0., 1.);\n\t\tAMCAX::OCCTIO::OCCTTool::Write(face, OUTPUT_PATH_PREFIX\"Line3_Mirror_face2.brep\");\n\t\tAMCAX::OCCTIO::OCCTTool::Write(edgeLine2, OUTPUT_PATH_PREFIX\"Line3_Mirror_edge.brep\");\n\t\tAMCAX::OCCTIO::OCCTTool::Write(edgeMirrorLine2, OUTPUT_PATH_PREFIX\"Line3_Mirror_Mirroredge.brep\");\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] LineS Normal(const Point3& p)\t @return The line passing through a point and perpendicular to the line\n\t @param p The point\n\t @brief Get a line passing through a point and perpendicular to the line\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <math/LineT.hpp>\n#include <math/Plane.hpp>\n#include <modeling/MakeFace.hpp>\n#include <modeling/MakeEdge.hpp>\nusing AMCAX::Line3;\nusing AMCAX::MakeEdge;\nusing AMCAX::MakeFace;\n#define ONE_RADIAN (M_PI / 180.)\n#define SQUARE(x) ((x) * (x))\nTEST_CASE(\"case1: Derived class interface unit testing\", \"[math][Line3][p1]\")\n{\n\tSECTION(\"Normal\")\n\t{\n\t\tLine3 line(Point3(94., 32., 4.8), Direction3(2.65, 3.28, 5.14));\n\t\tLine3 line2 = line.Normal(Point3(2.1, 3.4, 11.2));\n\t\tCHECK(line.Direction().Dot(line2.Direction()) == Approx(0.).margin(1e-6));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] auto Distance(const Point3& p)\t @return The distance between the point and the line\n\t @param p The point\n\t @brief Compute the distance from a point to the line\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <math/LineT.hpp>\n#include <math/Plane.hpp>\n#include <modeling/MakeFace.hpp>\n#include <modeling/MakeEdge.hpp>\nusing AMCAX::Line3;\nusing AMCAX::MakeEdge;\nusing AMCAX::MakeFace;\n#define ONE_RADIAN (M_PI / 180.)\n#define SQUARE(x) ((x) * (x))\nTEST_CASE(\"case1: Derived class interface unit testing\", \"[math][Line3][p1]\")\n{\n\tSECTION(\"Distance and SquaredDistance\")\n\t{\n\t\tauto pointToLine = [](const Point3& p, const Line3& line) {\n\t\t\tconst Point3& p1 = line.Location();\n\t\t\tdouble dX = p1.X() - p.X();\n\t\t\tdouble dY = p1.Y() - p.Y();\n\t\t\tdouble dZ = p1.Z() - p.Z();\n\t\t\tdouble pp1Square = SQUARE(dX) + SQUARE(dY) + SQUARE(dZ);\n\t\t\tDirection3 dir(dX, dY, dZ);\n\t\t\tdouble cos = std::fabs(dir.Dot(line.Direction()));\n\t\t\treturn std::sqrt(pp1Square - SQUARE(cos*std::sqrt(pp1Square)));\n\t\t};\n\t\tauto lineToLine = [&pointToLine](const Line3& line1, const Line3& line2) {\n\t\t\tif (line1.Direction().IsParallel(line2.Direction(), std::numeric_limits<double>::min()))\n\t\t\t\treturn pointToLine(line1.Location(), line2);\n\t\t\tDirection3 line1Dir = line1.Direction();\n\t\t\tDirection3 line2Dir = line2.Direction();\n\t\t\tdouble x3 = line1Dir.Y() * line2Dir.Z() - line2Dir.Y() * line1Dir.Z();\n\t\t\tdouble y3 = -(line1Dir.X() * line2Dir.Z() - line2Dir.X() * line1Dir.Z());\n\t\t\tdouble z3 = line1Dir.X() * line2Dir.Y() - line2Dir.X() * line1Dir.Y();\n\t\t\tDirection3 line3Dir(x3, y3, z3);\n\t\t\tDirection3 line12Dir(line1.Location().X() - line2.Location().X(), \n\t\t\t\t\t\t\t\t line1.Location().Y() - line2.Location().Y(), line1.Location().Z() - line2.Location().Z());\n\t\t\treturn std::fabs(line3Dir.Dot(line12Dir));\n\t\t};\n\t\tLine3 line(Point3(99., 2., 33.), Direction3(2.3, 4.6, 9.8));\n\t\tCHECK(line.Distance(Point3(0., 1., 0.)) == Approx(pointToLine(Point3(0., 1., 0.), line)).margin(1e-5));\n\t\tLine3 line2(Point3(0., 0., 0.), Direction3(1., 0., 0.));\n\t\tLine3 line3(Point3(0., 1., 0.), Direction3(1., 0., 0.));\n\t\tCHECK(line2.Distance(line3) == Approx(lineToLine(line2, line3)).margin(std::numeric_limits<double>::min()));\n\t\tCHECK(line2.SquaredDistance(line3) == Approx(SQUARE(lineToLine(line2, line3))).margin(std::numeric_limits<double>::min()));\n\t\tLine3 line4(Point3(0., 0., 0.), Direction3(1., 0., 0.));\n\t\tLine3 line5(Point3(0., 1., 0.), Direction3(1., 1., 0.));\n\t\tCHECK(line4.Distance(line5) == Approx(lineToLine(line4, line5)).margin(std::numeric_limits<double>::min()));\n\t\tLine3 line6(Point3(0., 0., 0.), Direction3(0., 0., 1.));\n\t\tLine3 line7(Point3(0., 1., 0.), Direction3(1., 1., 0.));\n\t\tCHECK(line6.Distance(line7) == Approx(lineToLine(line6, line7)).margin(std::numeric_limits<double>::min()));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] auto SquaredDistance(const LineS& l)\t @return The squared distance between two lines\n\t @param l The other line\n\t @brief Compute the squared distance between two lines\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <math/LineT.hpp>\n#include <math/Plane.hpp>\n#include <modeling/MakeFace.hpp>\n#include <modeling/MakeEdge.hpp>\nusing AMCAX::Line3;\nusing AMCAX::MakeEdge;\nusing AMCAX::MakeFace;\n#define ONE_RADIAN (M_PI / 180.)\n#define SQUARE(x) ((x) * (x))\nTEST_CASE(\"case1: Derived class interface unit testing\", \"[math][Line3][p1]\")\n{\n\tSECTION(\"Distance and SquaredDistance\")\n\t{\n\t\tauto pointToLine = [](const Point3& p, const Line3& line) {\n\t\t\tconst Point3& p1 = line.Location();\n\t\t\tdouble dX = p1.X() - p.X();\n\t\t\tdouble dY = p1.Y() - p.Y();\n\t\t\tdouble dZ = p1.Z() - p.Z();\n\t\t\tdouble pp1Square = SQUARE(dX) + SQUARE(dY) + SQUARE(dZ);\n\t\t\tDirection3 dir(dX, dY, dZ);\n\t\t\tdouble cos = std::fabs(dir.Dot(line.Direction()));\n\t\t\treturn std::sqrt(pp1Square - SQUARE(cos*std::sqrt(pp1Square)));\n\t\t};\n\t\tauto lineToLine = [&pointToLine](const Line3& line1, const Line3& line2) {\n\t\t\tif (line1.Direction().IsParallel(line2.Direction(), std::numeric_limits<double>::min()))\n\t\t\t\treturn pointToLine(line1.Location(), line2);\n\t\t\tDirection3 line1Dir = line1.Direction();\n\t\t\tDirection3 line2Dir = line2.Direction();\n\t\t\tdouble x3 = line1Dir.Y() * line2Dir.Z() - line2Dir.Y() * line1Dir.Z();\n\t\t\tdouble y3 = -(line1Dir.X() * line2Dir.Z() - line2Dir.X() * line1Dir.Z());\n\t\t\tdouble z3 = line1Dir.X() * line2Dir.Y() - line2Dir.X() * line1Dir.Y();\n\t\t\tDirection3 line3Dir(x3, y3, z3);\n\t\t\tDirection3 line12Dir(line1.Location().X() - line2.Location().X(), \n\t\t\t\t\t\t\t\t line1.Location().Y() - line2.Location().Y(), line1.Location().Z() - line2.Location().Z());\n\t\t\treturn std::fabs(line3Dir.Dot(line12Dir));\n\t\t};\n\t\tLine3 line(Point3(99., 2., 33.), Direction3(2.3, 4.6, 9.8));\n\t\tCHECK(line.Distance(Point3(0., 1., 0.)) == Approx(pointToLine(Point3(0., 1., 0.), line)).margin(1e-5));\n\t\tLine3 line2(Point3(0., 0., 0.), Direction3(1., 0., 0.));\n\t\tLine3 line3(Point3(0., 1., 0.), Direction3(1., 0., 0.));\n\t\tCHECK(line2.Distance(line3) == Approx(lineToLine(line2, line3)).margin(std::numeric_limits<double>::min()));\n\t\tCHECK(line2.SquaredDistance(line3) == Approx(SQUARE(lineToLine(line2, line3))).margin(std::numeric_limits<double>::min()));\n\t\tLine3 line4(Point3(0., 0., 0.), Direction3(1., 0., 0.));\n\t\tLine3 line5(Point3(0., 1., 0.), Direction3(1., 1., 0.));\n\t\tCHECK(line4.Distance(line5) == Approx(lineToLine(line4, line5)).margin(std::numeric_limits<double>::min()));\n\t\tLine3 line6(Point3(0., 0., 0.), Direction3(0., 0., 1.));\n\t\tLine3 line7(Point3(0., 1., 0.), Direction3(1., 1., 0.));\n\t\tCHECK(line6.Distance(line7) == Approx(lineToLine(line6, line7)).margin(std::numeric_limits<double>::min()));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] Derived Reversed()\t @return The line with reversed direction\n\t @brief Get the line with reversed direction\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <math/LineT.hpp>\n#include <math/Plane.hpp>\n#include <modeling/MakeFace.hpp>\n#include <modeling/MakeEdge.hpp>\nusing AMCAX::Line3;\nusing AMCAX::MakeEdge;\nusing AMCAX::MakeFace;\n#define ONE_RADIAN (M_PI / 180.)\n#define SQUARE(x) ((x) * (x))\nTEST_CASE(\"case2: Line3 base method Test\", \"[math][Line3][p1]\")\n{\n\tSECTION(\"Reverse\")\n\t{\n\t\tLine3 line(Point3(), Direction3(1., 1., 1.));\n\t\tLine3 reverseLine = line.Reversed();\n\t\tCHECK(reverseLine.Direction().IsEqual(Direction3(-1., -1., -1.), 1e-6 * ONE_RADIAN));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] auto Angle(const LineBase& other)\t @return The angle between the line and the other line\n\t @param other The other line\n\t @brief Compute the angle between the line and the other line\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <math/LineT.hpp>\n#include <math/Plane.hpp>\n#include <modeling/MakeFace.hpp>\n#include <modeling/MakeEdge.hpp>\nusing AMCAX::Line3;\nusing AMCAX::MakeEdge;\nusing AMCAX::MakeFace;\n#define ONE_RADIAN (M_PI / 180.)\n#define SQUARE(x) ((x) * (x))\nTEST_CASE(\"case2: Line3 base method Test\", \"[math][Line3][p1]\")\n{\n\tSECTION(\"Angle\")\n\t{\n\t\tLine3 line(Point3(0., 1., 0.), Direction3(1., 1., 1.));\n\t\tLine3 line2(Point3(0., 3.4, 0.), Direction3(2., -1., -1.5));\n\t\tCHECK(line.Angle(line2) == Approx(std::acos(line.Direction().Dot(line2.Direction()))).margin(1e-6 * ONE_RADIAN));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] const AxisT<double, DIM>& Position()\t @return The axis of the line\n\t @brief Get the axis of the line\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <math/LineT.hpp>\n#include <math/Plane.hpp>\n#include <modeling/MakeFace.hpp>\n#include <modeling/MakeEdge.hpp>\nusing AMCAX::Line3;\nusing AMCAX::MakeEdge;\nusing AMCAX::MakeFace;\n#define ONE_RADIAN (M_PI / 180.)\n#define SQUARE(x) ((x) * (x))\nTEST_CASE(\"case1: Derived class interface unit testing\", \"[math][Line3][p1]\")\n{\n\tSECTION(\"constructor\")\n\t{\n\t\tLine3 line;  \n\t\tCHECK(line.Location().IsEqual(Point3(0., 0., 0.), 1e-5));\n\t\tCHECK(line.Direction().IsEqual(Direction3(0., 0., 1.), 1e-5 * ONE_RADIAN));\n\t\tAxis3 axis(Point3(1., 1., 1.), Direction3(3., 3., 4.));\n\t\tLine3 line2(axis);\n\t\tCHECK(line2.Position().IsCoaxial(axis, 1e-5 * ONE_RADIAN, 1e-5));  \n\t\tLine3 line3(Point3(1., 2., 3.), Direction3(3., 2., 1.));\n\t\tCHECK(line3.Location().IsEqual(Point3(1., 2., 3.), 1e-5));\n\t\tCHECK(line3.Direction().IsEqual(Direction3(3., 2., 1.), 1e-5 * ONE_RADIAN));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] const DirectionT<double, DIM>& Direction()\t @return The direction of the line\n\t @brief Get the direction of the line\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <math/LineT.hpp>\n#include <math/Plane.hpp>\n#include <modeling/MakeFace.hpp>\n#include <modeling/MakeEdge.hpp>\nusing AMCAX::Line3;\nusing AMCAX::MakeEdge;\nusing AMCAX::MakeFace;\n#define ONE_RADIAN (M_PI / 180.)\n#define SQUARE(x) ((x) * (x))\nTEST_CASE(\"case1: Derived class interface unit testing\", \"[math][Line3][p1]\")\n{\n\tSECTION(\"constructor\")\n\t{\n\t\tLine3 line;  \n\t\tCHECK(line.Location().IsEqual(Point3(0., 0., 0.), 1e-5));\n\t\tCHECK(line.Direction().IsEqual(Direction3(0., 0., 1.), 1e-5 * ONE_RADIAN));\n\t\tAxis3 axis(Point3(1., 1., 1.), Direction3(3., 3., 4.));\n\t\tLine3 line2(axis);\n\t\tCHECK(line2.Position().IsCoaxial(axis, 1e-5 * ONE_RADIAN, 1e-5));  \n\t\tLine3 line3(Point3(1., 2., 3.), Direction3(3., 2., 1.));\n\t\tCHECK(line3.Location().IsEqual(Point3(1., 2., 3.), 1e-5));\n\t\tCHECK(line3.Direction().IsEqual(Direction3(3., 2., 1.), 1e-5 * ONE_RADIAN));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "void SetPosition(const AxisT<double, DIM>& axis)\t @param axis The axis\n\t @brief Set the axis of the line\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <math/LineT.hpp>\n#include <math/Plane.hpp>\n#include <modeling/MakeFace.hpp>\n#include <modeling/MakeEdge.hpp>\nusing AMCAX::Line3;\nusing AMCAX::MakeEdge;\nusing AMCAX::MakeFace;\n#define ONE_RADIAN (M_PI / 180.)\n#define SQUARE(x) ((x) * (x))\nTEST_CASE(\"case2: Line3 base method Test\", \"[math][Line3][p1]\")\n{\n\tSECTION(\"SetPosition\")\n\t{\n\t\tAxis3 axis(Point3(0.1, -2.3, 0.3), Direction3(1.2, -8.9, 3.));\n\t\tLine3 line;\n\t\tline.SetPosition(axis);\n\t\tCHECK(line.Location().IsEqual(axis.Location(), std::numeric_limits<double>::min()));\n\t\tCHECK(line.Direction().IsEqual(axis.Direction(), std::numeric_limits<double>::min()));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "void SetDirection(const DirectionT<double, DIM>& dir)\t @param dir The line direction\n\t @brief Set the line direction\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <math/LineT.hpp>\n#include <math/Plane.hpp>\n#include <modeling/MakeFace.hpp>\n#include <modeling/MakeEdge.hpp>\nusing AMCAX::Line3;\nusing AMCAX::MakeEdge;\nusing AMCAX::MakeFace;\n#define ONE_RADIAN (M_PI / 180.)\n#define SQUARE(x) ((x) * (x))\nTEST_CASE(\"case2: Line3 base method Test\", \"[math][Line3][p1]\")\n{\n\tSECTION(\"SetDirection\")\n\t{\n\t\tDirection3 dir(1., 1., 1.);\n\t\tLine3 line;\n\t\tline.SetDirection(dir);\n\t\tCHECK(line.Direction().IsEqual(dir, std::numeric_limits<double>::min()));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "void SetLocation(const PointT<double, DIM>& point)\t @param point The location point\n\t @brief Set the location of the line\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <math/LineT.hpp>\n#include <math/Plane.hpp>\n#include <modeling/MakeFace.hpp>\n#include <modeling/MakeEdge.hpp>\nusing AMCAX::Line3;\nusing AMCAX::MakeEdge;\nusing AMCAX::MakeFace;\n#define ONE_RADIAN (M_PI / 180.)\n#define SQUARE(x) ((x) * (x))\nTEST_CASE(\"case2: Line3 base method Test\", \"[math][Line3][p1]\")\n{\n\tSECTION(\"SetLocation\")\n\t{\n\t\tLine3 line(Point3(2., 3., 2.), Direction3(2., 3.4, -2.));\n\t\tline.SetLocation(Point3(1., -2., 8.));\n\t\tCHECK(line.Location().IsEqual(Point3(1., -2., 8.), std::numeric_limits<double>::min()));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] Derived Translated(const VectorT<double, DIM>& vec)\t @return The translated line\n\t @param vec The translation vector\n\t @brief Get the line translated by a vector\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <math/LineT.hpp>\n#include <math/Plane.hpp>\n#include <modeling/MakeFace.hpp>\n#include <modeling/MakeEdge.hpp>\nusing AMCAX::Line3;\nusing AMCAX::MakeEdge;\nusing AMCAX::MakeFace;\n#define ONE_RADIAN (M_PI / 180.)\n#define SQUARE(x) ((x) * (x))\nTEST_CASE(\"case2: Line3 base method Test\", \"[math][Line3][p1]\")\n{\n\tSECTION(\"Translate\")\n\t{\n\t\tLine3 line(Point3(), Direction3(1., 1., 1.));\n\t\tLine3 originalLine(Point3(), Direction3(1., 1., 1.));\n\t\tline.Translate(Point3(), Point3(0., 1., 0.));\n\t\tCHECK(originalLine.Direction().IsEqual(line.Direction(), 1e-6 * ONE_RADIAN));\n\t\tCHECK(line.Contains(Point3(0., 1., 0.), 1e-6));\n\t\tLine3 line2 = line.Translated(Vector3(Direction3(1., -1., 1.)));\n\t\tCHECK(line.Direction().IsEqual(line2.Direction(), 1e-6 * ONE_RADIAN));\n\t\tCHECK(line2.Contains(Point3(0. + 1. / std::sqrt(3.), 1 - 1. / std::sqrt(3.), 0. + 1. / std::sqrt(3.)), 1e-6));\n\t}\n}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "Derived& Translate(const PointT<double, DIM>& p1, const PointT<double, DIM>& p2)\t @return The reference to self\n\t @param p2 The target point\n\t @param p1 The source point\n\t @brief Translate the line by a vector from a point to another point\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <math/LineT.hpp>\n#include <math/Plane.hpp>\n#include <modeling/MakeFace.hpp>\n#include <modeling/MakeEdge.hpp>\nusing AMCAX::Line3;\nusing AMCAX::MakeEdge;\nusing AMCAX::MakeFace;\n#define ONE_RADIAN (M_PI / 180.)\n#define SQUARE(x) ((x) * (x))\nTEST_CASE(\"case2: Line3 base method Test\", \"[math][Line3][p1]\")\n{\n\tSECTION(\"Translate\")\n\t{\n\t\tLine3 line(Point3(), Direction3(1., 1., 1.));\n\t\tLine3 originalLine(Point3(), Direction3(1., 1., 1.));\n\t\tline.Translate(Point3(), Point3(0., 1., 0.));\n\t\tCHECK(originalLine.Direction().IsEqual(line.Direction(), 1e-6 * ONE_RADIAN));\n\t\tCHECK(line.Contains(Point3(0., 1., 0.), 1e-6));\n\t\tLine3 line2 = line.Translated(Vector3(Direction3(1., -1., 1.)));\n\t\tCHECK(line.Direction().IsEqual(line2.Direction(), 1e-6 * ONE_RADIAN));\n\t\tCHECK(line2.Contains(Point3(0. + 1. / std::sqrt(3.), 1 - 1. / std::sqrt(3.), 0. + 1. / std::sqrt(3.)), 1e-6));\n\t}\n}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] Derived Transformed(const TransformationT<double, DIM>& tr)\t @return The transformed line\n\t @param tr The transformation\n\t @brief Get the transformed line\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <math/LineT.hpp>\n#include <math/Plane.hpp>\n#include <modeling/MakeFace.hpp>\n#include <modeling/MakeEdge.hpp>\nusing AMCAX::Line3;\nusing AMCAX::MakeEdge;\nusing AMCAX::MakeFace;\n#define ONE_RADIAN (M_PI / 180.)\n#define SQUARE(x) ((x) * (x))\nTEST_CASE(\"case2: Line3 base method Test\", \"[math][Line3][p1]\")\n{\n\tSECTION(\"Transform\")\n\t{\n\t\tLine3 line(Point3(), Direction3(0., 1., 0.));\n\t\tTransformation3 translationTransform;\n\t\ttranslationTransform.SetTranslation(Point3(0., 0., 0.), Point3(1., 1., 1.));  \n\t\tLine3 translationLine = line.Transformed(translationTransform);\n\t\tCHECK(translationLine.Direction().IsEqual(line.Direction(), 1e-6 * ONE_RADIAN));\n\t\tCHECK(translationLine.Contains(Point3(1., 1., 1.), 1e-6));\n\t\tTransformation3 rotationTransfrom;\n\t\trotationTransfrom.SetRotation(Axis3(Point3(), Direction3(1., 0., 0.)), 90. * ONE_RADIAN);  \n\t\tLine3 rotationLine = line.Transformed(rotationTransfrom);\n\t\tCHECK(rotationLine.Direction().IsEqual(Direction3(0., 0., 1.), 1e-6 * ONE_RADIAN));\n\t\tCHECK(rotationLine.Contains(Point3(0., 0., 3.), 1e-6) == true);\n\t\tTransformation3 scaleTransfrom;\n\t\tscaleTransfrom.SetScale(Point3(1., 0., 1.), -1.); \n\t\tLine3 scaleLine = line.Transformed(scaleTransfrom);\n\t\tCHECK(line.Distance(Point3(1., 0., 1.)) == scaleLine.Distance(Point3(1., 0., 1.)));\n\t\tCHECK(scaleLine.Direction().IsEqual(Direction3(0., -1., 0.), 1e-6*ONE_RADIAN));\n\t\tTransformation3 mirrorTransfrom;\n\t\tmirrorTransfrom.SetMirror(Frame3(Point3(0., 0., 0.), Direction3(1., 0., 0.)));\n\t\tLine3 mirrorLine = line.Transformed(mirrorTransfrom);\n\t\tCHECK(line.Distance(Point3(0., 0., 0.)) == mirrorLine.Distance(Point3(0., 0., 0.)));\n\t\tAMCAX::OCCTIO::OCCTTool::Write(MakeEdge(line), OUTPUT_PATH_PREFIX\"Line3_Transform_InitialLine.brep\");\n\t\tTransformation3 CombinedTransfrom = scaleTransfrom * mirrorTransfrom* translationTransform * rotationTransfrom;  \n\t\tline.Transform(CombinedTransfrom);\n\t\tAMCAX::OCCTIO::OCCTTool::Write(MakeEdge(line), OUTPUT_PATH_PREFIX\"Line3_Transform_transformLine.brep\");\n\t\tCHECK(line.Contains(Point3(3., -1., 1.), 1e-6) == true);\n\t\tCHECK(line.Direction().IsEqual(Direction3(0., 0., -1.), 1e-6 * ONE_RADIAN));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "Derived& Transform(const TransformationT<double, DIM>& tr)\t @return The reference to self\n\t @param tr The transformation\n\t @brief Transform the line\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <math/LineT.hpp>\n#include <math/Plane.hpp>\n#include <modeling/MakeFace.hpp>\n#include <modeling/MakeEdge.hpp>\nusing AMCAX::Line3;\nusing AMCAX::MakeEdge;\nusing AMCAX::MakeFace;\n#define ONE_RADIAN (M_PI / 180.)\n#define SQUARE(x) ((x) * (x))\nTEST_CASE(\"case2: Line3 base method Test\", \"[math][Line3][p1]\")\n{\n\tSECTION(\"Transform\")\n\t{\n\t\tLine3 line(Point3(), Direction3(0., 1., 0.));\n\t\tTransformation3 translationTransform;\n\t\ttranslationTransform.SetTranslation(Point3(0., 0., 0.), Point3(1., 1., 1.));  \n\t\tLine3 translationLine = line.Transformed(translationTransform);\n\t\tCHECK(translationLine.Direction().IsEqual(line.Direction(), 1e-6 * ONE_RADIAN));\n\t\tCHECK(translationLine.Contains(Point3(1., 1., 1.), 1e-6));\n\t\tTransformation3 rotationTransfrom;\n\t\trotationTransfrom.SetRotation(Axis3(Point3(), Direction3(1., 0., 0.)), 90. * ONE_RADIAN);  \n\t\tLine3 rotationLine = line.Transformed(rotationTransfrom);\n\t\tCHECK(rotationLine.Direction().IsEqual(Direction3(0., 0., 1.), 1e-6 * ONE_RADIAN));\n\t\tCHECK(rotationLine.Contains(Point3(0., 0., 3.), 1e-6) == true);\n\t\tTransformation3 scaleTransfrom;\n\t\tscaleTransfrom.SetScale(Point3(1., 0., 1.), -1.); \n\t\tLine3 scaleLine = line.Transformed(scaleTransfrom);\n\t\tCHECK(line.Distance(Point3(1., 0., 1.)) == scaleLine.Distance(Point3(1., 0., 1.)));\n\t\tCHECK(scaleLine.Direction().IsEqual(Direction3(0., -1., 0.), 1e-6*ONE_RADIAN));\n\t\tTransformation3 mirrorTransfrom;\n\t\tmirrorTransfrom.SetMirror(Frame3(Point3(0., 0., 0.), Direction3(1., 0., 0.)));\n\t\tLine3 mirrorLine = line.Transformed(mirrorTransfrom);\n\t\tCHECK(line.Distance(Point3(0., 0., 0.)) == mirrorLine.Distance(Point3(0., 0., 0.)));\n\t\tAMCAX::OCCTIO::OCCTTool::Write(MakeEdge(line), OUTPUT_PATH_PREFIX\"Line3_Transform_InitialLine.brep\");\n\t\tTransformation3 CombinedTransfrom = scaleTransfrom * mirrorTransfrom* translationTransform * rotationTransfrom;  \n\t\tline.Transform(CombinedTransfrom);\n\t\tAMCAX::OCCTIO::OCCTTool::Write(MakeEdge(line), OUTPUT_PATH_PREFIX\"Line3_Transform_transformLine.brep\");\n\t\tCHECK(line.Contains(Point3(3., -1., 1.), 1e-6) == true);\n\t\tCHECK(line.Direction().IsEqual(Direction3(0., 0., -1.), 1e-6 * ONE_RADIAN));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] Derived Scaled(const PointT<double, DIM>& point, double scale)\t @return The scaled line\n\t @param scale The scale value\n\t @param point The scaling center point\n\t @brief Get the line scaled by a point\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <math/LineT.hpp>\n#include <math/Plane.hpp>\n#include <modeling/MakeFace.hpp>\n#include <modeling/MakeEdge.hpp>\nusing AMCAX::Line3;\nusing AMCAX::MakeEdge;\nusing AMCAX::MakeFace;\n#define ONE_RADIAN (M_PI / 180.)\n#define SQUARE(x) ((x) * (x))\nTEST_CASE(\"case2: Line3 base method Test\", \"[math][Line3][p1]\")\n{\n\tSECTION(\"Scale\")\n\t{\n\t\tLine3 line(Point3(), Direction3(0., 1., 0.));\n\t\tPoint3 point(1., 1., 0.);\n\t\tdouble originalDistance = line.Distance(point);\n\t\tLine3 line1 = line.Scaled(point, 1.1);\n\t\tCHECK(line1.Distance(point) > originalDistance);\n\t\tLine3 line2 = line.Scaled(point, 1.);\n\t\tCHECK(line2.Distance(point) == originalDistance);\n\t\tLine3 line3 = line.Scaled(point, 0.8);\n\t\tCHECK(line3.Distance(point) < originalDistance);\n\t\tLine3 line4 = line.Scaled(point, 0.);\n\t\tCHECK(line4.Contains(point, 1e-6));\n\t\tLine3 line5 = line.Scaled(point, -1.);\n\t\tCHECK(line5.Direction().IsEqual(Direction3(0., -1., 0.), 1e-6 * ONE_RADIAN));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] const PointT<double, DIM>& Location()\t @return The location of the line\n\t @brief Get the location point of the line\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <math/LineT.hpp>\n#include <math/Plane.hpp>\n#include <modeling/MakeFace.hpp>\n#include <modeling/MakeEdge.hpp>\nusing AMCAX::Line3;\nusing AMCAX::MakeEdge;\nusing AMCAX::MakeFace;\n#define ONE_RADIAN (M_PI / 180.)\n#define SQUARE(x) ((x) * (x))\nTEST_CASE(\"case1: Derived class interface unit testing\", \"[math][Line3][p1]\")\n{\n\tSECTION(\"constructor\")\n\t{\n\t\tLine3 line;  \n\t\tCHECK(line.Location().IsEqual(Point3(0., 0., 0.), 1e-5));\n\t\tCHECK(line.Direction().IsEqual(Direction3(0., 0., 1.), 1e-5 * ONE_RADIAN));\n\t\tAxis3 axis(Point3(1., 1., 1.), Direction3(3., 3., 4.));\n\t\tLine3 line2(axis);\n\t\tCHECK(line2.Position().IsCoaxial(axis, 1e-5 * ONE_RADIAN, 1e-5));  \n\t\tLine3 line3(Point3(1., 2., 3.), Direction3(3., 2., 1.));\n\t\tCHECK(line3.Location().IsEqual(Point3(1., 2., 3.), 1e-5));\n\t\tCHECK(line3.Direction().IsEqual(Direction3(3., 2., 1.), 1e-5 * ONE_RADIAN));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] bool Contains(const PointT<double, DIM>& p, double tol)\t @return True if the point is on the line under the tolerance\n\t @param tol The tolerance\n\t @param p The point\n\t @brief Does the line contain a point under a distance tolerance\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <math/LineT.hpp>\n#include <math/Plane.hpp>\n#include <modeling/MakeFace.hpp>\n#include <modeling/MakeEdge.hpp>\nusing AMCAX::Line3;\nusing AMCAX::MakeEdge;\nusing AMCAX::MakeFace;\n#define ONE_RADIAN (M_PI / 180.)\n#define SQUARE(x) ((x) * (x))\nTEST_CASE(\"case2: Line3 base method Test\", \"[math][Line3][p1]\")\n{\n\tSECTION(\"Contains\")\n\t{\n\t\tLine3 line(Point3(), Direction3(1., 1., 1.));\n\t\tPoint3 point1(2., 2., 2.);\n\t\tPoint3 point2(2., 1., 2.);\n\t\tauto isContains = [](const Line3& line, const Point3& point) {\n\t\t\tDirection3 dir(line.Location().X() - point.X(), line.Location().Y() - point.Y(), line.Location().Z() - point.Z());\n\t\t\treturn line.Direction().IsParallel(dir, 1e-5);\n\t\t};\n\t\tCHECK(line.Contains(point1, 1e-5) == isContains(line, point1));\n\t\tCHECK(line.Contains(point2, 1e-5) == isContains(line, point2));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] auto SquaredDistance(const Point3& p)\t @return The squared distance between the point and the line\n\t @param p The point\n\t @brief Compute the squared distance from a point to the line\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <math/LineT.hpp>\n#include <modeling/MakeEdge2d.hpp>\nusing AMCAX::Line2;\n#define ONE_RADIAN (M_PI / 180.)\nTEST_CASE(\"case1: Line basic interface test\", \"[math][Line2][p1]\")\n{\n\tSECTION(\"Distance and SquaredDistance test\")\n\t{\n\t\tauto pointToLine = [](const Point2& point, const Line2& line) {\n\t\t\tdouble a, b, c;\n\t\t\tline.Coefficients(a, b, c);\n\t\t\treturn std::fabs(a * point.X() + b * point.Y() + c);\n\t\t};\n\t\tauto lineToLine = [](const Line2& line1, const Line2& line2) {\n\t\t\tdouble a1, b1, c1, a2, b2, c2;\n\t\t\tline1.Coefficients(a1, b1, c1);\n\t\t\tline2.Coefficients(a2, b2, c2);\n\t\t\tif (a1 != a2 || b1 != b2) return 0.;\n\t\t\treturn std::fabs(c1 - c2);\n\t\t};\n\t\tLine2 line(3., 4., -30.);\n\t\tPoint2 point1(6., 3.);\n\t\tPoint2 point2(6., 2.);\n\t\tLine2 line2(3., 4., -29.);\n\t\tLine2 line3(2., 1., -99.);\n\t\tCHECK(line.Distance(point1) == Approx(pointToLine(point1, line)).margin(0.01));\n\t\tCHECK(line.SquaredDistance(point1) == Approx(pointToLine(point1, line) * pointToLine(point1, line)).margin(0.01));\n\t\tCHECK(line.Distance(point2) == Approx(pointToLine(point2, line)));\n\t\tCHECK(line.SquaredDistance(point2) == Approx(pointToLine(point2, line) * pointToLine(point2, line)).margin(0.01));\n\t\tCHECK(line.Distance(line2) == Approx(lineToLine(line, line2)));\n\t\tCHECK(line.SquaredDistance(line2) == Approx(lineToLine(line2, line) * lineToLine(line2, line)).margin(0.01));\n\t\tCHECK(line.Distance(line3) == Approx(lineToLine(line, line3)));\n\t\tCHECK(line.SquaredDistance(line3) == Approx(lineToLine(line3, line) * lineToLine(line3, line)).margin(0.01));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] auto Distance(const Point3& p)\t @return The distance between the point and the line\n\t @param p The point\n\t @brief Compute the distance from a point to the line\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <math/LineT.hpp>\n#include <modeling/MakeEdge2d.hpp>\nusing AMCAX::Line2;\n#define ONE_RADIAN (M_PI / 180.)\nTEST_CASE(\"case2: Line base method Test\", \"[math][Line2][p1]\")\n{\n\tSECTION(\"Scale\")\n\t{\n\t\tLine2 line(Point2(0., -1.), Direction2());\n\t\tPoint2 point;\n\t\tdouble distance = line.Distance(point);\n\t\tLine2 lineScale1 = line.Scaled(point, 1.1);\n\t\tCHECK(lineScale1.Distance(point) > distance);\n\t\tCHECK(lineScale1.Contains(Point2(0., -1.1), 1e-5));\n\t\tLine2 lineScale2 = line.Scaled(point, 1.);\n\t\tCHECK(lineScale2.Distance(point) == Approx(distance).margin(1e-5));\n\t\tCHECK(lineScale2.Contains(Point2(0., -1.), 1e-5));\n\t\tLine2 lineScale3 = line.Scaled(point, 0.8);\n\t\tCHECK(lineScale3.Distance(point) < distance);\n\t\tCHECK(lineScale3.Contains(Point2(0., -0.8), 1e-5));\n\t\tLine2 lineScale4 = line.Scaled(point, 0.);\n\t\tline.SetDirection(Direction2(-1.0, 4.0));\n\t\tLine2 lineScale5 = line.Scaled(Point2(-1., 2.), 0.);\n\t\tCHECK(lineScale4.Contains(Point2(0., 0.), 1e-5));\n\t\tCHECK(lineScale4.Direction().IsEqual(Direction2(), 1e-6 * ONE_RADIAN));\n\t\tCHECK(lineScale5.Contains(Point2(-1., 2.), 1e-5));\n\t\tCHECK(lineScale5.Direction().IsEqual(Direction2(-1., 4.), 1e-6 * ONE_RADIAN));\n\t\tLine2 lineScale6 = line.Scaled(point, -1.);\n\t\tCHECK(lineScale6.Direction().IsEqual(Direction2(1., -4.), 1e-5 * ONE_RADIAN));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] LineS Rotated(const Point2& point, double angle)\t @return The rotated line\n\t @param angle The rotation angle\n\t @param point The rotation center point\n\t @brief Get the line rotated around a point with an angle in 2D\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <math/LineT.hpp>\n#include <modeling/MakeEdge2d.hpp>\nusing AMCAX::Line2;\n#define ONE_RADIAN (M_PI / 180.)\nTEST_CASE(\"case1: Line basic interface test\", \"[math][Line2][p1]\")\n{\n\tSECTION(\"Rotated Test\")\n\t{\n\t\tLine2 line(Point2(0., 1.), Direction2(1., 1.));  \n\t\tLine2 rotateLine = line.Rotated(Point2(), (3. / 4) * M_PI);  \n\t\tCHECK(rotateLine.Direction().X() == Approx(-1.).margin(1e-5));\n\t\tCHECK(rotateLine.Direction().Y() == Approx(0.).margin(1e-5));\n\t\tdouble a, b, c;\n\t\trotateLine.Coefficients(a, b, c);\n\t\tCHECK((c - b) == Approx(0.).margin(0.5));\n\t\tCHECK(line.Distance(Point2()) == rotateLine.Distance(Point2()));  \n\t\tTopoShape lineShape1 = MakeEdge2d(line);\n\t\tTopoShape lineShape2 = MakeEdge2d(rotateLine);\n\t\tREQUIRE(OCCTIO::OCCTTool::Write(lineShape1, OUTPUT_PATH_PREFIX\"Line2_Rotated_before_p1.brep\"));\n\t\tREQUIRE(OCCTIO::OCCTTool::Write(lineShape2, OUTPUT_PATH_PREFIX\"Line2_Rotated_later_p1.brep\"));\n\t}\n}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "LineS& Rotate(const Point2& point, double angle)\t @return The reference to self\n\t @param angle The rotation angle\n\t @param point The rotation center point\n\t @brief Rotate the line around a point with an angle in 2D\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <math/LineT.hpp>\n#include <modeling/MakeEdge2d.hpp>\nusing AMCAX::Line2;\n#define ONE_RADIAN (M_PI / 180.)\nTEST_CASE(\"case1: Line basic interface test\", \"[math][Line2][p1]\")\n{\n\tSECTION(\"Rotate Test\")\n\t{\n\t\tLine2 line(Point2(0., 1.), Direction2(1., 1.));  \n\t\tLine2 line2(Point2(0., 1.), Direction2(1., 1.));  \n\t\tline.Rotate(Point2(), (5. / 4) * M_PI);  \n\t\tCHECK(line.Direction().X() == Approx(0.).margin(1e-5));\n\t\tCHECK(line.Direction().Y() == Approx(-1.).margin(1e-5));\n\t\tdouble a, b, c;\n\t\tline.Coefficients(a, b, c);\n\t\tCHECK((a + c) == Approx(0.).margin(0.5));\n\t\tCHECK(line2.Distance(Point2()) == line.Distance(Point2()));  \n\t\tCHECK(line.Contains(Point2(std::sqrt(2.) / 2., 0.), 1e-6) == true);\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] LineS Normal(const Point2& p)\t @return The line passing through a point and perpendicular to the line\n\t @param p The point\n\t @brief Get a line passing through a point and perpendicular to the line\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <math/LineT.hpp>\n#include <modeling/MakeEdge2d.hpp>\nusing AMCAX::Line2;\n#define ONE_RADIAN (M_PI / 180.)\nTEST_CASE(\"case1: Line basic interface test\", \"[math][Line2][p1]\")\n{\n\tSECTION(\"Normal Test\")\n\t{\n\t\tLine2 line(3., 4., 5.);  \n\t\tLine2 normalLine = line.Normal(Point2(1., 5.));\n\t\tdouble a, b, c;\n\t\tnormalLine.Coefficients(a, b, c);\n\t\tCHECK((a * 3 + b * 4) == Approx(0.0).margin(0.1));\n\t\tCHECK((a * 1 + b * 5 + c) == Approx(0.0).margin(0.1));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] auto SquaredDistance(const LineS& l)\t @return The squared distance between two lines\n\t @param l The other line\n\t @brief Compute the squared distance between two lines\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <math/LineT.hpp>\n#include <modeling/MakeEdge2d.hpp>\nusing AMCAX::Line2;\n#define ONE_RADIAN (M_PI / 180.)\nTEST_CASE(\"case1: Line basic interface test\", \"[math][Line2][p1]\")\n{\n\tSECTION(\"Distance and SquaredDistance test\")\n\t{\n\t\tauto pointToLine = [](const Point2& point, const Line2& line) {\n\t\t\tdouble a, b, c;\n\t\t\tline.Coefficients(a, b, c);\n\t\t\treturn std::fabs(a * point.X() + b * point.Y() + c);\n\t\t};\n\t\tauto lineToLine = [](const Line2& line1, const Line2& line2) {\n\t\t\tdouble a1, b1, c1, a2, b2, c2;\n\t\t\tline1.Coefficients(a1, b1, c1);\n\t\t\tline2.Coefficients(a2, b2, c2);\n\t\t\tif (a1 != a2 || b1 != b2) return 0.;\n\t\t\treturn std::fabs(c1 - c2);\n\t\t};\n\t\tLine2 line(3., 4., -30.);\n\t\tPoint2 point1(6., 3.);\n\t\tPoint2 point2(6., 2.);\n\t\tLine2 line2(3., 4., -29.);\n\t\tLine2 line3(2., 1., -99.);\n\t\tCHECK(line.Distance(point1) == Approx(pointToLine(point1, line)).margin(0.01));\n\t\tCHECK(line.SquaredDistance(point1) == Approx(pointToLine(point1, line) * pointToLine(point1, line)).margin(0.01));\n\t\tCHECK(line.Distance(point2) == Approx(pointToLine(point2, line)));\n\t\tCHECK(line.SquaredDistance(point2) == Approx(pointToLine(point2, line) * pointToLine(point2, line)).margin(0.01));\n\t\tCHECK(line.Distance(line2) == Approx(lineToLine(line, line2)));\n\t\tCHECK(line.SquaredDistance(line2) == Approx(lineToLine(line2, line) * lineToLine(line2, line)).margin(0.01));\n\t\tCHECK(line.Distance(line3) == Approx(lineToLine(line, line3)));\n\t\tCHECK(line.SquaredDistance(line3) == Approx(lineToLine(line3, line) * lineToLine(line3, line)).margin(0.01));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] auto SquaredDistance(const Point2& p)\t @return The squared distance between the point and the line\n\t @param p The point\n\t @brief Compute the squared distance from a point to the line\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <math/LineT.hpp>\n#include <modeling/MakeEdge2d.hpp>\nusing AMCAX::Line2;\n#define ONE_RADIAN (M_PI / 180.)\nTEST_CASE(\"case1: Line basic interface test\", \"[math][Line2][p1]\")\n{\n\tSECTION(\"Distance and SquaredDistance test\")\n\t{\n\t\tauto pointToLine = [](const Point2& point, const Line2& line) {\n\t\t\tdouble a, b, c;\n\t\t\tline.Coefficients(a, b, c);\n\t\t\treturn std::fabs(a * point.X() + b * point.Y() + c);\n\t\t};\n\t\tauto lineToLine = [](const Line2& line1, const Line2& line2) {\n\t\t\tdouble a1, b1, c1, a2, b2, c2;\n\t\t\tline1.Coefficients(a1, b1, c1);\n\t\t\tline2.Coefficients(a2, b2, c2);\n\t\t\tif (a1 != a2 || b1 != b2) return 0.;\n\t\t\treturn std::fabs(c1 - c2);\n\t\t};\n\t\tLine2 line(3., 4., -30.);\n\t\tPoint2 point1(6., 3.);\n\t\tPoint2 point2(6., 2.);\n\t\tLine2 line2(3., 4., -29.);\n\t\tLine2 line3(2., 1., -99.);\n\t\tCHECK(line.Distance(point1) == Approx(pointToLine(point1, line)).margin(0.01));\n\t\tCHECK(line.SquaredDistance(point1) == Approx(pointToLine(point1, line) * pointToLine(point1, line)).margin(0.01));\n\t\tCHECK(line.Distance(point2) == Approx(pointToLine(point2, line)));\n\t\tCHECK(line.SquaredDistance(point2) == Approx(pointToLine(point2, line) * pointToLine(point2, line)).margin(0.01));\n\t\tCHECK(line.Distance(line2) == Approx(lineToLine(line, line2)));\n\t\tCHECK(line.SquaredDistance(line2) == Approx(lineToLine(line2, line) * lineToLine(line2, line)).margin(0.01));\n\t\tCHECK(line.Distance(line3) == Approx(lineToLine(line, line3)));\n\t\tCHECK(line.SquaredDistance(line3) == Approx(lineToLine(line3, line) * lineToLine(line3, line)).margin(0.01));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] auto Distance(const Point2& p)\t @return The distance between the point and the line\n\t @param p The point\n\t @brief Compute the distance from a point to the line\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <math/LineT.hpp>\n#include <modeling/MakeEdge2d.hpp>\nusing AMCAX::Line2;\n#define ONE_RADIAN (M_PI / 180.)\nTEST_CASE(\"case2: Line base method Test\", \"[math][Line2][p1]\")\n{\n\tSECTION(\"SetDirection\")\n\t{\n\t\tLine2 line(Point2(), Direction2(1., 1.));  \n\t\tCHECK(line.Direction().IsEqual(Direction2(1., 1.), 1e-5 * ONE_RADIAN));\n\t\tCHECK(line.Distance(Point2(1., 2.)) > 0.);\n\t\tline.SetDirection(Direction2(1., 2.));  \n\t\tCHECK(line.Direction().IsEqual(Direction2(1., 2.), 1e-5 * ONE_RADIAN));\n\t\tCHECK(line.Distance(Point2(1., 2.)) == Approx(0.).margin(1e-5));\n\t\tdouble a, b, c;\n\t\tline.Coefficients(a, b, c);\n\t\tCHECK(a == Approx(2. / std::sqrt(5)).margin(1e-5));\n\t\tCHECK(b == Approx(-1. / std::sqrt(5)).margin(1e-5));\n\t\tCHECK(c == Approx(0. / std::sqrt(5)).margin(1e-5));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "void Coefficients(double& a, double& b, double& c)\t @param[out] a,b,c The coefficients\n\t @brief The coefficients of the algebraic representation of the 2D line\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <math/LineT.hpp>\n#include <modeling/MakeEdge2d.hpp>\nusing AMCAX::Line2;\n#define ONE_RADIAN (M_PI / 180.)\nTEST_CASE(\"case1: Line basic interface test\", \"[math][Line2][p1]\")\n{\n\tSECTION(\"Parameterized constructor test\")\n\t{\n\t\tLine2 line1(Axis2(Point2(1., 0.), Direction2(2., 1.)));\n\t\tLine2 line2(Point2(1., 0.), Direction2(2., 1.));  \n\t\tLine2 line3(1, -2, -1);\n\t\tdouble a, b, c;\n\t\tline1.Coefficients(a, b, c);\n\t\tCHECK(a == Approx(1.0 / std::sqrt(5)));\n\t\tCHECK(b == Approx(-2.0 / std::sqrt(5)));\n\t\tCHECK(c == Approx(-1.0 / std::sqrt(5)));\n\t\tline2.Coefficients(a, b, c);\n\t\tCHECK(a == Approx(1.0 / std::sqrt(5)));\n\t\tCHECK(b == Approx(-2.0 / std::sqrt(5)));\n\t\tCHECK(c == Approx(-1.0 / std::sqrt(5)));\n\t\tline3.Coefficients(a, b, c);\n\t\tCHECK(a == Approx(1.0 / std::sqrt(5)));\n\t\tCHECK(b == Approx(-2.0 / std::sqrt(5)));\n\t\tCHECK(c == Approx(-1.0 / std::sqrt(5)));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "LineS(double a, double b, double c)\t @param a,b,c The coefficients\n\t @brief Construct from the algebraic coefficients of 2D line\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <math/LineT.hpp>\n#include <modeling/MakeEdge2d.hpp>\nusing AMCAX::Line2;\n#define ONE_RADIAN (M_PI / 180.)\nTEST_CASE(\"case1: Line basic interface test\", \"[math][Line2][p1]\")\n{\n\tSECTION(\"Parameterized constructor test\")\n\t{\n\t\tLine2 line1(Axis2(Point2(1., 0.), Direction2(2., 1.)));\n\t\tLine2 line2(Point2(1., 0.), Direction2(2., 1.));  \n\t\tLine2 line3(1, -2, -1);\n\t\tdouble a, b, c;\n\t\tline1.Coefficients(a, b, c);\n\t\tCHECK(a == Approx(1.0 / std::sqrt(5)));\n\t\tCHECK(b == Approx(-2.0 / std::sqrt(5)));\n\t\tCHECK(c == Approx(-1.0 / std::sqrt(5)));\n\t\tline2.Coefficients(a, b, c);\n\t\tCHECK(a == Approx(1.0 / std::sqrt(5)));\n\t\tCHECK(b == Approx(-2.0 / std::sqrt(5)));\n\t\tCHECK(c == Approx(-1.0 / std::sqrt(5)));\n\t\tline3.Coefficients(a, b, c);\n\t\tCHECK(a == Approx(1.0 / std::sqrt(5)));\n\t\tCHECK(b == Approx(-2.0 / std::sqrt(5)));\n\t\tCHECK(c == Approx(-1.0 / std::sqrt(5)));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "Derived& Reverse()\t @return The reference to self\n\t @brief Reverse the line direction\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <math/LineT.hpp>\n#include <modeling/MakeEdge2d.hpp>\nusing AMCAX::Line2;\n#define ONE_RADIAN (M_PI / 180.)\nTEST_CASE(\"case2: Line base method Test\", \"[math][Line2][p1]\")\n{\n\tSECTION(\"Reverse\")\n\t{\n\t\tLine2 line;\n\t\tline.Reverse();\n\t\tCHECK(line.Direction().IsEqual(Direction2(-1., 0.), 1e-5 * ONE_RADIAN));\n\t\tLine2 line2(Point2(), Direction2(-3., 98.));\n\t\tline2.Reverse();\n\t\tCHECK(line2.Direction().IsEqual(Direction2(3., -98.), 1e-5 * ONE_RADIAN));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] auto Angle(const LineBase& other)\t @return The angle between the line and the other line\n\t @param other The other line\n\t @brief Compute the angle between the line and the other line\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <math/LineT.hpp>\n#include <modeling/MakeEdge2d.hpp>\nusing AMCAX::Line2;\n#define ONE_RADIAN (M_PI / 180.)\nTEST_CASE(\"case2: Line base method Test\", \"[math][Line2][p1]\")\n{\n\tSECTION(\"Angle\")\n\t{\n\t\tLine2 line;\n\t\tLine2 line2(Point2(), Direction2(0., 1.));\n\t\tCHECK(line.Angle(line2) == Approx(M_PI_2));\n\t\tCHECK(line2.Angle(line) == Approx(-M_PI_2));\n\t\tLine2 line3(Point2(), Direction2(2., 3.));\n\t\tLine2 line4(Point2(), Direction2(5., -8.));\n\t\tCHECK(line4.Angle(line3) == Approx(\n\t\t\tstd::acos((2. * 5. + 3. * (-8.)) / (std::sqrt(4. + 9.) * std::sqrt(25. + 64.)))\n\t\t).margin(1e-5 * ONE_RADIAN));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] const DirectionT<double, DIM>& Direction()\t @return The direction of the line\n\t @brief Get the direction of the line\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <math/LineT.hpp>\n#include <modeling/MakeEdge2d.hpp>\nusing AMCAX::Line2;\n#define ONE_RADIAN (M_PI / 180.)\nTEST_CASE(\"case2: Line base method Test\", \"[math][Line2][p1]\")\n{\n\tSECTION(\"Translate Test\")\n\t{\n\t\tLine2 line;\n\t\tline.Translate(Vector2(2., 0.));  \n\t\tCHECK(line.Direction().IsEqual(Direction2(), 1e-5 * ONE_RADIAN));\n\t\tCHECK(line.Contains(Point2(2., 0.), 1e-5));\n\t\tLine2 translateLine = line.Translated(Point2(2., 0.), Point2(-10., 0.));\n\t\tCHECK(translateLine.Contains(Point2(-10., 0.), 1e-5));\n\t}\n}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "void SetPosition(const AxisT<double, DIM>& axis)\t @param axis The axis\n\t @brief Set the axis of the line\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <math/LineT.hpp>\n#include <modeling/MakeEdge2d.hpp>\nusing AMCAX::Line2;\n#define ONE_RADIAN (M_PI / 180.)\nTEST_CASE(\"case2: Line base method Test\", \"[math][Line2][p1]\")\n{\n\tSECTION(\"SetPosition\")\n\t{\n\t\tLine2 line;\n\t\tCHECK(line.Location().IsEqual(Point2(0., 0.), 1e-5));\n\t\tCHECK(line.Direction().IsEqual(Direction2(1., 0.), 1e-5 * ONE_RADIAN));\n\t\tAxis2 axis(Point2(2., 1.), Direction2(1., 1.));\n\t\tline.SetPosition(axis);  \n\t\tdouble a, b, c;\n\t\tline.Coefficients(a, b, c);\n\t\tCHECK(a == Approx(1. / std::sqrt(2)).margin(1e-5));\n\t\tCHECK(b == Approx(-1. / std::sqrt(2)).margin(1e-5));\n\t\tCHECK(c == Approx(-1. / std::sqrt(2)).margin(1e-5));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "void SetDirection(const DirectionT<double, DIM>& dir)\t @param dir The line direction\n\t @brief Set the line direction\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <math/LineT.hpp>\n#include <modeling/MakeEdge2d.hpp>\nusing AMCAX::Line2;\n#define ONE_RADIAN (M_PI / 180.)\nTEST_CASE(\"case2: Line base method Test\", \"[math][Line2][p1]\")\n{\n\tSECTION(\"SetDirection\")\n\t{\n\t\tLine2 line(Point2(), Direction2(1., 1.));  \n\t\tCHECK(line.Direction().IsEqual(Direction2(1., 1.), 1e-5 * ONE_RADIAN));\n\t\tCHECK(line.Distance(Point2(1., 2.)) > 0.);\n\t\tline.SetDirection(Direction2(1., 2.));  \n\t\tCHECK(line.Direction().IsEqual(Direction2(1., 2.), 1e-5 * ONE_RADIAN));\n\t\tCHECK(line.Distance(Point2(1., 2.)) == Approx(0.).margin(1e-5));\n\t\tdouble a, b, c;\n\t\tline.Coefficients(a, b, c);\n\t\tCHECK(a == Approx(2. / std::sqrt(5)).margin(1e-5));\n\t\tCHECK(b == Approx(-1. / std::sqrt(5)).margin(1e-5));\n\t\tCHECK(c == Approx(0. / std::sqrt(5)).margin(1e-5));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "void SetLocation(const PointT<double, DIM>& point)\t @param point The location point\n\t @brief Set the location of the line\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <math/LineT.hpp>\n#include <modeling/MakeEdge2d.hpp>\nusing AMCAX::Line2;\n#define ONE_RADIAN (M_PI / 180.)\nTEST_CASE(\"case2: Line base method Test\", \"[math][Line2][p1]\")\n{\n\tSECTION(\"SetLocation\")\n\t{\n\t\tLine2 line(Point2(0., 0.), Direction2(1., 1.));  \n\t\tCHECK(line.Location().IsEqual(Point2(), 1e-5));\n\t\tline.SetLocation(Point2(2., 1.));  \n\t\tCHECK(line.Location().IsEqual(Point2(2., 1.), 1e-5));\n\t\tdouble a, b, c;\n\t\tline.Coefficients(a, b, c);\n\t\tCHECK(a == Approx(1. / std::sqrt(2)).margin(1e-5));\n\t\tCHECK(b == Approx(-1. / std::sqrt(2)).margin(1e-5));\n\t\tCHECK(c == Approx(-1. / std::sqrt(2)).margin(1e-5));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "Derived& Translate(const VectorT<double, DIM>& vec)\t @return The reference to self\n\t @param vec The translation vector\n\t @brief Translate the line by a vector\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <math/LineT.hpp>\n#include <modeling/MakeEdge2d.hpp>\nusing AMCAX::Line2;\n#define ONE_RADIAN (M_PI / 180.)\nTEST_CASE(\"case2: Line base method Test\", \"[math][Line2][p1]\")\n{\n\tSECTION(\"Translate Test\")\n\t{\n\t\tLine2 line;\n\t\tline.Translate(Vector2(2., 0.));  \n\t\tCHECK(line.Direction().IsEqual(Direction2(), 1e-5 * ONE_RADIAN));\n\t\tCHECK(line.Contains(Point2(2., 0.), 1e-5));\n\t\tLine2 translateLine = line.Translated(Point2(2., 0.), Point2(-10., 0.));\n\t\tCHECK(translateLine.Contains(Point2(-10., 0.), 1e-5));\n\t}\n}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] Derived Scaled(const PointT<double, DIM>& point, double scale)\t @return The scaled line\n\t @param scale The scale value\n\t @param point The scaling center point\n\t @brief Get the line scaled by a point\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <math/LineT.hpp>\n#include <modeling/MakeEdge2d.hpp>\nusing AMCAX::Line2;\n#define ONE_RADIAN (M_PI / 180.)\nTEST_CASE(\"case2: Line base method Test\", \"[math][Line2][p1]\")\n{\n\tSECTION(\"Scale\")\n\t{\n\t\tLine2 line(Point2(0., -1.), Direction2());\n\t\tPoint2 point;\n\t\tdouble distance = line.Distance(point);\n\t\tLine2 lineScale1 = line.Scaled(point, 1.1);\n\t\tCHECK(lineScale1.Distance(point) > distance);\n\t\tCHECK(lineScale1.Contains(Point2(0., -1.1), 1e-5));\n\t\tLine2 lineScale2 = line.Scaled(point, 1.);\n\t\tCHECK(lineScale2.Distance(point) == Approx(distance).margin(1e-5));\n\t\tCHECK(lineScale2.Contains(Point2(0., -1.), 1e-5));\n\t\tLine2 lineScale3 = line.Scaled(point, 0.8);\n\t\tCHECK(lineScale3.Distance(point) < distance);\n\t\tCHECK(lineScale3.Contains(Point2(0., -0.8), 1e-5));\n\t\tLine2 lineScale4 = line.Scaled(point, 0.);\n\t\tline.SetDirection(Direction2(-1.0, 4.0));\n\t\tLine2 lineScale5 = line.Scaled(Point2(-1., 2.), 0.);\n\t\tCHECK(lineScale4.Contains(Point2(0., 0.), 1e-5));\n\t\tCHECK(lineScale4.Direction().IsEqual(Direction2(), 1e-6 * ONE_RADIAN));\n\t\tCHECK(lineScale5.Contains(Point2(-1., 2.), 1e-5));\n\t\tCHECK(lineScale5.Direction().IsEqual(Direction2(-1., 4.), 1e-6 * ONE_RADIAN));\n\t\tLine2 lineScale6 = line.Scaled(point, -1.);\n\t\tCHECK(lineScale6.Direction().IsEqual(Direction2(1., -4.), 1e-5 * ONE_RADIAN));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] const PointT<double, DIM>& Location()\t @return The location of the line\n\t @brief Get the location point of the line\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <math/LineT.hpp>\n#include <modeling/MakeEdge2d.hpp>\nusing AMCAX::Line2;\n#define ONE_RADIAN (M_PI / 180.)\nTEST_CASE(\"case1: Line basic interface test\", \"[math][Line2][p1]\")\n{\n\tSECTION(\"Parameterless constructor test\")\n\t{\n\t\tLine2 line;  \n\t\tCHECK(line.Location().IsEqual(Axis2().Location(), 0.001));\n\t\tCHECK(line.Direction().IsEqual(Axis2().Direction(), 1e-5 * ONE_RADIAN));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] bool Contains(const PointT<double, DIM>& p, double tol)\t @return True if the point is on the line under the tolerance\n\t @param tol The tolerance\n\t @param p The point\n\t @brief Does the line contain a point under a distance tolerance\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <math/LineT.hpp>\n#include <modeling/MakeEdge2d.hpp>\nusing AMCAX::Line2;\n#define ONE_RADIAN (M_PI / 180.)\nTEST_CASE(\"case2: Line base method Test\", \"[math][Line2][p1]\")\n{\n\tSECTION(\"Contains\")\n\t{\n\t\tLine2 line(Axis2(Point2(2., 1.), Direction2(1., 1.)));  \n\t\tPoint2 point1(2., 1.);  \n\t\tPoint2 point2(1., 1.);  \n\t\tCHECK(line.Contains(point1, 1e-5));\n\t\tCHECK_FALSE(line.Contains(point2, 1e-5));\n\t\tCHECK(line.Contains(point2, 1.));  \n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] double SemilatusRectum()\t @return The semilatus rectum\n\t          Semilatus rectum = 2 * focalLength\n\t @details The semilatus rectum of parabola is half of the length of the chord through a focus parallel to the directrix.\n\t @brief Get the semilatus rectum of the parabola\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <math/ParabolaT.hpp>\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Test Parabola3\", \"[math][Parabola3][P1]\")\n{\n\tFrame3 frame;\n\tdouble focal = 5.0;\n\tParabola3 parabola(frame, focal);\n\tSECTION(\"SemilatusRectum\")\n\t{\n\t\tdouble SR = parabola.SemilatusRectum();\n\t\tdouble sr = 2 * focal;\n\t\tCHECK(SR == sr);\n\t}\n}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] double FocalParameter()\t @return The focal parameter\n\t          Focal parameter = 2 * focalLength.\n\t @details The focal parameter of parabola is the distance from the focus to the directrix.\n\t @brief Get the focal parameter of the parabola\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <math/ParabolaT.hpp>\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Test Parabola3\", \"[math][Parabola3][P1]\")\n{\n\tFrame3 frame;\n\tdouble focal = 5.0;\n\tParabola3 parabola(frame, focal);\n\tSECTION(\"FocalParameter\")\n\t{\n\t\tdouble FP = parabola.FocalParameter();\n\t\tdouble fp = 2 * focal;\n\t\tCHECK(FP == fp);\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] double SemilatusRectum()\t @return The semilatus rectum\n\t          Semilatus rectum = 2 * focalLength\n\t @details The semilatus rectum of parabola is half of the length of the chord through a focus parallel to the directrix.\n\t @brief Get the semilatus rectum of the parabola\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <math/ParabolaT.hpp>\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Test Parabola2\", \"[math][Parabola2][P1]\")\n{\n\tAxis2 axis;\n\tdouble focal = 5.0;\n\tbool isRight = true;\n\tParabola2 parabola(axis, focal, isRight);\n\tSECTION(\"SemilatusRectum\")\n\t{\n\t\tdouble SR = parabola.SemilatusRectum();\n\t\tdouble sr = 2 * focal;\n\t\tCHECK(SR == sr);\n\t}\n}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] double FocalParameter()\t @return The focal parameter\n\t          Focal parameter = 2 * focalLength.\n\t @details The focal parameter of parabola is the distance from the focus to the directrix.\n\t @brief Get the focal parameter of the parabola\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <math/ParabolaT.hpp>\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Test Parabola2\", \"[math][Parabola2][P1]\")\n{\n\tAxis2 axis;\n\tdouble focal = 5.0;\n\tbool isRight = true;\n\tParabola2 parabola(axis, focal, isRight);\n\tSECTION(\"FocalParameter\")\n\t{\n\t\tdouble FP = parabola.FocalParameter();\n\t\tdouble fp = 2 * focal;\n\t\tCHECK(FP == fp);\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] double SemilatusRectum()\t @return The semilatus rectum\n\t          Semilatus rectum = 2 * focalLength\n\t @details The semilatus rectum of parabola is half of the length of the chord through a focus parallel to the directrix.\n\t @brief Get the semilatus rectum of the parabola\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <geometry/Geom3Parabola.hpp>\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Test Geom3Parabola\", \"[math][Geom3Parabola][P1]\")\n{\n\tFrame3 frame;\n\tdouble focal = 5.0;\n\tGeom3Parabola g3p(frame, focal);\n\tSECTION(\"SemilatusRectum\")\n\t{\n\t\tdouble SR = g3p.SemilatusRectum();\n\t\tdouble sr = 2 * focal;\n\t\tCHECK(SR == sr);\n\t}\n}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] double FocalParameter()\t @return The focal parameter\n\t          Focal parameter = 2 * focalLength.\n\t @details The focal parameter of parabola is the distance from the focus to the directrix.\n\t @brief Get the focal parameter of the parabola\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <geometry/Geom3Parabola.hpp>\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Test Geom3Parabola\", \"[math][Geom3Parabola][P1]\")\n{\n\tFrame3 frame;\n\tdouble focal = 5.0;\n\tGeom3Parabola g3p(frame, focal);\n\tSECTION(\"FocalParameter\")\n\t{\n\t\tdouble FP = g3p.FocalParameter();\n\t\tdouble fp = 2 * focal;\n\t\tCHECK(FP == fp);\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] double SemilatusRectum()\t @return The semilatus rectum\n\t          Semilatus rectum = 2 * focalLength\n\t @details The semilatus rectum of parabola is half of the length of the chord through a focus parallel to the directrix.\n\t @brief Get the semilatus rectum of the parabola\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <geometry/Geom2Parabola.hpp>\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Test Geom2Parabola\", \"[math][Geom2Parabola][P1]\")\n{\n\tAxis2 axis;\n\tdouble focal = 5.0;\n\tbool isRight = true;\n\tGeom2Parabola g2p(axis, focal, isRight);\n\tSECTION(\"SemilatusRectum\")\n\t{\n\t\tdouble SR = g2p.SemilatusRectum();\n\t\tdouble sr = 2 * focal;\n\t\tCHECK(SR == sr);\n\t}\n}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] double FocalParameter()\t @return The focal parameter\n\t          Focal parameter = 2 * focalLength.\n\t @details The focal parameter of parabola is the distance from the focus to the directrix.\n\t @brief Get the focal parameter of the parabola\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <geometry/Geom2Parabola.hpp>\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Test Geom2Parabola\", \"[math][Geom2Parabola][P1]\")\n{\n\tAxis2 axis;\n\tdouble focal = 5.0;\n\tbool isRight = true;\n\tGeom2Parabola g2p(axis, focal, isRight);\n\tSECTION(\"FocalParameter\")\n\t{\n\t\tdouble FP = g2p.FocalParameter();\n\t\tdouble fp = 2 * focal;\n\t\tCHECK(FP == fp);\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] double Area()\t @return The area of the ellipse\n\t @brief Get the area of the ellipse\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <common/FrameT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <math/EllipseT.hpp>\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Test Ellipse3\", \"[math][Ellipse3][P1]\")\n{\n\tFrame3 frame;\n\tdouble major = 5.0;\n\tdouble minor = 4.0;\n\tEllipse3 ellipse(frame, major, minor);\n\tSECTION(\"Area\")\n\t{\n\t\tdouble S = ellipse.Area();\n\t\tCHECK(S == Approx(M_PI * major * minor));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "EllipseS& Transform(const TransformationT<double, DIM>& tr)\t @return The reference to self\n\t @param tr The transformation\n\t @brief Transform the ellipse\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <common/FrameT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <math/EllipseT.hpp>\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case3:this is a case for Test-Ellipse2-Rotate\", \"[math][Ellipse2][P1]\")\n{\n\tPoint2 point1(6.0, 0.0);\n\tDirection2 dir1(0.0, 1.0);\n\tAxis2 axis1(point1, dir1);\n\tdouble major = 5.0;\n\tdouble minor = 4.0;\n\tbool isRight = true;\n\tEllipse2 ellipse(axis1, major, minor, isRight);\n\tdouble angle = M_PI_2;\n\tPoint2 point_temp(0.0, 0.0);\n\tSECTION(\"Transform\")\n\t{\n\t\tEllipse2 Transfor_ellipse = ellipse.Transform(tr);\n\t\tCHECK(ellipse.Location().X() == Approx(5.0));\n\t\tCHECK(ellipse.Location().Y() == Approx(-2.0));\n\t\tCHECK(ellipse.MajorRadius() == Approx(5.0));\n\t\tCHECK(ellipse.MinorRadius() == Approx(4.0));\n\t\tCHECK(Transfor_ellipse.Location().X() == Approx(5.0));\n\t\tCHECK(Transfor_ellipse.Location().Y() == Approx(-2.0));\n\t\tCHECK(Transfor_ellipse.MajorRadius() == Approx(5.0));\n\t\tCHECK(Transfor_ellipse.MinorRadius() == Approx(4.0));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "EllipseS& Scale(const PointT<double, DIM>& point, double scale)\t @return The reference to self\n\t @param scale The scale value\n\t @param point The scaling center point\n\t @brief Scale the ellipse by a center point\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <common/FrameT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <math/EllipseT.hpp>\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case3:this is a case for Test-Ellipse2-Rotate\", \"[math][Ellipse2][P1]\")\n{\n\tPoint2 point1(6.0, 0.0);\n\tDirection2 dir1(0.0, 1.0);\n\tAxis2 axis1(point1, dir1);\n\tdouble major = 5.0;\n\tdouble minor = 4.0;\n\tbool isRight = true;\n\tEllipse2 ellipse(axis1, major, minor, isRight);\n\tdouble angle = M_PI_2;\n\tPoint2 point_temp(0.0, 0.0);\n\tSECTION(\"Scale\")\n\t{\n\t\tEllipse2 scale_ellipse = ellipse.Scale(point, scale);\n\t\tCHECK(ellipse.Location().X() == Approx(2.5));\n\t\tCHECK(ellipse.Location().Y() == Approx(-1.0));\n\t\tCHECK(ellipse.MajorRadius() == Approx(2.5));\n\t\tCHECK(ellipse.MinorRadius() == Approx(2.0));\n\t\tCHECK(scale_ellipse.Location().X() == Approx(2.5));\n\t\tCHECK(scale_ellipse.Location().Y() == Approx(-1.0));\n\t\tCHECK(scale_ellipse.MajorRadius() == Approx(2.5));\n\t\tCHECK(scale_ellipse.MinorRadius() == Approx(2.0));\n\t}\n\tscale = -2.0;}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] double Area()\t @return The area of the ellipse\n\t @brief Get the area of the ellipse\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <common/FrameT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <math/EllipseT.hpp>\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Test Ellipse2\", \"[math][Ellipse2][P1]\")\n{\n\tAxis2 axis;\n\tdouble major = 5.0;\n\tdouble minor = 4.0;\n\tbool isRight = true;\n\tEllipse2 ellipse(axis, major, minor, isRight);\n\tSECTION(\"Area\")\n\t{\n\t\tdouble S = ellipse.Area();\n\t\tCHECK(S == Approx(M_PI * major * minor));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "CircleS& Scale(const PointT<double, DIM>& p, double scale)\t @return The reference to self\n\t @param scale The scale value\n\t @param p The scaling center point\n\t @brief Scale the circle by a center point\n,\n",
      "output": "#include <math/CircleT.hpp>\n#include <common/CoordT.hpp>\n#include <common/TransformationType.hpp>\n#include <common/DirectionT.hpp>\n#include <common/PointT.hpp>\n#include <common/Precision.hpp>\n#include <common/CoordT.hpp>\n#include <common/TransformationType.hpp>\n#include <topology/TopoEdge.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <topology/TopoWire.hpp>\n#include <modeling/MakeWire.hpp>\n#include <geometry/GlobalProperty.hpp>\n#include <topology/BRepGlobalProperty.hpp>\n#include<iostream>\n#include \"catch.hpp\" \nusing namespace std;\nusing namespace AMCAX;\nTEST_CASE(\"TestCircle2D\", \"[math][Circle2D]\")\n{\n\tAMCAX::CircleT<double, 2> circle2D;\n\tAMCAX::Point2 center2D(0.0, 0.0);\n\tdouble redius2D = 5.0;\n\tdouble tol = 0.1;\n\tcircle2D.SetLocation(center2D);\n\tcircle2D.SetRadius(redius2D);\n\tdouble area2D = circle2D.Area();\n\tdouble length2D = circle2D.Length();\n\tAMCAX::Point2 retcenter2D = circle2D.Location();\n\tdouble retarea2D = M_PI * redius2D * redius2D;\n\tdouble retlength2D = 2 * M_PI * redius2D;\n\tstd::cout << area2D << std::endl;\n\tstd::cout << length2D << std::endl;\n\tstd::cout << retcenter2D.X() << std::endl;\n\tstd::cout << retcenter2D.Y() << std::endl;\n\tCHECK(area2D == retarea2D);\n\tCHECK(length2D == retlength2D);\n\tCHECK(retcenter2D.X() == center2D.X());\n\tCHECK(retcenter2D.Y() == center2D.Y());\n\tdouble a, b, c, d, e, f;\n\tcircle2D.Coefficients(a, b, c, d, e, f);\n\tstd::cout << a << std::endl;\n\tstd::cout << b << std::endl;\n\tstd::cout << c << std::endl;\n\tstd::cout << d << std::endl;\n\tstd::cout << e << std::endl;\n\tstd::cout << f << std::endl;\n\tCHECK(a == 1);\n\tCHECK(b == 1);\n\tCHECK(c == 0);\n\tCHECK(d == 0);\n\tCHECK(e == 0);\n\tCHECK(f == -25);\n\tstd::vector < AMCAX::Point2> testPoints = {\n\t\tAMCAX::Point2(3.0, 4.0),\n\t\tAMCAX::Point2(5.0, 0.0),\n\t\tAMCAX::Point2(4.9, 0.0),\n\t\tAMCAX::Point2(5.1, 0.0),\n\t\tAMCAX::Point2(6.0, 0.0)\n\t};\n\tfor (const auto& point : testPoints)\n\t{\n\t\tdouble distanceToCenter = std::sqrt(point.X() * point.X() + point.Y() * point.Y());\n\t\tbool expectedIsInCircle = distanceToCenter <= 5.0 + tol;\n\t\tbool isInCircle = circle2D.Contains(point, tol);\n\t\tCHECK(isInCircle == expectedIsInCircle);\n\t}\n\tfor (const auto& point : testPoints)\n\t{\n\t\tdouble distance = circle2D.Distance(point);\n\t\tdouble expectedDistance = std::abs(std::sqrt(std::pow(point.X() - center2D.X(), 2) + std::pow(point.Y() - center2D.Y(), 2)) - redius2D);\n\t\tCHECK(distance == expectedDistance);\n\t}\n\tAMCAX::AxisT<double, 2> mirrorAxis(AMCAX::Point2(0.0, 0.0), AMCAX::Direction2(0.0, 1.0));\n\tcircle2D.Mirror(mirrorAxis);\n\tAMCAX::Point2 mirroredCenter = circle2D.Location();\n\tstd::cout << \"Mirrored circle center: (\" << mirroredCenter.X() << \", \" << mirroredCenter.Y() << \")\" << std::endl;\n\tCHECK(mirroredCenter.X() == center2D.X());\n\tCHECK(mirroredCenter.Y() == center2D.Y());\n\tconst AMCAX::FrameT<double, 2>& frame = circle2D.Position();\n\tAMCAX::Point2 rotationPoint(0.0, 0.0);\n\tdouble  rotationAngle = M_PI / 4;\n\tauto rotatedCircle = circle2D.Rotated(rotationPoint, rotationAngle);\n\tdouble cosAngle = cos(rotationAngle);\n\tdouble sinAngle = sin(rotationAngle);\n\tdouble newX = cosAngle * (center2D.X() - rotationPoint.X()) - sinAngle * (center2D.Y() - rotationPoint.Y()) + rotationPoint.X();\n\tdouble newY = sinAngle * (center2D.X() - rotationPoint.X()) + cosAngle * (center2D.Y() - rotationPoint.Y()) + rotationPoint.Y();\n\tauto rotatedCenter = rotatedCircle.Location();\n\tCHECK(newX == center2D.X());\n\tCHECK(newY == center2D.Y());\n\tAMCAX::Point2 scalingCenter(0.0, 0.0);\n\tdouble scalingFactor = 2.0;\n\tauto scaledCircle = circle2D.Scale(scalingCenter, scalingFactor);\n\tdouble scaledRadius = scaledCircle.Radius();\n\tdouble expectedScaledRadius = redius2D * scalingFactor;\n\tCHECK(std::abs(scaledRadius - expectedScaledRadius) < 1e-6);\n\tAMCAX::VectorT<double, 2> translationVector(2.0, 3.0);\n\tauto translatedCircle = circle2D.Translated(translationVector);\n\tauto translatedCenter = translatedCircle.Location();\n\tdouble translatedX = center2D.X() + translationVector.X();\n\tCHECK(translatedX == translatedCenter.X());\n\tauto xAxis = circle2D.XAxis();\n\tauto directionAxis = xAxis.Direction();\n\tCHECK(directionAxis.X() == -1.0);\n\tCHECK(directionAxis.Y() == 0.0);\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] double SquaredDistance(const PointT<double, DIM>& p)\t @return The squared distance from the point to the circle\n\t @param p The point\n\t @brief Compute the squared distance from a point to the circle\n,\n",
      "output": "#include <math/CircleT.hpp>\n#include <common/CoordT.hpp>\n#include <common/TransformationType.hpp>\n#include <common/DirectionT.hpp>\n#include <common/PointT.hpp>\n#include <common/Precision.hpp>\n#include <common/CoordT.hpp>\n#include <common/TransformationType.hpp>\n#include <topology/TopoEdge.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <topology/TopoWire.hpp>\n#include <modeling/MakeWire.hpp>\n#include <geometry/GlobalProperty.hpp>\n#include <topology/BRepGlobalProperty.hpp>\n#include<iostream>\n#include \"catch.hpp\" \nusing namespace std;\nusing namespace AMCAX;\nTEST_CASE(\"TestCircle3D\", \"[math][Circle3D]\")\n{\n\tAMCAX::Circle3 circle3D;\n\tAMCAX::Point3  center3D(0.0, 0.0, 0.0);\n\tdouble radius3D = 5.0;\n\tdouble tol = 0.1;\n\tcircle3D.SetLocation(center3D);\n\tcircle3D.SetRadius(radius3D);\n\tdouble area = circle3D.Area();\n\tauto axis = circle3D.Axis();\n\tAMCAX::Point3 expectedDirection(0.0, 0.0, 1.0);\n\tauto direction = axis.Direction();\n\tCHECK(area == Approx(78.5398));\n\tCHECK(direction.X() == Approx(expectedDirection.X()).margin(tol));\n\tCHECK(direction.Y() == Approx(expectedDirection.Y()).margin(tol));\n\tCHECK(direction.Z() == Approx(expectedDirection.Z()).margin(tol));\n\tstd::vector <AMCAX::Point3> test3DPoints = {\n\t\tAMCAX::Point3(0.0, 0.0, 0.0),\n\t\tAMCAX::Point3(4.0, 0.0, 0.0),\n\t};\n\tfor (const auto& point : test3DPoints)\n\t{\n\t\tdouble distanceToCenter = std::sqrt(std::pow(point.X() - center3D.X(), 2) + std::pow(point.Y() - center3D.Y(), 2) + std::pow(point.Z() - center3D.Z(), 2));\n\t\tbool expectedIsCircle = distanceToCenter <= 5.0 + tol;\n\t\tbool isInCircle = circle3D.Contains(point, tol);\n\t\tCHECK(!isInCircle == expectedIsCircle);\n\t}\n\tAMCAX::PointT<double, 3>  pointOutside(10.0, 0.0, 0.0);\n\tdouble expectedDistance = 5.0;\n\tCHECK(circle3D.Distance(pointOutside) == Approx(expectedDistance));\n\tdouble length = circle3D.Length();\n\tCHECK(length == Approx(31.4159));\n\tauto location = circle3D.Location();\n\tCHECK(location.X() == Approx(0.0));\n\tCHECK(location.Y() == Approx(0.0));\n\tCHECK(location.Z() == Approx(0.0));\n\tAMCAX::PointT<double, 3> mirrorPoint(1.0, 0.0, 0.0);\n\tcircle3D.Mirror(mirrorPoint);\n\tauto mirroredLocation = circle3D.Location();\n\tCHECK(mirroredLocation.X() == Approx(2.0));\n\tCHECK(mirroredLocation.Y() == Approx(0.0));\n\tCHECK(mirroredLocation.Z() == Approx(0.0));\n\tauto position = circle3D.Position();   \n\tdouble r = circle3D.Radius();\n\tCHECK(r == 5.0);\n\tDirection3 zDirection(0.0, 0.0, 1.0);\n\tAxis3 zAxis(center3D, zDirection);\n\tTransformation3 rotation;\n\trotation.SetRotation(zAxis, M_PI / 2);  \n\tPoint3 newCenter1 = center3D.Transformed(rotation);\n\tCHECK(newCenter1.X() == 0.0);\n\tCHECK(newCenter1.Y() == 0.0);\n\tCHECK(newCenter1.Z() == 0.0);\n\tdouble angle = M_PI / 2;\n\tcircle3D.Rotated(zAxis, angle);\n\tAMCAX::Frame3 frame = circle3D.Position();\n\tCHECK(frame.Location().X() == 2.0);\n\tCHECK(frame.Location().Y() == 0.0);\n\tCHECK(frame.Location().Z() == 0.0);\n\tdouble scale = 2.0;\n\tcircle3D.Scale(center3D, scale);\n\tCHECK(circle3D.Radius() == radius3D * 2.0);\n\tAMCAX::PointT<double, 3> insidePoint(3.0, 4.0, 0.0);\n\tAMCAX::PointT<double, 3> onCirclePoint(5.0, 0.0, 0.0);\n\tAMCAX::PointT<double, 3> outsidePoint(8.0, 6.0, 0.0);\n\tdouble insideSquaredDistance = circle3D.SquaredDistance(insidePoint);\n\tdouble onCircleSquaredDistance = circle3D.SquaredDistance(onCirclePoint);\n\tdouble outsideSquaredDistance = circle3D.SquaredDistance(outsidePoint);\n\tCHECK(insideSquaredDistance == Approx(34.5378));\n\tCHECK(onCircleSquaredDistance == 81.0);\n\tCHECK(outsideSquaredDistance == Approx(7.7779));\n\tVectorT<double, 3> translationVector(5.0, 5.0, 0.0);\n\tcircle3D.Translate(translationVector);\n\tCHECK(circle3D.Location().X() == 9.0);\n\tCHECK(circle3D.Location().Y() == 5.0);\n\tCHECK(circle3D.Location().Z() == 0.0);\n\tauto xAxis = circle3D.XAxis();\n\tauto yAxis = circle3D.YAxis();\n\tCHECK(xAxis.Direction().X() == Approx(-1.0));\n\tCHECK(yAxis.Direction().Y() == Approx(-1.0));\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] double Distance(const PointT<double, DIM>& p)\t @return The distance from the point to the circle\n\t @param p The point\n\t @brief Compute the distance from a point to the circle\n,\n",
      "output": "#include <math/CircleT.hpp>\n#include <common/CoordT.hpp>\n#include <common/TransformationType.hpp>\n#include <common/DirectionT.hpp>\n#include <common/PointT.hpp>\n#include <common/Precision.hpp>\n#include <common/CoordT.hpp>\n#include <common/TransformationType.hpp>\n#include <topology/TopoEdge.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <topology/TopoWire.hpp>\n#include <modeling/MakeWire.hpp>\n#include <geometry/GlobalProperty.hpp>\n#include <topology/BRepGlobalProperty.hpp>\n#include<iostream>\n#include \"catch.hpp\" \nusing namespace std;\nusing namespace AMCAX;\nTEST_CASE(\"TestCircle3D\", \"[math][Circle3D]\")\n{\n\tAMCAX::Circle3 circle3D;\n\tAMCAX::Point3  center3D(0.0, 0.0, 0.0);\n\tdouble radius3D = 5.0;\n\tdouble tol = 0.1;\n\tcircle3D.SetLocation(center3D);\n\tcircle3D.SetRadius(radius3D);\n\tdouble area = circle3D.Area();\n\tauto axis = circle3D.Axis();\n\tAMCAX::Point3 expectedDirection(0.0, 0.0, 1.0);\n\tauto direction = axis.Direction();\n\tCHECK(area == Approx(78.5398));\n\tCHECK(direction.X() == Approx(expectedDirection.X()).margin(tol));\n\tCHECK(direction.Y() == Approx(expectedDirection.Y()).margin(tol));\n\tCHECK(direction.Z() == Approx(expectedDirection.Z()).margin(tol));\n\tstd::vector <AMCAX::Point3> test3DPoints = {\n\t\tAMCAX::Point3(0.0, 0.0, 0.0),\n\t\tAMCAX::Point3(4.0, 0.0, 0.0),\n\t};\n\tfor (const auto& point : test3DPoints)\n\t{\n\t\tdouble distanceToCenter = std::sqrt(std::pow(point.X() - center3D.X(), 2) + std::pow(point.Y() - center3D.Y(), 2) + std::pow(point.Z() - center3D.Z(), 2));\n\t\tbool expectedIsCircle = distanceToCenter <= 5.0 + tol;\n\t\tbool isInCircle = circle3D.Contains(point, tol);\n\t\tCHECK(!isInCircle == expectedIsCircle);\n\t}\n\tAMCAX::PointT<double, 3>  pointOutside(10.0, 0.0, 0.0);\n\tdouble expectedDistance = 5.0;\n\tCHECK(circle3D.Distance(pointOutside) == Approx(expectedDistance));\n\tdouble length = circle3D.Length();\n\tCHECK(length == Approx(31.4159));\n\tauto location = circle3D.Location();\n\tCHECK(location.X() == Approx(0.0));\n\tCHECK(location.Y() == Approx(0.0));\n\tCHECK(location.Z() == Approx(0.0));\n\tAMCAX::PointT<double, 3> mirrorPoint(1.0, 0.0, 0.0);\n\tcircle3D.Mirror(mirrorPoint);\n\tauto mirroredLocation = circle3D.Location();\n\tCHECK(mirroredLocation.X() == Approx(2.0));\n\tCHECK(mirroredLocation.Y() == Approx(0.0));\n\tCHECK(mirroredLocation.Z() == Approx(0.0));\n\tauto position = circle3D.Position();   \n\tdouble r = circle3D.Radius();\n\tCHECK(r == 5.0);\n\tDirection3 zDirection(0.0, 0.0, 1.0);\n\tAxis3 zAxis(center3D, zDirection);\n\tTransformation3 rotation;\n\trotation.SetRotation(zAxis, M_PI / 2);  \n\tPoint3 newCenter1 = center3D.Transformed(rotation);\n\tCHECK(newCenter1.X() == 0.0);\n\tCHECK(newCenter1.Y() == 0.0);\n\tCHECK(newCenter1.Z() == 0.0);\n\tdouble angle = M_PI / 2;\n\tcircle3D.Rotated(zAxis, angle);\n\tAMCAX::Frame3 frame = circle3D.Position();\n\tCHECK(frame.Location().X() == 2.0);\n\tCHECK(frame.Location().Y() == 0.0);\n\tCHECK(frame.Location().Z() == 0.0);\n\tdouble scale = 2.0;\n\tcircle3D.Scale(center3D, scale);\n\tCHECK(circle3D.Radius() == radius3D * 2.0);\n\tAMCAX::PointT<double, 3> insidePoint(3.0, 4.0, 0.0);\n\tAMCAX::PointT<double, 3> onCirclePoint(5.0, 0.0, 0.0);\n\tAMCAX::PointT<double, 3> outsidePoint(8.0, 6.0, 0.0);\n\tdouble insideSquaredDistance = circle3D.SquaredDistance(insidePoint);\n\tdouble onCircleSquaredDistance = circle3D.SquaredDistance(onCirclePoint);\n\tdouble outsideSquaredDistance = circle3D.SquaredDistance(outsidePoint);\n\tCHECK(insideSquaredDistance == Approx(34.5378));\n\tCHECK(onCircleSquaredDistance == 81.0);\n\tCHECK(outsideSquaredDistance == Approx(7.7779));\n\tVectorT<double, 3> translationVector(5.0, 5.0, 0.0);\n\tcircle3D.Translate(translationVector);\n\tCHECK(circle3D.Location().X() == 9.0);\n\tCHECK(circle3D.Location().Y() == 5.0);\n\tCHECK(circle3D.Location().Z() == 0.0);\n\tauto xAxis = circle3D.XAxis();\n\tauto yAxis = circle3D.YAxis();\n\tCHECK(xAxis.Direction().X() == Approx(-1.0));\n\tCHECK(yAxis.Direction().Y() == Approx(-1.0));\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] double Length()\t @return The length of the circle\n\t @brief Get the length of the circle\n,\n",
      "output": "#include <math/CircleT.hpp>\n#include <common/CoordT.hpp>\n#include <common/TransformationType.hpp>\n#include <common/DirectionT.hpp>\n#include <common/PointT.hpp>\n#include <common/Precision.hpp>\n#include <common/CoordT.hpp>\n#include <common/TransformationType.hpp>\n#include <topology/TopoEdge.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <topology/TopoWire.hpp>\n#include <modeling/MakeWire.hpp>\n#include <geometry/GlobalProperty.hpp>\n#include <topology/BRepGlobalProperty.hpp>\n#include<iostream>\n#include \"catch.hpp\" \nusing namespace std;\nusing namespace AMCAX;\nTEST_CASE(\"TestCircle2D\", \"[math][Circle2D]\")\n{\n\tAMCAX::CircleT<double, 2> circle2D;\n\tAMCAX::Point2 center2D(0.0, 0.0);\n\tdouble redius2D = 5.0;\n\tdouble tol = 0.1;\n\tcircle2D.SetLocation(center2D);\n\tcircle2D.SetRadius(redius2D);\n\tdouble area2D = circle2D.Area();\n\tdouble length2D = circle2D.Length();\n\tAMCAX::Point2 retcenter2D = circle2D.Location();\n\tdouble retarea2D = M_PI * redius2D * redius2D;\n\tdouble retlength2D = 2 * M_PI * redius2D;\n\tstd::cout << area2D << std::endl;\n\tstd::cout << length2D << std::endl;\n\tstd::cout << retcenter2D.X() << std::endl;\n\tstd::cout << retcenter2D.Y() << std::endl;\n\tCHECK(area2D == retarea2D);\n\tCHECK(length2D == retlength2D);\n\tCHECK(retcenter2D.X() == center2D.X());\n\tCHECK(retcenter2D.Y() == center2D.Y());\n\tdouble a, b, c, d, e, f;\n\tcircle2D.Coefficients(a, b, c, d, e, f);\n\tstd::cout << a << std::endl;\n\tstd::cout << b << std::endl;\n\tstd::cout << c << std::endl;\n\tstd::cout << d << std::endl;\n\tstd::cout << e << std::endl;\n\tstd::cout << f << std::endl;\n\tCHECK(a == 1);\n\tCHECK(b == 1);\n\tCHECK(c == 0);\n\tCHECK(d == 0);\n\tCHECK(e == 0);\n\tCHECK(f == -25);\n\tstd::vector < AMCAX::Point2> testPoints = {\n\t\tAMCAX::Point2(3.0, 4.0),\n\t\tAMCAX::Point2(5.0, 0.0),\n\t\tAMCAX::Point2(4.9, 0.0),\n\t\tAMCAX::Point2(5.1, 0.0),\n\t\tAMCAX::Point2(6.0, 0.0)\n\t};\n\tfor (const auto& point : testPoints)\n\t{\n\t\tdouble distanceToCenter = std::sqrt(point.X() * point.X() + point.Y() * point.Y());\n\t\tbool expectedIsInCircle = distanceToCenter <= 5.0 + tol;\n\t\tbool isInCircle = circle2D.Contains(point, tol);\n\t\tCHECK(isInCircle == expectedIsInCircle);\n\t}\n\tfor (const auto& point : testPoints)\n\t{\n\t\tdouble distance = circle2D.Distance(point);\n\t\tdouble expectedDistance = std::abs(std::sqrt(std::pow(point.X() - center2D.X(), 2) + std::pow(point.Y() - center2D.Y(), 2)) - redius2D);\n\t\tCHECK(distance == expectedDistance);\n\t}\n\tAMCAX::AxisT<double, 2> mirrorAxis(AMCAX::Point2(0.0, 0.0), AMCAX::Direction2(0.0, 1.0));\n\tcircle2D.Mirror(mirrorAxis);\n\tAMCAX::Point2 mirroredCenter = circle2D.Location();\n\tstd::cout << \"Mirrored circle center: (\" << mirroredCenter.X() << \", \" << mirroredCenter.Y() << \")\" << std::endl;\n\tCHECK(mirroredCenter.X() == center2D.X());\n\tCHECK(mirroredCenter.Y() == center2D.Y());\n\tconst AMCAX::FrameT<double, 2>& frame = circle2D.Position();\n\tAMCAX::Point2 rotationPoint(0.0, 0.0);\n\tdouble  rotationAngle = M_PI / 4;\n\tauto rotatedCircle = circle2D.Rotated(rotationPoint, rotationAngle);\n\tdouble cosAngle = cos(rotationAngle);\n\tdouble sinAngle = sin(rotationAngle);\n\tdouble newX = cosAngle * (center2D.X() - rotationPoint.X()) - sinAngle * (center2D.Y() - rotationPoint.Y()) + rotationPoint.X();\n\tdouble newY = sinAngle * (center2D.X() - rotationPoint.X()) + cosAngle * (center2D.Y() - rotationPoint.Y()) + rotationPoint.Y();\n\tauto rotatedCenter = rotatedCircle.Location();\n\tCHECK(newX == center2D.X());\n\tCHECK(newY == center2D.Y());\n\tAMCAX::Point2 scalingCenter(0.0, 0.0);\n\tdouble scalingFactor = 2.0;\n\tauto scaledCircle = circle2D.Scale(scalingCenter, scalingFactor);\n\tdouble scaledRadius = scaledCircle.Radius();\n\tdouble expectedScaledRadius = redius2D * scalingFactor;\n\tCHECK(std::abs(scaledRadius - expectedScaledRadius) < 1e-6);\n\tAMCAX::VectorT<double, 2> translationVector(2.0, 3.0);\n\tauto translatedCircle = circle2D.Translated(translationVector);\n\tauto translatedCenter = translatedCircle.Location();\n\tdouble translatedX = center2D.X() + translationVector.X();\n\tCHECK(translatedX == translatedCenter.X());\n\tauto xAxis = circle2D.XAxis();\n\tauto directionAxis = xAxis.Direction();\n\tCHECK(directionAxis.X() == -1.0);\n\tCHECK(directionAxis.Y() == 0.0);\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] double Radius()\t @return The radius\n\t @brief Get the radius\n,\n",
      "output": "#include <math/CircleT.hpp>\n#include <common/CoordT.hpp>\n#include <common/TransformationType.hpp>\n#include <common/DirectionT.hpp>\n#include <common/PointT.hpp>\n#include <common/Precision.hpp>\n#include <common/CoordT.hpp>\n#include <common/TransformationType.hpp>\n#include <topology/TopoEdge.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <topology/TopoWire.hpp>\n#include <modeling/MakeWire.hpp>\n#include <geometry/GlobalProperty.hpp>\n#include <topology/BRepGlobalProperty.hpp>\n#include<iostream>\n#include \"catch.hpp\" \nusing namespace std;\nusing namespace AMCAX;\nTEST_CASE(\"TestCircle3D\", \"[math][Circle3D]\")\n{\n\tAMCAX::Circle3 circle3D;\n\tAMCAX::Point3  center3D(0.0, 0.0, 0.0);\n\tdouble radius3D = 5.0;\n\tdouble tol = 0.1;\n\tcircle3D.SetLocation(center3D);\n\tcircle3D.SetRadius(radius3D);\n\tdouble area = circle3D.Area();\n\tauto axis = circle3D.Axis();\n\tAMCAX::Point3 expectedDirection(0.0, 0.0, 1.0);\n\tauto direction = axis.Direction();\n\tCHECK(area == Approx(78.5398));\n\tCHECK(direction.X() == Approx(expectedDirection.X()).margin(tol));\n\tCHECK(direction.Y() == Approx(expectedDirection.Y()).margin(tol));\n\tCHECK(direction.Z() == Approx(expectedDirection.Z()).margin(tol));\n\tstd::vector <AMCAX::Point3> test3DPoints = {\n\t\tAMCAX::Point3(0.0, 0.0, 0.0),\n\t\tAMCAX::Point3(4.0, 0.0, 0.0),\n\t};\n\tfor (const auto& point : test3DPoints)\n\t{\n\t\tdouble distanceToCenter = std::sqrt(std::pow(point.X() - center3D.X(), 2) + std::pow(point.Y() - center3D.Y(), 2) + std::pow(point.Z() - center3D.Z(), 2));\n\t\tbool expectedIsCircle = distanceToCenter <= 5.0 + tol;\n\t\tbool isInCircle = circle3D.Contains(point, tol);\n\t\tCHECK(!isInCircle == expectedIsCircle);\n\t}\n\tAMCAX::PointT<double, 3>  pointOutside(10.0, 0.0, 0.0);\n\tdouble expectedDistance = 5.0;\n\tCHECK(circle3D.Distance(pointOutside) == Approx(expectedDistance));\n\tdouble length = circle3D.Length();\n\tCHECK(length == Approx(31.4159));\n\tauto location = circle3D.Location();\n\tCHECK(location.X() == Approx(0.0));\n\tCHECK(location.Y() == Approx(0.0));\n\tCHECK(location.Z() == Approx(0.0));\n\tAMCAX::PointT<double, 3> mirrorPoint(1.0, 0.0, 0.0);\n\tcircle3D.Mirror(mirrorPoint);\n\tauto mirroredLocation = circle3D.Location();\n\tCHECK(mirroredLocation.X() == Approx(2.0));\n\tCHECK(mirroredLocation.Y() == Approx(0.0));\n\tCHECK(mirroredLocation.Z() == Approx(0.0));\n\tauto position = circle3D.Position();   \n\tdouble r = circle3D.Radius();\n\tCHECK(r == 5.0);\n\tDirection3 zDirection(0.0, 0.0, 1.0);\n\tAxis3 zAxis(center3D, zDirection);\n\tTransformation3 rotation;\n\trotation.SetRotation(zAxis, M_PI / 2);  \n\tPoint3 newCenter1 = center3D.Transformed(rotation);\n\tCHECK(newCenter1.X() == 0.0);\n\tCHECK(newCenter1.Y() == 0.0);\n\tCHECK(newCenter1.Z() == 0.0);\n\tdouble angle = M_PI / 2;\n\tcircle3D.Rotated(zAxis, angle);\n\tAMCAX::Frame3 frame = circle3D.Position();\n\tCHECK(frame.Location().X() == 2.0);\n\tCHECK(frame.Location().Y() == 0.0);\n\tCHECK(frame.Location().Z() == 0.0);\n\tdouble scale = 2.0;\n\tcircle3D.Scale(center3D, scale);\n\tCHECK(circle3D.Radius() == radius3D * 2.0);\n\tAMCAX::PointT<double, 3> insidePoint(3.0, 4.0, 0.0);\n\tAMCAX::PointT<double, 3> onCirclePoint(5.0, 0.0, 0.0);\n\tAMCAX::PointT<double, 3> outsidePoint(8.0, 6.0, 0.0);\n\tdouble insideSquaredDistance = circle3D.SquaredDistance(insidePoint);\n\tdouble onCircleSquaredDistance = circle3D.SquaredDistance(onCirclePoint);\n\tdouble outsideSquaredDistance = circle3D.SquaredDistance(outsidePoint);\n\tCHECK(insideSquaredDistance == Approx(34.5378));\n\tCHECK(onCircleSquaredDistance == 81.0);\n\tCHECK(outsideSquaredDistance == Approx(7.7779));\n\tVectorT<double, 3> translationVector(5.0, 5.0, 0.0);\n\tcircle3D.Translate(translationVector);\n\tCHECK(circle3D.Location().X() == 9.0);\n\tCHECK(circle3D.Location().Y() == 5.0);\n\tCHECK(circle3D.Location().Z() == 0.0);\n\tauto xAxis = circle3D.XAxis();\n\tauto yAxis = circle3D.YAxis();\n\tCHECK(xAxis.Direction().X() == Approx(-1.0));\n\tCHECK(yAxis.Direction().Y() == Approx(-1.0));\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "void SetRadius(double r)\t @param r The radius\n\t @brief Set the radius of the circle\n,\n",
      "output": "#include <math/CircleT.hpp>\n#include <common/CoordT.hpp>\n#include <common/TransformationType.hpp>\n#include <common/DirectionT.hpp>\n#include <common/PointT.hpp>\n#include <common/Precision.hpp>\n#include <common/CoordT.hpp>\n#include <common/TransformationType.hpp>\n#include <topology/TopoEdge.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <topology/TopoWire.hpp>\n#include <modeling/MakeWire.hpp>\n#include <geometry/GlobalProperty.hpp>\n#include <topology/BRepGlobalProperty.hpp>\n#include<iostream>\n#include \"catch.hpp\" \nusing namespace std;\nusing namespace AMCAX;\nTEST_CASE(\"TestCircle2D\", \"[math][Circle2D]\")\n{\n\tAMCAX::CircleT<double, 2> circle2D;\n\tAMCAX::Point2 center2D(0.0, 0.0);\n\tdouble redius2D = 5.0;\n\tdouble tol = 0.1;\n\tcircle2D.SetLocation(center2D);\n\tcircle2D.SetRadius(redius2D);\n\tdouble area2D = circle2D.Area();\n\tdouble length2D = circle2D.Length();\n\tAMCAX::Point2 retcenter2D = circle2D.Location();\n\tdouble retarea2D = M_PI * redius2D * redius2D;\n\tdouble retlength2D = 2 * M_PI * redius2D;\n\tstd::cout << area2D << std::endl;\n\tstd::cout << length2D << std::endl;\n\tstd::cout << retcenter2D.X() << std::endl;\n\tstd::cout << retcenter2D.Y() << std::endl;\n\tCHECK(area2D == retarea2D);\n\tCHECK(length2D == retlength2D);\n\tCHECK(retcenter2D.X() == center2D.X());\n\tCHECK(retcenter2D.Y() == center2D.Y());\n\tdouble a, b, c, d, e, f;\n\tcircle2D.Coefficients(a, b, c, d, e, f);\n\tstd::cout << a << std::endl;\n\tstd::cout << b << std::endl;\n\tstd::cout << c << std::endl;\n\tstd::cout << d << std::endl;\n\tstd::cout << e << std::endl;\n\tstd::cout << f << std::endl;\n\tCHECK(a == 1);\n\tCHECK(b == 1);\n\tCHECK(c == 0);\n\tCHECK(d == 0);\n\tCHECK(e == 0);\n\tCHECK(f == -25);\n\tstd::vector < AMCAX::Point2> testPoints = {\n\t\tAMCAX::Point2(3.0, 4.0),\n\t\tAMCAX::Point2(5.0, 0.0),\n\t\tAMCAX::Point2(4.9, 0.0),\n\t\tAMCAX::Point2(5.1, 0.0),\n\t\tAMCAX::Point2(6.0, 0.0)\n\t};\n\tfor (const auto& point : testPoints)\n\t{\n\t\tdouble distanceToCenter = std::sqrt(point.X() * point.X() + point.Y() * point.Y());\n\t\tbool expectedIsInCircle = distanceToCenter <= 5.0 + tol;\n\t\tbool isInCircle = circle2D.Contains(point, tol);\n\t\tCHECK(isInCircle == expectedIsInCircle);\n\t}\n\tfor (const auto& point : testPoints)\n\t{\n\t\tdouble distance = circle2D.Distance(point);\n\t\tdouble expectedDistance = std::abs(std::sqrt(std::pow(point.X() - center2D.X(), 2) + std::pow(point.Y() - center2D.Y(), 2)) - redius2D);\n\t\tCHECK(distance == expectedDistance);\n\t}\n\tAMCAX::AxisT<double, 2> mirrorAxis(AMCAX::Point2(0.0, 0.0), AMCAX::Direction2(0.0, 1.0));\n\tcircle2D.Mirror(mirrorAxis);\n\tAMCAX::Point2 mirroredCenter = circle2D.Location();\n\tstd::cout << \"Mirrored circle center: (\" << mirroredCenter.X() << \", \" << mirroredCenter.Y() << \")\" << std::endl;\n\tCHECK(mirroredCenter.X() == center2D.X());\n\tCHECK(mirroredCenter.Y() == center2D.Y());\n\tconst AMCAX::FrameT<double, 2>& frame = circle2D.Position();\n\tAMCAX::Point2 rotationPoint(0.0, 0.0);\n\tdouble  rotationAngle = M_PI / 4;\n\tauto rotatedCircle = circle2D.Rotated(rotationPoint, rotationAngle);\n\tdouble cosAngle = cos(rotationAngle);\n\tdouble sinAngle = sin(rotationAngle);\n\tdouble newX = cosAngle * (center2D.X() - rotationPoint.X()) - sinAngle * (center2D.Y() - rotationPoint.Y()) + rotationPoint.X();\n\tdouble newY = sinAngle * (center2D.X() - rotationPoint.X()) + cosAngle * (center2D.Y() - rotationPoint.Y()) + rotationPoint.Y();\n\tauto rotatedCenter = rotatedCircle.Location();\n\tCHECK(newX == center2D.X());\n\tCHECK(newY == center2D.Y());\n\tAMCAX::Point2 scalingCenter(0.0, 0.0);\n\tdouble scalingFactor = 2.0;\n\tauto scaledCircle = circle2D.Scale(scalingCenter, scalingFactor);\n\tdouble scaledRadius = scaledCircle.Radius();\n\tdouble expectedScaledRadius = redius2D * scalingFactor;\n\tCHECK(std::abs(scaledRadius - expectedScaledRadius) < 1e-6);\n\tAMCAX::VectorT<double, 2> translationVector(2.0, 3.0);\n\tauto translatedCircle = circle2D.Translated(translationVector);\n\tauto translatedCenter = translatedCircle.Location();\n\tdouble translatedX = center2D.X() + translationVector.X();\n\tCHECK(translatedX == translatedCenter.X());\n\tauto xAxis = circle2D.XAxis();\n\tauto directionAxis = xAxis.Direction();\n\tCHECK(directionAxis.X() == -1.0);\n\tCHECK(directionAxis.Y() == 0.0);\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] double Distance(const PointT<double, DIM>& p)\t @return The distance from the point to the circle\n\t @param p The point\n\t @brief Compute the distance from a point to the circle\n,\n",
      "output": "#include<catch.hpp>\n#include \"testHelper.h\"\n#include<iostream>\n#include <math/CircleT.hpp>\n#include <common/AxisT.hpp>\n#include <common/PointT.hpp>\nTEST_CASE(\"case1: create a Cirecle\", \"[math][CircleT][P1]\") {\n\tAMCAX::Point2 P(0.0,0.0);\n\tAMCAX::Direction2 D(1.0,0.0);\n\tAMCAX::Axis2  axis2(P, D);\n\tfloat radius = 5.0f;\n\tAMCAX::Circle2 circle2(axis2, radius, true);\n\tCHECK(circle2.Area() == radius * radius * M_PI); \n    double a, b, c, d, e, f;\n    circle2.Coefficients(a, b, c, d, e, f);  \n    double x = 0, y = 5;\n    CHECK(a * x * x + b * y * y + c * x * y + d * x + e * y + f == Approx(0.0).epsilon(1e-15));\n    double x1 = 5 * sqrt(2) / 2;\n    double y1 = 5 * sqrt(2) / 2;\n    double x2 = 6;\n    double y2 = 0;\n    double x3 = 5.5;\n    double y3 = 6.1;\n    AMCAX::Point2 P1(x1,y1);\n    AMCAX::Point2 P2(x2, y2);\n    AMCAX::Point2 P3(x3, y3);\n    double tolerance1 = 0.1;\n    double tolerance2 = 1.0;\n    CHECK(circle2.Contains(P1, tolerance1) == true);\n    CHECK(circle2.Contains(P2, tolerance2) == true);\n    CHECK(circle2.Contains(P3, tolerance2) == false);\n    CHECK(circle2.Distance(P1) == Approx(0.0).epsilon(1e-15));\n    CHECK(circle2.Distance(P2) == Approx(1.0).epsilon(1e-15));\n    CHECK(circle2.Length() == Approx(2*M_PI*radius).epsilon(1e-15));\n    AMCAX::Point2 locationP = circle2.Location();\n    CHECK(locationP.X() == Approx(0.0).epsilon(1e-15));\n    CHECK(locationP.Y() == Approx(0.0).epsilon(1e-15));\n    AMCAX::Point2 mirrorAxisPoint(1.0, 0.0);\n    AMCAX::Direction2 mirrorAxisDirection(0.0, 1.0);\n    AMCAX::Axis2 mirrorAxis(mirrorAxisPoint, mirrorAxisDirection);\n    circle2.Mirror(mirrorAxis);\n    CHECK(circle2.Length() == Approx(2 * M_PI * radius).epsilon(1e-15));\n    AMCAX::Point2 locationPmirror = circle2.Location();\n    CHECK(locationPmirror.X() == Approx(2.0).epsilon(1e-15));\n    CHECK(locationPmirror.Y() == Approx(0.0).epsilon(1e-15));\n    AMCAX::Point2 P4(7.0, 0.0);  \n    CHECK(circle2.Contains(P4, tolerance2) == true);\n    AMCAX::Point2 mirroredAxisPoint(1.0, 0.0);\n    AMCAX::Direction2 mirroredAxisDirection(0.0, 1.0);\n    AMCAX::Axis2 mirroedrAxis(mirroredAxisPoint, mirroredAxisDirection);\n    AMCAX::Circle2 circle2mirrored = circle2.Mirrored(mirroedrAxis);\n    CHECK(circle2mirrored.Length() == Approx(2 * M_PI * radius).epsilon(1e-15));\n    AMCAX::Point2 locationPmirrored = circle2mirrored.Location();\n    CHECK(locationPmirrored.X() == Approx(0.0).epsilon(1e-15));\n    CHECK(locationPmirrored.Y() == Approx(0.0).epsilon(1e-15));\n    AMCAX::Frame2 frame2mirrored = circle2mirrored.Position(); \n    CHECK(frame2mirrored.Location().X() == Approx(0.0).epsilon(1e-15));\n    CHECK(frame2mirrored.Location().Y() == Approx(0.0).epsilon(1e-15));\n    const double& radiusmirrored = circle2mirrored.Radius(); \n    CHECK(radiusmirrored == Approx(radius).epsilon(1e-15));\n    circle2mirrored.Scale(P,0.5); \n    AMCAX::Point2 scaleP1(0.0,-2.5);\n    CHECK(circle2mirrored.Contains(scaleP1, 0) == true);\n    AMCAX::Circle2 circle2Scaled = circle2mirrored.Scale(P, 2); \n    AMCAX::Point2 scaledP1(0.0, 5.0);\n    CHECK(circle2Scaled.Contains(scaledP1, 0) == true);\n    AMCAX::Point2 rotateP(0.0,0.0);\n    double angle = 90.0 * (2 * M_PI / 360.0);\n    circle2.Rotate(rotateP, angle); \n    AMCAX::Point2 P5(0.0, -3.0);\n    CHECK(circle2.Contains(P5, 0) == true);\n    double angle2 = -180.0 * (2 * M_PI / 360.0);\n    AMCAX::Circle2 rotatedCircle2 = circle2.Rotated(rotateP, angle2); \n    AMCAX::Point2 P6(0.0, 3.0);\n    CHECK(rotatedCircle2.Contains(P6, 0) == true); \n    AMCAX::Point2 newP(0.0, 0.0);\n    rotatedCircle2.SetLocation(newP);\n    CHECK(rotatedCircle2.Contains(P1, 0) == true);\n    std::cout << circle2.Length() << std::endl;\n};\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] double Length()\t @return The length of the circle\n\t @brief Get the length of the circle\n,\n",
      "output": "#include<catch.hpp>\n#include \"testHelper.h\"\n#include<iostream>\n#include <math/CircleT.hpp>\n#include <common/AxisT.hpp>\n#include <common/PointT.hpp>\nTEST_CASE(\"case1: create a Cirecle\", \"[math][CircleT][P1]\") {\n\tAMCAX::Point2 P(0.0,0.0);\n\tAMCAX::Direction2 D(1.0,0.0);\n\tAMCAX::Axis2  axis2(P, D);\n\tfloat radius = 5.0f;\n\tAMCAX::Circle2 circle2(axis2, radius, true);\n\tCHECK(circle2.Area() == radius * radius * M_PI); \n    double a, b, c, d, e, f;\n    circle2.Coefficients(a, b, c, d, e, f);  \n    double x = 0, y = 5;\n    CHECK(a * x * x + b * y * y + c * x * y + d * x + e * y + f == Approx(0.0).epsilon(1e-15));\n    double x1 = 5 * sqrt(2) / 2;\n    double y1 = 5 * sqrt(2) / 2;\n    double x2 = 6;\n    double y2 = 0;\n    double x3 = 5.5;\n    double y3 = 6.1;\n    AMCAX::Point2 P1(x1,y1);\n    AMCAX::Point2 P2(x2, y2);\n    AMCAX::Point2 P3(x3, y3);\n    double tolerance1 = 0.1;\n    double tolerance2 = 1.0;\n    CHECK(circle2.Contains(P1, tolerance1) == true);\n    CHECK(circle2.Contains(P2, tolerance2) == true);\n    CHECK(circle2.Contains(P3, tolerance2) == false);\n    CHECK(circle2.Distance(P1) == Approx(0.0).epsilon(1e-15));\n    CHECK(circle2.Distance(P2) == Approx(1.0).epsilon(1e-15));\n    CHECK(circle2.Length() == Approx(2*M_PI*radius).epsilon(1e-15));\n    AMCAX::Point2 locationP = circle2.Location();\n    CHECK(locationP.X() == Approx(0.0).epsilon(1e-15));\n    CHECK(locationP.Y() == Approx(0.0).epsilon(1e-15));\n    AMCAX::Point2 mirrorAxisPoint(1.0, 0.0);\n    AMCAX::Direction2 mirrorAxisDirection(0.0, 1.0);\n    AMCAX::Axis2 mirrorAxis(mirrorAxisPoint, mirrorAxisDirection);\n    circle2.Mirror(mirrorAxis);\n    CHECK(circle2.Length() == Approx(2 * M_PI * radius).epsilon(1e-15));\n    AMCAX::Point2 locationPmirror = circle2.Location();\n    CHECK(locationPmirror.X() == Approx(2.0).epsilon(1e-15));\n    CHECK(locationPmirror.Y() == Approx(0.0).epsilon(1e-15));\n    AMCAX::Point2 P4(7.0, 0.0);  \n    CHECK(circle2.Contains(P4, tolerance2) == true);\n    AMCAX::Point2 mirroredAxisPoint(1.0, 0.0);\n    AMCAX::Direction2 mirroredAxisDirection(0.0, 1.0);\n    AMCAX::Axis2 mirroedrAxis(mirroredAxisPoint, mirroredAxisDirection);\n    AMCAX::Circle2 circle2mirrored = circle2.Mirrored(mirroedrAxis);\n    CHECK(circle2mirrored.Length() == Approx(2 * M_PI * radius).epsilon(1e-15));\n    AMCAX::Point2 locationPmirrored = circle2mirrored.Location();\n    CHECK(locationPmirrored.X() == Approx(0.0).epsilon(1e-15));\n    CHECK(locationPmirrored.Y() == Approx(0.0).epsilon(1e-15));\n    AMCAX::Frame2 frame2mirrored = circle2mirrored.Position(); \n    CHECK(frame2mirrored.Location().X() == Approx(0.0).epsilon(1e-15));\n    CHECK(frame2mirrored.Location().Y() == Approx(0.0).epsilon(1e-15));\n    const double& radiusmirrored = circle2mirrored.Radius(); \n    CHECK(radiusmirrored == Approx(radius).epsilon(1e-15));\n    circle2mirrored.Scale(P,0.5); \n    AMCAX::Point2 scaleP1(0.0,-2.5);\n    CHECK(circle2mirrored.Contains(scaleP1, 0) == true);\n    AMCAX::Circle2 circle2Scaled = circle2mirrored.Scale(P, 2); \n    AMCAX::Point2 scaledP1(0.0, 5.0);\n    CHECK(circle2Scaled.Contains(scaledP1, 0) == true);\n    AMCAX::Point2 rotateP(0.0,0.0);\n    double angle = 90.0 * (2 * M_PI / 360.0);\n    circle2.Rotate(rotateP, angle); \n    AMCAX::Point2 P5(0.0, -3.0);\n    CHECK(circle2.Contains(P5, 0) == true);\n    double angle2 = -180.0 * (2 * M_PI / 360.0);\n    AMCAX::Circle2 rotatedCircle2 = circle2.Rotated(rotateP, angle2); \n    AMCAX::Point2 P6(0.0, 3.0);\n    CHECK(rotatedCircle2.Contains(P6, 0) == true); \n    AMCAX::Point2 newP(0.0, 0.0);\n    rotatedCircle2.SetLocation(newP);\n    CHECK(rotatedCircle2.Contains(P1, 0) == true);\n    std::cout << circle2.Length() << std::endl;\n};\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] double Radius()\t @return The radius\n\t @brief Get the radius\n,\n",
      "output": "#include<catch.hpp>\n#include \"testHelper.h\"\n#include<iostream>\n#include <math/CircleT.hpp>\n#include <common/AxisT.hpp>\n#include <common/PointT.hpp>\nTEST_CASE(\"CircleT Constructor Test\", \"[math][CircleT][P1]\") {\n\tSECTION(\"3D Circle Construction\") {\n        AMCAX::Circle3 circle3;\n        CHECK(circle3.Radius() == Approx(std::numeric_limits<double>::max()));\n        circle3.Axis();\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "void SetRadius(double r)\t @param r The radius\n\t @brief Set the radius of the circle\n,\n",
      "output": "#include<catch.hpp>\n#include \"testHelper.h\"\n#include<iostream>\n#include <math/CircleT.hpp>\n#include <common/AxisT.hpp>\n#include <common/PointT.hpp>\nTEST_CASE(\"CircleT Area and Length Test\", \"[CircleT]\") {\n    AMCAX::Circle2 circle2;\n    circle2.SetRadius(5.0);\n    CHECK(circle2.Area() == Approx(78.53982));\n    CHECK(circle2.Length() == Approx(31.41593));\n    AMCAX::Circle3 circle3;\n    circle3.SetRadius(10.0);\n    CHECK(circle3.Area() == Approx(314.15927));\n    CHECK(circle3.Length() == Approx(62.83185));\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static bool Read(TopoShape& s, std::istream& is)\t @return True if the input process is succeed\n\t @param[in,out] is The input stream\n\t @param[out] s The shape\n\t @brief Read a shape from a stream\n,\n",
      "output": "#include <catch.hpp>\n#include<testHelper.h>\n#include <topology/TopoShape.hpp>\n#include <occtio/OCCTTool.hpp>\nstatic bool ComparisonFields(const std::string& file1, const std::string& file2, const std::string& fields)\n{\n\tifstream file1Stream(file1);\n\tifstream file2Stream(file2);\n\tif (file1Stream.is_open() == false || file2Stream.is_open() == false)\n\t{\n\t\tfile1Stream.close();\n\t\tfile2Stream.close();\n\t\treturn false;\n\t}\n\tstd::string line1, line2;\n\twhile (std::getline(file1Stream, line1))\n\t{\n\t\tif (line1.find(fields) != std::string::npos) break;\n\t}\n\twhile (std::getline(file2Stream, line2))\n\t{\n\t\tif (line2.find(fields) != std::string::npos) break;\n\t}\n\tfile1Stream.close();\n\tfile2Stream.close();\n\treturn line1 == line2;\n}\nTEST_CASE(\"CASE3:Check occio read not exist file \", \"[occtio][OCCTTool][p2]\") {\n\tAMCAX::TopoShape shape;\n\tSECTION(\"OCCTIO::OCCTTool::Read\") {\n\t\tbool isReadSuccess = AMCAX::OCCTIO::OCCTTool::Read(shape, INPUT_PATH_PREFIX\"NOTEXIST.brep\");\n\t\tCHECK(isReadSuccess == false);\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static bool Write(const TopoShape& s, const std::string& file, bool withTriangles, int format = 3)\t @return True if the output process is succeed\n\t @param format The format version\n\t @param withTriangles Determine whether writing the triangular mesh of the shape\n\t @param file The output file\n\t @param s The shape\n\t @brief Write a shape to a file\n,\n",
      "output": "#include <catch.hpp>\n#include<testHelper.h>\n#include <topology/TopoShape.hpp>\n#include <occtio/OCCTTool.hpp>\nstatic bool ComparisonFields(const std::string& file1, const std::string& file2, const std::string& fields)\n{\n\tifstream file1Stream(file1);\n\tifstream file2Stream(file2);\n\tif (file1Stream.is_open() == false || file2Stream.is_open() == false)\n\t{\n\t\tfile1Stream.close();\n\t\tfile2Stream.close();\n\t\treturn false;\n\t}\n\tstd::string line1, line2;\n\twhile (std::getline(file1Stream, line1))\n\t{\n\t\tif (line1.find(fields) != std::string::npos) break;\n\t}\n\twhile (std::getline(file2Stream, line2))\n\t{\n\t\tif (line2.find(fields) != std::string::npos) break;\n\t}\n\tfile1Stream.close();\n\tfile2Stream.close();\n\treturn line1 == line2;\n}\nTEST_CASE(\"CASE1:Check occtio read and write normal brep file function with different param \", \"[occtio][OCCTTool][p1][XXX]\") {\n\tAMCAX::TopoShape shape;\n\tbool isReadSuccess = AMCAX::OCCTIO::OCCTTool::Read(shape, INPUT_PATH_PREFIX\"occtio/occtio_read_I_brephaveMesh-case1.brep\");\n\tbool isWriteSuccess1f = AMCAX::OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f1-f-case1.brep\", false, 1);\n\tbool isWriteSuccess2f = AMCAX::OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f2-f-case1.brep\", false, 2);\n\tbool isWriteSuccess3f = AMCAX::OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f3-f-case1.brep\", false, 3);\n\tbool isWriteSuccess1t = AMCAX::OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f1-t-case1.brep\", true, 1);\n\tbool isWriteSuccess2t = AMCAX::OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f2-t-case1.brep\", true, 2);\n\tbool isWriteSuccess3t = AMCAX::OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f3-t-case1.brep\", true, 3);\n\tCHECK(isReadSuccess == true);\n\tCHECK(isWriteSuccess1f == true);\n\tCHECK(isWriteSuccess2f == true);\n\tCHECK(isWriteSuccess3f == true);\n\tCHECK(containsStringInFile(OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f1-f-case1.brep\", \"Triangulations 0\") == true);\n\tCHECK(containsStringInFile(OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f1-f-case1.brep\", \"CASCADE Topology V1, (c) Matra-Datavision\") == true);\n\tCHECK(containsStringInFile(OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f2-f-case1.brep\", \"Triangulations 0\") == true);\n\tCHECK(containsStringInFile(OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f2-f-case1.brep\", \"CASCADE Topology V2, (c) Matra-Datavision\") == true);\n\tCHECK(containsStringInFile(OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f3-f-case1.brep\", \"Triangulations 0\") == true);\n\tCHECK(containsStringInFile(OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f3-f-case1.brep\", \"CASCADE Topology V3, (c) Open Cascade\") == true);\n\tCHECK(isWriteSuccess1t == true);\n\tCHECK(isWriteSuccess2t == true);\n\tCHECK(isWriteSuccess3t == true);\n\tCHECK(containsStringInFile(OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f1-t-case1.brep\", \"Triangulations 0\") == false);\n\tCHECK(containsStringInFile(OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f1-t-case1.brep\", \"CASCADE Topology V1, (c) Matra-Datavision\") == true);\n\tCHECK(containsStringInFile(OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f2-t-case1.brep\", \"Triangulations 0\") == false);\n\tCHECK(containsStringInFile(OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f2-t-case1.brep\", \"CASCADE Topology V2, (c) Matra-Datavision\") == true);\n\tCHECK(containsStringInFile(OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f3-t-case1.brep\", \"Triangulations 0\") == false);\n\tCHECK(containsStringInFile(OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f3-t-case1.brep\", \"CASCADE Topology V3, (c) Open Cascade\") == true);\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static bool Write(const TopoShape& s, const std::string& file, int format = 3)\t @return True if the output process is succeed\n\t @param format The format version\n\t @param file The output file\n\t @param s The shape\n\t @brief Write a shape to a file\n,\n",
      "output": "#include <catch.hpp>\n#include<testHelper.h>\n#include <topology/TopoShape.hpp>\n#include <occtio/OCCTTool.hpp>\nstatic bool ComparisonFields(const std::string& file1, const std::string& file2, const std::string& fields)\n{\n\tifstream file1Stream(file1);\n\tifstream file2Stream(file2);\n\tif (file1Stream.is_open() == false || file2Stream.is_open() == false)\n\t{\n\t\tfile1Stream.close();\n\t\tfile2Stream.close();\n\t\treturn false;\n\t}\n\tstd::string line1, line2;\n\twhile (std::getline(file1Stream, line1))\n\t{\n\t\tif (line1.find(fields) != std::string::npos) break;\n\t}\n\twhile (std::getline(file2Stream, line2))\n\t{\n\t\tif (line2.find(fields) != std::string::npos) break;\n\t}\n\tfile1Stream.close();\n\tfile2Stream.close();\n\treturn line1 == line2;\n}\nTEST_CASE(\"CASE1:Check occtio read and write normal brep file function with different param \", \"[occtio][OCCTTool][p1][XXX]\") {\n\tAMCAX::TopoShape shape;\n\tbool isReadSuccess = AMCAX::OCCTIO::OCCTTool::Read(shape, INPUT_PATH_PREFIX\"occtio/occtio_read_I_brephaveMesh-case1.brep\");\n\tbool isWriteSuccess1f = AMCAX::OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f1-f-case1.brep\", false, 1);\n\tbool isWriteSuccess2f = AMCAX::OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f2-f-case1.brep\", false, 2);\n\tbool isWriteSuccess3f = AMCAX::OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f3-f-case1.brep\", false, 3);\n\tbool isWriteSuccess1t = AMCAX::OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f1-t-case1.brep\", true, 1);\n\tbool isWriteSuccess2t = AMCAX::OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f2-t-case1.brep\", true, 2);\n\tbool isWriteSuccess3t = AMCAX::OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f3-t-case1.brep\", true, 3);\n\tCHECK(isReadSuccess == true);\n\tCHECK(isWriteSuccess1f == true);\n\tCHECK(isWriteSuccess2f == true);\n\tCHECK(isWriteSuccess3f == true);\n\tCHECK(containsStringInFile(OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f1-f-case1.brep\", \"Triangulations 0\") == true);\n\tCHECK(containsStringInFile(OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f1-f-case1.brep\", \"CASCADE Topology V1, (c) Matra-Datavision\") == true);\n\tCHECK(containsStringInFile(OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f2-f-case1.brep\", \"Triangulations 0\") == true);\n\tCHECK(containsStringInFile(OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f2-f-case1.brep\", \"CASCADE Topology V2, (c) Matra-Datavision\") == true);\n\tCHECK(containsStringInFile(OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f3-f-case1.brep\", \"Triangulations 0\") == true);\n\tCHECK(containsStringInFile(OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f3-f-case1.brep\", \"CASCADE Topology V3, (c) Open Cascade\") == true);\n\tCHECK(isWriteSuccess1t == true);\n\tCHECK(isWriteSuccess2t == true);\n\tCHECK(isWriteSuccess3t == true);\n\tCHECK(containsStringInFile(OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f1-t-case1.brep\", \"Triangulations 0\") == false);\n\tCHECK(containsStringInFile(OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f1-t-case1.brep\", \"CASCADE Topology V1, (c) Matra-Datavision\") == true);\n\tCHECK(containsStringInFile(OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f2-t-case1.brep\", \"Triangulations 0\") == false);\n\tCHECK(containsStringInFile(OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f2-t-case1.brep\", \"CASCADE Topology V2, (c) Matra-Datavision\") == true);\n\tCHECK(containsStringInFile(OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f3-t-case1.brep\", \"Triangulations 0\") == false);\n\tCHECK(containsStringInFile(OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f3-t-case1.brep\", \"CASCADE Topology V3, (c) Open Cascade\") == true);\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static bool Write(const TopoShape& s, std::ostream& os, bool withTriangles, int format = 3)\t @return True if the output process is succeed\n\t @param[in] format The format version\n\t @param[in] withTriangles Determine whether writing the triangular mesh of the shape\n\t @param[in,out] os The output stream\n\t @param[in] s The shape\n\t @brief Wrtie a shape to a stream\n,\n",
      "output": "#include <catch.hpp>\n#include<testHelper.h>\n#include <topology/TopoShape.hpp>\n#include <occtio/OCCTTool.hpp>\nstatic bool ComparisonFields(const std::string& file1, const std::string& file2, const std::string& fields)\n{\n\tifstream file1Stream(file1);\n\tifstream file2Stream(file2);\n\tif (file1Stream.is_open() == false || file2Stream.is_open() == false)\n\t{\n\t\tfile1Stream.close();\n\t\tfile2Stream.close();\n\t\treturn false;\n\t}\n\tstd::string line1, line2;\n\twhile (std::getline(file1Stream, line1))\n\t{\n\t\tif (line1.find(fields) != std::string::npos) break;\n\t}\n\twhile (std::getline(file2Stream, line2))\n\t{\n\t\tif (line2.find(fields) != std::string::npos) break;\n\t}\n\tfile1Stream.close();\n\tfile2Stream.close();\n\treturn line1 == line2;\n}\nTEST_CASE(\"CASE1:Check occtio read and write normal brep file function with different param \", \"[occtio][OCCTTool][p1][XXX]\") {\n\tAMCAX::TopoShape shape;\n\tbool isReadSuccess = AMCAX::OCCTIO::OCCTTool::Read(shape, INPUT_PATH_PREFIX\"occtio/occtio_read_I_brephaveMesh-case1.brep\");\n\tbool isWriteSuccess1f = AMCAX::OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f1-f-case1.brep\", false, 1);\n\tbool isWriteSuccess2f = AMCAX::OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f2-f-case1.brep\", false, 2);\n\tbool isWriteSuccess3f = AMCAX::OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f3-f-case1.brep\", false, 3);\n\tbool isWriteSuccess1t = AMCAX::OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f1-t-case1.brep\", true, 1);\n\tbool isWriteSuccess2t = AMCAX::OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f2-t-case1.brep\", true, 2);\n\tbool isWriteSuccess3t = AMCAX::OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f3-t-case1.brep\", true, 3);\n\tCHECK(isReadSuccess == true);\n\tCHECK(isWriteSuccess1f == true);\n\tCHECK(isWriteSuccess2f == true);\n\tCHECK(isWriteSuccess3f == true);\n\tCHECK(containsStringInFile(OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f1-f-case1.brep\", \"Triangulations 0\") == true);\n\tCHECK(containsStringInFile(OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f1-f-case1.brep\", \"CASCADE Topology V1, (c) Matra-Datavision\") == true);\n\tCHECK(containsStringInFile(OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f2-f-case1.brep\", \"Triangulations 0\") == true);\n\tCHECK(containsStringInFile(OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f2-f-case1.brep\", \"CASCADE Topology V2, (c) Matra-Datavision\") == true);\n\tCHECK(containsStringInFile(OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f3-f-case1.brep\", \"Triangulations 0\") == true);\n\tCHECK(containsStringInFile(OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f3-f-case1.brep\", \"CASCADE Topology V3, (c) Open Cascade\") == true);\n\tCHECK(isWriteSuccess1t == true);\n\tCHECK(isWriteSuccess2t == true);\n\tCHECK(isWriteSuccess3t == true);\n\tCHECK(containsStringInFile(OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f1-t-case1.brep\", \"Triangulations 0\") == false);\n\tCHECK(containsStringInFile(OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f1-t-case1.brep\", \"CASCADE Topology V1, (c) Matra-Datavision\") == true);\n\tCHECK(containsStringInFile(OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f2-t-case1.brep\", \"Triangulations 0\") == false);\n\tCHECK(containsStringInFile(OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f2-t-case1.brep\", \"CASCADE Topology V2, (c) Matra-Datavision\") == true);\n\tCHECK(containsStringInFile(OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f3-t-case1.brep\", \"Triangulations 0\") == false);\n\tCHECK(containsStringInFile(OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f3-t-case1.brep\", \"CASCADE Topology V3, (c) Open Cascade\") == true);\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static bool Write(const TopoShape& s, std::ostream& os, int format = 3)\t @return True if the output process is succeed\n\t @param[in] format The format version\n\t @param[in,out] os The output stream\n\t @param[in] s The shape\n\t @brief Write a shape to a stream\n,\n",
      "output": "#include <catch.hpp>\n#include<testHelper.h>\n#include <topology/TopoShape.hpp>\n#include <occtio/OCCTTool.hpp>\nstatic bool ComparisonFields(const std::string& file1, const std::string& file2, const std::string& fields)\n{\n\tifstream file1Stream(file1);\n\tifstream file2Stream(file2);\n\tif (file1Stream.is_open() == false || file2Stream.is_open() == false)\n\t{\n\t\tfile1Stream.close();\n\t\tfile2Stream.close();\n\t\treturn false;\n\t}\n\tstd::string line1, line2;\n\twhile (std::getline(file1Stream, line1))\n\t{\n\t\tif (line1.find(fields) != std::string::npos) break;\n\t}\n\twhile (std::getline(file2Stream, line2))\n\t{\n\t\tif (line2.find(fields) != std::string::npos) break;\n\t}\n\tfile1Stream.close();\n\tfile2Stream.close();\n\treturn line1 == line2;\n}\nTEST_CASE(\"CASE1:Check occtio read and write normal brep file function with different param \", \"[occtio][OCCTTool][p1][XXX]\") {\n\tAMCAX::TopoShape shape;\n\tbool isReadSuccess = AMCAX::OCCTIO::OCCTTool::Read(shape, INPUT_PATH_PREFIX\"occtio/occtio_read_I_brephaveMesh-case1.brep\");\n\tbool isWriteSuccess1f = AMCAX::OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f1-f-case1.brep\", false, 1);\n\tbool isWriteSuccess2f = AMCAX::OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f2-f-case1.brep\", false, 2);\n\tbool isWriteSuccess3f = AMCAX::OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f3-f-case1.brep\", false, 3);\n\tbool isWriteSuccess1t = AMCAX::OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f1-t-case1.brep\", true, 1);\n\tbool isWriteSuccess2t = AMCAX::OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f2-t-case1.brep\", true, 2);\n\tbool isWriteSuccess3t = AMCAX::OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f3-t-case1.brep\", true, 3);\n\tCHECK(isReadSuccess == true);\n\tCHECK(isWriteSuccess1f == true);\n\tCHECK(isWriteSuccess2f == true);\n\tCHECK(isWriteSuccess3f == true);\n\tCHECK(containsStringInFile(OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f1-f-case1.brep\", \"Triangulations 0\") == true);\n\tCHECK(containsStringInFile(OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f1-f-case1.brep\", \"CASCADE Topology V1, (c) Matra-Datavision\") == true);\n\tCHECK(containsStringInFile(OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f2-f-case1.brep\", \"Triangulations 0\") == true);\n\tCHECK(containsStringInFile(OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f2-f-case1.brep\", \"CASCADE Topology V2, (c) Matra-Datavision\") == true);\n\tCHECK(containsStringInFile(OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f3-f-case1.brep\", \"Triangulations 0\") == true);\n\tCHECK(containsStringInFile(OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f3-f-case1.brep\", \"CASCADE Topology V3, (c) Open Cascade\") == true);\n\tCHECK(isWriteSuccess1t == true);\n\tCHECK(isWriteSuccess2t == true);\n\tCHECK(isWriteSuccess3t == true);\n\tCHECK(containsStringInFile(OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f1-t-case1.brep\", \"Triangulations 0\") == false);\n\tCHECK(containsStringInFile(OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f1-t-case1.brep\", \"CASCADE Topology V1, (c) Matra-Datavision\") == true);\n\tCHECK(containsStringInFile(OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f2-t-case1.brep\", \"Triangulations 0\") == false);\n\tCHECK(containsStringInFile(OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f2-t-case1.brep\", \"CASCADE Topology V2, (c) Matra-Datavision\") == true);\n\tCHECK(containsStringInFile(OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f3-t-case1.brep\", \"Triangulations 0\") == false);\n\tCHECK(containsStringInFile(OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f3-t-case1.brep\", \"CASCADE Topology V3, (c) Open Cascade\") == true);\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static bool Read(TopoShape& s, const std::string& file)\t @return True if the input process is succeed\n\t @param file The input file\n\t @param s The shape\n\t @brief Read a shape from a file\n,\n",
      "output": "#include <catch.hpp>\n#include<testHelper.h>\n#include <topology/TopoShape.hpp>\n#include <occtio/OCCTTool.hpp>\nstatic bool ComparisonFields(const std::string& file1, const std::string& file2, const std::string& fields)\n{\n\tifstream file1Stream(file1);\n\tifstream file2Stream(file2);\n\tif (file1Stream.is_open() == false || file2Stream.is_open() == false)\n\t{\n\t\tfile1Stream.close();\n\t\tfile2Stream.close();\n\t\treturn false;\n\t}\n\tstd::string line1, line2;\n\twhile (std::getline(file1Stream, line1))\n\t{\n\t\tif (line1.find(fields) != std::string::npos) break;\n\t}\n\twhile (std::getline(file2Stream, line2))\n\t{\n\t\tif (line2.find(fields) != std::string::npos) break;\n\t}\n\tfile1Stream.close();\n\tfile2Stream.close();\n\treturn line1 == line2;\n}\nTEST_CASE(\"CASE3:Check occio read not exist file \", \"[occtio][OCCTTool][p2]\") {\n\tAMCAX::TopoShape shape;\n\tSECTION(\"OCCTIO::OCCTTool::Read\") {\n\t\tbool isReadSuccess = AMCAX::OCCTIO::OCCTTool::Read(shape, INPUT_PATH_PREFIX\"NOTEXIST.brep\");\n\t\tCHECK(isReadSuccess == false);\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static TopoShape FixShape(const TopoShape& shape, double prec, double maxTol)\t @return Fixed Shape\n\t @param maxTol The global max tolerance used when the algorithm needs to check the tolerance\n\t @param prec The global precision used when the algorithm needs to check the precision\n\t @param shape Input shape\n\t @brief Try to repair the shape to a valid shape\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <healing/ShapeFixTool.hpp>\n#include <common/Precision.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"bug1: ShapeFixTool \", \"[healing][ShapeFixTool][fixbug]\") {\n\tAMCAX::TopoShape readshape;\n\tAMCAX::OCCTIO::OCCTTool::Read(readshape, INPUT_PATH_PREFIX\"FixShape-Crash.brep\");\n\treadshape = AMCAX::ShapeFixTool::FixShape(readshape, AMCAX::Precision::Confusion(), 1E-1);\n\tAMCAX::OCCTIO::OCCTTool::Write(readshape, OUTPUT_PATH_PREFIX\"ShapeFixTool_O_FixedShape.brep\");\n\tGlobalProperty prop;\n\tBRepGlobalProperty::VolumeProperties(readshape, prop);\n\tCHECK(prop.Mass() == Approx(16486799.3305680156).epsilon(1e-2));\n\tPoint3 vP = prop.CenterOfMass();\n\tCHECK(vP.X() == Approx(-260.8706721039).epsilon(1e-2));\n\tCHECK(vP.Y() == Approx(-154.6717940115).epsilon(1e-2));\n\tCHECK(vP.Z() == Approx(-0.1139512307).epsilon(1e-2));\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API explicit BRepFaceClassifier(const TopoFace& f)\t @param f The input face\n\t @brief Construct from the face to be processed\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <hatch/BRepFaceClassifier.hpp>\n#include <common/FrameT.hpp>\n#include <math/CircleT.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeWire.hpp>\n#include <modeling/MakeFace.hpp>\n#include <boolean/BoolBRepFuse.hpp>\n#include <common/IndexSet.hpp>\n#include <topology/TopoExplorerTool.hpp>\nusing namespace AMCAX;\nTopoFace WrenchFace()\n{\n\tFrame3 fm1(Point3(0., 0., 0.), Direction3(0., 0., 1.0));\n\tCircle3 c1 = Circle3(fm1, 2.);\n\tTopoEdge ec1 = MakeEdge(c1);\n\tTopoWire wc1 = MakeWire(ec1);\n\tTopoFace F1 = MakeFace(wc1);\n\tTopoEdge edge1 = MakeEdge(Point3(-4., -1.0, 0.0), Point3(4., -1.0, 0.0));\n\tTopoEdge edge2 = MakeEdge(Point3(4., -1.0, 0.0), Point3(4., 1.0, 0.0));\n\tTopoEdge edge3 = MakeEdge(Point3(4., 1.0, 0.0), Point3(-4., 1.0, 0.0));\n\tTopoEdge edge4 = MakeEdge(Point3(-4., 1.0, 0.0), Point3(-4., -1.0, 0.0));\n\tTopoWire wireR = MakeWire(edge1, edge2, edge3, edge4);\n\tTopoFace F3 = MakeFace(wireR);\n\tBoolBRepFuse fuse(F1, F3);\n\tfuse.Build();\n\tfuse.SimplifyResult();\n\tTopoShape res = fuse.Shape();\n\tIndexSet<TopoShape> resFaces;\n\tTopoExplorerTool::MapShapes(res, ShapeType::Face, resFaces);\n\tstd::cout << resFaces.size() << std::endl;\n\tTopoFace face = static_cast<const TopoFace&>(resFaces[0]);\n\treturn face;\n}\nbool ImpInWrenchFace(const Point2& pt)\n{\n\tbool isFaceIn1 = pt.X() * pt.X() + pt.Y() * pt.Y() < 2 * 2;\n\tbool isFaceIn2 = pt.X() > -4 && pt.X() < 4 && pt.Y() > -1 && pt.Y() < 1;\n\treturn isFaceIn1 || isFaceIn2;\n}\nPoint2 SampleMethodFace()\n{\n\tdouble x = (double)rand() / RAND_MAX * 10 - 5;\n\tdouble y = (double)rand() / RAND_MAX * 5 - 2.0;\n\treturn Point2(x, y);\n}\nTEST_CASE(\"case1: BRepFaceClassifier 3.6.0 added API. \", \"[hatch][BRepFaceClassifier][P1]\") {\n\t\tTopoFace face = WrenchFace();\n\t\tBRepFaceClassifier classify(face);\n\t\tint n = 10000;\n\t\tint inSize = 0, intime = 0, ontime = 0;\n\t\tfor (int i = 0; i < n; ++i)\n\t\t{\n\t\t\tPoint2 pt = SampleMethodFace();\n\t\t\tbool isIn = ImpInWrenchFace(pt);\n\t\t\tclassify.Perform(pt, Precision::Confusion());\n\t\t\tbool isCIn = classify.State() == StateType::In;\n\t\t\tbool isCon = classify.State() == StateType::On;\n\t\t\tif (isIn)\n\t\t\t{\n\t\t\t\tinSize++;\n\t\t\t\tif (isCIn)\n\t\t\t\t{\n\t\t\t\t\tintime++;\n\t\t\t\t}\n\t\t\t\tif (isCon)\n\t\t\t\t{\n\t\t\t\t\tontime++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tstd::cout << inSize << \" \" << intime << \" \" << ontime << std::endl;\n\t\tCHECK(inSize == (intime + ontime));\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static bool IsSolidBounded(const TopoSolid& s)\t @return True if the solid and the solid is bounded (The infinite point is outside);\n\t @param s The solid\n\t @brief Classify whether the solid is bounded (The infinite point is outside)\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <io/ShapeTool.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <topology/TopoShape.hpp>\n#include <topology/TopoSolid.hpp>\n#include <modeling/MakeSolid.hpp>\n#include <modeling/MakeCylinder.hpp>\n#include <boolean/BoolBRepFuse.hpp>\n#include <boolean/BoolBRepCut.hpp>\n#include <topomesh/BRepMeshIncrementalMesh.hpp>\n#include <io/OBJTool.hpp>\n#include <hatch/BRepSolidClassifier.hpp>\n#include <healing/ShapeFixTool.hpp>\nusing namespace AMCAX;\nbool ImpInSolid1(const Point3& pt)\n{\n\tPoint3 pc1(849.32865292949998, -105.60711735517, 528.53715478963011);\n\tCoord3 cs1 = pt.Coord() - pc1.Coord();\n\tbool isSolidIn1 = pt.Y() < 29.654882644830003 && pt.Y() > -105.60711735517 && (cs1.X() * cs1.X() + cs1.Z() * cs1.Z()) < 5.415 * 5.415;\n\tPoint3 pc2(849.32865292763006, 12.992882644829002, 528.53715479109997);\n\tCoord3 cs2 = pt.Coord() - pc2.Coord();\n\tbool isSolidIn2 = pt.Z() < 543.83715479110003 && pt.Z() > 528.53715479109997 && (cs2.X() * cs2.X() + cs2.Y() * cs2.Y()) < 5.415 * 5.415;\n\treturn isSolidIn1 || isSolidIn2;\n}\nPoint3 SampleMethodCircle1()\n{\n\tdouble u = (double)rand() / RAND_MAX * 4 - 0.5;\n\tdouble r = (double)rand() / RAND_MAX * 0.00002 + 5.41499;\n\tdouble x = 849.32865292949998 + r * std::cos(u);\n\tdouble z = 528.53715478963011 + r * std::sin(u);\n\tdouble y = (double)rand() / RAND_MAX * 136 - 106;\n\treturn Point3(x, y, z);\n}\nTEST_CASE(\"bug: BRepClassificationTools::IsSolidBounded  related :\", \"[hatch][BRepClassificationTools][fixbug]\") {\n\tAMCAX::TopoShape readshape;\n\tbool readstatus = AMCAX::OCCTIO::OCCTTool::Read(readshape, INPUT_PATH_PREFIX\"0000-beforeFixShape.brep\");\n\tCHECK(readstatus == true);\n\treadshape = AMCAX::ShapeFixTool::FixShape(readshape, AMCAX::Precision::Confusion(), 1E-1);\n\tAMCAX::TopoSolid readsolid = AMCAX::MakeSolid(AMCAX::TopoCast::Shell(readshape));\n\tCHECK(AMCAX::BRepClassificationTools::IsSolidBounded(readsolid) == true);\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API MakeGeom3Ellipse(const Point3& s1, const Point3& s2, const Point3& center)\t @param center The center point\n\t @param s2 The point on the minor axis\n\t @param s1 The point on the major axis\n\t @brief Construct an ellipse from two points on the major and minor axis, and a center point\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/MakeGeom3Ellipse.hpp>\n#include <common/DirectionT.hpp>\n#include <common/PointT.hpp>\n#include <common/Precision.hpp>\n#include <topology/TopoEdge.hpp>\n#include <topology/TopoWire.hpp>\n#include <topology/TopoFace.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeWire.hpp>\n#include <modeling/MakeFace.hpp>\n#include <modeling/MakePrism.hpp>\n#include <topomesh/BRepMeshIncrementalMesh.hpp>\n#include <topology/TopoExplorerTool.hpp>\n#include <topology/TopoExplorer.hpp>\n#include <topology/TopoCast.hpp>\n#include <topology/TopoTool.hpp>\n#include <math/TriangularMesh.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"bug1: MakeGeom3Ellipse \", \"[geometry][MakeGeom3Ellipse][fixbug]\") {\n\tMakeGeom3Ellipse makeEllipse(Frame3(), 3.0, 1.0);\n\tstd::shared_ptr<Geom3Curve> curve = makeEllipse.Value();\n\tTopoEdge e = MakeEdge(curve);\n\tTopoWire w = MakeWire(e);\n\tTopoFace f = MakeFace(w);\n\tTopoShape s = MakePrism(f, Vector3(0.0, 0.0, 1.0));\n\tBRepMeshIncrementalMesh mesher(s, 0.005, true);\n\tint counttest = 0;\n\tfor (TopoExplorer ex(s, ShapeType::Face); ex.More(); ex.Next())\n\t{\n\t\tconst auto& face = TopoCast::Face(ex.Current());\n\t\tTopoLocation l;\n\t\tauto tri = TopoTool::Triangulation(face, l);\n\t\tCHECK(tri); \n\t\tif (tri)\n\t\t{\n\t\t\tcounttest = counttest + 1;\n\t\t\tif (counttest == 1)\n\t\t\t{\n\t\t\t\tCHECK(tri->NVertices() == 84);\n\t\t\t\tCHECK(tri->NTriangles() == 82);\n\t\t\t}\n\t\t\tif (counttest == 2)\n\t\t\t{\n\t\t\t\tCHECK(tri->NVertices() == 41);\n\t\t\t\tCHECK(tri->NTriangles() == 39);\n\t\t\t}\n\t\t\tif (counttest == 3)\n\t\t\t{\n\t\t\t\tCHECK(tri->NVertices() == 41);\n\t\t\t\tCHECK(tri->NTriangles() == 39);\n\t\t\t}\n\t\t}\n\t}\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API MakeGeom3Ellipse(const Frame3& frame, double majorRadius, double minorRadius)\t @param minorRadius The minor radius\n\t @param majorRadius The major radius\n\t @param frame The local frame\n\t @brief Construct an ellipse from a local frame, a major radius and a minor radius\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/MakeGeom3Ellipse.hpp>\n#include <common/DirectionT.hpp>\n#include <common/PointT.hpp>\n#include <common/Precision.hpp>\n#include <topology/TopoEdge.hpp>\n#include <topology/TopoWire.hpp>\n#include <topology/TopoFace.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeWire.hpp>\n#include <modeling/MakeFace.hpp>\n#include <modeling/MakePrism.hpp>\n#include <topomesh/BRepMeshIncrementalMesh.hpp>\n#include <topology/TopoExplorerTool.hpp>\n#include <topology/TopoExplorer.hpp>\n#include <topology/TopoCast.hpp>\n#include <topology/TopoTool.hpp>\n#include <math/TriangularMesh.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"bug1: MakeGeom3Ellipse \", \"[geometry][MakeGeom3Ellipse][fixbug]\") {\n\tMakeGeom3Ellipse makeEllipse(Frame3(), 3.0, 1.0);\n\tstd::shared_ptr<Geom3Curve> curve = makeEllipse.Value();\n\tTopoEdge e = MakeEdge(curve);\n\tTopoWire w = MakeWire(e);\n\tTopoFace f = MakeFace(w);\n\tTopoShape s = MakePrism(f, Vector3(0.0, 0.0, 1.0));\n\tBRepMeshIncrementalMesh mesher(s, 0.005, true);\n\tint counttest = 0;\n\tfor (TopoExplorer ex(s, ShapeType::Face); ex.More(); ex.Next())\n\t{\n\t\tconst auto& face = TopoCast::Face(ex.Current());\n\t\tTopoLocation l;\n\t\tauto tri = TopoTool::Triangulation(face, l);\n\t\tCHECK(tri); \n\t\tif (tri)\n\t\t{\n\t\t\tcounttest = counttest + 1;\n\t\t\tif (counttest == 1)\n\t\t\t{\n\t\t\t\tCHECK(tri->NVertices() == 84);\n\t\t\t\tCHECK(tri->NTriangles() == 82);\n\t\t\t}\n\t\t\tif (counttest == 2)\n\t\t\t{\n\t\t\t\tCHECK(tri->NVertices() == 41);\n\t\t\t\tCHECK(tri->NTriangles() == 39);\n\t\t\t}\n\t\t\tif (counttest == 3)\n\t\t\t{\n\t\t\t\tCHECK(tri->NVertices() == 41);\n\t\t\t\tCHECK(tri->NTriangles() == 39);\n\t\t\t}\n\t\t}\n\t}\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API MakeArcOfCircle2d(const Point2& p1, const Vector2& v, const Point2& p2)\t @param p2 The end point\n\t @param v The tangent vector at p1\n\t @param p1 The start point\n\t @brief Construct an arc of circle from two points p1, p2 and a tangent vector v at p1\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <common/VectorT.hpp>\n#include <common/PointT.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/MakeArcOfCircle2d.hpp>\n#include <sstream>\nusing namespace AMCAX;\nTEST_CASE(\"bug1: MakeArcOfCircle2d  add 1 cases\", \"[geomAlgo][MakeArcOfCircle2d][fixbug]\") {\n\tstd::stringstream output;\n\tstd::shared_ptr<Geom2TrimmedCurve> c = MakeArcOfCircle2d(Point2(0.0, 1.0), Vector2(1.0, 0.0), Point2(1.0, 0.0));\n\tstd::cout << *c << std::endl;\n\toutput << *c << std::endl;\n\tauto case1 = output.str();\n\tauto expect1 = \"8 4.71239 6.28319\";\n\tauto expect2 = \"2 0 -0 1 0 0 -1 1\";\n\tCHECK(case1.find(expect1) != std::string::npos);\n\tCHECK(case1.find(expect2) != std::string::npos);\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static bool IsPlanarCurve(const std::shared_ptr<Geom3Curve>& c, Plane& plane, double tol = 1.0e-7)\t @return True if the curve is a planar curve\n\t @param tol The tolerance\n\t @param plane The plane found when the curve is planar curve\n\t @param c The input curve\n\t @details If the input curve, such as a line, is on more than one plane, it will return the plane in which any one is located\n\t @brief Check if a 3D curve is a planar curve, and if it is planar, find the plane\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/Geom2BezierCurve.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/MakeArcOfCircle2d.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <modeling/MakeEdge.hpp>\n#include<modeling/MakeEdge2d.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\n#include <geometry/Geom3Circle.hpp>\nusing namespace AMCAX;\nstd::shared_ptr<Geom2BezierCurve> MakeBezierCurve2d()\n{\n\tstd::vector<Point2> poles(4);\n\tpoles[0].SetCoord(1.0, 0.0);\n\tpoles[1].SetCoord(2.0, 1.0);\n\tpoles[2].SetCoord(3.0, -1.0);\n\tpoles[3].SetCoord(4.0, 0.0);\n\treturn std::make_shared<Geom2BezierCurve>(poles);\n}\nstd::shared_ptr<Geom2BSplineCurve> MakeBSplineCurve2d()\n{\n\tstd::vector<Point2> poles(7);\n\tpoles[0].SetCoord(0.5, 0.5);\n\tpoles[1].SetCoord(1.0, 3.0);\n\tpoles[2].SetCoord(3.0, 1.0);\n\tpoles[3].SetCoord(3.8, 2.0);\n\tpoles[4].SetCoord(2.5, 3.5);\n\tpoles[5].SetCoord(1.0, 0.5);\n\tpoles[6].SetCoord(0.3, 2.0);\n\tstd::vector<double> knots = { 0.0, 0.25, 0.5, 0.75, 1.0 };\n\tstd::vector<int> mults = { 4, 1, 1, 1, 4 };\n\treturn std::make_shared<Geom2BSplineCurve>(poles, knots, mults, 3);\n}\nstd::shared_ptr<Geom3BSplineCurve> MakeBSplineCurve3d(int degree, bool rational)\n{\n\tif (degree == 3)\n\t{\n\t\tstd::vector<Point3> poles(7);\n\t\tpoles[0].SetCoord(0.5, 0.5, 0.3);\n\t\tpoles[1].SetCoord(1.0, 3.0, 0.4);\n\t\tpoles[2].SetCoord(3.0, 1.0, 0.1);\n\t\tpoles[3].SetCoord(3.8, 2.0, 0.6);\n\t\tpoles[4].SetCoord(2.5, 3.5, 0.8);\n\t\tpoles[5].SetCoord(1.0, 0.5, 0.9);\n\t\tpoles[6].SetCoord(0.3, 2.0, 0.5);\n\t\tstd::vector<double> weights = { 1.0, 2.0, 3.0, 4.0, 3.0, 2.0, 1.0 };\n\t\tstd::vector<double> knots = { 0.0, 0.25, 0.5, 1.0 };\n\t\tstd::vector<int> mults = { 4, 1, 2, 4 };\n\t\treturn rational ? std::make_shared<Geom3BSplineCurve>(poles, weights, knots, mults, 3)\n\t\t\t: std::make_shared<Geom3BSplineCurve>(poles, knots, mults, 3);\n\t}\n\telse if (degree == 2)\n\t{\n\t\tstd::vector<Point3> poles(6);\n\t\tpoles[0].SetCoord(0.5, 0.5, 0.3);\n\t\tpoles[1].SetCoord(1.0, 3.0, 0.4);\n\t\tpoles[2].SetCoord(3.0, 1.0, 0.1);\n\t\tpoles[3].SetCoord(3.8, 2.0, 0.6);\n\t\tpoles[4].SetCoord(2.5, 3.5, 0.8);\n\t\tpoles[5].SetCoord(1.0, 0.5, 0.9);\n\t\tstd::vector<double> weights = { 1.0, 2.0, 3.0, 4.0, 3.0, 2.0 };\n\t\tstd::vector<double> knots = { 0.0, 0.25, 0.5, 1.0 };\n\t\tstd::vector<int> mults = { 3, 1, 2, 3 };\n\t\treturn rational ? std::make_shared<Geom3BSplineCurve>(poles, weights, knots, mults, 2)\n\t\t\t: std::make_shared<Geom3BSplineCurve>(poles, knots, mults, 2);\n\t}\n\treturn nullptr;\n}\nTEST_CASE(\"case2: IsPlanarCurve dev case \", \"[geometry][IsPlanarCurve][P1]\")\n{\n\tshared_ptr<Geom3BSplineCurve> curve3 = MakeBSplineCurve3d(3,true) ;\n\tPlane plane;\n\tCHECK(GeometryTool::IsPlanarCurve(curve3, plane) == false);\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API explicit GeomAPIIntCurveCurve2(const std::shared_ptr<Geom2Curve>& c1, double tol = 1.0e-6)\t @param tol The tolerance for computing self-intersection\n\t @param c1 The curve\n\t @brief Construct from one curve for finding self-intersections\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <sstream>\n#include <geometry/GeomAPIIntCurveCurve2.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <common/PointT.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"bug1: GeomAPIIntCurveCurve2  add 1 cases\", \"[geometry][GeomAPIIntCurveCurve2][fixbug]\") {\n\tstd::shared_ptr<Geom2BSplineCurve> bs1 = std::make_shared<Geom2BSplineCurve>();\n\tstd::shared_ptr<Geom2BSplineCurve> bs2 = std::make_shared<Geom2BSplineCurve>();\n\tstd::string str1 = \"7 0 0 3 118 116 0.32094859236148043 1.01737460557672743 0.32206087674542322 1.01734745284654182 0.32382938579023346 1.01745552974970388 0.32622057752030481 1.01788932455950976 0.32814024437537276 1.01839643017089987 0.33002743385020250 1.01906060903165452 0.33185490242395432 1.01986927403602690 0.33356030574937923 1.02078382513330879 0.33505523022905437 1.02172426942215600 0.33630356053380972 1.02261635998227951 0.33727879099865676 1.02338700329485177 0.33824387261988464 1.02421002336103761 0.33987143181385676 1.02571995716873454 0.34214827935107528 1.02826048315421636 0.34461603767621785 1.03183954355064644 0.34665036808905569 1.03570920433382874 0.34820760193471290 1.03964073803085988 0.34933771881337422 1.04355887677937265 0.35009685624211401 1.04745091431990089 0.35052967495496640 1.05132419100513896 0.35066857936404372 1.05518894219017056 0.35052557522962369 1.05904245911643380 0.35008366013718967 1.06287636600114777 0.34929841370764381 1.06667869354746858 0.34813822094610908 1.07042299939338448 0.34675750395147792 1.07412664136932645 0.34534310541281921 1.07786690172476352 0.34358161112094421 1.08147777823012681 0.34192774635989071 1.08514486567176727 0.34024883979957521 1.08877932697709046 0.33856258005747963 1.09239630776272234 0.33684922584157972 1.09599070530577980 0.33511401239025801 1.09956576491048708 0.33335775759028152 1.10312101734871382 0.33158157690922768 1.10665621463276231 0.32978475270252700 1.11017051339371275 0.32796684236813672 1.11366345386663435 0.32612725706778090 1.11713471339148707 0.32426602655273468 1.12058421069008607 0.32238317488364737 1.12401188835076016 0.32047891905305792 1.12741748347385329 0.31855350786840358 1.13080068581386772 0.31660697714151498 1.13416123619352938 0.31463922025518198 1.13749923563291944 0.31264987984545162 1.14081514934997053 0.31063848196500760 1.14410959402646872 0.30860463164217128 1.14738321401338195 0.30654793927361806 1.15063653610177630 0.30446802732993405 1.15386990664646771 0.30236451953097970 1.15708359051903131 0.30023708628717172 1.16027763956461594 0.29808538476977109 1.16345202237806822 0.29590934129126883 1.16660648017917135 0.29370889405197392 1.16974079885919968 0.29148391413490155 1.17285470277829651 0.28923416621699150 1.17594813233618023 0.28695938621068906 1.17902112690429606 0.28465933895561080 1.18207371247860404 0.28233386645185193 1.18510589143436862 0.27998289479713001 1.18811761370470093 0.27760632123816548 1.19110879993250829 0.27520390350264767 1.19407947381928281 0.27277523052158237 1.19702979458848002 0.27031974327907626 1.19995999134850062 0.26783696716142708 1.20287004707951173 0.26532688195672521 1.20575953789980805 0.26278972678816304 1.20862781671414088 0.26022529469643624 1.21147474893699236 0.25763217763048496 1.21430150477218790 0.25500825126397131 1.21710994249041904 0.25235292985377017 1.21990005059103868 0.24966926670272568 1.22266796329330352 0.24696150391975732 1.22540882939352413 0.24423004526152650 1.22812190210150329 0.24146125706394184 1.23081996151861128 0.23861784080316129 1.23353765899792966 0.23566141121739081 1.23630795850379083 0.23313267974624646 1.23863075403103817 0.23108077081313610 1.24048682151979905 0.22951564660225790 1.24188808346222479 0.22785243018268259 1.24336238482365724 0.22603998536410663 1.24495322387069107 0.22406854105345719 1.24666425686480453 0.22194392374121000 1.24848570059305053 0.21966929759239204 1.25041206987825992 0.21725182330646176 1.25242961584586521 0.21469769930661789 1.25453321201678158 0.21201305169290471 1.25670455099802481 0.20919423964305814 1.25892740388225111 0.20624946264626334 1.26119206481064094 0.20318480037069683 1.26348679862854585 0.20000837020587425 1.26579929017010295 0.19672786860887337 1.26811801505294564 0.19336384906039994 1.27045063232052602 0.18992974310269095 1.27279484301208434 0.18643645229630731 1.27514361933883413 0.18288284026026952 1.27747988214753017 0.17926432420455884 1.27979154638979287 0.17557650128119320 1.28206361390544510 0.17182058886568480 1.28428512148975549 0.16804984196678602 1.28645557821983747 0.16432856924206579 1.28857394891545374 0.16070988708733733 1.29064090195652370 0.15717518220101778 1.29262871928824441 0.15369583278895632 1.29452720045016001 0.15026398879500619 1.29632707889676935 0.14689767435611573 1.29803910611286755 0.14368667318979397 1.29963940415365520 0.14066793270237543 1.30110806215344477 0.13786588940702740 1.30241800503027294 0.13522308508227587 1.30359724798135068 0.13268958893136670 1.30462396744174369 0.13022457745464813 1.30549794019590903 0.12782549497702861 1.30621459673763263 0.12551678736811231 1.30677267551026310 0.12264034969535306 1.30729452653584777 0.12051776185100731 1.30747541630908004 0.11912669923861925 1.30748468412943986 0.00000000000000000 4 0.00332678777314067 1 0.00530015559541836 1 0.00728182036673812 1 0.00927733380420748 1 0.01129573787307914 1 0.01327102124276026 1 0.01507750651120846 1 0.01659037664031113 1 0.01787187841143642 1 0.01880519345805253 1 0.02039488120903255 1 0.02452963651417061 1 0.02900897063209700 1 0.03340295596517878 1 0.03761684169382203 1 0.04167362563339645 1 0.04561938121714045 1 0.04949884613367380 1 0.05335394957604591 1 0.05721079085185987 1 0.06105670932975029 1 0.06491896046411526 1 0.06884011522460366 1 0.07280266881291077 1 0.07677853454115921 1 0.08082727159450992 1 0.08484703393156430 1 0.08884800850224144 1 0.09283736315162679 1 0.09681928451811667 1 0.10079344442245329 1 0.10475903456581770 1 0.10871533221895527 1 0.11266230101625047 1 0.11659995734938959 1 0.12052830686968952 1 0.12444792190998373 1 0.12835862681996368 1 0.13226049935437312 1 0.13615329767464079 1 0.14003667398886835 1 0.14391115976349200 1 0.14777767334262687 1 0.15163719748113480 1 0.15549084375107922 1 0.15933948557025243 1 0.16318380109489106 1 0.16702443368061037 1 0.17086206197732215 1 0.17469676853931951 1 0.17852903287965541 1 0.18235853795986209 1 0.18618547107174704 1 0.19001029311391093 1 0.19383342115543040 1 0.19765535049879729 1 0.20147647336026475 1 0.20529702393677510 1 0.20911722784810613 1 0.21293746918119616 1 0.21675849605951392 1 0.22058118324198547 1 0.22440637655431431 1 0.22823412013034025 1 0.23206350223258385 1 0.23589437276278422 1 0.23972883230279066 1 0.24357130772232163 1 0.24742464110863499 1 0.25128370603023881 1 0.25513705909052109 1 0.25898297113943686 1 0.26283319300761221 1 0.26673478756179048 1 0.27078270046115210 1 0.27498764230925066 1 0.27703550353465400 1 0.27908314380440813 1 0.28128986356810332 1 0.28370321223532124 1 0.28631785618959721 1 0.28912103899968400 1 0.29209869219406109 1 0.29526001444575162 1 0.29856723628509552 1 0.30202524340776099 1 0.30561830049238314 1 0.30933640124059564 1 0.31316962603536763 1 0.31710368845632919 1 0.32112310784334058 1 0.32522104893482329 1 0.32938444032265624 1 0.33359681084096160 1 0.33784938027078792 1 0.34214253792603233 1 0.34647801531348960 1 0.35084331838884097 1 0.35523312810758656 1 0.35953028089402317 1 0.36368926465670970 1 0.36773529430744634 1 0.37169603595072809 1 0.37557957415417503 1 0.37936041511409840 1 0.38302581855344769 1 0.38634253837102683 1 0.38943124796238249 1 0.39230486518080748 1 0.39502350628500010 1 0.39762992993310575 1 0.40014797436892702 1 0.40253156052235123 1 0.40475213727501114 1 0.40891189273334161 4\";\n\tstd::string str2 = \"7 0 0 3 118 116 0.44698587761425512 1.01737460557672743 0.44586770461012754 1.01734792256404072 0.44408669680926910 1.01745649198371058 0.44167433575859827 1.01788973448550668 0.43973012306214176 1.01839676158274872 0.43781512528503469 1.01906078430998237 0.43595772107855257 1.01986941991017832 0.43422167753434071 1.02078367982801188 0.43270019179331992 1.02172276730688871 0.43143529102668837 1.02260881639260637 0.43047395316133663 1.02337915724656336 0.42956918011417972 1.02417518983407696 0.42818486699350283 1.02596609318184684 0.42535867595845256 1.02808829688484948 0.42284370487027889 1.03193726498772675 0.42029420450207700 1.03578860458891087 0.41779215915839102 1.03971518009696795 0.41524996629274769 1.04360952276868124 0.41268259846706867 1.04748256529635642 0.41009244215779894 1.05134004607881448 0.40748344575385259 1.05519270420095079 0.40486605902395167 1.05904184662506151 0.40221826431976609 1.06286057810161427 0.39954731386633807 1.06664354970287856 0.39685998643058945 1.07039722937908555 0.39415205518567858 1.07412233241535748 0.39142459506816268 1.07782095032413006 0.38867831705369166 1.08149595009323263 0.38591346143208760 1.08514964980580220 0.38313020259072789 1.08878346979564511 0.38032844124366111 1.09239780218286464 0.37750825751929029 1.09599269297900204 0.37466975732311525 1.09956803650327561 0.37181298113969291 1.10312349001628252 0.36893792871143949 1.10665859650325404 0.36604460396156768 1.11017278012274700 0.36313313466979064 1.11366550770546358 0.36020385654578302 1.11713665503127646 0.35725711512561398 1.12058603617284369 0.35429324377611354 1.12401373368655166 0.35131230158758986 1.12741939957610104 0.34831421468687968 1.13080262402140796 0.34529890614255510 1.13416313676223202 0.34226629246633017 1.13750078799254517 0.33921704684458587 1.14081632451049253 0.33615179652790328 1.14411040925898311 0.33307117902797256 1.14738370759211961 0.32997572188237095 1.15063676015840910 0.32686583766548316 1.15386986351118148 0.32374192911050353 1.15708326206532552 0.32060452465855971 1.16027718535470581 0.31745360371300196 1.16345153388182476 0.31428913900094868 1.16660594252951411 0.31111112410899561 1.16974020701489989 0.30791955045097874 1.17285394667146026 0.30471460628308072 1.17594719675858417 0.30149648916692096 1.17901999285247383 0.29826547554743049 1.18207244366664344 0.29502169193428479 1.18510458595828827 0.29176503889034477 1.18811625270052801 0.28849545711393992 1.19110735246150123 0.28521287446926513 1.19407776448826497 0.28191760121088905 1.19702778959143030 0.27860991172799571 1.19995767798350750 0.27529017147185769 1.20286775332443230 0.27195821134041676 1.20575742910935957 0.26861365400632170 1.20862591999664737 0.26525581006410243 1.21147208574228693 0.26188571532285843 1.21429744804454320 0.25850537979441068 1.21710464921168948 0.25511712957007160 1.21989678109210420 0.25171762413613974 1.22266823849310202 0.24830072265899519 1.22540963473078257 0.24486605329372579 1.22811942696225307 0.24141572018592131 1.23080424790172627 0.23796057988059283 1.23349025995382422 0.23455481289528443 1.23625809731511249 0.23178384866187560 1.23861884218329443 0.22958637070091326 1.24049429822100898 0.22792095077852323 1.24183892665189632 0.22633085712869647 1.24330474335321250 0.22482706539293790 1.24489950308425112 0.22341229813088337 1.24661390687506479 0.22209453169097026 1.24843902517094874 0.22087888937927413 1.25036828651214238 0.21977124333451431 1.25238938953827761 0.21877814583739183 1.25449449573067429 0.21790282053379528 1.25666553458695951 0.21714464814126716 1.25889056843647418 0.21650897231276728 1.26115706505645897 0.21599821380382661 1.26345359947659142 0.21561431786668875 1.26576891766763566 0.21535790133274418 1.26809712034575073 0.21523156999800702 1.27043621478677027 0.21523493789335055 1.27278382859372918 0.21536761702246404 1.27513094567987695 0.21562960091705158 1.27746540211106607 0.21601986302685286 1.27977480962963663 0.21653701136757098 1.28204820066314440 0.21718164535537912 1.28428355977126407 0.21795318927362628 1.28647141444648527 0.21885182671844836 1.28860254299760535 0.21987018385314080 1.29066214545958857 0.22100473503305496 1.29264388729952517 0.22225426990375063 1.29454179066819441 0.22361918358992602 1.29635228361390098 0.22510542017288909 1.29807648877092108 0.22668582626421535 1.29967791748795536 0.22833572049978873 1.30113992652563426 0.23002054288496601 1.30245118636949164 0.23175614453859494 1.30361712921158590 0.23353904515484103 1.30463669825309792 0.23536790944712538 1.30550821214031298 0.23723013129137352 1.30622515706156905 0.23909802022459714 1.30677963590280544 0.24158931746901185 1.30731428646199599 0.24348144169383945 1.30748511863814065 0.24475247407226391 1.30748468412943986 0.00000000000000000 4 0.00334434293035562 1 0.00533825930397336 1 0.00734412586267121 1 0.00936623440575543 1 0.01141256205459959 1 0.01341573096600146 1 0.01524709020284723 1 0.01677336277701813 1 0.01804490068923616 1 0.01894326352103789 1 0.02037993823386658 1 0.02480566898074880 1 0.02939205655814846 1 0.03404043378943207 1 0.03869805978018042 1 0.04334980332413108 1 0.04799487443159717 1 0.05263737365801836 1 0.05728913631958347 1 0.06195364423015201 1 0.06660152728460191 1 0.07122956329812886 1 0.07584610283920201 1 0.08045084571229059 1 0.08504550471877484 1 0.08963256787874113 1 0.09421407873103112 1 0.09879117107574811 1 0.10336422781387057 1 0.10793330889559200 1 0.11249839490034602 1 0.11705945929549585 1 0.12161613091223618 1 0.12616821278487000 1 0.13071541215010135 1 0.13525724181627602 1 0.13979405378099050 1 0.14432538686178745 1 0.14885137954117900 1 0.15337193703905613 1 0.15788673904588241 1 0.16239626042792893 1 0.16690070771036525 1 0.17140021344792761 1 0.17589510396468730 1 0.18038552504431565 1 0.18487151865902063 1 0.18935308684053462 1 0.19383026236900400 1 0.19830276789454376 1 0.20277103974370816 1 0.20723457084840083 1 0.21169339151646616 1 0.21614758290681596 1 0.22059709488399620 1 0.22504193032631326 1 0.22948214264998190 1 0.23391784916535033 1 0.23834913245589026 1 0.24277612072013041 1 0.24719890919114179 1 0.25161757662768108 1 0.25603221057958453 1 0.26044282613505232 1 0.26484890217770901 1 0.26925063819864326 1 0.27364813118187725 1 0.27804209715833189 1 0.28243253716855193 1 0.28681951085634216 1 0.29120020890283443 1 0.29557446914500052 1 0.29994411461100146 1 0.30431579875993647 1 0.30870332268475420 1 0.31310853612917888 1 0.31523624508228770 1 0.31737014111002310 1 0.31952856178681960 1 0.32171830465981011 1 0.32394102970905830 1 0.32619217521253946 1 0.32846706602101300 1 0.33077763413829298 1 0.33310205916533187 1 0.33544576479270716 1 0.33779655322040053 1 0.34015052354015518 1 0.34250407705161767 1 0.34485099381932000 1 0.34718783135835085 1 0.34952735554083242 1 0.35187486439618521 1 0.35422711580943594 1 0.35657637606518838 1 0.35891858548088795 1 0.36124990679045155 1 0.36356703547085450 1 0.36589411785453302 1 0.36820554269186456 1 0.37050138589761700 1 0.37278277874756854 1 0.37505181955993466 1 0.37731379776658153 1 0.37958010527703534 1 0.38187591368213569 1 0.38405827564667433 1 0.38618898795548318 1 0.38827607822097537 1 0.39032555279796965 1 0.39234499730597777 1 0.39434796008648582 1 0.39630575790533801 1 0.39818438284552959 1 0.40198436891082029 4\";\n\tstd::istringstream iss1(str1);\n\tstd::istringstream iss2(str2);\n\tiss1 >> *bs1;\n\tiss2 >> *bs2;\n\tGeomAPIIntCurveCurve2 icc(bs1, bs2, 1e-12);\n\tCHECK(icc.NPoints() == 2);\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API GeomAPIIntCurveCurve2(const std::shared_ptr<Geom2Curve>& c1, const std::shared_ptr<Geom2Curve>& c2, double tol = 1.0e-6)\t @param tol The tolerance for computing intersection\n\t @param c2 The second curve\n\t @param c1 The first curve\n\t @brief Construct from two curves\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <sstream>\n#include <geometry/GeomAPIIntCurveCurve2.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <common/PointT.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"bug1: GeomAPIIntCurveCurve2  add 1 cases\", \"[geometry][GeomAPIIntCurveCurve2][fixbug]\") {\n\tstd::shared_ptr<Geom2BSplineCurve> bs1 = std::make_shared<Geom2BSplineCurve>();\n\tstd::shared_ptr<Geom2BSplineCurve> bs2 = std::make_shared<Geom2BSplineCurve>();\n\tstd::string str1 = \"7 0 0 3 118 116 0.32094859236148043 1.01737460557672743 0.32206087674542322 1.01734745284654182 0.32382938579023346 1.01745552974970388 0.32622057752030481 1.01788932455950976 0.32814024437537276 1.01839643017089987 0.33002743385020250 1.01906060903165452 0.33185490242395432 1.01986927403602690 0.33356030574937923 1.02078382513330879 0.33505523022905437 1.02172426942215600 0.33630356053380972 1.02261635998227951 0.33727879099865676 1.02338700329485177 0.33824387261988464 1.02421002336103761 0.33987143181385676 1.02571995716873454 0.34214827935107528 1.02826048315421636 0.34461603767621785 1.03183954355064644 0.34665036808905569 1.03570920433382874 0.34820760193471290 1.03964073803085988 0.34933771881337422 1.04355887677937265 0.35009685624211401 1.04745091431990089 0.35052967495496640 1.05132419100513896 0.35066857936404372 1.05518894219017056 0.35052557522962369 1.05904245911643380 0.35008366013718967 1.06287636600114777 0.34929841370764381 1.06667869354746858 0.34813822094610908 1.07042299939338448 0.34675750395147792 1.07412664136932645 0.34534310541281921 1.07786690172476352 0.34358161112094421 1.08147777823012681 0.34192774635989071 1.08514486567176727 0.34024883979957521 1.08877932697709046 0.33856258005747963 1.09239630776272234 0.33684922584157972 1.09599070530577980 0.33511401239025801 1.09956576491048708 0.33335775759028152 1.10312101734871382 0.33158157690922768 1.10665621463276231 0.32978475270252700 1.11017051339371275 0.32796684236813672 1.11366345386663435 0.32612725706778090 1.11713471339148707 0.32426602655273468 1.12058421069008607 0.32238317488364737 1.12401188835076016 0.32047891905305792 1.12741748347385329 0.31855350786840358 1.13080068581386772 0.31660697714151498 1.13416123619352938 0.31463922025518198 1.13749923563291944 0.31264987984545162 1.14081514934997053 0.31063848196500760 1.14410959402646872 0.30860463164217128 1.14738321401338195 0.30654793927361806 1.15063653610177630 0.30446802732993405 1.15386990664646771 0.30236451953097970 1.15708359051903131 0.30023708628717172 1.16027763956461594 0.29808538476977109 1.16345202237806822 0.29590934129126883 1.16660648017917135 0.29370889405197392 1.16974079885919968 0.29148391413490155 1.17285470277829651 0.28923416621699150 1.17594813233618023 0.28695938621068906 1.17902112690429606 0.28465933895561080 1.18207371247860404 0.28233386645185193 1.18510589143436862 0.27998289479713001 1.18811761370470093 0.27760632123816548 1.19110879993250829 0.27520390350264767 1.19407947381928281 0.27277523052158237 1.19702979458848002 0.27031974327907626 1.19995999134850062 0.26783696716142708 1.20287004707951173 0.26532688195672521 1.20575953789980805 0.26278972678816304 1.20862781671414088 0.26022529469643624 1.21147474893699236 0.25763217763048496 1.21430150477218790 0.25500825126397131 1.21710994249041904 0.25235292985377017 1.21990005059103868 0.24966926670272568 1.22266796329330352 0.24696150391975732 1.22540882939352413 0.24423004526152650 1.22812190210150329 0.24146125706394184 1.23081996151861128 0.23861784080316129 1.23353765899792966 0.23566141121739081 1.23630795850379083 0.23313267974624646 1.23863075403103817 0.23108077081313610 1.24048682151979905 0.22951564660225790 1.24188808346222479 0.22785243018268259 1.24336238482365724 0.22603998536410663 1.24495322387069107 0.22406854105345719 1.24666425686480453 0.22194392374121000 1.24848570059305053 0.21966929759239204 1.25041206987825992 0.21725182330646176 1.25242961584586521 0.21469769930661789 1.25453321201678158 0.21201305169290471 1.25670455099802481 0.20919423964305814 1.25892740388225111 0.20624946264626334 1.26119206481064094 0.20318480037069683 1.26348679862854585 0.20000837020587425 1.26579929017010295 0.19672786860887337 1.26811801505294564 0.19336384906039994 1.27045063232052602 0.18992974310269095 1.27279484301208434 0.18643645229630731 1.27514361933883413 0.18288284026026952 1.27747988214753017 0.17926432420455884 1.27979154638979287 0.17557650128119320 1.28206361390544510 0.17182058886568480 1.28428512148975549 0.16804984196678602 1.28645557821983747 0.16432856924206579 1.28857394891545374 0.16070988708733733 1.29064090195652370 0.15717518220101778 1.29262871928824441 0.15369583278895632 1.29452720045016001 0.15026398879500619 1.29632707889676935 0.14689767435611573 1.29803910611286755 0.14368667318979397 1.29963940415365520 0.14066793270237543 1.30110806215344477 0.13786588940702740 1.30241800503027294 0.13522308508227587 1.30359724798135068 0.13268958893136670 1.30462396744174369 0.13022457745464813 1.30549794019590903 0.12782549497702861 1.30621459673763263 0.12551678736811231 1.30677267551026310 0.12264034969535306 1.30729452653584777 0.12051776185100731 1.30747541630908004 0.11912669923861925 1.30748468412943986 0.00000000000000000 4 0.00332678777314067 1 0.00530015559541836 1 0.00728182036673812 1 0.00927733380420748 1 0.01129573787307914 1 0.01327102124276026 1 0.01507750651120846 1 0.01659037664031113 1 0.01787187841143642 1 0.01880519345805253 1 0.02039488120903255 1 0.02452963651417061 1 0.02900897063209700 1 0.03340295596517878 1 0.03761684169382203 1 0.04167362563339645 1 0.04561938121714045 1 0.04949884613367380 1 0.05335394957604591 1 0.05721079085185987 1 0.06105670932975029 1 0.06491896046411526 1 0.06884011522460366 1 0.07280266881291077 1 0.07677853454115921 1 0.08082727159450992 1 0.08484703393156430 1 0.08884800850224144 1 0.09283736315162679 1 0.09681928451811667 1 0.10079344442245329 1 0.10475903456581770 1 0.10871533221895527 1 0.11266230101625047 1 0.11659995734938959 1 0.12052830686968952 1 0.12444792190998373 1 0.12835862681996368 1 0.13226049935437312 1 0.13615329767464079 1 0.14003667398886835 1 0.14391115976349200 1 0.14777767334262687 1 0.15163719748113480 1 0.15549084375107922 1 0.15933948557025243 1 0.16318380109489106 1 0.16702443368061037 1 0.17086206197732215 1 0.17469676853931951 1 0.17852903287965541 1 0.18235853795986209 1 0.18618547107174704 1 0.19001029311391093 1 0.19383342115543040 1 0.19765535049879729 1 0.20147647336026475 1 0.20529702393677510 1 0.20911722784810613 1 0.21293746918119616 1 0.21675849605951392 1 0.22058118324198547 1 0.22440637655431431 1 0.22823412013034025 1 0.23206350223258385 1 0.23589437276278422 1 0.23972883230279066 1 0.24357130772232163 1 0.24742464110863499 1 0.25128370603023881 1 0.25513705909052109 1 0.25898297113943686 1 0.26283319300761221 1 0.26673478756179048 1 0.27078270046115210 1 0.27498764230925066 1 0.27703550353465400 1 0.27908314380440813 1 0.28128986356810332 1 0.28370321223532124 1 0.28631785618959721 1 0.28912103899968400 1 0.29209869219406109 1 0.29526001444575162 1 0.29856723628509552 1 0.30202524340776099 1 0.30561830049238314 1 0.30933640124059564 1 0.31316962603536763 1 0.31710368845632919 1 0.32112310784334058 1 0.32522104893482329 1 0.32938444032265624 1 0.33359681084096160 1 0.33784938027078792 1 0.34214253792603233 1 0.34647801531348960 1 0.35084331838884097 1 0.35523312810758656 1 0.35953028089402317 1 0.36368926465670970 1 0.36773529430744634 1 0.37169603595072809 1 0.37557957415417503 1 0.37936041511409840 1 0.38302581855344769 1 0.38634253837102683 1 0.38943124796238249 1 0.39230486518080748 1 0.39502350628500010 1 0.39762992993310575 1 0.40014797436892702 1 0.40253156052235123 1 0.40475213727501114 1 0.40891189273334161 4\";\n\tstd::string str2 = \"7 0 0 3 118 116 0.44698587761425512 1.01737460557672743 0.44586770461012754 1.01734792256404072 0.44408669680926910 1.01745649198371058 0.44167433575859827 1.01788973448550668 0.43973012306214176 1.01839676158274872 0.43781512528503469 1.01906078430998237 0.43595772107855257 1.01986941991017832 0.43422167753434071 1.02078367982801188 0.43270019179331992 1.02172276730688871 0.43143529102668837 1.02260881639260637 0.43047395316133663 1.02337915724656336 0.42956918011417972 1.02417518983407696 0.42818486699350283 1.02596609318184684 0.42535867595845256 1.02808829688484948 0.42284370487027889 1.03193726498772675 0.42029420450207700 1.03578860458891087 0.41779215915839102 1.03971518009696795 0.41524996629274769 1.04360952276868124 0.41268259846706867 1.04748256529635642 0.41009244215779894 1.05134004607881448 0.40748344575385259 1.05519270420095079 0.40486605902395167 1.05904184662506151 0.40221826431976609 1.06286057810161427 0.39954731386633807 1.06664354970287856 0.39685998643058945 1.07039722937908555 0.39415205518567858 1.07412233241535748 0.39142459506816268 1.07782095032413006 0.38867831705369166 1.08149595009323263 0.38591346143208760 1.08514964980580220 0.38313020259072789 1.08878346979564511 0.38032844124366111 1.09239780218286464 0.37750825751929029 1.09599269297900204 0.37466975732311525 1.09956803650327561 0.37181298113969291 1.10312349001628252 0.36893792871143949 1.10665859650325404 0.36604460396156768 1.11017278012274700 0.36313313466979064 1.11366550770546358 0.36020385654578302 1.11713665503127646 0.35725711512561398 1.12058603617284369 0.35429324377611354 1.12401373368655166 0.35131230158758986 1.12741939957610104 0.34831421468687968 1.13080262402140796 0.34529890614255510 1.13416313676223202 0.34226629246633017 1.13750078799254517 0.33921704684458587 1.14081632451049253 0.33615179652790328 1.14411040925898311 0.33307117902797256 1.14738370759211961 0.32997572188237095 1.15063676015840910 0.32686583766548316 1.15386986351118148 0.32374192911050353 1.15708326206532552 0.32060452465855971 1.16027718535470581 0.31745360371300196 1.16345153388182476 0.31428913900094868 1.16660594252951411 0.31111112410899561 1.16974020701489989 0.30791955045097874 1.17285394667146026 0.30471460628308072 1.17594719675858417 0.30149648916692096 1.17901999285247383 0.29826547554743049 1.18207244366664344 0.29502169193428479 1.18510458595828827 0.29176503889034477 1.18811625270052801 0.28849545711393992 1.19110735246150123 0.28521287446926513 1.19407776448826497 0.28191760121088905 1.19702778959143030 0.27860991172799571 1.19995767798350750 0.27529017147185769 1.20286775332443230 0.27195821134041676 1.20575742910935957 0.26861365400632170 1.20862591999664737 0.26525581006410243 1.21147208574228693 0.26188571532285843 1.21429744804454320 0.25850537979441068 1.21710464921168948 0.25511712957007160 1.21989678109210420 0.25171762413613974 1.22266823849310202 0.24830072265899519 1.22540963473078257 0.24486605329372579 1.22811942696225307 0.24141572018592131 1.23080424790172627 0.23796057988059283 1.23349025995382422 0.23455481289528443 1.23625809731511249 0.23178384866187560 1.23861884218329443 0.22958637070091326 1.24049429822100898 0.22792095077852323 1.24183892665189632 0.22633085712869647 1.24330474335321250 0.22482706539293790 1.24489950308425112 0.22341229813088337 1.24661390687506479 0.22209453169097026 1.24843902517094874 0.22087888937927413 1.25036828651214238 0.21977124333451431 1.25238938953827761 0.21877814583739183 1.25449449573067429 0.21790282053379528 1.25666553458695951 0.21714464814126716 1.25889056843647418 0.21650897231276728 1.26115706505645897 0.21599821380382661 1.26345359947659142 0.21561431786668875 1.26576891766763566 0.21535790133274418 1.26809712034575073 0.21523156999800702 1.27043621478677027 0.21523493789335055 1.27278382859372918 0.21536761702246404 1.27513094567987695 0.21562960091705158 1.27746540211106607 0.21601986302685286 1.27977480962963663 0.21653701136757098 1.28204820066314440 0.21718164535537912 1.28428355977126407 0.21795318927362628 1.28647141444648527 0.21885182671844836 1.28860254299760535 0.21987018385314080 1.29066214545958857 0.22100473503305496 1.29264388729952517 0.22225426990375063 1.29454179066819441 0.22361918358992602 1.29635228361390098 0.22510542017288909 1.29807648877092108 0.22668582626421535 1.29967791748795536 0.22833572049978873 1.30113992652563426 0.23002054288496601 1.30245118636949164 0.23175614453859494 1.30361712921158590 0.23353904515484103 1.30463669825309792 0.23536790944712538 1.30550821214031298 0.23723013129137352 1.30622515706156905 0.23909802022459714 1.30677963590280544 0.24158931746901185 1.30731428646199599 0.24348144169383945 1.30748511863814065 0.24475247407226391 1.30748468412943986 0.00000000000000000 4 0.00334434293035562 1 0.00533825930397336 1 0.00734412586267121 1 0.00936623440575543 1 0.01141256205459959 1 0.01341573096600146 1 0.01524709020284723 1 0.01677336277701813 1 0.01804490068923616 1 0.01894326352103789 1 0.02037993823386658 1 0.02480566898074880 1 0.02939205655814846 1 0.03404043378943207 1 0.03869805978018042 1 0.04334980332413108 1 0.04799487443159717 1 0.05263737365801836 1 0.05728913631958347 1 0.06195364423015201 1 0.06660152728460191 1 0.07122956329812886 1 0.07584610283920201 1 0.08045084571229059 1 0.08504550471877484 1 0.08963256787874113 1 0.09421407873103112 1 0.09879117107574811 1 0.10336422781387057 1 0.10793330889559200 1 0.11249839490034602 1 0.11705945929549585 1 0.12161613091223618 1 0.12616821278487000 1 0.13071541215010135 1 0.13525724181627602 1 0.13979405378099050 1 0.14432538686178745 1 0.14885137954117900 1 0.15337193703905613 1 0.15788673904588241 1 0.16239626042792893 1 0.16690070771036525 1 0.17140021344792761 1 0.17589510396468730 1 0.18038552504431565 1 0.18487151865902063 1 0.18935308684053462 1 0.19383026236900400 1 0.19830276789454376 1 0.20277103974370816 1 0.20723457084840083 1 0.21169339151646616 1 0.21614758290681596 1 0.22059709488399620 1 0.22504193032631326 1 0.22948214264998190 1 0.23391784916535033 1 0.23834913245589026 1 0.24277612072013041 1 0.24719890919114179 1 0.25161757662768108 1 0.25603221057958453 1 0.26044282613505232 1 0.26484890217770901 1 0.26925063819864326 1 0.27364813118187725 1 0.27804209715833189 1 0.28243253716855193 1 0.28681951085634216 1 0.29120020890283443 1 0.29557446914500052 1 0.29994411461100146 1 0.30431579875993647 1 0.30870332268475420 1 0.31310853612917888 1 0.31523624508228770 1 0.31737014111002310 1 0.31952856178681960 1 0.32171830465981011 1 0.32394102970905830 1 0.32619217521253946 1 0.32846706602101300 1 0.33077763413829298 1 0.33310205916533187 1 0.33544576479270716 1 0.33779655322040053 1 0.34015052354015518 1 0.34250407705161767 1 0.34485099381932000 1 0.34718783135835085 1 0.34952735554083242 1 0.35187486439618521 1 0.35422711580943594 1 0.35657637606518838 1 0.35891858548088795 1 0.36124990679045155 1 0.36356703547085450 1 0.36589411785453302 1 0.36820554269186456 1 0.37050138589761700 1 0.37278277874756854 1 0.37505181955993466 1 0.37731379776658153 1 0.37958010527703534 1 0.38187591368213569 1 0.38405827564667433 1 0.38618898795548318 1 0.38827607822097537 1 0.39032555279796965 1 0.39234499730597777 1 0.39434796008648582 1 0.39630575790533801 1 0.39818438284552959 1 0.40198436891082029 4\";\n\tstd::istringstream iss1(str1);\n\tstd::istringstream iss2(str2);\n\tiss1 >> *bs1;\n\tiss2 >> *bs2;\n\tGeomAPIIntCurveCurve2 icc(bs1, bs2, 1e-12);\n\tCHECK(icc.NPoints() == 2);\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] AMCAX_API bool Contains(const Point3& point, double tol)\t @return True if the distance between the point and the plane is under the distance tolerance\n\t @param tol The distance tolerance\n\t @param point The point\n\t @brief Determines whether the plane contains a point under a tolerance or not\n,\n",
      "output": "#include \"catch.hpp\"\n#include <testHelper.h>\n#include <math/Plane.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"case1: Plane construction and methods\", \"[math][Plane][p1]\") {\n\tSECTION(\"Contains methods\") {\n        std::function<bool(const Plane&, const Point3&)> pointInPlane = [](const Plane& plane, const Point3& point)->bool {\n            Point3 planePoint = plane.Location();  \n            Vector3 planeVector(planePoint, point);  \n            double a, b, c, d;\n            plane.Coefficients(a, b, c, d);\n            return planeVector.Dot(Vector3(a, b, c)) == 0;\n        };\n        Plane plane(0., 0., 1., -1.); \n        Point3 point(1., 1., 1.);\n        Point3 point2(1., 1., 2.);\n        Line3 line(Point3(1., 1., 1.), Direction3(1., 0., 0.));\n        Line3 line2(Point3(1., 1., 1.), Direction3(0., 0., 1.));  \n        Line3 line3(Point3(1., 1., 0.), Direction3(1., 0., 0.));\n        REQUIRE(plane.Contains(point, 1e-6) == pointInPlane(plane, point));\n        REQUIRE(plane.Contains(point2, 1e-6) == pointInPlane(plane, point2));\n        REQUIRE(plane.Contains(line, 1e-6, 1e-6));\n        REQUIRE_FALSE(plane.Contains(line2, 1e-6, 1e-6 * (M_PI / 180)));\n        REQUIRE_FALSE(plane.Contains(line3, 1e-6, 1e-6 * (M_PI / 180)));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] AMCAX_API double SquaredDistance(const Point3& point)\t @return The squared point-plane distance\n\t @param point The point\n\t @brief Compute the squared distance from a point to the plane\n,\n",
      "output": "#include \"catch.hpp\"\n#include <testHelper.h>\n#include <math/Plane.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"case1: Plane construction and methods\", \"[math][Plane][p1]\") {\n\tSECTION(\"Distance methods\") {\n        std::function<double(const Plane&, const Point3&)> pointToPlane = [](const Plane& plane, const Point3& point)->double {\n            double a, b, c, d;\n            plane.Coefficients(a, b, c, d);\n            return std::fabs(a * point.X() + b * point.Y() + c * point.Z() + d);\n        };\n        std::function<double(const Plane&, const Line3&)> lineToPlane = [](const Plane& plane, const Line3& line)->double {\n            Point3 point = line.Location();\n            double a, b, c, d;\n            plane.Coefficients(a, b, c, d);\n            if (line.Direction().Dot(Vector3(a, b, c)) != 0)  \n                return 0;\n            return std::fabs(a * point.X() + b * point.Y() + c * point.Z() + d);\n        };\n        std::function<double(const Plane&, const Plane&)> planeToPlane = [](const Plane& plane1, const Plane& plane2)->double {\n            double a1, b1, c1, d1, a2, b2, c2, d2;\n            plane1.Coefficients(a1, b1, c1, d1);\n            plane2.Coefficients(a2, b2, c2, d2);\n            if (a1 != a2 || b1 != b2 || c1 != c2) return 0;\n            return std::fabs(d1 - d2);\n        };\n        Plane plane(0., 0., 1., -1.); \n        Point3 point(1., 1., 2.);\n        Line3 line(Point3(1., 1., 3.), Direction3(0., 0., 1.));\n        Plane otherPlane1(0, 0, 1, -2); \n        Plane otherPlane2(1, 0, 1, -2); \n        REQUIRE(plane.Distance(point) == Approx(pointToPlane(plane, point)));\n        REQUIRE(plane.SquaredDistance(point) == Approx(pointToPlane(plane, point) * pointToPlane(plane, point)));\n        REQUIRE(plane.Distance(line) == Approx(lineToPlane(plane, line)));\n        REQUIRE(plane.SquaredDistance(line) == Approx(lineToPlane(plane, line) * lineToPlane(plane, line)));\n        REQUIRE(plane.Distance(otherPlane1) == Approx(planeToPlane(plane, otherPlane1)));\n        REQUIRE(plane.SquaredDistance(otherPlane1) == Approx(planeToPlane(plane, otherPlane1) * planeToPlane(plane, otherPlane1)));\n        REQUIRE(plane.Distance(otherPlane2) == Approx(planeToPlane(plane, otherPlane2)));\n        REQUIRE(plane.SquaredDistance(otherPlane2) == Approx(planeToPlane(plane, otherPlane2) * planeToPlane(plane, otherPlane2)));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API Plane(double a, double b, double c, double d)\t @param a,b,c,d The coefficients\n\t @brief Construct from an algebraic representation: ax + by + cz + d = 0\n,\n",
      "output": "#include \"catch.hpp\"\n#include <testHelper.h>\n#include <math/Plane.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"case1: Plane construction and methods\", \"[math][Plane][p1]\") {\n\tSECTION(\"Construct from algebraic representation\") {\n        Plane plane(1., 1., 1., -3.);  \n        double a, b, c, d;\n        plane.Coefficients(a, b, c, d);  \n        REQUIRE(a == Approx(1./std::sqrt(3)).margin(0.001));\n        REQUIRE(b == Approx(1. / std::sqrt(3)).margin(0.001));\n        REQUIRE(c == Approx(1. / std::sqrt(3)).margin(0.001));\n        REQUIRE(d == Approx(-3. / std::sqrt(3)).margin(0.001));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API Plane(const Point3& point, const Direction3& dir)\t @param dir The direction\n\t @param point The point\n\t @brief Construct from a point and a direction\n,\n",
      "output": "#include \"catch.hpp\"\n#include <testHelper.h>\n#include <math/Plane.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"case1: Plane construction and methods\", \"[math][Plane][p1]\") {\n\tSECTION(\"Construct from point and direction\") {\n        Point3 point(1., 1., 1.);\n        Direction3 dir(0., 0., 1.);\n        Plane plane(point, dir);  \n        Point3 point2(3., 4., 4.);\n        Direction3 dir2(2., 2., 1.);\n        Plane plane2(point2, dir2);  \n        double a, b, c, d;\n        plane.Coefficients(a, b, c, d);\n        double a2, b2, c2, d2;\n        plane2.Coefficients(a2, b2, c2, d2);\n        REQUIRE(a == Approx(0));\n        REQUIRE(b == Approx(0));\n        REQUIRE(c == Approx(1));\n        REQUIRE(d == Approx(-1));\n        REQUIRE(a2 == Approx(2./3).margin(0.0001));\n        REQUIRE(b2 == Approx(2./3).margin(0.0001));\n        REQUIRE(c2 == Approx(1./3).margin(0.0001));\n        REQUIRE(d2 == Approx(-6));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API explicit Plane(const Frame3& frame)\t @param frame The local frame\n\t @brief Construct from a local frame, XOY plane\n,\n",
      "output": "#include \"catch.hpp\"\n#include <testHelper.h>\n#include <math/Plane.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"case1: Plane construction and methods\", \"[math][Plane][p1]\") {\n\tSECTION(\"Construct from frame\") {\n        Frame3 frame1(Point3(0.0, 0.0, 0.0), Direction3(0.0, 0.0, 1.0));\n        Frame3 frame2(Point3(1.0, 0.0, 0.0), Direction3(2.0, 1.0, 1.0));\n        Plane plane1(frame1);\n        Plane plane2(frame2);  \n        double a1, b1, c1, d1;\n        plane1.Coefficients(a1, b1, c1, d1);\n        double a2, b2, c2, d2;\n        plane2.Coefficients(a2, b2, c2, d2);\n        REQUIRE(a1 == Approx(0));\n        REQUIRE(b1 == Approx(0));\n        REQUIRE(c1 == Approx(1));\n        REQUIRE(d1 == Approx(0));\n        REQUIRE(a2 == Approx(2. / std::sqrt(6)));\n        REQUIRE(b2 == Approx(1. / std::sqrt(6)));\n        REQUIRE(c2 == Approx(1. / std::sqrt(6)));\n        REQUIRE(d2 == Approx(-2. / std::sqrt(6)));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "Plane()\t Default constructor\n,\n",
      "output": "#include \"catch.hpp\"\n#include <testHelper.h>\n#include <math/Plane.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"case1: Plane construction and methods\", \"[math][Plane][p1]\") {\n\tSECTION(\"Default constructor\") {\n        Plane plane;\n        double a, b, c, d;\n        plane.Coefficients(a, b, c, d);\n        REQUIRE(a == Approx(0));\n        REQUIRE(b == Approx(0));\n        REQUIRE(c == Approx(1));\n        REQUIRE(d == Approx(0));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API void Coefficients(double& a, double& b, double& c, double& d)\t @param[out] a,b,c,d The coefficients\n\t @brief Get coefficients of algebraic representation: ax + by + cz + d = 0\n,\n",
      "output": "#include \"catch.hpp\"\n#include <testHelper.h>\n#include <math/Plane.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"case1: Plane construction and methods\", \"[math][Plane][p1]\") {\n\tSECTION(\"Default constructor\") {\n        Plane plane;\n        double a, b, c, d;\n        plane.Coefficients(a, b, c, d);\n        REQUIRE(a == Approx(0));\n        REQUIRE(b == Approx(0));\n        REQUIRE(c == Approx(1));\n        REQUIRE(d == Approx(0));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API Geom3Hyperbola(const Frame3& frame, double major, double minor)\t @param minor The minor radius\n\t @param major The major radius\n\t @param frame The local frame\n\t @brief Construct from a local frame, a major radius and a minor radius\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <math/EllipseT.hpp>\n#include <geometry/Geom3Hyperbola.hpp>\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Test Geom3Hyperbola\", \"[math][Geom3Hyperbola][P1]\")\n{\n\tFrame3 frame;\n\tdouble major = 5.0;\n\tdouble minor = 4.0;\n\tGeom3Hyperbola g3h(frame, major, minor);\n\tSECTION(\"FocalParameter\")\n\t{\n\t\tdouble FP = g3h.FocalParameter();\n\t\tdouble focal = 2 * sqrt(major * major + minor * minor);\n\t\tdouble fp = 2 * minor * minor / focal;;\n\t\tCHECK(FP == fp);\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API explicit Geom3Hyperbola(const Hyperbola3& h)\t @param h The hyperbola\n\t @brief Construct from an hyperbola\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <math/EllipseT.hpp>\n#include <geometry/Geom3Hyperbola.hpp>\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Test Geom3Hyperbola\", \"[math][Geom3Hyperbola][P1]\")\n{\n\tFrame3 frame;\n\tdouble major = 5.0;\n\tdouble minor = 4.0;\n\tGeom3Hyperbola g3h(frame, major, minor);\n\tSECTION(\"SemilatusRectum\")\n\t{\n\t\tdouble SR = g3h.SemilatusRectum();\n\t\tdouble sr = minor * minor / major;\n\t\tCHECK(SR == sr);\n\t}\n}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API Geom3Ellipse(const Frame3& frame, double major, double minor)\t @param minor The minor radius\n\t @param major The major radius\n\t @param frame The local frame\n\t @brief Construct from a local frame, a major radius and a minor radius\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <common/FrameT.hpp>\n#include <math/EllipseT.hpp>\n#include <geometry/Geom3Ellipse.hpp>\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Test Geom3Ellipse\", \"[math][Geom3Ellipse][P1]\")\n{\n\tFrame3 frame;\n\tdouble major = 5.0;\n\tdouble minor = 4.0;\n\tEllipse3 ellipse(frame, major, minor);\n\tGeom3Ellipse g3e(ellipse);\n\tSECTION(\"FocalParameter\")\n\t{\n\t\tdouble FP = g3e.FocalParameter();\n\t\tdouble focal = 2 * sqrt(major * major - minor * minor);\n\t\tdouble fp = 2 * minor * minor / focal;;\n\t\tCHECK(FP == fp);\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API explicit Geom3Ellipse(const Ellipse3& e)\t @param e The ellipse\n\t @brief Construct from an ellipse\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <common/FrameT.hpp>\n#include <math/EllipseT.hpp>\n#include <geometry/Geom3Ellipse.hpp>\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Test Geom3Ellipse\", \"[math][Geom3Ellipse][P1]\")\n{\n\tFrame3 frame;\n\tdouble major = 5.0;\n\tdouble minor = 4.0;\n\tEllipse3 ellipse(frame, major, minor);\n\tGeom3Ellipse g3e(ellipse);\n\tSECTION(\"FocalParameter\")\n\t{\n\t\tdouble FP = g3e.FocalParameter();\n\t\tdouble focal = 2 * sqrt(major * major - minor * minor);\n\t\tdouble fp = 2 * minor * minor / focal;;\n\t\tCHECK(FP == fp);\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "Geom3Ellipse()\t @brief Default constructor\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <common/FrameT.hpp>\n#include <math/EllipseT.hpp>\n#include <geometry/Geom3Ellipse.hpp>\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Test Geom3Ellipse\", \"[math][Geom3Ellipse][P1]\")\n{\n\tFrame3 frame;\n\tdouble major = 5.0;\n\tdouble minor = 4.0;\n\tEllipse3 ellipse(frame, major, minor);\n\tGeom3Ellipse g3e(ellipse);\n\tSECTION(\"FocalParameter\")\n\t{\n\t\tdouble FP = g3e.FocalParameter();\n\t\tdouble focal = 2 * sqrt(major * major - minor * minor);\n\t\tdouble fp = 2 * minor * minor / focal;;\n\t\tCHECK(FP == fp);\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API Cone& Scale(const Point3& point, double scale)\t @return The reference to self\n\t @param scale The scale value\n\t @param point The scaling center point\n\t @brief Scale the cone by a point\n,\n",
      "output": "#include<iostream>\n#include \"catch.hpp\"\n#include <common/FrameT.hpp>\n#include <modeling/MakeFace.hpp>\n#include <common/AxisT.hpp>\n#include <common/FrameT.hpp>\n#include <common/VectorT.hpp>\n#include <math/Cone.hpp>\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"TestCone\", \"[math][Cone]\")\n{\n\tAMCAX::Frame3 frame;\n\tdouble radius = 5.0;\n\tdouble angle = M_PI / 4;\n\tAMCAX::Cone cone(frame, radius, angle);\n\tAMCAX::Point3 apex = cone.Apex();\n\tCHECK(apex.X() == 0.0);\n\tCHECK(apex.Y() == 0.0);\n\tCHECK(apex.Z() == Approx(-5.0));\n\tAMCAX::Axis3 axis = cone.Axis();\n\tstd::cout << axis.Direction().X() << std::endl;\n\tstd::cout << axis.Direction().Y() << std::endl;\n\tstd::cout << axis.Direction().Z() << std::endl;\n\tCHECK(axis.Direction().X() == 0.0);\n\tCHECK(axis.Direction().Y() == 0.0);\n\tCHECK(axis.Direction().Z() == 1.0);\n\tdouble a1, a2, a3, b1, b2, b3, c1, c2, c3, d;\n\tcone.Coefficients(a1, a2, a3, b1, b2, b3, c1, c2, c3, d);\n\tstd::cout << \"a1: \" << a1 << \", a2: \" << a2 << \", a3: \" << a3 << std::endl;\n\tstd::cout << \"b1: \" << b1 << \", b2: \" << b2 << \", b3: \" << b3 << std::endl;\n\tstd::cout << \"c1: \" << c1 << \", c2: \" << c2 << \", c3: \" << c3 << std::endl;\n\tstd::cout << \"d: \" << d << std::endl;\n\tCHECK(a1 == 1.0);\n\tCHECK(a2 == 1.0);\n\tCHECK(a3 == Approx(-1.0));\n\tCHECK(b1 == 0);\n\tCHECK(b2 == 0);\n\tCHECK(b3 == 0);\n\tCHECK(c1 == 0);\n\tCHECK(c2 == 0);\n\tCHECK(c3 == Approx(-5.0));\n\tCHECK(d == -25.0);\n\tCHECK(cone.IsDirect() == true);\n\tCHECK(cone.Location().X() == 0.0);\n\tCHECK(cone.Location().Y() == 0.0);\n\tCHECK(cone.Location().Z() == 0.0);\n\tAMCAX::PointT<double, 3>mirrorPoint(5.0, 0.0, 0.0);\n\tcone.Mirror(mirrorPoint);\n\tauto mirroredLocation = cone.Location();\n\tCHECK(mirroredLocation.X() == 10.0);\n\tCHECK(mirroredLocation.Y() == 0.0);\n\tCHECK(mirroredLocation.Z() == 0.0);\n\tAMCAX::Frame3 coneFrame = cone.Position();\n\tCHECK(frame.Location().X() == 0.0);\n\tCHECK(frame.Location().Y() == 0.0);\n\tCHECK(frame.Location().Z() == 0.0);\n\tCHECK(cone.Radius() == 5.0);\n\tdouble  scaleCone = 2.0;\n\tcone.Scale(cone.Location(), scaleCone);\n\tCHECK(cone.Radius() == radius * 2.0);\n\tdouble semiCone = cone.SemiAngle();\n\tCHECK(semiCone == Approx(0.785398));\n\tconst  Frame3& position = cone.Position();\n\tstd::cout << position.XAxis() << std::endl;\n\tstd::cout << position.YAxis() << std::endl;\n\tDirection3 zDirection(0.0, 0.0, 1.0);\n\tAMCAX::Point3  centerCone(0.0, 0.0, 0.0);\n\tAxis3 zAxis(centerCone, zDirection);\n\tcone.Rotated(zAxis, angle);\n\tAMCAX::Frame3 coneFrame2 = cone.Position();\n\tCHECK(coneFrame.Location().X() == 10.0);\n\tCHECK(coneFrame.Location().Y() == 0.0);\n\tCHECK(coneFrame.Location().Z() == 0.0);\n\tdouble scale = 2.0;\n\tcone.Scale(centerCone, scale);\n\tCHECK(cone.Radius() == radius * 4.0);\n\tdouble semiAngle = cone.SemiAngle();\n\tstd::cout << semiAngle << std::endl;\n\tCHECK(semiAngle == Approx(0.785398));\n\tVectorT<double, 3> translationVector(5.0, 5.0, 0.0);\n\tcone.Translate(translationVector);\n\tCHECK(cone.Location().X() == 25.0);\n\tCHECK(cone.Location().Y() == 5.0);\n\tCHECK(cone.Location().Z() == 0.0);\n\tauto xAxis = cone.XAxis();\n\tauto yAxis = cone.YAxis();\n\tCHECK(xAxis.Direction().X() == Approx(-1.0));\n\tCHECK(yAxis.Direction().Y() == Approx(-1.0));\n\tAMCAX::Transformation3 tr;\n\ttr.SetTranslation(Vector3(1.0, 2.0, 3.0));\n\tcone.Transform(tr);\n\tAxis3 newXAxis = cone.Position().XAxis();\n\tCHECK(newXAxis.Location().X() == 26.0);\n\tCHECK(newXAxis.Location().Y() == 7.0);\n\tCHECK(newXAxis.Location().Z() == 3.0);\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API Cone(const Frame3& frame, double r, double angle)\t @param angle The semi-angle\n\t @param r The reference radius\n\t @param frame The local frame\n\t @brief Construct from a local frame, a reference radius and a semi-angle\n,\n",
      "output": "#include<iostream>\n#include \"catch.hpp\"\n#include <common/FrameT.hpp>\n#include <modeling/MakeFace.hpp>\n#include <common/AxisT.hpp>\n#include <common/FrameT.hpp>\n#include <common/VectorT.hpp>\n#include <math/Cone.hpp>\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"TestCone\", \"[math][Cone]\")\n{\n\tAMCAX::Frame3 frame;\n\tdouble radius = 5.0;\n\tdouble angle = M_PI / 4;\n\tAMCAX::Cone cone(frame, radius, angle);\n\tAMCAX::Point3 apex = cone.Apex();\n\tCHECK(apex.X() == 0.0);\n\tCHECK(apex.Y() == 0.0);\n\tCHECK(apex.Z() == Approx(-5.0));\n\tAMCAX::Axis3 axis = cone.Axis();\n\tstd::cout << axis.Direction().X() << std::endl;\n\tstd::cout << axis.Direction().Y() << std::endl;\n\tstd::cout << axis.Direction().Z() << std::endl;\n\tCHECK(axis.Direction().X() == 0.0);\n\tCHECK(axis.Direction().Y() == 0.0);\n\tCHECK(axis.Direction().Z() == 1.0);\n\tdouble a1, a2, a3, b1, b2, b3, c1, c2, c3, d;\n\tcone.Coefficients(a1, a2, a3, b1, b2, b3, c1, c2, c3, d);\n\tstd::cout << \"a1: \" << a1 << \", a2: \" << a2 << \", a3: \" << a3 << std::endl;\n\tstd::cout << \"b1: \" << b1 << \", b2: \" << b2 << \", b3: \" << b3 << std::endl;\n\tstd::cout << \"c1: \" << c1 << \", c2: \" << c2 << \", c3: \" << c3 << std::endl;\n\tstd::cout << \"d: \" << d << std::endl;\n\tCHECK(a1 == 1.0);\n\tCHECK(a2 == 1.0);\n\tCHECK(a3 == Approx(-1.0));\n\tCHECK(b1 == 0);\n\tCHECK(b2 == 0);\n\tCHECK(b3 == 0);\n\tCHECK(c1 == 0);\n\tCHECK(c2 == 0);\n\tCHECK(c3 == Approx(-5.0));\n\tCHECK(d == -25.0);\n\tCHECK(cone.IsDirect() == true);\n\tCHECK(cone.Location().X() == 0.0);\n\tCHECK(cone.Location().Y() == 0.0);\n\tCHECK(cone.Location().Z() == 0.0);\n\tAMCAX::PointT<double, 3>mirrorPoint(5.0, 0.0, 0.0);\n\tcone.Mirror(mirrorPoint);\n\tauto mirroredLocation = cone.Location();\n\tCHECK(mirroredLocation.X() == 10.0);\n\tCHECK(mirroredLocation.Y() == 0.0);\n\tCHECK(mirroredLocation.Z() == 0.0);\n\tAMCAX::Frame3 coneFrame = cone.Position();\n\tCHECK(frame.Location().X() == 0.0);\n\tCHECK(frame.Location().Y() == 0.0);\n\tCHECK(frame.Location().Z() == 0.0);\n\tCHECK(cone.Radius() == 5.0);\n\tdouble  scaleCone = 2.0;\n\tcone.Scale(cone.Location(), scaleCone);\n\tCHECK(cone.Radius() == radius * 2.0);\n\tdouble semiCone = cone.SemiAngle();\n\tCHECK(semiCone == Approx(0.785398));\n\tconst  Frame3& position = cone.Position();\n\tstd::cout << position.XAxis() << std::endl;\n\tstd::cout << position.YAxis() << std::endl;\n\tDirection3 zDirection(0.0, 0.0, 1.0);\n\tAMCAX::Point3  centerCone(0.0, 0.0, 0.0);\n\tAxis3 zAxis(centerCone, zDirection);\n\tcone.Rotated(zAxis, angle);\n\tAMCAX::Frame3 coneFrame2 = cone.Position();\n\tCHECK(coneFrame.Location().X() == 10.0);\n\tCHECK(coneFrame.Location().Y() == 0.0);\n\tCHECK(coneFrame.Location().Z() == 0.0);\n\tdouble scale = 2.0;\n\tcone.Scale(centerCone, scale);\n\tCHECK(cone.Radius() == radius * 4.0);\n\tdouble semiAngle = cone.SemiAngle();\n\tstd::cout << semiAngle << std::endl;\n\tCHECK(semiAngle == Approx(0.785398));\n\tVectorT<double, 3> translationVector(5.0, 5.0, 0.0);\n\tcone.Translate(translationVector);\n\tCHECK(cone.Location().X() == 25.0);\n\tCHECK(cone.Location().Y() == 5.0);\n\tCHECK(cone.Location().Z() == 0.0);\n\tauto xAxis = cone.XAxis();\n\tauto yAxis = cone.YAxis();\n\tCHECK(xAxis.Direction().X() == Approx(-1.0));\n\tCHECK(yAxis.Direction().Y() == Approx(-1.0));\n\tAMCAX::Transformation3 tr;\n\ttr.SetTranslation(Vector3(1.0, 2.0, 3.0));\n\tcone.Transform(tr);\n\tAxis3 newXAxis = cone.Position().XAxis();\n\tCHECK(newXAxis.Location().X() == 26.0);\n\tCHECK(newXAxis.Location().Y() == 7.0);\n\tCHECK(newXAxis.Location().Z() == 3.0);\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] AMCAX_API double SemiAngle()\t @return The semi-angle\n\t @brief Get the semi-angle\n,\n",
      "output": "#include<iostream>\n#include \"catch.hpp\"\n#include <common/FrameT.hpp>\n#include <modeling/MakeFace.hpp>\n#include <common/AxisT.hpp>\n#include <common/FrameT.hpp>\n#include <common/VectorT.hpp>\n#include <math/Cone.hpp>\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"TestCone\", \"[math][Cone]\")\n{\n\tAMCAX::Frame3 frame;\n\tdouble radius = 5.0;\n\tdouble angle = M_PI / 4;\n\tAMCAX::Cone cone(frame, radius, angle);\n\tAMCAX::Point3 apex = cone.Apex();\n\tCHECK(apex.X() == 0.0);\n\tCHECK(apex.Y() == 0.0);\n\tCHECK(apex.Z() == Approx(-5.0));\n\tAMCAX::Axis3 axis = cone.Axis();\n\tstd::cout << axis.Direction().X() << std::endl;\n\tstd::cout << axis.Direction().Y() << std::endl;\n\tstd::cout << axis.Direction().Z() << std::endl;\n\tCHECK(axis.Direction().X() == 0.0);\n\tCHECK(axis.Direction().Y() == 0.0);\n\tCHECK(axis.Direction().Z() == 1.0);\n\tdouble a1, a2, a3, b1, b2, b3, c1, c2, c3, d;\n\tcone.Coefficients(a1, a2, a3, b1, b2, b3, c1, c2, c3, d);\n\tstd::cout << \"a1: \" << a1 << \", a2: \" << a2 << \", a3: \" << a3 << std::endl;\n\tstd::cout << \"b1: \" << b1 << \", b2: \" << b2 << \", b3: \" << b3 << std::endl;\n\tstd::cout << \"c1: \" << c1 << \", c2: \" << c2 << \", c3: \" << c3 << std::endl;\n\tstd::cout << \"d: \" << d << std::endl;\n\tCHECK(a1 == 1.0);\n\tCHECK(a2 == 1.0);\n\tCHECK(a3 == Approx(-1.0));\n\tCHECK(b1 == 0);\n\tCHECK(b2 == 0);\n\tCHECK(b3 == 0);\n\tCHECK(c1 == 0);\n\tCHECK(c2 == 0);\n\tCHECK(c3 == Approx(-5.0));\n\tCHECK(d == -25.0);\n\tCHECK(cone.IsDirect() == true);\n\tCHECK(cone.Location().X() == 0.0);\n\tCHECK(cone.Location().Y() == 0.0);\n\tCHECK(cone.Location().Z() == 0.0);\n\tAMCAX::PointT<double, 3>mirrorPoint(5.0, 0.0, 0.0);\n\tcone.Mirror(mirrorPoint);\n\tauto mirroredLocation = cone.Location();\n\tCHECK(mirroredLocation.X() == 10.0);\n\tCHECK(mirroredLocation.Y() == 0.0);\n\tCHECK(mirroredLocation.Z() == 0.0);\n\tAMCAX::Frame3 coneFrame = cone.Position();\n\tCHECK(frame.Location().X() == 0.0);\n\tCHECK(frame.Location().Y() == 0.0);\n\tCHECK(frame.Location().Z() == 0.0);\n\tCHECK(cone.Radius() == 5.0);\n\tdouble  scaleCone = 2.0;\n\tcone.Scale(cone.Location(), scaleCone);\n\tCHECK(cone.Radius() == radius * 2.0);\n\tdouble semiCone = cone.SemiAngle();\n\tCHECK(semiCone == Approx(0.785398));\n\tconst  Frame3& position = cone.Position();\n\tstd::cout << position.XAxis() << std::endl;\n\tstd::cout << position.YAxis() << std::endl;\n\tDirection3 zDirection(0.0, 0.0, 1.0);\n\tAMCAX::Point3  centerCone(0.0, 0.0, 0.0);\n\tAxis3 zAxis(centerCone, zDirection);\n\tcone.Rotated(zAxis, angle);\n\tAMCAX::Frame3 coneFrame2 = cone.Position();\n\tCHECK(coneFrame.Location().X() == 10.0);\n\tCHECK(coneFrame.Location().Y() == 0.0);\n\tCHECK(coneFrame.Location().Z() == 0.0);\n\tdouble scale = 2.0;\n\tcone.Scale(centerCone, scale);\n\tCHECK(cone.Radius() == radius * 4.0);\n\tdouble semiAngle = cone.SemiAngle();\n\tstd::cout << semiAngle << std::endl;\n\tCHECK(semiAngle == Approx(0.785398));\n\tVectorT<double, 3> translationVector(5.0, 5.0, 0.0);\n\tcone.Translate(translationVector);\n\tCHECK(cone.Location().X() == 25.0);\n\tCHECK(cone.Location().Y() == 5.0);\n\tCHECK(cone.Location().Z() == 0.0);\n\tauto xAxis = cone.XAxis();\n\tauto yAxis = cone.YAxis();\n\tCHECK(xAxis.Direction().X() == Approx(-1.0));\n\tCHECK(yAxis.Direction().Y() == Approx(-1.0));\n\tAMCAX::Transformation3 tr;\n\ttr.SetTranslation(Vector3(1.0, 2.0, 3.0));\n\tcone.Transform(tr);\n\tAxis3 newXAxis = cone.Position().XAxis();\n\tCHECK(newXAxis.Location().X() == 26.0);\n\tCHECK(newXAxis.Location().Y() == 7.0);\n\tCHECK(newXAxis.Location().Z() == 3.0);\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] AMCAX_API Point3 Apex()\t @return The apex point\n\t @brief Get the apex of the cone\n,\n",
      "output": "#include<iostream>\n#include \"catch.hpp\"\n#include <common/FrameT.hpp>\n#include <modeling/MakeFace.hpp>\n#include <common/AxisT.hpp>\n#include <common/FrameT.hpp>\n#include <common/VectorT.hpp>\n#include <math/Cone.hpp>\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"TestCone\", \"[math][Cone]\")\n{\n\tAMCAX::Frame3 frame;\n\tdouble radius = 5.0;\n\tdouble angle = M_PI / 4;\n\tAMCAX::Cone cone(frame, radius, angle);\n\tAMCAX::Point3 apex = cone.Apex();\n\tCHECK(apex.X() == 0.0);\n\tCHECK(apex.Y() == 0.0);\n\tCHECK(apex.Z() == Approx(-5.0));\n\tAMCAX::Axis3 axis = cone.Axis();\n\tstd::cout << axis.Direction().X() << std::endl;\n\tstd::cout << axis.Direction().Y() << std::endl;\n\tstd::cout << axis.Direction().Z() << std::endl;\n\tCHECK(axis.Direction().X() == 0.0);\n\tCHECK(axis.Direction().Y() == 0.0);\n\tCHECK(axis.Direction().Z() == 1.0);\n\tdouble a1, a2, a3, b1, b2, b3, c1, c2, c3, d;\n\tcone.Coefficients(a1, a2, a3, b1, b2, b3, c1, c2, c3, d);\n\tstd::cout << \"a1: \" << a1 << \", a2: \" << a2 << \", a3: \" << a3 << std::endl;\n\tstd::cout << \"b1: \" << b1 << \", b2: \" << b2 << \", b3: \" << b3 << std::endl;\n\tstd::cout << \"c1: \" << c1 << \", c2: \" << c2 << \", c3: \" << c3 << std::endl;\n\tstd::cout << \"d: \" << d << std::endl;\n\tCHECK(a1 == 1.0);\n\tCHECK(a2 == 1.0);\n\tCHECK(a3 == Approx(-1.0));\n\tCHECK(b1 == 0);\n\tCHECK(b2 == 0);\n\tCHECK(b3 == 0);\n\tCHECK(c1 == 0);\n\tCHECK(c2 == 0);\n\tCHECK(c3 == Approx(-5.0));\n\tCHECK(d == -25.0);\n\tCHECK(cone.IsDirect() == true);\n\tCHECK(cone.Location().X() == 0.0);\n\tCHECK(cone.Location().Y() == 0.0);\n\tCHECK(cone.Location().Z() == 0.0);\n\tAMCAX::PointT<double, 3>mirrorPoint(5.0, 0.0, 0.0);\n\tcone.Mirror(mirrorPoint);\n\tauto mirroredLocation = cone.Location();\n\tCHECK(mirroredLocation.X() == 10.0);\n\tCHECK(mirroredLocation.Y() == 0.0);\n\tCHECK(mirroredLocation.Z() == 0.0);\n\tAMCAX::Frame3 coneFrame = cone.Position();\n\tCHECK(frame.Location().X() == 0.0);\n\tCHECK(frame.Location().Y() == 0.0);\n\tCHECK(frame.Location().Z() == 0.0);\n\tCHECK(cone.Radius() == 5.0);\n\tdouble  scaleCone = 2.0;\n\tcone.Scale(cone.Location(), scaleCone);\n\tCHECK(cone.Radius() == radius * 2.0);\n\tdouble semiCone = cone.SemiAngle();\n\tCHECK(semiCone == Approx(0.785398));\n\tconst  Frame3& position = cone.Position();\n\tstd::cout << position.XAxis() << std::endl;\n\tstd::cout << position.YAxis() << std::endl;\n\tDirection3 zDirection(0.0, 0.0, 1.0);\n\tAMCAX::Point3  centerCone(0.0, 0.0, 0.0);\n\tAxis3 zAxis(centerCone, zDirection);\n\tcone.Rotated(zAxis, angle);\n\tAMCAX::Frame3 coneFrame2 = cone.Position();\n\tCHECK(coneFrame.Location().X() == 10.0);\n\tCHECK(coneFrame.Location().Y() == 0.0);\n\tCHECK(coneFrame.Location().Z() == 0.0);\n\tdouble scale = 2.0;\n\tcone.Scale(centerCone, scale);\n\tCHECK(cone.Radius() == radius * 4.0);\n\tdouble semiAngle = cone.SemiAngle();\n\tstd::cout << semiAngle << std::endl;\n\tCHECK(semiAngle == Approx(0.785398));\n\tVectorT<double, 3> translationVector(5.0, 5.0, 0.0);\n\tcone.Translate(translationVector);\n\tCHECK(cone.Location().X() == 25.0);\n\tCHECK(cone.Location().Y() == 5.0);\n\tCHECK(cone.Location().Z() == 0.0);\n\tauto xAxis = cone.XAxis();\n\tauto yAxis = cone.YAxis();\n\tCHECK(xAxis.Direction().X() == Approx(-1.0));\n\tCHECK(yAxis.Direction().Y() == Approx(-1.0));\n\tAMCAX::Transformation3 tr;\n\ttr.SetTranslation(Vector3(1.0, 2.0, 3.0));\n\tcone.Transform(tr);\n\tAxis3 newXAxis = cone.Position().XAxis();\n\tCHECK(newXAxis.Location().X() == 26.0);\n\tCHECK(newXAxis.Location().Y() == 7.0);\n\tCHECK(newXAxis.Location().Z() == 3.0);\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API Geom3ConicalSurface(const Frame3& frame, double r, double angle)\t @param angle The semi-angle\n\t @param r The reference radius\n\t @param frame The local frame\n\t @brief Construct from a local frame, a reference radius and a semi-angle\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <common/PointT.hpp>\n#include <math/CurveCalculation.hpp>\n#include <geometry/Geom3ConicalSurface.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"case1: Geom3ConicalSurface::CircleD1 1/4 \", \"[math][Geom3ConicalSurface][P1][CircleD1]\") {\n\tDirection3 initialDir(0.0, 0.0, 1.0); \n\tFrame3 defaultFrame3(Point3(1.0, 1.0, 0.0), initialDir);\n\tAMCAX::Geom3ConicalSurface suface(defaultFrame3, 5.0, 1);\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API Geom3BSplineSurface(const Array2<Point3>& pts, const std::vector<double>& uKnots, const std::vector<double>& vKnots, const std::vector<int>& uMults, const std::vector<int>& vMults, int uDegree, int vDegree, bool uPeriodic = false, bool vPeriodic = false)\t @param vPeriodic Set whether the surface is periodic along the v direction\n\t @param uPeriodic Set whether the surface is periodic along the u direction\n\t @param vDegree The v degree\n\t @param uDegree The u degree\n\t @param vMults The v multiplicities\n\t @param uMults The u multiplicities\n\t @param vKnots The v knots\n\t @param uKnots The u knots\n\t @param pts The poles\n\t @brief Construct a B spline surface from poles, knots and multiplicities\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <modeling/MakeFace.hpp>\n#include <geometry/Geom3BSplineSurface.hpp>\n#include <topology/TopoFace.hpp>\n#include <topology/TopoTool.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"bug1: Geom3BSplineSurface::InsertUKnot() \", \"[geometry][Geom3BSplineSurface][fixbug]\") {\n\tTopoFace face;\n\tOCCTIO::OCCTTool::Read(face, INPUT_PATH_PREFIX\"face.brep\");\n\tauto surf = TopoTool::Surface(face);\n\tauto bsp = std::dynamic_pointer_cast<Geom3BSplineSurface>(surf);\n\tbsp->InsertUKnot(0.23, 1, 0.0, true);\n\tbool bWriteresult = OCCTIO::OCCTTool::Write(face, OUTPUT_PATH_PREFIX\"result.brep\");\n\tCHECK(bWriteresult == true);\n}\nTEST_CASE(\"case1: Geom3BSplineSurface::Geom3BSplineSurface() \", \"[geometry][Geom3BSplineSurface][p1]\") {\n\tArray2<Point3> poles(5, 4);\n\tpoles(0, 0).SetCoord(0.0, 0.0, 0.0);\n\tpoles(0, 1).SetCoord(0.0, 1.1, 2.0);\n\tpoles(0, 2).SetCoord(0.0, 2.3, 1.0);\n\tpoles(0, 3).SetCoord(0.0, 3.1, 1.5);\n\tpoles(1, 0).SetCoord(1.1, 0.1, 2.0);\n\tpoles(1, 1).SetCoord(1.2, 1.0, 0.0);\n\tpoles(1, 2).SetCoord(1.3, 2.1, -1.0);\n\tpoles(1, 3).SetCoord(1.23, 3.04, 1.32);\n\tpoles(2, 0).SetCoord(2.3, 0.1, -2.0);\n\tpoles(2, 1).SetCoord(2.1, 1.4, 2.0);\n\tpoles(2, 2).SetCoord(2.2, 2.1, 1.0);\n\tpoles(2, 3).SetCoord(2.23, 3.22, 1.26);\n\tpoles(3, 0).SetCoord(3.13, 0.2, 0.0);\n\tpoles(3, 1).SetCoord(3.12, 1.1, 0.0);\n\tpoles(3, 2).SetCoord(3.21, 2.1, 1.0);\n\tpoles(3, 3).SetCoord(3.33, 3.21, -1.2);\n\tpoles(4, 0).SetCoord(4.9, 4.93, 0.31);\n\tpoles(4, 1).SetCoord(5.3, 4.73, 0.33);\n\tpoles(4, 2).SetCoord(5.1, 4.43, -1.31);\n\tpoles(4, 3).SetCoord(9.2, 4.65, 3.31);\n\tstd::vector<double> uknots = { 0.0, 0.5, 1.0 };\n\tstd::vector<int> umults = { 4, 1, 4 };\n\tstd::vector<double> vknots = { 0.0, 0.5, 1.0 };\n\tstd::vector<int> vmults = { 3, 1, 3 };\n\tstd::shared_ptr<Geom3BSplineSurface> s = std::make_shared<Geom3BSplineSurface>(poles, uknots, vknots, umults, vmults, 3, 2);\n\tTopoFace face = MakeFace(s,0.001);\n\tbool bWriteresult = OCCTIO::OCCTTool::Write(face, OUTPUT_PATH_PREFIX\"Geom3BSplineSurface_case1.brep\");\n\tCHECK(bWriteresult == true);\n\tAMCAX::GlobalProperty prop;\n\tAMCAX::BRepGlobalProperty::SurfaceProperties(face, prop);\n\tCHECK(prop.Mass() == Approx( 21.3633));\n}\n#include<catch.hpp>\n#include<testHelper.h>\n#include <modeling/MakeFace.hpp>\n#include <geometry/Geom3BSplineSurface.hpp>\n#include <topology/TopoFace.hpp>\n#include <topology/TopoTool.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"bug1: Geom3BSplineSurface::InsertUKnot() \", \"[geometry][Geom3BSplineSurface][fixbug]\") {\n\tTopoFace face;\n\tOCCTIO::OCCTTool::Read(face, INPUT_PATH_PREFIX\"face.brep\");\n\tauto surf = TopoTool::Surface(face);\n\tauto bsp = std::dynamic_pointer_cast<Geom3BSplineSurface>(surf);\n\tbsp->InsertUKnot(0.23, 1, 0.0, true);\n\tbool bWriteresult = OCCTIO::OCCTTool::Write(face, OUTPUT_PATH_PREFIX\"result.brep\");\n\tCHECK(bWriteresult == true);\n}\nTEST_CASE(\"case1: Geom3BSplineSurface::Geom3BSplineSurface() \", \"[geometry][Geom3BSplineSurface][p1]\") {\n\tArray2<Point3> poles(5, 4);\n\tpoles(0, 0).SetCoord(0.0, 0.0, 0.0);\n\tpoles(0, 1).SetCoord(0.0, 1.1, 2.0);\n\tpoles(0, 2).SetCoord(0.0, 2.3, 1.0);\n\tpoles(0, 3).SetCoord(0.0, 3.1, 1.5);\n\tpoles(1, 0).SetCoord(1.1, 0.1, 2.0);\n\tpoles(1, 1).SetCoord(1.2, 1.0, 0.0);\n\tpoles(1, 2).SetCoord(1.3, 2.1, -1.0);\n\tpoles(1, 3).SetCoord(1.23, 3.04, 1.32);\n\tpoles(2, 0).SetCoord(2.3, 0.1, -2.0);\n\tpoles(2, 1).SetCoord(2.1, 1.4, 2.0);\n\tpoles(2, 2).SetCoord(2.2, 2.1, 1.0);\n\tpoles(2, 3).SetCoord(2.23, 3.22, 1.26);\n\tpoles(3, 0).SetCoord(3.13, 0.2, 0.0);\n\tpoles(3, 1).SetCoord(3.12, 1.1, 0.0);\n\tpoles(3, 2).SetCoord(3.21, 2.1, 1.0);\n\tpoles(3, 3).SetCoord(3.33, 3.21, -1.2);\n\tpoles(4, 0).SetCoord(4.9, 4.93, 0.31);\n\tpoles(4, 1).SetCoord(5.3, 4.73, 0.33);\n\tpoles(4, 2).SetCoord(5.1, 4.43, -1.31);\n\tpoles(4, 3).SetCoord(9.2, 4.65, 3.31);\n\tstd::vector<double> uknots = { 0.0, 0.5, 1.0 };\n\tstd::vector<int> umults = { 4, 1, 4 };\n\tstd::vector<double> vknots = { 0.0, 0.5, 1.0 };\n\tstd::vector<int> vmults = { 3, 1, 3 };\n\tstd::shared_ptr<Geom3BSplineSurface> s = std::make_shared<Geom3BSplineSurface>(poles, uknots, vknots, umults, vmults, 3, 2);\n\tTopoFace face = MakeFace(s,0.001);\n\tbool bWriteresult = OCCTIO::OCCTTool::Write(face, OUTPUT_PATH_PREFIX\"Geom3BSplineSurface_case1.brep\");\n\tCHECK(bWriteresult == true);\n\tAMCAX::GlobalProperty prop;\n\tAMCAX::BRepGlobalProperty::SurfaceProperties(face, prop);\n\tCHECK(prop.Mass() == Approx( 21.3633));\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API Geom3BSplineCurve(const std::vector<Point3>& pts, const std::vector<double>& weights, const std::vector<double>& knots, const std::vector<int>& multiplicities, int degree, bool isPeriodic = false, bool checkRational = true)\t @param checkRational To check whether the weights are rational\n\t @param isPeriodic Set the curve is periodic or not\n\t @param degree The degree of curve\n\t @param multiplicities The multiplicities\n\t @param knots The knots\n\t @param weights The weights\n\t @param pts The points\n\t @brief Construct a rational B spline curve from point, weights, knots and multiplicities with a given degree\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/Geom3BSplineCurve.hpp>\n#include <geometry/Geom3BSplineSurface.hpp>\n#include <topology/TopoFace.hpp>\n#include <topology/TopoTool.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"bug1: Geom3BSplineCurve \", \"[geometry][Geom3BSplineCurve][fixbug]\") {\n\tstd::stringstream output1,output2;\n\tstd::vector<Point3> poles{ Point3(0.0, 0.0, 0.0), Point3(0.0, 1.0, 0.0), Point3(0.0, 2.0, 0.0), Point3(0.0, 3.0, 0.0), Point3(0.0, 4.0, 0.0) };\n\tstd::vector<double> knots{ 0.0, 1.0, 2.0, 3.0 };\n\tstd::vector<int> mults{ 2, 2, 2, 2 };\n\tauto bc = std::make_shared<Geom3BSplineCurve>(poles, knots, mults, 2);\n\tdouble last = bc->LastParameter();\n\tstd::cout << bc->Value(last) << '\n';\n\tstd::cout << bc->DN(last, 0) << '\n';\n\toutput1 << bc->Value(last) << '\n';\n\toutput2 << bc->DN(last, 0) << '\n';\n\tauto case1 = output1.str();\n\tauto case2 = output2.str();\n\tauto expectValue = \"0 3 0\";\n\tauto expectDN = \"0 3 0\";\n\tCHECK(case1.find(expectValue) != std::string::npos);\n\tCHECK(case2.find(expectDN) != std::string::npos);\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API Geom2Parabola(const Axis2& directrix, const Point2& focus, bool isRight = true)\t @param isRight Is the local frame right-handed\n\t @param focus The focus\n\t @param directrix The directrix\n\t @brief Construct from a directrix and a focus\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <geometry/Geom2Parabola.hpp>\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Test Geom2Parabola\", \"[math][Geom2Parabola][P1]\")\n{\n\tAxis2 axis;\n\tdouble focal = 5.0;\n\tbool isRight = true;\n\tGeom2Parabola g2p(axis, focal, isRight);\n\tSECTION(\"FocalParameter\")\n\t{\n\t\tdouble FP = g2p.FocalParameter();\n\t\tdouble fp = 2 * focal;\n\t\tCHECK(FP == fp);\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API Geom2Parabola(const Frame2& frame, double focal)\t @param focal The focal length\n\t @param frame The local frame\n\t @brief Construct from a local frame and a focal length\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <geometry/Geom2Parabola.hpp>\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Test Geom2Parabola\", \"[math][Geom2Parabola][P1]\")\n{\n\tAxis2 axis;\n\tdouble focal = 5.0;\n\tbool isRight = true;\n\tGeom2Parabola g2p(axis, focal, isRight);\n\tSECTION(\"FocalParameter\")\n\t{\n\t\tdouble FP = g2p.FocalParameter();\n\t\tdouble fp = 2 * focal;\n\t\tCHECK(FP == fp);\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API Geom2Parabola(const Axis2& axis, double focal, bool isRight = true)\t @param isRight Is the local frame right-handed\n\t @param focal The focal length\n\t @param axis The axis\n\t @brief Construct from an axis and a focal length\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <geometry/Geom2Parabola.hpp>\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Test Geom2Parabola\", \"[math][Geom2Parabola][P1]\")\n{\n\tAxis2 axis;\n\tdouble focal = 5.0;\n\tbool isRight = true;\n\tGeom2Parabola g2p(axis, focal, isRight);\n\tSECTION(\"FocalParameter\")\n\t{\n\t\tdouble FP = g2p.FocalParameter();\n\t\tdouble fp = 2 * focal;\n\t\tCHECK(FP == fp);\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "Geom2Parabola()\t @brief Default constructor\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <geometry/Geom2Parabola.hpp>\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Test Geom2Parabola\", \"[math][Geom2Parabola][P1]\")\n{\n\tAxis2 axis;\n\tdouble focal = 5.0;\n\tbool isRight = true;\n\tGeom2Parabola g2p(axis, focal, isRight);\n\tSECTION(\"SemilatusRectum\")\n\t{\n\t\tdouble SR = g2p.SemilatusRectum();\n\t\tdouble sr = 2 * focal;\n\t\tCHECK(SR == sr);\n\t}\n}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API Geom2Hyperbola(const Frame2& frame, double major, double minor)\t @param minor The minor radius\n\t @param major The major radius\n\t @param frame The local frame\n\t @brief Construct from a local frame, a major radius and a minor radius\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <math/EllipseT.hpp>\n#include <geometry/Geom2Hyperbola.hpp>\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Test Geom2Hyperbola\", \"[math][Geom2Hyperbola][P1]\")\n{\n\tAxis2 axis;\n\tdouble major = 5.0;\n\tdouble minor = 4.0;\n\tbool isRight = true;\n\tGeom2Hyperbola g2h(axis, major, minor, isRight);\n\tSECTION(\"FocalParameter\")\n\t{\n\t\tdouble FP = g2h.FocalParameter();\n\t\tdouble focal = 2 * sqrt(major * major + minor * minor);\n\t\tdouble fp = 2 * minor * minor / focal;;\n\t\tCHECK(FP == fp);\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API Geom2Hyperbola(const Axis2& axis, double major, double minor, bool isRight = true)\t @param isRight Is the local frame right-handed\n\t @param minor The minor radius\n\t @param major The major radius\n\t @param axis The axis\n\t @brief Construct from an axis, a major radius and a minor radius\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <math/EllipseT.hpp>\n#include <geometry/Geom2Hyperbola.hpp>\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Test Geom2Hyperbola\", \"[math][Geom2Hyperbola][P1]\")\n{\n\tAxis2 axis;\n\tdouble major = 5.0;\n\tdouble minor = 4.0;\n\tbool isRight = true;\n\tGeom2Hyperbola g2h(axis, major, minor, isRight);\n\tSECTION(\"FocalParameter\")\n\t{\n\t\tdouble FP = g2h.FocalParameter();\n\t\tdouble focal = 2 * sqrt(major * major + minor * minor);\n\t\tdouble fp = 2 * minor * minor / focal;;\n\t\tCHECK(FP == fp);\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API Geom3Parabola(const Axis3& directrix, const Point3& focus)\t @param focus The focus\n\t @param directrix The directrix\n\t @brief Construct from a directrix and a focus\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <geometry/Geom3Parabola.hpp>\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Test Geom3Parabola\", \"[math][Geom3Parabola][P1]\")\n{\n\tFrame3 frame;\n\tdouble focal = 5.0;\n\tGeom3Parabola g3p(frame, focal);\n\tSECTION(\"FocalParameter\")\n\t{\n\t\tdouble FP = g3p.FocalParameter();\n\t\tdouble fp = 2 * focal;\n\t\tCHECK(FP == fp);\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API Geom3Parabola(const Frame3& frame, double focal)\t @param focal The focal length\n\t @param frame The local frame\n\t @brief Construct from a local frame and a focal length\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <geometry/Geom3Parabola.hpp>\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Test Geom3Parabola\", \"[math][Geom3Parabola][P1]\")\n{\n\tFrame3 frame;\n\tdouble focal = 5.0;\n\tGeom3Parabola g3p(frame, focal);\n\tSECTION(\"FocalParameter\")\n\t{\n\t\tdouble FP = g3p.FocalParameter();\n\t\tdouble fp = 2 * focal;\n\t\tCHECK(FP == fp);\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API explicit Geom3Parabola(const Parabola3& p)\t @param p The parabola\n\t @brief Construct from a parabola\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <geometry/Geom3Parabola.hpp>\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Test Geom3Parabola\", \"[math][Geom3Parabola][P1]\")\n{\n\tFrame3 frame;\n\tdouble focal = 5.0;\n\tGeom3Parabola g3p(frame, focal);\n\tSECTION(\"FocalParameter\")\n\t{\n\t\tdouble FP = g3p.FocalParameter();\n\t\tdouble fp = 2 * focal;\n\t\tCHECK(FP == fp);\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] AMCAX_API double SemilatusRectum()\t @return The semilatus rectum\n\t          Semilatus rectum = 2 * focalLength\n\t @details The semilatus rectum of parabola is half of the length of the chord through a focus parallel to the directrix.\n\t @brief Get the semilatus rectum of the parabola\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <geometry/Geom3Parabola.hpp>\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Test Geom3Parabola\", \"[math][Geom3Parabola][P1]\")\n{\n\tFrame3 frame;\n\tdouble focal = 5.0;\n\tGeom3Parabola g3p(frame, focal);\n\tSECTION(\"SemilatusRectum\")\n\t{\n\t\tdouble SR = g3p.SemilatusRectum();\n\t\tdouble sr = 2 * focal;\n\t\tCHECK(SR == sr);\n\t}\n}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] AMCAX_API double FocalParameter()\t @return The focal parameter\n\t          Focal parameter = 2 * focalLength.\n\t @details The focal parameter of parabola is the distance from the focus to the directrix.\n\t @brief Get the focal parameter of the parabola\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <geometry/Geom3Parabola.hpp>\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Test Geom3Parabola\", \"[math][Geom3Parabola][P1]\")\n{\n\tFrame3 frame;\n\tdouble focal = 5.0;\n\tGeom3Parabola g3p(frame, focal);\n\tSECTION(\"FocalParameter\")\n\t{\n\t\tdouble FP = g3p.FocalParameter();\n\t\tdouble fp = 2 * focal;\n\t\tCHECK(FP == fp);\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API Geom2Ellipse(const Frame2& frame, double major, double minor)\t @param minor The minor radius\n\t @param major The major radius\n\t @param frame The local frame\n\t @brief Construct from a local frame, a major radius and a minor radius\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <math/EllipseT.hpp>\n#include <geometry/Geom2Ellipse.hpp>\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Test Geom2Ellipse\", \"[math][Geom2Ellipse][P1]\")\n{\n\tAxis2 axis;\n\tdouble major = 5.0;\n\tdouble minor = 4.0;\n\tbool isRight = true;\n\tEllipse2 ellipse(axis, major, minor, isRight);\n\tGeom2Ellipse g2e(ellipse);\n\tSECTION(\"FocalParameter\")\n\t{\n\t\tdouble FP = g2e.FocalParameter();\n\t\tdouble focal = 2 * sqrt(major * major - minor * minor);\n\t\tdouble fp = 2 * minor * minor / focal;;\n\t\tCHECK(FP == fp);\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API Geom2Ellipse(const Axis2& majorAxis, double major, double minor, bool isRight)\t @param isRight Is the local frame right-handed\n\t @param minor The minor radius\n\t @param major The major radius\n\t @param majorAxis The axis\n\t @brief Construct from an axis, a major radius and a minor radius\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <math/EllipseT.hpp>\n#include <geometry/Geom2Ellipse.hpp>\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Test Geom2Ellipse\", \"[math][Geom2Ellipse][P1]\")\n{\n\tAxis2 axis;\n\tdouble major = 5.0;\n\tdouble minor = 4.0;\n\tbool isRight = true;\n\tEllipse2 ellipse(axis, major, minor, isRight);\n\tGeom2Ellipse g2e(ellipse);\n\tSECTION(\"FocalParameter\")\n\t{\n\t\tdouble FP = g2e.FocalParameter();\n\t\tdouble focal = 2 * sqrt(major * major - minor * minor);\n\t\tdouble fp = 2 * minor * minor / focal;;\n\t\tCHECK(FP == fp);\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API explicit Geom2Ellipse(const Ellipse2& e)\t @param e The ellipse\n\t @brief Construct from an ellipse\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <math/EllipseT.hpp>\n#include <geometry/Geom2Ellipse.hpp>\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Test Geom2Ellipse\", \"[math][Geom2Ellipse][P1]\")\n{\n\tAxis2 axis;\n\tdouble major = 5.0;\n\tdouble minor = 4.0;\n\tbool isRight = true;\n\tEllipse2 ellipse(axis, major, minor, isRight);\n\tGeom2Ellipse g2e(ellipse);\n\tSECTION(\"FocalParameter\")\n\t{\n\t\tdouble FP = g2e.FocalParameter();\n\t\tdouble focal = 2 * sqrt(major * major - minor * minor);\n\t\tdouble fp = 2 * minor * minor / focal;;\n\t\tCHECK(FP == fp);\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "Geom2Ellipse()\t @brief Default constructor\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <math/EllipseT.hpp>\n#include <geometry/Geom2Ellipse.hpp>\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Test Geom2Ellipse\", \"[math][Geom2Ellipse][P1]\")\n{\n\tAxis2 axis;\n\tdouble major = 5.0;\n\tdouble minor = 4.0;\n\tbool isRight = true;\n\tEllipse2 ellipse(axis, major, minor, isRight);\n\tGeom2Ellipse g2e(ellipse);\n\tSECTION(\"FocalParameter\")\n\t{\n\t\tdouble FP = g2e.FocalParameter();\n\t\tdouble focal = 2 * sqrt(major * major - minor * minor);\n\t\tdouble fp = 2 * minor * minor / focal;;\n\t\tCHECK(FP == fp);\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API double Parameter()\t @return The parameter of the point\n\t @brief Get the parameter of the point\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/MakeGeom2Circle.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/ComputePointsAbscissa.hpp>\n#include <geometry/MakeGeom2Hyperbola.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/MakeGeom2Ellipse.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/AdaptorGeom3Curve.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <geometry/MakeGeom3Hyperbola.hpp>\n#include <geometry/MakeGeom3Ellipse.hpp>\nTEST_CASE(\"bug1: ComputePointsAbscissa \", \"[geometry][ComputePointsAbscissa][fixbug]\")\n{\n    double r = 0.0;\n    std::shared_ptr<Geom2Curve> c = MakeGeom2Circle(Point2(0.0, 0.0), 0.0).Value();\n    AdaptorGeom2Curve circle(c);\n    ComputePointsAbscissa cpa(circle, 0.0, 0.0);\n    double angle1 = 0;\n    double x = r * cos(angle1);\n    double y = r * sin(angle1);\n    double param = cpa.Parameter();\n    Point2 s = circle.Value(param);\n    Point2 s1(x, y);\n    CHECK(angle1 == cpa.Parameter());\n    CHECK(s.X() == s1.X());\n    CHECK(s.Y() == s1.Y());\n    CHECK(ComputePointsAbscissa::Length(circle) == 0.0);\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API ComputePointsAbscissa(const Adaptor2Curve& c, double abscissa, double u0, double ui, double tol)\t @param tol The tolerance\n\t @param ui The initial guess of the parameter\n\t @param u0 The starting parameter\n\t @param abscissa The arc length\n\t @param c The curve\n\t @brief Compute the parameter of a point on a 2D curve with given arc length, an initial guess, and a tolerance\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/MakeGeom2Circle.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/ComputePointsAbscissa.hpp>\n#include <geometry/MakeGeom2Hyperbola.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/MakeGeom2Ellipse.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/AdaptorGeom3Curve.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <geometry/MakeGeom3Hyperbola.hpp>\n#include <geometry/MakeGeom3Ellipse.hpp>\nTEST_CASE(\"bug1: ComputePointsAbscissa \", \"[geometry][ComputePointsAbscissa][fixbug]\")\n{\n    double r = 0.0;\n    std::shared_ptr<Geom2Curve> c = MakeGeom2Circle(Point2(0.0, 0.0), 0.0).Value();\n    AdaptorGeom2Curve circle(c);\n    ComputePointsAbscissa cpa(circle, 0.0, 0.0);\n    double angle1 = 0;\n    double x = r * cos(angle1);\n    double y = r * sin(angle1);\n    double param = cpa.Parameter();\n    Point2 s = circle.Value(param);\n    Point2 s1(x, y);\n    CHECK(angle1 == cpa.Parameter());\n    CHECK(s.X() == s1.X());\n    CHECK(s.Y() == s1.Y());\n    CHECK(ComputePointsAbscissa::Length(circle) == 0.0);\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API ComputePointsAbscissa(const Adaptor3Curve& c, double abscissa, double u0, double ui, double tol)\t @param tol The tolerance\n\t @param ui The initial guess of the parameter\n\t @param u0 The starting parameter\n\t @param abscissa The arc length\n\t @param c The curve\n\t @brief Compute the parameter of a point on a 3D curve with given arc length, an initial guess, and a tolerance\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/MakeGeom2Circle.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/ComputePointsAbscissa.hpp>\n#include <geometry/MakeGeom2Hyperbola.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/MakeGeom2Ellipse.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/AdaptorGeom3Curve.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <geometry/MakeGeom3Hyperbola.hpp>\n#include <geometry/MakeGeom3Ellipse.hpp>\nTEST_CASE(\"bug2: ComputePointsAbscissa \", \"[geometry][ComputePointsAbscissa][fixbug]\")\n{\n\tSECTION(\"arc length-3D\")\n{\n    Frame3 frame;\n    double major = 5.0;\n    double minor = 4.0;\n    bool isRight = true;\n    std::shared_ptr< Geom3Hyperbola >h1 = MakeGeom3Hyperbola(frame, major, minor);\n    AdaptorGeom3Curve hyperbola(h1);\n    ComputePointsAbscissa cpa3(hyperbola, 1.0, 0.0);\n    double param3 = cpa3.Parameter();\n    Point3 point1 = hyperbola.Value(param3);\n    CHECK(cpa3.Parameter());\n    MakeEdge edge1(h1, 0.0, param3);\n    CHECK(BRepClassificationTools::IsPointInOnEdge(edge1, point1, 0.001) == true);\n}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API ComputePointsAbscissa(const Adaptor2Curve& c, double abscissa, double u0, double ui)\t @param ui The initial guess of the parameter\n\t @param u0 The starting parameter\n\t @param abscissa The arc length\n\t @param c The curve\n\t @brief Compute the parameter of a point on a 2D curve with given arc length and an initial guess\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/MakeGeom2Circle.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/ComputePointsAbscissa.hpp>\n#include <geometry/MakeGeom2Hyperbola.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/MakeGeom2Ellipse.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/AdaptorGeom3Curve.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <geometry/MakeGeom3Hyperbola.hpp>\n#include <geometry/MakeGeom3Ellipse.hpp>\nTEST_CASE(\"bug1: ComputePointsAbscissa \", \"[geometry][ComputePointsAbscissa][fixbug]\")\n{\n    double r = 0.0;\n    std::shared_ptr<Geom2Curve> c = MakeGeom2Circle(Point2(0.0, 0.0), 0.0).Value();\n    AdaptorGeom2Curve circle(c);\n    ComputePointsAbscissa cpa(circle, 0.0, 0.0);\n    double angle1 = 0;\n    double x = r * cos(angle1);\n    double y = r * sin(angle1);\n    double param = cpa.Parameter();\n    Point2 s = circle.Value(param);\n    Point2 s1(x, y);\n    CHECK(angle1 == cpa.Parameter());\n    CHECK(s.X() == s1.X());\n    CHECK(s.Y() == s1.Y());\n    CHECK(ComputePointsAbscissa::Length(circle) == 0.0);\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API ComputePointsAbscissa(const Adaptor3Curve& c, double abscissa, double u0, double ui)\t @param ui The initial guess of the parameter\n\t @param u0 The starting parameter\n\t @param abscissa The arc length\n\t @param c The curve\n\t @brief Compute the parameter of a point on a 3D curve with given arc length and an initial guess\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/MakeGeom2Circle.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/ComputePointsAbscissa.hpp>\n#include <geometry/MakeGeom2Hyperbola.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/MakeGeom2Ellipse.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/AdaptorGeom3Curve.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <geometry/MakeGeom3Hyperbola.hpp>\n#include <geometry/MakeGeom3Ellipse.hpp>\nTEST_CASE(\"bug2: ComputePointsAbscissa \", \"[geometry][ComputePointsAbscissa][fixbug]\")\n{\n\tSECTION(\"arc length-3D\")\n{\n    Frame3 frame;\n    double major = 5.0;\n    double minor = 4.0;\n    bool isRight = true;\n    std::shared_ptr< Geom3Hyperbola >h1 = MakeGeom3Hyperbola(frame, major, minor);\n    AdaptorGeom3Curve hyperbola(h1);\n    ComputePointsAbscissa cpa3(hyperbola, 1.0, 0.0);\n    double param3 = cpa3.Parameter();\n    Point3 point1 = hyperbola.Value(param3);\n    CHECK(cpa3.Parameter());\n    MakeEdge edge1(h1, 0.0, param3);\n    CHECK(BRepClassificationTools::IsPointInOnEdge(edge1, point1, 0.001) == true);\n}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API ComputePointsAbscissa(const Adaptor2Curve& c, double abscissa, double u0)\t @param u0 The starting parameter\n\t @param abscissa The arc length\n\t @param c The curve\n\t @brief Compute the parameter of a point on a 2D curve with given arc length\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/MakeGeom2Circle.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/ComputePointsAbscissa.hpp>\n#include <geometry/MakeGeom2Hyperbola.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/MakeGeom2Ellipse.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/AdaptorGeom3Curve.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <geometry/MakeGeom3Hyperbola.hpp>\n#include <geometry/MakeGeom3Ellipse.hpp>\nTEST_CASE(\"bug1: ComputePointsAbscissa \", \"[geometry][ComputePointsAbscissa][fixbug]\")\n{\n    double r = 0.0;\n    std::shared_ptr<Geom2Curve> c = MakeGeom2Circle(Point2(0.0, 0.0), 0.0).Value();\n    AdaptorGeom2Curve circle(c);\n    ComputePointsAbscissa cpa(circle, 0.0, 0.0);\n    double angle1 = 0;\n    double x = r * cos(angle1);\n    double y = r * sin(angle1);\n    double param = cpa.Parameter();\n    Point2 s = circle.Value(param);\n    Point2 s1(x, y);\n    CHECK(angle1 == cpa.Parameter());\n    CHECK(s.X() == s1.X());\n    CHECK(s.Y() == s1.Y());\n    CHECK(ComputePointsAbscissa::Length(circle) == 0.0);\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API ComputePointsAbscissa(const Adaptor3Curve& c, double abscissa, double u0)\t @param u0 The starting parameter\n\t @param abscissa The arc length\n\t @param c The curve\n\t @brief Compute the parameter of a point on a 3D curve with given arc length\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/MakeGeom2Circle.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/ComputePointsAbscissa.hpp>\n#include <geometry/MakeGeom2Hyperbola.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/MakeGeom2Ellipse.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/AdaptorGeom3Curve.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <geometry/MakeGeom3Hyperbola.hpp>\n#include <geometry/MakeGeom3Ellipse.hpp>\nTEST_CASE(\"bug1: ComputePointsAbscissa \", \"[geometry][ComputePointsAbscissa][fixbug]\")\n{\n    double r = 0.0;\n    std::shared_ptr<Geom2Curve> c = MakeGeom2Circle(Point2(0.0, 0.0), 0.0).Value();\n    AdaptorGeom2Curve circle(c);\n    ComputePointsAbscissa cpa(circle, 0.0, 0.0);\n    double angle1 = 0;\n    double x = r * cos(angle1);\n    double y = r * sin(angle1);\n    double param = cpa.Parameter();\n    Point2 s = circle.Value(param);\n    Point2 s1(x, y);\n    CHECK(angle1 == cpa.Parameter());\n    CHECK(s.X() == s1.X());\n    CHECK(s.Y() == s1.Y());\n    CHECK(ComputePointsAbscissa::Length(circle) == 0.0);\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API ComputePointsAbscissa(double tol, const Adaptor2Curve& c, double abscissa, double u0)\t @param u0 The starting parameter\n\t @param abscissa The arc length\n\t @param c The curve\n\t @param tol The tolerance\n\t @brief Compute the parameter of a point on a 2D curve with given arc length and a tolerance\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/MakeGeom2Circle.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/ComputePointsAbscissa.hpp>\n#include <geometry/MakeGeom2Hyperbola.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/MakeGeom2Ellipse.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/AdaptorGeom3Curve.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <geometry/MakeGeom3Hyperbola.hpp>\n#include <geometry/MakeGeom3Ellipse.hpp>\nTEST_CASE(\"bug1: ComputePointsAbscissa \", \"[geometry][ComputePointsAbscissa][fixbug]\")\n{\n    double r = 0.0;\n    std::shared_ptr<Geom2Curve> c = MakeGeom2Circle(Point2(0.0, 0.0), 0.0).Value();\n    AdaptorGeom2Curve circle(c);\n    ComputePointsAbscissa cpa(circle, 0.0, 0.0);\n    double angle1 = 0;\n    double x = r * cos(angle1);\n    double y = r * sin(angle1);\n    double param = cpa.Parameter();\n    Point2 s = circle.Value(param);\n    Point2 s1(x, y);\n    CHECK(angle1 == cpa.Parameter());\n    CHECK(s.X() == s1.X());\n    CHECK(s.Y() == s1.Y());\n    CHECK(ComputePointsAbscissa::Length(circle) == 0.0);\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API ComputePointsAbscissa(double tol, const Adaptor3Curve& c, double abscissa, double u0)\t @param u0 The starting parameter\n\t @param abscissa The arc length\n\t @param c The curve\n\t @param tol The tolerance\n\t @brief Compute the parameter of a point on a 3D curve with given arc length and a tolerance\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/MakeGeom2Circle.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/ComputePointsAbscissa.hpp>\n#include <geometry/MakeGeom2Hyperbola.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/MakeGeom2Ellipse.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/AdaptorGeom3Curve.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <geometry/MakeGeom3Hyperbola.hpp>\n#include <geometry/MakeGeom3Ellipse.hpp>\nTEST_CASE(\"bug2: ComputePointsAbscissa \", \"[geometry][ComputePointsAbscissa][fixbug]\")\n{\n\tSECTION(\"arc length and tolerance-3D\")\n{\n    Frame3 frame;\n    double major = 5.0;\n    double minor = 4.0;\n    bool isRight = true;\n    std::shared_ptr< Geom3Hyperbola >h1 = MakeGeom3Hyperbola(frame, major, minor);\n    AdaptorGeom3Curve hyperbola(h1);\n    ComputePointsAbscissa cpa3(Precision::Confusion(), hyperbola, 1.0, 0.0);\n    double param3 = cpa3.Parameter();\n    Point3 point1(hyperbola.Value(param3));\n    CHECK(cpa3.Parameter());\n    MakeEdge edge1(h1, 0.0, param3);\n    CHECK(BRepClassificationTools::IsPointInOnEdge(edge1, point1, 0.001) == true);\n}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API double Parameter()\t @return The parameter of the point\n\t @brief Get the parameter of the point\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/MakeGeom2Circle.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/ComputePointsAbscissa.hpp>\n#include <geometry/MakeGeom3Circle.hpp>\n#include <geometry/AdaptorGeom3Curve.hpp>\n#include <geometry/MakeGeom2Hyperbola.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/MakeGeom2Ellipse.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <geometry/MakeGeom3Ellipse.hpp>\n#include <geometry/MakeGeom3Hyperbola.hpp>\n#include <geometry/Geom2Line.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include<modeling/MakeEdge.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/MakeGeom2Parabola.hpp>\n#include <geometry/MakeGeom3Parabola.hpp>\n#include <geometry/Geom2BezierCurve.hpp>\n#include <geometry/Geom3BezierCurve.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2OffsetCurve.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\nTEST_CASE(\"test that the arc length is 0 - given arc length - 2D\", \"[geometry][ComputePointsAbscissa][case26]\")\n{\n\tSECTION(\"circle\")\n    {\n        double r = 2.0;\n        double l = 0.0;\n        std::shared_ptr<Geom2Curve> c = MakeGeom2Circle(Point2(0.0, 0.0), 2.0).Value();\n        AdaptorGeom2Curve circle(c);\n        ComputePointsAbscissa cpa(circle, 0.0, 0.0);\n        double angle1 = l / r;\n        double x = r * cos(angle1);\n        double y = r * sin(angle1);\n        double param = cpa.Parameter();\n        Point2 s = circle.Value(param);\n        Point2 s1(x, y);\n        CHECK(angle1 == cpa.Parameter());\n        CHECK(s.X() == s1.X());\n        CHECK(s.Y() == s1.Y());\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API ComputePointsAbscissa(const Adaptor2Curve& c, double abscissa, double u0, double ui, double tol)\t @param tol The tolerance\n\t @param ui The initial guess of the parameter\n\t @param u0 The starting parameter\n\t @param abscissa The arc length\n\t @param c The curve\n\t @brief Compute the parameter of a point on a 2D curve with given arc length, an initial guess, and a tolerance\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/MakeGeom2Circle.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/ComputePointsAbscissa.hpp>\n#include <geometry/MakeGeom3Circle.hpp>\n#include <geometry/AdaptorGeom3Curve.hpp>\n#include <geometry/MakeGeom2Hyperbola.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/MakeGeom2Ellipse.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <geometry/MakeGeom3Ellipse.hpp>\n#include <geometry/MakeGeom3Hyperbola.hpp>\n#include <geometry/Geom2Line.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include<modeling/MakeEdge.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/MakeGeom2Parabola.hpp>\n#include <geometry/MakeGeom3Parabola.hpp>\n#include <geometry/Geom2BezierCurve.hpp>\n#include <geometry/Geom3BezierCurve.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2OffsetCurve.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\nTEST_CASE(\"test that the arc length is 0 - given arc length - 2D\", \"[geometry][ComputePointsAbscissa][case26]\")\n{\n\tSECTION(\"circle\")\n    {\n        double r = 2.0;\n        double l = 0.0;\n        std::shared_ptr<Geom2Curve> c = MakeGeom2Circle(Point2(0.0, 0.0), 2.0).Value();\n        AdaptorGeom2Curve circle(c);\n        ComputePointsAbscissa cpa(circle, 0.0, 0.0);\n        double angle1 = l / r;\n        double x = r * cos(angle1);\n        double y = r * sin(angle1);\n        double param = cpa.Parameter();\n        Point2 s = circle.Value(param);\n        Point2 s1(x, y);\n        CHECK(angle1 == cpa.Parameter());\n        CHECK(s.X() == s1.X());\n        CHECK(s.Y() == s1.Y());\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API ComputePointsAbscissa(const Adaptor3Curve& c, double abscissa, double u0, double ui, double tol)\t @param tol The tolerance\n\t @param ui The initial guess of the parameter\n\t @param u0 The starting parameter\n\t @param abscissa The arc length\n\t @param c The curve\n\t @brief Compute the parameter of a point on a 3D curve with given arc length, an initial guess, and a tolerance\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/MakeGeom2Circle.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/ComputePointsAbscissa.hpp>\n#include <geometry/MakeGeom3Circle.hpp>\n#include <geometry/AdaptorGeom3Curve.hpp>\n#include <geometry/MakeGeom2Hyperbola.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/MakeGeom2Ellipse.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <geometry/MakeGeom3Ellipse.hpp>\n#include <geometry/MakeGeom3Hyperbola.hpp>\n#include <geometry/Geom2Line.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include<modeling/MakeEdge.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/MakeGeom2Parabola.hpp>\n#include <geometry/MakeGeom3Parabola.hpp>\n#include <geometry/Geom2BezierCurve.hpp>\n#include <geometry/Geom3BezierCurve.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2OffsetCurve.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\nTEST_CASE(\"test that the arc length is 0 - given arc length - 3D\", \"[geometry][ComputePointsAbscissa][case27]\")\n{\n\tSECTION(\"circle\")\n    {\n        Frame3 frame;\n        double r = 2.0;\n        double l = 0.0;\n        std::shared_ptr<Geom3Curve> c = MakeGeom3Circle(frame, r).Value();\n        AdaptorGeom3Curve circle(c);\n        ComputePointsAbscissa cpa(circle, 0.0, 0.0);\n        double angle1 = l / r;\n        double x = r * cos(angle1);\n        double y = r * sin(angle1);\n        double z = 0;\n        double param = cpa.Parameter();\n        Point3 s = circle.Value(param);\n        Point3 s1(x, y, z);\n        CHECK(angle1 == cpa.Parameter());\n        CHECK(s.X() == s1.X());\n        CHECK(s.Y() == s1.Y());\n        CHECK(s.Z() == s1.Z());\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API ComputePointsAbscissa(const Adaptor2Curve& c, double abscissa, double u0, double ui)\t @param ui The initial guess of the parameter\n\t @param u0 The starting parameter\n\t @param abscissa The arc length\n\t @param c The curve\n\t @brief Compute the parameter of a point on a 2D curve with given arc length and an initial guess\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/MakeGeom2Circle.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/ComputePointsAbscissa.hpp>\n#include <geometry/MakeGeom3Circle.hpp>\n#include <geometry/AdaptorGeom3Curve.hpp>\n#include <geometry/MakeGeom2Hyperbola.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/MakeGeom2Ellipse.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <geometry/MakeGeom3Ellipse.hpp>\n#include <geometry/MakeGeom3Hyperbola.hpp>\n#include <geometry/Geom2Line.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include<modeling/MakeEdge.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/MakeGeom2Parabola.hpp>\n#include <geometry/MakeGeom3Parabola.hpp>\n#include <geometry/Geom2BezierCurve.hpp>\n#include <geometry/Geom3BezierCurve.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2OffsetCurve.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\nTEST_CASE(\"test that the arc length is 0 - given arc length - 2D\", \"[geometry][ComputePointsAbscissa][case26]\")\n{\n\tSECTION(\"circle\")\n    {\n        double r = 2.0;\n        double l = 0.0;\n        std::shared_ptr<Geom2Curve> c = MakeGeom2Circle(Point2(0.0, 0.0), 2.0).Value();\n        AdaptorGeom2Curve circle(c);\n        ComputePointsAbscissa cpa(circle, 0.0, 0.0);\n        double angle1 = l / r;\n        double x = r * cos(angle1);\n        double y = r * sin(angle1);\n        double param = cpa.Parameter();\n        Point2 s = circle.Value(param);\n        Point2 s1(x, y);\n        CHECK(angle1 == cpa.Parameter());\n        CHECK(s.X() == s1.X());\n        CHECK(s.Y() == s1.Y());\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API ComputePointsAbscissa(const Adaptor3Curve& c, double abscissa, double u0, double ui)\t @param ui The initial guess of the parameter\n\t @param u0 The starting parameter\n\t @param abscissa The arc length\n\t @param c The curve\n\t @brief Compute the parameter of a point on a 3D curve with given arc length and an initial guess\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/MakeGeom2Circle.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/ComputePointsAbscissa.hpp>\n#include <geometry/MakeGeom3Circle.hpp>\n#include <geometry/AdaptorGeom3Curve.hpp>\n#include <geometry/MakeGeom2Hyperbola.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/MakeGeom2Ellipse.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <geometry/MakeGeom3Ellipse.hpp>\n#include <geometry/MakeGeom3Hyperbola.hpp>\n#include <geometry/Geom2Line.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include<modeling/MakeEdge.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/MakeGeom2Parabola.hpp>\n#include <geometry/MakeGeom3Parabola.hpp>\n#include <geometry/Geom2BezierCurve.hpp>\n#include <geometry/Geom3BezierCurve.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2OffsetCurve.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\nTEST_CASE(\"test that the arc length is 0 - given arc length - 3D\", \"[geometry][ComputePointsAbscissa][case27]\")\n{\n\tSECTION(\"circle\")\n    {\n        Frame3 frame;\n        double r = 2.0;\n        double l = 0.0;\n        std::shared_ptr<Geom3Curve> c = MakeGeom3Circle(frame, r).Value();\n        AdaptorGeom3Curve circle(c);\n        ComputePointsAbscissa cpa(circle, 0.0, 0.0);\n        double angle1 = l / r;\n        double x = r * cos(angle1);\n        double y = r * sin(angle1);\n        double z = 0;\n        double param = cpa.Parameter();\n        Point3 s = circle.Value(param);\n        Point3 s1(x, y, z);\n        CHECK(angle1 == cpa.Parameter());\n        CHECK(s.X() == s1.X());\n        CHECK(s.Y() == s1.Y());\n        CHECK(s.Z() == s1.Z());\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API ComputePointsAbscissa(const Adaptor2Curve& c, double abscissa, double u0)\t @param u0 The starting parameter\n\t @param abscissa The arc length\n\t @param c The curve\n\t @brief Compute the parameter of a point on a 2D curve with given arc length\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/MakeGeom2Circle.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/ComputePointsAbscissa.hpp>\n#include <geometry/MakeGeom3Circle.hpp>\n#include <geometry/AdaptorGeom3Curve.hpp>\n#include <geometry/MakeGeom2Hyperbola.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/MakeGeom2Ellipse.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <geometry/MakeGeom3Ellipse.hpp>\n#include <geometry/MakeGeom3Hyperbola.hpp>\n#include <geometry/Geom2Line.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include<modeling/MakeEdge.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/MakeGeom2Parabola.hpp>\n#include <geometry/MakeGeom3Parabola.hpp>\n#include <geometry/Geom2BezierCurve.hpp>\n#include <geometry/Geom3BezierCurve.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2OffsetCurve.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\nTEST_CASE(\"test that the arc length is 0 - given arc length - 2D\", \"[geometry][ComputePointsAbscissa][case26]\")\n{\n\tSECTION(\"circle\")\n    {\n        double r = 2.0;\n        double l = 0.0;\n        std::shared_ptr<Geom2Curve> c = MakeGeom2Circle(Point2(0.0, 0.0), 2.0).Value();\n        AdaptorGeom2Curve circle(c);\n        ComputePointsAbscissa cpa(circle, 0.0, 0.0);\n        double angle1 = l / r;\n        double x = r * cos(angle1);\n        double y = r * sin(angle1);\n        double param = cpa.Parameter();\n        Point2 s = circle.Value(param);\n        Point2 s1(x, y);\n        CHECK(angle1 == cpa.Parameter());\n        CHECK(s.X() == s1.X());\n        CHECK(s.Y() == s1.Y());\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API ComputePointsAbscissa(const Adaptor3Curve& c, double abscissa, double u0)\t @param u0 The starting parameter\n\t @param abscissa The arc length\n\t @param c The curve\n\t @brief Compute the parameter of a point on a 3D curve with given arc length\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/MakeGeom2Circle.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/ComputePointsAbscissa.hpp>\n#include <geometry/MakeGeom3Circle.hpp>\n#include <geometry/AdaptorGeom3Curve.hpp>\n#include <geometry/MakeGeom2Hyperbola.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/MakeGeom2Ellipse.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <geometry/MakeGeom3Ellipse.hpp>\n#include <geometry/MakeGeom3Hyperbola.hpp>\n#include <geometry/Geom2Line.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include<modeling/MakeEdge.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/MakeGeom2Parabola.hpp>\n#include <geometry/MakeGeom3Parabola.hpp>\n#include <geometry/Geom2BezierCurve.hpp>\n#include <geometry/Geom3BezierCurve.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2OffsetCurve.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\nTEST_CASE(\"test that the arc length is 0 - given arc length - 3D\", \"[geometry][ComputePointsAbscissa][case27]\")\n{\n\tSECTION(\"circle\")\n    {\n        Frame3 frame;\n        double r = 2.0;\n        double l = 0.0;\n        std::shared_ptr<Geom3Curve> c = MakeGeom3Circle(frame, r).Value();\n        AdaptorGeom3Curve circle(c);\n        ComputePointsAbscissa cpa(circle, 0.0, 0.0);\n        double angle1 = l / r;\n        double x = r * cos(angle1);\n        double y = r * sin(angle1);\n        double z = 0;\n        double param = cpa.Parameter();\n        Point3 s = circle.Value(param);\n        Point3 s1(x, y, z);\n        CHECK(angle1 == cpa.Parameter());\n        CHECK(s.X() == s1.X());\n        CHECK(s.Y() == s1.Y());\n        CHECK(s.Z() == s1.Z());\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API ComputePointsAbscissa(double tol, const Adaptor2Curve& c, double abscissa, double u0)\t @param u0 The starting parameter\n\t @param abscissa The arc length\n\t @param c The curve\n\t @param tol The tolerance\n\t @brief Compute the parameter of a point on a 2D curve with given arc length and a tolerance\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/MakeGeom2Circle.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/ComputePointsAbscissa.hpp>\n#include <geometry/MakeGeom3Circle.hpp>\n#include <geometry/AdaptorGeom3Curve.hpp>\n#include <geometry/MakeGeom2Hyperbola.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/MakeGeom2Ellipse.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <geometry/MakeGeom3Ellipse.hpp>\n#include <geometry/MakeGeom3Hyperbola.hpp>\n#include <geometry/Geom2Line.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include<modeling/MakeEdge.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/MakeGeom2Parabola.hpp>\n#include <geometry/MakeGeom3Parabola.hpp>\n#include <geometry/Geom2BezierCurve.hpp>\n#include <geometry/Geom3BezierCurve.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2OffsetCurve.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\nTEST_CASE(\"test that the arc length is 0 - given arc length - 2D\", \"[geometry][ComputePointsAbscissa][case26]\")\n{\n\tSECTION(\"circle\")\n    {\n        double r = 2.0;\n        double l = 0.0;\n        std::shared_ptr<Geom2Curve> c = MakeGeom2Circle(Point2(0.0, 0.0), 2.0).Value();\n        AdaptorGeom2Curve circle(c);\n        ComputePointsAbscissa cpa(circle, 0.0, 0.0);\n        double angle1 = l / r;\n        double x = r * cos(angle1);\n        double y = r * sin(angle1);\n        double param = cpa.Parameter();\n        Point2 s = circle.Value(param);\n        Point2 s1(x, y);\n        CHECK(angle1 == cpa.Parameter());\n        CHECK(s.X() == s1.X());\n        CHECK(s.Y() == s1.Y());\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API ComputePointsAbscissa(double tol, const Adaptor3Curve& c, double abscissa, double u0)\t @param u0 The starting parameter\n\t @param abscissa The arc length\n\t @param c The curve\n\t @param tol The tolerance\n\t @brief Compute the parameter of a point on a 3D curve with given arc length and a tolerance\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/MakeGeom2Circle.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/ComputePointsAbscissa.hpp>\n#include <geometry/MakeGeom3Circle.hpp>\n#include <geometry/AdaptorGeom3Curve.hpp>\n#include <geometry/MakeGeom2Hyperbola.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/MakeGeom2Ellipse.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <geometry/MakeGeom3Ellipse.hpp>\n#include <geometry/MakeGeom3Hyperbola.hpp>\n#include <geometry/Geom2Line.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include<modeling/MakeEdge.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/MakeGeom2Parabola.hpp>\n#include <geometry/MakeGeom3Parabola.hpp>\n#include <geometry/Geom2BezierCurve.hpp>\n#include <geometry/Geom3BezierCurve.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2OffsetCurve.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\nTEST_CASE(\"test that the arc length is 0 - given arc length - 3D\", \"[geometry][ComputePointsAbscissa][case27]\")\n{\n\tSECTION(\"circle\")\n    {\n        Frame3 frame;\n        double r = 2.0;\n        double l = 0.0;\n        std::shared_ptr<Geom3Curve> c = MakeGeom3Circle(frame, r).Value();\n        AdaptorGeom3Curve circle(c);\n        ComputePointsAbscissa cpa(circle, 0.0, 0.0);\n        double angle1 = l / r;\n        double x = r * cos(angle1);\n        double y = r * sin(angle1);\n        double z = 0;\n        double param = cpa.Parameter();\n        Point3 s = circle.Value(param);\n        Point3 s1(x, y, z);\n        CHECK(angle1 == cpa.Parameter());\n        CHECK(s.X() == s1.X());\n        CHECK(s.Y() == s1.Y());\n        CHECK(s.Z() == s1.Z());\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API double Parameter()\t @return The parameter of the point\n\t @brief Get the parameter of the point\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/MakeGeom2Circle.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/ComputePointsAbscissa.hpp>\n#include <geometry/MakeGeom3Circle.hpp>\n#include <geometry/AdaptorGeom3Curve.hpp>\n#include <geometry/MakeGeom2Hyperbola.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/MakeGeom2Ellipse.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <geometry/MakeGeom3Ellipse.hpp>\n#include <geometry/MakeGeom3Hyperbola.hpp>\n#include <geometry/Geom2Line.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include<modeling/MakeEdge.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/MakeGeom2Parabola.hpp>\n#include <geometry/MakeGeom3Parabola.hpp>\n#include <geometry/Geom2BezierCurve.hpp>\n#include <geometry/Geom3BezierCurve.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2OffsetCurve.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\nTEST_CASE(\"test the arc length parameter over the total length of the curve - given arc length - 2D\", \"[geometry][ComputePointsAbscissa][case18]\")\n{\n\tSECTION(\"circle\")\n    {\n        double r = 2.0;\n        double l = 19;\n        std::shared_ptr<Geom2Curve> c = MakeGeom2Circle(Point2(0.0, 0.0), 2.0).Value();\n        AdaptorGeom2Curve circle(c);\n        ComputePointsAbscissa cpa(circle, l, 0.0);\n        double angle1 = l / r;\n        double x = r * cos(angle1);\n        double y = r * sin(angle1);\n        double param = cpa.Parameter();\n        Point2 s = circle.Value(param);\n        Point2 s1(x, y);\n        CHECK(angle1 == cpa.Parameter());\n        CHECK(s.X() == s1.X());\n        CHECK(s.Y() == s1.Y());\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API ComputePointsAbscissa(const Adaptor2Curve& c, double abscissa, double u0, double ui, double tol)\t @param tol The tolerance\n\t @param ui The initial guess of the parameter\n\t @param u0 The starting parameter\n\t @param abscissa The arc length\n\t @param c The curve\n\t @brief Compute the parameter of a point on a 2D curve with given arc length, an initial guess, and a tolerance\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/MakeGeom2Circle.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/ComputePointsAbscissa.hpp>\n#include <geometry/MakeGeom3Circle.hpp>\n#include <geometry/AdaptorGeom3Curve.hpp>\n#include <geometry/MakeGeom2Hyperbola.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/MakeGeom2Ellipse.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <geometry/MakeGeom3Ellipse.hpp>\n#include <geometry/MakeGeom3Hyperbola.hpp>\n#include <geometry/Geom2Line.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include<modeling/MakeEdge.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/MakeGeom2Parabola.hpp>\n#include <geometry/MakeGeom3Parabola.hpp>\n#include <geometry/Geom2BezierCurve.hpp>\n#include <geometry/Geom3BezierCurve.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2OffsetCurve.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\nTEST_CASE(\"test the arc length parameter over the total length of the curve - given arc length - 2D\", \"[geometry][ComputePointsAbscissa][case18]\")\n{\n\tSECTION(\"circle\")\n    {\n        double r = 2.0;\n        double l = 19;\n        std::shared_ptr<Geom2Curve> c = MakeGeom2Circle(Point2(0.0, 0.0), 2.0).Value();\n        AdaptorGeom2Curve circle(c);\n        ComputePointsAbscissa cpa(circle, l, 0.0);\n        double angle1 = l / r;\n        double x = r * cos(angle1);\n        double y = r * sin(angle1);\n        double param = cpa.Parameter();\n        Point2 s = circle.Value(param);\n        Point2 s1(x, y);\n        CHECK(angle1 == cpa.Parameter());\n        CHECK(s.X() == s1.X());\n        CHECK(s.Y() == s1.Y());\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API ComputePointsAbscissa(const Adaptor3Curve& c, double abscissa, double u0, double ui, double tol)\t @param tol The tolerance\n\t @param ui The initial guess of the parameter\n\t @param u0 The starting parameter\n\t @param abscissa The arc length\n\t @param c The curve\n\t @brief Compute the parameter of a point on a 3D curve with given arc length, an initial guess, and a tolerance\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/MakeGeom2Circle.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/ComputePointsAbscissa.hpp>\n#include <geometry/MakeGeom3Circle.hpp>\n#include <geometry/AdaptorGeom3Curve.hpp>\n#include <geometry/MakeGeom2Hyperbola.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/MakeGeom2Ellipse.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <geometry/MakeGeom3Ellipse.hpp>\n#include <geometry/MakeGeom3Hyperbola.hpp>\n#include <geometry/Geom2Line.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include<modeling/MakeEdge.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/MakeGeom2Parabola.hpp>\n#include <geometry/MakeGeom3Parabola.hpp>\n#include <geometry/Geom2BezierCurve.hpp>\n#include <geometry/Geom3BezierCurve.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2OffsetCurve.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\nTEST_CASE(\"test the arc length parameter over the total length of the curve - given arc length - 3D\", \"[geometry][ComputePointsAbscissa][case19]\")\n{\n\tSECTION(\"circle\")\n    {\n        Frame3 frame;\n        double r = 2.0;\n        double l = 13;\n        std::shared_ptr<Geom3Curve> c = MakeGeom3Circle(frame, r).Value();\n        AdaptorGeom3Curve circle(c);\n        ComputePointsAbscissa cpa(circle, 13, 0.0);\n        double angle1 = l / r;\n        double x = r * cos(angle1);\n        double y = r * sin(angle1);\n        double z = 0;\n        double param = cpa.Parameter();\n        Point3 s = circle.Value(param);\n        Point3 s1(x, y, z);\n        CHECK(angle1 == cpa.Parameter());\n        CHECK(s.X() == s1.X());\n        CHECK(s.Y() == s1.Y());\n        CHECK(s.Z() == s1.Z());\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API ComputePointsAbscissa(const Adaptor2Curve& c, double abscissa, double u0, double ui)\t @param ui The initial guess of the parameter\n\t @param u0 The starting parameter\n\t @param abscissa The arc length\n\t @param c The curve\n\t @brief Compute the parameter of a point on a 2D curve with given arc length and an initial guess\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/MakeGeom2Circle.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/ComputePointsAbscissa.hpp>\n#include <geometry/MakeGeom3Circle.hpp>\n#include <geometry/AdaptorGeom3Curve.hpp>\n#include <geometry/MakeGeom2Hyperbola.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/MakeGeom2Ellipse.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <geometry/MakeGeom3Ellipse.hpp>\n#include <geometry/MakeGeom3Hyperbola.hpp>\n#include <geometry/Geom2Line.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include<modeling/MakeEdge.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/MakeGeom2Parabola.hpp>\n#include <geometry/MakeGeom3Parabola.hpp>\n#include <geometry/Geom2BezierCurve.hpp>\n#include <geometry/Geom3BezierCurve.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2OffsetCurve.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\nTEST_CASE(\"test the arc length parameter over the total length of the curve - given arc length - 2D\", \"[geometry][ComputePointsAbscissa][case18]\")\n{\n\tSECTION(\"circle\")\n    {\n        double r = 2.0;\n        double l = 19;\n        std::shared_ptr<Geom2Curve> c = MakeGeom2Circle(Point2(0.0, 0.0), 2.0).Value();\n        AdaptorGeom2Curve circle(c);\n        ComputePointsAbscissa cpa(circle, l, 0.0);\n        double angle1 = l / r;\n        double x = r * cos(angle1);\n        double y = r * sin(angle1);\n        double param = cpa.Parameter();\n        Point2 s = circle.Value(param);\n        Point2 s1(x, y);\n        CHECK(angle1 == cpa.Parameter());\n        CHECK(s.X() == s1.X());\n        CHECK(s.Y() == s1.Y());\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API ComputePointsAbscissa(const Adaptor3Curve& c, double abscissa, double u0, double ui)\t @param ui The initial guess of the parameter\n\t @param u0 The starting parameter\n\t @param abscissa The arc length\n\t @param c The curve\n\t @brief Compute the parameter of a point on a 3D curve with given arc length and an initial guess\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/MakeGeom2Circle.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/ComputePointsAbscissa.hpp>\n#include <geometry/MakeGeom3Circle.hpp>\n#include <geometry/AdaptorGeom3Curve.hpp>\n#include <geometry/MakeGeom2Hyperbola.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/MakeGeom2Ellipse.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <geometry/MakeGeom3Ellipse.hpp>\n#include <geometry/MakeGeom3Hyperbola.hpp>\n#include <geometry/Geom2Line.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include<modeling/MakeEdge.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/MakeGeom2Parabola.hpp>\n#include <geometry/MakeGeom3Parabola.hpp>\n#include <geometry/Geom2BezierCurve.hpp>\n#include <geometry/Geom3BezierCurve.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2OffsetCurve.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\nTEST_CASE(\"test the arc length parameter over the total length of the curve - given arc length - 2D\", \"[geometry][ComputePointsAbscissa][case18]\")\n{\n\tSECTION(\"circle\")\n    {\n        double r = 2.0;\n        double l = 19;\n        std::shared_ptr<Geom2Curve> c = MakeGeom2Circle(Point2(0.0, 0.0), 2.0).Value();\n        AdaptorGeom2Curve circle(c);\n        ComputePointsAbscissa cpa(circle, l, 0.0);\n        double angle1 = l / r;\n        double x = r * cos(angle1);\n        double y = r * sin(angle1);\n        double param = cpa.Parameter();\n        Point2 s = circle.Value(param);\n        Point2 s1(x, y);\n        CHECK(angle1 == cpa.Parameter());\n        CHECK(s.X() == s1.X());\n        CHECK(s.Y() == s1.Y());\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API ComputePointsAbscissa(const Adaptor2Curve& c, double abscissa, double u0)\t @param u0 The starting parameter\n\t @param abscissa The arc length\n\t @param c The curve\n\t @brief Compute the parameter of a point on a 2D curve with given arc length\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/MakeGeom2Circle.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/ComputePointsAbscissa.hpp>\n#include <geometry/MakeGeom3Circle.hpp>\n#include <geometry/AdaptorGeom3Curve.hpp>\n#include <geometry/MakeGeom2Hyperbola.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/MakeGeom2Ellipse.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <geometry/MakeGeom3Ellipse.hpp>\n#include <geometry/MakeGeom3Hyperbola.hpp>\n#include <geometry/Geom2Line.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include<modeling/MakeEdge.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/MakeGeom2Parabola.hpp>\n#include <geometry/MakeGeom3Parabola.hpp>\n#include <geometry/Geom2BezierCurve.hpp>\n#include <geometry/Geom3BezierCurve.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2OffsetCurve.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\nTEST_CASE(\"test the arc length parameter over the total length of the curve - given arc length - 2D\", \"[geometry][ComputePointsAbscissa][case18]\")\n{\n\tSECTION(\"circle\")\n    {\n        double r = 2.0;\n        double l = 19;\n        std::shared_ptr<Geom2Curve> c = MakeGeom2Circle(Point2(0.0, 0.0), 2.0).Value();\n        AdaptorGeom2Curve circle(c);\n        ComputePointsAbscissa cpa(circle, l, 0.0);\n        double angle1 = l / r;\n        double x = r * cos(angle1);\n        double y = r * sin(angle1);\n        double param = cpa.Parameter();\n        Point2 s = circle.Value(param);\n        Point2 s1(x, y);\n        CHECK(angle1 == cpa.Parameter());\n        CHECK(s.X() == s1.X());\n        CHECK(s.Y() == s1.Y());\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API ComputePointsAbscissa(const Adaptor3Curve& c, double abscissa, double u0)\t @param u0 The starting parameter\n\t @param abscissa The arc length\n\t @param c The curve\n\t @brief Compute the parameter of a point on a 3D curve with given arc length\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/MakeGeom2Circle.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/ComputePointsAbscissa.hpp>\n#include <geometry/MakeGeom3Circle.hpp>\n#include <geometry/AdaptorGeom3Curve.hpp>\n#include <geometry/MakeGeom2Hyperbola.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/MakeGeom2Ellipse.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <geometry/MakeGeom3Ellipse.hpp>\n#include <geometry/MakeGeom3Hyperbola.hpp>\n#include <geometry/Geom2Line.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include<modeling/MakeEdge.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/MakeGeom2Parabola.hpp>\n#include <geometry/MakeGeom3Parabola.hpp>\n#include <geometry/Geom2BezierCurve.hpp>\n#include <geometry/Geom3BezierCurve.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2OffsetCurve.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\nTEST_CASE(\"test the arc length parameter over the total length of the curve - given arc length - 3D\", \"[geometry][ComputePointsAbscissa][case19]\")\n{\n\tSECTION(\"circle\")\n    {\n        Frame3 frame;\n        double r = 2.0;\n        double l = 13;\n        std::shared_ptr<Geom3Curve> c = MakeGeom3Circle(frame, r).Value();\n        AdaptorGeom3Curve circle(c);\n        ComputePointsAbscissa cpa(circle, 13, 0.0);\n        double angle1 = l / r;\n        double x = r * cos(angle1);\n        double y = r * sin(angle1);\n        double z = 0;\n        double param = cpa.Parameter();\n        Point3 s = circle.Value(param);\n        Point3 s1(x, y, z);\n        CHECK(angle1 == cpa.Parameter());\n        CHECK(s.X() == s1.X());\n        CHECK(s.Y() == s1.Y());\n        CHECK(s.Z() == s1.Z());\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API ComputePointsAbscissa(double tol, const Adaptor2Curve& c, double abscissa, double u0)\t @param u0 The starting parameter\n\t @param abscissa The arc length\n\t @param c The curve\n\t @param tol The tolerance\n\t @brief Compute the parameter of a point on a 2D curve with given arc length and a tolerance\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/MakeGeom2Circle.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/ComputePointsAbscissa.hpp>\n#include <geometry/MakeGeom3Circle.hpp>\n#include <geometry/AdaptorGeom3Curve.hpp>\n#include <geometry/MakeGeom2Hyperbola.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/MakeGeom2Ellipse.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <geometry/MakeGeom3Ellipse.hpp>\n#include <geometry/MakeGeom3Hyperbola.hpp>\n#include <geometry/Geom2Line.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include<modeling/MakeEdge.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/MakeGeom2Parabola.hpp>\n#include <geometry/MakeGeom3Parabola.hpp>\n#include <geometry/Geom2BezierCurve.hpp>\n#include <geometry/Geom3BezierCurve.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2OffsetCurve.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\nTEST_CASE(\"test the arc length parameter over the total length of the curve - given arc length - 2D\", \"[geometry][ComputePointsAbscissa][case18]\")\n{\n\tSECTION(\"circle\")\n    {\n        double r = 2.0;\n        double l = 19;\n        std::shared_ptr<Geom2Curve> c = MakeGeom2Circle(Point2(0.0, 0.0), 2.0).Value();\n        AdaptorGeom2Curve circle(c);\n        ComputePointsAbscissa cpa(circle, l, 0.0);\n        double angle1 = l / r;\n        double x = r * cos(angle1);\n        double y = r * sin(angle1);\n        double param = cpa.Parameter();\n        Point2 s = circle.Value(param);\n        Point2 s1(x, y);\n        CHECK(angle1 == cpa.Parameter());\n        CHECK(s.X() == s1.X());\n        CHECK(s.Y() == s1.Y());\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API ComputePointsAbscissa(double tol, const Adaptor3Curve& c, double abscissa, double u0)\t @param u0 The starting parameter\n\t @param abscissa The arc length\n\t @param c The curve\n\t @param tol The tolerance\n\t @brief Compute the parameter of a point on a 3D curve with given arc length and a tolerance\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/MakeGeom2Circle.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/ComputePointsAbscissa.hpp>\n#include <geometry/MakeGeom3Circle.hpp>\n#include <geometry/AdaptorGeom3Curve.hpp>\n#include <geometry/MakeGeom2Hyperbola.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/MakeGeom2Ellipse.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <geometry/MakeGeom3Ellipse.hpp>\n#include <geometry/MakeGeom3Hyperbola.hpp>\n#include <geometry/Geom2Line.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include<modeling/MakeEdge.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/MakeGeom2Parabola.hpp>\n#include <geometry/MakeGeom3Parabola.hpp>\n#include <geometry/Geom2BezierCurve.hpp>\n#include <geometry/Geom3BezierCurve.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2OffsetCurve.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\nTEST_CASE(\"test the arc length parameter over the total length of the curve - given arc length - 2D\", \"[geometry][ComputePointsAbscissa][case18]\")\n{\n\tSECTION(\"line\")\n    {\n        shared_ptr<Geom2Line> line;\n        line = make_shared<Geom2Line>(Point2(0.0, 0.0), Direction2(1.0, 0.0));\n        shared_ptr<Geom2TrimmedCurve> TrimmedCurve = make_shared<Geom2TrimmedCurve>(line, 0.0, 6.0);\n        AdaptorGeom2Curve line1(TrimmedCurve);\n        ComputePointsAbscissa cpa4(line1, 8.0, 0.0);\n        double param4 = cpa4.Parameter();\n        double x = 8.0;\n        double y = 0.0;\n        Point2 s5 = line1.Value(param4);\n        Point2 s6(x, y);\n        CHECK(cpa4.Parameter() == 8.0);\n        CHECK(s5.X() == s6.X());\n        CHECK(s5.Y() == s6.Y());\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API double Parameter()\t @return The parameter of the point\n\t @brief Get the parameter of the point\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/MakeGeom2Circle.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/ComputePointsAbscissa.hpp>\n#include <geometry/MakeGeom3Circle.hpp>\n#include <geometry/AdaptorGeom3Curve.hpp>\n#include <geometry/MakeGeom2Hyperbola.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/MakeGeom2Ellipse.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <geometry/MakeGeom3Ellipse.hpp>\n#include <geometry/MakeGeom3Hyperbola.hpp>\n#include <geometry/Geom2Line.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include<modeling/MakeEdge.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/MakeGeom2Parabola.hpp>\n#include <geometry/MakeGeom3Parabola.hpp>\n#include <geometry/Geom2BezierCurve.hpp>\n#include <geometry/Geom3BezierCurve.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2OffsetCurve.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\nTEST_CASE(\"test the arc length is negative - given arc length - 2D\", \"[geometry][ComputePointsAbscissa][case9]\")\n{\n\tSECTION(\"circle\")\n    {\n        double r = 2.0;\n        double l = -1.0;\n        std::shared_ptr<Geom2Curve> c = MakeGeom2Circle(Point2(0.0, 0.0), 2.0).Value();\n        AdaptorGeom2Curve circle(c);\n        ComputePointsAbscissa cpa(circle, -1.0, 0.0);\n        double angle1 = l / r;\n        double x = r * cos(angle1);\n        double y = r * sin(angle1);\n        double param = cpa.Parameter();\n        Point2 s = circle.Value(param);\n        Point2 s1(x, y);\n        CHECK(angle1 == cpa.Parameter());\n        CHECK(s.X() == s1.X());\n        CHECK(s.Y() == s1.Y());\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API ComputePointsAbscissa(const Adaptor2Curve& c, double abscissa, double u0, double ui, double tol)\t @param tol The tolerance\n\t @param ui The initial guess of the parameter\n\t @param u0 The starting parameter\n\t @param abscissa The arc length\n\t @param c The curve\n\t @brief Compute the parameter of a point on a 2D curve with given arc length, an initial guess, and a tolerance\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/MakeGeom2Circle.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/ComputePointsAbscissa.hpp>\n#include <geometry/MakeGeom3Circle.hpp>\n#include <geometry/AdaptorGeom3Curve.hpp>\n#include <geometry/MakeGeom2Hyperbola.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/MakeGeom2Ellipse.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <geometry/MakeGeom3Ellipse.hpp>\n#include <geometry/MakeGeom3Hyperbola.hpp>\n#include <geometry/Geom2Line.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include<modeling/MakeEdge.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/MakeGeom2Parabola.hpp>\n#include <geometry/MakeGeom3Parabola.hpp>\n#include <geometry/Geom2BezierCurve.hpp>\n#include <geometry/Geom3BezierCurve.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2OffsetCurve.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\nTEST_CASE(\"test the arc length is negative - given arc length - 2D\", \"[geometry][ComputePointsAbscissa][case9]\")\n{\n\tSECTION(\"circle\")\n    {\n        double r = 2.0;\n        double l = -1.0;\n        std::shared_ptr<Geom2Curve> c = MakeGeom2Circle(Point2(0.0, 0.0), 2.0).Value();\n        AdaptorGeom2Curve circle(c);\n        ComputePointsAbscissa cpa(circle, -1.0, 0.0);\n        double angle1 = l / r;\n        double x = r * cos(angle1);\n        double y = r * sin(angle1);\n        double param = cpa.Parameter();\n        Point2 s = circle.Value(param);\n        Point2 s1(x, y);\n        CHECK(angle1 == cpa.Parameter());\n        CHECK(s.X() == s1.X());\n        CHECK(s.Y() == s1.Y());\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API ComputePointsAbscissa(const Adaptor3Curve& c, double abscissa, double u0, double ui, double tol)\t @param tol The tolerance\n\t @param ui The initial guess of the parameter\n\t @param u0 The starting parameter\n\t @param abscissa The arc length\n\t @param c The curve\n\t @brief Compute the parameter of a point on a 3D curve with given arc length, an initial guess, and a tolerance\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/MakeGeom2Circle.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/ComputePointsAbscissa.hpp>\n#include <geometry/MakeGeom3Circle.hpp>\n#include <geometry/AdaptorGeom3Curve.hpp>\n#include <geometry/MakeGeom2Hyperbola.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/MakeGeom2Ellipse.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <geometry/MakeGeom3Ellipse.hpp>\n#include <geometry/MakeGeom3Hyperbola.hpp>\n#include <geometry/Geom2Line.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include<modeling/MakeEdge.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/MakeGeom2Parabola.hpp>\n#include <geometry/MakeGeom3Parabola.hpp>\n#include <geometry/Geom2BezierCurve.hpp>\n#include <geometry/Geom3BezierCurve.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2OffsetCurve.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\nTEST_CASE(\"test the arc length is negative - given arc length - 3D\", \"[geometry][ComputePointsAbscissa][case10]\")\n{\n\tSECTION(\"line\")\n    {\n        double t = -2.0;\n        shared_ptr<Geom3Line> line;\n        line = make_shared<Geom3Line>(Point3(0.0, 0.0, 0.0), Direction3(1.0, 2.0, 3.0));\n        shared_ptr<Geom3TrimmedCurve> TrimmedCurve = make_shared<Geom3TrimmedCurve>(line, 0.0, 6.0);\n        AdaptorGeom3Curve line1(TrimmedCurve);\n        ComputePointsAbscissa cpa4(line1, -2.0, 0.0);\n        double param4 = cpa4.Parameter();\n        Point3 start(0.0, 0.0, 0.0);\n        Direction3 direction(1.0, 2.0, 3.0);\n        double x = start.X() + t * direction.X();\n        double y = start.Y() + t * direction.Y();\n        double z = start.Z() + t * direction.Z();\n        Point3 s5 = line1.Value(param4);\n        Point3 s6(x, y, z);\n        CHECK(cpa4.Parameter() == -2.0);\n        CHECK(s5.X() == s6.X());\n        CHECK(s5.Y() == s6.Y());\n        CHECK(s5.Z() == s6.Z());\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API ComputePointsAbscissa(const Adaptor2Curve& c, double abscissa, double u0, double ui)\t @param ui The initial guess of the parameter\n\t @param u0 The starting parameter\n\t @param abscissa The arc length\n\t @param c The curve\n\t @brief Compute the parameter of a point on a 2D curve with given arc length and an initial guess\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/MakeGeom2Circle.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/ComputePointsAbscissa.hpp>\n#include <geometry/MakeGeom3Circle.hpp>\n#include <geometry/AdaptorGeom3Curve.hpp>\n#include <geometry/MakeGeom2Hyperbola.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/MakeGeom2Ellipse.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <geometry/MakeGeom3Ellipse.hpp>\n#include <geometry/MakeGeom3Hyperbola.hpp>\n#include <geometry/Geom2Line.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include<modeling/MakeEdge.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/MakeGeom2Parabola.hpp>\n#include <geometry/MakeGeom3Parabola.hpp>\n#include <geometry/Geom2BezierCurve.hpp>\n#include <geometry/Geom3BezierCurve.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2OffsetCurve.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\nTEST_CASE(\"test the arc length is negative - given arc length - 2D\", \"[geometry][ComputePointsAbscissa][case9]\")\n{\n\tSECTION(\"circle\")\n    {\n        double r = 2.0;\n        double l = -1.0;\n        std::shared_ptr<Geom2Curve> c = MakeGeom2Circle(Point2(0.0, 0.0), 2.0).Value();\n        AdaptorGeom2Curve circle(c);\n        ComputePointsAbscissa cpa(circle, -1.0, 0.0);\n        double angle1 = l / r;\n        double x = r * cos(angle1);\n        double y = r * sin(angle1);\n        double param = cpa.Parameter();\n        Point2 s = circle.Value(param);\n        Point2 s1(x, y);\n        CHECK(angle1 == cpa.Parameter());\n        CHECK(s.X() == s1.X());\n        CHECK(s.Y() == s1.Y());\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API ComputePointsAbscissa(const Adaptor3Curve& c, double abscissa, double u0, double ui)\t @param ui The initial guess of the parameter\n\t @param u0 The starting parameter\n\t @param abscissa The arc length\n\t @param c The curve\n\t @brief Compute the parameter of a point on a 3D curve with given arc length and an initial guess\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/MakeGeom2Circle.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/ComputePointsAbscissa.hpp>\n#include <geometry/MakeGeom3Circle.hpp>\n#include <geometry/AdaptorGeom3Curve.hpp>\n#include <geometry/MakeGeom2Hyperbola.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/MakeGeom2Ellipse.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <geometry/MakeGeom3Ellipse.hpp>\n#include <geometry/MakeGeom3Hyperbola.hpp>\n#include <geometry/Geom2Line.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include<modeling/MakeEdge.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/MakeGeom2Parabola.hpp>\n#include <geometry/MakeGeom3Parabola.hpp>\n#include <geometry/Geom2BezierCurve.hpp>\n#include <geometry/Geom3BezierCurve.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2OffsetCurve.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\nTEST_CASE(\"test the arc length is negative - given arc length - 3D\", \"[geometry][ComputePointsAbscissa][case10]\")\n{\n\tSECTION(\"circle\")\n    {\n        Frame3 frame;\n        double r = 2.0;\n        double l = -1.0;\n        std::shared_ptr<Geom3Curve> c = MakeGeom3Circle(frame, r).Value();\n        AdaptorGeom3Curve circle(c);\n        ComputePointsAbscissa cpa(circle, -1.0, 0.0);\n        double angle1 = l / r;\n        double x = r * cos(angle1);\n        double y = r * sin(angle1);\n        double z = 0;\n        double param = cpa.Parameter();\n        Point3 s = circle.Value(param);\n        Point3 s1(x, y, z);\n        CHECK(angle1 == cpa.Parameter());\n        CHECK(s.X() == s1.X());\n        CHECK(s.Y() == s1.Y());\n        CHECK(s.Z() == s1.Z());\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API ComputePointsAbscissa(const Adaptor2Curve& c, double abscissa, double u0)\t @param u0 The starting parameter\n\t @param abscissa The arc length\n\t @param c The curve\n\t @brief Compute the parameter of a point on a 2D curve with given arc length\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/MakeGeom2Circle.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/ComputePointsAbscissa.hpp>\n#include <geometry/MakeGeom3Circle.hpp>\n#include <geometry/AdaptorGeom3Curve.hpp>\n#include <geometry/MakeGeom2Hyperbola.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/MakeGeom2Ellipse.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <geometry/MakeGeom3Ellipse.hpp>\n#include <geometry/MakeGeom3Hyperbola.hpp>\n#include <geometry/Geom2Line.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include<modeling/MakeEdge.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/MakeGeom2Parabola.hpp>\n#include <geometry/MakeGeom3Parabola.hpp>\n#include <geometry/Geom2BezierCurve.hpp>\n#include <geometry/Geom3BezierCurve.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2OffsetCurve.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\nTEST_CASE(\"test the arc length is negative - given arc length - 2D\", \"[geometry][ComputePointsAbscissa][case9]\")\n{\n\tSECTION(\"circle\")\n    {\n        double r = 2.0;\n        double l = -1.0;\n        std::shared_ptr<Geom2Curve> c = MakeGeom2Circle(Point2(0.0, 0.0), 2.0).Value();\n        AdaptorGeom2Curve circle(c);\n        ComputePointsAbscissa cpa(circle, -1.0, 0.0);\n        double angle1 = l / r;\n        double x = r * cos(angle1);\n        double y = r * sin(angle1);\n        double param = cpa.Parameter();\n        Point2 s = circle.Value(param);\n        Point2 s1(x, y);\n        CHECK(angle1 == cpa.Parameter());\n        CHECK(s.X() == s1.X());\n        CHECK(s.Y() == s1.Y());\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API ComputePointsAbscissa(const Adaptor3Curve& c, double abscissa, double u0)\t @param u0 The starting parameter\n\t @param abscissa The arc length\n\t @param c The curve\n\t @brief Compute the parameter of a point on a 3D curve with given arc length\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/MakeGeom2Circle.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/ComputePointsAbscissa.hpp>\n#include <geometry/MakeGeom3Circle.hpp>\n#include <geometry/AdaptorGeom3Curve.hpp>\n#include <geometry/MakeGeom2Hyperbola.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/MakeGeom2Ellipse.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <geometry/MakeGeom3Ellipse.hpp>\n#include <geometry/MakeGeom3Hyperbola.hpp>\n#include <geometry/Geom2Line.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include<modeling/MakeEdge.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/MakeGeom2Parabola.hpp>\n#include <geometry/MakeGeom3Parabola.hpp>\n#include <geometry/Geom2BezierCurve.hpp>\n#include <geometry/Geom3BezierCurve.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2OffsetCurve.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\nTEST_CASE(\"test the arc length is negative - given arc length - 3D\", \"[geometry][ComputePointsAbscissa][case10]\")\n{\n\tSECTION(\"circle\")\n    {\n        Frame3 frame;\n        double r = 2.0;\n        double l = -1.0;\n        std::shared_ptr<Geom3Curve> c = MakeGeom3Circle(frame, r).Value();\n        AdaptorGeom3Curve circle(c);\n        ComputePointsAbscissa cpa(circle, -1.0, 0.0);\n        double angle1 = l / r;\n        double x = r * cos(angle1);\n        double y = r * sin(angle1);\n        double z = 0;\n        double param = cpa.Parameter();\n        Point3 s = circle.Value(param);\n        Point3 s1(x, y, z);\n        CHECK(angle1 == cpa.Parameter());\n        CHECK(s.X() == s1.X());\n        CHECK(s.Y() == s1.Y());\n        CHECK(s.Z() == s1.Z());\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API ComputePointsAbscissa(double tol, const Adaptor2Curve& c, double abscissa, double u0)\t @param u0 The starting parameter\n\t @param abscissa The arc length\n\t @param c The curve\n\t @param tol The tolerance\n\t @brief Compute the parameter of a point on a 2D curve with given arc length and a tolerance\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/MakeGeom2Circle.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/ComputePointsAbscissa.hpp>\n#include <geometry/MakeGeom3Circle.hpp>\n#include <geometry/AdaptorGeom3Curve.hpp>\n#include <geometry/MakeGeom2Hyperbola.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/MakeGeom2Ellipse.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <geometry/MakeGeom3Ellipse.hpp>\n#include <geometry/MakeGeom3Hyperbola.hpp>\n#include <geometry/Geom2Line.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include<modeling/MakeEdge.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/MakeGeom2Parabola.hpp>\n#include <geometry/MakeGeom3Parabola.hpp>\n#include <geometry/Geom2BezierCurve.hpp>\n#include <geometry/Geom3BezierCurve.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2OffsetCurve.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\nTEST_CASE(\"test the arc length is negative - given arc length - 2D\", \"[geometry][ComputePointsAbscissa][case9]\")\n{\n\tSECTION(\"circle\")\n    {\n        double r = 2.0;\n        double l = -1.0;\n        std::shared_ptr<Geom2Curve> c = MakeGeom2Circle(Point2(0.0, 0.0), 2.0).Value();\n        AdaptorGeom2Curve circle(c);\n        ComputePointsAbscissa cpa(circle, -1.0, 0.0);\n        double angle1 = l / r;\n        double x = r * cos(angle1);\n        double y = r * sin(angle1);\n        double param = cpa.Parameter();\n        Point2 s = circle.Value(param);\n        Point2 s1(x, y);\n        CHECK(angle1 == cpa.Parameter());\n        CHECK(s.X() == s1.X());\n        CHECK(s.Y() == s1.Y());\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API ComputePointsAbscissa(double tol, const Adaptor3Curve& c, double abscissa, double u0)\t @param u0 The starting parameter\n\t @param abscissa The arc length\n\t @param c The curve\n\t @param tol The tolerance\n\t @brief Compute the parameter of a point on a 3D curve with given arc length and a tolerance\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/MakeGeom2Circle.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/ComputePointsAbscissa.hpp>\n#include <geometry/MakeGeom3Circle.hpp>\n#include <geometry/AdaptorGeom3Curve.hpp>\n#include <geometry/MakeGeom2Hyperbola.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/MakeGeom2Ellipse.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <geometry/MakeGeom3Ellipse.hpp>\n#include <geometry/MakeGeom3Hyperbola.hpp>\n#include <geometry/Geom2Line.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include<modeling/MakeEdge.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/MakeGeom2Parabola.hpp>\n#include <geometry/MakeGeom3Parabola.hpp>\n#include <geometry/Geom2BezierCurve.hpp>\n#include <geometry/Geom3BezierCurve.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2OffsetCurve.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\nTEST_CASE(\"test the arc length is negative - given arc length - 3D\", \"[geometry][ComputePointsAbscissa][case10]\")\n{\n\tSECTION(\"circle\")\n    {\n        Frame3 frame;\n        double r = 2.0;\n        double l = -1.0;\n        std::shared_ptr<Geom3Curve> c = MakeGeom3Circle(frame, r).Value();\n        AdaptorGeom3Curve circle(c);\n        ComputePointsAbscissa cpa(circle, -1.0, 0.0);\n        double angle1 = l / r;\n        double x = r * cos(angle1);\n        double y = r * sin(angle1);\n        double z = 0;\n        double param = cpa.Parameter();\n        Point3 s = circle.Value(param);\n        Point3 s1(x, y, z);\n        CHECK(angle1 == cpa.Parameter());\n        CHECK(s.X() == s1.X());\n        CHECK(s.Y() == s1.Y());\n        CHECK(s.Z() == s1.Z());\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static double Length(const Adaptor2Curve& c, double u1, double u2, double tol)\t @return The length of a curve in a given interval\n\t @param tol The tolerance\n\t @param u2 The last parameter\n\t @param u1 The first parameter\n\t @param c The curve\n\t @brief Compute the length of a 2D curve in a given interval with a tolerance\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/MakeGeom2Circle.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/ComputePointsAbscissa.hpp>\n#include <geometry/MakeGeom3Circle.hpp>\n#include <geometry/AdaptorGeom3Curve.hpp>\n#include <geometry/MakeGeom2Hyperbola.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/MakeGeom2Ellipse.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <geometry/MakeGeom3Ellipse.hpp>\n#include <geometry/MakeGeom3Hyperbola.hpp>\n#include <geometry/Geom2Line.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include<modeling/MakeEdge.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/MakeGeom2Parabola.hpp>\n#include <geometry/MakeGeom3Parabola.hpp>\n#include <geometry/Geom2BezierCurve.hpp>\n#include <geometry/Geom3BezierCurve.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2OffsetCurve.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\nTEST_CASE(\"test the calculation of the parameters of a point on a 2D curve for a given arc length, initial guess parameters and tolerances and the length of the 2D curve in a given interval, as well as the length of the 2D curve for a given interval and tolerances\", \"[geometry][ComputePointsAbscissa][case4]\")\n{\n\tSECTION(\"circle\")\n    {\n        double r = 3.0;\n        double l = 2.0;\n        std::shared_ptr<Geom2Curve> c = MakeGeom2Circle(Point2(0.0, 0.0), 3.0).Value();\n        AdaptorGeom2Curve circle(c);\n        ComputePointsAbscissa cpa(circle, 2.0, 0.0, 1.5, Precision::Confusion());\n        double angle1 = l / r;\n        std::cout << \"ԲĽǵĻֵΪ\" << \": \" << angle1 << '\n';\n        double x = r * cos(angle1);\n        double y = r * sin(angle1);\n        std::cout << \"xֵΪ\" << \": \" << x << '\n';\n        std::cout << \"yֵΪ\" << \": \" << y << '\n';\n        double param = cpa.Parameter();\n        if (cpa.IsDone())\n        {\n            std::cout << param << \": \" << circle.Value(param) << '\n';\n        }\n        Point2 s = circle.Value(param);\n        Point2 s1(x, y);\n        std::cout << s << std::endl;\n        CHECK(s.X() == s1.X());\n        CHECK(s.Y() == s1.Y());\n        std::cout << \"ڶά߳Ϊ\" << ComputePointsAbscissa::Length(circle, 0.0, 0.666667) << '\n';\n        std::cout << \"ݲĶά߳Ϊ\" << ComputePointsAbscissa::Length(circle, 0.0, 0.666667, Precision::Confusion()) << '\n';\n        CHECK(angle1 == cpa.Parameter());\n        CHECK(ComputePointsAbscissa::Length(circle, 0.0, 0.6666666667) == Approx(l).margin(1e-2));\n        CHECK(ComputePointsAbscissa::Length(circle, 0.0, 0.6666666667, Precision::Confusion()) == Approx(l).margin(1e-2));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static double Length(const Adaptor3Curve& c, double u1, double u2, double tol)\t @return The length of a curve in a given interval\n\t @param tol The tolerance\n\t @param u2 The last parameter\n\t @param u1 The first parameter\n\t @param c The curve\n\t @brief Compute the length of a 3D curve in a given interval with a tolerance\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/MakeGeom2Circle.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/ComputePointsAbscissa.hpp>\n#include <geometry/MakeGeom3Circle.hpp>\n#include <geometry/AdaptorGeom3Curve.hpp>\n#include <geometry/MakeGeom2Hyperbola.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/MakeGeom2Ellipse.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <geometry/MakeGeom3Ellipse.hpp>\n#include <geometry/MakeGeom3Hyperbola.hpp>\n#include <geometry/Geom2Line.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include<modeling/MakeEdge.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/MakeGeom2Parabola.hpp>\n#include <geometry/MakeGeom3Parabola.hpp>\n#include <geometry/Geom2BezierCurve.hpp>\n#include <geometry/Geom3BezierCurve.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2OffsetCurve.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\nTEST_CASE(\"test the calculation of the parameters of a point on a 2D curve for a given arc length, initial guess parameters and tolerances and the length of the 2D curve in a given interval, as well as the length of the 2D curve for a given interval and tolerances\", \"[geometry][ComputePointsAbscissa][case4]\")\n{\n\tSECTION(\"line\")\n    {\n        shared_ptr<Geom2Line> line;\n        line = make_shared<Geom2Line>(Point2(0.0, 0.0), Direction2(1.0, 0.0));\n        shared_ptr<Geom2TrimmedCurve> TrimmedCurve = make_shared<Geom2TrimmedCurve>(line, 0.0, 6.0);\n        AdaptorGeom2Curve line1(TrimmedCurve);\n        ComputePointsAbscissa cpa4(line1, 2.0, 0.0, 2.0, Precision::Confusion());\n        double param4 = cpa4.Parameter();\n        if (cpa4.IsDone())\n        {\n            std::cout << param4 << \": \" << line1.Value(param4) << '\n';\n        }\n        double x = 2.0;\n        double y = 0.0;\n        Point2 s5 = line1.Value(param4);\n        Point2 s6(x, y);\n        std::cout << s5 << std::endl;\n        CHECK(cpa4.Parameter() == 2.0);\n        CHECK(s5.X() == s6.X());\n        CHECK(s5.Y() == s6.Y());\n        std::cout << \"ڶά߳Ϊ\" << ComputePointsAbscissa::Length(line1, 0.0, 2.0) << '\n';\n        std::cout << \"ݲĶά߳Ϊ\" << ComputePointsAbscissa::Length(line1, 0.0, 3.0, Precision::Confusion()) << '\n';\n        CHECK(ComputePointsAbscissa::Length(line1, 0.0, 2.0) == 2.0);\n        CHECK(ComputePointsAbscissa::Length(line1, 0.0, 3.0, Precision::Confusion()) == 3.0);\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static double Length(const Adaptor2Curve& c, double u1, double u2)\t @return The length of a curve in a given interval\n\t @param u2 The last parameter\n\t @param u1 The first parameter\n\t @param c The curve\n\t @brief Compute the length of a 2D curve in a given interval\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/MakeGeom2Circle.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/ComputePointsAbscissa.hpp>\n#include <geometry/MakeGeom3Circle.hpp>\n#include <geometry/AdaptorGeom3Curve.hpp>\n#include <geometry/MakeGeom2Hyperbola.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/MakeGeom2Ellipse.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <geometry/MakeGeom3Ellipse.hpp>\n#include <geometry/MakeGeom3Hyperbola.hpp>\n#include <geometry/Geom2Line.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include<modeling/MakeEdge.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/MakeGeom2Parabola.hpp>\n#include <geometry/MakeGeom3Parabola.hpp>\n#include <geometry/Geom2BezierCurve.hpp>\n#include <geometry/Geom3BezierCurve.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2OffsetCurve.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\nTEST_CASE(\"tset the calculation of the parameters of a point on a 3D curve for a given arc length, initial guess parameters and tolerances and the length of the 3D curve within a given interval, as well as the length of the 3D curve for a given interval and tolerances\", \"[geometry][ComputePointsAbscissa][case8]\")\n{\n\tSECTION(\"line\")\n    {\n        double t = 2.0;\n        shared_ptr<Geom3Line> line;\n        line = make_shared<Geom3Line>(Point3(0.0, 0.0, 0.0), Direction3(1.0, 2.0, 3.0));\n        shared_ptr<Geom3TrimmedCurve> TrimmedCurve = make_shared<Geom3TrimmedCurve>(line, 0.0, 6.0);\n        AdaptorGeom3Curve line1(TrimmedCurve);\n        ComputePointsAbscissa cpa4(line1, 2.0, 0.0, 2.0, Precision::Confusion());\n        double param4 = cpa4.Parameter();\n        if (cpa4.IsDone())\n        {\n            std::cout << param4 << \": \" << line1.Value(param4) << '\n';\n        }\n        Point3 start(0.0, 0.0, 0.0);\n        Direction3 direction(1.0, 2.0, 3.0);\n        double x = start.X() + t * direction.X();\n        double y = start.Y() + t * direction.Y();\n        double z = start.Z() + t * direction.Z();\n        Point3 s5 = line1.Value(param4);\n        Point3 s6(x, y, z);\n        std::cout << s5 << std::endl;\n        CHECK(cpa4.Parameter() == 2.0);\n        CHECK(s5.X() == s6.X());\n        CHECK(s5.Y() == s6.Y());\n        CHECK(s5.Z() == s6.Z());\n        std::cout << \"ڶά߳Ϊ\" << ComputePointsAbscissa::Length(line1, 0.0, 2.0) << '\n';\n        std::cout << \"ݲĶά߳Ϊ\" << ComputePointsAbscissa::Length(line1, 0.0, 2.0, Precision::Confusion()) << '\n';\n        CHECK(ComputePointsAbscissa::Length(line1, 0.0, 2.0) == 2.0);\n        CHECK(ComputePointsAbscissa::Length(line1, 0.0, 2.0, Precision::Confusion()) == 2.0);\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static double Length(const Adaptor3Curve& c, double u1, double u2)\t @return The length of a curve in a given interval\n\t @param u2 The last parameter\n\t @param u1 The first parameter\n\t @param c The curve\n\t @brief Compute the length of a 3D curve in a given interval\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/MakeGeom2Circle.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/ComputePointsAbscissa.hpp>\n#include <geometry/MakeGeom3Circle.hpp>\n#include <geometry/AdaptorGeom3Curve.hpp>\n#include <geometry/MakeGeom2Hyperbola.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/MakeGeom2Ellipse.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <geometry/MakeGeom3Ellipse.hpp>\n#include <geometry/MakeGeom3Hyperbola.hpp>\n#include <geometry/Geom2Line.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include<modeling/MakeEdge.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/MakeGeom2Parabola.hpp>\n#include <geometry/MakeGeom3Parabola.hpp>\n#include <geometry/Geom2BezierCurve.hpp>\n#include <geometry/Geom3BezierCurve.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2OffsetCurve.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\nTEST_CASE(\"tset the calculation of the parameters of a point on a 3D curve for a given arc length, initial guess parameters and tolerances and the length of the 3D curve within a given interval, as well as the length of the 3D curve for a given interval and tolerances\", \"[geometry][ComputePointsAbscissa][case8]\")\n{\n\tSECTION(\"ellipse\")\n    {\n        Frame3 frame;\n        double major = 5.0;\n        double minor = 4.0;\n        bool isRight = true;\n        std::shared_ptr< Geom3Ellipse >g2e = MakeGeom3Ellipse(frame, major, minor);\n        AdaptorGeom3Curve ellipse(g2e);\n        double t = minor / major;\n        std::cout << \"t\" << t << '\n';\n        double T = 3.15129643210828;\n        double L = T * (minor + major);\n        std::cout << \"L\" << L << '\n';\n        ComputePointsAbscissa cpa2(ellipse, L, 0.0, 0.5, Precision::Confusion());\n        double param2 = cpa2.Parameter();\n        if (cpa2.IsDone())\n        {\n            std::cout << param2 << \": \" << ellipse.Value(param2) << '\n';\n        }\n        Point3 s2 = ellipse.Value(param2);\n        Point3 s3(5.0, 0.0, 0.0);\n        std::cout << s2 << std::endl;\n        CHECK(s2.X() == Approx(s3.X()).margin(1e-2));\n        CHECK(s2.Y() == Approx(s3.Y()).margin(1e-2));\n        CHECK(s2.Z() == Approx(s3.Z()).margin(1e-2));\n        std::cout << \"ڶά߳Ϊ\" << ComputePointsAbscissa::Length(ellipse, 0.0, 6.28319) << '\n';\n        std::cout << \"ݲĶά߳Ϊ\" << ComputePointsAbscissa::Length(ellipse, 0.0, 6.28319, Precision::Confusion()) << '\n';\n        CHECK(cpa2.Parameter() == Approx(2 * M_PI).margin(1e-2));\n        CHECK(ComputePointsAbscissa::Length(ellipse, 0.0, 6.28319) == Approx(L).margin(1e-2));\n        CHECK(ComputePointsAbscissa::Length(ellipse, 0.0, 6.28319, Precision::Confusion()) == Approx(L).margin(1e-2));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static double Length(const Adaptor2Curve& c, double tol)\t @return The length of a curve\n\t @param tol The tolerance\n\t @param c The curve\n\t @brief Compute the length of a 2D curve with a tolerance\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/MakeGeom2Circle.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/ComputePointsAbscissa.hpp>\n#include <geometry/MakeGeom3Circle.hpp>\n#include <geometry/AdaptorGeom3Curve.hpp>\n#include <geometry/MakeGeom2Hyperbola.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/MakeGeom2Ellipse.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <geometry/MakeGeom3Ellipse.hpp>\n#include <geometry/MakeGeom3Hyperbola.hpp>\n#include <geometry/Geom2Line.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include<modeling/MakeEdge.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/MakeGeom2Parabola.hpp>\n#include <geometry/MakeGeom3Parabola.hpp>\n#include <geometry/Geom2BezierCurve.hpp>\n#include <geometry/Geom3BezierCurve.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2OffsetCurve.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\nTEST_CASE(\"tset the calculation of the parameters of a point on a 3D curve for a given arc length, initial guess parameters and tolerances and the length of the 3D curve within a given interval, as well as the length of the 3D curve for a given interval and tolerances\", \"[geometry][ComputePointsAbscissa][case8]\")\n{\n\tSECTION(\"line\")\n    {\n        double t = 2.0;\n        shared_ptr<Geom3Line> line;\n        line = make_shared<Geom3Line>(Point3(0.0, 0.0, 0.0), Direction3(1.0, 2.0, 3.0));\n        shared_ptr<Geom3TrimmedCurve> TrimmedCurve = make_shared<Geom3TrimmedCurve>(line, 0.0, 6.0);\n        AdaptorGeom3Curve line1(TrimmedCurve);\n        ComputePointsAbscissa cpa4(line1, 2.0, 0.0, 2.0, Precision::Confusion());\n        double param4 = cpa4.Parameter();\n        if (cpa4.IsDone())\n        {\n            std::cout << param4 << \": \" << line1.Value(param4) << '\n';\n        }\n        Point3 start(0.0, 0.0, 0.0);\n        Direction3 direction(1.0, 2.0, 3.0);\n        double x = start.X() + t * direction.X();\n        double y = start.Y() + t * direction.Y();\n        double z = start.Z() + t * direction.Z();\n        Point3 s5 = line1.Value(param4);\n        Point3 s6(x, y, z);\n        std::cout << s5 << std::endl;\n        CHECK(cpa4.Parameter() == 2.0);\n        CHECK(s5.X() == s6.X());\n        CHECK(s5.Y() == s6.Y());\n        CHECK(s5.Z() == s6.Z());\n        std::cout << \"ڶά߳Ϊ\" << ComputePointsAbscissa::Length(line1, 0.0, 2.0) << '\n';\n        std::cout << \"ݲĶά߳Ϊ\" << ComputePointsAbscissa::Length(line1, 0.0, 2.0, Precision::Confusion()) << '\n';\n        CHECK(ComputePointsAbscissa::Length(line1, 0.0, 2.0) == 2.0);\n        CHECK(ComputePointsAbscissa::Length(line1, 0.0, 2.0, Precision::Confusion()) == 2.0);\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static double Length(const Adaptor3Curve& c, double tol)\t @return The length of a curve\n\t @param tol The tolerance\n\t @param c The curve\n\t @brief Compute the length of a 3D curve with a tolerance\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/MakeGeom2Circle.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/ComputePointsAbscissa.hpp>\n#include <geometry/MakeGeom3Circle.hpp>\n#include <geometry/AdaptorGeom3Curve.hpp>\n#include <geometry/MakeGeom2Hyperbola.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/MakeGeom2Ellipse.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <geometry/MakeGeom3Ellipse.hpp>\n#include <geometry/MakeGeom3Hyperbola.hpp>\n#include <geometry/Geom2Line.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include<modeling/MakeEdge.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/MakeGeom2Parabola.hpp>\n#include <geometry/MakeGeom3Parabola.hpp>\n#include <geometry/Geom2BezierCurve.hpp>\n#include <geometry/Geom3BezierCurve.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2OffsetCurve.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\nTEST_CASE(\"test the parameters for calculating a point on a 3D curve with a given arc length and tolerance, and the length of the 3D curve with tolerance.\", \"[geometry][ComputePointsAbscissa][case6]\")\n{\n\tSECTION(\"circle\")\n    {\n        Frame3 frame;\n        double r = 3.0;\n        double l = 2.0;\n        std::shared_ptr<Geom3Curve> c = MakeGeom3Circle(frame, r).Value();\n        AdaptorGeom3Curve circle(c);\n        ComputePointsAbscissa cpa(Precision::Confusion(), circle, 2.0, 0.0);\n        double angle1 = l / r;\n        std::cout << \"ԲĽǵĻֵΪ\" << \": \" << angle1 << '\n';\n        double x = r * cos(angle1);\n        double y = r * sin(angle1);\n        double z = 0;\n        std::cout << \"xֵΪ\" << \": \" << x << '\n';\n        std::cout << \"yֵΪ\" << \": \" << y << '\n';\n        std::cout << \"zֵΪ\" << \": \" << z << '\n';\n        double param = cpa.Parameter();\n        if (cpa.IsDone())\n        {\n            std::cout << param << \": \" << circle.Value(param) << '\n';\n        }\n        double p = 2 * M_PI * r;\n        std::cout << \"߳Ϊ\" << ComputePointsAbscissa::Length(circle, Precision::Confusion()) << '\n';\n        Point3 s = circle.Value(param);\n        Point3 s1(x, y, z);\n        std::cout << s << std::endl;\n        CHECK(s.X() == s1.X());\n        CHECK(s.Y() == s1.Y());\n        CHECK(s.Z() == s1.Z());\n        CHECK(p == ComputePointsAbscissa::Length(circle,Precision::Confusion()));\n        CHECK(angle1 == cpa.Parameter());\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API double Parameter()\t @return The parameter of the point\n\t @brief Get the parameter of the point\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/MakeGeom2Circle.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/ComputePointsAbscissa.hpp>\n#include <geometry/MakeGeom3Circle.hpp>\n#include <geometry/AdaptorGeom3Curve.hpp>\n#include <geometry/MakeGeom2Hyperbola.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/MakeGeom2Ellipse.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <geometry/MakeGeom3Ellipse.hpp>\n#include <geometry/MakeGeom3Hyperbola.hpp>\n#include <geometry/Geom2Line.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include<modeling/MakeEdge.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/MakeGeom2Parabola.hpp>\n#include <geometry/MakeGeom3Parabola.hpp>\n#include <geometry/Geom2BezierCurve.hpp>\n#include <geometry/Geom3BezierCurve.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2OffsetCurve.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\nTEST_CASE(\"test the calculation of parameters at a point on a two-dimensional curve with a given arc length and initial guess parameters\", \"[geometry][ComputePointsAbscissa][case3]\")\n{\n\tSECTION(\"bezier\")\n    {\n        std::vector<Point2> pts2 = {\n       Point2(0.0, 0.0),\n       Point2(2.0, 2.0),\n       Point2(4.0, 3.0),\n        };\n        std::shared_ptr<Geom2BezierCurve> bez2 = make_shared<Geom2BezierCurve>(pts2);\n        AdaptorGeom2Curve b(bez2);\n        ComputePointsAbscissa cpa6(b, 2.0, 0.0, 0.37);\n        double param6 = cpa6.Parameter();\n        if (cpa6.IsDone())\n        {\n            std::cout << param6 << \": \" << b.Value(param6) << '\n';\n        }\n        double x = 1.0;\n        double y = 1.0;\n        Point2 s7 = b.Value(param6);\n        Point2 s8(x, y);\n        std::cout << s7 << std::endl;\n        CHECK(cpa6.Parameter() != 0);\n        shared_ptr<Geom3Curve> curve2;\n        curve2 = GeometryTool::To3d(Frame3(), bez2);\n        MakeEdge edge2(curve2, 0.0, param6);\n        Point3 s9(s7.X(), s7.Y(), 0.0);\n        CHECK(BRepClassificationTools::IsPointInOnEdge(edge2, s9, 0.001) == true);\n        std::cout << \"߳Ϊ\" << ComputePointsAbscissa::Length(b) << '\n';\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API ComputePointsAbscissa(const Adaptor2Curve& c, double abscissa, double u0, double ui, double tol)\t @param tol The tolerance\n\t @param ui The initial guess of the parameter\n\t @param u0 The starting parameter\n\t @param abscissa The arc length\n\t @param c The curve\n\t @brief Compute the parameter of a point on a 2D curve with given arc length, an initial guess, and a tolerance\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/MakeGeom2Circle.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/ComputePointsAbscissa.hpp>\n#include <geometry/MakeGeom3Circle.hpp>\n#include <geometry/AdaptorGeom3Curve.hpp>\n#include <geometry/MakeGeom2Hyperbola.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/MakeGeom2Ellipse.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <geometry/MakeGeom3Ellipse.hpp>\n#include <geometry/MakeGeom3Hyperbola.hpp>\n#include <geometry/Geom2Line.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include<modeling/MakeEdge.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/MakeGeom2Parabola.hpp>\n#include <geometry/MakeGeom3Parabola.hpp>\n#include <geometry/Geom2BezierCurve.hpp>\n#include <geometry/Geom3BezierCurve.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2OffsetCurve.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\nTEST_CASE(\"test the parameters for calculating a point on a 2D curve with a given arc length and the length of the 2D curve.\", \"[geometry][ComputePointsAbscissa][case1]\")\n{\n\tSECTION(\"circle\")\n    {\n        double r = 2.0;\n        double l = 1.0;\n        std::shared_ptr<Geom2Curve> c = MakeGeom2Circle(Point2(0.0, 0.0), 2.0).Value();\n        AdaptorGeom2Curve circle(c);\n        ComputePointsAbscissa cpa(circle, 1.0, 0.0);\n        double angle1 = l / r;\n        std::cout << \"ԲĽǵĻֵΪ\" << \": \" << angle1 << '\n';\n        double x = r * cos(angle1);\n        double y = r * sin(angle1);\n        std::cout << \"xֵΪ\" << \": \" << x << '\n';\n        std::cout << \"yֵΪ\" << \": \" << y << '\n';\n        double param = cpa.Parameter();\n        if (cpa.IsDone())\n        {\n            std::cout << param << \": \" << circle.Value(param) << '\n';\n        }\n        double p = 2 * M_PI * r;\n        std::cout << \"߳Ϊ\" << ComputePointsAbscissa::Length(circle) << '\n';\n        Point2 s = circle.Value(param);\n        Point2 s1(x, y);\n        std::cout << s << std::endl;\n        CHECK(p == ComputePointsAbscissa::Length(circle));\n        CHECK(angle1 == cpa.Parameter());\n        CHECK(s.X() == s1.X());\n        CHECK(s.Y() == s1.Y());\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API ComputePointsAbscissa(const Adaptor3Curve& c, double abscissa, double u0, double ui, double tol)\t @param tol The tolerance\n\t @param ui The initial guess of the parameter\n\t @param u0 The starting parameter\n\t @param abscissa The arc length\n\t @param c The curve\n\t @brief Compute the parameter of a point on a 3D curve with given arc length, an initial guess, and a tolerance\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/MakeGeom2Circle.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/ComputePointsAbscissa.hpp>\n#include <geometry/MakeGeom3Circle.hpp>\n#include <geometry/AdaptorGeom3Curve.hpp>\n#include <geometry/MakeGeom2Hyperbola.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/MakeGeom2Ellipse.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <geometry/MakeGeom3Ellipse.hpp>\n#include <geometry/MakeGeom3Hyperbola.hpp>\n#include <geometry/Geom2Line.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include<modeling/MakeEdge.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/MakeGeom2Parabola.hpp>\n#include <geometry/MakeGeom3Parabola.hpp>\n#include <geometry/Geom2BezierCurve.hpp>\n#include <geometry/Geom3BezierCurve.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2OffsetCurve.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\nTEST_CASE(\"tset the parameters for calculating a point on a 3D curve of a given arc length and the length of the 3D curve.\", \"[geometry][ComputePointsAbscissa][case5]\")\n{\n\tSECTION(\"line\")\n    {\n        double t = 2.0;\n        shared_ptr<Geom3Line> line;\n        line = make_shared<Geom3Line>(Point3(0.0, 0.0, 0.0), Direction3(1.0, 2.0, 3.0));\n        shared_ptr<Geom3TrimmedCurve> TrimmedCurve = make_shared<Geom3TrimmedCurve>(line, 0.0, 6.0);\n        AdaptorGeom3Curve line1(TrimmedCurve);\n        ComputePointsAbscissa cpa4(line1, 2.0, 0.0);\n        double param4 = cpa4.Parameter();\n        if (cpa4.IsDone())\n        {\n            std::cout << param4 << \": \" << line1.Value(param4) << '\n';\n        }\n        Point3 start(0.0, 0.0, 0.0);\n        Direction3 direction(1.0, 2.0, 3.0);\n        double x = start.X() + t * direction.X();\n        double y = start.Y() + t * direction.Y();\n        double z = start.Z() + t * direction.Z();\n        Point3 s5 = line1.Value(param4);\n        Point3 s6(x, y, z);\n        std::cout << s5 << std::endl;\n        CHECK(cpa4.Parameter() == 2.0);\n        CHECK(s5.X() == s6.X());\n        CHECK(s5.Y() == s6.Y());\n        CHECK(s5.Z() == s6.Z());\n        std::cout << \"߳Ϊ\" << ComputePointsAbscissa::Length(line1) << '\n';\n        CHECK(ComputePointsAbscissa::Length(line1) == 6.0);\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API ComputePointsAbscissa(const Adaptor2Curve& c, double abscissa, double u0, double ui)\t @param ui The initial guess of the parameter\n\t @param u0 The starting parameter\n\t @param abscissa The arc length\n\t @param c The curve\n\t @brief Compute the parameter of a point on a 2D curve with given arc length and an initial guess\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/MakeGeom2Circle.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/ComputePointsAbscissa.hpp>\n#include <geometry/MakeGeom3Circle.hpp>\n#include <geometry/AdaptorGeom3Curve.hpp>\n#include <geometry/MakeGeom2Hyperbola.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/MakeGeom2Ellipse.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <geometry/MakeGeom3Ellipse.hpp>\n#include <geometry/MakeGeom3Hyperbola.hpp>\n#include <geometry/Geom2Line.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include<modeling/MakeEdge.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/MakeGeom2Parabola.hpp>\n#include <geometry/MakeGeom3Parabola.hpp>\n#include <geometry/Geom2BezierCurve.hpp>\n#include <geometry/Geom3BezierCurve.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2OffsetCurve.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\nTEST_CASE(\"test the parameters for calculating a point on a 2D curve with a given arc length and the length of the 2D curve.\", \"[geometry][ComputePointsAbscissa][case1]\")\n{\n\tSECTION(\"circle\")\n    {\n        double r = 2.0;\n        double l = 1.0;\n        std::shared_ptr<Geom2Curve> c = MakeGeom2Circle(Point2(0.0, 0.0), 2.0).Value();\n        AdaptorGeom2Curve circle(c);\n        ComputePointsAbscissa cpa(circle, 1.0, 0.0);\n        double angle1 = l / r;\n        std::cout << \"ԲĽǵĻֵΪ\" << \": \" << angle1 << '\n';\n        double x = r * cos(angle1);\n        double y = r * sin(angle1);\n        std::cout << \"xֵΪ\" << \": \" << x << '\n';\n        std::cout << \"yֵΪ\" << \": \" << y << '\n';\n        double param = cpa.Parameter();\n        if (cpa.IsDone())\n        {\n            std::cout << param << \": \" << circle.Value(param) << '\n';\n        }\n        double p = 2 * M_PI * r;\n        std::cout << \"߳Ϊ\" << ComputePointsAbscissa::Length(circle) << '\n';\n        Point2 s = circle.Value(param);\n        Point2 s1(x, y);\n        std::cout << s << std::endl;\n        CHECK(p == ComputePointsAbscissa::Length(circle));\n        CHECK(angle1 == cpa.Parameter());\n        CHECK(s.X() == s1.X());\n        CHECK(s.Y() == s1.Y());\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API ComputePointsAbscissa(const Adaptor3Curve& c, double abscissa, double u0, double ui)\t @param ui The initial guess of the parameter\n\t @param u0 The starting parameter\n\t @param abscissa The arc length\n\t @param c The curve\n\t @brief Compute the parameter of a point on a 3D curve with given arc length and an initial guess\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/MakeGeom2Circle.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/ComputePointsAbscissa.hpp>\n#include <geometry/MakeGeom3Circle.hpp>\n#include <geometry/AdaptorGeom3Curve.hpp>\n#include <geometry/MakeGeom2Hyperbola.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/MakeGeom2Ellipse.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <geometry/MakeGeom3Ellipse.hpp>\n#include <geometry/MakeGeom3Hyperbola.hpp>\n#include <geometry/Geom2Line.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include<modeling/MakeEdge.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/MakeGeom2Parabola.hpp>\n#include <geometry/MakeGeom3Parabola.hpp>\n#include <geometry/Geom2BezierCurve.hpp>\n#include <geometry/Geom3BezierCurve.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2OffsetCurve.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\nTEST_CASE(\"tset the parameters for calculating a point on a 3D curve of a given arc length and the length of the 3D curve.\", \"[geometry][ComputePointsAbscissa][case5]\")\n{\n\tSECTION(\"circle\")\n    {\n        Frame3 frame;\n        double r = 2.0;\n        double l = 1.0;\n        std::shared_ptr<Geom3Curve> c = MakeGeom3Circle(frame, r).Value();\n        AdaptorGeom3Curve circle(c);\n        ComputePointsAbscissa cpa(circle, 1.0, 0.0);\n        double angle1 = l / r;\n        std::cout << \"ԲĽǵĻֵΪ\" << \": \" << angle1 << '\n';\n        double x = r * cos(angle1);\n        double y = r * sin(angle1);\n        double z = 0;\n        std::cout << \"xֵΪ\" << \": \" << x << '\n';\n        std::cout << \"yֵΪ\" << \": \" << y << '\n';\n        std::cout << \"zֵΪ\" << \": \" << z << '\n';\n        double param = cpa.Parameter();\n        if (cpa.IsDone())\n        {\n            std::cout << param << \": \" << circle.Value(param) << '\n';\n        }\n        double p = 2 * M_PI * r;\n        std::cout << \"߳Ϊ\" << ComputePointsAbscissa::Length(circle) << '\n';\n        Point3 s = circle.Value(param);\n        Point3 s1(x, y, z);\n        std::cout << s << std::endl;\n        CHECK(p == ComputePointsAbscissa::Length(circle));\n        CHECK(angle1 == cpa.Parameter());\n        CHECK(s.X() == s1.X());\n        CHECK(s.Y() == s1.Y());\n        CHECK(s.Z() == s1.Z());\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API ComputePointsAbscissa(const Adaptor2Curve& c, double abscissa, double u0)\t @param u0 The starting parameter\n\t @param abscissa The arc length\n\t @param c The curve\n\t @brief Compute the parameter of a point on a 2D curve with given arc length\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/MakeGeom2Circle.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/ComputePointsAbscissa.hpp>\n#include <geometry/MakeGeom3Circle.hpp>\n#include <geometry/AdaptorGeom3Curve.hpp>\n#include <geometry/MakeGeom2Hyperbola.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/MakeGeom2Ellipse.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <geometry/MakeGeom3Ellipse.hpp>\n#include <geometry/MakeGeom3Hyperbola.hpp>\n#include <geometry/Geom2Line.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include<modeling/MakeEdge.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/MakeGeom2Parabola.hpp>\n#include <geometry/MakeGeom3Parabola.hpp>\n#include <geometry/Geom2BezierCurve.hpp>\n#include <geometry/Geom3BezierCurve.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2OffsetCurve.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\nTEST_CASE(\"test the parameters for calculating a point on a 2D curve with a given arc length and the length of the 2D curve.\", \"[geometry][ComputePointsAbscissa][case1]\")\n{\n\tSECTION(\"circle\")\n    {\n        double r = 2.0;\n        double l = 1.0;\n        std::shared_ptr<Geom2Curve> c = MakeGeom2Circle(Point2(0.0, 0.0), 2.0).Value();\n        AdaptorGeom2Curve circle(c);\n        ComputePointsAbscissa cpa(circle, 1.0, 0.0);\n        double angle1 = l / r;\n        std::cout << \"ԲĽǵĻֵΪ\" << \": \" << angle1 << '\n';\n        double x = r * cos(angle1);\n        double y = r * sin(angle1);\n        std::cout << \"xֵΪ\" << \": \" << x << '\n';\n        std::cout << \"yֵΪ\" << \": \" << y << '\n';\n        double param = cpa.Parameter();\n        if (cpa.IsDone())\n        {\n            std::cout << param << \": \" << circle.Value(param) << '\n';\n        }\n        double p = 2 * M_PI * r;\n        std::cout << \"߳Ϊ\" << ComputePointsAbscissa::Length(circle) << '\n';\n        Point2 s = circle.Value(param);\n        Point2 s1(x, y);\n        std::cout << s << std::endl;\n        CHECK(p == ComputePointsAbscissa::Length(circle));\n        CHECK(angle1 == cpa.Parameter());\n        CHECK(s.X() == s1.X());\n        CHECK(s.Y() == s1.Y());\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API ComputePointsAbscissa(const Adaptor3Curve& c, double abscissa, double u0)\t @param u0 The starting parameter\n\t @param abscissa The arc length\n\t @param c The curve\n\t @brief Compute the parameter of a point on a 3D curve with given arc length\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/MakeGeom2Circle.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/ComputePointsAbscissa.hpp>\n#include <geometry/MakeGeom3Circle.hpp>\n#include <geometry/AdaptorGeom3Curve.hpp>\n#include <geometry/MakeGeom2Hyperbola.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/MakeGeom2Ellipse.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <geometry/MakeGeom3Ellipse.hpp>\n#include <geometry/MakeGeom3Hyperbola.hpp>\n#include <geometry/Geom2Line.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include<modeling/MakeEdge.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/MakeGeom2Parabola.hpp>\n#include <geometry/MakeGeom3Parabola.hpp>\n#include <geometry/Geom2BezierCurve.hpp>\n#include <geometry/Geom3BezierCurve.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2OffsetCurve.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\nTEST_CASE(\"tset the parameters for calculating a point on a 3D curve of a given arc length and the length of the 3D curve.\", \"[geometry][ComputePointsAbscissa][case5]\")\n{\n\tSECTION(\"circle\")\n    {\n        Frame3 frame;\n        double r = 2.0;\n        double l = 1.0;\n        std::shared_ptr<Geom3Curve> c = MakeGeom3Circle(frame, r).Value();\n        AdaptorGeom3Curve circle(c);\n        ComputePointsAbscissa cpa(circle, 1.0, 0.0);\n        double angle1 = l / r;\n        std::cout << \"ԲĽǵĻֵΪ\" << \": \" << angle1 << '\n';\n        double x = r * cos(angle1);\n        double y = r * sin(angle1);\n        double z = 0;\n        std::cout << \"xֵΪ\" << \": \" << x << '\n';\n        std::cout << \"yֵΪ\" << \": \" << y << '\n';\n        std::cout << \"zֵΪ\" << \": \" << z << '\n';\n        double param = cpa.Parameter();\n        if (cpa.IsDone())\n        {\n            std::cout << param << \": \" << circle.Value(param) << '\n';\n        }\n        double p = 2 * M_PI * r;\n        std::cout << \"߳Ϊ\" << ComputePointsAbscissa::Length(circle) << '\n';\n        Point3 s = circle.Value(param);\n        Point3 s1(x, y, z);\n        std::cout << s << std::endl;\n        CHECK(p == ComputePointsAbscissa::Length(circle));\n        CHECK(angle1 == cpa.Parameter());\n        CHECK(s.X() == s1.X());\n        CHECK(s.Y() == s1.Y());\n        CHECK(s.Z() == s1.Z());\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API ComputePointsAbscissa(double tol, const Adaptor2Curve& c, double abscissa, double u0)\t @param u0 The starting parameter\n\t @param abscissa The arc length\n\t @param c The curve\n\t @param tol The tolerance\n\t @brief Compute the parameter of a point on a 2D curve with given arc length and a tolerance\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/MakeGeom2Circle.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/ComputePointsAbscissa.hpp>\n#include <geometry/MakeGeom3Circle.hpp>\n#include <geometry/AdaptorGeom3Curve.hpp>\n#include <geometry/MakeGeom2Hyperbola.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/MakeGeom2Ellipse.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <geometry/MakeGeom3Ellipse.hpp>\n#include <geometry/MakeGeom3Hyperbola.hpp>\n#include <geometry/Geom2Line.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include<modeling/MakeEdge.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/MakeGeom2Parabola.hpp>\n#include <geometry/MakeGeom3Parabola.hpp>\n#include <geometry/Geom2BezierCurve.hpp>\n#include <geometry/Geom3BezierCurve.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2OffsetCurve.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\nTEST_CASE(\"test the parameters for calculating a point on a 2D curve with a given arc length and the length of the 2D curve.\", \"[geometry][ComputePointsAbscissa][case1]\")\n{\n\tSECTION(\"circle\")\n    {\n        double r = 2.0;\n        double l = 1.0;\n        std::shared_ptr<Geom2Curve> c = MakeGeom2Circle(Point2(0.0, 0.0), 2.0).Value();\n        AdaptorGeom2Curve circle(c);\n        ComputePointsAbscissa cpa(circle, 1.0, 0.0);\n        double angle1 = l / r;\n        std::cout << \"ԲĽǵĻֵΪ\" << \": \" << angle1 << '\n';\n        double x = r * cos(angle1);\n        double y = r * sin(angle1);\n        std::cout << \"xֵΪ\" << \": \" << x << '\n';\n        std::cout << \"yֵΪ\" << \": \" << y << '\n';\n        double param = cpa.Parameter();\n        if (cpa.IsDone())\n        {\n            std::cout << param << \": \" << circle.Value(param) << '\n';\n        }\n        double p = 2 * M_PI * r;\n        std::cout << \"߳Ϊ\" << ComputePointsAbscissa::Length(circle) << '\n';\n        Point2 s = circle.Value(param);\n        Point2 s1(x, y);\n        std::cout << s << std::endl;\n        CHECK(p == ComputePointsAbscissa::Length(circle));\n        CHECK(angle1 == cpa.Parameter());\n        CHECK(s.X() == s1.X());\n        CHECK(s.Y() == s1.Y());\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API ComputePointsAbscissa(double tol, const Adaptor3Curve& c, double abscissa, double u0)\t @param u0 The starting parameter\n\t @param abscissa The arc length\n\t @param c The curve\n\t @param tol The tolerance\n\t @brief Compute the parameter of a point on a 3D curve with given arc length and a tolerance\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/MakeGeom2Circle.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/ComputePointsAbscissa.hpp>\n#include <geometry/MakeGeom3Circle.hpp>\n#include <geometry/AdaptorGeom3Curve.hpp>\n#include <geometry/MakeGeom2Hyperbola.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/MakeGeom2Ellipse.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <geometry/MakeGeom3Ellipse.hpp>\n#include <geometry/MakeGeom3Hyperbola.hpp>\n#include <geometry/Geom2Line.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include<modeling/MakeEdge.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/MakeGeom2Parabola.hpp>\n#include <geometry/MakeGeom3Parabola.hpp>\n#include <geometry/Geom2BezierCurve.hpp>\n#include <geometry/Geom3BezierCurve.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2OffsetCurve.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\nTEST_CASE(\"tset the parameters for calculating a point on a 3D curve of a given arc length and the length of the 3D curve.\", \"[geometry][ComputePointsAbscissa][case5]\")\n{\n\tSECTION(\"circle\")\n    {\n        Frame3 frame;\n        double r = 2.0;\n        double l = 1.0;\n        std::shared_ptr<Geom3Curve> c = MakeGeom3Circle(frame, r).Value();\n        AdaptorGeom3Curve circle(c);\n        ComputePointsAbscissa cpa(circle, 1.0, 0.0);\n        double angle1 = l / r;\n        std::cout << \"ԲĽǵĻֵΪ\" << \": \" << angle1 << '\n';\n        double x = r * cos(angle1);\n        double y = r * sin(angle1);\n        double z = 0;\n        std::cout << \"xֵΪ\" << \": \" << x << '\n';\n        std::cout << \"yֵΪ\" << \": \" << y << '\n';\n        std::cout << \"zֵΪ\" << \": \" << z << '\n';\n        double param = cpa.Parameter();\n        if (cpa.IsDone())\n        {\n            std::cout << param << \": \" << circle.Value(param) << '\n';\n        }\n        double p = 2 * M_PI * r;\n        std::cout << \"߳Ϊ\" << ComputePointsAbscissa::Length(circle) << '\n';\n        Point3 s = circle.Value(param);\n        Point3 s1(x, y, z);\n        std::cout << s << std::endl;\n        CHECK(p == ComputePointsAbscissa::Length(circle));\n        CHECK(angle1 == cpa.Parameter());\n        CHECK(s.X() == s1.X());\n        CHECK(s.Y() == s1.Y());\n        CHECK(s.Z() == s1.Z());\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar> [[nodiscard]] PointT Translated(const VectorT<OtherScalar, DIM>& vec),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.1\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Point3\", \"[Common][Point3]\") {\n\tSECTION(\"Translate(vec)\") {\n        PointT<double, 3> p1(1.0, 2.0, 3.0);\n        VectorT<double, 3> v1(2.0, 3.0, 4.0);\n        PointT<double, 3> p2(3.0, 5.0, 7.0);\n        CHECK(p1.Translated(v1).IsEqual(p2, tol));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, typename OtherScalar2, int DIM2 = DIM, typename = typename std::enable_if_t<DIM2 == 3>> [[nodiscard]] PointT Rotated(const AxisT<OtherScalar, DIM>& axis, const OtherScalar2& angle),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.1\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Point3\", \"[Common][Point3]\") {\n\tSECTION(\"Rotate 3D\") {\n        PointT<double, 3> p1(1.0, 2.0, 3.0);\n        PointT<double, 3> p2(2.0, 3.0, 4.0);\n        DirectionT<double, 3> d(1.0, 1.0, 2.0);\n        AxisT<double, 3> a(p2, d);\n        PointT<double, 3> p3((8.0 + std::sqrt(6.0)) / 6.0, (14.0 - std::sqrt(6.0)) / 6.0, 8.0 / 3.0);\n        CHECK(p1.Rotated(a, M_PI_2).IsEqual(p3, tol));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, typename OtherScalar2, int DIM2 = DIM, typename = typename std::enable_if_t<DIM2 == 3>> PointT& Rotate(const AxisT<OtherScalar, DIM>& axis, const OtherScalar2& angle),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.1\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Point3\", \"[Common][Point3]\") {\n\tSECTION(\"Rotate 3D\") {\n        PointT<double, 3> p1(1.0, 2.0, 3.0);\n        PointT<double, 3> p2(2.0, 3.0, 4.0);\n        DirectionT<double, 3> d(1.0, 1.0, 2.0);\n        AxisT<double, 3> a(p2, d);\n        PointT<double, 3> p3((8.0 + std::sqrt(6.0)) / 6.0, (14.0 - std::sqrt(6.0)) / 6.0, 8.0 / 3.0);\n        CHECK(p1.Rotated(a, M_PI_2).IsEqual(p3, tol));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, int DIM2 = DIM, std::enable_if_t<DIM2 == 3, int> = 0> [[nodiscard]] PointT Mirrored(const FrameT<OtherScalar, DIM>& frame),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.1\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Point3\", \"[Common][Point3]\") {\n\tSECTION(\"Mirror(point) 3D\") {\n        PointT<double, 3> p1(1.0, 2.0, 3.0);\n        PointT<double, 3> p2(2.0, 4.0, 5.0);\n        PointT<double, 3> p3(3.0, 6.0, 7.0);\n        CHECK(p1.Mirrored(p2).IsEqual(p3, tol));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar> [[nodiscard]] PointT Mirrored(const AxisT<OtherScalar, DIM>& axis),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.1\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Point3\", \"[Common][Point3]\") {\n\tSECTION(\"Mirror(axis) 3D\") {\n        PointT<double, 3> p1(1.0, 2.0, 3.0);\n        PointT<double, 3> p2(2.0, 3.0, 4.0);\n        DirectionT<double, 3> d(7.0, 3.0, 2.0);\n        AxisT<double, 3> a(p2, d);\n        PointT<double, 3> p3(9.0 / 31.0, 88.0 / 31.0, 131.0 / 31.0);\n        CHECK(p1.Mirrored(a).IsEqual(p3, tol));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, int DIM2 = DIM, std::enable_if_t<DIM2 == 3, int> = 0> PointT& Mirror(const FrameT<OtherScalar, DIM>& frame),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.1\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Point3\", \"[Common][Point3]\") {\n\tSECTION(\"Mirror(axis) 3D\") {\n        PointT<double, 3> p1(1.0, 2.0, 3.0);\n        PointT<double, 3> p2(2.0, 3.0, 4.0);\n        DirectionT<double, 3> d(7.0, 3.0, 2.0);\n        AxisT<double, 3> a(p2, d);\n        PointT<double, 3> p3(9.0 / 31.0, 88.0 / 31.0, 131.0 / 31.0);\n        CHECK(p1.Mirrored(a).IsEqual(p3, tol));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar> PointT& Mirror(const AxisT<OtherScalar, DIM>& axis),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.1\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Point3\", \"[Common][Point3]\") {\n\tSECTION(\"Mirror(axis) 3D\") {\n        PointT<double, 3> p1(1.0, 2.0, 3.0);\n        PointT<double, 3> p2(2.0, 3.0, 4.0);\n        DirectionT<double, 3> d(7.0, 3.0, 2.0);\n        AxisT<double, 3> a(p2, d);\n        PointT<double, 3> p3(9.0 / 31.0, 88.0 / 31.0, 131.0 / 31.0);\n        CHECK(p1.Mirrored(a).IsEqual(p3, tol));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar> PointT& Mirror(const PointT<OtherScalar, DIM>& p),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.1\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Point3\", \"[Common][Point3]\") {\n\tSECTION(\"Mirror(axis) 3D\") {\n        PointT<double, 3> p1(1.0, 2.0, 3.0);\n        PointT<double, 3> p2(2.0, 3.0, 4.0);\n        DirectionT<double, 3> d(7.0, 3.0, 2.0);\n        AxisT<double, 3> a(p2, d);\n        PointT<double, 3> p3(9.0 / 31.0, 88.0 / 31.0, 131.0 / 31.0);\n        CHECK(p1.Mirrored(a).IsEqual(p3, tol));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar> [[nodiscard]] auto SquaredDistance(const PointT<OtherScalar, DIM>& other),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.1\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Point3\", \"[Common][Point3]\") {\n\tSECTION(\"SquaredDistance\") {\n        PointT<double, 3> p1(1.0, 2.0, 3.0);\n        PointT<double, 3> p2(1.1, 2.2, 3.3);\n        CHECK(p1.SquaredDistance(p2) == Approx(0.14));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar> [[nodiscard]] auto Distance(const PointT<OtherScalar, DIM>& other),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.1\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Point3\", \"[Common][Point3]\") {\n\tSECTION(\"Distance\") {\n        PointT<double, 3> p1(1.0, 2.0, 3.0);\n        PointT<double, 3> p2(1.4, 2.5, 3.6);\n        CHECK(p1.Distance(p2) == sqrt(0.77));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, typename OtherScalar2> [[nodiscard]] bool IsEqual(const PointT<OtherScalar, DIM>& other, const OtherScalar2& tol),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.1\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Point3\", \"[Common][Point3]\") {\n\tSECTION(\"Constructor\",\"[2]\") {\n        Coord3 v(1.0, 2.0, 3.0);\n        Point3 result(v);\n        Point3 expected(1.0, 2.0, 3.0);\n        CHECK(result.IsEqual(expected, tol));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "PointT()\t @details The default point is (0, 0, ..., 0)\n\t @brief Default constructor\n,\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.1\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Point3\", \"[Common][Point3]\") {\n\tSECTION(\"Default constructor\",\"[1]\") {\n        Point3  p1;\n        Point3  p2(0.0, 0.0, 0.0);\n        CHECK(p1.IsEqual(p2, tol));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, typename OtherScalar2, int DIM2 = DIM, typename = typename std::enable_if_t<DIM2 == 2>> [[nodiscard]] PointT Rotated(const PointT<OtherScalar, DIM>& point, const OtherScalar2& angle),\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <iostream>\n#define tol 0.001\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Point2\", \"[Common][Point2]\") {\n\tSECTION(\"Rotate 2D\") {\n        PointT<double, 2> p1(1.0, 2.0);\n        PointT<double, 2> p2(2.0, 3.0);\n        PointT<double, 2> p3(3.0, 2.0);\n        CHECK(p1.Rotated(p2, M_PI_2).IsEqual(p3, tol));\n    }\n}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar> [[nodiscard]] PointT Mirrored(const AxisT<OtherScalar, DIM>& axis),\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <iostream>\n#define tol 0.001\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Point2\", \"[Common][Point2]\") {\n\tSECTION(\"Mirror(axis) 2D\") {\n        PointT<double, 2> p1(1.0, 2.0);\n        PointT<double, 2> p2(2.0, 3.0);\n        DirectionT<double, 2> d(7.0, 3.0);\n        AxisT<double, 2> a(p2, d);\n        PointT<double, 2> p3(17.0 / 29.0, 86.0 / 29.0);\n        CHECK(p1.Mirrored(a).IsEqual(p3, tol));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar> [[nodiscard]] PointT Mirrored(const PointT<OtherScalar, DIM>& p),\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <iostream>\n#define tol 0.001\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Point2\", \"[Common][Point2]\") {\n\tSECTION(\"Mirror(axis) 2D\") {\n        PointT<double, 2> p1(1.0, 2.0);\n        PointT<double, 2> p2(2.0, 3.0);\n        DirectionT<double, 2> d(7.0, 3.0);\n        AxisT<double, 2> a(p2, d);\n        PointT<double, 2> p3(17.0 / 29.0, 86.0 / 29.0);\n        CHECK(p1.Mirrored(a).IsEqual(p3, tol));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar> PointT& Mirror(const AxisT<OtherScalar, DIM>& axis),\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <iostream>\n#define tol 0.001\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Point2\", \"[Common][Point2]\") {\n\tSECTION(\"Mirror(axis) 2D\") {\n        PointT<double, 2> p1(1.0, 2.0);\n        PointT<double, 2> p2(2.0, 3.0);\n        DirectionT<double, 2> d(7.0, 3.0);\n        AxisT<double, 2> a(p2, d);\n        PointT<double, 2> p3(17.0 / 29.0, 86.0 / 29.0);\n        CHECK(p1.Mirrored(a).IsEqual(p3, tol));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar> PointT& Mirror(const PointT<OtherScalar, DIM>& p),\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <iostream>\n#define tol 0.001\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Point2\", \"[Common][Point2]\") {\n\tSECTION(\"Mirror(axis) 2D\") {\n        PointT<double, 2> p1(1.0, 2.0);\n        PointT<double, 2> p2(2.0, 3.0);\n        DirectionT<double, 2> d(7.0, 3.0);\n        AxisT<double, 2> a(p2, d);\n        PointT<double, 2> p3(17.0 / 29.0, 86.0 / 29.0);\n        CHECK(p1.Mirrored(a).IsEqual(p3, tol));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar> void Transform(CoordT<OtherScalar, DIM>& coord),\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T>\nbool IsEqual(const T& result, const T& expected)\n{\n\treturn result == expected;\n}\nbool IsEqual(const double& result, const double& expected)\n{\n\treturn std::fabs(result - expected) <= 1e-6;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)\n{\n\tfor (int i = 0; i < DIM; i++)\n\t{\n\t\tif (!IsEqual(result[i], expected[i]))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int ROW, int COL>\nbool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)\n{\n\tfor (int i = 0; i < ROW; i++)\n\t{\n\t\tfor (int j = 0; j < COL; j++)\n\t\t{\n\t\t\tif (!IsEqual(result(i, j), expected(i, j)))\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)\n{\n\treturn IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());\n}\nTEST_CASE(\"case1:this is a case for Transformation3\",\"[Common][Transformation3]\")\n{\n\tSECTION(\"SetMirror point 3D\") {\n\t\tTransformationT<double, 3> tr;\n\t\tPointT<double, 3> p(1.0, 2.0, 3.0);\n\t\ttr.SetMirror(p);\n\t\tCoordT<double, 3> p2(0.0, 1.0, 2.0);\n\t\ttr.Transform(p2);\n\t\tCoordT<double, 3> p3(2.0, 3.0, 4.0);\n\t\tCHECK(IsEqual(p2, p3));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] TransformationT Powered(int power)\t @return The power of transformation\n\t @param power The exponential\n\t @brief Get the power of transformation\n,\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T>\nbool IsEqual(const T& result, const T& expected)\n{\n\treturn result == expected;\n}\nbool IsEqual(const double& result, const double& expected)\n{\n\treturn std::fabs(result - expected) <= 1e-6;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)\n{\n\tfor (int i = 0; i < DIM; i++)\n\t{\n\t\tif (!IsEqual(result[i], expected[i]))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int ROW, int COL>\nbool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)\n{\n\tfor (int i = 0; i < ROW; i++)\n\t{\n\t\tfor (int j = 0; j < COL; j++)\n\t\t{\n\t\t\tif (!IsEqual(result(i, j), expected(i, j)))\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)\n{\n\treturn IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());\n}\nTEST_CASE(\"case1:this is a case for Transformation3\",\"[Common][Transformation3]\")\n{\n\tSECTION(\"Power\") {\n\t\tTransformationT<double, 3> tr;\n\t\ttr.SetRotation(Axis3(Point3(1.0, 2.0, 3.0), Direction3(1.0, 1.0, 1.0)), M_PI_2);\n\t\tTransformationT<double, 3> tr2;\n\t\ttr2.SetRotation(Axis3(Point3(1.0, 2.0, 3.0), Direction3(1.0, 1.0, 1.0)), M_PI);\n\t\tCHECK(IsEqual(tr.Powered(2), tr2));\n\t}\n}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar> [[nodiscard]] TransformationT LeftMultiplied(const TransformationT<OtherScalar, DIM>& other),\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T>\nbool IsEqual(const T& result, const T& expected)\n{\n\treturn result == expected;\n}\nbool IsEqual(const double& result, const double& expected)\n{\n\treturn std::fabs(result - expected) <= 1e-6;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)\n{\n\tfor (int i = 0; i < DIM; i++)\n\t{\n\t\tif (!IsEqual(result[i], expected[i]))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int ROW, int COL>\nbool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)\n{\n\tfor (int i = 0; i < ROW; i++)\n\t{\n\t\tfor (int j = 0; j < COL; j++)\n\t\t{\n\t\t\tif (!IsEqual(result(i, j), expected(i, j)))\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)\n{\n\treturn IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());\n}\nTEST_CASE(\"case1:this is a case for Transformation3\",\"[Common][Transformation3]\")\n{\n\tSECTION(\"LeftMultiply\") {\n\t\tTransformationT<double, 3> tr;\n\t\ttr.SetRotation(Axis3(Point3(1.0, 2.0, 3.0), Direction3(1.0, 1.0, 1.0)), M_PI_2);\n\t\tTransformationT<double, 3> tr2;\n\t\ttr2.SetRotation(Axis3(Point3(2.0, 3.0, 4.0), Direction3(1.0, 1.0, 2.0)), M_PI_2);\n\t\tCHECK(IsEqual(tr * tr2, tr2.LeftMultiplied(tr)));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar> TransformationT& LeftMultiply(const TransformationT<OtherScalar, DIM>& other),\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T>\nbool IsEqual(const T& result, const T& expected)\n{\n\treturn result == expected;\n}\nbool IsEqual(const double& result, const double& expected)\n{\n\treturn std::fabs(result - expected) <= 1e-6;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)\n{\n\tfor (int i = 0; i < DIM; i++)\n\t{\n\t\tif (!IsEqual(result[i], expected[i]))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int ROW, int COL>\nbool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)\n{\n\tfor (int i = 0; i < ROW; i++)\n\t{\n\t\tfor (int j = 0; j < COL; j++)\n\t\t{\n\t\t\tif (!IsEqual(result(i, j), expected(i, j)))\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)\n{\n\treturn IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());\n}\nTEST_CASE(\"case1:this is a case for Transformation3\",\"[Common][Transformation3]\")\n{\n\tSECTION(\"operator*\") {\n\t\tTransformationT<double, 3> tr;\n\t\ttr.SetRotation(Axis3(Point3(1.0, 2.0, 3.0), Direction3(1.0, 1.0, 1.0)), M_PI_2);\n\t\tTransformationT<double, 3> tr2;\n\t\ttr2.SetRotation(Axis3(Point3(1.0, 2.0, 3.0), Direction3(1.0, 1.0, 1.0)), M_PI_2);\n\t\tTransformationT<double, 3> tr3;\n\t\ttr3.SetRotation(Axis3(Point3(1.0, 2.0, 3.0), Direction3(1.0, 1.0, 1.0)), M_PI);\n\t\tCHECK(IsEqual(tr * tr2, tr3));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "TransformationT& Invert()\t @return The reference to self\n\t @brief Invert the transformation\n,\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T>\nbool IsEqual(const T& result, const T& expected)\n{\n\treturn result == expected;\n}\nbool IsEqual(const double& result, const double& expected)\n{\n\treturn std::fabs(result - expected) <= 1e-6;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)\n{\n\tfor (int i = 0; i < DIM; i++)\n\t{\n\t\tif (!IsEqual(result[i], expected[i]))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int ROW, int COL>\nbool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)\n{\n\tfor (int i = 0; i < ROW; i++)\n\t{\n\t\tfor (int j = 0; j < COL; j++)\n\t\t{\n\t\t\tif (!IsEqual(result(i, j), expected(i, j)))\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)\n{\n\treturn IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());\n}\nTEST_CASE(\"case1:this is a case for Transformation3\",\"[Common][Transformation3]\")\n{\n\tSECTION(\"Invert\") {\n\t\tTransformationT<double, 3> tr;\n\t\ttr.SetRotation(Axis3(Point3(1.0, 2.0, 3.0), Direction3(1.0, 1.0, 1.0)), M_PI_2);\n\t\ttr.Invert();\n\t\tTransformationT<double, 3> tr2;\n\t\ttr2.SetRotation(Axis3(Point3(1.0, 2.0, 3.0), Direction3(1.0, 1.0, 1.0)), -M_PI_2);\n\t\tCHECK(IsEqual(tr, tr2));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] const MatrixT<Scalar, DIM, DIM>& HVectorialPart()\t @return The homogeneous matrix\n\t @brief Get the homogeneous vectorial part of the transformation, i.e. the rotation matrix\n,\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T>\nbool IsEqual(const T& result, const T& expected)\n{\n\treturn result == expected;\n}\nbool IsEqual(const double& result, const double& expected)\n{\n\treturn std::fabs(result - expected) <= 1e-6;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)\n{\n\tfor (int i = 0; i < DIM; i++)\n\t{\n\t\tif (!IsEqual(result[i], expected[i]))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int ROW, int COL>\nbool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)\n{\n\tfor (int i = 0; i < ROW; i++)\n\t{\n\t\tfor (int j = 0; j < COL; j++)\n\t\t{\n\t\t\tif (!IsEqual(result(i, j), expected(i, j)))\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)\n{\n\treturn IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());\n}\nTEST_CASE(\"case1:this is a case for Transformation3\",\"[Common][Transformation3]\")\n{\n\tSECTION(\"default constructor 3D\") {\n\t\tTransformationT<double, 3> tr;\n\t\tMatrixT<double, 3, 3> mat;\n\t\tmat.SetIdentity();\n\t\tCoordT<double, 3> c;\n\t\tdouble scale = 1.0;\n\t\tCHECK(IsEqual(tr.ScaleFactor(), scale));\n\t\tCHECK(IsEqual(tr.Type(), TransformationType::Identity));\n\t\tCHECK(IsEqual(tr.HVectorialPart(), mat));\n\t\tCHECK(IsEqual(tr.TranslationPart(), c));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, typename OtherScalar2, int DIM2 = DIM, typename = typename std::enable_if_t<DIM2 == 3>> void GetRotation(CoordT<OtherScalar, DIM>& axis, OtherScalar2& angle),\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T>\nbool IsEqual(const T& result, const T& expected)\n{\n\treturn result == expected;\n}\nbool IsEqual(const double& result, const double& expected)\n{\n\treturn std::fabs(result - expected) <= 1e-6;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)\n{\n\tfor (int i = 0; i < DIM; i++)\n\t{\n\t\tif (!IsEqual(result[i], expected[i]))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int ROW, int COL>\nbool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)\n{\n\tfor (int i = 0; i < ROW; i++)\n\t{\n\t\tfor (int j = 0; j < COL; j++)\n\t\t{\n\t\t\tif (!IsEqual(result(i, j), expected(i, j)))\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)\n{\n\treturn IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());\n}\nTEST_CASE(\"case1:this is a case for Transformation3\",\"[Common][Transformation3]\")\n{\n\tSECTION(\"GetRotation\") {\n\t\tTransformationT<double, 3> tr;\n\t\ttr.SetRotation(Axis3(Point3(1.0, 2.0, 3.0), Direction3(1.0, 1.0, 1.0)), M_PI_2);\n\t\tCoordT<double, 3> axis;\n\t\tdouble angle;\n\t\ttr.GetRotation(axis, angle);\n\t\tCoordT<double, 3> axis2(1.0 / std::sqrt(3.0));\n\t\tdouble angle2 = M_PI_2;\n\t\tCHECK(IsEqual(axis, axis2));\n\t\tCHECK(IsEqual(angle, angle2));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] Scalar ScaleFactor()\t @return The scale factor\n\t @brief Get the scale factor of the transformation\n,\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T>\nbool IsEqual(const T& result, const T& expected)\n{\n\treturn result == expected;\n}\nbool IsEqual(const double& result, const double& expected)\n{\n\treturn std::fabs(result - expected) <= 1e-6;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)\n{\n\tfor (int i = 0; i < DIM; i++)\n\t{\n\t\tif (!IsEqual(result[i], expected[i]))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int ROW, int COL>\nbool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)\n{\n\tfor (int i = 0; i < ROW; i++)\n\t{\n\t\tfor (int j = 0; j < COL; j++)\n\t\t{\n\t\t\tif (!IsEqual(result(i, j), expected(i, j)))\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)\n{\n\treturn IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());\n}\nTEST_CASE(\"case1:this is a case for Transformation3\",\"[Common][Transformation3]\")\n{\n\tSECTION(\"default constructor 3D\") {\n\t\tTransformationT<double, 3> tr;\n\t\tMatrixT<double, 3, 3> mat;\n\t\tmat.SetIdentity();\n\t\tCoordT<double, 3> c;\n\t\tdouble scale = 1.0;\n\t\tCHECK(IsEqual(tr.ScaleFactor(), scale));\n\t\tCHECK(IsEqual(tr.Type(), TransformationType::Identity));\n\t\tCHECK(IsEqual(tr.HVectorialPart(), mat));\n\t\tCHECK(IsEqual(tr.TranslationPart(), c));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "void SetType(const TransformationType& t)\t @param t The new type of transformation\n\t @brief Set the type of transformation\n,\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T>\nbool IsEqual(const T& result, const T& expected)\n{\n\treturn result == expected;\n}\nbool IsEqual(const double& result, const double& expected)\n{\n\treturn std::fabs(result - expected) <= 1e-6;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)\n{\n\tfor (int i = 0; i < DIM; i++)\n\t{\n\t\tif (!IsEqual(result[i], expected[i]))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int ROW, int COL>\nbool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)\n{\n\tfor (int i = 0; i < ROW; i++)\n\t{\n\t\tfor (int j = 0; j < COL; j++)\n\t\t{\n\t\t\tif (!IsEqual(result(i, j), expected(i, j)))\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)\n{\n\treturn IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());\n}\nTEST_CASE(\"case1:this is a case for Transformation3\",\"[Common][Transformation3]\")\n{\n\tSECTION(\"SetValues 3D\") {\n\t\tTransformationT<double, 3> tr;\n\t\tdouble a = 1.0 / 3.0;\n\t\tdouble b = 1.0 / 3.0 - 1.0 / std::sqrt(3.0);\n\t\tdouble c = 1.0 / 3.0 + 1.0 / std::sqrt(3.0);\n\t\ttr.SetValues(a, b, c, -1.0 - 1.0 / std::sqrt(3.0), c, a, b, 2.0 / std::sqrt(3.0), b, c, a, 1.0 - 1.0 / std::sqrt(3.0));\n\t\ttr.SetType(TransformationType::Rotation);\n\t\tTransformationT<double, 3> tr2;\n\t\ttr2.SetRotation(Axis3(Point3(1.0, 2.0, 3.0), Direction3(1.0, 1.0, 1.0)), M_PI_2);\n\t\tCHECK(IsEqual(tr, tr2));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar> void SetTranslationPart(const VectorT<OtherScalar, DIM>& vec),\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T>\nbool IsEqual(const T& result, const T& expected)\n{\n\treturn result == expected;\n}\nbool IsEqual(const double& result, const double& expected)\n{\n\treturn std::fabs(result - expected) <= 1e-6;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)\n{\n\tfor (int i = 0; i < DIM; i++)\n\t{\n\t\tif (!IsEqual(result[i], expected[i]))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int ROW, int COL>\nbool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)\n{\n\tfor (int i = 0; i < ROW; i++)\n\t{\n\t\tfor (int j = 0; j < COL; j++)\n\t\t{\n\t\t\tif (!IsEqual(result(i, j), expected(i, j)))\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)\n{\n\treturn IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());\n}\nTEST_CASE(\"case1:this is a case for Transformation3\",\"[Common][Transformation3]\")\n{\n\tSECTION(\"SetTranslationPart 2D\") {\n\t\tTransformationT<double, 2> tr;\n\t\ttr.SetRotation(PointT<double, 2>(2.0, 3.0), M_PI_2);\n\t\ttr.SetTranslationPart(VectorT<double, 2>(1.0, 2.0));\n\t\tCoordT<double, 2> p(1.0, 2.0);\n\t\ttr.Transform(p);\n\t\tCoordT<double, 2> p2(-1.0, 3.0);\n\t\tCHECK(IsEqual(p, p2));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, typename OtherScalar2> void SetTranslation(const PointT<OtherScalar, DIM>& p1, const PointT<OtherScalar2, DIM>& p2),\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T>\nbool IsEqual(const T& result, const T& expected)\n{\n\treturn result == expected;\n}\nbool IsEqual(const double& result, const double& expected)\n{\n\treturn std::fabs(result - expected) <= 1e-6;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)\n{\n\tfor (int i = 0; i < DIM; i++)\n\t{\n\t\tif (!IsEqual(result[i], expected[i]))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int ROW, int COL>\nbool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)\n{\n\tfor (int i = 0; i < ROW; i++)\n\t{\n\t\tfor (int j = 0; j < COL; j++)\n\t\t{\n\t\t\tif (!IsEqual(result(i, j), expected(i, j)))\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)\n{\n\treturn IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());\n}\nTEST_CASE(\"case1:this is a case for Transformation3\",\"[Common][Transformation3]\")\n{\n\tSECTION(\"SetTranslation vector 3D\") {\n\t\tTransformationT<double, 3> tr;\n\t\ttr.SetTranslation(VectorT<double, 3>(1.0, 2.0, 3.0));\n\t\tCoordT<double, 3> p(1.0, 2.0, 3.0);\n\t\ttr.Transform(p);\n\t\tCoordT<double, 3> p2(2.0, 4.0, 6.0);\n\t\tCHECK(IsEqual(p, p2));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar> void SetTranslation(const VectorT<OtherScalar, DIM>& vec),\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T>\nbool IsEqual(const T& result, const T& expected)\n{\n\treturn result == expected;\n}\nbool IsEqual(const double& result, const double& expected)\n{\n\treturn std::fabs(result - expected) <= 1e-6;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)\n{\n\tfor (int i = 0; i < DIM; i++)\n\t{\n\t\tif (!IsEqual(result[i], expected[i]))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int ROW, int COL>\nbool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)\n{\n\tfor (int i = 0; i < ROW; i++)\n\t{\n\t\tfor (int j = 0; j < COL; j++)\n\t\t{\n\t\t\tif (!IsEqual(result(i, j), expected(i, j)))\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)\n{\n\treturn IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());\n}\nTEST_CASE(\"case1:this is a case for Transformation3\",\"[Common][Transformation3]\")\n{\n\tSECTION(\"SetRotationPart quaternion\") {\n\t\tTransformationT<double, 3> tr;\n\t\ttr.SetTranslation(VectorT<double, 3>(2.0 / 3.0, 2.0 / 3.0, 4.0 / 3.0));\n\t\tQuaternionT<double> q(std::sqrt(3.0) / 6.0, std::sqrt(3.0) / 6.0, std::sqrt(3.0) / 3.0, std::sqrt(2.0) / 2.0);\n\t\ttr.SetRotationPart(q);\n\t\tCoordT<double, 3> p(-1.0, -1.0, -1.0);\n\t\ttr.Transform(p);\n\t\tCoordT<double, 3> p2(std::sqrt(6.0) / 6.0, -std::sqrt(6.0) / 6.0, 0.0);\n\t\tCHECK(IsEqual(p, p2));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, int DIM2 = DIM, typename = typename std::enable_if_t<DIM2 == 3>> void SetTransformation(const FrameT<OtherScalar, DIM>& frameTo),\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T>\nbool IsEqual(const T& result, const T& expected)\n{\n\treturn result == expected;\n}\nbool IsEqual(const double& result, const double& expected)\n{\n\treturn std::fabs(result - expected) <= 1e-6;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)\n{\n\tfor (int i = 0; i < DIM; i++)\n\t{\n\t\tif (!IsEqual(result[i], expected[i]))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int ROW, int COL>\nbool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)\n{\n\tfor (int i = 0; i < ROW; i++)\n\t{\n\t\tfor (int j = 0; j < COL; j++)\n\t\t{\n\t\t\tif (!IsEqual(result(i, j), expected(i, j)))\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)\n{\n\treturn IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());\n}\nTEST_CASE(\"case1:this is a case for Transformation3\",\"[Common][Transformation3]\")\n{\n\tSECTION(\"SetTransformation 3D\") {\n\t\tFrameT<double, 3> f1(PointT<double, 3>(1.0, 2.0, 3.0), DirectionT<double, 3>(4.0, 5.0, 6.0), DirectionT<double, 3>(-3.0, -5.0, 1.0));\n\t\tTransformationT<double, 3> tr;\n\t\ttr.SetTransformation(f1);\n\t\tCoordT<double, 3> p(4.0, 1.0, 3.0);\n\t\ttr.Transform(p);\n\t\tCoordT<double, 3> p2(-91.0 / (17.0 * std::sqrt(462.0)), 127.0 / (17.0 * std::sqrt(6.0)), 7.0 / std::sqrt(77.0));\n\t\tCHECK(IsEqual(p, p2));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, typename OtherScalar2, int DIM2 = DIM, typename = typename std::enable_if_t<DIM2 == 3>> void SetTransformation(const FrameT<OtherScalar, DIM>& frameFrom, const FrameT<OtherScalar2, DIM>& frameTo),\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T>\nbool IsEqual(const T& result, const T& expected)\n{\n\treturn result == expected;\n}\nbool IsEqual(const double& result, const double& expected)\n{\n\treturn std::fabs(result - expected) <= 1e-6;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)\n{\n\tfor (int i = 0; i < DIM; i++)\n\t{\n\t\tif (!IsEqual(result[i], expected[i]))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int ROW, int COL>\nbool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)\n{\n\tfor (int i = 0; i < ROW; i++)\n\t{\n\t\tfor (int j = 0; j < COL; j++)\n\t\t{\n\t\t\tif (!IsEqual(result(i, j), expected(i, j)))\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)\n{\n\treturn IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());\n}\nTEST_CASE(\"case1:this is a case for Transformation3\",\"[Common][Transformation3]\")\n{\n\tSECTION(\"SetTransformation 3D\") {\t\n\t\tFrameT<double, 3> f1(PointT<double, 3>(1.0, 2.0, 3.0), DirectionT<double, 3>(4.0, 5.0, 6.0), DirectionT<double, 3>(-3.0, -5.0, 1.0));\n\t\tFrameT<double, 3> f2(PointT<double, 3>(3.0, 1.0, -1.0), DirectionT<double, 3>(1.0, 5.0, -3.0), DirectionT<double, 3>(2.0, -2.0, 2.0));\n\t\tTransformationT<double, 3> tr;\n\t\ttr.SetTransformation(f1, f2);\n\t\tCoordT<double, 3> p(4.0, 1.0, 3.0);\n\t\ttr.Transform(p);\n\t\tCoordT<double, 3> p2(54.0 / std::sqrt(770.0) - 232.0 / (34.0 * std::sqrt(1155.0)) + 100.0 / (34.0 * std::sqrt(15.0)) - 2.0 / std::sqrt(10.0),\n\t\t\t-72.0 / (7.0 * std::sqrt(22.0)) - 1744.0 / (238.0 * std::sqrt(33.0)) + 94.0 / (34.0 * std::sqrt(21.0)) - 16.0 / std::sqrt(14.0),\n\t\t\t33.0 / (7.0 * std::sqrt(55.0)) - 8184.0 / (119.0 * std::sqrt(330.0)) - 60.0 / (17.0 * std::sqrt(210.0)) - 9.0 / std::sqrt(35.0));\n\t\tCHECK(IsEqual(p, p2));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, typename OtherScalar2, int DIM2 = DIM, typename = typename std::enable_if_t<DIM2 == 3>> void SetDisplacement(const FrameT<OtherScalar, DIM>& frameFrom, const FrameT<OtherScalar2, DIM>& frameTo),\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T>\nbool IsEqual(const T& result, const T& expected)\n{\n\treturn result == expected;\n}\nbool IsEqual(const double& result, const double& expected)\n{\n\treturn std::fabs(result - expected) <= 1e-6;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)\n{\n\tfor (int i = 0; i < DIM; i++)\n\t{\n\t\tif (!IsEqual(result[i], expected[i]))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int ROW, int COL>\nbool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)\n{\n\tfor (int i = 0; i < ROW; i++)\n\t{\n\t\tfor (int j = 0; j < COL; j++)\n\t\t{\n\t\t\tif (!IsEqual(result(i, j), expected(i, j)))\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)\n{\n\treturn IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());\n}\nTEST_CASE(\"case1:this is a case for Transformation3\",\"[Common][Transformation3]\")\n{\n\tSECTION(\"SetDisplacement\") {\n\t\tFrameT<double, 3> f1(PointT<double, 3>(1.0, 2.0, 3.0), DirectionT<double, 3>(4.0, 5.0, 6.0), DirectionT<double, 3>(-3.0, -5.0, 1.0));\n\t\tFrameT<double, 3> f2(PointT<double, 3>(3.0, 1.0, -1.0), DirectionT<double, 3>(1.0, 5.0, -3.0), DirectionT<double, 3>(2.0, -2.0, 2.0));\n\t\tTransformationT<double, 3> tr;\n\t\ttr.SetDisplacement(f1, f2);\n\t\tCoordT<double, 3> p(4.0, 1.0, 3.0);\n\t\ttr.Transform(p);\n\t\tCoordT<double, 3> p2(7.0 / (7.0 * std::sqrt(55.0)) - 273.0 / (34.0 * std::sqrt(1155.0)) + 127.0 / (34.0 * std::sqrt(21.0)) + 3.0,\n\t\t\t35.0 / (7.0 * std::sqrt(55.0)) - 254.0 / (34.0 * std::sqrt(21.0)) + 1.0,\n\t\t\t-21.0 / (7.0 * std::sqrt(55.0)) - 91.0 / (34.0 * std::sqrt(1155.0)) - 381.0 / (34.0 * std::sqrt(21.0)) - 1.0);\n\t\tCHECK(IsEqual(p, p2));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, typename OtherScalar2> void SetScale(const PointT<OtherScalar, DIM>& point, const OtherScalar2& s),\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T>\nbool IsEqual(const T& result, const T& expected)\n{\n\treturn result == expected;\n}\nbool IsEqual(const double& result, const double& expected)\n{\n\treturn std::fabs(result - expected) <= 1e-6;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)\n{\n\tfor (int i = 0; i < DIM; i++)\n\t{\n\t\tif (!IsEqual(result[i], expected[i]))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int ROW, int COL>\nbool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)\n{\n\tfor (int i = 0; i < ROW; i++)\n\t{\n\t\tfor (int j = 0; j < COL; j++)\n\t\t{\n\t\t\tif (!IsEqual(result(i, j), expected(i, j)))\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)\n{\n\treturn IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());\n}\nTEST_CASE(\"case1:this is a case for Transformation3\",\"[Common][Transformation3]\")\n{\n\tSECTION(\"SetScale 3D\") {\n\t\tTransformationT<double, 3> tr;\n\t\ttr.SetScale(PointT<double, 3>(2.0, 3.0, 4.0), 1.5);\n\t\tCoordT<double, 3> p(1.0, 2.0, 3.0);\n\t\ttr.Transform(p);\n\t\tCoordT<double, 3> p2(0.5, 1.5, 2.5);\n\t\tCHECK(IsEqual(p, p2));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, int DIM2 = DIM, typename = typename std::enable_if_t<DIM2 == 3>> void SetRotationPart(const QuaternionT<OtherScalar>& q),\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T>\nbool IsEqual(const T& result, const T& expected)\n{\n\treturn result == expected;\n}\nbool IsEqual(const double& result, const double& expected)\n{\n\treturn std::fabs(result - expected) <= 1e-6;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)\n{\n\tfor (int i = 0; i < DIM; i++)\n\t{\n\t\tif (!IsEqual(result[i], expected[i]))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int ROW, int COL>\nbool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)\n{\n\tfor (int i = 0; i < ROW; i++)\n\t{\n\t\tfor (int j = 0; j < COL; j++)\n\t\t{\n\t\t\tif (!IsEqual(result(i, j), expected(i, j)))\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)\n{\n\treturn IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());\n}\nTEST_CASE(\"case1:this is a case for Transformation3\",\"[Common][Transformation3]\")\n{\n\tSECTION(\"SetRotationPart quaternion\") {\n\t\tTransformationT<double, 3> tr;\n\t\ttr.SetTranslation(VectorT<double, 3>(2.0 / 3.0, 2.0 / 3.0, 4.0 / 3.0));\n\t\tQuaternionT<double> q(std::sqrt(3.0) / 6.0, std::sqrt(3.0) / 6.0, std::sqrt(3.0) / 3.0, std::sqrt(2.0) / 2.0);\n\t\ttr.SetRotationPart(q);\n\t\tCoordT<double, 3> p(-1.0, -1.0, -1.0);\n\t\ttr.Transform(p);\n\t\tCoordT<double, 3> p2(std::sqrt(6.0) / 6.0, -std::sqrt(6.0) / 6.0, 0.0);\n\t\tCHECK(IsEqual(p, p2));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, int DIM2 = DIM, typename = typename std::enable_if_t<DIM2 == 3>> void SetRotation(const QuaternionT<OtherScalar>& q),\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T>\nbool IsEqual(const T& result, const T& expected)\n{\n\treturn result == expected;\n}\nbool IsEqual(const double& result, const double& expected)\n{\n\treturn std::fabs(result - expected) <= 1e-6;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)\n{\n\tfor (int i = 0; i < DIM; i++)\n\t{\n\t\tif (!IsEqual(result[i], expected[i]))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int ROW, int COL>\nbool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)\n{\n\tfor (int i = 0; i < ROW; i++)\n\t{\n\t\tfor (int j = 0; j < COL; j++)\n\t\t{\n\t\t\tif (!IsEqual(result(i, j), expected(i, j)))\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)\n{\n\treturn IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());\n}\nTEST_CASE(\"case1:this is a case for Transformation3\",\"[Common][Transformation3]\")\n{\n\tSECTION(\"SetRotation quaternion\") {\n\t\tTransformationT<double, 3> tr;\n\t\tQuaternionT<double> q(std::sqrt(3.0) / 6.0, std::sqrt(3.0) / 6.0, std::sqrt(3.0) / 3.0, std::sqrt(2.0) / 2.0);\n\t\ttr.SetRotation(q);\n\t\tCoordT<double, 3> p(-1.0, -1.0, -1.0);\n\t\ttr.Transform(p);\n\t\tCoordT<double, 3> p2((-4.0 + std::sqrt(6.0)) / 6.0, (-4.0 - std::sqrt(6.0)) / 6.0, -4.0 / 3.0);\n\t\tCHECK(IsEqual(p, p2));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, typename OtherScalar2, int DIM2 = DIM, typename = typename std::enable_if_t<DIM2 == 3>> void SetRotation(const AxisT<OtherScalar, DIM>& axis, const OtherScalar2& angle),\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T>\nbool IsEqual(const T& result, const T& expected)\n{\n\treturn result == expected;\n}\nbool IsEqual(const double& result, const double& expected)\n{\n\treturn std::fabs(result - expected) <= 1e-6;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)\n{\n\tfor (int i = 0; i < DIM; i++)\n\t{\n\t\tif (!IsEqual(result[i], expected[i]))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int ROW, int COL>\nbool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)\n{\n\tfor (int i = 0; i < ROW; i++)\n\t{\n\t\tfor (int j = 0; j < COL; j++)\n\t\t{\n\t\t\tif (!IsEqual(result(i, j), expected(i, j)))\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)\n{\n\treturn IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());\n}\nTEST_CASE(\"case1:this is a case for Transformation3\",\"[Common][Transformation3]\")\n{\n\tSECTION(\"SetRotation axis\") {\n\t\tTransformationT<double, 3> tr;\n\t\tAxisT<double, 3> a(PointT<double, 3>(2.0, 3.0, 4.0), DirectionT<double, 3>(1.0, 1.0, 2.0));\n\t\ttr.SetRotation(a, M_PI_2);\n\t\tCoordT<double, 3> p(1.0, 2.0, 3.0);\n\t\ttr.Transform(p);\n\t\tCoordT<double, 3> p2((8.0 + std::sqrt(6.0)) / 6.0, (14.0 - std::sqrt(6.0)) / 6.0, 8.0 / 3.0);\n\t\tCHECK(IsEqual(p, p2));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, typename OtherScalar2, int DIM2 = DIM, typename = typename std::enable_if_t<DIM2 == 2>> void SetRotation(const PointT<OtherScalar, DIM>& point, const OtherScalar2& angle),\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T>\nbool IsEqual(const T& result, const T& expected)\n{\n\treturn result == expected;\n}\nbool IsEqual(const double& result, const double& expected)\n{\n\treturn std::fabs(result - expected) <= 1e-6;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)\n{\n\tfor (int i = 0; i < DIM; i++)\n\t{\n\t\tif (!IsEqual(result[i], expected[i]))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int ROW, int COL>\nbool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)\n{\n\tfor (int i = 0; i < ROW; i++)\n\t{\n\t\tfor (int j = 0; j < COL; j++)\n\t\t{\n\t\t\tif (!IsEqual(result(i, j), expected(i, j)))\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)\n{\n\treturn IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());\n}\nTEST_CASE(\"case1:this is a case for Transformation3\",\"[Common][Transformation3]\")\n{\n\tSECTION(\"SetRotation point\") {\n\t\tTransformationT<double, 2> tr;\n\t\ttr.SetRotation(PointT<double, 2>(2.0, 3.0), M_PI_2);\n\t\tCoordT<double, 2> p(1.0, 2.0);\n\t\ttr.Transform(p);\n\t\tCoordT<double, 2> p2(3.0, 2.0);\n\t\tCHECK(IsEqual(p, p2));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, int DIM2 = DIM, std::enable_if_t<DIM2 == 3, int> = 0> void SetMirror(const FrameT<OtherScalar, DIM>& frame),\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T>\nbool IsEqual(const T& result, const T& expected)\n{\n\treturn result == expected;\n}\nbool IsEqual(const double& result, const double& expected)\n{\n\treturn std::fabs(result - expected) <= 1e-6;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)\n{\n\tfor (int i = 0; i < DIM; i++)\n\t{\n\t\tif (!IsEqual(result[i], expected[i]))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int ROW, int COL>\nbool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)\n{\n\tfor (int i = 0; i < ROW; i++)\n\t{\n\t\tfor (int j = 0; j < COL; j++)\n\t\t{\n\t\t\tif (!IsEqual(result(i, j), expected(i, j)))\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)\n{\n\treturn IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());\n}\nTEST_CASE(\"case1:this is a case for Transformation3\",\"[Common][Transformation3]\")\n{\n\tSECTION(\"SetMirror axis 3D\") {\n\t\tTransformationT<double, 3> tr;\n\t\tAxisT<double, 3> axis(PointT<double, 3>(2.0, 3.0, 4.0), DirectionT<double, 3>(7.0, 3.0, 2.0));\n\t\ttr.SetMirror(axis);\n\t\tCoordT<double, 3> p(1.0, 2.0, 3.0);\n\t\ttr.Transform(p);\n\t\tCoordT<double, 3> p2(9.0 / 31.0, 88.0 / 31.0, 131.0 / 31.0);\n\t\tCHECK(IsEqual(p, p2));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar> void SetMirror(const AxisT<OtherScalar, DIM>& axis),\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T>\nbool IsEqual(const T& result, const T& expected)\n{\n\treturn result == expected;\n}\nbool IsEqual(const double& result, const double& expected)\n{\n\treturn std::fabs(result - expected) <= 1e-6;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)\n{\n\tfor (int i = 0; i < DIM; i++)\n\t{\n\t\tif (!IsEqual(result[i], expected[i]))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int ROW, int COL>\nbool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)\n{\n\tfor (int i = 0; i < ROW; i++)\n\t{\n\t\tfor (int j = 0; j < COL; j++)\n\t\t{\n\t\t\tif (!IsEqual(result(i, j), expected(i, j)))\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)\n{\n\treturn IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());\n}\nTEST_CASE(\"case1:this is a case for Transformation3\",\"[Common][Transformation3]\")\n{\n\tSECTION(\"SetMirror axis 3D\") {\n\t\tTransformationT<double, 3> tr;\n\t\tAxisT<double, 3> axis(PointT<double, 3>(2.0, 3.0, 4.0), DirectionT<double, 3>(7.0, 3.0, 2.0));\n\t\ttr.SetMirror(axis);\n\t\tCoordT<double, 3> p(1.0, 2.0, 3.0);\n\t\ttr.Transform(p);\n\t\tCoordT<double, 3> p2(9.0 / 31.0, 88.0 / 31.0, 131.0 / 31.0);\n\t\tCHECK(IsEqual(p, p2));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar> void SetMirror(const PointT<OtherScalar, DIM>& point),\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T>\nbool IsEqual(const T& result, const T& expected)\n{\n\treturn result == expected;\n}\nbool IsEqual(const double& result, const double& expected)\n{\n\treturn std::fabs(result - expected) <= 1e-6;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)\n{\n\tfor (int i = 0; i < DIM; i++)\n\t{\n\t\tif (!IsEqual(result[i], expected[i]))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int ROW, int COL>\nbool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)\n{\n\tfor (int i = 0; i < ROW; i++)\n\t{\n\t\tfor (int j = 0; j < COL; j++)\n\t\t{\n\t\t\tif (!IsEqual(result(i, j), expected(i, j)))\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)\n{\n\treturn IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());\n}\nTEST_CASE(\"case1:this is a case for Transformation3\",\"[Common][Transformation3]\")\n{\n\tSECTION(\"SetMirror point 3D\") {\n\t\tTransformationT<double, 3> tr;\n\t\tPointT<double, 3> p(1.0, 2.0, 3.0);\n\t\ttr.SetMirror(p);\n\t\tCoordT<double, 3> p2(0.0, 1.0, 2.0);\n\t\ttr.Transform(p2);\n\t\tCoordT<double, 3> p3(2.0, 3.0, 4.0);\n\t\tCHECK(IsEqual(p2, p3));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, int OtherDIM> explicit TransformationT(const TransformationT<OtherScalar, OtherDIM>& trans),\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T>\nbool IsEqual(const T& result, const T& expected)\n{\n\treturn result == expected;\n}\nbool IsEqual(const double& result, const double& expected)\n{\n\treturn std::fabs(result - expected) <= 1e-6;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)\n{\n\tfor (int i = 0; i < DIM; i++)\n\t{\n\t\tif (!IsEqual(result[i], expected[i]))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int ROW, int COL>\nbool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)\n{\n\tfor (int i = 0; i < ROW; i++)\n\t{\n\t\tfor (int j = 0; j < COL; j++)\n\t\t{\n\t\t\tif (!IsEqual(result(i, j), expected(i, j)))\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)\n{\n\treturn IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());\n}\nTEST_CASE(\"case1:this is a case for Transformation3\",\"[Common][Transformation3]\")\n{\n\tSECTION(\"default constructor 3D\") {\n\t\tTransformationT<double, 3> tr;\n\t\tMatrixT<double, 3, 3> mat;\n\t\tmat.SetIdentity();\n\t\tCoordT<double, 3> c;\n\t\tdouble scale = 1.0;\n\t\tCHECK(IsEqual(tr.ScaleFactor(), scale));\n\t\tCHECK(IsEqual(tr.Type(), TransformationType::Identity));\n\t\tCHECK(IsEqual(tr.HVectorialPart(), mat));\n\t\tCHECK(IsEqual(tr.TranslationPart(), c));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "constexpr TransformationT()\t @details The default transformation is the identity transformation\n\t @brief Default constructor\n,\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T>\nbool IsEqual(const T& result, const T& expected)\n{\n\treturn result == expected;\n}\nbool IsEqual(const double& result, const double& expected)\n{\n\treturn std::fabs(result - expected) <= 1e-6;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)\n{\n\tfor (int i = 0; i < DIM; i++)\n\t{\n\t\tif (!IsEqual(result[i], expected[i]))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int ROW, int COL>\nbool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)\n{\n\tfor (int i = 0; i < ROW; i++)\n\t{\n\t\tfor (int j = 0; j < COL; j++)\n\t\t{\n\t\t\tif (!IsEqual(result(i, j), expected(i, j)))\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)\n{\n\treturn IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());\n}\nTEST_CASE(\"case1:this is a case for Transformation3\",\"[Common][Transformation3]\")\n{\n\tSECTION(\"default constructor 3D\") {\n\t\tTransformationT<double, 3> tr;\n\t\tMatrixT<double, 3, 3> mat;\n\t\tmat.SetIdentity();\n\t\tCoordT<double, 3> c;\n\t\tdouble scale = 1.0;\n\t\tCHECK(IsEqual(tr.ScaleFactor(), scale));\n\t\tCHECK(IsEqual(tr.Type(), TransformationType::Identity));\n\t\tCHECK(IsEqual(tr.HVectorialPart(), mat));\n\t\tCHECK(IsEqual(tr.TranslationPart(), c));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] const CoordT<Scalar, DIM>& TranslationPart()\t @return The translation part\n\t @brief Get the translation part of the transformation\n,\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T>\nbool IsEqual(const T& result, const T& expected)\n{\n\treturn result == expected;\n}\nbool IsEqual(const double& result, const double& expected)\n{\n\treturn std::fabs(result - expected) <= 1e-6;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)\n{\n\tfor (int i = 0; i < DIM; i++)\n\t{\n\t\tif (!IsEqual(result[i], expected[i]))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int ROW, int COL>\nbool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)\n{\n\tfor (int i = 0; i < ROW; i++)\n\t{\n\t\tfor (int j = 0; j < COL; j++)\n\t\t{\n\t\t\tif (!IsEqual(result(i, j), expected(i, j)))\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)\n{\n\treturn IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());\n}\nTEST_CASE(\"case1:this is a case for Transformation3\",\"[Common][Transformation3]\")\n{\n\tSECTION(\"default constructor 3D\") {\n\t\tTransformationT<double, 3> tr;\n\t\tMatrixT<double, 3, 3> mat;\n\t\tmat.SetIdentity();\n\t\tCoordT<double, 3> c;\n\t\tdouble scale = 1.0;\n\t\tCHECK(IsEqual(tr.ScaleFactor(), scale));\n\t\tCHECK(IsEqual(tr.Type(), TransformationType::Identity));\n\t\tCHECK(IsEqual(tr.HVectorialPart(), mat));\n\t\tCHECK(IsEqual(tr.TranslationPart(), c));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] TransformationType Type()\t @return The transformation type\n\t @brief Get the type of the transformation\n,\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T>\nbool IsEqual(const T& result, const T& expected)\n{\n\treturn result == expected;\n}\nbool IsEqual(const double& result, const double& expected)\n{\n\treturn std::fabs(result - expected) <= 1e-6;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)\n{\n\tfor (int i = 0; i < DIM; i++)\n\t{\n\t\tif (!IsEqual(result[i], expected[i]))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int ROW, int COL>\nbool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)\n{\n\tfor (int i = 0; i < ROW; i++)\n\t{\n\t\tfor (int j = 0; j < COL; j++)\n\t\t{\n\t\t\tif (!IsEqual(result(i, j), expected(i, j)))\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)\n{\n\treturn IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());\n}\nTEST_CASE(\"case1:this is a case for Transformation3\",\"[Common][Transformation3]\")\n{\n\tSECTION(\"default constructor 3D\") {\n\t\tTransformationT<double, 3> tr;\n\t\tMatrixT<double, 3, 3> mat;\n\t\tmat.SetIdentity();\n\t\tCoordT<double, 3> c;\n\t\tdouble scale = 1.0;\n\t\tCHECK(IsEqual(tr.ScaleFactor(), scale));\n\t\tCHECK(IsEqual(tr.Type(), TransformationType::Identity));\n\t\tCHECK(IsEqual(tr.HVectorialPart(), mat));\n\t\tCHECK(IsEqual(tr.TranslationPart(), c));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] Scalar ScaleFactor()\t @return The scale factor\n\t @brief Get the scale factor of the transformation\n,\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T>\nstatic bool IsEqual(const T& result, const T& expected)\n{\n\treturn result == expected;\n}\nstatic bool IsEqual(const double& result, const double& expected)\n{\n\treturn std::fabs(result - expected) <= 1e-15;\n}\ntemplate<typename T, int DIM>\nstatic bool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)\n{\n\tfor (int i = 0; i < DIM; i++)\n\t{\n\t\tif (!IsEqual(result[i], expected[i]))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int ROW, int COL>\nstatic bool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)\n{\n\tfor (int i = 0; i < ROW; i++)\n\t{\n\t\tfor (int j = 0; j < COL; j++)\n\t\t{\n\t\t\tif (!IsEqual(result(i, j), expected(i, j)))\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)\n{\n\treturn IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());\n}\nTEST_CASE(\"case1:this is a case for Transformation2\", \"[Common][Transformation2]\") {\n\tSECTION(\"default constructor 2D\") {\n\t\tTransformationT<double, 2> tr;\n\t\tMatrixT<double, 2, 2> mat;\n\t\tmat.SetIdentity();\n\t\tCoordT<double, 2> c;\n\t\tdouble scale = 1.0;\n\t\tCHECK(IsEqual(tr.ScaleFactor(), scale));\n\t\tCHECK(IsEqual(tr.Type(), TransformationType::Identity));\n\t\tCHECK(IsEqual(tr.HVectorialPart(), mat));\n\t\tCHECK(IsEqual(tr.TranslationPart(), c));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, int DIM2 = DIM, typename = typename std::enable_if_t<DIM2 == 2>> void SetTransformation(const AxisT<OtherScalar, DIM>& axisTo),\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T>\nstatic bool IsEqual(const T& result, const T& expected)\n{\n\treturn result == expected;\n}\nstatic bool IsEqual(const double& result, const double& expected)\n{\n\treturn std::fabs(result - expected) <= 1e-15;\n}\ntemplate<typename T, int DIM>\nstatic bool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)\n{\n\tfor (int i = 0; i < DIM; i++)\n\t{\n\t\tif (!IsEqual(result[i], expected[i]))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int ROW, int COL>\nstatic bool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)\n{\n\tfor (int i = 0; i < ROW; i++)\n\t{\n\t\tfor (int j = 0; j < COL; j++)\n\t\t{\n\t\t\tif (!IsEqual(result(i, j), expected(i, j)))\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)\n{\n\treturn IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());\n}\nTEST_CASE(\"case1:this is a case for Transformation2\", \"[Common][Transformation2]\") {\n\tSECTION(\"SetTransformation 2D\") {\n\t\tAxis2 a1(PointT<double, 2>(1.0, 2.0), DirectionT<double, 2>(3.0, 4.0));\n\t\tTransformationT<double, 2> tr;\n\t\ttr.SetTransformation(a1);\n\t\tCoordT<double, 2> p(4.0, 1.0);\n\t\ttr.Transform(p);\n\t\tCoordT<double, 2> p2(1.0, -3.0);\n\t\tCHECK(IsEqual(p, p2));\n\t}\n}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, typename OtherScalar2, int DIM2 = DIM, typename = typename std::enable_if_t<DIM2 == 2>> void SetTransformation(const AxisT<OtherScalar, DIM>& axisFrom, const AxisT<OtherScalar2, DIM>& axisTo),\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T>\nstatic bool IsEqual(const T& result, const T& expected)\n{\n\treturn result == expected;\n}\nstatic bool IsEqual(const double& result, const double& expected)\n{\n\treturn std::fabs(result - expected) <= 1e-15;\n}\ntemplate<typename T, int DIM>\nstatic bool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)\n{\n\tfor (int i = 0; i < DIM; i++)\n\t{\n\t\tif (!IsEqual(result[i], expected[i]))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int ROW, int COL>\nstatic bool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)\n{\n\tfor (int i = 0; i < ROW; i++)\n\t{\n\t\tfor (int j = 0; j < COL; j++)\n\t\t{\n\t\t\tif (!IsEqual(result(i, j), expected(i, j)))\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)\n{\n\treturn IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());\n}\nTEST_CASE(\"case1:this is a case for Transformation2\", \"[Common][Transformation2]\") {\n\tSECTION(\"SetTransformation 2D\") {\n\t\tAxis2 a1(PointT<double, 2>(1.0, 2.0), DirectionT<double, 2>(3.0, 4.0));\n\t\tAxis2 a2(PointT<double, 2>(3.0, 1.0), DirectionT<double, 2>(1.0, 5.0));\n\t\tTransformationT<double, 2> tr;\n\t\ttr.SetTransformation(a1, a2);\n\t\tCoordT<double, 2> p(4.0, 1.0);\n\t\ttr.Transform(p);\n\t\tCoordT<double, 2> p2(118.0 / (5.0 * std::sqrt(26.0)), 34.0 / (5.0 * std::sqrt(26.0)));\n\t\tCHECK(IsEqual(p, p2));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, typename OtherScalar2> void SetScale(const PointT<OtherScalar, DIM>& point, const OtherScalar2& s),\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T>\nstatic bool IsEqual(const T& result, const T& expected)\n{\n\treturn result == expected;\n}\nstatic bool IsEqual(const double& result, const double& expected)\n{\n\treturn std::fabs(result - expected) <= 1e-15;\n}\ntemplate<typename T, int DIM>\nstatic bool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)\n{\n\tfor (int i = 0; i < DIM; i++)\n\t{\n\t\tif (!IsEqual(result[i], expected[i]))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int ROW, int COL>\nstatic bool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)\n{\n\tfor (int i = 0; i < ROW; i++)\n\t{\n\t\tfor (int j = 0; j < COL; j++)\n\t\t{\n\t\t\tif (!IsEqual(result(i, j), expected(i, j)))\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)\n{\n\treturn IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());\n}\nTEST_CASE(\"case1:this is a case for Transformation2\", \"[Common][Transformation2]\") {\n\tSECTION(\"SetScale 2D\") {\n\t\tTransformationT<double, 2> tr;\n\t\ttr.SetScale(PointT<double, 2>(2.0, 3.0), 1.5);\n\t\tCoordT<double, 2> p(1.0, 2.0);\n\t\ttr.Transform(p);\n\t\tCoordT<double, 2> p2(0.5, 1.5);\n\t\tCHECK(IsEqual(p, p2));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar> void SetMirror(const AxisT<OtherScalar, DIM>& axis),\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T>\nstatic bool IsEqual(const T& result, const T& expected)\n{\n\treturn result == expected;\n}\nstatic bool IsEqual(const double& result, const double& expected)\n{\n\treturn std::fabs(result - expected) <= 1e-15;\n}\ntemplate<typename T, int DIM>\nstatic bool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)\n{\n\tfor (int i = 0; i < DIM; i++)\n\t{\n\t\tif (!IsEqual(result[i], expected[i]))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int ROW, int COL>\nstatic bool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)\n{\n\tfor (int i = 0; i < ROW; i++)\n\t{\n\t\tfor (int j = 0; j < COL; j++)\n\t\t{\n\t\t\tif (!IsEqual(result(i, j), expected(i, j)))\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)\n{\n\treturn IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());\n}\nTEST_CASE(\"case1:this is a case for Transformation2\", \"[Common][Transformation2]\") {\n\tSECTION(\"SetMirror axis 2D\") {\n\t\tTransformationT<double, 2> tr;\n\t\tAxisT<double, 2> axis(PointT<double, 2>(2.0, 3.0), DirectionT<double, 2>(7.0, 3.0));\n\t\ttr.SetMirror(axis);\n\t\tCoordT<double, 2> p(1.0, 2.0);\n\t\ttr.Transform(p);\n\t\tCoordT<double, 2> p2(17.0 / 29.0, 86.0 / 29.0);\n\t\tCHECK(IsEqual(p, p2));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar> void SetMirror(const PointT<OtherScalar, DIM>& point),\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T>\nstatic bool IsEqual(const T& result, const T& expected)\n{\n\treturn result == expected;\n}\nstatic bool IsEqual(const double& result, const double& expected)\n{\n\treturn std::fabs(result - expected) <= 1e-15;\n}\ntemplate<typename T, int DIM>\nstatic bool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)\n{\n\tfor (int i = 0; i < DIM; i++)\n\t{\n\t\tif (!IsEqual(result[i], expected[i]))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int ROW, int COL>\nstatic bool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)\n{\n\tfor (int i = 0; i < ROW; i++)\n\t{\n\t\tfor (int j = 0; j < COL; j++)\n\t\t{\n\t\t\tif (!IsEqual(result(i, j), expected(i, j)))\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)\n{\n\treturn IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());\n}\nTEST_CASE(\"case1:this is a case for Transformation2\", \"[Common][Transformation2]\") {\n\tSECTION(\"SetMirror point 2D\") {\n\t\tTransformationT<double, 2> tr;\n\t\tPointT<double, 2> p(2.0, 4.0);\n\t\ttr.SetMirror(p);\n\t\tCoordT<double, 2> p2(1.0, 2.0);\n\t\ttr.Transform(p2);\n\t\tCoordT<double, 2> p3(3.0, 6.0);\n\t\tCHECK(IsEqual(p2, p3));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] const CoordT<Scalar, DIM>& TranslationPart()\t @return The translation part\n\t @brief Get the translation part of the transformation\n,\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T>\nstatic bool IsEqual(const T& result, const T& expected)\n{\n\treturn result == expected;\n}\nstatic bool IsEqual(const double& result, const double& expected)\n{\n\treturn std::fabs(result - expected) <= 1e-15;\n}\ntemplate<typename T, int DIM>\nstatic bool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)\n{\n\tfor (int i = 0; i < DIM; i++)\n\t{\n\t\tif (!IsEqual(result[i], expected[i]))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int ROW, int COL>\nstatic bool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)\n{\n\tfor (int i = 0; i < ROW; i++)\n\t{\n\t\tfor (int j = 0; j < COL; j++)\n\t\t{\n\t\t\tif (!IsEqual(result(i, j), expected(i, j)))\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)\n{\n\treturn IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());\n}\nTEST_CASE(\"case1:this is a case for Transformation2\", \"[Common][Transformation2]\") {\n\tSECTION(\"default constructor 2D\") {\n\t\tTransformationT<double, 2> tr;\n\t\tMatrixT<double, 2, 2> mat;\n\t\tmat.SetIdentity();\n\t\tCoordT<double, 2> c;\n\t\tdouble scale = 1.0;\n\t\tCHECK(IsEqual(tr.ScaleFactor(), scale));\n\t\tCHECK(IsEqual(tr.Type(), TransformationType::Identity));\n\t\tCHECK(IsEqual(tr.HVectorialPart(), mat));\n\t\tCHECK(IsEqual(tr.TranslationPart(), c));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar> [[nodiscard]] VectorT Scaled(const OtherScalar& scale),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Vector3\", \"[Common][Vector3]\"){\n\tSECTION(\"Scale\") {\n        VectorT<double, 3> p1(1.0, 2.0, 3.0);\n        VectorT<double, 3> p3(1.5, 3.0, 4.5);\n        CHECK(p1.Scaled(1.5).IsEqual(p3, tolDis, tolAng));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, typename OtherScalar2, int DIM2 = DIM, typename = typename std::enable_if_t<DIM2 == 3>> [[nodiscard]] VectorT Rotated(const AxisT<OtherScalar, DIM>& axis, const OtherScalar2& angle),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Vector3\", \"[Common][Vector3]\"){\n\tSECTION(\"Rotate 3D\") {\n        VectorT<double, 3> p1(1.0, 2.0, 3.0);\n        PointT<double, 3> p2(2.0, 3.0, 4.0);\n        DirectionT<double, 3> d(1.0, 1.0, 2.0);\n        AxisT<double, 3> a(p2, d);\n        VectorT<double, 3> p3((9.0 - std::sqrt(6.0)) / 6.0, (9.0 - std::sqrt(6.0)) / 6.0, 3.0 + 1.0 / std::sqrt(6.0));\n        CHECK(p1.Rotated(a, M_PI_2).IsEqual(p3, tolDis, tolAng));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, typename OtherScalar2, int DIM2 = DIM, typename = typename std::enable_if_t<DIM2 == 3>> VectorT& Rotate(const AxisT<OtherScalar, DIM>& axis, const OtherScalar2& angle),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Vector3\", \"[Common][Vector3]\"){\n\tSECTION(\"Rotate 3D\") {\n        VectorT<double, 3> p1(1.0, 2.0, 3.0);\n        PointT<double, 3> p2(2.0, 3.0, 4.0);\n        DirectionT<double, 3> d(1.0, 1.0, 2.0);\n        AxisT<double, 3> a(p2, d);\n        VectorT<double, 3> p3((9.0 - std::sqrt(6.0)) / 6.0, (9.0 - std::sqrt(6.0)) / 6.0, 3.0 + 1.0 / std::sqrt(6.0));\n        CHECK(p1.Rotated(a, M_PI_2).IsEqual(p3, tolDis, tolAng));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, int DIM2 = DIM, std::enable_if_t<DIM2 == 3, int> = 0> [[nodiscard]] VectorT Mirrored(const FrameT<OtherScalar, DIM>& frame),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Vector3\", \"[Common][Vector3]\"){\n\tSECTION(\"Mirror(point) 3D\") {\n        VectorT<double, 3> p1(1.0, 2.0, 3.0);\n        VectorT<double, 3> p2(2.0, 4.0, 5.0);\n        VectorT<double, 3> p3(11.0 / 9.0, 22.0 / 9.0, 23.0 / 9.0);\n        CHECK(p1.Mirrored(p2).IsEqual(p3, tolDis, tolAng));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar> [[nodiscard]] VectorT Mirrored(const AxisT<OtherScalar, DIM>& axis),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Vector3\", \"[Common][Vector3]\"){\n\tSECTION(\"Mirror(axis) 3D\") {\n        VectorT<double, 3> p1(1.0, 2.0, 3.0);\n        PointT<double, 3> p2(2.0, 3.0, 4.0);\n        DirectionT<double, 3> d(7.0, 3.0, 2.0);\n        AxisT<double, 3> a(p2, d);\n        VectorT<double, 3> p3(102.0 / 31.0, -5.0 / 31.0, -55.0 / 31.0);\n        CHECK(p1.Mirrored(a).IsEqual(p3, tolDis, tolAng));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar> [[nodiscard]] VectorT Mirrored(const VectorT<OtherScalar, DIM>& p),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Vector3\", \"[Common][Vector3]\"){\n\tSECTION(\"Mirror(axis) 3D\") {\n        VectorT<double, 3> p1(1.0, 2.0, 3.0);\n        PointT<double, 3> p2(2.0, 3.0, 4.0);\n        DirectionT<double, 3> d(7.0, 3.0, 2.0);\n        AxisT<double, 3> a(p2, d);\n        VectorT<double, 3> p3(102.0 / 31.0, -5.0 / 31.0, -55.0 / 31.0);\n        CHECK(p1.Mirrored(a).IsEqual(p3, tolDis, tolAng));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, int DIM2 = DIM, std::enable_if_t<DIM2 == 3, int> = 0> VectorT& Mirror(const FrameT<OtherScalar, DIM>& frame),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Vector3\", \"[Common][Vector3]\"){\n\tSECTION(\"Mirror(frame) 3D\") {\n        VectorT<double, 3> p1(1.0, 2.0, 3.0);\n        PointT<double, 3> p2(2.0, 3.0, 4.0);\n        DirectionT<double, 3> d(7.0, 3.0, 2.0);\n        FrameT<double, 3> f(p2, d);\n        VectorT<double, 3> p3(-102.0 / 31.0, 5.0 / 31.0, 55.0 / 31.0);\n        CHECK(p1.Mirror(f).IsEqual(p3, tolDis, tolAng));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar> VectorT& Mirror(const AxisT<OtherScalar, DIM>& axis),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Vector3\", \"[Common][Vector3]\"){\n\tSECTION(\"Mirror(axis) 3D\") {\n        VectorT<double, 3> p1(1.0, 2.0, 3.0);\n        PointT<double, 3> p2(2.0, 3.0, 4.0);\n        DirectionT<double, 3> d(7.0, 3.0, 2.0);\n        AxisT<double, 3> a(p2, d);\n        VectorT<double, 3> p3(102.0 / 31.0, -5.0 / 31.0, -55.0 / 31.0);\n        CHECK(p1.Mirrored(a).IsEqual(p3, tolDis, tolAng));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar> VectorT& Mirror(const VectorT<OtherScalar, DIM>& p),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Vector3\", \"[Common][Vector3]\"){\n\tSECTION(\"Mirror(axis) 3D\") {\n        VectorT<double, 3> p1(1.0, 2.0, 3.0);\n        PointT<double, 3> p2(2.0, 3.0, 4.0);\n        DirectionT<double, 3> d(7.0, 3.0, 2.0);\n        AxisT<double, 3> a(p2, d);\n        VectorT<double, 3> p3(102.0 / 31.0, -5.0 / 31.0, -55.0 / 31.0);\n        CHECK(p1.Mirrored(a).IsEqual(p3, tolDis, tolAng));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] VectorT Normalized()\t @return The normalized vector\n\t @brief Get the normalized vector\n,\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Vector3\", \"[Common][Vector3]\"){\n\tSECTION(\"Normalize\") {\n        VectorT<double, 3> v1(1.0, 2.0, 2.0);\n        VectorT<double, 3> v2(1.0 / 3.0, 2.0 / 3.0, 2.0 / 3.0);\n        CHECK(v1.Normalized().IsEqual(v2, tolDis, tolAng));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar> [[nodiscard]] auto Cross(const VectorT<OtherScalar, DIM>& other),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Vector3\", \"[Common][Vector3]\"){\n\tSECTION(\"Cross 3D\") {\n        VectorT<double, 3> v1(1.0, 2.0, 3.0);\n        VectorT<double, 3> v2(2.0, 3.0, 4.0);\n        VectorT<double, 3> v3(-1.0, 2.0, -1.0);\n        CHECK(v1.Cross(v2).IsEqual(v3, tolDis, tolAng));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] double SquaredNorm()\t @return The squared norm of vector\n\t @brief Get the squared norm of vector\n,\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Vector3\", \"[Common][Vector3]\"){\n\tSECTION(\"SquaredNorm\") {\n        VectorT<double, 3> v1(1.0, 2.0, 3.0);\n        CHECK(v1.SquaredNorm() == Approx(14.0));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, typename OtherScalar2, int DIM2 = DIM, typename = typename std::enable_if_t<DIM2 == 3>> [[nodiscard]] Scalar AngleWithRef(const VectorT<OtherScalar, DIM>& other, const VectorT<OtherScalar2, DIM>& ref),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Vector3\", \"[Common][Vector3]\"){\n\tSECTION(\"AngleWithRef\") {\n        VectorT<double, 3> v1(1.0, 2.0, 3.0);\n        VectorT<double, 3> v2(-3.0, 2.0, -1.0);\n        VectorT<double, 3> v3(1.0, 1.0, 1.0);\n        CHECK(v1.AngleWithRef(v2, v3) == -acos(-1.0 / 7.0));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, int DIM2 = DIM, std::enable_if_t<DIM2 == 3, int> = 0> [[nodiscard]] auto Angle(const VectorT<OtherScalar, DIM>& other),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Vector3\", \"[Common][Vector3]\"){\n\tSECTION(\"Angle 3D\") {\n        VectorT<double, 3> v1(1.0, 2.0, 3.0);\n        VectorT<double, 3> v2(-3.0, 2.0, -1.0);\n        CHECK(v1.Angle(v2) == acos(-1.0 / 7.0));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, int DIM2 = DIM, std::enable_if_t<DIM2 == 2, int> = 0> [[nodiscard]] auto Angle(const VectorT<OtherScalar, DIM>& other),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Vector3\", \"[Common][Vector3]\"){\n\tSECTION(\"Angle 3D\") {\n        VectorT<double, 3> v1(1.0, 2.0, 3.0);\n        VectorT<double, 3> v2(-3.0, 2.0, -1.0);\n        CHECK(v1.Angle(v2) == acos(-1.0 / 7.0));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, typename OtherScalar2> [[nodiscard]] bool IsParallel(const VectorT<OtherScalar, DIM>& other, const OtherScalar2& tol),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Vector3\", \"[Common][Vector3]\"){\n\tSECTION(\"IsParallel\") {\n        VectorT<double, 3> v1(1.0, 2.0, 3.0);\n        VectorT<double, 3> v2(-1.0, -2.0, -3.01);\n        CHECK(v1.IsParallel(v2, tolDis) == false);\n        CHECK(v1.IsParallel(v2, 0.1) == true);\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, typename OtherScalar2> [[nodiscard]] bool IsOpposite(const VectorT<OtherScalar, DIM>& other, const OtherScalar2& tol),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Vector3\", \"[Common][Vector3]\"){\n\tSECTION(\"IsOpposite\") {\n        VectorT<double, 3> v1(1.0, 2.0, 3.0);\n        VectorT<double, 3> v2(-1.0, -2.0, -3.01);\n        CHECK(v1.IsOpposite(v2, tolDis) == false);\n        CHECK(v1.IsOpposite(v2, 0.1) == true);\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, typename OtherScalar2> [[nodiscard]] bool IsNormal(const VectorT<OtherScalar, DIM>& other, const OtherScalar2& tol),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Vector3\", \"[Common][Vector3]\"){\n\tSECTION(\"IsNormal\") {\n        VectorT<double, 3> v1(1.0, 2.0, 3.0);\n        VectorT<double, 3> v2(-4.0, -1.0, 2.01);\n        CHECK(v1.IsNormal(v2, 0.001) == false);\n        CHECK(v1.IsNormal(v2, 0.1) == true);\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, typename OtherScalar2, typename OtherScalar3> [[nodiscard]] bool IsEqual(const VectorT<OtherScalar, DIM>& other, const OtherScalar2& tolDis, const OtherScalar3& tolAng),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Vector3\", \"[Common][Vector3]\"){\n\tSECTION(\"IsEqual\") {\n        VectorT<double, 3> v1(1.0, 2.0, 3.0);\n        VectorT<double, 3> v2(1.01, 2.0, 3.0);\n        CHECK(v1.IsEqual(v2, tolDis, tolAng) == false);\n        CHECK(v1.IsEqual(v2, 0.1, tolAng) == true);\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar> void SetCoord(const CoordT<OtherScalar, DIM>& v),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Vector3\", \"[Common][Vector3]\"){\n\tSECTION(\"SetCoord(x, y, z)\") {\n        VectorT<double, 3> result;\n        result.SetCoord(1.0, 2.0, 3.0);\n        VectorT<double, 3> expected(1.0, 2.0, 3.0);\n        CHECK(result.IsEqual(expected, tolDis, tolAng));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename... T> void SetCoord(T... vs),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Vector3\", \"[Common][Vector3]\"){\n\tSECTION(\"SetCoord(x, y, z)\") {\n        VectorT<double, 3> result;\n        result.SetCoord(1.0, 2.0, 3.0);\n        VectorT<double, 3> expected(1.0, 2.0, 3.0);\n        CHECK(result.IsEqual(expected, tolDis, tolAng));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, typename OtherScalar2> VectorT(const PointT<OtherScalar, DIM>& p1, const PointT<OtherScalar2, DIM>& p2),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Vector3\", \"[Common][Vector3]\"){\n\tSECTION(\"Constructor from two points\") {\n        PointT<double, 3> p1(1.0, 2.0, 3.0);\n        PointT<double, 3> p2(2.0, 3.0, 4.0);\n        VectorT<double, 3> result(p1, p2);\n        VectorT<double, 3> expected(1.0, 1.0, 1.0);\n        CHECK(result.IsEqual(expected, tolDis, tolAng));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename... T> explicit VectorT(T... vs),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Vector3\", \"[Common][Vector3]\"){\n\tSECTION(\"Default constructor\") {\n        VectorT<double, 3> p1;\n        VectorT<double, 3> p2(0.0, 0.0, 0.0);\n        CHECK(p1.IsEqual(p2, tolDis, tolAng));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar> explicit VectorT(const CoordT<OtherScalar, DIM>& v),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Vector3\", \"[Common][Vector3]\"){\n\tSECTION(\"Constructor from direction\") {\n        DirectionT<double, 3> v(1.0, 2.0, 3.0);\n        VectorT<double, 3> result(v);\n        VectorT<double, 3> expected(1.0 / sqrt(14.0), 2.0 / sqrt(14.0), 3.0 / sqrt(14.0));\n        CHECK(result.IsEqual(expected, tolDis, tolAng));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar> explicit VectorT(const DirectionT<OtherScalar, DIM>& dir),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Vector3\", \"[Common][Vector3]\"){\n\tSECTION(\"Constructor from direction\") {\n        DirectionT<double, 3> v(1.0, 2.0, 3.0);\n        VectorT<double, 3> result(v);\n        VectorT<double, 3> expected(1.0 / sqrt(14.0), 2.0 / sqrt(14.0), 3.0 / sqrt(14.0));\n        CHECK(result.IsEqual(expected, tolDis, tolAng));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] auto Norm()\t @return The norm of vector\n\t @brief Get the norm of vector\n,\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Vector3\", \"[Common][Vector3]\"){\n\tSECTION(\"Norm\") {\n        VectorT<double, 3> v1(1.0, 2.0, 3.0);\n        CHECK(v1.Norm() == sqrt(14.0));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, int DIM2 = DIM, typename = typename std::enable_if_t<DIM2 == 2>> [[nodiscard]] VectorT Rotated(const OtherScalar& angle),\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Vector2\", \"[Common][Vector2]\"){\n\tSECTION(\"Rotate 2D\") {\n        VectorT<double, 2> p1(1.0, 2.0);\n        VectorT<double, 2> p3(-2.0, 1.0);\n        CHECK(p1.Rotated(M_PI_2).IsEqual(p3, tolDis, tolAng));\n    }\n}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, int DIM2 = DIM, typename = typename std::enable_if_t<DIM2 == 2>> VectorT& Rotate(const OtherScalar& angle),\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Vector2\", \"[Common][Vector2]\"){\n\tSECTION(\"Rotate 2D\") {\n        VectorT<double, 2> p1(1.0, 2.0);\n        VectorT<double, 2> p3(-2.0, 1.0);\n        CHECK(p1.Rotated(M_PI_2).IsEqual(p3, tolDis, tolAng));\n    }\n}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar> [[nodiscard]] VectorT Mirrored(const AxisT<OtherScalar, DIM>& axis),\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Vector2\", \"[Common][Vector2]\"){\n\tSECTION(\"Mirror(axis) 2D\") {\n        VectorT<double, 2> p1(1.0, 2.0);\n        PointT<double, 2> p2(2.0, 3.0);\n        DirectionT<double, 2> d(7.0, 3.0);\n        AxisT<double, 2> a(p2, d);\n        VectorT<double, 2> p3(62.0 / 29.0, -19.0 / 29.0);\n        CHECK(p1.Mirrored(a).IsEqual(p3, tolDis, tolAng));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar> VectorT& Mirror(const AxisT<OtherScalar, DIM>& axis),\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Vector2\", \"[Common][Vector2]\"){\n\tSECTION(\"Mirror(axis) 2D\") {\n        VectorT<double, 2> p1(1.0, 2.0);\n        PointT<double, 2> p2(2.0, 3.0);\n        DirectionT<double, 2> d(7.0, 3.0);\n        AxisT<double, 2> a(p2, d);\n        VectorT<double, 2> p3(62.0 / 29.0, -19.0 / 29.0);\n        CHECK(p1.Mirrored(a).IsEqual(p3, tolDis, tolAng));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar> VectorT& Mirror(const VectorT<OtherScalar, DIM>& p),\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Vector2\", \"[Common][Vector2]\"){\n\tSECTION(\"Mirror(axis) 2D\") {\n        VectorT<double, 2> p1(1.0, 2.0);\n        PointT<double, 2> p2(2.0, 3.0);\n        DirectionT<double, 2> d(7.0, 3.0);\n        AxisT<double, 2> a(p2, d);\n        VectorT<double, 2> p3(62.0 / 29.0, -19.0 / 29.0);\n        CHECK(p1.Mirrored(a).IsEqual(p3, tolDis, tolAng));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar> [[nodiscard]] auto Cross(const VectorT<OtherScalar, DIM>& other),\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Vector2\", \"[Common][Vector2]\"){\n\tSECTION(\"Cross 2D\") {\n        VectorT<double, 2> v1(1.0, 2.0);\n        VectorT<double, 2> v2(2.0, 3.0);\n        CHECK(v1.Cross(v2) == -1.0);\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, int DIM2 = DIM, std::enable_if_t<DIM2 == 2, int> = 0> [[nodiscard]] auto Angle(const VectorT<OtherScalar, DIM>& other),\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Vector2\", \"[Common][Vector2]\"){\n\tSECTION(\"Angle 2D\") {\n        VectorT<double, 2> v1(1.0, 3.0);\n        VectorT<double, 2> v2(-1.0, 2.0);\n        CHECK(v1.Angle(v2) == Approx(acos(M_SQRT1_2)));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, typename OtherScalar2> VectorT(const PointT<OtherScalar, DIM>& p1, const PointT<OtherScalar2, DIM>& p2),\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Vector2\", \"[Common][Vector2]\"){\n\tSECTION(\"Angle 2D\") {\n        VectorT<double, 2> v1(1.0, 3.0);\n        VectorT<double, 2> v2(-1.0, 2.0);\n        CHECK(v1.Angle(v2) == Approx(acos(M_SQRT1_2)));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename... T> explicit VectorT(T... vs),\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Vector2\", \"[Common][Vector2]\"){\n\tSECTION(\"Angle 2D\") {\n        VectorT<double, 2> v1(1.0, 3.0);\n        VectorT<double, 2> v2(-1.0, 2.0);\n        CHECK(v1.Angle(v2) == Approx(acos(M_SQRT1_2)));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar> explicit VectorT(const CoordT<OtherScalar, DIM>& v),\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Vector2\", \"[Common][Vector2]\"){\n\tSECTION(\"Mirror(axis) 2D\") {\n        VectorT<double, 2> p1(1.0, 2.0);\n        PointT<double, 2> p2(2.0, 3.0);\n        DirectionT<double, 2> d(7.0, 3.0);\n        AxisT<double, 2> a(p2, d);\n        VectorT<double, 2> p3(62.0 / 29.0, -19.0 / 29.0);\n        CHECK(p1.Mirrored(a).IsEqual(p3, tolDis, tolAng));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, typename OtherScalar2, int DIM2 = DIM, typename = typename std::enable_if_t<DIM2 == 3>> [[nodiscard]] DirectionT Rotated(const AxisT<OtherScalar, DIM>& axis, const OtherScalar2& angle),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Direction3\", \"[Common][Direction3]\") {\n\tSECTION(\"Rotate 3D\") {\n            DirectionT<double, 3> p1(1.0, 2.0, 3.0);\n            PointT<double, 3> p2(2.0, 3.0, 4.0);\n            DirectionT<double, 3> d(1.0, 1.0, 2.0);\n            AxisT<double, 3> a(p2, d);\n            DirectionT<double, 3> p3((9.0 - std::sqrt(6.0)) / 6.0, (9.0 - std::sqrt(6.0)) / 6.0, 3.0 + 1.0 / std::sqrt(6.0));\n            CHECK(p1.Rotated(a, M_PI_2).IsEqual(p3, tol));\n        }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, typename OtherScalar2, int DIM2 = DIM, typename = typename std::enable_if_t<DIM2 == 3>> DirectionT& Rotate(const AxisT<OtherScalar, DIM>& axis, const OtherScalar2& angle),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Direction3\", \"[Common][Direction3]\") {\n\tSECTION(\"IsParallel\"){\n        DirectionT<double, 3> v1(1.0, 2.0, 3.0);\n        DirectionT<double, 3> v2(-1.0, -2.0, -3.01);\n        CHECK(v1.IsParallel(v2, tol) == false);\n        CHECK(v1.IsParallel(v2, 0.1));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, int DIM2 = DIM, std::enable_if_t<DIM2 == 3, int> = 0> [[nodiscard]] DirectionT Mirrored(const FrameT<OtherScalar, DIM>& frame),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Direction3\", \"[Common][Direction3]\") {\n\tSECTION(\"Default constructor\") {\n        DirectionT<double, 3> p1;\n        DirectionT<double, 3> p2(1.0, 0.0, 0.0);\n        CHECK(p1.IsEqual(p2, tol));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar> [[nodiscard]] DirectionT Mirrored(const AxisT<OtherScalar, DIM>& axis),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Direction3\", \"[Common][Direction3]\") {\n\tSECTION(\"Mirror(axis) 3D\") {\n        DirectionT<double, 3> p1(1.0, 2.0, 3.0);\n        PointT<double, 3> p2(2.0, 3.0, 4.0);\n        DirectionT<double, 3> d(7.0, 3.0, 2.0);\n        AxisT<double, 3> a(p2, d);\n        DirectionT<double, 3> p3(102.0 / 31.0, -5.0 / 31.0, -55.0 / 31.0);\n        CHECK(p1.Mirrored(a).IsEqual(p3, tol));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, int DIM2 = DIM, std::enable_if_t<DIM2 == 3, int> = 0> DirectionT& Mirror(const FrameT<OtherScalar, DIM>& frame),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Direction3\", \"[Common][Direction3]\") {\n\tSECTION(\"Default constructor\") {\n        DirectionT<double, 3> p1;\n        DirectionT<double, 3> p2(1.0, 0.0, 0.0);\n        CHECK(p1.IsEqual(p2, tol));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar> DirectionT& Mirror(const AxisT<OtherScalar, DIM>& axis),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Direction3\", \"[Common][Direction3]\") {\n\tSECTION(\"Mirror(axis) 3D\") {\n        DirectionT<double, 3> p1(1.0, 2.0, 3.0);\n        PointT<double, 3> p2(2.0, 3.0, 4.0);\n        DirectionT<double, 3> d(7.0, 3.0, 2.0);\n        AxisT<double, 3> a(p2, d);\n        DirectionT<double, 3> p3(102.0 / 31.0, -5.0 / 31.0, -55.0 / 31.0);\n        CHECK(p1.Mirrored(a).IsEqual(p3, tol));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar> DirectionT& Mirror(const DirectionT<OtherScalar, DIM>& dir),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Direction3\", \"[Common][Direction3]\") {\n\tSECTION(\"Mirror(axis) 3D\") {\n        DirectionT<double, 3> p1(1.0, 2.0, 3.0);\n        PointT<double, 3> p2(2.0, 3.0, 4.0);\n        DirectionT<double, 3> d(7.0, 3.0, 2.0);\n        AxisT<double, 3> a(p2, d);\n        DirectionT<double, 3> p3(102.0 / 31.0, -5.0 / 31.0, -55.0 / 31.0);\n        CHECK(p1.Mirrored(a).IsEqual(p3, tol));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar> [[nodiscard]] auto Cross(const DirectionT<OtherScalar, DIM>& other),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Direction3\", \"[Common][Direction3]\") {\n\tSECTION(\"Cross 3D\") {\n        DirectionT<double, 3> v1(1.0, 2.0, 3.0);\n        DirectionT<double, 3> v2(2.0, 3.0, 4.0);\n        CoordT<double, 3> v3(-1.0 / std::sqrt(6.0), 2.0 / std::sqrt(6.0), -1.0 / std::sqrt(6.0));\n        CHECK(v1.Cross(v2).Coord().IsEqual(v3, tol));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, typename OtherScalar2, int DIM2 = DIM, typename = typename std::enable_if_t<DIM2 == 3>> [[nodiscard]] auto AngleWithRef(const DirectionT<OtherScalar, DIM>& other, const DirectionT<OtherScalar2, DIM>& ref),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Direction3\", \"[Common][Direction3]\") {\n\tSECTION(\"IsEqual\") {\n        DirectionT<double, 3> v1(1.0, 2.0, 3.0);\n        DirectionT<double, 3> v2(1.01, 2.0, 3.0);\n        CHECK(v1.IsEqual(v2, 0.01));\n        CHECK(v1.IsEqual(v2, tol) == false);\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, int DIM2 = DIM, std::enable_if_t<DIM2 == 3, int> = 0> [[nodiscard]] auto Angle(const DirectionT<OtherScalar, DIM>& other),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Direction3\", \"[Common][Direction3]\") {\n\tSECTION(\"SetCoord(x, y, z)\") {\n        DirectionT<double, 3> result;\n        result.SetCoord(1.0, 2.0, 3.0);\n        CoordT<double, 3> expected(1.0 / sqrt(14.0), 2.0 / sqrt(14.0), 3.0 / sqrt(14.0));\n        CHECK(result.Coord().IsEqual(expected, tol));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, typename OtherScalar2> [[nodiscard]] bool IsParallel(const DirectionT<OtherScalar, DIM>& other, const OtherScalar2& tol),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Direction3\", \"[Common][Direction3]\") {\n\tSECTION(\"IsParallel\"){\n        DirectionT<double, 3> v1(1.0, 2.0, 3.0);\n        DirectionT<double, 3> v2(-1.0, -2.0, -3.01);\n        CHECK(v1.IsParallel(v2, tol) == false);\n        CHECK(v1.IsParallel(v2, 0.1));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, typename OtherScalar2> [[nodiscard]] bool IsOpposite(const DirectionT<OtherScalar, DIM>& other, const OtherScalar2& tol),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Direction3\", \"[Common][Direction3]\") {\n\tSECTION(\"IsOpposite\") {\n        DirectionT<double, 3> v1(1.0, 2.0, 3.0);\n        DirectionT<double, 3> v2(-1.0, -2.0, -3.01);\n        CHECK(v1.IsOpposite(v2, 0.1));\n        CHECK(v1.IsOpposite(v2, tol) == false);\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, typename OtherScalar2> [[nodiscard]] bool IsNormal(const DirectionT<OtherScalar, DIM>& other, const OtherScalar2& tol),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Direction3\", \"[Common][Direction3]\") {\n\tSECTION(\"IsNormal\") {\n        DirectionT<double, 3> v1(1.0, 2.0, 3.0);\n        DirectionT<double, 3> v2(-4.0, -1.0, 2.01);\n        CHECK(v1.IsNormal(v2, tol) == false);\n        CHECK(v1.IsNormal(v2, 0.1));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, typename OtherScalar2> [[nodiscard]] bool IsEqual(const DirectionT<OtherScalar, DIM>& other, const OtherScalar2& tol),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Direction3\", \"[Common][Direction3]\") {\n\tSECTION(\"Constructor from vector\") {\n        VectorT<double, 3> v(1.0, 2.0, 3.0);\n        DirectionT<double, 3> result(v);\n        CoordT<double, 3> expected(1.0 / sqrt(14.0), 2.0 / sqrt(14.0), 3.0 / sqrt(14.0));\n        CHECK(result.Coord().IsEqual(expected, tol));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, typename = typename std::enable_if_t<DIM >= 4 && std::is_convertible_v<OtherScalar, Scalar>>> void SetW(const OtherScalar& w),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Direction3\", \"[Common][Direction3]\") {\n\tSECTION(\"SetX, SetY, SetZ, SetW\"){\n        DirectionT<double, 4> result;\n        result.SetX(1);\n        result.SetY(2);\n        result.SetZ(3);\n        result.SetW(4);\n        CoordT<double, 4> expected(1.0 / sqrt(850.0), 2.0 / sqrt(850.0), 3.0 / sqrt(170), 4.0 / sqrt(17));\n        CHECK(result.X() == Approx(1.0 / sqrt(850.0)));\n        CHECK(result.Y() == Approx(2.0 / sqrt(850.0)));\n        CHECK(result.Z() == Approx(3.0 / sqrt(170.0)));\n        CHECK(result.W() == Approx(4.0 / sqrt(17.0)));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename... T> void SetCoord(T... vs),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Direction3\", \"[Common][Direction3]\") {\n\tSECTION(\"SetCoord(x, y, z)\") {\n        DirectionT<double, 3> result;\n        result.SetCoord(1.0, 2.0, 3.0);\n        CoordT<double, 3> expected(1.0 / sqrt(14.0), 2.0 / sqrt(14.0), 3.0 / sqrt(14.0));\n        CHECK(result.Coord().IsEqual(expected, tol));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename... T> explicit DirectionT(T... vs),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Direction3\", \"[Common][Direction3]\") {\n\tSECTION(\"Default constructor\") {\n        DirectionT<double, 3> p1;\n        DirectionT<double, 3> p2(1.0, 0.0, 0.0);\n        CHECK(p1.IsEqual(p2, tol));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar> explicit DirectionT(const CoordT<OtherScalar, DIM>& v),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Direction3\", \"[Common][Direction3]\") {\n\tSECTION(\"Constructor from vector\") {\n        VectorT<double, 3> v(1.0, 2.0, 3.0);\n        DirectionT<double, 3> result(v);\n        CoordT<double, 3> expected(1.0 / sqrt(14.0), 2.0 / sqrt(14.0), 3.0 / sqrt(14.0));\n        CHECK(result.Coord().IsEqual(expected, tol));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar> explicit DirectionT(const VectorT<OtherScalar, DIM>& vec),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Direction3\", \"[Common][Direction3]\") {\n\tSECTION(\"Constructor from vector\") {\n        VectorT<double, 3> v(1.0, 2.0, 3.0);\n        DirectionT<double, 3> result(v);\n        CoordT<double, 3> expected(1.0 / sqrt(14.0), 2.0 / sqrt(14.0), 3.0 / sqrt(14.0));\n        CHECK(result.Coord().IsEqual(expected, tol));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "DirectionT()\t @details Default direction is (1, 0, ... , 0)\n\t @brief Default constructor\n,\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Direction3\", \"[Common][Direction3]\") {\n\tSECTION(\"Default constructor\") {\n        DirectionT<double, 3> p1;\n        DirectionT<double, 3> p2(1.0, 0.0, 0.0);\n        CHECK(p1.IsEqual(p2, tol));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, int DIM2 = DIM, typename = typename std::enable_if_t<DIM2 == 2>> [[nodiscard]] DirectionT Rotated(const OtherScalar& angle),\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Direction2\", \"[Common][Direction2]\") {\n\tSECTION(\"Mirror(axis) 2D\") {\n        DirectionT<double, 2> p1(1.0, 2.0);\n        PointT<double, 2> p2(2.0, 3.0);\n        DirectionT<double, 2> d(7.0, 3.0);\n        AxisT<double, 2> a(p2, d);\n        DirectionT<double, 2> p3(62.0 / 29.0, -19.0 / 29.0);\n        CHECK(p1.Mirrored(a).IsEqual(p3, tol));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, int DIM2 = DIM, typename = typename std::enable_if_t<DIM2 == 2>> DirectionT& Rotate(const OtherScalar& angle),\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Direction2\", \"[Common][Direction2]\") {\n\tSECTION(\"Rotate 2D\") {\n        DirectionT<double, 2> p1(1.0, 2.0);\n        DirectionT<double, 2> p3(-2.0, 1.0);\n        CHECK(p1.Rotated(M_PI_2).IsEqual(p3, tol));\n    }\n}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar> [[nodiscard]] DirectionT Mirrored(const AxisT<OtherScalar, DIM>& axis),\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Direction2\", \"[Common][Direction2]\") {\n\tSECTION(\"Mirror(axis) 2D\") {\n        DirectionT<double, 2> p1(1.0, 2.0);\n        PointT<double, 2> p2(2.0, 3.0);\n        DirectionT<double, 2> d(7.0, 3.0);\n        AxisT<double, 2> a(p2, d);\n        DirectionT<double, 2> p3(62.0 / 29.0, -19.0 / 29.0);\n        CHECK(p1.Mirrored(a).IsEqual(p3, tol));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar> [[nodiscard]] DirectionT Mirrored(const DirectionT<OtherScalar, DIM>& dir),\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Direction2\", \"[Common][Direction2]\") {\n\tSECTION(\"Mirror(axis) 2D\") {\n        DirectionT<double, 2> p1(1.0, 2.0);\n        PointT<double, 2> p2(2.0, 3.0);\n        DirectionT<double, 2> d(7.0, 3.0);\n        AxisT<double, 2> a(p2, d);\n        DirectionT<double, 2> p3(62.0 / 29.0, -19.0 / 29.0);\n        CHECK(p1.Mirrored(a).IsEqual(p3, tol));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar> DirectionT& Mirror(const AxisT<OtherScalar, DIM>& axis),\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Direction2\", \"[Common][Direction2]\") {\n\tSECTION(\"Mirror(axis) 2D\") {\n        DirectionT<double, 2> p1(1.0, 2.0);\n        PointT<double, 2> p2(2.0, 3.0);\n        DirectionT<double, 2> d(7.0, 3.0);\n        AxisT<double, 2> a(p2, d);\n        DirectionT<double, 2> p3(62.0 / 29.0, -19.0 / 29.0);\n        CHECK(p1.Mirrored(a).IsEqual(p3, tol));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar> DirectionT& Mirror(const DirectionT<OtherScalar, DIM>& dir),\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Direction2\", \"[Common][Direction2]\") {\n\tSECTION(\"Mirror(axis) 2D\") {\n        DirectionT<double, 2> p1(1.0, 2.0);\n        PointT<double, 2> p2(2.0, 3.0);\n        DirectionT<double, 2> d(7.0, 3.0);\n        AxisT<double, 2> a(p2, d);\n        DirectionT<double, 2> p3(62.0 / 29.0, -19.0 / 29.0);\n        CHECK(p1.Mirrored(a).IsEqual(p3, tol));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar> [[nodiscard]] auto Cross(const DirectionT<OtherScalar, DIM>& other),\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Direction2\", \"[Common][Direction2]\") {\n\tSECTION(\"Cross 2D\") {\n        DirectionT<double, 2> v1(1.0, 2.0);\n        DirectionT<double, 2> v2(2.0, 3.0);\n        CHECK(v1.Cross(v2) == Approx(-1.0/sqrt(65.0)));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, int DIM2 = DIM, std::enable_if_t<DIM2 == 2, int> = 0> [[nodiscard]] auto Angle(const DirectionT<OtherScalar, DIM>& other),\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Direction2\", \"[Common][Direction2]\") {\n\tSECTION(\"Angle 2D\") {\n        DirectionT<double, 2> v1(1.0, 3.0);\n        DirectionT<double, 2> v2(-1.0, 2.0);\n        CHECK(v1.Angle(v2) == Approx(acos(M_SQRT1_2)));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, typename OtherScalar2> [[nodiscard]] bool IsEqual(const DirectionT<OtherScalar, DIM>& other, const OtherScalar2& tol),\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Direction2\", \"[Common][Direction2]\") {\n\tSECTION(\"Mirror(axis) 2D\") {\n        DirectionT<double, 2> p1(1.0, 2.0);\n        PointT<double, 2> p2(2.0, 3.0);\n        DirectionT<double, 2> d(7.0, 3.0);\n        AxisT<double, 2> a(p2, d);\n        DirectionT<double, 2> p3(62.0 / 29.0, -19.0 / 29.0);\n        CHECK(p1.Mirrored(a).IsEqual(p3, tol));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename... T> explicit DirectionT(T... vs),\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Direction2\", \"[Common][Direction2]\") {\n\tSECTION(\"Angle 2D\") {\n        DirectionT<double, 2> v1(1.0, 3.0);\n        DirectionT<double, 2> v2(-1.0, 2.0);\n        CHECK(v1.Angle(v2) == Approx(acos(M_SQRT1_2)));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar> explicit DirectionT(const CoordT<OtherScalar, DIM>& v),\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Direction2\", \"[Common][Direction2]\") {\n\tSECTION(\"Mirror(point) 2D\") {\n        DirectionT<double, 2> p1(1.0, 2.0);\n        DirectionT<double, 2> p2(2.0, 3.0);\n        DirectionT<double, 2> p3(19.0 / 13.0, 22.0 / 13.0);\n        CHECK(p1.Mirrored(p2).IsEqual(p3, tol));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar> explicit DirectionT(const VectorT<OtherScalar, DIM>& vec),\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Direction2\", \"[Common][Direction2]\") {\n\tSECTION(\"Angle 2D\") {\n        DirectionT<double, 2> v1(1.0, 3.0);\n        DirectionT<double, 2> v2(-1.0, 2.0);\n        CHECK(v1.Angle(v2) == Approx(acos(M_SQRT1_2)));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, typename OtherScalar2> [[nodiscard]] FrameT Scaled(const PointT<OtherScalar, DIM>& point, const OtherScalar2& scale),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {\n\treturn result.Location().IsEqual(expected.Location(), tol) &&\n\t\tresult.Direction().IsEqual(expected.Direction(), tol);\n}\nTEST_CASE(\"case1:this is a case for Frame3\",\"[Common][Frame3]\")\n{\n\tSECTION(\"Scale 3D\"){\n\t\tPointT<double, 3> p(1.0, -1.0, 0.0);\n\t\tDirectionT<double, 3> dz(1.0, 2.0, 3.0);\n\t\tFrameT<double, 3> f1(p, dz);\n\t\tPointT<double, 3> p2(1.0, 2.0, 3.0);\n\t\tPointT<double, 3> p3(1.0, -2.5, -1.5);\n\t\tFrameT<double, 3> f2(p3, dz);\n\t\tCHECK(IsEqual(f1.Scaled(p2, 1.5), f2));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, typename OtherScalar2> FrameT& Scale(const PointT<OtherScalar, DIM>& point, const OtherScalar2& scale),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {\n\treturn result.Location().IsEqual(expected.Location(), tol) &&\n\t\tresult.Direction().IsEqual(expected.Direction(), tol);\n}\nTEST_CASE(\"case1:this is a case for Frame3\",\"[Common][Frame3]\")\n{\n\tSECTION(\"Scale 3D\"){\n\t\tPointT<double, 3> p(1.0, -1.0, 0.0);\n\t\tDirectionT<double, 3> dz(1.0, 2.0, 3.0);\n\t\tFrameT<double, 3> f1(p, dz);\n\t\tPointT<double, 3> p2(1.0, 2.0, 3.0);\n\t\tPointT<double, 3> p3(1.0, -2.5, -1.5);\n\t\tFrameT<double, 3> f2(p3, dz);\n\t\tCHECK(IsEqual(f1.Scaled(p2, 1.5), f2));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, typename OtherScalar2, int DIM2 = DIM, typename = typename std::enable_if_t<DIM2 == 3>> [[nodiscard]] FrameT Rotated(const AxisT<OtherScalar, DIM>& a, const OtherScalar2& angle),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {\n\treturn result.Location().IsEqual(expected.Location(), tol) &&\n\t\tresult.Direction().IsEqual(expected.Direction(), tol);\n}\nTEST_CASE(\"case1:this is a case for Frame3\",\"[Common][Frame3]\")\n{\n\tSECTION(\"Rotate 3D\"){\n\t\tPointT<double, 3> p(1.0, -1.0, 0.0);\n\t\tDirectionT<double, 3> dz(1.0, 2.0, 3.0);\n\t\tFrameT<double, 3> f1(p, dz);\n\t\tPointT<double, 3> p2(1.0, 2.0, 3.0);\n\t\tDirectionT<double, 3> dz2(3.0, 2.0, 1.0);\n\t\tAxisT<double, 3> axis(p2, dz2);\n\t\tPointT<double, 3> p3(-3.0 / sqrt(14.0) - 13.0 / 14.0, 9.0 / std::sqrt(14.0) + 10.0 / 14.0, -9.0 / std::sqrt(14.0) + 33.0 / 14.0);\n\t\tDirectionT<double, 3> dz3(4.0 / sqrt(14.0) + 15.0 / 7.0, -8.0 / sqrt(14.0) + 10.0 / 7.0, 4.0 / sqrt(14.0) + 5.0 / 7.0);\n\t\tDirectionT<double, 3> dx3(-7.0 / sqrt(14.0) + 6.0 / 7.0, 6.0 / sqrt(14.0) + 4.0 / 7.0, 9.0 / sqrt(14.0) + 2.0 / 7.0);\n\t\tFrameT<double, 3> f2(p3, dz3, dx3);\n\t\tFrameT<double, 3> f3 = f1.Rotated(axis, M_PI_2);\n\t\tCHECK(IsEqual(f3, f2));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, typename OtherScalar2, int DIM2 = DIM, typename = typename std::enable_if_t<DIM2 == 2>> [[nodiscard]] FrameT Rotated(const PointT<OtherScalar, DIM>& point, const OtherScalar2& angle),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {\n\treturn result.Location().IsEqual(expected.Location(), tol) &&\n\t\tresult.Direction().IsEqual(expected.Direction(), tol);\n}\nTEST_CASE(\"case1:this is a case for Frame3\",\"[Common][Frame3]\")\n{\n\tSECTION(\"Rotate 3D\"){\n\t\tPointT<double, 3> p(1.0, -1.0, 0.0);\n\t\tDirectionT<double, 3> dz(1.0, 2.0, 3.0);\n\t\tFrameT<double, 3> f1(p, dz);\n\t\tPointT<double, 3> p2(1.0, 2.0, 3.0);\n\t\tDirectionT<double, 3> dz2(3.0, 2.0, 1.0);\n\t\tAxisT<double, 3> axis(p2, dz2);\n\t\tPointT<double, 3> p3(-3.0 / sqrt(14.0) - 13.0 / 14.0, 9.0 / std::sqrt(14.0) + 10.0 / 14.0, -9.0 / std::sqrt(14.0) + 33.0 / 14.0);\n\t\tDirectionT<double, 3> dz3(4.0 / sqrt(14.0) + 15.0 / 7.0, -8.0 / sqrt(14.0) + 10.0 / 7.0, 4.0 / sqrt(14.0) + 5.0 / 7.0);\n\t\tDirectionT<double, 3> dx3(-7.0 / sqrt(14.0) + 6.0 / 7.0, 6.0 / sqrt(14.0) + 4.0 / 7.0, 9.0 / sqrt(14.0) + 2.0 / 7.0);\n\t\tFrameT<double, 3> f2(p3, dz3, dx3);\n\t\tFrameT<double, 3> f3 = f1.Rotated(axis, M_PI_2);\n\t\tCHECK(IsEqual(f3, f2));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, typename OtherScalar2, int DIM2 = DIM, typename = typename std::enable_if_t<DIM2 == 3>> FrameT& Rotate(const AxisT<OtherScalar, DIM>& a, const OtherScalar2& angle),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {\n\treturn result.Location().IsEqual(expected.Location(), tol) &&\n\t\tresult.Direction().IsEqual(expected.Direction(), tol);\n}\nTEST_CASE(\"case1:this is a case for Frame3\",\"[Common][Frame3]\")\n{\n\tSECTION(\"Rotate 3D\"){\n\t\tPointT<double, 3> p(1.0, -1.0, 0.0);\n\t\tDirectionT<double, 3> dz(1.0, 2.0, 3.0);\n\t\tFrameT<double, 3> f1(p, dz);\n\t\tPointT<double, 3> p2(1.0, 2.0, 3.0);\n\t\tDirectionT<double, 3> dz2(3.0, 2.0, 1.0);\n\t\tAxisT<double, 3> axis(p2, dz2);\n\t\tPointT<double, 3> p3(-3.0 / sqrt(14.0) - 13.0 / 14.0, 9.0 / std::sqrt(14.0) + 10.0 / 14.0, -9.0 / std::sqrt(14.0) + 33.0 / 14.0);\n\t\tDirectionT<double, 3> dz3(4.0 / sqrt(14.0) + 15.0 / 7.0, -8.0 / sqrt(14.0) + 10.0 / 7.0, 4.0 / sqrt(14.0) + 5.0 / 7.0);\n\t\tDirectionT<double, 3> dx3(-7.0 / sqrt(14.0) + 6.0 / 7.0, 6.0 / sqrt(14.0) + 4.0 / 7.0, 9.0 / sqrt(14.0) + 2.0 / 7.0);\n\t\tFrameT<double, 3> f2(p3, dz3, dx3);\n\t\tFrameT<double, 3> f3 = f1.Rotated(axis, M_PI_2);\n\t\tCHECK(IsEqual(f3, f2));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, int DIM2 = DIM, std::enable_if_t<DIM2 == 3, int> = 0> [[nodiscard]] FrameT Mirrored(const FrameT<OtherScalar, DIM>& frame),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {\n\treturn result.Location().IsEqual(expected.Location(), tol) &&\n\t\tresult.Direction().IsEqual(expected.Direction(), tol);\n}\nTEST_CASE(\"case1:this is a case for Frame3\",\"[Common][Frame3]\")\n{\n\tSECTION(\"Mirror point 3D\"){\n\t\tPointT<double, 3> p(1.0, -1.0, 0.0);\n\t\tPointT<double, 3> p2(1.0, 2.0, -2.0);\n\t\tPointT<double, 3> p3(1.0, 5.0, -4.0);\n\t\tDirectionT<double, 3> dz(1.0, 2.0, 3.0);\n\t\tFrameT<double, 3> f1(p, dz);\n\t\tDirectionT<double, 3> dz2(-1.0, -2.0, -3.0);\n\t\tDirectionT<double, 3> dx2(0.0, -3.0, 2.0);\n\t\tFrameT<double, 3> f2(p3, dz2, dx2);\n\t\tFrameT<double, 3> f3 = f1.Mirrored(p2);\n\t\tCHECK(f3.Location().IsEqual(p3, tol));\n\t\tCHECK(f3.Direction().IsEqual(dz2, tol));\n\t\tCHECK(f3.XDirection().IsEqual(dx2, tol));\n\t\tCHECK(f3.YDirection().IsEqual(dx2.Cross(dz2), tol));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar> [[nodiscard]] FrameT Mirrored(const AxisT<OtherScalar, DIM>& a),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {\n\treturn result.Location().IsEqual(expected.Location(), tol) &&\n\t\tresult.Direction().IsEqual(expected.Direction(), tol);\n}\nTEST_CASE(\"case1:this is a case for Frame3\",\"[Common][Frame3]\")\n{\n\tSECTION(\"Mirror axis 3D\"){\n\t\tPointT<double, 3> p(1.0, -1.0, 0.0);\n\t\tDirectionT<double, 3> dz(1.0, 2.0, 3.0);\n\t\tFrameT<double, 3> f1(p, dz);\n\t\tPointT<double, 3> p2(1.0, 2.0, -2.0);\n\t\tDirectionT<double, 3> d(1.0, 1.0, 1.0);\n\t\tAxisT<double, 3> axis(p2, d);\n\t\tPointT<double, 3> p3(1.0 / 3.0, 13.0 / 3.0, -14.0 / 3.0);\n\t\tDirectionT<double, 3> dz2(3.0, 2.0, 1.0);\n\t\tDirectionT<double, 3> dx2(2.0, -7.0, 8.0);\n\t\tFrameT<double, 3> f2(p3, dz2, dx2);\n\t\tFrameT<double, 3> f3 = f1.Mirrored(axis);\n\t\tCHECK(IsEqual(f2, f3));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar> [[nodiscard]] FrameT Mirrored(const PointT<OtherScalar, DIM>& point),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {\n\treturn result.Location().IsEqual(expected.Location(), tol) &&\n\t\tresult.Direction().IsEqual(expected.Direction(), tol);\n}\nTEST_CASE(\"case1:this is a case for Frame3\",\"[Common][Frame3]\")\n{\n\tSECTION(\"Mirror point 3D\"){\n\t\tPointT<double, 3> p(1.0, -1.0, 0.0);\n\t\tPointT<double, 3> p2(1.0, 2.0, -2.0);\n\t\tPointT<double, 3> p3(1.0, 5.0, -4.0);\n\t\tDirectionT<double, 3> dz(1.0, 2.0, 3.0);\n\t\tFrameT<double, 3> f1(p, dz);\n\t\tDirectionT<double, 3> dz2(-1.0, -2.0, -3.0);\n\t\tDirectionT<double, 3> dx2(0.0, -3.0, 2.0);\n\t\tFrameT<double, 3> f2(p3, dz2, dx2);\n\t\tFrameT<double, 3> f3 = f1.Mirrored(p2);\n\t\tCHECK(f3.Location().IsEqual(p3, tol));\n\t\tCHECK(f3.Direction().IsEqual(dz2, tol));\n\t\tCHECK(f3.XDirection().IsEqual(dx2, tol));\n\t\tCHECK(f3.YDirection().IsEqual(dx2.Cross(dz2), tol));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, int DIM2 = DIM, std::enable_if_t<DIM2 == 3, int> = 0> FrameT& Mirror(const FrameT<OtherScalar, DIM>& frame),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {\n\treturn result.Location().IsEqual(expected.Location(), tol) &&\n\t\tresult.Direction().IsEqual(expected.Direction(), tol);\n}\nTEST_CASE(\"case1:this is a case for Frame3\",\"[Common][Frame3]\")\n{\n\tSECTION(\"Mirror axis 3D\"){\n\t\tPointT<double, 3> p(1.0, -1.0, 0.0);\n\t\tDirectionT<double, 3> dz(1.0, 2.0, 3.0);\n\t\tFrameT<double, 3> f1(p, dz);\n\t\tPointT<double, 3> p2(1.0, 2.0, -2.0);\n\t\tDirectionT<double, 3> d(1.0, 1.0, 1.0);\n\t\tAxisT<double, 3> axis(p2, d);\n\t\tPointT<double, 3> p3(1.0 / 3.0, 13.0 / 3.0, -14.0 / 3.0);\n\t\tDirectionT<double, 3> dz2(3.0, 2.0, 1.0);\n\t\tDirectionT<double, 3> dx2(2.0, -7.0, 8.0);\n\t\tFrameT<double, 3> f2(p3, dz2, dx2);\n\t\tFrameT<double, 3> f3 = f1.Mirrored(axis);\n\t\tCHECK(IsEqual(f2, f3));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar> FrameT& Mirror(const PointT<OtherScalar, DIM>& point),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {\n\treturn result.Location().IsEqual(expected.Location(), tol) &&\n\t\tresult.Direction().IsEqual(expected.Direction(), tol);\n}\nTEST_CASE(\"case1:this is a case for Frame3\",\"[Common][Frame3]\")\n{\n\tSECTION(\"Mirror point 3D\"){\n\t\tPointT<double, 3> p(1.0, -1.0, 0.0);\n\t\tPointT<double, 3> p2(1.0, 2.0, -2.0);\n\t\tPointT<double, 3> p3(1.0, 5.0, -4.0);\n\t\tDirectionT<double, 3> dz(1.0, 2.0, 3.0);\n\t\tFrameT<double, 3> f1(p, dz);\n\t\tDirectionT<double, 3> dz2(-1.0, -2.0, -3.0);\n\t\tDirectionT<double, 3> dx2(0.0, -3.0, 2.0);\n\t\tFrameT<double, 3> f2(p3, dz2, dx2);\n\t\tFrameT<double, 3> f3 = f1.Mirrored(p2);\n\t\tCHECK(f3.Location().IsEqual(p3, tol));\n\t\tCHECK(f3.Direction().IsEqual(dz2, tol));\n\t\tCHECK(f3.XDirection().IsEqual(dx2, tol));\n\t\tCHECK(f3.YDirection().IsEqual(dx2.Cross(dz2), tol));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, typename OtherScalar2, typename OtherScalar3, int DIM2 = DIM, typename = typename std::enable_if_t<DIM2 == 3>> [[nodiscard]] bool IsCoplanar(const AxisT<OtherScalar, DIM>& a, const OtherScalar2& distol, const OtherScalar3& angtol),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {\n\treturn result.Location().IsEqual(expected.Location(), tol) &&\n\t\tresult.Direction().IsEqual(expected.Direction(), tol);\n}\nTEST_CASE(\"case1:this is a case for Frame3\",\"[Common][Frame3]\")\n{\n\tSECTION(\"IsCoplanar frame\"){\n\t\tPointT<double, 3> p(1.0, -1.0, 0.0);\n\t\tPointT<double, 3> p2(1.0, 2.0, -2.0);\n\t\tPointT<double, 3> p3(1.0, 2.0, -1.0);\n\t\tDirectionT<double, 3> dz(1.0, 2.0, 3.0);\n\t\tDirectionT<double, 3> dz2(1.0, 2.0, 3.1);\n\t\tFrameT<double, 3> f1(p, dz);\n\t\tFrameT<double, 3> f2(p2, dz);\n\t\tFrameT<double, 3> f3(p3, dz);\n\t\tFrameT<double, 3> f4(p2, dz2);\n\t\tCHECK(f1.IsCoplanar(f2, 1e-6, 1e-6) == true);\n\t\tCHECK(f1.IsCoplanar(f3, 1e-6, 1e-6) == false);\n\t\tCHECK(f1.IsCoplanar(f4, 1e-6, 1e-6) == false);\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, typename OtherScalar2, typename OtherScalar3, int DIM2 = DIM, typename = typename std::enable_if_t<DIM2 == 3>> [[nodiscard]] bool IsCoplanar(const FrameT<OtherScalar, DIM>& other, const OtherScalar2& distol, const OtherScalar3& angtol),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {\n\treturn result.Location().IsEqual(expected.Location(), tol) &&\n\t\tresult.Direction().IsEqual(expected.Direction(), tol);\n}\nTEST_CASE(\"case1:this is a case for Frame3\",\"[Common][Frame3]\")\n{\n\tSECTION(\"IsCoplanar frame\"){\n\t\tPointT<double, 3> p(1.0, -1.0, 0.0);\n\t\tPointT<double, 3> p2(1.0, 2.0, -2.0);\n\t\tPointT<double, 3> p3(1.0, 2.0, -1.0);\n\t\tDirectionT<double, 3> dz(1.0, 2.0, 3.0);\n\t\tDirectionT<double, 3> dz2(1.0, 2.0, 3.1);\n\t\tFrameT<double, 3> f1(p, dz);\n\t\tFrameT<double, 3> f2(p2, dz);\n\t\tFrameT<double, 3> f3(p3, dz);\n\t\tFrameT<double, 3> f4(p2, dz2);\n\t\tCHECK(f1.IsCoplanar(f2, 1e-6, 1e-6) == true);\n\t\tCHECK(f1.IsCoplanar(f3, 1e-6, 1e-6) == false);\n\t\tCHECK(f1.IsCoplanar(f4, 1e-6, 1e-6) == false);\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<int DIM2 = DIM, typename = typename std::enable_if_t<DIM2 >= 2>> [[nodiscard]] const DirectionT<Scalar, DIM>& YDirection(),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {\n\treturn result.Location().IsEqual(expected.Location(), tol) &&\n\t\tresult.Direction().IsEqual(expected.Direction(), tol);\n}\nTEST_CASE(\"case1:this is a case for Frame3\",\"[Common][Frame3]\")\n{\n\tSECTION(\"YDirection\"){\n\t\tPointT<double, 3> p(1.0, 2.0, 3.0);\n\t\tDirectionT<double, 3> dz(1.0, 2.0, 3.0);\n\t\tDirectionT<double, 3> dy(-13.0, 2.0, 3.0);\n\t\tFrameT<double, 3> f1(p, dz);\n\t\tCHECK(f1.YDirection().IsEqual(dy, tol));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<int DIM2 = DIM, typename = typename std::enable_if_t<DIM2 >= 1>> [[nodiscard]] const DirectionT<Scalar, DIM>& XDirection(),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {\n\treturn result.Location().IsEqual(expected.Location(), tol) &&\n\t\tresult.Direction().IsEqual(expected.Direction(), tol);\n}\nTEST_CASE(\"case1:this is a case for Frame3\",\"[Common][Frame3]\")\n{\n\tSECTION(\"XDirection\"){\n\t\tPointT<double, 3> p(1.0, 2.0, 3.0);\n\t\tDirectionT<double, 3> dz(1.0, 2.0, 3.0);\n\t\tDirectionT<double, 3> dx(0.0, 3.0, -2.0);\n\t\tFrameT<double, 3> f1(p, dz);\n\t\tCHECK(f1.XDirection().IsEqual(dx, tol));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<int DIM2 = DIM, typename = typename std::enable_if_t<DIM2 == 3>> [[nodiscard]] const DirectionT<Scalar, DIM>& Direction(),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {\n\treturn result.Location().IsEqual(expected.Location(), tol) &&\n\t\tresult.Direction().IsEqual(expected.Direction(), tol);\n}\nTEST_CASE(\"case1:this is a case for Frame3\",\"[Common][Frame3]\")\n{\n\tSECTION(\"SetDirection 3D\"){\n\t\tPointT<double, 3> p(0.0, 1.0, 2.0);\n\t\tDirectionT<double, 3> dz(1.0, 2.0, 3.0);\n\t\tDirectionT<double, 3> dz2(2.3, 2.6, 3.3);\n\t\tDirectionT<double, 3> dx(0.0, 3.0, -2.0);\n\t\tFrameT<double, 3> f1(p, dz);\n\t\tFrameT<double, 3> f2(p, dz2);\n\t\tf2.SetDirection(dz);\n\t\tf2.SetXDirection(dx);\n\t\tCHECK(IsEqual(f1, f2));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<int DIM2 = DIM, typename = typename std::enable_if_t<DIM2 == 3>> [[nodiscard]] AxisT<Scalar, DIM> Axis(),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {\n\treturn result.Location().IsEqual(expected.Location(), tol) &&\n\t\tresult.Direction().IsEqual(expected.Direction(), tol);\n}\nTEST_CASE(\"case1:this is a case for Frame3\",\"[Common][Frame3]\")\n{\n\tSECTION(\"Axis\"){\n\t\tPointT<double, 3> p(1.0, 2.0, 3.0);\n\t\tDirectionT<double, 3> dz(1.0, 2.0, 3.0);\n\t\tFrameT<double, 3> f1(p, dz);\n\t\tCHECK(IsEqual(f1.Axis(), AxisT<double, 3>(p, dz)));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, int DIM2 = DIM, std::enable_if_t<DIM2 == 3, int> = 0> void SetYDirection(const DirectionT<OtherScalar, DIM>& y),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {\n\treturn result.Location().IsEqual(expected.Location(), tol) &&\n\t\tresult.Direction().IsEqual(expected.Direction(), tol);\n}\nTEST_CASE(\"case1:this is a case for Frame3\",\"[Common][Frame3]\")\n{\n\tSECTION(\"SetYDirection 3D\"){\n\t\tPointT<double, 3> p(0.0, 1.0, 2.0);\n\t\tDirectionT<double, 3> dz(1.0, 2.0, 3.0);\n\t\tDirectionT<double, 3> dx(-1.0, -1.0, 1.0);\n\t\tDirectionT<double, 3> dy2(-13.0, 2.0, 3.0);\n\t\tFrameT<double, 3> f1(p, dz);\n\t\tFrameT<double, 3> f2(p, dz, dx);\n\t\tf2.SetYDirection(dy2);\n\t\tCHECK(IsEqual(f1, f2));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, int DIM2 = DIM, std::enable_if_t<DIM2 == 3, int> = 0> void SetXDirection(const DirectionT<OtherScalar, DIM>& x),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {\n\treturn result.Location().IsEqual(expected.Location(), tol) &&\n\t\tresult.Direction().IsEqual(expected.Direction(), tol);\n}\nTEST_CASE(\"case1:this is a case for Frame3\",\"[Common][Frame3]\")\n{\n\tSECTION(\"SetXDirection 3D\"){\n\t\tPointT<double, 3> p(0.0, 1.0, 2.0);\n\t\tDirectionT<double, 3> dz(1.0, 2.0, 3.0);\n\t\tDirectionT<double, 3> dx(-1.0, -1.0, 1.0);\n\t\tDirectionT<double, 3> dx2(0.0, 3.0, -2.0);\n\t\tFrameT<double, 3> f1(p, dz);\n\t\tFrameT<double, 3> f2(p, dz, dx);\n\t\tf2.SetXDirection(dx2);\n\t\tCHECK(IsEqual(f1, f2));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, int DIM2 = DIM, typename = typename std::enable_if_t<DIM2 == 3>> void SetDirection(const DirectionT<OtherScalar, DIM>& dir),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {\n\treturn result.Location().IsEqual(expected.Location(), tol) &&\n\t\tresult.Direction().IsEqual(expected.Direction(), tol);\n}\nTEST_CASE(\"case1:this is a case for Frame3\",\"[Common][Frame3]\")\n{\n\tSECTION(\"SetDirection 3D\"){\n\t\tPointT<double, 3> p(0.0, 1.0, 2.0);\n\t\tDirectionT<double, 3> dz(1.0, 2.0, 3.0);\n\t\tDirectionT<double, 3> dz2(2.3, 2.6, 3.3);\n\t\tDirectionT<double, 3> dx(0.0, 3.0, -2.0);\n\t\tFrameT<double, 3> f1(p, dz);\n\t\tFrameT<double, 3> f2(p, dz2);\n\t\tf2.SetDirection(dz);\n\t\tf2.SetXDirection(dx);\n\t\tCHECK(IsEqual(f1, f2));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, typename OtherScalar2, int DIM2 = DIM, std::enable_if_t<DIM2 == 3, int> = 0> FrameT(const PointT<OtherScalar, DIM>& point, const DirectionT<OtherScalar2, DIM>& dir),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {\n\treturn result.Location().IsEqual(expected.Location(), tol) &&\n\t\tresult.Direction().IsEqual(expected.Direction(), tol);\n}\nTEST_CASE(\"case1:this is a case for Frame3\",\"[Common][Frame3]\")\n{\n\tSECTION(\"Default constructor\"){\n\t\tFrameT<double, 3> f1;\n\t\tPointT<double, 3> p(0.0, 0.0, 0.0);\n\t\tDirectionT<double, 3> dz(0.0, 0.0, 1.0);\n\t\tDirectionT<double, 3> dx(1.0, 0.0, 0.0);\n\t\tFrameT<double, 3> f2(p, dz, dx);\n\t\tCHECK(IsEqual(f1, f2));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, typename OtherScalar2, typename OtherScalar3, int DIM2 = DIM, std::enable_if_t<DIM2 == 3, int> = 0> FrameT(const PointT<OtherScalar, DIM>& point, const DirectionT<OtherScalar2, DIM>& normal, const DirectionT<OtherScalar3, DIM>& x),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {\n\treturn result.Location().IsEqual(expected.Location(), tol) &&\n\t\tresult.Direction().IsEqual(expected.Direction(), tol);\n}\nTEST_CASE(\"case1:this is a case for Frame3\",\"[Common][Frame3]\")\n{\n\tSECTION(\"Default constructor\"){\n\t\tFrameT<double, 3> f1;\n\t\tPointT<double, 3> p(0.0, 0.0, 0.0);\n\t\tDirectionT<double, 3> dz(0.0, 0.0, 1.0);\n\t\tDirectionT<double, 3> dx(1.0, 0.0, 0.0);\n\t\tFrameT<double, 3> f2(p, dz, dx);\n\t\tCHECK(IsEqual(f1, f2));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, int DIM2 = DIM, std::enable_if_t<DIM2 == 2, int> = 0> explicit FrameT(const AxisT<OtherScalar, DIM>& axis, bool isright = true),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {\n\treturn result.Location().IsEqual(expected.Location(), tol) &&\n\t\tresult.Direction().IsEqual(expected.Direction(), tol);\n}\nTEST_CASE(\"case1:this is a case for Frame3\",\"[Common][Frame3]\")\n{\n\tSECTION(\"Location\"){\n\t\tPointT<double, 3> p(1.0, 2.0, 3.0);\n\t\tDirectionT<double, 3> dz(1.0, 2.0, 3.0);\n\t\tFrameT<double, 3> f1(p, dz);\n\t\tCHECK(f1.Location().IsEqual(p, tol));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, typename OtherScalar2, int DIM2 = DIM, std::enable_if_t<DIM2 == 2, int> = 0> FrameT(const PointT<OtherScalar, DIM>& point, const DirectionT<OtherScalar2, DIM>& xdir, bool isright = true),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {\n\treturn result.Location().IsEqual(expected.Location(), tol) &&\n\t\tresult.Direction().IsEqual(expected.Direction(), tol);\n}\nTEST_CASE(\"case1:this is a case for Frame3\",\"[Common][Frame3]\")\n{\n\tSECTION(\"IsCoplanar frame\"){\n\t\tPointT<double, 3> p(1.0, -1.0, 0.0);\n\t\tPointT<double, 3> p2(1.0, 2.0, -2.0);\n\t\tPointT<double, 3> p3(1.0, 2.0, -1.0);\n\t\tDirectionT<double, 3> dz(1.0, 2.0, 3.0);\n\t\tDirectionT<double, 3> dz2(1.0, 2.0, 3.1);\n\t\tFrameT<double, 3> f1(p, dz);\n\t\tFrameT<double, 3> f2(p2, dz);\n\t\tFrameT<double, 3> f3(p3, dz);\n\t\tFrameT<double, 3> f4(p2, dz2);\n\t\tCHECK(f1.IsCoplanar(f2, 1e-6, 1e-6) == true);\n\t\tCHECK(f1.IsCoplanar(f3, 1e-6, 1e-6) == false);\n\t\tCHECK(f1.IsCoplanar(f4, 1e-6, 1e-6) == false);\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, typename OtherScalar2, typename OtherScalar3, int DIM2 = DIM, std::enable_if_t<DIM2 == 2, int> = 0> FrameT(const PointT<OtherScalar, DIM>& point, const DirectionT<OtherScalar2, DIM>& xdir, const DirectionT<OtherScalar3, DIM>& ydir),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {\n\treturn result.Location().IsEqual(expected.Location(), tol) &&\n\t\tresult.Direction().IsEqual(expected.Direction(), tol);\n}\nTEST_CASE(\"case1:this is a case for Frame3\",\"[Common][Frame3]\")\n{\n\tSECTION(\"IsCoplanar frame\"){\n\t\tPointT<double, 3> p(1.0, -1.0, 0.0);\n\t\tPointT<double, 3> p2(1.0, 2.0, -2.0);\n\t\tPointT<double, 3> p3(1.0, 2.0, -1.0);\n\t\tDirectionT<double, 3> dz(1.0, 2.0, 3.0);\n\t\tDirectionT<double, 3> dz2(1.0, 2.0, 3.1);\n\t\tFrameT<double, 3> f1(p, dz);\n\t\tFrameT<double, 3> f2(p2, dz);\n\t\tFrameT<double, 3> f3(p3, dz);\n\t\tFrameT<double, 3> f4(p2, dz2);\n\t\tCHECK(f1.IsCoplanar(f2, 1e-6, 1e-6) == true);\n\t\tCHECK(f1.IsCoplanar(f3, 1e-6, 1e-6) == false);\n\t\tCHECK(f1.IsCoplanar(f4, 1e-6, 1e-6) == false);\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "FrameT()\t @details The default frame is the standard orthogonal frame\n\t @brief Default constructor\n,\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {\n\treturn result.Location().IsEqual(expected.Location(), tol) &&\n\t\tresult.Direction().IsEqual(expected.Direction(), tol);\n}\nTEST_CASE(\"case1:this is a case for Frame3\",\"[Common][Frame3]\")\n{\n\tSECTION(\"SetYDirection 3D\"){\n\t\tPointT<double, 3> p(0.0, 1.0, 2.0);\n\t\tDirectionT<double, 3> dz(1.0, 2.0, 3.0);\n\t\tDirectionT<double, 3> dx(-1.0, -1.0, 1.0);\n\t\tDirectionT<double, 3> dy2(-13.0, 2.0, 3.0);\n\t\tFrameT<double, 3> f1(p, dz);\n\t\tFrameT<double, 3> f2(p, dz, dx);\n\t\tf2.SetYDirection(dy2);\n\t\tCHECK(IsEqual(f1, f2));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] const PointT<Scalar, DIM>& Location()\t @return The location\n\t @brief Get the location\n,\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {\n\treturn result.Location().IsEqual(expected.Location(), tol) &&\n\t\tresult.Direction().IsEqual(expected.Direction(), tol);\n}\nTEST_CASE(\"case1:this is a case for Frame3\",\"[Common][Frame3]\")\n{\n\tSECTION(\"Location\"){\n\t\tPointT<double, 3> p(1.0, 2.0, 3.0);\n\t\tDirectionT<double, 3> dz(1.0, 2.0, 3.0);\n\t\tFrameT<double, 3> f1(p, dz);\n\t\tCHECK(f1.Location().IsEqual(p, tol));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, typename OtherScalar2> [[nodiscard]] FrameT Translated(const PointT<OtherScalar, DIM>& p1, const PointT<OtherScalar2, DIM>& p2),\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\nTEST_CASE(\"case1:this is a case for Frame2\", \"[Common][Frame2]\") {\n\tSECTION(\"Translate vector 2D\") {\n\t\tPointT<double, 2> p(1.0, 2.0);\n\t\tDirectionT<double, 2> d(1.0, 3.0);\n\t\tFrameT<double, 2> f1(p, d);\n\t\tVectorT<double, 2> v(2.0, 3.0);\n\t\tPointT<double, 2> p2(3.0, 5.0);\n\t\tFrameT<double, 2> f2(p2, d);\n\t\tCHECK(IsEqual(f1.Translated(v), f2));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar> [[nodiscard]] FrameT Translated(const VectorT<OtherScalar, DIM>& vec),\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\nTEST_CASE(\"case1:this is a case for Frame2\", \"[Common][Frame2]\") {\n\tSECTION(\"Translate vector 2D\") {\n\t\tPointT<double, 2> p(1.0, 2.0);\n\t\tDirectionT<double, 2> d(1.0, 3.0);\n\t\tFrameT<double, 2> f1(p, d);\n\t\tVectorT<double, 2> v(2.0, 3.0);\n\t\tPointT<double, 2> p2(3.0, 5.0);\n\t\tFrameT<double, 2> f2(p2, d);\n\t\tCHECK(IsEqual(f1.Translated(v), f2));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, typename OtherScalar2, int DIM2 = DIM, typename = typename std::enable_if_t<DIM2 == 2>> [[nodiscard]] FrameT Rotated(const PointT<OtherScalar, DIM>& point, const OtherScalar2& angle),\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\nTEST_CASE(\"case1:this is a case for Frame2\", \"[Common][Frame2]\") {\n\tSECTION(\"Construction 2D\") {\n\t\tPointT<double, 2> p(0.0, 0.0);\n\t\tDirectionT<double, 2> dx(1.0, 0.0);\n\t\tDirectionT<double, 2> dy(0.0, 1.0);\n\t\tFrameT<double, 2> f1;\n\t\tFrameT<double, 2> f2(p, dx, dy);\n\t\tCHECK(IsEqual(f1, f2));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, typename OtherScalar2, int DIM2 = DIM, typename = typename std::enable_if_t<DIM2 == 2>> FrameT& Rotate(const PointT<OtherScalar, DIM>& point, const OtherScalar2& angle),\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\nTEST_CASE(\"case1:this is a case for Frame2\", \"[Common][Frame2]\") {\n\tSECTION(\"Construction 2D\") {\n\t\tPointT<double, 2> p(1.0, 2.0);\n\t\tDirectionT<double, 2> dx(1.0, 3.0);\n\t\tDirectionT<double, 2> dy(-3.0, 1.0);\n\t\tFrameT<double, 2> f1(p, dx);\n\t\tFrameT<double, 2> f2(p, dx, dy);\n\t\tCHECK(IsEqual(f1, f2));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar> [[nodiscard]] FrameT Mirrored(const AxisT<OtherScalar, DIM>& a),\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\nTEST_CASE(\"case1:this is a case for Frame2\", \"[Common][Frame2]\") {\n\tSECTION(\"Mirror axis 2D\") {\n\t\tPointT<double, 2> p(1.0, 2.0);\n\t\tDirectionT<double, 2> d(1.0, 3.0);\n\t\tFrameT<double, 2> f1(p, d);\n\t\tPointT<double, 2> p2(2.0, 3.0);\n\t\tDirectionT<double, 2> d2(1.0, 4.0);\n\t\tAxisT<double, 2> axis(p2, d2);\n\t\tPointT<double, 2> p3(41.0 / 17.0, 28.0 / 17.0);\n\t\tDirectionT<double, 2> d3(9.0, 53.0);\n\t\tDirectionT<double, 2> d4(53.0, -9.0);\n\t\tFrameT<double, 2> f2 = f1.Mirrored(axis);\n\t\tCHECK(f2.Location().IsEqual(p3, tol));\n\t\tCHECK(f2.XDirection().IsEqual(d3, tol));\n\t\tCHECK(f2.YDirection().IsEqual(d4, tol));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar> [[nodiscard]] FrameT Mirrored(const PointT<OtherScalar, DIM>& point),\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\nTEST_CASE(\"case1:this is a case for Frame2\", \"[Common][Frame2]\") {\n\tSECTION(\"Mirror axis 2D\") {\n\t\tPointT<double, 2> p(1.0, 2.0);\n\t\tDirectionT<double, 2> d(1.0, 3.0);\n\t\tFrameT<double, 2> f1(p, d);\n\t\tPointT<double, 2> p2(2.0, 3.0);\n\t\tDirectionT<double, 2> d2(1.0, 4.0);\n\t\tAxisT<double, 2> axis(p2, d2);\n\t\tPointT<double, 2> p3(41.0 / 17.0, 28.0 / 17.0);\n\t\tDirectionT<double, 2> d3(9.0, 53.0);\n\t\tDirectionT<double, 2> d4(53.0, -9.0);\n\t\tFrameT<double, 2> f2 = f1.Mirrored(axis);\n\t\tCHECK(f2.Location().IsEqual(p3, tol));\n\t\tCHECK(f2.XDirection().IsEqual(d3, tol));\n\t\tCHECK(f2.YDirection().IsEqual(d4, tol));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar> FrameT& Mirror(const PointT<OtherScalar, DIM>& point),\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\nTEST_CASE(\"case1:this is a case for Frame2\", \"[Common][Frame2]\") {\n\tSECTION(\"Mirror point 2D\") {\n\t\tPointT<double, 2> p(1.0, 2.0);\n\t\tDirectionT<double, 2> d(1.0, 3.0);\n\t\tFrameT<double, 2> f1(p, d);\n\t\tPointT<double, 2> p2(2.0, 3.0);\n\t\tPointT<double, 2> p3(3.0, 4.0);\n\t\tDirectionT<double, 2> d2(-1.0, -3.0);\n\t\tFrameT<double, 2> f2(p3, d2);\n\t\tCHECK(IsEqual(f1.Mirrored(p2), f2));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<int DIM2 = DIM, typename = typename std::enable_if_t<DIM2 >= 2>> [[nodiscard]] const DirectionT<Scalar, DIM>& YDirection(),\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\n#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<int DIM2 = DIM, typename = typename std::enable_if_t<DIM2 >= 1>> [[nodiscard]] const DirectionT<Scalar, DIM>& XDirection(),\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\nTEST_CASE(\"case1:this is a case for Frame2\", \"[Common][Frame2]\") {\n\tSECTION(\"Mirror axis 2D\") {\n\t\tPointT<double, 2> p(1.0, 2.0);\n\t\tDirectionT<double, 2> d(1.0, 3.0);\n\t\tFrameT<double, 2> f1(p, d);\n\t\tPointT<double, 2> p2(2.0, 3.0);\n\t\tDirectionT<double, 2> d2(1.0, 4.0);\n\t\tAxisT<double, 2> axis(p2, d2);\n\t\tPointT<double, 2> p3(41.0 / 17.0, 28.0 / 17.0);\n\t\tDirectionT<double, 2> d3(9.0, 53.0);\n\t\tDirectionT<double, 2> d4(53.0, -9.0);\n\t\tFrameT<double, 2> f2 = f1.Mirrored(axis);\n\t\tCHECK(f2.Location().IsEqual(p3, tol));\n\t\tCHECK(f2.XDirection().IsEqual(d3, tol));\n\t\tCHECK(f2.YDirection().IsEqual(d4, tol));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, int DIM2 = DIM, std::enable_if_t<DIM2 == 2, int> = 0> void SetYDirection(const DirectionT<OtherScalar, DIM>& y),\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\nTEST_CASE(\"case1:this is a case for Frame2\", \"[Common][Frame2]\") {\n\tSECTION(\"SetYDirection 2D\") {\n\t\tPointT<double, 2> p(1.0, 2.0);\n\t\tDirectionT<double, 2> dx(1.0, 3.0);\n\t\tDirectionT<double, 2> dy(-3.0, 1.0);\n\t\tFrameT<double, 2> f1(p, dx);\n\t\tDirectionT<double, 2> dx2(-1.0, -2.0);\n\t\tFrameT<double, 2> f2(p, dx2);\n\t\tf2.SetYDirection(dy);\n\t\tCHECK(IsEqual(f1, f2));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, int DIM2 = DIM, std::enable_if_t<DIM2 == 2, int> = 0> void SetXDirection(const DirectionT<OtherScalar, DIM>& x),\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\nTEST_CASE(\"case1:this is a case for Frame2\", \"[Common][Frame2]\") {\n\tSECTION(\"SetXDirection 2D\") {\n\t\tPointT<double, 2> p(1.0, 2.0);\n\t\tDirectionT<double, 2> dx(1.0, 3.0);\n\t\tFrameT<double, 2> f1(p, dx);\n\t\tDirectionT<double, 2> dx2(-1.0, -2.0);\n\t\tFrameT<double, 2> f2(p, dx2);\n\t\tf2.SetXDirection(dx);\n\t\tCHECK(IsEqual(f1, f2));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, int DIM2 = DIM, std::enable_if_t<DIM2 == 2, int> = 0> void SetYAxis(const AxisT<OtherScalar, DIM>& axis),\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\nTEST_CASE(\"case1:this is a case for Frame2\", \"[Common][Frame2]\") {\n\tSECTION(\"SetYAxis 2D\") {\n\t\tPointT<double, 2> p(1.0, 2.0);\n\t\tPointT<double, 2> p2(3.0, 1.0);\n\t\tDirectionT<double, 2> dx(1.0, 3.0);\n\t\tDirectionT<double, 2> dy(-3.0, 1.0);\n\t\tFrameT<double, 2> f1(p, dx);\n\t\tDirectionT<double, 2> dx2(-1.0, -2.0);\n\t\tFrameT<double, 2> f2(p2, dx2);\n\t\tAxisT<double, 2> axis(p, dy);\n\t\tf2.SetYAxis(axis);\n\t\tCHECK(IsEqual(f1, f2));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, int DIM2 = DIM, std::enable_if_t<DIM2 == 2, int> = 0> void SetXAxis(const AxisT<OtherScalar, DIM>& axis),\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\nTEST_CASE(\"case1:this is a case for Frame2\", \"[Common][Frame2]\") {\n\tSECTION(\"SetXAxis 2D\") {\n\t\tPointT<double, 2> p(1.0, 2.0);\n\t\tPointT<double, 2> p2(3.0, 1.0);\n\t\tDirectionT<double, 2> dx(1.0, 3.0);\n\t\tFrameT<double, 2> f1(p, dx);\n\t\tDirectionT<double, 2> dx2(-1.0, -2.0);\n\t\tFrameT<double, 2> f2(p2, dx2);\n\t\tAxisT<double, 2> axis(p, dx);\n\t\tf2.SetXAxis(axis);\n\t\tCHECK(IsEqual(f1, f2));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, typename OtherScalar2, int DIM2 = DIM, std::enable_if_t<DIM2 == 3, int> = 0> FrameT(const PointT<OtherScalar, DIM>& point, const DirectionT<OtherScalar2, DIM>& dir),\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\n#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, int DIM2 = DIM, std::enable_if_t<DIM2 == 2, int> = 0> explicit FrameT(const AxisT<OtherScalar, DIM>& axis, bool isright = true),\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\nTEST_CASE(\"case1:this is a case for Frame2\", \"[Common][Frame2]\") {\n\tSECTION(\"Construction 2D\") {\n\t\tPointT<double, 2> p(0.0, 0.0);\n\t\tDirectionT<double, 2> dx(1.0, 0.0);\n\t\tDirectionT<double, 2> dy(0.0, 1.0);\n\t\tFrameT<double, 2> f1;\n\t\tFrameT<double, 2> f2(p, dx, dy);\n\t\tCHECK(IsEqual(f1, f2));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, typename OtherScalar2, int DIM2 = DIM, std::enable_if_t<DIM2 == 2, int> = 0> FrameT(const PointT<OtherScalar, DIM>& point, const DirectionT<OtherScalar2, DIM>& xdir, bool isright = true),\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\nTEST_CASE(\"case1:this is a case for Frame2\", \"[Common][Frame2]\") {\n\tSECTION(\"Construction 2D\") {\n\t\tPointT<double, 2> p(0.0, 0.0);\n\t\tDirectionT<double, 2> dx(1.0, 0.0);\n\t\tDirectionT<double, 2> dy(0.0, 1.0);\n\t\tFrameT<double, 2> f1;\n\t\tFrameT<double, 2> f2(p, dx, dy);\n\t\tCHECK(IsEqual(f1, f2));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, typename OtherScalar2, typename OtherScalar3, int DIM2 = DIM, std::enable_if_t<DIM2 == 2, int> = 0> FrameT(const PointT<OtherScalar, DIM>& point, const DirectionT<OtherScalar2, DIM>& xdir, const DirectionT<OtherScalar3, DIM>& ydir),\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\nTEST_CASE(\"case1:this is a case for Frame2\", \"[Common][Frame2]\") {\n\tSECTION(\"Construction 2D\") {\n\t\tPointT<double, 2> p(0.0, 0.0);\n\t\tDirectionT<double, 2> dx(1.0, 0.0);\n\t\tDirectionT<double, 2> dy(0.0, 1.0);\n\t\tFrameT<double, 2> f1;\n\t\tFrameT<double, 2> f2(p, dx, dy);\n\t\tCHECK(IsEqual(f1, f2));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] const PointT<Scalar, DIM>& Location()\t @return The location\n\t @brief Get the location\n,\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\nTEST_CASE(\"case1:this is a case for Frame2\", \"[Common][Frame2]\") {\n\tSECTION(\"Mirror axis 2D\") {\n\t\tPointT<double, 2> p(1.0, 2.0);\n\t\tDirectionT<double, 2> d(1.0, 3.0);\n\t\tFrameT<double, 2> f1(p, d);\n\t\tPointT<double, 2> p2(2.0, 3.0);\n\t\tDirectionT<double, 2> d2(1.0, 4.0);\n\t\tAxisT<double, 2> axis(p2, d2);\n\t\tPointT<double, 2> p3(41.0 / 17.0, 28.0 / 17.0);\n\t\tDirectionT<double, 2> d3(9.0, 53.0);\n\t\tDirectionT<double, 2> d4(53.0, -9.0);\n\t\tFrameT<double, 2> f2 = f1.Mirrored(axis);\n\t\tCHECK(f2.Location().IsEqual(p3, tol));\n\t\tCHECK(f2.XDirection().IsEqual(d3, tol));\n\t\tCHECK(f2.YDirection().IsEqual(d4, tol));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar> [[nodiscard]] AxisT Translated(const VectorT<OtherScalar, DIM>& vec),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected){\n\treturn result.Location().IsEqual(expected.Location(), tol) &&\n\t\tresult.Direction().IsEqual(expected.Direction(), tol);\n}\nTEST_CASE(\"case1:this is a case for Axis3\",\"[Common][Axis3]\")\n{\n\tint i = 1;\n\tSECTION(\"Translate(vec) 3D\"){\n\t\tAxisT<double, 3> a1(PointT<double, 3>(1.0, 2.0, 3.0), DirectionT<double, 3>{1.0, 2.0, 3.0});\n\t\tVectorT<double, 3> v1(2.0, 3.0, 4.0);\n\t\tAxisT<double, 3> a2(PointT<double, 3>(3.0, 5.0, 7.0), DirectionT<double, 3>{1.0, 2.0, 3.0});\n\t\tCHECK(IsEqual(a1.Translated(v1), a2));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, typename OtherScalar2> [[nodiscard]] AxisT Scaled(const PointT<OtherScalar, DIM> point, const OtherScalar2& scale),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected){\n\treturn result.Location().IsEqual(expected.Location(), tol) &&\n\t\tresult.Direction().IsEqual(expected.Direction(), tol);\n}\nTEST_CASE(\"case1:this is a case for Axis3\",\"[Common][Axis3]\")\n{\n\tint i = 1;\n\tSECTION(\"Scale 3D\"){\n\t\tAxisT<double, 3> a1(PointT<double, 3>{1.0, 2.0, 3.0}, DirectionT<double, 3>{1.0, 2.0, 3.0});\n\t\tPointT<double, 3> p(2.0, 3.0, 4.0);\n\t\tAxisT<double, 3> a2(PointT<double, 3>{0.5, 1.5, 2.5}, DirectionT<double, 3>{1.0, 2.0, 3.0});\n\t\tCHECK(IsEqual(a1.Scaled(p, 1.5), a2));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, typename OtherScalar2, int DIM2 = DIM, typename = typename std::enable_if_t<DIM2 == 3>> AxisT& Rotate(const AxisT<OtherScalar, DIM>& axis, const OtherScalar2& angle),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected){\n\treturn result.Location().IsEqual(expected.Location(), tol) &&\n\t\tresult.Direction().IsEqual(expected.Direction(), tol);\n}\nTEST_CASE(\"case1:this is a case for Axis3\",\"[Common][Axis3]\")\n{\n\tint i = 1;\n\tSECTION(\"Rotate 3D\"){\n\t\tAxisT<double, 3> a1(PointT<double, 3>{1.0, 2.0, 3.0}, DirectionT<double, 3>{1.0, 2.0, 3.0});\n\t\tAxisT<double, 3> a2(PointT<double, 3>{2.0, 3.0, 4.0}, DirectionT<double, 3>{1.0, 1.0, 2.0});\n\t\tAxisT<double, 3> a3(PointT<double, 3>{(8.0 + std::sqrt(6.0)) / 6.0, (14.0 - std::sqrt(6.0)) / 6.0, 8.0 / 3.0}, DirectionT<double, 3>{(9.0 - std::sqrt(6.0)) / 6.0, (9.0 - std::sqrt(6.0)) / 6.0, 3.0 + 1.0 / std::sqrt(6.0)});\n\t\tCHECK(IsEqual(a1.Rotated(a2, M_PI_2), a3));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, int DIM2 = DIM, std::enable_if_t<DIM2 == 3, int> = 0> [[nodiscard]] AxisT Mirrored(const FrameT<OtherScalar, DIM>& frame),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected){\n\treturn result.Location().IsEqual(expected.Location(), tol) &&\n\t\tresult.Direction().IsEqual(expected.Direction(), tol);\n}\nTEST_CASE(\"case1:this is a case for Axis3\",\"[Common][Axis3]\")\n{\n\tint i = 1;\n\tSECTION(\"Mirror(frame) 3D\"){\n\t\tAxisT<double, 3> a1(PointT<double, 3>{1.0, 2.0, 3.0}, DirectionT<double, 3>{1.0, 2.0, 3.0});\n\t\tFrameT<double, 3> f(PointT<double, 3>{2.0, 3.0, 4.0}, DirectionT<double, 3>{7.0, 3.0, 2.0});\n\t\tAxisT<double, 3> a2(PointT<double, 3>{115.0 / 31.0, 98.0 / 31.0, 117.0 / 31.0}, DirectionT<double, 3>{-102.0 / 31.0, 5.0 / 31.0, 55.0 / 31.0});\n\t\tCHECK(IsEqual(a1.Mirror(f), a2));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar> [[nodiscard]] AxisT Mirrored(const AxisT<OtherScalar, DIM>& axis),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected){\n\treturn result.Location().IsEqual(expected.Location(), tol) &&\n\t\tresult.Direction().IsEqual(expected.Direction(), tol);\n}\nTEST_CASE(\"case1:this is a case for Axis3\",\"[Common][Axis3]\")\n{\n\tint i = 1;\n\tSECTION(\"Mirror(axis) 3D\"){\n\t\tAxisT<double, 3> a1(PointT<double, 3>{1.0, 2.0, 3.0}, DirectionT<double, 3>{1.0, 2.0, 3.0});\n\t\tAxisT<double, 3> a2(PointT<double, 3>{2.0, 3.0, 4.0}, DirectionT<double, 3>{7.0, 3.0, 2.0});\n\t\tAxisT<double, 3> a3(PointT<double, 3>{9.0 / 31.0, 88.0 / 31.0, 131.0 / 31.0}, DirectionT<double, 3>{102.0 / 31.0, -5.0 / 31.0, -55.0 / 31.0});\n\t\tCHECK(IsEqual(a1.Mirrored(a2), a3));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar> [[nodiscard]] AxisT Mirrored(const PointT<OtherScalar, DIM>& point),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected){\n\treturn result.Location().IsEqual(expected.Location(), tol) &&\n\t\tresult.Direction().IsEqual(expected.Direction(), tol);\n}\nTEST_CASE(\"case1:this is a case for Axis3\",\"[Common][Axis3]\")\n{\n\tint i = 1;\n\tSECTION(\"Mirror(frame) 3D\"){\n\t\tAxisT<double, 3> a1(PointT<double, 3>{1.0, 2.0, 3.0}, DirectionT<double, 3>{1.0, 2.0, 3.0});\n\t\tFrameT<double, 3> f(PointT<double, 3>{2.0, 3.0, 4.0}, DirectionT<double, 3>{7.0, 3.0, 2.0});\n\t\tAxisT<double, 3> a2(PointT<double, 3>{115.0 / 31.0, 98.0 / 31.0, 117.0 / 31.0}, DirectionT<double, 3>{-102.0 / 31.0, 5.0 / 31.0, 55.0 / 31.0});\n\t\tCHECK(IsEqual(a1.Mirror(f), a2));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, int DIM2 = DIM, std::enable_if_t<DIM2 == 3, int> = 0> AxisT& Mirror(const FrameT<OtherScalar, DIM>& frame),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected){\n\treturn result.Location().IsEqual(expected.Location(), tol) &&\n\t\tresult.Direction().IsEqual(expected.Direction(), tol);\n}\nTEST_CASE(\"case1:this is a case for Axis3\",\"[Common][Axis3]\")\n{\n\tint i = 1;\n\tSECTION(\"Mirror(point) 3D\"){\n\t\tAxisT<double, 3> a1(PointT<double, 3>{1.0, 2.0, 3.0}, DirectionT<double, 3>{1.0, 1.0, 1.0});\n\t\tPointT<double, 3> p(2.0, 4.0, 5.0);\n\t\tAxisT<double, 3> a2(PointT<double, 3>{3.0, 6.0, 7.0}, DirectionT<double, 3>{-1.0, -1.0, -1.0});\n\t\tCHECK(IsEqual(a1.Mirrored(p), a2));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar> AxisT& Mirror(const PointT<OtherScalar, DIM>& point),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected){\n\treturn result.Location().IsEqual(expected.Location(), tol) &&\n\t\tresult.Direction().IsEqual(expected.Direction(), tol);\n}\nTEST_CASE(\"case1:this is a case for Axis3\",\"[Common][Axis3]\")\n{\n\tint i = 1;\n\tSECTION(\"Mirror(point) 3D\"){\n\t\tAxisT<double, 3> a1(PointT<double, 3>{1.0, 2.0, 3.0}, DirectionT<double, 3>{1.0, 1.0, 1.0});\n\t\tPointT<double, 3> p(2.0, 4.0, 5.0);\n\t\tAxisT<double, 3> a2(PointT<double, 3>{3.0, 6.0, 7.0}, DirectionT<double, 3>{-1.0, -1.0, -1.0});\n\t\tCHECK(IsEqual(a1.Mirrored(p), a2));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar> [[nodiscard]] double Angle(const AxisT<OtherScalar, DIM>& other),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected){\n\treturn result.Location().IsEqual(expected.Location(), tol) &&\n\t\tresult.Direction().IsEqual(expected.Direction(), tol);\n}\nTEST_CASE(\"case1:this is a case for Axis3\",\"[Common][Axis3]\")\n{\n\tint i = 1;\n\tSECTION(\"Angle\"){\n\t\tAxisT<double, 3> a1(PointT<double, 3>{0.0, 0.0, 0.0}, DirectionT<double, 3>{1.0, 2.0, 1.0});\n\t\tAxisT<double, 3> a2(PointT<double, 3>{2.0, 4.0, 3.0}, DirectionT<double, 3>{-1.0, 1.0, -1.0});\n\t\tCHECK(a1.Angle(a2) == M_PI_2);\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, typename OtherScalar2> [[nodiscard]] bool IsParallel(const AxisT<OtherScalar, DIM>& other, const OtherScalar2& tol),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected){\n\treturn result.Location().IsEqual(expected.Location(), tol) &&\n\t\tresult.Direction().IsEqual(expected.Direction(), tol);\n}\nTEST_CASE(\"case1:this is a case for Axis3\",\"[Common][Axis3]\")\n{\n\tint i = 1;\n\tSECTION(\"IsParallel\"){\n\t\tAxisT<double, 3> a1(PointT<double, 3>{0.0, 0.0, 0.0}, DirectionT<double, 3>{1.0, 2.0, 1.0});\n\t\tAxisT<double, 3> a2(PointT<double, 3>{2.0, 4.0, 3.0}, DirectionT<double, 3>{-1.0, -2.0, -1.0});\n\t\tCHECK(a1.IsParallel(a2, 1e-6) == true);\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, typename OtherScalar2> [[nodiscard]] bool IsOpposite(const AxisT<OtherScalar, DIM>& other, const OtherScalar2& tol),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected){\n\treturn result.Location().IsEqual(expected.Location(), tol) &&\n\t\tresult.Direction().IsEqual(expected.Direction(), tol);\n}\nTEST_CASE(\"case1:this is a case for Axis3\",\"[Common][Axis3]\")\n{\n\tint i = 1;\n\tSECTION(\"IsOpposite\"){\n\t\tAxisT<double, 3> a1(PointT<double, 3>{0.0, 0.0, 0.0}, DirectionT<double, 3>{1.0, 2.0, 1.0});\n\t\tAxisT<double, 3> a2(PointT<double, 3>{2.0, 4.0, 3.0}, DirectionT<double, 3>{-1.0, -2.0, -1.0});\n\t\tCHECK(a1.IsOpposite(a2, 1e-6) == true);\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, typename OtherScalar2> [[nodiscard]] bool IsNormal(const AxisT<OtherScalar, DIM>& other, const OtherScalar2& tol),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected){\n\treturn result.Location().IsEqual(expected.Location(), tol) &&\n\t\tresult.Direction().IsEqual(expected.Direction(), tol);\n}\nTEST_CASE(\"case1:this is a case for Axis3\",\"[Common][Axis3]\")\n{\n\tint i = 1;\n\tSECTION(\"IsNormal\"){\n\t\tAxisT<double, 3> a1(PointT<double, 3>{0.0, 0.0, 0.0}, DirectionT<double, 3>{1.0, 2.0, 1.0});\n\t\tAxisT<double, 3> a2(PointT<double, 3>{2.0, 4.0, 3.0}, DirectionT<double, 3>{-1.0, 1.0, -1.0});\n\t\tCHECK(a1.IsNormal(a2, 1e-6) == true);\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, typename OtherScalar2, typename OtherScalar3, int DIM2 = DIM, std::enable_if_t<DIM2 == 3, int> = 0> [[nodiscard]] bool IsCoaxial(const AxisT<OtherScalar, DIM>& other, const OtherScalar2& angtol, const OtherScalar3& distol),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected){\n\treturn result.Location().IsEqual(expected.Location(), tol) &&\n\t\tresult.Direction().IsEqual(expected.Direction(), tol);\n}\nTEST_CASE(\"case1:this is a case for Axis3\",\"[Common][Axis3]\")\n{\n\tint i = 1;\n\tSECTION(\"IsCoaxial 3D\"){\n\t\tAxisT<double, 3> a1(PointT<double, 3>{0.0, 0.0, 0.0}, DirectionT<double, 3>{1.0, 2.0, 3.0});\n\t\tAxisT<double, 3> a2(PointT<double, 3>{2.0, 4.0, 6.0}, DirectionT<double, 3>{1.0, 2.0, 3.0});\n\t\tAxisT<double, 3> a3(PointT<double, 3>{2.0, 4.0, 6.0}, DirectionT<double, 3>{2.0, 2.0, 3.0});\n\t\tAxisT<double, 3> a4(PointT<double, 3>{1.0, 4.0, 6.0}, DirectionT<double, 3>{1.0, 2.0, 3.0});\n\t\tCHECK(a1.IsCoaxial(a2, 1e-6, 1e-6) == true);\n\t\tCHECK(a1.IsCoaxial(a3, 1e-6, 1e-6) == false);\n\t\tCHECK(a1.IsCoaxial(a4, 1e-6, 1e-6) == false);\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, typename OtherScalar2, typename OtherScalar3, int DIM2 = DIM, std::enable_if_t<DIM2 == 2, int> = 0> [[nodiscard]] bool IsCoaxial(const AxisT<OtherScalar, DIM>& other, const OtherScalar2& angtol, const OtherScalar3& distol),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected){\n\treturn result.Location().IsEqual(expected.Location(), tol) &&\n\t\tresult.Direction().IsEqual(expected.Direction(), tol);\n}\nTEST_CASE(\"case1:this is a case for Axis3\",\"[Common][Axis3]\")\n{\n\tint i = 1;\n\tSECTION(\"IsCoaxial 3D\"){\n\t\tAxisT<double, 3> a1(PointT<double, 3>{0.0, 0.0, 0.0}, DirectionT<double, 3>{1.0, 2.0, 3.0});\n\t\tAxisT<double, 3> a2(PointT<double, 3>{2.0, 4.0, 6.0}, DirectionT<double, 3>{1.0, 2.0, 3.0});\n\t\tAxisT<double, 3> a3(PointT<double, 3>{2.0, 4.0, 6.0}, DirectionT<double, 3>{2.0, 2.0, 3.0});\n\t\tAxisT<double, 3> a4(PointT<double, 3>{1.0, 4.0, 6.0}, DirectionT<double, 3>{1.0, 2.0, 3.0});\n\t\tCHECK(a1.IsCoaxial(a2, 1e-6, 1e-6) == true);\n\t\tCHECK(a1.IsCoaxial(a3, 1e-6, 1e-6) == false);\n\t\tCHECK(a1.IsCoaxial(a4, 1e-6, 1e-6) == false);\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar> void SetDirection(const DirectionT<OtherScalar, DIM>& dir),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected){\n\treturn result.Location().IsEqual(expected.Location(), tol) &&\n\t\tresult.Direction().IsEqual(expected.Direction(), tol);\n}\nTEST_CASE(\"case1:this is a case for Axis3\",\"[Common][Axis3]\")\n{\n\tint i = 1;\n\tSECTION(\"SetDirection\"){\n\t\tAxisT<double, 3> a1;\n\t\tDirectionT<double, 3> d(1.0, 2.0, 3.0);\n\t\ta1.SetDirection(d);\n\t\tAxisT<double, 3> a2(PointT<double, 3>{0.0, 0.0, 0.0}, d);\n\t\tCHECK(IsEqual(a1, a2));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, typename OtherScalar2> AxisT(const PointT<OtherScalar, DIM>& point, const DirectionT<OtherScalar2, DIM>& dir),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected){\n\treturn result.Location().IsEqual(expected.Location(), tol) &&\n\t\tresult.Direction().IsEqual(expected.Direction(), tol);\n}\nTEST_CASE(\"case1:this is a case for Axis3\",\"[Common][Axis3]\")\n{\n\tint i = 1;\n\tSECTION(\"IsCoaxial 3D\"){\n\t\tAxisT<double, 3> a1(PointT<double, 3>{0.0, 0.0, 0.0}, DirectionT<double, 3>{1.0, 2.0, 3.0});\n\t\tAxisT<double, 3> a2(PointT<double, 3>{2.0, 4.0, 6.0}, DirectionT<double, 3>{1.0, 2.0, 3.0});\n\t\tAxisT<double, 3> a3(PointT<double, 3>{2.0, 4.0, 6.0}, DirectionT<double, 3>{2.0, 2.0, 3.0});\n\t\tAxisT<double, 3> a4(PointT<double, 3>{1.0, 4.0, 6.0}, DirectionT<double, 3>{1.0, 2.0, 3.0});\n\t\tCHECK(a1.IsCoaxial(a2, 1e-6, 1e-6) == true);\n\t\tCHECK(a1.IsCoaxial(a3, 1e-6, 1e-6) == false);\n\t\tCHECK(a1.IsCoaxial(a4, 1e-6, 1e-6) == false);\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AxisT()\t @details The default location is (0, 0, 0). In 2D, the default direction is (1, 0); in 3D, the default direction is (0, 0, 1).\n\t @brief Default constructor\n,\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected){\n\treturn result.Location().IsEqual(expected.Location(), tol) &&\n\t\tresult.Direction().IsEqual(expected.Direction(), tol);\n}\nTEST_CASE(\"case1:this is a case for Axis3\",\"[Common][Axis3]\")\n{\n\tint i = 1;\n\tSECTION(\"default constructor 3D\"){\n\t\tAxisT<double, 3> a1;\n\t\tAxisT<double, 3> a2(PointT<double, 3>{0.0, 0.0, 0.0}, DirectionT<double, 3>{0.0, 0.0, 1.0});\n\t\tCHECK(IsEqual(a1, a2));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar> [[nodiscard]] AxisT Mirrored(const PointT<OtherScalar, DIM>& point),\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {\n\treturn result.Location().IsEqual(expected.Location(), tol) &&\n\t\tresult.Direction().IsEqual(expected.Direction(), tol);\n}\nTEST_CASE(\"case1:this is a case for Axis2\", \"[Common][Axis2]\") {\n\tSECTION(\"Mirror(point) 2D\") {\n\t\tAxisT<double, 2> a1(PointT<double, 2>{1.0, 2.0}, DirectionT<double, 2>{1.0, 1.0});\n\t\tPointT<double, 2> p(3.0, 4.0);\n\t\tAxisT<double, 2> a2(PointT<double, 2>{5.0, 6.0}, DirectionT<double, 2>{-1.0, -1.0});\n\t\tCHECK(IsEqual(a1.Mirrored(p), a2));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar> AxisT& Mirror(const PointT<OtherScalar, DIM>& point),\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {\n\treturn result.Location().IsEqual(expected.Location(), tol) &&\n\t\tresult.Direction().IsEqual(expected.Direction(), tol);\n}\nTEST_CASE(\"case1:this is a case for Axis2\", \"[Common][Axis2]\") {\n\tSECTION(\"Mirror(point) 2D\") {\n\t\tAxisT<double, 2> a1(PointT<double, 2>{1.0, 2.0}, DirectionT<double, 2>{1.0, 1.0});\n\t\tPointT<double, 2> p(3.0, 4.0);\n\t\tAxisT<double, 2> a2(PointT<double, 2>{5.0, 6.0}, DirectionT<double, 2>{-1.0, -1.0});\n\t\tCHECK(IsEqual(a1.Mirrored(p), a2));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, typename OtherScalar2, typename OtherScalar3, int DIM2 = DIM, std::enable_if_t<DIM2 == 2, int> = 0> [[nodiscard]] bool IsCoaxial(const AxisT<OtherScalar, DIM>& other, const OtherScalar2& angtol, const OtherScalar3& distol),\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {\n\treturn result.Location().IsEqual(expected.Location(), tol) &&\n\t\tresult.Direction().IsEqual(expected.Direction(), tol);\n}\nTEST_CASE(\"case1:this is a case for Axis2\", \"[Common][Axis2]\") {\n\tSECTION(\"IsCoaxial 2D\") {\n\t\tAxisT<double, 2> a1(PointT<double, 2>{0.0, 0.0}, DirectionT<double, 2>{1.0, 2.0});\n\t\tAxisT<double, 2> a2(PointT<double, 2>{2.0, 4.0}, DirectionT<double, 2>{1.0, 2.0});\n\t\tAxisT<double, 2> a3(PointT<double, 2>{2.0, 4.0}, DirectionT<double, 2>{2.0, 2.0});\n\t\tAxisT<double, 2> a4(PointT<double, 2>{1.0, 4.0}, DirectionT<double, 2>{1.0, 2.0});\n\t\tCHECK(a1.IsCoaxial(a2, 1e-6, 1e-6) == true);\n\t\tCHECK(a1.IsCoaxial(a3, 1e-6, 1e-6) == false);\n\t\tCHECK(a1.IsCoaxial(a4, 1e-6, 1e-6) == false);\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, typename OtherScalar2> AxisT(const PointT<OtherScalar, DIM>& point, const DirectionT<OtherScalar2, DIM>& dir),\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {\n\treturn result.Location().IsEqual(expected.Location(), tol) &&\n\t\tresult.Direction().IsEqual(expected.Direction(), tol);\n}\nTEST_CASE(\"case1:this is a case for Axis2\", \"[Common][Axis2]\") {\n\tSECTION(\"IsCoaxial 2D\") {\n\t\tAxisT<double, 2> a1(PointT<double, 2>{0.0, 0.0}, DirectionT<double, 2>{1.0, 2.0});\n\t\tAxisT<double, 2> a2(PointT<double, 2>{2.0, 4.0}, DirectionT<double, 2>{1.0, 2.0});\n\t\tAxisT<double, 2> a3(PointT<double, 2>{2.0, 4.0}, DirectionT<double, 2>{2.0, 2.0});\n\t\tAxisT<double, 2> a4(PointT<double, 2>{1.0, 4.0}, DirectionT<double, 2>{1.0, 2.0});\n\t\tCHECK(a1.IsCoaxial(a2, 1e-6, 1e-6) == true);\n\t\tCHECK(a1.IsCoaxial(a3, 1e-6, 1e-6) == false);\n\t\tCHECK(a1.IsCoaxial(a4, 1e-6, 1e-6) == false);\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API void SimplifyResult(bool isUnfiyEdges = true, bool isUnifyFaces = true, double angularTol = Precision::Angular()\t @param angularTol The angular tolerance for checking parallel\n\t @param isUnifyFaces Set whether unify faces\n\t @param isUnfiyEdges Set whether unify edges\n\t @brief Simplify the boolean result, remove redundant edges and faces\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <boolean/BoolBuilder.hpp>\n#include <modeling/MakeBox.hpp>\n#include <boolean/BoolBRepFuse.hpp>\n#include <common/IndexSet.hpp>\n#include <topology/TopoExplorerTool.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"case1: BoolBuilder added SimplifyResult() API at 3.6.0. \", \"[boolean][BoolBuilder][P1]\") {\n\tTopoShape box1 = MakeBox(Point3(0., 0., 0.), Point3(2., 2., 2.));\n\tTopoShape box2 = MakeBox(Point3(1., 1., 0.), Point3(3., 3., 2.));\n\tBoolBRepFuse fuse(box1, box2);\n\tTopoShape shape1 = fuse.Shape();\n\tfuse.SimplifyResult();\n\tTopoShape shape2 = fuse.Shape();\n\tIndexSet<TopoShape> shape1Faces, shape2Faces;\n\tTopoExplorerTool::MapShapes(shape1, ShapeType::Face, shape1Faces);\n\tTopoExplorerTool::MapShapes(shape2, ShapeType::Face, shape2Faces);\n\tstd::cout << shape1Faces.size() << \"  \" << shape2Faces.size() << std::endl;\n\tCHECK(shape1Faces.size() == 14);\n\tCHECK(shape2Faces.size() == 10);\n}\n#include<catch.hpp>\n#include<testHelper.h>\n#include <boolean/BoolBuilder.hpp>\n#include <modeling/MakeBox.hpp>\n#include <boolean/BoolBRepFuse.hpp>\n#include <common/IndexSet.hpp>\n#include <topology/TopoExplorerTool.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"case1: BoolBuilder added SimplifyResult() API at 3.6.0. \", \"[boolean][BoolBuilder][P1]\") {\n\tTopoShape box1 = MakeBox(Point3(0., 0., 0.), Point3(2., 2., 2.));\n\tTopoShape box2 = MakeBox(Point3(1., 1., 0.), Point3(3., 3., 2.));\n\tBoolBRepFuse fuse(box1, box2);\n\tTopoShape shape1 = fuse.Shape();\n\tfuse.SimplifyResult();\n\tTopoShape shape2 = fuse.Shape();\n\tIndexSet<TopoShape> shape1Faces, shape2Faces;\n\tTopoExplorerTool::MapShapes(shape1, ShapeType::Face, shape1Faces);\n\tTopoExplorerTool::MapShapes(shape2, ShapeType::Face, shape2Faces);\n\tstd::cout << shape1Faces.size() << \"  \" << shape2Faces.size() << std::endl;\n\tCHECK(shape1Faces.size() == 14);\n\tCHECK(shape2Faces.size() == 10);\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API BoolBRepSection(const std::shared_ptr<Geom3Surface>& s1, const std::shared_ptr<Geom3Surface>& s2, bool perfomNow = true)\t @param perfomNow If true, the operation is performed immediately; if false, the Build() function has to be called manually\n\t @param s2 The tool surface\n\t @param s1 The argument surface\n\t @brief Special case: compute the section of two surfaces\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <boolean/BoolBRepSection.hpp>\n#include <common/CartesianCoordinateSystem.hpp>\n#include <math/LineT.hpp>\n#include <modeling/MakePrism.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeFace.hpp>\n#include <geometry/Geom3BezierCurve.hpp>\n#include <modeling/MakeRevol.hpp>\n#include <geometry/Geom3CylindricalSurface.hpp>\n#include <topology/TopoTool.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"bug1: BoolBRepSection \", \"[boolean][BoolBRepSection][fixbug]\")\n{\n\tLine3 line(CartesianCoordinateSystem::OZ());\n\tTopoShape infinitePlane1 = MakePrism(MakeEdge(line, 0.0, 1.0), Direction3(-1.0, 0.0, 0.0), false);\n\tTopoShape infinitePlane2 = MakePrism(MakeEdge(line, 0.0, 1.0), Direction3(1.0, 0.0, 0.0), false);\n\tTopoShape infinitePlane3 = MakePrism(MakeEdge(line, 0.0, 1.0), Direction3(0.0, 1.0, 0.0), false);\n\tTopoShape infinitePlane4 = MakePrism(MakeEdge(line, 0.0, 1.0), Direction3(0.0, -1.0, 0.0), false);\n\tstd::vector<Point3> poles{ Point3(1.0, 0.0, 0.0), Point3(0.8, 0.0, 0.5), Point3(1.0, 0.0, 1.0) };\n\tauto bz = std::make_shared<Geom3BezierCurve>(poles);\n\tTopoEdge e2 = MakeEdge(bz);\n\tTopoShape revolshape = MakeRevol(e2, CartesianCoordinateSystem::OZ());\n\tauto surface1 = std::make_shared<Geom3CylindricalSurface>(Frame3(), 1.0);\n\tauto surface2 = TopoTool::Surface(TopoCast::Face(revolshape));\n\tTopoShape result1 = BoolBRepSection(infinitePlane1, surface2); \n\tTopoShape result2 = BoolBRepSection(infinitePlane2, surface2); \n\tTopoShape result3 = BoolBRepSection(infinitePlane3, surface2); \n\tTopoShape result4 = BoolBRepSection(infinitePlane4, surface2); \n\tGlobalProperty prop1, prop2, prop3, prop4 ;\n\tCHECK( GetLinearProperties(result1, prop1, true, false) == Approx(1.0260606301));\n\tCHECK( GetLinearProperties(result2, prop1, true, false) == Approx(1.0260606301));\n\tCHECK( GetLinearProperties(result3, prop1, true, false) == Approx(1.0260606301));\n\tCHECK( GetLinearProperties(result4, prop1, true, false) == Approx(1.0260606301));\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API BoolBRepSection(const std::shared_ptr<Geom3Surface>& surface, const TopoShape& s2, bool perfomNow = true)\t @param perfomNow If true, the operation is performed immediately; if false, the Build() function has to be called manually\n\t @param s2 The tool shape\n\t @param surface The argument surface\n\t @brief Special case: compute the section of a surface and a shape\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <boolean/BoolBRepSection.hpp>\n#include <common/CartesianCoordinateSystem.hpp>\n#include <math/LineT.hpp>\n#include <modeling/MakePrism.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeFace.hpp>\n#include <geometry/Geom3BezierCurve.hpp>\n#include <modeling/MakeRevol.hpp>\n#include <geometry/Geom3CylindricalSurface.hpp>\n#include <topology/TopoTool.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"bug1: BoolBRepSection \", \"[boolean][BoolBRepSection][fixbug]\")\n{\n\tLine3 line(CartesianCoordinateSystem::OZ());\n\tTopoShape infinitePlane1 = MakePrism(MakeEdge(line, 0.0, 1.0), Direction3(-1.0, 0.0, 0.0), false);\n\tTopoShape infinitePlane2 = MakePrism(MakeEdge(line, 0.0, 1.0), Direction3(1.0, 0.0, 0.0), false);\n\tTopoShape infinitePlane3 = MakePrism(MakeEdge(line, 0.0, 1.0), Direction3(0.0, 1.0, 0.0), false);\n\tTopoShape infinitePlane4 = MakePrism(MakeEdge(line, 0.0, 1.0), Direction3(0.0, -1.0, 0.0), false);\n\tstd::vector<Point3> poles{ Point3(1.0, 0.0, 0.0), Point3(0.8, 0.0, 0.5), Point3(1.0, 0.0, 1.0) };\n\tauto bz = std::make_shared<Geom3BezierCurve>(poles);\n\tTopoEdge e2 = MakeEdge(bz);\n\tTopoShape revolshape = MakeRevol(e2, CartesianCoordinateSystem::OZ());\n\tauto surface1 = std::make_shared<Geom3CylindricalSurface>(Frame3(), 1.0);\n\tauto surface2 = TopoTool::Surface(TopoCast::Face(revolshape));\n\tTopoShape result1 = BoolBRepSection(infinitePlane1, surface2); \n\tTopoShape result2 = BoolBRepSection(infinitePlane2, surface2); \n\tTopoShape result3 = BoolBRepSection(infinitePlane3, surface2); \n\tTopoShape result4 = BoolBRepSection(infinitePlane4, surface2); \n\tGlobalProperty prop1, prop2, prop3, prop4 ;\n\tCHECK( GetLinearProperties(result1, prop1, true, false) == Approx(1.0260606301));\n\tCHECK( GetLinearProperties(result2, prop1, true, false) == Approx(1.0260606301));\n\tCHECK( GetLinearProperties(result3, prop1, true, false) == Approx(1.0260606301));\n\tCHECK( GetLinearProperties(result4, prop1, true, false) == Approx(1.0260606301));\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API BoolBRepSection(const TopoShape& s1, const std::shared_ptr<Geom3Surface>& surface, bool perfomNow = true)\t @param perfomNow If true, the operation is performed immediately; if false, the Build() function has to be called manually\n\t @param surface The tool surface\n\t @param s1 The argument shape\n\t @brief Special case: compute the section of a shape and a surface\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <boolean/BoolBRepSection.hpp>\n#include <common/CartesianCoordinateSystem.hpp>\n#include <math/LineT.hpp>\n#include <modeling/MakePrism.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeFace.hpp>\n#include <geometry/Geom3BezierCurve.hpp>\n#include <modeling/MakeRevol.hpp>\n#include <geometry/Geom3CylindricalSurface.hpp>\n#include <topology/TopoTool.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"bug1: BoolBRepSection \", \"[boolean][BoolBRepSection][fixbug]\")\n{\n\tLine3 line(CartesianCoordinateSystem::OZ());\n\tTopoShape infinitePlane1 = MakePrism(MakeEdge(line, 0.0, 1.0), Direction3(-1.0, 0.0, 0.0), false);\n\tTopoShape infinitePlane2 = MakePrism(MakeEdge(line, 0.0, 1.0), Direction3(1.0, 0.0, 0.0), false);\n\tTopoShape infinitePlane3 = MakePrism(MakeEdge(line, 0.0, 1.0), Direction3(0.0, 1.0, 0.0), false);\n\tTopoShape infinitePlane4 = MakePrism(MakeEdge(line, 0.0, 1.0), Direction3(0.0, -1.0, 0.0), false);\n\tstd::vector<Point3> poles{ Point3(1.0, 0.0, 0.0), Point3(0.8, 0.0, 0.5), Point3(1.0, 0.0, 1.0) };\n\tauto bz = std::make_shared<Geom3BezierCurve>(poles);\n\tTopoEdge e2 = MakeEdge(bz);\n\tTopoShape revolshape = MakeRevol(e2, CartesianCoordinateSystem::OZ());\n\tauto surface1 = std::make_shared<Geom3CylindricalSurface>(Frame3(), 1.0);\n\tauto surface2 = TopoTool::Surface(TopoCast::Face(revolshape));\n\tTopoShape result1 = BoolBRepSection(infinitePlane1, surface2); \n\tTopoShape result2 = BoolBRepSection(infinitePlane2, surface2); \n\tTopoShape result3 = BoolBRepSection(infinitePlane3, surface2); \n\tTopoShape result4 = BoolBRepSection(infinitePlane4, surface2); \n\tGlobalProperty prop1, prop2, prop3, prop4 ;\n\tCHECK( GetLinearProperties(result1, prop1, true, false) == Approx(1.0260606301));\n\tCHECK( GetLinearProperties(result2, prop1, true, false) == Approx(1.0260606301));\n\tCHECK( GetLinearProperties(result3, prop1, true, false) == Approx(1.0260606301));\n\tCHECK( GetLinearProperties(result4, prop1, true, false) == Approx(1.0260606301));\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API BoolBRepSection(const TopoShape& s1, const Plane& p1, bool perfomNow = true)\t @param perfomNow If true, the operation is performed immediately; if false, the Build() function has to be called manually\n\t @param p1 The tool plane\n\t @param s1 The argument shape\n\t @brief Special case: compute the section of a shape and an infinite plane\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <boolean/BoolBRepSection.hpp>\n#include <common/CartesianCoordinateSystem.hpp>\n#include <math/LineT.hpp>\n#include <modeling/MakePrism.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeFace.hpp>\n#include <geometry/Geom3BezierCurve.hpp>\n#include <modeling/MakeRevol.hpp>\n#include <geometry/Geom3CylindricalSurface.hpp>\n#include <topology/TopoTool.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"bug1: BoolBRepSection \", \"[boolean][BoolBRepSection][fixbug]\")\n{\n\tLine3 line(CartesianCoordinateSystem::OZ());\n\tTopoShape infinitePlane1 = MakePrism(MakeEdge(line, 0.0, 1.0), Direction3(-1.0, 0.0, 0.0), false);\n\tTopoShape infinitePlane2 = MakePrism(MakeEdge(line, 0.0, 1.0), Direction3(1.0, 0.0, 0.0), false);\n\tTopoShape infinitePlane3 = MakePrism(MakeEdge(line, 0.0, 1.0), Direction3(0.0, 1.0, 0.0), false);\n\tTopoShape infinitePlane4 = MakePrism(MakeEdge(line, 0.0, 1.0), Direction3(0.0, -1.0, 0.0), false);\n\tstd::vector<Point3> poles{ Point3(1.0, 0.0, 0.0), Point3(0.8, 0.0, 0.5), Point3(1.0, 0.0, 1.0) };\n\tauto bz = std::make_shared<Geom3BezierCurve>(poles);\n\tTopoEdge e2 = MakeEdge(bz);\n\tTopoShape revolshape = MakeRevol(e2, CartesianCoordinateSystem::OZ());\n\tauto surface1 = std::make_shared<Geom3CylindricalSurface>(Frame3(), 1.0);\n\tauto surface2 = TopoTool::Surface(TopoCast::Face(revolshape));\n\tTopoShape result1 = BoolBRepSection(infinitePlane1, surface2); \n\tTopoShape result2 = BoolBRepSection(infinitePlane2, surface2); \n\tTopoShape result3 = BoolBRepSection(infinitePlane3, surface2); \n\tTopoShape result4 = BoolBRepSection(infinitePlane4, surface2); \n\tGlobalProperty prop1, prop2, prop3, prop4 ;\n\tCHECK( GetLinearProperties(result1, prop1, true, false) == Approx(1.0260606301));\n\tCHECK( GetLinearProperties(result2, prop1, true, false) == Approx(1.0260606301));\n\tCHECK( GetLinearProperties(result3, prop1, true, false) == Approx(1.0260606301));\n\tCHECK( GetLinearProperties(result4, prop1, true, false) == Approx(1.0260606301));\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API BoolBRepSection(const TopoShape& s1, const TopoShape& s2, bool perfomNow = true)\t @param perfomNow If true, the operation is performed immediately; if false, the Build() function has to be called manually\n\t @param s2 The tool shape\n\t @param s1 The argument shape\n\t @brief Compute the section of two shapes\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <boolean/BoolBRepSection.hpp>\n#include <common/CartesianCoordinateSystem.hpp>\n#include <math/LineT.hpp>\n#include <modeling/MakePrism.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeFace.hpp>\n#include <geometry/Geom3BezierCurve.hpp>\n#include <modeling/MakeRevol.hpp>\n#include <geometry/Geom3CylindricalSurface.hpp>\n#include <topology/TopoTool.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"bug1: BoolBRepSection \", \"[boolean][BoolBRepSection][fixbug]\")\n{\n\tLine3 line(CartesianCoordinateSystem::OZ());\n\tTopoShape infinitePlane1 = MakePrism(MakeEdge(line, 0.0, 1.0), Direction3(-1.0, 0.0, 0.0), false);\n\tTopoShape infinitePlane2 = MakePrism(MakeEdge(line, 0.0, 1.0), Direction3(1.0, 0.0, 0.0), false);\n\tTopoShape infinitePlane3 = MakePrism(MakeEdge(line, 0.0, 1.0), Direction3(0.0, 1.0, 0.0), false);\n\tTopoShape infinitePlane4 = MakePrism(MakeEdge(line, 0.0, 1.0), Direction3(0.0, -1.0, 0.0), false);\n\tstd::vector<Point3> poles{ Point3(1.0, 0.0, 0.0), Point3(0.8, 0.0, 0.5), Point3(1.0, 0.0, 1.0) };\n\tauto bz = std::make_shared<Geom3BezierCurve>(poles);\n\tTopoEdge e2 = MakeEdge(bz);\n\tTopoShape revolshape = MakeRevol(e2, CartesianCoordinateSystem::OZ());\n\tauto surface1 = std::make_shared<Geom3CylindricalSurface>(Frame3(), 1.0);\n\tauto surface2 = TopoTool::Surface(TopoCast::Face(revolshape));\n\tTopoShape result1 = BoolBRepSection(infinitePlane1, surface2); \n\tTopoShape result2 = BoolBRepSection(infinitePlane2, surface2); \n\tTopoShape result3 = BoolBRepSection(infinitePlane3, surface2); \n\tTopoShape result4 = BoolBRepSection(infinitePlane4, surface2); \n\tGlobalProperty prop1, prop2, prop3, prop4 ;\n\tCHECK( GetLinearProperties(result1, prop1, true, false) == Approx(1.0260606301));\n\tCHECK( GetLinearProperties(result2, prop1, true, false) == Approx(1.0260606301));\n\tCHECK( GetLinearProperties(result3, prop1, true, false) == Approx(1.0260606301));\n\tCHECK( GetLinearProperties(result4, prop1, true, false) == Approx(1.0260606301));\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API BoolBRepSection()\t @details Only set the type of boolean operation to section\n\t @brief Default constructor\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <boolean/BoolBRepSection.hpp>\n#include <common/CartesianCoordinateSystem.hpp>\n#include <math/LineT.hpp>\n#include <modeling/MakePrism.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeFace.hpp>\n#include <geometry/Geom3BezierCurve.hpp>\n#include <modeling/MakeRevol.hpp>\n#include <geometry/Geom3CylindricalSurface.hpp>\n#include <topology/TopoTool.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"bug1: BoolBRepSection \", \"[boolean][BoolBRepSection][fixbug]\")\n{\n\tLine3 line(CartesianCoordinateSystem::OZ());\n\tTopoShape infinitePlane1 = MakePrism(MakeEdge(line, 0.0, 1.0), Direction3(-1.0, 0.0, 0.0), false);\n\tTopoShape infinitePlane2 = MakePrism(MakeEdge(line, 0.0, 1.0), Direction3(1.0, 0.0, 0.0), false);\n\tTopoShape infinitePlane3 = MakePrism(MakeEdge(line, 0.0, 1.0), Direction3(0.0, 1.0, 0.0), false);\n\tTopoShape infinitePlane4 = MakePrism(MakeEdge(line, 0.0, 1.0), Direction3(0.0, -1.0, 0.0), false);\n\tstd::vector<Point3> poles{ Point3(1.0, 0.0, 0.0), Point3(0.8, 0.0, 0.5), Point3(1.0, 0.0, 1.0) };\n\tauto bz = std::make_shared<Geom3BezierCurve>(poles);\n\tTopoEdge e2 = MakeEdge(bz);\n\tTopoShape revolshape = MakeRevol(e2, CartesianCoordinateSystem::OZ());\n\tauto surface1 = std::make_shared<Geom3CylindricalSurface>(Frame3(), 1.0);\n\tauto surface2 = TopoTool::Surface(TopoCast::Face(revolshape));\n\tTopoShape result1 = BoolBRepSection(infinitePlane1, surface2); \n\tTopoShape result2 = BoolBRepSection(infinitePlane2, surface2); \n\tTopoShape result3 = BoolBRepSection(infinitePlane3, surface2); \n\tTopoShape result4 = BoolBRepSection(infinitePlane4, surface2); \n\tGlobalProperty prop1, prop2, prop3, prop4 ;\n\tCHECK( GetLinearProperties(result1, prop1, true, false) == Approx(1.0260606301));\n\tCHECK( GetLinearProperties(result2, prop1, true, false) == Approx(1.0260606301));\n\tCHECK( GetLinearProperties(result3, prop1, true, false) == Approx(1.0260606301));\n\tCHECK( GetLinearProperties(result4, prop1, true, false) == Approx(1.0260606301));\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API BoolBRepFuse(const TopoShape& s1, const TopoShape& s2)\t @param s2 The tool shape\n\t @param s1 The argument shape\n\t @brief Compute the fuse of two shapes\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <boolean/BoolBRepFuse.hpp>\n#include <boolean/BoolBRepCut.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"bug1: BoolBRepFuse \", \"[boolean][BoolBRepFuse][fixbug]\")\n{\n\tTopoShape shape1, shape2;\n\tOCCTIO::OCCTTool::Read(shape1, INPUT_PATH_PREFIX\"boolean/part.brep\");\n\tOCCTIO::OCCTTool::Read(shape2, INPUT_PATH_PREFIX\"boolean/box.brep\");\n\tTopoShape result = BoolBRepFuse(shape1, shape2);\n\tCHECK(OCCTIO::OCCTTool::Write(result, OUTPUT_PATH_PREFIX\"testbug-view-556.brep\"));\n\tIndexSet<TopoShape> shapeFace, shapeEdge, shapeVertex ,shapeSolid;\n\tCHECK( GetTopoToolCount(result, AMCAX::ShapeType::Solid, shapeSolid)==1 );\n}\t\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API BoolBRepFuse()\t @details Only set the type of boolean operation to fuse\n\t @brief Default constructor\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <boolean/BoolBRepFuse.hpp>\n#include <boolean/BoolBRepCut.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"bug1: BoolBRepFuse \", \"[boolean][BoolBRepFuse][fixbug]\")\n{\n\tTopoShape shape1, shape2;\n\tOCCTIO::OCCTTool::Read(shape1, INPUT_PATH_PREFIX\"boolean/part.brep\");\n\tOCCTIO::OCCTTool::Read(shape2, INPUT_PATH_PREFIX\"boolean/box.brep\");\n\tTopoShape result = BoolBRepFuse(shape1, shape2);\n\tCHECK(OCCTIO::OCCTTool::Write(result, OUTPUT_PATH_PREFIX\"testbug-view-556.brep\"));\n\tIndexSet<TopoShape> shapeFace, shapeEdge, shapeVertex ,shapeSolid;\n\tCHECK( GetTopoToolCount(result, AMCAX::ShapeType::Solid, shapeSolid)==1 );\n}\t\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API explicit BoolBRepDefeaturing(const TopoShape& shape)\t @param shape The shape that require remove feature\n\t @brief Construct from a shape.\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <modeling/MakeBox.hpp>\n#include <modeling/MakeCylinder.hpp>\n#include <boolean/BoolBRepCut.hpp>\n#include <topomesh/BRepMeshIncrementalMesh.hpp>\n#include <io/OBJTool.hpp>\n#include <topology/TopoFace.hpp>\n#include <geometry/Geom3Surface.hpp>\n#include <topology/TopoTool.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <boolean/BoolBRepDefeaturing.hpp>\n#include <topology/TopoEdge.hpp>\n#include <common/IndexSet.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"case1: test BoolBRepDefeaturing Algorithm\", \"[boolean][BRepDefeaturing]\")\n{\n\tOUTPUT_DIRECTORY(Boolean, BRepDefeaturing);\n\tTopoShape box = MakeBox(Point3(-5.0, -5.0, 0.0), Point3(5.0, 5.0, 3.0));\n\tTopoShape cyl = MakeCylinder(Frame3(Point3(0.0, 0.0, 0.0), Direction3(0.0, 0.0, 1.0)), 3.0, 5.0);\n\tTopoShape shape = BoolBRepCut(box, cyl);\n\tOCCTIO::OCCTTool::Write(shape, outdir + \"testResultTemp.brep\");\n\tBRepMeshIncrementalMesh meshT(shape, 0.01, true);\n\tOBJTool::WriteShape(shape, outdir + \"testResultTemp.obj\");\n\tIndexSet<TopoShape> shapeFace, shapeEdge, shapeVertex;\n\tCHECK(GetTopoToolCount(shape, ShapeType::Face, shapeFace) == 7);\n\tCHECK(GetTopoToolCount(shape, ShapeType::Edge, shapeEdge) == 15);\n\tCHECK(GetTopoToolCount(shape, ShapeType::Vertex, shapeVertex) == 10);\n\tTopoFace cy;\n\tstd::list<TopoShape> faceToRemove;\n\tfor (TopoExplorer expF(shape, ShapeType::Face); expF.More(); expF.Next())\n\t{\n\t\tTopoFace f = static_cast<const TopoFace&>(expF.Current());\n\t\tstd::shared_ptr<Geom3Surface> surface = TopoTool::Surface(f);\n\t\tif (surface->Type() == SurfaceType::Cylinder)\n\t\t{\n\t\t\tcy = f;\n\t\t\tOCCTIO::OCCTTool::Write(f, outdir + \"RemoveFace.brep\");\n\t\t\tfaceToRemove.push_back(f);\n\t\t}\n\t}\n\tBoolBRepDefeaturing defeature(shape);\n\tdefeature.AddFaceToRemove(faceToRemove);\n\tdefeature.Build();\n\tTopoShape newShape = defeature.Shape();\n\tPoint3 p(-3.0, 0.0, 1.0);\n\tdouble tol = -1.0;\n\tbool isIn = BRepClassificationTools::IsPointInFace(cy, p, tol);\n\tCHECK(isIn == true);\n\tfor (TopoExplorer expF(newShape, ShapeType::Face); expF.More(); expF.Next())\n\t{\n\t\tTopoFace newFace = static_cast<const TopoFace&>(expF.Current());\n\t\tbool isIn1 = BRepClassificationTools::IsPointInFace(newFace, p, tol);\n\t\tCHECK(isIn1 == false);\n\t}\n\tfor (TopoExplorer expF1(newShape, ShapeType::Face); expF1.More(); expF1.Next())\n\t{\n\t\tbool result;\n\t\tTopoFace f1 = static_cast<const TopoFace&>(expF1.Current());\n\t\tstd::shared_ptr<Geom3Surface> surface1 = TopoTool::Surface(f1);\n\t\tif (surface1->Type() == SurfaceType::Cylinder)\n\t\t{\n\t\t\tresult = false;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tresult = true;\n\t\t}\n\t\tCHECK(result == true);\n\t}\n\tAMCAX::GlobalProperty props1, props2, props3;\n\tIndexSet<TopoShape> newshapeFace, newshapeEdge, newshapeVertex;\n\tCHECK(newShape.Type() == ShapeType::Compound);\n\tCHECK(GetTopoToolCount(newShape, ShapeType::Face, newshapeFace) == 6);\n\tCHECK(GetTopoToolCount(newShape, ShapeType::Edge, newshapeEdge) == 12);\n\tCHECK(GetTopoToolCount(newShape, ShapeType::Vertex, newshapeVertex) == 8);\n\tCHECK(GetLinearProperties(newShape,props1,true,false)== Approx(10 * 8 + 3 * 4));\n\tCHECK(GetSurfaceProperties(newShape, props2, true, false) == Approx(2 * (10 * 10) + 4*(10 * 3)));\n\tCHECK(GetVolumeProperties(newShape, props3, true, false) == Approx(10*10*3));\n\tPoint3 point = props3.CenterOfMass();\n\tCHECK(point.X() == Approx(0.0).margin(1e-12));\n\tCHECK(point.Y() == Approx(0.0).margin(1e-12));\n\tCHECK(point.Z() == Approx(1.5).margin(1e-12));\n\tstd::cout << \"defeature ok \" << std::endl;\n\tOCCTIO::OCCTTool::Write(newShape, outdir + \"testResult.brep\");\n\tBRepMeshIncrementalMesh meshR(newShape, 0.01, true);\n\tOBJTool::WriteShape(newShape, outdir + \"testResult.obj\");\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API BoolBRepCut(const TopoShape& s1, const TopoShape& s2, bool isForward = true)\t @param isForward Cut s1 by s2 if true, and cut s2 by s1 if false\n\t @param s2 The tool shape\n\t @param s1 The argument shape\n\t @brief Compute the cut operation of two shapes\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <boolean/BoolBRepCut.hpp>\n#include <modeling/MakeTorus.hpp>\n#include <modeling/MakeSphere.hpp>\n#include <modeling/MakeCone.hpp>\n#include <topology/TopoExplorer.hpp>\n#include <topology/TopoFace.hpp>\n#include <hatch/BRepClassificationTools.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"bug1: in Debug mode: BoolBuilder  \", \"[boolean][BoolBRepCut][P1][fixbug]\") {\n\tTopoShape torus = MakeTorus(Frame3(Point3(0.0, 0.0, 2.0), Direction3(1.0, 0.0, 0.0)), 4.0, 2.0);\n\tTopoShape sphere = MakeSphere(4.0);\n\tTopoShape result = BoolBRepCut(sphere, torus);\n\tAMCAX::GlobalProperty prop;\n\tAMCAX::BRepGlobalProperty::VolumeProperties(result, prop);\n\tCHECK(prop.Mass() == Approx(153.229)); \n\tbool isWriteSuccess = AMCAX::OCCTIO::OCCTTool::Write(result, OUTPUT_PATH_PREFIX\"BoolBRepCut_bug72.brep\", false);\n\tCHECK(isWriteSuccess == true);\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API BoolBRepCut()\t @details Only set the type of boolean operation to cut\n\t @brief Default constructor\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <boolean/BoolBRepCut.hpp>\n#include <modeling/MakeTorus.hpp>\n#include <modeling/MakeSphere.hpp>\n#include <modeling/MakeCone.hpp>\n#include <topology/TopoExplorer.hpp>\n#include <topology/TopoFace.hpp>\n#include <hatch/BRepClassificationTools.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"bug1: in Debug mode: BoolBuilder  \", \"[boolean][BoolBRepCut][P1][fixbug]\") {\n\tTopoShape torus = MakeTorus(Frame3(Point3(0.0, 0.0, 2.0), Direction3(1.0, 0.0, 0.0)), 4.0, 2.0);\n\tTopoShape sphere = MakeSphere(4.0);\n\tTopoShape result = BoolBRepCut(sphere, torus);\n\tAMCAX::GlobalProperty prop;\n\tAMCAX::BRepGlobalProperty::VolumeProperties(result, prop);\n\tCHECK(prop.Mass() == Approx(153.229)); \n\tbool isWriteSuccess = AMCAX::OCCTIO::OCCTTool::Write(result, OUTPUT_PATH_PREFIX\"BoolBRepCut_bug72.brep\", false);\n\tCHECK(isWriteSuccess == true);\n}\n}\n,{\n"
    },
    
    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    
