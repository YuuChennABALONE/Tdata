[
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API BoolBRepCut() @details Only set the type of boolean operation to cut @brief Default constructor",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API BoolBRepCut(const TopoShape& s1, const TopoShape& s2, bool isForward = true) @param isForward Cut s1 by s2 if true, and cut s2 by s1 if false @param s2 The tool shape @param s1 The argument shape @brief Compute the cut operation of two shapes",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API explicit BoolBRepDefeaturing(const TopoShape& shape) @param shape The shape that require remove feature @brief Construct from a shape.",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API BoolBRepFuse() @details Only set the type of boolean operation to fuse @brief Default constructor",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API BoolBRepFuse(const TopoShape& s1, const TopoShape& s2) @param s2 The tool shape @param s1 The argument shape @brief Compute the fuse of two shapes",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API BoolBRepSection(const TopoShape& s1, const TopoShape& s2, bool perfomNow = true) @param perfomNow If true, the operation is performed immediately; if false, the Build() function has to be called manually @param s2 The tool shape @param s1 The argument shape @brief Compute the section of two shapes",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API BoolBRepSection(const TopoShape& s1, const Plane& p1, bool perfomNow = true) @param perfomNow If true, the operation is performed immediately; if false, the Build() function has to be called manually @param p1 The tool plane @param s1 The argument shape @brief Special case: compute the section of a shape and an infinite plane",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API BoolBRepSection(const TopoShape& s1, const std::shared_ptr<Geom3Surface>& surface, bool perfomNow = true) @param perfomNow If true, the operation is performed immediately; if false, the Build() function has to be called manually @param surface The tool surface @param s1 The argument shape @brief Special case: compute the section of a shape and a surface",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API BoolBRepSection(const std::shared_ptr<Geom3Surface>& surface, const TopoShape& s2, bool perfomNow = true) @param perfomNow If true, the operation is performed immediately; if false, the Build() function has to be called manually @param s2 The tool shape @param surface The argument surface @brief Special case: compute the section of a surface and a shape",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API BoolBRepSection(const std::shared_ptr<Geom3Surface>& s1, const std::shared_ptr<Geom3Surface>& s2, bool perfomNow = true) @param perfomNow If true, the operation is performed immediately; if false, the Build() function has to be called manually @param s2 The tool surface @param s1 The argument surface @brief Special case: compute the section of two surfaces",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API void SimplifyResult(bool isUnfiyEdges = true, bool isUnifyFaces = true, double angularTol = Precision::Angular() @param angularTol The angular tolerance for checking parallel @param isUnifyFaces Set whether unify faces @param isUnfiyEdges Set whether unify edges @brief Simplify the boolean result, remove redundant edges and faces",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputtemplate<typename OtherScalar, typename OtherScalar2> AxisT(const PointT<OtherScalar, DIM>& point, const DirectionT<OtherScalar2, DIM>& dir)",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputtemplate<typename OtherScalar, typename OtherScalar2, typename OtherScalar3, int DIM2 = DIM, std::enable_if_t<DIM2 == 2, int> = 0> [[nodiscard]] bool IsCoaxial(const AxisT<OtherScalar, DIM>& other, const OtherScalar2& angtol, const OtherScalar3& distol)",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputtemplate<typename OtherScalar> AxisT& Mirror(const PointT<OtherScalar, DIM>& point)",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputtemplate<typename OtherScalar> [[nodiscard]] AxisT Mirrored(const PointT<OtherScalar, DIM>& point)",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputtemplate<typename OtherScalar, typename OtherScalar2> [[nodiscard]] AxisT Scaled(const PointT<OtherScalar, DIM> point, const OtherScalar2& scale)",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputtemplate<typename OtherScalar, typename OtherScalar2> AxisT& Translate(const PointT<OtherScalar, DIM>& p1, const PointT<OtherScalar2, DIM>& p2)",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAxisT() @details The default location is (0, 0, 0). In 2D, the default direction is (1, 0); in 3D, the default direction is (0, 0, 1). @brief Default constructor",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputtemplate<typename OtherScalar, typename OtherScalar2> AxisT(const PointT<OtherScalar, DIM>& point, const DirectionT<OtherScalar2, DIM>& dir)",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputtemplate<typename OtherScalar> void SetDirection(const DirectionT<OtherScalar, DIM>& dir)",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputtemplate<typename OtherScalar, typename OtherScalar2, typename OtherScalar3, int DIM2 = DIM, std::enable_if_t<DIM2 == 2, int> = 0> [[nodiscard]] bool IsCoaxial(const AxisT<OtherScalar, DIM>& other, const OtherScalar2& angtol, const OtherScalar3& distol)",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputtemplate<typename OtherScalar, typename OtherScalar2, typename OtherScalar3, int DIM2 = DIM, std::enable_if_t<DIM2 == 3, int> = 0> [[nodiscard]] bool IsCoaxial(const AxisT<OtherScalar, DIM>& other, const OtherScalar2& angtol, const OtherScalar3& distol)",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputtemplate<typename OtherScalar, typename OtherScalar2> [[nodiscard]] bool IsNormal(const AxisT<OtherScalar, DIM>& other, const OtherScalar2& tol)",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputtemplate<typename OtherScalar, typename OtherScalar2> [[nodiscard]] bool IsOpposite(const AxisT<OtherScalar, DIM>& other, const OtherScalar2& tol)",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputtemplate<typename OtherScalar, typename OtherScalar2> [[nodiscard]] bool IsParallel(const AxisT<OtherScalar, DIM>& other, const OtherScalar2& tol)",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputtemplate<typename OtherScalar> [[nodiscard]] double Angle(const AxisT<OtherScalar, DIM>& other)",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputtemplate<typename OtherScalar> AxisT& Mirror(const AxisT<OtherScalar, DIM>& axis)",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputtemplate<typename OtherScalar, int DIM2 = DIM, std::enable_if_t<DIM2 == 3, int> = 0> AxisT& Mirror(const FrameT<OtherScalar, DIM>& frame)",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputtemplate<typename OtherScalar> [[nodiscard]] AxisT Mirrored(const AxisT<OtherScalar, DIM>& axis)",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputtemplate<typename OtherScalar, int DIM2 = DIM, std::enable_if_t<DIM2 == 3, int> = 0> [[nodiscard]] AxisT Mirrored(const FrameT<OtherScalar, DIM>& frame)",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputtemplate<typename OtherScalar, typename OtherScalar2, int DIM2 = DIM, typename = typename std::enable_if_t<DIM2 == 3>> AxisT& Rotate(const AxisT<OtherScalar, DIM>& axis, const OtherScalar2& angle)",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputtemplate<typename OtherScalar, typename OtherScalar2> [[nodiscard]] AxisT Scaled(const PointT<OtherScalar, DIM> point, const OtherScalar2& scale)",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "input[[nodiscard]] const PointT<Scalar, DIM>& Location() @return The location @brief Get the location",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputtemplate<typename OtherScalar, typename OtherScalar2, typename OtherScalar3, int DIM2 = DIM, std::enable_if_t<DIM2 == 2, int> = 0> FrameT(const PointT<OtherScalar, DIM>& point, const DirectionT<OtherScalar2, DIM>& xdir, const DirectionT<OtherScalar3, DIM>& ydir)",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputtemplate<typename OtherScalar, typename OtherScalar2, int DIM2 = DIM, std::enable_if_t<DIM2 == 2, int> = 0> FrameT(const PointT<OtherScalar, DIM>& point, const DirectionT<OtherScalar2, DIM>& xdir, bool isright = true)",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputtemplate<typename OtherScalar, int DIM2 = DIM, std::enable_if_t<DIM2 == 2, int> = 0> explicit FrameT(const AxisT<OtherScalar, DIM>& axis, bool isright = true)",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputtemplate<typename OtherScalar, int DIM2 = DIM, std::enable_if_t<DIM2 == 2, int> = 0> void SetXAxis(const AxisT<OtherScalar, DIM>& axis)",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputtemplate<typename OtherScalar, int DIM2 = DIM, std::enable_if_t<DIM2 == 2, int> = 0> void SetYAxis(const AxisT<OtherScalar, DIM>& axis)",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputtemplate<typename OtherScalar, int DIM2 = DIM, std::enable_if_t<DIM2 == 2, int> = 0> void SetXDirection(const DirectionT<OtherScalar, DIM>& x)",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputtemplate<typename OtherScalar, int DIM2 = DIM, std::enable_if_t<DIM2 == 2, int> = 0> void SetYDirection(const DirectionT<OtherScalar, DIM>& y)",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputtemplate<int DIM2 = DIM, typename = typename std::enable_if_t<DIM2 >= 1>> [[nodiscard]] const DirectionT<Scalar, DIM>& XDirection()",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputtemplate<int DIM2 = DIM, typename = typename std::enable_if_t<DIM2 >= 2>> [[nodiscard]] const DirectionT<Scalar, DIM>& YDirection()",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputtemplate<typename OtherScalar> FrameT& Mirror(const PointT<OtherScalar, DIM>& point)",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputtemplate<typename OtherScalar> [[nodiscard]] FrameT Mirrored(const PointT<OtherScalar, DIM>& point)",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputtemplate<typename OtherScalar> [[nodiscard]] FrameT Mirrored(const AxisT<OtherScalar, DIM>& a)",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputtemplate<typename OtherScalar, typename OtherScalar2, int DIM2 = DIM, typename = typename std::enable_if_t<DIM2 == 2>> FrameT& Rotate(const PointT<OtherScalar, DIM>& point, const OtherScalar2& angle)",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputtemplate<typename OtherScalar, typename OtherScalar2, int DIM2 = DIM, typename = typename std::enable_if_t<DIM2 == 2>> [[nodiscard]] FrameT Rotated(const PointT<OtherScalar, DIM>& point, const OtherScalar2& angle)",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputtemplate<typename OtherScalar, typename OtherScalar2> [[nodiscard]] FrameT Scaled(const PointT<OtherScalar, DIM>& point, const OtherScalar2& scale)",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputtemplate<typename OtherScalar> [[nodiscard]] FrameT Translated(const VectorT<OtherScalar, DIM>& vec)",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputtemplate<typename OtherScalar, typename OtherScalar2> [[nodiscard]] FrameT Translated(const PointT<OtherScalar, DIM>& p1, const PointT<OtherScalar2, DIM>& p2)",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API BoolBRepCut() @details Only set the type of boolean operation to cut @brief Default constructor",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API BoolBRepCut(const TopoShape& s1, const TopoShape& s2, bool isForward = true) @param isForward Cut s1 by s2 if true, and cut s2 by s1 if false @param s2 The tool shape @param s1 The argument shape @brief Compute the cut operation of two shapes",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API BoolBRepDefeaturing() @brief Default constructor",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API explicit BoolBRepDefeaturing(const TopoShape& shape) @param shape The shape that require remove feature @brief Construct from a shape.",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API BoolBRepFuse() @details Only set the type of boolean operation to fuse @brief Default constructor",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API BoolBRepFuse(const TopoShape& s1, const TopoShape& s2) @param s2 The tool shape @param s1 The argument shape @brief Compute the fuse of two shapes",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "input[[nodiscard]] const PointT<Scalar, DIM>& Location() @return The location @brief Get the location",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputFrameT() @details The default frame is the standard orthogonal frame @brief Default constructor",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputtemplate<typename OtherScalar, typename OtherScalar2, typename OtherScalar3, int DIM2 = DIM, std::enable_if_t<DIM2 == 2, int> = 0> FrameT(const PointT<OtherScalar, DIM>& point, const DirectionT<OtherScalar2, DIM>& xdir, const DirectionT<OtherScalar3, DIM>& ydir)",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputtemplate<typename OtherScalar, typename OtherScalar2, int DIM2 = DIM, std::enable_if_t<DIM2 == 2, int> = 0> FrameT(const PointT<OtherScalar, DIM>& point, const DirectionT<OtherScalar2, DIM>& xdir, bool isright = true)",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputtemplate<typename OtherScalar, int DIM2 = DIM, std::enable_if_t<DIM2 == 2, int> = 0> explicit FrameT(const AxisT<OtherScalar, DIM>& axis, bool isright = true)",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputtemplate<typename OtherScalar, typename OtherScalar2, typename OtherScalar3, int DIM2 = DIM, std::enable_if_t<DIM2 == 3, int> = 0> FrameT(const PointT<OtherScalar, DIM>& point, const DirectionT<OtherScalar2, DIM>& normal, const DirectionT<OtherScalar3, DIM>& x)",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputtemplate<typename OtherScalar, typename OtherScalar2, int DIM2 = DIM, std::enable_if_t<DIM2 == 3, int> = 0> FrameT(const PointT<OtherScalar, DIM>& point, const DirectionT<OtherScalar2, DIM>& dir)",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputtemplate<typename OtherScalar, int DIM2 = DIM, typename = typename std::enable_if_t<DIM2 == 3>> void SetDirection(const DirectionT<OtherScalar, DIM>& dir)",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputtemplate<typename OtherScalar, int DIM2 = DIM, std::enable_if_t<DIM2 == 3, int> = 0> void SetXDirection(const DirectionT<OtherScalar, DIM>& x)",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputtemplate<typename OtherScalar, int DIM2 = DIM, std::enable_if_t<DIM2 == 3, int> = 0> void SetYDirection(const DirectionT<OtherScalar, DIM>& y)",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputtemplate<int DIM2 = DIM, typename = typename std::enable_if_t<DIM2 == 3>> [[nodiscard]] AxisT<Scalar, DIM> Axis()",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputtemplate<int DIM2 = DIM, typename = typename std::enable_if_t<DIM2 == 3>> [[nodiscard]] const DirectionT<Scalar, DIM>& Direction()",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputtemplate<int DIM2 = DIM, typename = typename std::enable_if_t<DIM2 >= 1>> [[nodiscard]] const DirectionT<Scalar, DIM>& XDirection()",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputtemplate<typename OtherScalar, typename OtherScalar2, typename OtherScalar3, int DIM2 = DIM, typename = typename std::enable_if_t<DIM2 == 3>> [[nodiscard]] bool IsCoplanar(const FrameT<OtherScalar, DIM>& other, const OtherScalar2& distol, const OtherScalar3& angtol)",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputtemplate<typename OtherScalar, typename OtherScalar2, typename OtherScalar3, int DIM2 = DIM, typename = typename std::enable_if_t<DIM2 == 3>> [[nodiscard]] bool IsCoplanar(const AxisT<OtherScalar, DIM>& a, const OtherScalar2& distol, const OtherScalar3& angtol)",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputtemplate<typename OtherScalar> FrameT& Mirror(const PointT<OtherScalar, DIM>& point)",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputtemplate<typename OtherScalar> FrameT& Mirror(const AxisT<OtherScalar, DIM>& a)",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputtemplate<typename OtherScalar, int DIM2 = DIM, std::enable_if_t<DIM2 == 3, int> = 0> FrameT& Mirror(const FrameT<OtherScalar, DIM>& frame)",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputtemplate<typename OtherScalar> [[nodiscard]] FrameT Mirrored(const PointT<OtherScalar, DIM>& point)",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputtemplate<typename OtherScalar> [[nodiscard]] FrameT Mirrored(const AxisT<OtherScalar, DIM>& a)",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputtemplate<typename OtherScalar, int DIM2 = DIM, std::enable_if_t<DIM2 == 3, int> = 0> [[nodiscard]] FrameT Mirrored(const FrameT<OtherScalar, DIM>& frame)",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputtemplate<typename OtherScalar, typename OtherScalar2, int DIM2 = DIM, typename = typename std::enable_if_t<DIM2 == 3>> FrameT& Rotate(const AxisT<OtherScalar, DIM>& a, const OtherScalar2& angle)",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputtemplate<typename OtherScalar, typename OtherScalar2, int DIM2 = DIM, typename = typename std::enable_if_t<DIM2 == 2>> [[nodiscard]] FrameT Rotated(const PointT<OtherScalar, DIM>& point, const OtherScalar2& angle)",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputtemplate<typename OtherScalar, typename OtherScalar2, int DIM2 = DIM, typename = typename std::enable_if_t<DIM2 == 3>> [[nodiscard]] FrameT Rotated(const AxisT<OtherScalar, DIM>& a, const OtherScalar2& angle)",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputtemplate<typename OtherScalar, typename OtherScalar2> FrameT& Scale(const PointT<OtherScalar, DIM>& point, const OtherScalar2& scale)",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputtemplate<typename OtherScalar, typename OtherScalar2> [[nodiscard]] FrameT Scaled(const PointT<OtherScalar, DIM>& point, const OtherScalar2& scale)",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputtemplate<typename OtherScalar> FrameT& Translate(const VectorT<OtherScalar, DIM>& vec)",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputtemplate<typename OtherScalar> explicit DirectionT(const VectorT<OtherScalar, DIM>& vec)",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputtemplate<typename OtherScalar> explicit DirectionT(const CoordT<OtherScalar, DIM>& v)",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputtemplate<typename... T> explicit DirectionT(T... vs)",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputtemplate<typename OtherScalar, typename OtherScalar2> [[nodiscard]] bool IsEqual(const DirectionT<OtherScalar, DIM>& other, const OtherScalar2& tol)",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputtemplate<typename OtherScalar, int DIM2 = DIM, std::enable_if_t<DIM2 == 2, int> = 0> [[nodiscard]] auto Angle(const DirectionT<OtherScalar, DIM>& other)",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputtemplate<typename OtherScalar> [[nodiscard]] auto Cross(const DirectionT<OtherScalar, DIM>& other)",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputtemplate<typename OtherScalar> DirectionT& Mirror(const DirectionT<OtherScalar, DIM>& dir)",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputtemplate<typename OtherScalar> DirectionT& Mirror(const AxisT<OtherScalar, DIM>& axis)",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputtemplate<typename OtherScalar> [[nodiscard]] DirectionT Mirrored(const DirectionT<OtherScalar, DIM>& dir)",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputtemplate<typename OtherScalar> [[nodiscard]] DirectionT Mirrored(const AxisT<OtherScalar, DIM>& axis)",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputtemplate<typename OtherScalar, int DIM2 = DIM, typename = typename std::enable_if_t<DIM2 == 2>> DirectionT& Rotate(const OtherScalar& angle)",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputtemplate<typename OtherScalar, int DIM2 = DIM, typename = typename std::enable_if_t<DIM2 == 2>> [[nodiscard]] DirectionT Rotated(const OtherScalar& angle)",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputDirectionT() @details Default direction is (1, 0, ... , 0) @brief Default constructor",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputtemplate<typename OtherScalar> explicit DirectionT(const VectorT<OtherScalar, DIM>& vec)",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputtemplate<typename OtherScalar> explicit DirectionT(const CoordT<OtherScalar, DIM>& v)",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputtemplate<typename... T> explicit DirectionT(T... vs)",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputtemplate<typename... T> void SetCoord(T... vs)",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputtemplate<typename OtherScalar, typename = typename std::enable_if_t<DIM >= 4 && std::is_convertible_v<OtherScalar, Scalar>>> void SetW(const OtherScalar& w)",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputtemplate<typename OtherScalar, typename OtherScalar2> [[nodiscard]] bool IsEqual(const DirectionT<OtherScalar, DIM>& other, const OtherScalar2& tol)",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputtemplate<typename OtherScalar, typename OtherScalar2> [[nodiscard]] bool IsNormal(const DirectionT<OtherScalar, DIM>& other, const OtherScalar2& tol)",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputtemplate<typename OtherScalar, typename OtherScalar2> [[nodiscard]] bool IsOpposite(const DirectionT<OtherScalar, DIM>& other, const OtherScalar2& tol)",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputtemplate<typename OtherScalar, typename OtherScalar2> [[nodiscard]] bool IsParallel(const DirectionT<OtherScalar, DIM>& other, const OtherScalar2& tol)",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputtemplate<typename OtherScalar, int DIM2 = DIM, std::enable_if_t<DIM2 == 3, int> = 0> [[nodiscard]] auto Angle(const DirectionT<OtherScalar, DIM>& other)",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputtemplate<typename OtherScalar, typename OtherScalar2, int DIM2 = DIM, typename = typename std::enable_if_t<DIM2 == 3>> [[nodiscard]] auto AngleWithRef(const DirectionT<OtherScalar, DIM>& other, const DirectionT<OtherScalar2, DIM>& ref)",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputtemplate<typename OtherScalar> [[nodiscard]] auto Cross(const DirectionT<OtherScalar, DIM>& other)",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputtemplate<typename OtherScalar> DirectionT& Mirror(const DirectionT<OtherScalar, DIM>& dir)",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputtemplate<typename OtherScalar> DirectionT& Mirror(const AxisT<OtherScalar, DIM>& axis)",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputtemplate<typename OtherScalar, int DIM2 = DIM, std::enable_if_t<DIM2 == 3, int> = 0> DirectionT& Mirror(const FrameT<OtherScalar, DIM>& frame)",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputtemplate<typename OtherScalar> [[nodiscard]] DirectionT Mirrored(const AxisT<OtherScalar, DIM>& axis)",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputtemplate<typename OtherScalar, int DIM2 = DIM, std::enable_if_t<DIM2 == 3, int> = 0> [[nodiscard]] DirectionT Mirrored(const FrameT<OtherScalar, DIM>& frame)",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputtemplate<typename OtherScalar, typename OtherScalar2, int DIM2 = DIM, typename = typename std::enable_if_t<DIM2 == 3>> [[nodiscard]] DirectionT Rotated(const AxisT<OtherScalar, DIM>& axis, const OtherScalar2& angle)",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputtemplate<typename... T> explicit VectorT(T... vs)",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputtemplate<typename OtherScalar, typename OtherScalar2> VectorT(const PointT<OtherScalar, DIM>& p1, const PointT<OtherScalar2, DIM>& p2)",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputtemplate<typename OtherScalar, int DIM2 = DIM, std::enable_if_t<DIM2 == 2, int> = 0> [[nodiscard]] auto Angle(const VectorT<OtherScalar, DIM>& other)",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputtemplate<typename OtherScalar> [[nodiscard]] auto Cross(const VectorT<OtherScalar, DIM>& other)",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputtemplate<typename OtherScalar> VectorT& Mirror(const VectorT<OtherScalar, DIM>& p)",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputtemplate<typename OtherScalar> VectorT& Mirror(const AxisT<OtherScalar, DIM>& axis)",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputtemplate<typename OtherScalar> [[nodiscard]] VectorT Mirrored(const VectorT<OtherScalar, DIM>& p)",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputtemplate<typename OtherScalar> [[nodiscard]] VectorT Mirrored(const AxisT<OtherScalar, DIM>& axis)",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputtemplate<typename OtherScalar, int DIM2 = DIM, typename = typename std::enable_if_t<DIM2 == 2>> VectorT& Rotate(const OtherScalar& angle)",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputtemplate<typename OtherScalar, int DIM2 = DIM, typename = typename std::enable_if_t<DIM2 == 2>> [[nodiscard]] VectorT Rotated(const OtherScalar& angle)",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "input[[nodiscard]] auto Norm() @return The norm of vector @brief Get the norm of vector",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputVectorT() @details The default vector is (0, 0, ..., 0) @brief The default constructor",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputtemplate<typename OtherScalar> explicit VectorT(const DirectionT<OtherScalar, DIM>& dir)",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputtemplate<typename OtherScalar> explicit VectorT(const CoordT<OtherScalar, DIM>& v)",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputtemplate<typename... T> explicit VectorT(T... vs)",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputtemplate<typename OtherScalar, typename OtherScalar2> VectorT(const PointT<OtherScalar, DIM>& p1, const PointT<OtherScalar2, DIM>& p2)",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputtemplate<typename... T> void SetCoord(T... vs)",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputtemplate<typename OtherScalar> void SetCoord(const CoordT<OtherScalar, DIM>& v)",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputtemplate<typename OtherScalar, typename OtherScalar2, typename OtherScalar3> [[nodiscard]] bool IsEqual(const VectorT<OtherScalar, DIM>& other, const OtherScalar2& tolDis, const OtherScalar3& tolAng)",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputtemplate<typename OtherScalar, typename OtherScalar2> [[nodiscard]] bool IsNormal(const VectorT<OtherScalar, DIM>& other, const OtherScalar2& tol)",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputtemplate<typename OtherScalar, typename OtherScalar2> [[nodiscard]] bool IsOpposite(const VectorT<OtherScalar, DIM>& other, const OtherScalar2& tol)",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputtemplate<typename OtherScalar, typename OtherScalar2> [[nodiscard]] bool IsParallel(const VectorT<OtherScalar, DIM>& other, const OtherScalar2& tol)",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputtemplate<typename OtherScalar, int DIM2 = DIM, std::enable_if_t<DIM2 == 3, int> = 0> [[nodiscard]] auto Angle(const VectorT<OtherScalar, DIM>& other)",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputtemplate<typename OtherScalar, typename OtherScalar2, int DIM2 = DIM, typename = typename std::enable_if_t<DIM2 == 3>> [[nodiscard]] Scalar AngleWithRef(const VectorT<OtherScalar, DIM>& other, const VectorT<OtherScalar2, DIM>& ref)",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "input[[nodiscard]] double SquaredNorm() @return The squared norm of vector @brief Get the squared norm of vector",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputtemplate<typename OtherScalar> [[nodiscard]] auto Cross(const VectorT<OtherScalar, DIM>& other)",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputVectorT& Normalize() @return The reference to self @brief Normalize the vector",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "input[[nodiscard]] VectorT Normalized() @return The normalized vector @brief Get the normalized vector",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputtemplate<typename OtherScalar> VectorT& Mirror(const VectorT<OtherScalar, DIM>& p)",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputtemplate<typename OtherScalar> VectorT& Mirror(const AxisT<OtherScalar, DIM>& axis)",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputtemplate<typename OtherScalar, int DIM2 = DIM, std::enable_if_t<DIM2 == 3, int> = 0> VectorT& Mirror(const FrameT<OtherScalar, DIM>& frame)",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputtemplate<typename OtherScalar> [[nodiscard]] VectorT Mirrored(const VectorT<OtherScalar, DIM>& p)",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputtemplate<typename OtherScalar> [[nodiscard]] VectorT Mirrored(const AxisT<OtherScalar, DIM>& axis)",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputtemplate<typename OtherScalar, int DIM2 = DIM, std::enable_if_t<DIM2 == 3, int> = 0> [[nodiscard]] VectorT Mirrored(const FrameT<OtherScalar, DIM>& frame)",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputtemplate<typename OtherScalar, typename OtherScalar2, int DIM2 = DIM, typename = typename std::enable_if_t<DIM2 == 3>> VectorT& Rotate(const AxisT<OtherScalar, DIM>& axis, const OtherScalar2& angle)",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputtemplate<typename OtherScalar, typename OtherScalar2, int DIM2 = DIM, typename = typename std::enable_if_t<DIM2 == 3>> [[nodiscard]] VectorT Rotated(const AxisT<OtherScalar, DIM>& axis, const OtherScalar2& angle)",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputtemplate<typename OtherScalar> [[nodiscard]] VectorT Scaled(const OtherScalar& scale)",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "input[[nodiscard]] const CoordT<Scalar, DIM>& TranslationPart() @return The translation part @brief Get the translation part of the transformation",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputtemplate<typename OtherScalar> void SetMirror(const PointT<OtherScalar, DIM>& point)",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputtemplate<typename OtherScalar> void SetMirror(const AxisT<OtherScalar, DIM>& axis)",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputtemplate<typename OtherScalar, typename OtherScalar2> void SetScale(const PointT<OtherScalar, DIM>& point, const OtherScalar2& s)",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputtemplate<typename OtherScalar, typename OtherScalar2, int DIM2 = DIM, typename = typename std::enable_if_t<DIM2 == 2>> void SetTransformation(const AxisT<OtherScalar, DIM>& axisFrom, const AxisT<OtherScalar2, DIM>& axisTo)",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputtemplate<typename OtherScalar, int DIM2 = DIM, typename = typename std::enable_if_t<DIM2 == 2>> void SetTransformation(const AxisT<OtherScalar, DIM>& axisTo)",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "input[[nodiscard]] Scalar ScaleFactor() @return The scale factor @brief Get the scale factor of the transformation",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "input[[nodiscard]] TransformationType Type() @return The transformation type @brief Get the type of the transformation",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "input[[nodiscard]] const CoordT<Scalar, DIM>& TranslationPart() @return The translation part @brief Get the translation part of the transformation",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputconstexpr TransformationT() @details The default transformation is the identity transformation @brief Default constructor",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputtemplate<typename OtherScalar, int OtherDIM> explicit TransformationT(const TransformationT<OtherScalar, OtherDIM>& trans)",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputtemplate<typename OtherScalar> void SetMirror(const PointT<OtherScalar, DIM>& point)",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputtemplate<typename OtherScalar> void SetMirror(const AxisT<OtherScalar, DIM>& axis)",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputtemplate<typename OtherScalar, int DIM2 = DIM, std::enable_if_t<DIM2 == 3, int> = 0> void SetMirror(const FrameT<OtherScalar, DIM>& frame)",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputtemplate<typename OtherScalar, typename OtherScalar2, int DIM2 = DIM, typename = typename std::enable_if_t<DIM2 == 2>> void SetRotation(const PointT<OtherScalar, DIM>& point, const OtherScalar2& angle)",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputtemplate<typename OtherScalar, typename OtherScalar2, int DIM2 = DIM, typename = typename std::enable_if_t<DIM2 == 3>> void SetRotation(const AxisT<OtherScalar, DIM>& axis, const OtherScalar2& angle)",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputtemplate<typename OtherScalar, int DIM2 = DIM, typename = typename std::enable_if_t<DIM2 == 3>> void SetRotation(const QuaternionT<OtherScalar>& q)",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputtemplate<typename OtherScalar, int DIM2 = DIM, typename = typename std::enable_if_t<DIM2 == 3>> void SetRotationPart(const QuaternionT<OtherScalar>& q)",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputtemplate<typename OtherScalar, typename OtherScalar2> void SetScale(const PointT<OtherScalar, DIM>& point, const OtherScalar2& s)",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputtemplate<typename OtherScalar, typename OtherScalar2, int DIM2 = DIM, typename = typename std::enable_if_t<DIM2 == 3>> void SetDisplacement(const FrameT<OtherScalar, DIM>& frameFrom, const FrameT<OtherScalar2, DIM>& frameTo)",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputtemplate<typename OtherScalar, typename OtherScalar2, int DIM2 = DIM, typename = typename std::enable_if_t<DIM2 == 3>> void SetTransformation(const FrameT<OtherScalar, DIM>& frameFrom, const FrameT<OtherScalar2, DIM>& frameTo)",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputtemplate<typename OtherScalar, int DIM2 = DIM, typename = typename std::enable_if_t<DIM2 == 3>> void SetTransformation(const FrameT<OtherScalar, DIM>& frameTo)",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputtemplate<typename OtherScalar> void SetTranslation(const VectorT<OtherScalar, DIM>& vec)",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputtemplate<typename OtherScalar, typename OtherScalar2> void SetTranslation(const PointT<OtherScalar, DIM>& p1, const PointT<OtherScalar2, DIM>& p2)",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputtemplate<typename OtherScalar> void SetTranslationPart(const VectorT<OtherScalar, DIM>& vec)",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputvoid SetType(const TransformationType& t) @param t The new type of transformation @brief Set the type of transformation",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "input[[nodiscard]] Scalar ScaleFactor() @return The scale factor @brief Get the scale factor of the transformation",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputtemplate<typename OtherScalar, typename OtherScalar2, int DIM2 = DIM, typename = typename std::enable_if_t<DIM2 == 3>> void GetRotation(CoordT<OtherScalar, DIM>& axis, OtherScalar2& angle)",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "input[[nodiscard]] const MatrixT<Scalar, DIM, DIM>& HVectorialPart() @return The homogeneous matrix @brief Get the homogeneous vectorial part of the transformation, i.e. the rotation matrix",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputTransformationT& Invert() @return The reference to self @brief Invert the transformation",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputtemplate<typename OtherScalar> TransformationT& LeftMultiply(const TransformationT<OtherScalar, DIM>& other)",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputtemplate<typename OtherScalar> [[nodiscard]] TransformationT LeftMultiplied(const TransformationT<OtherScalar, DIM>& other)",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "input[[nodiscard]] TransformationT Powered(int power) @return The power of transformation @param power The exponential @brief Get the power of transformation",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputtemplate<typename OtherScalar> void Transform(CoordT<OtherScalar, DIM>& coord)",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputtemplate<typename OtherScalar> PointT& Mirror(const PointT<OtherScalar, DIM>& p)",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputtemplate<typename OtherScalar> PointT& Mirror(const AxisT<OtherScalar, DIM>& axis)",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputtemplate<typename OtherScalar> [[nodiscard]] PointT Mirrored(const PointT<OtherScalar, DIM>& p)",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputtemplate<typename OtherScalar> [[nodiscard]] PointT Mirrored(const AxisT<OtherScalar, DIM>& axis)",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputtemplate<typename OtherScalar, typename OtherScalar2, int DIM2 = DIM, typename = typename std::enable_if_t<DIM2 == 2>> [[nodiscard]] PointT Rotated(const PointT<OtherScalar, DIM>& point, const OtherScalar2& angle)",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputtemplate<typename OtherScalar, typename OtherScalar2> [[nodiscard]] bool IsEqual(const PointT<OtherScalar, DIM>& other, const OtherScalar2& tol)",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputtemplate<typename OtherScalar> [[nodiscard]] auto Distance(const PointT<OtherScalar, DIM>& other)",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputtemplate<typename OtherScalar> [[nodiscard]] auto SquaredDistance(const PointT<OtherScalar, DIM>& other)",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputtemplate<typename OtherScalar> PointT& Mirror(const PointT<OtherScalar, DIM>& p)",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputtemplate<typename OtherScalar> PointT& Mirror(const AxisT<OtherScalar, DIM>& axis)",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputtemplate<typename OtherScalar, int DIM2 = DIM, std::enable_if_t<DIM2 == 3, int> = 0> PointT& Mirror(const FrameT<OtherScalar, DIM>& frame)",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputtemplate<typename OtherScalar> [[nodiscard]] PointT Mirrored(const AxisT<OtherScalar, DIM>& axis)",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputtemplate<typename OtherScalar, int DIM2 = DIM, std::enable_if_t<DIM2 == 3, int> = 0> [[nodiscard]] PointT Mirrored(const FrameT<OtherScalar, DIM>& frame)",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputtemplate<typename OtherScalar, typename OtherScalar2, int DIM2 = DIM, typename = typename std::enable_if_t<DIM2 == 3>> PointT& Rotate(const AxisT<OtherScalar, DIM>& axis, const OtherScalar2& angle)",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputtemplate<typename OtherScalar, typename OtherScalar2, int DIM2 = DIM, typename = typename std::enable_if_t<DIM2 == 3>> [[nodiscard]] PointT Rotated(const AxisT<OtherScalar, DIM>& axis, const OtherScalar2& angle)",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputtemplate<typename OtherScalar> [[nodiscard]] PointT Translated(const VectorT<OtherScalar, DIM>& vec)",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API MakeFace(const std::shared_ptr<Geom3Surface>& s, double tolDegen) @param tolDegen The tolerance @param s The surface @brief Construct from a surface with tolerance for degenerated edges",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API explicit MakeFace(const TopoWire& w, bool onlyPlane = false) @param onlyPlane If true, the surface will be a plane @param w The wire @brief Construct from a wire",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API MakeFace(const Plane& p, const TopoWire& w, bool inside = true) @param inside Whether the face is inside the wire @param w The wire @param p The plane @brief Construct from a plane and a wire",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API MakeFace(const Cylinder& c, const TopoWire& w, bool inside = true) @param inside Whether the face is inside the wire @param w The wire @param c The cylinder @brief Construct from a cylinder and a wire",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API MakeFace(const Cone& c, const TopoWire& w, bool inside = true) @param inside Whether the face is inside the wire @param w The wire @param c The cone @brief Construct from a cone and a wire",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API MakeFace(const Sphere& s, const TopoWire& w, bool inside = true) @param inside Whether the face is inside the wire @param w The wire @param s The sphere @brief Construct from a sphere and a wire",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API MakeFace(const Torus& t, const TopoWire& w, bool inside = true) @param inside Whether the face is inside the wire @param w The wire @param t The torus @brief Construct from a torus and a wire",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API MakeFace(const std::shared_ptr<Geom3Surface>& s, const TopoWire& w, bool inside = true) @param inside Whether the face is inside the wire @param w The wire @param s The surface @brief Construct from a surface and a wire",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API explicit MakeFace(const TopoWire& w, bool onlyPlane = false) @param onlyPlane If true, the surface will be a plane @param w The wire @brief Construct from a wire",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API GccCircle3Tangent(const GccQualifiedCurve& qualified1, const GccQualifiedCurve& qualified2, const GccQualifiedCurve& qualified3, double tolerance, double parameter1, double parameter2, double parameter3) @param parameter3 The initial guess of the parameter on the third curve @param parameter2 The initial guess of the parameter on the second curve @param parameter1 The initial guess of the parameter on the first curve @param tolerance The tolerance @param qualified3 The third curve @param qualified2 The second curve @param qualified1 The first curve @brief Construct a circle tangent to three curves",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API GccCircle3Tangent(const GccQualifiedCurve& qualified1, const GccQualifiedCurve& qualified2, const Point2& point, double tolerance, double parameter1, double parameter2) @param parameter2 The initial guess of the parameter on the second curve @param parameter1 The initial guess of the parameter on the first curve @param tolerance The tolerance @param point The point that the circle passes through @param qualified2 The second curve @param qualified1 The first curve @brief Construct a circle tangent to two curves and passing through a point",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API GccCircle3Tangent(const GccQualifiedCurve& qualified1, const Point2& point1, const Point2& point2, double tolerance, double parameter1) @param parameter1 The initial guess of the parameter on the curve @param tolerance The tolerance @param point2 The second point @param point1 The first point @param qualified1 The tangent curve @brief Construct a circle tangent to a curve and passing throught two points",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API GccCircle3Tangent(const Point2& point1, const Point2& point2, const Point2& point3, double tolerance) @param tolerance The tolerance @param point3 The third point @param point2 The second point @param point1 The first point @brief Construct a circle passing through three points",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API virtual void D1(double x, double& f, double& d) @param[out] d The function first derivative @param[out] f The function value @param[in] x The given parameter @brief Get the function first derivative at the given parameter",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API virtual std::shared_ptr<LawFunction> Trim(double fp, double lp, double tol) @return The new law @param tol The given tolerance, not all laws use this parameter @param lp The second parameter @param fp The first parameter @brief Get the trimmed law of this",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputexplicit Conic2Constraint(const Point2& point) @param point The point constraint @brief Construct from a point constraint",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API MakeConic2FromConstraints(const Conic2Constraint& startConstraint, const Conic2Constraint& endConstraint, double parameter) @param parameter The parameter to determine type and shape of the conic, valid range is (0.0, 1.0): ellipse if (0.0, 0.5), parabola if {0.5}, hyperbola if (0.5, 1.0) @param endConstraint The end point and tangent @param startConstraint The start point and tangent @brief Build by ending points and tangents and a parameter",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API explicit MakeConic2FromConstraints(const std::vector<Conic2Constraint>& constraints) @param constraints The constraints of the conic. It is supported that the constraints contain 5 points, 4 points and 1 tangent, 3 points and 2 tangent @brief Build by point and tangent constraints. The number of constraints must be 5 in total and the start and the end point constraints are required",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API ComputePointsAbscissa(double tol, const Adaptor3Curve& c, double abscissa, double u0) @param u0 The starting parameter @param abscissa The arc length @param c The curve @param tol The tolerance @brief Compute the parameter of a point on a 3D curve with given arc length and a tolerance",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API ComputePointsAbscissa(double tol, const Adaptor2Curve& c, double abscissa, double u0) @param u0 The starting parameter @param abscissa The arc length @param c The curve @param tol The tolerance @brief Compute the parameter of a point on a 2D curve with given arc length and a tolerance",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API ComputePointsAbscissa(const Adaptor3Curve& c, double abscissa, double u0) @param u0 The starting parameter @param abscissa The arc length @param c The curve @brief Compute the parameter of a point on a 3D curve with given arc length",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API ComputePointsAbscissa(const Adaptor2Curve& c, double abscissa, double u0) @param u0 The starting parameter @param abscissa The arc length @param c The curve @brief Compute the parameter of a point on a 2D curve with given arc length",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API ComputePointsAbscissa(const Adaptor3Curve& c, double abscissa, double u0, double ui) @param ui The initial guess of the parameter @param u0 The starting parameter @param abscissa The arc length @param c The curve @brief Compute the parameter of a point on a 3D curve with given arc length and an initial guess",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API ComputePointsAbscissa(const Adaptor2Curve& c, double abscissa, double u0, double ui) @param ui The initial guess of the parameter @param u0 The starting parameter @param abscissa The arc length @param c The curve @brief Compute the parameter of a point on a 2D curve with given arc length and an initial guess",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API ComputePointsAbscissa(const Adaptor3Curve& c, double abscissa, double u0, double ui, double tol) @param tol The tolerance @param ui The initial guess of the parameter @param u0 The starting parameter @param abscissa The arc length @param c The curve @brief Compute the parameter of a point on a 3D curve with given arc length, an initial guess, and a tolerance",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API ComputePointsAbscissa(const Adaptor2Curve& c, double abscissa, double u0, double ui, double tol) @param tol The tolerance @param ui The initial guess of the parameter @param u0 The starting parameter @param abscissa The arc length @param c The curve @brief Compute the parameter of a point on a 2D curve with given arc length, an initial guess, and a tolerance",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API double Parameter() @return The parameter of the point @brief Get the parameter of the point",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API static double Length(const Adaptor3Curve& c, double tol) @return The length of a curve @param tol The tolerance @param c The curve @brief Compute the length of a 3D curve with a tolerance",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API static double Length(const Adaptor2Curve& c, double tol) @return The length of a curve @param tol The tolerance @param c The curve @brief Compute the length of a 2D curve with a tolerance",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API static double Length(const Adaptor3Curve& c, double u1, double u2) @return The length of a curve in a given interval @param u2 The last parameter @param u1 The first parameter @param c The curve @brief Compute the length of a 3D curve in a given interval",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API static double Length(const Adaptor2Curve& c, double u1, double u2) @return The length of a curve in a given interval @param u2 The last parameter @param u1 The first parameter @param c The curve @brief Compute the length of a 2D curve in a given interval",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API static double Length(const Adaptor3Curve& c, double u1, double u2, double tol) @return The length of a curve in a given interval @param tol The tolerance @param u2 The last parameter @param u1 The first parameter @param c The curve @brief Compute the length of a 3D curve in a given interval with a tolerance",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API static double Length(const Adaptor2Curve& c, double u1, double u2, double tol) @return The length of a curve in a given interval @param tol The tolerance @param u2 The last parameter @param u1 The first parameter @param c The curve @brief Compute the length of a 2D curve in a given interval with a tolerance",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API ComputePointsAbscissa(double tol, const Adaptor3Curve& c, double abscissa, double u0) @param u0 The starting parameter @param abscissa The arc length @param c The curve @param tol The tolerance @brief Compute the parameter of a point on a 3D curve with given arc length and a tolerance",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API ComputePointsAbscissa(double tol, const Adaptor2Curve& c, double abscissa, double u0) @param u0 The starting parameter @param abscissa The arc length @param c The curve @param tol The tolerance @brief Compute the parameter of a point on a 2D curve with given arc length and a tolerance",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API ComputePointsAbscissa(const Adaptor3Curve& c, double abscissa, double u0) @param u0 The starting parameter @param abscissa The arc length @param c The curve @brief Compute the parameter of a point on a 3D curve with given arc length",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API ComputePointsAbscissa(const Adaptor2Curve& c, double abscissa, double u0) @param u0 The starting parameter @param abscissa The arc length @param c The curve @brief Compute the parameter of a point on a 2D curve with given arc length",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API ComputePointsAbscissa(const Adaptor3Curve& c, double abscissa, double u0, double ui) @param ui The initial guess of the parameter @param u0 The starting parameter @param abscissa The arc length @param c The curve @brief Compute the parameter of a point on a 3D curve with given arc length and an initial guess",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API ComputePointsAbscissa(const Adaptor2Curve& c, double abscissa, double u0, double ui) @param ui The initial guess of the parameter @param u0 The starting parameter @param abscissa The arc length @param c The curve @brief Compute the parameter of a point on a 2D curve with given arc length and an initial guess",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API ComputePointsAbscissa(const Adaptor3Curve& c, double abscissa, double u0, double ui, double tol) @param tol The tolerance @param ui The initial guess of the parameter @param u0 The starting parameter @param abscissa The arc length @param c The curve @brief Compute the parameter of a point on a 3D curve with given arc length, an initial guess, and a tolerance",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API ComputePointsAbscissa(const Adaptor2Curve& c, double abscissa, double u0, double ui, double tol) @param tol The tolerance @param ui The initial guess of the parameter @param u0 The starting parameter @param abscissa The arc length @param c The curve @brief Compute the parameter of a point on a 2D curve with given arc length, an initial guess, and a tolerance",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API double Parameter() @return The parameter of the point @brief Get the parameter of the point",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API ComputePointsAbscissa(double tol, const Adaptor3Curve& c, double abscissa, double u0) @param u0 The starting parameter @param abscissa The arc length @param c The curve @param tol The tolerance @brief Compute the parameter of a point on a 3D curve with given arc length and a tolerance",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API ComputePointsAbscissa(double tol, const Adaptor2Curve& c, double abscissa, double u0) @param u0 The starting parameter @param abscissa The arc length @param c The curve @param tol The tolerance @brief Compute the parameter of a point on a 2D curve with given arc length and a tolerance",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API ComputePointsAbscissa(const Adaptor3Curve& c, double abscissa, double u0) @param u0 The starting parameter @param abscissa The arc length @param c The curve @brief Compute the parameter of a point on a 3D curve with given arc length",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API ComputePointsAbscissa(const Adaptor2Curve& c, double abscissa, double u0) @param u0 The starting parameter @param abscissa The arc length @param c The curve @brief Compute the parameter of a point on a 2D curve with given arc length",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API ComputePointsAbscissa(const Adaptor3Curve& c, double abscissa, double u0, double ui) @param ui The initial guess of the parameter @param u0 The starting parameter @param abscissa The arc length @param c The curve @brief Compute the parameter of a point on a 3D curve with given arc length and an initial guess",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API ComputePointsAbscissa(const Adaptor2Curve& c, double abscissa, double u0, double ui) @param ui The initial guess of the parameter @param u0 The starting parameter @param abscissa The arc length @param c The curve @brief Compute the parameter of a point on a 2D curve with given arc length and an initial guess",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API ComputePointsAbscissa(const Adaptor3Curve& c, double abscissa, double u0, double ui, double tol) @param tol The tolerance @param ui The initial guess of the parameter @param u0 The starting parameter @param abscissa The arc length @param c The curve @brief Compute the parameter of a point on a 3D curve with given arc length, an initial guess, and a tolerance",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API ComputePointsAbscissa(const Adaptor2Curve& c, double abscissa, double u0, double ui, double tol) @param tol The tolerance @param ui The initial guess of the parameter @param u0 The starting parameter @param abscissa The arc length @param c The curve @brief Compute the parameter of a point on a 2D curve with given arc length, an initial guess, and a tolerance",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API double Parameter() @return The parameter of the point @brief Get the parameter of the point",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API static double Length(const Adaptor3Curve& c, double u1, double u2, double tol) @return The length of a curve in a given interval @param tol The tolerance @param u2 The last parameter @param u1 The first parameter @param c The curve @brief Compute the length of a 3D curve in a given interval with a tolerance",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API ComputePointsAbscissa(double tol, const Adaptor3Curve& c, double abscissa, double u0) @param u0 The starting parameter @param abscissa The arc length @param c The curve @param tol The tolerance @brief Compute the parameter of a point on a 3D curve with given arc length and a tolerance",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API ComputePointsAbscissa(double tol, const Adaptor2Curve& c, double abscissa, double u0) @param u0 The starting parameter @param abscissa The arc length @param c The curve @param tol The tolerance @brief Compute the parameter of a point on a 2D curve with given arc length and a tolerance",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API ComputePointsAbscissa(const Adaptor3Curve& c, double abscissa, double u0) @param u0 The starting parameter @param abscissa The arc length @param c The curve @brief Compute the parameter of a point on a 3D curve with given arc length",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API ComputePointsAbscissa(const Adaptor2Curve& c, double abscissa, double u0) @param u0 The starting parameter @param abscissa The arc length @param c The curve @brief Compute the parameter of a point on a 2D curve with given arc length",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API ComputePointsAbscissa(const Adaptor3Curve& c, double abscissa, double u0, double ui) @param ui The initial guess of the parameter @param u0 The starting parameter @param abscissa The arc length @param c The curve @brief Compute the parameter of a point on a 3D curve with given arc length and an initial guess",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API ComputePointsAbscissa(const Adaptor2Curve& c, double abscissa, double u0, double ui) @param ui The initial guess of the parameter @param u0 The starting parameter @param abscissa The arc length @param c The curve @brief Compute the parameter of a point on a 2D curve with given arc length and an initial guess",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API ComputePointsAbscissa(const Adaptor3Curve& c, double abscissa, double u0, double ui, double tol) @param tol The tolerance @param ui The initial guess of the parameter @param u0 The starting parameter @param abscissa The arc length @param c The curve @brief Compute the parameter of a point on a 3D curve with given arc length, an initial guess, and a tolerance",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API ComputePointsAbscissa(const Adaptor2Curve& c, double abscissa, double u0, double ui, double tol) @param tol The tolerance @param ui The initial guess of the parameter @param u0 The starting parameter @param abscissa The arc length @param c The curve @brief Compute the parameter of a point on a 2D curve with given arc length, an initial guess, and a tolerance",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API double Parameter() @return The parameter of the point @brief Get the parameter of the point",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API ComputePointsAbscissa(double tol, const Adaptor3Curve& c, double abscissa, double u0) @param u0 The starting parameter @param abscissa The arc length @param c The curve @param tol The tolerance @brief Compute the parameter of a point on a 3D curve with given arc length and a tolerance",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API ComputePointsAbscissa(double tol, const Adaptor3Curve& c, double abscissa, double u0) @param u0 The starting parameter @param abscissa The arc length @param c The curve @param tol The tolerance @brief Compute the parameter of a point on a 3D curve with given arc length and a tolerance",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API ComputePointsAbscissa(double tol, const Adaptor2Curve& c, double abscissa, double u0) @param u0 The starting parameter @param abscissa The arc length @param c The curve @param tol The tolerance @brief Compute the parameter of a point on a 2D curve with given arc length and a tolerance",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API ComputePointsAbscissa(const Adaptor3Curve& c, double abscissa, double u0) @param u0 The starting parameter @param abscissa The arc length @param c The curve @brief Compute the parameter of a point on a 3D curve with given arc length",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API ComputePointsAbscissa(const Adaptor2Curve& c, double abscissa, double u0) @param u0 The starting parameter @param abscissa The arc length @param c The curve @brief Compute the parameter of a point on a 2D curve with given arc length",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API ComputePointsAbscissa(const Adaptor3Curve& c, double abscissa, double u0, double ui) @param ui The initial guess of the parameter @param u0 The starting parameter @param abscissa The arc length @param c The curve @brief Compute the parameter of a point on a 3D curve with given arc length and an initial guess",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API ComputePointsAbscissa(const Adaptor2Curve& c, double abscissa, double u0, double ui) @param ui The initial guess of the parameter @param u0 The starting parameter @param abscissa The arc length @param c The curve @brief Compute the parameter of a point on a 2D curve with given arc length and an initial guess",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API ComputePointsAbscissa(const Adaptor3Curve& c, double abscissa, double u0, double ui, double tol) @param tol The tolerance @param ui The initial guess of the parameter @param u0 The starting parameter @param abscissa The arc length @param c The curve @brief Compute the parameter of a point on a 3D curve with given arc length, an initial guess, and a tolerance",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API ComputePointsAbscissa(const Adaptor2Curve& c, double abscissa, double u0, double ui, double tol) @param tol The tolerance @param ui The initial guess of the parameter @param u0 The starting parameter @param abscissa The arc length @param c The curve @brief Compute the parameter of a point on a 2D curve with given arc length, an initial guess, and a tolerance",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API double Parameter() @return The parameter of the point @brief Get the parameter of the point",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputGeom2Ellipse() @brief Default constructor",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API explicit Geom2Ellipse(const Ellipse2& e) @param e The ellipse @brief Construct from an ellipse",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API Geom2Ellipse(const Axis2& majorAxis, double major, double minor, bool isRight) @param isRight Is the local frame right-handed @param minor The minor radius @param major The major radius @param majorAxis The axis @brief Construct from an axis, a major radius and a minor radius",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API Geom2Ellipse(const Frame2& frame, double major, double minor) @param minor The minor radius @param major The major radius @param frame The local frame @brief Construct from a local frame, a major radius and a minor radius",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "input[[nodiscard]] AMCAX_API double FocalParameter() @return The focal parameter          Focal parameter = 2 * focalLength. @details The focal parameter of parabola is the distance from the focus to the directrix. @brief Get the focal parameter of the parabola",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "input[[nodiscard]] AMCAX_API double SemilatusRectum() @return The semilatus rectum          Semilatus rectum = 2 * focalLength @details The semilatus rectum of parabola is half of the length of the chord through a focus parallel to the directrix. @brief Get the semilatus rectum of the parabola",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API explicit Geom3Parabola(const Parabola3& p) @param p The parabola @brief Construct from a parabola",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API Geom3Parabola(const Frame3& frame, double focal) @param focal The focal length @param frame The local frame @brief Construct from a local frame and a focal length",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API Geom3Parabola(const Axis3& directrix, const Point3& focus) @param focus The focus @param directrix The directrix @brief Construct from a directrix and a focus",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API Geom2Hyperbola(const Axis2& axis, double major, double minor, bool isRight = true) @param isRight Is the local frame right-handed @param minor The minor radius @param major The major radius @param axis The axis @brief Construct from an axis, a major radius and a minor radius",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API Geom2Hyperbola(const Frame2& frame, double major, double minor) @param minor The minor radius @param major The major radius @param frame The local frame @brief Construct from a local frame, a major radius and a minor radius",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputGeom2Parabola() @brief Default constructor",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API Geom2Parabola(const Axis2& axis, double focal, bool isRight = true) @param isRight Is the local frame right-handed @param focal The focal length @param axis The axis @brief Construct from an axis and a focal length",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API Geom2Parabola(const Frame2& frame, double focal) @param focal The focal length @param frame The local frame @brief Construct from a local frame and a focal length",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API Geom2Parabola(const Axis2& directrix, const Point2& focus, bool isRight = true) @param isRight Is the local frame right-handed @param focus The focus @param directrix The directrix @brief Construct from a directrix and a focus",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API Geom3BSplineCurve(const std::vector<Point3>& pts, const std::vector<double>& weights, const std::vector<double>& knots, const std::vector<int>& multiplicities, int degree, bool isPeriodic = false, bool checkRational = true) @param checkRational To check whether the weights are rational @param isPeriodic Set the curve is periodic or not @param degree The degree of curve @param multiplicities The multiplicities @param knots The knots @param weights The weights @param pts The points @brief Construct a rational B spline curve from point, weights, knots and multiplicities with a given degree",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API Geom3BSplineSurface() @details A default surface is a unit square @brief Default constructor",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API Geom3BSplineSurface(const Array2<Point3>& pts, const std::vector<double>& uKnots, const std::vector<double>& vKnots, const std::vector<int>& uMults, const std::vector<int>& vMults, int uDegree, int vDegree, bool uPeriodic = false, bool vPeriodic = false) @param vPeriodic Set whether the surface is periodic along the v direction @param uPeriodic Set whether the surface is periodic along the u direction @param vDegree The v degree @param uDegree The u degree @param vMults The v multiplicities @param uMults The u multiplicities @param vKnots The v knots @param uKnots The u knots @param pts The poles @brief Construct a B spline surface from poles, knots and multiplicities",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API Geom3BSplineSurface(const Array2<Point3>& pts, const Array2<double>& weights, const std::vector<double>& uKnots, const std::vector<double>& vKnots, const std::vector<int>& uMults, const std::vector<int>& vMults, int uDegree, int vDegree, bool uPeriodic = false, bool vPeriodic = false) @param vPeriodic Set whether the surface is periodic along the v direction @param uPeriodic Set whether the surface is periodic along the u direction @param vDegree The v degree @param uDegree The u degree @param vMults The v multiplicities @param uMults The u multiplicities @param vKnots The v knots @param uKnots The u knots @param weights The weights @param pts The poles @brief Construct a rational B spline surface from poles, knots and multiplicities",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API void InsertUKnot(double u, int m, double parametricTolerance, bool add = true) @param add If true, the multiplicity is an incremental value; if false, the multiplicity is a final value @param parametricTolerance The tolerance of parameters @param m The multiplicity of the knot to be inserted @param u The knot to be inserted @brief Insert a u knot",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API Geom3ConicalSurface(const Frame3& frame, double r, double angle) @param angle The semi-angle @param r The reference radius @param frame The local frame @brief Construct from a local frame, a reference radius and a semi-angle",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "input[[nodiscard]] AMCAX_API Point3 Apex() @return The apex point @brief Get the apex of the cone",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "input[[nodiscard]] AMCAX_API double SemiAngle() @return The semi-angle @brief Get the semi-angle",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API Cone(const Frame3& frame, double r, double angle) @param angle The semi-angle @param r The reference radius @param frame The local frame @brief Construct from a local frame, a reference radius and a semi-angle",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API Cone& Scale(const Point3& point, double scale) @return The reference to self @param scale The scale value @param point The scaling center point @brief Scale the cone by a point",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputGeom3Ellipse() @brief Default constructor",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API explicit Geom3Ellipse(const Ellipse3& e) @param e The ellipse @brief Construct from an ellipse",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API Geom3Ellipse(const Frame3& frame, double major, double minor) @param minor The minor radius @param major The major radius @param frame The local frame @brief Construct from a local frame, a major radius and a minor radius",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API Geom3Ellipse(const Frame3& frame, double major, double minor) @param minor The minor radius @param major The major radius @param frame The local frame @brief Construct from a local frame, a major radius and a minor radius",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API explicit Geom3Hyperbola(const Hyperbola3& h) @param h The hyperbola @brief Construct from an hyperbola",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API Geom3Hyperbola(const Frame3& frame, double major, double minor) @param minor The minor radius @param major The major radius @param frame The local frame @brief Construct from a local frame, a major radius and a minor radius",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API void Coefficients(double& a, double& b, double& c, double& d) @param[out] a,b,c,d The coefficients @brief Get coefficients of algebraic representation: ax + by + cz + d = 0",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputPlane() Default constructor",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API explicit Plane(const Frame3& frame) @param frame The local frame @brief Construct from a local frame, XOY plane",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API Plane(const Point3& point, const Direction3& dir) @param dir The direction @param point The point @brief Construct from a point and a direction",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API Plane(double a, double b, double c, double d) @param a,b,c,d The coefficients @brief Construct from an algebraic representation: ax + by + cz + d = 0",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "input[[nodiscard]] AMCAX_API bool Contains(const Point3& point, double tol) @return True if the distance between the point and the plane is under the distance tolerance @param tol The distance tolerance @param point The point @brief Determines whether the plane contains a point under a tolerance or not",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API explicit GeomAPIIntCurveCurve2(const std::shared_ptr<Geom2Curve>& c1, double tol = 1.0e-6) @param tol The tolerance for computing self-intersection @param c1 The curve @brief Construct from one curve for finding self-intersections",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API static bool IsPlanarCurve(const std::shared_ptr<Geom3Curve>& c, Plane& plane, double tol = 1.0e-7) @return True if the curve is a planar curve @param tol The tolerance @param plane The plane found when the curve is planar curve @param c The input curve @details If the input curve, such as a line, is on more than one plane, it will return the plane in which any one is located @brief Check if a 3D curve is a planar curve, and if it is planar, find the plane",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API MakeArcOfCircle2d(const Point2& p1, const Vector2& v, const Point2& p2) @param p2 The end point @param v The tangent vector at p1 @param p1 The start point @brief Construct an arc of circle from two points p1, p2 and a tangent vector v at p1",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API MakeGeom3Ellipse(const Frame3& frame, double majorRadius, double minorRadius) @param minorRadius The minor radius @param majorRadius The major radius @param frame The local frame @brief Construct an ellipse from a local frame, a major radius and a minor radius",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API MakeGeom3Ellipse(const Point3& s1, const Point3& s2, const Point3& center) @param center The center point @param s2 The point on the minor axis @param s1 The point on the major axis @brief Construct an ellipse from two points on the major and minor axis, and a center point",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API static bool IsSolidBounded(const TopoSolid& s) @return True if the solid and the solid is bounded (The infinite point is outside); @param s The solid @brief Classify whether the solid is bounded (The infinite point is outside)",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API explicit BRepFaceClassifier(const TopoFace& f) @param f The input face @brief Construct from the face to be processed",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API void Perform(const Point2& p, double tol) @param tol The tolerance @param p The uv point @brief Classify a UV point on face with tolerance",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API static TopoShape FixShape(const TopoShape& shape, double prec, double maxTol) @return Fixed Shape @param maxTol The global max tolerance used when the algorithm needs to check the tolerance @param prec The global precision used when the algorithm needs to check the precision @param shape Input shape @brief Try to repair the shape to a valid shape",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API static bool Read(TopoShape& s, const std::string& file) @return True if the input process is succeed @param file The input file @param s The shape @brief Read a shape from a file",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "AMCAX_API static bool Write(const TopoShape& s, std::ostream& os, int format = 3) @return True if the",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "AMCAX_API static bool Write(const TopoShape& s, std::ostream& os, bool withTriangles, int format = 3) @return True if the",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "AMCAX_API static bool Write(const TopoShape& s, const std::string& file, int format = 3) @return True if the",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "AMCAX_API static bool Write(const TopoShape& s, const std::string& file, bool withTriangles, int format = 3) @return True if the",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API static bool Read(TopoShape& s, std::istream& is) @return True if the input process is succeed @param[in,out] is The input stream @param[out] s The shape @brief Read a shape from a stream",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputvoid SetRadius(double r) @param r The radius @brief Set the radius of the circle",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "input[[nodiscard]] double Radius() @return The radius @brief Get the radius",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "input[[nodiscard]] double Length() @return The length of the circle @brief Get the length of the circle",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "input[[nodiscard]] double Distance(const PointT<double, DIM>& p) @return The distance from the point to the circle @param p The point @brief Compute the distance from a point to the circle",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputvoid SetRadius(double r) @param r The radius @brief Set the radius of the circle",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "input[[nodiscard]] double Radius() @return The radius @brief Get the radius",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "input[[nodiscard]] double Distance(const PointT<double, DIM>& p) @return The distance from the point to the circle @param p The point @brief Compute the distance from a point to the circle",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "input[[nodiscard]] double SquaredDistance(const PointT<double, DIM>& p) @return The squared distance from the point to the circle @param p The point @brief Compute the squared distance from a point to the circle",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputCircleS& Scale(const PointT<double, DIM>& p, double scale) @return The reference to self @param scale The scale value @param p The scaling center point @brief Scale the circle by a center point",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "input[[nodiscard]] double Area() @return The area of the ellipse @brief Get the area of the ellipse",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputEllipseS& Scale(const PointT<double, DIM>& point, double scale) @return The reference to self @param scale The scale value @param point The scaling center point @brief Scale the ellipse by a center point",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputEllipseS& Transform(const TransformationT<double, DIM>& tr) @return The reference to self @param tr The transformation @brief Transform the ellipse",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "input[[nodiscard]] double Area() @return The area of the ellipse @brief Get the area of the ellipse",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "input[[nodiscard]] double FocalParameter() @return The focal parameter          Focal parameter = 2 * focalLength. @details The focal parameter of parabola is the distance from the focus to the directrix. @brief Get the focal parameter of the parabola",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "input[[nodiscard]] double SemilatusRectum() @return The semilatus rectum          Semilatus rectum = 2 * focalLength @details The semilatus rectum of parabola is half of the length of the chord through a focus parallel to the directrix. @brief Get the semilatus rectum of the parabola",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "input[[nodiscard]] double FocalParameter() @return The focal parameter          Focal parameter = 2 * focalLength. @details The focal parameter of parabola is the distance from the focus to the directrix. @brief Get the focal parameter of the parabola",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "input[[nodiscard]] double SemilatusRectum() @return The semilatus rectum          Semilatus rectum = 2 * focalLength @details The semilatus rectum of parabola is half of the length of the chord through a focus parallel to the directrix. @brief Get the semilatus rectum of the parabola",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "input[[nodiscard]] double FocalParameter() @return The focal parameter          Focal parameter = 2 * focalLength. @details The focal parameter of parabola is the distance from the focus to the directrix. @brief Get the focal parameter of the parabola",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "input[[nodiscard]] double SemilatusRectum() @return The semilatus rectum          Semilatus rectum = 2 * focalLength @details The semilatus rectum of parabola is half of the length of the chord through a focus parallel to the directrix. @brief Get the semilatus rectum of the parabola",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "input[[nodiscard]] double FocalParameter() @return The focal parameter          Focal parameter = 2 * focalLength. @details The focal parameter of parabola is the distance from the focus to the directrix. @brief Get the focal parameter of the parabola",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "input[[nodiscard]] double SemilatusRectum() @return The semilatus rectum          Semilatus rectum = 2 * focalLength @details The semilatus rectum of parabola is half of the length of the chord through a focus parallel to the directrix. @brief Get the semilatus rectum of the parabola",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "input[[nodiscard]] bool Contains(const PointT<double, DIM>& p, double tol) @return True if the point is on the line under the tolerance @param tol The tolerance @param p The point @brief Does the line contain a point under a distance tolerance",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "input[[nodiscard]] const PointT<double, DIM>& Location() @return The location of the line @brief Get the location point of the line",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "input[[nodiscard]] Derived Scaled(const PointT<double, DIM>& point, double scale) @return The scaled line @param scale The scale value @param point The scaling center point @brief Get the line scaled by a point",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputDerived& Translate(const VectorT<double, DIM>& vec) @return The reference to self @param vec The translation vector @brief Translate the line by a vector",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "input[[nodiscard]] Derived Translated(const PointT<double, DIM>& p1, const PointT<double, DIM>& p2) @return The translated line @param p2 The target point @param p1 The source point @brief Get the line translated by a vector from a point to another point",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputvoid SetLocation(const PointT<double, DIM>& point) @param point The location point @brief Set the location of the line",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputvoid SetDirection(const DirectionT<double, DIM>& dir) @param dir The line direction @brief Set the line direction",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputvoid SetPosition(const AxisT<double, DIM>& axis) @param axis The axis @brief Set the axis of the line",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "input[[nodiscard]] const DirectionT<double, DIM>& Direction() @return The direction of the line @brief Get the direction of the line",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "input[[nodiscard]] auto Angle(const LineBase& other) @return The angle between the line and the other line @param other The other line @brief Compute the angle between the line and the other line",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputDerived& Reverse() @return The reference to self @brief Reverse the line direction",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputLineS(double a, double b, double c) @param a,b,c The coefficients @brief Construct from the algebraic coefficients of 2D line",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputvoid Coefficients(double& a, double& b, double& c) @param[out] a,b,c The coefficients @brief The coefficients of the algebraic representation of the 2D line",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "input[[nodiscard]] auto Distance(const Point2& p) @return The distance between the point and the line @param p The point @brief Compute the distance from a point to the line",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "input[[nodiscard]] auto SquaredDistance(const Point2& p) @return The squared distance between the point and the line @param p The point @brief Compute the squared distance from a point to the line",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "input[[nodiscard]] auto SquaredDistance(const LineS& l) @return The squared distance between two lines @param l The other line @brief Compute the squared distance between two lines",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "input[[nodiscard]] LineS Normal(const Point2& p) @return The line passing through a point and perpendicular to the line @param p The point @brief Get a line passing through a point and perpendicular to the line",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputLineS& Rotate(const Point2& point, double angle) @return The reference to self @param angle The rotation angle @param point The rotation center point @brief Rotate the line around a point with an angle in 2D",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "input[[nodiscard]] LineS Rotated(const Point2& point, double angle) @return The rotated line @param angle The rotation angle @param point The rotation center point @brief Get the line rotated around a point with an angle in 2D",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "input[[nodiscard]] auto Distance(const Point3& p) @return The distance between the point and the line @param p The point @brief Compute the distance from a point to the line",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "input[[nodiscard]] auto SquaredDistance(const Point3& p) @return The squared distance between the point and the line @param p The point @brief Compute the squared distance from a point to the line",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API ComputePointsAbscissa(double tol, const Adaptor3Curve& c, double abscissa, double u0) @param u0 The starting parameter @param abscissa The arc length @param c The curve @param tol The tolerance @brief Compute the parameter of a point on a 3D curve with given arc length and a tolerance",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "input[[nodiscard]] bool Contains(const PointT<double, DIM>& p, double tol) @return True if the point is on the line under the tolerance @param tol The tolerance @param p The point @brief Does the line contain a point under a distance tolerance",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "input[[nodiscard]] const PointT<double, DIM>& Location() @return The location of the line @brief Get the location point of the line",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "input[[nodiscard]] Derived Scaled(const PointT<double, DIM>& point, double scale) @return The scaled line @param scale The scale value @param point The scaling center point @brief Get the line scaled by a point",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "input[[nodiscard]] Derived Transformed(const TransformationT<double, DIM>& tr) @return The transformed line @param tr The transformation @brief Get the transformed line",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputDerived& Translate(const PointT<double, DIM>& p1, const PointT<double, DIM>& p2) @return The reference to self @param p2 The target point @param p1 The source point @brief Translate the line by a vector from a point to another point",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "input[[nodiscard]] Derived Translated(const VectorT<double, DIM>& vec) @return The translated line @param vec The translation vector @brief Get the line translated by a vector",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputvoid SetLocation(const PointT<double, DIM>& point) @param point The location point @brief Set the location of the line",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputvoid SetDirection(const DirectionT<double, DIM>& dir) @param dir The line direction @brief Set the line direction",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputvoid SetPosition(const AxisT<double, DIM>& axis) @param axis The axis @brief Set the axis of the line",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "input[[nodiscard]] const DirectionT<double, DIM>& Direction() @return The direction of the line @brief Get the direction of the line",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "input[[nodiscard]] const AxisT<double, DIM>& Position() @return The axis of the line @brief Get the axis of the line",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "input[[nodiscard]] auto Angle(const LineBase& other) @return The angle between the line and the other line @param other The other line @brief Compute the angle between the line and the other line",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "input[[nodiscard]] Derived Reversed() @return The line with reversed direction @brief Get the line with reversed direction",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "input[[nodiscard]] auto SquaredDistance(const LineS& l) @return The squared distance between two lines @param l The other line @brief Compute the squared distance between two lines",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "input[[nodiscard]] auto Distance(const Point3& p) @return The distance between the point and the line @param p The point @brief Compute the distance from a point to the line",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "input[[nodiscard]] LineS Normal(const Point3& p) @return The line passing through a point and perpendicular to the line @param p The point @brief Get a line passing through a point and perpendicular to the line",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputLineS& Mirror(const Frame3& frame) @return The reference to self @param frame The mirror frame @brief Mirror the line by a frame",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "input[[nodiscard]] LineS Rotated(const Axis3& axis, double angle) @return The rotated line @param angle The rotation angle @param axis The rotation axis @brief Get the line rotated around an axis with an angle in 3D",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API Classifier2d(const std::vector<Point2>& pts, double tolU, double tolV, double uMin, double vMin, double uMax, double vMax) @param vMax The upper bound of v @param uMax The upper bound of u @param vMin The lower bound of v @param uMin The lower bound of u @param tolV The tolerance of v bound @param tolU The tolerance of u bound @param pts The points of a 2D closed polygon, the last point does not required to repeat the first point @details Require uMax > uMin, vMax > vMin, and at least 3 points @brief Construct from a 2D polygon and uv-bounds",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API int IsInOut(const Point2& p) @return 1: in; 0: on; -1: out @param p The test point @brief Check a point is in or out of the polygon",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API int IsInOutOn(const Point2& p, double tol) @return 1: in; 0: on; -1: out @param tol The tolerance of the point @param p The test point @brief Check a point is in or out of the polygon",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API static void AdjustPeriodic(double ufirst, double ulast, double precision, double& u1, double& u2) @param[in,out] u2 The second parameter to be adjust @param[in,out] u1 The first parameter to be adjust @param[in] precision The precision to check equality @param[in] ulast The upper bound of the period @param[in] ufirst The lower bound of the period          The parameter u2 is set in the range [u1, u1 + ulast - ufirst] @details The parameter u1 is set in the range [ufirst, ulast] @brief Adjust u1 and u2 to be in the period range.",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "input[[nodiscard]] AMCAX_API static Vector2 D1(double u, const Circle2& circle) @return The first derivative vector @param circle The circle @param u The parameter @brief Compute the first derivative on a 2D circle at a parameter",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API static void AdjustPeriodic(double ufirst, double ulast, double precision, double& u1, double& u2) @param[in,out] u2 The second parameter to be adjust @param[in,out] u1 The first parameter to be adjust @param[in] precision The precision to check equality @param[in] ulast The upper bound of the period @param[in] ufirst The lower bound of the period          The parameter u2 is set in the range [u1, u1 + ulast - ufirst] @details The parameter u1 is set in the range [ufirst, ulast] @brief Adjust u1 and u2 to be in the period range.",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "input[[nodiscard]] AMCAX_API static Point3 CircleValue(double u, const Frame3& pos, double radius) @return The point @param radius The radius @param pos The local frame where the circle lies @param u The parameter @brief Compute the point on a 3D circle represented by a local frame and a radius at a parameter",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "input[[nodiscard]] AMCAX_API static Point2 CircleValue(double u, const Frame2& pos, double radius) @return The point @param radius The radius @param pos The local frame where the circle lies @param u The parameter @brief Compute the point on a 2D circle represented by a local frame and a radius at a parameter",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "input[[nodiscard]] AMCAX_API static Point3 CircleD0(double u, const Frame3& pos, double radius) @return The point @param radius The radius @param pos The local frame where the circle lies @param u The parameter @brief Compute the point on a 3D circle represented by a local frame and a radius at a parameter",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "input[[nodiscard]] AMCAX_API static Point2 CircleD0(double u, const Frame2& pos, double radius) @return The point @param radius The radius @param pos The local frame where the circle lies @param u The parameter @brief Compute the point on a 2D circle represented by a local frame and a radius at a parameter",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "input[[nodiscard]] AMCAX_API static Vector3 CircleD1(double u, const Frame3& pos, double radius) @return The first derivative vector @param radius The radius @param pos The local frame where the circle lies @param u The parameter @brief Compute the first derivative on a 3D circle represented by a local frame and a radius at a parameter",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API static void CircleD1(double u, const Frame3& pos, double radius, Point3& p, Vector3& v1) @param[out] v1 The first derivative @param[out] p The point @param[in] radius The radius @param[in] pos The local frame where the circle lies @param[in] u The parameter @brief Compute the point and the first derivative on a 3D circle represented by a local frame and a radius at a parameter",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "input[[nodiscard]] AMCAX_API static Vector2 CircleD1(double u, const Frame2& pos, double radius) @return The first derivative vector @param radius The radius @param pos The local frame where the circle lies @param u The parameter @brief Compute the first derivative on a 2D circle represented by a local frame and a radius at a parameter",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API static void CircleD1(double u, const Frame2& pos, double radius, Point2& p, Vector2& v1) @param[out] v1 The first derivative @param[out] p The point @param[in] radius The radius @param[in] pos The local frame where the circle lies @param[in] u The parameter @brief Compute the point and the first derivative on a 2D circle represented by a local frame and a radius at a parameter",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "input[[nodiscard]] AMCAX_API static Vector3 CircleD2(double u, const Frame3& pos, double radius) @return The second derivative vector @param radius The radius @param pos The local frame where the circle lies @param u The parameter @brief Compute the second derivative on a 3D circle represented by a local frame and a radius at a parameter",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API static void CircleD2(double u, const Frame3& pos, double radius, Point3& p, Vector3& v1, Vector3& v2) @param[out] v2 The second derivative @param[out] v1 The first derivative @param[out] p The point @param[in] radius The radius @param[in] pos The local frame where the circle lies @param[in] u The parameter @brief Compute the point and the first two derivatives on a 3D circle represented by a local frame and a radius at a parameter",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "input[[nodiscard]] AMCAX_API static Vector2 CircleD2(double u, const Frame2& pos, double radius) @return The second derivative vector @param radius The radius @param pos The local frame where the circle lies @param u The parameter @brief Compute the second derivative on a 2D circle represented by a local frame and a radius at a parameter",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API static void CircleD2(double u, const Frame2& pos, double radius, Point2& p, Vector2& v1, Vector2& v2) @param[out] v2 The second derivative @param[out] v1 The first derivative @param[out] p The point @param[in] radius The radius @param[in] pos The local frame where the circle lies @param[in] u The parameter @brief Compute the point and the first two derivatives on a 2D circle represented by a local frame and a radius at a parameter",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "input[[nodiscard]] AMCAX_API static Vector3 CircleD3(double u, const Frame3& pos, double radius) @return The third derivative vector @param radius The radius @param pos The local frame where the circle lies @param u The parameter @brief Compute the third derivative on a 3D circle represented by a local frame and a radius at a parameter",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API static void CircleD3(double u, const Frame3& pos, double radius, Point3& p, Vector3& v1, Vector3& v2, Vector3& v3) @param[out] v3 The third derivative @param[out] v2 The second derivative @param[out] v1 The first derivative @param[out] p The point @param[in] radius The radius @param[in] pos The local frame where the circle lies @param[in] u The parameter @brief Compute the point and the first three derivatives on a 3D circle represented by a local frame and a radius at a parameter",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "input[[nodiscard]] AMCAX_API static Vector2 CircleD3(double u, const Frame2& pos, double radius) @return The third derivative vector @param radius The radius @param pos The local frame where the circle lies @param u The parameter @brief Compute the third derivative on a 2D circle represented by a local frame and a radius at a parameter",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API static void CircleD3(double u, const Frame2& pos, double radius, Point2& p, Vector2& v1, Vector2& v2, Vector2& v3) @param[out] v3 The third derivative @param[out] v2 The second derivative @param[out] v1 The first derivative @param[out] p The point @param[in] radius The radius @param[in] pos The local frame where the circle lies @param[in] u The parameter @brief Compute the point and the first three derivatives on a 2D circle represented by a local frame and a radius at a parameter",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "input[[nodiscard]] AMCAX_API static Vector3 CircleDN(double u, const Frame3& pos, double radius, int n) @return The n-th derivative vector @param n The order of derivative @param radius The radius @param pos The local frame where the circle lies @param u The parameter @brief Compute the n-th derivative on a 3D circle represented by a local frame and a radius at a parameter",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "input[[nodiscard]] AMCAX_API static Vector2 CircleDN(double u, const Frame2& pos, double radius, int n) @return The n-th derivative vector @param n The order of derivative @param radius The radius @param pos The local frame where the circle lies @param u The parameter @brief Compute the n-th derivative on a 2D circle represented by a local frame and a radius at a parameter",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "input[[nodiscard]] AMCAX_API static double CircleParameter(const Frame3& pos, const Point3& p) @return The parameter of point @param p The given point @param pos The local frame where the circle lies @brief Compute the parameter of a given point on a 3D circle represented by a local frame",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "input[[nodiscard]] AMCAX_API static double CircleParameter(const Frame2& pos, const Point2& p) @return The parameter of point @param p The given point @param pos The local frame where the circle lies @brief Compute the parameter of a given point on a 2D circle represented by a local frame",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "input[[nodiscard]] AMCAX_API static Point3 D0(double u, const Line3& line) @return The resulting point @param line The line @param u The parameter @brief Compute the point on a 3D line at a parameter",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "input[[nodiscard]] AMCAX_API static Point3 D0(double u, const Circle3& circle) @return The resulting point @param circle The circle @param u The parameter @brief Compute the point on a 3D circle at a parameter",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "input[[nodiscard]] AMCAX_API static Point3 D0(double u, const Ellipse3& ellipse) @return The resulting point @param ellipse The ellipse @param u The parameter @brief Compute the point on a 3D ellipse at a parameter",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "input[[nodiscard]] AMCAX_API static Point3 D0(double u, const Parabola3& parabola) @return The resulting point @param parabola The parabola @param u The parameter @brief Compute the point on a 3D parabola at a parameter",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "input[[nodiscard]] AMCAX_API static Point3 D0(double u, const Hyperbola3& hyperbola) @return The resulting point @param hyperbola The hyperbola @param u The parameter @brief Compute the point on a 3D hyperbola at a parameter",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "input[[nodiscard]] AMCAX_API static Point2 D0(double u, const Line2& line) @return The resulting point @param line The line @param u The parameter @brief Compute the point on a 2D line at a parameter",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "input[[nodiscard]] AMCAX_API static Point2 D0(double u, const Circle2& circle) @return The resulting point @param circle The circle @param u The parameter @brief Compute the point on a 2D circle at a parameter",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "input[[nodiscard]] AMCAX_API static Point2 D0(double u, const Ellipse2& ellipse) @return The resulting point @param ellipse The ellipse @param u The parameter @brief Compute the point on a 2D ellipse at a parameter",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "input[[nodiscard]] AMCAX_API static Point2 D0(double u, const Parabola2& parabola) @return The resulting point @param parabola The parabola @param u The parameter @brief Compute the point on a 2D parabola at a parameter",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "input[[nodiscard]] AMCAX_API static Point2 D0(double u, const Hyperbola2& hyperbola) @return The resulting point @param hyperbola The hyperbola @param u The parameter @brief Compute the point on a 2D hyperbola at a parameter",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "input[[nodiscard]] AMCAX_API static Vector3 D1(double u, const Line3& line) @return The first derivative vector @param line The line @param u The parameter @brief Compute the first derivative on a 3D line at a parameter",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API static void D1(double u, const Line3& line, Point3& p, Vector3& v1) @param[out] v1 The first derivative @param[out] p The point @param[in] line The line @param[in] u The parameter @brief Compute the point and the first derivative on a 3D line at a parameter",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "input[[nodiscard]] AMCAX_API static Vector3 D1(double u, const Circle3& circle) @return The first derivative vector @param circle The circle @param u The parameter @brief Compute the first derivative on a 3D circle at a parameter",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API static void D1(double u, const Circle3& circle, Point3& p, Vector3& v1) @param[out] v1 The first derivative @param[out] p The point @param[in] circle The circle @param[in] u The parameter @brief Compute the point and the first derivative on a 3D circle at a parameter",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "input[[nodiscard]] AMCAX_API static Vector3 D1(double u, const Ellipse3& ellipse) @return The first derivative vector @param ellipse The ellipse @param u The parameter @brief Compute the first derivative on a 3D ellipse at a parameter",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API static void D1(double u, const Ellipse3& ellipse, Point3& p, Vector3& v1) @param[out] v1 The first derivative @param[out] p The point @param[in] ellipse The ellipse @param[in] u The parameter @brief Compute the point and the first derivative on a 3D ellipse at a parameter",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "input[[nodiscard]] AMCAX_API static Vector3 D1(double u, const Parabola3& parabola) @return The first derivative vector @param parabola The parabola @param u The parameter @brief Compute the first derivative on a 3D parabola at a parameter",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API static void D1(double u, const Parabola3& parabola, Point3& p, Vector3& v1) @param[out] v1 The first derivative @param[out] p The point @param[in] parabola The parabola @param[in] u The parameter @brief Compute the point and the first derivative on a 3D parabola at a parameter",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "input[[nodiscard]] AMCAX_API static Vector3 D1(double u, const Hyperbola3& hyperbola) @return The first derivative vector @param hyperbola The hyperbola @param u The parameter @brief Compute the first derivative on a 3D hyperbola at a parameter",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API static void D1(double u, const Hyperbola3& hyperbola, Point3& p, Vector3& v1) @param[out] v1 The first derivative @param[out] p The point @param[in] hyperbola The hyperbola @param[in] u The parameter @brief Compute the point and the first derivative on a 3D hyperbola at a parameter",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "input[[nodiscard]] AMCAX_API static Vector2 D1(double u, const Line2& line) @return The first derivative vector @param line The line @param u The parameter @brief Compute the first derivative on a 2D line at a parameter",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API static void D1(double u, const Line2& line, Point2& p, Vector2& v1) @param[out] v1 The first derivative @param[out] p The point @param[in] line The line @param[in] u The parameter @brief Compute the point and the first derivative on a 2D line at a parameter",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "input[[nodiscard]] AMCAX_API static Vector2 D1(double u, const Circle2& circle) @return The first derivative vector @param circle The circle @param u The parameter @brief Compute the first derivative on a 2D circle at a parameter",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API static void D1(double u, const Circle2& circle, Point2& p, Vector2& v1) @param[out] v1 The first derivative @param[out] p The point @param[in] circle The circle @param[in] u The parameter @brief Compute the point and the first derivative on a 2D circle at a parameter",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "input[[nodiscard]] AMCAX_API static Vector2 D1(double u, const Ellipse2& ellipse) @return The first derivative vector @param ellipse The ellipse @param u The parameter @brief Compute the first derivative on a 2D ellipse at a parameter",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API static void D1(double u, const Ellipse2& ellipse, Point2& p, Vector2& v1) @param[out] v1 The first derivative @param[out] p The point @param[in] ellipse The ellipse @param[in] u The parameter @brief Compute the point and the first derivative on a 2D ellipse at a parameter",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "input[[nodiscard]] AMCAX_API static Vector2 D1(double u, const Parabola2& parabola) @return The first derivative vector @param parabola The parabola @param u The parameter @brief Compute the first derivative on a 2D parabola at a parameter",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API static void D1(double u, const Parabola2& parabola, Point2& p, Vector2& v1) @param[out] v1 The first derivative @param[out] p The point @param[in] parabola The parabola @param[in] u The parameter @brief Compute the point and the first derivative on a 2D parabola at a parameter",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "input[[nodiscard]] AMCAX_API static Vector2 D1(double u, const Hyperbola2& hyperbola) @return The first derivative vector @param hyperbola The hyperbola @param u The parameter @brief Compute the first derivative on a 2D hyperbola at a parameter",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API static void D1(double u, const Hyperbola2& hyperbola, Point2& p, Vector2& v1) @param[out] v1 The first derivative @param[out] p The point @param[in] hyperbola The hyperbola @param[in] u The parameter @brief Compute the point and the first derivative on a 2D hyperbola at a parameter",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "input[[nodiscard]] AMCAX_API static Vector3 D2(double u, const Line3& line) @return The second derivative vector @param line The line @param u The parameter @brief Compute the second derivative on a 3D line at a parameter",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API static void D2(double u, const Line3& line, Point3& p, Vector3& v1, Vector3& v2) @param[out] v2 The second derivative @param[out] v1 The first derivative @param[out] p The point @param[in] line The line @param[in] u The parameter @brief Compute the point and the first two derivatives on a 3D line at a parameter",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "input[[nodiscard]] AMCAX_API static Vector3 D2(double u, const Circle3& circle) @return The second derivative vector @param circle The circle @param u The parameter @brief Compute the second derivative on a 3D circle at a parameter",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API static void D2(double u, const Circle3& circle, Point3& p, Vector3& v1, Vector3& v2) @param[out] v2 The second derivative @param[out] v1 The first derivative @param[out] p The point @param[in] circle The circle @param[in] u The parameter @brief Compute the point and the first two derivatives on a 3D circle at a parameter",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "input[[nodiscard]] AMCAX_API static Vector3 D2(double u, const Ellipse3& ellipse) @return The second derivative vector @param ellipse The ellipse @param u The parameter @brief Compute the second derivative on a 3D ellipse at a parameter",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API static void D2(double u, const Ellipse3& ellipse, Point3& p, Vector3& v1, Vector3& v2) @param[out] v2 The second derivative @param[out] v1 The first derivative @param[out] p The point @param[in] ellipse The ellipse @param[in] u The parameter @brief Compute the point and the first two derivatives on a 3D ellipse at a parameter",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "input[[nodiscard]] AMCAX_API static Vector3 D2(double u, const Parabola3& parabola) @return The second derivative vector @param parabola The parabola @param u The parameter @brief Compute the second derivative on a 3D parabola at a parameter",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API static void D2(double u, const Parabola3& parabola, Point3& p, Vector3& v1, Vector3& v2) @param[out] v2 The second derivative @param[out] v1 The first derivative @param[out] p The point @param[in] parabola The parabola @param[in] u The parameter @brief Compute the point and the first two derivatives on a 3D parabola at a parameter",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "input[[nodiscard]] AMCAX_API static Vector3 D2(double u, const Hyperbola3& hyperbola) @return The second derivative vector @param hyperbola The hyperbola @param u The parameter @brief Compute the second derivative on a 3D hyperbola at a parameter",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API static void D2(double u, const Hyperbola3& hyperbola, Point3& p, Vector3& v1, Vector3& v2) @param[out] v2 The second derivative @param[out] v1 The first derivative @param[out] p The point @param[in] hyperbola The hyperbola @param[in] u The parameter @brief Compute the point and the first two derivatives on a 3D hyperbola at a parameter",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "input[[nodiscard]] AMCAX_API static Vector2 D2(double u, const Line2& line) @return The second derivative vector @param line The line @param u The parameter @brief Compute the second derivative on a 2D line at a parameter",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API static void D2(double u, const Line2& line, Point2& p, Vector2& v1, Vector2& v2) @param[out] v2 The second derivative @param[out] v1 The first derivative @param[out] p The point @param[in] line The line @param[in] u The parameter @brief Compute the point and the first two derivatives on a 2D line at a parameter",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "input[[nodiscard]] AMCAX_API static Vector2 D2(double u, const Circle2& circle) @return The second derivative vector @param circle The circle @param u The parameter @brief Compute the second derivative on a 2D circle at a parameter",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API static void D2(double u, const Circle2& circle, Point2& p, Vector2& v1, Vector2& v2) @param[out] v2 The second derivative @param[out] v1 The first derivative @param[out] p The point @param[in] circle The circle @param[in] u The parameter @brief Compute the point and the first two derivatives on a 2D circle at a parameter",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "input[[nodiscard]] AMCAX_API static Vector2 D2(double u, const Ellipse2& ellipse) @return The second derivative vector @param ellipse The ellipse @param u The parameter @brief Compute the second derivative on a 2D ellipse at a parameter",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API static void D2(double u, const Ellipse2& ellipse, Point2& p, Vector2& v1, Vector2& v2) @param[out] v2 The second derivative @param[out] v1 The first derivative @param[out] p The point @param[in] ellipse The ellipse @param[in] u The parameter @brief Compute the point and the first two derivatives on a 2D ellipse at a parameter",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "input[[nodiscard]] AMCAX_API static Vector2 D2(double u, const Parabola2& parabola) @return The second derivative vector @param parabola The parabola @param u The parameter @brief Compute the second derivative on a 2D parabola at a parameter",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API static void D2(double u, const Parabola2& parabola, Point2& p, Vector2& v1, Vector2& v2) @param[out] v2 The second derivative @param[out] v1 The first derivative @param[out] p The point @param[in] parabola The parabola @param[in] u The parameter @brief Compute the point and the first two derivatives on a 2D parabola at a parameter",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "input[[nodiscard]] AMCAX_API static Vector2 D2(double u, const Hyperbola2& hyperbola) @return The second derivative vector @param hyperbola The hyperbola @param u The parameter @brief Compute the second derivative on a 2D hyperbola at a parameter",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API static void D2(double u, const Hyperbola2& hyperbola, Point2& p, Vector2& v1, Vector2& v2) @param[out] v2 The second derivative @param[out] v1 The first derivative @param[out] p The point @param[in] hyperbola The hyperbola @param[in] u The parameter @brief Compute the point and the first two derivatives on a 2D hyperbola at a parameter",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "input[[nodiscard]] AMCAX_API static Vector3 D3(double u, const Line3& line) @return The third derivative vector @param line The line @param u The parameter @brief Compute the third derivative on a 3D line at a parameter",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API static void D3(double u, const Line3& line, Point3& p, Vector3& v1, Vector3& v2, Vector3& v3) @param[out] v3 The third derivative @param[out] v2 The second derivative @param[out] v1 The first derivative @param[out] p The point @param[in] line The line @param[in] u The parameter @brief Compute the point and the first three derivatives on a 3D line at a parameter",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "input[[nodiscard]] AMCAX_API static Vector3 D3(double u, const Circle3& circle) @return The third derivative vector @param circle The circle @param u The parameter @brief Compute the third derivative on a 3D circle at a parameter",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API static void D3(double u, const Circle3& circle, Point3& p, Vector3& v1, Vector3& v2, Vector3& v3) @param[out] v3 The third derivative @param[out] v2 The second derivative @param[out] v1 The first derivative @param[out] p The point @param[in] circle The circle @param[in] u The parameter @brief Compute the point and the first three derivatives on a 3D circle at a parameter",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API static void D3(double u, const Ellipse3& ellipse, Point3& p, Vector3& v1, Vector3& v2, Vector3& v3) @param[out] v3 The third derivative @param[out] v2 The second derivative @param[out] v1 The first derivative @param[out] p The point @param[in] ellipse The ellipse @param[in] u The parameter @brief Compute the point and the first three derivatives on a 3D ellipse at a parameter",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "input[[nodiscard]] AMCAX_API static Vector2 D3(double u, const Line2& line) @return The third derivative vector @param line The line @param u The parameter @brief Compute the third derivative on a 2D line at a parameter",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API static void D3(double u, const Line2& line, Point2& p, Vector2& v1, Vector2& v2, Vector2& v3) @param[out] v3 The third derivative @param[out] v2 The second derivative @param[out] v1 The first derivative @param[out] p The point @param[in] line The line @param[in] u The parameter @brief Compute the point and the first three derivatives on a 2D line at a parameter",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "input[[nodiscard]] AMCAX_API static Vector2 D3(double u, const Circle2& circle) @return The third derivative vector @param circle The circle @param u The parameter @brief Compute the third derivative on a 2D circle at a parameter",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API static void D3(double u, const Circle2& circle, Point2& p, Vector2& v1, Vector2& v2, Vector2& v3) @param[out] v3 The third derivative @param[out] v2 The second derivative @param[out] v1 The first derivative @param[out] p The point @param[in] circle The circle @param[in] u The parameter @brief Compute the point and the first three derivatives on a 2D circle at a parameter",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API static void D3(double u, const Ellipse2& ellipse, Point2& p, Vector2& v1, Vector2& v2, Vector2& v3) @param[out] v3 The third derivative @param[out] v2 The second derivative @param[out] v1 The first derivative @param[out] p The point @param[in] ellipse The ellipse @param[in] u The parameter @brief Compute the point and the first three derivatives on a 2D ellipse at a parameter",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API static void D3(double u, const Parabola2& parabola, Point2& p, Vector2& v1, Vector2& v2, Vector2& v3) @param[out] v3 The third derivative @param[out] v2 The second derivative @param[out] v1 The first derivative @param[out] p The point @param[in] parabola The parabola @param[in] u The parameter @brief Compute the point and the first three derivatives on a 2D parabola at a parameter",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputCylinder() @brief Default constructor",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API Cylinder(const Frame3& frame, double r) @param r The radius @param frame The local frame @brief Construct from a local frame and a radius",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API Cylinder& Scale(const Point3& point, double scale) @return The reference to self @param scale The scale value @param point The scaling center point @brief Scale the cylinder by a point",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputvoid SetMajorRadius(double r) @param r The new major radius @brief Set the major radius",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputvoid SetMinorRadius(double r) @param r The new minor radius @brief Set the minor radius",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "input[[nodiscard]] AxisT<double, DIM> Directrix2() @return The negative directrix @brief Get the directrix on the negative side of the major axis",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "input[[nodiscard]] PointT<double, DIM> Focus1() @return The positive focus @brief Get the focus on the positive side of the major axis",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "input[[nodiscard]] double MajorRadius() @return The major radius @brief Get the major radius",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "input[[nodiscard]] double MinorRadius() @return The minor radius @brief Get the minor radius",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "input[[nodiscard]] AxisT<double, DIM> Asymptote1() @return The positive asymptote @brief Get the asymptote of the hyperbola with positive slope",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "input[[nodiscard]] AxisT<double, DIM> Asymptote2() @return The negative asymptote @brief Get the asymptote of the hyperbola with negative slope",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "input[[nodiscard]] HyperbolaS ConjugateBranch2() @return The negative conjugate hyperbola @brief Get the conjugate hyperbola on the negative side of the minor axis",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputHyperbolaS& Scale(const PointT<double, DIM>& point, double scale) @return The reference to self @param scale The scale value @param point The scaling center point @brief Scale the hyperbola by a center point",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputvoid SetMajorRadius(double r) @param r The new major radius @brief Set the major radius",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputvoid SetMinorRadius(double r) @param r The new minor radius @brief Set the minor radius",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "input[[nodiscard]] AxisT<double, DIM> Directrix1() @return The positive directrix @brief Get the directrix on the positive side of the major axis",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "input[[nodiscard]] AxisT<double, DIM> Directrix2() @return The negative directrix @brief Get the directrix on the negative side of the major axis",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "input[[nodiscard]] PointT<double, DIM> Focus1() @return The positive focus @brief Get the focus on the positive side of the major axis",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "input[[nodiscard]] PointT<double, DIM> Focus2() @return The negative focus @brief Get the focus on the negative side of the major axis",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "input[[nodiscard]] double MajorRadius() @return The major radius @brief Get the major radius",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "input[[nodiscard]] double MinorRadius() @return The minor radius @brief Get the minor radius",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "input[[nodiscard]] AxisT<double, DIM> Asymptote1() @return The positive asymptote @brief Get the asymptote of the hyperbola with positive slope",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "input[[nodiscard]] AxisT<double, DIM> Asymptote2() @return The negative asymptote @brief Get the asymptote of the hyperbola with negative slope",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "input[[nodiscard]] HyperbolaS ConjugateBranch1() @return The positive conjugate hyperbola @brief Get the conjugate hyperbola on the positive side of the minor axis",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "input[[nodiscard]] HyperbolaS ConjugateBranch2() @return The negative conjugate hyperbola @brief Get the conjugate hyperbola on the negative side of the minor axis",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputHyperbolaS& Scale(const PointT<double, DIM>& point, double scale) @return The reference to self @param scale The scale value @param point The scaling center point @brief Scale the hyperbola by a center point",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAXMeshing_API void setTriMeshAsOutput(iPoints    &points, iTriangles &triangles)",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "AMCAXMeshing_API void Union() @brief apply (3)UNION and (4)put result to",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAXMeshing_API void computeInterSegments() after computing labels. @brief In order to obtain the intersection segments, we need call this",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAXMeshing_API std::vector<InterSegments> & getInterSegments()",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API explicit GeneralTransformShape(const GeneralTransformation3& t) @param t The general transformation @brief Construct from a general transformation",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API GeneralTransformShape(const TopoShape& s, const GeneralTransformation3& t, bool copy = false) @param copy Whether the geometry of the shape is copied @param t The general transformation @param s The shape @brief Transform a shape by a general transformation",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API MakeBox(double dx, double dy, double dz) @param dx,dy,dz The size @brief Construct from its size in x, y, z directions",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API MakeBox(const Point3& p, double dx, double dy, double dz) @param dx,dy,dz The size @param p The corner point @brief Construct from a corner point and its size",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API MakeBox(const Point3& p1, const Point3& p2) @param p2 The second point @param p1 The first point @brief Construct from two diagonal corner points",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API MakeBox(const Frame3& frame, double dx, double dy, double dz) @param dx,dy,dz The size @param frame The local coordinate system @brief Construct from a local coordinate system and size",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API const TopoFace& XMinFace() @return The X-min face @brief Get the face on X minimum",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API const TopoFace& ZMinFace() @return The Z-min face @brief Get the face on Z minimum",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API MakeTorus(double r1, double r2, double angle1, double angle2) @param angle2 The end angle @param angle1 The start angle @param r2 The minor radius @param r1 The major radius @brief Construct from a major radius, a minor radius and two angles that forms an arc of the section circle",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API MakeTorus(double r1, double r2, double angle1, double angle2, double angle) @param angle The rotation angle @param angle2 The end angle @param angle1 The start angle @param r2 The minor radius @param r1 The major radius @brief Construct from a major radius, a minor radius, two angles that forms an arc of the section circle and a rotation angle",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API MakeTorus(const Frame3& frame, double r1, double r2, double angle1, double angle2) @param angle2 The end angle @param angle1 The start angle @param r2 The minor radius @param r1 The major radius @param frame The local coordinate system @brief Construct from a local coordinate system, a major radius, a minor radius and two angles that forms an arc of the section circle",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API MakeTorus(const Frame3& frame, double r1, double r2, double angle1, double angle2, double angle) @param angle The rotation angle @param angle2 The end angle @param angle1 The start angle @param r2 The minor radius @param r1 The major radius @param frame The local coordinate system @brief Construct from a local coordinate system, a major radius, a minor radius, two angles that forms an arc of the section circle and a rotation angle",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API MakePolygon(const Point3& p1, const Point3& p2) @param p2 The second point @param p1 The first point @brief Construct from two points",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API void Add(const Point3& p) @param p The point @brief Add a new point to the polygon",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API MakePyramid(const Point3& p1, const Point3& p2, const Point3& p3, const Point3& apex) @param apex Apex point @param p1,p2,p3 Points on the base plane @brief Construct a tetrahedron",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API MakePyramid(const Point3& p1, const Point3& p2, const Point3& p3, const Point3& p4, const Point3& apex) @param apex Apex point @param p1,p2,p3,p4 Points on the base plane @brief Construct a quadrilateral pyramid",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API MakePyramid(const std::vector<Point3>& basepoints, const Point3& apex) @param apex Apex point @param basepoints Points on the base plane @brief Construct a pyramid with base points and an apex point",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API MakePyramid(const Frame3& frame, double radius, int nside, double height) @param height Height of the polygon @param nside Number of sides of the base polygon @param radius Radius of the circumcircle of the base polygon @param frame The local coordinate system @brief Construct a regular pyramid",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API MakePyramid(const Frame3& frame, const Point3& p1, const Point3& p2, const Point3& p3, const Point3& apex) @param apex Apex point @param p1,p2,p3 Points that are projected onto the base plane @param frame The frame of base plane @brief Construct a tetrahedron with a given plane frame",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API MakePyramid(const Frame3& frame, const Point3& p1, const Point3& p2, const Point3& p3, const Point3& p4, const Point3& apex) @param apex Apex point @param p1,p2,p3,p4 Points that are projected onto the base plane @param frame The frame of base plane @brief Construct a quadrilateral pyramid with a given plane frame",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API MakePyramid(const Frame3& frame, const std::vector<Point3>& basepoints, const Point3& apex) @param apex Apex point @param basepoints Points that are projected onto the base plane @param frame The frame of base plane @brief Construct a pyramid with a given base plane frame",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API MakePyramid(const Point3& baseLocation, const std::vector<Point3>& basepoints, const Point3& apex) @param apex Apex point @param basepoints The base points that are projected onto the base plane @param baseLocation The location of the base plane @details The base plane are determined by the location point and the first two base points @brief Construct a pyramid with a given location on the base plane",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API MakeRevol(const TopoShape& s, const Axis3& a, double d, bool copy = false) @param copy Whether copy the base shape @param d The rotation angle @param a The rotation axis @param s The base shape @brief Construct from a base shape, a rotation axis and a rotation angle",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API MakeRevol(const TopoShape& s, const Axis3& a, bool copy = false) @param copy Whether copy the base shape @param a The rotation axis @param s The base shape @brief Construct from a base shape and a rotation axis",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API MakeRightPrism(const Point3& p1, const Point3& p2, const Point3& p3, const Point3& apex) @param apex A point on the top plane @param p1,p2,p3 Points on the base plane @brief Construct a right triangular prism",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API MakeRightPrism(const Point3& p1, const Point3& p2, const Point3& p3, const Point3& p4, const Point3& apex) @param apex A point on the top plane @param p1,p2,p3,p4 Points on the base plane @brief Construct a right quadrilateral prism",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API MakeRightPrism(const std::vector<Point3>& basepoints, const Point3& apex) @param apex A point on the top plane @param basepoints Points on the base plane @brief Construct a right prism with base points and a point on the top plane",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API MakeRightPrism(const Frame3& frame, double radius, int nside, double height) @param height Height of the polygon @param nside Number of sides of the base polygon @param radius Radius of the circumcircle of the base polygon @param frame The local coordinate system @brief Construct a right regular prism",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API MakeRightPrism(const Frame3& frame, const Point3& p1, const Point3& p2, const Point3& p3, const Point3& apex) @param apex A point on the top plane @param p1,p2,p3 Points that are projected onto the base plane @param frame The frame of base plane @brief Construct a right triangular prism with a given plane frame",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API MakeRightPrism(const Frame3& frame, const Point3& p1, const Point3& p2, const Point3& p3, const Point3& p4, const Point3& apex) @param apex A point on the top plane @param p1,p2,p3,p4 Points that are projected onto the base plane @param frame The frame of base plane @brief Construct a right quadrilateral prism with a given plane frame",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API MakeRightPrism(const Frame3& frame, const std::vector<Point3>& basepoints, const Point3& apex) @param apex A point on the top plane @param basepoints Points that are projected onto the base plane @param frame The frame of base plane @brief Construct a right prism with a given base plane frame",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API MakeRightPrism(const Point3& baseLocation, const std::vector<Point3>& basepoints, const Point3& apex) @param apex A point on the top plane @param basepoints The base points that are projected onto the base plane @param baseLocation The location of the base plane @details The base plane are determined by the location point and the first two base points @brief Construct a right prism with a given location on the base plane",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API static TopoShape SewShape(const std::list<TopoShape>& shapes, double tolerance) @return The sewed shape @param tolerance The tolerance @param shapes The shapes to be sewed          If some edges do not coincide, the related faces remain unsewed. @details The border edges are merged to common edges under a given tolerance. @brief Sew faces to a shell",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API TransformShape(const TopoShape& s, const Transformation3& tr, bool copyGeom = false, bool copyMesh = false) @param copyMesh Whether the mesh of the shape is copied @param copyGeom Whether the geometry of the shape is copied @param tr The transformation @param s The shape @brief Construct from a shape with a transformation",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API TransformShape(const TopoShape& s, const Transformation3& tr, bool copyGeom = false, bool copyMesh = false) @param copyMesh Whether the mesh of the shape is copied @param copyGeom Whether the geometry of the shape is copied @param tr The transformation @param s The shape @brief Construct from a shape with a transformation",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API static std::shared_ptr<Geom3BSplineCurve> ApproxPoints(const std::vector<Point3>& points, int degree, int npoles, bool isClosed = false, ApproxParameterizationType ptype = ApproxParameterizationType::ChordLength) @return curve @param ptype parameterization type @param isClosed Is curve closed @param npoles Target number of poles @param degree Target degree @param points Data points to be approximated @brief Approx points to a curve",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API static std::shared_ptr<Geom3BSplineCurve> BlendCurves( const std::shared_ptr<Geom3BSplineCurve>& curve1, bool isFront1, ContinuityType cont1, const std::shared_ptr<Geom3BSplineCurve>& curve2, bool isFront2, ContinuityType cont2)",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API static std::shared_ptr<Geom3BSplineCurve> BlendCurves( const std::shared_ptr<Geom3BSplineCurve>& curve1, bool isFront1, ContinuityType cont1, std::vector<double>& parameters1, const std::shared_ptr<Geom3BSplineCurve>& curve2, bool isFront2, ContinuityType cont2, std::vector<double>& parameters2)",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API static std::shared_ptr<Geom3BSplineSurface> BlendSurfaces( const std::shared_ptr<Geom3BSplineSurface>& surf1, bool isUIso1, bool isFront1, ContinuityType cont1, std::vector<double>& parameters1, const std::shared_ptr<Geom3BSplineSurface>& surf2, bool isUIso2, bool isFront2, ContinuityType cont2, std::vector<double>& parameters2, bool autoReverse, bool isPrecise, const std::vector<double>& tol)",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API static std::shared_ptr<Geom3BSplineSurface> BlendFaces( const TopoFace& face1, const TopoEdge& edge1, ContinuityType cont1, std::vector<double>& parameters1, const TopoFace& face2, const TopoEdge& edge2, ContinuityType cont2, std::vector<double>& parameters2, bool autoReverse, bool isPrecise, const std::vector<double>& tol)",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API static std::shared_ptr<Geom3BSplineCurve> BlendCurves( const std::shared_ptr<Geom3BSplineCurve>& curve1, bool isFront1, ContinuityType cont1, const std::shared_ptr<Geom3BSplineCurve>& curve2, bool isFront2, ContinuityType cont2)",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API static std::shared_ptr<Geom3BSplineCurve> BlendCurves( const std::shared_ptr<Geom3BSplineCurve>& curve1, bool isFront1, ContinuityType cont1, std::vector<double>& parameters1, const std::shared_ptr<Geom3BSplineCurve>& curve2, bool isFront2, ContinuityType cont2, std::vector<double>& parameters2)",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API static std::shared_ptr<Geom3BSplineSurface> BlendSurfaces( const std::shared_ptr<Geom3BSplineSurface>& surf1, bool isUIso1, bool isFront1, ContinuityType cont1, std::vector<double>& parameters1, const std::shared_ptr<Geom3BSplineSurface>& surf2, bool isUIso2, bool isFront2, ContinuityType cont2, std::vector<double>& parameters2, bool autoReverse, bool isPrecise, const std::vector<double>& tol)",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API static std::shared_ptr<Geom3BSplineSurface> BlendFaces( const TopoFace& face1, const TopoEdge& edge1, ContinuityType cont1, std::vector<double>& parameters1, const TopoFace& face2, const TopoEdge& edge2, ContinuityType cont2, std::vector<double>& parameters2, bool autoReverse, bool isPrecise, const std::vector<double>& tol)",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API static std::shared_ptr<Geom3BSplineCurve> BuildCurve(const std::vector<Point3>& poles, int degree, bool isPeriodic) @return The built curve. If building curve is failed, return nullptr @param isPeriodic Whether the curve is periodic or not @param degree The curve degree @param poles Curve poles. If it is a periodic curve, don't include the point at the end that repeats the first point @brief Build BSpline curve",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API static std::shared_ptr<Geom3BSplineCurve> BuildCurve(const std::vector<Point3>& poles, const std::vector<double>& weights, int degree, bool isPeriodic) @return The built curve. If building curve is failed, return nullptr @param isPeriodic Whether the curve is periodic or not @param degree The curve degree @param weights Curve weights @param poles Curve poles. If it is a periodic curve, don't include the point at the end that repeats the first point @brief Build NURBS curve",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API static int ValidMaxDegree(int npoles, bool isPeriodic) @return The maximum valid degree @param isPeriodic Whether the curve is periodic @param npoles The number of control points @brief Given the number of the control points, calculate the maximum valide degree of a BSpline curve",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API static std::pair<NURBSSweepStatus, std::shared_ptr<Geom3BSplineSurface>> SweepWithThreeGuides(const std::shared_ptr<Geom3BSplineCurve>& guide1, const std::shared_ptr<Geom3BSplineCurve>& guide2, const std::shared_ptr<Geom3BSplineCurve>& guide3, const std::shared_ptr<Geom3BSplineCurve>& spine, double spineLeftBound, double spineRightBound)",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API static std::pair<NURBSSweepStatus, std::vector<std::shared_ptr<Geom3BSplineSurface>>> SweepWithTwoGuidesAndRadius(const std::shared_ptr<Geom3BSplineCurve>& guide1, const std::shared_ptr<Geom3BSplineCurve>& guide2, const LawFunction& radiusLaw, const std::shared_ptr<Geom3BSplineCurve>& spine, double spineLeftBound, double spineRightBound)",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API static std::pair<NURBSSweepStatus, std::shared_ptr<Geom3BSplineSurface>> SweepWithCenterAndTwoAngles(const std::shared_ptr<Geom3BSplineCurve>& centerCurve, const std::shared_ptr<Geom3BSplineCurve>& referenceCurve, const LawFunction& angleLaw1, const LawFunction& angleLaw2, const std::shared_ptr<Geom3BSplineCurve>& spine, double spineLeftBound, double spineRightBound)",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API static std::pair<NURBSSweepStatus, std::shared_ptr<Geom3BSplineSurface>> SweepWithCenterAndRadius(const std::shared_ptr<Geom3BSplineCurve>& centerCurve, const LawFunction& radiusLaw, const std::shared_ptr<Geom3BSplineCurve>& spine, double spineLeftBound, double spineRightBound)",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API static std::pair<NURBSSweepStatus, std::vector<std::shared_ptr<Geom3BSplineSurface>>> SweepWithTwoGuidesAndTangencySurface(const std::shared_ptr<Geom3BSplineCurve>& limitCurveWithTangency, const std::shared_ptr<Geom3BSplineSurface>& tangencySurface, const std::shared_ptr<Geom3BSplineCurve>& limitCurve, const std::shared_ptr<Geom3BSplineCurve>& spine, double spineLeftBound, double spineRightBound)",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API static std::pair<NURBSSweepStatus, std::vector<std::shared_ptr<Geom3BSplineSurface>>> SweepWithOneGuideAndTangencySurface(const std::shared_ptr<Geom3BSplineCurve>& guide, const std::shared_ptr<Geom3BSplineSurface>& tangencySurface, const LawFunction& radiusLaw, const std::shared_ptr<Geom3BSplineCurve>& spine, double spineLeftBound, double spineRightBound)",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API static std::pair<NURBSSweepStatus, std::vector<std::shared_ptr<Geom3BSplineSurface>>> SweepWithCurveOnTangencySurface(const std::shared_ptr<Geom3BSplineCurve>& guide, const std::shared_ptr<Geom3BSplineSurface>& tangencySurface, const LawFunction& radiusLaw, const LawFunction& angleLaw1, const LawFunction& angleLaw2, const std::shared_ptr<Geom3BSplineCurve>& spine, double spineLeftBound, double spineRightBound)",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API static std::shared_ptr<Geom3BSplineCurve> ToBSpline(const std::shared_ptr<Geom3Curve>& curve) @return Result BSpline curve @param curve The given curve @brief Convert a common curve to a BSpline curve",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API static std::shared_ptr<Geom3BSplineSurface> ToBSpline(const std::shared_ptr<Geom3Surface>& surface) @return BSpline surface @param surface The given surface @brief Convert a common surface to a BSpline surface",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API static std::vector<std::pair<double, bool>> CalcParamCorrespondece( const std::vector<std::shared_ptr<Geom3Curve>>& curves, bool isPeriodic, bool isConsiderReverse)",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API static std::shared_ptr<Geom3BSplineSurface> CurveNetworkSurfaceGordon(const std::vector<std::shared_ptr<Geom3BSplineCurve>>& verticalCurves, const std::vector<std::shared_ptr<Geom3BSplineCurve>>& horizontalCurves) @return The Gordon surface which go through the curves @param horizontalCurves Horizontal network curves @param verticalCurves Vertical network curves @brief Coons-Gordon surface",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API static std::pair<NURBSSweepStatus, std::shared_ptr<Geom3BSplineSurface>> SweepWithTwoGuideCurves( const std::shared_ptr<Geom3BSplineCurve>& profile, const std::shared_ptr<Geom3BSplineCurve>& guide1, const std::shared_ptr<Geom3BSplineCurve>& guide2, Point3 anchorPoint1, Point3 anchorPoint2, const std::shared_ptr<Geom3BSplineCurve>& spine, double spineLeftBound, double spineRightBound)",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API static std::pair<NURBSSweepStatus, std::shared_ptr<Geom3BSplineSurface>> SweepWithTwoGuideCurves( const std::shared_ptr<Geom3BSplineCurve>& profile, const std::shared_ptr<Geom3BSplineCurve>& guide1, const std::shared_ptr<Geom3BSplineCurve>& guide2, Point3 anchorPoint, const Direction3& anchorDirection, const std::shared_ptr<Geom3BSplineCurve>& spine, double spineLeftBound, double spineRightBound)",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API static std::pair<NURBSSweepStatus, std::vector<std::shared_ptr<Geom3BSplineSurface>>> SweepWithPullingDirection( const std::shared_ptr<Geom3BSplineCurve>& profile, const std::shared_ptr<Geom3BSplineCurve>& guide, const Direction3& direction, const LawFunction& angleLawFunc, const std::shared_ptr<Geom3BSplineCurve>& spine, double spineLeftBound, double spineRightBound)",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API static std::vector<std::shared_ptr<Geom3BSplineCurve>> ExplodeCurve(const std::shared_ptr<Geom3BSplineCurve>& curve) @return The result curves @param curve The given curve @brief Explode a curve into curves at C0 points",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputAMCAX_API static Array2<std::shared_ptr<Geom3BSplineSurface>> ExplodeSurface(const std::shared_ptr<Geom3BSplineSurface>& surface) @return The result surfaces @param surface The given surface @brief Explode a surface into patches at C0 isocurves",
    "output": "none"
}, 
    
{
    "instruction": "Generate a test program based on the following method declarations and parameter parsing ",
    "input": "inputvoid SetMajorRadius(double r) @param r The new major radius @brief Set the major radius",
    "output": "none"
}]