{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API BoolBRepCut()	 @details Only set the type of boolean operation to cut
	 @brief Default constructor
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <boolean/BoolBRepCut.hpp>
#include <modeling/MakeTorus.hpp>
#include <modeling/MakeSphere.hpp>
#include <modeling/MakeCone.hpp>
#include <topology/TopoExplorer.hpp>
#include <topology/TopoFace.hpp>
#include <hatch/BRepClassificationTools.hpp>
using namespace AMCAX;
TEST_CASE("bug1: in Debug mode: BoolBuilder  ", "[boolean][BoolBRepCut][P1][fixbug]") {
	TopoShape torus = MakeTorus(Frame3(Point3(0.0, 0.0, 2.0), Direction3(1.0, 0.0, 0.0)), 4.0, 2.0);
	TopoShape sphere = MakeSphere(4.0);
	TopoShape result = BoolBRepCut(sphere, torus);
	AMCAX::GlobalProperty prop;
	AMCAX::BRepGlobalProperty::VolumeProperties(result, prop);
	CHECK(prop.Mass() == Approx(153.229)); 
	bool isWriteSuccess = AMCAX::OCCTIO::OCCTTool::Write(result, OUTPUT_PATH_PREFIX"BoolBRepCut_bug72.brep", false);
	CHECK(isWriteSuccess == true);
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API BoolBRepCut(const TopoShape& s1, const TopoShape& s2, bool isForward = true)	 @param isForward Cut s1 by s2 if true, and cut s2 by s1 if false
	 @param s2 The tool shape
	 @param s1 The argument shape
	 @brief Compute the cut operation of two shapes
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <boolean/BoolBRepCut.hpp>
#include <modeling/MakeTorus.hpp>
#include <modeling/MakeSphere.hpp>
#include <modeling/MakeCone.hpp>
#include <topology/TopoExplorer.hpp>
#include <topology/TopoFace.hpp>
#include <hatch/BRepClassificationTools.hpp>
using namespace AMCAX;
TEST_CASE("bug1: in Debug mode: BoolBuilder  ", "[boolean][BoolBRepCut][P1][fixbug]") {
	TopoShape torus = MakeTorus(Frame3(Point3(0.0, 0.0, 2.0), Direction3(1.0, 0.0, 0.0)), 4.0, 2.0);
	TopoShape sphere = MakeSphere(4.0);
	TopoShape result = BoolBRepCut(sphere, torus);
	AMCAX::GlobalProperty prop;
	AMCAX::BRepGlobalProperty::VolumeProperties(result, prop);
	CHECK(prop.Mass() == Approx(153.229)); 
	bool isWriteSuccess = AMCAX::OCCTIO::OCCTTool::Write(result, OUTPUT_PATH_PREFIX"BoolBRepCut_bug72.brep", false);
	CHECK(isWriteSuccess == true);
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API BoolBRepFuse()	 @details Only set the type of boolean operation to fuse
	 @brief Default constructor
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <boolean/BoolBRepFuse.hpp>
#include <boolean/BoolBRepCut.hpp>
using namespace AMCAX;
TEST_CASE("bug1: BoolBRepFuse ", "[boolean][BoolBRepFuse][fixbug]")
{
	TopoShape shape1, shape2;
	OCCTIO::OCCTTool::Read(shape1, INPUT_PATH_PREFIX"boolean/part.brep");
	OCCTIO::OCCTTool::Read(shape2, INPUT_PATH_PREFIX"boolean/box.brep");
	TopoShape result = BoolBRepFuse(shape1, shape2);
	CHECK(OCCTIO::OCCTTool::Write(result, OUTPUT_PATH_PREFIX"testbug-view-556.brep"));
	IndexSet<TopoShape> shapeFace, shapeEdge, shapeVertex ,shapeSolid;
	CHECK( GetTopoToolCount(result, AMCAX::ShapeType::Solid, shapeSolid)==1 );
}	
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API BoolBRepFuse(const TopoShape& s1, const TopoShape& s2)	 @param s2 The tool shape
	 @param s1 The argument shape
	 @brief Compute the fuse of two shapes
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <boolean/BoolBRepFuse.hpp>
#include <boolean/BoolBRepCut.hpp>
using namespace AMCAX;
TEST_CASE("bug1: BoolBRepFuse ", "[boolean][BoolBRepFuse][fixbug]")
{
	TopoShape shape1, shape2;
	OCCTIO::OCCTTool::Read(shape1, INPUT_PATH_PREFIX"boolean/part.brep");
	OCCTIO::OCCTTool::Read(shape2, INPUT_PATH_PREFIX"boolean/box.brep");
	TopoShape result = BoolBRepFuse(shape1, shape2);
	CHECK(OCCTIO::OCCTTool::Write(result, OUTPUT_PATH_PREFIX"testbug-view-556.brep"));
	IndexSet<TopoShape> shapeFace, shapeEdge, shapeVertex ,shapeSolid;
	CHECK( GetTopoToolCount(result, AMCAX::ShapeType::Solid, shapeSolid)==1 );
}	
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API BoolBRepSection()	 @details Only set the type of boolean operation to section
	 @brief Default constructor
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <boolean/BoolBRepSection.hpp>
#include <common/CartesianCoordinateSystem.hpp>
#include <math/LineT.hpp>
#include <modeling/MakePrism.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeFace.hpp>
#include <geometry/Geom3BezierCurve.hpp>
#include <modeling/MakeRevol.hpp>
#include <geometry/Geom3CylindricalSurface.hpp>
#include <topology/TopoTool.hpp>
using namespace AMCAX;
TEST_CASE("bug1: BoolBRepSection ", "[boolean][BoolBRepSection][fixbug]")
{
	Line3 line(CartesianCoordinateSystem::OZ());
	TopoShape infinitePlane1 = MakePrism(MakeEdge(line, 0.0, 1.0), Direction3(-1.0, 0.0, 0.0), false);
	TopoShape infinitePlane2 = MakePrism(MakeEdge(line, 0.0, 1.0), Direction3(1.0, 0.0, 0.0), false);
	TopoShape infinitePlane3 = MakePrism(MakeEdge(line, 0.0, 1.0), Direction3(0.0, 1.0, 0.0), false);
	TopoShape infinitePlane4 = MakePrism(MakeEdge(line, 0.0, 1.0), Direction3(0.0, -1.0, 0.0), false);
	std::vector<Point3> poles{ Point3(1.0, 0.0, 0.0), Point3(0.8, 0.0, 0.5), Point3(1.0, 0.0, 1.0) };
	auto bz = std::make_shared<Geom3BezierCurve>(poles);
	TopoEdge e2 = MakeEdge(bz);
	TopoShape revolshape = MakeRevol(e2, CartesianCoordinateSystem::OZ());
	auto surface1 = std::make_shared<Geom3CylindricalSurface>(Frame3(), 1.0);
	auto surface2 = TopoTool::Surface(TopoCast::Face(revolshape));
	TopoShape result1 = BoolBRepSection(infinitePlane1, surface2); 
	TopoShape result2 = BoolBRepSection(infinitePlane2, surface2); 
	TopoShape result3 = BoolBRepSection(infinitePlane3, surface2); 
	TopoShape result4 = BoolBRepSection(infinitePlane4, surface2); 
	GlobalProperty prop1, prop2, prop3, prop4 ;
	CHECK( GetLinearProperties(result1, prop1, true, false) == Approx(1.0260606301));
	CHECK( GetLinearProperties(result2, prop1, true, false) == Approx(1.0260606301));
	CHECK( GetLinearProperties(result3, prop1, true, false) == Approx(1.0260606301));
	CHECK( GetLinearProperties(result4, prop1, true, false) == Approx(1.0260606301));
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API BoolBRepSection(const TopoShape& s1, const TopoShape& s2, bool perfomNow = true)	 @param perfomNow If true, the operation is performed immediately; if false, the Build() function has to be called manually
	 @param s2 The tool shape
	 @param s1 The argument shape
	 @brief Compute the section of two shapes
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <boolean/BoolBRepSection.hpp>
#include <common/CartesianCoordinateSystem.hpp>
#include <math/LineT.hpp>
#include <modeling/MakePrism.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeFace.hpp>
#include <geometry/Geom3BezierCurve.hpp>
#include <modeling/MakeRevol.hpp>
#include <geometry/Geom3CylindricalSurface.hpp>
#include <topology/TopoTool.hpp>
using namespace AMCAX;
TEST_CASE("bug1: BoolBRepSection ", "[boolean][BoolBRepSection][fixbug]")
{
	Line3 line(CartesianCoordinateSystem::OZ());
	TopoShape infinitePlane1 = MakePrism(MakeEdge(line, 0.0, 1.0), Direction3(-1.0, 0.0, 0.0), false);
	TopoShape infinitePlane2 = MakePrism(MakeEdge(line, 0.0, 1.0), Direction3(1.0, 0.0, 0.0), false);
	TopoShape infinitePlane3 = MakePrism(MakeEdge(line, 0.0, 1.0), Direction3(0.0, 1.0, 0.0), false);
	TopoShape infinitePlane4 = MakePrism(MakeEdge(line, 0.0, 1.0), Direction3(0.0, -1.0, 0.0), false);
	std::vector<Point3> poles{ Point3(1.0, 0.0, 0.0), Point3(0.8, 0.0, 0.5), Point3(1.0, 0.0, 1.0) };
	auto bz = std::make_shared<Geom3BezierCurve>(poles);
	TopoEdge e2 = MakeEdge(bz);
	TopoShape revolshape = MakeRevol(e2, CartesianCoordinateSystem::OZ());
	auto surface1 = std::make_shared<Geom3CylindricalSurface>(Frame3(), 1.0);
	auto surface2 = TopoTool::Surface(TopoCast::Face(revolshape));
	TopoShape result1 = BoolBRepSection(infinitePlane1, surface2); 
	TopoShape result2 = BoolBRepSection(infinitePlane2, surface2); 
	TopoShape result3 = BoolBRepSection(infinitePlane3, surface2); 
	TopoShape result4 = BoolBRepSection(infinitePlane4, surface2); 
	GlobalProperty prop1, prop2, prop3, prop4 ;
	CHECK( GetLinearProperties(result1, prop1, true, false) == Approx(1.0260606301));
	CHECK( GetLinearProperties(result2, prop1, true, false) == Approx(1.0260606301));
	CHECK( GetLinearProperties(result3, prop1, true, false) == Approx(1.0260606301));
	CHECK( GetLinearProperties(result4, prop1, true, false) == Approx(1.0260606301));
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API BoolBRepSection(const TopoShape& s1, const Plane& p1, bool perfomNow = true)	 @param perfomNow If true, the operation is performed immediately; if false, the Build() function has to be called manually
	 @param p1 The tool plane
	 @param s1 The argument shape
	 @brief Special case: compute the section of a shape and an infinite plane
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <boolean/BoolBRepSection.hpp>
#include <common/CartesianCoordinateSystem.hpp>
#include <math/LineT.hpp>
#include <modeling/MakePrism.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeFace.hpp>
#include <geometry/Geom3BezierCurve.hpp>
#include <modeling/MakeRevol.hpp>
#include <geometry/Geom3CylindricalSurface.hpp>
#include <topology/TopoTool.hpp>
using namespace AMCAX;
TEST_CASE("bug1: BoolBRepSection ", "[boolean][BoolBRepSection][fixbug]")
{
	Line3 line(CartesianCoordinateSystem::OZ());
	TopoShape infinitePlane1 = MakePrism(MakeEdge(line, 0.0, 1.0), Direction3(-1.0, 0.0, 0.0), false);
	TopoShape infinitePlane2 = MakePrism(MakeEdge(line, 0.0, 1.0), Direction3(1.0, 0.0, 0.0), false);
	TopoShape infinitePlane3 = MakePrism(MakeEdge(line, 0.0, 1.0), Direction3(0.0, 1.0, 0.0), false);
	TopoShape infinitePlane4 = MakePrism(MakeEdge(line, 0.0, 1.0), Direction3(0.0, -1.0, 0.0), false);
	std::vector<Point3> poles{ Point3(1.0, 0.0, 0.0), Point3(0.8, 0.0, 0.5), Point3(1.0, 0.0, 1.0) };
	auto bz = std::make_shared<Geom3BezierCurve>(poles);
	TopoEdge e2 = MakeEdge(bz);
	TopoShape revolshape = MakeRevol(e2, CartesianCoordinateSystem::OZ());
	auto surface1 = std::make_shared<Geom3CylindricalSurface>(Frame3(), 1.0);
	auto surface2 = TopoTool::Surface(TopoCast::Face(revolshape));
	TopoShape result1 = BoolBRepSection(infinitePlane1, surface2); 
	TopoShape result2 = BoolBRepSection(infinitePlane2, surface2); 
	TopoShape result3 = BoolBRepSection(infinitePlane3, surface2); 
	TopoShape result4 = BoolBRepSection(infinitePlane4, surface2); 
	GlobalProperty prop1, prop2, prop3, prop4 ;
	CHECK( GetLinearProperties(result1, prop1, true, false) == Approx(1.0260606301));
	CHECK( GetLinearProperties(result2, prop1, true, false) == Approx(1.0260606301));
	CHECK( GetLinearProperties(result3, prop1, true, false) == Approx(1.0260606301));
	CHECK( GetLinearProperties(result4, prop1, true, false) == Approx(1.0260606301));
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API BoolBRepSection(const TopoShape& s1, const std::shared_ptr<Geom3Surface>& surface, bool perfomNow = true)	 @param perfomNow If true, the operation is performed immediately; if false, the Build() function has to be called manually
	 @param surface The tool surface
	 @param s1 The argument shape
	 @brief Special case: compute the section of a shape and a surface
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <boolean/BoolBRepSection.hpp>
#include <common/CartesianCoordinateSystem.hpp>
#include <math/LineT.hpp>
#include <modeling/MakePrism.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeFace.hpp>
#include <geometry/Geom3BezierCurve.hpp>
#include <modeling/MakeRevol.hpp>
#include <geometry/Geom3CylindricalSurface.hpp>
#include <topology/TopoTool.hpp>
using namespace AMCAX;
TEST_CASE("bug1: BoolBRepSection ", "[boolean][BoolBRepSection][fixbug]")
{
	Line3 line(CartesianCoordinateSystem::OZ());
	TopoShape infinitePlane1 = MakePrism(MakeEdge(line, 0.0, 1.0), Direction3(-1.0, 0.0, 0.0), false);
	TopoShape infinitePlane2 = MakePrism(MakeEdge(line, 0.0, 1.0), Direction3(1.0, 0.0, 0.0), false);
	TopoShape infinitePlane3 = MakePrism(MakeEdge(line, 0.0, 1.0), Direction3(0.0, 1.0, 0.0), false);
	TopoShape infinitePlane4 = MakePrism(MakeEdge(line, 0.0, 1.0), Direction3(0.0, -1.0, 0.0), false);
	std::vector<Point3> poles{ Point3(1.0, 0.0, 0.0), Point3(0.8, 0.0, 0.5), Point3(1.0, 0.0, 1.0) };
	auto bz = std::make_shared<Geom3BezierCurve>(poles);
	TopoEdge e2 = MakeEdge(bz);
	TopoShape revolshape = MakeRevol(e2, CartesianCoordinateSystem::OZ());
	auto surface1 = std::make_shared<Geom3CylindricalSurface>(Frame3(), 1.0);
	auto surface2 = TopoTool::Surface(TopoCast::Face(revolshape));
	TopoShape result1 = BoolBRepSection(infinitePlane1, surface2); 
	TopoShape result2 = BoolBRepSection(infinitePlane2, surface2); 
	TopoShape result3 = BoolBRepSection(infinitePlane3, surface2); 
	TopoShape result4 = BoolBRepSection(infinitePlane4, surface2); 
	GlobalProperty prop1, prop2, prop3, prop4 ;
	CHECK( GetLinearProperties(result1, prop1, true, false) == Approx(1.0260606301));
	CHECK( GetLinearProperties(result2, prop1, true, false) == Approx(1.0260606301));
	CHECK( GetLinearProperties(result3, prop1, true, false) == Approx(1.0260606301));
	CHECK( GetLinearProperties(result4, prop1, true, false) == Approx(1.0260606301));
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API BoolBRepSection(const std::shared_ptr<Geom3Surface>& surface, const TopoShape& s2, bool perfomNow = true)	 @param perfomNow If true, the operation is performed immediately; if false, the Build() function has to be called manually
	 @param s2 The tool shape
	 @param surface The argument surface
	 @brief Special case: compute the section of a surface and a shape
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <boolean/BoolBRepSection.hpp>
#include <common/CartesianCoordinateSystem.hpp>
#include <math/LineT.hpp>
#include <modeling/MakePrism.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeFace.hpp>
#include <geometry/Geom3BezierCurve.hpp>
#include <modeling/MakeRevol.hpp>
#include <geometry/Geom3CylindricalSurface.hpp>
#include <topology/TopoTool.hpp>
using namespace AMCAX;
TEST_CASE("bug1: BoolBRepSection ", "[boolean][BoolBRepSection][fixbug]")
{
	Line3 line(CartesianCoordinateSystem::OZ());
	TopoShape infinitePlane1 = MakePrism(MakeEdge(line, 0.0, 1.0), Direction3(-1.0, 0.0, 0.0), false);
	TopoShape infinitePlane2 = MakePrism(MakeEdge(line, 0.0, 1.0), Direction3(1.0, 0.0, 0.0), false);
	TopoShape infinitePlane3 = MakePrism(MakeEdge(line, 0.0, 1.0), Direction3(0.0, 1.0, 0.0), false);
	TopoShape infinitePlane4 = MakePrism(MakeEdge(line, 0.0, 1.0), Direction3(0.0, -1.0, 0.0), false);
	std::vector<Point3> poles{ Point3(1.0, 0.0, 0.0), Point3(0.8, 0.0, 0.5), Point3(1.0, 0.0, 1.0) };
	auto bz = std::make_shared<Geom3BezierCurve>(poles);
	TopoEdge e2 = MakeEdge(bz);
	TopoShape revolshape = MakeRevol(e2, CartesianCoordinateSystem::OZ());
	auto surface1 = std::make_shared<Geom3CylindricalSurface>(Frame3(), 1.0);
	auto surface2 = TopoTool::Surface(TopoCast::Face(revolshape));
	TopoShape result1 = BoolBRepSection(infinitePlane1, surface2); 
	TopoShape result2 = BoolBRepSection(infinitePlane2, surface2); 
	TopoShape result3 = BoolBRepSection(infinitePlane3, surface2); 
	TopoShape result4 = BoolBRepSection(infinitePlane4, surface2); 
	GlobalProperty prop1, prop2, prop3, prop4 ;
	CHECK( GetLinearProperties(result1, prop1, true, false) == Approx(1.0260606301));
	CHECK( GetLinearProperties(result2, prop1, true, false) == Approx(1.0260606301));
	CHECK( GetLinearProperties(result3, prop1, true, false) == Approx(1.0260606301));
	CHECK( GetLinearProperties(result4, prop1, true, false) == Approx(1.0260606301));
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API BoolBRepSection(const std::shared_ptr<Geom3Surface>& s1, const std::shared_ptr<Geom3Surface>& s2, bool perfomNow = true)	 @param perfomNow If true, the operation is performed immediately; if false, the Build() function has to be called manually
	 @param s2 The tool surface
	 @param s1 The argument surface
	 @brief Special case: compute the section of two surfaces
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <boolean/BoolBRepSection.hpp>
#include <common/CartesianCoordinateSystem.hpp>
#include <math/LineT.hpp>
#include <modeling/MakePrism.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeFace.hpp>
#include <geometry/Geom3BezierCurve.hpp>
#include <modeling/MakeRevol.hpp>
#include <geometry/Geom3CylindricalSurface.hpp>
#include <topology/TopoTool.hpp>
using namespace AMCAX;
TEST_CASE("bug1: BoolBRepSection ", "[boolean][BoolBRepSection][fixbug]")
{
	Line3 line(CartesianCoordinateSystem::OZ());
	TopoShape infinitePlane1 = MakePrism(MakeEdge(line, 0.0, 1.0), Direction3(-1.0, 0.0, 0.0), false);
	TopoShape infinitePlane2 = MakePrism(MakeEdge(line, 0.0, 1.0), Direction3(1.0, 0.0, 0.0), false);
	TopoShape infinitePlane3 = MakePrism(MakeEdge(line, 0.0, 1.0), Direction3(0.0, 1.0, 0.0), false);
	TopoShape infinitePlane4 = MakePrism(MakeEdge(line, 0.0, 1.0), Direction3(0.0, -1.0, 0.0), false);
	std::vector<Point3> poles{ Point3(1.0, 0.0, 0.0), Point3(0.8, 0.0, 0.5), Point3(1.0, 0.0, 1.0) };
	auto bz = std::make_shared<Geom3BezierCurve>(poles);
	TopoEdge e2 = MakeEdge(bz);
	TopoShape revolshape = MakeRevol(e2, CartesianCoordinateSystem::OZ());
	auto surface1 = std::make_shared<Geom3CylindricalSurface>(Frame3(), 1.0);
	auto surface2 = TopoTool::Surface(TopoCast::Face(revolshape));
	TopoShape result1 = BoolBRepSection(infinitePlane1, surface2); 
	TopoShape result2 = BoolBRepSection(infinitePlane2, surface2); 
	TopoShape result3 = BoolBRepSection(infinitePlane3, surface2); 
	TopoShape result4 = BoolBRepSection(infinitePlane4, surface2); 
	GlobalProperty prop1, prop2, prop3, prop4 ;
	CHECK( GetLinearProperties(result1, prop1, true, false) == Approx(1.0260606301));
	CHECK( GetLinearProperties(result2, prop1, true, false) == Approx(1.0260606301));
	CHECK( GetLinearProperties(result3, prop1, true, false) == Approx(1.0260606301));
	CHECK( GetLinearProperties(result4, prop1, true, false) == Approx(1.0260606301));
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API void SimplifyResult(bool isUnfiyEdges = true, bool isUnifyFaces = true, double angularTol = Precision::Angular()	 @param angularTol The angular tolerance for checking parallel
	 @param isUnifyFaces Set whether unify faces
	 @param isUnfiyEdges Set whether unify edges
	 @brief Simplify the boolean result, remove redundant edges and faces
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <boolean/BoolBuilder.hpp>
#include <modeling/MakeBox.hpp>
#include <boolean/BoolBRepFuse.hpp>
#include <common/IndexSet.hpp>
#include <topology/TopoExplorerTool.hpp>
using namespace AMCAX;
TEST_CASE("case1: BoolBuilder added SimplifyResult() API at 3.6.0. ", "[boolean][BoolBuilder][P1]") {
	TopoShape box1 = MakeBox(Point3(0., 0., 0.), Point3(2., 2., 2.));
	TopoShape box2 = MakeBox(Point3(1., 1., 0.), Point3(3., 3., 2.));
	BoolBRepFuse fuse(box1, box2);
	TopoShape shape1 = fuse.Shape();
	fuse.SimplifyResult();
	TopoShape shape2 = fuse.Shape();
	IndexSet<TopoShape> shape1Faces, shape2Faces;
	TopoExplorerTool::MapShapes(shape1, ShapeType::Face, shape1Faces);
	TopoExplorerTool::MapShapes(shape2, ShapeType::Face, shape2Faces);
	std::cout << shape1Faces.size() << "  " << shape2Faces.size() << std::endl;
	CHECK(shape1Faces.size() == 14);
	CHECK(shape2Faces.size() == 10);
}
#include<catch.hpp>
#include<testHelper.h>
#include <boolean/BoolBuilder.hpp>
#include <modeling/MakeBox.hpp>
#include <boolean/BoolBRepFuse.hpp>
#include <common/IndexSet.hpp>
#include <topology/TopoExplorerTool.hpp>
using namespace AMCAX;
TEST_CASE("case1: BoolBuilder added SimplifyResult() API at 3.6.0. ", "[boolean][BoolBuilder][P1]") {
	TopoShape box1 = MakeBox(Point3(0., 0., 0.), Point3(2., 2., 2.));
	TopoShape box2 = MakeBox(Point3(1., 1., 0.), Point3(3., 3., 2.));
	BoolBRepFuse fuse(box1, box2);
	TopoShape shape1 = fuse.Shape();
	fuse.SimplifyResult();
	TopoShape shape2 = fuse.Shape();
	IndexSet<TopoShape> shape1Faces, shape2Faces;
	TopoExplorerTool::MapShapes(shape1, ShapeType::Face, shape1Faces);
	TopoExplorerTool::MapShapes(shape2, ShapeType::Face, shape2Faces);
	std::cout << shape1Faces.size() << "  " << shape2Faces.size() << std::endl;
	CHECK(shape1Faces.size() == 14);
	CHECK(shape2Faces.size() == 10);
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar, typename OtherScalar2> AxisT(const PointT<OtherScalar, DIM>& point, const DirectionT<OtherScalar2, DIM>& dir),
 "output":#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {
	return result.Location().IsEqual(expected.Location(), tol) &&
		result.Direction().IsEqual(expected.Direction(), tol);
}
#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {
	return result.Location().IsEqual(expected.Location(), tol) &&
		result.Direction().IsEqual(expected.Direction(), tol);
;
	SECTION("Rotate 2D") {
		AxisT<double, 2> a1(PointT<double, 2>{1.0, 2.0}, DirectionT<double, 2>{1.0, 2.0});
		PointT<double, 2> p(2.0, 3.0);
		AxisT<double, 2> a2(PointT<double, 2>{3.0, 2.0}, DirectionT<double, 2>{-2.0, 1.0});
		CHECK(IsEqual(a1.Rotated(p, M_PI_2), a2));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar, typename OtherScalar2, typename OtherScalar3, int DIM2 = DIM, std::enable_if_t<DIM2 == 2, int> = 0> [[nodiscard]] bool IsCoaxial(const AxisT<OtherScalar, DIM>& other, const OtherScalar2& angtol, const OtherScalar3& distol),
 "output":#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {
	return result.Location().IsEqual(expected.Location(), tol) &&
		result.Direction().IsEqual(expected.Direction(), tol);
}
#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {
	return result.Location().IsEqual(expected.Location(), tol) &&
		result.Direction().IsEqual(expected.Direction(), tol);
;
	SECTION("IsCoaxial 2D") {
		AxisT<double, 2> a1(PointT<double, 2>{0.0, 0.0}, DirectionT<double, 2>{1.0, 2.0});
		AxisT<double, 2> a2(PointT<double, 2>{2.0, 4.0}, DirectionT<double, 2>{1.0, 2.0});
		AxisT<double, 2> a3(PointT<double, 2>{2.0, 4.0}, DirectionT<double, 2>{2.0, 2.0});
		AxisT<double, 2> a4(PointT<double, 2>{1.0, 4.0}, DirectionT<double, 2>{1.0, 2.0});
		CHECK(a1.IsCoaxial(a2, 1e-6, 1e-6) == true);
		CHECK(a1.IsCoaxial(a3, 1e-6, 1e-6) == false);
		CHECK(a1.IsCoaxial(a4, 1e-6, 1e-6) == false);
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar> AxisT& Mirror(const PointT<OtherScalar, DIM>& point),
 "output":#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {
	return result.Location().IsEqual(expected.Location(), tol) &&
		result.Direction().IsEqual(expected.Direction(), tol);
}
#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {
	return result.Location().IsEqual(expected.Location(), tol) &&
		result.Direction().IsEqual(expected.Direction(), tol);
;
	SECTION("Mirror(point) 2D") {
		AxisT<double, 2> a1(PointT<double, 2>{1.0, 2.0}, DirectionT<double, 2>{1.0, 1.0});
		PointT<double, 2> p(3.0, 4.0);
		AxisT<double, 2> a2(PointT<double, 2>{5.0, 6.0}, DirectionT<double, 2>{-1.0, -1.0});
		CHECK(IsEqual(a1.Mirrored(p), a2));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar> [[nodiscard]] AxisT Mirrored(const PointT<OtherScalar, DIM>& point),
 "output":#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {
	return result.Location().IsEqual(expected.Location(), tol) &&
		result.Direction().IsEqual(expected.Direction(), tol);
}
#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {
	return result.Location().IsEqual(expected.Location(), tol) &&
		result.Direction().IsEqual(expected.Direction(), tol);
;
	SECTION("Mirror(axis) 2D") {
		AxisT<double, 2> a1(PointT<double, 2>{1.0, 2.0}, DirectionT<double, 2>{1.0, 2.0});
		AxisT<double, 2> a2(PointT<double, 2>{2.0, 2.0}, DirectionT<double, 2>{1.0, 1.0});
		AxisT<double, 2> a3(PointT<double, 2>{2.0, 1.0}, DirectionT<double, 2>{2.0, 1.0});
		CHECK(IsEqual(a1.Mirrored(a2), a3));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar> [[nodiscard]] AxisT Mirrored(const AxisT<OtherScalar, DIM>& axis),
 "output":#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {
	return result.Location().IsEqual(expected.Location(), tol) &&
		result.Direction().IsEqual(expected.Direction(), tol);
}
#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {
	return result.Location().IsEqual(expected.Location(), tol) &&
		result.Direction().IsEqual(expected.Direction(), tol);
;
	SECTION("Mirror(point) 2D") {
		AxisT<double, 2> a1(PointT<double, 2>{1.0, 2.0}, DirectionT<double, 2>{1.0, 1.0});
		PointT<double, 2> p(3.0, 4.0);
		AxisT<double, 2> a2(PointT<double, 2>{5.0, 6.0}, DirectionT<double, 2>{-1.0, -1.0});
		CHECK(IsEqual(a1.Mirrored(p), a2));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar, typename OtherScalar2, int DIM2 = DIM, typename = typename std::enable_if_t<DIM2 == 2>> [[nodiscard]] AxisT Rotated(const PointT<OtherScalar, DIM>& point, const OtherScalar2& angle),
 "output":#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {
	return result.Location().IsEqual(expected.Location(), tol) &&
		result.Direction().IsEqual(expected.Direction(), tol);
}
#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {
	return result.Location().IsEqual(expected.Location(), tol) &&
		result.Direction().IsEqual(expected.Direction(), tol);
;
	SECTION("Rotate 2D") {
		AxisT<double, 2> a1(PointT<double, 2>{1.0, 2.0}, DirectionT<double, 2>{1.0, 2.0});
		PointT<double, 2> p(2.0, 3.0);
		AxisT<double, 2> a2(PointT<double, 2>{3.0, 2.0}, DirectionT<double, 2>{-2.0, 1.0});
		CHECK(IsEqual(a1.Rotated(p, M_PI_2), a2));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar> [[nodiscard]] AxisT Translated(const VectorT<OtherScalar, DIM>& vec),
 "output":#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {
	return result.Location().IsEqual(expected.Location(), tol) &&
		result.Direction().IsEqual(expected.Direction(), tol);
}
#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {
	return result.Location().IsEqual(expected.Location(), tol) &&
		result.Direction().IsEqual(expected.Direction(), tol);
;
	SECTION("Translate(vec) 2D") {
		AxisT<double, 2> a1(PointT<double, 2>(1.0, 2.0), DirectionT<double, 2>{1.0, 2.0});
		VectorT<double, 2> v(2.0, 3.0);
		AxisT<double, 2> a2(PointT<double, 2>(3.0, 5.0), DirectionT<double, 2>{1.0, 2.0});
		CHECK(IsEqual(a1.Translated(v), a2));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar, typename OtherScalar2> [[nodiscard]] AxisT Translated(const PointT<OtherScalar, DIM>& p1, const PointT<OtherScalar2, DIM>& p2),
 "output":#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {
	return result.Location().IsEqual(expected.Location(), tol) &&
		result.Direction().IsEqual(expected.Direction(), tol);
}
#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {
	return result.Location().IsEqual(expected.Location(), tol) &&
		result.Direction().IsEqual(expected.Direction(), tol);
;
	SECTION("Translate(p1, p2) 2D") {
		AxisT<double, 2> a1(PointT<double, 2>(1.0, 2.0), DirectionT<double, 2>{1.0, 2.0});
		PointT<double, 2> p1(2.0, 3.0);
		PointT<double, 2> p2(4.0, 2.0);
		AxisT<double, 2> a2(PointT<double, 2>(3.0, 1.0), DirectionT<double, 2>{1.0, 2.0});
		CHECK(IsEqual(a1.Translated(p1, p2), a2));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AxisT()	 @details The default location is (0, 0, 0). In 2D, the default direction is (1, 0); in 3D, the default direction is (0, 0, 1).
	 @brief Default constructor
,
 "output":#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected){
	return result.Location().IsEqual(expected.Location(), tol) &&
		result.Direction().IsEqual(expected.Direction(), tol);
}
#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected){
	return result.Location().IsEqual(expected.Location(), tol) &&
		result.Direction().IsEqual(expected.Direction(), tol);
;
	SECTION("default constructor 3D"){
		AxisT<double, 3> a1;
		AxisT<double, 3> a2(PointT<double, 3>{0.0, 0.0, 0.0}, DirectionT<double, 3>{0.0, 0.0, 1.0});
		CHECK(IsEqual(a1, a2));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar, typename OtherScalar2> AxisT(const PointT<OtherScalar, DIM>& point, const DirectionT<OtherScalar2, DIM>& dir),
 "output":#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected){
	return result.Location().IsEqual(expected.Location(), tol) &&
		result.Direction().IsEqual(expected.Direction(), tol);
}
#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected){
	return result.Location().IsEqual(expected.Location(), tol) &&
		result.Direction().IsEqual(expected.Direction(), tol);
;
	SECTION("Translate(p1, p2) 3D"){
		AxisT<double, 3> a1(PointT<double, 3>(1.0, 2.0, 3.0), DirectionT<double, 3>{1.0, 2.0, 3.0});
		PointT<double, 3> p1(2.0, 3.0, 4.0);
		PointT<double, 3> p2(4.0, 2.0, 3.0);
		AxisT<double, 3> a2(PointT<double, 3>(3.0, 1.0, 2.0), DirectionT<double, 3>{1.0, 2.0, 3.0});
		CHECK(IsEqual(a1.Translated(p1, p2), a2));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar> void SetDirection(const DirectionT<OtherScalar, DIM>& dir),
 "output":#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected){
	return result.Location().IsEqual(expected.Location(), tol) &&
		result.Direction().IsEqual(expected.Direction(), tol);
}
#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected){
	return result.Location().IsEqual(expected.Location(), tol) &&
		result.Direction().IsEqual(expected.Direction(), tol);
;
	SECTION("SetDirection"){
		AxisT<double, 3> a1;
		DirectionT<double, 3> d(1.0, 2.0, 3.0);
		a1.SetDirection(d);
		AxisT<double, 3> a2(PointT<double, 3>{0.0, 0.0, 0.0}, d);
		CHECK(IsEqual(a1, a2));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar, typename OtherScalar2, typename OtherScalar3, int DIM2 = DIM, std::enable_if_t<DIM2 == 2, int> = 0> [[nodiscard]] bool IsCoaxial(const AxisT<OtherScalar, DIM>& other, const OtherScalar2& angtol, const OtherScalar3& distol),
 "output":#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected){
	return result.Location().IsEqual(expected.Location(), tol) &&
		result.Direction().IsEqual(expected.Direction(), tol);
}
#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected){
	return result.Location().IsEqual(expected.Location(), tol) &&
		result.Direction().IsEqual(expected.Direction(), tol);
;
	SECTION("IsCoaxial 3D"){
		AxisT<double, 3> a1(PointT<double, 3>{0.0, 0.0, 0.0}, DirectionT<double, 3>{1.0, 2.0, 3.0});
		AxisT<double, 3> a2(PointT<double, 3>{2.0, 4.0, 6.0}, DirectionT<double, 3>{1.0, 2.0, 3.0});
		AxisT<double, 3> a3(PointT<double, 3>{2.0, 4.0, 6.0}, DirectionT<double, 3>{2.0, 2.0, 3.0});
		AxisT<double, 3> a4(PointT<double, 3>{1.0, 4.0, 6.0}, DirectionT<double, 3>{1.0, 2.0, 3.0});
		CHECK(a1.IsCoaxial(a2, 1e-6, 1e-6) == true);
		CHECK(a1.IsCoaxial(a3, 1e-6, 1e-6) == false);
		CHECK(a1.IsCoaxial(a4, 1e-6, 1e-6) == false);
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar, typename OtherScalar2, typename OtherScalar3, int DIM2 = DIM, std::enable_if_t<DIM2 == 3, int> = 0> [[nodiscard]] bool IsCoaxial(const AxisT<OtherScalar, DIM>& other, const OtherScalar2& angtol, const OtherScalar3& distol),
 "output":#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected){
	return result.Location().IsEqual(expected.Location(), tol) &&
		result.Direction().IsEqual(expected.Direction(), tol);
}
#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected){
	return result.Location().IsEqual(expected.Location(), tol) &&
		result.Direction().IsEqual(expected.Direction(), tol);
;
	SECTION("IsCoaxial 3D"){
		AxisT<double, 3> a1(PointT<double, 3>{0.0, 0.0, 0.0}, DirectionT<double, 3>{1.0, 2.0, 3.0});
		AxisT<double, 3> a2(PointT<double, 3>{2.0, 4.0, 6.0}, DirectionT<double, 3>{1.0, 2.0, 3.0});
		AxisT<double, 3> a3(PointT<double, 3>{2.0, 4.0, 6.0}, DirectionT<double, 3>{2.0, 2.0, 3.0});
		AxisT<double, 3> a4(PointT<double, 3>{1.0, 4.0, 6.0}, DirectionT<double, 3>{1.0, 2.0, 3.0});
		CHECK(a1.IsCoaxial(a2, 1e-6, 1e-6) == true);
		CHECK(a1.IsCoaxial(a3, 1e-6, 1e-6) == false);
		CHECK(a1.IsCoaxial(a4, 1e-6, 1e-6) == false);
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar> [[nodiscard]] double Angle(const AxisT<OtherScalar, DIM>& other),
 "output":#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected){
	return result.Location().IsEqual(expected.Location(), tol) &&
		result.Direction().IsEqual(expected.Direction(), tol);
}
#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected){
	return result.Location().IsEqual(expected.Location(), tol) &&
		result.Direction().IsEqual(expected.Direction(), tol);
;
	SECTION("Angle"){
		AxisT<double, 3> a1(PointT<double, 3>{0.0, 0.0, 0.0}, DirectionT<double, 3>{1.0, 2.0, 1.0});
		AxisT<double, 3> a2(PointT<double, 3>{2.0, 4.0, 3.0}, DirectionT<double, 3>{-1.0, 1.0, -1.0});
		CHECK(a1.Angle(a2) == M_PI_2);
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar> AxisT& Mirror(const PointT<OtherScalar, DIM>& point),
 "output":#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected){
	return result.Location().IsEqual(expected.Location(), tol) &&
		result.Direction().IsEqual(expected.Direction(), tol);
}
#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected){
	return result.Location().IsEqual(expected.Location(), tol) &&
		result.Direction().IsEqual(expected.Direction(), tol);
;
	SECTION("Mirror(point) 3D"){
		AxisT<double, 3> a1(PointT<double, 3>{1.0, 2.0, 3.0}, DirectionT<double, 3>{1.0, 1.0, 1.0});
		PointT<double, 3> p(2.0, 4.0, 5.0);
		AxisT<double, 3> a2(PointT<double, 3>{3.0, 6.0, 7.0}, DirectionT<double, 3>{-1.0, -1.0, -1.0});
		CHECK(IsEqual(a1.Mirrored(p), a2));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar, int DIM2 = DIM, std::enable_if_t<DIM2 == 3, int> = 0> AxisT& Mirror(const FrameT<OtherScalar, DIM>& frame),
 "output":#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected){
	return result.Location().IsEqual(expected.Location(), tol) &&
		result.Direction().IsEqual(expected.Direction(), tol);
}
#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected){
	return result.Location().IsEqual(expected.Location(), tol) &&
		result.Direction().IsEqual(expected.Direction(), tol);
;
	SECTION("Mirror(frame) 3D"){
		AxisT<double, 3> a1(PointT<double, 3>{1.0, 2.0, 3.0}, DirectionT<double, 3>{1.0, 2.0, 3.0});
		FrameT<double, 3> f(PointT<double, 3>{2.0, 3.0, 4.0}, DirectionT<double, 3>{7.0, 3.0, 2.0});
		AxisT<double, 3> a2(PointT<double, 3>{115.0 / 31.0, 98.0 / 31.0, 117.0 / 31.0}, DirectionT<double, 3>{-102.0 / 31.0, 5.0 / 31.0, 55.0 / 31.0});
		CHECK(IsEqual(a1.Mirror(f), a2));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar> [[nodiscard]] AxisT Mirrored(const PointT<OtherScalar, DIM>& point),
 "output":#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected){
	return result.Location().IsEqual(expected.Location(), tol) &&
		result.Direction().IsEqual(expected.Direction(), tol);
}
#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected){
	return result.Location().IsEqual(expected.Location(), tol) &&
		result.Direction().IsEqual(expected.Direction(), tol);
;
	SECTION("Mirror(point) 3D"){
		AxisT<double, 3> a1(PointT<double, 3>{1.0, 2.0, 3.0}, DirectionT<double, 3>{1.0, 1.0, 1.0});
		PointT<double, 3> p(2.0, 4.0, 5.0);
		AxisT<double, 3> a2(PointT<double, 3>{3.0, 6.0, 7.0}, DirectionT<double, 3>{-1.0, -1.0, -1.0});
		CHECK(IsEqual(a1.Mirrored(p), a2));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar> [[nodiscard]] AxisT Mirrored(const AxisT<OtherScalar, DIM>& axis),
 "output":#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected){
	return result.Location().IsEqual(expected.Location(), tol) &&
		result.Direction().IsEqual(expected.Direction(), tol);
}
#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected){
	return result.Location().IsEqual(expected.Location(), tol) &&
		result.Direction().IsEqual(expected.Direction(), tol);
;
	SECTION("Mirror(point) 3D"){
		AxisT<double, 3> a1(PointT<double, 3>{1.0, 2.0, 3.0}, DirectionT<double, 3>{1.0, 1.0, 1.0});
		PointT<double, 3> p(2.0, 4.0, 5.0);
		AxisT<double, 3> a2(PointT<double, 3>{3.0, 6.0, 7.0}, DirectionT<double, 3>{-1.0, -1.0, -1.0});
		CHECK(IsEqual(a1.Mirrored(p), a2));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar, int DIM2 = DIM, std::enable_if_t<DIM2 == 3, int> = 0> [[nodiscard]] AxisT Mirrored(const FrameT<OtherScalar, DIM>& frame),
 "output":#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected){
	return result.Location().IsEqual(expected.Location(), tol) &&
		result.Direction().IsEqual(expected.Direction(), tol);
}
#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected){
	return result.Location().IsEqual(expected.Location(), tol) &&
		result.Direction().IsEqual(expected.Direction(), tol);
;
	SECTION("Mirror(axis) 3D"){
		AxisT<double, 3> a1(PointT<double, 3>{1.0, 2.0, 3.0}, DirectionT<double, 3>{1.0, 2.0, 3.0});
		AxisT<double, 3> a2(PointT<double, 3>{2.0, 3.0, 4.0}, DirectionT<double, 3>{7.0, 3.0, 2.0});
		AxisT<double, 3> a3(PointT<double, 3>{9.0 / 31.0, 88.0 / 31.0, 131.0 / 31.0}, DirectionT<double, 3>{102.0 / 31.0, -5.0 / 31.0, -55.0 / 31.0});
		CHECK(IsEqual(a1.Mirrored(a2), a3));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar, typename OtherScalar2> [[nodiscard]] AxisT Scaled(const PointT<OtherScalar, DIM> point, const OtherScalar2& scale),
 "output":#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected){
	return result.Location().IsEqual(expected.Location(), tol) &&
		result.Direction().IsEqual(expected.Direction(), tol);
}
#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected){
	return result.Location().IsEqual(expected.Location(), tol) &&
		result.Direction().IsEqual(expected.Direction(), tol);
;
	SECTION("Scale 3D"){
		AxisT<double, 3> a1(PointT<double, 3>{1.0, 2.0, 3.0}, DirectionT<double, 3>{1.0, 2.0, 3.0});
		PointT<double, 3> p(2.0, 3.0, 4.0);
		AxisT<double, 3> a2(PointT<double, 3>{0.5, 1.5, 2.5}, DirectionT<double, 3>{1.0, 2.0, 3.0});
		CHECK(IsEqual(a1.Scaled(p, 1.5), a2));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar, typename OtherScalar2> [[nodiscard]] AxisT Translated(const PointT<OtherScalar, DIM>& p1, const PointT<OtherScalar2, DIM>& p2),
 "output":#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected){
	return result.Location().IsEqual(expected.Location(), tol) &&
		result.Direction().IsEqual(expected.Direction(), tol);
}
#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected){
	return result.Location().IsEqual(expected.Location(), tol) &&
		result.Direction().IsEqual(expected.Direction(), tol);
;
	SECTION("Translate(p1, p2) 3D"){
		AxisT<double, 3> a1(PointT<double, 3>(1.0, 2.0, 3.0), DirectionT<double, 3>{1.0, 2.0, 3.0});
		PointT<double, 3> p1(2.0, 3.0, 4.0);
		PointT<double, 3> p2(4.0, 2.0, 3.0);
		AxisT<double, 3> a2(PointT<double, 3>(3.0, 1.0, 2.0), DirectionT<double, 3>{1.0, 2.0, 3.0});
		CHECK(IsEqual(a1.Translated(p1, p2), a2));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] const PointT<Scalar, DIM>& Location()	 @return The location
	 @brief Get the location
,
 "output":#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);
	}
	else if constexpr (DIM == 2)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else if constexpr (DIM == 3)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else
	{
		return false;
	}
}
#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);
	}
	else if constexpr (DIM == 2)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else if constexpr (DIM == 3)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else
	{
		return false;
	}
;
	SECTION("SetYAxis 2D") {
		PointT<double, 2> p(1.0, 2.0);
		PointT<double, 2> p2(3.0, 1.0);
		DirectionT<double, 2> dx(1.0, 3.0);
		DirectionT<double, 2> dy(-3.0, 1.0);
		FrameT<double, 2> f1(p, dx);
		DirectionT<double, 2> dx2(-1.0, -2.0);
		FrameT<double, 2> f2(p2, dx2);
		AxisT<double, 2> axis(p, dy);
		f2.SetYAxis(axis);
		CHECK(IsEqual(f1, f2));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar, typename OtherScalar2, typename OtherScalar3, int DIM2 = DIM, std::enable_if_t<DIM2 == 2, int> = 0> FrameT(const PointT<OtherScalar, DIM>& point, const DirectionT<OtherScalar2, DIM>& xdir, const DirectionT<OtherScalar3, DIM>& ydir),
 "output":#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);
	}
	else if constexpr (DIM == 2)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else if constexpr (DIM == 3)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else
	{
		return false;
	}
}
#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);
	}
	else if constexpr (DIM == 2)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else if constexpr (DIM == 3)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else
	{
		return false;
	}
;
	SECTION("Construction 2D") {
		PointT<double, 2> p(0.0, 0.0);
		DirectionT<double, 2> dx(1.0, 0.0);
		DirectionT<double, 2> dy(0.0, 1.0);
		FrameT<double, 2> f1;
		FrameT<double, 2> f2(p, dx, dy);
		CHECK(IsEqual(f1, f2));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar, typename OtherScalar2, int DIM2 = DIM, std::enable_if_t<DIM2 == 2, int> = 0> FrameT(const PointT<OtherScalar, DIM>& point, const DirectionT<OtherScalar2, DIM>& xdir, bool isright = true),
 "output":#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);
	}
	else if constexpr (DIM == 2)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else if constexpr (DIM == 3)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else
	{
		return false;
	}
}
#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);
	}
	else if constexpr (DIM == 2)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else if constexpr (DIM == 3)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else
	{
		return false;
	}
;
	SECTION("Construction 2D") {
		PointT<double, 2> p(0.0, 0.0);
		DirectionT<double, 2> dx(1.0, 0.0);
		DirectionT<double, 2> dy(0.0, 1.0);
		FrameT<double, 2> f1;
		FrameT<double, 2> f2(p, dx, dy);
		CHECK(IsEqual(f1, f2));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar, int DIM2 = DIM, std::enable_if_t<DIM2 == 2, int> = 0> explicit FrameT(const AxisT<OtherScalar, DIM>& axis, bool isright = true),
 "output":#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);
	}
	else if constexpr (DIM == 2)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else if constexpr (DIM == 3)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else
	{
		return false;
	}
}
#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);
	}
	else if constexpr (DIM == 2)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else if constexpr (DIM == 3)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else
	{
		return false;
	}
;
	SECTION("Construction 2D") {
		PointT<double, 2> p(0.0, 0.0);
		DirectionT<double, 2> dx(1.0, 0.0);
		DirectionT<double, 2> dy(0.0, 1.0);
		FrameT<double, 2> f1;
		FrameT<double, 2> f2(p, dx, dy);
		CHECK(IsEqual(f1, f2));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar, typename OtherScalar2, int DIM2 = DIM, std::enable_if_t<DIM2 == 3, int> = 0> FrameT(const PointT<OtherScalar, DIM>& point, const DirectionT<OtherScalar2, DIM>& dir),
 "output":#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);
	}
	else if constexpr (DIM == 2)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else if constexpr (DIM == 3)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else
	{
		return false;
	}
}
#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);
	}
	else if constexpr (DIM == 2)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else if constexpr (DIM == 3)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else
	{
		return false;
	}
;
	SECTION("Mirror point 2D") {
		PointT<double, 2> p(1.0, 2.0);
		DirectionT<double, 2> d(1.0, 3.0);
		FrameT<double, 2> f1(p, d);
		PointT<double, 2> p2(2.0, 3.0);
		PointT<double, 2> p3(3.0, 4.0);
		DirectionT<double, 2> d2(-1.0, -3.0);
		FrameT<double, 2> f2(p3, d2);
		CHECK(IsEqual(f1.Mirrored(p2), f2));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar, int DIM2 = DIM, std::enable_if_t<DIM2 == 2, int> = 0> void SetXAxis(const AxisT<OtherScalar, DIM>& axis),
 "output":#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);
	}
	else if constexpr (DIM == 2)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else if constexpr (DIM == 3)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else
	{
		return false;
	}
}
#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);
	}
	else if constexpr (DIM == 2)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else if constexpr (DIM == 3)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else
	{
		return false;
	}
;
	SECTION("SetXAxis 2D") {
		PointT<double, 2> p(1.0, 2.0);
		PointT<double, 2> p2(3.0, 1.0);
		DirectionT<double, 2> dx(1.0, 3.0);
		FrameT<double, 2> f1(p, dx);
		DirectionT<double, 2> dx2(-1.0, -2.0);
		FrameT<double, 2> f2(p2, dx2);
		AxisT<double, 2> axis(p, dx);
		f2.SetXAxis(axis);
		CHECK(IsEqual(f1, f2));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar, int DIM2 = DIM, std::enable_if_t<DIM2 == 2, int> = 0> void SetYAxis(const AxisT<OtherScalar, DIM>& axis),
 "output":#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);
	}
	else if constexpr (DIM == 2)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else if constexpr (DIM == 3)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else
	{
		return false;
	}
}
#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);
	}
	else if constexpr (DIM == 2)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else if constexpr (DIM == 3)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else
	{
		return false;
	}
;
	SECTION("SetYAxis 2D") {
		PointT<double, 2> p(1.0, 2.0);
		PointT<double, 2> p2(3.0, 1.0);
		DirectionT<double, 2> dx(1.0, 3.0);
		DirectionT<double, 2> dy(-3.0, 1.0);
		FrameT<double, 2> f1(p, dx);
		DirectionT<double, 2> dx2(-1.0, -2.0);
		FrameT<double, 2> f2(p2, dx2);
		AxisT<double, 2> axis(p, dy);
		f2.SetYAxis(axis);
		CHECK(IsEqual(f1, f2));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar, int DIM2 = DIM, std::enable_if_t<DIM2 == 2, int> = 0> void SetXDirection(const DirectionT<OtherScalar, DIM>& x),
 "output":#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);
	}
	else if constexpr (DIM == 2)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else if constexpr (DIM == 3)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else
	{
		return false;
	}
}
#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);
	}
	else if constexpr (DIM == 2)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else if constexpr (DIM == 3)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else
	{
		return false;
	}
;
	SECTION("SetXDirection 2D") {
		PointT<double, 2> p(1.0, 2.0);
		DirectionT<double, 2> dx(1.0, 3.0);
		FrameT<double, 2> f1(p, dx);
		DirectionT<double, 2> dx2(-1.0, -2.0);
		FrameT<double, 2> f2(p, dx2);
		f2.SetXDirection(dx);
		CHECK(IsEqual(f1, f2));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar, int DIM2 = DIM, std::enable_if_t<DIM2 == 2, int> = 0> void SetYDirection(const DirectionT<OtherScalar, DIM>& y),
 "output":#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);
	}
	else if constexpr (DIM == 2)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else if constexpr (DIM == 3)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else
	{
		return false;
	}
}
#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);
	}
	else if constexpr (DIM == 2)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else if constexpr (DIM == 3)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else
	{
		return false;
	}
;
	SECTION("Construction 2D") {
		PointT<double, 2> p(0.0, 0.0);
		DirectionT<double, 2> dx(1.0, 0.0);
		DirectionT<double, 2> dy(0.0, 1.0);
		FrameT<double, 2> f1;
		FrameT<double, 2> f2(p, dx, dy);
		CHECK(IsEqual(f1, f2));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<int DIM2 = DIM, typename = typename std::enable_if_t<DIM2 >= 2>> [[nodiscard]] const DirectionT<Scalar, DIM>& YDirection(),
 "output":#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);
	}
	else if constexpr (DIM == 2)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else if constexpr (DIM == 3)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else
	{
		return false;
	}
}
#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);
	}
	else if constexpr (DIM == 2)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else if constexpr (DIM == 3)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else
	{
		return false;
	}
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar> FrameT& Mirror(const PointT<OtherScalar, DIM>& point),
 "output":#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);
	}
	else if constexpr (DIM == 2)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else if constexpr (DIM == 3)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else
	{
		return false;
	}
}
#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);
	}
	else if constexpr (DIM == 2)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else if constexpr (DIM == 3)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else
	{
		return false;
	}
;
	SECTION("Mirror point 2D") {
		PointT<double, 2> p(1.0, 2.0);
		DirectionT<double, 2> d(1.0, 3.0);
		FrameT<double, 2> f1(p, d);
		PointT<double, 2> p2(2.0, 3.0);
		PointT<double, 2> p3(3.0, 4.0);
		DirectionT<double, 2> d2(-1.0, -3.0);
		FrameT<double, 2> f2(p3, d2);
		CHECK(IsEqual(f1.Mirrored(p2), f2));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar> FrameT& Mirror(const AxisT<OtherScalar, DIM>& a),
 "output":#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);
	}
	else if constexpr (DIM == 2)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else if constexpr (DIM == 3)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else
	{
		return false;
	}
}
#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);
	}
	else if constexpr (DIM == 2)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else if constexpr (DIM == 3)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else
	{
		return false;
	}
;
	SECTION("Mirror point 2D") {
		PointT<double, 2> p(1.0, 2.0);
		DirectionT<double, 2> d(1.0, 3.0);
		FrameT<double, 2> f1(p, d);
		PointT<double, 2> p2(2.0, 3.0);
		PointT<double, 2> p3(3.0, 4.0);
		DirectionT<double, 2> d2(-1.0, -3.0);
		FrameT<double, 2> f2(p3, d2);
		CHECK(IsEqual(f1.Mirrored(p2), f2));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar> [[nodiscard]] FrameT Mirrored(const PointT<OtherScalar, DIM>& point),
 "output":#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);
	}
	else if constexpr (DIM == 2)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else if constexpr (DIM == 3)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else
	{
		return false;
	}
}
#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);
	}
	else if constexpr (DIM == 2)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else if constexpr (DIM == 3)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else
	{
		return false;
	}
;
	SECTION("Mirror point 2D") {
		PointT<double, 2> p(1.0, 2.0);
		DirectionT<double, 2> d(1.0, 3.0);
		FrameT<double, 2> f1(p, d);
		PointT<double, 2> p2(2.0, 3.0);
		PointT<double, 2> p3(3.0, 4.0);
		DirectionT<double, 2> d2(-1.0, -3.0);
		FrameT<double, 2> f2(p3, d2);
		CHECK(IsEqual(f1.Mirrored(p2), f2));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar> [[nodiscard]] FrameT Mirrored(const AxisT<OtherScalar, DIM>& a),
 "output":#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);
	}
	else if constexpr (DIM == 2)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else if constexpr (DIM == 3)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else
	{
		return false;
	}
}
#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);
	}
	else if constexpr (DIM == 2)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else if constexpr (DIM == 3)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else
	{
		return false;
	}
;
	SECTION("Mirror point 2D") {
		PointT<double, 2> p(1.0, 2.0);
		DirectionT<double, 2> d(1.0, 3.0);
		FrameT<double, 2> f1(p, d);
		PointT<double, 2> p2(2.0, 3.0);
		PointT<double, 2> p3(3.0, 4.0);
		DirectionT<double, 2> d2(-1.0, -3.0);
		FrameT<double, 2> f2(p3, d2);
		CHECK(IsEqual(f1.Mirrored(p2), f2));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar, typename OtherScalar2, int DIM2 = DIM, typename = typename std::enable_if_t<DIM2 == 2>> [[nodiscard]] FrameT Rotated(const PointT<OtherScalar, DIM>& point, const OtherScalar2& angle),
 "output":#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);
	}
	else if constexpr (DIM == 2)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else if constexpr (DIM == 3)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else
	{
		return false;
	}
}
#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);
	}
	else if constexpr (DIM == 2)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else if constexpr (DIM == 3)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else
	{
		return false;
	}
;
	SECTION("Construction 2D") {
		PointT<double, 2> p(0.0, 0.0);
		DirectionT<double, 2> dx(1.0, 0.0);
		DirectionT<double, 2> dy(0.0, 1.0);
		FrameT<double, 2> f1;
		FrameT<double, 2> f2(p, dx, dy);
		CHECK(IsEqual(f1, f2));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar, typename OtherScalar2> [[nodiscard]] FrameT Scaled(const PointT<OtherScalar, DIM>& point, const OtherScalar2& scale),
 "output":#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);
	}
	else if constexpr (DIM == 2)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else if constexpr (DIM == 3)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else
	{
		return false;
	}
}
#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);
	}
	else if constexpr (DIM == 2)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else if constexpr (DIM == 3)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else
	{
		return false;
	}
;
	SECTION("Scale 2D") {
		PointT<double, 2> p(1.0, 2.0);
		DirectionT<double, 2> d(1.0, 3.0);
		FrameT<double, 2> f1(p, d);
		PointT<double, 2> p2(2.0, 3.0);
		PointT<double, 2> p3(0.5, 1.5);
		FrameT<double, 2> f2(p3, d);
		CHECK(IsEqual(f1.Scaled(p2, 1.5), f2));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar> [[nodiscard]] FrameT Translated(const VectorT<OtherScalar, DIM>& vec),
 "output":#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);
	}
	else if constexpr (DIM == 2)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else if constexpr (DIM == 3)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else
	{
		return false;
	}
}
#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);
	}
	else if constexpr (DIM == 2)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else if constexpr (DIM == 3)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else
	{
		return false;
	}
;
	SECTION("Translate vector 2D") {
		PointT<double, 2> p(1.0, 2.0);
		DirectionT<double, 2> d(1.0, 3.0);
		FrameT<double, 2> f1(p, d);
		VectorT<double, 2> v(2.0, 3.0);
		PointT<double, 2> p2(3.0, 5.0);
		FrameT<double, 2> f2(p2, d);
		CHECK(IsEqual(f1.Translated(v), f2));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar, typename OtherScalar2> [[nodiscard]] FrameT Translated(const PointT<OtherScalar, DIM>& p1, const PointT<OtherScalar2, DIM>& p2),
 "output":#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);
	}
	else if constexpr (DIM == 2)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else if constexpr (DIM == 3)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else
	{
		return false;
	}
}
#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);
	}
	else if constexpr (DIM == 2)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else if constexpr (DIM == 3)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else
	{
		return false;
	}
;
	SECTION("Translate vector 2D") {
		PointT<double, 2> p(1.0, 2.0);
		DirectionT<double, 2> d(1.0, 3.0);
		FrameT<double, 2> f1(p, d);
		VectorT<double, 2> v(2.0, 3.0);
		PointT<double, 2> p2(3.0, 5.0);
		FrameT<double, 2> f2(p2, d);
		CHECK(IsEqual(f1.Translated(v), f2));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar> void SetLocation(const PointT<OtherScalar, DIM>& point),
 "output":#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);
	}
	else if constexpr (DIM == 2)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else if constexpr (DIM == 3)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else
	{
		return false;
	}
}
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {
	return result.Location().IsEqual(expected.Location(), tol) &&
		result.Direction().IsEqual(expected.Direction(), tol);
}
#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);
	}
	else if constexpr (DIM == 2)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else if constexpr (DIM == 3)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else
	{
		return false;
	}
}
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {
	return result.Location().IsEqual(expected.Location(), tol) &&
		result.Direction().IsEqual(expected.Direction(), tol);
;
	SECTION("SetLocation"){
		PointT<double, 3> p(0.0, 1.0, 2.0);
		DirectionT<double, 3> dz(1.0, 2.0, 3.0);
		DirectionT<double, 3> dx(0.0, 3.0, -2.0);
		FrameT<double, 3> f1(p, dz);
		PointT<double, 3> p2(1.0, 2.0, 3.0);
		FrameT<double, 3> f2(p2, dz, dx);
		f2.SetLocation(p);
		CHECK(IsEqual(f1, f2));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] const PointT<Scalar, DIM>& Location()	 @return The location
	 @brief Get the location
,
 "output":#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);
	}
	else if constexpr (DIM == 2)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else if constexpr (DIM == 3)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else
	{
		return false;
	}
}
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {
	return result.Location().IsEqual(expected.Location(), tol) &&
		result.Direction().IsEqual(expected.Direction(), tol);
}
#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);
	}
	else if constexpr (DIM == 2)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else if constexpr (DIM == 3)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else
	{
		return false;
	}
}
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {
	return result.Location().IsEqual(expected.Location(), tol) &&
		result.Direction().IsEqual(expected.Direction(), tol);
;
	SECTION("Location"){
		PointT<double, 3> p(1.0, 2.0, 3.0);
		DirectionT<double, 3> dz(1.0, 2.0, 3.0);
		FrameT<double, 3> f1(p, dz);
		CHECK(f1.Location().IsEqual(p, tol));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar, typename OtherScalar2, typename OtherScalar3, int DIM2 = DIM, std::enable_if_t<DIM2 == 2, int> = 0> FrameT(const PointT<OtherScalar, DIM>& point, const DirectionT<OtherScalar2, DIM>& xdir, const DirectionT<OtherScalar3, DIM>& ydir),
 "output":#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);
	}
	else if constexpr (DIM == 2)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else if constexpr (DIM == 3)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else
	{
		return false;
	}
}
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {
	return result.Location().IsEqual(expected.Location(), tol) &&
		result.Direction().IsEqual(expected.Direction(), tol);
}
#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);
	}
	else if constexpr (DIM == 2)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else if constexpr (DIM == 3)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else
	{
		return false;
	}
}
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {
	return result.Location().IsEqual(expected.Location(), tol) &&
		result.Direction().IsEqual(expected.Direction(), tol);
;
	SECTION("Default constructor"){
		FrameT<double, 3> f1;
		PointT<double, 3> p(0.0, 0.0, 0.0);
		DirectionT<double, 3> dz(0.0, 0.0, 1.0);
		DirectionT<double, 3> dx(1.0, 0.0, 0.0);
		FrameT<double, 3> f2(p, dz, dx);
		CHECK(IsEqual(f1, f2));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar, typename OtherScalar2, typename OtherScalar3, int DIM2 = DIM, std::enable_if_t<DIM2 == 3, int> = 0> FrameT(const PointT<OtherScalar, DIM>& point, const DirectionT<OtherScalar2, DIM>& normal, const DirectionT<OtherScalar3, DIM>& x),
 "output":#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);
	}
	else if constexpr (DIM == 2)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else if constexpr (DIM == 3)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else
	{
		return false;
	}
}
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {
	return result.Location().IsEqual(expected.Location(), tol) &&
		result.Direction().IsEqual(expected.Direction(), tol);
}
#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);
	}
	else if constexpr (DIM == 2)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else if constexpr (DIM == 3)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else
	{
		return false;
	}
}
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {
	return result.Location().IsEqual(expected.Location(), tol) &&
		result.Direction().IsEqual(expected.Direction(), tol);
;
	SECTION("Translate point 3D"){
		PointT<double, 3> p(1.0, -1.0, 0.0);
		DirectionT<double, 3> dz(1.0, 2.0, 3.0);
		FrameT<double, 3> f1(p, dz);
		PointT<double, 3> p2(1.0, 2.0, 3.0);
		PointT<double, 3> p3(2.0, 3.0, 5.0);
		PointT<double, 3> p4(2.0, 0.0, 2.0);
		FrameT<double, 3> f2(p4, dz);
		CHECK(IsEqual(f1.Translated(p2, p3), f2));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar, typename OtherScalar2, int DIM2 = DIM, std::enable_if_t<DIM2 == 3, int> = 0> FrameT(const PointT<OtherScalar, DIM>& point, const DirectionT<OtherScalar2, DIM>& dir),
 "output":#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);
	}
	else if constexpr (DIM == 2)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else if constexpr (DIM == 3)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else
	{
		return false;
	}
}
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {
	return result.Location().IsEqual(expected.Location(), tol) &&
		result.Direction().IsEqual(expected.Direction(), tol);
}
#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);
	}
	else if constexpr (DIM == 2)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else if constexpr (DIM == 3)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else
	{
		return false;
	}
}
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {
	return result.Location().IsEqual(expected.Location(), tol) &&
		result.Direction().IsEqual(expected.Direction(), tol);
;
	SECTION("SetDirection 3D"){
		PointT<double, 3> p(0.0, 1.0, 2.0);
		DirectionT<double, 3> dz(1.0, 2.0, 3.0);
		DirectionT<double, 3> dz2(2.3, 2.6, 3.3);
		DirectionT<double, 3> dx(0.0, 3.0, -2.0);
		FrameT<double, 3> f1(p, dz);
		FrameT<double, 3> f2(p, dz2);
		f2.SetDirection(dz);
		f2.SetXDirection(dx);
		CHECK(IsEqual(f1, f2));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar, int DIM2 = DIM, typename = typename std::enable_if_t<DIM2 == 3>> void SetDirection(const DirectionT<OtherScalar, DIM>& dir),
 "output":#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);
	}
	else if constexpr (DIM == 2)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else if constexpr (DIM == 3)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else
	{
		return false;
	}
}
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {
	return result.Location().IsEqual(expected.Location(), tol) &&
		result.Direction().IsEqual(expected.Direction(), tol);
}
#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);
	}
	else if constexpr (DIM == 2)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else if constexpr (DIM == 3)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else
	{
		return false;
	}
}
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {
	return result.Location().IsEqual(expected.Location(), tol) &&
		result.Direction().IsEqual(expected.Direction(), tol);
;
	SECTION("SetDirection 3D"){
		PointT<double, 3> p(0.0, 1.0, 2.0);
		DirectionT<double, 3> dz(1.0, 2.0, 3.0);
		DirectionT<double, 3> dz2(2.3, 2.6, 3.3);
		DirectionT<double, 3> dx(0.0, 3.0, -2.0);
		FrameT<double, 3> f1(p, dz);
		FrameT<double, 3> f2(p, dz2);
		f2.SetDirection(dz);
		f2.SetXDirection(dx);
		CHECK(IsEqual(f1, f2));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar, int DIM2 = DIM, std::enable_if_t<DIM2 == 2, int> = 0> void SetXDirection(const DirectionT<OtherScalar, DIM>& x),
 "output":#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);
	}
	else if constexpr (DIM == 2)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else if constexpr (DIM == 3)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else
	{
		return false;
	}
}
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {
	return result.Location().IsEqual(expected.Location(), tol) &&
		result.Direction().IsEqual(expected.Direction(), tol);
}
#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);
	}
	else if constexpr (DIM == 2)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else if constexpr (DIM == 3)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else
	{
		return false;
	}
}
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {
	return result.Location().IsEqual(expected.Location(), tol) &&
		result.Direction().IsEqual(expected.Direction(), tol);
;
	SECTION("SetXDirection 3D"){
		PointT<double, 3> p(0.0, 1.0, 2.0);
		DirectionT<double, 3> dz(1.0, 2.0, 3.0);
		DirectionT<double, 3> dx(-1.0, -1.0, 1.0);
		DirectionT<double, 3> dx2(0.0, 3.0, -2.0);
		FrameT<double, 3> f1(p, dz);
		FrameT<double, 3> f2(p, dz, dx);
		f2.SetXDirection(dx2);
		CHECK(IsEqual(f1, f2));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar, int DIM2 = DIM, std::enable_if_t<DIM2 == 3, int> = 0> void SetXDirection(const DirectionT<OtherScalar, DIM>& x),
 "output":#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);
	}
	else if constexpr (DIM == 2)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else if constexpr (DIM == 3)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else
	{
		return false;
	}
}
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {
	return result.Location().IsEqual(expected.Location(), tol) &&
		result.Direction().IsEqual(expected.Direction(), tol);
}
#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);
	}
	else if constexpr (DIM == 2)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else if constexpr (DIM == 3)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else
	{
		return false;
	}
}
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {
	return result.Location().IsEqual(expected.Location(), tol) &&
		result.Direction().IsEqual(expected.Direction(), tol);
;
	SECTION("SetXDirection 3D"){
		PointT<double, 3> p(0.0, 1.0, 2.0);
		DirectionT<double, 3> dz(1.0, 2.0, 3.0);
		DirectionT<double, 3> dx(-1.0, -1.0, 1.0);
		DirectionT<double, 3> dx2(0.0, 3.0, -2.0);
		FrameT<double, 3> f1(p, dz);
		FrameT<double, 3> f2(p, dz, dx);
		f2.SetXDirection(dx2);
		CHECK(IsEqual(f1, f2));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar, int DIM2 = DIM, std::enable_if_t<DIM2 == 2, int> = 0> void SetYDirection(const DirectionT<OtherScalar, DIM>& y),
 "output":#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);
	}
	else if constexpr (DIM == 2)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else if constexpr (DIM == 3)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else
	{
		return false;
	}
}
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {
	return result.Location().IsEqual(expected.Location(), tol) &&
		result.Direction().IsEqual(expected.Direction(), tol);
}
#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);
	}
	else if constexpr (DIM == 2)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else if constexpr (DIM == 3)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else
	{
		return false;
	}
}
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {
	return result.Location().IsEqual(expected.Location(), tol) &&
		result.Direction().IsEqual(expected.Direction(), tol);
;
	SECTION("SetYDirection 3D"){
		PointT<double, 3> p(0.0, 1.0, 2.0);
		DirectionT<double, 3> dz(1.0, 2.0, 3.0);
		DirectionT<double, 3> dx(-1.0, -1.0, 1.0);
		DirectionT<double, 3> dy2(-13.0, 2.0, 3.0);
		FrameT<double, 3> f1(p, dz);
		FrameT<double, 3> f2(p, dz, dx);
		f2.SetYDirection(dy2);
		CHECK(IsEqual(f1, f2));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar, int DIM2 = DIM, std::enable_if_t<DIM2 == 3, int> = 0> void SetYDirection(const DirectionT<OtherScalar, DIM>& y),
 "output":#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);
	}
	else if constexpr (DIM == 2)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else if constexpr (DIM == 3)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else
	{
		return false;
	}
}
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {
	return result.Location().IsEqual(expected.Location(), tol) &&
		result.Direction().IsEqual(expected.Direction(), tol);
}
#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);
	}
	else if constexpr (DIM == 2)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else if constexpr (DIM == 3)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else
	{
		return false;
	}
}
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {
	return result.Location().IsEqual(expected.Location(), tol) &&
		result.Direction().IsEqual(expected.Direction(), tol);
;
	SECTION("SetYDirection 3D"){
		PointT<double, 3> p(0.0, 1.0, 2.0);
		DirectionT<double, 3> dz(1.0, 2.0, 3.0);
		DirectionT<double, 3> dx(-1.0, -1.0, 1.0);
		DirectionT<double, 3> dy2(-13.0, 2.0, 3.0);
		FrameT<double, 3> f1(p, dz);
		FrameT<double, 3> f2(p, dz, dx);
		f2.SetYDirection(dy2);
		CHECK(IsEqual(f1, f2));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<int DIM2 = DIM, typename = typename std::enable_if_t<DIM2 >= 2>> [[nodiscard]] AxisT<Scalar, DIM> YAxis(),
 "output":#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);
	}
	else if constexpr (DIM == 2)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else if constexpr (DIM == 3)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else
	{
		return false;
	}
}
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {
	return result.Location().IsEqual(expected.Location(), tol) &&
		result.Direction().IsEqual(expected.Direction(), tol);
}
#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);
	}
	else if constexpr (DIM == 2)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else if constexpr (DIM == 3)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else
	{
		return false;
	}
}
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {
	return result.Location().IsEqual(expected.Location(), tol) &&
		result.Direction().IsEqual(expected.Direction(), tol);
;
	SECTION("YAxis"){
		PointT<double, 3> p(1.0, 2.0, 3.0);
		DirectionT<double, 3> dz(1.0, 2.0, 3.0);
		DirectionT<double, 3> dx(0.0, 3.0, -2.0);
		DirectionT<double, 3> dy(-13.0, 2.0, 3.0);
		FrameT<double, 3> f1(p, dz);
		CHECK(IsEqual(f1.YAxis(), AxisT<double, 3>(p, dy)));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<int DIM2 = DIM, typename = typename std::enable_if_t<DIM2 >= 1>> [[nodiscard]] const DirectionT<Scalar, DIM>& XDirection(),
 "output":#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);
	}
	else if constexpr (DIM == 2)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else if constexpr (DIM == 3)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else
	{
		return false;
	}
}
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {
	return result.Location().IsEqual(expected.Location(), tol) &&
		result.Direction().IsEqual(expected.Direction(), tol);
}
#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);
	}
	else if constexpr (DIM == 2)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else if constexpr (DIM == 3)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else
	{
		return false;
	}
}
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {
	return result.Location().IsEqual(expected.Location(), tol) &&
		result.Direction().IsEqual(expected.Direction(), tol);
;
	SECTION("XDirection"){
		PointT<double, 3> p(1.0, 2.0, 3.0);
		DirectionT<double, 3> dz(1.0, 2.0, 3.0);
		DirectionT<double, 3> dx(0.0, 3.0, -2.0);
		FrameT<double, 3> f1(p, dz);
		CHECK(f1.XDirection().IsEqual(dx, tol));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<int DIM2 = DIM, typename = typename std::enable_if_t<DIM2 >= 2>> [[nodiscard]] const DirectionT<Scalar, DIM>& YDirection(),
 "output":#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);
	}
	else if constexpr (DIM == 2)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else if constexpr (DIM == 3)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else
	{
		return false;
	}
}
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {
	return result.Location().IsEqual(expected.Location(), tol) &&
		result.Direction().IsEqual(expected.Direction(), tol);
}
#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);
	}
	else if constexpr (DIM == 2)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else if constexpr (DIM == 3)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else
	{
		return false;
	}
}
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {
	return result.Location().IsEqual(expected.Location(), tol) &&
		result.Direction().IsEqual(expected.Direction(), tol);
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar, typename OtherScalar2, typename OtherScalar3, int DIM2 = DIM, typename = typename std::enable_if_t<DIM2 == 3>> [[nodiscard]] bool IsCoplanar(const FrameT<OtherScalar, DIM>& other, const OtherScalar2& distol, const OtherScalar3& angtol),
 "output":#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);
	}
	else if constexpr (DIM == 2)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else if constexpr (DIM == 3)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else
	{
		return false;
	}
}
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {
	return result.Location().IsEqual(expected.Location(), tol) &&
		result.Direction().IsEqual(expected.Direction(), tol);
}
#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);
	}
	else if constexpr (DIM == 2)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else if constexpr (DIM == 3)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else
	{
		return false;
	}
}
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {
	return result.Location().IsEqual(expected.Location(), tol) &&
		result.Direction().IsEqual(expected.Direction(), tol);
;
	SECTION("IsCoplanar frame"){
		PointT<double, 3> p(1.0, -1.0, 0.0);
		PointT<double, 3> p2(1.0, 2.0, -2.0);
		PointT<double, 3> p3(1.0, 2.0, -1.0);
		DirectionT<double, 3> dz(1.0, 2.0, 3.0);
		DirectionT<double, 3> dz2(1.0, 2.0, 3.1);
		FrameT<double, 3> f1(p, dz);
		FrameT<double, 3> f2(p2, dz);
		FrameT<double, 3> f3(p3, dz);
		FrameT<double, 3> f4(p2, dz2);
		CHECK(f1.IsCoplanar(f2, 1e-6, 1e-6) == true);
		CHECK(f1.IsCoplanar(f3, 1e-6, 1e-6) == false);
		CHECK(f1.IsCoplanar(f4, 1e-6, 1e-6) == false);
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar, typename OtherScalar2, typename OtherScalar3, int DIM2 = DIM, typename = typename std::enable_if_t<DIM2 == 3>> [[nodiscard]] bool IsCoplanar(const AxisT<OtherScalar, DIM>& a, const OtherScalar2& distol, const OtherScalar3& angtol),
 "output":#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);
	}
	else if constexpr (DIM == 2)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else if constexpr (DIM == 3)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else
	{
		return false;
	}
}
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {
	return result.Location().IsEqual(expected.Location(), tol) &&
		result.Direction().IsEqual(expected.Direction(), tol);
}
#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);
	}
	else if constexpr (DIM == 2)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else if constexpr (DIM == 3)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else
	{
		return false;
	}
}
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {
	return result.Location().IsEqual(expected.Location(), tol) &&
		result.Direction().IsEqual(expected.Direction(), tol);
;
	SECTION("IsCoplanar frame"){
		PointT<double, 3> p(1.0, -1.0, 0.0);
		PointT<double, 3> p2(1.0, 2.0, -2.0);
		PointT<double, 3> p3(1.0, 2.0, -1.0);
		DirectionT<double, 3> dz(1.0, 2.0, 3.0);
		DirectionT<double, 3> dz2(1.0, 2.0, 3.1);
		FrameT<double, 3> f1(p, dz);
		FrameT<double, 3> f2(p2, dz);
		FrameT<double, 3> f3(p3, dz);
		FrameT<double, 3> f4(p2, dz2);
		CHECK(f1.IsCoplanar(f2, 1e-6, 1e-6) == true);
		CHECK(f1.IsCoplanar(f3, 1e-6, 1e-6) == false);
		CHECK(f1.IsCoplanar(f4, 1e-6, 1e-6) == false);
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar> FrameT& Mirror(const PointT<OtherScalar, DIM>& point),
 "output":#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);
	}
	else if constexpr (DIM == 2)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else if constexpr (DIM == 3)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else
	{
		return false;
	}
}
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {
	return result.Location().IsEqual(expected.Location(), tol) &&
		result.Direction().IsEqual(expected.Direction(), tol);
}
#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);
	}
	else if constexpr (DIM == 2)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else if constexpr (DIM == 3)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else
	{
		return false;
	}
}
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {
	return result.Location().IsEqual(expected.Location(), tol) &&
		result.Direction().IsEqual(expected.Direction(), tol);
;
	SECTION("Mirror point 3D"){
		PointT<double, 3> p(1.0, -1.0, 0.0);
		PointT<double, 3> p2(1.0, 2.0, -2.0);
		PointT<double, 3> p3(1.0, 5.0, -4.0);
		DirectionT<double, 3> dz(1.0, 2.0, 3.0);
		FrameT<double, 3> f1(p, dz);
		DirectionT<double, 3> dz2(-1.0, -2.0, -3.0);
		DirectionT<double, 3> dx2(0.0, -3.0, 2.0);
		FrameT<double, 3> f2(p3, dz2, dx2);
		FrameT<double, 3> f3 = f1.Mirrored(p2);
		CHECK(f3.Location().IsEqual(p3, tol));
		CHECK(f3.Direction().IsEqual(dz2, tol));
		CHECK(f3.XDirection().IsEqual(dx2, tol));
		CHECK(f3.YDirection().IsEqual(dx2.Cross(dz2), tol));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar> [[nodiscard]] FrameT Mirrored(const PointT<OtherScalar, DIM>& point),
 "output":#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);
	}
	else if constexpr (DIM == 2)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else if constexpr (DIM == 3)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else
	{
		return false;
	}
}
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {
	return result.Location().IsEqual(expected.Location(), tol) &&
		result.Direction().IsEqual(expected.Direction(), tol);
}
#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);
	}
	else if constexpr (DIM == 2)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else if constexpr (DIM == 3)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else
	{
		return false;
	}
}
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {
	return result.Location().IsEqual(expected.Location(), tol) &&
		result.Direction().IsEqual(expected.Direction(), tol);
;
	SECTION("Mirror point 3D"){
		PointT<double, 3> p(1.0, -1.0, 0.0);
		PointT<double, 3> p2(1.0, 2.0, -2.0);
		PointT<double, 3> p3(1.0, 5.0, -4.0);
		DirectionT<double, 3> dz(1.0, 2.0, 3.0);
		FrameT<double, 3> f1(p, dz);
		DirectionT<double, 3> dz2(-1.0, -2.0, -3.0);
		DirectionT<double, 3> dx2(0.0, -3.0, 2.0);
		FrameT<double, 3> f2(p3, dz2, dx2);
		FrameT<double, 3> f3 = f1.Mirrored(p2);
		CHECK(f3.Location().IsEqual(p3, tol));
		CHECK(f3.Direction().IsEqual(dz2, tol));
		CHECK(f3.XDirection().IsEqual(dx2, tol));
		CHECK(f3.YDirection().IsEqual(dx2.Cross(dz2), tol));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar> [[nodiscard]] FrameT Mirrored(const AxisT<OtherScalar, DIM>& a),
 "output":#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);
	}
	else if constexpr (DIM == 2)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else if constexpr (DIM == 3)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else
	{
		return false;
	}
}
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {
	return result.Location().IsEqual(expected.Location(), tol) &&
		result.Direction().IsEqual(expected.Direction(), tol);
}
#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);
	}
	else if constexpr (DIM == 2)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else if constexpr (DIM == 3)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else
	{
		return false;
	}
}
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {
	return result.Location().IsEqual(expected.Location(), tol) &&
		result.Direction().IsEqual(expected.Direction(), tol);
;
	SECTION("Mirror point 3D"){
		PointT<double, 3> p(1.0, -1.0, 0.0);
		PointT<double, 3> p2(1.0, 2.0, -2.0);
		PointT<double, 3> p3(1.0, 5.0, -4.0);
		DirectionT<double, 3> dz(1.0, 2.0, 3.0);
		FrameT<double, 3> f1(p, dz);
		DirectionT<double, 3> dz2(-1.0, -2.0, -3.0);
		DirectionT<double, 3> dx2(0.0, -3.0, 2.0);
		FrameT<double, 3> f2(p3, dz2, dx2);
		FrameT<double, 3> f3 = f1.Mirrored(p2);
		CHECK(f3.Location().IsEqual(p3, tol));
		CHECK(f3.Direction().IsEqual(dz2, tol));
		CHECK(f3.XDirection().IsEqual(dx2, tol));
		CHECK(f3.YDirection().IsEqual(dx2.Cross(dz2), tol));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar, int DIM2 = DIM, std::enable_if_t<DIM2 == 3, int> = 0> [[nodiscard]] FrameT Mirrored(const FrameT<OtherScalar, DIM>& frame),
 "output":#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);
	}
	else if constexpr (DIM == 2)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else if constexpr (DIM == 3)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else
	{
		return false;
	}
}
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {
	return result.Location().IsEqual(expected.Location(), tol) &&
		result.Direction().IsEqual(expected.Direction(), tol);
}
#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);
	}
	else if constexpr (DIM == 2)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else if constexpr (DIM == 3)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else
	{
		return false;
	}
}
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {
	return result.Location().IsEqual(expected.Location(), tol) &&
		result.Direction().IsEqual(expected.Direction(), tol);
;
	SECTION("Mirror point 3D"){
		PointT<double, 3> p(1.0, -1.0, 0.0);
		PointT<double, 3> p2(1.0, 2.0, -2.0);
		PointT<double, 3> p3(1.0, 5.0, -4.0);
		DirectionT<double, 3> dz(1.0, 2.0, 3.0);
		FrameT<double, 3> f1(p, dz);
		DirectionT<double, 3> dz2(-1.0, -2.0, -3.0);
		DirectionT<double, 3> dx2(0.0, -3.0, 2.0);
		FrameT<double, 3> f2(p3, dz2, dx2);
		FrameT<double, 3> f3 = f1.Mirrored(p2);
		CHECK(f3.Location().IsEqual(p3, tol));
		CHECK(f3.Direction().IsEqual(dz2, tol));
		CHECK(f3.XDirection().IsEqual(dx2, tol));
		CHECK(f3.YDirection().IsEqual(dx2.Cross(dz2), tol));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar, typename OtherScalar2, int DIM2 = DIM, typename = typename std::enable_if_t<DIM2 == 3>> FrameT& Rotate(const AxisT<OtherScalar, DIM>& a, const OtherScalar2& angle),
 "output":#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);
	}
	else if constexpr (DIM == 2)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else if constexpr (DIM == 3)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else
	{
		return false;
	}
}
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {
	return result.Location().IsEqual(expected.Location(), tol) &&
		result.Direction().IsEqual(expected.Direction(), tol);
}
#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);
	}
	else if constexpr (DIM == 2)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else if constexpr (DIM == 3)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else
	{
		return false;
	}
}
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {
	return result.Location().IsEqual(expected.Location(), tol) &&
		result.Direction().IsEqual(expected.Direction(), tol);
;
	SECTION("Rotate 3D"){
		PointT<double, 3> p(1.0, -1.0, 0.0);
		DirectionT<double, 3> dz(1.0, 2.0, 3.0);
		FrameT<double, 3> f1(p, dz);
		PointT<double, 3> p2(1.0, 2.0, 3.0);
		DirectionT<double, 3> dz2(3.0, 2.0, 1.0);
		AxisT<double, 3> axis(p2, dz2);
		PointT<double, 3> p3(-3.0 / sqrt(14.0) - 13.0 / 14.0, 9.0 / std::sqrt(14.0) + 10.0 / 14.0, -9.0 / std::sqrt(14.0) + 33.0 / 14.0);
		DirectionT<double, 3> dz3(4.0 / sqrt(14.0) + 15.0 / 7.0, -8.0 / sqrt(14.0) + 10.0 / 7.0, 4.0 / sqrt(14.0) + 5.0 / 7.0);
		DirectionT<double, 3> dx3(-7.0 / sqrt(14.0) + 6.0 / 7.0, 6.0 / sqrt(14.0) + 4.0 / 7.0, 9.0 / sqrt(14.0) + 2.0 / 7.0);
		FrameT<double, 3> f2(p3, dz3, dx3);
		FrameT<double, 3> f3 = f1.Rotated(axis, M_PI_2);
		CHECK(IsEqual(f3, f2));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar, typename OtherScalar2, int DIM2 = DIM, typename = typename std::enable_if_t<DIM2 == 2>> [[nodiscard]] FrameT Rotated(const PointT<OtherScalar, DIM>& point, const OtherScalar2& angle),
 "output":#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);
	}
	else if constexpr (DIM == 2)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else if constexpr (DIM == 3)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else
	{
		return false;
	}
}
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {
	return result.Location().IsEqual(expected.Location(), tol) &&
		result.Direction().IsEqual(expected.Direction(), tol);
}
#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);
	}
	else if constexpr (DIM == 2)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else if constexpr (DIM == 3)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else
	{
		return false;
	}
}
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {
	return result.Location().IsEqual(expected.Location(), tol) &&
		result.Direction().IsEqual(expected.Direction(), tol);
;
	SECTION("Rotate 3D"){
		PointT<double, 3> p(1.0, -1.0, 0.0);
		DirectionT<double, 3> dz(1.0, 2.0, 3.0);
		FrameT<double, 3> f1(p, dz);
		PointT<double, 3> p2(1.0, 2.0, 3.0);
		DirectionT<double, 3> dz2(3.0, 2.0, 1.0);
		AxisT<double, 3> axis(p2, dz2);
		PointT<double, 3> p3(-3.0 / sqrt(14.0) - 13.0 / 14.0, 9.0 / std::sqrt(14.0) + 10.0 / 14.0, -9.0 / std::sqrt(14.0) + 33.0 / 14.0);
		DirectionT<double, 3> dz3(4.0 / sqrt(14.0) + 15.0 / 7.0, -8.0 / sqrt(14.0) + 10.0 / 7.0, 4.0 / sqrt(14.0) + 5.0 / 7.0);
		DirectionT<double, 3> dx3(-7.0 / sqrt(14.0) + 6.0 / 7.0, 6.0 / sqrt(14.0) + 4.0 / 7.0, 9.0 / sqrt(14.0) + 2.0 / 7.0);
		FrameT<double, 3> f2(p3, dz3, dx3);
		FrameT<double, 3> f3 = f1.Rotated(axis, M_PI_2);
		CHECK(IsEqual(f3, f2));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar, typename OtherScalar2, int DIM2 = DIM, typename = typename std::enable_if_t<DIM2 == 3>> [[nodiscard]] FrameT Rotated(const AxisT<OtherScalar, DIM>& a, const OtherScalar2& angle),
 "output":#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);
	}
	else if constexpr (DIM == 2)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else if constexpr (DIM == 3)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else
	{
		return false;
	}
}
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {
	return result.Location().IsEqual(expected.Location(), tol) &&
		result.Direction().IsEqual(expected.Direction(), tol);
}
#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);
	}
	else if constexpr (DIM == 2)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else if constexpr (DIM == 3)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else
	{
		return false;
	}
}
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {
	return result.Location().IsEqual(expected.Location(), tol) &&
		result.Direction().IsEqual(expected.Direction(), tol);
;
	SECTION("Rotate 3D"){
		PointT<double, 3> p(1.0, -1.0, 0.0);
		DirectionT<double, 3> dz(1.0, 2.0, 3.0);
		FrameT<double, 3> f1(p, dz);
		PointT<double, 3> p2(1.0, 2.0, 3.0);
		DirectionT<double, 3> dz2(3.0, 2.0, 1.0);
		AxisT<double, 3> axis(p2, dz2);
		PointT<double, 3> p3(-3.0 / sqrt(14.0) - 13.0 / 14.0, 9.0 / std::sqrt(14.0) + 10.0 / 14.0, -9.0 / std::sqrt(14.0) + 33.0 / 14.0);
		DirectionT<double, 3> dz3(4.0 / sqrt(14.0) + 15.0 / 7.0, -8.0 / sqrt(14.0) + 10.0 / 7.0, 4.0 / sqrt(14.0) + 5.0 / 7.0);
		DirectionT<double, 3> dx3(-7.0 / sqrt(14.0) + 6.0 / 7.0, 6.0 / sqrt(14.0) + 4.0 / 7.0, 9.0 / sqrt(14.0) + 2.0 / 7.0);
		FrameT<double, 3> f2(p3, dz3, dx3);
		FrameT<double, 3> f3 = f1.Rotated(axis, M_PI_2);
		CHECK(IsEqual(f3, f2));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar, typename OtherScalar2> [[nodiscard]] FrameT Scaled(const PointT<OtherScalar, DIM>& point, const OtherScalar2& scale),
 "output":#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);
	}
	else if constexpr (DIM == 2)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else if constexpr (DIM == 3)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else
	{
		return false;
	}
}
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {
	return result.Location().IsEqual(expected.Location(), tol) &&
		result.Direction().IsEqual(expected.Direction(), tol);
}
#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);
	}
	else if constexpr (DIM == 2)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else if constexpr (DIM == 3)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else
	{
		return false;
	}
}
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {
	return result.Location().IsEqual(expected.Location(), tol) &&
		result.Direction().IsEqual(expected.Direction(), tol);
;
	SECTION("Scale 3D"){
		PointT<double, 3> p(1.0, -1.0, 0.0);
		DirectionT<double, 3> dz(1.0, 2.0, 3.0);
		FrameT<double, 3> f1(p, dz);
		PointT<double, 3> p2(1.0, 2.0, 3.0);
		PointT<double, 3> p3(1.0, -2.5, -1.5);
		FrameT<double, 3> f2(p3, dz);
		CHECK(IsEqual(f1.Scaled(p2, 1.5), f2));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar> FrameT& Translate(const VectorT<OtherScalar, DIM>& vec),
 "output":#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);
	}
	else if constexpr (DIM == 2)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else if constexpr (DIM == 3)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else
	{
		return false;
	}
}
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {
	return result.Location().IsEqual(expected.Location(), tol) &&
		result.Direction().IsEqual(expected.Direction(), tol);
}
#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);
	}
	else if constexpr (DIM == 2)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else if constexpr (DIM == 3)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else
	{
		return false;
	}
}
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {
	return result.Location().IsEqual(expected.Location(), tol) &&
		result.Direction().IsEqual(expected.Direction(), tol);
;
	SECTION("Translate vector 3D"){
		PointT<double, 3> p(1.0, -1.0, 0.0);
		DirectionT<double, 3> dz(1.0, 2.0, 3.0);
		FrameT<double, 3> f1(p, dz);
		VectorT<double, 3> v(2.0, 3.0, -1.0);
		PointT<double, 3> p2(3.0, 2.0, -1.0);
		FrameT<double, 3> f2(p2, dz);
		CHECK(IsEqual(f1.Translated(v), f2));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar> [[nodiscard]] FrameT Translated(const VectorT<OtherScalar, DIM>& vec),
 "output":#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);
	}
	else if constexpr (DIM == 2)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else if constexpr (DIM == 3)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else
	{
		return false;
	}
}
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {
	return result.Location().IsEqual(expected.Location(), tol) &&
		result.Direction().IsEqual(expected.Direction(), tol);
}
#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);
	}
	else if constexpr (DIM == 2)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else if constexpr (DIM == 3)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else
	{
		return false;
	}
}
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {
	return result.Location().IsEqual(expected.Location(), tol) &&
		result.Direction().IsEqual(expected.Direction(), tol);
;
	SECTION("Translate vector 3D"){
		PointT<double, 3> p(1.0, -1.0, 0.0);
		DirectionT<double, 3> dz(1.0, 2.0, 3.0);
		FrameT<double, 3> f1(p, dz);
		VectorT<double, 3> v(2.0, 3.0, -1.0);
		PointT<double, 3> p2(3.0, 2.0, -1.0);
		FrameT<double, 3> f2(p2, dz);
		CHECK(IsEqual(f1.Translated(v), f2));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar, typename OtherScalar2> [[nodiscard]] FrameT Translated(const PointT<OtherScalar, DIM>& p1, const PointT<OtherScalar2, DIM>& p2),
 "output":#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);
	}
	else if constexpr (DIM == 2)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else if constexpr (DIM == 3)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else
	{
		return false;
	}
}
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {
	return result.Location().IsEqual(expected.Location(), tol) &&
		result.Direction().IsEqual(expected.Direction(), tol);
}
#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);
	}
	else if constexpr (DIM == 2)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else if constexpr (DIM == 3)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else
	{
		return false;
	}
}
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {
	return result.Location().IsEqual(expected.Location(), tol) &&
		result.Direction().IsEqual(expected.Direction(), tol);
;
	SECTION("IsCoplanar frame"){
		PointT<double, 3> p(1.0, -1.0, 0.0);
		PointT<double, 3> p2(1.0, 2.0, -2.0);
		PointT<double, 3> p3(1.0, 2.0, -1.0);
		DirectionT<double, 3> dz(1.0, 2.0, 3.0);
		DirectionT<double, 3> dz2(1.0, 2.0, 3.1);
		FrameT<double, 3> f1(p, dz);
		FrameT<double, 3> f2(p2, dz);
		FrameT<double, 3> f3(p3, dz);
		FrameT<double, 3> f4(p2, dz2);
		CHECK(f1.IsCoplanar(f2, 1e-6, 1e-6) == true);
		CHECK(f1.IsCoplanar(f3, 1e-6, 1e-6) == false);
		CHECK(f1.IsCoplanar(f4, 1e-6, 1e-6) == false);
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":DirectionT()	 @details Default direction is (1, 0, ... , 0)
	 @brief Default constructor
,
 "output":#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
;
	SECTION("Mirror(point) 2D") {
        DirectionT<double, 2> p1(1.0, 2.0);
        DirectionT<double, 2> p2(2.0, 3.0);
        DirectionT<double, 2> p3(19.0 / 13.0, 22.0 / 13.0);
        CHECK(p1.Mirrored(p2).IsEqual(p3, tol));
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar> explicit DirectionT(const VectorT<OtherScalar, DIM>& vec),
 "output":#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
;
	SECTION("Mirror(point) 2D") {
        DirectionT<double, 2> p1(1.0, 2.0);
        DirectionT<double, 2> p2(2.0, 3.0);
        DirectionT<double, 2> p3(19.0 / 13.0, 22.0 / 13.0);
        CHECK(p1.Mirrored(p2).IsEqual(p3, tol));
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar> explicit DirectionT(const CoordT<OtherScalar, DIM>& v),
 "output":#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
;
	SECTION("Mirror(point) 2D") {
        DirectionT<double, 2> p1(1.0, 2.0);
        DirectionT<double, 2> p2(2.0, 3.0);
        DirectionT<double, 2> p3(19.0 / 13.0, 22.0 / 13.0);
        CHECK(p1.Mirrored(p2).IsEqual(p3, tol));
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename... T> explicit DirectionT(T... vs),
 "output":#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
;
	SECTION("Angle 2D") {
        DirectionT<double, 2> v1(1.0, 3.0);
        DirectionT<double, 2> v2(-1.0, 2.0);
        CHECK(v1.Angle(v2) == Approx(acos(M_SQRT1_2)));
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar, typename OtherScalar2> [[nodiscard]] bool IsEqual(const DirectionT<OtherScalar, DIM>& other, const OtherScalar2& tol),
 "output":#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
;
	SECTION("Mirror(point) 2D") {
        DirectionT<double, 2> p1(1.0, 2.0);
        DirectionT<double, 2> p2(2.0, 3.0);
        DirectionT<double, 2> p3(19.0 / 13.0, 22.0 / 13.0);
        CHECK(p1.Mirrored(p2).IsEqual(p3, tol));
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar, int DIM2 = DIM, std::enable_if_t<DIM2 == 2, int> = 0> [[nodiscard]] auto Angle(const DirectionT<OtherScalar, DIM>& other),
 "output":#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
;
	SECTION("Angle 2D") {
        DirectionT<double, 2> v1(1.0, 3.0);
        DirectionT<double, 2> v2(-1.0, 2.0);
        CHECK(v1.Angle(v2) == Approx(acos(M_SQRT1_2)));
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar> [[nodiscard]] auto Cross(const DirectionT<OtherScalar, DIM>& other),
 "output":#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
;
	SECTION("Cross 2D") {
        DirectionT<double, 2> v1(1.0, 2.0);
        DirectionT<double, 2> v2(2.0, 3.0);
        CHECK(v1.Cross(v2) == Approx(-1.0/sqrt(65.0)));
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar> DirectionT& Mirror(const AxisT<OtherScalar, DIM>& axis),
 "output":#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
;
	SECTION("Mirror(axis) 2D") {
        DirectionT<double, 2> p1(1.0, 2.0);
        PointT<double, 2> p2(2.0, 3.0);
        DirectionT<double, 2> d(7.0, 3.0);
        AxisT<double, 2> a(p2, d);
        DirectionT<double, 2> p3(62.0 / 29.0, -19.0 / 29.0);
        CHECK(p1.Mirrored(a).IsEqual(p3, tol));
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar> [[nodiscard]] DirectionT Mirrored(const DirectionT<OtherScalar, DIM>& dir),
 "output":#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
;
	SECTION("Mirror(axis) 2D") {
        DirectionT<double, 2> p1(1.0, 2.0);
        PointT<double, 2> p2(2.0, 3.0);
        DirectionT<double, 2> d(7.0, 3.0);
        AxisT<double, 2> a(p2, d);
        DirectionT<double, 2> p3(62.0 / 29.0, -19.0 / 29.0);
        CHECK(p1.Mirrored(a).IsEqual(p3, tol));
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar> [[nodiscard]] DirectionT Mirrored(const AxisT<OtherScalar, DIM>& axis),
 "output":#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
;
	SECTION("Mirror(point) 2D") {
        DirectionT<double, 2> p1(1.0, 2.0);
        DirectionT<double, 2> p2(2.0, 3.0);
        DirectionT<double, 2> p3(19.0 / 13.0, 22.0 / 13.0);
        CHECK(p1.Mirrored(p2).IsEqual(p3, tol));
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar, int DIM2 = DIM, typename = typename std::enable_if_t<DIM2 == 2>> DirectionT& Rotate(const OtherScalar& angle),
 "output":#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
;
	SECTION("Rotate 2D") {
        DirectionT<double, 2> p1(1.0, 2.0);
        DirectionT<double, 2> p3(-2.0, 1.0);
        CHECK(p1.Rotated(M_PI_2).IsEqual(p3, tol));
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar, int DIM2 = DIM, typename = typename std::enable_if_t<DIM2 == 2>> [[nodiscard]] DirectionT Rotated(const OtherScalar& angle),
 "output":#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
;
	SECTION("Rotate 2D") {
        DirectionT<double, 2> p1(1.0, 2.0);
        DirectionT<double, 2> p3(-2.0, 1.0);
        CHECK(p1.Rotated(M_PI_2).IsEqual(p3, tol));
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":DirectionT()	 @details Default direction is (1, 0, ... , 0)
	 @brief Default constructor
,
 "output":#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
;
	SECTION("Default constructor") {
        DirectionT<double, 3> p1;
        DirectionT<double, 3> p2(1.0, 0.0, 0.0);
        CHECK(p1.IsEqual(p2, tol));
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar> explicit DirectionT(const VectorT<OtherScalar, DIM>& vec),
 "output":#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
;
	SECTION("Default constructor") {
        DirectionT<double, 3> p1;
        DirectionT<double, 3> p2(1.0, 0.0, 0.0);
        CHECK(p1.IsEqual(p2, tol));
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar> explicit DirectionT(const CoordT<OtherScalar, DIM>& v),
 "output":#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
;
	SECTION("Constructor from vector") {
        VectorT<double, 3> v(1.0, 2.0, 3.0);
        DirectionT<double, 3> result(v);
        CoordT<double, 3> expected(1.0 / sqrt(14.0), 2.0 / sqrt(14.0), 3.0 / sqrt(14.0));
        CHECK(result.Coord().IsEqual(expected, tol));
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename... T> explicit DirectionT(T... vs),
 "output":#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
;
	SECTION("Default constructor") {
        DirectionT<double, 3> p1;
        DirectionT<double, 3> p2(1.0, 0.0, 0.0);
        CHECK(p1.IsEqual(p2, tol));
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename... T> void SetCoord(T... vs),
 "output":#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
;
	SECTION("SetCoord(x, y, z)") {
        DirectionT<double, 3> result;
        result.SetCoord(1.0, 2.0, 3.0);
        CoordT<double, 3> expected(1.0 / sqrt(14.0), 2.0 / sqrt(14.0), 3.0 / sqrt(14.0));
        CHECK(result.Coord().IsEqual(expected, tol));
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar, typename = typename std::enable_if_t<DIM >= 1 && std::is_convertible_v<OtherScalar, Scalar>>> void SetX(const OtherScalar& x),
 "output":#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
;
	SECTION("SetX, SetY, SetZ, SetW"){
        DirectionT<double, 4> result;
        result.SetX(1);
        result.SetY(2);
        result.SetZ(3);
        result.SetW(4);
        CoordT<double, 4> expected(1.0 / sqrt(850.0), 2.0 / sqrt(850.0), 3.0 / sqrt(170), 4.0 / sqrt(17));
        CHECK(result.X() == Approx(1.0 / sqrt(850.0)));
        CHECK(result.Y() == Approx(2.0 / sqrt(850.0)));
        CHECK(result.Z() == Approx(3.0 / sqrt(170.0)));
        CHECK(result.W() == Approx(4.0 / sqrt(17.0)));
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar, typename = typename std::enable_if_t<DIM >= 2 && std::is_convertible_v<OtherScalar, Scalar>>> void SetY(const OtherScalar& y),
 "output":#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
;
	SECTION("SetX, SetY, SetZ, SetW"){
        DirectionT<double, 4> result;
        result.SetX(1);
        result.SetY(2);
        result.SetZ(3);
        result.SetW(4);
        CoordT<double, 4> expected(1.0 / sqrt(850.0), 2.0 / sqrt(850.0), 3.0 / sqrt(170), 4.0 / sqrt(17));
        CHECK(result.X() == Approx(1.0 / sqrt(850.0)));
        CHECK(result.Y() == Approx(2.0 / sqrt(850.0)));
        CHECK(result.Z() == Approx(3.0 / sqrt(170.0)));
        CHECK(result.W() == Approx(4.0 / sqrt(17.0)));
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar, typename = typename std::enable_if_t<DIM >= 4 && std::is_convertible_v<OtherScalar, Scalar>>> void SetW(const OtherScalar& w),
 "output":#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
;
	SECTION("SetX, SetY, SetZ, SetW"){
        DirectionT<double, 4> result;
        result.SetX(1);
        result.SetY(2);
        result.SetZ(3);
        result.SetW(4);
        CoordT<double, 4> expected(1.0 / sqrt(850.0), 2.0 / sqrt(850.0), 3.0 / sqrt(170), 4.0 / sqrt(17));
        CHECK(result.X() == Approx(1.0 / sqrt(850.0)));
        CHECK(result.Y() == Approx(2.0 / sqrt(850.0)));
        CHECK(result.Z() == Approx(3.0 / sqrt(170.0)));
        CHECK(result.W() == Approx(4.0 / sqrt(17.0)));
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar, typename OtherScalar2> [[nodiscard]] bool IsEqual(const DirectionT<OtherScalar, DIM>& other, const OtherScalar2& tol),
 "output":#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
;
	SECTION("Default constructor") {
        DirectionT<double, 3> p1;
        DirectionT<double, 3> p2(1.0, 0.0, 0.0);
        CHECK(p1.IsEqual(p2, tol));
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar, typename OtherScalar2> [[nodiscard]] bool IsNormal(const DirectionT<OtherScalar, DIM>& other, const OtherScalar2& tol),
 "output":#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
;
	SECTION("IsNormal") {
        DirectionT<double, 3> v1(1.0, 2.0, 3.0);
        DirectionT<double, 3> v2(-4.0, -1.0, 2.01);
        CHECK(v1.IsNormal(v2, tol) == false);
        CHECK(v1.IsNormal(v2, 0.1));
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar, typename OtherScalar2> [[nodiscard]] bool IsOpposite(const DirectionT<OtherScalar, DIM>& other, const OtherScalar2& tol),
 "output":#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
;
	SECTION("IsOpposite") {
        DirectionT<double, 3> v1(1.0, 2.0, 3.0);
        DirectionT<double, 3> v2(-1.0, -2.0, -3.01);
        CHECK(v1.IsOpposite(v2, 0.1));
        CHECK(v1.IsOpposite(v2, tol) == false);
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar, typename OtherScalar2> [[nodiscard]] bool IsParallel(const DirectionT<OtherScalar, DIM>& other, const OtherScalar2& tol),
 "output":#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
;
	SECTION("IsParallel"){
        DirectionT<double, 3> v1(1.0, 2.0, 3.0);
        DirectionT<double, 3> v2(-1.0, -2.0, -3.01);
        CHECK(v1.IsParallel(v2, tol) == false);
        CHECK(v1.IsParallel(v2, 0.1));
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar, int DIM2 = DIM, std::enable_if_t<DIM2 == 2, int> = 0> [[nodiscard]] auto Angle(const DirectionT<OtherScalar, DIM>& other),
 "output":#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
;
	SECTION("Angle 3D") {
        DirectionT<double, 3> v1(1.0, 2.0, 3.0);
        DirectionT<double, 3> v2(-3.0, 2.0, -1.0);
        CHECK(v1.Angle(v2) == acos(-1.0 / 7.0));
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar, int DIM2 = DIM, std::enable_if_t<DIM2 == 3, int> = 0> [[nodiscard]] auto Angle(const DirectionT<OtherScalar, DIM>& other),
 "output":#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
;
	SECTION("Angle 3D") {
        DirectionT<double, 3> v1(1.0, 2.0, 3.0);
        DirectionT<double, 3> v2(-3.0, 2.0, -1.0);
        CHECK(v1.Angle(v2) == acos(-1.0 / 7.0));
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar, typename OtherScalar2, int DIM2 = DIM, typename = typename std::enable_if_t<DIM2 == 3>> [[nodiscard]] auto AngleWithRef(const DirectionT<OtherScalar, DIM>& other, const DirectionT<OtherScalar2, DIM>& ref),
 "output":#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
;
	SECTION("AngleWithRef") {
        DirectionT<double, 3> v1(1.0, 2.0, 3.0);
        DirectionT<double, 3> v2(-3.0, 2.0, -1.0);
        DirectionT<double, 3> v3(1.0, 1.0, 1.0);
        CHECK(v1.AngleWithRef(v2, v3) == Approx(-acos(-1.0 / 7.0)));
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar> [[nodiscard]] auto Cross(const DirectionT<OtherScalar, DIM>& other),
 "output":#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
;
	SECTION("Cross 3D") {
        DirectionT<double, 3> v1(1.0, 2.0, 3.0);
        DirectionT<double, 3> v2(2.0, 3.0, 4.0);
        CoordT<double, 3> v3(-1.0 / std::sqrt(6.0), 2.0 / std::sqrt(6.0), -1.0 / std::sqrt(6.0));
        CHECK(v1.Cross(v2).Coord().IsEqual(v3, tol));
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":DirectionT& Reverse()	 @return The reference to self
	 @brief Reverse the direction
,
 "output":#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
;
	SECTION("Reverse") {
        DirectionT<double, 3> v1(1.0, 2.0, 2.0);
        DirectionT<double, 3> v2(-1.0, -2.0, -2.0);
        CHECK(v1.IsEqual(-v2, tol));
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar> DirectionT& Mirror(const DirectionT<OtherScalar, DIM>& dir),
 "output":#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
;
	SECTION("Mirror(frame) 3D") {
        DirectionT<double, 3> p1(1.0, 2.0, 3.0);
        PointT<double, 3> p2(2.0, 3.0, 4.0);
        DirectionT<double, 3> d(7.0, 3.0, 2.0);
        FrameT<double, 3> f(p2, d);
        DirectionT<double, 3> p3(-102.0 / 31.0, 5.0 / 31.0, 55.0 / 31.0);
        CHECK(p1.Mirrored(f).IsEqual(p3, tol));
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar> DirectionT& Mirror(const AxisT<OtherScalar, DIM>& axis),
 "output":#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
;
	SECTION("Mirror(axis) 3D") {
        DirectionT<double, 3> p1(1.0, 2.0, 3.0);
        PointT<double, 3> p2(2.0, 3.0, 4.0);
        DirectionT<double, 3> d(7.0, 3.0, 2.0);
        AxisT<double, 3> a(p2, d);
        DirectionT<double, 3> p3(102.0 / 31.0, -5.0 / 31.0, -55.0 / 31.0);
        CHECK(p1.Mirrored(a).IsEqual(p3, tol));
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar, int DIM2 = DIM, std::enable_if_t<DIM2 == 3, int> = 0> DirectionT& Mirror(const FrameT<OtherScalar, DIM>& frame),
 "output":#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
;
	SECTION("Mirror(axis) 3D") {
        DirectionT<double, 3> p1(1.0, 2.0, 3.0);
        PointT<double, 3> p2(2.0, 3.0, 4.0);
        DirectionT<double, 3> d(7.0, 3.0, 2.0);
        AxisT<double, 3> a(p2, d);
        DirectionT<double, 3> p3(102.0 / 31.0, -5.0 / 31.0, -55.0 / 31.0);
        CHECK(p1.Mirrored(a).IsEqual(p3, tol));
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar> [[nodiscard]] DirectionT Mirrored(const DirectionT<OtherScalar, DIM>& dir),
 "output":#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
;
	SECTION("Mirror(axis) 3D") {
        DirectionT<double, 3> p1(1.0, 2.0, 3.0);
        PointT<double, 3> p2(2.0, 3.0, 4.0);
        DirectionT<double, 3> d(7.0, 3.0, 2.0);
        AxisT<double, 3> a(p2, d);
        DirectionT<double, 3> p3(102.0 / 31.0, -5.0 / 31.0, -55.0 / 31.0);
        CHECK(p1.Mirrored(a).IsEqual(p3, tol));
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar> [[nodiscard]] DirectionT Mirrored(const AxisT<OtherScalar, DIM>& axis),
 "output":#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
;
	SECTION("Mirror(point) 3D") {
        DirectionT<double, 3> p1(1.0, 2.0, 3.0);
        DirectionT<double, 3> p2(2.0, 4.0, 5.0);
        DirectionT<double, 3> p3(11.0 / 9.0, 22.0 / 9.0, 23.0 / 9.0);
        CHECK(p1.Mirrored(p2).IsEqual(p3, tol));
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar, int DIM2 = DIM, std::enable_if_t<DIM2 == 3, int> = 0> [[nodiscard]] DirectionT Mirrored(const FrameT<OtherScalar, DIM>& frame),
 "output":#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
;
	SECTION("Mirror(point) 3D") {
        DirectionT<double, 3> p1(1.0, 2.0, 3.0);
        DirectionT<double, 3> p2(2.0, 4.0, 5.0);
        DirectionT<double, 3> p3(11.0 / 9.0, 22.0 / 9.0, 23.0 / 9.0);
        CHECK(p1.Mirrored(p2).IsEqual(p3, tol));
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar, typename OtherScalar2, int DIM2 = DIM, typename = typename std::enable_if_t<DIM2 == 3>> DirectionT& Rotate(const AxisT<OtherScalar, DIM>& axis, const OtherScalar2& angle),
 "output":#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
;
	SECTION("Rotate 3D") {
            DirectionT<double, 3> p1(1.0, 2.0, 3.0);
            PointT<double, 3> p2(2.0, 3.0, 4.0);
            DirectionT<double, 3> d(1.0, 1.0, 2.0);
            AxisT<double, 3> a(p2, d);
            DirectionT<double, 3> p3((9.0 - std::sqrt(6.0)) / 6.0, (9.0 - std::sqrt(6.0)) / 6.0, 3.0 + 1.0 / std::sqrt(6.0));
            CHECK(p1.Rotated(a, M_PI_2).IsEqual(p3, tol));
        }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar, typename OtherScalar2, int DIM2 = DIM, typename = typename std::enable_if_t<DIM2 == 3>> [[nodiscard]] DirectionT Rotated(const AxisT<OtherScalar, DIM>& axis, const OtherScalar2& angle),
 "output":#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
;
	SECTION("Rotate 3D") {
            DirectionT<double, 3> p1(1.0, 2.0, 3.0);
            PointT<double, 3> p2(2.0, 3.0, 4.0);
            DirectionT<double, 3> d(1.0, 1.0, 2.0);
            AxisT<double, 3> a(p2, d);
            DirectionT<double, 3> p3((9.0 - std::sqrt(6.0)) / 6.0, (9.0 - std::sqrt(6.0)) / 6.0, 3.0 + 1.0 / std::sqrt(6.0));
            CHECK(p1.Rotated(a, M_PI_2).IsEqual(p3, tol));
        }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar> explicit VectorT(const DirectionT<OtherScalar, DIM>& dir),
 "output":#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
;
	SECTION("Mirror(axis) 2D") {
        VectorT<double, 2> p1(1.0, 2.0);
        PointT<double, 2> p2(2.0, 3.0);
        DirectionT<double, 2> d(7.0, 3.0);
        AxisT<double, 2> a(p2, d);
        VectorT<double, 2> p3(62.0 / 29.0, -19.0 / 29.0);
        CHECK(p1.Mirrored(a).IsEqual(p3, tolDis, tolAng));
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar> explicit VectorT(const CoordT<OtherScalar, DIM>& v),
 "output":#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
;
	SECTION("Mirror(point) 2D") {
        VectorT<double, 2> p1(1.0, 2.0);
        VectorT<double, 2> p2(2.0, 3.0);
        VectorT<double, 2> p3(19.0 / 13.0, 22.0 / 13.0);
        CHECK(p1.Mirrored(p2).IsEqual(p3, tolDis, tolAng));
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename... T> explicit VectorT(T... vs),
 "output":#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
;
	SECTION("Angle 2D") {
        VectorT<double, 2> v1(1.0, 3.0);
        VectorT<double, 2> v2(-1.0, 2.0);
        CHECK(v1.Angle(v2) == Approx(acos(M_SQRT1_2)));
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar, typename OtherScalar2, typename OtherScalar3> [[nodiscard]] bool IsEqual(const VectorT<OtherScalar, DIM>& other, const OtherScalar2& tolDis, const OtherScalar3& tolAng),
 "output":#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
;
	SECTION("Mirror(point) 2D") {
        VectorT<double, 2> p1(1.0, 2.0);
        VectorT<double, 2> p2(2.0, 3.0);
        VectorT<double, 2> p3(19.0 / 13.0, 22.0 / 13.0);
        CHECK(p1.Mirrored(p2).IsEqual(p3, tolDis, tolAng));
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar, int DIM2 = DIM, std::enable_if_t<DIM2 == 2, int> = 0> [[nodiscard]] auto Angle(const VectorT<OtherScalar, DIM>& other),
 "output":#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
;
	SECTION("Angle 2D") {
        VectorT<double, 2> v1(1.0, 3.0);
        VectorT<double, 2> v2(-1.0, 2.0);
        CHECK(v1.Angle(v2) == Approx(acos(M_SQRT1_2)));
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar> [[nodiscard]] auto Cross(const VectorT<OtherScalar, DIM>& other),
 "output":#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
;
	SECTION("Cross 2D") {
        VectorT<double, 2> v1(1.0, 2.0);
        VectorT<double, 2> v2(2.0, 3.0);
        CHECK(v1.Cross(v2) == -1.0);
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar> VectorT& Mirror(const VectorT<OtherScalar, DIM>& p),
 "output":#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
;
	SECTION("Mirror(point) 2D") {
        VectorT<double, 2> p1(1.0, 2.0);
        VectorT<double, 2> p2(2.0, 3.0);
        VectorT<double, 2> p3(19.0 / 13.0, 22.0 / 13.0);
        CHECK(p1.Mirrored(p2).IsEqual(p3, tolDis, tolAng));
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar> VectorT& Mirror(const AxisT<OtherScalar, DIM>& axis),
 "output":#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
;
	SECTION("Mirror(axis) 2D") {
        VectorT<double, 2> p1(1.0, 2.0);
        PointT<double, 2> p2(2.0, 3.0);
        DirectionT<double, 2> d(7.0, 3.0);
        AxisT<double, 2> a(p2, d);
        VectorT<double, 2> p3(62.0 / 29.0, -19.0 / 29.0);
        CHECK(p1.Mirrored(a).IsEqual(p3, tolDis, tolAng));
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar> [[nodiscard]] VectorT Mirrored(const VectorT<OtherScalar, DIM>& p),
 "output":#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
;
	SECTION("Mirror(axis) 2D") {
        VectorT<double, 2> p1(1.0, 2.0);
        PointT<double, 2> p2(2.0, 3.0);
        DirectionT<double, 2> d(7.0, 3.0);
        AxisT<double, 2> a(p2, d);
        VectorT<double, 2> p3(62.0 / 29.0, -19.0 / 29.0);
        CHECK(p1.Mirrored(a).IsEqual(p3, tolDis, tolAng));
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar> [[nodiscard]] VectorT Mirrored(const AxisT<OtherScalar, DIM>& axis),
 "output":#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
;
	SECTION("Mirror(axis) 2D") {
        VectorT<double, 2> p1(1.0, 2.0);
        PointT<double, 2> p2(2.0, 3.0);
        DirectionT<double, 2> d(7.0, 3.0);
        AxisT<double, 2> a(p2, d);
        VectorT<double, 2> p3(62.0 / 29.0, -19.0 / 29.0);
        CHECK(p1.Mirrored(a).IsEqual(p3, tolDis, tolAng));
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar, int DIM2 = DIM, typename = typename std::enable_if_t<DIM2 == 2>> VectorT& Rotate(const OtherScalar& angle),
 "output":#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
;
	SECTION("Rotate 2D") {
        VectorT<double, 2> p1(1.0, 2.0);
        VectorT<double, 2> p3(-2.0, 1.0);
        CHECK(p1.Rotated(M_PI_2).IsEqual(p3, tolDis, tolAng));
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar, int DIM2 = DIM, typename = typename std::enable_if_t<DIM2 == 2>> [[nodiscard]] VectorT Rotated(const OtherScalar& angle),
 "output":#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
;
	SECTION("Rotate 2D") {
        VectorT<double, 2> p1(1.0, 2.0);
        VectorT<double, 2> p3(-2.0, 1.0);
        CHECK(p1.Rotated(M_PI_2).IsEqual(p3, tolDis, tolAng));
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar> [[nodiscard]] auto Dot(const VectorT<OtherScalar, DIM>& other),
 "output":#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
;
	SECTION("Dot") {
        VectorT<double, 4> v1(1.0, 2.0, 3.0, 4.0);
        VectorT<double, 4> v2(3.0, 4.0, 1.0, 2.0);
        CHECK(v1.Dot(v2) == Approx(22.0));
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] auto Norm()	 @return The norm of vector
	 @brief Get the norm of vector
,
 "output":#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
;
	SECTION("Norm") {
        VectorT<double, 3> v1(1.0, 2.0, 3.0);
        CHECK(v1.Norm() == sqrt(14.0));
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":VectorT()	 @details The default vector is (0, 0, ..., 0)
	 @brief The default constructor
,
 "output":#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
;
	SECTION("Default constructor") {
        VectorT<double, 3> p1;
        VectorT<double, 3> p2(0.0, 0.0, 0.0);
        CHECK(p1.IsEqual(p2, tolDis, tolAng));
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar> explicit VectorT(const DirectionT<OtherScalar, DIM>& dir),
 "output":#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
;
	SECTION("Default constructor") {
        VectorT<double, 3> p1;
        VectorT<double, 3> p2(0.0, 0.0, 0.0);
        CHECK(p1.IsEqual(p2, tolDis, tolAng));
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar> explicit VectorT(const CoordT<OtherScalar, DIM>& v),
 "output":#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
;
	SECTION("Default constructor") {
        VectorT<double, 3> p1;
        VectorT<double, 3> p2(0.0, 0.0, 0.0);
        CHECK(p1.IsEqual(p2, tolDis, tolAng));
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename... T> explicit VectorT(T... vs),
 "output":#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
;
	SECTION("Default constructor") {
        VectorT<double, 3> p1;
        VectorT<double, 3> p2(0.0, 0.0, 0.0);
        CHECK(p1.IsEqual(p2, tolDis, tolAng));
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar, typename OtherScalar2> VectorT(const PointT<OtherScalar, DIM>& p1, const PointT<OtherScalar2, DIM>& p2),
 "output":#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
;
	SECTION("Constructor from two points") {
        PointT<double, 3> p1(1.0, 2.0, 3.0);
        PointT<double, 3> p2(2.0, 3.0, 4.0);
        VectorT<double, 3> result(p1, p2);
        VectorT<double, 3> expected(1.0, 1.0, 1.0);
        CHECK(result.IsEqual(expected, tolDis, tolAng));
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename... T> void SetCoord(T... vs),
 "output":#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
;
	SECTION("SetCoord(x, y, z)") {
        VectorT<double, 3> result;
        result.SetCoord(1.0, 2.0, 3.0);
        VectorT<double, 3> expected(1.0, 2.0, 3.0);
        CHECK(result.IsEqual(expected, tolDis, tolAng));
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar> void SetCoord(const CoordT<OtherScalar, DIM>& v),
 "output":#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
;
	SECTION("SetCoord(v)") {
        VectorT<double, 3> result;
        result.SetCoord(CoordT<double, 3>(1.0, 2.0, 3.0));
        VectorT<double, 3> expected(1.0, 2.0, 3.0);
        CHECK(result.IsEqual(expected, tolDis, tolAng));
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar, typename OtherScalar2, typename OtherScalar3> [[nodiscard]] bool IsEqual(const VectorT<OtherScalar, DIM>& other, const OtherScalar2& tolDis, const OtherScalar3& tolAng),
 "output":#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
;
	SECTION("Default constructor") {
        VectorT<double, 3> p1;
        VectorT<double, 3> p2(0.0, 0.0, 0.0);
        CHECK(p1.IsEqual(p2, tolDis, tolAng));
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar, typename OtherScalar2> [[nodiscard]] bool IsNormal(const VectorT<OtherScalar, DIM>& other, const OtherScalar2& tol),
 "output":#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
;
	SECTION("IsNormal") {
        VectorT<double, 3> v1(1.0, 2.0, 3.0);
        VectorT<double, 3> v2(-4.0, -1.0, 2.01);
        CHECK(v1.IsNormal(v2, 0.001) == false);
        CHECK(v1.IsNormal(v2, 0.1) == true);
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar, typename OtherScalar2> [[nodiscard]] bool IsOpposite(const VectorT<OtherScalar, DIM>& other, const OtherScalar2& tol),
 "output":#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
;
	SECTION("IsOpposite") {
        VectorT<double, 3> v1(1.0, 2.0, 3.0);
        VectorT<double, 3> v2(-1.0, -2.0, -3.01);
        CHECK(v1.IsOpposite(v2, tolDis) == false);
        CHECK(v1.IsOpposite(v2, 0.1) == true);
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar, typename OtherScalar2> [[nodiscard]] bool IsParallel(const VectorT<OtherScalar, DIM>& other, const OtherScalar2& tol),
 "output":#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
;
	SECTION("IsParallel") {
        VectorT<double, 3> v1(1.0, 2.0, 3.0);
        VectorT<double, 3> v2(-1.0, -2.0, -3.01);
        CHECK(v1.IsParallel(v2, tolDis) == false);
        CHECK(v1.IsParallel(v2, 0.1) == true);
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar, int DIM2 = DIM, std::enable_if_t<DIM2 == 2, int> = 0> [[nodiscard]] auto Angle(const VectorT<OtherScalar, DIM>& other),
 "output":#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
;
	SECTION("Angle 3D") {
        VectorT<double, 3> v1(1.0, 2.0, 3.0);
        VectorT<double, 3> v2(-3.0, 2.0, -1.0);
        CHECK(v1.Angle(v2) == acos(-1.0 / 7.0));
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar, int DIM2 = DIM, std::enable_if_t<DIM2 == 3, int> = 0> [[nodiscard]] auto Angle(const VectorT<OtherScalar, DIM>& other),
 "output":#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
;
	SECTION("Angle 3D") {
        VectorT<double, 3> v1(1.0, 2.0, 3.0);
        VectorT<double, 3> v2(-3.0, 2.0, -1.0);
        CHECK(v1.Angle(v2) == acos(-1.0 / 7.0));
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar, typename OtherScalar2, int DIM2 = DIM, typename = typename std::enable_if_t<DIM2 == 3>> [[nodiscard]] Scalar AngleWithRef(const VectorT<OtherScalar, DIM>& other, const VectorT<OtherScalar2, DIM>& ref),
 "output":#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
;
	SECTION("AngleWithRef") {
        VectorT<double, 3> v1(1.0, 2.0, 3.0);
        VectorT<double, 3> v2(-3.0, 2.0, -1.0);
        VectorT<double, 3> v3(1.0, 1.0, 1.0);
        CHECK(v1.AngleWithRef(v2, v3) == -acos(-1.0 / 7.0));
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] double SquaredNorm()	 @return The squared norm of vector
	 @brief Get the squared norm of vector
,
 "output":#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
;
	SECTION("SquaredNorm") {
        VectorT<double, 3> v1(1.0, 2.0, 3.0);
        CHECK(v1.SquaredNorm() == Approx(14.0));
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar> [[nodiscard]] auto Cross(const VectorT<OtherScalar, DIM>& other),
 "output":#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
;
	SECTION("Cross 3D") {
        VectorT<double, 3> v1(1.0, 2.0, 3.0);
        VectorT<double, 3> v2(2.0, 3.0, 4.0);
        VectorT<double, 3> v3(-1.0, 2.0, -1.0);
        CHECK(v1.Cross(v2).IsEqual(v3, tolDis, tolAng));
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":VectorT& Normalize()	 @return The reference to self
	 @brief Normalize the vector
,
 "output":#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
;
	SECTION("Normalize") {
        VectorT<double, 3> v1(1.0, 2.0, 2.0);
        VectorT<double, 3> v2(1.0 / 3.0, 2.0 / 3.0, 2.0 / 3.0);
        CHECK(v1.Normalized().IsEqual(v2, tolDis, tolAng));
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] VectorT Normalized()	 @return The normalized vector
	 @brief Get the normalized vector
,
 "output":#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
;
	SECTION("Normalize") {
        VectorT<double, 3> v1(1.0, 2.0, 2.0);
        VectorT<double, 3> v2(1.0 / 3.0, 2.0 / 3.0, 2.0 / 3.0);
        CHECK(v1.Normalized().IsEqual(v2, tolDis, tolAng));
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":VectorT& Reverse()	 @return The reference to self
	 @brief Reverse the vector
,
 "output":#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
;
	SECTION("Reverse") {
        VectorT<double, 3> v1(1.0, 2.0, 2.0);
        VectorT<double, 3> v2(-1.0, -2.0, -2.0);
        CHECK(v1.IsEqual(-v2, tolDis, tolAng));
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar> VectorT& Mirror(const VectorT<OtherScalar, DIM>& p),
 "output":#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
;
	SECTION("Mirror(axis) 3D") {
        VectorT<double, 3> p1(1.0, 2.0, 3.0);
        PointT<double, 3> p2(2.0, 3.0, 4.0);
        DirectionT<double, 3> d(7.0, 3.0, 2.0);
        AxisT<double, 3> a(p2, d);
        VectorT<double, 3> p3(102.0 / 31.0, -5.0 / 31.0, -55.0 / 31.0);
        CHECK(p1.Mirrored(a).IsEqual(p3, tolDis, tolAng));
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar> VectorT& Mirror(const AxisT<OtherScalar, DIM>& axis),
 "output":#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
;
	SECTION("Mirror(axis) 3D") {
        VectorT<double, 3> p1(1.0, 2.0, 3.0);
        PointT<double, 3> p2(2.0, 3.0, 4.0);
        DirectionT<double, 3> d(7.0, 3.0, 2.0);
        AxisT<double, 3> a(p2, d);
        VectorT<double, 3> p3(102.0 / 31.0, -5.0 / 31.0, -55.0 / 31.0);
        CHECK(p1.Mirrored(a).IsEqual(p3, tolDis, tolAng));
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar, int DIM2 = DIM, std::enable_if_t<DIM2 == 3, int> = 0> VectorT& Mirror(const FrameT<OtherScalar, DIM>& frame),
 "output":#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
;
	SECTION("Mirror(axis) 3D") {
        VectorT<double, 3> p1(1.0, 2.0, 3.0);
        PointT<double, 3> p2(2.0, 3.0, 4.0);
        DirectionT<double, 3> d(7.0, 3.0, 2.0);
        AxisT<double, 3> a(p2, d);
        VectorT<double, 3> p3(102.0 / 31.0, -5.0 / 31.0, -55.0 / 31.0);
        CHECK(p1.Mirrored(a).IsEqual(p3, tolDis, tolAng));
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar> [[nodiscard]] VectorT Mirrored(const VectorT<OtherScalar, DIM>& p),
 "output":#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
;
	SECTION("Mirror(point) 3D") {
        VectorT<double, 3> p1(1.0, 2.0, 3.0);
        VectorT<double, 3> p2(2.0, 4.0, 5.0);
        VectorT<double, 3> p3(11.0 / 9.0, 22.0 / 9.0, 23.0 / 9.0);
        CHECK(p1.Mirrored(p2).IsEqual(p3, tolDis, tolAng));
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar> [[nodiscard]] VectorT Mirrored(const AxisT<OtherScalar, DIM>& axis),
 "output":#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
;
	SECTION("Mirror(point) 3D") {
        VectorT<double, 3> p1(1.0, 2.0, 3.0);
        VectorT<double, 3> p2(2.0, 4.0, 5.0);
        VectorT<double, 3> p3(11.0 / 9.0, 22.0 / 9.0, 23.0 / 9.0);
        CHECK(p1.Mirrored(p2).IsEqual(p3, tolDis, tolAng));
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar, int DIM2 = DIM, std::enable_if_t<DIM2 == 3, int> = 0> [[nodiscard]] VectorT Mirrored(const FrameT<OtherScalar, DIM>& frame),
 "output":#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
;
	SECTION("Mirror(point) 3D") {
        VectorT<double, 3> p1(1.0, 2.0, 3.0);
        VectorT<double, 3> p2(2.0, 4.0, 5.0);
        VectorT<double, 3> p3(11.0 / 9.0, 22.0 / 9.0, 23.0 / 9.0);
        CHECK(p1.Mirrored(p2).IsEqual(p3, tolDis, tolAng));
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar, typename OtherScalar2, int DIM2 = DIM, typename = typename std::enable_if_t<DIM2 == 3>> [[nodiscard]] VectorT Rotated(const AxisT<OtherScalar, DIM>& axis, const OtherScalar2& angle),
 "output":#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
;
	SECTION("Rotate 3D") {
        VectorT<double, 3> p1(1.0, 2.0, 3.0);
        PointT<double, 3> p2(2.0, 3.0, 4.0);
        DirectionT<double, 3> d(1.0, 1.0, 2.0);
        AxisT<double, 3> a(p2, d);
        VectorT<double, 3> p3((9.0 - std::sqrt(6.0)) / 6.0, (9.0 - std::sqrt(6.0)) / 6.0, 3.0 + 1.0 / std::sqrt(6.0));
        CHECK(p1.Rotated(a, M_PI_2).IsEqual(p3, tolDis, tolAng));
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar> [[nodiscard]] VectorT Scaled(const OtherScalar& scale),
 "output":#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
;
	SECTION("Scale") {
        VectorT<double, 3> p1(1.0, 2.0, 3.0);
        VectorT<double, 3> p3(1.5, 3.0, 4.5);
        CHECK(p1.Scaled(1.5).IsEqual(p3, tolDis, tolAng));
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] TransformationType Type()	 @return The transformation type
	 @brief Get the type of the transformation
,
 "output":#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T>
static bool IsEqual(const T& result, const T& expected)
{
	return result == expected;
}
static bool IsEqual(const double& result, const double& expected)
{
	return std::fabs(result - expected) <= 1e-15;
}
template<typename T, int DIM>
static bool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)
{
	for (int i = 0; i < DIM; i++)
	{
		if (!IsEqual(result[i], expected[i]))
		{
			return false;
		}
	}
	return true;
}
template<typename T, int ROW, int COL>
static bool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)
{
	for (int i = 0; i < ROW; i++)
	{
		for (int j = 0; j < COL; j++)
		{
			if (!IsEqual(result(i, j), expected(i, j)))
			{
				return false;
			}
		}
	}
	return true;
}
template<typename T, int DIM>
bool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)
{
	return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());
}
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());
	}
	else if constexpr (DIM == 2)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());
	}
	else if constexpr (DIM == 3)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());
	}
	else
	{
		return false;
	}
}
template<typename T, int DIM>
bool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)
{
	return IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());
}
#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T>
static bool IsEqual(const T& result, const T& expected)
{
	return result == expected;
}
static bool IsEqual(const double& result, const double& expected)
{
	return std::fabs(result - expected) <= 1e-15;
}
template<typename T, int DIM>
static bool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)
{
	for (int i = 0; i < DIM; i++)
	{
		if (!IsEqual(result[i], expected[i]))
		{
			return false;
		}
	}
	return true;
}
template<typename T, int ROW, int COL>
static bool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)
{
	for (int i = 0; i < ROW; i++)
	{
		for (int j = 0; j < COL; j++)
		{
			if (!IsEqual(result(i, j), expected(i, j)))
			{
				return false;
			}
		}
	}
	return true;
}
template<typename T, int DIM>
bool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)
{
	return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());
}
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());
	}
	else if constexpr (DIM == 2)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());
	}
	else if constexpr (DIM == 3)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());
	}
	else
	{
		return false;
	}
}
template<typename T, int DIM>
bool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)
{
	return IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());
;
	SECTION("default constructor 2D") {
		TransformationT<double, 2> tr;
		MatrixT<double, 2, 2> mat;
		mat.SetIdentity();
		CoordT<double, 2> c;
		double scale = 1.0;
		CHECK(IsEqual(tr.ScaleFactor(), scale));
		CHECK(IsEqual(tr.Type(), TransformationType::Identity));
		CHECK(IsEqual(tr.HVectorialPart(), mat));
		CHECK(IsEqual(tr.TranslationPart(), c));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] const CoordT<Scalar, DIM>& TranslationPart()	 @return The translation part
	 @brief Get the translation part of the transformation
,
 "output":#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T>
static bool IsEqual(const T& result, const T& expected)
{
	return result == expected;
}
static bool IsEqual(const double& result, const double& expected)
{
	return std::fabs(result - expected) <= 1e-15;
}
template<typename T, int DIM>
static bool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)
{
	for (int i = 0; i < DIM; i++)
	{
		if (!IsEqual(result[i], expected[i]))
		{
			return false;
		}
	}
	return true;
}
template<typename T, int ROW, int COL>
static bool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)
{
	for (int i = 0; i < ROW; i++)
	{
		for (int j = 0; j < COL; j++)
		{
			if (!IsEqual(result(i, j), expected(i, j)))
			{
				return false;
			}
		}
	}
	return true;
}
template<typename T, int DIM>
bool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)
{
	return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());
}
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());
	}
	else if constexpr (DIM == 2)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());
	}
	else if constexpr (DIM == 3)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());
	}
	else
	{
		return false;
	}
}
template<typename T, int DIM>
bool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)
{
	return IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());
}
#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T>
static bool IsEqual(const T& result, const T& expected)
{
	return result == expected;
}
static bool IsEqual(const double& result, const double& expected)
{
	return std::fabs(result - expected) <= 1e-15;
}
template<typename T, int DIM>
static bool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)
{
	for (int i = 0; i < DIM; i++)
	{
		if (!IsEqual(result[i], expected[i]))
		{
			return false;
		}
	}
	return true;
}
template<typename T, int ROW, int COL>
static bool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)
{
	for (int i = 0; i < ROW; i++)
	{
		for (int j = 0; j < COL; j++)
		{
			if (!IsEqual(result(i, j), expected(i, j)))
			{
				return false;
			}
		}
	}
	return true;
}
template<typename T, int DIM>
bool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)
{
	return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());
}
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());
	}
	else if constexpr (DIM == 2)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());
	}
	else if constexpr (DIM == 3)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());
	}
	else
	{
		return false;
	}
}
template<typename T, int DIM>
bool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)
{
	return IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());
;
	SECTION("default constructor 2D") {
		TransformationT<double, 2> tr;
		MatrixT<double, 2, 2> mat;
		mat.SetIdentity();
		CoordT<double, 2> c;
		double scale = 1.0;
		CHECK(IsEqual(tr.ScaleFactor(), scale));
		CHECK(IsEqual(tr.Type(), TransformationType::Identity));
		CHECK(IsEqual(tr.HVectorialPart(), mat));
		CHECK(IsEqual(tr.TranslationPart(), c));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar> void SetMirror(const PointT<OtherScalar, DIM>& point),
 "output":#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T>
static bool IsEqual(const T& result, const T& expected)
{
	return result == expected;
}
static bool IsEqual(const double& result, const double& expected)
{
	return std::fabs(result - expected) <= 1e-15;
}
template<typename T, int DIM>
static bool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)
{
	for (int i = 0; i < DIM; i++)
	{
		if (!IsEqual(result[i], expected[i]))
		{
			return false;
		}
	}
	return true;
}
template<typename T, int ROW, int COL>
static bool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)
{
	for (int i = 0; i < ROW; i++)
	{
		for (int j = 0; j < COL; j++)
		{
			if (!IsEqual(result(i, j), expected(i, j)))
			{
				return false;
			}
		}
	}
	return true;
}
template<typename T, int DIM>
bool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)
{
	return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());
}
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());
	}
	else if constexpr (DIM == 2)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());
	}
	else if constexpr (DIM == 3)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());
	}
	else
	{
		return false;
	}
}
template<typename T, int DIM>
bool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)
{
	return IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());
}
#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T>
static bool IsEqual(const T& result, const T& expected)
{
	return result == expected;
}
static bool IsEqual(const double& result, const double& expected)
{
	return std::fabs(result - expected) <= 1e-15;
}
template<typename T, int DIM>
static bool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)
{
	for (int i = 0; i < DIM; i++)
	{
		if (!IsEqual(result[i], expected[i]))
		{
			return false;
		}
	}
	return true;
}
template<typename T, int ROW, int COL>
static bool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)
{
	for (int i = 0; i < ROW; i++)
	{
		for (int j = 0; j < COL; j++)
		{
			if (!IsEqual(result(i, j), expected(i, j)))
			{
				return false;
			}
		}
	}
	return true;
}
template<typename T, int DIM>
bool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)
{
	return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());
}
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());
	}
	else if constexpr (DIM == 2)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());
	}
	else if constexpr (DIM == 3)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());
	}
	else
	{
		return false;
	}
}
template<typename T, int DIM>
bool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)
{
	return IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());
;
	SECTION("SetMirror axis 2D") {
		TransformationT<double, 2> tr;
		AxisT<double, 2> axis(PointT<double, 2>(2.0, 3.0), DirectionT<double, 2>(7.0, 3.0));
		tr.SetMirror(axis);
		CoordT<double, 2> p(1.0, 2.0);
		tr.Transform(p);
		CoordT<double, 2> p2(17.0 / 29.0, 86.0 / 29.0);
		CHECK(IsEqual(p, p2));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar> void SetMirror(const AxisT<OtherScalar, DIM>& axis),
 "output":#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T>
static bool IsEqual(const T& result, const T& expected)
{
	return result == expected;
}
static bool IsEqual(const double& result, const double& expected)
{
	return std::fabs(result - expected) <= 1e-15;
}
template<typename T, int DIM>
static bool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)
{
	for (int i = 0; i < DIM; i++)
	{
		if (!IsEqual(result[i], expected[i]))
		{
			return false;
		}
	}
	return true;
}
template<typename T, int ROW, int COL>
static bool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)
{
	for (int i = 0; i < ROW; i++)
	{
		for (int j = 0; j < COL; j++)
		{
			if (!IsEqual(result(i, j), expected(i, j)))
			{
				return false;
			}
		}
	}
	return true;
}
template<typename T, int DIM>
bool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)
{
	return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());
}
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());
	}
	else if constexpr (DIM == 2)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());
	}
	else if constexpr (DIM == 3)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());
	}
	else
	{
		return false;
	}
}
template<typename T, int DIM>
bool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)
{
	return IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());
}
#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T>
static bool IsEqual(const T& result, const T& expected)
{
	return result == expected;
}
static bool IsEqual(const double& result, const double& expected)
{
	return std::fabs(result - expected) <= 1e-15;
}
template<typename T, int DIM>
static bool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)
{
	for (int i = 0; i < DIM; i++)
	{
		if (!IsEqual(result[i], expected[i]))
		{
			return false;
		}
	}
	return true;
}
template<typename T, int ROW, int COL>
static bool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)
{
	for (int i = 0; i < ROW; i++)
	{
		for (int j = 0; j < COL; j++)
		{
			if (!IsEqual(result(i, j), expected(i, j)))
			{
				return false;
			}
		}
	}
	return true;
}
template<typename T, int DIM>
bool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)
{
	return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());
}
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());
	}
	else if constexpr (DIM == 2)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());
	}
	else if constexpr (DIM == 3)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());
	}
	else
	{
		return false;
	}
}
template<typename T, int DIM>
bool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)
{
	return IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());
;
	SECTION("SetMirror axis 2D") {
		TransformationT<double, 2> tr;
		AxisT<double, 2> axis(PointT<double, 2>(2.0, 3.0), DirectionT<double, 2>(7.0, 3.0));
		tr.SetMirror(axis);
		CoordT<double, 2> p(1.0, 2.0);
		tr.Transform(p);
		CoordT<double, 2> p2(17.0 / 29.0, 86.0 / 29.0);
		CHECK(IsEqual(p, p2));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar, typename OtherScalar2> void SetScale(const PointT<OtherScalar, DIM>& point, const OtherScalar2& s),
 "output":#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T>
static bool IsEqual(const T& result, const T& expected)
{
	return result == expected;
}
static bool IsEqual(const double& result, const double& expected)
{
	return std::fabs(result - expected) <= 1e-15;
}
template<typename T, int DIM>
static bool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)
{
	for (int i = 0; i < DIM; i++)
	{
		if (!IsEqual(result[i], expected[i]))
		{
			return false;
		}
	}
	return true;
}
template<typename T, int ROW, int COL>
static bool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)
{
	for (int i = 0; i < ROW; i++)
	{
		for (int j = 0; j < COL; j++)
		{
			if (!IsEqual(result(i, j), expected(i, j)))
			{
				return false;
			}
		}
	}
	return true;
}
template<typename T, int DIM>
bool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)
{
	return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());
}
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());
	}
	else if constexpr (DIM == 2)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());
	}
	else if constexpr (DIM == 3)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());
	}
	else
	{
		return false;
	}
}
template<typename T, int DIM>
bool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)
{
	return IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());
}
#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T>
static bool IsEqual(const T& result, const T& expected)
{
	return result == expected;
}
static bool IsEqual(const double& result, const double& expected)
{
	return std::fabs(result - expected) <= 1e-15;
}
template<typename T, int DIM>
static bool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)
{
	for (int i = 0; i < DIM; i++)
	{
		if (!IsEqual(result[i], expected[i]))
		{
			return false;
		}
	}
	return true;
}
template<typename T, int ROW, int COL>
static bool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)
{
	for (int i = 0; i < ROW; i++)
	{
		for (int j = 0; j < COL; j++)
		{
			if (!IsEqual(result(i, j), expected(i, j)))
			{
				return false;
			}
		}
	}
	return true;
}
template<typename T, int DIM>
bool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)
{
	return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());
}
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());
	}
	else if constexpr (DIM == 2)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());
	}
	else if constexpr (DIM == 3)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());
	}
	else
	{
		return false;
	}
}
template<typename T, int DIM>
bool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)
{
	return IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());
;
	SECTION("SetScale 2D") {
		TransformationT<double, 2> tr;
		tr.SetScale(PointT<double, 2>(2.0, 3.0), 1.5);
		CoordT<double, 2> p(1.0, 2.0);
		tr.Transform(p);
		CoordT<double, 2> p2(0.5, 1.5);
		CHECK(IsEqual(p, p2));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar, typename OtherScalar2, int DIM2 = DIM, typename = typename std::enable_if_t<DIM2 == 2>> void SetTransformation(const AxisT<OtherScalar, DIM>& axisFrom, const AxisT<OtherScalar2, DIM>& axisTo),
 "output":#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T>
static bool IsEqual(const T& result, const T& expected)
{
	return result == expected;
}
static bool IsEqual(const double& result, const double& expected)
{
	return std::fabs(result - expected) <= 1e-15;
}
template<typename T, int DIM>
static bool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)
{
	for (int i = 0; i < DIM; i++)
	{
		if (!IsEqual(result[i], expected[i]))
		{
			return false;
		}
	}
	return true;
}
template<typename T, int ROW, int COL>
static bool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)
{
	for (int i = 0; i < ROW; i++)
	{
		for (int j = 0; j < COL; j++)
		{
			if (!IsEqual(result(i, j), expected(i, j)))
			{
				return false;
			}
		}
	}
	return true;
}
template<typename T, int DIM>
bool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)
{
	return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());
}
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());
	}
	else if constexpr (DIM == 2)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());
	}
	else if constexpr (DIM == 3)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());
	}
	else
	{
		return false;
	}
}
template<typename T, int DIM>
bool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)
{
	return IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());
}
#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T>
static bool IsEqual(const T& result, const T& expected)
{
	return result == expected;
}
static bool IsEqual(const double& result, const double& expected)
{
	return std::fabs(result - expected) <= 1e-15;
}
template<typename T, int DIM>
static bool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)
{
	for (int i = 0; i < DIM; i++)
	{
		if (!IsEqual(result[i], expected[i]))
		{
			return false;
		}
	}
	return true;
}
template<typename T, int ROW, int COL>
static bool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)
{
	for (int i = 0; i < ROW; i++)
	{
		for (int j = 0; j < COL; j++)
		{
			if (!IsEqual(result(i, j), expected(i, j)))
			{
				return false;
			}
		}
	}
	return true;
}
template<typename T, int DIM>
bool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)
{
	return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());
}
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());
	}
	else if constexpr (DIM == 2)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());
	}
	else if constexpr (DIM == 3)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());
	}
	else
	{
		return false;
	}
}
template<typename T, int DIM>
bool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)
{
	return IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());
;
	SECTION("SetTransformation 2D") {
		Axis2 a1(PointT<double, 2>(1.0, 2.0), DirectionT<double, 2>(3.0, 4.0));
		Axis2 a2(PointT<double, 2>(3.0, 1.0), DirectionT<double, 2>(1.0, 5.0));
		TransformationT<double, 2> tr;
		tr.SetTransformation(a1, a2);
		CoordT<double, 2> p(4.0, 1.0);
		tr.Transform(p);
		CoordT<double, 2> p2(118.0 / (5.0 * std::sqrt(26.0)), 34.0 / (5.0 * std::sqrt(26.0)));
		CHECK(IsEqual(p, p2));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar, int DIM2 = DIM, typename = typename std::enable_if_t<DIM2 == 2>> void SetTransformation(const AxisT<OtherScalar, DIM>& axisTo),
 "output":#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T>
static bool IsEqual(const T& result, const T& expected)
{
	return result == expected;
}
static bool IsEqual(const double& result, const double& expected)
{
	return std::fabs(result - expected) <= 1e-15;
}
template<typename T, int DIM>
static bool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)
{
	for (int i = 0; i < DIM; i++)
	{
		if (!IsEqual(result[i], expected[i]))
		{
			return false;
		}
	}
	return true;
}
template<typename T, int ROW, int COL>
static bool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)
{
	for (int i = 0; i < ROW; i++)
	{
		for (int j = 0; j < COL; j++)
		{
			if (!IsEqual(result(i, j), expected(i, j)))
			{
				return false;
			}
		}
	}
	return true;
}
template<typename T, int DIM>
bool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)
{
	return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());
}
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());
	}
	else if constexpr (DIM == 2)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());
	}
	else if constexpr (DIM == 3)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());
	}
	else
	{
		return false;
	}
}
template<typename T, int DIM>
bool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)
{
	return IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());
}
#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T>
static bool IsEqual(const T& result, const T& expected)
{
	return result == expected;
}
static bool IsEqual(const double& result, const double& expected)
{
	return std::fabs(result - expected) <= 1e-15;
}
template<typename T, int DIM>
static bool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)
{
	for (int i = 0; i < DIM; i++)
	{
		if (!IsEqual(result[i], expected[i]))
		{
			return false;
		}
	}
	return true;
}
template<typename T, int ROW, int COL>
static bool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)
{
	for (int i = 0; i < ROW; i++)
	{
		for (int j = 0; j < COL; j++)
		{
			if (!IsEqual(result(i, j), expected(i, j)))
			{
				return false;
			}
		}
	}
	return true;
}
template<typename T, int DIM>
bool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)
{
	return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());
}
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());
	}
	else if constexpr (DIM == 2)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());
	}
	else if constexpr (DIM == 3)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());
	}
	else
	{
		return false;
	}
}
template<typename T, int DIM>
bool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)
{
	return IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());
;
	SECTION("SetTransformation 2D") {
		Axis2 a1(PointT<double, 2>(1.0, 2.0), DirectionT<double, 2>(3.0, 4.0));
		TransformationT<double, 2> tr;
		tr.SetTransformation(a1);
		CoordT<double, 2> p(4.0, 1.0);
		tr.Transform(p);
		CoordT<double, 2> p2(1.0, -3.0);
		CHECK(IsEqual(p, p2));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] Scalar ScaleFactor()	 @return The scale factor
	 @brief Get the scale factor of the transformation
,
 "output":#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T>
static bool IsEqual(const T& result, const T& expected)
{
	return result == expected;
}
static bool IsEqual(const double& result, const double& expected)
{
	return std::fabs(result - expected) <= 1e-15;
}
template<typename T, int DIM>
static bool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)
{
	for (int i = 0; i < DIM; i++)
	{
		if (!IsEqual(result[i], expected[i]))
		{
			return false;
		}
	}
	return true;
}
template<typename T, int ROW, int COL>
static bool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)
{
	for (int i = 0; i < ROW; i++)
	{
		for (int j = 0; j < COL; j++)
		{
			if (!IsEqual(result(i, j), expected(i, j)))
			{
				return false;
			}
		}
	}
	return true;
}
template<typename T, int DIM>
bool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)
{
	return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());
}
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());
	}
	else if constexpr (DIM == 2)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());
	}
	else if constexpr (DIM == 3)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());
	}
	else
	{
		return false;
	}
}
template<typename T, int DIM>
bool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)
{
	return IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());
}
#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T>
static bool IsEqual(const T& result, const T& expected)
{
	return result == expected;
}
static bool IsEqual(const double& result, const double& expected)
{
	return std::fabs(result - expected) <= 1e-15;
}
template<typename T, int DIM>
static bool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)
{
	for (int i = 0; i < DIM; i++)
	{
		if (!IsEqual(result[i], expected[i]))
		{
			return false;
		}
	}
	return true;
}
template<typename T, int ROW, int COL>
static bool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)
{
	for (int i = 0; i < ROW; i++)
	{
		for (int j = 0; j < COL; j++)
		{
			if (!IsEqual(result(i, j), expected(i, j)))
			{
				return false;
			}
		}
	}
	return true;
}
template<typename T, int DIM>
bool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)
{
	return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());
}
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());
	}
	else if constexpr (DIM == 2)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());
	}
	else if constexpr (DIM == 3)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());
	}
	else
	{
		return false;
	}
}
template<typename T, int DIM>
bool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)
{
	return IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());
;
	SECTION("default constructor 2D") {
		TransformationT<double, 2> tr;
		MatrixT<double, 2, 2> mat;
		mat.SetIdentity();
		CoordT<double, 2> c;
		double scale = 1.0;
		CHECK(IsEqual(tr.ScaleFactor(), scale));
		CHECK(IsEqual(tr.Type(), TransformationType::Identity));
		CHECK(IsEqual(tr.HVectorialPart(), mat));
		CHECK(IsEqual(tr.TranslationPart(), c));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] const MatrixT<Scalar, DIM, DIM>& HVectorialPart()	 @return The homogeneous matrix
	 @brief Get the homogeneous vectorial part of the transformation, i.e. the rotation matrix
,
 "output":#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T>
static bool IsEqual(const T& result, const T& expected)
{
	return result == expected;
}
static bool IsEqual(const double& result, const double& expected)
{
	return std::fabs(result - expected) <= 1e-15;
}
template<typename T, int DIM>
static bool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)
{
	for (int i = 0; i < DIM; i++)
	{
		if (!IsEqual(result[i], expected[i]))
		{
			return false;
		}
	}
	return true;
}
template<typename T, int ROW, int COL>
static bool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)
{
	for (int i = 0; i < ROW; i++)
	{
		for (int j = 0; j < COL; j++)
		{
			if (!IsEqual(result(i, j), expected(i, j)))
			{
				return false;
			}
		}
	}
	return true;
}
template<typename T, int DIM>
bool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)
{
	return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());
}
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());
	}
	else if constexpr (DIM == 2)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());
	}
	else if constexpr (DIM == 3)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());
	}
	else
	{
		return false;
	}
}
template<typename T, int DIM>
bool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)
{
	return IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());
}
#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T>
static bool IsEqual(const T& result, const T& expected)
{
	return result == expected;
}
static bool IsEqual(const double& result, const double& expected)
{
	return std::fabs(result - expected) <= 1e-15;
}
template<typename T, int DIM>
static bool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)
{
	for (int i = 0; i < DIM; i++)
	{
		if (!IsEqual(result[i], expected[i]))
		{
			return false;
		}
	}
	return true;
}
template<typename T, int ROW, int COL>
static bool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)
{
	for (int i = 0; i < ROW; i++)
	{
		for (int j = 0; j < COL; j++)
		{
			if (!IsEqual(result(i, j), expected(i, j)))
			{
				return false;
			}
		}
	}
	return true;
}
template<typename T, int DIM>
bool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)
{
	return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());
}
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());
	}
	else if constexpr (DIM == 2)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());
	}
	else if constexpr (DIM == 3)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());
	}
	else
	{
		return false;
	}
}
template<typename T, int DIM>
bool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)
{
	return IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());
;
	SECTION("default constructor 2D") {
		TransformationT<double, 2> tr;
		MatrixT<double, 2, 2> mat;
		mat.SetIdentity();
		CoordT<double, 2> c;
		double scale = 1.0;
		CHECK(IsEqual(tr.ScaleFactor(), scale));
		CHECK(IsEqual(tr.Type(), TransformationType::Identity));
		CHECK(IsEqual(tr.HVectorialPart(), mat));
		CHECK(IsEqual(tr.TranslationPart(), c));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar> void Transform(CoordT<OtherScalar, DIM>& coord),
 "output":#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T>
static bool IsEqual(const T& result, const T& expected)
{
	return result == expected;
}
static bool IsEqual(const double& result, const double& expected)
{
	return std::fabs(result - expected) <= 1e-15;
}
template<typename T, int DIM>
static bool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)
{
	for (int i = 0; i < DIM; i++)
	{
		if (!IsEqual(result[i], expected[i]))
		{
			return false;
		}
	}
	return true;
}
template<typename T, int ROW, int COL>
static bool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)
{
	for (int i = 0; i < ROW; i++)
	{
		for (int j = 0; j < COL; j++)
		{
			if (!IsEqual(result(i, j), expected(i, j)))
			{
				return false;
			}
		}
	}
	return true;
}
template<typename T, int DIM>
bool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)
{
	return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());
}
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());
	}
	else if constexpr (DIM == 2)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());
	}
	else if constexpr (DIM == 3)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());
	}
	else
	{
		return false;
	}
}
template<typename T, int DIM>
bool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)
{
	return IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());
}
#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T>
static bool IsEqual(const T& result, const T& expected)
{
	return result == expected;
}
static bool IsEqual(const double& result, const double& expected)
{
	return std::fabs(result - expected) <= 1e-15;
}
template<typename T, int DIM>
static bool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)
{
	for (int i = 0; i < DIM; i++)
	{
		if (!IsEqual(result[i], expected[i]))
		{
			return false;
		}
	}
	return true;
}
template<typename T, int ROW, int COL>
static bool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)
{
	for (int i = 0; i < ROW; i++)
	{
		for (int j = 0; j < COL; j++)
		{
			if (!IsEqual(result(i, j), expected(i, j)))
			{
				return false;
			}
		}
	}
	return true;
}
template<typename T, int DIM>
bool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)
{
	return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());
}
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());
	}
	else if constexpr (DIM == 2)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());
	}
	else if constexpr (DIM == 3)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());
	}
	else
	{
		return false;
	}
}
template<typename T, int DIM>
bool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)
{
	return IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());
;
	SECTION("SetMirror axis 2D") {
		TransformationT<double, 2> tr;
		AxisT<double, 2> axis(PointT<double, 2>(2.0, 3.0), DirectionT<double, 2>(7.0, 3.0));
		tr.SetMirror(axis);
		CoordT<double, 2> p(1.0, 2.0);
		tr.Transform(p);
		CoordT<double, 2> p2(17.0 / 29.0, 86.0 / 29.0);
		CHECK(IsEqual(p, p2));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] TransformationType Type()	 @return The transformation type
	 @brief Get the type of the transformation
,
 "output":#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T>
bool IsEqual(const T& result, const T& expected)
{
	return result == expected;
}
bool IsEqual(const double& result, const double& expected)
{
	return std::fabs(result - expected) <= 1e-6;
}
template<typename T, int DIM>
bool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)
{
	for (int i = 0; i < DIM; i++)
	{
		if (!IsEqual(result[i], expected[i]))
		{
			return false;
		}
	}
	return true;
}
template<typename T, int ROW, int COL>
bool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)
{
	for (int i = 0; i < ROW; i++)
	{
		for (int j = 0; j < COL; j++)
		{
			if (!IsEqual(result(i, j), expected(i, j)))
			{
				return false;
			}
		}
	}
	return true;
}
template<typename T, int DIM>
bool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)
{
	return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());
}
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());
	}
	else if constexpr (DIM == 2)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());
	}
	else if constexpr (DIM == 3)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());
	}
	else
	{
		return false;
	}
}
template<typename T, int DIM>
bool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)
{
	return IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());
}
#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T>
bool IsEqual(const T& result, const T& expected)
{
	return result == expected;
}
bool IsEqual(const double& result, const double& expected)
{
	return std::fabs(result - expected) <= 1e-6;
}
template<typename T, int DIM>
bool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)
{
	for (int i = 0; i < DIM; i++)
	{
		if (!IsEqual(result[i], expected[i]))
		{
			return false;
		}
	}
	return true;
}
template<typename T, int ROW, int COL>
bool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)
{
	for (int i = 0; i < ROW; i++)
	{
		for (int j = 0; j < COL; j++)
		{
			if (!IsEqual(result(i, j), expected(i, j)))
			{
				return false;
			}
		}
	}
	return true;
}
template<typename T, int DIM>
bool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)
{
	return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());
}
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());
	}
	else if constexpr (DIM == 2)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());
	}
	else if constexpr (DIM == 3)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());
	}
	else
	{
		return false;
	}
}
template<typename T, int DIM>
bool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)
{
	return IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());
;
	SECTION("default constructor 3D") {
		TransformationT<double, 3> tr;
		MatrixT<double, 3, 3> mat;
		mat.SetIdentity();
		CoordT<double, 3> c;
		double scale = 1.0;
		CHECK(IsEqual(tr.ScaleFactor(), scale));
		CHECK(IsEqual(tr.Type(), TransformationType::Identity));
		CHECK(IsEqual(tr.HVectorialPart(), mat));
		CHECK(IsEqual(tr.TranslationPart(), c));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] const CoordT<Scalar, DIM>& TranslationPart()	 @return The translation part
	 @brief Get the translation part of the transformation
,
 "output":#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T>
bool IsEqual(const T& result, const T& expected)
{
	return result == expected;
}
bool IsEqual(const double& result, const double& expected)
{
	return std::fabs(result - expected) <= 1e-6;
}
template<typename T, int DIM>
bool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)
{
	for (int i = 0; i < DIM; i++)
	{
		if (!IsEqual(result[i], expected[i]))
		{
			return false;
		}
	}
	return true;
}
template<typename T, int ROW, int COL>
bool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)
{
	for (int i = 0; i < ROW; i++)
	{
		for (int j = 0; j < COL; j++)
		{
			if (!IsEqual(result(i, j), expected(i, j)))
			{
				return false;
			}
		}
	}
	return true;
}
template<typename T, int DIM>
bool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)
{
	return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());
}
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());
	}
	else if constexpr (DIM == 2)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());
	}
	else if constexpr (DIM == 3)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());
	}
	else
	{
		return false;
	}
}
template<typename T, int DIM>
bool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)
{
	return IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());
}
#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T>
bool IsEqual(const T& result, const T& expected)
{
	return result == expected;
}
bool IsEqual(const double& result, const double& expected)
{
	return std::fabs(result - expected) <= 1e-6;
}
template<typename T, int DIM>
bool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)
{
	for (int i = 0; i < DIM; i++)
	{
		if (!IsEqual(result[i], expected[i]))
		{
			return false;
		}
	}
	return true;
}
template<typename T, int ROW, int COL>
bool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)
{
	for (int i = 0; i < ROW; i++)
	{
		for (int j = 0; j < COL; j++)
		{
			if (!IsEqual(result(i, j), expected(i, j)))
			{
				return false;
			}
		}
	}
	return true;
}
template<typename T, int DIM>
bool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)
{
	return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());
}
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());
	}
	else if constexpr (DIM == 2)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());
	}
	else if constexpr (DIM == 3)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());
	}
	else
	{
		return false;
	}
}
template<typename T, int DIM>
bool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)
{
	return IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());
;
	SECTION("default constructor 3D") {
		TransformationT<double, 3> tr;
		MatrixT<double, 3, 3> mat;
		mat.SetIdentity();
		CoordT<double, 3> c;
		double scale = 1.0;
		CHECK(IsEqual(tr.ScaleFactor(), scale));
		CHECK(IsEqual(tr.Type(), TransformationType::Identity));
		CHECK(IsEqual(tr.HVectorialPart(), mat));
		CHECK(IsEqual(tr.TranslationPart(), c));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":constexpr TransformationT()	 @details The default transformation is the identity transformation
	 @brief Default constructor
,
 "output":#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T>
bool IsEqual(const T& result, const T& expected)
{
	return result == expected;
}
bool IsEqual(const double& result, const double& expected)
{
	return std::fabs(result - expected) <= 1e-6;
}
template<typename T, int DIM>
bool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)
{
	for (int i = 0; i < DIM; i++)
	{
		if (!IsEqual(result[i], expected[i]))
		{
			return false;
		}
	}
	return true;
}
template<typename T, int ROW, int COL>
bool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)
{
	for (int i = 0; i < ROW; i++)
	{
		for (int j = 0; j < COL; j++)
		{
			if (!IsEqual(result(i, j), expected(i, j)))
			{
				return false;
			}
		}
	}
	return true;
}
template<typename T, int DIM>
bool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)
{
	return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());
}
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());
	}
	else if constexpr (DIM == 2)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());
	}
	else if constexpr (DIM == 3)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());
	}
	else
	{
		return false;
	}
}
template<typename T, int DIM>
bool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)
{
	return IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());
}
#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T>
bool IsEqual(const T& result, const T& expected)
{
	return result == expected;
}
bool IsEqual(const double& result, const double& expected)
{
	return std::fabs(result - expected) <= 1e-6;
}
template<typename T, int DIM>
bool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)
{
	for (int i = 0; i < DIM; i++)
	{
		if (!IsEqual(result[i], expected[i]))
		{
			return false;
		}
	}
	return true;
}
template<typename T, int ROW, int COL>
bool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)
{
	for (int i = 0; i < ROW; i++)
	{
		for (int j = 0; j < COL; j++)
		{
			if (!IsEqual(result(i, j), expected(i, j)))
			{
				return false;
			}
		}
	}
	return true;
}
template<typename T, int DIM>
bool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)
{
	return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());
}
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());
	}
	else if constexpr (DIM == 2)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());
	}
	else if constexpr (DIM == 3)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());
	}
	else
	{
		return false;
	}
}
template<typename T, int DIM>
bool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)
{
	return IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());
;
	SECTION("default constructor 3D") {
		TransformationT<double, 3> tr;
		MatrixT<double, 3, 3> mat;
		mat.SetIdentity();
		CoordT<double, 3> c;
		double scale = 1.0;
		CHECK(IsEqual(tr.ScaleFactor(), scale));
		CHECK(IsEqual(tr.Type(), TransformationType::Identity));
		CHECK(IsEqual(tr.HVectorialPart(), mat));
		CHECK(IsEqual(tr.TranslationPart(), c));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar, int OtherDIM> explicit TransformationT(const TransformationT<OtherScalar, OtherDIM>& trans),
 "output":#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T>
bool IsEqual(const T& result, const T& expected)
{
	return result == expected;
}
bool IsEqual(const double& result, const double& expected)
{
	return std::fabs(result - expected) <= 1e-6;
}
template<typename T, int DIM>
bool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)
{
	for (int i = 0; i < DIM; i++)
	{
		if (!IsEqual(result[i], expected[i]))
		{
			return false;
		}
	}
	return true;
}
template<typename T, int ROW, int COL>
bool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)
{
	for (int i = 0; i < ROW; i++)
	{
		for (int j = 0; j < COL; j++)
		{
			if (!IsEqual(result(i, j), expected(i, j)))
			{
				return false;
			}
		}
	}
	return true;
}
template<typename T, int DIM>
bool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)
{
	return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());
}
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());
	}
	else if constexpr (DIM == 2)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());
	}
	else if constexpr (DIM == 3)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());
	}
	else
	{
		return false;
	}
}
template<typename T, int DIM>
bool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)
{
	return IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());
}
#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T>
bool IsEqual(const T& result, const T& expected)
{
	return result == expected;
}
bool IsEqual(const double& result, const double& expected)
{
	return std::fabs(result - expected) <= 1e-6;
}
template<typename T, int DIM>
bool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)
{
	for (int i = 0; i < DIM; i++)
	{
		if (!IsEqual(result[i], expected[i]))
		{
			return false;
		}
	}
	return true;
}
template<typename T, int ROW, int COL>
bool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)
{
	for (int i = 0; i < ROW; i++)
	{
		for (int j = 0; j < COL; j++)
		{
			if (!IsEqual(result(i, j), expected(i, j)))
			{
				return false;
			}
		}
	}
	return true;
}
template<typename T, int DIM>
bool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)
{
	return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());
}
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());
	}
	else if constexpr (DIM == 2)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());
	}
	else if constexpr (DIM == 3)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());
	}
	else
	{
		return false;
	}
}
template<typename T, int DIM>
bool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)
{
	return IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());
;
	SECTION("Construct 3 dimension from 2 dimension") {
		TransformationT<double, 2> tr;
		tr.SetValues(3.0, 2.0, 3.0, 4.0, 5.0, 6.0);
		TransformationT<double, 3> tr2(tr);
		TransformationT<double, 3> tr3;
		tr3.SetValues(3.0, 2.0, 0.0, 3.0, 4.0, 5.0, 0.0, 6.0, 0.0, 0.0, std::sqrt(7.0), 0.0);
		CHECK(IsEqual(tr2, tr3));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar> void SetMirror(const PointT<OtherScalar, DIM>& point),
 "output":#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T>
bool IsEqual(const T& result, const T& expected)
{
	return result == expected;
}
bool IsEqual(const double& result, const double& expected)
{
	return std::fabs(result - expected) <= 1e-6;
}
template<typename T, int DIM>
bool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)
{
	for (int i = 0; i < DIM; i++)
	{
		if (!IsEqual(result[i], expected[i]))
		{
			return false;
		}
	}
	return true;
}
template<typename T, int ROW, int COL>
bool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)
{
	for (int i = 0; i < ROW; i++)
	{
		for (int j = 0; j < COL; j++)
		{
			if (!IsEqual(result(i, j), expected(i, j)))
			{
				return false;
			}
		}
	}
	return true;
}
template<typename T, int DIM>
bool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)
{
	return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());
}
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());
	}
	else if constexpr (DIM == 2)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());
	}
	else if constexpr (DIM == 3)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());
	}
	else
	{
		return false;
	}
}
template<typename T, int DIM>
bool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)
{
	return IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());
}
#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T>
bool IsEqual(const T& result, const T& expected)
{
	return result == expected;
}
bool IsEqual(const double& result, const double& expected)
{
	return std::fabs(result - expected) <= 1e-6;
}
template<typename T, int DIM>
bool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)
{
	for (int i = 0; i < DIM; i++)
	{
		if (!IsEqual(result[i], expected[i]))
		{
			return false;
		}
	}
	return true;
}
template<typename T, int ROW, int COL>
bool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)
{
	for (int i = 0; i < ROW; i++)
	{
		for (int j = 0; j < COL; j++)
		{
			if (!IsEqual(result(i, j), expected(i, j)))
			{
				return false;
			}
		}
	}
	return true;
}
template<typename T, int DIM>
bool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)
{
	return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());
}
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());
	}
	else if constexpr (DIM == 2)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());
	}
	else if constexpr (DIM == 3)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());
	}
	else
	{
		return false;
	}
}
template<typename T, int DIM>
bool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)
{
	return IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());
;
	SECTION("SetMirror point 3D") {
		TransformationT<double, 3> tr;
		PointT<double, 3> p(1.0, 2.0, 3.0);
		tr.SetMirror(p);
		CoordT<double, 3> p2(0.0, 1.0, 2.0);
		tr.Transform(p2);
		CoordT<double, 3> p3(2.0, 3.0, 4.0);
		CHECK(IsEqual(p2, p3));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar> void SetMirror(const AxisT<OtherScalar, DIM>& axis),
 "output":#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T>
bool IsEqual(const T& result, const T& expected)
{
	return result == expected;
}
bool IsEqual(const double& result, const double& expected)
{
	return std::fabs(result - expected) <= 1e-6;
}
template<typename T, int DIM>
bool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)
{
	for (int i = 0; i < DIM; i++)
	{
		if (!IsEqual(result[i], expected[i]))
		{
			return false;
		}
	}
	return true;
}
template<typename T, int ROW, int COL>
bool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)
{
	for (int i = 0; i < ROW; i++)
	{
		for (int j = 0; j < COL; j++)
		{
			if (!IsEqual(result(i, j), expected(i, j)))
			{
				return false;
			}
		}
	}
	return true;
}
template<typename T, int DIM>
bool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)
{
	return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());
}
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());
	}
	else if constexpr (DIM == 2)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());
	}
	else if constexpr (DIM == 3)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());
	}
	else
	{
		return false;
	}
}
template<typename T, int DIM>
bool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)
{
	return IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());
}
#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T>
bool IsEqual(const T& result, const T& expected)
{
	return result == expected;
}
bool IsEqual(const double& result, const double& expected)
{
	return std::fabs(result - expected) <= 1e-6;
}
template<typename T, int DIM>
bool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)
{
	for (int i = 0; i < DIM; i++)
	{
		if (!IsEqual(result[i], expected[i]))
		{
			return false;
		}
	}
	return true;
}
template<typename T, int ROW, int COL>
bool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)
{
	for (int i = 0; i < ROW; i++)
	{
		for (int j = 0; j < COL; j++)
		{
			if (!IsEqual(result(i, j), expected(i, j)))
			{
				return false;
			}
		}
	}
	return true;
}
template<typename T, int DIM>
bool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)
{
	return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());
}
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());
	}
	else if constexpr (DIM == 2)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());
	}
	else if constexpr (DIM == 3)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());
	}
	else
	{
		return false;
	}
}
template<typename T, int DIM>
bool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)
{
	return IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());
;
	SECTION("SetMirror axis 3D") {
		TransformationT<double, 3> tr;
		AxisT<double, 3> axis(PointT<double, 3>(2.0, 3.0, 4.0), DirectionT<double, 3>(7.0, 3.0, 2.0));
		tr.SetMirror(axis);
		CoordT<double, 3> p(1.0, 2.0, 3.0);
		tr.Transform(p);
		CoordT<double, 3> p2(9.0 / 31.0, 88.0 / 31.0, 131.0 / 31.0);
		CHECK(IsEqual(p, p2));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar, int DIM2 = DIM, std::enable_if_t<DIM2 == 3, int> = 0> void SetMirror(const FrameT<OtherScalar, DIM>& frame),
 "output":#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T>
bool IsEqual(const T& result, const T& expected)
{
	return result == expected;
}
bool IsEqual(const double& result, const double& expected)
{
	return std::fabs(result - expected) <= 1e-6;
}
template<typename T, int DIM>
bool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)
{
	for (int i = 0; i < DIM; i++)
	{
		if (!IsEqual(result[i], expected[i]))
		{
			return false;
		}
	}
	return true;
}
template<typename T, int ROW, int COL>
bool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)
{
	for (int i = 0; i < ROW; i++)
	{
		for (int j = 0; j < COL; j++)
		{
			if (!IsEqual(result(i, j), expected(i, j)))
			{
				return false;
			}
		}
	}
	return true;
}
template<typename T, int DIM>
bool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)
{
	return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());
}
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());
	}
	else if constexpr (DIM == 2)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());
	}
	else if constexpr (DIM == 3)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());
	}
	else
	{
		return false;
	}
}
template<typename T, int DIM>
bool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)
{
	return IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());
}
#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T>
bool IsEqual(const T& result, const T& expected)
{
	return result == expected;
}
bool IsEqual(const double& result, const double& expected)
{
	return std::fabs(result - expected) <= 1e-6;
}
template<typename T, int DIM>
bool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)
{
	for (int i = 0; i < DIM; i++)
	{
		if (!IsEqual(result[i], expected[i]))
		{
			return false;
		}
	}
	return true;
}
template<typename T, int ROW, int COL>
bool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)
{
	for (int i = 0; i < ROW; i++)
	{
		for (int j = 0; j < COL; j++)
		{
			if (!IsEqual(result(i, j), expected(i, j)))
			{
				return false;
			}
		}
	}
	return true;
}
template<typename T, int DIM>
bool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)
{
	return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());
}
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());
	}
	else if constexpr (DIM == 2)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());
	}
	else if constexpr (DIM == 3)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());
	}
	else
	{
		return false;
	}
}
template<typename T, int DIM>
bool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)
{
	return IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());
;
	SECTION("SetMirror point 3D") {
		TransformationT<double, 3> tr;
		PointT<double, 3> p(1.0, 2.0, 3.0);
		tr.SetMirror(p);
		CoordT<double, 3> p2(0.0, 1.0, 2.0);
		tr.Transform(p2);
		CoordT<double, 3> p3(2.0, 3.0, 4.0);
		CHECK(IsEqual(p2, p3));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar, typename OtherScalar2, int DIM2 = DIM, typename = typename std::enable_if_t<DIM2 == 2>> void SetRotation(const PointT<OtherScalar, DIM>& point, const OtherScalar2& angle),
 "output":#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T>
bool IsEqual(const T& result, const T& expected)
{
	return result == expected;
}
bool IsEqual(const double& result, const double& expected)
{
	return std::fabs(result - expected) <= 1e-6;
}
template<typename T, int DIM>
bool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)
{
	for (int i = 0; i < DIM; i++)
	{
		if (!IsEqual(result[i], expected[i]))
		{
			return false;
		}
	}
	return true;
}
template<typename T, int ROW, int COL>
bool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)
{
	for (int i = 0; i < ROW; i++)
	{
		for (int j = 0; j < COL; j++)
		{
			if (!IsEqual(result(i, j), expected(i, j)))
			{
				return false;
			}
		}
	}
	return true;
}
template<typename T, int DIM>
bool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)
{
	return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());
}
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());
	}
	else if constexpr (DIM == 2)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());
	}
	else if constexpr (DIM == 3)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());
	}
	else
	{
		return false;
	}
}
template<typename T, int DIM>
bool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)
{
	return IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());
}
#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T>
bool IsEqual(const T& result, const T& expected)
{
	return result == expected;
}
bool IsEqual(const double& result, const double& expected)
{
	return std::fabs(result - expected) <= 1e-6;
}
template<typename T, int DIM>
bool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)
{
	for (int i = 0; i < DIM; i++)
	{
		if (!IsEqual(result[i], expected[i]))
		{
			return false;
		}
	}
	return true;
}
template<typename T, int ROW, int COL>
bool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)
{
	for (int i = 0; i < ROW; i++)
	{
		for (int j = 0; j < COL; j++)
		{
			if (!IsEqual(result(i, j), expected(i, j)))
			{
				return false;
			}
		}
	}
	return true;
}
template<typename T, int DIM>
bool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)
{
	return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());
}
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());
	}
	else if constexpr (DIM == 2)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());
	}
	else if constexpr (DIM == 3)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());
	}
	else
	{
		return false;
	}
}
template<typename T, int DIM>
bool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)
{
	return IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());
;
	SECTION("SetRotation point") {
		TransformationT<double, 2> tr;
		tr.SetRotation(PointT<double, 2>(2.0, 3.0), M_PI_2);
		CoordT<double, 2> p(1.0, 2.0);
		tr.Transform(p);
		CoordT<double, 2> p2(3.0, 2.0);
		CHECK(IsEqual(p, p2));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar, typename OtherScalar2, int DIM2 = DIM, typename = typename std::enable_if_t<DIM2 == 3>> void SetRotation(const AxisT<OtherScalar, DIM>& axis, const OtherScalar2& angle),
 "output":#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T>
bool IsEqual(const T& result, const T& expected)
{
	return result == expected;
}
bool IsEqual(const double& result, const double& expected)
{
	return std::fabs(result - expected) <= 1e-6;
}
template<typename T, int DIM>
bool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)
{
	for (int i = 0; i < DIM; i++)
	{
		if (!IsEqual(result[i], expected[i]))
		{
			return false;
		}
	}
	return true;
}
template<typename T, int ROW, int COL>
bool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)
{
	for (int i = 0; i < ROW; i++)
	{
		for (int j = 0; j < COL; j++)
		{
			if (!IsEqual(result(i, j), expected(i, j)))
			{
				return false;
			}
		}
	}
	return true;
}
template<typename T, int DIM>
bool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)
{
	return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());
}
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());
	}
	else if constexpr (DIM == 2)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());
	}
	else if constexpr (DIM == 3)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());
	}
	else
	{
		return false;
	}
}
template<typename T, int DIM>
bool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)
{
	return IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());
}
#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T>
bool IsEqual(const T& result, const T& expected)
{
	return result == expected;
}
bool IsEqual(const double& result, const double& expected)
{
	return std::fabs(result - expected) <= 1e-6;
}
template<typename T, int DIM>
bool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)
{
	for (int i = 0; i < DIM; i++)
	{
		if (!IsEqual(result[i], expected[i]))
		{
			return false;
		}
	}
	return true;
}
template<typename T, int ROW, int COL>
bool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)
{
	for (int i = 0; i < ROW; i++)
	{
		for (int j = 0; j < COL; j++)
		{
			if (!IsEqual(result(i, j), expected(i, j)))
			{
				return false;
			}
		}
	}
	return true;
}
template<typename T, int DIM>
bool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)
{
	return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());
}
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());
	}
	else if constexpr (DIM == 2)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());
	}
	else if constexpr (DIM == 3)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());
	}
	else
	{
		return false;
	}
}
template<typename T, int DIM>
bool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)
{
	return IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());
;
	SECTION("SetRotation axis") {
		TransformationT<double, 3> tr;
		AxisT<double, 3> a(PointT<double, 3>(2.0, 3.0, 4.0), DirectionT<double, 3>(1.0, 1.0, 2.0));
		tr.SetRotation(a, M_PI_2);
		CoordT<double, 3> p(1.0, 2.0, 3.0);
		tr.Transform(p);
		CoordT<double, 3> p2((8.0 + std::sqrt(6.0)) / 6.0, (14.0 - std::sqrt(6.0)) / 6.0, 8.0 / 3.0);
		CHECK(IsEqual(p, p2));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar, int DIM2 = DIM, typename = typename std::enable_if_t<DIM2 == 3>> void SetRotation(const QuaternionT<OtherScalar>& q),
 "output":#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T>
bool IsEqual(const T& result, const T& expected)
{
	return result == expected;
}
bool IsEqual(const double& result, const double& expected)
{
	return std::fabs(result - expected) <= 1e-6;
}
template<typename T, int DIM>
bool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)
{
	for (int i = 0; i < DIM; i++)
	{
		if (!IsEqual(result[i], expected[i]))
		{
			return false;
		}
	}
	return true;
}
template<typename T, int ROW, int COL>
bool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)
{
	for (int i = 0; i < ROW; i++)
	{
		for (int j = 0; j < COL; j++)
		{
			if (!IsEqual(result(i, j), expected(i, j)))
			{
				return false;
			}
		}
	}
	return true;
}
template<typename T, int DIM>
bool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)
{
	return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());
}
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());
	}
	else if constexpr (DIM == 2)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());
	}
	else if constexpr (DIM == 3)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());
	}
	else
	{
		return false;
	}
}
template<typename T, int DIM>
bool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)
{
	return IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());
}
#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T>
bool IsEqual(const T& result, const T& expected)
{
	return result == expected;
}
bool IsEqual(const double& result, const double& expected)
{
	return std::fabs(result - expected) <= 1e-6;
}
template<typename T, int DIM>
bool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)
{
	for (int i = 0; i < DIM; i++)
	{
		if (!IsEqual(result[i], expected[i]))
		{
			return false;
		}
	}
	return true;
}
template<typename T, int ROW, int COL>
bool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)
{
	for (int i = 0; i < ROW; i++)
	{
		for (int j = 0; j < COL; j++)
		{
			if (!IsEqual(result(i, j), expected(i, j)))
			{
				return false;
			}
		}
	}
	return true;
}
template<typename T, int DIM>
bool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)
{
	return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());
}
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());
	}
	else if constexpr (DIM == 2)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());
	}
	else if constexpr (DIM == 3)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());
	}
	else
	{
		return false;
	}
}
template<typename T, int DIM>
bool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)
{
	return IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());
;
	SECTION("SetRotation quaternion") {
		TransformationT<double, 3> tr;
		QuaternionT<double> q(std::sqrt(3.0) / 6.0, std::sqrt(3.0) / 6.0, std::sqrt(3.0) / 3.0, std::sqrt(2.0) / 2.0);
		tr.SetRotation(q);
		CoordT<double, 3> p(-1.0, -1.0, -1.0);
		tr.Transform(p);
		CoordT<double, 3> p2((-4.0 + std::sqrt(6.0)) / 6.0, (-4.0 - std::sqrt(6.0)) / 6.0, -4.0 / 3.0);
		CHECK(IsEqual(p, p2));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar, int DIM2 = DIM, typename = typename std::enable_if_t<DIM2 == 3>> void SetRotationPart(const QuaternionT<OtherScalar>& q),
 "output":#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T>
bool IsEqual(const T& result, const T& expected)
{
	return result == expected;
}
bool IsEqual(const double& result, const double& expected)
{
	return std::fabs(result - expected) <= 1e-6;
}
template<typename T, int DIM>
bool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)
{
	for (int i = 0; i < DIM; i++)
	{
		if (!IsEqual(result[i], expected[i]))
		{
			return false;
		}
	}
	return true;
}
template<typename T, int ROW, int COL>
bool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)
{
	for (int i = 0; i < ROW; i++)
	{
		for (int j = 0; j < COL; j++)
		{
			if (!IsEqual(result(i, j), expected(i, j)))
			{
				return false;
			}
		}
	}
	return true;
}
template<typename T, int DIM>
bool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)
{
	return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());
}
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());
	}
	else if constexpr (DIM == 2)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());
	}
	else if constexpr (DIM == 3)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());
	}
	else
	{
		return false;
	}
}
template<typename T, int DIM>
bool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)
{
	return IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());
}
#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T>
bool IsEqual(const T& result, const T& expected)
{
	return result == expected;
}
bool IsEqual(const double& result, const double& expected)
{
	return std::fabs(result - expected) <= 1e-6;
}
template<typename T, int DIM>
bool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)
{
	for (int i = 0; i < DIM; i++)
	{
		if (!IsEqual(result[i], expected[i]))
		{
			return false;
		}
	}
	return true;
}
template<typename T, int ROW, int COL>
bool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)
{
	for (int i = 0; i < ROW; i++)
	{
		for (int j = 0; j < COL; j++)
		{
			if (!IsEqual(result(i, j), expected(i, j)))
			{
				return false;
			}
		}
	}
	return true;
}
template<typename T, int DIM>
bool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)
{
	return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());
}
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());
	}
	else if constexpr (DIM == 2)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());
	}
	else if constexpr (DIM == 3)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());
	}
	else
	{
		return false;
	}
}
template<typename T, int DIM>
bool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)
{
	return IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());
;
	SECTION("SetRotationPart quaternion") {
		TransformationT<double, 3> tr;
		tr.SetTranslation(VectorT<double, 3>(2.0 / 3.0, 2.0 / 3.0, 4.0 / 3.0));
		QuaternionT<double> q(std::sqrt(3.0) / 6.0, std::sqrt(3.0) / 6.0, std::sqrt(3.0) / 3.0, std::sqrt(2.0) / 2.0);
		tr.SetRotationPart(q);
		CoordT<double, 3> p(-1.0, -1.0, -1.0);
		tr.Transform(p);
		CoordT<double, 3> p2(std::sqrt(6.0) / 6.0, -std::sqrt(6.0) / 6.0, 0.0);
		CHECK(IsEqual(p, p2));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar, typename OtherScalar2> void SetScale(const PointT<OtherScalar, DIM>& point, const OtherScalar2& s),
 "output":#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T>
bool IsEqual(const T& result, const T& expected)
{
	return result == expected;
}
bool IsEqual(const double& result, const double& expected)
{
	return std::fabs(result - expected) <= 1e-6;
}
template<typename T, int DIM>
bool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)
{
	for (int i = 0; i < DIM; i++)
	{
		if (!IsEqual(result[i], expected[i]))
		{
			return false;
		}
	}
	return true;
}
template<typename T, int ROW, int COL>
bool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)
{
	for (int i = 0; i < ROW; i++)
	{
		for (int j = 0; j < COL; j++)
		{
			if (!IsEqual(result(i, j), expected(i, j)))
			{
				return false;
			}
		}
	}
	return true;
}
template<typename T, int DIM>
bool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)
{
	return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());
}
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());
	}
	else if constexpr (DIM == 2)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());
	}
	else if constexpr (DIM == 3)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());
	}
	else
	{
		return false;
	}
}
template<typename T, int DIM>
bool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)
{
	return IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());
}
#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T>
bool IsEqual(const T& result, const T& expected)
{
	return result == expected;
}
bool IsEqual(const double& result, const double& expected)
{
	return std::fabs(result - expected) <= 1e-6;
}
template<typename T, int DIM>
bool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)
{
	for (int i = 0; i < DIM; i++)
	{
		if (!IsEqual(result[i], expected[i]))
		{
			return false;
		}
	}
	return true;
}
template<typename T, int ROW, int COL>
bool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)
{
	for (int i = 0; i < ROW; i++)
	{
		for (int j = 0; j < COL; j++)
		{
			if (!IsEqual(result(i, j), expected(i, j)))
			{
				return false;
			}
		}
	}
	return true;
}
template<typename T, int DIM>
bool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)
{
	return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());
}
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());
	}
	else if constexpr (DIM == 2)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());
	}
	else if constexpr (DIM == 3)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());
	}
	else
	{
		return false;
	}
}
template<typename T, int DIM>
bool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)
{
	return IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());
;
	SECTION("SetScale 3D") {
		TransformationT<double, 3> tr;
		tr.SetScale(PointT<double, 3>(2.0, 3.0, 4.0), 1.5);
		CoordT<double, 3> p(1.0, 2.0, 3.0);
		tr.Transform(p);
		CoordT<double, 3> p2(0.5, 1.5, 2.5);
		CHECK(IsEqual(p, p2));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar, typename OtherScalar2, int DIM2 = DIM, typename = typename std::enable_if_t<DIM2 == 3>> void SetDisplacement(const FrameT<OtherScalar, DIM>& frameFrom, const FrameT<OtherScalar2, DIM>& frameTo),
 "output":#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T>
bool IsEqual(const T& result, const T& expected)
{
	return result == expected;
}
bool IsEqual(const double& result, const double& expected)
{
	return std::fabs(result - expected) <= 1e-6;
}
template<typename T, int DIM>
bool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)
{
	for (int i = 0; i < DIM; i++)
	{
		if (!IsEqual(result[i], expected[i]))
		{
			return false;
		}
	}
	return true;
}
template<typename T, int ROW, int COL>
bool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)
{
	for (int i = 0; i < ROW; i++)
	{
		for (int j = 0; j < COL; j++)
		{
			if (!IsEqual(result(i, j), expected(i, j)))
			{
				return false;
			}
		}
	}
	return true;
}
template<typename T, int DIM>
bool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)
{
	return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());
}
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());
	}
	else if constexpr (DIM == 2)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());
	}
	else if constexpr (DIM == 3)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());
	}
	else
	{
		return false;
	}
}
template<typename T, int DIM>
bool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)
{
	return IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());
}
#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T>
bool IsEqual(const T& result, const T& expected)
{
	return result == expected;
}
bool IsEqual(const double& result, const double& expected)
{
	return std::fabs(result - expected) <= 1e-6;
}
template<typename T, int DIM>
bool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)
{
	for (int i = 0; i < DIM; i++)
	{
		if (!IsEqual(result[i], expected[i]))
		{
			return false;
		}
	}
	return true;
}
template<typename T, int ROW, int COL>
bool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)
{
	for (int i = 0; i < ROW; i++)
	{
		for (int j = 0; j < COL; j++)
		{
			if (!IsEqual(result(i, j), expected(i, j)))
			{
				return false;
			}
		}
	}
	return true;
}
template<typename T, int DIM>
bool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)
{
	return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());
}
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());
	}
	else if constexpr (DIM == 2)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());
	}
	else if constexpr (DIM == 3)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());
	}
	else
	{
		return false;
	}
}
template<typename T, int DIM>
bool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)
{
	return IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());
;
	SECTION("SetDisplacement") {
		FrameT<double, 3> f1(PointT<double, 3>(1.0, 2.0, 3.0), DirectionT<double, 3>(4.0, 5.0, 6.0), DirectionT<double, 3>(-3.0, -5.0, 1.0));
		FrameT<double, 3> f2(PointT<double, 3>(3.0, 1.0, -1.0), DirectionT<double, 3>(1.0, 5.0, -3.0), DirectionT<double, 3>(2.0, -2.0, 2.0));
		TransformationT<double, 3> tr;
		tr.SetDisplacement(f1, f2);
		CoordT<double, 3> p(4.0, 1.0, 3.0);
		tr.Transform(p);
		CoordT<double, 3> p2(7.0 / (7.0 * std::sqrt(55.0)) - 273.0 / (34.0 * std::sqrt(1155.0)) + 127.0 / (34.0 * std::sqrt(21.0)) + 3.0,
			35.0 / (7.0 * std::sqrt(55.0)) - 254.0 / (34.0 * std::sqrt(21.0)) + 1.0,
			-21.0 / (7.0 * std::sqrt(55.0)) - 91.0 / (34.0 * std::sqrt(1155.0)) - 381.0 / (34.0 * std::sqrt(21.0)) - 1.0);
		CHECK(IsEqual(p, p2));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar, typename OtherScalar2, int DIM2 = DIM, typename = typename std::enable_if_t<DIM2 == 3>> void SetTransformation(const FrameT<OtherScalar, DIM>& frameFrom, const FrameT<OtherScalar2, DIM>& frameTo),
 "output":#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T>
bool IsEqual(const T& result, const T& expected)
{
	return result == expected;
}
bool IsEqual(const double& result, const double& expected)
{
	return std::fabs(result - expected) <= 1e-6;
}
template<typename T, int DIM>
bool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)
{
	for (int i = 0; i < DIM; i++)
	{
		if (!IsEqual(result[i], expected[i]))
		{
			return false;
		}
	}
	return true;
}
template<typename T, int ROW, int COL>
bool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)
{
	for (int i = 0; i < ROW; i++)
	{
		for (int j = 0; j < COL; j++)
		{
			if (!IsEqual(result(i, j), expected(i, j)))
			{
				return false;
			}
		}
	}
	return true;
}
template<typename T, int DIM>
bool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)
{
	return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());
}
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());
	}
	else if constexpr (DIM == 2)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());
	}
	else if constexpr (DIM == 3)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());
	}
	else
	{
		return false;
	}
}
template<typename T, int DIM>
bool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)
{
	return IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());
}
#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T>
bool IsEqual(const T& result, const T& expected)
{
	return result == expected;
}
bool IsEqual(const double& result, const double& expected)
{
	return std::fabs(result - expected) <= 1e-6;
}
template<typename T, int DIM>
bool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)
{
	for (int i = 0; i < DIM; i++)
	{
		if (!IsEqual(result[i], expected[i]))
		{
			return false;
		}
	}
	return true;
}
template<typename T, int ROW, int COL>
bool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)
{
	for (int i = 0; i < ROW; i++)
	{
		for (int j = 0; j < COL; j++)
		{
			if (!IsEqual(result(i, j), expected(i, j)))
			{
				return false;
			}
		}
	}
	return true;
}
template<typename T, int DIM>
bool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)
{
	return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());
}
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());
	}
	else if constexpr (DIM == 2)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());
	}
	else if constexpr (DIM == 3)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());
	}
	else
	{
		return false;
	}
}
template<typename T, int DIM>
bool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)
{
	return IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());
;
	SECTION("SetTransformation 3D") {	
		FrameT<double, 3> f1(PointT<double, 3>(1.0, 2.0, 3.0), DirectionT<double, 3>(4.0, 5.0, 6.0), DirectionT<double, 3>(-3.0, -5.0, 1.0));
		FrameT<double, 3> f2(PointT<double, 3>(3.0, 1.0, -1.0), DirectionT<double, 3>(1.0, 5.0, -3.0), DirectionT<double, 3>(2.0, -2.0, 2.0));
		TransformationT<double, 3> tr;
		tr.SetTransformation(f1, f2);
		CoordT<double, 3> p(4.0, 1.0, 3.0);
		tr.Transform(p);
		CoordT<double, 3> p2(54.0 / std::sqrt(770.0) - 232.0 / (34.0 * std::sqrt(1155.0)) + 100.0 / (34.0 * std::sqrt(15.0)) - 2.0 / std::sqrt(10.0),
			-72.0 / (7.0 * std::sqrt(22.0)) - 1744.0 / (238.0 * std::sqrt(33.0)) + 94.0 / (34.0 * std::sqrt(21.0)) - 16.0 / std::sqrt(14.0),
			33.0 / (7.0 * std::sqrt(55.0)) - 8184.0 / (119.0 * std::sqrt(330.0)) - 60.0 / (17.0 * std::sqrt(210.0)) - 9.0 / std::sqrt(35.0));
		CHECK(IsEqual(p, p2));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar, int DIM2 = DIM, typename = typename std::enable_if_t<DIM2 == 2>> void SetTransformation(const AxisT<OtherScalar, DIM>& axisTo),
 "output":#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T>
bool IsEqual(const T& result, const T& expected)
{
	return result == expected;
}
bool IsEqual(const double& result, const double& expected)
{
	return std::fabs(result - expected) <= 1e-6;
}
template<typename T, int DIM>
bool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)
{
	for (int i = 0; i < DIM; i++)
	{
		if (!IsEqual(result[i], expected[i]))
		{
			return false;
		}
	}
	return true;
}
template<typename T, int ROW, int COL>
bool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)
{
	for (int i = 0; i < ROW; i++)
	{
		for (int j = 0; j < COL; j++)
		{
			if (!IsEqual(result(i, j), expected(i, j)))
			{
				return false;
			}
		}
	}
	return true;
}
template<typename T, int DIM>
bool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)
{
	return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());
}
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());
	}
	else if constexpr (DIM == 2)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());
	}
	else if constexpr (DIM == 3)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());
	}
	else
	{
		return false;
	}
}
template<typename T, int DIM>
bool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)
{
	return IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());
}
#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T>
bool IsEqual(const T& result, const T& expected)
{
	return result == expected;
}
bool IsEqual(const double& result, const double& expected)
{
	return std::fabs(result - expected) <= 1e-6;
}
template<typename T, int DIM>
bool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)
{
	for (int i = 0; i < DIM; i++)
	{
		if (!IsEqual(result[i], expected[i]))
		{
			return false;
		}
	}
	return true;
}
template<typename T, int ROW, int COL>
bool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)
{
	for (int i = 0; i < ROW; i++)
	{
		for (int j = 0; j < COL; j++)
		{
			if (!IsEqual(result(i, j), expected(i, j)))
			{
				return false;
			}
		}
	}
	return true;
}
template<typename T, int DIM>
bool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)
{
	return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());
}
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());
	}
	else if constexpr (DIM == 2)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());
	}
	else if constexpr (DIM == 3)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());
	}
	else
	{
		return false;
	}
}
template<typename T, int DIM>
bool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)
{
	return IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());
;
	SECTION("SetTransformation 3D") {
		FrameT<double, 3> f1(PointT<double, 3>(1.0, 2.0, 3.0), DirectionT<double, 3>(4.0, 5.0, 6.0), DirectionT<double, 3>(-3.0, -5.0, 1.0));
		TransformationT<double, 3> tr;
		tr.SetTransformation(f1);
		CoordT<double, 3> p(4.0, 1.0, 3.0);
		tr.Transform(p);
		CoordT<double, 3> p2(-91.0 / (17.0 * std::sqrt(462.0)), 127.0 / (17.0 * std::sqrt(6.0)), 7.0 / std::sqrt(77.0));
		CHECK(IsEqual(p, p2));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar, int DIM2 = DIM, typename = typename std::enable_if_t<DIM2 == 3>> void SetTransformation(const FrameT<OtherScalar, DIM>& frameTo),
 "output":#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T>
bool IsEqual(const T& result, const T& expected)
{
	return result == expected;
}
bool IsEqual(const double& result, const double& expected)
{
	return std::fabs(result - expected) <= 1e-6;
}
template<typename T, int DIM>
bool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)
{
	for (int i = 0; i < DIM; i++)
	{
		if (!IsEqual(result[i], expected[i]))
		{
			return false;
		}
	}
	return true;
}
template<typename T, int ROW, int COL>
bool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)
{
	for (int i = 0; i < ROW; i++)
	{
		for (int j = 0; j < COL; j++)
		{
			if (!IsEqual(result(i, j), expected(i, j)))
			{
				return false;
			}
		}
	}
	return true;
}
template<typename T, int DIM>
bool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)
{
	return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());
}
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());
	}
	else if constexpr (DIM == 2)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());
	}
	else if constexpr (DIM == 3)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());
	}
	else
	{
		return false;
	}
}
template<typename T, int DIM>
bool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)
{
	return IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());
}
#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T>
bool IsEqual(const T& result, const T& expected)
{
	return result == expected;
}
bool IsEqual(const double& result, const double& expected)
{
	return std::fabs(result - expected) <= 1e-6;
}
template<typename T, int DIM>
bool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)
{
	for (int i = 0; i < DIM; i++)
	{
		if (!IsEqual(result[i], expected[i]))
		{
			return false;
		}
	}
	return true;
}
template<typename T, int ROW, int COL>
bool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)
{
	for (int i = 0; i < ROW; i++)
	{
		for (int j = 0; j < COL; j++)
		{
			if (!IsEqual(result(i, j), expected(i, j)))
			{
				return false;
			}
		}
	}
	return true;
}
template<typename T, int DIM>
bool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)
{
	return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());
}
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());
	}
	else if constexpr (DIM == 2)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());
	}
	else if constexpr (DIM == 3)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());
	}
	else
	{
		return false;
	}
}
template<typename T, int DIM>
bool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)
{
	return IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());
;
	SECTION("SetTransformation 3D") {	
		FrameT<double, 3> f1(PointT<double, 3>(1.0, 2.0, 3.0), DirectionT<double, 3>(4.0, 5.0, 6.0), DirectionT<double, 3>(-3.0, -5.0, 1.0));
		FrameT<double, 3> f2(PointT<double, 3>(3.0, 1.0, -1.0), DirectionT<double, 3>(1.0, 5.0, -3.0), DirectionT<double, 3>(2.0, -2.0, 2.0));
		TransformationT<double, 3> tr;
		tr.SetTransformation(f1, f2);
		CoordT<double, 3> p(4.0, 1.0, 3.0);
		tr.Transform(p);
		CoordT<double, 3> p2(54.0 / std::sqrt(770.0) - 232.0 / (34.0 * std::sqrt(1155.0)) + 100.0 / (34.0 * std::sqrt(15.0)) - 2.0 / std::sqrt(10.0),
			-72.0 / (7.0 * std::sqrt(22.0)) - 1744.0 / (238.0 * std::sqrt(33.0)) + 94.0 / (34.0 * std::sqrt(21.0)) - 16.0 / std::sqrt(14.0),
			33.0 / (7.0 * std::sqrt(55.0)) - 8184.0 / (119.0 * std::sqrt(330.0)) - 60.0 / (17.0 * std::sqrt(210.0)) - 9.0 / std::sqrt(35.0));
		CHECK(IsEqual(p, p2));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar> void SetTranslation(const VectorT<OtherScalar, DIM>& vec),
 "output":#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T>
bool IsEqual(const T& result, const T& expected)
{
	return result == expected;
}
bool IsEqual(const double& result, const double& expected)
{
	return std::fabs(result - expected) <= 1e-6;
}
template<typename T, int DIM>
bool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)
{
	for (int i = 0; i < DIM; i++)
	{
		if (!IsEqual(result[i], expected[i]))
		{
			return false;
		}
	}
	return true;
}
template<typename T, int ROW, int COL>
bool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)
{
	for (int i = 0; i < ROW; i++)
	{
		for (int j = 0; j < COL; j++)
		{
			if (!IsEqual(result(i, j), expected(i, j)))
			{
				return false;
			}
		}
	}
	return true;
}
template<typename T, int DIM>
bool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)
{
	return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());
}
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());
	}
	else if constexpr (DIM == 2)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());
	}
	else if constexpr (DIM == 3)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());
	}
	else
	{
		return false;
	}
}
template<typename T, int DIM>
bool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)
{
	return IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());
}
#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T>
bool IsEqual(const T& result, const T& expected)
{
	return result == expected;
}
bool IsEqual(const double& result, const double& expected)
{
	return std::fabs(result - expected) <= 1e-6;
}
template<typename T, int DIM>
bool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)
{
	for (int i = 0; i < DIM; i++)
	{
		if (!IsEqual(result[i], expected[i]))
		{
			return false;
		}
	}
	return true;
}
template<typename T, int ROW, int COL>
bool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)
{
	for (int i = 0; i < ROW; i++)
	{
		for (int j = 0; j < COL; j++)
		{
			if (!IsEqual(result(i, j), expected(i, j)))
			{
				return false;
			}
		}
	}
	return true;
}
template<typename T, int DIM>
bool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)
{
	return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());
}
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());
	}
	else if constexpr (DIM == 2)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());
	}
	else if constexpr (DIM == 3)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());
	}
	else
	{
		return false;
	}
}
template<typename T, int DIM>
bool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)
{
	return IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());
;
	SECTION("SetTranslation vector 2D") {
		TransformationT<double, 2> tr;
		tr.SetTranslation(VectorT<double, 2>(1.0, 2.0));
		CoordT<double, 2> p(1.0, 2.0);
		tr.Transform(p);
		CoordT<double, 2> p2(2.0, 4.0);
		CHECK(IsEqual(p, p2));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar, typename OtherScalar2> void SetTranslation(const PointT<OtherScalar, DIM>& p1, const PointT<OtherScalar2, DIM>& p2),
 "output":#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T>
bool IsEqual(const T& result, const T& expected)
{
	return result == expected;
}
bool IsEqual(const double& result, const double& expected)
{
	return std::fabs(result - expected) <= 1e-6;
}
template<typename T, int DIM>
bool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)
{
	for (int i = 0; i < DIM; i++)
	{
		if (!IsEqual(result[i], expected[i]))
		{
			return false;
		}
	}
	return true;
}
template<typename T, int ROW, int COL>
bool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)
{
	for (int i = 0; i < ROW; i++)
	{
		for (int j = 0; j < COL; j++)
		{
			if (!IsEqual(result(i, j), expected(i, j)))
			{
				return false;
			}
		}
	}
	return true;
}
template<typename T, int DIM>
bool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)
{
	return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());
}
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());
	}
	else if constexpr (DIM == 2)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());
	}
	else if constexpr (DIM == 3)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());
	}
	else
	{
		return false;
	}
}
template<typename T, int DIM>
bool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)
{
	return IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());
}
#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T>
bool IsEqual(const T& result, const T& expected)
{
	return result == expected;
}
bool IsEqual(const double& result, const double& expected)
{
	return std::fabs(result - expected) <= 1e-6;
}
template<typename T, int DIM>
bool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)
{
	for (int i = 0; i < DIM; i++)
	{
		if (!IsEqual(result[i], expected[i]))
		{
			return false;
		}
	}
	return true;
}
template<typename T, int ROW, int COL>
bool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)
{
	for (int i = 0; i < ROW; i++)
	{
		for (int j = 0; j < COL; j++)
		{
			if (!IsEqual(result(i, j), expected(i, j)))
			{
				return false;
			}
		}
	}
	return true;
}
template<typename T, int DIM>
bool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)
{
	return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());
}
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());
	}
	else if constexpr (DIM == 2)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());
	}
	else if constexpr (DIM == 3)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());
	}
	else
	{
		return false;
	}
}
template<typename T, int DIM>
bool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)
{
	return IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());
;
	SECTION("SetTranslation point 2D") {
		TransformationT<double, 2> tr;
		tr.SetTranslation(PointT<double, 2>(1.0, 2.0), PointT<double, 2>(3.0, 4.0));
		CoordT<double, 2> p(3.0, -1.0);
		tr.Transform(p);
		CoordT<double, 2> p2(5.0, 1.0);
		CHECK(IsEqual(p, p2));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar> void SetTranslationPart(const VectorT<OtherScalar, DIM>& vec),
 "output":#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T>
bool IsEqual(const T& result, const T& expected)
{
	return result == expected;
}
bool IsEqual(const double& result, const double& expected)
{
	return std::fabs(result - expected) <= 1e-6;
}
template<typename T, int DIM>
bool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)
{
	for (int i = 0; i < DIM; i++)
	{
		if (!IsEqual(result[i], expected[i]))
		{
			return false;
		}
	}
	return true;
}
template<typename T, int ROW, int COL>
bool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)
{
	for (int i = 0; i < ROW; i++)
	{
		for (int j = 0; j < COL; j++)
		{
			if (!IsEqual(result(i, j), expected(i, j)))
			{
				return false;
			}
		}
	}
	return true;
}
template<typename T, int DIM>
bool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)
{
	return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());
}
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());
	}
	else if constexpr (DIM == 2)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());
	}
	else if constexpr (DIM == 3)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());
	}
	else
	{
		return false;
	}
}
template<typename T, int DIM>
bool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)
{
	return IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());
}
#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T>
bool IsEqual(const T& result, const T& expected)
{
	return result == expected;
}
bool IsEqual(const double& result, const double& expected)
{
	return std::fabs(result - expected) <= 1e-6;
}
template<typename T, int DIM>
bool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)
{
	for (int i = 0; i < DIM; i++)
	{
		if (!IsEqual(result[i], expected[i]))
		{
			return false;
		}
	}
	return true;
}
template<typename T, int ROW, int COL>
bool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)
{
	for (int i = 0; i < ROW; i++)
	{
		for (int j = 0; j < COL; j++)
		{
			if (!IsEqual(result(i, j), expected(i, j)))
			{
				return false;
			}
		}
	}
	return true;
}
template<typename T, int DIM>
bool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)
{
	return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());
}
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());
	}
	else if constexpr (DIM == 2)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());
	}
	else if constexpr (DIM == 3)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());
	}
	else
	{
		return false;
	}
}
template<typename T, int DIM>
bool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)
{
	return IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());
;
	SECTION("SetTranslationPart 2D") {
		TransformationT<double, 2> tr;
		tr.SetRotation(PointT<double, 2>(2.0, 3.0), M_PI_2);
		tr.SetTranslationPart(VectorT<double, 2>(1.0, 2.0));
		CoordT<double, 2> p(1.0, 2.0);
		tr.Transform(p);
		CoordT<double, 2> p2(-1.0, 3.0);
		CHECK(IsEqual(p, p2));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":void SetType(const TransformationType& t)	 @param t The new type of transformation
	 @brief Set the type of transformation
,
 "output":#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T>
bool IsEqual(const T& result, const T& expected)
{
	return result == expected;
}
bool IsEqual(const double& result, const double& expected)
{
	return std::fabs(result - expected) <= 1e-6;
}
template<typename T, int DIM>
bool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)
{
	for (int i = 0; i < DIM; i++)
	{
		if (!IsEqual(result[i], expected[i]))
		{
			return false;
		}
	}
	return true;
}
template<typename T, int ROW, int COL>
bool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)
{
	for (int i = 0; i < ROW; i++)
	{
		for (int j = 0; j < COL; j++)
		{
			if (!IsEqual(result(i, j), expected(i, j)))
			{
				return false;
			}
		}
	}
	return true;
}
template<typename T, int DIM>
bool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)
{
	return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());
}
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());
	}
	else if constexpr (DIM == 2)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());
	}
	else if constexpr (DIM == 3)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());
	}
	else
	{
		return false;
	}
}
template<typename T, int DIM>
bool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)
{
	return IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());
}
#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T>
bool IsEqual(const T& result, const T& expected)
{
	return result == expected;
}
bool IsEqual(const double& result, const double& expected)
{
	return std::fabs(result - expected) <= 1e-6;
}
template<typename T, int DIM>
bool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)
{
	for (int i = 0; i < DIM; i++)
	{
		if (!IsEqual(result[i], expected[i]))
		{
			return false;
		}
	}
	return true;
}
template<typename T, int ROW, int COL>
bool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)
{
	for (int i = 0; i < ROW; i++)
	{
		for (int j = 0; j < COL; j++)
		{
			if (!IsEqual(result(i, j), expected(i, j)))
			{
				return false;
			}
		}
	}
	return true;
}
template<typename T, int DIM>
bool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)
{
	return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());
}
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());
	}
	else if constexpr (DIM == 2)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());
	}
	else if constexpr (DIM == 3)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());
	}
	else
	{
		return false;
	}
}
template<typename T, int DIM>
bool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)
{
	return IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());
;
	SECTION("SetValues 3D") {
		TransformationT<double, 3> tr;
		double a = 1.0 / 3.0;
		double b = 1.0 / 3.0 - 1.0 / std::sqrt(3.0);
		double c = 1.0 / 3.0 + 1.0 / std::sqrt(3.0);
		tr.SetValues(a, b, c, -1.0 - 1.0 / std::sqrt(3.0), c, a, b, 2.0 / std::sqrt(3.0), b, c, a, 1.0 - 1.0 / std::sqrt(3.0));
		tr.SetType(TransformationType::Rotation);
		TransformationT<double, 3> tr2;
		tr2.SetRotation(Axis3(Point3(1.0, 2.0, 3.0), Direction3(1.0, 1.0, 1.0)), M_PI_2);
		CHECK(IsEqual(tr, tr2));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] Scalar ScaleFactor()	 @return The scale factor
	 @brief Get the scale factor of the transformation
,
 "output":#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T>
bool IsEqual(const T& result, const T& expected)
{
	return result == expected;
}
bool IsEqual(const double& result, const double& expected)
{
	return std::fabs(result - expected) <= 1e-6;
}
template<typename T, int DIM>
bool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)
{
	for (int i = 0; i < DIM; i++)
	{
		if (!IsEqual(result[i], expected[i]))
		{
			return false;
		}
	}
	return true;
}
template<typename T, int ROW, int COL>
bool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)
{
	for (int i = 0; i < ROW; i++)
	{
		for (int j = 0; j < COL; j++)
		{
			if (!IsEqual(result(i, j), expected(i, j)))
			{
				return false;
			}
		}
	}
	return true;
}
template<typename T, int DIM>
bool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)
{
	return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());
}
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());
	}
	else if constexpr (DIM == 2)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());
	}
	else if constexpr (DIM == 3)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());
	}
	else
	{
		return false;
	}
}
template<typename T, int DIM>
bool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)
{
	return IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());
}
#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T>
bool IsEqual(const T& result, const T& expected)
{
	return result == expected;
}
bool IsEqual(const double& result, const double& expected)
{
	return std::fabs(result - expected) <= 1e-6;
}
template<typename T, int DIM>
bool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)
{
	for (int i = 0; i < DIM; i++)
	{
		if (!IsEqual(result[i], expected[i]))
		{
			return false;
		}
	}
	return true;
}
template<typename T, int ROW, int COL>
bool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)
{
	for (int i = 0; i < ROW; i++)
	{
		for (int j = 0; j < COL; j++)
		{
			if (!IsEqual(result(i, j), expected(i, j)))
			{
				return false;
			}
		}
	}
	return true;
}
template<typename T, int DIM>
bool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)
{
	return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());
}
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());
	}
	else if constexpr (DIM == 2)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());
	}
	else if constexpr (DIM == 3)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());
	}
	else
	{
		return false;
	}
}
template<typename T, int DIM>
bool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)
{
	return IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());
;
	SECTION("default constructor 3D") {
		TransformationT<double, 3> tr;
		MatrixT<double, 3, 3> mat;
		mat.SetIdentity();
		CoordT<double, 3> c;
		double scale = 1.0;
		CHECK(IsEqual(tr.ScaleFactor(), scale));
		CHECK(IsEqual(tr.Type(), TransformationType::Identity));
		CHECK(IsEqual(tr.HVectorialPart(), mat));
		CHECK(IsEqual(tr.TranslationPart(), c));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar, typename OtherScalar2, int DIM2 = DIM, typename = typename std::enable_if_t<DIM2 == 3>> void GetRotation(CoordT<OtherScalar, DIM>& axis, OtherScalar2& angle),
 "output":#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T>
bool IsEqual(const T& result, const T& expected)
{
	return result == expected;
}
bool IsEqual(const double& result, const double& expected)
{
	return std::fabs(result - expected) <= 1e-6;
}
template<typename T, int DIM>
bool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)
{
	for (int i = 0; i < DIM; i++)
	{
		if (!IsEqual(result[i], expected[i]))
		{
			return false;
		}
	}
	return true;
}
template<typename T, int ROW, int COL>
bool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)
{
	for (int i = 0; i < ROW; i++)
	{
		for (int j = 0; j < COL; j++)
		{
			if (!IsEqual(result(i, j), expected(i, j)))
			{
				return false;
			}
		}
	}
	return true;
}
template<typename T, int DIM>
bool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)
{
	return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());
}
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());
	}
	else if constexpr (DIM == 2)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());
	}
	else if constexpr (DIM == 3)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());
	}
	else
	{
		return false;
	}
}
template<typename T, int DIM>
bool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)
{
	return IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());
}
#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T>
bool IsEqual(const T& result, const T& expected)
{
	return result == expected;
}
bool IsEqual(const double& result, const double& expected)
{
	return std::fabs(result - expected) <= 1e-6;
}
template<typename T, int DIM>
bool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)
{
	for (int i = 0; i < DIM; i++)
	{
		if (!IsEqual(result[i], expected[i]))
		{
			return false;
		}
	}
	return true;
}
template<typename T, int ROW, int COL>
bool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)
{
	for (int i = 0; i < ROW; i++)
	{
		for (int j = 0; j < COL; j++)
		{
			if (!IsEqual(result(i, j), expected(i, j)))
			{
				return false;
			}
		}
	}
	return true;
}
template<typename T, int DIM>
bool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)
{
	return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());
}
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());
	}
	else if constexpr (DIM == 2)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());
	}
	else if constexpr (DIM == 3)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());
	}
	else
	{
		return false;
	}
}
template<typename T, int DIM>
bool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)
{
	return IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());
;
	SECTION("GetRotation") {
		TransformationT<double, 3> tr;
		tr.SetRotation(Axis3(Point3(1.0, 2.0, 3.0), Direction3(1.0, 1.0, 1.0)), M_PI_2);
		CoordT<double, 3> axis;
		double angle;
		tr.GetRotation(axis, angle);
		CoordT<double, 3> axis2(1.0 / std::sqrt(3.0));
		double angle2 = M_PI_2;
		CHECK(IsEqual(axis, axis2));
		CHECK(IsEqual(angle, angle2));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] const MatrixT<Scalar, DIM, DIM>& HVectorialPart()	 @return The homogeneous matrix
	 @brief Get the homogeneous vectorial part of the transformation, i.e. the rotation matrix
,
 "output":#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T>
bool IsEqual(const T& result, const T& expected)
{
	return result == expected;
}
bool IsEqual(const double& result, const double& expected)
{
	return std::fabs(result - expected) <= 1e-6;
}
template<typename T, int DIM>
bool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)
{
	for (int i = 0; i < DIM; i++)
	{
		if (!IsEqual(result[i], expected[i]))
		{
			return false;
		}
	}
	return true;
}
template<typename T, int ROW, int COL>
bool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)
{
	for (int i = 0; i < ROW; i++)
	{
		for (int j = 0; j < COL; j++)
		{
			if (!IsEqual(result(i, j), expected(i, j)))
			{
				return false;
			}
		}
	}
	return true;
}
template<typename T, int DIM>
bool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)
{
	return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());
}
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());
	}
	else if constexpr (DIM == 2)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());
	}
	else if constexpr (DIM == 3)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());
	}
	else
	{
		return false;
	}
}
template<typename T, int DIM>
bool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)
{
	return IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());
}
#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T>
bool IsEqual(const T& result, const T& expected)
{
	return result == expected;
}
bool IsEqual(const double& result, const double& expected)
{
	return std::fabs(result - expected) <= 1e-6;
}
template<typename T, int DIM>
bool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)
{
	for (int i = 0; i < DIM; i++)
	{
		if (!IsEqual(result[i], expected[i]))
		{
			return false;
		}
	}
	return true;
}
template<typename T, int ROW, int COL>
bool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)
{
	for (int i = 0; i < ROW; i++)
	{
		for (int j = 0; j < COL; j++)
		{
			if (!IsEqual(result(i, j), expected(i, j)))
			{
				return false;
			}
		}
	}
	return true;
}
template<typename T, int DIM>
bool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)
{
	return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());
}
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());
	}
	else if constexpr (DIM == 2)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());
	}
	else if constexpr (DIM == 3)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());
	}
	else
	{
		return false;
	}
}
template<typename T, int DIM>
bool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)
{
	return IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());
;
	SECTION("default constructor 3D") {
		TransformationT<double, 3> tr;
		MatrixT<double, 3, 3> mat;
		mat.SetIdentity();
		CoordT<double, 3> c;
		double scale = 1.0;
		CHECK(IsEqual(tr.ScaleFactor(), scale));
		CHECK(IsEqual(tr.Type(), TransformationType::Identity));
		CHECK(IsEqual(tr.HVectorialPart(), mat));
		CHECK(IsEqual(tr.TranslationPart(), c));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":TransformationT& Invert()	 @return The reference to self
	 @brief Invert the transformation
,
 "output":#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T>
bool IsEqual(const T& result, const T& expected)
{
	return result == expected;
}
bool IsEqual(const double& result, const double& expected)
{
	return std::fabs(result - expected) <= 1e-6;
}
template<typename T, int DIM>
bool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)
{
	for (int i = 0; i < DIM; i++)
	{
		if (!IsEqual(result[i], expected[i]))
		{
			return false;
		}
	}
	return true;
}
template<typename T, int ROW, int COL>
bool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)
{
	for (int i = 0; i < ROW; i++)
	{
		for (int j = 0; j < COL; j++)
		{
			if (!IsEqual(result(i, j), expected(i, j)))
			{
				return false;
			}
		}
	}
	return true;
}
template<typename T, int DIM>
bool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)
{
	return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());
}
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());
	}
	else if constexpr (DIM == 2)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());
	}
	else if constexpr (DIM == 3)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());
	}
	else
	{
		return false;
	}
}
template<typename T, int DIM>
bool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)
{
	return IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());
}
#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T>
bool IsEqual(const T& result, const T& expected)
{
	return result == expected;
}
bool IsEqual(const double& result, const double& expected)
{
	return std::fabs(result - expected) <= 1e-6;
}
template<typename T, int DIM>
bool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)
{
	for (int i = 0; i < DIM; i++)
	{
		if (!IsEqual(result[i], expected[i]))
		{
			return false;
		}
	}
	return true;
}
template<typename T, int ROW, int COL>
bool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)
{
	for (int i = 0; i < ROW; i++)
	{
		for (int j = 0; j < COL; j++)
		{
			if (!IsEqual(result(i, j), expected(i, j)))
			{
				return false;
			}
		}
	}
	return true;
}
template<typename T, int DIM>
bool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)
{
	return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());
}
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());
	}
	else if constexpr (DIM == 2)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());
	}
	else if constexpr (DIM == 3)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());
	}
	else
	{
		return false;
	}
}
template<typename T, int DIM>
bool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)
{
	return IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());
;
	SECTION("Invert") {
		TransformationT<double, 3> tr;
		tr.SetRotation(Axis3(Point3(1.0, 2.0, 3.0), Direction3(1.0, 1.0, 1.0)), M_PI_2);
		tr.Invert();
		TransformationT<double, 3> tr2;
		tr2.SetRotation(Axis3(Point3(1.0, 2.0, 3.0), Direction3(1.0, 1.0, 1.0)), -M_PI_2);
		CHECK(IsEqual(tr, tr2));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar> TransformationT& LeftMultiply(const TransformationT<OtherScalar, DIM>& other),
 "output":#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T>
bool IsEqual(const T& result, const T& expected)
{
	return result == expected;
}
bool IsEqual(const double& result, const double& expected)
{
	return std::fabs(result - expected) <= 1e-6;
}
template<typename T, int DIM>
bool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)
{
	for (int i = 0; i < DIM; i++)
	{
		if (!IsEqual(result[i], expected[i]))
		{
			return false;
		}
	}
	return true;
}
template<typename T, int ROW, int COL>
bool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)
{
	for (int i = 0; i < ROW; i++)
	{
		for (int j = 0; j < COL; j++)
		{
			if (!IsEqual(result(i, j), expected(i, j)))
			{
				return false;
			}
		}
	}
	return true;
}
template<typename T, int DIM>
bool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)
{
	return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());
}
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());
	}
	else if constexpr (DIM == 2)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());
	}
	else if constexpr (DIM == 3)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());
	}
	else
	{
		return false;
	}
}
template<typename T, int DIM>
bool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)
{
	return IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());
}
#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T>
bool IsEqual(const T& result, const T& expected)
{
	return result == expected;
}
bool IsEqual(const double& result, const double& expected)
{
	return std::fabs(result - expected) <= 1e-6;
}
template<typename T, int DIM>
bool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)
{
	for (int i = 0; i < DIM; i++)
	{
		if (!IsEqual(result[i], expected[i]))
		{
			return false;
		}
	}
	return true;
}
template<typename T, int ROW, int COL>
bool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)
{
	for (int i = 0; i < ROW; i++)
	{
		for (int j = 0; j < COL; j++)
		{
			if (!IsEqual(result(i, j), expected(i, j)))
			{
				return false;
			}
		}
	}
	return true;
}
template<typename T, int DIM>
bool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)
{
	return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());
}
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());
	}
	else if constexpr (DIM == 2)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());
	}
	else if constexpr (DIM == 3)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());
	}
	else
	{
		return false;
	}
}
template<typename T, int DIM>
bool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)
{
	return IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());
;
	SECTION("LeftMultiply") {
		TransformationT<double, 3> tr;
		tr.SetRotation(Axis3(Point3(1.0, 2.0, 3.0), Direction3(1.0, 1.0, 1.0)), M_PI_2);
		TransformationT<double, 3> tr2;
		tr2.SetRotation(Axis3(Point3(2.0, 3.0, 4.0), Direction3(1.0, 1.0, 2.0)), M_PI_2);
		CHECK(IsEqual(tr * tr2, tr2.LeftMultiplied(tr)));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar> [[nodiscard]] TransformationT LeftMultiplied(const TransformationT<OtherScalar, DIM>& other),
 "output":#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T>
bool IsEqual(const T& result, const T& expected)
{
	return result == expected;
}
bool IsEqual(const double& result, const double& expected)
{
	return std::fabs(result - expected) <= 1e-6;
}
template<typename T, int DIM>
bool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)
{
	for (int i = 0; i < DIM; i++)
	{
		if (!IsEqual(result[i], expected[i]))
		{
			return false;
		}
	}
	return true;
}
template<typename T, int ROW, int COL>
bool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)
{
	for (int i = 0; i < ROW; i++)
	{
		for (int j = 0; j < COL; j++)
		{
			if (!IsEqual(result(i, j), expected(i, j)))
			{
				return false;
			}
		}
	}
	return true;
}
template<typename T, int DIM>
bool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)
{
	return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());
}
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());
	}
	else if constexpr (DIM == 2)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());
	}
	else if constexpr (DIM == 3)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());
	}
	else
	{
		return false;
	}
}
template<typename T, int DIM>
bool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)
{
	return IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());
}
#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T>
bool IsEqual(const T& result, const T& expected)
{
	return result == expected;
}
bool IsEqual(const double& result, const double& expected)
{
	return std::fabs(result - expected) <= 1e-6;
}
template<typename T, int DIM>
bool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)
{
	for (int i = 0; i < DIM; i++)
	{
		if (!IsEqual(result[i], expected[i]))
		{
			return false;
		}
	}
	return true;
}
template<typename T, int ROW, int COL>
bool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)
{
	for (int i = 0; i < ROW; i++)
	{
		for (int j = 0; j < COL; j++)
		{
			if (!IsEqual(result(i, j), expected(i, j)))
			{
				return false;
			}
		}
	}
	return true;
}
template<typename T, int DIM>
bool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)
{
	return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());
}
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());
	}
	else if constexpr (DIM == 2)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());
	}
	else if constexpr (DIM == 3)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());
	}
	else
	{
		return false;
	}
}
template<typename T, int DIM>
bool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)
{
	return IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());
;
	SECTION("LeftMultiply") {
		TransformationT<double, 3> tr;
		tr.SetRotation(Axis3(Point3(1.0, 2.0, 3.0), Direction3(1.0, 1.0, 1.0)), M_PI_2);
		TransformationT<double, 3> tr2;
		tr2.SetRotation(Axis3(Point3(2.0, 3.0, 4.0), Direction3(1.0, 1.0, 2.0)), M_PI_2);
		CHECK(IsEqual(tr * tr2, tr2.LeftMultiplied(tr)));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":TransformationT& Power(int power)	 @return The reference to self
	 @param power The exponential
	 @brief Power of transformation
,
 "output":#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T>
bool IsEqual(const T& result, const T& expected)
{
	return result == expected;
}
bool IsEqual(const double& result, const double& expected)
{
	return std::fabs(result - expected) <= 1e-6;
}
template<typename T, int DIM>
bool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)
{
	for (int i = 0; i < DIM; i++)
	{
		if (!IsEqual(result[i], expected[i]))
		{
			return false;
		}
	}
	return true;
}
template<typename T, int ROW, int COL>
bool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)
{
	for (int i = 0; i < ROW; i++)
	{
		for (int j = 0; j < COL; j++)
		{
			if (!IsEqual(result(i, j), expected(i, j)))
			{
				return false;
			}
		}
	}
	return true;
}
template<typename T, int DIM>
bool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)
{
	return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());
}
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());
	}
	else if constexpr (DIM == 2)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());
	}
	else if constexpr (DIM == 3)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());
	}
	else
	{
		return false;
	}
}
template<typename T, int DIM>
bool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)
{
	return IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());
}
#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T>
bool IsEqual(const T& result, const T& expected)
{
	return result == expected;
}
bool IsEqual(const double& result, const double& expected)
{
	return std::fabs(result - expected) <= 1e-6;
}
template<typename T, int DIM>
bool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)
{
	for (int i = 0; i < DIM; i++)
	{
		if (!IsEqual(result[i], expected[i]))
		{
			return false;
		}
	}
	return true;
}
template<typename T, int ROW, int COL>
bool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)
{
	for (int i = 0; i < ROW; i++)
	{
		for (int j = 0; j < COL; j++)
		{
			if (!IsEqual(result(i, j), expected(i, j)))
			{
				return false;
			}
		}
	}
	return true;
}
template<typename T, int DIM>
bool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)
{
	return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());
}
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());
	}
	else if constexpr (DIM == 2)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());
	}
	else if constexpr (DIM == 3)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());
	}
	else
	{
		return false;
	}
}
template<typename T, int DIM>
bool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)
{
	return IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());
;
	SECTION("Power") {
		TransformationT<double, 3> tr;
		tr.SetRotation(Axis3(Point3(1.0, 2.0, 3.0), Direction3(1.0, 1.0, 1.0)), M_PI_2);
		TransformationT<double, 3> tr2;
		tr2.SetRotation(Axis3(Point3(1.0, 2.0, 3.0), Direction3(1.0, 1.0, 1.0)), M_PI);
		CHECK(IsEqual(tr.Powered(2), tr2));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] TransformationT Powered(int power)	 @return The power of transformation
	 @param power The exponential
	 @brief Get the power of transformation
,
 "output":#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T>
bool IsEqual(const T& result, const T& expected)
{
	return result == expected;
}
bool IsEqual(const double& result, const double& expected)
{
	return std::fabs(result - expected) <= 1e-6;
}
template<typename T, int DIM>
bool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)
{
	for (int i = 0; i < DIM; i++)
	{
		if (!IsEqual(result[i], expected[i]))
		{
			return false;
		}
	}
	return true;
}
template<typename T, int ROW, int COL>
bool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)
{
	for (int i = 0; i < ROW; i++)
	{
		for (int j = 0; j < COL; j++)
		{
			if (!IsEqual(result(i, j), expected(i, j)))
			{
				return false;
			}
		}
	}
	return true;
}
template<typename T, int DIM>
bool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)
{
	return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());
}
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());
	}
	else if constexpr (DIM == 2)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());
	}
	else if constexpr (DIM == 3)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());
	}
	else
	{
		return false;
	}
}
template<typename T, int DIM>
bool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)
{
	return IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());
}
#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T>
bool IsEqual(const T& result, const T& expected)
{
	return result == expected;
}
bool IsEqual(const double& result, const double& expected)
{
	return std::fabs(result - expected) <= 1e-6;
}
template<typename T, int DIM>
bool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)
{
	for (int i = 0; i < DIM; i++)
	{
		if (!IsEqual(result[i], expected[i]))
		{
			return false;
		}
	}
	return true;
}
template<typename T, int ROW, int COL>
bool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)
{
	for (int i = 0; i < ROW; i++)
	{
		for (int j = 0; j < COL; j++)
		{
			if (!IsEqual(result(i, j), expected(i, j)))
			{
				return false;
			}
		}
	}
	return true;
}
template<typename T, int DIM>
bool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)
{
	return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());
}
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());
	}
	else if constexpr (DIM == 2)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());
	}
	else if constexpr (DIM == 3)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());
	}
	else
	{
		return false;
	}
}
template<typename T, int DIM>
bool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)
{
	return IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());
;
	SECTION("Power") {
		TransformationT<double, 3> tr;
		tr.SetRotation(Axis3(Point3(1.0, 2.0, 3.0), Direction3(1.0, 1.0, 1.0)), M_PI_2);
		TransformationT<double, 3> tr2;
		tr2.SetRotation(Axis3(Point3(1.0, 2.0, 3.0), Direction3(1.0, 1.0, 1.0)), M_PI);
		CHECK(IsEqual(tr.Powered(2), tr2));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar> void Transform(CoordT<OtherScalar, DIM>& coord),
 "output":#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T>
bool IsEqual(const T& result, const T& expected)
{
	return result == expected;
}
bool IsEqual(const double& result, const double& expected)
{
	return std::fabs(result - expected) <= 1e-6;
}
template<typename T, int DIM>
bool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)
{
	for (int i = 0; i < DIM; i++)
	{
		if (!IsEqual(result[i], expected[i]))
		{
			return false;
		}
	}
	return true;
}
template<typename T, int ROW, int COL>
bool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)
{
	for (int i = 0; i < ROW; i++)
	{
		for (int j = 0; j < COL; j++)
		{
			if (!IsEqual(result(i, j), expected(i, j)))
			{
				return false;
			}
		}
	}
	return true;
}
template<typename T, int DIM>
bool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)
{
	return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());
}
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());
	}
	else if constexpr (DIM == 2)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());
	}
	else if constexpr (DIM == 3)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());
	}
	else
	{
		return false;
	}
}
template<typename T, int DIM>
bool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)
{
	return IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());
}
#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T>
bool IsEqual(const T& result, const T& expected)
{
	return result == expected;
}
bool IsEqual(const double& result, const double& expected)
{
	return std::fabs(result - expected) <= 1e-6;
}
template<typename T, int DIM>
bool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)
{
	for (int i = 0; i < DIM; i++)
	{
		if (!IsEqual(result[i], expected[i]))
		{
			return false;
		}
	}
	return true;
}
template<typename T, int ROW, int COL>
bool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)
{
	for (int i = 0; i < ROW; i++)
	{
		for (int j = 0; j < COL; j++)
		{
			if (!IsEqual(result(i, j), expected(i, j)))
			{
				return false;
			}
		}
	}
	return true;
}
template<typename T, int DIM>
bool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)
{
	return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());
}
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());
	}
	else if constexpr (DIM == 2)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());
	}
	else if constexpr (DIM == 3)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());
	}
	else
	{
		return false;
	}
}
template<typename T, int DIM>
bool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)
{
	return IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());
;
	SECTION("SetMirror point 3D") {
		TransformationT<double, 3> tr;
		PointT<double, 3> p(1.0, 2.0, 3.0);
		tr.SetMirror(p);
		CoordT<double, 3> p2(0.0, 1.0, 2.0);
		tr.Transform(p2);
		CoordT<double, 3> p3(2.0, 3.0, 4.0);
		CHECK(IsEqual(p2, p3));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar, typename OtherScalar2> [[nodiscard]] bool IsEqual(const PointT<OtherScalar, DIM>& other, const OtherScalar2& tol),
 "output":#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <iostream>
#define tol 0.001
using namespace AMCAX;
using namespace std;
#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <iostream>
#define tol 0.001
using namespace AMCAX;
using namespace std;
;
	SECTION("Mirror(point) 2D") {
        PointT<double, 2> p1(1.0, 2.0);
        PointT<double, 2> p2(2.0, 4.0);
        PointT<double, 2> p3(3.0, 6.0);
        CHECK(p1.Mirrored(p2).IsEqual(p3, tol));
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar> PointT& Mirror(const PointT<OtherScalar, DIM>& p),
 "output":#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <iostream>
#define tol 0.001
using namespace AMCAX;
using namespace std;
#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <iostream>
#define tol 0.001
using namespace AMCAX;
using namespace std;
;
	SECTION("Mirror(axis) 2D") {
        PointT<double, 2> p1(1.0, 2.0);
        PointT<double, 2> p2(2.0, 3.0);
        DirectionT<double, 2> d(7.0, 3.0);
        AxisT<double, 2> a(p2, d);
        PointT<double, 2> p3(17.0 / 29.0, 86.0 / 29.0);
        CHECK(p1.Mirrored(a).IsEqual(p3, tol));
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar> PointT& Mirror(const AxisT<OtherScalar, DIM>& axis),
 "output":#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <iostream>
#define tol 0.001
using namespace AMCAX;
using namespace std;
#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <iostream>
#define tol 0.001
using namespace AMCAX;
using namespace std;
;
	SECTION("Mirror(axis) 2D") {
        PointT<double, 2> p1(1.0, 2.0);
        PointT<double, 2> p2(2.0, 3.0);
        DirectionT<double, 2> d(7.0, 3.0);
        AxisT<double, 2> a(p2, d);
        PointT<double, 2> p3(17.0 / 29.0, 86.0 / 29.0);
        CHECK(p1.Mirrored(a).IsEqual(p3, tol));
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar> [[nodiscard]] PointT Mirrored(const AxisT<OtherScalar, DIM>& axis),
 "output":#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <iostream>
#define tol 0.001
using namespace AMCAX;
using namespace std;
#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <iostream>
#define tol 0.001
using namespace AMCAX;
using namespace std;
;
	SECTION("Mirror(point) 2D") {
        PointT<double, 2> p1(1.0, 2.0);
        PointT<double, 2> p2(2.0, 4.0);
        PointT<double, 2> p3(3.0, 6.0);
        CHECK(p1.Mirrored(p2).IsEqual(p3, tol));
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":explicit PointT(const CoordType& v)	 @param v The coordinate
	 @brief Construct from a coordinate
,
 "output":#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.1
using namespace AMCAX;
using namespace std;
#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.1
using namespace AMCAX;
using namespace std;
;
	SECTION("Constructor","[2]") {
        Coord3 v(1.0, 2.0, 3.0);
        Point3 result(v);
        Point3 expected(1.0, 2.0, 3.0);
        CHECK(result.IsEqual(expected, tol));
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":void SetCoord(const CoordType& v)	 @param v The coordinate
	 @brief Set the coordinate of point
,
 "output":#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.1
using namespace AMCAX;
using namespace std;
#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.1
using namespace AMCAX;
using namespace std;
;
	SECTION("SetCoord(x, y, z)") {
        Point3 result;
        result.SetCoord(1.0, 2.0, 3.0);
        Point3 expected(1.0, 2.0, 3.0);
        CHECK(result.IsEqual(expected, tol));
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar, typename OtherScalar2> [[nodiscard]] bool IsEqual(const PointT<OtherScalar, DIM>& other, const OtherScalar2& tol),
 "output":#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.1
using namespace AMCAX;
using namespace std;
#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.1
using namespace AMCAX;
using namespace std;
;
	SECTION("Default constructor","[1]") {
        Point3  p1;
        Point3  p2(0.0, 0.0, 0.0);
        CHECK(p1.IsEqual(p2, tol));
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar> [[nodiscard]] auto Distance(const PointT<OtherScalar, DIM>& other),
 "output":#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.1
using namespace AMCAX;
using namespace std;
#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.1
using namespace AMCAX;
using namespace std;
;
	SECTION("Distance") {
        PointT<double, 3> p1(1.0, 2.0, 3.0);
        PointT<double, 3> p2(1.4, 2.5, 3.6);
        CHECK(p1.Distance(p2) == sqrt(0.77));
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar> [[nodiscard]] auto SquaredDistance(const PointT<OtherScalar, DIM>& other),
 "output":#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.1
using namespace AMCAX;
using namespace std;
#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.1
using namespace AMCAX;
using namespace std;
;
	SECTION("SquaredDistance") {
        PointT<double, 3> p1(1.0, 2.0, 3.0);
        PointT<double, 3> p2(1.1, 2.2, 3.3);
        CHECK(p1.SquaredDistance(p2) == Approx(0.14));
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar> PointT& Mirror(const PointT<OtherScalar, DIM>& p),
 "output":#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.1
using namespace AMCAX;
using namespace std;
#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.1
using namespace AMCAX;
using namespace std;
;
	SECTION("Mirror(axis) 3D") {
        PointT<double, 3> p1(1.0, 2.0, 3.0);
        PointT<double, 3> p2(2.0, 3.0, 4.0);
        DirectionT<double, 3> d(7.0, 3.0, 2.0);
        AxisT<double, 3> a(p2, d);
        PointT<double, 3> p3(9.0 / 31.0, 88.0 / 31.0, 131.0 / 31.0);
        CHECK(p1.Mirrored(a).IsEqual(p3, tol));
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar> PointT& Mirror(const AxisT<OtherScalar, DIM>& axis),
 "output":#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.1
using namespace AMCAX;
using namespace std;
#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.1
using namespace AMCAX;
using namespace std;
;
	SECTION("Mirror(axis) 3D") {
        PointT<double, 3> p1(1.0, 2.0, 3.0);
        PointT<double, 3> p2(2.0, 3.0, 4.0);
        DirectionT<double, 3> d(7.0, 3.0, 2.0);
        AxisT<double, 3> a(p2, d);
        PointT<double, 3> p3(9.0 / 31.0, 88.0 / 31.0, 131.0 / 31.0);
        CHECK(p1.Mirrored(a).IsEqual(p3, tol));
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar, int DIM2 = DIM, std::enable_if_t<DIM2 == 3, int> = 0> PointT& Mirror(const FrameT<OtherScalar, DIM>& frame),
 "output":#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.1
using namespace AMCAX;
using namespace std;
#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.1
using namespace AMCAX;
using namespace std;
;
	SECTION("Mirror(frame) 3D") {
        PointT<double, 3> p1(1.0, 2.0, 3.0);
        PointT<double, 3> p2(2.0, 3.0, 4.0);
        DirectionT<double, 3> d(7.0, 3.0, 2.0);
        FrameT<double, 3> f(p2, d);
        PointT<double, 3> p3(115.0 / 31.0, 98.0 / 31.0, 117.0 / 31.0);
        CHECK(p1.Mirrored(f).IsEqual(p3, tol));
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar> [[nodiscard]] PointT Mirrored(const PointT<OtherScalar, DIM>& p),
 "output":#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.1
using namespace AMCAX;
using namespace std;
#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.1
using namespace AMCAX;
using namespace std;
;
	SECTION("Mirror(point) 3D") {
        PointT<double, 3> p1(1.0, 2.0, 3.0);
        PointT<double, 3> p2(2.0, 4.0, 5.0);
        PointT<double, 3> p3(3.0, 6.0, 7.0);
        CHECK(p1.Mirrored(p2).IsEqual(p3, tol));
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar> [[nodiscard]] PointT Mirrored(const AxisT<OtherScalar, DIM>& axis),
 "output":#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.1
using namespace AMCAX;
using namespace std;
#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.1
using namespace AMCAX;
using namespace std;
;
	SECTION("Mirror(point) 3D") {
        PointT<double, 3> p1(1.0, 2.0, 3.0);
        PointT<double, 3> p2(2.0, 4.0, 5.0);
        PointT<double, 3> p3(3.0, 6.0, 7.0);
        CHECK(p1.Mirrored(p2).IsEqual(p3, tol));
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar, int DIM2 = DIM, std::enable_if_t<DIM2 == 3, int> = 0> [[nodiscard]] PointT Mirrored(const FrameT<OtherScalar, DIM>& frame),
 "output":#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.1
using namespace AMCAX;
using namespace std;
#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.1
using namespace AMCAX;
using namespace std;
;
	SECTION("Mirror(point) 3D") {
        PointT<double, 3> p1(1.0, 2.0, 3.0);
        PointT<double, 3> p2(2.0, 4.0, 5.0);
        PointT<double, 3> p3(3.0, 6.0, 7.0);
        CHECK(p1.Mirrored(p2).IsEqual(p3, tol));
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar> PointT& Translate(const VectorT<OtherScalar, DIM>& vec),
 "output":#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.1
using namespace AMCAX;
using namespace std;
#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.1
using namespace AMCAX;
using namespace std;
;
	SECTION("Translate(vec)") {
        PointT<double, 3> p1(1.0, 2.0, 3.0);
        VectorT<double, 3> v1(2.0, 3.0, 4.0);
        PointT<double, 3> p2(3.0, 5.0, 7.0);
        CHECK(p1.Translated(v1).IsEqual(p2, tol));
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar, typename OtherScalar2> PointT& Translate(const PointT<OtherScalar, DIM>& p1, const PointT<OtherScalar2, DIM>& p2),
 "output":#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.1
using namespace AMCAX;
using namespace std;
#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.1
using namespace AMCAX;
using namespace std;
;
	SECTION("Translate(p1, p2)") {
        PointT<double, 3> p1(1.0, 2.0, 3.0);
        PointT<double, 3> p2(2.0, 3.0, 4.0);
        PointT<double, 3> p3(4.0, 2.0, 3.0);
        PointT<double, 3> p4(3.0, 1.0, 2.0);
        CHECK(p1.Translated(p2, p3).IsEqual(p4, tol));
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar> [[nodiscard]] PointT Translated(const VectorT<OtherScalar, DIM>& vec),
 "output":#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.1
using namespace AMCAX;
using namespace std;
#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.1
using namespace AMCAX;
using namespace std;
;
	SECTION("Translate(vec)") {
        PointT<double, 3> p1(1.0, 2.0, 3.0);
        VectorT<double, 3> v1(2.0, 3.0, 4.0);
        PointT<double, 3> p2(3.0, 5.0, 7.0);
        CHECK(p1.Translated(v1).IsEqual(p2, tol));
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API explicit MakeFace(const TopoWire& w, bool onlyPlane = false)	 @param onlyPlane If true, the surface will be a plane
	 @param w The wire
	 @brief Construct from a wire
,
 "output":#include <catch.hpp>
#include "testHelper.h"
#include<iostream>
#include <common/PointT.hpp>
#include <topology/TopoEdge.hpp>
#include <modeling/MakeWire.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <topology/TopoWire.hpp>
#include <topology/TopoShape.hpp>
#include <topology/TopoFace.hpp>
#include <modeling/MakeFace.hpp>
AMCAX::TopoFace crashbug1() {
    double h1 = 7., h2 = 3.;
    AMCAX::Point2 p1(0., h1 / 2.0), p2(30., h2 / 2.0), p3(30., -h2 / 2.0), p4(0., -h1 / 2.0);
    std::vector<AMCAX::Point2> v_p;
    v_p.push_back(p1);
    v_p.push_back(p2);
    v_p.push_back(p3);
    v_p.push_back(p4);
    AMCAX::TopoEdge e;
    std::list<AMCAX::TopoShape> edges_polygon;
    for (int i = 1; i < v_p.size(); i++) {
        e = AMCAX::MakeEdge2d(v_p[i - 1], v_p[i]);
        edges_polygon.push_back(e);
    }
    e = AMCAX::MakeEdge2d(v_p[3], v_p[0]);
    edges_polygon.push_back(e);
    AMCAX::MakeWire mkw;
    mkw.Add(edges_polygon);
    AMCAX::TopoWire w_poly = mkw;
    AMCAX::TopoFace f_poly = AMCAX::MakeFace(w_poly, true);
    return f_poly;
}
TEST_CASE("BUG1:Call MakeFace(const TopoWire& w, bool onlyPlane = false) crash ", "[modeling][MakeFace][fixbug][P1]") {
    AMCAX::TopoFace topoFace = crashbug1();
    CHECK(topoFace.IsNull() == false);
    CHECK(topoFace.Type() == AMCAX::ShapeType::Face);
    CHECK(topoFace.NChildren() == 1);
}
#include <catch.hpp>
#include "testHelper.h"
#include<iostream>
#include <common/PointT.hpp>
#include <topology/TopoEdge.hpp>
#include <modeling/MakeWire.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <topology/TopoWire.hpp>
#include <topology/TopoShape.hpp>
#include <topology/TopoFace.hpp>
#include <modeling/MakeFace.hpp>
AMCAX::TopoFace crashbug1() {
    double h1 = 7., h2 = 3.;
    AMCAX::Point2 p1(0., h1 / 2.0), p2(30., h2 / 2.0), p3(30., -h2 / 2.0), p4(0., -h1 / 2.0);
    std::vector<AMCAX::Point2> v_p;
    v_p.push_back(p1);
    v_p.push_back(p2);
    v_p.push_back(p3);
    v_p.push_back(p4);
    AMCAX::TopoEdge e;
    std::list<AMCAX::TopoShape> edges_polygon;
    for (int i = 1; i < v_p.size(); i++) {
        e = AMCAX::MakeEdge2d(v_p[i - 1], v_p[i]);
        edges_polygon.push_back(e);
    }
    e = AMCAX::MakeEdge2d(v_p[3], v_p[0]);
    edges_polygon.push_back(e);
    AMCAX::MakeWire mkw;
    mkw.Add(edges_polygon);
    AMCAX::TopoWire w_poly = mkw;
    AMCAX::TopoFace f_poly = AMCAX::MakeFace(w_poly, true);
    return f_poly;
}
TEST_CASE("BUG1:Call MakeFace(const TopoWire& w, bool onlyPlane = false) crash ", "[modeling][MakeFace][fixbug][P1]") {
    AMCAX::TopoFace topoFace = crashbug1();
    CHECK(topoFace.IsNull() == false);
    CHECK(topoFace.Type() == AMCAX::ShapeType::Face);
    CHECK(topoFace.NChildren() == 1);
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API MakeFace(const Plane& p, const TopoWire& w, bool inside = true)	 @param inside Whether the face is inside the wire
	 @param w The wire
	 @param p The plane
	 @brief Construct from a plane and a wire
,
 "output":#include <catch.hpp>
#include "testHelper.h"
#include<iostream>
#include <common/PointT.hpp>
#include <topology/TopoEdge.hpp>
#include <modeling/MakeWire.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <topology/TopoWire.hpp>
#include <topology/TopoShape.hpp>
#include <topology/TopoFace.hpp>
#include <modeling/MakeFace.hpp>
AMCAX::TopoFace crashbug1() {
    double h1 = 7., h2 = 3.;
    AMCAX::Point2 p1(0., h1 / 2.0), p2(30., h2 / 2.0), p3(30., -h2 / 2.0), p4(0., -h1 / 2.0);
    std::vector<AMCAX::Point2> v_p;
    v_p.push_back(p1);
    v_p.push_back(p2);
    v_p.push_back(p3);
    v_p.push_back(p4);
    AMCAX::TopoEdge e;
    std::list<AMCAX::TopoShape> edges_polygon;
    for (int i = 1; i < v_p.size(); i++) {
        e = AMCAX::MakeEdge2d(v_p[i - 1], v_p[i]);
        edges_polygon.push_back(e);
    }
    e = AMCAX::MakeEdge2d(v_p[3], v_p[0]);
    edges_polygon.push_back(e);
    AMCAX::MakeWire mkw;
    mkw.Add(edges_polygon);
    AMCAX::TopoWire w_poly = mkw;
    AMCAX::TopoFace f_poly = AMCAX::MakeFace(w_poly, true);
    return f_poly;
}
TEST_CASE("BUG1:Call MakeFace(const TopoWire& w, bool onlyPlane = false) crash ", "[modeling][MakeFace][fixbug][P1]") {
    AMCAX::TopoFace topoFace = crashbug1();
    CHECK(topoFace.IsNull() == false);
    CHECK(topoFace.Type() == AMCAX::ShapeType::Face);
    CHECK(topoFace.NChildren() == 1);
}
#include <catch.hpp>
#include "testHelper.h"
#include<iostream>
#include <common/PointT.hpp>
#include <topology/TopoEdge.hpp>
#include <modeling/MakeWire.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <topology/TopoWire.hpp>
#include <topology/TopoShape.hpp>
#include <topology/TopoFace.hpp>
#include <modeling/MakeFace.hpp>
AMCAX::TopoFace crashbug1() {
    double h1 = 7., h2 = 3.;
    AMCAX::Point2 p1(0., h1 / 2.0), p2(30., h2 / 2.0), p3(30., -h2 / 2.0), p4(0., -h1 / 2.0);
    std::vector<AMCAX::Point2> v_p;
    v_p.push_back(p1);
    v_p.push_back(p2);
    v_p.push_back(p3);
    v_p.push_back(p4);
    AMCAX::TopoEdge e;
    std::list<AMCAX::TopoShape> edges_polygon;
    for (int i = 1; i < v_p.size(); i++) {
        e = AMCAX::MakeEdge2d(v_p[i - 1], v_p[i]);
        edges_polygon.push_back(e);
    }
    e = AMCAX::MakeEdge2d(v_p[3], v_p[0]);
    edges_polygon.push_back(e);
    AMCAX::MakeWire mkw;
    mkw.Add(edges_polygon);
    AMCAX::TopoWire w_poly = mkw;
    AMCAX::TopoFace f_poly = AMCAX::MakeFace(w_poly, true);
    return f_poly;
}
TEST_CASE("BUG1:Call MakeFace(const TopoWire& w, bool onlyPlane = false) crash ", "[modeling][MakeFace][fixbug][P1]") {
    AMCAX::TopoFace topoFace = crashbug1();
    CHECK(topoFace.IsNull() == false);
    CHECK(topoFace.Type() == AMCAX::ShapeType::Face);
    CHECK(topoFace.NChildren() == 1);
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API MakeFace(const Cone& c, const TopoWire& w, bool inside = true)	 @param inside Whether the face is inside the wire
	 @param w The wire
	 @param c The cone
	 @brief Construct from a cone and a wire
,
 "output":#include <catch.hpp>
#include "testHelper.h"
#include<iostream>
#include <common/PointT.hpp>
#include <topology/TopoEdge.hpp>
#include <modeling/MakeWire.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <topology/TopoWire.hpp>
#include <topology/TopoShape.hpp>
#include <topology/TopoFace.hpp>
#include <modeling/MakeFace.hpp>
AMCAX::TopoFace crashbug1() {
    double h1 = 7., h2 = 3.;
    AMCAX::Point2 p1(0., h1 / 2.0), p2(30., h2 / 2.0), p3(30., -h2 / 2.0), p4(0., -h1 / 2.0);
    std::vector<AMCAX::Point2> v_p;
    v_p.push_back(p1);
    v_p.push_back(p2);
    v_p.push_back(p3);
    v_p.push_back(p4);
    AMCAX::TopoEdge e;
    std::list<AMCAX::TopoShape> edges_polygon;
    for (int i = 1; i < v_p.size(); i++) {
        e = AMCAX::MakeEdge2d(v_p[i - 1], v_p[i]);
        edges_polygon.push_back(e);
    }
    e = AMCAX::MakeEdge2d(v_p[3], v_p[0]);
    edges_polygon.push_back(e);
    AMCAX::MakeWire mkw;
    mkw.Add(edges_polygon);
    AMCAX::TopoWire w_poly = mkw;
    AMCAX::TopoFace f_poly = AMCAX::MakeFace(w_poly, true);
    return f_poly;
}
TEST_CASE("BUG1:Call MakeFace(const TopoWire& w, bool onlyPlane = false) crash ", "[modeling][MakeFace][fixbug][P1]") {
    AMCAX::TopoFace topoFace = crashbug1();
    CHECK(topoFace.IsNull() == false);
    CHECK(topoFace.Type() == AMCAX::ShapeType::Face);
    CHECK(topoFace.NChildren() == 1);
}
#include <catch.hpp>
#include "testHelper.h"
#include<iostream>
#include <common/PointT.hpp>
#include <topology/TopoEdge.hpp>
#include <modeling/MakeWire.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <topology/TopoWire.hpp>
#include <topology/TopoShape.hpp>
#include <topology/TopoFace.hpp>
#include <modeling/MakeFace.hpp>
AMCAX::TopoFace crashbug1() {
    double h1 = 7., h2 = 3.;
    AMCAX::Point2 p1(0., h1 / 2.0), p2(30., h2 / 2.0), p3(30., -h2 / 2.0), p4(0., -h1 / 2.0);
    std::vector<AMCAX::Point2> v_p;
    v_p.push_back(p1);
    v_p.push_back(p2);
    v_p.push_back(p3);
    v_p.push_back(p4);
    AMCAX::TopoEdge e;
    std::list<AMCAX::TopoShape> edges_polygon;
    for (int i = 1; i < v_p.size(); i++) {
        e = AMCAX::MakeEdge2d(v_p[i - 1], v_p[i]);
        edges_polygon.push_back(e);
    }
    e = AMCAX::MakeEdge2d(v_p[3], v_p[0]);
    edges_polygon.push_back(e);
    AMCAX::MakeWire mkw;
    mkw.Add(edges_polygon);
    AMCAX::TopoWire w_poly = mkw;
    AMCAX::TopoFace f_poly = AMCAX::MakeFace(w_poly, true);
    return f_poly;
}
TEST_CASE("BUG1:Call MakeFace(const TopoWire& w, bool onlyPlane = false) crash ", "[modeling][MakeFace][fixbug][P1]") {
    AMCAX::TopoFace topoFace = crashbug1();
    CHECK(topoFace.IsNull() == false);
    CHECK(topoFace.Type() == AMCAX::ShapeType::Face);
    CHECK(topoFace.NChildren() == 1);
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API MakeFace(const Torus& t, const TopoWire& w, bool inside = true)	 @param inside Whether the face is inside the wire
	 @param w The wire
	 @param t The torus
	 @brief Construct from a torus and a wire
,
 "output":#include <catch.hpp>
#include "testHelper.h"
#include<iostream>
#include <common/PointT.hpp>
#include <topology/TopoEdge.hpp>
#include <modeling/MakeWire.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <topology/TopoWire.hpp>
#include <topology/TopoShape.hpp>
#include <topology/TopoFace.hpp>
#include <modeling/MakeFace.hpp>
AMCAX::TopoFace crashbug1() {
    double h1 = 7., h2 = 3.;
    AMCAX::Point2 p1(0., h1 / 2.0), p2(30., h2 / 2.0), p3(30., -h2 / 2.0), p4(0., -h1 / 2.0);
    std::vector<AMCAX::Point2> v_p;
    v_p.push_back(p1);
    v_p.push_back(p2);
    v_p.push_back(p3);
    v_p.push_back(p4);
    AMCAX::TopoEdge e;
    std::list<AMCAX::TopoShape> edges_polygon;
    for (int i = 1; i < v_p.size(); i++) {
        e = AMCAX::MakeEdge2d(v_p[i - 1], v_p[i]);
        edges_polygon.push_back(e);
    }
    e = AMCAX::MakeEdge2d(v_p[3], v_p[0]);
    edges_polygon.push_back(e);
    AMCAX::MakeWire mkw;
    mkw.Add(edges_polygon);
    AMCAX::TopoWire w_poly = mkw;
    AMCAX::TopoFace f_poly = AMCAX::MakeFace(w_poly, true);
    return f_poly;
}
TEST_CASE("BUG1:Call MakeFace(const TopoWire& w, bool onlyPlane = false) crash ", "[modeling][MakeFace][fixbug][P1]") {
    AMCAX::TopoFace topoFace = crashbug1();
    CHECK(topoFace.IsNull() == false);
    CHECK(topoFace.Type() == AMCAX::ShapeType::Face);
    CHECK(topoFace.NChildren() == 1);
}
#include <catch.hpp>
#include "testHelper.h"
#include<iostream>
#include <common/PointT.hpp>
#include <topology/TopoEdge.hpp>
#include <modeling/MakeWire.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <topology/TopoWire.hpp>
#include <topology/TopoShape.hpp>
#include <topology/TopoFace.hpp>
#include <modeling/MakeFace.hpp>
AMCAX::TopoFace crashbug1() {
    double h1 = 7., h2 = 3.;
    AMCAX::Point2 p1(0., h1 / 2.0), p2(30., h2 / 2.0), p3(30., -h2 / 2.0), p4(0., -h1 / 2.0);
    std::vector<AMCAX::Point2> v_p;
    v_p.push_back(p1);
    v_p.push_back(p2);
    v_p.push_back(p3);
    v_p.push_back(p4);
    AMCAX::TopoEdge e;
    std::list<AMCAX::TopoShape> edges_polygon;
    for (int i = 1; i < v_p.size(); i++) {
        e = AMCAX::MakeEdge2d(v_p[i - 1], v_p[i]);
        edges_polygon.push_back(e);
    }
    e = AMCAX::MakeEdge2d(v_p[3], v_p[0]);
    edges_polygon.push_back(e);
    AMCAX::MakeWire mkw;
    mkw.Add(edges_polygon);
    AMCAX::TopoWire w_poly = mkw;
    AMCAX::TopoFace f_poly = AMCAX::MakeFace(w_poly, true);
    return f_poly;
}
TEST_CASE("BUG1:Call MakeFace(const TopoWire& w, bool onlyPlane = false) crash ", "[modeling][MakeFace][fixbug][P1]") {
    AMCAX::TopoFace topoFace = crashbug1();
    CHECK(topoFace.IsNull() == false);
    CHECK(topoFace.Type() == AMCAX::ShapeType::Face);
    CHECK(topoFace.NChildren() == 1);
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API MakeFace(const std::shared_ptr<Geom3Surface>& s, const TopoWire& w, bool inside = true)	 @param inside Whether the face is inside the wire
	 @param w The wire
	 @param s The surface
	 @brief Construct from a surface and a wire
,
 "output":#include <catch.hpp>
#include "testHelper.h"
#include<iostream>
#include <common/PointT.hpp>
#include <topology/TopoEdge.hpp>
#include <modeling/MakeWire.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <topology/TopoWire.hpp>
#include <topology/TopoShape.hpp>
#include <topology/TopoFace.hpp>
#include <modeling/MakeFace.hpp>
AMCAX::TopoFace crashbug1() {
    double h1 = 7., h2 = 3.;
    AMCAX::Point2 p1(0., h1 / 2.0), p2(30., h2 / 2.0), p3(30., -h2 / 2.0), p4(0., -h1 / 2.0);
    std::vector<AMCAX::Point2> v_p;
    v_p.push_back(p1);
    v_p.push_back(p2);
    v_p.push_back(p3);
    v_p.push_back(p4);
    AMCAX::TopoEdge e;
    std::list<AMCAX::TopoShape> edges_polygon;
    for (int i = 1; i < v_p.size(); i++) {
        e = AMCAX::MakeEdge2d(v_p[i - 1], v_p[i]);
        edges_polygon.push_back(e);
    }
    e = AMCAX::MakeEdge2d(v_p[3], v_p[0]);
    edges_polygon.push_back(e);
    AMCAX::MakeWire mkw;
    mkw.Add(edges_polygon);
    AMCAX::TopoWire w_poly = mkw;
    AMCAX::TopoFace f_poly = AMCAX::MakeFace(w_poly, true);
    return f_poly;
}
TEST_CASE("BUG1:Call MakeFace(const TopoWire& w, bool onlyPlane = false) crash ", "[modeling][MakeFace][fixbug][P1]") {
    AMCAX::TopoFace topoFace = crashbug1();
    CHECK(topoFace.IsNull() == false);
    CHECK(topoFace.Type() == AMCAX::ShapeType::Face);
    CHECK(topoFace.NChildren() == 1);
}
#include <catch.hpp>
#include "testHelper.h"
#include<iostream>
#include <common/PointT.hpp>
#include <topology/TopoEdge.hpp>
#include <modeling/MakeWire.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <topology/TopoWire.hpp>
#include <topology/TopoShape.hpp>
#include <topology/TopoFace.hpp>
#include <modeling/MakeFace.hpp>
AMCAX::TopoFace crashbug1() {
    double h1 = 7., h2 = 3.;
    AMCAX::Point2 p1(0., h1 / 2.0), p2(30., h2 / 2.0), p3(30., -h2 / 2.0), p4(0., -h1 / 2.0);
    std::vector<AMCAX::Point2> v_p;
    v_p.push_back(p1);
    v_p.push_back(p2);
    v_p.push_back(p3);
    v_p.push_back(p4);
    AMCAX::TopoEdge e;
    std::list<AMCAX::TopoShape> edges_polygon;
    for (int i = 1; i < v_p.size(); i++) {
        e = AMCAX::MakeEdge2d(v_p[i - 1], v_p[i]);
        edges_polygon.push_back(e);
    }
    e = AMCAX::MakeEdge2d(v_p[3], v_p[0]);
    edges_polygon.push_back(e);
    AMCAX::MakeWire mkw;
    mkw.Add(edges_polygon);
    AMCAX::TopoWire w_poly = mkw;
    AMCAX::TopoFace f_poly = AMCAX::MakeFace(w_poly, true);
    return f_poly;
}
TEST_CASE("BUG1:Call MakeFace(const TopoWire& w, bool onlyPlane = false) crash ", "[modeling][MakeFace][fixbug][P1]") {
    AMCAX::TopoFace topoFace = crashbug1();
    CHECK(topoFace.IsNull() == false);
    CHECK(topoFace.Type() == AMCAX::ShapeType::Face);
    CHECK(topoFace.NChildren() == 1);
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API explicit MakeFace(const TopoFace& f)	 @param f The face
	 @brief construct from a face
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <topology/TopoExplorerTool.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeWire.hpp>
#include <modeling/MakeFace.hpp>
#include <offset/MakeFaceExtension.hpp>
#include <topomesh/BRepMeshIncrementalMesh.hpp>
#include <io/OBJTool.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <topology/TopoTool.hpp>
#include <topology/TopoVertex.hpp>
using namespace AMCAX;
#include<catch.hpp>
#include<testHelper.h>
#include <topology/TopoExplorerTool.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeWire.hpp>
#include <modeling/MakeFace.hpp>
#include <offset/MakeFaceExtension.hpp>
#include <topomesh/BRepMeshIncrementalMesh.hpp>
#include <io/OBJTool.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <topology/TopoTool.hpp>
#include <topology/TopoVertex.hpp>
using namespace AMCAX;
;
	SECTION("check length = 1") {
		for (size_t i = 0; i < fedge.size(); i++)
		{
			std::cout << "i = " << i << std::endl;
			TopoEdge edge = static_cast<const TopoEdge&>(fedge[i]);
			mkExt.PerformWithEdgeAndLength(edge, 1.0);
			CHECK(mkExt.IsDone() == true);
			TopoShape newshape = mkExt.Shape();
			TopoFace newface = TopoCast::Face(newshape);
			IndexSet<TopoShape> fedge2;
			TopoExplorerTool::MapShapes(newface, ShapeType::Edge, fedge2);
			Point3 p,p2,p3;
			double tol = 0.01;
			switch (i)
			{
			case 0: 
				p = Point3(10.0, -1.0, 1.0);
				p2 = Point3(10.3, -1.0, 1.0);
				p3 = Point3(-10.1, -0.3, 1.0);
				break;
			case 1:
				p = Point3(11.05, 0.0, 1.0);
				p2 = Point3(10.0, 3.15, 1.0);
				p3 = Point3(9.4, 5.0, 1.0);
				break;
			case 2:
				p = Point3(0.0, 7.0, 1.0);
				p2 = Point3(-7.5, 7.0, 1.0);
				p3 = Point3(7.4, 7.01, 1.0);
				break;
			case 3:
				p = Point3(-10.05, 3.0, 1.0);
				p2 = Point3(-11.0, 0.15, 1.0);
				p3 = Point3(9.8, 0.6, 1.0);
				break;
			case 4:
				p = Point3(0.0, 2.5, 1.0);
				p2 = Point3(-4.2, 2.5, 1.0);
				p3 = Point3(4.3, 2.55, 1.0);
				break;
			case 5:
				p = Point3(2.8, 3.0, 1.0);
				p2 = Point3(3.7, 1.65, 1.0);
				p3 = Point3(1.9, 4.35, 1.0);
				break;
			case 6:
				p = Point3(0.0, 3.5, 1.0);
				p2 = Point3(3.5, 3.5, 1.0);
				p3 = Point3(-3.61, 3.50, 1.0);
				break;
			case 7:
				p = Point3(-2.8, 3.0, 1.0);
				p2 = Point3(-9.98, 0.048, 1.0);
				p3 = Point3(-8.0, 5.97, 1.0);
				break;
			default:
				p = Point3(-999.0, -9999.0, -9999.0);
				break;
			}
			bool isOn = false;
			bool isOn2 = false;
			bool isOn3 = false;
			int matchNum = 0;
			for (int j = 0; j < fedge2.size(); ++j)
			{
				TopoEdge newEdge = static_cast<const TopoEdge&>(fedge2[j]);
				isOn = BRepClassificationTools::IsPointInOnEdge(newEdge, p, tol);
				isOn2 = BRepClassificationTools::IsPointInOnEdge(newEdge, p2, tol);
				isOn3 = BRepClassificationTools::IsPointInOnEdge(newEdge, p3, tol);
				if (isOn)
				{
					matchNum = matchNum + 1;
				}
				if (isOn2)
				{
					matchNum = matchNum + 1;
				}
				if (isOn3)
				{
					matchNum = matchNum + 1;
				}				
			}
			CHECK(matchNum == 3);
			}
		}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API MakeFace(const std::shared_ptr<Geom3Surface>& s, double tolDegen)	 @param tolDegen The tolerance
	 @param s The surface
	 @brief Construct from a surface with tolerance for degenerated edges
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <topology/TopoExplorerTool.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeWire.hpp>
#include <modeling/MakeFace.hpp>
#include <offset/MakeFaceExtension.hpp>
#include <topomesh/BRepMeshIncrementalMesh.hpp>
#include <io/OBJTool.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <topology/TopoTool.hpp>
#include <topology/TopoVertex.hpp>
using namespace AMCAX;
#include<catch.hpp>
#include<testHelper.h>
#include <topology/TopoExplorerTool.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeWire.hpp>
#include <modeling/MakeFace.hpp>
#include <offset/MakeFaceExtension.hpp>
#include <topomesh/BRepMeshIncrementalMesh.hpp>
#include <io/OBJTool.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <topology/TopoTool.hpp>
#include <topology/TopoVertex.hpp>
using namespace AMCAX;
;
	SECTION("check length = 1") {
		for (size_t i = 0; i < fedge.size(); i++)
		{
			std::cout << "i = " << i << std::endl;
			TopoEdge edge = static_cast<const TopoEdge&>(fedge[i]);
			mkExt.PerformWithEdgeAndLength(edge, 1.0);
			CHECK(mkExt.IsDone() == true);
			TopoShape newshape = mkExt.Shape();
			TopoFace newface = TopoCast::Face(newshape);
			IndexSet<TopoShape> fedge2;
			TopoExplorerTool::MapShapes(newface, ShapeType::Edge, fedge2);
			Point3 p,p2,p3;
			double tol = 0.01;
			switch (i)
			{
			case 0: 
				p = Point3(10.0, -1.0, 1.0);
				p2 = Point3(10.3, -1.0, 1.0);
				p3 = Point3(-10.1, -0.3, 1.0);
				break;
			case 1:
				p = Point3(11.05, 0.0, 1.0);
				p2 = Point3(10.0, 3.15, 1.0);
				p3 = Point3(9.4, 5.0, 1.0);
				break;
			case 2:
				p = Point3(0.0, 7.0, 1.0);
				p2 = Point3(-7.5, 7.0, 1.0);
				p3 = Point3(7.4, 7.01, 1.0);
				break;
			case 3:
				p = Point3(-10.05, 3.0, 1.0);
				p2 = Point3(-11.0, 0.15, 1.0);
				p3 = Point3(9.8, 0.6, 1.0);
				break;
			case 4:
				p = Point3(0.0, 2.5, 1.0);
				p2 = Point3(-4.2, 2.5, 1.0);
				p3 = Point3(4.3, 2.55, 1.0);
				break;
			case 5:
				p = Point3(2.8, 3.0, 1.0);
				p2 = Point3(3.7, 1.65, 1.0);
				p3 = Point3(1.9, 4.35, 1.0);
				break;
			case 6:
				p = Point3(0.0, 3.5, 1.0);
				p2 = Point3(3.5, 3.5, 1.0);
				p3 = Point3(-3.61, 3.50, 1.0);
				break;
			case 7:
				p = Point3(-2.8, 3.0, 1.0);
				p2 = Point3(-9.98, 0.048, 1.0);
				p3 = Point3(-8.0, 5.97, 1.0);
				break;
			default:
				p = Point3(-999.0, -9999.0, -9999.0);
				break;
			}
			bool isOn = false;
			bool isOn2 = false;
			bool isOn3 = false;
			int matchNum = 0;
			for (int j = 0; j < fedge2.size(); ++j)
			{
				TopoEdge newEdge = static_cast<const TopoEdge&>(fedge2[j]);
				isOn = BRepClassificationTools::IsPointInOnEdge(newEdge, p, tol);
				isOn2 = BRepClassificationTools::IsPointInOnEdge(newEdge, p2, tol);
				isOn3 = BRepClassificationTools::IsPointInOnEdge(newEdge, p3, tol);
				if (isOn)
				{
					matchNum = matchNum + 1;
				}
				if (isOn2)
				{
					matchNum = matchNum + 1;
				}
				if (isOn3)
				{
					matchNum = matchNum + 1;
				}				
			}
			CHECK(matchNum == 3);
			}
		}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API MakeFace(const Sphere& s, const TopoWire& w, bool inside = true)	 @param inside Whether the face is inside the wire
	 @param w The wire
	 @param s The sphere
	 @brief Construct from a sphere and a wire
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <topology/TopoExplorerTool.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeWire.hpp>
#include <modeling/MakeFace.hpp>
#include <offset/MakeFaceExtension.hpp>
#include <topomesh/BRepMeshIncrementalMesh.hpp>
#include <io/OBJTool.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <topology/TopoTool.hpp>
#include <topology/TopoVertex.hpp>
using namespace AMCAX;
#include<catch.hpp>
#include<testHelper.h>
#include <topology/TopoExplorerTool.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeWire.hpp>
#include <modeling/MakeFace.hpp>
#include <offset/MakeFaceExtension.hpp>
#include <topomesh/BRepMeshIncrementalMesh.hpp>
#include <io/OBJTool.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <topology/TopoTool.hpp>
#include <topology/TopoVertex.hpp>
using namespace AMCAX;
;
	SECTION("check length = 1") {
		for (size_t i = 0; i < fedge.size(); i++)
		{
			std::cout << "i = " << i << std::endl;
			TopoEdge edge = static_cast<const TopoEdge&>(fedge[i]);
			mkExt.PerformWithEdgeAndLength(edge, 1.0);
			CHECK(mkExt.IsDone() == true);
			TopoShape newshape = mkExt.Shape();
			TopoFace newface = TopoCast::Face(newshape);
			IndexSet<TopoShape> fedge2;
			TopoExplorerTool::MapShapes(newface, ShapeType::Edge, fedge2);
			Point3 p,p2,p3;
			double tol = 0.01;
			switch (i)
			{
			case 0: 
				p = Point3(10.0, -1.0, 1.0);
				p2 = Point3(10.3, -1.0, 1.0);
				p3 = Point3(-10.1, -0.3, 1.0);
				break;
			case 1:
				p = Point3(11.05, 0.0, 1.0);
				p2 = Point3(10.0, 3.15, 1.0);
				p3 = Point3(9.4, 5.0, 1.0);
				break;
			case 2:
				p = Point3(0.0, 7.0, 1.0);
				p2 = Point3(-7.5, 7.0, 1.0);
				p3 = Point3(7.4, 7.01, 1.0);
				break;
			case 3:
				p = Point3(-10.05, 3.0, 1.0);
				p2 = Point3(-11.0, 0.15, 1.0);
				p3 = Point3(9.8, 0.6, 1.0);
				break;
			case 4:
				p = Point3(0.0, 2.5, 1.0);
				p2 = Point3(-4.2, 2.5, 1.0);
				p3 = Point3(4.3, 2.55, 1.0);
				break;
			case 5:
				p = Point3(2.8, 3.0, 1.0);
				p2 = Point3(3.7, 1.65, 1.0);
				p3 = Point3(1.9, 4.35, 1.0);
				break;
			case 6:
				p = Point3(0.0, 3.5, 1.0);
				p2 = Point3(3.5, 3.5, 1.0);
				p3 = Point3(-3.61, 3.50, 1.0);
				break;
			case 7:
				p = Point3(-2.8, 3.0, 1.0);
				p2 = Point3(-9.98, 0.048, 1.0);
				p3 = Point3(-8.0, 5.97, 1.0);
				break;
			default:
				p = Point3(-999.0, -9999.0, -9999.0);
				break;
			}
			bool isOn = false;
			bool isOn2 = false;
			bool isOn3 = false;
			int matchNum = 0;
			for (int j = 0; j < fedge2.size(); ++j)
			{
				TopoEdge newEdge = static_cast<const TopoEdge&>(fedge2[j]);
				isOn = BRepClassificationTools::IsPointInOnEdge(newEdge, p, tol);
				isOn2 = BRepClassificationTools::IsPointInOnEdge(newEdge, p2, tol);
				isOn3 = BRepClassificationTools::IsPointInOnEdge(newEdge, p3, tol);
				if (isOn)
				{
					matchNum = matchNum + 1;
				}
				if (isOn2)
				{
					matchNum = matchNum + 1;
				}
				if (isOn3)
				{
					matchNum = matchNum + 1;
				}				
			}
			CHECK(matchNum == 3);
			}
		}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API GccCircle3Tangent(const GccQualifiedCurve& qualified1, const GccQualifiedCurve& qualified2, const GccQualifiedCurve& qualified3, double tolerance, double parameter1, double parameter2, double parameter3)	 @param parameter3 The initial guess of the parameter on the third curve
	 @param parameter2 The initial guess of the parameter on the second curve
	 @param parameter1 The initial guess of the parameter on the first curve
	 @param tolerance The tolerance
	 @param qualified3 The third curve
	 @param qualified2 The second curve
	 @param qualified1 The first curve
	 @brief Construct a circle tangent to three curves
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <geomAlgo/GccCircle3Tangent.hpp>
#include <geometry/Geom2Curve.hpp>
#include <geometry/MakeGeom2Line.hpp>
#include <geometry/MakeGeom2Circle.hpp>
#include <geomAlgo/GccEntity.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geomAlgo/GccEntity.hpp>
#include <geomAlgo/GccQualifiedCurve.hpp>
#include <sstream>
using namespace AMCAX;
TEST_CASE("bug1: GccCircle3Tangent  add 48 cases", "[geomAlgo][GccCircle3Tangent][fixbug]") {
	std::shared_ptr<Geom2Curve> l = MakeGeom2Line(Point2(0.0, 0.0), Point2(1.0, 0.0)).Value();
	std::shared_ptr<Geom2Curve> c1 = MakeGeom2Circle(Point2(0.0, 3.0), 2.0).Value();
	std::shared_ptr<Geom2Curve> c2 = MakeGeom2Circle(Point2(4.0, 3.0), 2.0).Value();
	AdaptorGeom2Curve line(l);
	AdaptorGeom2Curve circle1(c1);
	AdaptorGeom2Curve circle2(c2);
	auto lineEnclosed = GccEntity::Enclosed(line);
	auto lineOutside = GccEntity::Outside(line);
	auto lineUnqualified = GccEntity::Unqualified(line);
	auto circle1Enclosed = GccEntity::Enclosed(circle1);
	auto circle1Enclosing = GccEntity::Enclosing(circle1);
	auto circle1Outside = GccEntity::Outside(circle1);
	auto circle1Unqualified = GccEntity::Unqualified(circle1);
	auto circle2Enclosed = GccEntity::Enclosed(circle2);
	auto circle2Enclosing = GccEntity::Enclosing(circle2);
	auto circle2Outside = GccEntity::Outside(circle2);
	auto circle2Unqualified = GccEntity::Unqualified(circle2);
	auto gccl = GccEntity::Enclosed(AdaptorGeom2Curve(l));
	auto gccc1 = GccEntity::Enclosing(AdaptorGeom2Curve(c1));
	auto gccc2 = GccEntity::Outside(AdaptorGeom2Curve(c2));
	auto c3t = [](const GccQualifiedCurve& gccc1, const GccQualifiedCurve& gccc2, const GccQualifiedCurve& gccl)
	{
		std::stringstream output;
		GccCircle3Tangent gcc(gccc1, gccc2, gccl, Precision::Confusion(), 0.0, 0.0, 0.0);
		std::cout << "Test case: " << GccEntity::PositionToString(gccc1.Qualifier()) << ' ' << GccEntity::PositionToString(gccc2.Qualifier()) << ' ' << GccEntity::PositionToString(gccl.Qualifier()) << std::endl;
		std::cout << "Solution: " << gcc.NSolutions() << std::endl;
		output << "Test case: " << GccEntity::PositionToString(gccc1.Qualifier()) << ' ' << GccEntity::PositionToString(gccc2.Qualifier()) << ' ' << GccEntity::PositionToString(gccl.Qualifier()) << std::endl;
		output << "Solution: " << gcc.NSolutions() << std::endl;
		if (gcc.IsDone())
		{
			for (int i = 0; i < gcc.NSolutions(); i++)
			{
				GccPosition q1, q2, q3;
				gcc.Qualifier(i, q1, q2, q3);
				output << i << ": " << *MakeGeom2Circle(gcc.Solution(i)).Value() << std::endl;
				output << "  " << GccEntity::PositionToString(q1) << ' ' << GccEntity::PositionToString(q2) << ' ' << GccEntity::PositionToString(q3) << std::endl;
			}
		}
		else
		{
			std::cout << "gcc.IsDone is False" << std::endl;
			output << "gcc.IsDone is False" << std::endl;
		}
		return output.str();
	};
	auto case1 = c3t(circle1Enclosed, circle2Enclosed, lineEnclosed);
	auto expect1 = "Test case: Enclosed Enclosed Enclosed\nSolution: 0\n";
	CHECK(case1.find(expect1) != std::string::npos);
	auto case2 = c3t(circle1Enclosed, circle2Enclosed, lineOutside);
	auto expect2 = "Test case: Enclosed Enclosed Outside\nSolution: 0\n";
	CHECK(case2.find(expect2) != std::string::npos);
	auto case3 = c3t(circle1Enclosed, circle2Enclosed, lineUnqualified);
	auto expect3 = "Test case: Enclosed Enclosed Unqualified\nSolution: 0\n";
	CHECK(case3.find(expect3) != std::string::npos);
	auto case4 = c3t(circle1Enclosed, circle2Enclosing, lineEnclosed);
	auto expect4 = "Test case: Enclosed Enclosing Enclosed\nSolution: 0\n";
	CHECK(case4.find(expect4) != std::string::npos);
	auto case5 = c3t(circle1Enclosed, circle2Enclosing, lineOutside);
	auto expect5 = "Test case: Enclosed Enclosing Outside\nSolution: 0\n";
	CHECK(case5.find(expect5) != std::string::npos);
	auto case6 = c3t(circle1Enclosed, circle2Enclosing, lineUnqualified);
	auto expect6 = "Test case: Enclosed Enclosing Unqualified\nSolution: 0\n";
	CHECK(case6.find(expect6) != std::string::npos);
	auto case7 = c3t(circle1Enclosed, circle2Outside, lineEnclosed);
	auto expect7 = "Test case: Enclosed Outside Enclosed\nSolution: 0\n";
	CHECK(case7.find(expect7) != std::string::npos);
	auto case8 = c3t(circle1Enclosed, circle2Outside, lineOutside);
	auto expect8 = "Test case: Enclosed Outside Outside\nSolution: 0\n";
	CHECK(case8.find(expect8) != std::string::npos);
	auto case9 = c3t(circle1Enclosed, circle2Outside, lineUnqualified);
	auto expect9 = "Test case: Enclosed Outside Unqualified\nSolution: 0\n";
	CHECK(case9.find(expect9) != std::string::npos);
	auto case10 = c3t(circle1Enclosed, circle2Unqualified, lineEnclosed);
	auto expect10 = "Test case: Enclosed Unqualified Enclosed\nSolution: 0\n";
	CHECK(case10.find(expect10) != std::string::npos);
	auto case11 = c3t(circle1Enclosed, circle2Unqualified, lineOutside);
	auto expect11 = "Test case: Enclosed Unqualified Outside\nSolution: 0\n";
	CHECK(case11.find(expect11) != std::string::npos);
	auto case12 = c3t(circle1Enclosed, circle2Unqualified, lineUnqualified);
	auto expect12 = "Test case: Enclosed Unqualified Unqualified\nSolution: 0\n";
	CHECK(case12.find(expect12) != std::string::npos);
	auto case13 = c3t(circle1Enclosing, circle2Enclosed, lineEnclosed);
	auto expect13 = "Test case: Enclosing Enclosed Enclosed\nSolution: 0\n";
	CHECK(case13.find(expect13) != std::string::npos);
	auto case14 = c3t(circle1Enclosing, circle2Enclosed, lineOutside);
	auto expect14 = "Test case: Enclosing Enclosed Outside\nSolution: 0\n";
	CHECK(case14.find(expect14) != std::string::npos);
	auto case15 = c3t(circle1Enclosing, circle2Enclosed, lineUnqualified);
	auto expect15 = "Test case: Enclosing Enclosed Unqualified\nSolution: 0\n";
	CHECK(case15.find(expect15) != std::string::npos);
	auto case16 = c3t(circle1Enclosing, circle2Enclosing, lineEnclosed);
	auto expect16 = "Test case: Enclosing Enclosing Enclosed\nSolution: 1\n0: 2 2 4.5 1 0 -0 1 4.5\n  Enclosing Enclosing Enclosed\n";
	CHECK(case16.find(expect16) != std::string::npos);
	auto case17 = c3t(circle1Enclosing, circle2Enclosing, lineOutside);
	auto expect17 = "Test case: Enclosing Enclosing Outside\nSolution: 0\n";
	CHECK(case17.find(expect17) != std::string::npos);
	auto case18 = c3t(circle1Enclosing, circle2Enclosing, lineUnqualified);
	auto expect18 = "Test case: Enclosing Enclosing Unqualified\nSolution: 1\n0: 2 2 4.5 1 0 -0 1 4.5\n  Enclosing Enclosing Enclosed\n";
	CHECK(case18.find(expect18) != std::string::npos);
	auto case19 = c3t(circle1Enclosing, circle2Outside, lineEnclosed);
	auto expect19 = "Test case: Enclosing Outside Enclosed\nSolution: 1\n0: 2 -1 3 1 0 -0 1 3\n  Enclosing Outside Enclosed\n";
	CHECK(case19.find(expect19) != std::string::npos);
	auto case20 = c3t(circle1Enclosing, circle2Outside, lineOutside);
	auto expect20 = "Test case: Enclosing Outside Outside\nSolution: 0\n";
	CHECK(case20.find(expect20) != std::string::npos);
	auto case21 = c3t(circle1Enclosing, circle2Outside, lineUnqualified);
	auto expect21 = "Test case: Enclosing Outside Unqualified\nSolution: 1\n0: 2 -1 3 1 0 -0 1 3\n  Enclosing Outside Enclosed\n";
	CHECK(case21.find(expect21) != std::string::npos);
	auto case22 = c3t(circle1Enclosing, circle2Unqualified, lineEnclosed);
	auto expect22 = "Test case: Enclosing Unqualified Enclosed\nSolution: 2\n0: 2 -1 3 1 0 -0 1 3\n  Enclosing Outside Enclosed\n1: 2 2 4.5 1 0 -0 1 4.5\n  Enclosing Enclosing Enclosed\n";
	CHECK(case22.find(expect22) != std::string::npos);
	auto case23 = c3t(circle1Enclosing, circle2Unqualified, lineOutside);
	auto expect23 = "Test case: Enclosing Unqualified Outside\nSolution: 0\n";
	CHECK(case23.find(expect23) != std::string::npos);
	auto case24 = c3t(circle1Enclosing, circle2Unqualified, lineUnqualified);
	auto expect24 = "Test case: Enclosing Unqualified Unqualified\nSolution: 2\n0: 2 -1 3 1 0 -0 1 3\n  Enclosing Outside Enclosed\n1: 2 2 4.5 1 0 -0 1 4.5\n  Enclosing Enclosing Enclosed\n";
	CHECK(case24.find(expect24) != std::string::npos);
	auto case25 = c3t(circle1Outside, circle2Enclosed, lineEnclosed);
	auto expect25 = "Test case: Outside Enclosed Enclosed\nSolution: 0\n";
	CHECK(case25.find(expect25) != std::string::npos);
	auto case26 = c3t(circle1Outside, circle2Enclosed, lineOutside);
	auto expect26 = "Test case: Outside Enclosed Outside\nSolution: 0\n";
	CHECK(case26.find(expect26) != std::string::npos);
	auto case27 = c3t(circle1Outside, circle2Enclosed, lineUnqualified);
	auto expect27 = "Test case: Outside Enclosed Unqualified\nSolution: 0\n";
	CHECK(case27.find(expect27) != std::string::npos);
	auto case28 = c3t(circle1Outside, circle2Enclosing, lineEnclosed);
	auto expect28 = "Test case: Outside Enclosing Enclosed\nSolution: 1\n0: 2 5 3 1 0 -0 1 3\n  Outside Enclosing Enclosed\n";
	CHECK(case28.find(expect28) != std::string::npos);
	auto case29 = c3t(circle1Outside, circle2Enclosing, lineOutside);
	auto expect29 = "Test case: Outside Enclosing Outside\nSolution: 0\n";
	CHECK(case29.find(expect29) != std::string::npos);
	auto case30 = c3t(circle1Outside, circle2Enclosing, lineUnqualified);
	auto expect30 = "Test case: Outside Enclosing Unqualified\nSolution: 1\n0: 2 5 3 1 0 -0 1 3\n  Outside Enclosing Enclosed\n";
	CHECK(case30.find(expect30) != std::string::npos);
	auto case31 = c3t(circle1Outside, circle2Outside, lineEnclosed);
	auto expect31 = "Test case: Outside Outside Enclosed\nSolution: 1\n0: 2 2 0.9 1 0 -0 1 0.9\n  Outside Outside Enclosed\n";
	CHECK(case31.find(expect31) != std::string::npos);
	auto case32 = c3t(circle1Outside, circle2Outside, lineOutside);
	auto expect32 = "Test case: Outside Outside Outside\nSolution: 0\n";
	CHECK(case32.find(expect32) != std::string::npos);
	auto case33 = c3t(circle1Outside, circle2Outside, lineUnqualified);
	auto expect33 = "Test case: Outside Outside Unqualified\nSolution: 1\n0: 2 2 0.9 1 0 -0 1 0.9\n  Outside Outside Enclosed\n";
	CHECK(case33.find(expect33) != std::string::npos);
	auto case34 = c3t(circle1Outside, circle2Unqualified, lineEnclosed);
	auto expect34 = "Test case: Outside Unqualified Enclosed\nSolution: 2\n0: 2 2 0.9 1 0 -0 1 0.9\n  Outside Outside Enclosed\n1: 2 5 3 1 0 -0 1 3\n  Outside Enclosing Enclosed\n";
	CHECK(case34.find(expect34) != std::string::npos);
	auto case35 = c3t(circle1Outside, circle2Unqualified, lineOutside);
	auto expect35 = "Test case: Outside Unqualified Outside\nSolution: 0\n";
	CHECK(case35.find(expect35) != std::string::npos);
	auto case36 = c3t(circle1Outside, circle2Unqualified, lineUnqualified);
	auto expect36 = "Test case: Outside Unqualified Unqualified\nSolution: 2\n0: 2 2 0.9 1 0 -0 1 0.9\n  Outside Outside Enclosed\n1: 2 5 3 1 0 -0 1 3\n  Outside Enclosing Enclosed\n";
	CHECK(case36.find(expect36) != std::string::npos);
	auto case37 = c3t(circle1Unqualified, circle2Enclosed, lineEnclosed);
	auto expect37 = "Test case: Unqualified Enclosed Enclosed\nSolution: 0\n";
	CHECK(case37.find(expect37) != std::string::npos);
	auto case38 = c3t(circle1Unqualified, circle2Enclosed, lineOutside);
	auto expect38 = "Test case: Unqualified Enclosed Outside\nSolution: 0\n";
	CHECK(case38.find(expect38) != std::string::npos);
	auto case39 = c3t(circle1Unqualified, circle2Enclosed, lineUnqualified);
	auto expect39 = "Test case: Unqualified Enclosed Unqualified\nSolution: 0\n";
	CHECK(case39.find(expect39) != std::string::npos);
	auto case40 = c3t(circle1Unqualified, circle2Enclosing, lineEnclosed);
	auto expect40 = "Test case: Unqualified Enclosing Enclosed\nSolution: 2\n0: 2 5 3 1 0 -0 1 3\n  Outside Enclosing Enclosed\n1: 2 2 4.5 1 0 -0 1 4.5\n  Enclosing Enclosing Enclosed\n";
	CHECK(case40.find(expect40) != std::string::npos);
	auto case41 = c3t(circle1Unqualified, circle2Enclosing, lineOutside);
	auto expect41 = "Test case: Unqualified Enclosing Outside\nSolution: 0\n";
	CHECK(case41.find(expect41) != std::string::npos);
	auto case42 = c3t(circle1Unqualified, circle2Enclosing, lineUnqualified);
	auto expect42 = "Test case: Unqualified Enclosing Unqualified\nSolution: 2\n0: 2 5 3 1 0 -0 1 3\n  Outside Enclosing Enclosed\n1: 2 2 4.5 1 0 -0 1 4.5\n  Enclosing Enclosing Enclosed\n";
	CHECK(case42.find(expect42) != std::string::npos);
	auto case43 = c3t(circle1Unqualified, circle2Outside, lineEnclosed);
	auto expect43 = "Test case: Unqualified Outside Enclosed\nSolution: 2\n0: 2 2 0.9 1 0 -0 1 0.9\n  Outside Outside Enclosed\n1: 2 -1 3 1 0 -0 1 3\n  Enclosing Outside Enclosed\n";
	CHECK(case43.find(expect43) != std::string::npos);
	auto case44 = c3t(circle1Unqualified, circle2Outside, lineOutside);
	auto expect44 = "Test case: Unqualified Outside Outside\nSolution: 0\n";
	CHECK(case44.find(expect44) != std::string::npos);
	auto case45 = c3t(circle1Unqualified, circle2Outside, lineUnqualified);
	auto expect45 = "Test case: Unqualified Outside Unqualified\nSolution: 2\n0: 2 2 0.9 1 0 -0 1 0.9\n  Outside Outside Enclosed\n1: 2 -1 3 1 0 -0 1 3\n  Enclosing Outside Enclosed\n";
	CHECK(case45.find(expect45) != std::string::npos);
	auto case46 = c3t(circle1Unqualified, circle2Unqualified, lineEnclosed);
	auto expect46 = "Test case: Unqualified Unqualified Enclosed\nSolution: 4\n0: 2 2 0.9 1 0 -0 1 0.9\n  Outside Outside Enclosed\n1: 2 5 3 1 0 -0 1 3\n  Outside Enclosing Enclosed\n2: 2 -1 3 1 0 -0 1 3\n  Enclosing Outside Enclosed\n3: 2 2 4.5 1 0 -0 1 4.5\n  Enclosing Enclosing Enclosed\n";
	CHECK(case46.find(expect46) != std::string::npos);
	auto case47 = c3t(circle1Unqualified, circle2Unqualified, lineOutside);
	auto expect47 = "Test case: Unqualified Unqualified Outside\nSolution: 0\n";
	CHECK(case47.find(expect47) != std::string::npos);
	auto case48 = c3t(circle1Unqualified, circle2Unqualified, lineUnqualified);
	auto expect48 = "Test case: Unqualified Unqualified Unqualified\nSolution: 4\n0: 2 2 0.9 1 0 -0 1 0.9\n  Outside Outside Enclosed\n1: 2 5 3 1 0 -0 1 3\n  Outside Enclosing Enclosed\n2: 2 -1 3 1 0 -0 1 3\n  Enclosing Outside Enclosed\n3: 2 2 4.5 1 0 -0 1 4.5\n  Enclosing Enclosing Enclosed";
	CHECK(case48.find(expect48) != std::string::npos);
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API GccCircle3Tangent(const GccQualifiedCurve& qualified1, const GccQualifiedCurve& qualified2, const Point2& point, double tolerance, double parameter1, double parameter2)	 @param parameter2 The initial guess of the parameter on the second curve
	 @param parameter1 The initial guess of the parameter on the first curve
	 @param tolerance The tolerance
	 @param point The point that the circle passes through
	 @param qualified2 The second curve
	 @param qualified1 The first curve
	 @brief Construct a circle tangent to two curves and passing through a point
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <geomAlgo/GccCircle3Tangent.hpp>
#include <geometry/Geom2Curve.hpp>
#include <geometry/MakeGeom2Line.hpp>
#include <geometry/MakeGeom2Circle.hpp>
#include <geomAlgo/GccEntity.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geomAlgo/GccEntity.hpp>
#include <geomAlgo/GccQualifiedCurve.hpp>
#include <sstream>
using namespace AMCAX;
TEST_CASE("bug1: GccCircle3Tangent  add 48 cases", "[geomAlgo][GccCircle3Tangent][fixbug]") {
	std::shared_ptr<Geom2Curve> l = MakeGeom2Line(Point2(0.0, 0.0), Point2(1.0, 0.0)).Value();
	std::shared_ptr<Geom2Curve> c1 = MakeGeom2Circle(Point2(0.0, 3.0), 2.0).Value();
	std::shared_ptr<Geom2Curve> c2 = MakeGeom2Circle(Point2(4.0, 3.0), 2.0).Value();
	AdaptorGeom2Curve line(l);
	AdaptorGeom2Curve circle1(c1);
	AdaptorGeom2Curve circle2(c2);
	auto lineEnclosed = GccEntity::Enclosed(line);
	auto lineOutside = GccEntity::Outside(line);
	auto lineUnqualified = GccEntity::Unqualified(line);
	auto circle1Enclosed = GccEntity::Enclosed(circle1);
	auto circle1Enclosing = GccEntity::Enclosing(circle1);
	auto circle1Outside = GccEntity::Outside(circle1);
	auto circle1Unqualified = GccEntity::Unqualified(circle1);
	auto circle2Enclosed = GccEntity::Enclosed(circle2);
	auto circle2Enclosing = GccEntity::Enclosing(circle2);
	auto circle2Outside = GccEntity::Outside(circle2);
	auto circle2Unqualified = GccEntity::Unqualified(circle2);
	auto gccl = GccEntity::Enclosed(AdaptorGeom2Curve(l));
	auto gccc1 = GccEntity::Enclosing(AdaptorGeom2Curve(c1));
	auto gccc2 = GccEntity::Outside(AdaptorGeom2Curve(c2));
	auto c3t = [](const GccQualifiedCurve& gccc1, const GccQualifiedCurve& gccc2, const GccQualifiedCurve& gccl)
	{
		std::stringstream output;
		GccCircle3Tangent gcc(gccc1, gccc2, gccl, Precision::Confusion(), 0.0, 0.0, 0.0);
		std::cout << "Test case: " << GccEntity::PositionToString(gccc1.Qualifier()) << ' ' << GccEntity::PositionToString(gccc2.Qualifier()) << ' ' << GccEntity::PositionToString(gccl.Qualifier()) << std::endl;
		std::cout << "Solution: " << gcc.NSolutions() << std::endl;
		output << "Test case: " << GccEntity::PositionToString(gccc1.Qualifier()) << ' ' << GccEntity::PositionToString(gccc2.Qualifier()) << ' ' << GccEntity::PositionToString(gccl.Qualifier()) << std::endl;
		output << "Solution: " << gcc.NSolutions() << std::endl;
		if (gcc.IsDone())
		{
			for (int i = 0; i < gcc.NSolutions(); i++)
			{
				GccPosition q1, q2, q3;
				gcc.Qualifier(i, q1, q2, q3);
				output << i << ": " << *MakeGeom2Circle(gcc.Solution(i)).Value() << std::endl;
				output << "  " << GccEntity::PositionToString(q1) << ' ' << GccEntity::PositionToString(q2) << ' ' << GccEntity::PositionToString(q3) << std::endl;
			}
		}
		else
		{
			std::cout << "gcc.IsDone is False" << std::endl;
			output << "gcc.IsDone is False" << std::endl;
		}
		return output.str();
	};
	auto case1 = c3t(circle1Enclosed, circle2Enclosed, lineEnclosed);
	auto expect1 = "Test case: Enclosed Enclosed Enclosed\nSolution: 0\n";
	CHECK(case1.find(expect1) != std::string::npos);
	auto case2 = c3t(circle1Enclosed, circle2Enclosed, lineOutside);
	auto expect2 = "Test case: Enclosed Enclosed Outside\nSolution: 0\n";
	CHECK(case2.find(expect2) != std::string::npos);
	auto case3 = c3t(circle1Enclosed, circle2Enclosed, lineUnqualified);
	auto expect3 = "Test case: Enclosed Enclosed Unqualified\nSolution: 0\n";
	CHECK(case3.find(expect3) != std::string::npos);
	auto case4 = c3t(circle1Enclosed, circle2Enclosing, lineEnclosed);
	auto expect4 = "Test case: Enclosed Enclosing Enclosed\nSolution: 0\n";
	CHECK(case4.find(expect4) != std::string::npos);
	auto case5 = c3t(circle1Enclosed, circle2Enclosing, lineOutside);
	auto expect5 = "Test case: Enclosed Enclosing Outside\nSolution: 0\n";
	CHECK(case5.find(expect5) != std::string::npos);
	auto case6 = c3t(circle1Enclosed, circle2Enclosing, lineUnqualified);
	auto expect6 = "Test case: Enclosed Enclosing Unqualified\nSolution: 0\n";
	CHECK(case6.find(expect6) != std::string::npos);
	auto case7 = c3t(circle1Enclosed, circle2Outside, lineEnclosed);
	auto expect7 = "Test case: Enclosed Outside Enclosed\nSolution: 0\n";
	CHECK(case7.find(expect7) != std::string::npos);
	auto case8 = c3t(circle1Enclosed, circle2Outside, lineOutside);
	auto expect8 = "Test case: Enclosed Outside Outside\nSolution: 0\n";
	CHECK(case8.find(expect8) != std::string::npos);
	auto case9 = c3t(circle1Enclosed, circle2Outside, lineUnqualified);
	auto expect9 = "Test case: Enclosed Outside Unqualified\nSolution: 0\n";
	CHECK(case9.find(expect9) != std::string::npos);
	auto case10 = c3t(circle1Enclosed, circle2Unqualified, lineEnclosed);
	auto expect10 = "Test case: Enclosed Unqualified Enclosed\nSolution: 0\n";
	CHECK(case10.find(expect10) != std::string::npos);
	auto case11 = c3t(circle1Enclosed, circle2Unqualified, lineOutside);
	auto expect11 = "Test case: Enclosed Unqualified Outside\nSolution: 0\n";
	CHECK(case11.find(expect11) != std::string::npos);
	auto case12 = c3t(circle1Enclosed, circle2Unqualified, lineUnqualified);
	auto expect12 = "Test case: Enclosed Unqualified Unqualified\nSolution: 0\n";
	CHECK(case12.find(expect12) != std::string::npos);
	auto case13 = c3t(circle1Enclosing, circle2Enclosed, lineEnclosed);
	auto expect13 = "Test case: Enclosing Enclosed Enclosed\nSolution: 0\n";
	CHECK(case13.find(expect13) != std::string::npos);
	auto case14 = c3t(circle1Enclosing, circle2Enclosed, lineOutside);
	auto expect14 = "Test case: Enclosing Enclosed Outside\nSolution: 0\n";
	CHECK(case14.find(expect14) != std::string::npos);
	auto case15 = c3t(circle1Enclosing, circle2Enclosed, lineUnqualified);
	auto expect15 = "Test case: Enclosing Enclosed Unqualified\nSolution: 0\n";
	CHECK(case15.find(expect15) != std::string::npos);
	auto case16 = c3t(circle1Enclosing, circle2Enclosing, lineEnclosed);
	auto expect16 = "Test case: Enclosing Enclosing Enclosed\nSolution: 1\n0: 2 2 4.5 1 0 -0 1 4.5\n  Enclosing Enclosing Enclosed\n";
	CHECK(case16.find(expect16) != std::string::npos);
	auto case17 = c3t(circle1Enclosing, circle2Enclosing, lineOutside);
	auto expect17 = "Test case: Enclosing Enclosing Outside\nSolution: 0\n";
	CHECK(case17.find(expect17) != std::string::npos);
	auto case18 = c3t(circle1Enclosing, circle2Enclosing, lineUnqualified);
	auto expect18 = "Test case: Enclosing Enclosing Unqualified\nSolution: 1\n0: 2 2 4.5 1 0 -0 1 4.5\n  Enclosing Enclosing Enclosed\n";
	CHECK(case18.find(expect18) != std::string::npos);
	auto case19 = c3t(circle1Enclosing, circle2Outside, lineEnclosed);
	auto expect19 = "Test case: Enclosing Outside Enclosed\nSolution: 1\n0: 2 -1 3 1 0 -0 1 3\n  Enclosing Outside Enclosed\n";
	CHECK(case19.find(expect19) != std::string::npos);
	auto case20 = c3t(circle1Enclosing, circle2Outside, lineOutside);
	auto expect20 = "Test case: Enclosing Outside Outside\nSolution: 0\n";
	CHECK(case20.find(expect20) != std::string::npos);
	auto case21 = c3t(circle1Enclosing, circle2Outside, lineUnqualified);
	auto expect21 = "Test case: Enclosing Outside Unqualified\nSolution: 1\n0: 2 -1 3 1 0 -0 1 3\n  Enclosing Outside Enclosed\n";
	CHECK(case21.find(expect21) != std::string::npos);
	auto case22 = c3t(circle1Enclosing, circle2Unqualified, lineEnclosed);
	auto expect22 = "Test case: Enclosing Unqualified Enclosed\nSolution: 2\n0: 2 -1 3 1 0 -0 1 3\n  Enclosing Outside Enclosed\n1: 2 2 4.5 1 0 -0 1 4.5\n  Enclosing Enclosing Enclosed\n";
	CHECK(case22.find(expect22) != std::string::npos);
	auto case23 = c3t(circle1Enclosing, circle2Unqualified, lineOutside);
	auto expect23 = "Test case: Enclosing Unqualified Outside\nSolution: 0\n";
	CHECK(case23.find(expect23) != std::string::npos);
	auto case24 = c3t(circle1Enclosing, circle2Unqualified, lineUnqualified);
	auto expect24 = "Test case: Enclosing Unqualified Unqualified\nSolution: 2\n0: 2 -1 3 1 0 -0 1 3\n  Enclosing Outside Enclosed\n1: 2 2 4.5 1 0 -0 1 4.5\n  Enclosing Enclosing Enclosed\n";
	CHECK(case24.find(expect24) != std::string::npos);
	auto case25 = c3t(circle1Outside, circle2Enclosed, lineEnclosed);
	auto expect25 = "Test case: Outside Enclosed Enclosed\nSolution: 0\n";
	CHECK(case25.find(expect25) != std::string::npos);
	auto case26 = c3t(circle1Outside, circle2Enclosed, lineOutside);
	auto expect26 = "Test case: Outside Enclosed Outside\nSolution: 0\n";
	CHECK(case26.find(expect26) != std::string::npos);
	auto case27 = c3t(circle1Outside, circle2Enclosed, lineUnqualified);
	auto expect27 = "Test case: Outside Enclosed Unqualified\nSolution: 0\n";
	CHECK(case27.find(expect27) != std::string::npos);
	auto case28 = c3t(circle1Outside, circle2Enclosing, lineEnclosed);
	auto expect28 = "Test case: Outside Enclosing Enclosed\nSolution: 1\n0: 2 5 3 1 0 -0 1 3\n  Outside Enclosing Enclosed\n";
	CHECK(case28.find(expect28) != std::string::npos);
	auto case29 = c3t(circle1Outside, circle2Enclosing, lineOutside);
	auto expect29 = "Test case: Outside Enclosing Outside\nSolution: 0\n";
	CHECK(case29.find(expect29) != std::string::npos);
	auto case30 = c3t(circle1Outside, circle2Enclosing, lineUnqualified);
	auto expect30 = "Test case: Outside Enclosing Unqualified\nSolution: 1\n0: 2 5 3 1 0 -0 1 3\n  Outside Enclosing Enclosed\n";
	CHECK(case30.find(expect30) != std::string::npos);
	auto case31 = c3t(circle1Outside, circle2Outside, lineEnclosed);
	auto expect31 = "Test case: Outside Outside Enclosed\nSolution: 1\n0: 2 2 0.9 1 0 -0 1 0.9\n  Outside Outside Enclosed\n";
	CHECK(case31.find(expect31) != std::string::npos);
	auto case32 = c3t(circle1Outside, circle2Outside, lineOutside);
	auto expect32 = "Test case: Outside Outside Outside\nSolution: 0\n";
	CHECK(case32.find(expect32) != std::string::npos);
	auto case33 = c3t(circle1Outside, circle2Outside, lineUnqualified);
	auto expect33 = "Test case: Outside Outside Unqualified\nSolution: 1\n0: 2 2 0.9 1 0 -0 1 0.9\n  Outside Outside Enclosed\n";
	CHECK(case33.find(expect33) != std::string::npos);
	auto case34 = c3t(circle1Outside, circle2Unqualified, lineEnclosed);
	auto expect34 = "Test case: Outside Unqualified Enclosed\nSolution: 2\n0: 2 2 0.9 1 0 -0 1 0.9\n  Outside Outside Enclosed\n1: 2 5 3 1 0 -0 1 3\n  Outside Enclosing Enclosed\n";
	CHECK(case34.find(expect34) != std::string::npos);
	auto case35 = c3t(circle1Outside, circle2Unqualified, lineOutside);
	auto expect35 = "Test case: Outside Unqualified Outside\nSolution: 0\n";
	CHECK(case35.find(expect35) != std::string::npos);
	auto case36 = c3t(circle1Outside, circle2Unqualified, lineUnqualified);
	auto expect36 = "Test case: Outside Unqualified Unqualified\nSolution: 2\n0: 2 2 0.9 1 0 -0 1 0.9\n  Outside Outside Enclosed\n1: 2 5 3 1 0 -0 1 3\n  Outside Enclosing Enclosed\n";
	CHECK(case36.find(expect36) != std::string::npos);
	auto case37 = c3t(circle1Unqualified, circle2Enclosed, lineEnclosed);
	auto expect37 = "Test case: Unqualified Enclosed Enclosed\nSolution: 0\n";
	CHECK(case37.find(expect37) != std::string::npos);
	auto case38 = c3t(circle1Unqualified, circle2Enclosed, lineOutside);
	auto expect38 = "Test case: Unqualified Enclosed Outside\nSolution: 0\n";
	CHECK(case38.find(expect38) != std::string::npos);
	auto case39 = c3t(circle1Unqualified, circle2Enclosed, lineUnqualified);
	auto expect39 = "Test case: Unqualified Enclosed Unqualified\nSolution: 0\n";
	CHECK(case39.find(expect39) != std::string::npos);
	auto case40 = c3t(circle1Unqualified, circle2Enclosing, lineEnclosed);
	auto expect40 = "Test case: Unqualified Enclosing Enclosed\nSolution: 2\n0: 2 5 3 1 0 -0 1 3\n  Outside Enclosing Enclosed\n1: 2 2 4.5 1 0 -0 1 4.5\n  Enclosing Enclosing Enclosed\n";
	CHECK(case40.find(expect40) != std::string::npos);
	auto case41 = c3t(circle1Unqualified, circle2Enclosing, lineOutside);
	auto expect41 = "Test case: Unqualified Enclosing Outside\nSolution: 0\n";
	CHECK(case41.find(expect41) != std::string::npos);
	auto case42 = c3t(circle1Unqualified, circle2Enclosing, lineUnqualified);
	auto expect42 = "Test case: Unqualified Enclosing Unqualified\nSolution: 2\n0: 2 5 3 1 0 -0 1 3\n  Outside Enclosing Enclosed\n1: 2 2 4.5 1 0 -0 1 4.5\n  Enclosing Enclosing Enclosed\n";
	CHECK(case42.find(expect42) != std::string::npos);
	auto case43 = c3t(circle1Unqualified, circle2Outside, lineEnclosed);
	auto expect43 = "Test case: Unqualified Outside Enclosed\nSolution: 2\n0: 2 2 0.9 1 0 -0 1 0.9\n  Outside Outside Enclosed\n1: 2 -1 3 1 0 -0 1 3\n  Enclosing Outside Enclosed\n";
	CHECK(case43.find(expect43) != std::string::npos);
	auto case44 = c3t(circle1Unqualified, circle2Outside, lineOutside);
	auto expect44 = "Test case: Unqualified Outside Outside\nSolution: 0\n";
	CHECK(case44.find(expect44) != std::string::npos);
	auto case45 = c3t(circle1Unqualified, circle2Outside, lineUnqualified);
	auto expect45 = "Test case: Unqualified Outside Unqualified\nSolution: 2\n0: 2 2 0.9 1 0 -0 1 0.9\n  Outside Outside Enclosed\n1: 2 -1 3 1 0 -0 1 3\n  Enclosing Outside Enclosed\n";
	CHECK(case45.find(expect45) != std::string::npos);
	auto case46 = c3t(circle1Unqualified, circle2Unqualified, lineEnclosed);
	auto expect46 = "Test case: Unqualified Unqualified Enclosed\nSolution: 4\n0: 2 2 0.9 1 0 -0 1 0.9\n  Outside Outside Enclosed\n1: 2 5 3 1 0 -0 1 3\n  Outside Enclosing Enclosed\n2: 2 -1 3 1 0 -0 1 3\n  Enclosing Outside Enclosed\n3: 2 2 4.5 1 0 -0 1 4.5\n  Enclosing Enclosing Enclosed\n";
	CHECK(case46.find(expect46) != std::string::npos);
	auto case47 = c3t(circle1Unqualified, circle2Unqualified, lineOutside);
	auto expect47 = "Test case: Unqualified Unqualified Outside\nSolution: 0\n";
	CHECK(case47.find(expect47) != std::string::npos);
	auto case48 = c3t(circle1Unqualified, circle2Unqualified, lineUnqualified);
	auto expect48 = "Test case: Unqualified Unqualified Unqualified\nSolution: 4\n0: 2 2 0.9 1 0 -0 1 0.9\n  Outside Outside Enclosed\n1: 2 5 3 1 0 -0 1 3\n  Outside Enclosing Enclosed\n2: 2 -1 3 1 0 -0 1 3\n  Enclosing Outside Enclosed\n3: 2 2 4.5 1 0 -0 1 4.5\n  Enclosing Enclosing Enclosed";
	CHECK(case48.find(expect48) != std::string::npos);
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API GccCircle3Tangent(const GccQualifiedCurve& qualified1, const Point2& point1, const Point2& point2, double tolerance, double parameter1)	 @param parameter1 The initial guess of the parameter on the curve
	 @param tolerance The tolerance
	 @param point2 The second point
	 @param point1 The first point
	 @param qualified1 The tangent curve
	 @brief Construct a circle tangent to a curve and passing throught two points
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <geomAlgo/GccCircle3Tangent.hpp>
#include <geometry/Geom2Curve.hpp>
#include <geometry/MakeGeom2Line.hpp>
#include <geometry/MakeGeom2Circle.hpp>
#include <geomAlgo/GccEntity.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geomAlgo/GccEntity.hpp>
#include <geomAlgo/GccQualifiedCurve.hpp>
#include <sstream>
using namespace AMCAX;
TEST_CASE("bug1: GccCircle3Tangent  add 48 cases", "[geomAlgo][GccCircle3Tangent][fixbug]") {
	std::shared_ptr<Geom2Curve> l = MakeGeom2Line(Point2(0.0, 0.0), Point2(1.0, 0.0)).Value();
	std::shared_ptr<Geom2Curve> c1 = MakeGeom2Circle(Point2(0.0, 3.0), 2.0).Value();
	std::shared_ptr<Geom2Curve> c2 = MakeGeom2Circle(Point2(4.0, 3.0), 2.0).Value();
	AdaptorGeom2Curve line(l);
	AdaptorGeom2Curve circle1(c1);
	AdaptorGeom2Curve circle2(c2);
	auto lineEnclosed = GccEntity::Enclosed(line);
	auto lineOutside = GccEntity::Outside(line);
	auto lineUnqualified = GccEntity::Unqualified(line);
	auto circle1Enclosed = GccEntity::Enclosed(circle1);
	auto circle1Enclosing = GccEntity::Enclosing(circle1);
	auto circle1Outside = GccEntity::Outside(circle1);
	auto circle1Unqualified = GccEntity::Unqualified(circle1);
	auto circle2Enclosed = GccEntity::Enclosed(circle2);
	auto circle2Enclosing = GccEntity::Enclosing(circle2);
	auto circle2Outside = GccEntity::Outside(circle2);
	auto circle2Unqualified = GccEntity::Unqualified(circle2);
	auto gccl = GccEntity::Enclosed(AdaptorGeom2Curve(l));
	auto gccc1 = GccEntity::Enclosing(AdaptorGeom2Curve(c1));
	auto gccc2 = GccEntity::Outside(AdaptorGeom2Curve(c2));
	auto c3t = [](const GccQualifiedCurve& gccc1, const GccQualifiedCurve& gccc2, const GccQualifiedCurve& gccl)
	{
		std::stringstream output;
		GccCircle3Tangent gcc(gccc1, gccc2, gccl, Precision::Confusion(), 0.0, 0.0, 0.0);
		std::cout << "Test case: " << GccEntity::PositionToString(gccc1.Qualifier()) << ' ' << GccEntity::PositionToString(gccc2.Qualifier()) << ' ' << GccEntity::PositionToString(gccl.Qualifier()) << std::endl;
		std::cout << "Solution: " << gcc.NSolutions() << std::endl;
		output << "Test case: " << GccEntity::PositionToString(gccc1.Qualifier()) << ' ' << GccEntity::PositionToString(gccc2.Qualifier()) << ' ' << GccEntity::PositionToString(gccl.Qualifier()) << std::endl;
		output << "Solution: " << gcc.NSolutions() << std::endl;
		if (gcc.IsDone())
		{
			for (int i = 0; i < gcc.NSolutions(); i++)
			{
				GccPosition q1, q2, q3;
				gcc.Qualifier(i, q1, q2, q3);
				output << i << ": " << *MakeGeom2Circle(gcc.Solution(i)).Value() << std::endl;
				output << "  " << GccEntity::PositionToString(q1) << ' ' << GccEntity::PositionToString(q2) << ' ' << GccEntity::PositionToString(q3) << std::endl;
			}
		}
		else
		{
			std::cout << "gcc.IsDone is False" << std::endl;
			output << "gcc.IsDone is False" << std::endl;
		}
		return output.str();
	};
	auto case1 = c3t(circle1Enclosed, circle2Enclosed, lineEnclosed);
	auto expect1 = "Test case: Enclosed Enclosed Enclosed\nSolution: 0\n";
	CHECK(case1.find(expect1) != std::string::npos);
	auto case2 = c3t(circle1Enclosed, circle2Enclosed, lineOutside);
	auto expect2 = "Test case: Enclosed Enclosed Outside\nSolution: 0\n";
	CHECK(case2.find(expect2) != std::string::npos);
	auto case3 = c3t(circle1Enclosed, circle2Enclosed, lineUnqualified);
	auto expect3 = "Test case: Enclosed Enclosed Unqualified\nSolution: 0\n";
	CHECK(case3.find(expect3) != std::string::npos);
	auto case4 = c3t(circle1Enclosed, circle2Enclosing, lineEnclosed);
	auto expect4 = "Test case: Enclosed Enclosing Enclosed\nSolution: 0\n";
	CHECK(case4.find(expect4) != std::string::npos);
	auto case5 = c3t(circle1Enclosed, circle2Enclosing, lineOutside);
	auto expect5 = "Test case: Enclosed Enclosing Outside\nSolution: 0\n";
	CHECK(case5.find(expect5) != std::string::npos);
	auto case6 = c3t(circle1Enclosed, circle2Enclosing, lineUnqualified);
	auto expect6 = "Test case: Enclosed Enclosing Unqualified\nSolution: 0\n";
	CHECK(case6.find(expect6) != std::string::npos);
	auto case7 = c3t(circle1Enclosed, circle2Outside, lineEnclosed);
	auto expect7 = "Test case: Enclosed Outside Enclosed\nSolution: 0\n";
	CHECK(case7.find(expect7) != std::string::npos);
	auto case8 = c3t(circle1Enclosed, circle2Outside, lineOutside);
	auto expect8 = "Test case: Enclosed Outside Outside\nSolution: 0\n";
	CHECK(case8.find(expect8) != std::string::npos);
	auto case9 = c3t(circle1Enclosed, circle2Outside, lineUnqualified);
	auto expect9 = "Test case: Enclosed Outside Unqualified\nSolution: 0\n";
	CHECK(case9.find(expect9) != std::string::npos);
	auto case10 = c3t(circle1Enclosed, circle2Unqualified, lineEnclosed);
	auto expect10 = "Test case: Enclosed Unqualified Enclosed\nSolution: 0\n";
	CHECK(case10.find(expect10) != std::string::npos);
	auto case11 = c3t(circle1Enclosed, circle2Unqualified, lineOutside);
	auto expect11 = "Test case: Enclosed Unqualified Outside\nSolution: 0\n";
	CHECK(case11.find(expect11) != std::string::npos);
	auto case12 = c3t(circle1Enclosed, circle2Unqualified, lineUnqualified);
	auto expect12 = "Test case: Enclosed Unqualified Unqualified\nSolution: 0\n";
	CHECK(case12.find(expect12) != std::string::npos);
	auto case13 = c3t(circle1Enclosing, circle2Enclosed, lineEnclosed);
	auto expect13 = "Test case: Enclosing Enclosed Enclosed\nSolution: 0\n";
	CHECK(case13.find(expect13) != std::string::npos);
	auto case14 = c3t(circle1Enclosing, circle2Enclosed, lineOutside);
	auto expect14 = "Test case: Enclosing Enclosed Outside\nSolution: 0\n";
	CHECK(case14.find(expect14) != std::string::npos);
	auto case15 = c3t(circle1Enclosing, circle2Enclosed, lineUnqualified);
	auto expect15 = "Test case: Enclosing Enclosed Unqualified\nSolution: 0\n";
	CHECK(case15.find(expect15) != std::string::npos);
	auto case16 = c3t(circle1Enclosing, circle2Enclosing, lineEnclosed);
	auto expect16 = "Test case: Enclosing Enclosing Enclosed\nSolution: 1\n0: 2 2 4.5 1 0 -0 1 4.5\n  Enclosing Enclosing Enclosed\n";
	CHECK(case16.find(expect16) != std::string::npos);
	auto case17 = c3t(circle1Enclosing, circle2Enclosing, lineOutside);
	auto expect17 = "Test case: Enclosing Enclosing Outside\nSolution: 0\n";
	CHECK(case17.find(expect17) != std::string::npos);
	auto case18 = c3t(circle1Enclosing, circle2Enclosing, lineUnqualified);
	auto expect18 = "Test case: Enclosing Enclosing Unqualified\nSolution: 1\n0: 2 2 4.5 1 0 -0 1 4.5\n  Enclosing Enclosing Enclosed\n";
	CHECK(case18.find(expect18) != std::string::npos);
	auto case19 = c3t(circle1Enclosing, circle2Outside, lineEnclosed);
	auto expect19 = "Test case: Enclosing Outside Enclosed\nSolution: 1\n0: 2 -1 3 1 0 -0 1 3\n  Enclosing Outside Enclosed\n";
	CHECK(case19.find(expect19) != std::string::npos);
	auto case20 = c3t(circle1Enclosing, circle2Outside, lineOutside);
	auto expect20 = "Test case: Enclosing Outside Outside\nSolution: 0\n";
	CHECK(case20.find(expect20) != std::string::npos);
	auto case21 = c3t(circle1Enclosing, circle2Outside, lineUnqualified);
	auto expect21 = "Test case: Enclosing Outside Unqualified\nSolution: 1\n0: 2 -1 3 1 0 -0 1 3\n  Enclosing Outside Enclosed\n";
	CHECK(case21.find(expect21) != std::string::npos);
	auto case22 = c3t(circle1Enclosing, circle2Unqualified, lineEnclosed);
	auto expect22 = "Test case: Enclosing Unqualified Enclosed\nSolution: 2\n0: 2 -1 3 1 0 -0 1 3\n  Enclosing Outside Enclosed\n1: 2 2 4.5 1 0 -0 1 4.5\n  Enclosing Enclosing Enclosed\n";
	CHECK(case22.find(expect22) != std::string::npos);
	auto case23 = c3t(circle1Enclosing, circle2Unqualified, lineOutside);
	auto expect23 = "Test case: Enclosing Unqualified Outside\nSolution: 0\n";
	CHECK(case23.find(expect23) != std::string::npos);
	auto case24 = c3t(circle1Enclosing, circle2Unqualified, lineUnqualified);
	auto expect24 = "Test case: Enclosing Unqualified Unqualified\nSolution: 2\n0: 2 -1 3 1 0 -0 1 3\n  Enclosing Outside Enclosed\n1: 2 2 4.5 1 0 -0 1 4.5\n  Enclosing Enclosing Enclosed\n";
	CHECK(case24.find(expect24) != std::string::npos);
	auto case25 = c3t(circle1Outside, circle2Enclosed, lineEnclosed);
	auto expect25 = "Test case: Outside Enclosed Enclosed\nSolution: 0\n";
	CHECK(case25.find(expect25) != std::string::npos);
	auto case26 = c3t(circle1Outside, circle2Enclosed, lineOutside);
	auto expect26 = "Test case: Outside Enclosed Outside\nSolution: 0\n";
	CHECK(case26.find(expect26) != std::string::npos);
	auto case27 = c3t(circle1Outside, circle2Enclosed, lineUnqualified);
	auto expect27 = "Test case: Outside Enclosed Unqualified\nSolution: 0\n";
	CHECK(case27.find(expect27) != std::string::npos);
	auto case28 = c3t(circle1Outside, circle2Enclosing, lineEnclosed);
	auto expect28 = "Test case: Outside Enclosing Enclosed\nSolution: 1\n0: 2 5 3 1 0 -0 1 3\n  Outside Enclosing Enclosed\n";
	CHECK(case28.find(expect28) != std::string::npos);
	auto case29 = c3t(circle1Outside, circle2Enclosing, lineOutside);
	auto expect29 = "Test case: Outside Enclosing Outside\nSolution: 0\n";
	CHECK(case29.find(expect29) != std::string::npos);
	auto case30 = c3t(circle1Outside, circle2Enclosing, lineUnqualified);
	auto expect30 = "Test case: Outside Enclosing Unqualified\nSolution: 1\n0: 2 5 3 1 0 -0 1 3\n  Outside Enclosing Enclosed\n";
	CHECK(case30.find(expect30) != std::string::npos);
	auto case31 = c3t(circle1Outside, circle2Outside, lineEnclosed);
	auto expect31 = "Test case: Outside Outside Enclosed\nSolution: 1\n0: 2 2 0.9 1 0 -0 1 0.9\n  Outside Outside Enclosed\n";
	CHECK(case31.find(expect31) != std::string::npos);
	auto case32 = c3t(circle1Outside, circle2Outside, lineOutside);
	auto expect32 = "Test case: Outside Outside Outside\nSolution: 0\n";
	CHECK(case32.find(expect32) != std::string::npos);
	auto case33 = c3t(circle1Outside, circle2Outside, lineUnqualified);
	auto expect33 = "Test case: Outside Outside Unqualified\nSolution: 1\n0: 2 2 0.9 1 0 -0 1 0.9\n  Outside Outside Enclosed\n";
	CHECK(case33.find(expect33) != std::string::npos);
	auto case34 = c3t(circle1Outside, circle2Unqualified, lineEnclosed);
	auto expect34 = "Test case: Outside Unqualified Enclosed\nSolution: 2\n0: 2 2 0.9 1 0 -0 1 0.9\n  Outside Outside Enclosed\n1: 2 5 3 1 0 -0 1 3\n  Outside Enclosing Enclosed\n";
	CHECK(case34.find(expect34) != std::string::npos);
	auto case35 = c3t(circle1Outside, circle2Unqualified, lineOutside);
	auto expect35 = "Test case: Outside Unqualified Outside\nSolution: 0\n";
	CHECK(case35.find(expect35) != std::string::npos);
	auto case36 = c3t(circle1Outside, circle2Unqualified, lineUnqualified);
	auto expect36 = "Test case: Outside Unqualified Unqualified\nSolution: 2\n0: 2 2 0.9 1 0 -0 1 0.9\n  Outside Outside Enclosed\n1: 2 5 3 1 0 -0 1 3\n  Outside Enclosing Enclosed\n";
	CHECK(case36.find(expect36) != std::string::npos);
	auto case37 = c3t(circle1Unqualified, circle2Enclosed, lineEnclosed);
	auto expect37 = "Test case: Unqualified Enclosed Enclosed\nSolution: 0\n";
	CHECK(case37.find(expect37) != std::string::npos);
	auto case38 = c3t(circle1Unqualified, circle2Enclosed, lineOutside);
	auto expect38 = "Test case: Unqualified Enclosed Outside\nSolution: 0\n";
	CHECK(case38.find(expect38) != std::string::npos);
	auto case39 = c3t(circle1Unqualified, circle2Enclosed, lineUnqualified);
	auto expect39 = "Test case: Unqualified Enclosed Unqualified\nSolution: 0\n";
	CHECK(case39.find(expect39) != std::string::npos);
	auto case40 = c3t(circle1Unqualified, circle2Enclosing, lineEnclosed);
	auto expect40 = "Test case: Unqualified Enclosing Enclosed\nSolution: 2\n0: 2 5 3 1 0 -0 1 3\n  Outside Enclosing Enclosed\n1: 2 2 4.5 1 0 -0 1 4.5\n  Enclosing Enclosing Enclosed\n";
	CHECK(case40.find(expect40) != std::string::npos);
	auto case41 = c3t(circle1Unqualified, circle2Enclosing, lineOutside);
	auto expect41 = "Test case: Unqualified Enclosing Outside\nSolution: 0\n";
	CHECK(case41.find(expect41) != std::string::npos);
	auto case42 = c3t(circle1Unqualified, circle2Enclosing, lineUnqualified);
	auto expect42 = "Test case: Unqualified Enclosing Unqualified\nSolution: 2\n0: 2 5 3 1 0 -0 1 3\n  Outside Enclosing Enclosed\n1: 2 2 4.5 1 0 -0 1 4.5\n  Enclosing Enclosing Enclosed\n";
	CHECK(case42.find(expect42) != std::string::npos);
	auto case43 = c3t(circle1Unqualified, circle2Outside, lineEnclosed);
	auto expect43 = "Test case: Unqualified Outside Enclosed\nSolution: 2\n0: 2 2 0.9 1 0 -0 1 0.9\n  Outside Outside Enclosed\n1: 2 -1 3 1 0 -0 1 3\n  Enclosing Outside Enclosed\n";
	CHECK(case43.find(expect43) != std::string::npos);
	auto case44 = c3t(circle1Unqualified, circle2Outside, lineOutside);
	auto expect44 = "Test case: Unqualified Outside Outside\nSolution: 0\n";
	CHECK(case44.find(expect44) != std::string::npos);
	auto case45 = c3t(circle1Unqualified, circle2Outside, lineUnqualified);
	auto expect45 = "Test case: Unqualified Outside Unqualified\nSolution: 2\n0: 2 2 0.9 1 0 -0 1 0.9\n  Outside Outside Enclosed\n1: 2 -1 3 1 0 -0 1 3\n  Enclosing Outside Enclosed\n";
	CHECK(case45.find(expect45) != std::string::npos);
	auto case46 = c3t(circle1Unqualified, circle2Unqualified, lineEnclosed);
	auto expect46 = "Test case: Unqualified Unqualified Enclosed\nSolution: 4\n0: 2 2 0.9 1 0 -0 1 0.9\n  Outside Outside Enclosed\n1: 2 5 3 1 0 -0 1 3\n  Outside Enclosing Enclosed\n2: 2 -1 3 1 0 -0 1 3\n  Enclosing Outside Enclosed\n3: 2 2 4.5 1 0 -0 1 4.5\n  Enclosing Enclosing Enclosed\n";
	CHECK(case46.find(expect46) != std::string::npos);
	auto case47 = c3t(circle1Unqualified, circle2Unqualified, lineOutside);
	auto expect47 = "Test case: Unqualified Unqualified Outside\nSolution: 0\n";
	CHECK(case47.find(expect47) != std::string::npos);
	auto case48 = c3t(circle1Unqualified, circle2Unqualified, lineUnqualified);
	auto expect48 = "Test case: Unqualified Unqualified Unqualified\nSolution: 4\n0: 2 2 0.9 1 0 -0 1 0.9\n  Outside Outside Enclosed\n1: 2 5 3 1 0 -0 1 3\n  Outside Enclosing Enclosed\n2: 2 -1 3 1 0 -0 1 3\n  Enclosing Outside Enclosed\n3: 2 2 4.5 1 0 -0 1 4.5\n  Enclosing Enclosing Enclosed";
	CHECK(case48.find(expect48) != std::string::npos);
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API GccCircle3Tangent(const Point2& point1, const Point2& point2, const Point2& point3, double tolerance)	 @param tolerance The tolerance
	 @param point3 The third point
	 @param point2 The second point
	 @param point1 The first point
	 @brief Construct a circle passing through three points
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <geomAlgo/GccCircle3Tangent.hpp>
#include <geometry/Geom2Curve.hpp>
#include <geometry/MakeGeom2Line.hpp>
#include <geometry/MakeGeom2Circle.hpp>
#include <geomAlgo/GccEntity.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geomAlgo/GccEntity.hpp>
#include <geomAlgo/GccQualifiedCurve.hpp>
#include <sstream>
using namespace AMCAX;
TEST_CASE("bug1: GccCircle3Tangent  add 48 cases", "[geomAlgo][GccCircle3Tangent][fixbug]") {
	std::shared_ptr<Geom2Curve> l = MakeGeom2Line(Point2(0.0, 0.0), Point2(1.0, 0.0)).Value();
	std::shared_ptr<Geom2Curve> c1 = MakeGeom2Circle(Point2(0.0, 3.0), 2.0).Value();
	std::shared_ptr<Geom2Curve> c2 = MakeGeom2Circle(Point2(4.0, 3.0), 2.0).Value();
	AdaptorGeom2Curve line(l);
	AdaptorGeom2Curve circle1(c1);
	AdaptorGeom2Curve circle2(c2);
	auto lineEnclosed = GccEntity::Enclosed(line);
	auto lineOutside = GccEntity::Outside(line);
	auto lineUnqualified = GccEntity::Unqualified(line);
	auto circle1Enclosed = GccEntity::Enclosed(circle1);
	auto circle1Enclosing = GccEntity::Enclosing(circle1);
	auto circle1Outside = GccEntity::Outside(circle1);
	auto circle1Unqualified = GccEntity::Unqualified(circle1);
	auto circle2Enclosed = GccEntity::Enclosed(circle2);
	auto circle2Enclosing = GccEntity::Enclosing(circle2);
	auto circle2Outside = GccEntity::Outside(circle2);
	auto circle2Unqualified = GccEntity::Unqualified(circle2);
	auto gccl = GccEntity::Enclosed(AdaptorGeom2Curve(l));
	auto gccc1 = GccEntity::Enclosing(AdaptorGeom2Curve(c1));
	auto gccc2 = GccEntity::Outside(AdaptorGeom2Curve(c2));
	auto c3t = [](const GccQualifiedCurve& gccc1, const GccQualifiedCurve& gccc2, const GccQualifiedCurve& gccl)
	{
		std::stringstream output;
		GccCircle3Tangent gcc(gccc1, gccc2, gccl, Precision::Confusion(), 0.0, 0.0, 0.0);
		std::cout << "Test case: " << GccEntity::PositionToString(gccc1.Qualifier()) << ' ' << GccEntity::PositionToString(gccc2.Qualifier()) << ' ' << GccEntity::PositionToString(gccl.Qualifier()) << std::endl;
		std::cout << "Solution: " << gcc.NSolutions() << std::endl;
		output << "Test case: " << GccEntity::PositionToString(gccc1.Qualifier()) << ' ' << GccEntity::PositionToString(gccc2.Qualifier()) << ' ' << GccEntity::PositionToString(gccl.Qualifier()) << std::endl;
		output << "Solution: " << gcc.NSolutions() << std::endl;
		if (gcc.IsDone())
		{
			for (int i = 0; i < gcc.NSolutions(); i++)
			{
				GccPosition q1, q2, q3;
				gcc.Qualifier(i, q1, q2, q3);
				output << i << ": " << *MakeGeom2Circle(gcc.Solution(i)).Value() << std::endl;
				output << "  " << GccEntity::PositionToString(q1) << ' ' << GccEntity::PositionToString(q2) << ' ' << GccEntity::PositionToString(q3) << std::endl;
			}
		}
		else
		{
			std::cout << "gcc.IsDone is False" << std::endl;
			output << "gcc.IsDone is False" << std::endl;
		}
		return output.str();
	};
	auto case1 = c3t(circle1Enclosed, circle2Enclosed, lineEnclosed);
	auto expect1 = "Test case: Enclosed Enclosed Enclosed\nSolution: 0\n";
	CHECK(case1.find(expect1) != std::string::npos);
	auto case2 = c3t(circle1Enclosed, circle2Enclosed, lineOutside);
	auto expect2 = "Test case: Enclosed Enclosed Outside\nSolution: 0\n";
	CHECK(case2.find(expect2) != std::string::npos);
	auto case3 = c3t(circle1Enclosed, circle2Enclosed, lineUnqualified);
	auto expect3 = "Test case: Enclosed Enclosed Unqualified\nSolution: 0\n";
	CHECK(case3.find(expect3) != std::string::npos);
	auto case4 = c3t(circle1Enclosed, circle2Enclosing, lineEnclosed);
	auto expect4 = "Test case: Enclosed Enclosing Enclosed\nSolution: 0\n";
	CHECK(case4.find(expect4) != std::string::npos);
	auto case5 = c3t(circle1Enclosed, circle2Enclosing, lineOutside);
	auto expect5 = "Test case: Enclosed Enclosing Outside\nSolution: 0\n";
	CHECK(case5.find(expect5) != std::string::npos);
	auto case6 = c3t(circle1Enclosed, circle2Enclosing, lineUnqualified);
	auto expect6 = "Test case: Enclosed Enclosing Unqualified\nSolution: 0\n";
	CHECK(case6.find(expect6) != std::string::npos);
	auto case7 = c3t(circle1Enclosed, circle2Outside, lineEnclosed);
	auto expect7 = "Test case: Enclosed Outside Enclosed\nSolution: 0\n";
	CHECK(case7.find(expect7) != std::string::npos);
	auto case8 = c3t(circle1Enclosed, circle2Outside, lineOutside);
	auto expect8 = "Test case: Enclosed Outside Outside\nSolution: 0\n";
	CHECK(case8.find(expect8) != std::string::npos);
	auto case9 = c3t(circle1Enclosed, circle2Outside, lineUnqualified);
	auto expect9 = "Test case: Enclosed Outside Unqualified\nSolution: 0\n";
	CHECK(case9.find(expect9) != std::string::npos);
	auto case10 = c3t(circle1Enclosed, circle2Unqualified, lineEnclosed);
	auto expect10 = "Test case: Enclosed Unqualified Enclosed\nSolution: 0\n";
	CHECK(case10.find(expect10) != std::string::npos);
	auto case11 = c3t(circle1Enclosed, circle2Unqualified, lineOutside);
	auto expect11 = "Test case: Enclosed Unqualified Outside\nSolution: 0\n";
	CHECK(case11.find(expect11) != std::string::npos);
	auto case12 = c3t(circle1Enclosed, circle2Unqualified, lineUnqualified);
	auto expect12 = "Test case: Enclosed Unqualified Unqualified\nSolution: 0\n";
	CHECK(case12.find(expect12) != std::string::npos);
	auto case13 = c3t(circle1Enclosing, circle2Enclosed, lineEnclosed);
	auto expect13 = "Test case: Enclosing Enclosed Enclosed\nSolution: 0\n";
	CHECK(case13.find(expect13) != std::string::npos);
	auto case14 = c3t(circle1Enclosing, circle2Enclosed, lineOutside);
	auto expect14 = "Test case: Enclosing Enclosed Outside\nSolution: 0\n";
	CHECK(case14.find(expect14) != std::string::npos);
	auto case15 = c3t(circle1Enclosing, circle2Enclosed, lineUnqualified);
	auto expect15 = "Test case: Enclosing Enclosed Unqualified\nSolution: 0\n";
	CHECK(case15.find(expect15) != std::string::npos);
	auto case16 = c3t(circle1Enclosing, circle2Enclosing, lineEnclosed);
	auto expect16 = "Test case: Enclosing Enclosing Enclosed\nSolution: 1\n0: 2 2 4.5 1 0 -0 1 4.5\n  Enclosing Enclosing Enclosed\n";
	CHECK(case16.find(expect16) != std::string::npos);
	auto case17 = c3t(circle1Enclosing, circle2Enclosing, lineOutside);
	auto expect17 = "Test case: Enclosing Enclosing Outside\nSolution: 0\n";
	CHECK(case17.find(expect17) != std::string::npos);
	auto case18 = c3t(circle1Enclosing, circle2Enclosing, lineUnqualified);
	auto expect18 = "Test case: Enclosing Enclosing Unqualified\nSolution: 1\n0: 2 2 4.5 1 0 -0 1 4.5\n  Enclosing Enclosing Enclosed\n";
	CHECK(case18.find(expect18) != std::string::npos);
	auto case19 = c3t(circle1Enclosing, circle2Outside, lineEnclosed);
	auto expect19 = "Test case: Enclosing Outside Enclosed\nSolution: 1\n0: 2 -1 3 1 0 -0 1 3\n  Enclosing Outside Enclosed\n";
	CHECK(case19.find(expect19) != std::string::npos);
	auto case20 = c3t(circle1Enclosing, circle2Outside, lineOutside);
	auto expect20 = "Test case: Enclosing Outside Outside\nSolution: 0\n";
	CHECK(case20.find(expect20) != std::string::npos);
	auto case21 = c3t(circle1Enclosing, circle2Outside, lineUnqualified);
	auto expect21 = "Test case: Enclosing Outside Unqualified\nSolution: 1\n0: 2 -1 3 1 0 -0 1 3\n  Enclosing Outside Enclosed\n";
	CHECK(case21.find(expect21) != std::string::npos);
	auto case22 = c3t(circle1Enclosing, circle2Unqualified, lineEnclosed);
	auto expect22 = "Test case: Enclosing Unqualified Enclosed\nSolution: 2\n0: 2 -1 3 1 0 -0 1 3\n  Enclosing Outside Enclosed\n1: 2 2 4.5 1 0 -0 1 4.5\n  Enclosing Enclosing Enclosed\n";
	CHECK(case22.find(expect22) != std::string::npos);
	auto case23 = c3t(circle1Enclosing, circle2Unqualified, lineOutside);
	auto expect23 = "Test case: Enclosing Unqualified Outside\nSolution: 0\n";
	CHECK(case23.find(expect23) != std::string::npos);
	auto case24 = c3t(circle1Enclosing, circle2Unqualified, lineUnqualified);
	auto expect24 = "Test case: Enclosing Unqualified Unqualified\nSolution: 2\n0: 2 -1 3 1 0 -0 1 3\n  Enclosing Outside Enclosed\n1: 2 2 4.5 1 0 -0 1 4.5\n  Enclosing Enclosing Enclosed\n";
	CHECK(case24.find(expect24) != std::string::npos);
	auto case25 = c3t(circle1Outside, circle2Enclosed, lineEnclosed);
	auto expect25 = "Test case: Outside Enclosed Enclosed\nSolution: 0\n";
	CHECK(case25.find(expect25) != std::string::npos);
	auto case26 = c3t(circle1Outside, circle2Enclosed, lineOutside);
	auto expect26 = "Test case: Outside Enclosed Outside\nSolution: 0\n";
	CHECK(case26.find(expect26) != std::string::npos);
	auto case27 = c3t(circle1Outside, circle2Enclosed, lineUnqualified);
	auto expect27 = "Test case: Outside Enclosed Unqualified\nSolution: 0\n";
	CHECK(case27.find(expect27) != std::string::npos);
	auto case28 = c3t(circle1Outside, circle2Enclosing, lineEnclosed);
	auto expect28 = "Test case: Outside Enclosing Enclosed\nSolution: 1\n0: 2 5 3 1 0 -0 1 3\n  Outside Enclosing Enclosed\n";
	CHECK(case28.find(expect28) != std::string::npos);
	auto case29 = c3t(circle1Outside, circle2Enclosing, lineOutside);
	auto expect29 = "Test case: Outside Enclosing Outside\nSolution: 0\n";
	CHECK(case29.find(expect29) != std::string::npos);
	auto case30 = c3t(circle1Outside, circle2Enclosing, lineUnqualified);
	auto expect30 = "Test case: Outside Enclosing Unqualified\nSolution: 1\n0: 2 5 3 1 0 -0 1 3\n  Outside Enclosing Enclosed\n";
	CHECK(case30.find(expect30) != std::string::npos);
	auto case31 = c3t(circle1Outside, circle2Outside, lineEnclosed);
	auto expect31 = "Test case: Outside Outside Enclosed\nSolution: 1\n0: 2 2 0.9 1 0 -0 1 0.9\n  Outside Outside Enclosed\n";
	CHECK(case31.find(expect31) != std::string::npos);
	auto case32 = c3t(circle1Outside, circle2Outside, lineOutside);
	auto expect32 = "Test case: Outside Outside Outside\nSolution: 0\n";
	CHECK(case32.find(expect32) != std::string::npos);
	auto case33 = c3t(circle1Outside, circle2Outside, lineUnqualified);
	auto expect33 = "Test case: Outside Outside Unqualified\nSolution: 1\n0: 2 2 0.9 1 0 -0 1 0.9\n  Outside Outside Enclosed\n";
	CHECK(case33.find(expect33) != std::string::npos);
	auto case34 = c3t(circle1Outside, circle2Unqualified, lineEnclosed);
	auto expect34 = "Test case: Outside Unqualified Enclosed\nSolution: 2\n0: 2 2 0.9 1 0 -0 1 0.9\n  Outside Outside Enclosed\n1: 2 5 3 1 0 -0 1 3\n  Outside Enclosing Enclosed\n";
	CHECK(case34.find(expect34) != std::string::npos);
	auto case35 = c3t(circle1Outside, circle2Unqualified, lineOutside);
	auto expect35 = "Test case: Outside Unqualified Outside\nSolution: 0\n";
	CHECK(case35.find(expect35) != std::string::npos);
	auto case36 = c3t(circle1Outside, circle2Unqualified, lineUnqualified);
	auto expect36 = "Test case: Outside Unqualified Unqualified\nSolution: 2\n0: 2 2 0.9 1 0 -0 1 0.9\n  Outside Outside Enclosed\n1: 2 5 3 1 0 -0 1 3\n  Outside Enclosing Enclosed\n";
	CHECK(case36.find(expect36) != std::string::npos);
	auto case37 = c3t(circle1Unqualified, circle2Enclosed, lineEnclosed);
	auto expect37 = "Test case: Unqualified Enclosed Enclosed\nSolution: 0\n";
	CHECK(case37.find(expect37) != std::string::npos);
	auto case38 = c3t(circle1Unqualified, circle2Enclosed, lineOutside);
	auto expect38 = "Test case: Unqualified Enclosed Outside\nSolution: 0\n";
	CHECK(case38.find(expect38) != std::string::npos);
	auto case39 = c3t(circle1Unqualified, circle2Enclosed, lineUnqualified);
	auto expect39 = "Test case: Unqualified Enclosed Unqualified\nSolution: 0\n";
	CHECK(case39.find(expect39) != std::string::npos);
	auto case40 = c3t(circle1Unqualified, circle2Enclosing, lineEnclosed);
	auto expect40 = "Test case: Unqualified Enclosing Enclosed\nSolution: 2\n0: 2 5 3 1 0 -0 1 3\n  Outside Enclosing Enclosed\n1: 2 2 4.5 1 0 -0 1 4.5\n  Enclosing Enclosing Enclosed\n";
	CHECK(case40.find(expect40) != std::string::npos);
	auto case41 = c3t(circle1Unqualified, circle2Enclosing, lineOutside);
	auto expect41 = "Test case: Unqualified Enclosing Outside\nSolution: 0\n";
	CHECK(case41.find(expect41) != std::string::npos);
	auto case42 = c3t(circle1Unqualified, circle2Enclosing, lineUnqualified);
	auto expect42 = "Test case: Unqualified Enclosing Unqualified\nSolution: 2\n0: 2 5 3 1 0 -0 1 3\n  Outside Enclosing Enclosed\n1: 2 2 4.5 1 0 -0 1 4.5\n  Enclosing Enclosing Enclosed\n";
	CHECK(case42.find(expect42) != std::string::npos);
	auto case43 = c3t(circle1Unqualified, circle2Outside, lineEnclosed);
	auto expect43 = "Test case: Unqualified Outside Enclosed\nSolution: 2\n0: 2 2 0.9 1 0 -0 1 0.9\n  Outside Outside Enclosed\n1: 2 -1 3 1 0 -0 1 3\n  Enclosing Outside Enclosed\n";
	CHECK(case43.find(expect43) != std::string::npos);
	auto case44 = c3t(circle1Unqualified, circle2Outside, lineOutside);
	auto expect44 = "Test case: Unqualified Outside Outside\nSolution: 0\n";
	CHECK(case44.find(expect44) != std::string::npos);
	auto case45 = c3t(circle1Unqualified, circle2Outside, lineUnqualified);
	auto expect45 = "Test case: Unqualified Outside Unqualified\nSolution: 2\n0: 2 2 0.9 1 0 -0 1 0.9\n  Outside Outside Enclosed\n1: 2 -1 3 1 0 -0 1 3\n  Enclosing Outside Enclosed\n";
	CHECK(case45.find(expect45) != std::string::npos);
	auto case46 = c3t(circle1Unqualified, circle2Unqualified, lineEnclosed);
	auto expect46 = "Test case: Unqualified Unqualified Enclosed\nSolution: 4\n0: 2 2 0.9 1 0 -0 1 0.9\n  Outside Outside Enclosed\n1: 2 5 3 1 0 -0 1 3\n  Outside Enclosing Enclosed\n2: 2 -1 3 1 0 -0 1 3\n  Enclosing Outside Enclosed\n3: 2 2 4.5 1 0 -0 1 4.5\n  Enclosing Enclosing Enclosed\n";
	CHECK(case46.find(expect46) != std::string::npos);
	auto case47 = c3t(circle1Unqualified, circle2Unqualified, lineOutside);
	auto expect47 = "Test case: Unqualified Unqualified Outside\nSolution: 0\n";
	CHECK(case47.find(expect47) != std::string::npos);
	auto case48 = c3t(circle1Unqualified, circle2Unqualified, lineUnqualified);
	auto expect48 = "Test case: Unqualified Unqualified Unqualified\nSolution: 4\n0: 2 2 0.9 1 0 -0 1 0.9\n  Outside Outside Enclosed\n1: 2 5 3 1 0 -0 1 3\n  Outside Enclosing Enclosed\n2: 2 -1 3 1 0 -0 1 3\n  Enclosing Outside Enclosed\n3: 2 2 4.5 1 0 -0 1 4.5\n  Enclosing Enclosing Enclosed";
	CHECK(case48.find(expect48) != std::string::npos);
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API virtual int NIntervals(ContinuityType s)	 @return The number of intervals
	 @param s The given continuity
	 @brief Get the number of intervals divided by parameters at which the curve continuity is lower than the given continuity
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include<geomAlgo/LawConstant.hpp>
#include<geomAlgo/LawFunction.hpp>
using namespace std;
#include<catch.hpp>
#include<testHelper.h>
#include<geomAlgo/LawConstant.hpp>
#include<geomAlgo/LawFunction.hpp>
using namespace std;;
	SECTION("NIntervals")
	{
		int num1 = cons.NIntervals(ContinuityType::C0);
		int num2 = cons.NIntervals(ContinuityType::G1);
		int num3 = cons.NIntervals(ContinuityType::C1);
		int num4 = cons.NIntervals(ContinuityType::G2);
		int num5 = cons.NIntervals(ContinuityType::C2);
		int num6 = cons.NIntervals(ContinuityType::C3);
		int num7 = cons.NIntervals(ContinuityType::CN);
		CHECK(num1 == 1);
		CHECK(num2 == 1);
		CHECK(num3 == 1);
		CHECK(num4 == 1);
		CHECK(num5 == 1);
		CHECK(num6 == 1);
		CHECK(num7 == 1);
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API virtual void Intervals(std::vector<double>& t, ContinuityType s)	 @param[in] s The given continuity
	 @param[out] t The array to store the parameters
	 @brief Get the bounding parameters of the intervals of the given continuity
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include<geomAlgo/LawConstant.hpp>
#include<geomAlgo/LawFunction.hpp>
using namespace std;
#include<catch.hpp>
#include<testHelper.h>
#include<geomAlgo/LawConstant.hpp>
#include<geomAlgo/LawFunction.hpp>
using namespace std;;
	SECTION("NIntervals")
	{
		int num1 = cons.NIntervals(ContinuityType::C0);
		int num2 = cons.NIntervals(ContinuityType::G1);
		int num3 = cons.NIntervals(ContinuityType::C1);
		int num4 = cons.NIntervals(ContinuityType::G2);
		int num5 = cons.NIntervals(ContinuityType::C2);
		int num6 = cons.NIntervals(ContinuityType::C3);
		int num7 = cons.NIntervals(ContinuityType::CN);
		CHECK(num1 == 1);
		CHECK(num2 == 1);
		CHECK(num3 == 1);
		CHECK(num4 == 1);
		CHECK(num5 == 1);
		CHECK(num6 == 1);
		CHECK(num7 == 1);
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API virtual double Value(double x)	 @return The function value
	 @param x The given parameter
	 @brief Get the function value at the given parameter
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include<geomAlgo/LawConstant.hpp>
#include<geomAlgo/LawFunction.hpp>
using namespace std;
#include<catch.hpp>
#include<testHelper.h>
#include<geomAlgo/LawConstant.hpp>
#include<geomAlgo/LawFunction.hpp>
using namespace std;;
	SECTION("Value")
	{
		double value = cons.Value(1.0);
		CHECK(value == Approx(2.0));
		double value1 = cons.Value(15.0);
		CHECK(value1 == Approx(2.0));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API virtual void D1(double x, double& f, double& d)	 @param[out] d The function first derivative
	 @param[out] f The function value
	 @param[in] x The given parameter
	 @brief Get the function first derivative at the given parameter
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include<geomAlgo/LawConstant.hpp>
#include<geomAlgo/LawFunction.hpp>
using namespace std;
#include<catch.hpp>
#include<testHelper.h>
#include<geomAlgo/LawConstant.hpp>
#include<geomAlgo/LawFunction.hpp>
using namespace std;;
	SECTION("D1")
	{
		double x = 1.0;
		double f = 0.0; 
		double d = 0.0;
		cons.D1(x, f, d);
		CHECK(f == Approx(2.0));
		CHECK(d == Approx(0.0));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API virtual void D2(double x, double& f, double& d, double& d2)	 @param[out] d2 The function second derivative
	 @param[out] d The function first derivative
	 @param[out] f The function value
	 @param[in] x The given parameter
	 @brief Get the function second derivative at the given parameter
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include<geomAlgo/LawConstant.hpp>
#include<geomAlgo/LawFunction.hpp>
using namespace std;
#include<catch.hpp>
#include<testHelper.h>
#include<geomAlgo/LawConstant.hpp>
#include<geomAlgo/LawFunction.hpp>
using namespace std;;
	SECTION("D2")
	{
		double x = 1.0;
		double f, d, d2;
		cons.D2(x, f, d, d2);
		CHECK(f == Approx(2.0));
		CHECK(d == Approx(0.0));
		CHECK(d2 == Approx(0.0));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API virtual std::shared_ptr<LawFunction> Trim(double fp, double lp, double tol)	 @return The new law
	 @param tol The given tolerance, not all laws use this parameter
	 @param lp The second parameter
	 @param fp The first parameter
	 @brief Get the trimmed law of this
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include<geomAlgo/LawConstant.hpp>
#include<geomAlgo/LawFunction.hpp>
using namespace std;
#include<catch.hpp>
#include<testHelper.h>
#include<geomAlgo/LawConstant.hpp>
#include<geomAlgo/LawFunction.hpp>
using namespace std;;
	SECTION("Trim")
	{
		shared_ptr<LawFunction>tr;
		double fp = 1.0;
		double lp = 5.0;
		double tol = 0.1;
		double fp1 = 0.0;
		double lp1 = 0.0;
		tr = cons.Trim(fp, lp, tol);
		tr->Bounds(fp1, lp1);
		CHECK(fp1 == fp);
		CHECK(lp1 == lp);
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API virtual void Bounds(double& fp, double& lp)	 @param[out] lp The second parameter
	 @param[out] fp The first parameter
	 @brief Get the parametric bounds
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include<geomAlgo/LawConstant.hpp>
#include<geomAlgo/LawFunction.hpp>
using namespace std;
#include<catch.hpp>
#include<testHelper.h>
#include<geomAlgo/LawConstant.hpp>
#include<geomAlgo/LawFunction.hpp>
using namespace std;;
	SECTION("Default")
	{
		LawConstant cons1;
		double fp = 0.0;
		double lp = 0.0;
		cons1.Bounds(fp, lp);
		CHECK(cons1.Value(1.0) == Approx(0.0));
		CHECK(fp == Approx(0.0));
		CHECK(lp == Approx(0.0));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":Conic2Constraint(const Point2& point, const Vector2& tangent)	 @param tangent The tangent vector constraint
	 @param point The point constraint
	 @brief Construct from point and tangent constraints
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <geomAlgo/MakeConic2FromConstraints.hpp>
#include <geometry/GeometryTool.hpp>
#include <math/HyperbolaT.hpp>
#include <geometry/Geom2Hyperbola.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <modeling/MakeEdge.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/Geom2Circle.hpp>
#include <geometry/GeomAPIProjectPointOnCurve3.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeEdge.hpp>
TEST_CASE("bug2: MakeConic2FromConstraints ", "[geomAlgo][MakeConic2FromConstraints][fixbug]")
{
	OUTPUT_DIRECTORY(nurbs, Constraints/bug496);
	Point2 a(0.0, 0.0);
	Point2 b(1.0, 1.0);
	Vector2 da(-0.5, 0.5);
	Vector2 db(1.0, -0.2);
	Point3 a1(a.X(), a.Y(), 0.0);
	Point3 b1(b.X(), b.Y(), 0.0);
	Vector3 da1(da.X(), da.Y(), 0.0);
	Vector3 db1(db.X(), db.Y(), 0.0);
	Conic2Constraint ca(a, da);
	Conic2Constraint cb(b, db);
	double parameter = 0.05 * 4;
	MakeConic2FromConstraints mc2fc(ca, cb, parameter);
	const auto& coefficients = mc2fc.Coefficients();
	shared_ptr<Geom3Curve> curve;
	curve = GeometryTool::To3d(Frame3(), mc2fc.Curve2d());
	double tol = -1.0;
	TopoEdge edge = MakeEdge(curve);
	bool res2 = BRepClassificationTools::IsPointInOnEdge(edge, b1, tol);
	CHECK(res2 == true);
	OCCTIO::OCCTTool::Write(MakeEdge(curve), outdir + "curve.brep");
	OCCTIO::OCCTTool::Write(MakeVertex(a1), outdir + "a1.brep");
	OCCTIO::OCCTTool::Write(MakeVertex(b1), outdir + "b1.brep");
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API MakeConic2FromConstraints(const Conic2Constraint& startConstraint, const Conic2Constraint& endConstraint, double parameter)	 @param parameter The parameter to determine type and shape of the conic, valid range is (0.0, 1.0): ellipse if (0.0, 0.5), parabola if {0.5}, hyperbola if (0.5, 1.0)
	 @param endConstraint The end point and tangent
	 @param startConstraint The start point and tangent
	 @brief Build by ending points and tangents and a parameter
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <geomAlgo/MakeConic2FromConstraints.hpp>
#include <geometry/GeometryTool.hpp>
#include <math/HyperbolaT.hpp>
#include <geometry/Geom2Hyperbola.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <modeling/MakeEdge.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/Geom2Circle.hpp>
#include <geometry/GeomAPIProjectPointOnCurve3.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeEdge.hpp>
TEST_CASE("bug1: MakeConic2FromConstraints ", "[geomAlgo][MakeConic2FromConstraints][fixbug]")
{
	Point2 a(0.0, 0.0);
	Point2 b(1.0, 1.0);
	Vector2 da(-0.5, 0.5);
	Vector2 db(1.0, -0.2);
	Point3 a1(a.X(), a.Y(), 0.0);
	Point3 b1(b.X(), b.Y(), 0.0);
	Vector3 da1(da.X(), da.Y(), 0.0);
	Vector3 db1(db.X(), db.Y(), 0.0);
	Conic2Constraint ca(a, da);
	Conic2Constraint cb(b, db);
	MakeConic2FromConstraints mc2fc(ca, cb, 0.0);
	shared_ptr<Geom3Curve> curve;
	curve = GeometryTool::To3d(Frame3(), mc2fc.Curve2d());
	CHECK(mc2fc.Curve2d() == nullptr);
	CHECK(curve == nullptr);
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API explicit MakeConic2FromConstraints(const std::vector<Conic2Constraint>& constraints)	 @param constraints The constraints of the conic. It is supported that the constraints contain 5 points, 4 points and 1 tangent, 3 points and 2 tangent
	 @brief Build by point and tangent constraints. The number of constraints must be 5 in total and the start and the end point constraints are required
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <geomAlgo/MakeConic2FromConstraints.hpp>
#include <geometry/GeometryTool.hpp>
#include <math/HyperbolaT.hpp>
#include <geometry/Geom2Hyperbola.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <modeling/MakeEdge.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/Geom2Circle.hpp>
#include <geometry/GeomAPIProjectPointOnCurve3.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeEdge.hpp>
#include<catch.hpp>
#include<testHelper.h>
#include <geomAlgo/MakeConic2FromConstraints.hpp>
#include <geometry/GeometryTool.hpp>
#include <math/HyperbolaT.hpp>
#include <geometry/Geom2Hyperbola.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <modeling/MakeEdge.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/Geom2Circle.hpp>
#include <geometry/GeomAPIProjectPointOnCurve3.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeEdge.hpp>
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API ComputePointsAbscissa(double tol, const Adaptor3Curve& c, double abscissa, double u0)	 @param u0 The starting parameter
	 @param abscissa The arc length
	 @param c The curve
	 @param tol The tolerance
	 @brief Compute the parameter of a point on a 3D curve with given arc length and a tolerance
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <geometry/MakeGeom2Circle.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/ComputePointsAbscissa.hpp>
#include <geometry/MakeGeom3Circle.hpp>
#include <geometry/AdaptorGeom3Curve.hpp>
#include <geometry/MakeGeom2Hyperbola.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/MakeGeom2Ellipse.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <geometry/MakeGeom3Ellipse.hpp>
#include <geometry/MakeGeom3Hyperbola.hpp>
#include <geometry/Geom2Line.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom3Line.hpp>
#include <geometry/Geom3TrimmedCurve.hpp>
#include<modeling/MakeEdge.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/GeometryTool.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <geometry/MakeGeom2Parabola.hpp>
#include <geometry/MakeGeom3Parabola.hpp>
#include <geometry/Geom2BezierCurve.hpp>
#include <geometry/Geom3BezierCurve.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/Geom2OffsetCurve.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
#include<catch.hpp>
#include<testHelper.h>
#include <geometry/MakeGeom2Circle.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/ComputePointsAbscissa.hpp>
#include <geometry/MakeGeom3Circle.hpp>
#include <geometry/AdaptorGeom3Curve.hpp>
#include <geometry/MakeGeom2Hyperbola.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/MakeGeom2Ellipse.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <geometry/MakeGeom3Ellipse.hpp>
#include <geometry/MakeGeom3Hyperbola.hpp>
#include <geometry/Geom2Line.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom3Line.hpp>
#include <geometry/Geom3TrimmedCurve.hpp>
#include<modeling/MakeEdge.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/GeometryTool.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <geometry/MakeGeom2Parabola.hpp>
#include <geometry/MakeGeom3Parabola.hpp>
#include <geometry/Geom2BezierCurve.hpp>
#include <geometry/Geom3BezierCurve.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/Geom2OffsetCurve.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
;
	SECTION("circle")
    {
        double r = 2.0;
        double l = 1.0;
        std::shared_ptr<Geom2Curve> c = MakeGeom2Circle(Point2(0.0, 0.0), 2.0).Value();
        AdaptorGeom2Curve circle(c);
        ComputePointsAbscissa cpa(circle, 1.0, 0.0);
        double angle1 = l / r;
        std::cout << "" << ": " << angle1 << '\n';
        double x = r * cos(angle1);
        double y = r * sin(angle1);
        std::cout << "x" << ": " << x << '\n';
        std::cout << "y" << ": " << y << '\n';
        double param = cpa.Parameter();
        if (cpa.IsDone())
        {
            std::cout << param << ": " << circle.Value(param) << '\n';
        }
        double p = 2 * M_PI * r;
        std::cout << "" << ComputePointsAbscissa::Length(circle) << '\n';
        Point2 s = circle.Value(param);
        Point2 s1(x, y);
        std::cout << s << std::endl;
        CHECK(p == ComputePointsAbscissa::Length(circle));
        CHECK(angle1 == cpa.Parameter());
        CHECK(s.X() == s1.X());
        CHECK(s.Y() == s1.Y());
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API ComputePointsAbscissa(double tol, const Adaptor2Curve& c, double abscissa, double u0)	 @param u0 The starting parameter
	 @param abscissa The arc length
	 @param c The curve
	 @param tol The tolerance
	 @brief Compute the parameter of a point on a 2D curve with given arc length and a tolerance
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <geometry/MakeGeom2Circle.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/ComputePointsAbscissa.hpp>
#include <geometry/MakeGeom3Circle.hpp>
#include <geometry/AdaptorGeom3Curve.hpp>
#include <geometry/MakeGeom2Hyperbola.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/MakeGeom2Ellipse.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <geometry/MakeGeom3Ellipse.hpp>
#include <geometry/MakeGeom3Hyperbola.hpp>
#include <geometry/Geom2Line.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom3Line.hpp>
#include <geometry/Geom3TrimmedCurve.hpp>
#include<modeling/MakeEdge.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/GeometryTool.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <geometry/MakeGeom2Parabola.hpp>
#include <geometry/MakeGeom3Parabola.hpp>
#include <geometry/Geom2BezierCurve.hpp>
#include <geometry/Geom3BezierCurve.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/Geom2OffsetCurve.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
#include<catch.hpp>
#include<testHelper.h>
#include <geometry/MakeGeom2Circle.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/ComputePointsAbscissa.hpp>
#include <geometry/MakeGeom3Circle.hpp>
#include <geometry/AdaptorGeom3Curve.hpp>
#include <geometry/MakeGeom2Hyperbola.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/MakeGeom2Ellipse.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <geometry/MakeGeom3Ellipse.hpp>
#include <geometry/MakeGeom3Hyperbola.hpp>
#include <geometry/Geom2Line.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom3Line.hpp>
#include <geometry/Geom3TrimmedCurve.hpp>
#include<modeling/MakeEdge.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/GeometryTool.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <geometry/MakeGeom2Parabola.hpp>
#include <geometry/MakeGeom3Parabola.hpp>
#include <geometry/Geom2BezierCurve.hpp>
#include <geometry/Geom3BezierCurve.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/Geom2OffsetCurve.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
;
	SECTION("circle")
    {
        double r = 2.0;
        double l = 1.0;
        std::shared_ptr<Geom2Curve> c = MakeGeom2Circle(Point2(0.0, 0.0), 2.0).Value();
        AdaptorGeom2Curve circle(c);
        ComputePointsAbscissa cpa(circle, 1.0, 0.0);
        double angle1 = l / r;
        std::cout << "" << ": " << angle1 << '\n';
        double x = r * cos(angle1);
        double y = r * sin(angle1);
        std::cout << "x" << ": " << x << '\n';
        std::cout << "y" << ": " << y << '\n';
        double param = cpa.Parameter();
        if (cpa.IsDone())
        {
            std::cout << param << ": " << circle.Value(param) << '\n';
        }
        double p = 2 * M_PI * r;
        std::cout << "" << ComputePointsAbscissa::Length(circle) << '\n';
        Point2 s = circle.Value(param);
        Point2 s1(x, y);
        std::cout << s << std::endl;
        CHECK(p == ComputePointsAbscissa::Length(circle));
        CHECK(angle1 == cpa.Parameter());
        CHECK(s.X() == s1.X());
        CHECK(s.Y() == s1.Y());
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API ComputePointsAbscissa(const Adaptor3Curve& c, double abscissa, double u0)	 @param u0 The starting parameter
	 @param abscissa The arc length
	 @param c The curve
	 @brief Compute the parameter of a point on a 3D curve with given arc length
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <geometry/MakeGeom2Circle.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/ComputePointsAbscissa.hpp>
#include <geometry/MakeGeom3Circle.hpp>
#include <geometry/AdaptorGeom3Curve.hpp>
#include <geometry/MakeGeom2Hyperbola.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/MakeGeom2Ellipse.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <geometry/MakeGeom3Ellipse.hpp>
#include <geometry/MakeGeom3Hyperbola.hpp>
#include <geometry/Geom2Line.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom3Line.hpp>
#include <geometry/Geom3TrimmedCurve.hpp>
#include<modeling/MakeEdge.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/GeometryTool.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <geometry/MakeGeom2Parabola.hpp>
#include <geometry/MakeGeom3Parabola.hpp>
#include <geometry/Geom2BezierCurve.hpp>
#include <geometry/Geom3BezierCurve.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/Geom2OffsetCurve.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
#include<catch.hpp>
#include<testHelper.h>
#include <geometry/MakeGeom2Circle.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/ComputePointsAbscissa.hpp>
#include <geometry/MakeGeom3Circle.hpp>
#include <geometry/AdaptorGeom3Curve.hpp>
#include <geometry/MakeGeom2Hyperbola.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/MakeGeom2Ellipse.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <geometry/MakeGeom3Ellipse.hpp>
#include <geometry/MakeGeom3Hyperbola.hpp>
#include <geometry/Geom2Line.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom3Line.hpp>
#include <geometry/Geom3TrimmedCurve.hpp>
#include<modeling/MakeEdge.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/GeometryTool.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <geometry/MakeGeom2Parabola.hpp>
#include <geometry/MakeGeom3Parabola.hpp>
#include <geometry/Geom2BezierCurve.hpp>
#include <geometry/Geom3BezierCurve.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/Geom2OffsetCurve.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
;
	SECTION("circle")
    {
        double r = 2.0;
        double l = 1.0;
        std::shared_ptr<Geom2Curve> c = MakeGeom2Circle(Point2(0.0, 0.0), 2.0).Value();
        AdaptorGeom2Curve circle(c);
        ComputePointsAbscissa cpa(circle, 1.0, 0.0);
        double angle1 = l / r;
        std::cout << "" << ": " << angle1 << '\n';
        double x = r * cos(angle1);
        double y = r * sin(angle1);
        std::cout << "x" << ": " << x << '\n';
        std::cout << "y" << ": " << y << '\n';
        double param = cpa.Parameter();
        if (cpa.IsDone())
        {
            std::cout << param << ": " << circle.Value(param) << '\n';
        }
        double p = 2 * M_PI * r;
        std::cout << "" << ComputePointsAbscissa::Length(circle) << '\n';
        Point2 s = circle.Value(param);
        Point2 s1(x, y);
        std::cout << s << std::endl;
        CHECK(p == ComputePointsAbscissa::Length(circle));
        CHECK(angle1 == cpa.Parameter());
        CHECK(s.X() == s1.X());
        CHECK(s.Y() == s1.Y());
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API ComputePointsAbscissa(const Adaptor2Curve& c, double abscissa, double u0)	 @param u0 The starting parameter
	 @param abscissa The arc length
	 @param c The curve
	 @brief Compute the parameter of a point on a 2D curve with given arc length
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <geometry/MakeGeom2Circle.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/ComputePointsAbscissa.hpp>
#include <geometry/MakeGeom3Circle.hpp>
#include <geometry/AdaptorGeom3Curve.hpp>
#include <geometry/MakeGeom2Hyperbola.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/MakeGeom2Ellipse.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <geometry/MakeGeom3Ellipse.hpp>
#include <geometry/MakeGeom3Hyperbola.hpp>
#include <geometry/Geom2Line.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom3Line.hpp>
#include <geometry/Geom3TrimmedCurve.hpp>
#include<modeling/MakeEdge.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/GeometryTool.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <geometry/MakeGeom2Parabola.hpp>
#include <geometry/MakeGeom3Parabola.hpp>
#include <geometry/Geom2BezierCurve.hpp>
#include <geometry/Geom3BezierCurve.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/Geom2OffsetCurve.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
#include<catch.hpp>
#include<testHelper.h>
#include <geometry/MakeGeom2Circle.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/ComputePointsAbscissa.hpp>
#include <geometry/MakeGeom3Circle.hpp>
#include <geometry/AdaptorGeom3Curve.hpp>
#include <geometry/MakeGeom2Hyperbola.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/MakeGeom2Ellipse.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <geometry/MakeGeom3Ellipse.hpp>
#include <geometry/MakeGeom3Hyperbola.hpp>
#include <geometry/Geom2Line.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom3Line.hpp>
#include <geometry/Geom3TrimmedCurve.hpp>
#include<modeling/MakeEdge.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/GeometryTool.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <geometry/MakeGeom2Parabola.hpp>
#include <geometry/MakeGeom3Parabola.hpp>
#include <geometry/Geom2BezierCurve.hpp>
#include <geometry/Geom3BezierCurve.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/Geom2OffsetCurve.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
;
	SECTION("circle")
    {
        double r = 2.0;
        double l = 1.0;
        std::shared_ptr<Geom2Curve> c = MakeGeom2Circle(Point2(0.0, 0.0), 2.0).Value();
        AdaptorGeom2Curve circle(c);
        ComputePointsAbscissa cpa(circle, 1.0, 0.0);
        double angle1 = l / r;
        std::cout << "" << ": " << angle1 << '\n';
        double x = r * cos(angle1);
        double y = r * sin(angle1);
        std::cout << "x" << ": " << x << '\n';
        std::cout << "y" << ": " << y << '\n';
        double param = cpa.Parameter();
        if (cpa.IsDone())
        {
            std::cout << param << ": " << circle.Value(param) << '\n';
        }
        double p = 2 * M_PI * r;
        std::cout << "" << ComputePointsAbscissa::Length(circle) << '\n';
        Point2 s = circle.Value(param);
        Point2 s1(x, y);
        std::cout << s << std::endl;
        CHECK(p == ComputePointsAbscissa::Length(circle));
        CHECK(angle1 == cpa.Parameter());
        CHECK(s.X() == s1.X());
        CHECK(s.Y() == s1.Y());
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API ComputePointsAbscissa(const Adaptor3Curve& c, double abscissa, double u0, double ui)	 @param ui The initial guess of the parameter
	 @param u0 The starting parameter
	 @param abscissa The arc length
	 @param c The curve
	 @brief Compute the parameter of a point on a 3D curve with given arc length and an initial guess
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <geometry/MakeGeom2Circle.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/ComputePointsAbscissa.hpp>
#include <geometry/MakeGeom3Circle.hpp>
#include <geometry/AdaptorGeom3Curve.hpp>
#include <geometry/MakeGeom2Hyperbola.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/MakeGeom2Ellipse.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <geometry/MakeGeom3Ellipse.hpp>
#include <geometry/MakeGeom3Hyperbola.hpp>
#include <geometry/Geom2Line.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom3Line.hpp>
#include <geometry/Geom3TrimmedCurve.hpp>
#include<modeling/MakeEdge.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/GeometryTool.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <geometry/MakeGeom2Parabola.hpp>
#include <geometry/MakeGeom3Parabola.hpp>
#include <geometry/Geom2BezierCurve.hpp>
#include <geometry/Geom3BezierCurve.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/Geom2OffsetCurve.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
#include<catch.hpp>
#include<testHelper.h>
#include <geometry/MakeGeom2Circle.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/ComputePointsAbscissa.hpp>
#include <geometry/MakeGeom3Circle.hpp>
#include <geometry/AdaptorGeom3Curve.hpp>
#include <geometry/MakeGeom2Hyperbola.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/MakeGeom2Ellipse.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <geometry/MakeGeom3Ellipse.hpp>
#include <geometry/MakeGeom3Hyperbola.hpp>
#include <geometry/Geom2Line.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom3Line.hpp>
#include <geometry/Geom3TrimmedCurve.hpp>
#include<modeling/MakeEdge.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/GeometryTool.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <geometry/MakeGeom2Parabola.hpp>
#include <geometry/MakeGeom3Parabola.hpp>
#include <geometry/Geom2BezierCurve.hpp>
#include <geometry/Geom3BezierCurve.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/Geom2OffsetCurve.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
;
	SECTION("ellipse")
    {
        Axis2 axis;
        double major = 5.0;
        double minor = 4.0;
        bool isRight = true;
        std::shared_ptr< Geom2Ellipse >g2e = MakeGeom2Ellipse(axis, major, minor, isRight);
        AdaptorGeom2Curve ellipse(g2e);
        double t = minor / major;
        std::cout << "t" << t << '\n';
        double T = 3.15129643210828;
        double L = T * (minor + major);
        std::cout << "L" << L << '\n';
        ComputePointsAbscissa cpa2(ellipse, L, 0.0);
        double param2 = cpa2.Parameter();
        if (cpa2.IsDone())
        {
            std::cout << param2 << ": " << ellipse.Value(param2) << '\n';
        }
        Point2 s2 = ellipse.Value(param2);
        Point2 s3(5.0, 0.0);
        std::cout << s2 << std::endl;
        CHECK(s2.X() == Approx(s3.X()).margin(1e-2));
        CHECK(s2.Y() == Approx(s3.Y()).margin(1e-2));
        std::cout << "" << ComputePointsAbscissa::Length(ellipse) << '\n';
        CHECK(ComputePointsAbscissa::Length(ellipse) == Approx(L).margin(1e-2));
        CHECK(cpa2.Parameter() == Approx(2 * M_PI).margin(1e-2));
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API ComputePointsAbscissa(const Adaptor2Curve& c, double abscissa, double u0, double ui)	 @param ui The initial guess of the parameter
	 @param u0 The starting parameter
	 @param abscissa The arc length
	 @param c The curve
	 @brief Compute the parameter of a point on a 2D curve with given arc length and an initial guess
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <geometry/MakeGeom2Circle.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/ComputePointsAbscissa.hpp>
#include <geometry/MakeGeom3Circle.hpp>
#include <geometry/AdaptorGeom3Curve.hpp>
#include <geometry/MakeGeom2Hyperbola.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/MakeGeom2Ellipse.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <geometry/MakeGeom3Ellipse.hpp>
#include <geometry/MakeGeom3Hyperbola.hpp>
#include <geometry/Geom2Line.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom3Line.hpp>
#include <geometry/Geom3TrimmedCurve.hpp>
#include<modeling/MakeEdge.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/GeometryTool.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <geometry/MakeGeom2Parabola.hpp>
#include <geometry/MakeGeom3Parabola.hpp>
#include <geometry/Geom2BezierCurve.hpp>
#include <geometry/Geom3BezierCurve.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/Geom2OffsetCurve.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
#include<catch.hpp>
#include<testHelper.h>
#include <geometry/MakeGeom2Circle.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/ComputePointsAbscissa.hpp>
#include <geometry/MakeGeom3Circle.hpp>
#include <geometry/AdaptorGeom3Curve.hpp>
#include <geometry/MakeGeom2Hyperbola.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/MakeGeom2Ellipse.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <geometry/MakeGeom3Ellipse.hpp>
#include <geometry/MakeGeom3Hyperbola.hpp>
#include <geometry/Geom2Line.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom3Line.hpp>
#include <geometry/Geom3TrimmedCurve.hpp>
#include<modeling/MakeEdge.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/GeometryTool.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <geometry/MakeGeom2Parabola.hpp>
#include <geometry/MakeGeom3Parabola.hpp>
#include <geometry/Geom2BezierCurve.hpp>
#include <geometry/Geom3BezierCurve.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/Geom2OffsetCurve.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
;
	SECTION("ellipse")
    {
        Axis2 axis;
        double major = 5.0;
        double minor = 4.0;
        bool isRight = true;
        std::shared_ptr< Geom2Ellipse >g2e = MakeGeom2Ellipse(axis, major, minor, isRight);
        AdaptorGeom2Curve ellipse(g2e);
        double t = minor / major;
        std::cout << "t" << t << '\n';
        double T = 3.15129643210828;
        double L = T * (minor + major);
        std::cout << "L" << L << '\n';
        ComputePointsAbscissa cpa2(ellipse, L, 0.0);
        double param2 = cpa2.Parameter();
        if (cpa2.IsDone())
        {
            std::cout << param2 << ": " << ellipse.Value(param2) << '\n';
        }
        Point2 s2 = ellipse.Value(param2);
        Point2 s3(5.0, 0.0);
        std::cout << s2 << std::endl;
        CHECK(s2.X() == Approx(s3.X()).margin(1e-2));
        CHECK(s2.Y() == Approx(s3.Y()).margin(1e-2));
        std::cout << "" << ComputePointsAbscissa::Length(ellipse) << '\n';
        CHECK(ComputePointsAbscissa::Length(ellipse) == Approx(L).margin(1e-2));
        CHECK(cpa2.Parameter() == Approx(2 * M_PI).margin(1e-2));
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API ComputePointsAbscissa(const Adaptor3Curve& c, double abscissa, double u0, double ui, double tol)	 @param tol The tolerance
	 @param ui The initial guess of the parameter
	 @param u0 The starting parameter
	 @param abscissa The arc length
	 @param c The curve
	 @brief Compute the parameter of a point on a 3D curve with given arc length, an initial guess, and a tolerance
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <geometry/MakeGeom2Circle.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/ComputePointsAbscissa.hpp>
#include <geometry/MakeGeom3Circle.hpp>
#include <geometry/AdaptorGeom3Curve.hpp>
#include <geometry/MakeGeom2Hyperbola.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/MakeGeom2Ellipse.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <geometry/MakeGeom3Ellipse.hpp>
#include <geometry/MakeGeom3Hyperbola.hpp>
#include <geometry/Geom2Line.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom3Line.hpp>
#include <geometry/Geom3TrimmedCurve.hpp>
#include<modeling/MakeEdge.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/GeometryTool.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <geometry/MakeGeom2Parabola.hpp>
#include <geometry/MakeGeom3Parabola.hpp>
#include <geometry/Geom2BezierCurve.hpp>
#include <geometry/Geom3BezierCurve.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/Geom2OffsetCurve.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
#include<catch.hpp>
#include<testHelper.h>
#include <geometry/MakeGeom2Circle.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/ComputePointsAbscissa.hpp>
#include <geometry/MakeGeom3Circle.hpp>
#include <geometry/AdaptorGeom3Curve.hpp>
#include <geometry/MakeGeom2Hyperbola.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/MakeGeom2Ellipse.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <geometry/MakeGeom3Ellipse.hpp>
#include <geometry/MakeGeom3Hyperbola.hpp>
#include <geometry/Geom2Line.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom3Line.hpp>
#include <geometry/Geom3TrimmedCurve.hpp>
#include<modeling/MakeEdge.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/GeometryTool.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <geometry/MakeGeom2Parabola.hpp>
#include <geometry/MakeGeom3Parabola.hpp>
#include <geometry/Geom2BezierCurve.hpp>
#include <geometry/Geom3BezierCurve.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/Geom2OffsetCurve.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
;
	SECTION("ellipse")
    {
        Axis2 axis;
        double major = 5.0;
        double minor = 4.0;
        bool isRight = true;
        std::shared_ptr< Geom2Ellipse >g2e = MakeGeom2Ellipse(axis, major, minor, isRight);
        AdaptorGeom2Curve ellipse(g2e);
        double t = minor / major;
        std::cout << "t" << t << '\n';
        double T = 3.15129643210828;
        double L = T * (minor + major);
        std::cout << "L" << L << '\n';
        ComputePointsAbscissa cpa2(ellipse, L, 0.0);
        double param2 = cpa2.Parameter();
        if (cpa2.IsDone())
        {
            std::cout << param2 << ": " << ellipse.Value(param2) << '\n';
        }
        Point2 s2 = ellipse.Value(param2);
        Point2 s3(5.0, 0.0);
        std::cout << s2 << std::endl;
        CHECK(s2.X() == Approx(s3.X()).margin(1e-2));
        CHECK(s2.Y() == Approx(s3.Y()).margin(1e-2));
        std::cout << "" << ComputePointsAbscissa::Length(ellipse) << '\n';
        CHECK(ComputePointsAbscissa::Length(ellipse) == Approx(L).margin(1e-2));
        CHECK(cpa2.Parameter() == Approx(2 * M_PI).margin(1e-2));
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API ComputePointsAbscissa(const Adaptor2Curve& c, double abscissa, double u0, double ui, double tol)	 @param tol The tolerance
	 @param ui The initial guess of the parameter
	 @param u0 The starting parameter
	 @param abscissa The arc length
	 @param c The curve
	 @brief Compute the parameter of a point on a 2D curve with given arc length, an initial guess, and a tolerance
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <geometry/MakeGeom2Circle.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/ComputePointsAbscissa.hpp>
#include <geometry/MakeGeom3Circle.hpp>
#include <geometry/AdaptorGeom3Curve.hpp>
#include <geometry/MakeGeom2Hyperbola.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/MakeGeom2Ellipse.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <geometry/MakeGeom3Ellipse.hpp>
#include <geometry/MakeGeom3Hyperbola.hpp>
#include <geometry/Geom2Line.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom3Line.hpp>
#include <geometry/Geom3TrimmedCurve.hpp>
#include<modeling/MakeEdge.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/GeometryTool.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <geometry/MakeGeom2Parabola.hpp>
#include <geometry/MakeGeom3Parabola.hpp>
#include <geometry/Geom2BezierCurve.hpp>
#include <geometry/Geom3BezierCurve.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/Geom2OffsetCurve.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
#include<catch.hpp>
#include<testHelper.h>
#include <geometry/MakeGeom2Circle.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/ComputePointsAbscissa.hpp>
#include <geometry/MakeGeom3Circle.hpp>
#include <geometry/AdaptorGeom3Curve.hpp>
#include <geometry/MakeGeom2Hyperbola.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/MakeGeom2Ellipse.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <geometry/MakeGeom3Ellipse.hpp>
#include <geometry/MakeGeom3Hyperbola.hpp>
#include <geometry/Geom2Line.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom3Line.hpp>
#include <geometry/Geom3TrimmedCurve.hpp>
#include<modeling/MakeEdge.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/GeometryTool.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <geometry/MakeGeom2Parabola.hpp>
#include <geometry/MakeGeom3Parabola.hpp>
#include <geometry/Geom2BezierCurve.hpp>
#include <geometry/Geom3BezierCurve.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/Geom2OffsetCurve.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
;
	SECTION("circle")
    {
        double r = 2.0;
        double l = 1.0;
        std::shared_ptr<Geom2Curve> c = MakeGeom2Circle(Point2(0.0, 0.0), 2.0).Value();
        AdaptorGeom2Curve circle(c);
        ComputePointsAbscissa cpa(circle, 1.0, 0.0);
        double angle1 = l / r;
        std::cout << "" << ": " << angle1 << '\n';
        double x = r * cos(angle1);
        double y = r * sin(angle1);
        std::cout << "x" << ": " << x << '\n';
        std::cout << "y" << ": " << y << '\n';
        double param = cpa.Parameter();
        if (cpa.IsDone())
        {
            std::cout << param << ": " << circle.Value(param) << '\n';
        }
        double p = 2 * M_PI * r;
        std::cout << "" << ComputePointsAbscissa::Length(circle) << '\n';
        Point2 s = circle.Value(param);
        Point2 s1(x, y);
        std::cout << s << std::endl;
        CHECK(p == ComputePointsAbscissa::Length(circle));
        CHECK(angle1 == cpa.Parameter());
        CHECK(s.X() == s1.X());
        CHECK(s.Y() == s1.Y());
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API double Parameter()	 @return The parameter of the point
	 @brief Get the parameter of the point
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <geometry/MakeGeom2Circle.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/ComputePointsAbscissa.hpp>
#include <geometry/MakeGeom3Circle.hpp>
#include <geometry/AdaptorGeom3Curve.hpp>
#include <geometry/MakeGeom2Hyperbola.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/MakeGeom2Ellipse.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <geometry/MakeGeom3Ellipse.hpp>
#include <geometry/MakeGeom3Hyperbola.hpp>
#include <geometry/Geom2Line.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom3Line.hpp>
#include <geometry/Geom3TrimmedCurve.hpp>
#include<modeling/MakeEdge.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/GeometryTool.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <geometry/MakeGeom2Parabola.hpp>
#include <geometry/MakeGeom3Parabola.hpp>
#include <geometry/Geom2BezierCurve.hpp>
#include <geometry/Geom3BezierCurve.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/Geom2OffsetCurve.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
#include<catch.hpp>
#include<testHelper.h>
#include <geometry/MakeGeom2Circle.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/ComputePointsAbscissa.hpp>
#include <geometry/MakeGeom3Circle.hpp>
#include <geometry/AdaptorGeom3Curve.hpp>
#include <geometry/MakeGeom2Hyperbola.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/MakeGeom2Ellipse.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <geometry/MakeGeom3Ellipse.hpp>
#include <geometry/MakeGeom3Hyperbola.hpp>
#include <geometry/Geom2Line.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom3Line.hpp>
#include <geometry/Geom3TrimmedCurve.hpp>
#include<modeling/MakeEdge.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/GeometryTool.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <geometry/MakeGeom2Parabola.hpp>
#include <geometry/MakeGeom3Parabola.hpp>
#include <geometry/Geom2BezierCurve.hpp>
#include <geometry/Geom3BezierCurve.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/Geom2OffsetCurve.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
;
	SECTION("line")
    {
        shared_ptr<Geom2Line> line;
        line = make_shared<Geom2Line>(Point2(0.0, 0.0), Direction2(1.0, 0.0));
        shared_ptr<Geom2TrimmedCurve> TrimmedCurve = make_shared<Geom2TrimmedCurve>(line, 0.0, 6.0);
        AdaptorGeom2Curve line1(TrimmedCurve);
        ComputePointsAbscissa cpa4(line1, 2.0, 0.0);
        double param4 = cpa4.Parameter();
        if (cpa4.IsDone())
        {
            std::cout << param4 << ": " << line1.Value(param4) << '\n';
        }
        double x = 2.0;
        double y = 0.0;
        Point2 s5 = line1.Value(param4);
        Point2 s6(x, y);
        std::cout << s5 << std::endl;
        CHECK(cpa4.Parameter() == 2.0);
        CHECK(s5.X() == s6.X());
        CHECK(s5.Y() == s6.Y());
        std::cout << "" << ComputePointsAbscissa::Length(line1) << '\n';
        CHECK(ComputePointsAbscissa::Length(line1) == 6.0);
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static double Length(const Adaptor3Curve& c)	 @return The length of a curve
	 @param c The curve
	 @brief Compute the length of a 3D curve
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <geometry/MakeGeom2Circle.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/ComputePointsAbscissa.hpp>
#include <geometry/MakeGeom3Circle.hpp>
#include <geometry/AdaptorGeom3Curve.hpp>
#include <geometry/MakeGeom2Hyperbola.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/MakeGeom2Ellipse.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <geometry/MakeGeom3Ellipse.hpp>
#include <geometry/MakeGeom3Hyperbola.hpp>
#include <geometry/Geom2Line.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom3Line.hpp>
#include <geometry/Geom3TrimmedCurve.hpp>
#include<modeling/MakeEdge.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/GeometryTool.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <geometry/MakeGeom2Parabola.hpp>
#include <geometry/MakeGeom3Parabola.hpp>
#include <geometry/Geom2BezierCurve.hpp>
#include <geometry/Geom3BezierCurve.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/Geom2OffsetCurve.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
#include<catch.hpp>
#include<testHelper.h>
#include <geometry/MakeGeom2Circle.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/ComputePointsAbscissa.hpp>
#include <geometry/MakeGeom3Circle.hpp>
#include <geometry/AdaptorGeom3Curve.hpp>
#include <geometry/MakeGeom2Hyperbola.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/MakeGeom2Ellipse.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <geometry/MakeGeom3Ellipse.hpp>
#include <geometry/MakeGeom3Hyperbola.hpp>
#include <geometry/Geom2Line.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom3Line.hpp>
#include <geometry/Geom3TrimmedCurve.hpp>
#include<modeling/MakeEdge.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/GeometryTool.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <geometry/MakeGeom2Parabola.hpp>
#include <geometry/MakeGeom3Parabola.hpp>
#include <geometry/Geom2BezierCurve.hpp>
#include <geometry/Geom3BezierCurve.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/Geom2OffsetCurve.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
;
	SECTION("line")
    {
        shared_ptr<Geom2Line> line;
        line = make_shared<Geom2Line>(Point2(0.0, 0.0), Direction2(1.0, 0.0));
        shared_ptr<Geom2TrimmedCurve> TrimmedCurve = make_shared<Geom2TrimmedCurve>(line, 0.0, 6.0);
        AdaptorGeom2Curve line1(TrimmedCurve);
        ComputePointsAbscissa cpa4(Precision::Confusion(), line1, 2.0, 0.0);
        double param4 = cpa4.Parameter();
        if (cpa4.IsDone())
        {
            std::cout << param4 << ": " << line1.Value(param4) << '\n';
        }
        double x = 2.0;
        double y = 0.0;
        Point2 s5 = line1.Value(param4);
        Point2 s6(x, y);
        std::cout << s5 << std::endl;
        CHECK(cpa4.Parameter() == 2.0);
        CHECK(s5.X() == s6.X());
        CHECK(s5.Y() == s6.Y());
        std::cout << "" << ComputePointsAbscissa::Length(line1, Precision::Confusion()) << '\n';
        CHECK(ComputePointsAbscissa::Length(line1, Precision::Confusion()) == 6.0);
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static double Length(const Adaptor2Curve& c)	 @return The length of a curve
	 @param c The curve
	 @brief Compute the length of a 2D curve
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <geometry/MakeGeom2Circle.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/ComputePointsAbscissa.hpp>
#include <geometry/MakeGeom3Circle.hpp>
#include <geometry/AdaptorGeom3Curve.hpp>
#include <geometry/MakeGeom2Hyperbola.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/MakeGeom2Ellipse.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <geometry/MakeGeom3Ellipse.hpp>
#include <geometry/MakeGeom3Hyperbola.hpp>
#include <geometry/Geom2Line.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom3Line.hpp>
#include <geometry/Geom3TrimmedCurve.hpp>
#include<modeling/MakeEdge.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/GeometryTool.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <geometry/MakeGeom2Parabola.hpp>
#include <geometry/MakeGeom3Parabola.hpp>
#include <geometry/Geom2BezierCurve.hpp>
#include <geometry/Geom3BezierCurve.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/Geom2OffsetCurve.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
#include<catch.hpp>
#include<testHelper.h>
#include <geometry/MakeGeom2Circle.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/ComputePointsAbscissa.hpp>
#include <geometry/MakeGeom3Circle.hpp>
#include <geometry/AdaptorGeom3Curve.hpp>
#include <geometry/MakeGeom2Hyperbola.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/MakeGeom2Ellipse.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <geometry/MakeGeom3Ellipse.hpp>
#include <geometry/MakeGeom3Hyperbola.hpp>
#include <geometry/Geom2Line.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom3Line.hpp>
#include <geometry/Geom3TrimmedCurve.hpp>
#include<modeling/MakeEdge.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/GeometryTool.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <geometry/MakeGeom2Parabola.hpp>
#include <geometry/MakeGeom3Parabola.hpp>
#include <geometry/Geom2BezierCurve.hpp>
#include <geometry/Geom3BezierCurve.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/Geom2OffsetCurve.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
;
	SECTION("line")
    {
        shared_ptr<Geom2Line> line;
        line = make_shared<Geom2Line>(Point2(0.0, 0.0), Direction2(1.0, 0.0));
        shared_ptr<Geom2TrimmedCurve> TrimmedCurve = make_shared<Geom2TrimmedCurve>(line, 0.0, 6.0);
        AdaptorGeom2Curve line1(TrimmedCurve);
        ComputePointsAbscissa cpa4(line1, 2.0, 0.0);
        double param4 = cpa4.Parameter();
        if (cpa4.IsDone())
        {
            std::cout << param4 << ": " << line1.Value(param4) << '\n';
        }
        double x = 2.0;
        double y = 0.0;
        Point2 s5 = line1.Value(param4);
        Point2 s6(x, y);
        std::cout << s5 << std::endl;
        CHECK(cpa4.Parameter() == 2.0);
        CHECK(s5.X() == s6.X());
        CHECK(s5.Y() == s6.Y());
        std::cout << "" << ComputePointsAbscissa::Length(line1) << '\n';
        CHECK(ComputePointsAbscissa::Length(line1) == 6.0);
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static double Length(const Adaptor3Curve& c, double tol)	 @return The length of a curve
	 @param tol The tolerance
	 @param c The curve
	 @brief Compute the length of a 3D curve with a tolerance
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <geometry/MakeGeom2Circle.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/ComputePointsAbscissa.hpp>
#include <geometry/MakeGeom3Circle.hpp>
#include <geometry/AdaptorGeom3Curve.hpp>
#include <geometry/MakeGeom2Hyperbola.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/MakeGeom2Ellipse.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <geometry/MakeGeom3Ellipse.hpp>
#include <geometry/MakeGeom3Hyperbola.hpp>
#include <geometry/Geom2Line.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom3Line.hpp>
#include <geometry/Geom3TrimmedCurve.hpp>
#include<modeling/MakeEdge.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/GeometryTool.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <geometry/MakeGeom2Parabola.hpp>
#include <geometry/MakeGeom3Parabola.hpp>
#include <geometry/Geom2BezierCurve.hpp>
#include <geometry/Geom3BezierCurve.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/Geom2OffsetCurve.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
#include<catch.hpp>
#include<testHelper.h>
#include <geometry/MakeGeom2Circle.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/ComputePointsAbscissa.hpp>
#include <geometry/MakeGeom3Circle.hpp>
#include <geometry/AdaptorGeom3Curve.hpp>
#include <geometry/MakeGeom2Hyperbola.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/MakeGeom2Ellipse.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <geometry/MakeGeom3Ellipse.hpp>
#include <geometry/MakeGeom3Hyperbola.hpp>
#include <geometry/Geom2Line.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom3Line.hpp>
#include <geometry/Geom3TrimmedCurve.hpp>
#include<modeling/MakeEdge.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/GeometryTool.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <geometry/MakeGeom2Parabola.hpp>
#include <geometry/MakeGeom3Parabola.hpp>
#include <geometry/Geom2BezierCurve.hpp>
#include <geometry/Geom3BezierCurve.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/Geom2OffsetCurve.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
;
	SECTION("circle")
    {
        double r = 3.0;
        double l = 2.0;
        std::shared_ptr<Geom2Curve> c = MakeGeom2Circle(Point2(0.0, 0.0), 3.0).Value();
        AdaptorGeom2Curve circle(c);
        ComputePointsAbscissa cpa(Precision::Confusion(), circle, 2.0, 0.0);
        double angle1 = l / r;
        std::cout << "" << ": " << angle1 << '\n';
        double x = r * cos(angle1);
        double y = r * sin(angle1);
        std::cout << "x" << ": " << x << '\n';
        std::cout << "y" << ": " << y << '\n';
        double param = cpa.Parameter();
        if (cpa.IsDone())
        {
            std::cout << param << ": " << circle.Value(param) << '\n';
        }
        double p = 2 * M_PI * r;
        std::cout << "" << ComputePointsAbscissa::Length(circle, Precision::Confusion()) << '\n';
        Point2 s = circle.Value(param);
        Point2 s1(x, y);
        std::cout << s << std::endl;
        CHECK(s.X() == s1.X());
        CHECK(s.Y() == s1.Y());
        CHECK(ComputePointsAbscissa::Length(circle, Precision::Confusion()) == p);
        CHECK(angle1 == cpa.Parameter());
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static double Length(const Adaptor2Curve& c, double tol)	 @return The length of a curve
	 @param tol The tolerance
	 @param c The curve
	 @brief Compute the length of a 2D curve with a tolerance
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <geometry/MakeGeom2Circle.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/ComputePointsAbscissa.hpp>
#include <geometry/MakeGeom3Circle.hpp>
#include <geometry/AdaptorGeom3Curve.hpp>
#include <geometry/MakeGeom2Hyperbola.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/MakeGeom2Ellipse.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <geometry/MakeGeom3Ellipse.hpp>
#include <geometry/MakeGeom3Hyperbola.hpp>
#include <geometry/Geom2Line.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom3Line.hpp>
#include <geometry/Geom3TrimmedCurve.hpp>
#include<modeling/MakeEdge.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/GeometryTool.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <geometry/MakeGeom2Parabola.hpp>
#include <geometry/MakeGeom3Parabola.hpp>
#include <geometry/Geom2BezierCurve.hpp>
#include <geometry/Geom3BezierCurve.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/Geom2OffsetCurve.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
#include<catch.hpp>
#include<testHelper.h>
#include <geometry/MakeGeom2Circle.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/ComputePointsAbscissa.hpp>
#include <geometry/MakeGeom3Circle.hpp>
#include <geometry/AdaptorGeom3Curve.hpp>
#include <geometry/MakeGeom2Hyperbola.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/MakeGeom2Ellipse.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <geometry/MakeGeom3Ellipse.hpp>
#include <geometry/MakeGeom3Hyperbola.hpp>
#include <geometry/Geom2Line.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom3Line.hpp>
#include <geometry/Geom3TrimmedCurve.hpp>
#include<modeling/MakeEdge.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/GeometryTool.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <geometry/MakeGeom2Parabola.hpp>
#include <geometry/MakeGeom3Parabola.hpp>
#include <geometry/Geom2BezierCurve.hpp>
#include <geometry/Geom3BezierCurve.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/Geom2OffsetCurve.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
;
	SECTION("circle")
    {
        double r = 3.0;
        double l = 2.0;
        std::shared_ptr<Geom2Curve> c = MakeGeom2Circle(Point2(0.0, 0.0), 3.0).Value();
        AdaptorGeom2Curve circle(c);
        ComputePointsAbscissa cpa(Precision::Confusion(), circle, 2.0, 0.0);
        double angle1 = l / r;
        std::cout << "" << ": " << angle1 << '\n';
        double x = r * cos(angle1);
        double y = r * sin(angle1);
        std::cout << "x" << ": " << x << '\n';
        std::cout << "y" << ": " << y << '\n';
        double param = cpa.Parameter();
        if (cpa.IsDone())
        {
            std::cout << param << ": " << circle.Value(param) << '\n';
        }
        double p = 2 * M_PI * r;
        std::cout << "" << ComputePointsAbscissa::Length(circle, Precision::Confusion()) << '\n';
        Point2 s = circle.Value(param);
        Point2 s1(x, y);
        std::cout << s << std::endl;
        CHECK(s.X() == s1.X());
        CHECK(s.Y() == s1.Y());
        CHECK(ComputePointsAbscissa::Length(circle, Precision::Confusion()) == p);
        CHECK(angle1 == cpa.Parameter());
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static double Length(const Adaptor3Curve& c, double u1, double u2)	 @return The length of a curve in a given interval
	 @param u2 The last parameter
	 @param u1 The first parameter
	 @param c The curve
	 @brief Compute the length of a 3D curve in a given interval
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <geometry/MakeGeom2Circle.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/ComputePointsAbscissa.hpp>
#include <geometry/MakeGeom3Circle.hpp>
#include <geometry/AdaptorGeom3Curve.hpp>
#include <geometry/MakeGeom2Hyperbola.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/MakeGeom2Ellipse.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <geometry/MakeGeom3Ellipse.hpp>
#include <geometry/MakeGeom3Hyperbola.hpp>
#include <geometry/Geom2Line.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom3Line.hpp>
#include <geometry/Geom3TrimmedCurve.hpp>
#include<modeling/MakeEdge.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/GeometryTool.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <geometry/MakeGeom2Parabola.hpp>
#include <geometry/MakeGeom3Parabola.hpp>
#include <geometry/Geom2BezierCurve.hpp>
#include <geometry/Geom3BezierCurve.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/Geom2OffsetCurve.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
#include<catch.hpp>
#include<testHelper.h>
#include <geometry/MakeGeom2Circle.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/ComputePointsAbscissa.hpp>
#include <geometry/MakeGeom3Circle.hpp>
#include <geometry/AdaptorGeom3Curve.hpp>
#include <geometry/MakeGeom2Hyperbola.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/MakeGeom2Ellipse.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <geometry/MakeGeom3Ellipse.hpp>
#include <geometry/MakeGeom3Hyperbola.hpp>
#include <geometry/Geom2Line.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom3Line.hpp>
#include <geometry/Geom3TrimmedCurve.hpp>
#include<modeling/MakeEdge.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/GeometryTool.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <geometry/MakeGeom2Parabola.hpp>
#include <geometry/MakeGeom3Parabola.hpp>
#include <geometry/Geom2BezierCurve.hpp>
#include <geometry/Geom3BezierCurve.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/Geom2OffsetCurve.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
;
	SECTION("line")
    {
        shared_ptr<Geom2Line> line;
        line = make_shared<Geom2Line>(Point2(0.0, 0.0), Direction2(1.0, 0.0));
        shared_ptr<Geom2TrimmedCurve> TrimmedCurve = make_shared<Geom2TrimmedCurve>(line, 0.0, 6.0);
        AdaptorGeom2Curve line1(TrimmedCurve);
        ComputePointsAbscissa cpa4(line1, 2.0, 0.0, 2.0, Precision::Confusion());
        double param4 = cpa4.Parameter();
        if (cpa4.IsDone())
        {
            std::cout << param4 << ": " << line1.Value(param4) << '\n';
        }
        double x = 2.0;
        double y = 0.0;
        Point2 s5 = line1.Value(param4);
        Point2 s6(x, y);
        std::cout << s5 << std::endl;
        CHECK(cpa4.Parameter() == 2.0);
        CHECK(s5.X() == s6.X());
        CHECK(s5.Y() == s6.Y());
        std::cout << "" << ComputePointsAbscissa::Length(line1, 0.0, 2.0) << '\n';
        std::cout << "" << ComputePointsAbscissa::Length(line1, 0.0, 3.0, Precision::Confusion()) << '\n';
        CHECK(ComputePointsAbscissa::Length(line1, 0.0, 2.0) == 2.0);
        CHECK(ComputePointsAbscissa::Length(line1, 0.0, 3.0, Precision::Confusion()) == 3.0);
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static double Length(const Adaptor2Curve& c, double u1, double u2)	 @return The length of a curve in a given interval
	 @param u2 The last parameter
	 @param u1 The first parameter
	 @param c The curve
	 @brief Compute the length of a 2D curve in a given interval
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <geometry/MakeGeom2Circle.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/ComputePointsAbscissa.hpp>
#include <geometry/MakeGeom3Circle.hpp>
#include <geometry/AdaptorGeom3Curve.hpp>
#include <geometry/MakeGeom2Hyperbola.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/MakeGeom2Ellipse.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <geometry/MakeGeom3Ellipse.hpp>
#include <geometry/MakeGeom3Hyperbola.hpp>
#include <geometry/Geom2Line.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom3Line.hpp>
#include <geometry/Geom3TrimmedCurve.hpp>
#include<modeling/MakeEdge.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/GeometryTool.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <geometry/MakeGeom2Parabola.hpp>
#include <geometry/MakeGeom3Parabola.hpp>
#include <geometry/Geom2BezierCurve.hpp>
#include <geometry/Geom3BezierCurve.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/Geom2OffsetCurve.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
#include<catch.hpp>
#include<testHelper.h>
#include <geometry/MakeGeom2Circle.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/ComputePointsAbscissa.hpp>
#include <geometry/MakeGeom3Circle.hpp>
#include <geometry/AdaptorGeom3Curve.hpp>
#include <geometry/MakeGeom2Hyperbola.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/MakeGeom2Ellipse.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <geometry/MakeGeom3Ellipse.hpp>
#include <geometry/MakeGeom3Hyperbola.hpp>
#include <geometry/Geom2Line.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom3Line.hpp>
#include <geometry/Geom3TrimmedCurve.hpp>
#include<modeling/MakeEdge.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/GeometryTool.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <geometry/MakeGeom2Parabola.hpp>
#include <geometry/MakeGeom3Parabola.hpp>
#include <geometry/Geom2BezierCurve.hpp>
#include <geometry/Geom3BezierCurve.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/Geom2OffsetCurve.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
;
	SECTION("line")
    {
        shared_ptr<Geom2Line> line;
        line = make_shared<Geom2Line>(Point2(0.0, 0.0), Direction2(1.0, 0.0));
        shared_ptr<Geom2TrimmedCurve> TrimmedCurve = make_shared<Geom2TrimmedCurve>(line, 0.0, 6.0);
        AdaptorGeom2Curve line1(TrimmedCurve);
        ComputePointsAbscissa cpa4(line1, 2.0, 0.0, 2.0, Precision::Confusion());
        double param4 = cpa4.Parameter();
        if (cpa4.IsDone())
        {
            std::cout << param4 << ": " << line1.Value(param4) << '\n';
        }
        double x = 2.0;
        double y = 0.0;
        Point2 s5 = line1.Value(param4);
        Point2 s6(x, y);
        std::cout << s5 << std::endl;
        CHECK(cpa4.Parameter() == 2.0);
        CHECK(s5.X() == s6.X());
        CHECK(s5.Y() == s6.Y());
        std::cout << "" << ComputePointsAbscissa::Length(line1, 0.0, 2.0) << '\n';
        std::cout << "" << ComputePointsAbscissa::Length(line1, 0.0, 3.0, Precision::Confusion()) << '\n';
        CHECK(ComputePointsAbscissa::Length(line1, 0.0, 2.0) == 2.0);
        CHECK(ComputePointsAbscissa::Length(line1, 0.0, 3.0, Precision::Confusion()) == 3.0);
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static double Length(const Adaptor3Curve& c, double u1, double u2, double tol)	 @return The length of a curve in a given interval
	 @param tol The tolerance
	 @param u2 The last parameter
	 @param u1 The first parameter
	 @param c The curve
	 @brief Compute the length of a 3D curve in a given interval with a tolerance
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <geometry/MakeGeom2Circle.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/ComputePointsAbscissa.hpp>
#include <geometry/MakeGeom3Circle.hpp>
#include <geometry/AdaptorGeom3Curve.hpp>
#include <geometry/MakeGeom2Hyperbola.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/MakeGeom2Ellipse.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <geometry/MakeGeom3Ellipse.hpp>
#include <geometry/MakeGeom3Hyperbola.hpp>
#include <geometry/Geom2Line.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom3Line.hpp>
#include <geometry/Geom3TrimmedCurve.hpp>
#include<modeling/MakeEdge.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/GeometryTool.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <geometry/MakeGeom2Parabola.hpp>
#include <geometry/MakeGeom3Parabola.hpp>
#include <geometry/Geom2BezierCurve.hpp>
#include <geometry/Geom3BezierCurve.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/Geom2OffsetCurve.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
#include<catch.hpp>
#include<testHelper.h>
#include <geometry/MakeGeom2Circle.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/ComputePointsAbscissa.hpp>
#include <geometry/MakeGeom3Circle.hpp>
#include <geometry/AdaptorGeom3Curve.hpp>
#include <geometry/MakeGeom2Hyperbola.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/MakeGeom2Ellipse.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <geometry/MakeGeom3Ellipse.hpp>
#include <geometry/MakeGeom3Hyperbola.hpp>
#include <geometry/Geom2Line.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom3Line.hpp>
#include <geometry/Geom3TrimmedCurve.hpp>
#include<modeling/MakeEdge.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/GeometryTool.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <geometry/MakeGeom2Parabola.hpp>
#include <geometry/MakeGeom3Parabola.hpp>
#include <geometry/Geom2BezierCurve.hpp>
#include <geometry/Geom3BezierCurve.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/Geom2OffsetCurve.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
;
	SECTION("circle")
    {
        double r = 3.0;
        double l = 2.0;
        std::shared_ptr<Geom2Curve> c = MakeGeom2Circle(Point2(0.0, 0.0), 3.0).Value();
        AdaptorGeom2Curve circle(c);
        ComputePointsAbscissa cpa(circle, 2.0, 0.0, 1.5, Precision::Confusion());
        double angle1 = l / r;
        std::cout << "" << ": " << angle1 << '\n';
        double x = r * cos(angle1);
        double y = r * sin(angle1);
        std::cout << "x" << ": " << x << '\n';
        std::cout << "y" << ": " << y << '\n';
        double param = cpa.Parameter();
        if (cpa.IsDone())
        {
            std::cout << param << ": " << circle.Value(param) << '\n';
        }
        Point2 s = circle.Value(param);
        Point2 s1(x, y);
        std::cout << s << std::endl;
        CHECK(s.X() == s1.X());
        CHECK(s.Y() == s1.Y());
        std::cout << "" << ComputePointsAbscissa::Length(circle, 0.0, 0.666667) << '\n';
        std::cout << "" << ComputePointsAbscissa::Length(circle, 0.0, 0.666667, Precision::Confusion()) << '\n';
        CHECK(angle1 == cpa.Parameter());
        CHECK(ComputePointsAbscissa::Length(circle, 0.0, 0.6666666667) == Approx(l).margin(1e-2));
        CHECK(ComputePointsAbscissa::Length(circle, 0.0, 0.6666666667, Precision::Confusion()) == Approx(l).margin(1e-2));
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static double Length(const Adaptor2Curve& c, double u1, double u2, double tol)	 @return The length of a curve in a given interval
	 @param tol The tolerance
	 @param u2 The last parameter
	 @param u1 The first parameter
	 @param c The curve
	 @brief Compute the length of a 2D curve in a given interval with a tolerance
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <geometry/MakeGeom2Circle.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/ComputePointsAbscissa.hpp>
#include <geometry/MakeGeom3Circle.hpp>
#include <geometry/AdaptorGeom3Curve.hpp>
#include <geometry/MakeGeom2Hyperbola.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/MakeGeom2Ellipse.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <geometry/MakeGeom3Ellipse.hpp>
#include <geometry/MakeGeom3Hyperbola.hpp>
#include <geometry/Geom2Line.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom3Line.hpp>
#include <geometry/Geom3TrimmedCurve.hpp>
#include<modeling/MakeEdge.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/GeometryTool.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <geometry/MakeGeom2Parabola.hpp>
#include <geometry/MakeGeom3Parabola.hpp>
#include <geometry/Geom2BezierCurve.hpp>
#include <geometry/Geom3BezierCurve.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/Geom2OffsetCurve.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
#include<catch.hpp>
#include<testHelper.h>
#include <geometry/MakeGeom2Circle.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/ComputePointsAbscissa.hpp>
#include <geometry/MakeGeom3Circle.hpp>
#include <geometry/AdaptorGeom3Curve.hpp>
#include <geometry/MakeGeom2Hyperbola.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/MakeGeom2Ellipse.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <geometry/MakeGeom3Ellipse.hpp>
#include <geometry/MakeGeom3Hyperbola.hpp>
#include <geometry/Geom2Line.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom3Line.hpp>
#include <geometry/Geom3TrimmedCurve.hpp>
#include<modeling/MakeEdge.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/GeometryTool.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <geometry/MakeGeom2Parabola.hpp>
#include <geometry/MakeGeom3Parabola.hpp>
#include <geometry/Geom2BezierCurve.hpp>
#include <geometry/Geom3BezierCurve.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/Geom2OffsetCurve.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
;
	SECTION("circle")
    {
        double r = 3.0;
        double l = 2.0;
        std::shared_ptr<Geom2Curve> c = MakeGeom2Circle(Point2(0.0, 0.0), 3.0).Value();
        AdaptorGeom2Curve circle(c);
        ComputePointsAbscissa cpa(circle, 2.0, 0.0, 1.5, Precision::Confusion());
        double angle1 = l / r;
        std::cout << "" << ": " << angle1 << '\n';
        double x = r * cos(angle1);
        double y = r * sin(angle1);
        std::cout << "x" << ": " << x << '\n';
        std::cout << "y" << ": " << y << '\n';
        double param = cpa.Parameter();
        if (cpa.IsDone())
        {
            std::cout << param << ": " << circle.Value(param) << '\n';
        }
        Point2 s = circle.Value(param);
        Point2 s1(x, y);
        std::cout << s << std::endl;
        CHECK(s.X() == s1.X());
        CHECK(s.Y() == s1.Y());
        std::cout << "" << ComputePointsAbscissa::Length(circle, 0.0, 0.666667) << '\n';
        std::cout << "" << ComputePointsAbscissa::Length(circle, 0.0, 0.666667, Precision::Confusion()) << '\n';
        CHECK(angle1 == cpa.Parameter());
        CHECK(ComputePointsAbscissa::Length(circle, 0.0, 0.6666666667) == Approx(l).margin(1e-2));
        CHECK(ComputePointsAbscissa::Length(circle, 0.0, 0.6666666667, Precision::Confusion()) == Approx(l).margin(1e-2));
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API ComputePointsAbscissa(double tol, const Adaptor3Curve& c, double abscissa, double u0)	 @param u0 The starting parameter
	 @param abscissa The arc length
	 @param c The curve
	 @param tol The tolerance
	 @brief Compute the parameter of a point on a 3D curve with given arc length and a tolerance
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <geometry/MakeGeom2Circle.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/ComputePointsAbscissa.hpp>
#include <geometry/MakeGeom3Circle.hpp>
#include <geometry/AdaptorGeom3Curve.hpp>
#include <geometry/MakeGeom2Hyperbola.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/MakeGeom2Ellipse.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <geometry/MakeGeom3Ellipse.hpp>
#include <geometry/MakeGeom3Hyperbola.hpp>
#include <geometry/Geom2Line.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom3Line.hpp>
#include <geometry/Geom3TrimmedCurve.hpp>
#include<modeling/MakeEdge.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/GeometryTool.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <geometry/MakeGeom2Parabola.hpp>
#include <geometry/MakeGeom3Parabola.hpp>
#include <geometry/Geom2BezierCurve.hpp>
#include <geometry/Geom3BezierCurve.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/Geom2OffsetCurve.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
#include<catch.hpp>
#include<testHelper.h>
#include <geometry/MakeGeom2Circle.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/ComputePointsAbscissa.hpp>
#include <geometry/MakeGeom3Circle.hpp>
#include <geometry/AdaptorGeom3Curve.hpp>
#include <geometry/MakeGeom2Hyperbola.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/MakeGeom2Ellipse.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <geometry/MakeGeom3Ellipse.hpp>
#include <geometry/MakeGeom3Hyperbola.hpp>
#include <geometry/Geom2Line.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom3Line.hpp>
#include <geometry/Geom3TrimmedCurve.hpp>
#include<modeling/MakeEdge.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/GeometryTool.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <geometry/MakeGeom2Parabola.hpp>
#include <geometry/MakeGeom3Parabola.hpp>
#include <geometry/Geom2BezierCurve.hpp>
#include <geometry/Geom3BezierCurve.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/Geom2OffsetCurve.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
;
	SECTION("circle")
    {
        double r = 2.0;
        double l = -1.0;
        std::shared_ptr<Geom2Curve> c = MakeGeom2Circle(Point2(0.0, 0.0), 2.0).Value();
        AdaptorGeom2Curve circle(c);
        ComputePointsAbscissa cpa(circle, -1.0, 0.0);
        double angle1 = l / r;
        double x = r * cos(angle1);
        double y = r * sin(angle1);
        double param = cpa.Parameter();
        Point2 s = circle.Value(param);
        Point2 s1(x, y);
        CHECK(angle1 == cpa.Parameter());
        CHECK(s.X() == s1.X());
        CHECK(s.Y() == s1.Y());
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API ComputePointsAbscissa(double tol, const Adaptor2Curve& c, double abscissa, double u0)	 @param u0 The starting parameter
	 @param abscissa The arc length
	 @param c The curve
	 @param tol The tolerance
	 @brief Compute the parameter of a point on a 2D curve with given arc length and a tolerance
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <geometry/MakeGeom2Circle.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/ComputePointsAbscissa.hpp>
#include <geometry/MakeGeom3Circle.hpp>
#include <geometry/AdaptorGeom3Curve.hpp>
#include <geometry/MakeGeom2Hyperbola.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/MakeGeom2Ellipse.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <geometry/MakeGeom3Ellipse.hpp>
#include <geometry/MakeGeom3Hyperbola.hpp>
#include <geometry/Geom2Line.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom3Line.hpp>
#include <geometry/Geom3TrimmedCurve.hpp>
#include<modeling/MakeEdge.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/GeometryTool.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <geometry/MakeGeom2Parabola.hpp>
#include <geometry/MakeGeom3Parabola.hpp>
#include <geometry/Geom2BezierCurve.hpp>
#include <geometry/Geom3BezierCurve.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/Geom2OffsetCurve.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
#include<catch.hpp>
#include<testHelper.h>
#include <geometry/MakeGeom2Circle.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/ComputePointsAbscissa.hpp>
#include <geometry/MakeGeom3Circle.hpp>
#include <geometry/AdaptorGeom3Curve.hpp>
#include <geometry/MakeGeom2Hyperbola.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/MakeGeom2Ellipse.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <geometry/MakeGeom3Ellipse.hpp>
#include <geometry/MakeGeom3Hyperbola.hpp>
#include <geometry/Geom2Line.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom3Line.hpp>
#include <geometry/Geom3TrimmedCurve.hpp>
#include<modeling/MakeEdge.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/GeometryTool.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <geometry/MakeGeom2Parabola.hpp>
#include <geometry/MakeGeom3Parabola.hpp>
#include <geometry/Geom2BezierCurve.hpp>
#include <geometry/Geom3BezierCurve.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/Geom2OffsetCurve.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
;
	SECTION("circle")
    {
        double r = 2.0;
        double l = -1.0;
        std::shared_ptr<Geom2Curve> c = MakeGeom2Circle(Point2(0.0, 0.0), 2.0).Value();
        AdaptorGeom2Curve circle(c);
        ComputePointsAbscissa cpa(circle, -1.0, 0.0);
        double angle1 = l / r;
        double x = r * cos(angle1);
        double y = r * sin(angle1);
        double param = cpa.Parameter();
        Point2 s = circle.Value(param);
        Point2 s1(x, y);
        CHECK(angle1 == cpa.Parameter());
        CHECK(s.X() == s1.X());
        CHECK(s.Y() == s1.Y());
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API ComputePointsAbscissa(const Adaptor3Curve& c, double abscissa, double u0)	 @param u0 The starting parameter
	 @param abscissa The arc length
	 @param c The curve
	 @brief Compute the parameter of a point on a 3D curve with given arc length
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <geometry/MakeGeom2Circle.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/ComputePointsAbscissa.hpp>
#include <geometry/MakeGeom3Circle.hpp>
#include <geometry/AdaptorGeom3Curve.hpp>
#include <geometry/MakeGeom2Hyperbola.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/MakeGeom2Ellipse.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <geometry/MakeGeom3Ellipse.hpp>
#include <geometry/MakeGeom3Hyperbola.hpp>
#include <geometry/Geom2Line.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom3Line.hpp>
#include <geometry/Geom3TrimmedCurve.hpp>
#include<modeling/MakeEdge.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/GeometryTool.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <geometry/MakeGeom2Parabola.hpp>
#include <geometry/MakeGeom3Parabola.hpp>
#include <geometry/Geom2BezierCurve.hpp>
#include <geometry/Geom3BezierCurve.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/Geom2OffsetCurve.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
#include<catch.hpp>
#include<testHelper.h>
#include <geometry/MakeGeom2Circle.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/ComputePointsAbscissa.hpp>
#include <geometry/MakeGeom3Circle.hpp>
#include <geometry/AdaptorGeom3Curve.hpp>
#include <geometry/MakeGeom2Hyperbola.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/MakeGeom2Ellipse.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <geometry/MakeGeom3Ellipse.hpp>
#include <geometry/MakeGeom3Hyperbola.hpp>
#include <geometry/Geom2Line.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom3Line.hpp>
#include <geometry/Geom3TrimmedCurve.hpp>
#include<modeling/MakeEdge.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/GeometryTool.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <geometry/MakeGeom2Parabola.hpp>
#include <geometry/MakeGeom3Parabola.hpp>
#include <geometry/Geom2BezierCurve.hpp>
#include <geometry/Geom3BezierCurve.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/Geom2OffsetCurve.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
;
	SECTION("circle")
    {
        double r = 2.0;
        double l = -1.0;
        std::shared_ptr<Geom2Curve> c = MakeGeom2Circle(Point2(0.0, 0.0), 2.0).Value();
        AdaptorGeom2Curve circle(c);
        ComputePointsAbscissa cpa(circle, -1.0, 0.0);
        double angle1 = l / r;
        double x = r * cos(angle1);
        double y = r * sin(angle1);
        double param = cpa.Parameter();
        Point2 s = circle.Value(param);
        Point2 s1(x, y);
        CHECK(angle1 == cpa.Parameter());
        CHECK(s.X() == s1.X());
        CHECK(s.Y() == s1.Y());
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API ComputePointsAbscissa(const Adaptor2Curve& c, double abscissa, double u0)	 @param u0 The starting parameter
	 @param abscissa The arc length
	 @param c The curve
	 @brief Compute the parameter of a point on a 2D curve with given arc length
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <geometry/MakeGeom2Circle.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/ComputePointsAbscissa.hpp>
#include <geometry/MakeGeom3Circle.hpp>
#include <geometry/AdaptorGeom3Curve.hpp>
#include <geometry/MakeGeom2Hyperbola.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/MakeGeom2Ellipse.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <geometry/MakeGeom3Ellipse.hpp>
#include <geometry/MakeGeom3Hyperbola.hpp>
#include <geometry/Geom2Line.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom3Line.hpp>
#include <geometry/Geom3TrimmedCurve.hpp>
#include<modeling/MakeEdge.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/GeometryTool.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <geometry/MakeGeom2Parabola.hpp>
#include <geometry/MakeGeom3Parabola.hpp>
#include <geometry/Geom2BezierCurve.hpp>
#include <geometry/Geom3BezierCurve.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/Geom2OffsetCurve.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
#include<catch.hpp>
#include<testHelper.h>
#include <geometry/MakeGeom2Circle.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/ComputePointsAbscissa.hpp>
#include <geometry/MakeGeom3Circle.hpp>
#include <geometry/AdaptorGeom3Curve.hpp>
#include <geometry/MakeGeom2Hyperbola.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/MakeGeom2Ellipse.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <geometry/MakeGeom3Ellipse.hpp>
#include <geometry/MakeGeom3Hyperbola.hpp>
#include <geometry/Geom2Line.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom3Line.hpp>
#include <geometry/Geom3TrimmedCurve.hpp>
#include<modeling/MakeEdge.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/GeometryTool.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <geometry/MakeGeom2Parabola.hpp>
#include <geometry/MakeGeom3Parabola.hpp>
#include <geometry/Geom2BezierCurve.hpp>
#include <geometry/Geom3BezierCurve.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/Geom2OffsetCurve.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
;
	SECTION("circle")
    {
        double r = 2.0;
        double l = -1.0;
        std::shared_ptr<Geom2Curve> c = MakeGeom2Circle(Point2(0.0, 0.0), 2.0).Value();
        AdaptorGeom2Curve circle(c);
        ComputePointsAbscissa cpa(circle, -1.0, 0.0);
        double angle1 = l / r;
        double x = r * cos(angle1);
        double y = r * sin(angle1);
        double param = cpa.Parameter();
        Point2 s = circle.Value(param);
        Point2 s1(x, y);
        CHECK(angle1 == cpa.Parameter());
        CHECK(s.X() == s1.X());
        CHECK(s.Y() == s1.Y());
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API ComputePointsAbscissa(const Adaptor3Curve& c, double abscissa, double u0, double ui)	 @param ui The initial guess of the parameter
	 @param u0 The starting parameter
	 @param abscissa The arc length
	 @param c The curve
	 @brief Compute the parameter of a point on a 3D curve with given arc length and an initial guess
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <geometry/MakeGeom2Circle.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/ComputePointsAbscissa.hpp>
#include <geometry/MakeGeom3Circle.hpp>
#include <geometry/AdaptorGeom3Curve.hpp>
#include <geometry/MakeGeom2Hyperbola.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/MakeGeom2Ellipse.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <geometry/MakeGeom3Ellipse.hpp>
#include <geometry/MakeGeom3Hyperbola.hpp>
#include <geometry/Geom2Line.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom3Line.hpp>
#include <geometry/Geom3TrimmedCurve.hpp>
#include<modeling/MakeEdge.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/GeometryTool.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <geometry/MakeGeom2Parabola.hpp>
#include <geometry/MakeGeom3Parabola.hpp>
#include <geometry/Geom2BezierCurve.hpp>
#include <geometry/Geom3BezierCurve.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/Geom2OffsetCurve.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
#include<catch.hpp>
#include<testHelper.h>
#include <geometry/MakeGeom2Circle.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/ComputePointsAbscissa.hpp>
#include <geometry/MakeGeom3Circle.hpp>
#include <geometry/AdaptorGeom3Curve.hpp>
#include <geometry/MakeGeom2Hyperbola.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/MakeGeom2Ellipse.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <geometry/MakeGeom3Ellipse.hpp>
#include <geometry/MakeGeom3Hyperbola.hpp>
#include <geometry/Geom2Line.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom3Line.hpp>
#include <geometry/Geom3TrimmedCurve.hpp>
#include<modeling/MakeEdge.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/GeometryTool.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <geometry/MakeGeom2Parabola.hpp>
#include <geometry/MakeGeom3Parabola.hpp>
#include <geometry/Geom2BezierCurve.hpp>
#include <geometry/Geom3BezierCurve.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/Geom2OffsetCurve.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
;
	SECTION("circle")
    {
        double r = 2.0;
        double l = -1.0;
        std::shared_ptr<Geom2Curve> c = MakeGeom2Circle(Point2(0.0, 0.0), 2.0).Value();
        AdaptorGeom2Curve circle(c);
        ComputePointsAbscissa cpa(circle, -1.0, 0.0);
        double angle1 = l / r;
        double x = r * cos(angle1);
        double y = r * sin(angle1);
        double param = cpa.Parameter();
        Point2 s = circle.Value(param);
        Point2 s1(x, y);
        CHECK(angle1 == cpa.Parameter());
        CHECK(s.X() == s1.X());
        CHECK(s.Y() == s1.Y());
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API ComputePointsAbscissa(const Adaptor2Curve& c, double abscissa, double u0, double ui)	 @param ui The initial guess of the parameter
	 @param u0 The starting parameter
	 @param abscissa The arc length
	 @param c The curve
	 @brief Compute the parameter of a point on a 2D curve with given arc length and an initial guess
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <geometry/MakeGeom2Circle.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/ComputePointsAbscissa.hpp>
#include <geometry/MakeGeom3Circle.hpp>
#include <geometry/AdaptorGeom3Curve.hpp>
#include <geometry/MakeGeom2Hyperbola.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/MakeGeom2Ellipse.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <geometry/MakeGeom3Ellipse.hpp>
#include <geometry/MakeGeom3Hyperbola.hpp>
#include <geometry/Geom2Line.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom3Line.hpp>
#include <geometry/Geom3TrimmedCurve.hpp>
#include<modeling/MakeEdge.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/GeometryTool.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <geometry/MakeGeom2Parabola.hpp>
#include <geometry/MakeGeom3Parabola.hpp>
#include <geometry/Geom2BezierCurve.hpp>
#include <geometry/Geom3BezierCurve.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/Geom2OffsetCurve.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
#include<catch.hpp>
#include<testHelper.h>
#include <geometry/MakeGeom2Circle.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/ComputePointsAbscissa.hpp>
#include <geometry/MakeGeom3Circle.hpp>
#include <geometry/AdaptorGeom3Curve.hpp>
#include <geometry/MakeGeom2Hyperbola.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/MakeGeom2Ellipse.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <geometry/MakeGeom3Ellipse.hpp>
#include <geometry/MakeGeom3Hyperbola.hpp>
#include <geometry/Geom2Line.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom3Line.hpp>
#include <geometry/Geom3TrimmedCurve.hpp>
#include<modeling/MakeEdge.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/GeometryTool.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <geometry/MakeGeom2Parabola.hpp>
#include <geometry/MakeGeom3Parabola.hpp>
#include <geometry/Geom2BezierCurve.hpp>
#include <geometry/Geom3BezierCurve.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/Geom2OffsetCurve.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
;
	SECTION("circle")
    {
        double r = 2.0;
        double l = -1.0;
        std::shared_ptr<Geom2Curve> c = MakeGeom2Circle(Point2(0.0, 0.0), 2.0).Value();
        AdaptorGeom2Curve circle(c);
        ComputePointsAbscissa cpa(circle, -1.0, 0.0);
        double angle1 = l / r;
        double x = r * cos(angle1);
        double y = r * sin(angle1);
        double param = cpa.Parameter();
        Point2 s = circle.Value(param);
        Point2 s1(x, y);
        CHECK(angle1 == cpa.Parameter());
        CHECK(s.X() == s1.X());
        CHECK(s.Y() == s1.Y());
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API ComputePointsAbscissa(const Adaptor3Curve& c, double abscissa, double u0, double ui, double tol)	 @param tol The tolerance
	 @param ui The initial guess of the parameter
	 @param u0 The starting parameter
	 @param abscissa The arc length
	 @param c The curve
	 @brief Compute the parameter of a point on a 3D curve with given arc length, an initial guess, and a tolerance
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <geometry/MakeGeom2Circle.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/ComputePointsAbscissa.hpp>
#include <geometry/MakeGeom3Circle.hpp>
#include <geometry/AdaptorGeom3Curve.hpp>
#include <geometry/MakeGeom2Hyperbola.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/MakeGeom2Ellipse.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <geometry/MakeGeom3Ellipse.hpp>
#include <geometry/MakeGeom3Hyperbola.hpp>
#include <geometry/Geom2Line.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom3Line.hpp>
#include <geometry/Geom3TrimmedCurve.hpp>
#include<modeling/MakeEdge.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/GeometryTool.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <geometry/MakeGeom2Parabola.hpp>
#include <geometry/MakeGeom3Parabola.hpp>
#include <geometry/Geom2BezierCurve.hpp>
#include <geometry/Geom3BezierCurve.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/Geom2OffsetCurve.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
#include<catch.hpp>
#include<testHelper.h>
#include <geometry/MakeGeom2Circle.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/ComputePointsAbscissa.hpp>
#include <geometry/MakeGeom3Circle.hpp>
#include <geometry/AdaptorGeom3Curve.hpp>
#include <geometry/MakeGeom2Hyperbola.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/MakeGeom2Ellipse.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <geometry/MakeGeom3Ellipse.hpp>
#include <geometry/MakeGeom3Hyperbola.hpp>
#include <geometry/Geom2Line.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom3Line.hpp>
#include <geometry/Geom3TrimmedCurve.hpp>
#include<modeling/MakeEdge.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/GeometryTool.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <geometry/MakeGeom2Parabola.hpp>
#include <geometry/MakeGeom3Parabola.hpp>
#include <geometry/Geom2BezierCurve.hpp>
#include <geometry/Geom3BezierCurve.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/Geom2OffsetCurve.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
;
	SECTION("circle")
    {
        double r = 2.0;
        double l = -1.0;
        std::shared_ptr<Geom2Curve> c = MakeGeom2Circle(Point2(0.0, 0.0), 2.0).Value();
        AdaptorGeom2Curve circle(c);
        ComputePointsAbscissa cpa(circle, -1.0, 0.0);
        double angle1 = l / r;
        double x = r * cos(angle1);
        double y = r * sin(angle1);
        double param = cpa.Parameter();
        Point2 s = circle.Value(param);
        Point2 s1(x, y);
        CHECK(angle1 == cpa.Parameter());
        CHECK(s.X() == s1.X());
        CHECK(s.Y() == s1.Y());
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API ComputePointsAbscissa(const Adaptor2Curve& c, double abscissa, double u0, double ui, double tol)	 @param tol The tolerance
	 @param ui The initial guess of the parameter
	 @param u0 The starting parameter
	 @param abscissa The arc length
	 @param c The curve
	 @brief Compute the parameter of a point on a 2D curve with given arc length, an initial guess, and a tolerance
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <geometry/MakeGeom2Circle.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/ComputePointsAbscissa.hpp>
#include <geometry/MakeGeom3Circle.hpp>
#include <geometry/AdaptorGeom3Curve.hpp>
#include <geometry/MakeGeom2Hyperbola.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/MakeGeom2Ellipse.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <geometry/MakeGeom3Ellipse.hpp>
#include <geometry/MakeGeom3Hyperbola.hpp>
#include <geometry/Geom2Line.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom3Line.hpp>
#include <geometry/Geom3TrimmedCurve.hpp>
#include<modeling/MakeEdge.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/GeometryTool.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <geometry/MakeGeom2Parabola.hpp>
#include <geometry/MakeGeom3Parabola.hpp>
#include <geometry/Geom2BezierCurve.hpp>
#include <geometry/Geom3BezierCurve.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/Geom2OffsetCurve.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
#include<catch.hpp>
#include<testHelper.h>
#include <geometry/MakeGeom2Circle.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/ComputePointsAbscissa.hpp>
#include <geometry/MakeGeom3Circle.hpp>
#include <geometry/AdaptorGeom3Curve.hpp>
#include <geometry/MakeGeom2Hyperbola.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/MakeGeom2Ellipse.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <geometry/MakeGeom3Ellipse.hpp>
#include <geometry/MakeGeom3Hyperbola.hpp>
#include <geometry/Geom2Line.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom3Line.hpp>
#include <geometry/Geom3TrimmedCurve.hpp>
#include<modeling/MakeEdge.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/GeometryTool.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <geometry/MakeGeom2Parabola.hpp>
#include <geometry/MakeGeom3Parabola.hpp>
#include <geometry/Geom2BezierCurve.hpp>
#include <geometry/Geom3BezierCurve.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/Geom2OffsetCurve.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
;
	SECTION("circle")
    {
        double r = 2.0;
        double l = -1.0;
        std::shared_ptr<Geom2Curve> c = MakeGeom2Circle(Point2(0.0, 0.0), 2.0).Value();
        AdaptorGeom2Curve circle(c);
        ComputePointsAbscissa cpa(circle, -1.0, 0.0);
        double angle1 = l / r;
        double x = r * cos(angle1);
        double y = r * sin(angle1);
        double param = cpa.Parameter();
        Point2 s = circle.Value(param);
        Point2 s1(x, y);
        CHECK(angle1 == cpa.Parameter());
        CHECK(s.X() == s1.X());
        CHECK(s.Y() == s1.Y());
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API double Parameter()	 @return The parameter of the point
	 @brief Get the parameter of the point
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <geometry/MakeGeom2Circle.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/ComputePointsAbscissa.hpp>
#include <geometry/MakeGeom3Circle.hpp>
#include <geometry/AdaptorGeom3Curve.hpp>
#include <geometry/MakeGeom2Hyperbola.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/MakeGeom2Ellipse.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <geometry/MakeGeom3Ellipse.hpp>
#include <geometry/MakeGeom3Hyperbola.hpp>
#include <geometry/Geom2Line.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom3Line.hpp>
#include <geometry/Geom3TrimmedCurve.hpp>
#include<modeling/MakeEdge.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/GeometryTool.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <geometry/MakeGeom2Parabola.hpp>
#include <geometry/MakeGeom3Parabola.hpp>
#include <geometry/Geom2BezierCurve.hpp>
#include <geometry/Geom3BezierCurve.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/Geom2OffsetCurve.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
#include<catch.hpp>
#include<testHelper.h>
#include <geometry/MakeGeom2Circle.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/ComputePointsAbscissa.hpp>
#include <geometry/MakeGeom3Circle.hpp>
#include <geometry/AdaptorGeom3Curve.hpp>
#include <geometry/MakeGeom2Hyperbola.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/MakeGeom2Ellipse.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <geometry/MakeGeom3Ellipse.hpp>
#include <geometry/MakeGeom3Hyperbola.hpp>
#include <geometry/Geom2Line.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom3Line.hpp>
#include <geometry/Geom3TrimmedCurve.hpp>
#include<modeling/MakeEdge.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/GeometryTool.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <geometry/MakeGeom2Parabola.hpp>
#include <geometry/MakeGeom3Parabola.hpp>
#include <geometry/Geom2BezierCurve.hpp>
#include <geometry/Geom3BezierCurve.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/Geom2OffsetCurve.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
;
	SECTION("circle")
    {
        double r = 2.0;
        double l = -1.0;
        std::shared_ptr<Geom2Curve> c = MakeGeom2Circle(Point2(0.0, 0.0), 2.0).Value();
        AdaptorGeom2Curve circle(c);
        ComputePointsAbscissa cpa(circle, -1.0, 0.0);
        double angle1 = l / r;
        double x = r * cos(angle1);
        double y = r * sin(angle1);
        double param = cpa.Parameter();
        Point2 s = circle.Value(param);
        Point2 s1(x, y);
        CHECK(angle1 == cpa.Parameter());
        CHECK(s.X() == s1.X());
        CHECK(s.Y() == s1.Y());
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static double Length(const Adaptor3Curve& c)	 @return The length of a curve
	 @param c The curve
	 @brief Compute the length of a 3D curve
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <geometry/MakeGeom2Circle.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/ComputePointsAbscissa.hpp>
#include <geometry/MakeGeom3Circle.hpp>
#include <geometry/AdaptorGeom3Curve.hpp>
#include <geometry/MakeGeom2Hyperbola.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/MakeGeom2Ellipse.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <geometry/MakeGeom3Ellipse.hpp>
#include <geometry/MakeGeom3Hyperbola.hpp>
#include <geometry/Geom2Line.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom3Line.hpp>
#include <geometry/Geom3TrimmedCurve.hpp>
#include<modeling/MakeEdge.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/GeometryTool.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <geometry/MakeGeom2Parabola.hpp>
#include <geometry/MakeGeom3Parabola.hpp>
#include <geometry/Geom2BezierCurve.hpp>
#include <geometry/Geom3BezierCurve.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/Geom2OffsetCurve.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
#include<catch.hpp>
#include<testHelper.h>
#include <geometry/MakeGeom2Circle.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/ComputePointsAbscissa.hpp>
#include <geometry/MakeGeom3Circle.hpp>
#include <geometry/AdaptorGeom3Curve.hpp>
#include <geometry/MakeGeom2Hyperbola.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/MakeGeom2Ellipse.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <geometry/MakeGeom3Ellipse.hpp>
#include <geometry/MakeGeom3Hyperbola.hpp>
#include <geometry/Geom2Line.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom3Line.hpp>
#include <geometry/Geom3TrimmedCurve.hpp>
#include<modeling/MakeEdge.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/GeometryTool.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <geometry/MakeGeom2Parabola.hpp>
#include <geometry/MakeGeom3Parabola.hpp>
#include <geometry/Geom2BezierCurve.hpp>
#include <geometry/Geom3BezierCurve.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/Geom2OffsetCurve.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
;
	SECTION("offset curve")
    {
        double r = 2.0;
        std::shared_ptr<Geom2Curve> c = MakeGeom2Circle(Point2(0.0, 0.0), 2.0).Value();
        shared_ptr<Geom2OffsetCurve> curve;
        double offset = -1.0;
        curve = make_shared<Geom2OffsetCurve>(c, offset);
        double r2 = r + offset;
        double p = 2 * M_PI * r2;
        double l = -2.0;
        AdaptorGeom2Curve offs(curve);
        ComputePointsAbscissa cpa8(Precision::Confusion(), offs, -2.0, 0.0);
        double angle1 = l / r2;
        double x = r2 * cos(angle1);
        double y = r2 * sin(angle1);
        double param8 = cpa8.Parameter();
        Point2 s = offs.Value(param8);
        Point2 s1(x, y);
        CHECK(p == ComputePointsAbscissa::Length(offs, Precision::Confusion()));
        CHECK(angle1 == Approx(cpa8.Parameter()).margin(1e-2));
        CHECK(s.X() == Approx(s1.X()).margin(1e-2));
        CHECK(s.Y() == Approx(s1.Y()).margin(1e-2));
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static double Length(const Adaptor3Curve& c, double tol)	 @return The length of a curve
	 @param tol The tolerance
	 @param c The curve
	 @brief Compute the length of a 3D curve with a tolerance
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <geometry/MakeGeom2Circle.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/ComputePointsAbscissa.hpp>
#include <geometry/MakeGeom3Circle.hpp>
#include <geometry/AdaptorGeom3Curve.hpp>
#include <geometry/MakeGeom2Hyperbola.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/MakeGeom2Ellipse.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <geometry/MakeGeom3Ellipse.hpp>
#include <geometry/MakeGeom3Hyperbola.hpp>
#include <geometry/Geom2Line.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom3Line.hpp>
#include <geometry/Geom3TrimmedCurve.hpp>
#include<modeling/MakeEdge.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/GeometryTool.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <geometry/MakeGeom2Parabola.hpp>
#include <geometry/MakeGeom3Parabola.hpp>
#include <geometry/Geom2BezierCurve.hpp>
#include <geometry/Geom3BezierCurve.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/Geom2OffsetCurve.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
#include<catch.hpp>
#include<testHelper.h>
#include <geometry/MakeGeom2Circle.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/ComputePointsAbscissa.hpp>
#include <geometry/MakeGeom3Circle.hpp>
#include <geometry/AdaptorGeom3Curve.hpp>
#include <geometry/MakeGeom2Hyperbola.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/MakeGeom2Ellipse.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <geometry/MakeGeom3Ellipse.hpp>
#include <geometry/MakeGeom3Hyperbola.hpp>
#include <geometry/Geom2Line.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom3Line.hpp>
#include <geometry/Geom3TrimmedCurve.hpp>
#include<modeling/MakeEdge.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/GeometryTool.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <geometry/MakeGeom2Parabola.hpp>
#include <geometry/MakeGeom3Parabola.hpp>
#include <geometry/Geom2BezierCurve.hpp>
#include <geometry/Geom3BezierCurve.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/Geom2OffsetCurve.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
;
	SECTION("offset curve")
    {
        double r = 2.0;
        std::shared_ptr<Geom2Curve> c = MakeGeom2Circle(Point2(0.0, 0.0), 2.0).Value();
        shared_ptr<Geom2OffsetCurve> curve;
        double offset = -1.0;
        curve = make_shared<Geom2OffsetCurve>(c, offset);
        double r2 = r + offset;
        double p = 2 * M_PI * r2;
        double l = -2.0;
        AdaptorGeom2Curve offs(curve);
        ComputePointsAbscissa cpa8(Precision::Confusion(), offs, -2.0, 0.0);
        double angle1 = l / r2;
        double x = r2 * cos(angle1);
        double y = r2 * sin(angle1);
        double param8 = cpa8.Parameter();
        Point2 s = offs.Value(param8);
        Point2 s1(x, y);
        CHECK(p == ComputePointsAbscissa::Length(offs, Precision::Confusion()));
        CHECK(angle1 == Approx(cpa8.Parameter()).margin(1e-2));
        CHECK(s.X() == Approx(s1.X()).margin(1e-2));
        CHECK(s.Y() == Approx(s1.Y()).margin(1e-2));
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API ComputePointsAbscissa(double tol, const Adaptor3Curve& c, double abscissa, double u0)	 @param u0 The starting parameter
	 @param abscissa The arc length
	 @param c The curve
	 @param tol The tolerance
	 @brief Compute the parameter of a point on a 3D curve with given arc length and a tolerance
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <geometry/MakeGeom2Circle.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/ComputePointsAbscissa.hpp>
#include <geometry/MakeGeom3Circle.hpp>
#include <geometry/AdaptorGeom3Curve.hpp>
#include <geometry/MakeGeom2Hyperbola.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/MakeGeom2Ellipse.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <geometry/MakeGeom3Ellipse.hpp>
#include <geometry/MakeGeom3Hyperbola.hpp>
#include <geometry/Geom2Line.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom3Line.hpp>
#include <geometry/Geom3TrimmedCurve.hpp>
#include<modeling/MakeEdge.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/GeometryTool.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <geometry/MakeGeom2Parabola.hpp>
#include <geometry/MakeGeom3Parabola.hpp>
#include <geometry/Geom2BezierCurve.hpp>
#include <geometry/Geom3BezierCurve.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/Geom2OffsetCurve.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
#include<catch.hpp>
#include<testHelper.h>
#include <geometry/MakeGeom2Circle.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/ComputePointsAbscissa.hpp>
#include <geometry/MakeGeom3Circle.hpp>
#include <geometry/AdaptorGeom3Curve.hpp>
#include <geometry/MakeGeom2Hyperbola.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/MakeGeom2Ellipse.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <geometry/MakeGeom3Ellipse.hpp>
#include <geometry/MakeGeom3Hyperbola.hpp>
#include <geometry/Geom2Line.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom3Line.hpp>
#include <geometry/Geom3TrimmedCurve.hpp>
#include<modeling/MakeEdge.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/GeometryTool.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <geometry/MakeGeom2Parabola.hpp>
#include <geometry/MakeGeom3Parabola.hpp>
#include <geometry/Geom2BezierCurve.hpp>
#include <geometry/Geom3BezierCurve.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/Geom2OffsetCurve.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
;
	SECTION("circle")
    {
        double r = 2.0;
        double l = 19;
        std::shared_ptr<Geom2Curve> c = MakeGeom2Circle(Point2(0.0, 0.0), 2.0).Value();
        AdaptorGeom2Curve circle(c);
        ComputePointsAbscissa cpa(circle, l, 0.0);
        double angle1 = l / r;
        double x = r * cos(angle1);
        double y = r * sin(angle1);
        double param = cpa.Parameter();
        Point2 s = circle.Value(param);
        Point2 s1(x, y);
        CHECK(angle1 == cpa.Parameter());
        CHECK(s.X() == s1.X());
        CHECK(s.Y() == s1.Y());
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API ComputePointsAbscissa(double tol, const Adaptor2Curve& c, double abscissa, double u0)	 @param u0 The starting parameter
	 @param abscissa The arc length
	 @param c The curve
	 @param tol The tolerance
	 @brief Compute the parameter of a point on a 2D curve with given arc length and a tolerance
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <geometry/MakeGeom2Circle.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/ComputePointsAbscissa.hpp>
#include <geometry/MakeGeom3Circle.hpp>
#include <geometry/AdaptorGeom3Curve.hpp>
#include <geometry/MakeGeom2Hyperbola.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/MakeGeom2Ellipse.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <geometry/MakeGeom3Ellipse.hpp>
#include <geometry/MakeGeom3Hyperbola.hpp>
#include <geometry/Geom2Line.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom3Line.hpp>
#include <geometry/Geom3TrimmedCurve.hpp>
#include<modeling/MakeEdge.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/GeometryTool.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <geometry/MakeGeom2Parabola.hpp>
#include <geometry/MakeGeom3Parabola.hpp>
#include <geometry/Geom2BezierCurve.hpp>
#include <geometry/Geom3BezierCurve.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/Geom2OffsetCurve.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
#include<catch.hpp>
#include<testHelper.h>
#include <geometry/MakeGeom2Circle.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/ComputePointsAbscissa.hpp>
#include <geometry/MakeGeom3Circle.hpp>
#include <geometry/AdaptorGeom3Curve.hpp>
#include <geometry/MakeGeom2Hyperbola.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/MakeGeom2Ellipse.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <geometry/MakeGeom3Ellipse.hpp>
#include <geometry/MakeGeom3Hyperbola.hpp>
#include <geometry/Geom2Line.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom3Line.hpp>
#include <geometry/Geom3TrimmedCurve.hpp>
#include<modeling/MakeEdge.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/GeometryTool.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <geometry/MakeGeom2Parabola.hpp>
#include <geometry/MakeGeom3Parabola.hpp>
#include <geometry/Geom2BezierCurve.hpp>
#include <geometry/Geom3BezierCurve.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/Geom2OffsetCurve.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
;
	SECTION("circle")
    {
        double r = 2.0;
        double l = 19;
        std::shared_ptr<Geom2Curve> c = MakeGeom2Circle(Point2(0.0, 0.0), 2.0).Value();
        AdaptorGeom2Curve circle(c);
        ComputePointsAbscissa cpa(circle, l, 0.0);
        double angle1 = l / r;
        double x = r * cos(angle1);
        double y = r * sin(angle1);
        double param = cpa.Parameter();
        Point2 s = circle.Value(param);
        Point2 s1(x, y);
        CHECK(angle1 == cpa.Parameter());
        CHECK(s.X() == s1.X());
        CHECK(s.Y() == s1.Y());
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API ComputePointsAbscissa(const Adaptor3Curve& c, double abscissa, double u0)	 @param u0 The starting parameter
	 @param abscissa The arc length
	 @param c The curve
	 @brief Compute the parameter of a point on a 3D curve with given arc length
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <geometry/MakeGeom2Circle.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/ComputePointsAbscissa.hpp>
#include <geometry/MakeGeom3Circle.hpp>
#include <geometry/AdaptorGeom3Curve.hpp>
#include <geometry/MakeGeom2Hyperbola.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/MakeGeom2Ellipse.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <geometry/MakeGeom3Ellipse.hpp>
#include <geometry/MakeGeom3Hyperbola.hpp>
#include <geometry/Geom2Line.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom3Line.hpp>
#include <geometry/Geom3TrimmedCurve.hpp>
#include<modeling/MakeEdge.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/GeometryTool.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <geometry/MakeGeom2Parabola.hpp>
#include <geometry/MakeGeom3Parabola.hpp>
#include <geometry/Geom2BezierCurve.hpp>
#include <geometry/Geom3BezierCurve.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/Geom2OffsetCurve.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
#include<catch.hpp>
#include<testHelper.h>
#include <geometry/MakeGeom2Circle.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/ComputePointsAbscissa.hpp>
#include <geometry/MakeGeom3Circle.hpp>
#include <geometry/AdaptorGeom3Curve.hpp>
#include <geometry/MakeGeom2Hyperbola.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/MakeGeom2Ellipse.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <geometry/MakeGeom3Ellipse.hpp>
#include <geometry/MakeGeom3Hyperbola.hpp>
#include <geometry/Geom2Line.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom3Line.hpp>
#include <geometry/Geom3TrimmedCurve.hpp>
#include<modeling/MakeEdge.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/GeometryTool.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <geometry/MakeGeom2Parabola.hpp>
#include <geometry/MakeGeom3Parabola.hpp>
#include <geometry/Geom2BezierCurve.hpp>
#include <geometry/Geom3BezierCurve.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/Geom2OffsetCurve.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
;
	SECTION("circle")
    {
        double r = 2.0;
        double l = 19;
        std::shared_ptr<Geom2Curve> c = MakeGeom2Circle(Point2(0.0, 0.0), 2.0).Value();
        AdaptorGeom2Curve circle(c);
        ComputePointsAbscissa cpa(circle, l, 0.0);
        double angle1 = l / r;
        double x = r * cos(angle1);
        double y = r * sin(angle1);
        double param = cpa.Parameter();
        Point2 s = circle.Value(param);
        Point2 s1(x, y);
        CHECK(angle1 == cpa.Parameter());
        CHECK(s.X() == s1.X());
        CHECK(s.Y() == s1.Y());
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API ComputePointsAbscissa(const Adaptor2Curve& c, double abscissa, double u0)	 @param u0 The starting parameter
	 @param abscissa The arc length
	 @param c The curve
	 @brief Compute the parameter of a point on a 2D curve with given arc length
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <geometry/MakeGeom2Circle.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/ComputePointsAbscissa.hpp>
#include <geometry/MakeGeom3Circle.hpp>
#include <geometry/AdaptorGeom3Curve.hpp>
#include <geometry/MakeGeom2Hyperbola.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/MakeGeom2Ellipse.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <geometry/MakeGeom3Ellipse.hpp>
#include <geometry/MakeGeom3Hyperbola.hpp>
#include <geometry/Geom2Line.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom3Line.hpp>
#include <geometry/Geom3TrimmedCurve.hpp>
#include<modeling/MakeEdge.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/GeometryTool.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <geometry/MakeGeom2Parabola.hpp>
#include <geometry/MakeGeom3Parabola.hpp>
#include <geometry/Geom2BezierCurve.hpp>
#include <geometry/Geom3BezierCurve.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/Geom2OffsetCurve.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
#include<catch.hpp>
#include<testHelper.h>
#include <geometry/MakeGeom2Circle.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/ComputePointsAbscissa.hpp>
#include <geometry/MakeGeom3Circle.hpp>
#include <geometry/AdaptorGeom3Curve.hpp>
#include <geometry/MakeGeom2Hyperbola.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/MakeGeom2Ellipse.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <geometry/MakeGeom3Ellipse.hpp>
#include <geometry/MakeGeom3Hyperbola.hpp>
#include <geometry/Geom2Line.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom3Line.hpp>
#include <geometry/Geom3TrimmedCurve.hpp>
#include<modeling/MakeEdge.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/GeometryTool.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <geometry/MakeGeom2Parabola.hpp>
#include <geometry/MakeGeom3Parabola.hpp>
#include <geometry/Geom2BezierCurve.hpp>
#include <geometry/Geom3BezierCurve.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/Geom2OffsetCurve.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
;
	SECTION("circle")
    {
        double r = 2.0;
        double l = 19;
        std::shared_ptr<Geom2Curve> c = MakeGeom2Circle(Point2(0.0, 0.0), 2.0).Value();
        AdaptorGeom2Curve circle(c);
        ComputePointsAbscissa cpa(circle, l, 0.0);
        double angle1 = l / r;
        double x = r * cos(angle1);
        double y = r * sin(angle1);
        double param = cpa.Parameter();
        Point2 s = circle.Value(param);
        Point2 s1(x, y);
        CHECK(angle1 == cpa.Parameter());
        CHECK(s.X() == s1.X());
        CHECK(s.Y() == s1.Y());
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API ComputePointsAbscissa(const Adaptor3Curve& c, double abscissa, double u0, double ui)	 @param ui The initial guess of the parameter
	 @param u0 The starting parameter
	 @param abscissa The arc length
	 @param c The curve
	 @brief Compute the parameter of a point on a 3D curve with given arc length and an initial guess
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <geometry/MakeGeom2Circle.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/ComputePointsAbscissa.hpp>
#include <geometry/MakeGeom3Circle.hpp>
#include <geometry/AdaptorGeom3Curve.hpp>
#include <geometry/MakeGeom2Hyperbola.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/MakeGeom2Ellipse.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <geometry/MakeGeom3Ellipse.hpp>
#include <geometry/MakeGeom3Hyperbola.hpp>
#include <geometry/Geom2Line.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom3Line.hpp>
#include <geometry/Geom3TrimmedCurve.hpp>
#include<modeling/MakeEdge.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/GeometryTool.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <geometry/MakeGeom2Parabola.hpp>
#include <geometry/MakeGeom3Parabola.hpp>
#include <geometry/Geom2BezierCurve.hpp>
#include <geometry/Geom3BezierCurve.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/Geom2OffsetCurve.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
#include<catch.hpp>
#include<testHelper.h>
#include <geometry/MakeGeom2Circle.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/ComputePointsAbscissa.hpp>
#include <geometry/MakeGeom3Circle.hpp>
#include <geometry/AdaptorGeom3Curve.hpp>
#include <geometry/MakeGeom2Hyperbola.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/MakeGeom2Ellipse.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <geometry/MakeGeom3Ellipse.hpp>
#include <geometry/MakeGeom3Hyperbola.hpp>
#include <geometry/Geom2Line.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom3Line.hpp>
#include <geometry/Geom3TrimmedCurve.hpp>
#include<modeling/MakeEdge.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/GeometryTool.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <geometry/MakeGeom2Parabola.hpp>
#include <geometry/MakeGeom3Parabola.hpp>
#include <geometry/Geom2BezierCurve.hpp>
#include <geometry/Geom3BezierCurve.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/Geom2OffsetCurve.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
;
	SECTION("circle")
    {
        double r = 2.0;
        double l = 19;
        std::shared_ptr<Geom2Curve> c = MakeGeom2Circle(Point2(0.0, 0.0), 2.0).Value();
        AdaptorGeom2Curve circle(c);
        ComputePointsAbscissa cpa(circle, l, 0.0);
        double angle1 = l / r;
        double x = r * cos(angle1);
        double y = r * sin(angle1);
        double param = cpa.Parameter();
        Point2 s = circle.Value(param);
        Point2 s1(x, y);
        CHECK(angle1 == cpa.Parameter());
        CHECK(s.X() == s1.X());
        CHECK(s.Y() == s1.Y());
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API ComputePointsAbscissa(const Adaptor2Curve& c, double abscissa, double u0, double ui)	 @param ui The initial guess of the parameter
	 @param u0 The starting parameter
	 @param abscissa The arc length
	 @param c The curve
	 @brief Compute the parameter of a point on a 2D curve with given arc length and an initial guess
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <geometry/MakeGeom2Circle.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/ComputePointsAbscissa.hpp>
#include <geometry/MakeGeom3Circle.hpp>
#include <geometry/AdaptorGeom3Curve.hpp>
#include <geometry/MakeGeom2Hyperbola.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/MakeGeom2Ellipse.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <geometry/MakeGeom3Ellipse.hpp>
#include <geometry/MakeGeom3Hyperbola.hpp>
#include <geometry/Geom2Line.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom3Line.hpp>
#include <geometry/Geom3TrimmedCurve.hpp>
#include<modeling/MakeEdge.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/GeometryTool.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <geometry/MakeGeom2Parabola.hpp>
#include <geometry/MakeGeom3Parabola.hpp>
#include <geometry/Geom2BezierCurve.hpp>
#include <geometry/Geom3BezierCurve.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/Geom2OffsetCurve.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
#include<catch.hpp>
#include<testHelper.h>
#include <geometry/MakeGeom2Circle.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/ComputePointsAbscissa.hpp>
#include <geometry/MakeGeom3Circle.hpp>
#include <geometry/AdaptorGeom3Curve.hpp>
#include <geometry/MakeGeom2Hyperbola.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/MakeGeom2Ellipse.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <geometry/MakeGeom3Ellipse.hpp>
#include <geometry/MakeGeom3Hyperbola.hpp>
#include <geometry/Geom2Line.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom3Line.hpp>
#include <geometry/Geom3TrimmedCurve.hpp>
#include<modeling/MakeEdge.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/GeometryTool.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <geometry/MakeGeom2Parabola.hpp>
#include <geometry/MakeGeom3Parabola.hpp>
#include <geometry/Geom2BezierCurve.hpp>
#include <geometry/Geom3BezierCurve.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/Geom2OffsetCurve.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
;
	SECTION("circle")
    {
        double r = 2.0;
        double l = 19;
        std::shared_ptr<Geom2Curve> c = MakeGeom2Circle(Point2(0.0, 0.0), 2.0).Value();
        AdaptorGeom2Curve circle(c);
        ComputePointsAbscissa cpa(circle, l, 0.0);
        double angle1 = l / r;
        double x = r * cos(angle1);
        double y = r * sin(angle1);
        double param = cpa.Parameter();
        Point2 s = circle.Value(param);
        Point2 s1(x, y);
        CHECK(angle1 == cpa.Parameter());
        CHECK(s.X() == s1.X());
        CHECK(s.Y() == s1.Y());
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API ComputePointsAbscissa(const Adaptor3Curve& c, double abscissa, double u0, double ui, double tol)	 @param tol The tolerance
	 @param ui The initial guess of the parameter
	 @param u0 The starting parameter
	 @param abscissa The arc length
	 @param c The curve
	 @brief Compute the parameter of a point on a 3D curve with given arc length, an initial guess, and a tolerance
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <geometry/MakeGeom2Circle.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/ComputePointsAbscissa.hpp>
#include <geometry/MakeGeom3Circle.hpp>
#include <geometry/AdaptorGeom3Curve.hpp>
#include <geometry/MakeGeom2Hyperbola.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/MakeGeom2Ellipse.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <geometry/MakeGeom3Ellipse.hpp>
#include <geometry/MakeGeom3Hyperbola.hpp>
#include <geometry/Geom2Line.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom3Line.hpp>
#include <geometry/Geom3TrimmedCurve.hpp>
#include<modeling/MakeEdge.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/GeometryTool.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <geometry/MakeGeom2Parabola.hpp>
#include <geometry/MakeGeom3Parabola.hpp>
#include <geometry/Geom2BezierCurve.hpp>
#include <geometry/Geom3BezierCurve.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/Geom2OffsetCurve.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
#include<catch.hpp>
#include<testHelper.h>
#include <geometry/MakeGeom2Circle.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/ComputePointsAbscissa.hpp>
#include <geometry/MakeGeom3Circle.hpp>
#include <geometry/AdaptorGeom3Curve.hpp>
#include <geometry/MakeGeom2Hyperbola.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/MakeGeom2Ellipse.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <geometry/MakeGeom3Ellipse.hpp>
#include <geometry/MakeGeom3Hyperbola.hpp>
#include <geometry/Geom2Line.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom3Line.hpp>
#include <geometry/Geom3TrimmedCurve.hpp>
#include<modeling/MakeEdge.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/GeometryTool.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <geometry/MakeGeom2Parabola.hpp>
#include <geometry/MakeGeom3Parabola.hpp>
#include <geometry/Geom2BezierCurve.hpp>
#include <geometry/Geom3BezierCurve.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/Geom2OffsetCurve.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
;
	SECTION("circle")
    {
        double r = 2.0;
        double l = 19;
        std::shared_ptr<Geom2Curve> c = MakeGeom2Circle(Point2(0.0, 0.0), 2.0).Value();
        AdaptorGeom2Curve circle(c);
        ComputePointsAbscissa cpa(circle, l, 0.0);
        double angle1 = l / r;
        double x = r * cos(angle1);
        double y = r * sin(angle1);
        double param = cpa.Parameter();
        Point2 s = circle.Value(param);
        Point2 s1(x, y);
        CHECK(angle1 == cpa.Parameter());
        CHECK(s.X() == s1.X());
        CHECK(s.Y() == s1.Y());
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API ComputePointsAbscissa(const Adaptor2Curve& c, double abscissa, double u0, double ui, double tol)	 @param tol The tolerance
	 @param ui The initial guess of the parameter
	 @param u0 The starting parameter
	 @param abscissa The arc length
	 @param c The curve
	 @brief Compute the parameter of a point on a 2D curve with given arc length, an initial guess, and a tolerance
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <geometry/MakeGeom2Circle.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/ComputePointsAbscissa.hpp>
#include <geometry/MakeGeom3Circle.hpp>
#include <geometry/AdaptorGeom3Curve.hpp>
#include <geometry/MakeGeom2Hyperbola.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/MakeGeom2Ellipse.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <geometry/MakeGeom3Ellipse.hpp>
#include <geometry/MakeGeom3Hyperbola.hpp>
#include <geometry/Geom2Line.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom3Line.hpp>
#include <geometry/Geom3TrimmedCurve.hpp>
#include<modeling/MakeEdge.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/GeometryTool.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <geometry/MakeGeom2Parabola.hpp>
#include <geometry/MakeGeom3Parabola.hpp>
#include <geometry/Geom2BezierCurve.hpp>
#include <geometry/Geom3BezierCurve.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/Geom2OffsetCurve.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
#include<catch.hpp>
#include<testHelper.h>
#include <geometry/MakeGeom2Circle.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/ComputePointsAbscissa.hpp>
#include <geometry/MakeGeom3Circle.hpp>
#include <geometry/AdaptorGeom3Curve.hpp>
#include <geometry/MakeGeom2Hyperbola.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/MakeGeom2Ellipse.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <geometry/MakeGeom3Ellipse.hpp>
#include <geometry/MakeGeom3Hyperbola.hpp>
#include <geometry/Geom2Line.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom3Line.hpp>
#include <geometry/Geom3TrimmedCurve.hpp>
#include<modeling/MakeEdge.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/GeometryTool.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <geometry/MakeGeom2Parabola.hpp>
#include <geometry/MakeGeom3Parabola.hpp>
#include <geometry/Geom2BezierCurve.hpp>
#include <geometry/Geom3BezierCurve.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/Geom2OffsetCurve.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
;
	SECTION("circle")
    {
        double r = 2.0;
        double l = 19;
        std::shared_ptr<Geom2Curve> c = MakeGeom2Circle(Point2(0.0, 0.0), 2.0).Value();
        AdaptorGeom2Curve circle(c);
        ComputePointsAbscissa cpa(circle, l, 0.0);
        double angle1 = l / r;
        double x = r * cos(angle1);
        double y = r * sin(angle1);
        double param = cpa.Parameter();
        Point2 s = circle.Value(param);
        Point2 s1(x, y);
        CHECK(angle1 == cpa.Parameter());
        CHECK(s.X() == s1.X());
        CHECK(s.Y() == s1.Y());
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API double Parameter()	 @return The parameter of the point
	 @brief Get the parameter of the point
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <geometry/MakeGeom2Circle.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/ComputePointsAbscissa.hpp>
#include <geometry/MakeGeom3Circle.hpp>
#include <geometry/AdaptorGeom3Curve.hpp>
#include <geometry/MakeGeom2Hyperbola.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/MakeGeom2Ellipse.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <geometry/MakeGeom3Ellipse.hpp>
#include <geometry/MakeGeom3Hyperbola.hpp>
#include <geometry/Geom2Line.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom3Line.hpp>
#include <geometry/Geom3TrimmedCurve.hpp>
#include<modeling/MakeEdge.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/GeometryTool.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <geometry/MakeGeom2Parabola.hpp>
#include <geometry/MakeGeom3Parabola.hpp>
#include <geometry/Geom2BezierCurve.hpp>
#include <geometry/Geom3BezierCurve.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/Geom2OffsetCurve.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
#include<catch.hpp>
#include<testHelper.h>
#include <geometry/MakeGeom2Circle.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/ComputePointsAbscissa.hpp>
#include <geometry/MakeGeom3Circle.hpp>
#include <geometry/AdaptorGeom3Curve.hpp>
#include <geometry/MakeGeom2Hyperbola.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/MakeGeom2Ellipse.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <geometry/MakeGeom3Ellipse.hpp>
#include <geometry/MakeGeom3Hyperbola.hpp>
#include <geometry/Geom2Line.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom3Line.hpp>
#include <geometry/Geom3TrimmedCurve.hpp>
#include<modeling/MakeEdge.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/GeometryTool.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <geometry/MakeGeom2Parabola.hpp>
#include <geometry/MakeGeom3Parabola.hpp>
#include <geometry/Geom2BezierCurve.hpp>
#include <geometry/Geom3BezierCurve.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/Geom2OffsetCurve.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
;
	SECTION("line")
    {
        shared_ptr<Geom2Line> line;
        line = make_shared<Geom2Line>(Point2(0.0, 0.0), Direction2(1.0, 0.0));
        shared_ptr<Geom2TrimmedCurve> TrimmedCurve = make_shared<Geom2TrimmedCurve>(line, 0.0, 6.0);
        AdaptorGeom2Curve line1(TrimmedCurve);
        ComputePointsAbscissa cpa4(line1, 8.0, 0.0);
        double param4 = cpa4.Parameter();
        double x = 8.0;
        double y = 0.0;
        Point2 s5 = line1.Value(param4);
        Point2 s6(x, y);
        CHECK(cpa4.Parameter() == 8.0);
        CHECK(s5.X() == s6.X());
        CHECK(s5.Y() == s6.Y());
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API ComputePointsAbscissa(double tol, const Adaptor3Curve& c, double abscissa, double u0)	 @param u0 The starting parameter
	 @param abscissa The arc length
	 @param c The curve
	 @param tol The tolerance
	 @brief Compute the parameter of a point on a 3D curve with given arc length and a tolerance
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <geometry/MakeGeom2Circle.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/ComputePointsAbscissa.hpp>
#include <geometry/MakeGeom3Circle.hpp>
#include <geometry/AdaptorGeom3Curve.hpp>
#include <geometry/MakeGeom2Hyperbola.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/MakeGeom2Ellipse.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <geometry/MakeGeom3Ellipse.hpp>
#include <geometry/MakeGeom3Hyperbola.hpp>
#include <geometry/Geom2Line.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom3Line.hpp>
#include <geometry/Geom3TrimmedCurve.hpp>
#include<modeling/MakeEdge.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/GeometryTool.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <geometry/MakeGeom2Parabola.hpp>
#include <geometry/MakeGeom3Parabola.hpp>
#include <geometry/Geom2BezierCurve.hpp>
#include <geometry/Geom3BezierCurve.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/Geom2OffsetCurve.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
#include<catch.hpp>
#include<testHelper.h>
#include <geometry/MakeGeom2Circle.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/ComputePointsAbscissa.hpp>
#include <geometry/MakeGeom3Circle.hpp>
#include <geometry/AdaptorGeom3Curve.hpp>
#include <geometry/MakeGeom2Hyperbola.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/MakeGeom2Ellipse.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <geometry/MakeGeom3Ellipse.hpp>
#include <geometry/MakeGeom3Hyperbola.hpp>
#include <geometry/Geom2Line.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom3Line.hpp>
#include <geometry/Geom3TrimmedCurve.hpp>
#include<modeling/MakeEdge.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/GeometryTool.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <geometry/MakeGeom2Parabola.hpp>
#include <geometry/MakeGeom3Parabola.hpp>
#include <geometry/Geom2BezierCurve.hpp>
#include <geometry/Geom3BezierCurve.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/Geom2OffsetCurve.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
;
	SECTION("circle")
    {
        double r = 2.0;
        double l = 0.0;
        std::shared_ptr<Geom2Curve> c = MakeGeom2Circle(Point2(0.0, 0.0), 2.0).Value();
        AdaptorGeom2Curve circle(c);
        ComputePointsAbscissa cpa(circle, 0.0, 0.0);
        double angle1 = l / r;
        double x = r * cos(angle1);
        double y = r * sin(angle1);
        double param = cpa.Parameter();
        Point2 s = circle.Value(param);
        Point2 s1(x, y);
        CHECK(angle1 == cpa.Parameter());
        CHECK(s.X() == s1.X());
        CHECK(s.Y() == s1.Y());
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API ComputePointsAbscissa(double tol, const Adaptor2Curve& c, double abscissa, double u0)	 @param u0 The starting parameter
	 @param abscissa The arc length
	 @param c The curve
	 @param tol The tolerance
	 @brief Compute the parameter of a point on a 2D curve with given arc length and a tolerance
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <geometry/MakeGeom2Circle.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/ComputePointsAbscissa.hpp>
#include <geometry/MakeGeom3Circle.hpp>
#include <geometry/AdaptorGeom3Curve.hpp>
#include <geometry/MakeGeom2Hyperbola.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/MakeGeom2Ellipse.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <geometry/MakeGeom3Ellipse.hpp>
#include <geometry/MakeGeom3Hyperbola.hpp>
#include <geometry/Geom2Line.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom3Line.hpp>
#include <geometry/Geom3TrimmedCurve.hpp>
#include<modeling/MakeEdge.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/GeometryTool.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <geometry/MakeGeom2Parabola.hpp>
#include <geometry/MakeGeom3Parabola.hpp>
#include <geometry/Geom2BezierCurve.hpp>
#include <geometry/Geom3BezierCurve.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/Geom2OffsetCurve.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
#include<catch.hpp>
#include<testHelper.h>
#include <geometry/MakeGeom2Circle.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/ComputePointsAbscissa.hpp>
#include <geometry/MakeGeom3Circle.hpp>
#include <geometry/AdaptorGeom3Curve.hpp>
#include <geometry/MakeGeom2Hyperbola.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/MakeGeom2Ellipse.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <geometry/MakeGeom3Ellipse.hpp>
#include <geometry/MakeGeom3Hyperbola.hpp>
#include <geometry/Geom2Line.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom3Line.hpp>
#include <geometry/Geom3TrimmedCurve.hpp>
#include<modeling/MakeEdge.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/GeometryTool.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <geometry/MakeGeom2Parabola.hpp>
#include <geometry/MakeGeom3Parabola.hpp>
#include <geometry/Geom2BezierCurve.hpp>
#include <geometry/Geom3BezierCurve.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/Geom2OffsetCurve.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
;
	SECTION("circle")
    {
        double r = 2.0;
        double l = 0.0;
        std::shared_ptr<Geom2Curve> c = MakeGeom2Circle(Point2(0.0, 0.0), 2.0).Value();
        AdaptorGeom2Curve circle(c);
        ComputePointsAbscissa cpa(circle, 0.0, 0.0);
        double angle1 = l / r;
        double x = r * cos(angle1);
        double y = r * sin(angle1);
        double param = cpa.Parameter();
        Point2 s = circle.Value(param);
        Point2 s1(x, y);
        CHECK(angle1 == cpa.Parameter());
        CHECK(s.X() == s1.X());
        CHECK(s.Y() == s1.Y());
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API ComputePointsAbscissa(const Adaptor3Curve& c, double abscissa, double u0)	 @param u0 The starting parameter
	 @param abscissa The arc length
	 @param c The curve
	 @brief Compute the parameter of a point on a 3D curve with given arc length
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <geometry/MakeGeom2Circle.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/ComputePointsAbscissa.hpp>
#include <geometry/MakeGeom3Circle.hpp>
#include <geometry/AdaptorGeom3Curve.hpp>
#include <geometry/MakeGeom2Hyperbola.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/MakeGeom2Ellipse.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <geometry/MakeGeom3Ellipse.hpp>
#include <geometry/MakeGeom3Hyperbola.hpp>
#include <geometry/Geom2Line.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom3Line.hpp>
#include <geometry/Geom3TrimmedCurve.hpp>
#include<modeling/MakeEdge.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/GeometryTool.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <geometry/MakeGeom2Parabola.hpp>
#include <geometry/MakeGeom3Parabola.hpp>
#include <geometry/Geom2BezierCurve.hpp>
#include <geometry/Geom3BezierCurve.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/Geom2OffsetCurve.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
#include<catch.hpp>
#include<testHelper.h>
#include <geometry/MakeGeom2Circle.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/ComputePointsAbscissa.hpp>
#include <geometry/MakeGeom3Circle.hpp>
#include <geometry/AdaptorGeom3Curve.hpp>
#include <geometry/MakeGeom2Hyperbola.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/MakeGeom2Ellipse.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <geometry/MakeGeom3Ellipse.hpp>
#include <geometry/MakeGeom3Hyperbola.hpp>
#include <geometry/Geom2Line.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom3Line.hpp>
#include <geometry/Geom3TrimmedCurve.hpp>
#include<modeling/MakeEdge.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/GeometryTool.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <geometry/MakeGeom2Parabola.hpp>
#include <geometry/MakeGeom3Parabola.hpp>
#include <geometry/Geom2BezierCurve.hpp>
#include <geometry/Geom3BezierCurve.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/Geom2OffsetCurve.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
;
	SECTION("circle")
    {
        double r = 2.0;
        double l = 0.0;
        std::shared_ptr<Geom2Curve> c = MakeGeom2Circle(Point2(0.0, 0.0), 2.0).Value();
        AdaptorGeom2Curve circle(c);
        ComputePointsAbscissa cpa(circle, 0.0, 0.0);
        double angle1 = l / r;
        double x = r * cos(angle1);
        double y = r * sin(angle1);
        double param = cpa.Parameter();
        Point2 s = circle.Value(param);
        Point2 s1(x, y);
        CHECK(angle1 == cpa.Parameter());
        CHECK(s.X() == s1.X());
        CHECK(s.Y() == s1.Y());
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API ComputePointsAbscissa(const Adaptor2Curve& c, double abscissa, double u0)	 @param u0 The starting parameter
	 @param abscissa The arc length
	 @param c The curve
	 @brief Compute the parameter of a point on a 2D curve with given arc length
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <geometry/MakeGeom2Circle.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/ComputePointsAbscissa.hpp>
#include <geometry/MakeGeom3Circle.hpp>
#include <geometry/AdaptorGeom3Curve.hpp>
#include <geometry/MakeGeom2Hyperbola.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/MakeGeom2Ellipse.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <geometry/MakeGeom3Ellipse.hpp>
#include <geometry/MakeGeom3Hyperbola.hpp>
#include <geometry/Geom2Line.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom3Line.hpp>
#include <geometry/Geom3TrimmedCurve.hpp>
#include<modeling/MakeEdge.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/GeometryTool.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <geometry/MakeGeom2Parabola.hpp>
#include <geometry/MakeGeom3Parabola.hpp>
#include <geometry/Geom2BezierCurve.hpp>
#include <geometry/Geom3BezierCurve.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/Geom2OffsetCurve.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
#include<catch.hpp>
#include<testHelper.h>
#include <geometry/MakeGeom2Circle.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/ComputePointsAbscissa.hpp>
#include <geometry/MakeGeom3Circle.hpp>
#include <geometry/AdaptorGeom3Curve.hpp>
#include <geometry/MakeGeom2Hyperbola.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/MakeGeom2Ellipse.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <geometry/MakeGeom3Ellipse.hpp>
#include <geometry/MakeGeom3Hyperbola.hpp>
#include <geometry/Geom2Line.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom3Line.hpp>
#include <geometry/Geom3TrimmedCurve.hpp>
#include<modeling/MakeEdge.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/GeometryTool.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <geometry/MakeGeom2Parabola.hpp>
#include <geometry/MakeGeom3Parabola.hpp>
#include <geometry/Geom2BezierCurve.hpp>
#include <geometry/Geom3BezierCurve.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/Geom2OffsetCurve.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
;
	SECTION("circle")
    {
        double r = 2.0;
        double l = 0.0;
        std::shared_ptr<Geom2Curve> c = MakeGeom2Circle(Point2(0.0, 0.0), 2.0).Value();
        AdaptorGeom2Curve circle(c);
        ComputePointsAbscissa cpa(circle, 0.0, 0.0);
        double angle1 = l / r;
        double x = r * cos(angle1);
        double y = r * sin(angle1);
        double param = cpa.Parameter();
        Point2 s = circle.Value(param);
        Point2 s1(x, y);
        CHECK(angle1 == cpa.Parameter());
        CHECK(s.X() == s1.X());
        CHECK(s.Y() == s1.Y());
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API ComputePointsAbscissa(const Adaptor3Curve& c, double abscissa, double u0, double ui)	 @param ui The initial guess of the parameter
	 @param u0 The starting parameter
	 @param abscissa The arc length
	 @param c The curve
	 @brief Compute the parameter of a point on a 3D curve with given arc length and an initial guess
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <geometry/MakeGeom2Circle.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/ComputePointsAbscissa.hpp>
#include <geometry/MakeGeom3Circle.hpp>
#include <geometry/AdaptorGeom3Curve.hpp>
#include <geometry/MakeGeom2Hyperbola.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/MakeGeom2Ellipse.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <geometry/MakeGeom3Ellipse.hpp>
#include <geometry/MakeGeom3Hyperbola.hpp>
#include <geometry/Geom2Line.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom3Line.hpp>
#include <geometry/Geom3TrimmedCurve.hpp>
#include<modeling/MakeEdge.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/GeometryTool.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <geometry/MakeGeom2Parabola.hpp>
#include <geometry/MakeGeom3Parabola.hpp>
#include <geometry/Geom2BezierCurve.hpp>
#include <geometry/Geom3BezierCurve.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/Geom2OffsetCurve.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
#include<catch.hpp>
#include<testHelper.h>
#include <geometry/MakeGeom2Circle.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/ComputePointsAbscissa.hpp>
#include <geometry/MakeGeom3Circle.hpp>
#include <geometry/AdaptorGeom3Curve.hpp>
#include <geometry/MakeGeom2Hyperbola.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/MakeGeom2Ellipse.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <geometry/MakeGeom3Ellipse.hpp>
#include <geometry/MakeGeom3Hyperbola.hpp>
#include <geometry/Geom2Line.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom3Line.hpp>
#include <geometry/Geom3TrimmedCurve.hpp>
#include<modeling/MakeEdge.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/GeometryTool.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <geometry/MakeGeom2Parabola.hpp>
#include <geometry/MakeGeom3Parabola.hpp>
#include <geometry/Geom2BezierCurve.hpp>
#include <geometry/Geom3BezierCurve.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/Geom2OffsetCurve.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
;
	SECTION("circle")
    {
        double r = 2.0;
        double l = 0.0;
        std::shared_ptr<Geom2Curve> c = MakeGeom2Circle(Point2(0.0, 0.0), 2.0).Value();
        AdaptorGeom2Curve circle(c);
        ComputePointsAbscissa cpa(circle, 0.0, 0.0);
        double angle1 = l / r;
        double x = r * cos(angle1);
        double y = r * sin(angle1);
        double param = cpa.Parameter();
        Point2 s = circle.Value(param);
        Point2 s1(x, y);
        CHECK(angle1 == cpa.Parameter());
        CHECK(s.X() == s1.X());
        CHECK(s.Y() == s1.Y());
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API ComputePointsAbscissa(const Adaptor2Curve& c, double abscissa, double u0, double ui)	 @param ui The initial guess of the parameter
	 @param u0 The starting parameter
	 @param abscissa The arc length
	 @param c The curve
	 @brief Compute the parameter of a point on a 2D curve with given arc length and an initial guess
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <geometry/MakeGeom2Circle.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/ComputePointsAbscissa.hpp>
#include <geometry/MakeGeom3Circle.hpp>
#include <geometry/AdaptorGeom3Curve.hpp>
#include <geometry/MakeGeom2Hyperbola.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/MakeGeom2Ellipse.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <geometry/MakeGeom3Ellipse.hpp>
#include <geometry/MakeGeom3Hyperbola.hpp>
#include <geometry/Geom2Line.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom3Line.hpp>
#include <geometry/Geom3TrimmedCurve.hpp>
#include<modeling/MakeEdge.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/GeometryTool.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <geometry/MakeGeom2Parabola.hpp>
#include <geometry/MakeGeom3Parabola.hpp>
#include <geometry/Geom2BezierCurve.hpp>
#include <geometry/Geom3BezierCurve.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/Geom2OffsetCurve.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
#include<catch.hpp>
#include<testHelper.h>
#include <geometry/MakeGeom2Circle.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/ComputePointsAbscissa.hpp>
#include <geometry/MakeGeom3Circle.hpp>
#include <geometry/AdaptorGeom3Curve.hpp>
#include <geometry/MakeGeom2Hyperbola.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/MakeGeom2Ellipse.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <geometry/MakeGeom3Ellipse.hpp>
#include <geometry/MakeGeom3Hyperbola.hpp>
#include <geometry/Geom2Line.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom3Line.hpp>
#include <geometry/Geom3TrimmedCurve.hpp>
#include<modeling/MakeEdge.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/GeometryTool.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <geometry/MakeGeom2Parabola.hpp>
#include <geometry/MakeGeom3Parabola.hpp>
#include <geometry/Geom2BezierCurve.hpp>
#include <geometry/Geom3BezierCurve.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/Geom2OffsetCurve.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
;
	SECTION("circle")
    {
        double r = 2.0;
        double l = 0.0;
        std::shared_ptr<Geom2Curve> c = MakeGeom2Circle(Point2(0.0, 0.0), 2.0).Value();
        AdaptorGeom2Curve circle(c);
        ComputePointsAbscissa cpa(circle, 0.0, 0.0);
        double angle1 = l / r;
        double x = r * cos(angle1);
        double y = r * sin(angle1);
        double param = cpa.Parameter();
        Point2 s = circle.Value(param);
        Point2 s1(x, y);
        CHECK(angle1 == cpa.Parameter());
        CHECK(s.X() == s1.X());
        CHECK(s.Y() == s1.Y());
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API ComputePointsAbscissa(const Adaptor3Curve& c, double abscissa, double u0, double ui, double tol)	 @param tol The tolerance
	 @param ui The initial guess of the parameter
	 @param u0 The starting parameter
	 @param abscissa The arc length
	 @param c The curve
	 @brief Compute the parameter of a point on a 3D curve with given arc length, an initial guess, and a tolerance
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <geometry/MakeGeom2Circle.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/ComputePointsAbscissa.hpp>
#include <geometry/MakeGeom3Circle.hpp>
#include <geometry/AdaptorGeom3Curve.hpp>
#include <geometry/MakeGeom2Hyperbola.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/MakeGeom2Ellipse.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <geometry/MakeGeom3Ellipse.hpp>
#include <geometry/MakeGeom3Hyperbola.hpp>
#include <geometry/Geom2Line.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom3Line.hpp>
#include <geometry/Geom3TrimmedCurve.hpp>
#include<modeling/MakeEdge.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/GeometryTool.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <geometry/MakeGeom2Parabola.hpp>
#include <geometry/MakeGeom3Parabola.hpp>
#include <geometry/Geom2BezierCurve.hpp>
#include <geometry/Geom3BezierCurve.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/Geom2OffsetCurve.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
#include<catch.hpp>
#include<testHelper.h>
#include <geometry/MakeGeom2Circle.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/ComputePointsAbscissa.hpp>
#include <geometry/MakeGeom3Circle.hpp>
#include <geometry/AdaptorGeom3Curve.hpp>
#include <geometry/MakeGeom2Hyperbola.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/MakeGeom2Ellipse.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <geometry/MakeGeom3Ellipse.hpp>
#include <geometry/MakeGeom3Hyperbola.hpp>
#include <geometry/Geom2Line.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom3Line.hpp>
#include <geometry/Geom3TrimmedCurve.hpp>
#include<modeling/MakeEdge.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/GeometryTool.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <geometry/MakeGeom2Parabola.hpp>
#include <geometry/MakeGeom3Parabola.hpp>
#include <geometry/Geom2BezierCurve.hpp>
#include <geometry/Geom3BezierCurve.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/Geom2OffsetCurve.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
;
	SECTION("circle")
    {
        double r = 2.0;
        double l = 0.0;
        std::shared_ptr<Geom2Curve> c = MakeGeom2Circle(Point2(0.0, 0.0), 2.0).Value();
        AdaptorGeom2Curve circle(c);
        ComputePointsAbscissa cpa(circle, 0.0, 0.0);
        double angle1 = l / r;
        double x = r * cos(angle1);
        double y = r * sin(angle1);
        double param = cpa.Parameter();
        Point2 s = circle.Value(param);
        Point2 s1(x, y);
        CHECK(angle1 == cpa.Parameter());
        CHECK(s.X() == s1.X());
        CHECK(s.Y() == s1.Y());
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API ComputePointsAbscissa(const Adaptor2Curve& c, double abscissa, double u0, double ui, double tol)	 @param tol The tolerance
	 @param ui The initial guess of the parameter
	 @param u0 The starting parameter
	 @param abscissa The arc length
	 @param c The curve
	 @brief Compute the parameter of a point on a 2D curve with given arc length, an initial guess, and a tolerance
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <geometry/MakeGeom2Circle.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/ComputePointsAbscissa.hpp>
#include <geometry/MakeGeom3Circle.hpp>
#include <geometry/AdaptorGeom3Curve.hpp>
#include <geometry/MakeGeom2Hyperbola.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/MakeGeom2Ellipse.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <geometry/MakeGeom3Ellipse.hpp>
#include <geometry/MakeGeom3Hyperbola.hpp>
#include <geometry/Geom2Line.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom3Line.hpp>
#include <geometry/Geom3TrimmedCurve.hpp>
#include<modeling/MakeEdge.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/GeometryTool.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <geometry/MakeGeom2Parabola.hpp>
#include <geometry/MakeGeom3Parabola.hpp>
#include <geometry/Geom2BezierCurve.hpp>
#include <geometry/Geom3BezierCurve.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/Geom2OffsetCurve.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
#include<catch.hpp>
#include<testHelper.h>
#include <geometry/MakeGeom2Circle.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/ComputePointsAbscissa.hpp>
#include <geometry/MakeGeom3Circle.hpp>
#include <geometry/AdaptorGeom3Curve.hpp>
#include <geometry/MakeGeom2Hyperbola.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/MakeGeom2Ellipse.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <geometry/MakeGeom3Ellipse.hpp>
#include <geometry/MakeGeom3Hyperbola.hpp>
#include <geometry/Geom2Line.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom3Line.hpp>
#include <geometry/Geom3TrimmedCurve.hpp>
#include<modeling/MakeEdge.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/GeometryTool.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <geometry/MakeGeom2Parabola.hpp>
#include <geometry/MakeGeom3Parabola.hpp>
#include <geometry/Geom2BezierCurve.hpp>
#include <geometry/Geom3BezierCurve.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/Geom2OffsetCurve.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
;
	SECTION("circle")
    {
        double r = 2.0;
        double l = 0.0;
        std::shared_ptr<Geom2Curve> c = MakeGeom2Circle(Point2(0.0, 0.0), 2.0).Value();
        AdaptorGeom2Curve circle(c);
        ComputePointsAbscissa cpa(circle, 0.0, 0.0);
        double angle1 = l / r;
        double x = r * cos(angle1);
        double y = r * sin(angle1);
        double param = cpa.Parameter();
        Point2 s = circle.Value(param);
        Point2 s1(x, y);
        CHECK(angle1 == cpa.Parameter());
        CHECK(s.X() == s1.X());
        CHECK(s.Y() == s1.Y());
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API double Parameter()	 @return The parameter of the point
	 @brief Get the parameter of the point
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <geometry/MakeGeom2Circle.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/ComputePointsAbscissa.hpp>
#include <geometry/MakeGeom3Circle.hpp>
#include <geometry/AdaptorGeom3Curve.hpp>
#include <geometry/MakeGeom2Hyperbola.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/MakeGeom2Ellipse.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <geometry/MakeGeom3Ellipse.hpp>
#include <geometry/MakeGeom3Hyperbola.hpp>
#include <geometry/Geom2Line.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom3Line.hpp>
#include <geometry/Geom3TrimmedCurve.hpp>
#include<modeling/MakeEdge.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/GeometryTool.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <geometry/MakeGeom2Parabola.hpp>
#include <geometry/MakeGeom3Parabola.hpp>
#include <geometry/Geom2BezierCurve.hpp>
#include <geometry/Geom3BezierCurve.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/Geom2OffsetCurve.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
#include<catch.hpp>
#include<testHelper.h>
#include <geometry/MakeGeom2Circle.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/ComputePointsAbscissa.hpp>
#include <geometry/MakeGeom3Circle.hpp>
#include <geometry/AdaptorGeom3Curve.hpp>
#include <geometry/MakeGeom2Hyperbola.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/MakeGeom2Ellipse.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <geometry/MakeGeom3Ellipse.hpp>
#include <geometry/MakeGeom3Hyperbola.hpp>
#include <geometry/Geom2Line.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom3Line.hpp>
#include <geometry/Geom3TrimmedCurve.hpp>
#include<modeling/MakeEdge.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/GeometryTool.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <geometry/MakeGeom2Parabola.hpp>
#include <geometry/MakeGeom3Parabola.hpp>
#include <geometry/Geom2BezierCurve.hpp>
#include <geometry/Geom3BezierCurve.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/Geom2OffsetCurve.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
;
	SECTION("line")
    {
        shared_ptr<Geom2Line> line;
        line = make_shared<Geom2Line>(Point2(0.0, 0.0), Direction2(1.0, 0.0));
        shared_ptr<Geom2TrimmedCurve> TrimmedCurve = make_shared<Geom2TrimmedCurve>(line, 0.0, 6.0);
        AdaptorGeom2Curve line1(TrimmedCurve);
        ComputePointsAbscissa cpa4(line1, 0.0, 0.0);
        double param4 = cpa4.Parameter();
        double x = 0.0;
        double y = 0.0;
        Point2 s5 = line1.Value(param4);
        Point2 s6(x, y);
        CHECK(cpa4.Parameter() == 0.0);
        CHECK(s5.X() == s6.X());
        CHECK(s5.Y() == s6.Y());
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static double Length(const Adaptor2Curve& c)	 @return The length of a curve
	 @param c The curve
	 @brief Compute the length of a 2D curve
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <geometry/MakeGeom2Circle.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/ComputePointsAbscissa.hpp>
#include <geometry/MakeGeom3Circle.hpp>
#include <geometry/AdaptorGeom3Curve.hpp>
#include <geometry/MakeGeom2Hyperbola.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/MakeGeom2Ellipse.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <geometry/MakeGeom3Ellipse.hpp>
#include <geometry/MakeGeom3Hyperbola.hpp>
#include <geometry/Geom2Line.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom3Line.hpp>
#include <geometry/Geom3TrimmedCurve.hpp>
#include<modeling/MakeEdge.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/GeometryTool.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <geometry/MakeGeom2Parabola.hpp>
#include <geometry/MakeGeom3Parabola.hpp>
#include <geometry/Geom2BezierCurve.hpp>
#include <geometry/Geom3BezierCurve.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/Geom2OffsetCurve.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
#include<catch.hpp>
#include<testHelper.h>
#include <geometry/MakeGeom2Circle.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/ComputePointsAbscissa.hpp>
#include <geometry/MakeGeom3Circle.hpp>
#include <geometry/AdaptorGeom3Curve.hpp>
#include <geometry/MakeGeom2Hyperbola.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/MakeGeom2Ellipse.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <geometry/MakeGeom3Ellipse.hpp>
#include <geometry/MakeGeom3Hyperbola.hpp>
#include <geometry/Geom2Line.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom3Line.hpp>
#include <geometry/Geom3TrimmedCurve.hpp>
#include<modeling/MakeEdge.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/GeometryTool.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <geometry/MakeGeom2Parabola.hpp>
#include <geometry/MakeGeom3Parabola.hpp>
#include <geometry/Geom2BezierCurve.hpp>
#include <geometry/Geom3BezierCurve.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/Geom2OffsetCurve.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
;
	SECTION("offset curve")
    {
        double r = 2.0;
        std::shared_ptr<Geom2Curve> c = MakeGeom2Circle(Point2(0.0, 0.0), 2.0).Value();
        shared_ptr<Geom2OffsetCurve> curve;
        double offset = -1.0;
        curve = make_shared<Geom2OffsetCurve>(c, offset);
        double r2 = r + offset;
        double p = 2 * M_PI * r2;
        double l = 0.0;
        AdaptorGeom2Curve offs(curve);
        ComputePointsAbscissa cpa8(offs, 0.0, 0.0);
        double angle1 = l / r2;
        double x = r2 * cos(angle1);
        double y = r2 * sin(angle1);
        double param8 = cpa8.Parameter();
        Point2 s = offs.Value(param8);
        Point2 s1(x, y);
        CHECK(p == ComputePointsAbscissa::Length(offs));
        CHECK(angle1 == cpa8.Parameter());
        CHECK(s.X() == s1.X());
        CHECK(s.Y() == s1.Y());
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API ComputePointsAbscissa(double tol, const Adaptor3Curve& c, double abscissa, double u0)	 @param u0 The starting parameter
	 @param abscissa The arc length
	 @param c The curve
	 @param tol The tolerance
	 @brief Compute the parameter of a point on a 3D curve with given arc length and a tolerance
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <geometry/MakeGeom2Circle.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/ComputePointsAbscissa.hpp>
#include <geometry/MakeGeom2Hyperbola.hpp>
#include <modeling/MakeEdge.hpp>
#include <geometry/GeometryTool.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/MakeGeom2Ellipse.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/AdaptorGeom3Curve.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <geometry/MakeGeom3Hyperbola.hpp>
#include <geometry/MakeGeom3Ellipse.hpp>
TEST_CASE("bug1: ComputePointsAbscissa ", "[geometry][ComputePointsAbscissa][fixbug]")
{
    double r = 0.0;
    std::shared_ptr<Geom2Curve> c = MakeGeom2Circle(Point2(0.0, 0.0), 0.0).Value();
    AdaptorGeom2Curve circle(c);
    ComputePointsAbscissa cpa(circle, 0.0, 0.0);
    double angle1 = 0;
    double x = r * cos(angle1);
    double y = r * sin(angle1);
    double param = cpa.Parameter();
    Point2 s = circle.Value(param);
    Point2 s1(x, y);
    CHECK(angle1 == cpa.Parameter());
    CHECK(s.X() == s1.X());
    CHECK(s.Y() == s1.Y());
    CHECK(ComputePointsAbscissa::Length(circle) == 0.0);
;
	SECTION("arc length, initial guess parameters and tolerances-3D")
{
    Frame3 frame;
    double major = 5.0;
    double minor = 4.0;
    bool isRight = true;
    std::shared_ptr< Geom3Hyperbola >h1 = MakeGeom3Hyperbola(frame, major, minor);
    AdaptorGeom3Curve hyperbola(h1);
    ComputePointsAbscissa cpa3(hyperbola, 1.0, 0.0, 0.5,Precision::Confusion());
    double L = 1.0;
    double param3 = cpa3.Parameter();
    Point3 point1(hyperbola.Value(param3));
    CHECK(cpa3.Parameter());
    MakeEdge edge1(h1, 0.0, param3);
    CHECK(BRepClassificationTools::IsPointInOnEdge(edge1, point1, 0.001) == true);
    CHECK(cpa3.Parameter());
    CHECK(ComputePointsAbscissa::Length(hyperbola, 0.0, param3) == Approx(L).margin(1e-2));
    CHECK(ComputePointsAbscissa::Length(hyperbola, 0.0, param3, Precision::Confusion()) == Approx(L).margin(1e-2));
}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API ComputePointsAbscissa(double tol, const Adaptor2Curve& c, double abscissa, double u0)	 @param u0 The starting parameter
	 @param abscissa The arc length
	 @param c The curve
	 @param tol The tolerance
	 @brief Compute the parameter of a point on a 2D curve with given arc length and a tolerance
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <geometry/MakeGeom2Circle.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/ComputePointsAbscissa.hpp>
#include <geometry/MakeGeom2Hyperbola.hpp>
#include <modeling/MakeEdge.hpp>
#include <geometry/GeometryTool.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/MakeGeom2Ellipse.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/AdaptorGeom3Curve.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <geometry/MakeGeom3Hyperbola.hpp>
#include <geometry/MakeGeom3Ellipse.hpp>
TEST_CASE("bug1: ComputePointsAbscissa ", "[geometry][ComputePointsAbscissa][fixbug]")
{
    double r = 0.0;
    std::shared_ptr<Geom2Curve> c = MakeGeom2Circle(Point2(0.0, 0.0), 0.0).Value();
    AdaptorGeom2Curve circle(c);
    ComputePointsAbscissa cpa(circle, 0.0, 0.0);
    double angle1 = 0;
    double x = r * cos(angle1);
    double y = r * sin(angle1);
    double param = cpa.Parameter();
    Point2 s = circle.Value(param);
    Point2 s1(x, y);
    CHECK(angle1 == cpa.Parameter());
    CHECK(s.X() == s1.X());
    CHECK(s.Y() == s1.Y());
    CHECK(ComputePointsAbscissa::Length(circle) == 0.0);
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API ComputePointsAbscissa(const Adaptor3Curve& c, double abscissa, double u0)	 @param u0 The starting parameter
	 @param abscissa The arc length
	 @param c The curve
	 @brief Compute the parameter of a point on a 3D curve with given arc length
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <geometry/MakeGeom2Circle.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/ComputePointsAbscissa.hpp>
#include <geometry/MakeGeom2Hyperbola.hpp>
#include <modeling/MakeEdge.hpp>
#include <geometry/GeometryTool.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/MakeGeom2Ellipse.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/AdaptorGeom3Curve.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <geometry/MakeGeom3Hyperbola.hpp>
#include <geometry/MakeGeom3Ellipse.hpp>
TEST_CASE("bug1: ComputePointsAbscissa ", "[geometry][ComputePointsAbscissa][fixbug]")
{
    double r = 0.0;
    std::shared_ptr<Geom2Curve> c = MakeGeom2Circle(Point2(0.0, 0.0), 0.0).Value();
    AdaptorGeom2Curve circle(c);
    ComputePointsAbscissa cpa(circle, 0.0, 0.0);
    double angle1 = 0;
    double x = r * cos(angle1);
    double y = r * sin(angle1);
    double param = cpa.Parameter();
    Point2 s = circle.Value(param);
    Point2 s1(x, y);
    CHECK(angle1 == cpa.Parameter());
    CHECK(s.X() == s1.X());
    CHECK(s.Y() == s1.Y());
    CHECK(ComputePointsAbscissa::Length(circle) == 0.0);
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API ComputePointsAbscissa(const Adaptor2Curve& c, double abscissa, double u0)	 @param u0 The starting parameter
	 @param abscissa The arc length
	 @param c The curve
	 @brief Compute the parameter of a point on a 2D curve with given arc length
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <geometry/MakeGeom2Circle.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/ComputePointsAbscissa.hpp>
#include <geometry/MakeGeom2Hyperbola.hpp>
#include <modeling/MakeEdge.hpp>
#include <geometry/GeometryTool.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/MakeGeom2Ellipse.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/AdaptorGeom3Curve.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <geometry/MakeGeom3Hyperbola.hpp>
#include <geometry/MakeGeom3Ellipse.hpp>
#include<catch.hpp>
#include<testHelper.h>
#include <geometry/MakeGeom2Circle.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/ComputePointsAbscissa.hpp>
#include <geometry/MakeGeom2Hyperbola.hpp>
#include <modeling/MakeEdge.hpp>
#include <geometry/GeometryTool.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/MakeGeom2Ellipse.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/AdaptorGeom3Curve.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <geometry/MakeGeom3Hyperbola.hpp>
#include <geometry/MakeGeom3Ellipse.hpp>
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API ComputePointsAbscissa(const Adaptor3Curve& c, double abscissa, double u0, double ui)	 @param ui The initial guess of the parameter
	 @param u0 The starting parameter
	 @param abscissa The arc length
	 @param c The curve
	 @brief Compute the parameter of a point on a 3D curve with given arc length and an initial guess
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <geometry/MakeGeom2Circle.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/ComputePointsAbscissa.hpp>
#include <geometry/MakeGeom2Hyperbola.hpp>
#include <modeling/MakeEdge.hpp>
#include <geometry/GeometryTool.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/MakeGeom2Ellipse.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/AdaptorGeom3Curve.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <geometry/MakeGeom3Hyperbola.hpp>
#include <geometry/MakeGeom3Ellipse.hpp>
TEST_CASE("bug1: ComputePointsAbscissa ", "[geometry][ComputePointsAbscissa][fixbug]")
{
    double r = 0.0;
    std::shared_ptr<Geom2Curve> c = MakeGeom2Circle(Point2(0.0, 0.0), 0.0).Value();
    AdaptorGeom2Curve circle(c);
    ComputePointsAbscissa cpa(circle, 0.0, 0.0);
    double angle1 = 0;
    double x = r * cos(angle1);
    double y = r * sin(angle1);
    double param = cpa.Parameter();
    Point2 s = circle.Value(param);
    Point2 s1(x, y);
    CHECK(angle1 == cpa.Parameter());
    CHECK(s.X() == s1.X());
    CHECK(s.Y() == s1.Y());
    CHECK(ComputePointsAbscissa::Length(circle) == 0.0);
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API ComputePointsAbscissa(const Adaptor2Curve& c, double abscissa, double u0, double ui)	 @param ui The initial guess of the parameter
	 @param u0 The starting parameter
	 @param abscissa The arc length
	 @param c The curve
	 @brief Compute the parameter of a point on a 2D curve with given arc length and an initial guess
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <geometry/MakeGeom2Circle.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/ComputePointsAbscissa.hpp>
#include <geometry/MakeGeom2Hyperbola.hpp>
#include <modeling/MakeEdge.hpp>
#include <geometry/GeometryTool.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/MakeGeom2Ellipse.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/AdaptorGeom3Curve.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <geometry/MakeGeom3Hyperbola.hpp>
#include <geometry/MakeGeom3Ellipse.hpp>
TEST_CASE("bug1: ComputePointsAbscissa ", "[geometry][ComputePointsAbscissa][fixbug]")
{
    double r = 0.0;
    std::shared_ptr<Geom2Curve> c = MakeGeom2Circle(Point2(0.0, 0.0), 0.0).Value();
    AdaptorGeom2Curve circle(c);
    ComputePointsAbscissa cpa(circle, 0.0, 0.0);
    double angle1 = 0;
    double x = r * cos(angle1);
    double y = r * sin(angle1);
    double param = cpa.Parameter();
    Point2 s = circle.Value(param);
    Point2 s1(x, y);
    CHECK(angle1 == cpa.Parameter());
    CHECK(s.X() == s1.X());
    CHECK(s.Y() == s1.Y());
    CHECK(ComputePointsAbscissa::Length(circle) == 0.0);
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API ComputePointsAbscissa(const Adaptor3Curve& c, double abscissa, double u0, double ui, double tol)	 @param tol The tolerance
	 @param ui The initial guess of the parameter
	 @param u0 The starting parameter
	 @param abscissa The arc length
	 @param c The curve
	 @brief Compute the parameter of a point on a 3D curve with given arc length, an initial guess, and a tolerance
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <geometry/MakeGeom2Circle.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/ComputePointsAbscissa.hpp>
#include <geometry/MakeGeom2Hyperbola.hpp>
#include <modeling/MakeEdge.hpp>
#include <geometry/GeometryTool.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/MakeGeom2Ellipse.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/AdaptorGeom3Curve.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <geometry/MakeGeom3Hyperbola.hpp>
#include <geometry/MakeGeom3Ellipse.hpp>
TEST_CASE("bug1: ComputePointsAbscissa ", "[geometry][ComputePointsAbscissa][fixbug]")
{
    double r = 0.0;
    std::shared_ptr<Geom2Curve> c = MakeGeom2Circle(Point2(0.0, 0.0), 0.0).Value();
    AdaptorGeom2Curve circle(c);
    ComputePointsAbscissa cpa(circle, 0.0, 0.0);
    double angle1 = 0;
    double x = r * cos(angle1);
    double y = r * sin(angle1);
    double param = cpa.Parameter();
    Point2 s = circle.Value(param);
    Point2 s1(x, y);
    CHECK(angle1 == cpa.Parameter());
    CHECK(s.X() == s1.X());
    CHECK(s.Y() == s1.Y());
    CHECK(ComputePointsAbscissa::Length(circle) == 0.0);
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API ComputePointsAbscissa(const Adaptor2Curve& c, double abscissa, double u0, double ui, double tol)	 @param tol The tolerance
	 @param ui The initial guess of the parameter
	 @param u0 The starting parameter
	 @param abscissa The arc length
	 @param c The curve
	 @brief Compute the parameter of a point on a 2D curve with given arc length, an initial guess, and a tolerance
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <geometry/MakeGeom2Circle.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/ComputePointsAbscissa.hpp>
#include <geometry/MakeGeom2Hyperbola.hpp>
#include <modeling/MakeEdge.hpp>
#include <geometry/GeometryTool.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/MakeGeom2Ellipse.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/AdaptorGeom3Curve.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <geometry/MakeGeom3Hyperbola.hpp>
#include <geometry/MakeGeom3Ellipse.hpp>
#include<catch.hpp>
#include<testHelper.h>
#include <geometry/MakeGeom2Circle.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/ComputePointsAbscissa.hpp>
#include <geometry/MakeGeom2Hyperbola.hpp>
#include <modeling/MakeEdge.hpp>
#include <geometry/GeometryTool.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/MakeGeom2Ellipse.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/AdaptorGeom3Curve.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <geometry/MakeGeom3Hyperbola.hpp>
#include <geometry/MakeGeom3Ellipse.hpp>
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API double Parameter()	 @return The parameter of the point
	 @brief Get the parameter of the point
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <geometry/MakeGeom2Circle.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/ComputePointsAbscissa.hpp>
#include <geometry/MakeGeom2Hyperbola.hpp>
#include <modeling/MakeEdge.hpp>
#include <geometry/GeometryTool.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/MakeGeom2Ellipse.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/AdaptorGeom3Curve.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <geometry/MakeGeom3Hyperbola.hpp>
#include <geometry/MakeGeom3Ellipse.hpp>
TEST_CASE("bug1: ComputePointsAbscissa ", "[geometry][ComputePointsAbscissa][fixbug]")
{
    double r = 0.0;
    std::shared_ptr<Geom2Curve> c = MakeGeom2Circle(Point2(0.0, 0.0), 0.0).Value();
    AdaptorGeom2Curve circle(c);
    ComputePointsAbscissa cpa(circle, 0.0, 0.0);
    double angle1 = 0;
    double x = r * cos(angle1);
    double y = r * sin(angle1);
    double param = cpa.Parameter();
    Point2 s = circle.Value(param);
    Point2 s1(x, y);
    CHECK(angle1 == cpa.Parameter());
    CHECK(s.X() == s1.X());
    CHECK(s.Y() == s1.Y());
    CHECK(ComputePointsAbscissa::Length(circle) == 0.0);
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API Geom2Ellipse(const Axis2& majorAxis, double major, double minor, bool isRight)	 @param isRight Is the local frame right-handed
	 @param minor The minor radius
	 @param major The major radius
	 @param majorAxis The axis
	 @brief Construct from an axis, a major radius and a minor radius
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <math/EllipseT.hpp>
#include <geometry/Geom2Ellipse.hpp>
using namespace AMCAX;
using namespace std;
#include <catch.hpp>
#include <testHelper.h>
#include <math/EllipseT.hpp>
#include <geometry/Geom2Ellipse.hpp>
using namespace AMCAX;
using namespace std;
;
	SECTION("SemilatusRectum")
	{
		double SR = g2e.SemilatusRectum();
		double sr = minor * minor / major;
		CHECK(SR == sr);
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] AMCAX_API double SemilatusRectum()	 @return The semilatus rectum
	          Semilatus rectum = 2 * focalLength
	 @details The semilatus rectum of parabola is half of the length of the chord through a focus parallel to the directrix.
	 @brief Get the semilatus rectum of the parabola
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <geometry/Geom3Parabola.hpp>
using namespace AMCAX;
using namespace std;
#include <catch.hpp>
#include <testHelper.h>
#include <geometry/Geom3Parabola.hpp>
using namespace AMCAX;
using namespace std;
;
	SECTION("SemilatusRectum")
	{
		double SR = g3p.SemilatusRectum();
		double sr = 2 * focal;
		CHECK(SR == sr);
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":Geom3Parabola()	 @brief Default constructor
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <geometry/Geom3Parabola.hpp>
using namespace AMCAX;
using namespace std;
#include <catch.hpp>
#include <testHelper.h>
#include <geometry/Geom3Parabola.hpp>
using namespace AMCAX;
using namespace std;
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API Geom3Parabola(const Frame3& frame, double focal)	 @param focal The focal length
	 @param frame The local frame
	 @brief Construct from a local frame and a focal length
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <geometry/Geom3Parabola.hpp>
using namespace AMCAX;
using namespace std;
#include <catch.hpp>
#include <testHelper.h>
#include <geometry/Geom3Parabola.hpp>
using namespace AMCAX;
using namespace std;
;
	SECTION("FocalParameter")
	{
		double FP = g3p.FocalParameter();
		double fp = 2 * focal;
		CHECK(FP == fp);
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API Geom3Parabola(const Axis3& directrix, const Point3& focus)	 @param focus The focus
	 @param directrix The directrix
	 @brief Construct from a directrix and a focus
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <geometry/Geom3Parabola.hpp>
using namespace AMCAX;
using namespace std;
#include <catch.hpp>
#include <testHelper.h>
#include <geometry/Geom3Parabola.hpp>
using namespace AMCAX;
using namespace std;
;
	SECTION("SemilatusRectum")
	{
		double SR = g3p.SemilatusRectum();
		double sr = 2 * focal;
		CHECK(SR == sr);
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API Geom2Hyperbola(const Frame2& frame, double major, double minor)	 @param minor The minor radius
	 @param major The major radius
	 @param frame The local frame
	 @brief Construct from a local frame, a major radius and a minor radius
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <math/EllipseT.hpp>
#include <geometry/Geom2Hyperbola.hpp>
using namespace AMCAX;
using namespace std;
#include <catch.hpp>
#include <testHelper.h>
#include <math/EllipseT.hpp>
#include <geometry/Geom2Hyperbola.hpp>
using namespace AMCAX;
using namespace std;
;
	SECTION("FocalParameter")
	{
		double FP = g2h.FocalParameter();
		double focal = 2 * sqrt(major * major + minor * minor);
		double fp = 2 * minor * minor / focal;;
		CHECK(FP == fp);
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API Geom2Parabola(const Axis2& axis, double focal, bool isRight = true)	 @param isRight Is the local frame right-handed
	 @param focal The focal length
	 @param axis The axis
	 @brief Construct from an axis and a focal length
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <geometry/Geom2Parabola.hpp>
using namespace AMCAX;
using namespace std;
#include <catch.hpp>
#include <testHelper.h>
#include <geometry/Geom2Parabola.hpp>
using namespace AMCAX;
using namespace std;
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API Geom3BSplineCurve(const std::vector<Point3>& pts, const std::vector<double>& knots, const std::vector<int>& multiplicities, int degree, bool isPeriodic = false)	 @param isPeriodic Set the curve is periodic or not
	 @param degree The degree of curve
	 @param multiplicities The multiplicities
	 @param knots The knots
	 @param pts The points
	 @brief Construct a B spline curve from points, knots and multiplicities with a given degree
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <geometry/Geom3BSplineCurve.hpp>
#include <geometry/Geom3BSplineSurface.hpp>
#include <topology/TopoFace.hpp>
#include <topology/TopoTool.hpp>
using namespace AMCAX;
TEST_CASE("bug1: Geom3BSplineCurve ", "[geometry][Geom3BSplineCurve][fixbug]") {
	std::stringstream output1,output2;
	std::vector<Point3> poles{ Point3(0.0, 0.0, 0.0), Point3(0.0, 1.0, 0.0), Point3(0.0, 2.0, 0.0), Point3(0.0, 3.0, 0.0), Point3(0.0, 4.0, 0.0) };
	std::vector<double> knots{ 0.0, 1.0, 2.0, 3.0 };
	std::vector<int> mults{ 2, 2, 2, 2 };
	auto bc = std::make_shared<Geom3BSplineCurve>(poles, knots, mults, 2);
	double last = bc->LastParameter();
	std::cout << bc->Value(last) << '\n';
	std::cout << bc->DN(last, 0) << '\n';
	output1 << bc->Value(last) << '\n';
	output2 << bc->DN(last, 0) << '\n';
	auto case1 = output1.str();
	auto case2 = output2.str();
	auto expectValue = "0 3 0";
	auto expectDN = "0 3 0";
	CHECK(case1.find(expectValue) != std::string::npos);
	CHECK(case2.find(expectDN) != std::string::npos);
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API Geom3BSplineCurve(const std::vector<Point3>& pts, const std::vector<double>& weights, const std::vector<double>& knots, const std::vector<int>& multiplicities, int degree, bool isPeriodic = false, bool checkRational = true)	 @param checkRational To check whether the weights are rational
	 @param isPeriodic Set the curve is periodic or not
	 @param degree The degree of curve
	 @param multiplicities The multiplicities
	 @param knots The knots
	 @param weights The weights
	 @param pts The points
	 @brief Construct a rational B spline curve from point, weights, knots and multiplicities with a given degree
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <geometry/Geom3BSplineCurve.hpp>
#include <geometry/Geom3BSplineSurface.hpp>
#include <topology/TopoFace.hpp>
#include <topology/TopoTool.hpp>
using namespace AMCAX;
TEST_CASE("bug1: Geom3BSplineCurve ", "[geometry][Geom3BSplineCurve][fixbug]") {
	std::stringstream output1,output2;
	std::vector<Point3> poles{ Point3(0.0, 0.0, 0.0), Point3(0.0, 1.0, 0.0), Point3(0.0, 2.0, 0.0), Point3(0.0, 3.0, 0.0), Point3(0.0, 4.0, 0.0) };
	std::vector<double> knots{ 0.0, 1.0, 2.0, 3.0 };
	std::vector<int> mults{ 2, 2, 2, 2 };
	auto bc = std::make_shared<Geom3BSplineCurve>(poles, knots, mults, 2);
	double last = bc->LastParameter();
	std::cout << bc->Value(last) << '\n';
	std::cout << bc->DN(last, 0) << '\n';
	output1 << bc->Value(last) << '\n';
	output2 << bc->DN(last, 0) << '\n';
	auto case1 = output1.str();
	auto case2 = output2.str();
	auto expectValue = "0 3 0";
	auto expectDN = "0 3 0";
	CHECK(case1.find(expectValue) != std::string::npos);
	CHECK(case2.find(expectDN) != std::string::npos);
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API Geom3BSplineSurface()	 @details A default surface is a unit square
	 @brief Default constructor
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <modeling/MakeFace.hpp>
#include <geometry/Geom3BSplineSurface.hpp>
#include <topology/TopoFace.hpp>
#include <topology/TopoTool.hpp>
using namespace AMCAX;
TEST_CASE("bug1: Geom3BSplineSurface::InsertUKnot() ", "[geometry][Geom3BSplineSurface][fixbug]") {
	TopoFace face;
	OCCTIO::OCCTTool::Read(face, INPUT_PATH_PREFIX"face.brep");
	auto surf = TopoTool::Surface(face);
	auto bsp = std::dynamic_pointer_cast<Geom3BSplineSurface>(surf);
	bsp->InsertUKnot(0.23, 1, 0.0, true);
	bool bWriteresult = OCCTIO::OCCTTool::Write(face, OUTPUT_PATH_PREFIX"result.brep");
	CHECK(bWriteresult == true);
}
TEST_CASE("case1: Geom3BSplineSurface::Geom3BSplineSurface() ", "[geometry][Geom3BSplineSurface][p1]") {
	Array2<Point3> poles(5, 4);
	poles(0, 0).SetCoord(0.0, 0.0, 0.0);
	poles(0, 1).SetCoord(0.0, 1.1, 2.0);
	poles(0, 2).SetCoord(0.0, 2.3, 1.0);
	poles(0, 3).SetCoord(0.0, 3.1, 1.5);
	poles(1, 0).SetCoord(1.1, 0.1, 2.0);
	poles(1, 1).SetCoord(1.2, 1.0, 0.0);
	poles(1, 2).SetCoord(1.3, 2.1, -1.0);
	poles(1, 3).SetCoord(1.23, 3.04, 1.32);
	poles(2, 0).SetCoord(2.3, 0.1, -2.0);
	poles(2, 1).SetCoord(2.1, 1.4, 2.0);
	poles(2, 2).SetCoord(2.2, 2.1, 1.0);
	poles(2, 3).SetCoord(2.23, 3.22, 1.26);
	poles(3, 0).SetCoord(3.13, 0.2, 0.0);
	poles(3, 1).SetCoord(3.12, 1.1, 0.0);
	poles(3, 2).SetCoord(3.21, 2.1, 1.0);
	poles(3, 3).SetCoord(3.33, 3.21, -1.2);
	poles(4, 0).SetCoord(4.9, 4.93, 0.31);
	poles(4, 1).SetCoord(5.3, 4.73, 0.33);
	poles(4, 2).SetCoord(5.1, 4.43, -1.31);
	poles(4, 3).SetCoord(9.2, 4.65, 3.31);
	std::vector<double> uknots = { 0.0, 0.5, 1.0 };
	std::vector<int> umults = { 4, 1, 4 };
	std::vector<double> vknots = { 0.0, 0.5, 1.0 };
	std::vector<int> vmults = { 3, 1, 3 };
	std::shared_ptr<Geom3BSplineSurface> s = std::make_shared<Geom3BSplineSurface>(poles, uknots, vknots, umults, vmults, 3, 2);
	TopoFace face = MakeFace(s,0.001);
	bool bWriteresult = OCCTIO::OCCTTool::Write(face, OUTPUT_PATH_PREFIX"Geom3BSplineSurface_case1.brep");
	CHECK(bWriteresult == true);
	AMCAX::GlobalProperty prop;
	AMCAX::BRepGlobalProperty::SurfaceProperties(face, prop);
	CHECK(prop.Mass() == Approx( 21.3633));
}
#include<catch.hpp>
#include<testHelper.h>
#include <modeling/MakeFace.hpp>
#include <geometry/Geom3BSplineSurface.hpp>
#include <topology/TopoFace.hpp>
#include <topology/TopoTool.hpp>
using namespace AMCAX;
TEST_CASE("bug1: Geom3BSplineSurface::InsertUKnot() ", "[geometry][Geom3BSplineSurface][fixbug]") {
	TopoFace face;
	OCCTIO::OCCTTool::Read(face, INPUT_PATH_PREFIX"face.brep");
	auto surf = TopoTool::Surface(face);
	auto bsp = std::dynamic_pointer_cast<Geom3BSplineSurface>(surf);
	bsp->InsertUKnot(0.23, 1, 0.0, true);
	bool bWriteresult = OCCTIO::OCCTTool::Write(face, OUTPUT_PATH_PREFIX"result.brep");
	CHECK(bWriteresult == true);
}
TEST_CASE("case1: Geom3BSplineSurface::Geom3BSplineSurface() ", "[geometry][Geom3BSplineSurface][p1]") {
	Array2<Point3> poles(5, 4);
	poles(0, 0).SetCoord(0.0, 0.0, 0.0);
	poles(0, 1).SetCoord(0.0, 1.1, 2.0);
	poles(0, 2).SetCoord(0.0, 2.3, 1.0);
	poles(0, 3).SetCoord(0.0, 3.1, 1.5);
	poles(1, 0).SetCoord(1.1, 0.1, 2.0);
	poles(1, 1).SetCoord(1.2, 1.0, 0.0);
	poles(1, 2).SetCoord(1.3, 2.1, -1.0);
	poles(1, 3).SetCoord(1.23, 3.04, 1.32);
	poles(2, 0).SetCoord(2.3, 0.1, -2.0);
	poles(2, 1).SetCoord(2.1, 1.4, 2.0);
	poles(2, 2).SetCoord(2.2, 2.1, 1.0);
	poles(2, 3).SetCoord(2.23, 3.22, 1.26);
	poles(3, 0).SetCoord(3.13, 0.2, 0.0);
	poles(3, 1).SetCoord(3.12, 1.1, 0.0);
	poles(3, 2).SetCoord(3.21, 2.1, 1.0);
	poles(3, 3).SetCoord(3.33, 3.21, -1.2);
	poles(4, 0).SetCoord(4.9, 4.93, 0.31);
	poles(4, 1).SetCoord(5.3, 4.73, 0.33);
	poles(4, 2).SetCoord(5.1, 4.43, -1.31);
	poles(4, 3).SetCoord(9.2, 4.65, 3.31);
	std::vector<double> uknots = { 0.0, 0.5, 1.0 };
	std::vector<int> umults = { 4, 1, 4 };
	std::vector<double> vknots = { 0.0, 0.5, 1.0 };
	std::vector<int> vmults = { 3, 1, 3 };
	std::shared_ptr<Geom3BSplineSurface> s = std::make_shared<Geom3BSplineSurface>(poles, uknots, vknots, umults, vmults, 3, 2);
	TopoFace face = MakeFace(s,0.001);
	bool bWriteresult = OCCTIO::OCCTTool::Write(face, OUTPUT_PATH_PREFIX"Geom3BSplineSurface_case1.brep");
	CHECK(bWriteresult == true);
	AMCAX::GlobalProperty prop;
	AMCAX::BRepGlobalProperty::SurfaceProperties(face, prop);
	CHECK(prop.Mass() == Approx( 21.3633));
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API Geom3BSplineSurface(const Array2<Point3>& pts, const std::vector<double>& uKnots, const std::vector<double>& vKnots, const std::vector<int>& uMults, const std::vector<int>& vMults, int uDegree, int vDegree, bool uPeriodic = false, bool vPeriodic = false)	 @param vPeriodic Set whether the surface is periodic along the v direction
	 @param uPeriodic Set whether the surface is periodic along the u direction
	 @param vDegree The v degree
	 @param uDegree The u degree
	 @param vMults The v multiplicities
	 @param uMults The u multiplicities
	 @param vKnots The v knots
	 @param uKnots The u knots
	 @param pts The poles
	 @brief Construct a B spline surface from poles, knots and multiplicities
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <modeling/MakeFace.hpp>
#include <geometry/Geom3BSplineSurface.hpp>
#include <topology/TopoFace.hpp>
#include <topology/TopoTool.hpp>
using namespace AMCAX;
TEST_CASE("bug1: Geom3BSplineSurface::InsertUKnot() ", "[geometry][Geom3BSplineSurface][fixbug]") {
	TopoFace face;
	OCCTIO::OCCTTool::Read(face, INPUT_PATH_PREFIX"face.brep");
	auto surf = TopoTool::Surface(face);
	auto bsp = std::dynamic_pointer_cast<Geom3BSplineSurface>(surf);
	bsp->InsertUKnot(0.23, 1, 0.0, true);
	bool bWriteresult = OCCTIO::OCCTTool::Write(face, OUTPUT_PATH_PREFIX"result.brep");
	CHECK(bWriteresult == true);
}
TEST_CASE("case1: Geom3BSplineSurface::Geom3BSplineSurface() ", "[geometry][Geom3BSplineSurface][p1]") {
	Array2<Point3> poles(5, 4);
	poles(0, 0).SetCoord(0.0, 0.0, 0.0);
	poles(0, 1).SetCoord(0.0, 1.1, 2.0);
	poles(0, 2).SetCoord(0.0, 2.3, 1.0);
	poles(0, 3).SetCoord(0.0, 3.1, 1.5);
	poles(1, 0).SetCoord(1.1, 0.1, 2.0);
	poles(1, 1).SetCoord(1.2, 1.0, 0.0);
	poles(1, 2).SetCoord(1.3, 2.1, -1.0);
	poles(1, 3).SetCoord(1.23, 3.04, 1.32);
	poles(2, 0).SetCoord(2.3, 0.1, -2.0);
	poles(2, 1).SetCoord(2.1, 1.4, 2.0);
	poles(2, 2).SetCoord(2.2, 2.1, 1.0);
	poles(2, 3).SetCoord(2.23, 3.22, 1.26);
	poles(3, 0).SetCoord(3.13, 0.2, 0.0);
	poles(3, 1).SetCoord(3.12, 1.1, 0.0);
	poles(3, 2).SetCoord(3.21, 2.1, 1.0);
	poles(3, 3).SetCoord(3.33, 3.21, -1.2);
	poles(4, 0).SetCoord(4.9, 4.93, 0.31);
	poles(4, 1).SetCoord(5.3, 4.73, 0.33);
	poles(4, 2).SetCoord(5.1, 4.43, -1.31);
	poles(4, 3).SetCoord(9.2, 4.65, 3.31);
	std::vector<double> uknots = { 0.0, 0.5, 1.0 };
	std::vector<int> umults = { 4, 1, 4 };
	std::vector<double> vknots = { 0.0, 0.5, 1.0 };
	std::vector<int> vmults = { 3, 1, 3 };
	std::shared_ptr<Geom3BSplineSurface> s = std::make_shared<Geom3BSplineSurface>(poles, uknots, vknots, umults, vmults, 3, 2);
	TopoFace face = MakeFace(s,0.001);
	bool bWriteresult = OCCTIO::OCCTTool::Write(face, OUTPUT_PATH_PREFIX"Geom3BSplineSurface_case1.brep");
	CHECK(bWriteresult == true);
	AMCAX::GlobalProperty prop;
	AMCAX::BRepGlobalProperty::SurfaceProperties(face, prop);
	CHECK(prop.Mass() == Approx( 21.3633));
}
#include<catch.hpp>
#include<testHelper.h>
#include <modeling/MakeFace.hpp>
#include <geometry/Geom3BSplineSurface.hpp>
#include <topology/TopoFace.hpp>
#include <topology/TopoTool.hpp>
using namespace AMCAX;
TEST_CASE("bug1: Geom3BSplineSurface::InsertUKnot() ", "[geometry][Geom3BSplineSurface][fixbug]") {
	TopoFace face;
	OCCTIO::OCCTTool::Read(face, INPUT_PATH_PREFIX"face.brep");
	auto surf = TopoTool::Surface(face);
	auto bsp = std::dynamic_pointer_cast<Geom3BSplineSurface>(surf);
	bsp->InsertUKnot(0.23, 1, 0.0, true);
	bool bWriteresult = OCCTIO::OCCTTool::Write(face, OUTPUT_PATH_PREFIX"result.brep");
	CHECK(bWriteresult == true);
}
TEST_CASE("case1: Geom3BSplineSurface::Geom3BSplineSurface() ", "[geometry][Geom3BSplineSurface][p1]") {
	Array2<Point3> poles(5, 4);
	poles(0, 0).SetCoord(0.0, 0.0, 0.0);
	poles(0, 1).SetCoord(0.0, 1.1, 2.0);
	poles(0, 2).SetCoord(0.0, 2.3, 1.0);
	poles(0, 3).SetCoord(0.0, 3.1, 1.5);
	poles(1, 0).SetCoord(1.1, 0.1, 2.0);
	poles(1, 1).SetCoord(1.2, 1.0, 0.0);
	poles(1, 2).SetCoord(1.3, 2.1, -1.0);
	poles(1, 3).SetCoord(1.23, 3.04, 1.32);
	poles(2, 0).SetCoord(2.3, 0.1, -2.0);
	poles(2, 1).SetCoord(2.1, 1.4, 2.0);
	poles(2, 2).SetCoord(2.2, 2.1, 1.0);
	poles(2, 3).SetCoord(2.23, 3.22, 1.26);
	poles(3, 0).SetCoord(3.13, 0.2, 0.0);
	poles(3, 1).SetCoord(3.12, 1.1, 0.0);
	poles(3, 2).SetCoord(3.21, 2.1, 1.0);
	poles(3, 3).SetCoord(3.33, 3.21, -1.2);
	poles(4, 0).SetCoord(4.9, 4.93, 0.31);
	poles(4, 1).SetCoord(5.3, 4.73, 0.33);
	poles(4, 2).SetCoord(5.1, 4.43, -1.31);
	poles(4, 3).SetCoord(9.2, 4.65, 3.31);
	std::vector<double> uknots = { 0.0, 0.5, 1.0 };
	std::vector<int> umults = { 4, 1, 4 };
	std::vector<double> vknots = { 0.0, 0.5, 1.0 };
	std::vector<int> vmults = { 3, 1, 3 };
	std::shared_ptr<Geom3BSplineSurface> s = std::make_shared<Geom3BSplineSurface>(poles, uknots, vknots, umults, vmults, 3, 2);
	TopoFace face = MakeFace(s,0.001);
	bool bWriteresult = OCCTIO::OCCTTool::Write(face, OUTPUT_PATH_PREFIX"Geom3BSplineSurface_case1.brep");
	CHECK(bWriteresult == true);
	AMCAX::GlobalProperty prop;
	AMCAX::BRepGlobalProperty::SurfaceProperties(face, prop);
	CHECK(prop.Mass() == Approx( 21.3633));
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API Geom3BSplineSurface(const Array2<Point3>& pts, const Array2<double>& weights, const std::vector<double>& uKnots, const std::vector<double>& vKnots, const std::vector<int>& uMults, const std::vector<int>& vMults, int uDegree, int vDegree, bool uPeriodic = false, bool vPeriodic = false)	 @param vPeriodic Set whether the surface is periodic along the v direction
	 @param uPeriodic Set whether the surface is periodic along the u direction
	 @param vDegree The v degree
	 @param uDegree The u degree
	 @param vMults The v multiplicities
	 @param uMults The u multiplicities
	 @param vKnots The v knots
	 @param uKnots The u knots
	 @param weights The weights
	 @param pts The poles
	 @brief Construct a rational B spline surface from poles, knots and multiplicities
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <modeling/MakeFace.hpp>
#include <geometry/Geom3BSplineSurface.hpp>
#include <topology/TopoFace.hpp>
#include <topology/TopoTool.hpp>
using namespace AMCAX;
TEST_CASE("bug1: Geom3BSplineSurface::InsertUKnot() ", "[geometry][Geom3BSplineSurface][fixbug]") {
	TopoFace face;
	OCCTIO::OCCTTool::Read(face, INPUT_PATH_PREFIX"face.brep");
	auto surf = TopoTool::Surface(face);
	auto bsp = std::dynamic_pointer_cast<Geom3BSplineSurface>(surf);
	bsp->InsertUKnot(0.23, 1, 0.0, true);
	bool bWriteresult = OCCTIO::OCCTTool::Write(face, OUTPUT_PATH_PREFIX"result.brep");
	CHECK(bWriteresult == true);
}
TEST_CASE("case1: Geom3BSplineSurface::Geom3BSplineSurface() ", "[geometry][Geom3BSplineSurface][p1]") {
	Array2<Point3> poles(5, 4);
	poles(0, 0).SetCoord(0.0, 0.0, 0.0);
	poles(0, 1).SetCoord(0.0, 1.1, 2.0);
	poles(0, 2).SetCoord(0.0, 2.3, 1.0);
	poles(0, 3).SetCoord(0.0, 3.1, 1.5);
	poles(1, 0).SetCoord(1.1, 0.1, 2.0);
	poles(1, 1).SetCoord(1.2, 1.0, 0.0);
	poles(1, 2).SetCoord(1.3, 2.1, -1.0);
	poles(1, 3).SetCoord(1.23, 3.04, 1.32);
	poles(2, 0).SetCoord(2.3, 0.1, -2.0);
	poles(2, 1).SetCoord(2.1, 1.4, 2.0);
	poles(2, 2).SetCoord(2.2, 2.1, 1.0);
	poles(2, 3).SetCoord(2.23, 3.22, 1.26);
	poles(3, 0).SetCoord(3.13, 0.2, 0.0);
	poles(3, 1).SetCoord(3.12, 1.1, 0.0);
	poles(3, 2).SetCoord(3.21, 2.1, 1.0);
	poles(3, 3).SetCoord(3.33, 3.21, -1.2);
	poles(4, 0).SetCoord(4.9, 4.93, 0.31);
	poles(4, 1).SetCoord(5.3, 4.73, 0.33);
	poles(4, 2).SetCoord(5.1, 4.43, -1.31);
	poles(4, 3).SetCoord(9.2, 4.65, 3.31);
	std::vector<double> uknots = { 0.0, 0.5, 1.0 };
	std::vector<int> umults = { 4, 1, 4 };
	std::vector<double> vknots = { 0.0, 0.5, 1.0 };
	std::vector<int> vmults = { 3, 1, 3 };
	std::shared_ptr<Geom3BSplineSurface> s = std::make_shared<Geom3BSplineSurface>(poles, uknots, vknots, umults, vmults, 3, 2);
	TopoFace face = MakeFace(s,0.001);
	bool bWriteresult = OCCTIO::OCCTTool::Write(face, OUTPUT_PATH_PREFIX"Geom3BSplineSurface_case1.brep");
	CHECK(bWriteresult == true);
	AMCAX::GlobalProperty prop;
	AMCAX::BRepGlobalProperty::SurfaceProperties(face, prop);
	CHECK(prop.Mass() == Approx( 21.3633));
}
#include<catch.hpp>
#include<testHelper.h>
#include <modeling/MakeFace.hpp>
#include <geometry/Geom3BSplineSurface.hpp>
#include <topology/TopoFace.hpp>
#include <topology/TopoTool.hpp>
using namespace AMCAX;
TEST_CASE("bug1: Geom3BSplineSurface::InsertUKnot() ", "[geometry][Geom3BSplineSurface][fixbug]") {
	TopoFace face;
	OCCTIO::OCCTTool::Read(face, INPUT_PATH_PREFIX"face.brep");
	auto surf = TopoTool::Surface(face);
	auto bsp = std::dynamic_pointer_cast<Geom3BSplineSurface>(surf);
	bsp->InsertUKnot(0.23, 1, 0.0, true);
	bool bWriteresult = OCCTIO::OCCTTool::Write(face, OUTPUT_PATH_PREFIX"result.brep");
	CHECK(bWriteresult == true);
}
TEST_CASE("case1: Geom3BSplineSurface::Geom3BSplineSurface() ", "[geometry][Geom3BSplineSurface][p1]") {
	Array2<Point3> poles(5, 4);
	poles(0, 0).SetCoord(0.0, 0.0, 0.0);
	poles(0, 1).SetCoord(0.0, 1.1, 2.0);
	poles(0, 2).SetCoord(0.0, 2.3, 1.0);
	poles(0, 3).SetCoord(0.0, 3.1, 1.5);
	poles(1, 0).SetCoord(1.1, 0.1, 2.0);
	poles(1, 1).SetCoord(1.2, 1.0, 0.0);
	poles(1, 2).SetCoord(1.3, 2.1, -1.0);
	poles(1, 3).SetCoord(1.23, 3.04, 1.32);
	poles(2, 0).SetCoord(2.3, 0.1, -2.0);
	poles(2, 1).SetCoord(2.1, 1.4, 2.0);
	poles(2, 2).SetCoord(2.2, 2.1, 1.0);
	poles(2, 3).SetCoord(2.23, 3.22, 1.26);
	poles(3, 0).SetCoord(3.13, 0.2, 0.0);
	poles(3, 1).SetCoord(3.12, 1.1, 0.0);
	poles(3, 2).SetCoord(3.21, 2.1, 1.0);
	poles(3, 3).SetCoord(3.33, 3.21, -1.2);
	poles(4, 0).SetCoord(4.9, 4.93, 0.31);
	poles(4, 1).SetCoord(5.3, 4.73, 0.33);
	poles(4, 2).SetCoord(5.1, 4.43, -1.31);
	poles(4, 3).SetCoord(9.2, 4.65, 3.31);
	std::vector<double> uknots = { 0.0, 0.5, 1.0 };
	std::vector<int> umults = { 4, 1, 4 };
	std::vector<double> vknots = { 0.0, 0.5, 1.0 };
	std::vector<int> vmults = { 3, 1, 3 };
	std::shared_ptr<Geom3BSplineSurface> s = std::make_shared<Geom3BSplineSurface>(poles, uknots, vknots, umults, vmults, 3, 2);
	TopoFace face = MakeFace(s,0.001);
	bool bWriteresult = OCCTIO::OCCTTool::Write(face, OUTPUT_PATH_PREFIX"Geom3BSplineSurface_case1.brep");
	CHECK(bWriteresult == true);
	AMCAX::GlobalProperty prop;
	AMCAX::BRepGlobalProperty::SurfaceProperties(face, prop);
	CHECK(prop.Mass() == Approx( 21.3633));
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API Geom3ConicalSurface(const Frame3& frame, double r, double angle)	 @param angle The semi-angle
	 @param r The reference radius
	 @param frame The local frame
	 @brief Construct from a local frame, a reference radius and a semi-angle
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
#include <geometry/Geom3ConicalSurface.hpp>
using namespace AMCAX;
TEST_CASE("case1: Geom3ConicalSurface::CircleD1 1/4 ", "[math][Geom3ConicalSurface][P1][CircleD1]") {
	Direction3 initialDir(0.0, 0.0, 1.0); 
	Frame3 defaultFrame3(Point3(1.0, 1.0, 0.0), initialDir);
	AMCAX::Geom3ConicalSurface suface(defaultFrame3, 5.0, 1);
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] AMCAX_API Point3 Apex()	 @return The apex point
	 @brief Get the apex of the cone
,
 "output":#include<iostream>
#include "catch.hpp"
#include <common/FrameT.hpp>
#include <modeling/MakeFace.hpp>
#include <common/AxisT.hpp>
#include <common/FrameT.hpp>
#include <common/VectorT.hpp>
#include <math/Cone.hpp>
using namespace AMCAX;
using namespace std;
TEST_CASE("TestCone", "[math][Cone]")
{
	AMCAX::Frame3 frame;
	double radius = 5.0;
	double angle = M_PI / 4;
	AMCAX::Cone cone(frame, radius, angle);
	AMCAX::Point3 apex = cone.Apex();
	CHECK(apex.X() == 0.0);
	CHECK(apex.Y() == 0.0);
	CHECK(apex.Z() == Approx(-5.0));
	AMCAX::Axis3 axis = cone.Axis();
	std::cout << axis.Direction().X() << std::endl;
	std::cout << axis.Direction().Y() << std::endl;
	std::cout << axis.Direction().Z() << std::endl;
	CHECK(axis.Direction().X() == 0.0);
	CHECK(axis.Direction().Y() == 0.0);
	CHECK(axis.Direction().Z() == 1.0);
	double a1, a2, a3, b1, b2, b3, c1, c2, c3, d;
	cone.Coefficients(a1, a2, a3, b1, b2, b3, c1, c2, c3, d);
	std::cout << "a1: " << a1 << ", a2: " << a2 << ", a3: " << a3 << std::endl;
	std::cout << "b1: " << b1 << ", b2: " << b2 << ", b3: " << b3 << std::endl;
	std::cout << "c1: " << c1 << ", c2: " << c2 << ", c3: " << c3 << std::endl;
	std::cout << "d: " << d << std::endl;
	CHECK(a1 == 1.0);
	CHECK(a2 == 1.0);
	CHECK(a3 == Approx(-1.0));
	CHECK(b1 == 0);
	CHECK(b2 == 0);
	CHECK(b3 == 0);
	CHECK(c1 == 0);
	CHECK(c2 == 0);
	CHECK(c3 == Approx(-5.0));
	CHECK(d == -25.0);
	CHECK(cone.IsDirect() == true);
	CHECK(cone.Location().X() == 0.0);
	CHECK(cone.Location().Y() == 0.0);
	CHECK(cone.Location().Z() == 0.0);
	AMCAX::PointT<double, 3>mirrorPoint(5.0, 0.0, 0.0);
	cone.Mirror(mirrorPoint);
	auto mirroredLocation = cone.Location();
	CHECK(mirroredLocation.X() == 10.0);
	CHECK(mirroredLocation.Y() == 0.0);
	CHECK(mirroredLocation.Z() == 0.0);
	AMCAX::Frame3 coneFrame = cone.Position();
	CHECK(frame.Location().X() == 0.0);
	CHECK(frame.Location().Y() == 0.0);
	CHECK(frame.Location().Z() == 0.0);
	CHECK(cone.Radius() == 5.0);
	double  scaleCone = 2.0;
	cone.Scale(cone.Location(), scaleCone);
	CHECK(cone.Radius() == radius * 2.0);
	double semiCone = cone.SemiAngle();
	CHECK(semiCone == Approx(0.785398));
	const  Frame3& position = cone.Position();
	std::cout << position.XAxis() << std::endl;
	std::cout << position.YAxis() << std::endl;
	Direction3 zDirection(0.0, 0.0, 1.0);
	AMCAX::Point3  centerCone(0.0, 0.0, 0.0);
	Axis3 zAxis(centerCone, zDirection);
	cone.Rotated(zAxis, angle);
	AMCAX::Frame3 coneFrame2 = cone.Position();
	CHECK(coneFrame.Location().X() == 10.0);
	CHECK(coneFrame.Location().Y() == 0.0);
	CHECK(coneFrame.Location().Z() == 0.0);
	double scale = 2.0;
	cone.Scale(centerCone, scale);
	CHECK(cone.Radius() == radius * 4.0);
	double semiAngle = cone.SemiAngle();
	std::cout << semiAngle << std::endl;
	CHECK(semiAngle == Approx(0.785398));
	VectorT<double, 3> translationVector(5.0, 5.0, 0.0);
	cone.Translate(translationVector);
	CHECK(cone.Location().X() == 25.0);
	CHECK(cone.Location().Y() == 5.0);
	CHECK(cone.Location().Z() == 0.0);
	auto xAxis = cone.XAxis();
	auto yAxis = cone.YAxis();
	CHECK(xAxis.Direction().X() == Approx(-1.0));
	CHECK(yAxis.Direction().Y() == Approx(-1.0));
	AMCAX::Transformation3 tr;
	tr.SetTranslation(Vector3(1.0, 2.0, 3.0));
	cone.Transform(tr);
	Axis3 newXAxis = cone.Position().XAxis();
	CHECK(newXAxis.Location().X() == 26.0);
	CHECK(newXAxis.Location().Y() == 7.0);
	CHECK(newXAxis.Location().Z() == 3.0);
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] AMCAX_API double SemiAngle()	 @return The semi-angle
	 @brief Get the semi-angle
,
 "output":#include<iostream>
#include "catch.hpp"
#include <common/FrameT.hpp>
#include <modeling/MakeFace.hpp>
#include <common/AxisT.hpp>
#include <common/FrameT.hpp>
#include <common/VectorT.hpp>
#include <math/Cone.hpp>
using namespace AMCAX;
using namespace std;
TEST_CASE("TestCone", "[math][Cone]")
{
	AMCAX::Frame3 frame;
	double radius = 5.0;
	double angle = M_PI / 4;
	AMCAX::Cone cone(frame, radius, angle);
	AMCAX::Point3 apex = cone.Apex();
	CHECK(apex.X() == 0.0);
	CHECK(apex.Y() == 0.0);
	CHECK(apex.Z() == Approx(-5.0));
	AMCAX::Axis3 axis = cone.Axis();
	std::cout << axis.Direction().X() << std::endl;
	std::cout << axis.Direction().Y() << std::endl;
	std::cout << axis.Direction().Z() << std::endl;
	CHECK(axis.Direction().X() == 0.0);
	CHECK(axis.Direction().Y() == 0.0);
	CHECK(axis.Direction().Z() == 1.0);
	double a1, a2, a3, b1, b2, b3, c1, c2, c3, d;
	cone.Coefficients(a1, a2, a3, b1, b2, b3, c1, c2, c3, d);
	std::cout << "a1: " << a1 << ", a2: " << a2 << ", a3: " << a3 << std::endl;
	std::cout << "b1: " << b1 << ", b2: " << b2 << ", b3: " << b3 << std::endl;
	std::cout << "c1: " << c1 << ", c2: " << c2 << ", c3: " << c3 << std::endl;
	std::cout << "d: " << d << std::endl;
	CHECK(a1 == 1.0);
	CHECK(a2 == 1.0);
	CHECK(a3 == Approx(-1.0));
	CHECK(b1 == 0);
	CHECK(b2 == 0);
	CHECK(b3 == 0);
	CHECK(c1 == 0);
	CHECK(c2 == 0);
	CHECK(c3 == Approx(-5.0));
	CHECK(d == -25.0);
	CHECK(cone.IsDirect() == true);
	CHECK(cone.Location().X() == 0.0);
	CHECK(cone.Location().Y() == 0.0);
	CHECK(cone.Location().Z() == 0.0);
	AMCAX::PointT<double, 3>mirrorPoint(5.0, 0.0, 0.0);
	cone.Mirror(mirrorPoint);
	auto mirroredLocation = cone.Location();
	CHECK(mirroredLocation.X() == 10.0);
	CHECK(mirroredLocation.Y() == 0.0);
	CHECK(mirroredLocation.Z() == 0.0);
	AMCAX::Frame3 coneFrame = cone.Position();
	CHECK(frame.Location().X() == 0.0);
	CHECK(frame.Location().Y() == 0.0);
	CHECK(frame.Location().Z() == 0.0);
	CHECK(cone.Radius() == 5.0);
	double  scaleCone = 2.0;
	cone.Scale(cone.Location(), scaleCone);
	CHECK(cone.Radius() == radius * 2.0);
	double semiCone = cone.SemiAngle();
	CHECK(semiCone == Approx(0.785398));
	const  Frame3& position = cone.Position();
	std::cout << position.XAxis() << std::endl;
	std::cout << position.YAxis() << std::endl;
	Direction3 zDirection(0.0, 0.0, 1.0);
	AMCAX::Point3  centerCone(0.0, 0.0, 0.0);
	Axis3 zAxis(centerCone, zDirection);
	cone.Rotated(zAxis, angle);
	AMCAX::Frame3 coneFrame2 = cone.Position();
	CHECK(coneFrame.Location().X() == 10.0);
	CHECK(coneFrame.Location().Y() == 0.0);
	CHECK(coneFrame.Location().Z() == 0.0);
	double scale = 2.0;
	cone.Scale(centerCone, scale);
	CHECK(cone.Radius() == radius * 4.0);
	double semiAngle = cone.SemiAngle();
	std::cout << semiAngle << std::endl;
	CHECK(semiAngle == Approx(0.785398));
	VectorT<double, 3> translationVector(5.0, 5.0, 0.0);
	cone.Translate(translationVector);
	CHECK(cone.Location().X() == 25.0);
	CHECK(cone.Location().Y() == 5.0);
	CHECK(cone.Location().Z() == 0.0);
	auto xAxis = cone.XAxis();
	auto yAxis = cone.YAxis();
	CHECK(xAxis.Direction().X() == Approx(-1.0));
	CHECK(yAxis.Direction().Y() == Approx(-1.0));
	AMCAX::Transformation3 tr;
	tr.SetTranslation(Vector3(1.0, 2.0, 3.0));
	cone.Transform(tr);
	Axis3 newXAxis = cone.Position().XAxis();
	CHECK(newXAxis.Location().X() == 26.0);
	CHECK(newXAxis.Location().Y() == 7.0);
	CHECK(newXAxis.Location().Z() == 3.0);
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API Cone(const Frame3& frame, double r, double angle)	 @param angle The semi-angle
	 @param r The reference radius
	 @param frame The local frame
	 @brief Construct from a local frame, a reference radius and a semi-angle
,
 "output":#include<iostream>
#include "catch.hpp"
#include <common/FrameT.hpp>
#include <modeling/MakeFace.hpp>
#include <common/AxisT.hpp>
#include <common/FrameT.hpp>
#include <common/VectorT.hpp>
#include <math/Cone.hpp>
using namespace AMCAX;
using namespace std;
TEST_CASE("TestCone", "[math][Cone]")
{
	AMCAX::Frame3 frame;
	double radius = 5.0;
	double angle = M_PI / 4;
	AMCAX::Cone cone(frame, radius, angle);
	AMCAX::Point3 apex = cone.Apex();
	CHECK(apex.X() == 0.0);
	CHECK(apex.Y() == 0.0);
	CHECK(apex.Z() == Approx(-5.0));
	AMCAX::Axis3 axis = cone.Axis();
	std::cout << axis.Direction().X() << std::endl;
	std::cout << axis.Direction().Y() << std::endl;
	std::cout << axis.Direction().Z() << std::endl;
	CHECK(axis.Direction().X() == 0.0);
	CHECK(axis.Direction().Y() == 0.0);
	CHECK(axis.Direction().Z() == 1.0);
	double a1, a2, a3, b1, b2, b3, c1, c2, c3, d;
	cone.Coefficients(a1, a2, a3, b1, b2, b3, c1, c2, c3, d);
	std::cout << "a1: " << a1 << ", a2: " << a2 << ", a3: " << a3 << std::endl;
	std::cout << "b1: " << b1 << ", b2: " << b2 << ", b3: " << b3 << std::endl;
	std::cout << "c1: " << c1 << ", c2: " << c2 << ", c3: " << c3 << std::endl;
	std::cout << "d: " << d << std::endl;
	CHECK(a1 == 1.0);
	CHECK(a2 == 1.0);
	CHECK(a3 == Approx(-1.0));
	CHECK(b1 == 0);
	CHECK(b2 == 0);
	CHECK(b3 == 0);
	CHECK(c1 == 0);
	CHECK(c2 == 0);
	CHECK(c3 == Approx(-5.0));
	CHECK(d == -25.0);
	CHECK(cone.IsDirect() == true);
	CHECK(cone.Location().X() == 0.0);
	CHECK(cone.Location().Y() == 0.0);
	CHECK(cone.Location().Z() == 0.0);
	AMCAX::PointT<double, 3>mirrorPoint(5.0, 0.0, 0.0);
	cone.Mirror(mirrorPoint);
	auto mirroredLocation = cone.Location();
	CHECK(mirroredLocation.X() == 10.0);
	CHECK(mirroredLocation.Y() == 0.0);
	CHECK(mirroredLocation.Z() == 0.0);
	AMCAX::Frame3 coneFrame = cone.Position();
	CHECK(frame.Location().X() == 0.0);
	CHECK(frame.Location().Y() == 0.0);
	CHECK(frame.Location().Z() == 0.0);
	CHECK(cone.Radius() == 5.0);
	double  scaleCone = 2.0;
	cone.Scale(cone.Location(), scaleCone);
	CHECK(cone.Radius() == radius * 2.0);
	double semiCone = cone.SemiAngle();
	CHECK(semiCone == Approx(0.785398));
	const  Frame3& position = cone.Position();
	std::cout << position.XAxis() << std::endl;
	std::cout << position.YAxis() << std::endl;
	Direction3 zDirection(0.0, 0.0, 1.0);
	AMCAX::Point3  centerCone(0.0, 0.0, 0.0);
	Axis3 zAxis(centerCone, zDirection);
	cone.Rotated(zAxis, angle);
	AMCAX::Frame3 coneFrame2 = cone.Position();
	CHECK(coneFrame.Location().X() == 10.0);
	CHECK(coneFrame.Location().Y() == 0.0);
	CHECK(coneFrame.Location().Z() == 0.0);
	double scale = 2.0;
	cone.Scale(centerCone, scale);
	CHECK(cone.Radius() == radius * 4.0);
	double semiAngle = cone.SemiAngle();
	std::cout << semiAngle << std::endl;
	CHECK(semiAngle == Approx(0.785398));
	VectorT<double, 3> translationVector(5.0, 5.0, 0.0);
	cone.Translate(translationVector);
	CHECK(cone.Location().X() == 25.0);
	CHECK(cone.Location().Y() == 5.0);
	CHECK(cone.Location().Z() == 0.0);
	auto xAxis = cone.XAxis();
	auto yAxis = cone.YAxis();
	CHECK(xAxis.Direction().X() == Approx(-1.0));
	CHECK(yAxis.Direction().Y() == Approx(-1.0));
	AMCAX::Transformation3 tr;
	tr.SetTranslation(Vector3(1.0, 2.0, 3.0));
	cone.Transform(tr);
	Axis3 newXAxis = cone.Position().XAxis();
	CHECK(newXAxis.Location().X() == 26.0);
	CHECK(newXAxis.Location().Y() == 7.0);
	CHECK(newXAxis.Location().Z() == 3.0);
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API Cone& Scale(const Point3& point, double scale)	 @return The reference to self
	 @param scale The scale value
	 @param point The scaling center point
	 @brief Scale the cone by a point
,
 "output":#include<iostream>
#include "catch.hpp"
#include <common/FrameT.hpp>
#include <modeling/MakeFace.hpp>
#include <common/AxisT.hpp>
#include <common/FrameT.hpp>
#include <common/VectorT.hpp>
#include <math/Cone.hpp>
using namespace AMCAX;
using namespace std;
TEST_CASE("TestCone", "[math][Cone]")
{
	AMCAX::Frame3 frame;
	double radius = 5.0;
	double angle = M_PI / 4;
	AMCAX::Cone cone(frame, radius, angle);
	AMCAX::Point3 apex = cone.Apex();
	CHECK(apex.X() == 0.0);
	CHECK(apex.Y() == 0.0);
	CHECK(apex.Z() == Approx(-5.0));
	AMCAX::Axis3 axis = cone.Axis();
	std::cout << axis.Direction().X() << std::endl;
	std::cout << axis.Direction().Y() << std::endl;
	std::cout << axis.Direction().Z() << std::endl;
	CHECK(axis.Direction().X() == 0.0);
	CHECK(axis.Direction().Y() == 0.0);
	CHECK(axis.Direction().Z() == 1.0);
	double a1, a2, a3, b1, b2, b3, c1, c2, c3, d;
	cone.Coefficients(a1, a2, a3, b1, b2, b3, c1, c2, c3, d);
	std::cout << "a1: " << a1 << ", a2: " << a2 << ", a3: " << a3 << std::endl;
	std::cout << "b1: " << b1 << ", b2: " << b2 << ", b3: " << b3 << std::endl;
	std::cout << "c1: " << c1 << ", c2: " << c2 << ", c3: " << c3 << std::endl;
	std::cout << "d: " << d << std::endl;
	CHECK(a1 == 1.0);
	CHECK(a2 == 1.0);
	CHECK(a3 == Approx(-1.0));
	CHECK(b1 == 0);
	CHECK(b2 == 0);
	CHECK(b3 == 0);
	CHECK(c1 == 0);
	CHECK(c2 == 0);
	CHECK(c3 == Approx(-5.0));
	CHECK(d == -25.0);
	CHECK(cone.IsDirect() == true);
	CHECK(cone.Location().X() == 0.0);
	CHECK(cone.Location().Y() == 0.0);
	CHECK(cone.Location().Z() == 0.0);
	AMCAX::PointT<double, 3>mirrorPoint(5.0, 0.0, 0.0);
	cone.Mirror(mirrorPoint);
	auto mirroredLocation = cone.Location();
	CHECK(mirroredLocation.X() == 10.0);
	CHECK(mirroredLocation.Y() == 0.0);
	CHECK(mirroredLocation.Z() == 0.0);
	AMCAX::Frame3 coneFrame = cone.Position();
	CHECK(frame.Location().X() == 0.0);
	CHECK(frame.Location().Y() == 0.0);
	CHECK(frame.Location().Z() == 0.0);
	CHECK(cone.Radius() == 5.0);
	double  scaleCone = 2.0;
	cone.Scale(cone.Location(), scaleCone);
	CHECK(cone.Radius() == radius * 2.0);
	double semiCone = cone.SemiAngle();
	CHECK(semiCone == Approx(0.785398));
	const  Frame3& position = cone.Position();
	std::cout << position.XAxis() << std::endl;
	std::cout << position.YAxis() << std::endl;
	Direction3 zDirection(0.0, 0.0, 1.0);
	AMCAX::Point3  centerCone(0.0, 0.0, 0.0);
	Axis3 zAxis(centerCone, zDirection);
	cone.Rotated(zAxis, angle);
	AMCAX::Frame3 coneFrame2 = cone.Position();
	CHECK(coneFrame.Location().X() == 10.0);
	CHECK(coneFrame.Location().Y() == 0.0);
	CHECK(coneFrame.Location().Z() == 0.0);
	double scale = 2.0;
	cone.Scale(centerCone, scale);
	CHECK(cone.Radius() == radius * 4.0);
	double semiAngle = cone.SemiAngle();
	std::cout << semiAngle << std::endl;
	CHECK(semiAngle == Approx(0.785398));
	VectorT<double, 3> translationVector(5.0, 5.0, 0.0);
	cone.Translate(translationVector);
	CHECK(cone.Location().X() == 25.0);
	CHECK(cone.Location().Y() == 5.0);
	CHECK(cone.Location().Z() == 0.0);
	auto xAxis = cone.XAxis();
	auto yAxis = cone.YAxis();
	CHECK(xAxis.Direction().X() == Approx(-1.0));
	CHECK(yAxis.Direction().Y() == Approx(-1.0));
	AMCAX::Transformation3 tr;
	tr.SetTranslation(Vector3(1.0, 2.0, 3.0));
	cone.Transform(tr);
	Axis3 newXAxis = cone.Position().XAxis();
	CHECK(newXAxis.Location().X() == 26.0);
	CHECK(newXAxis.Location().Y() == 7.0);
	CHECK(newXAxis.Location().Z() == 3.0);
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API Cone& Transform(const Transformation3& tr)	 @return The reference to self
	 @param tr The transformation
	 @brief Transform the cone
,
 "output":#include<iostream>
#include "catch.hpp"
#include <common/FrameT.hpp>
#include <modeling/MakeFace.hpp>
#include <common/AxisT.hpp>
#include <common/FrameT.hpp>
#include <common/VectorT.hpp>
#include <math/Cone.hpp>
using namespace AMCAX;
using namespace std;
TEST_CASE("TestCone", "[math][Cone]")
{
	AMCAX::Frame3 frame;
	double radius = 5.0;
	double angle = M_PI / 4;
	AMCAX::Cone cone(frame, radius, angle);
	AMCAX::Point3 apex = cone.Apex();
	CHECK(apex.X() == 0.0);
	CHECK(apex.Y() == 0.0);
	CHECK(apex.Z() == Approx(-5.0));
	AMCAX::Axis3 axis = cone.Axis();
	std::cout << axis.Direction().X() << std::endl;
	std::cout << axis.Direction().Y() << std::endl;
	std::cout << axis.Direction().Z() << std::endl;
	CHECK(axis.Direction().X() == 0.0);
	CHECK(axis.Direction().Y() == 0.0);
	CHECK(axis.Direction().Z() == 1.0);
	double a1, a2, a3, b1, b2, b3, c1, c2, c3, d;
	cone.Coefficients(a1, a2, a3, b1, b2, b3, c1, c2, c3, d);
	std::cout << "a1: " << a1 << ", a2: " << a2 << ", a3: " << a3 << std::endl;
	std::cout << "b1: " << b1 << ", b2: " << b2 << ", b3: " << b3 << std::endl;
	std::cout << "c1: " << c1 << ", c2: " << c2 << ", c3: " << c3 << std::endl;
	std::cout << "d: " << d << std::endl;
	CHECK(a1 == 1.0);
	CHECK(a2 == 1.0);
	CHECK(a3 == Approx(-1.0));
	CHECK(b1 == 0);
	CHECK(b2 == 0);
	CHECK(b3 == 0);
	CHECK(c1 == 0);
	CHECK(c2 == 0);
	CHECK(c3 == Approx(-5.0));
	CHECK(d == -25.0);
	CHECK(cone.IsDirect() == true);
	CHECK(cone.Location().X() == 0.0);
	CHECK(cone.Location().Y() == 0.0);
	CHECK(cone.Location().Z() == 0.0);
	AMCAX::PointT<double, 3>mirrorPoint(5.0, 0.0, 0.0);
	cone.Mirror(mirrorPoint);
	auto mirroredLocation = cone.Location();
	CHECK(mirroredLocation.X() == 10.0);
	CHECK(mirroredLocation.Y() == 0.0);
	CHECK(mirroredLocation.Z() == 0.0);
	AMCAX::Frame3 coneFrame = cone.Position();
	CHECK(frame.Location().X() == 0.0);
	CHECK(frame.Location().Y() == 0.0);
	CHECK(frame.Location().Z() == 0.0);
	CHECK(cone.Radius() == 5.0);
	double  scaleCone = 2.0;
	cone.Scale(cone.Location(), scaleCone);
	CHECK(cone.Radius() == radius * 2.0);
	double semiCone = cone.SemiAngle();
	CHECK(semiCone == Approx(0.785398));
	const  Frame3& position = cone.Position();
	std::cout << position.XAxis() << std::endl;
	std::cout << position.YAxis() << std::endl;
	Direction3 zDirection(0.0, 0.0, 1.0);
	AMCAX::Point3  centerCone(0.0, 0.0, 0.0);
	Axis3 zAxis(centerCone, zDirection);
	cone.Rotated(zAxis, angle);
	AMCAX::Frame3 coneFrame2 = cone.Position();
	CHECK(coneFrame.Location().X() == 10.0);
	CHECK(coneFrame.Location().Y() == 0.0);
	CHECK(coneFrame.Location().Z() == 0.0);
	double scale = 2.0;
	cone.Scale(centerCone, scale);
	CHECK(cone.Radius() == radius * 4.0);
	double semiAngle = cone.SemiAngle();
	std::cout << semiAngle << std::endl;
	CHECK(semiAngle == Approx(0.785398));
	VectorT<double, 3> translationVector(5.0, 5.0, 0.0);
	cone.Translate(translationVector);
	CHECK(cone.Location().X() == 25.0);
	CHECK(cone.Location().Y() == 5.0);
	CHECK(cone.Location().Z() == 0.0);
	auto xAxis = cone.XAxis();
	auto yAxis = cone.YAxis();
	CHECK(xAxis.Direction().X() == Approx(-1.0));
	CHECK(yAxis.Direction().Y() == Approx(-1.0));
	AMCAX::Transformation3 tr;
	tr.SetTranslation(Vector3(1.0, 2.0, 3.0));
	cone.Transform(tr);
	Axis3 newXAxis = cone.Position().XAxis();
	CHECK(newXAxis.Location().X() == 26.0);
	CHECK(newXAxis.Location().Y() == 7.0);
	CHECK(newXAxis.Location().Z() == 3.0);
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API Geom3Ellipse(const Frame3& frame, double major, double minor)	 @param minor The minor radius
	 @param major The major radius
	 @param frame The local frame
	 @brief Construct from a local frame, a major radius and a minor radius
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <common/FrameT.hpp>
#include <math/EllipseT.hpp>
#include <geometry/Geom3Ellipse.hpp>
using namespace AMCAX;
using namespace std;
#include <catch.hpp>
#include <testHelper.h>
#include <common/FrameT.hpp>
#include <math/EllipseT.hpp>
#include <geometry/Geom3Ellipse.hpp>
using namespace AMCAX;
using namespace std;
;
	SECTION("SemilatusRectum")
	{
		double SR = g3e.SemilatusRectum();
		double sr = minor * minor / major;
		CHECK(SR == sr);
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API Geom3Ellipse(const Frame3& frame, double major, double minor)	 @param minor The minor radius
	 @param major The major radius
	 @param frame The local frame
	 @brief Construct from a local frame, a major radius and a minor radius
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <geometry/MakeGeom3Ellipse.hpp>
#include <common/DirectionT.hpp>
#include <common/PointT.hpp>
#include <common/Precision.hpp>
#include <topology/TopoEdge.hpp>
#include <topology/TopoWire.hpp>
#include <topology/TopoFace.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeWire.hpp>
#include <modeling/MakeFace.hpp>
#include <modeling/MakePrism.hpp>
#include <topomesh/BRepMeshIncrementalMesh.hpp>
#include <topology/TopoExplorerTool.hpp>
#include <topology/TopoExplorer.hpp>
#include <topology/TopoCast.hpp>
#include <topology/TopoTool.hpp>
#include <math/TriangularMesh.hpp>
using namespace AMCAX;
TEST_CASE("bug1: MakeGeom3Ellipse ", "[geometry][MakeGeom3Ellipse][fixbug]") {
	MakeGeom3Ellipse makeEllipse(Frame3(), 3.0, 1.0);
	std::shared_ptr<Geom3Curve> curve = makeEllipse.Value();
	TopoEdge e = MakeEdge(curve);
	TopoWire w = MakeWire(e);
	TopoFace f = MakeFace(w);
	TopoShape s = MakePrism(f, Vector3(0.0, 0.0, 1.0));
	BRepMeshIncrementalMesh mesher(s, 0.005, true);
	int counttest = 0;
	for (TopoExplorer ex(s, ShapeType::Face); ex.More(); ex.Next())
	{
		const auto& face = TopoCast::Face(ex.Current());
		TopoLocation l;
		auto tri = TopoTool::Triangulation(face, l);
		CHECK(tri); 
		if (tri)
		{
			counttest = counttest + 1;
			if (counttest == 1)
			{
				CHECK(tri->NVertices() == 84);
				CHECK(tri->NTriangles() == 82);
			}
			if (counttest == 2)
			{
				CHECK(tri->NVertices() == 41);
				CHECK(tri->NTriangles() == 39);
			}
			if (counttest == 3)
			{
				CHECK(tri->NVertices() == 41);
				CHECK(tri->NTriangles() == 39);
			}
		}
	}
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API Geom3Hyperbola(const Frame3& frame, double major, double minor)	 @param minor The minor radius
	 @param major The major radius
	 @param frame The local frame
	 @brief Construct from a local frame, a major radius and a minor radius
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <math/EllipseT.hpp>
#include <geometry/Geom3Hyperbola.hpp>
using namespace AMCAX;
using namespace std;
#include <catch.hpp>
#include <testHelper.h>
#include <math/EllipseT.hpp>
#include <geometry/Geom3Hyperbola.hpp>
using namespace AMCAX;
using namespace std;
;
	SECTION("FocalParameter")
	{
		double FP = g3h.FocalParameter();
		double focal = 2 * sqrt(major * major + minor * minor);
		double fp = 2 * minor * minor / focal;;
		CHECK(FP == fp);
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API void Coefficients(double& a, double& b, double& c, double& d)	 @param[out] a,b,c,d The coefficients
	 @brief Get coefficients of algebraic representation: ax + by + cz + d = 0
,
 "output":#include "catch.hpp"
#include <testHelper.h>
#include <math/Plane.hpp>
using namespace AMCAX;
#include "catch.hpp"
#include <testHelper.h>
#include <math/Plane.hpp>
using namespace AMCAX;
;
	SECTION("Default constructor") {
        Plane plane;
        double a, b, c, d;
        plane.Coefficients(a, b, c, d);
        REQUIRE(a == Approx(0));
        REQUIRE(b == Approx(0));
        REQUIRE(c == Approx(1));
        REQUIRE(d == Approx(0));
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":Plane()	 Default constructor
,
 "output":#include "catch.hpp"
#include <testHelper.h>
#include <math/Plane.hpp>
using namespace AMCAX;
#include "catch.hpp"
#include <testHelper.h>
#include <math/Plane.hpp>
using namespace AMCAX;
;
	SECTION("Default constructor") {
        Plane plane;
        double a, b, c, d;
        plane.Coefficients(a, b, c, d);
        REQUIRE(a == Approx(0));
        REQUIRE(b == Approx(0));
        REQUIRE(c == Approx(1));
        REQUIRE(d == Approx(0));
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API explicit Plane(const Frame3& frame)	 @param frame The local frame
	 @brief Construct from a local frame, XOY plane
,
 "output":#include "catch.hpp"
#include <testHelper.h>
#include <math/Plane.hpp>
using namespace AMCAX;
#include "catch.hpp"
#include <testHelper.h>
#include <math/Plane.hpp>
using namespace AMCAX;
;
	SECTION("Construct from frame") {
        Frame3 frame1(Point3(0.0, 0.0, 0.0), Direction3(0.0, 0.0, 1.0));
        Frame3 frame2(Point3(1.0, 0.0, 0.0), Direction3(2.0, 1.0, 1.0));
        Plane plane1(frame1);
        Plane plane2(frame2);  
        double a1, b1, c1, d1;
        plane1.Coefficients(a1, b1, c1, d1);
        double a2, b2, c2, d2;
        plane2.Coefficients(a2, b2, c2, d2);
        REQUIRE(a1 == Approx(0));
        REQUIRE(b1 == Approx(0));
        REQUIRE(c1 == Approx(1));
        REQUIRE(d1 == Approx(0));
        REQUIRE(a2 == Approx(2. / std::sqrt(6)));
        REQUIRE(b2 == Approx(1. / std::sqrt(6)));
        REQUIRE(c2 == Approx(1. / std::sqrt(6)));
        REQUIRE(d2 == Approx(-2. / std::sqrt(6)));
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API Plane(const Point3& point, const Direction3& dir)	 @param dir The direction
	 @param point The point
	 @brief Construct from a point and a direction
,
 "output":#include "catch.hpp"
#include <testHelper.h>
#include <math/Plane.hpp>
using namespace AMCAX;
#include "catch.hpp"
#include <testHelper.h>
#include <math/Plane.hpp>
using namespace AMCAX;
;
	SECTION("Construct from point and direction") {
        Point3 point(1., 1., 1.);
        Direction3 dir(0., 0., 1.);
        Plane plane(point, dir);  
        Point3 point2(3., 4., 4.);
        Direction3 dir2(2., 2., 1.);
        Plane plane2(point2, dir2);  
        double a, b, c, d;
        plane.Coefficients(a, b, c, d);
        double a2, b2, c2, d2;
        plane2.Coefficients(a2, b2, c2, d2);
        REQUIRE(a == Approx(0));
        REQUIRE(b == Approx(0));
        REQUIRE(c == Approx(1));
        REQUIRE(d == Approx(-1));
        REQUIRE(a2 == Approx(2./3).margin(0.0001));
        REQUIRE(b2 == Approx(2./3).margin(0.0001));
        REQUIRE(c2 == Approx(1./3).margin(0.0001));
        REQUIRE(d2 == Approx(-6));
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API Plane(double a, double b, double c, double d)	 @param a,b,c,d The coefficients
	 @brief Construct from an algebraic representation: ax + by + cz + d = 0
,
 "output":#include "catch.hpp"
#include <testHelper.h>
#include <math/Plane.hpp>
using namespace AMCAX;
#include "catch.hpp"
#include <testHelper.h>
#include <math/Plane.hpp>
using namespace AMCAX;
;
	SECTION("Construct from frame") {
        Frame3 frame1(Point3(0.0, 0.0, 0.0), Direction3(0.0, 0.0, 1.0));
        Frame3 frame2(Point3(1.0, 0.0, 0.0), Direction3(2.0, 1.0, 1.0));
        Plane plane1(frame1);
        Plane plane2(frame2);  
        double a1, b1, c1, d1;
        plane1.Coefficients(a1, b1, c1, d1);
        double a2, b2, c2, d2;
        plane2.Coefficients(a2, b2, c2, d2);
        REQUIRE(a1 == Approx(0));
        REQUIRE(b1 == Approx(0));
        REQUIRE(c1 == Approx(1));
        REQUIRE(d1 == Approx(0));
        REQUIRE(a2 == Approx(2. / std::sqrt(6)));
        REQUIRE(b2 == Approx(1. / std::sqrt(6)));
        REQUIRE(c2 == Approx(1. / std::sqrt(6)));
        REQUIRE(d2 == Approx(-2. / std::sqrt(6)));
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] AMCAX_API bool Contains(const Point3& point, double tol)	 @return True if the distance between the point and the plane is under the distance tolerance
	 @param tol The distance tolerance
	 @param point The point
	 @brief Determines whether the plane contains a point under a tolerance or not
,
 "output":#include "catch.hpp"
#include <testHelper.h>
#include <math/Plane.hpp>
using namespace AMCAX;
#include "catch.hpp"
#include <testHelper.h>
#include <math/Plane.hpp>
using namespace AMCAX;
;
	SECTION("Contains methods") {
        std::function<bool(const Plane&, const Point3&)> pointInPlane = [](const Plane& plane, const Point3& point)->bool {
            Point3 planePoint = plane.Location();  
            Vector3 planeVector(planePoint, point);  
            double a, b, c, d;
            plane.Coefficients(a, b, c, d);
            return planeVector.Dot(Vector3(a, b, c)) == 0;
        };
        Plane plane(0., 0., 1., -1.); 
        Point3 point(1., 1., 1.);
        Point3 point2(1., 1., 2.);
        Line3 line(Point3(1., 1., 1.), Direction3(1., 0., 0.));
        Line3 line2(Point3(1., 1., 1.), Direction3(0., 0., 1.));  
        Line3 line3(Point3(1., 1., 0.), Direction3(1., 0., 0.));
        REQUIRE(plane.Contains(point, 1e-6) == pointInPlane(plane, point));
        REQUIRE(plane.Contains(point2, 1e-6) == pointInPlane(plane, point2));
        REQUIRE(plane.Contains(line, 1e-6, 1e-6));
        REQUIRE_FALSE(plane.Contains(line2, 1e-6, 1e-6 * (M_PI / 180)));
        REQUIRE_FALSE(plane.Contains(line3, 1e-6, 1e-6 * (M_PI / 180)));
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API GeomAPIIntCurveCurve2(const std::shared_ptr<Geom2Curve>& c1, const std::shared_ptr<Geom2Curve>& c2, double tol = 1.0e-6)	 @param tol The tolerance for computing intersection
	 @param c2 The second curve
	 @param c1 The first curve
	 @brief Construct from two curves
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <sstream>
#include <geometry/GeomAPIIntCurveCurve2.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <common/PointT.hpp>
using namespace AMCAX;
TEST_CASE("bug1: GeomAPIIntCurveCurve2  add 1 cases", "[geometry][GeomAPIIntCurveCurve2][fixbug]") {
	std::shared_ptr<Geom2BSplineCurve> bs1 = std::make_shared<Geom2BSplineCurve>();
	std::shared_ptr<Geom2BSplineCurve> bs2 = std::make_shared<Geom2BSplineCurve>();
	std::string str1 = "7 0 0 3 118 116 0.32094859236148043 1.01737460557672743 0.32206087674542322 1.01734745284654182 0.32382938579023346 1.01745552974970388 0.32622057752030481 1.01788932455950976 0.32814024437537276 1.01839643017089987 0.33002743385020250 1.01906060903165452 0.33185490242395432 1.01986927403602690 0.33356030574937923 1.02078382513330879 0.33505523022905437 1.02172426942215600 0.33630356053380972 1.02261635998227951 0.33727879099865676 1.02338700329485177 0.33824387261988464 1.02421002336103761 0.33987143181385676 1.02571995716873454 0.34214827935107528 1.02826048315421636 0.34461603767621785 1.03183954355064644 0.34665036808905569 1.03570920433382874 0.34820760193471290 1.03964073803085988 0.34933771881337422 1.04355887677937265 0.35009685624211401 1.04745091431990089 0.35052967495496640 1.05132419100513896 0.35066857936404372 1.05518894219017056 0.35052557522962369 1.05904245911643380 0.35008366013718967 1.06287636600114777 0.34929841370764381 1.06667869354746858 0.34813822094610908 1.07042299939338448 0.34675750395147792 1.07412664136932645 0.34534310541281921 1.07786690172476352 0.34358161112094421 1.08147777823012681 0.34192774635989071 1.08514486567176727 0.34024883979957521 1.08877932697709046 0.33856258005747963 1.09239630776272234 0.33684922584157972 1.09599070530577980 0.33511401239025801 1.09956576491048708 0.33335775759028152 1.10312101734871382 0.33158157690922768 1.10665621463276231 0.32978475270252700 1.11017051339371275 0.32796684236813672 1.11366345386663435 0.32612725706778090 1.11713471339148707 0.32426602655273468 1.12058421069008607 0.32238317488364737 1.12401188835076016 0.32047891905305792 1.12741748347385329 0.31855350786840358 1.13080068581386772 0.31660697714151498 1.13416123619352938 0.31463922025518198 1.13749923563291944 0.31264987984545162 1.14081514934997053 0.31063848196500760 1.14410959402646872 0.30860463164217128 1.14738321401338195 0.30654793927361806 1.15063653610177630 0.30446802732993405 1.15386990664646771 0.30236451953097970 1.15708359051903131 0.30023708628717172 1.16027763956461594 0.29808538476977109 1.16345202237806822 0.29590934129126883 1.16660648017917135 0.29370889405197392 1.16974079885919968 0.29148391413490155 1.17285470277829651 0.28923416621699150 1.17594813233618023 0.28695938621068906 1.17902112690429606 0.28465933895561080 1.18207371247860404 0.28233386645185193 1.18510589143436862 0.27998289479713001 1.18811761370470093 0.27760632123816548 1.19110879993250829 0.27520390350264767 1.19407947381928281 0.27277523052158237 1.19702979458848002 0.27031974327907626 1.19995999134850062 0.26783696716142708 1.20287004707951173 0.26532688195672521 1.20575953789980805 0.26278972678816304 1.20862781671414088 0.26022529469643624 1.21147474893699236 0.25763217763048496 1.21430150477218790 0.25500825126397131 1.21710994249041904 0.25235292985377017 1.21990005059103868 0.24966926670272568 1.22266796329330352 0.24696150391975732 1.22540882939352413 0.24423004526152650 1.22812190210150329 0.24146125706394184 1.23081996151861128 0.23861784080316129 1.23353765899792966 0.23566141121739081 1.23630795850379083 0.23313267974624646 1.23863075403103817 0.23108077081313610 1.24048682151979905 0.22951564660225790 1.24188808346222479 0.22785243018268259 1.24336238482365724 0.22603998536410663 1.24495322387069107 0.22406854105345719 1.24666425686480453 0.22194392374121000 1.24848570059305053 0.21966929759239204 1.25041206987825992 0.21725182330646176 1.25242961584586521 0.21469769930661789 1.25453321201678158 0.21201305169290471 1.25670455099802481 0.20919423964305814 1.25892740388225111 0.20624946264626334 1.26119206481064094 0.20318480037069683 1.26348679862854585 0.20000837020587425 1.26579929017010295 0.19672786860887337 1.26811801505294564 0.19336384906039994 1.27045063232052602 0.18992974310269095 1.27279484301208434 0.18643645229630731 1.27514361933883413 0.18288284026026952 1.27747988214753017 0.17926432420455884 1.27979154638979287 0.17557650128119320 1.28206361390544510 0.17182058886568480 1.28428512148975549 0.16804984196678602 1.28645557821983747 0.16432856924206579 1.28857394891545374 0.16070988708733733 1.29064090195652370 0.15717518220101778 1.29262871928824441 0.15369583278895632 1.29452720045016001 0.15026398879500619 1.29632707889676935 0.14689767435611573 1.29803910611286755 0.14368667318979397 1.29963940415365520 0.14066793270237543 1.30110806215344477 0.13786588940702740 1.30241800503027294 0.13522308508227587 1.30359724798135068 0.13268958893136670 1.30462396744174369 0.13022457745464813 1.30549794019590903 0.12782549497702861 1.30621459673763263 0.12551678736811231 1.30677267551026310 0.12264034969535306 1.30729452653584777 0.12051776185100731 1.30747541630908004 0.11912669923861925 1.30748468412943986 0.00000000000000000 4 0.00332678777314067 1 0.00530015559541836 1 0.00728182036673812 1 0.00927733380420748 1 0.01129573787307914 1 0.01327102124276026 1 0.01507750651120846 1 0.01659037664031113 1 0.01787187841143642 1 0.01880519345805253 1 0.02039488120903255 1 0.02452963651417061 1 0.02900897063209700 1 0.03340295596517878 1 0.03761684169382203 1 0.04167362563339645 1 0.04561938121714045 1 0.04949884613367380 1 0.05335394957604591 1 0.05721079085185987 1 0.06105670932975029 1 0.06491896046411526 1 0.06884011522460366 1 0.07280266881291077 1 0.07677853454115921 1 0.08082727159450992 1 0.08484703393156430 1 0.08884800850224144 1 0.09283736315162679 1 0.09681928451811667 1 0.10079344442245329 1 0.10475903456581770 1 0.10871533221895527 1 0.11266230101625047 1 0.11659995734938959 1 0.12052830686968952 1 0.12444792190998373 1 0.12835862681996368 1 0.13226049935437312 1 0.13615329767464079 1 0.14003667398886835 1 0.14391115976349200 1 0.14777767334262687 1 0.15163719748113480 1 0.15549084375107922 1 0.15933948557025243 1 0.16318380109489106 1 0.16702443368061037 1 0.17086206197732215 1 0.17469676853931951 1 0.17852903287965541 1 0.18235853795986209 1 0.18618547107174704 1 0.19001029311391093 1 0.19383342115543040 1 0.19765535049879729 1 0.20147647336026475 1 0.20529702393677510 1 0.20911722784810613 1 0.21293746918119616 1 0.21675849605951392 1 0.22058118324198547 1 0.22440637655431431 1 0.22823412013034025 1 0.23206350223258385 1 0.23589437276278422 1 0.23972883230279066 1 0.24357130772232163 1 0.24742464110863499 1 0.25128370603023881 1 0.25513705909052109 1 0.25898297113943686 1 0.26283319300761221 1 0.26673478756179048 1 0.27078270046115210 1 0.27498764230925066 1 0.27703550353465400 1 0.27908314380440813 1 0.28128986356810332 1 0.28370321223532124 1 0.28631785618959721 1 0.28912103899968400 1 0.29209869219406109 1 0.29526001444575162 1 0.29856723628509552 1 0.30202524340776099 1 0.30561830049238314 1 0.30933640124059564 1 0.31316962603536763 1 0.31710368845632919 1 0.32112310784334058 1 0.32522104893482329 1 0.32938444032265624 1 0.33359681084096160 1 0.33784938027078792 1 0.34214253792603233 1 0.34647801531348960 1 0.35084331838884097 1 0.35523312810758656 1 0.35953028089402317 1 0.36368926465670970 1 0.36773529430744634 1 0.37169603595072809 1 0.37557957415417503 1 0.37936041511409840 1 0.38302581855344769 1 0.38634253837102683 1 0.38943124796238249 1 0.39230486518080748 1 0.39502350628500010 1 0.39762992993310575 1 0.40014797436892702 1 0.40253156052235123 1 0.40475213727501114 1 0.40891189273334161 4";
	std::string str2 = "7 0 0 3 118 116 0.44698587761425512 1.01737460557672743 0.44586770461012754 1.01734792256404072 0.44408669680926910 1.01745649198371058 0.44167433575859827 1.01788973448550668 0.43973012306214176 1.01839676158274872 0.43781512528503469 1.01906078430998237 0.43595772107855257 1.01986941991017832 0.43422167753434071 1.02078367982801188 0.43270019179331992 1.02172276730688871 0.43143529102668837 1.02260881639260637 0.43047395316133663 1.02337915724656336 0.42956918011417972 1.02417518983407696 0.42818486699350283 1.02596609318184684 0.42535867595845256 1.02808829688484948 0.42284370487027889 1.03193726498772675 0.42029420450207700 1.03578860458891087 0.41779215915839102 1.03971518009696795 0.41524996629274769 1.04360952276868124 0.41268259846706867 1.04748256529635642 0.41009244215779894 1.05134004607881448 0.40748344575385259 1.05519270420095079 0.40486605902395167 1.05904184662506151 0.40221826431976609 1.06286057810161427 0.39954731386633807 1.06664354970287856 0.39685998643058945 1.07039722937908555 0.39415205518567858 1.07412233241535748 0.39142459506816268 1.07782095032413006 0.38867831705369166 1.08149595009323263 0.38591346143208760 1.08514964980580220 0.38313020259072789 1.08878346979564511 0.38032844124366111 1.09239780218286464 0.37750825751929029 1.09599269297900204 0.37466975732311525 1.09956803650327561 0.37181298113969291 1.10312349001628252 0.36893792871143949 1.10665859650325404 0.36604460396156768 1.11017278012274700 0.36313313466979064 1.11366550770546358 0.36020385654578302 1.11713665503127646 0.35725711512561398 1.12058603617284369 0.35429324377611354 1.12401373368655166 0.35131230158758986 1.12741939957610104 0.34831421468687968 1.13080262402140796 0.34529890614255510 1.13416313676223202 0.34226629246633017 1.13750078799254517 0.33921704684458587 1.14081632451049253 0.33615179652790328 1.14411040925898311 0.33307117902797256 1.14738370759211961 0.32997572188237095 1.15063676015840910 0.32686583766548316 1.15386986351118148 0.32374192911050353 1.15708326206532552 0.32060452465855971 1.16027718535470581 0.31745360371300196 1.16345153388182476 0.31428913900094868 1.16660594252951411 0.31111112410899561 1.16974020701489989 0.30791955045097874 1.17285394667146026 0.30471460628308072 1.17594719675858417 0.30149648916692096 1.17901999285247383 0.29826547554743049 1.18207244366664344 0.29502169193428479 1.18510458595828827 0.29176503889034477 1.18811625270052801 0.28849545711393992 1.19110735246150123 0.28521287446926513 1.19407776448826497 0.28191760121088905 1.19702778959143030 0.27860991172799571 1.19995767798350750 0.27529017147185769 1.20286775332443230 0.27195821134041676 1.20575742910935957 0.26861365400632170 1.20862591999664737 0.26525581006410243 1.21147208574228693 0.26188571532285843 1.21429744804454320 0.25850537979441068 1.21710464921168948 0.25511712957007160 1.21989678109210420 0.25171762413613974 1.22266823849310202 0.24830072265899519 1.22540963473078257 0.24486605329372579 1.22811942696225307 0.24141572018592131 1.23080424790172627 0.23796057988059283 1.23349025995382422 0.23455481289528443 1.23625809731511249 0.23178384866187560 1.23861884218329443 0.22958637070091326 1.24049429822100898 0.22792095077852323 1.24183892665189632 0.22633085712869647 1.24330474335321250 0.22482706539293790 1.24489950308425112 0.22341229813088337 1.24661390687506479 0.22209453169097026 1.24843902517094874 0.22087888937927413 1.25036828651214238 0.21977124333451431 1.25238938953827761 0.21877814583739183 1.25449449573067429 0.21790282053379528 1.25666553458695951 0.21714464814126716 1.25889056843647418 0.21650897231276728 1.26115706505645897 0.21599821380382661 1.26345359947659142 0.21561431786668875 1.26576891766763566 0.21535790133274418 1.26809712034575073 0.21523156999800702 1.27043621478677027 0.21523493789335055 1.27278382859372918 0.21536761702246404 1.27513094567987695 0.21562960091705158 1.27746540211106607 0.21601986302685286 1.27977480962963663 0.21653701136757098 1.28204820066314440 0.21718164535537912 1.28428355977126407 0.21795318927362628 1.28647141444648527 0.21885182671844836 1.28860254299760535 0.21987018385314080 1.29066214545958857 0.22100473503305496 1.29264388729952517 0.22225426990375063 1.29454179066819441 0.22361918358992602 1.29635228361390098 0.22510542017288909 1.29807648877092108 0.22668582626421535 1.29967791748795536 0.22833572049978873 1.30113992652563426 0.23002054288496601 1.30245118636949164 0.23175614453859494 1.30361712921158590 0.23353904515484103 1.30463669825309792 0.23536790944712538 1.30550821214031298 0.23723013129137352 1.30622515706156905 0.23909802022459714 1.30677963590280544 0.24158931746901185 1.30731428646199599 0.24348144169383945 1.30748511863814065 0.24475247407226391 1.30748468412943986 0.00000000000000000 4 0.00334434293035562 1 0.00533825930397336 1 0.00734412586267121 1 0.00936623440575543 1 0.01141256205459959 1 0.01341573096600146 1 0.01524709020284723 1 0.01677336277701813 1 0.01804490068923616 1 0.01894326352103789 1 0.02037993823386658 1 0.02480566898074880 1 0.02939205655814846 1 0.03404043378943207 1 0.03869805978018042 1 0.04334980332413108 1 0.04799487443159717 1 0.05263737365801836 1 0.05728913631958347 1 0.06195364423015201 1 0.06660152728460191 1 0.07122956329812886 1 0.07584610283920201 1 0.08045084571229059 1 0.08504550471877484 1 0.08963256787874113 1 0.09421407873103112 1 0.09879117107574811 1 0.10336422781387057 1 0.10793330889559200 1 0.11249839490034602 1 0.11705945929549585 1 0.12161613091223618 1 0.12616821278487000 1 0.13071541215010135 1 0.13525724181627602 1 0.13979405378099050 1 0.14432538686178745 1 0.14885137954117900 1 0.15337193703905613 1 0.15788673904588241 1 0.16239626042792893 1 0.16690070771036525 1 0.17140021344792761 1 0.17589510396468730 1 0.18038552504431565 1 0.18487151865902063 1 0.18935308684053462 1 0.19383026236900400 1 0.19830276789454376 1 0.20277103974370816 1 0.20723457084840083 1 0.21169339151646616 1 0.21614758290681596 1 0.22059709488399620 1 0.22504193032631326 1 0.22948214264998190 1 0.23391784916535033 1 0.23834913245589026 1 0.24277612072013041 1 0.24719890919114179 1 0.25161757662768108 1 0.25603221057958453 1 0.26044282613505232 1 0.26484890217770901 1 0.26925063819864326 1 0.27364813118187725 1 0.27804209715833189 1 0.28243253716855193 1 0.28681951085634216 1 0.29120020890283443 1 0.29557446914500052 1 0.29994411461100146 1 0.30431579875993647 1 0.30870332268475420 1 0.31310853612917888 1 0.31523624508228770 1 0.31737014111002310 1 0.31952856178681960 1 0.32171830465981011 1 0.32394102970905830 1 0.32619217521253946 1 0.32846706602101300 1 0.33077763413829298 1 0.33310205916533187 1 0.33544576479270716 1 0.33779655322040053 1 0.34015052354015518 1 0.34250407705161767 1 0.34485099381932000 1 0.34718783135835085 1 0.34952735554083242 1 0.35187486439618521 1 0.35422711580943594 1 0.35657637606518838 1 0.35891858548088795 1 0.36124990679045155 1 0.36356703547085450 1 0.36589411785453302 1 0.36820554269186456 1 0.37050138589761700 1 0.37278277874756854 1 0.37505181955993466 1 0.37731379776658153 1 0.37958010527703534 1 0.38187591368213569 1 0.38405827564667433 1 0.38618898795548318 1 0.38827607822097537 1 0.39032555279796965 1 0.39234499730597777 1 0.39434796008648582 1 0.39630575790533801 1 0.39818438284552959 1 0.40198436891082029 4";
	std::istringstream iss1(str1);
	std::istringstream iss2(str2);
	iss1 >> *bs1;
	iss2 >> *bs2;
	GeomAPIIntCurveCurve2 icc(bs1, bs2, 1e-12);
	CHECK(icc.NPoints() == 2);
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API explicit GeomAPIIntCurveCurve2(const std::shared_ptr<Geom2Curve>& c1, double tol = 1.0e-6)	 @param tol The tolerance for computing self-intersection
	 @param c1 The curve
	 @brief Construct from one curve for finding self-intersections
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <sstream>
#include <geometry/GeomAPIIntCurveCurve2.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <common/PointT.hpp>
using namespace AMCAX;
TEST_CASE("bug1: GeomAPIIntCurveCurve2  add 1 cases", "[geometry][GeomAPIIntCurveCurve2][fixbug]") {
	std::shared_ptr<Geom2BSplineCurve> bs1 = std::make_shared<Geom2BSplineCurve>();
	std::shared_ptr<Geom2BSplineCurve> bs2 = std::make_shared<Geom2BSplineCurve>();
	std::string str1 = "7 0 0 3 118 116 0.32094859236148043 1.01737460557672743 0.32206087674542322 1.01734745284654182 0.32382938579023346 1.01745552974970388 0.32622057752030481 1.01788932455950976 0.32814024437537276 1.01839643017089987 0.33002743385020250 1.01906060903165452 0.33185490242395432 1.01986927403602690 0.33356030574937923 1.02078382513330879 0.33505523022905437 1.02172426942215600 0.33630356053380972 1.02261635998227951 0.33727879099865676 1.02338700329485177 0.33824387261988464 1.02421002336103761 0.33987143181385676 1.02571995716873454 0.34214827935107528 1.02826048315421636 0.34461603767621785 1.03183954355064644 0.34665036808905569 1.03570920433382874 0.34820760193471290 1.03964073803085988 0.34933771881337422 1.04355887677937265 0.35009685624211401 1.04745091431990089 0.35052967495496640 1.05132419100513896 0.35066857936404372 1.05518894219017056 0.35052557522962369 1.05904245911643380 0.35008366013718967 1.06287636600114777 0.34929841370764381 1.06667869354746858 0.34813822094610908 1.07042299939338448 0.34675750395147792 1.07412664136932645 0.34534310541281921 1.07786690172476352 0.34358161112094421 1.08147777823012681 0.34192774635989071 1.08514486567176727 0.34024883979957521 1.08877932697709046 0.33856258005747963 1.09239630776272234 0.33684922584157972 1.09599070530577980 0.33511401239025801 1.09956576491048708 0.33335775759028152 1.10312101734871382 0.33158157690922768 1.10665621463276231 0.32978475270252700 1.11017051339371275 0.32796684236813672 1.11366345386663435 0.32612725706778090 1.11713471339148707 0.32426602655273468 1.12058421069008607 0.32238317488364737 1.12401188835076016 0.32047891905305792 1.12741748347385329 0.31855350786840358 1.13080068581386772 0.31660697714151498 1.13416123619352938 0.31463922025518198 1.13749923563291944 0.31264987984545162 1.14081514934997053 0.31063848196500760 1.14410959402646872 0.30860463164217128 1.14738321401338195 0.30654793927361806 1.15063653610177630 0.30446802732993405 1.15386990664646771 0.30236451953097970 1.15708359051903131 0.30023708628717172 1.16027763956461594 0.29808538476977109 1.16345202237806822 0.29590934129126883 1.16660648017917135 0.29370889405197392 1.16974079885919968 0.29148391413490155 1.17285470277829651 0.28923416621699150 1.17594813233618023 0.28695938621068906 1.17902112690429606 0.28465933895561080 1.18207371247860404 0.28233386645185193 1.18510589143436862 0.27998289479713001 1.18811761370470093 0.27760632123816548 1.19110879993250829 0.27520390350264767 1.19407947381928281 0.27277523052158237 1.19702979458848002 0.27031974327907626 1.19995999134850062 0.26783696716142708 1.20287004707951173 0.26532688195672521 1.20575953789980805 0.26278972678816304 1.20862781671414088 0.26022529469643624 1.21147474893699236 0.25763217763048496 1.21430150477218790 0.25500825126397131 1.21710994249041904 0.25235292985377017 1.21990005059103868 0.24966926670272568 1.22266796329330352 0.24696150391975732 1.22540882939352413 0.24423004526152650 1.22812190210150329 0.24146125706394184 1.23081996151861128 0.23861784080316129 1.23353765899792966 0.23566141121739081 1.23630795850379083 0.23313267974624646 1.23863075403103817 0.23108077081313610 1.24048682151979905 0.22951564660225790 1.24188808346222479 0.22785243018268259 1.24336238482365724 0.22603998536410663 1.24495322387069107 0.22406854105345719 1.24666425686480453 0.22194392374121000 1.24848570059305053 0.21966929759239204 1.25041206987825992 0.21725182330646176 1.25242961584586521 0.21469769930661789 1.25453321201678158 0.21201305169290471 1.25670455099802481 0.20919423964305814 1.25892740388225111 0.20624946264626334 1.26119206481064094 0.20318480037069683 1.26348679862854585 0.20000837020587425 1.26579929017010295 0.19672786860887337 1.26811801505294564 0.19336384906039994 1.27045063232052602 0.18992974310269095 1.27279484301208434 0.18643645229630731 1.27514361933883413 0.18288284026026952 1.27747988214753017 0.17926432420455884 1.27979154638979287 0.17557650128119320 1.28206361390544510 0.17182058886568480 1.28428512148975549 0.16804984196678602 1.28645557821983747 0.16432856924206579 1.28857394891545374 0.16070988708733733 1.29064090195652370 0.15717518220101778 1.29262871928824441 0.15369583278895632 1.29452720045016001 0.15026398879500619 1.29632707889676935 0.14689767435611573 1.29803910611286755 0.14368667318979397 1.29963940415365520 0.14066793270237543 1.30110806215344477 0.13786588940702740 1.30241800503027294 0.13522308508227587 1.30359724798135068 0.13268958893136670 1.30462396744174369 0.13022457745464813 1.30549794019590903 0.12782549497702861 1.30621459673763263 0.12551678736811231 1.30677267551026310 0.12264034969535306 1.30729452653584777 0.12051776185100731 1.30747541630908004 0.11912669923861925 1.30748468412943986 0.00000000000000000 4 0.00332678777314067 1 0.00530015559541836 1 0.00728182036673812 1 0.00927733380420748 1 0.01129573787307914 1 0.01327102124276026 1 0.01507750651120846 1 0.01659037664031113 1 0.01787187841143642 1 0.01880519345805253 1 0.02039488120903255 1 0.02452963651417061 1 0.02900897063209700 1 0.03340295596517878 1 0.03761684169382203 1 0.04167362563339645 1 0.04561938121714045 1 0.04949884613367380 1 0.05335394957604591 1 0.05721079085185987 1 0.06105670932975029 1 0.06491896046411526 1 0.06884011522460366 1 0.07280266881291077 1 0.07677853454115921 1 0.08082727159450992 1 0.08484703393156430 1 0.08884800850224144 1 0.09283736315162679 1 0.09681928451811667 1 0.10079344442245329 1 0.10475903456581770 1 0.10871533221895527 1 0.11266230101625047 1 0.11659995734938959 1 0.12052830686968952 1 0.12444792190998373 1 0.12835862681996368 1 0.13226049935437312 1 0.13615329767464079 1 0.14003667398886835 1 0.14391115976349200 1 0.14777767334262687 1 0.15163719748113480 1 0.15549084375107922 1 0.15933948557025243 1 0.16318380109489106 1 0.16702443368061037 1 0.17086206197732215 1 0.17469676853931951 1 0.17852903287965541 1 0.18235853795986209 1 0.18618547107174704 1 0.19001029311391093 1 0.19383342115543040 1 0.19765535049879729 1 0.20147647336026475 1 0.20529702393677510 1 0.20911722784810613 1 0.21293746918119616 1 0.21675849605951392 1 0.22058118324198547 1 0.22440637655431431 1 0.22823412013034025 1 0.23206350223258385 1 0.23589437276278422 1 0.23972883230279066 1 0.24357130772232163 1 0.24742464110863499 1 0.25128370603023881 1 0.25513705909052109 1 0.25898297113943686 1 0.26283319300761221 1 0.26673478756179048 1 0.27078270046115210 1 0.27498764230925066 1 0.27703550353465400 1 0.27908314380440813 1 0.28128986356810332 1 0.28370321223532124 1 0.28631785618959721 1 0.28912103899968400 1 0.29209869219406109 1 0.29526001444575162 1 0.29856723628509552 1 0.30202524340776099 1 0.30561830049238314 1 0.30933640124059564 1 0.31316962603536763 1 0.31710368845632919 1 0.32112310784334058 1 0.32522104893482329 1 0.32938444032265624 1 0.33359681084096160 1 0.33784938027078792 1 0.34214253792603233 1 0.34647801531348960 1 0.35084331838884097 1 0.35523312810758656 1 0.35953028089402317 1 0.36368926465670970 1 0.36773529430744634 1 0.37169603595072809 1 0.37557957415417503 1 0.37936041511409840 1 0.38302581855344769 1 0.38634253837102683 1 0.38943124796238249 1 0.39230486518080748 1 0.39502350628500010 1 0.39762992993310575 1 0.40014797436892702 1 0.40253156052235123 1 0.40475213727501114 1 0.40891189273334161 4";
	std::string str2 = "7 0 0 3 118 116 0.44698587761425512 1.01737460557672743 0.44586770461012754 1.01734792256404072 0.44408669680926910 1.01745649198371058 0.44167433575859827 1.01788973448550668 0.43973012306214176 1.01839676158274872 0.43781512528503469 1.01906078430998237 0.43595772107855257 1.01986941991017832 0.43422167753434071 1.02078367982801188 0.43270019179331992 1.02172276730688871 0.43143529102668837 1.02260881639260637 0.43047395316133663 1.02337915724656336 0.42956918011417972 1.02417518983407696 0.42818486699350283 1.02596609318184684 0.42535867595845256 1.02808829688484948 0.42284370487027889 1.03193726498772675 0.42029420450207700 1.03578860458891087 0.41779215915839102 1.03971518009696795 0.41524996629274769 1.04360952276868124 0.41268259846706867 1.04748256529635642 0.41009244215779894 1.05134004607881448 0.40748344575385259 1.05519270420095079 0.40486605902395167 1.05904184662506151 0.40221826431976609 1.06286057810161427 0.39954731386633807 1.06664354970287856 0.39685998643058945 1.07039722937908555 0.39415205518567858 1.07412233241535748 0.39142459506816268 1.07782095032413006 0.38867831705369166 1.08149595009323263 0.38591346143208760 1.08514964980580220 0.38313020259072789 1.08878346979564511 0.38032844124366111 1.09239780218286464 0.37750825751929029 1.09599269297900204 0.37466975732311525 1.09956803650327561 0.37181298113969291 1.10312349001628252 0.36893792871143949 1.10665859650325404 0.36604460396156768 1.11017278012274700 0.36313313466979064 1.11366550770546358 0.36020385654578302 1.11713665503127646 0.35725711512561398 1.12058603617284369 0.35429324377611354 1.12401373368655166 0.35131230158758986 1.12741939957610104 0.34831421468687968 1.13080262402140796 0.34529890614255510 1.13416313676223202 0.34226629246633017 1.13750078799254517 0.33921704684458587 1.14081632451049253 0.33615179652790328 1.14411040925898311 0.33307117902797256 1.14738370759211961 0.32997572188237095 1.15063676015840910 0.32686583766548316 1.15386986351118148 0.32374192911050353 1.15708326206532552 0.32060452465855971 1.16027718535470581 0.31745360371300196 1.16345153388182476 0.31428913900094868 1.16660594252951411 0.31111112410899561 1.16974020701489989 0.30791955045097874 1.17285394667146026 0.30471460628308072 1.17594719675858417 0.30149648916692096 1.17901999285247383 0.29826547554743049 1.18207244366664344 0.29502169193428479 1.18510458595828827 0.29176503889034477 1.18811625270052801 0.28849545711393992 1.19110735246150123 0.28521287446926513 1.19407776448826497 0.28191760121088905 1.19702778959143030 0.27860991172799571 1.19995767798350750 0.27529017147185769 1.20286775332443230 0.27195821134041676 1.20575742910935957 0.26861365400632170 1.20862591999664737 0.26525581006410243 1.21147208574228693 0.26188571532285843 1.21429744804454320 0.25850537979441068 1.21710464921168948 0.25511712957007160 1.21989678109210420 0.25171762413613974 1.22266823849310202 0.24830072265899519 1.22540963473078257 0.24486605329372579 1.22811942696225307 0.24141572018592131 1.23080424790172627 0.23796057988059283 1.23349025995382422 0.23455481289528443 1.23625809731511249 0.23178384866187560 1.23861884218329443 0.22958637070091326 1.24049429822100898 0.22792095077852323 1.24183892665189632 0.22633085712869647 1.24330474335321250 0.22482706539293790 1.24489950308425112 0.22341229813088337 1.24661390687506479 0.22209453169097026 1.24843902517094874 0.22087888937927413 1.25036828651214238 0.21977124333451431 1.25238938953827761 0.21877814583739183 1.25449449573067429 0.21790282053379528 1.25666553458695951 0.21714464814126716 1.25889056843647418 0.21650897231276728 1.26115706505645897 0.21599821380382661 1.26345359947659142 0.21561431786668875 1.26576891766763566 0.21535790133274418 1.26809712034575073 0.21523156999800702 1.27043621478677027 0.21523493789335055 1.27278382859372918 0.21536761702246404 1.27513094567987695 0.21562960091705158 1.27746540211106607 0.21601986302685286 1.27977480962963663 0.21653701136757098 1.28204820066314440 0.21718164535537912 1.28428355977126407 0.21795318927362628 1.28647141444648527 0.21885182671844836 1.28860254299760535 0.21987018385314080 1.29066214545958857 0.22100473503305496 1.29264388729952517 0.22225426990375063 1.29454179066819441 0.22361918358992602 1.29635228361390098 0.22510542017288909 1.29807648877092108 0.22668582626421535 1.29967791748795536 0.22833572049978873 1.30113992652563426 0.23002054288496601 1.30245118636949164 0.23175614453859494 1.30361712921158590 0.23353904515484103 1.30463669825309792 0.23536790944712538 1.30550821214031298 0.23723013129137352 1.30622515706156905 0.23909802022459714 1.30677963590280544 0.24158931746901185 1.30731428646199599 0.24348144169383945 1.30748511863814065 0.24475247407226391 1.30748468412943986 0.00000000000000000 4 0.00334434293035562 1 0.00533825930397336 1 0.00734412586267121 1 0.00936623440575543 1 0.01141256205459959 1 0.01341573096600146 1 0.01524709020284723 1 0.01677336277701813 1 0.01804490068923616 1 0.01894326352103789 1 0.02037993823386658 1 0.02480566898074880 1 0.02939205655814846 1 0.03404043378943207 1 0.03869805978018042 1 0.04334980332413108 1 0.04799487443159717 1 0.05263737365801836 1 0.05728913631958347 1 0.06195364423015201 1 0.06660152728460191 1 0.07122956329812886 1 0.07584610283920201 1 0.08045084571229059 1 0.08504550471877484 1 0.08963256787874113 1 0.09421407873103112 1 0.09879117107574811 1 0.10336422781387057 1 0.10793330889559200 1 0.11249839490034602 1 0.11705945929549585 1 0.12161613091223618 1 0.12616821278487000 1 0.13071541215010135 1 0.13525724181627602 1 0.13979405378099050 1 0.14432538686178745 1 0.14885137954117900 1 0.15337193703905613 1 0.15788673904588241 1 0.16239626042792893 1 0.16690070771036525 1 0.17140021344792761 1 0.17589510396468730 1 0.18038552504431565 1 0.18487151865902063 1 0.18935308684053462 1 0.19383026236900400 1 0.19830276789454376 1 0.20277103974370816 1 0.20723457084840083 1 0.21169339151646616 1 0.21614758290681596 1 0.22059709488399620 1 0.22504193032631326 1 0.22948214264998190 1 0.23391784916535033 1 0.23834913245589026 1 0.24277612072013041 1 0.24719890919114179 1 0.25161757662768108 1 0.25603221057958453 1 0.26044282613505232 1 0.26484890217770901 1 0.26925063819864326 1 0.27364813118187725 1 0.27804209715833189 1 0.28243253716855193 1 0.28681951085634216 1 0.29120020890283443 1 0.29557446914500052 1 0.29994411461100146 1 0.30431579875993647 1 0.30870332268475420 1 0.31310853612917888 1 0.31523624508228770 1 0.31737014111002310 1 0.31952856178681960 1 0.32171830465981011 1 0.32394102970905830 1 0.32619217521253946 1 0.32846706602101300 1 0.33077763413829298 1 0.33310205916533187 1 0.33544576479270716 1 0.33779655322040053 1 0.34015052354015518 1 0.34250407705161767 1 0.34485099381932000 1 0.34718783135835085 1 0.34952735554083242 1 0.35187486439618521 1 0.35422711580943594 1 0.35657637606518838 1 0.35891858548088795 1 0.36124990679045155 1 0.36356703547085450 1 0.36589411785453302 1 0.36820554269186456 1 0.37050138589761700 1 0.37278277874756854 1 0.37505181955993466 1 0.37731379776658153 1 0.37958010527703534 1 0.38187591368213569 1 0.38405827564667433 1 0.38618898795548318 1 0.38827607822097537 1 0.39032555279796965 1 0.39234499730597777 1 0.39434796008648582 1 0.39630575790533801 1 0.39818438284552959 1 0.40198436891082029 4";
	std::istringstream iss1(str1);
	std::istringstream iss2(str2);
	iss1 >> *bs1;
	iss2 >> *bs2;
	GeomAPIIntCurveCurve2 icc(bs1, bs2, 1e-12);
	CHECK(icc.NPoints() == 2);
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static bool IsPlanarCurve(const std::shared_ptr<Geom3Curve>& c, Plane& plane, double tol = 1.0e-7)	 @return True if the curve is a planar curve
	 @param tol The tolerance
	 @param plane The plane found when the curve is planar curve
	 @param c The input curve
	 @details If the input curve, such as a line, is on more than one plane, it will return the plane in which any one is located
	 @brief Check if a 3D curve is a planar curve, and if it is planar, find the plane
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <geometry/GeometryTool.hpp>
#include <geometry/Geom2BezierCurve.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/MakeArcOfCircle2d.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <modeling/MakeEdge.hpp>
#include<modeling/MakeEdge2d.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
#include <geometry/Geom3Circle.hpp>
using namespace AMCAX;
std::shared_ptr<Geom2BezierCurve> MakeBezierCurve2d()
{
	std::vector<Point2> poles(4);
	poles[0].SetCoord(1.0, 0.0);
	poles[1].SetCoord(2.0, 1.0);
	poles[2].SetCoord(3.0, -1.0);
	poles[3].SetCoord(4.0, 0.0);
	return std::make_shared<Geom2BezierCurve>(poles);
}
std::shared_ptr<Geom2BSplineCurve> MakeBSplineCurve2d()
{
	std::vector<Point2> poles(7);
	poles[0].SetCoord(0.5, 0.5);
	poles[1].SetCoord(1.0, 3.0);
	poles[2].SetCoord(3.0, 1.0);
	poles[3].SetCoord(3.8, 2.0);
	poles[4].SetCoord(2.5, 3.5);
	poles[5].SetCoord(1.0, 0.5);
	poles[6].SetCoord(0.3, 2.0);
	std::vector<double> knots = { 0.0, 0.25, 0.5, 0.75, 1.0 };
	std::vector<int> mults = { 4, 1, 1, 1, 4 };
	return std::make_shared<Geom2BSplineCurve>(poles, knots, mults, 3);
}
std::shared_ptr<Geom3BSplineCurve> MakeBSplineCurve3d(int degree, bool rational)
{
	if (degree == 3)
	{
		std::vector<Point3> poles(7);
		poles[0].SetCoord(0.5, 0.5, 0.3);
		poles[1].SetCoord(1.0, 3.0, 0.4);
		poles[2].SetCoord(3.0, 1.0, 0.1);
		poles[3].SetCoord(3.8, 2.0, 0.6);
		poles[4].SetCoord(2.5, 3.5, 0.8);
		poles[5].SetCoord(1.0, 0.5, 0.9);
		poles[6].SetCoord(0.3, 2.0, 0.5);
		std::vector<double> weights = { 1.0, 2.0, 3.0, 4.0, 3.0, 2.0, 1.0 };
		std::vector<double> knots = { 0.0, 0.25, 0.5, 1.0 };
		std::vector<int> mults = { 4, 1, 2, 4 };
		return rational ? std::make_shared<Geom3BSplineCurve>(poles, weights, knots, mults, 3)
			: std::make_shared<Geom3BSplineCurve>(poles, knots, mults, 3);
	}
	else if (degree == 2)
	{
		std::vector<Point3> poles(6);
		poles[0].SetCoord(0.5, 0.5, 0.3);
		poles[1].SetCoord(1.0, 3.0, 0.4);
		poles[2].SetCoord(3.0, 1.0, 0.1);
		poles[3].SetCoord(3.8, 2.0, 0.6);
		poles[4].SetCoord(2.5, 3.5, 0.8);
		poles[5].SetCoord(1.0, 0.5, 0.9);
		std::vector<double> weights = { 1.0, 2.0, 3.0, 4.0, 3.0, 2.0 };
		std::vector<double> knots = { 0.0, 0.25, 0.5, 1.0 };
		std::vector<int> mults = { 3, 1, 2, 3 };
		return rational ? std::make_shared<Geom3BSplineCurve>(poles, weights, knots, mults, 2)
			: std::make_shared<Geom3BSplineCurve>(poles, knots, mults, 2);
	}
	return nullptr;
}
TEST_CASE("case2: IsPlanarCurve dev case ", "[geometry][IsPlanarCurve][P1]")
{
	shared_ptr<Geom3BSplineCurve> curve3 = MakeBSplineCurve3d(3,true) ;
	Plane plane;
	CHECK(GeometryTool::IsPlanarCurve(curve3, plane) == false);
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API MakeArcOfCircle2d(const Point2& p1, const Point2& p2, const Point2& p3)	 @param p3 The end point
	 @param p2 The middle point
	 @param p1 The start point
	 @brief Construct an arc of circle from three points p1, p2, p3
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/VectorT.hpp>
#include <common/PointT.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/MakeArcOfCircle2d.hpp>
#include <sstream>
using namespace AMCAX;
TEST_CASE("bug1: MakeArcOfCircle2d  add 1 cases", "[geomAlgo][MakeArcOfCircle2d][fixbug]") {
	std::stringstream output;
	std::shared_ptr<Geom2TrimmedCurve> c = MakeArcOfCircle2d(Point2(0.0, 1.0), Vector2(1.0, 0.0), Point2(1.0, 0.0));
	std::cout << *c << std::endl;
	output << *c << std::endl;
	auto case1 = output.str();
	auto expect1 = "8 4.71239 6.28319";
	auto expect2 = "2 0 -0 1 0 0 -1 1";
	CHECK(case1.find(expect1) != std::string::npos);
	CHECK(case1.find(expect2) != std::string::npos);
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API MakeArcOfCircle2d(const Point2& p1, const Vector2& v, const Point2& p2)	 @param p2 The end point
	 @param v The tangent vector at p1
	 @param p1 The start point
	 @brief Construct an arc of circle from two points p1, p2 and a tangent vector v at p1
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/VectorT.hpp>
#include <common/PointT.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/MakeArcOfCircle2d.hpp>
#include <sstream>
using namespace AMCAX;
TEST_CASE("bug1: MakeArcOfCircle2d  add 1 cases", "[geomAlgo][MakeArcOfCircle2d][fixbug]") {
	std::stringstream output;
	std::shared_ptr<Geom2TrimmedCurve> c = MakeArcOfCircle2d(Point2(0.0, 1.0), Vector2(1.0, 0.0), Point2(1.0, 0.0));
	std::cout << *c << std::endl;
	output << *c << std::endl;
	auto case1 = output.str();
	auto expect1 = "8 4.71239 6.28319";
	auto expect2 = "2 0 -0 1 0 0 -1 1";
	CHECK(case1.find(expect1) != std::string::npos);
	CHECK(case1.find(expect2) != std::string::npos);
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API explicit MakeGeom3Ellipse(const Ellipse3& e)	 @param e The ellipse
	 @brief Construct from an ellipse
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <geometry/MakeGeom3Ellipse.hpp>
#include <common/DirectionT.hpp>
#include <common/PointT.hpp>
#include <common/Precision.hpp>
#include <topology/TopoEdge.hpp>
#include <topology/TopoWire.hpp>
#include <topology/TopoFace.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeWire.hpp>
#include <modeling/MakeFace.hpp>
#include <modeling/MakePrism.hpp>
#include <topomesh/BRepMeshIncrementalMesh.hpp>
#include <topology/TopoExplorerTool.hpp>
#include <topology/TopoExplorer.hpp>
#include <topology/TopoCast.hpp>
#include <topology/TopoTool.hpp>
#include <math/TriangularMesh.hpp>
using namespace AMCAX;
TEST_CASE("bug1: MakeGeom3Ellipse ", "[geometry][MakeGeom3Ellipse][fixbug]") {
	MakeGeom3Ellipse makeEllipse(Frame3(), 3.0, 1.0);
	std::shared_ptr<Geom3Curve> curve = makeEllipse.Value();
	TopoEdge e = MakeEdge(curve);
	TopoWire w = MakeWire(e);
	TopoFace f = MakeFace(w);
	TopoShape s = MakePrism(f, Vector3(0.0, 0.0, 1.0));
	BRepMeshIncrementalMesh mesher(s, 0.005, true);
	int counttest = 0;
	for (TopoExplorer ex(s, ShapeType::Face); ex.More(); ex.Next())
	{
		const auto& face = TopoCast::Face(ex.Current());
		TopoLocation l;
		auto tri = TopoTool::Triangulation(face, l);
		CHECK(tri); 
		if (tri)
		{
			counttest = counttest + 1;
			if (counttest == 1)
			{
				CHECK(tri->NVertices() == 84);
				CHECK(tri->NTriangles() == 82);
			}
			if (counttest == 2)
			{
				CHECK(tri->NVertices() == 41);
				CHECK(tri->NTriangles() == 39);
			}
			if (counttest == 3)
			{
				CHECK(tri->NVertices() == 41);
				CHECK(tri->NTriangles() == 39);
			}
		}
	}
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API MakeGeom3Ellipse(const Frame3& frame, double majorRadius, double minorRadius)	 @param minorRadius The minor radius
	 @param majorRadius The major radius
	 @param frame The local frame
	 @brief Construct an ellipse from a local frame, a major radius and a minor radius
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <geometry/MakeGeom3Ellipse.hpp>
#include <common/DirectionT.hpp>
#include <common/PointT.hpp>
#include <common/Precision.hpp>
#include <topology/TopoEdge.hpp>
#include <topology/TopoWire.hpp>
#include <topology/TopoFace.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeWire.hpp>
#include <modeling/MakeFace.hpp>
#include <modeling/MakePrism.hpp>
#include <topomesh/BRepMeshIncrementalMesh.hpp>
#include <topology/TopoExplorerTool.hpp>
#include <topology/TopoExplorer.hpp>
#include <topology/TopoCast.hpp>
#include <topology/TopoTool.hpp>
#include <math/TriangularMesh.hpp>
using namespace AMCAX;
TEST_CASE("bug1: MakeGeom3Ellipse ", "[geometry][MakeGeom3Ellipse][fixbug]") {
	MakeGeom3Ellipse makeEllipse(Frame3(), 3.0, 1.0);
	std::shared_ptr<Geom3Curve> curve = makeEllipse.Value();
	TopoEdge e = MakeEdge(curve);
	TopoWire w = MakeWire(e);
	TopoFace f = MakeFace(w);
	TopoShape s = MakePrism(f, Vector3(0.0, 0.0, 1.0));
	BRepMeshIncrementalMesh mesher(s, 0.005, true);
	int counttest = 0;
	for (TopoExplorer ex(s, ShapeType::Face); ex.More(); ex.Next())
	{
		const auto& face = TopoCast::Face(ex.Current());
		TopoLocation l;
		auto tri = TopoTool::Triangulation(face, l);
		CHECK(tri); 
		if (tri)
		{
			counttest = counttest + 1;
			if (counttest == 1)
			{
				CHECK(tri->NVertices() == 84);
				CHECK(tri->NTriangles() == 82);
			}
			if (counttest == 2)
			{
				CHECK(tri->NVertices() == 41);
				CHECK(tri->NTriangles() == 39);
			}
			if (counttest == 3)
			{
				CHECK(tri->NVertices() == 41);
				CHECK(tri->NTriangles() == 39);
			}
		}
	}
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API MakeGeom3Ellipse(const Point3& s1, const Point3& s2, const Point3& center)	 @param center The center point
	 @param s2 The point on the minor axis
	 @param s1 The point on the major axis
	 @brief Construct an ellipse from two points on the major and minor axis, and a center point
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <geometry/MakeGeom3Ellipse.hpp>
#include <common/DirectionT.hpp>
#include <common/PointT.hpp>
#include <common/Precision.hpp>
#include <topology/TopoEdge.hpp>
#include <topology/TopoWire.hpp>
#include <topology/TopoFace.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeWire.hpp>
#include <modeling/MakeFace.hpp>
#include <modeling/MakePrism.hpp>
#include <topomesh/BRepMeshIncrementalMesh.hpp>
#include <topology/TopoExplorerTool.hpp>
#include <topology/TopoExplorer.hpp>
#include <topology/TopoCast.hpp>
#include <topology/TopoTool.hpp>
#include <math/TriangularMesh.hpp>
using namespace AMCAX;
#include<catch.hpp>
#include<testHelper.h>
#include <geometry/MakeGeom3Ellipse.hpp>
#include <common/DirectionT.hpp>
#include <common/PointT.hpp>
#include <common/Precision.hpp>
#include <topology/TopoEdge.hpp>
#include <topology/TopoWire.hpp>
#include <topology/TopoFace.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeWire.hpp>
#include <modeling/MakeFace.hpp>
#include <modeling/MakePrism.hpp>
#include <topomesh/BRepMeshIncrementalMesh.hpp>
#include <topology/TopoExplorerTool.hpp>
#include <topology/TopoExplorer.hpp>
#include <topology/TopoCast.hpp>
#include <topology/TopoTool.hpp>
#include <math/TriangularMesh.hpp>
using namespace AMCAX;
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static bool IsSolidBounded(const TopoSolid& s)	 @return True if the solid and the solid is bounded (The infinite point is outside);
	 @param s The solid
	 @brief Classify whether the solid is bounded (The infinite point is outside)
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <io/ShapeTool.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <occtio/OCCTTool.hpp>
#include <topology/TopoShape.hpp>
#include <topology/TopoSolid.hpp>
#include <modeling/MakeSolid.hpp>
#include <modeling/MakeCylinder.hpp>
#include <boolean/BoolBRepFuse.hpp>
#include <boolean/BoolBRepCut.hpp>
#include <topomesh/BRepMeshIncrementalMesh.hpp>
#include <io/OBJTool.hpp>
#include <hatch/BRepSolidClassifier.hpp>
#include <healing/ShapeFixTool.hpp>
using namespace AMCAX;
bool ImpInSolid1(const Point3& pt)
{
	Point3 pc1(849.32865292949998, -105.60711735517, 528.53715478963011);
	Coord3 cs1 = pt.Coord() - pc1.Coord();
	bool isSolidIn1 = pt.Y() < 29.654882644830003 && pt.Y() > -105.60711735517 && (cs1.X() * cs1.X() + cs1.Z() * cs1.Z()) < 5.415 * 5.415;
	Point3 pc2(849.32865292763006, 12.992882644829002, 528.53715479109997);
	Coord3 cs2 = pt.Coord() - pc2.Coord();
	bool isSolidIn2 = pt.Z() < 543.83715479110003 && pt.Z() > 528.53715479109997 && (cs2.X() * cs2.X() + cs2.Y() * cs2.Y()) < 5.415 * 5.415;
	return isSolidIn1 || isSolidIn2;
}
Point3 SampleMethodCircle1()
{
	double u = (double)rand() / RAND_MAX * 4 - 0.5;
	double r = (double)rand() / RAND_MAX * 0.00002 + 5.41499;
	double x = 849.32865292949998 + r * std::cos(u);
	double z = 528.53715478963011 + r * std::sin(u);
	double y = (double)rand() / RAND_MAX * 136 - 106;
	return Point3(x, y, z);
}
TEST_CASE("bug: BRepClassificationTools::IsSolidBounded  related :", "[hatch][BRepClassificationTools][fixbug]") {
	AMCAX::TopoShape readshape;
	bool readstatus = AMCAX::OCCTIO::OCCTTool::Read(readshape, INPUT_PATH_PREFIX"0000-beforeFixShape.brep");
	CHECK(readstatus == true);
	readshape = AMCAX::ShapeFixTool::FixShape(readshape, AMCAX::Precision::Confusion(), 1E-1);
	AMCAX::TopoSolid readsolid = AMCAX::MakeSolid(AMCAX::TopoCast::Shell(readshape));
	CHECK(AMCAX::BRepClassificationTools::IsSolidBounded(readsolid) == true);
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API explicit BRepFaceClassifier(const TopoFace& f)	 @param f The input face
	 @brief Construct from the face to be processed
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <hatch/BRepFaceClassifier.hpp>
#include <common/FrameT.hpp>
#include <math/CircleT.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeWire.hpp>
#include <modeling/MakeFace.hpp>
#include <boolean/BoolBRepFuse.hpp>
#include <common/IndexSet.hpp>
#include <topology/TopoExplorerTool.hpp>
using namespace AMCAX;
TopoFace WrenchFace()
{
	Frame3 fm1(Point3(0., 0., 0.), Direction3(0., 0., 1.0));
	Circle3 c1 = Circle3(fm1, 2.);
	TopoEdge ec1 = MakeEdge(c1);
	TopoWire wc1 = MakeWire(ec1);
	TopoFace F1 = MakeFace(wc1);
	TopoEdge edge1 = MakeEdge(Point3(-4., -1.0, 0.0), Point3(4., -1.0, 0.0));
	TopoEdge edge2 = MakeEdge(Point3(4., -1.0, 0.0), Point3(4., 1.0, 0.0));
	TopoEdge edge3 = MakeEdge(Point3(4., 1.0, 0.0), Point3(-4., 1.0, 0.0));
	TopoEdge edge4 = MakeEdge(Point3(-4., 1.0, 0.0), Point3(-4., -1.0, 0.0));
	TopoWire wireR = MakeWire(edge1, edge2, edge3, edge4);
	TopoFace F3 = MakeFace(wireR);
	BoolBRepFuse fuse(F1, F3);
	fuse.Build();
	fuse.SimplifyResult();
	TopoShape res = fuse.Shape();
	IndexSet<TopoShape> resFaces;
	TopoExplorerTool::MapShapes(res, ShapeType::Face, resFaces);
	std::cout << resFaces.size() << std::endl;
	TopoFace face = static_cast<const TopoFace&>(resFaces[0]);
	return face;
}
bool ImpInWrenchFace(const Point2& pt)
{
	bool isFaceIn1 = pt.X() * pt.X() + pt.Y() * pt.Y() < 2 * 2;
	bool isFaceIn2 = pt.X() > -4 && pt.X() < 4 && pt.Y() > -1 && pt.Y() < 1;
	return isFaceIn1 || isFaceIn2;
}
Point2 SampleMethodFace()
{
	double x = (double)rand() / RAND_MAX * 10 - 5;
	double y = (double)rand() / RAND_MAX * 5 - 2.0;
	return Point2(x, y);
}
TEST_CASE("case1: BRepFaceClassifier 3.6.0 added API. ", "[hatch][BRepFaceClassifier][P1]") {
		TopoFace face = WrenchFace();
		BRepFaceClassifier classify(face);
		int n = 10000;
		int inSize = 0, intime = 0, ontime = 0;
		for (int i = 0; i < n; ++i)
		{
			Point2 pt = SampleMethodFace();
			bool isIn = ImpInWrenchFace(pt);
			classify.Perform(pt, Precision::Confusion());
			bool isCIn = classify.State() == StateType::In;
			bool isCon = classify.State() == StateType::On;
			if (isIn)
			{
				inSize++;
				if (isCIn)
				{
					intime++;
				}
				if (isCon)
				{
					ontime++;
				}
			}
		}
		std::cout << inSize << " " << intime << " " << ontime << std::endl;
		CHECK(inSize == (intime + ontime));
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static TopoShape FixShape(const TopoShape& shape, double prec, double maxTol)	 @return Fixed Shape
	 @param maxTol The global max tolerance used when the algorithm needs to check the tolerance
	 @param prec The global precision used when the algorithm needs to check the precision
	 @param shape Input shape
	 @brief Try to repair the shape to a valid shape
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <healing/ShapeFixTool.hpp>
#include <common/Precision.hpp>
using namespace AMCAX;
TEST_CASE("bug1: ShapeFixTool ", "[healing][ShapeFixTool][fixbug]") {
	AMCAX::TopoShape readshape;
	AMCAX::OCCTIO::OCCTTool::Read(readshape, INPUT_PATH_PREFIX"FixShape-Crash.brep");
	readshape = AMCAX::ShapeFixTool::FixShape(readshape, AMCAX::Precision::Confusion(), 1E-1);
	AMCAX::OCCTIO::OCCTTool::Write(readshape, OUTPUT_PATH_PREFIX"ShapeFixTool_O_FixedShape.brep");
	GlobalProperty prop;
	BRepGlobalProperty::VolumeProperties(readshape, prop);
	CHECK(prop.Mass() == Approx(16486799.3305680156).epsilon(1e-2));
	Point3 vP = prop.CenterOfMass();
	CHECK(vP.X() == Approx(-260.8706721039).epsilon(1e-2));
	CHECK(vP.Y() == Approx(-154.6717940115).epsilon(1e-2));
	CHECK(vP.Z() == Approx(-0.1139512307).epsilon(1e-2));
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static bool Read(TopoShape& s, const std::string& file)	 @return True if the input process is succeed
	 @param file The input file
	 @param s The shape
	 @brief Read a shape from a file
,
 "output":#include <catch.hpp>
#include<testHelper.h>
#include <topology/TopoShape.hpp>
#include <occtio/OCCTTool.hpp>
static bool ComparisonFields(const std::string& file1, const std::string& file2, const std::string& fields)
{
	ifstream file1Stream(file1);
	ifstream file2Stream(file2);
	if (file1Stream.is_open() == false || file2Stream.is_open() == false)
	{
		file1Stream.close();
		file2Stream.close();
		return false;
	}
	std::string line1, line2;
	while (std::getline(file1Stream, line1))
	{
		if (line1.find(fields) != std::string::npos) break;
	}
	while (std::getline(file2Stream, line2))
	{
		if (line2.find(fields) != std::string::npos) break;
	}
	file1Stream.close();
	file2Stream.close();
	return line1 == line2;
}
TEST_CASE("CASE2:Check occio read and write abnormal param brep file function ", "[occtio][OCCTTool][p1][XXX]") {
	AMCAX::TopoShape shape;
	bool isReadSuccess = AMCAX::OCCTIO::OCCTTool::Read(shape, INPUT_PATH_PREFIX"occtio/occtio_read_I_brephaveMesh-case1.brep");
	bool isReadSuccess1 = AMCAX::OCCTIO::OCCTTool::Read(shape, INPUT_PATH_PREFIX"occtio/occtio_read_I_brephaveMesh-case1.brep");
	bool isWriteSuccessf = AMCAX::OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f0-f-case2.brep", false, 0);
	bool isWriteSuccess4f = AMCAX::OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh2-f4-f-case2.brep", false, -999);
	bool isWriteSuccesst = AMCAX::OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f0-t-case2.brep", true, 0);
	bool isWriteSuccess4t = AMCAX::OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f4-t-case2.brep", true, 9999.99);
	CHECK(isReadSuccess == true);
	CHECK(isWriteSuccessf == false);
	CHECK(isWriteSuccess4f == false);
	CHECK(isWriteSuccesst == false);
	CHECK(isWriteSuccess4t == false);
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static bool Write(const TopoShape& s, std::ostream& os, int format = 3)	 @return True if the output process is succeed
	 @param[in] format The format version
	 @param[in,out] os The output stream
	 @param[in] s The shape
	 @brief Write a shape to a stream
,
 "output":#include <catch.hpp>
#include<testHelper.h>
#include <topology/TopoShape.hpp>
#include <occtio/OCCTTool.hpp>
static bool ComparisonFields(const std::string& file1, const std::string& file2, const std::string& fields)
{
	ifstream file1Stream(file1);
	ifstream file2Stream(file2);
	if (file1Stream.is_open() == false || file2Stream.is_open() == false)
	{
		file1Stream.close();
		file2Stream.close();
		return false;
	}
	std::string line1, line2;
	while (std::getline(file1Stream, line1))
	{
		if (line1.find(fields) != std::string::npos) break;
	}
	while (std::getline(file2Stream, line2))
	{
		if (line2.find(fields) != std::string::npos) break;
	}
	file1Stream.close();
	file2Stream.close();
	return line1 == line2;
}
TEST_CASE("CASE1:Check occtio read and write normal brep file function with different param ", "[occtio][OCCTTool][p1][XXX]") {
	AMCAX::TopoShape shape;
	bool isReadSuccess = AMCAX::OCCTIO::OCCTTool::Read(shape, INPUT_PATH_PREFIX"occtio/occtio_read_I_brephaveMesh-case1.brep");
	bool isWriteSuccess1f = AMCAX::OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f1-f-case1.brep", false, 1);
	bool isWriteSuccess2f = AMCAX::OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f2-f-case1.brep", false, 2);
	bool isWriteSuccess3f = AMCAX::OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f3-f-case1.brep", false, 3);
	bool isWriteSuccess1t = AMCAX::OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f1-t-case1.brep", true, 1);
	bool isWriteSuccess2t = AMCAX::OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f2-t-case1.brep", true, 2);
	bool isWriteSuccess3t = AMCAX::OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f3-t-case1.brep", true, 3);
	CHECK(isReadSuccess == true);
	CHECK(isWriteSuccess1f == true);
	CHECK(isWriteSuccess2f == true);
	CHECK(isWriteSuccess3f == true);
	CHECK(containsStringInFile(OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f1-f-case1.brep", "Triangulations 0") == true);
	CHECK(containsStringInFile(OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f1-f-case1.brep", "CASCADE Topology V1, (c) Matra-Datavision") == true);
	CHECK(containsStringInFile(OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f2-f-case1.brep", "Triangulations 0") == true);
	CHECK(containsStringInFile(OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f2-f-case1.brep", "CASCADE Topology V2, (c) Matra-Datavision") == true);
	CHECK(containsStringInFile(OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f3-f-case1.brep", "Triangulations 0") == true);
	CHECK(containsStringInFile(OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f3-f-case1.brep", "CASCADE Topology V3, (c) Open Cascade") == true);
	CHECK(isWriteSuccess1t == true);
	CHECK(isWriteSuccess2t == true);
	CHECK(isWriteSuccess3t == true);
	CHECK(containsStringInFile(OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f1-t-case1.brep", "Triangulations 0") == false);
	CHECK(containsStringInFile(OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f1-t-case1.brep", "CASCADE Topology V1, (c) Matra-Datavision") == true);
	CHECK(containsStringInFile(OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f2-t-case1.brep", "Triangulations 0") == false);
	CHECK(containsStringInFile(OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f2-t-case1.brep", "CASCADE Topology V2, (c) Matra-Datavision") == true);
	CHECK(containsStringInFile(OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f3-t-case1.brep", "Triangulations 0") == false);
	CHECK(containsStringInFile(OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f3-t-case1.brep", "CASCADE Topology V3, (c) Open Cascade") == true);
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static bool Write(const TopoShape& s, std::ostream& os, bool withTriangles, int format = 3)	 @return True if the output process is succeed
	 @param[in] format The format version
	 @param[in] withTriangles Determine whether writing the triangular mesh of the shape
	 @param[in,out] os The output stream
	 @param[in] s The shape
	 @brief Wrtie a shape to a stream
,
 "output":#include <catch.hpp>
#include<testHelper.h>
#include <topology/TopoShape.hpp>
#include <occtio/OCCTTool.hpp>
static bool ComparisonFields(const std::string& file1, const std::string& file2, const std::string& fields)
{
	ifstream file1Stream(file1);
	ifstream file2Stream(file2);
	if (file1Stream.is_open() == false || file2Stream.is_open() == false)
	{
		file1Stream.close();
		file2Stream.close();
		return false;
	}
	std::string line1, line2;
	while (std::getline(file1Stream, line1))
	{
		if (line1.find(fields) != std::string::npos) break;
	}
	while (std::getline(file2Stream, line2))
	{
		if (line2.find(fields) != std::string::npos) break;
	}
	file1Stream.close();
	file2Stream.close();
	return line1 == line2;
}
TEST_CASE("CASE1:Check occtio read and write normal brep file function with different param ", "[occtio][OCCTTool][p1][XXX]") {
	AMCAX::TopoShape shape;
	bool isReadSuccess = AMCAX::OCCTIO::OCCTTool::Read(shape, INPUT_PATH_PREFIX"occtio/occtio_read_I_brephaveMesh-case1.brep");
	bool isWriteSuccess1f = AMCAX::OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f1-f-case1.brep", false, 1);
	bool isWriteSuccess2f = AMCAX::OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f2-f-case1.brep", false, 2);
	bool isWriteSuccess3f = AMCAX::OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f3-f-case1.brep", false, 3);
	bool isWriteSuccess1t = AMCAX::OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f1-t-case1.brep", true, 1);
	bool isWriteSuccess2t = AMCAX::OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f2-t-case1.brep", true, 2);
	bool isWriteSuccess3t = AMCAX::OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f3-t-case1.brep", true, 3);
	CHECK(isReadSuccess == true);
	CHECK(isWriteSuccess1f == true);
	CHECK(isWriteSuccess2f == true);
	CHECK(isWriteSuccess3f == true);
	CHECK(containsStringInFile(OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f1-f-case1.brep", "Triangulations 0") == true);
	CHECK(containsStringInFile(OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f1-f-case1.brep", "CASCADE Topology V1, (c) Matra-Datavision") == true);
	CHECK(containsStringInFile(OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f2-f-case1.brep", "Triangulations 0") == true);
	CHECK(containsStringInFile(OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f2-f-case1.brep", "CASCADE Topology V2, (c) Matra-Datavision") == true);
	CHECK(containsStringInFile(OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f3-f-case1.brep", "Triangulations 0") == true);
	CHECK(containsStringInFile(OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f3-f-case1.brep", "CASCADE Topology V3, (c) Open Cascade") == true);
	CHECK(isWriteSuccess1t == true);
	CHECK(isWriteSuccess2t == true);
	CHECK(isWriteSuccess3t == true);
	CHECK(containsStringInFile(OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f1-t-case1.brep", "Triangulations 0") == false);
	CHECK(containsStringInFile(OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f1-t-case1.brep", "CASCADE Topology V1, (c) Matra-Datavision") == true);
	CHECK(containsStringInFile(OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f2-t-case1.brep", "Triangulations 0") == false);
	CHECK(containsStringInFile(OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f2-t-case1.brep", "CASCADE Topology V2, (c) Matra-Datavision") == true);
	CHECK(containsStringInFile(OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f3-t-case1.brep", "Triangulations 0") == false);
	CHECK(containsStringInFile(OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f3-t-case1.brep", "CASCADE Topology V3, (c) Open Cascade") == true);
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static bool Write(const TopoShape& s, const std::string& file, int format = 3)	 @return True if the output process is succeed
	 @param format The format version
	 @param file The output file
	 @param s The shape
	 @brief Write a shape to a file
,
 "output":#include <catch.hpp>
#include<testHelper.h>
#include <topology/TopoShape.hpp>
#include <occtio/OCCTTool.hpp>
static bool ComparisonFields(const std::string& file1, const std::string& file2, const std::string& fields)
{
	ifstream file1Stream(file1);
	ifstream file2Stream(file2);
	if (file1Stream.is_open() == false || file2Stream.is_open() == false)
	{
		file1Stream.close();
		file2Stream.close();
		return false;
	}
	std::string line1, line2;
	while (std::getline(file1Stream, line1))
	{
		if (line1.find(fields) != std::string::npos) break;
	}
	while (std::getline(file2Stream, line2))
	{
		if (line2.find(fields) != std::string::npos) break;
	}
	file1Stream.close();
	file2Stream.close();
	return line1 == line2;
}
TEST_CASE("CASE1:Check occtio read and write normal brep file function with different param ", "[occtio][OCCTTool][p1][XXX]") {
	AMCAX::TopoShape shape;
	bool isReadSuccess = AMCAX::OCCTIO::OCCTTool::Read(shape, INPUT_PATH_PREFIX"occtio/occtio_read_I_brephaveMesh-case1.brep");
	bool isWriteSuccess1f = AMCAX::OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f1-f-case1.brep", false, 1);
	bool isWriteSuccess2f = AMCAX::OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f2-f-case1.brep", false, 2);
	bool isWriteSuccess3f = AMCAX::OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f3-f-case1.brep", false, 3);
	bool isWriteSuccess1t = AMCAX::OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f1-t-case1.brep", true, 1);
	bool isWriteSuccess2t = AMCAX::OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f2-t-case1.brep", true, 2);
	bool isWriteSuccess3t = AMCAX::OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f3-t-case1.brep", true, 3);
	CHECK(isReadSuccess == true);
	CHECK(isWriteSuccess1f == true);
	CHECK(isWriteSuccess2f == true);
	CHECK(isWriteSuccess3f == true);
	CHECK(containsStringInFile(OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f1-f-case1.brep", "Triangulations 0") == true);
	CHECK(containsStringInFile(OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f1-f-case1.brep", "CASCADE Topology V1, (c) Matra-Datavision") == true);
	CHECK(containsStringInFile(OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f2-f-case1.brep", "Triangulations 0") == true);
	CHECK(containsStringInFile(OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f2-f-case1.brep", "CASCADE Topology V2, (c) Matra-Datavision") == true);
	CHECK(containsStringInFile(OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f3-f-case1.brep", "Triangulations 0") == true);
	CHECK(containsStringInFile(OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f3-f-case1.brep", "CASCADE Topology V3, (c) Open Cascade") == true);
	CHECK(isWriteSuccess1t == true);
	CHECK(isWriteSuccess2t == true);
	CHECK(isWriteSuccess3t == true);
	CHECK(containsStringInFile(OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f1-t-case1.brep", "Triangulations 0") == false);
	CHECK(containsStringInFile(OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f1-t-case1.brep", "CASCADE Topology V1, (c) Matra-Datavision") == true);
	CHECK(containsStringInFile(OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f2-t-case1.brep", "Triangulations 0") == false);
	CHECK(containsStringInFile(OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f2-t-case1.brep", "CASCADE Topology V2, (c) Matra-Datavision") == true);
	CHECK(containsStringInFile(OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f3-t-case1.brep", "Triangulations 0") == false);
	CHECK(containsStringInFile(OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f3-t-case1.brep", "CASCADE Topology V3, (c) Open Cascade") == true);
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static bool Write(const TopoShape& s, const std::string& file, bool withTriangles, int format = 3)	 @return True if the output process is succeed
	 @param format The format version
	 @param withTriangles Determine whether writing the triangular mesh of the shape
	 @param file The output file
	 @param s The shape
	 @brief Write a shape to a file
,
 "output":#include <catch.hpp>
#include<testHelper.h>
#include <topology/TopoShape.hpp>
#include <occtio/OCCTTool.hpp>
static bool ComparisonFields(const std::string& file1, const std::string& file2, const std::string& fields)
{
	ifstream file1Stream(file1);
	ifstream file2Stream(file2);
	if (file1Stream.is_open() == false || file2Stream.is_open() == false)
	{
		file1Stream.close();
		file2Stream.close();
		return false;
	}
	std::string line1, line2;
	while (std::getline(file1Stream, line1))
	{
		if (line1.find(fields) != std::string::npos) break;
	}
	while (std::getline(file2Stream, line2))
	{
		if (line2.find(fields) != std::string::npos) break;
	}
	file1Stream.close();
	file2Stream.close();
	return line1 == line2;
}
TEST_CASE("CASE1:Check occtio read and write normal brep file function with different param ", "[occtio][OCCTTool][p1][XXX]") {
	AMCAX::TopoShape shape;
	bool isReadSuccess = AMCAX::OCCTIO::OCCTTool::Read(shape, INPUT_PATH_PREFIX"occtio/occtio_read_I_brephaveMesh-case1.brep");
	bool isWriteSuccess1f = AMCAX::OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f1-f-case1.brep", false, 1);
	bool isWriteSuccess2f = AMCAX::OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f2-f-case1.brep", false, 2);
	bool isWriteSuccess3f = AMCAX::OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f3-f-case1.brep", false, 3);
	bool isWriteSuccess1t = AMCAX::OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f1-t-case1.brep", true, 1);
	bool isWriteSuccess2t = AMCAX::OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f2-t-case1.brep", true, 2);
	bool isWriteSuccess3t = AMCAX::OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f3-t-case1.brep", true, 3);
	CHECK(isReadSuccess == true);
	CHECK(isWriteSuccess1f == true);
	CHECK(isWriteSuccess2f == true);
	CHECK(isWriteSuccess3f == true);
	CHECK(containsStringInFile(OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f1-f-case1.brep", "Triangulations 0") == true);
	CHECK(containsStringInFile(OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f1-f-case1.brep", "CASCADE Topology V1, (c) Matra-Datavision") == true);
	CHECK(containsStringInFile(OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f2-f-case1.brep", "Triangulations 0") == true);
	CHECK(containsStringInFile(OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f2-f-case1.brep", "CASCADE Topology V2, (c) Matra-Datavision") == true);
	CHECK(containsStringInFile(OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f3-f-case1.brep", "Triangulations 0") == true);
	CHECK(containsStringInFile(OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f3-f-case1.brep", "CASCADE Topology V3, (c) Open Cascade") == true);
	CHECK(isWriteSuccess1t == true);
	CHECK(isWriteSuccess2t == true);
	CHECK(isWriteSuccess3t == true);
	CHECK(containsStringInFile(OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f1-t-case1.brep", "Triangulations 0") == false);
	CHECK(containsStringInFile(OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f1-t-case1.brep", "CASCADE Topology V1, (c) Matra-Datavision") == true);
	CHECK(containsStringInFile(OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f2-t-case1.brep", "Triangulations 0") == false);
	CHECK(containsStringInFile(OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f2-t-case1.brep", "CASCADE Topology V2, (c) Matra-Datavision") == true);
	CHECK(containsStringInFile(OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f3-t-case1.brep", "Triangulations 0") == false);
	CHECK(containsStringInFile(OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f3-t-case1.brep", "CASCADE Topology V3, (c) Open Cascade") == true);
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static bool Read(TopoShape& s, std::istream& is)	 @return True if the input process is succeed
	 @param[in,out] is The input stream
	 @param[out] s The shape
	 @brief Read a shape from a stream
,
 "output":#include <catch.hpp>
#include<testHelper.h>
#include <topology/TopoShape.hpp>
#include <occtio/OCCTTool.hpp>
static bool ComparisonFields(const std::string& file1, const std::string& file2, const std::string& fields)
{
	ifstream file1Stream(file1);
	ifstream file2Stream(file2);
	if (file1Stream.is_open() == false || file2Stream.is_open() == false)
	{
		file1Stream.close();
		file2Stream.close();
		return false;
	}
	std::string line1, line2;
	while (std::getline(file1Stream, line1))
	{
		if (line1.find(fields) != std::string::npos) break;
	}
	while (std::getline(file2Stream, line2))
	{
		if (line2.find(fields) != std::string::npos) break;
	}
	file1Stream.close();
	file2Stream.close();
	return line1 == line2;
}
TEST_CASE("CASE1:Check occtio read and write normal brep file function with different param ", "[occtio][OCCTTool][p1][XXX]") {
	AMCAX::TopoShape shape;
	bool isReadSuccess = AMCAX::OCCTIO::OCCTTool::Read(shape, INPUT_PATH_PREFIX"occtio/occtio_read_I_brephaveMesh-case1.brep");
	bool isWriteSuccess1f = AMCAX::OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f1-f-case1.brep", false, 1);
	bool isWriteSuccess2f = AMCAX::OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f2-f-case1.brep", false, 2);
	bool isWriteSuccess3f = AMCAX::OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f3-f-case1.brep", false, 3);
	bool isWriteSuccess1t = AMCAX::OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f1-t-case1.brep", true, 1);
	bool isWriteSuccess2t = AMCAX::OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f2-t-case1.brep", true, 2);
	bool isWriteSuccess3t = AMCAX::OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f3-t-case1.brep", true, 3);
	CHECK(isReadSuccess == true);
	CHECK(isWriteSuccess1f == true);
	CHECK(isWriteSuccess2f == true);
	CHECK(isWriteSuccess3f == true);
	CHECK(containsStringInFile(OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f1-f-case1.brep", "Triangulations 0") == true);
	CHECK(containsStringInFile(OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f1-f-case1.brep", "CASCADE Topology V1, (c) Matra-Datavision") == true);
	CHECK(containsStringInFile(OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f2-f-case1.brep", "Triangulations 0") == true);
	CHECK(containsStringInFile(OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f2-f-case1.brep", "CASCADE Topology V2, (c) Matra-Datavision") == true);
	CHECK(containsStringInFile(OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f3-f-case1.brep", "Triangulations 0") == true);
	CHECK(containsStringInFile(OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f3-f-case1.brep", "CASCADE Topology V3, (c) Open Cascade") == true);
	CHECK(isWriteSuccess1t == true);
	CHECK(isWriteSuccess2t == true);
	CHECK(isWriteSuccess3t == true);
	CHECK(containsStringInFile(OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f1-t-case1.brep", "Triangulations 0") == false);
	CHECK(containsStringInFile(OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f1-t-case1.brep", "CASCADE Topology V1, (c) Matra-Datavision") == true);
	CHECK(containsStringInFile(OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f2-t-case1.brep", "Triangulations 0") == false);
	CHECK(containsStringInFile(OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f2-t-case1.brep", "CASCADE Topology V2, (c) Matra-Datavision") == true);
	CHECK(containsStringInFile(OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f3-t-case1.brep", "Triangulations 0") == false);
	CHECK(containsStringInFile(OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f3-t-case1.brep", "CASCADE Topology V3, (c) Open Cascade") == true);
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":void SetRadius(double r)	 @param r The radius
	 @brief Set the radius of the circle
,
 "output":#include<catch.hpp>
#include "testHelper.h"
#include<iostream>
#include <math/CircleT.hpp>
#include <common/AxisT.hpp>
#include <common/PointT.hpp>
TEST_CASE("CircleT Area and Length Test", "[CircleT]") {
    AMCAX::Circle2 circle2;
    circle2.SetRadius(5.0);
    CHECK(circle2.Area() == Approx(78.53982));
    CHECK(circle2.Length() == Approx(31.41593));
    AMCAX::Circle3 circle3;
    circle3.SetRadius(10.0);
    CHECK(circle3.Area() == Approx(314.15927));
    CHECK(circle3.Length() == Approx(62.83185));
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] double Length()	 @return The length of the circle
	 @brief Get the length of the circle
,
 "output":#include<catch.hpp>
#include "testHelper.h"
#include<iostream>
#include <math/CircleT.hpp>
#include <common/AxisT.hpp>
#include <common/PointT.hpp>
TEST_CASE("case1: create a Cirecle", "[math][CircleT][P1]") {
	AMCAX::Point2 P(0.0,0.0);
	AMCAX::Direction2 D(1.0,0.0);
	AMCAX::Axis2  axis2(P, D);
	float radius = 5.0f;
	AMCAX::Circle2 circle2(axis2, radius, true);
	CHECK(circle2.Area() == radius * radius * M_PI); 
    double a, b, c, d, e, f;
    circle2.Coefficients(a, b, c, d, e, f);  
    double x = 0, y = 5;
    CHECK(a * x * x + b * y * y + c * x * y + d * x + e * y + f == Approx(0.0).epsilon(1e-15));
    double x1 = 5 * sqrt(2) / 2;
    double y1 = 5 * sqrt(2) / 2;
    double x2 = 6;
    double y2 = 0;
    double x3 = 5.5;
    double y3 = 6.1;
    AMCAX::Point2 P1(x1,y1);
    AMCAX::Point2 P2(x2, y2);
    AMCAX::Point2 P3(x3, y3);
    double tolerance1 = 0.1;
    double tolerance2 = 1.0;
    CHECK(circle2.Contains(P1, tolerance1) == true);
    CHECK(circle2.Contains(P2, tolerance2) == true);
    CHECK(circle2.Contains(P3, tolerance2) == false);
    CHECK(circle2.Distance(P1) == Approx(0.0).epsilon(1e-15));
    CHECK(circle2.Distance(P2) == Approx(1.0).epsilon(1e-15));
    CHECK(circle2.Length() == Approx(2*M_PI*radius).epsilon(1e-15));
    AMCAX::Point2 locationP = circle2.Location();
    CHECK(locationP.X() == Approx(0.0).epsilon(1e-15));
    CHECK(locationP.Y() == Approx(0.0).epsilon(1e-15));
    AMCAX::Point2 mirrorAxisPoint(1.0, 0.0);
    AMCAX::Direction2 mirrorAxisDirection(0.0, 1.0);
    AMCAX::Axis2 mirrorAxis(mirrorAxisPoint, mirrorAxisDirection);
    circle2.Mirror(mirrorAxis);
    CHECK(circle2.Length() == Approx(2 * M_PI * radius).epsilon(1e-15));
    AMCAX::Point2 locationPmirror = circle2.Location();
    CHECK(locationPmirror.X() == Approx(2.0).epsilon(1e-15));
    CHECK(locationPmirror.Y() == Approx(0.0).epsilon(1e-15));
    AMCAX::Point2 P4(7.0, 0.0);  
    CHECK(circle2.Contains(P4, tolerance2) == true);
    AMCAX::Point2 mirroredAxisPoint(1.0, 0.0);
    AMCAX::Direction2 mirroredAxisDirection(0.0, 1.0);
    AMCAX::Axis2 mirroedrAxis(mirroredAxisPoint, mirroredAxisDirection);
    AMCAX::Circle2 circle2mirrored = circle2.Mirrored(mirroedrAxis);
    CHECK(circle2mirrored.Length() == Approx(2 * M_PI * radius).epsilon(1e-15));
    AMCAX::Point2 locationPmirrored = circle2mirrored.Location();
    CHECK(locationPmirrored.X() == Approx(0.0).epsilon(1e-15));
    CHECK(locationPmirrored.Y() == Approx(0.0).epsilon(1e-15));
    AMCAX::Frame2 frame2mirrored = circle2mirrored.Position(); 
    CHECK(frame2mirrored.Location().X() == Approx(0.0).epsilon(1e-15));
    CHECK(frame2mirrored.Location().Y() == Approx(0.0).epsilon(1e-15));
    const double& radiusmirrored = circle2mirrored.Radius(); 
    CHECK(radiusmirrored == Approx(radius).epsilon(1e-15));
    circle2mirrored.Scale(P,0.5); 
    AMCAX::Point2 scaleP1(0.0,-2.5);
    CHECK(circle2mirrored.Contains(scaleP1, 0) == true);
    AMCAX::Circle2 circle2Scaled = circle2mirrored.Scale(P, 2); 
    AMCAX::Point2 scaledP1(0.0, 5.0);
    CHECK(circle2Scaled.Contains(scaledP1, 0) == true);
    AMCAX::Point2 rotateP(0.0,0.0);
    double angle = 90.0 * (2 * M_PI / 360.0);
    circle2.Rotate(rotateP, angle); 
    AMCAX::Point2 P5(0.0, -3.0);
    CHECK(circle2.Contains(P5, 0) == true);
    double angle2 = -180.0 * (2 * M_PI / 360.0);
    AMCAX::Circle2 rotatedCircle2 = circle2.Rotated(rotateP, angle2); 
    AMCAX::Point2 P6(0.0, 3.0);
    CHECK(rotatedCircle2.Contains(P6, 0) == true); 
    AMCAX::Point2 newP(0.0, 0.0);
    rotatedCircle2.SetLocation(newP);
    CHECK(rotatedCircle2.Contains(P1, 0) == true);
    std::cout << circle2.Length() << std::endl;
};
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":void SetRadius(double r)	 @param r The radius
	 @brief Set the radius of the circle
,
 "output":#include <math/CircleT.hpp>
#include <common/CoordT.hpp>
#include <common/TransformationType.hpp>
#include <common/DirectionT.hpp>
#include <common/PointT.hpp>
#include <common/Precision.hpp>
#include <common/CoordT.hpp>
#include <common/TransformationType.hpp>
#include <topology/TopoEdge.hpp>
#include <modeling/MakeEdge.hpp>
#include <topology/TopoWire.hpp>
#include <modeling/MakeWire.hpp>
#include <geometry/GlobalProperty.hpp>
#include <topology/BRepGlobalProperty.hpp>
#include<iostream>
#include "catch.hpp" 
using namespace std;
using namespace AMCAX;
TEST_CASE("TestCircle2D", "[math][Circle2D]")
{
	AMCAX::CircleT<double, 2> circle2D;
	AMCAX::Point2 center2D(0.0, 0.0);
	double redius2D = 5.0;
	double tol = 0.1;
	circle2D.SetLocation(center2D);
	circle2D.SetRadius(redius2D);
	double area2D = circle2D.Area();
	double length2D = circle2D.Length();
	AMCAX::Point2 retcenter2D = circle2D.Location();
	double retarea2D = M_PI * redius2D * redius2D;
	double retlength2D = 2 * M_PI * redius2D;
	std::cout << area2D << std::endl;
	std::cout << length2D << std::endl;
	std::cout << retcenter2D.X() << std::endl;
	std::cout << retcenter2D.Y() << std::endl;
	CHECK(area2D == retarea2D);
	CHECK(length2D == retlength2D);
	CHECK(retcenter2D.X() == center2D.X());
	CHECK(retcenter2D.Y() == center2D.Y());
	double a, b, c, d, e, f;
	circle2D.Coefficients(a, b, c, d, e, f);
	std::cout << a << std::endl;
	std::cout << b << std::endl;
	std::cout << c << std::endl;
	std::cout << d << std::endl;
	std::cout << e << std::endl;
	std::cout << f << std::endl;
	CHECK(a == 1);
	CHECK(b == 1);
	CHECK(c == 0);
	CHECK(d == 0);
	CHECK(e == 0);
	CHECK(f == -25);
	std::vector < AMCAX::Point2> testPoints = {
		AMCAX::Point2(3.0, 4.0),
		AMCAX::Point2(5.0, 0.0),
		AMCAX::Point2(4.9, 0.0),
		AMCAX::Point2(5.1, 0.0),
		AMCAX::Point2(6.0, 0.0)
	};
	for (const auto& point : testPoints)
	{
		double distanceToCenter = std::sqrt(point.X() * point.X() + point.Y() * point.Y());
		bool expectedIsInCircle = distanceToCenter <= 5.0 + tol;
		bool isInCircle = circle2D.Contains(point, tol);
		CHECK(isInCircle == expectedIsInCircle);
	}
	for (const auto& point : testPoints)
	{
		double distance = circle2D.Distance(point);
		double expectedDistance = std::abs(std::sqrt(std::pow(point.X() - center2D.X(), 2) + std::pow(point.Y() - center2D.Y(), 2)) - redius2D);
		CHECK(distance == expectedDistance);
	}
	AMCAX::AxisT<double, 2> mirrorAxis(AMCAX::Point2(0.0, 0.0), AMCAX::Direction2(0.0, 1.0));
	circle2D.Mirror(mirrorAxis);
	AMCAX::Point2 mirroredCenter = circle2D.Location();
	std::cout << "Mirrored circle center: (" << mirroredCenter.X() << ", " << mirroredCenter.Y() << ")" << std::endl;
	CHECK(mirroredCenter.X() == center2D.X());
	CHECK(mirroredCenter.Y() == center2D.Y());
	const AMCAX::FrameT<double, 2>& frame = circle2D.Position();
	AMCAX::Point2 rotationPoint(0.0, 0.0);
	double  rotationAngle = M_PI / 4;
	auto rotatedCircle = circle2D.Rotated(rotationPoint, rotationAngle);
	double cosAngle = cos(rotationAngle);
	double sinAngle = sin(rotationAngle);
	double newX = cosAngle * (center2D.X() - rotationPoint.X()) - sinAngle * (center2D.Y() - rotationPoint.Y()) + rotationPoint.X();
	double newY = sinAngle * (center2D.X() - rotationPoint.X()) + cosAngle * (center2D.Y() - rotationPoint.Y()) + rotationPoint.Y();
	auto rotatedCenter = rotatedCircle.Location();
	CHECK(newX == center2D.X());
	CHECK(newY == center2D.Y());
	AMCAX::Point2 scalingCenter(0.0, 0.0);
	double scalingFactor = 2.0;
	auto scaledCircle = circle2D.Scale(scalingCenter, scalingFactor);
	double scaledRadius = scaledCircle.Radius();
	double expectedScaledRadius = redius2D * scalingFactor;
	CHECK(std::abs(scaledRadius - expectedScaledRadius) < 1e-6);
	AMCAX::VectorT<double, 2> translationVector(2.0, 3.0);
	auto translatedCircle = circle2D.Translated(translationVector);
	auto translatedCenter = translatedCircle.Location();
	double translatedX = center2D.X() + translationVector.X();
	CHECK(translatedX == translatedCenter.X());
	auto xAxis = circle2D.XAxis();
	auto directionAxis = xAxis.Direction();
	CHECK(directionAxis.X() == -1.0);
	CHECK(directionAxis.Y() == 0.0);
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] double Radius()	 @return The radius
	 @brief Get the radius
,
 "output":#include <math/CircleT.hpp>
#include <common/CoordT.hpp>
#include <common/TransformationType.hpp>
#include <common/DirectionT.hpp>
#include <common/PointT.hpp>
#include <common/Precision.hpp>
#include <common/CoordT.hpp>
#include <common/TransformationType.hpp>
#include <topology/TopoEdge.hpp>
#include <modeling/MakeEdge.hpp>
#include <topology/TopoWire.hpp>
#include <modeling/MakeWire.hpp>
#include <geometry/GlobalProperty.hpp>
#include <topology/BRepGlobalProperty.hpp>
#include<iostream>
#include "catch.hpp" 
using namespace std;
using namespace AMCAX;
TEST_CASE("TestCircle3D", "[math][Circle3D]")
{
	AMCAX::Circle3 circle3D;
	AMCAX::Point3  center3D(0.0, 0.0, 0.0);
	double radius3D = 5.0;
	double tol = 0.1;
	circle3D.SetLocation(center3D);
	circle3D.SetRadius(radius3D);
	double area = circle3D.Area();
	auto axis = circle3D.Axis();
	AMCAX::Point3 expectedDirection(0.0, 0.0, 1.0);
	auto direction = axis.Direction();
	CHECK(area == Approx(78.5398));
	CHECK(direction.X() == Approx(expectedDirection.X()).margin(tol));
	CHECK(direction.Y() == Approx(expectedDirection.Y()).margin(tol));
	CHECK(direction.Z() == Approx(expectedDirection.Z()).margin(tol));
	std::vector <AMCAX::Point3> test3DPoints = {
		AMCAX::Point3(0.0, 0.0, 0.0),
		AMCAX::Point3(4.0, 0.0, 0.0),
	};
	for (const auto& point : test3DPoints)
	{
		double distanceToCenter = std::sqrt(std::pow(point.X() - center3D.X(), 2) + std::pow(point.Y() - center3D.Y(), 2) + std::pow(point.Z() - center3D.Z(), 2));
		bool expectedIsCircle = distanceToCenter <= 5.0 + tol;
		bool isInCircle = circle3D.Contains(point, tol);
		CHECK(!isInCircle == expectedIsCircle);
	}
	AMCAX::PointT<double, 3>  pointOutside(10.0, 0.0, 0.0);
	double expectedDistance = 5.0;
	CHECK(circle3D.Distance(pointOutside) == Approx(expectedDistance));
	double length = circle3D.Length();
	CHECK(length == Approx(31.4159));
	auto location = circle3D.Location();
	CHECK(location.X() == Approx(0.0));
	CHECK(location.Y() == Approx(0.0));
	CHECK(location.Z() == Approx(0.0));
	AMCAX::PointT<double, 3> mirrorPoint(1.0, 0.0, 0.0);
	circle3D.Mirror(mirrorPoint);
	auto mirroredLocation = circle3D.Location();
	CHECK(mirroredLocation.X() == Approx(2.0));
	CHECK(mirroredLocation.Y() == Approx(0.0));
	CHECK(mirroredLocation.Z() == Approx(0.0));
	auto position = circle3D.Position();   
	double r = circle3D.Radius();
	CHECK(r == 5.0);
	Direction3 zDirection(0.0, 0.0, 1.0);
	Axis3 zAxis(center3D, zDirection);
	Transformation3 rotation;
	rotation.SetRotation(zAxis, M_PI / 2);  
	Point3 newCenter1 = center3D.Transformed(rotation);
	CHECK(newCenter1.X() == 0.0);
	CHECK(newCenter1.Y() == 0.0);
	CHECK(newCenter1.Z() == 0.0);
	double angle = M_PI / 2;
	circle3D.Rotated(zAxis, angle);
	AMCAX::Frame3 frame = circle3D.Position();
	CHECK(frame.Location().X() == 2.0);
	CHECK(frame.Location().Y() == 0.0);
	CHECK(frame.Location().Z() == 0.0);
	double scale = 2.0;
	circle3D.Scale(center3D, scale);
	CHECK(circle3D.Radius() == radius3D * 2.0);
	AMCAX::PointT<double, 3> insidePoint(3.0, 4.0, 0.0);
	AMCAX::PointT<double, 3> onCirclePoint(5.0, 0.0, 0.0);
	AMCAX::PointT<double, 3> outsidePoint(8.0, 6.0, 0.0);
	double insideSquaredDistance = circle3D.SquaredDistance(insidePoint);
	double onCircleSquaredDistance = circle3D.SquaredDistance(onCirclePoint);
	double outsideSquaredDistance = circle3D.SquaredDistance(outsidePoint);
	CHECK(insideSquaredDistance == Approx(34.5378));
	CHECK(onCircleSquaredDistance == 81.0);
	CHECK(outsideSquaredDistance == Approx(7.7779));
	VectorT<double, 3> translationVector(5.0, 5.0, 0.0);
	circle3D.Translate(translationVector);
	CHECK(circle3D.Location().X() == 9.0);
	CHECK(circle3D.Location().Y() == 5.0);
	CHECK(circle3D.Location().Z() == 0.0);
	auto xAxis = circle3D.XAxis();
	auto yAxis = circle3D.YAxis();
	CHECK(xAxis.Direction().X() == Approx(-1.0));
	CHECK(yAxis.Direction().Y() == Approx(-1.0));
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] double Length()	 @return The length of the circle
	 @brief Get the length of the circle
,
 "output":#include <math/CircleT.hpp>
#include <common/CoordT.hpp>
#include <common/TransformationType.hpp>
#include <common/DirectionT.hpp>
#include <common/PointT.hpp>
#include <common/Precision.hpp>
#include <common/CoordT.hpp>
#include <common/TransformationType.hpp>
#include <topology/TopoEdge.hpp>
#include <modeling/MakeEdge.hpp>
#include <topology/TopoWire.hpp>
#include <modeling/MakeWire.hpp>
#include <geometry/GlobalProperty.hpp>
#include <topology/BRepGlobalProperty.hpp>
#include<iostream>
#include "catch.hpp" 
using namespace std;
using namespace AMCAX;
TEST_CASE("TestCircle2D", "[math][Circle2D]")
{
	AMCAX::CircleT<double, 2> circle2D;
	AMCAX::Point2 center2D(0.0, 0.0);
	double redius2D = 5.0;
	double tol = 0.1;
	circle2D.SetLocation(center2D);
	circle2D.SetRadius(redius2D);
	double area2D = circle2D.Area();
	double length2D = circle2D.Length();
	AMCAX::Point2 retcenter2D = circle2D.Location();
	double retarea2D = M_PI * redius2D * redius2D;
	double retlength2D = 2 * M_PI * redius2D;
	std::cout << area2D << std::endl;
	std::cout << length2D << std::endl;
	std::cout << retcenter2D.X() << std::endl;
	std::cout << retcenter2D.Y() << std::endl;
	CHECK(area2D == retarea2D);
	CHECK(length2D == retlength2D);
	CHECK(retcenter2D.X() == center2D.X());
	CHECK(retcenter2D.Y() == center2D.Y());
	double a, b, c, d, e, f;
	circle2D.Coefficients(a, b, c, d, e, f);
	std::cout << a << std::endl;
	std::cout << b << std::endl;
	std::cout << c << std::endl;
	std::cout << d << std::endl;
	std::cout << e << std::endl;
	std::cout << f << std::endl;
	CHECK(a == 1);
	CHECK(b == 1);
	CHECK(c == 0);
	CHECK(d == 0);
	CHECK(e == 0);
	CHECK(f == -25);
	std::vector < AMCAX::Point2> testPoints = {
		AMCAX::Point2(3.0, 4.0),
		AMCAX::Point2(5.0, 0.0),
		AMCAX::Point2(4.9, 0.0),
		AMCAX::Point2(5.1, 0.0),
		AMCAX::Point2(6.0, 0.0)
	};
	for (const auto& point : testPoints)
	{
		double distanceToCenter = std::sqrt(point.X() * point.X() + point.Y() * point.Y());
		bool expectedIsInCircle = distanceToCenter <= 5.0 + tol;
		bool isInCircle = circle2D.Contains(point, tol);
		CHECK(isInCircle == expectedIsInCircle);
	}
	for (const auto& point : testPoints)
	{
		double distance = circle2D.Distance(point);
		double expectedDistance = std::abs(std::sqrt(std::pow(point.X() - center2D.X(), 2) + std::pow(point.Y() - center2D.Y(), 2)) - redius2D);
		CHECK(distance == expectedDistance);
	}
	AMCAX::AxisT<double, 2> mirrorAxis(AMCAX::Point2(0.0, 0.0), AMCAX::Direction2(0.0, 1.0));
	circle2D.Mirror(mirrorAxis);
	AMCAX::Point2 mirroredCenter = circle2D.Location();
	std::cout << "Mirrored circle center: (" << mirroredCenter.X() << ", " << mirroredCenter.Y() << ")" << std::endl;
	CHECK(mirroredCenter.X() == center2D.X());
	CHECK(mirroredCenter.Y() == center2D.Y());
	const AMCAX::FrameT<double, 2>& frame = circle2D.Position();
	AMCAX::Point2 rotationPoint(0.0, 0.0);
	double  rotationAngle = M_PI / 4;
	auto rotatedCircle = circle2D.Rotated(rotationPoint, rotationAngle);
	double cosAngle = cos(rotationAngle);
	double sinAngle = sin(rotationAngle);
	double newX = cosAngle * (center2D.X() - rotationPoint.X()) - sinAngle * (center2D.Y() - rotationPoint.Y()) + rotationPoint.X();
	double newY = sinAngle * (center2D.X() - rotationPoint.X()) + cosAngle * (center2D.Y() - rotationPoint.Y()) + rotationPoint.Y();
	auto rotatedCenter = rotatedCircle.Location();
	CHECK(newX == center2D.X());
	CHECK(newY == center2D.Y());
	AMCAX::Point2 scalingCenter(0.0, 0.0);
	double scalingFactor = 2.0;
	auto scaledCircle = circle2D.Scale(scalingCenter, scalingFactor);
	double scaledRadius = scaledCircle.Radius();
	double expectedScaledRadius = redius2D * scalingFactor;
	CHECK(std::abs(scaledRadius - expectedScaledRadius) < 1e-6);
	AMCAX::VectorT<double, 2> translationVector(2.0, 3.0);
	auto translatedCircle = circle2D.Translated(translationVector);
	auto translatedCenter = translatedCircle.Location();
	double translatedX = center2D.X() + translationVector.X();
	CHECK(translatedX == translatedCenter.X());
	auto xAxis = circle2D.XAxis();
	auto directionAxis = xAxis.Direction();
	CHECK(directionAxis.X() == -1.0);
	CHECK(directionAxis.Y() == 0.0);
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] double Distance(const PointT<double, DIM>& p)	 @return The distance from the point to the circle
	 @param p The point
	 @brief Compute the distance from a point to the circle
,
 "output":#include <math/CircleT.hpp>
#include <common/CoordT.hpp>
#include <common/TransformationType.hpp>
#include <common/DirectionT.hpp>
#include <common/PointT.hpp>
#include <common/Precision.hpp>
#include <common/CoordT.hpp>
#include <common/TransformationType.hpp>
#include <topology/TopoEdge.hpp>
#include <modeling/MakeEdge.hpp>
#include <topology/TopoWire.hpp>
#include <modeling/MakeWire.hpp>
#include <geometry/GlobalProperty.hpp>
#include <topology/BRepGlobalProperty.hpp>
#include<iostream>
#include "catch.hpp" 
using namespace std;
using namespace AMCAX;
TEST_CASE("TestCircle3D", "[math][Circle3D]")
{
	AMCAX::Circle3 circle3D;
	AMCAX::Point3  center3D(0.0, 0.0, 0.0);
	double radius3D = 5.0;
	double tol = 0.1;
	circle3D.SetLocation(center3D);
	circle3D.SetRadius(radius3D);
	double area = circle3D.Area();
	auto axis = circle3D.Axis();
	AMCAX::Point3 expectedDirection(0.0, 0.0, 1.0);
	auto direction = axis.Direction();
	CHECK(area == Approx(78.5398));
	CHECK(direction.X() == Approx(expectedDirection.X()).margin(tol));
	CHECK(direction.Y() == Approx(expectedDirection.Y()).margin(tol));
	CHECK(direction.Z() == Approx(expectedDirection.Z()).margin(tol));
	std::vector <AMCAX::Point3> test3DPoints = {
		AMCAX::Point3(0.0, 0.0, 0.0),
		AMCAX::Point3(4.0, 0.0, 0.0),
	};
	for (const auto& point : test3DPoints)
	{
		double distanceToCenter = std::sqrt(std::pow(point.X() - center3D.X(), 2) + std::pow(point.Y() - center3D.Y(), 2) + std::pow(point.Z() - center3D.Z(), 2));
		bool expectedIsCircle = distanceToCenter <= 5.0 + tol;
		bool isInCircle = circle3D.Contains(point, tol);
		CHECK(!isInCircle == expectedIsCircle);
	}
	AMCAX::PointT<double, 3>  pointOutside(10.0, 0.0, 0.0);
	double expectedDistance = 5.0;
	CHECK(circle3D.Distance(pointOutside) == Approx(expectedDistance));
	double length = circle3D.Length();
	CHECK(length == Approx(31.4159));
	auto location = circle3D.Location();
	CHECK(location.X() == Approx(0.0));
	CHECK(location.Y() == Approx(0.0));
	CHECK(location.Z() == Approx(0.0));
	AMCAX::PointT<double, 3> mirrorPoint(1.0, 0.0, 0.0);
	circle3D.Mirror(mirrorPoint);
	auto mirroredLocation = circle3D.Location();
	CHECK(mirroredLocation.X() == Approx(2.0));
	CHECK(mirroredLocation.Y() == Approx(0.0));
	CHECK(mirroredLocation.Z() == Approx(0.0));
	auto position = circle3D.Position();   
	double r = circle3D.Radius();
	CHECK(r == 5.0);
	Direction3 zDirection(0.0, 0.0, 1.0);
	Axis3 zAxis(center3D, zDirection);
	Transformation3 rotation;
	rotation.SetRotation(zAxis, M_PI / 2);  
	Point3 newCenter1 = center3D.Transformed(rotation);
	CHECK(newCenter1.X() == 0.0);
	CHECK(newCenter1.Y() == 0.0);
	CHECK(newCenter1.Z() == 0.0);
	double angle = M_PI / 2;
	circle3D.Rotated(zAxis, angle);
	AMCAX::Frame3 frame = circle3D.Position();
	CHECK(frame.Location().X() == 2.0);
	CHECK(frame.Location().Y() == 0.0);
	CHECK(frame.Location().Z() == 0.0);
	double scale = 2.0;
	circle3D.Scale(center3D, scale);
	CHECK(circle3D.Radius() == radius3D * 2.0);
	AMCAX::PointT<double, 3> insidePoint(3.0, 4.0, 0.0);
	AMCAX::PointT<double, 3> onCirclePoint(5.0, 0.0, 0.0);
	AMCAX::PointT<double, 3> outsidePoint(8.0, 6.0, 0.0);
	double insideSquaredDistance = circle3D.SquaredDistance(insidePoint);
	double onCircleSquaredDistance = circle3D.SquaredDistance(onCirclePoint);
	double outsideSquaredDistance = circle3D.SquaredDistance(outsidePoint);
	CHECK(insideSquaredDistance == Approx(34.5378));
	CHECK(onCircleSquaredDistance == 81.0);
	CHECK(outsideSquaredDistance == Approx(7.7779));
	VectorT<double, 3> translationVector(5.0, 5.0, 0.0);
	circle3D.Translate(translationVector);
	CHECK(circle3D.Location().X() == 9.0);
	CHECK(circle3D.Location().Y() == 5.0);
	CHECK(circle3D.Location().Z() == 0.0);
	auto xAxis = circle3D.XAxis();
	auto yAxis = circle3D.YAxis();
	CHECK(xAxis.Direction().X() == Approx(-1.0));
	CHECK(yAxis.Direction().Y() == Approx(-1.0));
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] double SquaredDistance(const PointT<double, DIM>& p)	 @return The squared distance from the point to the circle
	 @param p The point
	 @brief Compute the squared distance from a point to the circle
,
 "output":#include <math/CircleT.hpp>
#include <common/CoordT.hpp>
#include <common/TransformationType.hpp>
#include <common/DirectionT.hpp>
#include <common/PointT.hpp>
#include <common/Precision.hpp>
#include <common/CoordT.hpp>
#include <common/TransformationType.hpp>
#include <topology/TopoEdge.hpp>
#include <modeling/MakeEdge.hpp>
#include <topology/TopoWire.hpp>
#include <modeling/MakeWire.hpp>
#include <geometry/GlobalProperty.hpp>
#include <topology/BRepGlobalProperty.hpp>
#include<iostream>
#include "catch.hpp" 
using namespace std;
using namespace AMCAX;
TEST_CASE("TestCircle3D", "[math][Circle3D]")
{
	AMCAX::Circle3 circle3D;
	AMCAX::Point3  center3D(0.0, 0.0, 0.0);
	double radius3D = 5.0;
	double tol = 0.1;
	circle3D.SetLocation(center3D);
	circle3D.SetRadius(radius3D);
	double area = circle3D.Area();
	auto axis = circle3D.Axis();
	AMCAX::Point3 expectedDirection(0.0, 0.0, 1.0);
	auto direction = axis.Direction();
	CHECK(area == Approx(78.5398));
	CHECK(direction.X() == Approx(expectedDirection.X()).margin(tol));
	CHECK(direction.Y() == Approx(expectedDirection.Y()).margin(tol));
	CHECK(direction.Z() == Approx(expectedDirection.Z()).margin(tol));
	std::vector <AMCAX::Point3> test3DPoints = {
		AMCAX::Point3(0.0, 0.0, 0.0),
		AMCAX::Point3(4.0, 0.0, 0.0),
	};
	for (const auto& point : test3DPoints)
	{
		double distanceToCenter = std::sqrt(std::pow(point.X() - center3D.X(), 2) + std::pow(point.Y() - center3D.Y(), 2) + std::pow(point.Z() - center3D.Z(), 2));
		bool expectedIsCircle = distanceToCenter <= 5.0 + tol;
		bool isInCircle = circle3D.Contains(point, tol);
		CHECK(!isInCircle == expectedIsCircle);
	}
	AMCAX::PointT<double, 3>  pointOutside(10.0, 0.0, 0.0);
	double expectedDistance = 5.0;
	CHECK(circle3D.Distance(pointOutside) == Approx(expectedDistance));
	double length = circle3D.Length();
	CHECK(length == Approx(31.4159));
	auto location = circle3D.Location();
	CHECK(location.X() == Approx(0.0));
	CHECK(location.Y() == Approx(0.0));
	CHECK(location.Z() == Approx(0.0));
	AMCAX::PointT<double, 3> mirrorPoint(1.0, 0.0, 0.0);
	circle3D.Mirror(mirrorPoint);
	auto mirroredLocation = circle3D.Location();
	CHECK(mirroredLocation.X() == Approx(2.0));
	CHECK(mirroredLocation.Y() == Approx(0.0));
	CHECK(mirroredLocation.Z() == Approx(0.0));
	auto position = circle3D.Position();   
	double r = circle3D.Radius();
	CHECK(r == 5.0);
	Direction3 zDirection(0.0, 0.0, 1.0);
	Axis3 zAxis(center3D, zDirection);
	Transformation3 rotation;
	rotation.SetRotation(zAxis, M_PI / 2);  
	Point3 newCenter1 = center3D.Transformed(rotation);
	CHECK(newCenter1.X() == 0.0);
	CHECK(newCenter1.Y() == 0.0);
	CHECK(newCenter1.Z() == 0.0);
	double angle = M_PI / 2;
	circle3D.Rotated(zAxis, angle);
	AMCAX::Frame3 frame = circle3D.Position();
	CHECK(frame.Location().X() == 2.0);
	CHECK(frame.Location().Y() == 0.0);
	CHECK(frame.Location().Z() == 0.0);
	double scale = 2.0;
	circle3D.Scale(center3D, scale);
	CHECK(circle3D.Radius() == radius3D * 2.0);
	AMCAX::PointT<double, 3> insidePoint(3.0, 4.0, 0.0);
	AMCAX::PointT<double, 3> onCirclePoint(5.0, 0.0, 0.0);
	AMCAX::PointT<double, 3> outsidePoint(8.0, 6.0, 0.0);
	double insideSquaredDistance = circle3D.SquaredDistance(insidePoint);
	double onCircleSquaredDistance = circle3D.SquaredDistance(onCirclePoint);
	double outsideSquaredDistance = circle3D.SquaredDistance(outsidePoint);
	CHECK(insideSquaredDistance == Approx(34.5378));
	CHECK(onCircleSquaredDistance == 81.0);
	CHECK(outsideSquaredDistance == Approx(7.7779));
	VectorT<double, 3> translationVector(5.0, 5.0, 0.0);
	circle3D.Translate(translationVector);
	CHECK(circle3D.Location().X() == 9.0);
	CHECK(circle3D.Location().Y() == 5.0);
	CHECK(circle3D.Location().Z() == 0.0);
	auto xAxis = circle3D.XAxis();
	auto yAxis = circle3D.YAxis();
	CHECK(xAxis.Direction().X() == Approx(-1.0));
	CHECK(yAxis.Direction().Y() == Approx(-1.0));
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":CircleS& Scale(const PointT<double, DIM>& p, double scale)	 @return The reference to self
	 @param scale The scale value
	 @param p The scaling center point
	 @brief Scale the circle by a center point
,
 "output":#include <math/CircleT.hpp>
#include <common/CoordT.hpp>
#include <common/TransformationType.hpp>
#include <common/DirectionT.hpp>
#include <common/PointT.hpp>
#include <common/Precision.hpp>
#include <common/CoordT.hpp>
#include <common/TransformationType.hpp>
#include <topology/TopoEdge.hpp>
#include <modeling/MakeEdge.hpp>
#include <topology/TopoWire.hpp>
#include <modeling/MakeWire.hpp>
#include <geometry/GlobalProperty.hpp>
#include <topology/BRepGlobalProperty.hpp>
#include<iostream>
#include "catch.hpp" 
using namespace std;
using namespace AMCAX;
TEST_CASE("TestCircle2D", "[math][Circle2D]")
{
	AMCAX::CircleT<double, 2> circle2D;
	AMCAX::Point2 center2D(0.0, 0.0);
	double redius2D = 5.0;
	double tol = 0.1;
	circle2D.SetLocation(center2D);
	circle2D.SetRadius(redius2D);
	double area2D = circle2D.Area();
	double length2D = circle2D.Length();
	AMCAX::Point2 retcenter2D = circle2D.Location();
	double retarea2D = M_PI * redius2D * redius2D;
	double retlength2D = 2 * M_PI * redius2D;
	std::cout << area2D << std::endl;
	std::cout << length2D << std::endl;
	std::cout << retcenter2D.X() << std::endl;
	std::cout << retcenter2D.Y() << std::endl;
	CHECK(area2D == retarea2D);
	CHECK(length2D == retlength2D);
	CHECK(retcenter2D.X() == center2D.X());
	CHECK(retcenter2D.Y() == center2D.Y());
	double a, b, c, d, e, f;
	circle2D.Coefficients(a, b, c, d, e, f);
	std::cout << a << std::endl;
	std::cout << b << std::endl;
	std::cout << c << std::endl;
	std::cout << d << std::endl;
	std::cout << e << std::endl;
	std::cout << f << std::endl;
	CHECK(a == 1);
	CHECK(b == 1);
	CHECK(c == 0);
	CHECK(d == 0);
	CHECK(e == 0);
	CHECK(f == -25);
	std::vector < AMCAX::Point2> testPoints = {
		AMCAX::Point2(3.0, 4.0),
		AMCAX::Point2(5.0, 0.0),
		AMCAX::Point2(4.9, 0.0),
		AMCAX::Point2(5.1, 0.0),
		AMCAX::Point2(6.0, 0.0)
	};
	for (const auto& point : testPoints)
	{
		double distanceToCenter = std::sqrt(point.X() * point.X() + point.Y() * point.Y());
		bool expectedIsInCircle = distanceToCenter <= 5.0 + tol;
		bool isInCircle = circle2D.Contains(point, tol);
		CHECK(isInCircle == expectedIsInCircle);
	}
	for (const auto& point : testPoints)
	{
		double distance = circle2D.Distance(point);
		double expectedDistance = std::abs(std::sqrt(std::pow(point.X() - center2D.X(), 2) + std::pow(point.Y() - center2D.Y(), 2)) - redius2D);
		CHECK(distance == expectedDistance);
	}
	AMCAX::AxisT<double, 2> mirrorAxis(AMCAX::Point2(0.0, 0.0), AMCAX::Direction2(0.0, 1.0));
	circle2D.Mirror(mirrorAxis);
	AMCAX::Point2 mirroredCenter = circle2D.Location();
	std::cout << "Mirrored circle center: (" << mirroredCenter.X() << ", " << mirroredCenter.Y() << ")" << std::endl;
	CHECK(mirroredCenter.X() == center2D.X());
	CHECK(mirroredCenter.Y() == center2D.Y());
	const AMCAX::FrameT<double, 2>& frame = circle2D.Position();
	AMCAX::Point2 rotationPoint(0.0, 0.0);
	double  rotationAngle = M_PI / 4;
	auto rotatedCircle = circle2D.Rotated(rotationPoint, rotationAngle);
	double cosAngle = cos(rotationAngle);
	double sinAngle = sin(rotationAngle);
	double newX = cosAngle * (center2D.X() - rotationPoint.X()) - sinAngle * (center2D.Y() - rotationPoint.Y()) + rotationPoint.X();
	double newY = sinAngle * (center2D.X() - rotationPoint.X()) + cosAngle * (center2D.Y() - rotationPoint.Y()) + rotationPoint.Y();
	auto rotatedCenter = rotatedCircle.Location();
	CHECK(newX == center2D.X());
	CHECK(newY == center2D.Y());
	AMCAX::Point2 scalingCenter(0.0, 0.0);
	double scalingFactor = 2.0;
	auto scaledCircle = circle2D.Scale(scalingCenter, scalingFactor);
	double scaledRadius = scaledCircle.Radius();
	double expectedScaledRadius = redius2D * scalingFactor;
	CHECK(std::abs(scaledRadius - expectedScaledRadius) < 1e-6);
	AMCAX::VectorT<double, 2> translationVector(2.0, 3.0);
	auto translatedCircle = circle2D.Translated(translationVector);
	auto translatedCenter = translatedCircle.Location();
	double translatedX = center2D.X() + translationVector.X();
	CHECK(translatedX == translatedCenter.X());
	auto xAxis = circle2D.XAxis();
	auto directionAxis = xAxis.Direction();
	CHECK(directionAxis.X() == -1.0);
	CHECK(directionAxis.Y() == 0.0);
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] double Area()	 @return The area of the ellipse
	 @brief Get the area of the ellipse
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <common/FrameT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <math/EllipseT.hpp>
using namespace AMCAX;
using namespace std;
TEST_CASE("bug1:Ellipse2 bug ", "[math][Ellipse2][bug]")
{
	Axis2 axis;
	double major = 4.0;
	double minor = 5.0;
	bool isRight = true;
	string str1;
	string str2 = "[_DomainError]";
	try
	{
		Ellipse2 ellipse(axis, major, minor, isRight);
	}
	catch (exception& e)
	{
		str1 = e.what();
	}
	CHECK(str1 == str2);
;
	SECTION("Area")
	{
		double S = ellipse.Area();
		CHECK(S == Approx(M_PI * major * minor));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":EllipseS& Scale(const PointT<double, DIM>& point, double scale)	 @return The reference to self
	 @param scale The scale value
	 @param point The scaling center point
	 @brief Scale the ellipse by a center point
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <common/FrameT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <math/EllipseT.hpp>
using namespace AMCAX;
using namespace std;
TEST_CASE("bug1:Ellipse2 bug ", "[math][Ellipse2][bug]")
{
	Axis2 axis;
	double major = 4.0;
	double minor = 5.0;
	bool isRight = true;
	string str1;
	string str2 = "[_DomainError]";
	try
	{
		Ellipse2 ellipse(axis, major, minor, isRight);
	}
	catch (exception& e)
	{
		str1 = e.what();
	}
	CHECK(str1 == str2);
;
	SECTION("Scale")
	{
		Ellipse2 scale_ellipse = ellipse.Scale(point, scale);
		CHECK(ellipse.Location().X() == Approx(2.5));
		CHECK(ellipse.Location().Y() == Approx(-1.0));
		CHECK(ellipse.MajorRadius() == Approx(2.5));
		CHECK(ellipse.MinorRadius() == Approx(2.0));
		CHECK(scale_ellipse.Location().X() == Approx(2.5));
		CHECK(scale_ellipse.Location().Y() == Approx(-1.0));
		CHECK(scale_ellipse.MajorRadius() == Approx(2.5));
		CHECK(scale_ellipse.MinorRadius() == Approx(2.0));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":EllipseS& Transform(const TransformationT<double, DIM>& tr)	 @return The reference to self
	 @param tr The transformation
	 @brief Transform the ellipse
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <common/FrameT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <math/EllipseT.hpp>
using namespace AMCAX;
using namespace std;
TEST_CASE("bug1:Ellipse2 bug ", "[math][Ellipse2][bug]")
{
	Axis2 axis;
	double major = 4.0;
	double minor = 5.0;
	bool isRight = true;
	string str1;
	string str2 = "[_DomainError]";
	try
	{
		Ellipse2 ellipse(axis, major, minor, isRight);
	}
	catch (exception& e)
	{
		str1 = e.what();
	}
	CHECK(str1 == str2);
;
	SECTION("Transform")
	{
		Ellipse2 Transfor_ellipse = ellipse.Transform(tr);
		CHECK(ellipse.Location().X() == Approx(5.0));
		CHECK(ellipse.Location().Y() == Approx(-2.0));
		CHECK(ellipse.MajorRadius() == Approx(5.0));
		CHECK(ellipse.MinorRadius() == Approx(4.0));
		CHECK(Transfor_ellipse.Location().X() == Approx(5.0));
		CHECK(Transfor_ellipse.Location().Y() == Approx(-2.0));
		CHECK(Transfor_ellipse.MajorRadius() == Approx(5.0));
		CHECK(Transfor_ellipse.MinorRadius() == Approx(4.0));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] double Area()	 @return The area of the ellipse
	 @brief Get the area of the ellipse
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <common/FrameT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <math/EllipseT.hpp>
using namespace AMCAX;
using namespace std;
TEST_CASE("bug1:Ellipse3 bug ", "[math][Ellipse3][bug]")
{
	Frame3 frame;
	double major = 4.0;
	double minor = 5.0;
	string str1;
	string str2 = "[_DomainError]";
	try
	{
		Ellipse3 ellipse(frame, major, minor);
	}
	catch (exception& e)
	{
		str1 = e.what();
	}
	CHECK(str1 == str2);
;
	SECTION("Area")
	{
		double S = ellipse.Area();
		CHECK(S == Approx(M_PI * major * minor));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":EllipseS& Scale(const PointT<double, DIM>& point, double scale)	 @return The reference to self
	 @param scale The scale value
	 @param point The scaling center point
	 @brief Scale the ellipse by a center point
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <common/FrameT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <math/EllipseT.hpp>
using namespace AMCAX;
using namespace std;
TEST_CASE("bug1:Ellipse3 bug ", "[math][Ellipse3][bug]")
{
	Frame3 frame;
	double major = 4.0;
	double minor = 5.0;
	string str1;
	string str2 = "[_DomainError]";
	try
	{
		Ellipse3 ellipse(frame, major, minor);
	}
	catch (exception& e)
	{
		str1 = e.what();
	}
	CHECK(str1 == str2);
;
	SECTION("Scale")
	{
		Ellipse3 scale_ellipse = ellipse.Scale(point, scale);
		CHECK(ellipse.Location().X() == Approx(6.0));
		CHECK(ellipse.Location().Y() == Approx(0.0));
		CHECK(ellipse.Location().Z() == Approx(6.0));
		CHECK(ellipse.MajorRadius() == Approx(2.5));
		CHECK(ellipse.MinorRadius() == Approx(2.0));
		CHECK(scale_ellipse.Location().X() == Approx(6.0));
		CHECK(scale_ellipse.Location().Y() == Approx(0.0));
		CHECK(scale_ellipse.Location().Z() == Approx(6.0));
		CHECK(scale_ellipse.MajorRadius() == Approx(2.5));
		CHECK(scale_ellipse.MinorRadius() == Approx(2.0));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":EllipseS& Transform(const TransformationT<double, DIM>& tr)	 @return The reference to self
	 @param tr The transformation
	 @brief Transform the ellipse
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <common/FrameT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <math/EllipseT.hpp>
using namespace AMCAX;
using namespace std;
TEST_CASE("bug1:Ellipse3 bug ", "[math][Ellipse3][bug]")
{
	Frame3 frame;
	double major = 4.0;
	double minor = 5.0;
	string str1;
	string str2 = "[_DomainError]";
	try
	{
		Ellipse3 ellipse(frame, major, minor);
	}
	catch (exception& e)
	{
		str1 = e.what();
	}
	CHECK(str1 == str2);
;
	SECTION("Transform")
	{
		Ellipse3 Transfor_ellipse = ellipse.Transform(tr);
		CHECK(ellipse.Location().X() == Approx(5.0));
		CHECK(ellipse.Location().Y() == Approx(-2.0));
		CHECK(ellipse.Location().Z() == Approx(3.0));
		CHECK(ellipse.Axis().Direction().X() == Approx(0.0));
		CHECK(ellipse.Axis().Direction().Y() == Approx(0.0));
		CHECK(ellipse.Axis().Direction().Z() == Approx(1.0));
		CHECK(Transfor_ellipse.Location().X() == Approx(5.0));
		CHECK(Transfor_ellipse.Location().Y() == Approx(-2.0));
		CHECK(Transfor_ellipse.Location().Z() == Approx(3.0));
		CHECK(Transfor_ellipse.Axis().Direction().X() == Approx(0.0));
		CHECK(Transfor_ellipse.Axis().Direction().Y() == Approx(0.0));
		CHECK(Transfor_ellipse.Axis().Direction().Z() == Approx(1.0));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] double SemilatusRectum()	 @return The semilatus rectum
	          Semilatus rectum = 2 * focalLength
	 @details The semilatus rectum of parabola is half of the length of the chord through a focus parallel to the directrix.
	 @brief Get the semilatus rectum of the parabola
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <geometry/Geom2Parabola.hpp>
using namespace AMCAX;
using namespace std;
#include <catch.hpp>
#include <testHelper.h>
#include <geometry/Geom2Parabola.hpp>
using namespace AMCAX;
using namespace std;
;
	SECTION("SemilatusRectum")
	{
		double SR = g2p.SemilatusRectum();
		double sr = 2 * focal;
		CHECK(SR == sr);
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] double SemilatusRectum()	 @return The semilatus rectum
	          Semilatus rectum = 2 * focalLength
	 @details The semilatus rectum of parabola is half of the length of the chord through a focus parallel to the directrix.
	 @brief Get the semilatus rectum of the parabola
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <geometry/Geom3Parabola.hpp>
using namespace AMCAX;
using namespace std;
#include <catch.hpp>
#include <testHelper.h>
#include <geometry/Geom3Parabola.hpp>
using namespace AMCAX;
using namespace std;
;
	SECTION("SemilatusRectum")
	{
		double SR = g3p.SemilatusRectum();
		double sr = 2 * focal;
		CHECK(SR == sr);
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] double FocalParameter()	 @return The focal parameter
	          Focal parameter = 2 * focalLength.
	 @details The focal parameter of parabola is the distance from the focus to the directrix.
	 @brief Get the focal parameter of the parabola
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <math/ParabolaT.hpp>
using namespace AMCAX;
using namespace std;
#include <catch.hpp>
#include <testHelper.h>
#include <math/ParabolaT.hpp>
using namespace AMCAX;
using namespace std;
;
	SECTION("FocalParameter")
	{
		double FP = parabola.FocalParameter();
		double fp = 2 * focal;
		CHECK(FP == fp);
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] double SemilatusRectum()	 @return The semilatus rectum
	          Semilatus rectum = 2 * focalLength
	 @details The semilatus rectum of parabola is half of the length of the chord through a focus parallel to the directrix.
	 @brief Get the semilatus rectum of the parabola
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <math/ParabolaT.hpp>
using namespace AMCAX;
using namespace std;
#include <catch.hpp>
#include <testHelper.h>
#include <math/ParabolaT.hpp>
using namespace AMCAX;
using namespace std;
;
	SECTION("SemilatusRectum")
	{
		double SR = parabola.SemilatusRectum();
		double sr = 2 * focal;
		CHECK(SR == sr);
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] double FocalParameter()	 @return The focal parameter
	          Focal parameter = 2 * focalLength.
	 @details The focal parameter of parabola is the distance from the focus to the directrix.
	 @brief Get the focal parameter of the parabola
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <math/ParabolaT.hpp>
using namespace AMCAX;
using namespace std;
#include <catch.hpp>
#include <testHelper.h>
#include <math/ParabolaT.hpp>
using namespace AMCAX;
using namespace std;
;
	SECTION("FocalParameter")
	{
		double FP = parabola.FocalParameter();
		double fp = 2 * focal;
		CHECK(FP == fp);
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] double SemilatusRectum()	 @return The semilatus rectum
	          Semilatus rectum = 2 * focalLength
	 @details The semilatus rectum of parabola is half of the length of the chord through a focus parallel to the directrix.
	 @brief Get the semilatus rectum of the parabola
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <math/ParabolaT.hpp>
using namespace AMCAX;
using namespace std;
#include <catch.hpp>
#include <testHelper.h>
#include <math/ParabolaT.hpp>
using namespace AMCAX;
using namespace std;
;
	SECTION("SemilatusRectum")
	{
		double SR = parabola.SemilatusRectum();
		double sr = 2 * focal;
		CHECK(SR == sr);
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] bool Contains(const PointT<double, DIM>& p, double tol)	 @return True if the point is on the line under the tolerance
	 @param tol The tolerance
	 @param p The point
	 @brief Does the line contain a point under a distance tolerance
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <math/LineT.hpp>
#include <modeling/MakeEdge2d.hpp>
using AMCAX::Line2;
#define ONE_RADIAN (M_PI / 180.)
#include <catch.hpp>
#include <testHelper.h>
#include <math/LineT.hpp>
#include <modeling/MakeEdge2d.hpp>
using AMCAX::Line2;
#define ONE_RADIAN (M_PI / 180.)
;
	SECTION("Contains")
	{
		Line2 line(Axis2(Point2(2., 1.), Direction2(1., 1.)));  
		Point2 point1(2., 1.);  
		Point2 point2(1., 1.);  
		CHECK(line.Contains(point1, 1e-5));
		CHECK_FALSE(line.Contains(point2, 1e-5));
		CHECK(line.Contains(point2, 1.));  
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] const PointT<double, DIM>& Location()	 @return The location of the line
	 @brief Get the location point of the line
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <math/LineT.hpp>
#include <modeling/MakeEdge2d.hpp>
using AMCAX::Line2;
#define ONE_RADIAN (M_PI / 180.)
#include <catch.hpp>
#include <testHelper.h>
#include <math/LineT.hpp>
#include <modeling/MakeEdge2d.hpp>
using AMCAX::Line2;
#define ONE_RADIAN (M_PI / 180.)
;
	SECTION("SetPosition")
	{
		Line2 line;
		CHECK(line.Location().IsEqual(Point2(0., 0.), 1e-5));
		CHECK(line.Direction().IsEqual(Direction2(1., 0.), 1e-5 * ONE_RADIAN));
		Axis2 axis(Point2(2., 1.), Direction2(1., 1.));
		line.SetPosition(axis);  
		double a, b, c;
		line.Coefficients(a, b, c);
		CHECK(a == Approx(1. / std::sqrt(2)).margin(1e-5));
		CHECK(b == Approx(-1. / std::sqrt(2)).margin(1e-5));
		CHECK(c == Approx(-1. / std::sqrt(2)).margin(1e-5));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] Derived Scaled(const PointT<double, DIM>& point, double scale)	 @return The scaled line
	 @param scale The scale value
	 @param point The scaling center point
	 @brief Get the line scaled by a point
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <math/LineT.hpp>
#include <modeling/MakeEdge2d.hpp>
using AMCAX::Line2;
#define ONE_RADIAN (M_PI / 180.)
#include <catch.hpp>
#include <testHelper.h>
#include <math/LineT.hpp>
#include <modeling/MakeEdge2d.hpp>
using AMCAX::Line2;
#define ONE_RADIAN (M_PI / 180.)
;
	SECTION("Scale")
	{
		Line2 line(Point2(0., -1.), Direction2());
		Point2 point;
		double distance = line.Distance(point);
		Line2 lineScale1 = line.Scaled(point, 1.1);
		CHECK(lineScale1.Distance(point) > distance);
		CHECK(lineScale1.Contains(Point2(0., -1.1), 1e-5));
		Line2 lineScale2 = line.Scaled(point, 1.);
		CHECK(lineScale2.Distance(point) == Approx(distance).margin(1e-5));
		CHECK(lineScale2.Contains(Point2(0., -1.), 1e-5));
		Line2 lineScale3 = line.Scaled(point, 0.8);
		CHECK(lineScale3.Distance(point) < distance);
		CHECK(lineScale3.Contains(Point2(0., -0.8), 1e-5));
		Line2 lineScale4 = line.Scaled(point, 0.);
		line.SetDirection(Direction2(-1.0, 4.0));
		Line2 lineScale5 = line.Scaled(Point2(-1., 2.), 0.);
		CHECK(lineScale4.Contains(Point2(0., 0.), 1e-5));
		CHECK(lineScale4.Direction().IsEqual(Direction2(), 1e-6 * ONE_RADIAN));
		CHECK(lineScale5.Contains(Point2(-1., 2.), 1e-5));
		CHECK(lineScale5.Direction().IsEqual(Direction2(-1., 4.), 1e-6 * ONE_RADIAN));
		Line2 lineScale6 = line.Scaled(point, -1.);
		CHECK(lineScale6.Direction().IsEqual(Direction2(1., -4.), 1e-5 * ONE_RADIAN));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":Derived& Translate(const VectorT<double, DIM>& vec)	 @return The reference to self
	 @param vec The translation vector
	 @brief Translate the line by a vector
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <math/LineT.hpp>
#include <modeling/MakeEdge2d.hpp>
using AMCAX::Line2;
#define ONE_RADIAN (M_PI / 180.)
#include <catch.hpp>
#include <testHelper.h>
#include <math/LineT.hpp>
#include <modeling/MakeEdge2d.hpp>
using AMCAX::Line2;
#define ONE_RADIAN (M_PI / 180.)
;
	SECTION("Translate Test")
	{
		Line2 line;
		line.Translate(Vector2(2., 0.));  
		CHECK(line.Direction().IsEqual(Direction2(), 1e-5 * ONE_RADIAN));
		CHECK(line.Contains(Point2(2., 0.), 1e-5));
		Line2 translateLine = line.Translated(Point2(2., 0.), Point2(-10., 0.));
		CHECK(translateLine.Contains(Point2(-10., 0.), 1e-5));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] Derived Translated(const PointT<double, DIM>& p1, const PointT<double, DIM>& p2)	 @return The translated line
	 @param p2 The target point
	 @param p1 The source point
	 @brief Get the line translated by a vector from a point to another point
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <math/LineT.hpp>
#include <modeling/MakeEdge2d.hpp>
using AMCAX::Line2;
#define ONE_RADIAN (M_PI / 180.)
#include <catch.hpp>
#include <testHelper.h>
#include <math/LineT.hpp>
#include <modeling/MakeEdge2d.hpp>
using AMCAX::Line2;
#define ONE_RADIAN (M_PI / 180.)
;
	SECTION("Translate Test")
	{
		Line2 line;
		line.Translate(Vector2(2., 0.));  
		CHECK(line.Direction().IsEqual(Direction2(), 1e-5 * ONE_RADIAN));
		CHECK(line.Contains(Point2(2., 0.), 1e-5));
		Line2 translateLine = line.Translated(Point2(2., 0.), Point2(-10., 0.));
		CHECK(translateLine.Contains(Point2(-10., 0.), 1e-5));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":void SetLocation(const PointT<double, DIM>& point)	 @param point The location point
	 @brief Set the location of the line
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <math/LineT.hpp>
#include <modeling/MakeEdge2d.hpp>
using AMCAX::Line2;
#define ONE_RADIAN (M_PI / 180.)
#include <catch.hpp>
#include <testHelper.h>
#include <math/LineT.hpp>
#include <modeling/MakeEdge2d.hpp>
using AMCAX::Line2;
#define ONE_RADIAN (M_PI / 180.)
;
	SECTION("SetLocation")
	{
		Line2 line(Point2(0., 0.), Direction2(1., 1.));  
		CHECK(line.Location().IsEqual(Point2(), 1e-5));
		line.SetLocation(Point2(2., 1.));  
		CHECK(line.Location().IsEqual(Point2(2., 1.), 1e-5));
		double a, b, c;
		line.Coefficients(a, b, c);
		CHECK(a == Approx(1. / std::sqrt(2)).margin(1e-5));
		CHECK(b == Approx(-1. / std::sqrt(2)).margin(1e-5));
		CHECK(c == Approx(-1. / std::sqrt(2)).margin(1e-5));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":void SetDirection(const DirectionT<double, DIM>& dir)	 @param dir The line direction
	 @brief Set the line direction
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <math/LineT.hpp>
#include <modeling/MakeEdge2d.hpp>
using AMCAX::Line2;
#define ONE_RADIAN (M_PI / 180.)
#include <catch.hpp>
#include <testHelper.h>
#include <math/LineT.hpp>
#include <modeling/MakeEdge2d.hpp>
using AMCAX::Line2;
#define ONE_RADIAN (M_PI / 180.)
;
	SECTION("SetDirection")
	{
		Line2 line(Point2(), Direction2(1., 1.));  
		CHECK(line.Direction().IsEqual(Direction2(1., 1.), 1e-5 * ONE_RADIAN));
		CHECK(line.Distance(Point2(1., 2.)) > 0.);
		line.SetDirection(Direction2(1., 2.));  
		CHECK(line.Direction().IsEqual(Direction2(1., 2.), 1e-5 * ONE_RADIAN));
		CHECK(line.Distance(Point2(1., 2.)) == Approx(0.).margin(1e-5));
		double a, b, c;
		line.Coefficients(a, b, c);
		CHECK(a == Approx(2. / std::sqrt(5)).margin(1e-5));
		CHECK(b == Approx(-1. / std::sqrt(5)).margin(1e-5));
		CHECK(c == Approx(0. / std::sqrt(5)).margin(1e-5));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":void SetPosition(const AxisT<double, DIM>& axis)	 @param axis The axis
	 @brief Set the axis of the line
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <math/LineT.hpp>
#include <modeling/MakeEdge2d.hpp>
using AMCAX::Line2;
#define ONE_RADIAN (M_PI / 180.)
#include <catch.hpp>
#include <testHelper.h>
#include <math/LineT.hpp>
#include <modeling/MakeEdge2d.hpp>
using AMCAX::Line2;
#define ONE_RADIAN (M_PI / 180.)
;
	SECTION("SetPosition")
	{
		Line2 line;
		CHECK(line.Location().IsEqual(Point2(0., 0.), 1e-5));
		CHECK(line.Direction().IsEqual(Direction2(1., 0.), 1e-5 * ONE_RADIAN));
		Axis2 axis(Point2(2., 1.), Direction2(1., 1.));
		line.SetPosition(axis);  
		double a, b, c;
		line.Coefficients(a, b, c);
		CHECK(a == Approx(1. / std::sqrt(2)).margin(1e-5));
		CHECK(b == Approx(-1. / std::sqrt(2)).margin(1e-5));
		CHECK(c == Approx(-1. / std::sqrt(2)).margin(1e-5));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] const DirectionT<double, DIM>& Direction()	 @return The direction of the line
	 @brief Get the direction of the line
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <math/LineT.hpp>
#include <modeling/MakeEdge2d.hpp>
using AMCAX::Line2;
#define ONE_RADIAN (M_PI / 180.)
#include <catch.hpp>
#include <testHelper.h>
#include <math/LineT.hpp>
#include <modeling/MakeEdge2d.hpp>
using AMCAX::Line2;
#define ONE_RADIAN (M_PI / 180.)
;
	SECTION("SetDirection")
	{
		Line2 line(Point2(), Direction2(1., 1.));  
		CHECK(line.Direction().IsEqual(Direction2(1., 1.), 1e-5 * ONE_RADIAN));
		CHECK(line.Distance(Point2(1., 2.)) > 0.);
		line.SetDirection(Direction2(1., 2.));  
		CHECK(line.Direction().IsEqual(Direction2(1., 2.), 1e-5 * ONE_RADIAN));
		CHECK(line.Distance(Point2(1., 2.)) == Approx(0.).margin(1e-5));
		double a, b, c;
		line.Coefficients(a, b, c);
		CHECK(a == Approx(2. / std::sqrt(5)).margin(1e-5));
		CHECK(b == Approx(-1. / std::sqrt(5)).margin(1e-5));
		CHECK(c == Approx(0. / std::sqrt(5)).margin(1e-5));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] auto Angle(const LineBase& other)	 @return The angle between the line and the other line
	 @param other The other line
	 @brief Compute the angle between the line and the other line
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <math/LineT.hpp>
#include <modeling/MakeEdge2d.hpp>
using AMCAX::Line2;
#define ONE_RADIAN (M_PI / 180.)
#include <catch.hpp>
#include <testHelper.h>
#include <math/LineT.hpp>
#include <modeling/MakeEdge2d.hpp>
using AMCAX::Line2;
#define ONE_RADIAN (M_PI / 180.)
;
	SECTION("Angle")
	{
		Line2 line;
		Line2 line2(Point2(), Direction2(0., 1.));
		CHECK(line.Angle(line2) == Approx(M_PI_2));
		CHECK(line2.Angle(line) == Approx(-M_PI_2));
		Line2 line3(Point2(), Direction2(2., 3.));
		Line2 line4(Point2(), Direction2(5., -8.));
		CHECK(line4.Angle(line3) == Approx(
			std::acos((2. * 5. + 3. * (-8.)) / (std::sqrt(4. + 9.) * std::sqrt(25. + 64.)))
		).margin(1e-5 * ONE_RADIAN));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":Derived& Reverse()	 @return The reference to self
	 @brief Reverse the line direction
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <math/LineT.hpp>
#include <modeling/MakeEdge2d.hpp>
using AMCAX::Line2;
#define ONE_RADIAN (M_PI / 180.)
#include <catch.hpp>
#include <testHelper.h>
#include <math/LineT.hpp>
#include <modeling/MakeEdge2d.hpp>
using AMCAX::Line2;
#define ONE_RADIAN (M_PI / 180.)
;
	SECTION("Reverse")
	{
		Line2 line;
		line.Reverse();
		CHECK(line.Direction().IsEqual(Direction2(-1., 0.), 1e-5 * ONE_RADIAN));
		Line2 line2(Point2(), Direction2(-3., 98.));
		line2.Reverse();
		CHECK(line2.Direction().IsEqual(Direction2(3., -98.), 1e-5 * ONE_RADIAN));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":LineS(double a, double b, double c)	 @param a,b,c The coefficients
	 @brief Construct from the algebraic coefficients of 2D line
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <math/LineT.hpp>
#include <modeling/MakeEdge2d.hpp>
using AMCAX::Line2;
#define ONE_RADIAN (M_PI / 180.)
#include <catch.hpp>
#include <testHelper.h>
#include <math/LineT.hpp>
#include <modeling/MakeEdge2d.hpp>
using AMCAX::Line2;
#define ONE_RADIAN (M_PI / 180.)
;
	SECTION("Normal Test")
	{
		Line2 line(3., 4., 5.);  
		Line2 normalLine = line.Normal(Point2(1., 5.));
		double a, b, c;
		normalLine.Coefficients(a, b, c);
		CHECK((a * 3 + b * 4) == Approx(0.0).margin(0.1));
		CHECK((a * 1 + b * 5 + c) == Approx(0.0).margin(0.1));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":void Coefficients(double& a, double& b, double& c)	 @param[out] a,b,c The coefficients
	 @brief The coefficients of the algebraic representation of the 2D line
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <math/LineT.hpp>
#include <modeling/MakeEdge2d.hpp>
using AMCAX::Line2;
#define ONE_RADIAN (M_PI / 180.)
#include <catch.hpp>
#include <testHelper.h>
#include <math/LineT.hpp>
#include <modeling/MakeEdge2d.hpp>
using AMCAX::Line2;
#define ONE_RADIAN (M_PI / 180.)
;
	SECTION("Parameterized constructor test")
	{
		Line2 line1(Axis2(Point2(1., 0.), Direction2(2., 1.)));
		Line2 line2(Point2(1., 0.), Direction2(2., 1.));  
		Line2 line3(1, -2, -1);
		double a, b, c;
		line1.Coefficients(a, b, c);
		CHECK(a == Approx(1.0 / std::sqrt(5)));
		CHECK(b == Approx(-2.0 / std::sqrt(5)));
		CHECK(c == Approx(-1.0 / std::sqrt(5)));
		line2.Coefficients(a, b, c);
		CHECK(a == Approx(1.0 / std::sqrt(5)));
		CHECK(b == Approx(-2.0 / std::sqrt(5)));
		CHECK(c == Approx(-1.0 / std::sqrt(5)));
		line3.Coefficients(a, b, c);
		CHECK(a == Approx(1.0 / std::sqrt(5)));
		CHECK(b == Approx(-2.0 / std::sqrt(5)));
		CHECK(c == Approx(-1.0 / std::sqrt(5)));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] auto Distance(const Point2& p)	 @return The distance between the point and the line
	 @param p The point
	 @brief Compute the distance from a point to the line
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <math/LineT.hpp>
#include <modeling/MakeEdge2d.hpp>
using AMCAX::Line2;
#define ONE_RADIAN (M_PI / 180.)
#include <catch.hpp>
#include <testHelper.h>
#include <math/LineT.hpp>
#include <modeling/MakeEdge2d.hpp>
using AMCAX::Line2;
#define ONE_RADIAN (M_PI / 180.)
;
	SECTION("SetDirection")
	{
		Line2 line(Point2(), Direction2(1., 1.));  
		CHECK(line.Direction().IsEqual(Direction2(1., 1.), 1e-5 * ONE_RADIAN));
		CHECK(line.Distance(Point2(1., 2.)) > 0.);
		line.SetDirection(Direction2(1., 2.));  
		CHECK(line.Direction().IsEqual(Direction2(1., 2.), 1e-5 * ONE_RADIAN));
		CHECK(line.Distance(Point2(1., 2.)) == Approx(0.).margin(1e-5));
		double a, b, c;
		line.Coefficients(a, b, c);
		CHECK(a == Approx(2. / std::sqrt(5)).margin(1e-5));
		CHECK(b == Approx(-1. / std::sqrt(5)).margin(1e-5));
		CHECK(c == Approx(0. / std::sqrt(5)).margin(1e-5));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] auto SquaredDistance(const Point2& p)	 @return The squared distance between the point and the line
	 @param p The point
	 @brief Compute the squared distance from a point to the line
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <math/LineT.hpp>
#include <modeling/MakeEdge2d.hpp>
using AMCAX::Line2;
#define ONE_RADIAN (M_PI / 180.)
#include <catch.hpp>
#include <testHelper.h>
#include <math/LineT.hpp>
#include <modeling/MakeEdge2d.hpp>
using AMCAX::Line2;
#define ONE_RADIAN (M_PI / 180.)
;
	SECTION("Distance and SquaredDistance test")
	{
		auto pointToLine = [](const Point2& point, const Line2& line) {
			double a, b, c;
			line.Coefficients(a, b, c);
			return std::fabs(a * point.X() + b * point.Y() + c);
		};
		auto lineToLine = [](const Line2& line1, const Line2& line2) {
			double a1, b1, c1, a2, b2, c2;
			line1.Coefficients(a1, b1, c1);
			line2.Coefficients(a2, b2, c2);
			if (a1 != a2 || b1 != b2) return 0.;
			return std::fabs(c1 - c2);
		};
		Line2 line(3., 4., -30.);
		Point2 point1(6., 3.);
		Point2 point2(6., 2.);
		Line2 line2(3., 4., -29.);
		Line2 line3(2., 1., -99.);
		CHECK(line.Distance(point1) == Approx(pointToLine(point1, line)).margin(0.01));
		CHECK(line.SquaredDistance(point1) == Approx(pointToLine(point1, line) * pointToLine(point1, line)).margin(0.01));
		CHECK(line.Distance(point2) == Approx(pointToLine(point2, line)));
		CHECK(line.SquaredDistance(point2) == Approx(pointToLine(point2, line) * pointToLine(point2, line)).margin(0.01));
		CHECK(line.Distance(line2) == Approx(lineToLine(line, line2)));
		CHECK(line.SquaredDistance(line2) == Approx(lineToLine(line2, line) * lineToLine(line2, line)).margin(0.01));
		CHECK(line.Distance(line3) == Approx(lineToLine(line, line3)));
		CHECK(line.SquaredDistance(line3) == Approx(lineToLine(line3, line) * lineToLine(line3, line)).margin(0.01));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] auto SquaredDistance(const LineS& l)	 @return The squared distance between two lines
	 @param l The other line
	 @brief Compute the squared distance between two lines
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <math/LineT.hpp>
#include <modeling/MakeEdge2d.hpp>
using AMCAX::Line2;
#define ONE_RADIAN (M_PI / 180.)
#include <catch.hpp>
#include <testHelper.h>
#include <math/LineT.hpp>
#include <modeling/MakeEdge2d.hpp>
using AMCAX::Line2;
#define ONE_RADIAN (M_PI / 180.)
;
	SECTION("Distance and SquaredDistance test")
	{
		auto pointToLine = [](const Point2& point, const Line2& line) {
			double a, b, c;
			line.Coefficients(a, b, c);
			return std::fabs(a * point.X() + b * point.Y() + c);
		};
		auto lineToLine = [](const Line2& line1, const Line2& line2) {
			double a1, b1, c1, a2, b2, c2;
			line1.Coefficients(a1, b1, c1);
			line2.Coefficients(a2, b2, c2);
			if (a1 != a2 || b1 != b2) return 0.;
			return std::fabs(c1 - c2);
		};
		Line2 line(3., 4., -30.);
		Point2 point1(6., 3.);
		Point2 point2(6., 2.);
		Line2 line2(3., 4., -29.);
		Line2 line3(2., 1., -99.);
		CHECK(line.Distance(point1) == Approx(pointToLine(point1, line)).margin(0.01));
		CHECK(line.SquaredDistance(point1) == Approx(pointToLine(point1, line) * pointToLine(point1, line)).margin(0.01));
		CHECK(line.Distance(point2) == Approx(pointToLine(point2, line)));
		CHECK(line.SquaredDistance(point2) == Approx(pointToLine(point2, line) * pointToLine(point2, line)).margin(0.01));
		CHECK(line.Distance(line2) == Approx(lineToLine(line, line2)));
		CHECK(line.SquaredDistance(line2) == Approx(lineToLine(line2, line) * lineToLine(line2, line)).margin(0.01));
		CHECK(line.Distance(line3) == Approx(lineToLine(line, line3)));
		CHECK(line.SquaredDistance(line3) == Approx(lineToLine(line3, line) * lineToLine(line3, line)).margin(0.01));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] LineS Normal(const Point2& p)	 @return The line passing through a point and perpendicular to the line
	 @param p The point
	 @brief Get a line passing through a point and perpendicular to the line
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <math/LineT.hpp>
#include <modeling/MakeEdge2d.hpp>
using AMCAX::Line2;
#define ONE_RADIAN (M_PI / 180.)
#include <catch.hpp>
#include <testHelper.h>
#include <math/LineT.hpp>
#include <modeling/MakeEdge2d.hpp>
using AMCAX::Line2;
#define ONE_RADIAN (M_PI / 180.)
;
	SECTION("Normal Test")
	{
		Line2 line(3., 4., 5.);  
		Line2 normalLine = line.Normal(Point2(1., 5.));
		double a, b, c;
		normalLine.Coefficients(a, b, c);
		CHECK((a * 3 + b * 4) == Approx(0.0).margin(0.1));
		CHECK((a * 1 + b * 5 + c) == Approx(0.0).margin(0.1));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":LineS& Rotate(const Point2& point, double angle)	 @return The reference to self
	 @param angle The rotation angle
	 @param point The rotation center point
	 @brief Rotate the line around a point with an angle in 2D
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <math/LineT.hpp>
#include <modeling/MakeEdge2d.hpp>
using AMCAX::Line2;
#define ONE_RADIAN (M_PI / 180.)
#include <catch.hpp>
#include <testHelper.h>
#include <math/LineT.hpp>
#include <modeling/MakeEdge2d.hpp>
using AMCAX::Line2;
#define ONE_RADIAN (M_PI / 180.)
;
	SECTION("Rotate Test")
	{
		Line2 line(Point2(0., 1.), Direction2(1., 1.));  
		Line2 line2(Point2(0., 1.), Direction2(1., 1.));  
		line.Rotate(Point2(), (5. / 4) * M_PI);  
		CHECK(line.Direction().X() == Approx(0.).margin(1e-5));
		CHECK(line.Direction().Y() == Approx(-1.).margin(1e-5));
		double a, b, c;
		line.Coefficients(a, b, c);
		CHECK((a + c) == Approx(0.).margin(0.5));
		CHECK(line2.Distance(Point2()) == line.Distance(Point2()));  
		CHECK(line.Contains(Point2(std::sqrt(2.) / 2., 0.), 1e-6) == true);
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] LineS Rotated(const Point2& point, double angle)	 @return The rotated line
	 @param angle The rotation angle
	 @param point The rotation center point
	 @brief Get the line rotated around a point with an angle in 2D
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <math/LineT.hpp>
#include <modeling/MakeEdge2d.hpp>
using AMCAX::Line2;
#define ONE_RADIAN (M_PI / 180.)
#include <catch.hpp>
#include <testHelper.h>
#include <math/LineT.hpp>
#include <modeling/MakeEdge2d.hpp>
using AMCAX::Line2;
#define ONE_RADIAN (M_PI / 180.)
;
	SECTION("Rotated Test")
	{
		Line2 line(Point2(0., 1.), Direction2(1., 1.));  
		Line2 rotateLine = line.Rotated(Point2(), (3. / 4) * M_PI);  
		CHECK(rotateLine.Direction().X() == Approx(-1.).margin(1e-5));
		CHECK(rotateLine.Direction().Y() == Approx(0.).margin(1e-5));
		double a, b, c;
		rotateLine.Coefficients(a, b, c);
		CHECK((c - b) == Approx(0.).margin(0.5));
		CHECK(line.Distance(Point2()) == rotateLine.Distance(Point2()));  
		TopoShape lineShape1 = MakeEdge2d(line);
		TopoShape lineShape2 = MakeEdge2d(rotateLine);
		REQUIRE(OCCTIO::OCCTTool::Write(lineShape1, OUTPUT_PATH_PREFIX"Line2_Rotated_before_p1.brep"));
		REQUIRE(OCCTIO::OCCTTool::Write(lineShape2, OUTPUT_PATH_PREFIX"Line2_Rotated_later_p1.brep"));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] auto SquaredDistance(const Point3& p)	 @return The squared distance between the point and the line
	 @param p The point
	 @brief Compute the squared distance from a point to the line
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <math/LineT.hpp>
#include <modeling/MakeEdge2d.hpp>
using AMCAX::Line2;
#define ONE_RADIAN (M_PI / 180.)
#include <catch.hpp>
#include <testHelper.h>
#include <math/LineT.hpp>
#include <modeling/MakeEdge2d.hpp>
using AMCAX::Line2;
#define ONE_RADIAN (M_PI / 180.)
;
	SECTION("Distance and SquaredDistance test")
	{
		auto pointToLine = [](const Point2& point, const Line2& line) {
			double a, b, c;
			line.Coefficients(a, b, c);
			return std::fabs(a * point.X() + b * point.Y() + c);
		};
		auto lineToLine = [](const Line2& line1, const Line2& line2) {
			double a1, b1, c1, a2, b2, c2;
			line1.Coefficients(a1, b1, c1);
			line2.Coefficients(a2, b2, c2);
			if (a1 != a2 || b1 != b2) return 0.;
			return std::fabs(c1 - c2);
		};
		Line2 line(3., 4., -30.);
		Point2 point1(6., 3.);
		Point2 point2(6., 2.);
		Line2 line2(3., 4., -29.);
		Line2 line3(2., 1., -99.);
		CHECK(line.Distance(point1) == Approx(pointToLine(point1, line)).margin(0.01));
		CHECK(line.SquaredDistance(point1) == Approx(pointToLine(point1, line) * pointToLine(point1, line)).margin(0.01));
		CHECK(line.Distance(point2) == Approx(pointToLine(point2, line)));
		CHECK(line.SquaredDistance(point2) == Approx(pointToLine(point2, line) * pointToLine(point2, line)).margin(0.01));
		CHECK(line.Distance(line2) == Approx(lineToLine(line, line2)));
		CHECK(line.SquaredDistance(line2) == Approx(lineToLine(line2, line) * lineToLine(line2, line)).margin(0.01));
		CHECK(line.Distance(line3) == Approx(lineToLine(line, line3)));
		CHECK(line.SquaredDistance(line3) == Approx(lineToLine(line3, line) * lineToLine(line3, line)).margin(0.01));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] bool Contains(const PointT<double, DIM>& p, double tol)	 @return True if the point is on the line under the tolerance
	 @param tol The tolerance
	 @param p The point
	 @brief Does the line contain a point under a distance tolerance
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <math/LineT.hpp>
#include <math/Plane.hpp>
#include <modeling/MakeFace.hpp>
#include <modeling/MakeEdge.hpp>
using AMCAX::Line3;
using AMCAX::MakeEdge;
using AMCAX::MakeFace;
#define ONE_RADIAN (M_PI / 180.)
#define SQUARE(x) ((x) * (x))
#include <catch.hpp>
#include <testHelper.h>
#include <math/LineT.hpp>
#include <math/Plane.hpp>
#include <modeling/MakeFace.hpp>
#include <modeling/MakeEdge.hpp>
using AMCAX::Line3;
using AMCAX::MakeEdge;
using AMCAX::MakeFace;
#define ONE_RADIAN (M_PI / 180.)
#define SQUARE(x) ((x) * (x))
;
	SECTION("Scale")
	{
		Line3 line(Point3(), Direction3(0., 1., 0.));
		Point3 point(1., 1., 0.);
		double originalDistance = line.Distance(point);
		Line3 line1 = line.Scaled(point, 1.1);
		CHECK(line1.Distance(point) > originalDistance);
		Line3 line2 = line.Scaled(point, 1.);
		CHECK(line2.Distance(point) == originalDistance);
		Line3 line3 = line.Scaled(point, 0.8);
		CHECK(line3.Distance(point) < originalDistance);
		Line3 line4 = line.Scaled(point, 0.);
		CHECK(line4.Contains(point, 1e-6));
		Line3 line5 = line.Scaled(point, -1.);
		CHECK(line5.Direction().IsEqual(Direction3(0., -1., 0.), 1e-6 * ONE_RADIAN));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] const PointT<double, DIM>& Location()	 @return The location of the line
	 @brief Get the location point of the line
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <math/LineT.hpp>
#include <math/Plane.hpp>
#include <modeling/MakeFace.hpp>
#include <modeling/MakeEdge.hpp>
using AMCAX::Line3;
using AMCAX::MakeEdge;
using AMCAX::MakeFace;
#define ONE_RADIAN (M_PI / 180.)
#define SQUARE(x) ((x) * (x))
#include <catch.hpp>
#include <testHelper.h>
#include <math/LineT.hpp>
#include <math/Plane.hpp>
#include <modeling/MakeFace.hpp>
#include <modeling/MakeEdge.hpp>
using AMCAX::Line3;
using AMCAX::MakeEdge;
using AMCAX::MakeFace;
#define ONE_RADIAN (M_PI / 180.)
#define SQUARE(x) ((x) * (x))
;
	SECTION("constructor")
	{
		Line3 line;  
		CHECK(line.Location().IsEqual(Point3(0., 0., 0.), 1e-5));
		CHECK(line.Direction().IsEqual(Direction3(0., 0., 1.), 1e-5 * ONE_RADIAN));
		Axis3 axis(Point3(1., 1., 1.), Direction3(3., 3., 4.));
		Line3 line2(axis);
		CHECK(line2.Position().IsCoaxial(axis, 1e-5 * ONE_RADIAN, 1e-5));  
		Line3 line3(Point3(1., 2., 3.), Direction3(3., 2., 1.));
		CHECK(line3.Location().IsEqual(Point3(1., 2., 3.), 1e-5));
		CHECK(line3.Direction().IsEqual(Direction3(3., 2., 1.), 1e-5 * ONE_RADIAN));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":Derived& Scale(const PointT<double, DIM>& point, double scale)	 @return The reference to self
	 @param scale The scale value
	 @param point The scaling center point
	 @brief Scale the line by a point
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <math/LineT.hpp>
#include <math/Plane.hpp>
#include <modeling/MakeFace.hpp>
#include <modeling/MakeEdge.hpp>
using AMCAX::Line3;
using AMCAX::MakeEdge;
using AMCAX::MakeFace;
#define ONE_RADIAN (M_PI / 180.)
#define SQUARE(x) ((x) * (x))
#include <catch.hpp>
#include <testHelper.h>
#include <math/LineT.hpp>
#include <math/Plane.hpp>
#include <modeling/MakeFace.hpp>
#include <modeling/MakeEdge.hpp>
using AMCAX::Line3;
using AMCAX::MakeEdge;
using AMCAX::MakeFace;
#define ONE_RADIAN (M_PI / 180.)
#define SQUARE(x) ((x) * (x))
;
	SECTION("Scale")
	{
		Line3 line(Point3(), Direction3(0., 1., 0.));
		Point3 point(1., 1., 0.);
		double originalDistance = line.Distance(point);
		Line3 line1 = line.Scaled(point, 1.1);
		CHECK(line1.Distance(point) > originalDistance);
		Line3 line2 = line.Scaled(point, 1.);
		CHECK(line2.Distance(point) == originalDistance);
		Line3 line3 = line.Scaled(point, 0.8);
		CHECK(line3.Distance(point) < originalDistance);
		Line3 line4 = line.Scaled(point, 0.);
		CHECK(line4.Contains(point, 1e-6));
		Line3 line5 = line.Scaled(point, -1.);
		CHECK(line5.Direction().IsEqual(Direction3(0., -1., 0.), 1e-6 * ONE_RADIAN));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] Derived Scaled(const PointT<double, DIM>& point, double scale)	 @return The scaled line
	 @param scale The scale value
	 @param point The scaling center point
	 @brief Get the line scaled by a point
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <math/LineT.hpp>
#include <math/Plane.hpp>
#include <modeling/MakeFace.hpp>
#include <modeling/MakeEdge.hpp>
using AMCAX::Line3;
using AMCAX::MakeEdge;
using AMCAX::MakeFace;
#define ONE_RADIAN (M_PI / 180.)
#define SQUARE(x) ((x) * (x))
#include <catch.hpp>
#include <testHelper.h>
#include <math/LineT.hpp>
#include <math/Plane.hpp>
#include <modeling/MakeFace.hpp>
#include <modeling/MakeEdge.hpp>
using AMCAX::Line3;
using AMCAX::MakeEdge;
using AMCAX::MakeFace;
#define ONE_RADIAN (M_PI / 180.)
#define SQUARE(x) ((x) * (x))
;
	SECTION("Scale")
	{
		Line3 line(Point3(), Direction3(0., 1., 0.));
		Point3 point(1., 1., 0.);
		double originalDistance = line.Distance(point);
		Line3 line1 = line.Scaled(point, 1.1);
		CHECK(line1.Distance(point) > originalDistance);
		Line3 line2 = line.Scaled(point, 1.);
		CHECK(line2.Distance(point) == originalDistance);
		Line3 line3 = line.Scaled(point, 0.8);
		CHECK(line3.Distance(point) < originalDistance);
		Line3 line4 = line.Scaled(point, 0.);
		CHECK(line4.Contains(point, 1e-6));
		Line3 line5 = line.Scaled(point, -1.);
		CHECK(line5.Direction().IsEqual(Direction3(0., -1., 0.), 1e-6 * ONE_RADIAN));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] Derived Transformed(const TransformationT<double, DIM>& tr)	 @return The transformed line
	 @param tr The transformation
	 @brief Get the transformed line
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <math/LineT.hpp>
#include <math/Plane.hpp>
#include <modeling/MakeFace.hpp>
#include <modeling/MakeEdge.hpp>
using AMCAX::Line3;
using AMCAX::MakeEdge;
using AMCAX::MakeFace;
#define ONE_RADIAN (M_PI / 180.)
#define SQUARE(x) ((x) * (x))
#include <catch.hpp>
#include <testHelper.h>
#include <math/LineT.hpp>
#include <math/Plane.hpp>
#include <modeling/MakeFace.hpp>
#include <modeling/MakeEdge.hpp>
using AMCAX::Line3;
using AMCAX::MakeEdge;
using AMCAX::MakeFace;
#define ONE_RADIAN (M_PI / 180.)
#define SQUARE(x) ((x) * (x))
;
	SECTION("Transform")
	{
		Line3 line(Point3(), Direction3(0., 1., 0.));
		Transformation3 translationTransform;
		translationTransform.SetTranslation(Point3(0., 0., 0.), Point3(1., 1., 1.));  
		Line3 translationLine = line.Transformed(translationTransform);
		CHECK(translationLine.Direction().IsEqual(line.Direction(), 1e-6 * ONE_RADIAN));
		CHECK(translationLine.Contains(Point3(1., 1., 1.), 1e-6));
		Transformation3 rotationTransfrom;
		rotationTransfrom.SetRotation(Axis3(Point3(), Direction3(1., 0., 0.)), 90. * ONE_RADIAN);  
		Line3 rotationLine = line.Transformed(rotationTransfrom);
		CHECK(rotationLine.Direction().IsEqual(Direction3(0., 0., 1.), 1e-6 * ONE_RADIAN));
		CHECK(rotationLine.Contains(Point3(0., 0., 3.), 1e-6) == true);
		Transformation3 scaleTransfrom;
		scaleTransfrom.SetScale(Point3(1., 0., 1.), -1.); 
		Line3 scaleLine = line.Transformed(scaleTransfrom);
		CHECK(line.Distance(Point3(1., 0., 1.)) == scaleLine.Distance(Point3(1., 0., 1.)));
		CHECK(scaleLine.Direction().IsEqual(Direction3(0., -1., 0.), 1e-6*ONE_RADIAN));
		Transformation3 mirrorTransfrom;
		mirrorTransfrom.SetMirror(Frame3(Point3(0., 0., 0.), Direction3(1., 0., 0.)));
		Line3 mirrorLine = line.Transformed(mirrorTransfrom);
		CHECK(line.Distance(Point3(0., 0., 0.)) == mirrorLine.Distance(Point3(0., 0., 0.)));
		AMCAX::OCCTIO::OCCTTool::Write(MakeEdge(line), OUTPUT_PATH_PREFIX"Line3_Transform_InitialLine.brep");
		Transformation3 CombinedTransfrom = scaleTransfrom * mirrorTransfrom* translationTransform * rotationTransfrom;  
		line.Transform(CombinedTransfrom);
		AMCAX::OCCTIO::OCCTTool::Write(MakeEdge(line), OUTPUT_PATH_PREFIX"Line3_Transform_transformLine.brep");
		CHECK(line.Contains(Point3(3., -1., 1.), 1e-6) == true);
		CHECK(line.Direction().IsEqual(Direction3(0., 0., -1.), 1e-6 * ONE_RADIAN));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":Derived& Translate(const PointT<double, DIM>& p1, const PointT<double, DIM>& p2)	 @return The reference to self
	 @param p2 The target point
	 @param p1 The source point
	 @brief Translate the line by a vector from a point to another point
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <math/LineT.hpp>
#include <math/Plane.hpp>
#include <modeling/MakeFace.hpp>
#include <modeling/MakeEdge.hpp>
using AMCAX::Line3;
using AMCAX::MakeEdge;
using AMCAX::MakeFace;
#define ONE_RADIAN (M_PI / 180.)
#define SQUARE(x) ((x) * (x))
#include <catch.hpp>
#include <testHelper.h>
#include <math/LineT.hpp>
#include <math/Plane.hpp>
#include <modeling/MakeFace.hpp>
#include <modeling/MakeEdge.hpp>
using AMCAX::Line3;
using AMCAX::MakeEdge;
using AMCAX::MakeFace;
#define ONE_RADIAN (M_PI / 180.)
#define SQUARE(x) ((x) * (x))
;
	SECTION("Translate")
	{
		Line3 line(Point3(), Direction3(1., 1., 1.));
		Line3 originalLine(Point3(), Direction3(1., 1., 1.));
		line.Translate(Point3(), Point3(0., 1., 0.));
		CHECK(originalLine.Direction().IsEqual(line.Direction(), 1e-6 * ONE_RADIAN));
		CHECK(line.Contains(Point3(0., 1., 0.), 1e-6));
		Line3 line2 = line.Translated(Vector3(Direction3(1., -1., 1.)));
		CHECK(line.Direction().IsEqual(line2.Direction(), 1e-6 * ONE_RADIAN));
		CHECK(line2.Contains(Point3(0. + 1. / std::sqrt(3.), 1 - 1. / std::sqrt(3.), 0. + 1. / std::sqrt(3.)), 1e-6));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] Derived Translated(const VectorT<double, DIM>& vec)	 @return The translated line
	 @param vec The translation vector
	 @brief Get the line translated by a vector
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <math/LineT.hpp>
#include <math/Plane.hpp>
#include <modeling/MakeFace.hpp>
#include <modeling/MakeEdge.hpp>
using AMCAX::Line3;
using AMCAX::MakeEdge;
using AMCAX::MakeFace;
#define ONE_RADIAN (M_PI / 180.)
#define SQUARE(x) ((x) * (x))
#include <catch.hpp>
#include <testHelper.h>
#include <math/LineT.hpp>
#include <math/Plane.hpp>
#include <modeling/MakeFace.hpp>
#include <modeling/MakeEdge.hpp>
using AMCAX::Line3;
using AMCAX::MakeEdge;
using AMCAX::MakeFace;
#define ONE_RADIAN (M_PI / 180.)
#define SQUARE(x) ((x) * (x))
;
	SECTION("Translate")
	{
		Line3 line(Point3(), Direction3(1., 1., 1.));
		Line3 originalLine(Point3(), Direction3(1., 1., 1.));
		line.Translate(Point3(), Point3(0., 1., 0.));
		CHECK(originalLine.Direction().IsEqual(line.Direction(), 1e-6 * ONE_RADIAN));
		CHECK(line.Contains(Point3(0., 1., 0.), 1e-6));
		Line3 line2 = line.Translated(Vector3(Direction3(1., -1., 1.)));
		CHECK(line.Direction().IsEqual(line2.Direction(), 1e-6 * ONE_RADIAN));
		CHECK(line2.Contains(Point3(0. + 1. / std::sqrt(3.), 1 - 1. / std::sqrt(3.), 0. + 1. / std::sqrt(3.)), 1e-6));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] Derived Translated(const PointT<double, DIM>& p1, const PointT<double, DIM>& p2)	 @return The translated line
	 @param p2 The target point
	 @param p1 The source point
	 @brief Get the line translated by a vector from a point to another point
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <math/LineT.hpp>
#include <math/Plane.hpp>
#include <modeling/MakeFace.hpp>
#include <modeling/MakeEdge.hpp>
using AMCAX::Line3;
using AMCAX::MakeEdge;
using AMCAX::MakeFace;
#define ONE_RADIAN (M_PI / 180.)
#define SQUARE(x) ((x) * (x))
#include <catch.hpp>
#include <testHelper.h>
#include <math/LineT.hpp>
#include <math/Plane.hpp>
#include <modeling/MakeFace.hpp>
#include <modeling/MakeEdge.hpp>
using AMCAX::Line3;
using AMCAX::MakeEdge;
using AMCAX::MakeFace;
#define ONE_RADIAN (M_PI / 180.)
#define SQUARE(x) ((x) * (x))
;
	SECTION("Translate")
	{
		Line3 line(Point3(), Direction3(1., 1., 1.));
		Line3 originalLine(Point3(), Direction3(1., 1., 1.));
		line.Translate(Point3(), Point3(0., 1., 0.));
		CHECK(originalLine.Direction().IsEqual(line.Direction(), 1e-6 * ONE_RADIAN));
		CHECK(line.Contains(Point3(0., 1., 0.), 1e-6));
		Line3 line2 = line.Translated(Vector3(Direction3(1., -1., 1.)));
		CHECK(line.Direction().IsEqual(line2.Direction(), 1e-6 * ONE_RADIAN));
		CHECK(line2.Contains(Point3(0. + 1. / std::sqrt(3.), 1 - 1. / std::sqrt(3.), 0. + 1. / std::sqrt(3.)), 1e-6));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":void SetLocation(const PointT<double, DIM>& point)	 @param point The location point
	 @brief Set the location of the line
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <math/LineT.hpp>
#include <math/Plane.hpp>
#include <modeling/MakeFace.hpp>
#include <modeling/MakeEdge.hpp>
using AMCAX::Line3;
using AMCAX::MakeEdge;
using AMCAX::MakeFace;
#define ONE_RADIAN (M_PI / 180.)
#define SQUARE(x) ((x) * (x))
#include <catch.hpp>
#include <testHelper.h>
#include <math/LineT.hpp>
#include <math/Plane.hpp>
#include <modeling/MakeFace.hpp>
#include <modeling/MakeEdge.hpp>
using AMCAX::Line3;
using AMCAX::MakeEdge;
using AMCAX::MakeFace;
#define ONE_RADIAN (M_PI / 180.)
#define SQUARE(x) ((x) * (x))
;
	SECTION("SetLocation")
	{
		Line3 line(Point3(2., 3., 2.), Direction3(2., 3.4, -2.));
		line.SetLocation(Point3(1., -2., 8.));
		CHECK(line.Location().IsEqual(Point3(1., -2., 8.), std::numeric_limits<double>::min()));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":void SetDirection(const DirectionT<double, DIM>& dir)	 @param dir The line direction
	 @brief Set the line direction
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <math/LineT.hpp>
#include <math/Plane.hpp>
#include <modeling/MakeFace.hpp>
#include <modeling/MakeEdge.hpp>
using AMCAX::Line3;
using AMCAX::MakeEdge;
using AMCAX::MakeFace;
#define ONE_RADIAN (M_PI / 180.)
#define SQUARE(x) ((x) * (x))
#include <catch.hpp>
#include <testHelper.h>
#include <math/LineT.hpp>
#include <math/Plane.hpp>
#include <modeling/MakeFace.hpp>
#include <modeling/MakeEdge.hpp>
using AMCAX::Line3;
using AMCAX::MakeEdge;
using AMCAX::MakeFace;
#define ONE_RADIAN (M_PI / 180.)
#define SQUARE(x) ((x) * (x))
;
	SECTION("SetDirection")
	{
		Direction3 dir(1., 1., 1.);
		Line3 line;
		line.SetDirection(dir);
		CHECK(line.Direction().IsEqual(dir, std::numeric_limits<double>::min()));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":void SetPosition(const AxisT<double, DIM>& axis)	 @param axis The axis
	 @brief Set the axis of the line
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <math/LineT.hpp>
#include <math/Plane.hpp>
#include <modeling/MakeFace.hpp>
#include <modeling/MakeEdge.hpp>
using AMCAX::Line3;
using AMCAX::MakeEdge;
using AMCAX::MakeFace;
#define ONE_RADIAN (M_PI / 180.)
#define SQUARE(x) ((x) * (x))
#include <catch.hpp>
#include <testHelper.h>
#include <math/LineT.hpp>
#include <math/Plane.hpp>
#include <modeling/MakeFace.hpp>
#include <modeling/MakeEdge.hpp>
using AMCAX::Line3;
using AMCAX::MakeEdge;
using AMCAX::MakeFace;
#define ONE_RADIAN (M_PI / 180.)
#define SQUARE(x) ((x) * (x))
;
	SECTION("SetPosition")
	{
		Axis3 axis(Point3(0.1, -2.3, 0.3), Direction3(1.2, -8.9, 3.));
		Line3 line;
		line.SetPosition(axis);
		CHECK(line.Location().IsEqual(axis.Location(), std::numeric_limits<double>::min()));
		CHECK(line.Direction().IsEqual(axis.Direction(), std::numeric_limits<double>::min()));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] const DirectionT<double, DIM>& Direction()	 @return The direction of the line
	 @brief Get the direction of the line
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <math/LineT.hpp>
#include <math/Plane.hpp>
#include <modeling/MakeFace.hpp>
#include <modeling/MakeEdge.hpp>
using AMCAX::Line3;
using AMCAX::MakeEdge;
using AMCAX::MakeFace;
#define ONE_RADIAN (M_PI / 180.)
#define SQUARE(x) ((x) * (x))
#include <catch.hpp>
#include <testHelper.h>
#include <math/LineT.hpp>
#include <math/Plane.hpp>
#include <modeling/MakeFace.hpp>
#include <modeling/MakeEdge.hpp>
using AMCAX::Line3;
using AMCAX::MakeEdge;
using AMCAX::MakeFace;
#define ONE_RADIAN (M_PI / 180.)
#define SQUARE(x) ((x) * (x))
;
	SECTION("constructor")
	{
		Line3 line;  
		CHECK(line.Location().IsEqual(Point3(0., 0., 0.), 1e-5));
		CHECK(line.Direction().IsEqual(Direction3(0., 0., 1.), 1e-5 * ONE_RADIAN));
		Axis3 axis(Point3(1., 1., 1.), Direction3(3., 3., 4.));
		Line3 line2(axis);
		CHECK(line2.Position().IsCoaxial(axis, 1e-5 * ONE_RADIAN, 1e-5));  
		Line3 line3(Point3(1., 2., 3.), Direction3(3., 2., 1.));
		CHECK(line3.Location().IsEqual(Point3(1., 2., 3.), 1e-5));
		CHECK(line3.Direction().IsEqual(Direction3(3., 2., 1.), 1e-5 * ONE_RADIAN));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] const AxisT<double, DIM>& Position()	 @return The axis of the line
	 @brief Get the axis of the line
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <math/LineT.hpp>
#include <math/Plane.hpp>
#include <modeling/MakeFace.hpp>
#include <modeling/MakeEdge.hpp>
using AMCAX::Line3;
using AMCAX::MakeEdge;
using AMCAX::MakeFace;
#define ONE_RADIAN (M_PI / 180.)
#define SQUARE(x) ((x) * (x))
#include <catch.hpp>
#include <testHelper.h>
#include <math/LineT.hpp>
#include <math/Plane.hpp>
#include <modeling/MakeFace.hpp>
#include <modeling/MakeEdge.hpp>
using AMCAX::Line3;
using AMCAX::MakeEdge;
using AMCAX::MakeFace;
#define ONE_RADIAN (M_PI / 180.)
#define SQUARE(x) ((x) * (x))
;
	SECTION("constructor")
	{
		Line3 line;  
		CHECK(line.Location().IsEqual(Point3(0., 0., 0.), 1e-5));
		CHECK(line.Direction().IsEqual(Direction3(0., 0., 1.), 1e-5 * ONE_RADIAN));
		Axis3 axis(Point3(1., 1., 1.), Direction3(3., 3., 4.));
		Line3 line2(axis);
		CHECK(line2.Position().IsCoaxial(axis, 1e-5 * ONE_RADIAN, 1e-5));  
		Line3 line3(Point3(1., 2., 3.), Direction3(3., 2., 1.));
		CHECK(line3.Location().IsEqual(Point3(1., 2., 3.), 1e-5));
		CHECK(line3.Direction().IsEqual(Direction3(3., 2., 1.), 1e-5 * ONE_RADIAN));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] auto Angle(const LineBase& other)	 @return The angle between the line and the other line
	 @param other The other line
	 @brief Compute the angle between the line and the other line
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <math/LineT.hpp>
#include <math/Plane.hpp>
#include <modeling/MakeFace.hpp>
#include <modeling/MakeEdge.hpp>
using AMCAX::Line3;
using AMCAX::MakeEdge;
using AMCAX::MakeFace;
#define ONE_RADIAN (M_PI / 180.)
#define SQUARE(x) ((x) * (x))
#include <catch.hpp>
#include <testHelper.h>
#include <math/LineT.hpp>
#include <math/Plane.hpp>
#include <modeling/MakeFace.hpp>
#include <modeling/MakeEdge.hpp>
using AMCAX::Line3;
using AMCAX::MakeEdge;
using AMCAX::MakeFace;
#define ONE_RADIAN (M_PI / 180.)
#define SQUARE(x) ((x) * (x))
;
	SECTION("Angle")
	{
		Line3 line(Point3(0., 1., 0.), Direction3(1., 1., 1.));
		Line3 line2(Point3(0., 3.4, 0.), Direction3(2., -1., -1.5));
		CHECK(line.Angle(line2) == Approx(std::acos(line.Direction().Dot(line2.Direction()))).margin(1e-6 * ONE_RADIAN));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] Derived Reversed()	 @return The line with reversed direction
	 @brief Get the line with reversed direction
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <math/LineT.hpp>
#include <math/Plane.hpp>
#include <modeling/MakeFace.hpp>
#include <modeling/MakeEdge.hpp>
using AMCAX::Line3;
using AMCAX::MakeEdge;
using AMCAX::MakeFace;
#define ONE_RADIAN (M_PI / 180.)
#define SQUARE(x) ((x) * (x))
#include <catch.hpp>
#include <testHelper.h>
#include <math/LineT.hpp>
#include <math/Plane.hpp>
#include <modeling/MakeFace.hpp>
#include <modeling/MakeEdge.hpp>
using AMCAX::Line3;
using AMCAX::MakeEdge;
using AMCAX::MakeFace;
#define ONE_RADIAN (M_PI / 180.)
#define SQUARE(x) ((x) * (x))
;
	SECTION("Reverse")
	{
		Line3 line(Point3(), Direction3(1., 1., 1.));
		Line3 reverseLine = line.Reversed();
		CHECK(reverseLine.Direction().IsEqual(Direction3(-1., -1., -1.), 1e-6 * ONE_RADIAN));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] auto Distance(const Point2& p)	 @return The distance between the point and the line
	 @param p The point
	 @brief Compute the distance from a point to the line
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <math/LineT.hpp>
#include <math/Plane.hpp>
#include <modeling/MakeFace.hpp>
#include <modeling/MakeEdge.hpp>
using AMCAX::Line3;
using AMCAX::MakeEdge;
using AMCAX::MakeFace;
#define ONE_RADIAN (M_PI / 180.)
#define SQUARE(x) ((x) * (x))
#include <catch.hpp>
#include <testHelper.h>
#include <math/LineT.hpp>
#include <math/Plane.hpp>
#include <modeling/MakeFace.hpp>
#include <modeling/MakeEdge.hpp>
using AMCAX::Line3;
using AMCAX::MakeEdge;
using AMCAX::MakeFace;
#define ONE_RADIAN (M_PI / 180.)
#define SQUARE(x) ((x) * (x))
;
	SECTION("Transform")
	{
		Line3 line(Point3(), Direction3(0., 1., 0.));
		Transformation3 translationTransform;
		translationTransform.SetTranslation(Point3(0., 0., 0.), Point3(1., 1., 1.));  
		Line3 translationLine = line.Transformed(translationTransform);
		CHECK(translationLine.Direction().IsEqual(line.Direction(), 1e-6 * ONE_RADIAN));
		CHECK(translationLine.Contains(Point3(1., 1., 1.), 1e-6));
		Transformation3 rotationTransfrom;
		rotationTransfrom.SetRotation(Axis3(Point3(), Direction3(1., 0., 0.)), 90. * ONE_RADIAN);  
		Line3 rotationLine = line.Transformed(rotationTransfrom);
		CHECK(rotationLine.Direction().IsEqual(Direction3(0., 0., 1.), 1e-6 * ONE_RADIAN));
		CHECK(rotationLine.Contains(Point3(0., 0., 3.), 1e-6) == true);
		Transformation3 scaleTransfrom;
		scaleTransfrom.SetScale(Point3(1., 0., 1.), -1.); 
		Line3 scaleLine = line.Transformed(scaleTransfrom);
		CHECK(line.Distance(Point3(1., 0., 1.)) == scaleLine.Distance(Point3(1., 0., 1.)));
		CHECK(scaleLine.Direction().IsEqual(Direction3(0., -1., 0.), 1e-6*ONE_RADIAN));
		Transformation3 mirrorTransfrom;
		mirrorTransfrom.SetMirror(Frame3(Point3(0., 0., 0.), Direction3(1., 0., 0.)));
		Line3 mirrorLine = line.Transformed(mirrorTransfrom);
		CHECK(line.Distance(Point3(0., 0., 0.)) == mirrorLine.Distance(Point3(0., 0., 0.)));
		AMCAX::OCCTIO::OCCTTool::Write(MakeEdge(line), OUTPUT_PATH_PREFIX"Line3_Transform_InitialLine.brep");
		Transformation3 CombinedTransfrom = scaleTransfrom * mirrorTransfrom* translationTransform * rotationTransfrom;  
		line.Transform(CombinedTransfrom);
		AMCAX::OCCTIO::OCCTTool::Write(MakeEdge(line), OUTPUT_PATH_PREFIX"Line3_Transform_transformLine.brep");
		CHECK(line.Contains(Point3(3., -1., 1.), 1e-6) == true);
		CHECK(line.Direction().IsEqual(Direction3(0., 0., -1.), 1e-6 * ONE_RADIAN));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] auto Distance(const LineS& l)	 @return The distance between two lines
	 @param l The other line
	 @brief Compute the distance between two lines
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <math/LineT.hpp>
#include <math/Plane.hpp>
#include <modeling/MakeFace.hpp>
#include <modeling/MakeEdge.hpp>
using AMCAX::Line3;
using AMCAX::MakeEdge;
using AMCAX::MakeFace;
#define ONE_RADIAN (M_PI / 180.)
#define SQUARE(x) ((x) * (x))
#include <catch.hpp>
#include <testHelper.h>
#include <math/LineT.hpp>
#include <math/Plane.hpp>
#include <modeling/MakeFace.hpp>
#include <modeling/MakeEdge.hpp>
using AMCAX::Line3;
using AMCAX::MakeEdge;
using AMCAX::MakeFace;
#define ONE_RADIAN (M_PI / 180.)
#define SQUARE(x) ((x) * (x))
;
	SECTION("Distance and SquaredDistance")
	{
		auto pointToLine = [](const Point3& p, const Line3& line) {
			const Point3& p1 = line.Location();
			double dX = p1.X() - p.X();
			double dY = p1.Y() - p.Y();
			double dZ = p1.Z() - p.Z();
			double pp1Square = SQUARE(dX) + SQUARE(dY) + SQUARE(dZ);
			Direction3 dir(dX, dY, dZ);
			double cos = std::fabs(dir.Dot(line.Direction()));
			return std::sqrt(pp1Square - SQUARE(cos*std::sqrt(pp1Square)));
		};
		auto lineToLine = [&pointToLine](const Line3& line1, const Line3& line2) {
			if (line1.Direction().IsParallel(line2.Direction(), std::numeric_limits<double>::min()))
				return pointToLine(line1.Location(), line2);
			Direction3 line1Dir = line1.Direction();
			Direction3 line2Dir = line2.Direction();
			double x3 = line1Dir.Y() * line2Dir.Z() - line2Dir.Y() * line1Dir.Z();
			double y3 = -(line1Dir.X() * line2Dir.Z() - line2Dir.X() * line1Dir.Z());
			double z3 = line1Dir.X() * line2Dir.Y() - line2Dir.X() * line1Dir.Y();
			Direction3 line3Dir(x3, y3, z3);
			Direction3 line12Dir(line1.Location().X() - line2.Location().X(), 
								 line1.Location().Y() - line2.Location().Y(), line1.Location().Z() - line2.Location().Z());
			return std::fabs(line3Dir.Dot(line12Dir));
		};
		Line3 line(Point3(99., 2., 33.), Direction3(2.3, 4.6, 9.8));
		CHECK(line.Distance(Point3(0., 1., 0.)) == Approx(pointToLine(Point3(0., 1., 0.), line)).margin(1e-5));
		Line3 line2(Point3(0., 0., 0.), Direction3(1., 0., 0.));
		Line3 line3(Point3(0., 1., 0.), Direction3(1., 0., 0.));
		CHECK(line2.Distance(line3) == Approx(lineToLine(line2, line3)).margin(std::numeric_limits<double>::min()));
		CHECK(line2.SquaredDistance(line3) == Approx(SQUARE(lineToLine(line2, line3))).margin(std::numeric_limits<double>::min()));
		Line3 line4(Point3(0., 0., 0.), Direction3(1., 0., 0.));
		Line3 line5(Point3(0., 1., 0.), Direction3(1., 1., 0.));
		CHECK(line4.Distance(line5) == Approx(lineToLine(line4, line5)).margin(std::numeric_limits<double>::min()));
		Line3 line6(Point3(0., 0., 0.), Direction3(0., 0., 1.));
		Line3 line7(Point3(0., 1., 0.), Direction3(1., 1., 0.));
		CHECK(line6.Distance(line7) == Approx(lineToLine(line6, line7)).margin(std::numeric_limits<double>::min()));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] auto SquaredDistance(const LineS& l)	 @return The squared distance between two lines
	 @param l The other line
	 @brief Compute the squared distance between two lines
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <math/LineT.hpp>
#include <math/Plane.hpp>
#include <modeling/MakeFace.hpp>
#include <modeling/MakeEdge.hpp>
using AMCAX::Line3;
using AMCAX::MakeEdge;
using AMCAX::MakeFace;
#define ONE_RADIAN (M_PI / 180.)
#define SQUARE(x) ((x) * (x))
#include <catch.hpp>
#include <testHelper.h>
#include <math/LineT.hpp>
#include <math/Plane.hpp>
#include <modeling/MakeFace.hpp>
#include <modeling/MakeEdge.hpp>
using AMCAX::Line3;
using AMCAX::MakeEdge;
using AMCAX::MakeFace;
#define ONE_RADIAN (M_PI / 180.)
#define SQUARE(x) ((x) * (x))
;
	SECTION("Distance and SquaredDistance")
	{
		auto pointToLine = [](const Point3& p, const Line3& line) {
			const Point3& p1 = line.Location();
			double dX = p1.X() - p.X();
			double dY = p1.Y() - p.Y();
			double dZ = p1.Z() - p.Z();
			double pp1Square = SQUARE(dX) + SQUARE(dY) + SQUARE(dZ);
			Direction3 dir(dX, dY, dZ);
			double cos = std::fabs(dir.Dot(line.Direction()));
			return std::sqrt(pp1Square - SQUARE(cos*std::sqrt(pp1Square)));
		};
		auto lineToLine = [&pointToLine](const Line3& line1, const Line3& line2) {
			if (line1.Direction().IsParallel(line2.Direction(), std::numeric_limits<double>::min()))
				return pointToLine(line1.Location(), line2);
			Direction3 line1Dir = line1.Direction();
			Direction3 line2Dir = line2.Direction();
			double x3 = line1Dir.Y() * line2Dir.Z() - line2Dir.Y() * line1Dir.Z();
			double y3 = -(line1Dir.X() * line2Dir.Z() - line2Dir.X() * line1Dir.Z());
			double z3 = line1Dir.X() * line2Dir.Y() - line2Dir.X() * line1Dir.Y();
			Direction3 line3Dir(x3, y3, z3);
			Direction3 line12Dir(line1.Location().X() - line2.Location().X(), 
								 line1.Location().Y() - line2.Location().Y(), line1.Location().Z() - line2.Location().Z());
			return std::fabs(line3Dir.Dot(line12Dir));
		};
		Line3 line(Point3(99., 2., 33.), Direction3(2.3, 4.6, 9.8));
		CHECK(line.Distance(Point3(0., 1., 0.)) == Approx(pointToLine(Point3(0., 1., 0.), line)).margin(1e-5));
		Line3 line2(Point3(0., 0., 0.), Direction3(1., 0., 0.));
		Line3 line3(Point3(0., 1., 0.), Direction3(1., 0., 0.));
		CHECK(line2.Distance(line3) == Approx(lineToLine(line2, line3)).margin(std::numeric_limits<double>::min()));
		CHECK(line2.SquaredDistance(line3) == Approx(SQUARE(lineToLine(line2, line3))).margin(std::numeric_limits<double>::min()));
		Line3 line4(Point3(0., 0., 0.), Direction3(1., 0., 0.));
		Line3 line5(Point3(0., 1., 0.), Direction3(1., 1., 0.));
		CHECK(line4.Distance(line5) == Approx(lineToLine(line4, line5)).margin(std::numeric_limits<double>::min()));
		Line3 line6(Point3(0., 0., 0.), Direction3(0., 0., 1.));
		Line3 line7(Point3(0., 1., 0.), Direction3(1., 1., 0.));
		CHECK(line6.Distance(line7) == Approx(lineToLine(line6, line7)).margin(std::numeric_limits<double>::min()));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] LineS Normal(const Point2& p)	 @return The line passing through a point and perpendicular to the line
	 @param p The point
	 @brief Get a line passing through a point and perpendicular to the line
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <math/LineT.hpp>
#include <math/Plane.hpp>
#include <modeling/MakeFace.hpp>
#include <modeling/MakeEdge.hpp>
using AMCAX::Line3;
using AMCAX::MakeEdge;
using AMCAX::MakeFace;
#define ONE_RADIAN (M_PI / 180.)
#define SQUARE(x) ((x) * (x))
#include <catch.hpp>
#include <testHelper.h>
#include <math/LineT.hpp>
#include <math/Plane.hpp>
#include <modeling/MakeFace.hpp>
#include <modeling/MakeEdge.hpp>
using AMCAX::Line3;
using AMCAX::MakeEdge;
using AMCAX::MakeFace;
#define ONE_RADIAN (M_PI / 180.)
#define SQUARE(x) ((x) * (x))
;
	SECTION("Normal")
	{
		Line3 line(Point3(94., 32., 4.8), Direction3(2.65, 3.28, 5.14));
		Line3 line2 = line.Normal(Point3(2.1, 3.4, 11.2));
		CHECK(line.Direction().Dot(line2.Direction()) == Approx(0.).margin(1e-6));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] auto Distance(const Point3& p)	 @return The distance between the point and the line
	 @param p The point
	 @brief Compute the distance from a point to the line
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <math/LineT.hpp>
#include <math/Plane.hpp>
#include <modeling/MakeFace.hpp>
#include <modeling/MakeEdge.hpp>
using AMCAX::Line3;
using AMCAX::MakeEdge;
using AMCAX::MakeFace;
#define ONE_RADIAN (M_PI / 180.)
#define SQUARE(x) ((x) * (x))
#include <catch.hpp>
#include <testHelper.h>
#include <math/LineT.hpp>
#include <math/Plane.hpp>
#include <modeling/MakeFace.hpp>
#include <modeling/MakeEdge.hpp>
using AMCAX::Line3;
using AMCAX::MakeEdge;
using AMCAX::MakeFace;
#define ONE_RADIAN (M_PI / 180.)
#define SQUARE(x) ((x) * (x))
;
	SECTION("Mirror")
	{
		Line3 line(Point3(1.0, 2.0, 3.0), Direction3(1.0, 0.0, 0.0));
		Line3 originalLine(Point3(1.0, 2.0, 3.0), Direction3(1.0, 0.0, 0.0));
		Frame3 frame(Point3(0.0, 0.0, 0.0), Direction3(0.0, 1.0, 0.0));
		line.Mirror(frame);
		CHECK(line.Distance(Point3(0.0, 0.0, 0.0)) == Approx(originalLine.Distance(Point3(0., 0., 0.))).margin(std::numeric_limits<double>::min()));
		Direction3 dir(originalLine.Location().X() - line.Location().X(),
					   originalLine.Location().Y() - line.Location().Y(),
					   originalLine.Location().Z() - line.Location().Z());
		CHECK(dir.IsParallel(Direction3(0.0, 1.0, 0.0), 1e-5 * ONE_RADIAN));
		Line3 line2(Point3(1.2, -4.6, 2.3), Direction3(1.8, 97.4, -12.8));
		Frame3 frame2(Point3(87.0, 2.3, 10.14), Direction3(-92.3, 2.6, 1.0));
		Line3 mirrorLine2 = line2.Mirrored(frame2);
		CHECK(line2.Distance(Point3(87.0, 2.3, 10.14)) == Approx(mirrorLine2.Distance(Point3(87.0, 2.3, 10.14))).margin(std::numeric_limits<double>::min()));
		Direction3 dir2(line2.Location().X() - mirrorLine2.Location().X(),
					    line2.Location().Y() - mirrorLine2.Location().Y(),
					    line2.Location().Z() - mirrorLine2.Location().Z());
		CHECK(dir2.IsParallel(Direction3(-92.3, 2.6, 1.0), 1e-5 * ONE_RADIAN));
		TopoFace face = MakeFace(Plane(frame2), 0., 4., 0., 4.);
		TopoEdge edgeLine2 = MakeEdge(line2, 0., 1.);
		TopoEdge edgeMirrorLine2 = MakeEdge(mirrorLine2, 0., 1.);
		AMCAX::OCCTIO::OCCTTool::Write(face, OUTPUT_PATH_PREFIX"Line3_Mirror_face2.brep");
		AMCAX::OCCTIO::OCCTTool::Write(edgeLine2, OUTPUT_PATH_PREFIX"Line3_Mirror_edge.brep");
		AMCAX::OCCTIO::OCCTTool::Write(edgeMirrorLine2, OUTPUT_PATH_PREFIX"Line3_Mirror_Mirroredge.brep");
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] LineS Normal(const Point3& p)	 @return The line passing through a point and perpendicular to the line
	 @param p The point
	 @brief Get a line passing through a point and perpendicular to the line
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <math/LineT.hpp>
#include <math/Plane.hpp>
#include <modeling/MakeFace.hpp>
#include <modeling/MakeEdge.hpp>
using AMCAX::Line3;
using AMCAX::MakeEdge;
using AMCAX::MakeFace;
#define ONE_RADIAN (M_PI / 180.)
#define SQUARE(x) ((x) * (x))
#include <catch.hpp>
#include <testHelper.h>
#include <math/LineT.hpp>
#include <math/Plane.hpp>
#include <modeling/MakeFace.hpp>
#include <modeling/MakeEdge.hpp>
using AMCAX::Line3;
using AMCAX::MakeEdge;
using AMCAX::MakeFace;
#define ONE_RADIAN (M_PI / 180.)
#define SQUARE(x) ((x) * (x))
;
	SECTION("Normal")
	{
		Line3 line(Point3(94., 32., 4.8), Direction3(2.65, 3.28, 5.14));
		Line3 line2 = line.Normal(Point3(2.1, 3.4, 11.2));
		CHECK(line.Direction().Dot(line2.Direction()) == Approx(0.).margin(1e-6));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":LineS& Mirror(const Frame3& frame)	 @return The reference to self
	 @param frame The mirror frame
	 @brief Mirror the line by a frame
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <math/LineT.hpp>
#include <math/Plane.hpp>
#include <modeling/MakeFace.hpp>
#include <modeling/MakeEdge.hpp>
using AMCAX::Line3;
using AMCAX::MakeEdge;
using AMCAX::MakeFace;
#define ONE_RADIAN (M_PI / 180.)
#define SQUARE(x) ((x) * (x))
#include <catch.hpp>
#include <testHelper.h>
#include <math/LineT.hpp>
#include <math/Plane.hpp>
#include <modeling/MakeFace.hpp>
#include <modeling/MakeEdge.hpp>
using AMCAX::Line3;
using AMCAX::MakeEdge;
using AMCAX::MakeFace;
#define ONE_RADIAN (M_PI / 180.)
#define SQUARE(x) ((x) * (x))
;
	SECTION("Mirror")
	{
		Line3 line(Point3(1.0, 2.0, 3.0), Direction3(1.0, 0.0, 0.0));
		Line3 originalLine(Point3(1.0, 2.0, 3.0), Direction3(1.0, 0.0, 0.0));
		Frame3 frame(Point3(0.0, 0.0, 0.0), Direction3(0.0, 1.0, 0.0));
		line.Mirror(frame);
		CHECK(line.Distance(Point3(0.0, 0.0, 0.0)) == Approx(originalLine.Distance(Point3(0., 0., 0.))).margin(std::numeric_limits<double>::min()));
		Direction3 dir(originalLine.Location().X() - line.Location().X(),
					   originalLine.Location().Y() - line.Location().Y(),
					   originalLine.Location().Z() - line.Location().Z());
		CHECK(dir.IsParallel(Direction3(0.0, 1.0, 0.0), 1e-5 * ONE_RADIAN));
		Line3 line2(Point3(1.2, -4.6, 2.3), Direction3(1.8, 97.4, -12.8));
		Frame3 frame2(Point3(87.0, 2.3, 10.14), Direction3(-92.3, 2.6, 1.0));
		Line3 mirrorLine2 = line2.Mirrored(frame2);
		CHECK(line2.Distance(Point3(87.0, 2.3, 10.14)) == Approx(mirrorLine2.Distance(Point3(87.0, 2.3, 10.14))).margin(std::numeric_limits<double>::min()));
		Direction3 dir2(line2.Location().X() - mirrorLine2.Location().X(),
					    line2.Location().Y() - mirrorLine2.Location().Y(),
					    line2.Location().Z() - mirrorLine2.Location().Z());
		CHECK(dir2.IsParallel(Direction3(-92.3, 2.6, 1.0), 1e-5 * ONE_RADIAN));
		TopoFace face = MakeFace(Plane(frame2), 0., 4., 0., 4.);
		TopoEdge edgeLine2 = MakeEdge(line2, 0., 1.);
		TopoEdge edgeMirrorLine2 = MakeEdge(mirrorLine2, 0., 1.);
		AMCAX::OCCTIO::OCCTTool::Write(face, OUTPUT_PATH_PREFIX"Line3_Mirror_face2.brep");
		AMCAX::OCCTIO::OCCTTool::Write(edgeLine2, OUTPUT_PATH_PREFIX"Line3_Mirror_edge.brep");
		AMCAX::OCCTIO::OCCTTool::Write(edgeMirrorLine2, OUTPUT_PATH_PREFIX"Line3_Mirror_Mirroredge.brep");
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] LineS Mirrored(const Frame3& frame)	 @return The mirrored line
	 @param frame The mirror frame
	 @brief Get the line mirrored by a frame
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <math/LineT.hpp>
#include <math/Plane.hpp>
#include <modeling/MakeFace.hpp>
#include <modeling/MakeEdge.hpp>
using AMCAX::Line3;
using AMCAX::MakeEdge;
using AMCAX::MakeFace;
#define ONE_RADIAN (M_PI / 180.)
#define SQUARE(x) ((x) * (x))
#include <catch.hpp>
#include <testHelper.h>
#include <math/LineT.hpp>
#include <math/Plane.hpp>
#include <modeling/MakeFace.hpp>
#include <modeling/MakeEdge.hpp>
using AMCAX::Line3;
using AMCAX::MakeEdge;
using AMCAX::MakeFace;
#define ONE_RADIAN (M_PI / 180.)
#define SQUARE(x) ((x) * (x))
;
	SECTION("Mirror")
	{
		Line3 line(Point3(1.0, 2.0, 3.0), Direction3(1.0, 0.0, 0.0));
		Line3 originalLine(Point3(1.0, 2.0, 3.0), Direction3(1.0, 0.0, 0.0));
		Frame3 frame(Point3(0.0, 0.0, 0.0), Direction3(0.0, 1.0, 0.0));
		line.Mirror(frame);
		CHECK(line.Distance(Point3(0.0, 0.0, 0.0)) == Approx(originalLine.Distance(Point3(0., 0., 0.))).margin(std::numeric_limits<double>::min()));
		Direction3 dir(originalLine.Location().X() - line.Location().X(),
					   originalLine.Location().Y() - line.Location().Y(),
					   originalLine.Location().Z() - line.Location().Z());
		CHECK(dir.IsParallel(Direction3(0.0, 1.0, 0.0), 1e-5 * ONE_RADIAN));
		Line3 line2(Point3(1.2, -4.6, 2.3), Direction3(1.8, 97.4, -12.8));
		Frame3 frame2(Point3(87.0, 2.3, 10.14), Direction3(-92.3, 2.6, 1.0));
		Line3 mirrorLine2 = line2.Mirrored(frame2);
		CHECK(line2.Distance(Point3(87.0, 2.3, 10.14)) == Approx(mirrorLine2.Distance(Point3(87.0, 2.3, 10.14))).margin(std::numeric_limits<double>::min()));
		Direction3 dir2(line2.Location().X() - mirrorLine2.Location().X(),
					    line2.Location().Y() - mirrorLine2.Location().Y(),
					    line2.Location().Z() - mirrorLine2.Location().Z());
		CHECK(dir2.IsParallel(Direction3(-92.3, 2.6, 1.0), 1e-5 * ONE_RADIAN));
		TopoFace face = MakeFace(Plane(frame2), 0., 4., 0., 4.);
		TopoEdge edgeLine2 = MakeEdge(line2, 0., 1.);
		TopoEdge edgeMirrorLine2 = MakeEdge(mirrorLine2, 0., 1.);
		AMCAX::OCCTIO::OCCTTool::Write(face, OUTPUT_PATH_PREFIX"Line3_Mirror_face2.brep");
		AMCAX::OCCTIO::OCCTTool::Write(edgeLine2, OUTPUT_PATH_PREFIX"Line3_Mirror_edge.brep");
		AMCAX::OCCTIO::OCCTTool::Write(edgeMirrorLine2, OUTPUT_PATH_PREFIX"Line3_Mirror_Mirroredge.brep");
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] LineS Rotated(const Axis3& axis, double angle)	 @return The rotated line
	 @param angle The rotation angle
	 @param axis The rotation axis
	 @brief Get the line rotated around an axis with an angle in 3D
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <math/LineT.hpp>
#include <math/Plane.hpp>
#include <modeling/MakeFace.hpp>
#include <modeling/MakeEdge.hpp>
using AMCAX::Line3;
using AMCAX::MakeEdge;
using AMCAX::MakeFace;
#define ONE_RADIAN (M_PI / 180.)
#define SQUARE(x) ((x) * (x))
#include <catch.hpp>
#include <testHelper.h>
#include <math/LineT.hpp>
#include <math/Plane.hpp>
#include <modeling/MakeFace.hpp>
#include <modeling/MakeEdge.hpp>
using AMCAX::Line3;
using AMCAX::MakeEdge;
using AMCAX::MakeFace;
#define ONE_RADIAN (M_PI / 180.)
#define SQUARE(x) ((x) * (x))
;
	SECTION("Rotate")
	{
		Axis3 axis(Point3(0., 0., 0.), Direction3(0., 1., 0.));
		Line3 line(Point3(0., 0., 0.), Direction3(1., 1., -1.));
		Line3 rotateLine = line.Rotated(axis, 90. * ONE_RADIAN);  
		TopoEdge edge1 = MakeEdge(line);
		TopoEdge edge2 = MakeEdge(rotateLine);
		TopoEdge edge3 = MakeEdge(Line3(axis));
		bool isWriteSuccess1 = AMCAX::OCCTIO::OCCTTool::Write(edge1, OUTPUT_PATH_PREFIX"Line3_Rotate_line.brep");
		bool isWriteSuccess2 = AMCAX::OCCTIO::OCCTTool::Write(edge2, OUTPUT_PATH_PREFIX"Line3_Rotate_lineRotate.brep");
		bool isWriteSuccess3 = AMCAX::OCCTIO::OCCTTool::Write(edge3, OUTPUT_PATH_PREFIX"Line3_Rotate_axis.brep");
		REQUIRE(isWriteSuccess1);
		REQUIRE(isWriteSuccess2);
		REQUIRE(isWriteSuccess3);
		auto pointToPoint = [](const Point3& p1, const Point3& p2) {
			return std::sqrt(
				SQUARE(p1.X() - p2.X()) +
				SQUARE(p1.Y() - p2.Y()) +
				SQUARE(p1.Z() - p2.Z())
			);
		};
		CHECK(line.Distance(Line3(axis)) == Approx(rotateLine.Distance(Line3(axis))).margin(std::numeric_limits<double>::min()));
		CHECK(pointToPoint(line.Location(), Point3()) == Approx(pointToPoint(rotateLine.Location(), Point3())).margin(std::numeric_limits<double>::min()));
		Point3 p(-1., 1., -1.);
		CHECK(rotateLine.Contains(p, 1e-6) == true);
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API Classifier2d(const std::vector<Point2>& pts, double tolU, double tolV, double uMin, double vMin, double uMax, double vMax)	 @param vMax The upper bound of v
	 @param uMax The upper bound of u
	 @param vMin The lower bound of v
	 @param uMin The lower bound of u
	 @param tolV The tolerance of v bound
	 @param tolU The tolerance of u bound
	 @param pts The points of a 2D closed polygon, the last point does not required to repeat the first point
	 @details Require uMax > uMin, vMax > vMin, and at least 3 points
	 @brief Construct from a 2D polygon and uv-bounds
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/Classifier2d.hpp>
using namespace AMCAX;
#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/Classifier2d.hpp>
using namespace AMCAX;
;
	SECTION("IsInOut Point normal set2 ") {
        Point2 OutPoint(2.5, 1.9);
        Point2 OnPoint(1.5, 0.5);
        Point2 InPoint(1.5, 1.0); 
        Point2 AnothInPoint(2.0, 1.5); 
        CHECK(classifier.IsInOut(OutPoint) == -1);
        CHECK(classifier.IsInOut(OnPoint) == 0);
        CHECK(classifier.IsInOut(InPoint) == 1);
        CHECK(classifier.IsInOut(AnothInPoint) == 1);
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API int IsInOut(const Point2& p)	 @return 1: in; 0: on; -1: out
	 @param p The test point
	 @brief Check a point is in or out of the polygon
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/Classifier2d.hpp>
using namespace AMCAX;
#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/Classifier2d.hpp>
using namespace AMCAX;
;
	SECTION("IsInOut Point normal set") {
        Point2 OutPoint(0.0, 0.0);
        Point2 OnPoint(1.0, 1.0);
        Point2 InPoint(2.0, 1.0);
        CHECK(classifier.IsInOut(OutPoint) == -1);
        CHECK(classifier.IsInOut(OnPoint) == 0);
        CHECK(classifier.IsInOut(InPoint) == 1);
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API int IsInOutOn(const Point2& p, double tol)	 @return 1: in; 0: on; -1: out
	 @param tol The tolerance of the point
	 @param p The test point
	 @brief Check a point is in or out of the polygon
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/Classifier2d.hpp>
using namespace AMCAX;
#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/Classifier2d.hpp>
using namespace AMCAX;
;
	SECTION("IsInOut Point normal set") {
        Point2 OutPoint(0.0, 0.0);
        Point2 OnPoint(1.0, 1.0);
        Point2 InPoint(2.0, 1.0);
        CHECK(classifier.IsInOut(OutPoint) == -1);
        CHECK(classifier.IsInOut(OnPoint) == 0);
        CHECK(classifier.IsInOut(InPoint) == 1);
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static void AdjustPeriodic(double ufirst, double ulast, double precision, double& u1, double& u2)	 @param[in,out] u2 The second parameter to be adjust
	 @param[in,out] u1 The first parameter to be adjust
	 @param[in] precision The precision to check equality
	 @param[in] ulast The upper bound of the period
	 @param[in] ufirst The lower bound of the period
	          The parameter u2 is set in the range [u1, u1 + ulast - ufirst]
	 @details The parameter u1 is set in the range [ufirst, ulast]
	 @brief Adjust u1 and u2 to be in the period range.
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
using namespace AMCAX;
TEST_CASE("case1: CurveCalculation::AdjustPeriodic ", "[math][CurveCalculation][P1]") {
	double u1 = 0.0;
	double u2 = 2 * M_PI;
	double ufirst = 0.0;
	double ulast = 2 * M_PI; 
	double precision = 0.001; 
	AMCAX::CurveCalculation::AdjustPeriodic(ufirst, ulast, precision, u1, u2);
	CHECK(u1 == 0);
	CHECK(u2 == 2 * M_PI);
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] AMCAX_API static Vector2 D1(double u, const Circle2& circle)	 @return The first derivative vector
	 @param circle The circle
	 @param u The parameter
	 @brief Compute the first derivative on a 2D circle at a parameter
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
using namespace AMCAX;
TEST_CASE("case1: CurveCalculation::CircleD1 1/4 ", "[math][CurveCalculation][P1][CircleD1]") {
	Direction2 initialDir(1.0, 0.0); 
	Frame2 defaultFrame2(Point2(1.0, 1.0), initialDir); 
	double radius = 2.0; 
	Vector2 tangentAt0 = AMCAX::CurveCalculation::CircleD1(0.0, defaultFrame2, radius);
	Vector2 tangentAt90Deg = AMCAX::CurveCalculation::CircleD1(M_PI_2, defaultFrame2, radius);
	Vector2 tangentAt180Deg = AMCAX::CurveCalculation::CircleD1(M_PI, defaultFrame2, radius);
	Vector2 tangentAt270Deg = AMCAX::CurveCalculation::CircleD1(3 * M_PI_2, defaultFrame2, radius);
	Vector2 tangentAt360Deg = AMCAX::CurveCalculation::CircleD1(2 * M_PI, defaultFrame2, radius);
	CHECK(tangentAt0.X() == Approx(-0.0));
	CHECK(tangentAt0.Y() == Approx(2.0));
	CHECK(tangentAt90Deg.X() == Approx(-2.0));
	CHECK(tangentAt90Deg.Y() == Approx(0.0).margin(1e-14));
	CHECK(tangentAt180Deg.X() == Approx(-0.0).margin(1e-14));
	CHECK(tangentAt180Deg.Y() == Approx(-2.0));
	CHECK(tangentAt270Deg.X() == Approx(2.0));
	CHECK(tangentAt270Deg.Y() == Approx(-0.0).margin(1e-14));
	CHECK(tangentAt360Deg.X() == Approx(0.0).margin(1e-14));
	CHECK(tangentAt360Deg.Y() == Approx(2.0));
	std::cout << "Tangent at 0 deg: " << tangentAt0 << std::endl;
	std::cout << "Tangent at 90 deg: " << tangentAt90Deg << std::endl;
	std::cout << "Tangent at 180 deg: " << tangentAt180Deg << std::endl;
	std::cout << "Tangent at 270 deg: " << tangentAt270Deg << std::endl;
	std::cout << "Tangent at 360 deg: " << tangentAt360Deg << std::endl;
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static void D2(double u, const Line3& line, Point3& p, Vector3& v1, Vector3& v2)	 @param[out] v2 The second derivative
	 @param[out] v1 The first derivative
	 @param[out] p The point
	 @param[in] line The line
	 @param[in] u The parameter
	 @brief Compute the point and the first two derivatives on a 3D line at a parameter
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
using namespace AMCAX;
TEST_CASE("case1: CurveCalculation::CircleD2 3/4 ", "[math][CurveCalculation][P1][CircleD2]") {
	Direction3 initialDir(0.0, 0.0, 1.0); 
	Frame3 defaultFrame3(Point3(1.0, 1.0, 0.0), initialDir); 
	double radius = 2.0; 
	Vector3 tangentAt0 = AMCAX::CurveCalculation::CircleD2(0.0, defaultFrame3, radius);
	Vector3 tangentAt90Deg = AMCAX::CurveCalculation::CircleD2(M_PI_2, defaultFrame3, radius);
	Vector3 tangentAt180Deg = AMCAX::CurveCalculation::CircleD2(M_PI, defaultFrame3, radius);
	Vector3 tangentAt270Deg = AMCAX::CurveCalculation::CircleD2(3 * M_PI_2, defaultFrame3, radius);
	Vector3 tangentAt360Deg = AMCAX::CurveCalculation::CircleD2(2 * M_PI, defaultFrame3, radius);
	CHECK(tangentAt0.X() == Approx(-2.0));
	CHECK(tangentAt0.Y() == Approx(-0.0));
	CHECK(tangentAt0.Z() == Approx(0.0));
	CHECK(tangentAt90Deg.X() == Approx(-0.0).margin(1e-14));
	CHECK(tangentAt90Deg.Y() == Approx(-2.0).margin(1e-14));
	CHECK(tangentAt90Deg.Z() == Approx(0.0).margin(1e-14));
	CHECK(tangentAt180Deg.X() == Approx(2.0).margin(1e-14));
	CHECK(tangentAt180Deg.Y() == Approx(-0.0).margin(1e-14));
	CHECK(tangentAt180Deg.Z() == Approx(-0.0));
	CHECK(tangentAt270Deg.X() == Approx(0.0).margin(1e-14));
	CHECK(tangentAt270Deg.Y() == Approx(2.0).margin(1e-14));
	CHECK(tangentAt270Deg.Z() == Approx(0.0).margin(1e-14));
	CHECK(tangentAt360Deg.X() == Approx(-2.0).margin(1e-14));
	CHECK(tangentAt360Deg.Y() == Approx(0.0).margin(1e-14));
	CHECK(tangentAt360Deg.Z() == Approx(0.0).margin(1e-14));
	std::cout << "Tangent at 0 deg: " << tangentAt0 << std::endl;
	std::cout << "Tangent at 90 deg: " << tangentAt90Deg << std::endl;
	std::cout << "Tangent at 180 deg: " << tangentAt180Deg << std::endl;
	std::cout << "Tangent at 270 deg: " << tangentAt270Deg << std::endl;
	std::cout << "Tangent at 360 deg: " << tangentAt360Deg << std::endl;
;
	SECTION("90 deg case") {
		AMCAX::CurveCalculation::CircleD2(M_PI_2, defaultFrame3, radius, p, v1, v2);
		CHECK(p.X() == Approx(1.0));
		CHECK(p.Y() == 3.0);
		CHECK(p.Z() == 0.0);
		CHECK(v1.X() == Approx(-2.0));
		CHECK(v1.Y() == Approx(0.0).margin(1e-14));
		CHECK(v1.Z() == Approx(0.0).margin(1e-14));
		CHECK(v2.X() == Approx(0.0).margin(1e-14));
		CHECK(v2.Y() == Approx(-2.0));
		CHECK(v2.Z() == Approx(0.0));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static void D2(double u, const Circle3& circle, Point3& p, Vector3& v1, Vector3& v2)	 @param[out] v2 The second derivative
	 @param[out] v1 The first derivative
	 @param[out] p The point
	 @param[in] circle The circle
	 @param[in] u The parameter
	 @brief Compute the point and the first two derivatives on a 3D circle at a parameter
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
using namespace AMCAX;
TEST_CASE("case1: CurveCalculation::CircleD2 3/4 ", "[math][CurveCalculation][P1][CircleD2]") {
	Direction3 initialDir(0.0, 0.0, 1.0); 
	Frame3 defaultFrame3(Point3(1.0, 1.0, 0.0), initialDir); 
	double radius = 2.0; 
	Vector3 tangentAt0 = AMCAX::CurveCalculation::CircleD2(0.0, defaultFrame3, radius);
	Vector3 tangentAt90Deg = AMCAX::CurveCalculation::CircleD2(M_PI_2, defaultFrame3, radius);
	Vector3 tangentAt180Deg = AMCAX::CurveCalculation::CircleD2(M_PI, defaultFrame3, radius);
	Vector3 tangentAt270Deg = AMCAX::CurveCalculation::CircleD2(3 * M_PI_2, defaultFrame3, radius);
	Vector3 tangentAt360Deg = AMCAX::CurveCalculation::CircleD2(2 * M_PI, defaultFrame3, radius);
	CHECK(tangentAt0.X() == Approx(-2.0));
	CHECK(tangentAt0.Y() == Approx(-0.0));
	CHECK(tangentAt0.Z() == Approx(0.0));
	CHECK(tangentAt90Deg.X() == Approx(-0.0).margin(1e-14));
	CHECK(tangentAt90Deg.Y() == Approx(-2.0).margin(1e-14));
	CHECK(tangentAt90Deg.Z() == Approx(0.0).margin(1e-14));
	CHECK(tangentAt180Deg.X() == Approx(2.0).margin(1e-14));
	CHECK(tangentAt180Deg.Y() == Approx(-0.0).margin(1e-14));
	CHECK(tangentAt180Deg.Z() == Approx(-0.0));
	CHECK(tangentAt270Deg.X() == Approx(0.0).margin(1e-14));
	CHECK(tangentAt270Deg.Y() == Approx(2.0).margin(1e-14));
	CHECK(tangentAt270Deg.Z() == Approx(0.0).margin(1e-14));
	CHECK(tangentAt360Deg.X() == Approx(-2.0).margin(1e-14));
	CHECK(tangentAt360Deg.Y() == Approx(0.0).margin(1e-14));
	CHECK(tangentAt360Deg.Z() == Approx(0.0).margin(1e-14));
	std::cout << "Tangent at 0 deg: " << tangentAt0 << std::endl;
	std::cout << "Tangent at 90 deg: " << tangentAt90Deg << std::endl;
	std::cout << "Tangent at 180 deg: " << tangentAt180Deg << std::endl;
	std::cout << "Tangent at 270 deg: " << tangentAt270Deg << std::endl;
	std::cout << "Tangent at 360 deg: " << tangentAt360Deg << std::endl;
;
	SECTION("90 deg case") {
		AMCAX::CurveCalculation::CircleD2(M_PI_2, defaultFrame3, radius, p, v1, v2);
		CHECK(p.X() == Approx(1.0));
		CHECK(p.Y() == 3.0);
		CHECK(p.Z() == 0.0);
		CHECK(v1.X() == Approx(-2.0));
		CHECK(v1.Y() == Approx(0.0).margin(1e-14));
		CHECK(v1.Z() == Approx(0.0).margin(1e-14));
		CHECK(v2.X() == Approx(0.0).margin(1e-14));
		CHECK(v2.Y() == Approx(-2.0));
		CHECK(v2.Z() == Approx(0.0));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static void D2(double u, const Circle2& circle, Point2& p, Vector2& v1, Vector2& v2)	 @param[out] v2 The second derivative
	 @param[out] v1 The first derivative
	 @param[out] p The point
	 @param[in] circle The circle
	 @param[in] u The parameter
	 @brief Compute the point and the first two derivatives on a 2D circle at a parameter
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
using namespace AMCAX;
TEST_CASE("case1: CurveCalculation::CircleD2 3/4 ", "[math][CurveCalculation][P1][CircleD2]") {
	Direction3 initialDir(0.0, 0.0, 1.0); 
	Frame3 defaultFrame3(Point3(1.0, 1.0, 0.0), initialDir); 
	double radius = 2.0; 
	Vector3 tangentAt0 = AMCAX::CurveCalculation::CircleD2(0.0, defaultFrame3, radius);
	Vector3 tangentAt90Deg = AMCAX::CurveCalculation::CircleD2(M_PI_2, defaultFrame3, radius);
	Vector3 tangentAt180Deg = AMCAX::CurveCalculation::CircleD2(M_PI, defaultFrame3, radius);
	Vector3 tangentAt270Deg = AMCAX::CurveCalculation::CircleD2(3 * M_PI_2, defaultFrame3, radius);
	Vector3 tangentAt360Deg = AMCAX::CurveCalculation::CircleD2(2 * M_PI, defaultFrame3, radius);
	CHECK(tangentAt0.X() == Approx(-2.0));
	CHECK(tangentAt0.Y() == Approx(-0.0));
	CHECK(tangentAt0.Z() == Approx(0.0));
	CHECK(tangentAt90Deg.X() == Approx(-0.0).margin(1e-14));
	CHECK(tangentAt90Deg.Y() == Approx(-2.0).margin(1e-14));
	CHECK(tangentAt90Deg.Z() == Approx(0.0).margin(1e-14));
	CHECK(tangentAt180Deg.X() == Approx(2.0).margin(1e-14));
	CHECK(tangentAt180Deg.Y() == Approx(-0.0).margin(1e-14));
	CHECK(tangentAt180Deg.Z() == Approx(-0.0));
	CHECK(tangentAt270Deg.X() == Approx(0.0).margin(1e-14));
	CHECK(tangentAt270Deg.Y() == Approx(2.0).margin(1e-14));
	CHECK(tangentAt270Deg.Z() == Approx(0.0).margin(1e-14));
	CHECK(tangentAt360Deg.X() == Approx(-2.0).margin(1e-14));
	CHECK(tangentAt360Deg.Y() == Approx(0.0).margin(1e-14));
	CHECK(tangentAt360Deg.Z() == Approx(0.0).margin(1e-14));
	std::cout << "Tangent at 0 deg: " << tangentAt0 << std::endl;
	std::cout << "Tangent at 90 deg: " << tangentAt90Deg << std::endl;
	std::cout << "Tangent at 180 deg: " << tangentAt180Deg << std::endl;
	std::cout << "Tangent at 270 deg: " << tangentAt270Deg << std::endl;
	std::cout << "Tangent at 360 deg: " << tangentAt360Deg << std::endl;
;
	SECTION("90 deg case") {
		AMCAX::CurveCalculation::CircleD2(M_PI_2, defaultFrame3, radius, p, v1, v2);
		CHECK(p.X() == Approx(1.0));
		CHECK(p.Y() == 3.0);
		CHECK(p.Z() == 0.0);
		CHECK(v1.X() == Approx(-2.0));
		CHECK(v1.Y() == Approx(0.0).margin(1e-14));
		CHECK(v1.Z() == Approx(0.0).margin(1e-14));
		CHECK(v2.X() == Approx(0.0).margin(1e-14));
		CHECK(v2.Y() == Approx(-2.0));
		CHECK(v2.Z() == Approx(0.0));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static void D3(double u, const Circle3& circle, Point3& p, Vector3& v1, Vector3& v2, Vector3& v3)	 @param[out] v3 The third derivative
	 @param[out] v2 The second derivative
	 @param[out] v1 The first derivative
	 @param[out] p The point
	 @param[in] circle The circle
	 @param[in] u The parameter
	 @brief Compute the point and the first three derivatives on a 3D circle at a parameter
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
using namespace AMCAX;
TEST_CASE("case1: CurveCalculation::CircleD3 3/4 ", "[math][CurveCalculation][P1][CircleD3]") {
	Direction3 initialDir(0.0, 0.0, 1.0); 
	Frame3 defaultFrame3(Point3(1.0, 1.0, 0.0), initialDir); 
	double radius = 2.0; 
	Vector3 tangentAt0 = AMCAX::CurveCalculation::CircleD3(0.0, defaultFrame3, radius);
	Vector3 tangentAt90Deg = AMCAX::CurveCalculation::CircleD3(M_PI_2, defaultFrame3, radius);
	Vector3 tangentAt180Deg = AMCAX::CurveCalculation::CircleD3(M_PI, defaultFrame3, radius);
	Vector3 tangentAt270Deg = AMCAX::CurveCalculation::CircleD3(3 * M_PI_2, defaultFrame3, radius);
	Vector3 tangentAt360Deg = AMCAX::CurveCalculation::CircleD3(2 * M_PI, defaultFrame3, radius);
	CHECK(tangentAt0.X() == Approx(0.0));
	CHECK(tangentAt0.Y() == Approx(-2.0));
	CHECK(tangentAt0.Z() == Approx(-0.0));
	CHECK(tangentAt90Deg.X() == Approx(2.0).margin(1e-14));
	CHECK(tangentAt90Deg.Y() == Approx(-0.0).margin(1e-14));
	CHECK(tangentAt90Deg.Z() == Approx(0.0).margin(1e-14));
	CHECK(tangentAt180Deg.X() == Approx(0.0).margin(1e-14));
	CHECK(tangentAt180Deg.Y() == Approx(2.0).margin(1e-14));
	CHECK(tangentAt180Deg.Z() == Approx(0.0));
	CHECK(tangentAt270Deg.X() == Approx(-2.0).margin(1e-14));
	CHECK(tangentAt270Deg.Y() == Approx(0.0).margin(1e-14));
	CHECK(tangentAt270Deg.Z() == Approx(0.0).margin(1e-14));
	CHECK(tangentAt360Deg.X() == Approx(-0.0).margin(1e-14));
	CHECK(tangentAt360Deg.Y() == Approx(-2.0).margin(1e-14));
	CHECK(tangentAt360Deg.Z() == Approx(0.0).margin(1e-14));
	std::cout << "Tangent at 0 deg: " << tangentAt0 << std::endl;
	std::cout << "Tangent at 90 deg: " << tangentAt90Deg << std::endl;
	std::cout << "Tangent at 180 deg: " << tangentAt180Deg << std::endl;
	std::cout << "Tangent at 270 deg: " << tangentAt270Deg << std::endl;
	std::cout << "Tangent at 360 deg: " << tangentAt360Deg << std::endl;
;
	SECTION("90 deg case") {
		AMCAX::CurveCalculation::CircleD3(M_PI_2, defaultFrame3, radius, p, v1, v2, v3);
		CHECK(p.X() == Approx(1.0));
		CHECK(p.Y() == 3.0);
		CHECK(p.Z() == 0.0);
		CHECK(v1.X() == Approx(-2.0));
		CHECK(v1.Y() == Approx(0.0).margin(1e-14));
		CHECK(v1.Z() == Approx(0.0).margin(1e-14));
		CHECK(v2.X() == Approx(0.0).margin(1e-14));
		CHECK(v2.Y() == Approx(-2.0));
		CHECK(v2.Z() == Approx(0.0));
		CHECK(v3.X() == Approx(2.0));
		CHECK(v3.Y() == Approx(-0.0).margin(1e-14));
		CHECK(v3.Z() == Approx(-0.0));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static void D3(double u, const Line2& line, Point2& p, Vector2& v1, Vector2& v2, Vector2& v3)	 @param[out] v3 The third derivative
	 @param[out] v2 The second derivative
	 @param[out] v1 The first derivative
	 @param[out] p The point
	 @param[in] line The line
	 @param[in] u The parameter
	 @brief Compute the point and the first three derivatives on a 2D line at a parameter
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
using namespace AMCAX;
TEST_CASE("case1: CurveCalculation::CircleD3 1/4 ", "[math][CurveCalculation][P1][CircleD3]") {
	Direction2 defaultDir2(1.0, 0.0);
	Frame2 defaultFrame2(Point2(1.0, 1.0), defaultDir2);
	double radius = 2.0;
	Vector2 tangentAt0 = AMCAX::CurveCalculation::CircleD3(0.0, defaultFrame2, radius);
	Vector2 tangentAt180 = AMCAX::CurveCalculation::CircleD3(M_PI, defaultFrame2, radius);
	Vector2 tangentAt360 = AMCAX::CurveCalculation::CircleD3(2 * M_PI, defaultFrame2, radius);
	CHECK(tangentAt0.X() == 0.0);
	CHECK(tangentAt0.Y() == -2.0);
	CHECK(tangentAt180.X() == Approx(0.0).margin(1e-14));
	CHECK(tangentAt180.Y() == 2.0 );
	CHECK(tangentAt360.X() == Approx(0.0).margin(1e-14));
	CHECK(tangentAt360.Y() == -2.0 );
;
	SECTION("360 deg case") {
		AMCAX::CurveCalculation::CircleD3(2*M_PI, defaultFrame2, radius, p, v1, v2, v3);
		CHECK(p.X() == 3.0);
		CHECK(p.Y() == Approx(1.0).margin(1e-14));
		CHECK(v1.X() == Approx(0.0).margin(1e-14));
		CHECK(v1.Y() == Approx(2.0));
		CHECK(v2.X() == Approx(-2.0).margin(1e-14));
		CHECK(v2.Y() == Approx(0.0).margin(1e-14));
		CHECK(v3.X() == Approx(-0.0).margin(1e-14));
		CHECK(v3.Y() == Approx(-2.0));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static void D3(double u, const Circle2& circle, Point2& p, Vector2& v1, Vector2& v2, Vector2& v3)	 @param[out] v3 The third derivative
	 @param[out] v2 The second derivative
	 @param[out] v1 The first derivative
	 @param[out] p The point
	 @param[in] circle The circle
	 @param[in] u The parameter
	 @brief Compute the point and the first three derivatives on a 2D circle at a parameter
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
using namespace AMCAX;
TEST_CASE("case1: CurveCalculation::CircleD3 1/4 ", "[math][CurveCalculation][P1][CircleD3]") {
	Direction2 defaultDir2(1.0, 0.0);
	Frame2 defaultFrame2(Point2(1.0, 1.0), defaultDir2);
	double radius = 2.0;
	Vector2 tangentAt0 = AMCAX::CurveCalculation::CircleD3(0.0, defaultFrame2, radius);
	Vector2 tangentAt180 = AMCAX::CurveCalculation::CircleD3(M_PI, defaultFrame2, radius);
	Vector2 tangentAt360 = AMCAX::CurveCalculation::CircleD3(2 * M_PI, defaultFrame2, radius);
	CHECK(tangentAt0.X() == 0.0);
	CHECK(tangentAt0.Y() == -2.0);
	CHECK(tangentAt180.X() == Approx(0.0).margin(1e-14));
	CHECK(tangentAt180.Y() == 2.0 );
	CHECK(tangentAt360.X() == Approx(0.0).margin(1e-14));
	CHECK(tangentAt360.Y() == -2.0 );
;
	SECTION("360 deg case") {
		AMCAX::CurveCalculation::CircleD3(2*M_PI, defaultFrame2, radius, p, v1, v2, v3);
		CHECK(p.X() == 3.0);
		CHECK(p.Y() == Approx(1.0).margin(1e-14));
		CHECK(v1.X() == Approx(0.0).margin(1e-14));
		CHECK(v1.Y() == Approx(2.0));
		CHECK(v2.X() == Approx(-2.0).margin(1e-14));
		CHECK(v2.Y() == Approx(0.0).margin(1e-14));
		CHECK(v3.X() == Approx(-0.0).margin(1e-14));
		CHECK(v3.Y() == Approx(-2.0));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] AMCAX_API static Point3 CircleValue(double u, const Frame3& pos, double radius)	 @return The point
	 @param radius The radius
	 @param pos The local frame where the circle lies
	 @param u The parameter
	 @brief Compute the point on a 3D circle represented by a local frame and a radius at a parameter
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
using namespace AMCAX;
TEST_CASE("case1: CurveCalculation::CircleD1 3/4 ", "[math][CurveCalculation][P1][CircleD1]") {
	Direction3 initialDir(0.0, 0.0,1.0); 
	Frame3 defaultFrame3(Point3(1.0, 0.0,0.0), initialDir); 
	double radius = 2.0; 
	Vector3 tangentAt0 = AMCAX::CurveCalculation::CircleD1(0.0, defaultFrame3, radius);
	Vector3 tangentAt90Deg = AMCAX::CurveCalculation::CircleD1(M_PI_2, defaultFrame3, radius);
	Vector3 tangentAt180Deg = AMCAX::CurveCalculation::CircleD1(M_PI, defaultFrame3, radius);
	Vector3 tangentAt270Deg = AMCAX::CurveCalculation::CircleD1(3 * M_PI_2, defaultFrame3, radius);
	Vector3 tangentAt360Deg = AMCAX::CurveCalculation::CircleD1(2 * M_PI, defaultFrame3, radius);
	CHECK(tangentAt0.X() == Approx(0.0));
	CHECK(tangentAt0.Y() == Approx(2.0));
	CHECK(tangentAt90Deg.X() == Approx(-2.0));
	CHECK(tangentAt90Deg.Y() == Approx(0.0).margin(1e-14));
	CHECK(tangentAt180Deg.X() == Approx(0.0).margin(1e-14));
	CHECK(tangentAt180Deg.Y() == Approx(-2.0));
	CHECK(tangentAt270Deg.X() == Approx(2.0));
	CHECK(tangentAt270Deg.Y() == Approx(-0.0).margin(1e-14));
	CHECK(tangentAt360Deg.X() == Approx(0.0).margin(1e-14));
	CHECK(tangentAt360Deg.Y() == Approx(2.0));
	std::cout << "Tangent at 0 deg: " << tangentAt0 << std::endl;
	std::cout << "Tangent at 90 deg: " << tangentAt90Deg << std::endl;
	std::cout << "Tangent at 180 deg: " << tangentAt180Deg << std::endl;
	std::cout << "Tangent at 270 deg: " << tangentAt270Deg << std::endl;
	std::cout << "Tangent at 360 deg: " << tangentAt360Deg << std::endl;
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] AMCAX_API static Point2 CircleValue(double u, const Frame2& pos, double radius)	 @return The point
	 @param radius The radius
	 @param pos The local frame where the circle lies
	 @param u The parameter
	 @brief Compute the point on a 2D circle represented by a local frame and a radius at a parameter
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
using namespace AMCAX;
TEST_CASE("case1: CurveCalculation::CircleD3 1/4 ", "[math][CurveCalculation][P1][CircleD3]") {
	Direction2 defaultDir2(1.0, 0.0);
	Frame2 defaultFrame2(Point2(1.0, 1.0), defaultDir2);
	double radius = 2.0;
	Vector2 tangentAt0 = AMCAX::CurveCalculation::CircleD3(0.0, defaultFrame2, radius);
	Vector2 tangentAt180 = AMCAX::CurveCalculation::CircleD3(M_PI, defaultFrame2, radius);
	Vector2 tangentAt360 = AMCAX::CurveCalculation::CircleD3(2 * M_PI, defaultFrame2, radius);
	CHECK(tangentAt0.X() == 0.0);
	CHECK(tangentAt0.Y() == -2.0);
	CHECK(tangentAt180.X() == Approx(0.0).margin(1e-14));
	CHECK(tangentAt180.Y() == 2.0 );
	CHECK(tangentAt360.X() == Approx(0.0).margin(1e-14));
	CHECK(tangentAt360.Y() == -2.0 );
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] AMCAX_API static Point3 CircleD0(double u, const Frame3& pos, double radius)	 @return The point
	 @param radius The radius
	 @param pos The local frame where the circle lies
	 @param u The parameter
	 @brief Compute the point on a 3D circle represented by a local frame and a radius at a parameter
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
using namespace AMCAX;
TEST_CASE("case1: CurveCalculation::CircleD0 2/2 ", "[math][CurveCalculation][P1]") {
	Direction3 defaultDirection(-1.0, 0.0,0.0); 
	Frame3 defaultFrame3(Point3(1.0, 0.0,0.0), defaultDirection);
	double 	r = 3.0;
	double u = 2 * M_PI / 4; 
	Point3  pointOnCirecle = CurveCalculation::CircleD0(u, defaultFrame3, r);
	std::cout << pointOnCirecle.X() << " " << pointOnCirecle.Y() << " " << pointOnCirecle.Y() << std::endl;
	CHECK(pointOnCirecle.X() == Approx(1.0).epsilon(1e-12));
	CHECK(pointOnCirecle.Y() == -3.0);
	CHECK((pointOnCirecle.X() - 1.0) * (pointOnCirecle.X() - 1.0) + pointOnCirecle.Y() * pointOnCirecle.Y() == r * r);
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] AMCAX_API static Point2 CircleD0(double u, const Frame2& pos, double radius)	 @return The point
	 @param radius The radius
	 @param pos The local frame where the circle lies
	 @param u The parameter
	 @brief Compute the point on a 2D circle represented by a local frame and a radius at a parameter
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
using namespace AMCAX;
TEST_CASE("case1: CurveCalculation::CircleD0 1/2 ", "[math][CurveCalculation][P1]") {
	Direction2 defaultDirection(1.0,0.0); 
	Frame2 defaultFrame2(Point2(0.0, 0.0), defaultDirection);
	double 	r = 3.0;
	double u = 4 * M_PI ; 
	Point2  pointOnCirecle = CurveCalculation::CircleD0(u, defaultFrame2, r);
	std::cout << pointOnCirecle.X() << " " << pointOnCirecle.Y() << " "  << std::endl;
	CHECK(pointOnCirecle.X() == 3.0);
	CHECK(pointOnCirecle.Y() == Approx(0.0).margin(1e-14));
	CHECK(pointOnCirecle.X() * pointOnCirecle.X() + pointOnCirecle.Y() * pointOnCirecle.Y() == r * r);
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] AMCAX_API static Vector3 CircleD1(double u, const Frame3& pos, double radius)	 @return The first derivative vector
	 @param radius The radius
	 @param pos The local frame where the circle lies
	 @param u The parameter
	 @brief Compute the first derivative on a 3D circle represented by a local frame and a radius at a parameter
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
using namespace AMCAX;
TEST_CASE("case1: CurveCalculation::CircleD1 1/4 ", "[math][CurveCalculation][P1][CircleD1]") {
	Direction2 initialDir(1.0, 0.0); 
	Frame2 defaultFrame2(Point2(1.0, 1.0), initialDir); 
	double radius = 2.0; 
	Vector2 tangentAt0 = AMCAX::CurveCalculation::CircleD1(0.0, defaultFrame2, radius);
	Vector2 tangentAt90Deg = AMCAX::CurveCalculation::CircleD1(M_PI_2, defaultFrame2, radius);
	Vector2 tangentAt180Deg = AMCAX::CurveCalculation::CircleD1(M_PI, defaultFrame2, radius);
	Vector2 tangentAt270Deg = AMCAX::CurveCalculation::CircleD1(3 * M_PI_2, defaultFrame2, radius);
	Vector2 tangentAt360Deg = AMCAX::CurveCalculation::CircleD1(2 * M_PI, defaultFrame2, radius);
	CHECK(tangentAt0.X() == Approx(-0.0));
	CHECK(tangentAt0.Y() == Approx(2.0));
	CHECK(tangentAt90Deg.X() == Approx(-2.0));
	CHECK(tangentAt90Deg.Y() == Approx(0.0).margin(1e-14));
	CHECK(tangentAt180Deg.X() == Approx(-0.0).margin(1e-14));
	CHECK(tangentAt180Deg.Y() == Approx(-2.0));
	CHECK(tangentAt270Deg.X() == Approx(2.0));
	CHECK(tangentAt270Deg.Y() == Approx(-0.0).margin(1e-14));
	CHECK(tangentAt360Deg.X() == Approx(0.0).margin(1e-14));
	CHECK(tangentAt360Deg.Y() == Approx(2.0));
	std::cout << "Tangent at 0 deg: " << tangentAt0 << std::endl;
	std::cout << "Tangent at 90 deg: " << tangentAt90Deg << std::endl;
	std::cout << "Tangent at 180 deg: " << tangentAt180Deg << std::endl;
	std::cout << "Tangent at 270 deg: " << tangentAt270Deg << std::endl;
	std::cout << "Tangent at 360 deg: " << tangentAt360Deg << std::endl;
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static void CircleD1(double u, const Frame3& pos, double radius, Point3& p, Vector3& v1)	 @param[out] v1 The first derivative
	 @param[out] p The point
	 @param[in] radius The radius
	 @param[in] pos The local frame where the circle lies
	 @param[in] u The parameter
	 @brief Compute the point and the first derivative on a 3D circle represented by a local frame and a radius at a parameter
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
using namespace AMCAX;
TEST_CASE("case2: CurveCalculation::CircleD1 1/4 ", "[math][CurveCalculation][P1][CircleD1]") {
	Direction2 initialDir(1.0, 0.0); 
	Frame2 defaultFrame2(Point2(0.0, 0.0), initialDir); 
	double radius = 2.0; 
	Vector2 tangentAt0 = AMCAX::CurveCalculation::CircleD1(0.0, defaultFrame2, radius);
	Vector2 tangentAt90Deg = AMCAX::CurveCalculation::CircleD1(M_PI_2, defaultFrame2, radius);
	Vector2 tangentAt180Deg = AMCAX::CurveCalculation::CircleD1(M_PI, defaultFrame2, radius);
	Vector2 tangentAt270Deg = AMCAX::CurveCalculation::CircleD1(3 * M_PI_2, defaultFrame2, radius);
	Vector2 tangentAt360Deg = AMCAX::CurveCalculation::CircleD1(2 * M_PI, defaultFrame2, radius);
	CHECK(tangentAt0.X() == Approx(0.0));
	CHECK(tangentAt0.Y() == Approx(2.0));
	CHECK(tangentAt90Deg.X() == Approx(-2.0));
	CHECK(tangentAt90Deg.Y() == Approx(0.0).margin(1e-14));
	CHECK(tangentAt180Deg.X() == Approx(0.0).margin(1e-14));
	CHECK(tangentAt180Deg.Y() == Approx(-2.0));
	CHECK(tangentAt270Deg.X() == Approx(2.0));
	CHECK(tangentAt270Deg.Y() == Approx(-0.0).margin(1e-14));
	CHECK(tangentAt360Deg.X() == Approx(0.0).margin(1e-14));
	CHECK(tangentAt360Deg.Y() == Approx(2.0));
	std::cout << "Tangent at 0 deg: " << tangentAt0 << std::endl;
	std::cout << "Tangent at 90 deg: " << tangentAt90Deg << std::endl;
	std::cout << "Tangent at 180 deg: " << tangentAt180Deg << std::endl;
	std::cout << "Tangent at 270 deg: " << tangentAt270Deg << std::endl;
	std::cout << "Tangent at 360 deg: " << tangentAt360Deg << std::endl;
;
	SECTION("0 deg case") {
		AMCAX::CurveCalculation::CircleD1(0.0, defaultFrame2,radius, p, v);
		CHECK(p.X() == 3.0);
		CHECK(p.Y() == 1.0);
		CHECK(v.X() == Approx(0.0));
		CHECK(v.Y() == Approx(2.0));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] AMCAX_API static Vector2 CircleD1(double u, const Frame2& pos, double radius)	 @return The first derivative vector
	 @param radius The radius
	 @param pos The local frame where the circle lies
	 @param u The parameter
	 @brief Compute the first derivative on a 2D circle represented by a local frame and a radius at a parameter
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
using namespace AMCAX;
TEST_CASE("case1: CurveCalculation::CircleD1 1/4 ", "[math][CurveCalculation][P1][CircleD1]") {
	Direction2 initialDir(1.0, 0.0); 
	Frame2 defaultFrame2(Point2(1.0, 1.0), initialDir); 
	double radius = 2.0; 
	Vector2 tangentAt0 = AMCAX::CurveCalculation::CircleD1(0.0, defaultFrame2, radius);
	Vector2 tangentAt90Deg = AMCAX::CurveCalculation::CircleD1(M_PI_2, defaultFrame2, radius);
	Vector2 tangentAt180Deg = AMCAX::CurveCalculation::CircleD1(M_PI, defaultFrame2, radius);
	Vector2 tangentAt270Deg = AMCAX::CurveCalculation::CircleD1(3 * M_PI_2, defaultFrame2, radius);
	Vector2 tangentAt360Deg = AMCAX::CurveCalculation::CircleD1(2 * M_PI, defaultFrame2, radius);
	CHECK(tangentAt0.X() == Approx(-0.0));
	CHECK(tangentAt0.Y() == Approx(2.0));
	CHECK(tangentAt90Deg.X() == Approx(-2.0));
	CHECK(tangentAt90Deg.Y() == Approx(0.0).margin(1e-14));
	CHECK(tangentAt180Deg.X() == Approx(-0.0).margin(1e-14));
	CHECK(tangentAt180Deg.Y() == Approx(-2.0));
	CHECK(tangentAt270Deg.X() == Approx(2.0));
	CHECK(tangentAt270Deg.Y() == Approx(-0.0).margin(1e-14));
	CHECK(tangentAt360Deg.X() == Approx(0.0).margin(1e-14));
	CHECK(tangentAt360Deg.Y() == Approx(2.0));
	std::cout << "Tangent at 0 deg: " << tangentAt0 << std::endl;
	std::cout << "Tangent at 90 deg: " << tangentAt90Deg << std::endl;
	std::cout << "Tangent at 180 deg: " << tangentAt180Deg << std::endl;
	std::cout << "Tangent at 270 deg: " << tangentAt270Deg << std::endl;
	std::cout << "Tangent at 360 deg: " << tangentAt360Deg << std::endl;
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static void CircleD1(double u, const Frame2& pos, double radius, Point2& p, Vector2& v1)	 @param[out] v1 The first derivative
	 @param[out] p The point
	 @param[in] radius The radius
	 @param[in] pos The local frame where the circle lies
	 @param[in] u The parameter
	 @brief Compute the point and the first derivative on a 2D circle represented by a local frame and a radius at a parameter
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
using namespace AMCAX;
TEST_CASE("case1: CurveCalculation::CircleD1 1/4 ", "[math][CurveCalculation][P1][CircleD1]") {
	Direction2 initialDir(1.0, 0.0); 
	Frame2 defaultFrame2(Point2(1.0, 1.0), initialDir); 
	double radius = 2.0; 
	Vector2 tangentAt0 = AMCAX::CurveCalculation::CircleD1(0.0, defaultFrame2, radius);
	Vector2 tangentAt90Deg = AMCAX::CurveCalculation::CircleD1(M_PI_2, defaultFrame2, radius);
	Vector2 tangentAt180Deg = AMCAX::CurveCalculation::CircleD1(M_PI, defaultFrame2, radius);
	Vector2 tangentAt270Deg = AMCAX::CurveCalculation::CircleD1(3 * M_PI_2, defaultFrame2, radius);
	Vector2 tangentAt360Deg = AMCAX::CurveCalculation::CircleD1(2 * M_PI, defaultFrame2, radius);
	CHECK(tangentAt0.X() == Approx(-0.0));
	CHECK(tangentAt0.Y() == Approx(2.0));
	CHECK(tangentAt90Deg.X() == Approx(-2.0));
	CHECK(tangentAt90Deg.Y() == Approx(0.0).margin(1e-14));
	CHECK(tangentAt180Deg.X() == Approx(-0.0).margin(1e-14));
	CHECK(tangentAt180Deg.Y() == Approx(-2.0));
	CHECK(tangentAt270Deg.X() == Approx(2.0));
	CHECK(tangentAt270Deg.Y() == Approx(-0.0).margin(1e-14));
	CHECK(tangentAt360Deg.X() == Approx(0.0).margin(1e-14));
	CHECK(tangentAt360Deg.Y() == Approx(2.0));
	std::cout << "Tangent at 0 deg: " << tangentAt0 << std::endl;
	std::cout << "Tangent at 90 deg: " << tangentAt90Deg << std::endl;
	std::cout << "Tangent at 180 deg: " << tangentAt180Deg << std::endl;
	std::cout << "Tangent at 270 deg: " << tangentAt270Deg << std::endl;
	std::cout << "Tangent at 360 deg: " << tangentAt360Deg << std::endl;
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] AMCAX_API static Vector3 CircleD2(double u, const Frame3& pos, double radius)	 @return The second derivative vector
	 @param radius The radius
	 @param pos The local frame where the circle lies
	 @param u The parameter
	 @brief Compute the second derivative on a 3D circle represented by a local frame and a radius at a parameter
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
using namespace AMCAX;
TEST_CASE("case1: CurveCalculation::CircleD2 3/4 ", "[math][CurveCalculation][P1][CircleD2]") {
	Direction3 initialDir(0.0, 0.0, 1.0); 
	Frame3 defaultFrame3(Point3(1.0, 1.0, 0.0), initialDir); 
	double radius = 2.0; 
	Vector3 tangentAt0 = AMCAX::CurveCalculation::CircleD2(0.0, defaultFrame3, radius);
	Vector3 tangentAt90Deg = AMCAX::CurveCalculation::CircleD2(M_PI_2, defaultFrame3, radius);
	Vector3 tangentAt180Deg = AMCAX::CurveCalculation::CircleD2(M_PI, defaultFrame3, radius);
	Vector3 tangentAt270Deg = AMCAX::CurveCalculation::CircleD2(3 * M_PI_2, defaultFrame3, radius);
	Vector3 tangentAt360Deg = AMCAX::CurveCalculation::CircleD2(2 * M_PI, defaultFrame3, radius);
	CHECK(tangentAt0.X() == Approx(-2.0));
	CHECK(tangentAt0.Y() == Approx(-0.0));
	CHECK(tangentAt0.Z() == Approx(0.0));
	CHECK(tangentAt90Deg.X() == Approx(-0.0).margin(1e-14));
	CHECK(tangentAt90Deg.Y() == Approx(-2.0).margin(1e-14));
	CHECK(tangentAt90Deg.Z() == Approx(0.0).margin(1e-14));
	CHECK(tangentAt180Deg.X() == Approx(2.0).margin(1e-14));
	CHECK(tangentAt180Deg.Y() == Approx(-0.0).margin(1e-14));
	CHECK(tangentAt180Deg.Z() == Approx(-0.0));
	CHECK(tangentAt270Deg.X() == Approx(0.0).margin(1e-14));
	CHECK(tangentAt270Deg.Y() == Approx(2.0).margin(1e-14));
	CHECK(tangentAt270Deg.Z() == Approx(0.0).margin(1e-14));
	CHECK(tangentAt360Deg.X() == Approx(-2.0).margin(1e-14));
	CHECK(tangentAt360Deg.Y() == Approx(0.0).margin(1e-14));
	CHECK(tangentAt360Deg.Z() == Approx(0.0).margin(1e-14));
	std::cout << "Tangent at 0 deg: " << tangentAt0 << std::endl;
	std::cout << "Tangent at 90 deg: " << tangentAt90Deg << std::endl;
	std::cout << "Tangent at 180 deg: " << tangentAt180Deg << std::endl;
	std::cout << "Tangent at 270 deg: " << tangentAt270Deg << std::endl;
	std::cout << "Tangent at 360 deg: " << tangentAt360Deg << std::endl;
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static void CircleD2(double u, const Frame3& pos, double radius, Point3& p, Vector3& v1, Vector3& v2)	 @param[out] v2 The second derivative
	 @param[out] v1 The first derivative
	 @param[out] p The point
	 @param[in] radius The radius
	 @param[in] pos The local frame where the circle lies
	 @param[in] u The parameter
	 @brief Compute the point and the first two derivatives on a 3D circle represented by a local frame and a radius at a parameter
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
using namespace AMCAX;
TEST_CASE("case1: CurveCalculation::CircleD2 3/4 ", "[math][CurveCalculation][P1][CircleD2]") {
	Direction3 initialDir(0.0, 0.0, 1.0); 
	Frame3 defaultFrame3(Point3(1.0, 1.0, 0.0), initialDir); 
	double radius = 2.0; 
	Vector3 tangentAt0 = AMCAX::CurveCalculation::CircleD2(0.0, defaultFrame3, radius);
	Vector3 tangentAt90Deg = AMCAX::CurveCalculation::CircleD2(M_PI_2, defaultFrame3, radius);
	Vector3 tangentAt180Deg = AMCAX::CurveCalculation::CircleD2(M_PI, defaultFrame3, radius);
	Vector3 tangentAt270Deg = AMCAX::CurveCalculation::CircleD2(3 * M_PI_2, defaultFrame3, radius);
	Vector3 tangentAt360Deg = AMCAX::CurveCalculation::CircleD2(2 * M_PI, defaultFrame3, radius);
	CHECK(tangentAt0.X() == Approx(-2.0));
	CHECK(tangentAt0.Y() == Approx(-0.0));
	CHECK(tangentAt0.Z() == Approx(0.0));
	CHECK(tangentAt90Deg.X() == Approx(-0.0).margin(1e-14));
	CHECK(tangentAt90Deg.Y() == Approx(-2.0).margin(1e-14));
	CHECK(tangentAt90Deg.Z() == Approx(0.0).margin(1e-14));
	CHECK(tangentAt180Deg.X() == Approx(2.0).margin(1e-14));
	CHECK(tangentAt180Deg.Y() == Approx(-0.0).margin(1e-14));
	CHECK(tangentAt180Deg.Z() == Approx(-0.0));
	CHECK(tangentAt270Deg.X() == Approx(0.0).margin(1e-14));
	CHECK(tangentAt270Deg.Y() == Approx(2.0).margin(1e-14));
	CHECK(tangentAt270Deg.Z() == Approx(0.0).margin(1e-14));
	CHECK(tangentAt360Deg.X() == Approx(-2.0).margin(1e-14));
	CHECK(tangentAt360Deg.Y() == Approx(0.0).margin(1e-14));
	CHECK(tangentAt360Deg.Z() == Approx(0.0).margin(1e-14));
	std::cout << "Tangent at 0 deg: " << tangentAt0 << std::endl;
	std::cout << "Tangent at 90 deg: " << tangentAt90Deg << std::endl;
	std::cout << "Tangent at 180 deg: " << tangentAt180Deg << std::endl;
	std::cout << "Tangent at 270 deg: " << tangentAt270Deg << std::endl;
	std::cout << "Tangent at 360 deg: " << tangentAt360Deg << std::endl;
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] AMCAX_API static Vector2 CircleD2(double u, const Frame2& pos, double radius)	 @return The second derivative vector
	 @param radius The radius
	 @param pos The local frame where the circle lies
	 @param u The parameter
	 @brief Compute the second derivative on a 2D circle represented by a local frame and a radius at a parameter
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
using namespace AMCAX;
TEST_CASE("case1: CurveCalculation::CircleD2 1/4 ", "[math][CurveCalculation][P1][CircleD2]") {
	Direction2 defaultDirection(1.0, 0.0); 
	Frame2 defaultFrame2(Point2(0.0, 0.0), defaultDirection);
	double 	r = 2.0;
	double u = 0.0; 
	Vector2  vector2 = CurveCalculation::CircleD2(u, defaultFrame2, r); 
	std::cout << vector2.X() << " " << vector2.Y() << " " << std::endl;
	CHECK(vector2.X() == -2.0);
	CHECK(vector2.Y() == Approx(0.0).margin(1e-14));
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static void CircleD2(double u, const Frame2& pos, double radius, Point2& p, Vector2& v1, Vector2& v2)	 @param[out] v2 The second derivative
	 @param[out] v1 The first derivative
	 @param[out] p The point
	 @param[in] radius The radius
	 @param[in] pos The local frame where the circle lies
	 @param[in] u The parameter
	 @brief Compute the point and the first two derivatives on a 2D circle represented by a local frame and a radius at a parameter
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
using namespace AMCAX;
TEST_CASE("case1: CurveCalculation::CircleD2 2/4 ", "[math][CurveCalculation][P1][CircleD2]") {
	Direction2 defaultDirection(1.0, 0.0);
	Frame2 defaultFrame2(Point2(1.0, 1.0), defaultDirection);
	double r = 3.0;
	double u = 0.0;
	Vector2 v1;
	Vector2 v2;
	Point2 p;
	CurveCalculation::CircleD2(u, defaultFrame2, r, p, v1, v2);
	CHECK(p.X() == 4.0);
	CHECK(p.Y() == 1.0 );
	CHECK(v1.X() == 0.0 );
	CHECK(v1.Y() == 3.0);
	CHECK(v2.X() == -3.0);
	CHECK(v2.Y() == 0.0);
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] AMCAX_API static Vector3 CircleD3(double u, const Frame3& pos, double radius)	 @return The third derivative vector
	 @param radius The radius
	 @param pos The local frame where the circle lies
	 @param u The parameter
	 @brief Compute the third derivative on a 3D circle represented by a local frame and a radius at a parameter
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
using namespace AMCAX;
TEST_CASE("case1: CurveCalculation::CircleD3 3/4 ", "[math][CurveCalculation][P1][CircleD3]") {
	Direction3 initialDir(0.0, 0.0, 1.0); 
	Frame3 defaultFrame3(Point3(1.0, 1.0, 0.0), initialDir); 
	double radius = 2.0; 
	Vector3 tangentAt0 = AMCAX::CurveCalculation::CircleD3(0.0, defaultFrame3, radius);
	Vector3 tangentAt90Deg = AMCAX::CurveCalculation::CircleD3(M_PI_2, defaultFrame3, radius);
	Vector3 tangentAt180Deg = AMCAX::CurveCalculation::CircleD3(M_PI, defaultFrame3, radius);
	Vector3 tangentAt270Deg = AMCAX::CurveCalculation::CircleD3(3 * M_PI_2, defaultFrame3, radius);
	Vector3 tangentAt360Deg = AMCAX::CurveCalculation::CircleD3(2 * M_PI, defaultFrame3, radius);
	CHECK(tangentAt0.X() == Approx(0.0));
	CHECK(tangentAt0.Y() == Approx(-2.0));
	CHECK(tangentAt0.Z() == Approx(-0.0));
	CHECK(tangentAt90Deg.X() == Approx(2.0).margin(1e-14));
	CHECK(tangentAt90Deg.Y() == Approx(-0.0).margin(1e-14));
	CHECK(tangentAt90Deg.Z() == Approx(0.0).margin(1e-14));
	CHECK(tangentAt180Deg.X() == Approx(0.0).margin(1e-14));
	CHECK(tangentAt180Deg.Y() == Approx(2.0).margin(1e-14));
	CHECK(tangentAt180Deg.Z() == Approx(0.0));
	CHECK(tangentAt270Deg.X() == Approx(-2.0).margin(1e-14));
	CHECK(tangentAt270Deg.Y() == Approx(0.0).margin(1e-14));
	CHECK(tangentAt270Deg.Z() == Approx(0.0).margin(1e-14));
	CHECK(tangentAt360Deg.X() == Approx(-0.0).margin(1e-14));
	CHECK(tangentAt360Deg.Y() == Approx(-2.0).margin(1e-14));
	CHECK(tangentAt360Deg.Z() == Approx(0.0).margin(1e-14));
	std::cout << "Tangent at 0 deg: " << tangentAt0 << std::endl;
	std::cout << "Tangent at 90 deg: " << tangentAt90Deg << std::endl;
	std::cout << "Tangent at 180 deg: " << tangentAt180Deg << std::endl;
	std::cout << "Tangent at 270 deg: " << tangentAt270Deg << std::endl;
	std::cout << "Tangent at 360 deg: " << tangentAt360Deg << std::endl;
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static void CircleD3(double u, const Frame3& pos, double radius, Point3& p, Vector3& v1, Vector3& v2, Vector3& v3)	 @param[out] v3 The third derivative
	 @param[out] v2 The second derivative
	 @param[out] v1 The first derivative
	 @param[out] p The point
	 @param[in] radius The radius
	 @param[in] pos The local frame where the circle lies
	 @param[in] u The parameter
	 @brief Compute the point and the first three derivatives on a 3D circle represented by a local frame and a radius at a parameter
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
using namespace AMCAX;
TEST_CASE("case1: CurveCalculation::CircleD3 3/4 ", "[math][CurveCalculation][P1][CircleD3]") {
	Direction3 initialDir(0.0, 0.0, 1.0); 
	Frame3 defaultFrame3(Point3(1.0, 1.0, 0.0), initialDir); 
	double radius = 2.0; 
	Vector3 tangentAt0 = AMCAX::CurveCalculation::CircleD3(0.0, defaultFrame3, radius);
	Vector3 tangentAt90Deg = AMCAX::CurveCalculation::CircleD3(M_PI_2, defaultFrame3, radius);
	Vector3 tangentAt180Deg = AMCAX::CurveCalculation::CircleD3(M_PI, defaultFrame3, radius);
	Vector3 tangentAt270Deg = AMCAX::CurveCalculation::CircleD3(3 * M_PI_2, defaultFrame3, radius);
	Vector3 tangentAt360Deg = AMCAX::CurveCalculation::CircleD3(2 * M_PI, defaultFrame3, radius);
	CHECK(tangentAt0.X() == Approx(0.0));
	CHECK(tangentAt0.Y() == Approx(-2.0));
	CHECK(tangentAt0.Z() == Approx(-0.0));
	CHECK(tangentAt90Deg.X() == Approx(2.0).margin(1e-14));
	CHECK(tangentAt90Deg.Y() == Approx(-0.0).margin(1e-14));
	CHECK(tangentAt90Deg.Z() == Approx(0.0).margin(1e-14));
	CHECK(tangentAt180Deg.X() == Approx(0.0).margin(1e-14));
	CHECK(tangentAt180Deg.Y() == Approx(2.0).margin(1e-14));
	CHECK(tangentAt180Deg.Z() == Approx(0.0));
	CHECK(tangentAt270Deg.X() == Approx(-2.0).margin(1e-14));
	CHECK(tangentAt270Deg.Y() == Approx(0.0).margin(1e-14));
	CHECK(tangentAt270Deg.Z() == Approx(0.0).margin(1e-14));
	CHECK(tangentAt360Deg.X() == Approx(-0.0).margin(1e-14));
	CHECK(tangentAt360Deg.Y() == Approx(-2.0).margin(1e-14));
	CHECK(tangentAt360Deg.Z() == Approx(0.0).margin(1e-14));
	std::cout << "Tangent at 0 deg: " << tangentAt0 << std::endl;
	std::cout << "Tangent at 90 deg: " << tangentAt90Deg << std::endl;
	std::cout << "Tangent at 180 deg: " << tangentAt180Deg << std::endl;
	std::cout << "Tangent at 270 deg: " << tangentAt270Deg << std::endl;
	std::cout << "Tangent at 360 deg: " << tangentAt360Deg << std::endl;
;
	SECTION("0 deg case") {
		AMCAX::CurveCalculation::CircleD3(0.0, defaultFrame3, radius, p, v1, v2, v3);
		CHECK(p.X() == 3.0);
		CHECK(p.Y() == 1.0);
		CHECK(p.Z() == 0.0);
		CHECK(v1.X() == Approx(0.0));
		CHECK(v1.Y() == Approx(2.0));
		CHECK(v1.Z() == Approx(0.0));
		CHECK(v2.X() == Approx(-2.0));
		CHECK(v2.Y() == Approx(0.0));
		CHECK(v2.Z() == Approx(0.0));
		CHECK(v3.X() == Approx(0.0));
		CHECK(v3.Y() == Approx(-2.0).margin(1e-14));
		CHECK(v3.Z() == Approx(-0.0));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] AMCAX_API static Vector2 CircleD3(double u, const Frame2& pos, double radius)	 @return The third derivative vector
	 @param radius The radius
	 @param pos The local frame where the circle lies
	 @param u The parameter
	 @brief Compute the third derivative on a 2D circle represented by a local frame and a radius at a parameter
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
using namespace AMCAX;
TEST_CASE("case1: CurveCalculation::CircleD3 1/4 ", "[math][CurveCalculation][P1][CircleD3]") {
	Direction2 defaultDir2(1.0, 0.0);
	Frame2 defaultFrame2(Point2(1.0, 1.0), defaultDir2);
	double radius = 2.0;
	Vector2 tangentAt0 = AMCAX::CurveCalculation::CircleD3(0.0, defaultFrame2, radius);
	Vector2 tangentAt180 = AMCAX::CurveCalculation::CircleD3(M_PI, defaultFrame2, radius);
	Vector2 tangentAt360 = AMCAX::CurveCalculation::CircleD3(2 * M_PI, defaultFrame2, radius);
	CHECK(tangentAt0.X() == 0.0);
	CHECK(tangentAt0.Y() == -2.0);
	CHECK(tangentAt180.X() == Approx(0.0).margin(1e-14));
	CHECK(tangentAt180.Y() == 2.0 );
	CHECK(tangentAt360.X() == Approx(0.0).margin(1e-14));
	CHECK(tangentAt360.Y() == -2.0 );
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static void CircleD3(double u, const Frame2& pos, double radius, Point2& p, Vector2& v1, Vector2& v2, Vector2& v3)	 @param[out] v3 The third derivative
	 @param[out] v2 The second derivative
	 @param[out] v1 The first derivative
	 @param[out] p The point
	 @param[in] radius The radius
	 @param[in] pos The local frame where the circle lies
	 @param[in] u The parameter
	 @brief Compute the point and the first three derivatives on a 2D circle represented by a local frame and a radius at a parameter
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
using namespace AMCAX;
TEST_CASE("case1: CurveCalculation::CircleD3 1/4 ", "[math][CurveCalculation][P1][CircleD3]") {
	Direction2 defaultDir2(1.0, 0.0);
	Frame2 defaultFrame2(Point2(1.0, 1.0), defaultDir2);
	double radius = 2.0;
	Vector2 tangentAt0 = AMCAX::CurveCalculation::CircleD3(0.0, defaultFrame2, radius);
	Vector2 tangentAt180 = AMCAX::CurveCalculation::CircleD3(M_PI, defaultFrame2, radius);
	Vector2 tangentAt360 = AMCAX::CurveCalculation::CircleD3(2 * M_PI, defaultFrame2, radius);
	CHECK(tangentAt0.X() == 0.0);
	CHECK(tangentAt0.Y() == -2.0);
	CHECK(tangentAt180.X() == Approx(0.0).margin(1e-14));
	CHECK(tangentAt180.Y() == 2.0 );
	CHECK(tangentAt360.X() == Approx(0.0).margin(1e-14));
	CHECK(tangentAt360.Y() == -2.0 );
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] AMCAX_API static Vector3 CircleDN(double u, const Frame3& pos, double radius, int n)	 @return The n-th derivative vector
	 @param n The order of derivative
	 @param radius The radius
	 @param pos The local frame where the circle lies
	 @param u The parameter
	 @brief Compute the n-th derivative on a 3D circle represented by a local frame and a radius at a parameter
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
using namespace AMCAX;
TEST_CASE("case1: CurveCalculation::CircleD3 3/4 ", "[math][CurveCalculation][P1][CircleD3]") {
	Direction3 initialDir(0.0, 0.0, 1.0); 
	Frame3 defaultFrame3(Point3(1.0, 1.0, 0.0), initialDir); 
	double radius = 2.0; 
	Vector3 tangentAt0 = AMCAX::CurveCalculation::CircleD3(0.0, defaultFrame3, radius);
	Vector3 tangentAt90Deg = AMCAX::CurveCalculation::CircleD3(M_PI_2, defaultFrame3, radius);
	Vector3 tangentAt180Deg = AMCAX::CurveCalculation::CircleD3(M_PI, defaultFrame3, radius);
	Vector3 tangentAt270Deg = AMCAX::CurveCalculation::CircleD3(3 * M_PI_2, defaultFrame3, radius);
	Vector3 tangentAt360Deg = AMCAX::CurveCalculation::CircleD3(2 * M_PI, defaultFrame3, radius);
	CHECK(tangentAt0.X() == Approx(0.0));
	CHECK(tangentAt0.Y() == Approx(-2.0));
	CHECK(tangentAt0.Z() == Approx(-0.0));
	CHECK(tangentAt90Deg.X() == Approx(2.0).margin(1e-14));
	CHECK(tangentAt90Deg.Y() == Approx(-0.0).margin(1e-14));
	CHECK(tangentAt90Deg.Z() == Approx(0.0).margin(1e-14));
	CHECK(tangentAt180Deg.X() == Approx(0.0).margin(1e-14));
	CHECK(tangentAt180Deg.Y() == Approx(2.0).margin(1e-14));
	CHECK(tangentAt180Deg.Z() == Approx(0.0));
	CHECK(tangentAt270Deg.X() == Approx(-2.0).margin(1e-14));
	CHECK(tangentAt270Deg.Y() == Approx(0.0).margin(1e-14));
	CHECK(tangentAt270Deg.Z() == Approx(0.0).margin(1e-14));
	CHECK(tangentAt360Deg.X() == Approx(-0.0).margin(1e-14));
	CHECK(tangentAt360Deg.Y() == Approx(-2.0).margin(1e-14));
	CHECK(tangentAt360Deg.Z() == Approx(0.0).margin(1e-14));
	std::cout << "Tangent at 0 deg: " << tangentAt0 << std::endl;
	std::cout << "Tangent at 90 deg: " << tangentAt90Deg << std::endl;
	std::cout << "Tangent at 180 deg: " << tangentAt180Deg << std::endl;
	std::cout << "Tangent at 270 deg: " << tangentAt270Deg << std::endl;
	std::cout << "Tangent at 360 deg: " << tangentAt360Deg << std::endl;
;
	SECTION("2 derivative vector") {
		Vector3  vector3 = CurveCalculation::CircleDN(u, defaultFrame3, radius, 2); 
		std::cout << vector3.X() << " " << vector3.Y() << " " << std::endl;
		CHECK(vector3.X() == -2.0);
		CHECK(vector3.Y() == Approx(0.0).margin(1e-14));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] AMCAX_API static Vector2 CircleDN(double u, const Frame2& pos, double radius, int n)	 @return The n-th derivative vector
	 @param n The order of derivative
	 @param radius The radius
	 @param pos The local frame where the circle lies
	 @param u The parameter
	 @brief Compute the n-th derivative on a 2D circle represented by a local frame and a radius at a parameter
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
using namespace AMCAX;
TEST_CASE("case1: CurveCalculation::CircleD3 3/4 ", "[math][CurveCalculation][P1][CircleD3]") {
	Direction3 initialDir(0.0, 0.0, 1.0); 
	Frame3 defaultFrame3(Point3(1.0, 1.0, 0.0), initialDir); 
	double radius = 2.0; 
	Vector3 tangentAt0 = AMCAX::CurveCalculation::CircleD3(0.0, defaultFrame3, radius);
	Vector3 tangentAt90Deg = AMCAX::CurveCalculation::CircleD3(M_PI_2, defaultFrame3, radius);
	Vector3 tangentAt180Deg = AMCAX::CurveCalculation::CircleD3(M_PI, defaultFrame3, radius);
	Vector3 tangentAt270Deg = AMCAX::CurveCalculation::CircleD3(3 * M_PI_2, defaultFrame3, radius);
	Vector3 tangentAt360Deg = AMCAX::CurveCalculation::CircleD3(2 * M_PI, defaultFrame3, radius);
	CHECK(tangentAt0.X() == Approx(0.0));
	CHECK(tangentAt0.Y() == Approx(-2.0));
	CHECK(tangentAt0.Z() == Approx(-0.0));
	CHECK(tangentAt90Deg.X() == Approx(2.0).margin(1e-14));
	CHECK(tangentAt90Deg.Y() == Approx(-0.0).margin(1e-14));
	CHECK(tangentAt90Deg.Z() == Approx(0.0).margin(1e-14));
	CHECK(tangentAt180Deg.X() == Approx(0.0).margin(1e-14));
	CHECK(tangentAt180Deg.Y() == Approx(2.0).margin(1e-14));
	CHECK(tangentAt180Deg.Z() == Approx(0.0));
	CHECK(tangentAt270Deg.X() == Approx(-2.0).margin(1e-14));
	CHECK(tangentAt270Deg.Y() == Approx(0.0).margin(1e-14));
	CHECK(tangentAt270Deg.Z() == Approx(0.0).margin(1e-14));
	CHECK(tangentAt360Deg.X() == Approx(-0.0).margin(1e-14));
	CHECK(tangentAt360Deg.Y() == Approx(-2.0).margin(1e-14));
	CHECK(tangentAt360Deg.Z() == Approx(0.0).margin(1e-14));
	std::cout << "Tangent at 0 deg: " << tangentAt0 << std::endl;
	std::cout << "Tangent at 90 deg: " << tangentAt90Deg << std::endl;
	std::cout << "Tangent at 180 deg: " << tangentAt180Deg << std::endl;
	std::cout << "Tangent at 270 deg: " << tangentAt270Deg << std::endl;
	std::cout << "Tangent at 360 deg: " << tangentAt360Deg << std::endl;
;
	SECTION("2 derivative vector") {
		Vector2  vector2 = CurveCalculation::CircleDN(u, defaultFrame2, r, 2); 
		std::cout << vector2.X() << " " << vector2.Y() << " " << std::endl;
		CHECK(vector2.X() == -2.0);
		CHECK(vector2.Y() == Approx(0.0).margin(1e-14));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] AMCAX_API static Point3 D0(double u, const Circle3& circle)	 @return The resulting point
	 @param circle The circle
	 @param u The parameter
	 @brief Compute the point on a 3D circle at a parameter
,
 "output":SECTION("u = M_PI") {
		CurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);
		CHECK(p.X() == -1.0);
		CHECK(p.Y() == Approx(1.0));
		CHECK(p.Z() == 0.0);
		CHECK(v1.X() == Approx(0.0).margin(1e-14));
		CHECK(v1.Y() == Approx(-2.0));
		CHECK(v1.Z() == Approx(0.0));
		CHECK(v2.X() == Approx(2.0));
		CHECK(v2.Y() == Approx(0.0).margin(1e-12));
		CHECK(v2.Z() == Approx(0.0));
		CHECK(v3.X() == Approx(0.0).margin(1e-12));
		CHECK(v3.Y() == Approx(2.0));
		CHECK(v3.Z() == Approx(0.0));
	;
	SECTION("from (1.0,0.0) POS enlarge 999 length") {
		Point2 point2 = CurveCalculation::D0(999.0, line2); 
		CHECK(point2.X() == 1000.0);
		CHECK(point2.Y() == 0.0);
	}}
SECTION("u = M_PI") {
		CurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);
		CHECK(p.X() == -1.0);
		CHECK(p.Y() == Approx(1.0));
		CHECK(p.Z() == 0.0);
		CHECK(v1.X() == Approx(0.0).margin(1e-14));
		CHECK(v1.Y() == Approx(-2.0));
		CHECK(v1.Z() == Approx(0.0));
		CHECK(v2.X() == Approx(2.0));
		CHECK(v2.Y() == Approx(0.0).margin(1e-12));
		CHECK(v2.Z() == Approx(0.0));
		CHECK(v3.X() == Approx(0.0).margin(1e-12));
		CHECK(v3.Y() == Approx(2.0));
		CHECK(v3.Z() == Approx(0.0));
	;
	SECTION("u = 4") {
		Point3 point3 = CurveCalculation::D0(4, parabola3);
		CHECK(point3.X() == 2.0);
		CHECK(point3.Y() == 4.0);
		CHECK(point3.Z() == 0.0);
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] AMCAX_API static Point3 D0(double u, const Parabola3& parabola)	 @return The resulting point
	 @param parabola The parabola
	 @param u The parameter
	 @brief Compute the point on a 3D parabola at a parameter
,
 "output":SECTION("u = M_PI") {
		CurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);
		CHECK(p.X() == -1.0);
		CHECK(p.Y() == Approx(1.0));
		CHECK(p.Z() == 0.0);
		CHECK(v1.X() == Approx(0.0).margin(1e-14));
		CHECK(v1.Y() == Approx(-2.0));
		CHECK(v1.Z() == Approx(0.0));
		CHECK(v2.X() == Approx(2.0));
		CHECK(v2.Y() == Approx(0.0).margin(1e-12));
		CHECK(v2.Z() == Approx(0.0));
		CHECK(v3.X() == Approx(0.0).margin(1e-12));
		CHECK(v3.Y() == Approx(2.0));
		CHECK(v3.Z() == Approx(0.0));
	;
	SECTION("from (1.0,0.0) POS enlarge 999 length") {
		Point2 point2 = CurveCalculation::D0(999.0, line2); 
		CHECK(point2.X() == 1000.0);
		CHECK(point2.Y() == 0.0);
	}}
SECTION("u = M_PI") {
		CurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);
		CHECK(p.X() == -1.0);
		CHECK(p.Y() == Approx(1.0));
		CHECK(p.Z() == 0.0);
		CHECK(v1.X() == Approx(0.0).margin(1e-14));
		CHECK(v1.Y() == Approx(-2.0));
		CHECK(v1.Z() == Approx(0.0));
		CHECK(v2.X() == Approx(2.0));
		CHECK(v2.Y() == Approx(0.0).margin(1e-12));
		CHECK(v2.Z() == Approx(0.0));
		CHECK(v3.X() == Approx(0.0).margin(1e-12));
		CHECK(v3.Y() == Approx(2.0));
		CHECK(v3.Z() == Approx(0.0));
	;
	SECTION("+999") {
		Point3 point3 = CurveCalculation::D0(999.0, line3);
		CHECK(point3.X() == 1000.0);
		CHECK(point3.Y() == 0.0);
		CHECK(point3.Z() == 0.0);
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] AMCAX_API static Point2 D0(double u, const Parabola2& parabola)	 @return The resulting point
	 @param parabola The parabola
	 @param u The parameter
	 @brief Compute the point on a 2D parabola at a parameter
,
 "output":SECTION("u = M_PI") {
		CurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);
		CHECK(p.X() == -1.0);
		CHECK(p.Y() == Approx(1.0));
		CHECK(p.Z() == 0.0);
		CHECK(v1.X() == Approx(0.0).margin(1e-14));
		CHECK(v1.Y() == Approx(-2.0));
		CHECK(v1.Z() == Approx(0.0));
		CHECK(v2.X() == Approx(2.0));
		CHECK(v2.Y() == Approx(0.0).margin(1e-12));
		CHECK(v2.Z() == Approx(0.0));
		CHECK(v3.X() == Approx(0.0).margin(1e-12));
		CHECK(v3.Y() == Approx(2.0));
		CHECK(v3.Z() == Approx(0.0));
	;
	SECTION("from (1.0,0.0) POS enlarge 999 length") {
		Point2 point2 = CurveCalculation::D0(999.0, line2); 
		CHECK(point2.X() == 1000.0);
		CHECK(point2.Y() == 0.0);
	}}
SECTION("u = M_PI") {
		CurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);
		CHECK(p.X() == -1.0);
		CHECK(p.Y() == Approx(1.0));
		CHECK(p.Z() == 0.0);
		CHECK(v1.X() == Approx(0.0).margin(1e-14));
		CHECK(v1.Y() == Approx(-2.0));
		CHECK(v1.Z() == Approx(0.0));
		CHECK(v2.X() == Approx(2.0));
		CHECK(v2.Y() == Approx(0.0).margin(1e-12));
		CHECK(v2.Z() == Approx(0.0));
		CHECK(v3.X() == Approx(0.0).margin(1e-12));
		CHECK(v3.Y() == Approx(2.0));
		CHECK(v3.Z() == Approx(0.0));
	;
	SECTION("u = 4") {
		Point2 point2 = CurveCalculation::D0(4, parabola2); 
		CHECK(point2.X() == 2.0);
		CHECK(point2.Y() == 4.0);
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] AMCAX_API static Point2 D0(double u, const Hyperbola2& hyperbola)	 @return The resulting point
	 @param hyperbola The hyperbola
	 @param u The parameter
	 @brief Compute the point on a 2D hyperbola at a parameter
,
 "output":SECTION("u = M_PI") {
		CurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);
		CHECK(p.X() == -1.0);
		CHECK(p.Y() == Approx(1.0));
		CHECK(p.Z() == 0.0);
		CHECK(v1.X() == Approx(0.0).margin(1e-14));
		CHECK(v1.Y() == Approx(-2.0));
		CHECK(v1.Z() == Approx(0.0));
		CHECK(v2.X() == Approx(2.0));
		CHECK(v2.Y() == Approx(0.0).margin(1e-12));
		CHECK(v2.Z() == Approx(0.0));
		CHECK(v3.X() == Approx(0.0).margin(1e-12));
		CHECK(v3.Y() == Approx(2.0));
		CHECK(v3.Z() == Approx(0.0));
	;
	SECTION("from (1.0,0.0) POS enlarge 999 length") {
		Point2 point2 = CurveCalculation::D0(999.0, line2); 
		CHECK(point2.X() == 1000.0);
		CHECK(point2.Y() == 0.0);
	}}
SECTION("u = M_PI") {
		CurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);
		CHECK(p.X() == -1.0);
		CHECK(p.Y() == Approx(1.0));
		CHECK(p.Z() == 0.0);
		CHECK(v1.X() == Approx(0.0).margin(1e-14));
		CHECK(v1.Y() == Approx(-2.0));
		CHECK(v1.Z() == Approx(0.0));
		CHECK(v2.X() == Approx(2.0));
		CHECK(v2.Y() == Approx(0.0).margin(1e-12));
		CHECK(v2.Z() == Approx(0.0));
		CHECK(v3.X() == Approx(0.0).margin(1e-12));
		CHECK(v3.Y() == Approx(2.0));
		CHECK(v3.Z() == Approx(0.0));
	;
	SECTION("+999") {
		Point3 point3 = CurveCalculation::D0(999.0, line3);
		CHECK(point3.X() == 1000.0);
		CHECK(point3.Y() == 0.0);
		CHECK(point3.Z() == 0.0);
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] AMCAX_API static Vector3 D1(double u, const Line3& line)	 @return The first derivative vector
	 @param line The line
	 @param u The parameter
	 @brief Compute the first derivative on a 3D line at a parameter
,
 "output":SECTION("u = M_PI") {
		CurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);
		CHECK(p.X() == -1.0);
		CHECK(p.Y() == Approx(1.0));
		CHECK(p.Z() == 0.0);
		CHECK(v1.X() == Approx(0.0).margin(1e-14));
		CHECK(v1.Y() == Approx(-2.0));
		CHECK(v1.Z() == Approx(0.0));
		CHECK(v2.X() == Approx(2.0));
		CHECK(v2.Y() == Approx(0.0).margin(1e-12));
		CHECK(v2.Z() == Approx(0.0));
		CHECK(v3.X() == Approx(0.0).margin(1e-12));
		CHECK(v3.Y() == Approx(2.0));
		CHECK(v3.Z() == Approx(0.0));
	;
	SECTION("from (1.0,0.0) POS enlarge 999 length") {
		Point2 point2 = CurveCalculation::D0(999.0, line2); 
		CHECK(point2.X() == 1000.0);
		CHECK(point2.Y() == 0.0);
	}}
SECTION("u = M_PI") {
		CurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);
		CHECK(p.X() == -1.0);
		CHECK(p.Y() == Approx(1.0));
		CHECK(p.Z() == 0.0);
		CHECK(v1.X() == Approx(0.0).margin(1e-14));
		CHECK(v1.Y() == Approx(-2.0));
		CHECK(v1.Z() == Approx(0.0));
		CHECK(v2.X() == Approx(2.0));
		CHECK(v2.Y() == Approx(0.0).margin(1e-12));
		CHECK(v2.Z() == Approx(0.0));
		CHECK(v3.X() == Approx(0.0).margin(1e-12));
		CHECK(v3.Y() == Approx(2.0));
		CHECK(v3.Z() == Approx(0.0));
	;
	SECTION("u = M_PI") {
		CurveCalculation::D1(M_PI, circle2,p,v);
		CHECK(p.X() == -1.0);
		CHECK(p.Y() == Approx(1.0));
		CHECK(v.X() == Approx(0.0).margin(1e-14));
		CHECK(v.Y() == Approx(-2.0));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static void D1(double u, const Line3& line, Point3& p, Vector3& v1)	 @param[out] v1 The first derivative
	 @param[out] p The point
	 @param[in] line The line
	 @param[in] u The parameter
	 @brief Compute the point and the first derivative on a 3D line at a parameter
,
 "output":SECTION("u = M_PI") {
		CurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);
		CHECK(p.X() == -1.0);
		CHECK(p.Y() == Approx(1.0));
		CHECK(p.Z() == 0.0);
		CHECK(v1.X() == Approx(0.0).margin(1e-14));
		CHECK(v1.Y() == Approx(-2.0));
		CHECK(v1.Z() == Approx(0.0));
		CHECK(v2.X() == Approx(2.0));
		CHECK(v2.Y() == Approx(0.0).margin(1e-12));
		CHECK(v2.Z() == Approx(0.0));
		CHECK(v3.X() == Approx(0.0).margin(1e-12));
		CHECK(v3.Y() == Approx(2.0));
		CHECK(v3.Z() == Approx(0.0));
	;
	SECTION("from (1.0,0.0) POS enlarge 999 length") {
		Point2 point2 = CurveCalculation::D0(999.0, line2); 
		CHECK(point2.X() == 1000.0);
		CHECK(point2.Y() == 0.0);
	}}
SECTION("u = M_PI") {
		CurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);
		CHECK(p.X() == -1.0);
		CHECK(p.Y() == Approx(1.0));
		CHECK(p.Z() == 0.0);
		CHECK(v1.X() == Approx(0.0).margin(1e-14));
		CHECK(v1.Y() == Approx(-2.0));
		CHECK(v1.Z() == Approx(0.0));
		CHECK(v2.X() == Approx(2.0));
		CHECK(v2.Y() == Approx(0.0).margin(1e-12));
		CHECK(v2.Z() == Approx(0.0));
		CHECK(v3.X() == Approx(0.0).margin(1e-12));
		CHECK(v3.Y() == Approx(2.0));
		CHECK(v3.Z() == Approx(0.0));
	;
	SECTION("u = M_PI") {
		CurveCalculation::D1(M_PI, circle2,p,v);
		CHECK(p.X() == -1.0);
		CHECK(p.Y() == Approx(1.0));
		CHECK(v.X() == Approx(0.0).margin(1e-14));
		CHECK(v.Y() == Approx(-2.0));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] AMCAX_API static Vector3 D1(double u, const Circle3& circle)	 @return The first derivative vector
	 @param circle The circle
	 @param u The parameter
	 @brief Compute the first derivative on a 3D circle at a parameter
,
 "output":SECTION("u = M_PI") {
		CurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);
		CHECK(p.X() == -1.0);
		CHECK(p.Y() == Approx(1.0));
		CHECK(p.Z() == 0.0);
		CHECK(v1.X() == Approx(0.0).margin(1e-14));
		CHECK(v1.Y() == Approx(-2.0));
		CHECK(v1.Z() == Approx(0.0));
		CHECK(v2.X() == Approx(2.0));
		CHECK(v2.Y() == Approx(0.0).margin(1e-12));
		CHECK(v2.Z() == Approx(0.0));
		CHECK(v3.X() == Approx(0.0).margin(1e-12));
		CHECK(v3.Y() == Approx(2.0));
		CHECK(v3.Z() == Approx(0.0));
	;
	SECTION("from (1.0,0.0) POS enlarge 999 length") {
		Point2 point2 = CurveCalculation::D0(999.0, line2); 
		CHECK(point2.X() == 1000.0);
		CHECK(point2.Y() == 0.0);
	}}
SECTION("u = M_PI") {
		CurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);
		CHECK(p.X() == -1.0);
		CHECK(p.Y() == Approx(1.0));
		CHECK(p.Z() == 0.0);
		CHECK(v1.X() == Approx(0.0).margin(1e-14));
		CHECK(v1.Y() == Approx(-2.0));
		CHECK(v1.Z() == Approx(0.0));
		CHECK(v2.X() == Approx(2.0));
		CHECK(v2.Y() == Approx(0.0).margin(1e-12));
		CHECK(v2.Z() == Approx(0.0));
		CHECK(v3.X() == Approx(0.0).margin(1e-12));
		CHECK(v3.Y() == Approx(2.0));
		CHECK(v3.Z() == Approx(0.0));
	;
	SECTION("u = M_PI") {
		Vector3 vector3 = CurveCalculation::D1(M_PI, circle3);
		CHECK(vector3.X() == Approx(0.0).margin(1e-14));
		CHECK(vector3.Y() == Approx(-2.0));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static void D1(double u, const Circle3& circle, Point3& p, Vector3& v1)	 @param[out] v1 The first derivative
	 @param[out] p The point
	 @param[in] circle The circle
	 @param[in] u The parameter
	 @brief Compute the point and the first derivative on a 3D circle at a parameter
,
 "output":SECTION("u = M_PI") {
		CurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);
		CHECK(p.X() == -1.0);
		CHECK(p.Y() == Approx(1.0));
		CHECK(p.Z() == 0.0);
		CHECK(v1.X() == Approx(0.0).margin(1e-14));
		CHECK(v1.Y() == Approx(-2.0));
		CHECK(v1.Z() == Approx(0.0));
		CHECK(v2.X() == Approx(2.0));
		CHECK(v2.Y() == Approx(0.0).margin(1e-12));
		CHECK(v2.Z() == Approx(0.0));
		CHECK(v3.X() == Approx(0.0).margin(1e-12));
		CHECK(v3.Y() == Approx(2.0));
		CHECK(v3.Z() == Approx(0.0));
	;
	SECTION("from (1.0,0.0) POS enlarge 999 length") {
		Point2 point2 = CurveCalculation::D0(999.0, line2); 
		CHECK(point2.X() == 1000.0);
		CHECK(point2.Y() == 0.0);
	}}
SECTION("u = M_PI") {
		CurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);
		CHECK(p.X() == -1.0);
		CHECK(p.Y() == Approx(1.0));
		CHECK(p.Z() == 0.0);
		CHECK(v1.X() == Approx(0.0).margin(1e-14));
		CHECK(v1.Y() == Approx(-2.0));
		CHECK(v1.Z() == Approx(0.0));
		CHECK(v2.X() == Approx(2.0));
		CHECK(v2.Y() == Approx(0.0).margin(1e-12));
		CHECK(v2.Z() == Approx(0.0));
		CHECK(v3.X() == Approx(0.0).margin(1e-12));
		CHECK(v3.Y() == Approx(2.0));
		CHECK(v3.Z() == Approx(0.0));
	;
	SECTION("u = M_PI") {
		CurveCalculation::D1(M_PI, circle2,p,v);
		CHECK(p.X() == -1.0);
		CHECK(p.Y() == Approx(1.0));
		CHECK(v.X() == Approx(0.0).margin(1e-14));
		CHECK(v.Y() == Approx(-2.0));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] AMCAX_API static Vector3 D1(double u, const Ellipse3& ellipse)	 @return The first derivative vector
	 @param ellipse The ellipse
	 @param u The parameter
	 @brief Compute the first derivative on a 3D ellipse at a parameter
,
 "output":SECTION("u = M_PI") {
		CurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);
		CHECK(p.X() == -1.0);
		CHECK(p.Y() == Approx(1.0));
		CHECK(p.Z() == 0.0);
		CHECK(v1.X() == Approx(0.0).margin(1e-14));
		CHECK(v1.Y() == Approx(-2.0));
		CHECK(v1.Z() == Approx(0.0));
		CHECK(v2.X() == Approx(2.0));
		CHECK(v2.Y() == Approx(0.0).margin(1e-12));
		CHECK(v2.Z() == Approx(0.0));
		CHECK(v3.X() == Approx(0.0).margin(1e-12));
		CHECK(v3.Y() == Approx(2.0));
		CHECK(v3.Z() == Approx(0.0));
	;
	SECTION("from (1.0,0.0) POS enlarge 999 length") {
		Point2 point2 = CurveCalculation::D0(999.0, line2); 
		CHECK(point2.X() == 1000.0);
		CHECK(point2.Y() == 0.0);
	}}
SECTION("u = M_PI") {
		CurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);
		CHECK(p.X() == -1.0);
		CHECK(p.Y() == Approx(1.0));
		CHECK(p.Z() == 0.0);
		CHECK(v1.X() == Approx(0.0).margin(1e-14));
		CHECK(v1.Y() == Approx(-2.0));
		CHECK(v1.Z() == Approx(0.0));
		CHECK(v2.X() == Approx(2.0));
		CHECK(v2.Y() == Approx(0.0).margin(1e-12));
		CHECK(v2.Z() == Approx(0.0));
		CHECK(v3.X() == Approx(0.0).margin(1e-12));
		CHECK(v3.Y() == Approx(2.0));
		CHECK(v3.Z() == Approx(0.0));
	;
	SECTION("u = M_PI") {
		Vector3 vector3 = CurveCalculation::D1(M_PI, circle3);
		CHECK(vector3.X() == Approx(0.0).margin(1e-14));
		CHECK(vector3.Y() == Approx(-2.0));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static void D1(double u, const Ellipse3& ellipse, Point3& p, Vector3& v1)	 @param[out] v1 The first derivative
	 @param[out] p The point
	 @param[in] ellipse The ellipse
	 @param[in] u The parameter
	 @brief Compute the point and the first derivative on a 3D ellipse at a parameter
,
 "output":SECTION("u = M_PI") {
		CurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);
		CHECK(p.X() == -1.0);
		CHECK(p.Y() == Approx(1.0));
		CHECK(p.Z() == 0.0);
		CHECK(v1.X() == Approx(0.0).margin(1e-14));
		CHECK(v1.Y() == Approx(-2.0));
		CHECK(v1.Z() == Approx(0.0));
		CHECK(v2.X() == Approx(2.0));
		CHECK(v2.Y() == Approx(0.0).margin(1e-12));
		CHECK(v2.Z() == Approx(0.0));
		CHECK(v3.X() == Approx(0.0).margin(1e-12));
		CHECK(v3.Y() == Approx(2.0));
		CHECK(v3.Z() == Approx(0.0));
	;
	SECTION("from (1.0,0.0) POS enlarge 999 length") {
		Point2 point2 = CurveCalculation::D0(999.0, line2); 
		CHECK(point2.X() == 1000.0);
		CHECK(point2.Y() == 0.0);
	}}
SECTION("u = M_PI") {
		CurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);
		CHECK(p.X() == -1.0);
		CHECK(p.Y() == Approx(1.0));
		CHECK(p.Z() == 0.0);
		CHECK(v1.X() == Approx(0.0).margin(1e-14));
		CHECK(v1.Y() == Approx(-2.0));
		CHECK(v1.Z() == Approx(0.0));
		CHECK(v2.X() == Approx(2.0));
		CHECK(v2.Y() == Approx(0.0).margin(1e-12));
		CHECK(v2.Z() == Approx(0.0));
		CHECK(v3.X() == Approx(0.0).margin(1e-12));
		CHECK(v3.Y() == Approx(2.0));
		CHECK(v3.Z() == Approx(0.0));
	;
	SECTION("u = M_PI") {
		CurveCalculation::D1(M_PI, circle2,p,v);
		CHECK(p.X() == -1.0);
		CHECK(p.Y() == Approx(1.0));
		CHECK(v.X() == Approx(0.0).margin(1e-14));
		CHECK(v.Y() == Approx(-2.0));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] AMCAX_API static Vector3 D1(double u, const Parabola3& parabola)	 @return The first derivative vector
	 @param parabola The parabola
	 @param u The parameter
	 @brief Compute the first derivative on a 3D parabola at a parameter
,
 "output":SECTION("u = M_PI") {
		CurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);
		CHECK(p.X() == -1.0);
		CHECK(p.Y() == Approx(1.0));
		CHECK(p.Z() == 0.0);
		CHECK(v1.X() == Approx(0.0).margin(1e-14));
		CHECK(v1.Y() == Approx(-2.0));
		CHECK(v1.Z() == Approx(0.0));
		CHECK(v2.X() == Approx(2.0));
		CHECK(v2.Y() == Approx(0.0).margin(1e-12));
		CHECK(v2.Z() == Approx(0.0));
		CHECK(v3.X() == Approx(0.0).margin(1e-12));
		CHECK(v3.Y() == Approx(2.0));
		CHECK(v3.Z() == Approx(0.0));
	;
	SECTION("from (1.0,0.0) POS enlarge 999 length") {
		Point2 point2 = CurveCalculation::D0(999.0, line2); 
		CHECK(point2.X() == 1000.0);
		CHECK(point2.Y() == 0.0);
	}}
SECTION("u = M_PI") {
		CurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);
		CHECK(p.X() == -1.0);
		CHECK(p.Y() == Approx(1.0));
		CHECK(p.Z() == 0.0);
		CHECK(v1.X() == Approx(0.0).margin(1e-14));
		CHECK(v1.Y() == Approx(-2.0));
		CHECK(v1.Z() == Approx(0.0));
		CHECK(v2.X() == Approx(2.0));
		CHECK(v2.Y() == Approx(0.0).margin(1e-12));
		CHECK(v2.Z() == Approx(0.0));
		CHECK(v3.X() == Approx(0.0).margin(1e-12));
		CHECK(v3.Y() == Approx(2.0));
		CHECK(v3.Z() == Approx(0.0));
	;
	SECTION("u = M_PI") {
		Vector3 vector3 = CurveCalculation::D1(M_PI, circle3);
		CHECK(vector3.X() == Approx(0.0).margin(1e-14));
		CHECK(vector3.Y() == Approx(-2.0));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static void D1(double u, const Parabola3& parabola, Point3& p, Vector3& v1)	 @param[out] v1 The first derivative
	 @param[out] p The point
	 @param[in] parabola The parabola
	 @param[in] u The parameter
	 @brief Compute the point and the first derivative on a 3D parabola at a parameter
,
 "output":SECTION("u = M_PI") {
		CurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);
		CHECK(p.X() == -1.0);
		CHECK(p.Y() == Approx(1.0));
		CHECK(p.Z() == 0.0);
		CHECK(v1.X() == Approx(0.0).margin(1e-14));
		CHECK(v1.Y() == Approx(-2.0));
		CHECK(v1.Z() == Approx(0.0));
		CHECK(v2.X() == Approx(2.0));
		CHECK(v2.Y() == Approx(0.0).margin(1e-12));
		CHECK(v2.Z() == Approx(0.0));
		CHECK(v3.X() == Approx(0.0).margin(1e-12));
		CHECK(v3.Y() == Approx(2.0));
		CHECK(v3.Z() == Approx(0.0));
	;
	SECTION("from (1.0,0.0) POS enlarge 999 length") {
		Point2 point2 = CurveCalculation::D0(999.0, line2); 
		CHECK(point2.X() == 1000.0);
		CHECK(point2.Y() == 0.0);
	}}
SECTION("u = M_PI") {
		CurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);
		CHECK(p.X() == -1.0);
		CHECK(p.Y() == Approx(1.0));
		CHECK(p.Z() == 0.0);
		CHECK(v1.X() == Approx(0.0).margin(1e-14));
		CHECK(v1.Y() == Approx(-2.0));
		CHECK(v1.Z() == Approx(0.0));
		CHECK(v2.X() == Approx(2.0));
		CHECK(v2.Y() == Approx(0.0).margin(1e-12));
		CHECK(v2.Z() == Approx(0.0));
		CHECK(v3.X() == Approx(0.0).margin(1e-12));
		CHECK(v3.Y() == Approx(2.0));
		CHECK(v3.Z() == Approx(0.0));
	;
	SECTION("u = M_PI") {
		CurveCalculation::D1(M_PI, circle2,p,v);
		CHECK(p.X() == -1.0);
		CHECK(p.Y() == Approx(1.0));
		CHECK(v.X() == Approx(0.0).margin(1e-14));
		CHECK(v.Y() == Approx(-2.0));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] AMCAX_API static Vector3 D1(double u, const Hyperbola3& hyperbola)	 @return The first derivative vector
	 @param hyperbola The hyperbola
	 @param u The parameter
	 @brief Compute the first derivative on a 3D hyperbola at a parameter
,
 "output":SECTION("u = M_PI") {
		CurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);
		CHECK(p.X() == -1.0);
		CHECK(p.Y() == Approx(1.0));
		CHECK(p.Z() == 0.0);
		CHECK(v1.X() == Approx(0.0).margin(1e-14));
		CHECK(v1.Y() == Approx(-2.0));
		CHECK(v1.Z() == Approx(0.0));
		CHECK(v2.X() == Approx(2.0));
		CHECK(v2.Y() == Approx(0.0).margin(1e-12));
		CHECK(v2.Z() == Approx(0.0));
		CHECK(v3.X() == Approx(0.0).margin(1e-12));
		CHECK(v3.Y() == Approx(2.0));
		CHECK(v3.Z() == Approx(0.0));
	;
	SECTION("from (1.0,0.0) POS enlarge 999 length") {
		Point2 point2 = CurveCalculation::D0(999.0, line2); 
		CHECK(point2.X() == 1000.0);
		CHECK(point2.Y() == 0.0);
	}}
SECTION("u = M_PI") {
		CurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);
		CHECK(p.X() == -1.0);
		CHECK(p.Y() == Approx(1.0));
		CHECK(p.Z() == 0.0);
		CHECK(v1.X() == Approx(0.0).margin(1e-14));
		CHECK(v1.Y() == Approx(-2.0));
		CHECK(v1.Z() == Approx(0.0));
		CHECK(v2.X() == Approx(2.0));
		CHECK(v2.Y() == Approx(0.0).margin(1e-12));
		CHECK(v2.Z() == Approx(0.0));
		CHECK(v3.X() == Approx(0.0).margin(1e-12));
		CHECK(v3.Y() == Approx(2.0));
		CHECK(v3.Z() == Approx(0.0));
	;
	SECTION("u = M_PI") {
		Vector3 vector3 = CurveCalculation::D1(M_PI, circle3);
		CHECK(vector3.X() == Approx(0.0).margin(1e-14));
		CHECK(vector3.Y() == Approx(-2.0));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static void D1(double u, const Hyperbola3& hyperbola, Point3& p, Vector3& v1)	 @param[out] v1 The first derivative
	 @param[out] p The point
	 @param[in] hyperbola The hyperbola
	 @param[in] u The parameter
	 @brief Compute the point and the first derivative on a 3D hyperbola at a parameter
,
 "output":SECTION("u = M_PI") {
		CurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);
		CHECK(p.X() == -1.0);
		CHECK(p.Y() == Approx(1.0));
		CHECK(p.Z() == 0.0);
		CHECK(v1.X() == Approx(0.0).margin(1e-14));
		CHECK(v1.Y() == Approx(-2.0));
		CHECK(v1.Z() == Approx(0.0));
		CHECK(v2.X() == Approx(2.0));
		CHECK(v2.Y() == Approx(0.0).margin(1e-12));
		CHECK(v2.Z() == Approx(0.0));
		CHECK(v3.X() == Approx(0.0).margin(1e-12));
		CHECK(v3.Y() == Approx(2.0));
		CHECK(v3.Z() == Approx(0.0));
	;
	SECTION("from (1.0,0.0) POS enlarge 999 length") {
		Point2 point2 = CurveCalculation::D0(999.0, line2); 
		CHECK(point2.X() == 1000.0);
		CHECK(point2.Y() == 0.0);
	}}
SECTION("u = M_PI") {
		CurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);
		CHECK(p.X() == -1.0);
		CHECK(p.Y() == Approx(1.0));
		CHECK(p.Z() == 0.0);
		CHECK(v1.X() == Approx(0.0).margin(1e-14));
		CHECK(v1.Y() == Approx(-2.0));
		CHECK(v1.Z() == Approx(0.0));
		CHECK(v2.X() == Approx(2.0));
		CHECK(v2.Y() == Approx(0.0).margin(1e-12));
		CHECK(v2.Z() == Approx(0.0));
		CHECK(v3.X() == Approx(0.0).margin(1e-12));
		CHECK(v3.Y() == Approx(2.0));
		CHECK(v3.Z() == Approx(0.0));
	;
	SECTION("u = M_PI") {
		CurveCalculation::D1(M_PI, circle2,p,v);
		CHECK(p.X() == -1.0);
		CHECK(p.Y() == Approx(1.0));
		CHECK(v.X() == Approx(0.0).margin(1e-14));
		CHECK(v.Y() == Approx(-2.0));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] AMCAX_API static Vector2 D1(double u, const Line2& line)	 @return The first derivative vector
	 @param line The line
	 @param u The parameter
	 @brief Compute the first derivative on a 2D line at a parameter
,
 "output":SECTION("u = M_PI") {
		CurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);
		CHECK(p.X() == -1.0);
		CHECK(p.Y() == Approx(1.0));
		CHECK(p.Z() == 0.0);
		CHECK(v1.X() == Approx(0.0).margin(1e-14));
		CHECK(v1.Y() == Approx(-2.0));
		CHECK(v1.Z() == Approx(0.0));
		CHECK(v2.X() == Approx(2.0));
		CHECK(v2.Y() == Approx(0.0).margin(1e-12));
		CHECK(v2.Z() == Approx(0.0));
		CHECK(v3.X() == Approx(0.0).margin(1e-12));
		CHECK(v3.Y() == Approx(2.0));
		CHECK(v3.Z() == Approx(0.0));
	;
	SECTION("from (1.0,0.0) POS enlarge 999 length") {
		Point2 point2 = CurveCalculation::D0(999.0, line2); 
		CHECK(point2.X() == 1000.0);
		CHECK(point2.Y() == 0.0);
	}}
SECTION("u = M_PI") {
		CurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);
		CHECK(p.X() == -1.0);
		CHECK(p.Y() == Approx(1.0));
		CHECK(p.Z() == 0.0);
		CHECK(v1.X() == Approx(0.0).margin(1e-14));
		CHECK(v1.Y() == Approx(-2.0));
		CHECK(v1.Z() == Approx(0.0));
		CHECK(v2.X() == Approx(2.0));
		CHECK(v2.Y() == Approx(0.0).margin(1e-12));
		CHECK(v2.Z() == Approx(0.0));
		CHECK(v3.X() == Approx(0.0).margin(1e-12));
		CHECK(v3.Y() == Approx(2.0));
		CHECK(v3.Z() == Approx(0.0));
	;
	SECTION("u = M_PI") {
		Vector2 vector2 = CurveCalculation::D1(M_PI, circle2);
		CHECK(vector2.X() == Approx(-0.0).margin(1e-12));
		CHECK(vector2.Y() == -2.0);
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static void D1(double u, const Line2& line, Point2& p, Vector2& v1)	 @param[out] v1 The first derivative
	 @param[out] p The point
	 @param[in] line The line
	 @param[in] u The parameter
	 @brief Compute the point and the first derivative on a 2D line at a parameter
,
 "output":SECTION("u = M_PI") {
		CurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);
		CHECK(p.X() == -1.0);
		CHECK(p.Y() == Approx(1.0));
		CHECK(p.Z() == 0.0);
		CHECK(v1.X() == Approx(0.0).margin(1e-14));
		CHECK(v1.Y() == Approx(-2.0));
		CHECK(v1.Z() == Approx(0.0));
		CHECK(v2.X() == Approx(2.0));
		CHECK(v2.Y() == Approx(0.0).margin(1e-12));
		CHECK(v2.Z() == Approx(0.0));
		CHECK(v3.X() == Approx(0.0).margin(1e-12));
		CHECK(v3.Y() == Approx(2.0));
		CHECK(v3.Z() == Approx(0.0));
	;
	SECTION("from (1.0,0.0) POS enlarge 999 length") {
		Point2 point2 = CurveCalculation::D0(999.0, line2); 
		CHECK(point2.X() == 1000.0);
		CHECK(point2.Y() == 0.0);
	}}
SECTION("u = M_PI") {
		CurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);
		CHECK(p.X() == -1.0);
		CHECK(p.Y() == Approx(1.0));
		CHECK(p.Z() == 0.0);
		CHECK(v1.X() == Approx(0.0).margin(1e-14));
		CHECK(v1.Y() == Approx(-2.0));
		CHECK(v1.Z() == Approx(0.0));
		CHECK(v2.X() == Approx(2.0));
		CHECK(v2.Y() == Approx(0.0).margin(1e-12));
		CHECK(v2.Z() == Approx(0.0));
		CHECK(v3.X() == Approx(0.0).margin(1e-12));
		CHECK(v3.Y() == Approx(2.0));
		CHECK(v3.Z() == Approx(0.0));
	;
	SECTION("u = M_PI") {
		CurveCalculation::D1(M_PI, circle2,p,v);
		CHECK(p.X() == -1.0);
		CHECK(p.Y() == Approx(1.0));
		CHECK(v.X() == Approx(0.0).margin(1e-14));
		CHECK(v.Y() == Approx(-2.0));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] AMCAX_API static Vector2 D1(double u, const Circle2& circle)	 @return The first derivative vector
	 @param circle The circle
	 @param u The parameter
	 @brief Compute the first derivative on a 2D circle at a parameter
,
 "output":SECTION("u = M_PI") {
		CurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);
		CHECK(p.X() == -1.0);
		CHECK(p.Y() == Approx(1.0));
		CHECK(p.Z() == 0.0);
		CHECK(v1.X() == Approx(0.0).margin(1e-14));
		CHECK(v1.Y() == Approx(-2.0));
		CHECK(v1.Z() == Approx(0.0));
		CHECK(v2.X() == Approx(2.0));
		CHECK(v2.Y() == Approx(0.0).margin(1e-12));
		CHECK(v2.Z() == Approx(0.0));
		CHECK(v3.X() == Approx(0.0).margin(1e-12));
		CHECK(v3.Y() == Approx(2.0));
		CHECK(v3.Z() == Approx(0.0));
	;
	SECTION("from (1.0,0.0) POS enlarge 999 length") {
		Point2 point2 = CurveCalculation::D0(999.0, line2); 
		CHECK(point2.X() == 1000.0);
		CHECK(point2.Y() == 0.0);
	}}
SECTION("u = M_PI") {
		CurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);
		CHECK(p.X() == -1.0);
		CHECK(p.Y() == Approx(1.0));
		CHECK(p.Z() == 0.0);
		CHECK(v1.X() == Approx(0.0).margin(1e-14));
		CHECK(v1.Y() == Approx(-2.0));
		CHECK(v1.Z() == Approx(0.0));
		CHECK(v2.X() == Approx(2.0));
		CHECK(v2.Y() == Approx(0.0).margin(1e-12));
		CHECK(v2.Z() == Approx(0.0));
		CHECK(v3.X() == Approx(0.0).margin(1e-12));
		CHECK(v3.Y() == Approx(2.0));
		CHECK(v3.Z() == Approx(0.0));
	;
	SECTION("u = M_PI") {
		Vector2 vector2 = CurveCalculation::D1(M_PI, circle2);
		CHECK(vector2.X() == Approx(-0.0).margin(1e-12));
		CHECK(vector2.Y() == -2.0);
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static void D1(double u, const Circle2& circle, Point2& p, Vector2& v1)	 @param[out] v1 The first derivative
	 @param[out] p The point
	 @param[in] circle The circle
	 @param[in] u The parameter
	 @brief Compute the point and the first derivative on a 2D circle at a parameter
,
 "output":SECTION("u = M_PI") {
		CurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);
		CHECK(p.X() == -1.0);
		CHECK(p.Y() == Approx(1.0));
		CHECK(p.Z() == 0.0);
		CHECK(v1.X() == Approx(0.0).margin(1e-14));
		CHECK(v1.Y() == Approx(-2.0));
		CHECK(v1.Z() == Approx(0.0));
		CHECK(v2.X() == Approx(2.0));
		CHECK(v2.Y() == Approx(0.0).margin(1e-12));
		CHECK(v2.Z() == Approx(0.0));
		CHECK(v3.X() == Approx(0.0).margin(1e-12));
		CHECK(v3.Y() == Approx(2.0));
		CHECK(v3.Z() == Approx(0.0));
	;
	SECTION("from (1.0,0.0) POS enlarge 999 length") {
		Point2 point2 = CurveCalculation::D0(999.0, line2); 
		CHECK(point2.X() == 1000.0);
		CHECK(point2.Y() == 0.0);
	}}
SECTION("u = M_PI") {
		CurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);
		CHECK(p.X() == -1.0);
		CHECK(p.Y() == Approx(1.0));
		CHECK(p.Z() == 0.0);
		CHECK(v1.X() == Approx(0.0).margin(1e-14));
		CHECK(v1.Y() == Approx(-2.0));
		CHECK(v1.Z() == Approx(0.0));
		CHECK(v2.X() == Approx(2.0));
		CHECK(v2.Y() == Approx(0.0).margin(1e-12));
		CHECK(v2.Z() == Approx(0.0));
		CHECK(v3.X() == Approx(0.0).margin(1e-12));
		CHECK(v3.Y() == Approx(2.0));
		CHECK(v3.Z() == Approx(0.0));
	;
	SECTION("u = M_PI") {
		CurveCalculation::D1(M_PI, circle2,p,v);
		CHECK(p.X() == -1.0);
		CHECK(p.Y() == Approx(1.0));
		CHECK(v.X() == Approx(0.0).margin(1e-14));
		CHECK(v.Y() == Approx(-2.0));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] AMCAX_API static Vector2 D1(double u, const Ellipse2& ellipse)	 @return The first derivative vector
	 @param ellipse The ellipse
	 @param u The parameter
	 @brief Compute the first derivative on a 2D ellipse at a parameter
,
 "output":SECTION("u = M_PI") {
		CurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);
		CHECK(p.X() == -1.0);
		CHECK(p.Y() == Approx(1.0));
		CHECK(p.Z() == 0.0);
		CHECK(v1.X() == Approx(0.0).margin(1e-14));
		CHECK(v1.Y() == Approx(-2.0));
		CHECK(v1.Z() == Approx(0.0));
		CHECK(v2.X() == Approx(2.0));
		CHECK(v2.Y() == Approx(0.0).margin(1e-12));
		CHECK(v2.Z() == Approx(0.0));
		CHECK(v3.X() == Approx(0.0).margin(1e-12));
		CHECK(v3.Y() == Approx(2.0));
		CHECK(v3.Z() == Approx(0.0));
	;
	SECTION("from (1.0,0.0) POS enlarge 999 length") {
		Point2 point2 = CurveCalculation::D0(999.0, line2); 
		CHECK(point2.X() == 1000.0);
		CHECK(point2.Y() == 0.0);
	}}
SECTION("u = M_PI") {
		CurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);
		CHECK(p.X() == -1.0);
		CHECK(p.Y() == Approx(1.0));
		CHECK(p.Z() == 0.0);
		CHECK(v1.X() == Approx(0.0).margin(1e-14));
		CHECK(v1.Y() == Approx(-2.0));
		CHECK(v1.Z() == Approx(0.0));
		CHECK(v2.X() == Approx(2.0));
		CHECK(v2.Y() == Approx(0.0).margin(1e-12));
		CHECK(v2.Z() == Approx(0.0));
		CHECK(v3.X() == Approx(0.0).margin(1e-12));
		CHECK(v3.Y() == Approx(2.0));
		CHECK(v3.Z() == Approx(0.0));
	;
	SECTION("u = M_PI") {
		Vector2 vector2 = CurveCalculation::D1(M_PI, circle2);
		CHECK(vector2.X() == Approx(-0.0).margin(1e-12));
		CHECK(vector2.Y() == -2.0);
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static void D1(double u, const Ellipse2& ellipse, Point2& p, Vector2& v1)	 @param[out] v1 The first derivative
	 @param[out] p The point
	 @param[in] ellipse The ellipse
	 @param[in] u The parameter
	 @brief Compute the point and the first derivative on a 2D ellipse at a parameter
,
 "output":SECTION("u = M_PI") {
		CurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);
		CHECK(p.X() == -1.0);
		CHECK(p.Y() == Approx(1.0));
		CHECK(p.Z() == 0.0);
		CHECK(v1.X() == Approx(0.0).margin(1e-14));
		CHECK(v1.Y() == Approx(-2.0));
		CHECK(v1.Z() == Approx(0.0));
		CHECK(v2.X() == Approx(2.0));
		CHECK(v2.Y() == Approx(0.0).margin(1e-12));
		CHECK(v2.Z() == Approx(0.0));
		CHECK(v3.X() == Approx(0.0).margin(1e-12));
		CHECK(v3.Y() == Approx(2.0));
		CHECK(v3.Z() == Approx(0.0));
	;
	SECTION("from (1.0,0.0) POS enlarge 999 length") {
		Point2 point2 = CurveCalculation::D0(999.0, line2); 
		CHECK(point2.X() == 1000.0);
		CHECK(point2.Y() == 0.0);
	}}
SECTION("u = M_PI") {
		CurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);
		CHECK(p.X() == -1.0);
		CHECK(p.Y() == Approx(1.0));
		CHECK(p.Z() == 0.0);
		CHECK(v1.X() == Approx(0.0).margin(1e-14));
		CHECK(v1.Y() == Approx(-2.0));
		CHECK(v1.Z() == Approx(0.0));
		CHECK(v2.X() == Approx(2.0));
		CHECK(v2.Y() == Approx(0.0).margin(1e-12));
		CHECK(v2.Z() == Approx(0.0));
		CHECK(v3.X() == Approx(0.0).margin(1e-12));
		CHECK(v3.Y() == Approx(2.0));
		CHECK(v3.Z() == Approx(0.0));
	;
	SECTION("u = M_PI") {
		CurveCalculation::D1(M_PI, circle2,p,v);
		CHECK(p.X() == -1.0);
		CHECK(p.Y() == Approx(1.0));
		CHECK(v.X() == Approx(0.0).margin(1e-14));
		CHECK(v.Y() == Approx(-2.0));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] AMCAX_API static Vector2 D1(double u, const Parabola2& parabola)	 @return The first derivative vector
	 @param parabola The parabola
	 @param u The parameter
	 @brief Compute the first derivative on a 2D parabola at a parameter
,
 "output":SECTION("u = M_PI") {
		CurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);
		CHECK(p.X() == -1.0);
		CHECK(p.Y() == Approx(1.0));
		CHECK(p.Z() == 0.0);
		CHECK(v1.X() == Approx(0.0).margin(1e-14));
		CHECK(v1.Y() == Approx(-2.0));
		CHECK(v1.Z() == Approx(0.0));
		CHECK(v2.X() == Approx(2.0));
		CHECK(v2.Y() == Approx(0.0).margin(1e-12));
		CHECK(v2.Z() == Approx(0.0));
		CHECK(v3.X() == Approx(0.0).margin(1e-12));
		CHECK(v3.Y() == Approx(2.0));
		CHECK(v3.Z() == Approx(0.0));
	;
	SECTION("from (1.0,0.0) POS enlarge 999 length") {
		Point2 point2 = CurveCalculation::D0(999.0, line2); 
		CHECK(point2.X() == 1000.0);
		CHECK(point2.Y() == 0.0);
	}}
SECTION("u = M_PI") {
		CurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);
		CHECK(p.X() == -1.0);
		CHECK(p.Y() == Approx(1.0));
		CHECK(p.Z() == 0.0);
		CHECK(v1.X() == Approx(0.0).margin(1e-14));
		CHECK(v1.Y() == Approx(-2.0));
		CHECK(v1.Z() == Approx(0.0));
		CHECK(v2.X() == Approx(2.0));
		CHECK(v2.Y() == Approx(0.0).margin(1e-12));
		CHECK(v2.Z() == Approx(0.0));
		CHECK(v3.X() == Approx(0.0).margin(1e-12));
		CHECK(v3.Y() == Approx(2.0));
		CHECK(v3.Z() == Approx(0.0));
	;
	SECTION("u = M_PI") {
		Vector2 vector2 = CurveCalculation::D1(M_PI, circle2);
		CHECK(vector2.X() == Approx(-0.0).margin(1e-12));
		CHECK(vector2.Y() == -2.0);
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static void D1(double u, const Parabola2& parabola, Point2& p, Vector2& v1)	 @param[out] v1 The first derivative
	 @param[out] p The point
	 @param[in] parabola The parabola
	 @param[in] u The parameter
	 @brief Compute the point and the first derivative on a 2D parabola at a parameter
,
 "output":SECTION("u = M_PI") {
		CurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);
		CHECK(p.X() == -1.0);
		CHECK(p.Y() == Approx(1.0));
		CHECK(p.Z() == 0.0);
		CHECK(v1.X() == Approx(0.0).margin(1e-14));
		CHECK(v1.Y() == Approx(-2.0));
		CHECK(v1.Z() == Approx(0.0));
		CHECK(v2.X() == Approx(2.0));
		CHECK(v2.Y() == Approx(0.0).margin(1e-12));
		CHECK(v2.Z() == Approx(0.0));
		CHECK(v3.X() == Approx(0.0).margin(1e-12));
		CHECK(v3.Y() == Approx(2.0));
		CHECK(v3.Z() == Approx(0.0));
	;
	SECTION("from (1.0,0.0) POS enlarge 999 length") {
		Point2 point2 = CurveCalculation::D0(999.0, line2); 
		CHECK(point2.X() == 1000.0);
		CHECK(point2.Y() == 0.0);
	}}
SECTION("u = M_PI") {
		CurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);
		CHECK(p.X() == -1.0);
		CHECK(p.Y() == Approx(1.0));
		CHECK(p.Z() == 0.0);
		CHECK(v1.X() == Approx(0.0).margin(1e-14));
		CHECK(v1.Y() == Approx(-2.0));
		CHECK(v1.Z() == Approx(0.0));
		CHECK(v2.X() == Approx(2.0));
		CHECK(v2.Y() == Approx(0.0).margin(1e-12));
		CHECK(v2.Z() == Approx(0.0));
		CHECK(v3.X() == Approx(0.0).margin(1e-12));
		CHECK(v3.Y() == Approx(2.0));
		CHECK(v3.Z() == Approx(0.0));
	;
	SECTION("u = M_PI") {
		CurveCalculation::D1(M_PI, circle2,p,v);
		CHECK(p.X() == -1.0);
		CHECK(p.Y() == Approx(1.0));
		CHECK(v.X() == Approx(0.0).margin(1e-14));
		CHECK(v.Y() == Approx(-2.0));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static void D1(double u, const Hyperbola2& hyperbola, Point2& p, Vector2& v1)	 @param[out] v1 The first derivative
	 @param[out] p The point
	 @param[in] hyperbola The hyperbola
	 @param[in] u The parameter
	 @brief Compute the point and the first derivative on a 2D hyperbola at a parameter
,
 "output":SECTION("u = M_PI") {
		CurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);
		CHECK(p.X() == -1.0);
		CHECK(p.Y() == Approx(1.0));
		CHECK(p.Z() == 0.0);
		CHECK(v1.X() == Approx(0.0).margin(1e-14));
		CHECK(v1.Y() == Approx(-2.0));
		CHECK(v1.Z() == Approx(0.0));
		CHECK(v2.X() == Approx(2.0));
		CHECK(v2.Y() == Approx(0.0).margin(1e-12));
		CHECK(v2.Z() == Approx(0.0));
		CHECK(v3.X() == Approx(0.0).margin(1e-12));
		CHECK(v3.Y() == Approx(2.0));
		CHECK(v3.Z() == Approx(0.0));
	;
	SECTION("from (1.0,0.0) POS enlarge 999 length") {
		Point2 point2 = CurveCalculation::D0(999.0, line2); 
		CHECK(point2.X() == 1000.0);
		CHECK(point2.Y() == 0.0);
	}}
SECTION("u = M_PI") {
		CurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);
		CHECK(p.X() == -1.0);
		CHECK(p.Y() == Approx(1.0));
		CHECK(p.Z() == 0.0);
		CHECK(v1.X() == Approx(0.0).margin(1e-14));
		CHECK(v1.Y() == Approx(-2.0));
		CHECK(v1.Z() == Approx(0.0));
		CHECK(v2.X() == Approx(2.0));
		CHECK(v2.Y() == Approx(0.0).margin(1e-12));
		CHECK(v2.Z() == Approx(0.0));
		CHECK(v3.X() == Approx(0.0).margin(1e-12));
		CHECK(v3.Y() == Approx(2.0));
		CHECK(v3.Z() == Approx(0.0));
	;
	SECTION("u = M_PI") {
		CurveCalculation::D1(M_PI, circle2,p,v);
		CHECK(p.X() == -1.0);
		CHECK(p.Y() == Approx(1.0));
		CHECK(v.X() == Approx(0.0).margin(1e-14));
		CHECK(v.Y() == Approx(-2.0));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] AMCAX_API static Vector3 D2(double u, const Line3& line)	 @return The second derivative vector
	 @param line The line
	 @param u The parameter
	 @brief Compute the second derivative on a 3D line at a parameter
,
 "output":SECTION("u = M_PI") {
		CurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);
		CHECK(p.X() == -1.0);
		CHECK(p.Y() == Approx(1.0));
		CHECK(p.Z() == 0.0);
		CHECK(v1.X() == Approx(0.0).margin(1e-14));
		CHECK(v1.Y() == Approx(-2.0));
		CHECK(v1.Z() == Approx(0.0));
		CHECK(v2.X() == Approx(2.0));
		CHECK(v2.Y() == Approx(0.0).margin(1e-12));
		CHECK(v2.Z() == Approx(0.0));
		CHECK(v3.X() == Approx(0.0).margin(1e-12));
		CHECK(v3.Y() == Approx(2.0));
		CHECK(v3.Z() == Approx(0.0));
	;
	SECTION("from (1.0,0.0) POS enlarge 999 length") {
		Point2 point2 = CurveCalculation::D0(999.0, line2); 
		CHECK(point2.X() == 1000.0);
		CHECK(point2.Y() == 0.0);
	}}
SECTION("u = M_PI") {
		CurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);
		CHECK(p.X() == -1.0);
		CHECK(p.Y() == Approx(1.0));
		CHECK(p.Z() == 0.0);
		CHECK(v1.X() == Approx(0.0).margin(1e-14));
		CHECK(v1.Y() == Approx(-2.0));
		CHECK(v1.Z() == Approx(0.0));
		CHECK(v2.X() == Approx(2.0));
		CHECK(v2.Y() == Approx(0.0).margin(1e-12));
		CHECK(v2.Z() == Approx(0.0));
		CHECK(v3.X() == Approx(0.0).margin(1e-12));
		CHECK(v3.Y() == Approx(2.0));
		CHECK(v3.Z() == Approx(0.0));
	;
	SECTION("u = M_PI") {
		CurveCalculation::D2(M_PI, circle2, p, v1,v2);
		CHECK(p.X() == -1.0);
		CHECK(p.Y() == Approx(1.0));
		CHECK(v1.X() == Approx(0.0).margin(1e-12) );
		CHECK(v1.Y() == -2.0);
		CHECK(v2.X() == 2.0);
		CHECK(v2.Y() == Approx(0.0).margin(1e-11));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static void D2(double u, const Line3& line, Point3& p, Vector3& v1, Vector3& v2)	 @param[out] v2 The second derivative
	 @param[out] v1 The first derivative
	 @param[out] p The point
	 @param[in] line The line
	 @param[in] u The parameter
	 @brief Compute the point and the first two derivatives on a 3D line at a parameter
,
 "output":SECTION("u = M_PI") {
		CurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);
		CHECK(p.X() == -1.0);
		CHECK(p.Y() == Approx(1.0));
		CHECK(p.Z() == 0.0);
		CHECK(v1.X() == Approx(0.0).margin(1e-14));
		CHECK(v1.Y() == Approx(-2.0));
		CHECK(v1.Z() == Approx(0.0));
		CHECK(v2.X() == Approx(2.0));
		CHECK(v2.Y() == Approx(0.0).margin(1e-12));
		CHECK(v2.Z() == Approx(0.0));
		CHECK(v3.X() == Approx(0.0).margin(1e-12));
		CHECK(v3.Y() == Approx(2.0));
		CHECK(v3.Z() == Approx(0.0));
	;
	SECTION("from (1.0,0.0) POS enlarge 999 length") {
		Point2 point2 = CurveCalculation::D0(999.0, line2); 
		CHECK(point2.X() == 1000.0);
		CHECK(point2.Y() == 0.0);
	}}
SECTION("u = M_PI") {
		CurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);
		CHECK(p.X() == -1.0);
		CHECK(p.Y() == Approx(1.0));
		CHECK(p.Z() == 0.0);
		CHECK(v1.X() == Approx(0.0).margin(1e-14));
		CHECK(v1.Y() == Approx(-2.0));
		CHECK(v1.Z() == Approx(0.0));
		CHECK(v2.X() == Approx(2.0));
		CHECK(v2.Y() == Approx(0.0).margin(1e-12));
		CHECK(v2.Z() == Approx(0.0));
		CHECK(v3.X() == Approx(0.0).margin(1e-12));
		CHECK(v3.Y() == Approx(2.0));
		CHECK(v3.Z() == Approx(0.0));
	;
	SECTION("u = M_PI") {
		CurveCalculation::D2(M_PI, circle2, p, v1,v2);
		CHECK(p.X() == -1.0);
		CHECK(p.Y() == Approx(1.0));
		CHECK(v1.X() == Approx(0.0).margin(1e-12) );
		CHECK(v1.Y() == -2.0);
		CHECK(v2.X() == 2.0);
		CHECK(v2.Y() == Approx(0.0).margin(1e-11));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] AMCAX_API static Vector3 D2(double u, const Circle3& circle)	 @return The second derivative vector
	 @param circle The circle
	 @param u The parameter
	 @brief Compute the second derivative on a 3D circle at a parameter
,
 "output":SECTION("u = M_PI") {
		CurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);
		CHECK(p.X() == -1.0);
		CHECK(p.Y() == Approx(1.0));
		CHECK(p.Z() == 0.0);
		CHECK(v1.X() == Approx(0.0).margin(1e-14));
		CHECK(v1.Y() == Approx(-2.0));
		CHECK(v1.Z() == Approx(0.0));
		CHECK(v2.X() == Approx(2.0));
		CHECK(v2.Y() == Approx(0.0).margin(1e-12));
		CHECK(v2.Z() == Approx(0.0));
		CHECK(v3.X() == Approx(0.0).margin(1e-12));
		CHECK(v3.Y() == Approx(2.0));
		CHECK(v3.Z() == Approx(0.0));
	;
	SECTION("from (1.0,0.0) POS enlarge 999 length") {
		Point2 point2 = CurveCalculation::D0(999.0, line2); 
		CHECK(point2.X() == 1000.0);
		CHECK(point2.Y() == 0.0);
	}}
SECTION("u = M_PI") {
		CurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);
		CHECK(p.X() == -1.0);
		CHECK(p.Y() == Approx(1.0));
		CHECK(p.Z() == 0.0);
		CHECK(v1.X() == Approx(0.0).margin(1e-14));
		CHECK(v1.Y() == Approx(-2.0));
		CHECK(v1.Z() == Approx(0.0));
		CHECK(v2.X() == Approx(2.0));
		CHECK(v2.Y() == Approx(0.0).margin(1e-12));
		CHECK(v2.Z() == Approx(0.0));
		CHECK(v3.X() == Approx(0.0).margin(1e-12));
		CHECK(v3.Y() == Approx(2.0));
		CHECK(v3.Z() == Approx(0.0));
	;
	SECTION("u = M_PI") {
		CurveCalculation::D2(M_PI, circle2, p, v1,v2);
		CHECK(p.X() == -1.0);
		CHECK(p.Y() == Approx(1.0));
		CHECK(v1.X() == Approx(0.0).margin(1e-12) );
		CHECK(v1.Y() == -2.0);
		CHECK(v2.X() == 2.0);
		CHECK(v2.Y() == Approx(0.0).margin(1e-11));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static void D2(double u, const Circle3& circle, Point3& p, Vector3& v1, Vector3& v2)	 @param[out] v2 The second derivative
	 @param[out] v1 The first derivative
	 @param[out] p The point
	 @param[in] circle The circle
	 @param[in] u The parameter
	 @brief Compute the point and the first two derivatives on a 3D circle at a parameter
,
 "output":SECTION("u = M_PI") {
		CurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);
		CHECK(p.X() == -1.0);
		CHECK(p.Y() == Approx(1.0));
		CHECK(p.Z() == 0.0);
		CHECK(v1.X() == Approx(0.0).margin(1e-14));
		CHECK(v1.Y() == Approx(-2.0));
		CHECK(v1.Z() == Approx(0.0));
		CHECK(v2.X() == Approx(2.0));
		CHECK(v2.Y() == Approx(0.0).margin(1e-12));
		CHECK(v2.Z() == Approx(0.0));
		CHECK(v3.X() == Approx(0.0).margin(1e-12));
		CHECK(v3.Y() == Approx(2.0));
		CHECK(v3.Z() == Approx(0.0));
	;
	SECTION("from (1.0,0.0) POS enlarge 999 length") {
		Point2 point2 = CurveCalculation::D0(999.0, line2); 
		CHECK(point2.X() == 1000.0);
		CHECK(point2.Y() == 0.0);
	}}
SECTION("u = M_PI") {
		CurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);
		CHECK(p.X() == -1.0);
		CHECK(p.Y() == Approx(1.0));
		CHECK(p.Z() == 0.0);
		CHECK(v1.X() == Approx(0.0).margin(1e-14));
		CHECK(v1.Y() == Approx(-2.0));
		CHECK(v1.Z() == Approx(0.0));
		CHECK(v2.X() == Approx(2.0));
		CHECK(v2.Y() == Approx(0.0).margin(1e-12));
		CHECK(v2.Z() == Approx(0.0));
		CHECK(v3.X() == Approx(0.0).margin(1e-12));
		CHECK(v3.Y() == Approx(2.0));
		CHECK(v3.Z() == Approx(0.0));
	;
	SECTION("u = M_PI") {
		CurveCalculation::D2(M_PI, circle2, p, v1,v2);
		CHECK(p.X() == -1.0);
		CHECK(p.Y() == Approx(1.0));
		CHECK(v1.X() == Approx(0.0).margin(1e-12) );
		CHECK(v1.Y() == -2.0);
		CHECK(v2.X() == 2.0);
		CHECK(v2.Y() == Approx(0.0).margin(1e-11));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] AMCAX_API static Vector3 D2(double u, const Ellipse3& ellipse)	 @return The second derivative vector
	 @param ellipse The ellipse
	 @param u The parameter
	 @brief Compute the second derivative on a 3D ellipse at a parameter
,
 "output":SECTION("u = M_PI") {
		CurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);
		CHECK(p.X() == -1.0);
		CHECK(p.Y() == Approx(1.0));
		CHECK(p.Z() == 0.0);
		CHECK(v1.X() == Approx(0.0).margin(1e-14));
		CHECK(v1.Y() == Approx(-2.0));
		CHECK(v1.Z() == Approx(0.0));
		CHECK(v2.X() == Approx(2.0));
		CHECK(v2.Y() == Approx(0.0).margin(1e-12));
		CHECK(v2.Z() == Approx(0.0));
		CHECK(v3.X() == Approx(0.0).margin(1e-12));
		CHECK(v3.Y() == Approx(2.0));
		CHECK(v3.Z() == Approx(0.0));
	;
	SECTION("from (1.0,0.0) POS enlarge 999 length") {
		Point2 point2 = CurveCalculation::D0(999.0, line2); 
		CHECK(point2.X() == 1000.0);
		CHECK(point2.Y() == 0.0);
	}}
SECTION("u = M_PI") {
		CurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);
		CHECK(p.X() == -1.0);
		CHECK(p.Y() == Approx(1.0));
		CHECK(p.Z() == 0.0);
		CHECK(v1.X() == Approx(0.0).margin(1e-14));
		CHECK(v1.Y() == Approx(-2.0));
		CHECK(v1.Z() == Approx(0.0));
		CHECK(v2.X() == Approx(2.0));
		CHECK(v2.Y() == Approx(0.0).margin(1e-12));
		CHECK(v2.Z() == Approx(0.0));
		CHECK(v3.X() == Approx(0.0).margin(1e-12));
		CHECK(v3.Y() == Approx(2.0));
		CHECK(v3.Z() == Approx(0.0));
	;
	SECTION("u = M_PI") {
		CurveCalculation::D2(M_PI, circle2, p, v1,v2);
		CHECK(p.X() == -1.0);
		CHECK(p.Y() == Approx(1.0));
		CHECK(v1.X() == Approx(0.0).margin(1e-12) );
		CHECK(v1.Y() == -2.0);
		CHECK(v2.X() == 2.0);
		CHECK(v2.Y() == Approx(0.0).margin(1e-11));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] AMCAX_API static Vector3 D2(double u, const Parabola3& parabola)	 @return The second derivative vector
	 @param parabola The parabola
	 @param u The parameter
	 @brief Compute the second derivative on a 3D parabola at a parameter
,
 "output":SECTION("u = M_PI") {
		CurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);
		CHECK(p.X() == -1.0);
		CHECK(p.Y() == Approx(1.0));
		CHECK(p.Z() == 0.0);
		CHECK(v1.X() == Approx(0.0).margin(1e-14));
		CHECK(v1.Y() == Approx(-2.0));
		CHECK(v1.Z() == Approx(0.0));
		CHECK(v2.X() == Approx(2.0));
		CHECK(v2.Y() == Approx(0.0).margin(1e-12));
		CHECK(v2.Z() == Approx(0.0));
		CHECK(v3.X() == Approx(0.0).margin(1e-12));
		CHECK(v3.Y() == Approx(2.0));
		CHECK(v3.Z() == Approx(0.0));
	;
	SECTION("from (1.0,0.0) POS enlarge 999 length") {
		Point2 point2 = CurveCalculation::D0(999.0, line2); 
		CHECK(point2.X() == 1000.0);
		CHECK(point2.Y() == 0.0);
	}}
SECTION("u = M_PI") {
		CurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);
		CHECK(p.X() == -1.0);
		CHECK(p.Y() == Approx(1.0));
		CHECK(p.Z() == 0.0);
		CHECK(v1.X() == Approx(0.0).margin(1e-14));
		CHECK(v1.Y() == Approx(-2.0));
		CHECK(v1.Z() == Approx(0.0));
		CHECK(v2.X() == Approx(2.0));
		CHECK(v2.Y() == Approx(0.0).margin(1e-12));
		CHECK(v2.Z() == Approx(0.0));
		CHECK(v3.X() == Approx(0.0).margin(1e-12));
		CHECK(v3.Y() == Approx(2.0));
		CHECK(v3.Z() == Approx(0.0));
	;
	SECTION("u = M_PI") {
		CurveCalculation::D2(M_PI, circle2, p, v1,v2);
		CHECK(p.X() == -1.0);
		CHECK(p.Y() == Approx(1.0));
		CHECK(v1.X() == Approx(0.0).margin(1e-12) );
		CHECK(v1.Y() == -2.0);
		CHECK(v2.X() == 2.0);
		CHECK(v2.Y() == Approx(0.0).margin(1e-11));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static void D2(double u, const Parabola3& parabola, Point3& p, Vector3& v1, Vector3& v2)	 @param[out] v2 The second derivative
	 @param[out] v1 The first derivative
	 @param[out] p The point
	 @param[in] parabola The parabola
	 @param[in] u The parameter
	 @brief Compute the point and the first two derivatives on a 3D parabola at a parameter
,
 "output":SECTION("u = M_PI") {
		CurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);
		CHECK(p.X() == -1.0);
		CHECK(p.Y() == Approx(1.0));
		CHECK(p.Z() == 0.0);
		CHECK(v1.X() == Approx(0.0).margin(1e-14));
		CHECK(v1.Y() == Approx(-2.0));
		CHECK(v1.Z() == Approx(0.0));
		CHECK(v2.X() == Approx(2.0));
		CHECK(v2.Y() == Approx(0.0).margin(1e-12));
		CHECK(v2.Z() == Approx(0.0));
		CHECK(v3.X() == Approx(0.0).margin(1e-12));
		CHECK(v3.Y() == Approx(2.0));
		CHECK(v3.Z() == Approx(0.0));
	;
	SECTION("from (1.0,0.0) POS enlarge 999 length") {
		Point2 point2 = CurveCalculation::D0(999.0, line2); 
		CHECK(point2.X() == 1000.0);
		CHECK(point2.Y() == 0.0);
	}}
SECTION("u = M_PI") {
		CurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);
		CHECK(p.X() == -1.0);
		CHECK(p.Y() == Approx(1.0));
		CHECK(p.Z() == 0.0);
		CHECK(v1.X() == Approx(0.0).margin(1e-14));
		CHECK(v1.Y() == Approx(-2.0));
		CHECK(v1.Z() == Approx(0.0));
		CHECK(v2.X() == Approx(2.0));
		CHECK(v2.Y() == Approx(0.0).margin(1e-12));
		CHECK(v2.Z() == Approx(0.0));
		CHECK(v3.X() == Approx(0.0).margin(1e-12));
		CHECK(v3.Y() == Approx(2.0));
		CHECK(v3.Z() == Approx(0.0));
	;
	SECTION("u = M_PI") {
		CurveCalculation::D2(M_PI, circle2, p, v1,v2);
		CHECK(p.X() == -1.0);
		CHECK(p.Y() == Approx(1.0));
		CHECK(v1.X() == Approx(0.0).margin(1e-12) );
		CHECK(v1.Y() == -2.0);
		CHECK(v2.X() == 2.0);
		CHECK(v2.Y() == Approx(0.0).margin(1e-11));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] AMCAX_API static Vector3 D2(double u, const Hyperbola3& hyperbola)	 @return The second derivative vector
	 @param hyperbola The hyperbola
	 @param u The parameter
	 @brief Compute the second derivative on a 3D hyperbola at a parameter
,
 "output":SECTION("u = M_PI") {
		CurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);
		CHECK(p.X() == -1.0);
		CHECK(p.Y() == Approx(1.0));
		CHECK(p.Z() == 0.0);
		CHECK(v1.X() == Approx(0.0).margin(1e-14));
		CHECK(v1.Y() == Approx(-2.0));
		CHECK(v1.Z() == Approx(0.0));
		CHECK(v2.X() == Approx(2.0));
		CHECK(v2.Y() == Approx(0.0).margin(1e-12));
		CHECK(v2.Z() == Approx(0.0));
		CHECK(v3.X() == Approx(0.0).margin(1e-12));
		CHECK(v3.Y() == Approx(2.0));
		CHECK(v3.Z() == Approx(0.0));
	;
	SECTION("from (1.0,0.0) POS enlarge 999 length") {
		Point2 point2 = CurveCalculation::D0(999.0, line2); 
		CHECK(point2.X() == 1000.0);
		CHECK(point2.Y() == 0.0);
	}}
SECTION("u = M_PI") {
		CurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);
		CHECK(p.X() == -1.0);
		CHECK(p.Y() == Approx(1.0));
		CHECK(p.Z() == 0.0);
		CHECK(v1.X() == Approx(0.0).margin(1e-14));
		CHECK(v1.Y() == Approx(-2.0));
		CHECK(v1.Z() == Approx(0.0));
		CHECK(v2.X() == Approx(2.0));
		CHECK(v2.Y() == Approx(0.0).margin(1e-12));
		CHECK(v2.Z() == Approx(0.0));
		CHECK(v3.X() == Approx(0.0).margin(1e-12));
		CHECK(v3.Y() == Approx(2.0));
		CHECK(v3.Z() == Approx(0.0));
	;
	SECTION("u = M_PI") {
		CurveCalculation::D2(M_PI, circle2, p, v1,v2);
		CHECK(p.X() == -1.0);
		CHECK(p.Y() == Approx(1.0));
		CHECK(v1.X() == Approx(0.0).margin(1e-12) );
		CHECK(v1.Y() == -2.0);
		CHECK(v2.X() == 2.0);
		CHECK(v2.Y() == Approx(0.0).margin(1e-11));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static void D2(double u, const Hyperbola3& hyperbola, Point3& p, Vector3& v1, Vector3& v2)	 @param[out] v2 The second derivative
	 @param[out] v1 The first derivative
	 @param[out] p The point
	 @param[in] hyperbola The hyperbola
	 @param[in] u The parameter
	 @brief Compute the point and the first two derivatives on a 3D hyperbola at a parameter
,
 "output":SECTION("u = M_PI") {
		CurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);
		CHECK(p.X() == -1.0);
		CHECK(p.Y() == Approx(1.0));
		CHECK(p.Z() == 0.0);
		CHECK(v1.X() == Approx(0.0).margin(1e-14));
		CHECK(v1.Y() == Approx(-2.0));
		CHECK(v1.Z() == Approx(0.0));
		CHECK(v2.X() == Approx(2.0));
		CHECK(v2.Y() == Approx(0.0).margin(1e-12));
		CHECK(v2.Z() == Approx(0.0));
		CHECK(v3.X() == Approx(0.0).margin(1e-12));
		CHECK(v3.Y() == Approx(2.0));
		CHECK(v3.Z() == Approx(0.0));
	;
	SECTION("from (1.0,0.0) POS enlarge 999 length") {
		Point2 point2 = CurveCalculation::D0(999.0, line2); 
		CHECK(point2.X() == 1000.0);
		CHECK(point2.Y() == 0.0);
	}}
SECTION("u = M_PI") {
		CurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);
		CHECK(p.X() == -1.0);
		CHECK(p.Y() == Approx(1.0));
		CHECK(p.Z() == 0.0);
		CHECK(v1.X() == Approx(0.0).margin(1e-14));
		CHECK(v1.Y() == Approx(-2.0));
		CHECK(v1.Z() == Approx(0.0));
		CHECK(v2.X() == Approx(2.0));
		CHECK(v2.Y() == Approx(0.0).margin(1e-12));
		CHECK(v2.Z() == Approx(0.0));
		CHECK(v3.X() == Approx(0.0).margin(1e-12));
		CHECK(v3.Y() == Approx(2.0));
		CHECK(v3.Z() == Approx(0.0));
	;
	SECTION("u = M_PI") {
		CurveCalculation::D2(M_PI, circle2, p, v1,v2);
		CHECK(p.X() == -1.0);
		CHECK(p.Y() == Approx(1.0));
		CHECK(v1.X() == Approx(0.0).margin(1e-12) );
		CHECK(v1.Y() == -2.0);
		CHECK(v2.X() == 2.0);
		CHECK(v2.Y() == Approx(0.0).margin(1e-11));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] AMCAX_API static Vector2 D2(double u, const Line2& line)	 @return The second derivative vector
	 @param line The line
	 @param u The parameter
	 @brief Compute the second derivative on a 2D line at a parameter
,
 "output":SECTION("u = M_PI") {
		CurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);
		CHECK(p.X() == -1.0);
		CHECK(p.Y() == Approx(1.0));
		CHECK(p.Z() == 0.0);
		CHECK(v1.X() == Approx(0.0).margin(1e-14));
		CHECK(v1.Y() == Approx(-2.0));
		CHECK(v1.Z() == Approx(0.0));
		CHECK(v2.X() == Approx(2.0));
		CHECK(v2.Y() == Approx(0.0).margin(1e-12));
		CHECK(v2.Z() == Approx(0.0));
		CHECK(v3.X() == Approx(0.0).margin(1e-12));
		CHECK(v3.Y() == Approx(2.0));
		CHECK(v3.Z() == Approx(0.0));
	;
	SECTION("from (1.0,0.0) POS enlarge 999 length") {
		Point2 point2 = CurveCalculation::D0(999.0, line2); 
		CHECK(point2.X() == 1000.0);
		CHECK(point2.Y() == 0.0);
	}}
SECTION("u = M_PI") {
		CurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);
		CHECK(p.X() == -1.0);
		CHECK(p.Y() == Approx(1.0));
		CHECK(p.Z() == 0.0);
		CHECK(v1.X() == Approx(0.0).margin(1e-14));
		CHECK(v1.Y() == Approx(-2.0));
		CHECK(v1.Z() == Approx(0.0));
		CHECK(v2.X() == Approx(2.0));
		CHECK(v2.Y() == Approx(0.0).margin(1e-12));
		CHECK(v2.Z() == Approx(0.0));
		CHECK(v3.X() == Approx(0.0).margin(1e-12));
		CHECK(v3.Y() == Approx(2.0));
		CHECK(v3.Z() == Approx(0.0));
	;
	SECTION("u =0") {
		Vector2 vector2 = CurveCalculation::D2(0.0, circle2);
		CHECK(vector2.X() == -2.0);
		CHECK(vector2.Y() == 0.0);
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static void D2(double u, const Line2& line, Point2& p, Vector2& v1, Vector2& v2)	 @param[out] v2 The second derivative
	 @param[out] v1 The first derivative
	 @param[out] p The point
	 @param[in] line The line
	 @param[in] u The parameter
	 @brief Compute the point and the first two derivatives on a 2D line at a parameter
,
 "output":SECTION("u = M_PI") {
		CurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);
		CHECK(p.X() == -1.0);
		CHECK(p.Y() == Approx(1.0));
		CHECK(p.Z() == 0.0);
		CHECK(v1.X() == Approx(0.0).margin(1e-14));
		CHECK(v1.Y() == Approx(-2.0));
		CHECK(v1.Z() == Approx(0.0));
		CHECK(v2.X() == Approx(2.0));
		CHECK(v2.Y() == Approx(0.0).margin(1e-12));
		CHECK(v2.Z() == Approx(0.0));
		CHECK(v3.X() == Approx(0.0).margin(1e-12));
		CHECK(v3.Y() == Approx(2.0));
		CHECK(v3.Z() == Approx(0.0));
	;
	SECTION("from (1.0,0.0) POS enlarge 999 length") {
		Point2 point2 = CurveCalculation::D0(999.0, line2); 
		CHECK(point2.X() == 1000.0);
		CHECK(point2.Y() == 0.0);
	}}
SECTION("u = M_PI") {
		CurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);
		CHECK(p.X() == -1.0);
		CHECK(p.Y() == Approx(1.0));
		CHECK(p.Z() == 0.0);
		CHECK(v1.X() == Approx(0.0).margin(1e-14));
		CHECK(v1.Y() == Approx(-2.0));
		CHECK(v1.Z() == Approx(0.0));
		CHECK(v2.X() == Approx(2.0));
		CHECK(v2.Y() == Approx(0.0).margin(1e-12));
		CHECK(v2.Z() == Approx(0.0));
		CHECK(v3.X() == Approx(0.0).margin(1e-12));
		CHECK(v3.Y() == Approx(2.0));
		CHECK(v3.Z() == Approx(0.0));
	;
	SECTION("u = M_PI") {
		CurveCalculation::D2(M_PI, circle2, p, v1,v2);
		CHECK(p.X() == -1.0);
		CHECK(p.Y() == Approx(1.0));
		CHECK(v1.X() == Approx(0.0).margin(1e-12) );
		CHECK(v1.Y() == -2.0);
		CHECK(v2.X() == 2.0);
		CHECK(v2.Y() == Approx(0.0).margin(1e-11));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] AMCAX_API static Vector2 D2(double u, const Circle2& circle)	 @return The second derivative vector
	 @param circle The circle
	 @param u The parameter
	 @brief Compute the second derivative on a 2D circle at a parameter
,
 "output":SECTION("u = M_PI") {
		CurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);
		CHECK(p.X() == -1.0);
		CHECK(p.Y() == Approx(1.0));
		CHECK(p.Z() == 0.0);
		CHECK(v1.X() == Approx(0.0).margin(1e-14));
		CHECK(v1.Y() == Approx(-2.0));
		CHECK(v1.Z() == Approx(0.0));
		CHECK(v2.X() == Approx(2.0));
		CHECK(v2.Y() == Approx(0.0).margin(1e-12));
		CHECK(v2.Z() == Approx(0.0));
		CHECK(v3.X() == Approx(0.0).margin(1e-12));
		CHECK(v3.Y() == Approx(2.0));
		CHECK(v3.Z() == Approx(0.0));
	;
	SECTION("from (1.0,0.0) POS enlarge 999 length") {
		Point2 point2 = CurveCalculation::D0(999.0, line2); 
		CHECK(point2.X() == 1000.0);
		CHECK(point2.Y() == 0.0);
	}}
SECTION("u = M_PI") {
		CurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);
		CHECK(p.X() == -1.0);
		CHECK(p.Y() == Approx(1.0));
		CHECK(p.Z() == 0.0);
		CHECK(v1.X() == Approx(0.0).margin(1e-14));
		CHECK(v1.Y() == Approx(-2.0));
		CHECK(v1.Z() == Approx(0.0));
		CHECK(v2.X() == Approx(2.0));
		CHECK(v2.Y() == Approx(0.0).margin(1e-12));
		CHECK(v2.Z() == Approx(0.0));
		CHECK(v3.X() == Approx(0.0).margin(1e-12));
		CHECK(v3.Y() == Approx(2.0));
		CHECK(v3.Z() == Approx(0.0));
	;
	SECTION("u = M_PI") {
		Vector2 vector2 = CurveCalculation::D2(M_PI, circle2);
		CHECK(vector2.X() == 2.0);
		CHECK(vector2.Y() == Approx(0.0).margin(1e-11));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static void D2(double u, const Circle2& circle, Point2& p, Vector2& v1, Vector2& v2)	 @param[out] v2 The second derivative
	 @param[out] v1 The first derivative
	 @param[out] p The point
	 @param[in] circle The circle
	 @param[in] u The parameter
	 @brief Compute the point and the first two derivatives on a 2D circle at a parameter
,
 "output":SECTION("u = M_PI") {
		CurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);
		CHECK(p.X() == -1.0);
		CHECK(p.Y() == Approx(1.0));
		CHECK(p.Z() == 0.0);
		CHECK(v1.X() == Approx(0.0).margin(1e-14));
		CHECK(v1.Y() == Approx(-2.0));
		CHECK(v1.Z() == Approx(0.0));
		CHECK(v2.X() == Approx(2.0));
		CHECK(v2.Y() == Approx(0.0).margin(1e-12));
		CHECK(v2.Z() == Approx(0.0));
		CHECK(v3.X() == Approx(0.0).margin(1e-12));
		CHECK(v3.Y() == Approx(2.0));
		CHECK(v3.Z() == Approx(0.0));
	;
	SECTION("from (1.0,0.0) POS enlarge 999 length") {
		Point2 point2 = CurveCalculation::D0(999.0, line2); 
		CHECK(point2.X() == 1000.0);
		CHECK(point2.Y() == 0.0);
	}}
SECTION("u = M_PI") {
		CurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);
		CHECK(p.X() == -1.0);
		CHECK(p.Y() == Approx(1.0));
		CHECK(p.Z() == 0.0);
		CHECK(v1.X() == Approx(0.0).margin(1e-14));
		CHECK(v1.Y() == Approx(-2.0));
		CHECK(v1.Z() == Approx(0.0));
		CHECK(v2.X() == Approx(2.0));
		CHECK(v2.Y() == Approx(0.0).margin(1e-12));
		CHECK(v2.Z() == Approx(0.0));
		CHECK(v3.X() == Approx(0.0).margin(1e-12));
		CHECK(v3.Y() == Approx(2.0));
		CHECK(v3.Z() == Approx(0.0));
	;
	SECTION("u = M_PI") {
		CurveCalculation::D2(M_PI, circle2, p, v1,v2);
		CHECK(p.X() == -1.0);
		CHECK(p.Y() == Approx(1.0));
		CHECK(v1.X() == Approx(0.0).margin(1e-12) );
		CHECK(v1.Y() == -2.0);
		CHECK(v2.X() == 2.0);
		CHECK(v2.Y() == Approx(0.0).margin(1e-11));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] AMCAX_API static Vector2 D2(double u, const Ellipse2& ellipse)	 @return The second derivative vector
	 @param ellipse The ellipse
	 @param u The parameter
	 @brief Compute the second derivative on a 2D ellipse at a parameter
,
 "output":SECTION("u = M_PI") {
		CurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);
		CHECK(p.X() == -1.0);
		CHECK(p.Y() == Approx(1.0));
		CHECK(p.Z() == 0.0);
		CHECK(v1.X() == Approx(0.0).margin(1e-14));
		CHECK(v1.Y() == Approx(-2.0));
		CHECK(v1.Z() == Approx(0.0));
		CHECK(v2.X() == Approx(2.0));
		CHECK(v2.Y() == Approx(0.0).margin(1e-12));
		CHECK(v2.Z() == Approx(0.0));
		CHECK(v3.X() == Approx(0.0).margin(1e-12));
		CHECK(v3.Y() == Approx(2.0));
		CHECK(v3.Z() == Approx(0.0));
	;
	SECTION("from (1.0,0.0) POS enlarge 999 length") {
		Point2 point2 = CurveCalculation::D0(999.0, line2); 
		CHECK(point2.X() == 1000.0);
		CHECK(point2.Y() == 0.0);
	}}
SECTION("u = M_PI") {
		CurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);
		CHECK(p.X() == -1.0);
		CHECK(p.Y() == Approx(1.0));
		CHECK(p.Z() == 0.0);
		CHECK(v1.X() == Approx(0.0).margin(1e-14));
		CHECK(v1.Y() == Approx(-2.0));
		CHECK(v1.Z() == Approx(0.0));
		CHECK(v2.X() == Approx(2.0));
		CHECK(v2.Y() == Approx(0.0).margin(1e-12));
		CHECK(v2.Z() == Approx(0.0));
		CHECK(v3.X() == Approx(0.0).margin(1e-12));
		CHECK(v3.Y() == Approx(2.0));
		CHECK(v3.Z() == Approx(0.0));
	;
	SECTION("u = M_PI") {
		Vector2 vector2 = CurveCalculation::D2(M_PI, circle2);
		CHECK(vector2.X() == 2.0);
		CHECK(vector2.Y() == Approx(0.0).margin(1e-11));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static void D2(double u, const Ellipse2& ellipse, Point2& p, Vector2& v1, Vector2& v2)	 @param[out] v2 The second derivative
	 @param[out] v1 The first derivative
	 @param[out] p The point
	 @param[in] ellipse The ellipse
	 @param[in] u The parameter
	 @brief Compute the point and the first two derivatives on a 2D ellipse at a parameter
,
 "output":SECTION("u = M_PI") {
		CurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);
		CHECK(p.X() == -1.0);
		CHECK(p.Y() == Approx(1.0));
		CHECK(p.Z() == 0.0);
		CHECK(v1.X() == Approx(0.0).margin(1e-14));
		CHECK(v1.Y() == Approx(-2.0));
		CHECK(v1.Z() == Approx(0.0));
		CHECK(v2.X() == Approx(2.0));
		CHECK(v2.Y() == Approx(0.0).margin(1e-12));
		CHECK(v2.Z() == Approx(0.0));
		CHECK(v3.X() == Approx(0.0).margin(1e-12));
		CHECK(v3.Y() == Approx(2.0));
		CHECK(v3.Z() == Approx(0.0));
	;
	SECTION("from (1.0,0.0) POS enlarge 999 length") {
		Point2 point2 = CurveCalculation::D0(999.0, line2); 
		CHECK(point2.X() == 1000.0);
		CHECK(point2.Y() == 0.0);
	}}
SECTION("u = M_PI") {
		CurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);
		CHECK(p.X() == -1.0);
		CHECK(p.Y() == Approx(1.0));
		CHECK(p.Z() == 0.0);
		CHECK(v1.X() == Approx(0.0).margin(1e-14));
		CHECK(v1.Y() == Approx(-2.0));
		CHECK(v1.Z() == Approx(0.0));
		CHECK(v2.X() == Approx(2.0));
		CHECK(v2.Y() == Approx(0.0).margin(1e-12));
		CHECK(v2.Z() == Approx(0.0));
		CHECK(v3.X() == Approx(0.0).margin(1e-12));
		CHECK(v3.Y() == Approx(2.0));
		CHECK(v3.Z() == Approx(0.0));
	;
	SECTION("u = M_PI") {
		CurveCalculation::D2(M_PI, circle2, p, v1,v2);
		CHECK(p.X() == -1.0);
		CHECK(p.Y() == Approx(1.0));
		CHECK(v1.X() == Approx(0.0).margin(1e-12) );
		CHECK(v1.Y() == -2.0);
		CHECK(v2.X() == 2.0);
		CHECK(v2.Y() == Approx(0.0).margin(1e-11));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] AMCAX_API static Vector2 D2(double u, const Parabola2& parabola)	 @return The second derivative vector
	 @param parabola The parabola
	 @param u The parameter
	 @brief Compute the second derivative on a 2D parabola at a parameter
,
 "output":SECTION("u = M_PI") {
		CurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);
		CHECK(p.X() == -1.0);
		CHECK(p.Y() == Approx(1.0));
		CHECK(p.Z() == 0.0);
		CHECK(v1.X() == Approx(0.0).margin(1e-14));
		CHECK(v1.Y() == Approx(-2.0));
		CHECK(v1.Z() == Approx(0.0));
		CHECK(v2.X() == Approx(2.0));
		CHECK(v2.Y() == Approx(0.0).margin(1e-12));
		CHECK(v2.Z() == Approx(0.0));
		CHECK(v3.X() == Approx(0.0).margin(1e-12));
		CHECK(v3.Y() == Approx(2.0));
		CHECK(v3.Z() == Approx(0.0));
	;
	SECTION("from (1.0,0.0) POS enlarge 999 length") {
		Point2 point2 = CurveCalculation::D0(999.0, line2); 
		CHECK(point2.X() == 1000.0);
		CHECK(point2.Y() == 0.0);
	}}
SECTION("u = M_PI") {
		CurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);
		CHECK(p.X() == -1.0);
		CHECK(p.Y() == Approx(1.0));
		CHECK(p.Z() == 0.0);
		CHECK(v1.X() == Approx(0.0).margin(1e-14));
		CHECK(v1.Y() == Approx(-2.0));
		CHECK(v1.Z() == Approx(0.0));
		CHECK(v2.X() == Approx(2.0));
		CHECK(v2.Y() == Approx(0.0).margin(1e-12));
		CHECK(v2.Z() == Approx(0.0));
		CHECK(v3.X() == Approx(0.0).margin(1e-12));
		CHECK(v3.Y() == Approx(2.0));
		CHECK(v3.Z() == Approx(0.0));
	;
	SECTION("u = M_PI") {
		Vector2 vector2 = CurveCalculation::D2(M_PI, circle2);
		CHECK(vector2.X() == 2.0);
		CHECK(vector2.Y() == Approx(0.0).margin(1e-11));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static void D2(double u, const Parabola2& parabola, Point2& p, Vector2& v1, Vector2& v2)	 @param[out] v2 The second derivative
	 @param[out] v1 The first derivative
	 @param[out] p The point
	 @param[in] parabola The parabola
	 @param[in] u The parameter
	 @brief Compute the point and the first two derivatives on a 2D parabola at a parameter
,
 "output":SECTION("u = M_PI") {
		CurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);
		CHECK(p.X() == -1.0);
		CHECK(p.Y() == Approx(1.0));
		CHECK(p.Z() == 0.0);
		CHECK(v1.X() == Approx(0.0).margin(1e-14));
		CHECK(v1.Y() == Approx(-2.0));
		CHECK(v1.Z() == Approx(0.0));
		CHECK(v2.X() == Approx(2.0));
		CHECK(v2.Y() == Approx(0.0).margin(1e-12));
		CHECK(v2.Z() == Approx(0.0));
		CHECK(v3.X() == Approx(0.0).margin(1e-12));
		CHECK(v3.Y() == Approx(2.0));
		CHECK(v3.Z() == Approx(0.0));
	;
	SECTION("from (1.0,0.0) POS enlarge 999 length") {
		Point2 point2 = CurveCalculation::D0(999.0, line2); 
		CHECK(point2.X() == 1000.0);
		CHECK(point2.Y() == 0.0);
	}}
SECTION("u = M_PI") {
		CurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);
		CHECK(p.X() == -1.0);
		CHECK(p.Y() == Approx(1.0));
		CHECK(p.Z() == 0.0);
		CHECK(v1.X() == Approx(0.0).margin(1e-14));
		CHECK(v1.Y() == Approx(-2.0));
		CHECK(v1.Z() == Approx(0.0));
		CHECK(v2.X() == Approx(2.0));
		CHECK(v2.Y() == Approx(0.0).margin(1e-12));
		CHECK(v2.Z() == Approx(0.0));
		CHECK(v3.X() == Approx(0.0).margin(1e-12));
		CHECK(v3.Y() == Approx(2.0));
		CHECK(v3.Z() == Approx(0.0));
	;
	SECTION("u = M_PI") {
		CurveCalculation::D2(M_PI, circle2, p, v1,v2);
		CHECK(p.X() == -1.0);
		CHECK(p.Y() == Approx(1.0));
		CHECK(v1.X() == Approx(0.0).margin(1e-12) );
		CHECK(v1.Y() == -2.0);
		CHECK(v2.X() == 2.0);
		CHECK(v2.Y() == Approx(0.0).margin(1e-11));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] AMCAX_API static Vector2 D2(double u, const Hyperbola2& hyperbola)	 @return The second derivative vector
	 @param hyperbola The hyperbola
	 @param u The parameter
	 @brief Compute the second derivative on a 2D hyperbola at a parameter
,
 "output":SECTION("u = M_PI") {
		CurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);
		CHECK(p.X() == -1.0);
		CHECK(p.Y() == Approx(1.0));
		CHECK(p.Z() == 0.0);
		CHECK(v1.X() == Approx(0.0).margin(1e-14));
		CHECK(v1.Y() == Approx(-2.0));
		CHECK(v1.Z() == Approx(0.0));
		CHECK(v2.X() == Approx(2.0));
		CHECK(v2.Y() == Approx(0.0).margin(1e-12));
		CHECK(v2.Z() == Approx(0.0));
		CHECK(v3.X() == Approx(0.0).margin(1e-12));
		CHECK(v3.Y() == Approx(2.0));
		CHECK(v3.Z() == Approx(0.0));
	;
	SECTION("from (1.0,0.0) POS enlarge 999 length") {
		Point2 point2 = CurveCalculation::D0(999.0, line2); 
		CHECK(point2.X() == 1000.0);
		CHECK(point2.Y() == 0.0);
	}}
SECTION("u = M_PI") {
		CurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);
		CHECK(p.X() == -1.0);
		CHECK(p.Y() == Approx(1.0));
		CHECK(p.Z() == 0.0);
		CHECK(v1.X() == Approx(0.0).margin(1e-14));
		CHECK(v1.Y() == Approx(-2.0));
		CHECK(v1.Z() == Approx(0.0));
		CHECK(v2.X() == Approx(2.0));
		CHECK(v2.Y() == Approx(0.0).margin(1e-12));
		CHECK(v2.Z() == Approx(0.0));
		CHECK(v3.X() == Approx(0.0).margin(1e-12));
		CHECK(v3.Y() == Approx(2.0));
		CHECK(v3.Z() == Approx(0.0));
	;
	SECTION("u = M_PI") {
		Vector2 vector2 = CurveCalculation::D2(M_PI, circle2);
		CHECK(vector2.X() == 2.0);
		CHECK(vector2.Y() == Approx(0.0).margin(1e-11));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static void D2(double u, const Hyperbola2& hyperbola, Point2& p, Vector2& v1, Vector2& v2)	 @param[out] v2 The second derivative
	 @param[out] v1 The first derivative
	 @param[out] p The point
	 @param[in] hyperbola The hyperbola
	 @param[in] u The parameter
	 @brief Compute the point and the first two derivatives on a 2D hyperbola at a parameter
,
 "output":SECTION("u = M_PI") {
		CurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);
		CHECK(p.X() == -1.0);
		CHECK(p.Y() == Approx(1.0));
		CHECK(p.Z() == 0.0);
		CHECK(v1.X() == Approx(0.0).margin(1e-14));
		CHECK(v1.Y() == Approx(-2.0));
		CHECK(v1.Z() == Approx(0.0));
		CHECK(v2.X() == Approx(2.0));
		CHECK(v2.Y() == Approx(0.0).margin(1e-12));
		CHECK(v2.Z() == Approx(0.0));
		CHECK(v3.X() == Approx(0.0).margin(1e-12));
		CHECK(v3.Y() == Approx(2.0));
		CHECK(v3.Z() == Approx(0.0));
	;
	SECTION("from (1.0,0.0) POS enlarge 999 length") {
		Point2 point2 = CurveCalculation::D0(999.0, line2); 
		CHECK(point2.X() == 1000.0);
		CHECK(point2.Y() == 0.0);
	}}
SECTION("u = M_PI") {
		CurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);
		CHECK(p.X() == -1.0);
		CHECK(p.Y() == Approx(1.0));
		CHECK(p.Z() == 0.0);
		CHECK(v1.X() == Approx(0.0).margin(1e-14));
		CHECK(v1.Y() == Approx(-2.0));
		CHECK(v1.Z() == Approx(0.0));
		CHECK(v2.X() == Approx(2.0));
		CHECK(v2.Y() == Approx(0.0).margin(1e-12));
		CHECK(v2.Z() == Approx(0.0));
		CHECK(v3.X() == Approx(0.0).margin(1e-12));
		CHECK(v3.Y() == Approx(2.0));
		CHECK(v3.Z() == Approx(0.0));
	;
	SECTION("u = M_PI") {
		CurveCalculation::D2(M_PI, circle2, p, v1,v2);
		CHECK(p.X() == -1.0);
		CHECK(p.Y() == Approx(1.0));
		CHECK(v1.X() == Approx(0.0).margin(1e-12) );
		CHECK(v1.Y() == -2.0);
		CHECK(v2.X() == 2.0);
		CHECK(v2.Y() == Approx(0.0).margin(1e-11));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] AMCAX_API static Vector3 D3(double u, const Line3& line)	 @return The third derivative vector
	 @param line The line
	 @param u The parameter
	 @brief Compute the third derivative on a 3D line at a parameter
,
 "output":SECTION("u = M_PI") {
		CurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);
		CHECK(p.X() == -1.0);
		CHECK(p.Y() == Approx(1.0));
		CHECK(p.Z() == 0.0);
		CHECK(v1.X() == Approx(0.0).margin(1e-14));
		CHECK(v1.Y() == Approx(-2.0));
		CHECK(v1.Z() == Approx(0.0));
		CHECK(v2.X() == Approx(2.0));
		CHECK(v2.Y() == Approx(0.0).margin(1e-12));
		CHECK(v2.Z() == Approx(0.0));
		CHECK(v3.X() == Approx(0.0).margin(1e-12));
		CHECK(v3.Y() == Approx(2.0));
		CHECK(v3.Z() == Approx(0.0));
	;
	SECTION("from (1.0,0.0) POS enlarge 999 length") {
		Point2 point2 = CurveCalculation::D0(999.0, line2); 
		CHECK(point2.X() == 1000.0);
		CHECK(point2.Y() == 0.0);
	}}
SECTION("u = M_PI") {
		CurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);
		CHECK(p.X() == -1.0);
		CHECK(p.Y() == Approx(1.0));
		CHECK(p.Z() == 0.0);
		CHECK(v1.X() == Approx(0.0).margin(1e-14));
		CHECK(v1.Y() == Approx(-2.0));
		CHECK(v1.Z() == Approx(0.0));
		CHECK(v2.X() == Approx(2.0));
		CHECK(v2.Y() == Approx(0.0).margin(1e-12));
		CHECK(v2.Z() == Approx(0.0));
		CHECK(v3.X() == Approx(0.0).margin(1e-12));
		CHECK(v3.Y() == Approx(2.0));
		CHECK(v3.Z() == Approx(0.0));
	;
	SECTION("u =0") {
		CurveCalculation::D3(0.0, circle2, p, v1, v2,v3);
		CHECK(p.X() == 3.0);
		CHECK(p.Y() == 1.0);
		CHECK(v1.X() == 0.0);
		CHECK(v1.Y() == 2.0);
		CHECK(v2.X() == -2.0);
		CHECK(v2.Y() == 0.0);
		CHECK(v3.X() == 0.0);
		CHECK(v3.Y() == -2.0);
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static void D3(double u, const Line3& line, Point3& p, Vector3& v1, Vector3& v2, Vector3& v3)	 @param[out] v3 The third derivative
	 @param[out] v2 The second derivative
	 @param[out] v1 The first derivative
	 @param[out] p The point
	 @param[in] line The line
	 @param[in] u The parameter
	 @brief Compute the point and the first three derivatives on a 3D line at a parameter
,
 "output":SECTION("u = M_PI") {
		CurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);
		CHECK(p.X() == -1.0);
		CHECK(p.Y() == Approx(1.0));
		CHECK(p.Z() == 0.0);
		CHECK(v1.X() == Approx(0.0).margin(1e-14));
		CHECK(v1.Y() == Approx(-2.0));
		CHECK(v1.Z() == Approx(0.0));
		CHECK(v2.X() == Approx(2.0));
		CHECK(v2.Y() == Approx(0.0).margin(1e-12));
		CHECK(v2.Z() == Approx(0.0));
		CHECK(v3.X() == Approx(0.0).margin(1e-12));
		CHECK(v3.Y() == Approx(2.0));
		CHECK(v3.Z() == Approx(0.0));
	;
	SECTION("from (1.0,0.0) POS enlarge 999 length") {
		Point2 point2 = CurveCalculation::D0(999.0, line2); 
		CHECK(point2.X() == 1000.0);
		CHECK(point2.Y() == 0.0);
	}}
SECTION("u = M_PI") {
		CurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);
		CHECK(p.X() == -1.0);
		CHECK(p.Y() == Approx(1.0));
		CHECK(p.Z() == 0.0);
		CHECK(v1.X() == Approx(0.0).margin(1e-14));
		CHECK(v1.Y() == Approx(-2.0));
		CHECK(v1.Z() == Approx(0.0));
		CHECK(v2.X() == Approx(2.0));
		CHECK(v2.Y() == Approx(0.0).margin(1e-12));
		CHECK(v2.Z() == Approx(0.0));
		CHECK(v3.X() == Approx(0.0).margin(1e-12));
		CHECK(v3.Y() == Approx(2.0));
		CHECK(v3.Z() == Approx(0.0));
	;
	SECTION("from (1.0,0.0) POS enlarge 999 length") {
		Point2 point2 = CurveCalculation::D0(999.0, line2); 
		CHECK(point2.X() == 1000.0);
		CHECK(point2.Y() == 0.0);
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] AMCAX_API static Vector3 D3(double u, const Circle3& circle)	 @return The third derivative vector
	 @param circle The circle
	 @param u The parameter
	 @brief Compute the third derivative on a 3D circle at a parameter
,
 "output":SECTION("u = M_PI") {
		CurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);
		CHECK(p.X() == -1.0);
		CHECK(p.Y() == Approx(1.0));
		CHECK(p.Z() == 0.0);
		CHECK(v1.X() == Approx(0.0).margin(1e-14));
		CHECK(v1.Y() == Approx(-2.0));
		CHECK(v1.Z() == Approx(0.0));
		CHECK(v2.X() == Approx(2.0));
		CHECK(v2.Y() == Approx(0.0).margin(1e-12));
		CHECK(v2.Z() == Approx(0.0));
		CHECK(v3.X() == Approx(0.0).margin(1e-12));
		CHECK(v3.Y() == Approx(2.0));
		CHECK(v3.Z() == Approx(0.0));
	;
	SECTION("from (1.0,0.0) POS enlarge 999 length") {
		Point2 point2 = CurveCalculation::D0(999.0, line2); 
		CHECK(point2.X() == 1000.0);
		CHECK(point2.Y() == 0.0);
	}}
SECTION("u = M_PI") {
		CurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);
		CHECK(p.X() == -1.0);
		CHECK(p.Y() == Approx(1.0));
		CHECK(p.Z() == 0.0);
		CHECK(v1.X() == Approx(0.0).margin(1e-14));
		CHECK(v1.Y() == Approx(-2.0));
		CHECK(v1.Z() == Approx(0.0));
		CHECK(v2.X() == Approx(2.0));
		CHECK(v2.Y() == Approx(0.0).margin(1e-12));
		CHECK(v2.Z() == Approx(0.0));
		CHECK(v3.X() == Approx(0.0).margin(1e-12));
		CHECK(v3.Y() == Approx(2.0));
		CHECK(v3.Z() == Approx(0.0));
	;
	SECTION("from (1.0,0.0) POS enlarge 999 length") {
		Point2 point2 = CurveCalculation::D0(999.0, line2); 
		CHECK(point2.X() == 1000.0);
		CHECK(point2.Y() == 0.0);
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static void D3(double u, const Circle3& circle, Point3& p, Vector3& v1, Vector3& v2, Vector3& v3)	 @param[out] v3 The third derivative
	 @param[out] v2 The second derivative
	 @param[out] v1 The first derivative
	 @param[out] p The point
	 @param[in] circle The circle
	 @param[in] u The parameter
	 @brief Compute the point and the first three derivatives on a 3D circle at a parameter
,
 "output":SECTION("u = M_PI") {
		CurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);
		CHECK(p.X() == -1.0);
		CHECK(p.Y() == Approx(1.0));
		CHECK(p.Z() == 0.0);
		CHECK(v1.X() == Approx(0.0).margin(1e-14));
		CHECK(v1.Y() == Approx(-2.0));
		CHECK(v1.Z() == Approx(0.0));
		CHECK(v2.X() == Approx(2.0));
		CHECK(v2.Y() == Approx(0.0).margin(1e-12));
		CHECK(v2.Z() == Approx(0.0));
		CHECK(v3.X() == Approx(0.0).margin(1e-12));
		CHECK(v3.Y() == Approx(2.0));
		CHECK(v3.Z() == Approx(0.0));
	;
	SECTION("from (1.0,0.0) POS enlarge 999 length") {
		Point2 point2 = CurveCalculation::D0(999.0, line2); 
		CHECK(point2.X() == 1000.0);
		CHECK(point2.Y() == 0.0);
	}}
SECTION("u = M_PI") {
		CurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);
		CHECK(p.X() == -1.0);
		CHECK(p.Y() == Approx(1.0));
		CHECK(p.Z() == 0.0);
		CHECK(v1.X() == Approx(0.0).margin(1e-14));
		CHECK(v1.Y() == Approx(-2.0));
		CHECK(v1.Z() == Approx(0.0));
		CHECK(v2.X() == Approx(2.0));
		CHECK(v2.Y() == Approx(0.0).margin(1e-12));
		CHECK(v2.Z() == Approx(0.0));
		CHECK(v3.X() == Approx(0.0).margin(1e-12));
		CHECK(v3.Y() == Approx(2.0));
		CHECK(v3.Z() == Approx(0.0));
	;
	SECTION("from (1.0,0.0) POS enlarge 999 length") {
		Point2 point2 = CurveCalculation::D0(999.0, line2); 
		CHECK(point2.X() == 1000.0);
		CHECK(point2.Y() == 0.0);
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] AMCAX_API static Vector3 D3(double u, const Ellipse3& ellipse)	 @return The third derivative vector
	 @param ellipse The ellipse
	 @param u The parameter
	 @brief Compute the third derivative on a 3D ellipse at a parameter
,
 "output":SECTION("u = M_PI") {
		CurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);
		CHECK(p.X() == -1.0);
		CHECK(p.Y() == Approx(1.0));
		CHECK(p.Z() == 0.0);
		CHECK(v1.X() == Approx(0.0).margin(1e-14));
		CHECK(v1.Y() == Approx(-2.0));
		CHECK(v1.Z() == Approx(0.0));
		CHECK(v2.X() == Approx(2.0));
		CHECK(v2.Y() == Approx(0.0).margin(1e-12));
		CHECK(v2.Z() == Approx(0.0));
		CHECK(v3.X() == Approx(0.0).margin(1e-12));
		CHECK(v3.Y() == Approx(2.0));
		CHECK(v3.Z() == Approx(0.0));
	;
	SECTION("from (1.0,0.0) POS enlarge 999 length") {
		Point2 point2 = CurveCalculation::D0(999.0, line2); 
		CHECK(point2.X() == 1000.0);
		CHECK(point2.Y() == 0.0);
	}}
SECTION("u = M_PI") {
		CurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);
		CHECK(p.X() == -1.0);
		CHECK(p.Y() == Approx(1.0));
		CHECK(p.Z() == 0.0);
		CHECK(v1.X() == Approx(0.0).margin(1e-14));
		CHECK(v1.Y() == Approx(-2.0));
		CHECK(v1.Z() == Approx(0.0));
		CHECK(v2.X() == Approx(2.0));
		CHECK(v2.Y() == Approx(0.0).margin(1e-12));
		CHECK(v2.Z() == Approx(0.0));
		CHECK(v3.X() == Approx(0.0).margin(1e-12));
		CHECK(v3.Y() == Approx(2.0));
		CHECK(v3.Z() == Approx(0.0));
	;
	SECTION("+999") {
		Point3 point3 = CurveCalculation::D0(999.0, line3);
		CHECK(point3.X() == 1000.0);
		CHECK(point3.Y() == 0.0);
		CHECK(point3.Z() == 0.0);
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static void D3(double u, const Ellipse3& ellipse, Point3& p, Vector3& v1, Vector3& v2, Vector3& v3)	 @param[out] v3 The third derivative
	 @param[out] v2 The second derivative
	 @param[out] v1 The first derivative
	 @param[out] p The point
	 @param[in] ellipse The ellipse
	 @param[in] u The parameter
	 @brief Compute the point and the first three derivatives on a 3D ellipse at a parameter
,
 "output":SECTION("u = M_PI") {
		CurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);
		CHECK(p.X() == -1.0);
		CHECK(p.Y() == Approx(1.0));
		CHECK(p.Z() == 0.0);
		CHECK(v1.X() == Approx(0.0).margin(1e-14));
		CHECK(v1.Y() == Approx(-2.0));
		CHECK(v1.Z() == Approx(0.0));
		CHECK(v2.X() == Approx(2.0));
		CHECK(v2.Y() == Approx(0.0).margin(1e-12));
		CHECK(v2.Z() == Approx(0.0));
		CHECK(v3.X() == Approx(0.0).margin(1e-12));
		CHECK(v3.Y() == Approx(2.0));
		CHECK(v3.Z() == Approx(0.0));
	;
	SECTION("from (1.0,0.0) POS enlarge 999 length") {
		Point2 point2 = CurveCalculation::D0(999.0, line2); 
		CHECK(point2.X() == 1000.0);
		CHECK(point2.Y() == 0.0);
	}}
SECTION("u = M_PI") {
		CurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);
		CHECK(p.X() == -1.0);
		CHECK(p.Y() == Approx(1.0));
		CHECK(p.Z() == 0.0);
		CHECK(v1.X() == Approx(0.0).margin(1e-14));
		CHECK(v1.Y() == Approx(-2.0));
		CHECK(v1.Z() == Approx(0.0));
		CHECK(v2.X() == Approx(2.0));
		CHECK(v2.Y() == Approx(0.0).margin(1e-12));
		CHECK(v2.Z() == Approx(0.0));
		CHECK(v3.X() == Approx(0.0).margin(1e-12));
		CHECK(v3.Y() == Approx(2.0));
		CHECK(v3.Z() == Approx(0.0));
	;
	SECTION("from (1.0,0.0) POS enlarge 999 length") {
		Point2 point2 = CurveCalculation::D0(999.0, line2); 
		CHECK(point2.X() == 1000.0);
		CHECK(point2.Y() == 0.0);
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] AMCAX_API static Vector3 D3(double u, const Parabola3& parabola)	 @return The third derivative vector
	 @param parabola The parabola
	 @param u The parameter
	 @brief Compute the third derivative on a 3D parabola at a parameter
,
 "output":SECTION("u = M_PI") {
		CurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);
		CHECK(p.X() == -1.0);
		CHECK(p.Y() == Approx(1.0));
		CHECK(p.Z() == 0.0);
		CHECK(v1.X() == Approx(0.0).margin(1e-14));
		CHECK(v1.Y() == Approx(-2.0));
		CHECK(v1.Z() == Approx(0.0));
		CHECK(v2.X() == Approx(2.0));
		CHECK(v2.Y() == Approx(0.0).margin(1e-12));
		CHECK(v2.Z() == Approx(0.0));
		CHECK(v3.X() == Approx(0.0).margin(1e-12));
		CHECK(v3.Y() == Approx(2.0));
		CHECK(v3.Z() == Approx(0.0));
	;
	SECTION("from (1.0,0.0) POS enlarge 999 length") {
		Point2 point2 = CurveCalculation::D0(999.0, line2); 
		CHECK(point2.X() == 1000.0);
		CHECK(point2.Y() == 0.0);
	}}
SECTION("u = M_PI") {
		CurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);
		CHECK(p.X() == -1.0);
		CHECK(p.Y() == Approx(1.0));
		CHECK(p.Z() == 0.0);
		CHECK(v1.X() == Approx(0.0).margin(1e-14));
		CHECK(v1.Y() == Approx(-2.0));
		CHECK(v1.Z() == Approx(0.0));
		CHECK(v2.X() == Approx(2.0));
		CHECK(v2.Y() == Approx(0.0).margin(1e-12));
		CHECK(v2.Z() == Approx(0.0));
		CHECK(v3.X() == Approx(0.0).margin(1e-12));
		CHECK(v3.Y() == Approx(2.0));
		CHECK(v3.Z() == Approx(0.0));
	;
	SECTION("u =0") {
		CurveCalculation::D3(0.0, circle2, p, v1, v2,v3);
		CHECK(p.X() == 3.0);
		CHECK(p.Y() == 1.0);
		CHECK(v1.X() == 0.0);
		CHECK(v1.Y() == 2.0);
		CHECK(v2.X() == -2.0);
		CHECK(v2.Y() == 0.0);
		CHECK(v3.X() == 0.0);
		CHECK(v3.Y() == -2.0);
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static void D3(double u, const Parabola3& parabola, Point3& p, Vector3& v1, Vector3& v2, Vector3& v3)	 @param[out] v3 The third derivative
	 @param[out] v2 The second derivative
	 @param[out] v1 The first derivative
	 @param[out] p The point
	 @param[in] parabola The parabola
	 @param[in] u The parameter
	 @brief Compute the point and the first three derivatives on a 3D parabola at a parameter
,
 "output":SECTION("u = M_PI") {
		CurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);
		CHECK(p.X() == -1.0);
		CHECK(p.Y() == Approx(1.0));
		CHECK(p.Z() == 0.0);
		CHECK(v1.X() == Approx(0.0).margin(1e-14));
		CHECK(v1.Y() == Approx(-2.0));
		CHECK(v1.Z() == Approx(0.0));
		CHECK(v2.X() == Approx(2.0));
		CHECK(v2.Y() == Approx(0.0).margin(1e-12));
		CHECK(v2.Z() == Approx(0.0));
		CHECK(v3.X() == Approx(0.0).margin(1e-12));
		CHECK(v3.Y() == Approx(2.0));
		CHECK(v3.Z() == Approx(0.0));
	;
	SECTION("from (1.0,0.0) POS enlarge 999 length") {
		Point2 point2 = CurveCalculation::D0(999.0, line2); 
		CHECK(point2.X() == 1000.0);
		CHECK(point2.Y() == 0.0);
	}}
SECTION("u = M_PI") {
		CurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);
		CHECK(p.X() == -1.0);
		CHECK(p.Y() == Approx(1.0));
		CHECK(p.Z() == 0.0);
		CHECK(v1.X() == Approx(0.0).margin(1e-14));
		CHECK(v1.Y() == Approx(-2.0));
		CHECK(v1.Z() == Approx(0.0));
		CHECK(v2.X() == Approx(2.0));
		CHECK(v2.Y() == Approx(0.0).margin(1e-12));
		CHECK(v2.Z() == Approx(0.0));
		CHECK(v3.X() == Approx(0.0).margin(1e-12));
		CHECK(v3.Y() == Approx(2.0));
		CHECK(v3.Z() == Approx(0.0));
	;
	SECTION("from (1.0,0.0) POS enlarge 999 length") {
		Point2 point2 = CurveCalculation::D0(999.0, line2); 
		CHECK(point2.X() == 1000.0);
		CHECK(point2.Y() == 0.0);
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] AMCAX_API static Vector3 D3(double u, const Hyperbola3& hyperbola)	 @return The third derivative vector
	 @param hyperbola The hyperbola
	 @param u The parameter
	 @brief Compute the third derivative on a 3D hyperbola at a parameter
,
 "output":SECTION("u = M_PI") {
		CurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);
		CHECK(p.X() == -1.0);
		CHECK(p.Y() == Approx(1.0));
		CHECK(p.Z() == 0.0);
		CHECK(v1.X() == Approx(0.0).margin(1e-14));
		CHECK(v1.Y() == Approx(-2.0));
		CHECK(v1.Z() == Approx(0.0));
		CHECK(v2.X() == Approx(2.0));
		CHECK(v2.Y() == Approx(0.0).margin(1e-12));
		CHECK(v2.Z() == Approx(0.0));
		CHECK(v3.X() == Approx(0.0).margin(1e-12));
		CHECK(v3.Y() == Approx(2.0));
		CHECK(v3.Z() == Approx(0.0));
	;
	SECTION("from (1.0,0.0) POS enlarge 999 length") {
		Point2 point2 = CurveCalculation::D0(999.0, line2); 
		CHECK(point2.X() == 1000.0);
		CHECK(point2.Y() == 0.0);
	}}
SECTION("u = M_PI") {
		CurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);
		CHECK(p.X() == -1.0);
		CHECK(p.Y() == Approx(1.0));
		CHECK(p.Z() == 0.0);
		CHECK(v1.X() == Approx(0.0).margin(1e-14));
		CHECK(v1.Y() == Approx(-2.0));
		CHECK(v1.Z() == Approx(0.0));
		CHECK(v2.X() == Approx(2.0));
		CHECK(v2.Y() == Approx(0.0).margin(1e-12));
		CHECK(v2.Z() == Approx(0.0));
		CHECK(v3.X() == Approx(0.0).margin(1e-12));
		CHECK(v3.Y() == Approx(2.0));
		CHECK(v3.Z() == Approx(0.0));
	;
	SECTION("u =0") {
		CurveCalculation::D3(0.0, circle2, p, v1, v2,v3);
		CHECK(p.X() == 3.0);
		CHECK(p.Y() == 1.0);
		CHECK(v1.X() == 0.0);
		CHECK(v1.Y() == 2.0);
		CHECK(v2.X() == -2.0);
		CHECK(v2.Y() == 0.0);
		CHECK(v3.X() == 0.0);
		CHECK(v3.Y() == -2.0);
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static void D3(double u, const Hyperbola3& hyperbola, Point3& p, Vector3& v1, Vector3& v2, Vector3& v3)	 @param[out] v3 The third derivative
	 @param[out] v2 The second derivative
	 @param[out] v1 The first derivative
	 @param[out] p The point
	 @param[in] hyperbola The hyperbola
	 @param[in] u The parameter
	 @brief Compute the point and the first three derivatives on a 3D hyperbola at a parameter
,
 "output":SECTION("u = M_PI") {
		CurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);
		CHECK(p.X() == -1.0);
		CHECK(p.Y() == Approx(1.0));
		CHECK(p.Z() == 0.0);
		CHECK(v1.X() == Approx(0.0).margin(1e-14));
		CHECK(v1.Y() == Approx(-2.0));
		CHECK(v1.Z() == Approx(0.0));
		CHECK(v2.X() == Approx(2.0));
		CHECK(v2.Y() == Approx(0.0).margin(1e-12));
		CHECK(v2.Z() == Approx(0.0));
		CHECK(v3.X() == Approx(0.0).margin(1e-12));
		CHECK(v3.Y() == Approx(2.0));
		CHECK(v3.Z() == Approx(0.0));
	;
	SECTION("from (1.0,0.0) POS enlarge 999 length") {
		Point2 point2 = CurveCalculation::D0(999.0, line2); 
		CHECK(point2.X() == 1000.0);
		CHECK(point2.Y() == 0.0);
	}}
SECTION("u = M_PI") {
		CurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);
		CHECK(p.X() == -1.0);
		CHECK(p.Y() == Approx(1.0));
		CHECK(p.Z() == 0.0);
		CHECK(v1.X() == Approx(0.0).margin(1e-14));
		CHECK(v1.Y() == Approx(-2.0));
		CHECK(v1.Z() == Approx(0.0));
		CHECK(v2.X() == Approx(2.0));
		CHECK(v2.Y() == Approx(0.0).margin(1e-12));
		CHECK(v2.Z() == Approx(0.0));
		CHECK(v3.X() == Approx(0.0).margin(1e-12));
		CHECK(v3.Y() == Approx(2.0));
		CHECK(v3.Z() == Approx(0.0));
	;
	SECTION("from (1.0,0.0) POS enlarge 999 length") {
		Point2 point2 = CurveCalculation::D0(999.0, line2); 
		CHECK(point2.X() == 1000.0);
		CHECK(point2.Y() == 0.0);
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] AMCAX_API static Vector2 D3(double u, const Line2& line)	 @return The third derivative vector
	 @param line The line
	 @param u The parameter
	 @brief Compute the third derivative on a 2D line at a parameter
,
 "output":SECTION("u = M_PI") {
		CurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);
		CHECK(p.X() == -1.0);
		CHECK(p.Y() == Approx(1.0));
		CHECK(p.Z() == 0.0);
		CHECK(v1.X() == Approx(0.0).margin(1e-14));
		CHECK(v1.Y() == Approx(-2.0));
		CHECK(v1.Z() == Approx(0.0));
		CHECK(v2.X() == Approx(2.0));
		CHECK(v2.Y() == Approx(0.0).margin(1e-12));
		CHECK(v2.Z() == Approx(0.0));
		CHECK(v3.X() == Approx(0.0).margin(1e-12));
		CHECK(v3.Y() == Approx(2.0));
		CHECK(v3.Z() == Approx(0.0));
	;
	SECTION("from (1.0,0.0) POS enlarge 999 length") {
		Point2 point2 = CurveCalculation::D0(999.0, line2); 
		CHECK(point2.X() == 1000.0);
		CHECK(point2.Y() == 0.0);
	}}
SECTION("u = M_PI") {
		CurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);
		CHECK(p.X() == -1.0);
		CHECK(p.Y() == Approx(1.0));
		CHECK(p.Z() == 0.0);
		CHECK(v1.X() == Approx(0.0).margin(1e-14));
		CHECK(v1.Y() == Approx(-2.0));
		CHECK(v1.Z() == Approx(0.0));
		CHECK(v2.X() == Approx(2.0));
		CHECK(v2.Y() == Approx(0.0).margin(1e-12));
		CHECK(v2.Z() == Approx(0.0));
		CHECK(v3.X() == Approx(0.0).margin(1e-12));
		CHECK(v3.Y() == Approx(2.0));
		CHECK(v3.Z() == Approx(0.0));
	;
	SECTION("u =0") {
		Point2 point2 = CurveCalculation::D0(0.0, parabola2);
		CHECK(point2.X() == 0.0);
		CHECK(point2.Y() == 0.0);
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static void D3(double u, const Line2& line, Point2& p, Vector2& v1, Vector2& v2, Vector2& v3)	 @param[out] v3 The third derivative
	 @param[out] v2 The second derivative
	 @param[out] v1 The first derivative
	 @param[out] p The point
	 @param[in] line The line
	 @param[in] u The parameter
	 @brief Compute the point and the first three derivatives on a 2D line at a parameter
,
 "output":SECTION("u = M_PI") {
		CurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);
		CHECK(p.X() == -1.0);
		CHECK(p.Y() == Approx(1.0));
		CHECK(p.Z() == 0.0);
		CHECK(v1.X() == Approx(0.0).margin(1e-14));
		CHECK(v1.Y() == Approx(-2.0));
		CHECK(v1.Z() == Approx(0.0));
		CHECK(v2.X() == Approx(2.0));
		CHECK(v2.Y() == Approx(0.0).margin(1e-12));
		CHECK(v2.Z() == Approx(0.0));
		CHECK(v3.X() == Approx(0.0).margin(1e-12));
		CHECK(v3.Y() == Approx(2.0));
		CHECK(v3.Z() == Approx(0.0));
	;
	SECTION("from (1.0,0.0) POS enlarge 999 length") {
		Point2 point2 = CurveCalculation::D0(999.0, line2); 
		CHECK(point2.X() == 1000.0);
		CHECK(point2.Y() == 0.0);
	}}
SECTION("u = M_PI") {
		CurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);
		CHECK(p.X() == -1.0);
		CHECK(p.Y() == Approx(1.0));
		CHECK(p.Z() == 0.0);
		CHECK(v1.X() == Approx(0.0).margin(1e-14));
		CHECK(v1.Y() == Approx(-2.0));
		CHECK(v1.Z() == Approx(0.0));
		CHECK(v2.X() == Approx(2.0));
		CHECK(v2.Y() == Approx(0.0).margin(1e-12));
		CHECK(v2.Z() == Approx(0.0));
		CHECK(v3.X() == Approx(0.0).margin(1e-12));
		CHECK(v3.Y() == Approx(2.0));
		CHECK(v3.Z() == Approx(0.0));
	;
	SECTION("from (1.0,0.0) POS enlarge 999 length") {
		Point2 point2 = CurveCalculation::D0(999.0, line2); 
		CHECK(point2.X() == 1000.0);
		CHECK(point2.Y() == 0.0);
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] AMCAX_API static Vector2 D3(double u, const Circle2& circle)	 @return The third derivative vector
	 @param circle The circle
	 @param u The parameter
	 @brief Compute the third derivative on a 2D circle at a parameter
,
 "output":SECTION("u = M_PI") {
		CurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);
		CHECK(p.X() == -1.0);
		CHECK(p.Y() == Approx(1.0));
		CHECK(p.Z() == 0.0);
		CHECK(v1.X() == Approx(0.0).margin(1e-14));
		CHECK(v1.Y() == Approx(-2.0));
		CHECK(v1.Z() == Approx(0.0));
		CHECK(v2.X() == Approx(2.0));
		CHECK(v2.Y() == Approx(0.0).margin(1e-12));
		CHECK(v2.Z() == Approx(0.0));
		CHECK(v3.X() == Approx(0.0).margin(1e-12));
		CHECK(v3.Y() == Approx(2.0));
		CHECK(v3.Z() == Approx(0.0));
	;
	SECTION("from (1.0,0.0) POS enlarge 999 length") {
		Point2 point2 = CurveCalculation::D0(999.0, line2); 
		CHECK(point2.X() == 1000.0);
		CHECK(point2.Y() == 0.0);
	}}
SECTION("u = M_PI") {
		CurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);
		CHECK(p.X() == -1.0);
		CHECK(p.Y() == Approx(1.0));
		CHECK(p.Z() == 0.0);
		CHECK(v1.X() == Approx(0.0).margin(1e-14));
		CHECK(v1.Y() == Approx(-2.0));
		CHECK(v1.Z() == Approx(0.0));
		CHECK(v2.X() == Approx(2.0));
		CHECK(v2.Y() == Approx(0.0).margin(1e-12));
		CHECK(v2.Z() == Approx(0.0));
		CHECK(v3.X() == Approx(0.0).margin(1e-12));
		CHECK(v3.Y() == Approx(2.0));
		CHECK(v3.Z() == Approx(0.0));
	;
	SECTION("from (1.0,0.0) POS enlarge 999 length") {
		Point2 point2 = CurveCalculation::D0(999.0, line2); 
		CHECK(point2.X() == 1000.0);
		CHECK(point2.Y() == 0.0);
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static void D3(double u, const Circle2& circle, Point2& p, Vector2& v1, Vector2& v2, Vector2& v3)	 @param[out] v3 The third derivative
	 @param[out] v2 The second derivative
	 @param[out] v1 The first derivative
	 @param[out] p The point
	 @param[in] circle The circle
	 @param[in] u The parameter
	 @brief Compute the point and the first three derivatives on a 2D circle at a parameter
,
 "output":SECTION("u = M_PI") {
		CurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);
		CHECK(p.X() == -1.0);
		CHECK(p.Y() == Approx(1.0));
		CHECK(p.Z() == 0.0);
		CHECK(v1.X() == Approx(0.0).margin(1e-14));
		CHECK(v1.Y() == Approx(-2.0));
		CHECK(v1.Z() == Approx(0.0));
		CHECK(v2.X() == Approx(2.0));
		CHECK(v2.Y() == Approx(0.0).margin(1e-12));
		CHECK(v2.Z() == Approx(0.0));
		CHECK(v3.X() == Approx(0.0).margin(1e-12));
		CHECK(v3.Y() == Approx(2.0));
		CHECK(v3.Z() == Approx(0.0));
	;
	SECTION("from (1.0,0.0) POS enlarge 999 length") {
		Point2 point2 = CurveCalculation::D0(999.0, line2); 
		CHECK(point2.X() == 1000.0);
		CHECK(point2.Y() == 0.0);
	}}
SECTION("u = M_PI") {
		CurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);
		CHECK(p.X() == -1.0);
		CHECK(p.Y() == Approx(1.0));
		CHECK(p.Z() == 0.0);
		CHECK(v1.X() == Approx(0.0).margin(1e-14));
		CHECK(v1.Y() == Approx(-2.0));
		CHECK(v1.Z() == Approx(0.0));
		CHECK(v2.X() == Approx(2.0));
		CHECK(v2.Y() == Approx(0.0).margin(1e-12));
		CHECK(v2.Z() == Approx(0.0));
		CHECK(v3.X() == Approx(0.0).margin(1e-12));
		CHECK(v3.Y() == Approx(2.0));
		CHECK(v3.Z() == Approx(0.0));
	;
	SECTION("from (1.0,0.0) POS enlarge 999 length") {
		Point2 point2 = CurveCalculation::D0(999.0, line2); 
		CHECK(point2.X() == 1000.0);
		CHECK(point2.Y() == 0.0);
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] AMCAX_API static Vector2 D3(double u, const Ellipse2& ellipse)	 @return The third derivative vector
	 @param ellipse The ellipse
	 @param u The parameter
	 @brief Compute the third derivative on a 2D ellipse at a parameter
,
 "output":SECTION("u = M_PI") {
		CurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);
		CHECK(p.X() == -1.0);
		CHECK(p.Y() == Approx(1.0));
		CHECK(p.Z() == 0.0);
		CHECK(v1.X() == Approx(0.0).margin(1e-14));
		CHECK(v1.Y() == Approx(-2.0));
		CHECK(v1.Z() == Approx(0.0));
		CHECK(v2.X() == Approx(2.0));
		CHECK(v2.Y() == Approx(0.0).margin(1e-12));
		CHECK(v2.Z() == Approx(0.0));
		CHECK(v3.X() == Approx(0.0).margin(1e-12));
		CHECK(v3.Y() == Approx(2.0));
		CHECK(v3.Z() == Approx(0.0));
	;
	SECTION("from (1.0,0.0) POS enlarge 999 length") {
		Point2 point2 = CurveCalculation::D0(999.0, line2); 
		CHECK(point2.X() == 1000.0);
		CHECK(point2.Y() == 0.0);
	}}
SECTION("u = M_PI") {
		CurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);
		CHECK(p.X() == -1.0);
		CHECK(p.Y() == Approx(1.0));
		CHECK(p.Z() == 0.0);
		CHECK(v1.X() == Approx(0.0).margin(1e-14));
		CHECK(v1.Y() == Approx(-2.0));
		CHECK(v1.Z() == Approx(0.0));
		CHECK(v2.X() == Approx(2.0));
		CHECK(v2.Y() == Approx(0.0).margin(1e-12));
		CHECK(v2.Z() == Approx(0.0));
		CHECK(v3.X() == Approx(0.0).margin(1e-12));
		CHECK(v3.Y() == Approx(2.0));
		CHECK(v3.Z() == Approx(0.0));
	;
	SECTION("u =0") {
		CurveCalculation::D3(0.0, circle2, p, v1, v2,v3);
		CHECK(p.X() == 3.0);
		CHECK(p.Y() == 1.0);
		CHECK(v1.X() == 0.0);
		CHECK(v1.Y() == 2.0);
		CHECK(v2.X() == -2.0);
		CHECK(v2.Y() == 0.0);
		CHECK(v3.X() == 0.0);
		CHECK(v3.Y() == -2.0);
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static void D3(double u, const Ellipse2& ellipse, Point2& p, Vector2& v1, Vector2& v2, Vector2& v3)	 @param[out] v3 The third derivative
	 @param[out] v2 The second derivative
	 @param[out] v1 The first derivative
	 @param[out] p The point
	 @param[in] ellipse The ellipse
	 @param[in] u The parameter
	 @brief Compute the point and the first three derivatives on a 2D ellipse at a parameter
,
 "output":SECTION("u = M_PI") {
		CurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);
		CHECK(p.X() == -1.0);
		CHECK(p.Y() == Approx(1.0));
		CHECK(p.Z() == 0.0);
		CHECK(v1.X() == Approx(0.0).margin(1e-14));
		CHECK(v1.Y() == Approx(-2.0));
		CHECK(v1.Z() == Approx(0.0));
		CHECK(v2.X() == Approx(2.0));
		CHECK(v2.Y() == Approx(0.0).margin(1e-12));
		CHECK(v2.Z() == Approx(0.0));
		CHECK(v3.X() == Approx(0.0).margin(1e-12));
		CHECK(v3.Y() == Approx(2.0));
		CHECK(v3.Z() == Approx(0.0));
	;
	SECTION("from (1.0,0.0) POS enlarge 999 length") {
		Point2 point2 = CurveCalculation::D0(999.0, line2); 
		CHECK(point2.X() == 1000.0);
		CHECK(point2.Y() == 0.0);
	}}
SECTION("u = M_PI") {
		CurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);
		CHECK(p.X() == -1.0);
		CHECK(p.Y() == Approx(1.0));
		CHECK(p.Z() == 0.0);
		CHECK(v1.X() == Approx(0.0).margin(1e-14));
		CHECK(v1.Y() == Approx(-2.0));
		CHECK(v1.Z() == Approx(0.0));
		CHECK(v2.X() == Approx(2.0));
		CHECK(v2.Y() == Approx(0.0).margin(1e-12));
		CHECK(v2.Z() == Approx(0.0));
		CHECK(v3.X() == Approx(0.0).margin(1e-12));
		CHECK(v3.Y() == Approx(2.0));
		CHECK(v3.Z() == Approx(0.0));
	;
	SECTION("from (1.0,0.0) POS enlarge 999 length") {
		Point2 point2 = CurveCalculation::D0(999.0, line2); 
		CHECK(point2.X() == 1000.0);
		CHECK(point2.Y() == 0.0);
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] AMCAX_API static Vector2 D3(double u, const Parabola2& parabola)	 @return The third derivative vector
	 @param parabola The parabola
	 @param u The parameter
	 @brief Compute the third derivative on a 2D parabola at a parameter
,
 "output":SECTION("u = M_PI") {
		CurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);
		CHECK(p.X() == -1.0);
		CHECK(p.Y() == Approx(1.0));
		CHECK(p.Z() == 0.0);
		CHECK(v1.X() == Approx(0.0).margin(1e-14));
		CHECK(v1.Y() == Approx(-2.0));
		CHECK(v1.Z() == Approx(0.0));
		CHECK(v2.X() == Approx(2.0));
		CHECK(v2.Y() == Approx(0.0).margin(1e-12));
		CHECK(v2.Z() == Approx(0.0));
		CHECK(v3.X() == Approx(0.0).margin(1e-12));
		CHECK(v3.Y() == Approx(2.0));
		CHECK(v3.Z() == Approx(0.0));
	;
	SECTION("from (1.0,0.0) POS enlarge 999 length") {
		Point2 point2 = CurveCalculation::D0(999.0, line2); 
		CHECK(point2.X() == 1000.0);
		CHECK(point2.Y() == 0.0);
	}}
SECTION("u = M_PI") {
		CurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);
		CHECK(p.X() == -1.0);
		CHECK(p.Y() == Approx(1.0));
		CHECK(p.Z() == 0.0);
		CHECK(v1.X() == Approx(0.0).margin(1e-14));
		CHECK(v1.Y() == Approx(-2.0));
		CHECK(v1.Z() == Approx(0.0));
		CHECK(v2.X() == Approx(2.0));
		CHECK(v2.Y() == Approx(0.0).margin(1e-12));
		CHECK(v2.Z() == Approx(0.0));
		CHECK(v3.X() == Approx(0.0).margin(1e-12));
		CHECK(v3.Y() == Approx(2.0));
		CHECK(v3.Z() == Approx(0.0));
	;
	SECTION("u =0") {  
		Point2 point2 = CurveCalculation::D0(0.0, parabola2);
		CHECK(point2.X() == 0.0);
		CHECK(point2.Y() == 0.0);
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static void D3(double u, const Parabola2& parabola, Point2& p, Vector2& v1, Vector2& v2, Vector2& v3)	 @param[out] v3 The third derivative
	 @param[out] v2 The second derivative
	 @param[out] v1 The first derivative
	 @param[out] p The point
	 @param[in] parabola The parabola
	 @param[in] u The parameter
	 @brief Compute the point and the first three derivatives on a 2D parabola at a parameter
,
 "output":SECTION("u = M_PI") {
		CurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);
		CHECK(p.X() == -1.0);
		CHECK(p.Y() == Approx(1.0));
		CHECK(p.Z() == 0.0);
		CHECK(v1.X() == Approx(0.0).margin(1e-14));
		CHECK(v1.Y() == Approx(-2.0));
		CHECK(v1.Z() == Approx(0.0));
		CHECK(v2.X() == Approx(2.0));
		CHECK(v2.Y() == Approx(0.0).margin(1e-12));
		CHECK(v2.Z() == Approx(0.0));
		CHECK(v3.X() == Approx(0.0).margin(1e-12));
		CHECK(v3.Y() == Approx(2.0));
		CHECK(v3.Z() == Approx(0.0));
	;
	SECTION("from (1.0,0.0) POS enlarge 999 length") {
		Point2 point2 = CurveCalculation::D0(999.0, line2); 
		CHECK(point2.X() == 1000.0);
		CHECK(point2.Y() == 0.0);
	}}
SECTION("u = M_PI") {
		CurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);
		CHECK(p.X() == -1.0);
		CHECK(p.Y() == Approx(1.0));
		CHECK(p.Z() == 0.0);
		CHECK(v1.X() == Approx(0.0).margin(1e-14));
		CHECK(v1.Y() == Approx(-2.0));
		CHECK(v1.Z() == Approx(0.0));
		CHECK(v2.X() == Approx(2.0));
		CHECK(v2.Y() == Approx(0.0).margin(1e-12));
		CHECK(v2.Z() == Approx(0.0));
		CHECK(v3.X() == Approx(0.0).margin(1e-12));
		CHECK(v3.Y() == Approx(2.0));
		CHECK(v3.Z() == Approx(0.0));
	;
	SECTION("from (1.0,0.0) POS enlarge 999 length") {
		Point2 point2 = CurveCalculation::D0(999.0, line2); 
		CHECK(point2.X() == 1000.0);
		CHECK(point2.Y() == 0.0);
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] AMCAX_API static Vector2 D3(double u, const Hyperbola2& hyperbola)	 @return The third derivative vector
	 @param hyperbola The hyperbola
	 @param u The parameter
	 @brief Compute the third derivative on a 2D hyperbola at a parameter
,
 "output":SECTION("u = M_PI") {
		CurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);
		CHECK(p.X() == -1.0);
		CHECK(p.Y() == Approx(1.0));
		CHECK(p.Z() == 0.0);
		CHECK(v1.X() == Approx(0.0).margin(1e-14));
		CHECK(v1.Y() == Approx(-2.0));
		CHECK(v1.Z() == Approx(0.0));
		CHECK(v2.X() == Approx(2.0));
		CHECK(v2.Y() == Approx(0.0).margin(1e-12));
		CHECK(v2.Z() == Approx(0.0));
		CHECK(v3.X() == Approx(0.0).margin(1e-12));
		CHECK(v3.Y() == Approx(2.0));
		CHECK(v3.Z() == Approx(0.0));
	;
	SECTION("from (1.0,0.0) POS enlarge 999 length") {
		Point2 point2 = CurveCalculation::D0(999.0, line2); 
		CHECK(point2.X() == 1000.0);
		CHECK(point2.Y() == 0.0);
	}}
SECTION("u = M_PI") {
		CurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);
		CHECK(p.X() == -1.0);
		CHECK(p.Y() == Approx(1.0));
		CHECK(p.Z() == 0.0);
		CHECK(v1.X() == Approx(0.0).margin(1e-14));
		CHECK(v1.Y() == Approx(-2.0));
		CHECK(v1.Z() == Approx(0.0));
		CHECK(v2.X() == Approx(2.0));
		CHECK(v2.Y() == Approx(0.0).margin(1e-12));
		CHECK(v2.Z() == Approx(0.0));
		CHECK(v3.X() == Approx(0.0).margin(1e-12));
		CHECK(v3.Y() == Approx(2.0));
		CHECK(v3.Z() == Approx(0.0));
	;
	SECTION("u =0") {
		CurveCalculation::D3(0.0, circle2, p, v1, v2,v3);
		CHECK(p.X() == 3.0);
		CHECK(p.Y() == 1.0);
		CHECK(v1.X() == 0.0);
		CHECK(v1.Y() == 2.0);
		CHECK(v2.X() == -2.0);
		CHECK(v2.Y() == 0.0);
		CHECK(v3.X() == 0.0);
		CHECK(v3.Y() == -2.0);
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static void D3(double u, const Hyperbola2& hyperbola, Point2& p, Vector2& v1, Vector2& v2, Vector2& v3)	 @param[out] v3 The third derivative
	 @param[out] v2 The second derivative
	 @param[out] v1 The first derivative
	 @param[out] p The point
	 @param[in] hyperbola The hyperbola
	 @param[in] u The parameter
	 @brief Compute the point and the first three derivatives on a 2D hyperbola at a parameter
,
 "output":SECTION("u = M_PI") {
		CurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);
		CHECK(p.X() == -1.0);
		CHECK(p.Y() == Approx(1.0));
		CHECK(p.Z() == 0.0);
		CHECK(v1.X() == Approx(0.0).margin(1e-14));
		CHECK(v1.Y() == Approx(-2.0));
		CHECK(v1.Z() == Approx(0.0));
		CHECK(v2.X() == Approx(2.0));
		CHECK(v2.Y() == Approx(0.0).margin(1e-12));
		CHECK(v2.Z() == Approx(0.0));
		CHECK(v3.X() == Approx(0.0).margin(1e-12));
		CHECK(v3.Y() == Approx(2.0));
		CHECK(v3.Z() == Approx(0.0));
	;
	SECTION("from (1.0,0.0) POS enlarge 999 length") {
		Point2 point2 = CurveCalculation::D0(999.0, line2); 
		CHECK(point2.X() == 1000.0);
		CHECK(point2.Y() == 0.0);
	}}
SECTION("u = M_PI") {
		CurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);
		CHECK(p.X() == -1.0);
		CHECK(p.Y() == Approx(1.0));
		CHECK(p.Z() == 0.0);
		CHECK(v1.X() == Approx(0.0).margin(1e-14));
		CHECK(v1.Y() == Approx(-2.0));
		CHECK(v1.Z() == Approx(0.0));
		CHECK(v2.X() == Approx(2.0));
		CHECK(v2.Y() == Approx(0.0).margin(1e-12));
		CHECK(v2.Z() == Approx(0.0));
		CHECK(v3.X() == Approx(0.0).margin(1e-12));
		CHECK(v3.Y() == Approx(2.0));
		CHECK(v3.Z() == Approx(0.0));
	;
	SECTION("from (1.0,0.0) POS enlarge 999 length") {
		Point2 point2 = CurveCalculation::D0(999.0, line2); 
		CHECK(point2.X() == 1000.0);
		CHECK(point2.Y() == 0.0);
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static void CircleD3(double u, const Frame3& pos, double radius, Point3& p, Vector3& v1, Vector3& v2, Vector3& v3)	 @param[out] v3 The third derivative
	 @param[out] v2 The second derivative
	 @param[out] v1 The first derivative
	 @param[out] p The point
	 @param[in] radius The radius
	 @param[in] pos The local frame where the circle lies
	 @param[in] u The parameter
	 @brief Compute the point and the first three derivatives on a 3D circle represented by a local frame and a radius at a parameter
,
 "output":SECTION("u = M_PI") {
		CurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);
		CHECK(p.X() == -1.0);
		CHECK(p.Y() == Approx(1.0));
		CHECK(p.Z() == 0.0);
		CHECK(v1.X() == Approx(0.0).margin(1e-14));
		CHECK(v1.Y() == Approx(-2.0));
		CHECK(v1.Z() == Approx(0.0));
		CHECK(v2.X() == Approx(2.0));
		CHECK(v2.Y() == Approx(0.0).margin(1e-12));
		CHECK(v2.Z() == Approx(0.0));
		CHECK(v3.X() == Approx(0.0).margin(1e-12));
		CHECK(v3.Y() == Approx(2.0));
		CHECK(v3.Z() == Approx(0.0));
	;
	SECTION("from (1.0,0.0) POS enlarge 999 length") {
		Point2 point2 = CurveCalculation::D0(999.0, line2); 
		CHECK(point2.X() == 1000.0);
		CHECK(point2.Y() == 0.0);
	}}
SECTION("u = M_PI") {
		CurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);
		CHECK(p.X() == -1.0);
		CHECK(p.Y() == Approx(1.0));
		CHECK(p.Z() == 0.0);
		CHECK(v1.X() == Approx(0.0).margin(1e-14));
		CHECK(v1.Y() == Approx(-2.0));
		CHECK(v1.Z() == Approx(0.0));
		CHECK(v2.X() == Approx(2.0));
		CHECK(v2.Y() == Approx(0.0).margin(1e-12));
		CHECK(v2.Z() == Approx(0.0));
		CHECK(v3.X() == Approx(0.0).margin(1e-12));
		CHECK(v3.Y() == Approx(2.0));
		CHECK(v3.Z() == Approx(0.0));
	;
	SECTION("u =0") {  
		Point2 point2 = CurveCalculation::D0(0.0, parabola2); 
		CHECK(point2.X() == 0.0);
		CHECK(point2.Y() == 0.0);
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API Cylinder(const Frame3& frame, double r)	 @param r The radius
	 @param frame The local frame
	 @brief Construct from a local frame and a radius
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <common/FrameT.hpp>
#include <modeling/MakeFace.hpp>
#include <common/AxisT.hpp>
#include <math/Cylinder.hpp>
#include <common/VectorT.hpp>
#include <occtio/OCCTTool.hpp>
#include <modeling/MakeCylinder.hpp>
#include <iostream>
using namespace AMCAX;
using namespace std;
#include <catch.hpp>
#include <testHelper.h>
#include <common/FrameT.hpp>
#include <modeling/MakeFace.hpp>
#include <common/AxisT.hpp>
#include <math/Cylinder.hpp>
#include <common/VectorT.hpp>
#include <occtio/OCCTTool.hpp>
#include <modeling/MakeCylinder.hpp>
#include <iostream>
using namespace AMCAX;
using namespace std;
;
	SECTION("IsDirect")
	{
		bool isDirect = cylinder.IsDirect();
		CHECK(isDirect == true);
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API Cylinder& Scale(const Point3& point, double scale)	 @return The reference to self
	 @param scale The scale value
	 @param point The scaling center point
	 @brief Scale the cylinder by a point
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <common/FrameT.hpp>
#include <modeling/MakeFace.hpp>
#include <common/AxisT.hpp>
#include <math/Cylinder.hpp>
#include <common/VectorT.hpp>
#include <occtio/OCCTTool.hpp>
#include <modeling/MakeCylinder.hpp>
#include <iostream>
using namespace AMCAX;
using namespace std;
#include <catch.hpp>
#include <testHelper.h>
#include <common/FrameT.hpp>
#include <modeling/MakeFace.hpp>
#include <common/AxisT.hpp>
#include <math/Cylinder.hpp>
#include <common/VectorT.hpp>
#include <occtio/OCCTTool.hpp>
#include <modeling/MakeCylinder.hpp>
#include <iostream>
using namespace AMCAX;
using namespace std;
;
	SECTION("Scale")
	{
		Cylinder scale_cylinder = cylinder.Scale(point_cy, scale);
		CHECK(cylinder.Radius() == Approx(2.5));
		CHECK(cylinder.Location().X() == Approx(6.0));
		CHECK(cylinder.Location().Y() == Approx(0.0));
		CHECK(cylinder.Location().Z() == Approx(0.0));
		CHECK(cylinder.Axis().Direction().X() == 0.0);
		CHECK(cylinder.Axis().Direction().Y() == 0.0);
		CHECK(cylinder.Axis().Direction().Z() == 1.0);
		CHECK(scale_cylinder.Radius() == Approx(2.5));
		CHECK(scale_cylinder.Location().X() == Approx(6.0));
		CHECK(scale_cylinder.Location().Y() == Approx(0.0));
		CHECK(scale_cylinder.Location().Z() == Approx(0.0));
		CHECK(scale_cylinder.Axis().Direction().X() == 0.0);
		CHECK(scale_cylinder.Axis().Direction().Y() == 0.0);
		CHECK(scale_cylinder.Axis().Direction().Z() == 1.0);
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API Cylinder& Transform(const Transformation3& tr)	 @return The reference to self
	 @param tr The transformation
	 @brief Transform the cylinder
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <common/FrameT.hpp>
#include <modeling/MakeFace.hpp>
#include <common/AxisT.hpp>
#include <math/Cylinder.hpp>
#include <common/VectorT.hpp>
#include <occtio/OCCTTool.hpp>
#include <modeling/MakeCylinder.hpp>
#include <iostream>
using namespace AMCAX;
using namespace std;
#include <catch.hpp>
#include <testHelper.h>
#include <common/FrameT.hpp>
#include <modeling/MakeFace.hpp>
#include <common/AxisT.hpp>
#include <math/Cylinder.hpp>
#include <common/VectorT.hpp>
#include <occtio/OCCTTool.hpp>
#include <modeling/MakeCylinder.hpp>
#include <iostream>
using namespace AMCAX;
using namespace std;
;
	SECTION("Transform")
	{
		Cylinder Transform_cylinder = cylinder.Transform(tr);
		CHECK(cylinder.Radius() == Approx(radius_cy));
		CHECK(cylinder.Location().X() == Approx(4.0));
		CHECK(cylinder.Location().Y() == Approx(3.0));
		CHECK(cylinder.Location().Z() == Approx(2.0));
		CHECK(cylinder.Axis().Direction().X() == Approx(0.0));
		CHECK(cylinder.Axis().Direction().Y() == Approx(0.0));
		CHECK(cylinder.Axis().Direction().Z() == Approx(1.0));
		CHECK(Transform_cylinder.Radius() == Approx(radius_cy));
		CHECK(Transform_cylinder.Location().X() == Approx(4.0));
		CHECK(Transform_cylinder.Location().Y() == Approx(3.0));
		CHECK(Transform_cylinder.Location().Z() == Approx(2.0));
		CHECK(Transform_cylinder.Axis().Direction().X() == Approx(0.0));
		CHECK(Transform_cylinder.Axis().Direction().Y() == Approx(0.0));
		CHECK(Transform_cylinder.Axis().Direction().Z() == Approx(1.0));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":void SetMajorRadius(double r)	 @param r The new major radius
	 @brief Set the major radius
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <modeling/MakeFace.hpp>
#include <common/AxisT.hpp>
#include <math/HyperbolaT.hpp>
#include <occtio/OCCTTool.hpp>
#include <common/VectorT.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <topology/TopoEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <common/TransformationT.hpp>
#include <iostream>
using namespace AMCAX;
using namespace std;
#include <catch.hpp>
#include <testHelper.h>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <modeling/MakeFace.hpp>
#include <common/AxisT.hpp>
#include <math/HyperbolaT.hpp>
#include <occtio/OCCTTool.hpp>
#include <common/VectorT.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <topology/TopoEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <common/TransformationT.hpp>
#include <iostream>
using namespace AMCAX;
using namespace std;
;
	SECTION("Default()") {
		Hyperbola2 hyperbola2d_de;	
		CHECK(hyperbola2d_de.Location().X() == Approx(0.0));
		CHECK(hyperbola2d_de.Location().Y() == Approx(0.0));
		hyperbola2d_de.SetMajorRadius(3.0);
		hyperbola2d_de.SetMinorRadius(4.0);
		CHECK(hyperbola2d_de.MajorRadius() == Approx(3.0));
		CHECK(hyperbola2d_de.MinorRadius() == Approx(4.0));
		CHECK(hyperbola2d_de.Focal() == Approx(10.0));
		CHECK(hyperbola2d_de.Focus1().X() == Approx(5.0));
		CHECK(hyperbola2d_de.Focus1().Y() == Approx(0.0));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":void SetMinorRadius(double r)	 @param r The new minor radius
	 @brief Set the minor radius
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <modeling/MakeFace.hpp>
#include <common/AxisT.hpp>
#include <math/HyperbolaT.hpp>
#include <occtio/OCCTTool.hpp>
#include <common/VectorT.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <topology/TopoEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <common/TransformationT.hpp>
#include <iostream>
using namespace AMCAX;
using namespace std;
#include <catch.hpp>
#include <testHelper.h>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <modeling/MakeFace.hpp>
#include <common/AxisT.hpp>
#include <math/HyperbolaT.hpp>
#include <occtio/OCCTTool.hpp>
#include <common/VectorT.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <topology/TopoEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <common/TransformationT.hpp>
#include <iostream>
using namespace AMCAX;
using namespace std;
;
	SECTION("SetMinorRadius()") {
		hyperbola2d_ax.SetMinorRadius(3.0);
		CHECK(hyperbola2d_ax.Location().X() == Approx(0.0));
		CHECK(hyperbola2d_ax.Location().Y() == Approx(0.0));
		CHECK(hyperbola2d_ax.MajorRadius() == Approx(3.0));
		CHECK(hyperbola2d_ax.MinorRadius() == Approx(3.0));
		Point3 point1(3.0, 0.0, 0.0);
		MakeEdge2d edge1(hyperbola2d_ax);
		CHECK(BRepClassificationTools::IsPointInOnEdge(edge1, point1, 0.001) == true);
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] AxisT<double, DIM> Directrix1()	 @return The positive directrix
	 @brief Get the directrix on the positive side of the major axis
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <modeling/MakeFace.hpp>
#include <common/AxisT.hpp>
#include <math/HyperbolaT.hpp>
#include <occtio/OCCTTool.hpp>
#include <common/VectorT.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <topology/TopoEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <common/TransformationT.hpp>
#include <iostream>
using namespace AMCAX;
using namespace std;
#include <catch.hpp>
#include <testHelper.h>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <modeling/MakeFace.hpp>
#include <common/AxisT.hpp>
#include <math/HyperbolaT.hpp>
#include <occtio/OCCTTool.hpp>
#include <common/VectorT.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <topology/TopoEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <common/TransformationT.hpp>
#include <iostream>
using namespace AMCAX;
using namespace std;
;
	SECTION("Directrix1()") {	
		Axis2 axis2d_dir = hyperbola2d_ax.Directrix1();
		CHECK(axis2d_dir.Direction().X() == Approx(0.0));
		CHECK(axis2d_dir.Direction().Y() == Approx(1.0));
		CHECK(axis2d_dir.Location().X() == Approx(9.0/5.0));
		CHECK(axis2d_dir.Location().Y() == Approx(0.0));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] AxisT<double, DIM> Directrix2()	 @return The negative directrix
	 @brief Get the directrix on the negative side of the major axis
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <modeling/MakeFace.hpp>
#include <common/AxisT.hpp>
#include <math/HyperbolaT.hpp>
#include <occtio/OCCTTool.hpp>
#include <common/VectorT.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <topology/TopoEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <common/TransformationT.hpp>
#include <iostream>
using namespace AMCAX;
using namespace std;
#include <catch.hpp>
#include <testHelper.h>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <modeling/MakeFace.hpp>
#include <common/AxisT.hpp>
#include <math/HyperbolaT.hpp>
#include <occtio/OCCTTool.hpp>
#include <common/VectorT.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <topology/TopoEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <common/TransformationT.hpp>
#include <iostream>
using namespace AMCAX;
using namespace std;
;
	SECTION("Directrix()") {
		Axis2 axis2d_dir = hyperbola2d_ax.Directrix2();
		CHECK(axis2d_dir.Direction().X() == Approx(0.0));
		CHECK(axis2d_dir.Direction().Y() == Approx(1.0));
		CHECK(axis2d_dir.Location().X() == Approx(-9.0 / 5.0));
		CHECK(axis2d_dir.Location().Y() == Approx(0.0));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] double Eccentricity()	 @return The eccentricity
	 @brief Get the eccentricity of the ellipse
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <modeling/MakeFace.hpp>
#include <common/AxisT.hpp>
#include <math/HyperbolaT.hpp>
#include <occtio/OCCTTool.hpp>
#include <common/VectorT.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <topology/TopoEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <common/TransformationT.hpp>
#include <iostream>
using namespace AMCAX;
using namespace std;
#include <catch.hpp>
#include <testHelper.h>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <modeling/MakeFace.hpp>
#include <common/AxisT.hpp>
#include <math/HyperbolaT.hpp>
#include <occtio/OCCTTool.hpp>
#include <common/VectorT.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <topology/TopoEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <common/TransformationT.hpp>
#include <iostream>
using namespace AMCAX;
using namespace std;
;
	SECTION("Eccentricity()") {	
		double e = hyperbola2d_ax.Eccentricity();
		CHECK(e == Approx(5.0 / 3.0));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] PointT<double, DIM> Focus1()	 @return The positive focus
	 @brief Get the focus on the positive side of the major axis
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <modeling/MakeFace.hpp>
#include <common/AxisT.hpp>
#include <math/HyperbolaT.hpp>
#include <occtio/OCCTTool.hpp>
#include <common/VectorT.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <topology/TopoEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <common/TransformationT.hpp>
#include <iostream>
using namespace AMCAX;
using namespace std;
#include <catch.hpp>
#include <testHelper.h>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <modeling/MakeFace.hpp>
#include <common/AxisT.hpp>
#include <math/HyperbolaT.hpp>
#include <occtio/OCCTTool.hpp>
#include <common/VectorT.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <topology/TopoEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <common/TransformationT.hpp>
#include <iostream>
using namespace AMCAX;
using namespace std;
;
	SECTION("Default()") {
		Hyperbola2 hyperbola2d_de;	
		CHECK(hyperbola2d_de.Location().X() == Approx(0.0));
		CHECK(hyperbola2d_de.Location().Y() == Approx(0.0));
		hyperbola2d_de.SetMajorRadius(3.0);
		hyperbola2d_de.SetMinorRadius(4.0);
		CHECK(hyperbola2d_de.MajorRadius() == Approx(3.0));
		CHECK(hyperbola2d_de.MinorRadius() == Approx(4.0));
		CHECK(hyperbola2d_de.Focal() == Approx(10.0));
		CHECK(hyperbola2d_de.Focus1().X() == Approx(5.0));
		CHECK(hyperbola2d_de.Focus1().Y() == Approx(0.0));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] PointT<double, DIM> Focus2()	 @return The negative focus
	 @brief Get the focus on the negative side of the major axis
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <modeling/MakeFace.hpp>
#include <common/AxisT.hpp>
#include <math/HyperbolaT.hpp>
#include <occtio/OCCTTool.hpp>
#include <common/VectorT.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <topology/TopoEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <common/TransformationT.hpp>
#include <iostream>
using namespace AMCAX;
using namespace std;
#include <catch.hpp>
#include <testHelper.h>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <modeling/MakeFace.hpp>
#include <common/AxisT.hpp>
#include <math/HyperbolaT.hpp>
#include <occtio/OCCTTool.hpp>
#include <common/VectorT.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <topology/TopoEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <common/TransformationT.hpp>
#include <iostream>
using namespace AMCAX;
using namespace std;
;
	SECTION("Focus2") {
		Point2 point2d_f1 = hyperbola2d_ax.Focus2();
		CHECK(point2d_f1.X() == Approx(-5.0));
		CHECK(point2d_f1.Y() == Approx(0.0));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] double MajorRadius()	 @return The major radius
	 @brief Get the major radius
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <modeling/MakeFace.hpp>
#include <common/AxisT.hpp>
#include <math/HyperbolaT.hpp>
#include <occtio/OCCTTool.hpp>
#include <common/VectorT.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <topology/TopoEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <common/TransformationT.hpp>
#include <iostream>
using namespace AMCAX;
using namespace std;
#include <catch.hpp>
#include <testHelper.h>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <modeling/MakeFace.hpp>
#include <common/AxisT.hpp>
#include <math/HyperbolaT.hpp>
#include <occtio/OCCTTool.hpp>
#include <common/VectorT.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <topology/TopoEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <common/TransformationT.hpp>
#include <iostream>
using namespace AMCAX;
using namespace std;
;
	SECTION("ConjugateBranch1()") {
		Point3 point1(0.0, 4.0, 0.0);
		Point3 point2(9.0 / 4.0, 5.0, 0.0);
		Hyperbola2 hyperbola2d_con = hyperbola2d_ax.ConjugateBranch1();
		MakeEdge2d edge1(hyperbola2d_con);
		CHECK(BRepClassificationTools::IsPointInOnEdge(edge1, point1, 0.001) == true);
		CHECK(BRepClassificationTools::IsPointInOnEdge(edge1, point2, 0.001) == true);
		double major2d_con = hyperbola2d_con.MajorRadius();
		double minor2d_con = hyperbola2d_con.MinorRadius();
		CHECK( major2d_con== Approx(4.0));
		CHECK(minor2d_con == Approx(3.0));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] double MinorRadius()	 @return The minor radius
	 @brief Get the minor radius
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <modeling/MakeFace.hpp>
#include <common/AxisT.hpp>
#include <math/HyperbolaT.hpp>
#include <occtio/OCCTTool.hpp>
#include <common/VectorT.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <topology/TopoEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <common/TransformationT.hpp>
#include <iostream>
using namespace AMCAX;
using namespace std;
#include <catch.hpp>
#include <testHelper.h>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <modeling/MakeFace.hpp>
#include <common/AxisT.hpp>
#include <math/HyperbolaT.hpp>
#include <occtio/OCCTTool.hpp>
#include <common/VectorT.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <topology/TopoEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <common/TransformationT.hpp>
#include <iostream>
using namespace AMCAX;
using namespace std;
;
	SECTION("Default()") {
		Hyperbola2 hyperbola2d_de;	
		CHECK(hyperbola2d_de.Location().X() == Approx(0.0));
		CHECK(hyperbola2d_de.Location().Y() == Approx(0.0));
		hyperbola2d_de.SetMajorRadius(3.0);
		hyperbola2d_de.SetMinorRadius(4.0);
		CHECK(hyperbola2d_de.MajorRadius() == Approx(3.0));
		CHECK(hyperbola2d_de.MinorRadius() == Approx(4.0));
		CHECK(hyperbola2d_de.Focal() == Approx(10.0));
		CHECK(hyperbola2d_de.Focus1().X() == Approx(5.0));
		CHECK(hyperbola2d_de.Focus1().Y() == Approx(0.0));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] AxisT<double, DIM> Asymptote1()	 @return The positive asymptote
	 @brief Get the asymptote of the hyperbola with positive slope
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <modeling/MakeFace.hpp>
#include <common/AxisT.hpp>
#include <math/HyperbolaT.hpp>
#include <occtio/OCCTTool.hpp>
#include <common/VectorT.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <topology/TopoEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <common/TransformationT.hpp>
#include <iostream>
using namespace AMCAX;
using namespace std;
#include <catch.hpp>
#include <testHelper.h>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <modeling/MakeFace.hpp>
#include <common/AxisT.hpp>
#include <math/HyperbolaT.hpp>
#include <occtio/OCCTTool.hpp>
#include <common/VectorT.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <topology/TopoEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <common/TransformationT.hpp>
#include <iostream>
using namespace AMCAX;
using namespace std;
;
	SECTION("Asymptote1()") {
		Axis2 axis2d_asy = hyperbola2d_ax.Asymptote1();
		CHECK(axis2d_asy.Direction().X()/ axis2d_asy.Direction().Y() == Approx(3.0/4.0));
		Point3 point1(0.0, 0.0, 0.0);
		Line2 line2d_asy(axis2d_asy);
		MakeEdge2d edge1(line2d_asy);
		CHECK(BRepClassificationTools::IsPointInOnEdge(edge1, point1, 0.001) == true);
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] AxisT<double, DIM> Asymptote2()	 @return The negative asymptote
	 @brief Get the asymptote of the hyperbola with negative slope
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <modeling/MakeFace.hpp>
#include <common/AxisT.hpp>
#include <math/HyperbolaT.hpp>
#include <occtio/OCCTTool.hpp>
#include <common/VectorT.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <topology/TopoEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <common/TransformationT.hpp>
#include <iostream>
using namespace AMCAX;
using namespace std;
#include <catch.hpp>
#include <testHelper.h>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <modeling/MakeFace.hpp>
#include <common/AxisT.hpp>
#include <math/HyperbolaT.hpp>
#include <occtio/OCCTTool.hpp>
#include <common/VectorT.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <topology/TopoEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <common/TransformationT.hpp>
#include <iostream>
using namespace AMCAX;
using namespace std;
;
	SECTION("Asymptote2()") {	
		Axis2 axis2d_asy = hyperbola2d_ax.Asymptote2();
		CHECK(axis2d_asy.Direction().X() / axis2d_asy.Direction().Y() == Approx(-3.0 / 4.0));
		Point3 point1(0.0, 0.0, 0.0);
		Line2 line2d_asy(axis2d_asy);
		MakeEdge2d edge1(line2d_asy);
		CHECK(BRepClassificationTools::IsPointInOnEdge(edge1, point1, 0.001) == true);
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] HyperbolaS ConjugateBranch1()	 @return The positive conjugate hyperbola
	 @brief Get the conjugate hyperbola on the positive side of the minor axis
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <modeling/MakeFace.hpp>
#include <common/AxisT.hpp>
#include <math/HyperbolaT.hpp>
#include <occtio/OCCTTool.hpp>
#include <common/VectorT.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <topology/TopoEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <common/TransformationT.hpp>
#include <iostream>
using namespace AMCAX;
using namespace std;
#include <catch.hpp>
#include <testHelper.h>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <modeling/MakeFace.hpp>
#include <common/AxisT.hpp>
#include <math/HyperbolaT.hpp>
#include <occtio/OCCTTool.hpp>
#include <common/VectorT.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <topology/TopoEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <common/TransformationT.hpp>
#include <iostream>
using namespace AMCAX;
using namespace std;
;
	SECTION("ConjugateBranch1()") {
		Point3 point1(0.0, 4.0, 0.0);
		Point3 point2(9.0 / 4.0, 5.0, 0.0);
		Hyperbola2 hyperbola2d_con = hyperbola2d_ax.ConjugateBranch1();
		MakeEdge2d edge1(hyperbola2d_con);
		CHECK(BRepClassificationTools::IsPointInOnEdge(edge1, point1, 0.001) == true);
		CHECK(BRepClassificationTools::IsPointInOnEdge(edge1, point2, 0.001) == true);
		double major2d_con = hyperbola2d_con.MajorRadius();
		double minor2d_con = hyperbola2d_con.MinorRadius();
		CHECK( major2d_con== Approx(4.0));
		CHECK(minor2d_con == Approx(3.0));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] HyperbolaS ConjugateBranch2()	 @return The negative conjugate hyperbola
	 @brief Get the conjugate hyperbola on the negative side of the minor axis
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <modeling/MakeFace.hpp>
#include <common/AxisT.hpp>
#include <math/HyperbolaT.hpp>
#include <occtio/OCCTTool.hpp>
#include <common/VectorT.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <topology/TopoEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <common/TransformationT.hpp>
#include <iostream>
using namespace AMCAX;
using namespace std;
#include <catch.hpp>
#include <testHelper.h>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <modeling/MakeFace.hpp>
#include <common/AxisT.hpp>
#include <math/HyperbolaT.hpp>
#include <occtio/OCCTTool.hpp>
#include <common/VectorT.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <topology/TopoEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <common/TransformationT.hpp>
#include <iostream>
using namespace AMCAX;
using namespace std;
;
	SECTION("ConjugateBranch2()") {
		Point3 point1(0.0, -4.0, 0.0);
		Point3 point2(9.0 / 4.0, -5.0, 0.0);
		Hyperbola2 hyperbola2d_con = hyperbola2d_ax.ConjugateBranch2();
		MakeEdge2d edge1(hyperbola2d_con);
		CHECK(BRepClassificationTools::IsPointInOnEdge(edge1, point1, 0.001) == true);
		CHECK(BRepClassificationTools::IsPointInOnEdge(edge1, point2, 0.001) == true);
		double major2d_con = hyperbola2d_con.MajorRadius();
		double minor2d_con = hyperbola2d_con.MinorRadius();
		CHECK(major2d_con == Approx(4.0));
		CHECK(minor2d_con == Approx(3.0));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] HyperbolaS OtherBranch()	 @return The hyperbola of the other branch
	 @brief Get the other branch of the hyperbola
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <modeling/MakeFace.hpp>
#include <common/AxisT.hpp>
#include <math/HyperbolaT.hpp>
#include <occtio/OCCTTool.hpp>
#include <common/VectorT.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <topology/TopoEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <common/TransformationT.hpp>
#include <iostream>
using namespace AMCAX;
using namespace std;
#include <catch.hpp>
#include <testHelper.h>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <modeling/MakeFace.hpp>
#include <common/AxisT.hpp>
#include <math/HyperbolaT.hpp>
#include <occtio/OCCTTool.hpp>
#include <common/VectorT.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <topology/TopoEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <common/TransformationT.hpp>
#include <iostream>
using namespace AMCAX;
using namespace std;
;
	SECTION("OtherBranch()") {
		Hyperbola2 hyperbola2d_ax_ob = hyperbola2d_ax.OtherBranch();
		Point2 point2d_m(0.0, 0.0);
		Point3 point1(-3.0, 0.0, 0.0);
		MakeEdge2d edge1(hyperbola2d_ax_ob);
		CHECK(BRepClassificationTools::IsPointInOnEdge(edge1, point1, 0.001) == true);
		CHECK(hyperbola2d_ax_ob.MajorRadius() == Approx(3.0));
		CHECK(hyperbola2d_ax_ob.MinorRadius() == Approx(4.0));
		CHECK(hyperbola2d_ax_ob.Location().X() == Approx(0.0));
		CHECK(hyperbola2d_ax_ob.Location().Y() == Approx(0.0));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":HyperbolaS& Scale(const PointT<double, DIM>& point, double scale)	 @return The reference to self
	 @param scale The scale value
	 @param point The scaling center point
	 @brief Scale the hyperbola by a center point
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <modeling/MakeFace.hpp>
#include <common/AxisT.hpp>
#include <math/HyperbolaT.hpp>
#include <occtio/OCCTTool.hpp>
#include <common/VectorT.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <topology/TopoEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <common/TransformationT.hpp>
#include <iostream>
using namespace AMCAX;
using namespace std;
#include <catch.hpp>
#include <testHelper.h>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <modeling/MakeFace.hpp>
#include <common/AxisT.hpp>
#include <math/HyperbolaT.hpp>
#include <occtio/OCCTTool.hpp>
#include <common/VectorT.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <topology/TopoEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <common/TransformationT.hpp>
#include <iostream>
using namespace AMCAX;
using namespace std;
;
	SECTION("Scale()") {		
		Point2 point1(0.0, 0.0);
		hyperbola2d_ax.Scale(point1, 0.5);
		CHECK(hyperbola2d_ax.Location().X() == Approx(0.0));
		CHECK(hyperbola2d_ax.Location().Y() == Approx(0.0));
		Point3 point3(1.5, 0.0, 0.0);
		MakeEdge2d edge1(hyperbola2d_ax);	
		CHECK(BRepClassificationTools::IsPointInOnEdge(edge1, point3, 0.001) == true);
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":HyperbolaS& Transform(const TransformationT<double, DIM>& tr)	 @return The reference to self
	 @param tr The transformation
	 @brief Transform the hyperbola
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <modeling/MakeFace.hpp>
#include <common/AxisT.hpp>
#include <math/HyperbolaT.hpp>
#include <occtio/OCCTTool.hpp>
#include <common/VectorT.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <topology/TopoEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <common/TransformationT.hpp>
#include <iostream>
using namespace AMCAX;
using namespace std;
#include <catch.hpp>
#include <testHelper.h>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <modeling/MakeFace.hpp>
#include <common/AxisT.hpp>
#include <math/HyperbolaT.hpp>
#include <occtio/OCCTTool.hpp>
#include <common/VectorT.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <topology/TopoEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <common/TransformationT.hpp>
#include <iostream>
using namespace AMCAX;
using namespace std;
;
	SECTION("Transform()") {
		Vector2 v1(1.0, 1.0);
		Transformation2 trans;
		trans.SetTranslation(v1);
		hyperbola2d_ax.Transform(trans);
		CHECK(hyperbola2d_ax.Location().X() == Approx(1.0));
		CHECK(hyperbola2d_ax.Location().Y() == Approx(1.0));
		CHECK(hyperbola2d_ax.MajorRadius() == Approx(3.0));
		CHECK(hyperbola2d_ax.MinorRadius() == Approx(4.0));
		Point3 point2(4.0, 1.0, 0.0);
		MakeEdge2d edge1(hyperbola2d_ax);
		CHECK(BRepClassificationTools::IsPointInOnEdge(edge1, point2, 0.001) == true);
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":void SetMajorRadius(double r)	 @param r The new major radius
	 @brief Set the major radius
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <modeling/MakeFace.hpp>
#include <common/AxisT.hpp>
#include <math/HyperbolaT.hpp>
#include <occtio/OCCTTool.hpp>
#include <common/VectorT.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <topology/TopoEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <iostream>
using namespace AMCAX;
using namespace std;
#include <catch.hpp>
#include <testHelper.h>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <modeling/MakeFace.hpp>
#include <common/AxisT.hpp>
#include <math/HyperbolaT.hpp>
#include <occtio/OCCTTool.hpp>
#include <common/VectorT.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <topology/TopoEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <iostream>
using namespace AMCAX;
using namespace std;
;
	SECTION("Default()") {
		Hyperbola3 hyperbola3d_de;	
		CHECK(hyperbola3d_de.Location().X() == Approx(0.0));
		CHECK(hyperbola3d_de.Location().Y() == Approx(0.0));
		CHECK(hyperbola3d_de.Location().Z() == Approx(0.0));
		hyperbola3d_de.SetMajorRadius(3.0);
		hyperbola3d_de.SetMinorRadius(4.0);
		CHECK(hyperbola3d_de.MajorRadius() == Approx(3.0));
		CHECK(hyperbola3d_de.MinorRadius() == Approx(4.0));
		CHECK(hyperbola3d_de.Focal() == Approx(10.0));
		CHECK(hyperbola3d_de.Focus1().X() == Approx(5.0));
		CHECK(hyperbola3d_de.Focus1().Y() == Approx(0.0));
		CHECK(hyperbola3d_de.Focus1().Z() == Approx(0.0));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":void SetMinorRadius(double r)	 @param r The new minor radius
	 @brief Set the minor radius
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <modeling/MakeFace.hpp>
#include <common/AxisT.hpp>
#include <math/HyperbolaT.hpp>
#include <occtio/OCCTTool.hpp>
#include <common/VectorT.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <topology/TopoEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <iostream>
using namespace AMCAX;
using namespace std;
#include <catch.hpp>
#include <testHelper.h>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <modeling/MakeFace.hpp>
#include <common/AxisT.hpp>
#include <math/HyperbolaT.hpp>
#include <occtio/OCCTTool.hpp>
#include <common/VectorT.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <topology/TopoEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <iostream>
using namespace AMCAX;
using namespace std;
;
	SECTION("Default()") {
		Hyperbola3 hyperbola3d_de;	
		CHECK(hyperbola3d_de.Location().X() == Approx(0.0));
		CHECK(hyperbola3d_de.Location().Y() == Approx(0.0));
		CHECK(hyperbola3d_de.Location().Z() == Approx(0.0));
		hyperbola3d_de.SetMajorRadius(3.0);
		hyperbola3d_de.SetMinorRadius(4.0);
		CHECK(hyperbola3d_de.MajorRadius() == Approx(3.0));
		CHECK(hyperbola3d_de.MinorRadius() == Approx(4.0));
		CHECK(hyperbola3d_de.Focal() == Approx(10.0));
		CHECK(hyperbola3d_de.Focus1().X() == Approx(5.0));
		CHECK(hyperbola3d_de.Focus1().Y() == Approx(0.0));
		CHECK(hyperbola3d_de.Focus1().Z() == Approx(0.0));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] AxisT<double, DIM> Directrix1()	 @return The positive directrix
	 @brief Get the directrix on the positive side of the major axis
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <modeling/MakeFace.hpp>
#include <common/AxisT.hpp>
#include <math/HyperbolaT.hpp>
#include <occtio/OCCTTool.hpp>
#include <common/VectorT.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <topology/TopoEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <iostream>
using namespace AMCAX;
using namespace std;
#include <catch.hpp>
#include <testHelper.h>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <modeling/MakeFace.hpp>
#include <common/AxisT.hpp>
#include <math/HyperbolaT.hpp>
#include <occtio/OCCTTool.hpp>
#include <common/VectorT.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <topology/TopoEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <iostream>
using namespace AMCAX;
using namespace std;
;
	SECTION("Directrix1()") {
		Axis3 axis3d_dir = hyperbola3d_fr.Directrix1();
		CHECK(axis3d_dir.Direction().X() == Approx(0.0));
		CHECK(axis3d_dir.Direction().Y() == Approx(1.0));
		CHECK(axis3d_dir.Direction().Z() == Approx(0.0));
		CHECK(axis3d_dir.Location().X() == Approx(9.0 / 5.0));
		CHECK(axis3d_dir.Location().Y() == Approx(0.0));
		CHECK(axis3d_dir.Location().Z() == Approx(1.0));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] AxisT<double, DIM> Directrix2()	 @return The negative directrix
	 @brief Get the directrix on the negative side of the major axis
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <modeling/MakeFace.hpp>
#include <common/AxisT.hpp>
#include <math/HyperbolaT.hpp>
#include <occtio/OCCTTool.hpp>
#include <common/VectorT.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <topology/TopoEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <iostream>
using namespace AMCAX;
using namespace std;
#include <catch.hpp>
#include <testHelper.h>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <modeling/MakeFace.hpp>
#include <common/AxisT.hpp>
#include <math/HyperbolaT.hpp>
#include <occtio/OCCTTool.hpp>
#include <common/VectorT.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <topology/TopoEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <iostream>
using namespace AMCAX;
using namespace std;
;
	SECTION("Directrix2()") {
		Axis3 axis3d_dir = hyperbola3d_fr.Directrix2();
		CHECK(axis3d_dir.Direction().X() == Approx(0.0));
		CHECK(axis3d_dir.Direction().Y() == Approx(1.0));
		CHECK(axis3d_dir.Direction().Z() == Approx(0.0));
		CHECK(axis3d_dir.Location().X() == Approx(-9.0 / 5.0));
		CHECK(axis3d_dir.Location().Y() == Approx(0.0));
		CHECK(axis3d_dir.Location().Z() == Approx(1.0));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] double Eccentricity()	 @return The eccentricity
	 @brief Get the eccentricity of the ellipse
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <modeling/MakeFace.hpp>
#include <common/AxisT.hpp>
#include <math/HyperbolaT.hpp>
#include <occtio/OCCTTool.hpp>
#include <common/VectorT.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <topology/TopoEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <iostream>
using namespace AMCAX;
using namespace std;
#include <catch.hpp>
#include <testHelper.h>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <modeling/MakeFace.hpp>
#include <common/AxisT.hpp>
#include <math/HyperbolaT.hpp>
#include <occtio/OCCTTool.hpp>
#include <common/VectorT.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <topology/TopoEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <iostream>
using namespace AMCAX;
using namespace std;
;
	SECTION("Eccentricity()") {
		double e = hyperbola3d_fr.Eccentricity();
		CHECK(e == Approx(5.0 / 3.0));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] PointT<double, DIM> Focus1()	 @return The positive focus
	 @brief Get the focus on the positive side of the major axis
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <modeling/MakeFace.hpp>
#include <common/AxisT.hpp>
#include <math/HyperbolaT.hpp>
#include <occtio/OCCTTool.hpp>
#include <common/VectorT.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <topology/TopoEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <iostream>
using namespace AMCAX;
using namespace std;
#include <catch.hpp>
#include <testHelper.h>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <modeling/MakeFace.hpp>
#include <common/AxisT.hpp>
#include <math/HyperbolaT.hpp>
#include <occtio/OCCTTool.hpp>
#include <common/VectorT.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <topology/TopoEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <iostream>
using namespace AMCAX;
using namespace std;
;
	SECTION("Default()") {
		Hyperbola3 hyperbola3d_de;	
		CHECK(hyperbola3d_de.Location().X() == Approx(0.0));
		CHECK(hyperbola3d_de.Location().Y() == Approx(0.0));
		CHECK(hyperbola3d_de.Location().Z() == Approx(0.0));
		hyperbola3d_de.SetMajorRadius(3.0);
		hyperbola3d_de.SetMinorRadius(4.0);
		CHECK(hyperbola3d_de.MajorRadius() == Approx(3.0));
		CHECK(hyperbola3d_de.MinorRadius() == Approx(4.0));
		CHECK(hyperbola3d_de.Focal() == Approx(10.0));
		CHECK(hyperbola3d_de.Focus1().X() == Approx(5.0));
		CHECK(hyperbola3d_de.Focus1().Y() == Approx(0.0));
		CHECK(hyperbola3d_de.Focus1().Z() == Approx(0.0));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] PointT<double, DIM> Focus2()	 @return The negative focus
	 @brief Get the focus on the negative side of the major axis
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <modeling/MakeFace.hpp>
#include <common/AxisT.hpp>
#include <math/HyperbolaT.hpp>
#include <occtio/OCCTTool.hpp>
#include <common/VectorT.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <topology/TopoEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <iostream>
using namespace AMCAX;
using namespace std;
#include <catch.hpp>
#include <testHelper.h>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <modeling/MakeFace.hpp>
#include <common/AxisT.hpp>
#include <math/HyperbolaT.hpp>
#include <occtio/OCCTTool.hpp>
#include <common/VectorT.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <topology/TopoEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <iostream>
using namespace AMCAX;
using namespace std;
;
	SECTION("Focus2") {
		Point3 point3d_f1 = hyperbola3d_fr.Focus2();
		CHECK(point3d_f1.X() == Approx(-5.0));
		CHECK(point3d_f1.Y() == Approx(0.0));
		CHECK(point3d_f1.Z() == Approx(1.0));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] double MajorRadius()	 @return The major radius
	 @brief Get the major radius
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <modeling/MakeFace.hpp>
#include <common/AxisT.hpp>
#include <math/HyperbolaT.hpp>
#include <occtio/OCCTTool.hpp>
#include <common/VectorT.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <topology/TopoEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <iostream>
using namespace AMCAX;
using namespace std;
#include <catch.hpp>
#include <testHelper.h>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <modeling/MakeFace.hpp>
#include <common/AxisT.hpp>
#include <math/HyperbolaT.hpp>
#include <occtio/OCCTTool.hpp>
#include <common/VectorT.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <topology/TopoEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <iostream>
using namespace AMCAX;
using namespace std;
;
	SECTION("Default()") {
		Hyperbola3 hyperbola3d_de;	
		CHECK(hyperbola3d_de.Location().X() == Approx(0.0));
		CHECK(hyperbola3d_de.Location().Y() == Approx(0.0));
		CHECK(hyperbola3d_de.Location().Z() == Approx(0.0));
		hyperbola3d_de.SetMajorRadius(3.0);
		hyperbola3d_de.SetMinorRadius(4.0);
		CHECK(hyperbola3d_de.MajorRadius() == Approx(3.0));
		CHECK(hyperbola3d_de.MinorRadius() == Approx(4.0));
		CHECK(hyperbola3d_de.Focal() == Approx(10.0));
		CHECK(hyperbola3d_de.Focus1().X() == Approx(5.0));
		CHECK(hyperbola3d_de.Focus1().Y() == Approx(0.0));
		CHECK(hyperbola3d_de.Focus1().Z() == Approx(0.0));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] double MinorRadius()	 @return The minor radius
	 @brief Get the minor radius
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <modeling/MakeFace.hpp>
#include <common/AxisT.hpp>
#include <math/HyperbolaT.hpp>
#include <occtio/OCCTTool.hpp>
#include <common/VectorT.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <topology/TopoEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <iostream>
using namespace AMCAX;
using namespace std;
#include <catch.hpp>
#include <testHelper.h>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <modeling/MakeFace.hpp>
#include <common/AxisT.hpp>
#include <math/HyperbolaT.hpp>
#include <occtio/OCCTTool.hpp>
#include <common/VectorT.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <topology/TopoEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <iostream>
using namespace AMCAX;
using namespace std;
;
	SECTION("ConjugateBranch1()") {
		Hyperbola3 hyperbola3d_con = hyperbola3d_fr.ConjugateBranch1();
		CHECK(hyperbola3d_con.Location().X() == Approx(0.0));
		CHECK(hyperbola3d_con.Location().Y() == Approx(0.0));
		CHECK(hyperbola3d_con.Location().Z() == Approx(1.0));
		Point3 point1(0.0, 4.0, 1.0);
		Point3 point2(9.0 / 4.0, 5.0, 1.0);
		MakeEdge edge1(hyperbola3d_con);
		CHECK(BRepClassificationTools::IsPointInOnEdge(edge1, point1, 0.001) == true);
		CHECK(BRepClassificationTools::IsPointInOnEdge(edge1, point2, 0.001) == true);
		double major3d_con = hyperbola3d_con.MajorRadius();
		double minor3d_con = hyperbola3d_con.MinorRadius();
		CHECK(major3d_con == Approx(4.0));
		CHECK(minor3d_con == Approx(3.0));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] AxisT<double, DIM> Asymptote1()	 @return The positive asymptote
	 @brief Get the asymptote of the hyperbola with positive slope
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <modeling/MakeFace.hpp>
#include <common/AxisT.hpp>
#include <math/HyperbolaT.hpp>
#include <occtio/OCCTTool.hpp>
#include <common/VectorT.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <topology/TopoEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <iostream>
using namespace AMCAX;
using namespace std;
#include <catch.hpp>
#include <testHelper.h>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <modeling/MakeFace.hpp>
#include <common/AxisT.hpp>
#include <math/HyperbolaT.hpp>
#include <occtio/OCCTTool.hpp>
#include <common/VectorT.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <topology/TopoEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <iostream>
using namespace AMCAX;
using namespace std;
;
	SECTION("Asymptote1()") {
		Axis3 axis3d_asy = hyperbola3d_fr.Asymptote1();
		CHECK(axis3d_asy.Direction().X() / axis3d_asy.Direction().Y() == Approx(3.0 / 4.0));
		CHECK(axis3d_asy.Direction().Z() == Approx(0.0));
		Point3 point1(0.0, 0.0, 1.0);
		Line3 line3d_asy(axis3d_asy);
		MakeEdge edge1(line3d_asy);
		CHECK(BRepClassificationTools::IsPointInOnEdge(edge1, point1, 0.001) == true);
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] AxisT<double, DIM> Asymptote2()	 @return The negative asymptote
	 @brief Get the asymptote of the hyperbola with negative slope
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <modeling/MakeFace.hpp>
#include <common/AxisT.hpp>
#include <math/HyperbolaT.hpp>
#include <occtio/OCCTTool.hpp>
#include <common/VectorT.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <topology/TopoEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <iostream>
using namespace AMCAX;
using namespace std;
#include <catch.hpp>
#include <testHelper.h>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <modeling/MakeFace.hpp>
#include <common/AxisT.hpp>
#include <math/HyperbolaT.hpp>
#include <occtio/OCCTTool.hpp>
#include <common/VectorT.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <topology/TopoEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <iostream>
using namespace AMCAX;
using namespace std;
;
	SECTION("Asymptote2()") {
		Axis3 axis3d_asy = hyperbola3d_fr.Asymptote2();
		CHECK(axis3d_asy.Direction().X() / axis3d_asy.Direction().Y() == Approx(-3.0 / 4.0));
		CHECK(axis3d_asy.Direction().Z() == Approx(0.0));
		Point3 point1(0.0, 0.0, 1.0);
		Line3 line3d_asy(axis3d_asy);
		MakeEdge edge1(line3d_asy);
		CHECK(BRepClassificationTools::IsPointInOnEdge(edge1, point1, 0.001) == true);
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] HyperbolaS ConjugateBranch1()	 @return The positive conjugate hyperbola
	 @brief Get the conjugate hyperbola on the positive side of the minor axis
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <modeling/MakeFace.hpp>
#include <common/AxisT.hpp>
#include <math/HyperbolaT.hpp>
#include <occtio/OCCTTool.hpp>
#include <common/VectorT.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <topology/TopoEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <iostream>
using namespace AMCAX;
using namespace std;
#include <catch.hpp>
#include <testHelper.h>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <modeling/MakeFace.hpp>
#include <common/AxisT.hpp>
#include <math/HyperbolaT.hpp>
#include <occtio/OCCTTool.hpp>
#include <common/VectorT.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <topology/TopoEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <iostream>
using namespace AMCAX;
using namespace std;
;
	SECTION("ConjugateBranch1()") {
		Hyperbola3 hyperbola3d_con = hyperbola3d_fr.ConjugateBranch1();
		CHECK(hyperbola3d_con.Location().X() == Approx(0.0));
		CHECK(hyperbola3d_con.Location().Y() == Approx(0.0));
		CHECK(hyperbola3d_con.Location().Z() == Approx(1.0));
		Point3 point1(0.0, 4.0, 1.0);
		Point3 point2(9.0 / 4.0, 5.0, 1.0);
		MakeEdge edge1(hyperbola3d_con);
		CHECK(BRepClassificationTools::IsPointInOnEdge(edge1, point1, 0.001) == true);
		CHECK(BRepClassificationTools::IsPointInOnEdge(edge1, point2, 0.001) == true);
		double major3d_con = hyperbola3d_con.MajorRadius();
		double minor3d_con = hyperbola3d_con.MinorRadius();
		CHECK(major3d_con == Approx(4.0));
		CHECK(minor3d_con == Approx(3.0));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] HyperbolaS ConjugateBranch2()	 @return The negative conjugate hyperbola
	 @brief Get the conjugate hyperbola on the negative side of the minor axis
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <modeling/MakeFace.hpp>
#include <common/AxisT.hpp>
#include <math/HyperbolaT.hpp>
#include <occtio/OCCTTool.hpp>
#include <common/VectorT.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <topology/TopoEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <iostream>
using namespace AMCAX;
using namespace std;
#include <catch.hpp>
#include <testHelper.h>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <modeling/MakeFace.hpp>
#include <common/AxisT.hpp>
#include <math/HyperbolaT.hpp>
#include <occtio/OCCTTool.hpp>
#include <common/VectorT.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <topology/TopoEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <iostream>
using namespace AMCAX;
using namespace std;
;
	SECTION("ConjugateBranch2()") {		
		Hyperbola3 hyperbola3d_con = hyperbola3d_fr.ConjugateBranch2();
		CHECK(hyperbola3d_con.Location().X() == Approx(0.0));
		CHECK(hyperbola3d_con.Location().Y() == Approx(0.0));
		CHECK(hyperbola3d_con.Location().Z() == Approx(1.0));
		Point3 point1(0.0, -4.0, 1.0);
		Point3 point2(9.0 / 4.0, -5.0, 1.0);
		MakeEdge edge2(hyperbola3d_con);
		CHECK(BRepClassificationTools::IsPointInOnEdge(edge2, point1, 0.001) == true);
		CHECK(BRepClassificationTools::IsPointInOnEdge(edge2, point2, 0.001) == true);
		double major3d_con = hyperbola3d_con.MajorRadius();
		double minor3d_con = hyperbola3d_con.MinorRadius();
		CHECK(major3d_con == Approx(4.0));
		CHECK(minor3d_con == Approx(3.0));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] HyperbolaS OtherBranch()	 @return The hyperbola of the other branch
	 @brief Get the other branch of the hyperbola
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <modeling/MakeFace.hpp>
#include <common/AxisT.hpp>
#include <math/HyperbolaT.hpp>
#include <occtio/OCCTTool.hpp>
#include <common/VectorT.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <topology/TopoEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <iostream>
using namespace AMCAX;
using namespace std;
#include <catch.hpp>
#include <testHelper.h>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <modeling/MakeFace.hpp>
#include <common/AxisT.hpp>
#include <math/HyperbolaT.hpp>
#include <occtio/OCCTTool.hpp>
#include <common/VectorT.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <topology/TopoEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <iostream>
using namespace AMCAX;
using namespace std;
;
	SECTION("OtherBranch()") {
		Hyperbola3 hyperbola3d_fr_ob = hyperbola3d_fr.OtherBranch();
		Point3 point3d_m(0.0, 0.0, 0.0);
		Point3 point2(-3.0, 0.0, 1.0);
		MakeEdge edge2(hyperbola3d_fr_ob);
		CHECK(BRepClassificationTools::IsPointInOnEdge(edge2, point2, 0.001) == true);
		CHECK(hyperbola3d_fr_ob.MajorRadius() == Approx(3.0));
		CHECK(hyperbola3d_fr_ob.MinorRadius() == Approx(4.0));
		CHECK(hyperbola3d_fr_ob.Location().X() == Approx(0.0));
		CHECK(hyperbola3d_fr_ob.Location().Y() == Approx(0.0));
		CHECK(hyperbola3d_fr_ob.Location().Z() == Approx(1.0));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":HyperbolaS& Scale(const PointT<double, DIM>& point, double scale)	 @return The reference to self
	 @param scale The scale value
	 @param point The scaling center point
	 @brief Scale the hyperbola by a center point
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <modeling/MakeFace.hpp>
#include <common/AxisT.hpp>
#include <math/HyperbolaT.hpp>
#include <occtio/OCCTTool.hpp>
#include <common/VectorT.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <topology/TopoEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <iostream>
using namespace AMCAX;
using namespace std;
#include <catch.hpp>
#include <testHelper.h>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <modeling/MakeFace.hpp>
#include <common/AxisT.hpp>
#include <math/HyperbolaT.hpp>
#include <occtio/OCCTTool.hpp>
#include <common/VectorT.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <topology/TopoEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <iostream>
using namespace AMCAX;
using namespace std;
;
	SECTION("Scale()") {		
		Point3 point1(0.0, 0.0, 1.0);
		hyperbola3d_fr.Scale(point1, 0.5);
		CHECK(hyperbola3d_fr.Location().X() == Approx(0.0));
		CHECK(hyperbola3d_fr.Location().Y() == Approx(0.0));
		CHECK(hyperbola3d_fr.Location().Z() == Approx(1.0));
		Point3 point2(1.5, 0.0, 1.0);
		MakeEdge edge1(hyperbola3d_fr);
		CHECK(BRepClassificationTools::IsPointInOnEdge(edge1, point2, 0.001) == true);
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":HyperbolaS& Transform(const TransformationT<double, DIM>& tr)	 @return The reference to self
	 @param tr The transformation
	 @brief Transform the hyperbola
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <modeling/MakeFace.hpp>
#include <common/AxisT.hpp>
#include <math/HyperbolaT.hpp>
#include <occtio/OCCTTool.hpp>
#include <common/VectorT.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <topology/TopoEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <iostream>
using namespace AMCAX;
using namespace std;
#include <catch.hpp>
#include <testHelper.h>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <modeling/MakeFace.hpp>
#include <common/AxisT.hpp>
#include <math/HyperbolaT.hpp>
#include <occtio/OCCTTool.hpp>
#include <common/VectorT.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <topology/TopoEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <iostream>
using namespace AMCAX;
using namespace std;
;
	SECTION("Transform()") {
		Vector3 v1(1.0, 1.0, 1.0);
		Transformation3 trans;
		trans.SetTranslation(v1);
		hyperbola3d_fr.Transform(trans);
		CHECK(hyperbola3d_fr.Location().X() == Approx(1.0));
		CHECK(hyperbola3d_fr.Location().Y() == Approx(1.0));
		CHECK(hyperbola3d_fr.Location().Z() == Approx(2.0));
		CHECK(hyperbola3d_fr.MajorRadius() == Approx(3.0));
		CHECK(hyperbola3d_fr.MinorRadius() == Approx(4.0));
		Point3 point1(4.0, 1.0, 2.0);
		MakeEdge edge1(hyperbola3d_fr);
		CHECK(BRepClassificationTools::IsPointInOnEdge(edge1, point1, 0.001) == true);
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAXMeshing_API void Union()	 @brief apply (3)UNION and (4)put result to output mesh.
,
 "output":#include<catch.hpp>
#include<testHelperBase.h>
#define AMCAXMeshing_Enable_CommonTraits
#define AMCAXMeshing_Disable_StandardTraits
#define AMCAXMeshing_Enable_EigenTraits
#include "mesh/io/OBJReader.hpp"
#include "mesh/io/OBJWriter.hpp"
#include "mesh/io/STLReader.hpp"
#include "mesh/io/STLWriter.hpp"
#include "meshModeling/MeshBoolean.hpp"
#include "meshModeling/TriMeshRepair.hpp"
#include "meshModeling/MeshParameterization.hpp"
using EIAC = AMCAX::Meshing::Geometry::EIAC;
using TriSoupTraits = AMCAX::Meshing::Mesh::TriSoupTraits_Coord;
using Points = typename TriSoupTraits::Points;
using Triangles = typename TriSoupTraits::Triangles;
using OBJReader = AMCAX::Meshing::Mesh::OBJReader<TriSoupTraits>;
using OBJWriter = AMCAX::Meshing::Mesh::OBJWriter<TriSoupTraits>;
using STLReader = AMCAX::Meshing::Mesh::STLReader<TriSoupTraits>;
using STLWriter = AMCAX::Meshing::Mesh::STLWriter<TriSoupTraits>;
using IOOptions = AMCAX::Meshing::Mesh::IOOptions;
using MeshBoolean = AMCAX::Meshing::Boolean::MeshBoolean<EIAC, TriSoupTraits>;
void read_mesh11(const std::string& filename, Points& points,Triangles& triangles, IOOptions& io_options)
{
	if (AMCAX::Meshing::ends_with(filename, ".obj"))
	{
		OBJReader reader;
		reader.read(filename, io_options);
		points = std::move(reader.m_points);
		triangles = std::move(reader.m_triangles);
	}
	else if (AMCAX::Meshing::ends_with(filename, ".stl"))
	{
		STLReader reader;
		reader.read(filename, io_options);
		points = std::move(reader.m_points);
		triangles = std::move(reader.m_triangles);
	}
}
void write_mesh11(const std::string& filename, const Points& points,const Triangles& triangles, IOOptions& io_options)
{
	OBJWriter writer;
	writer.m_points = std::move(points);
	writer.m_triangles = std::move(triangles);
	bool bWriteObj = writer.write(filename, io_options, 10);
	CHECK(bWriteObj == true);
};
TEST_CASE("case1: MeshBoolean_MeshBoolean  ", "[meshModeling][MeshBoolean][P1]")
{
	OUTPUT_DIRECTORY(Boolean, Boolean);
	IOOptions io_options;
	io_options.vertex_has_point = true;
	Points    points1, points2, result_points;
	Triangles triangles1, triangles2, result_triangles;
	read_mesh11(INPUT_PATH_PREFIX"./meshModeling_data/MeshBoolean_data/bunny25k.obj", points1, triangles1, io_options);
	read_mesh11(INPUT_PATH_PREFIX"./meshModeling_data/MeshBoolean_data/cow.obj", points2, triangles2, io_options);
	MeshBoolean boolean( true);
	boolean.addTriMeshAsInput(points1, triangles1);
	boolean.addTriMeshAsInput(points2, triangles2);
	boolean.setTriMeshAsOutput(result_points, result_triangles);
	boolean.computeLabels();
	{
		boolean.Union();
		make_file_writable(outdir + "AMCAXMeshing_Union.obj");
		write_mesh11(outdir + "AMCAXMeshing_Union.obj", result_points,
			result_triangles, io_options);
	}
	{
		boolean.Intersection();
		make_file_writable(outdir + "AMCAXMeshing_Intersection.obj");
		write_mesh11(outdir + "AMCAXMeshing_Intersection.obj", result_points,
			result_triangles, io_options);
	}
	{
		boolean.Xor();
		make_file_writable(outdir + "AMCAXMeshing_Xor.obj");
		write_mesh11(outdir + "AMCAXMeshing_Xor.obj", result_points, result_triangles,
			io_options);
	}
	{
		boolean.Subtraction();
		make_file_writable(outdir + "AMCAXMeshing_Subtraction.obj");
		write_mesh11(outdir + "AMCAXMeshing_Subtraction.obj", result_points,
			result_triangles, io_options);
	}
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAXMeshing_API MeshBoolean(bool         _verbose, unsigned int _thread_num = std::thread::hardware_concurrency(),
 "output":#include<catch.hpp>
#include<testHelperBase.h>
#define AMCAXMeshing_Enable_EigenTraits
#define AMCAXMeshing_Enable_CommonTraits
#define AMCAXMeshing_Disable_StandardTraits
#include "mesh/TriSoup.hpp"
#include "meshModeling/MeshBoolean.hpp"
#include "mesh/io/OBJReader.hpp"
#include "mesh/io/OBJWriter.hpp"
#include "mesh/io/STLReader.hpp"
#include "mesh/io/STLWriter.hpp"
#ifdef AMCAXMeshing_Enable_CommonTraits
using TriSoupTraits = AMCAX::Meshing::Mesh::TriSoupTraits_Coord;
#endif
using EIAC = AMCAX::Meshing::Geometry::EIAC;
using Points = typename TriSoupTraits::Points;
using Triangles = typename TriSoupTraits::Triangles;
using OBJReader = AMCAX::Meshing::Mesh::OBJReader<TriSoupTraits>;
using OBJWriter = AMCAX::Meshing::Mesh::OBJWriter<TriSoupTraits>;
using STLReader = AMCAX::Meshing::Mesh::STLReader<TriSoupTraits>;
using STLWriter = AMCAX::Meshing::Mesh::STLWriter<TriSoupTraits>;
using IOOptions = AMCAX::Meshing::Mesh::IOOptions;
using MeshBoolean = AMCAX::Meshing::Boolean::MeshBoolean<EIAC, TriSoupTraits>;
template <typename TriIndexT>
struct InterSegments
{
    using ti_t = TriIndexT;
    std::vector<ti_t> vertex_ids;
    bool closed;
};
void read_mesh2(const std::string& filename, Points& points,
    Triangles& triangles, IOOptions& io_options)
{
    if (AMCAX::Meshing::ends_with(filename, ".obj"))
    {
        OBJReader reader;
        reader.read(filename, io_options);
        points = std::move(reader.m_points);
        triangles = std::move(reader.m_triangles);
    }
    else if (AMCAX::Meshing::ends_with(filename, ".stl"))
    {
        STLReader reader;
        reader.read(filename, io_options);
        points = std::move(reader.m_points);
        triangles = std::move(reader.m_triangles);
    }
}
void write_mesh2(const std::string& filename, const Points& points,
    const Triangles& triangles, IOOptions& io_options)
{
    if (AMCAX::Meshing::ends_with(filename, ".obj"))
    {
        OBJWriter writer;
        writer.m_points = std::move(points);
        writer.m_triangles = std::move(triangles);
        writer.write(filename, io_options, 10);
    }
    else if (AMCAX::Meshing::ends_with(filename, ".stl"))
    {
        STLWriter writer;
        writer.m_points = std::move(points);
        writer.m_triangles = std::move(triangles);
        writer.write(filename, io_options, 10);
    }
};
TEST_CASE("bug1: MeshBoolean_InterSegments ", "[meshModeling][MeshBoolean_InterSegments][bug]")
{
    OUTPUT_DIRECTORY(MeshBoolean, InterSegments_bug);
    IOOptions io_options;
    io_options.vertex_has_point = true;
    Points      points1, points2, points3, points11, points22, points33, result_points, result_points11;
    Triangles   triangles1, triangles2, triangles3, triangles11, triangles22, triangles33, result_triangles, result_triangles11;
    read_mesh2(INPUT_PATH_PREFIX"./meshModeling_data/MeshBoolean_data/cow1.stl", points1, triangles1, io_options);
    read_mesh2(INPUT_PATH_PREFIX"./meshModeling_data/MeshBoolean_data/bunny1.stl", points2, triangles2, io_options);
    read_mesh2(INPUT_PATH_PREFIX"./meshModeling_data/MeshBoolean_data/cow1.stl", points3, triangles3, io_options);
    read_mesh2(INPUT_PATH_PREFIX"./meshModeling_data/MeshBoolean_data/cow1.obj", points11, triangles11, io_options);
    read_mesh2(INPUT_PATH_PREFIX"./meshModeling_data/MeshBoolean_data/bunny1.obj", points22, triangles22, io_options);
    read_mesh2(INPUT_PATH_PREFIX"./meshModeling_data/MeshBoolean_data/cow1.obj", points33, triangles33, io_options);
    MeshBoolean boolean(true);
    MeshBoolean boolean11(true);
    boolean.addTriMeshAsInput(points1, triangles1);
    boolean.addTriMeshAsInput(points2, triangles2);
    boolean.addTriMeshAsInput(points3, triangles3);
    boolean.setTriMeshAsOutput(result_points, result_triangles);
    boolean.computeLabels();
    boolean.computeInterSegments();
    boolean.Subtraction();
    boolean11.addTriMeshAsInput(points11, triangles11);
    boolean11.addTriMeshAsInput(points22, triangles22);
    boolean11.addTriMeshAsInput(points33, triangles33);
    boolean11.setTriMeshAsOutput(result_points11, result_triangles11);
    boolean11.computeLabels();
    boolean11.computeInterSegments();
    boolean11.Subtraction();
    const auto& inter_segs = boolean.getInterSegments();
    const auto& inter_segs11 = boolean11.getInterSegments();
    for (size_t s_id = 0; s_id < inter_segs.size(); ++s_id)
    {
        std::ofstream ofs(outdir + "stl_"+std::to_string(s_id) + ".obj");
        size_t v_num = inter_segs[s_id].vertex_ids.size();
        ofs << "# v_num: " << v_num << std::endl;
        size_t l_num = inter_segs[s_id].closed ? inter_segs[s_id].vertex_ids.size() : inter_segs[s_id].vertex_ids.size() - 1;
        ofs << "# l_num: " << l_num << std::endl;
        ofs << std::endl;
        for (auto v_id : inter_segs[s_id].vertex_ids)
        {
            ofs << "v " << result_points[v_id].x() << " " << result_points[v_id].y() << " " << result_points[v_id].z() << std::endl;
        }
        ofs << std::endl;
        for (size_t i = 0; i < inter_segs[s_id].vertex_ids.size() - 1; ++i)
        {
            ofs << "l " << i + 1 << " " << i + 2 << std::endl;
        }
        if (inter_segs[s_id].closed)
        {
            ofs << "l " << inter_segs[s_id].vertex_ids.size() << " " << 1 << std::endl;
        }
        ofs.close();
        write_mesh2(outdir + "InterSubtraction.stl", result_points, result_triangles, io_options);
    }
    for (size_t s_id = 0; s_id < inter_segs11.size(); ++s_id)
    {
        std::ofstream ofs(outdir + "obj_"+std::to_string(s_id) + ".obj");
        size_t v_num = inter_segs11[s_id].vertex_ids.size();
        ofs << "# v_num: " << v_num << std::endl;
        size_t l_num = inter_segs11[s_id].closed ? inter_segs11[s_id].vertex_ids.size() : inter_segs11[s_id].vertex_ids.size() - 1;
        ofs << "# l_num: " << l_num << std::endl;
        ofs << std::endl;
        for (auto v_id : inter_segs11[s_id].vertex_ids)
        {
            ofs << "v " << result_points11[v_id].x() << " " << result_points11[v_id].y() << " " << result_points11[v_id].z() << std::endl;
        }
        ofs << std::endl;
        for (size_t i = 0; i < inter_segs11[s_id].vertex_ids.size() - 1; ++i)
        {
            ofs << "l " << i + 1 << " " << i + 2 << std::endl;
        }
        if (inter_segs11[s_id].closed)
        {
            ofs << "l " << inter_segs11[s_id].vertex_ids.size() << " " << 1 << std::endl;
        }
        ofs.close();
        write_mesh2(outdir + "InterSubtraction.obj", result_points11, result_triangles11, io_options);
    }
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAXMeshing_API void Union()	 @brief apply (3)UNION and (4)put result to output mesh.
,
 "output":#include<catch.hpp>
#include<testHelperBase.h>
#include "mesh/TriSoup.hpp"
#include "meshModeling/MeshBoolean.hpp"
#include "mesh/io/OBJReader.hpp"
#include "mesh/io/OBJWriter.hpp"
#include "mesh/io/STLReader.hpp"
#include "mesh/io/STLWriter.hpp"
#ifdef AMCAXMeshing_Enable_CommonTraits
using TriSoupTraits = AMCAX::Meshing::Mesh::TriSoupTraits_Coord;
#endif
using EIAC = AMCAX::Meshing::Geometry::EIAC;
using Points = typename TriSoupTraits::Points;
using Triangles = typename TriSoupTraits::Triangles;
using OBJReader = AMCAX::Meshing::Mesh::OBJReader<TriSoupTraits>;
using OBJWriter = AMCAX::Meshing::Mesh::OBJWriter<TriSoupTraits>;
using STLReader = AMCAX::Meshing::Mesh::STLReader<TriSoupTraits>;
using STLWriter = AMCAX::Meshing::Mesh::STLWriter<TriSoupTraits>;
using IOOptions = AMCAX::Meshing::Mesh::IOOptions;
using MeshBoolean = AMCAX::Meshing::Boolean::MeshBoolean<EIAC, TriSoupTraits>;
template <typename Traits>
struct SourceFaceInfo
{
    using iTriangle = typename Traits::Triangle;
    using ti_t = std::remove_reference_t<decltype(std::declval<iTriangle>()[0])>;
    std::vector<std::pair<ti_t, ti_t>> face_ids;
};
void read_mesh1(const std::string& filename, Points& points,
    Triangles& triangles, IOOptions& io_options)
{
    if (AMCAX::Meshing::ends_with(filename, ".obj"))
    {
        OBJReader reader;
        reader.read(filename, io_options);
        points = std::move(reader.m_points);
        triangles = std::move(reader.m_triangles);
    }
    else if (AMCAX::Meshing::ends_with(filename, ".stl"))
    {
        STLReader reader;
        reader.read(filename, io_options);
        points = std::move(reader.m_points);
        triangles = std::move(reader.m_triangles);
    }
}
void write_mesh1(const std::string& filename, const Points& points,
    const Triangles& triangles, IOOptions& io_options)
{
    if (AMCAX::Meshing::ends_with(filename, ".obj"))
    {
        OBJWriter writer;
        writer.m_points = std::move(points);
        writer.m_triangles = std::move(triangles);
        writer.write(filename, io_options, 10);
    }
    else if (AMCAX::Meshing::ends_with(filename, ".stl"))
    {
        STLWriter writer;
        writer.m_points = std::move(points);
        writer.m_triangles = std::move(triangles);
        writer.write(filename, io_options, 10);
    }
};
TEST_CASE("case1: test MeshBoolean_MeshBoolean Algorithm", "[meshModeling][MeshBoolean1]")
{
	OUTPUT_DIRECTORY(MeshBoolean, MeshBoolean);
    constexpr size_t InputMeshNum = 2;
    IOOptions io_options;
    io_options.vertex_has_point = true;
	std::vector<Points>    points(InputMeshNum);
	std::vector<Triangles> triangles(InputMeshNum);
	Points                 result_points;
	Triangles              result_triangles;
    for (int num = 0; num < 5; num++)
    {
        read_mesh1(INPUT_PATH_PREFIX"./meshModeling_data/MeshBoolean_data/bunny1.stl", points[0], triangles[0], io_options);
        read_mesh1(INPUT_PATH_PREFIX"./meshModeling_data/MeshBoolean_data/cow1.stl", points[1], triangles[1], io_options);
        std::cout << "open file" << std::endl;
		MeshBoolean boolean(true);
		boolean.addTriMeshAsInput(points[0], triangles[0]);
		boolean.addTriMeshAsInput(points[1], triangles[1]);
		boolean.setTriMeshAsOutput(result_points, result_triangles);
	    boolean.computeLabels();
	    boolean.Union();
        const auto& souce_face_infos = boolean.getSourceFaceInfo();
        std::vector<Points>               res_source_pts(InputMeshNum);
        std::vector<Triangles>            res_source_tris(InputMeshNum);
        std::vector<std::vector<uint8_t>> source_face_visited(InputMeshNum);
        std::vector<std::vector<int>>     v2v(InputMeshNum);
        for (int m_id = 0; m_id < InputMeshNum; ++m_id)
        {
            source_face_visited[m_id].resize(triangles[m_id].size(), false);
            v2v[m_id].resize(points[m_id].size(), -1);
        }
        std::array<int, InputMeshNum> v_off{};
        for (const auto& face_info : souce_face_infos)
        {
            for (const auto& info : face_info.face_ids)
            {
                if (!source_face_visited[info.first][info.second])
                {
                    const auto& tri = triangles[info.first][info.second];
                    for (auto fv_id : tri)
                    {
                        if (v2v[info.first][fv_id] == -1)
                        {
                            res_source_pts[info.first].emplace_back(points[info.first][fv_id]);
                            v2v[info.first][fv_id] = v_off[info.first];
                            ++v_off[info.first];
                        }
                    }
                    res_source_tris[info.first].emplace_back(v2v[info.first][tri[0]], v2v[info.first][tri[1]], v2v[info.first][tri[2]]);
                    source_face_visited[info.first][info.second] = true;
                }
            }
        }
        for (int m_id = 0; m_id < InputMeshNum; ++m_id)
        {
            int res_union_ptsNum, res_union_trisNum, res_source_ptsNum, res_source_trisNum;
            switch (m_id)
            {
            case 0:
                res_union_ptsNum = result_points.size();
                res_union_trisNum = result_triangles.size();
                CHECK(res_union_ptsNum == 13219);
                CHECK(res_union_trisNum == 26438);
                res_source_ptsNum = res_source_pts[m_id].size();
                res_source_trisNum = res_source_tris[m_id].size();
                CHECK(res_source_ptsNum == 10329);
                CHECK(res_source_trisNum == 20271);
                break;
            case 1:
                res_source_ptsNum = res_source_pts[m_id].size();
                res_source_trisNum = res_source_tris[m_id].size();
                CHECK(res_source_ptsNum == 2276);
                CHECK(res_source_trisNum == 4363);
                break;
            default:
                break;
            }
            make_file_writable(outdir + "AMCAXMeshing_Union_SourceFace" + std::to_string(m_id) + ".stl");
            write_mesh1(outdir + "AMCAXMeshing_Union_Face" + ".stl", result_points, result_triangles, io_options);
            write_mesh1(outdir + "AMCAXMeshing_Union_SourceFace" + std::to_string(m_id) + ".stl", res_source_pts[m_id], res_source_tris[m_id], io_options);
        }
    }
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API explicit GeneralTransformShape(const GeneralTransformation3& t)	 @param t The general transformation
	 @brief Construct from a general transformation
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <modeling/MakeSphere.hpp>
#include <modeling/TransformShape.hpp>
#include <topomesh/BRepMeshIncrementalMesh.hpp>
#include <modeling/MakeShapeTool.hpp>
#include <common/TransformationT.hpp>
#include <common/CartesianCoordinateSystem.hpp>
#include <common/GeneralTransformationT.hpp>
#include <modeling/GeneralTransformShape.hpp>
#include <geometry/GlobalProperty.hpp>
#include <occtio/OCCTTool.hpp>
#include <topology/BRepGlobalProperty.hpp>
#include <geometry/Geom3BSplineCurve.hpp>
#include <modeling/MakeEdge.hpp>
#include <topology/TopoTool.hpp>
#include <topology/BRepAdaptorCurve3.hpp>
using namespace AMCAX;
TEST_CASE("bug1: GeneralTransformShape  ", "[modeling][GeneralTransformShape][fixbug]") {
	TopoShape s = MakeSphere(1.0);
	BRepMeshIncrementalMesh mesher(s, 0.005, true);
	MakeShapeTool::EnsureNormalConsistency(s);
	GeneralTransformation3 tr;
	tr.SetAffinity(Frame3(), 5.0);
	s = GeneralTransformShape(s, tr);
	CHECK(s.Type() == AMCAX::ShapeType::Solid);
	CHECK(s.IsNull() == false);
	GlobalProperty prop;
	BRepGlobalProperty::VolumeProperties(s, prop);
	CHECK(prop.Mass() == Approx(20.934791259).epsilon(1e-11));
	Point3 vP = prop.CenterOfMass();
#ifndef WIN_CASE
	CHECK(vP.X() == Approx(0.0).margin(1e-3));
	CHECK(vP.Y() == Approx(0.0).margin(1e-12));
	CHECK(vP.Z() == Approx(0.0).margin(1e-12));
#else
	CHECK(vP.X() == Approx(-2.2218808037914858e-04).epsilon(1e-12));
	CHECK(vP.Y() == Approx(-1.0782779568197278e-16).epsilon(1e-12));
	CHECK(vP.Z() == Approx(-1.6920954211916623e-16).epsilon(1e-12));
#endif
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API GeneralTransformShape(const TopoShape& s, const GeneralTransformation3& t, bool copy = false)	 @param copy Whether the geometry of the shape is copied
	 @param t The general transformation
	 @param s The shape
	 @brief Transform a shape by a general transformation
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <modeling/MakeSphere.hpp>
#include <modeling/TransformShape.hpp>
#include <topomesh/BRepMeshIncrementalMesh.hpp>
#include <modeling/MakeShapeTool.hpp>
#include <common/TransformationT.hpp>
#include <common/CartesianCoordinateSystem.hpp>
#include <common/GeneralTransformationT.hpp>
#include <modeling/GeneralTransformShape.hpp>
#include <geometry/GlobalProperty.hpp>
#include <occtio/OCCTTool.hpp>
#include <topology/BRepGlobalProperty.hpp>
#include <geometry/Geom3BSplineCurve.hpp>
#include <modeling/MakeEdge.hpp>
#include <topology/TopoTool.hpp>
#include <topology/BRepAdaptorCurve3.hpp>
using namespace AMCAX;
TEST_CASE("bug1: GeneralTransformShape  ", "[modeling][GeneralTransformShape][fixbug]") {
	TopoShape s = MakeSphere(1.0);
	BRepMeshIncrementalMesh mesher(s, 0.005, true);
	MakeShapeTool::EnsureNormalConsistency(s);
	GeneralTransformation3 tr;
	tr.SetAffinity(Frame3(), 5.0);
	s = GeneralTransformShape(s, tr);
	CHECK(s.Type() == AMCAX::ShapeType::Solid);
	CHECK(s.IsNull() == false);
	GlobalProperty prop;
	BRepGlobalProperty::VolumeProperties(s, prop);
	CHECK(prop.Mass() == Approx(20.934791259).epsilon(1e-11));
	Point3 vP = prop.CenterOfMass();
#ifndef WIN_CASE
	CHECK(vP.X() == Approx(0.0).margin(1e-3));
	CHECK(vP.Y() == Approx(0.0).margin(1e-12));
	CHECK(vP.Z() == Approx(0.0).margin(1e-12));
#else
	CHECK(vP.X() == Approx(-2.2218808037914858e-04).epsilon(1e-12));
	CHECK(vP.Y() == Approx(-1.0782779568197278e-16).epsilon(1e-12));
	CHECK(vP.Z() == Approx(-1.6920954211916623e-16).epsilon(1e-12));
#endif
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API MakeBox(double dx, double dy, double dz)	 @param dx,dy,dz The size
	 @brief Construct from its size in x, y, z directions
,
 "output":#include <modeling/MakeBox.hpp>
#include<catch.hpp>
#include<testHelper.h>
#include <modeling/MakeBox.hpp>
#include <modeling/MakeCylinder.hpp>
#include <topology/BRepExtremaProximityTool.hpp>
#include <io/OBJTool.hpp>
#include <topology/TopoFace.hpp>
#include <modeling/TransformShape.hpp>
#include <topology/TopoExplorerTool.hpp>
#include <modeling/MakeTorus.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
using namespace AMCAX;
#include <modeling/MakeBox.hpp>
#include<catch.hpp>
#include<testHelper.h>
#include <modeling/MakeBox.hpp>
#include <modeling/MakeCylinder.hpp>
#include <topology/BRepExtremaProximityTool.hpp>
#include <io/OBJTool.hpp>
#include <topology/TopoFace.hpp>
#include <modeling/TransformShape.hpp>
#include <topology/TopoExplorerTool.hpp>
#include <modeling/MakeTorus.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
using namespace AMCAX;
;
	SECTION("Box1") {
		OUTPUT_DIRECTORY(topology, OverlapFaces);
		MakeBox box(3.0, 2.0,2.0);
		TopoShape box2= box.Shape();
		box.Init(4.0, 5.0, 6.0);
		TopoFace shape = box.XMinFace(); 
		TopoFace shape1 = box.ZMinFace(); 
		TopoShape shape2 = box; 
		TopoShape shapeV = box;
		AMCAX::GlobalProperty prop1;
		double s_sahpe = GetSurfaceProperties(shape, prop1, true, false);
		double s_sahpe1 = GetSurfaceProperties(shape1, prop1, true, false);
		double s_sahpe2 = GetSurfaceProperties(shape2, prop1, true, false);
		double v_sahpe = GetVolumeProperties(shapeV, prop1, true, false);
		CHECK(s_sahpe == Approx(30.0).margin(1e-12));
		CHECK(s_sahpe1 == Approx(20.0).margin(1e-12));
		CHECK(s_sahpe2 == Approx(148.0).margin(1e-12));
		CHECK(v_sahpe == Approx(120.0).margin(1e-12));
		CHECK( OCCTIO::OCCTTool::Write(box, outdir + "MakeBox1.brep"));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API MakeBox(const Point3& p, double dx, double dy, double dz)	 @param dx,dy,dz The size
	 @param p The corner point
	 @brief Construct from a corner point and its size
,
 "output":#include <modeling/MakeBox.hpp>
#include<catch.hpp>
#include<testHelper.h>
#include <modeling/MakeBox.hpp>
#include <modeling/MakeCylinder.hpp>
#include <topology/BRepExtremaProximityTool.hpp>
#include <io/OBJTool.hpp>
#include <topology/TopoFace.hpp>
#include <modeling/TransformShape.hpp>
#include <topology/TopoExplorerTool.hpp>
#include <modeling/MakeTorus.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
using namespace AMCAX;
#include <modeling/MakeBox.hpp>
#include<catch.hpp>
#include<testHelper.h>
#include <modeling/MakeBox.hpp>
#include <modeling/MakeCylinder.hpp>
#include <topology/BRepExtremaProximityTool.hpp>
#include <io/OBJTool.hpp>
#include <topology/TopoFace.hpp>
#include <modeling/TransformShape.hpp>
#include <topology/TopoExplorerTool.hpp>
#include <modeling/MakeTorus.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
using namespace AMCAX;
;
	SECTION("Box2") 
	{
		OUTPUT_DIRECTORY(topology, OverlapFaces);
		MakeBox box2(Point3(1.0, 1.0, 1.0), 3.0, 3.0, 3.0);
		MakeBox box3;
		box3.Init(Point3(1.0, 1.0, 1.0), 3.0, 3.0, 3.0);
		TopoFace shape1 = box2.XMinFace();
		TopoFace shape2 = box2.XMaxFace();
		TopoFace shape3 = box2.YMinFace();
		TopoFace shape4 = box2.YMaxFace();
		TopoFace shape5 = box2.ZMinFace();
		TopoFace shape6 = box2.ZMaxFace();
		TopoShape shape = box2;
		TopoFace shape_1 = box3.XMinFace();
		TopoFace shape_2 = box3.XMaxFace();
		TopoFace shape_3 = box3.YMinFace();
		TopoFace shape_4 = box3.YMaxFace();
		TopoFace shape_5 = box3.ZMinFace();
		TopoFace shape_6 = box3.ZMaxFace();
		AMCAX::GlobalProperty prop1;
		double s_sahpe1 = GetSurfaceProperties(shape1, prop1, true, false);
		double s_sahpe2 = GetSurfaceProperties(shape2, prop1, true, false);
		double s_sahpe3 = GetSurfaceProperties(shape3, prop1, true, false);
		double s_sahpe4 = GetSurfaceProperties(shape4, prop1, true, false);
		double s_sahpe5 = GetSurfaceProperties(shape5, prop1, true, false);
		double s_sahpe6 = GetSurfaceProperties(shape6, prop1, true, false);
		double s_sahpe  = GetSurfaceProperties(shape, prop1, true, false);
		double v_sahpe = GetVolumeProperties(shape, prop1, true, false);
		BRepClassificationTools brep;
		bool r1 = brep.IsPointInOnFace(shape1, Point3(1.0, 2.0, 2.0), -1.0);
		bool r2 = brep.IsPointInOnFace(shape2, Point3(4.0, 2.0, 2.0), -1.0);
		bool r3 = brep.IsPointInOnFace(shape3, Point3(2.0, 1.0, 2.0), -1.0);
		bool r33 = brep.IsPointInOnFace(shape3, Point3(0.0, 1.0, 0.5), -1.0);
		bool r4 = brep.IsPointInOnFace(shape4, Point3(2.0, 4.0, 2.0), -1.0);
		bool r5 = brep.IsPointInOnFace(shape5, Point3(2.0, 2.0, 1.0), -1.0);
		bool r6 = brep.IsPointInOnFace(shape6, Point3(2.0, 2.0, 4.0), -1.0);
		double s_shape_1 = GetSurfaceProperties(shape_1, prop1, true, false);
		double s_shape_2 = GetSurfaceProperties(shape_2, prop1, true, false);
		double s_shape_3 = GetSurfaceProperties(shape_3, prop1, true, false);
		double s_shape_4 = GetSurfaceProperties(shape_4, prop1, true, false);
		double s_shape_5 = GetSurfaceProperties(shape_5, prop1, true, false);
		double s_shape_6 = GetSurfaceProperties(shape_6, prop1, true, false);
		bool r_1 = brep.IsPointInOnFace(shape_1, Point3(1.0, 2.0, 2.0), -1.0);
		bool r_2 = brep.IsPointInOnFace(shape_2, Point3(4.0, 2.0, 2.0), -1.0);
		bool r_3 = brep.IsPointInOnFace(shape_3, Point3(2.0, 1.0, 2.0), -1.0);
		bool r_33 = brep.IsPointInOnFace(shape_3, Point3(0.0, 1.0, 0.5), -1.0);
		bool r_4 = brep.IsPointInOnFace(shape_4, Point3(2.0, 4.0, 2.0), -1.0);
		bool r_5 = brep.IsPointInOnFace(shape_5, Point3(2.0, 2.0, 1.0), -1.0);
		bool r_6 = brep.IsPointInOnFace(shape_6, Point3(2.0, 2.0, 4.0), -1.0);
		CHECK(s_sahpe1 == Approx(9.0).margin(1e-12));
		CHECK(s_sahpe2 == Approx(9.0).margin(1e-12));
		CHECK(s_sahpe3 == Approx(9.0).margin(1e-12));
		CHECK(s_sahpe4 == Approx(9.0).margin(1e-12));
		CHECK(s_sahpe5 == Approx(9.0).margin(1e-12));
		CHECK(s_sahpe6 == Approx(9.0).margin(1e-12));
		CHECK(v_sahpe == Approx(27.0).margin(1e-12));
		CHECK(s_sahpe  == s_sahpe1+ s_sahpe2+ s_sahpe3+s_sahpe4+s_sahpe5+s_sahpe6);
		CHECK(s_sahpe1 == s_shape_1);
		CHECK(s_sahpe2 == s_shape_2);
		CHECK(s_sahpe3 == s_shape_3);
		CHECK(s_sahpe4 == s_shape_4);
		CHECK(s_sahpe5 == s_shape_5);
		CHECK(s_sahpe6 == s_shape_6);
		CHECK(r1 == true);
		CHECK(r2 == true);
		CHECK(r3 == true);
		CHECK(r33 == false);
		CHECK(r4 == true);
		CHECK(r5 == true);
		CHECK(r6 == true);
		CHECK(r_1 == true);
		CHECK(r_2 == true);
		CHECK(r_3 == true);
		CHECK(r_33 == false);
		CHECK(r_4 == true);
		CHECK(r_5 == true);
		CHECK(r_6 == true);
		CHECK(OCCTIO::OCCTTool::Write(box2, outdir + "MakeBox2.brep"));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API MakeBox(const Point3& p1, const Point3& p2)	 @param p2 The second point
	 @param p1 The first point
	 @brief Construct from two diagonal corner points
,
 "output":#include <modeling/MakeBox.hpp>
#include<catch.hpp>
#include<testHelper.h>
#include <modeling/MakeBox.hpp>
#include <modeling/MakeCylinder.hpp>
#include <topology/BRepExtremaProximityTool.hpp>
#include <io/OBJTool.hpp>
#include <topology/TopoFace.hpp>
#include <modeling/TransformShape.hpp>
#include <topology/TopoExplorerTool.hpp>
#include <modeling/MakeTorus.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
using namespace AMCAX;
#include <modeling/MakeBox.hpp>
#include<catch.hpp>
#include<testHelper.h>
#include <modeling/MakeBox.hpp>
#include <modeling/MakeCylinder.hpp>
#include <topology/BRepExtremaProximityTool.hpp>
#include <io/OBJTool.hpp>
#include <topology/TopoFace.hpp>
#include <modeling/TransformShape.hpp>
#include <topology/TopoExplorerTool.hpp>
#include <modeling/MakeTorus.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
using namespace AMCAX;
;
	SECTION("Box3")
	{
		OUTPUT_DIRECTORY(topology, OverlapFaces);
		MakeBox box2(Point3(-2.0, -2.0, -2.0), Point3(2.0,2.0,2.0));
		MakeBox box3;
		box3.Init(Point3(-2.0, -2.0, -2.0), Point3(2.0, 2.0, 2.0));
		TopoFace shape1 = box2.XMinFace();
		TopoFace shape2 = box2.XMaxFace();
		TopoFace shape3 = box2.YMinFace();
		TopoFace shape4 = box2.YMaxFace();
		TopoFace shape5 = box2.ZMinFace();
		TopoFace shape6 = box2.ZMaxFace();
		TopoShape shape = box2;
		TopoFace shape_1 = box3.XMinFace();
		TopoFace shape_2 = box3.XMaxFace();
		TopoFace shape_3 = box3.YMinFace();
		TopoFace shape_4 = box3.YMaxFace();
		TopoFace shape_5 = box3.ZMinFace();
		TopoFace shape_6 = box3.ZMaxFace();
		AMCAX::GlobalProperty prop1;
		double s_sahpe1 = GetSurfaceProperties(shape1, prop1, true, false);
		double s_sahpe2 = GetSurfaceProperties(shape2, prop1, true, false);
		double s_sahpe3 = GetSurfaceProperties(shape3, prop1, true, false);
		double s_sahpe4 = GetSurfaceProperties(shape4, prop1, true, false);
		double s_sahpe5 = GetSurfaceProperties(shape5, prop1, true, false);
		double s_sahpe6 = GetSurfaceProperties(shape6, prop1, true, false);
		double s_sahpe = GetSurfaceProperties(shape, prop1, true, false);
		double v_sahpe = GetVolumeProperties(shape, prop1, true, false);
		BRepClassificationTools brep;
		bool r1 = brep.IsPointInOnFace(shape1, Point3(-2.0, 0.0, 0.0), -1.0);
		bool r2 = brep.IsPointInOnFace(shape2, Point3(2.0, 0.0, 0.0), -1.0);
		bool r3 = brep.IsPointInOnFace(shape3, Point3(0.0, -2.0, 0.0), -1.0);
		bool r33 = brep.IsPointInOnFace(shape3, Point3(1.0, 0.5, 3.0), -1.0);
		bool r4 = brep.IsPointInOnFace(shape4, Point3(0.0, 2.0, 0.0), -1.0);
		bool r5 = brep.IsPointInOnFace(shape5, Point3(0.0, 0.0, -2.0), -1.0);
		bool r6 = brep.IsPointInOnFace(shape6, Point3(0.0, 0.0, 2.0), -1.0);
		double s_shape_1 = GetSurfaceProperties(shape_1, prop1, true, false);
		double s_shape_2 = GetSurfaceProperties(shape_2, prop1, true, false);
		double s_shape_3 = GetSurfaceProperties(shape_3, prop1, true, false);
		double s_shape_4 = GetSurfaceProperties(shape_4, prop1, true, false);
		double s_shape_5 = GetSurfaceProperties(shape_5, prop1, true, false);
		double s_shape_6 = GetSurfaceProperties(shape_6, prop1, true, false);
		bool r_1 = brep.IsPointInOnFace(shape_1, Point3(-2.0, 0.0, 0.0), -1.0);
		bool r_2 = brep.IsPointInOnFace(shape_2, Point3(2.0, 0.0, 0.0), -1.0);
		bool r_3 = brep.IsPointInOnFace(shape_3, Point3(0.0, -2.0, 0.0), -1.0);
		bool r_33 = brep.IsPointInOnFace(shape_3, Point3(1.0, 0.5, 3.0), -1.0);
		bool r_4 = brep.IsPointInOnFace(shape_4, Point3(0.0, 2.0, 0.0), -1.0);
		bool r_5 = brep.IsPointInOnFace(shape_5, Point3(0.0, 0.0, -2.0), -1.0);
		bool r_6 = brep.IsPointInOnFace(shape_6, Point3(0.0, 0.0, 2.0), -1.0);
		CHECK(s_sahpe1 == Approx(16.0).margin(1e-12));
		CHECK(s_sahpe2 == Approx(16.0).margin(1e-12));
		CHECK(s_sahpe3 == Approx(16.0).margin(1e-12));
		CHECK(s_sahpe4 == Approx(16.0).margin(1e-12));
		CHECK(s_sahpe5 == Approx(16.0).margin(1e-12));
		CHECK(s_sahpe6 == Approx(16.0).margin(1e-12));
		CHECK(v_sahpe == Approx(64.0).margin(1e-12));
		CHECK(s_sahpe == s_sahpe1 + s_sahpe2 + s_sahpe3 + s_sahpe4 + s_sahpe5 + s_sahpe6);
		CHECK(s_sahpe1 == s_shape_1);
		CHECK(s_sahpe2 == s_shape_2);
		CHECK(s_sahpe3 == s_shape_3);
		CHECK(s_sahpe4 == s_shape_4);
		CHECK(s_sahpe5 == s_shape_5);
		CHECK(s_sahpe6 == s_shape_6);
		CHECK(r1 == true);
		CHECK(r2 == true);
		CHECK(r3 == true);
		CHECK(r33 == false);
		CHECK(r4 == true);
		CHECK(r5 == true);
		CHECK(r6 == true);
		CHECK(r_1 == true);
		CHECK(r_2 == true);
		CHECK(r_3 == true);
		CHECK(r_33 == false);
		CHECK(r_4 == true);
		CHECK(r_5 == true);
		CHECK(r_6 == true);
		CHECK(OCCTIO::OCCTTool::Write(box2, outdir + "MakeBox3.brep"));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API MakeBox(const Frame3& frame, double dx, double dy, double dz)	 @param dx,dy,dz The size
	 @param frame The local coordinate system
	 @brief Construct from a local coordinate system and size
,
 "output":#include <modeling/MakeBox.hpp>
#include<catch.hpp>
#include<testHelper.h>
#include <modeling/MakeBox.hpp>
#include <modeling/MakeCylinder.hpp>
#include <topology/BRepExtremaProximityTool.hpp>
#include <io/OBJTool.hpp>
#include <topology/TopoFace.hpp>
#include <modeling/TransformShape.hpp>
#include <topology/TopoExplorerTool.hpp>
#include <modeling/MakeTorus.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
using namespace AMCAX;
#include <modeling/MakeBox.hpp>
#include<catch.hpp>
#include<testHelper.h>
#include <modeling/MakeBox.hpp>
#include <modeling/MakeCylinder.hpp>
#include <topology/BRepExtremaProximityTool.hpp>
#include <io/OBJTool.hpp>
#include <topology/TopoFace.hpp>
#include <modeling/TransformShape.hpp>
#include <topology/TopoExplorerTool.hpp>
#include <modeling/MakeTorus.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
using namespace AMCAX;
;
	SECTION("Box2") 
	{
		OUTPUT_DIRECTORY(topology, OverlapFaces);
		MakeBox box2(Point3(1.0, 1.0, 1.0), 3.0, 3.0, 3.0);
		MakeBox box3;
		box3.Init(Point3(1.0, 1.0, 1.0), 3.0, 3.0, 3.0);
		TopoFace shape1 = box2.XMinFace();
		TopoFace shape2 = box2.XMaxFace();
		TopoFace shape3 = box2.YMinFace();
		TopoFace shape4 = box2.YMaxFace();
		TopoFace shape5 = box2.ZMinFace();
		TopoFace shape6 = box2.ZMaxFace();
		TopoShape shape = box2;
		TopoFace shape_1 = box3.XMinFace();
		TopoFace shape_2 = box3.XMaxFace();
		TopoFace shape_3 = box3.YMinFace();
		TopoFace shape_4 = box3.YMaxFace();
		TopoFace shape_5 = box3.ZMinFace();
		TopoFace shape_6 = box3.ZMaxFace();
		AMCAX::GlobalProperty prop1;
		double s_sahpe1 = GetSurfaceProperties(shape1, prop1, true, false);
		double s_sahpe2 = GetSurfaceProperties(shape2, prop1, true, false);
		double s_sahpe3 = GetSurfaceProperties(shape3, prop1, true, false);
		double s_sahpe4 = GetSurfaceProperties(shape4, prop1, true, false);
		double s_sahpe5 = GetSurfaceProperties(shape5, prop1, true, false);
		double s_sahpe6 = GetSurfaceProperties(shape6, prop1, true, false);
		double s_sahpe  = GetSurfaceProperties(shape, prop1, true, false);
		double v_sahpe = GetVolumeProperties(shape, prop1, true, false);
		BRepClassificationTools brep;
		bool r1 = brep.IsPointInOnFace(shape1, Point3(1.0, 2.0, 2.0), -1.0);
		bool r2 = brep.IsPointInOnFace(shape2, Point3(4.0, 2.0, 2.0), -1.0);
		bool r3 = brep.IsPointInOnFace(shape3, Point3(2.0, 1.0, 2.0), -1.0);
		bool r33 = brep.IsPointInOnFace(shape3, Point3(0.0, 1.0, 0.5), -1.0);
		bool r4 = brep.IsPointInOnFace(shape4, Point3(2.0, 4.0, 2.0), -1.0);
		bool r5 = brep.IsPointInOnFace(shape5, Point3(2.0, 2.0, 1.0), -1.0);
		bool r6 = brep.IsPointInOnFace(shape6, Point3(2.0, 2.0, 4.0), -1.0);
		double s_shape_1 = GetSurfaceProperties(shape_1, prop1, true, false);
		double s_shape_2 = GetSurfaceProperties(shape_2, prop1, true, false);
		double s_shape_3 = GetSurfaceProperties(shape_3, prop1, true, false);
		double s_shape_4 = GetSurfaceProperties(shape_4, prop1, true, false);
		double s_shape_5 = GetSurfaceProperties(shape_5, prop1, true, false);
		double s_shape_6 = GetSurfaceProperties(shape_6, prop1, true, false);
		bool r_1 = brep.IsPointInOnFace(shape_1, Point3(1.0, 2.0, 2.0), -1.0);
		bool r_2 = brep.IsPointInOnFace(shape_2, Point3(4.0, 2.0, 2.0), -1.0);
		bool r_3 = brep.IsPointInOnFace(shape_3, Point3(2.0, 1.0, 2.0), -1.0);
		bool r_33 = brep.IsPointInOnFace(shape_3, Point3(0.0, 1.0, 0.5), -1.0);
		bool r_4 = brep.IsPointInOnFace(shape_4, Point3(2.0, 4.0, 2.0), -1.0);
		bool r_5 = brep.IsPointInOnFace(shape_5, Point3(2.0, 2.0, 1.0), -1.0);
		bool r_6 = brep.IsPointInOnFace(shape_6, Point3(2.0, 2.0, 4.0), -1.0);
		CHECK(s_sahpe1 == Approx(9.0).margin(1e-12));
		CHECK(s_sahpe2 == Approx(9.0).margin(1e-12));
		CHECK(s_sahpe3 == Approx(9.0).margin(1e-12));
		CHECK(s_sahpe4 == Approx(9.0).margin(1e-12));
		CHECK(s_sahpe5 == Approx(9.0).margin(1e-12));
		CHECK(s_sahpe6 == Approx(9.0).margin(1e-12));
		CHECK(v_sahpe == Approx(27.0).margin(1e-12));
		CHECK(s_sahpe  == s_sahpe1+ s_sahpe2+ s_sahpe3+s_sahpe4+s_sahpe5+s_sahpe6);
		CHECK(s_sahpe1 == s_shape_1);
		CHECK(s_sahpe2 == s_shape_2);
		CHECK(s_sahpe3 == s_shape_3);
		CHECK(s_sahpe4 == s_shape_4);
		CHECK(s_sahpe5 == s_shape_5);
		CHECK(s_sahpe6 == s_shape_6);
		CHECK(r1 == true);
		CHECK(r2 == true);
		CHECK(r3 == true);
		CHECK(r33 == false);
		CHECK(r4 == true);
		CHECK(r5 == true);
		CHECK(r6 == true);
		CHECK(r_1 == true);
		CHECK(r_2 == true);
		CHECK(r_3 == true);
		CHECK(r_33 == false);
		CHECK(r_4 == true);
		CHECK(r_5 == true);
		CHECK(r_6 == true);
		CHECK(OCCTIO::OCCTTool::Write(box2, outdir + "MakeBox2.brep"));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API void Init(double dx, double dy, double dz)	 @param dx,dy,dz The size
	 @brief Initialize and construct from its size in x, y, z directions
,
 "output":#include <modeling/MakeBox.hpp>
#include<catch.hpp>
#include<testHelper.h>
#include <modeling/MakeBox.hpp>
#include <modeling/MakeCylinder.hpp>
#include <topology/BRepExtremaProximityTool.hpp>
#include <io/OBJTool.hpp>
#include <topology/TopoFace.hpp>
#include <modeling/TransformShape.hpp>
#include <topology/TopoExplorerTool.hpp>
#include <modeling/MakeTorus.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
using namespace AMCAX;
#include <modeling/MakeBox.hpp>
#include<catch.hpp>
#include<testHelper.h>
#include <modeling/MakeBox.hpp>
#include <modeling/MakeCylinder.hpp>
#include <topology/BRepExtremaProximityTool.hpp>
#include <io/OBJTool.hpp>
#include <topology/TopoFace.hpp>
#include <modeling/TransformShape.hpp>
#include <topology/TopoExplorerTool.hpp>
#include <modeling/MakeTorus.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
using namespace AMCAX;
;
	SECTION("Box1") {
		OUTPUT_DIRECTORY(topology, OverlapFaces);
		MakeBox box(3.0, 2.0,2.0);
		TopoShape box2= box.Shape();
		box.Init(4.0, 5.0, 6.0);
		TopoFace shape = box.XMinFace(); 
		TopoFace shape1 = box.ZMinFace(); 
		TopoShape shape2 = box; 
		TopoShape shapeV = box;
		AMCAX::GlobalProperty prop1;
		double s_sahpe = GetSurfaceProperties(shape, prop1, true, false);
		double s_sahpe1 = GetSurfaceProperties(shape1, prop1, true, false);
		double s_sahpe2 = GetSurfaceProperties(shape2, prop1, true, false);
		double v_sahpe = GetVolumeProperties(shapeV, prop1, true, false);
		CHECK(s_sahpe == Approx(30.0).margin(1e-12));
		CHECK(s_sahpe1 == Approx(20.0).margin(1e-12));
		CHECK(s_sahpe2 == Approx(148.0).margin(1e-12));
		CHECK(v_sahpe == Approx(120.0).margin(1e-12));
		CHECK( OCCTIO::OCCTTool::Write(box, outdir + "MakeBox1.brep"));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API void Init(const Point3& p, double dx, double dy, double dz)	 @param dx,dy,dz The size
	 @param p The corner point
	 @brief Initialize and construct from a corner point and its size
,
 "output":#include <modeling/MakeBox.hpp>
#include<catch.hpp>
#include<testHelper.h>
#include <modeling/MakeBox.hpp>
#include <modeling/MakeCylinder.hpp>
#include <topology/BRepExtremaProximityTool.hpp>
#include <io/OBJTool.hpp>
#include <topology/TopoFace.hpp>
#include <modeling/TransformShape.hpp>
#include <topology/TopoExplorerTool.hpp>
#include <modeling/MakeTorus.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
using namespace AMCAX;
#include <modeling/MakeBox.hpp>
#include<catch.hpp>
#include<testHelper.h>
#include <modeling/MakeBox.hpp>
#include <modeling/MakeCylinder.hpp>
#include <topology/BRepExtremaProximityTool.hpp>
#include <io/OBJTool.hpp>
#include <topology/TopoFace.hpp>
#include <modeling/TransformShape.hpp>
#include <topology/TopoExplorerTool.hpp>
#include <modeling/MakeTorus.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
using namespace AMCAX;
;
	SECTION("Box2") 
	{
		OUTPUT_DIRECTORY(topology, OverlapFaces);
		MakeBox box2(Point3(1.0, 1.0, 1.0), 3.0, 3.0, 3.0);
		MakeBox box3;
		box3.Init(Point3(1.0, 1.0, 1.0), 3.0, 3.0, 3.0);
		TopoFace shape1 = box2.XMinFace();
		TopoFace shape2 = box2.XMaxFace();
		TopoFace shape3 = box2.YMinFace();
		TopoFace shape4 = box2.YMaxFace();
		TopoFace shape5 = box2.ZMinFace();
		TopoFace shape6 = box2.ZMaxFace();
		TopoShape shape = box2;
		TopoFace shape_1 = box3.XMinFace();
		TopoFace shape_2 = box3.XMaxFace();
		TopoFace shape_3 = box3.YMinFace();
		TopoFace shape_4 = box3.YMaxFace();
		TopoFace shape_5 = box3.ZMinFace();
		TopoFace shape_6 = box3.ZMaxFace();
		AMCAX::GlobalProperty prop1;
		double s_sahpe1 = GetSurfaceProperties(shape1, prop1, true, false);
		double s_sahpe2 = GetSurfaceProperties(shape2, prop1, true, false);
		double s_sahpe3 = GetSurfaceProperties(shape3, prop1, true, false);
		double s_sahpe4 = GetSurfaceProperties(shape4, prop1, true, false);
		double s_sahpe5 = GetSurfaceProperties(shape5, prop1, true, false);
		double s_sahpe6 = GetSurfaceProperties(shape6, prop1, true, false);
		double s_sahpe  = GetSurfaceProperties(shape, prop1, true, false);
		double v_sahpe = GetVolumeProperties(shape, prop1, true, false);
		BRepClassificationTools brep;
		bool r1 = brep.IsPointInOnFace(shape1, Point3(1.0, 2.0, 2.0), -1.0);
		bool r2 = brep.IsPointInOnFace(shape2, Point3(4.0, 2.0, 2.0), -1.0);
		bool r3 = brep.IsPointInOnFace(shape3, Point3(2.0, 1.0, 2.0), -1.0);
		bool r33 = brep.IsPointInOnFace(shape3, Point3(0.0, 1.0, 0.5), -1.0);
		bool r4 = brep.IsPointInOnFace(shape4, Point3(2.0, 4.0, 2.0), -1.0);
		bool r5 = brep.IsPointInOnFace(shape5, Point3(2.0, 2.0, 1.0), -1.0);
		bool r6 = brep.IsPointInOnFace(shape6, Point3(2.0, 2.0, 4.0), -1.0);
		double s_shape_1 = GetSurfaceProperties(shape_1, prop1, true, false);
		double s_shape_2 = GetSurfaceProperties(shape_2, prop1, true, false);
		double s_shape_3 = GetSurfaceProperties(shape_3, prop1, true, false);
		double s_shape_4 = GetSurfaceProperties(shape_4, prop1, true, false);
		double s_shape_5 = GetSurfaceProperties(shape_5, prop1, true, false);
		double s_shape_6 = GetSurfaceProperties(shape_6, prop1, true, false);
		bool r_1 = brep.IsPointInOnFace(shape_1, Point3(1.0, 2.0, 2.0), -1.0);
		bool r_2 = brep.IsPointInOnFace(shape_2, Point3(4.0, 2.0, 2.0), -1.0);
		bool r_3 = brep.IsPointInOnFace(shape_3, Point3(2.0, 1.0, 2.0), -1.0);
		bool r_33 = brep.IsPointInOnFace(shape_3, Point3(0.0, 1.0, 0.5), -1.0);
		bool r_4 = brep.IsPointInOnFace(shape_4, Point3(2.0, 4.0, 2.0), -1.0);
		bool r_5 = brep.IsPointInOnFace(shape_5, Point3(2.0, 2.0, 1.0), -1.0);
		bool r_6 = brep.IsPointInOnFace(shape_6, Point3(2.0, 2.0, 4.0), -1.0);
		CHECK(s_sahpe1 == Approx(9.0).margin(1e-12));
		CHECK(s_sahpe2 == Approx(9.0).margin(1e-12));
		CHECK(s_sahpe3 == Approx(9.0).margin(1e-12));
		CHECK(s_sahpe4 == Approx(9.0).margin(1e-12));
		CHECK(s_sahpe5 == Approx(9.0).margin(1e-12));
		CHECK(s_sahpe6 == Approx(9.0).margin(1e-12));
		CHECK(v_sahpe == Approx(27.0).margin(1e-12));
		CHECK(s_sahpe  == s_sahpe1+ s_sahpe2+ s_sahpe3+s_sahpe4+s_sahpe5+s_sahpe6);
		CHECK(s_sahpe1 == s_shape_1);
		CHECK(s_sahpe2 == s_shape_2);
		CHECK(s_sahpe3 == s_shape_3);
		CHECK(s_sahpe4 == s_shape_4);
		CHECK(s_sahpe5 == s_shape_5);
		CHECK(s_sahpe6 == s_shape_6);
		CHECK(r1 == true);
		CHECK(r2 == true);
		CHECK(r3 == true);
		CHECK(r33 == false);
		CHECK(r4 == true);
		CHECK(r5 == true);
		CHECK(r6 == true);
		CHECK(r_1 == true);
		CHECK(r_2 == true);
		CHECK(r_3 == true);
		CHECK(r_33 == false);
		CHECK(r_4 == true);
		CHECK(r_5 == true);
		CHECK(r_6 == true);
		CHECK(OCCTIO::OCCTTool::Write(box2, outdir + "MakeBox2.brep"));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API void Init(const Point3& p1, const Point3& p2)	 @param p2 The second point
	 @param p1 The first point
	 @brief Initialize and construct from two diagonal corner points
,
 "output":#include <modeling/MakeBox.hpp>
#include<catch.hpp>
#include<testHelper.h>
#include <modeling/MakeBox.hpp>
#include <modeling/MakeCylinder.hpp>
#include <topology/BRepExtremaProximityTool.hpp>
#include <io/OBJTool.hpp>
#include <topology/TopoFace.hpp>
#include <modeling/TransformShape.hpp>
#include <topology/TopoExplorerTool.hpp>
#include <modeling/MakeTorus.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
using namespace AMCAX;
#include <modeling/MakeBox.hpp>
#include<catch.hpp>
#include<testHelper.h>
#include <modeling/MakeBox.hpp>
#include <modeling/MakeCylinder.hpp>
#include <topology/BRepExtremaProximityTool.hpp>
#include <io/OBJTool.hpp>
#include <topology/TopoFace.hpp>
#include <modeling/TransformShape.hpp>
#include <topology/TopoExplorerTool.hpp>
#include <modeling/MakeTorus.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
using namespace AMCAX;
;
	SECTION("Box3")
	{
		OUTPUT_DIRECTORY(topology, OverlapFaces);
		MakeBox box2(Point3(-2.0, -2.0, -2.0), Point3(2.0,2.0,2.0));
		MakeBox box3;
		box3.Init(Point3(-2.0, -2.0, -2.0), Point3(2.0, 2.0, 2.0));
		TopoFace shape1 = box2.XMinFace();
		TopoFace shape2 = box2.XMaxFace();
		TopoFace shape3 = box2.YMinFace();
		TopoFace shape4 = box2.YMaxFace();
		TopoFace shape5 = box2.ZMinFace();
		TopoFace shape6 = box2.ZMaxFace();
		TopoShape shape = box2;
		TopoFace shape_1 = box3.XMinFace();
		TopoFace shape_2 = box3.XMaxFace();
		TopoFace shape_3 = box3.YMinFace();
		TopoFace shape_4 = box3.YMaxFace();
		TopoFace shape_5 = box3.ZMinFace();
		TopoFace shape_6 = box3.ZMaxFace();
		AMCAX::GlobalProperty prop1;
		double s_sahpe1 = GetSurfaceProperties(shape1, prop1, true, false);
		double s_sahpe2 = GetSurfaceProperties(shape2, prop1, true, false);
		double s_sahpe3 = GetSurfaceProperties(shape3, prop1, true, false);
		double s_sahpe4 = GetSurfaceProperties(shape4, prop1, true, false);
		double s_sahpe5 = GetSurfaceProperties(shape5, prop1, true, false);
		double s_sahpe6 = GetSurfaceProperties(shape6, prop1, true, false);
		double s_sahpe = GetSurfaceProperties(shape, prop1, true, false);
		double v_sahpe = GetVolumeProperties(shape, prop1, true, false);
		BRepClassificationTools brep;
		bool r1 = brep.IsPointInOnFace(shape1, Point3(-2.0, 0.0, 0.0), -1.0);
		bool r2 = brep.IsPointInOnFace(shape2, Point3(2.0, 0.0, 0.0), -1.0);
		bool r3 = brep.IsPointInOnFace(shape3, Point3(0.0, -2.0, 0.0), -1.0);
		bool r33 = brep.IsPointInOnFace(shape3, Point3(1.0, 0.5, 3.0), -1.0);
		bool r4 = brep.IsPointInOnFace(shape4, Point3(0.0, 2.0, 0.0), -1.0);
		bool r5 = brep.IsPointInOnFace(shape5, Point3(0.0, 0.0, -2.0), -1.0);
		bool r6 = brep.IsPointInOnFace(shape6, Point3(0.0, 0.0, 2.0), -1.0);
		double s_shape_1 = GetSurfaceProperties(shape_1, prop1, true, false);
		double s_shape_2 = GetSurfaceProperties(shape_2, prop1, true, false);
		double s_shape_3 = GetSurfaceProperties(shape_3, prop1, true, false);
		double s_shape_4 = GetSurfaceProperties(shape_4, prop1, true, false);
		double s_shape_5 = GetSurfaceProperties(shape_5, prop1, true, false);
		double s_shape_6 = GetSurfaceProperties(shape_6, prop1, true, false);
		bool r_1 = brep.IsPointInOnFace(shape_1, Point3(-2.0, 0.0, 0.0), -1.0);
		bool r_2 = brep.IsPointInOnFace(shape_2, Point3(2.0, 0.0, 0.0), -1.0);
		bool r_3 = brep.IsPointInOnFace(shape_3, Point3(0.0, -2.0, 0.0), -1.0);
		bool r_33 = brep.IsPointInOnFace(shape_3, Point3(1.0, 0.5, 3.0), -1.0);
		bool r_4 = brep.IsPointInOnFace(shape_4, Point3(0.0, 2.0, 0.0), -1.0);
		bool r_5 = brep.IsPointInOnFace(shape_5, Point3(0.0, 0.0, -2.0), -1.0);
		bool r_6 = brep.IsPointInOnFace(shape_6, Point3(0.0, 0.0, 2.0), -1.0);
		CHECK(s_sahpe1 == Approx(16.0).margin(1e-12));
		CHECK(s_sahpe2 == Approx(16.0).margin(1e-12));
		CHECK(s_sahpe3 == Approx(16.0).margin(1e-12));
		CHECK(s_sahpe4 == Approx(16.0).margin(1e-12));
		CHECK(s_sahpe5 == Approx(16.0).margin(1e-12));
		CHECK(s_sahpe6 == Approx(16.0).margin(1e-12));
		CHECK(v_sahpe == Approx(64.0).margin(1e-12));
		CHECK(s_sahpe == s_sahpe1 + s_sahpe2 + s_sahpe3 + s_sahpe4 + s_sahpe5 + s_sahpe6);
		CHECK(s_sahpe1 == s_shape_1);
		CHECK(s_sahpe2 == s_shape_2);
		CHECK(s_sahpe3 == s_shape_3);
		CHECK(s_sahpe4 == s_shape_4);
		CHECK(s_sahpe5 == s_shape_5);
		CHECK(s_sahpe6 == s_shape_6);
		CHECK(r1 == true);
		CHECK(r2 == true);
		CHECK(r3 == true);
		CHECK(r33 == false);
		CHECK(r4 == true);
		CHECK(r5 == true);
		CHECK(r6 == true);
		CHECK(r_1 == true);
		CHECK(r_2 == true);
		CHECK(r_3 == true);
		CHECK(r_33 == false);
		CHECK(r_4 == true);
		CHECK(r_5 == true);
		CHECK(r_6 == true);
		CHECK(OCCTIO::OCCTTool::Write(box2, outdir + "MakeBox3.brep"));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API void Init(const Frame3& frame, double dx, double dy, double dz)	 @param dx,dy,dz The size
	 @param frame The local coordinate system
	 @brief Initialize and construct from a local coordinate system and size
,
 "output":#include <modeling/MakeBox.hpp>
#include<catch.hpp>
#include<testHelper.h>
#include <modeling/MakeBox.hpp>
#include <modeling/MakeCylinder.hpp>
#include <topology/BRepExtremaProximityTool.hpp>
#include <io/OBJTool.hpp>
#include <topology/TopoFace.hpp>
#include <modeling/TransformShape.hpp>
#include <topology/TopoExplorerTool.hpp>
#include <modeling/MakeTorus.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
using namespace AMCAX;
#include <modeling/MakeBox.hpp>
#include<catch.hpp>
#include<testHelper.h>
#include <modeling/MakeBox.hpp>
#include <modeling/MakeCylinder.hpp>
#include <topology/BRepExtremaProximityTool.hpp>
#include <io/OBJTool.hpp>
#include <topology/TopoFace.hpp>
#include <modeling/TransformShape.hpp>
#include <topology/TopoExplorerTool.hpp>
#include <modeling/MakeTorus.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
using namespace AMCAX;
;
	SECTION("Box4")
	{
		OUTPUT_DIRECTORY(topology, OverlapFaces);
		Frame3 frame(Point3(0.0, 0.0, 0.0),Direction3(1.0, 1.0, 1.0));
		MakeBox box2(frame, 3.0, 3.0, 3.0);
		MakeBox box3;
		box3.Init(frame, 3.0, 3.0, 3.0);
		TopoFace shape1 = box2.XMinFace();
		TopoFace shape2 = box2.XMaxFace();
		TopoFace shape3 = box2.YMinFace();
		TopoFace shape4 = box2.YMaxFace();
		TopoFace shape5 = box2.ZMinFace();
		TopoFace shape6 = box2.ZMaxFace();
		TopoShape shape = box2;
		TopoFace shape_1 = box3.XMinFace();
		TopoFace shape_2 = box3.XMaxFace();
		TopoFace shape_3 = box3.YMinFace();
		TopoFace shape_4 = box3.YMaxFace();
		TopoFace shape_5 = box3.ZMinFace();
		TopoFace shape_6 = box3.ZMaxFace();
		AMCAX::GlobalProperty prop1;
		double s_sahpe1 = GetSurfaceProperties(shape1, prop1, true, false);
		double s_sahpe2 = GetSurfaceProperties(shape2, prop1, true, false);
		double s_sahpe3 = GetSurfaceProperties(shape3, prop1, true, false);
		double s_sahpe4 = GetSurfaceProperties(shape4, prop1, true, false);
		double s_sahpe5 = GetSurfaceProperties(shape5, prop1, true, false);
		double s_sahpe6 = GetSurfaceProperties(shape6, prop1, true, false);
		double s_sahpe = GetSurfaceProperties(shape, prop1, true, false);
		double v_sahpe = GetVolumeProperties(shape, prop1, true, false);
		BRepClassificationTools brep;
		bool r1 = brep.IsPointInOnFace(shape1, Point3(0.471005 , 1.580366 , 0.471005));
		bool r2 = brep.IsPointInOnFace(shape2, Point3(2.276501 , 1.893133 , -1.966139), -1.0);
		bool r3 = brep.IsPointInOnFace(shape3, Point3(1.595268 ,0.992078 ,0.388888), -1.0);
		bool r33 = brep.IsPointInOnFace(shape3, Point3(0.0, 1.0, 0.5), -1.0);
		bool r4 = brep.IsPointInOnFace(shape4, Point3(0.913586 , 3.603864 , - 1.054327), -1.0);
		bool r5 = brep.IsPointInOnFace(shape5, Point3(0.169491 , 0.796305 , -0.965796), -1.0);
		bool r6 = brep.IsPointInOnFace(shape6, Point3(1.633739, 2.302035, 1.260379), -1.0);
		double s_shape_1 = GetSurfaceProperties(shape_1, prop1, true, false);
		double s_shape_2 = GetSurfaceProperties(shape_2, prop1, true, false);
		double s_shape_3 = GetSurfaceProperties(shape_3, prop1, true, false);
		double s_shape_4 = GetSurfaceProperties(shape_4, prop1, true, false);
		double s_shape_5 = GetSurfaceProperties(shape_5, prop1, true, false);
		double s_shape_6 = GetSurfaceProperties(shape_6, prop1, true, false);
		bool r_1 = brep.IsPointInOnFace(shape_1, Point3(0.471005, 1.580366, 0.471005), -1.0);
		bool r_2 = brep.IsPointInOnFace(shape_2, Point3(2.276501, 1.893133, -1.966139), -1.0);
		bool r_3 = brep.IsPointInOnFace(shape_3, Point3(1.595268, 0.992078, 0.388888), -1.0);
		bool r_33 = brep.IsPointInOnFace(shape_3, Point3(0.0, 1.0, 0.5), -1.0);
		bool r_4 = brep.IsPointInOnFace(shape_4, Point3(0.913586, 3.603864, -1.054327), -1.0);
		bool r_5 = brep.IsPointInOnFace(shape_5, Point3(0.169491, 0.796305, -0.965796), -1.0);
		bool r_6 = brep.IsPointInOnFace(shape_6, Point3(1.633739, 2.302035, 1.260379), -1.0);
		CHECK(s_sahpe1 == Approx(9.0).margin(1e-12));
		CHECK(s_sahpe2 == Approx(9.0).margin(1e-12));
		CHECK(s_sahpe3 == Approx(9.0).margin(1e-12));
		CHECK(s_sahpe4 == Approx(9.0).margin(1e-12));
		CHECK(s_sahpe5 == Approx(9.0).margin(1e-12)); 
		CHECK(s_sahpe6 == Approx(9.0).margin(1e-12));
		CHECK(v_sahpe == Approx(27.0).margin(1e-12));
		CHECK(s_sahpe == s_sahpe1 + s_sahpe2 + s_sahpe3 + s_sahpe4 + s_sahpe5 + s_sahpe6);
		CHECK(s_sahpe1 == s_shape_1);
		CHECK(s_sahpe2 == s_shape_2);
		CHECK(s_sahpe3 == s_shape_3);
		CHECK(s_sahpe4 == s_shape_4);
		CHECK(s_sahpe5 == s_shape_5);
		CHECK(s_sahpe6 == s_shape_6);
		CHECK(r1 == true);
		CHECK(r2 == true);
		CHECK(r3 == true);
		CHECK(r33 == false);
		CHECK(r4 == true);
		CHECK(r5 == true);
		CHECK(r6 == true);
		CHECK(r_1 == true);
		CHECK(r_2 == true);
		CHECK(r_3 == true);
		CHECK(r_33 == false);
		CHECK(r_4 == true);
		CHECK(r_5 == true);
		CHECK(r_6 == true);
		CHECK(OCCTIO::OCCTTool::Write(box2, outdir + "MakeBox4.brep"));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API const TopoFace& XMinFace()	 @return The X-min face
	 @brief Get the face on X minimum
,
 "output":#include <modeling/MakeBox.hpp>
#include<catch.hpp>
#include<testHelper.h>
#include <modeling/MakeBox.hpp>
#include <modeling/MakeCylinder.hpp>
#include <topology/BRepExtremaProximityTool.hpp>
#include <io/OBJTool.hpp>
#include <topology/TopoFace.hpp>
#include <modeling/TransformShape.hpp>
#include <topology/TopoExplorerTool.hpp>
#include <modeling/MakeTorus.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
using namespace AMCAX;
#include <modeling/MakeBox.hpp>
#include<catch.hpp>
#include<testHelper.h>
#include <modeling/MakeBox.hpp>
#include <modeling/MakeCylinder.hpp>
#include <topology/BRepExtremaProximityTool.hpp>
#include <io/OBJTool.hpp>
#include <topology/TopoFace.hpp>
#include <modeling/TransformShape.hpp>
#include <topology/TopoExplorerTool.hpp>
#include <modeling/MakeTorus.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
using namespace AMCAX;
;
	SECTION("Box1") {
		OUTPUT_DIRECTORY(topology, OverlapFaces);
		MakeBox box(3.0, 2.0,2.0);
		TopoShape box2= box.Shape();
		box.Init(4.0, 5.0, 6.0);
		TopoFace shape = box.XMinFace(); 
		TopoFace shape1 = box.ZMinFace(); 
		TopoShape shape2 = box; 
		TopoShape shapeV = box;
		AMCAX::GlobalProperty prop1;
		double s_sahpe = GetSurfaceProperties(shape, prop1, true, false);
		double s_sahpe1 = GetSurfaceProperties(shape1, prop1, true, false);
		double s_sahpe2 = GetSurfaceProperties(shape2, prop1, true, false);
		double v_sahpe = GetVolumeProperties(shapeV, prop1, true, false);
		CHECK(s_sahpe == Approx(30.0).margin(1e-12));
		CHECK(s_sahpe1 == Approx(20.0).margin(1e-12));
		CHECK(s_sahpe2 == Approx(148.0).margin(1e-12));
		CHECK(v_sahpe == Approx(120.0).margin(1e-12));
		CHECK( OCCTIO::OCCTTool::Write(box, outdir + "MakeBox1.brep"));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API const TopoFace& YMinFace()	 @return The Y-min face
	 @brief Get the face on Y minimum
,
 "output":#include <modeling/MakeBox.hpp>
#include<catch.hpp>
#include<testHelper.h>
#include <modeling/MakeBox.hpp>
#include <modeling/MakeCylinder.hpp>
#include <topology/BRepExtremaProximityTool.hpp>
#include <io/OBJTool.hpp>
#include <topology/TopoFace.hpp>
#include <modeling/TransformShape.hpp>
#include <topology/TopoExplorerTool.hpp>
#include <modeling/MakeTorus.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
using namespace AMCAX;
#include <modeling/MakeBox.hpp>
#include<catch.hpp>
#include<testHelper.h>
#include <modeling/MakeBox.hpp>
#include <modeling/MakeCylinder.hpp>
#include <topology/BRepExtremaProximityTool.hpp>
#include <io/OBJTool.hpp>
#include <topology/TopoFace.hpp>
#include <modeling/TransformShape.hpp>
#include <topology/TopoExplorerTool.hpp>
#include <modeling/MakeTorus.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
using namespace AMCAX;
;
	SECTION("Box2") 
	{
		OUTPUT_DIRECTORY(topology, OverlapFaces);
		MakeBox box2(Point3(1.0, 1.0, 1.0), 3.0, 3.0, 3.0);
		MakeBox box3;
		box3.Init(Point3(1.0, 1.0, 1.0), 3.0, 3.0, 3.0);
		TopoFace shape1 = box2.XMinFace();
		TopoFace shape2 = box2.XMaxFace();
		TopoFace shape3 = box2.YMinFace();
		TopoFace shape4 = box2.YMaxFace();
		TopoFace shape5 = box2.ZMinFace();
		TopoFace shape6 = box2.ZMaxFace();
		TopoShape shape = box2;
		TopoFace shape_1 = box3.XMinFace();
		TopoFace shape_2 = box3.XMaxFace();
		TopoFace shape_3 = box3.YMinFace();
		TopoFace shape_4 = box3.YMaxFace();
		TopoFace shape_5 = box3.ZMinFace();
		TopoFace shape_6 = box3.ZMaxFace();
		AMCAX::GlobalProperty prop1;
		double s_sahpe1 = GetSurfaceProperties(shape1, prop1, true, false);
		double s_sahpe2 = GetSurfaceProperties(shape2, prop1, true, false);
		double s_sahpe3 = GetSurfaceProperties(shape3, prop1, true, false);
		double s_sahpe4 = GetSurfaceProperties(shape4, prop1, true, false);
		double s_sahpe5 = GetSurfaceProperties(shape5, prop1, true, false);
		double s_sahpe6 = GetSurfaceProperties(shape6, prop1, true, false);
		double s_sahpe  = GetSurfaceProperties(shape, prop1, true, false);
		double v_sahpe = GetVolumeProperties(shape, prop1, true, false);
		BRepClassificationTools brep;
		bool r1 = brep.IsPointInOnFace(shape1, Point3(1.0, 2.0, 2.0), -1.0);
		bool r2 = brep.IsPointInOnFace(shape2, Point3(4.0, 2.0, 2.0), -1.0);
		bool r3 = brep.IsPointInOnFace(shape3, Point3(2.0, 1.0, 2.0), -1.0);
		bool r33 = brep.IsPointInOnFace(shape3, Point3(0.0, 1.0, 0.5), -1.0);
		bool r4 = brep.IsPointInOnFace(shape4, Point3(2.0, 4.0, 2.0), -1.0);
		bool r5 = brep.IsPointInOnFace(shape5, Point3(2.0, 2.0, 1.0), -1.0);
		bool r6 = brep.IsPointInOnFace(shape6, Point3(2.0, 2.0, 4.0), -1.0);
		double s_shape_1 = GetSurfaceProperties(shape_1, prop1, true, false);
		double s_shape_2 = GetSurfaceProperties(shape_2, prop1, true, false);
		double s_shape_3 = GetSurfaceProperties(shape_3, prop1, true, false);
		double s_shape_4 = GetSurfaceProperties(shape_4, prop1, true, false);
		double s_shape_5 = GetSurfaceProperties(shape_5, prop1, true, false);
		double s_shape_6 = GetSurfaceProperties(shape_6, prop1, true, false);
		bool r_1 = brep.IsPointInOnFace(shape_1, Point3(1.0, 2.0, 2.0), -1.0);
		bool r_2 = brep.IsPointInOnFace(shape_2, Point3(4.0, 2.0, 2.0), -1.0);
		bool r_3 = brep.IsPointInOnFace(shape_3, Point3(2.0, 1.0, 2.0), -1.0);
		bool r_33 = brep.IsPointInOnFace(shape_3, Point3(0.0, 1.0, 0.5), -1.0);
		bool r_4 = brep.IsPointInOnFace(shape_4, Point3(2.0, 4.0, 2.0), -1.0);
		bool r_5 = brep.IsPointInOnFace(shape_5, Point3(2.0, 2.0, 1.0), -1.0);
		bool r_6 = brep.IsPointInOnFace(shape_6, Point3(2.0, 2.0, 4.0), -1.0);
		CHECK(s_sahpe1 == Approx(9.0).margin(1e-12));
		CHECK(s_sahpe2 == Approx(9.0).margin(1e-12));
		CHECK(s_sahpe3 == Approx(9.0).margin(1e-12));
		CHECK(s_sahpe4 == Approx(9.0).margin(1e-12));
		CHECK(s_sahpe5 == Approx(9.0).margin(1e-12));
		CHECK(s_sahpe6 == Approx(9.0).margin(1e-12));
		CHECK(v_sahpe == Approx(27.0).margin(1e-12));
		CHECK(s_sahpe  == s_sahpe1+ s_sahpe2+ s_sahpe3+s_sahpe4+s_sahpe5+s_sahpe6);
		CHECK(s_sahpe1 == s_shape_1);
		CHECK(s_sahpe2 == s_shape_2);
		CHECK(s_sahpe3 == s_shape_3);
		CHECK(s_sahpe4 == s_shape_4);
		CHECK(s_sahpe5 == s_shape_5);
		CHECK(s_sahpe6 == s_shape_6);
		CHECK(r1 == true);
		CHECK(r2 == true);
		CHECK(r3 == true);
		CHECK(r33 == false);
		CHECK(r4 == true);
		CHECK(r5 == true);
		CHECK(r6 == true);
		CHECK(r_1 == true);
		CHECK(r_2 == true);
		CHECK(r_3 == true);
		CHECK(r_33 == false);
		CHECK(r_4 == true);
		CHECK(r_5 == true);
		CHECK(r_6 == true);
		CHECK(OCCTIO::OCCTTool::Write(box2, outdir + "MakeBox2.brep"));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API const TopoFace& ZMinFace()	 @return The Z-min face
	 @brief Get the face on Z minimum
,
 "output":#include <modeling/MakeBox.hpp>
#include<catch.hpp>
#include<testHelper.h>
#include <modeling/MakeBox.hpp>
#include <modeling/MakeCylinder.hpp>
#include <topology/BRepExtremaProximityTool.hpp>
#include <io/OBJTool.hpp>
#include <topology/TopoFace.hpp>
#include <modeling/TransformShape.hpp>
#include <topology/TopoExplorerTool.hpp>
#include <modeling/MakeTorus.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
using namespace AMCAX;
#include <modeling/MakeBox.hpp>
#include<catch.hpp>
#include<testHelper.h>
#include <modeling/MakeBox.hpp>
#include <modeling/MakeCylinder.hpp>
#include <topology/BRepExtremaProximityTool.hpp>
#include <io/OBJTool.hpp>
#include <topology/TopoFace.hpp>
#include <modeling/TransformShape.hpp>
#include <topology/TopoExplorerTool.hpp>
#include <modeling/MakeTorus.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
using namespace AMCAX;
;
	SECTION("Box1") {
		OUTPUT_DIRECTORY(topology, OverlapFaces);
		MakeBox box(3.0, 2.0,2.0);
		TopoShape box2= box.Shape();
		box.Init(4.0, 5.0, 6.0);
		TopoFace shape = box.XMinFace(); 
		TopoFace shape1 = box.ZMinFace(); 
		TopoShape shape2 = box; 
		TopoShape shapeV = box;
		AMCAX::GlobalProperty prop1;
		double s_sahpe = GetSurfaceProperties(shape, prop1, true, false);
		double s_sahpe1 = GetSurfaceProperties(shape1, prop1, true, false);
		double s_sahpe2 = GetSurfaceProperties(shape2, prop1, true, false);
		double v_sahpe = GetVolumeProperties(shapeV, prop1, true, false);
		CHECK(s_sahpe == Approx(30.0).margin(1e-12));
		CHECK(s_sahpe1 == Approx(20.0).margin(1e-12));
		CHECK(s_sahpe2 == Approx(148.0).margin(1e-12));
		CHECK(v_sahpe == Approx(120.0).margin(1e-12));
		CHECK( OCCTIO::OCCTTool::Write(box, outdir + "MakeBox1.brep"));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API MakeTorus(double r1, double r2)	 @param r2 The minor radius
	 @param r1 The major radius
	 @brief Construct from a major radius and a minor radius
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <modeling/MakeTorus.hpp>
#include <common/CartesianCoordinateSystem.hpp>
#include <topology/TopoBuilder.hpp>
TEST_CASE("bug1: MakeTorus   ", "[modeling][MakeTorus][P1][fixbug]")
{
	std::vector<TopoShape> shapes;
	constexpr double major = 3.0;
	constexpr double minor = 1.0;
	auto addshape = [&](double angle1, double angle2, double angle)
	{
		Frame3 frame(Point3(0.0, 0.0, static_cast<double>(shapes.size()) * 3.0), CartesianCoordinateSystem::DZ());
		shapes.push_back(MakeTorus(frame, major, minor, angle1, angle2, angle));
	};
	addshape(0.0, 2.0 * M_PI, 2.0 * M_PI);
	addshape(0.0, 2.0 * M_PI, M_PI_2);
	addshape(0.0, M_PI, 2.0 * M_PI);
	addshape(M_PI_2, 3.0 * M_PI_2, 2.0 * M_PI);
	addshape(M_PI, 2.0 * M_PI, 2.0 * M_PI);
	addshape(-M_PI_2, M_PI_2, 2.0 * M_PI);
	addshape(M_PI_4, M_PI_4 * 3, 2.0 * M_PI);
	addshape(M_PI_4 * 3, M_PI_4 * 5, 2.0 * M_PI);
	addshape(M_PI_4 * 5, M_PI_4 * 7, 2.0 * M_PI);
	addshape(-M_PI_4, M_PI_4, 2.0 * M_PI);
	addshape(0.0, M_PI_2, M_PI_2);
	TopoShape result;
	TopoBuilder b;
	b.MakeCompound(TopoCast::Compound(result));
	for (const auto& s : shapes)
	{
		b.Add(result, s);
	}
	CHECK( OCCTIO::OCCTTool::Write(result, OUTPUT_PATH_PREFIX"MakeTorus_bug445.brep"));
	AMCAX::GlobalProperty props1, props2;
	CHECK(GetSurfaceProperties(result, props1, true, false) == Approx(831.9798765859));
	CHECK(GetVolumeProperties(result, props2, true, false) == Approx(255.8996));
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API MakeTorus(double r1, double r2, double angle1, double angle2)	 @param angle2 The end angle
	 @param angle1 The start angle
	 @param r2 The minor radius
	 @param r1 The major radius
	 @brief Construct from a major radius, a minor radius and two angles that forms an arc of the section circle
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <modeling/MakeTorus.hpp>
#include <common/CartesianCoordinateSystem.hpp>
#include <topology/TopoBuilder.hpp>
TEST_CASE("bug1: MakeTorus   ", "[modeling][MakeTorus][P1][fixbug]")
{
	std::vector<TopoShape> shapes;
	constexpr double major = 3.0;
	constexpr double minor = 1.0;
	auto addshape = [&](double angle1, double angle2, double angle)
	{
		Frame3 frame(Point3(0.0, 0.0, static_cast<double>(shapes.size()) * 3.0), CartesianCoordinateSystem::DZ());
		shapes.push_back(MakeTorus(frame, major, minor, angle1, angle2, angle));
	};
	addshape(0.0, 2.0 * M_PI, 2.0 * M_PI);
	addshape(0.0, 2.0 * M_PI, M_PI_2);
	addshape(0.0, M_PI, 2.0 * M_PI);
	addshape(M_PI_2, 3.0 * M_PI_2, 2.0 * M_PI);
	addshape(M_PI, 2.0 * M_PI, 2.0 * M_PI);
	addshape(-M_PI_2, M_PI_2, 2.0 * M_PI);
	addshape(M_PI_4, M_PI_4 * 3, 2.0 * M_PI);
	addshape(M_PI_4 * 3, M_PI_4 * 5, 2.0 * M_PI);
	addshape(M_PI_4 * 5, M_PI_4 * 7, 2.0 * M_PI);
	addshape(-M_PI_4, M_PI_4, 2.0 * M_PI);
	addshape(0.0, M_PI_2, M_PI_2);
	TopoShape result;
	TopoBuilder b;
	b.MakeCompound(TopoCast::Compound(result));
	for (const auto& s : shapes)
	{
		b.Add(result, s);
	}
	CHECK( OCCTIO::OCCTTool::Write(result, OUTPUT_PATH_PREFIX"MakeTorus_bug445.brep"));
	AMCAX::GlobalProperty props1, props2;
	CHECK(GetSurfaceProperties(result, props1, true, false) == Approx(831.9798765859));
	CHECK(GetVolumeProperties(result, props2, true, false) == Approx(255.8996));
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API MakeTorus(double r1, double r2, double angle1, double angle2, double angle)	 @param angle The rotation angle
	 @param angle2 The end angle
	 @param angle1 The start angle
	 @param r2 The minor radius
	 @param r1 The major radius
	 @brief Construct from a major radius, a minor radius, two angles that forms an arc of the section circle and a rotation angle
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <modeling/MakeTorus.hpp>
#include <common/CartesianCoordinateSystem.hpp>
#include <topology/TopoBuilder.hpp>
TEST_CASE("bug1: MakeTorus   ", "[modeling][MakeTorus][P1][fixbug]")
{
	std::vector<TopoShape> shapes;
	constexpr double major = 3.0;
	constexpr double minor = 1.0;
	auto addshape = [&](double angle1, double angle2, double angle)
	{
		Frame3 frame(Point3(0.0, 0.0, static_cast<double>(shapes.size()) * 3.0), CartesianCoordinateSystem::DZ());
		shapes.push_back(MakeTorus(frame, major, minor, angle1, angle2, angle));
	};
	addshape(0.0, 2.0 * M_PI, 2.0 * M_PI);
	addshape(0.0, 2.0 * M_PI, M_PI_2);
	addshape(0.0, M_PI, 2.0 * M_PI);
	addshape(M_PI_2, 3.0 * M_PI_2, 2.0 * M_PI);
	addshape(M_PI, 2.0 * M_PI, 2.0 * M_PI);
	addshape(-M_PI_2, M_PI_2, 2.0 * M_PI);
	addshape(M_PI_4, M_PI_4 * 3, 2.0 * M_PI);
	addshape(M_PI_4 * 3, M_PI_4 * 5, 2.0 * M_PI);
	addshape(M_PI_4 * 5, M_PI_4 * 7, 2.0 * M_PI);
	addshape(-M_PI_4, M_PI_4, 2.0 * M_PI);
	addshape(0.0, M_PI_2, M_PI_2);
	TopoShape result;
	TopoBuilder b;
	b.MakeCompound(TopoCast::Compound(result));
	for (const auto& s : shapes)
	{
		b.Add(result, s);
	}
	CHECK( OCCTIO::OCCTTool::Write(result, OUTPUT_PATH_PREFIX"MakeTorus_bug445.brep"));
	AMCAX::GlobalProperty props1, props2;
	CHECK(GetSurfaceProperties(result, props1, true, false) == Approx(831.9798765859));
	CHECK(GetVolumeProperties(result, props2, true, false) == Approx(255.8996));
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API MakeTorus(const Frame3& frame, double r1, double r2, double angle1, double angle2)	 @param angle2 The end angle
	 @param angle1 The start angle
	 @param r2 The minor radius
	 @param r1 The major radius
	 @param frame The local coordinate system
	 @brief Construct from a local coordinate system, a major radius, a minor radius and two angles that forms an arc of the section circle
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <modeling/MakeTorus.hpp>
#include <common/CartesianCoordinateSystem.hpp>
#include <topology/TopoBuilder.hpp>
TEST_CASE("bug1: MakeTorus   ", "[modeling][MakeTorus][P1][fixbug]")
{
	std::vector<TopoShape> shapes;
	constexpr double major = 3.0;
	constexpr double minor = 1.0;
	auto addshape = [&](double angle1, double angle2, double angle)
	{
		Frame3 frame(Point3(0.0, 0.0, static_cast<double>(shapes.size()) * 3.0), CartesianCoordinateSystem::DZ());
		shapes.push_back(MakeTorus(frame, major, minor, angle1, angle2, angle));
	};
	addshape(0.0, 2.0 * M_PI, 2.0 * M_PI);
	addshape(0.0, 2.0 * M_PI, M_PI_2);
	addshape(0.0, M_PI, 2.0 * M_PI);
	addshape(M_PI_2, 3.0 * M_PI_2, 2.0 * M_PI);
	addshape(M_PI, 2.0 * M_PI, 2.0 * M_PI);
	addshape(-M_PI_2, M_PI_2, 2.0 * M_PI);
	addshape(M_PI_4, M_PI_4 * 3, 2.0 * M_PI);
	addshape(M_PI_4 * 3, M_PI_4 * 5, 2.0 * M_PI);
	addshape(M_PI_4 * 5, M_PI_4 * 7, 2.0 * M_PI);
	addshape(-M_PI_4, M_PI_4, 2.0 * M_PI);
	addshape(0.0, M_PI_2, M_PI_2);
	TopoShape result;
	TopoBuilder b;
	b.MakeCompound(TopoCast::Compound(result));
	for (const auto& s : shapes)
	{
		b.Add(result, s);
	}
	CHECK( OCCTIO::OCCTTool::Write(result, OUTPUT_PATH_PREFIX"MakeTorus_bug445.brep"));
	AMCAX::GlobalProperty props1, props2;
	CHECK(GetSurfaceProperties(result, props1, true, false) == Approx(831.9798765859));
	CHECK(GetVolumeProperties(result, props2, true, false) == Approx(255.8996));
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API MakeTorus(const Frame3& frame, double r1, double r2, double angle1, double angle2, double angle)	 @param angle The rotation angle
	 @param angle2 The end angle
	 @param angle1 The start angle
	 @param r2 The minor radius
	 @param r1 The major radius
	 @param frame The local coordinate system
	 @brief Construct from a local coordinate system, a major radius, a minor radius, two angles that forms an arc of the section circle and a rotation angle
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <modeling/MakeTorus.hpp>
#include <common/CartesianCoordinateSystem.hpp>
#include <topology/TopoBuilder.hpp>
TEST_CASE("bug1: MakeTorus   ", "[modeling][MakeTorus][P1][fixbug]")
{
	std::vector<TopoShape> shapes;
	constexpr double major = 3.0;
	constexpr double minor = 1.0;
	auto addshape = [&](double angle1, double angle2, double angle)
	{
		Frame3 frame(Point3(0.0, 0.0, static_cast<double>(shapes.size()) * 3.0), CartesianCoordinateSystem::DZ());
		shapes.push_back(MakeTorus(frame, major, minor, angle1, angle2, angle));
	};
	addshape(0.0, 2.0 * M_PI, 2.0 * M_PI);
	addshape(0.0, 2.0 * M_PI, M_PI_2);
	addshape(0.0, M_PI, 2.0 * M_PI);
	addshape(M_PI_2, 3.0 * M_PI_2, 2.0 * M_PI);
	addshape(M_PI, 2.0 * M_PI, 2.0 * M_PI);
	addshape(-M_PI_2, M_PI_2, 2.0 * M_PI);
	addshape(M_PI_4, M_PI_4 * 3, 2.0 * M_PI);
	addshape(M_PI_4 * 3, M_PI_4 * 5, 2.0 * M_PI);
	addshape(M_PI_4 * 5, M_PI_4 * 7, 2.0 * M_PI);
	addshape(-M_PI_4, M_PI_4, 2.0 * M_PI);
	addshape(0.0, M_PI_2, M_PI_2);
	TopoShape result;
	TopoBuilder b;
	b.MakeCompound(TopoCast::Compound(result));
	for (const auto& s : shapes)
	{
		b.Add(result, s);
	}
	CHECK( OCCTIO::OCCTTool::Write(result, OUTPUT_PATH_PREFIX"MakeTorus_bug445.brep"));
	AMCAX::GlobalProperty props1, props2;
	CHECK(GetSurfaceProperties(result, props1, true, false) == Approx(831.9798765859));
	CHECK(GetVolumeProperties(result, props2, true, false) == Approx(255.8996));
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API MakePolygon(const Point3& p1, const Point3& p2)	 @param p2 The second point
	 @param p1 The first point
	 @brief Construct from two points
,
 "output":#include<catch.hpp>
#include<iostream>
#include <modeling/MakePolygon.hpp>
#include <topology/TopoVertex.hpp>
#include <topology/TopoEdge.hpp>
#include <topology/TopoExplorerTool.hpp>
#include <topology/TopoShape.hpp>
#include <topology/TopoTool.hpp>
TEST_CASE("void AMCAX::MakePolygon::Add(const Point3 & p) - case1 add valid 3D point", "[modeling][MakePolygon][P1]") {
        AMCAX::Point3 p1(1.0, 2.0, 3.0);
        AMCAX::Point3 p2(4.1, 5.1, 6.1);
        AMCAX::MakePolygon polygon(p1, p2);
        bool lastAdded1 = polygon.Added();
        CHECK(lastAdded1 == true);
        const AMCAX::TopoEdge &lastEdge = polygon.Edge();
        CHECK(lastEdge.IsNull() == false);
        CHECK(lastEdge.NChildren() == 2);
        CHECK(lastEdge.Type() == AMCAX::ShapeType::Edge);
        AMCAX::TopoVertex v1,v2;
        AMCAX::TopoExplorerTool::Vertices(lastEdge, v1, v2,false);
        CHECK_FALSE(v1.IsNull());
        CHECK_FALSE(v2.IsNull());
        CHECK(v1.Type() == AMCAX::ShapeType::Vertex);
        CHECK(v2.Type() == AMCAX::ShapeType::Vertex);
        AMCAX::Point3 vpoint1;
        vpoint1 = AMCAX::TopoTool::Point(v1);
        CHECK(vpoint1.X() == 1.0);
        CHECK(vpoint1.Y() == 2.0);
        CHECK(vpoint1.Z() == 3.0);
        AMCAX::Point3 p3(4.1, 5.1, 6.1);
        polygon.Add(p3);
        bool lastAdded2 = polygon.Added();
        CHECK(lastAdded2 == false);
        AMCAX::Point3 p4(7.0, 8.0, 9.0);
        polygon.Add(p4);
        bool lastAdded3 = polygon.Added();
        CHECK(lastAdded3 == true);
}
TEST_CASE("MakePolygon Invalid input points", "[modeling][MakePolygon][P3]") {
        AMCAX::Point3 p1(0.0, 0.0, 0.0);
        AMCAX::MakePolygon polygon(p1, p1);
        bool lastAdded = polygon.Added();
        CHECK(lastAdded == false);
    }
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API void Add(const Point3& p)	 @param p The point
	 @brief Add a new point to the polygon
,
 "output":#include<catch.hpp>
#include<iostream>
#include <modeling/MakePolygon.hpp>
#include <topology/TopoVertex.hpp>
#include <topology/TopoEdge.hpp>
#include <topology/TopoExplorerTool.hpp>
#include <topology/TopoShape.hpp>
#include <topology/TopoTool.hpp>
TEST_CASE("void AMCAX::MakePolygon::Add(const Point3 & p) - case1 add valid 3D point", "[modeling][MakePolygon][P1]") {
        AMCAX::Point3 p1(1.0, 2.0, 3.0);
        AMCAX::Point3 p2(4.1, 5.1, 6.1);
        AMCAX::MakePolygon polygon(p1, p2);
        bool lastAdded1 = polygon.Added();
        CHECK(lastAdded1 == true);
        const AMCAX::TopoEdge &lastEdge = polygon.Edge();
        CHECK(lastEdge.IsNull() == false);
        CHECK(lastEdge.NChildren() == 2);
        CHECK(lastEdge.Type() == AMCAX::ShapeType::Edge);
        AMCAX::TopoVertex v1,v2;
        AMCAX::TopoExplorerTool::Vertices(lastEdge, v1, v2,false);
        CHECK_FALSE(v1.IsNull());
        CHECK_FALSE(v2.IsNull());
        CHECK(v1.Type() == AMCAX::ShapeType::Vertex);
        CHECK(v2.Type() == AMCAX::ShapeType::Vertex);
        AMCAX::Point3 vpoint1;
        vpoint1 = AMCAX::TopoTool::Point(v1);
        CHECK(vpoint1.X() == 1.0);
        CHECK(vpoint1.Y() == 2.0);
        CHECK(vpoint1.Z() == 3.0);
        AMCAX::Point3 p3(4.1, 5.1, 6.1);
        polygon.Add(p3);
        bool lastAdded2 = polygon.Added();
        CHECK(lastAdded2 == false);
        AMCAX::Point3 p4(7.0, 8.0, 9.0);
        polygon.Add(p4);
        bool lastAdded3 = polygon.Added();
        CHECK(lastAdded3 == true);
}
#include<catch.hpp>
#include<iostream>
#include <modeling/MakePolygon.hpp>
#include <topology/TopoVertex.hpp>
#include <topology/TopoEdge.hpp>
#include <topology/TopoExplorerTool.hpp>
#include <topology/TopoShape.hpp>
#include <topology/TopoTool.hpp>
TEST_CASE("void AMCAX::MakePolygon::Add(const Point3 & p) - case1 add valid 3D point", "[modeling][MakePolygon][P1]") {
        AMCAX::Point3 p1(1.0, 2.0, 3.0);
        AMCAX::Point3 p2(4.1, 5.1, 6.1);
        AMCAX::MakePolygon polygon(p1, p2);
        bool lastAdded1 = polygon.Added();
        CHECK(lastAdded1 == true);
        const AMCAX::TopoEdge &lastEdge = polygon.Edge();
        CHECK(lastEdge.IsNull() == false);
        CHECK(lastEdge.NChildren() == 2);
        CHECK(lastEdge.Type() == AMCAX::ShapeType::Edge);
        AMCAX::TopoVertex v1,v2;
        AMCAX::TopoExplorerTool::Vertices(lastEdge, v1, v2,false);
        CHECK_FALSE(v1.IsNull());
        CHECK_FALSE(v2.IsNull());
        CHECK(v1.Type() == AMCAX::ShapeType::Vertex);
        CHECK(v2.Type() == AMCAX::ShapeType::Vertex);
        AMCAX::Point3 vpoint1;
        vpoint1 = AMCAX::TopoTool::Point(v1);
        CHECK(vpoint1.X() == 1.0);
        CHECK(vpoint1.Y() == 2.0);
        CHECK(vpoint1.Z() == 3.0);
        AMCAX::Point3 p3(4.1, 5.1, 6.1);
        polygon.Add(p3);
        bool lastAdded2 = polygon.Added();
        CHECK(lastAdded2 == false);
        AMCAX::Point3 p4(7.0, 8.0, 9.0);
        polygon.Add(p4);
        bool lastAdded3 = polygon.Added();
        CHECK(lastAdded3 == true);
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API MakePyramid(const Point3& p1, const Point3& p2, const Point3& p3, const Point3& apex)	 @param apex Apex point
	 @param p1,p2,p3 Points on the base plane
	 @brief Construct a tetrahedron
,
 "output":SECTION("baseLocationP and  p1 is same") {
        Point3 baseLocationP(-1.0, 0.0, 0.0);
        Point3 p1(0.0, 0.0, 0.0);
        Point3 p2(3.0, 0.0, 0.0);
        Point3 p3(1.0, -1.0, -10.0);
        Point3 apex(1., 2., 5.);
        std::vector<Point3> basepoints = { p1,p2,p3 };
        CHECK_THROWS_AS(AMCAX::MakePyramid(baseLocationP, basepoints, apex), AMCAX::_ConstructionError);
    ;
	SECTION("apex in the bottom face  ")
    {
        Point3 apex(0.0, 0.0, 0.0);
        std::vector<Point3> points = { p1, p2, p3,p4,apex };
        TopoShape shape = AMCAX::MakePyramid(p1, p2, p3, p4, apex);
        AMCAX::GlobalProperty props;
        CHECK(GetSurfaceProperties(shape, props, true, false) == Approx(30.0));
        CHECK(GetVolumeProperties(shape, props, true, false) == Approx(0.0));
        CHECK(shape.Type() == ShapeType::Solid);
        OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX"MakePyramid2_case03.brep");
        TopoSolid solid = AMCAX::TopoCast::Solid(shape);
        for (const Point3& p : points) {
            bool isPointOnSolid = AMCAX::BRepClassificationTools::IsPointInOnSolid(solid, p);
            CHECK(isPointOnSolid == true);
        }
    }}
SECTION("baseLocationP and  p1 is same") {
        Point3 baseLocationP(-1.0, 0.0, 0.0);
        Point3 p1(0.0, 0.0, 0.0);
        Point3 p2(3.0, 0.0, 0.0);
        Point3 p3(1.0, -1.0, -10.0);
        Point3 apex(1., 2., 5.);
        std::vector<Point3> basepoints = { p1,p2,p3 };
        CHECK_THROWS_AS(AMCAX::MakePyramid(baseLocationP, basepoints, apex), AMCAX::_ConstructionError);
    ;
	SECTION("radius = 0") {
        radius = 0.0;
        CHECK_THROWS_AS( AMCAX::MakePyramid(fram3, radius, nside, height),AMCAX::_ConstructionError );
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API MakePyramid(const Point3& p1, const Point3& p2, const Point3& p3, const Point3& p4, const Point3& apex)	 @param apex Apex point
	 @param p1,p2,p3,p4 Points on the base plane
	 @brief Construct a quadrilateral pyramid
,
 "output":SECTION("baseLocationP and  p1 is same") {
        Point3 baseLocationP(-1.0, 0.0, 0.0);
        Point3 p1(0.0, 0.0, 0.0);
        Point3 p2(3.0, 0.0, 0.0);
        Point3 p3(1.0, -1.0, -10.0);
        Point3 apex(1., 2., 5.);
        std::vector<Point3> basepoints = { p1,p2,p3 };
        CHECK_THROWS_AS(AMCAX::MakePyramid(baseLocationP, basepoints, apex), AMCAX::_ConstructionError);
    ;
	SECTION("apex in the bottom face  ")
    {
        Point3 apex(0.0, 0.0, 0.0);
        std::vector<Point3> points = { p1, p2, p3,p4,apex };
        TopoShape shape = AMCAX::MakePyramid(p1, p2, p3, p4, apex);
        AMCAX::GlobalProperty props;
        CHECK(GetSurfaceProperties(shape, props, true, false) == Approx(30.0));
        CHECK(GetVolumeProperties(shape, props, true, false) == Approx(0.0));
        CHECK(shape.Type() == ShapeType::Solid);
        OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX"MakePyramid2_case03.brep");
        TopoSolid solid = AMCAX::TopoCast::Solid(shape);
        for (const Point3& p : points) {
            bool isPointOnSolid = AMCAX::BRepClassificationTools::IsPointInOnSolid(solid, p);
            CHECK(isPointOnSolid == true);
        }
    }}
SECTION("baseLocationP and  p1 is same") {
        Point3 baseLocationP(-1.0, 0.0, 0.0);
        Point3 p1(0.0, 0.0, 0.0);
        Point3 p2(3.0, 0.0, 0.0);
        Point3 p3(1.0, -1.0, -10.0);
        Point3 apex(1., 2., 5.);
        std::vector<Point3> basepoints = { p1,p2,p3 };
        CHECK_THROWS_AS(AMCAX::MakePyramid(baseLocationP, basepoints, apex), AMCAX::_ConstructionError);
    ;
	SECTION("apex in the bottom face  ")
    {
        Point3 apex(0.0, 0.0, 0.0);
        std::vector<Point3> points = { p1, p2, p3,p4,apex };
        TopoShape shape = AMCAX::MakePyramid(p1, p2, p3, p4, apex);
        AMCAX::GlobalProperty props;
        CHECK(GetSurfaceProperties(shape, props, true, false) == Approx(30.0));
        CHECK(GetVolumeProperties(shape, props, true, false) == Approx(0.0));
        CHECK(shape.Type() == ShapeType::Solid);
        OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX"MakePyramid2_case03.brep");
        TopoSolid solid = AMCAX::TopoCast::Solid(shape);
        for (const Point3& p : points) {
            bool isPointOnSolid = AMCAX::BRepClassificationTools::IsPointInOnSolid(solid, p);
            CHECK(isPointOnSolid == true);
        }
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API MakePyramid(const Frame3& frame, double radius, int nside, double height)	 @param height Height of the polygon
	 @param nside Number of sides of the base polygon
	 @param radius Radius of the circumcircle of the base polygon
	 @param frame The local coordinate system
	 @brief Construct a regular pyramid
,
 "output":SECTION("baseLocationP and  p1 is same") {
        Point3 baseLocationP(-1.0, 0.0, 0.0);
        Point3 p1(0.0, 0.0, 0.0);
        Point3 p2(3.0, 0.0, 0.0);
        Point3 p3(1.0, -1.0, -10.0);
        Point3 apex(1., 2., 5.);
        std::vector<Point3> basepoints = { p1,p2,p3 };
        CHECK_THROWS_AS(AMCAX::MakePyramid(baseLocationP, basepoints, apex), AMCAX::_ConstructionError);
    ;
	SECTION("apex in the bottom face  ")
    {
        Point3 apex(0.0, 0.0, 0.0);
        std::vector<Point3> points = { p1, p2, p3,p4,apex };
        TopoShape shape = AMCAX::MakePyramid(p1, p2, p3, p4, apex);
        AMCAX::GlobalProperty props;
        CHECK(GetSurfaceProperties(shape, props, true, false) == Approx(30.0));
        CHECK(GetVolumeProperties(shape, props, true, false) == Approx(0.0));
        CHECK(shape.Type() == ShapeType::Solid);
        OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX"MakePyramid2_case03.brep");
        TopoSolid solid = AMCAX::TopoCast::Solid(shape);
        for (const Point3& p : points) {
            bool isPointOnSolid = AMCAX::BRepClassificationTools::IsPointInOnSolid(solid, p);
            CHECK(isPointOnSolid == true);
        }
    }}
SECTION("baseLocationP and  p1 is same") {
        Point3 baseLocationP(-1.0, 0.0, 0.0);
        Point3 p1(0.0, 0.0, 0.0);
        Point3 p2(3.0, 0.0, 0.0);
        Point3 p3(1.0, -1.0, -10.0);
        Point3 apex(1., 2., 5.);
        std::vector<Point3> basepoints = { p1,p2,p3 };
        CHECK_THROWS_AS(AMCAX::MakePyramid(baseLocationP, basepoints, apex), AMCAX::_ConstructionError);
    ;
	SECTION("fram3(point3,Direct3)") {
        Point3 p(1.0, 1.0, 1.0);
        Direction3 dir3(1.0, 1.0, 1.0);
        Frame3 fram3(p, dir3);
        TopoShape shape = AMCAX::MakePyramid(fram3, radius, nside, height);
        AMCAX::GlobalProperty props;
        CHECK(GetSurfaceProperties(shape, props, true, false) == Approx(180.0870564616));
        CHECK(GetVolumeProperties(shape, props, true, false) == Approx(122.4552608943));
        CHECK(shape.Type() == ShapeType::Solid);
        CHECK(OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX"MakePyramid4_case03.brep"));
        TopoSolid solid = AMCAX::TopoCast::Solid(shape);
        Point3 p1(3.88675, 3.88675, 3.88675);
        Point3 p2(1.0, 1.0, 1.0);
        Point3 p3(3.46687, 0.807266, 3.44647);
        std::vector<Point3> points = { p1,p2,p3 };
        for (const Point3& p : points) {
            bool isPointOnSolid = AMCAX::BRepClassificationTools::IsPointInOnSolid(solid, p);
            CHECK(isPointOnSolid == true);
        }
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API MakePyramid(const Frame3& frame, const Point3& p1, const Point3& p2, const Point3& p3, const Point3& apex)	 @param apex Apex point
	 @param p1,p2,p3 Points that are projected onto the base plane
	 @param frame The frame of base plane
	 @brief Construct a tetrahedron with a given plane frame
,
 "output":SECTION("baseLocationP and  p1 is same") {
        Point3 baseLocationP(-1.0, 0.0, 0.0);
        Point3 p1(0.0, 0.0, 0.0);
        Point3 p2(3.0, 0.0, 0.0);
        Point3 p3(1.0, -1.0, -10.0);
        Point3 apex(1., 2., 5.);
        std::vector<Point3> basepoints = { p1,p2,p3 };
        CHECK_THROWS_AS(AMCAX::MakePyramid(baseLocationP, basepoints, apex), AMCAX::_ConstructionError);
    ;
	SECTION("apex in the bottom face  ")
    {
        Point3 apex(0.0, 0.0, 0.0);
        std::vector<Point3> points = { p1, p2, p3,p4,apex };
        TopoShape shape = AMCAX::MakePyramid(p1, p2, p3, p4, apex);
        AMCAX::GlobalProperty props;
        CHECK(GetSurfaceProperties(shape, props, true, false) == Approx(30.0));
        CHECK(GetVolumeProperties(shape, props, true, false) == Approx(0.0));
        CHECK(shape.Type() == ShapeType::Solid);
        OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX"MakePyramid2_case03.brep");
        TopoSolid solid = AMCAX::TopoCast::Solid(shape);
        for (const Point3& p : points) {
            bool isPointOnSolid = AMCAX::BRepClassificationTools::IsPointInOnSolid(solid, p);
            CHECK(isPointOnSolid == true);
        }
    }}
SECTION("baseLocationP and  p1 is same") {
        Point3 baseLocationP(-1.0, 0.0, 0.0);
        Point3 p1(0.0, 0.0, 0.0);
        Point3 p2(3.0, 0.0, 0.0);
        Point3 p3(1.0, -1.0, -10.0);
        Point3 apex(1., 2., 5.);
        std::vector<Point3> basepoints = { p1,p2,p3 };
        CHECK_THROWS_AS(AMCAX::MakePyramid(baseLocationP, basepoints, apex), AMCAX::_ConstructionError);
    ;
	SECTION("fram3(point3,Direct3)") {
        Point3 p(1.0, 1.0, 1.0);
        Direction3 dir3(1.0, 1.0, 1.0);
        Frame3 fram3(p, dir3);
        TopoShape shape = AMCAX::MakePyramid(fram3, radius, nside, height);
        AMCAX::GlobalProperty props;
        CHECK(GetSurfaceProperties(shape, props, true, false) == Approx(180.0870564616));
        CHECK(GetVolumeProperties(shape, props, true, false) == Approx(122.4552608943));
        CHECK(shape.Type() == ShapeType::Solid);
        CHECK(OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX"MakePyramid4_case03.brep"));
        TopoSolid solid = AMCAX::TopoCast::Solid(shape);
        Point3 p1(3.88675, 3.88675, 3.88675);
        Point3 p2(1.0, 1.0, 1.0);
        Point3 p3(3.46687, 0.807266, 3.44647);
        std::vector<Point3> points = { p1,p2,p3 };
        for (const Point3& p : points) {
            bool isPointOnSolid = AMCAX::BRepClassificationTools::IsPointInOnSolid(solid, p);
            CHECK(isPointOnSolid == true);
        }
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API MakePyramid(const Frame3& frame, const Point3& p1, const Point3& p2, const Point3& p3, const Point3& p4, const Point3& apex)	 @param apex Apex point
	 @param p1,p2,p3,p4 Points that are projected onto the base plane
	 @param frame The frame of base plane
	 @brief Construct a quadrilateral pyramid with a given plane frame
,
 "output":SECTION("baseLocationP and  p1 is same") {
        Point3 baseLocationP(-1.0, 0.0, 0.0);
        Point3 p1(0.0, 0.0, 0.0);
        Point3 p2(3.0, 0.0, 0.0);
        Point3 p3(1.0, -1.0, -10.0);
        Point3 apex(1., 2., 5.);
        std::vector<Point3> basepoints = { p1,p2,p3 };
        CHECK_THROWS_AS(AMCAX::MakePyramid(baseLocationP, basepoints, apex), AMCAX::_ConstructionError);
    ;
	SECTION("apex in the bottom face  ")
    {
        Point3 apex(0.0, 0.0, 0.0);
        std::vector<Point3> points = { p1, p2, p3,p4,apex };
        TopoShape shape = AMCAX::MakePyramid(p1, p2, p3, p4, apex);
        AMCAX::GlobalProperty props;
        CHECK(GetSurfaceProperties(shape, props, true, false) == Approx(30.0));
        CHECK(GetVolumeProperties(shape, props, true, false) == Approx(0.0));
        CHECK(shape.Type() == ShapeType::Solid);
        OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX"MakePyramid2_case03.brep");
        TopoSolid solid = AMCAX::TopoCast::Solid(shape);
        for (const Point3& p : points) {
            bool isPointOnSolid = AMCAX::BRepClassificationTools::IsPointInOnSolid(solid, p);
            CHECK(isPointOnSolid == true);
        }
    }}
SECTION("baseLocationP and  p1 is same") {
        Point3 baseLocationP(-1.0, 0.0, 0.0);
        Point3 p1(0.0, 0.0, 0.0);
        Point3 p2(3.0, 0.0, 0.0);
        Point3 p3(1.0, -1.0, -10.0);
        Point3 apex(1., 2., 5.);
        std::vector<Point3> basepoints = { p1,p2,p3 };
        CHECK_THROWS_AS(AMCAX::MakePyramid(baseLocationP, basepoints, apex), AMCAX::_ConstructionError);
    ;
	SECTION("4 points not on the XY. ") {
        Point3 p0(0.0, 0.0, 0.0);
        Direction3 dir3(0.0, 0.0, 1.0);
        Frame3 fram3(p0, dir3);
        Point3 p1(-1.0, 0.0, 0.0);
        Point3 p2(1.0,-4.0,-2.0);
        Point3 p3(2.0, 0.0, -1.0);
        Point3 p4(1., 3., -1.0);
        std::vector<Point3> points = { p1,p2,p3,p4 };
        Point3 apex(0., 0., 5.0);
        TopoShape shape = AMCAX::MakePyramid(fram3, p1, p2, p3,p4,apex);
        AMCAX::GlobalProperty props;
        CHECK(GetSurfaceProperties(shape, props, true, false) == Approx(50.5080895892));
        CHECK(GetVolumeProperties(shape, props, true, false) == Approx(17.5));
        Point3 p11(-1.0, 0.0, 0.0);
        Point3 p21(2.0, 0.0, 0.0);
        Point3 p31(1., 3., 0.0);
        Point3 p41(1., -4., 0.0);
        Point3 apex1(0., 0., 0.0);
        std::vector<Point3> points2 = { p11,p21,p31,p41,apex1 };
        CHECK(shape.Type() == ShapeType::Solid);
        CHECK(OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX"MakePyramid6_case01.brep"));
        TopoSolid solid = AMCAX::TopoCast::Solid(shape);
        for (const Point3& p : points2) {
            bool isPointOnSolid = AMCAX::BRepClassificationTools::IsPointInOnSolid(solid, p);
            CHECK(isPointOnSolid == true);
        }
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API MakePyramid(const Frame3& frame, const std::vector<Point3>& basepoints, const Point3& apex)	 @param apex Apex point
	 @param basepoints Points that are projected onto the base plane
	 @param frame The frame of base plane
	 @brief Construct a pyramid with a given base plane frame
,
 "output":SECTION("baseLocationP and  p1 is same") {
        Point3 baseLocationP(-1.0, 0.0, 0.0);
        Point3 p1(0.0, 0.0, 0.0);
        Point3 p2(3.0, 0.0, 0.0);
        Point3 p3(1.0, -1.0, -10.0);
        Point3 apex(1., 2., 5.);
        std::vector<Point3> basepoints = { p1,p2,p3 };
        CHECK_THROWS_AS(AMCAX::MakePyramid(baseLocationP, basepoints, apex), AMCAX::_ConstructionError);
    ;
	SECTION("apex in the bottom face  ")
    {
        Point3 apex(0.0, 0.0, 0.0);
        std::vector<Point3> points = { p1, p2, p3,p4,apex };
        TopoShape shape = AMCAX::MakePyramid(p1, p2, p3, p4, apex);
        AMCAX::GlobalProperty props;
        CHECK(GetSurfaceProperties(shape, props, true, false) == Approx(30.0));
        CHECK(GetVolumeProperties(shape, props, true, false) == Approx(0.0));
        CHECK(shape.Type() == ShapeType::Solid);
        OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX"MakePyramid2_case03.brep");
        TopoSolid solid = AMCAX::TopoCast::Solid(shape);
        for (const Point3& p : points) {
            bool isPointOnSolid = AMCAX::BRepClassificationTools::IsPointInOnSolid(solid, p);
            CHECK(isPointOnSolid == true);
        }
    }}
SECTION("baseLocationP and  p1 is same") {
        Point3 baseLocationP(-1.0, 0.0, 0.0);
        Point3 p1(0.0, 0.0, 0.0);
        Point3 p2(3.0, 0.0, 0.0);
        Point3 p3(1.0, -1.0, -10.0);
        Point3 apex(1., 2., 5.);
        std::vector<Point3> basepoints = { p1,p2,p3 };
        CHECK_THROWS_AS(AMCAX::MakePyramid(baseLocationP, basepoints, apex), AMCAX::_ConstructionError);
    ;
	SECTION("2 point is same in vector points") {
        Point3 p3(1.0, -3.0, 0.0);
        Point3 apex(5.0, 3.0, 4.5);
        std::vector<Point3> points = { p1, p2,p3 };
        CHECK_THROWS_AS(AMCAX::MakePyramid(points, apex), AMCAX::_ConstructionError);
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API MakePyramid(const Point3& baseLocation, const std::vector<Point3>& basepoints, const Point3& apex)	 @param apex Apex point
	 @param basepoints The base points that are projected onto the base plane
	 @param baseLocation The location of the base plane
	 @details The base plane are determined by the location point and the first two base points
	 @brief Construct a pyramid with a given location on the base plane
,
 "output":SECTION("baseLocationP and  p1 is same") {
        Point3 baseLocationP(-1.0, 0.0, 0.0);
        Point3 p1(0.0, 0.0, 0.0);
        Point3 p2(3.0, 0.0, 0.0);
        Point3 p3(1.0, -1.0, -10.0);
        Point3 apex(1., 2., 5.);
        std::vector<Point3> basepoints = { p1,p2,p3 };
        CHECK_THROWS_AS(AMCAX::MakePyramid(baseLocationP, basepoints, apex), AMCAX::_ConstructionError);
    ;
	SECTION("apex in the bottom face  ")
    {
        Point3 apex(0.0, 0.0, 0.0);
        std::vector<Point3> points = { p1, p2, p3,p4,apex };
        TopoShape shape = AMCAX::MakePyramid(p1, p2, p3, p4, apex);
        AMCAX::GlobalProperty props;
        CHECK(GetSurfaceProperties(shape, props, true, false) == Approx(30.0));
        CHECK(GetVolumeProperties(shape, props, true, false) == Approx(0.0));
        CHECK(shape.Type() == ShapeType::Solid);
        OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX"MakePyramid2_case03.brep");
        TopoSolid solid = AMCAX::TopoCast::Solid(shape);
        for (const Point3& p : points) {
            bool isPointOnSolid = AMCAX::BRepClassificationTools::IsPointInOnSolid(solid, p);
            CHECK(isPointOnSolid == true);
        }
    }}
SECTION("baseLocationP and  p1 is same") {
        Point3 baseLocationP(-1.0, 0.0, 0.0);
        Point3 p1(0.0, 0.0, 0.0);
        Point3 p2(3.0, 0.0, 0.0);
        Point3 p3(1.0, -1.0, -10.0);
        Point3 apex(1., 2., 5.);
        std::vector<Point3> basepoints = { p1,p2,p3 };
        CHECK_THROWS_AS(AMCAX::MakePyramid(baseLocationP, basepoints, apex), AMCAX::_ConstructionError);
    ;
	SECTION("2 point is same in vector points") {
        Point3 p3(1.0, -3.0, 0.0);
        Point3 apex(5.0, 3.0, 4.5);
        std::vector<Point3> points = { p1, p2,p3 };
        CHECK_THROWS_AS(AMCAX::MakePyramid(points, apex), AMCAX::_ConstructionError);
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API MakeRevol(const TopoShape& s, const Axis3& a, double d, bool copy = false)	 @param copy Whether copy the base shape
	 @param d The rotation angle
	 @param a The rotation axis
	 @param s The base shape
	 @brief Construct from a base shape, a rotation axis and a rotation angle
,
 "output":#include <catch.hpp>
#include<testHelper.h>
#include <modeling/MakeRevol.hpp>
#include <common/PointT.hpp>
#include <topology/TopoVertex.hpp>
#include <common/CartesianCoordinateSystem.hpp>
#include <occtio/OCCTTool.hpp>
#include <topology/TopoBuilder.hpp>
#include <modeling/MakeVertex.hpp>
#include <common/IndexSet.hpp>
#include <topology/TopoExplorerTool.hpp>
#include <topology/TopoTool.hpp>
#include <topology/TopoCast.hpp>
using namespace AMCAX;
TEST_CASE("BUG1:create MakeRevol bug   ", "[modeling][MakeRevol][fixbug][P1]") {
	Point3 p(1.0, 0.0, 0.0);
	TopoVertex v0 = MakeVertex(p);
	TopoShape e = MakeRevol(v0, CartesianCoordinateSystem::OZ(), M_PI_2);
	TopoShape f = MakeRevol(e, CartesianCoordinateSystem::OX(), M_PI_2);
	IndexSet<TopoShape> vertices;
	TopoExplorerTool::MapShapes(f, ShapeType::Vertex, vertices);
	std::cout << TopoTool::Tolerance(TopoCast::Vertex(vertices[0])) << std::endl;
	CHECK(TopoTool::Tolerance(TopoCast::Vertex(vertices[0])) == 1e-07);
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API MakeRevol(const TopoShape& s, const Axis3& a, bool copy = false)	 @param copy Whether copy the base shape
	 @param a The rotation axis
	 @param s The base shape
	 @brief Construct from a base shape and a rotation axis
,
 "output":#include <catch.hpp>
#include<testHelper.h>
#include <modeling/MakeRevol.hpp>
#include <common/PointT.hpp>
#include <topology/TopoVertex.hpp>
#include <common/CartesianCoordinateSystem.hpp>
#include <occtio/OCCTTool.hpp>
#include <topology/TopoBuilder.hpp>
#include <modeling/MakeVertex.hpp>
#include <common/IndexSet.hpp>
#include <topology/TopoExplorerTool.hpp>
#include <topology/TopoTool.hpp>
#include <topology/TopoCast.hpp>
using namespace AMCAX;
TEST_CASE("BUG1:create MakeRevol bug   ", "[modeling][MakeRevol][fixbug][P1]") {
	Point3 p(1.0, 0.0, 0.0);
	TopoVertex v0 = MakeVertex(p);
	TopoShape e = MakeRevol(v0, CartesianCoordinateSystem::OZ(), M_PI_2);
	TopoShape f = MakeRevol(e, CartesianCoordinateSystem::OX(), M_PI_2);
	IndexSet<TopoShape> vertices;
	TopoExplorerTool::MapShapes(f, ShapeType::Vertex, vertices);
	std::cout << TopoTool::Tolerance(TopoCast::Vertex(vertices[0])) << std::endl;
	CHECK(TopoTool::Tolerance(TopoCast::Vertex(vertices[0])) == 1e-07);
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API MakeRightPrism(const Point3& p1, const Point3& p2, const Point3& p3, const Point3& apex)	 @param apex A point on the top plane
	 @param p1,p2,p3 Points on the base plane
	 @brief Construct a right triangular prism
,
 "output":SECTION("baseLocationP and  p1 is same") {
        Point3 baseLocationP(-1.0, 0.0, 0.0);
        Point3 p1(0.0, 0.0, 0.0);
        Point3 p2(3.0, 0.0, 0.0);
        Point3 p3(1.0, -1.0, -10.0);
        Point3 apex(1., 2., 5.);
        std::vector<Point3> basepoints = { p1,p2,p3 };
        CHECK_THROWS_AS(AMCAX::MakeRightPrism(baseLocationP, basepoints, apex), AMCAX::_ConstructionError);
    ;
	SECTION("p1=p2") {
        Point3 p1(-1.0, 0.0, 0.0);
        Point3 p2(-1.0, 0.0, 0.0);
        Point3 p3(2.0, 1.0, 0.0);
        Point3 p4(1.0, -1.0, 0.0);
        Point3 apex(2.0, 2.0, -4.5);
        std::vector<Point3> points = { p1, p2, p3,p4 };
        CHECK_THROWS_AS( AMCAX::MakeRightPrism(p1, p2, p3, p4, apex),AMCAX::_ConstructionError);
    }}
SECTION("baseLocationP and  p1 is same") {
        Point3 baseLocationP(-1.0, 0.0, 0.0);
        Point3 p1(0.0, 0.0, 0.0);
        Point3 p2(3.0, 0.0, 0.0);
        Point3 p3(1.0, -1.0, -10.0);
        Point3 apex(1., 2., 5.);
        std::vector<Point3> basepoints = { p1,p2,p3 };
        CHECK_THROWS_AS(AMCAX::MakeRightPrism(baseLocationP, basepoints, apex), AMCAX::_ConstructionError);
    ;
	SECTION("p1=p2") {
        Point3 p1(-1.0, 0.0, 0.0);
        Point3 p2(-1.0, 0.0, 0.0);
        Point3 p3(2.0, 1.0, 0.0);
        Point3 p4(1.0, -1.0, 0.0);
        Point3 apex(2.0, 2.0, -4.5);
        std::vector<Point3> points = { p1, p2, p3,p4 };
        CHECK_THROWS_AS( AMCAX::MakeRightPrism(p1, p2, p3, p4, apex),AMCAX::_ConstructionError);
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API MakeRightPrism(const Point3& p1, const Point3& p2, const Point3& p3, const Point3& p4, const Point3& apex)	 @param apex A point on the top plane
	 @param p1,p2,p3,p4 Points on the base plane
	 @brief Construct a right quadrilateral prism
,
 "output":SECTION("baseLocationP and  p1 is same") {
        Point3 baseLocationP(-1.0, 0.0, 0.0);
        Point3 p1(0.0, 0.0, 0.0);
        Point3 p2(3.0, 0.0, 0.0);
        Point3 p3(1.0, -1.0, -10.0);
        Point3 apex(1., 2., 5.);
        std::vector<Point3> basepoints = { p1,p2,p3 };
        CHECK_THROWS_AS(AMCAX::MakeRightPrism(baseLocationP, basepoints, apex), AMCAX::_ConstructionError);
    ;
	SECTION("p1=p2") {
        Point3 p1(-1.0, 0.0, 0.0);
        Point3 p2(-1.0, 0.0, 0.0);
        Point3 p3(2.0, 1.0, 0.0);
        Point3 p4(1.0, -1.0, 0.0);
        Point3 apex(2.0, 2.0, -4.5);
        std::vector<Point3> points = { p1, p2, p3,p4 };
        CHECK_THROWS_AS( AMCAX::MakeRightPrism(p1, p2, p3, p4, apex),AMCAX::_ConstructionError);
    }}
SECTION("baseLocationP and  p1 is same") {
        Point3 baseLocationP(-1.0, 0.0, 0.0);
        Point3 p1(0.0, 0.0, 0.0);
        Point3 p2(3.0, 0.0, 0.0);
        Point3 p3(1.0, -1.0, -10.0);
        Point3 apex(1., 2., 5.);
        std::vector<Point3> basepoints = { p1,p2,p3 };
        CHECK_THROWS_AS(AMCAX::MakeRightPrism(baseLocationP, basepoints, apex), AMCAX::_ConstructionError);
    ;
	SECTION("p1=p2") {
        Point3 p1(-1.0, 0.0, 0.0);
        Point3 p2(-1.0, 0.0, 0.0);
        Point3 p3(2.0, 1.0, 0.0);
        Point3 p4(1.0, -1.0, 0.0);
        Point3 apex(2.0, 2.0, -4.5);
        std::vector<Point3> points = { p1, p2, p3,p4 };
        CHECK_THROWS_AS( AMCAX::MakeRightPrism(p1, p2, p3, p4, apex),AMCAX::_ConstructionError);
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API MakeRightPrism(const std::vector<Point3>& basepoints, const Point3& apex)	 @param apex A point on the top plane
	 @param basepoints Points on the base plane
	 @brief Construct a right prism with base points and a point on the top plane
,
 "output":SECTION("baseLocationP and  p1 is same") {
        Point3 baseLocationP(-1.0, 0.0, 0.0);
        Point3 p1(0.0, 0.0, 0.0);
        Point3 p2(3.0, 0.0, 0.0);
        Point3 p3(1.0, -1.0, -10.0);
        Point3 apex(1., 2., 5.);
        std::vector<Point3> basepoints = { p1,p2,p3 };
        CHECK_THROWS_AS(AMCAX::MakeRightPrism(baseLocationP, basepoints, apex), AMCAX::_ConstructionError);
    ;
	SECTION("p1=p2") {
        Point3 p1(-1.0, 0.0, 0.0);
        Point3 p2(-1.0, 0.0, 0.0);
        Point3 p3(2.0, 1.0, 0.0);
        Point3 p4(1.0, -1.0, 0.0);
        Point3 apex(2.0, 2.0, -4.5);
        std::vector<Point3> points = { p1, p2, p3,p4 };
        CHECK_THROWS_AS( AMCAX::MakeRightPrism(p1, p2, p3, p4, apex),AMCAX::_ConstructionError);
    }}
SECTION("baseLocationP and  p1 is same") {
        Point3 baseLocationP(-1.0, 0.0, 0.0);
        Point3 p1(0.0, 0.0, 0.0);
        Point3 p2(3.0, 0.0, 0.0);
        Point3 p3(1.0, -1.0, -10.0);
        Point3 apex(1., 2., 5.);
        std::vector<Point3> basepoints = { p1,p2,p3 };
        CHECK_THROWS_AS(AMCAX::MakeRightPrism(baseLocationP, basepoints, apex), AMCAX::_ConstructionError);
    ;
	SECTION("4 points not on the XY. ") {
        Point3 p0(0.0, 0.0, 0.0);
        Direction3 dir3(0.0, 0.0, 1.0);
        Frame3 fram3(p0, dir3);
        Point3 p1(-1.0, 0.0, 0.0);
        Point3 p2(1.0, -4.0, -2.0);
        Point3 p3(2.0, 0.0, -1.0);
        Point3 p4(1., 3., -1.0);
        std::vector<Point3> basepoints = { p1,p2,p3,p4 };
        Point3 apex(0., 0., 5.0);
        TopoShape shape = AMCAX::MakeRightPrism(fram3, basepoints, apex);
        AMCAX::GlobalProperty props;
        CHECK(GetSurfaceProperties(shape, props, true, false) == Approx(97.8153525812));
        CHECK(GetVolumeProperties(shape, props, true, false) == Approx(52.5));
        Point3 p11(-1.0, 0.0, 0.0);
        Point3 p21(2.0, 0.0, 0.0);
        Point3 p31(1., 3., 0.0);
        Point3 p41(1., -4., 0.0);
        Point3 apex1(0., 0., 0.0);
        std::vector<Point3> points2 = { p11,p21,p31,p41,apex1 };
        CHECK(shape.Type() == ShapeType::Solid);
        CHECK(OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX"MakeRightPrism7_case01.brep"));
        TopoSolid solid = AMCAX::TopoCast::Solid(shape);
        for (const Point3& p : points2) {
            bool isPointOnSolid = AMCAX::BRepClassificationTools::IsPointInOnSolid(solid, p);
            CHECK(isPointOnSolid == true);
        }
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API MakeRightPrism(const Frame3& frame, double radius, int nside, double height)	 @param height Height of the polygon
	 @param nside Number of sides of the base polygon
	 @param radius Radius of the circumcircle of the base polygon
	 @param frame The local coordinate system
	 @brief Construct a right regular prism
,
 "output":SECTION("baseLocationP and  p1 is same") {
        Point3 baseLocationP(-1.0, 0.0, 0.0);
        Point3 p1(0.0, 0.0, 0.0);
        Point3 p2(3.0, 0.0, 0.0);
        Point3 p3(1.0, -1.0, -10.0);
        Point3 apex(1., 2., 5.);
        std::vector<Point3> basepoints = { p1,p2,p3 };
        CHECK_THROWS_AS(AMCAX::MakeRightPrism(baseLocationP, basepoints, apex), AMCAX::_ConstructionError);
    ;
	SECTION("p1=p2") {
        Point3 p1(-1.0, 0.0, 0.0);
        Point3 p2(-1.0, 0.0, 0.0);
        Point3 p3(2.0, 1.0, 0.0);
        Point3 p4(1.0, -1.0, 0.0);
        Point3 apex(2.0, 2.0, -4.5);
        std::vector<Point3> points = { p1, p2, p3,p4 };
        CHECK_THROWS_AS( AMCAX::MakeRightPrism(p1, p2, p3, p4, apex),AMCAX::_ConstructionError);
    }}
SECTION("baseLocationP and  p1 is same") {
        Point3 baseLocationP(-1.0, 0.0, 0.0);
        Point3 p1(0.0, 0.0, 0.0);
        Point3 p2(3.0, 0.0, 0.0);
        Point3 p3(1.0, -1.0, -10.0);
        Point3 apex(1., 2., 5.);
        std::vector<Point3> basepoints = { p1,p2,p3 };
        CHECK_THROWS_AS(AMCAX::MakeRightPrism(baseLocationP, basepoints, apex), AMCAX::_ConstructionError);
    ;
	SECTION("default fram3") {
        TopoShape shape = AMCAX::MakeRightPrism(fram3, radius, nside, height);
        AMCAX::GlobalProperty props;
        CHECK(GetSurfaceProperties(shape, props, true, false) == Approx(301.4548102606));
        CHECK(GetVolumeProperties(shape, props, true, false) == Approx(367.3657826828));
        CHECK(shape.Type() == ShapeType::Solid);
        OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX"MakeRightPrism4_01.brep");
        TopoSolid solid = AMCAX::TopoCast::Solid(shape);
        Point3 p1(0.0, 0.0, 0.0);
        Point3 p2(4.04508, -2.93893, 5.0);
        Point3 p3(-1.54508, 4.75528, 0.);
        Point3 p4(-4.045085, -2.938926, 2.837605);
        std::vector<Point3> points = { p1,p2,p3,p4 };
        for (const Point3& p : points) {
            bool isPointOnSolid = AMCAX::BRepClassificationTools::IsPointInOnSolid(solid, p);
            CHECK(isPointOnSolid == true);
        }
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API MakeRightPrism(const Frame3& frame, const Point3& p1, const Point3& p2, const Point3& p3, const Point3& apex)	 @param apex A point on the top plane
	 @param p1,p2,p3 Points that are projected onto the base plane
	 @param frame The frame of base plane
	 @brief Construct a right triangular prism with a given plane frame
,
 "output":SECTION("baseLocationP and  p1 is same") {
        Point3 baseLocationP(-1.0, 0.0, 0.0);
        Point3 p1(0.0, 0.0, 0.0);
        Point3 p2(3.0, 0.0, 0.0);
        Point3 p3(1.0, -1.0, -10.0);
        Point3 apex(1., 2., 5.);
        std::vector<Point3> basepoints = { p1,p2,p3 };
        CHECK_THROWS_AS(AMCAX::MakeRightPrism(baseLocationP, basepoints, apex), AMCAX::_ConstructionError);
    ;
	SECTION("p1=p2") {
        Point3 p1(-1.0, 0.0, 0.0);
        Point3 p2(-1.0, 0.0, 0.0);
        Point3 p3(2.0, 1.0, 0.0);
        Point3 p4(1.0, -1.0, 0.0);
        Point3 apex(2.0, 2.0, -4.5);
        std::vector<Point3> points = { p1, p2, p3,p4 };
        CHECK_THROWS_AS( AMCAX::MakeRightPrism(p1, p2, p3, p4, apex),AMCAX::_ConstructionError);
    }}
SECTION("baseLocationP and  p1 is same") {
        Point3 baseLocationP(-1.0, 0.0, 0.0);
        Point3 p1(0.0, 0.0, 0.0);
        Point3 p2(3.0, 0.0, 0.0);
        Point3 p3(1.0, -1.0, -10.0);
        Point3 apex(1., 2., 5.);
        std::vector<Point3> basepoints = { p1,p2,p3 };
        CHECK_THROWS_AS(AMCAX::MakeRightPrism(baseLocationP, basepoints, apex), AMCAX::_ConstructionError);
    ;
	SECTION("p1=p2") {
        Point3 p1(-1.0, 0.0, 0.0);
        Point3 p2(-1.0, 0.0, 0.0);
        Point3 p3(2.0, 1.0, 0.0);
        Point3 p4(1.0, -1.0, 0.0);
        Point3 apex(2.0, 2.0, -4.5);
        std::vector<Point3> points = { p1, p2, p3,p4 };
        CHECK_THROWS_AS( AMCAX::MakeRightPrism(p1, p2, p3, p4, apex),AMCAX::_ConstructionError);
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API MakeRightPrism(const Frame3& frame, const Point3& p1, const Point3& p2, const Point3& p3, const Point3& p4, const Point3& apex)	 @param apex A point on the top plane
	 @param p1,p2,p3,p4 Points that are projected onto the base plane
	 @param frame The frame of base plane
	 @brief Construct a right quadrilateral prism with a given plane frame
,
 "output":SECTION("baseLocationP and  p1 is same") {
        Point3 baseLocationP(-1.0, 0.0, 0.0);
        Point3 p1(0.0, 0.0, 0.0);
        Point3 p2(3.0, 0.0, 0.0);
        Point3 p3(1.0, -1.0, -10.0);
        Point3 apex(1., 2., 5.);
        std::vector<Point3> basepoints = { p1,p2,p3 };
        CHECK_THROWS_AS(AMCAX::MakeRightPrism(baseLocationP, basepoints, apex), AMCAX::_ConstructionError);
    ;
	SECTION("p1=p2") {
        Point3 p1(-1.0, 0.0, 0.0);
        Point3 p2(-1.0, 0.0, 0.0);
        Point3 p3(2.0, 1.0, 0.0);
        Point3 p4(1.0, -1.0, 0.0);
        Point3 apex(2.0, 2.0, -4.5);
        std::vector<Point3> points = { p1, p2, p3,p4 };
        CHECK_THROWS_AS( AMCAX::MakeRightPrism(p1, p2, p3, p4, apex),AMCAX::_ConstructionError);
    }}
SECTION("baseLocationP and  p1 is same") {
        Point3 baseLocationP(-1.0, 0.0, 0.0);
        Point3 p1(0.0, 0.0, 0.0);
        Point3 p2(3.0, 0.0, 0.0);
        Point3 p3(1.0, -1.0, -10.0);
        Point3 apex(1., 2., 5.);
        std::vector<Point3> basepoints = { p1,p2,p3 };
        CHECK_THROWS_AS(AMCAX::MakeRightPrism(baseLocationP, basepoints, apex), AMCAX::_ConstructionError);
    ;
	SECTION("4 points on same line") {
        Point3 p1(-1.0, 0.0, 0.0);
        Point3 p2(0.0, 0.0, 0.0);
        Point3 p3(2.0, 0.0, 0.0);
        Point3 p4(4.0, 0.0, 0.0);
        Point3 apex(2.0, 2.0, -4.5);
        std::vector<Point3> points = { p1, p2, p3,p4 };
        CHECK_THROWS_AS(AMCAX::MakeRightPrism(p1, p2, p3, p4, apex), AMCAX::_ConstructionError);
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API MakeRightPrism(const Frame3& frame, const std::vector<Point3>& basepoints, const Point3& apex)	 @param apex A point on the top plane
	 @param basepoints Points that are projected onto the base plane
	 @param frame The frame of base plane
	 @brief Construct a right prism with a given base plane frame
,
 "output":SECTION("baseLocationP and  p1 is same") {
        Point3 baseLocationP(-1.0, 0.0, 0.0);
        Point3 p1(0.0, 0.0, 0.0);
        Point3 p2(3.0, 0.0, 0.0);
        Point3 p3(1.0, -1.0, -10.0);
        Point3 apex(1., 2., 5.);
        std::vector<Point3> basepoints = { p1,p2,p3 };
        CHECK_THROWS_AS(AMCAX::MakeRightPrism(baseLocationP, basepoints, apex), AMCAX::_ConstructionError);
    ;
	SECTION("p1=p2") {
        Point3 p1(-1.0, 0.0, 0.0);
        Point3 p2(-1.0, 0.0, 0.0);
        Point3 p3(2.0, 1.0, 0.0);
        Point3 p4(1.0, -1.0, 0.0);
        Point3 apex(2.0, 2.0, -4.5);
        std::vector<Point3> points = { p1, p2, p3,p4 };
        CHECK_THROWS_AS( AMCAX::MakeRightPrism(p1, p2, p3, p4, apex),AMCAX::_ConstructionError);
    }}
SECTION("baseLocationP and  p1 is same") {
        Point3 baseLocationP(-1.0, 0.0, 0.0);
        Point3 p1(0.0, 0.0, 0.0);
        Point3 p2(3.0, 0.0, 0.0);
        Point3 p3(1.0, -1.0, -10.0);
        Point3 apex(1., 2., 5.);
        std::vector<Point3> basepoints = { p1,p2,p3 };
        CHECK_THROWS_AS(AMCAX::MakeRightPrism(baseLocationP, basepoints, apex), AMCAX::_ConstructionError);
    ;
	SECTION("default fram3") {
        TopoShape shape = AMCAX::MakeRightPrism(fram3, radius, nside, height);
        AMCAX::GlobalProperty props;
        CHECK(GetSurfaceProperties(shape, props, true, false) == Approx(301.4548102606));
        CHECK(GetVolumeProperties(shape, props, true, false) == Approx(367.3657826828));
        CHECK(shape.Type() == ShapeType::Solid);
        OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX"MakeRightPrism4_01.brep");
        TopoSolid solid = AMCAX::TopoCast::Solid(shape);
        Point3 p1(0.0, 0.0, 0.0);
        Point3 p2(4.04508, -2.93893, 5.0);
        Point3 p3(-1.54508, 4.75528, 0.);
        Point3 p4(-4.045085, -2.938926, 2.837605);
        std::vector<Point3> points = { p1,p2,p3,p4 };
        for (const Point3& p : points) {
            bool isPointOnSolid = AMCAX::BRepClassificationTools::IsPointInOnSolid(solid, p);
            CHECK(isPointOnSolid == true);
        }
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API MakeRightPrism(const Point3& baseLocation, const std::vector<Point3>& basepoints, const Point3& apex)	 @param apex A point on the top plane
	 @param basepoints The base points that are projected onto the base plane
	 @param baseLocation The location of the base plane
	 @details The base plane are determined by the location point and the first two base points
	 @brief Construct a right prism with a given location on the base plane
,
 "output":SECTION("baseLocationP and  p1 is same") {
        Point3 baseLocationP(-1.0, 0.0, 0.0);
        Point3 p1(0.0, 0.0, 0.0);
        Point3 p2(3.0, 0.0, 0.0);
        Point3 p3(1.0, -1.0, -10.0);
        Point3 apex(1., 2., 5.);
        std::vector<Point3> basepoints = { p1,p2,p3 };
        CHECK_THROWS_AS(AMCAX::MakeRightPrism(baseLocationP, basepoints, apex), AMCAX::_ConstructionError);
    ;
	SECTION("p1=p2") {
        Point3 p1(-1.0, 0.0, 0.0);
        Point3 p2(-1.0, 0.0, 0.0);
        Point3 p3(2.0, 1.0, 0.0);
        Point3 p4(1.0, -1.0, 0.0);
        Point3 apex(2.0, 2.0, -4.5);
        std::vector<Point3> points = { p1, p2, p3,p4 };
        CHECK_THROWS_AS( AMCAX::MakeRightPrism(p1, p2, p3, p4, apex),AMCAX::_ConstructionError);
    }}
SECTION("baseLocationP and  p1 is same") {
        Point3 baseLocationP(-1.0, 0.0, 0.0);
        Point3 p1(0.0, 0.0, 0.0);
        Point3 p2(3.0, 0.0, 0.0);
        Point3 p3(1.0, -1.0, -10.0);
        Point3 apex(1., 2., 5.);
        std::vector<Point3> basepoints = { p1,p2,p3 };
        CHECK_THROWS_AS(AMCAX::MakeRightPrism(baseLocationP, basepoints, apex), AMCAX::_ConstructionError);
    ;
	SECTION("4 points not on the XY. ") {
        Point3 p0(0.0, 0.0, 0.0);
        Direction3 dir3(0.0, 0.0, 1.0);
        Frame3 fram3(p0, dir3);
        Point3 p1(-1.0, 0.0, 0.0);
        Point3 p2(1.0, -4.0, -2.0);
        Point3 p3(2.0, 0.0, -1.0);
        Point3 p4(1., 3., -1.0);
        std::vector<Point3> basepoints = { p1,p2,p3,p4 };
        Point3 apex(0., 0., 5.0);
        TopoShape shape = AMCAX::MakeRightPrism(fram3, basepoints, apex);
        AMCAX::GlobalProperty props;
        CHECK(GetSurfaceProperties(shape, props, true, false) == Approx(97.8153525812));
        CHECK(GetVolumeProperties(shape, props, true, false) == Approx(52.5));
        Point3 p11(-1.0, 0.0, 0.0);
        Point3 p21(2.0, 0.0, 0.0);
        Point3 p31(1., 3., 0.0);
        Point3 p41(1., -4., 0.0);
        Point3 apex1(0., 0., 0.0);
        std::vector<Point3> points2 = { p11,p21,p31,p41,apex1 };
        CHECK(shape.Type() == ShapeType::Solid);
        CHECK(OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX"MakeRightPrism7_case01.brep"));
        TopoSolid solid = AMCAX::TopoCast::Solid(shape);
        for (const Point3& p : points2) {
            bool isPointOnSolid = AMCAX::BRepClassificationTools::IsPointInOnSolid(solid, p);
            CHECK(isPointOnSolid == true);
        }
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static TopoShape SewShape(const std::list<TopoShape>& shapes, double tolerance)	 @return The sewed shape
	 @param tolerance The tolerance
	 @param shapes The shapes to be sewed
	          If some edges do not coincide, the related faces remain unsewed.
	 @details The border edges are merged to common edges under a given tolerance.
	 @brief Sew faces to a shell
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <modeling/MakeShapeTool.hpp>
#include<modeling/MakeFace.hpp>
#include<math/Plane.hpp>
#include <common/CartesianCoordinateSystem.hpp>
#include <topology/TopoExplorerTool.hpp>
TEST_CASE("case1-1: MakeShapeTool::SewShape ", "[modeling][MakeShapeTool][SewShape][P1]")
{
	std::list<TopoShape> shapes;
	shapes.push_back(MakeFace(Plane(), 0.0, 1.0, 0.0, 1.0));
	shapes.push_back(MakeFace(Plane(Frame3(Point3(1.0, 0.0, 0.0), CartesianCoordinateSystem::DX(), -CartesianCoordinateSystem::DZ())), 0.0, 1.0, 0.0, 1.0));
	TopoShape result = MakeShapeTool::SewShape(shapes, Precision::Confusion());
	CHECK(OCCTIO::OCCTTool::Write(result, OUTPUT_PATH_PREFIX"SewShapetest1-0.brep"));
	IndexSet<TopoShape> sf1, sf2, sf3;
	CHECK(GetTopoToolCount(result, AMCAX::ShapeType::Shell, sf1) == 1);
	CHECK(GetTopoToolCount(result, AMCAX::ShapeType::Compound, sf2) == 0);
	CHECK(GetTopoToolCount(result, AMCAX::ShapeType::Face, sf3) == 2);
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API explicit TransformShape(const Transformation3& tr)	 @param tr The transformation
	 @brief Construct from a transformation
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <modeling/MakeSphere.hpp>
#include <modeling/TransformShape.hpp>
#include <topomesh/BRepMeshIncrementalMesh.hpp>
#include <modeling/MakeShapeTool.hpp>
#include <common/TransformationT.hpp>
#include <common/CartesianCoordinateSystem.hpp>
#include <common/GeneralTransformationT.hpp>
#include <modeling/GeneralTransformShape.hpp>
#include <geometry/GlobalProperty.hpp>
#include <occtio/OCCTTool.hpp>
#include <topology/BRepGlobalProperty.hpp>
using namespace AMCAX;
TEST_CASE("bug1: TransformShape  ", "[modeling][TransformShape][fixbug]") {
	TopoShape s = MakeSphere(1.0);
	BRepMeshIncrementalMesh mesher(s, 0.005, true);
	MakeShapeTool::EnsureNormalConsistency(s);
	Transformation3 tr;
	tr.SetRotation(CartesianCoordinateSystem::OZ(), M_PI_2);
	s = TransformShape(s, tr, true, true);
	CHECK(s.IsNull() == false);
	CHECK(s.Type() == AMCAX::ShapeType::Solid);
	GlobalProperty prop;
	BRepGlobalProperty::VolumeProperties(s, prop);
	CHECK(prop.Mass() == Approx(4.1887902048).epsilon(1e-11));
	Point3 vP = prop.CenterOfMass();
#ifndef WIN_CASE
	CHECK(vP.X() == Approx(0.0).margin(1e-12));
	CHECK(vP.Y() == Approx(0.0).margin(1e-12));
	CHECK(vP.Z() == Approx(0.0).margin(1e-12));
#else
	CHECK(vP.X() == Approx(-4.0938241231662633e-18).epsilon(1e-12));
	CHECK(vP.Y() == Approx(-6.1820277995281757e-17).epsilon(1e-12));
	CHECK(vP.Z() == Approx(-3.1794228708137405e-17).epsilon(1e-12)); 
#endif
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API TransformShape(const TopoShape& s, const Transformation3& tr, bool copyGeom = false, bool copyMesh = false)	 @param copyMesh Whether the mesh of the shape is copied
	 @param copyGeom Whether the geometry of the shape is copied
	 @param tr The transformation
	 @param s The shape
	 @brief Construct from a shape with a transformation
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <modeling/MakeSphere.hpp>
#include <modeling/TransformShape.hpp>
#include <topomesh/BRepMeshIncrementalMesh.hpp>
#include <modeling/MakeShapeTool.hpp>
#include <common/TransformationT.hpp>
#include <common/CartesianCoordinateSystem.hpp>
#include <common/GeneralTransformationT.hpp>
#include <modeling/GeneralTransformShape.hpp>
#include <geometry/GlobalProperty.hpp>
#include <occtio/OCCTTool.hpp>
#include <topology/BRepGlobalProperty.hpp>
using namespace AMCAX;
TEST_CASE("bug1: TransformShape  ", "[modeling][TransformShape][fixbug]") {
	TopoShape s = MakeSphere(1.0);
	BRepMeshIncrementalMesh mesher(s, 0.005, true);
	MakeShapeTool::EnsureNormalConsistency(s);
	Transformation3 tr;
	tr.SetRotation(CartesianCoordinateSystem::OZ(), M_PI_2);
	s = TransformShape(s, tr, true, true);
	CHECK(s.IsNull() == false);
	CHECK(s.Type() == AMCAX::ShapeType::Solid);
	GlobalProperty prop;
	BRepGlobalProperty::VolumeProperties(s, prop);
	CHECK(prop.Mass() == Approx(4.1887902048).epsilon(1e-11));
	Point3 vP = prop.CenterOfMass();
#ifndef WIN_CASE
	CHECK(vP.X() == Approx(0.0).margin(1e-12));
	CHECK(vP.Y() == Approx(0.0).margin(1e-12));
	CHECK(vP.Z() == Approx(0.0).margin(1e-12));
#else
	CHECK(vP.X() == Approx(-4.0938241231662633e-18).epsilon(1e-12));
	CHECK(vP.Y() == Approx(-6.1820277995281757e-17).epsilon(1e-12));
	CHECK(vP.Z() == Approx(-3.1794228708137405e-17).epsilon(1e-12)); 
#endif
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static std::shared_ptr<Geom3BSplineCurve> ApproxPoints(const std::vector<Point3>& points, int degree, int npoles, bool isClosed = false, ApproxParameterizationType ptype = ApproxParameterizationType::ChordLength)	 @return curve
	 @param ptype parameterization type
	 @param isClosed Is curve closed
	 @param npoles Target number of poles
	 @param degree Target degree
	 @param points Data points to be approximated
	 @brief Approx points to a curve
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <nurbs/NURBSAPIApprox.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <modeling/MakeEdge.hpp>
#include <nurbs/NURBSAPIInterpolate.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
#include <modeling/MakeVertex.hpp>
#include <nurbs/NURBSAPIBuildCurve.hpp>
#include<catch.hpp>
#include<testHelper.h>
#include <nurbs/NURBSAPIApprox.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <modeling/MakeEdge.hpp>
#include <nurbs/NURBSAPIInterpolate.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
#include <modeling/MakeVertex.hpp>
#include <nurbs/NURBSAPIBuildCurve.hpp>
;
	SECTION("TestApproxPoints")
	{
		OUTPUT_DIRECTORY(nurbs, Approxs/ApproxPoints);
		std::vector<Point3> points;
		Point3 p1(0.0, 0.0, 0.0);
		Point3 p2(-0.1, 1.0, -0.2);
		Point3 p3(0.1, 2.0, -0.1);
		Point3 p4(0.2, 3.0, 0.1);
		Point3 p5(0.1, 4.0, 0.0);
		Point3 p6(0.0, 5.0, -0.1);
		points.push_back(p1);
		points.push_back(p2);
		points.push_back(p3);
		points.push_back(p4);
		points.push_back(p5);
		points.push_back(p6);
		int degree = 3;
		int npoles = 5;
		auto curve = NURBSAPIApprox::ApproxPoints(points, degree, npoles);
		TopoVertex v1 = MakeVertex(p1);
		TopoVertex v2 = MakeVertex(p2);
		TopoVertex v3 = MakeVertex(p3);
		TopoVertex v4 = MakeVertex(p4);
		TopoVertex v5 = MakeVertex(p5);
		TopoVertex v6 = MakeVertex(p6);
		TopoEdge edge = MakeEdge(curve);
		BRepExtremaDistShapeShape dist1(v1, edge);
		BRepExtremaDistShapeShape dist2(v2, edge);
		BRepExtremaDistShapeShape dist3(v3, edge);
		BRepExtremaDistShapeShape dist4(v4, edge);
		BRepExtremaDistShapeShape dist5(v5, edge);
		BRepExtremaDistShapeShape dist6(v6, edge);
		CHECK(dist1.Value() <= Approx(refTol));
		CHECK(dist2.Value() <= Approx(refTol));
		CHECK(dist3.Value() <= Approx(refTol));
		CHECK(dist4.Value() <= Approx(refTol));
		CHECK(dist5.Value() <= Approx(refTol));
		CHECK(dist6.Value() <= Approx(refTol));
		Point3 sp = curve->StartPoint();
		Point3 ep = curve->EndPoint();
		CHECK(sp.X() == p1.X());
		CHECK(sp.Y() == p1.Y());
		CHECK(sp.Z() == p1.Z());
		CHECK(ep.X() == p6.X());
		CHECK(ep.Y() == p6.Y());
		CHECK(ep.Z() == p6.Z());
		CHECK(curve->Degree() == 3);
		CHECK(curve->NPoles() == 5);
		CHECK(curve->IsClosed() == false);
		CHECK(curve->IsPeriodic() == false);
		OCCTIO::OCCTTool::Write(v1, outdir + "v1.brep");
		OCCTIO::OCCTTool::Write(v2, outdir + "v2.brep");
		OCCTIO::OCCTTool::Write(v3, outdir + "v3.brep");
		OCCTIO::OCCTTool::Write(v4, outdir + "v4.brep");
		OCCTIO::OCCTTool::Write(v5, outdir + "v5.brep");
		OCCTIO::OCCTTool::Write(v6, outdir + "v6.brep");
		OCCTIO::OCCTTool::Write(edge, outdir + "result.brep");
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static std::shared_ptr<Geom3BSplineCurve> BlendCurves( const std::shared_ptr<Geom3BSplineCurve>& curve1, bool isFront1, ContinuityType cont1, const std::shared_ptr<Geom3BSplineCurve>& curve2, bool isFront2, ContinuityType cont2),
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <nurbs/NURBSAPIBlend.hpp>
#include <modeling/MakeEdge.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
#include <modeling/MakeVertex.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <modeling/MakeFace.hpp>
#include <topology/BRepAdaptorCurve3.hpp>
#include <topology/TopoTool.hpp>
#include <io/ShapeTool.hpp>
#include <topology/TopoTool.hpp>
#include <topology/TopoCast.hpp>
#include <geometry/Geom3Surface.hpp>
#include <geometry/Geom3BSplineSurface.hpp>
#include <nurbs/NURBSAPIConvert.hpp>
#include <nurbs/NURBSAPIGetGeometry.hpp>
#include <topology/TopoExplorer.hpp>
#include <topology/TopoExplorerTool.hpp>
double NURBSSampleEdge(int num, double tol, const shared_ptr<Geom3Curve>& curve, const TopoEdge& edge)
{
	double fpu1 = curve->FirstParameter();
	double lpu1 = curve->LastParameter();
	double delta = (lpu1 - fpu1) / num;
	Point3 p;
	int n = 0;
	for (int i = 0; i < num; i++) {
		double t = fpu1 + i * delta;
		curve->D0(t, p);
		if (BRepClassificationTools::IsPointInOnEdge(edge, p, tol))
		{
			n++;
		}
	}
	double r1 = 1.0 * (num - n) / num;
	return r1;
}
TopoEdge ChooseSimilarEdge(const TopoShape& shape, const TopoEdge& edge)
{
	int nsample = 1000;
	Point3 p1, p2;
	BRepAdaptorCurve3 refC(edge);
	double refFp = refC.FirstParameter();
	double refLp = refC.LastParameter();
	for (TopoExplorer ex(shape, ShapeType::Edge); ex.More(); ex.Next())
	{
		const TopoEdge& cre = static_cast<const TopoEdge&>((ex.Current()));
		BRepAdaptorCurve3 crC(edge);
		double crFp = crC.FirstParameter();
		double crLp = crC.LastParameter();
		if (std::abs(refFp - crFp) < 0.001 && std::abs(refLp - crLp) < 0.001)
		{
			bool isOK = true;
			for (int i = 0; i < nsample; i++)
			{
				double t1 = refFp + i * (refLp - refFp) / (nsample - 1);
				double t2 = crFp + i * (crLp - crFp) / (nsample - 1);
				refC.D0(t1, p1);
				crC.D0(t2, p2);
				if (p1.Distance(p2) > 0.001)
				{
					isOK = false;
					break;
				}
			}
			if (isOK)
			{
				return cre;
			}
		}
	}
	TopoEdge e;
	return e;
}
TEST_CASE("bug1: TestBridgeTrimmedPeriodicFace ", "[nurbs][Blend][fixbug]")
{
	std::string filedir = INPUT_PATH_PREFIX "/TestNURBS/TestBridgeTrimmedPeriodicFaces/";
	TopoFace f1 = ReadBRepFace(filedir + "face1.brep");
	TopoFace f2 = ReadBRepFace(filedir + "face2.brep");
	Point3 p1 = ReadBRepPoint(filedir + "pt1.brep");
	Point3 p2 = ReadBRepPoint(filedir + "pt2.brep");
	auto [d1, e1] = NearestEdge(p1, f1);
	auto [d2, e2] = NearestEdge(p2, f2);
	ContinuityType cont1 = ContinuityType::G2;
	ContinuityType cont2 = ContinuityType::G2;
	bool isPrecise = true;
	std::vector<double> tol;
	tol.push_back(0.001);
	tol.push_back(0.01);
	tol.push_back(0.01);
	std::vector<double> params(2, 1.0);
	bool autoReverse = true;
	auto result = NURBSAPIBlend::BlendFaces(f1, e1, cont1, params, f2, e2, cont2, params, autoReverse, isPrecise, tol);
	BRepExtremaDistShapeShape dist1(f1, MakeFace(result, 0.0));
	BRepExtremaDistShapeShape dist2(f2, MakeFace(result, 0.0));
	CHECK(dist1.Value() == Approx(0.0).margin(0.1));
	CHECK(dist2.Value() == Approx(0.0).margin(0.1));
;
	SECTION("TestBridgeCurve2")
	{
		OUTPUT_DIRECTORY(nurbs, Blend/bug680/BridgeCurve2);
		std::string filedir = INPUT_PATH_PREFIX "/TestNURBS/TestBridgeCurve2/";
		auto curve1 = ReadBRepCurve(filedir + "curve1.brep");
		auto curve2 = ReadBRepCurve(filedir + "curve2.brep");
		auto bridge = NURBSAPIBlend::BlendCurves(curve1, false, ContinuityType::G2, curve2, true, ContinuityType::G2);
		Point3 sp1 = curve1->StartPoint();
		Point3 ep1 = curve1->EndPoint();
		Point3 sp2 = curve2->StartPoint();
		Point3 ep2 = curve2->EndPoint();
		Point3 sp3 = bridge->StartPoint();
		Point3 ep3 = bridge->EndPoint();
		CHECK(sp3.X() == Approx(ep1.X()).margin(1e-7));
		CHECK(sp3.Y() == Approx(ep1.Y()));
		CHECK(sp3.Z() == Approx(ep1.Z()));
		CHECK(ep3.X() == Approx(sp2.X()).margin(1e-7));
		CHECK(ep3.Y() == Approx(sp2.Y()).margin(1e-7));
		CHECK(ep3.Z() == Approx(sp2.Z()).margin(1e-7));
		auto curve = ReadBRepCurve(filedir + "Rhino/rhinoResult.brep");
		double res = NurbsSampleCurve(num, refTol, bridge, curve);
		OCCTIO::OCCTTool::Write(MakeEdge(curve1), outdir + "src1.brep");
		OCCTIO::OCCTTool::Write(MakeEdge(curve2), outdir + "src2.brep");
		OCCTIO::OCCTTool::Write(MakeEdge(bridge), outdir + "result.brep");
		OCCTIO::OCCTTool::Write(MakeEdge(curve), outdir + "rhinoResult.brep");
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static std::shared_ptr<Geom3BSplineCurve> BlendCurves( const std::shared_ptr<Geom3BSplineCurve>& curve1, bool isFront1, ContinuityType cont1, std::vector<double>& parameters1, const std::shared_ptr<Geom3BSplineCurve>& curve2, bool isFront2, ContinuityType cont2, std::vector<double>& parameters2),
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <nurbs/NURBSAPIBlend.hpp>
#include <modeling/MakeEdge.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
#include <modeling/MakeVertex.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <modeling/MakeFace.hpp>
#include <topology/BRepAdaptorCurve3.hpp>
#include <topology/TopoTool.hpp>
#include <io/ShapeTool.hpp>
#include <topology/TopoTool.hpp>
#include <topology/TopoCast.hpp>
#include <geometry/Geom3Surface.hpp>
#include <geometry/Geom3BSplineSurface.hpp>
#include <nurbs/NURBSAPIConvert.hpp>
#include <nurbs/NURBSAPIGetGeometry.hpp>
#include <topology/TopoExplorer.hpp>
#include <topology/TopoExplorerTool.hpp>
double NURBSSampleEdge(int num, double tol, const shared_ptr<Geom3Curve>& curve, const TopoEdge& edge)
{
	double fpu1 = curve->FirstParameter();
	double lpu1 = curve->LastParameter();
	double delta = (lpu1 - fpu1) / num;
	Point3 p;
	int n = 0;
	for (int i = 0; i < num; i++) {
		double t = fpu1 + i * delta;
		curve->D0(t, p);
		if (BRepClassificationTools::IsPointInOnEdge(edge, p, tol))
		{
			n++;
		}
	}
	double r1 = 1.0 * (num - n) / num;
	return r1;
}
TopoEdge ChooseSimilarEdge(const TopoShape& shape, const TopoEdge& edge)
{
	int nsample = 1000;
	Point3 p1, p2;
	BRepAdaptorCurve3 refC(edge);
	double refFp = refC.FirstParameter();
	double refLp = refC.LastParameter();
	for (TopoExplorer ex(shape, ShapeType::Edge); ex.More(); ex.Next())
	{
		const TopoEdge& cre = static_cast<const TopoEdge&>((ex.Current()));
		BRepAdaptorCurve3 crC(edge);
		double crFp = crC.FirstParameter();
		double crLp = crC.LastParameter();
		if (std::abs(refFp - crFp) < 0.001 && std::abs(refLp - crLp) < 0.001)
		{
			bool isOK = true;
			for (int i = 0; i < nsample; i++)
			{
				double t1 = refFp + i * (refLp - refFp) / (nsample - 1);
				double t2 = crFp + i * (crLp - crFp) / (nsample - 1);
				refC.D0(t1, p1);
				crC.D0(t2, p2);
				if (p1.Distance(p2) > 0.001)
				{
					isOK = false;
					break;
				}
			}
			if (isOK)
			{
				return cre;
			}
		}
	}
	TopoEdge e;
	return e;
}
TEST_CASE("bug1: TestBridgeTrimmedPeriodicFace ", "[nurbs][Blend][fixbug]")
{
	std::string filedir = INPUT_PATH_PREFIX "/TestNURBS/TestBridgeTrimmedPeriodicFaces/";
	TopoFace f1 = ReadBRepFace(filedir + "face1.brep");
	TopoFace f2 = ReadBRepFace(filedir + "face2.brep");
	Point3 p1 = ReadBRepPoint(filedir + "pt1.brep");
	Point3 p2 = ReadBRepPoint(filedir + "pt2.brep");
	auto [d1, e1] = NearestEdge(p1, f1);
	auto [d2, e2] = NearestEdge(p2, f2);
	ContinuityType cont1 = ContinuityType::G2;
	ContinuityType cont2 = ContinuityType::G2;
	bool isPrecise = true;
	std::vector<double> tol;
	tol.push_back(0.001);
	tol.push_back(0.01);
	tol.push_back(0.01);
	std::vector<double> params(2, 1.0);
	bool autoReverse = true;
	auto result = NURBSAPIBlend::BlendFaces(f1, e1, cont1, params, f2, e2, cont2, params, autoReverse, isPrecise, tol);
	BRepExtremaDistShapeShape dist1(f1, MakeFace(result, 0.0));
	BRepExtremaDistShapeShape dist2(f2, MakeFace(result, 0.0));
	CHECK(dist1.Value() == Approx(0.0).margin(0.1));
	CHECK(dist2.Value() == Approx(0.0).margin(0.1));
;
	SECTION("TestBridgeCurve2")
	{
		OUTPUT_DIRECTORY(nurbs, Blend/bug680/BridgeCurve2);
		std::string filedir = INPUT_PATH_PREFIX "/TestNURBS/TestBridgeCurve2/";
		auto curve1 = ReadBRepCurve(filedir + "curve1.brep");
		auto curve2 = ReadBRepCurve(filedir + "curve2.brep");
		auto bridge = NURBSAPIBlend::BlendCurves(curve1, false, ContinuityType::G2, curve2, true, ContinuityType::G2);
		Point3 sp1 = curve1->StartPoint();
		Point3 ep1 = curve1->EndPoint();
		Point3 sp2 = curve2->StartPoint();
		Point3 ep2 = curve2->EndPoint();
		Point3 sp3 = bridge->StartPoint();
		Point3 ep3 = bridge->EndPoint();
		CHECK(sp3.X() == Approx(ep1.X()).margin(1e-7));
		CHECK(sp3.Y() == Approx(ep1.Y()));
		CHECK(sp3.Z() == Approx(ep1.Z()));
		CHECK(ep3.X() == Approx(sp2.X()).margin(1e-7));
		CHECK(ep3.Y() == Approx(sp2.Y()).margin(1e-7));
		CHECK(ep3.Z() == Approx(sp2.Z()).margin(1e-7));
		auto curve = ReadBRepCurve(filedir + "Rhino/rhinoResult.brep");
		double res = NurbsSampleCurve(num, refTol, bridge, curve);
		OCCTIO::OCCTTool::Write(MakeEdge(curve1), outdir + "src1.brep");
		OCCTIO::OCCTTool::Write(MakeEdge(curve2), outdir + "src2.brep");
		OCCTIO::OCCTTool::Write(MakeEdge(bridge), outdir + "result.brep");
		OCCTIO::OCCTTool::Write(MakeEdge(curve), outdir + "rhinoResult.brep");
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static std::shared_ptr<Geom3BSplineSurface> BlendSurfaces( const std::shared_ptr<Geom3BSplineSurface>& surf1, bool isUIso1, bool isFront1, ContinuityType cont1, std::vector<double>& parameters1, const std::shared_ptr<Geom3BSplineSurface>& surf2, bool isUIso2, bool isFront2, ContinuityType cont2, std::vector<double>& parameters2, bool autoReverse, bool isPrecise, const std::vector<double>& tol),
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <nurbs/NURBSAPIBlend.hpp>
#include <modeling/MakeEdge.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
#include <modeling/MakeVertex.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <modeling/MakeFace.hpp>
#include <topology/BRepAdaptorCurve3.hpp>
#include <topology/TopoTool.hpp>
#include <io/ShapeTool.hpp>
#include <topology/TopoTool.hpp>
#include <topology/TopoCast.hpp>
#include <geometry/Geom3Surface.hpp>
#include <geometry/Geom3BSplineSurface.hpp>
#include <nurbs/NURBSAPIConvert.hpp>
#include <nurbs/NURBSAPIGetGeometry.hpp>
#include <topology/TopoExplorer.hpp>
#include <topology/TopoExplorerTool.hpp>
double NURBSSampleEdge(int num, double tol, const shared_ptr<Geom3Curve>& curve, const TopoEdge& edge)
{
	double fpu1 = curve->FirstParameter();
	double lpu1 = curve->LastParameter();
	double delta = (lpu1 - fpu1) / num;
	Point3 p;
	int n = 0;
	for (int i = 0; i < num; i++) {
		double t = fpu1 + i * delta;
		curve->D0(t, p);
		if (BRepClassificationTools::IsPointInOnEdge(edge, p, tol))
		{
			n++;
		}
	}
	double r1 = 1.0 * (num - n) / num;
	return r1;
}
TopoEdge ChooseSimilarEdge(const TopoShape& shape, const TopoEdge& edge)
{
	int nsample = 1000;
	Point3 p1, p2;
	BRepAdaptorCurve3 refC(edge);
	double refFp = refC.FirstParameter();
	double refLp = refC.LastParameter();
	for (TopoExplorer ex(shape, ShapeType::Edge); ex.More(); ex.Next())
	{
		const TopoEdge& cre = static_cast<const TopoEdge&>((ex.Current()));
		BRepAdaptorCurve3 crC(edge);
		double crFp = crC.FirstParameter();
		double crLp = crC.LastParameter();
		if (std::abs(refFp - crFp) < 0.001 && std::abs(refLp - crLp) < 0.001)
		{
			bool isOK = true;
			for (int i = 0; i < nsample; i++)
			{
				double t1 = refFp + i * (refLp - refFp) / (nsample - 1);
				double t2 = crFp + i * (crLp - crFp) / (nsample - 1);
				refC.D0(t1, p1);
				crC.D0(t2, p2);
				if (p1.Distance(p2) > 0.001)
				{
					isOK = false;
					break;
				}
			}
			if (isOK)
			{
				return cre;
			}
		}
	}
	TopoEdge e;
	return e;
}
TEST_CASE("bug4:testBlendFaces ", "[nurbs][Blend][fixbug]")
{
	int num = 1000;
	double ratio = 0.1;
	double refTol = DEFAULT_TOLERANCE;
	OUTPUT_DIRECTORY(nurbs, Blend/bug737/testBlendFaces2);
	std::string filedir = INPUT_PATH_PREFIX "/TestNURBS/TestBlendFaces/";
	TopoFace f1 = ReadBRepFace(filedir + "surfaceShapeFrom1.brep");
	TopoFace f2 = ReadBRepFace(filedir + "surfaceShapeFrom2.brep");
	vector<TopoEdge>vec1;
	vector<TopoEdge>vec2;
	for (TopoExplorer exp(f1, ShapeType::Edge); exp.More(); exp.Next())
	{
		TopoEdge c1 = static_cast<const TopoEdge&>(exp.Current());
		vec1.push_back(c1);
	}
	for (TopoExplorer expE(f2, ShapeType::Edge); expE.More(); expE.Next())
	{
		TopoEdge c2 = static_cast<const TopoEdge&>(expE.Current());
		vec2.push_back(c2);
	}
	CHECK(vec1.size() == 4);
	CHECK(vec2.size() == 4);
	vector<double>parameters1 = { 1.0, 1.0 };
	vector<double>parameters2 = { 1.0, 1.0 };
	vector<double>tol = { 0.001, 0.1 * M_PI / 180.0, 0.05 };
	double res1, res2, res3, res4;
	for (int i = 0; i < vec1.size(); i++)
	{
		for (int j = 0; j < vec2.size(); j++)
		{
			shared_ptr<Geom3BSplineSurface> blendSurfaceG1 = NURBSAPIBlend::BlendFaces(f1, vec1[i], ContinuityType::G1, parameters1, f2, vec2[j], ContinuityType::G1, parameters2, true, true, tol);
			BRepExtremaDistShapeShape dist1(f1, MakeFace(blendSurfaceG1, 0.0));
			BRepExtremaDistShapeShape dist2(f2, MakeFace(blendSurfaceG1, 0.0));
			CHECK(dist1.Value() == Approx(0.0).margin(0.1));
			CHECK(dist2.Value() == Approx(0.0).margin(0.1));
			int count = GetTopoCount(MakeFace(blendSurfaceG1, 0.0), ShapeType::Edge);
			CHECK(count == 4);
			shared_ptr<Geom3Curve> u1;
			shared_ptr<Geom3Curve> u2;
			double first = blendSurfaceG1->FirstUParameter();
			u1 = blendSurfaceG1->UIso(first);
			double last = blendSurfaceG1->LastUParameter();
			u2 = blendSurfaceG1->UIso(last);
			res1 = NURBSSampleEdge(num, refTol, u1, vec1[i]);
			res2 = NURBSSampleEdge(num, refTol, u2, vec2[j]);
			CHECK(res1 <= ratio);
			CHECK(res2 <= ratio);
			shared_ptr<Geom3BSplineSurface> blendSurfaceG2 = NURBSAPIBlend::BlendFaces(f1, vec1[i], ContinuityType::G2, parameters1, f2, vec2[j], ContinuityType::G2, parameters2, true, true, tol);
			BRepExtremaDistShapeShape dist3(f1, MakeFace(blendSurfaceG2, 0.0));
			BRepExtremaDistShapeShape dist4(f2, MakeFace(blendSurfaceG2, 0.0));
			CHECK(dist3.Value() == Approx(0.0).margin(0.1));
			CHECK(dist4.Value() == Approx(0.0).margin(0.1));
			int count2 = GetTopoCount(MakeFace(blendSurfaceG2, 0.0), ShapeType::Edge);
			CHECK(count2 == 4);
			shared_ptr<Geom3Curve> u3;
			shared_ptr<Geom3Curve> u4;
			double first2 = blendSurfaceG2->FirstUParameter();
			u3 = blendSurfaceG2->UIso(first2);
			double last2 = blendSurfaceG2->LastUParameter();
			u4 = blendSurfaceG2->UIso(last2);
			res3 = NURBSSampleEdge(num, refTol, u3, vec1[i]);
			res4 = NURBSSampleEdge(num, refTol, u4, vec2[j]);
			CHECK(res3 <= ratio);
			CHECK(res4 <= ratio);
			OCCTIO::OCCTTool::Write(MakeFace(blendSurfaceG1, 0.0), outdir + "G1-result" + to_string(i + 1) + to_string(j + 1) + ".brep");
			OCCTIO::OCCTTool::Write(MakeFace(blendSurfaceG2, 0.0), outdir + "G2-result" + to_string(i + 1) + to_string(j + 1) + ".brep");
		}
	}
	OCCTIO::OCCTTool::Write(f1, outdir + "f1.brep");
	OCCTIO::OCCTTool::Write(f2, outdir + "f2.brep");
	OCCTIO::OCCTTool::Write(vec1[0], outdir + "e1.brep");
	OCCTIO::OCCTTool::Write(vec1[1], outdir + "e2.brep");
	OCCTIO::OCCTTool::Write(vec1[2], outdir + "e3.brep");
	OCCTIO::OCCTTool::Write(vec1[3], outdir + "e4.brep");
	OCCTIO::OCCTTool::Write(vec2[0], outdir + "e11.brep");
	OCCTIO::OCCTTool::Write(vec2[1], outdir + "e22.brep");
	OCCTIO::OCCTTool::Write(vec2[2], outdir + "e33.brep");
	OCCTIO::OCCTTool::Write(vec2[3], outdir + "e44.brep");
;
	SECTION("testBlendSurf")
	{
		OUTPUT_DIRECTORY(nurbs, Blend/BlendSurf);
		bool isPrecise = true;
		auto cont1 = ContinuityType::G2;
		auto cont2 = ContinuityType::G2;
		bool isU1 = true;
		bool isU2 = true;
		bool isFront1 = false;
		bool isFront2 = false;
		std::vector<double> param1, param2;
		std::shared_ptr<Geom3BSplineSurface> surface1 = ReadBRepSurface(INPUT_PATH_PREFIX"/TestNURBS/TestBlendSurf/surface1.brep");
		std::shared_ptr<Geom3BSplineSurface> surface2 = ReadBRepSurface(INPUT_PATH_PREFIX"/TestNURBS/TestBlendSurf/surface2.brep");
		std::shared_ptr<Geom3BSplineSurface> bsp3;
		auto bsp1 = std::dynamic_pointer_cast<Geom3BSplineSurface>(surface1);
		auto bsp2 = std::dynamic_pointer_cast<Geom3BSplineSurface>(surface2);
		std::vector<double> tol(3);
		tol[0] = 1e-3;
		tol[1] = M_PI / 180.0;
		tol[2] = 0.05;
		bsp3 = NURBSAPIBlend::BlendSurfaces(surface1, isU1, isFront1, cont1, param1, surface2, isU2, isFront2, cont2, param2, true, isPrecise, tol);
		BRepExtremaDistShapeShape dist1(MakeFace(surface1, 0.0), MakeFace(bsp3, 0.0));
		BRepExtremaDistShapeShape dist2(MakeFace(surface2, 0.0), MakeFace(bsp3, 0.0));
		CHECK(dist1.Value() == Approx(0.0).margin(0.1));
		CHECK(dist2.Value() == Approx(0.0).margin(0.1));
		double fpu1 = bsp3->FirstUParameter();
		double lpu1 = bsp3->LastUParameter();
		shared_ptr<Geom3Curve> u1 = bsp3->UIso(fpu1);
		shared_ptr<Geom3Curve> u2 = bsp3->UIso(lpu1);
		double f1 = surface1->LastUParameter();
		double f2 = surface2->LastUParameter();
		shared_ptr<Geom3Curve> c1 = surface1->UIso(f1);
		shared_ptr<Geom3Curve> c2 = surface2->UIso(f2);
		bool res1 = IsCurveOnSurf(num, ratio, u1, surface1);
		bool res2 = IsCurveOnSurf(num, ratio, u2, surface2);
		CHECK(res1 == true);
		CHECK(res2 == true);
		double res3 = NurbsSampleCurve(num, refTol, c1, u1);
		double res4 = NurbsSampleCurve(num, refTol, c2, u2);
		CHECK(res3 <= ratio);
		CHECK(res4 <= ratio);
		OCCTIO::OCCTTool::Write(MakeEdge(u1), outdir + "u1.brep");
		OCCTIO::OCCTTool::Write(MakeEdge(u2), outdir + "u2.brep");
		OCCTIO::OCCTTool::Write(MakeEdge(c1), outdir + "c1.brep");
		OCCTIO::OCCTTool::Write(MakeEdge(c2), outdir + "c2.brep");
		OCCTIO::OCCTTool::Write(MakeFace(surface1, 0.0), outdir + "src1.brep");
		OCCTIO::OCCTTool::Write(MakeFace(surface2, 0.0), outdir + "src2.brep");
		OCCTIO::OCCTTool::Write(MakeFace(bsp3, 0.0), outdir + "result.brep");
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static std::shared_ptr<Geom3BSplineSurface> BlendFaces( const TopoFace& face1, const TopoEdge& edge1, ContinuityType cont1, std::vector<double>& parameters1, const TopoFace& face2, const TopoEdge& edge2, ContinuityType cont2, std::vector<double>& parameters2, bool autoReverse, bool isPrecise, const std::vector<double>& tol),
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <nurbs/NURBSAPIBlend.hpp>
#include <modeling/MakeEdge.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
#include <modeling/MakeVertex.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <modeling/MakeFace.hpp>
#include <topology/BRepAdaptorCurve3.hpp>
#include <topology/TopoTool.hpp>
#include <io/ShapeTool.hpp>
#include <topology/TopoTool.hpp>
#include <topology/TopoCast.hpp>
#include <geometry/Geom3Surface.hpp>
#include <geometry/Geom3BSplineSurface.hpp>
#include <nurbs/NURBSAPIConvert.hpp>
#include <nurbs/NURBSAPIGetGeometry.hpp>
#include <topology/TopoExplorer.hpp>
#include <topology/TopoExplorerTool.hpp>
double NURBSSampleEdge(int num, double tol, const shared_ptr<Geom3Curve>& curve, const TopoEdge& edge)
{
	double fpu1 = curve->FirstParameter();
	double lpu1 = curve->LastParameter();
	double delta = (lpu1 - fpu1) / num;
	Point3 p;
	int n = 0;
	for (int i = 0; i < num; i++) {
		double t = fpu1 + i * delta;
		curve->D0(t, p);
		if (BRepClassificationTools::IsPointInOnEdge(edge, p, tol))
		{
			n++;
		}
	}
	double r1 = 1.0 * (num - n) / num;
	return r1;
}
TopoEdge ChooseSimilarEdge(const TopoShape& shape, const TopoEdge& edge)
{
	int nsample = 1000;
	Point3 p1, p2;
	BRepAdaptorCurve3 refC(edge);
	double refFp = refC.FirstParameter();
	double refLp = refC.LastParameter();
	for (TopoExplorer ex(shape, ShapeType::Edge); ex.More(); ex.Next())
	{
		const TopoEdge& cre = static_cast<const TopoEdge&>((ex.Current()));
		BRepAdaptorCurve3 crC(edge);
		double crFp = crC.FirstParameter();
		double crLp = crC.LastParameter();
		if (std::abs(refFp - crFp) < 0.001 && std::abs(refLp - crLp) < 0.001)
		{
			bool isOK = true;
			for (int i = 0; i < nsample; i++)
			{
				double t1 = refFp + i * (refLp - refFp) / (nsample - 1);
				double t2 = crFp + i * (crLp - crFp) / (nsample - 1);
				refC.D0(t1, p1);
				crC.D0(t2, p2);
				if (p1.Distance(p2) > 0.001)
				{
					isOK = false;
					break;
				}
			}
			if (isOK)
			{
				return cre;
			}
		}
	}
	TopoEdge e;
	return e;
}
TEST_CASE("bug1: TestBridgeTrimmedPeriodicFace ", "[nurbs][Blend][fixbug]")
{
	std::string filedir = INPUT_PATH_PREFIX "/TestNURBS/TestBridgeTrimmedPeriodicFaces/";
	TopoFace f1 = ReadBRepFace(filedir + "face1.brep");
	TopoFace f2 = ReadBRepFace(filedir + "face2.brep");
	Point3 p1 = ReadBRepPoint(filedir + "pt1.brep");
	Point3 p2 = ReadBRepPoint(filedir + "pt2.brep");
	auto [d1, e1] = NearestEdge(p1, f1);
	auto [d2, e2] = NearestEdge(p2, f2);
	ContinuityType cont1 = ContinuityType::G2;
	ContinuityType cont2 = ContinuityType::G2;
	bool isPrecise = true;
	std::vector<double> tol;
	tol.push_back(0.001);
	tol.push_back(0.01);
	tol.push_back(0.01);
	std::vector<double> params(2, 1.0);
	bool autoReverse = true;
	auto result = NURBSAPIBlend::BlendFaces(f1, e1, cont1, params, f2, e2, cont2, params, autoReverse, isPrecise, tol);
	BRepExtremaDistShapeShape dist1(f1, MakeFace(result, 0.0));
	BRepExtremaDistShapeShape dist2(f2, MakeFace(result, 0.0));
	CHECK(dist1.Value() == Approx(0.0).margin(0.1));
	CHECK(dist2.Value() == Approx(0.0).margin(0.1));
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static std::shared_ptr<Geom3BSplineCurve> BlendCurves( const std::shared_ptr<Geom3BSplineCurve>& curve1, bool isFront1, ContinuityType cont1, const std::shared_ptr<Geom3BSplineCurve>& curve2, bool isFront2, ContinuityType cont2),
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <nurbs/NURBSAPIBlend.hpp>
#include <modeling/MakeEdge.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
#include <modeling/MakeVertex.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <modeling/MakeFace.hpp>
#include <topology/BRepAdaptorCurve3.hpp>
#include <topology/TopoTool.hpp>
#include <io/ShapeTool.hpp>
#include <topology/TopoTool.hpp>
#include <topology/TopoCast.hpp>
#include <geometry/Geom3Surface.hpp>
#include <geometry/Geom3BSplineSurface.hpp>
#include <nurbs/NURBSAPIConvert.hpp>
#include <nurbs/NURBSAPIGetGeometry.hpp>
#include <topology/TopoExplorer.hpp>
#include <topology/TopoExplorerTool.hpp>
#include <geometry/Geom3CurveLocalProperty.hpp>
#include<catch.hpp>
#include<testHelper.h>
#include <nurbs/NURBSAPIBlend.hpp>
#include <modeling/MakeEdge.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
#include <modeling/MakeVertex.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <modeling/MakeFace.hpp>
#include <topology/BRepAdaptorCurve3.hpp>
#include <topology/TopoTool.hpp>
#include <io/ShapeTool.hpp>
#include <topology/TopoTool.hpp>
#include <topology/TopoCast.hpp>
#include <geometry/Geom3Surface.hpp>
#include <geometry/Geom3BSplineSurface.hpp>
#include <nurbs/NURBSAPIConvert.hpp>
#include <nurbs/NURBSAPIGetGeometry.hpp>
#include <topology/TopoExplorer.hpp>
#include <topology/TopoExplorerTool.hpp>
#include <geometry/Geom3CurveLocalProperty.hpp>
;
	SECTION("ContinuityType::C0")
	{
		auto cont1 = ContinuityType::C0;
		auto cont2 = ContinuityType::C0;
		SECTION("true+true")
		{
			OUTPUT_DIRECTORY(nurbs, Blend/Extend/BlendCurves1/C0/tt);
			bool isFront1 = true;
			bool isFront2 = true;
			auto bsp3 = NURBSAPIBlend::BlendCurves(bsp1, isFront1, cont1, bsp2, isFront2, cont2);
			Point3 sp3 = bsp3->StartPoint();
			Point3 ep3 = bsp3->EndPoint();
			CHECK(sp3.X() == Approx(sp1.X()).margin(1e-7));
			CHECK(sp3.Y() == Approx(sp1.Y()));
			CHECK(sp3.Z() == Approx(sp1.Z()));
			CHECK(ep3.X() == Approx(sp2.X()).margin(1e-7));
			CHECK(ep3.Y() == Approx(sp2.Y()).margin(1e-7));
			CHECK(ep3.Z() == Approx(sp2.Z()).margin(1e-7));
			OCCTIO::OCCTTool::Write(MakeVertex(sp1), outdir + "sp1.brep");
			OCCTIO::OCCTTool::Write(MakeVertex(ep1), outdir + "ep1.brep");
			OCCTIO::OCCTTool::Write(MakeVertex(sp2), outdir + "sp2.brep");
			OCCTIO::OCCTTool::Write(MakeVertex(ep2), outdir + "ep2.brep");
			OCCTIO::OCCTTool::Write(MakeVertex(sp3), outdir + "sp3.brep");
			OCCTIO::OCCTTool::Write(MakeVertex(ep3), outdir + "ep3.brep");
			OCCTIO::OCCTTool::Write(MakeEdge(bsp1), outdir + "src1.brep");
			OCCTIO::OCCTTool::Write(MakeEdge(bsp2), outdir + "src2.brep");
			OCCTIO::OCCTTool::Write(MakeEdge(bsp3), outdir + "result.brep");
		}
		SECTION("false+true")
		{
			OUTPUT_DIRECTORY(nurbs, Blend/Extend/BlendCurves1/C0/ft);
			bool isFront1 = false;
			bool isFront2 = true;
			auto bsp3 = NURBSAPIBlend::BlendCurves(bsp1, isFront1, cont1, bsp2, isFront2, cont2);
			Point3 sp3 = bsp3->StartPoint();
			Point3 ep3 = bsp3->EndPoint();
			CHECK(sp3.X() == Approx(ep1.X()).margin(1e-7));
			CHECK(sp3.Y() == Approx(ep1.Y()));
			CHECK(sp3.Z() == Approx(ep1.Z()));
			CHECK(ep3.X() == Approx(sp2.X()).margin(1e-7));
			CHECK(ep3.Y() == Approx(sp2.Y()).margin(1e-7));
			CHECK(ep3.Z() == Approx(sp2.Z()).margin(1e-7));
			OCCTIO::OCCTTool::Write(MakeVertex(sp1), outdir + "sp1.brep");
			OCCTIO::OCCTTool::Write(MakeVertex(ep1), outdir + "ep1.brep");
			OCCTIO::OCCTTool::Write(MakeVertex(sp2), outdir + "sp2.brep");
			OCCTIO::OCCTTool::Write(MakeVertex(ep2), outdir + "ep2.brep");
			OCCTIO::OCCTTool::Write(MakeVertex(sp3), outdir + "sp3.brep");
			OCCTIO::OCCTTool::Write(MakeVertex(ep3), outdir + "ep3.brep");
			OCCTIO::OCCTTool::Write(MakeEdge(bsp1), outdir + "src1.brep");
			OCCTIO::OCCTTool::Write(MakeEdge(bsp2), outdir + "src2.brep");
			OCCTIO::OCCTTool::Write(MakeEdge(bsp3), outdir + "result.brep");
		}
		SECTION("true+false")
		{
			OUTPUT_DIRECTORY(nurbs, Blend/Extend/BlendCurves1/C0/tf);
			bool isFront1 = true;
			bool isFront2 = false;
			auto bsp3 = NURBSAPIBlend::BlendCurves(bsp1, isFront1, cont1, bsp2, isFront2, cont2);
			Point3 sp3 = bsp3->StartPoint();
			Point3 ep3 = bsp3->EndPoint();
			CHECK(sp3.X() == Approx(sp1.X()).margin(1e-7));
			CHECK(sp3.Y() == Approx(sp1.Y()));
			CHECK(sp3.Z() == Approx(sp1.Z()));
			CHECK(ep3.X() == Approx(ep2.X()).margin(1e-7));
			CHECK(ep3.Y() == Approx(ep2.Y()).margin(1e-7));
			CHECK(ep3.Z() == Approx(ep2.Z()).margin(1e-7));
			OCCTIO::OCCTTool::Write(MakeVertex(sp1), outdir + "sp1.brep");
			OCCTIO::OCCTTool::Write(MakeVertex(ep1), outdir + "ep1.brep");
			OCCTIO::OCCTTool::Write(MakeVertex(sp2), outdir + "sp2.brep");
			OCCTIO::OCCTTool::Write(MakeVertex(ep2), outdir + "ep2.brep");
			OCCTIO::OCCTTool::Write(MakeVertex(sp3), outdir + "sp3.brep");
			OCCTIO::OCCTTool::Write(MakeVertex(ep3), outdir + "ep3.brep");
			OCCTIO::OCCTTool::Write(MakeEdge(bsp1), outdir + "src1.brep");
			OCCTIO::OCCTTool::Write(MakeEdge(bsp2), outdir + "src2.brep");
			OCCTIO::OCCTTool::Write(MakeEdge(bsp3), outdir + "result.brep");
		}
		SECTION("false+false")
		{
			OUTPUT_DIRECTORY(nurbs, Blend/Extend/BlendCurves1/C0/ff);
			bool isFront1 = false;
			bool isFront2 = false;
			auto bsp3 = NURBSAPIBlend::BlendCurves(bsp1, isFront1, cont1, bsp2, isFront2, cont2);
			Point3 sp3 = bsp3->StartPoint();
			Point3 ep3 = bsp3->EndPoint();
			CHECK(sp3.X() == Approx(ep1.X()).margin(1e-7));
			CHECK(sp3.Y() == Approx(ep1.Y()));
			CHECK(sp3.Z() == Approx(ep1.Z()));
			CHECK(ep3.X() == Approx(ep2.X()).margin(1e-7));
			CHECK(ep3.Y() == Approx(ep2.Y()).margin(1e-7));
			CHECK(ep3.Z() == Approx(ep2.Z()).margin(1e-7));
			OCCTIO::OCCTTool::Write(MakeVertex(sp1), outdir + "sp1.brep");
			OCCTIO::OCCTTool::Write(MakeVertex(ep1), outdir + "ep1.brep");
			OCCTIO::OCCTTool::Write(MakeVertex(sp2), outdir + "sp2.brep");
			OCCTIO::OCCTTool::Write(MakeVertex(ep2), outdir + "ep2.brep");
			OCCTIO::OCCTTool::Write(MakeVertex(sp3), outdir + "sp3.brep");
			OCCTIO::OCCTTool::Write(MakeVertex(ep3), outdir + "ep3.brep");
			OCCTIO::OCCTTool::Write(MakeEdge(bsp1), outdir + "src1.brep");
			OCCTIO::OCCTTool::Write(MakeEdge(bsp2), outdir + "src2.brep");
			OCCTIO::OCCTTool::Write(MakeEdge(bsp3), outdir + "result.brep");
		}
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static std::shared_ptr<Geom3BSplineCurve> BlendCurves( const std::shared_ptr<Geom3BSplineCurve>& curve1, bool isFront1, ContinuityType cont1, std::vector<double>& parameters1, const std::shared_ptr<Geom3BSplineCurve>& curve2, bool isFront2, ContinuityType cont2, std::vector<double>& parameters2),
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <nurbs/NURBSAPIBlend.hpp>
#include <modeling/MakeEdge.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
#include <modeling/MakeVertex.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <modeling/MakeFace.hpp>
#include <topology/BRepAdaptorCurve3.hpp>
#include <topology/TopoTool.hpp>
#include <io/ShapeTool.hpp>
#include <topology/TopoTool.hpp>
#include <topology/TopoCast.hpp>
#include <geometry/Geom3Surface.hpp>
#include <geometry/Geom3BSplineSurface.hpp>
#include <nurbs/NURBSAPIConvert.hpp>
#include <nurbs/NURBSAPIGetGeometry.hpp>
#include <topology/TopoExplorer.hpp>
#include <topology/TopoExplorerTool.hpp>
#include <geometry/Geom3CurveLocalProperty.hpp>
#include<catch.hpp>
#include<testHelper.h>
#include <nurbs/NURBSAPIBlend.hpp>
#include <modeling/MakeEdge.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
#include <modeling/MakeVertex.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <modeling/MakeFace.hpp>
#include <topology/BRepAdaptorCurve3.hpp>
#include <topology/TopoTool.hpp>
#include <io/ShapeTool.hpp>
#include <topology/TopoTool.hpp>
#include <topology/TopoCast.hpp>
#include <geometry/Geom3Surface.hpp>
#include <geometry/Geom3BSplineSurface.hpp>
#include <nurbs/NURBSAPIConvert.hpp>
#include <nurbs/NURBSAPIGetGeometry.hpp>
#include <topology/TopoExplorer.hpp>
#include <topology/TopoExplorerTool.hpp>
#include <geometry/Geom3CurveLocalProperty.hpp>
;
	SECTION("false+true")
	{
		OUTPUT_DIRECTORY(nurbs, Blend/Extend/bug792);
		bool isFront1 = false;
		bool isFront2 = true;
		auto bsp3 = NURBSAPIBlend::BlendCurves(bsp1, isFront1, cont1, params1, bsp2, isFront2, cont2, params2);
		double fp3 = bsp3->FirstParameter();
		Point3 p3;
		Vector3 sv3;
		bsp3->D1(fp3, p3, sv3);
		bool res1 = Direction3(sv3).IsParallel(Direction3(ev1), Precision::Angular());
		CHECK(res1 == true);
		OCCTIO::OCCTTool::Write(MakeVertex(p3), outdir + "p3.brep");
		OCCTIO::OCCTTool::Write(MakeVertex(pp1), outdir + "pp1.brep");
		OCCTIO::OCCTTool::Write(MakeEdge(bsp1), outdir + "src1.brep");
		OCCTIO::OCCTTool::Write(MakeEdge(bsp2), outdir + "src2.brep");
		OCCTIO::OCCTTool::Write(MakeEdge(bsp3), outdir + "result.brep");
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static std::shared_ptr<Geom3BSplineSurface> BlendSurfaces( const std::shared_ptr<Geom3BSplineSurface>& surf1, bool isUIso1, bool isFront1, ContinuityType cont1, std::vector<double>& parameters1, const std::shared_ptr<Geom3BSplineSurface>& surf2, bool isUIso2, bool isFront2, ContinuityType cont2, std::vector<double>& parameters2, bool autoReverse, bool isPrecise, const std::vector<double>& tol),
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <nurbs/NURBSAPIBlend.hpp>
#include <modeling/MakeEdge.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
#include <modeling/MakeVertex.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <modeling/MakeFace.hpp>
#include <topology/BRepAdaptorCurve3.hpp>
#include <topology/TopoTool.hpp>
#include <io/ShapeTool.hpp>
#include <topology/TopoTool.hpp>
#include <topology/TopoCast.hpp>
#include <geometry/Geom3Surface.hpp>
#include <geometry/Geom3BSplineSurface.hpp>
#include <nurbs/NURBSAPIConvert.hpp>
#include <nurbs/NURBSAPIGetGeometry.hpp>
#include <topology/TopoExplorer.hpp>
#include <topology/TopoExplorerTool.hpp>
#include <geometry/Geom3CurveLocalProperty.hpp>
#include <geometry/GeomAPIProjectPointOnCurve3.hpp>
double NURBSSampleEdge1(int num, double tol, const shared_ptr<Geom3Curve>& curve, const TopoEdge& edge)
{
	double fpu1 = curve->FirstParameter();
	double lpu1 = curve->LastParameter();
	double delta = (lpu1 - fpu1) / num;
	Point3 p;
	int n = 0;
	for (int i = 0; i < num; i++) {
		double t = fpu1 + i * delta;
		curve->D0(t, p);
		if (BRepClassificationTools::IsPointInOnEdge(edge, p, tol))
		{
			n++;
		}
	}
	double r1 = 1.0 * (num - n) / num;
	return r1;
}
TopoEdge ChooseSimilarEdge1(const TopoShape& shape, const TopoEdge& edge)
{
	int nsample = 1000;
	Point3 p1, p2;
	BRepAdaptorCurve3 refC(edge);
	double refFp = refC.FirstParameter();
	double refLp = refC.LastParameter();
	for (TopoExplorer ex(shape, ShapeType::Edge); ex.More(); ex.Next())
	{
		const TopoEdge& cre = static_cast<const TopoEdge&>((ex.Current()));
		BRepAdaptorCurve3 crC(edge);
		double crFp = crC.FirstParameter();
		double crLp = crC.LastParameter();
		if (std::abs(refFp - crFp) < 0.001 && std::abs(refLp - crLp) < 0.001)
		{
			bool isOK = true;
			for (int i = 0; i < nsample; i++)
			{
				double t1 = refFp + i * (refLp - refFp) / (nsample - 1);
				double t2 = crFp + i * (crLp - crFp) / (nsample - 1);
				refC.D0(t1, p1);
				crC.D0(t2, p2);
				if (p1.Distance(p2) > 0.001)
				{
					isOK = false;
					break;
				}
			}
			if (isOK)
			{
				return cre;
			}
		}
	}
	TopoEdge e;
	return e;
}
#include<catch.hpp>
#include<testHelper.h>
#include <nurbs/NURBSAPIBlend.hpp>
#include <modeling/MakeEdge.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
#include <modeling/MakeVertex.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <modeling/MakeFace.hpp>
#include <topology/BRepAdaptorCurve3.hpp>
#include <topology/TopoTool.hpp>
#include <io/ShapeTool.hpp>
#include <topology/TopoTool.hpp>
#include <topology/TopoCast.hpp>
#include <geometry/Geom3Surface.hpp>
#include <geometry/Geom3BSplineSurface.hpp>
#include <nurbs/NURBSAPIConvert.hpp>
#include <nurbs/NURBSAPIGetGeometry.hpp>
#include <topology/TopoExplorer.hpp>
#include <topology/TopoExplorerTool.hpp>
#include <geometry/Geom3CurveLocalProperty.hpp>
#include <geometry/GeomAPIProjectPointOnCurve3.hpp>
double NURBSSampleEdge1(int num, double tol, const shared_ptr<Geom3Curve>& curve, const TopoEdge& edge)
{
	double fpu1 = curve->FirstParameter();
	double lpu1 = curve->LastParameter();
	double delta = (lpu1 - fpu1) / num;
	Point3 p;
	int n = 0;
	for (int i = 0; i < num; i++) {
		double t = fpu1 + i * delta;
		curve->D0(t, p);
		if (BRepClassificationTools::IsPointInOnEdge(edge, p, tol))
		{
			n++;
		}
	}
	double r1 = 1.0 * (num - n) / num;
	return r1;
}
TopoEdge ChooseSimilarEdge1(const TopoShape& shape, const TopoEdge& edge)
{
	int nsample = 1000;
	Point3 p1, p2;
	BRepAdaptorCurve3 refC(edge);
	double refFp = refC.FirstParameter();
	double refLp = refC.LastParameter();
	for (TopoExplorer ex(shape, ShapeType::Edge); ex.More(); ex.Next())
	{
		const TopoEdge& cre = static_cast<const TopoEdge&>((ex.Current()));
		BRepAdaptorCurve3 crC(edge);
		double crFp = crC.FirstParameter();
		double crLp = crC.LastParameter();
		if (std::abs(refFp - crFp) < 0.001 && std::abs(refLp - crLp) < 0.001)
		{
			bool isOK = true;
			for (int i = 0; i < nsample; i++)
			{
				double t1 = refFp + i * (refLp - refFp) / (nsample - 1);
				double t2 = crFp + i * (crLp - crFp) / (nsample - 1);
				refC.D0(t1, p1);
				crC.D0(t2, p2);
				if (p1.Distance(p2) > 0.001)
				{
					isOK = false;
					break;
				}
			}
			if (isOK)
			{
				return cre;
			}
		}
	}
	TopoEdge e;
	return e;
;
	SECTION("ContinuityType::C0")
	{
		ContinuityType cont1 = ContinuityType::C0;
		ContinuityType cont2 = ContinuityType::C0;
		bool isU1 = false;
		bool isU2 = false;
		SECTION("isFront:true+true")
		{
			bool isFront1 = true;
			bool isFront2 = true;
			CHECK_THROWS_AS(NURBSAPIBlend::BlendSurfaces(surf1, isU1, isFront1, cont1, params1, surf2, isU2, isFront2, cont2, params2, isAutoReverse, isPrecise, tol), _DomainError);
		}
		SECTION("isFront:false+true")
		{
			bool isFront1 = false;
			bool isFront2 = true;
			CHECK_THROWS_AS(NURBSAPIBlend::BlendSurfaces(surf1, isU1, isFront1, cont1, params1, surf2, isU2, isFront2, cont2, params2, isAutoReverse, isPrecise, tol), _DomainError);
		}
		SECTION("isFront:true+false")
		{
			bool isFront1 = true;
			bool isFront2 = false;
			CHECK_THROWS_AS(NURBSAPIBlend::BlendSurfaces(surf1, isU1, isFront1, cont1, params1, surf2, isU2, isFront2, cont2, params2, isAutoReverse, isPrecise, tol), _DomainError);
		}
		SECTION("isFront:false+false")
		{
			bool isFront1 = false;
			bool isFront2 = false;
			CHECK_THROWS_AS(NURBSAPIBlend::BlendSurfaces(surf1, isU1, isFront1, cont1, params1, surf2, isU2, isFront2, cont2, params2, isAutoReverse, isPrecise, tol), _DomainError);
		}
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static std::shared_ptr<Geom3BSplineCurve> BuildCurve(const std::vector<Point3>& poles, int degree, bool isPeriodic)	 @return The built curve. If building curve is failed, return nullptr
	 @param isPeriodic Whether the curve is periodic or not
	 @param degree The curve degree
	 @param poles Curve poles. If it is a periodic curve, don't include the point at the end that repeats the first point
	 @brief Build BSpline curve
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <nurbs/NURBSAPIBuildCurve.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeVertex.hpp>
#include <nurbs/NURBSAPIExtend.hpp>
#include <geomAlgo/LawConstant.hpp>
#include <nurbs/NURBSAPILinearSweep.hpp>
#include <modeling/MakeFace.hpp>
std::shared_ptr<AMCAX::Geom3BSplineCurve> BuildBSpCurve(const std::vector<AMCAX::Point3>& poles, int degree, bool isPeriodic)
{
	int npoles = static_cast<int>(poles.size());
	if (isPeriodic)
	{
		return AMCAX::NURBSAPIBuildCurve::BuildCurve(poles, std::min(degree, npoles), true);
	}
	else
	{
		return AMCAX::NURBSAPIBuildCurve::BuildCurve(poles, std::min(degree, npoles - 1), false);
	}
}
#include<catch.hpp>
#include<testHelper.h>
#include <nurbs/NURBSAPIBuildCurve.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeVertex.hpp>
#include <nurbs/NURBSAPIExtend.hpp>
#include <geomAlgo/LawConstant.hpp>
#include <nurbs/NURBSAPILinearSweep.hpp>
#include <modeling/MakeFace.hpp>
std::shared_ptr<AMCAX::Geom3BSplineCurve> BuildBSpCurve(const std::vector<AMCAX::Point3>& poles, int degree, bool isPeriodic)
{
	int npoles = static_cast<int>(poles.size());
	if (isPeriodic)
	{
		return AMCAX::NURBSAPIBuildCurve::BuildCurve(poles, std::min(degree, npoles), true);
	}
	else
	{
		return AMCAX::NURBSAPIBuildCurve::BuildCurve(poles, std::min(degree, npoles - 1), false);
	}
;
	SECTION("TestBuildCurve()")
	{
		OUTPUT_DIRECTORY(nurbs, BuildCurve/BuildCurve);
		std::vector<Point3> poles;
		Point3 p1(0.0, 0.0, 0.0);
		Point3 p2(-0.1, 1.0, -0.2);
		Point3 p3(0.1, 2.0, -0.1);
		Point3 p4(0.2, 3.0, 0.1);
		Point3 p5(0.1, 4.0, 0.0);
		Point3 p6(0.0, 5.0, -0.1);
		poles.push_back(p1);
		poles.push_back(p2);
		poles.push_back(p3);
		poles.push_back(p4);
		poles.push_back(p5);
		poles.push_back(p6);
		bool isPeriodic = false;
		int degree = NURBSAPIBuildCurve::ValidMaxDegree(static_cast<int>(poles.size()), isPeriodic);
		degree = std::min(3, degree);
		auto curve = NURBSAPIBuildCurve::BuildCurve(poles, degree, isPeriodic);
		Point3 sp1 = curve->StartPoint();
		Point3 ep1 = curve->EndPoint();
		CHECK(sp1.X() == Approx(p1.X()));
		CHECK(sp1.Y() == Approx(p1.Y()));
		CHECK(sp1.Z() == Approx(p1.Z()));
		CHECK(ep1.X() == Approx(p6.X()).margin(1e-7));
		CHECK(ep1.Y() == Approx(p6.Y()).margin(1e-7));
		CHECK(ep1.Z() == Approx(p6.Z()).margin(1e-7));
		CHECK(curve->Degree() == degree);
		CHECK(curve->NPoles() == 6);
		CHECK(curve->IsPeriodic() == false);
		vector<Point3> vec = curve->Poles();
		CHECK(vec.size() == 6);
		CHECK(vec[0].X() == Approx(p1.X()));
		CHECK(vec[0].Y() == Approx(p1.Y()));
		CHECK(vec[0].Z() == Approx(p1.Z()));
		CHECK(vec[1].X() == Approx(p2.X()));
		CHECK(vec[1].Y() == Approx(p2.Y()));
		CHECK(vec[1].Z() == Approx(p2.Z()));
		CHECK(vec[2].X() == Approx(p3.X()));
		CHECK(vec[2].Y() == Approx(p3.Y()));
		CHECK(vec[2].Z() == Approx(p3.Z()));
		CHECK(vec[3].X() == Approx(p4.X()));
		CHECK(vec[3].Y() == Approx(p4.Y()));
		CHECK(vec[3].Z() == Approx(p4.Z()));
		CHECK(vec[4].X() == Approx(p5.X()));
		CHECK(vec[4].Y() == Approx(p5.Y()));
		CHECK(vec[4].Z() == Approx(p5.Z()));
		CHECK(vec[5].X() == Approx(p6.X()));
		CHECK(vec[5].Y() == Approx(p6.Y()));
		CHECK(vec[5].Z() == Approx(p6.Z()));
		OCCTIO::OCCTTool::Write(MakeVertex(p1), outdir + "p1.brep");
		OCCTIO::OCCTTool::Write(MakeVertex(p2), outdir + "p2.brep");
		OCCTIO::OCCTTool::Write(MakeVertex(p3), outdir + "p3.brep");
		OCCTIO::OCCTTool::Write(MakeVertex(p4), outdir + "p4.brep");
		OCCTIO::OCCTTool::Write(MakeVertex(p5), outdir + "p5.brep");
		OCCTIO::OCCTTool::Write(MakeVertex(p6), outdir + "p6.brep");
		OCCTIO::OCCTTool::Write(MakeEdge(curve), outdir + "result.brep");
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static std::shared_ptr<Geom3BSplineCurve> BuildCurve(const std::vector<Point3>& poles, const std::vector<double>& weights, int degree, bool isPeriodic)	 @return The built curve. If building curve is failed, return nullptr
	 @param isPeriodic Whether the curve is periodic or not
	 @param degree The curve degree
	 @param weights Curve weights
	 @param poles Curve poles. If it is a periodic curve, don't include the point at the end that repeats the first point
	 @brief Build NURBS curve
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <nurbs/NURBSAPIBuildCurve.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeVertex.hpp>
#include <nurbs/NURBSAPIExtend.hpp>
#include <geomAlgo/LawConstant.hpp>
#include <nurbs/NURBSAPILinearSweep.hpp>
#include <modeling/MakeFace.hpp>
std::shared_ptr<AMCAX::Geom3BSplineCurve> BuildBSpCurve(const std::vector<AMCAX::Point3>& poles, int degree, bool isPeriodic)
{
	int npoles = static_cast<int>(poles.size());
	if (isPeriodic)
	{
		return AMCAX::NURBSAPIBuildCurve::BuildCurve(poles, std::min(degree, npoles), true);
	}
	else
	{
		return AMCAX::NURBSAPIBuildCurve::BuildCurve(poles, std::min(degree, npoles - 1), false);
	}
}
#include<catch.hpp>
#include<testHelper.h>
#include <nurbs/NURBSAPIBuildCurve.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeVertex.hpp>
#include <nurbs/NURBSAPIExtend.hpp>
#include <geomAlgo/LawConstant.hpp>
#include <nurbs/NURBSAPILinearSweep.hpp>
#include <modeling/MakeFace.hpp>
std::shared_ptr<AMCAX::Geom3BSplineCurve> BuildBSpCurve(const std::vector<AMCAX::Point3>& poles, int degree, bool isPeriodic)
{
	int npoles = static_cast<int>(poles.size());
	if (isPeriodic)
	{
		return AMCAX::NURBSAPIBuildCurve::BuildCurve(poles, std::min(degree, npoles), true);
	}
	else
	{
		return AMCAX::NURBSAPIBuildCurve::BuildCurve(poles, std::min(degree, npoles - 1), false);
	}
;
	SECTION("TestBuildCurve()")
	{
		OUTPUT_DIRECTORY(nurbs, BuildCurve/BuildCurve);
		std::vector<Point3> poles;
		Point3 p1(0.0, 0.0, 0.0);
		Point3 p2(-0.1, 1.0, -0.2);
		Point3 p3(0.1, 2.0, -0.1);
		Point3 p4(0.2, 3.0, 0.1);
		Point3 p5(0.1, 4.0, 0.0);
		Point3 p6(0.0, 5.0, -0.1);
		poles.push_back(p1);
		poles.push_back(p2);
		poles.push_back(p3);
		poles.push_back(p4);
		poles.push_back(p5);
		poles.push_back(p6);
		bool isPeriodic = false;
		int degree = NURBSAPIBuildCurve::ValidMaxDegree(static_cast<int>(poles.size()), isPeriodic);
		degree = std::min(3, degree);
		auto curve = NURBSAPIBuildCurve::BuildCurve(poles, degree, isPeriodic);
		Point3 sp1 = curve->StartPoint();
		Point3 ep1 = curve->EndPoint();
		CHECK(sp1.X() == Approx(p1.X()));
		CHECK(sp1.Y() == Approx(p1.Y()));
		CHECK(sp1.Z() == Approx(p1.Z()));
		CHECK(ep1.X() == Approx(p6.X()).margin(1e-7));
		CHECK(ep1.Y() == Approx(p6.Y()).margin(1e-7));
		CHECK(ep1.Z() == Approx(p6.Z()).margin(1e-7));
		CHECK(curve->Degree() == degree);
		CHECK(curve->NPoles() == 6);
		CHECK(curve->IsPeriodic() == false);
		vector<Point3> vec = curve->Poles();
		CHECK(vec.size() == 6);
		CHECK(vec[0].X() == Approx(p1.X()));
		CHECK(vec[0].Y() == Approx(p1.Y()));
		CHECK(vec[0].Z() == Approx(p1.Z()));
		CHECK(vec[1].X() == Approx(p2.X()));
		CHECK(vec[1].Y() == Approx(p2.Y()));
		CHECK(vec[1].Z() == Approx(p2.Z()));
		CHECK(vec[2].X() == Approx(p3.X()));
		CHECK(vec[2].Y() == Approx(p3.Y()));
		CHECK(vec[2].Z() == Approx(p3.Z()));
		CHECK(vec[3].X() == Approx(p4.X()));
		CHECK(vec[3].Y() == Approx(p4.Y()));
		CHECK(vec[3].Z() == Approx(p4.Z()));
		CHECK(vec[4].X() == Approx(p5.X()));
		CHECK(vec[4].Y() == Approx(p5.Y()));
		CHECK(vec[4].Z() == Approx(p5.Z()));
		CHECK(vec[5].X() == Approx(p6.X()));
		CHECK(vec[5].Y() == Approx(p6.Y()));
		CHECK(vec[5].Z() == Approx(p6.Z()));
		OCCTIO::OCCTTool::Write(MakeVertex(p1), outdir + "p1.brep");
		OCCTIO::OCCTTool::Write(MakeVertex(p2), outdir + "p2.brep");
		OCCTIO::OCCTTool::Write(MakeVertex(p3), outdir + "p3.brep");
		OCCTIO::OCCTTool::Write(MakeVertex(p4), outdir + "p4.brep");
		OCCTIO::OCCTTool::Write(MakeVertex(p5), outdir + "p5.brep");
		OCCTIO::OCCTTool::Write(MakeVertex(p6), outdir + "p6.brep");
		OCCTIO::OCCTTool::Write(MakeEdge(curve), outdir + "result.brep");
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static std::pair<NURBSSweepStatus, std::shared_ptr<Geom3BSplineSurface>> SweepWithThreeGuides(const std::shared_ptr<Geom3BSplineCurve>& guide1, const std::shared_ptr<Geom3BSplineCurve>& guide2, const std::shared_ptr<Geom3BSplineCurve>& guide3, const std::shared_ptr<Geom3BSplineCurve>& spine, double spineLeftBound, double spineRightBound),
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <filesystem>
#include <fstream>
#include <random>
#include <sstream>
#include <nurbs/NURBSAPIGetGeometry.hpp>
#include <nurbs/NURBSAPIConicalSweep.hpp>
#include <boolean/BoolBRepCut.hpp>
#include <common/CartesianCoordinateSystem.hpp>
#include <common/IndexMap.hpp>
#include <common/QuaternionT.hpp>
#include <geomAlgo/LawBSpline.hpp>
#include <geomAlgo/LawConstant.hpp>
#include <nurbs/NURBSAPISmooth.hpp>
#include <geomAlgo/MakeConic2FromConstraints.hpp>
#include <geometry/Adaptor3CurveOnSurface.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/AdaptorGeom3Surface.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/Geom2Circle.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/Geom2Hyperbola.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom3BSplineCurve.hpp>
#include <geometry/Geom3BSplineSurface.hpp>
#include <geometry/Geom3Circle.hpp>
#include <geometry/Geom3Line.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
#include <geometry/Geom3Plane.hpp>
#include <geometry/Geom3SphericalSurface.hpp>
#include <geometry/Geom3Surface.hpp>
#include <geometry/Geom3TrimmedCurve.hpp>
#include <geometry/Geom3TrimmedSurface.hpp>
#include <geometry/GeomAPIExtremaCurveCurve3.hpp>
#include <geometry/GeomAPIProjectPointOnCurve2.hpp>
#include <geometry/GeomAPIProjectPointOnCurve3.hpp>
#include <geometry/GeomAPIProjectPointOnSurface.hpp>
#include <geometry/GeometryTool.hpp>
#include <geometry/GlobalProperty.hpp>
#include <healing/ShapeFixTool.hpp>
#include <io/STLTool.hpp>
#include <math/Sphere.hpp>
#include <math/TriangularMesh.hpp>
#include <modeling/CopyShape.hpp>
#include <modeling/MakeBox.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeFace.hpp>
#include <modeling/MakePrism.hpp>
#include <modeling/MakeRevol.hpp>
#include <modeling/MakeShapeTool.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeWire.hpp>
#include <modeling/TransformShape.hpp>
#include <nurbs/NURBSAPIApprox.hpp>
#include <nurbs/NURBSAPIBuildCurve.hpp>
#include <nurbs/NURBSAPICircularSweep.hpp>
#include <nurbs/NURBSAPIConvert.hpp>
#include <nurbs/NURBSAPICurveNetworkSurface.hpp>
#include <nurbs/NURBSAPIExplicitSweep.hpp>
#include <nurbs/NURBSAPIExplode.hpp>
#include <nurbs/NURBSAPIExtend.hpp>
#include <nurbs/NURBSAPIInterpolate.hpp>
#include <nurbs/NURBSAPIJoin.hpp>
#include <nurbs/NURBSAPILinearSweep.hpp>
#include <nurbs/NURBSAPILoft.hpp>
#include <nurbs/NURBSAPIMakeNURBSFromBoundaries.hpp>
#include <nurbs/NURBSAPIMatch.hpp>
#include <nurbs/NURBSAPIModifyEndToPlane.hpp>
#include <nurbs/NURBSAPIOffsetCurveOnSurface.hpp>
#include <nurbs/NURBSAPIProject.hpp>
#include <nurbs/NURBSAPIRebuild.hpp>
#include <nurbs/NURBSAPIReplaceEdge.hpp>
#include <nurbs/NURBSAPISweep.hpp>
#include <nurbs/NURBSAPISweep2.hpp>
#include <nurbs/NURBSAPISweepRotation.hpp>
#include <nurbs/NURBSAPITrim.hpp>
#include <nurbs/NURBSAPIUntrim.hpp>
#include <nurbs/NURBSLinearSweepWithDraftDirectionLength.hpp>
#include <occtio/OCCTTool.hpp>
#include <offset/MakePipe.hpp>
#include <offset/MakePipeShell.hpp>
#include <topology/BRepAdaptorCurve2.hpp>
#include <topology/BRepAdaptorCurve3.hpp>
#include <topology/BRepAdaptorSurface.hpp>
#include <topology/BRepGlobalProperty.hpp>
#include <topology/BRepTool.hpp>
#include <topology/TopoBuilder.hpp>
#include <topology/TopoCompound.hpp>
#include <topology/TopoEdge.hpp>
#include <topology/TopoExplorer.hpp>
#include <topology/TopoExplorerTool.hpp>
#include <topology/TopoFace.hpp>
#include <topology/TopoShape.hpp>
#include <topology/TopoShell.hpp>
#include <topology/TopoTool.hpp>
#include <topology/TopoVertex.hpp>
#include <topology/TopoWire.hpp>
#include <topology/WireExplorer.hpp>
#include <topomesh/BRepMeshIncrementalMesh.hpp>
#include <nurbs/NURBSAPIBlend.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
#include <math/LineT.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/GeomAPIIntSurfaceSurface.hpp>
using namespace AMCAX;
namespace
{
	std::shared_ptr<Geom3BSplineCurve> CurveChooser(const int id, const std::shared_ptr<Geom3BSplineCurve>& curve0, const std::shared_ptr<Geom3BSplineCurve>& curve1, const std::shared_ptr<Geom3BSplineCurve>& curve2)
	{
		std::shared_ptr<Geom3BSplineCurve> result;
		switch (id)
		{
		case 0:
		{
			result = curve0;
			break;
		}
		case 1:
		{
			result = curve1;
			break;
		}
		case 2:
		{
			result = curve2;
			break;
		}
		}
		return result;
	}
} 
#include<catch.hpp>
#include<testHelper.h>
#include <filesystem>
#include <fstream>
#include <random>
#include <sstream>
#include <nurbs/NURBSAPIGetGeometry.hpp>
#include <nurbs/NURBSAPIConicalSweep.hpp>
#include <boolean/BoolBRepCut.hpp>
#include <common/CartesianCoordinateSystem.hpp>
#include <common/IndexMap.hpp>
#include <common/QuaternionT.hpp>
#include <geomAlgo/LawBSpline.hpp>
#include <geomAlgo/LawConstant.hpp>
#include <nurbs/NURBSAPISmooth.hpp>
#include <geomAlgo/MakeConic2FromConstraints.hpp>
#include <geometry/Adaptor3CurveOnSurface.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/AdaptorGeom3Surface.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/Geom2Circle.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/Geom2Hyperbola.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom3BSplineCurve.hpp>
#include <geometry/Geom3BSplineSurface.hpp>
#include <geometry/Geom3Circle.hpp>
#include <geometry/Geom3Line.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
#include <geometry/Geom3Plane.hpp>
#include <geometry/Geom3SphericalSurface.hpp>
#include <geometry/Geom3Surface.hpp>
#include <geometry/Geom3TrimmedCurve.hpp>
#include <geometry/Geom3TrimmedSurface.hpp>
#include <geometry/GeomAPIExtremaCurveCurve3.hpp>
#include <geometry/GeomAPIProjectPointOnCurve2.hpp>
#include <geometry/GeomAPIProjectPointOnCurve3.hpp>
#include <geometry/GeomAPIProjectPointOnSurface.hpp>
#include <geometry/GeometryTool.hpp>
#include <geometry/GlobalProperty.hpp>
#include <healing/ShapeFixTool.hpp>
#include <io/STLTool.hpp>
#include <math/Sphere.hpp>
#include <math/TriangularMesh.hpp>
#include <modeling/CopyShape.hpp>
#include <modeling/MakeBox.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeFace.hpp>
#include <modeling/MakePrism.hpp>
#include <modeling/MakeRevol.hpp>
#include <modeling/MakeShapeTool.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeWire.hpp>
#include <modeling/TransformShape.hpp>
#include <nurbs/NURBSAPIApprox.hpp>
#include <nurbs/NURBSAPIBuildCurve.hpp>
#include <nurbs/NURBSAPICircularSweep.hpp>
#include <nurbs/NURBSAPIConvert.hpp>
#include <nurbs/NURBSAPICurveNetworkSurface.hpp>
#include <nurbs/NURBSAPIExplicitSweep.hpp>
#include <nurbs/NURBSAPIExplode.hpp>
#include <nurbs/NURBSAPIExtend.hpp>
#include <nurbs/NURBSAPIInterpolate.hpp>
#include <nurbs/NURBSAPIJoin.hpp>
#include <nurbs/NURBSAPILinearSweep.hpp>
#include <nurbs/NURBSAPILoft.hpp>
#include <nurbs/NURBSAPIMakeNURBSFromBoundaries.hpp>
#include <nurbs/NURBSAPIMatch.hpp>
#include <nurbs/NURBSAPIModifyEndToPlane.hpp>
#include <nurbs/NURBSAPIOffsetCurveOnSurface.hpp>
#include <nurbs/NURBSAPIProject.hpp>
#include <nurbs/NURBSAPIRebuild.hpp>
#include <nurbs/NURBSAPIReplaceEdge.hpp>
#include <nurbs/NURBSAPISweep.hpp>
#include <nurbs/NURBSAPISweep2.hpp>
#include <nurbs/NURBSAPISweepRotation.hpp>
#include <nurbs/NURBSAPITrim.hpp>
#include <nurbs/NURBSAPIUntrim.hpp>
#include <nurbs/NURBSLinearSweepWithDraftDirectionLength.hpp>
#include <occtio/OCCTTool.hpp>
#include <offset/MakePipe.hpp>
#include <offset/MakePipeShell.hpp>
#include <topology/BRepAdaptorCurve2.hpp>
#include <topology/BRepAdaptorCurve3.hpp>
#include <topology/BRepAdaptorSurface.hpp>
#include <topology/BRepGlobalProperty.hpp>
#include <topology/BRepTool.hpp>
#include <topology/TopoBuilder.hpp>
#include <topology/TopoCompound.hpp>
#include <topology/TopoEdge.hpp>
#include <topology/TopoExplorer.hpp>
#include <topology/TopoExplorerTool.hpp>
#include <topology/TopoFace.hpp>
#include <topology/TopoShape.hpp>
#include <topology/TopoShell.hpp>
#include <topology/TopoTool.hpp>
#include <topology/TopoVertex.hpp>
#include <topology/TopoWire.hpp>
#include <topology/WireExplorer.hpp>
#include <topomesh/BRepMeshIncrementalMesh.hpp>
#include <nurbs/NURBSAPIBlend.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
#include <math/LineT.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/GeomAPIIntSurfaceSurface.hpp>
using namespace AMCAX;
namespace
{
	std::shared_ptr<Geom3BSplineCurve> CurveChooser(const int id, const std::shared_ptr<Geom3BSplineCurve>& curve0, const std::shared_ptr<Geom3BSplineCurve>& curve1, const std::shared_ptr<Geom3BSplineCurve>& curve2)
	{
		std::shared_ptr<Geom3BSplineCurve> result;
		switch (id)
		{
		case 0:
		{
			result = curve0;
			break;
		}
		case 1:
		{
			result = curve1;
			break;
		}
		case 2:
		{
			result = curve2;
			break;
		}
		}
		return result;
	}
;
	SECTION("TestCircularSweepWithThreeGuides()")
	{
		std::string filedir(INPUT_PATH_PREFIX "/TestNURBS/TestCircularSweepWithThreeGuides/");
		auto guide1 = ReadBRepCurve(filedir + "guide1.brep");
		auto guide2 = ReadBRepCurve(filedir + "guide2.brep");
		auto guide3 = ReadBRepCurve(filedir + "guide3.brep");
		auto spine = ReadBRepCurve(filedir + "spine.brep");
		CHECK(OCCTIO::OCCTTool::Write(MakeEdge(guide1), OUTPUT_PATH_PREFIX "TestCircularSweepWithThreeGuides_guide1.brep"));
		CHECK(OCCTIO::OCCTTool::Write(MakeEdge(guide2), OUTPUT_PATH_PREFIX "TestCircularSweepWithThreeGuides_guide2.brep"));
		CHECK(OCCTIO::OCCTTool::Write(MakeEdge(guide3), OUTPUT_PATH_PREFIX "TestCircularSweepWithThreeGuides_guide3.brep"));
		CHECK(OCCTIO::OCCTTool::Write(MakeEdge(spine), OUTPUT_PATH_PREFIX "TestCircularSweepWithThreeGuides_spine.brep"));
		auto [status, surface] = NURBSAPICircularSweep::SweepWithThreeGuides(guide1, guide2, guide3, spine, spine->FirstParameter(), spine->LastParameter());
		CHECK(status == NURBSSweepStatus::Success);
		if (status == NURBSSweepStatus::Success && surface)
		{
			CHECK(OCCTIO::OCCTTool::Write(MakeFace(surface, 0.0), OUTPUT_PATH_PREFIX "TestCircularSweepWithThreeGuides_result.brep"));
			AMCAX::BRepExtremaDistShapeShape len1(MakeEdge(guide1), MakeFace(surface, 0.0));
			AMCAX::BRepExtremaDistShapeShape len2(MakeFace(surface, 0.0), MakeEdge(guide2));
			AMCAX::BRepExtremaDistShapeShape len3(MakeFace(surface, 0.0), MakeEdge(guide3));
			AMCAX::BRepExtremaDistShapeShape len4(MakeFace(surface, 0.0), MakeEdge(spine));
			CHECK(len1.Value() < 0.1);
			CHECK(len2.Value() < 0.1);
			CHECK(len3.Value() < 0.1);
			CHECK(IsCurveOnSurf(1000, 0.1, guide1, surface, 0.1));
			CHECK(IsCurveOnSurf(1000, 0.1, guide2, surface, 0.1));
			CHECK(IsCurveOnSurf(1000, 0.1, guide3, surface, 0.1));
			IndexSet<TopoShape> newshapeEdge1;
			TopoExplorerTool::MapShapes(MakeFace(surface, 0.0), ShapeType::Edge, newshapeEdge1);
			TopoExplorer ex0(newshapeEdge1[0], ShapeType::Edge);
			TopoExplorer ex1(newshapeEdge1[2], ShapeType::Edge);
			TopoEdge e0 = static_cast<const TopoEdge&>(ex0.Value());
			TopoEdge e1 = static_cast<const TopoEdge&>(ex1.Value());
			auto edge0 = NURBSAPIGetGeometry::GetCurve(e0);
			auto edge1 = NURBSAPIGetGeometry::GetCurve(e1);
			double n0 = NurbsSampleCurve(100, 0.1, edge0, guide1);
			double n1 = NurbsSampleCurve(100, 0.1, edge1, guide3);
			CHECK(n0 < 0.2);
			CHECK(n1 < 0.2);
		}
		spine->IncreaseDegree(5);
		guide1->IncreaseDegree(5);
		guide2->IncreaseDegree(5);
		guide3->IncreaseDegree(5);
		auto [status1, surface1] = NURBSAPICircularSweep::SweepWithThreeGuides(guide1, guide2, guide3, spine, spine->FirstParameter(), spine->LastParameter());
		CHECK(status1 == NURBSSweepStatus::Success);
		if (status1 == NURBSSweepStatus::Success && surface)
		{
			AMCAX::BRepExtremaDistShapeShape len11(MakeEdge(guide1), MakeFace(surface1, 0.0));
			AMCAX::BRepExtremaDistShapeShape len12(MakeFace(surface1, 0.0), MakeEdge(guide2));
			AMCAX::BRepExtremaDistShapeShape len13(MakeFace(surface1, 0.0), MakeEdge(guide3));
			AMCAX::BRepExtremaDistShapeShape len14(MakeFace(surface1, 0.0), MakeEdge(spine));
			CHECK(len11.Value() < 0.1);
			CHECK(len12.Value() < 0.1);
			CHECK(len13.Value() < 0.1);
			CHECK(IsCurveOnSurf(1000, 0.1, guide1, surface1, 0.1));
			CHECK(IsCurveOnSurf(1000, 0.1, guide2, surface1, 0.1));
			CHECK(IsCurveOnSurf(1000, 0.1, guide3, surface1, 0.1));
			double bsp3s = GetSurfaceProperties(MakeFace(surface1, 0.0), g, true, true);
			double bsp4s = GetSurfaceProperties(MakeFace(surface, 0.0), g, true, true);
			CHECK(bsp3s == Approx(bsp4s).margin(0.1));
		}
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static std::pair<NURBSSweepStatus, std::vector<std::shared_ptr<Geom3BSplineSurface>>> SweepWithTwoGuidesAndRadius(const std::shared_ptr<Geom3BSplineCurve>& guide1, const std::shared_ptr<Geom3BSplineCurve>& guide2, const LawFunction& radiusLaw, const std::shared_ptr<Geom3BSplineCurve>& spine, double spineLeftBound, double spineRightBound),
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <filesystem>
#include <fstream>
#include <random>
#include <sstream>
#include <nurbs/NURBSAPIGetGeometry.hpp>
#include <nurbs/NURBSAPIConicalSweep.hpp>
#include <boolean/BoolBRepCut.hpp>
#include <common/CartesianCoordinateSystem.hpp>
#include <common/IndexMap.hpp>
#include <common/QuaternionT.hpp>
#include <geomAlgo/LawBSpline.hpp>
#include <geomAlgo/LawConstant.hpp>
#include <nurbs/NURBSAPISmooth.hpp>
#include <geomAlgo/MakeConic2FromConstraints.hpp>
#include <geometry/Adaptor3CurveOnSurface.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/AdaptorGeom3Surface.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/Geom2Circle.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/Geom2Hyperbola.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom3BSplineCurve.hpp>
#include <geometry/Geom3BSplineSurface.hpp>
#include <geometry/Geom3Circle.hpp>
#include <geometry/Geom3Line.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
#include <geometry/Geom3Plane.hpp>
#include <geometry/Geom3SphericalSurface.hpp>
#include <geometry/Geom3Surface.hpp>
#include <geometry/Geom3TrimmedCurve.hpp>
#include <geometry/Geom3TrimmedSurface.hpp>
#include <geometry/GeomAPIExtremaCurveCurve3.hpp>
#include <geometry/GeomAPIProjectPointOnCurve2.hpp>
#include <geometry/GeomAPIProjectPointOnCurve3.hpp>
#include <geometry/GeomAPIProjectPointOnSurface.hpp>
#include <geometry/GeometryTool.hpp>
#include <geometry/GlobalProperty.hpp>
#include <healing/ShapeFixTool.hpp>
#include <io/STLTool.hpp>
#include <math/Sphere.hpp>
#include <math/TriangularMesh.hpp>
#include <modeling/CopyShape.hpp>
#include <modeling/MakeBox.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeFace.hpp>
#include <modeling/MakePrism.hpp>
#include <modeling/MakeRevol.hpp>
#include <modeling/MakeShapeTool.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeWire.hpp>
#include <modeling/TransformShape.hpp>
#include <nurbs/NURBSAPIApprox.hpp>
#include <nurbs/NURBSAPIBuildCurve.hpp>
#include <nurbs/NURBSAPICircularSweep.hpp>
#include <nurbs/NURBSAPIConvert.hpp>
#include <nurbs/NURBSAPICurveNetworkSurface.hpp>
#include <nurbs/NURBSAPIExplicitSweep.hpp>
#include <nurbs/NURBSAPIExplode.hpp>
#include <nurbs/NURBSAPIExtend.hpp>
#include <nurbs/NURBSAPIInterpolate.hpp>
#include <nurbs/NURBSAPIJoin.hpp>
#include <nurbs/NURBSAPILinearSweep.hpp>
#include <nurbs/NURBSAPILoft.hpp>
#include <nurbs/NURBSAPIMakeNURBSFromBoundaries.hpp>
#include <nurbs/NURBSAPIMatch.hpp>
#include <nurbs/NURBSAPIModifyEndToPlane.hpp>
#include <nurbs/NURBSAPIOffsetCurveOnSurface.hpp>
#include <nurbs/NURBSAPIProject.hpp>
#include <nurbs/NURBSAPIRebuild.hpp>
#include <nurbs/NURBSAPIReplaceEdge.hpp>
#include <nurbs/NURBSAPISweep.hpp>
#include <nurbs/NURBSAPISweep2.hpp>
#include <nurbs/NURBSAPISweepRotation.hpp>
#include <nurbs/NURBSAPITrim.hpp>
#include <nurbs/NURBSAPIUntrim.hpp>
#include <nurbs/NURBSLinearSweepWithDraftDirectionLength.hpp>
#include <occtio/OCCTTool.hpp>
#include <offset/MakePipe.hpp>
#include <offset/MakePipeShell.hpp>
#include <topology/BRepAdaptorCurve2.hpp>
#include <topology/BRepAdaptorCurve3.hpp>
#include <topology/BRepAdaptorSurface.hpp>
#include <topology/BRepGlobalProperty.hpp>
#include <topology/BRepTool.hpp>
#include <topology/TopoBuilder.hpp>
#include <topology/TopoCompound.hpp>
#include <topology/TopoEdge.hpp>
#include <topology/TopoExplorer.hpp>
#include <topology/TopoExplorerTool.hpp>
#include <topology/TopoFace.hpp>
#include <topology/TopoShape.hpp>
#include <topology/TopoShell.hpp>
#include <topology/TopoTool.hpp>
#include <topology/TopoVertex.hpp>
#include <topology/TopoWire.hpp>
#include <topology/WireExplorer.hpp>
#include <topomesh/BRepMeshIncrementalMesh.hpp>
#include <nurbs/NURBSAPIBlend.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
#include <math/LineT.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/GeomAPIIntSurfaceSurface.hpp>
using namespace AMCAX;
namespace
{
	std::shared_ptr<Geom3BSplineCurve> CurveChooser(const int id, const std::shared_ptr<Geom3BSplineCurve>& curve0, const std::shared_ptr<Geom3BSplineCurve>& curve1, const std::shared_ptr<Geom3BSplineCurve>& curve2)
	{
		std::shared_ptr<Geom3BSplineCurve> result;
		switch (id)
		{
		case 0:
		{
			result = curve0;
			break;
		}
		case 1:
		{
			result = curve1;
			break;
		}
		case 2:
		{
			result = curve2;
			break;
		}
		}
		return result;
	}
} 
#include<catch.hpp>
#include<testHelper.h>
#include <filesystem>
#include <fstream>
#include <random>
#include <sstream>
#include <nurbs/NURBSAPIGetGeometry.hpp>
#include <nurbs/NURBSAPIConicalSweep.hpp>
#include <boolean/BoolBRepCut.hpp>
#include <common/CartesianCoordinateSystem.hpp>
#include <common/IndexMap.hpp>
#include <common/QuaternionT.hpp>
#include <geomAlgo/LawBSpline.hpp>
#include <geomAlgo/LawConstant.hpp>
#include <nurbs/NURBSAPISmooth.hpp>
#include <geomAlgo/MakeConic2FromConstraints.hpp>
#include <geometry/Adaptor3CurveOnSurface.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/AdaptorGeom3Surface.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/Geom2Circle.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/Geom2Hyperbola.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom3BSplineCurve.hpp>
#include <geometry/Geom3BSplineSurface.hpp>
#include <geometry/Geom3Circle.hpp>
#include <geometry/Geom3Line.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
#include <geometry/Geom3Plane.hpp>
#include <geometry/Geom3SphericalSurface.hpp>
#include <geometry/Geom3Surface.hpp>
#include <geometry/Geom3TrimmedCurve.hpp>
#include <geometry/Geom3TrimmedSurface.hpp>
#include <geometry/GeomAPIExtremaCurveCurve3.hpp>
#include <geometry/GeomAPIProjectPointOnCurve2.hpp>
#include <geometry/GeomAPIProjectPointOnCurve3.hpp>
#include <geometry/GeomAPIProjectPointOnSurface.hpp>
#include <geometry/GeometryTool.hpp>
#include <geometry/GlobalProperty.hpp>
#include <healing/ShapeFixTool.hpp>
#include <io/STLTool.hpp>
#include <math/Sphere.hpp>
#include <math/TriangularMesh.hpp>
#include <modeling/CopyShape.hpp>
#include <modeling/MakeBox.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeFace.hpp>
#include <modeling/MakePrism.hpp>
#include <modeling/MakeRevol.hpp>
#include <modeling/MakeShapeTool.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeWire.hpp>
#include <modeling/TransformShape.hpp>
#include <nurbs/NURBSAPIApprox.hpp>
#include <nurbs/NURBSAPIBuildCurve.hpp>
#include <nurbs/NURBSAPICircularSweep.hpp>
#include <nurbs/NURBSAPIConvert.hpp>
#include <nurbs/NURBSAPICurveNetworkSurface.hpp>
#include <nurbs/NURBSAPIExplicitSweep.hpp>
#include <nurbs/NURBSAPIExplode.hpp>
#include <nurbs/NURBSAPIExtend.hpp>
#include <nurbs/NURBSAPIInterpolate.hpp>
#include <nurbs/NURBSAPIJoin.hpp>
#include <nurbs/NURBSAPILinearSweep.hpp>
#include <nurbs/NURBSAPILoft.hpp>
#include <nurbs/NURBSAPIMakeNURBSFromBoundaries.hpp>
#include <nurbs/NURBSAPIMatch.hpp>
#include <nurbs/NURBSAPIModifyEndToPlane.hpp>
#include <nurbs/NURBSAPIOffsetCurveOnSurface.hpp>
#include <nurbs/NURBSAPIProject.hpp>
#include <nurbs/NURBSAPIRebuild.hpp>
#include <nurbs/NURBSAPIReplaceEdge.hpp>
#include <nurbs/NURBSAPISweep.hpp>
#include <nurbs/NURBSAPISweep2.hpp>
#include <nurbs/NURBSAPISweepRotation.hpp>
#include <nurbs/NURBSAPITrim.hpp>
#include <nurbs/NURBSAPIUntrim.hpp>
#include <nurbs/NURBSLinearSweepWithDraftDirectionLength.hpp>
#include <occtio/OCCTTool.hpp>
#include <offset/MakePipe.hpp>
#include <offset/MakePipeShell.hpp>
#include <topology/BRepAdaptorCurve2.hpp>
#include <topology/BRepAdaptorCurve3.hpp>
#include <topology/BRepAdaptorSurface.hpp>
#include <topology/BRepGlobalProperty.hpp>
#include <topology/BRepTool.hpp>
#include <topology/TopoBuilder.hpp>
#include <topology/TopoCompound.hpp>
#include <topology/TopoEdge.hpp>
#include <topology/TopoExplorer.hpp>
#include <topology/TopoExplorerTool.hpp>
#include <topology/TopoFace.hpp>
#include <topology/TopoShape.hpp>
#include <topology/TopoShell.hpp>
#include <topology/TopoTool.hpp>
#include <topology/TopoVertex.hpp>
#include <topology/TopoWire.hpp>
#include <topology/WireExplorer.hpp>
#include <topomesh/BRepMeshIncrementalMesh.hpp>
#include <nurbs/NURBSAPIBlend.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
#include <math/LineT.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/GeomAPIIntSurfaceSurface.hpp>
using namespace AMCAX;
namespace
{
	std::shared_ptr<Geom3BSplineCurve> CurveChooser(const int id, const std::shared_ptr<Geom3BSplineCurve>& curve0, const std::shared_ptr<Geom3BSplineCurve>& curve1, const std::shared_ptr<Geom3BSplineCurve>& curve2)
	{
		std::shared_ptr<Geom3BSplineCurve> result;
		switch (id)
		{
		case 0:
		{
			result = curve0;
			break;
		}
		case 1:
		{
			result = curve1;
			break;
		}
		case 2:
		{
			result = curve2;
			break;
		}
		}
		return result;
	}
;
	SECTION("TestCircularSweepWithTwoGuidesAndRadius()")
	{
		std::string filedir(INPUT_PATH_PREFIX "/TestNURBS/TestCircularSweepWithTwoGuidesAndRadius/");
		auto guide1 = ReadBRepCurve(filedir + "guide1.brep");
		auto guide2 = ReadBRepCurve(filedir + "guide2.brep");
		auto spine = ReadBRepCurve(filedir + "spine.brep");
		CHECK(OCCTIO::OCCTTool::Write(MakeEdge(guide1), OUTPUT_PATH_PREFIX "TestCircularSweepWithTwoGuidesAndRadius_guide1.brep"));
		CHECK(OCCTIO::OCCTTool::Write(MakeEdge(guide2), OUTPUT_PATH_PREFIX "TestCircularSweepWithTwoGuidesAndRadius_guide2.brep"));
		CHECK(OCCTIO::OCCTTool::Write(MakeEdge(spine), OUTPUT_PATH_PREFIX "TestCircularSweepWithTwoGuidesAndRadius_spine.brep"));
		LawConstant radiusLaw;
		radiusLaw.Set(10.0, 0.0, 1.0);
		auto [status, surfaces] = NURBSAPICircularSweep::SweepWithTwoGuidesAndRadius(guide1, guide2, radiusLaw, spine, spine->FirstParameter(), spine->LastParameter());
		CHECK(status == NURBSSweepStatus::Success);
		if (status == NURBSSweepStatus::Success && !surfaces.empty())
		{
			CHECK(OCCTIO::OCCTTool::Write(MakeFace(surfaces.front(), 0.0), OUTPUT_PATH_PREFIX "TestCircularSweepWithTwoGuidesAndRadius_result.brep"));
			for (int i = 0; i < surfaces.size(); i++)
			{
				CHECK(OCCTIO::OCCTTool::Write(MakeFace(surfaces[i], 0.0), OUTPUT_PATH_PREFIX "TestCircularSweepWithTwoGuidesAndRadius_result" + std::to_string(i) + ".brep"));
				AMCAX::BRepExtremaDistShapeShape len1(MakeEdge(guide1), MakeFace(surfaces[i], 0.0));
				AMCAX::BRepExtremaDistShapeShape len2(MakeFace(surfaces[i], 0.0), MakeEdge(guide2));
				AMCAX::BRepExtremaDistShapeShape len3(MakeFace(surfaces[i], 0.0), MakeEdge(spine));
				CHECK(len1.Value() < 0.1);
				CHECK(len2.Value() < 0.1);
				CHECK(IsCurveOnSurf(1000, 0.1, guide1, surfaces[i], 0.1));
				CHECK(IsCurveOnSurf(1000, 0.1, guide2, surfaces[i], 0.1));
			}
		}
		spine->IncreaseDegree(11);
		guide1->IncreaseDegree(11);
		guide2->IncreaseDegree(11);
		auto [status1, surfaces1] = NURBSAPICircularSweep::SweepWithTwoGuidesAndRadius(guide1, guide2, radiusLaw, spine, spine->FirstParameter(), spine->LastParameter());
		CHECK(status1 == NURBSSweepStatus::Success);
		for (int i = 0; i < surfaces.size(); i++)
		{
			CHECK(OCCTIO::OCCTTool::Write(MakeFace(surfaces[i], 0.0), OUTPUT_PATH_PREFIX "TestCircularSweepWithTwoGuidesAndRadius_degree11result" + std::to_string(i) + ".brep"));
			double bsp3s = GetSurfaceProperties(MakeFace(surfaces1[i], 0.0), g, true, true);
			double bsp4s = GetSurfaceProperties(MakeFace(surfaces[i], 0.0), g, true, true);
			CHECK(bsp3s == Approx(bsp4s).margin(0.02));
		}
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static std::pair<NURBSSweepStatus, std::vector<std::shared_ptr<Geom3BSplineSurface>>> SweepWithTwoGuidesAndTangencySurface(const std::shared_ptr<Geom3BSplineCurve>& limitCurveWithTangency, const std::shared_ptr<Geom3BSplineSurface>& tangencySurface, const std::shared_ptr<Geom3BSplineCurve>& limitCurve, const std::shared_ptr<Geom3BSplineCurve>& spine, double spineLeftBound, double spineRightBound),
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <filesystem>
#include <fstream>
#include <random>
#include <sstream>
#include <nurbs/NURBSAPIGetGeometry.hpp>
#include <nurbs/NURBSAPIConicalSweep.hpp>
#include <boolean/BoolBRepCut.hpp>
#include <common/CartesianCoordinateSystem.hpp>
#include <common/IndexMap.hpp>
#include <common/QuaternionT.hpp>
#include <geomAlgo/LawBSpline.hpp>
#include <geomAlgo/LawConstant.hpp>
#include <nurbs/NURBSAPISmooth.hpp>
#include <geomAlgo/MakeConic2FromConstraints.hpp>
#include <geometry/Adaptor3CurveOnSurface.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/AdaptorGeom3Surface.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/Geom2Circle.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/Geom2Hyperbola.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom3BSplineCurve.hpp>
#include <geometry/Geom3BSplineSurface.hpp>
#include <geometry/Geom3Circle.hpp>
#include <geometry/Geom3Line.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
#include <geometry/Geom3Plane.hpp>
#include <geometry/Geom3SphericalSurface.hpp>
#include <geometry/Geom3Surface.hpp>
#include <geometry/Geom3TrimmedCurve.hpp>
#include <geometry/Geom3TrimmedSurface.hpp>
#include <geometry/GeomAPIExtremaCurveCurve3.hpp>
#include <geometry/GeomAPIProjectPointOnCurve2.hpp>
#include <geometry/GeomAPIProjectPointOnCurve3.hpp>
#include <geometry/GeomAPIProjectPointOnSurface.hpp>
#include <geometry/GeometryTool.hpp>
#include <geometry/GlobalProperty.hpp>
#include <healing/ShapeFixTool.hpp>
#include <io/STLTool.hpp>
#include <math/Sphere.hpp>
#include <math/TriangularMesh.hpp>
#include <modeling/CopyShape.hpp>
#include <modeling/MakeBox.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeFace.hpp>
#include <modeling/MakePrism.hpp>
#include <modeling/MakeRevol.hpp>
#include <modeling/MakeShapeTool.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeWire.hpp>
#include <modeling/TransformShape.hpp>
#include <nurbs/NURBSAPIApprox.hpp>
#include <nurbs/NURBSAPIBuildCurve.hpp>
#include <nurbs/NURBSAPICircularSweep.hpp>
#include <nurbs/NURBSAPIConvert.hpp>
#include <nurbs/NURBSAPICurveNetworkSurface.hpp>
#include <nurbs/NURBSAPIExplicitSweep.hpp>
#include <nurbs/NURBSAPIExplode.hpp>
#include <nurbs/NURBSAPIExtend.hpp>
#include <nurbs/NURBSAPIInterpolate.hpp>
#include <nurbs/NURBSAPIJoin.hpp>
#include <nurbs/NURBSAPILinearSweep.hpp>
#include <nurbs/NURBSAPILoft.hpp>
#include <nurbs/NURBSAPIMakeNURBSFromBoundaries.hpp>
#include <nurbs/NURBSAPIMatch.hpp>
#include <nurbs/NURBSAPIModifyEndToPlane.hpp>
#include <nurbs/NURBSAPIOffsetCurveOnSurface.hpp>
#include <nurbs/NURBSAPIProject.hpp>
#include <nurbs/NURBSAPIRebuild.hpp>
#include <nurbs/NURBSAPIReplaceEdge.hpp>
#include <nurbs/NURBSAPISweep.hpp>
#include <nurbs/NURBSAPISweep2.hpp>
#include <nurbs/NURBSAPISweepRotation.hpp>
#include <nurbs/NURBSAPITrim.hpp>
#include <nurbs/NURBSAPIUntrim.hpp>
#include <nurbs/NURBSLinearSweepWithDraftDirectionLength.hpp>
#include <occtio/OCCTTool.hpp>
#include <offset/MakePipe.hpp>
#include <offset/MakePipeShell.hpp>
#include <topology/BRepAdaptorCurve2.hpp>
#include <topology/BRepAdaptorCurve3.hpp>
#include <topology/BRepAdaptorSurface.hpp>
#include <topology/BRepGlobalProperty.hpp>
#include <topology/BRepTool.hpp>
#include <topology/TopoBuilder.hpp>
#include <topology/TopoCompound.hpp>
#include <topology/TopoEdge.hpp>
#include <topology/TopoExplorer.hpp>
#include <topology/TopoExplorerTool.hpp>
#include <topology/TopoFace.hpp>
#include <topology/TopoShape.hpp>
#include <topology/TopoShell.hpp>
#include <topology/TopoTool.hpp>
#include <topology/TopoVertex.hpp>
#include <topology/TopoWire.hpp>
#include <topology/WireExplorer.hpp>
#include <topomesh/BRepMeshIncrementalMesh.hpp>
#include <nurbs/NURBSAPIBlend.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
#include <math/LineT.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/GeomAPIIntSurfaceSurface.hpp>
using namespace AMCAX;
namespace
{
	std::shared_ptr<Geom3BSplineCurve> CurveChooser(const int id, const std::shared_ptr<Geom3BSplineCurve>& curve0, const std::shared_ptr<Geom3BSplineCurve>& curve1, const std::shared_ptr<Geom3BSplineCurve>& curve2)
	{
		std::shared_ptr<Geom3BSplineCurve> result;
		switch (id)
		{
		case 0:
		{
			result = curve0;
			break;
		}
		case 1:
		{
			result = curve1;
			break;
		}
		case 2:
		{
			result = curve2;
			break;
		}
		}
		return result;
	}
} 
#include<catch.hpp>
#include<testHelper.h>
#include <filesystem>
#include <fstream>
#include <random>
#include <sstream>
#include <nurbs/NURBSAPIGetGeometry.hpp>
#include <nurbs/NURBSAPIConicalSweep.hpp>
#include <boolean/BoolBRepCut.hpp>
#include <common/CartesianCoordinateSystem.hpp>
#include <common/IndexMap.hpp>
#include <common/QuaternionT.hpp>
#include <geomAlgo/LawBSpline.hpp>
#include <geomAlgo/LawConstant.hpp>
#include <nurbs/NURBSAPISmooth.hpp>
#include <geomAlgo/MakeConic2FromConstraints.hpp>
#include <geometry/Adaptor3CurveOnSurface.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/AdaptorGeom3Surface.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/Geom2Circle.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/Geom2Hyperbola.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom3BSplineCurve.hpp>
#include <geometry/Geom3BSplineSurface.hpp>
#include <geometry/Geom3Circle.hpp>
#include <geometry/Geom3Line.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
#include <geometry/Geom3Plane.hpp>
#include <geometry/Geom3SphericalSurface.hpp>
#include <geometry/Geom3Surface.hpp>
#include <geometry/Geom3TrimmedCurve.hpp>
#include <geometry/Geom3TrimmedSurface.hpp>
#include <geometry/GeomAPIExtremaCurveCurve3.hpp>
#include <geometry/GeomAPIProjectPointOnCurve2.hpp>
#include <geometry/GeomAPIProjectPointOnCurve3.hpp>
#include <geometry/GeomAPIProjectPointOnSurface.hpp>
#include <geometry/GeometryTool.hpp>
#include <geometry/GlobalProperty.hpp>
#include <healing/ShapeFixTool.hpp>
#include <io/STLTool.hpp>
#include <math/Sphere.hpp>
#include <math/TriangularMesh.hpp>
#include <modeling/CopyShape.hpp>
#include <modeling/MakeBox.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeFace.hpp>
#include <modeling/MakePrism.hpp>
#include <modeling/MakeRevol.hpp>
#include <modeling/MakeShapeTool.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeWire.hpp>
#include <modeling/TransformShape.hpp>
#include <nurbs/NURBSAPIApprox.hpp>
#include <nurbs/NURBSAPIBuildCurve.hpp>
#include <nurbs/NURBSAPICircularSweep.hpp>
#include <nurbs/NURBSAPIConvert.hpp>
#include <nurbs/NURBSAPICurveNetworkSurface.hpp>
#include <nurbs/NURBSAPIExplicitSweep.hpp>
#include <nurbs/NURBSAPIExplode.hpp>
#include <nurbs/NURBSAPIExtend.hpp>
#include <nurbs/NURBSAPIInterpolate.hpp>
#include <nurbs/NURBSAPIJoin.hpp>
#include <nurbs/NURBSAPILinearSweep.hpp>
#include <nurbs/NURBSAPILoft.hpp>
#include <nurbs/NURBSAPIMakeNURBSFromBoundaries.hpp>
#include <nurbs/NURBSAPIMatch.hpp>
#include <nurbs/NURBSAPIModifyEndToPlane.hpp>
#include <nurbs/NURBSAPIOffsetCurveOnSurface.hpp>
#include <nurbs/NURBSAPIProject.hpp>
#include <nurbs/NURBSAPIRebuild.hpp>
#include <nurbs/NURBSAPIReplaceEdge.hpp>
#include <nurbs/NURBSAPISweep.hpp>
#include <nurbs/NURBSAPISweep2.hpp>
#include <nurbs/NURBSAPISweepRotation.hpp>
#include <nurbs/NURBSAPITrim.hpp>
#include <nurbs/NURBSAPIUntrim.hpp>
#include <nurbs/NURBSLinearSweepWithDraftDirectionLength.hpp>
#include <occtio/OCCTTool.hpp>
#include <offset/MakePipe.hpp>
#include <offset/MakePipeShell.hpp>
#include <topology/BRepAdaptorCurve2.hpp>
#include <topology/BRepAdaptorCurve3.hpp>
#include <topology/BRepAdaptorSurface.hpp>
#include <topology/BRepGlobalProperty.hpp>
#include <topology/BRepTool.hpp>
#include <topology/TopoBuilder.hpp>
#include <topology/TopoCompound.hpp>
#include <topology/TopoEdge.hpp>
#include <topology/TopoExplorer.hpp>
#include <topology/TopoExplorerTool.hpp>
#include <topology/TopoFace.hpp>
#include <topology/TopoShape.hpp>
#include <topology/TopoShell.hpp>
#include <topology/TopoTool.hpp>
#include <topology/TopoVertex.hpp>
#include <topology/TopoWire.hpp>
#include <topology/WireExplorer.hpp>
#include <topomesh/BRepMeshIncrementalMesh.hpp>
#include <nurbs/NURBSAPIBlend.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
#include <math/LineT.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/GeomAPIIntSurfaceSurface.hpp>
using namespace AMCAX;
namespace
{
	std::shared_ptr<Geom3BSplineCurve> CurveChooser(const int id, const std::shared_ptr<Geom3BSplineCurve>& curve0, const std::shared_ptr<Geom3BSplineCurve>& curve1, const std::shared_ptr<Geom3BSplineCurve>& curve2)
	{
		std::shared_ptr<Geom3BSplineCurve> result;
		switch (id)
		{
		case 0:
		{
			result = curve0;
			break;
		}
		case 1:
		{
			result = curve1;
			break;
		}
		case 2:
		{
			result = curve2;
			break;
		}
		}
		return result;
	}
;
	SECTION("TestCircularSweepWithTwoGuidesAndTangencySurface()")
	{
		std::string filedir(INPUT_PATH_PREFIX "/TestNURBS/TestCircularSweepWithTwoGuidesAndTangencySurface/");
		auto guide1 = ReadBRepCurve(filedir + "guide1.brep");
		auto guide2 = ReadBRepCurve(filedir + "guide2.brep");
		auto surface = ReadBRepSurface(filedir + "surface.brep");
		auto spine = ReadBRepCurve(filedir + "spine.brep");
		CHECK(OCCTIO::OCCTTool::Write(MakeEdge(guide1), OUTPUT_PATH_PREFIX "TestCircularSweepWithTwoGuidesAndTangencySurface_guide1.brep"));
		CHECK(OCCTIO::OCCTTool::Write(MakeEdge(guide2), OUTPUT_PATH_PREFIX "TestCircularSweepWithTwoGuidesAndTangencySurface_guide2.brep"));
		CHECK(OCCTIO::OCCTTool::Write(MakeEdge(spine), OUTPUT_PATH_PREFIX "TestCircularSweepWithTwoGuidesAndTangencySurface_spine.brep"));
		CHECK(OCCTIO::OCCTTool::Write(MakeFace(surface, 0.0), OUTPUT_PATH_PREFIX "TestCircularSweepWithTwoGuidesAndTangencySurface_surface.brep"));
		auto [status, surfaces] = NURBSAPICircularSweep::SweepWithTwoGuidesAndTangencySurface(guide1, surface, guide2, spine, spine->FirstParameter(), spine->LastParameter());
		CHECK(status == NURBSSweepStatus::Success);
		if (status == NURBSSweepStatus::Success && !surfaces.empty())
		{
			CHECK(surfaces.size() == Approx(2.0));
			for (int i = 0; i < surfaces.size(); i++) {
				CHECK(OCCTIO::OCCTTool::Write(MakeFace(surfaces[i], 0.0), OUTPUT_PATH_PREFIX "TestCircularSweepWithTwoGuidesAndTangencySurface_result" + std::to_string(i) + ".brep"));
				AMCAX::BRepExtremaDistShapeShape len1(MakeEdge(guide1), MakeFace(surfaces[i], 0.0));
				AMCAX::BRepExtremaDistShapeShape len2(MakeEdge(guide2), MakeFace(surfaces[i], 0.0));
				AMCAX::BRepExtremaDistShapeShape len3(MakeFace(surface, 0.0), MakeFace(surfaces[i], 0.0));
				CHECK(len1.Value() < 0.1);
				CHECK(len2.Value() < 0.1);
				CHECK(len3.Value() < 0.1);
				CHECK(IsCurveOnSurf(100, 0.3, guide1, surfaces[i], 0.1));
				CHECK(IsCurveOnSurf(100, 0.3, guide2, surfaces[i], 0.1));
			}
		}
			CHECK(IsSurfTangent(100, 0.6, guide1, surface, surfaces[0], 20, 180));
			CHECK(IsSurfTangent(100, 0.6, guide1, surface, surfaces[1], 20, 180));
			guide1->IncreaseDegree(11);
			guide2->IncreaseDegree(11);
			spine->IncreaseDegree(11);
			surface->IncreaseDegree(11, 11);
			auto [status1, surfaces1] = NURBSAPICircularSweep::SweepWithTwoGuidesAndTangencySurface(guide1, surface, guide2, spine, spine->FirstParameter(), spine->LastParameter());
			CHECK(status1 == NURBSSweepStatus::Success);
			if (status1 == NURBSSweepStatus::Success && !surfaces1.empty())
			{
				CHECK(surfaces1.size() == Approx(2.0));
				for (int i = 0; i < surfaces1.size(); i++) {
					CHECK(OCCTIO::OCCTTool::Write(MakeFace(surfaces1[i], 0.0), OUTPUT_PATH_PREFIX "TestCircularSweepWithTwoGuidesAndTangencySurface_result" + std::to_string(i) + ".brep"));
					AMCAX::BRepExtremaDistShapeShape len1(MakeEdge(guide1), MakeFace(surfaces1[i], 0.0));
					AMCAX::BRepExtremaDistShapeShape len2(MakeEdge(guide2), MakeFace(surfaces1[i], 0.0));
					AMCAX::BRepExtremaDistShapeShape len3(MakeFace(surface, 0.0), MakeFace(surfaces1[i], 0.0));
					CHECK(len1.Value() < 0.1);
					CHECK(len2.Value() < 0.1);
					CHECK(len3.Value() < 0.1);
					CHECK(IsCurveOnSurf(100, 0.3, guide1, surfaces1[i], 0.1));
					CHECK(IsCurveOnSurf(100, 0.3, guide2, surfaces1[i], 0.1));
					double bsp3s = GetSurfaceProperties(MakeFace(surfaces1[i], 0.0), g, true, true);
					double bsp4s = GetSurfaceProperties(MakeFace(surfaces[i], 0.0), g, true, true);
					CHECK(bsp3s == Approx(bsp4s).margin(0.02));
				}
			}
		}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static std::pair<NURBSSweepStatus, std::vector<std::shared_ptr<Geom3BSplineSurface>>> SweepWithOneGuideAndTangencySurface(const std::shared_ptr<Geom3BSplineCurve>& guide, const std::shared_ptr<Geom3BSplineSurface>& tangencySurface, const LawFunction& radiusLaw, const std::shared_ptr<Geom3BSplineCurve>& spine, double spineLeftBound, double spineRightBound),
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <filesystem>
#include <fstream>
#include <random>
#include <sstream>
#include <nurbs/NURBSAPIGetGeometry.hpp>
#include <nurbs/NURBSAPIConicalSweep.hpp>
#include <boolean/BoolBRepCut.hpp>
#include <common/CartesianCoordinateSystem.hpp>
#include <common/IndexMap.hpp>
#include <common/QuaternionT.hpp>
#include <geomAlgo/LawBSpline.hpp>
#include <geomAlgo/LawConstant.hpp>
#include <nurbs/NURBSAPISmooth.hpp>
#include <geomAlgo/MakeConic2FromConstraints.hpp>
#include <geometry/Adaptor3CurveOnSurface.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/AdaptorGeom3Surface.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/Geom2Circle.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/Geom2Hyperbola.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom3BSplineCurve.hpp>
#include <geometry/Geom3BSplineSurface.hpp>
#include <geometry/Geom3Circle.hpp>
#include <geometry/Geom3Line.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
#include <geometry/Geom3Plane.hpp>
#include <geometry/Geom3SphericalSurface.hpp>
#include <geometry/Geom3Surface.hpp>
#include <geometry/Geom3TrimmedCurve.hpp>
#include <geometry/Geom3TrimmedSurface.hpp>
#include <geometry/GeomAPIExtremaCurveCurve3.hpp>
#include <geometry/GeomAPIProjectPointOnCurve2.hpp>
#include <geometry/GeomAPIProjectPointOnCurve3.hpp>
#include <geometry/GeomAPIProjectPointOnSurface.hpp>
#include <geometry/GeometryTool.hpp>
#include <geometry/GlobalProperty.hpp>
#include <healing/ShapeFixTool.hpp>
#include <io/STLTool.hpp>
#include <math/Sphere.hpp>
#include <math/TriangularMesh.hpp>
#include <modeling/CopyShape.hpp>
#include <modeling/MakeBox.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeFace.hpp>
#include <modeling/MakePrism.hpp>
#include <modeling/MakeRevol.hpp>
#include <modeling/MakeShapeTool.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeWire.hpp>
#include <modeling/TransformShape.hpp>
#include <nurbs/NURBSAPIApprox.hpp>
#include <nurbs/NURBSAPIBuildCurve.hpp>
#include <nurbs/NURBSAPICircularSweep.hpp>
#include <nurbs/NURBSAPIConvert.hpp>
#include <nurbs/NURBSAPICurveNetworkSurface.hpp>
#include <nurbs/NURBSAPIExplicitSweep.hpp>
#include <nurbs/NURBSAPIExplode.hpp>
#include <nurbs/NURBSAPIExtend.hpp>
#include <nurbs/NURBSAPIInterpolate.hpp>
#include <nurbs/NURBSAPIJoin.hpp>
#include <nurbs/NURBSAPILinearSweep.hpp>
#include <nurbs/NURBSAPILoft.hpp>
#include <nurbs/NURBSAPIMakeNURBSFromBoundaries.hpp>
#include <nurbs/NURBSAPIMatch.hpp>
#include <nurbs/NURBSAPIModifyEndToPlane.hpp>
#include <nurbs/NURBSAPIOffsetCurveOnSurface.hpp>
#include <nurbs/NURBSAPIProject.hpp>
#include <nurbs/NURBSAPIRebuild.hpp>
#include <nurbs/NURBSAPIReplaceEdge.hpp>
#include <nurbs/NURBSAPISweep.hpp>
#include <nurbs/NURBSAPISweep2.hpp>
#include <nurbs/NURBSAPISweepRotation.hpp>
#include <nurbs/NURBSAPITrim.hpp>
#include <nurbs/NURBSAPIUntrim.hpp>
#include <nurbs/NURBSLinearSweepWithDraftDirectionLength.hpp>
#include <occtio/OCCTTool.hpp>
#include <offset/MakePipe.hpp>
#include <offset/MakePipeShell.hpp>
#include <topology/BRepAdaptorCurve2.hpp>
#include <topology/BRepAdaptorCurve3.hpp>
#include <topology/BRepAdaptorSurface.hpp>
#include <topology/BRepGlobalProperty.hpp>
#include <topology/BRepTool.hpp>
#include <topology/TopoBuilder.hpp>
#include <topology/TopoCompound.hpp>
#include <topology/TopoEdge.hpp>
#include <topology/TopoExplorer.hpp>
#include <topology/TopoExplorerTool.hpp>
#include <topology/TopoFace.hpp>
#include <topology/TopoShape.hpp>
#include <topology/TopoShell.hpp>
#include <topology/TopoTool.hpp>
#include <topology/TopoVertex.hpp>
#include <topology/TopoWire.hpp>
#include <topology/WireExplorer.hpp>
#include <topomesh/BRepMeshIncrementalMesh.hpp>
#include <nurbs/NURBSAPIBlend.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
#include <math/LineT.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/GeomAPIIntSurfaceSurface.hpp>
using namespace AMCAX;
namespace
{
	std::shared_ptr<Geom3BSplineCurve> CurveChooser(const int id, const std::shared_ptr<Geom3BSplineCurve>& curve0, const std::shared_ptr<Geom3BSplineCurve>& curve1, const std::shared_ptr<Geom3BSplineCurve>& curve2)
	{
		std::shared_ptr<Geom3BSplineCurve> result;
		switch (id)
		{
		case 0:
		{
			result = curve0;
			break;
		}
		case 1:
		{
			result = curve1;
			break;
		}
		case 2:
		{
			result = curve2;
			break;
		}
		}
		return result;
	}
} 
#include<catch.hpp>
#include<testHelper.h>
#include <filesystem>
#include <fstream>
#include <random>
#include <sstream>
#include <nurbs/NURBSAPIGetGeometry.hpp>
#include <nurbs/NURBSAPIConicalSweep.hpp>
#include <boolean/BoolBRepCut.hpp>
#include <common/CartesianCoordinateSystem.hpp>
#include <common/IndexMap.hpp>
#include <common/QuaternionT.hpp>
#include <geomAlgo/LawBSpline.hpp>
#include <geomAlgo/LawConstant.hpp>
#include <nurbs/NURBSAPISmooth.hpp>
#include <geomAlgo/MakeConic2FromConstraints.hpp>
#include <geometry/Adaptor3CurveOnSurface.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/AdaptorGeom3Surface.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/Geom2Circle.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/Geom2Hyperbola.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom3BSplineCurve.hpp>
#include <geometry/Geom3BSplineSurface.hpp>
#include <geometry/Geom3Circle.hpp>
#include <geometry/Geom3Line.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
#include <geometry/Geom3Plane.hpp>
#include <geometry/Geom3SphericalSurface.hpp>
#include <geometry/Geom3Surface.hpp>
#include <geometry/Geom3TrimmedCurve.hpp>
#include <geometry/Geom3TrimmedSurface.hpp>
#include <geometry/GeomAPIExtremaCurveCurve3.hpp>
#include <geometry/GeomAPIProjectPointOnCurve2.hpp>
#include <geometry/GeomAPIProjectPointOnCurve3.hpp>
#include <geometry/GeomAPIProjectPointOnSurface.hpp>
#include <geometry/GeometryTool.hpp>
#include <geometry/GlobalProperty.hpp>
#include <healing/ShapeFixTool.hpp>
#include <io/STLTool.hpp>
#include <math/Sphere.hpp>
#include <math/TriangularMesh.hpp>
#include <modeling/CopyShape.hpp>
#include <modeling/MakeBox.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeFace.hpp>
#include <modeling/MakePrism.hpp>
#include <modeling/MakeRevol.hpp>
#include <modeling/MakeShapeTool.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeWire.hpp>
#include <modeling/TransformShape.hpp>
#include <nurbs/NURBSAPIApprox.hpp>
#include <nurbs/NURBSAPIBuildCurve.hpp>
#include <nurbs/NURBSAPICircularSweep.hpp>
#include <nurbs/NURBSAPIConvert.hpp>
#include <nurbs/NURBSAPICurveNetworkSurface.hpp>
#include <nurbs/NURBSAPIExplicitSweep.hpp>
#include <nurbs/NURBSAPIExplode.hpp>
#include <nurbs/NURBSAPIExtend.hpp>
#include <nurbs/NURBSAPIInterpolate.hpp>
#include <nurbs/NURBSAPIJoin.hpp>
#include <nurbs/NURBSAPILinearSweep.hpp>
#include <nurbs/NURBSAPILoft.hpp>
#include <nurbs/NURBSAPIMakeNURBSFromBoundaries.hpp>
#include <nurbs/NURBSAPIMatch.hpp>
#include <nurbs/NURBSAPIModifyEndToPlane.hpp>
#include <nurbs/NURBSAPIOffsetCurveOnSurface.hpp>
#include <nurbs/NURBSAPIProject.hpp>
#include <nurbs/NURBSAPIRebuild.hpp>
#include <nurbs/NURBSAPIReplaceEdge.hpp>
#include <nurbs/NURBSAPISweep.hpp>
#include <nurbs/NURBSAPISweep2.hpp>
#include <nurbs/NURBSAPISweepRotation.hpp>
#include <nurbs/NURBSAPITrim.hpp>
#include <nurbs/NURBSAPIUntrim.hpp>
#include <nurbs/NURBSLinearSweepWithDraftDirectionLength.hpp>
#include <occtio/OCCTTool.hpp>
#include <offset/MakePipe.hpp>
#include <offset/MakePipeShell.hpp>
#include <topology/BRepAdaptorCurve2.hpp>
#include <topology/BRepAdaptorCurve3.hpp>
#include <topology/BRepAdaptorSurface.hpp>
#include <topology/BRepGlobalProperty.hpp>
#include <topology/BRepTool.hpp>
#include <topology/TopoBuilder.hpp>
#include <topology/TopoCompound.hpp>
#include <topology/TopoEdge.hpp>
#include <topology/TopoExplorer.hpp>
#include <topology/TopoExplorerTool.hpp>
#include <topology/TopoFace.hpp>
#include <topology/TopoShape.hpp>
#include <topology/TopoShell.hpp>
#include <topology/TopoTool.hpp>
#include <topology/TopoVertex.hpp>
#include <topology/TopoWire.hpp>
#include <topology/WireExplorer.hpp>
#include <topomesh/BRepMeshIncrementalMesh.hpp>
#include <nurbs/NURBSAPIBlend.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
#include <math/LineT.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/GeomAPIIntSurfaceSurface.hpp>
using namespace AMCAX;
namespace
{
	std::shared_ptr<Geom3BSplineCurve> CurveChooser(const int id, const std::shared_ptr<Geom3BSplineCurve>& curve0, const std::shared_ptr<Geom3BSplineCurve>& curve1, const std::shared_ptr<Geom3BSplineCurve>& curve2)
	{
		std::shared_ptr<Geom3BSplineCurve> result;
		switch (id)
		{
		case 0:
		{
			result = curve0;
			break;
		}
		case 1:
		{
			result = curve1;
			break;
		}
		case 2:
		{
			result = curve2;
			break;
		}
		}
		return result;
	}
;
	SECTION("TestCircularSweepWithOneGuideAndTangencySurface()")
		{
			std::string filedir(INPUT_PATH_PREFIX "/TestNURBS/TestCircularSweepWithOneGuideAndTangencySurface/");
			auto guide = ReadBRepCurve(filedir + "guide.brep");
			auto surface = ReadBRepSurface(filedir + "surface.brep");
			auto spine = ReadBRepCurve(filedir + "spine.brep");
			CHECK(OCCTIO::OCCTTool::Write(MakeEdge(guide), OUTPUT_PATH_PREFIX "TestCircularSweepWithOneGuideAndTangencySurface_guide.brep"));
			CHECK(OCCTIO::OCCTTool::Write(MakeEdge(spine), OUTPUT_PATH_PREFIX "TestCircularSweepWithOneGuideAndTangencySurface_spine.brep"));
			CHECK(OCCTIO::OCCTTool::Write(MakeFace(surface, 0.0), OUTPUT_PATH_PREFIX "TestCircularSweepWithOneGuideAndTangencySurface_surface.brep"));
			LawConstant radiusLaw;
			radiusLaw.Set(10.0, 0.0, 1.0);
			clock_t bg = clock();
			auto [status, surfaces] = NURBSAPICircularSweep::SweepWithOneGuideAndTangencySurface(guide, surface, radiusLaw, spine, spine->FirstParameter(), spine->LastParameter());
			GlobalProperty g;
			clock_t ed = clock();
			std::cout << "time = " << ed - bg << "ms" << std::endl;
			CHECK(status == NURBSSweepStatus::Success);
			if (status == NURBSSweepStatus::Success && !surfaces.empty())
			{
				int nsurfaces = static_cast<int>(surfaces.size());
				for (int i = 0; i < nsurfaces; i++)
				{
					AMCAX::BRepExtremaDistShapeShape len(MakeFace(surface, 0.0), MakeFace(surfaces[i], 0.0));
					AMCAX::BRepExtremaDistShapeShape len1(MakeFace(surfaces[i], 0.0), MakeEdge(guide));
					CHECK(len.Value() < 0.1);
					CHECK(len1.Value() < 0.1);
					CHECK(OCCTIO::OCCTTool::Write(MakeFace(surfaces[i], 0.0), OUTPUT_PATH_PREFIX "TestCircularSweepWithOneGuideAndTangencySurface_result" + std::to_string(i) + ".brep"));
				}
			}
			std::string filedir1 = OUTPUT_PATH_PREFIX;
			IndexSet<TopoShape> newshapeEdge0;
			IndexSet<TopoShape> newshapeEdge1;
			IndexSet<TopoShape> newshapeEdge2;
			IndexSet<TopoShape> newshapeEdge3;
			TopoExplorerTool::MapShapes(MakeFace(surfaces[0], 0.0), ShapeType::Edge, newshapeEdge0);
			TopoExplorerTool::MapShapes(MakeFace(surfaces[1], 0.0), ShapeType::Edge, newshapeEdge1);
			TopoExplorerTool::MapShapes(MakeFace(surfaces[2], 0.0), ShapeType::Edge, newshapeEdge2);
			TopoExplorerTool::MapShapes(MakeFace(surfaces[3], 0.0), ShapeType::Edge, newshapeEdge3);
			std::cout << "newshapedege.size" << newshapeEdge1.size() << endl;
			CHECK(OCCTIO::OCCTTool::Write(newshapeEdge0[0], OUTPUT_PATH_PREFIX "TestCircularSweepWithOneGuideAndTangencySurface_newshapeEdge0[0].brep"));
			CHECK(OCCTIO::OCCTTool::Write(newshapeEdge1[2], OUTPUT_PATH_PREFIX "TestCircularSweepWithOneGuideAndTangencySurface_newshapeEdge1[2].brep"));
			CHECK(OCCTIO::OCCTTool::Write(newshapeEdge2[0], OUTPUT_PATH_PREFIX "TestCircularSweepWithOneGuideAndTangencySurface_newshapeEdge2[0].brep"));
			CHECK(OCCTIO::OCCTTool::Write(newshapeEdge3[0], OUTPUT_PATH_PREFIX "TestCircularSweepWithOneGuideAndTangencySurface_newshapeEdge3[0].brep"));
			auto edge0 = ReadBRepCurve(filedir1 + "TestCircularSweepWithOneGuideAndTangencySurface_newshapeEdge0[0].brep");
			auto edge1 = ReadBRepCurve(filedir1 + "TestCircularSweepWithOneGuideAndTangencySurface_newshapeEdge1[2].brep");
			auto edge2 = ReadBRepCurve(filedir1 + "TestCircularSweepWithOneGuideAndTangencySurface_newshapeEdge2[0].brep");
			auto edge3 = ReadBRepCurve(filedir1 + "TestCircularSweepWithOneGuideAndTangencySurface_newshapeEdge3[0].brep");
			CHECK(IsSurfTangent(100, 0.6, edge0, surface, surfaces[0], 20, 0));
			CHECK(IsSurfTangent(100, 0.6, edge1, surface, surfaces[1], 20, 180));
			CHECK(IsSurfTangent(100, 0.6, edge2, surface, surfaces[2], 20, 180));
			CHECK(IsSurfTangent(100, 0.6, edge3, surface, surfaces[3], 20, 0));
			guide->IncreaseDegree(11);
			spine->IncreaseDegree(11);
			surface->IncreaseDegree(11, 11);
			auto [status1, surfaces1] = NURBSAPICircularSweep::SweepWithOneGuideAndTangencySurface(guide, surface, radiusLaw, spine, spine->FirstParameter(), spine->LastParameter());
			CHECK(status1 == NURBSSweepStatus::Success);
			if (status1 == NURBSSweepStatus::Success && !surfaces.empty())
			{
				int nsurfaces = static_cast<int>(surfaces.size());
				for (int i = 0; i < nsurfaces; i++)
				{
					CHECK(OCCTIO::OCCTTool::Write(MakeFace(surfaces1[i], 0.0), OUTPUT_PATH_PREFIX "TestCircularSweepWithOneGuideAndTangencySurface_degree11result" + std::to_string(i) + ".brep"));
					double bsp3s = GetSurfaceProperties(MakeFace(surfaces1[i], 0.0), g, true, true);
					double bsp4s = GetSurfaceProperties(MakeFace(surfaces[i], 0.0), g, true, true);
					CHECK(bsp3s == Approx(bsp4s).margin(0.02));
				}
			}
		}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static std::pair<NURBSSweepStatus, std::vector<std::shared_ptr<Geom3BSplineSurface>>> SweepWithCurveOnTangencySurface(const std::shared_ptr<Geom3BSplineCurve>& guide, const std::shared_ptr<Geom3BSplineSurface>& tangencySurface, const LawFunction& radiusLaw, const LawFunction& angleLaw1, const LawFunction& angleLaw2, const std::shared_ptr<Geom3BSplineCurve>& spine, double spineLeftBound, double spineRightBound),
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <filesystem>
#include <fstream>
#include <random>
#include <sstream>
#include <nurbs/NURBSAPIGetGeometry.hpp>
#include <nurbs/NURBSAPIConicalSweep.hpp>
#include <boolean/BoolBRepCut.hpp>
#include <common/CartesianCoordinateSystem.hpp>
#include <common/IndexMap.hpp>
#include <common/QuaternionT.hpp>
#include <geomAlgo/LawBSpline.hpp>
#include <geomAlgo/LawConstant.hpp>
#include <nurbs/NURBSAPISmooth.hpp>
#include <geomAlgo/MakeConic2FromConstraints.hpp>
#include <geometry/Adaptor3CurveOnSurface.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/AdaptorGeom3Surface.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/Geom2Circle.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/Geom2Hyperbola.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom3BSplineCurve.hpp>
#include <geometry/Geom3BSplineSurface.hpp>
#include <geometry/Geom3Circle.hpp>
#include <geometry/Geom3Line.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
#include <geometry/Geom3Plane.hpp>
#include <geometry/Geom3SphericalSurface.hpp>
#include <geometry/Geom3Surface.hpp>
#include <geometry/Geom3TrimmedCurve.hpp>
#include <geometry/Geom3TrimmedSurface.hpp>
#include <geometry/GeomAPIExtremaCurveCurve3.hpp>
#include <geometry/GeomAPIProjectPointOnCurve2.hpp>
#include <geometry/GeomAPIProjectPointOnCurve3.hpp>
#include <geometry/GeomAPIProjectPointOnSurface.hpp>
#include <geometry/GeometryTool.hpp>
#include <geometry/GlobalProperty.hpp>
#include <healing/ShapeFixTool.hpp>
#include <io/STLTool.hpp>
#include <math/Sphere.hpp>
#include <math/TriangularMesh.hpp>
#include <modeling/CopyShape.hpp>
#include <modeling/MakeBox.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeFace.hpp>
#include <modeling/MakePrism.hpp>
#include <modeling/MakeRevol.hpp>
#include <modeling/MakeShapeTool.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeWire.hpp>
#include <modeling/TransformShape.hpp>
#include <nurbs/NURBSAPIApprox.hpp>
#include <nurbs/NURBSAPIBuildCurve.hpp>
#include <nurbs/NURBSAPICircularSweep.hpp>
#include <nurbs/NURBSAPIConvert.hpp>
#include <nurbs/NURBSAPICurveNetworkSurface.hpp>
#include <nurbs/NURBSAPIExplicitSweep.hpp>
#include <nurbs/NURBSAPIExplode.hpp>
#include <nurbs/NURBSAPIExtend.hpp>
#include <nurbs/NURBSAPIInterpolate.hpp>
#include <nurbs/NURBSAPIJoin.hpp>
#include <nurbs/NURBSAPILinearSweep.hpp>
#include <nurbs/NURBSAPILoft.hpp>
#include <nurbs/NURBSAPIMakeNURBSFromBoundaries.hpp>
#include <nurbs/NURBSAPIMatch.hpp>
#include <nurbs/NURBSAPIModifyEndToPlane.hpp>
#include <nurbs/NURBSAPIOffsetCurveOnSurface.hpp>
#include <nurbs/NURBSAPIProject.hpp>
#include <nurbs/NURBSAPIRebuild.hpp>
#include <nurbs/NURBSAPIReplaceEdge.hpp>
#include <nurbs/NURBSAPISweep.hpp>
#include <nurbs/NURBSAPISweep2.hpp>
#include <nurbs/NURBSAPISweepRotation.hpp>
#include <nurbs/NURBSAPITrim.hpp>
#include <nurbs/NURBSAPIUntrim.hpp>
#include <nurbs/NURBSLinearSweepWithDraftDirectionLength.hpp>
#include <occtio/OCCTTool.hpp>
#include <offset/MakePipe.hpp>
#include <offset/MakePipeShell.hpp>
#include <topology/BRepAdaptorCurve2.hpp>
#include <topology/BRepAdaptorCurve3.hpp>
#include <topology/BRepAdaptorSurface.hpp>
#include <topology/BRepGlobalProperty.hpp>
#include <topology/BRepTool.hpp>
#include <topology/TopoBuilder.hpp>
#include <topology/TopoCompound.hpp>
#include <topology/TopoEdge.hpp>
#include <topology/TopoExplorer.hpp>
#include <topology/TopoExplorerTool.hpp>
#include <topology/TopoFace.hpp>
#include <topology/TopoShape.hpp>
#include <topology/TopoShell.hpp>
#include <topology/TopoTool.hpp>
#include <topology/TopoVertex.hpp>
#include <topology/TopoWire.hpp>
#include <topology/WireExplorer.hpp>
#include <topomesh/BRepMeshIncrementalMesh.hpp>
#include <nurbs/NURBSAPIBlend.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
#include <math/LineT.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/GeomAPIIntSurfaceSurface.hpp>
using namespace AMCAX;
namespace
{
	std::shared_ptr<Geom3BSplineCurve> CurveChooser(const int id, const std::shared_ptr<Geom3BSplineCurve>& curve0, const std::shared_ptr<Geom3BSplineCurve>& curve1, const std::shared_ptr<Geom3BSplineCurve>& curve2)
	{
		std::shared_ptr<Geom3BSplineCurve> result;
		switch (id)
		{
		case 0:
		{
			result = curve0;
			break;
		}
		case 1:
		{
			result = curve1;
			break;
		}
		case 2:
		{
			result = curve2;
			break;
		}
		}
		return result;
	}
} 
#include<catch.hpp>
#include<testHelper.h>
#include <filesystem>
#include <fstream>
#include <random>
#include <sstream>
#include <nurbs/NURBSAPIGetGeometry.hpp>
#include <nurbs/NURBSAPIConicalSweep.hpp>
#include <boolean/BoolBRepCut.hpp>
#include <common/CartesianCoordinateSystem.hpp>
#include <common/IndexMap.hpp>
#include <common/QuaternionT.hpp>
#include <geomAlgo/LawBSpline.hpp>
#include <geomAlgo/LawConstant.hpp>
#include <nurbs/NURBSAPISmooth.hpp>
#include <geomAlgo/MakeConic2FromConstraints.hpp>
#include <geometry/Adaptor3CurveOnSurface.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/AdaptorGeom3Surface.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/Geom2Circle.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/Geom2Hyperbola.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom3BSplineCurve.hpp>
#include <geometry/Geom3BSplineSurface.hpp>
#include <geometry/Geom3Circle.hpp>
#include <geometry/Geom3Line.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
#include <geometry/Geom3Plane.hpp>
#include <geometry/Geom3SphericalSurface.hpp>
#include <geometry/Geom3Surface.hpp>
#include <geometry/Geom3TrimmedCurve.hpp>
#include <geometry/Geom3TrimmedSurface.hpp>
#include <geometry/GeomAPIExtremaCurveCurve3.hpp>
#include <geometry/GeomAPIProjectPointOnCurve2.hpp>
#include <geometry/GeomAPIProjectPointOnCurve3.hpp>
#include <geometry/GeomAPIProjectPointOnSurface.hpp>
#include <geometry/GeometryTool.hpp>
#include <geometry/GlobalProperty.hpp>
#include <healing/ShapeFixTool.hpp>
#include <io/STLTool.hpp>
#include <math/Sphere.hpp>
#include <math/TriangularMesh.hpp>
#include <modeling/CopyShape.hpp>
#include <modeling/MakeBox.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeFace.hpp>
#include <modeling/MakePrism.hpp>
#include <modeling/MakeRevol.hpp>
#include <modeling/MakeShapeTool.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeWire.hpp>
#include <modeling/TransformShape.hpp>
#include <nurbs/NURBSAPIApprox.hpp>
#include <nurbs/NURBSAPIBuildCurve.hpp>
#include <nurbs/NURBSAPICircularSweep.hpp>
#include <nurbs/NURBSAPIConvert.hpp>
#include <nurbs/NURBSAPICurveNetworkSurface.hpp>
#include <nurbs/NURBSAPIExplicitSweep.hpp>
#include <nurbs/NURBSAPIExplode.hpp>
#include <nurbs/NURBSAPIExtend.hpp>
#include <nurbs/NURBSAPIInterpolate.hpp>
#include <nurbs/NURBSAPIJoin.hpp>
#include <nurbs/NURBSAPILinearSweep.hpp>
#include <nurbs/NURBSAPILoft.hpp>
#include <nurbs/NURBSAPIMakeNURBSFromBoundaries.hpp>
#include <nurbs/NURBSAPIMatch.hpp>
#include <nurbs/NURBSAPIModifyEndToPlane.hpp>
#include <nurbs/NURBSAPIOffsetCurveOnSurface.hpp>
#include <nurbs/NURBSAPIProject.hpp>
#include <nurbs/NURBSAPIRebuild.hpp>
#include <nurbs/NURBSAPIReplaceEdge.hpp>
#include <nurbs/NURBSAPISweep.hpp>
#include <nurbs/NURBSAPISweep2.hpp>
#include <nurbs/NURBSAPISweepRotation.hpp>
#include <nurbs/NURBSAPITrim.hpp>
#include <nurbs/NURBSAPIUntrim.hpp>
#include <nurbs/NURBSLinearSweepWithDraftDirectionLength.hpp>
#include <occtio/OCCTTool.hpp>
#include <offset/MakePipe.hpp>
#include <offset/MakePipeShell.hpp>
#include <topology/BRepAdaptorCurve2.hpp>
#include <topology/BRepAdaptorCurve3.hpp>
#include <topology/BRepAdaptorSurface.hpp>
#include <topology/BRepGlobalProperty.hpp>
#include <topology/BRepTool.hpp>
#include <topology/TopoBuilder.hpp>
#include <topology/TopoCompound.hpp>
#include <topology/TopoEdge.hpp>
#include <topology/TopoExplorer.hpp>
#include <topology/TopoExplorerTool.hpp>
#include <topology/TopoFace.hpp>
#include <topology/TopoShape.hpp>
#include <topology/TopoShell.hpp>
#include <topology/TopoTool.hpp>
#include <topology/TopoVertex.hpp>
#include <topology/TopoWire.hpp>
#include <topology/WireExplorer.hpp>
#include <topomesh/BRepMeshIncrementalMesh.hpp>
#include <nurbs/NURBSAPIBlend.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
#include <math/LineT.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/GeomAPIIntSurfaceSurface.hpp>
using namespace AMCAX;
namespace
{
	std::shared_ptr<Geom3BSplineCurve> CurveChooser(const int id, const std::shared_ptr<Geom3BSplineCurve>& curve0, const std::shared_ptr<Geom3BSplineCurve>& curve1, const std::shared_ptr<Geom3BSplineCurve>& curve2)
	{
		std::shared_ptr<Geom3BSplineCurve> result;
		switch (id)
		{
		case 0:
		{
			result = curve0;
			break;
		}
		case 1:
		{
			result = curve1;
			break;
		}
		case 2:
		{
			result = curve2;
			break;
		}
		}
		return result;
	}
;
	SECTION("TestCircularSweepWithCurveOnTangencySurface()")	
		{
			std::string filedir(INPUT_PATH_PREFIX "/TestNURBS/TestCircularSweepWithCurveOnTangencySurface/");
			auto guide = ReadBRepCurve(filedir + "guide.brep");
			auto surface = ReadBRepSurface(filedir + "surface.brep");
			auto spine = ReadBRepCurve(filedir + "spine.brep");
			CHECK(OCCTIO::OCCTTool::Write(MakeEdge(guide), OUTPUT_PATH_PREFIX "TestCircularSweepWithCurveOnTangencySurface_guide.brep"));
			CHECK(OCCTIO::OCCTTool::Write(MakeEdge(spine), OUTPUT_PATH_PREFIX "TestCircularSweepWithCurveOnTangencySurface_spine.brep"));
			CHECK(OCCTIO::OCCTTool::Write(MakeFace(surface, 0.0), OUTPUT_PATH_PREFIX "TestCircularSweepWithCurveOnTangencySurface_surface.brep"));
			LawConstant radiusLaw, angleLaw1, angleLaw2;
			radiusLaw.Set(10.0, 0.0, 1.0);
			angleLaw1.Set(0.0, 0.0, 1.0);
			angleLaw2.Set(M_PI_2, 0.0, 1.0);
			auto [status, surfaces] = NURBSAPICircularSweep::SweepWithCurveOnTangencySurface(guide, surface, radiusLaw, angleLaw1, angleLaw2, spine, spine->FirstParameter(), spine->LastParameter());
			CHECK(status == NURBSSweepStatus::Success);
			if (status == NURBSSweepStatus::Success && !surfaces.empty())
			{
				int nsurfaces = static_cast<int>(surfaces.size());
				for (int i = 0; i < nsurfaces; i++)
				{
					CHECK(OCCTIO::OCCTTool::Write(MakeFace(surfaces[i], 0.0), OUTPUT_PATH_PREFIX "TestCircularSweepWithCurveOnTangencySurface_result" + std::to_string(i) + ".brep"));
					CHECK(IsCurveOnSurf(1000, 0.1, guide, surfaces[i], 0.5));
					AMCAX::BRepExtremaDistShapeShape len(MakeFace(surface, 0.0), MakeFace(surfaces[i], 0.0));
					AMCAX::BRepExtremaDistShapeShape len1(MakeFace(surfaces[i], 0.0), MakeEdge(guide));
					CHECK(len1.Value() < 1.0);
					CHECK(len.Value() < 0.1);
				}
			}
			std::string filedir1 = OUTPUT_PATH_PREFIX;
			IndexSet<TopoShape> newshapeEdge1;
			IndexSet<TopoShape> newshapeEdge2;
			TopoExplorerTool::MapShapes(MakeFace(surfaces[0], 0.0), ShapeType::Edge, newshapeEdge1);
			TopoExplorerTool::MapShapes(MakeFace(surfaces[1], 0.0), ShapeType::Edge, newshapeEdge2);
			std::cout << "newshapedege.size" << newshapeEdge1.size() << endl;
			CHECK(OCCTIO::OCCTTool::Write(newshapeEdge1[0], OUTPUT_PATH_PREFIX "TestCircularSweepWithCurveOnTangencySurface_newshapeEdge1[0].brep"));
			CHECK(OCCTIO::OCCTTool::Write(newshapeEdge2[1], OUTPUT_PATH_PREFIX "TestCircularSweepWithCurveOnTangencySurface_newshapeEdge2[1].brep"));
			CHECK(OCCTIO::OCCTTool::Write(newshapeEdge2[2], OUTPUT_PATH_PREFIX "TestCircularSweepWithCurveOnTangencySurface_newshapeEdge2[2].brep"));
			CHECK(OCCTIO::OCCTTool::Write(newshapeEdge2[0], OUTPUT_PATH_PREFIX "TestCircularSweepWithCurveOnTangencySurface_newshapeEdge2[0].brep"));
			CHECK(OCCTIO::OCCTTool::Write(newshapeEdge2[3], OUTPUT_PATH_PREFIX "TestCircularSweepWithCurveOnTangencySurface_newshapeEdge2[3].brep"));
			auto edge0 = ReadBRepCurve(filedir1 + "TestCircularSweepWithCurveOnTangencySurface_newshapeEdge1[0].brep");
			auto edge1 = ReadBRepCurve(filedir1 + "TestCircularSweepWithCurveOnTangencySurface_newshapeEdge2[0].brep");
			CHECK(IsSurfTangent(100, 0.6, edge0, surface, surfaces[0], 20, 0));
			CHECK(IsSurfTangent(100, 0.6, edge1, surface, surfaces[0], 20, 0));
			guide->IncreaseDegree(5);
			spine->IncreaseDegree(5);
			surface->IncreaseDegree(5, 5);
			auto [status1, surfaces1] = NURBSAPICircularSweep::SweepWithCurveOnTangencySurface(guide, surface, radiusLaw, angleLaw1, angleLaw2, spine, spine->FirstParameter(), spine->LastParameter());
			CHECK(status1 == NURBSSweepStatus::Success);
			if (status1 == NURBSSweepStatus::Success && !surfaces.empty())
			{
				int nsurfaces = static_cast<int>(surfaces.size());
				for (int i = 0; i < nsurfaces; i++)
				{
					CHECK(OCCTIO::OCCTTool::Write(MakeFace(surfaces1[i], 0.0), OUTPUT_PATH_PREFIX "TestCircularSweepWithCurveOnTangencySurface_degree5result" + std::to_string(i) + ".brep"));
					CHECK(IsCurveOnSurf(1000, 0.1, guide, surfaces1[i], 0.5));
					double bsp3s = GetSurfaceProperties(MakeFace(surfaces1[i], 0.0), g, true, true);
					double bsp4s = GetSurfaceProperties(MakeFace(surfaces[i], 0.0), g, true, true);
					CHECK(bsp3s == Approx(bsp4s).margin(0.02));
				}
			}
		}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static std::shared_ptr<Geom3BSplineCurve> ToBSpline(const std::shared_ptr<Geom3Curve>& curve)	 @return Result BSpline curve
	 @param curve The given curve
	 @brief Convert a common curve to a BSpline curve
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include<common/Exception.hpp>
#include <nurbs/NURBSAPIConvert.hpp>
#include <topology/TopoEdge.hpp>
#include <topology/TopoTool.hpp>
#include <topology/TopoVertex.hpp>
#include <geometry/Geom3TrimmedCurve.hpp>
#include <geometry/Geom3BSplineCurve.hpp>
#include <occtio/OCCTTool.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeFace.hpp>
#include <geometry/Geom3Circle.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
#include <geometry/Geom3Line.hpp>
#include <geometry/Geom3BezierCurve.hpp>
#include <geometry/Geom3Ellipse.hpp>
#include <geometry/Geom3Hyperbola.hpp>
#include <geometry/Geom3Parabola.hpp>
#include <geometry/Geom3SphericalSurface.hpp>
#include <math/Sphere.hpp>
#include <geometry/Geom3Surface.hpp>
#include <geometry/Geom3BSplineSurface.hpp>
#include <geometry/Geom3TrimmedSurface.hpp>
#include <geometry/Geom3ElementarySurface.hpp>
#include <geometry/Geom3OffsetSurface.hpp>
#include <geometry/Geom3SweptSurface.hpp>
#include <geometry/Geom3SurfaceOfExtrusion.hpp>
#include <geometry/Geom3BezierSurface.hpp>
#include <math/Cone.hpp>
#include <geometry/Geom3ConicalSurface.hpp>
#include <geometry/Geom3CylindricalSurface.hpp>
#include <geometry/Geom3Plane.hpp>
#include <geometry/Geom3ToroidalSurface.hpp>
#include <geometry/Geom3SurfaceOfExtrusion.hpp>
#include <geometry/Geom3SurfaceOfRevolution.hpp>
using namespace std;
using namespace AMCAX;
double NurbsLinearCurve(const shared_ptr<Geom3Curve>& curve1, const shared_ptr<Geom3BSplineCurve>& curve2)
{
    TopoShape edge1 = MakeEdge(curve1);
    TopoShape edge2 = MakeEdge(curve2);
    GlobalProperty props1, props2;
    double len1 = GetLinearProperties(edge1, props1, true, false);
    double len2 = GetLinearProperties(edge2, props2, true, false);
    double len = abs(len1 - len2);
    return len;
}
double NurbsSurfaceResult(const shared_ptr<Geom3Surface>& surface1, const shared_ptr<Geom3BSplineSurface>& surface2)
{
    TopoFace f1 = MakeFace(surface1, 0.0);
    TopoFace f2 = MakeFace(surface2, 0.0);
    GlobalProperty props1, props2;
    double s1 = GetSurfaceProperties(f1, props1, true, false);
    double s2 = GetSurfaceProperties(f2, props2, true, false);
    double res = abs(s1 - s2);
    return res;
}
TEST_CASE("bug3: ConvertToBSplineCurve ", "[nurbs][convert][fixbug]")
{
    double res;
    double tol = 0.1;
    Point3 p(0.0, 0.0, 0.0);
    Direction3 dir(0.0, 0.0, 1.0);
    Direction3 dir1(1.0, 0.0, 0.0);
    shared_ptr<Geom3Curve> curve;
    curve = make_shared<Geom3Circle>(Frame3(p, dir), 1.0);
    shared_ptr<Geom3TrimmedCurve> TrimmedCurve = make_shared<Geom3TrimmedCurve>(curve, 0.0, M_PI);
    Axis3 axis(p, dir1);
    shared_ptr<Geom3SurfaceOfRevolution> surf;
    surf = make_shared<Geom3SurfaceOfRevolution>(TrimmedCurve, axis);
    shared_ptr<Geom3BSplineSurface> bspSurf = NURBSAPIConvert::ToBSpline(surf);
    res = NurbsSurfaceResult(surf, bspSurf);
    CHECK(res <= tol);
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static std::shared_ptr<Geom3BSplineSurface> ToBSpline(const std::shared_ptr<Geom3Surface>& surface)	 @return BSpline surface
	 @param surface The given surface
	 @brief Convert a common surface to a BSpline surface
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include<common/Exception.hpp>
#include <nurbs/NURBSAPIConvert.hpp>
#include <topology/TopoEdge.hpp>
#include <topology/TopoTool.hpp>
#include <topology/TopoVertex.hpp>
#include <geometry/Geom3TrimmedCurve.hpp>
#include <geometry/Geom3BSplineCurve.hpp>
#include <occtio/OCCTTool.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeFace.hpp>
#include <geometry/Geom3Circle.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
#include <geometry/Geom3Line.hpp>
#include <geometry/Geom3BezierCurve.hpp>
#include <geometry/Geom3Ellipse.hpp>
#include <geometry/Geom3Hyperbola.hpp>
#include <geometry/Geom3Parabola.hpp>
#include <geometry/Geom3SphericalSurface.hpp>
#include <math/Sphere.hpp>
#include <geometry/Geom3Surface.hpp>
#include <geometry/Geom3BSplineSurface.hpp>
#include <geometry/Geom3TrimmedSurface.hpp>
#include <geometry/Geom3ElementarySurface.hpp>
#include <geometry/Geom3OffsetSurface.hpp>
#include <geometry/Geom3SweptSurface.hpp>
#include <geometry/Geom3SurfaceOfExtrusion.hpp>
#include <geometry/Geom3BezierSurface.hpp>
#include <math/Cone.hpp>
#include <geometry/Geom3ConicalSurface.hpp>
#include <geometry/Geom3CylindricalSurface.hpp>
#include <geometry/Geom3Plane.hpp>
#include <geometry/Geom3ToroidalSurface.hpp>
#include <geometry/Geom3SurfaceOfExtrusion.hpp>
#include <geometry/Geom3SurfaceOfRevolution.hpp>
using namespace std;
using namespace AMCAX;
double NurbsLinearCurve(const shared_ptr<Geom3Curve>& curve1, const shared_ptr<Geom3BSplineCurve>& curve2)
{
    TopoShape edge1 = MakeEdge(curve1);
    TopoShape edge2 = MakeEdge(curve2);
    GlobalProperty props1, props2;
    double len1 = GetLinearProperties(edge1, props1, true, false);
    double len2 = GetLinearProperties(edge2, props2, true, false);
    double len = abs(len1 - len2);
    return len;
}
double NurbsSurfaceResult(const shared_ptr<Geom3Surface>& surface1, const shared_ptr<Geom3BSplineSurface>& surface2)
{
    TopoFace f1 = MakeFace(surface1, 0.0);
    TopoFace f2 = MakeFace(surface2, 0.0);
    GlobalProperty props1, props2;
    double s1 = GetSurfaceProperties(f1, props1, true, false);
    double s2 = GetSurfaceProperties(f2, props2, true, false);
    double res = abs(s1 - s2);
    return res;
}
TEST_CASE("bug2: ConvertToBSplineCurve ", "[nurbs][convert][fixbug]")
{
    double res;
    double tol = 3.5;
    shared_ptr<Geom3ToroidalSurface> surf;
    surf = make_shared<Geom3ToroidalSurface>(Frame3(), 5.0, 4.0);
    shared_ptr<Geom3BSplineSurface> bspSurf = NURBSAPIConvert::ToBSpline(surf);
    double u1 = surf->FirstUParameter();
    double u2 = surf->LastUParameter();
    double v1 = surf->FirstVParameter();
    double v2 = surf->LastVParameter();
    double u11 = bspSurf->FirstUParameter();
    double u22 = bspSurf->LastUParameter();
    double v11 = bspSurf->FirstVParameter();
    double v22 = bspSurf->LastVParameter();
    CHECK(u1 == u11);
    CHECK(u2 == u22);
    CHECK(v1 == v11);
    CHECK(v2 == v22);
    res = NurbsSurfaceResult(surf, bspSurf);
    CHECK(res <= tol);
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static std::vector<std::shared_ptr<Geom3BezierCurve>> ToBezier(const std::shared_ptr<Geom3BSplineCurve>& curve)	 @return Result Bezier curves
	 @param curve The BSpline curve
	 @brief Convert a BSpline curve to Bezier curves
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include<common/Exception.hpp>
#include <nurbs/NURBSAPIConvert.hpp>
#include <topology/TopoEdge.hpp>
#include <topology/TopoTool.hpp>
#include <topology/TopoVertex.hpp>
#include <geometry/Geom3TrimmedCurve.hpp>
#include <geometry/Geom3BSplineCurve.hpp>
#include <occtio/OCCTTool.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeFace.hpp>
#include <geometry/Geom3Circle.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
#include <geometry/Geom3Line.hpp>
#include <geometry/Geom3BezierCurve.hpp>
#include <geometry/Geom3Ellipse.hpp>
#include <geometry/Geom3Hyperbola.hpp>
#include <geometry/Geom3Parabola.hpp>
#include <geometry/Geom3SphericalSurface.hpp>
#include <math/Sphere.hpp>
#include <geometry/Geom3Surface.hpp>
#include <geometry/Geom3BSplineSurface.hpp>
#include <geometry/Geom3TrimmedSurface.hpp>
#include <geometry/Geom3ElementarySurface.hpp>
#include <geometry/Geom3OffsetSurface.hpp>
#include <geometry/Geom3SweptSurface.hpp>
#include <geometry/Geom3SurfaceOfExtrusion.hpp>
#include <geometry/Geom3BezierSurface.hpp>
#include <math/Cone.hpp>
#include <geometry/Geom3ConicalSurface.hpp>
#include <geometry/Geom3CylindricalSurface.hpp>
#include <geometry/Geom3Plane.hpp>
#include <geometry/Geom3ToroidalSurface.hpp>
#include <geometry/Geom3SurfaceOfExtrusion.hpp>
#include <geometry/Geom3SurfaceOfRevolution.hpp>
using namespace std;
using namespace AMCAX;
double NurbsLinearCurve(const shared_ptr<Geom3Curve>& curve1, const shared_ptr<Geom3BSplineCurve>& curve2)
{
    TopoShape edge1 = MakeEdge(curve1);
    TopoShape edge2 = MakeEdge(curve2);
    GlobalProperty props1, props2;
    double len1 = GetLinearProperties(edge1, props1, true, false);
    double len2 = GetLinearProperties(edge2, props2, true, false);
    double len = abs(len1 - len2);
    return len;
}
double NurbsSurfaceResult(const shared_ptr<Geom3Surface>& surface1, const shared_ptr<Geom3BSplineSurface>& surface2)
{
    TopoFace f1 = MakeFace(surface1, 0.0);
    TopoFace f2 = MakeFace(surface2, 0.0);
    GlobalProperty props1, props2;
    double s1 = GetSurfaceProperties(f1, props1, true, false);
    double s2 = GetSurfaceProperties(f2, props2, true, false);
    double res = abs(s1 - s2);
    return res;
}
TEST_CASE("case1: this is a test for ConvertToBezierCurve", "[nurbs][convert][P1]")
{
    OUTPUT_DIRECTORY(nurbs, Convert/convertBezierCurve);
    vector<Point3> poles;
    poles.push_back(Point3(0.0, -1.0, 0.0));
    poles.push_back(Point3(0.7, -0.7, 0.0));
    poles.push_back(Point3(1.0, -0.3, 0.0));
    poles.push_back(Point3(1.2, 0.0, 0.0));
    poles.push_back(Point3(2.0, 0.3, 0.0));
    poles.push_back(Point3(0.7, 1.7, 0.0));
    poles.push_back(Point3(0.0, 1.0, 0.0));
    vector<double> knots;
    knots.push_back(0.0);
    knots.push_back(0.25);
    knots.push_back(0.5);
    knots.push_back(0.75);
    knots.push_back(1.0);
    vector<int> mults(5, 1);
    mults.front() = 4;
    mults.back() = 4;
    shared_ptr<Geom3BSplineCurve> curve;
    curve = make_shared<Geom3BSplineCurve>(poles, knots, mults, 3, false);
	vector<shared_ptr<Geom3BezierCurve>> beziers = NURBSAPIConvert::ToBezier(curve);
    TopoShape edge1 = MakeEdge(beziers[0]);
    TopoShape edge2 = MakeEdge(beziers[1]);
    TopoShape edge3 = MakeEdge(beziers[2]);
    TopoShape edge4 = MakeEdge(beziers[3]);
    TopoShape edge = MakeEdge(curve);
    GlobalProperty props1, props2, props3, props4;
    double len1 = GetLinearProperties(edge1, props1, true, false);
    double len2 = GetLinearProperties(edge2, props2, true, false);
    double len3 = GetLinearProperties(edge3, props2, true, false);
    double len4 = GetLinearProperties(edge4, props2, true, false);
    double bspLen = GetLinearProperties(edge, props2, true, false);
    double bezLen = len1 + len2 + len3 + len4;
    double len = abs(bspLen - bezLen);
    CHECK(beziers.size() == 4);
    CHECK(len < 0.1);
    CHECK(curve->Type() == CurveType::BSplineCurve);
    CHECK(beziers[0]->Type() == CurveType::BezierCurve);
    OCCTIO::OCCTTool::Write(MakeEdge(curve), outdir + "curve.brep");
    OCCTIO::OCCTTool::Write(MakeEdge(beziers[0]), outdir + "beziers0.brep");
    OCCTIO::OCCTTool::Write(MakeEdge(beziers[1]), outdir + "beziers1.brep");
    OCCTIO::OCCTTool::Write(MakeEdge(beziers[2]), outdir + "beziers2.brep");
    OCCTIO::OCCTTool::Write(MakeEdge(beziers[3]), outdir + "beziers3.brep");
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static std::vector<std::pair<double, bool>> CalcParamCorrespondece( const std::vector<std::shared_ptr<Geom3Curve>>& curves, bool isPeriodic, bool isConsiderReverse),
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <nurbs/NURBSAPICorrespondence.hpp>
#include <modeling/MakeEdge.hpp>
#include <topology/TopoExplorerTool.hpp>
#include <nurbs/NURBSAPIConvert.hpp>
using namespace std;
#include<catch.hpp>
#include<testHelper.h>
#include <nurbs/NURBSAPICorrespondence.hpp>
#include <modeling/MakeEdge.hpp>
#include <topology/TopoExplorerTool.hpp>
#include <nurbs/NURBSAPIConvert.hpp>
using namespace std;
;
	SECTION("isPeriodic+isConsiderReverse")
	{
		bool isPeriodic = true;
		bool isConsiderReverse = true;
		vector<pair<double, bool>> corrs = NURBSAPICorrespondence::CalcParamCorrespondece(curves, isPeriodic, isConsiderReverse);
		CHECK(corrs[0].first == 0.0);
		CHECK(corrs[0].second == false);
		CHECK(corrs[1].first > 0.0);
		CHECK(corrs[1].second == true);
		CHECK(corrs[2].first > 0.0);
		CHECK(corrs[2].second == true);
		CHECK(corrs[3].first > 0.0);
		CHECK(corrs[3].second == true);
		CHECK(corrs[4].first > 0.0);
		CHECK(corrs[4].second == true);
		CHECK(corrs[5].first > 0.0);
		CHECK(corrs[5].second == true);
		CHECK(corrs[6].first > 0.0);
		CHECK(corrs[6].second == true);
		CHECK(corrs.size() == 7);
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static std::shared_ptr<Geom3BSplineSurface> CurveNetworkSurfaceGordon(const std::vector<std::shared_ptr<Geom3BSplineCurve>>& verticalCurves, const std::vector<std::shared_ptr<Geom3BSplineCurve>>& horizontalCurves)	 @return The Gordon surface which go through the curves
	 @param horizontalCurves Horizontal network curves
	 @param verticalCurves Vertical network curves
	 @brief Coons-Gordon surface
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <nurbs/NURBSAPICurveNetworkSurface.hpp>
#include <topology/TopoEdge.hpp>
#include <topology/TopoTool.hpp>
#include <modeling/MakeFace.hpp>
#include <nurbs/NURBSAPILoft.hpp>
#include <common/Precision.hpp>
#include <modeling/MakeEdge.hpp>
#include <occtio/OCCTTool.hpp>
#include <geometry/Geom3BSplineCurve.hpp>
#include <geometry/Geom3BSplineSurface.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
#include <topology/TopoExplorerTool.hpp>
#include <geometry/GeomAPIProjectPointOnSurface.hpp>
using namespace std;
using namespace AMCAX;
double NurbsSampleCurveOnSurface(int num, double tol, const shared_ptr<Geom3Curve>& curve, const shared_ptr<Geom3Surface>& surf)
{
	const int nsample = num;
	double fp1 = curve->FirstParameter();
	double lp1 = curve->LastParameter();
	double delta1 = (lp1 - fp1) / nsample;
	Point3 p;
	int n = 0;
	for (int i = 0; i < nsample; i++)
	{
		double t1 = fp1 + i * delta1;
		curve->D0(t1, p);
		GeomAPIProjectPointOnSurface projector(p, surf);
		double dis = projector.LowerDistance();
		if (dis <= tol)
		{
			n++;
		}
	}
	double res = 1.0 * (num - n) / num;
	return res;
}
vector< shared_ptr<Geom3BSplineCurve>> ConstructBSplineCurve()
{
	vector<shared_ptr<Geom3BSplineCurve>> vec;
	shared_ptr<Geom3BSplineCurve> vbsp1, vbsp2, vbsp3, vbsp4, hbsp1, hbsp2, hbsp3;
	{
		int deg = 3;
		std::vector<Point3> poles;
		poles.push_back(Point3(0.0, -1.0, 0.1));
		poles.push_back(Point3(0.07, -0.7, 0.2));
		poles.push_back(Point3(0.1, -0.3, 0.1));
		poles.push_back(Point3(0.12, 0.0, -0.1));
		poles.push_back(Point3(0.20, 0.3, -0.2));
		poles.push_back(Point3(0.07, 0.7, -0.3));
		poles.push_back(Point3(0.0, 1.0, 0.0));
		int nknots = static_cast<int>(poles.size()) - deg + 1;
		std::vector<double> knots(nknots);
		for (int i = 0; i < nknots; i++)
		{
			knots[i] = (double)i / (double)(nknots - 1.0);
		}
		std::vector<int> mults(nknots, 1);
		mults.front() = deg + 1;
		mults.back() = deg + 1;
		vbsp1 = std::make_shared<Geom3BSplineCurve>(poles, knots, mults, deg);
	}
	{
		int deg = 3;
		std::vector<Point3> poles;
		poles.push_back(Point3(2.0, -2.0, -0.1));
		poles.push_back(Point3(2.1, -1.3, -0.2));
		poles.push_back(Point3(2.15, -0.8, -0.1));
		poles.push_back(Point3(1.83, -0.2, 0.1));
		poles.push_back(Point3(1.48, 0.1, 0.2));
		poles.push_back(Point3(1.0, 1.0, 0.1));
		int nknots = static_cast<int>(poles.size()) - deg + 1;
		std::vector<double> knots(nknots);
		for (int i = 0; i < nknots; i++)
		{
			knots[i] = (double)i / (double)(nknots - 1.0);
		}
		std::vector<int> mults(nknots, 1);
		mults.front() = deg + 1;
		mults.back() = deg + 1;
		vbsp2 = std::make_shared<Geom3BSplineCurve>(poles, knots, mults, deg);
	}
	{
		int deg = 3;
		std::vector<Point3> poles;
		poles.push_back(Point3(3.0, -2.0, 0.1));
		poles.push_back(Point3(3.07, -1.3, 0.2));
		poles.push_back(Point3(3.1, -0.3, 0.1));
		poles.push_back(Point3(3.12, 0.0, -0.1));
		poles.push_back(Point3(3.0, 0.3, -0.2));
		poles.push_back(Point3(2.57, 0.7, -0.3));
		poles.push_back(Point3(2.2, 1.0, 0.0));
		int nknots = static_cast<int>(poles.size()) - deg + 1;
		std::vector<double> knots(nknots);
		for (int i = 0; i < nknots; i++)
		{
			knots[i] = (double)i / (double)(nknots - 1.0);
		}
		std::vector<int> mults(nknots, 1);
		mults.front() = deg + 1;
		mults.back() = deg + 1;
		vbsp3 = std::make_shared<Geom3BSplineCurve>(poles, knots, mults, deg);
	}
	{
		int deg = 3;
		std::vector<Point3> poles;
		poles.push_back(Point3(4.0, -1.5, -0.1));
		poles.push_back(Point3(4.1, -1.3, -0.2));
		poles.push_back(Point3(4.15, -0.8, -0.1));
		poles.push_back(Point3(3.83, -0.2, 0.1));
		poles.push_back(Point3(3.48, 0.1, 0.2));
		poles.push_back(Point3(3.0, 1.0, 0.1));
		int nknots = static_cast<int>(poles.size()) - deg + 1;
		std::vector<double> knots(nknots);
		for (int i = 0; i < nknots; i++)
		{
			knots[i] = (double)i / (double)(nknots - 1.0);
		}
		std::vector<int> mults(nknots, 1);
		mults.front() = deg + 1;
		mults.back() = deg + 1;
		vbsp4 = std::make_shared<Geom3BSplineCurve>(poles, knots, mults, deg);
	}
	{
		int deg = 3;
		std::vector<Point3> poles;
		poles.push_back(Point3(0.0, -1.0, 0.1));
		poles.push_back(Point3(0.9, -1.5, -0.1));
		poles.push_back(Point3(3.0, -1.8, 0.1));
		poles.push_back(Point3(4.0, -1.5, -0.1));
		int nknots = static_cast<int>(poles.size()) - deg + 1;
		std::vector<double> knots(nknots);
		for (int i = 0; i < nknots; i++)
		{
			knots[i] = (double)i / (double)(nknots - 1.0);
		}
		std::vector<int> mults(nknots, 1);
		mults.front() = deg + 1;
		mults.back() = deg + 1;
		hbsp1 = std::make_shared<Geom3BSplineCurve>(poles, knots, mults, deg);
	}
	{
		int deg = 3;
		std::vector<Point3> poles;
		poles.push_back(Point3(0.0, 0.0, 0.0));
		poles.push_back(Point3(1.2, -1.15, -0.1));
		poles.push_back(Point3(2.7, -1.05, 0.1));
		poles.push_back(Point3(3.7, -1.3, -0.1));
		poles.push_back(Point3(5.0, -1.0, 0.1));
		int nknots = static_cast<int>(poles.size()) - deg + 1;
		std::vector<double> knots(nknots);
		for (int i = 0; i < nknots; i++)
		{
			knots[i] = (double)i / (double)(nknots - 1.0);
		}
		std::vector<int> mults(nknots, 1);
		mults.front() = deg + 1;
		mults.back() = deg + 1;
		hbsp2 = std::make_shared<Geom3BSplineCurve>(poles, knots, mults, deg);
	}
	{
		int deg = 3;
		vector<Point3> poles;
		poles.push_back(Point3(0.0, 1.0, 0.0));
		poles.push_back(Point3(0.9, 0.15, -0.1));
		poles.push_back(Point3(1.7, 0.05, 0.1));
		poles.push_back(Point3(2.7, 0.3, -0.1));
		poles.push_back(Point3(3.0, 1.0, 0.1));
		int nknots = static_cast<int>(poles.size()) - deg + 1;
		vector<double> knots(nknots);
		for (int i = 0; i < nknots; i++)
		{
			knots[i] = (double)i / (double)(nknots - 1.0);
		}
		vector<int> mults(nknots, 1);
		mults.front() = deg + 1;
		mults.back() = deg + 1;
		hbsp3 = make_shared<Geom3BSplineCurve>(poles, knots, mults, deg);
	}
	vec.push_back(vbsp1);
	vec.push_back(vbsp2);
	vec.push_back(vbsp3);
	vec.push_back(vbsp4);
	vec.push_back(hbsp1);
	vec.push_back(hbsp2);
	vec.push_back(hbsp3);
	return vec;
}
TEST_CASE("bug1: CurveNetworkSurface ", "[nurbs][CurveNetworkSurface][fixbug]")
{
	OUTPUT_DIRECTORY(nurbs, CurveNetworkSurface/bug464);
	double refTol = 0.1;
	vector< shared_ptr<Geom3BSplineCurve>> vec = ConstructBSplineCurve();
	TopoEdge edge1 = MakeEdge(vec[0]);
	TopoEdge edge2 = MakeEdge(vec[1]);
	TopoEdge edge3 = MakeEdge(vec[2]);
	TopoEdge edge4 = MakeEdge(vec[3]);
	TopoEdge edge5 = MakeEdge(vec[4]);
	TopoEdge edge6 = MakeEdge(vec[5]);
	TopoEdge edge7 = MakeEdge(vec[6]);
	vector<shared_ptr<Geom3BSplineCurve>> horizontalCurves, verticalCurves;
	verticalCurves.push_back(vec[0]);
	verticalCurves.push_back(vec[1]);
	verticalCurves.push_back(vec[2]);
	verticalCurves.push_back(vec[3]);
	horizontalCurves.push_back(vec[4]);
	horizontalCurves.push_back(vec[5]);
	horizontalCurves.push_back(vec[6]);
	shared_ptr<Geom3BSplineSurface> surf = NURBSAPICurveNetworkSurface::CurveNetworkSurfaceGordon(verticalCurves, horizontalCurves);
	TopoShape surface = MakeFace(surf, 0.0);
	BRepExtremaDistShapeShape dist1(edge1, surface);
	BRepExtremaDistShapeShape dist2(edge2, surface);
	BRepExtremaDistShapeShape dist3(edge3, surface);
	BRepExtremaDistShapeShape dist4(edge4, surface);
	BRepExtremaDistShapeShape dist5(edge5, surface);
	BRepExtremaDistShapeShape dist6(edge6, surface);
	BRepExtremaDistShapeShape dist7(edge7, surface);
	CHECK(dist3.Value() <= Approx(refTol));
	CHECK(dist4.Value() <= Approx(refTol));
	CHECK(dist7.Value() <= Approx(refTol));
	OCCTIO::OCCTTool::Write(MakeEdge(vec[0]), outdir + "vbsp1.brep");
	OCCTIO::OCCTTool::Write(MakeEdge(vec[1]), outdir + "vbsp2.brep");
	OCCTIO::OCCTTool::Write(MakeEdge(vec[2]), outdir + "vbsp3.brep");
	OCCTIO::OCCTTool::Write(MakeEdge(vec[3]), outdir + "vbsp4.brep");
	OCCTIO::OCCTTool::Write(MakeEdge(vec[4]), outdir + "hbsp1.brep");
	OCCTIO::OCCTTool::Write(MakeEdge(vec[5]), outdir + "hbsp2.brep");
	OCCTIO::OCCTTool::Write(MakeEdge(vec[6]), outdir + "hbsp3.brep");
	OCCTIO::OCCTTool::Write(surface, outdir + "surfResult.brep");
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static std::pair<NURBSSweepStatus, std::vector<std::shared_ptr<Geom3BSplineSurface>>> SweepWithReferenceSurface( const std::shared_ptr<Geom3BSplineCurve>& profile, const std::shared_ptr<Geom3BSplineCurve>& guide, const std::shared_ptr<Geom3BSplineSurface>& reference, const LawFunction& angleLawFunc, const std::shared_ptr<Geom3BSplineCurve>& spine, double spineLeftBound, double spineRightBound),
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <filesystem>
#include <fstream>
#include <random>
#include <sstream>
#include <nurbs/NURBSAPIGetGeometry.hpp>
#include <nurbs/NURBSAPIConicalSweep.hpp>
#include <boolean/BoolBRepCut.hpp>
#include <common/CartesianCoordinateSystem.hpp>
#include <common/IndexMap.hpp>
#include <common/QuaternionT.hpp>
#include <geomAlgo/LawBSpline.hpp>
#include <geomAlgo/LawConstant.hpp>
#include <nurbs/NURBSAPISmooth.hpp>
#include <geomAlgo/MakeConic2FromConstraints.hpp>
#include <geometry/Adaptor3CurveOnSurface.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/AdaptorGeom3Surface.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/Geom2Circle.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/Geom2Hyperbola.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom3BSplineCurve.hpp>
#include <geometry/Geom3BSplineSurface.hpp>
#include <geometry/Geom3Circle.hpp>
#include <geometry/Geom3Line.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
#include <geometry/Geom3Plane.hpp>
#include <geometry/Geom3SphericalSurface.hpp>
#include <geometry/Geom3Surface.hpp>
#include <geometry/Geom3TrimmedCurve.hpp>
#include <geometry/Geom3TrimmedSurface.hpp>
#include <geometry/GeomAPIExtremaCurveCurve3.hpp>
#include <geometry/GeomAPIProjectPointOnCurve2.hpp>
#include <geometry/GeomAPIProjectPointOnCurve3.hpp>
#include <geometry/GeomAPIProjectPointOnSurface.hpp>
#include <geometry/GeometryTool.hpp>
#include <geometry/GlobalProperty.hpp>
#include <healing/ShapeFixTool.hpp>
#include <io/STLTool.hpp>
#include <math/Sphere.hpp>
#include <math/TriangularMesh.hpp>
#include <modeling/CopyShape.hpp>
#include <modeling/MakeBox.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeFace.hpp>
#include <modeling/MakePrism.hpp>
#include <modeling/MakeRevol.hpp>
#include <modeling/MakeShapeTool.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeWire.hpp>
#include <modeling/TransformShape.hpp>
#include <nurbs/NURBSAPIApprox.hpp>
#include <nurbs/NURBSAPIBuildCurve.hpp>
#include <nurbs/NURBSAPICircularSweep.hpp>
#include <nurbs/NURBSAPIConvert.hpp>
#include <nurbs/NURBSAPICurveNetworkSurface.hpp>
#include <nurbs/NURBSAPIExplicitSweep.hpp>
#include <nurbs/NURBSAPIExplode.hpp>
#include <nurbs/NURBSAPIExtend.hpp>
#include <nurbs/NURBSAPIInterpolate.hpp>
#include <nurbs/NURBSAPIJoin.hpp>
#include <nurbs/NURBSAPILinearSweep.hpp>
#include <nurbs/NURBSAPILoft.hpp>
#include <nurbs/NURBSAPIMakeNURBSFromBoundaries.hpp>
#include <nurbs/NURBSAPIMatch.hpp>
#include <nurbs/NURBSAPIModifyEndToPlane.hpp>
#include <nurbs/NURBSAPIOffsetCurveOnSurface.hpp>
#include <nurbs/NURBSAPIProject.hpp>
#include <nurbs/NURBSAPIRebuild.hpp>
#include <nurbs/NURBSAPIReplaceEdge.hpp>
#include <nurbs/NURBSAPISweep.hpp>
#include <nurbs/NURBSAPISweep2.hpp>
#include <nurbs/NURBSAPISweepRotation.hpp>
#include <nurbs/NURBSAPITrim.hpp>
#include <nurbs/NURBSAPIUntrim.hpp>
#include <nurbs/NURBSLinearSweepWithDraftDirectionLength.hpp>
#include <occtio/OCCTTool.hpp>
#include <offset/MakePipe.hpp>
#include <offset/MakePipeShell.hpp>
#include <topology/BRepAdaptorCurve2.hpp>
#include <topology/BRepAdaptorCurve3.hpp>
#include <topology/BRepAdaptorSurface.hpp>
#include <topology/BRepGlobalProperty.hpp>
#include <topology/BRepTool.hpp>
#include <topology/TopoBuilder.hpp>
#include <topology/TopoCompound.hpp>
#include <topology/TopoEdge.hpp>
#include <topology/TopoExplorer.hpp>
#include <topology/TopoExplorerTool.hpp>
#include <topology/TopoFace.hpp>
#include <topology/TopoShape.hpp>
#include <topology/TopoShell.hpp>
#include <topology/TopoTool.hpp>
#include <topology/TopoVertex.hpp>
#include <topology/TopoWire.hpp>
#include <topology/WireExplorer.hpp>
#include <topomesh/BRepMeshIncrementalMesh.hpp>
#include <nurbs/NURBSAPIBlend.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
#include <math/LineT.hpp>
#include <hatch/BRepClassificationTools.hpp>
using namespace AMCAX;
namespace
{
	std::shared_ptr<Geom3BSplineCurve> CurveChooser(const int id, const std::shared_ptr<Geom3BSplineCurve>& curve0, const std::shared_ptr<Geom3BSplineCurve>& curve1, const std::shared_ptr<Geom3BSplineCurve>& curve2)
	{
		std::shared_ptr<Geom3BSplineCurve> result;
		switch (id)
		{
		case 0:
		{
			result = curve0;
			break;
		}
		case 1:
		{
			result = curve1;
			break;
		}
		case 2:
		{
			result = curve2;
			break;
		}
		}
		return result;
	}
} 
#include<catch.hpp>
#include<testHelper.h>
#include <filesystem>
#include <fstream>
#include <random>
#include <sstream>
#include <nurbs/NURBSAPIGetGeometry.hpp>
#include <nurbs/NURBSAPIConicalSweep.hpp>
#include <boolean/BoolBRepCut.hpp>
#include <common/CartesianCoordinateSystem.hpp>
#include <common/IndexMap.hpp>
#include <common/QuaternionT.hpp>
#include <geomAlgo/LawBSpline.hpp>
#include <geomAlgo/LawConstant.hpp>
#include <nurbs/NURBSAPISmooth.hpp>
#include <geomAlgo/MakeConic2FromConstraints.hpp>
#include <geometry/Adaptor3CurveOnSurface.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/AdaptorGeom3Surface.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/Geom2Circle.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/Geom2Hyperbola.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom3BSplineCurve.hpp>
#include <geometry/Geom3BSplineSurface.hpp>
#include <geometry/Geom3Circle.hpp>
#include <geometry/Geom3Line.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
#include <geometry/Geom3Plane.hpp>
#include <geometry/Geom3SphericalSurface.hpp>
#include <geometry/Geom3Surface.hpp>
#include <geometry/Geom3TrimmedCurve.hpp>
#include <geometry/Geom3TrimmedSurface.hpp>
#include <geometry/GeomAPIExtremaCurveCurve3.hpp>
#include <geometry/GeomAPIProjectPointOnCurve2.hpp>
#include <geometry/GeomAPIProjectPointOnCurve3.hpp>
#include <geometry/GeomAPIProjectPointOnSurface.hpp>
#include <geometry/GeometryTool.hpp>
#include <geometry/GlobalProperty.hpp>
#include <healing/ShapeFixTool.hpp>
#include <io/STLTool.hpp>
#include <math/Sphere.hpp>
#include <math/TriangularMesh.hpp>
#include <modeling/CopyShape.hpp>
#include <modeling/MakeBox.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeFace.hpp>
#include <modeling/MakePrism.hpp>
#include <modeling/MakeRevol.hpp>
#include <modeling/MakeShapeTool.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeWire.hpp>
#include <modeling/TransformShape.hpp>
#include <nurbs/NURBSAPIApprox.hpp>
#include <nurbs/NURBSAPIBuildCurve.hpp>
#include <nurbs/NURBSAPICircularSweep.hpp>
#include <nurbs/NURBSAPIConvert.hpp>
#include <nurbs/NURBSAPICurveNetworkSurface.hpp>
#include <nurbs/NURBSAPIExplicitSweep.hpp>
#include <nurbs/NURBSAPIExplode.hpp>
#include <nurbs/NURBSAPIExtend.hpp>
#include <nurbs/NURBSAPIInterpolate.hpp>
#include <nurbs/NURBSAPIJoin.hpp>
#include <nurbs/NURBSAPILinearSweep.hpp>
#include <nurbs/NURBSAPILoft.hpp>
#include <nurbs/NURBSAPIMakeNURBSFromBoundaries.hpp>
#include <nurbs/NURBSAPIMatch.hpp>
#include <nurbs/NURBSAPIModifyEndToPlane.hpp>
#include <nurbs/NURBSAPIOffsetCurveOnSurface.hpp>
#include <nurbs/NURBSAPIProject.hpp>
#include <nurbs/NURBSAPIRebuild.hpp>
#include <nurbs/NURBSAPIReplaceEdge.hpp>
#include <nurbs/NURBSAPISweep.hpp>
#include <nurbs/NURBSAPISweep2.hpp>
#include <nurbs/NURBSAPISweepRotation.hpp>
#include <nurbs/NURBSAPITrim.hpp>
#include <nurbs/NURBSAPIUntrim.hpp>
#include <nurbs/NURBSLinearSweepWithDraftDirectionLength.hpp>
#include <occtio/OCCTTool.hpp>
#include <offset/MakePipe.hpp>
#include <offset/MakePipeShell.hpp>
#include <topology/BRepAdaptorCurve2.hpp>
#include <topology/BRepAdaptorCurve3.hpp>
#include <topology/BRepAdaptorSurface.hpp>
#include <topology/BRepGlobalProperty.hpp>
#include <topology/BRepTool.hpp>
#include <topology/TopoBuilder.hpp>
#include <topology/TopoCompound.hpp>
#include <topology/TopoEdge.hpp>
#include <topology/TopoExplorer.hpp>
#include <topology/TopoExplorerTool.hpp>
#include <topology/TopoFace.hpp>
#include <topology/TopoShape.hpp>
#include <topology/TopoShell.hpp>
#include <topology/TopoTool.hpp>
#include <topology/TopoVertex.hpp>
#include <topology/TopoWire.hpp>
#include <topology/WireExplorer.hpp>
#include <topomesh/BRepMeshIncrementalMesh.hpp>
#include <nurbs/NURBSAPIBlend.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
#include <math/LineT.hpp>
#include <hatch/BRepClassificationTools.hpp>
using namespace AMCAX;
namespace
{
	std::shared_ptr<Geom3BSplineCurve> CurveChooser(const int id, const std::shared_ptr<Geom3BSplineCurve>& curve0, const std::shared_ptr<Geom3BSplineCurve>& curve1, const std::shared_ptr<Geom3BSplineCurve>& curve2)
	{
		std::shared_ptr<Geom3BSplineCurve> result;
		switch (id)
		{
		case 0:
		{
			result = curve0;
			break;
		}
		case 1:
		{
			result = curve1;
			break;
		}
		case 2:
		{
			result = curve2;
			break;
		}
		}
		return result;
	}
;
	SECTION("TestExplicitSweepWithReferenceSurface()")
	{
		std::string filedir = INPUT_PATH_PREFIX "/TestNURBS/TestExplicitSweepWithReferenceSurface/";
		auto surface = ReadBRepSurface(filedir + "surface.brep");
		CHECK(OCCTIO::OCCTTool::Write(MakeFace(surface, 0.0), OUTPUT_PATH_PREFIX "TestExplicitSweepWithReferenceSurface_surface.brep"));
		auto profile = ReadBRepCurve(filedir + "profile.brep");
		CHECK(OCCTIO::OCCTTool::Write(MakeEdge(profile), OUTPUT_PATH_PREFIX "TestExplicitSweepWithReferenceSurface_profile.brep"));
		CHECK(OCCTIO::OCCTTool::Write(MakeVertex(profile->Pole(0)), OUTPUT_PATH_PREFIX "TestExplicitSweepWithReferenceSurface_pole.brep"));
		auto guide = ReadBRepCurve(filedir + "guide.brep");
		CHECK(OCCTIO::OCCTTool::Write(MakeEdge(guide), OUTPUT_PATH_PREFIX "TestExplicitSweepWithReferenceSurface_guide.brep"));
		LawConstant law;
		law.Set(0.0, 0.0, 1.0);
		auto [status, surfaces] = NURBSAPIExplicitSweep::SweepWithReferenceSurface(profile, guide, surface, law, guide, guide->FirstParameter(), guide->LastParameter());
		CHECK(status == NURBSSweepStatus::Success);
		if (status == NURBSSweepStatus::Success)
		{
			CHECK(OCCTIO::OCCTTool::Write(MakeFace(surfaces.front(), 0.0), OUTPUT_PATH_PREFIX "TestExplicitSweepWithReferenceSurface_result.brep"));
			CHECK(IsCurveOnSurf(1000, 0.1, guide, surfaces[0], 0.1));
			CHECK(IsCurveOnSurf(1000, 0.1, profile, surfaces[0], 0.1));
			AMCAX::BRepExtremaDistShapeShape len1(MakeFace(surfaces[0], 0.0), MakeEdge(guide));
			AMCAX::BRepExtremaDistShapeShape len2(MakeFace(surfaces[0], 0.0), MakeEdge(profile));
			AMCAX::BRepExtremaDistShapeShape len3(MakeFace(surfaces[0], 0.0), MakeFace(surface, 0.0));
			CHECK(len1.Value() == Approx(0.0).margin(0.1));
			CHECK(len2.Value() == Approx(0.0).margin(0.1));
			CHECK(len3.Value() == Approx(0.0).margin(0.1));
			IndexSet<TopoShape> newshapeEdge1;
			TopoExplorerTool::MapShapes(MakeFace(surfaces.front(), 0.0), ShapeType::Edge, newshapeEdge1);
			std::cout << "newshapeedge1=" << newshapeEdge1.size() << std::endl;
			TopoExplorer ex0(newshapeEdge1[1], ShapeType::Edge);
			TopoExplorer ex1(newshapeEdge1[3], ShapeType::Edge);
			TopoEdge e0 = static_cast<const TopoEdge&>(ex0.Value());
			TopoEdge e1 = static_cast<const TopoEdge&>(ex1.Value());
			auto edge0 = NURBSAPIGetGeometry::GetCurve(e0);
			auto edge1 = NURBSAPIGetGeometry::GetCurve(e1);
			double n0 = NurbsSampleCurve(100, 0.15, edge0, profile);
			CHECK(n0 < 0.2);
			profile->IncreaseDegree(11);
			guide->IncreaseDegree(11);
			surface->IncreaseDegree(11,11);
			auto [status1, surfaces1] = NURBSAPIExplicitSweep::SweepWithReferenceSurface(profile, guide, surface, law, guide, guide->FirstParameter(), guide->LastParameter());
			CHECK(status1 == NURBSSweepStatus::Success);
			if (status1 == NURBSSweepStatus::Success)
			{
				CHECK(OCCTIO::OCCTTool::Write(MakeFace(surfaces.front(), 0.0), OUTPUT_PATH_PREFIX "TestExplicitSweepWithReferenceSurface_degree11result.brep"));
				CHECK(IsCurveOnSurf(1000, 0.1, guide, surfaces[0], 0.1));
				CHECK(IsCurveOnSurf(1000, 0.1, profile, surfaces[0], 0.1));
				AMCAX::BRepExtremaDistShapeShape len1(MakeFace(surfaces[0], 0.0), MakeEdge(guide));
				AMCAX::BRepExtremaDistShapeShape len2(MakeFace(surfaces[0], 0.0), MakeEdge(profile));
				AMCAX::BRepExtremaDistShapeShape len3(MakeFace(surfaces[0], 0.0), MakeFace(surface, 0.0));
				CHECK(len1.Value() == Approx(0.0).margin(0.1));
				CHECK(len2.Value() == Approx(0.0).margin(0.1));
				CHECK(len3.Value() == Approx(0.0).margin(0.1));
				double bsp3s = GetSurfaceProperties(MakeFace(surfaces1[0], 0.0), g, true, true);
				double bsp4s = GetSurfaceProperties(MakeFace(surfaces[0], 0.0), g, true, true);
				CHECK(bsp3s == Approx(bsp4s).margin(0.02));
			}
		}
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static std::pair<NURBSSweepStatus, std::shared_ptr<Geom3BSplineSurface>> SweepWithTwoGuideCurves( const std::shared_ptr<Geom3BSplineCurve>& profile, const std::shared_ptr<Geom3BSplineCurve>& guide1, const std::shared_ptr<Geom3BSplineCurve>& guide2, Point3 anchorPoint1, Point3 anchorPoint2, const std::shared_ptr<Geom3BSplineCurve>& spine, double spineLeftBound, double spineRightBound),
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <filesystem>
#include <fstream>
#include <random>
#include <sstream>
#include <nurbs/NURBSAPIGetGeometry.hpp>
#include <nurbs/NURBSAPIConicalSweep.hpp>
#include <boolean/BoolBRepCut.hpp>
#include <common/CartesianCoordinateSystem.hpp>
#include <common/IndexMap.hpp>
#include <common/QuaternionT.hpp>
#include <geomAlgo/LawBSpline.hpp>
#include <geomAlgo/LawConstant.hpp>
#include <nurbs/NURBSAPISmooth.hpp>
#include <geomAlgo/MakeConic2FromConstraints.hpp>
#include <geometry/Adaptor3CurveOnSurface.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/AdaptorGeom3Surface.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/Geom2Circle.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/Geom2Hyperbola.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom3BSplineCurve.hpp>
#include <geometry/Geom3BSplineSurface.hpp>
#include <geometry/Geom3Circle.hpp>
#include <geometry/Geom3Line.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
#include <geometry/Geom3Plane.hpp>
#include <geometry/Geom3SphericalSurface.hpp>
#include <geometry/Geom3Surface.hpp>
#include <geometry/Geom3TrimmedCurve.hpp>
#include <geometry/Geom3TrimmedSurface.hpp>
#include <geometry/GeomAPIExtremaCurveCurve3.hpp>
#include <geometry/GeomAPIProjectPointOnCurve2.hpp>
#include <geometry/GeomAPIProjectPointOnCurve3.hpp>
#include <geometry/GeomAPIProjectPointOnSurface.hpp>
#include <geometry/GeometryTool.hpp>
#include <geometry/GlobalProperty.hpp>
#include <healing/ShapeFixTool.hpp>
#include <io/STLTool.hpp>
#include <math/Sphere.hpp>
#include <math/TriangularMesh.hpp>
#include <modeling/CopyShape.hpp>
#include <modeling/MakeBox.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeFace.hpp>
#include <modeling/MakePrism.hpp>
#include <modeling/MakeRevol.hpp>
#include <modeling/MakeShapeTool.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeWire.hpp>
#include <modeling/TransformShape.hpp>
#include <nurbs/NURBSAPIApprox.hpp>
#include <nurbs/NURBSAPIBuildCurve.hpp>
#include <nurbs/NURBSAPICircularSweep.hpp>
#include <nurbs/NURBSAPIConvert.hpp>
#include <nurbs/NURBSAPICurveNetworkSurface.hpp>
#include <nurbs/NURBSAPIExplicitSweep.hpp>
#include <nurbs/NURBSAPIExplode.hpp>
#include <nurbs/NURBSAPIExtend.hpp>
#include <nurbs/NURBSAPIInterpolate.hpp>
#include <nurbs/NURBSAPIJoin.hpp>
#include <nurbs/NURBSAPILinearSweep.hpp>
#include <nurbs/NURBSAPILoft.hpp>
#include <nurbs/NURBSAPIMakeNURBSFromBoundaries.hpp>
#include <nurbs/NURBSAPIMatch.hpp>
#include <nurbs/NURBSAPIModifyEndToPlane.hpp>
#include <nurbs/NURBSAPIOffsetCurveOnSurface.hpp>
#include <nurbs/NURBSAPIProject.hpp>
#include <nurbs/NURBSAPIRebuild.hpp>
#include <nurbs/NURBSAPIReplaceEdge.hpp>
#include <nurbs/NURBSAPISweep.hpp>
#include <nurbs/NURBSAPISweep2.hpp>
#include <nurbs/NURBSAPISweepRotation.hpp>
#include <nurbs/NURBSAPITrim.hpp>
#include <nurbs/NURBSAPIUntrim.hpp>
#include <nurbs/NURBSLinearSweepWithDraftDirectionLength.hpp>
#include <occtio/OCCTTool.hpp>
#include <offset/MakePipe.hpp>
#include <offset/MakePipeShell.hpp>
#include <topology/BRepAdaptorCurve2.hpp>
#include <topology/BRepAdaptorCurve3.hpp>
#include <topology/BRepAdaptorSurface.hpp>
#include <topology/BRepGlobalProperty.hpp>
#include <topology/BRepTool.hpp>
#include <topology/TopoBuilder.hpp>
#include <topology/TopoCompound.hpp>
#include <topology/TopoEdge.hpp>
#include <topology/TopoExplorer.hpp>
#include <topology/TopoExplorerTool.hpp>
#include <topology/TopoFace.hpp>
#include <topology/TopoShape.hpp>
#include <topology/TopoShell.hpp>
#include <topology/TopoTool.hpp>
#include <topology/TopoVertex.hpp>
#include <topology/TopoWire.hpp>
#include <topology/WireExplorer.hpp>
#include <topomesh/BRepMeshIncrementalMesh.hpp>
#include <nurbs/NURBSAPIBlend.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
#include <math/LineT.hpp>
#include <hatch/BRepClassificationTools.hpp>
using namespace AMCAX;
namespace
{
	std::shared_ptr<Geom3BSplineCurve> CurveChooser(const int id, const std::shared_ptr<Geom3BSplineCurve>& curve0, const std::shared_ptr<Geom3BSplineCurve>& curve1, const std::shared_ptr<Geom3BSplineCurve>& curve2)
	{
		std::shared_ptr<Geom3BSplineCurve> result;
		switch (id)
		{
		case 0:
		{
			result = curve0;
			break;
		}
		case 1:
		{
			result = curve1;
			break;
		}
		case 2:
		{
			result = curve2;
			break;
		}
		}
		return result;
	}
} 
#include<catch.hpp>
#include<testHelper.h>
#include <filesystem>
#include <fstream>
#include <random>
#include <sstream>
#include <nurbs/NURBSAPIGetGeometry.hpp>
#include <nurbs/NURBSAPIConicalSweep.hpp>
#include <boolean/BoolBRepCut.hpp>
#include <common/CartesianCoordinateSystem.hpp>
#include <common/IndexMap.hpp>
#include <common/QuaternionT.hpp>
#include <geomAlgo/LawBSpline.hpp>
#include <geomAlgo/LawConstant.hpp>
#include <nurbs/NURBSAPISmooth.hpp>
#include <geomAlgo/MakeConic2FromConstraints.hpp>
#include <geometry/Adaptor3CurveOnSurface.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/AdaptorGeom3Surface.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/Geom2Circle.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/Geom2Hyperbola.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom3BSplineCurve.hpp>
#include <geometry/Geom3BSplineSurface.hpp>
#include <geometry/Geom3Circle.hpp>
#include <geometry/Geom3Line.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
#include <geometry/Geom3Plane.hpp>
#include <geometry/Geom3SphericalSurface.hpp>
#include <geometry/Geom3Surface.hpp>
#include <geometry/Geom3TrimmedCurve.hpp>
#include <geometry/Geom3TrimmedSurface.hpp>
#include <geometry/GeomAPIExtremaCurveCurve3.hpp>
#include <geometry/GeomAPIProjectPointOnCurve2.hpp>
#include <geometry/GeomAPIProjectPointOnCurve3.hpp>
#include <geometry/GeomAPIProjectPointOnSurface.hpp>
#include <geometry/GeometryTool.hpp>
#include <geometry/GlobalProperty.hpp>
#include <healing/ShapeFixTool.hpp>
#include <io/STLTool.hpp>
#include <math/Sphere.hpp>
#include <math/TriangularMesh.hpp>
#include <modeling/CopyShape.hpp>
#include <modeling/MakeBox.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeFace.hpp>
#include <modeling/MakePrism.hpp>
#include <modeling/MakeRevol.hpp>
#include <modeling/MakeShapeTool.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeWire.hpp>
#include <modeling/TransformShape.hpp>
#include <nurbs/NURBSAPIApprox.hpp>
#include <nurbs/NURBSAPIBuildCurve.hpp>
#include <nurbs/NURBSAPICircularSweep.hpp>
#include <nurbs/NURBSAPIConvert.hpp>
#include <nurbs/NURBSAPICurveNetworkSurface.hpp>
#include <nurbs/NURBSAPIExplicitSweep.hpp>
#include <nurbs/NURBSAPIExplode.hpp>
#include <nurbs/NURBSAPIExtend.hpp>
#include <nurbs/NURBSAPIInterpolate.hpp>
#include <nurbs/NURBSAPIJoin.hpp>
#include <nurbs/NURBSAPILinearSweep.hpp>
#include <nurbs/NURBSAPILoft.hpp>
#include <nurbs/NURBSAPIMakeNURBSFromBoundaries.hpp>
#include <nurbs/NURBSAPIMatch.hpp>
#include <nurbs/NURBSAPIModifyEndToPlane.hpp>
#include <nurbs/NURBSAPIOffsetCurveOnSurface.hpp>
#include <nurbs/NURBSAPIProject.hpp>
#include <nurbs/NURBSAPIRebuild.hpp>
#include <nurbs/NURBSAPIReplaceEdge.hpp>
#include <nurbs/NURBSAPISweep.hpp>
#include <nurbs/NURBSAPISweep2.hpp>
#include <nurbs/NURBSAPISweepRotation.hpp>
#include <nurbs/NURBSAPITrim.hpp>
#include <nurbs/NURBSAPIUntrim.hpp>
#include <nurbs/NURBSLinearSweepWithDraftDirectionLength.hpp>
#include <occtio/OCCTTool.hpp>
#include <offset/MakePipe.hpp>
#include <offset/MakePipeShell.hpp>
#include <topology/BRepAdaptorCurve2.hpp>
#include <topology/BRepAdaptorCurve3.hpp>
#include <topology/BRepAdaptorSurface.hpp>
#include <topology/BRepGlobalProperty.hpp>
#include <topology/BRepTool.hpp>
#include <topology/TopoBuilder.hpp>
#include <topology/TopoCompound.hpp>
#include <topology/TopoEdge.hpp>
#include <topology/TopoExplorer.hpp>
#include <topology/TopoExplorerTool.hpp>
#include <topology/TopoFace.hpp>
#include <topology/TopoShape.hpp>
#include <topology/TopoShell.hpp>
#include <topology/TopoTool.hpp>
#include <topology/TopoVertex.hpp>
#include <topology/TopoWire.hpp>
#include <topology/WireExplorer.hpp>
#include <topomesh/BRepMeshIncrementalMesh.hpp>
#include <nurbs/NURBSAPIBlend.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
#include <math/LineT.hpp>
#include <hatch/BRepClassificationTools.hpp>
using namespace AMCAX;
namespace
{
	std::shared_ptr<Geom3BSplineCurve> CurveChooser(const int id, const std::shared_ptr<Geom3BSplineCurve>& curve0, const std::shared_ptr<Geom3BSplineCurve>& curve1, const std::shared_ptr<Geom3BSplineCurve>& curve2)
	{
		std::shared_ptr<Geom3BSplineCurve> result;
		switch (id)
		{
		case 0:
		{
			result = curve0;
			break;
		}
		case 1:
		{
			result = curve1;
			break;
		}
		case 2:
		{
			result = curve2;
			break;
		}
		}
		return result;
	}
;
	SECTION("TestExplicitSweepWithTwoGuideCurvesTwoPoints()")
	{
		std::string filedir = INPUT_PATH_PREFIX "/TestNURBS/TestExplicitSweepWithTwoGuideCurvesTwoPoints/";
		auto profile = ReadBRepCurve(filedir + "profile.brep");
		CHECK(OCCTIO::OCCTTool::Write(MakeEdge(profile), OUTPUT_PATH_PREFIX "TestExplicitSweepWithTwoGuideCurvesTwoPoints_profile.brep"));
		auto guide1 = ReadBRepCurve(filedir + "guide1.brep");
		CHECK(OCCTIO::OCCTTool::Write(MakeEdge(guide1), OUTPUT_PATH_PREFIX "TestExplicitSweepWithTwoGuideCurvesTwoPoints_guide1.brep"));
		auto guide2 = ReadBRepCurve(filedir + "guide2.brep");
		CHECK(OCCTIO::OCCTTool::Write(MakeEdge(guide2), OUTPUT_PATH_PREFIX "TestExplicitSweepWithTwoGuideCurvesTwoPoints_guide2.brep"));
		auto anchorPoint1 = ReadBRepPoint(filedir + "point1.brep");
		auto anchorPoint2 = ReadBRepPoint(filedir + "point2.brep");
		CHECK(OCCTIO::OCCTTool::Write(MakeVertex(anchorPoint1), OUTPUT_PATH_PREFIX "TestExplicitSweepWithTwoGuideCurvesTwoPoints_point1.brep"));
		CHECK(OCCTIO::OCCTTool::Write(MakeVertex(anchorPoint2), OUTPUT_PATH_PREFIX "TestExplicitSweepWithTwoGuideCurvesTwoPoints_point2.brep"));
		auto [status, surface] = NURBSAPIExplicitSweep::SweepWithTwoGuideCurves(profile, guide1, guide2, anchorPoint1, anchorPoint2, guide1, guide1->FirstParameter(), guide1->LastParameter());
		CHECK(status == NURBSSweepStatus::Success);
		if (status == NURBSSweepStatus::Success)
		{
			CHECK(OCCTIO::OCCTTool::Write(MakeFace(surface, 0.0), OUTPUT_PATH_PREFIX "TestExplicitSweepWithTwoGuideCurvesTwoPoints_result.brep"));
			AMCAX::BRepExtremaDistShapeShape len1(MakeFace(surface, 0.0), MakeEdge(guide1));
			AMCAX::BRepExtremaDistShapeShape len2(MakeFace(surface, 0.0), MakeEdge(guide2));
			AMCAX::BRepExtremaDistShapeShape len3(MakeFace(surface, 0.0), MakeEdge(profile));
			CHECK(len1.Value() == Approx(0.0).margin(0.1));
			CHECK(len2.Value() == Approx(0.0).margin(0.1));
			CHECK(len3.Value() == Approx(0.0).margin(0.1));
		}
		profile->IncreaseDegree(11);
		guide1->IncreaseDegree(11);
		guide2->IncreaseDegree(11);
		auto [status1, surface1] = NURBSAPIExplicitSweep::SweepWithTwoGuideCurves(profile, guide1, guide2, anchorPoint1, anchorPoint2, guide1, guide1->FirstParameter(), guide1->LastParameter());
		CHECK(status1 == NURBSSweepStatus::Success);
		if (status1 == NURBSSweepStatus::Success)
		{
			CHECK(OCCTIO::OCCTTool::Write(MakeFace(surface1, 0.0), OUTPUT_PATH_PREFIX "TestExplicitSweepWithTwoGuideCurvesTwoPoints_degree11result.brep"));
			AMCAX::BRepExtremaDistShapeShape len1(MakeFace(surface1, 0.0), MakeEdge(guide1));
			AMCAX::BRepExtremaDistShapeShape len2(MakeFace(surface1, 0.0), MakeEdge(guide2));
			AMCAX::BRepExtremaDistShapeShape len3(MakeFace(surface1, 0.0), MakeEdge(profile));
			CHECK(len1.Value() == Approx(0.0).margin(0.1));
			CHECK(len2.Value() == Approx(0.0).margin(0.1));
			CHECK(len3.Value() == Approx(0.0).margin(0.1));
			double bsp3s = GetSurfaceProperties(MakeFace(surface1, 0.0), g, true, true);
			double bsp4s = GetSurfaceProperties(MakeFace(surface, 0.0), g, true, true);
			CHECK(bsp3s == Approx(bsp4s).margin(0.04));
		}
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static std::pair<NURBSSweepStatus, std::shared_ptr<Geom3BSplineSurface>> SweepWithTwoGuideCurves( const std::shared_ptr<Geom3BSplineCurve>& profile, const std::shared_ptr<Geom3BSplineCurve>& guide1, const std::shared_ptr<Geom3BSplineCurve>& guide2, Point3 anchorPoint, const Direction3& anchorDirection, const std::shared_ptr<Geom3BSplineCurve>& spine, double spineLeftBound, double spineRightBound),
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <filesystem>
#include <fstream>
#include <random>
#include <sstream>
#include <nurbs/NURBSAPIGetGeometry.hpp>
#include <nurbs/NURBSAPIConicalSweep.hpp>
#include <boolean/BoolBRepCut.hpp>
#include <common/CartesianCoordinateSystem.hpp>
#include <common/IndexMap.hpp>
#include <common/QuaternionT.hpp>
#include <geomAlgo/LawBSpline.hpp>
#include <geomAlgo/LawConstant.hpp>
#include <nurbs/NURBSAPISmooth.hpp>
#include <geomAlgo/MakeConic2FromConstraints.hpp>
#include <geometry/Adaptor3CurveOnSurface.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/AdaptorGeom3Surface.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/Geom2Circle.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/Geom2Hyperbola.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom3BSplineCurve.hpp>
#include <geometry/Geom3BSplineSurface.hpp>
#include <geometry/Geom3Circle.hpp>
#include <geometry/Geom3Line.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
#include <geometry/Geom3Plane.hpp>
#include <geometry/Geom3SphericalSurface.hpp>
#include <geometry/Geom3Surface.hpp>
#include <geometry/Geom3TrimmedCurve.hpp>
#include <geometry/Geom3TrimmedSurface.hpp>
#include <geometry/GeomAPIExtremaCurveCurve3.hpp>
#include <geometry/GeomAPIProjectPointOnCurve2.hpp>
#include <geometry/GeomAPIProjectPointOnCurve3.hpp>
#include <geometry/GeomAPIProjectPointOnSurface.hpp>
#include <geometry/GeometryTool.hpp>
#include <geometry/GlobalProperty.hpp>
#include <healing/ShapeFixTool.hpp>
#include <io/STLTool.hpp>
#include <math/Sphere.hpp>
#include <math/TriangularMesh.hpp>
#include <modeling/CopyShape.hpp>
#include <modeling/MakeBox.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeFace.hpp>
#include <modeling/MakePrism.hpp>
#include <modeling/MakeRevol.hpp>
#include <modeling/MakeShapeTool.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeWire.hpp>
#include <modeling/TransformShape.hpp>
#include <nurbs/NURBSAPIApprox.hpp>
#include <nurbs/NURBSAPIBuildCurve.hpp>
#include <nurbs/NURBSAPICircularSweep.hpp>
#include <nurbs/NURBSAPIConvert.hpp>
#include <nurbs/NURBSAPICurveNetworkSurface.hpp>
#include <nurbs/NURBSAPIExplicitSweep.hpp>
#include <nurbs/NURBSAPIExplode.hpp>
#include <nurbs/NURBSAPIExtend.hpp>
#include <nurbs/NURBSAPIInterpolate.hpp>
#include <nurbs/NURBSAPIJoin.hpp>
#include <nurbs/NURBSAPILinearSweep.hpp>
#include <nurbs/NURBSAPILoft.hpp>
#include <nurbs/NURBSAPIMakeNURBSFromBoundaries.hpp>
#include <nurbs/NURBSAPIMatch.hpp>
#include <nurbs/NURBSAPIModifyEndToPlane.hpp>
#include <nurbs/NURBSAPIOffsetCurveOnSurface.hpp>
#include <nurbs/NURBSAPIProject.hpp>
#include <nurbs/NURBSAPIRebuild.hpp>
#include <nurbs/NURBSAPIReplaceEdge.hpp>
#include <nurbs/NURBSAPISweep.hpp>
#include <nurbs/NURBSAPISweep2.hpp>
#include <nurbs/NURBSAPISweepRotation.hpp>
#include <nurbs/NURBSAPITrim.hpp>
#include <nurbs/NURBSAPIUntrim.hpp>
#include <nurbs/NURBSLinearSweepWithDraftDirectionLength.hpp>
#include <occtio/OCCTTool.hpp>
#include <offset/MakePipe.hpp>
#include <offset/MakePipeShell.hpp>
#include <topology/BRepAdaptorCurve2.hpp>
#include <topology/BRepAdaptorCurve3.hpp>
#include <topology/BRepAdaptorSurface.hpp>
#include <topology/BRepGlobalProperty.hpp>
#include <topology/BRepTool.hpp>
#include <topology/TopoBuilder.hpp>
#include <topology/TopoCompound.hpp>
#include <topology/TopoEdge.hpp>
#include <topology/TopoExplorer.hpp>
#include <topology/TopoExplorerTool.hpp>
#include <topology/TopoFace.hpp>
#include <topology/TopoShape.hpp>
#include <topology/TopoShell.hpp>
#include <topology/TopoTool.hpp>
#include <topology/TopoVertex.hpp>
#include <topology/TopoWire.hpp>
#include <topology/WireExplorer.hpp>
#include <topomesh/BRepMeshIncrementalMesh.hpp>
#include <nurbs/NURBSAPIBlend.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
#include <math/LineT.hpp>
#include <hatch/BRepClassificationTools.hpp>
using namespace AMCAX;
namespace
{
	std::shared_ptr<Geom3BSplineCurve> CurveChooser(const int id, const std::shared_ptr<Geom3BSplineCurve>& curve0, const std::shared_ptr<Geom3BSplineCurve>& curve1, const std::shared_ptr<Geom3BSplineCurve>& curve2)
	{
		std::shared_ptr<Geom3BSplineCurve> result;
		switch (id)
		{
		case 0:
		{
			result = curve0;
			break;
		}
		case 1:
		{
			result = curve1;
			break;
		}
		case 2:
		{
			result = curve2;
			break;
		}
		}
		return result;
	}
} 
#include<catch.hpp>
#include<testHelper.h>
#include <filesystem>
#include <fstream>
#include <random>
#include <sstream>
#include <nurbs/NURBSAPIGetGeometry.hpp>
#include <nurbs/NURBSAPIConicalSweep.hpp>
#include <boolean/BoolBRepCut.hpp>
#include <common/CartesianCoordinateSystem.hpp>
#include <common/IndexMap.hpp>
#include <common/QuaternionT.hpp>
#include <geomAlgo/LawBSpline.hpp>
#include <geomAlgo/LawConstant.hpp>
#include <nurbs/NURBSAPISmooth.hpp>
#include <geomAlgo/MakeConic2FromConstraints.hpp>
#include <geometry/Adaptor3CurveOnSurface.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/AdaptorGeom3Surface.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/Geom2Circle.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/Geom2Hyperbola.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom3BSplineCurve.hpp>
#include <geometry/Geom3BSplineSurface.hpp>
#include <geometry/Geom3Circle.hpp>
#include <geometry/Geom3Line.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
#include <geometry/Geom3Plane.hpp>
#include <geometry/Geom3SphericalSurface.hpp>
#include <geometry/Geom3Surface.hpp>
#include <geometry/Geom3TrimmedCurve.hpp>
#include <geometry/Geom3TrimmedSurface.hpp>
#include <geometry/GeomAPIExtremaCurveCurve3.hpp>
#include <geometry/GeomAPIProjectPointOnCurve2.hpp>
#include <geometry/GeomAPIProjectPointOnCurve3.hpp>
#include <geometry/GeomAPIProjectPointOnSurface.hpp>
#include <geometry/GeometryTool.hpp>
#include <geometry/GlobalProperty.hpp>
#include <healing/ShapeFixTool.hpp>
#include <io/STLTool.hpp>
#include <math/Sphere.hpp>
#include <math/TriangularMesh.hpp>
#include <modeling/CopyShape.hpp>
#include <modeling/MakeBox.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeFace.hpp>
#include <modeling/MakePrism.hpp>
#include <modeling/MakeRevol.hpp>
#include <modeling/MakeShapeTool.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeWire.hpp>
#include <modeling/TransformShape.hpp>
#include <nurbs/NURBSAPIApprox.hpp>
#include <nurbs/NURBSAPIBuildCurve.hpp>
#include <nurbs/NURBSAPICircularSweep.hpp>
#include <nurbs/NURBSAPIConvert.hpp>
#include <nurbs/NURBSAPICurveNetworkSurface.hpp>
#include <nurbs/NURBSAPIExplicitSweep.hpp>
#include <nurbs/NURBSAPIExplode.hpp>
#include <nurbs/NURBSAPIExtend.hpp>
#include <nurbs/NURBSAPIInterpolate.hpp>
#include <nurbs/NURBSAPIJoin.hpp>
#include <nurbs/NURBSAPILinearSweep.hpp>
#include <nurbs/NURBSAPILoft.hpp>
#include <nurbs/NURBSAPIMakeNURBSFromBoundaries.hpp>
#include <nurbs/NURBSAPIMatch.hpp>
#include <nurbs/NURBSAPIModifyEndToPlane.hpp>
#include <nurbs/NURBSAPIOffsetCurveOnSurface.hpp>
#include <nurbs/NURBSAPIProject.hpp>
#include <nurbs/NURBSAPIRebuild.hpp>
#include <nurbs/NURBSAPIReplaceEdge.hpp>
#include <nurbs/NURBSAPISweep.hpp>
#include <nurbs/NURBSAPISweep2.hpp>
#include <nurbs/NURBSAPISweepRotation.hpp>
#include <nurbs/NURBSAPITrim.hpp>
#include <nurbs/NURBSAPIUntrim.hpp>
#include <nurbs/NURBSLinearSweepWithDraftDirectionLength.hpp>
#include <occtio/OCCTTool.hpp>
#include <offset/MakePipe.hpp>
#include <offset/MakePipeShell.hpp>
#include <topology/BRepAdaptorCurve2.hpp>
#include <topology/BRepAdaptorCurve3.hpp>
#include <topology/BRepAdaptorSurface.hpp>
#include <topology/BRepGlobalProperty.hpp>
#include <topology/BRepTool.hpp>
#include <topology/TopoBuilder.hpp>
#include <topology/TopoCompound.hpp>
#include <topology/TopoEdge.hpp>
#include <topology/TopoExplorer.hpp>
#include <topology/TopoExplorerTool.hpp>
#include <topology/TopoFace.hpp>
#include <topology/TopoShape.hpp>
#include <topology/TopoShell.hpp>
#include <topology/TopoTool.hpp>
#include <topology/TopoVertex.hpp>
#include <topology/TopoWire.hpp>
#include <topology/WireExplorer.hpp>
#include <topomesh/BRepMeshIncrementalMesh.hpp>
#include <nurbs/NURBSAPIBlend.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
#include <math/LineT.hpp>
#include <hatch/BRepClassificationTools.hpp>
using namespace AMCAX;
namespace
{
	std::shared_ptr<Geom3BSplineCurve> CurveChooser(const int id, const std::shared_ptr<Geom3BSplineCurve>& curve0, const std::shared_ptr<Geom3BSplineCurve>& curve1, const std::shared_ptr<Geom3BSplineCurve>& curve2)
	{
		std::shared_ptr<Geom3BSplineCurve> result;
		switch (id)
		{
		case 0:
		{
			result = curve0;
			break;
		}
		case 1:
		{
			result = curve1;
			break;
		}
		case 2:
		{
			result = curve2;
			break;
		}
		}
		return result;
	}
;
	SECTION("TestExplicitSweepWithTwoGuideCurvesTwoPoints()")
	{
		std::string filedir = INPUT_PATH_PREFIX "/TestNURBS/TestExplicitSweepWithTwoGuideCurvesTwoPoints/";
		auto profile = ReadBRepCurve(filedir + "profile.brep");
		CHECK(OCCTIO::OCCTTool::Write(MakeEdge(profile), OUTPUT_PATH_PREFIX "TestExplicitSweepWithTwoGuideCurvesTwoPoints_profile.brep"));
		auto guide1 = ReadBRepCurve(filedir + "guide1.brep");
		CHECK(OCCTIO::OCCTTool::Write(MakeEdge(guide1), OUTPUT_PATH_PREFIX "TestExplicitSweepWithTwoGuideCurvesTwoPoints_guide1.brep"));
		auto guide2 = ReadBRepCurve(filedir + "guide2.brep");
		CHECK(OCCTIO::OCCTTool::Write(MakeEdge(guide2), OUTPUT_PATH_PREFIX "TestExplicitSweepWithTwoGuideCurvesTwoPoints_guide2.brep"));
		auto anchorPoint1 = ReadBRepPoint(filedir + "point1.brep");
		auto anchorPoint2 = ReadBRepPoint(filedir + "point2.brep");
		CHECK(OCCTIO::OCCTTool::Write(MakeVertex(anchorPoint1), OUTPUT_PATH_PREFIX "TestExplicitSweepWithTwoGuideCurvesTwoPoints_point1.brep"));
		CHECK(OCCTIO::OCCTTool::Write(MakeVertex(anchorPoint2), OUTPUT_PATH_PREFIX "TestExplicitSweepWithTwoGuideCurvesTwoPoints_point2.brep"));
		auto [status, surface] = NURBSAPIExplicitSweep::SweepWithTwoGuideCurves(profile, guide1, guide2, anchorPoint1, anchorPoint2, guide1, guide1->FirstParameter(), guide1->LastParameter());
		CHECK(status == NURBSSweepStatus::Success);
		if (status == NURBSSweepStatus::Success)
		{
			CHECK(OCCTIO::OCCTTool::Write(MakeFace(surface, 0.0), OUTPUT_PATH_PREFIX "TestExplicitSweepWithTwoGuideCurvesTwoPoints_result.brep"));
			AMCAX::BRepExtremaDistShapeShape len1(MakeFace(surface, 0.0), MakeEdge(guide1));
			AMCAX::BRepExtremaDistShapeShape len2(MakeFace(surface, 0.0), MakeEdge(guide2));
			AMCAX::BRepExtremaDistShapeShape len3(MakeFace(surface, 0.0), MakeEdge(profile));
			CHECK(len1.Value() == Approx(0.0).margin(0.1));
			CHECK(len2.Value() == Approx(0.0).margin(0.1));
			CHECK(len3.Value() == Approx(0.0).margin(0.1));
		}
		profile->IncreaseDegree(11);
		guide1->IncreaseDegree(11);
		guide2->IncreaseDegree(11);
		auto [status1, surface1] = NURBSAPIExplicitSweep::SweepWithTwoGuideCurves(profile, guide1, guide2, anchorPoint1, anchorPoint2, guide1, guide1->FirstParameter(), guide1->LastParameter());
		CHECK(status1 == NURBSSweepStatus::Success);
		if (status1 == NURBSSweepStatus::Success)
		{
			CHECK(OCCTIO::OCCTTool::Write(MakeFace(surface1, 0.0), OUTPUT_PATH_PREFIX "TestExplicitSweepWithTwoGuideCurvesTwoPoints_degree11result.brep"));
			AMCAX::BRepExtremaDistShapeShape len1(MakeFace(surface1, 0.0), MakeEdge(guide1));
			AMCAX::BRepExtremaDistShapeShape len2(MakeFace(surface1, 0.0), MakeEdge(guide2));
			AMCAX::BRepExtremaDistShapeShape len3(MakeFace(surface1, 0.0), MakeEdge(profile));
			CHECK(len1.Value() == Approx(0.0).margin(0.1));
			CHECK(len2.Value() == Approx(0.0).margin(0.1));
			CHECK(len3.Value() == Approx(0.0).margin(0.1));
			double bsp3s = GetSurfaceProperties(MakeFace(surface1, 0.0), g, true, true);
			double bsp4s = GetSurfaceProperties(MakeFace(surface, 0.0), g, true, true);
			CHECK(bsp3s == Approx(bsp4s).margin(0.04));
		}
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static std::pair<NURBSSweepStatus, std::vector<std::shared_ptr<Geom3BSplineSurface>>> SweepWithPullingDirection( const std::shared_ptr<Geom3BSplineCurve>& profile, const std::shared_ptr<Geom3BSplineCurve>& guide, const Direction3& direction, const LawFunction& angleLawFunc, const std::shared_ptr<Geom3BSplineCurve>& spine, double spineLeftBound, double spineRightBound),
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <filesystem>
#include <fstream>
#include <random>
#include <sstream>
#include <nurbs/NURBSAPIGetGeometry.hpp>
#include <nurbs/NURBSAPIConicalSweep.hpp>
#include <boolean/BoolBRepCut.hpp>
#include <common/CartesianCoordinateSystem.hpp>
#include <common/IndexMap.hpp>
#include <common/QuaternionT.hpp>
#include <geomAlgo/LawBSpline.hpp>
#include <geomAlgo/LawConstant.hpp>
#include <nurbs/NURBSAPISmooth.hpp>
#include <geomAlgo/MakeConic2FromConstraints.hpp>
#include <geometry/Adaptor3CurveOnSurface.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/AdaptorGeom3Surface.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/Geom2Circle.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/Geom2Hyperbola.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom3BSplineCurve.hpp>
#include <geometry/Geom3BSplineSurface.hpp>
#include <geometry/Geom3Circle.hpp>
#include <geometry/Geom3Line.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
#include <geometry/Geom3Plane.hpp>
#include <geometry/Geom3SphericalSurface.hpp>
#include <geometry/Geom3Surface.hpp>
#include <geometry/Geom3TrimmedCurve.hpp>
#include <geometry/Geom3TrimmedSurface.hpp>
#include <geometry/GeomAPIExtremaCurveCurve3.hpp>
#include <geometry/GeomAPIProjectPointOnCurve2.hpp>
#include <geometry/GeomAPIProjectPointOnCurve3.hpp>
#include <geometry/GeomAPIProjectPointOnSurface.hpp>
#include <geometry/GeometryTool.hpp>
#include <geometry/GlobalProperty.hpp>
#include <healing/ShapeFixTool.hpp>
#include <io/STLTool.hpp>
#include <math/Sphere.hpp>
#include <math/TriangularMesh.hpp>
#include <modeling/CopyShape.hpp>
#include <modeling/MakeBox.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeFace.hpp>
#include <modeling/MakePrism.hpp>
#include <modeling/MakeRevol.hpp>
#include <modeling/MakeShapeTool.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeWire.hpp>
#include <modeling/TransformShape.hpp>
#include <nurbs/NURBSAPIApprox.hpp>
#include <nurbs/NURBSAPIBuildCurve.hpp>
#include <nurbs/NURBSAPICircularSweep.hpp>
#include <nurbs/NURBSAPIConvert.hpp>
#include <nurbs/NURBSAPICurveNetworkSurface.hpp>
#include <nurbs/NURBSAPIExplicitSweep.hpp>
#include <nurbs/NURBSAPIExplode.hpp>
#include <nurbs/NURBSAPIExtend.hpp>
#include <nurbs/NURBSAPIInterpolate.hpp>
#include <nurbs/NURBSAPIJoin.hpp>
#include <nurbs/NURBSAPILinearSweep.hpp>
#include <nurbs/NURBSAPILoft.hpp>
#include <nurbs/NURBSAPIMakeNURBSFromBoundaries.hpp>
#include <nurbs/NURBSAPIMatch.hpp>
#include <nurbs/NURBSAPIModifyEndToPlane.hpp>
#include <nurbs/NURBSAPIOffsetCurveOnSurface.hpp>
#include <nurbs/NURBSAPIProject.hpp>
#include <nurbs/NURBSAPIRebuild.hpp>
#include <nurbs/NURBSAPIReplaceEdge.hpp>
#include <nurbs/NURBSAPISweep.hpp>
#include <nurbs/NURBSAPISweep2.hpp>
#include <nurbs/NURBSAPISweepRotation.hpp>
#include <nurbs/NURBSAPITrim.hpp>
#include <nurbs/NURBSAPIUntrim.hpp>
#include <nurbs/NURBSLinearSweepWithDraftDirectionLength.hpp>
#include <occtio/OCCTTool.hpp>
#include <offset/MakePipe.hpp>
#include <offset/MakePipeShell.hpp>
#include <topology/BRepAdaptorCurve2.hpp>
#include <topology/BRepAdaptorCurve3.hpp>
#include <topology/BRepAdaptorSurface.hpp>
#include <topology/BRepGlobalProperty.hpp>
#include <topology/BRepTool.hpp>
#include <topology/TopoBuilder.hpp>
#include <topology/TopoCompound.hpp>
#include <topology/TopoEdge.hpp>
#include <topology/TopoExplorer.hpp>
#include <topology/TopoExplorerTool.hpp>
#include <topology/TopoFace.hpp>
#include <topology/TopoShape.hpp>
#include <topology/TopoShell.hpp>
#include <topology/TopoTool.hpp>
#include <topology/TopoVertex.hpp>
#include <topology/TopoWire.hpp>
#include <topology/WireExplorer.hpp>
#include <topomesh/BRepMeshIncrementalMesh.hpp>
#include <nurbs/NURBSAPIBlend.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
#include <math/LineT.hpp>
#include <hatch/BRepClassificationTools.hpp>
using namespace AMCAX;
namespace
{
	std::shared_ptr<Geom3BSplineCurve> CurveChooser(const int id, const std::shared_ptr<Geom3BSplineCurve>& curve0, const std::shared_ptr<Geom3BSplineCurve>& curve1, const std::shared_ptr<Geom3BSplineCurve>& curve2)
	{
		std::shared_ptr<Geom3BSplineCurve> result;
		switch (id)
		{
		case 0:
		{
			result = curve0;
			break;
		}
		case 1:
		{
			result = curve1;
			break;
		}
		case 2:
		{
			result = curve2;
			break;
		}
		}
		return result;
	}
} 
#include<catch.hpp>
#include<testHelper.h>
#include <filesystem>
#include <fstream>
#include <random>
#include <sstream>
#include <nurbs/NURBSAPIGetGeometry.hpp>
#include <nurbs/NURBSAPIConicalSweep.hpp>
#include <boolean/BoolBRepCut.hpp>
#include <common/CartesianCoordinateSystem.hpp>
#include <common/IndexMap.hpp>
#include <common/QuaternionT.hpp>
#include <geomAlgo/LawBSpline.hpp>
#include <geomAlgo/LawConstant.hpp>
#include <nurbs/NURBSAPISmooth.hpp>
#include <geomAlgo/MakeConic2FromConstraints.hpp>
#include <geometry/Adaptor3CurveOnSurface.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/AdaptorGeom3Surface.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/Geom2Circle.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/Geom2Hyperbola.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom3BSplineCurve.hpp>
#include <geometry/Geom3BSplineSurface.hpp>
#include <geometry/Geom3Circle.hpp>
#include <geometry/Geom3Line.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
#include <geometry/Geom3Plane.hpp>
#include <geometry/Geom3SphericalSurface.hpp>
#include <geometry/Geom3Surface.hpp>
#include <geometry/Geom3TrimmedCurve.hpp>
#include <geometry/Geom3TrimmedSurface.hpp>
#include <geometry/GeomAPIExtremaCurveCurve3.hpp>
#include <geometry/GeomAPIProjectPointOnCurve2.hpp>
#include <geometry/GeomAPIProjectPointOnCurve3.hpp>
#include <geometry/GeomAPIProjectPointOnSurface.hpp>
#include <geometry/GeometryTool.hpp>
#include <geometry/GlobalProperty.hpp>
#include <healing/ShapeFixTool.hpp>
#include <io/STLTool.hpp>
#include <math/Sphere.hpp>
#include <math/TriangularMesh.hpp>
#include <modeling/CopyShape.hpp>
#include <modeling/MakeBox.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeFace.hpp>
#include <modeling/MakePrism.hpp>
#include <modeling/MakeRevol.hpp>
#include <modeling/MakeShapeTool.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeWire.hpp>
#include <modeling/TransformShape.hpp>
#include <nurbs/NURBSAPIApprox.hpp>
#include <nurbs/NURBSAPIBuildCurve.hpp>
#include <nurbs/NURBSAPICircularSweep.hpp>
#include <nurbs/NURBSAPIConvert.hpp>
#include <nurbs/NURBSAPICurveNetworkSurface.hpp>
#include <nurbs/NURBSAPIExplicitSweep.hpp>
#include <nurbs/NURBSAPIExplode.hpp>
#include <nurbs/NURBSAPIExtend.hpp>
#include <nurbs/NURBSAPIInterpolate.hpp>
#include <nurbs/NURBSAPIJoin.hpp>
#include <nurbs/NURBSAPILinearSweep.hpp>
#include <nurbs/NURBSAPILoft.hpp>
#include <nurbs/NURBSAPIMakeNURBSFromBoundaries.hpp>
#include <nurbs/NURBSAPIMatch.hpp>
#include <nurbs/NURBSAPIModifyEndToPlane.hpp>
#include <nurbs/NURBSAPIOffsetCurveOnSurface.hpp>
#include <nurbs/NURBSAPIProject.hpp>
#include <nurbs/NURBSAPIRebuild.hpp>
#include <nurbs/NURBSAPIReplaceEdge.hpp>
#include <nurbs/NURBSAPISweep.hpp>
#include <nurbs/NURBSAPISweep2.hpp>
#include <nurbs/NURBSAPISweepRotation.hpp>
#include <nurbs/NURBSAPITrim.hpp>
#include <nurbs/NURBSAPIUntrim.hpp>
#include <nurbs/NURBSLinearSweepWithDraftDirectionLength.hpp>
#include <occtio/OCCTTool.hpp>
#include <offset/MakePipe.hpp>
#include <offset/MakePipeShell.hpp>
#include <topology/BRepAdaptorCurve2.hpp>
#include <topology/BRepAdaptorCurve3.hpp>
#include <topology/BRepAdaptorSurface.hpp>
#include <topology/BRepGlobalProperty.hpp>
#include <topology/BRepTool.hpp>
#include <topology/TopoBuilder.hpp>
#include <topology/TopoCompound.hpp>
#include <topology/TopoEdge.hpp>
#include <topology/TopoExplorer.hpp>
#include <topology/TopoExplorerTool.hpp>
#include <topology/TopoFace.hpp>
#include <topology/TopoShape.hpp>
#include <topology/TopoShell.hpp>
#include <topology/TopoTool.hpp>
#include <topology/TopoVertex.hpp>
#include <topology/TopoWire.hpp>
#include <topology/WireExplorer.hpp>
#include <topomesh/BRepMeshIncrementalMesh.hpp>
#include <nurbs/NURBSAPIBlend.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
#include <math/LineT.hpp>
#include <hatch/BRepClassificationTools.hpp>
using namespace AMCAX;
namespace
{
	std::shared_ptr<Geom3BSplineCurve> CurveChooser(const int id, const std::shared_ptr<Geom3BSplineCurve>& curve0, const std::shared_ptr<Geom3BSplineCurve>& curve1, const std::shared_ptr<Geom3BSplineCurve>& curve2)
	{
		std::shared_ptr<Geom3BSplineCurve> result;
		switch (id)
		{
		case 0:
		{
			result = curve0;
			break;
		}
		case 1:
		{
			result = curve1;
			break;
		}
		case 2:
		{
			result = curve2;
			break;
		}
		}
		return result;
	}
;
	SECTION("TestExplicitSweepWithPullingDirection()")
	{
		std::string filedir = INPUT_PATH_PREFIX "/TestNURBS/TestExplicitSweepWithPullingDirection/";
		auto guide = ReadBRepCurve(filedir + "guide.brep");
		CHECK(OCCTIO::OCCTTool::Write(MakeEdge(guide), OUTPUT_PATH_PREFIX "TestExplicitSweepWithPullingDirection_guide.brep"));
		auto profile = ReadBRepCurve(filedir + "profile.brep");
		CHECK(OCCTIO::OCCTTool::Write(MakeEdge(profile), OUTPUT_PATH_PREFIX "TestExplicitSweepWithPullingDirection_profile.brep"));
		auto spineLineEdge = ReadBRepEdge(filedir + "spine.brep");
		double fp, lp;
		auto spineLine = TopoTool::Curve(spineLineEdge, fp, lp);
		auto spine = NURBSAPIConvert::ToBSpline(std::make_shared<Geom3TrimmedCurve>(spineLine, 0, 3));
		CHECK(OCCTIO::OCCTTool::Write(MakeEdge(spine), OUTPUT_PATH_PREFIX "TestExplicitSweepWithPullingDirection_spine.brep"));
		auto pullingDirectionEdge = ReadBRepEdge(filedir + "pullingDirection.brep");
		auto dirCurve = TopoTool::Curve(pullingDirectionEdge, fp, lp);
		Point3 p1, p2;
		Vector3 d1, d2;
		dirCurve->D1(0.0, p1, d1);
		dirCurve->D1(1.0, p2, d2);
		Direction3 pullingDirection(d1);
		LawConstant law;
		law.Set(0.0, 0.0, 1.0);
		auto [status, surfaces] = NURBSAPIExplicitSweep::SweepWithPullingDirection(profile, guide, pullingDirection, law, spine, spine->FirstParameter(), spine->LastParameter());
		CHECK(status == NURBSSweepStatus::Success);
		if (status == NURBSSweepStatus::Success)
		{
			for (int i = 0; i < surfaces.size(); i++)
			{
				CHECK(OCCTIO::OCCTTool::Write(MakeFace(surfaces[i], 0.0), OUTPUT_PATH_PREFIX "TestExplicitSweepWithPullingDirection_result" + std::to_string(i) + ".brep"));
				CHECK(IsCurveOnSurf(1000, 0.3, guide, surfaces[i], 0.1));
				AMCAX::BRepExtremaDistShapeShape len1(MakeFace(surfaces[i], 0.0), MakeEdge(guide));
				AMCAX::BRepExtremaDistShapeShape len2(MakeFace(surfaces[i], 0.0), MakeEdge(profile));
				CHECK(len1.Value() == Approx(0.0).margin(0.1));
				CHECK(len2.Value() == Approx(0.0).margin(0.1));
				if (i < 2) {
					CHECK(IsCurveOnSurf(1000, 0.1, profile, surfaces[i], 0.1));
				}
			}
		}
		profile->IncreaseDegree(5);
		guide->IncreaseDegree(5);
		spine->IncreaseDegree(5);
		auto [status1, surfaces1] = NURBSAPIExplicitSweep::SweepWithPullingDirection(profile, guide, pullingDirection, law, spine, spine->FirstParameter(), spine->LastParameter());
		CHECK(status1 == NURBSSweepStatus::Success);
		if (status1 == NURBSSweepStatus::Success)
		{
			for (int i = 0; i < surfaces1.size(); i++)
			{
				CHECK(OCCTIO::OCCTTool::Write(MakeFace(surfaces1[i], 0.0), OUTPUT_PATH_PREFIX "TestExplicitSweepWithPullingDirection_degree5result" + std::to_string(i) + ".brep"));
				CHECK(IsCurveOnSurf(1000, 0.3, guide, surfaces1[i], 0.1));
				AMCAX::BRepExtremaDistShapeShape len1(MakeFace(surfaces1[i], 0.0), MakeEdge(guide));
				AMCAX::BRepExtremaDistShapeShape len2(MakeFace(surfaces1[i], 0.0), MakeEdge(profile));
				CHECK(len1.Value() == Approx(0.0).margin(0.1));
				CHECK(len2.Value() == Approx(0.0).margin(0.1));
				if (i < 2) {
					CHECK(IsCurveOnSurf(1000, 0.1, profile, surfaces1[i], 0.1));
					double bsp3s = GetSurfaceProperties(MakeFace(surfaces1[i], 0.0), g, true, true);
					double bsp4s = GetSurfaceProperties(MakeFace(surfaces[i], 0.0), g, true, true);
					CHECK(bsp3s == Approx(bsp4s).margin(0.02));
				}
			}
		}
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static std::vector<std::shared_ptr<Geom3BSplineCurve>> ExplodeCurve(const std::shared_ptr<Geom3BSplineCurve>& curve)	 @return The result curves
	 @param curve The given curve
	 @brief Explode a curve into curves at C0 points
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <nurbs/NURBSAPIExplode.hpp>
#include <topology/TopoEdge.hpp>
#include <topology/TopoTool.hpp>
#include <nurbs/NURBSAPIJoin.hpp>
#include <nurbs/NURBSAPIExplode.hpp>
#include <geometry/Geom3BSplineCurve.hpp>
#include <geometry/Geom3BSplineSurface.hpp>
#include <topology/TopoFace.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeFace.hpp>
#include<catch.hpp>
#include<testHelper.h>
#include <nurbs/NURBSAPIExplode.hpp>
#include <topology/TopoEdge.hpp>
#include <topology/TopoTool.hpp>
#include <nurbs/NURBSAPIJoin.hpp>
#include <nurbs/NURBSAPIExplode.hpp>
#include <geometry/Geom3BSplineCurve.hpp>
#include <geometry/Geom3BSplineSurface.hpp>
#include <topology/TopoFace.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeFace.hpp>
;
	SECTION("isPeriodic")
	{
		OUTPUT_DIRECTORY(nurbs, Explode/ExplodeCurve1);
		filename = "periodicCurve";
		std::vector<std::shared_ptr<Geom3BSplineCurve>> curves;
		for (int i = 0; i < 3; i++)
		{
			curves.push_back(ReadBRepCurve(filedir + filename + std::to_string(i) + ".brep"));
		}
		auto [sortedCurves, isReverse, isResultPeriodic] = NURBSAPIJoin::JoinCurvePrepare(curves, 0.0001);
		auto results = NURBSAPIJoin::JoinCurves(sortedCurves, isReverse, isResultPeriodic);
		int nresults = static_cast<int>(results.size());
		for (int i = 0; i < nresults; i++)
		{
			OCCTIO::OCCTTool::Write(MakeEdge(results[i]), outdir + "joinCurve" + to_string(i) + ".brep");
		}
		auto explodeResult = NURBSAPIExplode::ExplodeCurve(results.front());
		int expResults = static_cast<int>(explodeResult.size());
		for (int j = 0; j < expResults; j++)
		{
			OCCTIO::OCCTTool::Write(MakeEdge(explodeResult[j]), outdir + "expCurve" + to_string(j) + ".brep");
		}
		CHECK(results.size() == 1);
		CHECK(explodeResult.size() == 3);
		Point3 p1, p2, p3, p4;
		p1 = curves[0]->StartPoint();
		p2 = curves[2]->EndPoint();
		p3 = results[0]->StartPoint();
		p4 = results[0]->EndPoint();
		CHECK(p1.X() == Approx(p3.X()));
		CHECK(p1.Y() == Approx(p3.Y()));
		CHECK(p1.Z() == Approx(p3.Z()));
		CHECK(p2.X() == Approx(p4.X()));
		CHECK(p2.Y() == Approx(p4.Y()));
		CHECK(p2.Z() == Approx(p4.Z()));
		TopoShape c1 = MakeEdge(curves[0]);
		TopoShape c2 = MakeEdge(curves[1]);
		TopoShape c3 = MakeEdge(curves[2]);
		TopoShape c = MakeEdge(results[0]);
		TopoShape e1 = MakeEdge(explodeResult[0]);
		TopoShape e2 = MakeEdge(explodeResult[1]);
		TopoShape e3 = MakeEdge(explodeResult[2]);
		GlobalProperty props1, props2, props3, props4, props5, props6, props7;
		double len1 = GetLinearProperties(c1, props1, true, false);
		double len2 = GetLinearProperties(c2, props2, true, false);
		double len3 = GetLinearProperties(c3, props3, true, false);
		double joinLen = GetLinearProperties(c, props4, true, false);
		double exLen1 = GetLinearProperties(e1, props5, true, false);
		double exLen2 = GetLinearProperties(e2, props6, true, false);
		double exLen3 = GetLinearProperties(e3, props7, true, false);
		double cuvLen = len1 + len2 + len3;
		double len = abs(cuvLen - joinLen);
		double len11 = abs(len1 - exLen1);
		double len22 = abs(len2 - exLen2);
		double len33 = abs(len3 - exLen3);
		CHECK(len < 0.1);
		CHECK(len11 < 0.1);
		CHECK(len22 < 0.1);
		CHECK(len33 < 0.1);
		double res1 = NurbsSampleCurve(num, sTol, curves[0], explodeResult[0]);
		double res2 = NurbsSampleCurve(num, sTol, curves[1], explodeResult[1]);
		double res3 = NurbsSampleCurve(num, sTol, curves[2], explodeResult[2]);
		CHECK(res1 <= ratio);
		CHECK(res2 <= ratio);
		CHECK(res3 <= ratio);
		OCCTIO::OCCTTool::Write(MakeEdge(curves[0]), outdir + "curve0.brep");
		OCCTIO::OCCTTool::Write(MakeEdge(curves[1]), outdir + "curve1.brep");
		OCCTIO::OCCTTool::Write(MakeEdge(curves[2]), outdir + "curve2.brep");
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static Array2<std::shared_ptr<Geom3BSplineSurface>> ExplodeSurface(const std::shared_ptr<Geom3BSplineSurface>& surface)	 @return The result surfaces
	 @param surface The given surface
	 @brief Explode a surface into patches at C0 isocurves
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <nurbs/NURBSAPIExplode.hpp>
#include <topology/TopoEdge.hpp>
#include <topology/TopoTool.hpp>
#include <nurbs/NURBSAPIJoin.hpp>
#include <nurbs/NURBSAPIExplode.hpp>
#include <geometry/Geom3BSplineCurve.hpp>
#include <geometry/Geom3BSplineSurface.hpp>
#include <topology/TopoFace.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeFace.hpp>
#include<catch.hpp>
#include<testHelper.h>
#include <nurbs/NURBSAPIExplode.hpp>
#include <topology/TopoEdge.hpp>
#include <topology/TopoTool.hpp>
#include <nurbs/NURBSAPIJoin.hpp>
#include <nurbs/NURBSAPIExplode.hpp>
#include <geometry/Geom3BSplineCurve.hpp>
#include <geometry/Geom3BSplineSurface.hpp>
#include <topology/TopoFace.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeFace.hpp>
;
	SECTION("isUPeriodic+nonVPeriodic")
	{
		OUTPUT_DIRECTORY(nurbs, Explode/ExplodeSurface3);
		string filedir = INPUT_PATH_PREFIX"./TestNURBS/TestJoinSurface/";
		std::vector<std::shared_ptr<Geom3BSplineSurface>> surfaces;
		surfaces.push_back(ReadBRepSurface(filedir + "surface0.brep"));
		surfaces.push_back(ReadBRepSurface(filedir + "surface1.brep"));
		surfaces.push_back(ReadBRepSurface(filedir + "surface2.brep"));
		surfaces.push_back(ReadBRepSurface(filedir + "surface3.brep"));
		auto [sortedSurfaces, isUIso, isFrontBackReverse, isIsoReverse, isLocalUPeriodic, isLocalVPeriodic] = NURBSAPIJoin::JoinSurfacesPrepare(surfaces, 0.0001);
		auto [isSucceed, result] = NURBSAPIJoin::JoinSurfaces(sortedSurfaces, isUIso, isFrontBackReverse, isIsoReverse, isLocalUPeriodic, isLocalVPeriodic);
		Throw_Construction_Error_if(!isSucceed, "failed");
		CHECK(isSucceed == true);
		auto explodeResult = NURBSAPIExplode::ExplodeSurface(result);
		int row = explodeResult.NRow();
		int col = explodeResult.NCol();
		for (int i = 0; i < row; i++)
		{
			for (int j = 0; j < col; j++)
			{
				OCCTIO::OCCTTool::Write(MakeFace(explodeResult(i, j), 0.0), outdir +  "expSurface" + to_string(i) + to_string(j) +".brep");
			}
		}
		CHECK(row*col == 4);
		TopoShape f1 = MakeFace(surfaces[0],0.0);
		TopoShape f2 = MakeFace(surfaces[1], 0.0);
		TopoShape f3 = MakeFace(surfaces[2], 0.0);
		TopoShape f4 = MakeFace(surfaces[3], 0.0);
		TopoShape f = MakeFace(result,0.0);
		TopoShape exp1 = MakeFace(explodeResult(0, 0), 0.0);
		TopoShape exp2 = MakeFace(explodeResult(1, 0), 0.0);
		TopoShape exp3 = MakeFace(explodeResult(2, 0), 0.0);
		TopoShape exp4 = MakeFace(explodeResult(3, 0), 0.0);
		GlobalProperty props1, props2, props3, props4, props5, props6, props7, props8;
		double surf1 = GetSurfaceProperties(f1, props1, true, false);
		double surf2 = GetSurfaceProperties(f2, props2, true, false);
		double surf3 = GetSurfaceProperties(f3, props3, true, false);
		double surf4 = GetSurfaceProperties(f4, props4, true, false);
		double surface = GetSurfaceProperties(f, props5, true, false);
		double exSurf1 = GetSurfaceProperties(exp1, props5, true, false);
		double exSurf2 = GetSurfaceProperties(exp2, props6, true, false);
		double exSurf3 = GetSurfaceProperties(exp3, props7, true, false);
		double exSurf4 = GetSurfaceProperties(exp4, props8, true, false);
		double surf = surf1 + surf2 + surf3 + surf4;
		double dif = abs(surface - surf);
		double dif1 = abs(surf1 - exSurf1);
		double dif2 = abs(surf2 - exSurf2);
		double dif3 = abs(surf3 - exSurf3);
		double dif4 = abs(surf4 - exSurf4);
		CHECK(dif1 < 0.1);
		CHECK(dif2 < 0.1);
		CHECK(dif3 < 0.1);
		CHECK(dif4 < 0.1);
		double res1 = NurbsSampleSurface(num, sTol, surfaces[0], explodeResult(0, 0));
		double res2 = NurbsSampleSurface(num, sTol, surfaces[1], explodeResult(1, 0));
		double res3 = NurbsSampleSurface(num, sTol, surfaces[2], explodeResult(2, 0));
		double res4 = NurbsSampleSurface(num, sTol, surfaces[3], explodeResult(3, 0));
		CHECK(res1 <= ratio);
		CHECK(res2 <= ratio);
		CHECK(res3 <= ratio);
		CHECK(res4 <= ratio);
		OCCTIO::OCCTTool::Write(MakeFace(surfaces[0], 0.0), outdir + "surf1.brep");
		OCCTIO::OCCTTool::Write(MakeFace(surfaces[1], 0.0), outdir + "surf2.brep");
		OCCTIO::OCCTTool::Write(MakeFace(surfaces[2], 0.0), outdir + "surf3.brep");
		OCCTIO::OCCTTool::Write(MakeFace(surfaces[3], 0.0), outdir + "surf4.brep");
		OCCTIO::OCCTTool::Write(MakeFace(result, 0.0), outdir + "joinSurface.brep");
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static std::shared_ptr<Geom3Curve> ExtendCurvePerpendicularToPlane(const std::shared_ptr<Geom3Curve>& curve, const std::shared_ptr<Geom3Plane>& plane)	 @return New curve
	 @param plane Plane
	 @param curve Curve
	 The degree of curve is not changed but the size of knots and poles increase 1.
	 The original curve is part of new curve.
	 @brief Extend curve to plane and the curve end which is closer to plane is perpendicular to the plane, which can be used in mirror to fix the gap.
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <nurbs/NURBSAPIExtend.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeFace.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/Geom3Plane.hpp>
#include <geometry/Geom3TrimmedSurface.hpp>
#include <nurbs/NURBSAPIConvert.hpp>
#include <nurbs/NURBSAPIBuildCurve.hpp>
#include <geomAlgo/LawBSpline.hpp>
#include <offset/MakePipe.hpp>
#include <modeling/MakeWire.hpp>
#include <topology/TopoTool.hpp>
#include <topology/TopoExplorerTool.hpp>
#include <geometry/GeomAPIProjectPointOnCurve3.hpp>
#include <geometry/GeomAPIProjectPointOnSurface.hpp>
double NurbsExtendSample(int num, double len, double tol, const shared_ptr<Geom3Curve>& curve1, const shared_ptr<Geom3Curve>& curve2)
{
	const int nsample = num;
	double fp1 = curve1->FirstParameter();
	double lp1 = curve1->LastParameter();
	double delta1 = (lp1 - fp1) / nsample;
	Point3 p;
	int n = 0;
	for (int i = 0; i < nsample; i++)
	{
		double t1 = fp1 + i * delta1;
		curve1->D0(t1, p);
		TopoVertex vt = MakeVertex(p);
		TopoEdge edge = MakeEdge(curve2);
		BRepExtremaDistShapeShape dist(vt, edge);
		double dis = abs(dist.Value() - len);
		if (dis <= tol)
		{
			n++;
		}
	}
	double res = 1.0 * (num - n) / num;
	return res;
}
shared_ptr<Geom3Surface> ConstructExtendSurface()
{
	std::vector<Point3> profilePoles;
	std::vector<double> profileKnots(3);
	std::vector<int> profileMults(3, 1);
	profilePoles.push_back(Point3(0.0, 0.0, 0.0));
	profilePoles.push_back(Point3(1.0, -0.2, 0.0));
	profilePoles.push_back(Point3(2.0, 0.1, 0.0));
	profilePoles.push_back(Point3(2.3, -0.1, 0.0));
	profilePoles.push_back(Point3(2.9, 0.1, 0.0));
	profileKnots[0] = 0;
	profileKnots[1] = 0.5;
	profileKnots[2] = 1;
	profileMults.front() = 4;
	profileMults.back() = 4;
	std::shared_ptr<Geom3BSplineCurve> profile = std::make_shared<Geom3BSplineCurve>(profilePoles, profileKnots, profileMults, 3);
	std::vector<Point3> spinePoles;
	std::vector<double> spineKnots(4);
	std::vector<int> spineMults(4, 1);
	spinePoles.push_back(Point3(0.0, 0.0, 0.0));
	spinePoles.push_back(Point3(0.0, 0.0, 1.0));
	spinePoles.push_back(Point3(0.0, 0.2, 1.5));
	spinePoles.push_back(Point3(0.0, 0.5, 2.0));
	spinePoles.push_back(Point3(0.0, 1.0, 2.3));
	spinePoles.push_back(Point3(0.0, 1.6, 2.3));
	spineKnots[0] = 0;
	spineKnots[1] = 1.0 / 3.0;
	spineKnots[2] = 2.0 / 3.0;
	spineKnots[3] = 1;
	spineMults.front() = 4;
	spineMults.back() = 4;
	std::shared_ptr<Geom3BSplineCurve> spine = std::make_shared<Geom3BSplineCurve>(spinePoles, spineKnots, spineMults, 3);
	TopoShape pipe = MakePipe(MakeWire(MakeEdge(spine)), MakeWire(MakeEdge(profile))).Shape();
	TopoExplorer ex(pipe, ShapeType::Face);
	std::shared_ptr<Geom3Surface> surface = TopoTool::Surface(static_cast<const TopoFace&>(ex.Current()));
	return surface;
}
shared_ptr<Geom3Surface> ConstructExtendPeriodicSurf()
{
	std::vector<Point3> profilePoles;
	profilePoles.push_back(Point3(0.0, 0.0, 0.0));
	profilePoles.push_back(Point3(1.0, -1.0, 0.0));
	profilePoles.push_back(Point3(2.0, -1.5, 0.0));
	profilePoles.push_back(Point3(2.3, -1.0, 0.0));
	profilePoles.push_back(Point3(2.9, 0.0, 0.0));
	profilePoles.push_back(Point3(2.3, 0.9, 0.0));
	profilePoles.push_back(Point3(2.1, 1.6, 0.0));
	profilePoles.push_back(Point3(1.0, 1.0, 0.0));
	std::vector<double> profileKnots(profilePoles.size() + 1);
	for (int i = 0; i < static_cast<int>(profileKnots.size()); i++)
	{
		profileKnots[i] = (double)i / (double)(profilePoles.size());
	}
	profileKnots[1] += 1.0 / (double)(3 * profilePoles.size());
	std::vector<int> profileMults(profileKnots.size(), 1);
	std::shared_ptr<Geom3BSplineCurve> profile = std::make_shared<Geom3BSplineCurve>(profilePoles, profileKnots, profileMults, 3, true);
	std::vector<Point3> spinePoles;
	std::vector<double> spineKnots(4);
	std::vector<int> spineMults(4, 1);
	spinePoles.push_back(Point3(0.0, 0.0, 0.0));
	spinePoles.push_back(Point3(0.0, 0.0, 1.0));
	spinePoles.push_back(Point3(0.0, 0.2, 1.5));
	spinePoles.push_back(Point3(0.0, 0.5, 2.0));
	spinePoles.push_back(Point3(0.0, 1.0, 2.3));
	spinePoles.push_back(Point3(0.0, 1.6, 2.3));
	spineKnots[0] = 0;
	spineKnots[1] = 1.0 / 3.0;
	spineKnots[2] = 2.0 / 3.0;
	spineKnots[3] = 1;
	spineMults.front() = 4;
	spineMults.back() = 4;
	std::shared_ptr<Geom3BSplineCurve> spine = std::make_shared<Geom3BSplineCurve>(spinePoles, spineKnots, spineMults, 3);
	TopoShape pipe = MakePipe(MakeWire(MakeEdge(spine)), MakeWire(MakeEdge(profile))).Shape();
	TopoExplorer ex(pipe, ShapeType::Face);
	std::shared_ptr<Geom3Surface> surface = TopoTool::Surface(static_cast<const TopoFace&>(ex.Current()));
	return surface;
}
TEST_CASE("bug7: ExtendPeriodicSurf3 ", "[nurbs][Extend][fixbug]")
{
	OUTPUT_DIRECTORY(nurbs, Extend/bug689/ExtendPeriodicSurf3);
	shared_ptr<Geom3Surface> surface = ConstructExtendPeriodicSurf();
	auto plane = std::make_shared<Geom3Plane>(Point3(0.0, 0.0, -5.3), Direction3(0.0, 0.0, 1.0));
	auto planevf = NURBSAPIExtend::ExtendSurfPerpendicularToPlane(surface, false, true, plane);
	shared_ptr<Geom3TrimmedSurface>trimSurf = std::make_shared<Geom3TrimmedSurface>(plane, -10.0, 10.0, -10.0, 10.0);
	double fpv1 = planevf->FirstUParameter();
	shared_ptr<Geom3Curve> fv1 = planevf->UIso(fpv1);
	Point3 p1;
	Vector3 vec;
	double fs = fv1->FirstParameter();
	fv1->D1(fs, p1, vec);
	Axis3 axis = plane->Axis();
	bool res = axis.Direction().IsParallel(Direction3(vec), Precision::Angular());
	CHECK(res == true);
	OCCTIO::OCCTTool::Write(MakeEdge(fv1), outdir + "curve2.brep");
	OCCTIO::OCCTTool::Write(MakeFace(trimSurf, 0.0), outdir + "trimSurf.brep");
	OCCTIO::OCCTTool::Write(MakeFace(surface, 0.0), outdir + "src.brep");
	OCCTIO::OCCTTool::Write(MakeFace(planevf, 0.0), outdir + "result.brep");
;
	SECTION("ExtendCurvePerpendicularToPlane1")
	{
		OUTPUT_DIRECTORY(nurbs, Extend/ExtendCurve/ExtendCurvePerpendicularToPlane1);
		auto plane1 = std::make_shared<Geom3Plane>(Point3(0.0, 1.2, 0.0), Direction3(0.0, 1.0, 0.0));
		auto n4bsp = NURBSAPIExtend::ExtendCurvePerpendicularToPlane(bsp, plane1);
		shared_ptr<Geom3TrimmedSurface>trimtp1 = std::make_shared<Geom3TrimmedSurface>(plane1, -2.0, 2.0, -2.0, 2.0);
		shared_ptr<Geom3BSplineCurve> bspCurve = NURBSAPIConvert::ToBSpline(n4bsp);
		CHECK(bspCurve->Degree() == degree);
		CHECK(bspCurve->NPoles() == (pNum + 1));
		CHECK(bspCurve->NKnots() == (kNum + 1));
		double fp = n4bsp->FirstParameter();
		double lp = n4bsp->LastParameter();
		Point3 p1 = n4bsp->Value(fp);
		Point3 p2 = n4bsp->Value(lp);
		CHECK(p1.X() == sp.X());
		CHECK(p1.Y() == sp.Y());
		CHECK(p1.Z() == sp.Z());
		bool res1 = BRepClassificationTools::IsPointInFace(MakeFace(trimtp1, 0.0), p2);
		CHECK(res1 == true);
		Point3 p3;
		Vector3 vec;
		n4bsp->D1(lp, p3, vec);
		Axis3 axis = plane1->Axis();
		bool res2 = axis.Direction().IsParallel(Direction3(vec), Precision::Angular());
		CHECK(res2 == true);
		OCCTIO::OCCTTool::Write(MakeVertex(sp), outdir + "sp.brep");
		OCCTIO::OCCTTool::Write(MakeVertex(ep), outdir + "ep.brep");
		OCCTIO::OCCTTool::Write(MakeVertex(p1), outdir + "p1.brep");
		OCCTIO::OCCTTool::Write(MakeVertex(p2), outdir + "p2.brep");
		OCCTIO::OCCTTool::Write(MakeEdge(bsp), outdir + "src.brep");
		OCCTIO::OCCTTool::Write(MakeFace(trimtp1, 0.0), outdir + "trimtp1.brep");
		OCCTIO::OCCTTool::Write(MakeEdge(n4bsp), outdir + "result.brep");
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static std::shared_ptr<Geom3Curve> ExtendCurvePerpendicularToPlane(const std::shared_ptr<Geom3Curve>& curve, bool isFront, const std::shared_ptr<Geom3Plane>& plane)	 @return New curve
	 @param plane Plane
	 @param isFront Extend front or back
	 @param curve Curve
	 The degree of curve is not changed but the size of knots and poles increase 1.
	 The original curve is part of new curve.
	 @brief Extend curve to plane and the end of curve is perpendicular to the plane, which can be used in mirror to fix the gap.
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <nurbs/NURBSAPIExtend.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeFace.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/Geom3Plane.hpp>
#include <geometry/Geom3TrimmedSurface.hpp>
#include <nurbs/NURBSAPIConvert.hpp>
#include <nurbs/NURBSAPIBuildCurve.hpp>
#include <geomAlgo/LawBSpline.hpp>
#include <offset/MakePipe.hpp>
#include <modeling/MakeWire.hpp>
#include <topology/TopoTool.hpp>
#include <topology/TopoExplorerTool.hpp>
#include <geometry/GeomAPIProjectPointOnCurve3.hpp>
#include <geometry/GeomAPIProjectPointOnSurface.hpp>
double NurbsExtendSample(int num, double len, double tol, const shared_ptr<Geom3Curve>& curve1, const shared_ptr<Geom3Curve>& curve2)
{
	const int nsample = num;
	double fp1 = curve1->FirstParameter();
	double lp1 = curve1->LastParameter();
	double delta1 = (lp1 - fp1) / nsample;
	Point3 p;
	int n = 0;
	for (int i = 0; i < nsample; i++)
	{
		double t1 = fp1 + i * delta1;
		curve1->D0(t1, p);
		TopoVertex vt = MakeVertex(p);
		TopoEdge edge = MakeEdge(curve2);
		BRepExtremaDistShapeShape dist(vt, edge);
		double dis = abs(dist.Value() - len);
		if (dis <= tol)
		{
			n++;
		}
	}
	double res = 1.0 * (num - n) / num;
	return res;
}
shared_ptr<Geom3Surface> ConstructExtendSurface()
{
	std::vector<Point3> profilePoles;
	std::vector<double> profileKnots(3);
	std::vector<int> profileMults(3, 1);
	profilePoles.push_back(Point3(0.0, 0.0, 0.0));
	profilePoles.push_back(Point3(1.0, -0.2, 0.0));
	profilePoles.push_back(Point3(2.0, 0.1, 0.0));
	profilePoles.push_back(Point3(2.3, -0.1, 0.0));
	profilePoles.push_back(Point3(2.9, 0.1, 0.0));
	profileKnots[0] = 0;
	profileKnots[1] = 0.5;
	profileKnots[2] = 1;
	profileMults.front() = 4;
	profileMults.back() = 4;
	std::shared_ptr<Geom3BSplineCurve> profile = std::make_shared<Geom3BSplineCurve>(profilePoles, profileKnots, profileMults, 3);
	std::vector<Point3> spinePoles;
	std::vector<double> spineKnots(4);
	std::vector<int> spineMults(4, 1);
	spinePoles.push_back(Point3(0.0, 0.0, 0.0));
	spinePoles.push_back(Point3(0.0, 0.0, 1.0));
	spinePoles.push_back(Point3(0.0, 0.2, 1.5));
	spinePoles.push_back(Point3(0.0, 0.5, 2.0));
	spinePoles.push_back(Point3(0.0, 1.0, 2.3));
	spinePoles.push_back(Point3(0.0, 1.6, 2.3));
	spineKnots[0] = 0;
	spineKnots[1] = 1.0 / 3.0;
	spineKnots[2] = 2.0 / 3.0;
	spineKnots[3] = 1;
	spineMults.front() = 4;
	spineMults.back() = 4;
	std::shared_ptr<Geom3BSplineCurve> spine = std::make_shared<Geom3BSplineCurve>(spinePoles, spineKnots, spineMults, 3);
	TopoShape pipe = MakePipe(MakeWire(MakeEdge(spine)), MakeWire(MakeEdge(profile))).Shape();
	TopoExplorer ex(pipe, ShapeType::Face);
	std::shared_ptr<Geom3Surface> surface = TopoTool::Surface(static_cast<const TopoFace&>(ex.Current()));
	return surface;
}
shared_ptr<Geom3Surface> ConstructExtendPeriodicSurf()
{
	std::vector<Point3> profilePoles;
	profilePoles.push_back(Point3(0.0, 0.0, 0.0));
	profilePoles.push_back(Point3(1.0, -1.0, 0.0));
	profilePoles.push_back(Point3(2.0, -1.5, 0.0));
	profilePoles.push_back(Point3(2.3, -1.0, 0.0));
	profilePoles.push_back(Point3(2.9, 0.0, 0.0));
	profilePoles.push_back(Point3(2.3, 0.9, 0.0));
	profilePoles.push_back(Point3(2.1, 1.6, 0.0));
	profilePoles.push_back(Point3(1.0, 1.0, 0.0));
	std::vector<double> profileKnots(profilePoles.size() + 1);
	for (int i = 0; i < static_cast<int>(profileKnots.size()); i++)
	{
		profileKnots[i] = (double)i / (double)(profilePoles.size());
	}
	profileKnots[1] += 1.0 / (double)(3 * profilePoles.size());
	std::vector<int> profileMults(profileKnots.size(), 1);
	std::shared_ptr<Geom3BSplineCurve> profile = std::make_shared<Geom3BSplineCurve>(profilePoles, profileKnots, profileMults, 3, true);
	std::vector<Point3> spinePoles;
	std::vector<double> spineKnots(4);
	std::vector<int> spineMults(4, 1);
	spinePoles.push_back(Point3(0.0, 0.0, 0.0));
	spinePoles.push_back(Point3(0.0, 0.0, 1.0));
	spinePoles.push_back(Point3(0.0, 0.2, 1.5));
	spinePoles.push_back(Point3(0.0, 0.5, 2.0));
	spinePoles.push_back(Point3(0.0, 1.0, 2.3));
	spinePoles.push_back(Point3(0.0, 1.6, 2.3));
	spineKnots[0] = 0;
	spineKnots[1] = 1.0 / 3.0;
	spineKnots[2] = 2.0 / 3.0;
	spineKnots[3] = 1;
	spineMults.front() = 4;
	spineMults.back() = 4;
	std::shared_ptr<Geom3BSplineCurve> spine = std::make_shared<Geom3BSplineCurve>(spinePoles, spineKnots, spineMults, 3);
	TopoShape pipe = MakePipe(MakeWire(MakeEdge(spine)), MakeWire(MakeEdge(profile))).Shape();
	TopoExplorer ex(pipe, ShapeType::Face);
	std::shared_ptr<Geom3Surface> surface = TopoTool::Surface(static_cast<const TopoFace&>(ex.Current()));
	return surface;
}
TEST_CASE("bug7: ExtendPeriodicSurf3 ", "[nurbs][Extend][fixbug]")
{
	OUTPUT_DIRECTORY(nurbs, Extend/bug689/ExtendPeriodicSurf3);
	shared_ptr<Geom3Surface> surface = ConstructExtendPeriodicSurf();
	auto plane = std::make_shared<Geom3Plane>(Point3(0.0, 0.0, -5.3), Direction3(0.0, 0.0, 1.0));
	auto planevf = NURBSAPIExtend::ExtendSurfPerpendicularToPlane(surface, false, true, plane);
	shared_ptr<Geom3TrimmedSurface>trimSurf = std::make_shared<Geom3TrimmedSurface>(plane, -10.0, 10.0, -10.0, 10.0);
	double fpv1 = planevf->FirstUParameter();
	shared_ptr<Geom3Curve> fv1 = planevf->UIso(fpv1);
	Point3 p1;
	Vector3 vec;
	double fs = fv1->FirstParameter();
	fv1->D1(fs, p1, vec);
	Axis3 axis = plane->Axis();
	bool res = axis.Direction().IsParallel(Direction3(vec), Precision::Angular());
	CHECK(res == true);
	OCCTIO::OCCTTool::Write(MakeEdge(fv1), outdir + "curve2.brep");
	OCCTIO::OCCTTool::Write(MakeFace(trimSurf, 0.0), outdir + "trimSurf.brep");
	OCCTIO::OCCTTool::Write(MakeFace(surface, 0.0), outdir + "src.brep");
	OCCTIO::OCCTTool::Write(MakeFace(planevf, 0.0), outdir + "result.brep");
;
	SECTION("ExtendCurvePerpendicularToPlane2")
	{
		OUTPUT_DIRECTORY(nurbs, Extend/IncreaseDegree/ExtendCurve/ExtendCurvePerpendicularToPlane2);
		auto plane2 = std::make_shared<Geom3Plane>(Point3(0.0, -1.2, 0.0), Direction3(0.0, 1.0, 0.0));
		auto n5bsp = NURBSAPIExtend::ExtendCurvePerpendicularToPlane(bsp, plane2);
		shared_ptr<Geom3TrimmedSurface>trimtp2 = std::make_shared<Geom3TrimmedSurface>(plane2, -2.0, 2.0, -2.0, 2.0);
		double fp = n5bsp->FirstParameter();
		double lp = n5bsp->LastParameter();
		Point3 p1 = n5bsp->Value(fp);
		Point3 p2 = n5bsp->Value(lp);
		auto n5bspInc = NURBSAPIExtend::ExtendCurvePerpendicularToPlane(bspInc, plane2);
		shared_ptr<Geom3BSplineCurve> bspCurveInc = NURBSAPIConvert::ToBSpline(n5bspInc);
		CHECK(bspCurveInc->Degree() == refDeg);
		CHECK(bspCurveInc->NKnots() == (kNum + 1));
		double fpInc = n5bspInc->FirstParameter();
		double lpInc = n5bspInc->LastParameter();
		Point3 p1Inc = n5bspInc->Value(fpInc);
		Point3 p2Inc = n5bspInc->Value(lpInc);
		CHECK(p2Inc.X() == Approx(ep.X()));
		CHECK(p2Inc.Y() == Approx(ep.Y()));
		CHECK(p2Inc.Z() == Approx(ep.Z()));
		bool res11 = BRepClassificationTools::IsPointInFace(MakeFace(trimtp2, 0.0), p1Inc);
		CHECK(res11 == true);
		Point3 p3Inc;
		Vector3 vecInc;
		n5bspInc->D1(fpInc, p3Inc, vecInc);
		Axis3 axisInc = plane2->Axis();
		bool res22 = axisInc.Direction().IsParallel(Direction3(vecInc), Precision::Angular());
		CHECK(res22 == true);
		double res33 = NurbsSampleCurve(num, refTol, n5bsp, n5bspInc);
		CHECK(res33 <= ratio);
		OCCTIO::OCCTTool::Write(MakeVertex(sp), outdir + "sp.brep");
		OCCTIO::OCCTTool::Write(MakeVertex(ep), outdir + "ep.brep");
		OCCTIO::OCCTTool::Write(MakeVertex(p1), outdir + "p1.brep");
		OCCTIO::OCCTTool::Write(MakeVertex(p2), outdir + "p2.brep");
		OCCTIO::OCCTTool::Write(MakeEdge(bsp), outdir + "src.brep");
		OCCTIO::OCCTTool::Write(MakeFace(trimtp2, 0.0), outdir + "trimtp2.brep");
		OCCTIO::OCCTTool::Write(MakeEdge(n5bsp), outdir + "result.brep");
		OCCTIO::OCCTTool::Write(MakeEdge(n5bspInc), outdir + "resultInc.brep");
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static std::shared_ptr<Geom3Surface> ExtendSurfPerpendicularToPlane(const std::shared_ptr<Geom3Surface>& surf, const std::shared_ptr<Geom3Plane>& plane)	 @return New surface
	 @param plane Plane
	 @param surf Surf
	 The degree of surface is not changed but the size of the extended direction (u or v) knots and poles increase 1.
	 The original surface is part of new surface.
	 @brief Extend surface to plane and the surface end which is closer to plane is always perpendicular to the plane, which can be used in mirror to fix the gap.
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <nurbs/NURBSAPIExtend.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeFace.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/Geom3Plane.hpp>
#include <geometry/Geom3TrimmedSurface.hpp>
#include <nurbs/NURBSAPIConvert.hpp>
#include <nurbs/NURBSAPIBuildCurve.hpp>
#include <geomAlgo/LawBSpline.hpp>
#include <offset/MakePipe.hpp>
#include <modeling/MakeWire.hpp>
#include <topology/TopoTool.hpp>
#include <topology/TopoExplorerTool.hpp>
#include <geometry/GeomAPIProjectPointOnCurve3.hpp>
#include <geometry/GeomAPIProjectPointOnSurface.hpp>
double NurbsExtendSample(int num, double len, double tol, const shared_ptr<Geom3Curve>& curve1, const shared_ptr<Geom3Curve>& curve2)
{
	const int nsample = num;
	double fp1 = curve1->FirstParameter();
	double lp1 = curve1->LastParameter();
	double delta1 = (lp1 - fp1) / nsample;
	Point3 p;
	int n = 0;
	for (int i = 0; i < nsample; i++)
	{
		double t1 = fp1 + i * delta1;
		curve1->D0(t1, p);
		TopoVertex vt = MakeVertex(p);
		TopoEdge edge = MakeEdge(curve2);
		BRepExtremaDistShapeShape dist(vt, edge);
		double dis = abs(dist.Value() - len);
		if (dis <= tol)
		{
			n++;
		}
	}
	double res = 1.0 * (num - n) / num;
	return res;
}
shared_ptr<Geom3Surface> ConstructExtendSurface()
{
	std::vector<Point3> profilePoles;
	std::vector<double> profileKnots(3);
	std::vector<int> profileMults(3, 1);
	profilePoles.push_back(Point3(0.0, 0.0, 0.0));
	profilePoles.push_back(Point3(1.0, -0.2, 0.0));
	profilePoles.push_back(Point3(2.0, 0.1, 0.0));
	profilePoles.push_back(Point3(2.3, -0.1, 0.0));
	profilePoles.push_back(Point3(2.9, 0.1, 0.0));
	profileKnots[0] = 0;
	profileKnots[1] = 0.5;
	profileKnots[2] = 1;
	profileMults.front() = 4;
	profileMults.back() = 4;
	std::shared_ptr<Geom3BSplineCurve> profile = std::make_shared<Geom3BSplineCurve>(profilePoles, profileKnots, profileMults, 3);
	std::vector<Point3> spinePoles;
	std::vector<double> spineKnots(4);
	std::vector<int> spineMults(4, 1);
	spinePoles.push_back(Point3(0.0, 0.0, 0.0));
	spinePoles.push_back(Point3(0.0, 0.0, 1.0));
	spinePoles.push_back(Point3(0.0, 0.2, 1.5));
	spinePoles.push_back(Point3(0.0, 0.5, 2.0));
	spinePoles.push_back(Point3(0.0, 1.0, 2.3));
	spinePoles.push_back(Point3(0.0, 1.6, 2.3));
	spineKnots[0] = 0;
	spineKnots[1] = 1.0 / 3.0;
	spineKnots[2] = 2.0 / 3.0;
	spineKnots[3] = 1;
	spineMults.front() = 4;
	spineMults.back() = 4;
	std::shared_ptr<Geom3BSplineCurve> spine = std::make_shared<Geom3BSplineCurve>(spinePoles, spineKnots, spineMults, 3);
	TopoShape pipe = MakePipe(MakeWire(MakeEdge(spine)), MakeWire(MakeEdge(profile))).Shape();
	TopoExplorer ex(pipe, ShapeType::Face);
	std::shared_ptr<Geom3Surface> surface = TopoTool::Surface(static_cast<const TopoFace&>(ex.Current()));
	return surface;
}
shared_ptr<Geom3Surface> ConstructExtendPeriodicSurf()
{
	std::vector<Point3> profilePoles;
	profilePoles.push_back(Point3(0.0, 0.0, 0.0));
	profilePoles.push_back(Point3(1.0, -1.0, 0.0));
	profilePoles.push_back(Point3(2.0, -1.5, 0.0));
	profilePoles.push_back(Point3(2.3, -1.0, 0.0));
	profilePoles.push_back(Point3(2.9, 0.0, 0.0));
	profilePoles.push_back(Point3(2.3, 0.9, 0.0));
	profilePoles.push_back(Point3(2.1, 1.6, 0.0));
	profilePoles.push_back(Point3(1.0, 1.0, 0.0));
	std::vector<double> profileKnots(profilePoles.size() + 1);
	for (int i = 0; i < static_cast<int>(profileKnots.size()); i++)
	{
		profileKnots[i] = (double)i / (double)(profilePoles.size());
	}
	profileKnots[1] += 1.0 / (double)(3 * profilePoles.size());
	std::vector<int> profileMults(profileKnots.size(), 1);
	std::shared_ptr<Geom3BSplineCurve> profile = std::make_shared<Geom3BSplineCurve>(profilePoles, profileKnots, profileMults, 3, true);
	std::vector<Point3> spinePoles;
	std::vector<double> spineKnots(4);
	std::vector<int> spineMults(4, 1);
	spinePoles.push_back(Point3(0.0, 0.0, 0.0));
	spinePoles.push_back(Point3(0.0, 0.0, 1.0));
	spinePoles.push_back(Point3(0.0, 0.2, 1.5));
	spinePoles.push_back(Point3(0.0, 0.5, 2.0));
	spinePoles.push_back(Point3(0.0, 1.0, 2.3));
	spinePoles.push_back(Point3(0.0, 1.6, 2.3));
	spineKnots[0] = 0;
	spineKnots[1] = 1.0 / 3.0;
	spineKnots[2] = 2.0 / 3.0;
	spineKnots[3] = 1;
	spineMults.front() = 4;
	spineMults.back() = 4;
	std::shared_ptr<Geom3BSplineCurve> spine = std::make_shared<Geom3BSplineCurve>(spinePoles, spineKnots, spineMults, 3);
	TopoShape pipe = MakePipe(MakeWire(MakeEdge(spine)), MakeWire(MakeEdge(profile))).Shape();
	TopoExplorer ex(pipe, ShapeType::Face);
	std::shared_ptr<Geom3Surface> surface = TopoTool::Surface(static_cast<const TopoFace&>(ex.Current()));
	return surface;
}
TEST_CASE("bug7: ExtendPeriodicSurf3 ", "[nurbs][Extend][fixbug]")
{
	OUTPUT_DIRECTORY(nurbs, Extend/bug689/ExtendPeriodicSurf3);
	shared_ptr<Geom3Surface> surface = ConstructExtendPeriodicSurf();
	auto plane = std::make_shared<Geom3Plane>(Point3(0.0, 0.0, -5.3), Direction3(0.0, 0.0, 1.0));
	auto planevf = NURBSAPIExtend::ExtendSurfPerpendicularToPlane(surface, false, true, plane);
	shared_ptr<Geom3TrimmedSurface>trimSurf = std::make_shared<Geom3TrimmedSurface>(plane, -10.0, 10.0, -10.0, 10.0);
	double fpv1 = planevf->FirstUParameter();
	shared_ptr<Geom3Curve> fv1 = planevf->UIso(fpv1);
	Point3 p1;
	Vector3 vec;
	double fs = fv1->FirstParameter();
	fv1->D1(fs, p1, vec);
	Axis3 axis = plane->Axis();
	bool res = axis.Direction().IsParallel(Direction3(vec), Precision::Angular());
	CHECK(res == true);
	OCCTIO::OCCTTool::Write(MakeEdge(fv1), outdir + "curve2.brep");
	OCCTIO::OCCTTool::Write(MakeFace(trimSurf, 0.0), outdir + "trimSurf.brep");
	OCCTIO::OCCTTool::Write(MakeFace(surface, 0.0), outdir + "src.brep");
	OCCTIO::OCCTTool::Write(MakeFace(planevf, 0.0), outdir + "result.brep");
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static std::shared_ptr<Geom3Surface> ExtendSurfPerpendicularToPlane(const std::shared_ptr<Geom3Surface>& surf, bool isExtendU, bool isFront, const std::shared_ptr<Geom3Plane>& plane)	 @return New surface
	 @param plane Plane
	 @param isFront Extend front or back
	 @param isExtendU Extend u or v
	 @param surf Surf
	 The degree of surface is not changed but the size of the extended direction (u or v) knots and poles increase 1.
	 The original surface is part of new surface.
	 @brief Extend surface to plane and the end of surface is always perpendicular to the plane, which can be used in mirror to fix the gap.
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <nurbs/NURBSAPIExtend.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeFace.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/Geom3Plane.hpp>
#include <geometry/Geom3TrimmedSurface.hpp>
#include <nurbs/NURBSAPIConvert.hpp>
#include <nurbs/NURBSAPIBuildCurve.hpp>
#include <geomAlgo/LawBSpline.hpp>
#include <offset/MakePipe.hpp>
#include <modeling/MakeWire.hpp>
#include <topology/TopoTool.hpp>
#include <topology/TopoExplorerTool.hpp>
#include <geometry/GeomAPIProjectPointOnCurve3.hpp>
#include <geometry/GeomAPIProjectPointOnSurface.hpp>
double NurbsExtendSample(int num, double len, double tol, const shared_ptr<Geom3Curve>& curve1, const shared_ptr<Geom3Curve>& curve2)
{
	const int nsample = num;
	double fp1 = curve1->FirstParameter();
	double lp1 = curve1->LastParameter();
	double delta1 = (lp1 - fp1) / nsample;
	Point3 p;
	int n = 0;
	for (int i = 0; i < nsample; i++)
	{
		double t1 = fp1 + i * delta1;
		curve1->D0(t1, p);
		TopoVertex vt = MakeVertex(p);
		TopoEdge edge = MakeEdge(curve2);
		BRepExtremaDistShapeShape dist(vt, edge);
		double dis = abs(dist.Value() - len);
		if (dis <= tol)
		{
			n++;
		}
	}
	double res = 1.0 * (num - n) / num;
	return res;
}
shared_ptr<Geom3Surface> ConstructExtendSurface()
{
	std::vector<Point3> profilePoles;
	std::vector<double> profileKnots(3);
	std::vector<int> profileMults(3, 1);
	profilePoles.push_back(Point3(0.0, 0.0, 0.0));
	profilePoles.push_back(Point3(1.0, -0.2, 0.0));
	profilePoles.push_back(Point3(2.0, 0.1, 0.0));
	profilePoles.push_back(Point3(2.3, -0.1, 0.0));
	profilePoles.push_back(Point3(2.9, 0.1, 0.0));
	profileKnots[0] = 0;
	profileKnots[1] = 0.5;
	profileKnots[2] = 1;
	profileMults.front() = 4;
	profileMults.back() = 4;
	std::shared_ptr<Geom3BSplineCurve> profile = std::make_shared<Geom3BSplineCurve>(profilePoles, profileKnots, profileMults, 3);
	std::vector<Point3> spinePoles;
	std::vector<double> spineKnots(4);
	std::vector<int> spineMults(4, 1);
	spinePoles.push_back(Point3(0.0, 0.0, 0.0));
	spinePoles.push_back(Point3(0.0, 0.0, 1.0));
	spinePoles.push_back(Point3(0.0, 0.2, 1.5));
	spinePoles.push_back(Point3(0.0, 0.5, 2.0));
	spinePoles.push_back(Point3(0.0, 1.0, 2.3));
	spinePoles.push_back(Point3(0.0, 1.6, 2.3));
	spineKnots[0] = 0;
	spineKnots[1] = 1.0 / 3.0;
	spineKnots[2] = 2.0 / 3.0;
	spineKnots[3] = 1;
	spineMults.front() = 4;
	spineMults.back() = 4;
	std::shared_ptr<Geom3BSplineCurve> spine = std::make_shared<Geom3BSplineCurve>(spinePoles, spineKnots, spineMults, 3);
	TopoShape pipe = MakePipe(MakeWire(MakeEdge(spine)), MakeWire(MakeEdge(profile))).Shape();
	TopoExplorer ex(pipe, ShapeType::Face);
	std::shared_ptr<Geom3Surface> surface = TopoTool::Surface(static_cast<const TopoFace&>(ex.Current()));
	return surface;
}
shared_ptr<Geom3Surface> ConstructExtendPeriodicSurf()
{
	std::vector<Point3> profilePoles;
	profilePoles.push_back(Point3(0.0, 0.0, 0.0));
	profilePoles.push_back(Point3(1.0, -1.0, 0.0));
	profilePoles.push_back(Point3(2.0, -1.5, 0.0));
	profilePoles.push_back(Point3(2.3, -1.0, 0.0));
	profilePoles.push_back(Point3(2.9, 0.0, 0.0));
	profilePoles.push_back(Point3(2.3, 0.9, 0.0));
	profilePoles.push_back(Point3(2.1, 1.6, 0.0));
	profilePoles.push_back(Point3(1.0, 1.0, 0.0));
	std::vector<double> profileKnots(profilePoles.size() + 1);
	for (int i = 0; i < static_cast<int>(profileKnots.size()); i++)
	{
		profileKnots[i] = (double)i / (double)(profilePoles.size());
	}
	profileKnots[1] += 1.0 / (double)(3 * profilePoles.size());
	std::vector<int> profileMults(profileKnots.size(), 1);
	std::shared_ptr<Geom3BSplineCurve> profile = std::make_shared<Geom3BSplineCurve>(profilePoles, profileKnots, profileMults, 3, true);
	std::vector<Point3> spinePoles;
	std::vector<double> spineKnots(4);
	std::vector<int> spineMults(4, 1);
	spinePoles.push_back(Point3(0.0, 0.0, 0.0));
	spinePoles.push_back(Point3(0.0, 0.0, 1.0));
	spinePoles.push_back(Point3(0.0, 0.2, 1.5));
	spinePoles.push_back(Point3(0.0, 0.5, 2.0));
	spinePoles.push_back(Point3(0.0, 1.0, 2.3));
	spinePoles.push_back(Point3(0.0, 1.6, 2.3));
	spineKnots[0] = 0;
	spineKnots[1] = 1.0 / 3.0;
	spineKnots[2] = 2.0 / 3.0;
	spineKnots[3] = 1;
	spineMults.front() = 4;
	spineMults.back() = 4;
	std::shared_ptr<Geom3BSplineCurve> spine = std::make_shared<Geom3BSplineCurve>(spinePoles, spineKnots, spineMults, 3);
	TopoShape pipe = MakePipe(MakeWire(MakeEdge(spine)), MakeWire(MakeEdge(profile))).Shape();
	TopoExplorer ex(pipe, ShapeType::Face);
	std::shared_ptr<Geom3Surface> surface = TopoTool::Surface(static_cast<const TopoFace&>(ex.Current()));
	return surface;
}
TEST_CASE("bug2:ExtendPeriodicSurf ", "[nurbs][Extend][fixbug]")
{
	OUTPUT_DIRECTORY(nurbs, Extend/bug612);
	int num = 1000;
	double tol = 1e-4;
	double ratio = 0.01;
	double refTol = DEFAULT_TOLERANCE;
	std::vector<Point3> profilePoles;
	profilePoles.push_back(Point3(0.0, 0.0, 0.0));
	profilePoles.push_back(Point3(1.0, -1.0, 0.0));
	profilePoles.push_back(Point3(2.0, -1.5, 0.0));
	profilePoles.push_back(Point3(2.3, -1.0, 0.0));
	profilePoles.push_back(Point3(2.9, 0.0, 0.0));
	profilePoles.push_back(Point3(2.3, 0.9, 0.0));
	profilePoles.push_back(Point3(2.1, 1.6, 0.0));
	profilePoles.push_back(Point3(1.0, 1.0, 0.0));
	std::vector<double> profileKnots(profilePoles.size() + 1);
	for (int i = 0; i < static_cast<int>(profileKnots.size()); i++)
	{
		profileKnots[i] = (double)i / (double)(profilePoles.size());
	}
	profileKnots[1] += 1.0 / (double)(3 * profilePoles.size());
	std::vector<int> profileMults(profileKnots.size(), 1);
	std::shared_ptr<Geom3BSplineCurve> profile = std::make_shared<Geom3BSplineCurve>(profilePoles, profileKnots, profileMults, 3, true);
	std::vector<Point3> spinePoles;
	std::vector<double> spineKnots(4);
	std::vector<int> spineMults(4, 1);
	spinePoles.push_back(Point3(0.0, 0.0, 0.0));
	spinePoles.push_back(Point3(0.0, 0.0, 1.0));
	spinePoles.push_back(Point3(0.0, 0.2, 1.5));
	spinePoles.push_back(Point3(0.0, 0.5, 2.0));
	spinePoles.push_back(Point3(0.0, 1.0, 2.3));
	spinePoles.push_back(Point3(0.0, 1.6, 2.3));
	spineKnots[0] = 0;
	spineKnots[1] = 1.0 / 3.0;
	spineKnots[2] = 2.0 / 3.0;
	spineKnots[3] = 1;
	spineMults.front() = 4;
	spineMults.back() = 4;
	std::shared_ptr<Geom3BSplineCurve> spine = std::make_shared<Geom3BSplineCurve>(spinePoles, spineKnots, spineMults, 3);
	TopoShape pipe = MakePipe(MakeWire(MakeEdge(spine)), MakeWire(MakeEdge(profile))).Shape();
	TopoExplorer ex(pipe, ShapeType::Face);
	std::shared_ptr<Geom3Surface> surface = TopoTool::Surface(static_cast<const TopoFace&>(ex.Current()));
	shared_ptr<Geom3BSplineSurface> bspSurf = NURBSAPIConvert::ToBSpline(surface);
	int udeg = bspSurf->UDegree();
	int vdeg = bspSurf->VDegree();
	int upNum = bspSurf->NUPoles();
	int vpNum = bspSurf->NVPoles();
	int ukNum = bspSurf->NUKnots();
	int vkNum = bspSurf->NVKnots();
	double fpu = surface->FirstUParameter();
	double fpv = surface->FirstVParameter();
	double lpu = surface->LastUParameter();
	double lpv = surface->LastVParameter();
	shared_ptr<Geom3Curve> fu = surface->UIso(fpu);
	shared_ptr<Geom3Curve> fv = surface->VIso(fpv);
	shared_ptr<Geom3Curve> lu = surface->UIso(lpu);
	shared_ptr<Geom3Curve> lv = surface->VIso(lpv);
	auto plane = std::make_shared<Geom3Plane>(Point3(0.0, 0.0, -5.3), Direction3(0.0, 0.0, 1.0));
	auto planevf = NURBSAPIExtend::ExtendSurfPerpendicularToPlane(surface, false, true, plane);
	shared_ptr<Geom3TrimmedSurface>trimSurf = std::make_shared<Geom3TrimmedSurface>(plane, -10.0, 10.0, -10.0, 10.0);
	shared_ptr<Geom3BSplineSurface> bspSurf2 = NURBSAPIConvert::ToBSpline(planevf);
	CHECK(bspSurf2->UDegree() == udeg);
	CHECK(bspSurf2->VDegree() == vdeg);
	CHECK(bspSurf2->NUPoles() == upNum);
	CHECK(bspSurf2->NVPoles() == (vpNum + 1));
	CHECK(bspSurf2->NUKnots() == ukNum);
	CHECK(bspSurf2->NVKnots() == (vkNum + 1));
	double fpv2 = planevf->FirstVParameter();
	shared_ptr<Geom3Curve> fv2 = planevf->VIso(fpv2);
	bool res2 = IsCurveOnSurf(num, ratio, fv2, plane, -1.0);
	CHECK(res2 == true);
	OCCTIO::OCCTTool::Write(MakeFace(trimSurf, 0.0), outdir + "trimSurf.brep");
	OCCTIO::OCCTTool::Write(MakeFace(surface, 0.0), outdir + "src.brep");
	OCCTIO::OCCTTool::Write(MakeFace(planevf, 0.0), outdir + "result.brep");
;
	SECTION("ExtendSurfPerpendicularToPlane4")
	{
		OUTPUT_DIRECTORY(nurbs, Extend/bug614/ExtendSurfPerpendicularToPlane4);
		shared_ptr<Geom3Plane> plane = make_shared<Geom3Plane>(Point3(0.0, 1.8, 0.0), Direction3(0.0, 1.0, 0.0));
		auto planevl = NURBSAPIExtend::ExtendSurfPerpendicularToPlane(surface, false, false, plane);
		shared_ptr<Geom3TrimmedSurface>trimSurf = std::make_shared<Geom3TrimmedSurface>(plane, -5.0, 5.0, -5.0, 5.0);
		shared_ptr<Geom3BSplineSurface> bspSurf2 = NURBSAPIConvert::ToBSpline(planevl);
		CHECK(bspSurf2->VDegree() == vdeg);
		CHECK(bspSurf2->NVPoles() == (vpNum + 1));
		CHECK(bspSurf2->NVKnots() == (vkNum + 1));
		OCCTIO::OCCTTool::Write(MakeFace(trimSurf, 0.0), outdir + "trimSurf.brep");
		OCCTIO::OCCTTool::Write(MakeFace(surface, 0.0), outdir + "src.brep");
		OCCTIO::OCCTTool::Write(MakeFace(planevl, 0.0), outdir + "result.brep");
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static std::shared_ptr<Geom3Curve> ExtendCurveToDynamicPoint(const std::shared_ptr<Geom3Curve>& curve, bool isFront, const Point3& pt)	 @return New curve
	 @param pt Point
	 @param isFront Extend front or back
	 @param curve Curve
	 The degree is not changed but the number of poles and knots increase 1.
	 The original curve is part of new curve.
	 @brief Extend curve to a point.
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <nurbs/NURBSAPIExtend.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeFace.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/Geom3Plane.hpp>
#include <geometry/Geom3TrimmedSurface.hpp>
#include <nurbs/NURBSAPIConvert.hpp>
#include <nurbs/NURBSAPIBuildCurve.hpp>
#include <geomAlgo/LawBSpline.hpp>
#include <offset/MakePipe.hpp>
#include <modeling/MakeWire.hpp>
#include <topology/TopoTool.hpp>
#include <topology/TopoExplorerTool.hpp>
#include <geometry/GeomAPIProjectPointOnCurve3.hpp>
#include <geometry/GeomAPIProjectPointOnSurface.hpp>
double NurbsExtendSample(int num, double len, double tol, const shared_ptr<Geom3Curve>& curve1, const shared_ptr<Geom3Curve>& curve2)
{
	const int nsample = num;
	double fp1 = curve1->FirstParameter();
	double lp1 = curve1->LastParameter();
	double delta1 = (lp1 - fp1) / nsample;
	Point3 p;
	int n = 0;
	for (int i = 0; i < nsample; i++)
	{
		double t1 = fp1 + i * delta1;
		curve1->D0(t1, p);
		TopoVertex vt = MakeVertex(p);
		TopoEdge edge = MakeEdge(curve2);
		BRepExtremaDistShapeShape dist(vt, edge);
		double dis = abs(dist.Value() - len);
		if (dis <= tol)
		{
			n++;
		}
	}
	double res = 1.0 * (num - n) / num;
	return res;
}
shared_ptr<Geom3Surface> ConstructExtendSurface()
{
	std::vector<Point3> profilePoles;
	std::vector<double> profileKnots(3);
	std::vector<int> profileMults(3, 1);
	profilePoles.push_back(Point3(0.0, 0.0, 0.0));
	profilePoles.push_back(Point3(1.0, -0.2, 0.0));
	profilePoles.push_back(Point3(2.0, 0.1, 0.0));
	profilePoles.push_back(Point3(2.3, -0.1, 0.0));
	profilePoles.push_back(Point3(2.9, 0.1, 0.0));
	profileKnots[0] = 0;
	profileKnots[1] = 0.5;
	profileKnots[2] = 1;
	profileMults.front() = 4;
	profileMults.back() = 4;
	std::shared_ptr<Geom3BSplineCurve> profile = std::make_shared<Geom3BSplineCurve>(profilePoles, profileKnots, profileMults, 3);
	std::vector<Point3> spinePoles;
	std::vector<double> spineKnots(4);
	std::vector<int> spineMults(4, 1);
	spinePoles.push_back(Point3(0.0, 0.0, 0.0));
	spinePoles.push_back(Point3(0.0, 0.0, 1.0));
	spinePoles.push_back(Point3(0.0, 0.2, 1.5));
	spinePoles.push_back(Point3(0.0, 0.5, 2.0));
	spinePoles.push_back(Point3(0.0, 1.0, 2.3));
	spinePoles.push_back(Point3(0.0, 1.6, 2.3));
	spineKnots[0] = 0;
	spineKnots[1] = 1.0 / 3.0;
	spineKnots[2] = 2.0 / 3.0;
	spineKnots[3] = 1;
	spineMults.front() = 4;
	spineMults.back() = 4;
	std::shared_ptr<Geom3BSplineCurve> spine = std::make_shared<Geom3BSplineCurve>(spinePoles, spineKnots, spineMults, 3);
	TopoShape pipe = MakePipe(MakeWire(MakeEdge(spine)), MakeWire(MakeEdge(profile))).Shape();
	TopoExplorer ex(pipe, ShapeType::Face);
	std::shared_ptr<Geom3Surface> surface = TopoTool::Surface(static_cast<const TopoFace&>(ex.Current()));
	return surface;
}
shared_ptr<Geom3Surface> ConstructExtendPeriodicSurf()
{
	std::vector<Point3> profilePoles;
	profilePoles.push_back(Point3(0.0, 0.0, 0.0));
	profilePoles.push_back(Point3(1.0, -1.0, 0.0));
	profilePoles.push_back(Point3(2.0, -1.5, 0.0));
	profilePoles.push_back(Point3(2.3, -1.0, 0.0));
	profilePoles.push_back(Point3(2.9, 0.0, 0.0));
	profilePoles.push_back(Point3(2.3, 0.9, 0.0));
	profilePoles.push_back(Point3(2.1, 1.6, 0.0));
	profilePoles.push_back(Point3(1.0, 1.0, 0.0));
	std::vector<double> profileKnots(profilePoles.size() + 1);
	for (int i = 0; i < static_cast<int>(profileKnots.size()); i++)
	{
		profileKnots[i] = (double)i / (double)(profilePoles.size());
	}
	profileKnots[1] += 1.0 / (double)(3 * profilePoles.size());
	std::vector<int> profileMults(profileKnots.size(), 1);
	std::shared_ptr<Geom3BSplineCurve> profile = std::make_shared<Geom3BSplineCurve>(profilePoles, profileKnots, profileMults, 3, true);
	std::vector<Point3> spinePoles;
	std::vector<double> spineKnots(4);
	std::vector<int> spineMults(4, 1);
	spinePoles.push_back(Point3(0.0, 0.0, 0.0));
	spinePoles.push_back(Point3(0.0, 0.0, 1.0));
	spinePoles.push_back(Point3(0.0, 0.2, 1.5));
	spinePoles.push_back(Point3(0.0, 0.5, 2.0));
	spinePoles.push_back(Point3(0.0, 1.0, 2.3));
	spinePoles.push_back(Point3(0.0, 1.6, 2.3));
	spineKnots[0] = 0;
	spineKnots[1] = 1.0 / 3.0;
	spineKnots[2] = 2.0 / 3.0;
	spineKnots[3] = 1;
	spineMults.front() = 4;
	spineMults.back() = 4;
	std::shared_ptr<Geom3BSplineCurve> spine = std::make_shared<Geom3BSplineCurve>(spinePoles, spineKnots, spineMults, 3);
	TopoShape pipe = MakePipe(MakeWire(MakeEdge(spine)), MakeWire(MakeEdge(profile))).Shape();
	TopoExplorer ex(pipe, ShapeType::Face);
	std::shared_ptr<Geom3Surface> surface = TopoTool::Surface(static_cast<const TopoFace&>(ex.Current()));
	return surface;
}
TEST_CASE("bug7: ExtendPeriodicSurf3 ", "[nurbs][Extend][fixbug]")
{
	OUTPUT_DIRECTORY(nurbs, Extend/bug689/ExtendPeriodicSurf3);
	shared_ptr<Geom3Surface> surface = ConstructExtendPeriodicSurf();
	auto plane = std::make_shared<Geom3Plane>(Point3(0.0, 0.0, -5.3), Direction3(0.0, 0.0, 1.0));
	auto planevf = NURBSAPIExtend::ExtendSurfPerpendicularToPlane(surface, false, true, plane);
	shared_ptr<Geom3TrimmedSurface>trimSurf = std::make_shared<Geom3TrimmedSurface>(plane, -10.0, 10.0, -10.0, 10.0);
	double fpv1 = planevf->FirstUParameter();
	shared_ptr<Geom3Curve> fv1 = planevf->UIso(fpv1);
	Point3 p1;
	Vector3 vec;
	double fs = fv1->FirstParameter();
	fv1->D1(fs, p1, vec);
	Axis3 axis = plane->Axis();
	bool res = axis.Direction().IsParallel(Direction3(vec), Precision::Angular());
	CHECK(res == true);
	OCCTIO::OCCTTool::Write(MakeEdge(fv1), outdir + "curve2.brep");
	OCCTIO::OCCTTool::Write(MakeFace(trimSurf, 0.0), outdir + "trimSurf.brep");
	OCCTIO::OCCTTool::Write(MakeFace(surface, 0.0), outdir + "src.brep");
	OCCTIO::OCCTTool::Write(MakeFace(planevf, 0.0), outdir + "result.brep");
;
	SECTION("TestExtendDynamic")
	{
		OUTPUT_DIRECTORY(nurbs, Extend/bug711/ExtendDynamic);
		int num = 1000;
		double ratio = 0.1;
		double refTol = DEFAULT_TOLERANCE;
		int refDeg = INCREASE_DEGREE;
		auto src2 = ReadBRepCurve(INPUT_PATH_PREFIX"/TestNURBS/TestExtendDynamic/src2.brep");
		auto targetPoint2 = ReadBRepPoint(INPUT_PATH_PREFIX"/TestNURBS/TestExtendDynamic/target2.brep");
		LawBSpline srcw2(src2->Weights(), src2->Knots(), src2->Multiplicities(), src2->Degree(), src2->IsPeriodic());
		double src2weight, src2dw, src2dw2;
		double t2 = src2->FirstParameter() + 0.01;
		srcw2.D2(t2, src2weight, src2dw, src2dw2);
		shared_ptr<Geom3BSplineCurve> src2Inc = std::dynamic_pointer_cast<Geom3BSplineCurve>(src2->Copy());
		src2Inc->IncreaseDegree(refDeg);
		auto extended2 = NURBSAPIExtend::ExtendCurveToDynamicPoint(src2, true, targetPoint2);
		auto extended2Inc = NURBSAPIExtend::ExtendCurveToDynamicPoint(src2Inc, true, targetPoint2);
		shared_ptr<Geom3BSplineCurve> bspCurve2 = NURBSAPIConvert::ToBSpline(extended2);
		shared_ptr<Geom3BSplineCurve> bspCurve2Inc = NURBSAPIConvert::ToBSpline(extended2Inc);
		CHECK(bspCurve2Inc->Degree() == refDeg);
		CHECK(bspCurve2Inc->NKnots() == bspCurve2->NKnots());
		double lp = extended2->LastParameter();
		Point3 ep2 = extended2->Value(lp);
		double fp2Inc = extended2Inc->FirstParameter();
		double lp2Inc = extended2Inc->LastParameter();
		Point3 p3Inc = extended2Inc->Value(fp2Inc);
		Point3 p4Inc = extended2Inc->Value(lp2Inc);
		CHECK(p3Inc.X() == Approx(targetPoint2.X()));
		CHECK(p3Inc.Y() == Approx(targetPoint2.Y()));
		CHECK(p3Inc.Z() == Approx(targetPoint2.Z()));
		CHECK(p4Inc.X() == Approx(ep2.X()));
		CHECK(p4Inc.Y() == Approx(ep2.Y()));
		CHECK(p4Inc.Z() == Approx(ep2.Z()));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static std::shared_ptr<Geom3Curve> ExtendCurveToPoint(const std::shared_ptr<Geom3Curve>& curve, bool isFront, const Point3& pt)	 @return New curve
	 @param pt Point
	 @param isFront Extend front or back
	 @param curve Curve
	 The degree and the number of poles and knots are not changed.
	 The original curve is part of new curve.
	 @brief Extend curve to a point.
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <nurbs/NURBSAPIExtend.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeFace.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/Geom3Plane.hpp>
#include <geometry/Geom3TrimmedSurface.hpp>
#include <nurbs/NURBSAPIConvert.hpp>
#include <nurbs/NURBSAPIBuildCurve.hpp>
#include <geomAlgo/LawBSpline.hpp>
#include <offset/MakePipe.hpp>
#include <modeling/MakeWire.hpp>
#include <topology/TopoTool.hpp>
#include <topology/TopoExplorerTool.hpp>
#include <geometry/GeomAPIProjectPointOnCurve3.hpp>
#include <geometry/GeomAPIProjectPointOnSurface.hpp>
double NurbsExtendSample(int num, double len, double tol, const shared_ptr<Geom3Curve>& curve1, const shared_ptr<Geom3Curve>& curve2)
{
	const int nsample = num;
	double fp1 = curve1->FirstParameter();
	double lp1 = curve1->LastParameter();
	double delta1 = (lp1 - fp1) / nsample;
	Point3 p;
	int n = 0;
	for (int i = 0; i < nsample; i++)
	{
		double t1 = fp1 + i * delta1;
		curve1->D0(t1, p);
		TopoVertex vt = MakeVertex(p);
		TopoEdge edge = MakeEdge(curve2);
		BRepExtremaDistShapeShape dist(vt, edge);
		double dis = abs(dist.Value() - len);
		if (dis <= tol)
		{
			n++;
		}
	}
	double res = 1.0 * (num - n) / num;
	return res;
}
shared_ptr<Geom3Surface> ConstructExtendSurface()
{
	std::vector<Point3> profilePoles;
	std::vector<double> profileKnots(3);
	std::vector<int> profileMults(3, 1);
	profilePoles.push_back(Point3(0.0, 0.0, 0.0));
	profilePoles.push_back(Point3(1.0, -0.2, 0.0));
	profilePoles.push_back(Point3(2.0, 0.1, 0.0));
	profilePoles.push_back(Point3(2.3, -0.1, 0.0));
	profilePoles.push_back(Point3(2.9, 0.1, 0.0));
	profileKnots[0] = 0;
	profileKnots[1] = 0.5;
	profileKnots[2] = 1;
	profileMults.front() = 4;
	profileMults.back() = 4;
	std::shared_ptr<Geom3BSplineCurve> profile = std::make_shared<Geom3BSplineCurve>(profilePoles, profileKnots, profileMults, 3);
	std::vector<Point3> spinePoles;
	std::vector<double> spineKnots(4);
	std::vector<int> spineMults(4, 1);
	spinePoles.push_back(Point3(0.0, 0.0, 0.0));
	spinePoles.push_back(Point3(0.0, 0.0, 1.0));
	spinePoles.push_back(Point3(0.0, 0.2, 1.5));
	spinePoles.push_back(Point3(0.0, 0.5, 2.0));
	spinePoles.push_back(Point3(0.0, 1.0, 2.3));
	spinePoles.push_back(Point3(0.0, 1.6, 2.3));
	spineKnots[0] = 0;
	spineKnots[1] = 1.0 / 3.0;
	spineKnots[2] = 2.0 / 3.0;
	spineKnots[3] = 1;
	spineMults.front() = 4;
	spineMults.back() = 4;
	std::shared_ptr<Geom3BSplineCurve> spine = std::make_shared<Geom3BSplineCurve>(spinePoles, spineKnots, spineMults, 3);
	TopoShape pipe = MakePipe(MakeWire(MakeEdge(spine)), MakeWire(MakeEdge(profile))).Shape();
	TopoExplorer ex(pipe, ShapeType::Face);
	std::shared_ptr<Geom3Surface> surface = TopoTool::Surface(static_cast<const TopoFace&>(ex.Current()));
	return surface;
}
shared_ptr<Geom3Surface> ConstructExtendPeriodicSurf()
{
	std::vector<Point3> profilePoles;
	profilePoles.push_back(Point3(0.0, 0.0, 0.0));
	profilePoles.push_back(Point3(1.0, -1.0, 0.0));
	profilePoles.push_back(Point3(2.0, -1.5, 0.0));
	profilePoles.push_back(Point3(2.3, -1.0, 0.0));
	profilePoles.push_back(Point3(2.9, 0.0, 0.0));
	profilePoles.push_back(Point3(2.3, 0.9, 0.0));
	profilePoles.push_back(Point3(2.1, 1.6, 0.0));
	profilePoles.push_back(Point3(1.0, 1.0, 0.0));
	std::vector<double> profileKnots(profilePoles.size() + 1);
	for (int i = 0; i < static_cast<int>(profileKnots.size()); i++)
	{
		profileKnots[i] = (double)i / (double)(profilePoles.size());
	}
	profileKnots[1] += 1.0 / (double)(3 * profilePoles.size());
	std::vector<int> profileMults(profileKnots.size(), 1);
	std::shared_ptr<Geom3BSplineCurve> profile = std::make_shared<Geom3BSplineCurve>(profilePoles, profileKnots, profileMults, 3, true);
	std::vector<Point3> spinePoles;
	std::vector<double> spineKnots(4);
	std::vector<int> spineMults(4, 1);
	spinePoles.push_back(Point3(0.0, 0.0, 0.0));
	spinePoles.push_back(Point3(0.0, 0.0, 1.0));
	spinePoles.push_back(Point3(0.0, 0.2, 1.5));
	spinePoles.push_back(Point3(0.0, 0.5, 2.0));
	spinePoles.push_back(Point3(0.0, 1.0, 2.3));
	spinePoles.push_back(Point3(0.0, 1.6, 2.3));
	spineKnots[0] = 0;
	spineKnots[1] = 1.0 / 3.0;
	spineKnots[2] = 2.0 / 3.0;
	spineKnots[3] = 1;
	spineMults.front() = 4;
	spineMults.back() = 4;
	std::shared_ptr<Geom3BSplineCurve> spine = std::make_shared<Geom3BSplineCurve>(spinePoles, spineKnots, spineMults, 3);
	TopoShape pipe = MakePipe(MakeWire(MakeEdge(spine)), MakeWire(MakeEdge(profile))).Shape();
	TopoExplorer ex(pipe, ShapeType::Face);
	std::shared_ptr<Geom3Surface> surface = TopoTool::Surface(static_cast<const TopoFace&>(ex.Current()));
	return surface;
}
TEST_CASE("bug7: ExtendPeriodicSurf3 ", "[nurbs][Extend][fixbug]")
{
	OUTPUT_DIRECTORY(nurbs, Extend/bug689/ExtendPeriodicSurf3);
	shared_ptr<Geom3Surface> surface = ConstructExtendPeriodicSurf();
	auto plane = std::make_shared<Geom3Plane>(Point3(0.0, 0.0, -5.3), Direction3(0.0, 0.0, 1.0));
	auto planevf = NURBSAPIExtend::ExtendSurfPerpendicularToPlane(surface, false, true, plane);
	shared_ptr<Geom3TrimmedSurface>trimSurf = std::make_shared<Geom3TrimmedSurface>(plane, -10.0, 10.0, -10.0, 10.0);
	double fpv1 = planevf->FirstUParameter();
	shared_ptr<Geom3Curve> fv1 = planevf->UIso(fpv1);
	Point3 p1;
	Vector3 vec;
	double fs = fv1->FirstParameter();
	fv1->D1(fs, p1, vec);
	Axis3 axis = plane->Axis();
	bool res = axis.Direction().IsParallel(Direction3(vec), Precision::Angular());
	CHECK(res == true);
	OCCTIO::OCCTTool::Write(MakeEdge(fv1), outdir + "curve2.brep");
	OCCTIO::OCCTTool::Write(MakeFace(trimSurf, 0.0), outdir + "trimSurf.brep");
	OCCTIO::OCCTTool::Write(MakeFace(surface, 0.0), outdir + "src.brep");
	OCCTIO::OCCTTool::Write(MakeFace(planevf, 0.0), outdir + "result.brep");
;
	SECTION("TestExtendCurveToPoint")
	{
		OUTPUT_DIRECTORY(nurbs, Extend/ExtendCurve/ExtendCurveToPoint);
		Point3 target(-3.0, -2.0, 0.0);
		auto n3bsp = NURBSAPIExtend::ExtendCurveToPoint(bsp, true, target);
		shared_ptr<Geom3BSplineCurve> bspCurve = NURBSAPIConvert::ToBSpline(n3bsp);
		CHECK(bspCurve->Degree() == degree);
		CHECK(bspCurve->NPoles() == pNum);
		CHECK(bspCurve->NKnots() == kNum);
		double fp1 = n3bsp->FirstParameter();
		double lp1 = n3bsp->LastParameter();
		Point3 p1 = n3bsp->Value(fp1);
		Point3 p2 = n3bsp->Value(lp1);
		CHECK(abs(p1.X() - target.X()) <= distTol);
		CHECK(abs(p1.Y() - target.Y()) <= distTol);
		CHECK(abs(p1.Z() - target.Z()) <= distTol);
		CHECK(p2.X() == ep.X());
		CHECK(p2.Y() == ep.Y());
		CHECK(p2.Z() == ep.Z());
		OCCTIO::OCCTTool::Write(MakeVertex(sp), outdir + "sp.brep");
		OCCTIO::OCCTTool::Write(MakeVertex(ep), outdir + "ep.brep");
		OCCTIO::OCCTTool::Write(MakeVertex(p1), outdir + "p1.brep");
		OCCTIO::OCCTTool::Write(MakeVertex(p2), outdir + "p2.brep");
		OCCTIO::OCCTTool::Write(MakeEdge(bsp), outdir + "src.brep");
		OCCTIO::OCCTTool::Write(MakeVertex(target), outdir + "target.brep");
		OCCTIO::OCCTTool::Write(MakeEdge(n3bsp), outdir + "result.brep");
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static std::shared_ptr<Geom3Surface> ExtendSurfToPoint(const std::shared_ptr<Geom3Surface>& surf, bool isU, bool isFront, const Point3& pt)	 @return New surface
	 @param pt Point
	 @param isFront Extend front or back
	 @param isU Extend u or v
	 @param surf Surface
	 The degree of the surface, the size of the extended direction (u or v) knots and poles are not changed.
	 The original surface is part of new surface.
	 @brief Extend surface to a point.
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <nurbs/NURBSAPIExtend.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeFace.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/Geom3Plane.hpp>
#include <geometry/Geom3TrimmedSurface.hpp>
#include <nurbs/NURBSAPIConvert.hpp>
#include <nurbs/NURBSAPIBuildCurve.hpp>
#include <geomAlgo/LawBSpline.hpp>
#include <offset/MakePipe.hpp>
#include <modeling/MakeWire.hpp>
#include <topology/TopoTool.hpp>
#include <topology/TopoExplorerTool.hpp>
#include <geometry/GeomAPIProjectPointOnCurve3.hpp>
#include <geometry/GeomAPIProjectPointOnSurface.hpp>
double NurbsExtendSample(int num, double len, double tol, const shared_ptr<Geom3Curve>& curve1, const shared_ptr<Geom3Curve>& curve2)
{
	const int nsample = num;
	double fp1 = curve1->FirstParameter();
	double lp1 = curve1->LastParameter();
	double delta1 = (lp1 - fp1) / nsample;
	Point3 p;
	int n = 0;
	for (int i = 0; i < nsample; i++)
	{
		double t1 = fp1 + i * delta1;
		curve1->D0(t1, p);
		TopoVertex vt = MakeVertex(p);
		TopoEdge edge = MakeEdge(curve2);
		BRepExtremaDistShapeShape dist(vt, edge);
		double dis = abs(dist.Value() - len);
		if (dis <= tol)
		{
			n++;
		}
	}
	double res = 1.0 * (num - n) / num;
	return res;
}
shared_ptr<Geom3Surface> ConstructExtendSurface()
{
	std::vector<Point3> profilePoles;
	std::vector<double> profileKnots(3);
	std::vector<int> profileMults(3, 1);
	profilePoles.push_back(Point3(0.0, 0.0, 0.0));
	profilePoles.push_back(Point3(1.0, -0.2, 0.0));
	profilePoles.push_back(Point3(2.0, 0.1, 0.0));
	profilePoles.push_back(Point3(2.3, -0.1, 0.0));
	profilePoles.push_back(Point3(2.9, 0.1, 0.0));
	profileKnots[0] = 0;
	profileKnots[1] = 0.5;
	profileKnots[2] = 1;
	profileMults.front() = 4;
	profileMults.back() = 4;
	std::shared_ptr<Geom3BSplineCurve> profile = std::make_shared<Geom3BSplineCurve>(profilePoles, profileKnots, profileMults, 3);
	std::vector<Point3> spinePoles;
	std::vector<double> spineKnots(4);
	std::vector<int> spineMults(4, 1);
	spinePoles.push_back(Point3(0.0, 0.0, 0.0));
	spinePoles.push_back(Point3(0.0, 0.0, 1.0));
	spinePoles.push_back(Point3(0.0, 0.2, 1.5));
	spinePoles.push_back(Point3(0.0, 0.5, 2.0));
	spinePoles.push_back(Point3(0.0, 1.0, 2.3));
	spinePoles.push_back(Point3(0.0, 1.6, 2.3));
	spineKnots[0] = 0;
	spineKnots[1] = 1.0 / 3.0;
	spineKnots[2] = 2.0 / 3.0;
	spineKnots[3] = 1;
	spineMults.front() = 4;
	spineMults.back() = 4;
	std::shared_ptr<Geom3BSplineCurve> spine = std::make_shared<Geom3BSplineCurve>(spinePoles, spineKnots, spineMults, 3);
	TopoShape pipe = MakePipe(MakeWire(MakeEdge(spine)), MakeWire(MakeEdge(profile))).Shape();
	TopoExplorer ex(pipe, ShapeType::Face);
	std::shared_ptr<Geom3Surface> surface = TopoTool::Surface(static_cast<const TopoFace&>(ex.Current()));
	return surface;
}
shared_ptr<Geom3Surface> ConstructExtendPeriodicSurf()
{
	std::vector<Point3> profilePoles;
	profilePoles.push_back(Point3(0.0, 0.0, 0.0));
	profilePoles.push_back(Point3(1.0, -1.0, 0.0));
	profilePoles.push_back(Point3(2.0, -1.5, 0.0));
	profilePoles.push_back(Point3(2.3, -1.0, 0.0));
	profilePoles.push_back(Point3(2.9, 0.0, 0.0));
	profilePoles.push_back(Point3(2.3, 0.9, 0.0));
	profilePoles.push_back(Point3(2.1, 1.6, 0.0));
	profilePoles.push_back(Point3(1.0, 1.0, 0.0));
	std::vector<double> profileKnots(profilePoles.size() + 1);
	for (int i = 0; i < static_cast<int>(profileKnots.size()); i++)
	{
		profileKnots[i] = (double)i / (double)(profilePoles.size());
	}
	profileKnots[1] += 1.0 / (double)(3 * profilePoles.size());
	std::vector<int> profileMults(profileKnots.size(), 1);
	std::shared_ptr<Geom3BSplineCurve> profile = std::make_shared<Geom3BSplineCurve>(profilePoles, profileKnots, profileMults, 3, true);
	std::vector<Point3> spinePoles;
	std::vector<double> spineKnots(4);
	std::vector<int> spineMults(4, 1);
	spinePoles.push_back(Point3(0.0, 0.0, 0.0));
	spinePoles.push_back(Point3(0.0, 0.0, 1.0));
	spinePoles.push_back(Point3(0.0, 0.2, 1.5));
	spinePoles.push_back(Point3(0.0, 0.5, 2.0));
	spinePoles.push_back(Point3(0.0, 1.0, 2.3));
	spinePoles.push_back(Point3(0.0, 1.6, 2.3));
	spineKnots[0] = 0;
	spineKnots[1] = 1.0 / 3.0;
	spineKnots[2] = 2.0 / 3.0;
	spineKnots[3] = 1;
	spineMults.front() = 4;
	spineMults.back() = 4;
	std::shared_ptr<Geom3BSplineCurve> spine = std::make_shared<Geom3BSplineCurve>(spinePoles, spineKnots, spineMults, 3);
	TopoShape pipe = MakePipe(MakeWire(MakeEdge(spine)), MakeWire(MakeEdge(profile))).Shape();
	TopoExplorer ex(pipe, ShapeType::Face);
	std::shared_ptr<Geom3Surface> surface = TopoTool::Surface(static_cast<const TopoFace&>(ex.Current()));
	return surface;
}
TEST_CASE("bug2:ExtendPeriodicSurf ", "[nurbs][Extend][fixbug]")
{
	OUTPUT_DIRECTORY(nurbs, Extend/bug612);
	int num = 1000;
	double tol = 1e-4;
	double ratio = 0.01;
	double refTol = DEFAULT_TOLERANCE;
	std::vector<Point3> profilePoles;
	profilePoles.push_back(Point3(0.0, 0.0, 0.0));
	profilePoles.push_back(Point3(1.0, -1.0, 0.0));
	profilePoles.push_back(Point3(2.0, -1.5, 0.0));
	profilePoles.push_back(Point3(2.3, -1.0, 0.0));
	profilePoles.push_back(Point3(2.9, 0.0, 0.0));
	profilePoles.push_back(Point3(2.3, 0.9, 0.0));
	profilePoles.push_back(Point3(2.1, 1.6, 0.0));
	profilePoles.push_back(Point3(1.0, 1.0, 0.0));
	std::vector<double> profileKnots(profilePoles.size() + 1);
	for (int i = 0; i < static_cast<int>(profileKnots.size()); i++)
	{
		profileKnots[i] = (double)i / (double)(profilePoles.size());
	}
	profileKnots[1] += 1.0 / (double)(3 * profilePoles.size());
	std::vector<int> profileMults(profileKnots.size(), 1);
	std::shared_ptr<Geom3BSplineCurve> profile = std::make_shared<Geom3BSplineCurve>(profilePoles, profileKnots, profileMults, 3, true);
	std::vector<Point3> spinePoles;
	std::vector<double> spineKnots(4);
	std::vector<int> spineMults(4, 1);
	spinePoles.push_back(Point3(0.0, 0.0, 0.0));
	spinePoles.push_back(Point3(0.0, 0.0, 1.0));
	spinePoles.push_back(Point3(0.0, 0.2, 1.5));
	spinePoles.push_back(Point3(0.0, 0.5, 2.0));
	spinePoles.push_back(Point3(0.0, 1.0, 2.3));
	spinePoles.push_back(Point3(0.0, 1.6, 2.3));
	spineKnots[0] = 0;
	spineKnots[1] = 1.0 / 3.0;
	spineKnots[2] = 2.0 / 3.0;
	spineKnots[3] = 1;
	spineMults.front() = 4;
	spineMults.back() = 4;
	std::shared_ptr<Geom3BSplineCurve> spine = std::make_shared<Geom3BSplineCurve>(spinePoles, spineKnots, spineMults, 3);
	TopoShape pipe = MakePipe(MakeWire(MakeEdge(spine)), MakeWire(MakeEdge(profile))).Shape();
	TopoExplorer ex(pipe, ShapeType::Face);
	std::shared_ptr<Geom3Surface> surface = TopoTool::Surface(static_cast<const TopoFace&>(ex.Current()));
	shared_ptr<Geom3BSplineSurface> bspSurf = NURBSAPIConvert::ToBSpline(surface);
	int udeg = bspSurf->UDegree();
	int vdeg = bspSurf->VDegree();
	int upNum = bspSurf->NUPoles();
	int vpNum = bspSurf->NVPoles();
	int ukNum = bspSurf->NUKnots();
	int vkNum = bspSurf->NVKnots();
	double fpu = surface->FirstUParameter();
	double fpv = surface->FirstVParameter();
	double lpu = surface->LastUParameter();
	double lpv = surface->LastVParameter();
	shared_ptr<Geom3Curve> fu = surface->UIso(fpu);
	shared_ptr<Geom3Curve> fv = surface->VIso(fpv);
	shared_ptr<Geom3Curve> lu = surface->UIso(lpu);
	shared_ptr<Geom3Curve> lv = surface->VIso(lpv);
	auto plane = std::make_shared<Geom3Plane>(Point3(0.0, 0.0, -5.3), Direction3(0.0, 0.0, 1.0));
	auto planevf = NURBSAPIExtend::ExtendSurfPerpendicularToPlane(surface, false, true, plane);
	shared_ptr<Geom3TrimmedSurface>trimSurf = std::make_shared<Geom3TrimmedSurface>(plane, -10.0, 10.0, -10.0, 10.0);
	shared_ptr<Geom3BSplineSurface> bspSurf2 = NURBSAPIConvert::ToBSpline(planevf);
	CHECK(bspSurf2->UDegree() == udeg);
	CHECK(bspSurf2->VDegree() == vdeg);
	CHECK(bspSurf2->NUPoles() == upNum);
	CHECK(bspSurf2->NVPoles() == (vpNum + 1));
	CHECK(bspSurf2->NUKnots() == ukNum);
	CHECK(bspSurf2->NVKnots() == (vkNum + 1));
	double fpv2 = planevf->FirstVParameter();
	shared_ptr<Geom3Curve> fv2 = planevf->VIso(fpv2);
	bool res2 = IsCurveOnSurf(num, ratio, fv2, plane, -1.0);
	CHECK(res2 == true);
	OCCTIO::OCCTTool::Write(MakeFace(trimSurf, 0.0), outdir + "trimSurf.brep");
	OCCTIO::OCCTTool::Write(MakeFace(surface, 0.0), outdir + "src.brep");
	OCCTIO::OCCTTool::Write(MakeFace(planevf, 0.0), outdir + "result.brep");
;
	SECTION("ExtendSurfToPoint3")
	{
		OUTPUT_DIRECTORY(nurbs, Extend/bug614/ExtendSurfToPoint3);
		Point3 target(1.0, -0.2, -0.2);
		auto pointvf = NURBSAPIExtend::ExtendSurfToPoint(surface, false, true, target);
		shared_ptr<Geom3BSplineSurface> bspSurf2 = NURBSAPIConvert::ToBSpline(pointvf);
		CHECK(bspSurf2->VDegree() == vdeg);
		CHECK(bspSurf2->NVPoles() == vpNum);
		CHECK(bspSurf2->NVKnots() == vkNum);
		double fpv1 = pointvf->FirstVParameter();
		shared_ptr<Geom3Curve> fv1 = pointvf->VIso(fpv1);
		OCCTIO::OCCTTool::Write(MakeEdge(fv), outdir + "curve1.brep");
		OCCTIO::OCCTTool::Write(MakeEdge(fv1), outdir + "curve2.brep");
		OCCTIO::OCCTTool::Write(MakeVertex(target), outdir + "refp.brep");
		OCCTIO::OCCTTool::Write(MakeFace(surface, 0.0), outdir + "src.brep");
		OCCTIO::OCCTTool::Write(MakeFace(pointvf, 0.0), outdir + "result.brep");
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static std::shared_ptr<Geom3Surface> ExtendSurfByAverageLength(const std::shared_ptr<Geom3Surface>& surf, bool isExtendU, bool isFront, double averageLength, double tol = 1e-3)	 @return New surface
	 @param tol The tolerance
	 @param averageLength The average extend length
	 @param isFront Extend front or back
	 @param isExtendU Extend u direction or v direction
	 @param surf Surface
	 If new patch needed, refer to GeometryTool.
	 The degree and the number of poles and knots are not changed.
	 The original surface is part of new surface.
	 @brief Extend surface with specified average 3D length.
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <nurbs/NURBSAPIExtend.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeFace.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/Geom3Plane.hpp>
#include <geometry/Geom3TrimmedSurface.hpp>
#include <nurbs/NURBSAPIConvert.hpp>
#include <nurbs/NURBSAPIBuildCurve.hpp>
#include <geomAlgo/LawBSpline.hpp>
#include <offset/MakePipe.hpp>
#include <modeling/MakeWire.hpp>
#include <topology/TopoTool.hpp>
#include <topology/TopoExplorerTool.hpp>
#include <geometry/GeomAPIProjectPointOnCurve3.hpp>
#include <geometry/GeomAPIProjectPointOnSurface.hpp>
double NurbsExtendSample(int num, double len, double tol, const shared_ptr<Geom3Curve>& curve1, const shared_ptr<Geom3Curve>& curve2)
{
	const int nsample = num;
	double fp1 = curve1->FirstParameter();
	double lp1 = curve1->LastParameter();
	double delta1 = (lp1 - fp1) / nsample;
	Point3 p;
	int n = 0;
	for (int i = 0; i < nsample; i++)
	{
		double t1 = fp1 + i * delta1;
		curve1->D0(t1, p);
		TopoVertex vt = MakeVertex(p);
		TopoEdge edge = MakeEdge(curve2);
		BRepExtremaDistShapeShape dist(vt, edge);
		double dis = abs(dist.Value() - len);
		if (dis <= tol)
		{
			n++;
		}
	}
	double res = 1.0 * (num - n) / num;
	return res;
}
shared_ptr<Geom3Surface> ConstructExtendSurface()
{
	std::vector<Point3> profilePoles;
	std::vector<double> profileKnots(3);
	std::vector<int> profileMults(3, 1);
	profilePoles.push_back(Point3(0.0, 0.0, 0.0));
	profilePoles.push_back(Point3(1.0, -0.2, 0.0));
	profilePoles.push_back(Point3(2.0, 0.1, 0.0));
	profilePoles.push_back(Point3(2.3, -0.1, 0.0));
	profilePoles.push_back(Point3(2.9, 0.1, 0.0));
	profileKnots[0] = 0;
	profileKnots[1] = 0.5;
	profileKnots[2] = 1;
	profileMults.front() = 4;
	profileMults.back() = 4;
	std::shared_ptr<Geom3BSplineCurve> profile = std::make_shared<Geom3BSplineCurve>(profilePoles, profileKnots, profileMults, 3);
	std::vector<Point3> spinePoles;
	std::vector<double> spineKnots(4);
	std::vector<int> spineMults(4, 1);
	spinePoles.push_back(Point3(0.0, 0.0, 0.0));
	spinePoles.push_back(Point3(0.0, 0.0, 1.0));
	spinePoles.push_back(Point3(0.0, 0.2, 1.5));
	spinePoles.push_back(Point3(0.0, 0.5, 2.0));
	spinePoles.push_back(Point3(0.0, 1.0, 2.3));
	spinePoles.push_back(Point3(0.0, 1.6, 2.3));
	spineKnots[0] = 0;
	spineKnots[1] = 1.0 / 3.0;
	spineKnots[2] = 2.0 / 3.0;
	spineKnots[3] = 1;
	spineMults.front() = 4;
	spineMults.back() = 4;
	std::shared_ptr<Geom3BSplineCurve> spine = std::make_shared<Geom3BSplineCurve>(spinePoles, spineKnots, spineMults, 3);
	TopoShape pipe = MakePipe(MakeWire(MakeEdge(spine)), MakeWire(MakeEdge(profile))).Shape();
	TopoExplorer ex(pipe, ShapeType::Face);
	std::shared_ptr<Geom3Surface> surface = TopoTool::Surface(static_cast<const TopoFace&>(ex.Current()));
	return surface;
}
shared_ptr<Geom3Surface> ConstructExtendPeriodicSurf()
{
	std::vector<Point3> profilePoles;
	profilePoles.push_back(Point3(0.0, 0.0, 0.0));
	profilePoles.push_back(Point3(1.0, -1.0, 0.0));
	profilePoles.push_back(Point3(2.0, -1.5, 0.0));
	profilePoles.push_back(Point3(2.3, -1.0, 0.0));
	profilePoles.push_back(Point3(2.9, 0.0, 0.0));
	profilePoles.push_back(Point3(2.3, 0.9, 0.0));
	profilePoles.push_back(Point3(2.1, 1.6, 0.0));
	profilePoles.push_back(Point3(1.0, 1.0, 0.0));
	std::vector<double> profileKnots(profilePoles.size() + 1);
	for (int i = 0; i < static_cast<int>(profileKnots.size()); i++)
	{
		profileKnots[i] = (double)i / (double)(profilePoles.size());
	}
	profileKnots[1] += 1.0 / (double)(3 * profilePoles.size());
	std::vector<int> profileMults(profileKnots.size(), 1);
	std::shared_ptr<Geom3BSplineCurve> profile = std::make_shared<Geom3BSplineCurve>(profilePoles, profileKnots, profileMults, 3, true);
	std::vector<Point3> spinePoles;
	std::vector<double> spineKnots(4);
	std::vector<int> spineMults(4, 1);
	spinePoles.push_back(Point3(0.0, 0.0, 0.0));
	spinePoles.push_back(Point3(0.0, 0.0, 1.0));
	spinePoles.push_back(Point3(0.0, 0.2, 1.5));
	spinePoles.push_back(Point3(0.0, 0.5, 2.0));
	spinePoles.push_back(Point3(0.0, 1.0, 2.3));
	spinePoles.push_back(Point3(0.0, 1.6, 2.3));
	spineKnots[0] = 0;
	spineKnots[1] = 1.0 / 3.0;
	spineKnots[2] = 2.0 / 3.0;
	spineKnots[3] = 1;
	spineMults.front() = 4;
	spineMults.back() = 4;
	std::shared_ptr<Geom3BSplineCurve> spine = std::make_shared<Geom3BSplineCurve>(spinePoles, spineKnots, spineMults, 3);
	TopoShape pipe = MakePipe(MakeWire(MakeEdge(spine)), MakeWire(MakeEdge(profile))).Shape();
	TopoExplorer ex(pipe, ShapeType::Face);
	std::shared_ptr<Geom3Surface> surface = TopoTool::Surface(static_cast<const TopoFace&>(ex.Current()));
	return surface;
}
TEST_CASE("bug2:ExtendPeriodicSurf ", "[nurbs][Extend][fixbug]")
{
	OUTPUT_DIRECTORY(nurbs, Extend/bug612);
	int num = 1000;
	double tol = 1e-4;
	double ratio = 0.01;
	double refTol = DEFAULT_TOLERANCE;
	std::vector<Point3> profilePoles;
	profilePoles.push_back(Point3(0.0, 0.0, 0.0));
	profilePoles.push_back(Point3(1.0, -1.0, 0.0));
	profilePoles.push_back(Point3(2.0, -1.5, 0.0));
	profilePoles.push_back(Point3(2.3, -1.0, 0.0));
	profilePoles.push_back(Point3(2.9, 0.0, 0.0));
	profilePoles.push_back(Point3(2.3, 0.9, 0.0));
	profilePoles.push_back(Point3(2.1, 1.6, 0.0));
	profilePoles.push_back(Point3(1.0, 1.0, 0.0));
	std::vector<double> profileKnots(profilePoles.size() + 1);
	for (int i = 0; i < static_cast<int>(profileKnots.size()); i++)
	{
		profileKnots[i] = (double)i / (double)(profilePoles.size());
	}
	profileKnots[1] += 1.0 / (double)(3 * profilePoles.size());
	std::vector<int> profileMults(profileKnots.size(), 1);
	std::shared_ptr<Geom3BSplineCurve> profile = std::make_shared<Geom3BSplineCurve>(profilePoles, profileKnots, profileMults, 3, true);
	std::vector<Point3> spinePoles;
	std::vector<double> spineKnots(4);
	std::vector<int> spineMults(4, 1);
	spinePoles.push_back(Point3(0.0, 0.0, 0.0));
	spinePoles.push_back(Point3(0.0, 0.0, 1.0));
	spinePoles.push_back(Point3(0.0, 0.2, 1.5));
	spinePoles.push_back(Point3(0.0, 0.5, 2.0));
	spinePoles.push_back(Point3(0.0, 1.0, 2.3));
	spinePoles.push_back(Point3(0.0, 1.6, 2.3));
	spineKnots[0] = 0;
	spineKnots[1] = 1.0 / 3.0;
	spineKnots[2] = 2.0 / 3.0;
	spineKnots[3] = 1;
	spineMults.front() = 4;
	spineMults.back() = 4;
	std::shared_ptr<Geom3BSplineCurve> spine = std::make_shared<Geom3BSplineCurve>(spinePoles, spineKnots, spineMults, 3);
	TopoShape pipe = MakePipe(MakeWire(MakeEdge(spine)), MakeWire(MakeEdge(profile))).Shape();
	TopoExplorer ex(pipe, ShapeType::Face);
	std::shared_ptr<Geom3Surface> surface = TopoTool::Surface(static_cast<const TopoFace&>(ex.Current()));
	shared_ptr<Geom3BSplineSurface> bspSurf = NURBSAPIConvert::ToBSpline(surface);
	int udeg = bspSurf->UDegree();
	int vdeg = bspSurf->VDegree();
	int upNum = bspSurf->NUPoles();
	int vpNum = bspSurf->NVPoles();
	int ukNum = bspSurf->NUKnots();
	int vkNum = bspSurf->NVKnots();
	double fpu = surface->FirstUParameter();
	double fpv = surface->FirstVParameter();
	double lpu = surface->LastUParameter();
	double lpv = surface->LastVParameter();
	shared_ptr<Geom3Curve> fu = surface->UIso(fpu);
	shared_ptr<Geom3Curve> fv = surface->VIso(fpv);
	shared_ptr<Geom3Curve> lu = surface->UIso(lpu);
	shared_ptr<Geom3Curve> lv = surface->VIso(lpv);
	auto plane = std::make_shared<Geom3Plane>(Point3(0.0, 0.0, -5.3), Direction3(0.0, 0.0, 1.0));
	auto planevf = NURBSAPIExtend::ExtendSurfPerpendicularToPlane(surface, false, true, plane);
	shared_ptr<Geom3TrimmedSurface>trimSurf = std::make_shared<Geom3TrimmedSurface>(plane, -10.0, 10.0, -10.0, 10.0);
	shared_ptr<Geom3BSplineSurface> bspSurf2 = NURBSAPIConvert::ToBSpline(planevf);
	CHECK(bspSurf2->UDegree() == udeg);
	CHECK(bspSurf2->VDegree() == vdeg);
	CHECK(bspSurf2->NUPoles() == upNum);
	CHECK(bspSurf2->NVPoles() == (vpNum + 1));
	CHECK(bspSurf2->NUKnots() == ukNum);
	CHECK(bspSurf2->NVKnots() == (vkNum + 1));
	double fpv2 = planevf->FirstVParameter();
	shared_ptr<Geom3Curve> fv2 = planevf->VIso(fpv2);
	bool res2 = IsCurveOnSurf(num, ratio, fv2, plane, -1.0);
	CHECK(res2 == true);
	OCCTIO::OCCTTool::Write(MakeFace(trimSurf, 0.0), outdir + "trimSurf.brep");
	OCCTIO::OCCTTool::Write(MakeFace(surface, 0.0), outdir + "src.brep");
	OCCTIO::OCCTTool::Write(MakeFace(planevf, 0.0), outdir + "result.brep");
;
	SECTION("ExtendSurfByAverageLength3")
	{
		OUTPUT_DIRECTORY(nurbs, Extend/bug614/ExtendSurfByAverageLength3);
		auto lengthvf = NURBSAPIExtend::ExtendSurfByAverageLength(surface, false, true, len);
		shared_ptr<Geom3BSplineSurface> bspSurf2 = NURBSAPIConvert::ToBSpline(lengthvf);
		CHECK(bspSurf2->VDegree() == vdeg);
		CHECK(bspSurf2->NVPoles() == vpNum);
		CHECK(bspSurf2->NVKnots() == vkNum);
		double fpv1 = lengthvf->FirstVParameter();
		shared_ptr<Geom3Curve> fv1 = lengthvf->VIso(fpv1);
		OCCTIO::OCCTTool::Write(MakeEdge(fv), outdir + "curve1.brep");
		OCCTIO::OCCTTool::Write(MakeEdge(fv1), outdir + "curve2.brep");
		OCCTIO::OCCTTool::Write(MakeFace(surface, 0.0), outdir + "src.brep");
		OCCTIO::OCCTTool::Write(MakeFace(lengthvf, 0.0), outdir + "result.brep");
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static std::shared_ptr<Geom3Curve> ExtendCurveToDynamicPoint(const std::shared_ptr<Geom3Curve>& curve, bool isFront, const Point3& pt)	 @return New curve
	 @param pt Point
	 @param isFront Extend front or back
	 @param curve Curve
	 The degree is not changed but the number of poles and knots increase 1.
	 The original curve is part of new curve.
	 @brief Extend curve to a point.
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <nurbs/NURBSAPIExtend.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeFace.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/Geom3Plane.hpp>
#include <geometry/Geom3TrimmedSurface.hpp>
#include <nurbs/NURBSAPIConvert.hpp>
#include <nurbs/NURBSAPIBuildCurve.hpp>
#include <geomAlgo/LawBSpline.hpp>
#include <offset/MakePipe.hpp>
#include <modeling/MakeWire.hpp>
#include <topology/TopoTool.hpp>
#include <topology/TopoExplorerTool.hpp>
#include <geometry/GeomAPIProjectPointOnCurve3.hpp>
#include <geometry/GeomAPIProjectPointOnSurface.hpp>
double NurbsExtendSample2(int num, double len, double tol, const shared_ptr<Geom3Curve>& curve1, const shared_ptr<Geom3Curve>& curve2)
{
	const int nsample = num;
	double fp1 = curve1->FirstParameter();
	double lp1 = curve1->LastParameter();
	double delta1 = (lp1 - fp1) / nsample;
	Point3 p;
	int n = 0;
	for (int i = 0; i < nsample; i++)
	{
		double t1 = fp1 + i * delta1;
		curve1->D0(t1, p);
		TopoVertex vt = MakeVertex(p);
		TopoEdge edge = MakeEdge(curve2);
		BRepExtremaDistShapeShape dist(vt, edge);
		double dis = abs(dist.Value() - len);
		if (dis <= tol)
		{
			n++;
		}
	}
	double res = 1.0 * (num - n) / num;
	return res;
}
shared_ptr<Geom3Surface> ConstructExtendSurface2()
{
	std::vector<Point3> profilePoles;
	std::vector<double> profileKnots(3);
	std::vector<int> profileMults(3, 1);
	profilePoles.push_back(Point3(0.0, 0.0, 0.0));
	profilePoles.push_back(Point3(1.0, -0.2, 0.0));
	profilePoles.push_back(Point3(2.0, 0.1, 0.0));
	profilePoles.push_back(Point3(2.3, -0.1, 0.0));
	profilePoles.push_back(Point3(2.9, 0.1, 0.0));
	profileKnots[0] = 0;
	profileKnots[1] = 0.5;
	profileKnots[2] = 1;
	profileMults.front() = 4;
	profileMults.back() = 4;
	std::shared_ptr<Geom3BSplineCurve> profile = std::make_shared<Geom3BSplineCurve>(profilePoles, profileKnots, profileMults, 3);
	std::vector<Point3> spinePoles;
	std::vector<double> spineKnots(4);
	std::vector<int> spineMults(4, 1);
	spinePoles.push_back(Point3(0.0, 0.0, 0.0));
	spinePoles.push_back(Point3(0.0, 0.0, 1.0));
	spinePoles.push_back(Point3(0.0, 0.2, 1.5));
	spinePoles.push_back(Point3(0.0, 0.5, 2.0));
	spinePoles.push_back(Point3(0.0, 1.0, 2.3));
	spinePoles.push_back(Point3(0.0, 1.6, 2.3));
	spineKnots[0] = 0;
	spineKnots[1] = 1.0 / 3.0;
	spineKnots[2] = 2.0 / 3.0;
	spineKnots[3] = 1;
	spineMults.front() = 4;
	spineMults.back() = 4;
	std::shared_ptr<Geom3BSplineCurve> spine = std::make_shared<Geom3BSplineCurve>(spinePoles, spineKnots, spineMults, 3);
	TopoShape pipe = MakePipe(MakeWire(MakeEdge(spine)), MakeWire(MakeEdge(profile))).Shape();
	TopoExplorer ex(pipe, ShapeType::Face);
	std::shared_ptr<Geom3Surface> surface = TopoTool::Surface(static_cast<const TopoFace&>(ex.Current()));
	return surface;
}
#include<catch.hpp>
#include<testHelper.h>
#include <nurbs/NURBSAPIExtend.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeFace.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/Geom3Plane.hpp>
#include <geometry/Geom3TrimmedSurface.hpp>
#include <nurbs/NURBSAPIConvert.hpp>
#include <nurbs/NURBSAPIBuildCurve.hpp>
#include <geomAlgo/LawBSpline.hpp>
#include <offset/MakePipe.hpp>
#include <modeling/MakeWire.hpp>
#include <topology/TopoTool.hpp>
#include <topology/TopoExplorerTool.hpp>
#include <geometry/GeomAPIProjectPointOnCurve3.hpp>
#include <geometry/GeomAPIProjectPointOnSurface.hpp>
double NurbsExtendSample2(int num, double len, double tol, const shared_ptr<Geom3Curve>& curve1, const shared_ptr<Geom3Curve>& curve2)
{
	const int nsample = num;
	double fp1 = curve1->FirstParameter();
	double lp1 = curve1->LastParameter();
	double delta1 = (lp1 - fp1) / nsample;
	Point3 p;
	int n = 0;
	for (int i = 0; i < nsample; i++)
	{
		double t1 = fp1 + i * delta1;
		curve1->D0(t1, p);
		TopoVertex vt = MakeVertex(p);
		TopoEdge edge = MakeEdge(curve2);
		BRepExtremaDistShapeShape dist(vt, edge);
		double dis = abs(dist.Value() - len);
		if (dis <= tol)
		{
			n++;
		}
	}
	double res = 1.0 * (num - n) / num;
	return res;
}
shared_ptr<Geom3Surface> ConstructExtendSurface2()
{
	std::vector<Point3> profilePoles;
	std::vector<double> profileKnots(3);
	std::vector<int> profileMults(3, 1);
	profilePoles.push_back(Point3(0.0, 0.0, 0.0));
	profilePoles.push_back(Point3(1.0, -0.2, 0.0));
	profilePoles.push_back(Point3(2.0, 0.1, 0.0));
	profilePoles.push_back(Point3(2.3, -0.1, 0.0));
	profilePoles.push_back(Point3(2.9, 0.1, 0.0));
	profileKnots[0] = 0;
	profileKnots[1] = 0.5;
	profileKnots[2] = 1;
	profileMults.front() = 4;
	profileMults.back() = 4;
	std::shared_ptr<Geom3BSplineCurve> profile = std::make_shared<Geom3BSplineCurve>(profilePoles, profileKnots, profileMults, 3);
	std::vector<Point3> spinePoles;
	std::vector<double> spineKnots(4);
	std::vector<int> spineMults(4, 1);
	spinePoles.push_back(Point3(0.0, 0.0, 0.0));
	spinePoles.push_back(Point3(0.0, 0.0, 1.0));
	spinePoles.push_back(Point3(0.0, 0.2, 1.5));
	spinePoles.push_back(Point3(0.0, 0.5, 2.0));
	spinePoles.push_back(Point3(0.0, 1.0, 2.3));
	spinePoles.push_back(Point3(0.0, 1.6, 2.3));
	spineKnots[0] = 0;
	spineKnots[1] = 1.0 / 3.0;
	spineKnots[2] = 2.0 / 3.0;
	spineKnots[3] = 1;
	spineMults.front() = 4;
	spineMults.back() = 4;
	std::shared_ptr<Geom3BSplineCurve> spine = std::make_shared<Geom3BSplineCurve>(spinePoles, spineKnots, spineMults, 3);
	TopoShape pipe = MakePipe(MakeWire(MakeEdge(spine)), MakeWire(MakeEdge(profile))).Shape();
	TopoExplorer ex(pipe, ShapeType::Face);
	std::shared_ptr<Geom3Surface> surface = TopoTool::Surface(static_cast<const TopoFace&>(ex.Current()));
	return surface;
;
	SECTION("TestExtendDynamic")
	{
		OUTPUT_DIRECTORY(nurbs, Extend/bug747/ExtendCurveDynamic/ExtendDynamic);
		int num = 1000;
		double ratio = 0.1;
		double refTol = DEFAULT_TOLERANCE;
		int refDeg = INCREASE_DEGREE;
		auto src1 = ReadBRepCurve(INPUT_PATH_PREFIX"/TestNURBS/TestExtendDynamic/src1.brep");
		auto targetPoint1 = ReadBRepPoint(INPUT_PATH_PREFIX"/TestNURBS/TestExtendDynamic/target1.brep");
		LawBSpline srcw1(src1->Weights(), src1->Knots(), src1->Multiplicities(), src1->Degree(), src1->IsPeriodic());
		double src1weight, rhi1weight, src2weight, rhi2weight, src1dw, rhi1dw, src2dw, rhi2dw, src1dw2, rhi1dw2, src2dw2, rhi2dw2;
		double t1 = src1->LastParameter() - 0.01;
		srcw1.D2(t1, src1weight, src1dw, src1dw2);
		int degree1 = src1->Degree();
		int pNum1 = src1->NPoles();
		int kNum1 = src1->NKnots();
		double f1 = src1->FirstParameter();
		double l1 = src1->LastParameter();
		Point3 sp1 = src1->Value(f1);
		Point3 ep1 = src1->Value(l1);
		shared_ptr<Geom3BSplineCurve> src1Inc = std::dynamic_pointer_cast<Geom3BSplineCurve>(src1->Copy());
		src1Inc->IncreaseDegree(refDeg);
		auto extended1 = NURBSAPIExtend::ExtendCurveToDynamicPoint(src1, false, targetPoint1);
		double fp1 = extended1->FirstParameter();
		double lp1 = extended1->LastParameter();
		Point3 p1 = extended1->Value(fp1);
		Point3 p2 = extended1->Value(lp1);
		auto extended1Inc = NURBSAPIExtend::ExtendCurveToDynamicPoint(src1Inc, false, targetPoint1);
		shared_ptr<Geom3BSplineCurve> bspCurve1Inc = NURBSAPIConvert::ToBSpline(extended1Inc);
		CHECK(bspCurve1Inc->Degree() == refDeg);
		CHECK(bspCurve1Inc->NKnots() == (kNum1 + 1));
		double fp1Inc = extended1Inc->FirstParameter();
		double lp1Inc = extended1Inc->LastParameter();
		Point3 p1Inc = extended1Inc->Value(fp1Inc);
		Point3 p2Inc = extended1Inc->Value(lp1Inc);
		CHECK(p1Inc.X() == Approx(sp1.X()));
		CHECK(p1Inc.Y() == Approx(sp1.Y()));
		CHECK(p1Inc.Z() == Approx(sp1.Z()));
		CHECK(p2Inc.X() == Approx(targetPoint1.X()));
		CHECK(p2Inc.Y() == Approx(targetPoint1.Y()));
		CHECK(p2Inc.Z() == Approx(targetPoint1.Z()));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static std::shared_ptr<Geom3Surface> ExtendSurfToPoint(const std::shared_ptr<Geom3Surface>& surf, bool isU, bool isFront, const Point3& pt)	 @return New surface
	 @param pt Point
	 @param isFront Extend front or back
	 @param isU Extend u or v
	 @param surf Surface
	 The degree of the surface, the size of the extended direction (u or v) knots and poles are not changed.
	 The original surface is part of new surface.
	 @brief Extend surface to a point.
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <nurbs/NURBSAPIExtend.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeFace.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/Geom3Plane.hpp>
#include <geometry/Geom3TrimmedSurface.hpp>
#include <nurbs/NURBSAPIConvert.hpp>
#include <nurbs/NURBSAPIBuildCurve.hpp>
#include <geomAlgo/LawBSpline.hpp>
#include <offset/MakePipe.hpp>
#include <modeling/MakeWire.hpp>
#include <topology/TopoTool.hpp>
#include <topology/TopoExplorerTool.hpp>
#include <geometry/GeomAPIProjectPointOnCurve3.hpp>
#include <geometry/GeomAPIProjectPointOnSurface.hpp>
double NurbsExtendSample2(int num, double len, double tol, const shared_ptr<Geom3Curve>& curve1, const shared_ptr<Geom3Curve>& curve2)
{
	const int nsample = num;
	double fp1 = curve1->FirstParameter();
	double lp1 = curve1->LastParameter();
	double delta1 = (lp1 - fp1) / nsample;
	Point3 p;
	int n = 0;
	for (int i = 0; i < nsample; i++)
	{
		double t1 = fp1 + i * delta1;
		curve1->D0(t1, p);
		TopoVertex vt = MakeVertex(p);
		TopoEdge edge = MakeEdge(curve2);
		BRepExtremaDistShapeShape dist(vt, edge);
		double dis = abs(dist.Value() - len);
		if (dis <= tol)
		{
			n++;
		}
	}
	double res = 1.0 * (num - n) / num;
	return res;
}
shared_ptr<Geom3Surface> ConstructExtendSurface2()
{
	std::vector<Point3> profilePoles;
	std::vector<double> profileKnots(3);
	std::vector<int> profileMults(3, 1);
	profilePoles.push_back(Point3(0.0, 0.0, 0.0));
	profilePoles.push_back(Point3(1.0, -0.2, 0.0));
	profilePoles.push_back(Point3(2.0, 0.1, 0.0));
	profilePoles.push_back(Point3(2.3, -0.1, 0.0));
	profilePoles.push_back(Point3(2.9, 0.1, 0.0));
	profileKnots[0] = 0;
	profileKnots[1] = 0.5;
	profileKnots[2] = 1;
	profileMults.front() = 4;
	profileMults.back() = 4;
	std::shared_ptr<Geom3BSplineCurve> profile = std::make_shared<Geom3BSplineCurve>(profilePoles, profileKnots, profileMults, 3);
	std::vector<Point3> spinePoles;
	std::vector<double> spineKnots(4);
	std::vector<int> spineMults(4, 1);
	spinePoles.push_back(Point3(0.0, 0.0, 0.0));
	spinePoles.push_back(Point3(0.0, 0.0, 1.0));
	spinePoles.push_back(Point3(0.0, 0.2, 1.5));
	spinePoles.push_back(Point3(0.0, 0.5, 2.0));
	spinePoles.push_back(Point3(0.0, 1.0, 2.3));
	spinePoles.push_back(Point3(0.0, 1.6, 2.3));
	spineKnots[0] = 0;
	spineKnots[1] = 1.0 / 3.0;
	spineKnots[2] = 2.0 / 3.0;
	spineKnots[3] = 1;
	spineMults.front() = 4;
	spineMults.back() = 4;
	std::shared_ptr<Geom3BSplineCurve> spine = std::make_shared<Geom3BSplineCurve>(spinePoles, spineKnots, spineMults, 3);
	TopoShape pipe = MakePipe(MakeWire(MakeEdge(spine)), MakeWire(MakeEdge(profile))).Shape();
	TopoExplorer ex(pipe, ShapeType::Face);
	std::shared_ptr<Geom3Surface> surface = TopoTool::Surface(static_cast<const TopoFace&>(ex.Current()));
	return surface;
}
#include<catch.hpp>
#include<testHelper.h>
#include <nurbs/NURBSAPIExtend.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeFace.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/Geom3Plane.hpp>
#include <geometry/Geom3TrimmedSurface.hpp>
#include <nurbs/NURBSAPIConvert.hpp>
#include <nurbs/NURBSAPIBuildCurve.hpp>
#include <geomAlgo/LawBSpline.hpp>
#include <offset/MakePipe.hpp>
#include <modeling/MakeWire.hpp>
#include <topology/TopoTool.hpp>
#include <topology/TopoExplorerTool.hpp>
#include <geometry/GeomAPIProjectPointOnCurve3.hpp>
#include <geometry/GeomAPIProjectPointOnSurface.hpp>
double NurbsExtendSample2(int num, double len, double tol, const shared_ptr<Geom3Curve>& curve1, const shared_ptr<Geom3Curve>& curve2)
{
	const int nsample = num;
	double fp1 = curve1->FirstParameter();
	double lp1 = curve1->LastParameter();
	double delta1 = (lp1 - fp1) / nsample;
	Point3 p;
	int n = 0;
	for (int i = 0; i < nsample; i++)
	{
		double t1 = fp1 + i * delta1;
		curve1->D0(t1, p);
		TopoVertex vt = MakeVertex(p);
		TopoEdge edge = MakeEdge(curve2);
		BRepExtremaDistShapeShape dist(vt, edge);
		double dis = abs(dist.Value() - len);
		if (dis <= tol)
		{
			n++;
		}
	}
	double res = 1.0 * (num - n) / num;
	return res;
}
shared_ptr<Geom3Surface> ConstructExtendSurface2()
{
	std::vector<Point3> profilePoles;
	std::vector<double> profileKnots(3);
	std::vector<int> profileMults(3, 1);
	profilePoles.push_back(Point3(0.0, 0.0, 0.0));
	profilePoles.push_back(Point3(1.0, -0.2, 0.0));
	profilePoles.push_back(Point3(2.0, 0.1, 0.0));
	profilePoles.push_back(Point3(2.3, -0.1, 0.0));
	profilePoles.push_back(Point3(2.9, 0.1, 0.0));
	profileKnots[0] = 0;
	profileKnots[1] = 0.5;
	profileKnots[2] = 1;
	profileMults.front() = 4;
	profileMults.back() = 4;
	std::shared_ptr<Geom3BSplineCurve> profile = std::make_shared<Geom3BSplineCurve>(profilePoles, profileKnots, profileMults, 3);
	std::vector<Point3> spinePoles;
	std::vector<double> spineKnots(4);
	std::vector<int> spineMults(4, 1);
	spinePoles.push_back(Point3(0.0, 0.0, 0.0));
	spinePoles.push_back(Point3(0.0, 0.0, 1.0));
	spinePoles.push_back(Point3(0.0, 0.2, 1.5));
	spinePoles.push_back(Point3(0.0, 0.5, 2.0));
	spinePoles.push_back(Point3(0.0, 1.0, 2.3));
	spinePoles.push_back(Point3(0.0, 1.6, 2.3));
	spineKnots[0] = 0;
	spineKnots[1] = 1.0 / 3.0;
	spineKnots[2] = 2.0 / 3.0;
	spineKnots[3] = 1;
	spineMults.front() = 4;
	spineMults.back() = 4;
	std::shared_ptr<Geom3BSplineCurve> spine = std::make_shared<Geom3BSplineCurve>(spinePoles, spineKnots, spineMults, 3);
	TopoShape pipe = MakePipe(MakeWire(MakeEdge(spine)), MakeWire(MakeEdge(profile))).Shape();
	TopoExplorer ex(pipe, ShapeType::Face);
	std::shared_ptr<Geom3Surface> surface = TopoTool::Surface(static_cast<const TopoFace&>(ex.Current()));
	return surface;
;
	SECTION("ExtendSurfToPoint1")
	{
		OUTPUT_DIRECTORY(nurbs, Extend/ExtendSurf/ExtendSurfToPoint1);
		Point3 target(-1.2, 0.5, 1.0);
		auto pointuf = NURBSAPIExtend::ExtendSurfToPoint(surface, true, true, target);
		shared_ptr<Geom3BSplineSurface> bspSurf2 = NURBSAPIConvert::ToBSpline(pointuf);
		CHECK(bspSurf2->UDegree() == udeg);
		CHECK(bspSurf2->VDegree() == vdeg);
		CHECK(bspSurf2->NUPoles() == upNum);
		CHECK(bspSurf2->NVPoles() == vpNum);
		CHECK(bspSurf2->NUKnots() == ukNum);
		CHECK(bspSurf2->NVKnots() == vkNum);
		GeomAPIProjectPointOnSurface proj(target, pointuf);
		Point3 pp = proj.NearestPoint();
		double fpu2 = pointuf->FirstUParameter();
		shared_ptr<Geom3Curve> fu2 = pointuf->UIso(fpu2);
		TopoEdge edge2 = MakeEdge(fu2);
		bool res1 = BRepClassificationTools::IsPointInOnEdge(edge2, pp, 1e-3);
		CHECK(res1 == true);
		OCCTIO::OCCTTool::Write(MakeVertex(target), outdir + "refp.brep");
		OCCTIO::OCCTTool::Write(MakeEdge(fu), outdir + "fu.brep");
		OCCTIO::OCCTTool::Write(MakeEdge(fu2), outdir + "fu2.brep");
		OCCTIO::OCCTTool::Write(MakeVertex(pp), outdir + "pp.brep");
		OCCTIO::OCCTTool::Write(MakeFace(surface, 0.0), outdir + "src.brep");
		OCCTIO::OCCTTool::Write(MakeFace(pointuf, 0.0), outdir + "result.brep");
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static std::shared_ptr<Geom3Surface> ExtendSurfByAverageLength(const std::shared_ptr<Geom3Surface>& surf, bool isExtendU, bool isFront, double averageLength, double tol = 1e-3)	 @return New surface
	 @param tol The tolerance
	 @param averageLength The average extend length
	 @param isFront Extend front or back
	 @param isExtendU Extend u direction or v direction
	 @param surf Surface
	 If new patch needed, refer to GeometryTool.
	 The degree and the number of poles and knots are not changed.
	 The original surface is part of new surface.
	 @brief Extend surface with specified average 3D length.
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <nurbs/NURBSAPIExtend.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeFace.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/Geom3Plane.hpp>
#include <geometry/Geom3TrimmedSurface.hpp>
#include <nurbs/NURBSAPIConvert.hpp>
#include <nurbs/NURBSAPIBuildCurve.hpp>
#include <geomAlgo/LawBSpline.hpp>
#include <offset/MakePipe.hpp>
#include <modeling/MakeWire.hpp>
#include <topology/TopoTool.hpp>
#include <topology/TopoExplorerTool.hpp>
#include <geometry/GeomAPIProjectPointOnCurve3.hpp>
#include <geometry/GeomAPIProjectPointOnSurface.hpp>
double NurbsExtendSample2(int num, double len, double tol, const shared_ptr<Geom3Curve>& curve1, const shared_ptr<Geom3Curve>& curve2)
{
	const int nsample = num;
	double fp1 = curve1->FirstParameter();
	double lp1 = curve1->LastParameter();
	double delta1 = (lp1 - fp1) / nsample;
	Point3 p;
	int n = 0;
	for (int i = 0; i < nsample; i++)
	{
		double t1 = fp1 + i * delta1;
		curve1->D0(t1, p);
		TopoVertex vt = MakeVertex(p);
		TopoEdge edge = MakeEdge(curve2);
		BRepExtremaDistShapeShape dist(vt, edge);
		double dis = abs(dist.Value() - len);
		if (dis <= tol)
		{
			n++;
		}
	}
	double res = 1.0 * (num - n) / num;
	return res;
}
shared_ptr<Geom3Surface> ConstructExtendSurface2()
{
	std::vector<Point3> profilePoles;
	std::vector<double> profileKnots(3);
	std::vector<int> profileMults(3, 1);
	profilePoles.push_back(Point3(0.0, 0.0, 0.0));
	profilePoles.push_back(Point3(1.0, -0.2, 0.0));
	profilePoles.push_back(Point3(2.0, 0.1, 0.0));
	profilePoles.push_back(Point3(2.3, -0.1, 0.0));
	profilePoles.push_back(Point3(2.9, 0.1, 0.0));
	profileKnots[0] = 0;
	profileKnots[1] = 0.5;
	profileKnots[2] = 1;
	profileMults.front() = 4;
	profileMults.back() = 4;
	std::shared_ptr<Geom3BSplineCurve> profile = std::make_shared<Geom3BSplineCurve>(profilePoles, profileKnots, profileMults, 3);
	std::vector<Point3> spinePoles;
	std::vector<double> spineKnots(4);
	std::vector<int> spineMults(4, 1);
	spinePoles.push_back(Point3(0.0, 0.0, 0.0));
	spinePoles.push_back(Point3(0.0, 0.0, 1.0));
	spinePoles.push_back(Point3(0.0, 0.2, 1.5));
	spinePoles.push_back(Point3(0.0, 0.5, 2.0));
	spinePoles.push_back(Point3(0.0, 1.0, 2.3));
	spinePoles.push_back(Point3(0.0, 1.6, 2.3));
	spineKnots[0] = 0;
	spineKnots[1] = 1.0 / 3.0;
	spineKnots[2] = 2.0 / 3.0;
	spineKnots[3] = 1;
	spineMults.front() = 4;
	spineMults.back() = 4;
	std::shared_ptr<Geom3BSplineCurve> spine = std::make_shared<Geom3BSplineCurve>(spinePoles, spineKnots, spineMults, 3);
	TopoShape pipe = MakePipe(MakeWire(MakeEdge(spine)), MakeWire(MakeEdge(profile))).Shape();
	TopoExplorer ex(pipe, ShapeType::Face);
	std::shared_ptr<Geom3Surface> surface = TopoTool::Surface(static_cast<const TopoFace&>(ex.Current()));
	return surface;
}
#include<catch.hpp>
#include<testHelper.h>
#include <nurbs/NURBSAPIExtend.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeFace.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/Geom3Plane.hpp>
#include <geometry/Geom3TrimmedSurface.hpp>
#include <nurbs/NURBSAPIConvert.hpp>
#include <nurbs/NURBSAPIBuildCurve.hpp>
#include <geomAlgo/LawBSpline.hpp>
#include <offset/MakePipe.hpp>
#include <modeling/MakeWire.hpp>
#include <topology/TopoTool.hpp>
#include <topology/TopoExplorerTool.hpp>
#include <geometry/GeomAPIProjectPointOnCurve3.hpp>
#include <geometry/GeomAPIProjectPointOnSurface.hpp>
double NurbsExtendSample2(int num, double len, double tol, const shared_ptr<Geom3Curve>& curve1, const shared_ptr<Geom3Curve>& curve2)
{
	const int nsample = num;
	double fp1 = curve1->FirstParameter();
	double lp1 = curve1->LastParameter();
	double delta1 = (lp1 - fp1) / nsample;
	Point3 p;
	int n = 0;
	for (int i = 0; i < nsample; i++)
	{
		double t1 = fp1 + i * delta1;
		curve1->D0(t1, p);
		TopoVertex vt = MakeVertex(p);
		TopoEdge edge = MakeEdge(curve2);
		BRepExtremaDistShapeShape dist(vt, edge);
		double dis = abs(dist.Value() - len);
		if (dis <= tol)
		{
			n++;
		}
	}
	double res = 1.0 * (num - n) / num;
	return res;
}
shared_ptr<Geom3Surface> ConstructExtendSurface2()
{
	std::vector<Point3> profilePoles;
	std::vector<double> profileKnots(3);
	std::vector<int> profileMults(3, 1);
	profilePoles.push_back(Point3(0.0, 0.0, 0.0));
	profilePoles.push_back(Point3(1.0, -0.2, 0.0));
	profilePoles.push_back(Point3(2.0, 0.1, 0.0));
	profilePoles.push_back(Point3(2.3, -0.1, 0.0));
	profilePoles.push_back(Point3(2.9, 0.1, 0.0));
	profileKnots[0] = 0;
	profileKnots[1] = 0.5;
	profileKnots[2] = 1;
	profileMults.front() = 4;
	profileMults.back() = 4;
	std::shared_ptr<Geom3BSplineCurve> profile = std::make_shared<Geom3BSplineCurve>(profilePoles, profileKnots, profileMults, 3);
	std::vector<Point3> spinePoles;
	std::vector<double> spineKnots(4);
	std::vector<int> spineMults(4, 1);
	spinePoles.push_back(Point3(0.0, 0.0, 0.0));
	spinePoles.push_back(Point3(0.0, 0.0, 1.0));
	spinePoles.push_back(Point3(0.0, 0.2, 1.5));
	spinePoles.push_back(Point3(0.0, 0.5, 2.0));
	spinePoles.push_back(Point3(0.0, 1.0, 2.3));
	spinePoles.push_back(Point3(0.0, 1.6, 2.3));
	spineKnots[0] = 0;
	spineKnots[1] = 1.0 / 3.0;
	spineKnots[2] = 2.0 / 3.0;
	spineKnots[3] = 1;
	spineMults.front() = 4;
	spineMults.back() = 4;
	std::shared_ptr<Geom3BSplineCurve> spine = std::make_shared<Geom3BSplineCurve>(spinePoles, spineKnots, spineMults, 3);
	TopoShape pipe = MakePipe(MakeWire(MakeEdge(spine)), MakeWire(MakeEdge(profile))).Shape();
	TopoExplorer ex(pipe, ShapeType::Face);
	std::shared_ptr<Geom3Surface> surface = TopoTool::Surface(static_cast<const TopoFace&>(ex.Current()));
	return surface;
;
	SECTION("ExtendSurfByAverageLength1")
	{
		OUTPUT_DIRECTORY(nurbs, Extend/ExtendSurf/ExtendSurfByAverageLength1);
		auto lengthsurf = NURBSAPIExtend::ExtendSurfByAverageLength(surface, true, true, len);
		shared_ptr<Geom3BSplineSurface> bspSurf2 = NURBSAPIConvert::ToBSpline(lengthsurf);
		CHECK(bspSurf2->UDegree() == udeg);
		CHECK(bspSurf2->VDegree() == vdeg);
		CHECK(bspSurf2->NUPoles() == upNum);
		CHECK(bspSurf2->NVPoles() == vpNum);
		CHECK(bspSurf2->NUKnots() == ukNum);
		CHECK(bspSurf2->NVKnots() == vkNum);
		double fpu11 = lengthsurf->FirstUParameter();
		shared_ptr<Geom3Curve> fu11 = lengthsurf->UIso(fpu11);
		double res1 = NurbsExtendSample2(num, len, tol, fu, fu11);
		CHECK(res1 <= ratio);
		OCCTIO::OCCTTool::Write(MakeEdge(fu), outdir + "curve1.brep");
		OCCTIO::OCCTTool::Write(MakeEdge(fu11), outdir + "curve2.brep");
		OCCTIO::OCCTTool::Write(MakeFace(surface, 0.0), outdir + "src.brep");
		OCCTIO::OCCTTool::Write(MakeFace(lengthsurf, 0.0), outdir + "result.brep");
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static std::shared_ptr<Geom3Surface> ExtendSurfPerpendicularToPlane(const std::shared_ptr<Geom3Surface>& surf, const std::shared_ptr<Geom3Plane>& plane)	 @return New surface
	 @param plane Plane
	 @param surf Surf
	 The degree of surface is not changed but the size of the extended direction (u or v) knots and poles increase 1.
	 The original surface is part of new surface.
	 @brief Extend surface to plane and the surface end which is closer to plane is always perpendicular to the plane, which can be used in mirror to fix the gap.
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <nurbs/NURBSAPIExtend.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeFace.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/Geom3Plane.hpp>
#include <geometry/Geom3TrimmedSurface.hpp>
#include <nurbs/NURBSAPIConvert.hpp>
#include <nurbs/NURBSAPIBuildCurve.hpp>
#include <geomAlgo/LawBSpline.hpp>
#include <offset/MakePipe.hpp>
#include <modeling/MakeWire.hpp>
#include <topology/TopoTool.hpp>
#include <topology/TopoExplorerTool.hpp>
#include <geometry/GeomAPIProjectPointOnCurve3.hpp>
#include <geometry/GeomAPIProjectPointOnSurface.hpp>
double NurbsExtendSample3(int num, double len, double tol, const shared_ptr<Geom3Curve>& curve1, const shared_ptr<Geom3Curve>& curve2)
{
	const int nsample = num;
	double fp1 = curve1->FirstParameter();
	double lp1 = curve1->LastParameter();
	double delta1 = (lp1 - fp1) / nsample;
	Point3 p;
	int n = 0;
	for (int i = 0; i < nsample; i++)
	{
		double t1 = fp1 + i * delta1;
		curve1->D0(t1, p);
		TopoVertex vt = MakeVertex(p);
		TopoEdge edge = MakeEdge(curve2);
		BRepExtremaDistShapeShape dist(vt, edge);
		double dis = abs(dist.Value() - len);
		if (dis <= tol)
		{
			n++;
		}
	}
	double res = 1.0 * (num - n) / num;
	return res;
}
shared_ptr<Geom3Surface> ConstructExtendSurface3()
{
	std::vector<Point3> profilePoles;
	std::vector<double> profileKnots(3);
	std::vector<int> profileMults(3, 1);
	profilePoles.push_back(Point3(0.0, 0.0, 0.0));
	profilePoles.push_back(Point3(1.0, -0.2, 0.0));
	profilePoles.push_back(Point3(2.0, 0.1, 0.0));
	profilePoles.push_back(Point3(2.3, -0.1, 0.0));
	profilePoles.push_back(Point3(2.9, 0.1, 0.0));
	profileKnots[0] = 0;
	profileKnots[1] = 0.5;
	profileKnots[2] = 1;
	profileMults.front() = 4;
	profileMults.back() = 4;
	std::shared_ptr<Geom3BSplineCurve> profile = std::make_shared<Geom3BSplineCurve>(profilePoles, profileKnots, profileMults, 3);
	std::vector<Point3> spinePoles;
	std::vector<double> spineKnots(4);
	std::vector<int> spineMults(4, 1);
	spinePoles.push_back(Point3(0.0, 0.0, 0.0));
	spinePoles.push_back(Point3(0.0, 0.0, 1.0));
	spinePoles.push_back(Point3(0.0, 0.2, 1.5));
	spinePoles.push_back(Point3(0.0, 0.5, 2.0));
	spinePoles.push_back(Point3(0.0, 1.0, 2.3));
	spinePoles.push_back(Point3(0.0, 1.6, 2.3));
	spineKnots[0] = 0;
	spineKnots[1] = 1.0 / 3.0;
	spineKnots[2] = 2.0 / 3.0;
	spineKnots[3] = 1;
	spineMults.front() = 4;
	spineMults.back() = 4;
	std::shared_ptr<Geom3BSplineCurve> spine = std::make_shared<Geom3BSplineCurve>(spinePoles, spineKnots, spineMults, 3);
	TopoShape pipe = MakePipe(MakeWire(MakeEdge(spine)), MakeWire(MakeEdge(profile))).Shape();
	TopoExplorer ex(pipe, ShapeType::Face);
	std::shared_ptr<Geom3Surface> surface = TopoTool::Surface(static_cast<const TopoFace&>(ex.Current()));
	return surface;
}
shared_ptr<Geom3Surface> ConstructExtendPeriodicSurf3()
{
	std::vector<Point3> profilePoles;
	profilePoles.push_back(Point3(0.0, 0.0, 0.0));
	profilePoles.push_back(Point3(1.0, -1.0, 0.0));
	profilePoles.push_back(Point3(2.0, -1.5, 0.0));
	profilePoles.push_back(Point3(2.3, -1.0, 0.0));
	profilePoles.push_back(Point3(2.9, 0.0, 0.0));
	profilePoles.push_back(Point3(2.3, 0.9, 0.0));
	profilePoles.push_back(Point3(2.1, 1.6, 0.0));
	profilePoles.push_back(Point3(1.0, 1.0, 0.0));
	std::vector<double> profileKnots(profilePoles.size() + 1);
	for (int i = 0; i < static_cast<int>(profileKnots.size()); i++)
	{
		profileKnots[i] = (double)i / (double)(profilePoles.size());
	}
	profileKnots[1] += 1.0 / (double)(3 * profilePoles.size());
	std::vector<int> profileMults(profileKnots.size(), 1);
	std::shared_ptr<Geom3BSplineCurve> profile = std::make_shared<Geom3BSplineCurve>(profilePoles, profileKnots, profileMults, 3, true);
	std::vector<Point3> spinePoles;
	std::vector<double> spineKnots(4);
	std::vector<int> spineMults(4, 1);
	spinePoles.push_back(Point3(0.0, 0.0, 0.0));
	spinePoles.push_back(Point3(0.0, 0.0, 1.0));
	spinePoles.push_back(Point3(0.0, 0.2, 1.5));
	spinePoles.push_back(Point3(0.0, 0.5, 2.0));
	spinePoles.push_back(Point3(0.0, 1.0, 2.3));
	spinePoles.push_back(Point3(0.0, 1.6, 2.3));
	spineKnots[0] = 0;
	spineKnots[1] = 1.0 / 3.0;
	spineKnots[2] = 2.0 / 3.0;
	spineKnots[3] = 1;
	spineMults.front() = 4;
	spineMults.back() = 4;
	std::shared_ptr<Geom3BSplineCurve> spine = std::make_shared<Geom3BSplineCurve>(spinePoles, spineKnots, spineMults, 3);
	TopoShape pipe = MakePipe(MakeWire(MakeEdge(spine)), MakeWire(MakeEdge(profile))).Shape();
	TopoExplorer ex(pipe, ShapeType::Face);
	std::shared_ptr<Geom3Surface> surface = TopoTool::Surface(static_cast<const TopoFace&>(ex.Current()));
	return surface;
}
#include<catch.hpp>
#include<testHelper.h>
#include <nurbs/NURBSAPIExtend.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeFace.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/Geom3Plane.hpp>
#include <geometry/Geom3TrimmedSurface.hpp>
#include <nurbs/NURBSAPIConvert.hpp>
#include <nurbs/NURBSAPIBuildCurve.hpp>
#include <geomAlgo/LawBSpline.hpp>
#include <offset/MakePipe.hpp>
#include <modeling/MakeWire.hpp>
#include <topology/TopoTool.hpp>
#include <topology/TopoExplorerTool.hpp>
#include <geometry/GeomAPIProjectPointOnCurve3.hpp>
#include <geometry/GeomAPIProjectPointOnSurface.hpp>
double NurbsExtendSample3(int num, double len, double tol, const shared_ptr<Geom3Curve>& curve1, const shared_ptr<Geom3Curve>& curve2)
{
	const int nsample = num;
	double fp1 = curve1->FirstParameter();
	double lp1 = curve1->LastParameter();
	double delta1 = (lp1 - fp1) / nsample;
	Point3 p;
	int n = 0;
	for (int i = 0; i < nsample; i++)
	{
		double t1 = fp1 + i * delta1;
		curve1->D0(t1, p);
		TopoVertex vt = MakeVertex(p);
		TopoEdge edge = MakeEdge(curve2);
		BRepExtremaDistShapeShape dist(vt, edge);
		double dis = abs(dist.Value() - len);
		if (dis <= tol)
		{
			n++;
		}
	}
	double res = 1.0 * (num - n) / num;
	return res;
}
shared_ptr<Geom3Surface> ConstructExtendSurface3()
{
	std::vector<Point3> profilePoles;
	std::vector<double> profileKnots(3);
	std::vector<int> profileMults(3, 1);
	profilePoles.push_back(Point3(0.0, 0.0, 0.0));
	profilePoles.push_back(Point3(1.0, -0.2, 0.0));
	profilePoles.push_back(Point3(2.0, 0.1, 0.0));
	profilePoles.push_back(Point3(2.3, -0.1, 0.0));
	profilePoles.push_back(Point3(2.9, 0.1, 0.0));
	profileKnots[0] = 0;
	profileKnots[1] = 0.5;
	profileKnots[2] = 1;
	profileMults.front() = 4;
	profileMults.back() = 4;
	std::shared_ptr<Geom3BSplineCurve> profile = std::make_shared<Geom3BSplineCurve>(profilePoles, profileKnots, profileMults, 3);
	std::vector<Point3> spinePoles;
	std::vector<double> spineKnots(4);
	std::vector<int> spineMults(4, 1);
	spinePoles.push_back(Point3(0.0, 0.0, 0.0));
	spinePoles.push_back(Point3(0.0, 0.0, 1.0));
	spinePoles.push_back(Point3(0.0, 0.2, 1.5));
	spinePoles.push_back(Point3(0.0, 0.5, 2.0));
	spinePoles.push_back(Point3(0.0, 1.0, 2.3));
	spinePoles.push_back(Point3(0.0, 1.6, 2.3));
	spineKnots[0] = 0;
	spineKnots[1] = 1.0 / 3.0;
	spineKnots[2] = 2.0 / 3.0;
	spineKnots[3] = 1;
	spineMults.front() = 4;
	spineMults.back() = 4;
	std::shared_ptr<Geom3BSplineCurve> spine = std::make_shared<Geom3BSplineCurve>(spinePoles, spineKnots, spineMults, 3);
	TopoShape pipe = MakePipe(MakeWire(MakeEdge(spine)), MakeWire(MakeEdge(profile))).Shape();
	TopoExplorer ex(pipe, ShapeType::Face);
	std::shared_ptr<Geom3Surface> surface = TopoTool::Surface(static_cast<const TopoFace&>(ex.Current()));
	return surface;
}
shared_ptr<Geom3Surface> ConstructExtendPeriodicSurf3()
{
	std::vector<Point3> profilePoles;
	profilePoles.push_back(Point3(0.0, 0.0, 0.0));
	profilePoles.push_back(Point3(1.0, -1.0, 0.0));
	profilePoles.push_back(Point3(2.0, -1.5, 0.0));
	profilePoles.push_back(Point3(2.3, -1.0, 0.0));
	profilePoles.push_back(Point3(2.9, 0.0, 0.0));
	profilePoles.push_back(Point3(2.3, 0.9, 0.0));
	profilePoles.push_back(Point3(2.1, 1.6, 0.0));
	profilePoles.push_back(Point3(1.0, 1.0, 0.0));
	std::vector<double> profileKnots(profilePoles.size() + 1);
	for (int i = 0; i < static_cast<int>(profileKnots.size()); i++)
	{
		profileKnots[i] = (double)i / (double)(profilePoles.size());
	}
	profileKnots[1] += 1.0 / (double)(3 * profilePoles.size());
	std::vector<int> profileMults(profileKnots.size(), 1);
	std::shared_ptr<Geom3BSplineCurve> profile = std::make_shared<Geom3BSplineCurve>(profilePoles, profileKnots, profileMults, 3, true);
	std::vector<Point3> spinePoles;
	std::vector<double> spineKnots(4);
	std::vector<int> spineMults(4, 1);
	spinePoles.push_back(Point3(0.0, 0.0, 0.0));
	spinePoles.push_back(Point3(0.0, 0.0, 1.0));
	spinePoles.push_back(Point3(0.0, 0.2, 1.5));
	spinePoles.push_back(Point3(0.0, 0.5, 2.0));
	spinePoles.push_back(Point3(0.0, 1.0, 2.3));
	spinePoles.push_back(Point3(0.0, 1.6, 2.3));
	spineKnots[0] = 0;
	spineKnots[1] = 1.0 / 3.0;
	spineKnots[2] = 2.0 / 3.0;
	spineKnots[3] = 1;
	spineMults.front() = 4;
	spineMults.back() = 4;
	std::shared_ptr<Geom3BSplineCurve> spine = std::make_shared<Geom3BSplineCurve>(spinePoles, spineKnots, spineMults, 3);
	TopoShape pipe = MakePipe(MakeWire(MakeEdge(spine)), MakeWire(MakeEdge(profile))).Shape();
	TopoExplorer ex(pipe, ShapeType::Face);
	std::shared_ptr<Geom3Surface> surface = TopoTool::Surface(static_cast<const TopoFace&>(ex.Current()));
	return surface;
;
	SECTION("ExtendSurfPerpendicularToPlane4")
	{
		OUTPUT_DIRECTORY(nurbs, Extend/ExtendSurf/ExtendSurfPerpendicularToPlane4);
		shared_ptr<Geom3Plane> plane = make_shared<Geom3Plane>(Point3(0.0, 1.8, 0.0), Direction3(0.0, 1.0, 0.0));
		auto planevl = NURBSAPIExtend::ExtendSurfPerpendicularToPlane(surface, false, false, plane);
		shared_ptr<Geom3TrimmedSurface>trimSurf = std::make_shared<Geom3TrimmedSurface>(plane, -5.0, 5.0, -5.0, 5.0);
		shared_ptr<Geom3BSplineSurface> bspSurf2 = NURBSAPIConvert::ToBSpline(planevl);
		CHECK(bspSurf2->UDegree() == udeg);
		CHECK(bspSurf2->NUPoles() == upNum);
		CHECK(bspSurf2->NUKnots() == ukNum);
		double lpu1 = planevl->LastUParameter();
		shared_ptr<Geom3Curve> lu1 = planevl->UIso(lpu1);
		Point3 p1;
		Vector3 vec;
		double ls = lu1->LastParameter();
		lu1->D1(ls, p1, vec);
		Axis3 axis = plane->Axis();
		bool res = axis.Direction().IsParallel(Direction3(vec), Precision::Angular());
		double lpv1 = planevl->LastVParameter();
		shared_ptr<Geom3Curve> lv1 = planevl->VIso(lpv1);
		bool res1 = IsCurveOnSurf(num, ratio, lv1, plane, -1.0);
		CHECK(res1 == true);
		OCCTIO::OCCTTool::Write(MakeEdge(lv), outdir + "curve1.brep");
		OCCTIO::OCCTTool::Write(MakeEdge(lv1), outdir + "curve2.brep");
		OCCTIO::OCCTTool::Write(MakeFace(trimSurf, 0.0), outdir + "trimSurf.brep");
		OCCTIO::OCCTTool::Write(MakeFace(surface, 0.0), outdir + "src.brep");
		OCCTIO::OCCTTool::Write(MakeFace(planevl, 0.0), outdir + "result.brep");
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static std::shared_ptr<Geom3Surface> ExtendSurfPerpendicularToPlane(const std::shared_ptr<Geom3Surface>& surf, bool isExtendU, bool isFront, const std::shared_ptr<Geom3Plane>& plane)	 @return New surface
	 @param plane Plane
	 @param isFront Extend front or back
	 @param isExtendU Extend u or v
	 @param surf Surf
	 The degree of surface is not changed but the size of the extended direction (u or v) knots and poles increase 1.
	 The original surface is part of new surface.
	 @brief Extend surface to plane and the end of surface is always perpendicular to the plane, which can be used in mirror to fix the gap.
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <nurbs/NURBSAPIExtend.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeFace.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/Geom3Plane.hpp>
#include <geometry/Geom3TrimmedSurface.hpp>
#include <nurbs/NURBSAPIConvert.hpp>
#include <nurbs/NURBSAPIBuildCurve.hpp>
#include <geomAlgo/LawBSpline.hpp>
#include <offset/MakePipe.hpp>
#include <modeling/MakeWire.hpp>
#include <topology/TopoTool.hpp>
#include <topology/TopoExplorerTool.hpp>
#include <geometry/GeomAPIProjectPointOnCurve3.hpp>
#include <geometry/GeomAPIProjectPointOnSurface.hpp>
double NurbsExtendSample3(int num, double len, double tol, const shared_ptr<Geom3Curve>& curve1, const shared_ptr<Geom3Curve>& curve2)
{
	const int nsample = num;
	double fp1 = curve1->FirstParameter();
	double lp1 = curve1->LastParameter();
	double delta1 = (lp1 - fp1) / nsample;
	Point3 p;
	int n = 0;
	for (int i = 0; i < nsample; i++)
	{
		double t1 = fp1 + i * delta1;
		curve1->D0(t1, p);
		TopoVertex vt = MakeVertex(p);
		TopoEdge edge = MakeEdge(curve2);
		BRepExtremaDistShapeShape dist(vt, edge);
		double dis = abs(dist.Value() - len);
		if (dis <= tol)
		{
			n++;
		}
	}
	double res = 1.0 * (num - n) / num;
	return res;
}
shared_ptr<Geom3Surface> ConstructExtendSurface3()
{
	std::vector<Point3> profilePoles;
	std::vector<double> profileKnots(3);
	std::vector<int> profileMults(3, 1);
	profilePoles.push_back(Point3(0.0, 0.0, 0.0));
	profilePoles.push_back(Point3(1.0, -0.2, 0.0));
	profilePoles.push_back(Point3(2.0, 0.1, 0.0));
	profilePoles.push_back(Point3(2.3, -0.1, 0.0));
	profilePoles.push_back(Point3(2.9, 0.1, 0.0));
	profileKnots[0] = 0;
	profileKnots[1] = 0.5;
	profileKnots[2] = 1;
	profileMults.front() = 4;
	profileMults.back() = 4;
	std::shared_ptr<Geom3BSplineCurve> profile = std::make_shared<Geom3BSplineCurve>(profilePoles, profileKnots, profileMults, 3);
	std::vector<Point3> spinePoles;
	std::vector<double> spineKnots(4);
	std::vector<int> spineMults(4, 1);
	spinePoles.push_back(Point3(0.0, 0.0, 0.0));
	spinePoles.push_back(Point3(0.0, 0.0, 1.0));
	spinePoles.push_back(Point3(0.0, 0.2, 1.5));
	spinePoles.push_back(Point3(0.0, 0.5, 2.0));
	spinePoles.push_back(Point3(0.0, 1.0, 2.3));
	spinePoles.push_back(Point3(0.0, 1.6, 2.3));
	spineKnots[0] = 0;
	spineKnots[1] = 1.0 / 3.0;
	spineKnots[2] = 2.0 / 3.0;
	spineKnots[3] = 1;
	spineMults.front() = 4;
	spineMults.back() = 4;
	std::shared_ptr<Geom3BSplineCurve> spine = std::make_shared<Geom3BSplineCurve>(spinePoles, spineKnots, spineMults, 3);
	TopoShape pipe = MakePipe(MakeWire(MakeEdge(spine)), MakeWire(MakeEdge(profile))).Shape();
	TopoExplorer ex(pipe, ShapeType::Face);
	std::shared_ptr<Geom3Surface> surface = TopoTool::Surface(static_cast<const TopoFace&>(ex.Current()));
	return surface;
}
shared_ptr<Geom3Surface> ConstructExtendPeriodicSurf3()
{
	std::vector<Point3> profilePoles;
	profilePoles.push_back(Point3(0.0, 0.0, 0.0));
	profilePoles.push_back(Point3(1.0, -1.0, 0.0));
	profilePoles.push_back(Point3(2.0, -1.5, 0.0));
	profilePoles.push_back(Point3(2.3, -1.0, 0.0));
	profilePoles.push_back(Point3(2.9, 0.0, 0.0));
	profilePoles.push_back(Point3(2.3, 0.9, 0.0));
	profilePoles.push_back(Point3(2.1, 1.6, 0.0));
	profilePoles.push_back(Point3(1.0, 1.0, 0.0));
	std::vector<double> profileKnots(profilePoles.size() + 1);
	for (int i = 0; i < static_cast<int>(profileKnots.size()); i++)
	{
		profileKnots[i] = (double)i / (double)(profilePoles.size());
	}
	profileKnots[1] += 1.0 / (double)(3 * profilePoles.size());
	std::vector<int> profileMults(profileKnots.size(), 1);
	std::shared_ptr<Geom3BSplineCurve> profile = std::make_shared<Geom3BSplineCurve>(profilePoles, profileKnots, profileMults, 3, true);
	std::vector<Point3> spinePoles;
	std::vector<double> spineKnots(4);
	std::vector<int> spineMults(4, 1);
	spinePoles.push_back(Point3(0.0, 0.0, 0.0));
	spinePoles.push_back(Point3(0.0, 0.0, 1.0));
	spinePoles.push_back(Point3(0.0, 0.2, 1.5));
	spinePoles.push_back(Point3(0.0, 0.5, 2.0));
	spinePoles.push_back(Point3(0.0, 1.0, 2.3));
	spinePoles.push_back(Point3(0.0, 1.6, 2.3));
	spineKnots[0] = 0;
	spineKnots[1] = 1.0 / 3.0;
	spineKnots[2] = 2.0 / 3.0;
	spineKnots[3] = 1;
	spineMults.front() = 4;
	spineMults.back() = 4;
	std::shared_ptr<Geom3BSplineCurve> spine = std::make_shared<Geom3BSplineCurve>(spinePoles, spineKnots, spineMults, 3);
	TopoShape pipe = MakePipe(MakeWire(MakeEdge(spine)), MakeWire(MakeEdge(profile))).Shape();
	TopoExplorer ex(pipe, ShapeType::Face);
	std::shared_ptr<Geom3Surface> surface = TopoTool::Surface(static_cast<const TopoFace&>(ex.Current()));
	return surface;
}
#include<catch.hpp>
#include<testHelper.h>
#include <nurbs/NURBSAPIExtend.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeFace.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/Geom3Plane.hpp>
#include <geometry/Geom3TrimmedSurface.hpp>
#include <nurbs/NURBSAPIConvert.hpp>
#include <nurbs/NURBSAPIBuildCurve.hpp>
#include <geomAlgo/LawBSpline.hpp>
#include <offset/MakePipe.hpp>
#include <modeling/MakeWire.hpp>
#include <topology/TopoTool.hpp>
#include <topology/TopoExplorerTool.hpp>
#include <geometry/GeomAPIProjectPointOnCurve3.hpp>
#include <geometry/GeomAPIProjectPointOnSurface.hpp>
double NurbsExtendSample3(int num, double len, double tol, const shared_ptr<Geom3Curve>& curve1, const shared_ptr<Geom3Curve>& curve2)
{
	const int nsample = num;
	double fp1 = curve1->FirstParameter();
	double lp1 = curve1->LastParameter();
	double delta1 = (lp1 - fp1) / nsample;
	Point3 p;
	int n = 0;
	for (int i = 0; i < nsample; i++)
	{
		double t1 = fp1 + i * delta1;
		curve1->D0(t1, p);
		TopoVertex vt = MakeVertex(p);
		TopoEdge edge = MakeEdge(curve2);
		BRepExtremaDistShapeShape dist(vt, edge);
		double dis = abs(dist.Value() - len);
		if (dis <= tol)
		{
			n++;
		}
	}
	double res = 1.0 * (num - n) / num;
	return res;
}
shared_ptr<Geom3Surface> ConstructExtendSurface3()
{
	std::vector<Point3> profilePoles;
	std::vector<double> profileKnots(3);
	std::vector<int> profileMults(3, 1);
	profilePoles.push_back(Point3(0.0, 0.0, 0.0));
	profilePoles.push_back(Point3(1.0, -0.2, 0.0));
	profilePoles.push_back(Point3(2.0, 0.1, 0.0));
	profilePoles.push_back(Point3(2.3, -0.1, 0.0));
	profilePoles.push_back(Point3(2.9, 0.1, 0.0));
	profileKnots[0] = 0;
	profileKnots[1] = 0.5;
	profileKnots[2] = 1;
	profileMults.front() = 4;
	profileMults.back() = 4;
	std::shared_ptr<Geom3BSplineCurve> profile = std::make_shared<Geom3BSplineCurve>(profilePoles, profileKnots, profileMults, 3);
	std::vector<Point3> spinePoles;
	std::vector<double> spineKnots(4);
	std::vector<int> spineMults(4, 1);
	spinePoles.push_back(Point3(0.0, 0.0, 0.0));
	spinePoles.push_back(Point3(0.0, 0.0, 1.0));
	spinePoles.push_back(Point3(0.0, 0.2, 1.5));
	spinePoles.push_back(Point3(0.0, 0.5, 2.0));
	spinePoles.push_back(Point3(0.0, 1.0, 2.3));
	spinePoles.push_back(Point3(0.0, 1.6, 2.3));
	spineKnots[0] = 0;
	spineKnots[1] = 1.0 / 3.0;
	spineKnots[2] = 2.0 / 3.0;
	spineKnots[3] = 1;
	spineMults.front() = 4;
	spineMults.back() = 4;
	std::shared_ptr<Geom3BSplineCurve> spine = std::make_shared<Geom3BSplineCurve>(spinePoles, spineKnots, spineMults, 3);
	TopoShape pipe = MakePipe(MakeWire(MakeEdge(spine)), MakeWire(MakeEdge(profile))).Shape();
	TopoExplorer ex(pipe, ShapeType::Face);
	std::shared_ptr<Geom3Surface> surface = TopoTool::Surface(static_cast<const TopoFace&>(ex.Current()));
	return surface;
}
shared_ptr<Geom3Surface> ConstructExtendPeriodicSurf3()
{
	std::vector<Point3> profilePoles;
	profilePoles.push_back(Point3(0.0, 0.0, 0.0));
	profilePoles.push_back(Point3(1.0, -1.0, 0.0));
	profilePoles.push_back(Point3(2.0, -1.5, 0.0));
	profilePoles.push_back(Point3(2.3, -1.0, 0.0));
	profilePoles.push_back(Point3(2.9, 0.0, 0.0));
	profilePoles.push_back(Point3(2.3, 0.9, 0.0));
	profilePoles.push_back(Point3(2.1, 1.6, 0.0));
	profilePoles.push_back(Point3(1.0, 1.0, 0.0));
	std::vector<double> profileKnots(profilePoles.size() + 1);
	for (int i = 0; i < static_cast<int>(profileKnots.size()); i++)
	{
		profileKnots[i] = (double)i / (double)(profilePoles.size());
	}
	profileKnots[1] += 1.0 / (double)(3 * profilePoles.size());
	std::vector<int> profileMults(profileKnots.size(), 1);
	std::shared_ptr<Geom3BSplineCurve> profile = std::make_shared<Geom3BSplineCurve>(profilePoles, profileKnots, profileMults, 3, true);
	std::vector<Point3> spinePoles;
	std::vector<double> spineKnots(4);
	std::vector<int> spineMults(4, 1);
	spinePoles.push_back(Point3(0.0, 0.0, 0.0));
	spinePoles.push_back(Point3(0.0, 0.0, 1.0));
	spinePoles.push_back(Point3(0.0, 0.2, 1.5));
	spinePoles.push_back(Point3(0.0, 0.5, 2.0));
	spinePoles.push_back(Point3(0.0, 1.0, 2.3));
	spinePoles.push_back(Point3(0.0, 1.6, 2.3));
	spineKnots[0] = 0;
	spineKnots[1] = 1.0 / 3.0;
	spineKnots[2] = 2.0 / 3.0;
	spineKnots[3] = 1;
	spineMults.front() = 4;
	spineMults.back() = 4;
	std::shared_ptr<Geom3BSplineCurve> spine = std::make_shared<Geom3BSplineCurve>(spinePoles, spineKnots, spineMults, 3);
	TopoShape pipe = MakePipe(MakeWire(MakeEdge(spine)), MakeWire(MakeEdge(profile))).Shape();
	TopoExplorer ex(pipe, ShapeType::Face);
	std::shared_ptr<Geom3Surface> surface = TopoTool::Surface(static_cast<const TopoFace&>(ex.Current()));
	return surface;
;
	SECTION("ExtendSurfPerpendicularToPlane1")
	{
		OUTPUT_DIRECTORY(nurbs, Extend/bug752/ExtendSurfPerpendicularToPlane1);
		shared_ptr<Geom3Plane> plane = make_shared<Geom3Plane>(Point3(-0.2, 0.0, 0.0), Direction3(1.0, 0.0, 0.0));
		auto srcSurf = NURBSAPIExtend::ExtendSurfPerpendicularToPlane(surface, true, true, plane);
		auto planeuf = NURBSAPIExtend::ExtendSurfPerpendicularToPlane(surfaceInc, true, true, plane);
		shared_ptr<Geom3TrimmedSurface>trimSurf = std::make_shared<Geom3TrimmedSurface>(plane, -2.0, 2.0, -2.0, 2.0);
		double fpv1 = planeuf->FirstVParameter();
		shared_ptr<Geom3Curve> fv1 = planeuf->VIso(fpv1);
		Point3 p1;
		Vector3 vec;
		double fs = fv1->FirstParameter();
		fv1->D1(fs, p1, vec);
		Axis3 axis = plane->Axis();
		bool res = axis.Direction().IsParallel(Direction3(vec), Precision::Angular());
		CHECK(res == true);
		double fpu1 = planeuf->FirstUParameter();
		shared_ptr<Geom3Curve> fu1 = planeuf->UIso(fpu1);
		bool res1 = IsCurveOnSurf(num, ratio, fu1, plane, -1.0);
		CHECK(res1 == true);
		double fppu1 = srcSurf->FirstUParameter();
		double fppv1 = srcSurf->FirstVParameter();
		double lppu1 = srcSurf->LastUParameter();
		double lppv1 = srcSurf->LastVParameter();
		shared_ptr<Geom3Curve> fuu1 = srcSurf->UIso(fppu1);
		shared_ptr<Geom3Curve> fvv1 = srcSurf->VIso(fppv1);
		shared_ptr<Geom3Curve> luu1 = srcSurf->UIso(lppu1);
		shared_ptr<Geom3Curve> lvv1 = srcSurf->VIso(lppv1);
		double fppu2 = planeuf->FirstUParameter();
		double fppv2 = planeuf->FirstVParameter();
		double lppu2 = planeuf->LastUParameter();
		double lppv2 = planeuf->LastVParameter();
		shared_ptr<Geom3Curve> fuu2 = planeuf->UIso(fppu2);
		shared_ptr<Geom3Curve> fvv2 = planeuf->VIso(fppv2);
		shared_ptr<Geom3Curve> luu2 = planeuf->UIso(lppu2);
		shared_ptr<Geom3Curve> lvv2 = planeuf->VIso(lppv2);
		double res3 = NurbsSampleCurve(num, refTol, fuu1, fuu2);
		double res4 = NurbsSampleCurve(num, refTol, fvv1, fvv2);
		double res5 = NurbsSampleCurve(num, refTol, luu1, luu2);
		double res6 = NurbsSampleCurve(num, refTol, lvv1, lvv2);
		CHECK(res3 <= ratio);
		CHECK(res4 <= ratio);
		CHECK(res5 <= ratio);
		CHECK(res6 <= ratio);
		OCCTIO::OCCTTool::Write(MakeEdge(fu), outdir + "curve1.brep");
		OCCTIO::OCCTTool::Write(MakeEdge(fu1), outdir + "curve2.brep");
		OCCTIO::OCCTTool::Write(MakeFace(trimSurf, 0.0), outdir + "trimSurf.brep");
		OCCTIO::OCCTTool::Write(MakeFace(surface, 0.0), outdir + "src.brep");
		OCCTIO::OCCTTool::Write(MakeFace(surfaceInc, 0.0), outdir + "srcInc.brep");
		OCCTIO::OCCTTool::Write(MakeFace(srcSurf, 0.0), outdir + "oldresult.brep");
		OCCTIO::OCCTTool::Write(MakeFace(planeuf, 0.0), outdir + "result.brep");
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static std::shared_ptr<Geom3Surface> ExtendSurfToPoint(const std::shared_ptr<Geom3Surface>& surf, bool isU, bool isFront, const Point3& pt)	 @return New surface
	 @param pt Point
	 @param isFront Extend front or back
	 @param isU Extend u or v
	 @param surf Surface
	 The degree of the surface, the size of the extended direction (u or v) knots and poles are not changed.
	 The original surface is part of new surface.
	 @brief Extend surface to a point.
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <nurbs/NURBSAPIExtend.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeFace.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/Geom3Plane.hpp>
#include <geometry/Geom3TrimmedSurface.hpp>
#include <nurbs/NURBSAPIConvert.hpp>
#include <nurbs/NURBSAPIBuildCurve.hpp>
#include <geomAlgo/LawBSpline.hpp>
#include <offset/MakePipe.hpp>
#include <modeling/MakeWire.hpp>
#include <topology/TopoTool.hpp>
#include <topology/TopoExplorerTool.hpp>
#include <geometry/GeomAPIProjectPointOnCurve3.hpp>
#include <geometry/GeomAPIProjectPointOnSurface.hpp>
double NurbsExtendSample3(int num, double len, double tol, const shared_ptr<Geom3Curve>& curve1, const shared_ptr<Geom3Curve>& curve2)
{
	const int nsample = num;
	double fp1 = curve1->FirstParameter();
	double lp1 = curve1->LastParameter();
	double delta1 = (lp1 - fp1) / nsample;
	Point3 p;
	int n = 0;
	for (int i = 0; i < nsample; i++)
	{
		double t1 = fp1 + i * delta1;
		curve1->D0(t1, p);
		TopoVertex vt = MakeVertex(p);
		TopoEdge edge = MakeEdge(curve2);
		BRepExtremaDistShapeShape dist(vt, edge);
		double dis = abs(dist.Value() - len);
		if (dis <= tol)
		{
			n++;
		}
	}
	double res = 1.0 * (num - n) / num;
	return res;
}
shared_ptr<Geom3Surface> ConstructExtendSurface3()
{
	std::vector<Point3> profilePoles;
	std::vector<double> profileKnots(3);
	std::vector<int> profileMults(3, 1);
	profilePoles.push_back(Point3(0.0, 0.0, 0.0));
	profilePoles.push_back(Point3(1.0, -0.2, 0.0));
	profilePoles.push_back(Point3(2.0, 0.1, 0.0));
	profilePoles.push_back(Point3(2.3, -0.1, 0.0));
	profilePoles.push_back(Point3(2.9, 0.1, 0.0));
	profileKnots[0] = 0;
	profileKnots[1] = 0.5;
	profileKnots[2] = 1;
	profileMults.front() = 4;
	profileMults.back() = 4;
	std::shared_ptr<Geom3BSplineCurve> profile = std::make_shared<Geom3BSplineCurve>(profilePoles, profileKnots, profileMults, 3);
	std::vector<Point3> spinePoles;
	std::vector<double> spineKnots(4);
	std::vector<int> spineMults(4, 1);
	spinePoles.push_back(Point3(0.0, 0.0, 0.0));
	spinePoles.push_back(Point3(0.0, 0.0, 1.0));
	spinePoles.push_back(Point3(0.0, 0.2, 1.5));
	spinePoles.push_back(Point3(0.0, 0.5, 2.0));
	spinePoles.push_back(Point3(0.0, 1.0, 2.3));
	spinePoles.push_back(Point3(0.0, 1.6, 2.3));
	spineKnots[0] = 0;
	spineKnots[1] = 1.0 / 3.0;
	spineKnots[2] = 2.0 / 3.0;
	spineKnots[3] = 1;
	spineMults.front() = 4;
	spineMults.back() = 4;
	std::shared_ptr<Geom3BSplineCurve> spine = std::make_shared<Geom3BSplineCurve>(spinePoles, spineKnots, spineMults, 3);
	TopoShape pipe = MakePipe(MakeWire(MakeEdge(spine)), MakeWire(MakeEdge(profile))).Shape();
	TopoExplorer ex(pipe, ShapeType::Face);
	std::shared_ptr<Geom3Surface> surface = TopoTool::Surface(static_cast<const TopoFace&>(ex.Current()));
	return surface;
}
shared_ptr<Geom3Surface> ConstructExtendPeriodicSurf3()
{
	std::vector<Point3> profilePoles;
	profilePoles.push_back(Point3(0.0, 0.0, 0.0));
	profilePoles.push_back(Point3(1.0, -1.0, 0.0));
	profilePoles.push_back(Point3(2.0, -1.5, 0.0));
	profilePoles.push_back(Point3(2.3, -1.0, 0.0));
	profilePoles.push_back(Point3(2.9, 0.0, 0.0));
	profilePoles.push_back(Point3(2.3, 0.9, 0.0));
	profilePoles.push_back(Point3(2.1, 1.6, 0.0));
	profilePoles.push_back(Point3(1.0, 1.0, 0.0));
	std::vector<double> profileKnots(profilePoles.size() + 1);
	for (int i = 0; i < static_cast<int>(profileKnots.size()); i++)
	{
		profileKnots[i] = (double)i / (double)(profilePoles.size());
	}
	profileKnots[1] += 1.0 / (double)(3 * profilePoles.size());
	std::vector<int> profileMults(profileKnots.size(), 1);
	std::shared_ptr<Geom3BSplineCurve> profile = std::make_shared<Geom3BSplineCurve>(profilePoles, profileKnots, profileMults, 3, true);
	std::vector<Point3> spinePoles;
	std::vector<double> spineKnots(4);
	std::vector<int> spineMults(4, 1);
	spinePoles.push_back(Point3(0.0, 0.0, 0.0));
	spinePoles.push_back(Point3(0.0, 0.0, 1.0));
	spinePoles.push_back(Point3(0.0, 0.2, 1.5));
	spinePoles.push_back(Point3(0.0, 0.5, 2.0));
	spinePoles.push_back(Point3(0.0, 1.0, 2.3));
	spinePoles.push_back(Point3(0.0, 1.6, 2.3));
	spineKnots[0] = 0;
	spineKnots[1] = 1.0 / 3.0;
	spineKnots[2] = 2.0 / 3.0;
	spineKnots[3] = 1;
	spineMults.front() = 4;
	spineMults.back() = 4;
	std::shared_ptr<Geom3BSplineCurve> spine = std::make_shared<Geom3BSplineCurve>(spinePoles, spineKnots, spineMults, 3);
	TopoShape pipe = MakePipe(MakeWire(MakeEdge(spine)), MakeWire(MakeEdge(profile))).Shape();
	TopoExplorer ex(pipe, ShapeType::Face);
	std::shared_ptr<Geom3Surface> surface = TopoTool::Surface(static_cast<const TopoFace&>(ex.Current()));
	return surface;
}
#include<catch.hpp>
#include<testHelper.h>
#include <nurbs/NURBSAPIExtend.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeFace.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/Geom3Plane.hpp>
#include <geometry/Geom3TrimmedSurface.hpp>
#include <nurbs/NURBSAPIConvert.hpp>
#include <nurbs/NURBSAPIBuildCurve.hpp>
#include <geomAlgo/LawBSpline.hpp>
#include <offset/MakePipe.hpp>
#include <modeling/MakeWire.hpp>
#include <topology/TopoTool.hpp>
#include <topology/TopoExplorerTool.hpp>
#include <geometry/GeomAPIProjectPointOnCurve3.hpp>
#include <geometry/GeomAPIProjectPointOnSurface.hpp>
double NurbsExtendSample3(int num, double len, double tol, const shared_ptr<Geom3Curve>& curve1, const shared_ptr<Geom3Curve>& curve2)
{
	const int nsample = num;
	double fp1 = curve1->FirstParameter();
	double lp1 = curve1->LastParameter();
	double delta1 = (lp1 - fp1) / nsample;
	Point3 p;
	int n = 0;
	for (int i = 0; i < nsample; i++)
	{
		double t1 = fp1 + i * delta1;
		curve1->D0(t1, p);
		TopoVertex vt = MakeVertex(p);
		TopoEdge edge = MakeEdge(curve2);
		BRepExtremaDistShapeShape dist(vt, edge);
		double dis = abs(dist.Value() - len);
		if (dis <= tol)
		{
			n++;
		}
	}
	double res = 1.0 * (num - n) / num;
	return res;
}
shared_ptr<Geom3Surface> ConstructExtendSurface3()
{
	std::vector<Point3> profilePoles;
	std::vector<double> profileKnots(3);
	std::vector<int> profileMults(3, 1);
	profilePoles.push_back(Point3(0.0, 0.0, 0.0));
	profilePoles.push_back(Point3(1.0, -0.2, 0.0));
	profilePoles.push_back(Point3(2.0, 0.1, 0.0));
	profilePoles.push_back(Point3(2.3, -0.1, 0.0));
	profilePoles.push_back(Point3(2.9, 0.1, 0.0));
	profileKnots[0] = 0;
	profileKnots[1] = 0.5;
	profileKnots[2] = 1;
	profileMults.front() = 4;
	profileMults.back() = 4;
	std::shared_ptr<Geom3BSplineCurve> profile = std::make_shared<Geom3BSplineCurve>(profilePoles, profileKnots, profileMults, 3);
	std::vector<Point3> spinePoles;
	std::vector<double> spineKnots(4);
	std::vector<int> spineMults(4, 1);
	spinePoles.push_back(Point3(0.0, 0.0, 0.0));
	spinePoles.push_back(Point3(0.0, 0.0, 1.0));
	spinePoles.push_back(Point3(0.0, 0.2, 1.5));
	spinePoles.push_back(Point3(0.0, 0.5, 2.0));
	spinePoles.push_back(Point3(0.0, 1.0, 2.3));
	spinePoles.push_back(Point3(0.0, 1.6, 2.3));
	spineKnots[0] = 0;
	spineKnots[1] = 1.0 / 3.0;
	spineKnots[2] = 2.0 / 3.0;
	spineKnots[3] = 1;
	spineMults.front() = 4;
	spineMults.back() = 4;
	std::shared_ptr<Geom3BSplineCurve> spine = std::make_shared<Geom3BSplineCurve>(spinePoles, spineKnots, spineMults, 3);
	TopoShape pipe = MakePipe(MakeWire(MakeEdge(spine)), MakeWire(MakeEdge(profile))).Shape();
	TopoExplorer ex(pipe, ShapeType::Face);
	std::shared_ptr<Geom3Surface> surface = TopoTool::Surface(static_cast<const TopoFace&>(ex.Current()));
	return surface;
}
shared_ptr<Geom3Surface> ConstructExtendPeriodicSurf3()
{
	std::vector<Point3> profilePoles;
	profilePoles.push_back(Point3(0.0, 0.0, 0.0));
	profilePoles.push_back(Point3(1.0, -1.0, 0.0));
	profilePoles.push_back(Point3(2.0, -1.5, 0.0));
	profilePoles.push_back(Point3(2.3, -1.0, 0.0));
	profilePoles.push_back(Point3(2.9, 0.0, 0.0));
	profilePoles.push_back(Point3(2.3, 0.9, 0.0));
	profilePoles.push_back(Point3(2.1, 1.6, 0.0));
	profilePoles.push_back(Point3(1.0, 1.0, 0.0));
	std::vector<double> profileKnots(profilePoles.size() + 1);
	for (int i = 0; i < static_cast<int>(profileKnots.size()); i++)
	{
		profileKnots[i] = (double)i / (double)(profilePoles.size());
	}
	profileKnots[1] += 1.0 / (double)(3 * profilePoles.size());
	std::vector<int> profileMults(profileKnots.size(), 1);
	std::shared_ptr<Geom3BSplineCurve> profile = std::make_shared<Geom3BSplineCurve>(profilePoles, profileKnots, profileMults, 3, true);
	std::vector<Point3> spinePoles;
	std::vector<double> spineKnots(4);
	std::vector<int> spineMults(4, 1);
	spinePoles.push_back(Point3(0.0, 0.0, 0.0));
	spinePoles.push_back(Point3(0.0, 0.0, 1.0));
	spinePoles.push_back(Point3(0.0, 0.2, 1.5));
	spinePoles.push_back(Point3(0.0, 0.5, 2.0));
	spinePoles.push_back(Point3(0.0, 1.0, 2.3));
	spinePoles.push_back(Point3(0.0, 1.6, 2.3));
	spineKnots[0] = 0;
	spineKnots[1] = 1.0 / 3.0;
	spineKnots[2] = 2.0 / 3.0;
	spineKnots[3] = 1;
	spineMults.front() = 4;
	spineMults.back() = 4;
	std::shared_ptr<Geom3BSplineCurve> spine = std::make_shared<Geom3BSplineCurve>(spinePoles, spineKnots, spineMults, 3);
	TopoShape pipe = MakePipe(MakeWire(MakeEdge(spine)), MakeWire(MakeEdge(profile))).Shape();
	TopoExplorer ex(pipe, ShapeType::Face);
	std::shared_ptr<Geom3Surface> surface = TopoTool::Surface(static_cast<const TopoFace&>(ex.Current()));
	return surface;
;
	SECTION("ExtendPeriodicSurf2")
	{
		OUTPUT_DIRECTORY(nurbs, Extend/IncreaseDegree/ExtendSurf/ExtendPeriodicSurf2);
		Point3 p(1.0, -0.2, -0.2);
		auto srcSurf = NURBSAPIExtend::ExtendSurfToPoint(surface, false, true, p);
		auto pointvf = NURBSAPIExtend::ExtendSurfToPoint(surfaceInc, false, true, p);
		shared_ptr<Geom3BSplineSurface> bspSurf2 = NURBSAPIConvert::ToBSpline(pointvf);
		CHECK(bspSurf2->UDegree() == refDeg);
		CHECK(bspSurf2->VDegree() == refDeg);
		CHECK(bspSurf2->NUKnots() == ukNum);
		CHECK(bspSurf2->NVKnots() == vkNum);
		GeomAPIProjectPointOnSurface proj(p, pointvf);
		Point3 pp = proj.NearestPoint();
		double fpv2 = pointvf->FirstVParameter();
		shared_ptr<Geom3Curve> fv2 = pointvf->VIso(fpv2);
		TopoEdge edge2 = MakeEdge(fv2);
		bool res1 = BRepClassificationTools::IsPointInOnEdge(edge2, pp, 1e-3);
		CHECK(res1 == true);  
		double fppu1 = srcSurf->FirstUParameter();
		double fppv1 = srcSurf->FirstVParameter();
		double lppu1 = srcSurf->LastUParameter();
		double lppv1 = srcSurf->LastVParameter();
		shared_ptr<Geom3Curve> fuu1 = srcSurf->UIso(fppu1);
		shared_ptr<Geom3Curve> fvv1 = srcSurf->VIso(fppv1);
		shared_ptr<Geom3Curve> luu1 = srcSurf->UIso(lppu1);
		shared_ptr<Geom3Curve> lvv1 = srcSurf->VIso(lppv1);
		double fppu2 = pointvf->FirstUParameter();
		double fppv2 = pointvf->FirstVParameter();
		double lppu2 = pointvf->LastUParameter();
		double lppv2 = pointvf->LastVParameter();
		shared_ptr<Geom3Curve> fuu2 = pointvf->UIso(fppu2);
		shared_ptr<Geom3Curve> fvv2 = pointvf->VIso(fppv2);
		shared_ptr<Geom3Curve> luu2 = pointvf->UIso(lppu2);
		shared_ptr<Geom3Curve> lvv2 = pointvf->VIso(lppv2);
		double res3 = NurbsSampleCurve(num, refTol, fuu1, fuu2);
		double res4 = NurbsSampleCurve(num, refTol, fvv1, fvv2);
		double res5 = NurbsSampleCurve(num, refTol, luu1, luu2);
		double res6 = NurbsSampleCurve(num, refTol, lvv1, lvv2);
		CHECK(res3 <= ratio);
		CHECK(res4 <= ratio);
		CHECK(res5 <= ratio);
		CHECK(res6 <= ratio);
		TopoFace face = MakeFace(srcSurf, 0.0);
		TopoFace faceInc = MakeFace(pointvf, 0.0);
		GlobalProperty props1, props2;
		double s1 = GetSurfaceProperties(face, props1, true, false);
		double s2 = GetSurfaceProperties(faceInc, props2, true, false);
		CHECK(abs(s1 - s2) <= refTol);
		OCCTIO::OCCTTool::Write(MakeVertex(p), outdir + "refp.brep");
		OCCTIO::OCCTTool::Write(MakeEdge(fv), outdir + "curve1.brep");
		OCCTIO::OCCTTool::Write(MakeEdge(fv2), outdir + "curve2.brep");
		OCCTIO::OCCTTool::Write(MakeFace(surface, 0.0), outdir + "src.brep");
		OCCTIO::OCCTTool::Write(MakeFace(surfaceInc, 0.0), outdir + "srcInc.brep");
		OCCTIO::OCCTTool::Write(MakeFace(pointvf, 0.0), outdir + "result.brep");
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static std::shared_ptr<Geom3Curve> GetCurve(const TopoEdge& edge)	 @return The trimmed curve
	 @param edge The edge
	 @brief Get not infinite curve from the edge such as part of a line
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <nurbs/NURBSAPIGetGeometry.hpp>
#include <topology/TopoEdge.hpp>
#include <topology/TopoFace.hpp>
#include <modeling/MakeEdge.hpp>
#include <math/CircleT.hpp>
#include <math/EllipseT.hpp>
#include <math/HyperbolaT.hpp>
#include <modeling/MakeFace.hpp>
#include <math/Plane.hpp>
#include <math/Cylinder.hpp>
#include <math/Cone.hpp>
#include <math/Sphere.hpp>
#include <math/Torus.hpp>
#include<catch.hpp>
#include<testHelper.h>
#include <nurbs/NURBSAPIGetGeometry.hpp>
#include <topology/TopoEdge.hpp>
#include <topology/TopoFace.hpp>
#include <modeling/MakeEdge.hpp>
#include <math/CircleT.hpp>
#include <math/EllipseT.hpp>
#include <math/HyperbolaT.hpp>
#include <modeling/MakeFace.hpp>
#include <math/Plane.hpp>
#include <math/Cylinder.hpp>
#include <math/Cone.hpp>
#include <math/Sphere.hpp>
#include <math/Torus.hpp>
;
	SECTION("Line")
	{
		Line3 line;
		TopoEdge edge = MakeEdge(line);
		CHECK_THROWS_AS(NURBSAPIGetGeometry::GetCurve(edge), _DomainError);
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static std::shared_ptr<Geom3Surface> GetSurface(const TopoFace& face)	 @return The trimmed surface
	 @param face The face
	 @brief Get not infinite surface from the face such as part of a plane or cylinder
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <nurbs/NURBSAPIGetGeometry.hpp>
#include <topology/TopoEdge.hpp>
#include <topology/TopoFace.hpp>
#include <modeling/MakeEdge.hpp>
#include <math/CircleT.hpp>
#include <math/EllipseT.hpp>
#include <math/HyperbolaT.hpp>
#include <modeling/MakeFace.hpp>
#include <math/Plane.hpp>
#include <math/Cylinder.hpp>
#include <math/Cone.hpp>
#include <math/Sphere.hpp>
#include <math/Torus.hpp>
#include<catch.hpp>
#include<testHelper.h>
#include <nurbs/NURBSAPIGetGeometry.hpp>
#include <topology/TopoEdge.hpp>
#include <topology/TopoFace.hpp>
#include <modeling/MakeEdge.hpp>
#include <math/CircleT.hpp>
#include <math/EllipseT.hpp>
#include <math/HyperbolaT.hpp>
#include <modeling/MakeFace.hpp>
#include <math/Plane.hpp>
#include <math/Cylinder.hpp>
#include <math/Cone.hpp>
#include <math/Sphere.hpp>
#include <math/Torus.hpp>
;
	SECTION("Plane")
	{
		Plane p;
		TopoFace face = MakeFace(p, 0.0, 1.0, 2.0, 3.0);
		shared_ptr<Geom3Surface> surface = NURBSAPIGetGeometry::GetSurface(face);
		double u1 = surface->FirstUParameter();
		double u2 = surface->LastUParameter();
		double v1 = surface->FirstVParameter();
		double v2 = surface->LastVParameter();
		CHECK(u1 == Approx(0.0));
		CHECK(u2 == Approx(1.0));
		OCCTIO::OCCTTool::Write(face, outdir + "Plane.brep");
        OCCTIO::OCCTTool::Write(MakeFace(surface, 0.0), outdir + "geomPlane.brep");
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static std::shared_ptr<Geom3BSplineCurve> InterpolatePoints(const std::vector<Point3>& points, int degree = 3, bool isClosed = false, ApproxParameterizationType ptype = ApproxParameterizationType::ChordLength)	 @return The curve
	 @param ptype Parameterization type
	 @param isClosed Is the curve closed
	 @param degree Curve degree
	 @param points Data points
	 @brief The curve which interpolate the points is constructed
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <nurbs/NURBSAPIInterpolate.hpp>
#include <nurbs/NURBSAPIApprox.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeEdge.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
#include <geometry/GeomAPIProjectPointOnCurve3.hpp>
#include <nurbs/NURBSAPIBuildCurve.hpp>
#include<catch.hpp>
#include<testHelper.h>
#include <nurbs/NURBSAPIInterpolate.hpp>
#include <nurbs/NURBSAPIApprox.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeEdge.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
#include <geometry/GeomAPIProjectPointOnCurve3.hpp>
#include <nurbs/NURBSAPIBuildCurve.hpp>
;
	SECTION("TestApproxInterpolatePeriodicCurve")
	{
		OUTPUT_DIRECTORY(nurbs, Interpolate/ApproxInterpolatePeriodicCurve);
		std::vector<Point3> points;
		Point3 p1(0.0, -0.7, 0.0);
		Point3 p2(0.2, -0.6, 0.0);
		Point3 p3(0.5, 0.0, 0.0);
		Point3 p4(0.7, 0.1, 0.0);
		Point3 p5(0.5, 0.3, 0.0);
		Point3 p6(0.3, 0.7, 0.0);
		Point3 p7(0.0, 0.8, 0.0);
		Point3 p8(-0.3, 0.9, 0.0);
		Point3 p9(-0.8, 0.5, 0.0);
		Point3 p10(-0.7, 0.1, 0.0);
		Point3 p11(-0.6, -0.2, 0.0);
		Point3 p12(-0.3, -0.7, 0.0);
		points.push_back(p1);
		points.push_back(p2);
		points.push_back(p3);
		points.push_back(p4);
		points.push_back(p5);
		points.push_back(p6);
		points.push_back(p7);
		points.push_back(p8);
		points.push_back(p9);
		points.push_back(p10);
		points.push_back(p11);
		points.push_back(p12);
		ApproxParameterizationType ptype = ApproxParameterizationType::Centripetal;
		bool isPeriodic = true;
		auto curve1 = NURBSAPIApprox::ApproxPoints(points, 3, 7, isPeriodic, ptype);
		auto curve2 = NURBSAPIInterpolate::InterpolatePoints(points, 3, isPeriodic, ptype);
		Point3 sp = curve2->StartPoint();
		Point3 ep = curve2->EndPoint();
		CHECK(sp.X() == Approx(0.0).margin(1e-7));
		CHECK(sp.Y() == Approx(-0.7).margin(1e-7));
		CHECK(sp.Z() == Approx(0.0).margin(1e-7));
		CHECK(ep.X() == Approx(sp.X()).margin(1e-7));
		CHECK(ep.Y() == sp.Y());
		CHECK(ep.Z() == sp.Z());
		TopoVertex v1 = MakeVertex(p1);
		TopoVertex v2 = MakeVertex(p2);
		TopoVertex v3 = MakeVertex(p3);
		TopoVertex v4 = MakeVertex(p4);
		TopoVertex v5 = MakeVertex(p5);
		TopoVertex v6 = MakeVertex(p6);
		TopoVertex v7 = MakeVertex(p7);
		TopoVertex v8 = MakeVertex(p8);
		TopoVertex v9 = MakeVertex(p9);
		TopoVertex v10 = MakeVertex(p10);
		TopoVertex v11 = MakeVertex(p11);
		TopoVertex v12 = MakeVertex(p12);
		TopoEdge edge2 = MakeEdge(curve2);
		BRepExtremaDistShapeShape dist1(v1, edge2);
		BRepExtremaDistShapeShape dist2(v2, edge2);
		BRepExtremaDistShapeShape dist3(v3, edge2);
		BRepExtremaDistShapeShape dist4(v4, edge2);
		BRepExtremaDistShapeShape dist5(v5, edge2);
		BRepExtremaDistShapeShape dist6(v6, edge2);
		BRepExtremaDistShapeShape dist7(v7, edge2);
		BRepExtremaDistShapeShape dist8(v8, edge2);
		BRepExtremaDistShapeShape dist9(v9, edge2);
		BRepExtremaDistShapeShape dist10(v10, edge2);
		BRepExtremaDistShapeShape dist11(v11, edge2);
		BRepExtremaDistShapeShape dist12(v12, edge2);
		CHECK(dist1.Value() <= Approx(tol));
		CHECK(dist2.Value() <= Approx(tol));
		CHECK(dist3.Value() <= Approx(tol));
		CHECK(dist4.Value() <= Approx(tol));
		CHECK(dist5.Value() <= Approx(tol));
		CHECK(dist6.Value() <= Approx(tol));
		CHECK(dist7.Value() <= Approx(tol));
		CHECK(dist8.Value() <= Approx(tol));
		CHECK(dist9.Value() <= Approx(tol));
		CHECK(dist10.Value() <= Approx(tol));
		CHECK(dist11.Value() <= Approx(tol));
		CHECK(dist12.Value() <= Approx(tol));
		CHECK(curve1->Degree() == 3);
		CHECK(curve1->NPoles() == 7);
		CHECK(curve1->IsClosed() == true);
		CHECK(curve1->IsPeriodic() == true);
		for (int i = 0; i < points.size(); i++)
		{
			double maxValue = -1.0;
			bool res;
			GeomAPIProjectPointOnCurve3 prop(points[i], curve2);
			double param = prop.LowerDistanceParameter();
			if (maxValue > param)
			{
				res = false;
			}
			else
			{
				maxValue = param;
				res = true;
			}
			CHECK(res == true);
		}
		OCCTIO::OCCTTool::Write(MakeVertex(points[0]), outdir + "p1.brep");
		OCCTIO::OCCTTool::Write(MakeVertex(points[1]), outdir + "p2.brep");
		OCCTIO::OCCTTool::Write(MakeVertex(points[2]), outdir + "p3.brep");
		OCCTIO::OCCTTool::Write(MakeVertex(points[3]), outdir + "p4.brep");
		OCCTIO::OCCTTool::Write(MakeVertex(points[4]), outdir + "p5.brep");
		OCCTIO::OCCTTool::Write(MakeVertex(points[5]), outdir + "p6.brep");
		OCCTIO::OCCTTool::Write(MakeVertex(points[6]), outdir + "p7.brep");
		OCCTIO::OCCTTool::Write(MakeVertex(points[7]), outdir + "p8.brep");
		OCCTIO::OCCTTool::Write(MakeVertex(points[8]), outdir + "p9.brep");
		OCCTIO::OCCTTool::Write(MakeVertex(points[9]), outdir + "p10.brep");
		OCCTIO::OCCTTool::Write(MakeVertex(points[10]), outdir + "p11.brep");
		OCCTIO::OCCTTool::Write(MakeVertex(points[11]), outdir + "p12.brep");
		OCCTIO::OCCTTool::Write(MakeEdge(curve2), outdir + "result.brep");
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static std::pair<std::shared_ptr<Geom3BSplineCurve>, std::shared_ptr<Geom2BSplineCurve>> JoinCurves( const std::vector<std::shared_ptr<Geom3BSplineCurve>>& curves, const std::vector<std::shared_ptr<Geom2BSplineCurve>>& curve2ds, const std::vector<bool>& isReverse, bool isPeriodic),
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <nurbs/NURBSAPIJoin.hpp>
#include <topology/TopoEdge.hpp>
#include <topology/TopoTool.hpp>
#include <nurbs/NURBSAPIExplode.hpp>
#include <common/Precision.hpp>
#include <common/CartesianCoordinateSystem.hpp>
#include <geometry/Geom3BSplineCurve.hpp>
#include <nurbs/NURBSAPIJoin.hpp>
#include <geometry/Geom3BSplineCurve.hpp>
#include <geometry/Geom3BSplineSurface.hpp>
#include <topology/TopoFace.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeFace.hpp>
#include <nurbs/NURBSAPIInterpolate.hpp>
TEST_CASE("bug1: JoinCurve http :
{
	OUTPUT_DIRECTORY(nurbs, Join/bug468);
	double eps = 1e-4;
	string filedir = INPUT_PATH_PREFIX"./TestNURBS/TestJoinSurface/";
	std::vector<std::shared_ptr<Geom3BSplineSurface>> surfaces;
	surfaces.push_back(ReadBRepSurface(filedir + "surface0.brep"));
	surfaces.push_back(ReadBRepSurface(filedir + "surface1.brep"));
	surfaces.push_back(ReadBRepSurface(filedir + "surface2.brep"));
	surfaces.push_back(ReadBRepSurface(filedir + "surface3.brep"));
	auto [sortedSurfaces, isUIso, isFrontBackReverse, isIsoReverse, isLocalUPeriodic, isLocalVPeriodic] = NURBSAPIJoin::JoinSurfacesPrepare(surfaces, 0.0001);
	auto [isSucceed, result] = NURBSAPIJoin::JoinSurfaces(sortedSurfaces, isUIso, isFrontBackReverse, isIsoReverse, isLocalUPeriodic, isLocalVPeriodic);
	Throw_Construction_Error_if(!isSucceed, "failed");
	auto explodeResult = NURBSAPIExplode::ExplodeSurface(result);
	TopoShape f1 = MakeFace(surfaces[0], 0.0);
	TopoShape f2 = MakeFace(surfaces[1], 0.0);
	TopoShape f3 = MakeFace(surfaces[2], 0.0);
	TopoShape f4 = MakeFace(surfaces[3], 0.0);
	TopoShape f = MakeFace(result, 0.0);
	GlobalProperty props1, props2, props3, props4, props5, props6, props7, props8;
	double surf1 = GetSurfaceProperties(f1, props1, true, false);
	double surf2 = GetSurfaceProperties(f2, props2, true, false);
	double surf3 = GetSurfaceProperties(f3, props3, true, false);
	double surf4 = GetSurfaceProperties(f4, props4, true, false);
	double surface = GetSurfacePropertiesEps(f, props5, eps, true);
	double surf = surf1 + surf2 + surf3 + surf4;
	double dif = abs(surface - surf);
	CHECK(GetTopoCount(MakeFace(result, 0.0), ShapeType::Face) == 1);
	CHECK(dif < 0.1);
	OCCTIO::OCCTTool::Write(MakeFace(surfaces[0], 0.0), outdir + "surf1.brep");
	OCCTIO::OCCTTool::Write(MakeFace(surfaces[1], 0.0), outdir + "surf2.brep");
	OCCTIO::OCCTTool::Write(MakeFace(surfaces[2], 0.0), outdir + "surf3.brep");
	OCCTIO::OCCTTool::Write(MakeFace(surfaces[3], 0.0), outdir + "surf4.brep");
	OCCTIO::OCCTTool::Write(MakeFace(result, 0.0), outdir + "joinSurf.brep");
}
#include<catch.hpp>
#include<testHelper.h>
#include <nurbs/NURBSAPIJoin.hpp>
#include <topology/TopoEdge.hpp>
#include <topology/TopoTool.hpp>
#include <nurbs/NURBSAPIExplode.hpp>
#include <common/Precision.hpp>
#include <common/CartesianCoordinateSystem.hpp>
#include <geometry/Geom3BSplineCurve.hpp>
#include <nurbs/NURBSAPIJoin.hpp>
#include <geometry/Geom3BSplineCurve.hpp>
#include <geometry/Geom3BSplineSurface.hpp>
#include <topology/TopoFace.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeFace.hpp>
#include <nurbs/NURBSAPIInterpolate.hpp>
TEST_CASE("bug1: JoinCurve http :
{
	OUTPUT_DIRECTORY(nurbs, Join/bug468);
	double eps = 1e-4;
	string filedir = INPUT_PATH_PREFIX"./TestNURBS/TestJoinSurface/";
	std::vector<std::shared_ptr<Geom3BSplineSurface>> surfaces;
	surfaces.push_back(ReadBRepSurface(filedir + "surface0.brep"));
	surfaces.push_back(ReadBRepSurface(filedir + "surface1.brep"));
	surfaces.push_back(ReadBRepSurface(filedir + "surface2.brep"));
	surfaces.push_back(ReadBRepSurface(filedir + "surface3.brep"));
	auto [sortedSurfaces, isUIso, isFrontBackReverse, isIsoReverse, isLocalUPeriodic, isLocalVPeriodic] = NURBSAPIJoin::JoinSurfacesPrepare(surfaces, 0.0001);
	auto [isSucceed, result] = NURBSAPIJoin::JoinSurfaces(sortedSurfaces, isUIso, isFrontBackReverse, isIsoReverse, isLocalUPeriodic, isLocalVPeriodic);
	Throw_Construction_Error_if(!isSucceed, "failed");
	auto explodeResult = NURBSAPIExplode::ExplodeSurface(result);
	TopoShape f1 = MakeFace(surfaces[0], 0.0);
	TopoShape f2 = MakeFace(surfaces[1], 0.0);
	TopoShape f3 = MakeFace(surfaces[2], 0.0);
	TopoShape f4 = MakeFace(surfaces[3], 0.0);
	TopoShape f = MakeFace(result, 0.0);
	GlobalProperty props1, props2, props3, props4, props5, props6, props7, props8;
	double surf1 = GetSurfaceProperties(f1, props1, true, false);
	double surf2 = GetSurfaceProperties(f2, props2, true, false);
	double surf3 = GetSurfaceProperties(f3, props3, true, false);
	double surf4 = GetSurfaceProperties(f4, props4, true, false);
	double surface = GetSurfacePropertiesEps(f, props5, eps, true);
	double surf = surf1 + surf2 + surf3 + surf4;
	double dif = abs(surface - surf);
	CHECK(GetTopoCount(MakeFace(result, 0.0), ShapeType::Face) == 1);
	CHECK(dif < 0.1);
	OCCTIO::OCCTTool::Write(MakeFace(surfaces[0], 0.0), outdir + "surf1.brep");
	OCCTIO::OCCTTool::Write(MakeFace(surfaces[1], 0.0), outdir + "surf2.brep");
	OCCTIO::OCCTTool::Write(MakeFace(surfaces[2], 0.0), outdir + "surf3.brep");
	OCCTIO::OCCTTool::Write(MakeFace(surfaces[3], 0.0), outdir + "surf4.brep");
	OCCTIO::OCCTTool::Write(MakeFace(result, 0.0), outdir + "joinSurf.brep");
;
	SECTION("isPeriodic")
	{
		OUTPUT_DIRECTORY(nurbs, Join/JoinCurve1);
		filename = "periodicCurve";
		std::vector<std::shared_ptr<Geom3BSplineCurve>> curves;
		for (int i = 0; i < 3; i++)
		{
			curves.push_back(ReadBRepCurve(filedir + filename + std::to_string(i) + ".brep"));
		}
		auto [sortedCurves, isReverse, isResultPeriodic] = NURBSAPIJoin::JoinCurvePrepare(curves, 0.0001);
		auto results = NURBSAPIJoin::JoinCurves(sortedCurves, isReverse, isResultPeriodic);
		int nresults = static_cast<int>(results.size());
		for (int i = 0; i < nresults; i++)
		{
			OCCTIO::OCCTTool::Write(MakeEdge(results[i]), outdir + "joinCurve" + to_string(i) + ".brep");
		}
		auto explodeResult = NURBSAPIExplode::ExplodeCurve(results.front());
		int expResults = static_cast<int>(explodeResult.size());
		for (int j = 0; j < expResults; j++)
		{
			OCCTIO::OCCTTool::Write(MakeEdge(explodeResult[j]), outdir + "expCurve" + to_string(j) + ".brep");
		}
		CHECK(results.size() == 1);
		CHECK(explodeResult.size() == 3);
		Point3 p1, p2, p3, p4;
		p1 = curves[0]->StartPoint();
		p2 = curves[2]->EndPoint();
		p3 = results[0]->StartPoint();
		p4 = results[0]->EndPoint();
		CHECK(p1.X() == Approx(p3.X()));
		CHECK(p1.Y() == Approx(p3.Y()));
		CHECK(p1.Z() == Approx(p3.Z()));
		CHECK(p2.X() == Approx(p4.X()));
		CHECK(p2.Y() == Approx(p4.Y()));
		CHECK(p2.Z() == Approx(p4.Z()));
		TopoShape c1 = MakeEdge(curves[0]);
		TopoShape c2 = MakeEdge(curves[1]);
		TopoShape c3 = MakeEdge(curves[2]);
		TopoShape c = MakeEdge(results[0]);
		TopoShape e1 = MakeEdge(explodeResult[0]);
		TopoShape e2 = MakeEdge(explodeResult[1]);
		TopoShape e3 = MakeEdge(explodeResult[2]);
		GlobalProperty props1, props2, props3, props4, props5, props6, props7;
		double len1 = GetLinearProperties(c1, props1, true, false);
		double len2 = GetLinearProperties(c2, props2, true, false);
		double len3 = GetLinearProperties(c3, props3, true, false);
		double joinLen = GetLinearProperties(c, props4, true, false);
		double exLen1 = GetLinearProperties(e1, props5, true, false);
		double exLen2 = GetLinearProperties(e2, props6, true, false);
		double exLen3 = GetLinearProperties(e3, props7, true, false);
		double cuvLen = len1 + len2 + len3;
		double len = abs(cuvLen - joinLen);
		double len11 = abs(len1 - exLen1);
		double len22 = abs(len2 - exLen2);
		double len33 = abs(len3 - exLen3);
		CHECK(len < 0.1);
		CHECK(len11 < 0.1);
		CHECK(len22 < 0.1);
		CHECK(len33 < 0.1);
		double res1 = NurbsSampleCurve(num, sTol,  curves[0], explodeResult[0]);
		double res2 = NurbsSampleCurve(num, sTol,  curves[1], explodeResult[1]);
		double res3 = NurbsSampleCurve(num, sTol,  curves[2], explodeResult[2]);
		CHECK(res1 <= ratio);
		CHECK(res2 <= ratio);
		CHECK(res3 <= ratio);
		double res4 = NurbsSampleCurve(num, sTol, curves[0], results[0]);
		double res5 = NurbsSampleCurve(num, sTol, curves[1], results[0]);
		double res6 = NurbsSampleCurve(num, sTol, curves[2], results[0]);
		CHECK(res4 <= ratio);
		CHECK(res5 <= ratio);
		CHECK(res6 <= ratio);
		OCCTIO::OCCTTool::Write(MakeEdge(curves[0]), outdir + "curve0.brep");
		OCCTIO::OCCTTool::Write(MakeEdge(curves[1]), outdir + "curve1.brep");
		OCCTIO::OCCTTool::Write(MakeEdge(curves[2]), outdir + "curve2.brep");
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static std::vector<std::shared_ptr<Geom3BSplineCurve>> JoinCurves( const std::vector<std::vector<std::shared_ptr<Geom3BSplineCurve>>>& curves, const std::vector<std::vector<bool>>& isReverse, const std::vector<bool>& isPeriodic),
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <nurbs/NURBSAPIJoin.hpp>
#include <topology/TopoEdge.hpp>
#include <topology/TopoTool.hpp>
#include <nurbs/NURBSAPIExplode.hpp>
#include <common/Precision.hpp>
#include <common/CartesianCoordinateSystem.hpp>
#include <geometry/Geom3BSplineCurve.hpp>
#include <nurbs/NURBSAPIJoin.hpp>
#include <geometry/Geom3BSplineCurve.hpp>
#include <geometry/Geom3BSplineSurface.hpp>
#include <topology/TopoFace.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeFace.hpp>
#include <nurbs/NURBSAPIInterpolate.hpp>
TEST_CASE("bug1: JoinCurve http :
{
	OUTPUT_DIRECTORY(nurbs, Join/bug468);
	double eps = 1e-4;
	string filedir = INPUT_PATH_PREFIX"./TestNURBS/TestJoinSurface/";
	std::vector<std::shared_ptr<Geom3BSplineSurface>> surfaces;
	surfaces.push_back(ReadBRepSurface(filedir + "surface0.brep"));
	surfaces.push_back(ReadBRepSurface(filedir + "surface1.brep"));
	surfaces.push_back(ReadBRepSurface(filedir + "surface2.brep"));
	surfaces.push_back(ReadBRepSurface(filedir + "surface3.brep"));
	auto [sortedSurfaces, isUIso, isFrontBackReverse, isIsoReverse, isLocalUPeriodic, isLocalVPeriodic] = NURBSAPIJoin::JoinSurfacesPrepare(surfaces, 0.0001);
	auto [isSucceed, result] = NURBSAPIJoin::JoinSurfaces(sortedSurfaces, isUIso, isFrontBackReverse, isIsoReverse, isLocalUPeriodic, isLocalVPeriodic);
	Throw_Construction_Error_if(!isSucceed, "failed");
	auto explodeResult = NURBSAPIExplode::ExplodeSurface(result);
	TopoShape f1 = MakeFace(surfaces[0], 0.0);
	TopoShape f2 = MakeFace(surfaces[1], 0.0);
	TopoShape f3 = MakeFace(surfaces[2], 0.0);
	TopoShape f4 = MakeFace(surfaces[3], 0.0);
	TopoShape f = MakeFace(result, 0.0);
	GlobalProperty props1, props2, props3, props4, props5, props6, props7, props8;
	double surf1 = GetSurfaceProperties(f1, props1, true, false);
	double surf2 = GetSurfaceProperties(f2, props2, true, false);
	double surf3 = GetSurfaceProperties(f3, props3, true, false);
	double surf4 = GetSurfaceProperties(f4, props4, true, false);
	double surface = GetSurfacePropertiesEps(f, props5, eps, true);
	double surf = surf1 + surf2 + surf3 + surf4;
	double dif = abs(surface - surf);
	CHECK(GetTopoCount(MakeFace(result, 0.0), ShapeType::Face) == 1);
	CHECK(dif < 0.1);
	OCCTIO::OCCTTool::Write(MakeFace(surfaces[0], 0.0), outdir + "surf1.brep");
	OCCTIO::OCCTTool::Write(MakeFace(surfaces[1], 0.0), outdir + "surf2.brep");
	OCCTIO::OCCTTool::Write(MakeFace(surfaces[2], 0.0), outdir + "surf3.brep");
	OCCTIO::OCCTTool::Write(MakeFace(surfaces[3], 0.0), outdir + "surf4.brep");
	OCCTIO::OCCTTool::Write(MakeFace(result, 0.0), outdir + "joinSurf.brep");
}
#include<catch.hpp>
#include<testHelper.h>
#include <nurbs/NURBSAPIJoin.hpp>
#include <topology/TopoEdge.hpp>
#include <topology/TopoTool.hpp>
#include <nurbs/NURBSAPIExplode.hpp>
#include <common/Precision.hpp>
#include <common/CartesianCoordinateSystem.hpp>
#include <geometry/Geom3BSplineCurve.hpp>
#include <nurbs/NURBSAPIJoin.hpp>
#include <geometry/Geom3BSplineCurve.hpp>
#include <geometry/Geom3BSplineSurface.hpp>
#include <topology/TopoFace.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeFace.hpp>
#include <nurbs/NURBSAPIInterpolate.hpp>
TEST_CASE("bug1: JoinCurve http :
{
	OUTPUT_DIRECTORY(nurbs, Join/bug468);
	double eps = 1e-4;
	string filedir = INPUT_PATH_PREFIX"./TestNURBS/TestJoinSurface/";
	std::vector<std::shared_ptr<Geom3BSplineSurface>> surfaces;
	surfaces.push_back(ReadBRepSurface(filedir + "surface0.brep"));
	surfaces.push_back(ReadBRepSurface(filedir + "surface1.brep"));
	surfaces.push_back(ReadBRepSurface(filedir + "surface2.brep"));
	surfaces.push_back(ReadBRepSurface(filedir + "surface3.brep"));
	auto [sortedSurfaces, isUIso, isFrontBackReverse, isIsoReverse, isLocalUPeriodic, isLocalVPeriodic] = NURBSAPIJoin::JoinSurfacesPrepare(surfaces, 0.0001);
	auto [isSucceed, result] = NURBSAPIJoin::JoinSurfaces(sortedSurfaces, isUIso, isFrontBackReverse, isIsoReverse, isLocalUPeriodic, isLocalVPeriodic);
	Throw_Construction_Error_if(!isSucceed, "failed");
	auto explodeResult = NURBSAPIExplode::ExplodeSurface(result);
	TopoShape f1 = MakeFace(surfaces[0], 0.0);
	TopoShape f2 = MakeFace(surfaces[1], 0.0);
	TopoShape f3 = MakeFace(surfaces[2], 0.0);
	TopoShape f4 = MakeFace(surfaces[3], 0.0);
	TopoShape f = MakeFace(result, 0.0);
	GlobalProperty props1, props2, props3, props4, props5, props6, props7, props8;
	double surf1 = GetSurfaceProperties(f1, props1, true, false);
	double surf2 = GetSurfaceProperties(f2, props2, true, false);
	double surf3 = GetSurfaceProperties(f3, props3, true, false);
	double surf4 = GetSurfaceProperties(f4, props4, true, false);
	double surface = GetSurfacePropertiesEps(f, props5, eps, true);
	double surf = surf1 + surf2 + surf3 + surf4;
	double dif = abs(surface - surf);
	CHECK(GetTopoCount(MakeFace(result, 0.0), ShapeType::Face) == 1);
	CHECK(dif < 0.1);
	OCCTIO::OCCTTool::Write(MakeFace(surfaces[0], 0.0), outdir + "surf1.brep");
	OCCTIO::OCCTTool::Write(MakeFace(surfaces[1], 0.0), outdir + "surf2.brep");
	OCCTIO::OCCTTool::Write(MakeFace(surfaces[2], 0.0), outdir + "surf3.brep");
	OCCTIO::OCCTTool::Write(MakeFace(surfaces[3], 0.0), outdir + "surf4.brep");
	OCCTIO::OCCTTool::Write(MakeFace(result, 0.0), outdir + "joinSurf.brep");
;
	SECTION("isPeriodic")
	{
		OUTPUT_DIRECTORY(nurbs, Join/JoinCurve1);
		filename = "periodicCurve";
		std::vector<std::shared_ptr<Geom3BSplineCurve>> curves;
		for (int i = 0; i < 3; i++)
		{
			curves.push_back(ReadBRepCurve(filedir + filename + std::to_string(i) + ".brep"));
		}
		auto [sortedCurves, isReverse, isResultPeriodic] = NURBSAPIJoin::JoinCurvePrepare(curves, 0.0001);
		auto results = NURBSAPIJoin::JoinCurves(sortedCurves, isReverse, isResultPeriodic);
		int nresults = static_cast<int>(results.size());
		for (int i = 0; i < nresults; i++)
		{
			OCCTIO::OCCTTool::Write(MakeEdge(results[i]), outdir + "joinCurve" + to_string(i) + ".brep");
		}
		auto explodeResult = NURBSAPIExplode::ExplodeCurve(results.front());
		int expResults = static_cast<int>(explodeResult.size());
		for (int j = 0; j < expResults; j++)
		{
			OCCTIO::OCCTTool::Write(MakeEdge(explodeResult[j]), outdir + "expCurve" + to_string(j) + ".brep");
		}
		CHECK(results.size() == 1);
		CHECK(explodeResult.size() == 3);
		Point3 p1, p2, p3, p4;
		p1 = curves[0]->StartPoint();
		p2 = curves[2]->EndPoint();
		p3 = results[0]->StartPoint();
		p4 = results[0]->EndPoint();
		CHECK(p1.X() == Approx(p3.X()));
		CHECK(p1.Y() == Approx(p3.Y()));
		CHECK(p1.Z() == Approx(p3.Z()));
		CHECK(p2.X() == Approx(p4.X()));
		CHECK(p2.Y() == Approx(p4.Y()));
		CHECK(p2.Z() == Approx(p4.Z()));
		TopoShape c1 = MakeEdge(curves[0]);
		TopoShape c2 = MakeEdge(curves[1]);
		TopoShape c3 = MakeEdge(curves[2]);
		TopoShape c = MakeEdge(results[0]);
		TopoShape e1 = MakeEdge(explodeResult[0]);
		TopoShape e2 = MakeEdge(explodeResult[1]);
		TopoShape e3 = MakeEdge(explodeResult[2]);
		GlobalProperty props1, props2, props3, props4, props5, props6, props7;
		double len1 = GetLinearProperties(c1, props1, true, false);
		double len2 = GetLinearProperties(c2, props2, true, false);
		double len3 = GetLinearProperties(c3, props3, true, false);
		double joinLen = GetLinearProperties(c, props4, true, false);
		double exLen1 = GetLinearProperties(e1, props5, true, false);
		double exLen2 = GetLinearProperties(e2, props6, true, false);
		double exLen3 = GetLinearProperties(e3, props7, true, false);
		double cuvLen = len1 + len2 + len3;
		double len = abs(cuvLen - joinLen);
		double len11 = abs(len1 - exLen1);
		double len22 = abs(len2 - exLen2);
		double len33 = abs(len3 - exLen3);
		CHECK(len < 0.1);
		CHECK(len11 < 0.1);
		CHECK(len22 < 0.1);
		CHECK(len33 < 0.1);
		double res1 = NurbsSampleCurve(num, sTol,  curves[0], explodeResult[0]);
		double res2 = NurbsSampleCurve(num, sTol,  curves[1], explodeResult[1]);
		double res3 = NurbsSampleCurve(num, sTol,  curves[2], explodeResult[2]);
		CHECK(res1 <= ratio);
		CHECK(res2 <= ratio);
		CHECK(res3 <= ratio);
		double res4 = NurbsSampleCurve(num, sTol, curves[0], results[0]);
		double res5 = NurbsSampleCurve(num, sTol, curves[1], results[0]);
		double res6 = NurbsSampleCurve(num, sTol, curves[2], results[0]);
		CHECK(res4 <= ratio);
		CHECK(res5 <= ratio);
		CHECK(res6 <= ratio);
		OCCTIO::OCCTTool::Write(MakeEdge(curves[0]), outdir + "curve0.brep");
		OCCTIO::OCCTTool::Write(MakeEdge(curves[1]), outdir + "curve1.brep");
		OCCTIO::OCCTTool::Write(MakeEdge(curves[2]), outdir + "curve2.brep");
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static std::shared_ptr<Geom3BSplineCurve> JoinCurves( const std::vector<std::shared_ptr<Geom3BSplineCurve>>& curves, const std::vector<bool>& isReverse, bool isPeriodic),
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <nurbs/NURBSAPIJoin.hpp>
#include <topology/TopoEdge.hpp>
#include <topology/TopoTool.hpp>
#include <nurbs/NURBSAPIExplode.hpp>
#include <common/Precision.hpp>
#include <common/CartesianCoordinateSystem.hpp>
#include <geometry/Geom3BSplineCurve.hpp>
#include <nurbs/NURBSAPIJoin.hpp>
#include <geometry/Geom3BSplineCurve.hpp>
#include <geometry/Geom3BSplineSurface.hpp>
#include <topology/TopoFace.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeFace.hpp>
#include <nurbs/NURBSAPIInterpolate.hpp>
TEST_CASE("bug1: JoinCurve http :
{
	OUTPUT_DIRECTORY(nurbs, Join/bug468);
	double eps = 1e-4;
	string filedir = INPUT_PATH_PREFIX"./TestNURBS/TestJoinSurface/";
	std::vector<std::shared_ptr<Geom3BSplineSurface>> surfaces;
	surfaces.push_back(ReadBRepSurface(filedir + "surface0.brep"));
	surfaces.push_back(ReadBRepSurface(filedir + "surface1.brep"));
	surfaces.push_back(ReadBRepSurface(filedir + "surface2.brep"));
	surfaces.push_back(ReadBRepSurface(filedir + "surface3.brep"));
	auto [sortedSurfaces, isUIso, isFrontBackReverse, isIsoReverse, isLocalUPeriodic, isLocalVPeriodic] = NURBSAPIJoin::JoinSurfacesPrepare(surfaces, 0.0001);
	auto [isSucceed, result] = NURBSAPIJoin::JoinSurfaces(sortedSurfaces, isUIso, isFrontBackReverse, isIsoReverse, isLocalUPeriodic, isLocalVPeriodic);
	Throw_Construction_Error_if(!isSucceed, "failed");
	auto explodeResult = NURBSAPIExplode::ExplodeSurface(result);
	TopoShape f1 = MakeFace(surfaces[0], 0.0);
	TopoShape f2 = MakeFace(surfaces[1], 0.0);
	TopoShape f3 = MakeFace(surfaces[2], 0.0);
	TopoShape f4 = MakeFace(surfaces[3], 0.0);
	TopoShape f = MakeFace(result, 0.0);
	GlobalProperty props1, props2, props3, props4, props5, props6, props7, props8;
	double surf1 = GetSurfaceProperties(f1, props1, true, false);
	double surf2 = GetSurfaceProperties(f2, props2, true, false);
	double surf3 = GetSurfaceProperties(f3, props3, true, false);
	double surf4 = GetSurfaceProperties(f4, props4, true, false);
	double surface = GetSurfacePropertiesEps(f, props5, eps, true);
	double surf = surf1 + surf2 + surf3 + surf4;
	double dif = abs(surface - surf);
	CHECK(GetTopoCount(MakeFace(result, 0.0), ShapeType::Face) == 1);
	CHECK(dif < 0.1);
	OCCTIO::OCCTTool::Write(MakeFace(surfaces[0], 0.0), outdir + "surf1.brep");
	OCCTIO::OCCTTool::Write(MakeFace(surfaces[1], 0.0), outdir + "surf2.brep");
	OCCTIO::OCCTTool::Write(MakeFace(surfaces[2], 0.0), outdir + "surf3.brep");
	OCCTIO::OCCTTool::Write(MakeFace(surfaces[3], 0.0), outdir + "surf4.brep");
	OCCTIO::OCCTTool::Write(MakeFace(result, 0.0), outdir + "joinSurf.brep");
}
#include<catch.hpp>
#include<testHelper.h>
#include <nurbs/NURBSAPIJoin.hpp>
#include <topology/TopoEdge.hpp>
#include <topology/TopoTool.hpp>
#include <nurbs/NURBSAPIExplode.hpp>
#include <common/Precision.hpp>
#include <common/CartesianCoordinateSystem.hpp>
#include <geometry/Geom3BSplineCurve.hpp>
#include <nurbs/NURBSAPIJoin.hpp>
#include <geometry/Geom3BSplineCurve.hpp>
#include <geometry/Geom3BSplineSurface.hpp>
#include <topology/TopoFace.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeFace.hpp>
#include <nurbs/NURBSAPIInterpolate.hpp>
TEST_CASE("bug1: JoinCurve http :
{
	OUTPUT_DIRECTORY(nurbs, Join/bug468);
	double eps = 1e-4;
	string filedir = INPUT_PATH_PREFIX"./TestNURBS/TestJoinSurface/";
	std::vector<std::shared_ptr<Geom3BSplineSurface>> surfaces;
	surfaces.push_back(ReadBRepSurface(filedir + "surface0.brep"));
	surfaces.push_back(ReadBRepSurface(filedir + "surface1.brep"));
	surfaces.push_back(ReadBRepSurface(filedir + "surface2.brep"));
	surfaces.push_back(ReadBRepSurface(filedir + "surface3.brep"));
	auto [sortedSurfaces, isUIso, isFrontBackReverse, isIsoReverse, isLocalUPeriodic, isLocalVPeriodic] = NURBSAPIJoin::JoinSurfacesPrepare(surfaces, 0.0001);
	auto [isSucceed, result] = NURBSAPIJoin::JoinSurfaces(sortedSurfaces, isUIso, isFrontBackReverse, isIsoReverse, isLocalUPeriodic, isLocalVPeriodic);
	Throw_Construction_Error_if(!isSucceed, "failed");
	auto explodeResult = NURBSAPIExplode::ExplodeSurface(result);
	TopoShape f1 = MakeFace(surfaces[0], 0.0);
	TopoShape f2 = MakeFace(surfaces[1], 0.0);
	TopoShape f3 = MakeFace(surfaces[2], 0.0);
	TopoShape f4 = MakeFace(surfaces[3], 0.0);
	TopoShape f = MakeFace(result, 0.0);
	GlobalProperty props1, props2, props3, props4, props5, props6, props7, props8;
	double surf1 = GetSurfaceProperties(f1, props1, true, false);
	double surf2 = GetSurfaceProperties(f2, props2, true, false);
	double surf3 = GetSurfaceProperties(f3, props3, true, false);
	double surf4 = GetSurfaceProperties(f4, props4, true, false);
	double surface = GetSurfacePropertiesEps(f, props5, eps, true);
	double surf = surf1 + surf2 + surf3 + surf4;
	double dif = abs(surface - surf);
	CHECK(GetTopoCount(MakeFace(result, 0.0), ShapeType::Face) == 1);
	CHECK(dif < 0.1);
	OCCTIO::OCCTTool::Write(MakeFace(surfaces[0], 0.0), outdir + "surf1.brep");
	OCCTIO::OCCTTool::Write(MakeFace(surfaces[1], 0.0), outdir + "surf2.brep");
	OCCTIO::OCCTTool::Write(MakeFace(surfaces[2], 0.0), outdir + "surf3.brep");
	OCCTIO::OCCTTool::Write(MakeFace(surfaces[3], 0.0), outdir + "surf4.brep");
	OCCTIO::OCCTTool::Write(MakeFace(result, 0.0), outdir + "joinSurf.brep");
;
	SECTION("isPeriodic")
	{
		OUTPUT_DIRECTORY(nurbs, Join/JoinCurve1);
		filename = "periodicCurve";
		std::vector<std::shared_ptr<Geom3BSplineCurve>> curves;
		for (int i = 0; i < 3; i++)
		{
			curves.push_back(ReadBRepCurve(filedir + filename + std::to_string(i) + ".brep"));
		}
		auto [sortedCurves, isReverse, isResultPeriodic] = NURBSAPIJoin::JoinCurvePrepare(curves, 0.0001);
		auto results = NURBSAPIJoin::JoinCurves(sortedCurves, isReverse, isResultPeriodic);
		int nresults = static_cast<int>(results.size());
		for (int i = 0; i < nresults; i++)
		{
			OCCTIO::OCCTTool::Write(MakeEdge(results[i]), outdir + "joinCurve" + to_string(i) + ".brep");
		}
		auto explodeResult = NURBSAPIExplode::ExplodeCurve(results.front());
		int expResults = static_cast<int>(explodeResult.size());
		for (int j = 0; j < expResults; j++)
		{
			OCCTIO::OCCTTool::Write(MakeEdge(explodeResult[j]), outdir + "expCurve" + to_string(j) + ".brep");
		}
		CHECK(results.size() == 1);
		CHECK(explodeResult.size() == 3);
		Point3 p1, p2, p3, p4;
		p1 = curves[0]->StartPoint();
		p2 = curves[2]->EndPoint();
		p3 = results[0]->StartPoint();
		p4 = results[0]->EndPoint();
		CHECK(p1.X() == Approx(p3.X()));
		CHECK(p1.Y() == Approx(p3.Y()));
		CHECK(p1.Z() == Approx(p3.Z()));
		CHECK(p2.X() == Approx(p4.X()));
		CHECK(p2.Y() == Approx(p4.Y()));
		CHECK(p2.Z() == Approx(p4.Z()));
		TopoShape c1 = MakeEdge(curves[0]);
		TopoShape c2 = MakeEdge(curves[1]);
		TopoShape c3 = MakeEdge(curves[2]);
		TopoShape c = MakeEdge(results[0]);
		TopoShape e1 = MakeEdge(explodeResult[0]);
		TopoShape e2 = MakeEdge(explodeResult[1]);
		TopoShape e3 = MakeEdge(explodeResult[2]);
		GlobalProperty props1, props2, props3, props4, props5, props6, props7;
		double len1 = GetLinearProperties(c1, props1, true, false);
		double len2 = GetLinearProperties(c2, props2, true, false);
		double len3 = GetLinearProperties(c3, props3, true, false);
		double joinLen = GetLinearProperties(c, props4, true, false);
		double exLen1 = GetLinearProperties(e1, props5, true, false);
		double exLen2 = GetLinearProperties(e2, props6, true, false);
		double exLen3 = GetLinearProperties(e3, props7, true, false);
		double cuvLen = len1 + len2 + len3;
		double len = abs(cuvLen - joinLen);
		double len11 = abs(len1 - exLen1);
		double len22 = abs(len2 - exLen2);
		double len33 = abs(len3 - exLen3);
		CHECK(len < 0.1);
		CHECK(len11 < 0.1);
		CHECK(len22 < 0.1);
		CHECK(len33 < 0.1);
		double res1 = NurbsSampleCurve(num, sTol,  curves[0], explodeResult[0]);
		double res2 = NurbsSampleCurve(num, sTol,  curves[1], explodeResult[1]);
		double res3 = NurbsSampleCurve(num, sTol,  curves[2], explodeResult[2]);
		CHECK(res1 <= ratio);
		CHECK(res2 <= ratio);
		CHECK(res3 <= ratio);
		double res4 = NurbsSampleCurve(num, sTol, curves[0], results[0]);
		double res5 = NurbsSampleCurve(num, sTol, curves[1], results[0]);
		double res6 = NurbsSampleCurve(num, sTol, curves[2], results[0]);
		CHECK(res4 <= ratio);
		CHECK(res5 <= ratio);
		CHECK(res6 <= ratio);
		OCCTIO::OCCTTool::Write(MakeEdge(curves[0]), outdir + "curve0.brep");
		OCCTIO::OCCTTool::Write(MakeEdge(curves[1]), outdir + "curve1.brep");
		OCCTIO::OCCTTool::Write(MakeEdge(curves[2]), outdir + "curve2.brep");
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static std::tuple<std::vector<std::shared_ptr<Geom3BSplineSurface>>, std::vector<bool>, std::vector<bool>, std::vector<bool>, bool, bool> JoinSurfacesPrepare(const std::vector<std::shared_ptr<Geom3BSplineSurface>>& surfaces, double tol),
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <nurbs/NURBSAPIJoin.hpp>
#include <topology/TopoEdge.hpp>
#include <topology/TopoTool.hpp>
#include <nurbs/NURBSAPIExplode.hpp>
#include <common/Precision.hpp>
#include <common/CartesianCoordinateSystem.hpp>
#include <geometry/Geom3BSplineCurve.hpp>
#include <nurbs/NURBSAPIJoin.hpp>
#include <geometry/Geom3BSplineCurve.hpp>
#include <geometry/Geom3BSplineSurface.hpp>
#include <topology/TopoFace.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeFace.hpp>
#include <nurbs/NURBSAPIInterpolate.hpp>
TEST_CASE("bug1: JoinCurve http :
{
	OUTPUT_DIRECTORY(nurbs, Join/bug468);
	double eps = 1e-4;
	string filedir = INPUT_PATH_PREFIX"./TestNURBS/TestJoinSurface/";
	std::vector<std::shared_ptr<Geom3BSplineSurface>> surfaces;
	surfaces.push_back(ReadBRepSurface(filedir + "surface0.brep"));
	surfaces.push_back(ReadBRepSurface(filedir + "surface1.brep"));
	surfaces.push_back(ReadBRepSurface(filedir + "surface2.brep"));
	surfaces.push_back(ReadBRepSurface(filedir + "surface3.brep"));
	auto [sortedSurfaces, isUIso, isFrontBackReverse, isIsoReverse, isLocalUPeriodic, isLocalVPeriodic] = NURBSAPIJoin::JoinSurfacesPrepare(surfaces, 0.0001);
	auto [isSucceed, result] = NURBSAPIJoin::JoinSurfaces(sortedSurfaces, isUIso, isFrontBackReverse, isIsoReverse, isLocalUPeriodic, isLocalVPeriodic);
	Throw_Construction_Error_if(!isSucceed, "failed");
	auto explodeResult = NURBSAPIExplode::ExplodeSurface(result);
	TopoShape f1 = MakeFace(surfaces[0], 0.0);
	TopoShape f2 = MakeFace(surfaces[1], 0.0);
	TopoShape f3 = MakeFace(surfaces[2], 0.0);
	TopoShape f4 = MakeFace(surfaces[3], 0.0);
	TopoShape f = MakeFace(result, 0.0);
	GlobalProperty props1, props2, props3, props4, props5, props6, props7, props8;
	double surf1 = GetSurfaceProperties(f1, props1, true, false);
	double surf2 = GetSurfaceProperties(f2, props2, true, false);
	double surf3 = GetSurfaceProperties(f3, props3, true, false);
	double surf4 = GetSurfaceProperties(f4, props4, true, false);
	double surface = GetSurfacePropertiesEps(f, props5, eps, true);
	double surf = surf1 + surf2 + surf3 + surf4;
	double dif = abs(surface - surf);
	CHECK(GetTopoCount(MakeFace(result, 0.0), ShapeType::Face) == 1);
	CHECK(dif < 0.1);
	OCCTIO::OCCTTool::Write(MakeFace(surfaces[0], 0.0), outdir + "surf1.brep");
	OCCTIO::OCCTTool::Write(MakeFace(surfaces[1], 0.0), outdir + "surf2.brep");
	OCCTIO::OCCTTool::Write(MakeFace(surfaces[2], 0.0), outdir + "surf3.brep");
	OCCTIO::OCCTTool::Write(MakeFace(surfaces[3], 0.0), outdir + "surf4.brep");
	OCCTIO::OCCTTool::Write(MakeFace(result, 0.0), outdir + "joinSurf.brep");
}
#include<catch.hpp>
#include<testHelper.h>
#include <nurbs/NURBSAPIJoin.hpp>
#include <topology/TopoEdge.hpp>
#include <topology/TopoTool.hpp>
#include <nurbs/NURBSAPIExplode.hpp>
#include <common/Precision.hpp>
#include <common/CartesianCoordinateSystem.hpp>
#include <geometry/Geom3BSplineCurve.hpp>
#include <nurbs/NURBSAPIJoin.hpp>
#include <geometry/Geom3BSplineCurve.hpp>
#include <geometry/Geom3BSplineSurface.hpp>
#include <topology/TopoFace.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeFace.hpp>
#include <nurbs/NURBSAPIInterpolate.hpp>
TEST_CASE("bug1: JoinCurve http :
{
	OUTPUT_DIRECTORY(nurbs, Join/bug468);
	double eps = 1e-4;
	string filedir = INPUT_PATH_PREFIX"./TestNURBS/TestJoinSurface/";
	std::vector<std::shared_ptr<Geom3BSplineSurface>> surfaces;
	surfaces.push_back(ReadBRepSurface(filedir + "surface0.brep"));
	surfaces.push_back(ReadBRepSurface(filedir + "surface1.brep"));
	surfaces.push_back(ReadBRepSurface(filedir + "surface2.brep"));
	surfaces.push_back(ReadBRepSurface(filedir + "surface3.brep"));
	auto [sortedSurfaces, isUIso, isFrontBackReverse, isIsoReverse, isLocalUPeriodic, isLocalVPeriodic] = NURBSAPIJoin::JoinSurfacesPrepare(surfaces, 0.0001);
	auto [isSucceed, result] = NURBSAPIJoin::JoinSurfaces(sortedSurfaces, isUIso, isFrontBackReverse, isIsoReverse, isLocalUPeriodic, isLocalVPeriodic);
	Throw_Construction_Error_if(!isSucceed, "failed");
	auto explodeResult = NURBSAPIExplode::ExplodeSurface(result);
	TopoShape f1 = MakeFace(surfaces[0], 0.0);
	TopoShape f2 = MakeFace(surfaces[1], 0.0);
	TopoShape f3 = MakeFace(surfaces[2], 0.0);
	TopoShape f4 = MakeFace(surfaces[3], 0.0);
	TopoShape f = MakeFace(result, 0.0);
	GlobalProperty props1, props2, props3, props4, props5, props6, props7, props8;
	double surf1 = GetSurfaceProperties(f1, props1, true, false);
	double surf2 = GetSurfaceProperties(f2, props2, true, false);
	double surf3 = GetSurfaceProperties(f3, props3, true, false);
	double surf4 = GetSurfaceProperties(f4, props4, true, false);
	double surface = GetSurfacePropertiesEps(f, props5, eps, true);
	double surf = surf1 + surf2 + surf3 + surf4;
	double dif = abs(surface - surf);
	CHECK(GetTopoCount(MakeFace(result, 0.0), ShapeType::Face) == 1);
	CHECK(dif < 0.1);
	OCCTIO::OCCTTool::Write(MakeFace(surfaces[0], 0.0), outdir + "surf1.brep");
	OCCTIO::OCCTTool::Write(MakeFace(surfaces[1], 0.0), outdir + "surf2.brep");
	OCCTIO::OCCTTool::Write(MakeFace(surfaces[2], 0.0), outdir + "surf3.brep");
	OCCTIO::OCCTTool::Write(MakeFace(surfaces[3], 0.0), outdir + "surf4.brep");
	OCCTIO::OCCTTool::Write(MakeFace(result, 0.0), outdir + "joinSurf.brep");
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static std::pair<bool, std::shared_ptr<Geom3BSplineSurface>> JoinSurfaces( const std::shared_ptr<Geom3BSplineSurface>& surface1, const std::shared_ptr<Geom3BSplineSurface>& surface2, bool isSurface1UIso, bool isSurface2UIso, bool isSurface1FrontBackReverse, bool isSurface2FrontBackReverse, bool isSurface1IsoReverse, bool isSurface2IsoReverse, bool isUPeriodic, bool isVPeriodic),
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <nurbs/NURBSAPIJoin.hpp>
#include <topology/TopoEdge.hpp>
#include <topology/TopoTool.hpp>
#include <nurbs/NURBSAPIExplode.hpp>
#include <common/Precision.hpp>
#include <common/CartesianCoordinateSystem.hpp>
#include <geometry/Geom3BSplineCurve.hpp>
#include <nurbs/NURBSAPIJoin.hpp>
#include <geometry/Geom3BSplineCurve.hpp>
#include <geometry/Geom3BSplineSurface.hpp>
#include <topology/TopoFace.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeFace.hpp>
#include <nurbs/NURBSAPIInterpolate.hpp>
TEST_CASE("bug1: JoinCurve http :
{
	OUTPUT_DIRECTORY(nurbs, Join/bug468);
	double eps = 1e-4;
	string filedir = INPUT_PATH_PREFIX"./TestNURBS/TestJoinSurface/";
	std::vector<std::shared_ptr<Geom3BSplineSurface>> surfaces;
	surfaces.push_back(ReadBRepSurface(filedir + "surface0.brep"));
	surfaces.push_back(ReadBRepSurface(filedir + "surface1.brep"));
	surfaces.push_back(ReadBRepSurface(filedir + "surface2.brep"));
	surfaces.push_back(ReadBRepSurface(filedir + "surface3.brep"));
	auto [sortedSurfaces, isUIso, isFrontBackReverse, isIsoReverse, isLocalUPeriodic, isLocalVPeriodic] = NURBSAPIJoin::JoinSurfacesPrepare(surfaces, 0.0001);
	auto [isSucceed, result] = NURBSAPIJoin::JoinSurfaces(sortedSurfaces, isUIso, isFrontBackReverse, isIsoReverse, isLocalUPeriodic, isLocalVPeriodic);
	Throw_Construction_Error_if(!isSucceed, "failed");
	auto explodeResult = NURBSAPIExplode::ExplodeSurface(result);
	TopoShape f1 = MakeFace(surfaces[0], 0.0);
	TopoShape f2 = MakeFace(surfaces[1], 0.0);
	TopoShape f3 = MakeFace(surfaces[2], 0.0);
	TopoShape f4 = MakeFace(surfaces[3], 0.0);
	TopoShape f = MakeFace(result, 0.0);
	GlobalProperty props1, props2, props3, props4, props5, props6, props7, props8;
	double surf1 = GetSurfaceProperties(f1, props1, true, false);
	double surf2 = GetSurfaceProperties(f2, props2, true, false);
	double surf3 = GetSurfaceProperties(f3, props3, true, false);
	double surf4 = GetSurfaceProperties(f4, props4, true, false);
	double surface = GetSurfacePropertiesEps(f, props5, eps, true);
	double surf = surf1 + surf2 + surf3 + surf4;
	double dif = abs(surface - surf);
	CHECK(GetTopoCount(MakeFace(result, 0.0), ShapeType::Face) == 1);
	CHECK(dif < 0.1);
	OCCTIO::OCCTTool::Write(MakeFace(surfaces[0], 0.0), outdir + "surf1.brep");
	OCCTIO::OCCTTool::Write(MakeFace(surfaces[1], 0.0), outdir + "surf2.brep");
	OCCTIO::OCCTTool::Write(MakeFace(surfaces[2], 0.0), outdir + "surf3.brep");
	OCCTIO::OCCTTool::Write(MakeFace(surfaces[3], 0.0), outdir + "surf4.brep");
	OCCTIO::OCCTTool::Write(MakeFace(result, 0.0), outdir + "joinSurf.brep");
}
#include<catch.hpp>
#include<testHelper.h>
#include <nurbs/NURBSAPIJoin.hpp>
#include <topology/TopoEdge.hpp>
#include <topology/TopoTool.hpp>
#include <nurbs/NURBSAPIExplode.hpp>
#include <common/Precision.hpp>
#include <common/CartesianCoordinateSystem.hpp>
#include <geometry/Geom3BSplineCurve.hpp>
#include <nurbs/NURBSAPIJoin.hpp>
#include <geometry/Geom3BSplineCurve.hpp>
#include <geometry/Geom3BSplineSurface.hpp>
#include <topology/TopoFace.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeFace.hpp>
#include <nurbs/NURBSAPIInterpolate.hpp>
TEST_CASE("bug1: JoinCurve http :
{
	OUTPUT_DIRECTORY(nurbs, Join/bug468);
	double eps = 1e-4;
	string filedir = INPUT_PATH_PREFIX"./TestNURBS/TestJoinSurface/";
	std::vector<std::shared_ptr<Geom3BSplineSurface>> surfaces;
	surfaces.push_back(ReadBRepSurface(filedir + "surface0.brep"));
	surfaces.push_back(ReadBRepSurface(filedir + "surface1.brep"));
	surfaces.push_back(ReadBRepSurface(filedir + "surface2.brep"));
	surfaces.push_back(ReadBRepSurface(filedir + "surface3.brep"));
	auto [sortedSurfaces, isUIso, isFrontBackReverse, isIsoReverse, isLocalUPeriodic, isLocalVPeriodic] = NURBSAPIJoin::JoinSurfacesPrepare(surfaces, 0.0001);
	auto [isSucceed, result] = NURBSAPIJoin::JoinSurfaces(sortedSurfaces, isUIso, isFrontBackReverse, isIsoReverse, isLocalUPeriodic, isLocalVPeriodic);
	Throw_Construction_Error_if(!isSucceed, "failed");
	auto explodeResult = NURBSAPIExplode::ExplodeSurface(result);
	TopoShape f1 = MakeFace(surfaces[0], 0.0);
	TopoShape f2 = MakeFace(surfaces[1], 0.0);
	TopoShape f3 = MakeFace(surfaces[2], 0.0);
	TopoShape f4 = MakeFace(surfaces[3], 0.0);
	TopoShape f = MakeFace(result, 0.0);
	GlobalProperty props1, props2, props3, props4, props5, props6, props7, props8;
	double surf1 = GetSurfaceProperties(f1, props1, true, false);
	double surf2 = GetSurfaceProperties(f2, props2, true, false);
	double surf3 = GetSurfaceProperties(f3, props3, true, false);
	double surf4 = GetSurfaceProperties(f4, props4, true, false);
	double surface = GetSurfacePropertiesEps(f, props5, eps, true);
	double surf = surf1 + surf2 + surf3 + surf4;
	double dif = abs(surface - surf);
	CHECK(GetTopoCount(MakeFace(result, 0.0), ShapeType::Face) == 1);
	CHECK(dif < 0.1);
	OCCTIO::OCCTTool::Write(MakeFace(surfaces[0], 0.0), outdir + "surf1.brep");
	OCCTIO::OCCTTool::Write(MakeFace(surfaces[1], 0.0), outdir + "surf2.brep");
	OCCTIO::OCCTTool::Write(MakeFace(surfaces[2], 0.0), outdir + "surf3.brep");
	OCCTIO::OCCTTool::Write(MakeFace(surfaces[3], 0.0), outdir + "surf4.brep");
	OCCTIO::OCCTTool::Write(MakeFace(result, 0.0), outdir + "joinSurf.brep");
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static std::pair<bool, std::shared_ptr<Geom3BSplineSurface>> JoinSurfaces( const std::vector<std::shared_ptr<Geom3BSplineSurface>>& surfaces, const std::vector<bool>& isUIso, const std::vector<bool>& isFrontBackReverse, const std::vector<bool>& isIsoReverse, bool isUPeriodic, bool isVPeriodic),
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <nurbs/NURBSAPIJoin.hpp>
#include <topology/TopoEdge.hpp>
#include <topology/TopoTool.hpp>
#include <nurbs/NURBSAPIExplode.hpp>
#include <common/Precision.hpp>
#include <common/CartesianCoordinateSystem.hpp>
#include <geometry/Geom3BSplineCurve.hpp>
#include <nurbs/NURBSAPIJoin.hpp>
#include <geometry/Geom3BSplineCurve.hpp>
#include <geometry/Geom3BSplineSurface.hpp>
#include <topology/TopoFace.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeFace.hpp>
#include <nurbs/NURBSAPIInterpolate.hpp>
TEST_CASE("bug1: JoinCurve http :
{
	OUTPUT_DIRECTORY(nurbs, Join/bug468);
	double eps = 1e-4;
	string filedir = INPUT_PATH_PREFIX"./TestNURBS/TestJoinSurface/";
	std::vector<std::shared_ptr<Geom3BSplineSurface>> surfaces;
	surfaces.push_back(ReadBRepSurface(filedir + "surface0.brep"));
	surfaces.push_back(ReadBRepSurface(filedir + "surface1.brep"));
	surfaces.push_back(ReadBRepSurface(filedir + "surface2.brep"));
	surfaces.push_back(ReadBRepSurface(filedir + "surface3.brep"));
	auto [sortedSurfaces, isUIso, isFrontBackReverse, isIsoReverse, isLocalUPeriodic, isLocalVPeriodic] = NURBSAPIJoin::JoinSurfacesPrepare(surfaces, 0.0001);
	auto [isSucceed, result] = NURBSAPIJoin::JoinSurfaces(sortedSurfaces, isUIso, isFrontBackReverse, isIsoReverse, isLocalUPeriodic, isLocalVPeriodic);
	Throw_Construction_Error_if(!isSucceed, "failed");
	auto explodeResult = NURBSAPIExplode::ExplodeSurface(result);
	TopoShape f1 = MakeFace(surfaces[0], 0.0);
	TopoShape f2 = MakeFace(surfaces[1], 0.0);
	TopoShape f3 = MakeFace(surfaces[2], 0.0);
	TopoShape f4 = MakeFace(surfaces[3], 0.0);
	TopoShape f = MakeFace(result, 0.0);
	GlobalProperty props1, props2, props3, props4, props5, props6, props7, props8;
	double surf1 = GetSurfaceProperties(f1, props1, true, false);
	double surf2 = GetSurfaceProperties(f2, props2, true, false);
	double surf3 = GetSurfaceProperties(f3, props3, true, false);
	double surf4 = GetSurfaceProperties(f4, props4, true, false);
	double surface = GetSurfacePropertiesEps(f, props5, eps, true);
	double surf = surf1 + surf2 + surf3 + surf4;
	double dif = abs(surface - surf);
	CHECK(GetTopoCount(MakeFace(result, 0.0), ShapeType::Face) == 1);
	CHECK(dif < 0.1);
	OCCTIO::OCCTTool::Write(MakeFace(surfaces[0], 0.0), outdir + "surf1.brep");
	OCCTIO::OCCTTool::Write(MakeFace(surfaces[1], 0.0), outdir + "surf2.brep");
	OCCTIO::OCCTTool::Write(MakeFace(surfaces[2], 0.0), outdir + "surf3.brep");
	OCCTIO::OCCTTool::Write(MakeFace(surfaces[3], 0.0), outdir + "surf4.brep");
	OCCTIO::OCCTTool::Write(MakeFace(result, 0.0), outdir + "joinSurf.brep");
}
#include<catch.hpp>
#include<testHelper.h>
#include <nurbs/NURBSAPIJoin.hpp>
#include <topology/TopoEdge.hpp>
#include <topology/TopoTool.hpp>
#include <nurbs/NURBSAPIExplode.hpp>
#include <common/Precision.hpp>
#include <common/CartesianCoordinateSystem.hpp>
#include <geometry/Geom3BSplineCurve.hpp>
#include <nurbs/NURBSAPIJoin.hpp>
#include <geometry/Geom3BSplineCurve.hpp>
#include <geometry/Geom3BSplineSurface.hpp>
#include <topology/TopoFace.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeFace.hpp>
#include <nurbs/NURBSAPIInterpolate.hpp>
TEST_CASE("bug1: JoinCurve http :
{
	OUTPUT_DIRECTORY(nurbs, Join/bug468);
	double eps = 1e-4;
	string filedir = INPUT_PATH_PREFIX"./TestNURBS/TestJoinSurface/";
	std::vector<std::shared_ptr<Geom3BSplineSurface>> surfaces;
	surfaces.push_back(ReadBRepSurface(filedir + "surface0.brep"));
	surfaces.push_back(ReadBRepSurface(filedir + "surface1.brep"));
	surfaces.push_back(ReadBRepSurface(filedir + "surface2.brep"));
	surfaces.push_back(ReadBRepSurface(filedir + "surface3.brep"));
	auto [sortedSurfaces, isUIso, isFrontBackReverse, isIsoReverse, isLocalUPeriodic, isLocalVPeriodic] = NURBSAPIJoin::JoinSurfacesPrepare(surfaces, 0.0001);
	auto [isSucceed, result] = NURBSAPIJoin::JoinSurfaces(sortedSurfaces, isUIso, isFrontBackReverse, isIsoReverse, isLocalUPeriodic, isLocalVPeriodic);
	Throw_Construction_Error_if(!isSucceed, "failed");
	auto explodeResult = NURBSAPIExplode::ExplodeSurface(result);
	TopoShape f1 = MakeFace(surfaces[0], 0.0);
	TopoShape f2 = MakeFace(surfaces[1], 0.0);
	TopoShape f3 = MakeFace(surfaces[2], 0.0);
	TopoShape f4 = MakeFace(surfaces[3], 0.0);
	TopoShape f = MakeFace(result, 0.0);
	GlobalProperty props1, props2, props3, props4, props5, props6, props7, props8;
	double surf1 = GetSurfaceProperties(f1, props1, true, false);
	double surf2 = GetSurfaceProperties(f2, props2, true, false);
	double surf3 = GetSurfaceProperties(f3, props3, true, false);
	double surf4 = GetSurfaceProperties(f4, props4, true, false);
	double surface = GetSurfacePropertiesEps(f, props5, eps, true);
	double surf = surf1 + surf2 + surf3 + surf4;
	double dif = abs(surface - surf);
	CHECK(GetTopoCount(MakeFace(result, 0.0), ShapeType::Face) == 1);
	CHECK(dif < 0.1);
	OCCTIO::OCCTTool::Write(MakeFace(surfaces[0], 0.0), outdir + "surf1.brep");
	OCCTIO::OCCTTool::Write(MakeFace(surfaces[1], 0.0), outdir + "surf2.brep");
	OCCTIO::OCCTTool::Write(MakeFace(surfaces[2], 0.0), outdir + "surf3.brep");
	OCCTIO::OCCTTool::Write(MakeFace(surfaces[3], 0.0), outdir + "surf4.brep");
	OCCTIO::OCCTTool::Write(MakeFace(result, 0.0), outdir + "joinSurf.brep");
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static std::pair<NURBSSweepStatus, std::shared_ptr<Geom3BSplineSurface>> SweepWithTwoLimits(const std::shared_ptr<Geom3BSplineCurve>& guide1, const std::shared_ptr<Geom3BSplineCurve>& guide2, const std::shared_ptr<Geom3BSplineCurve>& spine, double spineLeftBound, double spineRightBound, const LawFunction& length1Law, const LawFunction& length2Law),
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <filesystem>
#include <fstream>
#include <random>
#include <sstream>
#include <nurbs/NURBSAPIGetGeometry.hpp>
#include <nurbs/NURBSAPIConicalSweep.hpp>
#include <boolean/BoolBRepCut.hpp>
#include <common/CartesianCoordinateSystem.hpp>
#include <common/IndexMap.hpp>
#include <common/QuaternionT.hpp>
#include <geomAlgo/LawBSpline.hpp>
#include <geomAlgo/LawConstant.hpp>
#include <nurbs/NURBSAPISmooth.hpp>
#include <geomAlgo/MakeConic2FromConstraints.hpp>
#include <geometry/Adaptor3CurveOnSurface.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/AdaptorGeom3Surface.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/Geom2Circle.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/Geom2Hyperbola.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom3BSplineCurve.hpp>
#include <geometry/Geom3BSplineSurface.hpp>
#include <geometry/Geom3Circle.hpp>
#include <geometry/Geom3Line.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
#include <geometry/Geom3Plane.hpp>
#include <geometry/Geom3SphericalSurface.hpp>
#include <geometry/Geom3Surface.hpp>
#include <geometry/Geom3TrimmedCurve.hpp>
#include <geometry/Geom3TrimmedSurface.hpp>
#include <geometry/GeomAPIExtremaCurveCurve3.hpp>
#include <geometry/GeomAPIProjectPointOnCurve2.hpp>
#include <geometry/GeomAPIProjectPointOnCurve3.hpp>
#include <geometry/GeomAPIProjectPointOnSurface.hpp>
#include <geometry/GeometryTool.hpp>
#include <geometry/GlobalProperty.hpp>
#include <healing/ShapeFixTool.hpp>
#include <io/STLTool.hpp>
#include <math/Sphere.hpp>
#include <math/TriangularMesh.hpp>
#include <modeling/CopyShape.hpp>
#include <modeling/MakeBox.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeFace.hpp>
#include <modeling/MakePrism.hpp>
#include <modeling/MakeRevol.hpp>
#include <modeling/MakeShapeTool.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeWire.hpp>
#include <modeling/TransformShape.hpp>
#include <nurbs/NURBSAPIApprox.hpp>
#include <nurbs/NURBSAPIBuildCurve.hpp>
#include <nurbs/NURBSAPICircularSweep.hpp>
#include <nurbs/NURBSAPIConvert.hpp>
#include <nurbs/NURBSAPICurveNetworkSurface.hpp>
#include <nurbs/NURBSAPIExplicitSweep.hpp>
#include <nurbs/NURBSAPIExplode.hpp>
#include <nurbs/NURBSAPIExtend.hpp>
#include <nurbs/NURBSAPIInterpolate.hpp>
#include <nurbs/NURBSAPIJoin.hpp>
#include <nurbs/NURBSAPILinearSweep.hpp>
#include <nurbs/NURBSAPILoft.hpp>
#include <nurbs/NURBSAPIMakeNURBSFromBoundaries.hpp>
#include <nurbs/NURBSAPIMatch.hpp>
#include <nurbs/NURBSAPIModifyEndToPlane.hpp>
#include <nurbs/NURBSAPIOffsetCurveOnSurface.hpp>
#include <nurbs/NURBSAPIProject.hpp>
#include <nurbs/NURBSAPIRebuild.hpp>
#include <nurbs/NURBSAPIReplaceEdge.hpp>
#include <nurbs/NURBSAPISweep.hpp>
#include <nurbs/NURBSAPISweep2.hpp>
#include <nurbs/NURBSAPISweepRotation.hpp>
#include <nurbs/NURBSAPITrim.hpp>
#include <nurbs/NURBSAPIUntrim.hpp>
#include <nurbs/NURBSLinearSweepWithDraftDirectionLength.hpp>
#include <occtio/OCCTTool.hpp>
#include <offset/MakePipe.hpp>
#include <offset/MakePipeShell.hpp>
#include <topology/BRepAdaptorCurve2.hpp>
#include <topology/BRepAdaptorCurve3.hpp>
#include <topology/BRepAdaptorSurface.hpp>
#include <topology/BRepGlobalProperty.hpp>
#include <topology/BRepTool.hpp>
#include <topology/TopoBuilder.hpp>
#include <topology/TopoCompound.hpp>
#include <topology/TopoEdge.hpp>
#include <topology/TopoExplorer.hpp>
#include <topology/TopoExplorerTool.hpp>
#include <topology/TopoFace.hpp>
#include <topology/TopoShape.hpp>
#include <topology/TopoShell.hpp>
#include <topology/TopoTool.hpp>
#include <topology/TopoVertex.hpp>
#include <topology/TopoWire.hpp>
#include <topology/WireExplorer.hpp>
#include <topomesh/BRepMeshIncrementalMesh.hpp>
#include <nurbs/NURBSAPIBlend.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
#include <math/LineT.hpp>
#include <hatch/BRepClassificationTools.hpp>
using namespace AMCAX;
namespace
{
	std::shared_ptr<Geom3BSplineCurve> CurveChooser(const int id, const std::shared_ptr<Geom3BSplineCurve>& curve0, const std::shared_ptr<Geom3BSplineCurve>& curve1, const std::shared_ptr<Geom3BSplineCurve>& curve2)
	{
		std::shared_ptr<Geom3BSplineCurve> result;
		switch (id)
		{
		case 0:
		{
			result = curve0;
			break;
		}
		case 1:
		{
			result = curve1;
			break;
		}
		case 2:
		{
			result = curve2;
			break;
		}
		}
		return result;
	}
} 
#include<catch.hpp>
#include<testHelper.h>
#include <filesystem>
#include <fstream>
#include <random>
#include <sstream>
#include <nurbs/NURBSAPIGetGeometry.hpp>
#include <nurbs/NURBSAPIConicalSweep.hpp>
#include <boolean/BoolBRepCut.hpp>
#include <common/CartesianCoordinateSystem.hpp>
#include <common/IndexMap.hpp>
#include <common/QuaternionT.hpp>
#include <geomAlgo/LawBSpline.hpp>
#include <geomAlgo/LawConstant.hpp>
#include <nurbs/NURBSAPISmooth.hpp>
#include <geomAlgo/MakeConic2FromConstraints.hpp>
#include <geometry/Adaptor3CurveOnSurface.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/AdaptorGeom3Surface.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/Geom2Circle.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/Geom2Hyperbola.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom3BSplineCurve.hpp>
#include <geometry/Geom3BSplineSurface.hpp>
#include <geometry/Geom3Circle.hpp>
#include <geometry/Geom3Line.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
#include <geometry/Geom3Plane.hpp>
#include <geometry/Geom3SphericalSurface.hpp>
#include <geometry/Geom3Surface.hpp>
#include <geometry/Geom3TrimmedCurve.hpp>
#include <geometry/Geom3TrimmedSurface.hpp>
#include <geometry/GeomAPIExtremaCurveCurve3.hpp>
#include <geometry/GeomAPIProjectPointOnCurve2.hpp>
#include <geometry/GeomAPIProjectPointOnCurve3.hpp>
#include <geometry/GeomAPIProjectPointOnSurface.hpp>
#include <geometry/GeometryTool.hpp>
#include <geometry/GlobalProperty.hpp>
#include <healing/ShapeFixTool.hpp>
#include <io/STLTool.hpp>
#include <math/Sphere.hpp>
#include <math/TriangularMesh.hpp>
#include <modeling/CopyShape.hpp>
#include <modeling/MakeBox.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeFace.hpp>
#include <modeling/MakePrism.hpp>
#include <modeling/MakeRevol.hpp>
#include <modeling/MakeShapeTool.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeWire.hpp>
#include <modeling/TransformShape.hpp>
#include <nurbs/NURBSAPIApprox.hpp>
#include <nurbs/NURBSAPIBuildCurve.hpp>
#include <nurbs/NURBSAPICircularSweep.hpp>
#include <nurbs/NURBSAPIConvert.hpp>
#include <nurbs/NURBSAPICurveNetworkSurface.hpp>
#include <nurbs/NURBSAPIExplicitSweep.hpp>
#include <nurbs/NURBSAPIExplode.hpp>
#include <nurbs/NURBSAPIExtend.hpp>
#include <nurbs/NURBSAPIInterpolate.hpp>
#include <nurbs/NURBSAPIJoin.hpp>
#include <nurbs/NURBSAPILinearSweep.hpp>
#include <nurbs/NURBSAPILoft.hpp>
#include <nurbs/NURBSAPIMakeNURBSFromBoundaries.hpp>
#include <nurbs/NURBSAPIMatch.hpp>
#include <nurbs/NURBSAPIModifyEndToPlane.hpp>
#include <nurbs/NURBSAPIOffsetCurveOnSurface.hpp>
#include <nurbs/NURBSAPIProject.hpp>
#include <nurbs/NURBSAPIRebuild.hpp>
#include <nurbs/NURBSAPIReplaceEdge.hpp>
#include <nurbs/NURBSAPISweep.hpp>
#include <nurbs/NURBSAPISweep2.hpp>
#include <nurbs/NURBSAPISweepRotation.hpp>
#include <nurbs/NURBSAPITrim.hpp>
#include <nurbs/NURBSAPIUntrim.hpp>
#include <nurbs/NURBSLinearSweepWithDraftDirectionLength.hpp>
#include <occtio/OCCTTool.hpp>
#include <offset/MakePipe.hpp>
#include <offset/MakePipeShell.hpp>
#include <topology/BRepAdaptorCurve2.hpp>
#include <topology/BRepAdaptorCurve3.hpp>
#include <topology/BRepAdaptorSurface.hpp>
#include <topology/BRepGlobalProperty.hpp>
#include <topology/BRepTool.hpp>
#include <topology/TopoBuilder.hpp>
#include <topology/TopoCompound.hpp>
#include <topology/TopoEdge.hpp>
#include <topology/TopoExplorer.hpp>
#include <topology/TopoExplorerTool.hpp>
#include <topology/TopoFace.hpp>
#include <topology/TopoShape.hpp>
#include <topology/TopoShell.hpp>
#include <topology/TopoTool.hpp>
#include <topology/TopoVertex.hpp>
#include <topology/TopoWire.hpp>
#include <topology/WireExplorer.hpp>
#include <topomesh/BRepMeshIncrementalMesh.hpp>
#include <nurbs/NURBSAPIBlend.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
#include <math/LineT.hpp>
#include <hatch/BRepClassificationTools.hpp>
using namespace AMCAX;
namespace
{
	std::shared_ptr<Geom3BSplineCurve> CurveChooser(const int id, const std::shared_ptr<Geom3BSplineCurve>& curve0, const std::shared_ptr<Geom3BSplineCurve>& curve1, const std::shared_ptr<Geom3BSplineCurve>& curve2)
	{
		std::shared_ptr<Geom3BSplineCurve> result;
		switch (id)
		{
		case 0:
		{
			result = curve0;
			break;
		}
		case 1:
		{
			result = curve1;
			break;
		}
		case 2:
		{
			result = curve2;
			break;
		}
		}
		return result;
	}
;
	SECTION("TestLinearSweepWithTwoLimits()")
	{
		std::string filedir = INPUT_PATH_PREFIX "/TestNURBS/TestLinearSweepWithTwoLimits/";
		auto guide1 = ReadBRepCurve(filedir + "guide1.brep");
		CHECK(OCCTIO::OCCTTool::Write(MakeEdge(guide1), OUTPUT_PATH_PREFIX "TestLinearSweepWithTwoLimits_guide1.brep"));
		auto guide2 = ReadBRepCurve(filedir + "guide2.brep");
		CHECK(OCCTIO::OCCTTool::Write(MakeEdge(guide2), OUTPUT_PATH_PREFIX "TestLinearSweepWithTwoLimits_guide2.brep"));
		auto spineFP = ReadBRepPoint(filedir + "spineFP.brep");
		auto spineLP = ReadBRepPoint(filedir + "spineLP.brep");
		std::vector<Point3> poles;
		poles.push_back(spineFP);
		poles.push_back(spineLP);
		auto spine = NURBSAPIBuildCurve::BuildCurve(poles, 1, false);
		CHECK(OCCTIO::OCCTTool::Write(MakeEdge(spine), OUTPUT_PATH_PREFIX "TestLinearSweepWithTwoLimits_spine.brep"));
		LawConstant law1;
		law1.Set(0.1, 0.0, 1.0);
		LawConstant law2;
		law2.Set(0.2, 0.0, 1.0);
		auto [status, surface] = NURBSAPILinearSweep::SweepWithTwoLimits(guide1, guide2, spine, spine->FirstParameter(), spine->LastParameter(), law1, law2);
		CHECK(status == NURBSSweepStatus::Success);
		if (status == NURBSSweepStatus::Success)
		{
			CHECK(OCCTIO::OCCTTool::Write(MakeFace(surface, 0.0), OUTPUT_PATH_PREFIX "TestLinearSweepWithTwoLimits_result.brep"));
			CHECK(IsCurveOnSurf(1000, 0.3, guide1, surface, 0.2));
			CHECK(IsCurveOnSurf(1000, 0.2, guide2, surface, 0.2));
			AMCAX::BRepExtremaDistShapeShape len1(MakeFace(surface, 0.0), MakeEdge(guide1));
			AMCAX::BRepExtremaDistShapeShape len2(MakeFace(surface, 0.0), MakeEdge(guide2));
			CHECK(len1.Value() == Approx(0.0).margin(0.1));
			CHECK(len2.Value() == Approx(0.0).margin(0.1));
		}
		guide1->IncreaseDegree(11);
		guide2->IncreaseDegree(11);
		spine->IncreaseDegree(11);
		auto [status1, surface1] = NURBSAPILinearSweep::SweepWithTwoLimits(guide1, guide2, spine, spine->FirstParameter(), spine->LastParameter(), law1, law2);
		CHECK(status1 == NURBSSweepStatus::Success);
		if (status1 == NURBSSweepStatus::Success)
		{
			CHECK(OCCTIO::OCCTTool::Write(MakeFace(surface1, 0.0), OUTPUT_PATH_PREFIX "TestLinearSweepWithTwoLimits_rdegree11esult.brep"));
			CHECK(IsCurveOnSurf(1000, 0.3, guide1, surface1, 0.2));
			CHECK(IsCurveOnSurf(1000, 0.2, guide2, surface1, 0.2));
			AMCAX::BRepExtremaDistShapeShape len1(MakeFace(surface1, 0.0), MakeEdge(guide1));
			AMCAX::BRepExtremaDistShapeShape len2(MakeFace(surface1, 0.0), MakeEdge(guide2));
			CHECK(len1.Value() == Approx(0.0).margin(0.1));
			CHECK(len2.Value() == Approx(0.0).margin(0.1));
			double bsp3s = GetSurfaceProperties(MakeFace(surface1, 0.0), g, true, true);
			double bsp4s = GetSurfaceProperties(MakeFace(surface1, 0.0), g, true, true);
			CHECK(bsp3s == Approx(bsp4s).margin(0.02));
		}
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static std::pair<NURBSSweepStatus, std::shared_ptr<Geom3BSplineSurface>> SweepWithLimitAndMiddle(const std::shared_ptr<Geom3BSplineCurve>& guide1, const std::shared_ptr<Geom3BSplineCurve>& guide2, const std::shared_ptr<Geom3BSplineCurve>& spine, double spineLeftBound, double spineRightBound),
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <filesystem>
#include <fstream>
#include <random>
#include <sstream>
#include <nurbs/NURBSAPIGetGeometry.hpp>
#include <nurbs/NURBSAPIConicalSweep.hpp>
#include <boolean/BoolBRepCut.hpp>
#include <common/CartesianCoordinateSystem.hpp>
#include <common/IndexMap.hpp>
#include <common/QuaternionT.hpp>
#include <geomAlgo/LawBSpline.hpp>
#include <geomAlgo/LawConstant.hpp>
#include <nurbs/NURBSAPISmooth.hpp>
#include <geomAlgo/MakeConic2FromConstraints.hpp>
#include <geometry/Adaptor3CurveOnSurface.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/AdaptorGeom3Surface.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/Geom2Circle.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/Geom2Hyperbola.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom3BSplineCurve.hpp>
#include <geometry/Geom3BSplineSurface.hpp>
#include <geometry/Geom3Circle.hpp>
#include <geometry/Geom3Line.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
#include <geometry/Geom3Plane.hpp>
#include <geometry/Geom3SphericalSurface.hpp>
#include <geometry/Geom3Surface.hpp>
#include <geometry/Geom3TrimmedCurve.hpp>
#include <geometry/Geom3TrimmedSurface.hpp>
#include <geometry/GeomAPIExtremaCurveCurve3.hpp>
#include <geometry/GeomAPIProjectPointOnCurve2.hpp>
#include <geometry/GeomAPIProjectPointOnCurve3.hpp>
#include <geometry/GeomAPIProjectPointOnSurface.hpp>
#include <geometry/GeometryTool.hpp>
#include <geometry/GlobalProperty.hpp>
#include <healing/ShapeFixTool.hpp>
#include <io/STLTool.hpp>
#include <math/Sphere.hpp>
#include <math/TriangularMesh.hpp>
#include <modeling/CopyShape.hpp>
#include <modeling/MakeBox.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeFace.hpp>
#include <modeling/MakePrism.hpp>
#include <modeling/MakeRevol.hpp>
#include <modeling/MakeShapeTool.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeWire.hpp>
#include <modeling/TransformShape.hpp>
#include <nurbs/NURBSAPIApprox.hpp>
#include <nurbs/NURBSAPIBuildCurve.hpp>
#include <nurbs/NURBSAPICircularSweep.hpp>
#include <nurbs/NURBSAPIConvert.hpp>
#include <nurbs/NURBSAPICurveNetworkSurface.hpp>
#include <nurbs/NURBSAPIExplicitSweep.hpp>
#include <nurbs/NURBSAPIExplode.hpp>
#include <nurbs/NURBSAPIExtend.hpp>
#include <nurbs/NURBSAPIInterpolate.hpp>
#include <nurbs/NURBSAPIJoin.hpp>
#include <nurbs/NURBSAPILinearSweep.hpp>
#include <nurbs/NURBSAPILoft.hpp>
#include <nurbs/NURBSAPIMakeNURBSFromBoundaries.hpp>
#include <nurbs/NURBSAPIMatch.hpp>
#include <nurbs/NURBSAPIModifyEndToPlane.hpp>
#include <nurbs/NURBSAPIOffsetCurveOnSurface.hpp>
#include <nurbs/NURBSAPIProject.hpp>
#include <nurbs/NURBSAPIRebuild.hpp>
#include <nurbs/NURBSAPIReplaceEdge.hpp>
#include <nurbs/NURBSAPISweep.hpp>
#include <nurbs/NURBSAPISweep2.hpp>
#include <nurbs/NURBSAPISweepRotation.hpp>
#include <nurbs/NURBSAPITrim.hpp>
#include <nurbs/NURBSAPIUntrim.hpp>
#include <nurbs/NURBSLinearSweepWithDraftDirectionLength.hpp>
#include <occtio/OCCTTool.hpp>
#include <offset/MakePipe.hpp>
#include <offset/MakePipeShell.hpp>
#include <topology/BRepAdaptorCurve2.hpp>
#include <topology/BRepAdaptorCurve3.hpp>
#include <topology/BRepAdaptorSurface.hpp>
#include <topology/BRepGlobalProperty.hpp>
#include <topology/BRepTool.hpp>
#include <topology/TopoBuilder.hpp>
#include <topology/TopoCompound.hpp>
#include <topology/TopoEdge.hpp>
#include <topology/TopoExplorer.hpp>
#include <topology/TopoExplorerTool.hpp>
#include <topology/TopoFace.hpp>
#include <topology/TopoShape.hpp>
#include <topology/TopoShell.hpp>
#include <topology/TopoTool.hpp>
#include <topology/TopoVertex.hpp>
#include <topology/TopoWire.hpp>
#include <topology/WireExplorer.hpp>
#include <topomesh/BRepMeshIncrementalMesh.hpp>
#include <nurbs/NURBSAPIBlend.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
#include <math/LineT.hpp>
#include <hatch/BRepClassificationTools.hpp>
using namespace AMCAX;
namespace
{
	std::shared_ptr<Geom3BSplineCurve> CurveChooser(const int id, const std::shared_ptr<Geom3BSplineCurve>& curve0, const std::shared_ptr<Geom3BSplineCurve>& curve1, const std::shared_ptr<Geom3BSplineCurve>& curve2)
	{
		std::shared_ptr<Geom3BSplineCurve> result;
		switch (id)
		{
		case 0:
		{
			result = curve0;
			break;
		}
		case 1:
		{
			result = curve1;
			break;
		}
		case 2:
		{
			result = curve2;
			break;
		}
		}
		return result;
	}
} 
#include<catch.hpp>
#include<testHelper.h>
#include <filesystem>
#include <fstream>
#include <random>
#include <sstream>
#include <nurbs/NURBSAPIGetGeometry.hpp>
#include <nurbs/NURBSAPIConicalSweep.hpp>
#include <boolean/BoolBRepCut.hpp>
#include <common/CartesianCoordinateSystem.hpp>
#include <common/IndexMap.hpp>
#include <common/QuaternionT.hpp>
#include <geomAlgo/LawBSpline.hpp>
#include <geomAlgo/LawConstant.hpp>
#include <nurbs/NURBSAPISmooth.hpp>
#include <geomAlgo/MakeConic2FromConstraints.hpp>
#include <geometry/Adaptor3CurveOnSurface.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/AdaptorGeom3Surface.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/Geom2Circle.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/Geom2Hyperbola.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom3BSplineCurve.hpp>
#include <geometry/Geom3BSplineSurface.hpp>
#include <geometry/Geom3Circle.hpp>
#include <geometry/Geom3Line.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
#include <geometry/Geom3Plane.hpp>
#include <geometry/Geom3SphericalSurface.hpp>
#include <geometry/Geom3Surface.hpp>
#include <geometry/Geom3TrimmedCurve.hpp>
#include <geometry/Geom3TrimmedSurface.hpp>
#include <geometry/GeomAPIExtremaCurveCurve3.hpp>
#include <geometry/GeomAPIProjectPointOnCurve2.hpp>
#include <geometry/GeomAPIProjectPointOnCurve3.hpp>
#include <geometry/GeomAPIProjectPointOnSurface.hpp>
#include <geometry/GeometryTool.hpp>
#include <geometry/GlobalProperty.hpp>
#include <healing/ShapeFixTool.hpp>
#include <io/STLTool.hpp>
#include <math/Sphere.hpp>
#include <math/TriangularMesh.hpp>
#include <modeling/CopyShape.hpp>
#include <modeling/MakeBox.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeFace.hpp>
#include <modeling/MakePrism.hpp>
#include <modeling/MakeRevol.hpp>
#include <modeling/MakeShapeTool.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeWire.hpp>
#include <modeling/TransformShape.hpp>
#include <nurbs/NURBSAPIApprox.hpp>
#include <nurbs/NURBSAPIBuildCurve.hpp>
#include <nurbs/NURBSAPICircularSweep.hpp>
#include <nurbs/NURBSAPIConvert.hpp>
#include <nurbs/NURBSAPICurveNetworkSurface.hpp>
#include <nurbs/NURBSAPIExplicitSweep.hpp>
#include <nurbs/NURBSAPIExplode.hpp>
#include <nurbs/NURBSAPIExtend.hpp>
#include <nurbs/NURBSAPIInterpolate.hpp>
#include <nurbs/NURBSAPIJoin.hpp>
#include <nurbs/NURBSAPILinearSweep.hpp>
#include <nurbs/NURBSAPILoft.hpp>
#include <nurbs/NURBSAPIMakeNURBSFromBoundaries.hpp>
#include <nurbs/NURBSAPIMatch.hpp>
#include <nurbs/NURBSAPIModifyEndToPlane.hpp>
#include <nurbs/NURBSAPIOffsetCurveOnSurface.hpp>
#include <nurbs/NURBSAPIProject.hpp>
#include <nurbs/NURBSAPIRebuild.hpp>
#include <nurbs/NURBSAPIReplaceEdge.hpp>
#include <nurbs/NURBSAPISweep.hpp>
#include <nurbs/NURBSAPISweep2.hpp>
#include <nurbs/NURBSAPISweepRotation.hpp>
#include <nurbs/NURBSAPITrim.hpp>
#include <nurbs/NURBSAPIUntrim.hpp>
#include <nurbs/NURBSLinearSweepWithDraftDirectionLength.hpp>
#include <occtio/OCCTTool.hpp>
#include <offset/MakePipe.hpp>
#include <offset/MakePipeShell.hpp>
#include <topology/BRepAdaptorCurve2.hpp>
#include <topology/BRepAdaptorCurve3.hpp>
#include <topology/BRepAdaptorSurface.hpp>
#include <topology/BRepGlobalProperty.hpp>
#include <topology/BRepTool.hpp>
#include <topology/TopoBuilder.hpp>
#include <topology/TopoCompound.hpp>
#include <topology/TopoEdge.hpp>
#include <topology/TopoExplorer.hpp>
#include <topology/TopoExplorerTool.hpp>
#include <topology/TopoFace.hpp>
#include <topology/TopoShape.hpp>
#include <topology/TopoShell.hpp>
#include <topology/TopoTool.hpp>
#include <topology/TopoVertex.hpp>
#include <topology/TopoWire.hpp>
#include <topology/WireExplorer.hpp>
#include <topomesh/BRepMeshIncrementalMesh.hpp>
#include <nurbs/NURBSAPIBlend.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
#include <math/LineT.hpp>
#include <hatch/BRepClassificationTools.hpp>
using namespace AMCAX;
namespace
{
	std::shared_ptr<Geom3BSplineCurve> CurveChooser(const int id, const std::shared_ptr<Geom3BSplineCurve>& curve0, const std::shared_ptr<Geom3BSplineCurve>& curve1, const std::shared_ptr<Geom3BSplineCurve>& curve2)
	{
		std::shared_ptr<Geom3BSplineCurve> result;
		switch (id)
		{
		case 0:
		{
			result = curve0;
			break;
		}
		case 1:
		{
			result = curve1;
			break;
		}
		case 2:
		{
			result = curve2;
			break;
		}
		}
		return result;
	}
;
	SECTION("TestLinearSweepWithLimitAndMiddle()")
	{
		std::string filedir = INPUT_PATH_PREFIX "/TestNURBS/TestLinearSweepWithLimitAndMiddle/";
		auto guide1 = ReadBRepCurve(filedir + "guide1.brep");
		CHECK(OCCTIO::OCCTTool::Write(MakeEdge(guide1), OUTPUT_PATH_PREFIX "TestLinearSweepWithLimitAndMiddle_guide1.brep"));
		auto guide2 = ReadBRepCurve(filedir + "guide2.brep");
		CHECK(OCCTIO::OCCTTool::Write(MakeEdge(guide2), OUTPUT_PATH_PREFIX "TestLinearSweepWithLimitAndMiddle_guide2.brep"));
		auto spineFP = ReadBRepPoint(filedir + "spineFP.brep");
		auto spineLP = ReadBRepPoint(filedir + "spineLP.brep");
		std::vector<Point3> poles;
		poles.push_back(spineFP);
		poles.push_back(spineLP);
		auto spine = NURBSAPIBuildCurve::BuildCurve(poles, 1, false);
		CHECK(OCCTIO::OCCTTool::Write(MakeEdge(spine), OUTPUT_PATH_PREFIX "TestLinearSweepWithLimitAndMiddle_spine.brep"));
		auto [status, surface] = NURBSAPILinearSweep::SweepWithLimitAndMiddle(guide1, guide2, spine, spine->FirstParameter(), spine->LastParameter());
		CHECK(status == NURBSSweepStatus::Success);
		if (status == NURBSSweepStatus::Success)
		{
			CHECK(OCCTIO::OCCTTool::Write(MakeFace(surface, 0.0), OUTPUT_PATH_PREFIX "TestLinearSweepWithLimitAndMiddle_result.brep"));
			CHECK(IsCurveOnSurf(1000, 0.6, guide1, surface, 0.1));
			CHECK(IsCurveOnSurf(1000, 0.6, guide2, surface, 0.1));
			AMCAX::BRepExtremaDistShapeShape len1(MakeFace(surface, 0.0), MakeEdge(guide1));
			AMCAX::BRepExtremaDistShapeShape len2(MakeFace(surface, 0.0), MakeEdge(guide2));
			CHECK(len1.Value() == Approx(0.0).margin(0.1));
			CHECK(len2.Value() == Approx(0.0).margin(0.1));
		}
		guide1->IncreaseDegree(5);
		guide2->IncreaseDegree(5);
		spine->IncreaseDegree(5);
		auto [status1, surface1] = NURBSAPILinearSweep::SweepWithLimitAndMiddle(guide1, guide2, spine, spine->FirstParameter(), spine->LastParameter());
		CHECK(status1 == NURBSSweepStatus::Success);
		if (status1 == NURBSSweepStatus::Success)
		{
			CHECK(OCCTIO::OCCTTool::Write(MakeFace(surface1, 0.0), OUTPUT_PATH_PREFIX "TestLinearSweepWithLimitAndMiddle_degree5result.brep"));
			CHECK(IsCurveOnSurf(1000, 0.6, guide1, surface1, 0.1));
			CHECK(IsCurveOnSurf(1000, 0.6, guide2, surface1, 0.1));
			AMCAX::BRepExtremaDistShapeShape len1(MakeFace(surface1, 0.0), MakeEdge(guide1));
			AMCAX::BRepExtremaDistShapeShape len2(MakeFace(surface1, 0.0), MakeEdge(guide2));
			CHECK(len1.Value() == Approx(0.0).margin(0.1));
			CHECK(len2.Value() == Approx(0.0).margin(0.1));
			double bsp3s = GetSurfaceProperties(MakeFace(surface1, 0.0), g, true, true);
			double bsp4s = GetSurfaceProperties(MakeFace(surface, 0.0), g, true, true);
			CHECK(bsp3s == Approx(bsp4s).margin(0.02));
		}
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static std::pair<NURBSSweepStatus, std::vector<std::shared_ptr<Geom3BSplineSurface>>> SweepWithReferenceSurface(const std::shared_ptr<Geom3BSplineCurve>& guide, const std::shared_ptr<Geom3BSplineSurface>& reference, const LawFunction& angleLaw, const LawFunction& length1Law, const LawFunction& length2Law, const std::shared_ptr<Geom3BSplineCurve>& spine, double spineLeftBound, double spineRightBound),
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <filesystem>
#include <fstream>
#include <random>
#include <sstream>
#include <nurbs/NURBSAPIGetGeometry.hpp>
#include <nurbs/NURBSAPIConicalSweep.hpp>
#include <boolean/BoolBRepCut.hpp>
#include <common/CartesianCoordinateSystem.hpp>
#include <common/IndexMap.hpp>
#include <common/QuaternionT.hpp>
#include <geomAlgo/LawBSpline.hpp>
#include <geomAlgo/LawConstant.hpp>
#include <nurbs/NURBSAPISmooth.hpp>
#include <geomAlgo/MakeConic2FromConstraints.hpp>
#include <geometry/Adaptor3CurveOnSurface.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/AdaptorGeom3Surface.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/Geom2Circle.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/Geom2Hyperbola.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom3BSplineCurve.hpp>
#include <geometry/Geom3BSplineSurface.hpp>
#include <geometry/Geom3Circle.hpp>
#include <geometry/Geom3Line.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
#include <geometry/Geom3Plane.hpp>
#include <geometry/Geom3SphericalSurface.hpp>
#include <geometry/Geom3Surface.hpp>
#include <geometry/Geom3TrimmedCurve.hpp>
#include <geometry/Geom3TrimmedSurface.hpp>
#include <geometry/GeomAPIExtremaCurveCurve3.hpp>
#include <geometry/GeomAPIProjectPointOnCurve2.hpp>
#include <geometry/GeomAPIProjectPointOnCurve3.hpp>
#include <geometry/GeomAPIProjectPointOnSurface.hpp>
#include <geometry/GeometryTool.hpp>
#include <geometry/GlobalProperty.hpp>
#include <healing/ShapeFixTool.hpp>
#include <io/STLTool.hpp>
#include <math/Sphere.hpp>
#include <math/TriangularMesh.hpp>
#include <modeling/CopyShape.hpp>
#include <modeling/MakeBox.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeFace.hpp>
#include <modeling/MakePrism.hpp>
#include <modeling/MakeRevol.hpp>
#include <modeling/MakeShapeTool.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeWire.hpp>
#include <modeling/TransformShape.hpp>
#include <nurbs/NURBSAPIApprox.hpp>
#include <nurbs/NURBSAPIBuildCurve.hpp>
#include <nurbs/NURBSAPICircularSweep.hpp>
#include <nurbs/NURBSAPIConvert.hpp>
#include <nurbs/NURBSAPICurveNetworkSurface.hpp>
#include <nurbs/NURBSAPIExplicitSweep.hpp>
#include <nurbs/NURBSAPIExplode.hpp>
#include <nurbs/NURBSAPIExtend.hpp>
#include <nurbs/NURBSAPIInterpolate.hpp>
#include <nurbs/NURBSAPIJoin.hpp>
#include <nurbs/NURBSAPILinearSweep.hpp>
#include <nurbs/NURBSAPILoft.hpp>
#include <nurbs/NURBSAPIMakeNURBSFromBoundaries.hpp>
#include <nurbs/NURBSAPIMatch.hpp>
#include <nurbs/NURBSAPIModifyEndToPlane.hpp>
#include <nurbs/NURBSAPIOffsetCurveOnSurface.hpp>
#include <nurbs/NURBSAPIProject.hpp>
#include <nurbs/NURBSAPIRebuild.hpp>
#include <nurbs/NURBSAPIReplaceEdge.hpp>
#include <nurbs/NURBSAPISweep.hpp>
#include <nurbs/NURBSAPISweep2.hpp>
#include <nurbs/NURBSAPISweepRotation.hpp>
#include <nurbs/NURBSAPITrim.hpp>
#include <nurbs/NURBSAPIUntrim.hpp>
#include <nurbs/NURBSLinearSweepWithDraftDirectionLength.hpp>
#include <occtio/OCCTTool.hpp>
#include <offset/MakePipe.hpp>
#include <offset/MakePipeShell.hpp>
#include <topology/BRepAdaptorCurve2.hpp>
#include <topology/BRepAdaptorCurve3.hpp>
#include <topology/BRepAdaptorSurface.hpp>
#include <topology/BRepGlobalProperty.hpp>
#include <topology/BRepTool.hpp>
#include <topology/TopoBuilder.hpp>
#include <topology/TopoCompound.hpp>
#include <topology/TopoEdge.hpp>
#include <topology/TopoExplorer.hpp>
#include <topology/TopoExplorerTool.hpp>
#include <topology/TopoFace.hpp>
#include <topology/TopoShape.hpp>
#include <topology/TopoShell.hpp>
#include <topology/TopoTool.hpp>
#include <topology/TopoVertex.hpp>
#include <topology/TopoWire.hpp>
#include <topology/WireExplorer.hpp>
#include <topomesh/BRepMeshIncrementalMesh.hpp>
#include <nurbs/NURBSAPIBlend.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
#include <math/LineT.hpp>
#include <hatch/BRepClassificationTools.hpp>
using namespace AMCAX;
namespace
{
	std::shared_ptr<Geom3BSplineCurve> CurveChooser(const int id, const std::shared_ptr<Geom3BSplineCurve>& curve0, const std::shared_ptr<Geom3BSplineCurve>& curve1, const std::shared_ptr<Geom3BSplineCurve>& curve2)
	{
		std::shared_ptr<Geom3BSplineCurve> result;
		switch (id)
		{
		case 0:
		{
			result = curve0;
			break;
		}
		case 1:
		{
			result = curve1;
			break;
		}
		case 2:
		{
			result = curve2;
			break;
		}
		}
		return result;
	}
} 
#include<catch.hpp>
#include<testHelper.h>
#include <filesystem>
#include <fstream>
#include <random>
#include <sstream>
#include <nurbs/NURBSAPIGetGeometry.hpp>
#include <nurbs/NURBSAPIConicalSweep.hpp>
#include <boolean/BoolBRepCut.hpp>
#include <common/CartesianCoordinateSystem.hpp>
#include <common/IndexMap.hpp>
#include <common/QuaternionT.hpp>
#include <geomAlgo/LawBSpline.hpp>
#include <geomAlgo/LawConstant.hpp>
#include <nurbs/NURBSAPISmooth.hpp>
#include <geomAlgo/MakeConic2FromConstraints.hpp>
#include <geometry/Adaptor3CurveOnSurface.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/AdaptorGeom3Surface.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/Geom2Circle.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/Geom2Hyperbola.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom3BSplineCurve.hpp>
#include <geometry/Geom3BSplineSurface.hpp>
#include <geometry/Geom3Circle.hpp>
#include <geometry/Geom3Line.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
#include <geometry/Geom3Plane.hpp>
#include <geometry/Geom3SphericalSurface.hpp>
#include <geometry/Geom3Surface.hpp>
#include <geometry/Geom3TrimmedCurve.hpp>
#include <geometry/Geom3TrimmedSurface.hpp>
#include <geometry/GeomAPIExtremaCurveCurve3.hpp>
#include <geometry/GeomAPIProjectPointOnCurve2.hpp>
#include <geometry/GeomAPIProjectPointOnCurve3.hpp>
#include <geometry/GeomAPIProjectPointOnSurface.hpp>
#include <geometry/GeometryTool.hpp>
#include <geometry/GlobalProperty.hpp>
#include <healing/ShapeFixTool.hpp>
#include <io/STLTool.hpp>
#include <math/Sphere.hpp>
#include <math/TriangularMesh.hpp>
#include <modeling/CopyShape.hpp>
#include <modeling/MakeBox.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeFace.hpp>
#include <modeling/MakePrism.hpp>
#include <modeling/MakeRevol.hpp>
#include <modeling/MakeShapeTool.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeWire.hpp>
#include <modeling/TransformShape.hpp>
#include <nurbs/NURBSAPIApprox.hpp>
#include <nurbs/NURBSAPIBuildCurve.hpp>
#include <nurbs/NURBSAPICircularSweep.hpp>
#include <nurbs/NURBSAPIConvert.hpp>
#include <nurbs/NURBSAPICurveNetworkSurface.hpp>
#include <nurbs/NURBSAPIExplicitSweep.hpp>
#include <nurbs/NURBSAPIExplode.hpp>
#include <nurbs/NURBSAPIExtend.hpp>
#include <nurbs/NURBSAPIInterpolate.hpp>
#include <nurbs/NURBSAPIJoin.hpp>
#include <nurbs/NURBSAPILinearSweep.hpp>
#include <nurbs/NURBSAPILoft.hpp>
#include <nurbs/NURBSAPIMakeNURBSFromBoundaries.hpp>
#include <nurbs/NURBSAPIMatch.hpp>
#include <nurbs/NURBSAPIModifyEndToPlane.hpp>
#include <nurbs/NURBSAPIOffsetCurveOnSurface.hpp>
#include <nurbs/NURBSAPIProject.hpp>
#include <nurbs/NURBSAPIRebuild.hpp>
#include <nurbs/NURBSAPIReplaceEdge.hpp>
#include <nurbs/NURBSAPISweep.hpp>
#include <nurbs/NURBSAPISweep2.hpp>
#include <nurbs/NURBSAPISweepRotation.hpp>
#include <nurbs/NURBSAPITrim.hpp>
#include <nurbs/NURBSAPIUntrim.hpp>
#include <nurbs/NURBSLinearSweepWithDraftDirectionLength.hpp>
#include <occtio/OCCTTool.hpp>
#include <offset/MakePipe.hpp>
#include <offset/MakePipeShell.hpp>
#include <topology/BRepAdaptorCurve2.hpp>
#include <topology/BRepAdaptorCurve3.hpp>
#include <topology/BRepAdaptorSurface.hpp>
#include <topology/BRepGlobalProperty.hpp>
#include <topology/BRepTool.hpp>
#include <topology/TopoBuilder.hpp>
#include <topology/TopoCompound.hpp>
#include <topology/TopoEdge.hpp>
#include <topology/TopoExplorer.hpp>
#include <topology/TopoExplorerTool.hpp>
#include <topology/TopoFace.hpp>
#include <topology/TopoShape.hpp>
#include <topology/TopoShell.hpp>
#include <topology/TopoTool.hpp>
#include <topology/TopoVertex.hpp>
#include <topology/TopoWire.hpp>
#include <topology/WireExplorer.hpp>
#include <topomesh/BRepMeshIncrementalMesh.hpp>
#include <nurbs/NURBSAPIBlend.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
#include <math/LineT.hpp>
#include <hatch/BRepClassificationTools.hpp>
using namespace AMCAX;
namespace
{
	std::shared_ptr<Geom3BSplineCurve> CurveChooser(const int id, const std::shared_ptr<Geom3BSplineCurve>& curve0, const std::shared_ptr<Geom3BSplineCurve>& curve1, const std::shared_ptr<Geom3BSplineCurve>& curve2)
	{
		std::shared_ptr<Geom3BSplineCurve> result;
		switch (id)
		{
		case 0:
		{
			result = curve0;
			break;
		}
		case 1:
		{
			result = curve1;
			break;
		}
		case 2:
		{
			result = curve2;
			break;
		}
		}
		return result;
	}
;
	SECTION("TestLinearSweepWithReferenceSurface()")
	{
		std::string filedir = INPUT_PATH_PREFIX "/TestNURBS/TestLinearSweepWithReferenceSurface/";
		auto guide = ReadBRepCurve(filedir + "guide.brep");
		CHECK(OCCTIO::OCCTTool::Write(MakeEdge(guide), OUTPUT_PATH_PREFIX "TestLinearSweepWithReferenceSurface_guide.brep"));
		auto surface = ReadBRepSurface(filedir + "surface.brep");
		CHECK(OCCTIO::OCCTTool::Write(MakeFace(surface, 0.0), OUTPUT_PATH_PREFIX "TestLinearSweepWithReferenceSurface_surface.brep"));
		LawConstant degreeLaw;
		degreeLaw.Set(M_PI_4, 0.0, 1.0);
		LawConstant length1Law;
		length1Law.Set(3, 0.0, 1.0);
		LawConstant length2Law;
		length2Law.Set(5, 0.0, 1.0);
		auto [status, surfaces] = NURBSAPILinearSweep::SweepWithReferenceSurface(guide, surface, degreeLaw, length1Law, length2Law, guide, guide->FirstParameter(), guide->LastParameter());
		CHECK(status == NURBSSweepStatus::Success);
		if (status == NURBSSweepStatus::Success)
		{
			CHECK(OCCTIO::OCCTTool::Write(MakeFace(surfaces.front(), 0.0), OUTPUT_PATH_PREFIX "TestLinearSweepWithReferenceSurface_result.brep"));
			CHECK(IsCurveOnSurf(1000, 0.1, guide, surface));
			CHECK(IsCurveOnSurf(1000, 0.1, guide, surfaces.front()));
			IndexSet<TopoShape> newshapeEdge1;
			TopoExplorerTool::MapShapes(MakeFace(surfaces.front(), 0.0), ShapeType::Edge, newshapeEdge1);
			AMCAX::BRepExtremaDistShapeShape len1(newshapeEdge1[0], MakeEdge(guide));
			AMCAX::BRepExtremaDistShapeShape len2(newshapeEdge1[2], MakeEdge(guide));
			CHECK(len1.Value() == Approx(3.0).margin(0.1));
			CHECK(len2.Value() == Approx(5.0).margin(0.1));
		}
		guide->IncreaseDegree(11);
		surface->IncreaseDegree(11,11);
		auto [status1, surfaces1] = NURBSAPILinearSweep::SweepWithReferenceSurface(guide, surface, degreeLaw, length1Law, length2Law, guide, guide->FirstParameter(), guide->LastParameter());
		CHECK(status1 == NURBSSweepStatus::Success);
		if (status1 == NURBSSweepStatus::Success)
		{
			CHECK(OCCTIO::OCCTTool::Write(MakeFace(surfaces1.front(), 0.0), OUTPUT_PATH_PREFIX "TestLinearSweepWithReferenceSurface_degree11result.brep"));
			CHECK(IsCurveOnSurf(1000, 0.1, guide, surface));
			CHECK(IsCurveOnSurf(1000, 0.1, guide, surfaces1.front()));
			IndexSet<TopoShape> newshapeEdge1;
			TopoExplorerTool::MapShapes(MakeFace(surfaces1.front(), 0.0), ShapeType::Edge, newshapeEdge1);
			AMCAX::BRepExtremaDistShapeShape len1(newshapeEdge1[0], MakeEdge(guide));
			AMCAX::BRepExtremaDistShapeShape len2(newshapeEdge1[2], MakeEdge(guide));
			CHECK(len1.Value() == Approx(3.0).margin(0.1));
			CHECK(len2.Value() == Approx(5.0).margin(0.1));
			double bsp3s = GetSurfaceProperties(MakeFace(surfaces1.front(), 0.0), g, true, true);
			double bsp4s = GetSurfaceProperties(MakeFace(surfaces.front(), 0.0), g, true, true);
			CHECK(bsp3s == Approx(bsp4s).margin(0.02));
		}
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static std::pair<NURBSSweepStatus, std::vector<std::shared_ptr<Geom3BSplineSurface>>> SweepWithReferenceCurve(const std::shared_ptr<Geom3BSplineCurve>& guide, const std::shared_ptr<Geom3BSplineCurve>& reference, const LawFunction& angleLaw, const LawFunction& length1Law, const LawFunction& length2Law, const std::shared_ptr<Geom3BSplineCurve>& spine, double spineLeftBound, double spineRightBound),
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <filesystem>
#include <fstream>
#include <random>
#include <sstream>
#include <nurbs/NURBSAPIGetGeometry.hpp>
#include <nurbs/NURBSAPIConicalSweep.hpp>
#include <boolean/BoolBRepCut.hpp>
#include <common/CartesianCoordinateSystem.hpp>
#include <common/IndexMap.hpp>
#include <common/QuaternionT.hpp>
#include <geomAlgo/LawBSpline.hpp>
#include <geomAlgo/LawConstant.hpp>
#include <nurbs/NURBSAPISmooth.hpp>
#include <geomAlgo/MakeConic2FromConstraints.hpp>
#include <geometry/Adaptor3CurveOnSurface.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/AdaptorGeom3Surface.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/Geom2Circle.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/Geom2Hyperbola.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom3BSplineCurve.hpp>
#include <geometry/Geom3BSplineSurface.hpp>
#include <geometry/Geom3Circle.hpp>
#include <geometry/Geom3Line.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
#include <geometry/Geom3Plane.hpp>
#include <geometry/Geom3SphericalSurface.hpp>
#include <geometry/Geom3Surface.hpp>
#include <geometry/Geom3TrimmedCurve.hpp>
#include <geometry/Geom3TrimmedSurface.hpp>
#include <geometry/GeomAPIExtremaCurveCurve3.hpp>
#include <geometry/GeomAPIProjectPointOnCurve2.hpp>
#include <geometry/GeomAPIProjectPointOnCurve3.hpp>
#include <geometry/GeomAPIProjectPointOnSurface.hpp>
#include <geometry/GeometryTool.hpp>
#include <geometry/GlobalProperty.hpp>
#include <healing/ShapeFixTool.hpp>
#include <io/STLTool.hpp>
#include <math/Sphere.hpp>
#include <math/TriangularMesh.hpp>
#include <modeling/CopyShape.hpp>
#include <modeling/MakeBox.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeFace.hpp>
#include <modeling/MakePrism.hpp>
#include <modeling/MakeRevol.hpp>
#include <modeling/MakeShapeTool.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeWire.hpp>
#include <modeling/TransformShape.hpp>
#include <nurbs/NURBSAPIApprox.hpp>
#include <nurbs/NURBSAPIBuildCurve.hpp>
#include <nurbs/NURBSAPICircularSweep.hpp>
#include <nurbs/NURBSAPIConvert.hpp>
#include <nurbs/NURBSAPICurveNetworkSurface.hpp>
#include <nurbs/NURBSAPIExplicitSweep.hpp>
#include <nurbs/NURBSAPIExplode.hpp>
#include <nurbs/NURBSAPIExtend.hpp>
#include <nurbs/NURBSAPIInterpolate.hpp>
#include <nurbs/NURBSAPIJoin.hpp>
#include <nurbs/NURBSAPILinearSweep.hpp>
#include <nurbs/NURBSAPILoft.hpp>
#include <nurbs/NURBSAPIMakeNURBSFromBoundaries.hpp>
#include <nurbs/NURBSAPIMatch.hpp>
#include <nurbs/NURBSAPIModifyEndToPlane.hpp>
#include <nurbs/NURBSAPIOffsetCurveOnSurface.hpp>
#include <nurbs/NURBSAPIProject.hpp>
#include <nurbs/NURBSAPIRebuild.hpp>
#include <nurbs/NURBSAPIReplaceEdge.hpp>
#include <nurbs/NURBSAPISweep.hpp>
#include <nurbs/NURBSAPISweep2.hpp>
#include <nurbs/NURBSAPISweepRotation.hpp>
#include <nurbs/NURBSAPITrim.hpp>
#include <nurbs/NURBSAPIUntrim.hpp>
#include <nurbs/NURBSLinearSweepWithDraftDirectionLength.hpp>
#include <occtio/OCCTTool.hpp>
#include <offset/MakePipe.hpp>
#include <offset/MakePipeShell.hpp>
#include <topology/BRepAdaptorCurve2.hpp>
#include <topology/BRepAdaptorCurve3.hpp>
#include <topology/BRepAdaptorSurface.hpp>
#include <topology/BRepGlobalProperty.hpp>
#include <topology/BRepTool.hpp>
#include <topology/TopoBuilder.hpp>
#include <topology/TopoCompound.hpp>
#include <topology/TopoEdge.hpp>
#include <topology/TopoExplorer.hpp>
#include <topology/TopoExplorerTool.hpp>
#include <topology/TopoFace.hpp>
#include <topology/TopoShape.hpp>
#include <topology/TopoShell.hpp>
#include <topology/TopoTool.hpp>
#include <topology/TopoVertex.hpp>
#include <topology/TopoWire.hpp>
#include <topology/WireExplorer.hpp>
#include <topomesh/BRepMeshIncrementalMesh.hpp>
#include <nurbs/NURBSAPIBlend.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
#include <math/LineT.hpp>
#include <hatch/BRepClassificationTools.hpp>
using namespace AMCAX;
namespace
{
	std::shared_ptr<Geom3BSplineCurve> CurveChooser(const int id, const std::shared_ptr<Geom3BSplineCurve>& curve0, const std::shared_ptr<Geom3BSplineCurve>& curve1, const std::shared_ptr<Geom3BSplineCurve>& curve2)
	{
		std::shared_ptr<Geom3BSplineCurve> result;
		switch (id)
		{
		case 0:
		{
			result = curve0;
			break;
		}
		case 1:
		{
			result = curve1;
			break;
		}
		case 2:
		{
			result = curve2;
			break;
		}
		}
		return result;
	}
} 
#include<catch.hpp>
#include<testHelper.h>
#include <filesystem>
#include <fstream>
#include <random>
#include <sstream>
#include <nurbs/NURBSAPIGetGeometry.hpp>
#include <nurbs/NURBSAPIConicalSweep.hpp>
#include <boolean/BoolBRepCut.hpp>
#include <common/CartesianCoordinateSystem.hpp>
#include <common/IndexMap.hpp>
#include <common/QuaternionT.hpp>
#include <geomAlgo/LawBSpline.hpp>
#include <geomAlgo/LawConstant.hpp>
#include <nurbs/NURBSAPISmooth.hpp>
#include <geomAlgo/MakeConic2FromConstraints.hpp>
#include <geometry/Adaptor3CurveOnSurface.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/AdaptorGeom3Surface.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/Geom2Circle.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/Geom2Hyperbola.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom3BSplineCurve.hpp>
#include <geometry/Geom3BSplineSurface.hpp>
#include <geometry/Geom3Circle.hpp>
#include <geometry/Geom3Line.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
#include <geometry/Geom3Plane.hpp>
#include <geometry/Geom3SphericalSurface.hpp>
#include <geometry/Geom3Surface.hpp>
#include <geometry/Geom3TrimmedCurve.hpp>
#include <geometry/Geom3TrimmedSurface.hpp>
#include <geometry/GeomAPIExtremaCurveCurve3.hpp>
#include <geometry/GeomAPIProjectPointOnCurve2.hpp>
#include <geometry/GeomAPIProjectPointOnCurve3.hpp>
#include <geometry/GeomAPIProjectPointOnSurface.hpp>
#include <geometry/GeometryTool.hpp>
#include <geometry/GlobalProperty.hpp>
#include <healing/ShapeFixTool.hpp>
#include <io/STLTool.hpp>
#include <math/Sphere.hpp>
#include <math/TriangularMesh.hpp>
#include <modeling/CopyShape.hpp>
#include <modeling/MakeBox.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeFace.hpp>
#include <modeling/MakePrism.hpp>
#include <modeling/MakeRevol.hpp>
#include <modeling/MakeShapeTool.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeWire.hpp>
#include <modeling/TransformShape.hpp>
#include <nurbs/NURBSAPIApprox.hpp>
#include <nurbs/NURBSAPIBuildCurve.hpp>
#include <nurbs/NURBSAPICircularSweep.hpp>
#include <nurbs/NURBSAPIConvert.hpp>
#include <nurbs/NURBSAPICurveNetworkSurface.hpp>
#include <nurbs/NURBSAPIExplicitSweep.hpp>
#include <nurbs/NURBSAPIExplode.hpp>
#include <nurbs/NURBSAPIExtend.hpp>
#include <nurbs/NURBSAPIInterpolate.hpp>
#include <nurbs/NURBSAPIJoin.hpp>
#include <nurbs/NURBSAPILinearSweep.hpp>
#include <nurbs/NURBSAPILoft.hpp>
#include <nurbs/NURBSAPIMakeNURBSFromBoundaries.hpp>
#include <nurbs/NURBSAPIMatch.hpp>
#include <nurbs/NURBSAPIModifyEndToPlane.hpp>
#include <nurbs/NURBSAPIOffsetCurveOnSurface.hpp>
#include <nurbs/NURBSAPIProject.hpp>
#include <nurbs/NURBSAPIRebuild.hpp>
#include <nurbs/NURBSAPIReplaceEdge.hpp>
#include <nurbs/NURBSAPISweep.hpp>
#include <nurbs/NURBSAPISweep2.hpp>
#include <nurbs/NURBSAPISweepRotation.hpp>
#include <nurbs/NURBSAPITrim.hpp>
#include <nurbs/NURBSAPIUntrim.hpp>
#include <nurbs/NURBSLinearSweepWithDraftDirectionLength.hpp>
#include <occtio/OCCTTool.hpp>
#include <offset/MakePipe.hpp>
#include <offset/MakePipeShell.hpp>
#include <topology/BRepAdaptorCurve2.hpp>
#include <topology/BRepAdaptorCurve3.hpp>
#include <topology/BRepAdaptorSurface.hpp>
#include <topology/BRepGlobalProperty.hpp>
#include <topology/BRepTool.hpp>
#include <topology/TopoBuilder.hpp>
#include <topology/TopoCompound.hpp>
#include <topology/TopoEdge.hpp>
#include <topology/TopoExplorer.hpp>
#include <topology/TopoExplorerTool.hpp>
#include <topology/TopoFace.hpp>
#include <topology/TopoShape.hpp>
#include <topology/TopoShell.hpp>
#include <topology/TopoTool.hpp>
#include <topology/TopoVertex.hpp>
#include <topology/TopoWire.hpp>
#include <topology/WireExplorer.hpp>
#include <topomesh/BRepMeshIncrementalMesh.hpp>
#include <nurbs/NURBSAPIBlend.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
#include <math/LineT.hpp>
#include <hatch/BRepClassificationTools.hpp>
using namespace AMCAX;
namespace
{
	std::shared_ptr<Geom3BSplineCurve> CurveChooser(const int id, const std::shared_ptr<Geom3BSplineCurve>& curve0, const std::shared_ptr<Geom3BSplineCurve>& curve1, const std::shared_ptr<Geom3BSplineCurve>& curve2)
	{
		std::shared_ptr<Geom3BSplineCurve> result;
		switch (id)
		{
		case 0:
		{
			result = curve0;
			break;
		}
		case 1:
		{
			result = curve1;
			break;
		}
		case 2:
		{
			result = curve2;
			break;
		}
		}
		return result;
	}
;
	SECTION("TestLinearSweepWithReferenceCurve2()")
	{
		std::string filedir = INPUT_PATH_PREFIX "/TestNURBS/TestLinearSweepWithReferenceCurve2/";
		auto guide = ReadBRepCurve(filedir + "guide.brep");
		CHECK(OCCTIO::OCCTTool::Write(MakeEdge(guide), OUTPUT_PATH_PREFIX "TestLinearSweepWithReferenceCurve2_guide.brep"));
		auto ref = ReadBRepCurve(filedir + "reference.brep");
		CHECK(OCCTIO::OCCTTool::Write(MakeEdge(ref), OUTPUT_PATH_PREFIX "TestLinearSweepWithReferenceCurve2_ref.brep"));
		auto spine = guide;
		LawConstant degreeLaw;
		degreeLaw.Set(M_PI / 3.0, 0.0, 1.0);
		LawConstant length1Law;
		length1Law.Set(3, 0.0, 1.0);
		LawConstant length2Law;
		length2Law.Set(3, 0.0, 1.0);
		auto [status, surfaces] = NURBSAPILinearSweep::SweepWithReferenceCurve(guide, ref, degreeLaw, length1Law, length2Law, spine, spine->FirstParameter(), spine->LastParameter());
		CHECK(status == NURBSSweepStatus::Success);
		if (status == NURBSSweepStatus::Success)
		{
			CHECK(OCCTIO::OCCTTool::Write(MakeFace(surfaces.front(), 0.0), OUTPUT_PATH_PREFIX "TestLinearSweepWithReferenceCurve2_result.brep"));
			CHECK(OCCTIO::OCCTTool::Write(MakeFace(surfaces[1], 0.0), OUTPUT_PATH_PREFIX "TestLinearSweepWithReferenceCurve2_result1.brep"));
			CHECK(OCCTIO::OCCTTool::Write(MakeFace(surfaces[2], 0.0), OUTPUT_PATH_PREFIX "TestLinearSweepWithReferenceCurve2_result2.brep"));
		}
		CHECK(IsCurveOnSurf(1000, 0.1, guide, surfaces.front(), 0.1));
		IndexSet<TopoShape> newshapeEdge1;
		TopoExplorerTool::MapShapes(MakeFace(surfaces.front(), 0.0), ShapeType::Edge, newshapeEdge1);
		AMCAX::BRepExtremaDistShapeShape len1(newshapeEdge1[0], MakeEdge(guide));
		AMCAX::BRepExtremaDistShapeShape len2(newshapeEdge1[2], MakeEdge(guide));
		CHECK(len1.Value() == Approx(3.0).margin(0.1));
		CHECK(len2.Value() == Approx(3.0).margin(0.1));
		guide->IncreaseDegree(11);
		ref->IncreaseDegree(11);
		spine->IncreaseDegree(11);
		auto [status1, surfaces1] = NURBSAPILinearSweep::SweepWithReferenceCurve(guide, ref, degreeLaw, length1Law, length2Law, spine, spine->FirstParameter(), spine->LastParameter());
		CHECK(status1 == NURBSSweepStatus::Success);
		if (status1 == NURBSSweepStatus::Success)
		{
			double bsp3s = GetSurfaceProperties(MakeFace(surfaces1.front(), 0.0), g, true, true);
			double bsp4s = GetSurfaceProperties(MakeFace(surfaces.front(), 0.0), g, true, true);
			CHECK(bsp3s == Approx(bsp4s).margin(0.02));
		}
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static std::pair<NURBSSweepStatus, std::vector<std::shared_ptr<Geom3BSplineSurface>>> SweepWithTangencySurface(const std::shared_ptr<Geom3BSplineCurve>& guide, const std::shared_ptr<Geom3BSplineSurface>& tangencySurface, const std::shared_ptr<Geom3BSplineCurve>& spine, double spineLeftBound, double spineRightBound),
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <filesystem>
#include <fstream>
#include <random>
#include <sstream>
#include <nurbs/NURBSAPIGetGeometry.hpp>
#include <nurbs/NURBSAPIConicalSweep.hpp>
#include <boolean/BoolBRepCut.hpp>
#include <common/CartesianCoordinateSystem.hpp>
#include <common/IndexMap.hpp>
#include <common/QuaternionT.hpp>
#include <geomAlgo/LawBSpline.hpp>
#include <geomAlgo/LawConstant.hpp>
#include <nurbs/NURBSAPISmooth.hpp>
#include <geomAlgo/MakeConic2FromConstraints.hpp>
#include <geometry/Adaptor3CurveOnSurface.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/AdaptorGeom3Surface.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/Geom2Circle.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/Geom2Hyperbola.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom3BSplineCurve.hpp>
#include <geometry/Geom3BSplineSurface.hpp>
#include <geometry/Geom3Circle.hpp>
#include <geometry/Geom3Line.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
#include <geometry/Geom3Plane.hpp>
#include <geometry/Geom3SphericalSurface.hpp>
#include <geometry/Geom3Surface.hpp>
#include <geometry/Geom3TrimmedCurve.hpp>
#include <geometry/Geom3TrimmedSurface.hpp>
#include <geometry/GeomAPIExtremaCurveCurve3.hpp>
#include <geometry/GeomAPIProjectPointOnCurve2.hpp>
#include <geometry/GeomAPIProjectPointOnCurve3.hpp>
#include <geometry/GeomAPIProjectPointOnSurface.hpp>
#include <geometry/GeometryTool.hpp>
#include <geometry/GlobalProperty.hpp>
#include <healing/ShapeFixTool.hpp>
#include <io/STLTool.hpp>
#include <math/Sphere.hpp>
#include <math/TriangularMesh.hpp>
#include <modeling/CopyShape.hpp>
#include <modeling/MakeBox.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeFace.hpp>
#include <modeling/MakePrism.hpp>
#include <modeling/MakeRevol.hpp>
#include <modeling/MakeShapeTool.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeWire.hpp>
#include <modeling/TransformShape.hpp>
#include <nurbs/NURBSAPIApprox.hpp>
#include <nurbs/NURBSAPIBuildCurve.hpp>
#include <nurbs/NURBSAPICircularSweep.hpp>
#include <nurbs/NURBSAPIConvert.hpp>
#include <nurbs/NURBSAPICurveNetworkSurface.hpp>
#include <nurbs/NURBSAPIExplicitSweep.hpp>
#include <nurbs/NURBSAPIExplode.hpp>
#include <nurbs/NURBSAPIExtend.hpp>
#include <nurbs/NURBSAPIInterpolate.hpp>
#include <nurbs/NURBSAPIJoin.hpp>
#include <nurbs/NURBSAPILinearSweep.hpp>
#include <nurbs/NURBSAPILoft.hpp>
#include <nurbs/NURBSAPIMakeNURBSFromBoundaries.hpp>
#include <nurbs/NURBSAPIMatch.hpp>
#include <nurbs/NURBSAPIModifyEndToPlane.hpp>
#include <nurbs/NURBSAPIOffsetCurveOnSurface.hpp>
#include <nurbs/NURBSAPIProject.hpp>
#include <nurbs/NURBSAPIRebuild.hpp>
#include <nurbs/NURBSAPIReplaceEdge.hpp>
#include <nurbs/NURBSAPISweep.hpp>
#include <nurbs/NURBSAPISweep2.hpp>
#include <nurbs/NURBSAPISweepRotation.hpp>
#include <nurbs/NURBSAPITrim.hpp>
#include <nurbs/NURBSAPIUntrim.hpp>
#include <nurbs/NURBSLinearSweepWithDraftDirectionLength.hpp>
#include <occtio/OCCTTool.hpp>
#include <offset/MakePipe.hpp>
#include <offset/MakePipeShell.hpp>
#include <topology/BRepAdaptorCurve2.hpp>
#include <topology/BRepAdaptorCurve3.hpp>
#include <topology/BRepAdaptorSurface.hpp>
#include <topology/BRepGlobalProperty.hpp>
#include <topology/BRepTool.hpp>
#include <topology/TopoBuilder.hpp>
#include <topology/TopoCompound.hpp>
#include <topology/TopoEdge.hpp>
#include <topology/TopoExplorer.hpp>
#include <topology/TopoExplorerTool.hpp>
#include <topology/TopoFace.hpp>
#include <topology/TopoShape.hpp>
#include <topology/TopoShell.hpp>
#include <topology/TopoTool.hpp>
#include <topology/TopoVertex.hpp>
#include <topology/TopoWire.hpp>
#include <topology/WireExplorer.hpp>
#include <topomesh/BRepMeshIncrementalMesh.hpp>
#include <nurbs/NURBSAPIBlend.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
#include <math/LineT.hpp>
#include <hatch/BRepClassificationTools.hpp>
using namespace AMCAX;
namespace
{
	std::shared_ptr<Geom3BSplineCurve> CurveChooser(const int id, const std::shared_ptr<Geom3BSplineCurve>& curve0, const std::shared_ptr<Geom3BSplineCurve>& curve1, const std::shared_ptr<Geom3BSplineCurve>& curve2)
	{
		std::shared_ptr<Geom3BSplineCurve> result;
		switch (id)
		{
		case 0:
		{
			result = curve0;
			break;
		}
		case 1:
		{
			result = curve1;
			break;
		}
		case 2:
		{
			result = curve2;
			break;
		}
		}
		return result;
	}
} 
#include<catch.hpp>
#include<testHelper.h>
#include <filesystem>
#include <fstream>
#include <random>
#include <sstream>
#include <nurbs/NURBSAPIGetGeometry.hpp>
#include <nurbs/NURBSAPIConicalSweep.hpp>
#include <boolean/BoolBRepCut.hpp>
#include <common/CartesianCoordinateSystem.hpp>
#include <common/IndexMap.hpp>
#include <common/QuaternionT.hpp>
#include <geomAlgo/LawBSpline.hpp>
#include <geomAlgo/LawConstant.hpp>
#include <nurbs/NURBSAPISmooth.hpp>
#include <geomAlgo/MakeConic2FromConstraints.hpp>
#include <geometry/Adaptor3CurveOnSurface.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/AdaptorGeom3Surface.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/Geom2Circle.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/Geom2Hyperbola.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom3BSplineCurve.hpp>
#include <geometry/Geom3BSplineSurface.hpp>
#include <geometry/Geom3Circle.hpp>
#include <geometry/Geom3Line.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
#include <geometry/Geom3Plane.hpp>
#include <geometry/Geom3SphericalSurface.hpp>
#include <geometry/Geom3Surface.hpp>
#include <geometry/Geom3TrimmedCurve.hpp>
#include <geometry/Geom3TrimmedSurface.hpp>
#include <geometry/GeomAPIExtremaCurveCurve3.hpp>
#include <geometry/GeomAPIProjectPointOnCurve2.hpp>
#include <geometry/GeomAPIProjectPointOnCurve3.hpp>
#include <geometry/GeomAPIProjectPointOnSurface.hpp>
#include <geometry/GeometryTool.hpp>
#include <geometry/GlobalProperty.hpp>
#include <healing/ShapeFixTool.hpp>
#include <io/STLTool.hpp>
#include <math/Sphere.hpp>
#include <math/TriangularMesh.hpp>
#include <modeling/CopyShape.hpp>
#include <modeling/MakeBox.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeFace.hpp>
#include <modeling/MakePrism.hpp>
#include <modeling/MakeRevol.hpp>
#include <modeling/MakeShapeTool.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeWire.hpp>
#include <modeling/TransformShape.hpp>
#include <nurbs/NURBSAPIApprox.hpp>
#include <nurbs/NURBSAPIBuildCurve.hpp>
#include <nurbs/NURBSAPICircularSweep.hpp>
#include <nurbs/NURBSAPIConvert.hpp>
#include <nurbs/NURBSAPICurveNetworkSurface.hpp>
#include <nurbs/NURBSAPIExplicitSweep.hpp>
#include <nurbs/NURBSAPIExplode.hpp>
#include <nurbs/NURBSAPIExtend.hpp>
#include <nurbs/NURBSAPIInterpolate.hpp>
#include <nurbs/NURBSAPIJoin.hpp>
#include <nurbs/NURBSAPILinearSweep.hpp>
#include <nurbs/NURBSAPILoft.hpp>
#include <nurbs/NURBSAPIMakeNURBSFromBoundaries.hpp>
#include <nurbs/NURBSAPIMatch.hpp>
#include <nurbs/NURBSAPIModifyEndToPlane.hpp>
#include <nurbs/NURBSAPIOffsetCurveOnSurface.hpp>
#include <nurbs/NURBSAPIProject.hpp>
#include <nurbs/NURBSAPIRebuild.hpp>
#include <nurbs/NURBSAPIReplaceEdge.hpp>
#include <nurbs/NURBSAPISweep.hpp>
#include <nurbs/NURBSAPISweep2.hpp>
#include <nurbs/NURBSAPISweepRotation.hpp>
#include <nurbs/NURBSAPITrim.hpp>
#include <nurbs/NURBSAPIUntrim.hpp>
#include <nurbs/NURBSLinearSweepWithDraftDirectionLength.hpp>
#include <occtio/OCCTTool.hpp>
#include <offset/MakePipe.hpp>
#include <offset/MakePipeShell.hpp>
#include <topology/BRepAdaptorCurve2.hpp>
#include <topology/BRepAdaptorCurve3.hpp>
#include <topology/BRepAdaptorSurface.hpp>
#include <topology/BRepGlobalProperty.hpp>
#include <topology/BRepTool.hpp>
#include <topology/TopoBuilder.hpp>
#include <topology/TopoCompound.hpp>
#include <topology/TopoEdge.hpp>
#include <topology/TopoExplorer.hpp>
#include <topology/TopoExplorerTool.hpp>
#include <topology/TopoFace.hpp>
#include <topology/TopoShape.hpp>
#include <topology/TopoShell.hpp>
#include <topology/TopoTool.hpp>
#include <topology/TopoVertex.hpp>
#include <topology/TopoWire.hpp>
#include <topology/WireExplorer.hpp>
#include <topomesh/BRepMeshIncrementalMesh.hpp>
#include <nurbs/NURBSAPIBlend.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
#include <math/LineT.hpp>
#include <hatch/BRepClassificationTools.hpp>
using namespace AMCAX;
namespace
{
	std::shared_ptr<Geom3BSplineCurve> CurveChooser(const int id, const std::shared_ptr<Geom3BSplineCurve>& curve0, const std::shared_ptr<Geom3BSplineCurve>& curve1, const std::shared_ptr<Geom3BSplineCurve>& curve2)
	{
		std::shared_ptr<Geom3BSplineCurve> result;
		switch (id)
		{
		case 0:
		{
			result = curve0;
			break;
		}
		case 1:
		{
			result = curve1;
			break;
		}
		case 2:
		{
			result = curve2;
			break;
		}
		}
		return result;
	}
;
	SECTION("TestLinearSweepWithTangencySurface2()")
	{
		std::string filedir = INPUT_PATH_PREFIX "/TestNURBS/TestLinearSweepWithTangencySurface2/";
		std::string filedir1 = OUTPUT_PATH_PREFIX;
		auto curve = ReadBRepCurve(filedir + "curve.brep");
		CHECK(OCCTIO::OCCTTool::Write(MakeEdge(curve), OUTPUT_PATH_PREFIX "TestLinearSweepWithTangencySurface2_curve.brep"));
		auto surface = ReadBRepSurface(filedir + "surface.brep");
		CHECK(OCCTIO::OCCTTool::Write(MakeFace(surface, 0.0), OUTPUT_PATH_PREFIX "TestLinearSweepWithTangencySurface2_surface.brep"));
		clock_t bg = clock();
		auto [status, resultSurfaces] = NURBSAPILinearSweep::SweepWithTangencySurface(curve, surface, curve, curve->FirstParameter(), curve->LastParameter());
		clock_t ed = clock();
		std::cout << "time = " << ed - bg << "ms" << std::endl;
		CHECK(status == NURBSSweepStatus::Success);
		if (status == NURBSSweepStatus::Success)
		{
			TopoCompound comp;
			TopoBuilder builder;
			builder.MakeCompound(comp);
			for (const auto& srf : resultSurfaces)
			{
				builder.Add(comp, MakeFace(srf, Precision::Confusion()));
			}
			CHECK(OCCTIO::OCCTTool::Write(comp, OUTPUT_PATH_PREFIX "TestLinearSweepWithTangencySurface2_result.brep"));
			IndexSet<TopoShape> newshapeEdge1;
			TopoExplorerTool::MapShapes(comp, ShapeType::Edge, newshapeEdge1);
			std::cout << "newshapedege.size" << newshapeEdge1.size() << endl;
			CHECK(OCCTIO::OCCTTool::Write(newshapeEdge1[2], OUTPUT_PATH_PREFIX "TestLinearSweepWithTangencySurface2_newshapeEdge1[2].brep"));
			CHECK(OCCTIO::OCCTTool::Write(newshapeEdge1[6], OUTPUT_PATH_PREFIX "TestLinearSweepWithTangencySurface2_newshapeEdge1[6].brep"));
			auto edge0 = ReadBRepCurve(filedir1 + "TestLinearSweepWithTangencySurface2_newshapeEdge1[2].brep");
			auto edge1 = ReadBRepCurve(filedir1 + "TestLinearSweepWithTangencySurface2_newshapeEdge1[6].brep");
			auto surfaces = ReadBRepSurface(filedir1 + "TestLinearSweepWithTangencySurface2_result.brep");
			CHECK(IsSurfTangent(100, 0.1, edge0, surface, resultSurfaces.front(), 20, 0));
			CHECK(IsSurfTangent(100, 0.1, edge1, surface, resultSurfaces.back(), 20, 180));
		}
		CHECK(IsCurveOnSurf(1000, 0.1, curve, resultSurfaces.front(), 0.1));
		CHECK(IsCurveOnSurf(1000, 0.1, curve, resultSurfaces.back(), 0.1));
		IndexSet<TopoShape> newshapeEdge1, newshapeEdge2;
		TopoExplorerTool::MapShapes(MakeFace(resultSurfaces.front(), 0.0), ShapeType::Edge, newshapeEdge1);
		TopoExplorerTool::MapShapes(MakeFace(resultSurfaces.back(), 0.0), ShapeType::Edge, newshapeEdge2);
		AMCAX::BRepExtremaDistShapeShape len1(newshapeEdge1[2], MakeFace(surface, 0.0));
		AMCAX::BRepExtremaDistShapeShape len2(newshapeEdge2[2], MakeFace(surface, 0.0));
		CHECK(len1.Value() == Approx(0.0).margin(0.1));
		CHECK(len2.Value() == Approx(0.0).margin(0.1));
		curve->IncreaseDegree(5);
		surface->IncreaseDegree(5, 5);
		auto [status1, resultSurfaces1] = NURBSAPILinearSweep::SweepWithTangencySurface(curve, surface, curve, curve->FirstParameter(), curve->LastParameter());
		CHECK(status == NURBSSweepStatus::Success);
		CHECK(IsCurveOnSurf(1000, 0.1, curve, resultSurfaces1.front(), 0.1));
		CHECK(IsCurveOnSurf(1000, 0.1, curve, resultSurfaces1.back(), 0.1));
		double bsp3s = GetSurfaceProperties(MakeFace(resultSurfaces1.front(), 0.0), g, true, true);
		double bsp4s = GetSurfaceProperties(MakeFace(resultSurfaces.front(), 0.0), g, true, true);
		CHECK(bsp3s == Approx(bsp4s).margin(0.02));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static std::pair<NURBSSweepStatus, std::vector<std::shared_ptr<Geom3BSplineSurface>>> SweepWithDraftDirection(const std::shared_ptr<Geom3BSplineCurve>& guide, const Direction3& draftDirection, const LawFunction& angleLaw, const NURBSLinearSweepWithDraftDirectionLength& length1, const NURBSLinearSweepWithDraftDirectionLength& length2),
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <filesystem>
#include <fstream>
#include <random>
#include <sstream>
#include <nurbs/NURBSAPIGetGeometry.hpp>
#include <nurbs/NURBSAPIConicalSweep.hpp>
#include <boolean/BoolBRepCut.hpp>
#include <common/CartesianCoordinateSystem.hpp>
#include <common/IndexMap.hpp>
#include <common/QuaternionT.hpp>
#include <geomAlgo/LawBSpline.hpp>
#include <geomAlgo/LawConstant.hpp>
#include <nurbs/NURBSAPISmooth.hpp>
#include <geomAlgo/MakeConic2FromConstraints.hpp>
#include <geometry/Adaptor3CurveOnSurface.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/AdaptorGeom3Surface.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/Geom2Circle.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/Geom2Hyperbola.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom3BSplineCurve.hpp>
#include <geometry/Geom3BSplineSurface.hpp>
#include <geometry/Geom3Circle.hpp>
#include <geometry/Geom3Line.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
#include <geometry/Geom3Plane.hpp>
#include <geometry/Geom3SphericalSurface.hpp>
#include <geometry/Geom3Surface.hpp>
#include <geometry/Geom3TrimmedCurve.hpp>
#include <geometry/Geom3TrimmedSurface.hpp>
#include <geometry/GeomAPIExtremaCurveCurve3.hpp>
#include <geometry/GeomAPIProjectPointOnCurve2.hpp>
#include <geometry/GeomAPIProjectPointOnCurve3.hpp>
#include <geometry/GeomAPIProjectPointOnSurface.hpp>
#include <geometry/GeometryTool.hpp>
#include <geometry/GlobalProperty.hpp>
#include <healing/ShapeFixTool.hpp>
#include <io/STLTool.hpp>
#include <math/Sphere.hpp>
#include <math/TriangularMesh.hpp>
#include <modeling/CopyShape.hpp>
#include <modeling/MakeBox.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeFace.hpp>
#include <modeling/MakePrism.hpp>
#include <modeling/MakeRevol.hpp>
#include <modeling/MakeShapeTool.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeWire.hpp>
#include <modeling/TransformShape.hpp>
#include <nurbs/NURBSAPIApprox.hpp>
#include <nurbs/NURBSAPIBuildCurve.hpp>
#include <nurbs/NURBSAPICircularSweep.hpp>
#include <nurbs/NURBSAPIConvert.hpp>
#include <nurbs/NURBSAPICurveNetworkSurface.hpp>
#include <nurbs/NURBSAPIExplicitSweep.hpp>
#include <nurbs/NURBSAPIExplode.hpp>
#include <nurbs/NURBSAPIExtend.hpp>
#include <nurbs/NURBSAPIInterpolate.hpp>
#include <nurbs/NURBSAPIJoin.hpp>
#include <nurbs/NURBSAPILinearSweep.hpp>
#include <nurbs/NURBSAPILoft.hpp>
#include <nurbs/NURBSAPIMakeNURBSFromBoundaries.hpp>
#include <nurbs/NURBSAPIMatch.hpp>
#include <nurbs/NURBSAPIModifyEndToPlane.hpp>
#include <nurbs/NURBSAPIOffsetCurveOnSurface.hpp>
#include <nurbs/NURBSAPIProject.hpp>
#include <nurbs/NURBSAPIRebuild.hpp>
#include <nurbs/NURBSAPIReplaceEdge.hpp>
#include <nurbs/NURBSAPISweep.hpp>
#include <nurbs/NURBSAPISweep2.hpp>
#include <nurbs/NURBSAPISweepRotation.hpp>
#include <nurbs/NURBSAPITrim.hpp>
#include <nurbs/NURBSAPIUntrim.hpp>
#include <nurbs/NURBSLinearSweepWithDraftDirectionLength.hpp>
#include <occtio/OCCTTool.hpp>
#include <offset/MakePipe.hpp>
#include <offset/MakePipeShell.hpp>
#include <topology/BRepAdaptorCurve2.hpp>
#include <topology/BRepAdaptorCurve3.hpp>
#include <topology/BRepAdaptorSurface.hpp>
#include <topology/BRepGlobalProperty.hpp>
#include <topology/BRepTool.hpp>
#include <topology/TopoBuilder.hpp>
#include <topology/TopoCompound.hpp>
#include <topology/TopoEdge.hpp>
#include <topology/TopoExplorer.hpp>
#include <topology/TopoExplorerTool.hpp>
#include <topology/TopoFace.hpp>
#include <topology/TopoShape.hpp>
#include <topology/TopoShell.hpp>
#include <topology/TopoTool.hpp>
#include <topology/TopoVertex.hpp>
#include <topology/TopoWire.hpp>
#include <topology/WireExplorer.hpp>
#include <topomesh/BRepMeshIncrementalMesh.hpp>
#include <nurbs/NURBSAPIBlend.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
#include <math/LineT.hpp>
#include <hatch/BRepClassificationTools.hpp>
using namespace AMCAX;
namespace
{
	std::shared_ptr<Geom3BSplineCurve> CurveChooser(const int id, const std::shared_ptr<Geom3BSplineCurve>& curve0, const std::shared_ptr<Geom3BSplineCurve>& curve1, const std::shared_ptr<Geom3BSplineCurve>& curve2)
	{
		std::shared_ptr<Geom3BSplineCurve> result;
		switch (id)
		{
		case 0:
		{
			result = curve0;
			break;
		}
		case 1:
		{
			result = curve1;
			break;
		}
		case 2:
		{
			result = curve2;
			break;
		}
		}
		return result;
	}
} 
#include<catch.hpp>
#include<testHelper.h>
#include <filesystem>
#include <fstream>
#include <random>
#include <sstream>
#include <nurbs/NURBSAPIGetGeometry.hpp>
#include <nurbs/NURBSAPIConicalSweep.hpp>
#include <boolean/BoolBRepCut.hpp>
#include <common/CartesianCoordinateSystem.hpp>
#include <common/IndexMap.hpp>
#include <common/QuaternionT.hpp>
#include <geomAlgo/LawBSpline.hpp>
#include <geomAlgo/LawConstant.hpp>
#include <nurbs/NURBSAPISmooth.hpp>
#include <geomAlgo/MakeConic2FromConstraints.hpp>
#include <geometry/Adaptor3CurveOnSurface.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/AdaptorGeom3Surface.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/Geom2Circle.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/Geom2Hyperbola.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom3BSplineCurve.hpp>
#include <geometry/Geom3BSplineSurface.hpp>
#include <geometry/Geom3Circle.hpp>
#include <geometry/Geom3Line.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
#include <geometry/Geom3Plane.hpp>
#include <geometry/Geom3SphericalSurface.hpp>
#include <geometry/Geom3Surface.hpp>
#include <geometry/Geom3TrimmedCurve.hpp>
#include <geometry/Geom3TrimmedSurface.hpp>
#include <geometry/GeomAPIExtremaCurveCurve3.hpp>
#include <geometry/GeomAPIProjectPointOnCurve2.hpp>
#include <geometry/GeomAPIProjectPointOnCurve3.hpp>
#include <geometry/GeomAPIProjectPointOnSurface.hpp>
#include <geometry/GeometryTool.hpp>
#include <geometry/GlobalProperty.hpp>
#include <healing/ShapeFixTool.hpp>
#include <io/STLTool.hpp>
#include <math/Sphere.hpp>
#include <math/TriangularMesh.hpp>
#include <modeling/CopyShape.hpp>
#include <modeling/MakeBox.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeFace.hpp>
#include <modeling/MakePrism.hpp>
#include <modeling/MakeRevol.hpp>
#include <modeling/MakeShapeTool.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeWire.hpp>
#include <modeling/TransformShape.hpp>
#include <nurbs/NURBSAPIApprox.hpp>
#include <nurbs/NURBSAPIBuildCurve.hpp>
#include <nurbs/NURBSAPICircularSweep.hpp>
#include <nurbs/NURBSAPIConvert.hpp>
#include <nurbs/NURBSAPICurveNetworkSurface.hpp>
#include <nurbs/NURBSAPIExplicitSweep.hpp>
#include <nurbs/NURBSAPIExplode.hpp>
#include <nurbs/NURBSAPIExtend.hpp>
#include <nurbs/NURBSAPIInterpolate.hpp>
#include <nurbs/NURBSAPIJoin.hpp>
#include <nurbs/NURBSAPILinearSweep.hpp>
#include <nurbs/NURBSAPILoft.hpp>
#include <nurbs/NURBSAPIMakeNURBSFromBoundaries.hpp>
#include <nurbs/NURBSAPIMatch.hpp>
#include <nurbs/NURBSAPIModifyEndToPlane.hpp>
#include <nurbs/NURBSAPIOffsetCurveOnSurface.hpp>
#include <nurbs/NURBSAPIProject.hpp>
#include <nurbs/NURBSAPIRebuild.hpp>
#include <nurbs/NURBSAPIReplaceEdge.hpp>
#include <nurbs/NURBSAPISweep.hpp>
#include <nurbs/NURBSAPISweep2.hpp>
#include <nurbs/NURBSAPISweepRotation.hpp>
#include <nurbs/NURBSAPITrim.hpp>
#include <nurbs/NURBSAPIUntrim.hpp>
#include <nurbs/NURBSLinearSweepWithDraftDirectionLength.hpp>
#include <occtio/OCCTTool.hpp>
#include <offset/MakePipe.hpp>
#include <offset/MakePipeShell.hpp>
#include <topology/BRepAdaptorCurve2.hpp>
#include <topology/BRepAdaptorCurve3.hpp>
#include <topology/BRepAdaptorSurface.hpp>
#include <topology/BRepGlobalProperty.hpp>
#include <topology/BRepTool.hpp>
#include <topology/TopoBuilder.hpp>
#include <topology/TopoCompound.hpp>
#include <topology/TopoEdge.hpp>
#include <topology/TopoExplorer.hpp>
#include <topology/TopoExplorerTool.hpp>
#include <topology/TopoFace.hpp>
#include <topology/TopoShape.hpp>
#include <topology/TopoShell.hpp>
#include <topology/TopoTool.hpp>
#include <topology/TopoVertex.hpp>
#include <topology/TopoWire.hpp>
#include <topology/WireExplorer.hpp>
#include <topomesh/BRepMeshIncrementalMesh.hpp>
#include <nurbs/NURBSAPIBlend.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
#include <math/LineT.hpp>
#include <hatch/BRepClassificationTools.hpp>
using namespace AMCAX;
namespace
{
	std::shared_ptr<Geom3BSplineCurve> CurveChooser(const int id, const std::shared_ptr<Geom3BSplineCurve>& curve0, const std::shared_ptr<Geom3BSplineCurve>& curve1, const std::shared_ptr<Geom3BSplineCurve>& curve2)
	{
		std::shared_ptr<Geom3BSplineCurve> result;
		switch (id)
		{
		case 0:
		{
			result = curve0;
			break;
		}
		case 1:
		{
			result = curve1;
			break;
		}
		case 2:
		{
			result = curve2;
			break;
		}
		}
		return result;
	}
;
	SECTION("TestLinearSweepWithDraftDirection()")
	{
		std::string filedir = INPUT_PATH_PREFIX "/TestNURBS/TestLinearSweepWithDraftDirection/";
		auto curve = ReadBRepCurve(filedir + "curve.brep");
		CHECK(OCCTIO::OCCTTool::Write(MakeEdge(curve), OUTPUT_PATH_PREFIX "TestLinearSweepWithDraftDirection_curve.brep"));
		Direction3 draftDirection(0.0, 0.0, 1.0);
		LawConstant angleLaw;
		angleLaw.Set(M_PI_4 * 0.5, 0.0, 1.0);
		auto surf1 = ReadBRepSurface(filedir + "surf1.brep");
		NURBSLinearSweepWithDraftDirectionLength standard(NURBSLinearSweepWithDraftDirectionLengthType::Standard, 3.0, surf1);
		auto [status, result] = NURBSAPILinearSweep::SweepWithDraftDirection(curve, draftDirection, angleLaw, standard, standard);
		CHECK(status == NURBSSweepStatus::Success);
		if (status == NURBSSweepStatus::Success)
		{
			const auto& surf = result[1];
			CHECK(OCCTIO::OCCTTool::Write(MakeFace(surf, 0.0), OUTPUT_PATH_PREFIX "TestLinearSweepWithDraftDirection_result.brep"));
			CHECK(OCCTIO::OCCTTool::Write(MakeFace(result[0], 0.0), OUTPUT_PATH_PREFIX "TestLinearSweepWithDraftDirection_result0.brep"));
			CHECK(OCCTIO::OCCTTool::Write(MakeFace(result[2], 0.0), OUTPUT_PATH_PREFIX "TestLinearSweepWithDraftDirection_result2.brep"));
			CHECK(OCCTIO::OCCTTool::Write(MakeFace(result[3], 0.0), OUTPUT_PATH_PREFIX "TestLinearSweepWithDraftDirection_result3.brep"));
			TopoShape face = MakeFace(surf, Precision::Confusion());
			CHECK(IsCurveOnSurf(1000, 0.2, curve, result[1], 0.2));
			AMCAX::BRepExtremaDistShapeShape len1(MakeEdge(curve), MakeFace(result[1], 0.0));
			CHECK(len1.Value() < 0.1);
		}
		curve->IncreaseDegree(11);
		auto [status1, result1] = NURBSAPILinearSweep::SweepWithDraftDirection(curve, draftDirection, angleLaw, standard, standard);
		CHECK(status1 == NURBSSweepStatus::Success);
		if (status1 == NURBSSweepStatus::Success)
		{
			const auto& surf = result1[1];
			CHECK(OCCTIO::OCCTTool::Write(MakeFace(surf, 0.0), OUTPUT_PATH_PREFIX "TestLinearSweepWithDraftDirection_degree11result.brep"));
			TopoShape face = MakeFace(surf, Precision::Confusion());
			CHECK(IsCurveOnSurf(1000, 0.2, curve, result1[1], 0.2));
			AMCAX::BRepExtremaDistShapeShape len1(MakeEdge(curve), MakeFace(result1[1], 0.0));
			CHECK(len1.Value() < 0.1);
			double bsp3s = GetSurfaceProperties(MakeFace(result1[1], 0.0), g, true, true);
			double bsp4s = GetSurfaceProperties(MakeFace(result[1], 0.0), g, true, true);
			CHECK(bsp3s == Approx(bsp4s).margin(0.02));
		}
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static std::pair<NURBSSweepStatus, std::vector<std::shared_ptr<Geom3BSplineSurface>>> SweepWithTwoTangencySurfaces(const std::shared_ptr<Geom3BSplineCurve>& spine, const std::shared_ptr<Geom3BSplineSurface>& tangencySurface1, const std::shared_ptr<Geom3BSplineSurface>& tangencySurface2, double spineLeftBound, double spineRightBound),
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <filesystem>
#include <fstream>
#include <random>
#include <sstream>
#include <nurbs/NURBSAPIGetGeometry.hpp>
#include <nurbs/NURBSAPIConicalSweep.hpp>
#include <boolean/BoolBRepCut.hpp>
#include <common/CartesianCoordinateSystem.hpp>
#include <common/IndexMap.hpp>
#include <common/QuaternionT.hpp>
#include <geomAlgo/LawBSpline.hpp>
#include <geomAlgo/LawConstant.hpp>
#include <nurbs/NURBSAPISmooth.hpp>
#include <geomAlgo/MakeConic2FromConstraints.hpp>
#include <geometry/Adaptor3CurveOnSurface.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/AdaptorGeom3Surface.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/Geom2Circle.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/Geom2Hyperbola.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom3BSplineCurve.hpp>
#include <geometry/Geom3BSplineSurface.hpp>
#include <geometry/Geom3Circle.hpp>
#include <geometry/Geom3Line.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
#include <geometry/Geom3Plane.hpp>
#include <geometry/Geom3SphericalSurface.hpp>
#include <geometry/Geom3Surface.hpp>
#include <geometry/Geom3TrimmedCurve.hpp>
#include <geometry/Geom3TrimmedSurface.hpp>
#include <geometry/GeomAPIExtremaCurveCurve3.hpp>
#include <geometry/GeomAPIProjectPointOnCurve2.hpp>
#include <geometry/GeomAPIProjectPointOnCurve3.hpp>
#include <geometry/GeomAPIProjectPointOnSurface.hpp>
#include <geometry/GeometryTool.hpp>
#include <geometry/GlobalProperty.hpp>
#include <healing/ShapeFixTool.hpp>
#include <io/STLTool.hpp>
#include <math/Sphere.hpp>
#include <math/TriangularMesh.hpp>
#include <modeling/CopyShape.hpp>
#include <modeling/MakeBox.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeFace.hpp>
#include <modeling/MakePrism.hpp>
#include <modeling/MakeRevol.hpp>
#include <modeling/MakeShapeTool.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeWire.hpp>
#include <modeling/TransformShape.hpp>
#include <nurbs/NURBSAPIApprox.hpp>
#include <nurbs/NURBSAPIBuildCurve.hpp>
#include <nurbs/NURBSAPICircularSweep.hpp>
#include <nurbs/NURBSAPIConvert.hpp>
#include <nurbs/NURBSAPICurveNetworkSurface.hpp>
#include <nurbs/NURBSAPIExplicitSweep.hpp>
#include <nurbs/NURBSAPIExplode.hpp>
#include <nurbs/NURBSAPIExtend.hpp>
#include <nurbs/NURBSAPIInterpolate.hpp>
#include <nurbs/NURBSAPIJoin.hpp>
#include <nurbs/NURBSAPILinearSweep.hpp>
#include <nurbs/NURBSAPILoft.hpp>
#include <nurbs/NURBSAPIMakeNURBSFromBoundaries.hpp>
#include <nurbs/NURBSAPIMatch.hpp>
#include <nurbs/NURBSAPIModifyEndToPlane.hpp>
#include <nurbs/NURBSAPIOffsetCurveOnSurface.hpp>
#include <nurbs/NURBSAPIProject.hpp>
#include <nurbs/NURBSAPIRebuild.hpp>
#include <nurbs/NURBSAPIReplaceEdge.hpp>
#include <nurbs/NURBSAPISweep.hpp>
#include <nurbs/NURBSAPISweep2.hpp>
#include <nurbs/NURBSAPISweepRotation.hpp>
#include <nurbs/NURBSAPITrim.hpp>
#include <nurbs/NURBSAPIUntrim.hpp>
#include <nurbs/NURBSLinearSweepWithDraftDirectionLength.hpp>
#include <occtio/OCCTTool.hpp>
#include <offset/MakePipe.hpp>
#include <offset/MakePipeShell.hpp>
#include <topology/BRepAdaptorCurve2.hpp>
#include <topology/BRepAdaptorCurve3.hpp>
#include <topology/BRepAdaptorSurface.hpp>
#include <topology/BRepGlobalProperty.hpp>
#include <topology/BRepTool.hpp>
#include <topology/TopoBuilder.hpp>
#include <topology/TopoCompound.hpp>
#include <topology/TopoEdge.hpp>
#include <topology/TopoExplorer.hpp>
#include <topology/TopoExplorerTool.hpp>
#include <topology/TopoFace.hpp>
#include <topology/TopoShape.hpp>
#include <topology/TopoShell.hpp>
#include <topology/TopoTool.hpp>
#include <topology/TopoVertex.hpp>
#include <topology/TopoWire.hpp>
#include <topology/WireExplorer.hpp>
#include <topomesh/BRepMeshIncrementalMesh.hpp>
#include <nurbs/NURBSAPIBlend.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
#include <math/LineT.hpp>
#include <hatch/BRepClassificationTools.hpp>
using namespace AMCAX;
namespace
{
	std::shared_ptr<Geom3BSplineCurve> CurveChooser(const int id, const std::shared_ptr<Geom3BSplineCurve>& curve0, const std::shared_ptr<Geom3BSplineCurve>& curve1, const std::shared_ptr<Geom3BSplineCurve>& curve2)
	{
		std::shared_ptr<Geom3BSplineCurve> result;
		switch (id)
		{
		case 0:
		{
			result = curve0;
			break;
		}
		case 1:
		{
			result = curve1;
			break;
		}
		case 2:
		{
			result = curve2;
			break;
		}
		}
		return result;
	}
} 
#include<catch.hpp>
#include<testHelper.h>
#include <filesystem>
#include <fstream>
#include <random>
#include <sstream>
#include <nurbs/NURBSAPIGetGeometry.hpp>
#include <nurbs/NURBSAPIConicalSweep.hpp>
#include <boolean/BoolBRepCut.hpp>
#include <common/CartesianCoordinateSystem.hpp>
#include <common/IndexMap.hpp>
#include <common/QuaternionT.hpp>
#include <geomAlgo/LawBSpline.hpp>
#include <geomAlgo/LawConstant.hpp>
#include <nurbs/NURBSAPISmooth.hpp>
#include <geomAlgo/MakeConic2FromConstraints.hpp>
#include <geometry/Adaptor3CurveOnSurface.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/AdaptorGeom3Surface.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/Geom2Circle.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/Geom2Hyperbola.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom3BSplineCurve.hpp>
#include <geometry/Geom3BSplineSurface.hpp>
#include <geometry/Geom3Circle.hpp>
#include <geometry/Geom3Line.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
#include <geometry/Geom3Plane.hpp>
#include <geometry/Geom3SphericalSurface.hpp>
#include <geometry/Geom3Surface.hpp>
#include <geometry/Geom3TrimmedCurve.hpp>
#include <geometry/Geom3TrimmedSurface.hpp>
#include <geometry/GeomAPIExtremaCurveCurve3.hpp>
#include <geometry/GeomAPIProjectPointOnCurve2.hpp>
#include <geometry/GeomAPIProjectPointOnCurve3.hpp>
#include <geometry/GeomAPIProjectPointOnSurface.hpp>
#include <geometry/GeometryTool.hpp>
#include <geometry/GlobalProperty.hpp>
#include <healing/ShapeFixTool.hpp>
#include <io/STLTool.hpp>
#include <math/Sphere.hpp>
#include <math/TriangularMesh.hpp>
#include <modeling/CopyShape.hpp>
#include <modeling/MakeBox.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeFace.hpp>
#include <modeling/MakePrism.hpp>
#include <modeling/MakeRevol.hpp>
#include <modeling/MakeShapeTool.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeWire.hpp>
#include <modeling/TransformShape.hpp>
#include <nurbs/NURBSAPIApprox.hpp>
#include <nurbs/NURBSAPIBuildCurve.hpp>
#include <nurbs/NURBSAPICircularSweep.hpp>
#include <nurbs/NURBSAPIConvert.hpp>
#include <nurbs/NURBSAPICurveNetworkSurface.hpp>
#include <nurbs/NURBSAPIExplicitSweep.hpp>
#include <nurbs/NURBSAPIExplode.hpp>
#include <nurbs/NURBSAPIExtend.hpp>
#include <nurbs/NURBSAPIInterpolate.hpp>
#include <nurbs/NURBSAPIJoin.hpp>
#include <nurbs/NURBSAPILinearSweep.hpp>
#include <nurbs/NURBSAPILoft.hpp>
#include <nurbs/NURBSAPIMakeNURBSFromBoundaries.hpp>
#include <nurbs/NURBSAPIMatch.hpp>
#include <nurbs/NURBSAPIModifyEndToPlane.hpp>
#include <nurbs/NURBSAPIOffsetCurveOnSurface.hpp>
#include <nurbs/NURBSAPIProject.hpp>
#include <nurbs/NURBSAPIRebuild.hpp>
#include <nurbs/NURBSAPIReplaceEdge.hpp>
#include <nurbs/NURBSAPISweep.hpp>
#include <nurbs/NURBSAPISweep2.hpp>
#include <nurbs/NURBSAPISweepRotation.hpp>
#include <nurbs/NURBSAPITrim.hpp>
#include <nurbs/NURBSAPIUntrim.hpp>
#include <nurbs/NURBSLinearSweepWithDraftDirectionLength.hpp>
#include <occtio/OCCTTool.hpp>
#include <offset/MakePipe.hpp>
#include <offset/MakePipeShell.hpp>
#include <topology/BRepAdaptorCurve2.hpp>
#include <topology/BRepAdaptorCurve3.hpp>
#include <topology/BRepAdaptorSurface.hpp>
#include <topology/BRepGlobalProperty.hpp>
#include <topology/BRepTool.hpp>
#include <topology/TopoBuilder.hpp>
#include <topology/TopoCompound.hpp>
#include <topology/TopoEdge.hpp>
#include <topology/TopoExplorer.hpp>
#include <topology/TopoExplorerTool.hpp>
#include <topology/TopoFace.hpp>
#include <topology/TopoShape.hpp>
#include <topology/TopoShell.hpp>
#include <topology/TopoTool.hpp>
#include <topology/TopoVertex.hpp>
#include <topology/TopoWire.hpp>
#include <topology/WireExplorer.hpp>
#include <topomesh/BRepMeshIncrementalMesh.hpp>
#include <nurbs/NURBSAPIBlend.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
#include <math/LineT.hpp>
#include <hatch/BRepClassificationTools.hpp>
using namespace AMCAX;
namespace
{
	std::shared_ptr<Geom3BSplineCurve> CurveChooser(const int id, const std::shared_ptr<Geom3BSplineCurve>& curve0, const std::shared_ptr<Geom3BSplineCurve>& curve1, const std::shared_ptr<Geom3BSplineCurve>& curve2)
	{
		std::shared_ptr<Geom3BSplineCurve> result;
		switch (id)
		{
		case 0:
		{
			result = curve0;
			break;
		}
		case 1:
		{
			result = curve1;
			break;
		}
		case 2:
		{
			result = curve2;
			break;
		}
		}
		return result;
	}
;
	SECTION("TestLinearSweepWithTwoTangencySurfaces()")
	{
		std::string filedir1 = OUTPUT_PATH_PREFIX;
		std::string filedir = INPUT_PATH_PREFIX "/TestNURBS/TestLinearSweepWithTwoTangencySurfaces/";
		auto spine = ReadBRepCurve(filedir + "spine.brep");
		CHECK(OCCTIO::OCCTTool::Write(MakeEdge(spine), OUTPUT_PATH_PREFIX "TestLinearSweepWithTwoTangencySurfaces_spine.brep"));
		auto surf1 = ReadBRepSurface(filedir + "surf1.brep");
		CHECK(OCCTIO::OCCTTool::Write(MakeFace(surf1, 0.0), OUTPUT_PATH_PREFIX "TestLinearSweepWithTwoTangencySurfaces_surf1.brep"));
		auto surf2 = ReadBRepSurface(filedir + "surf2.brep");
		CHECK(OCCTIO::OCCTTool::Write(MakeFace(surf2, 0.0), OUTPUT_PATH_PREFIX "TestLinearSweepWithTwoTangencySurfaces_surf2.brep"));
		auto [status, result] = NURBSAPILinearSweep::SweepWithTwoTangencySurfaces(spine, surf1, surf2, spine->FirstParameter(), spine->LastParameter());
		CHECK(status == NURBSSweepStatus::Success);
		if (status == NURBSSweepStatus::Success && !result.empty())
		{
			CHECK(OCCTIO::OCCTTool::Write(MakeFace(result.front(), 0.0), OUTPUT_PATH_PREFIX "TestLinearSweepWithTwoTangencySurfaces_result.brep"));
		}
		CHECK(result.size() == 1);
		IndexSet<TopoShape> newshapeEdge1;
		std::cout << "newshapedege.size" << newshapeEdge1.size() << endl;
		TopoExplorerTool::MapShapes(MakeFace(result.front(), 0.0), ShapeType::Edge, newshapeEdge1);
		CHECK(OCCTIO::OCCTTool::Write(newshapeEdge1[0], OUTPUT_PATH_PREFIX "TestLinearSweepWithTwoTangencySurfaces_newshapeEdge1[0].brep"));
		CHECK(OCCTIO::OCCTTool::Write(newshapeEdge1[2], OUTPUT_PATH_PREFIX "TestLinearSweepWithTwoTangencySurfaces_newshapeEdge1[2].brep"));
		auto edge0 = ReadBRepCurve(filedir1 + "TestLinearSweepWithTwoTangencySurfaces_newshapeEdge1[0].brep");
		auto edge1 = ReadBRepCurve(filedir1 + "TestLinearSweepWithTwoTangencySurfaces_newshapeEdge1[2].brep");
		auto surface = ReadBRepSurface(filedir1 + "TestLinearSweepWithTwoTangencySurfaces_result.brep");
		AMCAX::BRepExtremaDistShapeShape len1(newshapeEdge1[0], MakeFace(surf1, 0.0));
		AMCAX::BRepExtremaDistShapeShape len2(newshapeEdge1[2], MakeFace(surf2, 0.0));
		CHECK(IsSurfTangent(100, 0.1, edge0, surf1, surface, 20, 180));
		CHECK(IsSurfTangent(100, 0.1, edge1, surf2, surface, 20, 0));
		CHECK(len1.Value() == Approx(0.0).margin(0.1));
		CHECK(len2.Value() == Approx(0.0).margin(0.1));
		surf1->IncreaseDegree(11, 11);
		surf2->IncreaseDegree(11, 11);
		spine->IncreaseDegree(11);
		auto [status1, result1] = NURBSAPILinearSweep::SweepWithTwoTangencySurfaces(spine, surf1, surf2, spine->FirstParameter(), spine->LastParameter());
		CHECK(status1 == NURBSSweepStatus::Success);
		if (status1 == NURBSSweepStatus::Success && !result1.empty())
		{
			CHECK(OCCTIO::OCCTTool::Write(MakeFace(result1.front(), 0.0), OUTPUT_PATH_PREFIX "TestLinearSweepWithTwoTangencySurfaces_degree11result.brep"));
			CHECK(IsSurfTangent(100, 0.1, edge0, surf1, surface, 20, 180));
			CHECK(IsSurfTangent(100, 0.1, edge1, surf2, surface, 20, 0));
			CHECK(len1.Value() == Approx(0.0).margin(0.1));
			CHECK(len2.Value() == Approx(0.0).margin(0.1));
			double bsp3s = GetSurfaceProperties(MakeFace(result1[0], 0.0), g, true, true);
			double bsp4s = GetSurfaceProperties(MakeFace(result[0], 0.0), g, true, true);
			CHECK(bsp3s == Approx(bsp4s).margin(0.02));
		}
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static std::shared_ptr<Geom3BSplineSurface> MakeLoft(const std::vector<NURBSCurveSection>& sections, bool isClosedLofting = false, NURBSLoftSurfaceStype stype = NURBSLoftSurfaceStype::Standard, ApproxParameterizationType ptype = ApproxParameterizationType::Centripetal)	 @return The loft surface
	 @param ptype Parameterization type
	 @param stype The type of surface building such as interpolate, approx. It determines the error between surface and curves.
	 @param isClosedLofting Is surface closed
	 @param sections Curves with begin parameter and is reverse flag
	 @brief Make lofting (section curves -> a surface)
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <nurbs/NURBSAPILoft.hpp>
#include <geometry/Geom3BSplineCurve.hpp>
#include <geometry/Geom3BSplineSurface.hpp>
#include <nurbs/NURBSAPICurveNetworkSurface.hpp>
#include <topology/TopoEdge.hpp>
#include <topology/TopoTool.hpp>
#include <nurbs/NURBSAPILoft.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeFace.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
#include <geometry/GeomAPIProjectPointOnSurface.hpp>
using namespace std;
double NurbsSampleCurveOnSurface1(int num, double tol, const shared_ptr<Geom3Curve>& curve, const shared_ptr<Geom3Surface>& surf)
{
	const int nsample = num;
	double fp1 = curve->FirstParameter();
	double lp1 = curve->LastParameter();
	double delta1 = (lp1 - fp1) / nsample;
	Point3 p;
	int n = 0;
	for (int i = 0; i < nsample; i++)
	{
		double t1 = fp1 + i * delta1;
		curve->D0(t1, p);
		GeomAPIProjectPointOnSurface projector(p, surf);
		double dis = projector.LowerDistance();
		if (dis <= tol)
		{
			n++;
		}
	}
	double res = 1.0 * (num - n) / num;
	return res;
}
vector< shared_ptr<Geom3BSplineCurve>> ConstructBSplineCurve1()
{
	vector<shared_ptr<Geom3BSplineCurve>> vec;
	std::vector<bool> isVRational(4, true);
	isVRational[1] = false;
	std::shared_ptr<Geom3BSplineCurve> vbsp1, vbsp2, vbsp3, vbsp4;
	{
		int deg = 3;
		std::vector<Point3> poles;
		poles.push_back(Point3(0.0, -1.0, 0.1));
		poles.push_back(Point3(0.07, -0.7, 0.2));
		poles.push_back(Point3(0.1, -0.3, 0.1));
		poles.push_back(Point3(0.12, 0.0, -0.1));
		poles.push_back(Point3(0.20, 0.3, -0.2));
		poles.push_back(Point3(0.07, 0.7, -0.3));
		poles.push_back(Point3(0.0, 1.0, 0.0));
		std::vector<double> weights;
		weights.push_back(0.5);
		weights.push_back(1.5);
		weights.push_back(1.2);
		weights.push_back(0.5);
		weights.push_back(0.7);
		weights.push_back(0.9);
		weights.push_back(0.4);
		int nknots = static_cast<int>(poles.size()) - deg + 1;
		std::vector<double> knots(nknots);
		for (int i = 0; i < nknots; i++)
		{
			knots[i] = (double)i / (double)(nknots - 1.0);
		}
		std::vector<int> mults(nknots, 1);
		mults.front() = deg + 1;
		mults.back() = deg + 1;
		if (isVRational[0])
		{
			vbsp1 = std::make_shared<Geom3BSplineCurve>(poles, weights, knots, mults, deg);
		}
		else
		{
			vbsp1 = std::make_shared<Geom3BSplineCurve>(poles, knots, mults, deg);
		}
	}
	{
		int deg = 3;
		std::vector<Point3> poles;
		poles.push_back(Point3(2.0, -2.0, -0.1));
		poles.push_back(Point3(2.1, -1.3, -0.2));
		poles.push_back(Point3(2.15, -0.8, -0.1));
		poles.push_back(Point3(1.83, -0.2, 0.1));
		poles.push_back(Point3(1.48, 0.1, 0.2));
		poles.push_back(Point3(1.0, 1.0, 0.1));
		std::vector<double> weights;
		weights.push_back(0.5);
		weights.push_back(1.5);
		weights.push_back(1.2);
		weights.push_back(0.5);
		weights.push_back(1.2);
		weights.push_back(0.5);
		int nknots = static_cast<int>(poles.size()) - deg + 1;
		std::vector<double> knots(nknots);
		for (int i = 0; i < nknots; i++)
		{
			knots[i] = (double)i / (double)(nknots - 1.0);
		}
		std::vector<int> mults(nknots, 1);
		mults.front() = deg + 1;
		mults.back() = deg + 1;
		if (isVRational[1])
		{
			vbsp2 = std::make_shared<Geom3BSplineCurve>(poles, weights, knots, mults, deg);
		}
		else
		{
			vbsp2 = std::make_shared<Geom3BSplineCurve>(poles, knots, mults, deg);
		}
	}
	{
		int deg = 3;
		std::vector<Point3> poles;
		poles.push_back(Point3(3.0, -2.0, 0.1));
		poles.push_back(Point3(3.07, -1.3, 0.2));
		poles.push_back(Point3(3.1, -0.3, 0.1));
		poles.push_back(Point3(3.12, 0.0, -0.1));
		poles.push_back(Point3(3.0, 0.3, -0.2));
		poles.push_back(Point3(2.57, 0.7, -0.3));
		poles.push_back(Point3(2.2, 1.0, 0.0));
		std::vector<double> weights;
		weights.push_back(0.7);
		weights.push_back(1.5);
		weights.push_back(1.2);
		weights.push_back(0.5);
		weights.push_back(1.2);
		weights.push_back(0.8);
		weights.push_back(1.3);
		int nknots = static_cast<int>(poles.size()) - deg + 1;
		std::vector<double> knots(nknots);
		for (int i = 0; i < nknots; i++)
		{
			knots[i] = (double)i / (double)(nknots - 1.0);
		}
		std::vector<int> mults(nknots, 1);
		mults.front() = deg + 1;
		mults.back() = deg + 1;
		if (isVRational[2])
		{
			vbsp3 = std::make_shared<Geom3BSplineCurve>(poles, weights, knots, mults, deg);
		}
		else
		{
			vbsp3 = std::make_shared<Geom3BSplineCurve>(poles, knots, mults, deg);
		}
	}
	{
		int deg = 3;
		std::vector<Point3> poles;
		poles.push_back(Point3(4.0, -1.5, -0.1));
		poles.push_back(Point3(4.1, -1.3, -0.2));
		poles.push_back(Point3(4.15, -0.8, -0.1));
		poles.push_back(Point3(3.83, -0.2, 0.1));
		poles.push_back(Point3(3.48, 0.1, 0.2));
		poles.push_back(Point3(3.0, 1.0, 0.1));
		std::vector<double> weights;
		weights.push_back(1.5);
		weights.push_back(0.7);
		weights.push_back(1.2);
		weights.push_back(0.8);
		weights.push_back(1.2);
		weights.push_back(1.3);
		int nknots = static_cast<int>(poles.size()) - deg + 1;
		std::vector<double> knots(nknots);
		for (int i = 0; i < nknots; i++)
		{
			knots[i] = (double)i / (double)(nknots - 1.0);
		}
		std::vector<int> mults(nknots, 1);
		mults.front() = deg + 1;
		mults.back() = deg + 1;
		if (isVRational[3])
		{
			vbsp4 = std::make_shared<Geom3BSplineCurve>(poles, weights, knots, mults, deg);
		}
		else
		{
			vbsp4 = std::make_shared<Geom3BSplineCurve>(poles, knots, mults, deg);
		}
	}
	vec.push_back(vbsp1);
	vec.push_back(vbsp2);
	vec.push_back(vbsp3);
	vec.push_back(vbsp4);
	return vec;
}
TEST_CASE("bug1: MakeLoft ", "[nurbs][Loft][fixbug]")
{
	OUTPUT_DIRECTORY(nurbs, Loft/bug570);
	std::vector<NURBSCurveSection> sections;
	std::vector<shared_ptr<Geom3BSplineCurve>> curve;
	int deg = 3;
	double sqrt32 = std::sqrt(3.0) / 2.0;
	std::vector<Point3> poles;
	poles.push_back(Point3(-4.0, 0.0, 1.0));
	poles.push_back(Point3(-3.0, 0.0, -0.5));
	poles.push_back(Point3(sqrt32 - 4.0, 0.0, 0.5));
	poles.push_back(Point3(-4.0, 0.0, 1.0));
	poles.push_back(Point3(-sqrt32 - 4, 0.0, 0.5));
	poles.push_back(Point3(-sqrt32 - 4, 0.0, -0.5));
	std::vector<double> weights;
	weights.push_back(1.1);
	weights.push_back(0.8);
	weights.push_back(1.7);
	weights.push_back(1.3);
	weights.push_back(0.9);
	weights.push_back(1.0);
	std::vector<double> knots(static_cast<int>(poles.size()) + 1);
	for (int i = 0; i < static_cast<int>(knots.size()); i++)
	{
		knots[i] = (double)i / (double)(static_cast<int>(knots.size()) - 1);
	}
	knots[1] += 0.1;
	std::vector<int> mults(knots.size(), 1);
	std::shared_ptr<Geom3BSplineCurve> basicCurve = std::make_shared<Geom3BSplineCurve>(poles, weights, knots, mults, deg, true);
	int nsec = 7;
	for (int i = 0; i < nsec; i++)
	{
		auto crCurve = std::dynamic_pointer_cast<Geom3BSplineCurve>(basicCurve->Copy());
		int pid = i % crCurve->NPoles();
		crCurve->SetPole(pid, Point3(crCurve->Pole(pid).Coord() + Coord3(0.1, 0.1, 0.1)));
		Transformation3 trans;
		trans.SetRotation(Axis3(Point3(0.0, 0.0, 0.0), Direction3(0.0, 0.0, 1.0)), 2 * M_PI * i / (double)nsec);
		crCurve->Transform(trans);
		sections.push_back(NURBSCurveSection(crCurve, i * 0.2, false));
		OCCTIO::OCCTTool::Write(MakeEdge(crCurve), outdir + "crCurve" + to_string(i) + ".brep");
		curve.push_back(crCurve);
	}
	bool isClosedLofting = true;
	NURBSLoftSurfaceStype stype = NURBSLoftSurfaceStype::Standard;
	ApproxParameterizationType ptype = ApproxParameterizationType::Centripetal;
	shared_ptr<Geom3BSplineSurface> surf = NURBSAPILoft::MakeLoft(sections, isClosedLofting, stype, ptype);
	Point3 p;
	surf->D0(surf->FirstUParameter(), surf->FirstVParameter(), p);
	OCCTIO::OCCTTool::Write(MakeFace(surf, 0.0), outdir + "surf.brep");
	int num = 1000;
	double tol = 0.1;
	double ratio = 0.1;
	double res1 = NurbsSampleCurveOnSurface1(num, tol, curve[0], surf);
	double res2 = NurbsSampleCurveOnSurface1(num, tol, curve[1], surf);
	double res3 = NurbsSampleCurveOnSurface1(num, tol, curve[2], surf);
	double res4 = NurbsSampleCurveOnSurface1(num, tol, curve[3], surf);
	double res5 = NurbsSampleCurveOnSurface1(num, tol, curve[4], surf);
	double res6 = NurbsSampleCurveOnSurface1(num, tol, curve[5], surf);
	double res7 = NurbsSampleCurveOnSurface1(num, tol, curve[6], surf);
	CHECK(res1 <= ratio);
	CHECK(res2 <= ratio);
	CHECK(res3 <= ratio);
	CHECK(res4 <= ratio);
	CHECK(res5 <= ratio);
	CHECK(res6 <= ratio);
	CHECK(res7 <= ratio);
	TopoEdge edge1 = MakeEdge(curve[0]);
	TopoEdge edge2 = MakeEdge(curve[1]);
	TopoEdge edge3 = MakeEdge(curve[2]);
	TopoEdge edge4 = MakeEdge(curve[3]);
	TopoEdge edge5 = MakeEdge(curve[4]);
	TopoEdge edge6 = MakeEdge(curve[5]);
	TopoEdge edge7 = MakeEdge(curve[6]);
	TopoShape surface = MakeFace(surf, 0.0);
	BRepExtremaDistShapeShape dist1(edge1, surface);
	BRepExtremaDistShapeShape dist2(edge2, surface);
	BRepExtremaDistShapeShape dist3(edge3, surface);
	BRepExtremaDistShapeShape dist4(edge4, surface);
	BRepExtremaDistShapeShape dist5(edge5, surface);
	BRepExtremaDistShapeShape dist6(edge6, surface);
	BRepExtremaDistShapeShape dist7(edge7, surface);
	double tolgen = 1e-4;
	CHECK(dist1.Value() < tolgen);
	CHECK(dist2.Value() < tolgen);
	CHECK(dist3.Value() < tolgen);
	CHECK(dist4.Value() < tolgen);
	CHECK(dist5.Value() < tolgen);
	CHECK(dist6.Value() < tolgen);
	CHECK(dist7.Value() < tolgen);
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static std::shared_ptr<Geom3BSplineSurface> MakeSurf(const std::vector<std::shared_ptr<Geom3BSplineCurve>>& boundCurves, bool isParallel)	 @return The surface
	 @param isParallel Are the result surface isocurves parallel to boundary curves
	 @param boundCurves The boundary curves
	 @brief Given 2 or 3 or 4 boundaries, make a surface
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <nurbs/NURBSAPIMakeNURBSFromBoundaries.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeFace.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
#include <modeling/MakeVertex.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <topology/TopoExplorerTool.hpp>
#include<catch.hpp>
#include<testHelper.h>
#include <nurbs/NURBSAPIMakeNURBSFromBoundaries.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeFace.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
#include <modeling/MakeVertex.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <topology/TopoExplorerTool.hpp>
;
	SECTION("TestMakeSurf")
	{
		OUTPUT_DIRECTORY(nurbs, MakeNURBSFromBoundaries);
		std::shared_ptr<Geom3BSplineCurve> vbsp1, vbsp2, hbsp1, hbsp2;
		{
			int deg = 3;
			std::vector<Point3> poles;
			poles.push_back(Point3(0.0, -1.0, 0.1));
			poles.push_back(Point3(0.07, -0.7, 0.2));
			poles.push_back(Point3(0.1, -0.3, 0.1));
			poles.push_back(Point3(0.12, 0.0, -0.1));
			poles.push_back(Point3(0.20, 0.3, -0.2));
			poles.push_back(Point3(0.07, 0.7, -0.3));
			poles.push_back(Point3(0.0, 1.0, 0.0));
			int nknots = static_cast<int>(poles.size()) - deg + 1;
			std::vector<double> knots(nknots);
			for (int i = 0; i < nknots; i++)
			{
				knots[i] = (double)i / (double)(nknots - 1.0);
			}
			std::vector<int> mults(nknots, 1);
			mults.front() = deg + 1;
			mults.back() = deg + 1;
			vbsp1 = std::make_shared<Geom3BSplineCurve>(poles, knots, mults, deg);
		}
		{
			int deg = 3;
			std::vector<Point3> poles;
			poles.push_back(Point3(4.0, -1.5, -0.1));
			poles.push_back(Point3(4.1, -1.3, -0.2));
			poles.push_back(Point3(4.15, -0.8, -0.1));
			poles.push_back(Point3(3.83, -0.2, 0.1));
			poles.push_back(Point3(3.48, 0.1, 0.2));
			poles.push_back(Point3(3.0, 1.0, 0.1));
			int nknots = static_cast<int>(poles.size()) - deg + 1;
			std::vector<double> knots(nknots);
			for (int i = 0; i < nknots; i++)
			{
				knots[i] = (double)i / (double)(nknots - 1.0);
			}
			std::vector<int> mults(nknots, 1);
			mults.front() = deg + 1;
			mults.back() = deg + 1;
			vbsp2 = std::make_shared<Geom3BSplineCurve>(poles, knots, mults, deg);
		}
		{
			int deg = 3;
			std::vector<Point3> poles;
			poles.push_back(Point3(0.0, -1.0, 0.1));
			poles.push_back(Point3(0.9, -1.5, -0.1));
			poles.push_back(Point3(3.0, -1.8, 0.1));
			poles.push_back(Point3(4.0, -1.5, -0.1));
			int nknots = static_cast<int>(poles.size()) - deg + 1;
			std::vector<double> knots(nknots);
			for (int i = 0; i < nknots; i++)
			{
				knots[i] = (double)i / (double)(nknots - 1.0);
			}
			std::vector<int> mults(nknots, 1);
			mults.front() = deg + 1;
			mults.back() = deg + 1;
			hbsp1 = std::make_shared<Geom3BSplineCurve>(poles, knots, mults, deg);
		}
		{
			int deg = 3;
			std::vector<Point3> poles;
			poles.push_back(Point3(0.0, 1.0, 0.0));
			poles.push_back(Point3(0.9, 0.15, -0.1));
			poles.push_back(Point3(1.7, 0.05, 0.1));
			poles.push_back(Point3(2.7, 0.3, -0.1));
			poles.push_back(Point3(3.0, 1.0, 0.1));
			int nknots = static_cast<int>(poles.size()) - deg + 1;
			std::vector<double> knots(nknots);
			for (int i = 0; i < nknots; i++)
			{
				knots[i] = (double)i / (double)(nknots - 1.0);
			}
			std::vector<int> mults(nknots, 1);
			mults.front() = deg + 1;
			mults.back() = deg + 1;
			hbsp2 = std::make_shared<Geom3BSplineCurve>(poles, knots, mults, deg);
		}
		std::vector<std::shared_ptr<Geom3BSplineCurve>> curves;
		curves.push_back(vbsp1);
		curves.push_back(vbsp2);
		curves.push_back(hbsp1);
		curves.push_back(hbsp2);
		auto surf = NURBSAPIMakeNURBSFromBoundaries::MakeSurf(curves, false);
		int nums = GetTopoCount(MakeFace(surf, 0.0), ShapeType::Face);
		CHECK(nums == 1);
		double fpu = surf->FirstUParameter();
		double fpv = surf->FirstVParameter();
		double lpu = surf->LastUParameter();
		double lpv = surf->LastVParameter();
		shared_ptr<Geom3Curve> fu = surf->UIso(fpu);
		shared_ptr<Geom3Curve> fv = surf->VIso(fpv);
		shared_ptr<Geom3Curve> lu = surf->UIso(lpu);
		shared_ptr<Geom3Curve> lv = surf->VIso(lpv);
		Point3 p1, p2, p3, p4, p5, p6, p7, p8;
		double fusp = fu->FirstParameter();
		double fuep = fu->LastParameter();
		double fvsp = fv->FirstParameter();
		double fvep = fv->LastParameter();
		double lusp = lu->FirstParameter();
		double luep = lu->LastParameter();
		double lvsp = lv->FirstParameter();
		double lvep = lv->LastParameter();
		Point3 p11, p22, p33, p44, p55, p66, p77, p88;
		double fusp2 = vbsp1->FirstParameter();
		double fuep2 = vbsp1->LastParameter();
		double fvsp2 = hbsp1->FirstParameter();
		double fvep2 = hbsp1->LastParameter();
		double lusp2 = vbsp2->FirstParameter();
		double luep2 = vbsp2->LastParameter();
		double lvsp2 = hbsp2->FirstParameter();
		double lvep2 = hbsp2->LastParameter();
		fu->D0(fusp, p1);
		fu->D0(fuep, p2);
		fv->D0(fvsp, p3);
		fv->D0(fvep, p4);
		lu->D0(lusp, p5);
		lu->D0(luep, p6);
		lv->D0(lvsp, p7);
		lv->D0(lvep, p8);
		vbsp1->D0(fusp2, p11);
		vbsp1->D0(fuep2, p22);
		hbsp1->D0(fvsp2, p33);
		hbsp1->D0(fvep2, p44);
		vbsp2->D0(lusp2, p55);
		vbsp2->D0(luep2, p66);
		hbsp2->D0(lvsp2, p77);
		hbsp2->D0(lvep2, p88);
		double refTol = 5e-3;
		CHECK(abs(p1.X() - p11.X()) <= refTol);
		CHECK(abs(p1.Y() - p11.Y()) <= refTol);
		CHECK(abs(p1.Z() - p11.Z()) <= refTol);
		CHECK(abs(p2.X() - p22.X()) <= refTol);
		CHECK(abs(p2.Y() - p22.Y()) <= refTol);
		CHECK(abs(p2.Z() - p22.Z()) <= refTol);
		CHECK(abs(p3.X() - p33.X()) <= refTol);
		CHECK(abs(p3.Y() - p33.Y()) <= refTol);
		CHECK(abs(p3.Z() - p33.Z()) <= refTol);
		CHECK(abs(p4.X() - p44.X()) <= refTol);
		CHECK(abs(p4.Y() - p44.Y()) <= refTol);
		CHECK(abs(p4.Z() - p44.Z()) <= refTol);
		CHECK(abs(p5.X() - p55.X()) <= refTol);
		CHECK(abs(p5.Y() - p55.Y()) <= refTol);
		CHECK(abs(p5.Z() - p55.Z()) <= refTol);
		CHECK(abs(p6.X() - p66.X()) <= refTol);
		CHECK(abs(p6.Y() - p66.Y()) <= refTol);
		CHECK(abs(p6.Z() - p66.Z()) <= refTol);
		CHECK(abs(p7.X() - p77.X()) <= refTol);
		CHECK(abs(p7.Y() - p77.Y()) <= refTol);
		CHECK(abs(p7.Z() - p77.Z()) <= refTol);
		CHECK(abs(p8.X() - p88.X()) <= refTol);
		CHECK(abs(p8.Y() - p88.Y()) <= refTol);
		CHECK(abs(p8.Z() - p88.Z()) <= refTol);
		int num = 1000;
		double tol = 5e-3;
		double ratio = 0.1;
		double res1 = NurbsSampleCurve(num, tol, vbsp1, fu);
		double res2 = NurbsSampleCurve(num, tol, vbsp2, lu);
		double res3 = NurbsSampleCurve(num, tol, hbsp1, fv);
		double res4 = NurbsSampleCurve(num, tol, hbsp2, lv);
		CHECK(res1 <= ratio);
		CHECK(res2 <= ratio); 
		CHECK(res3 <= ratio);
		CHECK(res4 <= ratio);
		OCCTIO::OCCTTool::Write(MakeEdge(vbsp1), outdir + "curve1.brep");
		OCCTIO::OCCTTool::Write(MakeEdge(vbsp2), outdir + "curve2.brep");
		OCCTIO::OCCTTool::Write(MakeEdge(hbsp1), outdir + "curve3.brep");
		OCCTIO::OCCTTool::Write(MakeEdge(hbsp2), outdir + "curve4.brep");
		OCCTIO::OCCTTool::Write(MakeEdge(fu), outdir + "fu.brep");
		OCCTIO::OCCTTool::Write(MakeEdge(lu), outdir + "lu.brep");
		OCCTIO::OCCTTool::Write(MakeEdge(fv), outdir + "fv.brep");
		OCCTIO::OCCTTool::Write(MakeEdge(lv), outdir + "lv.brep");
		OCCTIO::OCCTTool::Write(MakeFace(surf, 0.0), outdir + "result.brep");
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static std::shared_ptr<Geom3BSplineCurve> MatchCurve( ContinuityType cont, const std::shared_ptr<Geom3BSplineCurve>& curve, bool isFront, const std::shared_ptr<Geom3BSplineCurve>& targetCurve, bool isTargetFront, int otherEndCont),
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <nurbs/NURBSAPIMatch.hpp>
#include <topology/TopoEdge.hpp>
#include <topology/TopoTool.hpp>
#include <nurbs/NURBSAPISweep.hpp>
#include <nurbs/NURBSAPIRebuild.hpp>
#include <modeling/MakeWire.hpp>
#include <modeling/MakeEdge.hpp>
#include <offset/MakePipeShell.hpp>
#include <geometry/Geom3BSplineSurface.hpp>
#include <topology/TopoVertex.hpp>
#include <topomesh/BRepMeshIncrementalMesh.hpp>
#include <geometry/GeomAPIProjectPointOnCurve3.hpp>
#include <modeling/TransformShape.hpp>
#include <nurbs/NURBSAPIMatch.hpp>
#include <modeling/MakeFace.hpp>
#include <nurbs/NURBSAPIConvert.hpp>
#include <topology/TopoExplorerTool.hpp>
#include <modeling/MakeVertex.hpp>
using namespace AMCAX;
std::shared_ptr<Geom3BSplineSurface> GenerateTestSurface1(const int id)
{
	std::shared_ptr<Geom3BSplineSurface> bspSurf;
	switch (id)
	{
	case 0:
	{
		std::vector<Point3> profilePoles;
		std::vector<double> profileKnots(3);
		std::vector<int> profileMults(3, 1);
		profilePoles.push_back(Point3(0.0, 0.0, 0.0));
		profilePoles.push_back(Point3(1.0, -0.2, 0.1));
		profilePoles.push_back(Point3(2.0, 0.1, -0.1));
		profilePoles.push_back(Point3(3.0, -0.1, 0.0));
		profilePoles.push_back(Point3(4.0, 0.1, 0.2));
		profileKnots[0] = 0;
		profileKnots[1] = 0.5;
		profileKnots[2] = 1;
		profileMults.front() = 4;
		profileMults.back() = 4;
		std::shared_ptr<Geom3BSplineCurve> profileCurve = std::make_shared<Geom3BSplineCurve>(profilePoles, profileKnots, profileMults, 3);
		std::vector<Point3> spinePoles;
		std::vector<double> spineKnots(4);
		std::vector<int> spineMults(4, 1);
		spinePoles.push_back(Point3(0.0, 0.0, 0.0));
		spinePoles.push_back(Point3(-0.1, 1.0, -0.2));
		spinePoles.push_back(Point3(0.1, 2.0, -0.1));
		spinePoles.push_back(Point3(0.2, 3.0, 0.1));
		spinePoles.push_back(Point3(0.1, 4.0, 0.0));
		spinePoles.push_back(Point3(0.0, 5.0, -0.1));
		spineKnots[0] = 0;
		spineKnots[1] = 1.0 / 3.0;
		spineKnots[2] = 2.0 / 3.0;
		spineKnots[3] = 1;
		spineMults.front() = 4;
		spineMults.back() = 4;
		std::shared_ptr<Geom3BSplineCurve> spineCurve = std::make_shared<Geom3BSplineCurve>(spinePoles, spineKnots, spineMults, 3);
		TopoWire profile = MakeWire(MakeEdge(profileCurve)).Wire();
		TopoWire spine = MakeWire(MakeEdge(spineCurve)).Wire();
		MakePipeShell pipeShell(spine);
		pipeShell.Add(profile);
		pipeShell.SetMode(Frame3());
		TopoShape pipe = pipeShell.Shape();
		TopoExplorer ex(pipe, ShapeType::Face);
		TopoFace inputBasicFace = static_cast<const TopoFace&>(ex.Current());
		auto surf = TopoTool::Surface(inputBasicFace);
		bspSurf = NURBSAPIConvert::ToBSpline(surf);
		break;
	}
	case 1:
	{
		Array2<Point3> poles(2, 5);
		poles(0, 0) = Point3(0.0, 0.0, 0.0);
		poles(0, 1) = Point3(1.0, -0.2, 0.1);
		poles(0, 2) = Point3(2.0, 0.1, -0.1);
		poles(0, 3) = Point3(3.0, -0.1, 0.0);
		poles(0, 4) = Point3(4.0, 0.1, 0.2);
		poles(1, 0) = Point3(0.0, 1.0, -0.1);
		poles(1, 1) = Point3(1.0, 0.8, 0.0);
		poles(1, 2) = Point3(2.0, 1.1, -0.2);
		poles(1, 3) = Point3(3.0, 0.9, -0.1);
		poles(1, 4) = Point3(4.0, 1.1, 0.1);
		std::vector<double> vKnots(3);
		std::vector<int> vMults(3, 1);
		vKnots[0] = 0;
		vKnots[1] = 0.5;
		vKnots[2] = 1;
		vMults.front() = 4;
		vMults.back() = 4;
		std::vector<double> uKnots(2);
		std::vector<int> uMults(2, 1);
		uKnots[0] = 0;
		uKnots[1] = 1;
		uMults.front() = 2;
		uMults.back() = 2;
		bspSurf = std::make_shared<Geom3BSplineSurface>(poles, uKnots, vKnots, uMults, vMults, 1, 3);
		Transformation3 trsf;
		trsf.SetTranslationPart(Vector3(0.0, -6.0, 0.0));
		bspSurf->Transform(trsf);
		break;
	}
	case 2:
	{
		std::vector<Point3> profilePoles;
		std::vector<double> profileKnots(4);
		std::vector<int> profileMults(4, 1);
		profilePoles.push_back(Point3(0.0, 0.0, 0.0));
		profilePoles.push_back(Point3(1.0, -2.0, -3.0));
		profilePoles.push_back(Point3(2.0, 1.0, 2.0));
		profilePoles.push_back(Point3(3.0, -1.0, -1.0));
		profilePoles.push_back(Point3(4.0, -3.0, 3.0));
		profilePoles.push_back(Point3(5.0, 0.0, 1.0));
		profileKnots[0] = 0;
		profileKnots[1] = 1.0 / 3.0;
		profileKnots[2] = 2.0 / 3.0;
		profileKnots[3] = 1;
		profileMults.front() = 4;
		profileMults.back() = 4;
		std::shared_ptr<Geom3BSplineCurve> profileCurve = std::make_shared<Geom3BSplineCurve>(profilePoles, profileKnots, profileMults, 3);
		std::vector<Point3> spinePoles;
		std::vector<double> spineKnots(4);
		std::vector<int> spineMults(4, 1);
		spinePoles.push_back(Point3(0.0, 0.0, 0.0));
		spinePoles.push_back(Point3(-0.1, 1.0, -1.0));
		spinePoles.push_back(Point3(0.1, -2.0, -2.0));
		spinePoles.push_back(Point3(0.2, -3.0, -3.0));
		spinePoles.push_back(Point3(0.1, -4.0, -4.0));
		spinePoles.push_back(Point3(0.0, -2.5, -5.0));
		spinePoles.push_back(Point3(0.1, -1.0, -6.0));
		spinePoles.push_back(Point3(0.0, 0.0, -7.0));
		spineKnots[0] = 0;
		spineKnots[1] = 1.0 / 3.0;
		spineKnots[2] = 2.0 / 3.0;
		spineKnots[3] = 1;
		spineMults.front() = 6;
		spineMults.back() = 6;
		shared_ptr<Geom3BSplineCurve> spineCurve = std::make_shared<Geom3BSplineCurve>(spinePoles, spineKnots, spineMults, 5);
		TopoWire profile = MakeWire(MakeEdge(profileCurve)).Wire();
		TopoWire spine = MakeWire(MakeEdge(spineCurve)).Wire();
		MakePipeShell pipeShell(spine);
		pipeShell.Add(profile);
		pipeShell.SetMode(Frame3());
		TopoShape pipe = pipeShell.Shape();
		TopoExplorer ex(pipe, ShapeType::Face);
		TopoFace inputBasicFace = static_cast<const TopoFace&>(ex.Current());
		shared_ptr<Geom3Surface> surf = TopoTool::Surface(inputBasicFace);
		shared_ptr<Geom3BSplineSurface>  bspSurf = NURBSAPIConvert::ToBSpline(surf);
		Transformation3 trsf;
		trsf.SetTranslationPart(Vector3(-6.0, 0.0, 0.0));
		bspSurf->Transform(trsf);
		break;
	}
	}
	return bspSurf;
}
TEST_CASE("bug2: TestMatchTrimmedSurface ", "[nurbs][Match][fixbug]")
{
	OUTPUT_DIRECTORY(nurbs, Match/bug590);
	string filedir = INPUT_PATH_PREFIX"./TestNURBS/TestMatchTrimmedSurface/";
	TopoFace f1 = ReadBRepFace(filedir + "surf1.brep");
	TopoFace f2 = ReadBRepFace(filedir + "surf2.brep");
	Point3 p1, p2;
	bool isSurf1TrimmedEdge = true;
	bool isSurf2TrimmedEdge = true;
	if (isSurf1TrimmedEdge)
	{
		p1 = ReadBRepPoint(filedir + "tptS1.brep");
	}
	else
	{
		p1 = ReadBRepPoint(filedir + "nptS1.brep");
	}
	if (isSurf2TrimmedEdge)
	{
		p2 = ReadBRepPoint(filedir + "tptS2.brep");
	}
	else
	{
		p2 = ReadBRepPoint(filedir + "nptS2.brep");
	}
	auto [d1, e1] = NearestEdge(p1, f1);
	auto [d2, e2] = NearestEdge(p2, f2);
	ContinuityType cont = ContinuityType::G2;
	int otherEndCont = 0;
	NURBSMatchSurfConfig config;
	bool isPrecise = true;
	std::vector<double> tol;
	tol.push_back(0.001);
	tol.push_back(0.1);
	tol.push_back(0.05);
	std::vector<double> params(2, 1.0);
	auto result = NURBSAPIMatch::MatchFace(f1, e1, f2, e2, cont, otherEndCont, isPrecise, tol, params, false, config, config);
	double f = 0.0;
	double l = 0.0;
	shared_ptr< Geom3Curve > curve2 = TopoTool::Curve(e2, f, l);
	shared_ptr< Geom3Surface > src = TopoTool::Surface(f1);
	shared_ptr< Geom3Surface > surface = TopoTool::Surface(result[0]);
	double srcfpv = src->FirstVParameter();
	double fpv = surface->FirstVParameter();
	double lpv = surface->LastVParameter();
	shared_ptr<Geom3Curve> srcfv = src->VIso(srcfpv);
	shared_ptr<Geom3Curve> fv = surface->VIso(fpv);
	shared_ptr<Geom3Curve> lv = surface->VIso(lpv);
	int num = 1000;
	double resTol = 1e-3;
	double ratio = 0.1;
	double res1 = NurbsSampleCurve(num, resTol, srcfv, fv);
	double res2 = NurbsSampleCurve(num, resTol, curve2, lv);
	CHECK(res1 <= ratio);
	CHECK(res2 <= ratio);
	OCCTIO::OCCTTool::Write(MakeEdge(srcfv), outdir + "srcfv.brep");
	OCCTIO::OCCTTool::Write(MakeEdge(fv), outdir + "fv.brep");
	OCCTIO::OCCTTool::Write(MakeEdge(lv), outdir + "lv.brep");
	OCCTIO::OCCTTool::Write(f1, outdir + "f1.brep");
	OCCTIO::OCCTTool::Write(f2, outdir + "f2.brep");
	OCCTIO::OCCTTool::Write(MakeVertex(p1), outdir + "p1.brep");
	OCCTIO::OCCTTool::Write(MakeVertex(p2), outdir + "p2.brep");
	OCCTIO::OCCTTool::Write(e1, outdir + "e1.brep");
	OCCTIO::OCCTTool::Write(e2, outdir + "e2.brep");
	OCCTIO::OCCTTool::Write(result.front(), outdir + "result.brep");
;
	SECTION("MatchCurve1")
	{
		OUTPUT_DIRECTORY(nurbs, Match/bug725/MatchCurve/MatchCurve1);
		string filedir = INPUT_PATH_PREFIX"./TestNURBS/TestMatchCurve/";
		shared_ptr<Geom3BSplineCurve> bsp1 = ReadBRepCurve(filedir + "curve1.brep");
		shared_ptr<Geom3BSplineCurve> bsp2 = ReadBRepCurve(filedir + "curve2.brep");
		shared_ptr<Geom3BSplineCurve> oldnbsp1 = NURBSAPIMatch::MatchCurve(ContinuityType::C0, bsp1, true, bsp2, true, 0); 
		shared_ptr<Geom3BSplineCurve> oldnbsp2 = NURBSAPIMatch::MatchCurve(ContinuityType::C0, bsp1, false, bsp2, true, 0);
		shared_ptr<Geom3BSplineCurve> oldnbsp3 = NURBSAPIMatch::MatchCurve(ContinuityType::C0, bsp1, true, bsp2, false, 0);
		shared_ptr<Geom3BSplineCurve> oldnbsp4 = NURBSAPIMatch::MatchCurve(ContinuityType::C0, bsp1, false, bsp2, false, 0);
		shared_ptr<Geom3BSplineCurve> oldnbsp5 = NURBSAPIMatch::MatchCurve(ContinuityType::G1, bsp1, true, bsp2, true, 0);
		shared_ptr<Geom3BSplineCurve> oldnbsp6 = NURBSAPIMatch::MatchCurve(ContinuityType::G1, bsp1, false, bsp2, true, 0);
		shared_ptr<Geom3BSplineCurve> oldnbsp7 = NURBSAPIMatch::MatchCurve(ContinuityType::G1, bsp1, true, bsp2, false, 0);
		shared_ptr<Geom3BSplineCurve> oldnbsp8 = NURBSAPIMatch::MatchCurve(ContinuityType::G1, bsp1, false, bsp2, false, 0);
		shared_ptr<Geom3BSplineCurve> oldnbsp9 = NURBSAPIMatch::MatchCurve(ContinuityType::G2, bsp1, true, bsp2, true, 0);
		shared_ptr<Geom3BSplineCurve> oldnbsp10 = NURBSAPIMatch::MatchCurve(ContinuityType::G2, bsp1, false, bsp2, true, 0);
		shared_ptr<Geom3BSplineCurve> oldnbsp11 = NURBSAPIMatch::MatchCurve(ContinuityType::G2, bsp1, true, bsp2, false, 0);
		shared_ptr<Geom3BSplineCurve> oldnbsp12 = NURBSAPIMatch::MatchCurve(ContinuityType::G2, bsp1, false, bsp2, false, 0);
		shared_ptr<Geom3BSplineCurve> bsp1Inc = std::dynamic_pointer_cast<Geom3BSplineCurve>(bsp1->Copy());
		shared_ptr<Geom3BSplineCurve> bsp2Inc = std::dynamic_pointer_cast<Geom3BSplineCurve>(bsp2->Copy());
		bsp1Inc->IncreaseDegree(refDeg);
		bsp2Inc->IncreaseDegree(refDeg);
		shared_ptr<Geom3BSplineCurve> nbsp1 = NURBSAPIMatch::MatchCurve(ContinuityType::C0, bsp1Inc, true, bsp2Inc, true, 0); 
		shared_ptr<Geom3BSplineCurve> nbsp2 = NURBSAPIMatch::MatchCurve(ContinuityType::C0, bsp1Inc, false, bsp2Inc, true, 0);
		shared_ptr<Geom3BSplineCurve> nbsp3 = NURBSAPIMatch::MatchCurve(ContinuityType::C0, bsp1Inc, true, bsp2Inc, false, 0);
		shared_ptr<Geom3BSplineCurve> nbsp4 = NURBSAPIMatch::MatchCurve(ContinuityType::C0, bsp1Inc, false, bsp2Inc, false, 0);
		shared_ptr<Geom3BSplineCurve> nbsp5 = NURBSAPIMatch::MatchCurve(ContinuityType::G1, bsp1Inc, true, bsp2Inc, true, 0);
		shared_ptr<Geom3BSplineCurve> nbsp6 = NURBSAPIMatch::MatchCurve(ContinuityType::G1, bsp1Inc, false, bsp2Inc, true, 0);
		shared_ptr<Geom3BSplineCurve> nbsp7 = NURBSAPIMatch::MatchCurve(ContinuityType::G1, bsp1Inc, true, bsp2Inc, false, 0);
		shared_ptr<Geom3BSplineCurve> nbsp8 = NURBSAPIMatch::MatchCurve(ContinuityType::G1, bsp1Inc, false, bsp2Inc, false, 0);
		shared_ptr<Geom3BSplineCurve> nbsp9 = NURBSAPIMatch::MatchCurve(ContinuityType::G2, bsp1Inc, true, bsp2Inc, true, 0);
		shared_ptr<Geom3BSplineCurve> nbsp10 = NURBSAPIMatch::MatchCurve(ContinuityType::G2, bsp1Inc, false, bsp2Inc, true, 0);
		shared_ptr<Geom3BSplineCurve> nbsp11 = NURBSAPIMatch::MatchCurve(ContinuityType::G2, bsp1Inc, true, bsp2Inc, false, 0);
		shared_ptr<Geom3BSplineCurve> nbsp12 = NURBSAPIMatch::MatchCurve(ContinuityType::G2, bsp1Inc, false, bsp2Inc, false, 0);
		double res1 = NurbsSampleCurve(num, refTol, oldnbsp1, nbsp1);
		double res2 = NurbsSampleCurve(num, refTol, oldnbsp2, nbsp2);
		double res3 = NurbsSampleCurve(num, refTol, oldnbsp3, nbsp3);
		double res4 = NurbsSampleCurve(num, refTol, oldnbsp4, nbsp4);
		double res5 = NurbsSampleCurve(num, refTol, oldnbsp5, nbsp5);
		double res6 = NurbsSampleCurve(num, refTol, oldnbsp6, nbsp6);
		double res7 = NurbsSampleCurve(num, refTol, oldnbsp7, nbsp7);
		double res8 = NurbsSampleCurve(num, refTol, oldnbsp8, nbsp8);
		double res9 = NurbsSampleCurve(num, refTol, oldnbsp9, nbsp9);
		double res10 = NurbsSampleCurve(num, refTol, oldnbsp10, nbsp10);
		double res11 = NurbsSampleCurve(num, refTol, oldnbsp11, nbsp11);
		double res12 = NurbsSampleCurve(num, refTol, oldnbsp12, nbsp12);
		OCCTIO::OCCTTool::Write(MakeEdge(bsp1), outdir + "bsp1.brep");
		OCCTIO::OCCTTool::Write(MakeEdge(bsp2), outdir + "bsp2.brep");
		OCCTIO::OCCTTool::Write(MakeEdge(bsp1Inc), outdir + "bsp1Inc.brep");
		OCCTIO::OCCTTool::Write(MakeEdge(bsp2Inc), outdir + "bsp2Inc.brep");
		OCCTIO::OCCTTool::Write(MakeEdge(oldnbsp1), outdir + "oldresult.brep");
		OCCTIO::OCCTTool::Write(MakeEdge(nbsp1), outdir + "result.brep");
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static std::shared_ptr<Geom3BSplineCurve> MatchCurve( ContinuityType cont, const std::shared_ptr<Geom3BSplineCurve>& curve, bool isFront, const std::shared_ptr<Geom3BSplineCurve>& targetCurve, bool isTargetFront, int otherEndCont, std::vector<double>& params),
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <nurbs/NURBSAPIMatch.hpp>
#include <topology/TopoEdge.hpp>
#include <topology/TopoTool.hpp>
#include <nurbs/NURBSAPISweep.hpp>
#include <nurbs/NURBSAPIRebuild.hpp>
#include <modeling/MakeWire.hpp>
#include <modeling/MakeEdge.hpp>
#include <offset/MakePipeShell.hpp>
#include <geometry/Geom3BSplineSurface.hpp>
#include <topology/TopoVertex.hpp>
#include <topomesh/BRepMeshIncrementalMesh.hpp>
#include <geometry/GeomAPIProjectPointOnCurve3.hpp>
#include <modeling/TransformShape.hpp>
#include <nurbs/NURBSAPIMatch.hpp>
#include <modeling/MakeFace.hpp>
#include <nurbs/NURBSAPIConvert.hpp>
#include <topology/TopoExplorerTool.hpp>
#include <modeling/MakeVertex.hpp>
using namespace AMCAX;
std::shared_ptr<Geom3BSplineSurface> GenerateTestSurface1(const int id)
{
	std::shared_ptr<Geom3BSplineSurface> bspSurf;
	switch (id)
	{
	case 0:
	{
		std::vector<Point3> profilePoles;
		std::vector<double> profileKnots(3);
		std::vector<int> profileMults(3, 1);
		profilePoles.push_back(Point3(0.0, 0.0, 0.0));
		profilePoles.push_back(Point3(1.0, -0.2, 0.1));
		profilePoles.push_back(Point3(2.0, 0.1, -0.1));
		profilePoles.push_back(Point3(3.0, -0.1, 0.0));
		profilePoles.push_back(Point3(4.0, 0.1, 0.2));
		profileKnots[0] = 0;
		profileKnots[1] = 0.5;
		profileKnots[2] = 1;
		profileMults.front() = 4;
		profileMults.back() = 4;
		std::shared_ptr<Geom3BSplineCurve> profileCurve = std::make_shared<Geom3BSplineCurve>(profilePoles, profileKnots, profileMults, 3);
		std::vector<Point3> spinePoles;
		std::vector<double> spineKnots(4);
		std::vector<int> spineMults(4, 1);
		spinePoles.push_back(Point3(0.0, 0.0, 0.0));
		spinePoles.push_back(Point3(-0.1, 1.0, -0.2));
		spinePoles.push_back(Point3(0.1, 2.0, -0.1));
		spinePoles.push_back(Point3(0.2, 3.0, 0.1));
		spinePoles.push_back(Point3(0.1, 4.0, 0.0));
		spinePoles.push_back(Point3(0.0, 5.0, -0.1));
		spineKnots[0] = 0;
		spineKnots[1] = 1.0 / 3.0;
		spineKnots[2] = 2.0 / 3.0;
		spineKnots[3] = 1;
		spineMults.front() = 4;
		spineMults.back() = 4;
		std::shared_ptr<Geom3BSplineCurve> spineCurve = std::make_shared<Geom3BSplineCurve>(spinePoles, spineKnots, spineMults, 3);
		TopoWire profile = MakeWire(MakeEdge(profileCurve)).Wire();
		TopoWire spine = MakeWire(MakeEdge(spineCurve)).Wire();
		MakePipeShell pipeShell(spine);
		pipeShell.Add(profile);
		pipeShell.SetMode(Frame3());
		TopoShape pipe = pipeShell.Shape();
		TopoExplorer ex(pipe, ShapeType::Face);
		TopoFace inputBasicFace = static_cast<const TopoFace&>(ex.Current());
		auto surf = TopoTool::Surface(inputBasicFace);
		bspSurf = NURBSAPIConvert::ToBSpline(surf);
		break;
	}
	case 1:
	{
		Array2<Point3> poles(2, 5);
		poles(0, 0) = Point3(0.0, 0.0, 0.0);
		poles(0, 1) = Point3(1.0, -0.2, 0.1);
		poles(0, 2) = Point3(2.0, 0.1, -0.1);
		poles(0, 3) = Point3(3.0, -0.1, 0.0);
		poles(0, 4) = Point3(4.0, 0.1, 0.2);
		poles(1, 0) = Point3(0.0, 1.0, -0.1);
		poles(1, 1) = Point3(1.0, 0.8, 0.0);
		poles(1, 2) = Point3(2.0, 1.1, -0.2);
		poles(1, 3) = Point3(3.0, 0.9, -0.1);
		poles(1, 4) = Point3(4.0, 1.1, 0.1);
		std::vector<double> vKnots(3);
		std::vector<int> vMults(3, 1);
		vKnots[0] = 0;
		vKnots[1] = 0.5;
		vKnots[2] = 1;
		vMults.front() = 4;
		vMults.back() = 4;
		std::vector<double> uKnots(2);
		std::vector<int> uMults(2, 1);
		uKnots[0] = 0;
		uKnots[1] = 1;
		uMults.front() = 2;
		uMults.back() = 2;
		bspSurf = std::make_shared<Geom3BSplineSurface>(poles, uKnots, vKnots, uMults, vMults, 1, 3);
		Transformation3 trsf;
		trsf.SetTranslationPart(Vector3(0.0, -6.0, 0.0));
		bspSurf->Transform(trsf);
		break;
	}
	case 2:
	{
		std::vector<Point3> profilePoles;
		std::vector<double> profileKnots(4);
		std::vector<int> profileMults(4, 1);
		profilePoles.push_back(Point3(0.0, 0.0, 0.0));
		profilePoles.push_back(Point3(1.0, -2.0, -3.0));
		profilePoles.push_back(Point3(2.0, 1.0, 2.0));
		profilePoles.push_back(Point3(3.0, -1.0, -1.0));
		profilePoles.push_back(Point3(4.0, -3.0, 3.0));
		profilePoles.push_back(Point3(5.0, 0.0, 1.0));
		profileKnots[0] = 0;
		profileKnots[1] = 1.0 / 3.0;
		profileKnots[2] = 2.0 / 3.0;
		profileKnots[3] = 1;
		profileMults.front() = 4;
		profileMults.back() = 4;
		std::shared_ptr<Geom3BSplineCurve> profileCurve = std::make_shared<Geom3BSplineCurve>(profilePoles, profileKnots, profileMults, 3);
		std::vector<Point3> spinePoles;
		std::vector<double> spineKnots(4);
		std::vector<int> spineMults(4, 1);
		spinePoles.push_back(Point3(0.0, 0.0, 0.0));
		spinePoles.push_back(Point3(-0.1, 1.0, -1.0));
		spinePoles.push_back(Point3(0.1, -2.0, -2.0));
		spinePoles.push_back(Point3(0.2, -3.0, -3.0));
		spinePoles.push_back(Point3(0.1, -4.0, -4.0));
		spinePoles.push_back(Point3(0.0, -2.5, -5.0));
		spinePoles.push_back(Point3(0.1, -1.0, -6.0));
		spinePoles.push_back(Point3(0.0, 0.0, -7.0));
		spineKnots[0] = 0;
		spineKnots[1] = 1.0 / 3.0;
		spineKnots[2] = 2.0 / 3.0;
		spineKnots[3] = 1;
		spineMults.front() = 6;
		spineMults.back() = 6;
		shared_ptr<Geom3BSplineCurve> spineCurve = std::make_shared<Geom3BSplineCurve>(spinePoles, spineKnots, spineMults, 5);
		TopoWire profile = MakeWire(MakeEdge(profileCurve)).Wire();
		TopoWire spine = MakeWire(MakeEdge(spineCurve)).Wire();
		MakePipeShell pipeShell(spine);
		pipeShell.Add(profile);
		pipeShell.SetMode(Frame3());
		TopoShape pipe = pipeShell.Shape();
		TopoExplorer ex(pipe, ShapeType::Face);
		TopoFace inputBasicFace = static_cast<const TopoFace&>(ex.Current());
		shared_ptr<Geom3Surface> surf = TopoTool::Surface(inputBasicFace);
		shared_ptr<Geom3BSplineSurface>  bspSurf = NURBSAPIConvert::ToBSpline(surf);
		Transformation3 trsf;
		trsf.SetTranslationPart(Vector3(-6.0, 0.0, 0.0));
		bspSurf->Transform(trsf);
		break;
	}
	}
	return bspSurf;
}
TEST_CASE("bug2: TestMatchTrimmedSurface ", "[nurbs][Match][fixbug]")
{
	OUTPUT_DIRECTORY(nurbs, Match/bug590);
	string filedir = INPUT_PATH_PREFIX"./TestNURBS/TestMatchTrimmedSurface/";
	TopoFace f1 = ReadBRepFace(filedir + "surf1.brep");
	TopoFace f2 = ReadBRepFace(filedir + "surf2.brep");
	Point3 p1, p2;
	bool isSurf1TrimmedEdge = true;
	bool isSurf2TrimmedEdge = true;
	if (isSurf1TrimmedEdge)
	{
		p1 = ReadBRepPoint(filedir + "tptS1.brep");
	}
	else
	{
		p1 = ReadBRepPoint(filedir + "nptS1.brep");
	}
	if (isSurf2TrimmedEdge)
	{
		p2 = ReadBRepPoint(filedir + "tptS2.brep");
	}
	else
	{
		p2 = ReadBRepPoint(filedir + "nptS2.brep");
	}
	auto [d1, e1] = NearestEdge(p1, f1);
	auto [d2, e2] = NearestEdge(p2, f2);
	ContinuityType cont = ContinuityType::G2;
	int otherEndCont = 0;
	NURBSMatchSurfConfig config;
	bool isPrecise = true;
	std::vector<double> tol;
	tol.push_back(0.001);
	tol.push_back(0.1);
	tol.push_back(0.05);
	std::vector<double> params(2, 1.0);
	auto result = NURBSAPIMatch::MatchFace(f1, e1, f2, e2, cont, otherEndCont, isPrecise, tol, params, false, config, config);
	double f = 0.0;
	double l = 0.0;
	shared_ptr< Geom3Curve > curve2 = TopoTool::Curve(e2, f, l);
	shared_ptr< Geom3Surface > src = TopoTool::Surface(f1);
	shared_ptr< Geom3Surface > surface = TopoTool::Surface(result[0]);
	double srcfpv = src->FirstVParameter();
	double fpv = surface->FirstVParameter();
	double lpv = surface->LastVParameter();
	shared_ptr<Geom3Curve> srcfv = src->VIso(srcfpv);
	shared_ptr<Geom3Curve> fv = surface->VIso(fpv);
	shared_ptr<Geom3Curve> lv = surface->VIso(lpv);
	int num = 1000;
	double resTol = 1e-3;
	double ratio = 0.1;
	double res1 = NurbsSampleCurve(num, resTol, srcfv, fv);
	double res2 = NurbsSampleCurve(num, resTol, curve2, lv);
	CHECK(res1 <= ratio);
	CHECK(res2 <= ratio);
	OCCTIO::OCCTTool::Write(MakeEdge(srcfv), outdir + "srcfv.brep");
	OCCTIO::OCCTTool::Write(MakeEdge(fv), outdir + "fv.brep");
	OCCTIO::OCCTTool::Write(MakeEdge(lv), outdir + "lv.brep");
	OCCTIO::OCCTTool::Write(f1, outdir + "f1.brep");
	OCCTIO::OCCTTool::Write(f2, outdir + "f2.brep");
	OCCTIO::OCCTTool::Write(MakeVertex(p1), outdir + "p1.brep");
	OCCTIO::OCCTTool::Write(MakeVertex(p2), outdir + "p2.brep");
	OCCTIO::OCCTTool::Write(e1, outdir + "e1.brep");
	OCCTIO::OCCTTool::Write(e2, outdir + "e2.brep");
	OCCTIO::OCCTTool::Write(result.front(), outdir + "result.brep");
;
	SECTION("MatchCurve1")
	{
		OUTPUT_DIRECTORY(nurbs, Match/bug725/MatchCurve/MatchCurve1);
		string filedir = INPUT_PATH_PREFIX"./TestNURBS/TestMatchCurve/";
		shared_ptr<Geom3BSplineCurve> bsp1 = ReadBRepCurve(filedir + "curve1.brep");
		shared_ptr<Geom3BSplineCurve> bsp2 = ReadBRepCurve(filedir + "curve2.brep");
		shared_ptr<Geom3BSplineCurve> oldnbsp1 = NURBSAPIMatch::MatchCurve(ContinuityType::C0, bsp1, true, bsp2, true, 0); 
		shared_ptr<Geom3BSplineCurve> oldnbsp2 = NURBSAPIMatch::MatchCurve(ContinuityType::C0, bsp1, false, bsp2, true, 0);
		shared_ptr<Geom3BSplineCurve> oldnbsp3 = NURBSAPIMatch::MatchCurve(ContinuityType::C0, bsp1, true, bsp2, false, 0);
		shared_ptr<Geom3BSplineCurve> oldnbsp4 = NURBSAPIMatch::MatchCurve(ContinuityType::C0, bsp1, false, bsp2, false, 0);
		shared_ptr<Geom3BSplineCurve> oldnbsp5 = NURBSAPIMatch::MatchCurve(ContinuityType::G1, bsp1, true, bsp2, true, 0);
		shared_ptr<Geom3BSplineCurve> oldnbsp6 = NURBSAPIMatch::MatchCurve(ContinuityType::G1, bsp1, false, bsp2, true, 0);
		shared_ptr<Geom3BSplineCurve> oldnbsp7 = NURBSAPIMatch::MatchCurve(ContinuityType::G1, bsp1, true, bsp2, false, 0);
		shared_ptr<Geom3BSplineCurve> oldnbsp8 = NURBSAPIMatch::MatchCurve(ContinuityType::G1, bsp1, false, bsp2, false, 0);
		shared_ptr<Geom3BSplineCurve> oldnbsp9 = NURBSAPIMatch::MatchCurve(ContinuityType::G2, bsp1, true, bsp2, true, 0);
		shared_ptr<Geom3BSplineCurve> oldnbsp10 = NURBSAPIMatch::MatchCurve(ContinuityType::G2, bsp1, false, bsp2, true, 0);
		shared_ptr<Geom3BSplineCurve> oldnbsp11 = NURBSAPIMatch::MatchCurve(ContinuityType::G2, bsp1, true, bsp2, false, 0);
		shared_ptr<Geom3BSplineCurve> oldnbsp12 = NURBSAPIMatch::MatchCurve(ContinuityType::G2, bsp1, false, bsp2, false, 0);
		shared_ptr<Geom3BSplineCurve> bsp1Inc = std::dynamic_pointer_cast<Geom3BSplineCurve>(bsp1->Copy());
		shared_ptr<Geom3BSplineCurve> bsp2Inc = std::dynamic_pointer_cast<Geom3BSplineCurve>(bsp2->Copy());
		bsp1Inc->IncreaseDegree(refDeg);
		bsp2Inc->IncreaseDegree(refDeg);
		shared_ptr<Geom3BSplineCurve> nbsp1 = NURBSAPIMatch::MatchCurve(ContinuityType::C0, bsp1Inc, true, bsp2Inc, true, 0); 
		shared_ptr<Geom3BSplineCurve> nbsp2 = NURBSAPIMatch::MatchCurve(ContinuityType::C0, bsp1Inc, false, bsp2Inc, true, 0);
		shared_ptr<Geom3BSplineCurve> nbsp3 = NURBSAPIMatch::MatchCurve(ContinuityType::C0, bsp1Inc, true, bsp2Inc, false, 0);
		shared_ptr<Geom3BSplineCurve> nbsp4 = NURBSAPIMatch::MatchCurve(ContinuityType::C0, bsp1Inc, false, bsp2Inc, false, 0);
		shared_ptr<Geom3BSplineCurve> nbsp5 = NURBSAPIMatch::MatchCurve(ContinuityType::G1, bsp1Inc, true, bsp2Inc, true, 0);
		shared_ptr<Geom3BSplineCurve> nbsp6 = NURBSAPIMatch::MatchCurve(ContinuityType::G1, bsp1Inc, false, bsp2Inc, true, 0);
		shared_ptr<Geom3BSplineCurve> nbsp7 = NURBSAPIMatch::MatchCurve(ContinuityType::G1, bsp1Inc, true, bsp2Inc, false, 0);
		shared_ptr<Geom3BSplineCurve> nbsp8 = NURBSAPIMatch::MatchCurve(ContinuityType::G1, bsp1Inc, false, bsp2Inc, false, 0);
		shared_ptr<Geom3BSplineCurve> nbsp9 = NURBSAPIMatch::MatchCurve(ContinuityType::G2, bsp1Inc, true, bsp2Inc, true, 0);
		shared_ptr<Geom3BSplineCurve> nbsp10 = NURBSAPIMatch::MatchCurve(ContinuityType::G2, bsp1Inc, false, bsp2Inc, true, 0);
		shared_ptr<Geom3BSplineCurve> nbsp11 = NURBSAPIMatch::MatchCurve(ContinuityType::G2, bsp1Inc, true, bsp2Inc, false, 0);
		shared_ptr<Geom3BSplineCurve> nbsp12 = NURBSAPIMatch::MatchCurve(ContinuityType::G2, bsp1Inc, false, bsp2Inc, false, 0);
		double res1 = NurbsSampleCurve(num, refTol, oldnbsp1, nbsp1);
		double res2 = NurbsSampleCurve(num, refTol, oldnbsp2, nbsp2);
		double res3 = NurbsSampleCurve(num, refTol, oldnbsp3, nbsp3);
		double res4 = NurbsSampleCurve(num, refTol, oldnbsp4, nbsp4);
		double res5 = NurbsSampleCurve(num, refTol, oldnbsp5, nbsp5);
		double res6 = NurbsSampleCurve(num, refTol, oldnbsp6, nbsp6);
		double res7 = NurbsSampleCurve(num, refTol, oldnbsp7, nbsp7);
		double res8 = NurbsSampleCurve(num, refTol, oldnbsp8, nbsp8);
		double res9 = NurbsSampleCurve(num, refTol, oldnbsp9, nbsp9);
		double res10 = NurbsSampleCurve(num, refTol, oldnbsp10, nbsp10);
		double res11 = NurbsSampleCurve(num, refTol, oldnbsp11, nbsp11);
		double res12 = NurbsSampleCurve(num, refTol, oldnbsp12, nbsp12);
		OCCTIO::OCCTTool::Write(MakeEdge(bsp1), outdir + "bsp1.brep");
		OCCTIO::OCCTTool::Write(MakeEdge(bsp2), outdir + "bsp2.brep");
		OCCTIO::OCCTTool::Write(MakeEdge(bsp1Inc), outdir + "bsp1Inc.brep");
		OCCTIO::OCCTTool::Write(MakeEdge(bsp2Inc), outdir + "bsp2Inc.brep");
		OCCTIO::OCCTTool::Write(MakeEdge(oldnbsp1), outdir + "oldresult.brep");
		OCCTIO::OCCTTool::Write(MakeEdge(nbsp1), outdir + "result.brep");
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static std::pair<std::shared_ptr<Geom3BSplineCurve>, std::shared_ptr<Geom3BSplineCurve>> MatchCurveWithEachOther( ContinuityType cont, const std::shared_ptr<Geom3BSplineCurve>& curve, bool isFront, const std::shared_ptr<Geom3BSplineCurve>& targetCurve, bool isTargetFront, int otherEndCont),
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <nurbs/NURBSAPIMatch.hpp>
#include <topology/TopoEdge.hpp>
#include <topology/TopoTool.hpp>
#include <nurbs/NURBSAPISweep.hpp>
#include <nurbs/NURBSAPIRebuild.hpp>
#include <modeling/MakeWire.hpp>
#include <modeling/MakeEdge.hpp>
#include <offset/MakePipeShell.hpp>
#include <geometry/Geom3BSplineSurface.hpp>
#include <topology/TopoVertex.hpp>
#include <topomesh/BRepMeshIncrementalMesh.hpp>
#include <geometry/GeomAPIProjectPointOnCurve3.hpp>
#include <modeling/TransformShape.hpp>
#include <nurbs/NURBSAPIMatch.hpp>
#include <modeling/MakeFace.hpp>
#include <nurbs/NURBSAPIConvert.hpp>
#include <topology/TopoExplorerTool.hpp>
#include <modeling/MakeVertex.hpp>
using namespace AMCAX;
std::shared_ptr<Geom3BSplineSurface> GenerateTestSurface1(const int id)
{
	std::shared_ptr<Geom3BSplineSurface> bspSurf;
	switch (id)
	{
	case 0:
	{
		std::vector<Point3> profilePoles;
		std::vector<double> profileKnots(3);
		std::vector<int> profileMults(3, 1);
		profilePoles.push_back(Point3(0.0, 0.0, 0.0));
		profilePoles.push_back(Point3(1.0, -0.2, 0.1));
		profilePoles.push_back(Point3(2.0, 0.1, -0.1));
		profilePoles.push_back(Point3(3.0, -0.1, 0.0));
		profilePoles.push_back(Point3(4.0, 0.1, 0.2));
		profileKnots[0] = 0;
		profileKnots[1] = 0.5;
		profileKnots[2] = 1;
		profileMults.front() = 4;
		profileMults.back() = 4;
		std::shared_ptr<Geom3BSplineCurve> profileCurve = std::make_shared<Geom3BSplineCurve>(profilePoles, profileKnots, profileMults, 3);
		std::vector<Point3> spinePoles;
		std::vector<double> spineKnots(4);
		std::vector<int> spineMults(4, 1);
		spinePoles.push_back(Point3(0.0, 0.0, 0.0));
		spinePoles.push_back(Point3(-0.1, 1.0, -0.2));
		spinePoles.push_back(Point3(0.1, 2.0, -0.1));
		spinePoles.push_back(Point3(0.2, 3.0, 0.1));
		spinePoles.push_back(Point3(0.1, 4.0, 0.0));
		spinePoles.push_back(Point3(0.0, 5.0, -0.1));
		spineKnots[0] = 0;
		spineKnots[1] = 1.0 / 3.0;
		spineKnots[2] = 2.0 / 3.0;
		spineKnots[3] = 1;
		spineMults.front() = 4;
		spineMults.back() = 4;
		std::shared_ptr<Geom3BSplineCurve> spineCurve = std::make_shared<Geom3BSplineCurve>(spinePoles, spineKnots, spineMults, 3);
		TopoWire profile = MakeWire(MakeEdge(profileCurve)).Wire();
		TopoWire spine = MakeWire(MakeEdge(spineCurve)).Wire();
		MakePipeShell pipeShell(spine);
		pipeShell.Add(profile);
		pipeShell.SetMode(Frame3());
		TopoShape pipe = pipeShell.Shape();
		TopoExplorer ex(pipe, ShapeType::Face);
		TopoFace inputBasicFace = static_cast<const TopoFace&>(ex.Current());
		auto surf = TopoTool::Surface(inputBasicFace);
		bspSurf = NURBSAPIConvert::ToBSpline(surf);
		break;
	}
	case 1:
	{
		Array2<Point3> poles(2, 5);
		poles(0, 0) = Point3(0.0, 0.0, 0.0);
		poles(0, 1) = Point3(1.0, -0.2, 0.1);
		poles(0, 2) = Point3(2.0, 0.1, -0.1);
		poles(0, 3) = Point3(3.0, -0.1, 0.0);
		poles(0, 4) = Point3(4.0, 0.1, 0.2);
		poles(1, 0) = Point3(0.0, 1.0, -0.1);
		poles(1, 1) = Point3(1.0, 0.8, 0.0);
		poles(1, 2) = Point3(2.0, 1.1, -0.2);
		poles(1, 3) = Point3(3.0, 0.9, -0.1);
		poles(1, 4) = Point3(4.0, 1.1, 0.1);
		std::vector<double> vKnots(3);
		std::vector<int> vMults(3, 1);
		vKnots[0] = 0;
		vKnots[1] = 0.5;
		vKnots[2] = 1;
		vMults.front() = 4;
		vMults.back() = 4;
		std::vector<double> uKnots(2);
		std::vector<int> uMults(2, 1);
		uKnots[0] = 0;
		uKnots[1] = 1;
		uMults.front() = 2;
		uMults.back() = 2;
		bspSurf = std::make_shared<Geom3BSplineSurface>(poles, uKnots, vKnots, uMults, vMults, 1, 3);
		Transformation3 trsf;
		trsf.SetTranslationPart(Vector3(0.0, -6.0, 0.0));
		bspSurf->Transform(trsf);
		break;
	}
	case 2:
	{
		std::vector<Point3> profilePoles;
		std::vector<double> profileKnots(4);
		std::vector<int> profileMults(4, 1);
		profilePoles.push_back(Point3(0.0, 0.0, 0.0));
		profilePoles.push_back(Point3(1.0, -2.0, -3.0));
		profilePoles.push_back(Point3(2.0, 1.0, 2.0));
		profilePoles.push_back(Point3(3.0, -1.0, -1.0));
		profilePoles.push_back(Point3(4.0, -3.0, 3.0));
		profilePoles.push_back(Point3(5.0, 0.0, 1.0));
		profileKnots[0] = 0;
		profileKnots[1] = 1.0 / 3.0;
		profileKnots[2] = 2.0 / 3.0;
		profileKnots[3] = 1;
		profileMults.front() = 4;
		profileMults.back() = 4;
		std::shared_ptr<Geom3BSplineCurve> profileCurve = std::make_shared<Geom3BSplineCurve>(profilePoles, profileKnots, profileMults, 3);
		std::vector<Point3> spinePoles;
		std::vector<double> spineKnots(4);
		std::vector<int> spineMults(4, 1);
		spinePoles.push_back(Point3(0.0, 0.0, 0.0));
		spinePoles.push_back(Point3(-0.1, 1.0, -1.0));
		spinePoles.push_back(Point3(0.1, -2.0, -2.0));
		spinePoles.push_back(Point3(0.2, -3.0, -3.0));
		spinePoles.push_back(Point3(0.1, -4.0, -4.0));
		spinePoles.push_back(Point3(0.0, -2.5, -5.0));
		spinePoles.push_back(Point3(0.1, -1.0, -6.0));
		spinePoles.push_back(Point3(0.0, 0.0, -7.0));
		spineKnots[0] = 0;
		spineKnots[1] = 1.0 / 3.0;
		spineKnots[2] = 2.0 / 3.0;
		spineKnots[3] = 1;
		spineMults.front() = 6;
		spineMults.back() = 6;
		shared_ptr<Geom3BSplineCurve> spineCurve = std::make_shared<Geom3BSplineCurve>(spinePoles, spineKnots, spineMults, 5);
		TopoWire profile = MakeWire(MakeEdge(profileCurve)).Wire();
		TopoWire spine = MakeWire(MakeEdge(spineCurve)).Wire();
		MakePipeShell pipeShell(spine);
		pipeShell.Add(profile);
		pipeShell.SetMode(Frame3());
		TopoShape pipe = pipeShell.Shape();
		TopoExplorer ex(pipe, ShapeType::Face);
		TopoFace inputBasicFace = static_cast<const TopoFace&>(ex.Current());
		shared_ptr<Geom3Surface> surf = TopoTool::Surface(inputBasicFace);
		shared_ptr<Geom3BSplineSurface>  bspSurf = NURBSAPIConvert::ToBSpline(surf);
		Transformation3 trsf;
		trsf.SetTranslationPart(Vector3(-6.0, 0.0, 0.0));
		bspSurf->Transform(trsf);
		break;
	}
	}
	return bspSurf;
}
TEST_CASE("bug2: TestMatchTrimmedSurface ", "[nurbs][Match][fixbug]")
{
	OUTPUT_DIRECTORY(nurbs, Match/bug590);
	string filedir = INPUT_PATH_PREFIX"./TestNURBS/TestMatchTrimmedSurface/";
	TopoFace f1 = ReadBRepFace(filedir + "surf1.brep");
	TopoFace f2 = ReadBRepFace(filedir + "surf2.brep");
	Point3 p1, p2;
	bool isSurf1TrimmedEdge = true;
	bool isSurf2TrimmedEdge = true;
	if (isSurf1TrimmedEdge)
	{
		p1 = ReadBRepPoint(filedir + "tptS1.brep");
	}
	else
	{
		p1 = ReadBRepPoint(filedir + "nptS1.brep");
	}
	if (isSurf2TrimmedEdge)
	{
		p2 = ReadBRepPoint(filedir + "tptS2.brep");
	}
	else
	{
		p2 = ReadBRepPoint(filedir + "nptS2.brep");
	}
	auto [d1, e1] = NearestEdge(p1, f1);
	auto [d2, e2] = NearestEdge(p2, f2);
	ContinuityType cont = ContinuityType::G2;
	int otherEndCont = 0;
	NURBSMatchSurfConfig config;
	bool isPrecise = true;
	std::vector<double> tol;
	tol.push_back(0.001);
	tol.push_back(0.1);
	tol.push_back(0.05);
	std::vector<double> params(2, 1.0);
	auto result = NURBSAPIMatch::MatchFace(f1, e1, f2, e2, cont, otherEndCont, isPrecise, tol, params, false, config, config);
	double f = 0.0;
	double l = 0.0;
	shared_ptr< Geom3Curve > curve2 = TopoTool::Curve(e2, f, l);
	shared_ptr< Geom3Surface > src = TopoTool::Surface(f1);
	shared_ptr< Geom3Surface > surface = TopoTool::Surface(result[0]);
	double srcfpv = src->FirstVParameter();
	double fpv = surface->FirstVParameter();
	double lpv = surface->LastVParameter();
	shared_ptr<Geom3Curve> srcfv = src->VIso(srcfpv);
	shared_ptr<Geom3Curve> fv = surface->VIso(fpv);
	shared_ptr<Geom3Curve> lv = surface->VIso(lpv);
	int num = 1000;
	double resTol = 1e-3;
	double ratio = 0.1;
	double res1 = NurbsSampleCurve(num, resTol, srcfv, fv);
	double res2 = NurbsSampleCurve(num, resTol, curve2, lv);
	CHECK(res1 <= ratio);
	CHECK(res2 <= ratio);
	OCCTIO::OCCTTool::Write(MakeEdge(srcfv), outdir + "srcfv.brep");
	OCCTIO::OCCTTool::Write(MakeEdge(fv), outdir + "fv.brep");
	OCCTIO::OCCTTool::Write(MakeEdge(lv), outdir + "lv.brep");
	OCCTIO::OCCTTool::Write(f1, outdir + "f1.brep");
	OCCTIO::OCCTTool::Write(f2, outdir + "f2.brep");
	OCCTIO::OCCTTool::Write(MakeVertex(p1), outdir + "p1.brep");
	OCCTIO::OCCTTool::Write(MakeVertex(p2), outdir + "p2.brep");
	OCCTIO::OCCTTool::Write(e1, outdir + "e1.brep");
	OCCTIO::OCCTTool::Write(e2, outdir + "e2.brep");
	OCCTIO::OCCTTool::Write(result.front(), outdir + "result.brep");
;
	SECTION("MatchCurveWithEachOther")
	{
		string filedir = INPUT_PATH_PREFIX"./TestNURBS/TestMatchCurve/";
		string filedir1 = INPUT_PATH_PREFIX"./TestNURBS/TestMatchCurve/Rhino/";
		string filedir2 = INPUT_PATH_PREFIX"./TestNURBS/TestMatchCurve/Rhino/stepEachOther/";
		shared_ptr<Geom3BSplineCurve> bsp1 = ReadBRepCurve(filedir + "curve1.brep");
		shared_ptr<Geom3BSplineCurve> bsp2 = ReadBRepCurve(filedir + "curve2.brep");
		 OUTPUT_DIRECTORY(nurbs, Match/MatchCurve/MatchCurveWithEachOther);
		 auto nbsp1 = NURBSAPIMatch::MatchCurveWithEachOther(ContinuityType::C0, bsp1, true, bsp2, true, 0);
		 auto nbsp2 = NURBSAPIMatch::MatchCurveWithEachOther(ContinuityType::C0, bsp1, false, bsp2, true, 0);
		 auto nbsp3 = NURBSAPIMatch::MatchCurveWithEachOther(ContinuityType::C0, bsp1, true, bsp2, false, 0);
		 auto nbsp4 = NURBSAPIMatch::MatchCurveWithEachOther(ContinuityType::C0, bsp1, false, bsp2, false, 0);
		 auto nbsp5 = NURBSAPIMatch::MatchCurveWithEachOther(ContinuityType::G1, bsp1, true, bsp2, true, 0);
		 auto nbsp6 = NURBSAPIMatch::MatchCurveWithEachOther(ContinuityType::G1, bsp1, false, bsp2, true, 0);
		 auto nbsp7 = NURBSAPIMatch::MatchCurveWithEachOther(ContinuityType::G1, bsp1, true, bsp2, false, 0);
		 auto nbsp8 = NURBSAPIMatch::MatchCurveWithEachOther(ContinuityType::G1, bsp1, false, bsp2, false, 0);
		 auto nbsp9 = NURBSAPIMatch::MatchCurveWithEachOther(ContinuityType::G2, bsp1, true, bsp2, true, 0);
		 auto nbsp10 = NURBSAPIMatch::MatchCurveWithEachOther(ContinuityType::G2, bsp1, false, bsp2, true, 0);
		 auto nbsp11 = NURBSAPIMatch::MatchCurveWithEachOther(ContinuityType::G2, bsp1, true, bsp2, false, 0);
		 auto nbsp12 = NURBSAPIMatch::MatchCurveWithEachOther(ContinuityType::G2, bsp1, false, bsp2, false, 0);
		 shared_ptr<Geom3BSplineCurve> bsp1C0res1 = ReadBRepCurve(filedir2 + "bsp1C0truetrue.brep");
		 shared_ptr<Geom3BSplineCurve> bsp1C0res2 = ReadBRepCurve(filedir2 + "bsp1C0falsetrue.brep");
		 shared_ptr<Geom3BSplineCurve> bsp1C0res3 = ReadBRepCurve(filedir2 + "bsp1C0truefalse.brep");
		 shared_ptr<Geom3BSplineCurve> bsp1C0res4 = ReadBRepCurve(filedir2 + "bsp1C0falsefalse.brep");
		 shared_ptr<Geom3BSplineCurve> bsp1G1res1 = ReadBRepCurve(filedir2 + "bsp1G1truetrue.brep");
		 shared_ptr<Geom3BSplineCurve> bsp1G1res2 = ReadBRepCurve(filedir2 + "bsp1G1falsetrue.brep");
		 shared_ptr<Geom3BSplineCurve> bsp1G1res3 = ReadBRepCurve(filedir2 + "bsp1G1truefalse.brep");
		 shared_ptr<Geom3BSplineCurve> bsp1G1res4 = ReadBRepCurve(filedir2 + "bsp1G1falsefalse.brep");
		 shared_ptr<Geom3BSplineCurve> bsp1G2res1 = ReadBRepCurve(filedir2 + "bsp1G2truetrue.brep");
		 shared_ptr<Geom3BSplineCurve> bsp1G2res2 = ReadBRepCurve(filedir2 + "bsp1G2falsetrue.brep");
		 shared_ptr<Geom3BSplineCurve> bsp1G2res3 = ReadBRepCurve(filedir2 + "bsp1G2truefalse.brep");
		 shared_ptr<Geom3BSplineCurve> bsp1G2res4 = ReadBRepCurve(filedir2 + "bsp1G2falsefalse.brep");
		 shared_ptr<Geom3BSplineCurve> bsp2C0res1 = ReadBRepCurve(filedir2 + "bsp2C0truetrue.brep");
		 shared_ptr<Geom3BSplineCurve> bsp2C0res2 = ReadBRepCurve(filedir2 + "bsp2C0falsetrue.brep");
		 shared_ptr<Geom3BSplineCurve> bsp2C0res3 = ReadBRepCurve(filedir2 + "bsp2C0truefalse.brep");
		 shared_ptr<Geom3BSplineCurve> bsp2C0res4 = ReadBRepCurve(filedir2 + "bsp2C0falsefalse.brep");
		 shared_ptr<Geom3BSplineCurve> bsp2G1res1 = ReadBRepCurve(filedir2 + "bsp2G1truetrue.brep");
		 shared_ptr<Geom3BSplineCurve> bsp2G1res2 = ReadBRepCurve(filedir2 + "bsp2G1falsetrue.brep");
		 shared_ptr<Geom3BSplineCurve> bsp2G1res3 = ReadBRepCurve(filedir2 + "bsp2G1truefalse.brep");
		 shared_ptr<Geom3BSplineCurve> bsp2G1res4 = ReadBRepCurve(filedir2 + "bsp2G1falsefalse.brep");
		 shared_ptr<Geom3BSplineCurve> bsp2G2res1 = ReadBRepCurve(filedir2 + "bsp2G2truetrue.brep");
		 shared_ptr<Geom3BSplineCurve> bsp2G2res2 = ReadBRepCurve(filedir2 + "bsp2G2falsetrue.brep");
		 shared_ptr<Geom3BSplineCurve> bsp2G2res3 = ReadBRepCurve(filedir2 + "bsp2G2truefalse.brep");
		 shared_ptr<Geom3BSplineCurve> bsp2G2res4 = ReadBRepCurve(filedir2 + "bsp2G2falsefalse.brep");
		 CHECK(nbsp1.first->NKnots() == bsp1C0res1->NKnots());
		 CHECK(nbsp1.second->NKnots() == bsp2C0res1->NKnots());
		 CHECK((nbsp1.first->StartPoint()).X() == Approx((nbsp1.second->StartPoint()).X()));
		 CHECK((nbsp1.first->StartPoint()).Y() == Approx((nbsp1.second->StartPoint()).Y()));
		 CHECK((nbsp1.first->StartPoint()).Z() == Approx((nbsp1.second->StartPoint()).Z()));
		 CHECK((nbsp1.first->EndPoint()).X() == Approx((bsp1->EndPoint()).X()));
		 CHECK((nbsp1.first->EndPoint()).Y() == Approx((bsp1->EndPoint()).Y()));
		 CHECK((nbsp1.first->EndPoint()).Z() == Approx((bsp1->EndPoint()).Z()));
		 CHECK((nbsp1.second->EndPoint()).X() == Approx((bsp2->EndPoint()).X()));
		 CHECK((nbsp1.second->EndPoint()).Y() == Approx((bsp2->EndPoint()).Y()));
		 CHECK((nbsp1.second->EndPoint()).Z() == Approx((bsp2->EndPoint()).Z()));
		 CHECK(nbsp2.first->NKnots() == bsp1C0res2->NKnots());
		 CHECK(nbsp2.second->NKnots() == bsp2C0res2->NKnots());
		 CHECK((nbsp2.first->EndPoint()).X() == Approx((nbsp2.second->StartPoint()).X()));
		 CHECK((nbsp2.first->EndPoint()).Y() == Approx((nbsp2.second->StartPoint()).Y()));
		 CHECK((nbsp2.first->EndPoint()).Z() == Approx((nbsp2.second->StartPoint()).Z()));
		 CHECK((nbsp2.first->StartPoint()).X() == Approx((bsp1->StartPoint()).X()));
		 CHECK((nbsp2.first->StartPoint()).Y() == Approx((bsp1->StartPoint()).Y()));
		 CHECK((nbsp2.first->StartPoint()).Z() == Approx((bsp1->StartPoint()).Z()));
		 CHECK((nbsp2.second->EndPoint()).X() == Approx((bsp2->EndPoint()).X()));
		 CHECK((nbsp2.second->EndPoint()).Y() == Approx((bsp2->EndPoint()).Y()));
		 CHECK((nbsp2.second->EndPoint()).Z() == Approx((bsp2->EndPoint()).Z()));
		 CHECK(nbsp3.first->NKnots() == bsp1C0res3->NKnots());
		 CHECK(nbsp3.second->NKnots() == bsp2C0res3->NKnots());
		 CHECK((nbsp3.first->StartPoint()).X() == Approx((nbsp3.second->EndPoint()).X()));
		 CHECK((nbsp3.first->StartPoint()).Y() == Approx((nbsp3.second->EndPoint()).Y()));
		 CHECK((nbsp3.first->StartPoint()).Z() == Approx((nbsp3.second->EndPoint()).Z()));
		 CHECK((nbsp3.first->EndPoint()).X() == Approx((bsp1->EndPoint()).X()));
		 CHECK((nbsp3.first->EndPoint()).Y() == Approx((bsp1->EndPoint()).Y()));
		 CHECK((nbsp3.first->EndPoint()).Z() == Approx((bsp1->EndPoint()).Z()));
		 CHECK((nbsp3.second->StartPoint()).X() == Approx((bsp2->StartPoint()).X()));
		 CHECK((nbsp3.second->StartPoint()).Y() == Approx((bsp2->StartPoint()).Y()));
		 CHECK((nbsp3.second->StartPoint()).Z() == Approx((bsp2->StartPoint()).Z()));
		 CHECK(nbsp4.first->NKnots() == bsp1C0res4->NKnots());
		 CHECK(nbsp4.second->NKnots() == bsp2C0res4->NKnots());
		 CHECK((nbsp4.first->EndPoint()).X() == Approx((nbsp4.second->EndPoint()).X()));
		 CHECK((nbsp4.first->EndPoint()).Y() == Approx((nbsp4.second->EndPoint()).Y()));
		 CHECK((nbsp4.first->EndPoint()).Z() == Approx((nbsp4.second->EndPoint()).Z()));
		 CHECK((nbsp4.first->StartPoint()).X() == Approx((bsp1->StartPoint()).X()));
		 CHECK((nbsp4.first->StartPoint()).Y() == Approx((bsp1->StartPoint()).Y()));
		 CHECK((nbsp4.first->StartPoint()).Z() == Approx((bsp1->StartPoint()).Z()));
		 CHECK((nbsp4.second->StartPoint()).X() == Approx((bsp2->StartPoint()).X()));
		 CHECK((nbsp4.second->StartPoint()).Y() == Approx((bsp2->StartPoint()).Y()));
		 CHECK((nbsp4.second->StartPoint()).Z() == Approx((bsp2->StartPoint()).Z()));
		 CHECK(nbsp5.first->NKnots() == bsp1G1res1->NKnots());
		 CHECK(nbsp5.second->NKnots() == bsp2G1res1->NKnots());
		 CHECK((nbsp5.first->StartPoint()).X() == Approx((nbsp5.second->StartPoint()).X()));
		 CHECK((nbsp5.first->StartPoint()).Y() == Approx((nbsp5.second->StartPoint()).Y()));
		 CHECK((nbsp5.first->StartPoint()).Z() == Approx((nbsp5.second->StartPoint()).Z()));
		 CHECK((nbsp5.first->EndPoint()).X() == Approx((bsp1->EndPoint()).X()));
		 CHECK((nbsp5.first->EndPoint()).Y() == Approx((bsp1->EndPoint()).Y()));
		 CHECK((nbsp5.first->EndPoint()).Z() == Approx((bsp1->EndPoint()).Z()));
		 CHECK((nbsp5.second->EndPoint()).X() == Approx((bsp2->EndPoint()).X()));
		 CHECK((nbsp5.second->EndPoint()).Y() == Approx((bsp2->EndPoint()).Y()));
		 CHECK((nbsp5.second->EndPoint()).Z() == Approx((bsp2->EndPoint()).Z()));
		 CHECK(nbsp6.first->NKnots() == bsp1G1res2->NKnots());
		 CHECK(nbsp6.second->NKnots() == bsp2G1res2->NKnots());
		 CHECK((nbsp6.first->EndPoint()).X() == Approx((nbsp6.second->StartPoint()).X()));
		 CHECK((nbsp6.first->EndPoint()).Y() == Approx((nbsp6.second->StartPoint()).Y()));
		 CHECK((nbsp6.first->EndPoint()).Z() == Approx((nbsp6.second->StartPoint()).Z()));
		 CHECK((nbsp6.first->StartPoint()).X() == Approx((bsp1->StartPoint()).X()));
		 CHECK((nbsp6.first->StartPoint()).Y() == Approx((bsp1->StartPoint()).Y()));
		 CHECK((nbsp6.first->StartPoint()).Z() == Approx((bsp1->StartPoint()).Z()));
		 CHECK((nbsp6.second->EndPoint()).X() == Approx((bsp2->EndPoint()).X()));
		 CHECK((nbsp6.second->EndPoint()).Y() == Approx((bsp2->EndPoint()).Y()));
		 CHECK((nbsp6.second->EndPoint()).Z() == Approx((bsp2->EndPoint()).Z()));
		 CHECK(nbsp7.first->NKnots() == bsp1G1res3->NKnots());
		 CHECK(nbsp7.second->NKnots() == bsp2G1res3->NKnots());
		 CHECK((nbsp7.first->StartPoint()).X() == Approx((nbsp7.second->EndPoint()).X()));
		 CHECK((nbsp7.first->StartPoint()).Y() == Approx((nbsp7.second->EndPoint()).Y()));
		 CHECK((nbsp7.first->StartPoint()).Z() == Approx((nbsp7.second->EndPoint()).Z()));
		 CHECK((nbsp7.first->EndPoint()).X() == Approx((bsp1->EndPoint()).X()));
		 CHECK((nbsp7.first->EndPoint()).Y() == Approx((bsp1->EndPoint()).Y()));
		 CHECK((nbsp7.first->EndPoint()).Z() == Approx((bsp1->EndPoint()).Z()));
		 CHECK((nbsp7.second->StartPoint()).X() == Approx((bsp2->StartPoint()).X()));
		 CHECK((nbsp7.second->StartPoint()).Y() == Approx((bsp2->StartPoint()).Y()));
		 CHECK((nbsp7.second->StartPoint()).Z() == Approx((bsp2->StartPoint()).Z()));
		 CHECK(nbsp8.first->NKnots() == bsp1G1res4->NKnots());
		 CHECK(nbsp8.second->NKnots() == bsp2G1res4->NKnots());
		 CHECK((nbsp8.first->EndPoint()).X() == Approx((nbsp8.second->EndPoint()).X()));
		 CHECK((nbsp8.first->EndPoint()).Y() == Approx((nbsp8.second->EndPoint()).Y()));
		 CHECK((nbsp8.first->EndPoint()).Z() == Approx((nbsp8.second->EndPoint()).Z()));
		 CHECK((nbsp8.first->StartPoint()).X() == Approx((bsp1->StartPoint()).X()));
		 CHECK((nbsp8.first->StartPoint()).Y() == Approx((bsp1->StartPoint()).Y()));
		 CHECK((nbsp8.first->StartPoint()).Z() == Approx((bsp1->StartPoint()).Z()));
		 CHECK((nbsp8.second->StartPoint()).X() == Approx((bsp2->StartPoint()).X()));
		 CHECK((nbsp8.second->StartPoint()).Y() == Approx((bsp2->StartPoint()).Y()));
		 CHECK((nbsp8.second->StartPoint()).Z() == Approx((bsp2->StartPoint()).Z()));
		 CHECK(nbsp9.first->NKnots() == bsp1G2res1->NKnots());
		 CHECK(nbsp9.second->NKnots() == bsp2G2res1->NKnots());
		 CHECK((nbsp9.first->StartPoint()).X() == Approx((nbsp9.second->StartPoint()).X()));
		 CHECK((nbsp9.first->StartPoint()).Y() == Approx((nbsp9.second->StartPoint()).Y()));
		 CHECK((nbsp9.first->StartPoint()).Z() == Approx((nbsp9.second->StartPoint()).Z()));
		 CHECK((nbsp9.first->EndPoint()).X() == Approx((bsp1->EndPoint()).X()));
		 CHECK((nbsp9.first->EndPoint()).Y() == Approx((bsp1->EndPoint()).Y()));
		 CHECK((nbsp9.first->EndPoint()).Z() == Approx((bsp1->EndPoint()).Z()));
		 CHECK((nbsp9.second->EndPoint()).X() == Approx((bsp2->EndPoint()).X()));
		 CHECK((nbsp9.second->EndPoint()).Y() == Approx((bsp2->EndPoint()).Y()));
		 CHECK((nbsp9.second->EndPoint()).Z() == Approx((bsp2->EndPoint()).Z()));
		 CHECK(nbsp10.first->NKnots() == bsp1G2res2->NKnots());
		 CHECK(nbsp10.second->NKnots() == bsp2G2res2->NKnots());
		 CHECK((nbsp10.first->EndPoint()).X() == Approx((nbsp10.second->StartPoint()).X()));
		 CHECK((nbsp10.first->EndPoint()).Y() == Approx((nbsp10.second->StartPoint()).Y()));
		 CHECK((nbsp10.first->EndPoint()).Z() == Approx((nbsp10.second->StartPoint()).Z()));
		 CHECK((nbsp10.first->StartPoint()).X() == Approx((bsp1->StartPoint()).X()));
		 CHECK((nbsp10.first->StartPoint()).Y() == Approx((bsp1->StartPoint()).Y()));
		 CHECK((nbsp10.first->StartPoint()).Z() == Approx((bsp1->StartPoint()).Z()));
		 CHECK((nbsp10.second->EndPoint()).X() == Approx((bsp2->EndPoint()).X()));
		 CHECK((nbsp10.second->EndPoint()).Y() == Approx((bsp2->EndPoint()).Y()));
		 CHECK((nbsp10.second->EndPoint()).Z() == Approx((bsp2->EndPoint()).Z()));
		 CHECK(nbsp11.first->NKnots() == bsp1G2res3->NKnots());
		 CHECK(nbsp11.second->NKnots() == bsp2G2res3->NKnots());
		 CHECK((nbsp11.first->StartPoint()).X() == Approx((nbsp11.second->EndPoint()).X()));
		 CHECK((nbsp11.first->StartPoint()).Y() == Approx((nbsp11.second->EndPoint()).Y()));
		 CHECK((nbsp11.first->StartPoint()).Z() == Approx((nbsp11.second->EndPoint()).Z()));
		 CHECK((nbsp11.first->EndPoint()).X() == Approx((bsp1->EndPoint()).X()));
		 CHECK((nbsp11.first->EndPoint()).Y() == Approx((bsp1->EndPoint()).Y()));
		 CHECK((nbsp11.first->EndPoint()).Z() == Approx((bsp1->EndPoint()).Z()));
		 CHECK((nbsp11.second->StartPoint()).X() == Approx((bsp2->StartPoint()).X()));
		 CHECK((nbsp11.second->StartPoint()).Y() == Approx((bsp2->StartPoint()).Y()));
		 CHECK((nbsp11.second->StartPoint()).Z() == Approx((bsp2->StartPoint()).Z()));
		 CHECK(nbsp12.first->NKnots() == bsp1G2res4->NKnots());
		 CHECK(nbsp12.second->NKnots() == bsp2G2res4->NKnots());
		 CHECK((nbsp12.first->EndPoint()).X() == Approx((nbsp12.second->EndPoint()).X()));
		 CHECK((nbsp12.first->EndPoint()).Y() == Approx((nbsp12.second->EndPoint()).Y()));
		 CHECK((nbsp12.first->EndPoint()).Z() == Approx((nbsp12.second->EndPoint()).Z()));
		 CHECK((nbsp12.first->StartPoint()).X() == Approx((bsp1->StartPoint()).X()));
		 CHECK((nbsp12.first->StartPoint()).Y() == Approx((bsp1->StartPoint()).Y()));
		 CHECK((nbsp12.first->StartPoint()).Z() == Approx((bsp1->StartPoint()).Z()));
		 CHECK((nbsp12.second->StartPoint()).X() == Approx((bsp2->StartPoint()).X()));
		 CHECK((nbsp12.second->StartPoint()).Y() == Approx((bsp2->StartPoint()).Y()));
		 CHECK((nbsp12.second->StartPoint()).Z() == Approx((bsp2->StartPoint()).Z()));
		 OCCTIO::OCCTTool::Write(MakeEdge(bsp1), outdir + "bsp1.brep");
		 OCCTIO::OCCTTool::Write(MakeEdge(bsp2), outdir + "bsp2.brep");
		 OCCTIO::OCCTTool::Write(MakeEdge(nbsp1.first), outdir + "f1.brep");
		 OCCTIO::OCCTTool::Write(MakeEdge(nbsp1.second), outdir + "s1.brep");
		 OCCTIO::OCCTTool::Write(MakeEdge(nbsp2.first), outdir + "f2.brep");
		 OCCTIO::OCCTTool::Write(MakeEdge(nbsp2.second), outdir + "s2.brep");
		 OCCTIO::OCCTTool::Write(MakeEdge(nbsp3.first), outdir + "f3.brep");
		 OCCTIO::OCCTTool::Write(MakeEdge(nbsp3.second), outdir + "s3.brep");
		 OCCTIO::OCCTTool::Write(MakeEdge(nbsp4.first), outdir + "f4.brep");
		 OCCTIO::OCCTTool::Write(MakeEdge(nbsp4.second), outdir + "s4.brep");
		 OCCTIO::OCCTTool::Write(MakeEdge(nbsp5.first), outdir + "f5.brep");
		 OCCTIO::OCCTTool::Write(MakeEdge(nbsp5.second), outdir + "s5.brep");
		 OCCTIO::OCCTTool::Write(MakeEdge(nbsp6.first), outdir + "f6.brep");
		 OCCTIO::OCCTTool::Write(MakeEdge(nbsp6.second), outdir + "s6.brep");
		 OCCTIO::OCCTTool::Write(MakeEdge(nbsp7.first), outdir + "f7.brep");
		 OCCTIO::OCCTTool::Write(MakeEdge(nbsp7.second), outdir + "s7.brep");
		 OCCTIO::OCCTTool::Write(MakeEdge(nbsp8.first), outdir + "f8.brep");
		 OCCTIO::OCCTTool::Write(MakeEdge(nbsp8.second), outdir + "s8.brep");
		 OCCTIO::OCCTTool::Write(MakeEdge(nbsp9.first), outdir + "f9.brep");
		 OCCTIO::OCCTTool::Write(MakeEdge(nbsp9.second), outdir + "s9.brep");
		 OCCTIO::OCCTTool::Write(MakeEdge(nbsp10.first), outdir + "f10.brep");
		 OCCTIO::OCCTTool::Write(MakeEdge(nbsp10.second), outdir + "s10.brep");
		 OCCTIO::OCCTTool::Write(MakeEdge(nbsp11.first), outdir + "f11.brep");
		 OCCTIO::OCCTTool::Write(MakeEdge(nbsp11.second), outdir + "s11.brep");
		 OCCTIO::OCCTTool::Write(MakeEdge(nbsp12.first), outdir + "f12.brep");
		 OCCTIO::OCCTTool::Write(MakeEdge(nbsp12.second), outdir + "s12.brep");
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static std::pair<std::shared_ptr<Geom3BSplineCurve>, std::shared_ptr<Geom3BSplineCurve>> MatchCurveWithEachOther( ContinuityType cont, const std::shared_ptr<Geom3BSplineCurve>& curve, bool isFront, const std::shared_ptr<Geom3BSplineCurve>& targetCurve, bool isTargetFront, int otherEndCont, std::vector<double>& params),
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <nurbs/NURBSAPIMatch.hpp>
#include <topology/TopoEdge.hpp>
#include <topology/TopoTool.hpp>
#include <nurbs/NURBSAPISweep.hpp>
#include <nurbs/NURBSAPIRebuild.hpp>
#include <modeling/MakeWire.hpp>
#include <modeling/MakeEdge.hpp>
#include <offset/MakePipeShell.hpp>
#include <geometry/Geom3BSplineSurface.hpp>
#include <topology/TopoVertex.hpp>
#include <topomesh/BRepMeshIncrementalMesh.hpp>
#include <geometry/GeomAPIProjectPointOnCurve3.hpp>
#include <modeling/TransformShape.hpp>
#include <nurbs/NURBSAPIMatch.hpp>
#include <modeling/MakeFace.hpp>
#include <nurbs/NURBSAPIConvert.hpp>
#include <topology/TopoExplorerTool.hpp>
#include <modeling/MakeVertex.hpp>
using namespace AMCAX;
std::shared_ptr<Geom3BSplineSurface> GenerateTestSurface1(const int id)
{
	std::shared_ptr<Geom3BSplineSurface> bspSurf;
	switch (id)
	{
	case 0:
	{
		std::vector<Point3> profilePoles;
		std::vector<double> profileKnots(3);
		std::vector<int> profileMults(3, 1);
		profilePoles.push_back(Point3(0.0, 0.0, 0.0));
		profilePoles.push_back(Point3(1.0, -0.2, 0.1));
		profilePoles.push_back(Point3(2.0, 0.1, -0.1));
		profilePoles.push_back(Point3(3.0, -0.1, 0.0));
		profilePoles.push_back(Point3(4.0, 0.1, 0.2));
		profileKnots[0] = 0;
		profileKnots[1] = 0.5;
		profileKnots[2] = 1;
		profileMults.front() = 4;
		profileMults.back() = 4;
		std::shared_ptr<Geom3BSplineCurve> profileCurve = std::make_shared<Geom3BSplineCurve>(profilePoles, profileKnots, profileMults, 3);
		std::vector<Point3> spinePoles;
		std::vector<double> spineKnots(4);
		std::vector<int> spineMults(4, 1);
		spinePoles.push_back(Point3(0.0, 0.0, 0.0));
		spinePoles.push_back(Point3(-0.1, 1.0, -0.2));
		spinePoles.push_back(Point3(0.1, 2.0, -0.1));
		spinePoles.push_back(Point3(0.2, 3.0, 0.1));
		spinePoles.push_back(Point3(0.1, 4.0, 0.0));
		spinePoles.push_back(Point3(0.0, 5.0, -0.1));
		spineKnots[0] = 0;
		spineKnots[1] = 1.0 / 3.0;
		spineKnots[2] = 2.0 / 3.0;
		spineKnots[3] = 1;
		spineMults.front() = 4;
		spineMults.back() = 4;
		std::shared_ptr<Geom3BSplineCurve> spineCurve = std::make_shared<Geom3BSplineCurve>(spinePoles, spineKnots, spineMults, 3);
		TopoWire profile = MakeWire(MakeEdge(profileCurve)).Wire();
		TopoWire spine = MakeWire(MakeEdge(spineCurve)).Wire();
		MakePipeShell pipeShell(spine);
		pipeShell.Add(profile);
		pipeShell.SetMode(Frame3());
		TopoShape pipe = pipeShell.Shape();
		TopoExplorer ex(pipe, ShapeType::Face);
		TopoFace inputBasicFace = static_cast<const TopoFace&>(ex.Current());
		auto surf = TopoTool::Surface(inputBasicFace);
		bspSurf = NURBSAPIConvert::ToBSpline(surf);
		break;
	}
	case 1:
	{
		Array2<Point3> poles(2, 5);
		poles(0, 0) = Point3(0.0, 0.0, 0.0);
		poles(0, 1) = Point3(1.0, -0.2, 0.1);
		poles(0, 2) = Point3(2.0, 0.1, -0.1);
		poles(0, 3) = Point3(3.0, -0.1, 0.0);
		poles(0, 4) = Point3(4.0, 0.1, 0.2);
		poles(1, 0) = Point3(0.0, 1.0, -0.1);
		poles(1, 1) = Point3(1.0, 0.8, 0.0);
		poles(1, 2) = Point3(2.0, 1.1, -0.2);
		poles(1, 3) = Point3(3.0, 0.9, -0.1);
		poles(1, 4) = Point3(4.0, 1.1, 0.1);
		std::vector<double> vKnots(3);
		std::vector<int> vMults(3, 1);
		vKnots[0] = 0;
		vKnots[1] = 0.5;
		vKnots[2] = 1;
		vMults.front() = 4;
		vMults.back() = 4;
		std::vector<double> uKnots(2);
		std::vector<int> uMults(2, 1);
		uKnots[0] = 0;
		uKnots[1] = 1;
		uMults.front() = 2;
		uMults.back() = 2;
		bspSurf = std::make_shared<Geom3BSplineSurface>(poles, uKnots, vKnots, uMults, vMults, 1, 3);
		Transformation3 trsf;
		trsf.SetTranslationPart(Vector3(0.0, -6.0, 0.0));
		bspSurf->Transform(trsf);
		break;
	}
	case 2:
	{
		std::vector<Point3> profilePoles;
		std::vector<double> profileKnots(4);
		std::vector<int> profileMults(4, 1);
		profilePoles.push_back(Point3(0.0, 0.0, 0.0));
		profilePoles.push_back(Point3(1.0, -2.0, -3.0));
		profilePoles.push_back(Point3(2.0, 1.0, 2.0));
		profilePoles.push_back(Point3(3.0, -1.0, -1.0));
		profilePoles.push_back(Point3(4.0, -3.0, 3.0));
		profilePoles.push_back(Point3(5.0, 0.0, 1.0));
		profileKnots[0] = 0;
		profileKnots[1] = 1.0 / 3.0;
		profileKnots[2] = 2.0 / 3.0;
		profileKnots[3] = 1;
		profileMults.front() = 4;
		profileMults.back() = 4;
		std::shared_ptr<Geom3BSplineCurve> profileCurve = std::make_shared<Geom3BSplineCurve>(profilePoles, profileKnots, profileMults, 3);
		std::vector<Point3> spinePoles;
		std::vector<double> spineKnots(4);
		std::vector<int> spineMults(4, 1);
		spinePoles.push_back(Point3(0.0, 0.0, 0.0));
		spinePoles.push_back(Point3(-0.1, 1.0, -1.0));
		spinePoles.push_back(Point3(0.1, -2.0, -2.0));
		spinePoles.push_back(Point3(0.2, -3.0, -3.0));
		spinePoles.push_back(Point3(0.1, -4.0, -4.0));
		spinePoles.push_back(Point3(0.0, -2.5, -5.0));
		spinePoles.push_back(Point3(0.1, -1.0, -6.0));
		spinePoles.push_back(Point3(0.0, 0.0, -7.0));
		spineKnots[0] = 0;
		spineKnots[1] = 1.0 / 3.0;
		spineKnots[2] = 2.0 / 3.0;
		spineKnots[3] = 1;
		spineMults.front() = 6;
		spineMults.back() = 6;
		shared_ptr<Geom3BSplineCurve> spineCurve = std::make_shared<Geom3BSplineCurve>(spinePoles, spineKnots, spineMults, 5);
		TopoWire profile = MakeWire(MakeEdge(profileCurve)).Wire();
		TopoWire spine = MakeWire(MakeEdge(spineCurve)).Wire();
		MakePipeShell pipeShell(spine);
		pipeShell.Add(profile);
		pipeShell.SetMode(Frame3());
		TopoShape pipe = pipeShell.Shape();
		TopoExplorer ex(pipe, ShapeType::Face);
		TopoFace inputBasicFace = static_cast<const TopoFace&>(ex.Current());
		shared_ptr<Geom3Surface> surf = TopoTool::Surface(inputBasicFace);
		shared_ptr<Geom3BSplineSurface>  bspSurf = NURBSAPIConvert::ToBSpline(surf);
		Transformation3 trsf;
		trsf.SetTranslationPart(Vector3(-6.0, 0.0, 0.0));
		bspSurf->Transform(trsf);
		break;
	}
	}
	return bspSurf;
}
TEST_CASE("bug2: TestMatchTrimmedSurface ", "[nurbs][Match][fixbug]")
{
	OUTPUT_DIRECTORY(nurbs, Match/bug590);
	string filedir = INPUT_PATH_PREFIX"./TestNURBS/TestMatchTrimmedSurface/";
	TopoFace f1 = ReadBRepFace(filedir + "surf1.brep");
	TopoFace f2 = ReadBRepFace(filedir + "surf2.brep");
	Point3 p1, p2;
	bool isSurf1TrimmedEdge = true;
	bool isSurf2TrimmedEdge = true;
	if (isSurf1TrimmedEdge)
	{
		p1 = ReadBRepPoint(filedir + "tptS1.brep");
	}
	else
	{
		p1 = ReadBRepPoint(filedir + "nptS1.brep");
	}
	if (isSurf2TrimmedEdge)
	{
		p2 = ReadBRepPoint(filedir + "tptS2.brep");
	}
	else
	{
		p2 = ReadBRepPoint(filedir + "nptS2.brep");
	}
	auto [d1, e1] = NearestEdge(p1, f1);
	auto [d2, e2] = NearestEdge(p2, f2);
	ContinuityType cont = ContinuityType::G2;
	int otherEndCont = 0;
	NURBSMatchSurfConfig config;
	bool isPrecise = true;
	std::vector<double> tol;
	tol.push_back(0.001);
	tol.push_back(0.1);
	tol.push_back(0.05);
	std::vector<double> params(2, 1.0);
	auto result = NURBSAPIMatch::MatchFace(f1, e1, f2, e2, cont, otherEndCont, isPrecise, tol, params, false, config, config);
	double f = 0.0;
	double l = 0.0;
	shared_ptr< Geom3Curve > curve2 = TopoTool::Curve(e2, f, l);
	shared_ptr< Geom3Surface > src = TopoTool::Surface(f1);
	shared_ptr< Geom3Surface > surface = TopoTool::Surface(result[0]);
	double srcfpv = src->FirstVParameter();
	double fpv = surface->FirstVParameter();
	double lpv = surface->LastVParameter();
	shared_ptr<Geom3Curve> srcfv = src->VIso(srcfpv);
	shared_ptr<Geom3Curve> fv = surface->VIso(fpv);
	shared_ptr<Geom3Curve> lv = surface->VIso(lpv);
	int num = 1000;
	double resTol = 1e-3;
	double ratio = 0.1;
	double res1 = NurbsSampleCurve(num, resTol, srcfv, fv);
	double res2 = NurbsSampleCurve(num, resTol, curve2, lv);
	CHECK(res1 <= ratio);
	CHECK(res2 <= ratio);
	OCCTIO::OCCTTool::Write(MakeEdge(srcfv), outdir + "srcfv.brep");
	OCCTIO::OCCTTool::Write(MakeEdge(fv), outdir + "fv.brep");
	OCCTIO::OCCTTool::Write(MakeEdge(lv), outdir + "lv.brep");
	OCCTIO::OCCTTool::Write(f1, outdir + "f1.brep");
	OCCTIO::OCCTTool::Write(f2, outdir + "f2.brep");
	OCCTIO::OCCTTool::Write(MakeVertex(p1), outdir + "p1.brep");
	OCCTIO::OCCTTool::Write(MakeVertex(p2), outdir + "p2.brep");
	OCCTIO::OCCTTool::Write(e1, outdir + "e1.brep");
	OCCTIO::OCCTTool::Write(e2, outdir + "e2.brep");
	OCCTIO::OCCTTool::Write(result.front(), outdir + "result.brep");
;
	SECTION("MatchCurveWithEachOther")
	{
		string filedir = INPUT_PATH_PREFIX"./TestNURBS/TestMatchCurve/";
		string filedir1 = INPUT_PATH_PREFIX"./TestNURBS/TestMatchCurve/Rhino/";
		string filedir2 = INPUT_PATH_PREFIX"./TestNURBS/TestMatchCurve/Rhino/stepEachOther/";
		shared_ptr<Geom3BSplineCurve> bsp1 = ReadBRepCurve(filedir + "curve1.brep");
		shared_ptr<Geom3BSplineCurve> bsp2 = ReadBRepCurve(filedir + "curve2.brep");
		 OUTPUT_DIRECTORY(nurbs, Match/MatchCurve/MatchCurveWithEachOther);
		 auto nbsp1 = NURBSAPIMatch::MatchCurveWithEachOther(ContinuityType::C0, bsp1, true, bsp2, true, 0);
		 auto nbsp2 = NURBSAPIMatch::MatchCurveWithEachOther(ContinuityType::C0, bsp1, false, bsp2, true, 0);
		 auto nbsp3 = NURBSAPIMatch::MatchCurveWithEachOther(ContinuityType::C0, bsp1, true, bsp2, false, 0);
		 auto nbsp4 = NURBSAPIMatch::MatchCurveWithEachOther(ContinuityType::C0, bsp1, false, bsp2, false, 0);
		 auto nbsp5 = NURBSAPIMatch::MatchCurveWithEachOther(ContinuityType::G1, bsp1, true, bsp2, true, 0);
		 auto nbsp6 = NURBSAPIMatch::MatchCurveWithEachOther(ContinuityType::G1, bsp1, false, bsp2, true, 0);
		 auto nbsp7 = NURBSAPIMatch::MatchCurveWithEachOther(ContinuityType::G1, bsp1, true, bsp2, false, 0);
		 auto nbsp8 = NURBSAPIMatch::MatchCurveWithEachOther(ContinuityType::G1, bsp1, false, bsp2, false, 0);
		 auto nbsp9 = NURBSAPIMatch::MatchCurveWithEachOther(ContinuityType::G2, bsp1, true, bsp2, true, 0);
		 auto nbsp10 = NURBSAPIMatch::MatchCurveWithEachOther(ContinuityType::G2, bsp1, false, bsp2, true, 0);
		 auto nbsp11 = NURBSAPIMatch::MatchCurveWithEachOther(ContinuityType::G2, bsp1, true, bsp2, false, 0);
		 auto nbsp12 = NURBSAPIMatch::MatchCurveWithEachOther(ContinuityType::G2, bsp1, false, bsp2, false, 0);
		 shared_ptr<Geom3BSplineCurve> bsp1C0res1 = ReadBRepCurve(filedir2 + "bsp1C0truetrue.brep");
		 shared_ptr<Geom3BSplineCurve> bsp1C0res2 = ReadBRepCurve(filedir2 + "bsp1C0falsetrue.brep");
		 shared_ptr<Geom3BSplineCurve> bsp1C0res3 = ReadBRepCurve(filedir2 + "bsp1C0truefalse.brep");
		 shared_ptr<Geom3BSplineCurve> bsp1C0res4 = ReadBRepCurve(filedir2 + "bsp1C0falsefalse.brep");
		 shared_ptr<Geom3BSplineCurve> bsp1G1res1 = ReadBRepCurve(filedir2 + "bsp1G1truetrue.brep");
		 shared_ptr<Geom3BSplineCurve> bsp1G1res2 = ReadBRepCurve(filedir2 + "bsp1G1falsetrue.brep");
		 shared_ptr<Geom3BSplineCurve> bsp1G1res3 = ReadBRepCurve(filedir2 + "bsp1G1truefalse.brep");
		 shared_ptr<Geom3BSplineCurve> bsp1G1res4 = ReadBRepCurve(filedir2 + "bsp1G1falsefalse.brep");
		 shared_ptr<Geom3BSplineCurve> bsp1G2res1 = ReadBRepCurve(filedir2 + "bsp1G2truetrue.brep");
		 shared_ptr<Geom3BSplineCurve> bsp1G2res2 = ReadBRepCurve(filedir2 + "bsp1G2falsetrue.brep");
		 shared_ptr<Geom3BSplineCurve> bsp1G2res3 = ReadBRepCurve(filedir2 + "bsp1G2truefalse.brep");
		 shared_ptr<Geom3BSplineCurve> bsp1G2res4 = ReadBRepCurve(filedir2 + "bsp1G2falsefalse.brep");
		 shared_ptr<Geom3BSplineCurve> bsp2C0res1 = ReadBRepCurve(filedir2 + "bsp2C0truetrue.brep");
		 shared_ptr<Geom3BSplineCurve> bsp2C0res2 = ReadBRepCurve(filedir2 + "bsp2C0falsetrue.brep");
		 shared_ptr<Geom3BSplineCurve> bsp2C0res3 = ReadBRepCurve(filedir2 + "bsp2C0truefalse.brep");
		 shared_ptr<Geom3BSplineCurve> bsp2C0res4 = ReadBRepCurve(filedir2 + "bsp2C0falsefalse.brep");
		 shared_ptr<Geom3BSplineCurve> bsp2G1res1 = ReadBRepCurve(filedir2 + "bsp2G1truetrue.brep");
		 shared_ptr<Geom3BSplineCurve> bsp2G1res2 = ReadBRepCurve(filedir2 + "bsp2G1falsetrue.brep");
		 shared_ptr<Geom3BSplineCurve> bsp2G1res3 = ReadBRepCurve(filedir2 + "bsp2G1truefalse.brep");
		 shared_ptr<Geom3BSplineCurve> bsp2G1res4 = ReadBRepCurve(filedir2 + "bsp2G1falsefalse.brep");
		 shared_ptr<Geom3BSplineCurve> bsp2G2res1 = ReadBRepCurve(filedir2 + "bsp2G2truetrue.brep");
		 shared_ptr<Geom3BSplineCurve> bsp2G2res2 = ReadBRepCurve(filedir2 + "bsp2G2falsetrue.brep");
		 shared_ptr<Geom3BSplineCurve> bsp2G2res3 = ReadBRepCurve(filedir2 + "bsp2G2truefalse.brep");
		 shared_ptr<Geom3BSplineCurve> bsp2G2res4 = ReadBRepCurve(filedir2 + "bsp2G2falsefalse.brep");
		 CHECK(nbsp1.first->NKnots() == bsp1C0res1->NKnots());
		 CHECK(nbsp1.second->NKnots() == bsp2C0res1->NKnots());
		 CHECK((nbsp1.first->StartPoint()).X() == Approx((nbsp1.second->StartPoint()).X()));
		 CHECK((nbsp1.first->StartPoint()).Y() == Approx((nbsp1.second->StartPoint()).Y()));
		 CHECK((nbsp1.first->StartPoint()).Z() == Approx((nbsp1.second->StartPoint()).Z()));
		 CHECK((nbsp1.first->EndPoint()).X() == Approx((bsp1->EndPoint()).X()));
		 CHECK((nbsp1.first->EndPoint()).Y() == Approx((bsp1->EndPoint()).Y()));
		 CHECK((nbsp1.first->EndPoint()).Z() == Approx((bsp1->EndPoint()).Z()));
		 CHECK((nbsp1.second->EndPoint()).X() == Approx((bsp2->EndPoint()).X()));
		 CHECK((nbsp1.second->EndPoint()).Y() == Approx((bsp2->EndPoint()).Y()));
		 CHECK((nbsp1.second->EndPoint()).Z() == Approx((bsp2->EndPoint()).Z()));
		 CHECK(nbsp2.first->NKnots() == bsp1C0res2->NKnots());
		 CHECK(nbsp2.second->NKnots() == bsp2C0res2->NKnots());
		 CHECK((nbsp2.first->EndPoint()).X() == Approx((nbsp2.second->StartPoint()).X()));
		 CHECK((nbsp2.first->EndPoint()).Y() == Approx((nbsp2.second->StartPoint()).Y()));
		 CHECK((nbsp2.first->EndPoint()).Z() == Approx((nbsp2.second->StartPoint()).Z()));
		 CHECK((nbsp2.first->StartPoint()).X() == Approx((bsp1->StartPoint()).X()));
		 CHECK((nbsp2.first->StartPoint()).Y() == Approx((bsp1->StartPoint()).Y()));
		 CHECK((nbsp2.first->StartPoint()).Z() == Approx((bsp1->StartPoint()).Z()));
		 CHECK((nbsp2.second->EndPoint()).X() == Approx((bsp2->EndPoint()).X()));
		 CHECK((nbsp2.second->EndPoint()).Y() == Approx((bsp2->EndPoint()).Y()));
		 CHECK((nbsp2.second->EndPoint()).Z() == Approx((bsp2->EndPoint()).Z()));
		 CHECK(nbsp3.first->NKnots() == bsp1C0res3->NKnots());
		 CHECK(nbsp3.second->NKnots() == bsp2C0res3->NKnots());
		 CHECK((nbsp3.first->StartPoint()).X() == Approx((nbsp3.second->EndPoint()).X()));
		 CHECK((nbsp3.first->StartPoint()).Y() == Approx((nbsp3.second->EndPoint()).Y()));
		 CHECK((nbsp3.first->StartPoint()).Z() == Approx((nbsp3.second->EndPoint()).Z()));
		 CHECK((nbsp3.first->EndPoint()).X() == Approx((bsp1->EndPoint()).X()));
		 CHECK((nbsp3.first->EndPoint()).Y() == Approx((bsp1->EndPoint()).Y()));
		 CHECK((nbsp3.first->EndPoint()).Z() == Approx((bsp1->EndPoint()).Z()));
		 CHECK((nbsp3.second->StartPoint()).X() == Approx((bsp2->StartPoint()).X()));
		 CHECK((nbsp3.second->StartPoint()).Y() == Approx((bsp2->StartPoint()).Y()));
		 CHECK((nbsp3.second->StartPoint()).Z() == Approx((bsp2->StartPoint()).Z()));
		 CHECK(nbsp4.first->NKnots() == bsp1C0res4->NKnots());
		 CHECK(nbsp4.second->NKnots() == bsp2C0res4->NKnots());
		 CHECK((nbsp4.first->EndPoint()).X() == Approx((nbsp4.second->EndPoint()).X()));
		 CHECK((nbsp4.first->EndPoint()).Y() == Approx((nbsp4.second->EndPoint()).Y()));
		 CHECK((nbsp4.first->EndPoint()).Z() == Approx((nbsp4.second->EndPoint()).Z()));
		 CHECK((nbsp4.first->StartPoint()).X() == Approx((bsp1->StartPoint()).X()));
		 CHECK((nbsp4.first->StartPoint()).Y() == Approx((bsp1->StartPoint()).Y()));
		 CHECK((nbsp4.first->StartPoint()).Z() == Approx((bsp1->StartPoint()).Z()));
		 CHECK((nbsp4.second->StartPoint()).X() == Approx((bsp2->StartPoint()).X()));
		 CHECK((nbsp4.second->StartPoint()).Y() == Approx((bsp2->StartPoint()).Y()));
		 CHECK((nbsp4.second->StartPoint()).Z() == Approx((bsp2->StartPoint()).Z()));
		 CHECK(nbsp5.first->NKnots() == bsp1G1res1->NKnots());
		 CHECK(nbsp5.second->NKnots() == bsp2G1res1->NKnots());
		 CHECK((nbsp5.first->StartPoint()).X() == Approx((nbsp5.second->StartPoint()).X()));
		 CHECK((nbsp5.first->StartPoint()).Y() == Approx((nbsp5.second->StartPoint()).Y()));
		 CHECK((nbsp5.first->StartPoint()).Z() == Approx((nbsp5.second->StartPoint()).Z()));
		 CHECK((nbsp5.first->EndPoint()).X() == Approx((bsp1->EndPoint()).X()));
		 CHECK((nbsp5.first->EndPoint()).Y() == Approx((bsp1->EndPoint()).Y()));
		 CHECK((nbsp5.first->EndPoint()).Z() == Approx((bsp1->EndPoint()).Z()));
		 CHECK((nbsp5.second->EndPoint()).X() == Approx((bsp2->EndPoint()).X()));
		 CHECK((nbsp5.second->EndPoint()).Y() == Approx((bsp2->EndPoint()).Y()));
		 CHECK((nbsp5.second->EndPoint()).Z() == Approx((bsp2->EndPoint()).Z()));
		 CHECK(nbsp6.first->NKnots() == bsp1G1res2->NKnots());
		 CHECK(nbsp6.second->NKnots() == bsp2G1res2->NKnots());
		 CHECK((nbsp6.first->EndPoint()).X() == Approx((nbsp6.second->StartPoint()).X()));
		 CHECK((nbsp6.first->EndPoint()).Y() == Approx((nbsp6.second->StartPoint()).Y()));
		 CHECK((nbsp6.first->EndPoint()).Z() == Approx((nbsp6.second->StartPoint()).Z()));
		 CHECK((nbsp6.first->StartPoint()).X() == Approx((bsp1->StartPoint()).X()));
		 CHECK((nbsp6.first->StartPoint()).Y() == Approx((bsp1->StartPoint()).Y()));
		 CHECK((nbsp6.first->StartPoint()).Z() == Approx((bsp1->StartPoint()).Z()));
		 CHECK((nbsp6.second->EndPoint()).X() == Approx((bsp2->EndPoint()).X()));
		 CHECK((nbsp6.second->EndPoint()).Y() == Approx((bsp2->EndPoint()).Y()));
		 CHECK((nbsp6.second->EndPoint()).Z() == Approx((bsp2->EndPoint()).Z()));
		 CHECK(nbsp7.first->NKnots() == bsp1G1res3->NKnots());
		 CHECK(nbsp7.second->NKnots() == bsp2G1res3->NKnots());
		 CHECK((nbsp7.first->StartPoint()).X() == Approx((nbsp7.second->EndPoint()).X()));
		 CHECK((nbsp7.first->StartPoint()).Y() == Approx((nbsp7.second->EndPoint()).Y()));
		 CHECK((nbsp7.first->StartPoint()).Z() == Approx((nbsp7.second->EndPoint()).Z()));
		 CHECK((nbsp7.first->EndPoint()).X() == Approx((bsp1->EndPoint()).X()));
		 CHECK((nbsp7.first->EndPoint()).Y() == Approx((bsp1->EndPoint()).Y()));
		 CHECK((nbsp7.first->EndPoint()).Z() == Approx((bsp1->EndPoint()).Z()));
		 CHECK((nbsp7.second->StartPoint()).X() == Approx((bsp2->StartPoint()).X()));
		 CHECK((nbsp7.second->StartPoint()).Y() == Approx((bsp2->StartPoint()).Y()));
		 CHECK((nbsp7.second->StartPoint()).Z() == Approx((bsp2->StartPoint()).Z()));
		 CHECK(nbsp8.first->NKnots() == bsp1G1res4->NKnots());
		 CHECK(nbsp8.second->NKnots() == bsp2G1res4->NKnots());
		 CHECK((nbsp8.first->EndPoint()).X() == Approx((nbsp8.second->EndPoint()).X()));
		 CHECK((nbsp8.first->EndPoint()).Y() == Approx((nbsp8.second->EndPoint()).Y()));
		 CHECK((nbsp8.first->EndPoint()).Z() == Approx((nbsp8.second->EndPoint()).Z()));
		 CHECK((nbsp8.first->StartPoint()).X() == Approx((bsp1->StartPoint()).X()));
		 CHECK((nbsp8.first->StartPoint()).Y() == Approx((bsp1->StartPoint()).Y()));
		 CHECK((nbsp8.first->StartPoint()).Z() == Approx((bsp1->StartPoint()).Z()));
		 CHECK((nbsp8.second->StartPoint()).X() == Approx((bsp2->StartPoint()).X()));
		 CHECK((nbsp8.second->StartPoint()).Y() == Approx((bsp2->StartPoint()).Y()));
		 CHECK((nbsp8.second->StartPoint()).Z() == Approx((bsp2->StartPoint()).Z()));
		 CHECK(nbsp9.first->NKnots() == bsp1G2res1->NKnots());
		 CHECK(nbsp9.second->NKnots() == bsp2G2res1->NKnots());
		 CHECK((nbsp9.first->StartPoint()).X() == Approx((nbsp9.second->StartPoint()).X()));
		 CHECK((nbsp9.first->StartPoint()).Y() == Approx((nbsp9.second->StartPoint()).Y()));
		 CHECK((nbsp9.first->StartPoint()).Z() == Approx((nbsp9.second->StartPoint()).Z()));
		 CHECK((nbsp9.first->EndPoint()).X() == Approx((bsp1->EndPoint()).X()));
		 CHECK((nbsp9.first->EndPoint()).Y() == Approx((bsp1->EndPoint()).Y()));
		 CHECK((nbsp9.first->EndPoint()).Z() == Approx((bsp1->EndPoint()).Z()));
		 CHECK((nbsp9.second->EndPoint()).X() == Approx((bsp2->EndPoint()).X()));
		 CHECK((nbsp9.second->EndPoint()).Y() == Approx((bsp2->EndPoint()).Y()));
		 CHECK((nbsp9.second->EndPoint()).Z() == Approx((bsp2->EndPoint()).Z()));
		 CHECK(nbsp10.first->NKnots() == bsp1G2res2->NKnots());
		 CHECK(nbsp10.second->NKnots() == bsp2G2res2->NKnots());
		 CHECK((nbsp10.first->EndPoint()).X() == Approx((nbsp10.second->StartPoint()).X()));
		 CHECK((nbsp10.first->EndPoint()).Y() == Approx((nbsp10.second->StartPoint()).Y()));
		 CHECK((nbsp10.first->EndPoint()).Z() == Approx((nbsp10.second->StartPoint()).Z()));
		 CHECK((nbsp10.first->StartPoint()).X() == Approx((bsp1->StartPoint()).X()));
		 CHECK((nbsp10.first->StartPoint()).Y() == Approx((bsp1->StartPoint()).Y()));
		 CHECK((nbsp10.first->StartPoint()).Z() == Approx((bsp1->StartPoint()).Z()));
		 CHECK((nbsp10.second->EndPoint()).X() == Approx((bsp2->EndPoint()).X()));
		 CHECK((nbsp10.second->EndPoint()).Y() == Approx((bsp2->EndPoint()).Y()));
		 CHECK((nbsp10.second->EndPoint()).Z() == Approx((bsp2->EndPoint()).Z()));
		 CHECK(nbsp11.first->NKnots() == bsp1G2res3->NKnots());
		 CHECK(nbsp11.second->NKnots() == bsp2G2res3->NKnots());
		 CHECK((nbsp11.first->StartPoint()).X() == Approx((nbsp11.second->EndPoint()).X()));
		 CHECK((nbsp11.first->StartPoint()).Y() == Approx((nbsp11.second->EndPoint()).Y()));
		 CHECK((nbsp11.first->StartPoint()).Z() == Approx((nbsp11.second->EndPoint()).Z()));
		 CHECK((nbsp11.first->EndPoint()).X() == Approx((bsp1->EndPoint()).X()));
		 CHECK((nbsp11.first->EndPoint()).Y() == Approx((bsp1->EndPoint()).Y()));
		 CHECK((nbsp11.first->EndPoint()).Z() == Approx((bsp1->EndPoint()).Z()));
		 CHECK((nbsp11.second->StartPoint()).X() == Approx((bsp2->StartPoint()).X()));
		 CHECK((nbsp11.second->StartPoint()).Y() == Approx((bsp2->StartPoint()).Y()));
		 CHECK((nbsp11.second->StartPoint()).Z() == Approx((bsp2->StartPoint()).Z()));
		 CHECK(nbsp12.first->NKnots() == bsp1G2res4->NKnots());
		 CHECK(nbsp12.second->NKnots() == bsp2G2res4->NKnots());
		 CHECK((nbsp12.first->EndPoint()).X() == Approx((nbsp12.second->EndPoint()).X()));
		 CHECK((nbsp12.first->EndPoint()).Y() == Approx((nbsp12.second->EndPoint()).Y()));
		 CHECK((nbsp12.first->EndPoint()).Z() == Approx((nbsp12.second->EndPoint()).Z()));
		 CHECK((nbsp12.first->StartPoint()).X() == Approx((bsp1->StartPoint()).X()));
		 CHECK((nbsp12.first->StartPoint()).Y() == Approx((bsp1->StartPoint()).Y()));
		 CHECK((nbsp12.first->StartPoint()).Z() == Approx((bsp1->StartPoint()).Z()));
		 CHECK((nbsp12.second->StartPoint()).X() == Approx((bsp2->StartPoint()).X()));
		 CHECK((nbsp12.second->StartPoint()).Y() == Approx((bsp2->StartPoint()).Y()));
		 CHECK((nbsp12.second->StartPoint()).Z() == Approx((bsp2->StartPoint()).Z()));
		 OCCTIO::OCCTTool::Write(MakeEdge(bsp1), outdir + "bsp1.brep");
		 OCCTIO::OCCTTool::Write(MakeEdge(bsp2), outdir + "bsp2.brep");
		 OCCTIO::OCCTTool::Write(MakeEdge(nbsp1.first), outdir + "f1.brep");
		 OCCTIO::OCCTTool::Write(MakeEdge(nbsp1.second), outdir + "s1.brep");
		 OCCTIO::OCCTTool::Write(MakeEdge(nbsp2.first), outdir + "f2.brep");
		 OCCTIO::OCCTTool::Write(MakeEdge(nbsp2.second), outdir + "s2.brep");
		 OCCTIO::OCCTTool::Write(MakeEdge(nbsp3.first), outdir + "f3.brep");
		 OCCTIO::OCCTTool::Write(MakeEdge(nbsp3.second), outdir + "s3.brep");
		 OCCTIO::OCCTTool::Write(MakeEdge(nbsp4.first), outdir + "f4.brep");
		 OCCTIO::OCCTTool::Write(MakeEdge(nbsp4.second), outdir + "s4.brep");
		 OCCTIO::OCCTTool::Write(MakeEdge(nbsp5.first), outdir + "f5.brep");
		 OCCTIO::OCCTTool::Write(MakeEdge(nbsp5.second), outdir + "s5.brep");
		 OCCTIO::OCCTTool::Write(MakeEdge(nbsp6.first), outdir + "f6.brep");
		 OCCTIO::OCCTTool::Write(MakeEdge(nbsp6.second), outdir + "s6.brep");
		 OCCTIO::OCCTTool::Write(MakeEdge(nbsp7.first), outdir + "f7.brep");
		 OCCTIO::OCCTTool::Write(MakeEdge(nbsp7.second), outdir + "s7.brep");
		 OCCTIO::OCCTTool::Write(MakeEdge(nbsp8.first), outdir + "f8.brep");
		 OCCTIO::OCCTTool::Write(MakeEdge(nbsp8.second), outdir + "s8.brep");
		 OCCTIO::OCCTTool::Write(MakeEdge(nbsp9.first), outdir + "f9.brep");
		 OCCTIO::OCCTTool::Write(MakeEdge(nbsp9.second), outdir + "s9.brep");
		 OCCTIO::OCCTTool::Write(MakeEdge(nbsp10.first), outdir + "f10.brep");
		 OCCTIO::OCCTTool::Write(MakeEdge(nbsp10.second), outdir + "s10.brep");
		 OCCTIO::OCCTTool::Write(MakeEdge(nbsp11.first), outdir + "f11.brep");
		 OCCTIO::OCCTTool::Write(MakeEdge(nbsp11.second), outdir + "s11.brep");
		 OCCTIO::OCCTTool::Write(MakeEdge(nbsp12.first), outdir + "f12.brep");
		 OCCTIO::OCCTTool::Write(MakeEdge(nbsp12.second), outdir + "s12.brep");
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static std::vector<std::shared_ptr<Geom3BSplineSurface>> MatchSurf( const std::shared_ptr<Geom3BSplineSurface> surf, bool isModifyU, bool isFront, const std::shared_ptr<Geom3BSplineSurface>& targetSurf, bool isTargetU, bool isTargetFront, ContinuityType connectCont, int otherEndCont, bool isPrecise, const std::vector<double>& tol, std::vector<double>& params, bool isEachOther, const NURBSMatchSurfConfig& surfConfig, const NURBSMatchSurfConfig& targetSurfConfig),
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <nurbs/NURBSAPIMatch.hpp>
#include <topology/TopoEdge.hpp>
#include <topology/TopoTool.hpp>
#include <nurbs/NURBSAPISweep.hpp>
#include <nurbs/NURBSAPIRebuild.hpp>
#include <modeling/MakeWire.hpp>
#include <modeling/MakeEdge.hpp>
#include <offset/MakePipeShell.hpp>
#include <geometry/Geom3BSplineSurface.hpp>
#include <topology/TopoVertex.hpp>
#include <topomesh/BRepMeshIncrementalMesh.hpp>
#include <geometry/GeomAPIProjectPointOnCurve3.hpp>
#include <modeling/TransformShape.hpp>
#include <nurbs/NURBSAPIMatch.hpp>
#include <modeling/MakeFace.hpp>
#include <nurbs/NURBSAPIConvert.hpp>
#include <topology/TopoExplorerTool.hpp>
#include <modeling/MakeVertex.hpp>
using namespace AMCAX;
std::shared_ptr<Geom3BSplineSurface> GenerateTestSurface1(const int id)
{
	std::shared_ptr<Geom3BSplineSurface> bspSurf;
	switch (id)
	{
	case 0:
	{
		std::vector<Point3> profilePoles;
		std::vector<double> profileKnots(3);
		std::vector<int> profileMults(3, 1);
		profilePoles.push_back(Point3(0.0, 0.0, 0.0));
		profilePoles.push_back(Point3(1.0, -0.2, 0.1));
		profilePoles.push_back(Point3(2.0, 0.1, -0.1));
		profilePoles.push_back(Point3(3.0, -0.1, 0.0));
		profilePoles.push_back(Point3(4.0, 0.1, 0.2));
		profileKnots[0] = 0;
		profileKnots[1] = 0.5;
		profileKnots[2] = 1;
		profileMults.front() = 4;
		profileMults.back() = 4;
		std::shared_ptr<Geom3BSplineCurve> profileCurve = std::make_shared<Geom3BSplineCurve>(profilePoles, profileKnots, profileMults, 3);
		std::vector<Point3> spinePoles;
		std::vector<double> spineKnots(4);
		std::vector<int> spineMults(4, 1);
		spinePoles.push_back(Point3(0.0, 0.0, 0.0));
		spinePoles.push_back(Point3(-0.1, 1.0, -0.2));
		spinePoles.push_back(Point3(0.1, 2.0, -0.1));
		spinePoles.push_back(Point3(0.2, 3.0, 0.1));
		spinePoles.push_back(Point3(0.1, 4.0, 0.0));
		spinePoles.push_back(Point3(0.0, 5.0, -0.1));
		spineKnots[0] = 0;
		spineKnots[1] = 1.0 / 3.0;
		spineKnots[2] = 2.0 / 3.0;
		spineKnots[3] = 1;
		spineMults.front() = 4;
		spineMults.back() = 4;
		std::shared_ptr<Geom3BSplineCurve> spineCurve = std::make_shared<Geom3BSplineCurve>(spinePoles, spineKnots, spineMults, 3);
		TopoWire profile = MakeWire(MakeEdge(profileCurve)).Wire();
		TopoWire spine = MakeWire(MakeEdge(spineCurve)).Wire();
		MakePipeShell pipeShell(spine);
		pipeShell.Add(profile);
		pipeShell.SetMode(Frame3());
		TopoShape pipe = pipeShell.Shape();
		TopoExplorer ex(pipe, ShapeType::Face);
		TopoFace inputBasicFace = static_cast<const TopoFace&>(ex.Current());
		auto surf = TopoTool::Surface(inputBasicFace);
		bspSurf = NURBSAPIConvert::ToBSpline(surf);
		break;
	}
	case 1:
	{
		Array2<Point3> poles(2, 5);
		poles(0, 0) = Point3(0.0, 0.0, 0.0);
		poles(0, 1) = Point3(1.0, -0.2, 0.1);
		poles(0, 2) = Point3(2.0, 0.1, -0.1);
		poles(0, 3) = Point3(3.0, -0.1, 0.0);
		poles(0, 4) = Point3(4.0, 0.1, 0.2);
		poles(1, 0) = Point3(0.0, 1.0, -0.1);
		poles(1, 1) = Point3(1.0, 0.8, 0.0);
		poles(1, 2) = Point3(2.0, 1.1, -0.2);
		poles(1, 3) = Point3(3.0, 0.9, -0.1);
		poles(1, 4) = Point3(4.0, 1.1, 0.1);
		std::vector<double> vKnots(3);
		std::vector<int> vMults(3, 1);
		vKnots[0] = 0;
		vKnots[1] = 0.5;
		vKnots[2] = 1;
		vMults.front() = 4;
		vMults.back() = 4;
		std::vector<double> uKnots(2);
		std::vector<int> uMults(2, 1);
		uKnots[0] = 0;
		uKnots[1] = 1;
		uMults.front() = 2;
		uMults.back() = 2;
		bspSurf = std::make_shared<Geom3BSplineSurface>(poles, uKnots, vKnots, uMults, vMults, 1, 3);
		Transformation3 trsf;
		trsf.SetTranslationPart(Vector3(0.0, -6.0, 0.0));
		bspSurf->Transform(trsf);
		break;
	}
	case 2:
	{
		std::vector<Point3> profilePoles;
		std::vector<double> profileKnots(4);
		std::vector<int> profileMults(4, 1);
		profilePoles.push_back(Point3(0.0, 0.0, 0.0));
		profilePoles.push_back(Point3(1.0, -2.0, -3.0));
		profilePoles.push_back(Point3(2.0, 1.0, 2.0));
		profilePoles.push_back(Point3(3.0, -1.0, -1.0));
		profilePoles.push_back(Point3(4.0, -3.0, 3.0));
		profilePoles.push_back(Point3(5.0, 0.0, 1.0));
		profileKnots[0] = 0;
		profileKnots[1] = 1.0 / 3.0;
		profileKnots[2] = 2.0 / 3.0;
		profileKnots[3] = 1;
		profileMults.front() = 4;
		profileMults.back() = 4;
		std::shared_ptr<Geom3BSplineCurve> profileCurve = std::make_shared<Geom3BSplineCurve>(profilePoles, profileKnots, profileMults, 3);
		std::vector<Point3> spinePoles;
		std::vector<double> spineKnots(4);
		std::vector<int> spineMults(4, 1);
		spinePoles.push_back(Point3(0.0, 0.0, 0.0));
		spinePoles.push_back(Point3(-0.1, 1.0, -1.0));
		spinePoles.push_back(Point3(0.1, -2.0, -2.0));
		spinePoles.push_back(Point3(0.2, -3.0, -3.0));
		spinePoles.push_back(Point3(0.1, -4.0, -4.0));
		spinePoles.push_back(Point3(0.0, -2.5, -5.0));
		spinePoles.push_back(Point3(0.1, -1.0, -6.0));
		spinePoles.push_back(Point3(0.0, 0.0, -7.0));
		spineKnots[0] = 0;
		spineKnots[1] = 1.0 / 3.0;
		spineKnots[2] = 2.0 / 3.0;
		spineKnots[3] = 1;
		spineMults.front() = 6;
		spineMults.back() = 6;
		shared_ptr<Geom3BSplineCurve> spineCurve = std::make_shared<Geom3BSplineCurve>(spinePoles, spineKnots, spineMults, 5);
		TopoWire profile = MakeWire(MakeEdge(profileCurve)).Wire();
		TopoWire spine = MakeWire(MakeEdge(spineCurve)).Wire();
		MakePipeShell pipeShell(spine);
		pipeShell.Add(profile);
		pipeShell.SetMode(Frame3());
		TopoShape pipe = pipeShell.Shape();
		TopoExplorer ex(pipe, ShapeType::Face);
		TopoFace inputBasicFace = static_cast<const TopoFace&>(ex.Current());
		shared_ptr<Geom3Surface> surf = TopoTool::Surface(inputBasicFace);
		shared_ptr<Geom3BSplineSurface>  bspSurf = NURBSAPIConvert::ToBSpline(surf);
		Transformation3 trsf;
		trsf.SetTranslationPart(Vector3(-6.0, 0.0, 0.0));
		bspSurf->Transform(trsf);
		break;
	}
	}
	return bspSurf;
}
TEST_CASE("bug1: TestMatchSurf2 ", "[nurbs][Match][fixbug]")
{
	OUTPUT_DIRECTORY(nurbs, Match/bug589);
	ContinuityType cont1 = ContinuityType::G2;
	bool isU1 = false;
	bool isFront1 = true;
	int surf1ID = 0;
	shared_ptr<Geom3BSplineSurface> bsp1 = GenerateTestSurface1(surf1ID);
	int nupoles = 5;
	int udeg = 3;
	int nuknots = nupoles - udeg + 1;
	int nvpoles = isU1 ? bsp1->NVPoles() : bsp1->NUPoles();
	int vdeg = isU1 ? bsp1->VDegree() : bsp1->UDegree();
	int nvknots = nvpoles - vdeg + 1;
	Array2<Point3> poles(nupoles, nvpoles);
	for (int i = 0; i < nupoles; i++)
	{
		for (int j = 0; j < nvpoles; j++)
		{
			poles(i, j).SetCoord((double)i, (double)j, 0.0);
		}
	}
	std::vector<double> uknots(nuknots), vknots(nvknots);
	for (int i = 0; i < nuknots; i++)
	{
		uknots[i] = (double)i / (double)(nuknots - 1);
	}
	for (int i = 0; i < nvknots; i++)
	{
		vknots[i] = (double)i / (double)(nvknots - 1);
	}
	vector<int> umults(nuknots, 1), vmults(nvknots, 1);
	umults.front() = udeg + 1;
	umults.back() = udeg + 1;
	vmults.front() = vdeg + 1;
	vmults.back() = vdeg + 1;
	shared_ptr<Geom3BSplineSurface> bsp2 = make_shared<Geom3BSplineSurface>(poles, uknots, vknots, umults, vmults, udeg, vdeg);
	Transformation3 trsf;
	trsf.SetTranslationPart(Vector3(0.0, 0.0, 5.0));
	bsp2->Transform(trsf);
	bool isU2 = true;
	bool isFront2 = true;
	NURBSMatchSurfConfig config;
	vector<double> params;
	auto bspSurf3 = NURBSAPIMatch::MatchSurf(bsp2, isU2, isFront2, bsp1, isU1, isFront1, cont1, 0, false, vector<double>(), params, false, config, config);
	double f1 = bsp1->FirstVParameter();
	double f2 = bsp2->LastUParameter();
	double f3 = bspSurf3[0]->FirstUParameter();
	double f4 = bspSurf3[0]->LastUParameter();
	shared_ptr<Geom3Curve> fu1 = bsp1->VIso(f1);
	shared_ptr<Geom3Curve> fu2 = bsp2->UIso(f2);
	shared_ptr<Geom3Curve> fu3 = bspSurf3[0]->UIso(f3);
	shared_ptr<Geom3Curve> fu4 = bspSurf3[0]->UIso(f4);
	int num = 1000;
	double resTol = 1e-3;
	double ratio = 0.1;
	double res1 = NurbsSampleCurve(num, resTol, fu3, fu1);
	double res2 = NurbsSampleCurve(num, resTol, fu4, fu2);
	CHECK(res1 <= ratio);
	CHECK(res2 <= ratio);
	OCCTIO::OCCTTool::Write(MakeFace(bsp1, 0.0), outdir + "bsp1.brep");
	OCCTIO::OCCTTool::Write(MakeFace(bsp2, 0.0), outdir + "bsp2.brep");
	OCCTIO::OCCTTool::Write(MakeEdge(fu1), outdir + "fu1.brep"); 
	OCCTIO::OCCTTool::Write(MakeEdge(fu2), outdir + "fu2.brep");
	OCCTIO::OCCTTool::Write(MakeEdge(fu3), outdir + "fu3.brep");
	OCCTIO::OCCTTool::Write(MakeEdge(fu4), outdir + "fu4.brep");
	OCCTIO::OCCTTool::Write(MakeFace(bspSurf3.front(), 0.0), outdir + "Result.brep");
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static std::vector<TopoFace> MatchFace( const TopoFace& face1, const TopoEdge& edge1, const TopoFace& face2, const TopoEdge& edge2, ContinuityType connectCont, int otherEndCont, bool isPrecise, const std::vector<double>& tol, std::vector<double>& params, bool isEachOther, const NURBSMatchSurfConfig& surf1Config, const NURBSMatchSurfConfig& surf2Config),
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <nurbs/NURBSAPIMatch.hpp>
#include <topology/TopoEdge.hpp>
#include <topology/TopoTool.hpp>
#include <nurbs/NURBSAPISweep.hpp>
#include <nurbs/NURBSAPIRebuild.hpp>
#include <modeling/MakeWire.hpp>
#include <modeling/MakeEdge.hpp>
#include <offset/MakePipeShell.hpp>
#include <geometry/Geom3BSplineSurface.hpp>
#include <topology/TopoVertex.hpp>
#include <topomesh/BRepMeshIncrementalMesh.hpp>
#include <geometry/GeomAPIProjectPointOnCurve3.hpp>
#include <modeling/TransformShape.hpp>
#include <nurbs/NURBSAPIMatch.hpp>
#include <modeling/MakeFace.hpp>
#include <nurbs/NURBSAPIConvert.hpp>
#include <topology/TopoExplorerTool.hpp>
#include <modeling/MakeVertex.hpp>
using namespace AMCAX;
std::shared_ptr<Geom3BSplineSurface> GenerateTestSurface1(const int id)
{
	std::shared_ptr<Geom3BSplineSurface> bspSurf;
	switch (id)
	{
	case 0:
	{
		std::vector<Point3> profilePoles;
		std::vector<double> profileKnots(3);
		std::vector<int> profileMults(3, 1);
		profilePoles.push_back(Point3(0.0, 0.0, 0.0));
		profilePoles.push_back(Point3(1.0, -0.2, 0.1));
		profilePoles.push_back(Point3(2.0, 0.1, -0.1));
		profilePoles.push_back(Point3(3.0, -0.1, 0.0));
		profilePoles.push_back(Point3(4.0, 0.1, 0.2));
		profileKnots[0] = 0;
		profileKnots[1] = 0.5;
		profileKnots[2] = 1;
		profileMults.front() = 4;
		profileMults.back() = 4;
		std::shared_ptr<Geom3BSplineCurve> profileCurve = std::make_shared<Geom3BSplineCurve>(profilePoles, profileKnots, profileMults, 3);
		std::vector<Point3> spinePoles;
		std::vector<double> spineKnots(4);
		std::vector<int> spineMults(4, 1);
		spinePoles.push_back(Point3(0.0, 0.0, 0.0));
		spinePoles.push_back(Point3(-0.1, 1.0, -0.2));
		spinePoles.push_back(Point3(0.1, 2.0, -0.1));
		spinePoles.push_back(Point3(0.2, 3.0, 0.1));
		spinePoles.push_back(Point3(0.1, 4.0, 0.0));
		spinePoles.push_back(Point3(0.0, 5.0, -0.1));
		spineKnots[0] = 0;
		spineKnots[1] = 1.0 / 3.0;
		spineKnots[2] = 2.0 / 3.0;
		spineKnots[3] = 1;
		spineMults.front() = 4;
		spineMults.back() = 4;
		std::shared_ptr<Geom3BSplineCurve> spineCurve = std::make_shared<Geom3BSplineCurve>(spinePoles, spineKnots, spineMults, 3);
		TopoWire profile = MakeWire(MakeEdge(profileCurve)).Wire();
		TopoWire spine = MakeWire(MakeEdge(spineCurve)).Wire();
		MakePipeShell pipeShell(spine);
		pipeShell.Add(profile);
		pipeShell.SetMode(Frame3());
		TopoShape pipe = pipeShell.Shape();
		TopoExplorer ex(pipe, ShapeType::Face);
		TopoFace inputBasicFace = static_cast<const TopoFace&>(ex.Current());
		auto surf = TopoTool::Surface(inputBasicFace);
		bspSurf = NURBSAPIConvert::ToBSpline(surf);
		break;
	}
	case 1:
	{
		Array2<Point3> poles(2, 5);
		poles(0, 0) = Point3(0.0, 0.0, 0.0);
		poles(0, 1) = Point3(1.0, -0.2, 0.1);
		poles(0, 2) = Point3(2.0, 0.1, -0.1);
		poles(0, 3) = Point3(3.0, -0.1, 0.0);
		poles(0, 4) = Point3(4.0, 0.1, 0.2);
		poles(1, 0) = Point3(0.0, 1.0, -0.1);
		poles(1, 1) = Point3(1.0, 0.8, 0.0);
		poles(1, 2) = Point3(2.0, 1.1, -0.2);
		poles(1, 3) = Point3(3.0, 0.9, -0.1);
		poles(1, 4) = Point3(4.0, 1.1, 0.1);
		std::vector<double> vKnots(3);
		std::vector<int> vMults(3, 1);
		vKnots[0] = 0;
		vKnots[1] = 0.5;
		vKnots[2] = 1;
		vMults.front() = 4;
		vMults.back() = 4;
		std::vector<double> uKnots(2);
		std::vector<int> uMults(2, 1);
		uKnots[0] = 0;
		uKnots[1] = 1;
		uMults.front() = 2;
		uMults.back() = 2;
		bspSurf = std::make_shared<Geom3BSplineSurface>(poles, uKnots, vKnots, uMults, vMults, 1, 3);
		Transformation3 trsf;
		trsf.SetTranslationPart(Vector3(0.0, -6.0, 0.0));
		bspSurf->Transform(trsf);
		break;
	}
	case 2:
	{
		std::vector<Point3> profilePoles;
		std::vector<double> profileKnots(4);
		std::vector<int> profileMults(4, 1);
		profilePoles.push_back(Point3(0.0, 0.0, 0.0));
		profilePoles.push_back(Point3(1.0, -2.0, -3.0));
		profilePoles.push_back(Point3(2.0, 1.0, 2.0));
		profilePoles.push_back(Point3(3.0, -1.0, -1.0));
		profilePoles.push_back(Point3(4.0, -3.0, 3.0));
		profilePoles.push_back(Point3(5.0, 0.0, 1.0));
		profileKnots[0] = 0;
		profileKnots[1] = 1.0 / 3.0;
		profileKnots[2] = 2.0 / 3.0;
		profileKnots[3] = 1;
		profileMults.front() = 4;
		profileMults.back() = 4;
		std::shared_ptr<Geom3BSplineCurve> profileCurve = std::make_shared<Geom3BSplineCurve>(profilePoles, profileKnots, profileMults, 3);
		std::vector<Point3> spinePoles;
		std::vector<double> spineKnots(4);
		std::vector<int> spineMults(4, 1);
		spinePoles.push_back(Point3(0.0, 0.0, 0.0));
		spinePoles.push_back(Point3(-0.1, 1.0, -1.0));
		spinePoles.push_back(Point3(0.1, -2.0, -2.0));
		spinePoles.push_back(Point3(0.2, -3.0, -3.0));
		spinePoles.push_back(Point3(0.1, -4.0, -4.0));
		spinePoles.push_back(Point3(0.0, -2.5, -5.0));
		spinePoles.push_back(Point3(0.1, -1.0, -6.0));
		spinePoles.push_back(Point3(0.0, 0.0, -7.0));
		spineKnots[0] = 0;
		spineKnots[1] = 1.0 / 3.0;
		spineKnots[2] = 2.0 / 3.0;
		spineKnots[3] = 1;
		spineMults.front() = 6;
		spineMults.back() = 6;
		shared_ptr<Geom3BSplineCurve> spineCurve = std::make_shared<Geom3BSplineCurve>(spinePoles, spineKnots, spineMults, 5);
		TopoWire profile = MakeWire(MakeEdge(profileCurve)).Wire();
		TopoWire spine = MakeWire(MakeEdge(spineCurve)).Wire();
		MakePipeShell pipeShell(spine);
		pipeShell.Add(profile);
		pipeShell.SetMode(Frame3());
		TopoShape pipe = pipeShell.Shape();
		TopoExplorer ex(pipe, ShapeType::Face);
		TopoFace inputBasicFace = static_cast<const TopoFace&>(ex.Current());
		shared_ptr<Geom3Surface> surf = TopoTool::Surface(inputBasicFace);
		shared_ptr<Geom3BSplineSurface>  bspSurf = NURBSAPIConvert::ToBSpline(surf);
		Transformation3 trsf;
		trsf.SetTranslationPart(Vector3(-6.0, 0.0, 0.0));
		bspSurf->Transform(trsf);
		break;
	}
	}
	return bspSurf;
}
TEST_CASE("bug2: TestMatchTrimmedSurface ", "[nurbs][Match][fixbug]")
{
	OUTPUT_DIRECTORY(nurbs, Match/bug590);
	string filedir = INPUT_PATH_PREFIX"./TestNURBS/TestMatchTrimmedSurface/";
	TopoFace f1 = ReadBRepFace(filedir + "surf1.brep");
	TopoFace f2 = ReadBRepFace(filedir + "surf2.brep");
	Point3 p1, p2;
	bool isSurf1TrimmedEdge = true;
	bool isSurf2TrimmedEdge = true;
	if (isSurf1TrimmedEdge)
	{
		p1 = ReadBRepPoint(filedir + "tptS1.brep");
	}
	else
	{
		p1 = ReadBRepPoint(filedir + "nptS1.brep");
	}
	if (isSurf2TrimmedEdge)
	{
		p2 = ReadBRepPoint(filedir + "tptS2.brep");
	}
	else
	{
		p2 = ReadBRepPoint(filedir + "nptS2.brep");
	}
	auto [d1, e1] = NearestEdge(p1, f1);
	auto [d2, e2] = NearestEdge(p2, f2);
	ContinuityType cont = ContinuityType::G2;
	int otherEndCont = 0;
	NURBSMatchSurfConfig config;
	bool isPrecise = true;
	std::vector<double> tol;
	tol.push_back(0.001);
	tol.push_back(0.1);
	tol.push_back(0.05);
	std::vector<double> params(2, 1.0);
	auto result = NURBSAPIMatch::MatchFace(f1, e1, f2, e2, cont, otherEndCont, isPrecise, tol, params, false, config, config);
	double f = 0.0;
	double l = 0.0;
	shared_ptr< Geom3Curve > curve2 = TopoTool::Curve(e2, f, l);
	shared_ptr< Geom3Surface > src = TopoTool::Surface(f1);
	shared_ptr< Geom3Surface > surface = TopoTool::Surface(result[0]);
	double srcfpv = src->FirstVParameter();
	double fpv = surface->FirstVParameter();
	double lpv = surface->LastVParameter();
	shared_ptr<Geom3Curve> srcfv = src->VIso(srcfpv);
	shared_ptr<Geom3Curve> fv = surface->VIso(fpv);
	shared_ptr<Geom3Curve> lv = surface->VIso(lpv);
	int num = 1000;
	double resTol = 1e-3;
	double ratio = 0.1;
	double res1 = NurbsSampleCurve(num, resTol, srcfv, fv);
	double res2 = NurbsSampleCurve(num, resTol, curve2, lv);
	CHECK(res1 <= ratio);
	CHECK(res2 <= ratio);
	OCCTIO::OCCTTool::Write(MakeEdge(srcfv), outdir + "srcfv.brep");
	OCCTIO::OCCTTool::Write(MakeEdge(fv), outdir + "fv.brep");
	OCCTIO::OCCTTool::Write(MakeEdge(lv), outdir + "lv.brep");
	OCCTIO::OCCTTool::Write(f1, outdir + "f1.brep");
	OCCTIO::OCCTTool::Write(f2, outdir + "f2.brep");
	OCCTIO::OCCTTool::Write(MakeVertex(p1), outdir + "p1.brep");
	OCCTIO::OCCTTool::Write(MakeVertex(p2), outdir + "p2.brep");
	OCCTIO::OCCTTool::Write(e1, outdir + "e1.brep");
	OCCTIO::OCCTTool::Write(e2, outdir + "e2.brep");
	OCCTIO::OCCTTool::Write(result.front(), outdir + "result.brep");
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static std::shared_ptr<Geom3BSplineCurve> MatchCurve( ContinuityType cont, const std::shared_ptr<Geom3BSplineCurve>& curve, bool isFront, const std::shared_ptr<Geom3BSplineCurve>& targetCurve, bool isTargetFront, int otherEndCont),
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <nurbs/NURBSAPIMatch.hpp>
#include <topology/TopoEdge.hpp>
#include <topology/TopoTool.hpp>
#include <nurbs/NURBSAPISweep.hpp>
#include <nurbs/NURBSAPIRebuild.hpp>
#include <modeling/MakeWire.hpp>
#include <modeling/MakeEdge.hpp>
#include <offset/MakePipeShell.hpp>
#include <geometry/Geom3BSplineSurface.hpp>
#include <topology/TopoVertex.hpp>
#include <topomesh/BRepMeshIncrementalMesh.hpp>
#include <geometry/GeomAPIProjectPointOnCurve3.hpp>
#include <modeling/TransformShape.hpp>
#include <nurbs/NURBSAPIMatch.hpp>
#include <modeling/MakeFace.hpp>
#include <nurbs/NURBSAPIConvert.hpp>
#include <topology/TopoExplorerTool.hpp>
#include <modeling/MakeVertex.hpp>
using namespace AMCAX;
std::shared_ptr<Geom3BSplineSurface> GenerateTestSurface11(const int id)
{
	std::shared_ptr<Geom3BSplineSurface> bspSurf;
	switch (id)
	{
	case 0:
	{
		std::vector<Point3> profilePoles;
		std::vector<double> profileKnots(3);
		std::vector<int> profileMults(3, 1);
		profilePoles.push_back(Point3(0.0, 0.0, 0.0));
		profilePoles.push_back(Point3(1.0, -0.2, 0.1));
		profilePoles.push_back(Point3(2.0, 0.1, -0.1));
		profilePoles.push_back(Point3(3.0, -0.1, 0.0));
		profilePoles.push_back(Point3(4.0, 0.1, 0.2));
		profileKnots[0] = 0;
		profileKnots[1] = 0.5;
		profileKnots[2] = 1;
		profileMults.front() = 4;
		profileMults.back() = 4;
		std::shared_ptr<Geom3BSplineCurve> profileCurve = std::make_shared<Geom3BSplineCurve>(profilePoles, profileKnots, profileMults, 3);
		std::vector<Point3> spinePoles;
		std::vector<double> spineKnots(4);
		std::vector<int> spineMults(4, 1);
		spinePoles.push_back(Point3(0.0, 0.0, 0.0));
		spinePoles.push_back(Point3(-0.1, 1.0, -0.2));
		spinePoles.push_back(Point3(0.1, 2.0, -0.1));
		spinePoles.push_back(Point3(0.2, 3.0, 0.1));
		spinePoles.push_back(Point3(0.1, 4.0, 0.0));
		spinePoles.push_back(Point3(0.0, 5.0, -0.1));
		spineKnots[0] = 0;
		spineKnots[1] = 1.0 / 3.0;
		spineKnots[2] = 2.0 / 3.0;
		spineKnots[3] = 1;
		spineMults.front() = 4;
		spineMults.back() = 4;
		std::shared_ptr<Geom3BSplineCurve> spineCurve = std::make_shared<Geom3BSplineCurve>(spinePoles, spineKnots, spineMults, 3);
		TopoWire profile = MakeWire(MakeEdge(profileCurve)).Wire();
		TopoWire spine = MakeWire(MakeEdge(spineCurve)).Wire();
		MakePipeShell pipeShell(spine);
		pipeShell.Add(profile);
		pipeShell.SetMode(Frame3());
		TopoShape pipe = pipeShell.Shape();
		TopoExplorer ex(pipe, ShapeType::Face);
		TopoFace inputBasicFace = static_cast<const TopoFace&>(ex.Current());
		auto surf = TopoTool::Surface(inputBasicFace);
		bspSurf = NURBSAPIConvert::ToBSpline(surf);
		break;
	}
	case 1:
	{
		Array2<Point3> poles(2, 5);
		poles(0, 0) = Point3(0.0, 0.0, 0.0);
		poles(0, 1) = Point3(1.0, -0.2, 0.1);
		poles(0, 2) = Point3(2.0, 0.1, -0.1);
		poles(0, 3) = Point3(3.0, -0.1, 0.0);
		poles(0, 4) = Point3(4.0, 0.1, 0.2);
		poles(1, 0) = Point3(0.0, 1.0, -0.1);
		poles(1, 1) = Point3(1.0, 0.8, 0.0);
		poles(1, 2) = Point3(2.0, 1.1, -0.2);
		poles(1, 3) = Point3(3.0, 0.9, -0.1);
		poles(1, 4) = Point3(4.0, 1.1, 0.1);
		std::vector<double> vKnots(3);
		std::vector<int> vMults(3, 1);
		vKnots[0] = 0;
		vKnots[1] = 0.5;
		vKnots[2] = 1;
		vMults.front() = 4;
		vMults.back() = 4;
		std::vector<double> uKnots(2);
		std::vector<int> uMults(2, 1);
		uKnots[0] = 0;
		uKnots[1] = 1;
		uMults.front() = 2;
		uMults.back() = 2;
		bspSurf = std::make_shared<Geom3BSplineSurface>(poles, uKnots, vKnots, uMults, vMults, 1, 3);
		Transformation3 trsf;
		trsf.SetTranslationPart(Vector3(0.0, -6.0, 0.0));
		bspSurf->Transform(trsf);
		break;
	}
	case 2:
	{
		std::vector<Point3> profilePoles;
		std::vector<double> profileKnots(4);
		std::vector<int> profileMults(4, 1);
		profilePoles.push_back(Point3(0.0, 0.0, 0.0));
		profilePoles.push_back(Point3(1.0, -2.0, -3.0));
		profilePoles.push_back(Point3(2.0, 1.0, 2.0));
		profilePoles.push_back(Point3(3.0, -1.0, -1.0));
		profilePoles.push_back(Point3(4.0, -3.0, 3.0));
		profilePoles.push_back(Point3(5.0, 0.0, 1.0));
		profileKnots[0] = 0;
		profileKnots[1] = 1.0 / 3.0;
		profileKnots[2] = 2.0 / 3.0;
		profileKnots[3] = 1;
		profileMults.front() = 4;
		profileMults.back() = 4;
		std::shared_ptr<Geom3BSplineCurve> profileCurve = std::make_shared<Geom3BSplineCurve>(profilePoles, profileKnots, profileMults, 3);
		std::vector<Point3> spinePoles;
		std::vector<double> spineKnots(4);
		std::vector<int> spineMults(4, 1);
		spinePoles.push_back(Point3(0.0, 0.0, 0.0));
		spinePoles.push_back(Point3(-0.1, 1.0, -1.0));
		spinePoles.push_back(Point3(0.1, -2.0, -2.0));
		spinePoles.push_back(Point3(0.2, -3.0, -3.0));
		spinePoles.push_back(Point3(0.1, -4.0, -4.0));
		spinePoles.push_back(Point3(0.0, -2.5, -5.0));
		spinePoles.push_back(Point3(0.1, -1.0, -6.0));
		spinePoles.push_back(Point3(0.0, 0.0, -7.0));
		spineKnots[0] = 0;
		spineKnots[1] = 1.0 / 3.0;
		spineKnots[2] = 2.0 / 3.0;
		spineKnots[3] = 1;
		spineMults.front() = 6;
		spineMults.back() = 6;
		shared_ptr<Geom3BSplineCurve> spineCurve = std::make_shared<Geom3BSplineCurve>(spinePoles, spineKnots, spineMults, 5);
		TopoWire profile = MakeWire(MakeEdge(profileCurve)).Wire();
		TopoWire spine = MakeWire(MakeEdge(spineCurve)).Wire();
		MakePipeShell pipeShell(spine);
		pipeShell.Add(profile);
		pipeShell.SetMode(Frame3());
		TopoShape pipe = pipeShell.Shape();
		TopoExplorer ex(pipe, ShapeType::Face);
		TopoFace inputBasicFace = static_cast<const TopoFace&>(ex.Current());
		shared_ptr<Geom3Surface> surf = TopoTool::Surface(inputBasicFace);
		shared_ptr<Geom3BSplineSurface>  bspSurf = NURBSAPIConvert::ToBSpline(surf);
		Transformation3 trsf;
		trsf.SetTranslationPart(Vector3(-6.0, 0.0, 0.0));
		bspSurf->Transform(trsf);
		break;
	}
	}
	return bspSurf;
}
#include<catch.hpp>
#include<testHelper.h>
#include <nurbs/NURBSAPIMatch.hpp>
#include <topology/TopoEdge.hpp>
#include <topology/TopoTool.hpp>
#include <nurbs/NURBSAPISweep.hpp>
#include <nurbs/NURBSAPIRebuild.hpp>
#include <modeling/MakeWire.hpp>
#include <modeling/MakeEdge.hpp>
#include <offset/MakePipeShell.hpp>
#include <geometry/Geom3BSplineSurface.hpp>
#include <topology/TopoVertex.hpp>
#include <topomesh/BRepMeshIncrementalMesh.hpp>
#include <geometry/GeomAPIProjectPointOnCurve3.hpp>
#include <modeling/TransformShape.hpp>
#include <nurbs/NURBSAPIMatch.hpp>
#include <modeling/MakeFace.hpp>
#include <nurbs/NURBSAPIConvert.hpp>
#include <topology/TopoExplorerTool.hpp>
#include <modeling/MakeVertex.hpp>
using namespace AMCAX;
std::shared_ptr<Geom3BSplineSurface> GenerateTestSurface11(const int id)
{
	std::shared_ptr<Geom3BSplineSurface> bspSurf;
	switch (id)
	{
	case 0:
	{
		std::vector<Point3> profilePoles;
		std::vector<double> profileKnots(3);
		std::vector<int> profileMults(3, 1);
		profilePoles.push_back(Point3(0.0, 0.0, 0.0));
		profilePoles.push_back(Point3(1.0, -0.2, 0.1));
		profilePoles.push_back(Point3(2.0, 0.1, -0.1));
		profilePoles.push_back(Point3(3.0, -0.1, 0.0));
		profilePoles.push_back(Point3(4.0, 0.1, 0.2));
		profileKnots[0] = 0;
		profileKnots[1] = 0.5;
		profileKnots[2] = 1;
		profileMults.front() = 4;
		profileMults.back() = 4;
		std::shared_ptr<Geom3BSplineCurve> profileCurve = std::make_shared<Geom3BSplineCurve>(profilePoles, profileKnots, profileMults, 3);
		std::vector<Point3> spinePoles;
		std::vector<double> spineKnots(4);
		std::vector<int> spineMults(4, 1);
		spinePoles.push_back(Point3(0.0, 0.0, 0.0));
		spinePoles.push_back(Point3(-0.1, 1.0, -0.2));
		spinePoles.push_back(Point3(0.1, 2.0, -0.1));
		spinePoles.push_back(Point3(0.2, 3.0, 0.1));
		spinePoles.push_back(Point3(0.1, 4.0, 0.0));
		spinePoles.push_back(Point3(0.0, 5.0, -0.1));
		spineKnots[0] = 0;
		spineKnots[1] = 1.0 / 3.0;
		spineKnots[2] = 2.0 / 3.0;
		spineKnots[3] = 1;
		spineMults.front() = 4;
		spineMults.back() = 4;
		std::shared_ptr<Geom3BSplineCurve> spineCurve = std::make_shared<Geom3BSplineCurve>(spinePoles, spineKnots, spineMults, 3);
		TopoWire profile = MakeWire(MakeEdge(profileCurve)).Wire();
		TopoWire spine = MakeWire(MakeEdge(spineCurve)).Wire();
		MakePipeShell pipeShell(spine);
		pipeShell.Add(profile);
		pipeShell.SetMode(Frame3());
		TopoShape pipe = pipeShell.Shape();
		TopoExplorer ex(pipe, ShapeType::Face);
		TopoFace inputBasicFace = static_cast<const TopoFace&>(ex.Current());
		auto surf = TopoTool::Surface(inputBasicFace);
		bspSurf = NURBSAPIConvert::ToBSpline(surf);
		break;
	}
	case 1:
	{
		Array2<Point3> poles(2, 5);
		poles(0, 0) = Point3(0.0, 0.0, 0.0);
		poles(0, 1) = Point3(1.0, -0.2, 0.1);
		poles(0, 2) = Point3(2.0, 0.1, -0.1);
		poles(0, 3) = Point3(3.0, -0.1, 0.0);
		poles(0, 4) = Point3(4.0, 0.1, 0.2);
		poles(1, 0) = Point3(0.0, 1.0, -0.1);
		poles(1, 1) = Point3(1.0, 0.8, 0.0);
		poles(1, 2) = Point3(2.0, 1.1, -0.2);
		poles(1, 3) = Point3(3.0, 0.9, -0.1);
		poles(1, 4) = Point3(4.0, 1.1, 0.1);
		std::vector<double> vKnots(3);
		std::vector<int> vMults(3, 1);
		vKnots[0] = 0;
		vKnots[1] = 0.5;
		vKnots[2] = 1;
		vMults.front() = 4;
		vMults.back() = 4;
		std::vector<double> uKnots(2);
		std::vector<int> uMults(2, 1);
		uKnots[0] = 0;
		uKnots[1] = 1;
		uMults.front() = 2;
		uMults.back() = 2;
		bspSurf = std::make_shared<Geom3BSplineSurface>(poles, uKnots, vKnots, uMults, vMults, 1, 3);
		Transformation3 trsf;
		trsf.SetTranslationPart(Vector3(0.0, -6.0, 0.0));
		bspSurf->Transform(trsf);
		break;
	}
	case 2:
	{
		std::vector<Point3> profilePoles;
		std::vector<double> profileKnots(4);
		std::vector<int> profileMults(4, 1);
		profilePoles.push_back(Point3(0.0, 0.0, 0.0));
		profilePoles.push_back(Point3(1.0, -2.0, -3.0));
		profilePoles.push_back(Point3(2.0, 1.0, 2.0));
		profilePoles.push_back(Point3(3.0, -1.0, -1.0));
		profilePoles.push_back(Point3(4.0, -3.0, 3.0));
		profilePoles.push_back(Point3(5.0, 0.0, 1.0));
		profileKnots[0] = 0;
		profileKnots[1] = 1.0 / 3.0;
		profileKnots[2] = 2.0 / 3.0;
		profileKnots[3] = 1;
		profileMults.front() = 4;
		profileMults.back() = 4;
		std::shared_ptr<Geom3BSplineCurve> profileCurve = std::make_shared<Geom3BSplineCurve>(profilePoles, profileKnots, profileMults, 3);
		std::vector<Point3> spinePoles;
		std::vector<double> spineKnots(4);
		std::vector<int> spineMults(4, 1);
		spinePoles.push_back(Point3(0.0, 0.0, 0.0));
		spinePoles.push_back(Point3(-0.1, 1.0, -1.0));
		spinePoles.push_back(Point3(0.1, -2.0, -2.0));
		spinePoles.push_back(Point3(0.2, -3.0, -3.0));
		spinePoles.push_back(Point3(0.1, -4.0, -4.0));
		spinePoles.push_back(Point3(0.0, -2.5, -5.0));
		spinePoles.push_back(Point3(0.1, -1.0, -6.0));
		spinePoles.push_back(Point3(0.0, 0.0, -7.0));
		spineKnots[0] = 0;
		spineKnots[1] = 1.0 / 3.0;
		spineKnots[2] = 2.0 / 3.0;
		spineKnots[3] = 1;
		spineMults.front() = 6;
		spineMults.back() = 6;
		shared_ptr<Geom3BSplineCurve> spineCurve = std::make_shared<Geom3BSplineCurve>(spinePoles, spineKnots, spineMults, 5);
		TopoWire profile = MakeWire(MakeEdge(profileCurve)).Wire();
		TopoWire spine = MakeWire(MakeEdge(spineCurve)).Wire();
		MakePipeShell pipeShell(spine);
		pipeShell.Add(profile);
		pipeShell.SetMode(Frame3());
		TopoShape pipe = pipeShell.Shape();
		TopoExplorer ex(pipe, ShapeType::Face);
		TopoFace inputBasicFace = static_cast<const TopoFace&>(ex.Current());
		shared_ptr<Geom3Surface> surf = TopoTool::Surface(inputBasicFace);
		shared_ptr<Geom3BSplineSurface>  bspSurf = NURBSAPIConvert::ToBSpline(surf);
		Transformation3 trsf;
		trsf.SetTranslationPart(Vector3(-6.0, 0.0, 0.0));
		bspSurf->Transform(trsf);
		break;
	}
	}
	return bspSurf;
;
	SECTION("MatchSurf1")
	{
		OUTPUT_DIRECTORY(nurbs, Match/bug777/MatchSurf/MatchSurf1);
		string filedir = INPUT_PATH_PREFIX"./TestNURBS/TestMatchSurf/";
		shared_ptr<Geom3BSplineSurface> surface1 = ReadBRepSurface(filedir + "surface1.brep");
		shared_ptr<Geom3BSplineSurface> surface2 = ReadBRepSurface(filedir + "surface2.brep");
		bool isU1 = false, isFront1 = false, isU2 = false, isFront2 = true;
		ContinuityType cont = ContinuityType::G2; 
		int otherEndCont = 0;					  
		bool isAutoReverse = true;
		bool isPrecise = true;
		vector<double> tol;
		tol.push_back(0.001);
		tol.push_back(M_PI / 180.0);
		tol.push_back(0.0005);
		bool isEachOther = false;
		NURBSMatchSurfConfig config;
		config.isOrientationFixed = !isAutoReverse;
		vector<double> params;
		auto oldbspSurf3 = NURBSAPIMatch::MatchSurf(surface2, isU2, isFront2, surface1, isU1, isFront1, cont, otherEndCont, isPrecise, tol, params, isEachOther, config, config);
		for (const auto& s : oldbspSurf3)
		{
			OCCTIO::OCCTTool::Write(MakeFace(s, 0.0), outdir + "result.brep");
		}
		int refDeg = 11;
		shared_ptr<Geom3BSplineSurface> surface1Inc = std::dynamic_pointer_cast<Geom3BSplineSurface>(surface1->Copy());
		surface1Inc->IncreaseDegree(refDeg, refDeg);
		shared_ptr<Geom3BSplineSurface> surface2Inc = std::dynamic_pointer_cast<Geom3BSplineSurface>(surface2->Copy());
		surface2Inc->IncreaseDegree(refDeg, refDeg);
		auto bspSurf3 = NURBSAPIMatch::MatchSurf(surface2Inc, isU2, isFront2, surface1Inc, isU1, isFront1, cont, otherEndCont, isPrecise, tol, params, isEachOther, config, config);
		CHECK(surface1Inc->UDegree() == refDeg);
		CHECK(surface1Inc->VDegree() == refDeg);
		CHECK(surface2Inc->UDegree() == refDeg);
		CHECK(surface2Inc->VDegree() == refDeg);
		CHECK(bspSurf3[0]->UDegree() == refDeg);
		CHECK(bspSurf3[0]->VDegree() == refDeg);
		double f1 = surface1->LastVParameter();
		double f2 = surface2->LastVParameter();
		double f3 = bspSurf3[0]->FirstVParameter();
		double f4 = bspSurf3[0]->LastVParameter();
		shared_ptr<Geom3Curve> fu11 = surface1->VIso(f1);
		shared_ptr<Geom3Curve> fu22 = surface2->VIso(f2);
		shared_ptr<Geom3Curve> fu33 = bspSurf3[0]->VIso(f3);
		shared_ptr<Geom3Curve> fu44 = bspSurf3[0]->VIso(f4);
		double resTol = 1e-3;
		double res1 = NurbsSampleCurve(num, resTol, fu33, fu11);
		double res2 = NurbsSampleCurve(num, resTol, fu44, fu22);
		CHECK(res1 <= ratio);
		CHECK(res2 <= ratio);
		OCCTIO::OCCTTool::Write(MakeEdge(fu11), outdir + "fu11.brep");
		OCCTIO::OCCTTool::Write(MakeEdge(fu22), outdir + "fu22.brep");
		OCCTIO::OCCTTool::Write(MakeEdge(fu33), outdir + "fu33.brep");
		OCCTIO::OCCTTool::Write(MakeEdge(fu44), outdir + "fu44.brep");
		OCCTIO::OCCTTool::Write(MakeFace(surface1, 0.0), outdir + "surface1.brep");
		OCCTIO::OCCTTool::Write(MakeFace(surface2, 0.0), outdir + "surface2.brep");
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static std::vector<std::shared_ptr<Geom3BSplineSurface>> MatchSurf( const std::shared_ptr<Geom3BSplineSurface> surf, bool isModifyU, bool isFront, const std::shared_ptr<Geom3BSplineSurface>& targetSurf, bool isTargetU, bool isTargetFront, ContinuityType connectCont, int otherEndCont, bool isPrecise, const std::vector<double>& tol, std::vector<double>& params, bool isEachOther, const NURBSMatchSurfConfig& surfConfig, const NURBSMatchSurfConfig& targetSurfConfig),
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <nurbs/NURBSAPIMatch.hpp>
#include <topology/TopoEdge.hpp>
#include <topology/TopoTool.hpp>
#include <nurbs/NURBSAPISweep.hpp>
#include <nurbs/NURBSAPIRebuild.hpp>
#include <modeling/MakeWire.hpp>
#include <modeling/MakeEdge.hpp>
#include <offset/MakePipeShell.hpp>
#include <geometry/Geom3BSplineSurface.hpp>
#include <topology/TopoVertex.hpp>
#include <topomesh/BRepMeshIncrementalMesh.hpp>
#include <geometry/GeomAPIProjectPointOnCurve3.hpp>
#include <modeling/TransformShape.hpp>
#include <nurbs/NURBSAPIMatch.hpp>
#include <modeling/MakeFace.hpp>
#include <nurbs/NURBSAPIConvert.hpp>
#include <topology/TopoExplorerTool.hpp>
#include <modeling/MakeVertex.hpp>
using namespace AMCAX;
std::shared_ptr<Geom3BSplineSurface> GenerateTestSurface11(const int id)
{
	std::shared_ptr<Geom3BSplineSurface> bspSurf;
	switch (id)
	{
	case 0:
	{
		std::vector<Point3> profilePoles;
		std::vector<double> profileKnots(3);
		std::vector<int> profileMults(3, 1);
		profilePoles.push_back(Point3(0.0, 0.0, 0.0));
		profilePoles.push_back(Point3(1.0, -0.2, 0.1));
		profilePoles.push_back(Point3(2.0, 0.1, -0.1));
		profilePoles.push_back(Point3(3.0, -0.1, 0.0));
		profilePoles.push_back(Point3(4.0, 0.1, 0.2));
		profileKnots[0] = 0;
		profileKnots[1] = 0.5;
		profileKnots[2] = 1;
		profileMults.front() = 4;
		profileMults.back() = 4;
		std::shared_ptr<Geom3BSplineCurve> profileCurve = std::make_shared<Geom3BSplineCurve>(profilePoles, profileKnots, profileMults, 3);
		std::vector<Point3> spinePoles;
		std::vector<double> spineKnots(4);
		std::vector<int> spineMults(4, 1);
		spinePoles.push_back(Point3(0.0, 0.0, 0.0));
		spinePoles.push_back(Point3(-0.1, 1.0, -0.2));
		spinePoles.push_back(Point3(0.1, 2.0, -0.1));
		spinePoles.push_back(Point3(0.2, 3.0, 0.1));
		spinePoles.push_back(Point3(0.1, 4.0, 0.0));
		spinePoles.push_back(Point3(0.0, 5.0, -0.1));
		spineKnots[0] = 0;
		spineKnots[1] = 1.0 / 3.0;
		spineKnots[2] = 2.0 / 3.0;
		spineKnots[3] = 1;
		spineMults.front() = 4;
		spineMults.back() = 4;
		std::shared_ptr<Geom3BSplineCurve> spineCurve = std::make_shared<Geom3BSplineCurve>(spinePoles, spineKnots, spineMults, 3);
		TopoWire profile = MakeWire(MakeEdge(profileCurve)).Wire();
		TopoWire spine = MakeWire(MakeEdge(spineCurve)).Wire();
		MakePipeShell pipeShell(spine);
		pipeShell.Add(profile);
		pipeShell.SetMode(Frame3());
		TopoShape pipe = pipeShell.Shape();
		TopoExplorer ex(pipe, ShapeType::Face);
		TopoFace inputBasicFace = static_cast<const TopoFace&>(ex.Current());
		auto surf = TopoTool::Surface(inputBasicFace);
		bspSurf = NURBSAPIConvert::ToBSpline(surf);
		break;
	}
	case 1:
	{
		Array2<Point3> poles(2, 5);
		poles(0, 0) = Point3(0.0, 0.0, 0.0);
		poles(0, 1) = Point3(1.0, -0.2, 0.1);
		poles(0, 2) = Point3(2.0, 0.1, -0.1);
		poles(0, 3) = Point3(3.0, -0.1, 0.0);
		poles(0, 4) = Point3(4.0, 0.1, 0.2);
		poles(1, 0) = Point3(0.0, 1.0, -0.1);
		poles(1, 1) = Point3(1.0, 0.8, 0.0);
		poles(1, 2) = Point3(2.0, 1.1, -0.2);
		poles(1, 3) = Point3(3.0, 0.9, -0.1);
		poles(1, 4) = Point3(4.0, 1.1, 0.1);
		std::vector<double> vKnots(3);
		std::vector<int> vMults(3, 1);
		vKnots[0] = 0;
		vKnots[1] = 0.5;
		vKnots[2] = 1;
		vMults.front() = 4;
		vMults.back() = 4;
		std::vector<double> uKnots(2);
		std::vector<int> uMults(2, 1);
		uKnots[0] = 0;
		uKnots[1] = 1;
		uMults.front() = 2;
		uMults.back() = 2;
		bspSurf = std::make_shared<Geom3BSplineSurface>(poles, uKnots, vKnots, uMults, vMults, 1, 3);
		Transformation3 trsf;
		trsf.SetTranslationPart(Vector3(0.0, -6.0, 0.0));
		bspSurf->Transform(trsf);
		break;
	}
	case 2:
	{
		std::vector<Point3> profilePoles;
		std::vector<double> profileKnots(4);
		std::vector<int> profileMults(4, 1);
		profilePoles.push_back(Point3(0.0, 0.0, 0.0));
		profilePoles.push_back(Point3(1.0, -2.0, -3.0));
		profilePoles.push_back(Point3(2.0, 1.0, 2.0));
		profilePoles.push_back(Point3(3.0, -1.0, -1.0));
		profilePoles.push_back(Point3(4.0, -3.0, 3.0));
		profilePoles.push_back(Point3(5.0, 0.0, 1.0));
		profileKnots[0] = 0;
		profileKnots[1] = 1.0 / 3.0;
		profileKnots[2] = 2.0 / 3.0;
		profileKnots[3] = 1;
		profileMults.front() = 4;
		profileMults.back() = 4;
		std::shared_ptr<Geom3BSplineCurve> profileCurve = std::make_shared<Geom3BSplineCurve>(profilePoles, profileKnots, profileMults, 3);
		std::vector<Point3> spinePoles;
		std::vector<double> spineKnots(4);
		std::vector<int> spineMults(4, 1);
		spinePoles.push_back(Point3(0.0, 0.0, 0.0));
		spinePoles.push_back(Point3(-0.1, 1.0, -1.0));
		spinePoles.push_back(Point3(0.1, -2.0, -2.0));
		spinePoles.push_back(Point3(0.2, -3.0, -3.0));
		spinePoles.push_back(Point3(0.1, -4.0, -4.0));
		spinePoles.push_back(Point3(0.0, -2.5, -5.0));
		spinePoles.push_back(Point3(0.1, -1.0, -6.0));
		spinePoles.push_back(Point3(0.0, 0.0, -7.0));
		spineKnots[0] = 0;
		spineKnots[1] = 1.0 / 3.0;
		spineKnots[2] = 2.0 / 3.0;
		spineKnots[3] = 1;
		spineMults.front() = 6;
		spineMults.back() = 6;
		shared_ptr<Geom3BSplineCurve> spineCurve = std::make_shared<Geom3BSplineCurve>(spinePoles, spineKnots, spineMults, 5);
		TopoWire profile = MakeWire(MakeEdge(profileCurve)).Wire();
		TopoWire spine = MakeWire(MakeEdge(spineCurve)).Wire();
		MakePipeShell pipeShell(spine);
		pipeShell.Add(profile);
		pipeShell.SetMode(Frame3());
		TopoShape pipe = pipeShell.Shape();
		TopoExplorer ex(pipe, ShapeType::Face);
		TopoFace inputBasicFace = static_cast<const TopoFace&>(ex.Current());
		shared_ptr<Geom3Surface> surf = TopoTool::Surface(inputBasicFace);
		shared_ptr<Geom3BSplineSurface>  bspSurf = NURBSAPIConvert::ToBSpline(surf);
		Transformation3 trsf;
		trsf.SetTranslationPart(Vector3(-6.0, 0.0, 0.0));
		bspSurf->Transform(trsf);
		break;
	}
	}
	return bspSurf;
}
#include<catch.hpp>
#include<testHelper.h>
#include <nurbs/NURBSAPIMatch.hpp>
#include <topology/TopoEdge.hpp>
#include <topology/TopoTool.hpp>
#include <nurbs/NURBSAPISweep.hpp>
#include <nurbs/NURBSAPIRebuild.hpp>
#include <modeling/MakeWire.hpp>
#include <modeling/MakeEdge.hpp>
#include <offset/MakePipeShell.hpp>
#include <geometry/Geom3BSplineSurface.hpp>
#include <topology/TopoVertex.hpp>
#include <topomesh/BRepMeshIncrementalMesh.hpp>
#include <geometry/GeomAPIProjectPointOnCurve3.hpp>
#include <modeling/TransformShape.hpp>
#include <nurbs/NURBSAPIMatch.hpp>
#include <modeling/MakeFace.hpp>
#include <nurbs/NURBSAPIConvert.hpp>
#include <topology/TopoExplorerTool.hpp>
#include <modeling/MakeVertex.hpp>
using namespace AMCAX;
std::shared_ptr<Geom3BSplineSurface> GenerateTestSurface11(const int id)
{
	std::shared_ptr<Geom3BSplineSurface> bspSurf;
	switch (id)
	{
	case 0:
	{
		std::vector<Point3> profilePoles;
		std::vector<double> profileKnots(3);
		std::vector<int> profileMults(3, 1);
		profilePoles.push_back(Point3(0.0, 0.0, 0.0));
		profilePoles.push_back(Point3(1.0, -0.2, 0.1));
		profilePoles.push_back(Point3(2.0, 0.1, -0.1));
		profilePoles.push_back(Point3(3.0, -0.1, 0.0));
		profilePoles.push_back(Point3(4.0, 0.1, 0.2));
		profileKnots[0] = 0;
		profileKnots[1] = 0.5;
		profileKnots[2] = 1;
		profileMults.front() = 4;
		profileMults.back() = 4;
		std::shared_ptr<Geom3BSplineCurve> profileCurve = std::make_shared<Geom3BSplineCurve>(profilePoles, profileKnots, profileMults, 3);
		std::vector<Point3> spinePoles;
		std::vector<double> spineKnots(4);
		std::vector<int> spineMults(4, 1);
		spinePoles.push_back(Point3(0.0, 0.0, 0.0));
		spinePoles.push_back(Point3(-0.1, 1.0, -0.2));
		spinePoles.push_back(Point3(0.1, 2.0, -0.1));
		spinePoles.push_back(Point3(0.2, 3.0, 0.1));
		spinePoles.push_back(Point3(0.1, 4.0, 0.0));
		spinePoles.push_back(Point3(0.0, 5.0, -0.1));
		spineKnots[0] = 0;
		spineKnots[1] = 1.0 / 3.0;
		spineKnots[2] = 2.0 / 3.0;
		spineKnots[3] = 1;
		spineMults.front() = 4;
		spineMults.back() = 4;
		std::shared_ptr<Geom3BSplineCurve> spineCurve = std::make_shared<Geom3BSplineCurve>(spinePoles, spineKnots, spineMults, 3);
		TopoWire profile = MakeWire(MakeEdge(profileCurve)).Wire();
		TopoWire spine = MakeWire(MakeEdge(spineCurve)).Wire();
		MakePipeShell pipeShell(spine);
		pipeShell.Add(profile);
		pipeShell.SetMode(Frame3());
		TopoShape pipe = pipeShell.Shape();
		TopoExplorer ex(pipe, ShapeType::Face);
		TopoFace inputBasicFace = static_cast<const TopoFace&>(ex.Current());
		auto surf = TopoTool::Surface(inputBasicFace);
		bspSurf = NURBSAPIConvert::ToBSpline(surf);
		break;
	}
	case 1:
	{
		Array2<Point3> poles(2, 5);
		poles(0, 0) = Point3(0.0, 0.0, 0.0);
		poles(0, 1) = Point3(1.0, -0.2, 0.1);
		poles(0, 2) = Point3(2.0, 0.1, -0.1);
		poles(0, 3) = Point3(3.0, -0.1, 0.0);
		poles(0, 4) = Point3(4.0, 0.1, 0.2);
		poles(1, 0) = Point3(0.0, 1.0, -0.1);
		poles(1, 1) = Point3(1.0, 0.8, 0.0);
		poles(1, 2) = Point3(2.0, 1.1, -0.2);
		poles(1, 3) = Point3(3.0, 0.9, -0.1);
		poles(1, 4) = Point3(4.0, 1.1, 0.1);
		std::vector<double> vKnots(3);
		std::vector<int> vMults(3, 1);
		vKnots[0] = 0;
		vKnots[1] = 0.5;
		vKnots[2] = 1;
		vMults.front() = 4;
		vMults.back() = 4;
		std::vector<double> uKnots(2);
		std::vector<int> uMults(2, 1);
		uKnots[0] = 0;
		uKnots[1] = 1;
		uMults.front() = 2;
		uMults.back() = 2;
		bspSurf = std::make_shared<Geom3BSplineSurface>(poles, uKnots, vKnots, uMults, vMults, 1, 3);
		Transformation3 trsf;
		trsf.SetTranslationPart(Vector3(0.0, -6.0, 0.0));
		bspSurf->Transform(trsf);
		break;
	}
	case 2:
	{
		std::vector<Point3> profilePoles;
		std::vector<double> profileKnots(4);
		std::vector<int> profileMults(4, 1);
		profilePoles.push_back(Point3(0.0, 0.0, 0.0));
		profilePoles.push_back(Point3(1.0, -2.0, -3.0));
		profilePoles.push_back(Point3(2.0, 1.0, 2.0));
		profilePoles.push_back(Point3(3.0, -1.0, -1.0));
		profilePoles.push_back(Point3(4.0, -3.0, 3.0));
		profilePoles.push_back(Point3(5.0, 0.0, 1.0));
		profileKnots[0] = 0;
		profileKnots[1] = 1.0 / 3.0;
		profileKnots[2] = 2.0 / 3.0;
		profileKnots[3] = 1;
		profileMults.front() = 4;
		profileMults.back() = 4;
		std::shared_ptr<Geom3BSplineCurve> profileCurve = std::make_shared<Geom3BSplineCurve>(profilePoles, profileKnots, profileMults, 3);
		std::vector<Point3> spinePoles;
		std::vector<double> spineKnots(4);
		std::vector<int> spineMults(4, 1);
		spinePoles.push_back(Point3(0.0, 0.0, 0.0));
		spinePoles.push_back(Point3(-0.1, 1.0, -1.0));
		spinePoles.push_back(Point3(0.1, -2.0, -2.0));
		spinePoles.push_back(Point3(0.2, -3.0, -3.0));
		spinePoles.push_back(Point3(0.1, -4.0, -4.0));
		spinePoles.push_back(Point3(0.0, -2.5, -5.0));
		spinePoles.push_back(Point3(0.1, -1.0, -6.0));
		spinePoles.push_back(Point3(0.0, 0.0, -7.0));
		spineKnots[0] = 0;
		spineKnots[1] = 1.0 / 3.0;
		spineKnots[2] = 2.0 / 3.0;
		spineKnots[3] = 1;
		spineMults.front() = 6;
		spineMults.back() = 6;
		shared_ptr<Geom3BSplineCurve> spineCurve = std::make_shared<Geom3BSplineCurve>(spinePoles, spineKnots, spineMults, 5);
		TopoWire profile = MakeWire(MakeEdge(profileCurve)).Wire();
		TopoWire spine = MakeWire(MakeEdge(spineCurve)).Wire();
		MakePipeShell pipeShell(spine);
		pipeShell.Add(profile);
		pipeShell.SetMode(Frame3());
		TopoShape pipe = pipeShell.Shape();
		TopoExplorer ex(pipe, ShapeType::Face);
		TopoFace inputBasicFace = static_cast<const TopoFace&>(ex.Current());
		shared_ptr<Geom3Surface> surf = TopoTool::Surface(inputBasicFace);
		shared_ptr<Geom3BSplineSurface>  bspSurf = NURBSAPIConvert::ToBSpline(surf);
		Transformation3 trsf;
		trsf.SetTranslationPart(Vector3(-6.0, 0.0, 0.0));
		bspSurf->Transform(trsf);
		break;
	}
	}
	return bspSurf;
;
	SECTION("MatchSurf1")
	 {
		 OUTPUT_DIRECTORY(nurbs, Match/MatchSurf/MatchSurf1);
		 string filedir = INPUT_PATH_PREFIX"./TestNURBS/TestMatchSurf/";
		 shared_ptr<Geom3BSplineSurface> surface1 = ReadBRepSurface(filedir + "surface1.brep");
		 shared_ptr<Geom3BSplineSurface> surface2 = ReadBRepSurface(filedir + "surface2.brep");
		 bool isU1 = false, isFront1 = false, isU2 = false, isFront2 = true;
		 ContinuityType cont = ContinuityType::G2; 
		 int otherEndCont = 0;					  
		 bool isAutoReverse = true;
		 bool isPrecise = true;
		 vector<double> tol;
		 tol.push_back(0.001);
		 tol.push_back(M_PI / 180.0);
		 tol.push_back(0.0005);
		 bool isEachOther = false;
		 NURBSMatchSurfConfig config;
		 config.isOrientationFixed = !isAutoReverse;
		 vector<double> params;
		 auto bspSurf3 = NURBSAPIMatch::MatchSurf(surface2, isU2, isFront2, surface1, isU1, isFront1, cont, otherEndCont, isPrecise, tol, params, isEachOther, config, config);
		 for (const auto& s : bspSurf3)
		 {
			 OCCTIO::OCCTTool::Write(MakeFace(s, 0.0), outdir + "result.brep");
		 }
		 double f1 = surface1->LastVParameter();
		 double f2 = surface2->LastVParameter();
		 double f3 = bspSurf3[0]->FirstVParameter();
		 double f4 = bspSurf3[0]->LastVParameter();
		 shared_ptr<Geom3Curve> fu1 = surface1->VIso(f1);
		 shared_ptr<Geom3Curve> fu2 = surface2->VIso(f2);
		 shared_ptr<Geom3Curve> fu3 = bspSurf3[0]->VIso(f3);
		 shared_ptr<Geom3Curve> fu4 = bspSurf3[0]->VIso(f4);
		 int num = 1000;
		 double resTol = 1e-3;
		 double ratio = 0.1;
		 double res1 = NurbsSampleCurve(num, resTol, fu3, fu1);
		 double res2 = NurbsSampleCurve(num, resTol, fu4, fu2);
		 CHECK(res1 <= ratio);
		 CHECK(res2 <= ratio);
		 OCCTIO::OCCTTool::Write(MakeEdge(fu1), outdir + "fu1.brep");
		 OCCTIO::OCCTTool::Write(MakeEdge(fu2), outdir + "fu2.brep");
		 OCCTIO::OCCTTool::Write(MakeEdge(fu3), outdir + "fu3.brep");
		 OCCTIO::OCCTTool::Write(MakeEdge(fu4), outdir + "fu4.brep");
		 OCCTIO::OCCTTool::Write(MakeFace(surface1, 0.0), outdir + "surface1.brep");
		 OCCTIO::OCCTTool::Write(MakeFace(surface2, 0.0), outdir + "surface2.brep");
	 }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static std::vector<TopoFace> MatchFace( const TopoFace& face1, const TopoEdge& edge1, const TopoFace& face2, const TopoEdge& edge2, ContinuityType connectCont, int otherEndCont, bool isPrecise, const std::vector<double>& tol, std::vector<double>& params, bool isEachOther, const NURBSMatchSurfConfig& surf1Config, const NURBSMatchSurfConfig& surf2Config),
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <nurbs/NURBSAPIMatch.hpp>
#include <topology/TopoEdge.hpp>
#include <topology/TopoTool.hpp>
#include <nurbs/NURBSAPISweep.hpp>
#include <nurbs/NURBSAPIRebuild.hpp>
#include <modeling/MakeWire.hpp>
#include <modeling/MakeEdge.hpp>
#include <offset/MakePipeShell.hpp>
#include <geometry/Geom3BSplineSurface.hpp>
#include <topology/TopoVertex.hpp>
#include <topomesh/BRepMeshIncrementalMesh.hpp>
#include <geometry/GeomAPIProjectPointOnCurve3.hpp>
#include <modeling/TransformShape.hpp>
#include <nurbs/NURBSAPIMatch.hpp>
#include <modeling/MakeFace.hpp>
#include <nurbs/NURBSAPIConvert.hpp>
#include <topology/TopoExplorerTool.hpp>
#include <modeling/MakeVertex.hpp>
using namespace AMCAX;
std::shared_ptr<Geom3BSplineSurface> GenerateTestSurface11(const int id)
{
	std::shared_ptr<Geom3BSplineSurface> bspSurf;
	switch (id)
	{
	case 0:
	{
		std::vector<Point3> profilePoles;
		std::vector<double> profileKnots(3);
		std::vector<int> profileMults(3, 1);
		profilePoles.push_back(Point3(0.0, 0.0, 0.0));
		profilePoles.push_back(Point3(1.0, -0.2, 0.1));
		profilePoles.push_back(Point3(2.0, 0.1, -0.1));
		profilePoles.push_back(Point3(3.0, -0.1, 0.0));
		profilePoles.push_back(Point3(4.0, 0.1, 0.2));
		profileKnots[0] = 0;
		profileKnots[1] = 0.5;
		profileKnots[2] = 1;
		profileMults.front() = 4;
		profileMults.back() = 4;
		std::shared_ptr<Geom3BSplineCurve> profileCurve = std::make_shared<Geom3BSplineCurve>(profilePoles, profileKnots, profileMults, 3);
		std::vector<Point3> spinePoles;
		std::vector<double> spineKnots(4);
		std::vector<int> spineMults(4, 1);
		spinePoles.push_back(Point3(0.0, 0.0, 0.0));
		spinePoles.push_back(Point3(-0.1, 1.0, -0.2));
		spinePoles.push_back(Point3(0.1, 2.0, -0.1));
		spinePoles.push_back(Point3(0.2, 3.0, 0.1));
		spinePoles.push_back(Point3(0.1, 4.0, 0.0));
		spinePoles.push_back(Point3(0.0, 5.0, -0.1));
		spineKnots[0] = 0;
		spineKnots[1] = 1.0 / 3.0;
		spineKnots[2] = 2.0 / 3.0;
		spineKnots[3] = 1;
		spineMults.front() = 4;
		spineMults.back() = 4;
		std::shared_ptr<Geom3BSplineCurve> spineCurve = std::make_shared<Geom3BSplineCurve>(spinePoles, spineKnots, spineMults, 3);
		TopoWire profile = MakeWire(MakeEdge(profileCurve)).Wire();
		TopoWire spine = MakeWire(MakeEdge(spineCurve)).Wire();
		MakePipeShell pipeShell(spine);
		pipeShell.Add(profile);
		pipeShell.SetMode(Frame3());
		TopoShape pipe = pipeShell.Shape();
		TopoExplorer ex(pipe, ShapeType::Face);
		TopoFace inputBasicFace = static_cast<const TopoFace&>(ex.Current());
		auto surf = TopoTool::Surface(inputBasicFace);
		bspSurf = NURBSAPIConvert::ToBSpline(surf);
		break;
	}
	case 1:
	{
		Array2<Point3> poles(2, 5);
		poles(0, 0) = Point3(0.0, 0.0, 0.0);
		poles(0, 1) = Point3(1.0, -0.2, 0.1);
		poles(0, 2) = Point3(2.0, 0.1, -0.1);
		poles(0, 3) = Point3(3.0, -0.1, 0.0);
		poles(0, 4) = Point3(4.0, 0.1, 0.2);
		poles(1, 0) = Point3(0.0, 1.0, -0.1);
		poles(1, 1) = Point3(1.0, 0.8, 0.0);
		poles(1, 2) = Point3(2.0, 1.1, -0.2);
		poles(1, 3) = Point3(3.0, 0.9, -0.1);
		poles(1, 4) = Point3(4.0, 1.1, 0.1);
		std::vector<double> vKnots(3);
		std::vector<int> vMults(3, 1);
		vKnots[0] = 0;
		vKnots[1] = 0.5;
		vKnots[2] = 1;
		vMults.front() = 4;
		vMults.back() = 4;
		std::vector<double> uKnots(2);
		std::vector<int> uMults(2, 1);
		uKnots[0] = 0;
		uKnots[1] = 1;
		uMults.front() = 2;
		uMults.back() = 2;
		bspSurf = std::make_shared<Geom3BSplineSurface>(poles, uKnots, vKnots, uMults, vMults, 1, 3);
		Transformation3 trsf;
		trsf.SetTranslationPart(Vector3(0.0, -6.0, 0.0));
		bspSurf->Transform(trsf);
		break;
	}
	case 2:
	{
		std::vector<Point3> profilePoles;
		std::vector<double> profileKnots(4);
		std::vector<int> profileMults(4, 1);
		profilePoles.push_back(Point3(0.0, 0.0, 0.0));
		profilePoles.push_back(Point3(1.0, -2.0, -3.0));
		profilePoles.push_back(Point3(2.0, 1.0, 2.0));
		profilePoles.push_back(Point3(3.0, -1.0, -1.0));
		profilePoles.push_back(Point3(4.0, -3.0, 3.0));
		profilePoles.push_back(Point3(5.0, 0.0, 1.0));
		profileKnots[0] = 0;
		profileKnots[1] = 1.0 / 3.0;
		profileKnots[2] = 2.0 / 3.0;
		profileKnots[3] = 1;
		profileMults.front() = 4;
		profileMults.back() = 4;
		std::shared_ptr<Geom3BSplineCurve> profileCurve = std::make_shared<Geom3BSplineCurve>(profilePoles, profileKnots, profileMults, 3);
		std::vector<Point3> spinePoles;
		std::vector<double> spineKnots(4);
		std::vector<int> spineMults(4, 1);
		spinePoles.push_back(Point3(0.0, 0.0, 0.0));
		spinePoles.push_back(Point3(-0.1, 1.0, -1.0));
		spinePoles.push_back(Point3(0.1, -2.0, -2.0));
		spinePoles.push_back(Point3(0.2, -3.0, -3.0));
		spinePoles.push_back(Point3(0.1, -4.0, -4.0));
		spinePoles.push_back(Point3(0.0, -2.5, -5.0));
		spinePoles.push_back(Point3(0.1, -1.0, -6.0));
		spinePoles.push_back(Point3(0.0, 0.0, -7.0));
		spineKnots[0] = 0;
		spineKnots[1] = 1.0 / 3.0;
		spineKnots[2] = 2.0 / 3.0;
		spineKnots[3] = 1;
		spineMults.front() = 6;
		spineMults.back() = 6;
		shared_ptr<Geom3BSplineCurve> spineCurve = std::make_shared<Geom3BSplineCurve>(spinePoles, spineKnots, spineMults, 5);
		TopoWire profile = MakeWire(MakeEdge(profileCurve)).Wire();
		TopoWire spine = MakeWire(MakeEdge(spineCurve)).Wire();
		MakePipeShell pipeShell(spine);
		pipeShell.Add(profile);
		pipeShell.SetMode(Frame3());
		TopoShape pipe = pipeShell.Shape();
		TopoExplorer ex(pipe, ShapeType::Face);
		TopoFace inputBasicFace = static_cast<const TopoFace&>(ex.Current());
		shared_ptr<Geom3Surface> surf = TopoTool::Surface(inputBasicFace);
		shared_ptr<Geom3BSplineSurface>  bspSurf = NURBSAPIConvert::ToBSpline(surf);
		Transformation3 trsf;
		trsf.SetTranslationPart(Vector3(-6.0, 0.0, 0.0));
		bspSurf->Transform(trsf);
		break;
	}
	}
	return bspSurf;
}
#include<catch.hpp>
#include<testHelper.h>
#include <nurbs/NURBSAPIMatch.hpp>
#include <topology/TopoEdge.hpp>
#include <topology/TopoTool.hpp>
#include <nurbs/NURBSAPISweep.hpp>
#include <nurbs/NURBSAPIRebuild.hpp>
#include <modeling/MakeWire.hpp>
#include <modeling/MakeEdge.hpp>
#include <offset/MakePipeShell.hpp>
#include <geometry/Geom3BSplineSurface.hpp>
#include <topology/TopoVertex.hpp>
#include <topomesh/BRepMeshIncrementalMesh.hpp>
#include <geometry/GeomAPIProjectPointOnCurve3.hpp>
#include <modeling/TransformShape.hpp>
#include <nurbs/NURBSAPIMatch.hpp>
#include <modeling/MakeFace.hpp>
#include <nurbs/NURBSAPIConvert.hpp>
#include <topology/TopoExplorerTool.hpp>
#include <modeling/MakeVertex.hpp>
using namespace AMCAX;
std::shared_ptr<Geom3BSplineSurface> GenerateTestSurface11(const int id)
{
	std::shared_ptr<Geom3BSplineSurface> bspSurf;
	switch (id)
	{
	case 0:
	{
		std::vector<Point3> profilePoles;
		std::vector<double> profileKnots(3);
		std::vector<int> profileMults(3, 1);
		profilePoles.push_back(Point3(0.0, 0.0, 0.0));
		profilePoles.push_back(Point3(1.0, -0.2, 0.1));
		profilePoles.push_back(Point3(2.0, 0.1, -0.1));
		profilePoles.push_back(Point3(3.0, -0.1, 0.0));
		profilePoles.push_back(Point3(4.0, 0.1, 0.2));
		profileKnots[0] = 0;
		profileKnots[1] = 0.5;
		profileKnots[2] = 1;
		profileMults.front() = 4;
		profileMults.back() = 4;
		std::shared_ptr<Geom3BSplineCurve> profileCurve = std::make_shared<Geom3BSplineCurve>(profilePoles, profileKnots, profileMults, 3);
		std::vector<Point3> spinePoles;
		std::vector<double> spineKnots(4);
		std::vector<int> spineMults(4, 1);
		spinePoles.push_back(Point3(0.0, 0.0, 0.0));
		spinePoles.push_back(Point3(-0.1, 1.0, -0.2));
		spinePoles.push_back(Point3(0.1, 2.0, -0.1));
		spinePoles.push_back(Point3(0.2, 3.0, 0.1));
		spinePoles.push_back(Point3(0.1, 4.0, 0.0));
		spinePoles.push_back(Point3(0.0, 5.0, -0.1));
		spineKnots[0] = 0;
		spineKnots[1] = 1.0 / 3.0;
		spineKnots[2] = 2.0 / 3.0;
		spineKnots[3] = 1;
		spineMults.front() = 4;
		spineMults.back() = 4;
		std::shared_ptr<Geom3BSplineCurve> spineCurve = std::make_shared<Geom3BSplineCurve>(spinePoles, spineKnots, spineMults, 3);
		TopoWire profile = MakeWire(MakeEdge(profileCurve)).Wire();
		TopoWire spine = MakeWire(MakeEdge(spineCurve)).Wire();
		MakePipeShell pipeShell(spine);
		pipeShell.Add(profile);
		pipeShell.SetMode(Frame3());
		TopoShape pipe = pipeShell.Shape();
		TopoExplorer ex(pipe, ShapeType::Face);
		TopoFace inputBasicFace = static_cast<const TopoFace&>(ex.Current());
		auto surf = TopoTool::Surface(inputBasicFace);
		bspSurf = NURBSAPIConvert::ToBSpline(surf);
		break;
	}
	case 1:
	{
		Array2<Point3> poles(2, 5);
		poles(0, 0) = Point3(0.0, 0.0, 0.0);
		poles(0, 1) = Point3(1.0, -0.2, 0.1);
		poles(0, 2) = Point3(2.0, 0.1, -0.1);
		poles(0, 3) = Point3(3.0, -0.1, 0.0);
		poles(0, 4) = Point3(4.0, 0.1, 0.2);
		poles(1, 0) = Point3(0.0, 1.0, -0.1);
		poles(1, 1) = Point3(1.0, 0.8, 0.0);
		poles(1, 2) = Point3(2.0, 1.1, -0.2);
		poles(1, 3) = Point3(3.0, 0.9, -0.1);
		poles(1, 4) = Point3(4.0, 1.1, 0.1);
		std::vector<double> vKnots(3);
		std::vector<int> vMults(3, 1);
		vKnots[0] = 0;
		vKnots[1] = 0.5;
		vKnots[2] = 1;
		vMults.front() = 4;
		vMults.back() = 4;
		std::vector<double> uKnots(2);
		std::vector<int> uMults(2, 1);
		uKnots[0] = 0;
		uKnots[1] = 1;
		uMults.front() = 2;
		uMults.back() = 2;
		bspSurf = std::make_shared<Geom3BSplineSurface>(poles, uKnots, vKnots, uMults, vMults, 1, 3);
		Transformation3 trsf;
		trsf.SetTranslationPart(Vector3(0.0, -6.0, 0.0));
		bspSurf->Transform(trsf);
		break;
	}
	case 2:
	{
		std::vector<Point3> profilePoles;
		std::vector<double> profileKnots(4);
		std::vector<int> profileMults(4, 1);
		profilePoles.push_back(Point3(0.0, 0.0, 0.0));
		profilePoles.push_back(Point3(1.0, -2.0, -3.0));
		profilePoles.push_back(Point3(2.0, 1.0, 2.0));
		profilePoles.push_back(Point3(3.0, -1.0, -1.0));
		profilePoles.push_back(Point3(4.0, -3.0, 3.0));
		profilePoles.push_back(Point3(5.0, 0.0, 1.0));
		profileKnots[0] = 0;
		profileKnots[1] = 1.0 / 3.0;
		profileKnots[2] = 2.0 / 3.0;
		profileKnots[3] = 1;
		profileMults.front() = 4;
		profileMults.back() = 4;
		std::shared_ptr<Geom3BSplineCurve> profileCurve = std::make_shared<Geom3BSplineCurve>(profilePoles, profileKnots, profileMults, 3);
		std::vector<Point3> spinePoles;
		std::vector<double> spineKnots(4);
		std::vector<int> spineMults(4, 1);
		spinePoles.push_back(Point3(0.0, 0.0, 0.0));
		spinePoles.push_back(Point3(-0.1, 1.0, -1.0));
		spinePoles.push_back(Point3(0.1, -2.0, -2.0));
		spinePoles.push_back(Point3(0.2, -3.0, -3.0));
		spinePoles.push_back(Point3(0.1, -4.0, -4.0));
		spinePoles.push_back(Point3(0.0, -2.5, -5.0));
		spinePoles.push_back(Point3(0.1, -1.0, -6.0));
		spinePoles.push_back(Point3(0.0, 0.0, -7.0));
		spineKnots[0] = 0;
		spineKnots[1] = 1.0 / 3.0;
		spineKnots[2] = 2.0 / 3.0;
		spineKnots[3] = 1;
		spineMults.front() = 6;
		spineMults.back() = 6;
		shared_ptr<Geom3BSplineCurve> spineCurve = std::make_shared<Geom3BSplineCurve>(spinePoles, spineKnots, spineMults, 5);
		TopoWire profile = MakeWire(MakeEdge(profileCurve)).Wire();
		TopoWire spine = MakeWire(MakeEdge(spineCurve)).Wire();
		MakePipeShell pipeShell(spine);
		pipeShell.Add(profile);
		pipeShell.SetMode(Frame3());
		TopoShape pipe = pipeShell.Shape();
		TopoExplorer ex(pipe, ShapeType::Face);
		TopoFace inputBasicFace = static_cast<const TopoFace&>(ex.Current());
		shared_ptr<Geom3Surface> surf = TopoTool::Surface(inputBasicFace);
		shared_ptr<Geom3BSplineSurface>  bspSurf = NURBSAPIConvert::ToBSpline(surf);
		Transformation3 trsf;
		trsf.SetTranslationPart(Vector3(-6.0, 0.0, 0.0));
		bspSurf->Transform(trsf);
		break;
	}
	}
	return bspSurf;
;
	SECTION("MatchTrimmedSurface")
	 {
		 OUTPUT_DIRECTORY(nurbs, Match/MatchFace/MatchTrimmedSurface);
		 string filedir = INPUT_PATH_PREFIX"./TestNURBS/TestMatchTrimmedSurface/";
		 TopoFace f1 = ReadBRepFace(filedir + "surf1.brep");
		 TopoFace f2 = ReadBRepFace(filedir + "surf2.brep");
		 Point3 p1, p2;
		 bool isSurf1TrimmedEdge = true;
		 bool isSurf2TrimmedEdge = true;
		 if (isSurf1TrimmedEdge)
		 {
			 p1 = ReadBRepPoint(filedir + "tptS1.brep");
		 }
		 else
		 {
			 p1 = ReadBRepPoint(filedir + "nptS1.brep");
		 }
		 if (isSurf2TrimmedEdge)
		 {
			 p2 = ReadBRepPoint(filedir + "tptS2.brep");
		 }
		 else
		 {
			 p2 = ReadBRepPoint(filedir + "nptS2.brep");
		 }
		 auto [d1, e1] = NearestEdge(p1, f1);
		 auto [d2, e2] = NearestEdge(p2, f2);
		 ContinuityType cont = ContinuityType::G2;
		 int otherEndCont = 0;
		 NURBSMatchSurfConfig config;
		 bool isPrecise = true;
		 std::vector<double> tol;
		 tol.push_back(0.001);
		 tol.push_back(0.1);
		 tol.push_back(0.05);
		 std::vector<double> params(2, 1.0);
		 auto result = NURBSAPIMatch::MatchFace(f1, e1, f2, e2, cont, otherEndCont, isPrecise, tol, params, false, config, config);
		 OCCTIO::OCCTTool::Write(f1, outdir + "f1.brep");
		 OCCTIO::OCCTTool::Write(f2, outdir + "f2.brep");
		 OCCTIO::OCCTTool::Write(MakeVertex(p1), outdir + "p1.brep");
		 OCCTIO::OCCTTool::Write(MakeVertex(p2), outdir + "p2.brep");
		 OCCTIO::OCCTTool::Write(e1, outdir + "e1.brep");
		 OCCTIO::OCCTTool::Write(e2, outdir + "e2.brep");
	 }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static std::shared_ptr<Geom3BSplineSurface> SurfaceToPlaneG0(const std::shared_ptr<Geom3BSplineSurface>& surf, bool isUIso, bool isFront, const std::shared_ptr<Geom3Plane>& plane)	 @return The result surface
	 @param plane The plane
	 @param isFront Front or back end
	 @param isUIso U end or v end
	 @param surf The source surface
	 @brief Make the surface end G0 to the plane.
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <nurbs/NURBSAPIModifyEndToPlane.hpp>
#include <offset/MakePipe.hpp>
#include <geometry/Geom3TrimmedSurface.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeFace.hpp>
#include <geometry/Geom3BSplineCurve.hpp>
#include <geometry/Geom3Plane.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <modeling/MakeWire.hpp>
#include <topology/TopoTool.hpp>
#include <topology/TopoExplorerTool.hpp>
#include <nurbs/NURBSAPIConvert.hpp>
TEST_CASE("case1: this is a test for TestSymmetrySurf", "[nurbs][ModifyEndToPlane][P1]")
{
	OUTPUT_DIRECTORY(nurbs, ModifyEndToPlane/SymmetrySurf);
	std::vector<Point3> profilePoles;
	std::vector<double> profileKnots(3);
	std::vector<int> profileMults(3, 1);
	profilePoles.push_back(Point3(0.0, 0.0, 0.0));
	profilePoles.push_back(Point3(1.0, -0.2, 0.0));
	profilePoles.push_back(Point3(2.0, 0.1, 0.0));
	profilePoles.push_back(Point3(2.3, -0.1, 0.0));
	profilePoles.push_back(Point3(2.9, 0.1, 0.0));
	profileKnots[0] = 0;
	profileKnots[1] = 0.5;
	profileKnots[2] = 1;
	profileMults.front() = 4;
	profileMults.back() = 4;
	std::shared_ptr<Geom3BSplineCurve> profile = std::make_shared<Geom3BSplineCurve>(profilePoles, profileKnots, profileMults, 3);
	std::vector<Point3> spinePoles;
	std::vector<double> spineKnots(4);
	std::vector<int> spineMults(4, 1);
	spinePoles.push_back(Point3(0.0, 0.0, 0.0));
	spinePoles.push_back(Point3(0.0, 0.0, 1.0));
	spinePoles.push_back(Point3(0.0, 0.2, 1.5));
	spinePoles.push_back(Point3(0.0, 0.5, 2.0));
	spinePoles.push_back(Point3(0.0, 1.0, 2.3));
	spinePoles.push_back(Point3(0.0, 1.6, 2.3));
	spineKnots[0] = 0;
	spineKnots[1] = 1.0 / 3.0;
	spineKnots[2] = 2.0 / 3.0;
	spineKnots[3] = 1;
	spineMults.front() = 4;
	spineMults.back() = 4;
	std::shared_ptr<Geom3BSplineCurve> spine = std::make_shared<Geom3BSplineCurve>(spinePoles, spineKnots, spineMults, 3);
	TopoShape pipe = MakePipe(MakeWire(MakeEdge(spine)), MakeWire(MakeEdge(profile))).Shape();
	TopoExplorer ex(pipe, ShapeType::Face);
	shared_ptr <Geom3Plane> tp1 = std::make_shared<Geom3Plane>(Point3(-3.2, 0.0, 0.0), Direction3(1.0, 0.1, 0.0));
	shared_ptr<Geom3TrimmedSurface> trimtp1 = std::make_shared<Geom3TrimmedSurface>(tp1, -10.0, 10.0, -10.0, 10.0);
	shared_ptr <Geom3Plane> tp2 = std::make_shared<Geom3Plane>(Point3(3.1, 0.0, 0.0), Direction3(1.0, 0.0, 0.0));
	shared_ptr<Geom3TrimmedSurface> trimtp2 = std::make_shared<Geom3TrimmedSurface>(tp2, -10.0, 10.0, -10.0, 10.0);
	shared_ptr<Geom3BSplineSurface> surface = NURBSAPIConvert::ToBSpline(TopoTool::Surface(static_cast<const TopoFace&>(ex.Current())));
	shared_ptr<Geom3BSplineSurface> sG0 = NURBSAPIModifyEndToPlane::SurfaceToPlaneG0(surface, true, true, tp1);
	shared_ptr<Geom3BSplineSurface> sG1 = NURBSAPIModifyEndToPlane::SurfaceToPlaneG1(surface, true, false, tp2);
	CHECK(GetTopoCount(MakeFace(sG0, 0.0), ShapeType::Edge) == 4);
	CHECK(GetTopoCount(MakeFace(sG1, 0.0), ShapeType::Edge) == 4);
	IndexSet<TopoShape>newshapeEdge1, newshapeEdge2;
	TopoExplorerTool::MapShapes(MakeFace(sG0, 0.0), ShapeType::Edge, newshapeEdge1);
	TopoExplorerTool::MapShapes(MakeFace(sG1, 0.0), ShapeType::Edge, newshapeEdge2);
	CHECK(newshapeEdge1.size() == 4);
	CHECK(newshapeEdge2.size() == 4);
	double first = 0.0;
	double last = 0.0;
	int num = 1000;
	double ratio = 0.0;
	double tol = 0.0;
	shared_ptr<Geom3BSplineCurve> curve1 = NURBSAPIConvert::ToBSpline(TopoTool::Curve(static_cast<const TopoEdge&>(newshapeEdge1[0]), first, last));
	shared_ptr<Geom3BSplineCurve> curve2 = NURBSAPIConvert::ToBSpline(TopoTool::Curve(static_cast<const TopoEdge&>(newshapeEdge2[2]), first, last));
	bool res1 = IsCurveOnSurf(num, ratio, curve1, trimtp1, -1.0);
	bool res2 = IsCurveOnSurf(num, ratio, curve2, trimtp2, -1.0);
	CHECK(res1 == true);
	CHECK(res2 == true);
	double fu1 = surface->LastUParameter();
	double fu2 = surface->FirstUParameter();
	double fu3 = sG0->LastUParameter();
	double fu4 = sG1->FirstUParameter();
	shared_ptr<Geom3Curve> f1 = surface->UIso(fu1);
	shared_ptr<Geom3Curve> f2 = surface->UIso(fu2);
	shared_ptr<Geom3Curve> f3 = sG0->UIso(fu3);
	shared_ptr<Geom3Curve> f4 = sG1->UIso(fu4);
	double refTol = 1e-1;
	ratio = 0.1;
	double res3 = NurbsSampleCurve(num, refTol, f3, f1);
	double res4 = NurbsSampleCurve(num, refTol, f4, f2);
	CHECK(res3 <= ratio);
	CHECK(res4 <= ratio);
	OCCTIO::OCCTTool::Write(MakeFace(surface,0.0), outdir + "surface.brep");
	OCCTIO::OCCTTool::Write(MakeFace(trimtp1, 0.0), outdir + "trimtp1 .brep");
	OCCTIO::OCCTTool::Write(MakeFace(trimtp2, 0.0), outdir + "trimtp2.brep");
	OCCTIO::OCCTTool::Write(MakeFace(sG0, 0.0), outdir + "sG0.brep");
	OCCTIO::OCCTTool::Write(MakeFace(sG1, 0.0), outdir + "sG1.brep");
	OCCTIO::OCCTTool::Write(MakeEdge(curve1), outdir + "curve1.brep");
	OCCTIO::OCCTTool::Write(MakeEdge(curve2), outdir + "curve2.brep"); 
	OCCTIO::OCCTTool::Write(MakeEdge(f1), outdir + "f1.brep");
	OCCTIO::OCCTTool::Write(MakeEdge(f2), outdir + "f2.brep");
	OCCTIO::OCCTTool::Write(MakeEdge(f3), outdir + "f3.brep");
	OCCTIO::OCCTTool::Write(MakeEdge(f4), outdir + "f4.brep");
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static std::pair<std::vector<std::shared_ptr<Geom3Curve>>, std::vector<Point3>> OffsetCurveOnSurface( const TopoEdge& edge, const TopoFace& face, double offset, bool reverse),
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <nurbs/NURBSAPIOffsetCurveOnSurface.hpp>
#include <geometry/Geom3BSplineCurve.hpp>
#include <modeling/MakeWire.hpp>
#include <modeling/MakeEdge.hpp>
#include <offset/MakePipeShell.hpp>
#include <topology/TopoTool.hpp>
#include <geometry/Geom3BSplineSurface.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <healing/ShapeFixTool.hpp>
#include <modeling/MakeFace.hpp>
#include <geometry/GeomAPIProjectPointOnCurve3.hpp>
#include <geometry/GeomAPIProjectPointOnCurve2.hpp>
#include <nurbs/NURBSAPIConvert.hpp>
#include <modeling/MakeVertex.hpp>
#include <hatch/BRepClassificationTools.hpp>
std::shared_ptr<Geom3BSplineSurface> GenerateTestSurface(const int id)
{
	std::shared_ptr<Geom3BSplineSurface> bspSurf;
	switch (id)
	{
	case 0:
	{
		std::vector<Point3> profilePoles;
		std::vector<double> profileKnots(3);
		std::vector<int> profileMults(3, 1);
		profilePoles.push_back(Point3(0.0, 0.0, 0.0));
		profilePoles.push_back(Point3(1.0, -0.2, 0.1));
		profilePoles.push_back(Point3(2.0, 0.1, -0.1));
		profilePoles.push_back(Point3(3.0, -0.1, 0.0));
		profilePoles.push_back(Point3(4.0, 0.1, 0.2));
		profileKnots[0] = 0;
		profileKnots[1] = 0.5;
		profileKnots[2] = 1;
		profileMults.front() = 4;
		profileMults.back() = 4;
		std::shared_ptr<Geom3BSplineCurve> profileCurve = std::make_shared<Geom3BSplineCurve>(profilePoles, profileKnots, profileMults, 3);
		std::vector<Point3> spinePoles;
		std::vector<double> spineKnots(4);
		std::vector<int> spineMults(4, 1);
		spinePoles.push_back(Point3(0.0, 0.0, 0.0));
		spinePoles.push_back(Point3(-0.1, 1.0, -0.2));
		spinePoles.push_back(Point3(0.1, 2.0, -0.1));
		spinePoles.push_back(Point3(0.2, 3.0, 0.1));
		spinePoles.push_back(Point3(0.1, 4.0, 0.0));
		spinePoles.push_back(Point3(0.0, 5.0, -0.1));
		spineKnots[0] = 0;
		spineKnots[1] = 1.0 / 3.0;
		spineKnots[2] = 2.0 / 3.0;
		spineKnots[3] = 1;
		spineMults.front() = 4;
		spineMults.back() = 4;
		std::shared_ptr<Geom3BSplineCurve> spineCurve = std::make_shared<Geom3BSplineCurve>(spinePoles, spineKnots, spineMults, 3);
		TopoWire profile = MakeWire(MakeEdge(profileCurve)).Wire();
		TopoWire spine = MakeWire(MakeEdge(spineCurve)).Wire();
		MakePipeShell pipeShell(spine);
		pipeShell.Add(profile);
		pipeShell.SetMode(Frame3());
		TopoShape pipe = pipeShell.Shape();
		TopoExplorer ex(pipe, ShapeType::Face);
		TopoFace inputBasicFace = static_cast<const TopoFace&>(ex.Current());
		shared_ptr<Geom3Surface> surf = TopoTool::Surface(inputBasicFace);
		shared_ptr<Geom3BSplineSurface> bspSurf = NURBSAPIConvert::ToBSpline(surf);
		break;
	}
	case 1:
	{
		Array2<Point3> poles(2, 5);
		poles(0, 0) = Point3(0.0, 0.0, 0.0);
		poles(0, 1) = Point3(1.0, -0.2, 0.1);
		poles(0, 2) = Point3(2.0, 0.1, -0.1);
		poles(0, 3) = Point3(3.0, -0.1, 0.0);
		poles(0, 4) = Point3(4.0, 0.1, 0.2);
		poles(1, 0) = Point3(0.0, 1.0, -0.1);
		poles(1, 1) = Point3(1.0, 0.8, 0.0);
		poles(1, 2) = Point3(2.0, 1.1, -0.2);
		poles(1, 3) = Point3(3.0, 0.9, -0.1);
		poles(1, 4) = Point3(4.0, 1.1, 0.1);
		std::vector<double> vKnots(3);
		std::vector<int> vMults(3, 1);
		vKnots[0] = 0;
		vKnots[1] = 0.5;
		vKnots[2] = 1;
		vMults.front() = 4;
		vMults.back() = 4;
		std::vector<double> uKnots(2);
		std::vector<int> uMults(2, 1);
		uKnots[0] = 0;
		uKnots[1] = 1;
		uMults.front() = 2;
		uMults.back() = 2;
		bspSurf = std::make_shared<Geom3BSplineSurface>(poles, uKnots, vKnots, uMults, vMults, 1, 3);
		Transformation3 trsf;
		trsf.SetTranslationPart(Vector3(0.0, -6.0, 0.0));
		bspSurf->Transform(trsf);
		break;
	}
	case 2:
	{
		std::vector<Point3> profilePoles;
		std::vector<double> profileKnots(4);
		std::vector<int> profileMults(4, 1);
		profilePoles.push_back(Point3(0.0, 0.0, 0.0));
		profilePoles.push_back(Point3(1.0, -2.0, -3.0));
		profilePoles.push_back(Point3(2.0, 1.0, 2.0));
		profilePoles.push_back(Point3(3.0, -1.0, -1.0));
		profilePoles.push_back(Point3(4.0, -3.0, 3.0));
		profilePoles.push_back(Point3(5.0, 0.0, 1.0));
		profileKnots[0] = 0;
		profileKnots[1] = 1.0 / 3.0;
		profileKnots[2] = 2.0 / 3.0;
		profileKnots[3] = 1;
		profileMults.front() = 4;
		profileMults.back() = 4;
		std::shared_ptr<Geom3BSplineCurve> profileCurve = std::make_shared<Geom3BSplineCurve>(profilePoles, profileKnots, profileMults, 3);
		std::vector<Point3> spinePoles;
		std::vector<double> spineKnots(4);
		std::vector<int> spineMults(4, 1);
		spinePoles.push_back(Point3(0.0, 0.0, 0.0));
		spinePoles.push_back(Point3(-0.1, 1.0, -1.0));
		spinePoles.push_back(Point3(0.1, -2.0, -2.0));
		spinePoles.push_back(Point3(0.2, -3.0, -3.0));
		spinePoles.push_back(Point3(0.1, -4.0, -4.0));
		spinePoles.push_back(Point3(0.0, -2.5, -5.0));
		spinePoles.push_back(Point3(0.1, -1.0, -6.0));
		spinePoles.push_back(Point3(0.0, 0.0, -7.0));
		spineKnots[0] = 0;
		spineKnots[1] = 1.0 / 3.0;
		spineKnots[2] = 2.0 / 3.0;
		spineKnots[3] = 1;
		spineMults.front() = 6;
		spineMults.back() = 6;
		shared_ptr<Geom3BSplineCurve> spineCurve = make_shared<Geom3BSplineCurve>(spinePoles, spineKnots, spineMults, 5);
		TopoWire profile = MakeWire(MakeEdge(profileCurve)).Wire();
		TopoWire spine = MakeWire(MakeEdge(spineCurve)).Wire();
		MakePipeShell pipeShell(spine);
		pipeShell.Add(profile);
		pipeShell.SetMode(Frame3());
		TopoShape pipe = pipeShell.Shape();
		TopoExplorer ex(pipe, ShapeType::Face);
		TopoFace inputBasicFace = static_cast<const TopoFace&>(ex.Current());
		shared_ptr<Geom3Surface> surf = TopoTool::Surface(inputBasicFace);
		shared_ptr<Geom3BSplineSurface> bspSurf = NURBSAPIConvert::ToBSpline(surf);
		Transformation3 trsf;
		trsf.SetTranslationPart(Vector3(-6.0, 0.0, 0.0));
		bspSurf->Transform(trsf);
		break;
	}
	}
	return bspSurf;
}
TEST_CASE("case1: this is a test for TestOffsetCurveOnSurface1", "[nurbs][Offset][P1]")
{
	OUTPUT_DIRECTORY(nurbs, OffsetCurveOnSurface/OffsetCurveOnSurface1);
	shared_ptr<Geom3BSplineSurface> surf = GenerateTestSurface(1);
	int deg = 3;
	std::vector<Point2> poles;
	poles.push_back(Point2(0.0, 0.2));
	poles.push_back(Point2(0.1, 0.35));
	poles.push_back(Point2(0.25, 0.13));
	poles.push_back(Point2(0.35, 0.07));
	poles.push_back(Point2(0.43, 0.2));
	poles.push_back(Point2(0.5, 0.21));
	poles.push_back(Point2(0.6, 0.17));
	poles.push_back(Point2(0.7, 0.21));
	std::vector<double> weights;
	weights.push_back(0.8);
	weights.push_back(0.9);
	weights.push_back(1.1);
	weights.push_back(0.7);
	weights.push_back(1.2);
	weights.push_back(1.0);
	weights.push_back(1.3);
	weights.push_back(0.7);
	std::vector<double> knots(static_cast<int>(poles.size()) - deg + 1);
	for (int i = 0; i < static_cast<int>(knots.size()); i++)
	{
		knots[i] = (double)i / (double)(static_cast<int>(poles.size()) - 1);
	}
	std::vector<int> mults(knots.size(), 1);
	mults.front() = deg + 1;
	mults.back() = deg + 1;
	shared_ptr<Geom2BSplineCurve> bsp = std::make_shared<Geom2BSplineCurve>(poles, weights, knots, mults, deg);
	TopoEdge edge = MakeEdge(bsp, surf);
	ShapeFixTool::FixEdgeAddCurve(edge);
	double fp, lp;
	shared_ptr<Geom3Curve> c3d = TopoTool::Curve(edge, fp, lp);
	OCCTIO::OCCTTool::Write(edge, outdir + "edge.brep");
	OCCTIO::OCCTTool::Write(MakeEdge(c3d), outdir + "c3d.brep");
	TopoFace face = MakeFace(surf, Precision::Confusion());
	{
		double offset = 0.1;
		bool reverse = true;
		auto [curves, points] = NURBSAPIOffsetCurveOnSurface::OffsetCurveOnSurface(edge, face, offset, reverse);
		int NSample = 100;
		double maxDist = Precision::NegativeInfinity();
		double minDist = Precision::PositiveInfinity();
		Point3 refFirstPoint, refLastPoint;
		c3d->D0(c3d->FirstParameter(), refFirstPoint);
		c3d->D0(c3d->LastParameter(), refLastPoint);
		for (int i = 0; i < static_cast<int>(curves.size()); i++)
		{
			fp = curves[i]->FirstParameter();
			lp = curves[i]->LastParameter();
			double delta = (lp - fp) / (double)(NSample - 1);
			for (int j = 0; j < NSample; j++)
			{
				double t = fp + j * delta;
				Point3 p;
				curves[i]->D0(t, p);
				GeomAPIProjectPointOnCurve3 projector(p, c3d);
				double crdist;
				if (projector.NPoints())
				{
					crdist = projector.LowerDistance();
				}
				else
				{
					crdist = std::min(p.Distance(refFirstPoint), p.Distance(refLastPoint));
				}
				maxDist = std::max(maxDist, crdist);
				minDist = std::min(minDist, crdist);
			}
			OCCTIO::OCCTTool::Write(MakeEdge(curves[i]), outdir + "curves" + to_string(i) + ".brep");
		}
		int num = 1000;
		double ratio = 0.01;
		for (int i = 0; i < static_cast<int>(curves.size()); i++)
		{
			bool res1 = IsCurveOnSurf(num, ratio, curves[i], surf);
			CHECK(res1 == true);
		}
		OCCTIO::OCCTTool::Write(edge, outdir + "edge.brep");
		OCCTIO::OCCTTool::Write(face, outdir + "face.brep");
	}
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static std::pair<std::vector<std::shared_ptr<Geom3Curve>>, std::vector<Point3>> OffsetCurveOnSurfaceToPoint( const TopoEdge& edge, const TopoFace& face, const Point2& point),
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <nurbs/NURBSAPIOffsetCurveOnSurface.hpp>
#include <geometry/Geom3BSplineCurve.hpp>
#include <modeling/MakeWire.hpp>
#include <modeling/MakeEdge.hpp>
#include <offset/MakePipeShell.hpp>
#include <topology/TopoTool.hpp>
#include <geometry/Geom3BSplineSurface.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <healing/ShapeFixTool.hpp>
#include <modeling/MakeFace.hpp>
#include <geometry/GeomAPIProjectPointOnCurve3.hpp>
#include <geometry/GeomAPIProjectPointOnCurve2.hpp>
#include <nurbs/NURBSAPIConvert.hpp>
#include <modeling/MakeVertex.hpp>
#include <hatch/BRepClassificationTools.hpp>
std::shared_ptr<Geom3BSplineSurface> GenerateTestSurface(const int id)
{
	std::shared_ptr<Geom3BSplineSurface> bspSurf;
	switch (id)
	{
	case 0:
	{
		std::vector<Point3> profilePoles;
		std::vector<double> profileKnots(3);
		std::vector<int> profileMults(3, 1);
		profilePoles.push_back(Point3(0.0, 0.0, 0.0));
		profilePoles.push_back(Point3(1.0, -0.2, 0.1));
		profilePoles.push_back(Point3(2.0, 0.1, -0.1));
		profilePoles.push_back(Point3(3.0, -0.1, 0.0));
		profilePoles.push_back(Point3(4.0, 0.1, 0.2));
		profileKnots[0] = 0;
		profileKnots[1] = 0.5;
		profileKnots[2] = 1;
		profileMults.front() = 4;
		profileMults.back() = 4;
		std::shared_ptr<Geom3BSplineCurve> profileCurve = std::make_shared<Geom3BSplineCurve>(profilePoles, profileKnots, profileMults, 3);
		std::vector<Point3> spinePoles;
		std::vector<double> spineKnots(4);
		std::vector<int> spineMults(4, 1);
		spinePoles.push_back(Point3(0.0, 0.0, 0.0));
		spinePoles.push_back(Point3(-0.1, 1.0, -0.2));
		spinePoles.push_back(Point3(0.1, 2.0, -0.1));
		spinePoles.push_back(Point3(0.2, 3.0, 0.1));
		spinePoles.push_back(Point3(0.1, 4.0, 0.0));
		spinePoles.push_back(Point3(0.0, 5.0, -0.1));
		spineKnots[0] = 0;
		spineKnots[1] = 1.0 / 3.0;
		spineKnots[2] = 2.0 / 3.0;
		spineKnots[3] = 1;
		spineMults.front() = 4;
		spineMults.back() = 4;
		std::shared_ptr<Geom3BSplineCurve> spineCurve = std::make_shared<Geom3BSplineCurve>(spinePoles, spineKnots, spineMults, 3);
		TopoWire profile = MakeWire(MakeEdge(profileCurve)).Wire();
		TopoWire spine = MakeWire(MakeEdge(spineCurve)).Wire();
		MakePipeShell pipeShell(spine);
		pipeShell.Add(profile);
		pipeShell.SetMode(Frame3());
		TopoShape pipe = pipeShell.Shape();
		TopoExplorer ex(pipe, ShapeType::Face);
		TopoFace inputBasicFace = static_cast<const TopoFace&>(ex.Current());
		shared_ptr<Geom3Surface> surf = TopoTool::Surface(inputBasicFace);
		shared_ptr<Geom3BSplineSurface> bspSurf = NURBSAPIConvert::ToBSpline(surf);
		break;
	}
	case 1:
	{
		Array2<Point3> poles(2, 5);
		poles(0, 0) = Point3(0.0, 0.0, 0.0);
		poles(0, 1) = Point3(1.0, -0.2, 0.1);
		poles(0, 2) = Point3(2.0, 0.1, -0.1);
		poles(0, 3) = Point3(3.0, -0.1, 0.0);
		poles(0, 4) = Point3(4.0, 0.1, 0.2);
		poles(1, 0) = Point3(0.0, 1.0, -0.1);
		poles(1, 1) = Point3(1.0, 0.8, 0.0);
		poles(1, 2) = Point3(2.0, 1.1, -0.2);
		poles(1, 3) = Point3(3.0, 0.9, -0.1);
		poles(1, 4) = Point3(4.0, 1.1, 0.1);
		std::vector<double> vKnots(3);
		std::vector<int> vMults(3, 1);
		vKnots[0] = 0;
		vKnots[1] = 0.5;
		vKnots[2] = 1;
		vMults.front() = 4;
		vMults.back() = 4;
		std::vector<double> uKnots(2);
		std::vector<int> uMults(2, 1);
		uKnots[0] = 0;
		uKnots[1] = 1;
		uMults.front() = 2;
		uMults.back() = 2;
		bspSurf = std::make_shared<Geom3BSplineSurface>(poles, uKnots, vKnots, uMults, vMults, 1, 3);
		Transformation3 trsf;
		trsf.SetTranslationPart(Vector3(0.0, -6.0, 0.0));
		bspSurf->Transform(trsf);
		break;
	}
	case 2:
	{
		std::vector<Point3> profilePoles;
		std::vector<double> profileKnots(4);
		std::vector<int> profileMults(4, 1);
		profilePoles.push_back(Point3(0.0, 0.0, 0.0));
		profilePoles.push_back(Point3(1.0, -2.0, -3.0));
		profilePoles.push_back(Point3(2.0, 1.0, 2.0));
		profilePoles.push_back(Point3(3.0, -1.0, -1.0));
		profilePoles.push_back(Point3(4.0, -3.0, 3.0));
		profilePoles.push_back(Point3(5.0, 0.0, 1.0));
		profileKnots[0] = 0;
		profileKnots[1] = 1.0 / 3.0;
		profileKnots[2] = 2.0 / 3.0;
		profileKnots[3] = 1;
		profileMults.front() = 4;
		profileMults.back() = 4;
		std::shared_ptr<Geom3BSplineCurve> profileCurve = std::make_shared<Geom3BSplineCurve>(profilePoles, profileKnots, profileMults, 3);
		std::vector<Point3> spinePoles;
		std::vector<double> spineKnots(4);
		std::vector<int> spineMults(4, 1);
		spinePoles.push_back(Point3(0.0, 0.0, 0.0));
		spinePoles.push_back(Point3(-0.1, 1.0, -1.0));
		spinePoles.push_back(Point3(0.1, -2.0, -2.0));
		spinePoles.push_back(Point3(0.2, -3.0, -3.0));
		spinePoles.push_back(Point3(0.1, -4.0, -4.0));
		spinePoles.push_back(Point3(0.0, -2.5, -5.0));
		spinePoles.push_back(Point3(0.1, -1.0, -6.0));
		spinePoles.push_back(Point3(0.0, 0.0, -7.0));
		spineKnots[0] = 0;
		spineKnots[1] = 1.0 / 3.0;
		spineKnots[2] = 2.0 / 3.0;
		spineKnots[3] = 1;
		spineMults.front() = 6;
		spineMults.back() = 6;
		shared_ptr<Geom3BSplineCurve> spineCurve = make_shared<Geom3BSplineCurve>(spinePoles, spineKnots, spineMults, 5);
		TopoWire profile = MakeWire(MakeEdge(profileCurve)).Wire();
		TopoWire spine = MakeWire(MakeEdge(spineCurve)).Wire();
		MakePipeShell pipeShell(spine);
		pipeShell.Add(profile);
		pipeShell.SetMode(Frame3());
		TopoShape pipe = pipeShell.Shape();
		TopoExplorer ex(pipe, ShapeType::Face);
		TopoFace inputBasicFace = static_cast<const TopoFace&>(ex.Current());
		shared_ptr<Geom3Surface> surf = TopoTool::Surface(inputBasicFace);
		shared_ptr<Geom3BSplineSurface> bspSurf = NURBSAPIConvert::ToBSpline(surf);
		Transformation3 trsf;
		trsf.SetTranslationPart(Vector3(-6.0, 0.0, 0.0));
		bspSurf->Transform(trsf);
		break;
	}
	}
	return bspSurf;
}
TEST_CASE("Not Fix bug1: TestOffsetCurveFailedCase ", "[nurbs][Offset][bug]")
{
	OUTPUT_DIRECTORY(nurbs, OffsetCurveOnSurface/bug794);
	TopoEdge edge = ReadBRepEdge(INPUT_PATH_PREFIX"/TestNURBS/TestOffsetCurveFailedCase/curve.brep");
	TopoFace face = ReadBRepFace(INPUT_PATH_PREFIX"/TestNURBS/TestOffsetCurveFailedCase/face.brep");
	Point2 uv(0.5, 0.5);
	shared_ptr<Geom3Surface> s = TopoTool::Surface(face);
	auto [curves1, points1] = NURBSAPIOffsetCurveOnSurface::OffsetCurveOnSurfaceToPoint(edge, face, uv);
	for (size_t i = 0; i < curves1.size(); i++)
	{
		OCCTIO::OCCTTool::Write(MakeEdge(curves1[i]), outdir + "result1" + to_string(i) + ".brep");
	}
	double tol = -1.0;
	Point3 uv1(uv.X(), uv.Y(), 0.0);
	TopoEdge e = MakeEdge(curves1[0]);
	bool res1 = BRepClassificationTools::IsPointInOnEdge(e, uv1, tol);
	CHECK(res1 == true);
	Point2 uv2(0.6, 0.3);
	auto [curves, points] = NURBSAPIOffsetCurveOnSurface::OffsetCurveOnSurfaceToPoint(edge, face, uv2);
	for (size_t i = 0; i < curves.size(); i++)
	{
		OCCTIO::OCCTTool::Write(MakeEdge(curves[i]), outdir + "result2" + to_string(i) + ".brep");
	}
	Point3 uv22(uv2.X(), uv2.Y(), 0.0);
	TopoEdge e2 = MakeEdge(curves[0]);
	bool res4 = BRepClassificationTools::IsPointInOnEdge(e2, uv22, tol);
	CHECK(res4 == true);
	OCCTIO::OCCTTool::Write(MakeVertex(uv1), outdir + "refp1.brep");
	OCCTIO::OCCTTool::Write(MakeVertex(uv22), outdir + "refp2.brep");
	OCCTIO::OCCTTool::Write(edge, outdir + "edge.brep");
	OCCTIO::OCCTTool::Write(face, outdir + "face.brep");
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static std::pair<std::vector<std::pair<std::shared_ptr<Geom3Curve>, std::shared_ptr<Geom2Curve>>>, std::vector<std::pair<Point3, Point2>>> NURBSProjectCurveOnSurface(const std::shared_ptr<Geom3Curve>& curve, const std::shared_ptr<Geom3Surface>& surf, const Point3& pt),
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <nurbs/NURBSAPIProject.hpp>
#include <geometry/Geom3SphericalSurface.hpp>
#include <common/CartesianCoordinateSystem.hpp>
#include <modeling/MakeFace.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeVertex.hpp>
#include <nurbs/NURBSAPIConvert.hpp>
TEST_CASE("bug1: testNURBSAPIProject ", "[nurbs][Project][fixbug]")
{
	OUTPUT_DIRECTORY(nurbs, Project/bug692);
	std::shared_ptr<Geom3SphericalSurface> sphere = std::make_shared<Geom3SphericalSurface>(CartesianCoordinateSystem::XOY(), 3);
	std::vector<Point3> poles;
	poles.push_back(Point3(0., -1., 0.));
	poles.push_back(Point3(.7, -.7, 0.));
	poles.push_back(Point3(1., -.3, 0.));
	poles.push_back(Point3(1.2, 0., 0.));
	poles.push_back(Point3(2., .3, 0.));
	poles.push_back(Point3(.7, 1.7, 0.));
	poles.push_back(Point3(0., 1., 0.));
	std::vector<double> weights;
	weights.push_back(0.9);
	weights.push_back(1.25);
	weights.push_back(1.5);
	weights.push_back(0.75);
	weights.push_back(1.2);
	weights.push_back(1.1);
	weights.push_back(1.3);
	std::vector<double> knots;
	knots.push_back(0.);
	knots.push_back(.25);
	knots.push_back(.5);
	knots.push_back(.75);
	knots.push_back(1.);
	std::vector<int> mults(5, 1);
	mults.front() = 4;
	mults.back() = 4;
	std::shared_ptr<Geom3BSplineCurve> bsp = std::make_shared<Geom3BSplineCurve>(poles, weights, knots, mults, 3);
	Transformation3 trsf;
	trsf.SetDisplacement(CartesianCoordinateSystem::XOY(), Frame3(Point3(-4.0, 0.0, 0.0), Direction3(1.0, 0.0, 0.0), Direction3(0.0, 1.0, 0.0)));
	bsp->Transform(trsf);
	bool isParallel = false;	
	int num = 1000;
	double ratio = 0.1;
	bool res1, res2;
	if (!isParallel)
	{
		auto [lines, points] = NURBSAPIProject::NURBSProjectCurveOnSurface(bsp, sphere, Point3(-10.0, 0.0, 0.0));
		res1 = IsCurveOnSurf(num, ratio, lines[0].first, sphere, -1.0);
		CHECK(res1 == true);
		for (int i = 0; i < static_cast<int>(lines.size()); i++)
		{
			OCCTIO::OCCTTool::Write(MakeEdge(lines[i].first), outdir + "result" + std::to_string(i) + ".brep");
		}
		for (int i = 0; i < static_cast<int>(points.size()); i++)
		{
			OCCTIO::OCCTTool::Write(MakeVertex(points[i].first), outdir + "pResult" + std::to_string(i) + ".brep");
		}
	}
	else
	{
		auto [lines, points] = NURBSAPIProject::NURBSProjectCurveOnSurface(bsp, sphere, Direction3(1.0, 0.0, 0.0));
		for (int i = 0; i < static_cast<int>(lines.size()); i++)
		{
			OCCTIO::OCCTTool::Write(MakeEdge(lines[i].first), outdir + "linesResult" + std::to_string(i) + ".brep");
		}
		for (int i = 0; i < static_cast<int>(points.size()); i++)
		{
			OCCTIO::OCCTTool::Write(MakeVertex(points[i].first), outdir + "pointResult" + std::to_string(i) + ".brep");
		}
	}
	OCCTIO::OCCTTool::Write(MakeEdge(bsp), outdir + "src.brep");
	OCCTIO::OCCTTool::Write(MakeVertex(Point3(-10.0, 0.0, 0.0)), outdir + "point.brep");
	OCCTIO::OCCTTool::Write(MakeFace(sphere, 0.0), outdir + "sphere.brep");
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static std::pair<std::vector<std::pair<std::shared_ptr<Geom3Curve>, std::shared_ptr<Geom2Curve>>>, std::vector<std::pair<Point3, Point2>>> NURBSProjectCurveOnSurface(const std::shared_ptr<Geom3Curve>& curve, const std::shared_ptr<Geom3Surface>& surf, const Direction3& dir),
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <nurbs/NURBSAPIProject.hpp>
#include <geometry/Geom3SphericalSurface.hpp>
#include <common/CartesianCoordinateSystem.hpp>
#include <modeling/MakeFace.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeVertex.hpp>
#include <nurbs/NURBSAPIConvert.hpp>
TEST_CASE("bug1: testNURBSAPIProject ", "[nurbs][Project][fixbug]")
{
	OUTPUT_DIRECTORY(nurbs, Project/bug692);
	std::shared_ptr<Geom3SphericalSurface> sphere = std::make_shared<Geom3SphericalSurface>(CartesianCoordinateSystem::XOY(), 3);
	std::vector<Point3> poles;
	poles.push_back(Point3(0., -1., 0.));
	poles.push_back(Point3(.7, -.7, 0.));
	poles.push_back(Point3(1., -.3, 0.));
	poles.push_back(Point3(1.2, 0., 0.));
	poles.push_back(Point3(2., .3, 0.));
	poles.push_back(Point3(.7, 1.7, 0.));
	poles.push_back(Point3(0., 1., 0.));
	std::vector<double> weights;
	weights.push_back(0.9);
	weights.push_back(1.25);
	weights.push_back(1.5);
	weights.push_back(0.75);
	weights.push_back(1.2);
	weights.push_back(1.1);
	weights.push_back(1.3);
	std::vector<double> knots;
	knots.push_back(0.);
	knots.push_back(.25);
	knots.push_back(.5);
	knots.push_back(.75);
	knots.push_back(1.);
	std::vector<int> mults(5, 1);
	mults.front() = 4;
	mults.back() = 4;
	std::shared_ptr<Geom3BSplineCurve> bsp = std::make_shared<Geom3BSplineCurve>(poles, weights, knots, mults, 3);
	Transformation3 trsf;
	trsf.SetDisplacement(CartesianCoordinateSystem::XOY(), Frame3(Point3(-4.0, 0.0, 0.0), Direction3(1.0, 0.0, 0.0), Direction3(0.0, 1.0, 0.0)));
	bsp->Transform(trsf);
	bool isParallel = false;	
	int num = 1000;
	double ratio = 0.1;
	bool res1, res2;
	if (!isParallel)
	{
		auto [lines, points] = NURBSAPIProject::NURBSProjectCurveOnSurface(bsp, sphere, Point3(-10.0, 0.0, 0.0));
		res1 = IsCurveOnSurf(num, ratio, lines[0].first, sphere, -1.0);
		CHECK(res1 == true);
		for (int i = 0; i < static_cast<int>(lines.size()); i++)
		{
			OCCTIO::OCCTTool::Write(MakeEdge(lines[i].first), outdir + "result" + std::to_string(i) + ".brep");
		}
		for (int i = 0; i < static_cast<int>(points.size()); i++)
		{
			OCCTIO::OCCTTool::Write(MakeVertex(points[i].first), outdir + "pResult" + std::to_string(i) + ".brep");
		}
	}
	else
	{
		auto [lines, points] = NURBSAPIProject::NURBSProjectCurveOnSurface(bsp, sphere, Direction3(1.0, 0.0, 0.0));
		for (int i = 0; i < static_cast<int>(lines.size()); i++)
		{
			OCCTIO::OCCTTool::Write(MakeEdge(lines[i].first), outdir + "linesResult" + std::to_string(i) + ".brep");
		}
		for (int i = 0; i < static_cast<int>(points.size()); i++)
		{
			OCCTIO::OCCTTool::Write(MakeVertex(points[i].first), outdir + "pointResult" + std::to_string(i) + ".brep");
		}
	}
	OCCTIO::OCCTTool::Write(MakeEdge(bsp), outdir + "src.brep");
	OCCTIO::OCCTTool::Write(MakeVertex(Point3(-10.0, 0.0, 0.0)), outdir + "point.brep");
	OCCTIO::OCCTTool::Write(MakeFace(sphere, 0.0), outdir + "sphere.brep");
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static std::pair<std::shared_ptr<Geom3BSplineCurve>, double> RebuildCurve(const std::shared_ptr<Geom3BSplineCurve>& srcCurve, int targetDeg, int targetNPoles, bool isForceNonRational)	 @return The rebuilt curve and the error
	 @param isForceNonRational Is result non-rational
	 @param targetNPoles Target number of poles
	 @param targetDeg Target degree
	 @param srcCurve Source curve
	 @brief Rebuild curve with target degree and target number of poles
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <nurbs/NURBSAPIRebuild.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeFace.hpp>
#include <nurbs/NURBSAPISweep.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
#include <modeling/MakeVertex.hpp>
#include <nurbs/NURBSAPIBuildCurve.hpp>
double NurbsCompareCurve(int num, const shared_ptr<Geom3Curve>& curve1, const shared_ptr<Geom3Curve>& curve2)
{
	double maxdist = 0.0;
	const int nsample = num;
	double fp1 = curve1->FirstParameter();
	double lp1 = curve1->LastParameter();
	double delta1 = abs((lp1 - fp1) / nsample);
	Point3 p;
	int n = 0;
	for (int i = 0; i < nsample; i++)
	{
		double t1 = fp1 + i * delta1;
		curve1->D0(t1, p);
		TopoEdge edge = MakeEdge(curve2);
		BRepExtremaDistShapeShape shape(MakeVertex(p), edge);
		double dist = shape.Value();
		if (dist > maxdist)
		{
			maxdist = dist;
		}
	}
	return maxdist;
}
double NurbsCompareSurface(int num, const shared_ptr<Geom3Surface>& surf1, const shared_ptr<Geom3Surface>& surf2)
{
	double maxdist = 0.0;
	const int nsample = num;
	double fpu1 = surf1->FirstUParameter();
	double lpu1 = surf1->LastUParameter();
	double fpv1 = surf1->FirstVParameter();
	double lpv1 = surf1->LastVParameter();
	double deltaU1 = (lpu1 - fpu1) / nsample;
	double deltaV1 = (lpv1 - fpv1) / nsample;
	Point3 p1;
	int n = 0;
	double tu1 = 0.0;
	double tv1 = 0.0;
	for (int i = 0; i < nsample; i++)
	{
		tu1 = fpu1 + i * deltaU1;
		for (int j = 0; j < nsample; j++)
		{
			tv1 = fpv1 + j * deltaV1;
			surf1->D0(tu1, tv1, p1);
			TopoFace face = MakeFace(surf2, 0.0);
			BRepExtremaDistShapeShape shape(MakeVertex(p1), face);
			double dist = shape.Value();
			if (dist > maxdist)
			{
				maxdist = dist;
			}
		}
	}
	return maxdist;
}
#include<catch.hpp>
#include<testHelper.h>
#include <nurbs/NURBSAPIRebuild.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeFace.hpp>
#include <nurbs/NURBSAPISweep.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
#include <modeling/MakeVertex.hpp>
#include <nurbs/NURBSAPIBuildCurve.hpp>
double NurbsCompareCurve(int num, const shared_ptr<Geom3Curve>& curve1, const shared_ptr<Geom3Curve>& curve2)
{
	double maxdist = 0.0;
	const int nsample = num;
	double fp1 = curve1->FirstParameter();
	double lp1 = curve1->LastParameter();
	double delta1 = abs((lp1 - fp1) / nsample);
	Point3 p;
	int n = 0;
	for (int i = 0; i < nsample; i++)
	{
		double t1 = fp1 + i * delta1;
		curve1->D0(t1, p);
		TopoEdge edge = MakeEdge(curve2);
		BRepExtremaDistShapeShape shape(MakeVertex(p), edge);
		double dist = shape.Value();
		if (dist > maxdist)
		{
			maxdist = dist;
		}
	}
	return maxdist;
}
double NurbsCompareSurface(int num, const shared_ptr<Geom3Surface>& surf1, const shared_ptr<Geom3Surface>& surf2)
{
	double maxdist = 0.0;
	const int nsample = num;
	double fpu1 = surf1->FirstUParameter();
	double lpu1 = surf1->LastUParameter();
	double fpv1 = surf1->FirstVParameter();
	double lpv1 = surf1->LastVParameter();
	double deltaU1 = (lpu1 - fpu1) / nsample;
	double deltaV1 = (lpv1 - fpv1) / nsample;
	Point3 p1;
	int n = 0;
	double tu1 = 0.0;
	double tv1 = 0.0;
	for (int i = 0; i < nsample; i++)
	{
		tu1 = fpu1 + i * deltaU1;
		for (int j = 0; j < nsample; j++)
		{
			tv1 = fpv1 + j * deltaV1;
			surf1->D0(tu1, tv1, p1);
			TopoFace face = MakeFace(surf2, 0.0);
			BRepExtremaDistShapeShape shape(MakeVertex(p1), face);
			double dist = shape.Value();
			if (dist > maxdist)
			{
				maxdist = dist;
			}
		}
	}
	return maxdist;
;
	SECTION("TestRebuildCurve")
	{
		OUTPUT_DIRECTORY(nurbs, Rebuild/RebuildCurve);
		int deg = 3;
		std::vector<Point3> poles;
		poles.push_back(Point3(0., -1., 0.));
		poles.push_back(Point3(.7, -.7, 0.));
		poles.push_back(Point3(1., -.3, 0.));
		poles.push_back(Point3(1.2, 0., 0.));
		poles.push_back(Point3(2., .3, 0.));
		poles.push_back(Point3(.7, 1.7, 0.));
		poles.push_back(Point3(0., 1., 0.));
		std::vector<double> weights;
		weights.push_back(0.8);
		weights.push_back(0.9);
		weights.push_back(1.1);
		weights.push_back(0.3);
		weights.push_back(0.6);
		weights.push_back(1.2);
		weights.push_back(0.8);
		int nknots = static_cast<int>(poles.size()) - deg + 1;
		std::vector<double> knots(nknots);
		for (int i = 0; i < nknots; i++)
		{
			knots[i] = (double)i / (double)(nknots - 1);
		}
		std::vector<int> mults(nknots, 1);
		mults.front() = deg + 1;
		mults.back() = deg + 1;
		auto bsp = std::make_shared<Geom3BSplineCurve>(poles, weights, knots, mults, deg);
		auto [result, error] = NURBSAPIRebuild::RebuildCurve(bsp, 3, 15, false);
		CHECK(bsp->Degree() == 3);
		CHECK(bsp->NKnots() == 5);
		CHECK(bsp->NPoles() == 7);
		CHECK(result->Degree() == 3);
		CHECK(result->NKnots() == 13);
		CHECK(result->NPoles() == 15);
		double dist = NurbsCompareCurve(num, bsp, result);
		double res = abs(dist - error);
		CHECK(res <= val);
		OCCTIO::OCCTTool::Write(MakeEdge(bsp), outdir + "src.brep");
		OCCTIO::OCCTTool::Write(MakeEdge(result), outdir + "result.brep");
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static std::pair<std::shared_ptr<Geom3BSplineCurve>, double> RebuildCurve(const std::shared_ptr<Geom3BSplineCurve>& srcCurve, int targetDeg, int targetNPoles, bool isForceNonRational, const std::vector<double>& knots, const std::vector<int>& mults)	 @return The rebuilt curve and the error
	 @param mults Target mults
	 @param knots Target knots
	 @param isForceNonRational Is result non-rational
	 @param targetNPoles Target number of poles
	 @param targetDeg Target degree
	 @param srcCurve Source curve
	 @brief Rebuild curve with target degree, target number of poles, target uv knots and mults
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <nurbs/NURBSAPIRebuild.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeFace.hpp>
#include <nurbs/NURBSAPISweep.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
#include <modeling/MakeVertex.hpp>
#include <nurbs/NURBSAPIBuildCurve.hpp>
double NurbsCompareCurve(int num, const shared_ptr<Geom3Curve>& curve1, const shared_ptr<Geom3Curve>& curve2)
{
	double maxdist = 0.0;
	const int nsample = num;
	double fp1 = curve1->FirstParameter();
	double lp1 = curve1->LastParameter();
	double delta1 = abs((lp1 - fp1) / nsample);
	Point3 p;
	int n = 0;
	for (int i = 0; i < nsample; i++)
	{
		double t1 = fp1 + i * delta1;
		curve1->D0(t1, p);
		TopoEdge edge = MakeEdge(curve2);
		BRepExtremaDistShapeShape shape(MakeVertex(p), edge);
		double dist = shape.Value();
		if (dist > maxdist)
		{
			maxdist = dist;
		}
	}
	return maxdist;
}
double NurbsCompareSurface(int num, const shared_ptr<Geom3Surface>& surf1, const shared_ptr<Geom3Surface>& surf2)
{
	double maxdist = 0.0;
	const int nsample = num;
	double fpu1 = surf1->FirstUParameter();
	double lpu1 = surf1->LastUParameter();
	double fpv1 = surf1->FirstVParameter();
	double lpv1 = surf1->LastVParameter();
	double deltaU1 = (lpu1 - fpu1) / nsample;
	double deltaV1 = (lpv1 - fpv1) / nsample;
	Point3 p1;
	int n = 0;
	double tu1 = 0.0;
	double tv1 = 0.0;
	for (int i = 0; i < nsample; i++)
	{
		tu1 = fpu1 + i * deltaU1;
		for (int j = 0; j < nsample; j++)
		{
			tv1 = fpv1 + j * deltaV1;
			surf1->D0(tu1, tv1, p1);
			TopoFace face = MakeFace(surf2, 0.0);
			BRepExtremaDistShapeShape shape(MakeVertex(p1), face);
			double dist = shape.Value();
			if (dist > maxdist)
			{
				maxdist = dist;
			}
		}
	}
	return maxdist;
}
#include<catch.hpp>
#include<testHelper.h>
#include <nurbs/NURBSAPIRebuild.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeFace.hpp>
#include <nurbs/NURBSAPISweep.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
#include <modeling/MakeVertex.hpp>
#include <nurbs/NURBSAPIBuildCurve.hpp>
double NurbsCompareCurve(int num, const shared_ptr<Geom3Curve>& curve1, const shared_ptr<Geom3Curve>& curve2)
{
	double maxdist = 0.0;
	const int nsample = num;
	double fp1 = curve1->FirstParameter();
	double lp1 = curve1->LastParameter();
	double delta1 = abs((lp1 - fp1) / nsample);
	Point3 p;
	int n = 0;
	for (int i = 0; i < nsample; i++)
	{
		double t1 = fp1 + i * delta1;
		curve1->D0(t1, p);
		TopoEdge edge = MakeEdge(curve2);
		BRepExtremaDistShapeShape shape(MakeVertex(p), edge);
		double dist = shape.Value();
		if (dist > maxdist)
		{
			maxdist = dist;
		}
	}
	return maxdist;
}
double NurbsCompareSurface(int num, const shared_ptr<Geom3Surface>& surf1, const shared_ptr<Geom3Surface>& surf2)
{
	double maxdist = 0.0;
	const int nsample = num;
	double fpu1 = surf1->FirstUParameter();
	double lpu1 = surf1->LastUParameter();
	double fpv1 = surf1->FirstVParameter();
	double lpv1 = surf1->LastVParameter();
	double deltaU1 = (lpu1 - fpu1) / nsample;
	double deltaV1 = (lpv1 - fpv1) / nsample;
	Point3 p1;
	int n = 0;
	double tu1 = 0.0;
	double tv1 = 0.0;
	for (int i = 0; i < nsample; i++)
	{
		tu1 = fpu1 + i * deltaU1;
		for (int j = 0; j < nsample; j++)
		{
			tv1 = fpv1 + j * deltaV1;
			surf1->D0(tu1, tv1, p1);
			TopoFace face = MakeFace(surf2, 0.0);
			BRepExtremaDistShapeShape shape(MakeVertex(p1), face);
			double dist = shape.Value();
			if (dist > maxdist)
			{
				maxdist = dist;
			}
		}
	}
	return maxdist;
;
	SECTION("TestRebuildCurve")
	{
		OUTPUT_DIRECTORY(nurbs, Rebuild/RebuildCurve);
		int deg = 3;
		std::vector<Point3> poles;
		poles.push_back(Point3(0., -1., 0.));
		poles.push_back(Point3(.7, -.7, 0.));
		poles.push_back(Point3(1., -.3, 0.));
		poles.push_back(Point3(1.2, 0., 0.));
		poles.push_back(Point3(2., .3, 0.));
		poles.push_back(Point3(.7, 1.7, 0.));
		poles.push_back(Point3(0., 1., 0.));
		std::vector<double> weights;
		weights.push_back(0.8);
		weights.push_back(0.9);
		weights.push_back(1.1);
		weights.push_back(0.3);
		weights.push_back(0.6);
		weights.push_back(1.2);
		weights.push_back(0.8);
		int nknots = static_cast<int>(poles.size()) - deg + 1;
		std::vector<double> knots(nknots);
		for (int i = 0; i < nknots; i++)
		{
			knots[i] = (double)i / (double)(nknots - 1);
		}
		std::vector<int> mults(nknots, 1);
		mults.front() = deg + 1;
		mults.back() = deg + 1;
		auto bsp = std::make_shared<Geom3BSplineCurve>(poles, weights, knots, mults, deg);
		auto [result, error] = NURBSAPIRebuild::RebuildCurve(bsp, 3, 15, false);
		CHECK(bsp->Degree() == 3);
		CHECK(bsp->NKnots() == 5);
		CHECK(bsp->NPoles() == 7);
		CHECK(result->Degree() == 3);
		CHECK(result->NKnots() == 13);
		CHECK(result->NPoles() == 15);
		double dist = NurbsCompareCurve(num, bsp, result);
		double res = abs(dist - error);
		CHECK(res <= val);
		OCCTIO::OCCTTool::Write(MakeEdge(bsp), outdir + "src.brep");
		OCCTIO::OCCTTool::Write(MakeEdge(result), outdir + "result.brep");
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static std::pair<std::shared_ptr<Geom3BSplineCurve>, double> RebuildCurve(const std::shared_ptr<Geom3BSplineCurve>& srcCurve, int targetDeg, double tol, bool isForceNonRational)	 @return The rebuilt curve and the error
	 @param isForceNonRational Is result non-rational
	 @param tol The tolerance of source curve and result curve. It is usally set over 1e-2 to guarantee the time performance
	 @param targetDeg Target degree
	 @param srcCurve Source curve
	 @brief Rebuild curve with target degree and target tolerance.
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <nurbs/NURBSAPIRebuild.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeFace.hpp>
#include <nurbs/NURBSAPISweep.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
#include <modeling/MakeVertex.hpp>
#include <nurbs/NURBSAPIBuildCurve.hpp>
double NurbsCompareCurve(int num, const shared_ptr<Geom3Curve>& curve1, const shared_ptr<Geom3Curve>& curve2)
{
	double maxdist = 0.0;
	const int nsample = num;
	double fp1 = curve1->FirstParameter();
	double lp1 = curve1->LastParameter();
	double delta1 = abs((lp1 - fp1) / nsample);
	Point3 p;
	int n = 0;
	for (int i = 0; i < nsample; i++)
	{
		double t1 = fp1 + i * delta1;
		curve1->D0(t1, p);
		TopoEdge edge = MakeEdge(curve2);
		BRepExtremaDistShapeShape shape(MakeVertex(p), edge);
		double dist = shape.Value();
		if (dist > maxdist)
		{
			maxdist = dist;
		}
	}
	return maxdist;
}
double NurbsCompareSurface(int num, const shared_ptr<Geom3Surface>& surf1, const shared_ptr<Geom3Surface>& surf2)
{
	double maxdist = 0.0;
	const int nsample = num;
	double fpu1 = surf1->FirstUParameter();
	double lpu1 = surf1->LastUParameter();
	double fpv1 = surf1->FirstVParameter();
	double lpv1 = surf1->LastVParameter();
	double deltaU1 = (lpu1 - fpu1) / nsample;
	double deltaV1 = (lpv1 - fpv1) / nsample;
	Point3 p1;
	int n = 0;
	double tu1 = 0.0;
	double tv1 = 0.0;
	for (int i = 0; i < nsample; i++)
	{
		tu1 = fpu1 + i * deltaU1;
		for (int j = 0; j < nsample; j++)
		{
			tv1 = fpv1 + j * deltaV1;
			surf1->D0(tu1, tv1, p1);
			TopoFace face = MakeFace(surf2, 0.0);
			BRepExtremaDistShapeShape shape(MakeVertex(p1), face);
			double dist = shape.Value();
			if (dist > maxdist)
			{
				maxdist = dist;
			}
		}
	}
	return maxdist;
}
#include<catch.hpp>
#include<testHelper.h>
#include <nurbs/NURBSAPIRebuild.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeFace.hpp>
#include <nurbs/NURBSAPISweep.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
#include <modeling/MakeVertex.hpp>
#include <nurbs/NURBSAPIBuildCurve.hpp>
double NurbsCompareCurve(int num, const shared_ptr<Geom3Curve>& curve1, const shared_ptr<Geom3Curve>& curve2)
{
	double maxdist = 0.0;
	const int nsample = num;
	double fp1 = curve1->FirstParameter();
	double lp1 = curve1->LastParameter();
	double delta1 = abs((lp1 - fp1) / nsample);
	Point3 p;
	int n = 0;
	for (int i = 0; i < nsample; i++)
	{
		double t1 = fp1 + i * delta1;
		curve1->D0(t1, p);
		TopoEdge edge = MakeEdge(curve2);
		BRepExtremaDistShapeShape shape(MakeVertex(p), edge);
		double dist = shape.Value();
		if (dist > maxdist)
		{
			maxdist = dist;
		}
	}
	return maxdist;
}
double NurbsCompareSurface(int num, const shared_ptr<Geom3Surface>& surf1, const shared_ptr<Geom3Surface>& surf2)
{
	double maxdist = 0.0;
	const int nsample = num;
	double fpu1 = surf1->FirstUParameter();
	double lpu1 = surf1->LastUParameter();
	double fpv1 = surf1->FirstVParameter();
	double lpv1 = surf1->LastVParameter();
	double deltaU1 = (lpu1 - fpu1) / nsample;
	double deltaV1 = (lpv1 - fpv1) / nsample;
	Point3 p1;
	int n = 0;
	double tu1 = 0.0;
	double tv1 = 0.0;
	for (int i = 0; i < nsample; i++)
	{
		tu1 = fpu1 + i * deltaU1;
		for (int j = 0; j < nsample; j++)
		{
			tv1 = fpv1 + j * deltaV1;
			surf1->D0(tu1, tv1, p1);
			TopoFace face = MakeFace(surf2, 0.0);
			BRepExtremaDistShapeShape shape(MakeVertex(p1), face);
			double dist = shape.Value();
			if (dist > maxdist)
			{
				maxdist = dist;
			}
		}
	}
	return maxdist;
;
	SECTION("TestRebuildCurve")
	{
		OUTPUT_DIRECTORY(nurbs, Rebuild/RebuildCurve);
		int deg = 3;
		std::vector<Point3> poles;
		poles.push_back(Point3(0., -1., 0.));
		poles.push_back(Point3(.7, -.7, 0.));
		poles.push_back(Point3(1., -.3, 0.));
		poles.push_back(Point3(1.2, 0., 0.));
		poles.push_back(Point3(2., .3, 0.));
		poles.push_back(Point3(.7, 1.7, 0.));
		poles.push_back(Point3(0., 1., 0.));
		std::vector<double> weights;
		weights.push_back(0.8);
		weights.push_back(0.9);
		weights.push_back(1.1);
		weights.push_back(0.3);
		weights.push_back(0.6);
		weights.push_back(1.2);
		weights.push_back(0.8);
		int nknots = static_cast<int>(poles.size()) - deg + 1;
		std::vector<double> knots(nknots);
		for (int i = 0; i < nknots; i++)
		{
			knots[i] = (double)i / (double)(nknots - 1);
		}
		std::vector<int> mults(nknots, 1);
		mults.front() = deg + 1;
		mults.back() = deg + 1;
		auto bsp = std::make_shared<Geom3BSplineCurve>(poles, weights, knots, mults, deg);
		auto [result, error] = NURBSAPIRebuild::RebuildCurve(bsp, 3, 15, false);
		CHECK(bsp->Degree() == 3);
		CHECK(bsp->NKnots() == 5);
		CHECK(bsp->NPoles() == 7);
		CHECK(result->Degree() == 3);
		CHECK(result->NKnots() == 13);
		CHECK(result->NPoles() == 15);
		double dist = NurbsCompareCurve(num, bsp, result);
		double res = abs(dist - error);
		CHECK(res <= val);
		OCCTIO::OCCTTool::Write(MakeEdge(bsp), outdir + "src.brep");
		OCCTIO::OCCTTool::Write(MakeEdge(result), outdir + "result.brep");
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static std::pair<std::shared_ptr<Geom2BSplineCurve>, double> RebuildCurve(const std::shared_ptr<Geom2BSplineCurve>& srcCurve, int targetDeg, double tol, bool isForceNonRational)	 @return The rebuilt curve and the error
	 @param isForceNonRational Is result non-rational
	 @param tol The tolerance of source curve and result curve. It is usally set over 1e-2 to guarantee the time performance
	 @param targetDeg Target degree
	 @param srcCurve Source curve
	 @brief Rebuild 2d curve with target degree and target tolerance.
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <nurbs/NURBSAPIRebuild.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeFace.hpp>
#include <nurbs/NURBSAPISweep.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
#include <modeling/MakeVertex.hpp>
#include <nurbs/NURBSAPIBuildCurve.hpp>
double NurbsCompareCurve(int num, const shared_ptr<Geom3Curve>& curve1, const shared_ptr<Geom3Curve>& curve2)
{
	double maxdist = 0.0;
	const int nsample = num;
	double fp1 = curve1->FirstParameter();
	double lp1 = curve1->LastParameter();
	double delta1 = abs((lp1 - fp1) / nsample);
	Point3 p;
	int n = 0;
	for (int i = 0; i < nsample; i++)
	{
		double t1 = fp1 + i * delta1;
		curve1->D0(t1, p);
		TopoEdge edge = MakeEdge(curve2);
		BRepExtremaDistShapeShape shape(MakeVertex(p), edge);
		double dist = shape.Value();
		if (dist > maxdist)
		{
			maxdist = dist;
		}
	}
	return maxdist;
}
double NurbsCompareSurface(int num, const shared_ptr<Geom3Surface>& surf1, const shared_ptr<Geom3Surface>& surf2)
{
	double maxdist = 0.0;
	const int nsample = num;
	double fpu1 = surf1->FirstUParameter();
	double lpu1 = surf1->LastUParameter();
	double fpv1 = surf1->FirstVParameter();
	double lpv1 = surf1->LastVParameter();
	double deltaU1 = (lpu1 - fpu1) / nsample;
	double deltaV1 = (lpv1 - fpv1) / nsample;
	Point3 p1;
	int n = 0;
	double tu1 = 0.0;
	double tv1 = 0.0;
	for (int i = 0; i < nsample; i++)
	{
		tu1 = fpu1 + i * deltaU1;
		for (int j = 0; j < nsample; j++)
		{
			tv1 = fpv1 + j * deltaV1;
			surf1->D0(tu1, tv1, p1);
			TopoFace face = MakeFace(surf2, 0.0);
			BRepExtremaDistShapeShape shape(MakeVertex(p1), face);
			double dist = shape.Value();
			if (dist > maxdist)
			{
				maxdist = dist;
			}
		}
	}
	return maxdist;
}
#include<catch.hpp>
#include<testHelper.h>
#include <nurbs/NURBSAPIRebuild.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeFace.hpp>
#include <nurbs/NURBSAPISweep.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
#include <modeling/MakeVertex.hpp>
#include <nurbs/NURBSAPIBuildCurve.hpp>
double NurbsCompareCurve(int num, const shared_ptr<Geom3Curve>& curve1, const shared_ptr<Geom3Curve>& curve2)
{
	double maxdist = 0.0;
	const int nsample = num;
	double fp1 = curve1->FirstParameter();
	double lp1 = curve1->LastParameter();
	double delta1 = abs((lp1 - fp1) / nsample);
	Point3 p;
	int n = 0;
	for (int i = 0; i < nsample; i++)
	{
		double t1 = fp1 + i * delta1;
		curve1->D0(t1, p);
		TopoEdge edge = MakeEdge(curve2);
		BRepExtremaDistShapeShape shape(MakeVertex(p), edge);
		double dist = shape.Value();
		if (dist > maxdist)
		{
			maxdist = dist;
		}
	}
	return maxdist;
}
double NurbsCompareSurface(int num, const shared_ptr<Geom3Surface>& surf1, const shared_ptr<Geom3Surface>& surf2)
{
	double maxdist = 0.0;
	const int nsample = num;
	double fpu1 = surf1->FirstUParameter();
	double lpu1 = surf1->LastUParameter();
	double fpv1 = surf1->FirstVParameter();
	double lpv1 = surf1->LastVParameter();
	double deltaU1 = (lpu1 - fpu1) / nsample;
	double deltaV1 = (lpv1 - fpv1) / nsample;
	Point3 p1;
	int n = 0;
	double tu1 = 0.0;
	double tv1 = 0.0;
	for (int i = 0; i < nsample; i++)
	{
		tu1 = fpu1 + i * deltaU1;
		for (int j = 0; j < nsample; j++)
		{
			tv1 = fpv1 + j * deltaV1;
			surf1->D0(tu1, tv1, p1);
			TopoFace face = MakeFace(surf2, 0.0);
			BRepExtremaDistShapeShape shape(MakeVertex(p1), face);
			double dist = shape.Value();
			if (dist > maxdist)
			{
				maxdist = dist;
			}
		}
	}
	return maxdist;
;
	SECTION("TestRebuildCurve")
	{
		OUTPUT_DIRECTORY(nurbs, Rebuild/RebuildCurve);
		int deg = 3;
		std::vector<Point3> poles;
		poles.push_back(Point3(0., -1., 0.));
		poles.push_back(Point3(.7, -.7, 0.));
		poles.push_back(Point3(1., -.3, 0.));
		poles.push_back(Point3(1.2, 0., 0.));
		poles.push_back(Point3(2., .3, 0.));
		poles.push_back(Point3(.7, 1.7, 0.));
		poles.push_back(Point3(0., 1., 0.));
		std::vector<double> weights;
		weights.push_back(0.8);
		weights.push_back(0.9);
		weights.push_back(1.1);
		weights.push_back(0.3);
		weights.push_back(0.6);
		weights.push_back(1.2);
		weights.push_back(0.8);
		int nknots = static_cast<int>(poles.size()) - deg + 1;
		std::vector<double> knots(nknots);
		for (int i = 0; i < nknots; i++)
		{
			knots[i] = (double)i / (double)(nknots - 1);
		}
		std::vector<int> mults(nknots, 1);
		mults.front() = deg + 1;
		mults.back() = deg + 1;
		auto bsp = std::make_shared<Geom3BSplineCurve>(poles, weights, knots, mults, deg);
		auto [result, error] = NURBSAPIRebuild::RebuildCurve(bsp, 3, 15, false);
		CHECK(bsp->Degree() == 3);
		CHECK(bsp->NKnots() == 5);
		CHECK(bsp->NPoles() == 7);
		CHECK(result->Degree() == 3);
		CHECK(result->NKnots() == 13);
		CHECK(result->NPoles() == 15);
		double dist = NurbsCompareCurve(num, bsp, result);
		double res = abs(dist - error);
		CHECK(res <= val);
		OCCTIO::OCCTTool::Write(MakeEdge(bsp), outdir + "src.brep");
		OCCTIO::OCCTTool::Write(MakeEdge(result), outdir + "result.brep");
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static std::pair<std::shared_ptr<Geom3BSplineSurface>, double> RebuildSurface(const std::shared_ptr<Geom3BSplineSurface>& srcSurf, int targetUDeg, int targetVDeg, int targetNUPoles, int targetNVPoles)	 @return The rebuit surface and the error
	 @param targetNVPoles Target number of v poles
	 @param targetNUPoles Target number of u poles
	 @param targetVDeg Target v degree
	 @param targetUDeg Target u degree
	 @param srcSurf Source surface
	 @brief Rebuild surface with target degree and target number of poles
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <nurbs/NURBSAPIRebuild.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeFace.hpp>
#include <nurbs/NURBSAPISweep.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
#include <modeling/MakeVertex.hpp>
#include <nurbs/NURBSAPIBuildCurve.hpp>
double NurbsCompareCurve(int num, const shared_ptr<Geom3Curve>& curve1, const shared_ptr<Geom3Curve>& curve2)
{
	double maxdist = 0.0;
	const int nsample = num;
	double fp1 = curve1->FirstParameter();
	double lp1 = curve1->LastParameter();
	double delta1 = abs((lp1 - fp1) / nsample);
	Point3 p;
	int n = 0;
	for (int i = 0; i < nsample; i++)
	{
		double t1 = fp1 + i * delta1;
		curve1->D0(t1, p);
		TopoEdge edge = MakeEdge(curve2);
		BRepExtremaDistShapeShape shape(MakeVertex(p), edge);
		double dist = shape.Value();
		if (dist > maxdist)
		{
			maxdist = dist;
		}
	}
	return maxdist;
}
double NurbsCompareSurface(int num, const shared_ptr<Geom3Surface>& surf1, const shared_ptr<Geom3Surface>& surf2)
{
	double maxdist = 0.0;
	const int nsample = num;
	double fpu1 = surf1->FirstUParameter();
	double lpu1 = surf1->LastUParameter();
	double fpv1 = surf1->FirstVParameter();
	double lpv1 = surf1->LastVParameter();
	double deltaU1 = (lpu1 - fpu1) / nsample;
	double deltaV1 = (lpv1 - fpv1) / nsample;
	Point3 p1;
	int n = 0;
	double tu1 = 0.0;
	double tv1 = 0.0;
	for (int i = 0; i < nsample; i++)
	{
		tu1 = fpu1 + i * deltaU1;
		for (int j = 0; j < nsample; j++)
		{
			tv1 = fpv1 + j * deltaV1;
			surf1->D0(tu1, tv1, p1);
			TopoFace face = MakeFace(surf2, 0.0);
			BRepExtremaDistShapeShape shape(MakeVertex(p1), face);
			double dist = shape.Value();
			if (dist > maxdist)
			{
				maxdist = dist;
			}
		}
	}
	return maxdist;
}
#include<catch.hpp>
#include<testHelper.h>
#include <nurbs/NURBSAPIRebuild.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeFace.hpp>
#include <nurbs/NURBSAPISweep.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
#include <modeling/MakeVertex.hpp>
#include <nurbs/NURBSAPIBuildCurve.hpp>
double NurbsCompareCurve(int num, const shared_ptr<Geom3Curve>& curve1, const shared_ptr<Geom3Curve>& curve2)
{
	double maxdist = 0.0;
	const int nsample = num;
	double fp1 = curve1->FirstParameter();
	double lp1 = curve1->LastParameter();
	double delta1 = abs((lp1 - fp1) / nsample);
	Point3 p;
	int n = 0;
	for (int i = 0; i < nsample; i++)
	{
		double t1 = fp1 + i * delta1;
		curve1->D0(t1, p);
		TopoEdge edge = MakeEdge(curve2);
		BRepExtremaDistShapeShape shape(MakeVertex(p), edge);
		double dist = shape.Value();
		if (dist > maxdist)
		{
			maxdist = dist;
		}
	}
	return maxdist;
}
double NurbsCompareSurface(int num, const shared_ptr<Geom3Surface>& surf1, const shared_ptr<Geom3Surface>& surf2)
{
	double maxdist = 0.0;
	const int nsample = num;
	double fpu1 = surf1->FirstUParameter();
	double lpu1 = surf1->LastUParameter();
	double fpv1 = surf1->FirstVParameter();
	double lpv1 = surf1->LastVParameter();
	double deltaU1 = (lpu1 - fpu1) / nsample;
	double deltaV1 = (lpv1 - fpv1) / nsample;
	Point3 p1;
	int n = 0;
	double tu1 = 0.0;
	double tv1 = 0.0;
	for (int i = 0; i < nsample; i++)
	{
		tu1 = fpu1 + i * deltaU1;
		for (int j = 0; j < nsample; j++)
		{
			tv1 = fpv1 + j * deltaV1;
			surf1->D0(tu1, tv1, p1);
			TopoFace face = MakeFace(surf2, 0.0);
			BRepExtremaDistShapeShape shape(MakeVertex(p1), face);
			double dist = shape.Value();
			if (dist > maxdist)
			{
				maxdist = dist;
			}
		}
	}
	return maxdist;
;
	SECTION("TestRebuildSurface")
	{
		OUTPUT_DIRECTORY(nurbs, Rebuild/bug735/RebuildSurface);
		std::shared_ptr<Geom3BSplineCurve> bsp1, bsp2;
		{
			int deg = 3;
			std::vector<Point3> poles;
			poles.push_back(Point3(0.0, -1.0, 0.0));
			poles.push_back(Point3(0.7, -0.7, 0.0));
			poles.push_back(Point3(1.0, -0.3, 0.0));
			poles.push_back(Point3(1.2, 0.0, 0.0));
			poles.push_back(Point3(2.0, 0.3, 0.0));
			poles.push_back(Point3(0.7, 1.7, 0.0));
			poles.push_back(Point3(0.0, 1.0, 0.0));
			std::vector<double> weights;
			weights.push_back(1.0);
			weights.push_back(1.2);
			weights.push_back(1.5);
			weights.push_back(1.0);
			weights.push_back(1.1);
			weights.push_back(1.3);
			weights.push_back(1.0);
			int nknots = static_cast<int>(poles.size()) - deg + 1;
			std::vector<double> knots(nknots);
			for (int i = 0; i < nknots; i++)
			{
				knots[i] = (double)i / (double)(nknots - 1.0);
			}
			std::vector<int> mults(nknots, 1);
			mults.front() = 4;
			mults.back() = 4;
			bsp1 = std::make_shared<Geom3BSplineCurve>(poles, weights, knots, mults, deg);
		}
		{
			std::vector<Point3> spinePoles;
			std::vector<double> spineKnots(4);
			std::vector<int> spineMults(4, 1);
			spinePoles.push_back(Point3(0.0, -1.0, 0.0));
			spinePoles.push_back(Point3(-0.1, -0.8, 1.0));
			spinePoles.push_back(Point3(0.1, -0.5, 2.0));
			spinePoles.push_back(Point3(0.2, -0.7, 3.0));
			spinePoles.push_back(Point3(0.1, -0.9, 3.5));
			spinePoles.push_back(Point3(0.0, -1.1, 4.5));
			std::vector<double> weights;
			weights.push_back(1.4);
			weights.push_back(1.7);
			weights.push_back(1.1);
			weights.push_back(1.3);
			weights.push_back(1.0);
			weights.push_back(0.9);
			spineKnots[0] = 0;
			spineKnots[1] = 1.0 / 3.0;
			spineKnots[2] = 2.0 / 3.0;
			spineKnots[3] = 1;
			spineMults.front() = 4;
			spineMults.back() = 4;
			bsp2 = std::make_shared<Geom3BSplineCurve>(spinePoles, weights, spineKnots, spineMults, 3);
		}
		bool isParallel = false;
		auto tmp = NURBSAPISweep::SweepOneRail(bsp1, bsp2, isParallel);
		const auto& bsp3 = tmp[0];
		clock_t bg = clock();
		auto [oldbsp4, olderr] = NURBSAPIRebuild::RebuildSurface(bsp3, 3, 3, 20, 10);
		clock_t ed = clock();
		auto [bsp4, err] = NURBSAPIRebuild::RebuildSurface(bsp3, 11, 11, 30, 20);
		CHECK(bsp4->UDegree() == 11);
		CHECK(bsp4->VDegree() == 11);
		CHECK(bsp4->NUPoles() == 30);
		CHECK(bsp4->NVPoles() == 20);
		OCCTIO::OCCTTool::Write(MakeEdge(bsp1), outdir + "bsp11.brep");
		OCCTIO::OCCTTool::Write(MakeEdge(bsp2), outdir + "bsp21.brep");
		OCCTIO::OCCTTool::Write(MakeFace(bsp3, 0.0), outdir + "src1.brep");
		OCCTIO::OCCTTool::Write(MakeFace(bsp4, 0.0), outdir + "result1.brep");
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static std::pair<std::shared_ptr<Geom3BSplineSurface>, double> RebuildSurface(const std::shared_ptr<Geom3BSplineSurface>& srcSurf, int targetUDeg, int targetVDeg, int targetNUPoles, int targetNVPoles, const std::vector<double>& uknots, const std::vector<double>& vknots, const std::vector<int>& umults, const std::vector<int>& vmults)	 @return The rebuit surface and the error
	 @param vmults Target v multipicities
	 @param umults Target u multipicities
	 @param vknots Target v knots
	 @param uknots Target u knots
	 @param targetNVPoles Target number of v poles
	 @param targetNUPoles Target number of u poles
	 @param targetVDeg Target v degree
	 @param targetUDeg Target u degree
	 @param srcSurf Source surface
	 @brief Rebuild surface with target degree, target number of poles, target uv knots and mults
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <nurbs/NURBSAPIRebuild.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeFace.hpp>
#include <nurbs/NURBSAPISweep.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
#include <modeling/MakeVertex.hpp>
#include <nurbs/NURBSAPIBuildCurve.hpp>
double NurbsCompareCurve(int num, const shared_ptr<Geom3Curve>& curve1, const shared_ptr<Geom3Curve>& curve2)
{
	double maxdist = 0.0;
	const int nsample = num;
	double fp1 = curve1->FirstParameter();
	double lp1 = curve1->LastParameter();
	double delta1 = abs((lp1 - fp1) / nsample);
	Point3 p;
	int n = 0;
	for (int i = 0; i < nsample; i++)
	{
		double t1 = fp1 + i * delta1;
		curve1->D0(t1, p);
		TopoEdge edge = MakeEdge(curve2);
		BRepExtremaDistShapeShape shape(MakeVertex(p), edge);
		double dist = shape.Value();
		if (dist > maxdist)
		{
			maxdist = dist;
		}
	}
	return maxdist;
}
double NurbsCompareSurface(int num, const shared_ptr<Geom3Surface>& surf1, const shared_ptr<Geom3Surface>& surf2)
{
	double maxdist = 0.0;
	const int nsample = num;
	double fpu1 = surf1->FirstUParameter();
	double lpu1 = surf1->LastUParameter();
	double fpv1 = surf1->FirstVParameter();
	double lpv1 = surf1->LastVParameter();
	double deltaU1 = (lpu1 - fpu1) / nsample;
	double deltaV1 = (lpv1 - fpv1) / nsample;
	Point3 p1;
	int n = 0;
	double tu1 = 0.0;
	double tv1 = 0.0;
	for (int i = 0; i < nsample; i++)
	{
		tu1 = fpu1 + i * deltaU1;
		for (int j = 0; j < nsample; j++)
		{
			tv1 = fpv1 + j * deltaV1;
			surf1->D0(tu1, tv1, p1);
			TopoFace face = MakeFace(surf2, 0.0);
			BRepExtremaDistShapeShape shape(MakeVertex(p1), face);
			double dist = shape.Value();
			if (dist > maxdist)
			{
				maxdist = dist;
			}
		}
	}
	return maxdist;
}
#include<catch.hpp>
#include<testHelper.h>
#include <nurbs/NURBSAPIRebuild.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeFace.hpp>
#include <nurbs/NURBSAPISweep.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
#include <modeling/MakeVertex.hpp>
#include <nurbs/NURBSAPIBuildCurve.hpp>
double NurbsCompareCurve(int num, const shared_ptr<Geom3Curve>& curve1, const shared_ptr<Geom3Curve>& curve2)
{
	double maxdist = 0.0;
	const int nsample = num;
	double fp1 = curve1->FirstParameter();
	double lp1 = curve1->LastParameter();
	double delta1 = abs((lp1 - fp1) / nsample);
	Point3 p;
	int n = 0;
	for (int i = 0; i < nsample; i++)
	{
		double t1 = fp1 + i * delta1;
		curve1->D0(t1, p);
		TopoEdge edge = MakeEdge(curve2);
		BRepExtremaDistShapeShape shape(MakeVertex(p), edge);
		double dist = shape.Value();
		if (dist > maxdist)
		{
			maxdist = dist;
		}
	}
	return maxdist;
}
double NurbsCompareSurface(int num, const shared_ptr<Geom3Surface>& surf1, const shared_ptr<Geom3Surface>& surf2)
{
	double maxdist = 0.0;
	const int nsample = num;
	double fpu1 = surf1->FirstUParameter();
	double lpu1 = surf1->LastUParameter();
	double fpv1 = surf1->FirstVParameter();
	double lpv1 = surf1->LastVParameter();
	double deltaU1 = (lpu1 - fpu1) / nsample;
	double deltaV1 = (lpv1 - fpv1) / nsample;
	Point3 p1;
	int n = 0;
	double tu1 = 0.0;
	double tv1 = 0.0;
	for (int i = 0; i < nsample; i++)
	{
		tu1 = fpu1 + i * deltaU1;
		for (int j = 0; j < nsample; j++)
		{
			tv1 = fpv1 + j * deltaV1;
			surf1->D0(tu1, tv1, p1);
			TopoFace face = MakeFace(surf2, 0.0);
			BRepExtremaDistShapeShape shape(MakeVertex(p1), face);
			double dist = shape.Value();
			if (dist > maxdist)
			{
				maxdist = dist;
			}
		}
	}
	return maxdist;
;
	SECTION("TestRebuildSurface")
	{
		OUTPUT_DIRECTORY(nurbs, Rebuild/bug735/RebuildSurface);
		std::shared_ptr<Geom3BSplineCurve> bsp1, bsp2;
		{
			int deg = 3;
			std::vector<Point3> poles;
			poles.push_back(Point3(0.0, -1.0, 0.0));
			poles.push_back(Point3(0.7, -0.7, 0.0));
			poles.push_back(Point3(1.0, -0.3, 0.0));
			poles.push_back(Point3(1.2, 0.0, 0.0));
			poles.push_back(Point3(2.0, 0.3, 0.0));
			poles.push_back(Point3(0.7, 1.7, 0.0));
			poles.push_back(Point3(0.0, 1.0, 0.0));
			std::vector<double> weights;
			weights.push_back(1.0);
			weights.push_back(1.2);
			weights.push_back(1.5);
			weights.push_back(1.0);
			weights.push_back(1.1);
			weights.push_back(1.3);
			weights.push_back(1.0);
			int nknots = static_cast<int>(poles.size()) - deg + 1;
			std::vector<double> knots(nknots);
			for (int i = 0; i < nknots; i++)
			{
				knots[i] = (double)i / (double)(nknots - 1.0);
			}
			std::vector<int> mults(nknots, 1);
			mults.front() = 4;
			mults.back() = 4;
			bsp1 = std::make_shared<Geom3BSplineCurve>(poles, weights, knots, mults, deg);
		}
		{
			std::vector<Point3> spinePoles;
			std::vector<double> spineKnots(4);
			std::vector<int> spineMults(4, 1);
			spinePoles.push_back(Point3(0.0, -1.0, 0.0));
			spinePoles.push_back(Point3(-0.1, -0.8, 1.0));
			spinePoles.push_back(Point3(0.1, -0.5, 2.0));
			spinePoles.push_back(Point3(0.2, -0.7, 3.0));
			spinePoles.push_back(Point3(0.1, -0.9, 3.5));
			spinePoles.push_back(Point3(0.0, -1.1, 4.5));
			std::vector<double> weights;
			weights.push_back(1.4);
			weights.push_back(1.7);
			weights.push_back(1.1);
			weights.push_back(1.3);
			weights.push_back(1.0);
			weights.push_back(0.9);
			spineKnots[0] = 0;
			spineKnots[1] = 1.0 / 3.0;
			spineKnots[2] = 2.0 / 3.0;
			spineKnots[3] = 1;
			spineMults.front() = 4;
			spineMults.back() = 4;
			bsp2 = std::make_shared<Geom3BSplineCurve>(spinePoles, weights, spineKnots, spineMults, 3);
		}
		bool isParallel = false;
		auto tmp = NURBSAPISweep::SweepOneRail(bsp1, bsp2, isParallel);
		const auto& bsp3 = tmp[0];
		clock_t bg = clock();
		auto [oldbsp4, olderr] = NURBSAPIRebuild::RebuildSurface(bsp3, 3, 3, 20, 10);
		clock_t ed = clock();
		auto [bsp4, err] = NURBSAPIRebuild::RebuildSurface(bsp3, 11, 11, 30, 20);
		CHECK(bsp4->UDegree() == 11);
		CHECK(bsp4->VDegree() == 11);
		CHECK(bsp4->NUPoles() == 30);
		CHECK(bsp4->NVPoles() == 20);
		OCCTIO::OCCTTool::Write(MakeEdge(bsp1), outdir + "bsp11.brep");
		OCCTIO::OCCTTool::Write(MakeEdge(bsp2), outdir + "bsp21.brep");
		OCCTIO::OCCTTool::Write(MakeFace(bsp3, 0.0), outdir + "src1.brep");
		OCCTIO::OCCTTool::Write(MakeFace(bsp4, 0.0), outdir + "result1.brep");
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static std::pair<std::shared_ptr<Geom3BSplineSurface>, double> RebuildSurface(const std::shared_ptr<Geom3BSplineSurface>& srcSurf, int targetUDeg, int targetVDeg, double tol)	 @return The rebuit surface and the error
	 @param tol Target tolerance between source surface and result surface. It is usally set over 1e-2 to guarantee the time performance
	 @param targetVDeg Target v degree
	 @param targetUDeg Target u degree
	 @param srcSurf Source surface
	 @brief Rebuild surface with target degree and target tolerance
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <nurbs/NURBSAPIRebuild.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeFace.hpp>
#include <nurbs/NURBSAPISweep.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
#include <modeling/MakeVertex.hpp>
#include <nurbs/NURBSAPIBuildCurve.hpp>
double NurbsCompareCurve(int num, const shared_ptr<Geom3Curve>& curve1, const shared_ptr<Geom3Curve>& curve2)
{
	double maxdist = 0.0;
	const int nsample = num;
	double fp1 = curve1->FirstParameter();
	double lp1 = curve1->LastParameter();
	double delta1 = abs((lp1 - fp1) / nsample);
	Point3 p;
	int n = 0;
	for (int i = 0; i < nsample; i++)
	{
		double t1 = fp1 + i * delta1;
		curve1->D0(t1, p);
		TopoEdge edge = MakeEdge(curve2);
		BRepExtremaDistShapeShape shape(MakeVertex(p), edge);
		double dist = shape.Value();
		if (dist > maxdist)
		{
			maxdist = dist;
		}
	}
	return maxdist;
}
double NurbsCompareSurface(int num, const shared_ptr<Geom3Surface>& surf1, const shared_ptr<Geom3Surface>& surf2)
{
	double maxdist = 0.0;
	const int nsample = num;
	double fpu1 = surf1->FirstUParameter();
	double lpu1 = surf1->LastUParameter();
	double fpv1 = surf1->FirstVParameter();
	double lpv1 = surf1->LastVParameter();
	double deltaU1 = (lpu1 - fpu1) / nsample;
	double deltaV1 = (lpv1 - fpv1) / nsample;
	Point3 p1;
	int n = 0;
	double tu1 = 0.0;
	double tv1 = 0.0;
	for (int i = 0; i < nsample; i++)
	{
		tu1 = fpu1 + i * deltaU1;
		for (int j = 0; j < nsample; j++)
		{
			tv1 = fpv1 + j * deltaV1;
			surf1->D0(tu1, tv1, p1);
			TopoFace face = MakeFace(surf2, 0.0);
			BRepExtremaDistShapeShape shape(MakeVertex(p1), face);
			double dist = shape.Value();
			if (dist > maxdist)
			{
				maxdist = dist;
			}
		}
	}
	return maxdist;
}
#include<catch.hpp>
#include<testHelper.h>
#include <nurbs/NURBSAPIRebuild.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeFace.hpp>
#include <nurbs/NURBSAPISweep.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
#include <modeling/MakeVertex.hpp>
#include <nurbs/NURBSAPIBuildCurve.hpp>
double NurbsCompareCurve(int num, const shared_ptr<Geom3Curve>& curve1, const shared_ptr<Geom3Curve>& curve2)
{
	double maxdist = 0.0;
	const int nsample = num;
	double fp1 = curve1->FirstParameter();
	double lp1 = curve1->LastParameter();
	double delta1 = abs((lp1 - fp1) / nsample);
	Point3 p;
	int n = 0;
	for (int i = 0; i < nsample; i++)
	{
		double t1 = fp1 + i * delta1;
		curve1->D0(t1, p);
		TopoEdge edge = MakeEdge(curve2);
		BRepExtremaDistShapeShape shape(MakeVertex(p), edge);
		double dist = shape.Value();
		if (dist > maxdist)
		{
			maxdist = dist;
		}
	}
	return maxdist;
}
double NurbsCompareSurface(int num, const shared_ptr<Geom3Surface>& surf1, const shared_ptr<Geom3Surface>& surf2)
{
	double maxdist = 0.0;
	const int nsample = num;
	double fpu1 = surf1->FirstUParameter();
	double lpu1 = surf1->LastUParameter();
	double fpv1 = surf1->FirstVParameter();
	double lpv1 = surf1->LastVParameter();
	double deltaU1 = (lpu1 - fpu1) / nsample;
	double deltaV1 = (lpv1 - fpv1) / nsample;
	Point3 p1;
	int n = 0;
	double tu1 = 0.0;
	double tv1 = 0.0;
	for (int i = 0; i < nsample; i++)
	{
		tu1 = fpu1 + i * deltaU1;
		for (int j = 0; j < nsample; j++)
		{
			tv1 = fpv1 + j * deltaV1;
			surf1->D0(tu1, tv1, p1);
			TopoFace face = MakeFace(surf2, 0.0);
			BRepExtremaDistShapeShape shape(MakeVertex(p1), face);
			double dist = shape.Value();
			if (dist > maxdist)
			{
				maxdist = dist;
			}
		}
	}
	return maxdist;
;
	SECTION("TestRebuildSurface")
	{
		OUTPUT_DIRECTORY(nurbs, Rebuild/bug735/RebuildSurface);
		std::shared_ptr<Geom3BSplineCurve> bsp1, bsp2;
		{
			int deg = 3;
			std::vector<Point3> poles;
			poles.push_back(Point3(0.0, -1.0, 0.0));
			poles.push_back(Point3(0.7, -0.7, 0.0));
			poles.push_back(Point3(1.0, -0.3, 0.0));
			poles.push_back(Point3(1.2, 0.0, 0.0));
			poles.push_back(Point3(2.0, 0.3, 0.0));
			poles.push_back(Point3(0.7, 1.7, 0.0));
			poles.push_back(Point3(0.0, 1.0, 0.0));
			std::vector<double> weights;
			weights.push_back(1.0);
			weights.push_back(1.2);
			weights.push_back(1.5);
			weights.push_back(1.0);
			weights.push_back(1.1);
			weights.push_back(1.3);
			weights.push_back(1.0);
			int nknots = static_cast<int>(poles.size()) - deg + 1;
			std::vector<double> knots(nknots);
			for (int i = 0; i < nknots; i++)
			{
				knots[i] = (double)i / (double)(nknots - 1.0);
			}
			std::vector<int> mults(nknots, 1);
			mults.front() = 4;
			mults.back() = 4;
			bsp1 = std::make_shared<Geom3BSplineCurve>(poles, weights, knots, mults, deg);
		}
		{
			std::vector<Point3> spinePoles;
			std::vector<double> spineKnots(4);
			std::vector<int> spineMults(4, 1);
			spinePoles.push_back(Point3(0.0, -1.0, 0.0));
			spinePoles.push_back(Point3(-0.1, -0.8, 1.0));
			spinePoles.push_back(Point3(0.1, -0.5, 2.0));
			spinePoles.push_back(Point3(0.2, -0.7, 3.0));
			spinePoles.push_back(Point3(0.1, -0.9, 3.5));
			spinePoles.push_back(Point3(0.0, -1.1, 4.5));
			std::vector<double> weights;
			weights.push_back(1.4);
			weights.push_back(1.7);
			weights.push_back(1.1);
			weights.push_back(1.3);
			weights.push_back(1.0);
			weights.push_back(0.9);
			spineKnots[0] = 0;
			spineKnots[1] = 1.0 / 3.0;
			spineKnots[2] = 2.0 / 3.0;
			spineKnots[3] = 1;
			spineMults.front() = 4;
			spineMults.back() = 4;
			bsp2 = std::make_shared<Geom3BSplineCurve>(spinePoles, weights, spineKnots, spineMults, 3);
		}
		bool isParallel = false;
		auto tmp = NURBSAPISweep::SweepOneRail(bsp1, bsp2, isParallel);
		const auto& bsp3 = tmp[0];
		clock_t bg = clock();
		auto [oldbsp4, olderr] = NURBSAPIRebuild::RebuildSurface(bsp3, 3, 3, 20, 10);
		clock_t ed = clock();
		auto [bsp4, err] = NURBSAPIRebuild::RebuildSurface(bsp3, 11, 11, 30, 20);
		CHECK(bsp4->UDegree() == 11);
		CHECK(bsp4->VDegree() == 11);
		CHECK(bsp4->NUPoles() == 30);
		CHECK(bsp4->NVPoles() == 20);
		OCCTIO::OCCTTool::Write(MakeEdge(bsp1), outdir + "bsp11.brep");
		OCCTIO::OCCTTool::Write(MakeEdge(bsp2), outdir + "bsp21.brep");
		OCCTIO::OCCTTool::Write(MakeFace(bsp3, 0.0), outdir + "src1.brep");
		OCCTIO::OCCTTool::Write(MakeFace(bsp4, 0.0), outdir + "result1.brep");
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static TopoFace ReplaceEdgeWithLine(const TopoFace& face, const std::vector<TopoEdge>& edges)	 @return The new face
	 @param edges Edges to be replaced
	 @param face Face
	 @brief Replace edges on face with a line
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <nurbs/NURBSAPIReplaceEdge.hpp>
#include <modeling/MakeWire.hpp>
#include <modeling/MakeEdge.hpp>
#include <offset/MakePipeShell.hpp>
#include <modeling/MakePrism.hpp>
#include <modeling/MakeFace.hpp>
#include <geometry/Geom3Plane.hpp>
#include <topology/TopoTool.hpp>
#include <geometry/GeomAPIProjectPointOnCurve3.hpp>
#include <topology/TopoExplorerTool.hpp>
#include <nurbs/NURBSAPIUntrim.hpp>
#include <topology/WireExplorer.hpp>
#include <modeling/MakeVertex.hpp>
#include<catch.hpp>
#include<testHelper.h>
#include <nurbs/NURBSAPIReplaceEdge.hpp>
#include <modeling/MakeWire.hpp>
#include <modeling/MakeEdge.hpp>
#include <offset/MakePipeShell.hpp>
#include <modeling/MakePrism.hpp>
#include <modeling/MakeFace.hpp>
#include <geometry/Geom3Plane.hpp>
#include <topology/TopoTool.hpp>
#include <geometry/GeomAPIProjectPointOnCurve3.hpp>
#include <topology/TopoExplorerTool.hpp>
#include <nurbs/NURBSAPIUntrim.hpp>
#include <topology/WireExplorer.hpp>
#include <modeling/MakeVertex.hpp>
;
	SECTION("TestReplaceEdge")
	{
		OUTPUT_DIRECTORY(nurbs, ReplaceEdge/ReplaceEdge);
		std::vector<Point3> profilePoles;
		std::vector<double> profileKnots(3);
		std::vector<int> profileMults(3, 1);
		profilePoles.push_back(Point3(0.0, 0.0, 0.0));
		profilePoles.push_back(Point3(1.0, -0.2, 0.1));
		profilePoles.push_back(Point3(2.0, 0.1, -0.1));
		profilePoles.push_back(Point3(3.0, -0.1, 0.0));
		profilePoles.push_back(Point3(4.0, 0.1, 0.2));
		profileKnots[0] = 0;
		profileKnots[1] = 0.5;
		profileKnots[2] = 1;
		profileMults.front() = 4;
		profileMults.back() = 4;
		std::shared_ptr<Geom3BSplineCurve> profileCurve = std::make_shared<Geom3BSplineCurve>(profilePoles, profileKnots, profileMults, 3);
		std::vector<Point3> spinePoles;
		std::vector<double> spineKnots(4);
		std::vector<int> spineMults(4, 1);
		spinePoles.push_back(Point3(0.0, 0.0, 0.0));
		spinePoles.push_back(Point3(-0.1, 1.0, -0.2));
		spinePoles.push_back(Point3(0.1, 2.0, -0.1));
		spinePoles.push_back(Point3(0.2, 3.0, 0.1));
		spinePoles.push_back(Point3(0.1, 4.0, 0.0));
		spinePoles.push_back(Point3(0.0, 5.0, -0.1));
		spineKnots[0] = 0;
		spineKnots[1] = 1.0 / 3.0;
		spineKnots[2] = 2.0 / 3.0;
		spineKnots[3] = 1;
		spineMults.front() = 4;
		spineMults.back() = 4;
		std::shared_ptr<Geom3BSplineCurve> spineCurve = std::make_shared<Geom3BSplineCurve>(spinePoles, spineKnots, spineMults, 3);
		TopoWire profile = MakeWire(MakeEdge(profileCurve)).Wire();
		TopoWire spine = MakeWire(MakeEdge(spineCurve)).Wire();
		MakePipeShell pipeShell(spine);
		pipeShell.Add(profile);
		pipeShell.SetMode(Frame3());
		TopoShape pipe = pipeShell.Shape();
		TopoExplorer ex(pipe, ShapeType::Face);
		TopoFace inputBasicFace = static_cast<const TopoFace&>(ex.Current());
		TopoShape cutCylidner1 = MakePrism(MakeEdge(Circle3(Frame3(Point3(0.0, 0.0, -0.3), Direction3(0.0, 0.0, 1.0)), 1.0)), Vector3(0.1, 0.1, 1.0));
		TopoShape cutPlane1 = MakeFace(std::make_shared<Geom3Plane>(Frame3(Point3(0.6, 0.6, 0.0), Direction3(-0.3, -0.3, 0.0), Direction3(0.3, -0.3, 0.0))), -2.0, 2.0, -1.0, 1.0, 1e-8);
		TopoShape cutCylidner2 = MakePrism(MakeEdge(Circle3(Frame3(Point3(2.0, 2.0, -0.3), Direction3(0.0, 0.0, 1.0)), 0.1)), Vector3(0.1, 0.1, 1.0));
		TopoShape cutPlane2 = MakeFace(std::make_shared<Geom3Plane>(Frame3(Point3(0.6, 5.0, 0.0), Direction3(0.3, -0.3, 0.0), Direction3(0.3, 0.3, 0.0))), -2.0, 2.0, -1.0, 1.0, 1e-8);
		TopoShape cutPlane3 = MakeFace(std::make_shared<Geom3Plane>(Frame3(Point3(4.0, 5.0, 0.0), Direction3(-0.3, -0.3, 0.0), Direction3(0.3, -0.3, 0.0))), -2.0, 2.0, -1.0, 1.0, 1e-8);
		TopoShape cc = CutAndLeaveLargePart(inputBasicFace, cutCylidner1);
		TopoShape ccp = CutAndLeaveLargePart(cc, cutPlane1);
		TopoShape ccpc = CutAndLeaveLargePart(ccp, cutCylidner2);
		TopoShape ccpcp = CutAndLeaveLargePart(ccpc, cutPlane2);
		TopoShape ccpcpp = CutAndLeaveLargePart(ccpcp, cutPlane3);
		TopoFace inputFace = static_cast<const TopoFace&>(ccpcpp);
		Throw_Construction_Error_if(inputFace.IsNull(), "it is not a face");
		Point3 refp(0.768477, 0.684154, -0.076058120);
		TopoEdge theEdge;
		double dist = 1e100;
		for (TopoExplorer exe(inputFace, ShapeType::Edge); exe.More(); exe.Next())
		{
			TopoEdge cr = static_cast<const TopoEdge&>(exe.Current());
			double f, l;
			auto curve3 = TopoTool::Curve(cr, f, l);
			GeomAPIProjectPointOnCurve3 projector(refp, curve3, f, l);
			if (projector.NPoints())
			{
				double crdist = projector.LowerDistance();
				if (dist > crdist)
				{
					dist = crdist;
					theEdge = cr;
				}
			}
		}
		TopoVertex v1, v2;
		std::vector<TopoEdge> deleteEdges;
		deleteEdges.push_back(theEdge);
		IndexMap<TopoShape, std::list<TopoShape>> map;
		TopoExplorerTool::MapShapesAndUniqueAncestors(inputFace, ShapeType::Edge, ShapeType::Wire, map);
		TopoWire wire = static_cast<const TopoWire&>(map[theEdge].front());
		WireExplorer we(wire);
		TopoEdge firstEdge = static_cast<const TopoEdge&>(we.Current());
		if (firstEdge.IsSame(theEdge))
		{
			Throw_Construction_Error_if(!we.More(), "only one edge");
			we.Next();
			TopoEdge frontNeighbourEdge = static_cast<const TopoEdge&>(we.Current());
			v2 = TopoExplorerTool::LastVertex(frontNeighbourEdge, true);
			deleteEdges.push_back(frontNeighbourEdge);
			TopoEdge lastEdge;
			for (we.Next(); we.More(); we.Next())
			{
				lastEdge = static_cast<const TopoEdge&>(we.Current());
			}
			deleteEdges.push_back(lastEdge);
			v1 = TopoExplorerTool::FirstVertex(lastEdge, true);
		}
		else
		{
			TopoEdge frontNeighbourEdge, nextNeighbourEdge;
			for (we.Next(); we.More(); we.Next())
			{
				TopoEdge crEdge = static_cast<const TopoEdge&>(we.Current());
				if (crEdge.IsSame(theEdge))
				{
					break;
				}
				else
				{
					frontNeighbourEdge = crEdge;
				}
			}
			deleteEdges.push_back(frontNeighbourEdge);
			we.Next();
			nextNeighbourEdge = static_cast<const TopoEdge&>(we.Current());
			deleteEdges.push_back(nextNeighbourEdge);
			v1 = TopoExplorerTool::FirstVertex(frontNeighbourEdge, true);
			v2 = TopoExplorerTool::LastVertex(nextNeighbourEdge, true);
		}
        for (int i = 0; i < static_cast<int>(deleteEdges.size()); i++)
		{
			OCCTIO::OCCTTool::Write(deleteEdges[i], outdir + "deleteEdges" + std::to_string(i) +".brep");
		}
		TopoFace result = NURBSAPIReplaceEdge::ReplaceEdgeWithLine(inputFace, deleteEdges);
		int res1 = GetTopoCount(inputFace, ShapeType::Edge);
		int res2 = GetTopoCount(result, ShapeType::Edge);
		CHECK(res1 == 10);
		CHECK(res2 == 8);
		TopoShape shape1 = CutAndLeaveLargePart(inputBasicFace, cutPlane1);
		TopoShape shape2 = CutAndLeaveLargePart(shape1, cutCylidner2);
		TopoShape shape3 = CutAndLeaveLargePart(shape2, cutPlane2);
		TopoShape shape4 = CutAndLeaveLargePart(shape3, cutPlane3);
		GlobalProperty props1, props2;
		double s1 = GetSurfaceProperties(shape4, props1, false, true);
		double s2 = GetSurfaceProperties(result, props2, false, true);
		double tol = 0.1;
		double res3 = abs(s1 - s2);
		CHECK(res3 <= tol);
		IndexSet<TopoShape> solidEdges1, solidEdges2;
		TopoExplorerTool::MapShapes(shape4, ShapeType::Edge, solidEdges1);
		TopoExplorerTool::MapShapes(result, ShapeType::Edge, solidEdges2);
		pair<Point3, Point3> pa1 = NurbsReadCurve(solidEdges1[6]);
		pair<Point3, Point3> pa2 = NurbsReadCurve(solidEdges2[1]);
		Point3 sp1 = pa1.first;
		Point3 sp2 = pa2.first;
		Point3 ep1 = pa1.second;
		Point3 ep2 = pa2.second;
		CHECK(sp1.IsEqual(sp2, 1e-7) == true);
		CHECK(ep1.IsEqual(ep2, 1e-7) == true);
		int num = 1000;
		double tolGen = 1e-7;
		double res4 = NurbsSampleParameter(num, tolGen, solidEdges2[1], result);
		CHECK(res4 <= 0.1);
		OCCTIO::OCCTTool::Write(inputFace, outdir + "src.brep");
		OCCTIO::OCCTTool::Write(shape1, outdir + "shape1.brep");
		OCCTIO::OCCTTool::Write(shape4, outdir + "shape4.brep");
		OCCTIO::OCCTTool::Write(solidEdges1[6], outdir + "edge1.brep");
		OCCTIO::OCCTTool::Write(solidEdges2[1], outdir + "edge2.brep");
		OCCTIO::OCCTTool::Write(wire, outdir + "wire.brep");
		OCCTIO::OCCTTool::Write(result, outdir + "result.brep");
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static std::tuple<bool, bool, std::shared_ptr<Geom3BSplineCurve>> SmoothCurve(const std::shared_ptr<Geom3BSplineCurve>& curve, double angularCorrection, double deviation)	  The third is the smoothed curve.
	  The second is whether the smoothing operation succeeded;
	 @return The first is whether the curve C0 tangent angular is below the angularCorrection;
	 @param deviation The tolerance of smoothing
	 the C0 points will be smoothed; Else it will return failure.
	 the guide curve C0 points is below the parameter value,
	 If the angular difference of the left derivative and the right derivative of
	 @param angularCorrection The smooth sweeping angular correction of the guide curve in radians.
	 @param curve The source curve
	 @brief Smooth curve
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <filesystem>
#include <fstream>
#include <random>
#include <sstream>
#include <nurbs/NURBSAPIGetGeometry.hpp>
#include <nurbs/NURBSAPIConicalSweep.hpp>
#include <boolean/BoolBRepCut.hpp>
#include <common/CartesianCoordinateSystem.hpp>
#include <common/IndexMap.hpp>
#include <common/QuaternionT.hpp>
#include <geomAlgo/LawBSpline.hpp>
#include <geomAlgo/LawConstant.hpp>
#include <nurbs/NURBSAPISmooth.hpp>
#include <geomAlgo/MakeConic2FromConstraints.hpp>
#include <geometry/Adaptor3CurveOnSurface.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/AdaptorGeom3Surface.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/Geom2Circle.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/Geom2Hyperbola.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom3BSplineCurve.hpp>
#include <geometry/Geom3BSplineSurface.hpp>
#include <geometry/Geom3Circle.hpp>
#include <geometry/Geom3Line.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
#include <geometry/Geom3Plane.hpp>
#include <geometry/Geom3SphericalSurface.hpp>
#include <geometry/Geom3Surface.hpp>
#include <geometry/Geom3TrimmedCurve.hpp>
#include <geometry/Geom3TrimmedSurface.hpp>
#include <geometry/GeomAPIExtremaCurveCurve3.hpp>
#include <geometry/GeomAPIProjectPointOnCurve2.hpp>
#include <geometry/GeomAPIProjectPointOnCurve3.hpp>
#include <geometry/GeomAPIProjectPointOnSurface.hpp>
#include <geometry/GeometryTool.hpp>
#include <geometry/GlobalProperty.hpp>
#include <healing/ShapeFixTool.hpp>
#include <io/STLTool.hpp>
#include <math/Sphere.hpp>
#include <math/TriangularMesh.hpp>
#include <modeling/CopyShape.hpp>
#include <modeling/MakeBox.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeFace.hpp>
#include <modeling/MakePrism.hpp>
#include <modeling/MakeRevol.hpp>
#include <modeling/MakeShapeTool.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeWire.hpp>
#include <modeling/TransformShape.hpp>
#include <nurbs/NURBSAPIApprox.hpp>
#include <nurbs/NURBSAPIBuildCurve.hpp>
#include <nurbs/NURBSAPICircularSweep.hpp>
#include <nurbs/NURBSAPIConvert.hpp>
#include <nurbs/NURBSAPICurveNetworkSurface.hpp>
#include <nurbs/NURBSAPIExplicitSweep.hpp>
#include <nurbs/NURBSAPIExplode.hpp>
#include <nurbs/NURBSAPIExtend.hpp>
#include <nurbs/NURBSAPIInterpolate.hpp>
#include <nurbs/NURBSAPIJoin.hpp>
#include <nurbs/NURBSAPILinearSweep.hpp>
#include <nurbs/NURBSAPILoft.hpp>
#include <nurbs/NURBSAPIMakeNURBSFromBoundaries.hpp>
#include <nurbs/NURBSAPIMatch.hpp>
#include <nurbs/NURBSAPIModifyEndToPlane.hpp>
#include <nurbs/NURBSAPIOffsetCurveOnSurface.hpp>
#include <nurbs/NURBSAPIProject.hpp>
#include <nurbs/NURBSAPIRebuild.hpp>
#include <nurbs/NURBSAPIReplaceEdge.hpp>
#include <nurbs/NURBSAPISweep.hpp>
#include <nurbs/NURBSAPISweep2.hpp>
#include <nurbs/NURBSAPISweepRotation.hpp>
#include <nurbs/NURBSAPITrim.hpp>
#include <nurbs/NURBSAPIUntrim.hpp>
#include <nurbs/NURBSLinearSweepWithDraftDirectionLength.hpp>
#include <occtio/OCCTTool.hpp>
#include <offset/MakePipe.hpp>
#include <offset/MakePipeShell.hpp>
#include <topology/BRepAdaptorCurve2.hpp>
#include <topology/BRepAdaptorCurve3.hpp>
#include <topology/BRepAdaptorSurface.hpp>
#include <topology/BRepGlobalProperty.hpp>
#include <topology/BRepTool.hpp>
#include <topology/TopoBuilder.hpp>
#include <topology/TopoCompound.hpp>
#include <topology/TopoEdge.hpp>
#include <topology/TopoExplorer.hpp>
#include <topology/TopoExplorerTool.hpp>
#include <topology/TopoFace.hpp>
#include <topology/TopoShape.hpp>
#include <topology/TopoShell.hpp>
#include <topology/TopoTool.hpp>
#include <topology/TopoVertex.hpp>
#include <topology/TopoWire.hpp>
#include <topology/WireExplorer.hpp>
#include <topomesh/BRepMeshIncrementalMesh.hpp>
#include <geometry/ComputePointsAbscissa.hpp>
#include <nurbs/NURBSAPIBlend.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
#include <math/LineT.hpp>
#include <hatch/BRepClassificationTools.hpp>
using namespace AMCAX;
namespace
{
	std::shared_ptr<Geom3BSplineCurve> CurveChooser(const int id, const std::shared_ptr<Geom3BSplineCurve>& curve0, const std::shared_ptr<Geom3BSplineCurve>& curve1, const std::shared_ptr<Geom3BSplineCurve>& curve2)
	{
		std::shared_ptr<Geom3BSplineCurve> result;
		switch (id)
		{
		case 0:
		{
			result = curve0;
			break;
		}
		case 1:
		{
			result = curve1;
			break;
		}
		case 2:
		{
			result = curve2;
			break;
		}
		}
		return result;
	}
} 
GlobalProperty props;
#include<catch.hpp>
#include<testHelper.h>
#include <filesystem>
#include <fstream>
#include <random>
#include <sstream>
#include <nurbs/NURBSAPIGetGeometry.hpp>
#include <nurbs/NURBSAPIConicalSweep.hpp>
#include <boolean/BoolBRepCut.hpp>
#include <common/CartesianCoordinateSystem.hpp>
#include <common/IndexMap.hpp>
#include <common/QuaternionT.hpp>
#include <geomAlgo/LawBSpline.hpp>
#include <geomAlgo/LawConstant.hpp>
#include <nurbs/NURBSAPISmooth.hpp>
#include <geomAlgo/MakeConic2FromConstraints.hpp>
#include <geometry/Adaptor3CurveOnSurface.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/AdaptorGeom3Surface.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/Geom2Circle.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/Geom2Hyperbola.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom3BSplineCurve.hpp>
#include <geometry/Geom3BSplineSurface.hpp>
#include <geometry/Geom3Circle.hpp>
#include <geometry/Geom3Line.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
#include <geometry/Geom3Plane.hpp>
#include <geometry/Geom3SphericalSurface.hpp>
#include <geometry/Geom3Surface.hpp>
#include <geometry/Geom3TrimmedCurve.hpp>
#include <geometry/Geom3TrimmedSurface.hpp>
#include <geometry/GeomAPIExtremaCurveCurve3.hpp>
#include <geometry/GeomAPIProjectPointOnCurve2.hpp>
#include <geometry/GeomAPIProjectPointOnCurve3.hpp>
#include <geometry/GeomAPIProjectPointOnSurface.hpp>
#include <geometry/GeometryTool.hpp>
#include <geometry/GlobalProperty.hpp>
#include <healing/ShapeFixTool.hpp>
#include <io/STLTool.hpp>
#include <math/Sphere.hpp>
#include <math/TriangularMesh.hpp>
#include <modeling/CopyShape.hpp>
#include <modeling/MakeBox.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeFace.hpp>
#include <modeling/MakePrism.hpp>
#include <modeling/MakeRevol.hpp>
#include <modeling/MakeShapeTool.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeWire.hpp>
#include <modeling/TransformShape.hpp>
#include <nurbs/NURBSAPIApprox.hpp>
#include <nurbs/NURBSAPIBuildCurve.hpp>
#include <nurbs/NURBSAPICircularSweep.hpp>
#include <nurbs/NURBSAPIConvert.hpp>
#include <nurbs/NURBSAPICurveNetworkSurface.hpp>
#include <nurbs/NURBSAPIExplicitSweep.hpp>
#include <nurbs/NURBSAPIExplode.hpp>
#include <nurbs/NURBSAPIExtend.hpp>
#include <nurbs/NURBSAPIInterpolate.hpp>
#include <nurbs/NURBSAPIJoin.hpp>
#include <nurbs/NURBSAPILinearSweep.hpp>
#include <nurbs/NURBSAPILoft.hpp>
#include <nurbs/NURBSAPIMakeNURBSFromBoundaries.hpp>
#include <nurbs/NURBSAPIMatch.hpp>
#include <nurbs/NURBSAPIModifyEndToPlane.hpp>
#include <nurbs/NURBSAPIOffsetCurveOnSurface.hpp>
#include <nurbs/NURBSAPIProject.hpp>
#include <nurbs/NURBSAPIRebuild.hpp>
#include <nurbs/NURBSAPIReplaceEdge.hpp>
#include <nurbs/NURBSAPISweep.hpp>
#include <nurbs/NURBSAPISweep2.hpp>
#include <nurbs/NURBSAPISweepRotation.hpp>
#include <nurbs/NURBSAPITrim.hpp>
#include <nurbs/NURBSAPIUntrim.hpp>
#include <nurbs/NURBSLinearSweepWithDraftDirectionLength.hpp>
#include <occtio/OCCTTool.hpp>
#include <offset/MakePipe.hpp>
#include <offset/MakePipeShell.hpp>
#include <topology/BRepAdaptorCurve2.hpp>
#include <topology/BRepAdaptorCurve3.hpp>
#include <topology/BRepAdaptorSurface.hpp>
#include <topology/BRepGlobalProperty.hpp>
#include <topology/BRepTool.hpp>
#include <topology/TopoBuilder.hpp>
#include <topology/TopoCompound.hpp>
#include <topology/TopoEdge.hpp>
#include <topology/TopoExplorer.hpp>
#include <topology/TopoExplorerTool.hpp>
#include <topology/TopoFace.hpp>
#include <topology/TopoShape.hpp>
#include <topology/TopoShell.hpp>
#include <topology/TopoTool.hpp>
#include <topology/TopoVertex.hpp>
#include <topology/TopoWire.hpp>
#include <topology/WireExplorer.hpp>
#include <topomesh/BRepMeshIncrementalMesh.hpp>
#include <geometry/ComputePointsAbscissa.hpp>
#include <nurbs/NURBSAPIBlend.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
#include <math/LineT.hpp>
#include <hatch/BRepClassificationTools.hpp>
using namespace AMCAX;
namespace
{
	std::shared_ptr<Geom3BSplineCurve> CurveChooser(const int id, const std::shared_ptr<Geom3BSplineCurve>& curve0, const std::shared_ptr<Geom3BSplineCurve>& curve1, const std::shared_ptr<Geom3BSplineCurve>& curve2)
	{
		std::shared_ptr<Geom3BSplineCurve> result;
		switch (id)
		{
		case 0:
		{
			result = curve0;
			break;
		}
		case 1:
		{
			result = curve1;
			break;
		}
		case 2:
		{
			result = curve2;
			break;
		}
		}
		return result;
	}
;
	SECTION("TestSmoothCurve2()")
	{
		std::string filedir = INPUT_PATH_PREFIX "/TestNURBS/TestSmooth/";
		auto c0 = ReadBRepCurve(filedir + "curve1.brep");
		auto c1 = ReadBRepCurve(filedir + "curve2.brep");
		std::vector<std::shared_ptr<Geom3BSplineCurve>>curves;
		curves.push_back(c0);
		curves.push_back(c1);
		Point3 p;
		c0->D0(c0->LastParameter(), p);
		CHECK(OCCTIO::OCCTTool::Write(MakeVertex(p), OUTPUT_PATH_PREFIX"smooth2_p.brep"));
		auto [sorted, isReverse, isPeriodic] = NURBSAPIJoin::JoinCurvePrepare(curves);
		auto joinedBSp = NURBSAPIJoin::JoinCurves(sorted, isReverse, isPeriodic);
		auto [isOK11, isOK12, smoothedCurve1] = NURBSAPISmooth::SmoothCurve(joinedBSp,  M_PI , 0.1);
		auto [isOK21, isOK22, smoothedCurve2] = NURBSAPISmooth::SmoothCurve(joinedBSp,  20.0*M_PI/180.0 , 0.1);
		auto [isOK31, isOK32, smoothedCurve3] = NURBSAPISmooth::SmoothCurve(joinedBSp,  M_PI , 0.01);
		CHECK(isOK11 == true);
		CHECK(isOK12 == true);
		CHECK(isOK21 == true);
		CHECK(isOK22 == true);
		CHECK(isOK31 == true);
		CHECK(isOK32 == true);
		if (isOK12 &&isOK22 &&isOK32  )
		{
			CHECK(OCCTIO::OCCTTool::Write(MakeEdge(smoothedCurve1), OUTPUT_PATH_PREFIX"TestSmoothCurve2_result.brep"));
			double t0 = GetLinearProperties(MakeEdge(smoothedCurve1), props, true, true);
			double t2 = GetLinearProperties(MakeEdge(smoothedCurve2), props, true, true);
			double t3 = GetLinearProperties(MakeEdge(smoothedCurve3), props, true, true);
			double t1 = GetLinearProperties(MakeEdge(c1), props, true, true) + GetLinearProperties(MakeEdge(c0), props, true, true);
			CHECK(t1 == Approx(t0).margin(0.1));
			CHECK(t1 == Approx(t2).margin(0.1));
			CHECK(t1 == Approx(t3).margin(0.1));
			double n11 = NurbsSampleCurve(100, 0.1, c1, smoothedCurve1);
			double n12 = NurbsSampleCurve(100, 0.1, c0, smoothedCurve1);
			CHECK(n11 == 0);
			CHECK(n12 == 0);
			double n21 = NurbsSampleCurve(100, 0.1, c1, smoothedCurve2);
			double n22 = NurbsSampleCurve(100, 0.1, c0, smoothedCurve2);
			CHECK(n21 == 0);
			CHECK(n22 == 0);
			double n31 = NurbsSampleCurve(100, 0.01, c1, smoothedCurve3);
			double n32 = NurbsSampleCurve(100, 0.01, c0, smoothedCurve3);
			CHECK(n31 == 0);
			CHECK(n32 == 0);
		}
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static std::vector<std::shared_ptr<Geom3BSplineSurface>> SweepOneRail( const std::shared_ptr<Geom3BSplineCurve>& profile, const std::shared_ptr<Geom3BSplineCurve>& spine, bool isParallel),
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeFace.hpp>
#include <nurbs/NURBSAPIConvert.hpp>
#include <topology/TopoTool.hpp>
#include <nurbs/NURBSAPIExplicitSweep.hpp>
#include <modeling/MakeVertex.hpp>
#include <nurbs/NURBSAPISweepRotation.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
#include <topology/TopoExplorerTool.hpp>
using namespace AMCAX;
namespace
{
	std::shared_ptr<Geom3BSplineCurve> CurveChooser(const int id, const std::shared_ptr<Geom3BSplineCurve>& curve0, const std::shared_ptr<Geom3BSplineCurve>& curve1, const std::shared_ptr<Geom3BSplineCurve>& curve2)
	{
		std::shared_ptr<Geom3BSplineCurve> result;
		switch (id)
		{
		case 0:
		{
			result = curve0;
			break;
		}
		case 1:
		{
			result = curve1;
			break;
		}
		case 2:
		{
			result = curve2;
			break;
		}
		}
		return result;
	}
} 
#include<catch.hpp>
#include<testHelper.h>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeFace.hpp>
#include <nurbs/NURBSAPIConvert.hpp>
#include <topology/TopoTool.hpp>
#include <nurbs/NURBSAPIExplicitSweep.hpp>
#include <modeling/MakeVertex.hpp>
#include <nurbs/NURBSAPISweepRotation.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
#include <topology/TopoExplorerTool.hpp>
using namespace AMCAX;
namespace
{
	std::shared_ptr<Geom3BSplineCurve> CurveChooser(const int id, const std::shared_ptr<Geom3BSplineCurve>& curve0, const std::shared_ptr<Geom3BSplineCurve>& curve1, const std::shared_ptr<Geom3BSplineCurve>& curve2)
	{
		std::shared_ptr<Geom3BSplineCurve> result;
		switch (id)
		{
		case 0:
		{
			result = curve0;
			break;
		}
		case 1:
		{
			result = curve1;
			break;
		}
		case 2:
		{
			result = curve2;
			break;
		}
		}
		return result;
	}
;
	SECTION("TestRotationSweep()")	
	{
		std::string filedir = INPUT_PATH_PREFIX "/TestNURBS/TestRotationSweep/";
		std::shared_ptr<Geom3BSplineCurve> spine = ReadBRepCurve(filedir + "spine.brep");
		std::shared_ptr<Geom3BSplineCurve> profile = ReadBRepCurve(filedir + "profile.brep");
		CHECK(OCCTIO::OCCTTool::Write(MakeEdge(spine), OUTPUT_PATH_PREFIX "TestRotationSweep_spine.brep"));
		CHECK(OCCTIO::OCCTTool::Write(MakeEdge(profile), OUTPUT_PATH_PREFIX "TestRotationSweep_profile.brep"));
		Point3 p(2.5, 2.5, 0.0);
		Vector3 vec(0.0, 0.0, 10.0);
		Axis3 axis(p, Direction3(vec));
		auto surface1 = NURBSAPISweepRotation::RotationSweep(spine, profile, axis);
		CHECK(OCCTIO::OCCTTool::Write(MakeFace(surface1, 0.0), OUTPUT_PATH_PREFIX "TestRotationSweep_result.brep"));
		AMCAX::BRepExtremaDistShapeShape len3(MakeEdge(profile), MakeEdge(spine));
		AMCAX::BRepExtremaDistShapeShape len2(MakeFace(surface1, 0.0), MakeEdge(spine));
		GlobalProperty props;
		IndexSet<TopoShape> newshapeEdge1;
		std::cout << "newshapedege.size" << newshapeEdge1.size() << endl;
		TopoExplorerTool::MapShapes(MakeFace(surface1, 0.0), ShapeType::Edge, newshapeEdge1);
		CHECK(OCCTIO::OCCTTool::Write(newshapeEdge1[0], OUTPUT_PATH_PREFIX "TestRotationSweep_newshapeEdge1[0].brep"));
		CHECK(OCCTIO::OCCTTool::Write(newshapeEdge1[1], OUTPUT_PATH_PREFIX "TestRotationSweep_newshapeEdge1[1].brep"));
		CHECK(OCCTIO::OCCTTool::Write(newshapeEdge1[2], OUTPUT_PATH_PREFIX "TestRotationSweep_newshapeEdge1[2].brep"));
		double	n, t;
		cout << " newshapeEdge1.size= " << newshapeEdge1.size() << endl;
		for (int i = 0; i < newshapeEdge1.size(); i++) {
			t = GetLinearProperties(newshapeEdge1[i], props, true, true);
			n = t + n;
		}
		cout << " spine = " << GetLinearProperties(MakeEdge(spine), props, true, true) << endl;
		cout << " profile = " << GetLinearProperties(MakeEdge(profile), props, true, true) << endl;
		CHECK(len2.Value() < 1.0);
		CHECK(IsCurveOnSurf(1000, 0.1, profile, surface1, 0.1));
		CHECK(IsCurveOnSurf(1000, 0.1, spine, surface1, 0.1));
		{
			spine->IncreaseDegree(7);
			profile->IncreaseDegree(7);
			CHECK(OCCTIO::OCCTTool::Write(MakeEdge(profile), OUTPUT_PATH_PREFIX "TestRotationSweep_degree11profile.brep"));
			auto surface11 = NURBSAPISweepRotation::RotationSweep(spine, profile, axis);
			CHECK(surface11->UDegree() == 7);
			CHECK(surface11->VDegree() == 7);
			CHECK(OCCTIO::OCCTTool::Write(MakeFace(surface11, 0.0), OUTPUT_PATH_PREFIX "TestRotationSweep_degree11result.brep"));
			double bsp3s = GetSurfaceProperties(MakeFace(surface1, 0.0), g, true, true);
			double bsp4s = GetSurfaceProperties(MakeFace(surface11, 0.0), g, true, true);
			CHECK(bsp3s == Approx(bsp4s).margin(0.02));
		} 
		{
			spine->IncreaseDegree(11);
			profile->IncreaseDegree(11);
			CHECK(OCCTIO::OCCTTool::Write(MakeEdge(profile), OUTPUT_PATH_PREFIX "TestRotationSweep_degree11profile.brep"));
			auto surface11 = NURBSAPISweepRotation::RotationSweep(spine, profile, axis);
			CHECK(surface11->UDegree()==11);
			CHECK(surface11->VDegree()==11);
			CHECK(OCCTIO::OCCTTool::Write(MakeFace(surface11, 0.0), OUTPUT_PATH_PREFIX "TestRotationSweep_degree11result.brep"));
			double bsp3s = GetSurfaceProperties(MakeFace(surface1, 0.0), g, true, true);
			double bsp4s = GetSurfaceProperties(MakeFace(surface11, 0.0), g, true, true);
			CHECK(bsp3s == Approx(bsp4s).margin(0.02));
		}
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static std::vector<std::shared_ptr<Geom3BSplineSurface>> SweepOneRail( const std::shared_ptr<Geom3BSplineCurve>& profile, const std::shared_ptr<Geom3BSplineCurve>& spine, double spineParam, bool isParallel),
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeFace.hpp>
#include <nurbs/NURBSAPIConvert.hpp>
#include <topology/TopoTool.hpp>
#include <nurbs/NURBSAPIExplicitSweep.hpp>
#include <modeling/MakeVertex.hpp>
#include <nurbs/NURBSAPISweepRotation.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
#include <topology/TopoExplorerTool.hpp>
using namespace AMCAX;
namespace
{
	std::shared_ptr<Geom3BSplineCurve> CurveChooser(const int id, const std::shared_ptr<Geom3BSplineCurve>& curve0, const std::shared_ptr<Geom3BSplineCurve>& curve1, const std::shared_ptr<Geom3BSplineCurve>& curve2)
	{
		std::shared_ptr<Geom3BSplineCurve> result;
		switch (id)
		{
		case 0:
		{
			result = curve0;
			break;
		}
		case 1:
		{
			result = curve1;
			break;
		}
		case 2:
		{
			result = curve2;
			break;
		}
		}
		return result;
	}
} 
#include<catch.hpp>
#include<testHelper.h>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeFace.hpp>
#include <nurbs/NURBSAPIConvert.hpp>
#include <topology/TopoTool.hpp>
#include <nurbs/NURBSAPIExplicitSweep.hpp>
#include <modeling/MakeVertex.hpp>
#include <nurbs/NURBSAPISweepRotation.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
#include <topology/TopoExplorerTool.hpp>
using namespace AMCAX;
namespace
{
	std::shared_ptr<Geom3BSplineCurve> CurveChooser(const int id, const std::shared_ptr<Geom3BSplineCurve>& curve0, const std::shared_ptr<Geom3BSplineCurve>& curve1, const std::shared_ptr<Geom3BSplineCurve>& curve2)
	{
		std::shared_ptr<Geom3BSplineCurve> result;
		switch (id)
		{
		case 0:
		{
			result = curve0;
			break;
		}
		case 1:
		{
			result = curve1;
			break;
		}
		case 2:
		{
			result = curve2;
			break;
		}
		}
		return result;
	}
;
	SECTION("TestRotationSweep()")	
	SECTION("TestRotationSweepPeriodic()")
	{
		std::string filedir = INPUT_PATH_PREFIX "/TestNURBS/TestRotationSweepPeriodic/";
		std::shared_ptr<Geom3BSplineCurve> spine = ReadBRepCurve(filedir + "spine.brep");
		std::shared_ptr<Geom3BSplineCurve> profile = ReadBRepCurve(filedir + "profile.brep");
		CHECK(OCCTIO::OCCTTool::Write(MakeEdge(spine), OUTPUT_PATH_PREFIX "TestRotationSweepPeriodic_spine.brep"));
		CHECK(OCCTIO::OCCTTool::Write(MakeEdge(profile), OUTPUT_PATH_PREFIX "TestRotationSweepPeriodic_profile.brep"));
		Point3 p(21.1, 22.8, 0.0);
		Vector3 vec(0.0, 0.0, 5.0);
		Axis3 axis(p, Direction3(vec));
		Line3 line(axis);
		auto surface = NURBSAPISweepRotation::RotationSweep(profile, spine, axis);
		CHECK(OCCTIO::OCCTTool::Write(MakeFace(surface, 0.0), OUTPUT_PATH_PREFIX "TestRotationSweepPeriodic_result.brep"));
		AMCAX::BRepExtremaDistShapeShape len1(MakeFace(surface, 0.0), MakeEdge(line));
		AMCAX::BRepExtremaDistShapeShape len2(MakeFace(surface, 0.0), MakeEdge(spine));
		CHECK(len1.Value() < 1.0);
		CHECK(len2.Value() < 1.0);
		CHECK(IsCurveOnSurf(1000, 0.1, profile, surface, 0.1));
		CHECK(IsCurveOnSurf(1000, 0.1, spine, surface, 0.1));
		spine->IncreaseDegree(11);
		profile->IncreaseDegree(11);
		auto surface1 = NURBSAPISweepRotation::RotationSweep(profile, spine, axis);
		CHECK(OCCTIO::OCCTTool::Write(MakeFace(surface, 0.0), OUTPUT_PATH_PREFIX "TestRotationSweepPeriodic_degree11result.brep"));
		CHECK(surface1->UDegree() == 11);
		CHECK(surface1->VDegree() == 11);
		double bsp3s = GetSurfaceProperties(MakeFace(surface1, 0.0), g, true, true);
		double bsp4s = GetSurfaceProperties(MakeFace(surface, 0.0), g, true, true);
		CHECK(bsp3s == Approx(bsp4s).margin(0.1));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static std::vector<std::shared_ptr<Geom3BSplineSurface>> SweepOneRail( const std::shared_ptr<Geom3BSplineCurve>& profile, const std::shared_ptr<Geom3BSplineCurve>& spine, bool isParallel),
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <filesystem>
#include <fstream>
#include <random>
#include <sstream>
#include <nurbs/NURBSAPIGetGeometry.hpp>
#include <nurbs/NURBSAPIConicalSweep.hpp>
#include <boolean/BoolBRepCut.hpp>
#include <common/CartesianCoordinateSystem.hpp>
#include <common/IndexMap.hpp>
#include <common/QuaternionT.hpp>
#include <geomAlgo/LawBSpline.hpp>
#include <geomAlgo/LawConstant.hpp>
#include <nurbs/NURBSAPISmooth.hpp>
#include <geomAlgo/MakeConic2FromConstraints.hpp>
#include <geometry/Adaptor3CurveOnSurface.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/AdaptorGeom3Surface.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/Geom2Circle.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/Geom2Hyperbola.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom3BSplineCurve.hpp>
#include <geometry/Geom3BSplineSurface.hpp>
#include <geometry/Geom3Circle.hpp>
#include <geometry/Geom3Line.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
#include <geometry/Geom3Plane.hpp>
#include <geometry/Geom3SphericalSurface.hpp>
#include <geometry/Geom3Surface.hpp>
#include <geometry/Geom3TrimmedCurve.hpp>
#include <geometry/Geom3TrimmedSurface.hpp>
#include <geometry/GeomAPIExtremaCurveCurve3.hpp>
#include <geometry/GeomAPIProjectPointOnCurve2.hpp>
#include <geometry/GeomAPIProjectPointOnCurve3.hpp>
#include <geometry/GeomAPIProjectPointOnSurface.hpp>
#include <geometry/GeometryTool.hpp>
#include <geometry/GlobalProperty.hpp>
#include <healing/ShapeFixTool.hpp>
#include <io/STLTool.hpp>
#include <math/Sphere.hpp>
#include <math/TriangularMesh.hpp>
#include <modeling/CopyShape.hpp>
#include <modeling/MakeBox.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeFace.hpp>
#include <modeling/MakePrism.hpp>
#include <modeling/MakeRevol.hpp>
#include <modeling/MakeShapeTool.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeWire.hpp>
#include <modeling/TransformShape.hpp>
#include <nurbs/NURBSAPIApprox.hpp>
#include <nurbs/NURBSAPIBuildCurve.hpp>
#include <nurbs/NURBSAPICircularSweep.hpp>
#include <nurbs/NURBSAPIConvert.hpp>
#include <nurbs/NURBSAPICurveNetworkSurface.hpp>
#include <nurbs/NURBSAPIExplicitSweep.hpp>
#include <nurbs/NURBSAPIExplode.hpp>
#include <nurbs/NURBSAPIExtend.hpp>
#include <nurbs/NURBSAPIInterpolate.hpp>
#include <nurbs/NURBSAPIJoin.hpp>
#include <nurbs/NURBSAPILinearSweep.hpp>
#include <nurbs/NURBSAPILoft.hpp>
#include <nurbs/NURBSAPIMakeNURBSFromBoundaries.hpp>
#include <nurbs/NURBSAPIMatch.hpp>
#include <nurbs/NURBSAPIModifyEndToPlane.hpp>
#include <nurbs/NURBSAPIOffsetCurveOnSurface.hpp>
#include <nurbs/NURBSAPIProject.hpp>
#include <nurbs/NURBSAPIRebuild.hpp>
#include <nurbs/NURBSAPIReplaceEdge.hpp>
#include <nurbs/NURBSAPISweep.hpp>
#include <nurbs/NURBSAPISweep2.hpp>
#include <nurbs/NURBSAPISweepRotation.hpp>
#include <nurbs/NURBSAPITrim.hpp>
#include <nurbs/NURBSAPIUntrim.hpp>
#include <nurbs/NURBSLinearSweepWithDraftDirectionLength.hpp>
#include <occtio/OCCTTool.hpp>
#include <offset/MakePipe.hpp>
#include <offset/MakePipeShell.hpp>
#include <topology/BRepAdaptorCurve2.hpp>
#include <topology/BRepAdaptorCurve3.hpp>
#include <topology/BRepAdaptorSurface.hpp>
#include <topology/BRepGlobalProperty.hpp>
#include <topology/BRepTool.hpp>
#include <topology/TopoBuilder.hpp>
#include <topology/TopoCompound.hpp>
#include <topology/TopoEdge.hpp>
#include <topology/TopoExplorer.hpp>
#include <topology/TopoExplorerTool.hpp>
#include <topology/TopoFace.hpp>
#include <topology/TopoShape.hpp>
#include <topology/TopoShell.hpp>
#include <topology/TopoTool.hpp>
#include <topology/TopoVertex.hpp>
#include <topology/TopoWire.hpp>
#include <topology/WireExplorer.hpp>
#include <topomesh/BRepMeshIncrementalMesh.hpp>
#include <nurbs/NURBSAPIBlend.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
#include <math/LineT.hpp>
#include <hatch/BRepClassificationTools.hpp>
using namespace AMCAX;
namespace
{
	std::shared_ptr<Geom3BSplineCurve> CurveChooser(const int id, const std::shared_ptr<Geom3BSplineCurve>& curve0, const std::shared_ptr<Geom3BSplineCurve>& curve1, const std::shared_ptr<Geom3BSplineCurve>& curve2)
	{
		std::shared_ptr<Geom3BSplineCurve> result;
		switch (id)
		{
		case 0:
		{
			result = curve0;
			break;
		}
		case 1:
		{
			result = curve1;
			break;
		}
		case 2:
		{
			result = curve2;
			break;
		}
		}
		return result;
	}
}		
GlobalProperty g;
#include<catch.hpp>
#include<testHelper.h>
#include <filesystem>
#include <fstream>
#include <random>
#include <sstream>
#include <nurbs/NURBSAPIGetGeometry.hpp>
#include <nurbs/NURBSAPIConicalSweep.hpp>
#include <boolean/BoolBRepCut.hpp>
#include <common/CartesianCoordinateSystem.hpp>
#include <common/IndexMap.hpp>
#include <common/QuaternionT.hpp>
#include <geomAlgo/LawBSpline.hpp>
#include <geomAlgo/LawConstant.hpp>
#include <nurbs/NURBSAPISmooth.hpp>
#include <geomAlgo/MakeConic2FromConstraints.hpp>
#include <geometry/Adaptor3CurveOnSurface.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/AdaptorGeom3Surface.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/Geom2Circle.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/Geom2Hyperbola.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom3BSplineCurve.hpp>
#include <geometry/Geom3BSplineSurface.hpp>
#include <geometry/Geom3Circle.hpp>
#include <geometry/Geom3Line.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
#include <geometry/Geom3Plane.hpp>
#include <geometry/Geom3SphericalSurface.hpp>
#include <geometry/Geom3Surface.hpp>
#include <geometry/Geom3TrimmedCurve.hpp>
#include <geometry/Geom3TrimmedSurface.hpp>
#include <geometry/GeomAPIExtremaCurveCurve3.hpp>
#include <geometry/GeomAPIProjectPointOnCurve2.hpp>
#include <geometry/GeomAPIProjectPointOnCurve3.hpp>
#include <geometry/GeomAPIProjectPointOnSurface.hpp>
#include <geometry/GeometryTool.hpp>
#include <geometry/GlobalProperty.hpp>
#include <healing/ShapeFixTool.hpp>
#include <io/STLTool.hpp>
#include <math/Sphere.hpp>
#include <math/TriangularMesh.hpp>
#include <modeling/CopyShape.hpp>
#include <modeling/MakeBox.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeFace.hpp>
#include <modeling/MakePrism.hpp>
#include <modeling/MakeRevol.hpp>
#include <modeling/MakeShapeTool.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeWire.hpp>
#include <modeling/TransformShape.hpp>
#include <nurbs/NURBSAPIApprox.hpp>
#include <nurbs/NURBSAPIBuildCurve.hpp>
#include <nurbs/NURBSAPICircularSweep.hpp>
#include <nurbs/NURBSAPIConvert.hpp>
#include <nurbs/NURBSAPICurveNetworkSurface.hpp>
#include <nurbs/NURBSAPIExplicitSweep.hpp>
#include <nurbs/NURBSAPIExplode.hpp>
#include <nurbs/NURBSAPIExtend.hpp>
#include <nurbs/NURBSAPIInterpolate.hpp>
#include <nurbs/NURBSAPIJoin.hpp>
#include <nurbs/NURBSAPILinearSweep.hpp>
#include <nurbs/NURBSAPILoft.hpp>
#include <nurbs/NURBSAPIMakeNURBSFromBoundaries.hpp>
#include <nurbs/NURBSAPIMatch.hpp>
#include <nurbs/NURBSAPIModifyEndToPlane.hpp>
#include <nurbs/NURBSAPIOffsetCurveOnSurface.hpp>
#include <nurbs/NURBSAPIProject.hpp>
#include <nurbs/NURBSAPIRebuild.hpp>
#include <nurbs/NURBSAPIReplaceEdge.hpp>
#include <nurbs/NURBSAPISweep.hpp>
#include <nurbs/NURBSAPISweep2.hpp>
#include <nurbs/NURBSAPISweepRotation.hpp>
#include <nurbs/NURBSAPITrim.hpp>
#include <nurbs/NURBSAPIUntrim.hpp>
#include <nurbs/NURBSLinearSweepWithDraftDirectionLength.hpp>
#include <occtio/OCCTTool.hpp>
#include <offset/MakePipe.hpp>
#include <offset/MakePipeShell.hpp>
#include <topology/BRepAdaptorCurve2.hpp>
#include <topology/BRepAdaptorCurve3.hpp>
#include <topology/BRepAdaptorSurface.hpp>
#include <topology/BRepGlobalProperty.hpp>
#include <topology/BRepTool.hpp>
#include <topology/TopoBuilder.hpp>
#include <topology/TopoCompound.hpp>
#include <topology/TopoEdge.hpp>
#include <topology/TopoExplorer.hpp>
#include <topology/TopoExplorerTool.hpp>
#include <topology/TopoFace.hpp>
#include <topology/TopoShape.hpp>
#include <topology/TopoShell.hpp>
#include <topology/TopoTool.hpp>
#include <topology/TopoVertex.hpp>
#include <topology/TopoWire.hpp>
#include <topology/WireExplorer.hpp>
#include <topomesh/BRepMeshIncrementalMesh.hpp>
#include <nurbs/NURBSAPIBlend.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
#include <math/LineT.hpp>
#include <hatch/BRepClassificationTools.hpp>
using namespace AMCAX;
namespace
{
	std::shared_ptr<Geom3BSplineCurve> CurveChooser(const int id, const std::shared_ptr<Geom3BSplineCurve>& curve0, const std::shared_ptr<Geom3BSplineCurve>& curve1, const std::shared_ptr<Geom3BSplineCurve>& curve2)
	{
		std::shared_ptr<Geom3BSplineCurve> result;
		switch (id)
		{
		case 0:
		{
			result = curve0;
			break;
		}
		case 1:
		{
			result = curve1;
			break;
		}
		case 2:
		{
			result = curve2;
			break;
		}
		}
		return result;
	}
;
	SECTION("TestSweepTest1()")
	{
		std::shared_ptr<Geom3BSplineCurve> bsp1, bsp2;
		{
			int deg = 3;
			std::vector<Point3> poles;
			poles.push_back(Point3(0.0, -1.0, 0.0));
			poles.push_back(Point3(0.7, -0.7, 0.0));
			poles.push_back(Point3(1.0, -0.3, 0.0));
			poles.push_back(Point3(1.2, 0.0, 0.0));
			poles.push_back(Point3(2.0, 0.3, 0.0));
			poles.push_back(Point3(0.7, 1.7, 0.0));
			poles.push_back(Point3(0.0, 1.0, 0.0));
			poles.push_back(Point3(-0.7, 1.7, 0.0));
			poles.push_back(Point3(-2.0, 0.3, 0.0));
			poles.push_back(Point3(-1.2, 0.0, 0.0));
			poles.push_back(Point3(-1.0, -0.3, 0.0));
			poles.push_back(Point3(-0.7, -0.7, 0.0));
			poles.push_back(Point3(0.0, -1.0, 0.0));
			std::vector<double> weights;
			weights.push_back(1.0);
			weights.push_back(1.2);
			weights.push_back(1.3);
			weights.push_back(1.4);
			weights.push_back(1.5);
			weights.push_back(1.6);
			weights.push_back(1.7);
			weights.push_back(1.8);
			weights.push_back(1.9);
			weights.push_back(1.0);
			weights.push_back(1.1);
			weights.push_back(1.3);
			weights.push_back(1.0);
			int nknots = static_cast<int>(poles.size()) - deg + 1;
			std::vector<double> knots(nknots);
			for (int i = 0; i < nknots; i++)
			{
				knots[i] = (double)i / (double)(nknots - 1.0);
			}
			std::vector<int> mults(nknots, 1);
			mults.front() = 4;
			mults.back() = 4;
			bsp1 = std::make_shared<Geom3BSplineCurve>(poles, weights, knots, mults, deg);
			CHECK(OCCTIO::OCCTTool::Write(MakeEdge(bsp1), OUTPUT_PATH_PREFIX "TestSweepTest1_bsp1.brep"));
		}
		{
			std::vector<Point3> spinePoles;
			std::vector<double> spineKnots(4);
			std::vector<int> spineMults(4, 1);
			spinePoles.push_back(Point3(0.0, 1.0, 0.0));
			spinePoles.push_back(Point3(-0.1, -0.8, 1.0));
			spinePoles.push_back(Point3(0.1, -0.5, 2.0));
			spinePoles.push_back(Point3(0.2, -0.7, 3.0));
			spinePoles.push_back(Point3(0.1, -0.9, 3.5));
			spinePoles.push_back(Point3(0.0, -1.1, 4.5));
			std::vector<double> weights;
			weights.push_back(1.4);
			weights.push_back(1.7);
			weights.push_back(1.1);
			weights.push_back(1.3);
			weights.push_back(1.0);
			weights.push_back(0.9);
			spineKnots[0] = 0;
			spineKnots[1] = 1.0 / 3.0;
			spineKnots[2] = 2.0 / 3.0;
			spineKnots[3] = 1;
			spineMults.front() = 4;
			spineMults.back() = 4;
			bsp2 = std::make_shared<Geom3BSplineCurve>(spinePoles, weights, spineKnots, spineMults, 3);
			CHECK(OCCTIO::OCCTTool::Write(MakeEdge(bsp2), OUTPUT_PATH_PREFIX "TestSweepTest1_bsp2.brep"));
		}
		bool isParallel = false;
		auto bsp3 = NURBSAPISweep::SweepOneRail(bsp1, bsp2, isParallel);
		for (int i = 0; i < static_cast<int>(bsp3.size()); i++)
		{
			std::string filename = OUTPUT_PATH_PREFIX "TestSweepTest1_result" + std::to_string(i) + ".brep";
			CHECK(OCCTIO::OCCTTool::Write(MakeFace(bsp3[i], 0.0), filename.c_str()));
		}
		CHECK(bsp3.size() == 1);
		AMCAX::BRepExtremaDistShapeShape len(MakeEdge(bsp1), MakeFace(bsp3[0], 0.0));
		CHECK(len.Value() == Approx(0.0).margin(0.1));
		CHECK(IsCurveOnSurf(1000, 0.2, bsp1, bsp3[0], 0.2));
		bsp2->IncreaseDegree(25);
		bsp1->IncreaseDegree(25);
		auto bsp4 = NURBSAPISweep::SweepOneRail(bsp1, bsp2, isParallel);
		CHECK(OCCTIO::OCCTTool::Write(MakeFace(bsp4[0], 0.0), OUTPUT_PATH_PREFIX "TestSweepTest1_degree25result.brep"));
		AMCAX::BRepExtremaDistShapeShape len1(MakeEdge(bsp1), MakeFace(bsp4[0], 0.0));
		CHECK(len1.Value() == Approx(0.0).margin(0.1));
		CHECK(IsCurveOnSurf(1000, 0.2, bsp1, bsp4[0], 0.2));
		double bsp3s = GetSurfaceProperties(MakeFace(bsp3[0], 0.0), g, true, true);
		double bsp4s = GetSurfaceProperties(MakeFace(bsp4[0], 0.0), g, true, true);
		double bsp3v = GetVolumeProperties(MakeFace(bsp3[0], 0.0), g, true, true);
		double bsp4v = GetVolumeProperties(MakeFace(bsp4[0], 0.0), g, true, true);
		CHECK(bsp3s == Approx(bsp4s).margin(0.02));
		CHECK(bsp3v == Approx(bsp4v).margin(0.02));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static std::vector<std::shared_ptr<Geom3BSplineSurface>> SweepOneRail( const std::shared_ptr<Geom3BSplineCurve>& profile, const std::shared_ptr<Geom3BSplineCurve>& spine, double spineParam, bool isParallel),
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <filesystem>
#include <fstream>
#include <random>
#include <sstream>
#include <nurbs/NURBSAPIGetGeometry.hpp>
#include <nurbs/NURBSAPIConicalSweep.hpp>
#include <boolean/BoolBRepCut.hpp>
#include <common/CartesianCoordinateSystem.hpp>
#include <common/IndexMap.hpp>
#include <common/QuaternionT.hpp>
#include <geomAlgo/LawBSpline.hpp>
#include <geomAlgo/LawConstant.hpp>
#include <nurbs/NURBSAPISmooth.hpp>
#include <geomAlgo/MakeConic2FromConstraints.hpp>
#include <geometry/Adaptor3CurveOnSurface.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/AdaptorGeom3Surface.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/Geom2Circle.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/Geom2Hyperbola.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom3BSplineCurve.hpp>
#include <geometry/Geom3BSplineSurface.hpp>
#include <geometry/Geom3Circle.hpp>
#include <geometry/Geom3Line.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
#include <geometry/Geom3Plane.hpp>
#include <geometry/Geom3SphericalSurface.hpp>
#include <geometry/Geom3Surface.hpp>
#include <geometry/Geom3TrimmedCurve.hpp>
#include <geometry/Geom3TrimmedSurface.hpp>
#include <geometry/GeomAPIExtremaCurveCurve3.hpp>
#include <geometry/GeomAPIProjectPointOnCurve2.hpp>
#include <geometry/GeomAPIProjectPointOnCurve3.hpp>
#include <geometry/GeomAPIProjectPointOnSurface.hpp>
#include <geometry/GeometryTool.hpp>
#include <geometry/GlobalProperty.hpp>
#include <healing/ShapeFixTool.hpp>
#include <io/STLTool.hpp>
#include <math/Sphere.hpp>
#include <math/TriangularMesh.hpp>
#include <modeling/CopyShape.hpp>
#include <modeling/MakeBox.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeFace.hpp>
#include <modeling/MakePrism.hpp>
#include <modeling/MakeRevol.hpp>
#include <modeling/MakeShapeTool.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeWire.hpp>
#include <modeling/TransformShape.hpp>
#include <nurbs/NURBSAPIApprox.hpp>
#include <nurbs/NURBSAPIBuildCurve.hpp>
#include <nurbs/NURBSAPICircularSweep.hpp>
#include <nurbs/NURBSAPIConvert.hpp>
#include <nurbs/NURBSAPICurveNetworkSurface.hpp>
#include <nurbs/NURBSAPIExplicitSweep.hpp>
#include <nurbs/NURBSAPIExplode.hpp>
#include <nurbs/NURBSAPIExtend.hpp>
#include <nurbs/NURBSAPIInterpolate.hpp>
#include <nurbs/NURBSAPIJoin.hpp>
#include <nurbs/NURBSAPILinearSweep.hpp>
#include <nurbs/NURBSAPILoft.hpp>
#include <nurbs/NURBSAPIMakeNURBSFromBoundaries.hpp>
#include <nurbs/NURBSAPIMatch.hpp>
#include <nurbs/NURBSAPIModifyEndToPlane.hpp>
#include <nurbs/NURBSAPIOffsetCurveOnSurface.hpp>
#include <nurbs/NURBSAPIProject.hpp>
#include <nurbs/NURBSAPIRebuild.hpp>
#include <nurbs/NURBSAPIReplaceEdge.hpp>
#include <nurbs/NURBSAPISweep.hpp>
#include <nurbs/NURBSAPISweep2.hpp>
#include <nurbs/NURBSAPISweepRotation.hpp>
#include <nurbs/NURBSAPITrim.hpp>
#include <nurbs/NURBSAPIUntrim.hpp>
#include <nurbs/NURBSLinearSweepWithDraftDirectionLength.hpp>
#include <occtio/OCCTTool.hpp>
#include <offset/MakePipe.hpp>
#include <offset/MakePipeShell.hpp>
#include <topology/BRepAdaptorCurve2.hpp>
#include <topology/BRepAdaptorCurve3.hpp>
#include <topology/BRepAdaptorSurface.hpp>
#include <topology/BRepGlobalProperty.hpp>
#include <topology/BRepTool.hpp>
#include <topology/TopoBuilder.hpp>
#include <topology/TopoCompound.hpp>
#include <topology/TopoEdge.hpp>
#include <topology/TopoExplorer.hpp>
#include <topology/TopoExplorerTool.hpp>
#include <topology/TopoFace.hpp>
#include <topology/TopoShape.hpp>
#include <topology/TopoShell.hpp>
#include <topology/TopoTool.hpp>
#include <topology/TopoVertex.hpp>
#include <topology/TopoWire.hpp>
#include <topology/WireExplorer.hpp>
#include <topomesh/BRepMeshIncrementalMesh.hpp>
#include <nurbs/NURBSAPIBlend.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
#include <math/LineT.hpp>
#include <hatch/BRepClassificationTools.hpp>
using namespace AMCAX;
namespace
{
	std::shared_ptr<Geom3BSplineCurve> CurveChooser(const int id, const std::shared_ptr<Geom3BSplineCurve>& curve0, const std::shared_ptr<Geom3BSplineCurve>& curve1, const std::shared_ptr<Geom3BSplineCurve>& curve2)
	{
		std::shared_ptr<Geom3BSplineCurve> result;
		switch (id)
		{
		case 0:
		{
			result = curve0;
			break;
		}
		case 1:
		{
			result = curve1;
			break;
		}
		case 2:
		{
			result = curve2;
			break;
		}
		}
		return result;
	}
}		
GlobalProperty g;
#include<catch.hpp>
#include<testHelper.h>
#include <filesystem>
#include <fstream>
#include <random>
#include <sstream>
#include <nurbs/NURBSAPIGetGeometry.hpp>
#include <nurbs/NURBSAPIConicalSweep.hpp>
#include <boolean/BoolBRepCut.hpp>
#include <common/CartesianCoordinateSystem.hpp>
#include <common/IndexMap.hpp>
#include <common/QuaternionT.hpp>
#include <geomAlgo/LawBSpline.hpp>
#include <geomAlgo/LawConstant.hpp>
#include <nurbs/NURBSAPISmooth.hpp>
#include <geomAlgo/MakeConic2FromConstraints.hpp>
#include <geometry/Adaptor3CurveOnSurface.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/AdaptorGeom3Surface.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/Geom2Circle.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/Geom2Hyperbola.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom3BSplineCurve.hpp>
#include <geometry/Geom3BSplineSurface.hpp>
#include <geometry/Geom3Circle.hpp>
#include <geometry/Geom3Line.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
#include <geometry/Geom3Plane.hpp>
#include <geometry/Geom3SphericalSurface.hpp>
#include <geometry/Geom3Surface.hpp>
#include <geometry/Geom3TrimmedCurve.hpp>
#include <geometry/Geom3TrimmedSurface.hpp>
#include <geometry/GeomAPIExtremaCurveCurve3.hpp>
#include <geometry/GeomAPIProjectPointOnCurve2.hpp>
#include <geometry/GeomAPIProjectPointOnCurve3.hpp>
#include <geometry/GeomAPIProjectPointOnSurface.hpp>
#include <geometry/GeometryTool.hpp>
#include <geometry/GlobalProperty.hpp>
#include <healing/ShapeFixTool.hpp>
#include <io/STLTool.hpp>
#include <math/Sphere.hpp>
#include <math/TriangularMesh.hpp>
#include <modeling/CopyShape.hpp>
#include <modeling/MakeBox.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeFace.hpp>
#include <modeling/MakePrism.hpp>
#include <modeling/MakeRevol.hpp>
#include <modeling/MakeShapeTool.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeWire.hpp>
#include <modeling/TransformShape.hpp>
#include <nurbs/NURBSAPIApprox.hpp>
#include <nurbs/NURBSAPIBuildCurve.hpp>
#include <nurbs/NURBSAPICircularSweep.hpp>
#include <nurbs/NURBSAPIConvert.hpp>
#include <nurbs/NURBSAPICurveNetworkSurface.hpp>
#include <nurbs/NURBSAPIExplicitSweep.hpp>
#include <nurbs/NURBSAPIExplode.hpp>
#include <nurbs/NURBSAPIExtend.hpp>
#include <nurbs/NURBSAPIInterpolate.hpp>
#include <nurbs/NURBSAPIJoin.hpp>
#include <nurbs/NURBSAPILinearSweep.hpp>
#include <nurbs/NURBSAPILoft.hpp>
#include <nurbs/NURBSAPIMakeNURBSFromBoundaries.hpp>
#include <nurbs/NURBSAPIMatch.hpp>
#include <nurbs/NURBSAPIModifyEndToPlane.hpp>
#include <nurbs/NURBSAPIOffsetCurveOnSurface.hpp>
#include <nurbs/NURBSAPIProject.hpp>
#include <nurbs/NURBSAPIRebuild.hpp>
#include <nurbs/NURBSAPIReplaceEdge.hpp>
#include <nurbs/NURBSAPISweep.hpp>
#include <nurbs/NURBSAPISweep2.hpp>
#include <nurbs/NURBSAPISweepRotation.hpp>
#include <nurbs/NURBSAPITrim.hpp>
#include <nurbs/NURBSAPIUntrim.hpp>
#include <nurbs/NURBSLinearSweepWithDraftDirectionLength.hpp>
#include <occtio/OCCTTool.hpp>
#include <offset/MakePipe.hpp>
#include <offset/MakePipeShell.hpp>
#include <topology/BRepAdaptorCurve2.hpp>
#include <topology/BRepAdaptorCurve3.hpp>
#include <topology/BRepAdaptorSurface.hpp>
#include <topology/BRepGlobalProperty.hpp>
#include <topology/BRepTool.hpp>
#include <topology/TopoBuilder.hpp>
#include <topology/TopoCompound.hpp>
#include <topology/TopoEdge.hpp>
#include <topology/TopoExplorer.hpp>
#include <topology/TopoExplorerTool.hpp>
#include <topology/TopoFace.hpp>
#include <topology/TopoShape.hpp>
#include <topology/TopoShell.hpp>
#include <topology/TopoTool.hpp>
#include <topology/TopoVertex.hpp>
#include <topology/TopoWire.hpp>
#include <topology/WireExplorer.hpp>
#include <topomesh/BRepMeshIncrementalMesh.hpp>
#include <nurbs/NURBSAPIBlend.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
#include <math/LineT.hpp>
#include <hatch/BRepClassificationTools.hpp>
using namespace AMCAX;
namespace
{
	std::shared_ptr<Geom3BSplineCurve> CurveChooser(const int id, const std::shared_ptr<Geom3BSplineCurve>& curve0, const std::shared_ptr<Geom3BSplineCurve>& curve1, const std::shared_ptr<Geom3BSplineCurve>& curve2)
	{
		std::shared_ptr<Geom3BSplineCurve> result;
		switch (id)
		{
		case 0:
		{
			result = curve0;
			break;
		}
		case 1:
		{
			result = curve1;
			break;
		}
		case 2:
		{
			result = curve2;
			break;
		}
		}
		return result;
	}
;
	SECTION("TestSweepTest1()")
	{
		std::shared_ptr<Geom3BSplineCurve> bsp1, bsp2;
		{
			int deg = 3;
			std::vector<Point3> poles;
			poles.push_back(Point3(0.0, -1.0, 0.0));
			poles.push_back(Point3(0.7, -0.7, 0.0));
			poles.push_back(Point3(1.0, -0.3, 0.0));
			poles.push_back(Point3(1.2, 0.0, 0.0));
			poles.push_back(Point3(2.0, 0.3, 0.0));
			poles.push_back(Point3(0.7, 1.7, 0.0));
			poles.push_back(Point3(0.0, 1.0, 0.0));
			poles.push_back(Point3(-0.7, 1.7, 0.0));
			poles.push_back(Point3(-2.0, 0.3, 0.0));
			poles.push_back(Point3(-1.2, 0.0, 0.0));
			poles.push_back(Point3(-1.0, -0.3, 0.0));
			poles.push_back(Point3(-0.7, -0.7, 0.0));
			poles.push_back(Point3(0.0, -1.0, 0.0));
			std::vector<double> weights;
			weights.push_back(1.0);
			weights.push_back(1.2);
			weights.push_back(1.3);
			weights.push_back(1.4);
			weights.push_back(1.5);
			weights.push_back(1.6);
			weights.push_back(1.7);
			weights.push_back(1.8);
			weights.push_back(1.9);
			weights.push_back(1.0);
			weights.push_back(1.1);
			weights.push_back(1.3);
			weights.push_back(1.0);
			int nknots = static_cast<int>(poles.size()) - deg + 1;
			std::vector<double> knots(nknots);
			for (int i = 0; i < nknots; i++)
			{
				knots[i] = (double)i / (double)(nknots - 1.0);
			}
			std::vector<int> mults(nknots, 1);
			mults.front() = 4;
			mults.back() = 4;
			bsp1 = std::make_shared<Geom3BSplineCurve>(poles, weights, knots, mults, deg);
			CHECK(OCCTIO::OCCTTool::Write(MakeEdge(bsp1), OUTPUT_PATH_PREFIX "TestSweepTest1_bsp1.brep"));
		}
		{
			std::vector<Point3> spinePoles;
			std::vector<double> spineKnots(4);
			std::vector<int> spineMults(4, 1);
			spinePoles.push_back(Point3(0.0, 1.0, 0.0));
			spinePoles.push_back(Point3(-0.1, -0.8, 1.0));
			spinePoles.push_back(Point3(0.1, -0.5, 2.0));
			spinePoles.push_back(Point3(0.2, -0.7, 3.0));
			spinePoles.push_back(Point3(0.1, -0.9, 3.5));
			spinePoles.push_back(Point3(0.0, -1.1, 4.5));
			std::vector<double> weights;
			weights.push_back(1.4);
			weights.push_back(1.7);
			weights.push_back(1.1);
			weights.push_back(1.3);
			weights.push_back(1.0);
			weights.push_back(0.9);
			spineKnots[0] = 0;
			spineKnots[1] = 1.0 / 3.0;
			spineKnots[2] = 2.0 / 3.0;
			spineKnots[3] = 1;
			spineMults.front() = 4;
			spineMults.back() = 4;
			bsp2 = std::make_shared<Geom3BSplineCurve>(spinePoles, weights, spineKnots, spineMults, 3);
			CHECK(OCCTIO::OCCTTool::Write(MakeEdge(bsp2), OUTPUT_PATH_PREFIX "TestSweepTest1_bsp2.brep"));
		}
		bool isParallel = false;
		auto bsp3 = NURBSAPISweep::SweepOneRail(bsp1, bsp2, isParallel);
		for (int i = 0; i < static_cast<int>(bsp3.size()); i++)
		{
			std::string filename = OUTPUT_PATH_PREFIX "TestSweepTest1_result" + std::to_string(i) + ".brep";
			CHECK(OCCTIO::OCCTTool::Write(MakeFace(bsp3[i], 0.0), filename.c_str()));
		}
		CHECK(bsp3.size() == 1);
		AMCAX::BRepExtremaDistShapeShape len(MakeEdge(bsp1), MakeFace(bsp3[0], 0.0));
		CHECK(len.Value() == Approx(0.0).margin(0.1));
		CHECK(IsCurveOnSurf(1000, 0.2, bsp1, bsp3[0], 0.2));
		bsp2->IncreaseDegree(25);
		bsp1->IncreaseDegree(25);
		auto bsp4 = NURBSAPISweep::SweepOneRail(bsp1, bsp2, isParallel);
		CHECK(OCCTIO::OCCTTool::Write(MakeFace(bsp4[0], 0.0), OUTPUT_PATH_PREFIX "TestSweepTest1_degree25result.brep"));
		AMCAX::BRepExtremaDistShapeShape len1(MakeEdge(bsp1), MakeFace(bsp4[0], 0.0));
		CHECK(len1.Value() == Approx(0.0).margin(0.1));
		CHECK(IsCurveOnSurf(1000, 0.2, bsp1, bsp4[0], 0.2));
		double bsp3s = GetSurfaceProperties(MakeFace(bsp3[0], 0.0), g, true, true);
		double bsp4s = GetSurfaceProperties(MakeFace(bsp4[0], 0.0), g, true, true);
		double bsp3v = GetVolumeProperties(MakeFace(bsp3[0], 0.0), g, true, true);
		double bsp4v = GetVolumeProperties(MakeFace(bsp4[0], 0.0), g, true, true);
		CHECK(bsp3s == Approx(bsp4s).margin(0.02));
		CHECK(bsp3v == Approx(bsp4v).margin(0.02));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static std::vector<std::shared_ptr<Geom3BSplineSurface>> SweepOneRail( const std::vector<NURBSCurveSection>& profile, const std::shared_ptr<Geom3BSplineCurve>& spine, double spineRefParam, const std::vector<std::pair<int, double>>& spineCorrParams, bool isClosedSweep, bool isAutoTwist),
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <filesystem>
#include <fstream>
#include <random>
#include <sstream>
#include <nurbs/NURBSAPIGetGeometry.hpp>
#include <nurbs/NURBSAPIConicalSweep.hpp>
#include <boolean/BoolBRepCut.hpp>
#include <common/CartesianCoordinateSystem.hpp>
#include <common/IndexMap.hpp>
#include <common/QuaternionT.hpp>
#include <geomAlgo/LawBSpline.hpp>
#include <geomAlgo/LawConstant.hpp>
#include <nurbs/NURBSAPISmooth.hpp>
#include <geomAlgo/MakeConic2FromConstraints.hpp>
#include <geometry/Adaptor3CurveOnSurface.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/AdaptorGeom3Surface.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/Geom2Circle.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/Geom2Hyperbola.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom3BSplineCurve.hpp>
#include <geometry/Geom3BSplineSurface.hpp>
#include <geometry/Geom3Circle.hpp>
#include <geometry/Geom3Line.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
#include <geometry/Geom3Plane.hpp>
#include <geometry/Geom3SphericalSurface.hpp>
#include <geometry/Geom3Surface.hpp>
#include <geometry/Geom3TrimmedCurve.hpp>
#include <geometry/Geom3TrimmedSurface.hpp>
#include <geometry/GeomAPIExtremaCurveCurve3.hpp>
#include <geometry/GeomAPIProjectPointOnCurve2.hpp>
#include <geometry/GeomAPIProjectPointOnCurve3.hpp>
#include <geometry/GeomAPIProjectPointOnSurface.hpp>
#include <geometry/GeometryTool.hpp>
#include <geometry/GlobalProperty.hpp>
#include <healing/ShapeFixTool.hpp>
#include <io/STLTool.hpp>
#include <math/Sphere.hpp>
#include <math/TriangularMesh.hpp>
#include <modeling/CopyShape.hpp>
#include <modeling/MakeBox.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeFace.hpp>
#include <modeling/MakePrism.hpp>
#include <modeling/MakeRevol.hpp>
#include <modeling/MakeShapeTool.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeWire.hpp>
#include <modeling/TransformShape.hpp>
#include <nurbs/NURBSAPIApprox.hpp>
#include <nurbs/NURBSAPIBuildCurve.hpp>
#include <nurbs/NURBSAPICircularSweep.hpp>
#include <nurbs/NURBSAPIConvert.hpp>
#include <nurbs/NURBSAPICurveNetworkSurface.hpp>
#include <nurbs/NURBSAPIExplicitSweep.hpp>
#include <nurbs/NURBSAPIExplode.hpp>
#include <nurbs/NURBSAPIExtend.hpp>
#include <nurbs/NURBSAPIInterpolate.hpp>
#include <nurbs/NURBSAPIJoin.hpp>
#include <nurbs/NURBSAPILinearSweep.hpp>
#include <nurbs/NURBSAPILoft.hpp>
#include <nurbs/NURBSAPIMakeNURBSFromBoundaries.hpp>
#include <nurbs/NURBSAPIMatch.hpp>
#include <nurbs/NURBSAPIModifyEndToPlane.hpp>
#include <nurbs/NURBSAPIOffsetCurveOnSurface.hpp>
#include <nurbs/NURBSAPIProject.hpp>
#include <nurbs/NURBSAPIRebuild.hpp>
#include <nurbs/NURBSAPIReplaceEdge.hpp>
#include <nurbs/NURBSAPISweep.hpp>
#include <nurbs/NURBSAPISweep2.hpp>
#include <nurbs/NURBSAPISweepRotation.hpp>
#include <nurbs/NURBSAPITrim.hpp>
#include <nurbs/NURBSAPIUntrim.hpp>
#include <nurbs/NURBSLinearSweepWithDraftDirectionLength.hpp>
#include <occtio/OCCTTool.hpp>
#include <offset/MakePipe.hpp>
#include <offset/MakePipeShell.hpp>
#include <topology/BRepAdaptorCurve2.hpp>
#include <topology/BRepAdaptorCurve3.hpp>
#include <topology/BRepAdaptorSurface.hpp>
#include <topology/BRepGlobalProperty.hpp>
#include <topology/BRepTool.hpp>
#include <topology/TopoBuilder.hpp>
#include <topology/TopoCompound.hpp>
#include <topology/TopoEdge.hpp>
#include <topology/TopoExplorer.hpp>
#include <topology/TopoExplorerTool.hpp>
#include <topology/TopoFace.hpp>
#include <topology/TopoShape.hpp>
#include <topology/TopoShell.hpp>
#include <topology/TopoTool.hpp>
#include <topology/TopoVertex.hpp>
#include <topology/TopoWire.hpp>
#include <topology/WireExplorer.hpp>
#include <topomesh/BRepMeshIncrementalMesh.hpp>
#include <nurbs/NURBSAPIBlend.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
#include <math/LineT.hpp>
#include <hatch/BRepClassificationTools.hpp>
using namespace AMCAX;
namespace
{
	std::shared_ptr<Geom3BSplineCurve> CurveChooser(const int id, const std::shared_ptr<Geom3BSplineCurve>& curve0, const std::shared_ptr<Geom3BSplineCurve>& curve1, const std::shared_ptr<Geom3BSplineCurve>& curve2)
	{
		std::shared_ptr<Geom3BSplineCurve> result;
		switch (id)
		{
		case 0:
		{
			result = curve0;
			break;
		}
		case 1:
		{
			result = curve1;
			break;
		}
		case 2:
		{
			result = curve2;
			break;
		}
		}
		return result;
	}
}		
GlobalProperty g;
#include<catch.hpp>
#include<testHelper.h>
#include <filesystem>
#include <fstream>
#include <random>
#include <sstream>
#include <nurbs/NURBSAPIGetGeometry.hpp>
#include <nurbs/NURBSAPIConicalSweep.hpp>
#include <boolean/BoolBRepCut.hpp>
#include <common/CartesianCoordinateSystem.hpp>
#include <common/IndexMap.hpp>
#include <common/QuaternionT.hpp>
#include <geomAlgo/LawBSpline.hpp>
#include <geomAlgo/LawConstant.hpp>
#include <nurbs/NURBSAPISmooth.hpp>
#include <geomAlgo/MakeConic2FromConstraints.hpp>
#include <geometry/Adaptor3CurveOnSurface.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/AdaptorGeom3Surface.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/Geom2Circle.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/Geom2Hyperbola.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom3BSplineCurve.hpp>
#include <geometry/Geom3BSplineSurface.hpp>
#include <geometry/Geom3Circle.hpp>
#include <geometry/Geom3Line.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
#include <geometry/Geom3Plane.hpp>
#include <geometry/Geom3SphericalSurface.hpp>
#include <geometry/Geom3Surface.hpp>
#include <geometry/Geom3TrimmedCurve.hpp>
#include <geometry/Geom3TrimmedSurface.hpp>
#include <geometry/GeomAPIExtremaCurveCurve3.hpp>
#include <geometry/GeomAPIProjectPointOnCurve2.hpp>
#include <geometry/GeomAPIProjectPointOnCurve3.hpp>
#include <geometry/GeomAPIProjectPointOnSurface.hpp>
#include <geometry/GeometryTool.hpp>
#include <geometry/GlobalProperty.hpp>
#include <healing/ShapeFixTool.hpp>
#include <io/STLTool.hpp>
#include <math/Sphere.hpp>
#include <math/TriangularMesh.hpp>
#include <modeling/CopyShape.hpp>
#include <modeling/MakeBox.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeFace.hpp>
#include <modeling/MakePrism.hpp>
#include <modeling/MakeRevol.hpp>
#include <modeling/MakeShapeTool.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeWire.hpp>
#include <modeling/TransformShape.hpp>
#include <nurbs/NURBSAPIApprox.hpp>
#include <nurbs/NURBSAPIBuildCurve.hpp>
#include <nurbs/NURBSAPICircularSweep.hpp>
#include <nurbs/NURBSAPIConvert.hpp>
#include <nurbs/NURBSAPICurveNetworkSurface.hpp>
#include <nurbs/NURBSAPIExplicitSweep.hpp>
#include <nurbs/NURBSAPIExplode.hpp>
#include <nurbs/NURBSAPIExtend.hpp>
#include <nurbs/NURBSAPIInterpolate.hpp>
#include <nurbs/NURBSAPIJoin.hpp>
#include <nurbs/NURBSAPILinearSweep.hpp>
#include <nurbs/NURBSAPILoft.hpp>
#include <nurbs/NURBSAPIMakeNURBSFromBoundaries.hpp>
#include <nurbs/NURBSAPIMatch.hpp>
#include <nurbs/NURBSAPIModifyEndToPlane.hpp>
#include <nurbs/NURBSAPIOffsetCurveOnSurface.hpp>
#include <nurbs/NURBSAPIProject.hpp>
#include <nurbs/NURBSAPIRebuild.hpp>
#include <nurbs/NURBSAPIReplaceEdge.hpp>
#include <nurbs/NURBSAPISweep.hpp>
#include <nurbs/NURBSAPISweep2.hpp>
#include <nurbs/NURBSAPISweepRotation.hpp>
#include <nurbs/NURBSAPITrim.hpp>
#include <nurbs/NURBSAPIUntrim.hpp>
#include <nurbs/NURBSLinearSweepWithDraftDirectionLength.hpp>
#include <occtio/OCCTTool.hpp>
#include <offset/MakePipe.hpp>
#include <offset/MakePipeShell.hpp>
#include <topology/BRepAdaptorCurve2.hpp>
#include <topology/BRepAdaptorCurve3.hpp>
#include <topology/BRepAdaptorSurface.hpp>
#include <topology/BRepGlobalProperty.hpp>
#include <topology/BRepTool.hpp>
#include <topology/TopoBuilder.hpp>
#include <topology/TopoCompound.hpp>
#include <topology/TopoEdge.hpp>
#include <topology/TopoExplorer.hpp>
#include <topology/TopoExplorerTool.hpp>
#include <topology/TopoFace.hpp>
#include <topology/TopoShape.hpp>
#include <topology/TopoShell.hpp>
#include <topology/TopoTool.hpp>
#include <topology/TopoVertex.hpp>
#include <topology/TopoWire.hpp>
#include <topology/WireExplorer.hpp>
#include <topomesh/BRepMeshIncrementalMesh.hpp>
#include <nurbs/NURBSAPIBlend.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
#include <math/LineT.hpp>
#include <hatch/BRepClassificationTools.hpp>
using namespace AMCAX;
namespace
{
	std::shared_ptr<Geom3BSplineCurve> CurveChooser(const int id, const std::shared_ptr<Geom3BSplineCurve>& curve0, const std::shared_ptr<Geom3BSplineCurve>& curve1, const std::shared_ptr<Geom3BSplineCurve>& curve2)
	{
		std::shared_ptr<Geom3BSplineCurve> result;
		switch (id)
		{
		case 0:
		{
			result = curve0;
			break;
		}
		case 1:
		{
			result = curve1;
			break;
		}
		case 2:
		{
			result = curve2;
			break;
		}
		}
		return result;
	}
;
	SECTION("TestSweepTest1()")
	{
		std::shared_ptr<Geom3BSplineCurve> bsp1, bsp2;
		{
			int deg = 3;
			std::vector<Point3> poles;
			poles.push_back(Point3(0.0, -1.0, 0.0));
			poles.push_back(Point3(0.7, -0.7, 0.0));
			poles.push_back(Point3(1.0, -0.3, 0.0));
			poles.push_back(Point3(1.2, 0.0, 0.0));
			poles.push_back(Point3(2.0, 0.3, 0.0));
			poles.push_back(Point3(0.7, 1.7, 0.0));
			poles.push_back(Point3(0.0, 1.0, 0.0));
			poles.push_back(Point3(-0.7, 1.7, 0.0));
			poles.push_back(Point3(-2.0, 0.3, 0.0));
			poles.push_back(Point3(-1.2, 0.0, 0.0));
			poles.push_back(Point3(-1.0, -0.3, 0.0));
			poles.push_back(Point3(-0.7, -0.7, 0.0));
			poles.push_back(Point3(0.0, -1.0, 0.0));
			std::vector<double> weights;
			weights.push_back(1.0);
			weights.push_back(1.2);
			weights.push_back(1.3);
			weights.push_back(1.4);
			weights.push_back(1.5);
			weights.push_back(1.6);
			weights.push_back(1.7);
			weights.push_back(1.8);
			weights.push_back(1.9);
			weights.push_back(1.0);
			weights.push_back(1.1);
			weights.push_back(1.3);
			weights.push_back(1.0);
			int nknots = static_cast<int>(poles.size()) - deg + 1;
			std::vector<double> knots(nknots);
			for (int i = 0; i < nknots; i++)
			{
				knots[i] = (double)i / (double)(nknots - 1.0);
			}
			std::vector<int> mults(nknots, 1);
			mults.front() = 4;
			mults.back() = 4;
			bsp1 = std::make_shared<Geom3BSplineCurve>(poles, weights, knots, mults, deg);
			CHECK(OCCTIO::OCCTTool::Write(MakeEdge(bsp1), OUTPUT_PATH_PREFIX "TestSweepTest1_bsp1.brep"));
		}
		{
			std::vector<Point3> spinePoles;
			std::vector<double> spineKnots(4);
			std::vector<int> spineMults(4, 1);
			spinePoles.push_back(Point3(0.0, 1.0, 0.0));
			spinePoles.push_back(Point3(-0.1, -0.8, 1.0));
			spinePoles.push_back(Point3(0.1, -0.5, 2.0));
			spinePoles.push_back(Point3(0.2, -0.7, 3.0));
			spinePoles.push_back(Point3(0.1, -0.9, 3.5));
			spinePoles.push_back(Point3(0.0, -1.1, 4.5));
			std::vector<double> weights;
			weights.push_back(1.4);
			weights.push_back(1.7);
			weights.push_back(1.1);
			weights.push_back(1.3);
			weights.push_back(1.0);
			weights.push_back(0.9);
			spineKnots[0] = 0;
			spineKnots[1] = 1.0 / 3.0;
			spineKnots[2] = 2.0 / 3.0;
			spineKnots[3] = 1;
			spineMults.front() = 4;
			spineMults.back() = 4;
			bsp2 = std::make_shared<Geom3BSplineCurve>(spinePoles, weights, spineKnots, spineMults, 3);
			CHECK(OCCTIO::OCCTTool::Write(MakeEdge(bsp2), OUTPUT_PATH_PREFIX "TestSweepTest1_bsp2.brep"));
		}
		bool isParallel = false;
		auto bsp3 = NURBSAPISweep::SweepOneRail(bsp1, bsp2, isParallel);
		for (int i = 0; i < static_cast<int>(bsp3.size()); i++)
		{
			std::string filename = OUTPUT_PATH_PREFIX "TestSweepTest1_result" + std::to_string(i) + ".brep";
			CHECK(OCCTIO::OCCTTool::Write(MakeFace(bsp3[i], 0.0), filename.c_str()));
		}
		CHECK(bsp3.size() == 1);
		AMCAX::BRepExtremaDistShapeShape len(MakeEdge(bsp1), MakeFace(bsp3[0], 0.0));
		CHECK(len.Value() == Approx(0.0).margin(0.1));
		CHECK(IsCurveOnSurf(1000, 0.2, bsp1, bsp3[0], 0.2));
		bsp2->IncreaseDegree(25);
		bsp1->IncreaseDegree(25);
		auto bsp4 = NURBSAPISweep::SweepOneRail(bsp1, bsp2, isParallel);
		CHECK(OCCTIO::OCCTTool::Write(MakeFace(bsp4[0], 0.0), OUTPUT_PATH_PREFIX "TestSweepTest1_degree25result.brep"));
		AMCAX::BRepExtremaDistShapeShape len1(MakeEdge(bsp1), MakeFace(bsp4[0], 0.0));
		CHECK(len1.Value() == Approx(0.0).margin(0.1));
		CHECK(IsCurveOnSurf(1000, 0.2, bsp1, bsp4[0], 0.2));
		double bsp3s = GetSurfaceProperties(MakeFace(bsp3[0], 0.0), g, true, true);
		double bsp4s = GetSurfaceProperties(MakeFace(bsp4[0], 0.0), g, true, true);
		double bsp3v = GetVolumeProperties(MakeFace(bsp3[0], 0.0), g, true, true);
		double bsp4v = GetVolumeProperties(MakeFace(bsp4[0], 0.0), g, true, true);
		CHECK(bsp3s == Approx(bsp4s).margin(0.02));
		CHECK(bsp3v == Approx(bsp4v).margin(0.02));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static std::vector<std::shared_ptr<Geom3BSplineSurface>> SweepOneRail( const std::shared_ptr<Geom3BSplineCurve>& profile, const std::shared_ptr<Geom3BSplineCurve>& spine, bool isParallel),
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeFace.hpp>
#include <nurbs/NURBSAPIConvert.hpp>
#include <topology/TopoTool.hpp>
#include <nurbs/NURBSAPIExplicitSweep.hpp>
#include <modeling/MakeVertex.hpp>
#include <nurbs/NURBSAPISweep.hpp>
#include<catch.hpp>
#include<testHelper.h>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeFace.hpp>
#include <nurbs/NURBSAPIConvert.hpp>
#include <topology/TopoTool.hpp>
#include <nurbs/NURBSAPIExplicitSweep.hpp>
#include <modeling/MakeVertex.hpp>
#include <nurbs/NURBSAPISweep.hpp>
;
	SECTION("TestSweepMoreover2()")
	{
		std::string filedir = INPUT_PATH_PREFIX "/TestNURBS/TestSweepMoreover2/";
		auto spine = ReadBRepCurve(filedir + "spine.brep");
		auto profile = ReadBRepCurve(filedir + "profile.brep");
		CHECK(OCCTIO::OCCTTool::Write(MakeEdge(spine), OUTPUT_PATH_PREFIX "TestSweepMoreover2_spine.brep"));
		CHECK(OCCTIO::OCCTTool::Write(MakeEdge(profile), OUTPUT_PATH_PREFIX "TestSweepMoreover2_spine.brep"));
		auto surfaces = NURBSAPISweep::SweepOneRail(profile, spine, false);
		std::shared_ptr<Geom3BSplineSurface> result = surfaces[0];
		CHECK(OCCTIO::OCCTTool::Write(MakeFace(result, 0.0), OUTPUT_PATH_PREFIX "TestSweepMoreover2_surface.brep"));
		CHECK(IsCurveOnSurf(100, 0.1, profile, surfaces[0], 0.01));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static std::vector<std::shared_ptr<Geom3BSplineSurface>> SweepOneRail( const std::shared_ptr<Geom3BSplineCurve>& profile, const std::shared_ptr<Geom3BSplineCurve>& spine, double spineParam, bool isParallel),
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeFace.hpp>
#include <nurbs/NURBSAPIConvert.hpp>
#include <topology/TopoTool.hpp>
#include <nurbs/NURBSAPIExplicitSweep.hpp>
#include <modeling/MakeVertex.hpp>
#include <nurbs/NURBSAPISweep.hpp>
#include<catch.hpp>
#include<testHelper.h>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeFace.hpp>
#include <nurbs/NURBSAPIConvert.hpp>
#include <topology/TopoTool.hpp>
#include <nurbs/NURBSAPIExplicitSweep.hpp>
#include <modeling/MakeVertex.hpp>
#include <nurbs/NURBSAPISweep.hpp>
;
	SECTION("TestSweepMoreover1()")
	{
		std::string filedir = INPUT_PATH_PREFIX "/TestNURBS/TestSweepMoreover1-2/";
		auto spine = ReadBRepCurve(filedir + "spine.brep");
		std::vector<NURBSCurveSection> profiles;
		for (int i = 1; i <= 4; i++)
		{
			auto p = ReadBRepCurve(filedir + "profile" + std::to_string(i) + ".brep");
			p->SetPeriodic();
			CHECK(OCCTIO::OCCTTool::Write(MakeEdge(p), OUTPUT_PATH_PREFIX "TestSweepMoreover1_profile" + std::to_string(i) + ".brep"));
			profiles.push_back(NURBSCurveSection(p));
		}
		CHECK(OCCTIO::OCCTTool::Write(MakeEdge(spine), OUTPUT_PATH_PREFIX "TestSweepMoreover1_spine.brep"));
		bool isClosedSweep = true;
		bool isAutoTwist = true;
		std::vector<std::pair<int, double>> corrParams;
		auto surfaces = NURBSAPISweep::SweepOneRail(profiles, spine, 0.1, corrParams, isClosedSweep, isAutoTwist);
		std::shared_ptr<Geom3BSplineSurface> result = surfaces[0];
		CHECK(OCCTIO::OCCTTool::Write(MakeFace(result, 0.0), OUTPUT_PATH_PREFIX "TestSweepMoreover2_surface.brep"));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static std::vector<std::shared_ptr<Geom3BSplineSurface>> SweepOneRail( const std::vector<NURBSCurveSection>& profile, const std::shared_ptr<Geom3BSplineCurve>& spine, double spineRefParam, const std::vector<std::pair<int, double>>& spineCorrParams, bool isClosedSweep, bool isAutoTwist),
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeFace.hpp>
#include <nurbs/NURBSAPIConvert.hpp>
#include <topology/TopoTool.hpp>
#include <nurbs/NURBSAPIExplicitSweep.hpp>
#include <modeling/MakeVertex.hpp>
#include <nurbs/NURBSAPISweep.hpp>
#include<catch.hpp>
#include<testHelper.h>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeFace.hpp>
#include <nurbs/NURBSAPIConvert.hpp>
#include <topology/TopoTool.hpp>
#include <nurbs/NURBSAPIExplicitSweep.hpp>
#include <modeling/MakeVertex.hpp>
#include <nurbs/NURBSAPISweep.hpp>
;
	SECTION("TestSweepMoreover1()")
	{
		std::string filedir = INPUT_PATH_PREFIX "/TestNURBS/TestSweepMoreover1-2/";
		auto spine = ReadBRepCurve(filedir + "spine.brep");
		std::vector<NURBSCurveSection> profiles;
		for (int i = 1; i <= 4; i++)
		{
			auto p = ReadBRepCurve(filedir + "profile" + std::to_string(i) + ".brep");
			p->SetPeriodic();
			CHECK(OCCTIO::OCCTTool::Write(MakeEdge(p), OUTPUT_PATH_PREFIX "TestSweepMoreover1_profile" + std::to_string(i) + ".brep"));
			profiles.push_back(NURBSCurveSection(p));
		}
		CHECK(OCCTIO::OCCTTool::Write(MakeEdge(spine), OUTPUT_PATH_PREFIX "TestSweepMoreover1_spine.brep"));
		bool isClosedSweep = true;
		bool isAutoTwist = true;
		std::vector<std::pair<int, double>> corrParams;
		auto surfaces = NURBSAPISweep::SweepOneRail(profiles, spine, 0.1, corrParams, isClosedSweep, isAutoTwist);
		std::shared_ptr<Geom3BSplineSurface> result = surfaces[0];
		CHECK(OCCTIO::OCCTTool::Write(MakeFace(result, 0.0), OUTPUT_PATH_PREFIX "TestSweepMoreover2_surface.brep"));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static std::vector<std::shared_ptr<Geom3BSplineSurface>> SweepTwoRails( const std::shared_ptr<Geom3BSplineCurve>& profile, const std::shared_ptr<Geom3BSplineCurve>& spine1, const std::shared_ptr<Geom3BSplineCurve>& spine2),
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <filesystem>
#include <fstream>
#include <random>
#include <sstream>
#include <nurbs/NURBSAPIGetGeometry.hpp>
#include <nurbs/NURBSAPIConicalSweep.hpp>
#include <boolean/BoolBRepCut.hpp>
#include <common/CartesianCoordinateSystem.hpp>
#include <common/IndexMap.hpp>
#include <common/QuaternionT.hpp>
#include <geomAlgo/LawBSpline.hpp>
#include <geomAlgo/LawConstant.hpp>
#include <nurbs/NURBSAPISmooth.hpp>
#include <geomAlgo/MakeConic2FromConstraints.hpp>
#include <geometry/Adaptor3CurveOnSurface.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/AdaptorGeom3Surface.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/Geom2Circle.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/Geom2Hyperbola.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom3BSplineCurve.hpp>
#include <geometry/Geom3BSplineSurface.hpp>
#include <geometry/Geom3Circle.hpp>
#include <geometry/Geom3Line.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
#include <geometry/Geom3Plane.hpp>
#include <geometry/Geom3SphericalSurface.hpp>
#include <geometry/Geom3Surface.hpp>
#include <geometry/Geom3TrimmedCurve.hpp>
#include <geometry/Geom3TrimmedSurface.hpp>
#include <geometry/GeomAPIExtremaCurveCurve3.hpp>
#include <geometry/GeomAPIProjectPointOnCurve2.hpp>
#include <geometry/GeomAPIProjectPointOnCurve3.hpp>
#include <geometry/GeomAPIProjectPointOnSurface.hpp>
#include <geometry/GeometryTool.hpp>
#include <geometry/GlobalProperty.hpp>
#include <healing/ShapeFixTool.hpp>
#include <io/STLTool.hpp>
#include <math/Sphere.hpp>
#include <math/TriangularMesh.hpp>
#include <modeling/CopyShape.hpp>
#include <modeling/MakeBox.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeFace.hpp>
#include <modeling/MakePrism.hpp>
#include <modeling/MakeRevol.hpp>
#include <modeling/MakeShapeTool.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeWire.hpp>
#include <modeling/TransformShape.hpp>
#include <nurbs/NURBSAPIApprox.hpp>
#include <nurbs/NURBSAPIBuildCurve.hpp>
#include <nurbs/NURBSAPICircularSweep.hpp>
#include <nurbs/NURBSAPIConvert.hpp>
#include <nurbs/NURBSAPICurveNetworkSurface.hpp>
#include <nurbs/NURBSAPIExplicitSweep.hpp>
#include <nurbs/NURBSAPIExplode.hpp>
#include <nurbs/NURBSAPIExtend.hpp>
#include <nurbs/NURBSAPIInterpolate.hpp>
#include <nurbs/NURBSAPIJoin.hpp>
#include <nurbs/NURBSAPILinearSweep.hpp>
#include <nurbs/NURBSAPILoft.hpp>
#include <nurbs/NURBSAPIMakeNURBSFromBoundaries.hpp>
#include <nurbs/NURBSAPIMatch.hpp>
#include <nurbs/NURBSAPIModifyEndToPlane.hpp>
#include <nurbs/NURBSAPIOffsetCurveOnSurface.hpp>
#include <nurbs/NURBSAPIProject.hpp>
#include <nurbs/NURBSAPIRebuild.hpp>
#include <nurbs/NURBSAPIReplaceEdge.hpp>
#include <nurbs/NURBSAPISweep.hpp>
#include <nurbs/NURBSAPISweep2.hpp>
#include <nurbs/NURBSAPISweepRotation.hpp>
#include <nurbs/NURBSAPITrim.hpp>
#include <nurbs/NURBSAPIUntrim.hpp>
#include <nurbs/NURBSLinearSweepWithDraftDirectionLength.hpp>
#include <occtio/OCCTTool.hpp>
#include <offset/MakePipe.hpp>
#include <offset/MakePipeShell.hpp>
#include <topology/BRepAdaptorCurve2.hpp>
#include <topology/BRepAdaptorCurve3.hpp>
#include <topology/BRepAdaptorSurface.hpp>
#include <topology/BRepGlobalProperty.hpp>
#include <topology/BRepTool.hpp>
#include <topology/TopoBuilder.hpp>
#include <topology/TopoCompound.hpp>
#include <topology/TopoEdge.hpp>
#include <topology/TopoExplorer.hpp>
#include <topology/TopoExplorerTool.hpp>
#include <topology/TopoFace.hpp>
#include <topology/TopoShape.hpp>
#include <topology/TopoShell.hpp>
#include <topology/TopoTool.hpp>
#include <topology/TopoVertex.hpp>
#include <topology/TopoWire.hpp>
#include <topology/WireExplorer.hpp>
#include <topomesh/BRepMeshIncrementalMesh.hpp>
#include <nurbs/NURBSAPIBlend.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
#include <math/LineT.hpp>
#include <hatch/BRepClassificationTools.hpp>
using namespace AMCAX;
namespace
{
	std::shared_ptr<Geom3BSplineCurve> CurveChooser(const int id, const std::shared_ptr<Geom3BSplineCurve>& curve0, const std::shared_ptr<Geom3BSplineCurve>& curve1, const std::shared_ptr<Geom3BSplineCurve>& curve2)
	{
		std::shared_ptr<Geom3BSplineCurve> result;
		switch (id)
		{
		case 0:
		{
			result = curve0;
			break;
		}
		case 1:
		{
			result = curve1;
			break;
		}
		case 2:
		{
			result = curve2;
			break;
		}
		}
		return result;
	}
}
#include<catch.hpp>
#include<testHelper.h>
#include <filesystem>
#include <fstream>
#include <random>
#include <sstream>
#include <nurbs/NURBSAPIGetGeometry.hpp>
#include <nurbs/NURBSAPIConicalSweep.hpp>
#include <boolean/BoolBRepCut.hpp>
#include <common/CartesianCoordinateSystem.hpp>
#include <common/IndexMap.hpp>
#include <common/QuaternionT.hpp>
#include <geomAlgo/LawBSpline.hpp>
#include <geomAlgo/LawConstant.hpp>
#include <nurbs/NURBSAPISmooth.hpp>
#include <geomAlgo/MakeConic2FromConstraints.hpp>
#include <geometry/Adaptor3CurveOnSurface.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/AdaptorGeom3Surface.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/Geom2Circle.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/Geom2Hyperbola.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom3BSplineCurve.hpp>
#include <geometry/Geom3BSplineSurface.hpp>
#include <geometry/Geom3Circle.hpp>
#include <geometry/Geom3Line.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
#include <geometry/Geom3Plane.hpp>
#include <geometry/Geom3SphericalSurface.hpp>
#include <geometry/Geom3Surface.hpp>
#include <geometry/Geom3TrimmedCurve.hpp>
#include <geometry/Geom3TrimmedSurface.hpp>
#include <geometry/GeomAPIExtremaCurveCurve3.hpp>
#include <geometry/GeomAPIProjectPointOnCurve2.hpp>
#include <geometry/GeomAPIProjectPointOnCurve3.hpp>
#include <geometry/GeomAPIProjectPointOnSurface.hpp>
#include <geometry/GeometryTool.hpp>
#include <geometry/GlobalProperty.hpp>
#include <healing/ShapeFixTool.hpp>
#include <io/STLTool.hpp>
#include <math/Sphere.hpp>
#include <math/TriangularMesh.hpp>
#include <modeling/CopyShape.hpp>
#include <modeling/MakeBox.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeFace.hpp>
#include <modeling/MakePrism.hpp>
#include <modeling/MakeRevol.hpp>
#include <modeling/MakeShapeTool.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeWire.hpp>
#include <modeling/TransformShape.hpp>
#include <nurbs/NURBSAPIApprox.hpp>
#include <nurbs/NURBSAPIBuildCurve.hpp>
#include <nurbs/NURBSAPICircularSweep.hpp>
#include <nurbs/NURBSAPIConvert.hpp>
#include <nurbs/NURBSAPICurveNetworkSurface.hpp>
#include <nurbs/NURBSAPIExplicitSweep.hpp>
#include <nurbs/NURBSAPIExplode.hpp>
#include <nurbs/NURBSAPIExtend.hpp>
#include <nurbs/NURBSAPIInterpolate.hpp>
#include <nurbs/NURBSAPIJoin.hpp>
#include <nurbs/NURBSAPILinearSweep.hpp>
#include <nurbs/NURBSAPILoft.hpp>
#include <nurbs/NURBSAPIMakeNURBSFromBoundaries.hpp>
#include <nurbs/NURBSAPIMatch.hpp>
#include <nurbs/NURBSAPIModifyEndToPlane.hpp>
#include <nurbs/NURBSAPIOffsetCurveOnSurface.hpp>
#include <nurbs/NURBSAPIProject.hpp>
#include <nurbs/NURBSAPIRebuild.hpp>
#include <nurbs/NURBSAPIReplaceEdge.hpp>
#include <nurbs/NURBSAPISweep.hpp>
#include <nurbs/NURBSAPISweep2.hpp>
#include <nurbs/NURBSAPISweepRotation.hpp>
#include <nurbs/NURBSAPITrim.hpp>
#include <nurbs/NURBSAPIUntrim.hpp>
#include <nurbs/NURBSLinearSweepWithDraftDirectionLength.hpp>
#include <occtio/OCCTTool.hpp>
#include <offset/MakePipe.hpp>
#include <offset/MakePipeShell.hpp>
#include <topology/BRepAdaptorCurve2.hpp>
#include <topology/BRepAdaptorCurve3.hpp>
#include <topology/BRepAdaptorSurface.hpp>
#include <topology/BRepGlobalProperty.hpp>
#include <topology/BRepTool.hpp>
#include <topology/TopoBuilder.hpp>
#include <topology/TopoCompound.hpp>
#include <topology/TopoEdge.hpp>
#include <topology/TopoExplorer.hpp>
#include <topology/TopoExplorerTool.hpp>
#include <topology/TopoFace.hpp>
#include <topology/TopoShape.hpp>
#include <topology/TopoShell.hpp>
#include <topology/TopoTool.hpp>
#include <topology/TopoVertex.hpp>
#include <topology/TopoWire.hpp>
#include <topology/WireExplorer.hpp>
#include <topomesh/BRepMeshIncrementalMesh.hpp>
#include <nurbs/NURBSAPIBlend.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
#include <math/LineT.hpp>
#include <hatch/BRepClassificationTools.hpp>
using namespace AMCAX;
namespace
{
	std::shared_ptr<Geom3BSplineCurve> CurveChooser(const int id, const std::shared_ptr<Geom3BSplineCurve>& curve0, const std::shared_ptr<Geom3BSplineCurve>& curve1, const std::shared_ptr<Geom3BSplineCurve>& curve2)
	{
		std::shared_ptr<Geom3BSplineCurve> result;
		switch (id)
		{
		case 0:
		{
			result = curve0;
			break;
		}
		case 1:
		{
			result = curve1;
			break;
		}
		case 2:
		{
			result = curve2;
			break;
		}
		}
		return result;
	}
;
	SECTION("TestSweep2()")
		{
			std::shared_ptr<Geom3BSplineCurve> bsp1, bsp2, bsp3;
			{
				int deg = 3;
				std::vector<Point3> poles;
				poles.push_back(Point3(0.0, -1.0, 0.0));
				poles.push_back(Point3(0.7, -0.7, 0.0));
				poles.push_back(Point3(1.0, -0.3, 0.0));
				poles.push_back(Point3(1.2, 0.0, -0.0));
				poles.push_back(Point3(2.0, 0.3, -0.0));
				poles.push_back(Point3(0.7, 1.7, -0.0));
				poles.push_back(Point3(0.0, 1.0, 0.0));
				poles.push_back(Point3(-0.7, 1.7, -0.0));
				poles.push_back(Point3(-2.0, 0.3, -0.0));
				poles.push_back(Point3(-1.2, 0.0, -0.0));
				poles.push_back(Point3(-1.0, -0.3, 0.0));
				poles.push_back(Point3(-0.7, -0.7, 0.0));
				poles.push_back(Point3(0.0, -1.0, 0.0));
				std::vector<double> weights;
				weights.push_back(0.9);
				weights.push_back(1.1);
				weights.push_back(1.2);
				weights.push_back(0.7);
				weights.push_back(1.5);
				weights.push_back(0.9);
				weights.push_back(1.2);
				weights.push_back(1.5);
				weights.push_back(0.8);
				weights.push_back(0.5);
				weights.push_back(1.1);
				weights.push_back(1.0);
				weights.push_back(1.3);
				int nknots = static_cast<int>(poles.size()) - deg + 1;
				std::vector<double> knots(nknots);
				for (int i = 0; i < nknots; i++)
				{
					knots[i] = (double)i / (double)(nknots - 1.0);
				}
				std::vector<int> mults(nknots, 1);
				mults.front() = 4;
				mults.back() = 4;
				bsp1 = std::make_shared<Geom3BSplineCurve>(poles, weights, knots, mults, deg);
			}
			{
				int deg = 3;
				std::vector<Point3> poles;
				poles.push_back(Point3(0.0, 1.0, 0.0));
				poles.push_back(Point3(0.0, 0.7, 0.0));
				poles.push_back(Point3(0.0, 0.3, 0.5));
				poles.push_back(Point3(0.0, 0.3, 1.0));
				std::vector<double> weights;
				weights.push_back(0.9);
				weights.push_back(1.1);
				weights.push_back(1.2);
				weights.push_back(0.7);
				int nknots = static_cast<int>(poles.size()) - deg + 1;
				std::vector<double> knots(nknots);
				for (int i = 0; i < nknots; i++)
				{
					knots[i] = (double)i / (double)(nknots - 1.0);
				}
				std::vector<int> mults(nknots, 1);
				mults.front() = 4;
				mults.back() = 4;
				bsp2 = std::make_shared<Geom3BSplineCurve>(poles, weights, knots, mults, 3);
			}
			{
				int deg = 3;
				std::vector<Point3> poles;
				poles.push_back(Point3(0.0, -1.0, 0.0));
				poles.push_back(Point3(0.0, -0.5, 0.0));
				poles.push_back(Point3(0.0, -0.2, 0.5));
				poles.push_back(Point3(0.0, -0.2, 1.0));
				std::vector<double> weights;
				weights.push_back(0.7);
				weights.push_back(1.5);
				weights.push_back(0.9);
				weights.push_back(1.2);
				int nknots = static_cast<int>(poles.size()) - deg + 1;
				std::vector<double> knots(nknots);
				for (int i = 0; i < nknots; i++)
				{
					knots[i] = (double)i / (double)(nknots - 1.0);
				}
				std::vector<int> mults(nknots, 1);
				mults.front() = 4;
				mults.back() = 4;
				bsp3 = std::make_shared<Geom3BSplineCurve>(poles, weights, knots, mults, 3);
			}
			CHECK(OCCTIO::OCCTTool::Write(MakeEdge(bsp1), OUTPUT_PATH_PREFIX "TestSweep2_profile.brep"));
			CHECK(OCCTIO::OCCTTool::Write(MakeEdge(bsp2), OUTPUT_PATH_PREFIX "TestSweep2_spine1.brep"));
			CHECK(OCCTIO::OCCTTool::Write(MakeEdge(bsp3), OUTPUT_PATH_PREFIX "TestSweep2_spine2.brep"));
			auto bsp4 = NURBSAPISweep2::SweepTwoRails(bsp1, bsp2, bsp3);
			CHECK(OCCTIO::OCCTTool::Write(MakeFace(bsp4[0], 0.0), OUTPUT_PATH_PREFIX "TestSweep2_result.brep"));
			CHECK(bsp4.size() == 1);
			CHECK(IsCurveOnSurf(1000, 0.2, bsp1, bsp4[0], 0.1));
			CHECK(IsCurveOnSurf(1000, 0.2, bsp3, bsp4[0], 0.1));
			IndexSet<TopoShape> newshapeEdge1;
			TopoExplorerTool::MapShapes(MakeFace(bsp4[0], 0.0), ShapeType::Edge, newshapeEdge1);
			std::cout << "newshapeedge1=" << newshapeEdge1.size() << std::endl;
			CHECK(OCCTIO::OCCTTool::Write(newshapeEdge1[2], OUTPUT_PATH_PREFIX "TestSweep2_newshapeEdge1[2].brep"));
			TopoExplorer ex0(newshapeEdge1[0], ShapeType::Edge);
			TopoExplorer ex1(newshapeEdge1[1], ShapeType::Edge);
			TopoExplorer ex2(newshapeEdge1[2], ShapeType::Edge);
			TopoEdge e0 = static_cast<const TopoEdge&>(ex0.Value());
			TopoEdge e1 = static_cast<const TopoEdge&>(ex1.Value());
			TopoEdge e2 = static_cast<const TopoEdge&>(ex2.Value());
			auto edge0 = NURBSAPIGetGeometry::GetCurve(e0);
			auto edge1 = NURBSAPIGetGeometry::GetCurve(e1);
			auto edge2 = NURBSAPIGetGeometry::GetCurve(e2);
			double n0 = NurbsSampleCurve(100, 0.15, edge0, bsp3);
			double n1 = NurbsSampleCurve(100, 0.15, edge1, bsp1);
			CHECK(n0 < 0.2);
			CHECK(n1 < 0.2);
			GlobalProperty g;
			bsp1->IncreaseDegree(11);
			bsp2->IncreaseDegree(11);
			bsp3->IncreaseDegree(11);
			auto bsp5 = NURBSAPISweep2::SweepTwoRails(bsp1, bsp2, bsp3);
			CHECK(IsCurveOnSurf(1000, 0.2, bsp1, bsp5[0], 0.1));
			CHECK(IsCurveOnSurf(1000, 0.2, bsp3, bsp5[0], 0.1));
			double bsp5s = GetSurfaceProperties(MakeFace(bsp5[0], 0.0), g, true, true);
			double bsp4s = GetSurfaceProperties(MakeFace(bsp4[0], 0.0), g, true, true);
			double bsp5v = GetVolumeProperties(MakeFace(bsp5[0], 0.0), g, true, true);
			double bsp4v = GetVolumeProperties(MakeFace(bsp4[0], 0.0), g, true, true);
			CHECK(bsp5s == Approx(bsp4s).margin(0.02));
			CHECK(bsp5v == Approx(bsp4v).margin(0.02));
		}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static std::vector<std::shared_ptr<Geom3BSplineSurface>> SweepTwoRails( const std::vector<NURBSCurveSection>& profile, const std::shared_ptr<Geom3BSplineCurve>& spine1, const std::shared_ptr<Geom3BSplineCurve>& spine2, double spine1RefParam, const std::vector<std::pair<int, double>>& spine1CorrParams, const std::vector<std::pair<int, double>>& spine2CorrParams, bool isClosedSweep, bool isAutoTwist),
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <filesystem>
#include <fstream>
#include <random>
#include <sstream>
#include <nurbs/NURBSAPIGetGeometry.hpp>
#include <nurbs/NURBSAPIConicalSweep.hpp>
#include <boolean/BoolBRepCut.hpp>
#include <common/CartesianCoordinateSystem.hpp>
#include <common/IndexMap.hpp>
#include <common/QuaternionT.hpp>
#include <geomAlgo/LawBSpline.hpp>
#include <geomAlgo/LawConstant.hpp>
#include <nurbs/NURBSAPISmooth.hpp>
#include <geomAlgo/MakeConic2FromConstraints.hpp>
#include <geometry/Adaptor3CurveOnSurface.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/AdaptorGeom3Surface.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/Geom2Circle.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/Geom2Hyperbola.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom3BSplineCurve.hpp>
#include <geometry/Geom3BSplineSurface.hpp>
#include <geometry/Geom3Circle.hpp>
#include <geometry/Geom3Line.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
#include <geometry/Geom3Plane.hpp>
#include <geometry/Geom3SphericalSurface.hpp>
#include <geometry/Geom3Surface.hpp>
#include <geometry/Geom3TrimmedCurve.hpp>
#include <geometry/Geom3TrimmedSurface.hpp>
#include <geometry/GeomAPIExtremaCurveCurve3.hpp>
#include <geometry/GeomAPIProjectPointOnCurve2.hpp>
#include <geometry/GeomAPIProjectPointOnCurve3.hpp>
#include <geometry/GeomAPIProjectPointOnSurface.hpp>
#include <geometry/GeometryTool.hpp>
#include <geometry/GlobalProperty.hpp>
#include <healing/ShapeFixTool.hpp>
#include <io/STLTool.hpp>
#include <math/Sphere.hpp>
#include <math/TriangularMesh.hpp>
#include <modeling/CopyShape.hpp>
#include <modeling/MakeBox.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeFace.hpp>
#include <modeling/MakePrism.hpp>
#include <modeling/MakeRevol.hpp>
#include <modeling/MakeShapeTool.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeWire.hpp>
#include <modeling/TransformShape.hpp>
#include <nurbs/NURBSAPIApprox.hpp>
#include <nurbs/NURBSAPIBuildCurve.hpp>
#include <nurbs/NURBSAPICircularSweep.hpp>
#include <nurbs/NURBSAPIConvert.hpp>
#include <nurbs/NURBSAPICurveNetworkSurface.hpp>
#include <nurbs/NURBSAPIExplicitSweep.hpp>
#include <nurbs/NURBSAPIExplode.hpp>
#include <nurbs/NURBSAPIExtend.hpp>
#include <nurbs/NURBSAPIInterpolate.hpp>
#include <nurbs/NURBSAPIJoin.hpp>
#include <nurbs/NURBSAPILinearSweep.hpp>
#include <nurbs/NURBSAPILoft.hpp>
#include <nurbs/NURBSAPIMakeNURBSFromBoundaries.hpp>
#include <nurbs/NURBSAPIMatch.hpp>
#include <nurbs/NURBSAPIModifyEndToPlane.hpp>
#include <nurbs/NURBSAPIOffsetCurveOnSurface.hpp>
#include <nurbs/NURBSAPIProject.hpp>
#include <nurbs/NURBSAPIRebuild.hpp>
#include <nurbs/NURBSAPIReplaceEdge.hpp>
#include <nurbs/NURBSAPISweep.hpp>
#include <nurbs/NURBSAPISweep2.hpp>
#include <nurbs/NURBSAPISweepRotation.hpp>
#include <nurbs/NURBSAPITrim.hpp>
#include <nurbs/NURBSAPIUntrim.hpp>
#include <nurbs/NURBSLinearSweepWithDraftDirectionLength.hpp>
#include <occtio/OCCTTool.hpp>
#include <offset/MakePipe.hpp>
#include <offset/MakePipeShell.hpp>
#include <topology/BRepAdaptorCurve2.hpp>
#include <topology/BRepAdaptorCurve3.hpp>
#include <topology/BRepAdaptorSurface.hpp>
#include <topology/BRepGlobalProperty.hpp>
#include <topology/BRepTool.hpp>
#include <topology/TopoBuilder.hpp>
#include <topology/TopoCompound.hpp>
#include <topology/TopoEdge.hpp>
#include <topology/TopoExplorer.hpp>
#include <topology/TopoExplorerTool.hpp>
#include <topology/TopoFace.hpp>
#include <topology/TopoShape.hpp>
#include <topology/TopoShell.hpp>
#include <topology/TopoTool.hpp>
#include <topology/TopoVertex.hpp>
#include <topology/TopoWire.hpp>
#include <topology/WireExplorer.hpp>
#include <topomesh/BRepMeshIncrementalMesh.hpp>
#include <nurbs/NURBSAPIBlend.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
#include <math/LineT.hpp>
#include <hatch/BRepClassificationTools.hpp>
using namespace AMCAX;
namespace
{
	std::shared_ptr<Geom3BSplineCurve> CurveChooser(const int id, const std::shared_ptr<Geom3BSplineCurve>& curve0, const std::shared_ptr<Geom3BSplineCurve>& curve1, const std::shared_ptr<Geom3BSplineCurve>& curve2)
	{
		std::shared_ptr<Geom3BSplineCurve> result;
		switch (id)
		{
		case 0:
		{
			result = curve0;
			break;
		}
		case 1:
		{
			result = curve1;
			break;
		}
		case 2:
		{
			result = curve2;
			break;
		}
		}
		return result;
	}
}
#include<catch.hpp>
#include<testHelper.h>
#include <filesystem>
#include <fstream>
#include <random>
#include <sstream>
#include <nurbs/NURBSAPIGetGeometry.hpp>
#include <nurbs/NURBSAPIConicalSweep.hpp>
#include <boolean/BoolBRepCut.hpp>
#include <common/CartesianCoordinateSystem.hpp>
#include <common/IndexMap.hpp>
#include <common/QuaternionT.hpp>
#include <geomAlgo/LawBSpline.hpp>
#include <geomAlgo/LawConstant.hpp>
#include <nurbs/NURBSAPISmooth.hpp>
#include <geomAlgo/MakeConic2FromConstraints.hpp>
#include <geometry/Adaptor3CurveOnSurface.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/AdaptorGeom3Surface.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/Geom2Circle.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/Geom2Hyperbola.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom3BSplineCurve.hpp>
#include <geometry/Geom3BSplineSurface.hpp>
#include <geometry/Geom3Circle.hpp>
#include <geometry/Geom3Line.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
#include <geometry/Geom3Plane.hpp>
#include <geometry/Geom3SphericalSurface.hpp>
#include <geometry/Geom3Surface.hpp>
#include <geometry/Geom3TrimmedCurve.hpp>
#include <geometry/Geom3TrimmedSurface.hpp>
#include <geometry/GeomAPIExtremaCurveCurve3.hpp>
#include <geometry/GeomAPIProjectPointOnCurve2.hpp>
#include <geometry/GeomAPIProjectPointOnCurve3.hpp>
#include <geometry/GeomAPIProjectPointOnSurface.hpp>
#include <geometry/GeometryTool.hpp>
#include <geometry/GlobalProperty.hpp>
#include <healing/ShapeFixTool.hpp>
#include <io/STLTool.hpp>
#include <math/Sphere.hpp>
#include <math/TriangularMesh.hpp>
#include <modeling/CopyShape.hpp>
#include <modeling/MakeBox.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeFace.hpp>
#include <modeling/MakePrism.hpp>
#include <modeling/MakeRevol.hpp>
#include <modeling/MakeShapeTool.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeWire.hpp>
#include <modeling/TransformShape.hpp>
#include <nurbs/NURBSAPIApprox.hpp>
#include <nurbs/NURBSAPIBuildCurve.hpp>
#include <nurbs/NURBSAPICircularSweep.hpp>
#include <nurbs/NURBSAPIConvert.hpp>
#include <nurbs/NURBSAPICurveNetworkSurface.hpp>
#include <nurbs/NURBSAPIExplicitSweep.hpp>
#include <nurbs/NURBSAPIExplode.hpp>
#include <nurbs/NURBSAPIExtend.hpp>
#include <nurbs/NURBSAPIInterpolate.hpp>
#include <nurbs/NURBSAPIJoin.hpp>
#include <nurbs/NURBSAPILinearSweep.hpp>
#include <nurbs/NURBSAPILoft.hpp>
#include <nurbs/NURBSAPIMakeNURBSFromBoundaries.hpp>
#include <nurbs/NURBSAPIMatch.hpp>
#include <nurbs/NURBSAPIModifyEndToPlane.hpp>
#include <nurbs/NURBSAPIOffsetCurveOnSurface.hpp>
#include <nurbs/NURBSAPIProject.hpp>
#include <nurbs/NURBSAPIRebuild.hpp>
#include <nurbs/NURBSAPIReplaceEdge.hpp>
#include <nurbs/NURBSAPISweep.hpp>
#include <nurbs/NURBSAPISweep2.hpp>
#include <nurbs/NURBSAPISweepRotation.hpp>
#include <nurbs/NURBSAPITrim.hpp>
#include <nurbs/NURBSAPIUntrim.hpp>
#include <nurbs/NURBSLinearSweepWithDraftDirectionLength.hpp>
#include <occtio/OCCTTool.hpp>
#include <offset/MakePipe.hpp>
#include <offset/MakePipeShell.hpp>
#include <topology/BRepAdaptorCurve2.hpp>
#include <topology/BRepAdaptorCurve3.hpp>
#include <topology/BRepAdaptorSurface.hpp>
#include <topology/BRepGlobalProperty.hpp>
#include <topology/BRepTool.hpp>
#include <topology/TopoBuilder.hpp>
#include <topology/TopoCompound.hpp>
#include <topology/TopoEdge.hpp>
#include <topology/TopoExplorer.hpp>
#include <topology/TopoExplorerTool.hpp>
#include <topology/TopoFace.hpp>
#include <topology/TopoShape.hpp>
#include <topology/TopoShell.hpp>
#include <topology/TopoTool.hpp>
#include <topology/TopoVertex.hpp>
#include <topology/TopoWire.hpp>
#include <topology/WireExplorer.hpp>
#include <topomesh/BRepMeshIncrementalMesh.hpp>
#include <nurbs/NURBSAPIBlend.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
#include <math/LineT.hpp>
#include <hatch/BRepClassificationTools.hpp>
using namespace AMCAX;
namespace
{
	std::shared_ptr<Geom3BSplineCurve> CurveChooser(const int id, const std::shared_ptr<Geom3BSplineCurve>& curve0, const std::shared_ptr<Geom3BSplineCurve>& curve1, const std::shared_ptr<Geom3BSplineCurve>& curve2)
	{
		std::shared_ptr<Geom3BSplineCurve> result;
		switch (id)
		{
		case 0:
		{
			result = curve0;
			break;
		}
		case 1:
		{
			result = curve1;
			break;
		}
		case 2:
		{
			result = curve2;
			break;
		}
		}
		return result;
	}
;
	SECTION("TestSweep2C0AllStraight()")	
		{
			std::string filedir = INPUT_PATH_PREFIX "/TestNURBS/TestSweep2C0AllStraight/";
			std::vector<NURBSCurveSection> profiles;
			std::shared_ptr<Geom3BSplineCurve> profile0 = ReadBRepCurve(filedir + "profile0.brep");
			std::shared_ptr<Geom3BSplineCurve> profile1 = ReadBRepCurve(filedir + "profile1.brep");
			std::shared_ptr<Geom3BSplineCurve> profile2 = ReadBRepCurve(filedir + "profile2.brep");
			for (int i = 0; i <= 2; i++)
			{
				profiles.push_back(NURBSCurveSection(ReadBRepCurve(filedir + "profile" + std::to_string(i) + ".brep")));
			}
			auto spine1 = ReadBRepCurve(filedir + "spine1.brep");
			auto spine2 = ReadBRepCurve(filedir + "spine2.brep");
			spine1->SetPeriodic();
			spine2->SetPeriodic();
			CHECK(OCCTIO::OCCTTool::Write(MakeEdge(spine1), OUTPUT_PATH_PREFIX "TestSweep2C0AllStraight_spine1.brep"));
			CHECK(OCCTIO::OCCTTool::Write(MakeEdge(spine2), OUTPUT_PATH_PREFIX "TestSweep2C0AllStraight_spine2.brep"));
			bool isAutoTwist = true;
			bool isClosedSweep = true;
			std::vector<std::pair<int, double>> parm;
			auto bsp4 = NURBSAPISweep2::SweepTwoRails(profiles, spine1, spine2, 0.5, std::vector<std::pair<int, double>>(), std::vector<std::pair<int, double>>(), isClosedSweep, isAutoTwist);
			for (int i = 0; i < static_cast<int>(bsp4.size()); i++)
			{
				CHECK(OCCTIO::OCCTTool::Write(MakeFace(bsp4[i], 0.0), OUTPUT_PATH_PREFIX "TestSweep2C0AllStraight_face" + std::to_string(i) + ".brep"));
			}
			CHECK(IsCurveOnSurf(1000, 0.3, profile0, bsp4[3], 0.1));
			CHECK(IsCurveOnSurf(1000, 0.1, profile1, bsp4[3], 0.1));
			CHECK(IsCurveOnSurf(1000, 0.1, profile2, bsp4[0], 0.1));
		}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static std::vector<std::shared_ptr<Geom3BSplineSurface>> SweepTwoRails( const std::shared_ptr<Geom3BSplineCurve>& profile, const std::shared_ptr<Geom3BSplineCurve>& spine1, const std::shared_ptr<Geom3BSplineCurve>& spine2),
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeFace.hpp>
#include <nurbs/NURBSAPISweep2.hpp>
#include <nurbs/NURBSAPIConvert.hpp>
#include <topology/TopoTool.hpp>
#include <nurbs/NURBSAPIExplicitSweep.hpp>
#include <modeling/MakeVertex.hpp>
#include<catch.hpp>
#include<testHelper.h>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeFace.hpp>
#include <nurbs/NURBSAPISweep2.hpp>
#include <nurbs/NURBSAPIConvert.hpp>
#include <topology/TopoTool.hpp>
#include <nurbs/NURBSAPIExplicitSweep.hpp>
#include <modeling/MakeVertex.hpp>
;
	SECTION("TestSweep2moreover1()")
	{
		std::string filedir = INPUT_PATH_PREFIX "/TestNURBS/TestSweep2moreover1/";
		auto spine1 = ReadBRepCurve(filedir + "spine1.brep");
		auto spine2 = ReadBRepCurve(filedir + "spine2.brep");
		auto profile = ReadBRepCurve(filedir + "profile1.brep");
		Point3 startPoint = spine1->StartPoint();
		Point3 endPoint = spine2->StartPoint();
		Point3 anchorPoint1(startPoint.X(), startPoint.Y(), startPoint.Z());
		Point3 anchorPoint2(endPoint.X(), endPoint.Y(), endPoint.Z());
		Direction3 dir(1.00, 0.0,0.0);
		CHECK(OCCTIO::OCCTTool::Write(MakeEdge(spine1), OUTPUT_PATH_PREFIX "TestSweep2moreover1_spine1.brep"));
		CHECK(OCCTIO::OCCTTool::Write(MakeEdge(spine2), OUTPUT_PATH_PREFIX "TestSweep2moreover1_spine2.brep"));
		CHECK(OCCTIO::OCCTTool::Write(MakeEdge(profile), OUTPUT_PATH_PREFIX "TestSweep2moreover1_profile.brep"));
		CHECK(OCCTIO::OCCTTool::Write(MakeVertex(anchorPoint1), OUTPUT_PATH_PREFIX "TestSweep2moreover1_anchorPoint1.brep"));
		CHECK(OCCTIO::OCCTTool::Write(MakeVertex(anchorPoint2), OUTPUT_PATH_PREFIX "TestSweep2moreover1_anchorPoint2.brep"));
		auto [status, surface] = NURBSAPIExplicitSweep::SweepWithTwoGuideCurves(profile, spine1, spine2, anchorPoint2, anchorPoint1, spine1, spine1->FirstParameter(), spine1->LastParameter());
		auto surfaces = NURBSAPISweep2::SweepTwoRails(profile, spine1, spine2);
		std::shared_ptr<Geom3BSplineSurface> result = surfaces[0];
		CHECK(OCCTIO::OCCTTool::Write(MakeFace(result, 0.0), OUTPUT_PATH_PREFIX "TestSweep2moreover1_surface1.brep"));
		CHECK(OCCTIO::OCCTTool::Write(MakeFace(surface, 0.0), OUTPUT_PATH_PREFIX "TestSweep2moreover1_surface2.brep"));
		CHECK(IsCurveOnSurf(100, 0.1, profile, surfaces[0], 0.01));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static std::vector<std::shared_ptr<Geom3BSplineSurface>> SweepTwoRails( const std::vector<NURBSCurveSection>& profile, const std::shared_ptr<Geom3BSplineCurve>& spine1, const std::shared_ptr<Geom3BSplineCurve>& spine2, double spine1RefParam, const std::vector<std::pair<int, double>>& spine1CorrParams, const std::vector<std::pair<int, double>>& spine2CorrParams, bool isClosedSweep, bool isAutoTwist),
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeFace.hpp>
#include <nurbs/NURBSAPISweep2.hpp>
#include <nurbs/NURBSAPIConvert.hpp>
#include <topology/TopoTool.hpp>
#include <nurbs/NURBSAPIExplicitSweep.hpp>
#include <modeling/MakeVertex.hpp>
#include<catch.hpp>
#include<testHelper.h>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeFace.hpp>
#include <nurbs/NURBSAPISweep2.hpp>
#include <nurbs/NURBSAPIConvert.hpp>
#include <topology/TopoTool.hpp>
#include <nurbs/NURBSAPIExplicitSweep.hpp>
#include <modeling/MakeVertex.hpp>
;
	SECTION("TestSweep2moreover1()")
	{
		std::string filedir = INPUT_PATH_PREFIX "/TestNURBS/TestSweep2moreover1/";
		auto spine1 = ReadBRepCurve(filedir + "spine1.brep");
		auto spine2 = ReadBRepCurve(filedir + "spine2.brep");
		auto profile = ReadBRepCurve(filedir + "profile1.brep");
		Point3 startPoint = spine1->StartPoint();
		Point3 endPoint = spine2->StartPoint();
		Point3 anchorPoint1(startPoint.X(), startPoint.Y(), startPoint.Z());
		Point3 anchorPoint2(endPoint.X(), endPoint.Y(), endPoint.Z());
		Direction3 dir(1.00, 0.0,0.0);
		CHECK(OCCTIO::OCCTTool::Write(MakeEdge(spine1), OUTPUT_PATH_PREFIX "TestSweep2moreover1_spine1.brep"));
		CHECK(OCCTIO::OCCTTool::Write(MakeEdge(spine2), OUTPUT_PATH_PREFIX "TestSweep2moreover1_spine2.brep"));
		CHECK(OCCTIO::OCCTTool::Write(MakeEdge(profile), OUTPUT_PATH_PREFIX "TestSweep2moreover1_profile.brep"));
		CHECK(OCCTIO::OCCTTool::Write(MakeVertex(anchorPoint1), OUTPUT_PATH_PREFIX "TestSweep2moreover1_anchorPoint1.brep"));
		CHECK(OCCTIO::OCCTTool::Write(MakeVertex(anchorPoint2), OUTPUT_PATH_PREFIX "TestSweep2moreover1_anchorPoint2.brep"));
		auto [status, surface] = NURBSAPIExplicitSweep::SweepWithTwoGuideCurves(profile, spine1, spine2, anchorPoint2, anchorPoint1, spine1, spine1->FirstParameter(), spine1->LastParameter());
		auto surfaces = NURBSAPISweep2::SweepTwoRails(profile, spine1, spine2);
		std::shared_ptr<Geom3BSplineSurface> result = surfaces[0];
		CHECK(OCCTIO::OCCTTool::Write(MakeFace(result, 0.0), OUTPUT_PATH_PREFIX "TestSweep2moreover1_surface1.brep"));
		CHECK(OCCTIO::OCCTTool::Write(MakeFace(surface, 0.0), OUTPUT_PATH_PREFIX "TestSweep2moreover1_surface2.brep"));
		CHECK(IsCurveOnSurf(100, 0.1, profile, surfaces[0], 0.01));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static std::shared_ptr<Geom3BSplineSurface> RotationSweep( const std::shared_ptr<Geom3BSplineCurve>& profile, const std::shared_ptr<Geom3BSplineCurve>& spine, const Axis3& axis),
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeFace.hpp>
#include <nurbs/NURBSAPIConvert.hpp>
#include <topology/TopoTool.hpp>
#include <nurbs/NURBSAPIExplicitSweep.hpp>
#include <modeling/MakeVertex.hpp>
#include <nurbs/NURBSAPISweepRotation.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
#include <topology/TopoExplorerTool.hpp>
using namespace AMCAX;
namespace
{
	std::shared_ptr<Geom3BSplineCurve> CurveChooser(const int id, const std::shared_ptr<Geom3BSplineCurve>& curve0, const std::shared_ptr<Geom3BSplineCurve>& curve1, const std::shared_ptr<Geom3BSplineCurve>& curve2)
	{
		std::shared_ptr<Geom3BSplineCurve> result;
		switch (id)
		{
		case 0:
		{
			result = curve0;
			break;
		}
		case 1:
		{
			result = curve1;
			break;
		}
		case 2:
		{
			result = curve2;
			break;
		}
		}
		return result;
	}
} 
#include<catch.hpp>
#include<testHelper.h>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeFace.hpp>
#include <nurbs/NURBSAPIConvert.hpp>
#include <topology/TopoTool.hpp>
#include <nurbs/NURBSAPIExplicitSweep.hpp>
#include <modeling/MakeVertex.hpp>
#include <nurbs/NURBSAPISweepRotation.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
#include <topology/TopoExplorerTool.hpp>
using namespace AMCAX;
namespace
{
	std::shared_ptr<Geom3BSplineCurve> CurveChooser(const int id, const std::shared_ptr<Geom3BSplineCurve>& curve0, const std::shared_ptr<Geom3BSplineCurve>& curve1, const std::shared_ptr<Geom3BSplineCurve>& curve2)
	{
		std::shared_ptr<Geom3BSplineCurve> result;
		switch (id)
		{
		case 0:
		{
			result = curve0;
			break;
		}
		case 1:
		{
			result = curve1;
			break;
		}
		case 2:
		{
			result = curve2;
			break;
		}
		}
		return result;
	}
;
	SECTION("TestRotationSweep()")	
	SECTION("TestRotationSweepPeriodic()")
	{
		std::string filedir = INPUT_PATH_PREFIX "/TestNURBS/TestRotationSweepPeriodic/";
		std::shared_ptr<Geom3BSplineCurve> spine = ReadBRepCurve(filedir + "spine.brep");
		std::shared_ptr<Geom3BSplineCurve> profile = ReadBRepCurve(filedir + "profile.brep");
		CHECK(OCCTIO::OCCTTool::Write(MakeEdge(spine), OUTPUT_PATH_PREFIX "TestRotationSweepPeriodic_spine.brep"));
		CHECK(OCCTIO::OCCTTool::Write(MakeEdge(profile), OUTPUT_PATH_PREFIX "TestRotationSweepPeriodic_profile.brep"));
		Point3 p(21.1, 22.8, 0.0);
		Vector3 vec(0.0, 0.0, 5.0);
		Axis3 axis(p, Direction3(vec));
		Line3 line(axis);
		auto surface = NURBSAPISweepRotation::RotationSweep(profile, spine, axis);
		CHECK(OCCTIO::OCCTTool::Write(MakeFace(surface, 0.0), OUTPUT_PATH_PREFIX "TestRotationSweepPeriodic_result.brep"));
		AMCAX::BRepExtremaDistShapeShape len1(MakeFace(surface, 0.0), MakeEdge(line));
		AMCAX::BRepExtremaDistShapeShape len2(MakeFace(surface, 0.0), MakeEdge(spine));
		CHECK(len1.Value() < 1.0);
		CHECK(len2.Value() < 1.0);
		CHECK(IsCurveOnSurf(1000, 0.1, profile, surface, 0.1));
		CHECK(IsCurveOnSurf(1000, 0.1, spine, surface, 0.1));
		spine->IncreaseDegree(11);
		profile->IncreaseDegree(11);
		auto surface1 = NURBSAPISweepRotation::RotationSweep(profile, spine, axis);
		CHECK(OCCTIO::OCCTTool::Write(MakeFace(surface, 0.0), OUTPUT_PATH_PREFIX "TestRotationSweepPeriodic_degree11result.brep"));
		CHECK(surface1->UDegree() == 11);
		CHECK(surface1->VDegree() == 11);
		double bsp3s = GetSurfaceProperties(MakeFace(surface1, 0.0), g, true, true);
		double bsp4s = GetSurfaceProperties(MakeFace(surface, 0.0), g, true, true);
		CHECK(bsp3s == Approx(bsp4s).margin(0.1));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static std::shared_ptr<Geom3BSplineSurface> RotationSweep( const std::shared_ptr<Geom3BSplineCurve>& profile, const std::shared_ptr<Geom3BSplineCurve>& spine, const Axis3& axis),
 "output":
#include<catch.hpp>
#include<testHelper.h>
#include <filesystem>
#include <fstream>
#include <random>
#include <sstream>
#include <nurbs/NURBSAPIGetGeometry.hpp>
#include <nurbs/NURBSAPIConicalSweep.hpp>
#include <boolean/BoolBRepCut.hpp>
#include <common/CartesianCoordinateSystem.hpp>
#include <common/IndexMap.hpp>
#include <common/QuaternionT.hpp>
#include <geomAlgo/LawBSpline.hpp>
#include <geomAlgo/LawConstant.hpp>
#include <nurbs/NURBSAPISmooth.hpp>
#include <geomAlgo/MakeConic2FromConstraints.hpp>
#include <geometry/Adaptor3CurveOnSurface.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/AdaptorGeom3Surface.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/Geom2Circle.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/Geom2Hyperbola.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom3BSplineCurve.hpp>
#include <geometry/Geom3BSplineSurface.hpp>
#include <geometry/Geom3Circle.hpp>
#include <geometry/Geom3Line.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
#include <geometry/Geom3Plane.hpp>
#include <geometry/Geom3SphericalSurface.hpp>
#include <geometry/Geom3Surface.hpp>
#include <geometry/Geom3TrimmedCurve.hpp>
#include <geometry/Geom3TrimmedSurface.hpp>
#include <geometry/GeomAPIExtremaCurveCurve3.hpp>
#include <geometry/GeomAPIProjectPointOnCurve2.hpp>
#include <geometry/GeomAPIProjectPointOnCurve3.hpp>
#include <geometry/GeomAPIProjectPointOnSurface.hpp>
#include <geometry/GeometryTool.hpp>
#include <geometry/GlobalProperty.hpp>
#include <healing/ShapeFixTool.hpp>
#include <io/STLTool.hpp>
#include <math/Sphere.hpp>
#include <math/TriangularMesh.hpp>
#include <modeling/CopyShape.hpp>
#include <modeling/MakeBox.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeFace.hpp>
#include <modeling/MakePrism.hpp>
#include <modeling/MakeRevol.hpp>
#include <modeling/MakeShapeTool.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeWire.hpp>
#include <modeling/TransformShape.hpp>
#include <nurbs/NURBSAPIApprox.hpp>
#include <nurbs/NURBSAPIBuildCurve.hpp>
#include <nurbs/NURBSAPICircularSweep.hpp>
#include <nurbs/NURBSAPIConvert.hpp>
#include <nurbs/NURBSAPICurveNetworkSurface.hpp>
#include <nurbs/NURBSAPIExplicitSweep.hpp>
#include <nurbs/NURBSAPIExplode.hpp>
#include <nurbs/NURBSAPIExtend.hpp>
#include <nurbs/NURBSAPIInterpolate.hpp>
#include <nurbs/NURBSAPIJoin.hpp>
#include <nurbs/NURBSAPILinearSweep.hpp>
#include <nurbs/NURBSAPILoft.hpp>
#include <nurbs/NURBSAPIMakeNURBSFromBoundaries.hpp>
#include <nurbs/NURBSAPIMatch.hpp>
#include <nurbs/NURBSAPIModifyEndToPlane.hpp>
#include <nurbs/NURBSAPIOffsetCurveOnSurface.hpp>
#include <nurbs/NURBSAPIProject.hpp>
#include <nurbs/NURBSAPIRebuild.hpp>
#include <nurbs/NURBSAPIReplaceEdge.hpp>
#include <nurbs/NURBSAPISweep.hpp>
#include <nurbs/NURBSAPISweep2.hpp>
#include <nurbs/NURBSAPISweepRotation.hpp>
#include <nurbs/NURBSAPITrim.hpp>
#include <nurbs/NURBSAPIUntrim.hpp>
#include <nurbs/NURBSLinearSweepWithDraftDirectionLength.hpp>
#include <occtio/OCCTTool.hpp>
#include <offset/MakePipe.hpp>
#include <offset/MakePipeShell.hpp>
#include <topology/BRepAdaptorCurve2.hpp>
#include <topology/BRepAdaptorCurve3.hpp>
#include <topology/BRepAdaptorSurface.hpp>
#include <topology/BRepGlobalProperty.hpp>
#include <topology/BRepTool.hpp>
#include <topology/TopoBuilder.hpp>
#include <topology/TopoCompound.hpp>
#include <topology/TopoEdge.hpp>
#include <topology/TopoExplorer.hpp>
#include <topology/TopoExplorerTool.hpp>
#include <topology/TopoFace.hpp>
#include <topology/TopoShape.hpp>
#include <topology/TopoShell.hpp>
#include <topology/TopoTool.hpp>
#include <topology/TopoVertex.hpp>
#include <topology/TopoWire.hpp>
#include <topology/WireExplorer.hpp>
#include <topomesh/BRepMeshIncrementalMesh.hpp>
#include <nurbs/NURBSAPIBlend.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
#include <math/LineT.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/GeomAPIIntSurfaceSurface.hpp>
using namespace AMCAX;
#include<catch.hpp>
#include<testHelper.h>
#include <filesystem>
#include <fstream>
#include <random>
#include <sstream>
#include <nurbs/NURBSAPIGetGeometry.hpp>
#include <nurbs/NURBSAPIConicalSweep.hpp>
#include <boolean/BoolBRepCut.hpp>
#include <common/CartesianCoordinateSystem.hpp>
#include <common/IndexMap.hpp>
#include <common/QuaternionT.hpp>
#include <geomAlgo/LawBSpline.hpp>
#include <geomAlgo/LawConstant.hpp>
#include <nurbs/NURBSAPISmooth.hpp>
#include <geomAlgo/MakeConic2FromConstraints.hpp>
#include <geometry/Adaptor3CurveOnSurface.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/AdaptorGeom3Surface.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/Geom2Circle.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/Geom2Hyperbola.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom3BSplineCurve.hpp>
#include <geometry/Geom3BSplineSurface.hpp>
#include <geometry/Geom3Circle.hpp>
#include <geometry/Geom3Line.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
#include <geometry/Geom3Plane.hpp>
#include <geometry/Geom3SphericalSurface.hpp>
#include <geometry/Geom3Surface.hpp>
#include <geometry/Geom3TrimmedCurve.hpp>
#include <geometry/Geom3TrimmedSurface.hpp>
#include <geometry/GeomAPIExtremaCurveCurve3.hpp>
#include <geometry/GeomAPIProjectPointOnCurve2.hpp>
#include <geometry/GeomAPIProjectPointOnCurve3.hpp>
#include <geometry/GeomAPIProjectPointOnSurface.hpp>
#include <geometry/GeometryTool.hpp>
#include <geometry/GlobalProperty.hpp>
#include <healing/ShapeFixTool.hpp>
#include <io/STLTool.hpp>
#include <math/Sphere.hpp>
#include <math/TriangularMesh.hpp>
#include <modeling/CopyShape.hpp>
#include <modeling/MakeBox.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeFace.hpp>
#include <modeling/MakePrism.hpp>
#include <modeling/MakeRevol.hpp>
#include <modeling/MakeShapeTool.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeWire.hpp>
#include <modeling/TransformShape.hpp>
#include <nurbs/NURBSAPIApprox.hpp>
#include <nurbs/NURBSAPIBuildCurve.hpp>
#include <nurbs/NURBSAPICircularSweep.hpp>
#include <nurbs/NURBSAPIConvert.hpp>
#include <nurbs/NURBSAPICurveNetworkSurface.hpp>
#include <nurbs/NURBSAPIExplicitSweep.hpp>
#include <nurbs/NURBSAPIExplode.hpp>
#include <nurbs/NURBSAPIExtend.hpp>
#include <nurbs/NURBSAPIInterpolate.hpp>
#include <nurbs/NURBSAPIJoin.hpp>
#include <nurbs/NURBSAPILinearSweep.hpp>
#include <nurbs/NURBSAPILoft.hpp>
#include <nurbs/NURBSAPIMakeNURBSFromBoundaries.hpp>
#include <nurbs/NURBSAPIMatch.hpp>
#include <nurbs/NURBSAPIModifyEndToPlane.hpp>
#include <nurbs/NURBSAPIOffsetCurveOnSurface.hpp>
#include <nurbs/NURBSAPIProject.hpp>
#include <nurbs/NURBSAPIRebuild.hpp>
#include <nurbs/NURBSAPIReplaceEdge.hpp>
#include <nurbs/NURBSAPISweep.hpp>
#include <nurbs/NURBSAPISweep2.hpp>
#include <nurbs/NURBSAPISweepRotation.hpp>
#include <nurbs/NURBSAPITrim.hpp>
#include <nurbs/NURBSAPIUntrim.hpp>
#include <nurbs/NURBSLinearSweepWithDraftDirectionLength.hpp>
#include <occtio/OCCTTool.hpp>
#include <offset/MakePipe.hpp>
#include <offset/MakePipeShell.hpp>
#include <topology/BRepAdaptorCurve2.hpp>
#include <topology/BRepAdaptorCurve3.hpp>
#include <topology/BRepAdaptorSurface.hpp>
#include <topology/BRepGlobalProperty.hpp>
#include <topology/BRepTool.hpp>
#include <topology/TopoBuilder.hpp>
#include <topology/TopoCompound.hpp>
#include <topology/TopoEdge.hpp>
#include <topology/TopoExplorer.hpp>
#include <topology/TopoExplorerTool.hpp>
#include <topology/TopoFace.hpp>
#include <topology/TopoShape.hpp>
#include <topology/TopoShell.hpp>
#include <topology/TopoTool.hpp>
#include <topology/TopoVertex.hpp>
#include <topology/TopoWire.hpp>
#include <topology/WireExplorer.hpp>
#include <topomesh/BRepMeshIncrementalMesh.hpp>
#include <nurbs/NURBSAPIBlend.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
#include <math/LineT.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/GeomAPIIntSurfaceSurface.hpp>
using namespace AMCAX;;
	SECTION("TestRotationSweepMore2()")
	{
		std::string filedir = INPUT_PATH_PREFIX "/TestNURBS/TestRotationSweepMore2/";
		std::shared_ptr<Geom3BSplineCurve> spine = ReadBRepCurve(filedir + "spine.brep");
		std::shared_ptr<Geom3BSplineCurve> profile = ReadBRepCurve(filedir + "profile.brep");
		CHECK(OCCTIO::OCCTTool::Write(MakeEdge(spine), OUTPUT_PATH_PREFIX "TestRotationSweepMore_spine2.brep"));
		CHECK(OCCTIO::OCCTTool::Write(MakeEdge(profile), OUTPUT_PATH_PREFIX "TestRotationSweepMore_profile2.brep"));
		Point3 p(0.0, 0.0, 0.0);
		Vector3 vec(0.0, 0.0, 5.0);
		Axis3 axis(p, Direction3(vec));
		auto surface1 = NURBSAPISweepRotation::RotationSweep( profile, spine, axis);
		CHECK(OCCTIO::OCCTTool::Write(MakeFace(surface1, 0.0), OUTPUT_PATH_PREFIX "TestRotationSweepMore_result2.brep"));
		CHECK(IsCurveOnSurf(100, 0.1, profile, surface1, 0.01));
		profile->IncreaseDegree(11);
		CHECK(OCCTIO::OCCTTool::Write(MakeEdge(profile), OUTPUT_PATH_PREFIX "TestRotationSweepMore_degree11profile.brep"));
		auto surface11 = NURBSAPISweepRotation::RotationSweep( profile, spine, axis);
		CHECK(OCCTIO::OCCTTool::Write(MakeFace(surface11, 0.0), OUTPUT_PATH_PREFIX "TestRotationSweepMore_degree11result2.brep"));
		double bsp3s = GetSurfaceProperties(MakeFace(surface1, 0.0), g, true, true);
		double bsp4s = GetSurfaceProperties(MakeFace(surface11, 0.0), g, true, true);
		CHECK(bsp3s == Approx(bsp4s).margin(0.02));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static TopoShape Trim(const std::list<TopoShape>& cutter, const TopoShape& srcShape, const std::vector<double>& param, bool isViewPortIntersection, const Coord3& eyeOrDir)	 @return The trimmed shape
	 @param eyeOrDir if isViewPortIntersection, it is the position of the camera (or eye), else it is the direction of parallel projection
	 @param isViewPortIntersection Point projection or parallel projection
	 If the srcShape is a TopoEdge, param.size = 1.  If the srcShape is a TopoFace, param.size = 2
	 @param param The parameter to determin which part of the srcShape is deleted.
	 @param srcShape The source shape which can be a TopoEdge or a TopoFace
	 @param cutter The cutters consist of TopoEdges and TopoFaces
	 @brief Trim a shape with cutters
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <nurbs/NURBSAPITrim.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeEdge.hpp>
#include <topology/TopoTool.hpp>
#include <geometry/Geom3TrimmedCurve.hpp>
#include <topology/BRepAdaptorCurve3.hpp>
#include <geometry/GeomAPIProjectPointOnSurface.hpp>
#include <nurbs/NURBSAPIUntrim.hpp>
#include <topology/TopoExplorerTool.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <topology/BRepAdaptorCurve3.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
pair<Point3,Point3> NurbsReadAdaptorCurve(const TopoShape& shape)
{
	pair<Point3, Point3> res;
	TopoExplorer ex(shape, ShapeType::Edge);
	TopoEdge e = static_cast<const TopoEdge&>(ex.Value());
	BRepAdaptorCurve3 brep(e);
	const AdaptorGeom3Curve curve = brep.Curve();
	double u1 = curve.FirstParameter();
	double u2 = curve.LastParameter();
	res.first = curve.Value(u1);
	res.second = curve.Value(u2);
	return res;
}
shared_ptr< Geom3Curve > NurbsReadTempCurve(const TopoShape& shape)
{
	pair<Point3, Point3> res;
	TopoExplorer ex(shape, ShapeType::Edge);
	TopoEdge e = static_cast<const TopoEdge&>(ex.Value());
	double f = 0.0;
	double l = 0.0;
	shared_ptr< Geom3Curve > curve = TopoTool::Curve(e, f, l);
	return curve;
}
double NurbsSampleAdaptorCurve(int num, double tol, const TopoShape& shape1, const TopoShape& shape2)
{
	const int nsample = num;
	TopoExplorer ex1(shape1, ShapeType::Edge);
	TopoEdge e1 = static_cast<const TopoEdge&>(ex1.Value());
	BRepAdaptorCurve3 brep1(e1);
	const AdaptorGeom3Curve curve1 = brep1.Curve();
	TopoExplorer ex2(shape2, ShapeType::Edge);
	TopoEdge e2 = static_cast<const TopoEdge&>(ex2.Value());
	double fp1 = curve1.FirstParameter();
	double lp1 = curve1.LastParameter();
	double delta1 = abs((lp1 - fp1) / nsample);
	Point3 p;
	int n = 0;
	for (int i = 0; i < nsample; i++)
	{
		double t1 = fp1 + i * delta1;
		curve1.D0(t1, p);
		BRepExtremaDistShapeShape shape(MakeVertex(p), e2);
		double dist = shape.Value();
		if (dist <= tol)
		{
			n++;
		}
	}
	double res = 1.0 * (num - n) / num;
	return res;
}
#include<catch.hpp>
#include<testHelper.h>
#include <nurbs/NURBSAPITrim.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeEdge.hpp>
#include <topology/TopoTool.hpp>
#include <geometry/Geom3TrimmedCurve.hpp>
#include <topology/BRepAdaptorCurve3.hpp>
#include <geometry/GeomAPIProjectPointOnSurface.hpp>
#include <nurbs/NURBSAPIUntrim.hpp>
#include <topology/TopoExplorerTool.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <topology/BRepAdaptorCurve3.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
pair<Point3,Point3> NurbsReadAdaptorCurve(const TopoShape& shape)
{
	pair<Point3, Point3> res;
	TopoExplorer ex(shape, ShapeType::Edge);
	TopoEdge e = static_cast<const TopoEdge&>(ex.Value());
	BRepAdaptorCurve3 brep(e);
	const AdaptorGeom3Curve curve = brep.Curve();
	double u1 = curve.FirstParameter();
	double u2 = curve.LastParameter();
	res.first = curve.Value(u1);
	res.second = curve.Value(u2);
	return res;
}
shared_ptr< Geom3Curve > NurbsReadTempCurve(const TopoShape& shape)
{
	pair<Point3, Point3> res;
	TopoExplorer ex(shape, ShapeType::Edge);
	TopoEdge e = static_cast<const TopoEdge&>(ex.Value());
	double f = 0.0;
	double l = 0.0;
	shared_ptr< Geom3Curve > curve = TopoTool::Curve(e, f, l);
	return curve;
}
double NurbsSampleAdaptorCurve(int num, double tol, const TopoShape& shape1, const TopoShape& shape2)
{
	const int nsample = num;
	TopoExplorer ex1(shape1, ShapeType::Edge);
	TopoEdge e1 = static_cast<const TopoEdge&>(ex1.Value());
	BRepAdaptorCurve3 brep1(e1);
	const AdaptorGeom3Curve curve1 = brep1.Curve();
	TopoExplorer ex2(shape2, ShapeType::Edge);
	TopoEdge e2 = static_cast<const TopoEdge&>(ex2.Value());
	double fp1 = curve1.FirstParameter();
	double lp1 = curve1.LastParameter();
	double delta1 = abs((lp1 - fp1) / nsample);
	Point3 p;
	int n = 0;
	for (int i = 0; i < nsample; i++)
	{
		double t1 = fp1 + i * delta1;
		curve1.D0(t1, p);
		BRepExtremaDistShapeShape shape(MakeVertex(p), e2);
		double dist = shape.Value();
		if (dist <= tol)
		{
			n++;
		}
	}
	double res = 1.0 * (num - n) / num;
	return res;
;
	SECTION("TestTrim")
	{
		OUTPUT_DIRECTORY(nurbs, Trim/TrimCurve);
		std::string filedir = INPUT_PATH_PREFIX"./TestNURBS/TestTrim/";
		TopoShape cutterEdge = ReadBRepEdge(filedir + "cutterEdge.brep");
		TopoShape srcEdge = ReadBRepEdge(filedir + "srcEdge.brep");
		TopoShape cutterFace = ReadBRepFace(filedir + "cutterFace.brep");
		TopoShape srcFace = ReadBRepFace(filedir + "srcFace.brep");
		bool isCutterEdge = true;
		bool isSrcEdge = false;
		bool isEye = true;
		TopoShape srcShape = isSrcEdge ? srcEdge : srcFace;
		std::list<TopoShape> cutterShape;
		if (isCutterEdge)
		{
			cutterShape.push_back(cutterEdge);
		}
		else
		{
			cutterShape.push_back(cutterFace);
		}
		Coord3 eyeOrDir(1.0, -1.0, 0.0);
		std::vector<double> param;
		param.push_back(0.1);
		param.push_back(0.1);
		auto result = NURBSAPITrim::Trim(cutterShape, srcShape, param, isEye, eyeOrDir);
		TopoShape temp = ReadBRepFace(filedir + "resultEdgeFaceEye.brep");
		GlobalProperty props1, props2;
		double s1 = GetSurfaceProperties(result, props1, false, true);
		double s2 = GetSurfaceProperties(temp, props2, false, true);
		CHECK(s1 == Approx(s2).margin(1e-7));
		int num1 = GetTopoCount(result, ShapeType::Edge);
		int num2 = GetTopoCount(srcShape, ShapeType::Edge);
		CHECK(num1 == 5);
		CHECK(num2 == 4);
		IndexSet<TopoShape> solidEdges1, solidEdges2;
		TopoExplorerTool::MapShapes(result, ShapeType::Edge, solidEdges1);
		TopoExplorerTool::MapShapes(temp, ShapeType::Edge, solidEdges2);
		pair<Point3, Point3> pa1 = NurbsReadCurve(solidEdges1[0]);
		pair<Point3, Point3> pa2 = NurbsReadCurve(solidEdges2[0]);
		Point3 sp1 = pa1.first;
		Point3 sp2 = pa2.first;
		Point3 ep1 = pa1.second;
		Point3 ep2 = pa2.second;
		CHECK(sp1.IsEqual(sp2, 1e-7) == true);
		CHECK(ep1.IsEqual(ep2, 1e-7) == true);
		shared_ptr< Geom3Curve > cur1 = NurbsReadTempCurve(solidEdges1[0]);
		shared_ptr< Geom3Curve > cur2 = NurbsReadTempCurve(solidEdges2[0]);
		double res = NurbsSampleCurve(num, tol, cur1, cur2);
		CHECK(res <= ratio);
		OCCTIO::OCCTTool::Write(srcShape, outdir + "src.brep");
		OCCTIO::OCCTTool::Write(cutterEdge, outdir + "cutterEdge.brep");
		OCCTIO::OCCTTool::Write(solidEdges1[0], outdir + "solidEdges1[0].brep");
		OCCTIO::OCCTTool::Write(solidEdges2[0], outdir + "solidEdges2[0].brep");
		OCCTIO::OCCTTool::Write(MakeEdge(cur1), outdir + "cur1.brep");
		OCCTIO::OCCTTool::Write(MakeEdge(cur2), outdir + "cur2.brep");
		OCCTIO::OCCTTool::Write(result, outdir + "result.brep");
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static TopoShape Untrim(const TopoEdge& edge, const TopoFace& face)	 @return New face
	 @param face Face to Untrim
	 @param edge Edge to untrim
			5. replace the old wire with the new wire
			4. make new wire and judge orientation by the same edge of the two wires\n
			3. build new edges\n
			2. decide which part of the edges is remained\n
			1. judge whether the edges of the wire is on oriBound;\n
	 The algorithm of making the untrim face in usual cases is:\n
	 \n
			Since the untrim edge is on inner wire, just remove the inner wire.\n
	 else \n
			Perform as the one wire case and add the other wires to the result.\n
	 else if the untrim edge is on outer wire\n
				Make the untrim face by the algorithm illustrated below. (usual cases)\n
			else\n
				Make two untrim faces and judge which is required by select a point on untrim edge.\n
			else if the number of oriBound edges is 0:\n
				return the face built by the whole surface.\n
			else if the number of non-oriBound edges is 0:\n
				return the face built by the whole surface.\n
			if num of intersection points is less than 2 or the untrimm edge is the only edge of the wire: \n
	 If face has one wire:\n
			3. the number of oriBound edges and non-oriBound edges.\n
			2. the number of intersection points with boundaries of wire containing untrim edge;\n
			1. number of wires;\n
	 The cases are sort of complicated. It can be classified by:\n
	 @brief Restore the trimmed face (by n edges) to its untrimmed state (trimmed by n-1 edges)\n
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <nurbs/NURBSAPIUntrim.hpp>
#include <geometry/Geom3BSplineCurve.hpp>
#include <topology/TopoFace.hpp>
#include <topology/TopoEdge.hpp>
#include <modeling/MakeWire.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakePrism.hpp>
#include <geometry/Geom3Plane.hpp>
#include <offset/MakePipeShell.hpp>
#include <modeling/MakeFace.hpp>
#include <boolean/BoolBRepCut.hpp>
#include <io/STLTool.hpp>
#include <topology/TopoTool.hpp>
#include <geometry/GeomAPIProjectPointOnCurve3.hpp>
#include <geometry/Geom3TrimmedSurface.hpp>
#include <common/CartesianCoordinateSystem.hpp>
#include <geometry/Geom3BSplineSurface.hpp>
#include <topology/TopoVertex.hpp>
#include <geometry/GeomAPIProjectPointOnSurface.hpp>
#include <topology/BRepAdaptorCurve3.hpp>
#include <nurbs/NURBSAPIReplaceEdge.hpp>
#include <nurbs/NURBSAPITrim.hpp>
#include <topology/TopoExplorerTool.hpp>
#include <modeling/MakeVertex.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
using namespace std;
bool MakeDir(const std::string& dir)
{
	if (!std::filesystem::exists(dir))
	{
		std::filesystem::create_directories(dir.c_str());
		return true;
	}
	else
	{
		return false;
	}
}
TEST_CASE("bug1: TestUntrim2CornerCase ", "[nurbs][Untrim][fixbug]")
{
	OUTPUT_DIRECTORY(nurbs, Untrim/bug552);
	shared_ptr<Geom3Plane> gp = make_shared<Geom3Plane>(CartesianCoordinateSystem::XOY());
	shared_ptr<Geom3TrimmedSurface> tgp = make_shared<Geom3TrimmedSurface>(gp, -1.0, 1.0, -1.0, 1.0);
	TopoFace inputBasicFace = MakeFace(tgp, 1e-8).Face();
	TopoShape cutCylidner1 = MakePrism(MakeEdge(Circle3(Frame3(Point3(-1.0, -1.0, -1.0), Direction3(0.0, 0.0, 1.0), Direction3(1.0, 0.0, 0.0)), 2.0)), Vector3(0.0, 0.0, 2.0));
	TopoShape cutCylidner2 = MakePrism(MakeEdge(Circle3(Frame3(Point3(1.0, 1.0, -1.0), Direction3(0.0, 0.0, 1.0), Direction3(1.0, 0.0, 0.0)), 2.0)), Vector3(0.0, 0.0, 2.0));
	TopoShape cutCylidner3 = MakePrism(MakeEdge(Circle3(Frame3(Point3(-0.2, -0.2, -1.0), Direction3(0.0, 0.0, 1.0), Direction3(1.0, 0.0, 0.0)), 0.1)), Vector3(0.0, 0.0, 2.0));
	TopoShape cc = CutAndLeaveLargePart(inputBasicFace, cutCylidner1);
	TopoShape ccc = CutAndLeaveLargePart(cc, cutCylidner2);
	TopoShape cccc = CutAndLeaveLargePart(ccc, cutCylidner3);
	TopoFace inputFace = static_cast<const TopoFace&>(cccc);
	Point3 refp3(-0.2, -0.2, 0.0);
	TopoEdge theEdge;
	double dist = 1e100;
	for (TopoExplorer exe(inputFace, ShapeType::Edge); exe.More(); exe.Next())
	{
		TopoEdge cr = static_cast<const TopoEdge&>(exe.Current());
		BRepExtremaDistShapeShape shape(MakeVertex(refp3), cr);
		double crdist = shape.Value();
	    if (dist > crdist)
			{
				dist = crdist;
				theEdge = cr;
			}
		}
	TopoShape result3 = NURBSAPIUntrim::Untrim(theEdge, static_cast<const TopoFace&>(inputFace));
	TopoShape f3 = CutAndLeaveLargePart(inputBasicFace, cutCylidner1);
	TopoShape cccc1 = CutAndLeaveLargePart(f3, cutCylidner2);
	GlobalProperty props1, props2, props3, props4, props5, props6, props7;
	double res3 = GetSurfaceProperties(result3, props3, true, false);
	double res33 = GetSurfaceProperties(cccc1, props7, true, false);
	CHECK(GetTopoCount(result3, ShapeType::Edge) == 2);
	CHECK(res3 == Approx(res33));
	OCCTIO::OCCTTool::Write(MakeVertex(refp3), outdir + "refp3.brep");
	OCCTIO::OCCTTool::Write(theEdge, outdir + "theEdge.brep");
	OCCTIO::OCCTTool::Write(inputFace, outdir + "trimFace.brep");
	OCCTIO::OCCTTool::Write(result3, outdir + "untrimResult.brep");
	OCCTIO::OCCTTool::Write(cccc1, outdir + "src.brep");
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API void PerformWithEdgeAndLength(const TopoEdge& edge, double length)	 @param length The extend Length, > 0 means extending face outward
	 @param edge The boundary edge belonging to the face
	 @brief Extend the face using one edge by length
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <topology/TopoExplorerTool.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeWire.hpp>
#include <modeling/MakeFace.hpp>
#include <offset/MakeFaceExtension.hpp>
#include <topomesh/BRepMeshIncrementalMesh.hpp>
#include <io/OBJTool.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <topology/TopoTool.hpp>
#include <topology/TopoVertex.hpp>
using namespace AMCAX;
#include<catch.hpp>
#include<testHelper.h>
#include <topology/TopoExplorerTool.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeWire.hpp>
#include <modeling/MakeFace.hpp>
#include <offset/MakeFaceExtension.hpp>
#include <topomesh/BRepMeshIncrementalMesh.hpp>
#include <io/OBJTool.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <topology/TopoTool.hpp>
#include <topology/TopoVertex.hpp>
using namespace AMCAX;
;
	SECTION("check length = 0 isDone should always false") {
		for (size_t i = 0; i < fedge.size(); i++)
		{
			TopoEdge edge = static_cast<const TopoEdge&>(fedge[i]);
			mkExt.PerformWithEdgeAndLength(edge, 0.0);
			CHECK(mkExt.IsDone() == false);
			}
		}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API void PerformBySimple(const TopoShape& s, double offsetValue)	 @param offsetValue The value of offset
	 @param s The input face or shell
	 @details The input must be a non-closed single face or a shell which only contain tangent faces.
	 @brief Construct an offset shape using the simple algorithm without intersections computation
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <offset/MakeOffsetShape.hpp>
#include <io/ShapeTool.hpp>
#include <topomesh/BRepMeshIncrementalMesh.hpp>
#include <io/OBJTool.hpp>
#include <geometry/Geom3Curve.hpp>
#include <topology/TopoTool.hpp>
using namespace AMCAX;
TEST_CASE("bug1: MakeOffset::PerformBySimple ", "[offset][MakeOffsetShape][P1]") {
	TopoShape shape;
	ShapeTool::Read(shape, INPUT_PATH_PREFIX"shell.txt");
	bool bOCCToolWrite = OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX"testResultTemp.brep");
	CHECK(bOCCToolWrite == true);
	BRepMeshIncrementalMesh meshI(shape, 0.001, true);
	bool bWriteShape = OBJTool::WriteShape(shape, OUTPUT_PATH_PREFIX"testResultTemp.obj");
	CHECK(bWriteShape);
	MakeOffsetShape offsetMaker;
	offsetMaker.PerformBySimple(shape, 4.0);
	if (!offsetMaker.IsDone())
	{
		CHECK(offsetMaker.IsDone() == true);
		std::cout << "make Offset sample error" << std::endl;
	}
	else
	{
		std::cout << "make Offset sample ok " << std::endl;
		TopoShape result = offsetMaker.Shape();
		OCCTIO::OCCTTool::Write(result, OUTPUT_PATH_PREFIX"testResult.brep");
		BRepMeshIncrementalMesh meshR(result, 0.00001, true);
		OBJTool::WriteShape(result, OUTPUT_PATH_PREFIX"testResult.obj");
		int CheckContinuity = 0;
		int notCheckContinuity = 0;
		double cf, cl;
		for (TopoExplorer ex(result, ShapeType::Edge); ex.More(); ex.Next())
		{
			auto &edge = TopoCast::Edge(ex.Current());
			std::shared_ptr<Geom3Curve> c3d = TopoTool::Curve(edge, cf, cl);
			if (int(c3d->Continuity()) > 0) {
				CheckContinuity = CheckContinuity + 1;
			}
			else
			{
				notCheckContinuity = notCheckContinuity + 1;
			}
		}
		CHECK(CheckContinuity == 15);
		CHECK(notCheckContinuity == 1);
	}
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API explicit MakePipeShell(const TopoWire& spine)	 @param spine The spine wire
	 @brief Construct from a spine wire. The default sweep method is corrected frenet.
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <modeling/MakeShape.hpp>
#include <io/ShapeTool.hpp>
#include <topology/TopoWire.hpp>
#include <offset/MakePipeShell.hpp>
#include <topomesh/BRepMeshIncrementalMesh.hpp>
#include <io/OBJTool.hpp>
using namespace AMCAX;
TEST_CASE("bug1: MakePipeShell ", "[offset][MakePipeShell][fixbug]") 
{
	OUTPUT_DIRECTORY(offset, MakePipeShell);
	TopoShape shape1;
	ShapeTool s1;
	bool result1 = s1.Read(shape1, INPUT_PATH_PREFIX"./offset/spine(1).shape", 0);
	CHECK(result1 == true);
	TopoWire spine = TopoCast::Wire(shape1);
	TopoShape shape2;
	ShapeTool s2;
	bool result2 = s2.Read(shape2, INPUT_PATH_PREFIX"./offset/profile(1).shape",0);
	CHECK(result2 == true);
	TopoWire profile = TopoCast::Wire(shape2);
	MakePipeShell makePipe = MakePipeShell(spine);
	makePipe.Add(profile);
	makePipe.SetForceApproxC1(true);
	makePipe.Build();
	TopoShape pipe = makePipe.Shape();
	OCCTIO::OCCTTool b;
	bool result3 = b.Write(pipe, outdir + "pipeRes_OCC_true.brep");
	CHECK(result3 == true);
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API MeshMakeCone(double r, double h, bool isBottom = true, size_t rseg = 8, size_t vseg = 4),
 "output":#include<catch.hpp>
#include<testHelperBase.h>
#include <polymeshAPI/MeshMakeCone.hpp>
#include <polymesh/PolyMeshIO.hpp>
#include <polymeshAPI/MeshSubdivideHE.hpp>
using namespace AMCAX;
TEST_CASE("case1:MeshMakeCone  ", "[polymeshAPI][SubD][MeshMakeCone][P1]") {
	double r = 1;
	double h = 1;
	SubD::MeshMakeCone meshmakeCone(r, h);
	AMCAX::SubD::PolyMesh* mesh = meshmakeCone.BuildMesh();
	CHECK(mesh != nullptr);
	AMCAX::SubD::MeshSubdivideHE::CatmullClark(mesh, 3);
	bool result = AMCAX::SubD::PolyMeshIO::WriteMesh(OUTPUT_PATH_PREFIX"MeshMakeCone_case01.obj", mesh);
	CHECK(result == true);
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API MeshMakeCone(Frame3 frame, double r, double h, bool isBottom = true, size_t rseg = 8, size_t vseg = 4),
 "output":#include<catch.hpp>
#include<testHelperBase.h>
#include <polymeshAPI/MeshMakeCone.hpp>
#include <polymesh/PolyMeshIO.hpp>
#include <polymeshAPI/MeshSubdivideHE.hpp>
using namespace AMCAX;
TEST_CASE("case1:MeshMakeCone  ", "[polymeshAPI][SubD][MeshMakeCone][P1]") {
	double r = 1;
	double h = 1;
	SubD::MeshMakeCone meshmakeCone(r, h);
	AMCAX::SubD::PolyMesh* mesh = meshmakeCone.BuildMesh();
	CHECK(mesh != nullptr);
	AMCAX::SubD::MeshSubdivideHE::CatmullClark(mesh, 3);
	bool result = AMCAX::SubD::PolyMeshIO::WriteMesh(OUTPUT_PATH_PREFIX"MeshMakeCone_case01.obj", mesh);
	CHECK(result == true);
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API explicit MeshMakeSphere(double r, size_t rseg = 8, size_t vseg = 4)	 @param vseg The number of segments in vertical, must >= 2
	 @param rseg The number of segments in rotation, must >= 4
	 @param r The radius
	 @brief Construct from origin and radius
,
 "output":#include<catch.hpp>
#include<testHelperBase.h>
#include <polymeshAPI/MeshMakeSphere.hpp>
#include <polymesh/PolyMeshIO.hpp>
#include <polymeshAPI/MeshSubdivideHE.hpp>
using namespace AMCAX;
TEST_CASE("case1: MeshMakeSphere  ", "[polymeshAPI][SubD][MeshMakeSphere][P1]") {
	double r = 2.1;
	AMCAX::SubD::MeshMakeSphere sphere(r);
	AMCAX::SubD::PolyMesh* mesh = sphere.BuildMesh();
	CHECK(mesh != nullptr);
	AMCAX::SubD::MeshSubdivideHE::CatmullClark(mesh, 3);
	bool result = AMCAX::SubD::PolyMeshIO::WriteMesh(OUTPUT_PATH_PREFIX"MeshMakeSphere_case01.obj", mesh);
	CHECK(result == true);
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API bool DoCatmullClark(PolyMesh* mesh, size_t subtime)	 @return Thue if the subdivide is successful
	 @param subtime The number of subdivision
	 @param mesh The input quadrilateral mesh 
	 @brief Do Catmull-Clark subdivision
,
 "output":#include<catch.hpp>
#include<testHelperBase.h>
#include <common/FrameT.hpp>
#include <polymeshAPI/MeshMakeCube.hpp>
#include <polymeshAPI/MeshMakeCone.hpp>
#include <polymeshAPI/MeshMakeCylinder.hpp>
#include <polymeshAPI/MeshMakeSphere.hpp>
#include <polymeshAPI/MeshSubdivideHE.hpp>
#include <polymeshAPI/MeshSubdivideRender.hpp>
#include <polymeshAPI/MeshTool.hpp>
#include <polymesh/PolyMeshIO.hpp>
#include <chrono>
using AMCAX::SubD::MeshSubdivideHE;
using AMCAX::SubD::MeshTool;
using AMCAX::SubD::MeshSubdivideRenderCC;
using AMCAX::SubD::MeshMakeCube;
using AMCAX::SubD::MeshMakeCone;
using AMCAX::SubD::MeshMakeCylinder;
using AMCAX::SubD::MeshMakeSphere;
using AMCAX::SubD::PolyMesh;
using AMCAX::Frame3;
using AMCAX::SubD::PolyMeshIO;
static void WriteCCToOBJ(const MeshSubdivideRenderCC& subdive, std::string& fileName)
{
	std::ofstream file(fileName);
	auto mPoints = subdive.Points();
	for (int i = 0; i < static_cast<int>(mPoints.size()); ++i)
	{
		file << "v " << mPoints[i] << std::endl;
	}
	auto mFaces = subdive.Faces();
	for (int i = 0; i < static_cast<int>(mFaces.size()); ++i)
	{
		const std::array<int, 4>& face = mFaces[i];
		file << "f " << face[0] + 1 << " " << face[1] + 1 << " " << face[2] + 1 << " " << face[3] + 1 << std::endl;
	}
	file.close();
}
static bool CheckSubdivide(const PolyMesh* beginMesh, const MeshSubdivideRenderCC& endRenderCC, int level = 1)
{
	size_t beginVertexNum = beginMesh->numVertices();
	size_t beginEdgeNum = beginMesh->numEdges();
	size_t beginPolygonNum = beginMesh->numPolygons();
	size_t currentVertexNum = beginVertexNum, currentEdgeNum = beginEdgeNum, currentPolygonNum = beginPolygonNum;
	for (int i = 0; i < level; ++i)
	{
		currentVertexNum = beginVertexNum + beginEdgeNum + beginPolygonNum;
		currentEdgeNum = beginEdgeNum * 2 + 4 * beginPolygonNum;
		currentPolygonNum = 4 * beginPolygonNum;
		beginVertexNum = currentVertexNum;
		beginEdgeNum = currentEdgeNum;
		beginPolygonNum = currentPolygonNum;
	}
	return (endRenderCC.Faces().size() == currentPolygonNum) && (endRenderCC.Points().size() == currentVertexNum);
}
static bool CheckSubdivide(size_t vertexNum, size_t edgeNum, size_t polygonNumconst, PolyMesh* endMesh, int level = 1)
{
	size_t beginVertexNum = vertexNum;
	size_t beginEdgeNum = edgeNum;
	size_t beginPolygonNum = polygonNumconst;
	size_t currentVertexNum = beginVertexNum, currentEdgeNum = beginEdgeNum, currentPolygonNum = beginPolygonNum;
	for (int i = 0; i < level; ++i)
	{
		currentVertexNum = beginVertexNum + beginEdgeNum + beginPolygonNum;
		currentEdgeNum = beginEdgeNum * 2 + 4 * beginPolygonNum;
		currentPolygonNum = 4 * beginPolygonNum;
		beginVertexNum = currentVertexNum;
		beginEdgeNum = currentEdgeNum;
		beginPolygonNum = currentPolygonNum;
	}
	return (endMesh->numPolygons() == currentPolygonNum) && (endMesh->numVertices() == currentVertexNum);
}
#if 0
#endif
TEST_CASE("CASE1:MeshSubdivideRenderCC Normal parameter test", "[polymeshAPI][SubD][MeshSubdivideRenderCC][p1]")
{
	MeshMakeCube makeCube(Frame3(), 10, 10, 10, 10, 10, 10);
	PolyMesh* mesh = makeCube.BuildMesh();
	std::string fileNameOBJ = OUTPUT_PATH_PREFIX"polymeshAPI_MeshSubdivideRenderCC_case1.obj";
	MeshSubdivideHE::CatmullClark(mesh, 1);  
	MeshSubdivideRenderCC subdive;
	bool isCatmullClarkResult = subdive.DoCatmullClark(mesh, 3);
	WriteCCToOBJ(subdive, fileNameOBJ);
	delete mesh;
	CHECK(isCatmullClarkResult == true);
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":MeshSubdivideRenderLoop()	 @brief Default constructor
,
 "output":#include<catch.hpp>
#include<testHelperBase.h>
#include <common/FrameT.hpp>
#include <polymeshAPI/MeshMakeCube.hpp>
#include <polymeshAPI/MeshMakeCone.hpp>
#include <polymeshAPI/MeshMakeCylinder.hpp>
#include <polymeshAPI/MeshMakeSphere.hpp>
#include <polymeshAPI/MeshSubdivideHE.hpp>
#include <polymeshAPI/MeshSubdivideRender.hpp>
#include <polymeshAPI/MeshTool.hpp>
#include <polymesh/PolyMeshIO.hpp>
#include <polymeshAPI/MeshCheck.hpp>
#include <chrono>
using AMCAX::SubD::MeshSubdivideHE;
using AMCAX::SubD::MeshTool;
using AMCAX::SubD::MeshSubdivideRenderLoop;
using AMCAX::SubD::MeshMakeCube;
using AMCAX::SubD::MeshMakeCone;  
using AMCAX::SubD::MeshMakeCylinder;  
using AMCAX::SubD::MeshMakeSphere;  
using AMCAX::SubD::PolyMesh;
using AMCAX::Frame3;
using AMCAX::SubD::PolyMeshIO;
static void WriteLoopToOBJ(const MeshSubdivideRenderLoop& subdive, std::string& fileName)
{
	std::ofstream file(fileName);
	auto mPoints = subdive.Points();
	for (int i = 0; i < static_cast<int>(mPoints.size()); ++i)
	{
		file << "v " << mPoints[i] << std::endl;
	}
	auto mFaces = subdive.Faces();
	for (int i = 0; i < static_cast<int>(mFaces.size()); ++i)
	{
		const std::array<int, 3>& face = mFaces[i];
		file << "f " << face[0] + 1 << " " << face[1] + 1 << " " << face[2] + 1 << std::endl;
	}
	file.close();
}
static bool CheckSubdivide(const PolyMesh* beginMesh, const MeshSubdivideRenderLoop& endRenderCC, int level = 1)
{
	size_t beginVertexNum = beginMesh->numVertices();
	size_t beginEdgeNum = beginMesh->numEdges();
	size_t beginPolygonNum = beginMesh->numPolygons();
	size_t currentVertexNum = beginVertexNum, currentEdgeNum = beginEdgeNum, currentPolygonNum = beginPolygonNum;
	for (int i = 0; i < level; ++i)
	{
		currentVertexNum = beginVertexNum + beginEdgeNum;
		currentEdgeNum = beginEdgeNum * 2 + 3 * beginPolygonNum;
		currentPolygonNum = 4 * beginPolygonNum;
		beginVertexNum = currentVertexNum;
		beginEdgeNum = currentEdgeNum;
		beginPolygonNum = currentPolygonNum;
	}
	return (endRenderCC.Faces().size() == currentPolygonNum) && (endRenderCC.Points().size() == currentVertexNum);
}
TEST_CASE("CASE5: MeshSubdivideRenderLoop Different subdivision levels", "[polymeshAPI][SubD][MeshSubdivideRenderLoop][p1]")
{
	for (int level = 1; level <= 5; ++level)
	{
		MeshMakeCube makeCube(Frame3(), 10, 10, 10, 10, 10, 10);
		PolyMesh* mesh = makeCube.BuildMesh();
		MeshTool::MeshTriangles(mesh);
		MeshSubdivideRenderLoop subdive;
		bool isLoopResult = subdive.DoLoop(mesh, level);
		std::string fileNameOBJ = OUTPUT_PATH_PREFIX"polymeshAPI_MeshSubdivideRenderLoop_level" + std::to_string(level) + "_case5.obj";
		WriteLoopToOBJ(subdive, fileNameOBJ);
		CHECK(isLoopResult == true);
		CHECK(CheckSubdivide(mesh, subdive, level));
		delete mesh;
	}
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API bool DoLoop(PolyMesh* mesh, size_t subtime)	 @return Thue if the subdivide is successful
	 @param subtime The number of subdivision
	 @param mesh The input triangle mesh 
	 @brief Do Loop subdivision
,
 "output":#include<catch.hpp>
#include<testHelperBase.h>
#include <common/FrameT.hpp>
#include <polymeshAPI/MeshMakeCube.hpp>
#include <polymeshAPI/MeshMakeCone.hpp>
#include <polymeshAPI/MeshMakeCylinder.hpp>
#include <polymeshAPI/MeshMakeSphere.hpp>
#include <polymeshAPI/MeshSubdivideHE.hpp>
#include <polymeshAPI/MeshSubdivideRender.hpp>
#include <polymeshAPI/MeshTool.hpp>
#include <polymesh/PolyMeshIO.hpp>
#include <polymeshAPI/MeshCheck.hpp>
#include <chrono>
using AMCAX::SubD::MeshSubdivideHE;
using AMCAX::SubD::MeshTool;
using AMCAX::SubD::MeshSubdivideRenderLoop;
using AMCAX::SubD::MeshMakeCube;
using AMCAX::SubD::MeshMakeCone;  
using AMCAX::SubD::MeshMakeCylinder;  
using AMCAX::SubD::MeshMakeSphere;  
using AMCAX::SubD::PolyMesh;
using AMCAX::Frame3;
using AMCAX::SubD::PolyMeshIO;
static void WriteLoopToOBJ(const MeshSubdivideRenderLoop& subdive, std::string& fileName)
{
	std::ofstream file(fileName);
	auto mPoints = subdive.Points();
	for (int i = 0; i < static_cast<int>(mPoints.size()); ++i)
	{
		file << "v " << mPoints[i] << std::endl;
	}
	auto mFaces = subdive.Faces();
	for (int i = 0; i < static_cast<int>(mFaces.size()); ++i)
	{
		const std::array<int, 3>& face = mFaces[i];
		file << "f " << face[0] + 1 << " " << face[1] + 1 << " " << face[2] + 1 << std::endl;
	}
	file.close();
}
static bool CheckSubdivide(const PolyMesh* beginMesh, const MeshSubdivideRenderLoop& endRenderCC, int level = 1)
{
	size_t beginVertexNum = beginMesh->numVertices();
	size_t beginEdgeNum = beginMesh->numEdges();
	size_t beginPolygonNum = beginMesh->numPolygons();
	size_t currentVertexNum = beginVertexNum, currentEdgeNum = beginEdgeNum, currentPolygonNum = beginPolygonNum;
	for (int i = 0; i < level; ++i)
	{
		currentVertexNum = beginVertexNum + beginEdgeNum;
		currentEdgeNum = beginEdgeNum * 2 + 3 * beginPolygonNum;
		currentPolygonNum = 4 * beginPolygonNum;
		beginVertexNum = currentVertexNum;
		beginEdgeNum = currentEdgeNum;
		beginPolygonNum = currentPolygonNum;
	}
	return (endRenderCC.Faces().size() == currentPolygonNum) && (endRenderCC.Points().size() == currentVertexNum);
}
TEST_CASE("CASE1:MeshSubdivideRenderLoop Normal parameter test", "[polymeshAPI][SubD][MeshSubdivideRenderLoop][p1]")
{
	MeshMakeCube makeCube(Frame3(), 10, 10, 10, 10, 10, 10);
	PolyMesh* mesh = makeCube.BuildMesh();
	std::string fileNameOBJ = OUTPUT_PATH_PREFIX"polymeshAPI_MeshSubdivideRenderLoop_case1.obj";
	MeshTool::MeshTriangles(mesh);  
	MeshSubdivideRenderLoop subdive;
	bool isLoopResult = subdive.DoLoop(mesh, 3);
	WriteLoopToOBJ(subdive, fileNameOBJ);
	delete mesh;
	CHECK(isLoopResult == true);
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API const std::vector<AMCAX::TopoShape>& Shapes()	 @return An immutable reference to the shapes in this product node.
	 @brief Get the immutable reference to shapes in this product node.
,
 "output":#include <catch.hpp>
#include<testHelper.h>
#include <step/StepData.hpp>
#include <step/mesh/StepMeshData.hpp>
#include <step/mesh/StepMeshReader.hpp>
using namespace AMCAX;
template<typename DataPtr>
void traverse(const DataPtr& stepData, const int indent, std::ostream& ost)
{
	for (int i = 0; i < indent; ++i)
	{
		ost << "|   ";
	}
	ost << stepData->ProductName() << ' ';
	ost << '[' << stepData->Shapes().size() << ']' << ':' << ' ';
	for (const auto& shape : stepData->Shapes())
	{
		ost << stepData->PartColor()[shape].to_string() << ' ';
	}
	ost << std::endl;
	for (const auto& child : stepData->Children())
	{
		traverse(child, indent + 1, ost);
	}
}
#include <catch.hpp>
#include<testHelper.h>
#include <step/StepData.hpp>
#include <step/mesh/StepMeshData.hpp>
#include <step/mesh/StepMeshReader.hpp>
using namespace AMCAX;
template<typename DataPtr>
void traverse(const DataPtr& stepData, const int indent, std::ostream& ost)
{
	for (int i = 0; i < indent; ++i)
	{
		ost << "|   ";
	}
	ost << stepData->ProductName() << ' ';
	ost << '[' << stepData->Shapes().size() << ']' << ':' << ' ';
	for (const auto& shape : stepData->Shapes())
	{
		ost << stepData->PartColor()[shape].to_string() << ' ';
	}
	ost << std::endl;
	for (const auto& child : stepData->Children())
	{
		traverse(child, indent + 1, ost);
	}
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API std::vector<AMCAX::TopoShape>& Shapes()	 @return A mutable reference to shapes in this product node.
	 @brief Get the mutable reference to shapes in this product node.
,
 "output":#include <catch.hpp>
#include<testHelper.h>
#include <step/StepData.hpp>
#include <step/mesh/StepMeshData.hpp>
#include <step/mesh/StepMeshReader.hpp>
using namespace AMCAX;
template<typename DataPtr>
void traverse(const DataPtr& stepData, const int indent, std::ostream& ost)
{
	for (int i = 0; i < indent; ++i)
	{
		ost << "|   ";
	}
	ost << stepData->ProductName() << ' ';
	ost << '[' << stepData->Shapes().size() << ']' << ':' << ' ';
	for (const auto& shape : stepData->Shapes())
	{
		ost << stepData->PartColor()[shape].to_string() << ' ';
	}
	ost << std::endl;
	for (const auto& child : stepData->Children())
	{
		traverse(child, indent + 1, ost);
	}
}
#include <catch.hpp>
#include<testHelper.h>
#include <step/StepData.hpp>
#include <step/mesh/StepMeshData.hpp>
#include <step/mesh/StepMeshReader.hpp>
using namespace AMCAX;
template<typename DataPtr>
void traverse(const DataPtr& stepData, const int indent, std::ostream& ost)
{
	for (int i = 0; i < indent; ++i)
	{
		ost << "|   ";
	}
	ost << stepData->ProductName() << ' ';
	ost << '[' << stepData->Shapes().size() << ']' << ':' << ' ';
	for (const auto& shape : stepData->Shapes())
	{
		ost << stepData->PartColor()[shape].to_string() << ' ';
	}
	ost << std::endl;
	for (const auto& child : stepData->Children())
	{
		traverse(child, indent + 1, ost);
	}
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static AMCAX::STEP::StepDataList& ApplyTrsfInplace(AMCAX::STEP::StepDataList& shapes)	 @return An of the StepData trees, with the structure unchanged, and transformation applied to the definite shapes.
	 @param  shapes An array of the StepData tree.
	 @brief  Apply the Transformations to the definite Shapes inplace.
,
 "output":#include <catch.hpp>
#include<testHelper.h>
#include <common/BoundingBox3.hpp>
#include <topology/BRepBoundingBox.hpp>
#include <step/StepReader.hpp>
#include <step/StepDataTool.hpp>
#include <io/ShapeTool.hpp>
using namespace AMCAX;
TEST_CASE("bug1: StepDataTool::ApplyTrsfInplace test bug:  ", "[step][StepDataTool][bug]")
{
	OUTPUT_DIRECTORY(Step, ApplyTrsfInline);
	STEP::StepReader reader(INPUT_PATH_PREFIX"./step_data/bed214T.step");
	reader.Read();
	STEP::StepDataList list = std::move(reader.GetShapes());
	STEP::StepDataList sdlist = STEP::StepDataTool::ApplyTrsfInplace(list);
	TopoShape comp = STEP::StepDataTool::MakeCompound(sdlist);
	OCCTIO::OCCTTool::Write(comp, outdir + "ApplyTrsfInplace_result.brep");
	BoundingBox3 bbox3;
	BRepBoundingBox::AddToBox(comp, bbox3);
	Point3 pmin = bbox3.CornerMin(), pmax = bbox3.CornerMax();
	double dis = pmin.Distance(pmax);
	CHECK(dis == Approx(3754.52));
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static AMCAX::STEP::StepDataList& FlattenInplace(AMCAX::STEP::StepDataList& shapes, bool unrolling = true)	 @return An array of StepData nodes, with all transformation applied to the definite shapes.
	 @param  unrolling Whether each node is allowed to contain 0 or multiple shapes.
	 @param  shapes An array of the StepData tree.
	 @brief  Flatten a StepData tree into an one-dimensional array, inplace.
,
 "output":#include <catch.hpp>
#include<testHelper.h>
#include <common/BoundingBox3.hpp>
#include <topology/BRepBoundingBox.hpp>
#include <step/StepReader.hpp>
#include <step/StepDataTool.hpp>
#include <io/ShapeTool.hpp>
using namespace AMCAX;
TEST_CASE("bug2: StepDataTool::FlattenInplace test bug:  ", "[step][StepDataTool][bug]")
{
	OUTPUT_DIRECTORY(Step, ApplyTrsfInline);
	STEP::StepReader reader(INPUT_PATH_PREFIX"./step_data/bed214T.step");
	reader.Read();
	STEP::StepDataList list = std::move(reader.GetShapes());
	STEP::StepDataList sdlist = STEP::StepDataTool::FlattenInplace(list);
	TopoShape comp = STEP::StepDataTool::MakeCompound(sdlist);
	OCCTIO::OCCTTool::Write(comp, outdir + "FlattenInplace_result.brep");
	BoundingBox3 bbox3;
	BRepBoundingBox::AddToBox(comp, bbox3);
	Point3 pmin = bbox3.CornerMin(), pmax = bbox3.CornerMax();
	double dis = pmin.Distance(pmax);
	CHECK(dis == Approx(3754.52));
	STEP::StepReader reader1(INPUT_PATH_PREFIX"./step_data/chip_FJ.step");
	reader1.Read();
	STEP::StepDataList list1 = std::move(reader1.GetShapes());
	STEP::StepDataList sdlist1 = STEP::StepDataTool::FlattenInplace(list1);
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] AMCAX_API static AMCAX::TopoShape MakeCompound(std::shared_ptr<AMCAX::STEP::StepData>& root, bool inplace = false)	 @note   If the StepData tree contains only one shape object, the shape object itself will be returned.
	 @return A TopoShape.
	 @param  shape A StepData tree.
	 @brief  Create a TopoShape from a StepData tree.
,
 "output":#include <catch.hpp>
#include<testHelper.h>
#include <common/BoundingBox3.hpp>
#include <topology/BRepBoundingBox.hpp>
#include <step/StepReader.hpp>
#include <step/StepDataTool.hpp>
#include <io/ShapeTool.hpp>
using namespace AMCAX;
TEST_CASE("bug1: StepDataTool::ApplyTrsfInplace test bug:  ", "[step][StepDataTool][bug]")
{
	OUTPUT_DIRECTORY(Step, ApplyTrsfInline);
	STEP::StepReader reader(INPUT_PATH_PREFIX"./step_data/bed214T.step");
	reader.Read();
	STEP::StepDataList list = std::move(reader.GetShapes());
	STEP::StepDataList sdlist = STEP::StepDataTool::ApplyTrsfInplace(list);
	TopoShape comp = STEP::StepDataTool::MakeCompound(sdlist);
	OCCTIO::OCCTTool::Write(comp, outdir + "ApplyTrsfInplace_result.brep");
	BoundingBox3 bbox3;
	BRepBoundingBox::AddToBox(comp, bbox3);
	Point3 pmin = bbox3.CornerMin(), pmax = bbox3.CornerMax();
	double dis = pmin.Distance(pmax);
	CHECK(dis == Approx(3754.52));
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] AMCAX_API static AMCAX::TopoShape MakeCompound(AMCAX::STEP::StepDataList& sdlist, bool inplace = false)	 @note   If the StepDataList contains only one shape object, the shape object itself will be returned.
	 @return A TopoShape.
	 @param  sdlist A StepDataList.
	 @brief  Create a TopoShape from a StepDataList.
,
 "output":#include <catch.hpp>
#include<testHelper.h>
#include <common/BoundingBox3.hpp>
#include <topology/BRepBoundingBox.hpp>
#include <step/StepReader.hpp>
#include <step/StepDataTool.hpp>
#include <io/ShapeTool.hpp>
using namespace AMCAX;
TEST_CASE("bug1: StepDataTool::ApplyTrsfInplace test bug:  ", "[step][StepDataTool][bug]")
{
	OUTPUT_DIRECTORY(Step, ApplyTrsfInline);
	STEP::StepReader reader(INPUT_PATH_PREFIX"./step_data/bed214T.step");
	reader.Read();
	STEP::StepDataList list = std::move(reader.GetShapes());
	STEP::StepDataList sdlist = STEP::StepDataTool::ApplyTrsfInplace(list);
	TopoShape comp = STEP::StepDataTool::MakeCompound(sdlist);
	OCCTIO::OCCTTool::Write(comp, outdir + "ApplyTrsfInplace_result.brep");
	BoundingBox3 bbox3;
	BRepBoundingBox::AddToBox(comp, bbox3);
	Point3 pmin = bbox3.CornerMin(), pmax = bbox3.CornerMax();
	double dis = pmin.Distance(pmax);
	CHECK(dis == Approx(3754.52));
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API void SetProgressCallback(const StepMeshProgressCallback& callback)	 @param[in] callback The callback function for the progress of the STEP process.
	 @brief Set the callback function for the progress of the STEP process.
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <step/mesh/StepMesh.hpp>
#include <step/mesh/StepMeshData.hpp>
#include <step/mesh/StepMeshReader.hpp>
#include <step/mesh/StepMeshProgress.hpp>
#include <common/IndexSet.hpp>
#include <topology/TopoExplorerTool.hpp>
#include <fstream>
#include <iostream>
#include <filesystem>
using namespace AMCAX;
using namespace  AMCAX::STEP;
TEST_CASE("case2:StepMeshReader ", "[step][StepMeshData][P1]") {
    StepMeshReader<AMCAX::Meshing::Mesh::TriSoupTraits_Coord> reader(INPUT_PATH_PREFIX"tank.step");
    reader.SetUnit(STEP::StepLengthUnit::PresetLengthUnit::FOOT); 
    fs::path logFilePath = OUTPUT_PATH_PREFIX"progress.txt";
    if (fs::exists(logFilePath))
    {
        fs::remove(logFilePath);
        std::cout << "deleted progress.txt file" << std::endl;
    }
    reader.SetProgressCallback(ProgressCallback);
    bool topoSuccess = reader.Read();
    CHECK(topoSuccess);
    bool meshSuccess = reader.ToMesh();
    CHECK(meshSuccess);
    CHECK( containsStringInFile(OUTPUT_PATH_PREFIX"progress.txt", "State: 0 c1: 0 c2: 0") );
    CHECK( containsStringInFile(OUTPUT_PATH_PREFIX"progress.txt", "State: 1 c1: 0 c2: 0") );
    CHECK( containsStringInFile(OUTPUT_PATH_PREFIX"progress.txt", "State: 2 c1: 0 c2: 0") );
    CHECK( containsStringInFile(OUTPUT_PATH_PREFIX"progress.txt", "State: 3 c1: 0 c2: 0") );
    CHECK( containsStringInFile(OUTPUT_PATH_PREFIX"progress.txt", "State: 4 c1: 0 c2: 0") );
    CHECK( containsStringInFile(OUTPUT_PATH_PREFIX"progress.txt", "State: 5 c1: 0 c2: 19") );
    CHECK( containsStringInFile(OUTPUT_PATH_PREFIX"progress.txt", "State: 6 c1: 1 c2: 19") );
    CHECK( containsStringInFile(OUTPUT_PATH_PREFIX"progress.txt", "State: 6 c1: 19 c2: 19") );
    CHECK( containsStringInFile(OUTPUT_PATH_PREFIX"progress.txt", "State: 7 c1: 19 c2: 19") );
    CHECK( containsStringInFile(OUTPUT_PATH_PREFIX"progress.txt", "State: 8 c1: 0 c2: 0") );
    CHECK( containsStringInFile(OUTPUT_PATH_PREFIX"progress.txt", "State: 9 c1: 0 c2: 0") );
    CHECK( containsStringInFile(OUTPUT_PATH_PREFIX"progress.txt", "State: 10 c1: 0 c2: 0") );
    CHECK( containsStringInFile(OUTPUT_PATH_PREFIX"progress.txt", "State: 512 c1: 0 c2: 0") );
    CHECK( containsStringInFile(OUTPUT_PATH_PREFIX"progress.txt", "State: 513 c1: 0 c2: 0") );
    CHECK( containsStringInFile(OUTPUT_PATH_PREFIX"progress.txt", "State: 514 c1: 0 c2: 0") );
    CHECK( containsStringInFile(OUTPUT_PATH_PREFIX"progress.txt", "State: 515 c1: 0 c2: 54") );
    CHECK( containsStringInFile(OUTPUT_PATH_PREFIX"progress.txt", "State: 516 c1: 1 c2: 54") );
    CHECK( containsStringInFile(OUTPUT_PATH_PREFIX"progress.txt", "State: 516 c1: 54 c2: 54") );
    CHECK( containsStringInFile(OUTPUT_PATH_PREFIX"progress.txt", "State: 517 c1: 0 c2: 0") );
    CHECK( containsStringInFile(OUTPUT_PATH_PREFIX"progress.txt", "State: 518 c1: 0 c2: 0") );
    CHECK( containsStringInFile(OUTPUT_PATH_PREFIX"progress.txt", "State: 519 c1: 0 c2: 0") );
    CHECK( containsStringInFile(OUTPUT_PATH_PREFIX"progress.txt", "State: 520 c1: 0 c2: 0") );
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API const StepMeshDataList<Traits>& GetShapes()	 @return The list of pointers of StepMeshData Trees.
	 @brief Get the list of pointers of StepMeshData Trees.
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <step/mesh/StepMesh.hpp>
#include <step/mesh/StepMeshData.hpp>
#include <step/mesh/StepMeshReader.hpp>
#include <step/mesh/StepMeshProgress.hpp>
#include <common/IndexSet.hpp>
#include <topology/TopoExplorerTool.hpp>
#include <fstream>
#include <iostream>
#include <filesystem>
using namespace AMCAX;
using namespace  AMCAX::STEP;
TEST_CASE("case1:StepMeshReader  ", "[step][StepMeshData][P1]") {
    StepMeshReader<AMCAX::Meshing::Mesh::TriSoupTraits_Coord> reader(INPUT_PATH_PREFIX"tank.step");
    bool topoSuccess = reader.Read();
    CHECK(topoSuccess == true);
    bool meshSuccess = reader.ToMesh();
    CHECK(meshSuccess == true);
    StepMeshDataList<AMCAX::Meshing::Mesh::TriSoupTraits_Coord> container = reader.GetShapes();
    for (auto& meshdata : container)
    {
        int nSolidCount = meshdata->SolidCount(true);
        int nMeshCount = meshdata->MeshCount(true);
        std::cout << "SolidCount: " << nSolidCount << ", ";
        std::cout << "MeshCount: " << nMeshCount << std::endl;
        CHECK(nSolidCount == nMeshCount);
        CHECK(nSolidCount != 0);
        CHECK(nMeshCount != 0);
    }
}
void ProgressCallback(const STEP::StepMeshProgressState state,
    const STEP::StepProgressCarrier c1,
    const STEP::StepProgressCarrier c2)
{
    std::ofstream logFile(OUTPUT_PATH_PREFIX"progress.txt", std::ios::app); 
    if (logFile.is_open())
    {
        logFile << "State: " << state
            << " c1: " << c1.payload.u64
            << " c2: " << c2.payload.u64
            << std::endl;
        logFile.close(); 
    }
    else
    {
        std::cerr << " progress.txt" << std::endl;
    }
}
namespace fs = std::filesystem;
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API StepMeshDataList<Traits>& GetShapes()	 @return The list of pointers of StepMeshData Trees.
	 @brief Get the list of pointers of StepMeshData Trees.
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <step/mesh/StepMesh.hpp>
#include <step/mesh/StepMeshData.hpp>
#include <step/mesh/StepMeshReader.hpp>
#include <step/mesh/StepMeshProgress.hpp>
#include <common/IndexSet.hpp>
#include <topology/TopoExplorerTool.hpp>
#include <fstream>
#include <iostream>
#include <filesystem>
using namespace AMCAX;
using namespace  AMCAX::STEP;
TEST_CASE("case1:StepMeshReader  ", "[step][StepMeshData][P1]") {
    StepMeshReader<AMCAX::Meshing::Mesh::TriSoupTraits_Coord> reader(INPUT_PATH_PREFIX"tank.step");
    bool topoSuccess = reader.Read();
    CHECK(topoSuccess == true);
    bool meshSuccess = reader.ToMesh();
    CHECK(meshSuccess == true);
    StepMeshDataList<AMCAX::Meshing::Mesh::TriSoupTraits_Coord> container = reader.GetShapes();
    for (auto& meshdata : container)
    {
        int nSolidCount = meshdata->SolidCount(true);
        int nMeshCount = meshdata->MeshCount(true);
        std::cout << "SolidCount: " << nSolidCount << ", ";
        std::cout << "MeshCount: " << nMeshCount << std::endl;
        CHECK(nSolidCount == nMeshCount);
        CHECK(nSolidCount != 0);
        CHECK(nMeshCount != 0);
    }
}
void ProgressCallback(const STEP::StepMeshProgressState state,
    const STEP::StepProgressCarrier c1,
    const STEP::StepProgressCarrier c2)
{
    std::ofstream logFile(OUTPUT_PATH_PREFIX"progress.txt", std::ios::app); 
    if (logFile.is_open())
    {
        logFile << "State: " << state
            << " c1: " << c1.payload.u64
            << " c2: " << c2.payload.u64
            << std::endl;
        logFile.close(); 
    }
    else
    {
        std::cerr << " progress.txt" << std::endl;
    }
}
namespace fs = std::filesystem;
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API bool WriteShape(const std::shared_ptr<AMCAX::STEP::StepData>& shape)	 @return True if the shape is written successfully, otherwise false.
	 @param[in] shape The TopoShape object and related data to be translated and to be wrote into the STEP file.
	 @brief Add a StepData tree to the exporting list.
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <step/StepWriter.hpp>
#include <step/StepReader.hpp>
#include<step/StepDataTool.hpp>
using namespace AMCAX;
TEST_CASE("bug1: WriteShape  ", "[step][WriteShape][P1][fixbug]") {
	AMCAX::TopoShape shapeRead;
	AMCAX::OCCTIO::OCCTTool::Read(shapeRead, INPUT_PATH_PREFIX"tmploft.brep");
	CHECK(shapeRead.IsNull() == false);
	AMCAX::STEP::StepWriter writer(OUTPUT_PATH_PREFIX"tmploft.step");
	writer.Init();
	bool bWriteShape = writer.WriteShape(shapeRead);
	CHECK(bWriteShape == true);
	writer.Done();
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API bool WriteShape(const AMCAX::TopoShape& shape)	 @return True if the shape is written successfully, otherwise false.
	 @param[in] shape The TopoShape object and related data to be translated and to be wrote into the STEP file.
	 @brief Add a TopoShape to the exporting list.
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <step/StepWriter.hpp>
#include <step/StepReader.hpp>
#include<step/StepDataTool.hpp>
using namespace AMCAX;
TEST_CASE("bug1: WriteShape  ", "[step][WriteShape][P1][fixbug]") {
	AMCAX::TopoShape shapeRead;
	AMCAX::OCCTIO::OCCTTool::Read(shapeRead, INPUT_PATH_PREFIX"tmploft.brep");
	CHECK(shapeRead.IsNull() == false);
	AMCAX::STEP::StepWriter writer(OUTPUT_PATH_PREFIX"tmploft.step");
	writer.Init();
	bool bWriteShape = writer.WriteShape(shapeRead);
	CHECK(bWriteShape == true);
	writer.Done();
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static void AddToBox(const TopoShape& S, BoundingBox3& B, bool useTriangulation = true)	 @param[in] useTriangulation Does the computation use triangulation
	 @param[in,out] B The bounding box
	 @param[in] S The shape
	 @brief Add a shape to a bounding box
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/BoundingBox3.hpp>
#include <topology/BRepBoundingBox.hpp>
#include <topology/TopoExplorerTool.hpp>
using namespace AMCAX;
TEST_CASE("NOTFIX bug1:  case1:this is a case for BoundingBox3", "[topology][BoundingBox3][bug]") 
{
	TopoShape toposhape;
	OCCTIO::OCCTTool::Read(toposhape, INPUT_PATH_PREFIX"topology/Lens_1.brep");
	IndexSet<TopoShape> shapeFaces;
	TopoExplorerTool::MapShapes(toposhape, ShapeType::Face, shapeFaces);
	CHECK(shapeFaces.size() == 3);
	TopoShape shape1 = shapeFaces[1];
	OCCTIO::OCCTTool::Write(shape1, OUTPUT_PATH_PREFIX"firstface.brep");
	BoundingBox3 box3;
	BRepBoundingBox::AddToBox(shape1, box3);
	Point3 pmin = box3.CornerMin(), pmax = box3.CornerMax();
	CHECK(pmin.X() == Approx(-1.0));
	CHECK(pmin.Y() == Approx(-1.0));
	CHECK(pmin.Z() == Approx(-0.5));
	CHECK(pmax.X() == Approx(1.0));
	CHECK(pmax.Y() == Approx(1.0));
	CHECK(pmax.Z() == Approx(-0.3));
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API BRepExtremaProximityTool()	 @brief Empty constructor for proximity tool
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeWire.hpp>
#include <modeling/MakeBox.hpp>
#include <modeling/MakeCylinder.hpp>
#include <topology/TopoCompSolid.hpp>
#include <topology/TopoCompound.hpp>
#include <topology/TopoFace.hpp>
#include <topology/TopoSolid.hpp>
#include <topology/TopoShell.hpp>
#include <topology/TopoBuilder.hpp>
#include <topology/TopoExplorerTool.hpp>
#include <topology/BRepExtremaProximityTool.hpp>
#include <io/OBJTool.hpp>
#include <modeling/TransformShape.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
using namespace std;
#include<catch.hpp>
#include<testHelper.h>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeWire.hpp>
#include <modeling/MakeBox.hpp>
#include <modeling/MakeCylinder.hpp>
#include <topology/TopoCompSolid.hpp>
#include <topology/TopoCompound.hpp>
#include <topology/TopoFace.hpp>
#include <topology/TopoSolid.hpp>
#include <topology/TopoShell.hpp>
#include <topology/TopoBuilder.hpp>
#include <topology/TopoExplorerTool.hpp>
#include <topology/BRepExtremaProximityTool.hpp>
#include <io/OBJTool.hpp>
#include <modeling/TransformShape.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
using namespace std;
;
	SECTION("Default Construction")
	{
		BRepExtremaProximityTool proxTool;
		bool r3 = proxTool.PerformProximityValue(tolMax);
		CHECK(r3 == false);
		CHECK(tolMax == Approx(0.0));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API BRepExtremaProximityTool(const TopoShape& shape1, const TopoShape& shape2)	 @param shape2 The second shape
	 @param shape1 The first shape
	 @brief Construct proximity tool from two shapes
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeWire.hpp>
#include <modeling/MakeBox.hpp>
#include <modeling/MakeCylinder.hpp>
#include <topology/TopoCompSolid.hpp>
#include <topology/TopoCompound.hpp>
#include <topology/TopoFace.hpp>
#include <topology/TopoSolid.hpp>
#include <topology/TopoShell.hpp>
#include <topology/TopoBuilder.hpp>
#include <topology/TopoExplorerTool.hpp>
#include <topology/BRepExtremaProximityTool.hpp>
#include <io/OBJTool.hpp>
#include <modeling/TransformShape.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
using namespace std;
#include<catch.hpp>
#include<testHelper.h>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeWire.hpp>
#include <modeling/MakeBox.hpp>
#include <modeling/MakeCylinder.hpp>
#include <topology/TopoCompSolid.hpp>
#include <topology/TopoCompound.hpp>
#include <topology/TopoFace.hpp>
#include <topology/TopoSolid.hpp>
#include <topology/TopoShell.hpp>
#include <topology/TopoBuilder.hpp>
#include <topology/TopoExplorerTool.hpp>
#include <topology/BRepExtremaProximityTool.hpp>
#include <io/OBJTool.hpp>
#include <modeling/TransformShape.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
using namespace std;
;
	SECTION("Parametric Construction-Null")
	{
		TopoShape shape1;
		TopoShape shape2;
		BRepExtremaProximityTool proxTool(shape1, shape2);
		bool r3 = proxTool.PerformProximityValue(tolMax);
		CHECK(r3 == false);
		CHECK(tolMax == Approx(0.0));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API void LoadShapes(const TopoShape& shape1, const TopoShape& shape2)	 @param shape2 The second shape
	 @param shape1 The first shape
	 @brief Load the shape of proximity tool
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeWire.hpp>
#include <modeling/MakeBox.hpp>
#include <modeling/MakeCylinder.hpp>
#include <topology/TopoCompSolid.hpp>
#include <topology/TopoCompound.hpp>
#include <topology/TopoFace.hpp>
#include <topology/TopoSolid.hpp>
#include <topology/TopoShell.hpp>
#include <topology/TopoBuilder.hpp>
#include <topology/TopoExplorerTool.hpp>
#include <topology/BRepExtremaProximityTool.hpp>
#include <io/OBJTool.hpp>
#include <modeling/TransformShape.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
using namespace std;
#include<catch.hpp>
#include<testHelper.h>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeWire.hpp>
#include <modeling/MakeBox.hpp>
#include <modeling/MakeCylinder.hpp>
#include <topology/TopoCompSolid.hpp>
#include <topology/TopoCompound.hpp>
#include <topology/TopoFace.hpp>
#include <topology/TopoSolid.hpp>
#include <topology/TopoShell.hpp>
#include <topology/TopoBuilder.hpp>
#include <topology/TopoExplorerTool.hpp>
#include <topology/BRepExtremaProximityTool.hpp>
#include <io/OBJTool.hpp>
#include <modeling/TransformShape.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
using namespace std;
;
	SECTION("LoadShapes-Null")
	{
		TopoShape shape1;
		TopoShape shape2;
		BRepExtremaProximityTool proxTool;
		proxTool.LoadShapes(shape1, shape2);
		bool r3 = proxTool.PerformProximityValue(tolMax);
		CHECK(r3 == false);
		CHECK(tolMax == Approx(0.0));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API bool PerformOverlapFaces(std::vector<std::pair<TopoShape, TopoShape>>& facesInShape, const double tolerance = Precision::Confusion()	 @return true if two shape have overlapping faces
	 @param tolerance The horizontal tolerance used for check overlaping
	 @param facesInShape The couples of faces with overlapping areas
	 @brief Performs find faces of shape with finite overlapping areas
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeWire.hpp>
#include <modeling/MakeBox.hpp>
#include <modeling/MakeCylinder.hpp>
#include <topology/TopoCompSolid.hpp>
#include <topology/TopoCompound.hpp>
#include <topology/TopoFace.hpp>
#include <topology/TopoSolid.hpp>
#include <topology/TopoShell.hpp>
#include <topology/TopoBuilder.hpp>
#include <topology/TopoExplorerTool.hpp>
#include <topology/BRepExtremaProximityTool.hpp>
#include <io/OBJTool.hpp>
#include <modeling/TransformShape.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
using namespace std;
#include<catch.hpp>
#include<testHelper.h>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeWire.hpp>
#include <modeling/MakeBox.hpp>
#include <modeling/MakeCylinder.hpp>
#include <topology/TopoCompSolid.hpp>
#include <topology/TopoCompound.hpp>
#include <topology/TopoFace.hpp>
#include <topology/TopoSolid.hpp>
#include <topology/TopoShell.hpp>
#include <topology/TopoBuilder.hpp>
#include <topology/TopoExplorerTool.hpp>
#include <topology/BRepExtremaProximityTool.hpp>
#include <io/OBJTool.hpp>
#include <modeling/TransformShape.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
using namespace std;
;
	SECTION("horizontal translation[overlap=0] ")
	{
		x1 = 2.0;
		x2 = 4.0;
		MakeBox box2(Point3(x1, 0.0, 0.0), Point3(x2, 2.0, 1.0));
		TopoFace shape2 = box2.ZMinFace();
		proxTool.LoadShapes(shape1, shape2);
		bool r1 = proxTool.PerformOverlapFaces(overlapShape, tolerance);
		CHECK(overlapShape.size() == 0);
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API bool PerformIntersectionFaces(std::vector<std::pair<TopoShape, TopoShape>>& facesInShape, const double tolerance = Precision::Confusion()	 @return true if two shape have intersecting faces
	 @param tolerance The tolerance used for check intersection
	 @param facesInShape The couple of faces which intersect with each other
	 @brief Performs find intersecting faces of shape
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeWire.hpp>
#include <modeling/MakeBox.hpp>
#include <modeling/MakeCylinder.hpp>
#include <topology/TopoCompSolid.hpp>
#include <topology/TopoCompound.hpp>
#include <topology/TopoFace.hpp>
#include <topology/TopoSolid.hpp>
#include <topology/TopoShell.hpp>
#include <topology/TopoBuilder.hpp>
#include <topology/TopoExplorerTool.hpp>
#include <topology/BRepExtremaProximityTool.hpp>
#include <io/OBJTool.hpp>
#include <modeling/TransformShape.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
using namespace std;
#include<catch.hpp>
#include<testHelper.h>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeWire.hpp>
#include <modeling/MakeBox.hpp>
#include <modeling/MakeCylinder.hpp>
#include <topology/TopoCompSolid.hpp>
#include <topology/TopoCompound.hpp>
#include <topology/TopoFace.hpp>
#include <topology/TopoSolid.hpp>
#include <topology/TopoShell.hpp>
#include <topology/TopoBuilder.hpp>
#include <topology/TopoExplorerTool.hpp>
#include <topology/BRepExtremaProximityTool.hpp>
#include <io/OBJTool.hpp>
#include <modeling/TransformShape.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
using namespace std;
;
	SECTION("horizontal translation[separate=3.0*tolerance] ")
	{
		x1 = 2.0 + 3.0 * tolerance;
		x2 = 4.0 + 3.0 * tolerance;
		MakeBox box2(Point3(x1, 0.0, 0.0), Point3(x2, 2.0, 1.0));
		TopoFace shape2 = box2.ZMinFace();
		proxTool.LoadShapes(shape1, shape2);
		bool r2 = proxTool.PerformIntersectionFaces(intersectionShape, tolerance);
		CHECK(r2 == false);
		CHECK(intersectionShape.size() == 0);
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API bool PerformProximityValue(double& hdProxDistance)	 @return true if perform successfully
	 @param hdProxDistance The result approximate hausdorff distance
	 @details The hausdorff distance H(S1, S2) = max(maxmin||S1 - S2||, maxmin||S2 - S1||);
	 @brief Compute the approximate hausdorff distance with two shape
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeWire.hpp>
#include <modeling/MakeBox.hpp>
#include <modeling/MakeCylinder.hpp>
#include <topology/TopoCompSolid.hpp>
#include <topology/TopoCompound.hpp>
#include <topology/TopoFace.hpp>
#include <topology/TopoSolid.hpp>
#include <topology/TopoShell.hpp>
#include <topology/TopoBuilder.hpp>
#include <topology/TopoExplorerTool.hpp>
#include <topology/BRepExtremaProximityTool.hpp>
#include <io/OBJTool.hpp>
#include <modeling/TransformShape.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
using namespace std;
#include<catch.hpp>
#include<testHelper.h>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeWire.hpp>
#include <modeling/MakeBox.hpp>
#include <modeling/MakeCylinder.hpp>
#include <topology/TopoCompSolid.hpp>
#include <topology/TopoCompound.hpp>
#include <topology/TopoFace.hpp>
#include <topology/TopoSolid.hpp>
#include <topology/TopoShell.hpp>
#include <topology/TopoBuilder.hpp>
#include <topology/TopoExplorerTool.hpp>
#include <topology/BRepExtremaProximityTool.hpp>
#include <io/OBJTool.hpp>
#include <modeling/TransformShape.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
using namespace std;
;
	SECTION("Parametric Construction-TopoShape")
	{
		TopoShape shape1 = MakeBox(Point3(0.0, 0.0, 0.0), Point3(2.0, 2.0, 1.0));
		TopoShape shape2 = MakeBox(Point3(1.0, 1.0, 0.0), Point3(3.0, 3.0, 1.0));
		BRepExtremaProximityTool proxTool(shape1, shape2);
		vector<pair<TopoShape, TopoShape>> overlapShape;
		vector<pair<TopoShape, TopoShape>> intersectionShape;
		bool r1 = proxTool.PerformOverlapFaces(overlapShape, tolerance);
		bool r2 = proxTool.PerformIntersectionFaces(intersectionShape, tolerance);
		bool r3 = proxTool.PerformProximityValue(tolMax);
		CHECK(r1 == true);
		CHECK(r2 == true);
		CHECK(r3 == true);
		CHECK(overlapShape.size() == 2);
		CHECK(intersectionShape.size() == 12);
		CHECK(tolMax == Approx(sqrt(2.0)));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API BRepExtremaProximityTool()	 @brief Empty constructor for proximity tool
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <modeling/MakeSphere.hpp>
#include <topology/BRepExtremaProximityTool.hpp>
#include <io/OBJTool.hpp>
#include <modeling/TransformShape.hpp>
#include <topology/TopoExplorerTool.hpp>
#include <modeling/MakeCone.hpp>
#include <modeling/MakeSphere.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
using namespace std;
#include<catch.hpp>
#include<testHelper.h>
#include <modeling/MakeSphere.hpp>
#include <topology/BRepExtremaProximityTool.hpp>
#include <io/OBJTool.hpp>
#include <modeling/TransformShape.hpp>
#include <topology/TopoExplorerTool.hpp>
#include <modeling/MakeCone.hpp>
#include <modeling/MakeSphere.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
using namespace std;
;
	SECTION("Left Translation=2.0")
	{
		x = 0.0 - 2.0;
		tr.SetTranslation(Point3(0.0, 1.0, 1.0), Point3(x, 1.0, 1.0));
		TransformShape ts(shape2, tr, false, false);
		BRepExtremaProximityTool proxTool(shape1, ts);
		bool r2 = proxTool.PerformIntersectionFaces(intersectionShape, tolerance);
		CHECK(r2 == true);
		CHECK(intersectionShape.size() == 1);
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API BRepExtremaProximityTool(const TopoShape& shape1, const TopoShape& shape2)	 @param shape2 The second shape
	 @param shape1 The first shape
	 @brief Construct proximity tool from two shapes
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <modeling/MakeSphere.hpp>
#include <topology/BRepExtremaProximityTool.hpp>
#include <io/OBJTool.hpp>
#include <modeling/TransformShape.hpp>
#include <topology/TopoExplorerTool.hpp>
#include <modeling/MakeCone.hpp>
#include <modeling/MakeSphere.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
using namespace std;
#include<catch.hpp>
#include<testHelper.h>
#include <modeling/MakeSphere.hpp>
#include <topology/BRepExtremaProximityTool.hpp>
#include <io/OBJTool.hpp>
#include <modeling/TransformShape.hpp>
#include <topology/TopoExplorerTool.hpp>
#include <modeling/MakeCone.hpp>
#include <modeling/MakeSphere.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
using namespace std;
;
	SECTION("point overlap")
	{
		Axis3 axis(Point3(0.0, 0.0, 0.0), Direction3(1.0, 0.0, 0.0));
		angle = M_PI;
		tr.SetRotation(axis, angle);
		TransformShape ts(shape2, tr, false, false);
		BRepExtremaProximityTool proxTool(shape1, ts);
		bool r1 = proxTool.PerformOverlapFaces(overlapShape, tolerance);
		CHECK(r1 == false);
		CHECK(overlapShape.size() == 0);
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API void LoadShapes(const TopoShape& shape1, const TopoShape& shape2)	 @param shape2 The second shape
	 @param shape1 The first shape
	 @brief Load the shape of proximity tool
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <modeling/MakeSphere.hpp>
#include <topology/BRepExtremaProximityTool.hpp>
#include <io/OBJTool.hpp>
#include <modeling/TransformShape.hpp>
#include <topology/TopoExplorerTool.hpp>
#include <modeling/MakeCone.hpp>
#include <modeling/MakeSphere.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
using namespace std;
#include<catch.hpp>
#include<testHelper.h>
#include <modeling/MakeSphere.hpp>
#include <topology/BRepExtremaProximityTool.hpp>
#include <io/OBJTool.hpp>
#include <modeling/TransformShape.hpp>
#include <topology/TopoExplorerTool.hpp>
#include <modeling/MakeCone.hpp>
#include <modeling/MakeSphere.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
using namespace std;
;
	SECTION("Point to Point")
	{
		angle = M_PI;
		tr1.SetRotation(axis, angle);
		TransformShape ts1(shape2, tr1, false, false);
		y = -1.0 + 2.0;
		tr.SetTranslation(Point3(0.0, -1.0, 1.0), Point3(0.0, y, 1.0));
		TransformShape ts(ts1, tr, false, false);
		BRepExtremaProximityTool proxTool(shape1, ts);
		bool r1 = proxTool.PerformOverlapFaces(overlapShape, tolerance);
		bool r2 = proxTool.PerformIntersectionFaces(intersectionShape, tolerance);
		bool r3 = proxTool.PerformProximityValue(tolMax);
		CHECK(r1 == false);
		CHECK(r2 == true);
		CHECK(r3 == true);
		CHECK(overlapShape.size() == 0);
		CHECK(intersectionShape.size() == 1);
		BRepExtremaDistShapeShape dist(shape1, ts);
		CHECK(dist.Value() < tolerance);
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API bool PerformOverlapFaces(std::vector<std::pair<TopoShape, TopoShape>>& facesInShape, const double tolerance = Precision::Confusion()	 @return true if two shape have overlapping faces
	 @param tolerance The horizontal tolerance used for check overlaping
	 @param facesInShape The couples of faces with overlapping areas
	 @brief Performs find faces of shape with finite overlapping areas
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <modeling/MakeSphere.hpp>
#include <topology/BRepExtremaProximityTool.hpp>
#include <io/OBJTool.hpp>
#include <modeling/TransformShape.hpp>
#include <topology/TopoExplorerTool.hpp>
#include <modeling/MakeCone.hpp>
#include <modeling/MakeSphere.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
using namespace std;
#include<catch.hpp>
#include<testHelper.h>
#include <modeling/MakeSphere.hpp>
#include <topology/BRepExtremaProximityTool.hpp>
#include <io/OBJTool.hpp>
#include <modeling/TransformShape.hpp>
#include <topology/TopoExplorerTool.hpp>
#include <modeling/MakeCone.hpp>
#include <modeling/MakeSphere.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
using namespace std;
;
	SECTION("U Direction[angle=M_PI_2-0.1*tolerance]")
	{
		angle = M_PI_2 - 0.1 * tolerance;
		tr.SetRotation(axis, angle);
		TransformShape ts(shape2, tr, false, false);
		BRepExtremaProximityTool proxTool(shape1, ts);
		bool r1 = proxTool.PerformOverlapFaces(overlapShape, tolerance);
		CHECK(r1 == true);
		CHECK(overlapShape.size() == 1);
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API bool PerformIntersectionFaces(std::vector<std::pair<TopoShape, TopoShape>>& facesInShape, const double tolerance = Precision::Confusion()	 @return true if two shape have intersecting faces
	 @param tolerance The tolerance used for check intersection
	 @param facesInShape The couple of faces which intersect with each other
	 @brief Performs find intersecting faces of shape
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <modeling/MakeSphere.hpp>
#include <topology/BRepExtremaProximityTool.hpp>
#include <io/OBJTool.hpp>
#include <modeling/TransformShape.hpp>
#include <topology/TopoExplorerTool.hpp>
#include <modeling/MakeCone.hpp>
#include <modeling/MakeSphere.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
using namespace std;
#include<catch.hpp>
#include<testHelper.h>
#include <modeling/MakeSphere.hpp>
#include <topology/BRepExtremaProximityTool.hpp>
#include <io/OBJTool.hpp>
#include <modeling/TransformShape.hpp>
#include <topology/TopoExplorerTool.hpp>
#include <modeling/MakeCone.hpp>
#include <modeling/MakeSphere.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
using namespace std;
;
	SECTION("V Direction[Translation=8.0]")
	{
		z = 8.0;
		tr1.SetTranslation(Point3(0.0, 0.0, 0.0), Point3(0.0, 6.0, z));
		TransformShape ts(shape2, tr1, false, false);
		BRepExtremaProximityTool proxTool(shape1, ts);
		bool r2 = proxTool.PerformIntersectionFaces(intersectionShape, tolerance);
		CHECK(r2 == true);
		CHECK(intersectionShape.size() == 1);
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API bool PerformProximityValue(double& hdProxDistance)	 @return true if perform successfully
	 @param hdProxDistance The result approximate hausdorff distance
	 @details The hausdorff distance H(S1, S2) = max(maxmin||S1 - S2||, maxmin||S2 - S1||);
	 @brief Compute the approximate hausdorff distance with two shape
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <modeling/MakeSphere.hpp>
#include <topology/BRepExtremaProximityTool.hpp>
#include <io/OBJTool.hpp>
#include <modeling/TransformShape.hpp>
#include <topology/TopoExplorerTool.hpp>
#include <modeling/MakeCone.hpp>
#include <modeling/MakeSphere.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
using namespace std;
#include<catch.hpp>
#include<testHelper.h>
#include <modeling/MakeSphere.hpp>
#include <topology/BRepExtremaProximityTool.hpp>
#include <io/OBJTool.hpp>
#include <modeling/TransformShape.hpp>
#include <topology/TopoExplorerTool.hpp>
#include <modeling/MakeCone.hpp>
#include <modeling/MakeSphere.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
using namespace std;
;
	SECTION("U Direction[Complete overlap]")
	{
		BRepExtremaProximityTool proxTool(shape1, shape2);
		bool r1 = proxTool.PerformOverlapFaces(overlapShape, tolerance);
		bool r2 = proxTool.PerformIntersectionFaces(intersectionShape, tolerance);
		bool r3 = proxTool.PerformProximityValue(tolMax);
		CHECK(r1 == true);
		CHECK(r2 == true);
		CHECK(r3 == true);
		CHECK(overlapShape.size() == 1);
		CHECK(intersectionShape.size() == 1);
		CHECK(tolMax == Approx(0.0));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API BRepExtremaProximityTool(const TopoShape& shape1, const TopoShape& shape2)	 @param shape2 The second shape
	 @param shape1 The first shape
	 @brief Construct proximity tool from two shapes
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <modeling/MakeBox.hpp>
#include <modeling/MakeCylinder.hpp>
#include <topology/BRepExtremaProximityTool.hpp>
#include <io/OBJTool.hpp>
#include <topology/TopoFace.hpp>
#include <modeling/TransformShape.hpp>
#include <topology/TopoExplorerTool.hpp>
#include <modeling/MakeTorus.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
using namespace AMCAX;
using namespace std;
#include<catch.hpp>
#include<testHelper.h>
#include <modeling/MakeBox.hpp>
#include <modeling/MakeCylinder.hpp>
#include <topology/BRepExtremaProximityTool.hpp>
#include <io/OBJTool.hpp>
#include <topology/TopoFace.hpp>
#include <modeling/TransformShape.hpp>
#include <topology/TopoExplorerTool.hpp>
#include <modeling/MakeTorus.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
using namespace AMCAX;
using namespace std;
;
	SECTION("Edge to Edge")
	{
		tr1.SetTranslation(Point3(-1.0, 1.0, 0.0), Point3(0.0, 2.0, 0.0));
		TransformShape ts(shape1, tr1, false, false);
		BRepExtremaProximityTool proxTool(ts, shape2);
		bool r1 = proxTool.PerformOverlapFaces(overlapShape, tolerance);
		CHECK(r1 == false);
		CHECK(overlapShape.size() == 0);
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API BRepExtremaProximityTool()	 @brief Empty constructor for proximity tool
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <io/OBJTool.hpp>
#include <modeling/TransformShape.hpp>
#include <geometry/Geom3BezierCurve.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakePrism.hpp>
#include <topology/TopoTool.hpp>
#include <topology/TopoFace.hpp>
#include <geometry/GeometryTool.hpp>
#include <topology/BRepExtremaProximityTool.hpp>
#include <modeling/MakeBox.hpp>
#include <geometry/Geom3BSplineCurve.hpp>
#include <topology/TopoWire.hpp>
#include <modeling/MakeWire.hpp>
#include <offset/MakePipeShell.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
using namespace AMCAX;
using namespace std;
#include<catch.hpp>
#include<testHelper.h>
#include <io/OBJTool.hpp>
#include <modeling/TransformShape.hpp>
#include <geometry/Geom3BezierCurve.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakePrism.hpp>
#include <topology/TopoTool.hpp>
#include <topology/TopoFace.hpp>
#include <geometry/GeometryTool.hpp>
#include <topology/BRepExtremaProximityTool.hpp>
#include <modeling/MakeBox.hpp>
#include <geometry/Geom3BSplineCurve.hpp>
#include <topology/TopoWire.hpp>
#include <modeling/MakeWire.hpp>
#include <offset/MakePipeShell.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
using namespace AMCAX;
using namespace std;
;
	SECTION("Back translation=0.9*tolerance")
	{
		y = 0.0 + 0.9 * tolerance;
		tr1.SetTranslation(Point3(0.0, 0.0, 0.0), Point3(0.0, y, 0.0));
		TransformShape ts(shape2, tr1, false, false);
		BRepExtremaProximityTool proxTool(shape1, ts);
		bool r1 = proxTool.PerformOverlapFaces(overlapShape, tolerance);
		bool r2 = proxTool.PerformIntersectionFaces(intersectionShape, tolerance);
		bool r3 = proxTool.PerformProximityValue(tolMax);
		CHECK(r1 == true);
		CHECK(r2 == true);
		CHECK(r3 == true);
		CHECK(overlapShape.size() == 1);
		CHECK(intersectionShape.size() == 1);
		CHECK(tolMax == Approx(y));
		BRepExtremaDistShapeShape dist(shape1, ts);
		CHECK(dist.Value() < tolerance);
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API BRepExtremaProximityTool(const TopoShape& shape1, const TopoShape& shape2)	 @param shape2 The second shape
	 @param shape1 The first shape
	 @brief Construct proximity tool from two shapes
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <io/OBJTool.hpp>
#include <modeling/TransformShape.hpp>
#include <geometry/Geom3BezierCurve.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakePrism.hpp>
#include <topology/TopoTool.hpp>
#include <topology/TopoFace.hpp>
#include <geometry/GeometryTool.hpp>
#include <topology/BRepExtremaProximityTool.hpp>
#include <modeling/MakeBox.hpp>
#include <geometry/Geom3BSplineCurve.hpp>
#include <topology/TopoWire.hpp>
#include <modeling/MakeWire.hpp>
#include <offset/MakePipeShell.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
using namespace AMCAX;
using namespace std;
#include<catch.hpp>
#include<testHelper.h>
#include <io/OBJTool.hpp>
#include <modeling/TransformShape.hpp>
#include <geometry/Geom3BezierCurve.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakePrism.hpp>
#include <topology/TopoTool.hpp>
#include <topology/TopoFace.hpp>
#include <geometry/GeometryTool.hpp>
#include <topology/BRepExtremaProximityTool.hpp>
#include <modeling/MakeBox.hpp>
#include <geometry/Geom3BSplineCurve.hpp>
#include <topology/TopoWire.hpp>
#include <modeling/MakeWire.hpp>
#include <offset/MakePipeShell.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
using namespace AMCAX;
using namespace std;
;
	SECTION("param = 0.0")
	{
		param = 0.0;
		BRepExtremaProximityTool proxTool(shape1, shape2);
		bool r1 = proxTool.PerformOverlapFaces(overlapShape, param);
		CHECK(r1 == true);
		CHECK(overlapShape.size() == 1);
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API void LoadShapes(const TopoShape& shape1, const TopoShape& shape2)	 @param shape2 The second shape
	 @param shape1 The first shape
	 @brief Load the shape of proximity tool
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <io/OBJTool.hpp>
#include <modeling/TransformShape.hpp>
#include <geometry/Geom3BezierCurve.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakePrism.hpp>
#include <topology/TopoTool.hpp>
#include <topology/TopoFace.hpp>
#include <geometry/GeometryTool.hpp>
#include <topology/BRepExtremaProximityTool.hpp>
#include <modeling/MakeBox.hpp>
#include <geometry/Geom3BSplineCurve.hpp>
#include <topology/TopoWire.hpp>
#include <modeling/MakeWire.hpp>
#include <offset/MakePipeShell.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
using namespace AMCAX;
using namespace std;
#include<catch.hpp>
#include<testHelper.h>
#include <io/OBJTool.hpp>
#include <modeling/TransformShape.hpp>
#include <geometry/Geom3BezierCurve.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakePrism.hpp>
#include <topology/TopoTool.hpp>
#include <topology/TopoFace.hpp>
#include <geometry/GeometryTool.hpp>
#include <topology/BRepExtremaProximityTool.hpp>
#include <modeling/MakeBox.hpp>
#include <geometry/Geom3BSplineCurve.hpp>
#include <topology/TopoWire.hpp>
#include <modeling/MakeWire.hpp>
#include <offset/MakePipeShell.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
using namespace AMCAX;
using namespace std;
;
	SECTION("Left translation=1.0")
	{
		x = 0.0 - 1.0;
		tr1.SetTranslation(Point3(0.0, 0.0, 0.0), Point3(x, 0.0, 0.0));
		TransformShape ts(shape2, tr1, false, false);
		BRepExtremaProximityTool proxTool(shape1, ts);
		bool r1 = proxTool.PerformOverlapFaces(overlapShape, tolerance);
		bool r2 = proxTool.PerformIntersectionFaces(intersectionShape, tolerance);
		bool r3 = proxTool.PerformProximityValue(tolMax);
		CHECK(r1 == true);
		CHECK(r2 == true);
		CHECK(r3 == true);
		CHECK(overlapShape.size() == 1);
		CHECK(intersectionShape.size() == 1);
		CHECK(tolMax == Approx(-x));
		BRepExtremaDistShapeShape dist(shape1, ts);
		CHECK(dist.Value() < tolerance);
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API bool PerformOverlapFaces(std::vector<std::pair<TopoShape, TopoShape>>& facesInShape, const double tolerance = Precision::Confusion()	 @return true if two shape have overlapping faces
	 @param tolerance The horizontal tolerance used for check overlaping
	 @param facesInShape The couples of faces with overlapping areas
	 @brief Performs find faces of shape with finite overlapping areas
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <io/OBJTool.hpp>
#include <modeling/TransformShape.hpp>
#include <geometry/Geom3BezierCurve.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakePrism.hpp>
#include <topology/TopoTool.hpp>
#include <topology/TopoFace.hpp>
#include <geometry/GeometryTool.hpp>
#include <topology/BRepExtremaProximityTool.hpp>
#include <modeling/MakeBox.hpp>
#include <geometry/Geom3BSplineCurve.hpp>
#include <topology/TopoWire.hpp>
#include <modeling/MakeWire.hpp>
#include <offset/MakePipeShell.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
using namespace AMCAX;
using namespace std;
#include<catch.hpp>
#include<testHelper.h>
#include <io/OBJTool.hpp>
#include <modeling/TransformShape.hpp>
#include <geometry/Geom3BezierCurve.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakePrism.hpp>
#include <topology/TopoTool.hpp>
#include <topology/TopoFace.hpp>
#include <geometry/GeometryTool.hpp>
#include <topology/BRepExtremaProximityTool.hpp>
#include <modeling/MakeBox.hpp>
#include <geometry/Geom3BSplineCurve.hpp>
#include <topology/TopoWire.hpp>
#include <modeling/MakeWire.hpp>
#include <offset/MakePipeShell.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
using namespace AMCAX;
using namespace std;
;
	SECTION("param = 0.0")
	{
		param = 0.0;
		BRepExtremaProximityTool proxTool(shape1, shape2);
		bool r1 = proxTool.PerformOverlapFaces(overlapShape, param);
		CHECK(r1 == true);
		CHECK(overlapShape.size() == 1);
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API bool PerformIntersectionFaces(std::vector<std::pair<TopoShape, TopoShape>>& facesInShape, const double tolerance = Precision::Confusion()	 @return true if two shape have intersecting faces
	 @param tolerance The tolerance used for check intersection
	 @param facesInShape The couple of faces which intersect with each other
	 @brief Performs find intersecting faces of shape
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <io/OBJTool.hpp>
#include <modeling/TransformShape.hpp>
#include <geometry/Geom3BezierCurve.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakePrism.hpp>
#include <topology/TopoTool.hpp>
#include <topology/TopoFace.hpp>
#include <geometry/GeometryTool.hpp>
#include <topology/BRepExtremaProximityTool.hpp>
#include <modeling/MakeBox.hpp>
#include <geometry/Geom3BSplineCurve.hpp>
#include <topology/TopoWire.hpp>
#include <modeling/MakeWire.hpp>
#include <offset/MakePipeShell.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
using namespace AMCAX;
using namespace std;
#include<catch.hpp>
#include<testHelper.h>
#include <io/OBJTool.hpp>
#include <modeling/TransformShape.hpp>
#include <geometry/Geom3BezierCurve.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakePrism.hpp>
#include <topology/TopoTool.hpp>
#include <topology/TopoFace.hpp>
#include <geometry/GeometryTool.hpp>
#include <topology/BRepExtremaProximityTool.hpp>
#include <modeling/MakeBox.hpp>
#include <geometry/Geom3BSplineCurve.hpp>
#include <topology/TopoWire.hpp>
#include <modeling/MakeWire.hpp>
#include <offset/MakePipeShell.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
using namespace AMCAX;
using namespace std;
;
	SECTION("Back translation=0.9*tolerance")
	{
		y = 0.0 + 0.9 * tolerance;
		tr1.SetTranslation(Point3(0.0, 0.0, 0.0), Point3(0.0, y, 0.0));
		TransformShape ts(shape2, tr1, false, false);
		BRepExtremaProximityTool proxTool(shape1, ts);
		bool r1 = proxTool.PerformOverlapFaces(overlapShape, tolerance);
		bool r2 = proxTool.PerformIntersectionFaces(intersectionShape, tolerance);
		bool r3 = proxTool.PerformProximityValue(tolMax);
		CHECK(r1 == true);
		CHECK(r2 == true);
		CHECK(r3 == true);
		CHECK(overlapShape.size() == 1);
		CHECK(intersectionShape.size() == 1);
		CHECK(tolMax == Approx(y));
		BRepExtremaDistShapeShape dist(shape1, ts);
		CHECK(dist.Value() < tolerance);
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API bool PerformProximityValue(double& hdProxDistance)	 @return true if perform successfully
	 @param hdProxDistance The result approximate hausdorff distance
	 @details The hausdorff distance H(S1, S2) = max(maxmin||S1 - S2||, maxmin||S2 - S1||);
	 @brief Compute the approximate hausdorff distance with two shape
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <io/OBJTool.hpp>
#include <modeling/TransformShape.hpp>
#include <geometry/Geom3BezierCurve.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakePrism.hpp>
#include <topology/TopoTool.hpp>
#include <topology/TopoFace.hpp>
#include <geometry/GeometryTool.hpp>
#include <topology/BRepExtremaProximityTool.hpp>
#include <modeling/MakeBox.hpp>
#include <geometry/Geom3BSplineCurve.hpp>
#include <topology/TopoWire.hpp>
#include <modeling/MakeWire.hpp>
#include <offset/MakePipeShell.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
using namespace AMCAX;
using namespace std;
#include<catch.hpp>
#include<testHelper.h>
#include <io/OBJTool.hpp>
#include <modeling/TransformShape.hpp>
#include <geometry/Geom3BezierCurve.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakePrism.hpp>
#include <topology/TopoTool.hpp>
#include <topology/TopoFace.hpp>
#include <geometry/GeometryTool.hpp>
#include <topology/BRepExtremaProximityTool.hpp>
#include <modeling/MakeBox.hpp>
#include <geometry/Geom3BSplineCurve.hpp>
#include <topology/TopoWire.hpp>
#include <modeling/MakeWire.hpp>
#include <offset/MakePipeShell.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
using namespace AMCAX;
using namespace std;
;
	SECTION("Back translation=0.0")
	{
		BRepExtremaProximityTool proxTool(shape1, shape2);
		bool r1 = proxTool.PerformOverlapFaces(overlapShape, tolerance);
		bool r2 = proxTool.PerformIntersectionFaces(intersectionShape, tolerance);
		bool r3 = proxTool.PerformProximityValue(tolMax);
		CHECK(r1 == true);
		CHECK(r2 == true);
		CHECK(r3 == true);
		CHECK(overlapShape.size() == 1);
		CHECK(intersectionShape.size() == 1);
		CHECK(tolMax == Approx(0.0));
		BRepExtremaDistShapeShape dist(shape1, shape2);
		CHECK(dist.Value() < tolerance);
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API BoolBRepCut()	 @details Only set the type of boolean operation to cut
	 @brief Default constructor
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <boolean/BoolBRepCut.hpp>
#include <modeling/MakeTorus.hpp>
#include <modeling/MakeSphere.hpp>
#include <modeling/MakeCone.hpp>
#include <topology/TopoExplorer.hpp>
#include <topology/TopoFace.hpp>
#include <hatch/BRepClassificationTools.hpp>
using namespace AMCAX;
TEST_CASE("bug1: in Debug mode: BoolBuilder  ", "[boolean][BoolBRepCut][P1][fixbug]") {
	TopoShape torus = MakeTorus(Frame3(Point3(0.0, 0.0, 2.0), Direction3(1.0, 0.0, 0.0)), 4.0, 2.0);
	TopoShape sphere = MakeSphere(4.0);
	TopoShape result = BoolBRepCut(sphere, torus);
	AMCAX::GlobalProperty prop;
	AMCAX::BRepGlobalProperty::VolumeProperties(result, prop);
	CHECK(prop.Mass() == Approx(153.229)); 
	bool isWriteSuccess = AMCAX::OCCTIO::OCCTTool::Write(result, OUTPUT_PATH_PREFIX"BoolBRepCut_bug72.brep", false);
	CHECK(isWriteSuccess == true);
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API BoolBRepCut(const TopoShape& s1, const TopoShape& s2, bool isForward = true)	 @param isForward Cut s1 by s2 if true, and cut s2 by s1 if false
	 @param s2 The tool shape
	 @param s1 The argument shape
	 @brief Compute the cut operation of two shapes
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <boolean/BoolBRepCut.hpp>
#include <modeling/MakeTorus.hpp>
#include <modeling/MakeSphere.hpp>
#include <modeling/MakeCone.hpp>
#include <topology/TopoExplorer.hpp>
#include <topology/TopoFace.hpp>
#include <hatch/BRepClassificationTools.hpp>
using namespace AMCAX;
TEST_CASE("bug1: in Debug mode: BoolBuilder  ", "[boolean][BoolBRepCut][P1][fixbug]") {
	TopoShape torus = MakeTorus(Frame3(Point3(0.0, 0.0, 2.0), Direction3(1.0, 0.0, 0.0)), 4.0, 2.0);
	TopoShape sphere = MakeSphere(4.0);
	TopoShape result = BoolBRepCut(sphere, torus);
	AMCAX::GlobalProperty prop;
	AMCAX::BRepGlobalProperty::VolumeProperties(result, prop);
	CHECK(prop.Mass() == Approx(153.229)); 
	bool isWriteSuccess = AMCAX::OCCTIO::OCCTTool::Write(result, OUTPUT_PATH_PREFIX"BoolBRepCut_bug72.brep", false);
	CHECK(isWriteSuccess == true);
}
}
,