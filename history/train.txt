{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "void SetRadius(double r)\t @param r The radius\n\t @brief Set the radius of the circle\n",
 "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <geomAlgo/GccCircle3Tangent.hpp>\n#include <geometry/Geom2Curve.hpp>\n#include <geometry/MakeGeom2Line.hpp>\n#include <geometry/MakeGeom2Circle.hpp>\n#include <geomAlgo/GccEntity.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geomAlgo/GccQualifiedCurve.hpp>\n\nTEST_CASE(\"SetRadius Test\") {\n\tCircleS circle;\n\tcircle.SetRadius(5.0);\n\tCHECK(circle.Radius() == 5.0);\n}"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] double Radius()\t @return The radius\n\t @brief Get the radius\n",
 "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <geomAlgo/GccCircle3Tangent.hpp>\n#include <geometry/Geom2Curve.hpp>\n#include <geometry/MakeGeom2Line.hpp>\n#include <geometry/MakeGeom2Circle.hpp>\n#include <geomAlgo/GccEntity.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geomAlgo/GccQualifiedCurve.hpp>\n\nTEST_CASE(\"Radius Test\") {\n\tCircleS circle;\n\tcircle.SetRadius(3.0);\n\tCHECK(circle.Radius() == 3.0);\n}"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] double Length()\t @return The length of the circle\n\t @brief Get the length of the circle\n",
 "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <geomAlgo/GccCircle3Tangent.hpp>\n#include <geometry/Geom2Curve.hpp>\n#include <geometry/MakeGeom2Line.hpp>\n#include <geometry/MakeGeom2Circle.hpp>\n#include <geomAlgo/GccEntity.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geomAlgo/GccQualifiedCurve.hpp>\n\nTEST_CASE(\"Length Test\") {\n\tCircleS circle;\n\tcircle.SetRadius(2.0);\n\tCHECK(circle.Length() == 2 * 3.14159);\n}"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] double Distance(const PointT<double, DIM>& p)\t @return The distance from the point to the circle\n\t @param p The point\n\t @brief Compute the distance from a point to the circle\n",
 "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <geomAlgo/GccCircle3Tangent.hpp>\n#include <geometry/Geom2Curve.hpp>\n#include <geometry/MakeGeom2Line.hpp>\n#include <geometry/MakeGeom2Circle.hpp>\n#include <geomAlgo/GccEntity.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geomAlgo/GccQualifiedCurve.hpp>\n\nTEST_CASE(\"Distance Test\") {\n\tCircleS circle;\n\tcircle.SetRadius(5.0);\n\tPointT<double, 2> point(0.0, 0.0);\n\tCHECK(circle.Distance(point) == 5.0);\n}"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] double SquaredDistance(const PointT<double, DIM>& p)\t @return The squared distance from the point to the circle\n\t @param p The point\n\t @brief Compute the squared distance from a point to the circle\n",
 "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <geomAlgo/GccCircle3Tangent.hpp>\n#include <geometry/Geom2Curve.hpp>\n#include <geometry/MakeGeom2Line.hpp>\n#include <geometry/MakeGeom2Circle.hpp>\n#include <geomAlgo/GccEntity.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geomAlgo/GccQualifiedCurve.hpp>\n\nTEST_CASE(\"SquaredDistance Test\") {\n\tCircleS circle;\n\tcircle.SetRadius(3.0);\n\tPointT<double, 2> point(0.0, 0.0);\n\tCHECK(circle.SquaredDistance(point) == 9.0);\n}"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "CircleS& Scale(const PointT<double, DIM>& p, double scale)\t @return The reference to self\n\t @param scale The scale value\n\t @param p The scaling center point\n\t @brief Scale the circle by a center point\n",
 "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <geomAlgo/GccCircle3Tangent.hpp>\n#include <geometry/Geom2Curve.hpp>\n#include <geometry/MakeGeom2Line.hpp>\n#include <geometry/MakeGeom2Circle.hpp>\n#include <geomAlgo/GccEntity.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geomAlgo/GccQualifiedCurve.hpp>\n\nTEST_CASE(\"Scale Test\") {\n\tCircleS circle;\n\tcircle.SetRadius(2.0);\n\tcircle.Scale(PointT<double, 2>(1.0, 1.0), 2.0);\n\tCHECK(circle.Radius() == 4.0);\n}"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "CircleS& Transform(const TransformationT<double, DIM>& tr)\t @return The reference to self\n\t @param tr The transformation\n\t @brief Transform the circle\n",
 "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <geomAlgo/GccCircle3Tangent.hpp>\n#include <geometry/Geom2Curve.hpp>\n#include <geometry/MakeGeom2Line.hpp>\n#include <geometry/MakeGeom2Circle.hpp>\n#include <geomAlgo/GccEntity.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geomAlgo/GccQualifiedCurve.hpp>\n\nTEST_CASE(\"Transform Test\") {\n\tCircleS circle;\n\tcircle.SetRadius(2.0);\n\tTransformationT<double, 2> transformation; // assume this is defined\n\tcircle.Transform(transformation);\n\t// Check some properties of the transformed circle\n}"} {"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "void SetRadius(double r)\t @param r The radius\n\t @brief Set the radius of the circle\n",
 "output": "#include<catch.hpp>\n#include<testHelper.h>\n\n#include <common/VectorT.hpp>\n#include <common/PointT.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/MakeArcOfCircle2d.hpp>\n#include <sstream>\n\nusing namespace AMCAX;\n\n\n\nTEST_CASE(\"bug1: MakeArcOfCircle2d http://192.168.2.72:8080/bug-view-63.html add 1 cases\", \"[geomAlgo][MakeArcOfCircle2d][fixbug]\") \n\t\n\tstd::stringstream output;\n\tstd::shared_ptr<Geom2TrimmedCurve> c = MakeArcOfCircle2d(Point2(0.0, 1.0), Vector2(1.0, 0.0), Point2(1.0, 0.0));\n\tstd::cout << *c << std::endl;\n\toutput << *c << std::endl;\n\n\tauto case1 = output.str();\n\tauto expect1 = \"8 4.71239 6.28319\";\n\tauto expect2 = \"2 0 -0 1 0 0 -1 1\";\n\tCHECK(case1.find(expect1) != std::string::npos);\n\tCHECK(case1.find(expect2) != std::string::npos);\n\n\n\n\n"}
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] double Radius()\t @return The radius\n\t @brief Get the radius\n",
 "output": "#include<catch.hpp>\n#include<testHelper.h>\n\n#include <common/VectorT.hpp>\n#include <common/PointT.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/MakeArcOfCircle2d.hpp>\n#include <sstream>\n\nusing namespace AMCAX;\n\n\n\nTEST_CASE(\"bug1: MakeArcOfCircle2d http://192.168.2.72:8080/bug-view-63.html add 1 cases\", \"[geomAlgo][MakeArcOfCircle2d][fixbug]\") \n\t\n\tstd::stringstream output;\n\tstd::shared_ptr<Geom2TrimmedCurve> c = MakeArcOfCircle2d(Point2(0.0, 1.0), Vector2(1.0, 0.0), Point2(1.0, 0.0));\n\tstd::cout << *c << std::endl;\n\toutput << *c << std::endl;\n\n\tauto case1 = output.str();\n\tauto expect1 = \"8 4.71239 6.28319\";\n\tauto expect2 = \"2 0 -0 1 0 0 -1 1\";\n\tCHECK(case1.find(expect1) != std::string::npos);\n\tCHECK(case1.find(expect2) != std::string::npos);\n\n\n\n\n"}
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] double Length()\t @return The length of the circle\n\t @brief Get the length of the circle\n",
 "output": "#include<catch.hpp>\n#include<testHelper.h>\n\n#include <common/VectorT.hpp>\n#include <common/PointT.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/MakeArcOfCircle2d.hpp>\n#include <sstream>\n\nusing namespace AMCAX;\n\n\n\nTEST_CASE(\"bug1: MakeArcOfCircle2d http://192.168.2.72:8080/bug-view-63.html add 1 cases\", \"[geomAlgo][MakeArcOfCircle2d][fixbug]\") \n\t\n\tstd::stringstream output;\n\tstd::shared_ptr<Geom2TrimmedCurve> c = MakeArcOfCircle2d(Point2(0.0, 1.0), Vector2(1.0, 0.0), Point2(1.0, 0.0));\n\tstd::cout << *c << std::endl;\n\toutput << *c << std::endl;\n\n\tauto case1 = output.str();\n\tauto expect1 = \"8 4.71239 6.28319\";\n\tauto expect2 = \"2 0 -0 1 0 0 -1 1\";\n\tCHECK(case1.find(expect1) != std::string::npos);\n\tCHECK(case1.find(expect2) != std::string::npos);\n\n\n\n\n"}
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] double Distance(const PointT<double, DIM>& p)\t @return The distance from the point to the circle\n\t @param p The point\n\t @brief Compute the distance from a point to the circle\n",
 "output": "#include<catch.hpp>\n#include<testHelper.h>\n\n#include <common/VectorT.hpp>\n#include <common/PointT.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/MakeArcOfCircle2d.hpp>\n#include <sstream>\n\nusing namespace AMCAX;\n\n\n\nTEST_CASE(\"bug1: MakeArcOfCircle2d http://192.168.2.72:8080/bug-view-63.html add 1 cases\", \"[geomAlgo][MakeArcOfCircle2d][fixbug]\") \n\t\n\tstd::stringstream output;\n\tstd::shared_ptr<Geom2TrimmedCurve> c = MakeArcOfCircle2d(Point2(0.0, 1.0), Vector2(1.0, 0.0), Point2(1.0, 0.0));\n\tstd::cout << *c << std::endl;\n\toutput << *c << std::endl;\n\n\tauto case1 = output.str();\n\tauto expect1 = \"8 4.71239 6.28319\";\n\tauto expect2 = \"2 0 -0 1 0 0 -1 1\";\n\tCHECK(case1.find(expect1) != std::string::npos);\n\tCHECK(case1.find(expect2) != std::string::npos);\n\n\n\n\n"}
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] double SquaredDistance(const PointT<double, DIM>& p)\t @return The squared distance from the point to the circle\n\t @param p The point\n\t @brief Compute the squared distance from a point to the circle\n",
 "output": "#include<catch.hpp>\n#include<testHelper.h>\n\n#include <common/VectorT.hpp>\n#include <common/PointT.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/MakeArcOfCircle2d.hpp>\n#include <sstream>\n\nusing namespace AMCAX;\n\n\n\nTEST_CASE(\"bug1: MakeArcOfCircle2d http://192.168.2.72:8080/bug-view-63.html add 1 cases\", \"[geomAlgo][MakeArcOfCircle2d][fixbug]\") \n\t\n\tstd::stringstream output;\n\tstd::shared_ptr<Geom2TrimmedCurve> c = MakeArcOfCircle2d(Point2(0.0, 1.0), Vector2(1.0, 0.0), Point2(1.0, 0.0));\n\tstd::cout << *c << std::endl;\n\toutput << *c << std::endl;\n\n\tauto case1 = output.str();\n\tauto expect1 = \"8 4.71239 6.28319\";\n\tauto expect2 = \"2 0 -0 1 0 0 -1 1\";\n\tCHECK(case1.find(expect1) != std::string::npos);\n\tCHECK(case1.find(expect2) != std::string::npos);\n\n\n\n\n"}
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "CircleS& Scale(const PointT<double, DIM>& p, double scale)\t @return The reference to self\n\t @param scale The scale value\n\t @param p The scaling center point\n\t @brief Scale the circle by a center point\n",
 "output": "#include<catch.hpp>\n#include<testHelper.h>\n\n#include <common/VectorT.hpp>\n#include <common/PointT.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/MakeArcOfCircle2d.hpp>\n#include <sstream>\n\nusing namespace AMCAX;\n\n\n\nTEST_CASE(\"bug1: MakeArcOfCircle2d http://192.168.2.72:8080/bug-view-63.html add 1 cases\", \"[geomAlgo][MakeArcOfCircle2d][fixbug]\") \n\t\n\tstd::stringstream output;\n\tstd::shared_ptr<Geom2TrimmedCurve> c = MakeArcOfCircle2d(Point2(0.0, 1.0), Vector2(1.0, 0.0), Point2(1.0, 0.0));\n\tstd::cout << *c << std::endl;\n\toutput << *c << std::endl;\n\n\tauto case1 = output.str();\n\tauto expect1 = \"8 4.71239 6.28319\";\n\tauto expect2 = \"2 0 -0 1 0 0 -1 1\";\n\tCHECK(case1.find(expect1) != std::string::npos);\n\tCHECK(case1.find(expect2) != std::string::npos);\n\n\n\n\n"}
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "CircleS& Transform(const TransformationT<double, DIM>& tr)\t @return The reference to self\n\t @param tr The transformation\n\t @brief Transform the circle\n",
 "output": "#include<catch.hpp>\n#include<testHelper.h>\n\n#include <common/VectorT.hpp>\n#include <common/PointT.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/MakeArcOfCircle2d.hpp>\n#include <sstream>\n\nusing namespace AMCAX;\n\n\n\nTEST_CASE(\"bug1: MakeArcOfCircle2d http://192.168.2.72:8080/bug-view-63.html add 1 cases\", \"[geomAlgo][MakeArcOfCircle2d][fixbug]\") \n\t\n\tstd::stringstream output;\n\tstd::shared_ptr<Geom2TrimmedCurve> c = MakeArcOfCircle2d(Point2(0.0, 1.0), Vector2(1.0, 0.0), Point2(1.0, 0.0));\n\tstd::cout << *c << std::endl;\n\toutput << *c << std::endl;\n\n\tauto case1 = output.str();\n\tauto expect1 = \"8 4.71239 6.28319\";\n\tauto expect2 = \"2 0 -0 1 0 0 -1 1\";\n\tCHECK(case1.find(expect1) != std::string::npos);\n\tCHECK(case1.find(expect2) != std::string::npos);\n\n\n\n\n"}{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "void SetRadius(double r)\t @param r The radius\n\t @brief Set the radius of the circle\n",
 "output": "#include<catch.hpp>\n#include \"testHelper.h\"\n#include<iostream>\n#include <math/CircleT.hpp>\n#include <common/AxisT.hpp>\n#include <common/PointT.hpp>\n\nTEST_CASE(\"case1: create a Circle\", \"[math][CircleT][P1]\") \n\n\tAMCAX::Point2 P(0.0,0.0);\n\tAMCAX::Direction2 D(1.0,0.0);\n\tAMCAX::Axis2  axis2(P, D);\n\tfloat radius = 5.0f;\n\tAMCAX::Circle2 circle2(axis2, radius, true);\n\tCHECK(circle2.Area() == radius * radius * M_PI);\n    double a, b, c, d, e, f;\n    circle2.Coefficients(a, b, c, d, e, f);  //test Coefficients()\n    ..."},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] double Radius()\t @return The radius\n\t @brief Get the radius\n",
 "output": "#include<catch.hpp>\n#include \"testHelper.h\"\n#include<iostream>\n#include <math/CircleT.hpp>\n#include <common/AxisT.hpp>\n#include <common/PointT.hpp>\n\nTEST_CASE(\"CircleT Constructor Test\", \"[math][CircleT][P1]\") \n    SECTION(\"2D Circle Construction\") \n        AMCAX::Circle2 circle2;\n        constexpr double maxr = std::numeric_limits<double>::max();\n        CHECK(circle2.Radius() == Approx(maxr).epsilon(1e-15));\n        ..."},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] double Length()\t @return The length of the circle\n\t @brief Get the length of the circle\n",
 "output": "#include<catch.hpp>\n#include \"testHelper.h\"\n#include<iostream>\n#include <math/CircleT.hpp>\n#include <common/AxisT.hpp>\n#include <common/PointT.hpp>\n\nTEST_CASE(\"CircleT Area and Length Test\", \"[CircleT]\") \n    AMCAX::Circle2 circle2;\n    circle2.SetRadius(5.0);\n    CHECK(circle2.Area() == Approx(78.53982));\n    CHECK(circle2.Length() == Approx(31.41593));\n    ..."},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] double Distance(const PointT<double, DIM>& p)\t @return The distance from the point to the circle\n\t @param p The point\n\t @brief Compute the distance from a point to the circle\n",
 "output": "#include<catch.hpp>\n#include \"testHelper.h\"\n#include<iostream>\n#include <math/CircleT.hpp>\n#include <common/AxisT.hpp>\n#include <common/PointT.hpp>\n\nTEST_CASE(\"case1: create a Circle with Distance\", \"[math][CircleT][P1]\") \n\tAMCAX::Point2 P(0.0,0.0);\n\tAMCAX::Circle2 circle2;\n\tcircle2.SetRadius(5.0);\n\tCHECK(circle2.Distance(P) == Approx(5.0).epsilon(1e-15));\n    ..."},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] double SquaredDistance(const PointT<double, DIM>& p)\t @return The squared distance from the point to the circle\n\t @param p The point\n\t @brief Compute the squared distance from a point to the circle\n",
 "output": "#include<catch.hpp>\n#include \"testHelper.h\"\n#include<iostream>\n#include <math/CircleT.hpp>\n#include <common/AxisT.hpp>\n#include <common/PointT.hpp>\n\nTEST_CASE(\"case1: create a Circle with Squared Distance\", \"[math][CircleT][P1]\") \n\tAMCAX::Point2 P(0.0,0.0);\n\tAMCAX::Circle2 circle2;\n\tcircle2.SetRadius(5.0);\n\tCHECK(circle2.SquaredDistance(P) == Approx(25.0).epsilon(1e-15));\n    ..."},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "CircleS& Scale(const PointT<double, DIM>& p, double scale)\t @return The reference to self\n\t @param scale The scale value\n\t @param p The scaling center point\n\t @brief Scale the circle by a center point\n",
 "output": "#include<catch.hpp>\n#include \"testHelper.h\"\n#include<iostream>\n#include <math/CircleT.hpp>\n#include <common/AxisT.hpp>\n#include <common/PointT.hpp>\n\nTEST_CASE(\"case1: Scale Circle\", \"[math][CircleT][P1]\") \n\tAMCAX::Circle2 circle;\n\tcircle.SetRadius(5.0);\n\tAMCAX::Point2 center(0.0, 0.0);\n\tcircle.Scale(center, 2.0);\n\tCHECK(circle.Radius() == Approx(10.0).epsilon(1e-15));\n    ..."},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "CircleS& Transform(const TransformationT<double, DIM>& tr)\t @return The reference to self\n\t @param tr The transformation\n\t @brief Transform the circle\n",
 "output": "#include<catch.hpp>\n#include \"testHelper.h\"\n#include<iostream>\n#include <math/CircleT.hpp>\n#include <common/AxisT.hpp>\n#include <common/PointT.hpp>\n\nTEST_CASE(\"case1: Transform Circle\", \"[math][CircleT][P1]\") \n\tAMCAX::Circle2 circle;\n\tcircle.SetRadius(5.0);\n\tTransformationT<double, 2> transformation;\n\tcircle.Transform(transformation);\n\t..."}{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "void SetRadius(double r)\t @param r The radius\n\t @brief Set the radius of the circle\n[[nodiscard]] double Radius()\t @return The radius\n\t @brief Get the radius\n",
 "output": "#include <math/CircleT.hpp>\n#include <common/CoordT.hpp>\n#include <common/TransformationType.hpp>\n#include <common/DirectionT.hpp>\n#include <common/PointT.hpp>\n#include <common/Precision.hpp>\n#include <iostream>\n#include \"catch.hpp\"\n\nusing namespace std;\n\nTEST_CASE(\"TestCircle2D\", \"[math][Circle2D]\") {\n\tAMCAX::CircleT<double, 2> circle2D;\n\tcircle2D.SetRadius(5.0);\n\tCHECK(circle2D.Radius() == 5.0);\n}"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] double Length()\t @return The length of the circle\n\t @brief Get the length of the circle\n",
 "output": "#include <math/CircleT.hpp>\n#include <common/CoordT.hpp>\n#include <common/TransformationType.hpp>\n#include <common/DirectionT.hpp>\n#include <common/PointT.hpp>\n#include <common/Precision.hpp>\n#include <iostream>\n#include \"catch.hpp\"\n\nusing namespace std;\n\nTEST_CASE(\"TestCircleLength\", \"[math][Circle]\") {\n\tAMCAX::CircleT<double, 2> circle2D;\n\tcircle2D.SetRadius(5.0);\n\tCHECK(circle2D.Length() == Approx(31.4159));\n}"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] double Distance(const PointT<double, DIM>& p)\t @return The distance from the point to the circle\n\t @param p The point\n\t @brief Compute the distance from a point to the circle\n",
 "output": "#include <math/CircleT.hpp>\n#include <common/CoordT.hpp>\n#include <common/TransformationType.hpp>\n#include <common/DirectionT.hpp>\n#include <common/PointT.hpp>\n#include <common/Precision.hpp>\n#include <iostream>\n#include \"catch.hpp\"\n\nusing namespace std;\n\nTEST_CASE(\"TestCircleDistance\", \"[math][Circle]\") {\n\tAMCAX::CircleT<double, 2> circle2D;\n\tAMCAX::PointT<double, 2> point(3.0, 4.0);\n\tcircle2D.SetRadius(5.0);\n\tCHECK(circle2D.Distance(point) == Approx(1.0));\n}"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] double SquaredDistance(const PointT<double, DIM>& p)\t @return The squared distance from the point to the circle\n\t @param p The point\n\t @brief Compute the squared distance from a point to the circle\n",
 "output": "#include <math/CircleT.hpp>\n#include <common/CoordT.hpp>\n#include <common/TransformationType.hpp>\n#include <common/DirectionT.hpp>\n#include <common/PointT.hpp>\n#include <common/Precision.hpp>\n#include <iostream>\n#include \"catch.hpp\"\n\nusing namespace std;\n\nTEST_CASE(\"TestCircleSquaredDistance\", \"[math][Circle]\") {\n\tAMCAX::CircleT<double, 2> circle2D;\n\tAMCAX::PointT<double, 2> point(3.0, 4.0);\n\tcircle2D.SetRadius(5.0);\n\tCHECK(circle2D.SquaredDistance(point) == Approx(1.0));\n}"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "CircleS& Scale(const PointT<double, DIM>& p, double scale)\t @return The reference to self\n\t @param scale The scale value\n\t @param p The scaling center point\n\t @brief Scale the circle by a center point\n",
 "output": "#include <math/CircleT.hpp>\n#include <common/CoordT.hpp>\n#include <common/TransformationType.hpp>\n#include <common/DirectionT.hpp>\n#include <common/PointT.hpp>\n#include <common/Precision.hpp>\n#include <iostream>\n#include \"catch.hpp\"\n\nusing namespace std;\n\nTEST_CASE(\"TestCircleScale\", \"[math][Circle]\") {\n\tAMCAX::CircleT<double, 2> circle2D;\n\tAMCAX::PointT<double, 2> center(0.0, 0.0);\n\tcircle2D.SetRadius(5.0);\n\tcircle2D.Scale(center, 2.0);\n\tCHECK(circle2D.Radius() == Approx(10.0));\n}"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "CircleS& Transform(const TransformationT<double, DIM>& tr)\t @return The reference to self\n\t @param tr The transformation\n\t @brief Transform the circle\n",
 "output": "#include <math/CircleT.hpp>\n#include <common/CoordT.hpp>\n#include <common/TransformationType.hpp>\n#include <common/DirectionT.hpp>\n#include <common/PointT.hpp>\n#include <common/Precision.hpp>\n#include <iostream>\n#include \"catch.hpp\"\n\nusing namespace std;\n\nTEST_CASE(\"TestCircleTransform\", \"[math][Circle\") {\n\tAMCAX::CircleT<double, 2> circle2D;\n\tcircle2D.SetRadius(5.0);\n\tTransformationT<double, 2> transform;\n\tcircle2D.Transform(transform);\n\t// Add checks for transformed circle properties\n}"}{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "AMCAX_API Classifier2d(const std::vector<Point2>& pts, double tolU, double tolV, double uMin, double vMin, double uMax, double vMax)\t @param vMax The upper bound of v\n\t @param uMax The upper bound of u\n\t @param vMin The lower bound of v\n\t @param uMin The lower bound of u\n\t @param tolV The tolerance of v bound\n\t @param tolU The tolerance of u bound\n\t @param pts The points of a 2D closed polygon, the last point does not required to repeat the first point\n\t @details Require uMax > uMin, vMax > vMin, and at least 3 points\n\t @brief Construct from a 2D polygon and uv-bounds",
 "output": "#include<catch.hpp>\n#include<testHelper.h>\n\n#include <common/PointT.hpp>\n#include <math/Classifier2d.hpp>\n\nusing namespace AMCAX;\n\nTEST_CASE(\"case1: Classifier2d \", \"[math][Classifier2d][P1]\") \n\n    std::vector<Point2> pts = \n        Point2(2.0, 0.0),\n        Point2(1.0, 1.0),\n        Point2(2.0, 2.0),\n        Point2(3.0, 2.0)\n    ;\n\n    double tolU = 0.1;\n    double tolV = 0.1;\n    double uMin = 0.0;\n    double vMin = 0.0;\n    double uMax = 2.5;\n    double vMax = 1.5;\n\n    Classifier2d classifier(pts, tolU, tolV, uMin, vMin, uMax, vMax);\n\n    SECTION(\"IsInOut Point normal set\") \n        CHECK(classifier.IsInOut(Point2(0.0, 0.0)) == -1);\n        CHECK(classifier.IsInOut(Point2(1.0, 1.0)) == 0);\n        CHECK(classifier.IsInOut(Point2(2.0, 1.0)) == 1);\n    \n\n    SECTION(\"IsInOut Point normal set2 \") \n        CHECK(classifier.IsInOut(Point2(2.5, 1.9)) == -1);\n        CHECK(classifier.IsInOut(Point2(1.5, 0.5)) == 0);\n        CHECK(classifier.IsInOut(Point2(1.5, 1.0)) == 1);\n        CHECK(classifier.IsInOut(Point2(2.0, 1.5)) == 1);\n    \n\nTEST_CASE(\"case2: Classifier2d \", \"[math][Classifier2d][P1]\") \n\n    std::vector<Point2> pts = \n        Point2(1.0, -2.0),\n        Point2(1.0, 2.0),\n        Point2(3.0, 1.0),\n        Point2(3.0, -1.0)\n    ;\n\n    double tolU = 0.1;\n    double tolV = 0.1;\n    double uMin = 2.0;\n    double vMin = -2.0;\n    double uMax = 4.0;\n    double vMax =  2.0;\n\n    Classifier2d classifier(pts, tolU, tolV, uMin, vMin, uMax, vMax);\n\n    SECTION(\"IsInOut Point normal set\") \n        CHECK(classifier.IsInOut(Point2(1.0, 2.0)) == -1);\n        CHECK(classifier.IsInOut(Point2(1.5, 1.0)) == -1);\n        CHECK(classifier.IsInOut(Point2(1.9, -1.6)) == 0);\n        CHECK(classifier.IsInOut(Point2(2.5, -1.0)) == 1);\n    \n\n    SECTION(\"IsInOut Point normal set2 \") \n        CHECK(classifier.IsInOut(Point2(-0.5, -0.6)) == -1);\n        CHECK(classifier.IsInOut(Point2(4.5, -0.4)) == -1);\n        CHECK(classifier.IsInOut(Point2(3.0, -0.0)) == 0);\n        CHECK(classifier.IsInOut(Point2(2.0,-0.0)) == 1);\n        CHECK(classifier.IsInOut(Point2(2.8,-0.90)) == 1);\n    \n\nTEST_CASE(\"case3: Classifier2d \", \"[math][Classifier2d][P1\") \n\n    std::vector<Point2> pts = \n        Point2(2.0, 0.0),\n        Point2(1.0, 1.0),\n        Point2(2.0, 2.0),\n        Point2(3.0, 2.0)\n    ;\n\n    double tolU = 0.1;\n    double tolV = 0.1;\n    double uMin = 0.0;\n    double vMin = 0.0;\n    double uMax = 2.5;\n    double vMax = 1.5;\n\n    Classifier2d classifier(pts, tolU, tolV, uMin, vMin, uMax, vMax);\n\n    SECTION(\"IsInOutOn Point normal set\") \n        CHECK(classifier.IsInOutOn(Point2(0.0, 0.0), 0.0) == -1);\n        CHECK(classifier.IsInOutOn(Point2(1.0, 1.0), 0.0) != 0);\n        CHECK(classifier.IsInOutOn(Point2(1.0, 1.0), 1.0) == 0);\n        CHECK(classifier.IsInOutOn(Point2(2.0, 1.0), 0.0) == 1);\n    \n\n    SECTION(\"IsInOutOn Point normal set2 \") \n        CHECK(classifier.IsInOutOn(Point2(2.5, 1.9), 0.3) == -1);\n        CHECK(classifier.IsInOutOn(Point2(1.5, 0.5), 0.0) != 0);\n        CHECK(classifier.IsInOutOn(Point2(1.5, 1.0), 1.0) == 1);\n        CHECK(classifier.IsInOutOn(Point2(2.0, 1.5), 0.0) == 1);\n    \n"}{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] AMCAX_API Point3 Apex()\t @return The apex point\n\t @brief Get the apex of the cone",
 "output": "#include<iostream>\n#include \"catch.hpp\"\n#include <common/FrameT.hpp>\n#include <modeling/MakeFace.hpp>\n#include <common/AxisT.hpp>\n#include <common/FrameT.hpp>\n#include <common/VectorT.hpp>\n#include <math/Cone.hpp>\nusing namespace AMCAX;\nusing namespace std;\n\nTEST_CASE(\"TestCone\", \"[math][Cone]\")\n\n\tAMCAX::Frame3 frame;\n\tdouble radius = 5.0;\n\tdouble angle = M_PI / 4;\n\tAMCAX::Cone cone(frame, radius, angle);\n\tAMCAX::Point3 apex = cone.Apex();\n\tCHECK(apex.X() == 0.0);\n\tCHECK(apex.Y() == 0.0);\n\tCHECK(apex.Z() == Approx(-5.0));"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] AMCAX_API double SemiAngle()\t @return The semi-angle\n\t @brief Get the semi-angle",
 "output": "#include<iostream>\n#include \"catch.hpp\"\n#include <common/FrameT.hpp>\n#include <modeling/MakeFace.hpp>\n#include <common/AxisT.hpp>\n#include <common/FrameT.hpp>\n#include <common/VectorT.hpp>\n#include <math/Cone.hpp>\nusing namespace AMCAX;\nusing namespace std;\n\nTEST_CASE(\"TestCone\", \"[math][Cone]\")\n\n\tAMCAX::Frame3 frame;\n\tdouble radius = 5.0;\n\tdouble angle = M_PI / 4;\n\tAMCAX::Cone cone(frame, radius, angle);\n\tdouble semiCone = cone.SemiAngle();\n\tCHECK(semiCone == Approx(0.785398));"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "Cone()\t @brief Default constructor",
 "output": "#include<iostream>\n#include \"catch.hpp\"\n#include <common/FrameT.hpp>\n#include <modeling/MakeFace.hpp>\n#include <common/AxisT.hpp>\n#include <common/FrameT.hpp>\n#include <common/VectorT.hpp>\n#include <math/Cone.hpp>\nusing namespace AMCAX;\nusing namespace std;\n\nTEST_CASE(\"TestCone\", \"[math][Cone]\")\n\n\tAMCAX::Frame3 frame;\n\tdouble radius = 5.0;\n\tdouble angle = M_PI / 4;\n\tAMCAX::Cone cone(frame, radius, angle);"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "AMCAX_API Cone(const Frame3& frame, double r, double angle)\t @param angle The semi-angle\n\t@param r The reference radius\n\t@param frame The local frame\n\t@brief Construct from a local frame, a reference radius and a semi-angle",
 "output": "#include<iostream>\n#include \"catch.hpp\"\n#include <common/FrameT.hpp>\n#include <modeling/MakeFace.hpp>\n#include <common/AxisT.hpp>\n#include <common/FrameT.hpp>\n#include <common/VectorT.hpp>\n#include <math/Cone.hpp>\nusing namespace AMCAX;\nusing namespace std;\n\nTEST_CASE(\"TestCone\", \"[math][Cone]\")\n\n\tAMCAX::Frame3 frame;\n\tdouble radius = 5.0;\n\tdouble angle = M_PI / 4;\n\tAMCAX::Cone cone(frame, radius, angle);"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "AMCAX_API Cone& Scale(const Point3& point, double scale)\t @return The reference to self\n\t@param scale The scale value\n\t@param point The scaling center point\n\t@brief Scale the cone by a point",
 "output": "#include<iostream>\n#include \"catch.hpp\"\n#include <common/FrameT.hpp>\n#include <modeling/MakeFace.hpp>\n#include <common/AxisT.hpp>\n#include <common/FrameT.hpp>\n#include <common/VectorT.hpp>\n#include <math/Cone.hpp>\nusing namespace AMCAX;\nusing namespace std;\n\nTEST_CASE(\"TestCone\", \"[math][Cone]\")\n\n\tAMCAX::Frame3 frame;\n\tdouble radius = 5.0;\n\tdouble angle = M_PI / 4;\n\tAMCAX::Cone cone(frame, radius, angle);\n\tdouble scaleCone = 2.0;\n\tcone.Scale(cone.Location(), scaleCone);"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "AMCAX_API Cone& Transform(const Transformation3& tr)\t @return The reference to self\n\t@param tr The transformation\n\t@brief Transform the cone",
 "output": "#include<iostream>\n#include \"catch.hpp\"\n#include <common/FrameT.hpp>\n#include <modeling/MakeFace.hpp>\n#include <common/AxisT.hpp>\n#include <common/FrameT.hpp>\n#include <common/VectorT.hpp>\n#include <math/Cone.hpp>\nusing namespace AMCAX;\nusing namespace std;\n\nTEST_CASE(\"TestCone\", \"[math][Cone\")\n\n\tAMCAX::Frame3 frame;\n\tdouble radius = 5.0;\n\tdouble angle = M_PI / 4;\n\tAMCAX::Cone cone(frame, radius, angle);\n\tAMCAX::Transformation3 tr;\n\ttr.SetTranslation(Vector3(1.0, 2.0, 3.0));\n\tcone.Transform(tr);"}    {
        "instruction": "Generate a test program based on the following method declarations and parameter parsing.",
        "input": "[[nodiscard]] AMCAX_API Point3 Apex()\t @return The apex point\n\t @brief Get the apex of the cone",
        "output": "#include<catch.hpp>\n#include<testHelperBase.h>\n\n#include <polymeshAPI/MeshMakeCone.hpp>\n#include <polymesh/PolyMeshIO.hpp>\n#include <polymeshAPI/MeshSubdivideHE.hpp>\n\nusing namespace AMCAX;\n\nTEST_CASE(\"case1:MeshMakeCone  \", \"[polymeshAPI][SubD][MeshMakeCone][P1]\") \n\tdouble r = 1;\n\tdouble h = 1;\n\tSubD::MeshMakeCone meshmakeCone(r, h);\n\tAMCAX::SubD::PolyMesh* mesh = meshmakeCone.BuildMesh();\n\tCHECK(mesh != nullptr);\n\tAMCAX::SubD::MeshSubdivideHE::CatmullClark(mesh, 3);\n\tbool result = AMCAX::SubD::PolyMeshIO::WriteMesh(OUTPUT_PATH_PREFIX\"MeshMakeCone_case01.obj\", mesh);\n\tCHECK(result == true);"
    },
    {
        "instruction": "Generate a test program based on the following method declarations and parameter parsing.",
        "input": "[[nodiscard]] AMCAX_API double SemiAngle()\t @return The semi-angle\n\t @brief Get the semi-angle",
        "output": "#include<catch.hpp>\n#include<testHelperBase.h>\n\n#include <polymeshAPI/MeshMakeCone.hpp>\n#include <polymesh/PolyMeshIO.hpp>\n#include <polymeshAPI/MeshSubdivideHE.hpp>\n\nusing namespace AMCAX;\n\nTEST_CASE(\"case1:MeshMakeCone  \", \"[polymeshAPI][SubD][MeshMakeCone][P1]\") \n\tdouble r = 1;\n\tdouble h = 1;\n\tSubD::MeshMakeCone meshmakeCone(r, h);\n\tAMCAX::SubD::PolyMesh* mesh = meshmakeCone.BuildMesh();\n\tCHECK(mesh != nullptr);\n\tAMCAX::SubD::MeshSubdivideHE::CatmullClark(mesh, 3);\n\tbool result = AMCAX::SubD::PolyMeshIO::WriteMesh(OUTPUT_PATH_PREFIX\"MeshMakeCone_case01.obj\", mesh);\n\tCHECK(result == true);"
    },
    {
        "instruction": "Generate a test program based on the following method declarations and parameter parsing.",
        "input": "Cone()\t @brief Default constructor",
        "output": "#include<catch.hpp>\n#include<testHelperBase.h>\n\n#include <polymeshAPI/MeshMakeCone.hpp>\n#include <polymesh/PolyMeshIO.hpp>\n#include <polymeshAPI/MeshSubdivideHE.hpp>\n\nusing namespace AMCAX;\n\nTEST_CASE(\"case1:MeshMakeCone  \", \"[polymeshAPI][SubD][MeshMakeCone][P1]\") \n\tdouble r = 1;\n\tdouble h = 1;\n\tSubD::MeshMakeCone meshmakeCone(r, h);\n\tAMCAX::SubD::PolyMesh* mesh = meshmakeCone.BuildMesh();\n\tCHECK(mesh != nullptr);\n\tAMCAX::SubD::MeshSubdivideHE::CatmullClark(mesh, 3);\n\tbool result = AMCAX::SubD::PolyMeshIO::WriteMesh(OUTPUT_PATH_PREFIX\"MeshMakeCone_case01.obj\", mesh);\n\tCHECK(result == true);"
    },
    {
        "instruction": "Generate a test program based on the following method declarations and parameter parsing.",
        "input": "AMCAX_API Cone(const Frame3& frame, double r, double angle)\t @param angle The semi-angle\n\t@param r The reference radius\n\t@param frame The local frame\n\t @brief Construct from a local frame, a reference radius and a semi-angle",
        "output": "#include<catch.hpp>\n#include<testHelperBase.h>\n\n#include <polymeshAPI/MeshMakeCone.hpp>\n#include <polymesh/PolyMeshIO.hpp>\n#include <polymeshAPI/MeshSubdivideHE.hpp>\n\nusing namespace AMCAX;\n\nTEST_CASE(\"case1:MeshMakeCone  \", \"[polymeshAPI][SubD][MeshMakeCone][P1]\") \n\tdouble r = 1;\n\tdouble h = 1;\n\tSubD::MeshMakeCone meshmakeCone(r, h);\n\tAMCAX::SubD::PolyMesh* mesh = meshmakeCone.BuildMesh();\n\tCHECK(mesh != nullptr);\n\tAMCAX::SubD::MeshSubdivideHE::CatmullClark(mesh, 3);\n\tbool result = AMCAX::SubD::PolyMeshIO::WriteMesh(OUTPUT_PATH_PREFIX\"MeshMakeCone_case01.obj\", mesh);\n\tCHECK(result == true);"
    },
    {
        "instruction": "Generate a test program based on the following method declarations and parameter parsing.",
        "input": "AMCAX_API Cone& Scale(const Point3& point, double scale)\t @return The reference to self\n\t@param scale The scale value\n\t@param point The scaling center point\n\t @brief Scale the cone by a point",
        "output": "#include<catch.hpp>\n#include<testHelperBase.h>\n\n#include <polymeshAPI/MeshMakeCone.hpp>\n#include <polymesh/PolyMeshIO.hpp>\n#include <polymeshAPI/MeshSubdivideHE.hpp>\n\nusing namespace AMCAX;\n\nTEST_CASE(\"case1:MeshMakeCone  \", \"[polymeshAPI][SubD][MeshMakeCone][P1]\") \n\tdouble r = 1;\n\tdouble h = 1;\n\tSubD::MeshMakeCone meshmakeCone(r, h);\n\tAMCAX::SubD::PolyMesh* mesh = meshmakeCone.BuildMesh();\n\tCHECK(mesh != nullptr);\n\tAMCAX::SubD::MeshSubdivideHE::CatmullClark(mesh, 3);\n\tbool result = AMCAX::SubD::PolyMeshIO::WriteMesh(OUTPUT_PATH_PREFIX\"MeshMakeCone_case01.obj\", mesh);\n\tCHECK(result == true);"
    },
    {
        "instruction": "Generate a test program based on the following method declarations and parameter parsing.",
        "input": "AMCAX_API Cone& Transform(const Transformation3& tr)\t @return The reference to self\n\t@param tr The transformation\n\t @brief Transform the cone",
        "output": "#include<catch.hpp>\n#include<testHelperBase.h>\n\n#include <polymeshAPI/MeshMakeCone.hpp>\n#include <polymesh/PolyMeshIO.hpp>\n#include <polymeshAPI/MeshSubdivideHE.hpp>\n\nusing namespace AMCAX;\n\nTEST_CASE(\"case1:MeshMakeCone  \", \"[polymeshAPI][SubD][MeshMakeCone][P1]\") \n\tdouble r = 1;\n\tdouble h = 1;\n\tSubD::MeshMakeCone meshmakeCone(r, h);\n\tAMCAX::SubD::PolyMesh* mesh = meshmakeCone.BuildMesh();\n\tCHECK(mesh != nullptr);\n\tAMCAX::SubD::MeshSubdivideHE::CatmullClark(mesh, 3);\n\tbool result = AMCAX::SubD::PolyMeshIO::WriteMesh(OUTPUT_PATH_PREFIX\"MeshMakeCone_case01.obj\", mesh);\n\tCHECK(result == true);"
    }{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "AMCAX_API static void AdjustPeriodic(double ufirst, double ulast, double precision, double& u1, double& u2)\t @paramin,[out] u2 The second parameter to be adjust\n\t @param[in,out] u1 The first parameter to be adjust\n\t @param[in] precision The precision to check equality\n\t @param[in] ulast The upper bound of the period\n\t @param[in] ufirst The lower bound of the period\n\t          The parameter u2 is set in the range [u1, u1 + ulast - ufirst]\n\t @details The parameter u1 is set in the range [ufirst, ulast]\n\t @brief Adjust u1 and u2 to be in the period range.",
 "output": "#include<catch.hpp>\n#include<testHelper.h>\n\n\n#include <common/PointT.hpp>\n#include <math/CurveCalculation.hpp>\n\n\nusing namespace AMCAX;\n\n\n\n\nTEST_CASE(\"case1: CurveCalculation::AdjustPeriodic \", \"[math][CurveCalculation][P1]\") \n\n\tdouble u1 = 0.0;\n\tdouble u2 = 2 * M_PI;\n\tdouble ufirst = 0.0;\n\tdouble ulast = 2 * M_PI; // 假设周期为 2π\n\tdouble precision = 0.001; // 精度\n\n\tAMCAX::CurveCalculation::AdjustPeriodic(ufirst, ulast, precision, u1, u2);\n\tCHECK(u1 == 0);\n\tCHECK(u2 == 2 * M_PI);\n\n\n\n\nTEST_CASE(\"case2: CurveCalculation::AdjustPeriodic \", \"[math][CurveCalculation][P1]\") \n\n\tdouble u1 = 1.1;\n\tdouble u2 = 2.2;\n\tdouble ufirst = 0.0;\n\tdouble ulast = 2 * M_PI; // 假设周期为 2π\n\tdouble precision = 0.001; // 精度\n\n\tAMCAX::CurveCalculation::AdjustPeriodic(ufirst, ulast, precision, u1, u2);\n\tCHECK(u1 == 1.1);\n\tCHECK(u2 == 2.2);\n\n\nTEST_CASE(\"case3: CurveCalculation::AdjustPeriodic \", \"[math][CurveCalculation][P1]\") \n\n\tdouble u1 = 2 * M_PI;\n\tdouble u2 = 3 * M_PI;\n\tdouble ufirst = 0.0;\n\tdouble ulast = 2 * M_PI; // 假设周期为 2π\n\tdouble precision = 0.001; // 精度\n\n\tAMCAX::CurveCalculation::AdjustPeriodic(ufirst, ulast, precision, u1, u2);\n\tCHECK(u1 == 0);\n\tCHECK(u2 == M_PI);\n\n\nTEST_CASE(\"case4: CurveCalculation::AdjustPeriodic \", \"[math][CurveCalculation][P1]\") \n\n\tdouble u1 = 2 * M_PI + 0.3;\n\tdouble u2 = 3 * M_PI + 0.3;\n\tdouble ufirst = 0.0;\n\tdouble ulast = 2 * M_PI; // 假设周期为 2π\n\tdouble precision = 0.001; // 精度\n\n\tAMCAX::CurveCalculation::AdjustPeriodic(ufirst, ulast, precision, u1, u2);\n\tCHECK(u1 == Approx(0.3).epsilon(1e-2));\n\tCHECK(u2 ==  Approx(M_PI +0.3).epsilon(1e-2));\n\n\nTEST_CASE(\"case5: CurveCalculation::AdjustPeriodic \", \"[math][CurveCalculation][P1]\") \n\n\tdouble u1 = -0.5;\n\tdouble u2 = 2.5;\n\tdouble ufirst = 0.5;\n\tdouble ulast = 2.5; \n\tdouble precision = 0.001; \n\n\tAMCAX::CurveCalculation::AdjustPeriodic(ufirst, ulast, precision, u1, u2);\n\tCHECK(u1 == 1.5);\n\tCHECK(u2 == 2.5);\n\n\nTEST_CASE(\"case6: CurveCalculation::AdjustPeriodic \", \"[math][CurveCalculation][P1]\") \n\n\tdouble u1 = -0.0;\n\tdouble u2 = -0.0;\n\tdouble ufirst = 0.5;\n\tdouble ulast = 2.5;\n\tdouble precision = 0.001;\n\n\tAMCAX::CurveCalculation::AdjustPeriodic(ufirst, ulast, precision, u1, u2);\n\tCHECK(u1 == 2.0);\n\tCHECK(u2 == 4.0);"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] AMCAX_API static Point3 D0(double u, const Line3& line)\t @return The resulting point\n\t @param line The line\n\t @param u The parameter\n\t @brief Compute the point on a 3D line at a parameter",
 "output": "#include<catch.hpp>\n#include<testHelper.h>\n\n#include <common/PointT.hpp>\n#include <math/CurveCalculation.hpp>\n\nusing namespace AMCAX;\n\nTEST_CASE(\"case1: CurveCalculation::D0 on Line3\", \"[math][CurveCalculation][P1]\") {\n\tdouble u = 0.5;\n\tLine3 line;\n\tPoint3 result = AMCAX::CurveCalculation::D0(u, line);\n\tCHECK(result.X() == /* expected value */);\n\tCHECK(result.Y() == /* expected value */);\n\tCHECK(result.Z() == /* expected value */);\n}\n\nTEST_CASE(\"case2: CurveCalculation::D0 on Line3\", \"[math][CurveCalculation][P1]\") {\n\tdouble u = 1.0;\n\tLine3 line;\n\tPoint3 result = AMCAX::CurveCalculation::D0(u, line);\n\tCHECK(result.X() == /* expected value */);\n\tCHECK(result.Y() == /* expected value */);\n\tCHECK(result.Z() == /* expected value */);\n}"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] AMCAX_API static Point3 D0(double u, const Circle3& circle)\t @return The resulting point\n\t @param circle The circle\n\t @param u The parameter\n\t @brief Compute the point on a 3D circle at a parameter",
 "output": "#include<catch.hpp>\n#include<testHelper.h>\n\n#include <common/PointT.hpp>\n#include <math/CurveCalculation.hpp>\n\nusing namespace AMCAX;\n\nTEST_CASE(\"case1: CurveCalculation::D0 on Circle3\", \"[math][CurveCalculation][P1]\") {\n\tdouble u = 0.5;\n\tCircle3 circle;\n\tPoint3 result = AMCAX::CurveCalculation::D0(u, circle);\n\tCHECK(result.X() == /* expected value */);\n\tCHECK(result.Y() == /* expected value */);\n\tCHECK(result.Z() == /* expected value */);\n}\n\nTEST_CASE(\"case2: CurveCalculation::D0 on Circle3\", \"[math][CurveCalculation][P1]\") {\n\tdouble u = 1.0;\n\tCircle3 circle;\n\tPoint3 result = AMCAX::CurveCalculation::D0(u, circle);\n\tCHECK(result.X() == /* expected value */);\n\tCHECK(result.Y() == /* expected value */);\n\tCHECK(result.Z() == /* expected value */);\n}"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] AMCAX_API static Point3 D0(double u, const Ellipse3& ellipse)\t @return The resulting point\n\t @param ellipse The ellipse\n\t @param u The parameter\n\t @brief Compute the point on a 3D ellipse at a parameter",
 "output": "#include<catch.hpp>\n#include<testHelper.h>\n\n#include <common/PointT.hpp>\n#include <math/CurveCalculation.hpp>\n\nusing namespace AMCAX;\n\nTEST_CASE(\"case1: CurveCalculation::D0 on Ellipse3\", \"[math][CurveCalculation][P1]\") {\n\tdouble u = 0.5;\n\tEllipse3 ellipse;\n\tPoint3 result = AMCAX::CurveCalculation::D0(u, ellipse);\n\tCHECK(result.X() == /* expected value */);\n\tCHECK(result.Y() == /* expected value */);\n\tCHECK(result.Z() == /* expected value */);\n}\n\nTEST_CASE(\"case2: CurveCalculation::D0 on Ellipse3\", \"[math][CurveCalculation][P1]\") {\n\tdouble u = 1.0;\n\tEllipse3 ellipse;\n\tPoint3 result = AMCAX::CurveCalculation::D0(u, ellipse);\n\tCHECK(result.X() == /* expected value */);\n\tCHECK(result.Y() == /* expected value */);\n\tCHECK(result.Z() == /* expected value */);\n}"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] AMCAX_API static Point3 D0(double u, const Parabola3& parabola)\t @return The resulting point\n\t @param parabola The parabola\n\t @param u The parameter\n\t @brief Compute the point on a 3D parabola at a parameter",
 "output": "#include<catch.hpp>\n#include<testHelper.h>\n\n#include <common/PointT.hpp>\n#include <math/CurveCalculation.hpp>\n\nusing namespace AMCAX;\n\nTEST_CASE(\"case1: CurveCalculation::D0 on Parabola3\", \"[math][CurveCalculation][P1]\") {\n\tdouble u = 0.5;\n\tParabola3 parabola;\n\tPoint3 result = AMCAX::CurveCalculation::D0(u, parabola);\n\tCHECK(result.X() == /* expected value */);\n\tCHECK(result.Y() == /* expected value */);\n\tCHECK(result.Z() == /* expected value */);\n}\n\nTEST_CASE(\"case2: CurveCalculation::D0 on Parabola3\", \"[math][CurveCalculation][P1]\") {\n\tdouble u = 1.0;\n\tParabola3 parabola;\n\tPoint3 result = AMCAX::CurveCalculation::D0(u, parabola);\n\tCHECK(result.X() == /* expected value */);\n\tCHECK(result.Y() == /* expected value */);\n\tCHECK(result.Z() == /* expected value */);\n}"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] AMCAX_API static Point3 D0(double u, const Hyperbola3& hyperbola)\t @return The resulting point\n\t @param hyperbola The hyperbola\n\t @param u The parameter\n\t @brief Compute the point on a 3D hyperbola at a parameter",
 "output": "#include<catch.hpp>\n#include<testHelper.h>\n\n#include <common/PointT.hpp>\n#include <math/CurveCalculation.hpp>\n\nusing namespace AMCAX;\n\nTEST_CASE(\"case1: CurveCalculation::D0 on Hyperbola3\", \"[math][CurveCalculation][P1]\") {\n\tdouble u = 0.5;\n\tHyperbola3 hyperbola;\n\tPoint3 result = AMCAX::CurveCalculation::D0(u, hyperbola);\n\tCHECK(result.X() == /* expected value */);\n\tCHECK(result.Y() == /* expected value */);\n\tCHECK(result.Z() == /* expected value */);\n}\n\nTEST_CASE(\"case2: CurveCalculation::D0 on Hyperbola3\", \"[math][CurveCalculation][P1]\") {\n\tdouble u = 1.0;\n\tHyperbola3 hyperbola;\n\tPoint3 result = AMCAX::CurveCalculation::D0(u, hyperbola);\n\tCHECK(result.X() == /* expected value */);\n\tCHECK(result.Y() == /* expected value */);\n\tCHECK(result.Z() == /* expected value */);\n}"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] AMCAX_API static Point2 D0(double u, const Line2& line)\t @return The resulting point\n\t @param line The line\n\t @param u The parameter\n\t @brief Compute the point on a 2D line at a parameter",
 "output": "#include<catch.hpp>\n#include<testHelper.h>\n\n#include <common/PointT.hpp>\n#include <math/CurveCalculation.hpp>\n\nusing namespace AMCAX;\n\nTEST_CASE(\"case1: CurveCalculation::D0 on Line2\", \"[math][CurveCalculation][P1]\") {\n\tdouble u = 0.5;\n\tLine2 line;\n\tPoint2 result = AMCAX::CurveCalculation::D0(u, line);\n\tCHECK(result.X() == /* expected value */);\n\tCHECK(result.Y() == /* expected value */);\n}\n\nTEST_CASE(\"case2: CurveCalculation::D0 on Line2\", \"[math][CurveCalculation][P1]\") {\n\tdouble u = 1.0;\n\tLine2 line;\n\tPoint2 result = AMCAX::CurveCalculation::D0(u, line);\n\tCHECK(result.X() == /* expected value */);\n\tCHECK(result.Y() == /* expected value */);\n}"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] AMCAX_API static Point2 D0(double u, const Circle2& circle)\t @return The resulting point\n\t @param circle The circle\n\t @param u The parameter\n\t @brief Compute the point on a 2D circle at a parameter",
 "output": "#include<catch.hpp>\n#include<testHelper.h>\n\n#include <common/PointT.hpp>\n#include <math/CurveCalculation.hpp>\n\nusing namespace AMCAX;\n\nTEST_CASE(\"case1: CurveCalculation::D0 on Circle2\", \"[math][CurveCalculation][P1]\") {\n\tdouble u = 0.5;\n\tCircle2 circle;\n\tPoint2 result = AMCAX::CurveCalculation::D0(u, circle);\n\tCHECK(result.X() == /* expected value */);\n\tCHECK(result.Y() == /* expected value */);\n}\n\nTEST_CASE(\"case2: CurveCalculation::D0 on Circle2\", \"[math][CurveCalculation][P1]\") {\n\tdouble u = 1.0;\n\tCircle2 circle;\n\tPoint2 result = AMCAX::CurveCalculation::D0(u, circle);\n\tCHECK(result.X() == /* expected value */);\n\tCHECK(result.Y() == /* expected value */);\n}"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] AMCAX_API static Point2 D0(double u, const Ellipse2& ellipse)\t @return The resulting point\n\t @param ellipse The ellipse\n\t @param u The parameter\n\t @brief Compute the point on a 2D ellipse at a parameter",
 "output": "#include<catch.hpp>\n#include<testHelper.h>\n\n#include <common/PointT.hpp>\n#include <math/CurveCalculation.hpp>\n\nusing namespace AMCAX;\n\nTEST_CASE(\"case1: CurveCalculation::D0 on Ellipse2\", \"[math][CurveCalculation][P1]\") {\n\tdouble u = 0.5;\n\tEllipse2 ellipse;\n\tPoint2 result = AMCAX::CurveCalculation::D0(u, ellipse);\n\tCHECK(result.X() == /* expected value */);\n\tCHECK(result.Y() == /* expected value */);\n}\n\nTEST_CASE(\"case2: CurveCalculation::D0 on Ellipse2\", \"[math][CurveCalculation][P1]\") {\n\tdouble u = 1.0;\n\tEllipse2 ellipse;\n\tPoint2 result = AMCAX::CurveCalculation::D0(u, ellipse);\n\tCHECK(result.X() == /* expected value */);\n\tCHECK(result.Y() == /* expected value */);\n}"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] AMCAX_API static Point2 D0(double u, const Parabola2& parabola)\t @return The resulting point\n\t @param parabola The parabola\n\t @param u The parameter\n\t @brief Compute the point on a 2D parabola at a parameter",
 "output": "#include<catch.hpp>\n#include<testHelper.h>\n\n#include <common/PointT.hpp>\n#include <math/CurveCalculation.hpp>\n\nusing namespace AMCAX;\n\nTEST_CASE(\"case1: CurveCalculation::D0 on Parabola2\", \"[math][CurveCalculation][P1]\") {\n\tdouble u = 0.5;\n\tParabola2 parabola;\n\tPoint2 result = AMCAX::CurveCalculation::D0(u, parabola);\n\tCHECK(result.X() == /* expected value */);\n\tCHECK(result.Y() == /* expected value */);\n}\n\nTEST_CASE(\"case2: CurveCalculation::D0 on Parabola2\", \"[math][CurveCalculation][P1]\") {\n\tdouble u = 1.0;\n\tParabola2 parabola;\n\tPoint2 result = AMCAX::CurveCalculation::D0(u, parabola);\n\tCHECK(result.X() == /* expected value */);\n\tCHECK(result.Y() == /* expected value */);\n}"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] AMCAX_API static Point2 D0(double u, const Hyperbola2& hyperbola)\t @return The resulting point\n\t @param hyperbola The hyperbola\n\t @param u The parameter\n\t @brief Compute the point on a 2D hyperbola at a parameter",
 "output": "#include<catch.hpp>\n#include<testHelper.h>\n\n#include <common/PointT.hpp>\n#include <math/CurveCalculation.hpp>\n\nusing namespace AMCAX;\n\nTEST_CASE(\"case1: CurveCalculation::D0 on Hyperbola2\", \"[math][CurveCalculation][P1]\") {\n\tdouble u = 0.5;\n\tHyperbola2 hyperbola;\n\tPoint2 result = AMCAX::CurveCalculation::D0(u, hyperbola);\n\tCHECK(result.X() == /* expected value */);\n\tCHECK(result.Y() == /* expected value */);\n}\n\nTEST_CASE(\"case2: CurveCalculation::D0 on Hyperbola2\", \"[math][CurveCalculation][P1]\") {\n\tdouble u = 1.0;\n\tHyperbola2 hyperbola;\n\tPoint2 result = AMCAX::CurveCalculation::D0(u, hyperbola);\n\tCHECK(result.X() == /* expected value */);\n\tCHECK(result.Y() == /* expected value */);\n}"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] AMCAX_API static Vector3 D1(double u, const Line3& line)\t @return The first derivative vector\n\t @param line The line\n\t @param u The parameter\n\t @brief Compute the first derivative on a 3D line at a parameter",
 "output": "#include<catch.hpp>\n#include<testHelper.h>\n\n#include <common/PointT.hpp>\n#include <math/CurveCalculation.hpp>\n\nusing namespace AMCAX;\n\nTEST_CASE(\"case1: CurveCalculation::D1 on Line3\", \"[math][CurveCalculation][P1]\") {\n\tdouble u = 0.5;\n\tLine3 line;\n\tVector3 result = AMCAX::CurveCalculation::D1(u, line);\n\tCHECK(result.X() == /* expected value */);\n\tCHECK(result.Y() == /* expected value */);\n\tCHECK(result.Z() == /* expected value */);\n}\n\nTEST_CASE(\"case2: CurveCalculation::D1 on Line3\", \"[math][CurveCalculation][P1]\") {\n\tdouble u = 1.0;\n\tLine3 line;\n\tVector3 result = AMCAX::CurveCalculation::D1(u, line);\n\tCHECK(result.X() == /* expected value */);\n\tCHECK(result.Y() == /* expected value */);\n\tCHECK(result.Z() == /* expected value */);\n}"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "AMCAX_API static void D1(double u, const Line3& line, Point3& p, Vector3& v1)\t @param[out] v1 The first derivative\n\t @param[out] p The point\n\t @param[in] line The line\n\t @param[in] u The parameter\n\t @brief Compute the point and the first derivative on a 3D line at a parameter",
 "output": "#include<catch.hpp>\n#include<testHelper.h>\n\n#include <common/PointT.hpp>\n#include <math/CurveCalculation.hpp>\n\nusing namespace AMCAX;\n\nTEST_CASE(\"case1: CurveCalculation::D1 on Line3 with outputs\", \"[math][CurveCalculation][P1]\") {\n\tdouble u = 0.5;\n\tLine3 line;\n\tPoint3 p;\n\tVector3 v1;\n\tAMCAX::CurveCalculation::D1(u, line, p, v1);\n\tCHECK(p.X() == /* expected value */);\n\tCHECK(p.Y() == /* expected value */);\n\tCHECK(p.Z() == /* expected value */);\n\tCHECK(v1.X() == /* expected value */);\n\tCHECK(v1.Y() == /* expected value */);\n\tCHECK(v1.Z() == /* expected value */);\n}\n\nTEST_CASE(\"case2: CurveCalculation::D1 on Line3 with outputs\", \"[math][CurveCalculation][P1]\") {\n\tdouble u = 1.0;\n\tLine3 line;\n\tPoint3 p;\n\tVector3 v1;\n\tAMCAX::CurveCalculation::D1(u, line, p, v1);\n\tCHECK(p.X() == /* expected value */);\n\tCHECK(p.Y() == /* expected value */);\n\tCHECK(p.Z() == /* expected value */);\n\tCHECK(v1.X() == /* expected value */);\n\tCHECK(v1.Y() == /* expected value */);\n\tCHECK(v1.Z() == /* expected value */);\n}"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] AMCAX_API static Vector3 D1(double u, const Circle3& circle)\t @return The first derivative vector\n\t @param circle The circle\n\t @param u The parameter\n\t @brief Compute the first derivative on a 3D circle at a parameter",
 "output": "#include<catch.hpp>\n#include<testHelper.h>\n\n#include <common/PointT.hpp>\n#include <math/CurveCalculation.hpp>\n\nusing namespace AMCAX;\n\nTEST_CASE(\"case1: CurveCalculation::D1 on Circle3\", \"[math][CurveCalculation][P1]\") {\n\tdouble u = 0.5;\n\tCircle3 circle;\n\tVector3 result = AMCAX::CurveCalculation::D1(u, circle);\n\tCHECK(result.X() == /* expected value */);\n\tCHECK(result.Y() == /* expected value */);\n\tCHECK(result.Z() == /* expected value */);\n}\n\nTEST_CASE(\"case2: CurveCalculation::D1 on Circle3\", \"[math][CurveCalculation][P1]\") {\n\tdouble u = 1.0;\n\tCircle3 circle;\n\tVector3 result = AMCAX::CurveCalculation::D1(u, circle);\n\tCHECK(result.X() == /* expected value */);\n\tCHECK(result.Y() == /* expected value */);\n\tCHECK(result.Z() == /* expected value */);\n}"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] AMCAX_API static Vector3 D1(double u, const Ellipse3& ellipse)\t @return The first derivative vector\n\t @param ellipse The ellipse\n\t @param u The parameter\n\t @brief Compute the first derivative on a 3D ellipse at a parameter",
 "output": "#include<catch.hpp>\n#include<testHelper.h>\n\n#include <common/PointT.hpp>\n#include <math/CurveCalculation.hpp>\n\nusing namespace AMCAX;\n\nTEST_CASE(\"case1: CurveCalculation::D1 on Ellipse3\", \"[math][CurveCalculation][P1]\") {\n\tdouble u = 0.5;\n\tEllipse3 ellipse;\n\tVector3 result = AMCAX::CurveCalculation::D1(u, ellipse);\n\tCHECK(result.X() == /* expected value */);\n\tCHECK(result.Y() == /* expected value */);\n\tCHECK(result.Z() == /* expected value */);\n}\n\nTEST_CASE(\"case2: CurveCalculation::D1 on Ellipse3\", \"[math][CurveCalculation][P1]\") {\n\tdouble u = 1.0;\n\tEllipse3 ellipse;\n\tVector3 result = AMCAX::CurveCalculation::D1(u, ellipse);\n\tCHECK(result.X() == /* expected value */);\n\tCHECK(result.Y() == /* expected value */);\n\tCHECK(result.Z() == /* expected value */);\n}"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] AMCAX_API static Vector3 D1(double u, const Parabola3& parabola)\t @return The first derivative vector\n\t @param parabola The parabola\n\t @param u The parameter\n\t @brief Compute the first derivative on a 3D parabola at a parameter",
 "output": "#include<catch.hpp>\n#include<testHelper.h>\n\n#include <common/PointT.hpp>\n#include <math/CurveCalculation.hpp>\n\nusing namespace AMCAX;\n\nTEST_CASE(\"case1: CurveCalculation::D1 on Parabola3\", \"[math][CurveCalculation][P1]\") {\n\tdouble u = 0.5;\n\tParabola3 parabola;\n\tVector3 result = AMCAX::CurveCalculation::D1(u, parabola);\n\tCHECK(result.X() == /* expected value */);\n\tCHECK(result.Y() == /* expected value */);\n\tCHECK(result.Z() == /* expected value */);\n}\n\nTEST_CASE(\"case2: CurveCalculation::D1 on Parabola3\", \"[math][CurveCalculation][P1]\") {\n\tdouble u = 1.0;\n\tParabola3 parabola;\n\tVector3 result = AMCAX::CurveCalculation::D1(u, parabola);\n\tCHECK(result.X() == /* expected value */);\n\tCHECK(result.Y() == /* expected value */);\n\tCHECK(result.Z() == /* expected value */);\n}"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] AMCAX_API static Vector3 D1(double u, const Hyperbola3& hyperbola)\t @return The first derivative vector\n\t @param hyperbola The hyperbola\n\t @param u The parameter\n\t @brief Compute the first derivative on a 3D hyperbola at a parameter",
 "output": "#include<catch.hpp>\n#include<testHelper.h>\n\n#include <common/PointT.hpp>\n#include <math/CurveCalculation.hpp>\n\nusing namespace AMCAX;\n\nTEST_CASE(\"case1: CurveCalculation::D1 on Hyperbola3\", \"[math][CurveCalculation][P1]\") {\n\tdouble u = 0.5;\n\tHyperbola3 hyperbola;\n\tVector3 result = AMCAX::CurveCalculation::D1(u, hyperbola);\n\tCHECK(result.X() == /* expected value */);\n\tCHECK(result.Y() == /* expected value */);\n\tCHECK(result.Z() == /* expected value */);\n}\n\nTEST_CASE(\"case2: CurveCalculation::D1 on Hyperbola3\", \"[math][CurveCalculation][P1]\") {\n\tdouble u = 1.0;\n\tHyperbola3 hyperbola;\n\tVector3 result = AMCAX::CurveCalculation::D1(u, hyperbola);\n\tCHECK(result.X() == /* expected value */);\n\tCHECK(result.Y() == /* expected value */);\n\tCHECK(result.Z() == /* expected value */);\n}"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] AMCAX_API static Vector2 D1(double u, const Line2& line)\t @return The first derivative vector\n\t @param line The line\n\t @param u The parameter\n\t @brief Compute the first derivative on a 2D line at a parameter",
 "output": "#include<catch.hpp>\n#include<testHelper.h>\n\n#include <common/PointT.hpp>\n#include <math/CurveCalculation.hpp>\n\nusing namespace AMCAX;\n\nTEST_CASE(\"case1: CurveCalculation::D1 on Line2\", \"[math][CurveCalculation][P1]\") {\n\tdouble u = 0.5;\n\tLine2 line;\n\tVector2 result = AMCAX::CurveCalculation::D1(u, line);\n\tCHECK(result.X() == /* expected value */);\n\tCHECK(result.Y() == /* expected value */);\n}\n\nTEST_CASE(\"case2: CurveCalculation::D1 on Line2\", \"[math][CurveCalculation][P1]\") {\n\tdouble u = 1.0;\n\tLine2 line;\n\tVector2 result = AMCAX::CurveCalculation::D1(u, line);\n\tCHECK(result.X() == /* expected value */);\n\tCHECK(result.Y() == /* expected value */);\n}"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] AMCAX_API static Vector2 D1(double u, const Circle2& circle)\t @return The first derivative vector\n\t @param circle The circle\n\t @param u The parameter\n\t @brief Compute the first derivative on a 2D circle at a parameter",
 "output": "#include<catch.hpp>\n#include<testHelper.h>\n\n#include <common/PointT.hpp>\n#include <math/CurveCalculation.hpp>\n\nusing namespace AMCAX;\n\nTEST_CASE(\"case1: CurveCalculation::D1 on Circle2\", \"[math][CurveCalculation][P1]\") {\n\tdouble u = 0.5;\n\tCircle2 circle;\n\tVector2 result = AMCAX::CurveCalculation::D1(u, circle);\n\tCHECK(result.X() == /* expected value */);\n\tCHECK(result.Y() == /* expected value */);\n}\n\nTEST_CASE(\"case2: CurveCalculation::D1 on Circle2\", \"[math][CurveCalculation][P1]\") {\n\tdouble u = 1.0;\n\tCircle2 circle;\n\tVector2 result = AMCAX::CurveCalculation::D1(u, circle);\n\tCHECK(result.X() == /* expected value */);\n\tCHECK(result.Y() == /* expected value */);\n}"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] AMCAX_API static Vector2 D1(double u, const Ellipse2& ellipse)\t @return The first derivative vector\n\t @param ellipse The ellipse\n\t @param u The parameter\n\t @brief Compute the first derivative on a 2D ellipse at a parameter",
 "output": "#include<catch.hpp>\n#include<testHelper.h>\n\n#include <common/PointT.hpp>\n#include <math/CurveCalculation.hpp>\n\nusing namespace AMCAX;\n\nTEST_CASE(\"case1: CurveCalculation::D1 on Ellipse2\", \"[math][CurveCalculation][P1]\") {\n\tdouble u = 0.5;\n\tEllipse2 ellipse;\n\tVector2 result = AMCAX::CurveCalculation::D1(u, ellipse);\n\tCHECK(result.X() == /* expected value */);\n\tCHECK(result.Y() == /* expected value */);\n}\n\nTEST_CASE(\"case2: CurveCalculation::D1 on Ellipse2\", \"[math][CurveCalculation][P1]\") {\n\tdouble u = 1.0;\n\tEllipse2 ellipse;\n\tVector2 result = AMCAX::CurveCalculation::D1(u, ellipse);\n\tCHECK(result.X() == /* expected value */);\n\tCHECK(result.Y() == /* expected value */);\n}"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] AMCAX_API static Vector2 D1(double u, const Parabola2& parabola)\t @return The first derivative vector\n\t @param parabola The parabola\n\t @param u The parameter\n\t @brief Compute the first derivative on a 2D parabola at a parameter",
 "output": "#include<catch.hpp>\n#include<testHelper.h>\n\n#include <common/PointT.hpp>\n#include <math/CurveCalculation.hpp>\n\nusing namespace AMCAX;\n\nTEST_CASE(\"case1: CurveCalculation::D1 on Parabola2\", \"[math][CurveCalculation][P1]\") {\n\tdouble u = 0.5;\n\tParabola2 parabola;\n\tVector2 result = AMCAX::CurveCalculation::D1(u, parabola);\n\tCHECK(result.X() == /* expected value */);\n\tCHECK(result.Y() == /* expected value */);\n}\n\nTEST_CASE(\"case2: CurveCalculation::D1 on Parabola2\", \"[math][CurveCalculation][P1]\") {\n\tdouble u = 1.0;\n\tParabola2 parabola;\n\tVector2 result = AMCAX::CurveCalculation::D1(u, parabola);\n\tCHECK(result.X() == /* expected value */);\n\tCHECK(result.Y() == /* expected value */);\n}"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] AMCAX_API static Vector2 D1(double u, const Hyperbola2& hyperbola)\t @return The first derivative vector\n\t @param hyperbola The hyperbola\n\t @param u The parameter\n\t @brief Compute the first derivative on a 2D hyperbola at a parameter",
 "output": "#include<catch.hpp>\n#include<testHelper.h>\n\n#include <common/PointT.hpp>\n#include <math/CurveCalculation.hpp>\n\nusing namespace AMCAX;\n\nTEST_CASE(\"case1: CurveCalculation::D1 on Hyperbola2\", \"[math][CurveCalculation][P1]\") {\n\tdouble u = 0.5;\n\tHyperbola2 hyperbola;\n\tVector2 result = AMCAX::CurveCalculation::D1(u, hyperbola);\n\tCHECK(result.X() == /* expected value */);\n\tCHECK(result.Y() == /* expected value */);\n}\n\nTEST_CASE(\"case2: CurveCalculation::D1 on Hyperbola2\", \"[math][CurveCalculation][P1]\") {\n\tdouble u = 1.0;\n\tHyperbola2 hyperbola;\n\tVector2 result = AMCAX::CurveCalculation::D1(u, hyperbola);\n\tCHECK(result.X() == /* expected value */);\n\tCHECK(result.Y() == /* expected value */);\n}"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] AMCAX_API static Vector3 D2(double u, const Line3& line)\t @return The second derivative vector\n\t @param line The line\n\t @param u The parameter\n\t @brief Compute the second derivative on a 3D line at a parameter",
 "output": "#include<catch.hpp>\n#include<testHelper.h>\n\n#include <common/PointT.hpp>\n#include <math/CurveCalculation.hpp>\n\nusing namespace AMCAX;\n\nTEST_CASE(\"case1: CurveCalculation::D2 on Line3\", \"[math][CurveCalculation][P1]\") {\n\tdouble u = 0.5;\n\tLine3 line;\n\tVector3 result = AMCAX::CurveCalculation::D2(u, line);\n\tCHECK(result.X() == /* expected value */);\n\tCHECK(result.Y() == /* expected value */);\n\tCHECK(result.Z() == /* expected value */);\n}\n\nTEST_CASE(\"case2: CurveCalculation::D2 on Line3\", \"[math][CurveCalculation][P1]\") {\n\tdouble u = 1.0;\n\tLine3 line;\n\tVector3 result = AMCAX::CurveCalculation::D2(u, line);\n\tCHECK(result.X() == /* expected value */);\n\tCHECK(result.Y() == /* expected value */);\n\tCHECK(result.Z() == /* expected value */);\n}"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "AMCAX_API static void D2(double u, const Line3& line, Point3& p, Vector3& v1, Vector3& v2)\t @param[out] v2 The second derivative\n\t @param[out] v1 The first derivative\n\t @param[out] p The point\n\t @param[in] line The line\n\t @param[in] u The parameter\n\t @brief Compute the point and the first two derivatives on a 3D line at a parameter",
 "output": "#include<catch.hpp>\n#include<testHelper.h>\n\n#include <common/PointT.hpp>\n#include <math/CurveCalculation.hpp>\n\nusing namespace AMCAX;\n\nTEST_CASE(\"case1: CurveCalculation::D2 on Line3 with outputs\", \"[math][CurveCalculation][P1]\") {\n\tdouble u = 0.5;\n\tLine3 line;\n\tPoint3 p;\n\tVector3 v1;\n\tVector3 v2;\n\tAMCAX::CurveCalculation::D2(u, line, p, v1, v2);\n\tCHECK(p.X() == /* expected value */);\n\tCHECK(p.Y() == /* expected value */);\n\tCHECK(p.Z() == /* expected value */);\n\tCHECK(v1.X() == /* expected value */);\n\tCHECK(v1.Y() == /* expected value */);\n\tCHECK(v1.Z() == /* expected value */);\n\tCHECK(v2.X() == /* expected value */);\n\tCHECK(v2.Y() == /* expected value */);\n\tCHECK(v2.Z() == /* expected value */);\n}\n\nTEST_CASE(\"case2: CurveCalculation::D2 on Line3 with outputs\", \"[math][CurveCalculation][P1]\") {\n\tdouble u = 1.0;\n\tLine3 line;\n\tPoint3 p;\n\tVector3 v1;\n\tVector3 v2;\n\tAMCAX::CurveCalculation::D2(u, line, p, v1, v2);\n\tCHECK(p.X() == /* expected value */);\n\tCHECK(p.Y() == /* expected value */);\n\tCHECK(p.Z() == /* expected value */);\n\tCHECK(v1.X() == /* expected value */);\n\tCHECK(v1.Y() == /* expected value */);\n\tCHECK(v1.Z() == /* expected value */);\n\tCHECK(v2.X() == /* expected value */);\n\tCHECK(v2.Y() == /* expected value */);\n\tCHECK(v2.Z() == /* expected value */);\n}"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] AMCAX_API static Vector3 D2(double u, const Circle3& circle)\t @return The second derivative vector\n\t @param circle The circle\n\t @param u The parameter\n\t @brief Compute the second derivative on a 3D circle at a parameter",
 "output": "#include<catch.hpp>\n#include<testHelper.h>\n\n#include <common/PointT.hpp>\n#include <math/CurveCalculation.hpp>\n\nusing namespace AMCAX;\n\nTEST_CASE(\"case1: CurveCalculation::D2 on Circle3\", \"[math][CurveCalculation][P1]\") {\n\tdouble u = 0.5;\n\tCircle3 circle;\n\tVector3 result = AMCAX::CurveCalculation::D2(u, circle);\n\tCHECK(result.X() == /* expected value */);\n\tCHECK(result.Y() == /* expected value */);\n\tCHECK(result.Z() == /* expected value */);\n}\n\nTEST_CASE(\"case2: CurveCalculation::D2 on Circle3\", \"[math][CurveCalculation][P1]\") {\n\tdouble u = 1.0;\n\tCircle3 circle;\n\tVector3 result = AMCAX::CurveCalculation::D2(u, circle);\n\tCHECK(result.X() == /* expected value */);\n\tCHECK(result.Y() == /* expected value */);\n\tCHECK(result.Z() == /* expected value */);\n}"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] AMCAX_API static Vector3 D2(double u, const Ellipse3& ellipse)\t @return The second derivative vector\n\t @param ellipse The ellipse\n\t @param u The parameter\n\t @brief Compute the second derivative on a 3D ellipse at a parameter",
 "output": "#include<catch.hpp>\n#include<testHelper.h>\n\n#include <common/PointT.hpp>\n#include <math/CurveCalculation.hpp>\n\nusing namespace AMCAX;\n\nTEST_CASE(\"case1: CurveCalculation::D2 on Ellipse3\", \"[math][CurveCalculation][P1]\") {\n\tdouble u = 0.5;\n\tEllipse3 ellipse;\n\tVector3 result = AMCAX::CurveCalculation::D2(u, ellipse);\n\tCHECK(result.X() == /* expected value */);\n\tCHECK(result.Y() == /* expected value */);\n\tCHECK(result.Z() == /* expected value */);\n}\n\nTEST_CASE(\"case2: CurveCalculation::D2 on Ellipse3\", \"[math][CurveCalculation][P1]\") {\n\tdouble u = 1.0;\n\tEllipse3 ellipse;\n\tVector3 result = AMCAX::CurveCalculation::D2(u, ellipse);\n\tCHECK(result.X() == /* expected value */);\n\tCHECK(result.Y() == /* expected value */);\n\tCHECK(result.Z() == /* expected value */);\n}"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] AMCAX_API static Vector3 D2(double u, const Parabola3& parabola)\t @return The second derivative vector\n\t @param parabola The parabola\n\t @param u The parameter\n\t @brief Compute the second derivative on a 3D parabola at a parameter",
 "output": "#include<catch.hpp>\n#include<testHelper.h>\n\n#include <common/PointT.hpp>\n#include <math/CurveCalculation.hpp>\n\nusing namespace AMCAX;\n\nTEST_CASE(\"case1: CurveCalculation::D2 on Parabola3\", \"[math][CurveCalculation][P1]\") {\n\tdouble u = 0.5;\n\tParabola3 parabola;\n\tVector3 result = AMCAX::CurveCalculation::D2(u, parabola);\n\tCHECK(result.X() == /* expected value */);\n\tCHECK(result.Y() == /* expected value */);\n\tCHECK(result.Z() == /* expected value */);\n}\n\nTEST_CASE(\"case2: CurveCalculation::D2 on Parabola3\", \"[math][CurveCalculation][P1]\") {\n\tdouble u = 1.0;\n\tParabola3 parabola;\n\tVector3 result = AMCAX::CurveCalculation::D2(u, parabola);\n\tCHECK(result.X() == /* expected value */);\n\tCHECK(result.Y() == /* expected value */);\n\tCHECK(result.Z() == /* expected value */);\n}"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] AMCAX_API static Vector3 D2(double u, const Hyperbola3& hyperbola)\t @return The second derivative vector\n\t @param hyperbola The hyperbola\n\t @param u The parameter\n\t @brief Compute the second derivative on a 3D hyperbola at a parameter",
 "output": "#include<catch.hpp>\n#include<testHelper.h>\n\n#include <common/PointT.hpp>\n#include <math/CurveCalculation.hpp>\n\nusing namespace AMCAX;\n\nTEST_CASE(\"case1: CurveCalculation::D2 on Hyperbola3\", \"[math][CurveCalculation][P1]\") {\n\tdouble u = 0.5;\n\tHyperbola3 hyperbola;\n\tVector3 result = AMCAX::CurveCalculation::D2(u, hyperbola);\n\tCHECK(result.X() == /* expected value */);\n\tCHECK(result.Y() == /* expected value */);\n\tCHECK(result.Z() == /* expected value */);\n}\n\nTEST_CASE(\"case2: CurveCalculation::D2 on Hyperbola3\", \"[math][CurveCalculation][P1]\") {\n\tdouble u = 1.0;\n\tHyperbola3 hyperbola;\n\tVector3 result = AMCAX::CurveCalculation::D2(u, hyperbola);\n\tCHECK(result.X() == /* expected value */);\n\tCHECK(result.Y() == /* expected value */);\n\tCHECK(result.Z() == /* expected value */);\n}"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] AMCAX_API static Vector2 D2(double u, const Line2& line)\t @return The second derivative vector\n\t @param line The line\n\t @param u The parameter\n\t @brief Compute the second derivative on a 2D line at a parameter",
 "output": "#include<catch.hpp>\n#include<testHelper.h>\n\n#include <common/PointT.hpp>\n#include <math/CurveCalculation.hpp>\n\nusing namespace AMCAX;\n\nTEST_CASE(\"case1: CurveCalculation::D2 on Line2\", \"[math][CurveCalculation][P1]\") {\n\tdouble u = 0.5;\n\tLine2 line;\n\tVector2 result = AMCAX::CurveCalculation::D2(u, line);\n\tCHECK(result.X() == /* expected value */);\n\tCHECK(result.Y() == /* expected value */);\n}\n\nTEST_CASE(\"case2: CurveCalculation::D2 on Line2\", \"[math][CurveCalculation][P1]\") {\n\tdouble u = 1.0;\n\tLine2 line;\n\tVector2 result = AMCAX::CurveCalculation::D2(u, line);\n\tCHECK(result.X() == /* expected value */);\n\tCHECK(result.Y() == /* expected value */);\n}"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] AMCAX_API static Vector2 D2(double u, const Circle2& circle)\t @return The second derivative vector\n\t @param circle The circle\n\t @param u The parameter\n\t @brief Compute the second derivative on a 2D circle at a parameter",
 "output": "#include<catch.hpp>\n#include<testHelper.h>\n\n#include <common/PointT.hpp>\n#include <math/CurveCalculation.hpp>\n\nusing namespace AMCAX;\n\nTEST_CASE(\"case1: CurveCalculation::D2 on Circle2\", \"[math][CurveCalculation][P1]\") {\n\tdouble u = 0.5;\n\tCircle2 circle;\n\tVector2 result = AMCAX::CurveCalculation::D2(u, circle);\n\tCHECK(result.X() == /* expected value */);\n\tCHECK(result.Y() == /* expected value */);\n}\n\nTEST_CASE(\"case2: CurveCalculation::D2 on Circle2\", \"[math][CurveCalculation][P1]\") {\n\tdouble u = 1.0;\n\tCircle2 circle;\n\tVector2 result = AMCAX::CurveCalculation::D2(u, circle);\n\tCHECK(result.X() == /* expected value */);\n\tCHECK(result.Y() == /* expected value */);\n}"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] AMCAX_API static Vector2 D2(double u, const Ellipse2& ellipse)\t @return The second derivative vector\n\t @param ellipse The ellipse\n\t @param u The parameter\n\t @brief Compute the second derivative on a 2D ellipse at a parameter",
 "output": "#include<catch.hpp>\n#include<testHelper.h>\n\n#include <common/PointT.hpp>\n#include <math/CurveCalculation.hpp>\n\nusing namespace AMCAX;\n\nTEST_CASE(\"case1: CurveCalculation::D2 on Ellipse2\", \"[math][CurveCalculation][P1]\") {\n\tdouble u = 0.5;\n\tEllipse2 ellipse;\n\tVector2 result = AMCAX::CurveCalculation::D2(u, ellipse);\n\tCHECK(result.X() == /* expected value */);\n\tCHECK(result.Y() == /* expected value */);\n}\n\nTEST_CASE(\"case2: CurveCalculation::D2 on Ellipse2\", \"[math][CurveCalculation][P1]\") {\n\tdouble u = 1.0;\n\tEllipse2 ellipse;\n\tVector2 result = AMCAX::CurveCalculation::D2(u, ellipse);\n\tCHECK(result.X() == /* expected value */);\n\tCHECK(result.Y() == /* expected value */);\n}"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] AMCAX_API static Vector2 D2(double u, const Parabola2& parabola)\t @return The second derivative vector\n\t @param parabola The parabola\n\t @param u The parameter\n\t @brief Compute the second derivative on a 2D parabola at a parameter",
 "output": "#include<catch.hpp>\n#include<testHelper.h>\n\n#include <common/PointT.hpp>\n#include <math/CurveCalculation.hpp>\n\nusing namespace AMCAX;\n\nTEST_CASE(\"case1: CurveCalculation::D2 on Parabola2\", \"[math][CurveCalculation][P1]\") {\n\tdouble u = 0.5;\n\tParabola2 parabola;\n\tVector2 result = AMCAX::CurveCalculation::D2(u, parabola);\n\tCHECK(result.X() == /* expected value */);\n\tCHECK(result.Y() == /* expected value */);\n}\n\nTEST_CASE(\"case2: CurveCalculation::D2 on Parabola2\", \"[math][CurveCalculation][P1]\") {\n\tdouble u = 1.0;\n\tParabola2 parabola;\n\tVector2 result = AMCAX::CurveCalculation::D2(u, parabola);\n\tCHECK(result.X() == /* expected value */);\n\tCHECK(result.Y() == /* expected value */);\n}"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] AMCAX_API static Vector2 D2(double u, const Hyperbola2& hyperbola)\t @return The second derivative vector\n\t @param hyperbola The hyperbola\n\t @param u The parameter\n\t @brief Compute the second derivative on a 2D hyperbola at a parameter",
 "output": "#include<catch.hpp>\n#include<testHelper.h>\n\n#include <common/PointT.hpp>\n#include <math/CurveCalculation.hpp>\n\nusing namespace AMCAX;\n\nTEST_CASE(\"case1: CurveCalculation::D2 on Hyperbola2\", \"[math][CurveCalculation][P1]\") {\n\tdouble u = 0.5;\n\tHyperbola2 hyperbola;\n\tVector2 result = AMCAX::CurveCalculation::D2(u, hyperbola);\n\tCHECK(result.X() == /* expected value */);\n\tCHECK(result.Y() == /* expected value */);\n}\n\nTEST_CASE(\"case2: CurveCalculation::D2 on Hyperbola2\", \"[math][CurveCalculation][P1]\") {\n\tdouble u = 1.0;\n\tHyperbola2 hyperbola;\n\tVector2 result = AMCAX::CurveCalculation::D2(u, hyperbola);\n\tCHECK(result.X() == /* expected value */);\n\tCHECK(result.Y() == /* expected value */);\n}"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] AMCAX_API static Vector3 D3(double u, const Line3& line)\t @return The third derivative vector\n\t @param line The line\n\t @param u The parameter\n\t @brief Compute the third derivative on a 3D line at a parameter",
 "output": "#include<catch.hpp>\n#include<testHelper.h>\n\n#include <common/PointT.hpp>\n#include <math/CurveCalculation.hpp>\n\nusing namespace AMCAX;\n\nTEST_CASE(\"case1: CurveCalculation::D3 on Line3\", \"[math][CurveCalculation][P1]\") {\n\tdouble u = 0.5;\n\tLine3 line;\n\tVector3 result = AMCAX::CurveCalculation::D3(u, line);\n\tCHECK(result.X() == /* expected value */);\n\tCHECK(result.Y() == /* expected value */);\n\tCHECK(result.Z() == /* expected value */);\n}\n\nTEST_CASE(\"case2: CurveCalculation::D3 on Line3\", \"[math][CurveCalculation][P1]\") {\n\tdouble u = 1.0;\n\tLine3 line;\n\tVector3 result = AMCAX::CurveCalculation::D3(u, line);\n\tCHECK(result.X() == /* expected value */);\n\tCHECK(result.Y() == /* expected value */);\n\tCHECK(result.Z() == /* expected value */);\n}"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "AMCAX_API static void D3(double u, const Line3& line, Point3& p, Vector3& v1, Vector3& v2, Vector3& v3)\t @param[out] v3 The third derivative\n\t @param[out] v2 The second derivative\n\t @param[out] v1 The first derivative\n\t @param[out] p The point\n\t @param[in] line The line\n\t @param[in] u The parameter\n\t @brief Compute the point and the first three derivatives on a 3D line at a parameter",
 "output": "#include<catch.hpp>\n#include<testHelper.h>\n\n#include <common/PointT.hpp>\n#include <math/CurveCalculation.hpp>\n\nusing namespace AMCAX;\n\nTEST_CASE(\"case1: CurveCalculation::D3 on Line3 with outputs\", \"[math][CurveCalculation][P1]\") {\n\tdouble u = 0.5;\n\tLine3 line;\n\tPoint3 p;\n\tVector3 v1;\n\tVector3 v2;\n\tVector3 v3;\n\tAMCAX::CurveCalculation::D3(u, line, p, v1, v2, v3);\n\tCHECK(p.X() == /* expected value */);\n\tCHECK(p.Y() == /* expected value */);\n\tCHECK(p.Z() == /* expected value */);\n\tCHECK(v1.X() == /* expected value */);\n\tCHECK(v1.Y() == /* expected value */);\n\tCHECK(v1.Z() == /* expected value */);\n\tCHECK(v2.X() == /* expected value */);\n\tCHECK(v2.Y() == /* expected value */);\n\tCHECK(v2.Z() == /* expected value */);\n\tCHECK(v3.X() == /* expected value */);\n\tCHECK(v3.Y() == /* expected value */);\n\tCHECK(v3.Z() == /* expected value */);\n}\n\nTEST_CASE(\"case2: CurveCalculation::D3 on Line3 with outputs\", \"[math][CurveCalculation][P1]\") {\n\tdouble u = 1.0;\n\tLine3 line;\n\tPoint3 p;\n\tVector3 v1;\n\tVector3 v2;\n\tVector3 v3;\n\tAMCAX::CurveCalculation::D3(u, line, p, v1, v2, v3);\n\tCHECK(p.X() == /* expected value */);\n\tCHECK(p.Y() == /* expected value */);\n\tCHECK(p.Z() == /* expected value */);\n\tCHECK(v1.X() == /* expected value */);\n\tCHECK(v1.Y() == /* expected value */);\n\tCHECK(v1.Z() == /* expected value */);\n\tCHECK(v2.X() == /* expected value */);\n\tCHECK(v2.Y() == /* expected value */);\n\tCHECK(v2.Z() == /* expected value */);\n\tCHECK(v3.X() == /* expected value */);\n\tCHECK(v3.Y() == /* expected value */);\n\tCHECK(v3.Z() == /* expected value */);\n}"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] AMCAX_API static Vector3 D3(double u, const Circle3& circle)\t @return The third derivative vector\n\t @param circle The circle\n\t @param u The parameter\n\t @brief Compute the third derivative on a 3D circle at a parameter",
 "output": "#include<catch.hpp>\n#include<testHelper.h>\n\n#include <common/PointT.hpp>\n#include <math/CurveCalculation.hpp>\n\nusing namespace AMCAX;\n\nTEST_CASE(\"case1: CurveCalculation::D3 on Circle3\", \"[math][CurveCalculation][P1]\") {\n\tdouble u = 0.5;\n\tCircle3 circle;\n\tVector3 result = AMCAX::CurveCalculation::D3(u, circle);\n\tCHECK(result.X() == /* expected value */);\n\tCHECK(result.Y() == /* expected value */);\n\tCHECK(result.Z() == /* expected value */);\n}\n\nTEST_CASE(\"case2: CurveCalculation::D3 on Circle3\", \"[math][CurveCalculation][P1]\") {\n\tdouble u = 1.0;\n\tCircle3 circle;\n\tVector3 result = AMCAX::CurveCalculation::D3(u, circle);\n\tCHECK(result.X() == /* expected value */);\n\tCHECK(result.Y() == /* expected value */);\n\tCHECK(result.Z() == /* expected value */);\n}"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] AMCAX_API static Vector3 D3(double u, const Ellipse3& ellipse)\t @return The third derivative vector\n\t @param ellipse The ellipse\n\t @param u The parameter\n\t @brief Compute the third derivative on a 3D ellipse at a parameter",
 "output": "#include<catch.hpp>\n#include<testHelper.h>\n\n#include <common/PointT.hpp>\n#include <math/CurveCalculation.hpp>\n\nusing namespace AMCAX;\n\nTEST_CASE(\"case1: CurveCalculation::D3 on Ellipse3\", \"[math][CurveCalculation][P1]\") {\n\tdouble u = 0.5;\n\tEllipse3 ellipse;\n\tVector3 result = AMCAX::CurveCalculation::D3(u, ellipse);\n\tCHECK(result.X() == /* expected value */);\n\tCHECK(result.Y() == /* expected value */);\n\tCHECK(result.Z() == /* expected value */);\n}\n\nTEST_CASE(\"case2: CurveCalculation::D3 on Ellipse3\", \"[math][CurveCalculation][P1]\") {\n\tdouble u = 1.0;\n\tEllipse3 ellipse;\n\tVector3 result = AMCAX::CurveCalculation::D3(u, ellipse);\n\tCHECK(result.X() == /* expected value */);\n\tCHECK(result.Y() == /* expected value */);\n\tCHECK(result.Z() == /* expected value */);\n}"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] AMCAX_API static Vector3 D3(double u, const Parabola3& parabola)\t @return The third derivative vector\n\t @param parabola The parabola\n\t @param u The parameter\n\t @brief Compute the third derivative on a 3D parabola at a parameter",
 "output": "#include<catch.hpp>\n#include<testHelper.h>\n\n#include <common/PointT.hpp>\n#include <math/CurveCalculation.hpp>\n\nusing namespace AMCAX;\n\nTEST_CASE(\"case1: CurveCalculation::D3 on Parabola3\", \"[math][CurveCalculation][P1]\") {\n\tdouble u = 0.5;\n\tParabola3 parabola;\n\tVector3 result = AMCAX::CurveCalculation::D3(u, parabola);\n\tCHECK(result.X() == /* expected value */);\n\tCHECK(result.Y() == /* expected value */);\n\tCHECK(result.Z() == /* expected value */);\n}\n\nTEST_CASE(\"case2: CurveCalculation::D3 on Parabola3\", \"[math][CurveCalculation][P1]\") {\n\tdouble u = 1.0;\n\tParabola3 parabola;\n\tVector3 result = AMCAX::CurveCalculation::D3(u, parabola);\n\tCHECK(result.X() == /* expected value */);\n\tCHECK(result.Y() == /* expected value */);\n\tCHECK(result.Z() == /* expected value */);\n}"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] AMCAX_API static Vector3 D3(double u, const Hyperbola3& hyperbola)\t @return The third derivative vector\n\t @param hyperbola The hyperbola\n\t @param u The parameter\n\t @brief Compute the third derivative on a 3D hyperbola at a parameter",
 "output": "#include<catch.hpp>\n#include<testHelper.h>\n\n#include <common/PointT.hpp>\n#include <math/CurveCalculation.hpp>\n\nusing namespace AMCAX;\n\nTEST_CASE(\"case1: CurveCalculation::D3 on Hyperbola3\", \"[math][CurveCalculation][P1]\") {\n\tdouble u = 0.5;\n\tHyperbola3 hyperbola;\n\tVector3 result = AMCAX::CurveCalculation::D3(u, hyperbola);\n\tCHECK(result.X() == /* expected value */);\n\tCHECK(result.Y() == /* expected value */);\n\tCHECK(result.Z() == /* expected value */);\n}\n\nTEST_CASE(\"case2: CurveCalculation::D3 on Hyperbola3\", \"[math][CurveCalculation][P1]\") {\n\tdouble u = 1.0;\n\tHyperbola3 hyperbola;\n\tVector3 result = AMCAX::CurveCalculation::D3(u, hyperbola);\n\tCHECK(result.X() == /* expected value */);\n\tCHECK(result.Y() == /* expected value */);\n\tCHECK(result.Z() == /* expected value */);\n}"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] AMCAX_API static Vector2 D3(double u, const Line2& line)\t @return The third derivative vector\n\t @param line The line\n\t @param u The parameter\n\t @brief Compute the third derivative on a 2D line at a parameter",
 "output": "#include<catch.hpp>\n#include<testHelper.h>\n\n#include <common/PointT.hpp>\n#include <math/CurveCalculation.hpp>\n\nusing namespace AMCAX;\n\nTEST_CASE(\"case1: CurveCalculation::D3 on Line2\", \"[math][CurveCalculation][P1]\") {\n\tdouble u = 0.5;\n\tLine2 line;\n\tVector2 result = AMCAX::CurveCalculation::D3(u, line);\n\tCHECK(result.X() == /* expected value */);\n\tCHECK(result.Y() == /* expected value */);\n}\n\nTEST_CASE(\"case2: CurveCalculation::D3 on Line2\", \"[math][CurveCalculation][P1]\") {\n\tdouble u = 1.0;\n\tLine2 line;\n\tVector2 result = AMCAX::CurveCalculation::D3(u, line);\n\tCHECK(result.X() == /* expected value */);\n\tCHECK(result.Y() == /* expected value */);\n}"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] AMCAX_API static Vector2 D3(double u, const Circle2& circle)\t @return The third derivative vector\n\t @param circle The circle\n\t @param u The parameter\n\t @brief Compute the third derivative on a 2D circle at a parameter",
 "output": "#include<catch.hpp>\n#include<testHelper.h>\n\n#include <common/PointT.hpp>\n#include <math/CurveCalculation.hpp>\n\nusing namespace AMCAX;\n\nTEST_CASE(\"case1: CurveCalculation::D3 on Circle2\", \"[math][CurveCalculation][P1]\") {\n\tdouble u = 0.5;\n\tCircle2 circle;\n\tVector2 result = AMCAX::CurveCalculation::D3(u, circle);\n\tCHECK(result.X() == /* expected value */);\n\tCHECK(result.Y() == /* expected value */);\n}\n\nTEST_CASE(\"case2: CurveCalculation::D3 on Circle2\", \"[math][CurveCalculation][P1]\") {\n\tdouble u = 1.0;\n\tCircle2 circle;\n\tVector2 result = AMCAX::CurveCalculation::D3(u, circle);\n\tCHECK(result.X() == /* expected value */);\n\tCHECK(result.Y() == /* expected value */);\n}"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] AMCAX_API static Vector2 D3(double u, const Ellipse2& ellipse)\t @return The third derivative vector\n\t @param ellipse The ellipse\n\t @param u The parameter\n\t @brief Compute the third derivative on a 2D ellipse at a parameter",
 "output": "#include<catch.hpp>\n#include<testHelper.h>\n\n#include <common/PointT.hpp>\n#include <math/CurveCalculation.hpp>\n\nusing namespace AMCAX;\n\nTEST_CASE(\"case1: CurveCalculation::D3 on Ellipse2\", \"[math][CurveCalculation][P1]\") {\n\tdouble u = 0.5;\n\tEllipse2 ellipse;\n\tVector2 result = AMCAX::CurveCalculation::D3(u, ellipse);\n\tCHECK(result.X() == /* expected value */);\n\tCHECK(result.Y() == /* expected value */);\n}\n\nTEST_CASE(\"case2: CurveCalculation::D3 on Ellipse2\", \"[math][CurveCalculation][P1]\") {\n\tdouble u = 1.0;\n\tEllipse2 ellipse;\n\tVector2 result = AMCAX::CurveCalculation::D3(u, ellipse);\n\tCHECK(result.X() == /* expected value */);\n\tCHECK(result.Y() == /* expected value */);\n}"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] AMCAX_API static Vector2 D3(double u, const Parabola2& parabola)\t @return The third derivative vector\n\t @param parabola The parabola\n\t @param u The parameter\n\t @brief Compute the third derivative on a 2D parabola at a parameter",
 "output": "#include<catch.hpp>\n#include<testHelper.h>\n\n#include <common/PointT.hpp>\n#include <math/CurveCalculation.hpp>\n\nusing namespace AMCAX;\n\nTEST_CASE(\"case1: CurveCalculation::D3 on Parabola2\", \"[math][CurveCalculation][P1]\") {\n\tdouble u = 0.5;\n\tParabola2 parabola;\n\tVector2 result = AMCAX::CurveCalculation::D3(u, parabola);\n\tCHECK(result.X() == /* expected value */);\n\tCHECK(result.Y() == /* expected value */);\n}\n\nTEST_CASE(\"case2: CurveCalculation::D3 on Parabola2\", \"[math][CurveCalculation][P1]\") {\n\tdouble u = 1.0;\n\tParabola2 parabola;\n\tVector2 result = AMCAX::CurveCalculation::D3(u, parabola);\n\tCHECK(result.X() == /* expected value */);\n\tCHECK(result.Y() == /* expected value */);\n}"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] AMCAX_API static Vector2 D3(double u, const Hyperbola2& hyperbola)\t @return The third derivative vector\n\t @param hyperbola The hyperbola\n\t @param u The parameter\n\t @brief Compute the third derivative on a 2D hyperbola at a parameter",
 "output": "#include<catch.hpp>\n#include<testHelper.h>\n\n#include <common/PointT.hpp>\n#include <math/CurveCalculation.hpp>\n\nusing namespace AMCAX;\n\nTEST_CASE(\"case1: CurveCalculation::D3 on Hyperbola2\", \"[math][CurveCalculation][P1]\") {\n\tdouble u = 0.5;\n\tHyperbola2 hyperbola;\n\tVector2 result = AMCAX::CurveCalculation::D3(u, hyperbola);\n\tCHECK(result.X() == /* expected value */);\n\tCHECK(result.Y() == /* expected value */);\n}\n\nTEST_CASE(\"case2: CurveCalculation::D3 on Hyperbola2\", \"[math][CurveCalculation][P1\") {\n\tdouble u = 1.0;\n\tHyperbola2 hyperbola;\n\tVector2 result = AMCAX::CurveCalculation::D3(u, hyperbola);\n\tCHECK(result.X() == /* expected value */);\n\tCHECK(result.Y() == /* expected value */);\n}"}{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "AMCAX_API static void AdjustPeriodic(double ufirst, double ulast, double precision, double& u1, double& u2)\n\t @paramin,out u2 The second parameter to be adjust\n\t @param[in,out] u1 The first parameter to be adjust\n\t @param[in] precision The precision to check equality\n\t @param[in] ulast The upper bound of the period\n\t @param[in] ufirst The lower bound of the period\n\t          The parameter u2 is set in the range [u1, u1 + ulast - ufirst]\n\t @details The parameter u1 is set in the range [ufirst, ulast]\n\t @brief Adjust u1 and u2 to be in the period range.",
 "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <common/PointT.hpp>\n#include <math/CurveCalculation.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <geometry/MakeArcOfHyperbola2d.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <modeling/MakeEdge2d.hpp>\n\nusing namespace AMCAX;\n\nTEST_CASE(\"AdjustPeriodic Test Case\", \"[AdjustPeriodic]\") {\n\tdouble u1, u2;\n\tAdjustPeriodic(0.0, 10.0, 0.01, u1, u2);\n\tCHECK(u1 >= 0.0);\n\tCHECK(u2 <= 10.0);\n}"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] AMCAX_API static Point3 D0(double u, const Line3& line)\n\t @return The resulting point\n\t @param line The line\n\t @param u The parameter\n\t @brief Compute the point on a 3D line at a parameter",
 "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <common/PointT.hpp>\n#include <math/CurveCalculation.hpp>\n#include <occtio/OCCTTool.hpp>\n\nusing namespace AMCAX;\n\nTEST_CASE(\"D0 with Line3\", \"[D0]\") {\n\tLine3 line(...);\n\tPoint3 result = D0(1.0, line);\n\tCHECK(result.X() == ...);\n\tCHECK(result.Y() == ...);\n\tCHECK(result.Z() == ...);\n}"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] AMCAX_API static Point3 D0(double u, const Circle3& circle)\n\t @return The resulting point\n\t @param circle The circle\n\t @param u The parameter\n\t @brief Compute the point on a 3D circle at a parameter",
 "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <common/PointT.hpp>\n#include <math/CurveCalculation.hpp>\n#include <occtio/OCCTTool.hpp>\n\nusing namespace AMCAX;\n\nTEST_CASE(\"D0 with Circle3\", \"[D0]\") {\n\tCircle3 circle(...);\n\tPoint3 result = D0(1.0, circle);\n\tCHECK(result.X() == ...);\n\tCHECK(result.Y() == ...);\n\tCHECK(result.Z() == ...);\n}"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] AMCAX_API static Point3 D0(double u, const Ellipse3& ellipse)\n\t @return The resulting point\n\t @param ellipse The ellipse\n\t @param u The parameter\n\t @brief Compute the point on a 3D ellipse at a parameter",
 "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <common/PointT.hpp>\n#include <math/CurveCalculation.hpp>\n#include <occtio/OCCTTool.hpp>\n\nusing namespace AMCAX;\n\nTEST_CASE(\"D0 with Ellipse3\", \"[D0]\") {\n\tEllipse3 ellipse(...);\n\tPoint3 result = D0(1.0, ellipse);\n\tCHECK(result.X() == ...);\n\tCHECK(result.Y() == ...);\n\tCHECK(result.Z() == ...);\n}"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] AMCAX_API static Point3 D0(double u, const Parabola3& parabola)\n\t @return The resulting point\n\t @param parabola The parabola\n\t @param u The parameter\n\t @brief Compute the point on a 3D parabola at a parameter",
 "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <common/PointT.hpp>\n#include <math/CurveCalculation.hpp>\n#include <occtio/OCCTTool.hpp>\n\nusing namespace AMCAX;\n\nTEST_CASE(\"D0 with Parabola3\", \"[D0]\") {\n\tParabola3 parabola(...);\n\tPoint3 result = D0(1.0, parabola);\n\tCHECK(result.X() == ...);\n\tCHECK(result.Y() == ...);\n\tCHECK(result.Z() == ...);\n}"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] AMCAX_API static Point3 D0(double u, const Hyperbola3& hyperbola)\n\t @return The resulting point\n\t @param hyperbola The hyperbola\n\t @param u The parameter\n\t @brief Compute the point on a 3D hyperbola at a parameter",
 "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <common/PointT.hpp>\n#include <math/CurveCalculation.hpp>\n#include <occtio/OCCTTool.hpp>\n\nusing namespace AMCAX;\n\nTEST_CASE(\"D0 with Hyperbola3\", \"[D0]\") {\n\tHyperbola3 hyperbola(...);\n\tPoint3 result = D0(1.0, hyperbola);\n\tCHECK(result.X() == ...);\n\tCHECK(result.Y() == ...);\n\tCHECK(result.Z() == ...);\n}"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] AMCAX_API static Point2 D0(double u, const Line2& line)\n\t @return The resulting point\n\t @param line The line\n\t @param u The parameter\n\t @brief Compute the point on a 2D line at a parameter",
 "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <common/PointT.hpp>\n#include <math/CurveCalculation.hpp>\n#include <occtio/OCCTTool.hpp>\n\nusing namespace AMCAX;\n\nTEST_CASE(\"D0 with Line2\", \"[D0]\") {\n\tLine2 line(...);\n\tPoint2 result = D0(1.0, line);\n\tCHECK(result.X() == ...);\n\tCHECK(result.Y() == ...);\n}"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] AMCAX_API static Point2 D0(double u, const Circle2& circle)\n\t @return The resulting point\n\t @param circle The circle\n\t @param u The parameter\n\t @brief Compute the point on a 2D circle at a parameter",
 "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <common/PointT.hpp>\n#include <math/CurveCalculation.hpp>\n#include <occtio/OCCTTool.hpp>\n\nusing namespace AMCAX;\n\nTEST_CASE(\"D0 with Circle2\", \"[D0]\") {\n\tCircle2 circle(...);\n\tPoint2 result = D0(1.0, circle);\n\tCHECK(result.X() == ...);\n\tCHECK(result.Y() == ...);\n}"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] AMCAX_API static Point2 D0(double u, const Ellipse2& ellipse)\n\t @return The resulting point\n\t @param ellipse The ellipse\n\t @param u The parameter\n\t @brief Compute the point on a 2D ellipse at a parameter",
 "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <common/PointT.hpp>\n#include <math/CurveCalculation.hpp>\n#include <occtio/OCCTTool.hpp>\n\nusing namespace AMCAX;\n\nTEST_CASE(\"D0 with Ellipse2\", \"[D0]\") {\n\tEllipse2 ellipse(...);\n\tPoint2 result = D0(1.0, ellipse);\n\tCHECK(result.X() == ...);\n\tCHECK(result.Y() == ...);\n}"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] AMCAX_API static Point2 D0(double u, const Parabola2& parabola)\n\t @return The resulting point\n\t @param parabola The parabola\n\t @param u The parameter\n\t @brief Compute the point on a 2D parabola at a parameter",
 "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <common/PointT.hpp>\n#include <math/CurveCalculation.hpp>\n#include <occtio/OCCTTool.hpp>\n\nusing namespace AMCAX;\n\nTEST_CASE(\"D0 with Parabola2\", \"[D0]\") {\n\tParabola2 parabola(...);\n\tPoint2 result = D0(1.0, parabola);\n\tCHECK(result.X() == ...);\n\tCHECK(result.Y() == ...);\n}"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] AMCAX_API static Point2 D0(double u, const Hyperbola2& hyperbola)\n\t @return The resulting point\n\t @param hyperbola The hyperbola\n\t @param u The parameter\n\t @brief Compute the point on a 2D hyperbola at a parameter",
 "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <common/PointT.hpp>\n#include <math/CurveCalculation.hpp>\n#include <occtio/OCCTTool.hpp>\n\nusing namespace AMCAX;\n\nTEST_CASE(\"D0 with Hyperbola2\", \"[D0]\") {\n\tHyperbola2 hyperbola(...);\n\tPoint2 result = D0(1.0, hyperbola);\n\tCHECK(result.X() == ...);\n\tCHECK(result.Y() == ...);\n}"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] AMCAX_API static Vector3 D1(double u, const Line3& line)\n\t @return The first derivative vector\n\t @param line The line\n\t @param u The parameter\n\t @brief Compute the first derivative on a 3D line at a parameter",
 "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <common/PointT.hpp>\n#include <math/CurveCalculation.hpp>\n#include <occtio/OCCTTool.hpp>\n\nusing namespace AMCAX;\n\nTEST_CASE(\"D1 with Line3\", \"[D1]\") {\n\tLine3 line(...);\n\tVector3 result = D1(1.0, line);\n\tCHECK(result.X() == ...);\n\tCHECK(result.Y() == ...);\n\tCHECK(result.Z() == ...);\n}"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "AMCAX_API static void D1(double u, const Line3& line, Point3& p, Vector3& v1)\n\t @param[out] v1 The first derivative\n\t @param[out] p The point\n\t @param[in] line The line\n\t @param[in] u The parameter\n\t @brief Compute the point and the first derivative on a 3D line at a parameter",
 "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <common/PointT.hpp>\n#include <math/CurveCalculation.hpp>\n#include <occtio/OCCTTool.hpp>\n\nusing namespace AMCAX;\n\nTEST_CASE(\"D1 with Line3\", \"[D1]\") {\n\tLine3 line(...);\n\tPoint3 p;\n\tVector3 v1;\n\tD1(1.0, line, p, v1);\n\tCHECK(p.X() == ...);\n\tCHECK(p.Y() == ...);\n\tCHECK(p.Z() == ...);\n\tCHECK(v1.X() == ...);\n\tCHECK(v1.Y() == ...);\n\tCHECK(v1.Z() == ...);\n}"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] AMCAX_API static Vector3 D1(double u, const Circle3& circle)\n\t @return The first derivative vector\n\t @param circle The circle\n\t @param u The parameter\n\t @brief Compute the first derivative on a 3D circle at a parameter",
 "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <common/PointT.hpp>\n#include <math/CurveCalculation.hpp>\n#include <occtio/OCCTTool.hpp>\n\nusing namespace AMCAX;\n\nTEST_CASE(\"D1 with Circle3\", \"[D1]\") {\n\tCircle3 circle(...);\n\tVector3 result = D1(1.0, circle);\n\tCHECK(result.X() == ...);\n\tCHECK(result.Y() == ...);\n\tCHECK(result.Z() == ...);\n}"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "AMCAX_API static void D1(double u, const Circle3& circle, Point3& p, Vector3& v1)\n\t @param[out] v1 The first derivative\n\t @param[out] p The point\n\t @param[in] circle The circle\n\t @param[in] u The parameter\n\t @brief Compute the point and the first derivative on a 3D circle at a parameter",
 "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <common/PointT.hpp>\n#include <math/CurveCalculation.hpp>\n#include <occtio/OCCTTool.hpp>\n\nusing namespace AMCAX;\n\nTEST_CASE(\"D1 with Circle3\", \"[D1]\") {\n\tCircle3 circle(...);\n\tPoint3 p;\n\tVector3 v1;\n\tD1(1.0, circle, p, v1);\n\tCHECK(p.X() == ...);\n\tCHECK(p.Y() == ...);\n\tCHECK(p.Z() == ...);\n\tCHECK(v1.X() == ...);\n\tCHECK(v1.Y() == ...);\n\tCHECK(v1.Z() == ...);\n}"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] AMCAX_API static Vector3 D1(double u, const Ellipse3& ellipse)\n\t @return The first derivative vector\n\t @param ellipse The ellipse\n\t @param u The parameter\n\t @brief Compute the first derivative on a 3D ellipse at a parameter",
 "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <common/PointT.hpp>\n#include <math/CurveCalculation.hpp>\n#include <occtio/OCCTTool.hpp>\n\nusing namespace AMCAX;\n\nTEST_CASE(\"D1 with Ellipse3\", \"[D1]\") {\n\tEllipse3 ellipse(...);\n\tVector3 result = D1(1.0, ellipse);\n\tCHECK(result.X() == ...);\n\tCHECK(result.Y() == ...);\n\tCHECK(result.Z() == ...);\n}"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "AMCAX_API static void D1(double u, const Ellipse3& ellipse, Point3& p, Vector3& v1)\n\t @param[out] v1 The first derivative\n\t @param[out] p The point\n\t @param[in] ellipse The ellipse\n\t @param[in] u The parameter\n\t @brief Compute the point and the first derivative on a 3D ellipse at a parameter",
 "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <common/PointT.hpp>\n#include <math/CurveCalculation.hpp>\n#include <occtio/OCCTTool.hpp>\n\nusing namespace AMCAX;\n\nTEST_CASE(\"D1 with Ellipse3\", \"[D1]\") {\n\tEllipse3 ellipse(...);\n\tPoint3 p;\n\tVector3 v1;\n\tD1(1.0, ellipse, p, v1);\n\tCHECK(p.X() == ...);\n\tCHECK(p.Y() == ...);\n\tCHECK(p.Z() == ...);\n\tCHECK(v1.X() == ...);\n\tCHECK(v1.Y() == ...);\n\tCHECK(v1.Z() == ...);\n}"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] AMCAX_API static Vector3 D1(double u, const Parabola3& parabola)\n\t @return The first derivative vector\n\t @param parabola The parabola\n\t @param u The parameter\n\t @brief Compute the first derivative on a 3D parabola at a parameter",
 "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <common/PointT.hpp>\n#include <math/CurveCalculation.hpp>\n#include <occtio/OCCTTool.hpp>\n\nusing namespace AMCAX;\n\nTEST_CASE(\"D1 with Parabola3\", \"[D1]\") {\n\tParabola3 parabola(...);\n\tVector3 result = D1(1.0, parabola);\n\tCHECK(result.X() == ...);\n\tCHECK(result.Y() == ...);\n\tCHECK(result.Z() == ...);\n}"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "AMCAX_API static void D1(double u, const Parabola3& parabola, Point3& p, Vector3& v1)\n\t @param[out] v1 The first derivative\n\t @param[out] p The point\n\t @param[in] parabola The parabola\n\t @param[in] u The parameter\n\t @brief Compute the point and the first derivative on a 3D parabola at a parameter",
 "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <common/PointT.hpp>\n#include <math/CurveCalculation.hpp>\n#include <occtio/OCCTTool.hpp>\n\nusing namespace AMCAX;\n\nTEST_CASE(\"D1 with Parabola3\", \"[D1]\") {\n\tParabola3 parabola(...);\n\tPoint3 p;\n\tVector3 v1;\n\tD1(1.0, parabola, p, v1);\n\tCHECK(p.X() == ...);\n\tCHECK(p.Y() == ...);\n\tCHECK(p.Z() == ...);\n\tCHECK(v1.X() == ...);\n\tCHECK(v1.Y() == ...);\n\tCHECK(v1.Z() == ...);\n}"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] AMCAX_API static Vector3 D1(double u, const Hyperbola3& hyperbola)\n\t @return The first derivative vector\n\t @param hyperbola The hyperbola\n\t @param u The parameter\n\t @brief Compute the first derivative on a 3D hyperbola at a parameter",
 "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <common/PointT.hpp>\n#include <math/CurveCalculation.hpp>\n#include <occtio/OCCTTool.hpp>\n\nusing namespace AMCAX;\n\nTEST_CASE(\"D1 with Hyperbola3\", \"[D1]\") {\n\tHyperbola3 hyperbola(...);\n\tVector3 result = D1(1.0, hyperbola);\n\tCHECK(result.X() == ...);\n\tCHECK(result.Y() == ...);\n\tCHECK(result.Z() == ...);\n}"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "AMCAX_API static void D1(double u, const Hyperbola3& hyperbola, Point3& p, Vector3& v1)\n\t @param[out] v1 The first derivative\n\t @param[out] p The point\n\t @param[in] hyperbola The hyperbola\n\t @param[in] u The parameter\n\t @brief Compute the point and the first derivative on a 3D hyperbola at a parameter",
 "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <common/PointT.hpp>\n#include <math/CurveCalculation.hpp>\n#include <occtio/OCCTTool.hpp>\n\nusing namespace AMCAX;\n\nTEST_CASE(\"D1 with Hyperbola3\", \"[D1]\") {\n\tHyperbola3 hyperbola(...);\n\tPoint3 p;\n\tVector3 v1;\n\tD1(1.0, hyperbola, p, v1);\n\tCHECK(p.X() == ...);\n\tCHECK(p.Y() == ...);\n\tCHECK(p.Z() == ...);\n\tCHECK(v1.X() == ...);\n\tCHECK(v1.Y() == ...);\n\tCHECK(v1.Z() == ...);\n}"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] AMCAX_API static Vector2 D1(double u, const Line2& line)\n\t @return The first derivative vector\n\t @param line The line\n\t @param u The parameter\n\t @brief Compute the first derivative on a 2D line at a parameter",
 "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <common/PointT.hpp>\n#include <math/CurveCalculation.hpp>\n#include <occtio/OCCTTool.hpp>\n\nusing namespace AMCAX;\n\nTEST_CASE(\"D1 with Line2\", \"[D1]\") {\n\tLine2 line(...);\n\tVector2 result = D1(1.0, line);\n\tCHECK(result.X() == ...);\n\tCHECK(result.Y() == ...);\n}"}{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "Cylinder()\n @brief Default constructor",
 "output": "#include <catch.hpp>\n#include <testHelper.h>\n\n#include <common/FrameT.hpp>\n#include <modeling/MakeFace.hpp>\n#include <common/AxisT.hpp>\n#include <math/Cylinder.hpp>\n#include <common/VectorT.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <modeling/MakeCylinder.hpp>\n#include <iostream>\n\nusing namespace AMCAX;\nusing namespace std;\n\nTEST_CASE(\"case1:this is a case for Test Cylinder\", \"math][Cylinder][P1]\")\n\n\tCylinder cylinder;\n\tCHECK(cylinder.Location().X() == Approx(0.0));\n\tCHECK(cylinder.Location().Y() == Approx(0.0));\n\tCHECK(cylinder.Location().Z() == Approx(0.0));"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "AMCAX_API Cylinder(const Frame3& frame, double r)\n @param r The radius\n @param frame The local frame\n @brief Construct from a local frame and a radius",
 "output": "#include <catch.hpp>\n#include <testHelper.h>\n\n#include <common/FrameT.hpp>\n#include <modeling/MakeFace.hpp>\n#include <common/AxisT.hpp>\n#include <math/Cylinder.hpp>\n#include <common/VectorT.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <modeling/MakeCylinder.hpp>\n#include <iostream>\n\nusing namespace AMCAX;\nusing namespace std;\n\nTEST_CASE(\"case2:this is a case for Test Cylinder Constructor\", \"[math][Cylinder][P1]\")\n\n\tFrame3 frame;\n\tdouble radius = 5.0;\n\tCylinder cylinder(frame, radius);\n\tCHECK(cylinder.Radius() == Approx(radius));\n\tCHECK(cylinder.Location().X() == Approx(0.0));\n\tCHECK(cylinder.Location().Y() == Approx(0.0));\n\tCHECK(cylinder.Location().Z() == Approx(0.0));"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "AMCAX_API Cylinder& Scale(const Point3& point, double scale)\n @return The reference to self\n @param scale The scale value\n @param point The scaling center point\n @brief Scale the cylinder by a point",
 "output": "#include <catch.hpp>\n#include <testHelper.h>\n\n#include <common/FrameT.hpp>\n#include <modeling/MakeFace.hpp>\n#include <common/AxisT.hpp>\n#include <math/Cylinder.hpp>\n#include <common/VectorT.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <modeling/MakeCylinder.hpp>\n#include <iostream>\n\nusing namespace AMCAX;\nusing namespace std;\n\nTEST_CASE(\"case3:this is a case for Test Cylinder Scale\", \"[math][Cylinder][P1]\")\n\n\tPoint3 point(6.0, 0.0, 0.0);\n\tdouble scaleValue = 2.0;\n\tCylinder cylinder;\n\tcylinder.Scale(point, scaleValue);\n\tCHECK(cylinder.Radius() == Approx(10.0));"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "AMCAX_API Cylinder& Transform(const Transformation3& tr)\n @return The reference to self\n @param tr The transformation\n @brief Transform the cylinder",
 "output": "#include <catch.hpp>\n#include <testHelper.h>\n\n#include <common/FrameT.hpp>\n#include <modeling/MakeFace.hpp>\n#include <common/AxisT.hpp>\n#include <math/Cylinder.hpp>\n#include <common/VectorT.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <modeling/MakeCylinder.hpp>\n#include <iostream>\n\nusing namespace AMCAX;\nusing namespace std;\n\nTEST_CASE(\"case4:this is a case for Test Cylinder Transform\", \"[math][Cylinder][P1\")\n\n\tTransformation3 tr;\n\ttr.SetTranslation(Vector3(1.0, 2.0, 3.0));\n\tCylinder cylinder;\n\tcylinder.Transform(tr);\n\tCHECK(cylinder.Location().X() == Approx(1.0));\n\tCHECK(cylinder.Location().Y() == Approx(2.0));\n\tCHECK(cylinder.Location().Z() == Approx(3.0));"}{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] double Area()\t @return The area of the ellipse\n\t @brief Get the area of the ellipse\nEllipseS& Scale(const PointT<double, DIM>& point, double scale)\t @return The reference to self\n\t @param scale The scale value\n\t @param point The scaling center point\n\t @brief Scale the ellipse by a center point\nEllipseS& Transform(const TransformationT<double, DIM>& tr)\t @return The reference to self\n\t @param tr The transformation\n\t @brief Transform the ellipse\n",
 "output": "#include <catch.hpp>\n#include <testHelper.h>\n\n#include <math/EllipseT.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n\nusing namespace AMCAX;\nusing namespace std;\n\nTEST_CASE(\"case1:this is a case for Test Geom2Ellipse\", \"[math][Geom2Ellipse][P1]\")\n\n\t//Geom2Ellipse构造函数调用\n\tAxis2 axis;//默认二维坐标系中为X轴方向(1.0，0.0)\n\tdouble major = 5.0;\n\tdouble minor = 4.0;\n\tbool isRight = true;\n\tEllipse2 ellipse(axis, major, minor, isRight);\n\tGeom2Ellipse g2e(ellipse);\n\n\t//FocalParameter()函数调用，获取焦点到圆锥曲线准线的距离\n\tSECTION(\"FocalParameter\")\n\t\n\t\tdouble FP = g2e.FocalParameter();\n\t\tdouble focal = 2 * sqrt(major * major - minor * minor);\n\t\tdouble fp = 2 * minor * minor / focal;;\n\t\tCHECK(FP == fp);\n\t\n\n\t//SemilatusRectum函数调用\n\tSECTION(\"SemilatusRectum\")\n\t\n\t\tdouble SR = g2e.SemilatusRectum();\n\t\tdouble sr = minor * minor / major;\n\t\tCHECK(SR == sr);\n\t\n\n\n"}{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] double Area()\t @return The area of the ellipse\n\t @brief Get the area of the ellipse",
 "output": "#include <catch.hpp>\n#include <testHelper.h>\n\n#include <common/FrameT.hpp>\n#include <math/EllipseT.hpp>\n#include <geometry/Geom3Ellipse.hpp>\n\nusing namespace AMCAX;\nusing namespace std;\n\nTEST_CASE(\"case1:this is a case for Test Geom3Ellipse\", \"[math][Geom3Ellipse][P1]\")\n\n\t//Geom3Ellipse构造函数调用\n\tFrame3 frame;\n\tdouble major = 5.0;\n\tdouble minor = 4.0;\n\tEllipse3 ellipse(frame, major, minor);\n\tGeom3Ellipse g3e(ellipse);\n\n\t//FocalParameter()函数调用，获取焦点到圆锥曲线准线的距离\n\tSECTION(\"FocalParameter\")\n\t\n\t\tdouble FP = g3e.FocalParameter();\n\t\tdouble focal = 2 * sqrt(major * major - minor * minor);\n\t\tdouble fp = 2 * minor * minor / focal;;\n\t\tCHECK(FP == fp);\n\t\n\n\t//SemilatusRectum函数调用\n\tSECTION(\"SemilatusRectum\")\n\t\n\t\tdouble SR = g3e.SemilatusRectum();\n\t\tdouble sr = minor * minor / major;\n\t\tCHECK(SR == sr);\n\t\n\n"}
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "EllipseS& Scale(const PointT<double, DIM>& point, double scale)\t @return The reference to self\n\t @param scale The scale value\n\t @param point The scaling center point\n\t @brief Scale the ellipse by a center point",
 "output": "#include <catch.hpp>\n#include <testHelper.h>\n\n#include <common/FrameT.hpp>\n#include <math/EllipseT.hpp>\n#include <geometry/Geom3Ellipse.hpp>\n\nusing namespace AMCAX;\nusing namespace std;\n\nTEST_CASE(\"case2: Test Scale method of Ellipse\", \"[math][Ellipse][Scale]\")\n\n\tFrame3 frame;\n\tEllipseS ellipse(frame);\n\tPointT<double, DIM> center(0.0, 0.0);\n\tdouble scale = 2.0;\n\tEllipseS& scaledEllipse = ellipse.Scale(center, scale);\n\tCHECK(&scaledEllipse == &ellipse);\n\n"}
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "EllipseS& Transform(const TransformationT<double, DIM>& tr)\t @return The reference to self\n\t @param tr The transformation\n\t @brief Transform the ellipse",
 "output": "#include <catch.hpp>\n#include <testHelper.h>\n\n#include <common/FrameT.hpp>\n#include <math/EllipseT.hpp>\n#include <geometry/Geom3Ellipse.hpp>\n\nusing namespace AMCAX;\nusing namespace std;\n\nTEST_CASE(\"case3: Test Transform method of Ellipse\", \"[math][Ellipse][Transform]\")\n\n\tFrame3 frame;\n\tEllipseS ellipse(frame);\n\tTransformationT<double, DIM> transformation;\n\tEllipseS& transformedEllipse = ellipse.Transform(transformation);\n\tCHECK(&transformedEllipse == &ellipse);\n\n"}{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] double Area()\t @return The area of the ellipse\n\t @brief Get the area of the ellipse",
 "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/MakeGeom3Ellipse.hpp>\n#include <common/DirectionT.hpp>\n#include <common/PointT.hpp>\n#include <common/Precision.hpp>\n#include <topology/TopoEdge.hpp>\n#include <topology/TopoWire.hpp>\n#include <topology/TopoFace.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeWire.hpp>\n#include <modeling/MakeFace.hpp>\n#include <modeling/MakePrism.hpp>\n#include <topomesh/BRepMeshIncrementalMesh.hpp>\n#include <topology/TopoExplorerTool.hpp>\n#include <topology/TopoExplorer.hpp>\n#include <topology/TopoCast.hpp>\n#include <topology/TopoTool.hpp>\n#include <math/TriangularMesh.hpp>\n\nTEST_CASE(\"Calculate Area of Ellipse\", \"[geometry][MakeGeom3Ellipse]\")\n{\n\tMakeGeom3Ellipse makeEllipse(Frame3(), 3.0, 1.0);\n\tdouble area = makeEllipse.Area();\n\tCHECK(area > 0);\n}"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "EllipseS& Scale(const PointT<double, DIM>& point, double scale)\t @return The reference to self\n\t @param scale The scale value\n\t @param point The scaling center point\n\t @brief Scale the ellipse by a center point",
 "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/MakeGeom3Ellipse.hpp>\n#include <common/DirectionT.hpp>\n#include <common/PointT.hpp>\n#include <common/Precision.hpp>\n#include <topology/TopoEdge.hpp>\n#include <topology/TopoWire.hpp>\n#include <topology/TopoFace.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeWire.hpp>\n#include <modeling/MakeFace.hpp>\n#include <modeling/MakePrism.hpp>\n#include <topomesh/BRepMeshIncrementalMesh.hpp>\n#include <topology/TopoExplorerTool.hpp>\n#include <topology/TopoExplorer.hpp>\n#include <topology/TopoCast.hpp>\n#include <topology/TopoTool.hpp>\n#include <math/TriangularMesh.hpp>\n\nTEST_CASE(\"Scale Ellipse\", \"[geometry][MakeGeom3Ellipse]\")\n{\n\tEllipseS ellipse;\n\tPointT<double, DIM> center(0.0, 0.0);\n\tdouble scale = 2.0;\n\tEllipseS& scaledEllipse = ellipse.Scale(center, scale);\n\tCHECK(&scaledEllipse == &ellipse);\n}"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "EllipseS& Transform(const TransformationT<double, DIM>& tr)\t @return The reference to self\n\t @param tr The transformation\n\t @brief Transform the ellipse",
 "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/MakeGeom3Ellipse.hpp>\n#include <common/DirectionT.hpp>\n#include <common/PointT.hpp>\n#include <common/Precision.hpp>\n#include <topology/TopoEdge.hpp>\n#include <topology/TopoWire.hpp>\n#include <topology/TopoFace.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeWire.hpp>\n#include <modeling/MakeFace.hpp>\n#include <modeling/MakePrism.hpp>\n#include <topomesh/BRepMeshIncrementalMesh.hpp>\n#include <topology/TopoExplorerTool.hpp>\n#include <topology/TopoExplorer.hpp>\n#include <topology/TopoCast.hpp>\n#include <topology/TopoTool.hpp>\n#include <math/TriangularMesh.hpp>\n\nTEST_CASE(\"Transform Ellipse\", \"[geometry][MakeGeom3Ellipse]\")\n{\n\tEllipseS ellipse;\n\tTransformationT<double, DIM> transformation;\n\tEllipseS& transformedEllipse = ellipse.Transform(transformation);\n\tCHECK(&transformedEllipse == &ellipse);\n}"}{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] double Area()\n @return The area of the ellipse\n @brief Get the area of the ellipse",
 "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <common/FrameT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <math/EllipseT.hpp>\n\nTEST_CASE(\"case1:this is a case for Test Ellipse2\", \"[math][Ellipse2][P1]\")\n\tAxis2 axis;\n\tdouble major = 5.0;\n\tdouble minor = 4.0;\n\tEllipse2 ellipse(axis, major, minor, true);\n\tCHECK(ellipse.Area() == Approx(M_PI * major * minor));"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "EllipseS& Scale(const PointT<double, DIM>& point, double scale)\n @return The reference to self\n @param scale The scale value\n @param point The scaling center point\n @brief Scale the ellipse by a center point",
 "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <common/FrameT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <math/EllipseT.hpp>\n\nTEST_CASE(\"case3:this is a case for Test-Ellipse2-Scale\", \"[math][Ellipse2][P1]\")\n\tPoint2 point(-1.0, -2.0);\n\tdouble scale = 0.5;\n\tEllipse2 ellipse(axis, major, minor, true);\n\tEllipse2 scale_ellipse = ellipse.Scale(point, scale);\n\tCHECK(scale_ellipse.Location() == Approx(Point2(2.5, -1.0)));\n\tCHECK(scale_ellipse.MajorRadius() == Approx(2.5));"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "EllipseS& Transform(const TransformationT<double, DIM>& tr)\n @return The reference to self\n @param tr The transformation\n @brief Transform the ellipse",
 "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <common/FrameT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <math/EllipseT.hpp>\n\nTEST_CASE(\"case4:this is a case for Test-Ellipse2-Transform\", \"[math][Ellipse2][P1]\")\n\tTransformationT<double, DIM> tr;\n\ttr.SetTranslation(Vector2(-1.0, -2.0));\n\tEllipse2 ellipse(axis, major, minor, true);\n\tEllipse2 transformed_ellipse = ellipse.Transform(tr);\n\tCHECK(transformed_ellipse.Location().X() == Approx(5.0));\n\tCHECK(transformed_ellipse.Location().Y() == Approx(-2.0));"}{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] double Area()\t @return The area of the ellipse\n\t @brief Get the area of the ellipse\n",
 "output": "#include <catch.hpp>\n#include <testHelper.h>\n\n#include <common/FrameT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <math/EllipseT.hpp>\n\nusing namespace AMCAX;\nusing namespace std;\n\nTEST_CASE(\"case1:this is a case for Test Ellipse3\", \"[math][Ellipse3][P1]\")\n\tFrame3 frame;\n\tdouble major = 5.0;\n\tdouble minor = 4.0;\n\tEllipse3 ellipse(frame, major, minor);\n\tSECTION(\"Area\")\n\t\tdouble S = ellipse.Area();\n\t\tCHECK(S == Approx(M_PI * major * minor));\n"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "EllipseS& Scale(const PointT<double, DIM>& point, double scale)\t @return The reference to self\n\t @param scale The scale value\n\t @param point The scaling center point\n\t @brief Scale the ellipse by a center point\n",
 "output": "#include <catch.hpp>\n#include <testHelper.h>\n\n#include <common/FrameT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <math/EllipseT.hpp>\n\nusing namespace AMCAX;\nusing namespace std;\n\nTEST_CASE(\"case1:this is a case for Test Ellipse3 Scale\", \"[math][Ellipse3][P1]\")\n\tPoint3 point(6.0, 6.0, 6.0);\n\tdouble scale = 0.5;\n\tEllipse3 ellipse(frame, major, minor);\n\tSECTION(\"Scale\")\n\t\tEllipse3 scale_ellipse = ellipse.Scale(point, scale);\n\t\tCHECK(ellipse.Location().X() == Approx(6.0));\n\t\tCHECK(ellipse.Location().Y() == Approx(0.0));\n\t\tCHECK(ellipse.Location().Z() == Approx(6.0));\n\t\tCHECK(ellipse.MajorRadius() == Approx(2.5));\n\t\tCHECK(ellipse.MinorRadius() == Approx(2.0));\n"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "EllipseS& Transform(const TransformationT<double, DIM>& tr)\t @return The reference to self\n\t @param tr The transformation\n\t @brief Transform the ellipse\n",
 "output": "#include <catch.hpp>\n#include <testHelper.h>\n\n#include <common/FrameT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <math/EllipseT.hpp>\n\nusing namespace AMCAX;\nusing namespace std;\n\nTEST_CASE(\"case1:this is a case for Test Ellipse3 Transform\", \"[math][Ellipse3][P1\")\n\tTransformation3 tr;\n\ttr.SetTranslation(Vector3(-1.0, -2.0, -3.0));\n\tEllipse3 Transfor_ellipse = ellipse.Transform(tr);\n\tCHECK(ellipse.Location().X() == Approx(5.0));\n\tCHECK(ellipse.Location().Y() == Approx(-2.0));\n\tCHECK(ellipse.Location().Z() == Approx(3.0));\n\tCHECK(Transfor_ellipse.Location().X() == Approx(5.0));\n\tCHECK(Transfor_ellipse.Location().Y() == Approx(-2.0));\n\tCHECK(Transfor_ellipse.Location().Z() == Approx(3.0));\n"}{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "void SetMajorRadius(double r)\t @param r The new major radius\n\t @brief Set the major radius\n",
 "output": "#include <catch.hpp>\n#include <testHelper.h>\n\n#include <math/EllipseT.hpp>\n#include <geometry/Geom2Hyperbola.hpp>\n\nusing namespace AMCAX;\nusing namespace std;\n\nTEST_CASE(\"case1:this is a case for Test Geom2Hyperbola\", \"[math][Geom2Hyperbola][P1]\")\n\n\t//Geom2Hyperbola构造函数调用\n\tAxis2 axis;//默认二维坐标系中为X轴方向(1.0，0.0)\n\tdouble major = 5.0;\n\tdouble minor = 4.0;\n\tbool isRight = true;\n\tGeom2Hyperbola g2h(axis, major, minor, isRight);\n\n\t//FocalParameter()函数调用，获取焦点到圆锥曲线准线的距离\n\tSECTION(\"FocalParameter\")\n\t\n\t\tdouble FP = g2h.FocalParameter();\n\t\tdouble focal = 2 * sqrt(major * major + minor * minor);\n\t\tdouble fp = 2 * minor * minor / focal;;\n\t\tCHECK(FP == fp);\n\t\n\n\t//SemilatusRectum函数调用\n\tSECTION(\"SemilatusRectum\")\n\t\n\t\tdouble SR = g2h.SemilatusRectum();\n\t\tdouble sr = minor * minor / major;\n\t\tCHECK(SR == sr);\n\t\n\n\n"}
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "void SetMinorRadius(double r)\t @param r The new minor radius\n\t @brief Set the minor radius\n",
 "output": "#include <catch.hpp>\n#include <testHelper.h>\n\n#include <math/EllipseT.hpp>\n#include <geometry/Geom2Hyperbola.hpp>\n\nusing namespace AMCAX;\nusing namespace std;\n\nTEST_CASE(\"case1:this is a case for Test Geom2Hyperbola\", \"[math][Geom2Hyperbola][P1]\")\n\n\t//Geom2Hyperbola构造函数调用\n\tAxis2 axis;//默认二维坐标系中为X轴方向(1.0，0.0)\n\tdouble major = 5.0;\n\tdouble minor = 4.0;\n\tbool isRight = true;\n\tGeom2Hyperbola g2h(axis, major, minor, isRight);\n\n\t//FocalParameter()函数调用，获取焦点到圆锥曲线准线的距离\n\tSECTION(\"FocalParameter\")\n\t\n\t\tdouble FP = g2h.FocalParameter();\n\t\tdouble focal = 2 * sqrt(major * major + minor * minor);\n\t\tdouble fp = 2 * minor * minor / focal;;\n\t\tCHECK(FP == fp);\n\t\n\n\t//SemilatusRectum函数调用\n\tSECTION(\"SemilatusRectum\")\n\t\n\t\tdouble SR = g2h.SemilatusRectum();\n\t\tdouble sr = minor * minor / major;\n\t\tCHECK(SR == sr);\n\t\n\n\n"}
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] AxisT<double, DIM> Directrix1()\t @return The positive directrix\n\t @brief Get the directrix on the positive side of the major axis\n",
 "output": "#include <catch.hpp>\n#include <testHelper.h>\n\n#include <math/EllipseT.hpp>\n#include <geometry/Geom2Hyperbola.hpp>\n\nusing namespace AMCAX;\nusing namespace std;\n\nTEST_CASE(\"case1:this is a case for Test Geom2Hyperbola\", \"[math][Geom2Hyperbola][P1]\")\n\n\t//Geom2Hyperbola构造函数调用\n\tAxis2 axis;//默认二维坐标系中为X轴方向(1.0，0.0)\n\tdouble major = 5.0;\n\tdouble minor = 4.0;\n\tbool isRight = true;\n\tGeom2Hyperbola g2h(axis, major, minor, isRight);\n\n\t//FocalParameter()函数调用，获取焦点到圆锥曲线准线的距离\n\tSECTION(\"FocalParameter\")\n\t\n\t\tdouble FP = g2h.FocalParameter();\n\t\tdouble focal = 2 * sqrt(major * major + minor * minor);\n\t\tdouble fp = 2 * minor * minor / focal;;\n\t\tCHECK(FP == fp);\n\t\n\n\t//SemilatusRectum函数调用\n\tSECTION(\"SemilatusRectum\")\n\t\n\t\tdouble SR = g2h.SemilatusRectum();\n\t\tdouble sr = minor * minor / major;\n\t\tCHECK(SR == sr);\n\t\n\n\n"}
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] AxisT<double, DIM> Directrix2()\t @return The negative directrix\n\t @brief Get the directrix on the negative side of the major axis\n",
 "output": "#include <catch.hpp>\n#include <testHelper.h>\n\n#include <math/EllipseT.hpp>\n#include <geometry/Geom2Hyperbola.hpp>\n\nusing namespace AMCAX;\nusing namespace std;\n\nTEST_CASE(\"case1:this is a case for Test Geom2Hyperbola\", \"[math][Geom2Hyperbola][P1]\")\n\n\t//Geom2Hyperbola构造函数调用\n\tAxis2 axis;//默认二维坐标系中为X轴方向(1.0，0.0)\n\tdouble major = 5.0;\n\tdouble minor = 4.0;\n\tbool isRight = true;\n\tGeom2Hyperbola g2h(axis, major, minor, isRight);\n\n\t//FocalParameter()函数调用，获取焦点到圆锥曲线准线的距离\n\tSECTION(\"FocalParameter\")\n\t\n\t\tdouble FP = g2h.FocalParameter();\n\t\tdouble focal = 2 * sqrt(major * major + minor * minor);\n\t\tdouble fp = 2 * minor * minor / focal;;\n\t\tCHECK(FP == fp);\n\t\n\n\t//SemilatusRectum函数调用\n\tSECTION(\"SemilatusRectum\")\n\t\n\t\tdouble SR = g2h.SemilatusRectum();\n\t\tdouble sr = minor * minor / major;\n\t\tCHECK(SR == sr);\n\t\n\n\n"}
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] double Eccentricity()\t @return The eccentricity\n\t @brief Get the eccentricity of the ellipse\n",
 "output": "#include <catch.hpp>\n#include <testHelper.h>\n\n#include <math/EllipseT.hpp>\n#include <geometry/Geom2Hyperbola.hpp>\n\nusing namespace AMCAX;\nusing namespace std;\n\nTEST_CASE(\"case1:this is a case for Test Geom2Hyperbola\", \"[math][Geom2Hyperbola][P1]\")\n\n\t//Geom2Hyperbola构造函数调用\n\tAxis2 axis;//默认二维坐标系中为X轴方向(1.0，0.0)\n\tdouble major = 5.0;\n\tdouble minor = 4.0;\n\tbool isRight = true;\n\tGeom2Hyperbola g2h(axis, major, minor, isRight);\n\n\t//FocalParameter()函数调用，获取焦点到圆锥曲线准线的距离\n\tSECTION(\"FocalParameter\")\n\t\n\t\tdouble FP = g2h.FocalParameter();\n\t\tdouble focal = 2 * sqrt(major * major + minor * minor);\n\t\tdouble fp = 2 * minor * minor / focal;;\n\t\tCHECK(FP == fp);\n\t\n\n\t//SemilatusRectum函数调用\n\tSECTION(\"SemilatusRectum\")\n\t\n\t\tdouble SR = g2h.SemilatusRectum();\n\t\tdouble sr = minor * minor / major;\n\t\tCHECK(SR == sr);\n\t\n\n\n"}
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] PointT<double, DIM> Focus1()\t @return The positive focus\n\t @brief Get the focus on the positive side of the major axis\n",
 "output": "#include <catch.hpp>\n#include <testHelper.h>\n\n#include <math/EllipseT.hpp>\n#include <geometry/Geom2Hyperbola.hpp>\n\nusing namespace AMCAX;\nusing namespace std;\n\nTEST_CASE(\"case1:this is a case for Test Geom2Hyperbola\", \"[math][Geom2Hyperbola][P1]\")\n\n\t//Geom2Hyperbola构造函数调用\n\tAxis2 axis;//默认二维坐标系中为X轴方向(1.0，0.0)\n\tdouble major = 5.0;\n\tdouble minor = 4.0;\n\tbool isRight = true;\n\tGeom2Hyperbola g2h(axis, major, minor, isRight);\n\n\t//FocalParameter()函数调用，获取焦点到圆锥曲线准线的距离\n\tSECTION(\"FocalParameter\")\n\t\n\t\tdouble FP = g2h.FocalParameter();\n\t\tdouble focal = 2 * sqrt(major * major + minor * minor);\n\t\tdouble fp = 2 * minor * minor / focal;;\n\t\tCHECK(FP == fp);\n\t\n\n\t//SemilatusRectum函数调用\n\tSECTION(\"SemilatusRectum\")\n\t\n\t\tdouble SR = g2h.SemilatusRectum();\n\t\tdouble sr = minor * minor / major;\n\t\tCHECK(SR == sr);\n\t\n\n\n"}
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] PointT<double, DIM> Focus2()\t @return The negative focus\n\t @brief Get the focus on the negative side of the major axis\n",
 "output": "#include <catch.hpp>\n#include <testHelper.h>\n\n#include <math/EllipseT.hpp>\n#include <geometry/Geom2Hyperbola.hpp>\n\nusing namespace AMCAX;\nusing namespace std;\n\nTEST_CASE(\"case1:this is a case for Test Geom2Hyperbola\", \"[math][Geom2Hyperbola][P1]\")\n\n\t//Geom2Hyperbola构造函数调用\n\tAxis2 axis;//默认二维坐标系中为X轴方向(1.0，0.0)\n\tdouble major = 5.0;\n\tdouble minor = 4.0;\n\tbool isRight = true;\n\tGeom2Hyperbola g2h(axis, major, minor, isRight);\n\n\t//FocalParameter()函数调用，获取焦点到圆锥曲线准线的距离\n\tSECTION(\"FocalParameter\")\n\t\n\t\tdouble FP = g2h.FocalParameter();\n\t\tdouble focal = 2 * sqrt(major * major + minor * minor);\n\t\tdouble fp = 2 * minor * minor / focal;;\n\t\tCHECK(FP == fp);\n\t\n\n\t//SemilatusRectum函数调用\n\tSECTION(\"SemilatusRectum\")\n\t\n\t\tdouble SR = g2h.SemilatusRectum();\n\t\tdouble sr = minor * minor / major;\n\t\tCHECK(SR == sr);\n\t\n\n\n"}
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] double MajorRadius()\t @return The major radius\n\t @brief Get the major radius\n",
 "output": "#include <catch.hpp>\n#include <testHelper.h>\n\n#include <math/EllipseT.hpp>\n#include <geometry/Geom2Hyperbola.hpp>\n\nusing namespace AMCAX;\nusing namespace std;\n\nTEST_CASE(\"case1:this is a case for Test Geom2Hyperbola\", \"[math][Geom2Hyperbola][P1]\")\n\n\t//Geom2Hyperbola构造函数调用\n\tAxis2 axis;//默认二维坐标系中为X轴方向(1.0，0.0)\n\tdouble major = 5.0;\n\tdouble minor = 4.0;\n\tbool isRight = true;\n\tGeom2Hyperbola g2h(axis, major, minor, isRight);\n\n\t//FocalParameter()函数调用，获取焦点到圆锥曲线准线的距离\n\tSECTION(\"FocalParameter\")\n\t\n\t\tdouble FP = g2h.FocalParameter();\n\t\tdouble focal = 2 * sqrt(major * major + minor * minor);\n\t\tdouble fp = 2 * minor * minor / focal;;\n\t\tCHECK(FP == fp);\n\t\n\n\t//SemilatusRectum函数调用\n\tSECTION(\"SemilatusRectum\")\n\t\n\t\tdouble SR = g2h.SemilatusRectum();\n\t\tdouble sr = minor * minor / major;\n\t\tCHECK(SR == sr);\n\t\n\n\n"}
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] double MinorRadius()\t @return The minor radius\n\t @brief Get the minor radius\n",
 "output": "#include <catch.hpp>\n#include <testHelper.h>\n\n#include <math/EllipseT.hpp>\n#include <geometry/Geom2Hyperbola.hpp>\n\nusing namespace AMCAX;\nusing namespace std;\n\nTEST_CASE(\"case1:this is a case for Test Geom2Hyperbola\", \"[math][Geom2Hyperbola][P1]\")\n\n\t//Geom2Hyperbola构造函数调用\n\tAxis2 axis;//默认二维坐标系中为X轴方向(1.0，0.0)\n\tdouble major = 5.0;\n\tdouble minor = 4.0;\n\tbool isRight = true;\n\tGeom2Hyperbola g2h(axis, major, minor, isRight);\n\n\t//FocalParameter()函数调用，获取焦点到圆锥曲线准线的距离\n\tSECTION(\"FocalParameter\")\n\t\n\t\tdouble FP = g2h.FocalParameter();\n\t\tdouble focal = 2 * sqrt(major * major + minor * minor);\n\t\tdouble fp = 2 * minor * minor / focal;;\n\t\tCHECK(FP == fp);\n\t\n\n\t//SemilatusRectum函数调用\n\tSECTION(\"SemilatusRectum\")\n\t\n\t\tdouble SR = g2h.SemilatusRectum();\n\t\tdouble sr = minor * minor / major;\n\t\tCHECK(SR == sr);\n\t\n\n\n"}
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] AxisT<double, DIM> Asymptote1()\t @return The positive asymptote\n\t @brief Get the asymptote of the hyperbola with positive slope\n",
 "output": "#include <catch.hpp>\n#include <testHelper.h>\n\n#include <math/EllipseT.hpp>\n#include <geometry/Geom2Hyperbola.hpp>\n\nusing namespace AMCAX;\nusing namespace std;\n\nTEST_CASE(\"case1:this is a case for Test Geom2Hyperbola\", \"[math][Geom2Hyperbola][P1]\")\n\n\t//Geom2Hyperbola构造函数调用\n\tAxis2 axis;//默认二维坐标系中为X轴方向(1.0，0.0)\n\tdouble major = 5.0;\n\tdouble minor = 4.0;\n\tbool isRight = true;\n\tGeom2Hyperbola g2h(axis, major, minor, isRight);\n\n\t//FocalParameter()函数调用，获取焦点到圆锥曲线准线的距离\n\tSECTION(\"FocalParameter\")\n\t\n\t\tdouble FP = g2h.FocalParameter();\n\t\tdouble focal = 2 * sqrt(major * major + minor * minor);\n\t\tdouble fp = 2 * minor * minor / focal;;\n\t\tCHECK(FP == fp);\n\t\n\n\t//SemilatusRectum函数调用\n\tSECTION(\"SemilatusRectum\")\n\t\n\t\tdouble SR = g2h.SemilatusRectum();\n\t\tdouble sr = minor * minor / major;\n\t\tCHECK(SR == sr);\n\t\n\n\n"}
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] AxisT<double, DIM> Asymptote2()\t @return The negative asymptote\n\t @brief Get the asymptote of the hyperbola with negative slope\n",
 "output": "#include <catch.hpp>\n#include <testHelper.h>\n\n#include <math/EllipseT.hpp>\n#include <geometry/Geom2Hyperbola.hpp>\n\nusing namespace AMCAX;\nusing namespace std;\n\nTEST_CASE(\"case1:this is a case for Test Geom2Hyperbola\", \"[math][Geom2Hyperbola][P1]\")\n\n\t//Geom2Hyperbola构造函数调用\n\tAxis2 axis;//默认二维坐标系中为X轴方向(1.0，0.0)\n\tdouble major = 5.0;\n\tdouble minor = 4.0;\n\tbool isRight = true;\n\tGeom2Hyperbola g2h(axis, major, minor, isRight);\n\n\t//FocalParameter()函数调用，获取焦点到圆锥曲线准线的距离\n\tSECTION(\"FocalParameter\")\n\t\n\t\tdouble FP = g2h.FocalParameter();\n\t\tdouble focal = 2 * sqrt(major * major + minor * minor);\n\t\tdouble fp = 2 * minor * minor / focal;;\n\t\tCHECK(FP == fp);\n\t\n\n\t//SemilatusRectum函数调用\n\tSECTION(\"SemilatusRectum\")\n\t\n\t\tdouble SR = g2h.SemilatusRectum();\n\t\tdouble sr = minor * minor / major;\n\t\tCHECK(SR == sr);\n\t\n\n\n"}
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] HyperbolaS ConjugateBranch1()\t @return The positive conjugate hyperbola\n\t @brief Get the conjugate hyperbola on the positive side of the minor axis\n",
 "output": "#include <catch.hpp>\n#include <testHelper.h>\n\n#include <math/EllipseT.hpp>\n#include <geometry/Geom2Hyperbola.hpp>\n\nusing namespace AMCAX;\nusing namespace std;\n\nTEST_CASE(\"case1:this is a case for Test Geom2Hyperbola\", \"[math][Geom2Hyperbola][P1]\")\n\n\t//Geom2Hyperbola构造函数调用\n\tAxis2 axis;//默认二维坐标系中为X轴方向(1.0，0.0)\n\tdouble major = 5.0;\n\tdouble minor = 4.0;\n\tbool isRight = true;\n\tGeom2Hyperbola g2h(axis, major, minor, isRight);\n\n\t//FocalParameter()函数调用，获取焦点到圆锥曲线准线的距离\n\tSECTION(\"FocalParameter\")\n\t\n\t\tdouble FP = g2h.FocalParameter();\n\t\tdouble focal = 2 * sqrt(major * major + minor * minor);\n\t\tdouble fp = 2 * minor * minor / focal;;\n\t\tCHECK(FP == fp);\n\t\n\n\t//SemilatusRectum函数调用\n\tSECTION(\"SemilatusRectum\")\n\t\n\t\tdouble SR = g2h.SemilatusRectum();\n\t\tdouble sr = minor * minor / major;\n\t\tCHECK(SR == sr);\n\t\n\n\n"}
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] HyperbolaS ConjugateBranch2()\t @return The negative conjugate hyperbola\n\t @brief Get the conjugate hyperbola on the negative side of the minor axis\n",
 "output": "#include <catch.hpp>\n#include <testHelper.h>\n\n#include <math/EllipseT.hpp>\n#include <geometry/Geom2Hyperbola.hpp>\n\nusing namespace AMCAX;\nusing namespace std;\n\nTEST_CASE(\"case1:this is a case for Test Geom2Hyperbola\", \"[math][Geom2Hyperbola][P1]\")\n\n\t//Geom2Hyperbola构造函数调用\n\tAxis2 axis;//默认二维坐标系中为X轴方向(1.0，0.0)\n\tdouble major = 5.0;\n\tdouble minor = 4.0;\n\tbool isRight = true;\n\tGeom2Hyperbola g2h(axis, major, minor, isRight);\n\n\t//FocalParameter()函数调用，获取焦点到圆锥曲线准线的距离\n\tSECTION(\"FocalParameter\")\n\t\n\t\tdouble FP = g2h.FocalParameter();\n\t\tdouble focal = 2 * sqrt(major * major + minor * minor);\n\t\tdouble fp = 2 * minor * minor / focal;;\n\t\tCHECK(FP == fp);\n\t\n\n\t//SemilatusRectum函数调用\n\tSECTION(\"SemilatusRectum\")\n\t\n\t\tdouble SR = g2h.SemilatusRectum();\n\t\tdouble sr = minor * minor / major;\n\t\tCHECK(SR == sr);\n\t\n\n\n"}
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] HyperbolaS OtherBranch()\t @return The hyperbola of the other branch\n\t @brief Get the other branch of the hyperbola\n",
 "output": "#include <catch.hpp>\n#include <testHelper.h>\n\n#include <math/EllipseT.hpp>\n#include <geometry/Geom2Hyperbola.hpp>\n\nusing namespace AMCAX;\nusing namespace std;\n\nTEST_CASE(\"case1:this is a case for Test Geom2Hyperbola\", \"[math][Geom2Hyperbola][P1]\")\n\n\t//Geom2Hyperbola构造函数调用\n\tAxis2 axis;//默认二维坐标系中为X轴方向(1.0，0.0)\n\tdouble major = 5.0;\n\tdouble minor = 4.0;\n\tbool isRight = true;\n\tGeom2Hyperbola g2h(axis, major, minor, isRight);\n\n\t//FocalParameter()函数调用，获取焦点到圆锥曲线准线的距离\n\tSECTION(\"FocalParameter\")\n\t\n\t\tdouble FP = g2h.FocalParameter();\n\t\tdouble focal = 2 * sqrt(major * major + minor * minor);\n\t\tdouble fp = 2 * minor * minor / focal;;\n\t\tCHECK(FP == fp);\n\t\n\n\t//SemilatusRectum函数调用\n\tSECTION(\"SemilatusRectum\")\n\t\n\t\tdouble SR = g2h.SemilatusRectum();\n\t\tdouble sr = minor * minor / major;\n\t\tCHECK(SR == sr);\n\t\n\n\n"}
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "HyperbolaS& Scale(const PointT<double, DIM>& point, double scale)\t @return The reference to self\n\t @param scale The scale value\n\t @param point The scaling center point\n\t @brief Scale the hyperbola by a center point\n",
 "output": "#include <catch.hpp>\n#include <testHelper.h>\n\n#include <math/EllipseT.hpp>\n#include <geometry/Geom2Hyperbola.hpp>\n\nusing namespace AMCAX;\nusing namespace std;\n\nTEST_CASE(\"case1:this is a case for Test Geom2Hyperbola\", \"[math][Geom2Hyperbola][P1]\")\n\n\t//Geom2Hyperbola构造函数调用\n\tAxis2 axis;//默认二维坐标系中为X轴方向(1.0，0.0)\n\tdouble major = 5.0;\n\tdouble minor = 4.0;\n\tbool isRight = true;\n\tGeom2Hyperbola g2h(axis, major, minor, isRight);\n\n\t//FocalParameter()函数调用，获取焦点到圆锥曲线准线的距离\n\tSECTION(\"FocalParameter\")\n\t\n\t\tdouble FP = g2h.FocalParameter();\n\t\tdouble focal = 2 * sqrt(major * major + minor * minor);\n\t\tdouble fp = 2 * minor * minor / focal;;\n\t\tCHECK(FP == fp);\n\t\n\n\t//SemilatusRectum函数调用\n\tSECTION(\"SemilatusRectum\")\n\t\n\t\tdouble SR = g2h.SemilatusRectum();\n\t\tdouble sr = minor * minor / major;\n\t\tCHECK(SR == sr);\n\t\n\n\n"}
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "HyperbolaS& Transform(const TransformationT<double, DIM>& tr)\t @return The reference to self\n\t @param tr The transformation\n\t @brief Transform the hyperbola\n",
 "output": "#include <catch.hpp>\n#include <testHelper.h>\n\n#include <math/EllipseT.hpp>\n#include <geometry/Geom2Hyperbola.hpp>\n\nusing namespace AMCAX;\nusing namespace std;\n\nTEST_CASE(\"case1:this is a case for Test Geom2Hyperbola\", \"[math][Geom2Hyperbola][P1]\")\n\n\t//Geom2Hyperbola构造函数调用\n\tAxis2 axis;//默认二维坐标系中为X轴方向(1.0，0.0)\n\tdouble major = 5.0;\n\tdouble minor = 4.0;\n\tbool isRight = true;\n\tGeom2Hyperbola g2h(axis, major, minor, isRight);\n\n\t//FocalParameter()函数调用，获取焦点到圆锥曲线准线的距离\n\tSECTION(\"FocalParameter\")\n\t\n\t\tdouble FP = g2h.FocalParameter();\n\t\tdouble focal = 2 * sqrt(major * major + minor * minor);\n\t\tdouble fp = 2 * minor * minor / focal;;\n\t\tCHECK(FP == fp);\n\t\n\n\t//SemilatusRectum函数调用\n\tSECTION(\"SemilatusRectum\")\n\t\n\t\tdouble SR = g2h.SemilatusRectum();\n\t\tdouble sr = minor * minor / major;\n\t\tCHECK(SR == sr);\n\t\n\n\n"}{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "void SetMajorRadius(double r)\t @param r The new major radius\n\t @brief Set the major radius\nvoid SetMinorRadius(double r)\t @param r The new minor radius\n\t @brief Set the minor radius\n",
 "output": "#include <catch.hpp>\n#include <testHelper.h>\n\n#include <math/EllipseT.hpp>\n#include <geometry/Geom3Hyperbola.hpp>\n\nusing namespace AMCAX;\nusing namespace std;\n\nTEST_CASE(\"case1:this is a case for Test Geom3Hyperbola\", \"[math][Geom3Hyperbola][P1]\")\n\n\tFrame3 frame;\n\tdouble major = 5.0;\n\tdouble minor = 4.0;\n\tGeom3Hyperbola g3h(frame, major, minor);\n"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] AxisT<double, DIM> Directrix1()\t @return The positive directrix\n\t @brief Get the directrix on the positive side of the major axis\n[[nodiscard]] AxisT<double, DIM> Directrix2()\t @return The negative directrix\n\t @brief Get the directrix on the negative side of the major axis\n",
 "output": "#include <catch.hpp>\n#include <testHelper.h>\n\n#include <math/EllipseT.hpp>\n#include <geometry/Geom3Hyperbola.hpp>\n\nusing namespace AMCAX;\nusing namespace std;\n\nTEST_CASE(\"case1:this is a case for Test Geom3Hyperbola\", \"[math][Geom3Hyperbola][P1]\")\n\n\tFrame3 frame;\n\tdouble major = 5.0;\n\tdouble minor = 4.0;\n\tGeom3Hyperbola g3h(frame, major, minor);\n"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] double Eccentricity()\t @return The eccentricity\n\t @brief Get the eccentricity of the ellipse\n[[nodiscard]] PointT<double, DIM> Focus1()\t @return The positive focus\n\t @brief Get the focus on the positive side of the major axis\n",
 "output": "#include <catch.hpp>\n#include <testHelper.h>\n\n#include <math/EllipseT.hpp>\n#include <geometry/Geom3Hyperbola.hpp>\n\nusing namespace AMCAX;\nusing namespace std;\n\nTEST_CASE(\"case1:this is a case for Test Geom3Hyperbola\", \"[math][Geom3Hyperbola][P1]\")\n\n\tFrame3 frame;\n\tdouble major = 5.0;\n\tdouble minor = 4.0;\n\tGeom3Hyperbola g3h(frame, major, minor);\n"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] double MajorRadius()\t @return The major radius\n\t @brief Get the major radius\n[[nodiscard]] double MinorRadius()\t @return The minor radius\n\t @brief Get the minor radius\n",
 "output": "#include <catch.hpp>\n#include <testHelper.h>\n\n#include <math/EllipseT.hpp>\n#include <geometry/Geom3Hyperbola.hpp>\n\nusing namespace AMCAX;\nusing namespace std;\n\nTEST_CASE(\"case1:this is a case for Test Geom3Hyperbola\", \"[math][Geom3Hyperbola][P1]\")\n\n\tFrame3 frame;\n\tdouble major = 5.0;\n\tdouble minor = 4.0;\n\tGeom3Hyperbola g3h(frame, major, minor);\n"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] AxisT<double, DIM> Asymptote1()\t @return The positive asymptote\n\t @brief Get the asymptote of the hyperbola with positive slope\n[[nodiscard]] AxisT<double, DIM> Asymptote2()\t @return The negative asymptote\n\t @brief Get the asymptote of the hyperbola with negative slope\n",
 "output": "#include <catch.hpp>\n#include <testHelper.h>\n\n#include <math/EllipseT.hpp>\n#include <geometry/Geom3Hyperbola.hpp>\n\nusing namespace AMCAX;\nusing namespace std;\n\nTEST_CASE(\"case1:this is a case for Test Geom3Hyperbola\", \"[math][Geom3Hyperbola][P1]\")\n\n\tFrame3 frame;\n\tdouble major = 5.0;\n\tdouble minor = 4.0;\n\tGeom3Hyperbola g3h(frame, major, minor);\n"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] HyperbolaS ConjugateBranch1()\t @return The positive conjugate hyperbola\n\t @brief Get the conjugate hyperbola on the positive side of the minor axis\n[[nodiscard]] HyperbolaS ConjugateBranch2()\t @return The negative conjugate hyperbola\n\t @brief Get the conjugate hyperbola on the negative side of the minor axis\n",
 "output": "#include <catch.hpp>\n#include <testHelper.h>\n\n#include <math/EllipseT.hpp>\n#include <geometry/Geom3Hyperbola.hpp>\n\nusing namespace AMCAX;\nusing namespace std;\n\nTEST_CASE(\"case1:this is a case for Test Geom3Hyperbola\", \"[math][Geom3Hyperbola][P1]\")\n\n\tFrame3 frame;\n\tdouble major = 5.0;\n\tdouble minor = 4.0;\n\tGeom3Hyperbola g3h(frame, major, minor);\n"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] HyperbolaS OtherBranch()\t @return The hyperbola of the other branch\n\t @brief Get the other branch of the hyperbola\nHyperbolaS& Scale(const PointT<double, DIM>& point, double scale)\t @return The reference to self\n\t @param scale The scale value\n\t @param point The scaling center point\n\t @brief Scale the hyperbola by a center point\n",
 "output": "#include <catch.hpp>\n#include <testHelper.h>\n\n#include <math/EllipseT.hpp>\n#include <geometry/Geom3Hyperbola.hpp>\n\nusing namespace AMCAX;\nusing namespace std;\n\nTEST_CASE(\"case1:this is a case for Test Geom3Hyperbola\", \"[math][Geom3Hyperbola][P1]\")\n\n\tFrame3 frame;\n\tdouble major = 5.0;\n\tdouble minor = 4.0;\n\tGeom3Hyperbola g3h(frame, major, minor);\n"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "HyperbolaS& Transform(const TransformationT<double, DIM>& tr)\t @return The reference to self\n\t @param tr The transformation\n\t @brief Transform the hyperbola\n",
 "output": "#include <catch.hpp>\n#include <testHelper.h>\n\n#include <math/EllipseT.hpp>\n#include <geometry/Geom3Hyperbola.hpp>\n\nusing namespace AMCAX;\nusing namespace std;\n\nTEST_CASE(\"case1:this is a case for Test Geom3Hyperbola\", \"[math][Geom3Hyperbola][P1]\")\n\n\tFrame3 frame;\n\tdouble major = 5.0;\n\tdouble minor = 4.0;\n\tGeom3Hyperbola g3h(frame, major, minor);\n"}{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "void SetMajorRadius(double r)\\t @param r The new major radius\\n\\t @brief Set the major radius\\n",
 "output": "#include <catch.hpp>\\n#include <testHelper.h>\\n...\\n\\nTEST_CASE(\"case1:this is a case for Hyperbola2\", \"[math][Hyperbola2][p1]\") \\n\\t//Construct hyperbola2d_ax\\n\\tPoint2 point2_Hy(0.0, 0.0);\\n\\tDirection2 dir2_Hy(1.0, 0.0);\\n\\tAxis2 major2_Axis(point2_Hy, dir2_Hy);\\n\\tdouble major2 = 3.0, minor2 = 4.0;\\n\\tHyperbola2 hyperbola2d_ax(major2_Axis, major2, minor2, true);\\n\\thyperbola2d_ax.SetMajorRadius(4.0);\\n\\tCHECK(hyperbola2d_ax.MajorRadius() == Approx(4.0));"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "void SetMinorRadius(double r)\\t @param r The new minor radius\\n\\t @brief Set the minor radius\\n",
 "output": "#include <catch.hpp>\\n#include <testHelper.h>\\n...\\n\\nTEST_CASE(\"case1:this is a case for Hyperbola2\", \"[math][Hyperbola2][p1]\") \\n\\t//Construct hyperbola2d_ax\\n\\tPoint2 point2_Hy(0.0, 0.0);\\n\\tDirection2 dir2_Hy(1.0, 0.0);\\n\\tAxis2 major2_Axis(point2_Hy, dir2_Hy);\\n\\tdouble major2 = 3.0, minor2 = 4.0;\\n\\tHyperbola2 hyperbola2d_ax(major2_Axis, major2, minor2, true);\\n\\thyperbola2d_ax.SetMinorRadius(3.0);\\n\\tCHECK(hyperbola2d_ax.MinorRadius() == Approx(3.0));"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] AxisT<double, DIM> Directrix1()\\t @return The positive directrix\\n\\t @brief Get the directrix on the positive side of the major axis\\n",
 "output": "#include <catch.hpp>\\n#include <testHelper.h>\\n...\\n\\nTEST_CASE(\"case1:this is a case for Hyperbola2\", \"[math][Hyperbola2][p1]\") \\n\\t//Construct hyperbola2d_ax\\n\\tPoint2 point2_Hy(0.0, 0.0);\\n\\tDirection2 dir2_Hy(1.0, 0.0);\\n\\tAxis2 major2_Axis(point2_Hy, dir2_Hy);\\n\\tdouble major2 = 3.0, minor2 = 4.0;\\n\\tHyperbola2 hyperbola2d_ax(major2_Axis, major2, minor2, true);\\n\\tAxisT<double, DIM> directrix = hyperbola2d_ax.Directrix1();\\n\\tCHECK(directrix.Direction().X() == Approx(0.0));"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] AxisT<double, DIM> Directrix2()\\t @return The negative directrix\\n\\t @brief Get the directrix on the negative side of the major axis\\n",
 "output": "#include <catch.hpp>\\n#include <testHelper.h>\\n...\\n\\nTEST_CASE(\"case1:this is a case for Hyperbola2\", \"[math][Hyperbola2][p1]\") \\n\\t//Construct hyperbola2d_ax\\n\\tPoint2 point2_Hy(0.0, 0.0);\\n\\tDirection2 dir2_Hy(1.0, 0.0);\\n\\tAxis2 major2_Axis(point2_Hy, dir2_Hy);\\n\\tdouble major2 = 3.0, minor2 = 4.0;\\n\\tHyperbola2 hyperbola2d_ax(major2_Axis, major2, minor2, true);\\n\\tAxisT<double, DIM> directrix = hyperbola2d_ax.Directrix2();\\n\\tCHECK(directrix.Direction().X() == Approx(0.0));"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] double Eccentricity()\\t @return The eccentricity\\n\\t @brief Get the eccentricity of the ellipse\\n",
 "output": "#include <catch.hpp>\\n#include <testHelper.h>\\n...\\n\\nTEST_CASE(\"case1:this is a case for Hyperbola2\", \"[math][Hyperbola2][p1]\") \\n\\t//Construct hyperbola2d_ax\\n\\tPoint2 point2_Hy(0.0, 0.0);\\n\\tDirection2 dir2_Hy(1.0, 0.0);\\n\\tAxis2 major2_Axis(point2_Hy, dir2_Hy);\\n\\tdouble major2 = 3.0, minor2 = 4.0;\\n\\tHyperbola2 hyperbola2d_ax(major2_Axis, major2, minor2, true);\\n\\tdouble eccentricity = hyperbola2d_ax.Eccentricity();\\n\\tCHECK(eccentricity == Approx(5.0 / 3.0));"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] PointT<double, DIM> Focus1()\\t @return The positive focus\\n\\t @brief Get the focus on the positive side of the major axis\\n",
 "output": "#include <catch.hpp>\\n#include <testHelper.h>\\n...\\n\\nTEST_CASE(\"case1:this is a case for Hyperbola2\", \"[math][Hyperbola2][p1]\") \\n\\t//Construct hyperbola2d_ax\\n\\tPoint2 point2_Hy(0.0, 0.0);\\n\\tDirection2 dir2_Hy(1.0, 0.0);\\n\\tAxis2 major2_Axis(point2_Hy, dir2_Hy);\\n\\tdouble major2 = 3.0, minor2 = 4.0;\\n\\tHyperbola2 hyperbola2d_ax(major2_Axis, major2, minor2, true);\\n\\tPointT<double, DIM> focus = hyperbola2d_ax.Focus1();\\n\\tCHECK(focus.X() == Approx(5.0));"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] PointT<double, DIM> Focus2()\\t @return The negative focus\\n\\t @brief Get the focus on the negative side of the major axis\\n",
 "output": "#include <catch.hpp>\\n#include <testHelper.h>\\n...\\n\\nTEST_CASE(\"case1:this is a case for Hyperbola2\", \"[math][Hyperbola2][p1]\") \\n\\t//Construct hyperbola2d_ax\\n\\tPoint2 point2_Hy(0.0, 0.0);\\n\\tDirection2 dir2_Hy(1.0, 0.0);\\n\\tAxis2 major2_Axis(point2_Hy, dir2_Hy);\\n\\tdouble major2 = 3.0, minor2 = 4.0;\\n\\tHyperbola2 hyperbola2d_ax(major2_Axis, major2, minor2, true);\\n\\tPointT<double, DIM> focus = hyperbola2d_ax.Focus2();\\n\\tCHECK(focus.X() == Approx(-5.0));"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] double MajorRadius()\\t @return The major radius\\n\\t @brief Get the major radius\\n",
 "output": "#include <catch.hpp>\\n#include <testHelper.h>\\n...\\n\\nTEST_CASE(\"case1:this is a case for Hyperbola2\", \"[math][Hyperbola2][p1]\") \\n\\t//Construct hyperbola2d_ax\\n\\tPoint2 point2_Hy(0.0, 0.0);\\n\\tDirection2 dir2_Hy(1.0, 0.0);\\n\\tAxis2 major2_Axis(point2_Hy, dir2_Hy);\\n\\tdouble major2 = 3.0, minor2 = 4.0;\\n\\tHyperbola2 hyperbola2d_ax(major2_Axis, major2, minor2, true);\\n\\tdouble majorRadius = hyperbola2d_ax.MajorRadius();\\n\\tCHECK(majorRadius == Approx(3.0));"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] double MinorRadius()\\t @return The minor radius\\n\\t @brief Get the minor radius\\n",
 "output": "#include <catch.hpp>\\n#include <testHelper.h>\\n...\\n\\nTEST_CASE(\"case1:this is a case for Hyperbola2\", \"[math][Hyperbola2][p1]\") \\n\\t//Construct hyperbola2d_ax\\n\\tPoint2 point2_Hy(0.0, 0.0);\\n\\tDirection2 dir2_Hy(1.0, 0.0);\\n\\tAxis2 major2_Axis(point2_Hy, dir2_Hy);\\n\\tdouble major2 = 3.0, minor2 = 4.0;\\n\\tHyperbola2 hyperbola2d_ax(major2_Axis, major2, minor2, true);\\n\\tdouble minorRadius = hyperbola2d_ax.MinorRadius();\\n\\tCHECK(minorRadius == Approx(4.0));"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] AxisT<double, DIM> Asymptote1()\\t @return The positive asymptote\\n\\t @brief Get the asymptote of the hyperbola with positive slope\\n",
 "output": "#include <catch.hpp>\\n#include <testHelper.h>\\n...\\n\\nTEST_CASE(\"case1:this is a case for Hyperbola2\", \"[math][Hyperbola2][p1]\") \\n\\t//Construct hyperbola2d_ax\\n\\tPoint2 point2_Hy(0.0, 0.0);\\n\\tDirection2 dir2_Hy(1.0, 0.0);\\n\\tAxis2 major2_Axis(point2_Hy, dir2_Hy);\\n\\tdouble major2 = 3.0, minor2 = 4.0;\\n\\tHyperbola2 hyperbola2d_ax(major2_Axis, major2, minor2, true);\\n\\tAxisT<double, DIM> asymptote = hyperbola2d_ax.Asymptote1();\\n\\tCHECK(asymptote.Direction().X() / asymptote.Direction().Y() == Approx(3.0/4.0));"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] AxisT<double, DIM> Asymptote2()\\t @return The negative asymptote\\n\\t @brief Get the asymptote of the hyperbola with negative slope\\n",
 "output": "#include <catch.hpp>\\n#include <testHelper.h>\\n...\\n\\nTEST_CASE(\"case1:this is a case for Hyperbola2\", \"[math][Hyperbola2][p1]\") \\n\\t//Construct hyperbola2d_ax\\n\\tPoint2 point2_Hy(0.0, 0.0);\\n\\tDirection2 dir2_Hy(1.0, 0.0);\\n\\tAxis2 major2_Axis(point2_Hy, dir2_Hy);\\n\\tdouble major2 = 3.0, minor2 = 4.0;\\n\\tHyperbola2 hyperbola2d_ax(major2_Axis, major2, minor2, true);\\n\\tAxisT<double, DIM> asymptote = hyperbola2d_ax.Asymptote2();\\n\\tCHECK(asymptote.Direction().X() / asymptote.Direction().Y() == Approx(-3.0/4.0));"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] HyperbolaS ConjugateBranch1()\\t @return The positive conjugate hyperbola\\n\\t @brief Get the conjugate hyperbola on the positive side of the minor axis\\n",
 "output": "#include <catch.hpp>\\n#include <testHelper.h>\\n...\\n\\nTEST_CASE(\"case1:this is a case for Hyperbola2\", \"[math][Hyperbola2][p1]\") \\n\\t//Construct hyperbola2d_ax\\n\\tPoint2 point2_Hy(0.0, 0.0);\\n\\tDirection2 dir2_Hy(1.0, 0.0);\\n\\tAxis2 major2_Axis(point2_Hy, dir2_Hy);\\n\\tdouble major2 = 3.0, minor2 = 4.0;\\n\\tHyperbola2 hyperbola2d_ax(major2_Axis, major2, minor2, true);\\n\\tHyperbolaS conjugateBranch = hyperbola2d_ax.ConjugateBranch1();\\n\\tdouble major2d_con = conjugateBranch.MajorRadius();\\n\\tCHECK(major2d_con == Approx(4.0));"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] HyperbolaS ConjugateBranch2()\\t @return The negative conjugate hyperbola\\n\\t @brief Get the conjugate hyperbola on the negative side of the minor axis\\n",
 "output": "#include <catch.hpp>\\n#include <testHelper.h>\\n...\\n\\nTEST_CASE(\"case1:this is a case for Hyperbola2\", \"[math][Hyperbola2][p1]\") \\n\\t//Construct hyperbola2d_ax\\n\\tPoint2 point2_Hy(0.0, 0.0);\\n\\tDirection2 dir2_Hy(1.0, 0.0);\\n\\tAxis2 major2_Axis(point2_Hy, dir2_Hy);\\n\\tdouble major2 = 3.0, minor2 = 4.0;\\n\\tHyperbola2 hyperbola2d_ax(major2_Axis, major2, minor2, true);\\n\\tHyperbolaS conjugateBranch = hyperbola2d_ax.ConjugateBranch2();\\n\\tdouble major2d_con = conjugateBranch.MajorRadius();\\n\\tCHECK(major2d_con == Approx(4.0));"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] HyperbolaS OtherBranch()\\t @return The hyperbola of the other branch\\n\\t @brief Get the other branch of the hyperbola\\n",
 "output": "#include <catch.hpp>\\n#include <testHelper.h>\\n...\\n\\nTEST_CASE(\"case1:this is a case for Hyperbola2\", \"[math][Hyperbola2][p1]\") \\n\\t//Construct hyperbola2d_ax\\n\\tPoint2 point2_Hy(0.0, 0.0);\\n\\tDirection2 dir2_Hy(1.0, 0.0);\\n\\tAxis2 major2_Axis(point2_Hy, dir2_Hy);\\n\\tdouble major2 = 3.0, minor2 = 4.0;\\n\\tHyperbola2 hyperbola2d_ax(major2_Axis, major2, minor2, true);\\n\\tHyperbolaS otherBranch = hyperbola2d_ax.OtherBranch();\\n\\tdouble major2d_con = otherBranch.MajorRadius();\\n\\tCHECK(major2d_con == Approx(3.0));"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "HyperbolaS& Scale(const PointT<double, DIM>& point, double scale)\\t @return The reference to self\\n\\t @param scale The scale value\\n\\t @param point The scaling center point\\n\\t @brief Scale the hyperbola by a center point\\n",
 "output": "#include <catch.hpp>\\n#include <testHelper.h>\\n...\\n\\nTEST_CASE(\"case1:this is a case for Hyperbola2\", \"[math][Hyperbola2][p1]\") \\n\\t//Construct hyperbola2d_ax\\n\\tPoint2 point2_Hy(0.0, 0.0);\\n\\tDirection2 dir2_Hy(1.0, 0.0);\\n\\tAxis2 major2_Axis(point2_Hy, dir2_Hy);\\n\\tdouble major2 = 3.0, minor2 = 4.0;\\n\\tHyperbola2 hyperbola2d_ax(major2_Axis, major2, minor2, true);\\n\\tPointT<double, DIM> center(0.0, 0.0);\\n\\thyperbola2d_ax.Scale(center, 0.5);\\n\\tCHECK(hyperbola2d_ax.Location().X() == Approx(0.0));"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "HyperbolaS& Transform(const TransformationT<double, DIM>& tr)\\t @return The reference to self\\n\\t @param tr The transformation\\n\\t @brief Transform the hyperbola\\n",
 "output": "#include <catch.hpp>\\n#include <testHelper.h>\\n...\\n\\nTEST_CASE(\"case1:this is a case for Hyperbola2\", \"[math][Hyperbola2][p1]\") \\n\\t//Construct hyperbola2d_ax\\n\\tPoint2 point2_Hy(0.0, 0.0);\\n\\tDirection2 dir2_Hy(1.0, 0.0);\\n\\tAxis2 major2_Axis(point2_Hy, dir2_Hy);\\n\\tdouble major2 = 3.0, minor2 = 4.0;\\n\\tHyperbola2 hyperbola2d_ax(major2_Axis, major2, minor2, true);\\n\\tTransformationT<double, DIM> trans;\\n\\thyperbola2d_ax.Transform(trans);\\n\\tCHECK(hyperbola2d_ax.Location().X() == Approx(0.0));"}{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "void SetMajorRadius(double r)\t @param r The new major radius\n\t @brief Set the major radius\n",
 "output": "#include <catch.hpp>\n#include <testHelper.h>\n\n// Test for SetMajorRadius\nTEST_CASE(\"case1: SetMajorRadius test\") {\n\tHyperbola3 hyperbola3d_fr;\n\thyperbola3d_fr.SetMajorRadius(4.0);\n\tCHECK(hyperbola3d_fr.MajorRadius() == Approx(4.0));\n}"}
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "void SetMinorRadius(double r)\t @param r The new minor radius\n\t @brief Set the minor radius\n",
 "output": "#include <catch.hpp>\n#include <testHelper.h>\n\n// Test for SetMinorRadius\nTEST_CASE(\"case2: SetMinorRadius test\") {\n\tHyperbola3 hyperbola3d_fr;\n\thyperbola3d_fr.SetMinorRadius(3.0);\n\tCHECK(hyperbola3d_fr.MinorRadius() == Approx(3.0));\n}"}
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] AxisT<double, DIM> Directrix1()\t @return The positive directrix\n\t @brief Get the directrix on the positive side of the major axis\n",
 "output": "#include <catch.hpp>\n#include <testHelper.h>\n\n// Test for Directrix1\nTEST_CASE(\"case3: Directrix1 test\") {\n\tHyperbola3 hyperbola3d_fr;\n\tAxisT<double, DIM> dir = hyperbola3d_fr.Directrix1();\n\tCHECK(dir.Location().X() == Approx(0.0)); // example check\n}"}
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] AxisT<double, DIM> Directrix2()\t @return The negative directrix\n\t @brief Get the directrix on the negative side of the major axis\n",
 "output": "#include <catch.hpp>\n#include <testHelper.h>\n\n// Test for Directrix2\nTEST_CASE(\"case4: Directrix2 test\") {\n\tHyperbola3 hyperbola3d_fr;\n\tAxisT<double, DIM> dir = hyperbola3d_fr.Directrix2();\n\tCHECK(dir.Location().X() == Approx(0.0)); // example check\n}"}
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] double Eccentricity()\t @return The eccentricity\n\t @brief Get the eccentricity of the ellipse\n",
 "output": "#include <catch.hpp>\n#include <testHelper.h>\n\n// Test for Eccentricity\nTEST_CASE(\"case5: Eccentricity test\") {\n\tHyperbola3 hyperbola3d_fr;\n\tdouble e = hyperbola3d_fr.Eccentricity();\n\tCHECK(e == Approx(5.0 / 3.0)); // example check\n}"}
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] PointT<double, DIM> Focus1()\t @return The positive focus\n\t @brief Get the focus on the positive side of the major axis\n",
 "output": "#include <catch.hpp>\n#include <testHelper.h>\n\n// Test for Focus1\nTEST_CASE(\"case6: Focus1 test\") {\n\tHyperbola3 hyperbola3d_fr;\n\tPointT<double, DIM> focus = hyperbola3d_fr.Focus1();\n\tCHECK(focus.X() == Approx(5.0)); // example check\n}"}
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] PointT<double, DIM> Focus2()\t @return The negative focus\n\t @brief Get the focus on the negative side of the major axis\n",
 "output": "#include <catch.hpp>\n#include <testHelper.h>\n\n// Test for Focus2\nTEST_CASE(\"case7: Focus2 test\") {\n\tHyperbola3 hyperbola3d_fr;\n\tPointT<double, DIM> focus = hyperbola3d_fr.Focus2();\n\tCHECK(focus.X() == Approx(-5.0)); // example check\n}"}
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] double MajorRadius()\t @return The major radius\n\t @brief Get the major radius\n",
 "output": "#include <catch.hpp>\n#include <testHelper.h>\n\n// Test for MajorRadius\nTEST_CASE(\"case8: MajorRadius test\") {\n\tHyperbola3 hyperbola3d_fr;\n\tCHECK(hyperbola3d_fr.MajorRadius() == Approx(3.0)); // example check\n}"}
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] double MinorRadius()\t @return The minor radius\n\t @brief Get the minor radius\n",
 "output": "#include <catch.hpp>\n#include <testHelper.h>\n\n// Test for MinorRadius\nTEST_CASE(\"case9: MinorRadius test\") {\n\tHyperbola3 hyperbola3d_fr;\n\tCHECK(hyperbola3d_fr.MinorRadius() == Approx(4.0)); // example check\n}"}
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] AxisT<double, DIM> Asymptote1()\t @return The positive asymptote\n\t @brief Get the asymptote of the hyperbola with positive slope\n",
 "output": "#include <catch.hpp>\n#include <testHelper.h>\n\n// Test for Asymptote1\nTEST_CASE(\"case10: Asymptote1 test\") {\n\tHyperbola3 hyperbola3d_fr;\n\tAxisT<double, DIM> asymptote = hyperbola3d_fr.Asymptote1();\n\tCHECK(asymptote.Direction().X() / asymptote.Direction().Y() == Approx(3.0 / 4.0));\n}"}
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] AxisT<double, DIM> Asymptote2()\t @return The negative asymptote\n\t @brief Get the asymptote of the hyperbola with negative slope\n",
 "output": "#include <catch.hpp>\n#include <testHelper.h>\n\n// Test for Asymptote2\nTEST_CASE(\"case11: Asymptote2 test\") {\n\tHyperbola3 hyperbola3d_fr;\n\tAxisT<double, DIM> asymptote = hyperbola3d_fr.Asymptote2();\n\tCHECK(asymptote.Direction().X() / asymptote.Direction().Y() == Approx(-3.0 / 4.0));\n}"}
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] HyperbolaS ConjugateBranch1()\t @return The positive conjugate hyperbola\n\t @brief Get the conjugate hyperbola on the positive side of the minor axis\n",
 "output": "#include <catch.hpp>\n#include <testHelper.h>\n\n// Test for ConjugateBranch1\nTEST_CASE(\"case12: ConjugateBranch1 test\") {\n\tHyperbola3 hyperbola3d_fr;\n\tHyperbolaS conjugate = hyperbola3d_fr.ConjugateBranch1();\n\tCHECK(conjugate.Location().X() == Approx(0.0)); // example check\n}"}
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] HyperbolaS ConjugateBranch2()\t @return The negative conjugate hyperbola\n\t @brief Get the conjugate hyperbola on the negative side of the minor axis\n",
 "output": "#include <catch.hpp>\n#include <testHelper.h>\n\n// Test for ConjugateBranch2\nTEST_CASE(\"case13: ConjugateBranch2 test\") {\n\tHyperbola3 hyperbola3d_fr;\n\tHyperbolaS conjugate = hyperbola3d_fr.ConjugateBranch2();\n\tCHECK(conjugate.Location().X() == Approx(0.0)); // example check\n}"}
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] HyperbolaS OtherBranch()\t @return The hyperbola of the other branch\n\t @brief Get the other branch of the hyperbola\n",
 "output": "#include <catch.hpp>\n#include <testHelper.h>\n\n// Test for OtherBranch\nTEST_CASE(\"case14: OtherBranch test\") {\n\tHyperbola3 hyperbola3d_fr;\n\tHyperbolaS other = hyperbola3d_fr.OtherBranch();\n\tCHECK(other.Location().X() == Approx(0.0)); // example check\n}"}
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "HyperbolaS& Scale(const PointT<double, DIM>& point, double scale)\t @return The reference to self\n\t @param scale The scale value\n\t @param point The scaling center point\n\t @brief Scale the hyperbola by a center point\n",
 "output": "#include <catch.hpp>\n#include <testHelper.h>\n\n// Test for Scale\nTEST_CASE(\"case15: Scale test\") {\n\tHyperbola3 hyperbola3d_fr;\n\tPointT<double, DIM> center(0.0, 0.0, 1.0);\n\thyperbola3d_fr.Scale(center, 0.5);\n\tCHECK(hyperbola3d_fr.Location().X() == Approx(0.0));\n}"}
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "HyperbolaS& Transform(const TransformationT<double, DIM>& tr)\t @return The reference to self\n\t @param tr The transformation\n\t @brief Transform the hyperbola\n",
 "output": "#include <catch.hpp>\n#include <testHelper.h>\n\n// Test for Transform\nTEST_CASE(\"case16: Transform test\") {\n\tHyperbola3 hyperbola3d_fr;\n\tTransformationT<double, DIM> trans;\n\ttrans.SetTranslation(Vector3(1.0, 1.0, 1.0));\n\thyperbola3d_fr.Transform(trans);\n\tCHECK(hyperbola3d_fr.Location().X() == Approx(1.0));\n}"}{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] bool Contains(const PointT<double, DIM>& p, double tol)\t @return True if the point is on the line under the tolerance\n\t @param tol The tolerance\n\t @param p The point\n\t @brief Does the line contain a point under a distance tolerance\n",
 "output": "#include <catch.hpp>\n#include <testHelper.h>\n\nTEST_CASE(\"Contains Test\", \"[math][Line2][p1]\") {\n\tLine2 line;\n\tPoint2 point1(2., 1.);\n\tPoint2 point2(1., 1.);\n\tCHECK(line.Contains(point1, 1e-5));\n\tCHECK_FALSE(line.Contains(point2, 1e-5));\n\tCHECK(line.Contains(point2, 1.));\n}\n"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] const PointT<double, DIM>& Location()\t @return The location of the line\n\t @brief Get the location point of the line\n",
 "output": "#include <catch.hpp>\n#include <testHelper.h>\n\nTEST_CASE(\"Location Test\", \"[math][Line2][p1]\") {\n\tLine2 line;\n\tCHECK(line.Location().IsEqual(Point2(0., 0.), 1e-5));\n}\n"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "Derived& Mirror(const AxisT<double, DIM>& axis)\t @return The reference to self\n\t @param axis The mirror axis\n\t @brief Mirror the line by an axis\n",
 "output": "#include <catch.hpp>\n#include <testHelper.h>\n\nTEST_CASE(\"Mirror Test\", \"[math][Line2][p1]\") {\n\tLine2 line;\n\tAxis2 axis(Point2(1., 1.), Direction2(1., 0.));\n\tline.Mirror(axis);\n\tCHECK(line.Direction().IsEqual(Direction2(-1., 0.), 1e-5));\n}\n"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] Derived Mirrored(const AxisT<double, DIM>& axis)\t @return The mirrored line\n\t @param axis The mirror axis\n\t @brief Get the line mirrored by an axis\n",
 "output": "#include <catch.hpp>\n#include <testHelper.h>\n\nTEST_CASE(\"Mirrored Test\", \"[math][Line2][p1]\") {\n\tLine2 line;\n\tAxis2 axis(Point2(1., 1.), Direction2(1., 0.));\n\tLine2 mirroredLine = line.Mirrored(axis);\n\tCHECK(mirroredLine.Direction().IsEqual(Direction2(-1., 0.), 1e-5));\n}\n"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "Derived& Scale(const PointT<double, DIM>& point, double scale)\t @return The reference to self\n\t @param scale The scale value\n\t @param point The scaling center point\n\t @brief Scale the line by a point\n",
 "output": "#include <catch.hpp>\n#include <testHelper.h>\n\nTEST_CASE(\"Scale Test\", \"[math][Line2][p1]\") {\n\tLine2 line(Point2(0., -1.), Direction2());\n\tPoint2 point(0., 0.);\n\tline.Scale(point, 1.1);\n\tCHECK(line.Distance(point) > 0);\n}\n"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] Derived Scaled(const PointT<double, DIM>& point, double scale)\t @return The scaled line\n\t @param scale The scale value\n\t @param point The scaling center point\n\t @brief Get the line scaled by a point\n",
 "output": "#include <catch.hpp>\n#include <testHelper.h>\n\nTEST_CASE(\"Scaled Test\", \"[math][Line2][p1]\") {\n\tLine2 line(Point2(0., -1.), Direction2());\n\tPoint2 point(0., 0.);\n\tLine2 scaledLine = line.Scaled(point, 1.1);\n\tCHECK(scaledLine.Distance(point) > 0);\n}\n"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "Derived& Transform(const TransformationT<double, DIM>& tr)\t @return The reference to self\n\t @param tr The transformation\n\t @brief Transform the line\n",
 "output": "#include <catch.hpp>\n#include <testHelper.h>\n\nTEST_CASE(\"Transform Test\", \"[math][Line2][p1]\") {\n\tLine2 line;\n\tTransformation2 tfObject;\n\tline.Transform(tfObject);\n\tCHECK(line.Location().IsEqual(Point2(0., 0.), 1e-5));\n}\n"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] Derived Transformed(const TransformationT<double, DIM>& tr)\t @return The transformed line\n\t @param tr The transformation\n\t @brief Get the transformed line\n",
 "output": "#include <catch.hpp>\n#include <testHelper.h>\n\nTEST_CASE(\"Transformed Test\", \"[math][Line2][p1]\") {\n\tLine2 line;\n\tTransformation2 tfObject;\n\tLine2 transformedLine = line.Transformed(tfObject);\n\tCHECK(transformedLine.Location().IsEqual(Point2(0., 0.), 1e-5));\n}\n"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "Derived& Translate(const VectorT<double, DIM>& vec)\t @return The reference to self\n\t @param vec The translation vector\n\t @brief Translate the line by a vector\n",
 "output": "#include <catch.hpp>\n#include <testHelper.h>\n\nTEST_CASE(\"Translate Test\", \"[math][Line2][p1]\") {\n\tLine2 line;\n\tline.Translate(Vector2(2., 0.));\n\tCHECK(line.Contains(Point2(2., 0.), 1e-5));\n}\n"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "Derived& Translate(const PointT<double, DIM>& p1, const PointT<double, DIM>& p2)\t @return The reference to self\n\t @param p2 The target point\n\t @param p1 The source point\n\t @brief Translate the line by a vector from a point to another point\n",
 "output": "#include <catch.hpp>\n#include <testHelper.h>\n\nTEST_CASE(\"Translate Points Test\", \"[math][Line2][p1]\") {\n\tLine2 line;\n\tPoint2 p1(0., 0.), p2(2., 2.);\n\tline.Translate(p1, p2);\n\tCHECK(line.Contains(p2, 1e-5));\n}\n"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] Derived Translated(const VectorT<double, DIM>& vec)\t @return The translated line\n\t @param vec The translation vector\n\t @brief Get the line translated by a vector\n",
 "output": "#include <catch.hpp>\n#include <testHelper.h>\n\nTEST_CASE(\"Translated Test\", \"[math][Line2][p1]\") {\n\tLine2 line;\n\tLine2 translatedLine = line.Translated(Vector2(2., 0.));\n\tCHECK(translatedLine.Contains(Point2(2., 0.), 1e-5));\n}\n"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] Derived Translated(const PointT<double, DIM>& p1, const PointT<double, DIM>& p2)\t @return The translated line\n\t @param p2 The target point\n\t @param p1 The source point\n\t @brief Get the line translated by a vector from a point to another point\n",
 "output": "#include <catch.hpp>\n#include <testHelper.h>\n\nTEST_CASE(\"Translated Points Test\", \"[math][Line2][p1]\") {\n\tLine2 line;\n\tPoint2 p1(0., 0.), p2(2., 2.);\n\tLine2 translatedLine = line.Translated(p1, p2);\n\tCHECK(translatedLine.Contains(p2, 1e-5));\n}\n"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "void SetLocation(const PointT<double, DIM>& point)\t @param point The location point\n\t @brief Set the location of the line\n",
 "output": "#include <catch.hpp>\n#include <testHelper.h>\n\nTEST_CASE(\"SetLocation Test\", \"[math][Line2][p1]\") {\n\tLine2 line;\n\tline.SetLocation(Point2(2., 1.));\n\tCHECK(line.Location().IsEqual(Point2(2., 1.), 1e-5));\n}\n"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "void SetDirection(const DirectionT<double, DIM>& dir)\t @param dir The line direction\n\t @brief Set the line direction\n",
 "output": "#include <catch.hpp>\n#include <testHelper.h>\n\nTEST_CASE(\"SetDirection Test\", \"[math][Line2][p1]\") {\n\tLine2 line;\n\tline.SetDirection(Direction2(1., 1.));\n\tCHECK(line.Direction().IsEqual(Direction2(1., 1.), 1e-5));\n}\n"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "void SetPosition(const AxisT<double, DIM>& axis)\t @param axis The axis\n\t @brief Set the axis of the line\n",
 "output": "#include <catch.hpp>\n#include <testHelper.h>\n\nTEST_CASE(\"SetPosition Test\", \"[math][Line2][p1]\") {\n\tLine2 line;\n\tAxis2 axis(Point2(2., 1.), Direction2(1., 1.));\n\tline.SetPosition(axis);\n\tCHECK(line.Location().IsEqual(Point2(2., 1.), 1e-5));\n}\n"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] const DirectionT<double, DIM>& Direction()\t @return The direction of the line\n\t @brief Get the direction of the line\n",
 "output": "#include <catch.hpp>\n#include <testHelper.h>\n\nTEST_CASE(\"Direction Test\", \"[math][Line2][p1]\") {\n\tLine2 line;\n\tCHECK(line.Direction().IsEqual(Direction2(1., 0.), 1e-5));\n}\n"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] const AxisT<double, DIM>& Position()\t @return The axis of the line\n\t @brief Get the axis of the line\n",
 "output": "#include <catch.hpp>\n#include <testHelper.h>\n\nTEST_CASE(\"Position Test\", \"[math][Line2][p1]\") {\n\tLine2 line;\n\tCHECK(line.Position().IsEqual(Axis2(Point2(0., 0.), Direction2(1., 0.)), 1e-5));\n}\n"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] auto Angle(const LineBase& other)\t @return The angle between the line and the other line\n\t @param other The other line\n\t @brief Compute the angle between the line and the other line\n",
 "output": "#include <catch.hpp>\n#include <testHelper.h>\n\nTEST_CASE(\"Angle Test\", \"[math][Line2][p1]\") {\n\tLine2 line1(Point2(0., 0.), Direction2(1., 0.));\n\tLine2 line2(Point2(0., 0.), Direction2(0., 1.));\n\tCHECK(line1.Angle(line2) == Approx(M_PI_2));\n}\n"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "Derived& Reverse()\t @return The reference to self\n\t @brief Reverse the line direction\n",
 "output": "#include <catch.hpp>\n#include <testHelper.h>\n\nTEST_CASE(\"Reverse Test\", \"[math][Line2][p1]\") {\n\tLine2 line;\n\tline.Reverse();\n\tCHECK(line.Direction().IsEqual(Direction2(-1., 0.), 1e-5));\n}\n"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] Derived Reversed()\t @return The line with reversed direction\n\t @brief Get the line with reversed direction\n",
 "output": "#include <catch.hpp>\n#include <testHelper.h>\n\nTEST_CASE(\"Reversed Test\", \"[math][Line2][p1]\") {\n\tLine2 line;\n\tLine2 reversedLine = line.Reversed();\n\tCHECK(reversedLine.Direction().IsEqual(Direction2(-1., 0.), 1e-5));\n}\n"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "Derived& Mirror(const PointT<double, DIM>& point)\t @return The reference to self\n\t @param point The mirror center point\n\t @brief Mirror the line by a point\n",
 "output": "#include <catch.hpp>\n#include <testHelper.h>\n\nTEST_CASE(\"Mirror Point Test\", \"[math][Line2][p1]\") {\n\tLine2 line(Point2(2., 1.), Direction2(1., 1.));\n\tPoint2 point(4., -6.);\n\tline.Mirror(point);\n\tCHECK(line.Distance(point) == Approx(0.).margin(1e-5));\n}\n"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] Derived Mirrored(const PointT<double, DIM>& point)\t @return The mirrored line\n\t @param point The mirror center point\n\t @brief Get the line mirrored by a point\n",
 "output": "#include <catch.hpp>\n#include <testHelper.h>\n\nTEST_CASE(\"Mirrored Point Test\", \"[math][Line2][p1]\") {\n\tLine2 line(Point2(2., 1.), Direction2(1., 1.));\n\tPoint2 point(4., -6.);\n\tLine2 mirroredLine = line.Mirrored(point);\n\tCHECK(mirroredLine.Distance(point) == Approx(0.).margin(1e-5));\n}\n"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "LineS(double a, double b, double c)\t @param a,b,c The coefficients\n\t @brief Construct from the algebraic coefficients of 2D line\n",
 "output": "#include <catch.hpp>\n#include <testHelper.h>\n\nTEST_CASE(\"Constructor Test\", \"[math][Line2][p1]\") {\n\tLineS line(1., -2., -1.);\n\tCHECK(line.Coefficients() == std::make_tuple(1., -2., -1.));\n}\n"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "void Coefficients(double& a, double& b, double& c)\t @param[out] a,b,c The coefficients\n\t @brief The coefficients of the algebraic representation of the 2D line\n",
 "output": "#include <catch.hpp>\n#include <testHelper.h>\n\nTEST_CASE(\"Coefficients Test\", \"[math][Line2][p1]\") {\n\tLine2 line(1., -2., -1.);\n\tdouble a, b, c;\n\tline.Coefficients(a, b, c);\n\tCHECK(a == 1.);\n\tCHECK(b == -2.);\n\tCHECK(c == -1.);\n}\n"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] auto Distance(const Point2& p)\t @return The distance between the point and the line\n\t @param p The point\n\t @brief Compute the distance from a point to the line\n",
 "output": "#include <catch.hpp>\n#include <testHelper.h>\n\nTEST_CASE(\"Distance Test\", \"[math][Line2][p1]\") {\n\tLine2 line(1., -2., -1.);\n\tPoint2 point(2., 2.);\n\tCHECK(line.Distance(point) == Approx(1.414));\n}\n"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] auto Distance(const LineS& l)\t @return The distance between two lines\n\t @param l The other line\n\t @brief Compute the distance between two lines\n",
 "output": "#include <catch.hpp>\n#include <testHelper.h>\n\nTEST_CASE(\"Distance Between Lines Test\", \"[math][Line2][p1]\") {\n\tLine2 line1(1., -2., -1.);\n\tLine2 line2(1., 1., 1.);\n\tCHECK(line1.Distance(line2) == Approx(1.414));\n}\n"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] auto SquaredDistance(const Point2& p)\t @return The squared distance between the point and the line\n\t @param p The point\n\t @brief Compute the squared distance from a point to the line\n",
 "output": "#include <catch.hpp>\n#include <testHelper.h>\n\nTEST_CASE(\"Squared Distance Test\", \"[math][Line2][p1]\") {\n\tLine2 line(1., -2., -1.);\n\tPoint2 point(2., 2.);\n\tCHECK(line.SquaredDistance(point) == Approx(2.));\n}\n"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] auto SquaredDistance(const LineS& l)\t @return The squared distance between two lines\n\t @param l The other line\n\t @brief Compute the squared distance between two lines\n",
 "output": "#include <catch.hpp>\n#include <testHelper.h>\n\nTEST_CASE(\"Squared Distance Between Lines Test\", \"[math][Line2][p1]\") {\n\tLine2 line1(1., -2., -1.);\n\tLine2 line2(1., 1., 1.);\n\tCHECK(line1.SquaredDistance(line2) == Approx(2.));\n}\n"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] LineS Normal(const Point2& p)\t @return The line passing through a point and perpendicular to the line\n\t @param p The point\n\t @brief Get a line passing through a point and perpendicular to the line\n",
 "output": "#include <catch.hpp>\n#include <testHelper.h>\n\nTEST_CASE(\"Normal Test\", \"[math][Line2][p1]\") {\n\tLine2 line(1., -2., -1.);\n\tPoint2 point(2., 2.);\n\tLine2 normalLine = line.Normal(point);\n\tCHECK(normalLine.Distance(point) == 0);\n}\n"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "LineS& Rotate(const Point2& point, double angle)\t @return The reference to self\n\t @param angle The rotation angle\n\t @param point The rotation center point\n\t @brief Rotate the line around a point with an angle in 2D\n",
 "output": "#include <catch.hpp>\n#include <testHelper.h>\n\nTEST_CASE(\"Rotate Test\", \"[math][Line2][p1]\") {\n\tLine2 line(Point2(0., 1.), Direction2(1., 0.));\n\tline.Rotate(Point2(0., 0.), M_PI / 4);\n\tCHECK(line.Direction().IsEqual(Direction2(0.7071, 0.7071), 1e-5));\n}\n"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] LineS Rotated(const Point2& point, double angle)\t @return The rotated line\n\t @param angle The rotation angle\n\t @param point The rotation center point\n\t @brief Get the line rotated around a point with an angle in 2D\n",
 "output": "#include <catch.hpp>\n#include <testHelper.h>\n\nTEST_CASE(\"Rotated Test\", \"[math][Line2][p1]\") {\n\tLine2 line(Point2(0., 1.), Direction2(1., 0.));\n\tLine2 rotatedLine = line.Rotated(Point2(0., 0.), M_PI / 4);\n\tCHECK(rotatedLine.Direction().IsEqual(Direction2(0.7071, 0.7071), 1e-5));\n}\n"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] auto Distance(const Point3& p)\t @return The distance between the point and the line\n\t @param p The point\n\t @brief Compute the distance from a point to the line\n",
 "output": "#include <catch.hpp>\n#include <testHelper.h>\n\nTEST_CASE(\"Distance in 3D Test\", \"[math][Line2][p1]\") {\n\tLine2 line(1., -2., -1.);\n\tPoint3 point(2., 2., 2.);\n\tCHECK(line.Distance(point) == Approx(1.414));\n}\n"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] auto SquaredDistance(const Point3& p)\t @return The squared distance between the point and the line\n\t @param p The point\n\t @brief Compute the squared distance from a point to the line\n",
 "output": "#include <catch.hpp>\n#include <testHelper.h>\n\nTEST_CASE(\"Squared Distance in 3D Test\", \"[math][Line2][p1]\") {\n\tLine2 line(1., -2., -1.);\n\tPoint3 point(2., 2., 2.);\n\tCHECK(line.SquaredDistance(point) == Approx(2.));\n}\n"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] LineS Normal(const Point3& p)\t @return The line passing through a point and perpendicular to the line\n\t @param p The point\n\t @brief Get a line passing through a point and perpendicular to the line\n",
 "output": "#include <catch.hpp>\n#include <testHelper.h>\n\nTEST_CASE(\"Normal in 3D Test\", \"[math][Line2][p1]\") {\n\tLine2 line(1., -2., -1.);\n\tPoint3 point(2., 2., 2.);\n\tLine2 normalLine = line.Normal(point);\n\tCHECK(normalLine.Distance(point) == 0);\n}\n"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "LineS& Mirror(const Frame3& frame)\t @return The reference to self\n\t @param frame The mirror frame\n\t @brief Mirror the line by a frame\n",
 "output": "#include <catch.hpp>\n#include <testHelper.h>\n\nTEST_CASE(\"Mirror Frame Test\", \"[math][Line2][p1]\") {\n\tLine2 line;\n\tFrame3 frame;\n\tline.Mirror(frame);\n\tCHECK(line.Direction().IsEqual(Direction2(-1., 0.), 1e-5));\n}\n"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] LineS Mirrored(const Frame3& frame)\t @return The mirrored line\n\t @param frame The mirror frame\n\t @brief Get the line mirrored by a frame\n",
 "output": "#include <catch.hpp>\n#include <testHelper.h>\n\nTEST_CASE(\"Mirrored Frame Test\", \"[math][Line2][p1]\") {\n\tLine2 line;\n\tFrame3 frame;\n\tLine2 mirroredLine = line.Mirrored(frame);\n\tCHECK(mirroredLine.Direction().IsEqual(Direction2(-1., 0.), 1e-5));\n}\n"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "LineS& Rotate(const Axis3& axis, double angle)\t @return The reference to self\n\t @param angle The rotation angle\n\t @param axis The rotation axis\n\t @brief Rotate the line around an axis with an angle in 3D\n",
 "output": "#include <catch.hpp>\n#include <testHelper.h>\n\nTEST_CASE(\"Rotate Axis Test\", \"[math][Line2][p1]\") {\n\tLine2 line;\n\tAxis3 axis;\n\tline.Rotate(axis, M_PI / 4);\n\tCHECK(line.Direction().IsEqual(Direction2(0.7071, 0.7071), 1e-5));\n}\n"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] LineS Rotated(const Axis3& axis, double angle)\t @return The rotated line\n\t @param angle The rotation angle\n\t @param axis The rotation axis\n\t @brief Get the line rotated around an axis with an angle in 3D\n",
 "output": "#include <catch.hpp>\n#include <testHelper.h>\n\nTEST_CASE(\"Rotated Axis Test\", \"[math][Line2][p1]\") {\n\tLine2 line;\n\tAxis3 axis;\n\tLine2 rotatedLine = line.Rotated(axis, M_PI / 4);\n\tCHECK(rotatedLine.Direction().IsEqual(Direction2(0.7071, 0.7071), 1e-5));\n}\n"}{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] bool Contains(const PointT<double, DIM>& p, double tol)\t @return True if the point is on the line under the tolerance\n\t @param tol The tolerance\n\t @param p The point\n\t @brief Does the line contain a point under a distance tolerance",
 "output": "#include <catch.hpp>\n#include <testHelper.h>\n\nTEST_CASE(\"case1: Contains Method Test\", \"[math][Line3][Contains]\")\n\tLine3 line;\n\tCHECK(line.Contains(Point3(1., 1., 1.), 0.1) == true);\n\tCHECK(line.Contains(Point3(2., 2., 2.), 0.1) == false);\n"}
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] const PointT<double, DIM>& Location()\t @return The location of the line\n\t @brief Get the location point of the line",
 "output": "#include <catch.hpp>\n#include <testHelper.h>\n\nTEST_CASE(\"case2: Location Method Test\", \"[math][Line3][Location]\")\n\tLine3 line;\n\tCHECK(line.Location() == Point3(0., 0., 0.));\n"}
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "Derived& Mirror(const AxisT<double, DIM>& axis)\t @return The reference to self\n\t @param axis The mirror axis\n\t @brief Mirror the line by an axis",
 "output": "#include <catch.hpp>\n#include <testHelper.h>\n\nTEST_CASE(\"case3: Mirror Method Test\", \"[math][Line3][Mirror]\")\n\tAxis3 axis(Point3(0., 0., 0.), Direction3(1., 0., 0.));\n\tLine3 line;\n\tline.Mirror(axis);\n\tCHECK(line.Location() == expectedLocation);\n"}
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] Derived Mirrored(const AxisT<double, DIM>& axis)\t @return The mirrored line\n\t @param axis The mirror axis\n\t @brief Get the line mirrored by an axis",
 "output": "#include <catch.hpp>\n#include <testHelper.h>\n\nTEST_CASE(\"case4: Mirrored Method Test\", \"[math][Line3][Mirrored]\")\n\tAxis3 axis(Point3(0., 0., 0.), Direction3(1., 0., 0.));\n\tLine3 line;\n\tLine3 mirroredLine = line.Mirrored(axis);\n\tCHECK(mirroredLine.Location() == expectedMirroredLocation);\n"}
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "Derived& Scale(const PointT<double, DIM>& point, double scale)\t @return The reference to self\n\t @param scale The scale value\n\t @param point The scaling center point\n\t @brief Scale the line by a point",
 "output": "#include <catch.hpp>\n#include <testHelper.h>\n\nTEST_CASE(\"case5: Scale Method Test\", \"[math][Line3][Scale]\")\n\tPoint3 center(1., 1., 1.);\n\tLine3 line;\n\tline.Scale(center, 2.0);\n\tCHECK(line.Location() == expectedScaledLocation);\n"}
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] Derived Scaled(const PointT<double, DIM>& point, double scale)\t @return The scaled line\n\t @param scale The scale value\n\t @param point The scaling center point\n\t @brief Get the line scaled by a point",
 "output": "#include <catch.hpp>\n#include <testHelper.h>\n\nTEST_CASE(\"case6: Scaled Method Test\", \"[math][Line3][Scaled]\")\n\tPoint3 center(1., 1., 1.);\n\tLine3 line;\n\tLine3 scaledLine = line.Scaled(center, 2.0);\n\tCHECK(scaledLine.Location() == expectedScaledLocation);\n"}
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "Derived& Transform(const TransformationT<double, DIM>& tr)\t @return The reference to self\n\t @param tr The transformation\n\t @brief Transform the line",
 "output": "#include <catch.hpp>\n#include <testHelper.h>\n\nTEST_CASE(\"case7: Transform Method Test\", \"[math][Line3][Transform]\")\n\tTransformation3 transform;\n\tLine3 line;\n\tline.Transform(transform);\n\tCHECK(line.Location() == expectedTransformedLocation);\n"}
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] Derived Transformed(const TransformationT<double, DIM>& tr)\t @return The transformed line\n\t @param tr The transformation\n\t @brief Get the transformed line",
 "output": "#include <catch.hpp>\n#include <testHelper.h>\n\nTEST_CASE(\"case8: Transformed Method Test\", \"[math][Line3][Transformed]\")\n\tTransformation3 transform;\n\tLine3 line;\n\tLine3 transformedLine = line.Transformed(transform);\n\tCHECK(transformedLine.Location() == expectedTransformedLocation);\n"}
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "Derived& Translate(const VectorT<double, DIM>& vec)\t @return The reference to self\n\t @param vec The translation vector\n\t @brief Translate the line by a vector",
 "output": "#include <catch.hpp>\n#include <testHelper.h>\n\nTEST_CASE(\"case9: Translate Method Test\", \"[math][Line3][Translate]\")\n\tVector3 translation(1., 1., 1.);\n\tLine3 line;\n\tline.Translate(translation);\n\tCHECK(line.Location() == expectedTranslatedLocation);\n"}
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "Derived& Translate(const PointT<double, DIM>& p1, const PointT<double, DIM>& p2)\t @return The reference to self\n\t @param p2 The target point\n\t @param p1 The source point\n\t @brief Translate the line by a vector from a point to another point",
 "output": "#include <catch.hpp>\n#include <testHelper.h>\n\nTEST_CASE(\"case10: Translate Method with Points Test\", \"[math][Line3][TranslatePoints]\")\n\tPoint3 from(0., 0., 0.), to(1., 1., 1.);\n\tLine3 line;\n\tline.Translate(from, to);\n\tCHECK(line.Location() == expectedTranslatedLocation);\n"}
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] Derived Translated(const VectorT<double, DIM>& vec)\t @return The translated line\n\t @param vec The translation vector\n\t @brief Get the line translated by a vector",
 "output": "#include <catch.hpp>\n#include <testHelper.h>\n\nTEST_CASE(\"case11: Translated Method Test\", \"[math][Line3][Translated]\")\n\tVector3 translation(1., 1., 1.);\n\tLine3 line;\n\tLine3 translatedLine = line.Translated(translation);\n\tCHECK(translatedLine.Location() == expectedTranslatedLocation);\n"}
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] Derived Translated(const PointT<double, DIM>& p1, const PointT<double, DIM>& p2)\t @return The translated line\n\t @param p2 The target point\n\t @param p1 The source point\n\t @brief Get the line translated by a vector from a point to another point",
 "output": "#include <catch.hpp>\n#include <testHelper.h>\n\nTEST_CASE(\"case12: Translated Method with Points Test\", \"[math][Line3][TranslatePoints]\")\n\tPoint3 from(0., 0., 0.), to(1., 1., 1.);\n\tLine3 line;\n\tLine3 translatedLine = line.Translated(from, to);\n\tCHECK(translatedLine.Location() == expectedTranslatedLocation);\n"}
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "void SetLocation(const PointT<double, DIM>& point)\t @param point The location point\n\t @brief Set the location of the line",
 "output": "#include <catch.hpp>\n#include <testHelper.h>\n\nTEST_CASE(\"case13: SetLocation Method Test\", \"[math][Line3][SetLocation]\")\n\tPoint3 point(1., 1., 1.);\n\tLine3 line;\n\tline.SetLocation(point);\n\tCHECK(line.Location() == point);\n"}
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "void SetDirection(const DirectionT<double, DIM>& dir)\t @param dir The line direction\n\t @brief Set the line direction",
 "output": "#include <catch.hpp>\n#include <testHelper.h>\n\nTEST_CASE(\"case14: SetDirection Method Test\", \"[math][Line3][SetDirection]\")\n\tDirection3 dir(1., 1., 1.);\n\tLine3 line;\n\tline.SetDirection(dir);\n\tCHECK(line.Direction() == dir);\n"}
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "void SetPosition(const AxisT<double, DIM>& axis)\t @param axis The axis\n\t @brief Set the axis of the line",
 "output": "#include <catch.hpp>\n#include <testHelper.h>\n\nTEST_CASE(\"case15: SetPosition Method Test\", \"[math][Line3][SetPosition]\")\n\tAxis3 axis(Point3(0., 0., 0.), Direction3(1., 0., 0.));\n\tLine3 line;\n\tline.SetPosition(axis);\n\tCHECK(line.Position() == axis);\n"}
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] const DirectionT<double, DIM>& Direction()\t @return The direction of the line\n\t @brief Get the direction of the line",
 "output": "#include <catch.hpp>\n#include <testHelper.h>\n\nTEST_CASE(\"case16: Direction Method Test\", \"[math][Line3][Direction]\")\n\tLine3 line;\n\tCHECK(line.Direction() == Direction3(0., 0., 1.));\n"}
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] const AxisT<double, DIM>& Position()\t @return The axis of the line\n\t @brief Get the axis of the line",
 "output": "#include <catch.hpp>\n#include <testHelper.h>\n\nTEST_CASE(\"case17: Position Method Test\", \"[math][Line3][Position]\")\n\tLine3 line;\n\tCHECK(line.Position() == Axis3(Point3(0., 0., 0.), Direction3(1., 0., 0.)));\n"}
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] auto Angle(const LineBase& other)\t @return The angle between the line and the other line\n\t @param other The other line\n\t @brief Compute the angle between the line and the other line",
 "output": "#include <catch.hpp>\n#include <testHelper.h>\n\nTEST_CASE(\"case18: Angle Method Test\", \"[math][Line3][Angle]\")\n\tLine3 line1(Point3(0., 0., 0.), Direction3(1., 0., 0.));\n\tLine3 line2(Point3(0., 0., 0.), Direction3(0., 1., 0.));\n\tCHECK(line1.Angle(line2) == Approx(M_PI / 2));\n"}
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "Derived& Reverse()\t @return The reference to self\n\t @brief Reverse the line direction",
 "output": "#include <catch.hpp>\n#include <testHelper.h>\n\nTEST_CASE(\"case19: Reverse Method Test\", \"[math][Line3][Reverse]\")\n\tLine3 line;\n\tline.Reverse();\n\tCHECK(line.Direction() == Direction3(-1., -1., -1.));\n"}
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] Derived Reversed()\t @return The line with reversed direction\n\t @brief Get the line with reversed direction",
 "output": "#include <catch.hpp>\n#include <testHelper.h>\n\nTEST_CASE(\"case20: Reversed Method Test\", \"[math][Line3][Reversed]\")\n\tLine3 line;\n\tLine3 reversedLine = line.Reversed();\n\tCHECK(reversedLine.Direction() == Direction3(-1., -1., -1.));\n"}
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "Derived& Mirror(const PointT<double, DIM>& point)\t @return The reference to self\n\t @param point The mirror center point\n\t @brief Mirror the line by a point",
 "output": "#include <catch.hpp>\n#include <testHelper.h>\n\nTEST_CASE(\"case21: Mirror Method with Point Test\", \"[math][Line3][MirrorPoint]\")\n\tPoint3 point(0., 0., 0.);\n\tLine3 line;\n\tline.Mirror(point);\n\tCHECK(line.Location() == expectedLocation);\n"}
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] Derived Mirrored(const PointT<double, DIM>& point)\t @return The mirrored line\n\t @param point The mirror center point\n\t @brief Get the line mirrored by a point",
 "output": "#include <catch.hpp>\n#include <testHelper.h>\n\nTEST_CASE(\"case22: Mirrored Method with Point Test\", \"[math][Line3][MirroredPoint]\")\n\tPoint3 point(0., 0., 0.);\n\tLine3 line;\n\tLine3 mirroredLine = line.Mirrored(point);\n\tCHECK(mirroredLine.Location() == expectedMirroredLocation);\n"}
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "LineS(double a, double b, double c)\t @param a,b,c The coefficients\n\t @brief Construct from the algebraic coefficients of 2D line",
 "output": "#include <catch.hpp>\n#include <testHelper.h>\n\nTEST_CASE(\"case23: LineS Constructor Test\", \"[math][LineS][Constructor]\")\n\tLineS line(1.0, 2.0, 3.0);\n\tCHECK(line.Distance(Point2(0., 0.)) == expectedDistance);\n"}
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "void Coefficients(double& a, double& b, double& c)\t @param[out] a,b,c The coefficients\n\t @brief The coefficients of the algebraic representation of the 2D line",
 "output": "#include <catch.hpp>\n#include <testHelper.h>\n\nTEST_CASE(\"case24: Coefficients Method Test\", \"[math][LineS][Coefficients]\")\n\tLineS line;\n\tdouble a, b, c;\n\tline.Coefficients(a, b, c);\n\tCHECK(a == expectedA);\n\tCHECK(b == expectedB);\n\tCHECK(c == expectedC);\n"}
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] auto Distance(const Point2& p)\t @return The distance between the point and the line\n\t @param p The point\n\t @brief Compute the distance from a point to the line",
 "output": "#include <catch.hpp>\n#include <testHelper.h>\n\nTEST_CASE(\"case25: Distance Method Test\", \"[math][LineS][Distance]\")\n\tLineS line;\n\tPoint2 point(1., 1.);\n\tCHECK(line.Distance(point) == expectedDistance);\n"}
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] auto Distance(const LineS& l)\t @return The distance between two lines\n\t @param l The other line\n\t @brief Compute the distance between two lines",
 "output": "#include <catch.hpp>\n#include <testHelper.h>\n\nTEST_CASE(\"case26: Distance Method with Line Test\", \"[math][LineS][DistanceLine]\")\n\tLineS line1(1.0, 2.0, 3.0);\n\tLineS line2(4.0, 5.0, 6.0);\n\tCHECK(line1.Distance(line2) == expectedDistance);\n"}
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] auto SquaredDistance(const Point2& p)\t @return The squared distance between the point and the line\n\t @param p The point\n\t @brief Compute the squared distance from a point to the line",
 "output": "#include <catch.hpp>\n#include <testHelper.h>\n\nTEST_CASE(\"case27: SquaredDistance Method Test\", \"[math][LineS][SquaredDistance]\")\n\tLineS line;\n\tPoint2 point(1., 1.);\n\tCHECK(line.SquaredDistance(point) == expectedSquaredDistance);\n"}
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] auto SquaredDistance(const LineS& l)\t @return The squared distance between two lines\n\t @param l The other line\n\t @brief Compute the squared distance between two lines",
 "output": "#include <catch.hpp>\n#include <testHelper.h>\n\nTEST_CASE(\"case28: SquaredDistance Method with Line Test\", \"[math][LineS][SquaredDistanceLine]\")\n\tLineS line1(1.0, 2.0, 3.0);\n\tLineS line2(4.0, 5.0, 6.0);\n\tCHECK(line1.SquaredDistance(line2) == expectedSquaredDistance);\n"}
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] LineS Normal(const Point2& p)\t @return The line passing through a point and perpendicular to the line\n\t @param p The point\n\t @brief Get a line passing through a point and perpendicular to the line",
 "output": "#include <catch.hpp>\n#include <testHelper.h>\n\nTEST_CASE(\"case29: Normal Method Test\", \"[math][LineS][Normal]\")\n\tPoint2 point(1., 1.);\n\tLineS line;\n\tLineS normalLine = line.Normal(point);\n\tCHECK(normalLine.Direction().IsEqual(expectedDirection));\n"}
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "LineS& Rotate(const Point2& point, double angle)\t @return The reference to self\n\t @param angle The rotation angle\n\t @param point The rotation center point\n\t @brief Rotate the line around a point with an angle in 2D",
 "output": "#include <catch.hpp>\n#include <testHelper.h>\n\nTEST_CASE(\"case30: Rotate Method Test\", \"[math][LineS][Rotate]\")\n\tPoint2 point(0., 0.);\n\tLineS line;\n\tline.Rotate(point, 90.0);\n\tCHECK(line.Location() == expectedLocation);\n"}
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] LineS Rotated(const Point2& point, double angle)\t @return The rotated line\n\t @param angle The rotation angle\n\t @param point The rotation center point\n\t @brief Get the line rotated around a point with an angle in 2D",
 "output": "#include <catch.hpp>\n#include <testHelper.h>\n\nTEST_CASE(\"case31: Rotated Method Test\", \"[math][LineS][Rotated]\")\n\tPoint2 point(0., 0.);\n\tLineS line;\n\tLineS rotatedLine = line.Rotated(point, 90.0);\n\tCHECK(rotatedLine.Location() == expectedRotatedLocation);\n"}
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] auto Distance(const Point3& p)\t @return The distance between the point and the line\n\t @param p The point\n\t @brief Compute the distance from a point to the line",
 "output": "#include <catch.hpp>\n#include <testHelper.h>\n\nTEST_CASE(\"case32: Distance Method with Point3 Test\", \"[math][Line3][DistancePoint3]\")\n\tLine3 line;\n\tPoint3 point(1., 1., 1.);\n\tCHECK(line.Distance(point) == expectedDistance);\n"}
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] auto SquaredDistance(const Point3& p)\t @return The squared distance between the point and the line\n\t @param p The point\n\t @brief Compute the squared distance from a point to the line",
 "output": "#include <catch.hpp>\n#include <testHelper.h>\n\nTEST_CASE(\"case33: SquaredDistance Method with Point3 Test\", \"[math][Line3][SquaredDistancePoint3]\")\n\tLine3 line;\n\tPoint3 point(1., 1., 1.);\n\tCHECK(line.SquaredDistance(point) == expectedSquaredDistance);\n"}
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] LineS Normal(const Point3& p)\t @return The line passing through a point and perpendicular to the line\n\t @param p The point\n\t @brief Get a line passing through a point and perpendicular to the line",
 "output": "#include <catch.hpp>\n#include <testHelper.h>\n\nTEST_CASE(\"case34: Normal Method with Point3 Test\", \"[math][LineS][NormalPoint3]\")\n\tPoint3 point(1., 1., 1.);\n\tLineS line;\n\tLineS normalLine = line.Normal(point);\n\tCHECK(normalLine.Direction().IsEqual(expectedDirection));\n"}
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] const PointT<double, DIM>& Location()\\t @return The location of the line\\n\\t @brief Get the location point of the line\\n",
 "output": "#include<catch.hpp>\\n#include<testHelper.h>\\n\\nTEST_CASE(\"Test Location Method\", \"[Location]\") {\\n\\tconst PointT<double, DIM>& loc = Location();\\n\\tCHECK(loc == expectedLocation);\\n}"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "Derived& Mirror(const AxisT<double, DIM>& axis)\\t @return The reference to self\\n\\t @param axis The mirror axis\\n\\t @brief Mirror the line by an axis\\n",
 "output": "#include<catch.hpp>\\n#include<testHelper.h>\\n\\nTEST_CASE(\"Test Mirror Method\", \"[Mirror]\") {\\n\\tAxisT<double, DIM> axis;\\n\\tDerived& ref = Mirror(axis);\\n\\tCHECK(ref == expectedReference);\\n}"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] Derived Mirrored(const AxisT<double, DIM>& axis)\\t @return The mirrored line\\n\\t @param axis The mirror axis\\n\\t @brief Get the line mirrored by an axis\\n",
 "output": "#include<catch.hpp>\\n#include<testHelper.h>\\n\\nTEST_CASE(\"Test Mirrored Method\", \"[Mirrored]\") {\\n\\tAxisT<double, DIM> axis;\\n\\tDerived mirroredLine = Mirrored(axis);\\n\\tCHECK(mirroredLine == expectedMirrored);\\n}"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "Derived& Scale(const PointT<double, DIM>& point, double scale)\\t @return The reference to self\\n\\t @param scale The scale value\\n\\t @param point The scaling center point\\n\\t @brief Scale the line by a point\\n",
 "output": "#include<catch.hpp>\\n#include<testHelper.h>\\n\\nTEST_CASE(\"Test Scale Method\", \"[Scale]\") {\\n\\tPointT<double, DIM> point;\\n\\tdouble scaleValue;\\n\\tDerived& ref = Scale(point, scaleValue);\\n\\tCHECK(ref == expectedScaled);\\n}"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] Derived Scaled(const PointT<double, DIM>& point, double scale)\\t @return The scaled line\\n\\t @param scale The scale value\\n\\t @param point The scaling center point\\n\\t @brief Get the line scaled by a point\\n",
 "output": "#include<catch.hpp>\\n#include<testHelper.h>\\n\\nTEST_CASE(\"Test Scaled Method\", \"[Scaled]\") {\\n\\tPointT<double, DIM> point;\\n\\tdouble scaleValue;\\n\\tDerived scaledLine = Scaled(point, scaleValue);\\n\\tCHECK(scaledLine == expectedScaledLine);\\n}"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "Derived& Transform(const TransformationT<double, DIM>& tr)\\t @return The reference to self\\n\\t @param tr The transformation\\n\\t @brief Transform the line\\n",
 "output": "#include<catch.hpp>\\n#include<testHelper.h>\\n\\nTEST_CASE(\"Test Transform Method\", \"[Transform]\") {\\n\\tTransformationT<double, DIM> transformation;\\n\\tDerived& ref = Transform(transformation);\\n\\tCHECK(ref == expectedTransformed);\\n}"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] Derived Transformed(const TransformationT<double, DIM>& tr)\\t @return The transformed line\\n\\t @param tr The transformation\\n\\t @brief Get the transformed line\\n",
 "output": "#include<catch.hpp>\\n#include<testHelper.h>\\n\\nTEST_CASE(\"Test Transformed Method\", \"[Transformed]\") {\\n\\tTransformationT<double, DIM> transformation;\\n\\tDerived transformedLine = Transformed(transformation);\\n\\tCHECK(transformedLine == expectedTransformedLine);\\n}"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "Derived& Translate(const VectorT<double, DIM>& vec)\\t @return The reference to self\\n\\t @param vec The translation vector\\n\\t @brief Translate the line by a vector\\n",
 "output": "#include<catch.hpp>\\n#include<testHelper.h>\\n\\nTEST_CASE(\"Test Translate Method\", \"[Translate]\") {\\n\\tVectorT<double, DIM> vector;\\n\\tDerived& ref = Translate(vector);\\n\\tCHECK(ref == expectedTranslated);\\n}"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "Derived& Translate(const PointT<double, DIM>& p1, const PointT<double, DIM>& p2)\\t @return The reference to self\\n\\t @param p2 The target point\\n\\t @param p1 The source point\\n\\t @brief Translate the line by a vector from a point to another point\\n",
 "output": "#include<catch.hpp>\\n#include<testHelper.h>\\n\\nTEST_CASE(\"Test Translate with Points Method\", \"[Translate]\") {\\n\\tPointT<double, DIM> p1, p2;\\n\\tDerived& ref = Translate(p1, p2);\\n\\tCHECK(ref == expectedTranslatedWithPoints);\\n}"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] Derived Translated(const VectorT<double, DIM>& vec)\\t @return The translated line\\n\\t @param vec The translation vector\\n\\t @brief Get the line translated by a vector\\n",
 "output": "#include<catch.hpp>\\n#include<testHelper.h>\\n\\nTEST_CASE(\"Test Translated Method\", \"[Translated]\") {\\n\\tVectorT<double, DIM> vector;\\n\\tDerived translatedLine = Translated(vector);\\n\\tCHECK(translatedLine == expectedTranslatedLine);\\n}"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] Derived Translated(const PointT<double, DIM>& p1, const PointT<double, DIM>& p2)\\t @return The translated line\\n\\t @param p2 The target point\\n\\t @param p1 The source point\\n\\t @brief Get the line translated by a vector from a point to another point\\n",
 "output": "#include<catch.hpp>\\n#include<testHelper.h>\\n\\nTEST_CASE(\"Test Translated with Points Method\", \"[Translated]\") {\\n\\tPointT<double, DIM> p1, p2;\\n\\tDerived translatedLine = Translated(p1, p2);\\n\\tCHECK(translatedLine == expectedTranslatedWithPoints);\\n}"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "void SetLocation(const PointT<double, DIM>& point)\\t @param point The location point\\n\\t @brief Set the location of the line\\n",
 "output": "#include<catch.hpp>\\n#include<testHelper.h>\\n\\nTEST_CASE(\"Test SetLocation Method\", \"[SetLocation]\") {\\n\\tPointT<double, DIM> point;\\n\\tSetLocation(point);\\n\\t// Add checks to validate location set\\n}"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "void SetDirection(const DirectionT<double, DIM>& dir)\\t @param dir The line direction\\n\\t @brief Set the line direction\\n",
 "output": "#include<catch.hpp>\\n#include<testHelper.h>\\n\\nTEST_CASE(\"Test SetDirection Method\", \"[SetDirection]\") {\\n\\tDirectionT<double, DIM> direction;\\n\\tSetDirection(direction);\\n\\t// Add checks to validate direction set\\n}"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "void SetPosition(const AxisT<double, DIM>& axis)\\t @param axis The axis\\n\\t @brief Set the axis of the line\\n",
 "output": "#include<catch.hpp>\\n#include<testHelper.h>\\n\\nTEST_CASE(\"Test SetPosition Method\", \"[SetPosition]\") {\\n\\tAxisT<double, DIM> axis;\\n\\tSetPosition(axis);\\n\\t// Add checks to validate position set\\n}"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] const DirectionT<double, DIM>& Direction()\\t @return The direction of the line\\n\\t @brief Get the direction of the line\\n",
 "output": "#include<catch.hpp>\\n#include<testHelper.h>\\n\\nTEST_CASE(\"Test Direction Method\", \"[Direction]\") {\\n\\tconst DirectionT<double, DIM>& dir = Direction();\\n\\tCHECK(dir == expectedDirection);\\n}"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] const AxisT<double, DIM>& Position()\\t @return The axis of the line\\n\\t @brief Get the axis of the line\\n",
 "output": "#include<catch.hpp>\\n#include<testHelper.h>\\n\\nTEST_CASE(\"Test Position Method\", \"[Position]\") {\\n\\tconst AxisT<double, DIM>& pos = Position();\\n\\tCHECK(pos == expectedPosition);\\n}"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] auto Angle(const LineBase& other)\\t @return The angle between the line and the other line\\n\\t @param other The other line\\n\\t @brief Compute the angle between the line and the other line\\n",
 "output": "#include<catch.hpp>\\n#include<testHelper.h>\\n\\nTEST_CASE(\"Test Angle Method\", \"[Angle]\") {\\n\\tLineBase other;\\n\\tauto angle = Angle(other);\\n\\tCHECK(angle == expectedAngle);\\n}"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "Derived& Reverse()\\t @return The reference to self\\n\\t @brief Reverse the line direction\\n",
 "output": "#include<catch.hpp>\\n#include<testHelper.h>\\n\\nTEST_CASE(\"Test Reverse Method\", \"[Reverse]\") {\\n\\tDerived& ref = Reverse();\\n\\tCHECK(ref == expectedReverse);\\n}"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] Derived Reversed()\\t @return The line with reversed direction\\n\\t @brief Get the line with reversed direction\\n",
 "output": "#include<catch.hpp>\\n#include<testHelper.h>\\n\\nTEST_CASE(\"Test Reversed Method\", \"[Reversed]\") {\\n\\tDerived reversedLine = Reversed();\\n\\tCHECK(reversedLine == expectedReversed);\\n}"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "Derived& Mirror(const PointT<double, DIM>& point)\\t @return The reference to self\\n\\t @param point The mirror center point\\n\\t @brief Mirror the line by a point\\n",
 "output": "#include<catch.hpp>\\n#include<testHelper.h>\\n\\nTEST_CASE(\"Test Mirror with Point Method\", \"[Mirror]\") {\\n\\tPointT<double, DIM> point;\\n\\tDerived& ref = Mirror(point);\\n\\tCHECK(ref == expectedMirrorWithPoint);\\n}"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] Derived Mirrored(const PointT<double, DIM>& point)\\t @return The mirrored line\\n\\t @param point The mirror center point\\n\\t @brief Get the line mirrored by a point\\n",
 "output": "#include<catch.hpp>\\n#include<testHelper.h>\\n\\nTEST_CASE(\"Test Mirrored with Point Method\", \"[Mirrored]\") {\\n\\tPointT<double, DIM> point;\\n\\tDerived mirroredLine = Mirrored(point);\\n\\tCHECK(mirroredLine == expectedMirroredWithPoint);\\n}"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "LineS(double a, double b, double c)\\t @param a,b,c The coefficients\\n\\t @brief Construct from the algebraic coefficients of 2D line\\n",
 "output": "#include<catch.hpp>\\n#include<testHelper.h>\\n\\nTEST_CASE(\"Test LineS Constructor\", \"[LineS]\") {\\n\\tdouble a, b, c;\\n\\tLineS line(a, b, c);\\n\\t// Add checks to validate line construction\\n}"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "void Coefficients(double& a, double& b, double& c)\\t @param[out] a,b,c The coefficients\\n\\t @brief The coefficients of the algebraic representation of the 2D line\\n",
 "output": "#include<catch.hpp>\\n#include<testHelper.h>\\n\\nTEST_CASE(\"Test Coefficients Method\", \"[Coefficients]\") {\\n\\tdouble a, b, c;\\n\\tCoefficients(a, b, c);\\n\\t// Add checks to validate coefficients\\n}"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] auto Distance(const Point2& p)\\t @return The distance between the point and the line\\n\\t @param p The point\\n\\t @brief Compute the distance from a point to the line\\n",
 "output": "#include<catch.hpp>\\n#include<testHelper.h>\\n\\nTEST_CASE(\"Test Distance Method with Point2\", \"[Distance]\") {\\n\\tPoint2 point;\\n\\tauto distance = Distance(point);\\n\\tCHECK(distance == expectedDistance);\\n}"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] auto Distance(const LineS& l)\\t @return The distance between two lines\\n\\t @param l The other line\\n\\t @brief Compute the distance between two lines\\n",
 "output": "#include<catch.hpp>\\n#include<testHelper.h>\\n\\nTEST_CASE(\"Test Distance Method with LineS\", \"[Distance]\") {\\n\\tLineS line;\\n\\tauto distance = Distance(line);\\n\\tCHECK(distance == expectedDistanceBetweenLines);\\n}"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] auto SquaredDistance(const Point2& p)\\t @return The squared distance between the point and the line\\n\\t @param p The point\\n\\t @brief Compute the squared distance from a point to the line\\n",
 "output": "#include<catch.hpp>\\n#include<testHelper.h>\\n\\nTEST_CASE(\"Test SquaredDistance Method with Point2\", \"[SquaredDistance]\") {\\n\\tPoint2 point;\\n\\tauto squaredDistance = SquaredDistance(point);\\n\\tCHECK(squaredDistance == expectedSquaredDistance);\\n}"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] auto SquaredDistance(const LineS& l)\\t @return The squared distance between two lines\\n\\t @param l The other line\\n\\t @brief Compute the squared distance between two lines\\n",
 "output": "#include<catch.hpp>\\n#include<testHelper.h>\\n\\nTEST_CASE(\"Test SquaredDistance Method with LineS\", \"[SquaredDistance]\") {\\n\\tLineS line;\\n\\tauto squaredDistance = SquaredDistance(line);\\n\\tCHECK(squaredDistance == expectedSquaredDistanceBetweenLines);\\n}"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] LineS Normal(const Point2& p)\\t @return The line passing through a point and perpendicular to the line\\n\\t @param p The point\\n\\t @brief Get a line passing through a point and perpendicular to the line\\n",
 "output": "#include<catch.hpp>\\n#include<testHelper.h>\\n\\nTEST_CASE(\"Test Normal Method with Point2\", \"[Normal]\") {\\n\\tPoint2 point;\\n\\tLineS normalLine = Normal(point);\\n\\tCHECK(normalLine == expectedNormalLine);\\n}"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "LineS& Rotate(const Point2& point, double angle)\\t @return The reference to self\\n\\t @param angle The rotation angle\\n\\t @param point The rotation center point\\n\\t @brief Rotate the line around a point with an angle in 2D\\n",
 "output": "#include<catch.hpp>\\n#include<testHelper.h>\\n\\nTEST_CASE(\"Test Rotate Method\", \"[Rotate]\") {\\n\\tPoint2 center;\\n\\tdouble angle;\\n\\tLineS& ref = Rotate(center, angle);\\n\\tCHECK(ref == expectedRotated);\\n}"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] LineS Rotated(const Point2& point, double angle)\\t @return The rotated line\\n\\t @param angle The rotation angle\\n\\t @param point The rotation center point\\n\\t @brief Get the line rotated around a point with an angle in 2D\\n",
 "output": "#include<catch.hpp>\\n#include<testHelper.h>\\n\\nTEST_CASE(\"Test Rotated Method\", \"[Rotated]\") {\\n\\tPoint2 center;\\n\\tdouble angle;\\n\\tLineS rotatedLine = Rotated(center, angle);\\n\\tCHECK(rotatedLine == expectedRotatedLine);\\n}"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] auto Distance(const Point3& p)\\t @return The distance between the point and the line\\n\\t @param p The point\\n\\t @brief Compute the distance from a point to the line\\n",
 "output": "#include<catch.hpp>\\n#include<testHelper.h>\\n\\nTEST_CASE(\"Test Distance Method with Point3\", \"[Distance]\") {\\n\\tPoint3 point;\\n\\tauto distance = Distance(point);\\n\\tCHECK(distance == expectedDistance);\\n}"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] auto SquaredDistance(const Point3& p)\\t @return The squared distance between the point and the line\\n\\t @param p The point\\n\\t @brief Compute the squared distance from a point to the line\\n",
 "output": "#include<catch.hpp>\\n#include<testHelper.h>\\n\\nTEST_CASE(\"Test SquaredDistance Method with Point3\", \"[SquaredDistance]\") {\\n\\tPoint3 point;\\n\\tauto squaredDistance = SquaredDistance(point);\\n\\tCHECK(squaredDistance == expectedSquaredDistance);\\n}"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] LineS Normal(const Point3& p)\\t @return The line passing through a point and perpendicular to the line\\n\\t @param p The point\\n\\t @brief Get a line passing through a point and perpendicular to the line\\n",
 "output": "#include<catch.hpp>\\n#include<testHelper.h>\\n\\nTEST_CASE(\"Test Normal Method with Point3\", \"[Normal]\") {\\n\\tPoint3 point;\\n\\tLineS normalLine = Normal(point);\\n\\tCHECK(normalLine == expectedNormalLine);\\n}"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "LineS& Mirror(const Frame3& frame)\\t @return The reference to self\\n\\t @param frame The mirror frame\\n\\t @brief Mirror the line by a frame\\n",
 "output": "#include<catch.hpp>\\n#include<testHelper.h>\\n\\nTEST_CASE(\"Test Mirror with Frame Method\", \"[Mirror]\") {\\n\\tFrame3 frame;\\n\\tLineS& ref = Mirror(frame);\\n\\tCHECK(ref == expectedMirrorWithFrame);\\n}"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] LineS Mirrored(const Frame3& frame)\\t @return The mirrored line\\n\\t @param frame The mirror frame\\n\\t @brief Get the line mirrored by a frame\\n",
 "output": "#include<catch.hpp>\\n#include<testHelper.h>\\n\\nTEST_CASE(\"Test Mirrored with Frame Method\", \"[Mirrored]\") {\\n\\tFrame3 frame;\\n\\tLineS mirroredLine = Mirrored(frame);\\n\\tCHECK(mirroredLine == expectedMirroredWithFrame);\\n}"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "LineS& Rotate(const Axis3& axis, double angle)\\t @return The reference to self\\n\\t @param angle The rotation angle\\n\\t @param axis The rotation axis\\n\\t @brief Rotate the line around an axis with an angle in 3D\\n",
 "output": "#include<catch.hpp>\\n#include<testHelper.h>\\n\\nTEST_CASE(\"Test Rotate with Axis Method\", \"[Rotate]\") {\\n\\tAxis3 axis;\\n\\tdouble angle;\\n\\tLineS& ref = Rotate(axis, angle);\\n\\tCHECK(ref == expectedRotatedWithAxis);\\n}"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] LineS Rotated(const Axis3& axis, double angle)\\t @return The rotated line\\n\\t @param angle The rotation angle\\n\\t @param axis The rotation axis\\n\\t @brief Get the line rotated around an axis with an angle in 3D\\n",
 "output": "#include<catch.hpp>\\n#include<testHelper.h>\\n\\nTEST_CASE(\"Test Rotated with Axis Method\", \"[Rotated]\") {\\n\\tAxis3 axis;\\n\\tdouble angle;\\n\\tLineS rotatedLine = Rotated(axis, angle);\\n\\tCHECK(rotatedLine == expectedRotatedLine);\\n}"}{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "template<int DIM2 = DIM, std::enable_if_t<DIM2 == 2, int> = 0> void Coefficients(double& a, double& b, double& c, double& d, double& e, double& f)\n[[nodiscard]] double Focal()\t @return The focal length\n\t @brief Get the focal length\n[[nodiscard]] double FocalParameter()\t @return The focal parameter\n\t          Focal parameter = 2 * focalLength.\n\t @details The focal parameter of parabola is the distance from the focus to the directrix.\n\t @brief Get the focal parameter of the parabola\n[[nodiscard]] double SemilatusRectum()\t @return The semilatus rectum\n\t          Semilatus rectum = 2 * focalLength\n\t @details The semilatus rectum of parabola is half of the length of the chord through a focus parallel to the directrix.\n\t @brief Get the semilatus rectum of the parabola\n[[nodiscard]] AxisT<double, DIM> Directrix()\t @return The directrix\n\t @brief Get the directrix\nParabolaS& Scale(const PointT<double, DIM>& point, double scale)\t @return The reference to self\n\t @param scale The scale value\n\t @param point The scaling center point\n\t @brief Scale the parabola by a center point\nParabolaS& Transform(const TransformationT<double, DIM>& tr)\t @return The reference to self\n\t @param tr The transformation\n\t @brief Transform the parabola",
 "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <geometry/Geom2Parabola.hpp>\n\nusing namespace AMCAX;\nusing namespace std;\n\nTEST_CASE(\"case1:this is a case for Test Geom2Parabola\", \"[math][Geom2Parabola][P1]\")\n\n\t//Geom2Parabola构造函数调用\n\tAxis2 axis;//默认二维坐标系中为X轴方向(1.0，0.0)\n\tdouble focal = 5.0;\n\tbool isRight = true;\n\tGeom2Parabola g2p(axis, focal, isRight);\n\n\t//FocalParameter()函数调用，获取焦点到圆锥曲线准线的距离\n\tSECTION(\"FocalParameter\")\n\t\n\t\tdouble FP = g2p.FocalParameter();\n\t\tdouble fp = 2 * focal;\n\t\tCHECK(FP == fp);\n\t\n\n\t//SemilatusRectum函数调用\n\tSECTION(\"SemilatusRectum\")\n\t\n\t\tdouble SR = g2p.SemilatusRectum();\n\t\tdouble sr = 2 * focal;\n\t\tCHECK(SR == sr);\n\t\n\n"}{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "template<int DIM2 = DIM, std::enable_if_t<DIM2 == 2, int> = 0> void Coefficients(double& a, double& b, double& c, double& d, double& e, double& f)\n[[nodiscard]] double Focal()\t @return The focal length\n\t @brief Get the focal length\n[[nodiscard]] double FocalParameter()\t @return The focal parameter\n\t          Focal parameter = 2 * focalLength.\n\t @details The focal parameter of parabola is the distance from the focus to the directrix.\n\t @brief Get the focal parameter of the parabola\n[[nodiscard]] double SemilatusRectum()\t @return The semilatus rectum\n\t          Semilatus rectum = 2 * focalLength\n\t @details The semilatus rectum of parabola is half of the length of the chord through a focus parallel to the directrix.\n\t @brief Get the semilatus rectum of the parabola\n[[nodiscard]] AxisT<double, DIM> Directrix()\t @return The directrix\n\t @brief Get the directrix\nParabolaS& Scale(const PointT<double, DIM>& point, double scale)\t @return The reference to self\n\t @param scale The scale value\n\t @param point The scaling center point\n\t @brief Scale the parabola by a center point\nParabolaS& Transform(const TransformationT<double, DIM>& tr)\t @return The reference to self\n\t @param tr The transformation\n\t @brief Transform the parabola",
 "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <geometry/Geom3Parabola.hpp>\n\nusing namespace AMCAX;\nusing namespace std;\n\nTEST_CASE(\"case1:this is a case for Test Geom3Parabola\", \"[math][Geom3Parabola][P1]\")\n\n\t//Geom3Parabola构造函数调用\n\tFrame3 frame;\n\tdouble focal = 5.0;\n\tGeom3Parabola g3p(frame, focal);\n\n\t//FocalParameter()函数调用，获取焦点到圆锥曲线准线的距离\n\tSECTION(\"FocalParameter\")\n\t\n\t\tdouble FP = g3p.FocalParameter();\n\t\tdouble fp = 2 * focal;\n\t\tCHECK(FP == fp);\n\t\n\n\t//SemilatusRectum函数调用\n\tSECTION(\"SemilatusRectum\")\n\t\n\t\tdouble SR = g3p.SemilatusRectum();\n\t\tdouble sr = 2 * focal;\n\t\tCHECK(SR == sr);\n\t\n\n\n"}{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "template<int DIM2 = DIM, std::enable_if_t<DIM2 == 2, int> = 0> void Coefficients(double& a, double& b, double& c, double& d, double& e, double& f)\n[[nodiscard]] double Focal()\t @return The focal length\n\t @brief Get the focal length\n[[nodiscard]] double FocalParameter()\t @return The focal parameter\n\t          Focal parameter = 2 * focalLength.\n\t @details The focal parameter of parabola is the distance from the focus to the directrix.\n\t @brief Get the focal parameter of the parabola\n[[nodiscard]] double SemilatusRectum()\t @return The semilatus rectum\n\t          Semilatus rectum = 2 * focalLength\n\t @details The semilatus rectum of parabola is half of the length of the chord through a focus parallel to the directrix.\n\t @brief Get the semilatus rectum of the parabola\n[[nodiscard]] AxisT<double, DIM> Directrix()\t @return The directrix\n\t @brief Get the directrix\nParabolaS& Scale(const PointT<double, DIM>& point, double scale)\t @return The reference to self\n\t @param scale The scale value\n\t @param point The scaling center point\n\t @brief Scale the parabola by a center point\nParabolaS& Transform(const TransformationT<double, DIM>& tr)\t @return The reference to self\n\t @param tr The transformation\n\t @brief Transform the parabola",
 "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <math/ParabolaT.hpp>\n\nusing namespace AMCAX;\nusing namespace std;\n\nTEST_CASE(\"case1:this is a case for Test Parabola2\", \"[math][Parabola2][P1]\")\n\n\t//Parabola2构造函数调用\n\tAxis2 axis;//默认二维坐标系中为X轴方向(1.0，0.0)\n\tdouble focal = 5.0;\n\tbool isRight = true;\n\tParabola2 parabola(axis, focal, isRight);\n\n\t//FocalParameter()函数调用，获取焦点到圆锥曲线准线的距离\n\tSECTION(\"FocalParameter\")\n\t\n\t\tdouble FP = parabola.FocalParameter();\n\t\tdouble fp = 2 * focal;\n\t\tCHECK(FP == fp);\n\t\n\n\t//SemilatusRectum函数调用\n\tSECTION(\"SemilatusRectum\")\n\t\n\t\tdouble SR = parabola.SemilatusRectum();\n\t\tdouble sr = 2 * focal;\n\t\tCHECK(SR == sr);"}{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "template<int DIM2 = DIM, std::enable_if_t<DIM2 == 2, int> = 0> void Coefficients(double& a, double& b, double& c, double& d, double& e, double& f)\n[[nodiscard]] double Focal()\t @return The focal length\n\t @brief Get the focal length\n[[nodiscard]] double FocalParameter()\t @return The focal parameter\n\t          Focal parameter = 2 * focalLength.\n\t @details The focal parameter of parabola is the distance from the focus to the directrix.\n\t @brief Get the focal parameter of the parabola\n[[nodiscard]] double SemilatusRectum()\t @return The semilatus rectum\n\t          Semilatus rectum = 2 * focalLength\n\t @details The semilatus rectum of parabola is half of the length of the chord through a focus parallel to the directrix.\n\t @brief Get the semilatus rectum of the parabola\n[[nodiscard]] AxisT<double, DIM> Directrix()\t @return The directrix\n\t @brief Get the directrix\nParabolaS& Scale(const PointT<double, DIM>& point, double scale)\t @return The reference to self\n\t @param scale The scale value\n\t @param point The scaling center point\n\t @brief Scale the parabola by a center point\nParabolaS& Transform(const TransformationT<double, DIM>& tr)\t @return The reference to self\n\t @param tr The transformation\n\t @brief Transform the parabola",
 "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <math/ParabolaT.hpp>\n\nusing namespace AMCAX;\nusing namespace std;\n\nTEST_CASE(\"case1:this is a case for Test Parabola3\", \"[math][Parabola3][P1]\")\n\n\t//Parabola3构造函数调用\n\tFrame3 frame;//默认二维坐标系中为X轴方向(1.0，0.0)\n\tdouble focal = 5.0;\n\tParabola3 parabola(frame, focal);\n\n\t//FocalParameter()函数调用，获取焦点到圆锥曲线准线的距离\n\tSECTION(\"FocalParameter\")\n\t\n\t\tdouble FP = parabola.FocalParameter();\n\t\tdouble fp = 2 * focal;\n\t\tCHECK(FP == fp);\n\t\n\n\t//SemilatusRectum函数调用\n\tSECTION(\"SemilatusRectum\")\n\t\n\t\tdouble SR = parabola.SemilatusRectum();\n\t\tdouble sr = 2 * focal;\n\t\tCHECK(SR == sr);\n\t\n\n\n"}{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] AMCAX_API double Distance(const Point3& point)\t @return The point-plane distance\n\t @param point The point\n\t @brief Compute the distance from a point to the plane\nAMCAX_API void Coefficients(double& a, double& b, double& c, double& d)\t @param[out] a,b,c,d The coefficients\n\t @brief Get coefficients of algebraic representation: ax + by + cz + d = 0\nPlane()\t Default constructor\nAMCAX_API explicit Plane(const Frame3& frame)\t @param frame The local frame\n\t @brief Construct from a local frame, XOY plane\nAMCAX_API Plane(const Point3& point, const Direction3& dir)\t @param dir The direction\n\t @param point The point\n\t @brief Construct from a point and a direction\nAMCAX_API Plane(double a, double b, double c, double d)\t @param a,b,c,d The coefficients\n\t @brief Construct from an algebraic representation: ax + by + cz + d = 0\n[[nodiscard]] AMCAX_API double Distance(const Line3& line)\t @return The line-plane distance\n\t @param line The line\n\t @brief Compute the distance from a line to the plane\n[[nodiscard]] AMCAX_API double Distance(const Plane& plane)\t @return The plane-plane distance\n\t @param plane The other plane\n\t @brief Compute the distance from another plane to the plane\n[[nodiscard]] AMCAX_API double SquaredDistance(const Point3& point)\t @return The squared point-plane distance\n\t @param point The point\n\t @brief Compute the squared distance from a point to the plane\n[[nodiscard]] AMCAX_API double SquaredDistance(const Line3& line)\t @return The squared line-plane distance\n\t @param line The line\n\t @brief Compute the squared distance from a line to the plane\n[[nodiscard]] AMCAX_API double SquaredDistance(const Plane& plane)\t @return The squared plane-plane distance\n\t @param plane The other plane\n\t @brief Compute the squared distance from another plane to the plane\n[[nodiscard]] AMCAX_API bool Contains(const Point3& point, double tol)\t @return True if the distance between the point and the plane is under the distance tolerance\n\t @param tol The distance tolerance\n\t @param point The point\n\t @brief Determines whether the plane contains a point under a tolerance or not\n[[nodiscard]] AMCAX_API bool Contains(const Line3& line, double distol, double angtol)\t @return True if the distance from the location point of the line to the plane is under the distance tolerance and the direction of the line is perpendicular to the normal direction of the plane\n\t @param angtol The angle tolerance\n\t @param distol The distance tolerance\n\t @param line The line\n\t @brief Determines whether the plane contains a line under a distance tolerance and an angle tolerance",
 "output": "#include \"catch.hpp\"\n#include <testHelper.h>\n#include <math/Plane.hpp>\n\nusing namespace AMCAX;\n\nTEST_CASE(\"case1: Plane construction and methods\", \"[math][Plane][p1]\") \n    SECTION(\"Default constructor\") \n        Plane plane;\n        //z = 0\n        double a, b, c, d;\n        plane.Coefficients(a, b, c, d);\n        REQUIRE(a == Approx(0));\n        REQUIRE(b == Approx(0));\n        REQUIRE(c == Approx(1));\n        REQUIRE(d == Approx(0));\n    \n\n    SECTION(\"Construct from frame\") \n        Frame3 frame1(Point3(0.0, 0.0, 0.0), Direction3(0.0, 0.0, 1.0));\n        Frame3 frame2(Point3(1.0, 0.0, 0.0), Direction3(2.0, 1.0, 1.0));\n        Plane plane1(frame1);\n        Plane plane2(frame2);  // 2x + y + z  -2 = 0\n        double a1, b1, c1, d1;\n        plane1.Coefficients(a1, b1, c1, d1);\n        double a2, b2, c2, d2;\n        plane2.Coefficients(a2, b2, c2, d2);\n\n        // Direction3 is (0.0, 0.0, 1.0) z = 0\n        REQUIRE(a1 == Approx(0));\n        REQUIRE(b1 == Approx(0));\n        REQUIRE(c1 == Approx(1));\n        REQUIRE(d1 == Approx(0));\n\n        REQUIRE(a2 == Approx(2. / std::sqrt(6)));\n        REQUIRE(b2 == Approx(1. / std::sqrt(6)));\n        REQUIRE(c2 == Approx(1. / std::sqrt(6)));\n        REQUIRE(d2 == Approx(-2. / std::sqrt(6)));\n\n    \n\n    SECTION(\"Construct from point and direction\") \n        Point3 point(1., 1., 1.);\n        Direction3 dir(0., 0., 1.);\n        Plane plane(point, dir);  // z = 1\n\n        Point3 point2(3., 4., 4.);\n        Direction3 dir2(2., 2., 1.);\n        Plane plane2(point2, dir2);  // 2x + 2y + z + d = 0 => d = -6-8-4 = -18 => 2x + 2y + z -18 = 0 => 2/3x + 2/3y + 1/3z - 6 = 0\n\n        double a, b, c, d;\n        plane.Coefficients(a, b, c, d);\n        double a2, b2, c2, d2;\n        plane2.Coefficients(a2, b2, c2, d2);\n\n        REQUIRE(a == Approx(0));\n        REQUIRE(b == Approx(0));\n        REQUIRE(c == Approx(1));\n        REQUIRE(d == Approx(-1));\n\n        REQUIRE(a2 == Approx(2./3).margin(0.0001));\n        REQUIRE(b2 == Approx(2./3).margin(0.0001));\n        REQUIRE(c2 == Approx(1./3).margin(0.0001));\n        REQUIRE(d2 == Approx(-6));\n    \n\n    SECTION(\"Construct from algebraic representation\") \n        Plane plane(1., 1., 1., -3.);  // Construct the plane directly using algebraic coefficients\n        double a, b, c, d;\n        plane.Coefficients(a, b, c, d);  // Here the output coefficients are normalized to turn the normal vector (a, b, c) of the plane into a unit vector\n        REQUIRE(a == Approx(1./std::sqrt(3)).margin(0.001));\n        REQUIRE(b == Approx(1. / std::sqrt(3)).margin(0.001));\n        REQUIRE(c == Approx(1. / std::sqrt(3)).margin(0.001));\n        REQUIRE(d == Approx(-3. / std::sqrt(3)).margin(0.001));\n    \n\n    SECTION(\"Distance methods\") \n\n        // Point-to-plane solving\n        std::function<double(const Plane&, const Point3&)> pointToPlane = [](const Plane& plane, const Point3& point)->double \n            double a, b, c, d;\n            plane.Coefficients(a, b, c, d);\n            return std::fabs(a * point.X() + b * point.Y() + c * point.Z() + d);\n        ;\n\n        // Line-to-plane solving\n        std::function<double(const Plane&, const Line3&)> lineToPlane = [](const Plane& plane, const Line3& line)->double \n            Point3 point = line.Location();\n            double a, b, c, d;\n            plane.Coefficients(a, b, c, d);\n            if (line.Direction().Dot(Vector3(a, b, c)) != 0)  // The dot product of the vector is not equal to 0, indicating that the line is not parallel to the plane.\n                return 0;\n            return std::fabs(a * point.X() + b * point.Y() + c * point.Z() + d);\n        ;\n\n        //  plane-to-plane Solving\n        std::function<double(const Plane&, const Plane&)> planeToPlane = [](const Plane& plane1, const Plane& plane2)->double \n            double a1, b1, c1, d1, a2, b2, c2, d2;\n            plane1.Coefficients(a1, b1, c1, d1);\n            plane2.Coefficients(a2, b2, c2, d2);\n            if (a1 != a2 || b1 != b2 || c1 != c2) return 0;\n            return std::fabs(d1 - d2);\n        ;\n\n        Plane plane(0., 0., 1., -1.); // z = 1\n        Point3 point(1., 1., 2.);\n        Line3 line(Point3(1., 1., 3.), Direction3(0., 0., 1.));\n        Plane otherPlane1(0, 0, 1, -2); // z = 2\n        Plane otherPlane2(1, 0, 1, -2); // x + z = 2  disparallel\n\n        // The distance between a point and a plane\n        REQUIRE(plane.Distance(point) == Approx(pointToPlane(plane, point)));\n        REQUIRE(plane.SquaredDistance(point) == Approx(pointToPlane(plane, point) * pointToPlane(plane, point)));\n        // The distance between a line and a plane\n        REQUIRE(plane.Distance(line) == Approx(lineToPlane(plane, line)));\n        REQUIRE(plane.SquaredDistance(line) == Approx(lineToPlane(plane, line) * lineToPlane(plane, line)));\n        // The distance between the sides\n        // parallel\n        REQUIRE(plane.Distance(otherPlane1) == Approx(planeToPlane(plane, otherPlane1)));\n        REQUIRE(plane.SquaredDistance(otherPlane1) == Approx(planeToPlane(plane, otherPlane1) * planeToPlane(plane, otherPlane1)));\n        // disparallel\n        REQUIRE(plane.Distance(otherPlane2) == Approx(planeToPlane(plane, otherPlane2)));\n        REQUIRE(plane.SquaredDistance(otherPlane2) == Approx(planeToPlane(plane, otherPlane2) * planeToPlane(plane, otherPlane2)));\n    \n\n    SECTION(\"Contains methods\") \n        // Solving for point on plane\n        std::function<bool(const Plane&, const Point3&)> pointInPlane = [(const Plane& plane, const Point3& point)->bool \n            Point3 planePoint = plane.Location();  // Return a point on the plane\n            Vector3 planeVector(planePoint, point);  // Utilize a vector formed by the plane and the target point\n            double a, b, c, d;\n            plane.Coefficients(a, b, c, d);\n            // Use the dot product with the normal vector to determine if it is zero; if it is zero, it means it is parallel and lies on the plane.\n            return planeVector.Dot(Vector3(a, b, c)) == 0;\n        ;\n\n        Plane plane(0., 0., 1., -1.); // z = 1\n        Point3 point(1., 1., 1.);\n        Point3 point2(1., 1., 2.);\n        Line3 line(Point3(1., 1., 1.), Direction3(1., 0., 0.));\n        Line3 line2(Point3(1., 1., 1.), Direction3(0., 0., 1.));  // If the point is on the plane, the direction of the line is not perpendicular to the normal vector of the plane  = Plane do not contain lines\n        Line3 line3(Point3(1., 1., 0.), Direction3(1., 0., 0.));\n\n        // Points are contained in faces\n        REQUIRE(plane.Contains(point, 1e-6) == pointInPlane(plane, point));\n        REQUIRE(plane.Contains(point2, 1e-6) == pointInPlane(plane, point2));\n        // Lines are contained in surfaces\n        REQUIRE(plane.Contains(line, 1e-6, 1e-6));\n        REQUIRE_FALSE(plane.Contains(line2, 1e-6, 1e-6 * (M_PI / 180)));\n        REQUIRE_FALSE(plane.Contains(line3, 1e-6, 1e-6 * (M_PI / 180)));\n    \n\n    SECTION(\"Reverse methods\") \n        Frame3 frame1(Point3(0.0, 0.0, 0.0), Direction3(0.0, 0.0, 1.0));  // X(1.0, 0.0, 0.0) Y(0.0, 1.0, 0.0)\n        Frame3 frame2(Point3(0.0, 0.0, 0.0), Direction3(1.0, 1.0, 1.0));\n        Plane plane1(frame1);\n        Plane plane2(frame2);\n\n        Direction3 beforeXDir1 = plane1.XAxis().Direction();\n        Direction3 beforeYDir1 = plane1.YAxis().Direction();\n        Direction3 beforeXDir2 = plane2.XAxis().Direction();\n        Direction3 beforeYDir2 = plane2.YAxis().Direction();\n        //std::cout << \"beforeXDir1: \" << beforeXDir1.X() << \", \" << beforeXDir1.Y() << \", \" << beforeXDir1.Z() << std::endl;\n        //std::cout << \"beforeYDir1: \" << beforeYDir1.X() << \", \" << beforeYDir1.Y() << \", \" << beforeYDir1.Z() << std::endl;\n        //std::cout << \"beforeXDir2: \" << beforeXDir2.X() << \", \" << beforeXDir2.Y() << \", \" << beforeXDir2.Z() << std::endl;\n        //std::cout << \"beforeYDir2: \" << beforeYDir2.X() << \", \" << beforeYDir2.Y() << \", \" << beforeYDir2.Z() << std::endl;\n\n        plane1.UReverse();\n        plane1.VReverse();\n        plane2.UReverse();\n        plane2.VReverse();\n        Direction3 afterXDir1 = plane1.XAxis().Direction();\n        Direction3 afterYDir1 = plane1.YAxis().Direction();\n        Direction3 afterXDir2 = plane2.XAxis().Direction();\n        Direction3 afterYDir2 = plane2.YAxis().Direction();\n        //std::cout << \"afterXDir1: \" << afterXDir1.X() << \", \" << afterXDir1.Y() << \", \" << afterXDir1.Z() << std::endl;\n        //std::cout << \"afterYDir1: \" << afterYDir1.X() << \", \" << afterYDir1.Y() << \", \" << afterYDir1.Z() << std::endl;\n        //std::cout << \"afterXDir2: \" << afterXDir2.X() << \", \" << afterXDir2.Y() << \", \" << afterXDir2.Z() << std::endl;\n        //std::cout << \"afterYDir2: \" << afterYDir2.X() << \", \" << afterYDir2.Y() << \", \" << afterYDir2.Z() << std::endl;\n\n        REQUIRE(beforeXDir1.IsOpposite(afterXDir1, 1e-5 * (M_PI / 180)));  // IsOpposite: Determine whether two directions are opposite within a specified angular tolerance.\n        REQUIRE(beforeYDir1.IsOpposite(afterYDir1, 1e-5 * (M_PI / 180)));\n        REQUIRE(beforeXDir2.IsOpposite(afterXDir2, 1e-5 * (M_PI / 180)));\n        REQUIRE(beforeYDir2.IsOpposite(afterYDir2, 1e-5 * (M_PI / 180)));\n    \n"}{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] AMCAX_API double Distance(const Point3& point)\t @return The point-plane distance\n\t @param point The point\n\t @brief Compute the distance from a point to the plane",
 "output": "#include<catch.hpp>\n#include<testHelper.h>\n\nTEST_CASE(\"case1: this is a test for Distance with Point3\", \"[nurbs][ModifyEndToPlane][P1]\")\n\tPoint3 testPoint(1.0, 2.0, 3.0);\n\tdouble result = Distance(testPoint);\n\tCHECK(result >= 0);"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "AMCAX_API void Coefficients(double& a, double& b, double& c, double& d)\t @param[out] a,b,c,d The coefficients\n\t @brief Get coefficients of algebraic representation: ax + by + cz + d = 0",
 "output": "#include<catch.hpp>\n#include<testHelper.h>\n\nTEST_CASE(\"case1: this is a test for Coefficients\", \"[nurbs][ModifyEndToPlane][P1]\")\n\tdouble a, b, c, d;\n\tCoefficients(a, b, c, d);\n\tCHECK(a != 0);\n\tCHECK(b != 0);\n\tCHECK(c != 0);\n\tCHECK(d != 0);"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "AMCAX_API explicit Plane(const Frame3& frame)\t @param frame The local frame\n\t @brief Construct from a local frame, XOY plane",
 "output": "#include<catch.hpp>\n#include<testHelper.h>\n\nTEST_CASE(\"case1: this is a test for Plane constructor with Frame3\", \"[nurbs][ModifyEndToPlane][P1]\")\n\tFrame3 frame;\n\tPlane myPlane(frame);\n\tCHECK(myPlane.IsValid());"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "AMCAX_API Plane(const Point3& point, const Direction3& dir)\t @param dir The direction\n\t @param point The point\n\t @brief Construct from a point and a direction",
 "output": "#include<catch.hpp>\n#include<testHelper.h>\n\nTEST_CASE(\"case1: this is a test for Plane constructor with Point3 and Direction3\", \"[nurbs][ModifyEndToPlane][P1]\")\n\tPoint3 testPoint(1.0, 2.0, 3.0);\n\tDirection3 testDir(0.0, 1.0, 0.0);\n\tPlane myPlane(testPoint, testDir);\n\tCHECK(myPlane.IsValid());"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "AMCAX_API Plane(double a, double b, double c, double d)\t @param a,b,c,d The coefficients\n\t @brief Construct from an algebraic representation: ax + by + cz + d = 0",
 "output": "#include<catch.hpp>\n#include<testHelper.h>\n\nTEST_CASE(\"case1: this is a test for Plane constructor with coefficients\", \"[nurbs][ModifyEndToPlane][P1]\")\n\tPlane myPlane(1.0, 2.0, 3.0, 4.0);\n\tCHECK(myPlane.IsValid());"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] AMCAX_API double Distance(const Line3& line)\t @return The line-plane distance\n\t @param line The line\n\t @brief Compute the distance from a line to the plane",
 "output": "#include<catch.hpp>\n#include<testHelper.h>\n\nTEST_CASE(\"case1: this is a test for Distance with Line3\", \"[nurbs][ModifyEndToPlane][P1]\")\n\tLine3 testLine;\n\tdouble result = Distance(testLine);\n\tCHECK(result >= 0);"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] AMCAX_API double Distance(const Plane& plane)\t @return The plane-plane distance\n\t @param plane The other plane\n\t @brief Compute the distance from another plane to the plane",
 "output": "#include<catch.hpp>\n#include<testHelper.h>\n\nTEST_CASE(\"case1: this is a test for Distance with Plane\", \"[nurbs][ModifyEndToPlane][P1]\")\n\tPlane otherPlane;\n\tdouble result = Distance(otherPlane);\n\tCHECK(result >= 0);"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] AMCAX_API double SquaredDistance(const Point3& point)\t @return The squared point-plane distance\n\t @param point The point\n\t @brief Compute the squared distance from a point to the plane",
 "output": "#include<catch.hpp>\n#include<testHelper.h>\n\nTEST_CASE(\"case1: this is a test for SquaredDistance with Point3\", \"[nurbs][ModifyEndToPlane][P1]\")\n\tPoint3 testPoint(1.0, 2.0, 3.0);\n\tdouble result = SquaredDistance(testPoint);\n\tCHECK(result >= 0);"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] AMCAX_API double SquaredDistance(const Line3& line)\t @return The squared line-plane distance\n\t @param line The line\n\t @brief Compute the squared distance from a line to the plane",
 "output": "#include<catch.hpp>\n#include<testHelper.h>\n\nTEST_CASE(\"case1: this is a test for SquaredDistance with Line3\", \"[nurbs][ModifyEndToPlane][P1]\")\n\tLine3 testLine;\n\tdouble result = SquaredDistance(testLine);\n\tCHECK(result >= 0);"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] AMCAX_API double SquaredDistance(const Plane& plane)\t @return The squared plane-plane distance\n\t @param plane The other plane\n\t @brief Compute the squared distance from another plane to the plane",
 "output": "#include<catch.hpp>\n#include<testHelper.h>\n\nTEST_CASE(\"case1: this is a test for SquaredDistance with Plane\", \"[nurbs][ModifyEndToPlane][P1]\")\n\tPlane otherPlane;\n\tdouble result = SquaredDistance(otherPlane);\n\tCHECK(result >= 0);"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] AMCAX_API bool Contains(const Point3& point, double tol)\t @return True if the distance between the point and the plane is under the distance tolerance\n\t @param tol The distance tolerance\n\t @param point The point\n\t @brief Determines whether the plane contains a point under a tolerance or not",
 "output": "#include<catch.hpp>\n#include<testHelper.h>\n\nTEST_CASE(\"case1: this is a test for Contains with Point3\", \"[nurbs][ModifyEndToPlane][P1]\")\n\tPoint3 testPoint(1.0, 2.0, 3.0);\n\tdouble tolerance = 0.1;\n\tbool result = Contains(testPoint, tolerance);\n\tCHECK(result == true || result == false);"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] AMCAX_API bool Contains(const Line3& line, double distol, double angtol)\t @return True if the distance from the location point of the line to the plane is under the distance tolerance and the direction of the line is perpendicular to the normal direction of the plane\n\t @param angtol The angle tolerance\n\t @param distol The distance tolerance\n\t @param line The line\n\t @brief Determines whether the plane contains a line under a distance tolerance and an angle tolerance",
 "output": "#include<catch.hpp>\n#include<testHelper.h>\n\nTEST_CASE(\"case1: this is a test for Contains with Line3\", \"[nurbs][ModifyEndToPlane][P1]\")\n\tLine3 testLine;\n\tdouble distanceTolerance = 0.1;\n\tdouble angleTolerance = 0.1;\n\tbool result = Contains(testLine, distanceTolerance, angleTolerance);\n\tCHECK(result == true || result == false);"}{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] AMCAX_API double Radius()\t @return The radius\n\t @brief Get the radius\nAMCAX_API void SetRadius(double r)\t @param r The radius\n\t @brief Set the radius\nAMCAX_API void Coefficients(double& a1, double& a2, double& a3, double& b1, double& b2, double& b3, double& c1, double& c2, double& c3, double& d)\t @param[out] a1,a2,a3,b1,b2,b3,c1,c2,c3,d The coefficients\n\t @details The algebraic representation of the sphere is a_1 x^2 + a_2 y^2 + a_3 z^2 + 2 (b_1 xy + b_2 xz + b_3 yz) + 2 (c_1 x + c_2 y + c_3 z) + d = 0\n\t @brief Get the coefficients of the algebraic representation of the sphere\nAMCAX_API Sphere& Scale(const Point3& point, double scale)\t @return The reference to self\n\t @param scale The scale value\n\t @param point The scaling center point\n\t @brief Scale the sphere by a point\nAMCAX_API Sphere& Transform(const Transformation3& tr)\t @return The reference to self\n\t @param tr The transformation\n\t @brief Transform the sphere",
 "output": "#include<catch.hpp>\n#include<testHelperBase.h>\n#include <polymeshAPI/MeshMakeSphere.hpp>\n#include <polymesh/PolyMeshIO.hpp>\n#include <polymeshAPI/MeshSubdivideHE.hpp>\nusing namespace AMCAX;\n\nTEST_CASE(\"case1: MeshMakeSphere  \", \"[polymeshAPI][SubD][MeshMakeSphere][P1]\") \n\tdouble r = 2.1;\n\tAMCAX::SubD::MeshMakeSphere sphere(r);\n\tAMCAX::SubD::PolyMesh* mesh = sphere.BuildMesh();\n\tCHECK(mesh != nullptr);\n\tAMCAX::SubD::MeshSubdivideHE::CatmullClark(mesh, 3);\n\tbool result = AMCAX::SubD::PolyMeshIO::WriteMesh(OUTPUT_PATH_PREFIX\"MeshMakeSphere_case01.obj\", mesh);\n\tCHECK(result == true);\n"}{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] AMCAX_API double MajorRadius()\t @return The major radius\n\t @brief Get the major radius",
 "output": "#include<catch.hpp>\n#include<testHelper.h>\n\n#include <modeling/MakeTorus.hpp>\n#include <common/CartesianCoordinateSystem.hpp>\n#include <topology/TopoBuilder.hpp>\n\nTEST_CASE(\"bug1: MakeTorus  https://qa.amcax.net/bug-view-445.html \", \"[modeling][MakeTorus][P1][fixbug]\")\n\n\t// Test for MajorRadius\n"},
根据您提供的方法声明和测试程序进行对比：

方法声明：
```cpp
AMCAX_API BoolBRepCut() @details Only set the type of boolean operation to cut
 @brief Default constructor
```

测试程序：
```cpp
#include<catch.hpp>
#include<testHelper.h>

#include <boolean/BoolBRepCut.hpp>
#include <modeling/MakeTorus.hpp>
#include <modeling/MakeSphere.hpp>
#include <modeling/MakeCone.hpp>
#include <topology/TopoExplorer.hpp>
#include <topology/TopoFace.hpp>
#include <hatch/BRepClassificationTools.hpp>

using namespace AMCAX;
```

### 对比结果：
1. 方法声明是一个默认构造函数，没有参数。
2. 测试程序中包含了多个头文件，但没有调用构造函数 `BoolBRepCut()`，仅仅是包含了其声明。

因此，测试程序并未测试方法声明中的构造函数。

### 输出：
```
00000
``````根据您提供的方法声明和测试程序进行对比：

方法声明：
```cpp
AMCAX_API BoolBRepCut() @details Only set the type of boolean operation to cut
@brief Default constructor
```

测试程序：
```cpp
TEST_CASE("bug1: in Debug mode: BoolBuilder  ", "boolean][BoolBRepCut][P1][fixbug") {
    TopoShape torus = MakeTorus(Frame3(Point3(0.0, 0.0, 2.0), Direction3(1.0, 0.0, 0.0)), 4.0, 2.0);
    TopoShape sphere = MakeSphere(4.0);
    TopoShape result = BoolBRepCut(sphere, torus);
    
    AMCAX::GlobalProperty prop;
    AMCAX::BRepGlobalProperty::VolumeProperties(result, prop);
    CHECK(prop.Mass() == Approx(153.229)); 
    
    bool isWriteSuccess = AMCAX::OCCTIO::OCCTTool::Write(result, OUTPUT_PATH_PREFIX"BoolBRepCut_bug72.brep", false);
    CHECK(isWriteSuccess == true);
}
```

对比结果：
- 方法声明中的 `BoolBRepCut()` 是一个构造函数，没有参数。
- 测试程序中调用了 `BoolBRepCut(sphere, torus)`，这是一个带有参数的函数调用。

因此，测试程序不是该方法声明的测试程序。

输出应为：“00000”。```00000```11111```00000```11111```00000```11111```00000```00000```00000```00000```00000```00000```00000```11111```00000```11111```00000```11111```00000```11111```00000```11111```00000```11111```00000```11111```00000```11111```00000```11111```00000```00000```00000```00000```00000```00000```