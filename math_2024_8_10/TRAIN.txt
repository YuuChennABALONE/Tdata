{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] AMCAX_API static Point3 D0(double u, const Line3& line)	 @return The resulting point
	 @param line The line
	 @param u The parameter
	 @brief Compute the point on a 3D line at a parameter
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
#include <occtio/OCCTTool.hpp>
#include <geometry/MakeArcOfHyperbola2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeEdge2d.hpp>
using namespace AMCAX;
TEST_CASE("case1: CurveCalculation::D0() [6/10] ", "[math][CurveCalculation][P1][D0]") {
	Frame3 fram3;
	double major_radius = 1000.0;
	double minor_radius = 10.0;
	Hyperbola3 hyperbola(fram3, major_radius, minor_radius);
	Point3 point3 = CurveCalculation::D0(0.0, hyperbola);
	CHECK(point3.X() == 1000.0);
	CHECK(point3.Y() == 0.0);
	CHECK(point3.Z() == 0.0);
}
}
,
{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static void CircleD3(double u, const Frame3& pos, double radius, Point3& p, Vector3& v1, Vector3& v2, Vector3& v3)	 @param[out] v3 The third derivative
	 @param[out] v2 The second derivative
	 @param[out] v1 The first derivative
	 @param[out] p The point
	 @param[in] radius The radius
	 @param[in] pos The local frame where the circle lies
	 @param[in] u The parameter
	 @brief Compute the point and the first three derivatives on a 3D circle represented by a local frame and a radius at a parameter
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
using namespace AMCAX;
TEST_CASE("case1: CurveCalculation::CircleD3 3/4 ", "[math][CurveCalculation][P1][CircleD3]") {
	Direction3 initialDir(0.0, 0.0, 1.0); 
	Frame3 defaultFrame3(Point3(1.0, 1.0, 0.0), initialDir); 
	double radius = 2.0; 
	Vector3 tangentAt0 = AMCAX::CurveCalculation::CircleD3(0.0, defaultFrame3, radius);
	Vector3 tangentAt90Deg = AMCAX::CurveCalculation::CircleD3(M_PI_2, defaultFrame3, radius);
	Vector3 tangentAt180Deg = AMCAX::CurveCalculation::CircleD3(M_PI, defaultFrame3, radius);
	Vector3 tangentAt270Deg = AMCAX::CurveCalculation::CircleD3(3 * M_PI_2, defaultFrame3, radius);
	Vector3 tangentAt360Deg = AMCAX::CurveCalculation::CircleD3(2 * M_PI, defaultFrame3, radius);
	CHECK(tangentAt0.X() == Approx(0.0));
	CHECK(tangentAt0.Y() == Approx(-2.0));
	CHECK(tangentAt0.Z() == Approx(-0.0));
	CHECK(tangentAt90Deg.X() == Approx(2.0).margin(1e-14));
	CHECK(tangentAt90Deg.Y() == Approx(-0.0).margin(1e-14));
	CHECK(tangentAt90Deg.Z() == Approx(0.0).margin(1e-14));
	CHECK(tangentAt180Deg.X() == Approx(0.0).margin(1e-14));
	CHECK(tangentAt180Deg.Y() == Approx(2.0).margin(1e-14));
	CHECK(tangentAt180Deg.Z() == Approx(0.0));
	CHECK(tangentAt270Deg.X() == Approx(-2.0).margin(1e-14));
	CHECK(tangentAt270Deg.Y() == Approx(0.0).margin(1e-14));
	CHECK(tangentAt270Deg.Z() == Approx(0.0).margin(1e-14));
	CHECK(tangentAt360Deg.X() == Approx(-0.0).margin(1e-14));
	CHECK(tangentAt360Deg.Y() == Approx(-2.0).margin(1e-14));
	CHECK(tangentAt360Deg.Z() == Approx(0.0).margin(1e-14));
	std::cout << "Tangent at 0 deg: " << tangentAt0 << std::endl;
	std::cout << "Tangent at 90 deg: " << tangentAt90Deg << std::endl;
	std::cout << "Tangent at 180 deg: " << tangentAt180Deg << std::endl;
	std::cout << "Tangent at 270 deg: " << tangentAt270Deg << std::endl;
	std::cout << "Tangent at 360 deg: " << tangentAt360Deg << std::endl;
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] AMCAX_API static Vector2 CircleD3(double u, const Frame2& pos, double radius)	 @return The third derivative vector
	 @param radius The radius
	 @param pos The local frame where the circle lies
	 @param u The parameter
	 @brief Compute the third derivative on a 2D circle represented by a local frame and a radius at a parameter
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
using namespace AMCAX;
TEST_CASE("case1: CurveCalculation::CircleD3 1/4 ", "[math][CurveCalculation][P1][CircleD3]") {
	Direction2 defaultDir2(1.0, 0.0);
	Frame2 defaultFrame2(Point2(1.0, 1.0), defaultDir2);
	double radius = 2.0;
	Vector2 tangentAt0 = AMCAX::CurveCalculation::CircleD3(0.0, defaultFrame2, radius);
	Vector2 tangentAt180 = AMCAX::CurveCalculation::CircleD3(M_PI, defaultFrame2, radius);
	Vector2 tangentAt360 = AMCAX::CurveCalculation::CircleD3(2 * M_PI, defaultFrame2, radius);
	CHECK(tangentAt0.X() == 0.0);
	CHECK(tangentAt0.Y() == -2.0);
	CHECK(tangentAt180.X() == Approx(0.0).margin(1e-14));
	CHECK(tangentAt180.Y() == 2.0 );
	CHECK(tangentAt360.X() == Approx(0.0).margin(1e-14));
	CHECK(tangentAt360.Y() == -2.0 );
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static void CircleD3(double u, const Frame2& pos, double radius, Point2& p, Vector2& v1, Vector2& v2, Vector2& v3)	 @param[out] v3 The third derivative
	 @param[out] v2 The second derivative
	 @param[out] v1 The first derivative
	 @param[out] p The point
	 @param[in] radius The radius
	 @param[in] pos The local frame where the circle lies
	 @param[in] u The parameter
	 @brief Compute the point and the first three derivatives on a 2D circle represented by a local frame and a radius at a parameter
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
using namespace AMCAX;
TEST_CASE("case1: CurveCalculation::CircleD3 1/4 ", "[math][CurveCalculation][P1][CircleD3]") {
	Direction2 defaultDir2(1.0, 0.0);
	Frame2 defaultFrame2(Point2(1.0, 1.0), defaultDir2);
	double radius = 2.0;
	Vector2 tangentAt0 = AMCAX::CurveCalculation::CircleD3(0.0, defaultFrame2, radius);
	Vector2 tangentAt180 = AMCAX::CurveCalculation::CircleD3(M_PI, defaultFrame2, radius);
	Vector2 tangentAt360 = AMCAX::CurveCalculation::CircleD3(2 * M_PI, defaultFrame2, radius);
	CHECK(tangentAt0.X() == 0.0);
	CHECK(tangentAt0.Y() == -2.0);
	CHECK(tangentAt180.X() == Approx(0.0).margin(1e-14));
	CHECK(tangentAt180.Y() == 2.0 );
	CHECK(tangentAt360.X() == Approx(0.0).margin(1e-14));
	CHECK(tangentAt360.Y() == -2.0 );
}
}
,
{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] AMCAX_API static Vector2 CircleD2(double u, const Frame2& pos, double radius)	 @return The second derivative vector
	 @param radius The radius
	 @param pos The local frame where the circle lies
	 @param u The parameter
	 @brief Compute the second derivative on a 2D circle represented by a local frame and a radius at a parameter
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
using namespace AMCAX;
TEST_CASE("case1: CurveCalculation::CircleD2 1/4 ", "[math][CurveCalculation][P1][CircleD2]") {
	Direction2 defaultDirection(1.0, 0.0); 
	Frame2 defaultFrame2(Point2(0.0, 0.0), defaultDirection);
	double 	r = 2.0;
	double u = 0.0; 
	Vector2  vector2 = CurveCalculation::CircleD2(u, defaultFrame2, r); 
	std::cout << vector2.X() << " " << vector2.Y() << " " << std::endl;
	CHECK(vector2.X() == -2.0);
	CHECK(vector2.Y() == Approx(0.0).margin(1e-14));
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static void CircleD2(double u, const Frame2& pos, double radius, Point2& p, Vector2& v1, Vector2& v2)	 @param[out] v2 The second derivative
	 @param[out] v1 The first derivative
	 @param[out] p The point
	 @param[in] radius The radius
	 @param[in] pos The local frame where the circle lies
	 @param[in] u The parameter
	 @brief Compute the point and the first two derivatives on a 2D circle represented by a local frame and a radius at a parameter
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
using namespace AMCAX;
TEST_CASE("case1: CurveCalculation::CircleD2 1/4 ", "[math][CurveCalculation][P1][CircleD2]") {
	Direction2 defaultDirection(1.0, 0.0); 
	Frame2 defaultFrame2(Point2(0.0, 0.0), defaultDirection);
	double 	r = 2.0;
	double u = 0.0; 
	Vector2  vector2 = CurveCalculation::CircleD2(u, defaultFrame2, r); 
	std::cout << vector2.X() << " " << vector2.Y() << " " << std::endl;
	CHECK(vector2.X() == -2.0);
	CHECK(vector2.Y() == Approx(0.0).margin(1e-14));
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] AMCAX_API static Vector3 CircleD3(double u, const Frame3& pos, double radius)	 @return The third derivative vector
	 @param radius The radius
	 @param pos The local frame where the circle lies
	 @param u The parameter
	 @brief Compute the third derivative on a 3D circle represented by a local frame and a radius at a parameter
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
using namespace AMCAX;
TEST_CASE("case1: CurveCalculation::CircleD3 3/4 ", "[math][CurveCalculation][P1][CircleD3]") {
	Direction3 initialDir(0.0, 0.0, 1.0); 
	Frame3 defaultFrame3(Point3(1.0, 1.0, 0.0), initialDir); 
	double radius = 2.0; 
	Vector3 tangentAt0 = AMCAX::CurveCalculation::CircleD3(0.0, defaultFrame3, radius);
	Vector3 tangentAt90Deg = AMCAX::CurveCalculation::CircleD3(M_PI_2, defaultFrame3, radius);
	Vector3 tangentAt180Deg = AMCAX::CurveCalculation::CircleD3(M_PI, defaultFrame3, radius);
	Vector3 tangentAt270Deg = AMCAX::CurveCalculation::CircleD3(3 * M_PI_2, defaultFrame3, radius);
	Vector3 tangentAt360Deg = AMCAX::CurveCalculation::CircleD3(2 * M_PI, defaultFrame3, radius);
	CHECK(tangentAt0.X() == Approx(0.0));
	CHECK(tangentAt0.Y() == Approx(-2.0));
	CHECK(tangentAt0.Z() == Approx(-0.0));
	CHECK(tangentAt90Deg.X() == Approx(2.0).margin(1e-14));
	CHECK(tangentAt90Deg.Y() == Approx(-0.0).margin(1e-14));
	CHECK(tangentAt90Deg.Z() == Approx(0.0).margin(1e-14));
	CHECK(tangentAt180Deg.X() == Approx(0.0).margin(1e-14));
	CHECK(tangentAt180Deg.Y() == Approx(2.0).margin(1e-14));
	CHECK(tangentAt180Deg.Z() == Approx(0.0));
	CHECK(tangentAt270Deg.X() == Approx(-2.0).margin(1e-14));
	CHECK(tangentAt270Deg.Y() == Approx(0.0).margin(1e-14));
	CHECK(tangentAt270Deg.Z() == Approx(0.0).margin(1e-14));
	CHECK(tangentAt360Deg.X() == Approx(-0.0).margin(1e-14));
	CHECK(tangentAt360Deg.Y() == Approx(-2.0).margin(1e-14));
	CHECK(tangentAt360Deg.Z() == Approx(0.0).margin(1e-14));
	std::cout << "Tangent at 0 deg: " << tangentAt0 << std::endl;
	std::cout << "Tangent at 90 deg: " << tangentAt90Deg << std::endl;
	std::cout << "Tangent at 180 deg: " << tangentAt180Deg << std::endl;
	std::cout << "Tangent at 270 deg: " << tangentAt270Deg << std::endl;
	std::cout << "Tangent at 360 deg: " << tangentAt360Deg << std::endl;
}
}
,
{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static void CircleD1(double u, const Frame2& pos, double radius, Point2& p, Vector2& v1)	 @param[out] v1 The first derivative
	 @param[out] p The point
	 @param[in] radius The radius
	 @param[in] pos The local frame where the circle lies
	 @param[in] u The parameter
	 @brief Compute the point and the first derivative on a 2D circle represented by a local frame and a radius at a parameter
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
using namespace AMCAX;
TEST_CASE("case1: CurveCalculation::CircleD1 1/4 ", "[math][CurveCalculation][P1][CircleD1]") {
	Direction2 initialDir(1.0, 0.0); 
	Frame2 defaultFrame2(Point2(1.0, 1.0), initialDir); 
	double radius = 2.0; 
	Vector2 tangentAt0 = AMCAX::CurveCalculation::CircleD1(0.0, defaultFrame2, radius);
	Vector2 tangentAt90Deg = AMCAX::CurveCalculation::CircleD1(M_PI_2, defaultFrame2, radius);
	Vector2 tangentAt180Deg = AMCAX::CurveCalculation::CircleD1(M_PI, defaultFrame2, radius);
	Vector2 tangentAt270Deg = AMCAX::CurveCalculation::CircleD1(3 * M_PI_2, defaultFrame2, radius);
	Vector2 tangentAt360Deg = AMCAX::CurveCalculation::CircleD1(2 * M_PI, defaultFrame2, radius);
	CHECK(tangentAt0.X() == Approx(-0.0));
	CHECK(tangentAt0.Y() == Approx(2.0));
	CHECK(tangentAt90Deg.X() == Approx(-2.0));
	CHECK(tangentAt90Deg.Y() == Approx(0.0).margin(1e-14));
	CHECK(tangentAt180Deg.X() == Approx(-0.0).margin(1e-14));
	CHECK(tangentAt180Deg.Y() == Approx(-2.0));
	CHECK(tangentAt270Deg.X() == Approx(2.0));
	CHECK(tangentAt270Deg.Y() == Approx(-0.0).margin(1e-14));
	CHECK(tangentAt360Deg.X() == Approx(0.0).margin(1e-14));
	CHECK(tangentAt360Deg.Y() == Approx(2.0));
	std::cout << "Tangent at 0 deg: " << tangentAt0 << std::endl;
	std::cout << "Tangent at 90 deg: " << tangentAt90Deg << std::endl;
	std::cout << "Tangent at 180 deg: " << tangentAt180Deg << std::endl;
	std::cout << "Tangent at 270 deg: " << tangentAt270Deg << std::endl;
	std::cout << "Tangent at 360 deg: " << tangentAt360Deg << std::endl;
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] AMCAX_API static Vector3 CircleD2(double u, const Frame3& pos, double radius)	 @return The second derivative vector
	 @param radius The radius
	 @param pos The local frame where the circle lies
	 @param u The parameter
	 @brief Compute the second derivative on a 3D circle represented by a local frame and a radius at a parameter
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
using namespace AMCAX;
TEST_CASE("case1: CurveCalculation::CircleD2 3/4 ", "[math][CurveCalculation][P1][CircleD2]") {
	Direction3 initialDir(0.0, 0.0, 1.0); 
	Frame3 defaultFrame3(Point3(1.0, 1.0, 0.0), initialDir); 
	double radius = 2.0; 
	Vector3 tangentAt0 = AMCAX::CurveCalculation::CircleD2(0.0, defaultFrame3, radius);
	Vector3 tangentAt90Deg = AMCAX::CurveCalculation::CircleD2(M_PI_2, defaultFrame3, radius);
	Vector3 tangentAt180Deg = AMCAX::CurveCalculation::CircleD2(M_PI, defaultFrame3, radius);
	Vector3 tangentAt270Deg = AMCAX::CurveCalculation::CircleD2(3 * M_PI_2, defaultFrame3, radius);
	Vector3 tangentAt360Deg = AMCAX::CurveCalculation::CircleD2(2 * M_PI, defaultFrame3, radius);
	CHECK(tangentAt0.X() == Approx(-2.0));
	CHECK(tangentAt0.Y() == Approx(-0.0));
	CHECK(tangentAt0.Z() == Approx(0.0));
	CHECK(tangentAt90Deg.X() == Approx(-0.0).margin(1e-14));
	CHECK(tangentAt90Deg.Y() == Approx(-2.0).margin(1e-14));
	CHECK(tangentAt90Deg.Z() == Approx(0.0).margin(1e-14));
	CHECK(tangentAt180Deg.X() == Approx(2.0).margin(1e-14));
	CHECK(tangentAt180Deg.Y() == Approx(-0.0).margin(1e-14));
	CHECK(tangentAt180Deg.Z() == Approx(-0.0));
	CHECK(tangentAt270Deg.X() == Approx(0.0).margin(1e-14));
	CHECK(tangentAt270Deg.Y() == Approx(2.0).margin(1e-14));
	CHECK(tangentAt270Deg.Z() == Approx(0.0).margin(1e-14));
	CHECK(tangentAt360Deg.X() == Approx(-2.0).margin(1e-14));
	CHECK(tangentAt360Deg.Y() == Approx(0.0).margin(1e-14));
	CHECK(tangentAt360Deg.Z() == Approx(0.0).margin(1e-14));
	std::cout << "Tangent at 0 deg: " << tangentAt0 << std::endl;
	std::cout << "Tangent at 90 deg: " << tangentAt90Deg << std::endl;
	std::cout << "Tangent at 180 deg: " << tangentAt180Deg << std::endl;
	std::cout << "Tangent at 270 deg: " << tangentAt270Deg << std::endl;
	std::cout << "Tangent at 360 deg: " << tangentAt360Deg << std::endl;
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static void CircleD2(double u, const Frame3& pos, double radius, Point3& p, Vector3& v1, Vector3& v2)	 @param[out] v2 The second derivative
	 @param[out] v1 The first derivative
	 @param[out] p The point
	 @param[in] radius The radius
	 @param[in] pos The local frame where the circle lies
	 @param[in] u The parameter
	 @brief Compute the point and the first two derivatives on a 3D circle represented by a local frame and a radius at a parameter
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
using namespace AMCAX;
TEST_CASE("case1: CurveCalculation::CircleD2 3/4 ", "[math][CurveCalculation][P1][CircleD2]") {
	Direction3 initialDir(0.0, 0.0, 1.0); 
	Frame3 defaultFrame3(Point3(1.0, 1.0, 0.0), initialDir); 
	double radius = 2.0; 
	Vector3 tangentAt0 = AMCAX::CurveCalculation::CircleD2(0.0, defaultFrame3, radius);
	Vector3 tangentAt90Deg = AMCAX::CurveCalculation::CircleD2(M_PI_2, defaultFrame3, radius);
	Vector3 tangentAt180Deg = AMCAX::CurveCalculation::CircleD2(M_PI, defaultFrame3, radius);
	Vector3 tangentAt270Deg = AMCAX::CurveCalculation::CircleD2(3 * M_PI_2, defaultFrame3, radius);
	Vector3 tangentAt360Deg = AMCAX::CurveCalculation::CircleD2(2 * M_PI, defaultFrame3, radius);
	CHECK(tangentAt0.X() == Approx(-2.0));
	CHECK(tangentAt0.Y() == Approx(-0.0));
	CHECK(tangentAt0.Z() == Approx(0.0));
	CHECK(tangentAt90Deg.X() == Approx(-0.0).margin(1e-14));
	CHECK(tangentAt90Deg.Y() == Approx(-2.0).margin(1e-14));
	CHECK(tangentAt90Deg.Z() == Approx(0.0).margin(1e-14));
	CHECK(tangentAt180Deg.X() == Approx(2.0).margin(1e-14));
	CHECK(tangentAt180Deg.Y() == Approx(-0.0).margin(1e-14));
	CHECK(tangentAt180Deg.Z() == Approx(-0.0));
	CHECK(tangentAt270Deg.X() == Approx(0.0).margin(1e-14));
	CHECK(tangentAt270Deg.Y() == Approx(2.0).margin(1e-14));
	CHECK(tangentAt270Deg.Z() == Approx(0.0).margin(1e-14));
	CHECK(tangentAt360Deg.X() == Approx(-2.0).margin(1e-14));
	CHECK(tangentAt360Deg.Y() == Approx(0.0).margin(1e-14));
	CHECK(tangentAt360Deg.Z() == Approx(0.0).margin(1e-14));
	std::cout << "Tangent at 0 deg: " << tangentAt0 << std::endl;
	std::cout << "Tangent at 90 deg: " << tangentAt90Deg << std::endl;
	std::cout << "Tangent at 180 deg: " << tangentAt180Deg << std::endl;
	std::cout << "Tangent at 270 deg: " << tangentAt270Deg << std::endl;
	std::cout << "Tangent at 360 deg: " << tangentAt360Deg << std::endl;
}
}
,
{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] AMCAX_API static Vector3 CircleD1(double u, const Frame3& pos, double radius)	 @return The first derivative vector
	 @param radius The radius
	 @param pos The local frame where the circle lies
	 @param u The parameter
	 @brief Compute the first derivative on a 3D circle represented by a local frame and a radius at a parameter
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
using namespace AMCAX;
TEST_CASE("case1: CurveCalculation::CircleD1 3/4 ", "[math][CurveCalculation][P1][CircleD1]") {
	Direction3 initialDir(0.0, 0.0,1.0); 
	Frame3 defaultFrame3(Point3(1.0, 0.0,0.0), initialDir); 
	double radius = 2.0; 
	Vector3 tangentAt0 = AMCAX::CurveCalculation::CircleD1(0.0, defaultFrame3, radius);
	Vector3 tangentAt90Deg = AMCAX::CurveCalculation::CircleD1(M_PI_2, defaultFrame3, radius);
	Vector3 tangentAt180Deg = AMCAX::CurveCalculation::CircleD1(M_PI, defaultFrame3, radius);
	Vector3 tangentAt270Deg = AMCAX::CurveCalculation::CircleD1(3 * M_PI_2, defaultFrame3, radius);
	Vector3 tangentAt360Deg = AMCAX::CurveCalculation::CircleD1(2 * M_PI, defaultFrame3, radius);
	CHECK(tangentAt0.X() == Approx(0.0));
	CHECK(tangentAt0.Y() == Approx(2.0));
	CHECK(tangentAt90Deg.X() == Approx(-2.0));
	CHECK(tangentAt90Deg.Y() == Approx(0.0).margin(1e-14));
	CHECK(tangentAt180Deg.X() == Approx(0.0).margin(1e-14));
	CHECK(tangentAt180Deg.Y() == Approx(-2.0));
	CHECK(tangentAt270Deg.X() == Approx(2.0));
	CHECK(tangentAt270Deg.Y() == Approx(-0.0).margin(1e-14));
	CHECK(tangentAt360Deg.X() == Approx(0.0).margin(1e-14));
	CHECK(tangentAt360Deg.Y() == Approx(2.0));
	std::cout << "Tangent at 0 deg: " << tangentAt0 << std::endl;
	std::cout << "Tangent at 90 deg: " << tangentAt90Deg << std::endl;
	std::cout << "Tangent at 180 deg: " << tangentAt180Deg << std::endl;
	std::cout << "Tangent at 270 deg: " << tangentAt270Deg << std::endl;
	std::cout << "Tangent at 360 deg: " << tangentAt360Deg << std::endl;
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static void CircleD1(double u, const Frame3& pos, double radius, Point3& p, Vector3& v1)	 @param[out] v1 The first derivative
	 @param[out] p The point
	 @param[in] radius The radius
	 @param[in] pos The local frame where the circle lies
	 @param[in] u The parameter
	 @brief Compute the point and the first derivative on a 3D circle represented by a local frame and a radius at a parameter
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
using namespace AMCAX;
TEST_CASE("case1: CurveCalculation::CircleD1 4/4 ", "[math][CurveCalculation][P1][CircleD1]") {
	Direction3 initialDir(0.0, 0.0,1.0);
	Frame3 defaultFrame3(Point3(1.0, 1.0,0.0), initialDir);
	double radius = 2.0;
	Point3 p;
	Vector3 v;
	SECTION("0 deg case") {
		AMCAX::CurveCalculation::CircleD1(0.0, defaultFrame3, radius, p, v);
		CHECK(p.X() == 3.0);
		CHECK(p.Y() == 1.0);
		CHECK(p.Z() == 0.0);
		CHECK(v.X() == Approx(0.0));
		CHECK(v.Y() == Approx(2.0));
		CHECK(v.Z() == Approx(0.0));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] AMCAX_API static Vector2 CircleD1(double u, const Frame2& pos, double radius)	 @return The first derivative vector
	 @param radius The radius
	 @param pos The local frame where the circle lies
	 @param u The parameter
	 @brief Compute the first derivative on a 2D circle represented by a local frame and a radius at a parameter
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
using namespace AMCAX;
TEST_CASE("case1: CurveCalculation::CircleD1 1/4 ", "[math][CurveCalculation][P1][CircleD1]") {
	Direction2 initialDir(1.0, 0.0); 
	Frame2 defaultFrame2(Point2(1.0, 1.0), initialDir); 
	double radius = 2.0; 
	Vector2 tangentAt0 = AMCAX::CurveCalculation::CircleD1(0.0, defaultFrame2, radius);
	Vector2 tangentAt90Deg = AMCAX::CurveCalculation::CircleD1(M_PI_2, defaultFrame2, radius);
	Vector2 tangentAt180Deg = AMCAX::CurveCalculation::CircleD1(M_PI, defaultFrame2, radius);
	Vector2 tangentAt270Deg = AMCAX::CurveCalculation::CircleD1(3 * M_PI_2, defaultFrame2, radius);
	Vector2 tangentAt360Deg = AMCAX::CurveCalculation::CircleD1(2 * M_PI, defaultFrame2, radius);
	CHECK(tangentAt0.X() == Approx(-0.0));
	CHECK(tangentAt0.Y() == Approx(2.0));
	CHECK(tangentAt90Deg.X() == Approx(-2.0));
	CHECK(tangentAt90Deg.Y() == Approx(0.0).margin(1e-14));
	CHECK(tangentAt180Deg.X() == Approx(-0.0).margin(1e-14));
	CHECK(tangentAt180Deg.Y() == Approx(-2.0));
	CHECK(tangentAt270Deg.X() == Approx(2.0));
	CHECK(tangentAt270Deg.Y() == Approx(-0.0).margin(1e-14));
	CHECK(tangentAt360Deg.X() == Approx(0.0).margin(1e-14));
	CHECK(tangentAt360Deg.Y() == Approx(2.0));
	std::cout << "Tangent at 0 deg: " << tangentAt0 << std::endl;
	std::cout << "Tangent at 90 deg: " << tangentAt90Deg << std::endl;
	std::cout << "Tangent at 180 deg: " << tangentAt180Deg << std::endl;
	std::cout << "Tangent at 270 deg: " << tangentAt270Deg << std::endl;
	std::cout << "Tangent at 360 deg: " << tangentAt360Deg << std::endl;
}
}
,
{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] AMCAX_API static Point2 CircleValue(double u, const Frame2& pos, double radius)	 @return The point
	 @param radius The radius
	 @param pos The local frame where the circle lies
	 @param u The parameter
	 @brief Compute the point on a 2D circle represented by a local frame and a radius at a parameter
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
using namespace AMCAX;
TEST_CASE("case1: CurveCalculation::CircleValue()[1 / 2] ", "[math][CurveCalculation][P1][CircleValue]") {
	Direction2 defaultDirection(1.0, 0.0); 
	Frame2 defaultFrame2(Point2(1.0, 1.0), defaultDirection);
	Point2 point2 = AMCAX::CurveCalculation::CircleValue(0.0, defaultFrame2, 3.0);
	CHECK(point2.X() == 4.0);
	CHECK(point2.Y() == 1.0);
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] AMCAX_API static Point3 CircleD0(double u, const Frame3& pos, double radius)	 @return The point
	 @param radius The radius
	 @param pos The local frame where the circle lies
	 @param u The parameter
	 @brief Compute the point on a 3D circle represented by a local frame and a radius at a parameter
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
using namespace AMCAX;
TEST_CASE("case1: CurveCalculation::CircleD0 1/2 ", "[math][CurveCalculation][P1]") {
	Direction2 defaultDirection(1.0,0.0); 
	Frame2 defaultFrame2(Point2(0.0, 0.0), defaultDirection);
	double 	r = 3.0;
	double u = 4 * M_PI ; 
	Point2  pointOnCirecle = CurveCalculation::CircleD0(u, defaultFrame2, r);
	std::cout << pointOnCirecle.X() << " " << pointOnCirecle.Y() << " "  << std::endl;
	CHECK(pointOnCirecle.X() == 3.0);
	CHECK(pointOnCirecle.Y() == Approx(0.0).margin(1e-14));
	CHECK(pointOnCirecle.X() * pointOnCirecle.X() + pointOnCirecle.Y() * pointOnCirecle.Y() == r * r);
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] AMCAX_API static Point2 CircleD0(double u, const Frame2& pos, double radius)	 @return The point
	 @param radius The radius
	 @param pos The local frame where the circle lies
	 @param u The parameter
	 @brief Compute the point on a 2D circle represented by a local frame and a radius at a parameter
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
using namespace AMCAX;
TEST_CASE("case1: CurveCalculation::CircleD0 1/2 ", "[math][CurveCalculation][P1]") {
	Direction2 defaultDirection(1.0,0.0); 
	Frame2 defaultFrame2(Point2(0.0, 0.0), defaultDirection);
	double 	r = 3.0;
	double u = 4 * M_PI ; 
	Point2  pointOnCirecle = CurveCalculation::CircleD0(u, defaultFrame2, r);
	std::cout << pointOnCirecle.X() << " " << pointOnCirecle.Y() << " "  << std::endl;
	CHECK(pointOnCirecle.X() == 3.0);
	CHECK(pointOnCirecle.Y() == Approx(0.0).margin(1e-14));
	CHECK(pointOnCirecle.X() * pointOnCirecle.X() + pointOnCirecle.Y() * pointOnCirecle.Y() == r * r);
}
}
,
{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] AMCAX_API static Point3 CircleValue(double u, const Frame3& pos, double radius)	 @return The point
	 @param radius The radius
	 @param pos The local frame where the circle lies
	 @param u The parameter
	 @brief Compute the point on a 3D circle represented by a local frame and a radius at a parameter
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
using namespace AMCAX;
TEST_CASE("case1: CurveCalculation::CircleD2 3/4 ", "[math][CurveCalculation][P1][CircleD2]") {
	Direction3 initialDir(0.0, 0.0, 1.0); 
	Frame3 defaultFrame3(Point3(1.0, 1.0, 0.0), initialDir); 
	double radius = 2.0; 
	Vector3 tangentAt0 = AMCAX::CurveCalculation::CircleD2(0.0, defaultFrame3, radius);
	Vector3 tangentAt90Deg = AMCAX::CurveCalculation::CircleD2(M_PI_2, defaultFrame3, radius);
	Vector3 tangentAt180Deg = AMCAX::CurveCalculation::CircleD2(M_PI, defaultFrame3, radius);
	Vector3 tangentAt270Deg = AMCAX::CurveCalculation::CircleD2(3 * M_PI_2, defaultFrame3, radius);
	Vector3 tangentAt360Deg = AMCAX::CurveCalculation::CircleD2(2 * M_PI, defaultFrame3, radius);
	CHECK(tangentAt0.X() == Approx(-2.0));
	CHECK(tangentAt0.Y() == Approx(-0.0));
	CHECK(tangentAt0.Z() == Approx(0.0));
	CHECK(tangentAt90Deg.X() == Approx(-0.0).margin(1e-14));
	CHECK(tangentAt90Deg.Y() == Approx(-2.0).margin(1e-14));
	CHECK(tangentAt90Deg.Z() == Approx(0.0).margin(1e-14));
	CHECK(tangentAt180Deg.X() == Approx(2.0).margin(1e-14));
	CHECK(tangentAt180Deg.Y() == Approx(-0.0).margin(1e-14));
	CHECK(tangentAt180Deg.Z() == Approx(-0.0));
	CHECK(tangentAt270Deg.X() == Approx(0.0).margin(1e-14));
	CHECK(tangentAt270Deg.Y() == Approx(2.0).margin(1e-14));
	CHECK(tangentAt270Deg.Z() == Approx(0.0).margin(1e-14));
	CHECK(tangentAt360Deg.X() == Approx(-2.0).margin(1e-14));
	CHECK(tangentAt360Deg.Y() == Approx(0.0).margin(1e-14));
	CHECK(tangentAt360Deg.Z() == Approx(0.0).margin(1e-14));
	std::cout << "Tangent at 0 deg: " << tangentAt0 << std::endl;
	std::cout << "Tangent at 90 deg: " << tangentAt90Deg << std::endl;
	std::cout << "Tangent at 180 deg: " << tangentAt180Deg << std::endl;
	std::cout << "Tangent at 270 deg: " << tangentAt270Deg << std::endl;
	std::cout << "Tangent at 360 deg: " << tangentAt360Deg << std::endl;
}
}
,
{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API void Coefficients(double& a, double& b, double& c, double& d)	 @param[out] a,b,c,d The coefficients
	 @brief Get coefficients of algebraic representation: ax + by + cz + d = 0
,
 "output":#include "catch.hpp"
#include <testHelper.h>
#include <math/Plane.hpp>
using namespace AMCAX;
TEST_CASE("case1: Plane construction and methods", "[math][Plane][p1]") {
	SECTION("Default constructor") {
        Plane plane;
        double a, b, c, d;
        plane.Coefficients(a, b, c, d);
        REQUIRE(a == Approx(0));
        REQUIRE(b == Approx(0));
        REQUIRE(c == Approx(1));
        REQUIRE(d == Approx(0));
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":Plane()	 Default constructor
,
 "output":#include "catch.hpp"
#include <testHelper.h>
#include <math/Plane.hpp>
using namespace AMCAX;
TEST_CASE("case1: Plane construction and methods", "[math][Plane][p1]") {
	SECTION("Default constructor") {
        Plane plane;
        double a, b, c, d;
        plane.Coefficients(a, b, c, d);
        REQUIRE(a == Approx(0));
        REQUIRE(b == Approx(0));
        REQUIRE(c == Approx(1));
        REQUIRE(d == Approx(0));
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API explicit Plane(const Frame3& frame)	 @param frame The local frame
	 @brief Construct from a local frame, XOY plane
,
 "output":#include "catch.hpp"
#include <testHelper.h>
#include <math/Plane.hpp>
using namespace AMCAX;
TEST_CASE("case1: Plane construction and methods", "[math][Plane][p1]") {
	SECTION("Construct from frame") {
        Frame3 frame1(Point3(0.0, 0.0, 0.0), Direction3(0.0, 0.0, 1.0));
        Frame3 frame2(Point3(1.0, 0.0, 0.0), Direction3(2.0, 1.0, 1.0));
        Plane plane1(frame1);
        Plane plane2(frame2);  
        double a1, b1, c1, d1;
        plane1.Coefficients(a1, b1, c1, d1);
        double a2, b2, c2, d2;
        plane2.Coefficients(a2, b2, c2, d2);
        REQUIRE(a1 == Approx(0));
        REQUIRE(b1 == Approx(0));
        REQUIRE(c1 == Approx(1));
        REQUIRE(d1 == Approx(0));
        REQUIRE(a2 == Approx(2. / std::sqrt(6)));
        REQUIRE(b2 == Approx(1. / std::sqrt(6)));
        REQUIRE(c2 == Approx(1. / std::sqrt(6)));
        REQUIRE(d2 == Approx(-2. / std::sqrt(6)));
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API Plane(const Point3& point, const Direction3& dir)	 @param dir The direction
	 @param point The point
	 @brief Construct from a point and a direction
,
 "output":#include "catch.hpp"
#include <testHelper.h>
#include <math/Plane.hpp>
using namespace AMCAX;
TEST_CASE("case1: Plane construction and methods", "[math][Plane][p1]") {
	SECTION("Construct from point and direction") {
        Point3 point(1., 1., 1.);
        Direction3 dir(0., 0., 1.);
        Plane plane(point, dir);  
        Point3 point2(3., 4., 4.);
        Direction3 dir2(2., 2., 1.);
        Plane plane2(point2, dir2);  
        double a, b, c, d;
        plane.Coefficients(a, b, c, d);
        double a2, b2, c2, d2;
        plane2.Coefficients(a2, b2, c2, d2);
        REQUIRE(a == Approx(0));
        REQUIRE(b == Approx(0));
        REQUIRE(c == Approx(1));
        REQUIRE(d == Approx(-1));
        REQUIRE(a2 == Approx(2./3).margin(0.0001));
        REQUIRE(b2 == Approx(2./3).margin(0.0001));
        REQUIRE(c2 == Approx(1./3).margin(0.0001));
        REQUIRE(d2 == Approx(-6));
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API Plane(double a, double b, double c, double d)	 @param a,b,c,d The coefficients
	 @brief Construct from an algebraic representation: ax + by + cz + d = 0
,
 "output":#include "catch.hpp"
#include <testHelper.h>
#include <math/Plane.hpp>
using namespace AMCAX;
TEST_CASE("case1: Plane construction and methods", "[math][Plane][p1]") {
	SECTION("Construct from algebraic representation") {
        Plane plane(1., 1., 1., -3.);  
        double a, b, c, d;
        plane.Coefficients(a, b, c, d);  
        REQUIRE(a == Approx(1./std::sqrt(3)).margin(0.001));
        REQUIRE(b == Approx(1. / std::sqrt(3)).margin(0.001));
        REQUIRE(c == Approx(1. / std::sqrt(3)).margin(0.001));
        REQUIRE(d == Approx(-3. / std::sqrt(3)).margin(0.001));
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] AMCAX_API double SquaredDistance(const Point3& point)	 @return The squared point-plane distance
	 @param point The point
	 @brief Compute the squared distance from a point to the plane
,
 "output":#include "catch.hpp"
#include <testHelper.h>
#include <math/Plane.hpp>
using namespace AMCAX;
TEST_CASE("case1: Plane construction and methods", "[math][Plane][p1]") {
	SECTION("Distance methods") {
        std::function<double(const Plane&, const Point3&)> pointToPlane = [](const Plane& plane, const Point3& point)->double {
            double a, b, c, d;
            plane.Coefficients(a, b, c, d);
            return std::fabs(a * point.X() + b * point.Y() + c * point.Z() + d);
        };
        std::function<double(const Plane&, const Line3&)> lineToPlane = [](const Plane& plane, const Line3& line)->double {
            Point3 point = line.Location();
            double a, b, c, d;
            plane.Coefficients(a, b, c, d);
            if (line.Direction().Dot(Vector3(a, b, c)) != 0)  
                return 0;
            return std::fabs(a * point.X() + b * point.Y() + c * point.Z() + d);
        };
        std::function<double(const Plane&, const Plane&)> planeToPlane = [](const Plane& plane1, const Plane& plane2)->double {
            double a1, b1, c1, d1, a2, b2, c2, d2;
            plane1.Coefficients(a1, b1, c1, d1);
            plane2.Coefficients(a2, b2, c2, d2);
            if (a1 != a2 || b1 != b2 || c1 != c2) return 0;
            return std::fabs(d1 - d2);
        };
        Plane plane(0., 0., 1., -1.); 
        Point3 point(1., 1., 2.);
        Line3 line(Point3(1., 1., 3.), Direction3(0., 0., 1.));
        Plane otherPlane1(0, 0, 1, -2); 
        Plane otherPlane2(1, 0, 1, -2); 
        REQUIRE(plane.Distance(point) == Approx(pointToPlane(plane, point)));
        REQUIRE(plane.SquaredDistance(point) == Approx(pointToPlane(plane, point) * pointToPlane(plane, point)));
        REQUIRE(plane.Distance(line) == Approx(lineToPlane(plane, line)));
        REQUIRE(plane.SquaredDistance(line) == Approx(lineToPlane(plane, line) * lineToPlane(plane, line)));
        REQUIRE(plane.Distance(otherPlane1) == Approx(planeToPlane(plane, otherPlane1)));
        REQUIRE(plane.SquaredDistance(otherPlane1) == Approx(planeToPlane(plane, otherPlane1) * planeToPlane(plane, otherPlane1)));
        REQUIRE(plane.Distance(otherPlane2) == Approx(planeToPlane(plane, otherPlane2)));
        REQUIRE(plane.SquaredDistance(otherPlane2) == Approx(planeToPlane(plane, otherPlane2) * planeToPlane(plane, otherPlane2)));
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] AMCAX_API bool Contains(const Point3& point, double tol)	 @return True if the distance between the point and the plane is under the distance tolerance
	 @param tol The distance tolerance
	 @param point The point
	 @brief Determines whether the plane contains a point under a tolerance or not
,
 "output":#include "catch.hpp"
#include <testHelper.h>
#include <math/Plane.hpp>
using namespace AMCAX;
TEST_CASE("case1: Plane construction and methods", "[math][Plane][p1]") {
	SECTION("Contains methods") {
        std::function<bool(const Plane&, const Point3&)> pointInPlane = [](const Plane& plane, const Point3& point)->bool {
            Point3 planePoint = plane.Location();  
            Vector3 planeVector(planePoint, point);  
            double a, b, c, d;
            plane.Coefficients(a, b, c, d);
            return planeVector.Dot(Vector3(a, b, c)) == 0;
        };
        Plane plane(0., 0., 1., -1.); 
        Point3 point(1., 1., 1.);
        Point3 point2(1., 1., 2.);
        Line3 line(Point3(1., 1., 1.), Direction3(1., 0., 0.));
        Line3 line2(Point3(1., 1., 1.), Direction3(0., 0., 1.));  
        Line3 line3(Point3(1., 1., 0.), Direction3(1., 0., 0.));
        REQUIRE(plane.Contains(point, 1e-6) == pointInPlane(plane, point));
        REQUIRE(plane.Contains(point2, 1e-6) == pointInPlane(plane, point2));
        REQUIRE(plane.Contains(line, 1e-6, 1e-6));
        REQUIRE_FALSE(plane.Contains(line2, 1e-6, 1e-6 * (M_PI / 180)));
        REQUIRE_FALSE(plane.Contains(line3, 1e-6, 1e-6 * (M_PI / 180)));
    }}
}
,
{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] double FocalParameter()	 @return The focal parameter
	          Focal parameter = 2 * focalLength.
	 @details The focal parameter of parabola is the distance from the focus to the directrix.
	 @brief Get the focal parameter of the parabola
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <math/ParabolaT.hpp>
using namespace AMCAX;
using namespace std;
TEST_CASE("case1:this is a case for Test Parabola3", "[math][Parabola3][P1]")
{
	Frame3 frame;
	double focal = 5.0;
	Parabola3 parabola(frame, focal);
	SECTION("FocalParameter")
	{
		double FP = parabola.FocalParameter();
		double fp = 2 * focal;
		CHECK(FP == fp);
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] double SemilatusRectum()	 @return The semilatus rectum
	          Semilatus rectum = 2 * focalLength
	 @details The semilatus rectum of parabola is half of the length of the chord through a focus parallel to the directrix.
	 @brief Get the semilatus rectum of the parabola
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <math/ParabolaT.hpp>
using namespace AMCAX;
using namespace std;
TEST_CASE("case1:this is a case for Test Parabola3", "[math][Parabola3][P1]")
{
	Frame3 frame;
	double focal = 5.0;
	Parabola3 parabola(frame, focal);
	SECTION("SemilatusRectum")
	{
		double SR = parabola.SemilatusRectum();
		double sr = 2 * focal;
		CHECK(SR == sr);
	}
}}
}
,
{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] double FocalParameter()	 @return The focal parameter
	          Focal parameter = 2 * focalLength.
	 @details The focal parameter of parabola is the distance from the focus to the directrix.
	 @brief Get the focal parameter of the parabola
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <math/ParabolaT.hpp>
using namespace AMCAX;
using namespace std;
TEST_CASE("case1:this is a case for Test Parabola2", "[math][Parabola2][P1]")
{
	Axis2 axis;
	double focal = 5.0;
	bool isRight = true;
	Parabola2 parabola(axis, focal, isRight);
	SECTION("FocalParameter")
	{
		double FP = parabola.FocalParameter();
		double fp = 2 * focal;
		CHECK(FP == fp);
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] double SemilatusRectum()	 @return The semilatus rectum
	          Semilatus rectum = 2 * focalLength
	 @details The semilatus rectum of parabola is half of the length of the chord through a focus parallel to the directrix.
	 @brief Get the semilatus rectum of the parabola
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <math/ParabolaT.hpp>
using namespace AMCAX;
using namespace std;
TEST_CASE("case1:this is a case for Test Parabola2", "[math][Parabola2][P1]")
{
	Axis2 axis;
	double focal = 5.0;
	bool isRight = true;
	Parabola2 parabola(axis, focal, isRight);
	SECTION("SemilatusRectum")
	{
		double SR = parabola.SemilatusRectum();
		double sr = 2 * focal;
		CHECK(SR == sr);
	}
}}
}
,
{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] double FocalParameter()	 @return The focal parameter
	          Focal parameter = 2 * focalLength.
	 @details The focal parameter of parabola is the distance from the focus to the directrix.
	 @brief Get the focal parameter of the parabola
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <geometry/Geom3Parabola.hpp>
using namespace AMCAX;
using namespace std;
TEST_CASE("case1:this is a case for Test Geom3Parabola", "[math][Geom3Parabola][P1]")
{
	Frame3 frame;
	double focal = 5.0;
	Geom3Parabola g3p(frame, focal);
	SECTION("FocalParameter")
	{
		double FP = g3p.FocalParameter();
		double fp = 2 * focal;
		CHECK(FP == fp);
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] double SemilatusRectum()	 @return The semilatus rectum
	          Semilatus rectum = 2 * focalLength
	 @details The semilatus rectum of parabola is half of the length of the chord through a focus parallel to the directrix.
	 @brief Get the semilatus rectum of the parabola
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <geometry/Geom3Parabola.hpp>
using namespace AMCAX;
using namespace std;
TEST_CASE("case1:this is a case for Test Geom3Parabola", "[math][Geom3Parabola][P1]")
{
	Frame3 frame;
	double focal = 5.0;
	Geom3Parabola g3p(frame, focal);
	SECTION("SemilatusRectum")
	{
		double SR = g3p.SemilatusRectum();
		double sr = 2 * focal;
		CHECK(SR == sr);
	}
}}
}
,
{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] double FocalParameter()	 @return The focal parameter
	          Focal parameter = 2 * focalLength.
	 @details The focal parameter of parabola is the distance from the focus to the directrix.
	 @brief Get the focal parameter of the parabola
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <geometry/Geom2Parabola.hpp>
using namespace AMCAX;
using namespace std;
TEST_CASE("case1:this is a case for Test Geom2Parabola", "[math][Geom2Parabola][P1]")
{
	Axis2 axis;
	double focal = 5.0;
	bool isRight = true;
	Geom2Parabola g2p(axis, focal, isRight);
	SECTION("FocalParameter")
	{
		double FP = g2p.FocalParameter();
		double fp = 2 * focal;
		CHECK(FP == fp);
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] double SemilatusRectum()	 @return The semilatus rectum
	          Semilatus rectum = 2 * focalLength
	 @details The semilatus rectum of parabola is half of the length of the chord through a focus parallel to the directrix.
	 @brief Get the semilatus rectum of the parabola
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <geometry/Geom2Parabola.hpp>
using namespace AMCAX;
using namespace std;
TEST_CASE("case1:this is a case for Test Geom2Parabola", "[math][Geom2Parabola][P1]")
{
	Axis2 axis;
	double focal = 5.0;
	bool isRight = true;
	Geom2Parabola g2p(axis, focal, isRight);
	SECTION("SemilatusRectum")
	{
		double SR = g2p.SemilatusRectum();
		double sr = 2 * focal;
		CHECK(SR == sr);
	}
}}
}
,
{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] bool Contains(const PointT<double, DIM>& p, double tol)	 @return True if the point is on the line under the tolerance
	 @param tol The tolerance
	 @param p The point
	 @brief Does the line contain a point under a distance tolerance
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <math/LineT.hpp>
#include <math/Plane.hpp>
#include <modeling/MakeFace.hpp>
#include <modeling/MakeEdge.hpp>
using AMCAX::Line3;
using AMCAX::MakeEdge;
using AMCAX::MakeFace;
#define ONE_RADIAN (M_PI / 180.)
#define SQUARE(x) ((x) * (x))
TEST_CASE("case2: Line3 base method Test", "[math][Line3][p1]")
{
	SECTION("Translate")
	{
		Line3 line(Point3(), Direction3(1., 1., 1.));
		Line3 originalLine(Point3(), Direction3(1., 1., 1.));
		line.Translate(Point3(), Point3(0., 1., 0.));
		CHECK(originalLine.Direction().IsEqual(line.Direction(), 1e-6 * ONE_RADIAN));
		CHECK(line.Contains(Point3(0., 1., 0.), 1e-6));
		Line3 line2 = line.Translated(Vector3(Direction3(1., -1., 1.)));
		CHECK(line.Direction().IsEqual(line2.Direction(), 1e-6 * ONE_RADIAN));
		CHECK(line2.Contains(Point3(0. + 1. / std::sqrt(3.), 1 - 1. / std::sqrt(3.), 0. + 1. / std::sqrt(3.)), 1e-6));
	}
}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] const PointT<double, DIM>& Location()	 @return The location of the line
	 @brief Get the location point of the line
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <math/LineT.hpp>
#include <math/Plane.hpp>
#include <modeling/MakeFace.hpp>
#include <modeling/MakeEdge.hpp>
using AMCAX::Line3;
using AMCAX::MakeEdge;
using AMCAX::MakeFace;
#define ONE_RADIAN (M_PI / 180.)
#define SQUARE(x) ((x) * (x))
TEST_CASE("case1: Derived class interface unit testing", "[math][Line3][p1]")
{
	SECTION("constructor")
	{
		Line3 line;  
		CHECK(line.Location().IsEqual(Point3(0., 0., 0.), 1e-5));
		CHECK(line.Direction().IsEqual(Direction3(0., 0., 1.), 1e-5 * ONE_RADIAN));
		Axis3 axis(Point3(1., 1., 1.), Direction3(3., 3., 4.));
		Line3 line2(axis);
		CHECK(line2.Position().IsCoaxial(axis, 1e-5 * ONE_RADIAN, 1e-5));  
		Line3 line3(Point3(1., 2., 3.), Direction3(3., 2., 1.));
		CHECK(line3.Location().IsEqual(Point3(1., 2., 3.), 1e-5));
		CHECK(line3.Direction().IsEqual(Direction3(3., 2., 1.), 1e-5 * ONE_RADIAN));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] Derived Scaled(const PointT<double, DIM>& point, double scale)	 @return The scaled line
	 @param scale The scale value
	 @param point The scaling center point
	 @brief Get the line scaled by a point
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <math/LineT.hpp>
#include <math/Plane.hpp>
#include <modeling/MakeFace.hpp>
#include <modeling/MakeEdge.hpp>
using AMCAX::Line3;
using AMCAX::MakeEdge;
using AMCAX::MakeFace;
#define ONE_RADIAN (M_PI / 180.)
#define SQUARE(x) ((x) * (x))
TEST_CASE("case2: Line3 base method Test", "[math][Line3][p1]")
{
	SECTION("Scale")
	{
		Line3 line(Point3(), Direction3(0., 1., 0.));
		Point3 point(1., 1., 0.);
		double originalDistance = line.Distance(point);
		Line3 line1 = line.Scaled(point, 1.1);
		CHECK(line1.Distance(point) > originalDistance);
		Line3 line2 = line.Scaled(point, 1.);
		CHECK(line2.Distance(point) == originalDistance);
		Line3 line3 = line.Scaled(point, 0.8);
		CHECK(line3.Distance(point) < originalDistance);
		Line3 line4 = line.Scaled(point, 0.);
		CHECK(line4.Contains(point, 1e-6));
		Line3 line5 = line.Scaled(point, -1.);
		CHECK(line5.Direction().IsEqual(Direction3(0., -1., 0.), 1e-6 * ONE_RADIAN));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":Derived& Translate(const PointT<double, DIM>& p1, const PointT<double, DIM>& p2)	 @return The reference to self
	 @param p2 The target point
	 @param p1 The source point
	 @brief Translate the line by a vector from a point to another point
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <math/LineT.hpp>
#include <math/Plane.hpp>
#include <modeling/MakeFace.hpp>
#include <modeling/MakeEdge.hpp>
using AMCAX::Line3;
using AMCAX::MakeEdge;
using AMCAX::MakeFace;
#define ONE_RADIAN (M_PI / 180.)
#define SQUARE(x) ((x) * (x))
TEST_CASE("case2: Line3 base method Test", "[math][Line3][p1]")
{
	SECTION("Translate")
	{
		Line3 line(Point3(), Direction3(1., 1., 1.));
		Line3 originalLine(Point3(), Direction3(1., 1., 1.));
		line.Translate(Point3(), Point3(0., 1., 0.));
		CHECK(originalLine.Direction().IsEqual(line.Direction(), 1e-6 * ONE_RADIAN));
		CHECK(line.Contains(Point3(0., 1., 0.), 1e-6));
		Line3 line2 = line.Translated(Vector3(Direction3(1., -1., 1.)));
		CHECK(line.Direction().IsEqual(line2.Direction(), 1e-6 * ONE_RADIAN));
		CHECK(line2.Contains(Point3(0. + 1. / std::sqrt(3.), 1 - 1. / std::sqrt(3.), 0. + 1. / std::sqrt(3.)), 1e-6));
	}
}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] Derived Translated(const VectorT<double, DIM>& vec)	 @return The translated line
	 @param vec The translation vector
	 @brief Get the line translated by a vector
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <math/LineT.hpp>
#include <math/Plane.hpp>
#include <modeling/MakeFace.hpp>
#include <modeling/MakeEdge.hpp>
using AMCAX::Line3;
using AMCAX::MakeEdge;
using AMCAX::MakeFace;
#define ONE_RADIAN (M_PI / 180.)
#define SQUARE(x) ((x) * (x))
TEST_CASE("case2: Line3 base method Test", "[math][Line3][p1]")
{
	SECTION("Translate")
	{
		Line3 line(Point3(), Direction3(1., 1., 1.));
		Line3 originalLine(Point3(), Direction3(1., 1., 1.));
		line.Translate(Point3(), Point3(0., 1., 0.));
		CHECK(originalLine.Direction().IsEqual(line.Direction(), 1e-6 * ONE_RADIAN));
		CHECK(line.Contains(Point3(0., 1., 0.), 1e-6));
		Line3 line2 = line.Translated(Vector3(Direction3(1., -1., 1.)));
		CHECK(line.Direction().IsEqual(line2.Direction(), 1e-6 * ONE_RADIAN));
		CHECK(line2.Contains(Point3(0. + 1. / std::sqrt(3.), 1 - 1. / std::sqrt(3.), 0. + 1. / std::sqrt(3.)), 1e-6));
	}
}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":void SetLocation(const PointT<double, DIM>& point)	 @param point The location point
	 @brief Set the location of the line
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <math/LineT.hpp>
#include <math/Plane.hpp>
#include <modeling/MakeFace.hpp>
#include <modeling/MakeEdge.hpp>
using AMCAX::Line3;
using AMCAX::MakeEdge;
using AMCAX::MakeFace;
#define ONE_RADIAN (M_PI / 180.)
#define SQUARE(x) ((x) * (x))
TEST_CASE("case2: Line3 base method Test", "[math][Line3][p1]")
{
	SECTION("SetLocation")
	{
		Line3 line(Point3(2., 3., 2.), Direction3(2., 3.4, -2.));
		line.SetLocation(Point3(1., -2., 8.));
		CHECK(line.Location().IsEqual(Point3(1., -2., 8.), std::numeric_limits<double>::min()));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":void SetDirection(const DirectionT<double, DIM>& dir)	 @param dir The line direction
	 @brief Set the line direction
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <math/LineT.hpp>
#include <math/Plane.hpp>
#include <modeling/MakeFace.hpp>
#include <modeling/MakeEdge.hpp>
using AMCAX::Line3;
using AMCAX::MakeEdge;
using AMCAX::MakeFace;
#define ONE_RADIAN (M_PI / 180.)
#define SQUARE(x) ((x) * (x))
TEST_CASE("case2: Line3 base method Test", "[math][Line3][p1]")
{
	SECTION("SetDirection")
	{
		Direction3 dir(1., 1., 1.);
		Line3 line;
		line.SetDirection(dir);
		CHECK(line.Direction().IsEqual(dir, std::numeric_limits<double>::min()));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":void SetPosition(const AxisT<double, DIM>& axis)	 @param axis The axis
	 @brief Set the axis of the line
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <math/LineT.hpp>
#include <math/Plane.hpp>
#include <modeling/MakeFace.hpp>
#include <modeling/MakeEdge.hpp>
using AMCAX::Line3;
using AMCAX::MakeEdge;
using AMCAX::MakeFace;
#define ONE_RADIAN (M_PI / 180.)
#define SQUARE(x) ((x) * (x))
TEST_CASE("case2: Line3 base method Test", "[math][Line3][p1]")
{
	SECTION("SetPosition")
	{
		Axis3 axis(Point3(0.1, -2.3, 0.3), Direction3(1.2, -8.9, 3.));
		Line3 line;
		line.SetPosition(axis);
		CHECK(line.Location().IsEqual(axis.Location(), std::numeric_limits<double>::min()));
		CHECK(line.Direction().IsEqual(axis.Direction(), std::numeric_limits<double>::min()));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] const DirectionT<double, DIM>& Direction()	 @return The direction of the line
	 @brief Get the direction of the line
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <math/LineT.hpp>
#include <math/Plane.hpp>
#include <modeling/MakeFace.hpp>
#include <modeling/MakeEdge.hpp>
using AMCAX::Line3;
using AMCAX::MakeEdge;
using AMCAX::MakeFace;
#define ONE_RADIAN (M_PI / 180.)
#define SQUARE(x) ((x) * (x))
TEST_CASE("case1: Derived class interface unit testing", "[math][Line3][p1]")
{
	SECTION("constructor")
	{
		Line3 line;  
		CHECK(line.Location().IsEqual(Point3(0., 0., 0.), 1e-5));
		CHECK(line.Direction().IsEqual(Direction3(0., 0., 1.), 1e-5 * ONE_RADIAN));
		Axis3 axis(Point3(1., 1., 1.), Direction3(3., 3., 4.));
		Line3 line2(axis);
		CHECK(line2.Position().IsCoaxial(axis, 1e-5 * ONE_RADIAN, 1e-5));  
		Line3 line3(Point3(1., 2., 3.), Direction3(3., 2., 1.));
		CHECK(line3.Location().IsEqual(Point3(1., 2., 3.), 1e-5));
		CHECK(line3.Direction().IsEqual(Direction3(3., 2., 1.), 1e-5 * ONE_RADIAN));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] const AxisT<double, DIM>& Position()	 @return The axis of the line
	 @brief Get the axis of the line
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <math/LineT.hpp>
#include <math/Plane.hpp>
#include <modeling/MakeFace.hpp>
#include <modeling/MakeEdge.hpp>
using AMCAX::Line3;
using AMCAX::MakeEdge;
using AMCAX::MakeFace;
#define ONE_RADIAN (M_PI / 180.)
#define SQUARE(x) ((x) * (x))
TEST_CASE("case1: Derived class interface unit testing", "[math][Line3][p1]")
{
	SECTION("constructor")
	{
		Line3 line;  
		CHECK(line.Location().IsEqual(Point3(0., 0., 0.), 1e-5));
		CHECK(line.Direction().IsEqual(Direction3(0., 0., 1.), 1e-5 * ONE_RADIAN));
		Axis3 axis(Point3(1., 1., 1.), Direction3(3., 3., 4.));
		Line3 line2(axis);
		CHECK(line2.Position().IsCoaxial(axis, 1e-5 * ONE_RADIAN, 1e-5));  
		Line3 line3(Point3(1., 2., 3.), Direction3(3., 2., 1.));
		CHECK(line3.Location().IsEqual(Point3(1., 2., 3.), 1e-5));
		CHECK(line3.Direction().IsEqual(Direction3(3., 2., 1.), 1e-5 * ONE_RADIAN));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] auto Angle(const LineBase& other)	 @return The angle between the line and the other line
	 @param other The other line
	 @brief Compute the angle between the line and the other line
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <math/LineT.hpp>
#include <math/Plane.hpp>
#include <modeling/MakeFace.hpp>
#include <modeling/MakeEdge.hpp>
using AMCAX::Line3;
using AMCAX::MakeEdge;
using AMCAX::MakeFace;
#define ONE_RADIAN (M_PI / 180.)
#define SQUARE(x) ((x) * (x))
TEST_CASE("case2: Line3 base method Test", "[math][Line3][p1]")
{
	SECTION("Angle")
	{
		Line3 line(Point3(0., 1., 0.), Direction3(1., 1., 1.));
		Line3 line2(Point3(0., 3.4, 0.), Direction3(2., -1., -1.5));
		CHECK(line.Angle(line2) == Approx(std::acos(line.Direction().Dot(line2.Direction()))).margin(1e-6 * ONE_RADIAN));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] Derived Reversed()	 @return The line with reversed direction
	 @brief Get the line with reversed direction
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <math/LineT.hpp>
#include <math/Plane.hpp>
#include <modeling/MakeFace.hpp>
#include <modeling/MakeEdge.hpp>
using AMCAX::Line3;
using AMCAX::MakeEdge;
using AMCAX::MakeFace;
#define ONE_RADIAN (M_PI / 180.)
#define SQUARE(x) ((x) * (x))
TEST_CASE("case2: Line3 base method Test", "[math][Line3][p1]")
{
	SECTION("Reverse")
	{
		Line3 line(Point3(), Direction3(1., 1., 1.));
		Line3 reverseLine = line.Reversed();
		CHECK(reverseLine.Direction().IsEqual(Direction3(-1., -1., -1.), 1e-6 * ONE_RADIAN));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] auto Distance(const LineS& l)	 @return The distance between two lines
	 @param l The other line
	 @brief Compute the distance between two lines
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <math/LineT.hpp>
#include <math/Plane.hpp>
#include <modeling/MakeFace.hpp>
#include <modeling/MakeEdge.hpp>
using AMCAX::Line3;
using AMCAX::MakeEdge;
using AMCAX::MakeFace;
#define ONE_RADIAN (M_PI / 180.)
#define SQUARE(x) ((x) * (x))
TEST_CASE("case1: Derived class interface unit testing", "[math][Line3][p1]")
{
	SECTION("Distance and SquaredDistance")
	{
		auto pointToLine = [](const Point3& p, const Line3& line) {
			const Point3& p1 = line.Location();
			double dX = p1.X() - p.X();
			double dY = p1.Y() - p.Y();
			double dZ = p1.Z() - p.Z();
			double pp1Square = SQUARE(dX) + SQUARE(dY) + SQUARE(dZ);
			Direction3 dir(dX, dY, dZ);
			double cos = std::fabs(dir.Dot(line.Direction()));
			return std::sqrt(pp1Square - SQUARE(cos*std::sqrt(pp1Square)));
		};
		auto lineToLine = [&pointToLine](const Line3& line1, const Line3& line2) {
			if (line1.Direction().IsParallel(line2.Direction(), std::numeric_limits<double>::min()))
				return pointToLine(line1.Location(), line2);
			Direction3 line1Dir = line1.Direction();
			Direction3 line2Dir = line2.Direction();
			double x3 = line1Dir.Y() * line2Dir.Z() - line2Dir.Y() * line1Dir.Z();
			double y3 = -(line1Dir.X() * line2Dir.Z() - line2Dir.X() * line1Dir.Z());
			double z3 = line1Dir.X() * line2Dir.Y() - line2Dir.X() * line1Dir.Y();
			Direction3 line3Dir(x3, y3, z3);
			Direction3 line12Dir(line1.Location().X() - line2.Location().X(), 
								 line1.Location().Y() - line2.Location().Y(), line1.Location().Z() - line2.Location().Z());
			return std::fabs(line3Dir.Dot(line12Dir));
		};
		Line3 line(Point3(99., 2., 33.), Direction3(2.3, 4.6, 9.8));
		CHECK(line.Distance(Point3(0., 1., 0.)) == Approx(pointToLine(Point3(0., 1., 0.), line)).margin(1e-5));
		Line3 line2(Point3(0., 0., 0.), Direction3(1., 0., 0.));
		Line3 line3(Point3(0., 1., 0.), Direction3(1., 0., 0.));
		CHECK(line2.Distance(line3) == Approx(lineToLine(line2, line3)).margin(std::numeric_limits<double>::min()));
		CHECK(line2.SquaredDistance(line3) == Approx(SQUARE(lineToLine(line2, line3))).margin(std::numeric_limits<double>::min()));
		Line3 line4(Point3(0., 0., 0.), Direction3(1., 0., 0.));
		Line3 line5(Point3(0., 1., 0.), Direction3(1., 1., 0.));
		CHECK(line4.Distance(line5) == Approx(lineToLine(line4, line5)).margin(std::numeric_limits<double>::min()));
		Line3 line6(Point3(0., 0., 0.), Direction3(0., 0., 1.));
		Line3 line7(Point3(0., 1., 0.), Direction3(1., 1., 0.));
		CHECK(line6.Distance(line7) == Approx(lineToLine(line6, line7)).margin(std::numeric_limits<double>::min()));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] auto SquaredDistance(const LineS& l)	 @return The squared distance between two lines
	 @param l The other line
	 @brief Compute the squared distance between two lines
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <math/LineT.hpp>
#include <math/Plane.hpp>
#include <modeling/MakeFace.hpp>
#include <modeling/MakeEdge.hpp>
using AMCAX::Line3;
using AMCAX::MakeEdge;
using AMCAX::MakeFace;
#define ONE_RADIAN (M_PI / 180.)
#define SQUARE(x) ((x) * (x))
TEST_CASE("case1: Derived class interface unit testing", "[math][Line3][p1]")
{
	SECTION("Distance and SquaredDistance")
	{
		auto pointToLine = [](const Point3& p, const Line3& line) {
			const Point3& p1 = line.Location();
			double dX = p1.X() - p.X();
			double dY = p1.Y() - p.Y();
			double dZ = p1.Z() - p.Z();
			double pp1Square = SQUARE(dX) + SQUARE(dY) + SQUARE(dZ);
			Direction3 dir(dX, dY, dZ);
			double cos = std::fabs(dir.Dot(line.Direction()));
			return std::sqrt(pp1Square - SQUARE(cos*std::sqrt(pp1Square)));
		};
		auto lineToLine = [&pointToLine](const Line3& line1, const Line3& line2) {
			if (line1.Direction().IsParallel(line2.Direction(), std::numeric_limits<double>::min()))
				return pointToLine(line1.Location(), line2);
			Direction3 line1Dir = line1.Direction();
			Direction3 line2Dir = line2.Direction();
			double x3 = line1Dir.Y() * line2Dir.Z() - line2Dir.Y() * line1Dir.Z();
			double y3 = -(line1Dir.X() * line2Dir.Z() - line2Dir.X() * line1Dir.Z());
			double z3 = line1Dir.X() * line2Dir.Y() - line2Dir.X() * line1Dir.Y();
			Direction3 line3Dir(x3, y3, z3);
			Direction3 line12Dir(line1.Location().X() - line2.Location().X(), 
								 line1.Location().Y() - line2.Location().Y(), line1.Location().Z() - line2.Location().Z());
			return std::fabs(line3Dir.Dot(line12Dir));
		};
		Line3 line(Point3(99., 2., 33.), Direction3(2.3, 4.6, 9.8));
		CHECK(line.Distance(Point3(0., 1., 0.)) == Approx(pointToLine(Point3(0., 1., 0.), line)).margin(1e-5));
		Line3 line2(Point3(0., 0., 0.), Direction3(1., 0., 0.));
		Line3 line3(Point3(0., 1., 0.), Direction3(1., 0., 0.));
		CHECK(line2.Distance(line3) == Approx(lineToLine(line2, line3)).margin(std::numeric_limits<double>::min()));
		CHECK(line2.SquaredDistance(line3) == Approx(SQUARE(lineToLine(line2, line3))).margin(std::numeric_limits<double>::min()));
		Line3 line4(Point3(0., 0., 0.), Direction3(1., 0., 0.));
		Line3 line5(Point3(0., 1., 0.), Direction3(1., 1., 0.));
		CHECK(line4.Distance(line5) == Approx(lineToLine(line4, line5)).margin(std::numeric_limits<double>::min()));
		Line3 line6(Point3(0., 0., 0.), Direction3(0., 0., 1.));
		Line3 line7(Point3(0., 1., 0.), Direction3(1., 1., 0.));
		CHECK(line6.Distance(line7) == Approx(lineToLine(line6, line7)).margin(std::numeric_limits<double>::min()));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] auto Distance(const Point3& p)	 @return The distance between the point and the line
	 @param p The point
	 @brief Compute the distance from a point to the line
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <math/LineT.hpp>
#include <math/Plane.hpp>
#include <modeling/MakeFace.hpp>
#include <modeling/MakeEdge.hpp>
using AMCAX::Line3;
using AMCAX::MakeEdge;
using AMCAX::MakeFace;
#define ONE_RADIAN (M_PI / 180.)
#define SQUARE(x) ((x) * (x))
TEST_CASE("case1: Derived class interface unit testing", "[math][Line3][p1]")
{
	SECTION("Distance and SquaredDistance")
	{
		auto pointToLine = [](const Point3& p, const Line3& line) {
			const Point3& p1 = line.Location();
			double dX = p1.X() - p.X();
			double dY = p1.Y() - p.Y();
			double dZ = p1.Z() - p.Z();
			double pp1Square = SQUARE(dX) + SQUARE(dY) + SQUARE(dZ);
			Direction3 dir(dX, dY, dZ);
			double cos = std::fabs(dir.Dot(line.Direction()));
			return std::sqrt(pp1Square - SQUARE(cos*std::sqrt(pp1Square)));
		};
		auto lineToLine = [&pointToLine](const Line3& line1, const Line3& line2) {
			if (line1.Direction().IsParallel(line2.Direction(), std::numeric_limits<double>::min()))
				return pointToLine(line1.Location(), line2);
			Direction3 line1Dir = line1.Direction();
			Direction3 line2Dir = line2.Direction();
			double x3 = line1Dir.Y() * line2Dir.Z() - line2Dir.Y() * line1Dir.Z();
			double y3 = -(line1Dir.X() * line2Dir.Z() - line2Dir.X() * line1Dir.Z());
			double z3 = line1Dir.X() * line2Dir.Y() - line2Dir.X() * line1Dir.Y();
			Direction3 line3Dir(x3, y3, z3);
			Direction3 line12Dir(line1.Location().X() - line2.Location().X(), 
								 line1.Location().Y() - line2.Location().Y(), line1.Location().Z() - line2.Location().Z());
			return std::fabs(line3Dir.Dot(line12Dir));
		};
		Line3 line(Point3(99., 2., 33.), Direction3(2.3, 4.6, 9.8));
		CHECK(line.Distance(Point3(0., 1., 0.)) == Approx(pointToLine(Point3(0., 1., 0.), line)).margin(1e-5));
		Line3 line2(Point3(0., 0., 0.), Direction3(1., 0., 0.));
		Line3 line3(Point3(0., 1., 0.), Direction3(1., 0., 0.));
		CHECK(line2.Distance(line3) == Approx(lineToLine(line2, line3)).margin(std::numeric_limits<double>::min()));
		CHECK(line2.SquaredDistance(line3) == Approx(SQUARE(lineToLine(line2, line3))).margin(std::numeric_limits<double>::min()));
		Line3 line4(Point3(0., 0., 0.), Direction3(1., 0., 0.));
		Line3 line5(Point3(0., 1., 0.), Direction3(1., 1., 0.));
		CHECK(line4.Distance(line5) == Approx(lineToLine(line4, line5)).margin(std::numeric_limits<double>::min()));
		Line3 line6(Point3(0., 0., 0.), Direction3(0., 0., 1.));
		Line3 line7(Point3(0., 1., 0.), Direction3(1., 1., 0.));
		CHECK(line6.Distance(line7) == Approx(lineToLine(line6, line7)).margin(std::numeric_limits<double>::min()));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] auto SquaredDistance(const Point3& p)	 @return The squared distance between the point and the line
	 @param p The point
	 @brief Compute the squared distance from a point to the line
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <math/LineT.hpp>
#include <math/Plane.hpp>
#include <modeling/MakeFace.hpp>
#include <modeling/MakeEdge.hpp>
using AMCAX::Line3;
using AMCAX::MakeEdge;
using AMCAX::MakeFace;
#define ONE_RADIAN (M_PI / 180.)
#define SQUARE(x) ((x) * (x))
TEST_CASE("case1: Derived class interface unit testing", "[math][Line3][p1]")
{
	SECTION("Distance and SquaredDistance")
	{
		auto pointToLine = [](const Point3& p, const Line3& line) {
			const Point3& p1 = line.Location();
			double dX = p1.X() - p.X();
			double dY = p1.Y() - p.Y();
			double dZ = p1.Z() - p.Z();
			double pp1Square = SQUARE(dX) + SQUARE(dY) + SQUARE(dZ);
			Direction3 dir(dX, dY, dZ);
			double cos = std::fabs(dir.Dot(line.Direction()));
			return std::sqrt(pp1Square - SQUARE(cos*std::sqrt(pp1Square)));
		};
		auto lineToLine = [&pointToLine](const Line3& line1, const Line3& line2) {
			if (line1.Direction().IsParallel(line2.Direction(), std::numeric_limits<double>::min()))
				return pointToLine(line1.Location(), line2);
			Direction3 line1Dir = line1.Direction();
			Direction3 line2Dir = line2.Direction();
			double x3 = line1Dir.Y() * line2Dir.Z() - line2Dir.Y() * line1Dir.Z();
			double y3 = -(line1Dir.X() * line2Dir.Z() - line2Dir.X() * line1Dir.Z());
			double z3 = line1Dir.X() * line2Dir.Y() - line2Dir.X() * line1Dir.Y();
			Direction3 line3Dir(x3, y3, z3);
			Direction3 line12Dir(line1.Location().X() - line2.Location().X(), 
								 line1.Location().Y() - line2.Location().Y(), line1.Location().Z() - line2.Location().Z());
			return std::fabs(line3Dir.Dot(line12Dir));
		};
		Line3 line(Point3(99., 2., 33.), Direction3(2.3, 4.6, 9.8));
		CHECK(line.Distance(Point3(0., 1., 0.)) == Approx(pointToLine(Point3(0., 1., 0.), line)).margin(1e-5));
		Line3 line2(Point3(0., 0., 0.), Direction3(1., 0., 0.));
		Line3 line3(Point3(0., 1., 0.), Direction3(1., 0., 0.));
		CHECK(line2.Distance(line3) == Approx(lineToLine(line2, line3)).margin(std::numeric_limits<double>::min()));
		CHECK(line2.SquaredDistance(line3) == Approx(SQUARE(lineToLine(line2, line3))).margin(std::numeric_limits<double>::min()));
		Line3 line4(Point3(0., 0., 0.), Direction3(1., 0., 0.));
		Line3 line5(Point3(0., 1., 0.), Direction3(1., 1., 0.));
		CHECK(line4.Distance(line5) == Approx(lineToLine(line4, line5)).margin(std::numeric_limits<double>::min()));
		Line3 line6(Point3(0., 0., 0.), Direction3(0., 0., 1.));
		Line3 line7(Point3(0., 1., 0.), Direction3(1., 1., 0.));
		CHECK(line6.Distance(line7) == Approx(lineToLine(line6, line7)).margin(std::numeric_limits<double>::min()));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] LineS Normal(const Point3& p)	 @return The line passing through a point and perpendicular to the line
	 @param p The point
	 @brief Get a line passing through a point and perpendicular to the line
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <math/LineT.hpp>
#include <math/Plane.hpp>
#include <modeling/MakeFace.hpp>
#include <modeling/MakeEdge.hpp>
using AMCAX::Line3;
using AMCAX::MakeEdge;
using AMCAX::MakeFace;
#define ONE_RADIAN (M_PI / 180.)
#define SQUARE(x) ((x) * (x))
TEST_CASE("case1: Derived class interface unit testing", "[math][Line3][p1]")
{
	SECTION("Normal")
	{
		Line3 line(Point3(94., 32., 4.8), Direction3(2.65, 3.28, 5.14));
		Line3 line2 = line.Normal(Point3(2.1, 3.4, 11.2));
		CHECK(line.Direction().Dot(line2.Direction()) == Approx(0.).margin(1e-6));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":LineS& Mirror(const Frame3& frame)	 @return The reference to self
	 @param frame The mirror frame
	 @brief Mirror the line by a frame
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <math/LineT.hpp>
#include <math/Plane.hpp>
#include <modeling/MakeFace.hpp>
#include <modeling/MakeEdge.hpp>
using AMCAX::Line3;
using AMCAX::MakeEdge;
using AMCAX::MakeFace;
#define ONE_RADIAN (M_PI / 180.)
#define SQUARE(x) ((x) * (x))
TEST_CASE("case1: Derived class interface unit testing", "[math][Line3][p1]")
{
	SECTION("Mirror")
	{
		Line3 line(Point3(1.0, 2.0, 3.0), Direction3(1.0, 0.0, 0.0));
		Line3 originalLine(Point3(1.0, 2.0, 3.0), Direction3(1.0, 0.0, 0.0));
		Frame3 frame(Point3(0.0, 0.0, 0.0), Direction3(0.0, 1.0, 0.0));
		line.Mirror(frame);
		CHECK(line.Distance(Point3(0.0, 0.0, 0.0)) == Approx(originalLine.Distance(Point3(0., 0., 0.))).margin(std::numeric_limits<double>::min()));
		Direction3 dir(originalLine.Location().X() - line.Location().X(),
					   originalLine.Location().Y() - line.Location().Y(),
					   originalLine.Location().Z() - line.Location().Z());
		CHECK(dir.IsParallel(Direction3(0.0, 1.0, 0.0), 1e-5 * ONE_RADIAN));
		Line3 line2(Point3(1.2, -4.6, 2.3), Direction3(1.8, 97.4, -12.8));
		Frame3 frame2(Point3(87.0, 2.3, 10.14), Direction3(-92.3, 2.6, 1.0));
		Line3 mirrorLine2 = line2.Mirrored(frame2);
		CHECK(line2.Distance(Point3(87.0, 2.3, 10.14)) == Approx(mirrorLine2.Distance(Point3(87.0, 2.3, 10.14))).margin(std::numeric_limits<double>::min()));
		Direction3 dir2(line2.Location().X() - mirrorLine2.Location().X(),
					    line2.Location().Y() - mirrorLine2.Location().Y(),
					    line2.Location().Z() - mirrorLine2.Location().Z());
		CHECK(dir2.IsParallel(Direction3(-92.3, 2.6, 1.0), 1e-5 * ONE_RADIAN));
		TopoFace face = MakeFace(Plane(frame2), 0., 4., 0., 4.);
		TopoEdge edgeLine2 = MakeEdge(line2, 0., 1.);
		TopoEdge edgeMirrorLine2 = MakeEdge(mirrorLine2, 0., 1.);
		AMCAX::OCCTIO::OCCTTool::Write(face, OUTPUT_PATH_PREFIX"Line3_Mirror_face2.brep");
		AMCAX::OCCTIO::OCCTTool::Write(edgeLine2, OUTPUT_PATH_PREFIX"Line3_Mirror_edge.brep");
		AMCAX::OCCTIO::OCCTTool::Write(edgeMirrorLine2, OUTPUT_PATH_PREFIX"Line3_Mirror_Mirroredge.brep");
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] LineS Rotated(const Axis3& axis, double angle)	 @return The rotated line
	 @param angle The rotation angle
	 @param axis The rotation axis
	 @brief Get the line rotated around an axis with an angle in 3D
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <math/LineT.hpp>
#include <math/Plane.hpp>
#include <modeling/MakeFace.hpp>
#include <modeling/MakeEdge.hpp>
using AMCAX::Line3;
using AMCAX::MakeEdge;
using AMCAX::MakeFace;
#define ONE_RADIAN (M_PI / 180.)
#define SQUARE(x) ((x) * (x))
TEST_CASE("case1: Derived class interface unit testing", "[math][Line3][p1]")
{
	SECTION("Rotate")
	{
		Axis3 axis(Point3(0., 0., 0.), Direction3(0., 1., 0.));
		Line3 line(Point3(0., 0., 0.), Direction3(1., 1., -1.));
		Line3 rotateLine = line.Rotated(axis, 90. * ONE_RADIAN);  
		TopoEdge edge1 = MakeEdge(line);
		TopoEdge edge2 = MakeEdge(rotateLine);
		TopoEdge edge3 = MakeEdge(Line3(axis));
		bool isWriteSuccess1 = AMCAX::OCCTIO::OCCTTool::Write(edge1, OUTPUT_PATH_PREFIX"Line3_Rotate_line.brep");
		bool isWriteSuccess2 = AMCAX::OCCTIO::OCCTTool::Write(edge2, OUTPUT_PATH_PREFIX"Line3_Rotate_lineRotate.brep");
		bool isWriteSuccess3 = AMCAX::OCCTIO::OCCTTool::Write(edge3, OUTPUT_PATH_PREFIX"Line3_Rotate_axis.brep");
		REQUIRE(isWriteSuccess1);
		REQUIRE(isWriteSuccess2);
		REQUIRE(isWriteSuccess3);
		auto pointToPoint = [](const Point3& p1, const Point3& p2) {
			return std::sqrt(
				SQUARE(p1.X() - p2.X()) +
				SQUARE(p1.Y() - p2.Y()) +
				SQUARE(p1.Z() - p2.Z())
			);
		};
		CHECK(line.Distance(Line3(axis)) == Approx(rotateLine.Distance(Line3(axis))).margin(std::numeric_limits<double>::min()));
		CHECK(pointToPoint(line.Location(), Point3()) == Approx(pointToPoint(rotateLine.Location(), Point3())).margin(std::numeric_limits<double>::min()));
		Point3 p(-1., 1., -1.);
		CHECK(rotateLine.Contains(p, 1e-6) == true);
	}
}}
}
,
{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] bool Contains(const PointT<double, DIM>& p, double tol)	 @return True if the point is on the line under the tolerance
	 @param tol The tolerance
	 @param p The point
	 @brief Does the line contain a point under a distance tolerance
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <math/LineT.hpp>
#include <modeling/MakeEdge2d.hpp>
using AMCAX::Line2;
#define ONE_RADIAN (M_PI / 180.)
TEST_CASE("case2: Line base method Test", "[math][Line2][p1]")
{
	SECTION("Contains")
	{
		Line2 line(Axis2(Point2(2., 1.), Direction2(1., 1.)));  
		Point2 point1(2., 1.);  
		Point2 point2(1., 1.);  
		CHECK(line.Contains(point1, 1e-5));
		CHECK_FALSE(line.Contains(point2, 1e-5));
		CHECK(line.Contains(point2, 1.));  
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] const PointT<double, DIM>& Location()	 @return The location of the line
	 @brief Get the location point of the line
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <math/LineT.hpp>
#include <modeling/MakeEdge2d.hpp>
using AMCAX::Line2;
#define ONE_RADIAN (M_PI / 180.)
TEST_CASE("case1: Line basic interface test", "[math][Line2][p1]")
{
	SECTION("Parameterless constructor test")
	{
		Line2 line;  
		CHECK(line.Location().IsEqual(Axis2().Location(), 0.001));
		CHECK(line.Direction().IsEqual(Axis2().Direction(), 1e-5 * ONE_RADIAN));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] Derived Scaled(const PointT<double, DIM>& point, double scale)	 @return The scaled line
	 @param scale The scale value
	 @param point The scaling center point
	 @brief Get the line scaled by a point
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <math/LineT.hpp>
#include <modeling/MakeEdge2d.hpp>
using AMCAX::Line2;
#define ONE_RADIAN (M_PI / 180.)
TEST_CASE("case2: Line base method Test", "[math][Line2][p1]")
{
	SECTION("Scale")
	{
		Line2 line(Point2(0., -1.), Direction2());
		Point2 point;
		double distance = line.Distance(point);
		Line2 lineScale1 = line.Scaled(point, 1.1);
		CHECK(lineScale1.Distance(point) > distance);
		CHECK(lineScale1.Contains(Point2(0., -1.1), 1e-5));
		Line2 lineScale2 = line.Scaled(point, 1.);
		CHECK(lineScale2.Distance(point) == Approx(distance).margin(1e-5));
		CHECK(lineScale2.Contains(Point2(0., -1.), 1e-5));
		Line2 lineScale3 = line.Scaled(point, 0.8);
		CHECK(lineScale3.Distance(point) < distance);
		CHECK(lineScale3.Contains(Point2(0., -0.8), 1e-5));
		Line2 lineScale4 = line.Scaled(point, 0.);
		line.SetDirection(Direction2(-1.0, 4.0));
		Line2 lineScale5 = line.Scaled(Point2(-1., 2.), 0.);
		CHECK(lineScale4.Contains(Point2(0., 0.), 1e-5));
		CHECK(lineScale4.Direction().IsEqual(Direction2(), 1e-6 * ONE_RADIAN));
		CHECK(lineScale5.Contains(Point2(-1., 2.), 1e-5));
		CHECK(lineScale5.Direction().IsEqual(Direction2(-1., 4.), 1e-6 * ONE_RADIAN));
		Line2 lineScale6 = line.Scaled(point, -1.);
		CHECK(lineScale6.Direction().IsEqual(Direction2(1., -4.), 1e-5 * ONE_RADIAN));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":Derived& Translate(const VectorT<double, DIM>& vec)	 @return The reference to self
	 @param vec The translation vector
	 @brief Translate the line by a vector
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <math/LineT.hpp>
#include <modeling/MakeEdge2d.hpp>
using AMCAX::Line2;
#define ONE_RADIAN (M_PI / 180.)
TEST_CASE("case2: Line base method Test", "[math][Line2][p1]")
{
	SECTION("Translate Test")
	{
		Line2 line;
		line.Translate(Vector2(2., 0.));  
		CHECK(line.Direction().IsEqual(Direction2(), 1e-5 * ONE_RADIAN));
		CHECK(line.Contains(Point2(2., 0.), 1e-5));
		Line2 translateLine = line.Translated(Point2(2., 0.), Point2(-10., 0.));
		CHECK(translateLine.Contains(Point2(-10., 0.), 1e-5));
	}
}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":void SetLocation(const PointT<double, DIM>& point)	 @param point The location point
	 @brief Set the location of the line
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <math/LineT.hpp>
#include <modeling/MakeEdge2d.hpp>
using AMCAX::Line2;
#define ONE_RADIAN (M_PI / 180.)
TEST_CASE("case2: Line base method Test", "[math][Line2][p1]")
{
	SECTION("SetLocation")
	{
		Line2 line(Point2(0., 0.), Direction2(1., 1.));  
		CHECK(line.Location().IsEqual(Point2(), 1e-5));
		line.SetLocation(Point2(2., 1.));  
		CHECK(line.Location().IsEqual(Point2(2., 1.), 1e-5));
		double a, b, c;
		line.Coefficients(a, b, c);
		CHECK(a == Approx(1. / std::sqrt(2)).margin(1e-5));
		CHECK(b == Approx(-1. / std::sqrt(2)).margin(1e-5));
		CHECK(c == Approx(-1. / std::sqrt(2)).margin(1e-5));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":void SetDirection(const DirectionT<double, DIM>& dir)	 @param dir The line direction
	 @brief Set the line direction
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <math/LineT.hpp>
#include <modeling/MakeEdge2d.hpp>
using AMCAX::Line2;
#define ONE_RADIAN (M_PI / 180.)
TEST_CASE("case2: Line base method Test", "[math][Line2][p1]")
{
	SECTION("SetDirection")
	{
		Line2 line(Point2(), Direction2(1., 1.));  
		CHECK(line.Direction().IsEqual(Direction2(1., 1.), 1e-5 * ONE_RADIAN));
		CHECK(line.Distance(Point2(1., 2.)) > 0.);
		line.SetDirection(Direction2(1., 2.));  
		CHECK(line.Direction().IsEqual(Direction2(1., 2.), 1e-5 * ONE_RADIAN));
		CHECK(line.Distance(Point2(1., 2.)) == Approx(0.).margin(1e-5));
		double a, b, c;
		line.Coefficients(a, b, c);
		CHECK(a == Approx(2. / std::sqrt(5)).margin(1e-5));
		CHECK(b == Approx(-1. / std::sqrt(5)).margin(1e-5));
		CHECK(c == Approx(0. / std::sqrt(5)).margin(1e-5));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":void SetPosition(const AxisT<double, DIM>& axis)	 @param axis The axis
	 @brief Set the axis of the line
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <math/LineT.hpp>
#include <modeling/MakeEdge2d.hpp>
using AMCAX::Line2;
#define ONE_RADIAN (M_PI / 180.)
TEST_CASE("case2: Line base method Test", "[math][Line2][p1]")
{
	SECTION("SetPosition")
	{
		Line2 line;
		CHECK(line.Location().IsEqual(Point2(0., 0.), 1e-5));
		CHECK(line.Direction().IsEqual(Direction2(1., 0.), 1e-5 * ONE_RADIAN));
		Axis2 axis(Point2(2., 1.), Direction2(1., 1.));
		line.SetPosition(axis);  
		double a, b, c;
		line.Coefficients(a, b, c);
		CHECK(a == Approx(1. / std::sqrt(2)).margin(1e-5));
		CHECK(b == Approx(-1. / std::sqrt(2)).margin(1e-5));
		CHECK(c == Approx(-1. / std::sqrt(2)).margin(1e-5));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] const DirectionT<double, DIM>& Direction()	 @return The direction of the line
	 @brief Get the direction of the line
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <math/LineT.hpp>
#include <modeling/MakeEdge2d.hpp>
using AMCAX::Line2;
#define ONE_RADIAN (M_PI / 180.)
TEST_CASE("case2: Line base method Test", "[math][Line2][p1]")
{
	SECTION("SetPosition")
	{
		Line2 line;
		CHECK(line.Location().IsEqual(Point2(0., 0.), 1e-5));
		CHECK(line.Direction().IsEqual(Direction2(1., 0.), 1e-5 * ONE_RADIAN));
		Axis2 axis(Point2(2., 1.), Direction2(1., 1.));
		line.SetPosition(axis);  
		double a, b, c;
		line.Coefficients(a, b, c);
		CHECK(a == Approx(1. / std::sqrt(2)).margin(1e-5));
		CHECK(b == Approx(-1. / std::sqrt(2)).margin(1e-5));
		CHECK(c == Approx(-1. / std::sqrt(2)).margin(1e-5));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] auto Angle(const LineBase& other)	 @return The angle between the line and the other line
	 @param other The other line
	 @brief Compute the angle between the line and the other line
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <math/LineT.hpp>
#include <modeling/MakeEdge2d.hpp>
using AMCAX::Line2;
#define ONE_RADIAN (M_PI / 180.)
TEST_CASE("case2: Line base method Test", "[math][Line2][p1]")
{
	SECTION("Angle")
	{
		Line2 line;
		Line2 line2(Point2(), Direction2(0., 1.));
		CHECK(line.Angle(line2) == Approx(M_PI_2));
		CHECK(line2.Angle(line) == Approx(-M_PI_2));
		Line2 line3(Point2(), Direction2(2., 3.));
		Line2 line4(Point2(), Direction2(5., -8.));
		CHECK(line4.Angle(line3) == Approx(
			std::acos((2. * 5. + 3. * (-8.)) / (std::sqrt(4. + 9.) * std::sqrt(25. + 64.)))
		).margin(1e-5 * ONE_RADIAN));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":Derived& Reverse()	 @return The reference to self
	 @brief Reverse the line direction
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <math/LineT.hpp>
#include <modeling/MakeEdge2d.hpp>
using AMCAX::Line2;
#define ONE_RADIAN (M_PI / 180.)
TEST_CASE("case2: Line base method Test", "[math][Line2][p1]")
{
	SECTION("Reverse")
	{
		Line2 line;
		line.Reverse();
		CHECK(line.Direction().IsEqual(Direction2(-1., 0.), 1e-5 * ONE_RADIAN));
		Line2 line2(Point2(), Direction2(-3., 98.));
		line2.Reverse();
		CHECK(line2.Direction().IsEqual(Direction2(3., -98.), 1e-5 * ONE_RADIAN));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":LineS(double a, double b, double c)	 @param a,b,c The coefficients
	 @brief Construct from the algebraic coefficients of 2D line
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <math/LineT.hpp>
#include <modeling/MakeEdge2d.hpp>
using AMCAX::Line2;
#define ONE_RADIAN (M_PI / 180.)
TEST_CASE("case1: Line basic interface test", "[math][Line2][p1]")
{
	SECTION("Parameterized constructor test")
	{
		Line2 line1(Axis2(Point2(1., 0.), Direction2(2., 1.)));
		Line2 line2(Point2(1., 0.), Direction2(2., 1.));  
		Line2 line3(1, -2, -1);
		double a, b, c;
		line1.Coefficients(a, b, c);
		CHECK(a == Approx(1.0 / std::sqrt(5)));
		CHECK(b == Approx(-2.0 / std::sqrt(5)));
		CHECK(c == Approx(-1.0 / std::sqrt(5)));
		line2.Coefficients(a, b, c);
		CHECK(a == Approx(1.0 / std::sqrt(5)));
		CHECK(b == Approx(-2.0 / std::sqrt(5)));
		CHECK(c == Approx(-1.0 / std::sqrt(5)));
		line3.Coefficients(a, b, c);
		CHECK(a == Approx(1.0 / std::sqrt(5)));
		CHECK(b == Approx(-2.0 / std::sqrt(5)));
		CHECK(c == Approx(-1.0 / std::sqrt(5)));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":void Coefficients(double& a, double& b, double& c)	 @param[out] a,b,c The coefficients
	 @brief The coefficients of the algebraic representation of the 2D line
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <math/LineT.hpp>
#include <modeling/MakeEdge2d.hpp>
using AMCAX::Line2;
#define ONE_RADIAN (M_PI / 180.)
#include <catch.hpp>
#include <testHelper.h>
#include <math/LineT.hpp>
#include <modeling/MakeEdge2d.hpp>
using AMCAX::Line2;
#define ONE_RADIAN (M_PI / 180.)
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] auto Distance(const Point2& p)	 @return The distance between the point and the line
	 @param p The point
	 @brief Compute the distance from a point to the line
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <math/LineT.hpp>
#include <modeling/MakeEdge2d.hpp>
using AMCAX::Line2;
#define ONE_RADIAN (M_PI / 180.)
TEST_CASE("case2: Line base method Test", "[math][Line2][p1]")
{
	SECTION("SetDirection")
	{
		Line2 line(Point2(), Direction2(1., 1.));  
		CHECK(line.Direction().IsEqual(Direction2(1., 1.), 1e-5 * ONE_RADIAN));
		CHECK(line.Distance(Point2(1., 2.)) > 0.);
		line.SetDirection(Direction2(1., 2.));  
		CHECK(line.Direction().IsEqual(Direction2(1., 2.), 1e-5 * ONE_RADIAN));
		CHECK(line.Distance(Point2(1., 2.)) == Approx(0.).margin(1e-5));
		double a, b, c;
		line.Coefficients(a, b, c);
		CHECK(a == Approx(2. / std::sqrt(5)).margin(1e-5));
		CHECK(b == Approx(-1. / std::sqrt(5)).margin(1e-5));
		CHECK(c == Approx(0. / std::sqrt(5)).margin(1e-5));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] auto SquaredDistance(const Point2& p)	 @return The squared distance between the point and the line
	 @param p The point
	 @brief Compute the squared distance from a point to the line
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <math/LineT.hpp>
#include <modeling/MakeEdge2d.hpp>
using AMCAX::Line2;
#define ONE_RADIAN (M_PI / 180.)
TEST_CASE("case1: Line basic interface test", "[math][Line2][p1]")
{
	SECTION("Distance and SquaredDistance test")
	{
		auto pointToLine = [](const Point2& point, const Line2& line) {
			double a, b, c;
			line.Coefficients(a, b, c);
			return std::fabs(a * point.X() + b * point.Y() + c);
		};
		auto lineToLine = [](const Line2& line1, const Line2& line2) {
			double a1, b1, c1, a2, b2, c2;
			line1.Coefficients(a1, b1, c1);
			line2.Coefficients(a2, b2, c2);
			if (a1 != a2 || b1 != b2) return 0.;
			return std::fabs(c1 - c2);
		};
		Line2 line(3., 4., -30.);
		Point2 point1(6., 3.);
		Point2 point2(6., 2.);
		Line2 line2(3., 4., -29.);
		Line2 line3(2., 1., -99.);
		CHECK(line.Distance(point1) == Approx(pointToLine(point1, line)).margin(0.01));
		CHECK(line.SquaredDistance(point1) == Approx(pointToLine(point1, line) * pointToLine(point1, line)).margin(0.01));
		CHECK(line.Distance(point2) == Approx(pointToLine(point2, line)));
		CHECK(line.SquaredDistance(point2) == Approx(pointToLine(point2, line) * pointToLine(point2, line)).margin(0.01));
		CHECK(line.Distance(line2) == Approx(lineToLine(line, line2)));
		CHECK(line.SquaredDistance(line2) == Approx(lineToLine(line2, line) * lineToLine(line2, line)).margin(0.01));
		CHECK(line.Distance(line3) == Approx(lineToLine(line, line3)));
		CHECK(line.SquaredDistance(line3) == Approx(lineToLine(line3, line) * lineToLine(line3, line)).margin(0.01));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] auto SquaredDistance(const LineS& l)	 @return The squared distance between two lines
	 @param l The other line
	 @brief Compute the squared distance between two lines
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <math/LineT.hpp>
#include <modeling/MakeEdge2d.hpp>
using AMCAX::Line2;
#define ONE_RADIAN (M_PI / 180.)
TEST_CASE("case1: Line basic interface test", "[math][Line2][p1]")
{
	SECTION("Distance and SquaredDistance test")
	{
		auto pointToLine = [](const Point2& point, const Line2& line) {
			double a, b, c;
			line.Coefficients(a, b, c);
			return std::fabs(a * point.X() + b * point.Y() + c);
		};
		auto lineToLine = [](const Line2& line1, const Line2& line2) {
			double a1, b1, c1, a2, b2, c2;
			line1.Coefficients(a1, b1, c1);
			line2.Coefficients(a2, b2, c2);
			if (a1 != a2 || b1 != b2) return 0.;
			return std::fabs(c1 - c2);
		};
		Line2 line(3., 4., -30.);
		Point2 point1(6., 3.);
		Point2 point2(6., 2.);
		Line2 line2(3., 4., -29.);
		Line2 line3(2., 1., -99.);
		CHECK(line.Distance(point1) == Approx(pointToLine(point1, line)).margin(0.01));
		CHECK(line.SquaredDistance(point1) == Approx(pointToLine(point1, line) * pointToLine(point1, line)).margin(0.01));
		CHECK(line.Distance(point2) == Approx(pointToLine(point2, line)));
		CHECK(line.SquaredDistance(point2) == Approx(pointToLine(point2, line) * pointToLine(point2, line)).margin(0.01));
		CHECK(line.Distance(line2) == Approx(lineToLine(line, line2)));
		CHECK(line.SquaredDistance(line2) == Approx(lineToLine(line2, line) * lineToLine(line2, line)).margin(0.01));
		CHECK(line.Distance(line3) == Approx(lineToLine(line, line3)));
		CHECK(line.SquaredDistance(line3) == Approx(lineToLine(line3, line) * lineToLine(line3, line)).margin(0.01));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] LineS Normal(const Point2& p)	 @return The line passing through a point and perpendicular to the line
	 @param p The point
	 @brief Get a line passing through a point and perpendicular to the line
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <math/LineT.hpp>
#include <modeling/MakeEdge2d.hpp>
using AMCAX::Line2;
#define ONE_RADIAN (M_PI / 180.)
TEST_CASE("case1: Line basic interface test", "[math][Line2][p1]")
{
	SECTION("Normal Test")
	{
		Line2 line(3., 4., 5.);  
		Line2 normalLine = line.Normal(Point2(1., 5.));
		double a, b, c;
		normalLine.Coefficients(a, b, c);
		CHECK((a * 3 + b * 4) == Approx(0.0).margin(0.1));
		CHECK((a * 1 + b * 5 + c) == Approx(0.0).margin(0.1));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":LineS& Rotate(const Point2& point, double angle)	 @return The reference to self
	 @param angle The rotation angle
	 @param point The rotation center point
	 @brief Rotate the line around a point with an angle in 2D
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <math/LineT.hpp>
#include <modeling/MakeEdge2d.hpp>
using AMCAX::Line2;
#define ONE_RADIAN (M_PI / 180.)
TEST_CASE("case1: Line basic interface test", "[math][Line2][p1]")
{
	SECTION("Rotate Test")
	{
		Line2 line(Point2(0., 1.), Direction2(1., 1.));  
		Line2 line2(Point2(0., 1.), Direction2(1., 1.));  
		line.Rotate(Point2(), (5. / 4) * M_PI);  
		CHECK(line.Direction().X() == Approx(0.).margin(1e-5));
		CHECK(line.Direction().Y() == Approx(-1.).margin(1e-5));
		double a, b, c;
		line.Coefficients(a, b, c);
		CHECK((a + c) == Approx(0.).margin(0.5));
		CHECK(line2.Distance(Point2()) == line.Distance(Point2()));  
		CHECK(line.Contains(Point2(std::sqrt(2.) / 2., 0.), 1e-6) == true);
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] LineS Rotated(const Point2& point, double angle)	 @return The rotated line
	 @param angle The rotation angle
	 @param point The rotation center point
	 @brief Get the line rotated around a point with an angle in 2D
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <math/LineT.hpp>
#include <modeling/MakeEdge2d.hpp>
using AMCAX::Line2;
#define ONE_RADIAN (M_PI / 180.)
TEST_CASE("case1: Line basic interface test", "[math][Line2][p1]")
{
	SECTION("Rotated Test")
	{
		Line2 line(Point2(0., 1.), Direction2(1., 1.));  
		Line2 rotateLine = line.Rotated(Point2(), (3. / 4) * M_PI);  
		CHECK(rotateLine.Direction().X() == Approx(-1.).margin(1e-5));
		CHECK(rotateLine.Direction().Y() == Approx(0.).margin(1e-5));
		double a, b, c;
		rotateLine.Coefficients(a, b, c);
		CHECK((c - b) == Approx(0.).margin(0.5));
		CHECK(line.Distance(Point2()) == rotateLine.Distance(Point2()));  
		TopoShape lineShape1 = MakeEdge2d(line);
		TopoShape lineShape2 = MakeEdge2d(rotateLine);
		REQUIRE(OCCTIO::OCCTTool::Write(lineShape1, OUTPUT_PATH_PREFIX"Line2_Rotated_before_p1.brep"));
		REQUIRE(OCCTIO::OCCTTool::Write(lineShape2, OUTPUT_PATH_PREFIX"Line2_Rotated_later_p1.brep"));
	}
}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] auto Distance(const Point3& p)	 @return The distance between the point and the line
	 @param p The point
	 @brief Compute the distance from a point to the line
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <math/LineT.hpp>
#include <modeling/MakeEdge2d.hpp>
using AMCAX::Line2;
#define ONE_RADIAN (M_PI / 180.)
TEST_CASE("case2: Line base method Test", "[math][Line2][p1]")
{
	SECTION("Scale")
	{
		Line2 line(Point2(0., -1.), Direction2());
		Point2 point;
		double distance = line.Distance(point);
		Line2 lineScale1 = line.Scaled(point, 1.1);
		CHECK(lineScale1.Distance(point) > distance);
		CHECK(lineScale1.Contains(Point2(0., -1.1), 1e-5));
		Line2 lineScale2 = line.Scaled(point, 1.);
		CHECK(lineScale2.Distance(point) == Approx(distance).margin(1e-5));
		CHECK(lineScale2.Contains(Point2(0., -1.), 1e-5));
		Line2 lineScale3 = line.Scaled(point, 0.8);
		CHECK(lineScale3.Distance(point) < distance);
		CHECK(lineScale3.Contains(Point2(0., -0.8), 1e-5));
		Line2 lineScale4 = line.Scaled(point, 0.);
		line.SetDirection(Direction2(-1.0, 4.0));
		Line2 lineScale5 = line.Scaled(Point2(-1., 2.), 0.);
		CHECK(lineScale4.Contains(Point2(0., 0.), 1e-5));
		CHECK(lineScale4.Direction().IsEqual(Direction2(), 1e-6 * ONE_RADIAN));
		CHECK(lineScale5.Contains(Point2(-1., 2.), 1e-5));
		CHECK(lineScale5.Direction().IsEqual(Direction2(-1., 4.), 1e-6 * ONE_RADIAN));
		Line2 lineScale6 = line.Scaled(point, -1.);
		CHECK(lineScale6.Direction().IsEqual(Direction2(1., -4.), 1e-5 * ONE_RADIAN));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] auto SquaredDistance(const Point3& p)	 @return The squared distance between the point and the line
	 @param p The point
	 @brief Compute the squared distance from a point to the line
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <math/LineT.hpp>
#include <modeling/MakeEdge2d.hpp>
using AMCAX::Line2;
#define ONE_RADIAN (M_PI / 180.)
TEST_CASE("case1: Line basic interface test", "[math][Line2][p1]")
{
	SECTION("Distance and SquaredDistance test")
	{
		auto pointToLine = [](const Point2& point, const Line2& line) {
			double a, b, c;
			line.Coefficients(a, b, c);
			return std::fabs(a * point.X() + b * point.Y() + c);
		};
		auto lineToLine = [](const Line2& line1, const Line2& line2) {
			double a1, b1, c1, a2, b2, c2;
			line1.Coefficients(a1, b1, c1);
			line2.Coefficients(a2, b2, c2);
			if (a1 != a2 || b1 != b2) return 0.;
			return std::fabs(c1 - c2);
		};
		Line2 line(3., 4., -30.);
		Point2 point1(6., 3.);
		Point2 point2(6., 2.);
		Line2 line2(3., 4., -29.);
		Line2 line3(2., 1., -99.);
		CHECK(line.Distance(point1) == Approx(pointToLine(point1, line)).margin(0.01));
		CHECK(line.SquaredDistance(point1) == Approx(pointToLine(point1, line) * pointToLine(point1, line)).margin(0.01));
		CHECK(line.Distance(point2) == Approx(pointToLine(point2, line)));
		CHECK(line.SquaredDistance(point2) == Approx(pointToLine(point2, line) * pointToLine(point2, line)).margin(0.01));
		CHECK(line.Distance(line2) == Approx(lineToLine(line, line2)));
		CHECK(line.SquaredDistance(line2) == Approx(lineToLine(line2, line) * lineToLine(line2, line)).margin(0.01));
		CHECK(line.Distance(line3) == Approx(lineToLine(line, line3)));
		CHECK(line.SquaredDistance(line3) == Approx(lineToLine(line3, line) * lineToLine(line3, line)).margin(0.01));
	}}
}
,
{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":void SetMajorRadius(double r)	 @param r The new major radius
	 @brief Set the major radius
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <modeling/MakeFace.hpp>
#include <common/AxisT.hpp>
#include <math/HyperbolaT.hpp>
#include <occtio/OCCTTool.hpp>
#include <common/VectorT.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <topology/TopoEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <iostream>
using namespace AMCAX;
using namespace std;
TEST_CASE("case1:this is a case for Hyperbola3", "[math][Hyperbola3][p1]") {
	Point3 point3_fr(0.0, 0.0, 1.0);
	Direction3 dir3_fr(0.0, 0.0, 1.0);
	Frame3 frame3(point3_fr, dir3_fr);
	double major3 = 3.0, minor3 = 4.0;
	Hyperbola3 hyperbola3d_fr(frame3, major3, minor3);
	SECTION("Default()") {
		Hyperbola3 hyperbola3d_de;	
		CHECK(hyperbola3d_de.Location().X() == Approx(0.0));
		CHECK(hyperbola3d_de.Location().Y() == Approx(0.0));
		CHECK(hyperbola3d_de.Location().Z() == Approx(0.0));
		hyperbola3d_de.SetMajorRadius(3.0);
		hyperbola3d_de.SetMinorRadius(4.0);
		CHECK(hyperbola3d_de.MajorRadius() == Approx(3.0));
		CHECK(hyperbola3d_de.MinorRadius() == Approx(4.0));
		CHECK(hyperbola3d_de.Focal() == Approx(10.0));
		CHECK(hyperbola3d_de.Focus1().X() == Approx(5.0));
		CHECK(hyperbola3d_de.Focus1().Y() == Approx(0.0));
		CHECK(hyperbola3d_de.Focus1().Z() == Approx(0.0));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":void SetMinorRadius(double r)	 @param r The new minor radius
	 @brief Set the minor radius
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <modeling/MakeFace.hpp>
#include <common/AxisT.hpp>
#include <math/HyperbolaT.hpp>
#include <occtio/OCCTTool.hpp>
#include <common/VectorT.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <topology/TopoEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <iostream>
using namespace AMCAX;
using namespace std;
TEST_CASE("case1:this is a case for Hyperbola3", "[math][Hyperbola3][p1]") {
	Point3 point3_fr(0.0, 0.0, 1.0);
	Direction3 dir3_fr(0.0, 0.0, 1.0);
	Frame3 frame3(point3_fr, dir3_fr);
	double major3 = 3.0, minor3 = 4.0;
	Hyperbola3 hyperbola3d_fr(frame3, major3, minor3);
	SECTION("SetMinorRadius()") {
		hyperbola3d_fr.SetMinorRadius(3.0);
		CHECK(hyperbola3d_fr.Location().X() == Approx(0.0));
		CHECK(hyperbola3d_fr.Location().Y() == Approx(0.0));
		CHECK(hyperbola3d_fr.MajorRadius() == Approx(3.0));
		CHECK(hyperbola3d_fr.MinorRadius() == Approx(3.0));
		Point3 point1(3.0, 0.0, 1.0);
		MakeEdge edge1(hyperbola3d_fr);
		CHECK(BRepClassificationTools::IsPointInOnEdge(edge1, point1, 0.001) == true);
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] AxisT<double, DIM> Directrix1()	 @return The positive directrix
	 @brief Get the directrix on the positive side of the major axis
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <modeling/MakeFace.hpp>
#include <common/AxisT.hpp>
#include <math/HyperbolaT.hpp>
#include <occtio/OCCTTool.hpp>
#include <common/VectorT.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <topology/TopoEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <iostream>
using namespace AMCAX;
using namespace std;
TEST_CASE("case1:this is a case for Hyperbola3", "[math][Hyperbola3][p1]") {
	Point3 point3_fr(0.0, 0.0, 1.0);
	Direction3 dir3_fr(0.0, 0.0, 1.0);
	Frame3 frame3(point3_fr, dir3_fr);
	double major3 = 3.0, minor3 = 4.0;
	Hyperbola3 hyperbola3d_fr(frame3, major3, minor3);
	SECTION("Directrix1()") {
		Axis3 axis3d_dir = hyperbola3d_fr.Directrix1();
		CHECK(axis3d_dir.Direction().X() == Approx(0.0));
		CHECK(axis3d_dir.Direction().Y() == Approx(1.0));
		CHECK(axis3d_dir.Direction().Z() == Approx(0.0));
		CHECK(axis3d_dir.Location().X() == Approx(9.0 / 5.0));
		CHECK(axis3d_dir.Location().Y() == Approx(0.0));
		CHECK(axis3d_dir.Location().Z() == Approx(1.0));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] AxisT<double, DIM> Directrix2()	 @return The negative directrix
	 @brief Get the directrix on the negative side of the major axis
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <modeling/MakeFace.hpp>
#include <common/AxisT.hpp>
#include <math/HyperbolaT.hpp>
#include <occtio/OCCTTool.hpp>
#include <common/VectorT.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <topology/TopoEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <iostream>
using namespace AMCAX;
using namespace std;
TEST_CASE("case1:this is a case for Hyperbola3", "[math][Hyperbola3][p1]") {
	Point3 point3_fr(0.0, 0.0, 1.0);
	Direction3 dir3_fr(0.0, 0.0, 1.0);
	Frame3 frame3(point3_fr, dir3_fr);
	double major3 = 3.0, minor3 = 4.0;
	Hyperbola3 hyperbola3d_fr(frame3, major3, minor3);
	SECTION("Directrix2()") {
		Axis3 axis3d_dir = hyperbola3d_fr.Directrix2();
		CHECK(axis3d_dir.Direction().X() == Approx(0.0));
		CHECK(axis3d_dir.Direction().Y() == Approx(1.0));
		CHECK(axis3d_dir.Direction().Z() == Approx(0.0));
		CHECK(axis3d_dir.Location().X() == Approx(-9.0 / 5.0));
		CHECK(axis3d_dir.Location().Y() == Approx(0.0));
		CHECK(axis3d_dir.Location().Z() == Approx(1.0));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] PointT<double, DIM> Focus1()	 @return The positive focus
	 @brief Get the focus on the positive side of the major axis
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <modeling/MakeFace.hpp>
#include <common/AxisT.hpp>
#include <math/HyperbolaT.hpp>
#include <occtio/OCCTTool.hpp>
#include <common/VectorT.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <topology/TopoEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <iostream>
using namespace AMCAX;
using namespace std;
TEST_CASE("case1:this is a case for Hyperbola3", "[math][Hyperbola3][p1]") {
	Point3 point3_fr(0.0, 0.0, 1.0);
	Direction3 dir3_fr(0.0, 0.0, 1.0);
	Frame3 frame3(point3_fr, dir3_fr);
	double major3 = 3.0, minor3 = 4.0;
	Hyperbola3 hyperbola3d_fr(frame3, major3, minor3);
	SECTION("Default()") {
		Hyperbola3 hyperbola3d_de;	
		CHECK(hyperbola3d_de.Location().X() == Approx(0.0));
		CHECK(hyperbola3d_de.Location().Y() == Approx(0.0));
		CHECK(hyperbola3d_de.Location().Z() == Approx(0.0));
		hyperbola3d_de.SetMajorRadius(3.0);
		hyperbola3d_de.SetMinorRadius(4.0);
		CHECK(hyperbola3d_de.MajorRadius() == Approx(3.0));
		CHECK(hyperbola3d_de.MinorRadius() == Approx(4.0));
		CHECK(hyperbola3d_de.Focal() == Approx(10.0));
		CHECK(hyperbola3d_de.Focus1().X() == Approx(5.0));
		CHECK(hyperbola3d_de.Focus1().Y() == Approx(0.0));
		CHECK(hyperbola3d_de.Focus1().Z() == Approx(0.0));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] PointT<double, DIM> Focus2()	 @return The negative focus
	 @brief Get the focus on the negative side of the major axis
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <modeling/MakeFace.hpp>
#include <common/AxisT.hpp>
#include <math/HyperbolaT.hpp>
#include <occtio/OCCTTool.hpp>
#include <common/VectorT.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <topology/TopoEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <iostream>
using namespace AMCAX;
using namespace std;
TEST_CASE("case1:this is a case for Hyperbola3", "[math][Hyperbola3][p1]") {
	Point3 point3_fr(0.0, 0.0, 1.0);
	Direction3 dir3_fr(0.0, 0.0, 1.0);
	Frame3 frame3(point3_fr, dir3_fr);
	double major3 = 3.0, minor3 = 4.0;
	Hyperbola3 hyperbola3d_fr(frame3, major3, minor3);
	SECTION("Focus2") {
		Point3 point3d_f1 = hyperbola3d_fr.Focus2();
		CHECK(point3d_f1.X() == Approx(-5.0));
		CHECK(point3d_f1.Y() == Approx(0.0));
		CHECK(point3d_f1.Z() == Approx(1.0));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] double MajorRadius()	 @return The major radius
	 @brief Get the major radius
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <modeling/MakeFace.hpp>
#include <common/AxisT.hpp>
#include <math/HyperbolaT.hpp>
#include <occtio/OCCTTool.hpp>
#include <common/VectorT.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <topology/TopoEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <iostream>
using namespace AMCAX;
using namespace std;
TEST_CASE("case1:this is a case for Hyperbola3", "[math][Hyperbola3][p1]") {
	Point3 point3_fr(0.0, 0.0, 1.0);
	Direction3 dir3_fr(0.0, 0.0, 1.0);
	Frame3 frame3(point3_fr, dir3_fr);
	double major3 = 3.0, minor3 = 4.0;
	Hyperbola3 hyperbola3d_fr(frame3, major3, minor3);
	SECTION("ConjugateBranch1()") {
		Hyperbola3 hyperbola3d_con = hyperbola3d_fr.ConjugateBranch1();
		CHECK(hyperbola3d_con.Location().X() == Approx(0.0));
		CHECK(hyperbola3d_con.Location().Y() == Approx(0.0));
		CHECK(hyperbola3d_con.Location().Z() == Approx(1.0));
		Point3 point1(0.0, 4.0, 1.0);
		Point3 point2(9.0 / 4.0, 5.0, 1.0);
		MakeEdge edge1(hyperbola3d_con);
		CHECK(BRepClassificationTools::IsPointInOnEdge(edge1, point1, 0.001) == true);
		CHECK(BRepClassificationTools::IsPointInOnEdge(edge1, point2, 0.001) == true);
		double major3d_con = hyperbola3d_con.MajorRadius();
		double minor3d_con = hyperbola3d_con.MinorRadius();
		CHECK(major3d_con == Approx(4.0));
		CHECK(minor3d_con == Approx(3.0));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] double MinorRadius()	 @return The minor radius
	 @brief Get the minor radius
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <modeling/MakeFace.hpp>
#include <common/AxisT.hpp>
#include <math/HyperbolaT.hpp>
#include <occtio/OCCTTool.hpp>
#include <common/VectorT.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <topology/TopoEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <iostream>
using namespace AMCAX;
using namespace std;
TEST_CASE("case1:this is a case for Hyperbola3", "[math][Hyperbola3][p1]") {
	Point3 point3_fr(0.0, 0.0, 1.0);
	Direction3 dir3_fr(0.0, 0.0, 1.0);
	Frame3 frame3(point3_fr, dir3_fr);
	double major3 = 3.0, minor3 = 4.0;
	Hyperbola3 hyperbola3d_fr(frame3, major3, minor3);
	SECTION("MinorRadius()") {
		CHECK(hyperbola3d_fr.MinorRadius() == Approx(4.0));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] AxisT<double, DIM> Asymptote1()	 @return The positive asymptote
	 @brief Get the asymptote of the hyperbola with positive slope
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <modeling/MakeFace.hpp>
#include <common/AxisT.hpp>
#include <math/HyperbolaT.hpp>
#include <occtio/OCCTTool.hpp>
#include <common/VectorT.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <topology/TopoEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <iostream>
using namespace AMCAX;
using namespace std;
TEST_CASE("case1:this is a case for Hyperbola3", "[math][Hyperbola3][p1]") {
	Point3 point3_fr(0.0, 0.0, 1.0);
	Direction3 dir3_fr(0.0, 0.0, 1.0);
	Frame3 frame3(point3_fr, dir3_fr);
	double major3 = 3.0, minor3 = 4.0;
	Hyperbola3 hyperbola3d_fr(frame3, major3, minor3);
	SECTION("Asymptote1()") {
		Axis3 axis3d_asy = hyperbola3d_fr.Asymptote1();
		CHECK(axis3d_asy.Direction().X() / axis3d_asy.Direction().Y() == Approx(3.0 / 4.0));
		CHECK(axis3d_asy.Direction().Z() == Approx(0.0));
		Point3 point1(0.0, 0.0, 1.0);
		Line3 line3d_asy(axis3d_asy);
		MakeEdge edge1(line3d_asy);
		CHECK(BRepClassificationTools::IsPointInOnEdge(edge1, point1, 0.001) == true);
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] AxisT<double, DIM> Asymptote2()	 @return The negative asymptote
	 @brief Get the asymptote of the hyperbola with negative slope
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <modeling/MakeFace.hpp>
#include <common/AxisT.hpp>
#include <math/HyperbolaT.hpp>
#include <occtio/OCCTTool.hpp>
#include <common/VectorT.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <topology/TopoEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <iostream>
using namespace AMCAX;
using namespace std;
TEST_CASE("case1:this is a case for Hyperbola3", "[math][Hyperbola3][p1]") {
	Point3 point3_fr(0.0, 0.0, 1.0);
	Direction3 dir3_fr(0.0, 0.0, 1.0);
	Frame3 frame3(point3_fr, dir3_fr);
	double major3 = 3.0, minor3 = 4.0;
	Hyperbola3 hyperbola3d_fr(frame3, major3, minor3);
	SECTION("Asymptote2()") {
		Axis3 axis3d_asy = hyperbola3d_fr.Asymptote2();
		CHECK(axis3d_asy.Direction().X() / axis3d_asy.Direction().Y() == Approx(-3.0 / 4.0));
		CHECK(axis3d_asy.Direction().Z() == Approx(0.0));
		Point3 point1(0.0, 0.0, 1.0);
		Line3 line3d_asy(axis3d_asy);
		MakeEdge edge1(line3d_asy);
		CHECK(BRepClassificationTools::IsPointInOnEdge(edge1, point1, 0.001) == true);
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] HyperbolaS ConjugateBranch1()	 @return The positive conjugate hyperbola
	 @brief Get the conjugate hyperbola on the positive side of the minor axis
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <modeling/MakeFace.hpp>
#include <common/AxisT.hpp>
#include <math/HyperbolaT.hpp>
#include <occtio/OCCTTool.hpp>
#include <common/VectorT.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <topology/TopoEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <iostream>
using namespace AMCAX;
using namespace std;
TEST_CASE("case1:this is a case for Hyperbola3", "[math][Hyperbola3][p1]") {
	Point3 point3_fr(0.0, 0.0, 1.0);
	Direction3 dir3_fr(0.0, 0.0, 1.0);
	Frame3 frame3(point3_fr, dir3_fr);
	double major3 = 3.0, minor3 = 4.0;
	Hyperbola3 hyperbola3d_fr(frame3, major3, minor3);
	SECTION("ConjugateBranch1()") {
		Hyperbola3 hyperbola3d_con = hyperbola3d_fr.ConjugateBranch1();
		CHECK(hyperbola3d_con.Location().X() == Approx(0.0));
		CHECK(hyperbola3d_con.Location().Y() == Approx(0.0));
		CHECK(hyperbola3d_con.Location().Z() == Approx(1.0));
		Point3 point1(0.0, 4.0, 1.0);
		Point3 point2(9.0 / 4.0, 5.0, 1.0);
		MakeEdge edge1(hyperbola3d_con);
		CHECK(BRepClassificationTools::IsPointInOnEdge(edge1, point1, 0.001) == true);
		CHECK(BRepClassificationTools::IsPointInOnEdge(edge1, point2, 0.001) == true);
		double major3d_con = hyperbola3d_con.MajorRadius();
		double minor3d_con = hyperbola3d_con.MinorRadius();
		CHECK(major3d_con == Approx(4.0));
		CHECK(minor3d_con == Approx(3.0));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] HyperbolaS ConjugateBranch2()	 @return The negative conjugate hyperbola
	 @brief Get the conjugate hyperbola on the negative side of the minor axis
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <modeling/MakeFace.hpp>
#include <common/AxisT.hpp>
#include <math/HyperbolaT.hpp>
#include <occtio/OCCTTool.hpp>
#include <common/VectorT.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <topology/TopoEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <iostream>
using namespace AMCAX;
using namespace std;
TEST_CASE("case1:this is a case for Hyperbola3", "[math][Hyperbola3][p1]") {
	Point3 point3_fr(0.0, 0.0, 1.0);
	Direction3 dir3_fr(0.0, 0.0, 1.0);
	Frame3 frame3(point3_fr, dir3_fr);
	double major3 = 3.0, minor3 = 4.0;
	Hyperbola3 hyperbola3d_fr(frame3, major3, minor3);
	SECTION("ConjugateBranch2()") {		
		Hyperbola3 hyperbola3d_con = hyperbola3d_fr.ConjugateBranch2();
		CHECK(hyperbola3d_con.Location().X() == Approx(0.0));
		CHECK(hyperbola3d_con.Location().Y() == Approx(0.0));
		CHECK(hyperbola3d_con.Location().Z() == Approx(1.0));
		Point3 point1(0.0, -4.0, 1.0);
		Point3 point2(9.0 / 4.0, -5.0, 1.0);
		MakeEdge edge2(hyperbola3d_con);
		CHECK(BRepClassificationTools::IsPointInOnEdge(edge2, point1, 0.001) == true);
		CHECK(BRepClassificationTools::IsPointInOnEdge(edge2, point2, 0.001) == true);
		double major3d_con = hyperbola3d_con.MajorRadius();
		double minor3d_con = hyperbola3d_con.MinorRadius();
		CHECK(major3d_con == Approx(4.0));
		CHECK(minor3d_con == Approx(3.0));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":HyperbolaS& Scale(const PointT<double, DIM>& point, double scale)	 @return The reference to self
	 @param scale The scale value
	 @param point The scaling center point
	 @brief Scale the hyperbola by a center point
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <modeling/MakeFace.hpp>
#include <common/AxisT.hpp>
#include <math/HyperbolaT.hpp>
#include <occtio/OCCTTool.hpp>
#include <common/VectorT.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <topology/TopoEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <iostream>
using namespace AMCAX;
using namespace std;
TEST_CASE("case1:this is a case for Hyperbola3", "[math][Hyperbola3][p1]") {
	Point3 point3_fr(0.0, 0.0, 1.0);
	Direction3 dir3_fr(0.0, 0.0, 1.0);
	Frame3 frame3(point3_fr, dir3_fr);
	double major3 = 3.0, minor3 = 4.0;
	Hyperbola3 hyperbola3d_fr(frame3, major3, minor3);
	SECTION("Scale()") {		
		Point3 point1(0.0, 0.0, 1.0);
		hyperbola3d_fr.Scale(point1, 0.5);
		CHECK(hyperbola3d_fr.Location().X() == Approx(0.0));
		CHECK(hyperbola3d_fr.Location().Y() == Approx(0.0));
		CHECK(hyperbola3d_fr.Location().Z() == Approx(1.0));
		Point3 point2(1.5, 0.0, 1.0);
		MakeEdge edge1(hyperbola3d_fr);
		CHECK(BRepClassificationTools::IsPointInOnEdge(edge1, point2, 0.001) == true);
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] AMCAX_API static Vector2 D1(double u, const Circle2& circle)	 @return The first derivative vector
	 @param circle The circle
	 @param u The parameter
	 @brief Compute the first derivative on a 2D circle at a parameter
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
using namespace AMCAX;
TEST_CASE("case1: CurveCalculation::CircleD1 1/4 ", "[math][CurveCalculation][P1][CircleD1]") {
	Direction2 initialDir(1.0, 0.0); 
	Frame2 defaultFrame2(Point2(1.0, 1.0), initialDir); 
	double radius = 2.0; 
	Vector2 tangentAt0 = AMCAX::CurveCalculation::CircleD1(0.0, defaultFrame2, radius);
	Vector2 tangentAt90Deg = AMCAX::CurveCalculation::CircleD1(M_PI_2, defaultFrame2, radius);
	Vector2 tangentAt180Deg = AMCAX::CurveCalculation::CircleD1(M_PI, defaultFrame2, radius);
	Vector2 tangentAt270Deg = AMCAX::CurveCalculation::CircleD1(3 * M_PI_2, defaultFrame2, radius);
	Vector2 tangentAt360Deg = AMCAX::CurveCalculation::CircleD1(2 * M_PI, defaultFrame2, radius);
	CHECK(tangentAt0.X() == Approx(-0.0));
	CHECK(tangentAt0.Y() == Approx(2.0));
	CHECK(tangentAt90Deg.X() == Approx(-2.0));
	CHECK(tangentAt90Deg.Y() == Approx(0.0).margin(1e-14));
	CHECK(tangentAt180Deg.X() == Approx(-0.0).margin(1e-14));
	CHECK(tangentAt180Deg.Y() == Approx(-2.0));
	CHECK(tangentAt270Deg.X() == Approx(2.0));
	CHECK(tangentAt270Deg.Y() == Approx(-0.0).margin(1e-14));
	CHECK(tangentAt360Deg.X() == Approx(0.0).margin(1e-14));
	CHECK(tangentAt360Deg.Y() == Approx(2.0));
	std::cout << "Tangent at 0 deg: " << tangentAt0 << std::endl;
	std::cout << "Tangent at 90 deg: " << tangentAt90Deg << std::endl;
	std::cout << "Tangent at 180 deg: " << tangentAt180Deg << std::endl;
	std::cout << "Tangent at 270 deg: " << tangentAt270Deg << std::endl;
	std::cout << "Tangent at 360 deg: " << tangentAt360Deg << std::endl;
}
}
,
{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":void SetMajorRadius(double r)	 @param r The new major radius
	 @brief Set the major radius
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <modeling/MakeFace.hpp>
#include <common/AxisT.hpp>
#include <math/HyperbolaT.hpp>
#include <occtio/OCCTTool.hpp>
#include <common/VectorT.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <topology/TopoEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <common/TransformationT.hpp>
#include <iostream>
using namespace AMCAX;
using namespace std;
TEST_CASE("case1:this is a case for Hyperbola2", "[math][Hyperbola2][p1]") {
	Point2 point2_Hy(0.0, 0.0);	
	Direction2 dir2_Hy(1.0, 0.0);
	Axis2 major2_Axis(point2_Hy, dir2_Hy);
	double major2 = 3.0, minor2 = 4.0;
	Hyperbola2 hyperbola2d_ax(major2_Axis, major2, minor2, true);
	Point2 point2_fr(1.0, 1.0);
	Direction2 dir2_fr(0.0, 1.0);
	Frame2 frame2(point2_fr, dir2_fr);
	Hyperbola2 hyperbola2d_fr(frame2, major2, minor2);
	SECTION("Default()") {
		Hyperbola2 hyperbola2d_de;	
		CHECK(hyperbola2d_de.Location().X() == Approx(0.0));
		CHECK(hyperbola2d_de.Location().Y() == Approx(0.0));
		hyperbola2d_de.SetMajorRadius(3.0);
		hyperbola2d_de.SetMinorRadius(4.0);
		CHECK(hyperbola2d_de.MajorRadius() == Approx(3.0));
		CHECK(hyperbola2d_de.MinorRadius() == Approx(4.0));
		CHECK(hyperbola2d_de.Focal() == Approx(10.0));
		CHECK(hyperbola2d_de.Focus1().X() == Approx(5.0));
		CHECK(hyperbola2d_de.Focus1().Y() == Approx(0.0));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":void SetMinorRadius(double r)	 @param r The new minor radius
	 @brief Set the minor radius
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <modeling/MakeFace.hpp>
#include <common/AxisT.hpp>
#include <math/HyperbolaT.hpp>
#include <occtio/OCCTTool.hpp>
#include <common/VectorT.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <topology/TopoEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <common/TransformationT.hpp>
#include <iostream>
using namespace AMCAX;
using namespace std;
TEST_CASE("case1:this is a case for Hyperbola2", "[math][Hyperbola2][p1]") {
	Point2 point2_Hy(0.0, 0.0);	
	Direction2 dir2_Hy(1.0, 0.0);
	Axis2 major2_Axis(point2_Hy, dir2_Hy);
	double major2 = 3.0, minor2 = 4.0;
	Hyperbola2 hyperbola2d_ax(major2_Axis, major2, minor2, true);
	Point2 point2_fr(1.0, 1.0);
	Direction2 dir2_fr(0.0, 1.0);
	Frame2 frame2(point2_fr, dir2_fr);
	Hyperbola2 hyperbola2d_fr(frame2, major2, minor2);
	SECTION("SetMinorRadius()") {
		hyperbola2d_ax.SetMinorRadius(3.0);
		CHECK(hyperbola2d_ax.Location().X() == Approx(0.0));
		CHECK(hyperbola2d_ax.Location().Y() == Approx(0.0));
		CHECK(hyperbola2d_ax.MajorRadius() == Approx(3.0));
		CHECK(hyperbola2d_ax.MinorRadius() == Approx(3.0));
		Point3 point1(3.0, 0.0, 0.0);
		MakeEdge2d edge1(hyperbola2d_ax);
		CHECK(BRepClassificationTools::IsPointInOnEdge(edge1, point1, 0.001) == true);
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] PointT<double, DIM> Focus1()	 @return The positive focus
	 @brief Get the focus on the positive side of the major axis
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <modeling/MakeFace.hpp>
#include <common/AxisT.hpp>
#include <math/HyperbolaT.hpp>
#include <occtio/OCCTTool.hpp>
#include <common/VectorT.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <topology/TopoEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <common/TransformationT.hpp>
#include <iostream>
using namespace AMCAX;
using namespace std;
TEST_CASE("case1:this is a case for Hyperbola2", "[math][Hyperbola2][p1]") {
	Point2 point2_Hy(0.0, 0.0);	
	Direction2 dir2_Hy(1.0, 0.0);
	Axis2 major2_Axis(point2_Hy, dir2_Hy);
	double major2 = 3.0, minor2 = 4.0;
	Hyperbola2 hyperbola2d_ax(major2_Axis, major2, minor2, true);
	Point2 point2_fr(1.0, 1.0);
	Direction2 dir2_fr(0.0, 1.0);
	Frame2 frame2(point2_fr, dir2_fr);
	Hyperbola2 hyperbola2d_fr(frame2, major2, minor2);
	SECTION("Default()") {
		Hyperbola2 hyperbola2d_de;	
		CHECK(hyperbola2d_de.Location().X() == Approx(0.0));
		CHECK(hyperbola2d_de.Location().Y() == Approx(0.0));
		hyperbola2d_de.SetMajorRadius(3.0);
		hyperbola2d_de.SetMinorRadius(4.0);
		CHECK(hyperbola2d_de.MajorRadius() == Approx(3.0));
		CHECK(hyperbola2d_de.MinorRadius() == Approx(4.0));
		CHECK(hyperbola2d_de.Focal() == Approx(10.0));
		CHECK(hyperbola2d_de.Focus1().X() == Approx(5.0));
		CHECK(hyperbola2d_de.Focus1().Y() == Approx(0.0));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] double MajorRadius()	 @return The major radius
	 @brief Get the major radius
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <modeling/MakeFace.hpp>
#include <common/AxisT.hpp>
#include <math/HyperbolaT.hpp>
#include <occtio/OCCTTool.hpp>
#include <common/VectorT.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <topology/TopoEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <common/TransformationT.hpp>
#include <iostream>
using namespace AMCAX;
using namespace std;
TEST_CASE("case1:this is a case for Hyperbola2", "[math][Hyperbola2][p1]") {
	Point2 point2_Hy(0.0, 0.0);	
	Direction2 dir2_Hy(1.0, 0.0);
	Axis2 major2_Axis(point2_Hy, dir2_Hy);
	double major2 = 3.0, minor2 = 4.0;
	Hyperbola2 hyperbola2d_ax(major2_Axis, major2, minor2, true);
	Point2 point2_fr(1.0, 1.0);
	Direction2 dir2_fr(0.0, 1.0);
	Frame2 frame2(point2_fr, dir2_fr);
	Hyperbola2 hyperbola2d_fr(frame2, major2, minor2);
	SECTION("Default()") {
		Hyperbola2 hyperbola2d_de;	
		CHECK(hyperbola2d_de.Location().X() == Approx(0.0));
		CHECK(hyperbola2d_de.Location().Y() == Approx(0.0));
		hyperbola2d_de.SetMajorRadius(3.0);
		hyperbola2d_de.SetMinorRadius(4.0);
		CHECK(hyperbola2d_de.MajorRadius() == Approx(3.0));
		CHECK(hyperbola2d_de.MinorRadius() == Approx(4.0));
		CHECK(hyperbola2d_de.Focal() == Approx(10.0));
		CHECK(hyperbola2d_de.Focus1().X() == Approx(5.0));
		CHECK(hyperbola2d_de.Focus1().Y() == Approx(0.0));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] double MinorRadius()	 @return The minor radius
	 @brief Get the minor radius
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <modeling/MakeFace.hpp>
#include <common/AxisT.hpp>
#include <math/HyperbolaT.hpp>
#include <occtio/OCCTTool.hpp>
#include <common/VectorT.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <topology/TopoEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <common/TransformationT.hpp>
#include <iostream>
using namespace AMCAX;
using namespace std;
TEST_CASE("case1:this is a case for Hyperbola2", "[math][Hyperbola2][p1]") {
	Point2 point2_Hy(0.0, 0.0);	
	Direction2 dir2_Hy(1.0, 0.0);
	Axis2 major2_Axis(point2_Hy, dir2_Hy);
	double major2 = 3.0, minor2 = 4.0;
	Hyperbola2 hyperbola2d_ax(major2_Axis, major2, minor2, true);
	Point2 point2_fr(1.0, 1.0);
	Direction2 dir2_fr(0.0, 1.0);
	Frame2 frame2(point2_fr, dir2_fr);
	Hyperbola2 hyperbola2d_fr(frame2, major2, minor2);
	SECTION("ConjugateBranch1()") {
		Point3 point1(0.0, 4.0, 0.0);
		Point3 point2(9.0 / 4.0, 5.0, 0.0);
		Hyperbola2 hyperbola2d_con = hyperbola2d_ax.ConjugateBranch1();
		MakeEdge2d edge1(hyperbola2d_con);
		CHECK(BRepClassificationTools::IsPointInOnEdge(edge1, point1, 0.001) == true);
		CHECK(BRepClassificationTools::IsPointInOnEdge(edge1, point2, 0.001) == true);
		double major2d_con = hyperbola2d_con.MajorRadius();
		double minor2d_con = hyperbola2d_con.MinorRadius();
		CHECK( major2d_con== Approx(4.0));
		CHECK(minor2d_con == Approx(3.0));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] AxisT<double, DIM> Asymptote1()	 @return The positive asymptote
	 @brief Get the asymptote of the hyperbola with positive slope
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <modeling/MakeFace.hpp>
#include <common/AxisT.hpp>
#include <math/HyperbolaT.hpp>
#include <occtio/OCCTTool.hpp>
#include <common/VectorT.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <topology/TopoEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <common/TransformationT.hpp>
#include <iostream>
using namespace AMCAX;
using namespace std;
TEST_CASE("case1:this is a case for Hyperbola2", "[math][Hyperbola2][p1]") {
	Point2 point2_Hy(0.0, 0.0);	
	Direction2 dir2_Hy(1.0, 0.0);
	Axis2 major2_Axis(point2_Hy, dir2_Hy);
	double major2 = 3.0, minor2 = 4.0;
	Hyperbola2 hyperbola2d_ax(major2_Axis, major2, minor2, true);
	Point2 point2_fr(1.0, 1.0);
	Direction2 dir2_fr(0.0, 1.0);
	Frame2 frame2(point2_fr, dir2_fr);
	Hyperbola2 hyperbola2d_fr(frame2, major2, minor2);
	SECTION("Asymptote1()") {
		Axis2 axis2d_asy = hyperbola2d_ax.Asymptote1();
		CHECK(axis2d_asy.Direction().X()/ axis2d_asy.Direction().Y() == Approx(3.0/4.0));
		Point3 point1(0.0, 0.0, 0.0);
		Line2 line2d_asy(axis2d_asy);
		MakeEdge2d edge1(line2d_asy);
		CHECK(BRepClassificationTools::IsPointInOnEdge(edge1, point1, 0.001) == true);
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] AxisT<double, DIM> Asymptote2()	 @return The negative asymptote
	 @brief Get the asymptote of the hyperbola with negative slope
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <modeling/MakeFace.hpp>
#include <common/AxisT.hpp>
#include <math/HyperbolaT.hpp>
#include <occtio/OCCTTool.hpp>
#include <common/VectorT.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <topology/TopoEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <common/TransformationT.hpp>
#include <iostream>
using namespace AMCAX;
using namespace std;
TEST_CASE("case1:this is a case for Hyperbola2", "[math][Hyperbola2][p1]") {
	Point2 point2_Hy(0.0, 0.0);	
	Direction2 dir2_Hy(1.0, 0.0);
	Axis2 major2_Axis(point2_Hy, dir2_Hy);
	double major2 = 3.0, minor2 = 4.0;
	Hyperbola2 hyperbola2d_ax(major2_Axis, major2, minor2, true);
	Point2 point2_fr(1.0, 1.0);
	Direction2 dir2_fr(0.0, 1.0);
	Frame2 frame2(point2_fr, dir2_fr);
	Hyperbola2 hyperbola2d_fr(frame2, major2, minor2);
	SECTION("Asymptote2()") {	
		Axis2 axis2d_asy = hyperbola2d_ax.Asymptote2();
		CHECK(axis2d_asy.Direction().X() / axis2d_asy.Direction().Y() == Approx(-3.0 / 4.0));
		Point3 point1(0.0, 0.0, 0.0);
		Line2 line2d_asy(axis2d_asy);
		MakeEdge2d edge1(line2d_asy);
		CHECK(BRepClassificationTools::IsPointInOnEdge(edge1, point1, 0.001) == true);
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] HyperbolaS ConjugateBranch2()	 @return The negative conjugate hyperbola
	 @brief Get the conjugate hyperbola on the negative side of the minor axis
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <modeling/MakeFace.hpp>
#include <common/AxisT.hpp>
#include <math/HyperbolaT.hpp>
#include <occtio/OCCTTool.hpp>
#include <common/VectorT.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <topology/TopoEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <common/TransformationT.hpp>
#include <iostream>
using namespace AMCAX;
using namespace std;
TEST_CASE("case1:this is a case for Hyperbola2", "[math][Hyperbola2][p1]") {
	Point2 point2_Hy(0.0, 0.0);	
	Direction2 dir2_Hy(1.0, 0.0);
	Axis2 major2_Axis(point2_Hy, dir2_Hy);
	double major2 = 3.0, minor2 = 4.0;
	Hyperbola2 hyperbola2d_ax(major2_Axis, major2, minor2, true);
	Point2 point2_fr(1.0, 1.0);
	Direction2 dir2_fr(0.0, 1.0);
	Frame2 frame2(point2_fr, dir2_fr);
	Hyperbola2 hyperbola2d_fr(frame2, major2, minor2);
	SECTION("ConjugateBranch2()") {
		Point3 point1(0.0, -4.0, 0.0);
		Point3 point2(9.0 / 4.0, -5.0, 0.0);
		Hyperbola2 hyperbola2d_con = hyperbola2d_ax.ConjugateBranch2();
		MakeEdge2d edge1(hyperbola2d_con);
		CHECK(BRepClassificationTools::IsPointInOnEdge(edge1, point1, 0.001) == true);
		CHECK(BRepClassificationTools::IsPointInOnEdge(edge1, point2, 0.001) == true);
		double major2d_con = hyperbola2d_con.MajorRadius();
		double minor2d_con = hyperbola2d_con.MinorRadius();
		CHECK(major2d_con == Approx(4.0));
		CHECK(minor2d_con == Approx(3.0));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":HyperbolaS& Scale(const PointT<double, DIM>& point, double scale)	 @return The reference to self
	 @param scale The scale value
	 @param point The scaling center point
	 @brief Scale the hyperbola by a center point
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <modeling/MakeFace.hpp>
#include <common/AxisT.hpp>
#include <math/HyperbolaT.hpp>
#include <occtio/OCCTTool.hpp>
#include <common/VectorT.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <topology/TopoEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <common/TransformationT.hpp>
#include <iostream>
using namespace AMCAX;
using namespace std;
TEST_CASE("case1:this is a case for Hyperbola2", "[math][Hyperbola2][p1]") {
	Point2 point2_Hy(0.0, 0.0);	
	Direction2 dir2_Hy(1.0, 0.0);
	Axis2 major2_Axis(point2_Hy, dir2_Hy);
	double major2 = 3.0, minor2 = 4.0;
	Hyperbola2 hyperbola2d_ax(major2_Axis, major2, minor2, true);
	Point2 point2_fr(1.0, 1.0);
	Direction2 dir2_fr(0.0, 1.0);
	Frame2 frame2(point2_fr, dir2_fr);
	Hyperbola2 hyperbola2d_fr(frame2, major2, minor2);
	SECTION("Scale()") {		
		Point2 point2(1.0, 1.0);
		hyperbola2d_ax.Scale(point2, 0.5);
		CHECK(hyperbola2d_ax.Location().X() == Approx(0.5));
		CHECK(hyperbola2d_ax.Location().Y() == Approx(0.5));
		Point3 point3(2.0, 0.5, 0.0);
		MakeEdge2d edge1(hyperbola2d_ax);
		CHECK(BRepClassificationTools::IsPointInOnEdge(edge1, point3, 0.001) == true);
	}}
}
,
{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] double Area()	 @return The area of the ellipse
	 @brief Get the area of the ellipse
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <common/FrameT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <math/EllipseT.hpp>
using namespace AMCAX;
using namespace std;
TEST_CASE("case1:this is a case for Test Ellipse3", "[math][Ellipse3][P1]")
{
	Frame3 frame;
	double major = 5.0;
	double minor = 4.0;
	Ellipse3 ellipse(frame, major, minor);
	SECTION("Area")
	{
		double S = ellipse.Area();
		CHECK(S == Approx(M_PI * major * minor));
	}}
}
,
{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] double Area()	 @return The area of the ellipse
	 @brief Get the area of the ellipse
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <common/FrameT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <math/EllipseT.hpp>
using namespace AMCAX;
using namespace std;
TEST_CASE("case1:this is a case for Test Ellipse2", "[math][Ellipse2][P1]")
{
	Axis2 axis;
	double major = 5.0;
	double minor = 4.0;
	bool isRight = true;
	Ellipse2 ellipse(axis, major, minor, isRight);
	SECTION("Area")
	{
		double S = ellipse.Area();
		CHECK(S == Approx(M_PI * major * minor));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":EllipseS& Scale(const PointT<double, DIM>& point, double scale)	 @return The reference to self
	 @param scale The scale value
	 @param point The scaling center point
	 @brief Scale the ellipse by a center point
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <common/FrameT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <math/EllipseT.hpp>
using namespace AMCAX;
using namespace std;
TEST_CASE("case3:this is a case for Test-Ellipse2-Rotate", "[math][Ellipse2][P1]")
{
	Point2 point1(6.0, 0.0);
	Direction2 dir1(0.0, 1.0);
	Axis2 axis1(point1, dir1);
	double major = 5.0;
	double minor = 4.0;
	bool isRight = true;
	Ellipse2 ellipse(axis1, major, minor, isRight);
	double angle = M_PI_2;
	Point2 point_temp(0.0, 0.0);
	SECTION("Scale")
	{
		Ellipse2 scale_ellipse = ellipse.Scale(point, scale);
		CHECK(ellipse.Location().X() == Approx(2.5));
		CHECK(ellipse.Location().Y() == Approx(-1.0));
		CHECK(ellipse.MajorRadius() == Approx(2.5));
		CHECK(ellipse.MinorRadius() == Approx(2.0));
		CHECK(scale_ellipse.Location().X() == Approx(2.5));
		CHECK(scale_ellipse.Location().Y() == Approx(-1.0));
		CHECK(scale_ellipse.MajorRadius() == Approx(2.5));
		CHECK(scale_ellipse.MinorRadius() == Approx(2.0));
	}
	scale = -2.0;}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":EllipseS& Transform(const TransformationT<double, DIM>& tr)	 @return The reference to self
	 @param tr The transformation
	 @brief Transform the ellipse
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <common/FrameT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <math/EllipseT.hpp>
using namespace AMCAX;
using namespace std;
TEST_CASE("case3:this is a case for Test-Ellipse2-Rotate", "[math][Ellipse2][P1]")
{
	Point2 point1(6.0, 0.0);
	Direction2 dir1(0.0, 1.0);
	Axis2 axis1(point1, dir1);
	double major = 5.0;
	double minor = 4.0;
	bool isRight = true;
	Ellipse2 ellipse(axis1, major, minor, isRight);
	double angle = M_PI_2;
	Point2 point_temp(0.0, 0.0);
	SECTION("Transform")
	{
		Ellipse2 Transfor_ellipse = ellipse.Transform(tr);
		CHECK(ellipse.Location().X() == Approx(5.0));
		CHECK(ellipse.Location().Y() == Approx(-2.0));
		CHECK(ellipse.MajorRadius() == Approx(5.0));
		CHECK(ellipse.MinorRadius() == Approx(4.0));
		CHECK(Transfor_ellipse.Location().X() == Approx(5.0));
		CHECK(Transfor_ellipse.Location().Y() == Approx(-2.0));
		CHECK(Transfor_ellipse.MajorRadius() == Approx(5.0));
		CHECK(Transfor_ellipse.MinorRadius() == Approx(4.0));
	}}
}
,
{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":Cylinder()	 @brief Default constructor
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <common/FrameT.hpp>
#include <modeling/MakeFace.hpp>
#include <common/AxisT.hpp>
#include <math/Cylinder.hpp>
#include <common/VectorT.hpp>
#include <occtio/OCCTTool.hpp>
#include <modeling/MakeCylinder.hpp>
#include <iostream>
using namespace AMCAX;
using namespace std;
TEST_CASE("case1:this is a case for Test Cylinder", "[math][Cylinder][P1]")
{
	Frame3 frame;
	double radius = 5.0;
	Cylinder cylinder(frame, radius);
	SECTION("Cylinder")
	{
		CHECK(cylinder.Radius() == Approx(radius));
		CHECK(cylinder.Location().X() == Approx(0.0));
		CHECK(cylinder.Location().Y() == Approx(0.0));
		CHECK(cylinder.Location().Z() == Approx(0.0));
		Cylinder cylinder1;
		CHECK(cylinder1.Location().X() == Approx(0.0));
		CHECK(cylinder1.Location().Y() == Approx(0.0));
		CHECK(cylinder1.Location().Z() == Approx(0.0));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API Cylinder(const Frame3& frame, double r)	 @param r The radius
	 @param frame The local frame
	 @brief Construct from a local frame and a radius
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <common/FrameT.hpp>
#include <modeling/MakeFace.hpp>
#include <common/AxisT.hpp>
#include <math/Cylinder.hpp>
#include <common/VectorT.hpp>
#include <occtio/OCCTTool.hpp>
#include <modeling/MakeCylinder.hpp>
#include <iostream>
using namespace AMCAX;
using namespace std;
TEST_CASE("bug1:Cylinder ", "[math][Cylinder][fixbug]")
{
	Point3 point_cy(6.0, 0.0, 0.0);
	Direction3 dir_cy(0.0, 0.0, 1.0);
	Frame3 frame_cy(point_cy, dir_cy);
	double radius_cy = 5.0;
	Cylinder cylinder(frame_cy, radius_cy);
	double r = 0.0;
	SECTION("SetRadius1")
	{
		cylinder.SetRadius(r);
		CHECK(cylinder.Radius() == Approx(0.0));
	}
	r = -1.0;
	string str1;
	string str2 = "[_DomainError]";}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API Cylinder& Scale(const Point3& point, double scale)	 @return The reference to self
	 @param scale The scale value
	 @param point The scaling center point
	 @brief Scale the cylinder by a point
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <common/FrameT.hpp>
#include <modeling/MakeFace.hpp>
#include <common/AxisT.hpp>
#include <math/Cylinder.hpp>
#include <common/VectorT.hpp>
#include <occtio/OCCTTool.hpp>
#include <modeling/MakeCylinder.hpp>
#include <iostream>
using namespace AMCAX;
using namespace std;
TEST_CASE("case2:this is a case for Test Cylinder_Mirror&Mirrored/Rotate&Rotated/Scale&Scaled", "[math][Cylinder][P1]")
{
	Point3 point_cy(6.0, 0.0, 0.0);
	Direction3 dir_cy(0.0, 0.0, 1.0);
	Frame3 frame_cy(point_cy, dir_cy);
	double radius_cy = 5.0;
	Cylinder cylinder(frame_cy, radius_cy);
	SECTION("Scale")
	{
		Cylinder scale_cylinder = cylinder.Scale(point_cy, scale);
		CHECK(cylinder.Radius() == Approx(2.5));
		CHECK(cylinder.Location().X() == Approx(6.0));
		CHECK(cylinder.Location().Y() == Approx(0.0));
		CHECK(cylinder.Location().Z() == Approx(0.0));
		CHECK(cylinder.Axis().Direction().X() == 0.0);
		CHECK(cylinder.Axis().Direction().Y() == 0.0);
		CHECK(cylinder.Axis().Direction().Z() == 1.0);
		CHECK(scale_cylinder.Radius() == Approx(2.5));
		CHECK(scale_cylinder.Location().X() == Approx(6.0));
		CHECK(scale_cylinder.Location().Y() == Approx(0.0));
		CHECK(scale_cylinder.Location().Z() == Approx(0.0));
		CHECK(scale_cylinder.Axis().Direction().X() == 0.0);
		CHECK(scale_cylinder.Axis().Direction().Y() == 0.0);
		CHECK(scale_cylinder.Axis().Direction().Z() == 1.0);
	}
	scale = 2.0;}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static void AdjustPeriodic(double ufirst, double ulast, double precision, double& u1, double& u2)	 @param[in,out] u2 The second parameter to be adjust
	 @param[in,out] u1 The first parameter to be adjust
	 @param[in] precision The precision to check equality
	 @param[in] ulast The upper bound of the period
	 @param[in] ufirst The lower bound of the period
	          The parameter u2 is set in the range [u1, u1 + ulast - ufirst]
	 @details The parameter u1 is set in the range [ufirst, ulast]
	 @brief Adjust u1 and u2 to be in the period range.
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
using namespace AMCAX;
TEST_CASE("case1: CurveCalculation::AdjustPeriodic ", "[math][CurveCalculation][P1]") {
	double u1 = 0.0;
	double u2 = 2 * M_PI;
	double ufirst = 0.0;
	double ulast = 2 * M_PI; 
	double precision = 0.001; 
	AMCAX::CurveCalculation::AdjustPeriodic(ufirst, ulast, precision, u1, u2);
	CHECK(u1 == 0);
	CHECK(u2 == 2 * M_PI);
}
}
,
{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] AMCAX_API static Point3 D0(double u, const Line3& line)	 @return The resulting point
	 @param line The line
	 @param u The parameter
	 @brief Compute the point on a 3D line at a parameter
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
#include <occtio/OCCTTool.hpp>
#include <geometry/MakeArcOfHyperbola2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeEdge2d.hpp>
using namespace AMCAX;
TEST_CASE("case1: CurveCalculation::D0() [6/10] ", "[math][CurveCalculation][P1][D0]") {
	Frame3 fram3;
	double major_radius = 1000.0;
	double minor_radius = 10.0;
	Hyperbola3 hyperbola(fram3, major_radius, minor_radius);
	Point3 point3 = CurveCalculation::D0(0.0, hyperbola);
	CHECK(point3.X() == 1000.0);
	CHECK(point3.Y() == 0.0);
	CHECK(point3.Z() == 0.0);
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] AMCAX_API static Point3 D0(double u, const Circle3& circle)	 @return The resulting point
	 @param circle The circle
	 @param u The parameter
	 @brief Compute the point on a 3D circle at a parameter
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
#include <occtio/OCCTTool.hpp>
#include <geometry/MakeArcOfHyperbola2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeEdge2d.hpp>
using namespace AMCAX;
TEST_CASE("case1: CurveCalculation::D0() [2/10] ", "[math][CurveCalculation][P1][D0]") {
	AMCAX::Circle3 circle3D;
	AMCAX::Point3  center3D(1.0, 1.0, 1.0);
	double radius3D = 5.0;
	double tol = 0.1;
	circle3D.SetLocation(center3D);
	circle3D.SetRadius(radius3D);
	Point3 point3 = AMCAX::CurveCalculation::D0(M_PI_2, circle3D);
	CHECK(point3.X() == Approx(1.0));
	CHECK(point3.Y() == 6.0);
	CHECK(point3.Z() == 1.0);
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] AMCAX_API static Point3 D0(double u, const Ellipse3& ellipse)	 @return The resulting point
	 @param ellipse The ellipse
	 @param u The parameter
	 @brief Compute the point on a 3D ellipse at a parameter
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
#include <occtio/OCCTTool.hpp>
#include <geometry/MakeArcOfHyperbola2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeEdge2d.hpp>
using namespace AMCAX;
TEST_CASE("case1: CurveCalculation::D0() [4/10] ", "[math][CurveCalculation][P1][D0]") {
	Frame3 fram3 = Frame3(Point3(0.0, 0.0, 1.0), Direction3(0.0, 0.0, 1.0));
	AMCAX::Ellipse3 ellipse3(fram3, 5.0, 3.0);
	Point3 point3 = AMCAX::CurveCalculation::D0(M_PI_2, ellipse3);
	CHECK(point3.X() == Approx(0.0).margin(1e-12));
	CHECK(point3.Y() == 3.0);
	CHECK(point3.Z() == 1.0);
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] AMCAX_API static Point3 D0(double u, const Parabola3& parabola)	 @return The resulting point
	 @param parabola The parabola
	 @param u The parameter
	 @brief Compute the point on a 3D parabola at a parameter
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
#include <occtio/OCCTTool.hpp>
#include <geometry/MakeArcOfHyperbola2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeEdge2d.hpp>
using namespace AMCAX;
TEST_CASE("case1: CurveCalculation::D0() [10/10] ", "[math][CurveCalculation][P1][D0]") {
	Point3 point3(0.0, 0.0, 0.0);
	Direction3 dir3(0.0, 0.0, 1.0);
	Frame3 fram3(point3, dir3);
	double focal = 2.0;
	Parabola3 parabola3(fram3, focal);
	SECTION("u =0") {
		Point3 point3 = CurveCalculation::D0(0.0, parabola3);
		CHECK(point3.X() == 0.0);
		CHECK(point3.Y() == 0.0);
		CHECK(point3.Z() == 0.0);
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] AMCAX_API static Point3 D0(double u, const Hyperbola3& hyperbola)	 @return The resulting point
	 @param hyperbola The hyperbola
	 @param u The parameter
	 @brief Compute the point on a 3D hyperbola at a parameter
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
#include <occtio/OCCTTool.hpp>
#include <geometry/MakeArcOfHyperbola2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeEdge2d.hpp>
using namespace AMCAX;
TEST_CASE("case1: CurveCalculation::D0() [6/10] ", "[math][CurveCalculation][P1][D0]") {
	Frame3 fram3;
	double major_radius = 1000.0;
	double minor_radius = 10.0;
	Hyperbola3 hyperbola(fram3, major_radius, minor_radius);
	Point3 point3 = CurveCalculation::D0(0.0, hyperbola);
	CHECK(point3.X() == 1000.0);
	CHECK(point3.Y() == 0.0);
	CHECK(point3.Z() == 0.0);
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] AMCAX_API static Point2 D0(double u, const Line2& line)	 @return The resulting point
	 @param line The line
	 @param u The parameter
	 @brief Compute the point on a 2D line at a parameter
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
#include <occtio/OCCTTool.hpp>
#include <geometry/MakeArcOfHyperbola2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeEdge2d.hpp>
using namespace AMCAX;
TEST_CASE("case1: CurveCalculation::D0() [1/10] ", "[math][CurveCalculation][P1][D0]") {
	AMCAX::Point2 P(0.0, 0.0);
	AMCAX::Direction2 D(1.0, 0.0);
	AMCAX::Axis2  axis2(P, D);
	float radius = 2.0f;
	AMCAX::Circle2 circle2(axis2, radius, true);
	Point2 point2 = AMCAX::CurveCalculation::D0(0.0, circle2);
	CHECK(point2.X() == 2.0);
	CHECK(point2.Y() == 0.0);
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] AMCAX_API static Point2 D0(double u, const Circle2& circle)	 @return The resulting point
	 @param circle The circle
	 @param u The parameter
	 @brief Compute the point on a 2D circle at a parameter
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
#include <occtio/OCCTTool.hpp>
#include <geometry/MakeArcOfHyperbola2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeEdge2d.hpp>
using namespace AMCAX;
TEST_CASE("case1: CurveCalculation::D0() [1/10] ", "[math][CurveCalculation][P1][D0]") {
	AMCAX::Point2 P(0.0, 0.0);
	AMCAX::Direction2 D(1.0, 0.0);
	AMCAX::Axis2  axis2(P, D);
	float radius = 2.0f;
	AMCAX::Circle2 circle2(axis2, radius, true);
	Point2 point2 = AMCAX::CurveCalculation::D0(0.0, circle2);
	CHECK(point2.X() == 2.0);
	CHECK(point2.Y() == 0.0);
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] AMCAX_API static Point2 D0(double u, const Ellipse2& ellipse)	 @return The resulting point
	 @param ellipse The ellipse
	 @param u The parameter
	 @brief Compute the point on a 2D ellipse at a parameter
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
#include <occtio/OCCTTool.hpp>
#include <geometry/MakeArcOfHyperbola2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeEdge2d.hpp>
using namespace AMCAX;
TEST_CASE("case1: CurveCalculation::D0() [3/10] ", "[math][CurveCalculation][P1][D0]") {
	AMCAX::Ellipse2 ellipse2(AMCAX::Axis2(AMCAX::Point2(0.0, 0.0), AMCAX::Direction2(1.0, 0.0)), 5.0, 3.0);
	Point2 point2 = AMCAX::CurveCalculation::D0(M_PI_2, ellipse2);
	CHECK(point2.X() == Approx(0.0).margin(1e-12));
	CHECK(point2.Y() == 3.0);
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] AMCAX_API static Point2 D0(double u, const Parabola2& parabola)	 @return The resulting point
	 @param parabola The parabola
	 @param u The parameter
	 @brief Compute the point on a 2D parabola at a parameter
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
#include <occtio/OCCTTool.hpp>
#include <geometry/MakeArcOfHyperbola2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeEdge2d.hpp>
using namespace AMCAX;
TEST_CASE("case1: CurveCalculation::D0() [9/10] ", "[math][CurveCalculation][P1][D0]") {
	AMCAX::Point2 P(0.0, 0.0);
	AMCAX::Direction2 D(1.0, 0.0);
	AMCAX::Axis2  axis2(P, D);
	double focal = 2.0;
	AMCAX::Parabola2 parabola2(axis2,focal );
	SECTION("u =0") {  
		Point2 point2 = CurveCalculation::D0(0.0, parabola2); 
		CHECK(point2.X() == 0.0);
		CHECK(point2.Y() == 0.0);
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] AMCAX_API static Point2 D0(double u, const Hyperbola2& hyperbola)	 @return The resulting point
	 @param hyperbola The hyperbola
	 @param u The parameter
	 @brief Compute the point on a 2D hyperbola at a parameter
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
#include <occtio/OCCTTool.hpp>
#include <geometry/MakeArcOfHyperbola2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeEdge2d.hpp>
using namespace AMCAX;
TEST_CASE("case1: CurveCalculation::D0() [5/10] ", "[math][CurveCalculation][P1][D0]") {
	Axis2 majorAxis;
	double major_radius = 5;
	double minor_radius = 3;
	Hyperbola2 hyperbola(majorAxis, major_radius, minor_radius);
	Point2 point2 = CurveCalculation::D0(0.0, hyperbola);
	CHECK(point2.X() == 5.0);
	CHECK(point2.Y() == 0.0);
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] AMCAX_API static Vector3 D1(double u, const Line3& line)	 @return The first derivative vector
	 @param line The line
	 @param u The parameter
	 @brief Compute the first derivative on a 3D line at a parameter
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
#include <occtio/OCCTTool.hpp>
#include <geometry/MakeArcOfHyperbola2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeEdge2d.hpp>
using namespace AMCAX;
TEST_CASE("case1: CurveCalculation::D1() circle3[3/20] ", "[math][CurveCalculation][P1][D1]") {
	Direction3 initialDir(0.0, 0.0, 1.0); 
	Frame3 defaultFrame3(Point3(1.0, 0.0, 0.0), initialDir); 
	double radius = 2.0; 
	AMCAX::Circle3 circle3(defaultFrame3, radius);
	SECTION("u =0") {
		Vector3 vector3 = CurveCalculation::D1(0.0, circle3);
		CHECK(vector3.X() == Approx(0.0));
		CHECK(vector3.Y() == Approx(2.0));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static void D1(double u, const Line3& line, Point3& p, Vector3& v1)	 @param[out] v1 The first derivative
	 @param[out] p The point
	 @param[in] line The line
	 @param[in] u The parameter
	 @brief Compute the point and the first derivative on a 3D line at a parameter
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
#include <occtio/OCCTTool.hpp>
#include <geometry/MakeArcOfHyperbola2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeEdge2d.hpp>
using namespace AMCAX;
TEST_CASE("case1: CurveCalculation::D1() circle3[4/20] ", "[math][CurveCalculation][P1][D1]") {
	Direction3 initialDir(0.0, 0.0, 1.0);
	Frame3 defaultFrame3(Point3(1.0, 1.0, 0.0), initialDir);
	Point3 p;
	Vector3 v;
	double radius = 2.0; 
	AMCAX::Circle3 circle3(defaultFrame3, radius);
	SECTION("u =0") {
		CurveCalculation::D1(0.0, circle3,p,v);
		CHECK(p.X() == 3.0);
		CHECK(p.Y() == 1.0);
		CHECK(p.Z() == 0.0);
		CHECK(v.X() == Approx(0.0));
		CHECK(v.Y() == Approx(2.0));
		CHECK(v.Z() == Approx(0.0));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] AMCAX_API static Vector3 D1(double u, const Circle3& circle)	 @return The first derivative vector
	 @param circle The circle
	 @param u The parameter
	 @brief Compute the first derivative on a 3D circle at a parameter
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
#include <occtio/OCCTTool.hpp>
#include <geometry/MakeArcOfHyperbola2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeEdge2d.hpp>
using namespace AMCAX;
TEST_CASE("case1: CurveCalculation::D1() circle3[3/20] ", "[math][CurveCalculation][P1][D1]") {
	Direction3 initialDir(0.0, 0.0, 1.0); 
	Frame3 defaultFrame3(Point3(1.0, 0.0, 0.0), initialDir); 
	double radius = 2.0; 
	AMCAX::Circle3 circle3(defaultFrame3, radius);
	SECTION("u =0") {
		Vector3 vector3 = CurveCalculation::D1(0.0, circle3);
		CHECK(vector3.X() == Approx(0.0));
		CHECK(vector3.Y() == Approx(2.0));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static void D1(double u, const Circle3& circle, Point3& p, Vector3& v1)	 @param[out] v1 The first derivative
	 @param[out] p The point
	 @param[in] circle The circle
	 @param[in] u The parameter
	 @brief Compute the point and the first derivative on a 3D circle at a parameter
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
#include <occtio/OCCTTool.hpp>
#include <geometry/MakeArcOfHyperbola2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeEdge2d.hpp>
using namespace AMCAX;
TEST_CASE("case1: CurveCalculation::D1() circle3[4/20] ", "[math][CurveCalculation][P1][D1]") {
	Direction3 initialDir(0.0, 0.0, 1.0);
	Frame3 defaultFrame3(Point3(1.0, 1.0, 0.0), initialDir);
	Point3 p;
	Vector3 v;
	double radius = 2.0; 
	AMCAX::Circle3 circle3(defaultFrame3, radius);
	SECTION("u =0") {
		CurveCalculation::D1(0.0, circle3,p,v);
		CHECK(p.X() == 3.0);
		CHECK(p.Y() == 1.0);
		CHECK(p.Z() == 0.0);
		CHECK(v.X() == Approx(0.0));
		CHECK(v.Y() == Approx(2.0));
		CHECK(v.Z() == Approx(0.0));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] AMCAX_API static Vector3 D1(double u, const Ellipse3& ellipse)	 @return The first derivative vector
	 @param ellipse The ellipse
	 @param u The parameter
	 @brief Compute the first derivative on a 3D ellipse at a parameter
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
#include <occtio/OCCTTool.hpp>
#include <geometry/MakeArcOfHyperbola2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeEdge2d.hpp>
using namespace AMCAX;
TEST_CASE("case1: CurveCalculation::D1() ellipse3 [7/20] ", "[math][CurveCalculation][P1][D1]") {
	Direction3 initialDir(0.0, 0.0, 1.0); 
	Frame3 defaultFrame3(Point3(0.0, 0.0, 0.0), initialDir); 
	Ellipse3 ellipse3(defaultFrame3,5.0,3.0 );
	MakeEdge edge= MakeEdge(ellipse3);
	bool bWriteresult = OCCTIO::OCCTTool::Write(edge, OUTPUT_PATH_PREFIX"ellipse3CurveCalculation_case1.brep",true,3);
	SECTION("u =0") {
		Vector3 vector3 = CurveCalculation::D1(0.0, ellipse3);
		CHECK(vector3.X() == Approx(0.0));
		CHECK(vector3.Y() == Approx(3.0));
		CHECK(vector3.Z() == Approx(0.0));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static void D1(double u, const Ellipse3& ellipse, Point3& p, Vector3& v1)	 @param[out] v1 The first derivative
	 @param[out] p The point
	 @param[in] ellipse The ellipse
	 @param[in] u The parameter
	 @brief Compute the point and the first derivative on a 3D ellipse at a parameter
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
#include <occtio/OCCTTool.hpp>
#include <geometry/MakeArcOfHyperbola2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeEdge2d.hpp>
using namespace AMCAX;
TEST_CASE("case1: CurveCalculation::D1() ellipse3 [7/20] ", "[math][CurveCalculation][P1][D1]") {
	Direction3 initialDir(0.0, 0.0, 1.0); 
	Frame3 defaultFrame3(Point3(0.0, 0.0, 0.0), initialDir); 
	Ellipse3 ellipse3(defaultFrame3,5.0,3.0 );
	MakeEdge edge= MakeEdge(ellipse3);
	bool bWriteresult = OCCTIO::OCCTTool::Write(edge, OUTPUT_PATH_PREFIX"ellipse3CurveCalculation_case1.brep",true,3);
	SECTION("u =0") {
		Vector3 vector3 = CurveCalculation::D1(0.0, ellipse3);
		CHECK(vector3.X() == Approx(0.0));
		CHECK(vector3.Y() == Approx(3.0));
		CHECK(vector3.Z() == Approx(0.0));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] AMCAX_API static Vector3 D1(double u, const Parabola3& parabola)	 @return The first derivative vector
	 @param parabola The parabola
	 @param u The parameter
	 @brief Compute the first derivative on a 3D parabola at a parameter
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
#include <occtio/OCCTTool.hpp>
#include <geometry/MakeArcOfHyperbola2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeEdge2d.hpp>
using namespace AMCAX;
TEST_CASE("case1: CurveCalculation::D1() ellipse3 [7/20] ", "[math][CurveCalculation][P1][D1]") {
	Direction3 initialDir(0.0, 0.0, 1.0); 
	Frame3 defaultFrame3(Point3(0.0, 0.0, 0.0), initialDir); 
	Ellipse3 ellipse3(defaultFrame3,5.0,3.0 );
	MakeEdge edge= MakeEdge(ellipse3);
	bool bWriteresult = OCCTIO::OCCTTool::Write(edge, OUTPUT_PATH_PREFIX"ellipse3CurveCalculation_case1.brep",true,3);
	SECTION("u = M_PI_2") {
		Vector3 vector3 = CurveCalculation::D1(M_PI_2, ellipse3);
		CHECK(vector3.X() == Approx(-5.0));
		CHECK(vector3.Y() == Approx(0.0).margin(1e-14));
		CHECK(vector3.Z() == Approx(0.0));
	}
}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static void D1(double u, const Parabola3& parabola, Point3& p, Vector3& v1)	 @param[out] v1 The first derivative
	 @param[out] p The point
	 @param[in] parabola The parabola
	 @param[in] u The parameter
	 @brief Compute the point and the first derivative on a 3D parabola at a parameter
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
#include <occtio/OCCTTool.hpp>
#include <geometry/MakeArcOfHyperbola2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeEdge2d.hpp>
using namespace AMCAX;
TEST_CASE("case1: CurveCalculation::D1() ellipse3 [8/20] ", "[math][CurveCalculation][P1][D1]") {
	Direction3 initialDir(0.0, 0.0, 1.0); 
	Frame3 defaultFrame3(Point3(0.0, 0.0, 0.0), initialDir); 
	Ellipse3 ellipse3(defaultFrame3, 5.0, 3.0);
	Point3 p;
	Vector3 v;
	MakeEdge edge = MakeEdge(ellipse3);
	bool bWriteresult = OCCTIO::OCCTTool::Write(edge, OUTPUT_PATH_PREFIX"ellipse3CurveCalculation_case1.brep", true, 3);
	SECTION("u =0") {
		CurveCalculation::D1(0.0, ellipse3,p,v);
		CHECK(p.X() == 5.0);
		CHECK(p.Y() == 0.0);
		CHECK(p.Z() == 0.0);
		CHECK(v.X() == Approx(0.0));
		CHECK(v.Y() == Approx(3.0));
		CHECK(v.Z() == Approx(0.0));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] AMCAX_API static Vector3 D1(double u, const Hyperbola3& hyperbola)	 @return The first derivative vector
	 @param hyperbola The hyperbola
	 @param u The parameter
	 @brief Compute the first derivative on a 3D hyperbola at a parameter
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
#include <occtio/OCCTTool.hpp>
#include <geometry/MakeArcOfHyperbola2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeEdge2d.hpp>
using namespace AMCAX;
TEST_CASE("case1: CurveCalculation::D1() Hyperbola3 [11/20] ", "[math][CurveCalculation][P1][D1]") {
	Direction3 dir3(0.0, 0.0, 1.0);
	Point3 point3(0.0, 0.0, 0.0);
	Frame3 frame3(point3, dir3);
	Hyperbola3 hyperbola3(frame3, 5.0, 3.0); 
	Vector3 vector3 = CurveCalculation::D1(0.0, hyperbola3); 
	CHECK(vector3.X() == 0.0);
	CHECK(vector3.Y() == 3.0);
	CHECK(vector3.Z() == 0.0);
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static void D1(double u, const Hyperbola3& hyperbola, Point3& p, Vector3& v1)	 @param[out] v1 The first derivative
	 @param[out] p The point
	 @param[in] hyperbola The hyperbola
	 @param[in] u The parameter
	 @brief Compute the point and the first derivative on a 3D hyperbola at a parameter
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
#include <occtio/OCCTTool.hpp>
#include <geometry/MakeArcOfHyperbola2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeEdge2d.hpp>
using namespace AMCAX;
TEST_CASE("case1: CurveCalculation::D1() Hyperbola3 [12/20] ", "[math][CurveCalculation][P1][D1]") {
	Direction3 dir3(0.0, 0.0, 1.0);
	Point3 point3(0.0, 0.0, 0.0);
	Frame3 frame3(point3, dir3);
	Hyperbola3 hyperbola3(frame3, 5.0, 3.0); 
	Point3 p;
	Vector3 v;
	CurveCalculation::D1(0.0, hyperbola3,p,v); 
	CHECK(p.X() == 5.0);
	CHECK(p.Y() == 0.0);
	CHECK(p.Z() == 0.0);
	CHECK(v.X() == 0.0);
	CHECK(v.Y() == 3.0);
	CHECK(v.Z() == 0.0);
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] AMCAX_API static Vector2 D1(double u, const Line2& line)	 @return The first derivative vector
	 @param line The line
	 @param u The parameter
	 @brief Compute the first derivative on a 2D line at a parameter
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
#include <occtio/OCCTTool.hpp>
#include <geometry/MakeArcOfHyperbola2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeEdge2d.hpp>
using namespace AMCAX;
TEST_CASE("case1: CurveCalculation::D1() circle2[1/20] ", "[math][CurveCalculation][P1][D1]") {
	Direction2 initialDir(1.0, 0.0); 
	Frame2 defaultFrame2(Point2(1.0, 1.0), initialDir); 
    double radius = 2.0;
    AMCAX::Circle2 circle2(defaultFrame2,radius);
	SECTION("u =0") {
		Vector2 vector2 = CurveCalculation::D1(0.0, circle2);
		CHECK(vector2.X() == Approx(-0.0));
		CHECK(vector2.Y() == 2.0);
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static void D1(double u, const Line2& line, Point2& p, Vector2& v1)	 @param[out] v1 The first derivative
	 @param[out] p The point
	 @param[in] line The line
	 @param[in] u The parameter
	 @brief Compute the point and the first derivative on a 2D line at a parameter
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
#include <occtio/OCCTTool.hpp>
#include <geometry/MakeArcOfHyperbola2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeEdge2d.hpp>
using namespace AMCAX;
TEST_CASE("case1: CurveCalculation::D1() circle2[2/20] ", "[math][CurveCalculation][P1][D1]") {
	Direction2 initialDir(1.0, 0.0); 
	Frame2 defaultFrame2(Point2(1.0, 1.0), initialDir); 
	double radius = 2.0;
	AMCAX::Circle2 circle2(defaultFrame2, radius);
	Point2 p;
	Vector2 v;
	SECTION("u =0") {
		CurveCalculation::D1(0.0, circle2,p,v);
		CHECK(p.X() == 3.0);
		CHECK(p.Y() == 1.0);
		CHECK(v.X() == Approx(0.0));
		CHECK(v.Y() == Approx(2.0));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] AMCAX_API static Vector2 D1(double u, const Circle2& circle)	 @return The first derivative vector
	 @param circle The circle
	 @param u The parameter
	 @brief Compute the first derivative on a 2D circle at a parameter
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
#include <occtio/OCCTTool.hpp>
#include <geometry/MakeArcOfHyperbola2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeEdge2d.hpp>
using namespace AMCAX;
TEST_CASE("case1: CurveCalculation::D1() circle2[1/20] ", "[math][CurveCalculation][P1][D1]") {
	Direction2 initialDir(1.0, 0.0); 
	Frame2 defaultFrame2(Point2(1.0, 1.0), initialDir); 
    double radius = 2.0;
    AMCAX::Circle2 circle2(defaultFrame2,radius);
	SECTION("u =0") {
		Vector2 vector2 = CurveCalculation::D1(0.0, circle2);
		CHECK(vector2.X() == Approx(-0.0));
		CHECK(vector2.Y() == 2.0);
	}}
}
,
{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static void AdjustPeriodic(double ufirst, double ulast, double precision, double& u1, double& u2)	 @param[in,out] u2 The second parameter to be adjust
	 @param[in,out] u1 The first parameter to be adjust
	 @param[in] precision The precision to check equality
	 @param[in] ulast The upper bound of the period
	 @param[in] ufirst The lower bound of the period
	          The parameter u2 is set in the range [u1, u1 + ulast - ufirst]
	 @details The parameter u1 is set in the range [ufirst, ulast]
	 @brief Adjust u1 and u2 to be in the period range.
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
using namespace AMCAX;
TEST_CASE("case1: CurveCalculation::AdjustPeriodic ", "[math][CurveCalculation][P1]") {
	double u1 = 0.0;
	double u2 = 2 * M_PI;
	double ufirst = 0.0;
	double ulast = 2 * M_PI; 
	double precision = 0.001; 
	AMCAX::CurveCalculation::AdjustPeriodic(ufirst, ulast, precision, u1, u2);
	CHECK(u1 == 0);
	CHECK(u2 == 2 * M_PI);
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] AMCAX_API Point3 Apex()	 @return The apex point
	 @brief Get the apex of the cone
,
 "output":#include<iostream>
#include "catch.hpp"
#include <common/FrameT.hpp>
#include <modeling/MakeFace.hpp>
#include <common/AxisT.hpp>
#include <common/FrameT.hpp>
#include <common/VectorT.hpp>
#include <math/Cone.hpp>
using namespace AMCAX;
using namespace std;
TEST_CASE("TestCone", "[math][Cone]")
{
	AMCAX::Frame3 frame;
	double radius = 5.0;
	double angle = M_PI / 4;
	AMCAX::Cone cone(frame, radius, angle);
	AMCAX::Point3 apex = cone.Apex();
	CHECK(apex.X() == 0.0);
	CHECK(apex.Y() == 0.0);
	CHECK(apex.Z() == Approx(-5.0));
	AMCAX::Axis3 axis = cone.Axis();
	std::cout << axis.Direction().X() << std::endl;
	std::cout << axis.Direction().Y() << std::endl;
	std::cout << axis.Direction().Z() << std::endl;
	CHECK(axis.Direction().X() == 0.0);
	CHECK(axis.Direction().Y() == 0.0);
	CHECK(axis.Direction().Z() == 1.0);
	double a1, a2, a3, b1, b2, b3, c1, c2, c3, d;
	cone.Coefficients(a1, a2, a3, b1, b2, b3, c1, c2, c3, d);
	std::cout << "a1: " << a1 << ", a2: " << a2 << ", a3: " << a3 << std::endl;
	std::cout << "b1: " << b1 << ", b2: " << b2 << ", b3: " << b3 << std::endl;
	std::cout << "c1: " << c1 << ", c2: " << c2 << ", c3: " << c3 << std::endl;
	std::cout << "d: " << d << std::endl;
	CHECK(a1 == 1.0);
	CHECK(a2 == 1.0);
	CHECK(a3 == Approx(-1.0));
	CHECK(b1 == 0);
	CHECK(b2 == 0);
	CHECK(b3 == 0);
	CHECK(c1 == 0);
	CHECK(c2 == 0);
	CHECK(c3 == Approx(-5.0));
	CHECK(d == -25.0);
	CHECK(cone.IsDirect() == true);
	CHECK(cone.Location().X() == 0.0);
	CHECK(cone.Location().Y() == 0.0);
	CHECK(cone.Location().Z() == 0.0);
	AMCAX::PointT<double, 3>mirrorPoint(5.0, 0.0, 0.0);
	cone.Mirror(mirrorPoint);
	auto mirroredLocation = cone.Location();
	CHECK(mirroredLocation.X() == 10.0);
	CHECK(mirroredLocation.Y() == 0.0);
	CHECK(mirroredLocation.Z() == 0.0);
	AMCAX::Frame3 coneFrame = cone.Position();
	CHECK(frame.Location().X() == 0.0);
	CHECK(frame.Location().Y() == 0.0);
	CHECK(frame.Location().Z() == 0.0);
	CHECK(cone.Radius() == 5.0);
	double  scaleCone = 2.0;
	cone.Scale(cone.Location(), scaleCone);
	CHECK(cone.Radius() == radius * 2.0);
	double semiCone = cone.SemiAngle();
	CHECK(semiCone == Approx(0.785398));
	const  Frame3& position = cone.Position();
	std::cout << position.XAxis() << std::endl;
	std::cout << position.YAxis() << std::endl;
	Direction3 zDirection(0.0, 0.0, 1.0);
	AMCAX::Point3  centerCone(0.0, 0.0, 0.0);
	Axis3 zAxis(centerCone, zDirection);
	cone.Rotated(zAxis, angle);
	AMCAX::Frame3 coneFrame2 = cone.Position();
	CHECK(coneFrame.Location().X() == 10.0);
	CHECK(coneFrame.Location().Y() == 0.0);
	CHECK(coneFrame.Location().Z() == 0.0);
	double scale = 2.0;
	cone.Scale(centerCone, scale);
	CHECK(cone.Radius() == radius * 4.0);
	double semiAngle = cone.SemiAngle();
	std::cout << semiAngle << std::endl;
	CHECK(semiAngle == Approx(0.785398));
	VectorT<double, 3> translationVector(5.0, 5.0, 0.0);
	cone.Translate(translationVector);
	CHECK(cone.Location().X() == 25.0);
	CHECK(cone.Location().Y() == 5.0);
	CHECK(cone.Location().Z() == 0.0);
	auto xAxis = cone.XAxis();
	auto yAxis = cone.YAxis();
	CHECK(xAxis.Direction().X() == Approx(-1.0));
	CHECK(yAxis.Direction().Y() == Approx(-1.0));
	AMCAX::Transformation3 tr;
	tr.SetTranslation(Vector3(1.0, 2.0, 3.0));
	cone.Transform(tr);
	Axis3 newXAxis = cone.Position().XAxis();
	CHECK(newXAxis.Location().X() == 26.0);
	CHECK(newXAxis.Location().Y() == 7.0);
	CHECK(newXAxis.Location().Z() == 3.0);
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] AMCAX_API double SemiAngle()	 @return The semi-angle
	 @brief Get the semi-angle
,
 "output":#include<iostream>
#include "catch.hpp"
#include <common/FrameT.hpp>
#include <modeling/MakeFace.hpp>
#include <common/AxisT.hpp>
#include <common/FrameT.hpp>
#include <common/VectorT.hpp>
#include <math/Cone.hpp>
using namespace AMCAX;
using namespace std;
TEST_CASE("TestCone", "[math][Cone]")
{
	AMCAX::Frame3 frame;
	double radius = 5.0;
	double angle = M_PI / 4;
	AMCAX::Cone cone(frame, radius, angle);
	AMCAX::Point3 apex = cone.Apex();
	CHECK(apex.X() == 0.0);
	CHECK(apex.Y() == 0.0);
	CHECK(apex.Z() == Approx(-5.0));
	AMCAX::Axis3 axis = cone.Axis();
	std::cout << axis.Direction().X() << std::endl;
	std::cout << axis.Direction().Y() << std::endl;
	std::cout << axis.Direction().Z() << std::endl;
	CHECK(axis.Direction().X() == 0.0);
	CHECK(axis.Direction().Y() == 0.0);
	CHECK(axis.Direction().Z() == 1.0);
	double a1, a2, a3, b1, b2, b3, c1, c2, c3, d;
	cone.Coefficients(a1, a2, a3, b1, b2, b3, c1, c2, c3, d);
	std::cout << "a1: " << a1 << ", a2: " << a2 << ", a3: " << a3 << std::endl;
	std::cout << "b1: " << b1 << ", b2: " << b2 << ", b3: " << b3 << std::endl;
	std::cout << "c1: " << c1 << ", c2: " << c2 << ", c3: " << c3 << std::endl;
	std::cout << "d: " << d << std::endl;
	CHECK(a1 == 1.0);
	CHECK(a2 == 1.0);
	CHECK(a3 == Approx(-1.0));
	CHECK(b1 == 0);
	CHECK(b2 == 0);
	CHECK(b3 == 0);
	CHECK(c1 == 0);
	CHECK(c2 == 0);
	CHECK(c3 == Approx(-5.0));
	CHECK(d == -25.0);
	CHECK(cone.IsDirect() == true);
	CHECK(cone.Location().X() == 0.0);
	CHECK(cone.Location().Y() == 0.0);
	CHECK(cone.Location().Z() == 0.0);
	AMCAX::PointT<double, 3>mirrorPoint(5.0, 0.0, 0.0);
	cone.Mirror(mirrorPoint);
	auto mirroredLocation = cone.Location();
	CHECK(mirroredLocation.X() == 10.0);
	CHECK(mirroredLocation.Y() == 0.0);
	CHECK(mirroredLocation.Z() == 0.0);
	AMCAX::Frame3 coneFrame = cone.Position();
	CHECK(frame.Location().X() == 0.0);
	CHECK(frame.Location().Y() == 0.0);
	CHECK(frame.Location().Z() == 0.0);
	CHECK(cone.Radius() == 5.0);
	double  scaleCone = 2.0;
	cone.Scale(cone.Location(), scaleCone);
	CHECK(cone.Radius() == radius * 2.0);
	double semiCone = cone.SemiAngle();
	CHECK(semiCone == Approx(0.785398));
	const  Frame3& position = cone.Position();
	std::cout << position.XAxis() << std::endl;
	std::cout << position.YAxis() << std::endl;
	Direction3 zDirection(0.0, 0.0, 1.0);
	AMCAX::Point3  centerCone(0.0, 0.0, 0.0);
	Axis3 zAxis(centerCone, zDirection);
	cone.Rotated(zAxis, angle);
	AMCAX::Frame3 coneFrame2 = cone.Position();
	CHECK(coneFrame.Location().X() == 10.0);
	CHECK(coneFrame.Location().Y() == 0.0);
	CHECK(coneFrame.Location().Z() == 0.0);
	double scale = 2.0;
	cone.Scale(centerCone, scale);
	CHECK(cone.Radius() == radius * 4.0);
	double semiAngle = cone.SemiAngle();
	std::cout << semiAngle << std::endl;
	CHECK(semiAngle == Approx(0.785398));
	VectorT<double, 3> translationVector(5.0, 5.0, 0.0);
	cone.Translate(translationVector);
	CHECK(cone.Location().X() == 25.0);
	CHECK(cone.Location().Y() == 5.0);
	CHECK(cone.Location().Z() == 0.0);
	auto xAxis = cone.XAxis();
	auto yAxis = cone.YAxis();
	CHECK(xAxis.Direction().X() == Approx(-1.0));
	CHECK(yAxis.Direction().Y() == Approx(-1.0));
	AMCAX::Transformation3 tr;
	tr.SetTranslation(Vector3(1.0, 2.0, 3.0));
	cone.Transform(tr);
	Axis3 newXAxis = cone.Position().XAxis();
	CHECK(newXAxis.Location().X() == 26.0);
	CHECK(newXAxis.Location().Y() == 7.0);
	CHECK(newXAxis.Location().Z() == 3.0);
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API Cone(const Frame3& frame, double r, double angle)	 @param angle The semi-angle
	 @param r The reference radius
	 @param frame The local frame
	 @brief Construct from a local frame, a reference radius and a semi-angle
,
 "output":#include<iostream>
#include "catch.hpp"
#include <common/FrameT.hpp>
#include <modeling/MakeFace.hpp>
#include <common/AxisT.hpp>
#include <common/FrameT.hpp>
#include <common/VectorT.hpp>
#include <math/Cone.hpp>
using namespace AMCAX;
using namespace std;
TEST_CASE("TestCone", "[math][Cone]")
{
	AMCAX::Frame3 frame;
	double radius = 5.0;
	double angle = M_PI / 4;
	AMCAX::Cone cone(frame, radius, angle);
	AMCAX::Point3 apex = cone.Apex();
	CHECK(apex.X() == 0.0);
	CHECK(apex.Y() == 0.0);
	CHECK(apex.Z() == Approx(-5.0));
	AMCAX::Axis3 axis = cone.Axis();
	std::cout << axis.Direction().X() << std::endl;
	std::cout << axis.Direction().Y() << std::endl;
	std::cout << axis.Direction().Z() << std::endl;
	CHECK(axis.Direction().X() == 0.0);
	CHECK(axis.Direction().Y() == 0.0);
	CHECK(axis.Direction().Z() == 1.0);
	double a1, a2, a3, b1, b2, b3, c1, c2, c3, d;
	cone.Coefficients(a1, a2, a3, b1, b2, b3, c1, c2, c3, d);
	std::cout << "a1: " << a1 << ", a2: " << a2 << ", a3: " << a3 << std::endl;
	std::cout << "b1: " << b1 << ", b2: " << b2 << ", b3: " << b3 << std::endl;
	std::cout << "c1: " << c1 << ", c2: " << c2 << ", c3: " << c3 << std::endl;
	std::cout << "d: " << d << std::endl;
	CHECK(a1 == 1.0);
	CHECK(a2 == 1.0);
	CHECK(a3 == Approx(-1.0));
	CHECK(b1 == 0);
	CHECK(b2 == 0);
	CHECK(b3 == 0);
	CHECK(c1 == 0);
	CHECK(c2 == 0);
	CHECK(c3 == Approx(-5.0));
	CHECK(d == -25.0);
	CHECK(cone.IsDirect() == true);
	CHECK(cone.Location().X() == 0.0);
	CHECK(cone.Location().Y() == 0.0);
	CHECK(cone.Location().Z() == 0.0);
	AMCAX::PointT<double, 3>mirrorPoint(5.0, 0.0, 0.0);
	cone.Mirror(mirrorPoint);
	auto mirroredLocation = cone.Location();
	CHECK(mirroredLocation.X() == 10.0);
	CHECK(mirroredLocation.Y() == 0.0);
	CHECK(mirroredLocation.Z() == 0.0);
	AMCAX::Frame3 coneFrame = cone.Position();
	CHECK(frame.Location().X() == 0.0);
	CHECK(frame.Location().Y() == 0.0);
	CHECK(frame.Location().Z() == 0.0);
	CHECK(cone.Radius() == 5.0);
	double  scaleCone = 2.0;
	cone.Scale(cone.Location(), scaleCone);
	CHECK(cone.Radius() == radius * 2.0);
	double semiCone = cone.SemiAngle();
	CHECK(semiCone == Approx(0.785398));
	const  Frame3& position = cone.Position();
	std::cout << position.XAxis() << std::endl;
	std::cout << position.YAxis() << std::endl;
	Direction3 zDirection(0.0, 0.0, 1.0);
	AMCAX::Point3  centerCone(0.0, 0.0, 0.0);
	Axis3 zAxis(centerCone, zDirection);
	cone.Rotated(zAxis, angle);
	AMCAX::Frame3 coneFrame2 = cone.Position();
	CHECK(coneFrame.Location().X() == 10.0);
	CHECK(coneFrame.Location().Y() == 0.0);
	CHECK(coneFrame.Location().Z() == 0.0);
	double scale = 2.0;
	cone.Scale(centerCone, scale);
	CHECK(cone.Radius() == radius * 4.0);
	double semiAngle = cone.SemiAngle();
	std::cout << semiAngle << std::endl;
	CHECK(semiAngle == Approx(0.785398));
	VectorT<double, 3> translationVector(5.0, 5.0, 0.0);
	cone.Translate(translationVector);
	CHECK(cone.Location().X() == 25.0);
	CHECK(cone.Location().Y() == 5.0);
	CHECK(cone.Location().Z() == 0.0);
	auto xAxis = cone.XAxis();
	auto yAxis = cone.YAxis();
	CHECK(xAxis.Direction().X() == Approx(-1.0));
	CHECK(yAxis.Direction().Y() == Approx(-1.0));
	AMCAX::Transformation3 tr;
	tr.SetTranslation(Vector3(1.0, 2.0, 3.0));
	cone.Transform(tr);
	Axis3 newXAxis = cone.Position().XAxis();
	CHECK(newXAxis.Location().X() == 26.0);
	CHECK(newXAxis.Location().Y() == 7.0);
	CHECK(newXAxis.Location().Z() == 3.0);
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API Cone& Scale(const Point3& point, double scale)	 @return The reference to self
	 @param scale The scale value
	 @param point The scaling center point
	 @brief Scale the cone by a point
,
 "output":#include<iostream>
#include "catch.hpp"
#include <common/FrameT.hpp>
#include <modeling/MakeFace.hpp>
#include <common/AxisT.hpp>
#include <common/FrameT.hpp>
#include <common/VectorT.hpp>
#include <math/Cone.hpp>
using namespace AMCAX;
using namespace std;
TEST_CASE("TestCone", "[math][Cone]")
{
	AMCAX::Frame3 frame;
	double radius = 5.0;
	double angle = M_PI / 4;
	AMCAX::Cone cone(frame, radius, angle);
	AMCAX::Point3 apex = cone.Apex();
	CHECK(apex.X() == 0.0);
	CHECK(apex.Y() == 0.0);
	CHECK(apex.Z() == Approx(-5.0));
	AMCAX::Axis3 axis = cone.Axis();
	std::cout << axis.Direction().X() << std::endl;
	std::cout << axis.Direction().Y() << std::endl;
	std::cout << axis.Direction().Z() << std::endl;
	CHECK(axis.Direction().X() == 0.0);
	CHECK(axis.Direction().Y() == 0.0);
	CHECK(axis.Direction().Z() == 1.0);
	double a1, a2, a3, b1, b2, b3, c1, c2, c3, d;
	cone.Coefficients(a1, a2, a3, b1, b2, b3, c1, c2, c3, d);
	std::cout << "a1: " << a1 << ", a2: " << a2 << ", a3: " << a3 << std::endl;
	std::cout << "b1: " << b1 << ", b2: " << b2 << ", b3: " << b3 << std::endl;
	std::cout << "c1: " << c1 << ", c2: " << c2 << ", c3: " << c3 << std::endl;
	std::cout << "d: " << d << std::endl;
	CHECK(a1 == 1.0);
	CHECK(a2 == 1.0);
	CHECK(a3 == Approx(-1.0));
	CHECK(b1 == 0);
	CHECK(b2 == 0);
	CHECK(b3 == 0);
	CHECK(c1 == 0);
	CHECK(c2 == 0);
	CHECK(c3 == Approx(-5.0));
	CHECK(d == -25.0);
	CHECK(cone.IsDirect() == true);
	CHECK(cone.Location().X() == 0.0);
	CHECK(cone.Location().Y() == 0.0);
	CHECK(cone.Location().Z() == 0.0);
	AMCAX::PointT<double, 3>mirrorPoint(5.0, 0.0, 0.0);
	cone.Mirror(mirrorPoint);
	auto mirroredLocation = cone.Location();
	CHECK(mirroredLocation.X() == 10.0);
	CHECK(mirroredLocation.Y() == 0.0);
	CHECK(mirroredLocation.Z() == 0.0);
	AMCAX::Frame3 coneFrame = cone.Position();
	CHECK(frame.Location().X() == 0.0);
	CHECK(frame.Location().Y() == 0.0);
	CHECK(frame.Location().Z() == 0.0);
	CHECK(cone.Radius() == 5.0);
	double  scaleCone = 2.0;
	cone.Scale(cone.Location(), scaleCone);
	CHECK(cone.Radius() == radius * 2.0);
	double semiCone = cone.SemiAngle();
	CHECK(semiCone == Approx(0.785398));
	const  Frame3& position = cone.Position();
	std::cout << position.XAxis() << std::endl;
	std::cout << position.YAxis() << std::endl;
	Direction3 zDirection(0.0, 0.0, 1.0);
	AMCAX::Point3  centerCone(0.0, 0.0, 0.0);
	Axis3 zAxis(centerCone, zDirection);
	cone.Rotated(zAxis, angle);
	AMCAX::Frame3 coneFrame2 = cone.Position();
	CHECK(coneFrame.Location().X() == 10.0);
	CHECK(coneFrame.Location().Y() == 0.0);
	CHECK(coneFrame.Location().Z() == 0.0);
	double scale = 2.0;
	cone.Scale(centerCone, scale);
	CHECK(cone.Radius() == radius * 4.0);
	double semiAngle = cone.SemiAngle();
	std::cout << semiAngle << std::endl;
	CHECK(semiAngle == Approx(0.785398));
	VectorT<double, 3> translationVector(5.0, 5.0, 0.0);
	cone.Translate(translationVector);
	CHECK(cone.Location().X() == 25.0);
	CHECK(cone.Location().Y() == 5.0);
	CHECK(cone.Location().Z() == 0.0);
	auto xAxis = cone.XAxis();
	auto yAxis = cone.YAxis();
	CHECK(xAxis.Direction().X() == Approx(-1.0));
	CHECK(yAxis.Direction().Y() == Approx(-1.0));
	AMCAX::Transformation3 tr;
	tr.SetTranslation(Vector3(1.0, 2.0, 3.0));
	cone.Transform(tr);
	Axis3 newXAxis = cone.Position().XAxis();
	CHECK(newXAxis.Location().X() == 26.0);
	CHECK(newXAxis.Location().Y() == 7.0);
	CHECK(newXAxis.Location().Z() == 3.0);
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API Cone& Transform(const Transformation3& tr)	 @return The reference to self
	 @param tr The transformation
	 @brief Transform the cone
,
 "output":#include<iostream>
#include "catch.hpp"
#include <common/FrameT.hpp>
#include <modeling/MakeFace.hpp>
#include <common/AxisT.hpp>
#include <common/FrameT.hpp>
#include <common/VectorT.hpp>
#include <math/Cone.hpp>
using namespace AMCAX;
using namespace std;
TEST_CASE("TestCone", "[math][Cone]")
{
	AMCAX::Frame3 frame;
	double radius = 5.0;
	double angle = M_PI / 4;
	AMCAX::Cone cone(frame, radius, angle);
	AMCAX::Point3 apex = cone.Apex();
	CHECK(apex.X() == 0.0);
	CHECK(apex.Y() == 0.0);
	CHECK(apex.Z() == Approx(-5.0));
	AMCAX::Axis3 axis = cone.Axis();
	std::cout << axis.Direction().X() << std::endl;
	std::cout << axis.Direction().Y() << std::endl;
	std::cout << axis.Direction().Z() << std::endl;
	CHECK(axis.Direction().X() == 0.0);
	CHECK(axis.Direction().Y() == 0.0);
	CHECK(axis.Direction().Z() == 1.0);
	double a1, a2, a3, b1, b2, b3, c1, c2, c3, d;
	cone.Coefficients(a1, a2, a3, b1, b2, b3, c1, c2, c3, d);
	std::cout << "a1: " << a1 << ", a2: " << a2 << ", a3: " << a3 << std::endl;
	std::cout << "b1: " << b1 << ", b2: " << b2 << ", b3: " << b3 << std::endl;
	std::cout << "c1: " << c1 << ", c2: " << c2 << ", c3: " << c3 << std::endl;
	std::cout << "d: " << d << std::endl;
	CHECK(a1 == 1.0);
	CHECK(a2 == 1.0);
	CHECK(a3 == Approx(-1.0));
	CHECK(b1 == 0);
	CHECK(b2 == 0);
	CHECK(b3 == 0);
	CHECK(c1 == 0);
	CHECK(c2 == 0);
	CHECK(c3 == Approx(-5.0));
	CHECK(d == -25.0);
	CHECK(cone.IsDirect() == true);
	CHECK(cone.Location().X() == 0.0);
	CHECK(cone.Location().Y() == 0.0);
	CHECK(cone.Location().Z() == 0.0);
	AMCAX::PointT<double, 3>mirrorPoint(5.0, 0.0, 0.0);
	cone.Mirror(mirrorPoint);
	auto mirroredLocation = cone.Location();
	CHECK(mirroredLocation.X() == 10.0);
	CHECK(mirroredLocation.Y() == 0.0);
	CHECK(mirroredLocation.Z() == 0.0);
	AMCAX::Frame3 coneFrame = cone.Position();
	CHECK(frame.Location().X() == 0.0);
	CHECK(frame.Location().Y() == 0.0);
	CHECK(frame.Location().Z() == 0.0);
	CHECK(cone.Radius() == 5.0);
	double  scaleCone = 2.0;
	cone.Scale(cone.Location(), scaleCone);
	CHECK(cone.Radius() == radius * 2.0);
	double semiCone = cone.SemiAngle();
	CHECK(semiCone == Approx(0.785398));
	const  Frame3& position = cone.Position();
	std::cout << position.XAxis() << std::endl;
	std::cout << position.YAxis() << std::endl;
	Direction3 zDirection(0.0, 0.0, 1.0);
	AMCAX::Point3  centerCone(0.0, 0.0, 0.0);
	Axis3 zAxis(centerCone, zDirection);
	cone.Rotated(zAxis, angle);
	AMCAX::Frame3 coneFrame2 = cone.Position();
	CHECK(coneFrame.Location().X() == 10.0);
	CHECK(coneFrame.Location().Y() == 0.0);
	CHECK(coneFrame.Location().Z() == 0.0);
	double scale = 2.0;
	cone.Scale(centerCone, scale);
	CHECK(cone.Radius() == radius * 4.0);
	double semiAngle = cone.SemiAngle();
	std::cout << semiAngle << std::endl;
	CHECK(semiAngle == Approx(0.785398));
	VectorT<double, 3> translationVector(5.0, 5.0, 0.0);
	cone.Translate(translationVector);
	CHECK(cone.Location().X() == 25.0);
	CHECK(cone.Location().Y() == 5.0);
	CHECK(cone.Location().Z() == 0.0);
	auto xAxis = cone.XAxis();
	auto yAxis = cone.YAxis();
	CHECK(xAxis.Direction().X() == Approx(-1.0));
	CHECK(yAxis.Direction().Y() == Approx(-1.0));
	AMCAX::Transformation3 tr;
	tr.SetTranslation(Vector3(1.0, 2.0, 3.0));
	cone.Transform(tr);
	Axis3 newXAxis = cone.Position().XAxis();
	CHECK(newXAxis.Location().X() == 26.0);
	CHECK(newXAxis.Location().Y() == 7.0);
	CHECK(newXAxis.Location().Z() == 3.0);
}
}
,
{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API Classifier2d(const std::vector<Point2>& pts, double tolU, double tolV, double uMin, double vMin, double uMax, double vMax)	 @param vMax The upper bound of v
	 @param uMax The upper bound of u
	 @param vMin The lower bound of v
	 @param uMin The lower bound of u
	 @param tolV The tolerance of v bound
	 @param tolU The tolerance of u bound
	 @param pts The points of a 2D closed polygon, the last point does not required to repeat the first point
	 @details Require uMax > uMin, vMax > vMin, and at least 3 points
	 @brief Construct from a 2D polygon and uv-bounds
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/Classifier2d.hpp>
using namespace AMCAX;
TEST_CASE("case1: Classifier2d ", "[math][Classifier2d][P1]") {
    std::vector<Point2> pts = {
        Point2(2.0, 0.0),
        Point2(1.0, 1.0),
        Point2(2.0, 2.0),
        Point2(3.0, 2.0)
    }; 
    double tolU = 0.1;
    double tolV = 0.1;
    double uMin = 0.0;
    double vMin = 0.0;
    double uMax = 2.5;
    double vMax = 1.5;
    Classifier2d classifier(pts, tolU, tolV, uMin, vMin, uMax, vMax);
	SECTION("IsInOut Point normal set") {
        Point2 OutPoint(0.0, 0.0);
        Point2 OnPoint(1.0, 1.0);
        Point2 InPoint(2.0, 1.0);
        CHECK(classifier.IsInOut(OutPoint) == -1);
        CHECK(classifier.IsInOut(OnPoint) == 0);
        CHECK(classifier.IsInOut(InPoint) == 1);
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API int IsInOut(const Point2& p)	 @return 1: in; 0: on; -1: out
	 @param p The test point
	 @brief Check a point is in or out of the polygon
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/Classifier2d.hpp>
using namespace AMCAX;
TEST_CASE("case1: Classifier2d ", "[math][Classifier2d][P1]") {
    std::vector<Point2> pts = {
        Point2(2.0, 0.0),
        Point2(1.0, 1.0),
        Point2(2.0, 2.0),
        Point2(3.0, 2.0)
    }; 
    double tolU = 0.1;
    double tolV = 0.1;
    double uMin = 0.0;
    double vMin = 0.0;
    double uMax = 2.5;
    double vMax = 1.5;
    Classifier2d classifier(pts, tolU, tolV, uMin, vMin, uMax, vMax);
	SECTION("IsInOut Point normal set") {
        Point2 OutPoint(0.0, 0.0);
        Point2 OnPoint(1.0, 1.0);
        Point2 InPoint(2.0, 1.0);
        CHECK(classifier.IsInOut(OutPoint) == -1);
        CHECK(classifier.IsInOut(OnPoint) == 0);
        CHECK(classifier.IsInOut(InPoint) == 1);
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API int IsInOutOn(const Point2& p, double tol)	 @return 1: in; 0: on; -1: out
	 @param tol The tolerance of the point
	 @param p The test point
	 @brief Check a point is in or out of the polygon
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/Classifier2d.hpp>
using namespace AMCAX;
TEST_CASE("case3: Classifier2d ", "[math][Classifier2d][P1]") {
    std::vector<Point2> pts = {
        Point2(2.0, 0.0),
        Point2(1.0, 1.0),
        Point2(2.0, 2.0),
        Point2(3.0, 2.0)
    }; 
    double tolU = 0.1;
    double tolV = 0.1;
    double uMin = 0.0;
    double vMin = 0.0;
    double uMax = 2.5;
    double vMax = 1.5;
    Classifier2d classifier(pts, tolU, tolV, uMin, vMin, uMax, vMax);
	SECTION("IsInOutOn Point normal set") {
        Point2 OutPoint(0.0, 0.0);
        Point2 OnPoint(1.0, 1.0);
        Point2 AnothOnPoint(2.0, 2.0);
        Point2 InPoint(2.0, 1.0);
        CHECK(classifier.IsInOutOn(OutPoint,0.0) == -1);
        CHECK(classifier.IsInOutOn(OnPoint,0.0) != 0);
        CHECK(classifier.IsInOutOn(OnPoint, 1.0) == 0);
        CHECK(classifier.IsInOutOn(AnothOnPoint, 1.0) == 0); 
        CHECK(classifier.IsInOutOn(InPoint,0.0) == 1);
    }}
}
,
{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API Classifier2d(const std::vector<Point2>& pts, double tolU, double tolV, double uMin, double vMin, double uMax, double vMax)	 @param vMax The upper bound of v
	 @param uMax The upper bound of u
	 @param vMin The lower bound of v
	 @param uMin The lower bound of u
	 @param tolV The tolerance of v bound
	 @param tolU The tolerance of u bound
	 @param pts The points of a 2D closed polygon, the last point does not required to repeat the first point
	 @details Require uMax > uMin, vMax > vMin, and at least 3 points
	 @brief Construct from a 2D polygon and uv-bounds
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/Classifier2d.hpp>
using namespace AMCAX;
TEST_CASE("case1: Classifier2d ", "[math][Classifier2d][P1]") {
    std::vector<Point2> pts = {
        Point2(2.0, 0.0),
        Point2(1.0, 1.0),
        Point2(2.0, 2.0),
        Point2(3.0, 2.0)
    }; 
    double tolU = 0.1;
    double tolV = 0.1;
    double uMin = 0.0;
    double vMin = 0.0;
    double uMax = 2.5;
    double vMax = 1.5;
    Classifier2d classifier(pts, tolU, tolV, uMin, vMin, uMax, vMax);
	SECTION("IsInOut Point normal set") {
        Point2 OutPoint(0.0, 0.0);
        Point2 OnPoint(1.0, 1.0);
        Point2 InPoint(2.0, 1.0);
        CHECK(classifier.IsInOut(OutPoint) == -1);
        CHECK(classifier.IsInOut(OnPoint) == 0);
        CHECK(classifier.IsInOut(InPoint) == 1);
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API int IsInOut(const Point2& p)	 @return 1: in; 0: on; -1: out
	 @param p The test point
	 @brief Check a point is in or out of the polygon
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/Classifier2d.hpp>
using namespace AMCAX;
TEST_CASE("case1: Classifier2d ", "[math][Classifier2d][P1]") {
    std::vector<Point2> pts = {
        Point2(2.0, 0.0),
        Point2(1.0, 1.0),
        Point2(2.0, 2.0),
        Point2(3.0, 2.0)
    }; 
    double tolU = 0.1;
    double tolV = 0.1;
    double uMin = 0.0;
    double vMin = 0.0;
    double uMax = 2.5;
    double vMax = 1.5;
    Classifier2d classifier(pts, tolU, tolV, uMin, vMin, uMax, vMax);
	SECTION("IsInOut Point normal set") {
        Point2 OutPoint(0.0, 0.0);
        Point2 OnPoint(1.0, 1.0);
        Point2 InPoint(2.0, 1.0);
        CHECK(classifier.IsInOut(OutPoint) == -1);
        CHECK(classifier.IsInOut(OnPoint) == 0);
        CHECK(classifier.IsInOut(InPoint) == 1);
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API int IsInOutOn(const Point2& p, double tol)	 @return 1: in; 0: on; -1: out
	 @param tol The tolerance of the point
	 @param p The test point
	 @brief Check a point is in or out of the polygon
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/Classifier2d.hpp>
using namespace AMCAX;
TEST_CASE("case3: Classifier2d ", "[math][Classifier2d][P1]") {
    std::vector<Point2> pts = {
        Point2(2.0, 0.0),
        Point2(1.0, 1.0),
        Point2(2.0, 2.0),
        Point2(3.0, 2.0)
    }; 
    double tolU = 0.1;
    double tolV = 0.1;
    double uMin = 0.0;
    double vMin = 0.0;
    double uMax = 2.5;
    double vMax = 1.5;
    Classifier2d classifier(pts, tolU, tolV, uMin, vMin, uMax, vMax);
	SECTION("IsInOutOn Point normal set") {
        Point2 OutPoint(0.0, 0.0);
        Point2 OnPoint(1.0, 1.0);
        Point2 AnothOnPoint(2.0, 2.0);
        Point2 InPoint(2.0, 1.0);
        CHECK(classifier.IsInOutOn(OutPoint,0.0) == -1);
        CHECK(classifier.IsInOutOn(OnPoint,0.0) != 0);
        CHECK(classifier.IsInOutOn(OnPoint, 1.0) == 0);
        CHECK(classifier.IsInOutOn(AnothOnPoint, 1.0) == 0); 
        CHECK(classifier.IsInOutOn(InPoint,0.0) == 1);
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] AMCAX_API Point3 Apex()	 @return The apex point
	 @brief Get the apex of the cone
,
 "output":#include<iostream>
#include "catch.hpp"
#include <common/FrameT.hpp>
#include <modeling/MakeFace.hpp>
#include <common/AxisT.hpp>
#include <common/FrameT.hpp>
#include <common/VectorT.hpp>
#include <math/Cone.hpp>
using namespace AMCAX;
using namespace std;
TEST_CASE("TestCone", "[math][Cone]")
{
	AMCAX::Frame3 frame;
	double radius = 5.0;
	double angle = M_PI / 4;
	AMCAX::Cone cone(frame, radius, angle);
	AMCAX::Point3 apex = cone.Apex();
	CHECK(apex.X() == 0.0);
	CHECK(apex.Y() == 0.0);
	CHECK(apex.Z() == Approx(-5.0));
	AMCAX::Axis3 axis = cone.Axis();
	std::cout << axis.Direction().X() << std::endl;
	std::cout << axis.Direction().Y() << std::endl;
	std::cout << axis.Direction().Z() << std::endl;
	CHECK(axis.Direction().X() == 0.0);
	CHECK(axis.Direction().Y() == 0.0);
	CHECK(axis.Direction().Z() == 1.0);
	double a1, a2, a3, b1, b2, b3, c1, c2, c3, d;
	cone.Coefficients(a1, a2, a3, b1, b2, b3, c1, c2, c3, d);
	std::cout << "a1: " << a1 << ", a2: " << a2 << ", a3: " << a3 << std::endl;
	std::cout << "b1: " << b1 << ", b2: " << b2 << ", b3: " << b3 << std::endl;
	std::cout << "c1: " << c1 << ", c2: " << c2 << ", c3: " << c3 << std::endl;
	std::cout << "d: " << d << std::endl;
	CHECK(a1 == 1.0);
	CHECK(a2 == 1.0);
	CHECK(a3 == Approx(-1.0));
	CHECK(b1 == 0);
	CHECK(b2 == 0);
	CHECK(b3 == 0);
	CHECK(c1 == 0);
	CHECK(c2 == 0);
	CHECK(c3 == Approx(-5.0));
	CHECK(d == -25.0);
	CHECK(cone.IsDirect() == true);
	CHECK(cone.Location().X() == 0.0);
	CHECK(cone.Location().Y() == 0.0);
	CHECK(cone.Location().Z() == 0.0);
	AMCAX::PointT<double, 3>mirrorPoint(5.0, 0.0, 0.0);
	cone.Mirror(mirrorPoint);
	auto mirroredLocation = cone.Location();
	CHECK(mirroredLocation.X() == 10.0);
	CHECK(mirroredLocation.Y() == 0.0);
	CHECK(mirroredLocation.Z() == 0.0);
	AMCAX::Frame3 coneFrame = cone.Position();
	CHECK(frame.Location().X() == 0.0);
	CHECK(frame.Location().Y() == 0.0);
	CHECK(frame.Location().Z() == 0.0);
	CHECK(cone.Radius() == 5.0);
	double  scaleCone = 2.0;
	cone.Scale(cone.Location(), scaleCone);
	CHECK(cone.Radius() == radius * 2.0);
	double semiCone = cone.SemiAngle();
	CHECK(semiCone == Approx(0.785398));
	const  Frame3& position = cone.Position();
	std::cout << position.XAxis() << std::endl;
	std::cout << position.YAxis() << std::endl;
	Direction3 zDirection(0.0, 0.0, 1.0);
	AMCAX::Point3  centerCone(0.0, 0.0, 0.0);
	Axis3 zAxis(centerCone, zDirection);
	cone.Rotated(zAxis, angle);
	AMCAX::Frame3 coneFrame2 = cone.Position();
	CHECK(coneFrame.Location().X() == 10.0);
	CHECK(coneFrame.Location().Y() == 0.0);
	CHECK(coneFrame.Location().Z() == 0.0);
	double scale = 2.0;
	cone.Scale(centerCone, scale);
	CHECK(cone.Radius() == radius * 4.0);
	double semiAngle = cone.SemiAngle();
	std::cout << semiAngle << std::endl;
	CHECK(semiAngle == Approx(0.785398));
	VectorT<double, 3> translationVector(5.0, 5.0, 0.0);
	cone.Translate(translationVector);
	CHECK(cone.Location().X() == 25.0);
	CHECK(cone.Location().Y() == 5.0);
	CHECK(cone.Location().Z() == 0.0);
	auto xAxis = cone.XAxis();
	auto yAxis = cone.YAxis();
	CHECK(xAxis.Direction().X() == Approx(-1.0));
	CHECK(yAxis.Direction().Y() == Approx(-1.0));
	AMCAX::Transformation3 tr;
	tr.SetTranslation(Vector3(1.0, 2.0, 3.0));
	cone.Transform(tr);
	Axis3 newXAxis = cone.Position().XAxis();
	CHECK(newXAxis.Location().X() == 26.0);
	CHECK(newXAxis.Location().Y() == 7.0);
	CHECK(newXAxis.Location().Z() == 3.0);
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] AMCAX_API double SemiAngle()	 @return The semi-angle
	 @brief Get the semi-angle
,
 "output":#include<iostream>
#include "catch.hpp"
#include <common/FrameT.hpp>
#include <modeling/MakeFace.hpp>
#include <common/AxisT.hpp>
#include <common/FrameT.hpp>
#include <common/VectorT.hpp>
#include <math/Cone.hpp>
using namespace AMCAX;
using namespace std;
TEST_CASE("TestCone", "[math][Cone]")
{
	AMCAX::Frame3 frame;
	double radius = 5.0;
	double angle = M_PI / 4;
	AMCAX::Cone cone(frame, radius, angle);
	AMCAX::Point3 apex = cone.Apex();
	CHECK(apex.X() == 0.0);
	CHECK(apex.Y() == 0.0);
	CHECK(apex.Z() == Approx(-5.0));
	AMCAX::Axis3 axis = cone.Axis();
	std::cout << axis.Direction().X() << std::endl;
	std::cout << axis.Direction().Y() << std::endl;
	std::cout << axis.Direction().Z() << std::endl;
	CHECK(axis.Direction().X() == 0.0);
	CHECK(axis.Direction().Y() == 0.0);
	CHECK(axis.Direction().Z() == 1.0);
	double a1, a2, a3, b1, b2, b3, c1, c2, c3, d;
	cone.Coefficients(a1, a2, a3, b1, b2, b3, c1, c2, c3, d);
	std::cout << "a1: " << a1 << ", a2: " << a2 << ", a3: " << a3 << std::endl;
	std::cout << "b1: " << b1 << ", b2: " << b2 << ", b3: " << b3 << std::endl;
	std::cout << "c1: " << c1 << ", c2: " << c2 << ", c3: " << c3 << std::endl;
	std::cout << "d: " << d << std::endl;
	CHECK(a1 == 1.0);
	CHECK(a2 == 1.0);
	CHECK(a3 == Approx(-1.0));
	CHECK(b1 == 0);
	CHECK(b2 == 0);
	CHECK(b3 == 0);
	CHECK(c1 == 0);
	CHECK(c2 == 0);
	CHECK(c3 == Approx(-5.0));
	CHECK(d == -25.0);
	CHECK(cone.IsDirect() == true);
	CHECK(cone.Location().X() == 0.0);
	CHECK(cone.Location().Y() == 0.0);
	CHECK(cone.Location().Z() == 0.0);
	AMCAX::PointT<double, 3>mirrorPoint(5.0, 0.0, 0.0);
	cone.Mirror(mirrorPoint);
	auto mirroredLocation = cone.Location();
	CHECK(mirroredLocation.X() == 10.0);
	CHECK(mirroredLocation.Y() == 0.0);
	CHECK(mirroredLocation.Z() == 0.0);
	AMCAX::Frame3 coneFrame = cone.Position();
	CHECK(frame.Location().X() == 0.0);
	CHECK(frame.Location().Y() == 0.0);
	CHECK(frame.Location().Z() == 0.0);
	CHECK(cone.Radius() == 5.0);
	double  scaleCone = 2.0;
	cone.Scale(cone.Location(), scaleCone);
	CHECK(cone.Radius() == radius * 2.0);
	double semiCone = cone.SemiAngle();
	CHECK(semiCone == Approx(0.785398));
	const  Frame3& position = cone.Position();
	std::cout << position.XAxis() << std::endl;
	std::cout << position.YAxis() << std::endl;
	Direction3 zDirection(0.0, 0.0, 1.0);
	AMCAX::Point3  centerCone(0.0, 0.0, 0.0);
	Axis3 zAxis(centerCone, zDirection);
	cone.Rotated(zAxis, angle);
	AMCAX::Frame3 coneFrame2 = cone.Position();
	CHECK(coneFrame.Location().X() == 10.0);
	CHECK(coneFrame.Location().Y() == 0.0);
	CHECK(coneFrame.Location().Z() == 0.0);
	double scale = 2.0;
	cone.Scale(centerCone, scale);
	CHECK(cone.Radius() == radius * 4.0);
	double semiAngle = cone.SemiAngle();
	std::cout << semiAngle << std::endl;
	CHECK(semiAngle == Approx(0.785398));
	VectorT<double, 3> translationVector(5.0, 5.0, 0.0);
	cone.Translate(translationVector);
	CHECK(cone.Location().X() == 25.0);
	CHECK(cone.Location().Y() == 5.0);
	CHECK(cone.Location().Z() == 0.0);
	auto xAxis = cone.XAxis();
	auto yAxis = cone.YAxis();
	CHECK(xAxis.Direction().X() == Approx(-1.0));
	CHECK(yAxis.Direction().Y() == Approx(-1.0));
	AMCAX::Transformation3 tr;
	tr.SetTranslation(Vector3(1.0, 2.0, 3.0));
	cone.Transform(tr);
	Axis3 newXAxis = cone.Position().XAxis();
	CHECK(newXAxis.Location().X() == 26.0);
	CHECK(newXAxis.Location().Y() == 7.0);
	CHECK(newXAxis.Location().Z() == 3.0);
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API Cone(const Frame3& frame, double r, double angle)	 @param angle The semi-angle
	 @param r The reference radius
	 @param frame The local frame
	 @brief Construct from a local frame, a reference radius and a semi-angle
,
 "output":#include<iostream>
#include "catch.hpp"
#include <common/FrameT.hpp>
#include <modeling/MakeFace.hpp>
#include <common/AxisT.hpp>
#include <common/FrameT.hpp>
#include <common/VectorT.hpp>
#include <math/Cone.hpp>
using namespace AMCAX;
using namespace std;
TEST_CASE("TestCone", "[math][Cone]")
{
	AMCAX::Frame3 frame;
	double radius = 5.0;
	double angle = M_PI / 4;
	AMCAX::Cone cone(frame, radius, angle);
	AMCAX::Point3 apex = cone.Apex();
	CHECK(apex.X() == 0.0);
	CHECK(apex.Y() == 0.0);
	CHECK(apex.Z() == Approx(-5.0));
	AMCAX::Axis3 axis = cone.Axis();
	std::cout << axis.Direction().X() << std::endl;
	std::cout << axis.Direction().Y() << std::endl;
	std::cout << axis.Direction().Z() << std::endl;
	CHECK(axis.Direction().X() == 0.0);
	CHECK(axis.Direction().Y() == 0.0);
	CHECK(axis.Direction().Z() == 1.0);
	double a1, a2, a3, b1, b2, b3, c1, c2, c3, d;
	cone.Coefficients(a1, a2, a3, b1, b2, b3, c1, c2, c3, d);
	std::cout << "a1: " << a1 << ", a2: " << a2 << ", a3: " << a3 << std::endl;
	std::cout << "b1: " << b1 << ", b2: " << b2 << ", b3: " << b3 << std::endl;
	std::cout << "c1: " << c1 << ", c2: " << c2 << ", c3: " << c3 << std::endl;
	std::cout << "d: " << d << std::endl;
	CHECK(a1 == 1.0);
	CHECK(a2 == 1.0);
	CHECK(a3 == Approx(-1.0));
	CHECK(b1 == 0);
	CHECK(b2 == 0);
	CHECK(b3 == 0);
	CHECK(c1 == 0);
	CHECK(c2 == 0);
	CHECK(c3 == Approx(-5.0));
	CHECK(d == -25.0);
	CHECK(cone.IsDirect() == true);
	CHECK(cone.Location().X() == 0.0);
	CHECK(cone.Location().Y() == 0.0);
	CHECK(cone.Location().Z() == 0.0);
	AMCAX::PointT<double, 3>mirrorPoint(5.0, 0.0, 0.0);
	cone.Mirror(mirrorPoint);
	auto mirroredLocation = cone.Location();
	CHECK(mirroredLocation.X() == 10.0);
	CHECK(mirroredLocation.Y() == 0.0);
	CHECK(mirroredLocation.Z() == 0.0);
	AMCAX::Frame3 coneFrame = cone.Position();
	CHECK(frame.Location().X() == 0.0);
	CHECK(frame.Location().Y() == 0.0);
	CHECK(frame.Location().Z() == 0.0);
	CHECK(cone.Radius() == 5.0);
	double  scaleCone = 2.0;
	cone.Scale(cone.Location(), scaleCone);
	CHECK(cone.Radius() == radius * 2.0);
	double semiCone = cone.SemiAngle();
	CHECK(semiCone == Approx(0.785398));
	const  Frame3& position = cone.Position();
	std::cout << position.XAxis() << std::endl;
	std::cout << position.YAxis() << std::endl;
	Direction3 zDirection(0.0, 0.0, 1.0);
	AMCAX::Point3  centerCone(0.0, 0.0, 0.0);
	Axis3 zAxis(centerCone, zDirection);
	cone.Rotated(zAxis, angle);
	AMCAX::Frame3 coneFrame2 = cone.Position();
	CHECK(coneFrame.Location().X() == 10.0);
	CHECK(coneFrame.Location().Y() == 0.0);
	CHECK(coneFrame.Location().Z() == 0.0);
	double scale = 2.0;
	cone.Scale(centerCone, scale);
	CHECK(cone.Radius() == radius * 4.0);
	double semiAngle = cone.SemiAngle();
	std::cout << semiAngle << std::endl;
	CHECK(semiAngle == Approx(0.785398));
	VectorT<double, 3> translationVector(5.0, 5.0, 0.0);
	cone.Translate(translationVector);
	CHECK(cone.Location().X() == 25.0);
	CHECK(cone.Location().Y() == 5.0);
	CHECK(cone.Location().Z() == 0.0);
	auto xAxis = cone.XAxis();
	auto yAxis = cone.YAxis();
	CHECK(xAxis.Direction().X() == Approx(-1.0));
	CHECK(yAxis.Direction().Y() == Approx(-1.0));
	AMCAX::Transformation3 tr;
	tr.SetTranslation(Vector3(1.0, 2.0, 3.0));
	cone.Transform(tr);
	Axis3 newXAxis = cone.Position().XAxis();
	CHECK(newXAxis.Location().X() == 26.0);
	CHECK(newXAxis.Location().Y() == 7.0);
	CHECK(newXAxis.Location().Z() == 3.0);
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API Cone& Scale(const Point3& point, double scale)	 @return The reference to self
	 @param scale The scale value
	 @param point The scaling center point
	 @brief Scale the cone by a point
,
 "output":#include<iostream>
#include "catch.hpp"
#include <common/FrameT.hpp>
#include <modeling/MakeFace.hpp>
#include <common/AxisT.hpp>
#include <common/FrameT.hpp>
#include <common/VectorT.hpp>
#include <math/Cone.hpp>
using namespace AMCAX;
using namespace std;
TEST_CASE("TestCone", "[math][Cone]")
{
	AMCAX::Frame3 frame;
	double radius = 5.0;
	double angle = M_PI / 4;
	AMCAX::Cone cone(frame, radius, angle);
	AMCAX::Point3 apex = cone.Apex();
	CHECK(apex.X() == 0.0);
	CHECK(apex.Y() == 0.0);
	CHECK(apex.Z() == Approx(-5.0));
	AMCAX::Axis3 axis = cone.Axis();
	std::cout << axis.Direction().X() << std::endl;
	std::cout << axis.Direction().Y() << std::endl;
	std::cout << axis.Direction().Z() << std::endl;
	CHECK(axis.Direction().X() == 0.0);
	CHECK(axis.Direction().Y() == 0.0);
	CHECK(axis.Direction().Z() == 1.0);
	double a1, a2, a3, b1, b2, b3, c1, c2, c3, d;
	cone.Coefficients(a1, a2, a3, b1, b2, b3, c1, c2, c3, d);
	std::cout << "a1: " << a1 << ", a2: " << a2 << ", a3: " << a3 << std::endl;
	std::cout << "b1: " << b1 << ", b2: " << b2 << ", b3: " << b3 << std::endl;
	std::cout << "c1: " << c1 << ", c2: " << c2 << ", c3: " << c3 << std::endl;
	std::cout << "d: " << d << std::endl;
	CHECK(a1 == 1.0);
	CHECK(a2 == 1.0);
	CHECK(a3 == Approx(-1.0));
	CHECK(b1 == 0);
	CHECK(b2 == 0);
	CHECK(b3 == 0);
	CHECK(c1 == 0);
	CHECK(c2 == 0);
	CHECK(c3 == Approx(-5.0));
	CHECK(d == -25.0);
	CHECK(cone.IsDirect() == true);
	CHECK(cone.Location().X() == 0.0);
	CHECK(cone.Location().Y() == 0.0);
	CHECK(cone.Location().Z() == 0.0);
	AMCAX::PointT<double, 3>mirrorPoint(5.0, 0.0, 0.0);
	cone.Mirror(mirrorPoint);
	auto mirroredLocation = cone.Location();
	CHECK(mirroredLocation.X() == 10.0);
	CHECK(mirroredLocation.Y() == 0.0);
	CHECK(mirroredLocation.Z() == 0.0);
	AMCAX::Frame3 coneFrame = cone.Position();
	CHECK(frame.Location().X() == 0.0);
	CHECK(frame.Location().Y() == 0.0);
	CHECK(frame.Location().Z() == 0.0);
	CHECK(cone.Radius() == 5.0);
	double  scaleCone = 2.0;
	cone.Scale(cone.Location(), scaleCone);
	CHECK(cone.Radius() == radius * 2.0);
	double semiCone = cone.SemiAngle();
	CHECK(semiCone == Approx(0.785398));
	const  Frame3& position = cone.Position();
	std::cout << position.XAxis() << std::endl;
	std::cout << position.YAxis() << std::endl;
	Direction3 zDirection(0.0, 0.0, 1.0);
	AMCAX::Point3  centerCone(0.0, 0.0, 0.0);
	Axis3 zAxis(centerCone, zDirection);
	cone.Rotated(zAxis, angle);
	AMCAX::Frame3 coneFrame2 = cone.Position();
	CHECK(coneFrame.Location().X() == 10.0);
	CHECK(coneFrame.Location().Y() == 0.0);
	CHECK(coneFrame.Location().Z() == 0.0);
	double scale = 2.0;
	cone.Scale(centerCone, scale);
	CHECK(cone.Radius() == radius * 4.0);
	double semiAngle = cone.SemiAngle();
	std::cout << semiAngle << std::endl;
	CHECK(semiAngle == Approx(0.785398));
	VectorT<double, 3> translationVector(5.0, 5.0, 0.0);
	cone.Translate(translationVector);
	CHECK(cone.Location().X() == 25.0);
	CHECK(cone.Location().Y() == 5.0);
	CHECK(cone.Location().Z() == 0.0);
	auto xAxis = cone.XAxis();
	auto yAxis = cone.YAxis();
	CHECK(xAxis.Direction().X() == Approx(-1.0));
	CHECK(yAxis.Direction().Y() == Approx(-1.0));
	AMCAX::Transformation3 tr;
	tr.SetTranslation(Vector3(1.0, 2.0, 3.0));
	cone.Transform(tr);
	Axis3 newXAxis = cone.Position().XAxis();
	CHECK(newXAxis.Location().X() == 26.0);
	CHECK(newXAxis.Location().Y() == 7.0);
	CHECK(newXAxis.Location().Z() == 3.0);
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API Cone& Transform(const Transformation3& tr)	 @return The reference to self
	 @param tr The transformation
	 @brief Transform the cone
,
 "output":#include<iostream>
#include "catch.hpp"
#include <common/FrameT.hpp>
#include <modeling/MakeFace.hpp>
#include <common/AxisT.hpp>
#include <common/FrameT.hpp>
#include <common/VectorT.hpp>
#include <math/Cone.hpp>
using namespace AMCAX;
using namespace std;
TEST_CASE("TestCone", "[math][Cone]")
{
	AMCAX::Frame3 frame;
	double radius = 5.0;
	double angle = M_PI / 4;
	AMCAX::Cone cone(frame, radius, angle);
	AMCAX::Point3 apex = cone.Apex();
	CHECK(apex.X() == 0.0);
	CHECK(apex.Y() == 0.0);
	CHECK(apex.Z() == Approx(-5.0));
	AMCAX::Axis3 axis = cone.Axis();
	std::cout << axis.Direction().X() << std::endl;
	std::cout << axis.Direction().Y() << std::endl;
	std::cout << axis.Direction().Z() << std::endl;
	CHECK(axis.Direction().X() == 0.0);
	CHECK(axis.Direction().Y() == 0.0);
	CHECK(axis.Direction().Z() == 1.0);
	double a1, a2, a3, b1, b2, b3, c1, c2, c3, d;
	cone.Coefficients(a1, a2, a3, b1, b2, b3, c1, c2, c3, d);
	std::cout << "a1: " << a1 << ", a2: " << a2 << ", a3: " << a3 << std::endl;
	std::cout << "b1: " << b1 << ", b2: " << b2 << ", b3: " << b3 << std::endl;
	std::cout << "c1: " << c1 << ", c2: " << c2 << ", c3: " << c3 << std::endl;
	std::cout << "d: " << d << std::endl;
	CHECK(a1 == 1.0);
	CHECK(a2 == 1.0);
	CHECK(a3 == Approx(-1.0));
	CHECK(b1 == 0);
	CHECK(b2 == 0);
	CHECK(b3 == 0);
	CHECK(c1 == 0);
	CHECK(c2 == 0);
	CHECK(c3 == Approx(-5.0));
	CHECK(d == -25.0);
	CHECK(cone.IsDirect() == true);
	CHECK(cone.Location().X() == 0.0);
	CHECK(cone.Location().Y() == 0.0);
	CHECK(cone.Location().Z() == 0.0);
	AMCAX::PointT<double, 3>mirrorPoint(5.0, 0.0, 0.0);
	cone.Mirror(mirrorPoint);
	auto mirroredLocation = cone.Location();
	CHECK(mirroredLocation.X() == 10.0);
	CHECK(mirroredLocation.Y() == 0.0);
	CHECK(mirroredLocation.Z() == 0.0);
	AMCAX::Frame3 coneFrame = cone.Position();
	CHECK(frame.Location().X() == 0.0);
	CHECK(frame.Location().Y() == 0.0);
	CHECK(frame.Location().Z() == 0.0);
	CHECK(cone.Radius() == 5.0);
	double  scaleCone = 2.0;
	cone.Scale(cone.Location(), scaleCone);
	CHECK(cone.Radius() == radius * 2.0);
	double semiCone = cone.SemiAngle();
	CHECK(semiCone == Approx(0.785398));
	const  Frame3& position = cone.Position();
	std::cout << position.XAxis() << std::endl;
	std::cout << position.YAxis() << std::endl;
	Direction3 zDirection(0.0, 0.0, 1.0);
	AMCAX::Point3  centerCone(0.0, 0.0, 0.0);
	Axis3 zAxis(centerCone, zDirection);
	cone.Rotated(zAxis, angle);
	AMCAX::Frame3 coneFrame2 = cone.Position();
	CHECK(coneFrame.Location().X() == 10.0);
	CHECK(coneFrame.Location().Y() == 0.0);
	CHECK(coneFrame.Location().Z() == 0.0);
	double scale = 2.0;
	cone.Scale(centerCone, scale);
	CHECK(cone.Radius() == radius * 4.0);
	double semiAngle = cone.SemiAngle();
	std::cout << semiAngle << std::endl;
	CHECK(semiAngle == Approx(0.785398));
	VectorT<double, 3> translationVector(5.0, 5.0, 0.0);
	cone.Translate(translationVector);
	CHECK(cone.Location().X() == 25.0);
	CHECK(cone.Location().Y() == 5.0);
	CHECK(cone.Location().Z() == 0.0);
	auto xAxis = cone.XAxis();
	auto yAxis = cone.YAxis();
	CHECK(xAxis.Direction().X() == Approx(-1.0));
	CHECK(yAxis.Direction().Y() == Approx(-1.0));
	AMCAX::Transformation3 tr;
	tr.SetTranslation(Vector3(1.0, 2.0, 3.0));
	cone.Transform(tr);
	Axis3 newXAxis = cone.Position().XAxis();
	CHECK(newXAxis.Location().X() == 26.0);
	CHECK(newXAxis.Location().Y() == 7.0);
	CHECK(newXAxis.Location().Z() == 3.0);
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":void SetRadius(double r)	 @param r The radius
	 @brief Set the radius of the circle
,
 "output":#include <math/CircleT.hpp>
#include <common/CoordT.hpp>
#include <common/TransformationType.hpp>
#include <common/DirectionT.hpp>
#include <common/PointT.hpp>
#include <common/Precision.hpp>
#include <common/CoordT.hpp>
#include <common/TransformationType.hpp>
#include <topology/TopoEdge.hpp>
#include <modeling/MakeEdge.hpp>
#include <topology/TopoWire.hpp>
#include <modeling/MakeWire.hpp>
#include <geometry/GlobalProperty.hpp>
#include <topology/BRepGlobalProperty.hpp>
#include<iostream>
#include "catch.hpp" 
using namespace std;
using namespace AMCAX;
TEST_CASE("TestCircle2D", "[math][Circle2D]")
{
	AMCAX::CircleT<double, 2> circle2D;
	AMCAX::Point2 center2D(0.0, 0.0);
	double redius2D = 5.0;
	double tol = 0.1;
	circle2D.SetLocation(center2D);
	circle2D.SetRadius(redius2D);
	double area2D = circle2D.Area();
	double length2D = circle2D.Length();
	AMCAX::Point2 retcenter2D = circle2D.Location();
	double retarea2D = M_PI * redius2D * redius2D;
	double retlength2D = 2 * M_PI * redius2D;
	std::cout << area2D << std::endl;
	std::cout << length2D << std::endl;
	std::cout << retcenter2D.X() << std::endl;
	std::cout << retcenter2D.Y() << std::endl;
	CHECK(area2D == retarea2D);
	CHECK(length2D == retlength2D);
	CHECK(retcenter2D.X() == center2D.X());
	CHECK(retcenter2D.Y() == center2D.Y());
	double a, b, c, d, e, f;
	circle2D.Coefficients(a, b, c, d, e, f);
	std::cout << a << std::endl;
	std::cout << b << std::endl;
	std::cout << c << std::endl;
	std::cout << d << std::endl;
	std::cout << e << std::endl;
	std::cout << f << std::endl;
	CHECK(a == 1);
	CHECK(b == 1);
	CHECK(c == 0);
	CHECK(d == 0);
	CHECK(e == 0);
	CHECK(f == -25);
	std::vector < AMCAX::Point2> testPoints = {
		AMCAX::Point2(3.0, 4.0),
		AMCAX::Point2(5.0, 0.0),
		AMCAX::Point2(4.9, 0.0),
		AMCAX::Point2(5.1, 0.0),
		AMCAX::Point2(6.0, 0.0)
	};
	for (const auto& point : testPoints)
	{
		double distanceToCenter = std::sqrt(point.X() * point.X() + point.Y() * point.Y());
		bool expectedIsInCircle = distanceToCenter <= 5.0 + tol;
		bool isInCircle = circle2D.Contains(point, tol);
		CHECK(isInCircle == expectedIsInCircle);
	}
	for (const auto& point : testPoints)
	{
		double distance = circle2D.Distance(point);
		double expectedDistance = std::abs(std::sqrt(std::pow(point.X() - center2D.X(), 2) + std::pow(point.Y() - center2D.Y(), 2)) - redius2D);
		CHECK(distance == expectedDistance);
	}
	AMCAX::AxisT<double, 2> mirrorAxis(AMCAX::Point2(0.0, 0.0), AMCAX::Direction2(0.0, 1.0));
	circle2D.Mirror(mirrorAxis);
	AMCAX::Point2 mirroredCenter = circle2D.Location();
	std::cout << "Mirrored circle center: (" << mirroredCenter.X() << ", " << mirroredCenter.Y() << ")" << std::endl;
	CHECK(mirroredCenter.X() == center2D.X());
	CHECK(mirroredCenter.Y() == center2D.Y());
	const AMCAX::FrameT<double, 2>& frame = circle2D.Position();
	AMCAX::Point2 rotationPoint(0.0, 0.0);
	double  rotationAngle = M_PI / 4;
	auto rotatedCircle = circle2D.Rotated(rotationPoint, rotationAngle);
	double cosAngle = cos(rotationAngle);
	double sinAngle = sin(rotationAngle);
	double newX = cosAngle * (center2D.X() - rotationPoint.X()) - sinAngle * (center2D.Y() - rotationPoint.Y()) + rotationPoint.X();
	double newY = sinAngle * (center2D.X() - rotationPoint.X()) + cosAngle * (center2D.Y() - rotationPoint.Y()) + rotationPoint.Y();
	auto rotatedCenter = rotatedCircle.Location();
	CHECK(newX == center2D.X());
	CHECK(newY == center2D.Y());
	AMCAX::Point2 scalingCenter(0.0, 0.0);
	double scalingFactor = 2.0;
	auto scaledCircle = circle2D.Scale(scalingCenter, scalingFactor);
	double scaledRadius = scaledCircle.Radius();
	double expectedScaledRadius = redius2D * scalingFactor;
	CHECK(std::abs(scaledRadius - expectedScaledRadius) < 1e-6);
	AMCAX::VectorT<double, 2> translationVector(2.0, 3.0);
	auto translatedCircle = circle2D.Translated(translationVector);
	auto translatedCenter = translatedCircle.Location();
	double translatedX = center2D.X() + translationVector.X();
	CHECK(translatedX == translatedCenter.X());
	auto xAxis = circle2D.XAxis();
	auto directionAxis = xAxis.Direction();
	CHECK(directionAxis.X() == -1.0);
	CHECK(directionAxis.Y() == 0.0);
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] double Radius()	 @return The radius
	 @brief Get the radius
,
 "output":#include <math/CircleT.hpp>
#include <common/CoordT.hpp>
#include <common/TransformationType.hpp>
#include <common/DirectionT.hpp>
#include <common/PointT.hpp>
#include <common/Precision.hpp>
#include <common/CoordT.hpp>
#include <common/TransformationType.hpp>
#include <topology/TopoEdge.hpp>
#include <modeling/MakeEdge.hpp>
#include <topology/TopoWire.hpp>
#include <modeling/MakeWire.hpp>
#include <geometry/GlobalProperty.hpp>
#include <topology/BRepGlobalProperty.hpp>
#include<iostream>
#include "catch.hpp" 
using namespace std;
using namespace AMCAX;
TEST_CASE("TestCircle3D", "[math][Circle3D]")
{
	AMCAX::Circle3 circle3D;
	AMCAX::Point3  center3D(0.0, 0.0, 0.0);
	double radius3D = 5.0;
	double tol = 0.1;
	circle3D.SetLocation(center3D);
	circle3D.SetRadius(radius3D);
	double area = circle3D.Area();
	auto axis = circle3D.Axis();
	AMCAX::Point3 expectedDirection(0.0, 0.0, 1.0);
	auto direction = axis.Direction();
	CHECK(area == Approx(78.5398));
	CHECK(direction.X() == Approx(expectedDirection.X()).margin(tol));
	CHECK(direction.Y() == Approx(expectedDirection.Y()).margin(tol));
	CHECK(direction.Z() == Approx(expectedDirection.Z()).margin(tol));
	std::vector <AMCAX::Point3> test3DPoints = {
		AMCAX::Point3(0.0, 0.0, 0.0),
		AMCAX::Point3(4.0, 0.0, 0.0),
	};
	for (const auto& point : test3DPoints)
	{
		double distanceToCenter = std::sqrt(std::pow(point.X() - center3D.X(), 2) + std::pow(point.Y() - center3D.Y(), 2) + std::pow(point.Z() - center3D.Z(), 2));
		bool expectedIsCircle = distanceToCenter <= 5.0 + tol;
		bool isInCircle = circle3D.Contains(point, tol);
		CHECK(!isInCircle == expectedIsCircle);
	}
	AMCAX::PointT<double, 3>  pointOutside(10.0, 0.0, 0.0);
	double expectedDistance = 5.0;
	CHECK(circle3D.Distance(pointOutside) == Approx(expectedDistance));
	double length = circle3D.Length();
	CHECK(length == Approx(31.4159));
	auto location = circle3D.Location();
	CHECK(location.X() == Approx(0.0));
	CHECK(location.Y() == Approx(0.0));
	CHECK(location.Z() == Approx(0.0));
	AMCAX::PointT<double, 3> mirrorPoint(1.0, 0.0, 0.0);
	circle3D.Mirror(mirrorPoint);
	auto mirroredLocation = circle3D.Location();
	CHECK(mirroredLocation.X() == Approx(2.0));
	CHECK(mirroredLocation.Y() == Approx(0.0));
	CHECK(mirroredLocation.Z() == Approx(0.0));
	auto position = circle3D.Position();   
	double r = circle3D.Radius();
	CHECK(r == 5.0);
	Direction3 zDirection(0.0, 0.0, 1.0);
	Axis3 zAxis(center3D, zDirection);
	Transformation3 rotation;
	rotation.SetRotation(zAxis, M_PI / 2);  
	Point3 newCenter1 = center3D.Transformed(rotation);
	CHECK(newCenter1.X() == 0.0);
	CHECK(newCenter1.Y() == 0.0);
	CHECK(newCenter1.Z() == 0.0);
	double angle = M_PI / 2;
	circle3D.Rotated(zAxis, angle);
	AMCAX::Frame3 frame = circle3D.Position();
	CHECK(frame.Location().X() == 2.0);
	CHECK(frame.Location().Y() == 0.0);
	CHECK(frame.Location().Z() == 0.0);
	double scale = 2.0;
	circle3D.Scale(center3D, scale);
	CHECK(circle3D.Radius() == radius3D * 2.0);
	AMCAX::PointT<double, 3> insidePoint(3.0, 4.0, 0.0);
	AMCAX::PointT<double, 3> onCirclePoint(5.0, 0.0, 0.0);
	AMCAX::PointT<double, 3> outsidePoint(8.0, 6.0, 0.0);
	double insideSquaredDistance = circle3D.SquaredDistance(insidePoint);
	double onCircleSquaredDistance = circle3D.SquaredDistance(onCirclePoint);
	double outsideSquaredDistance = circle3D.SquaredDistance(outsidePoint);
	CHECK(insideSquaredDistance == Approx(34.5378));
	CHECK(onCircleSquaredDistance == 81.0);
	CHECK(outsideSquaredDistance == Approx(7.7779));
	VectorT<double, 3> translationVector(5.0, 5.0, 0.0);
	circle3D.Translate(translationVector);
	CHECK(circle3D.Location().X() == 9.0);
	CHECK(circle3D.Location().Y() == 5.0);
	CHECK(circle3D.Location().Z() == 0.0);
	auto xAxis = circle3D.XAxis();
	auto yAxis = circle3D.YAxis();
	CHECK(xAxis.Direction().X() == Approx(-1.0));
	CHECK(yAxis.Direction().Y() == Approx(-1.0));
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] double Distance(const PointT<double, DIM>& p)	 @return The distance from the point to the circle
	 @param p The point
	 @brief Compute the distance from a point to the circle
,
 "output":#include <math/CircleT.hpp>
#include <common/CoordT.hpp>
#include <common/TransformationType.hpp>
#include <common/DirectionT.hpp>
#include <common/PointT.hpp>
#include <common/Precision.hpp>
#include <common/CoordT.hpp>
#include <common/TransformationType.hpp>
#include <topology/TopoEdge.hpp>
#include <modeling/MakeEdge.hpp>
#include <topology/TopoWire.hpp>
#include <modeling/MakeWire.hpp>
#include <geometry/GlobalProperty.hpp>
#include <topology/BRepGlobalProperty.hpp>
#include<iostream>
#include "catch.hpp" 
using namespace std;
using namespace AMCAX;
TEST_CASE("TestCircle2D", "[math][Circle2D]")
{
	AMCAX::CircleT<double, 2> circle2D;
	AMCAX::Point2 center2D(0.0, 0.0);
	double redius2D = 5.0;
	double tol = 0.1;
	circle2D.SetLocation(center2D);
	circle2D.SetRadius(redius2D);
	double area2D = circle2D.Area();
	double length2D = circle2D.Length();
	AMCAX::Point2 retcenter2D = circle2D.Location();
	double retarea2D = M_PI * redius2D * redius2D;
	double retlength2D = 2 * M_PI * redius2D;
	std::cout << area2D << std::endl;
	std::cout << length2D << std::endl;
	std::cout << retcenter2D.X() << std::endl;
	std::cout << retcenter2D.Y() << std::endl;
	CHECK(area2D == retarea2D);
	CHECK(length2D == retlength2D);
	CHECK(retcenter2D.X() == center2D.X());
	CHECK(retcenter2D.Y() == center2D.Y());
	double a, b, c, d, e, f;
	circle2D.Coefficients(a, b, c, d, e, f);
	std::cout << a << std::endl;
	std::cout << b << std::endl;
	std::cout << c << std::endl;
	std::cout << d << std::endl;
	std::cout << e << std::endl;
	std::cout << f << std::endl;
	CHECK(a == 1);
	CHECK(b == 1);
	CHECK(c == 0);
	CHECK(d == 0);
	CHECK(e == 0);
	CHECK(f == -25);
	std::vector < AMCAX::Point2> testPoints = {
		AMCAX::Point2(3.0, 4.0),
		AMCAX::Point2(5.0, 0.0),
		AMCAX::Point2(4.9, 0.0),
		AMCAX::Point2(5.1, 0.0),
		AMCAX::Point2(6.0, 0.0)
	};
	for (const auto& point : testPoints)
	{
		double distanceToCenter = std::sqrt(point.X() * point.X() + point.Y() * point.Y());
		bool expectedIsInCircle = distanceToCenter <= 5.0 + tol;
		bool isInCircle = circle2D.Contains(point, tol);
		CHECK(isInCircle == expectedIsInCircle);
	}
	for (const auto& point : testPoints)
	{
		double distance = circle2D.Distance(point);
		double expectedDistance = std::abs(std::sqrt(std::pow(point.X() - center2D.X(), 2) + std::pow(point.Y() - center2D.Y(), 2)) - redius2D);
		CHECK(distance == expectedDistance);
	}
	AMCAX::AxisT<double, 2> mirrorAxis(AMCAX::Point2(0.0, 0.0), AMCAX::Direction2(0.0, 1.0));
	circle2D.Mirror(mirrorAxis);
	AMCAX::Point2 mirroredCenter = circle2D.Location();
	std::cout << "Mirrored circle center: (" << mirroredCenter.X() << ", " << mirroredCenter.Y() << ")" << std::endl;
	CHECK(mirroredCenter.X() == center2D.X());
	CHECK(mirroredCenter.Y() == center2D.Y());
	const AMCAX::FrameT<double, 2>& frame = circle2D.Position();
	AMCAX::Point2 rotationPoint(0.0, 0.0);
	double  rotationAngle = M_PI / 4;
	auto rotatedCircle = circle2D.Rotated(rotationPoint, rotationAngle);
	double cosAngle = cos(rotationAngle);
	double sinAngle = sin(rotationAngle);
	double newX = cosAngle * (center2D.X() - rotationPoint.X()) - sinAngle * (center2D.Y() - rotationPoint.Y()) + rotationPoint.X();
	double newY = sinAngle * (center2D.X() - rotationPoint.X()) + cosAngle * (center2D.Y() - rotationPoint.Y()) + rotationPoint.Y();
	auto rotatedCenter = rotatedCircle.Location();
	CHECK(newX == center2D.X());
	CHECK(newY == center2D.Y());
	AMCAX::Point2 scalingCenter(0.0, 0.0);
	double scalingFactor = 2.0;
	auto scaledCircle = circle2D.Scale(scalingCenter, scalingFactor);
	double scaledRadius = scaledCircle.Radius();
	double expectedScaledRadius = redius2D * scalingFactor;
	CHECK(std::abs(scaledRadius - expectedScaledRadius) < 1e-6);
	AMCAX::VectorT<double, 2> translationVector(2.0, 3.0);
	auto translatedCircle = circle2D.Translated(translationVector);
	auto translatedCenter = translatedCircle.Location();
	double translatedX = center2D.X() + translationVector.X();
	CHECK(translatedX == translatedCenter.X());
	auto xAxis = circle2D.XAxis();
	auto directionAxis = xAxis.Direction();
	CHECK(directionAxis.X() == -1.0);
	CHECK(directionAxis.Y() == 0.0);
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] double SquaredDistance(const PointT<double, DIM>& p)	 @return The squared distance from the point to the circle
	 @param p The point
	 @brief Compute the squared distance from a point to the circle
,
 "output":#include <math/CircleT.hpp>
#include <common/CoordT.hpp>
#include <common/TransformationType.hpp>
#include <common/DirectionT.hpp>
#include <common/PointT.hpp>
#include <common/Precision.hpp>
#include <common/CoordT.hpp>
#include <common/TransformationType.hpp>
#include <topology/TopoEdge.hpp>
#include <modeling/MakeEdge.hpp>
#include <topology/TopoWire.hpp>
#include <modeling/MakeWire.hpp>
#include <geometry/GlobalProperty.hpp>
#include <topology/BRepGlobalProperty.hpp>
#include<iostream>
#include "catch.hpp" 
using namespace std;
using namespace AMCAX;
TEST_CASE("TestCircle3D", "[math][Circle3D]")
{
	AMCAX::Circle3 circle3D;
	AMCAX::Point3  center3D(0.0, 0.0, 0.0);
	double radius3D = 5.0;
	double tol = 0.1;
	circle3D.SetLocation(center3D);
	circle3D.SetRadius(radius3D);
	double area = circle3D.Area();
	auto axis = circle3D.Axis();
	AMCAX::Point3 expectedDirection(0.0, 0.0, 1.0);
	auto direction = axis.Direction();
	CHECK(area == Approx(78.5398));
	CHECK(direction.X() == Approx(expectedDirection.X()).margin(tol));
	CHECK(direction.Y() == Approx(expectedDirection.Y()).margin(tol));
	CHECK(direction.Z() == Approx(expectedDirection.Z()).margin(tol));
	std::vector <AMCAX::Point3> test3DPoints = {
		AMCAX::Point3(0.0, 0.0, 0.0),
		AMCAX::Point3(4.0, 0.0, 0.0),
	};
	for (const auto& point : test3DPoints)
	{
		double distanceToCenter = std::sqrt(std::pow(point.X() - center3D.X(), 2) + std::pow(point.Y() - center3D.Y(), 2) + std::pow(point.Z() - center3D.Z(), 2));
		bool expectedIsCircle = distanceToCenter <= 5.0 + tol;
		bool isInCircle = circle3D.Contains(point, tol);
		CHECK(!isInCircle == expectedIsCircle);
	}
	AMCAX::PointT<double, 3>  pointOutside(10.0, 0.0, 0.0);
	double expectedDistance = 5.0;
	CHECK(circle3D.Distance(pointOutside) == Approx(expectedDistance));
	double length = circle3D.Length();
	CHECK(length == Approx(31.4159));
	auto location = circle3D.Location();
	CHECK(location.X() == Approx(0.0));
	CHECK(location.Y() == Approx(0.0));
	CHECK(location.Z() == Approx(0.0));
	AMCAX::PointT<double, 3> mirrorPoint(1.0, 0.0, 0.0);
	circle3D.Mirror(mirrorPoint);
	auto mirroredLocation = circle3D.Location();
	CHECK(mirroredLocation.X() == Approx(2.0));
	CHECK(mirroredLocation.Y() == Approx(0.0));
	CHECK(mirroredLocation.Z() == Approx(0.0));
	auto position = circle3D.Position();   
	double r = circle3D.Radius();
	CHECK(r == 5.0);
	Direction3 zDirection(0.0, 0.0, 1.0);
	Axis3 zAxis(center3D, zDirection);
	Transformation3 rotation;
	rotation.SetRotation(zAxis, M_PI / 2);  
	Point3 newCenter1 = center3D.Transformed(rotation);
	CHECK(newCenter1.X() == 0.0);
	CHECK(newCenter1.Y() == 0.0);
	CHECK(newCenter1.Z() == 0.0);
	double angle = M_PI / 2;
	circle3D.Rotated(zAxis, angle);
	AMCAX::Frame3 frame = circle3D.Position();
	CHECK(frame.Location().X() == 2.0);
	CHECK(frame.Location().Y() == 0.0);
	CHECK(frame.Location().Z() == 0.0);
	double scale = 2.0;
	circle3D.Scale(center3D, scale);
	CHECK(circle3D.Radius() == radius3D * 2.0);
	AMCAX::PointT<double, 3> insidePoint(3.0, 4.0, 0.0);
	AMCAX::PointT<double, 3> onCirclePoint(5.0, 0.0, 0.0);
	AMCAX::PointT<double, 3> outsidePoint(8.0, 6.0, 0.0);
	double insideSquaredDistance = circle3D.SquaredDistance(insidePoint);
	double onCircleSquaredDistance = circle3D.SquaredDistance(onCirclePoint);
	double outsideSquaredDistance = circle3D.SquaredDistance(outsidePoint);
	CHECK(insideSquaredDistance == Approx(34.5378));
	CHECK(onCircleSquaredDistance == 81.0);
	CHECK(outsideSquaredDistance == Approx(7.7779));
	VectorT<double, 3> translationVector(5.0, 5.0, 0.0);
	circle3D.Translate(translationVector);
	CHECK(circle3D.Location().X() == 9.0);
	CHECK(circle3D.Location().Y() == 5.0);
	CHECK(circle3D.Location().Z() == 0.0);
	auto xAxis = circle3D.XAxis();
	auto yAxis = circle3D.YAxis();
	CHECK(xAxis.Direction().X() == Approx(-1.0));
	CHECK(yAxis.Direction().Y() == Approx(-1.0));
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":CircleS& Scale(const PointT<double, DIM>& p, double scale)	 @return The reference to self
	 @param scale The scale value
	 @param p The scaling center point
	 @brief Scale the circle by a center point
,
 "output":#include <math/CircleT.hpp>
#include <common/CoordT.hpp>
#include <common/TransformationType.hpp>
#include <common/DirectionT.hpp>
#include <common/PointT.hpp>
#include <common/Precision.hpp>
#include <common/CoordT.hpp>
#include <common/TransformationType.hpp>
#include <topology/TopoEdge.hpp>
#include <modeling/MakeEdge.hpp>
#include <topology/TopoWire.hpp>
#include <modeling/MakeWire.hpp>
#include <geometry/GlobalProperty.hpp>
#include <topology/BRepGlobalProperty.hpp>
#include<iostream>
#include "catch.hpp" 
using namespace std;
using namespace AMCAX;
TEST_CASE("TestCircle2D", "[math][Circle2D]")
{
	AMCAX::CircleT<double, 2> circle2D;
	AMCAX::Point2 center2D(0.0, 0.0);
	double redius2D = 5.0;
	double tol = 0.1;
	circle2D.SetLocation(center2D);
	circle2D.SetRadius(redius2D);
	double area2D = circle2D.Area();
	double length2D = circle2D.Length();
	AMCAX::Point2 retcenter2D = circle2D.Location();
	double retarea2D = M_PI * redius2D * redius2D;
	double retlength2D = 2 * M_PI * redius2D;
	std::cout << area2D << std::endl;
	std::cout << length2D << std::endl;
	std::cout << retcenter2D.X() << std::endl;
	std::cout << retcenter2D.Y() << std::endl;
	CHECK(area2D == retarea2D);
	CHECK(length2D == retlength2D);
	CHECK(retcenter2D.X() == center2D.X());
	CHECK(retcenter2D.Y() == center2D.Y());
	double a, b, c, d, e, f;
	circle2D.Coefficients(a, b, c, d, e, f);
	std::cout << a << std::endl;
	std::cout << b << std::endl;
	std::cout << c << std::endl;
	std::cout << d << std::endl;
	std::cout << e << std::endl;
	std::cout << f << std::endl;
	CHECK(a == 1);
	CHECK(b == 1);
	CHECK(c == 0);
	CHECK(d == 0);
	CHECK(e == 0);
	CHECK(f == -25);
	std::vector < AMCAX::Point2> testPoints = {
		AMCAX::Point2(3.0, 4.0),
		AMCAX::Point2(5.0, 0.0),
		AMCAX::Point2(4.9, 0.0),
		AMCAX::Point2(5.1, 0.0),
		AMCAX::Point2(6.0, 0.0)
	};
	for (const auto& point : testPoints)
	{
		double distanceToCenter = std::sqrt(point.X() * point.X() + point.Y() * point.Y());
		bool expectedIsInCircle = distanceToCenter <= 5.0 + tol;
		bool isInCircle = circle2D.Contains(point, tol);
		CHECK(isInCircle == expectedIsInCircle);
	}
	for (const auto& point : testPoints)
	{
		double distance = circle2D.Distance(point);
		double expectedDistance = std::abs(std::sqrt(std::pow(point.X() - center2D.X(), 2) + std::pow(point.Y() - center2D.Y(), 2)) - redius2D);
		CHECK(distance == expectedDistance);
	}
	AMCAX::AxisT<double, 2> mirrorAxis(AMCAX::Point2(0.0, 0.0), AMCAX::Direction2(0.0, 1.0));
	circle2D.Mirror(mirrorAxis);
	AMCAX::Point2 mirroredCenter = circle2D.Location();
	std::cout << "Mirrored circle center: (" << mirroredCenter.X() << ", " << mirroredCenter.Y() << ")" << std::endl;
	CHECK(mirroredCenter.X() == center2D.X());
	CHECK(mirroredCenter.Y() == center2D.Y());
	const AMCAX::FrameT<double, 2>& frame = circle2D.Position();
	AMCAX::Point2 rotationPoint(0.0, 0.0);
	double  rotationAngle = M_PI / 4;
	auto rotatedCircle = circle2D.Rotated(rotationPoint, rotationAngle);
	double cosAngle = cos(rotationAngle);
	double sinAngle = sin(rotationAngle);
	double newX = cosAngle * (center2D.X() - rotationPoint.X()) - sinAngle * (center2D.Y() - rotationPoint.Y()) + rotationPoint.X();
	double newY = sinAngle * (center2D.X() - rotationPoint.X()) + cosAngle * (center2D.Y() - rotationPoint.Y()) + rotationPoint.Y();
	auto rotatedCenter = rotatedCircle.Location();
	CHECK(newX == center2D.X());
	CHECK(newY == center2D.Y());
	AMCAX::Point2 scalingCenter(0.0, 0.0);
	double scalingFactor = 2.0;
	auto scaledCircle = circle2D.Scale(scalingCenter, scalingFactor);
	double scaledRadius = scaledCircle.Radius();
	double expectedScaledRadius = redius2D * scalingFactor;
	CHECK(std::abs(scaledRadius - expectedScaledRadius) < 1e-6);
	AMCAX::VectorT<double, 2> translationVector(2.0, 3.0);
	auto translatedCircle = circle2D.Translated(translationVector);
	auto translatedCenter = translatedCircle.Location();
	double translatedX = center2D.X() + translationVector.X();
	CHECK(translatedX == translatedCenter.X());
	auto xAxis = circle2D.XAxis();
	auto directionAxis = xAxis.Direction();
	CHECK(directionAxis.X() == -1.0);
	CHECK(directionAxis.Y() == 0.0);
}
}
,
{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":void SetRadius(double r)	 @param r The radius
	 @brief Set the radius of the circle
,
 "output":#include <math/CircleT.hpp>
#include <common/CoordT.hpp>
#include <common/TransformationType.hpp>
#include <common/DirectionT.hpp>
#include <common/PointT.hpp>
#include <common/Precision.hpp>
#include <common/CoordT.hpp>
#include <common/TransformationType.hpp>
#include <topology/TopoEdge.hpp>
#include <modeling/MakeEdge.hpp>
#include <topology/TopoWire.hpp>
#include <modeling/MakeWire.hpp>
#include <geometry/GlobalProperty.hpp>
#include <topology/BRepGlobalProperty.hpp>
#include<iostream>
#include "catch.hpp" 
using namespace std;
using namespace AMCAX;
TEST_CASE("TestCircle2D", "[math][Circle2D]")
{
	AMCAX::CircleT<double, 2> circle2D;
	AMCAX::Point2 center2D(0.0, 0.0);
	double redius2D = 5.0;
	double tol = 0.1;
	circle2D.SetLocation(center2D);
	circle2D.SetRadius(redius2D);
	double area2D = circle2D.Area();
	double length2D = circle2D.Length();
	AMCAX::Point2 retcenter2D = circle2D.Location();
	double retarea2D = M_PI * redius2D * redius2D;
	double retlength2D = 2 * M_PI * redius2D;
	std::cout << area2D << std::endl;
	std::cout << length2D << std::endl;
	std::cout << retcenter2D.X() << std::endl;
	std::cout << retcenter2D.Y() << std::endl;
	CHECK(area2D == retarea2D);
	CHECK(length2D == retlength2D);
	CHECK(retcenter2D.X() == center2D.X());
	CHECK(retcenter2D.Y() == center2D.Y());
	double a, b, c, d, e, f;
	circle2D.Coefficients(a, b, c, d, e, f);
	std::cout << a << std::endl;
	std::cout << b << std::endl;
	std::cout << c << std::endl;
	std::cout << d << std::endl;
	std::cout << e << std::endl;
	std::cout << f << std::endl;
	CHECK(a == 1);
	CHECK(b == 1);
	CHECK(c == 0);
	CHECK(d == 0);
	CHECK(e == 0);
	CHECK(f == -25);
	std::vector < AMCAX::Point2> testPoints = {
		AMCAX::Point2(3.0, 4.0),
		AMCAX::Point2(5.0, 0.0),
		AMCAX::Point2(4.9, 0.0),
		AMCAX::Point2(5.1, 0.0),
		AMCAX::Point2(6.0, 0.0)
	};
	for (const auto& point : testPoints)
	{
		double distanceToCenter = std::sqrt(point.X() * point.X() + point.Y() * point.Y());
		bool expectedIsInCircle = distanceToCenter <= 5.0 + tol;
		bool isInCircle = circle2D.Contains(point, tol);
		CHECK(isInCircle == expectedIsInCircle);
	}
	for (const auto& point : testPoints)
	{
		double distance = circle2D.Distance(point);
		double expectedDistance = std::abs(std::sqrt(std::pow(point.X() - center2D.X(), 2) + std::pow(point.Y() - center2D.Y(), 2)) - redius2D);
		CHECK(distance == expectedDistance);
	}
	AMCAX::AxisT<double, 2> mirrorAxis(AMCAX::Point2(0.0, 0.0), AMCAX::Direction2(0.0, 1.0));
	circle2D.Mirror(mirrorAxis);
	AMCAX::Point2 mirroredCenter = circle2D.Location();
	std::cout << "Mirrored circle center: (" << mirroredCenter.X() << ", " << mirroredCenter.Y() << ")" << std::endl;
	CHECK(mirroredCenter.X() == center2D.X());
	CHECK(mirroredCenter.Y() == center2D.Y());
	const AMCAX::FrameT<double, 2>& frame = circle2D.Position();
	AMCAX::Point2 rotationPoint(0.0, 0.0);
	double  rotationAngle = M_PI / 4;
	auto rotatedCircle = circle2D.Rotated(rotationPoint, rotationAngle);
	double cosAngle = cos(rotationAngle);
	double sinAngle = sin(rotationAngle);
	double newX = cosAngle * (center2D.X() - rotationPoint.X()) - sinAngle * (center2D.Y() - rotationPoint.Y()) + rotationPoint.X();
	double newY = sinAngle * (center2D.X() - rotationPoint.X()) + cosAngle * (center2D.Y() - rotationPoint.Y()) + rotationPoint.Y();
	auto rotatedCenter = rotatedCircle.Location();
	CHECK(newX == center2D.X());
	CHECK(newY == center2D.Y());
	AMCAX::Point2 scalingCenter(0.0, 0.0);
	double scalingFactor = 2.0;
	auto scaledCircle = circle2D.Scale(scalingCenter, scalingFactor);
	double scaledRadius = scaledCircle.Radius();
	double expectedScaledRadius = redius2D * scalingFactor;
	CHECK(std::abs(scaledRadius - expectedScaledRadius) < 1e-6);
	AMCAX::VectorT<double, 2> translationVector(2.0, 3.0);
	auto translatedCircle = circle2D.Translated(translationVector);
	auto translatedCenter = translatedCircle.Location();
	double translatedX = center2D.X() + translationVector.X();
	CHECK(translatedX == translatedCenter.X());
	auto xAxis = circle2D.XAxis();
	auto directionAxis = xAxis.Direction();
	CHECK(directionAxis.X() == -1.0);
	CHECK(directionAxis.Y() == 0.0);
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] double Radius()	 @return The radius
	 @brief Get the radius
,
 "output":#include <math/CircleT.hpp>
#include <common/CoordT.hpp>
#include <common/TransformationType.hpp>
#include <common/DirectionT.hpp>
#include <common/PointT.hpp>
#include <common/Precision.hpp>
#include <common/CoordT.hpp>
#include <common/TransformationType.hpp>
#include <topology/TopoEdge.hpp>
#include <modeling/MakeEdge.hpp>
#include <topology/TopoWire.hpp>
#include <modeling/MakeWire.hpp>
#include <geometry/GlobalProperty.hpp>
#include <topology/BRepGlobalProperty.hpp>
#include<iostream>
#include "catch.hpp" 
using namespace std;
using namespace AMCAX;
TEST_CASE("TestCircle3D", "[math][Circle3D]")
{
	AMCAX::Circle3 circle3D;
	AMCAX::Point3  center3D(0.0, 0.0, 0.0);
	double radius3D = 5.0;
	double tol = 0.1;
	circle3D.SetLocation(center3D);
	circle3D.SetRadius(radius3D);
	double area = circle3D.Area();
	auto axis = circle3D.Axis();
	AMCAX::Point3 expectedDirection(0.0, 0.0, 1.0);
	auto direction = axis.Direction();
	CHECK(area == Approx(78.5398));
	CHECK(direction.X() == Approx(expectedDirection.X()).margin(tol));
	CHECK(direction.Y() == Approx(expectedDirection.Y()).margin(tol));
	CHECK(direction.Z() == Approx(expectedDirection.Z()).margin(tol));
	std::vector <AMCAX::Point3> test3DPoints = {
		AMCAX::Point3(0.0, 0.0, 0.0),
		AMCAX::Point3(4.0, 0.0, 0.0),
	};
	for (const auto& point : test3DPoints)
	{
		double distanceToCenter = std::sqrt(std::pow(point.X() - center3D.X(), 2) + std::pow(point.Y() - center3D.Y(), 2) + std::pow(point.Z() - center3D.Z(), 2));
		bool expectedIsCircle = distanceToCenter <= 5.0 + tol;
		bool isInCircle = circle3D.Contains(point, tol);
		CHECK(!isInCircle == expectedIsCircle);
	}
	AMCAX::PointT<double, 3>  pointOutside(10.0, 0.0, 0.0);
	double expectedDistance = 5.0;
	CHECK(circle3D.Distance(pointOutside) == Approx(expectedDistance));
	double length = circle3D.Length();
	CHECK(length == Approx(31.4159));
	auto location = circle3D.Location();
	CHECK(location.X() == Approx(0.0));
	CHECK(location.Y() == Approx(0.0));
	CHECK(location.Z() == Approx(0.0));
	AMCAX::PointT<double, 3> mirrorPoint(1.0, 0.0, 0.0);
	circle3D.Mirror(mirrorPoint);
	auto mirroredLocation = circle3D.Location();
	CHECK(mirroredLocation.X() == Approx(2.0));
	CHECK(mirroredLocation.Y() == Approx(0.0));
	CHECK(mirroredLocation.Z() == Approx(0.0));
	auto position = circle3D.Position();   
	double r = circle3D.Radius();
	CHECK(r == 5.0);
	Direction3 zDirection(0.0, 0.0, 1.0);
	Axis3 zAxis(center3D, zDirection);
	Transformation3 rotation;
	rotation.SetRotation(zAxis, M_PI / 2);  
	Point3 newCenter1 = center3D.Transformed(rotation);
	CHECK(newCenter1.X() == 0.0);
	CHECK(newCenter1.Y() == 0.0);
	CHECK(newCenter1.Z() == 0.0);
	double angle = M_PI / 2;
	circle3D.Rotated(zAxis, angle);
	AMCAX::Frame3 frame = circle3D.Position();
	CHECK(frame.Location().X() == 2.0);
	CHECK(frame.Location().Y() == 0.0);
	CHECK(frame.Location().Z() == 0.0);
	double scale = 2.0;
	circle3D.Scale(center3D, scale);
	CHECK(circle3D.Radius() == radius3D * 2.0);
	AMCAX::PointT<double, 3> insidePoint(3.0, 4.0, 0.0);
	AMCAX::PointT<double, 3> onCirclePoint(5.0, 0.0, 0.0);
	AMCAX::PointT<double, 3> outsidePoint(8.0, 6.0, 0.0);
	double insideSquaredDistance = circle3D.SquaredDistance(insidePoint);
	double onCircleSquaredDistance = circle3D.SquaredDistance(onCirclePoint);
	double outsideSquaredDistance = circle3D.SquaredDistance(outsidePoint);
	CHECK(insideSquaredDistance == Approx(34.5378));
	CHECK(onCircleSquaredDistance == 81.0);
	CHECK(outsideSquaredDistance == Approx(7.7779));
	VectorT<double, 3> translationVector(5.0, 5.0, 0.0);
	circle3D.Translate(translationVector);
	CHECK(circle3D.Location().X() == 9.0);
	CHECK(circle3D.Location().Y() == 5.0);
	CHECK(circle3D.Location().Z() == 0.0);
	auto xAxis = circle3D.XAxis();
	auto yAxis = circle3D.YAxis();
	CHECK(xAxis.Direction().X() == Approx(-1.0));
	CHECK(yAxis.Direction().Y() == Approx(-1.0));
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] double Length()	 @return The length of the circle
	 @brief Get the length of the circle
,
 "output":#include <math/CircleT.hpp>
#include <common/CoordT.hpp>
#include <common/TransformationType.hpp>
#include <common/DirectionT.hpp>
#include <common/PointT.hpp>
#include <common/Precision.hpp>
#include <common/CoordT.hpp>
#include <common/TransformationType.hpp>
#include <topology/TopoEdge.hpp>
#include <modeling/MakeEdge.hpp>
#include <topology/TopoWire.hpp>
#include <modeling/MakeWire.hpp>
#include <geometry/GlobalProperty.hpp>
#include <topology/BRepGlobalProperty.hpp>
#include<iostream>
#include "catch.hpp" 
using namespace std;
using namespace AMCAX;
TEST_CASE("TestCircle2D", "[math][Circle2D]")
{
	AMCAX::CircleT<double, 2> circle2D;
	AMCAX::Point2 center2D(0.0, 0.0);
	double redius2D = 5.0;
	double tol = 0.1;
	circle2D.SetLocation(center2D);
	circle2D.SetRadius(redius2D);
	double area2D = circle2D.Area();
	double length2D = circle2D.Length();
	AMCAX::Point2 retcenter2D = circle2D.Location();
	double retarea2D = M_PI * redius2D * redius2D;
	double retlength2D = 2 * M_PI * redius2D;
	std::cout << area2D << std::endl;
	std::cout << length2D << std::endl;
	std::cout << retcenter2D.X() << std::endl;
	std::cout << retcenter2D.Y() << std::endl;
	CHECK(area2D == retarea2D);
	CHECK(length2D == retlength2D);
	CHECK(retcenter2D.X() == center2D.X());
	CHECK(retcenter2D.Y() == center2D.Y());
	double a, b, c, d, e, f;
	circle2D.Coefficients(a, b, c, d, e, f);
	std::cout << a << std::endl;
	std::cout << b << std::endl;
	std::cout << c << std::endl;
	std::cout << d << std::endl;
	std::cout << e << std::endl;
	std::cout << f << std::endl;
	CHECK(a == 1);
	CHECK(b == 1);
	CHECK(c == 0);
	CHECK(d == 0);
	CHECK(e == 0);
	CHECK(f == -25);
	std::vector < AMCAX::Point2> testPoints = {
		AMCAX::Point2(3.0, 4.0),
		AMCAX::Point2(5.0, 0.0),
		AMCAX::Point2(4.9, 0.0),
		AMCAX::Point2(5.1, 0.0),
		AMCAX::Point2(6.0, 0.0)
	};
	for (const auto& point : testPoints)
	{
		double distanceToCenter = std::sqrt(point.X() * point.X() + point.Y() * point.Y());
		bool expectedIsInCircle = distanceToCenter <= 5.0 + tol;
		bool isInCircle = circle2D.Contains(point, tol);
		CHECK(isInCircle == expectedIsInCircle);
	}
	for (const auto& point : testPoints)
	{
		double distance = circle2D.Distance(point);
		double expectedDistance = std::abs(std::sqrt(std::pow(point.X() - center2D.X(), 2) + std::pow(point.Y() - center2D.Y(), 2)) - redius2D);
		CHECK(distance == expectedDistance);
	}
	AMCAX::AxisT<double, 2> mirrorAxis(AMCAX::Point2(0.0, 0.0), AMCAX::Direction2(0.0, 1.0));
	circle2D.Mirror(mirrorAxis);
	AMCAX::Point2 mirroredCenter = circle2D.Location();
	std::cout << "Mirrored circle center: (" << mirroredCenter.X() << ", " << mirroredCenter.Y() << ")" << std::endl;
	CHECK(mirroredCenter.X() == center2D.X());
	CHECK(mirroredCenter.Y() == center2D.Y());
	const AMCAX::FrameT<double, 2>& frame = circle2D.Position();
	AMCAX::Point2 rotationPoint(0.0, 0.0);
	double  rotationAngle = M_PI / 4;
	auto rotatedCircle = circle2D.Rotated(rotationPoint, rotationAngle);
	double cosAngle = cos(rotationAngle);
	double sinAngle = sin(rotationAngle);
	double newX = cosAngle * (center2D.X() - rotationPoint.X()) - sinAngle * (center2D.Y() - rotationPoint.Y()) + rotationPoint.X();
	double newY = sinAngle * (center2D.X() - rotationPoint.X()) + cosAngle * (center2D.Y() - rotationPoint.Y()) + rotationPoint.Y();
	auto rotatedCenter = rotatedCircle.Location();
	CHECK(newX == center2D.X());
	CHECK(newY == center2D.Y());
	AMCAX::Point2 scalingCenter(0.0, 0.0);
	double scalingFactor = 2.0;
	auto scaledCircle = circle2D.Scale(scalingCenter, scalingFactor);
	double scaledRadius = scaledCircle.Radius();
	double expectedScaledRadius = redius2D * scalingFactor;
	CHECK(std::abs(scaledRadius - expectedScaledRadius) < 1e-6);
	AMCAX::VectorT<double, 2> translationVector(2.0, 3.0);
	auto translatedCircle = circle2D.Translated(translationVector);
	auto translatedCenter = translatedCircle.Location();
	double translatedX = center2D.X() + translationVector.X();
	CHECK(translatedX == translatedCenter.X());
	auto xAxis = circle2D.XAxis();
	auto directionAxis = xAxis.Direction();
	CHECK(directionAxis.X() == -1.0);
	CHECK(directionAxis.Y() == 0.0);
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] double Distance(const PointT<double, DIM>& p)	 @return The distance from the point to the circle
	 @param p The point
	 @brief Compute the distance from a point to the circle
,
 "output":#include <math/CircleT.hpp>
#include <common/CoordT.hpp>
#include <common/TransformationType.hpp>
#include <common/DirectionT.hpp>
#include <common/PointT.hpp>
#include <common/Precision.hpp>
#include <common/CoordT.hpp>
#include <common/TransformationType.hpp>
#include <topology/TopoEdge.hpp>
#include <modeling/MakeEdge.hpp>
#include <topology/TopoWire.hpp>
#include <modeling/MakeWire.hpp>
#include <geometry/GlobalProperty.hpp>
#include <topology/BRepGlobalProperty.hpp>
#include<iostream>
#include "catch.hpp" 
using namespace std;
using namespace AMCAX;
TEST_CASE("TestCircle2D", "[math][Circle2D]")
{
	AMCAX::CircleT<double, 2> circle2D;
	AMCAX::Point2 center2D(0.0, 0.0);
	double redius2D = 5.0;
	double tol = 0.1;
	circle2D.SetLocation(center2D);
	circle2D.SetRadius(redius2D);
	double area2D = circle2D.Area();
	double length2D = circle2D.Length();
	AMCAX::Point2 retcenter2D = circle2D.Location();
	double retarea2D = M_PI * redius2D * redius2D;
	double retlength2D = 2 * M_PI * redius2D;
	std::cout << area2D << std::endl;
	std::cout << length2D << std::endl;
	std::cout << retcenter2D.X() << std::endl;
	std::cout << retcenter2D.Y() << std::endl;
	CHECK(area2D == retarea2D);
	CHECK(length2D == retlength2D);
	CHECK(retcenter2D.X() == center2D.X());
	CHECK(retcenter2D.Y() == center2D.Y());
	double a, b, c, d, e, f;
	circle2D.Coefficients(a, b, c, d, e, f);
	std::cout << a << std::endl;
	std::cout << b << std::endl;
	std::cout << c << std::endl;
	std::cout << d << std::endl;
	std::cout << e << std::endl;
	std::cout << f << std::endl;
	CHECK(a == 1);
	CHECK(b == 1);
	CHECK(c == 0);
	CHECK(d == 0);
	CHECK(e == 0);
	CHECK(f == -25);
	std::vector < AMCAX::Point2> testPoints = {
		AMCAX::Point2(3.0, 4.0),
		AMCAX::Point2(5.0, 0.0),
		AMCAX::Point2(4.9, 0.0),
		AMCAX::Point2(5.1, 0.0),
		AMCAX::Point2(6.0, 0.0)
	};
	for (const auto& point : testPoints)
	{
		double distanceToCenter = std::sqrt(point.X() * point.X() + point.Y() * point.Y());
		bool expectedIsInCircle = distanceToCenter <= 5.0 + tol;
		bool isInCircle = circle2D.Contains(point, tol);
		CHECK(isInCircle == expectedIsInCircle);
	}
	for (const auto& point : testPoints)
	{
		double distance = circle2D.Distance(point);
		double expectedDistance = std::abs(std::sqrt(std::pow(point.X() - center2D.X(), 2) + std::pow(point.Y() - center2D.Y(), 2)) - redius2D);
		CHECK(distance == expectedDistance);
	}
	AMCAX::AxisT<double, 2> mirrorAxis(AMCAX::Point2(0.0, 0.0), AMCAX::Direction2(0.0, 1.0));
	circle2D.Mirror(mirrorAxis);
	AMCAX::Point2 mirroredCenter = circle2D.Location();
	std::cout << "Mirrored circle center: (" << mirroredCenter.X() << ", " << mirroredCenter.Y() << ")" << std::endl;
	CHECK(mirroredCenter.X() == center2D.X());
	CHECK(mirroredCenter.Y() == center2D.Y());
	const AMCAX::FrameT<double, 2>& frame = circle2D.Position();
	AMCAX::Point2 rotationPoint(0.0, 0.0);
	double  rotationAngle = M_PI / 4;
	auto rotatedCircle = circle2D.Rotated(rotationPoint, rotationAngle);
	double cosAngle = cos(rotationAngle);
	double sinAngle = sin(rotationAngle);
	double newX = cosAngle * (center2D.X() - rotationPoint.X()) - sinAngle * (center2D.Y() - rotationPoint.Y()) + rotationPoint.X();
	double newY = sinAngle * (center2D.X() - rotationPoint.X()) + cosAngle * (center2D.Y() - rotationPoint.Y()) + rotationPoint.Y();
	auto rotatedCenter = rotatedCircle.Location();
	CHECK(newX == center2D.X());
	CHECK(newY == center2D.Y());
	AMCAX::Point2 scalingCenter(0.0, 0.0);
	double scalingFactor = 2.0;
	auto scaledCircle = circle2D.Scale(scalingCenter, scalingFactor);
	double scaledRadius = scaledCircle.Radius();
	double expectedScaledRadius = redius2D * scalingFactor;
	CHECK(std::abs(scaledRadius - expectedScaledRadius) < 1e-6);
	AMCAX::VectorT<double, 2> translationVector(2.0, 3.0);
	auto translatedCircle = circle2D.Translated(translationVector);
	auto translatedCenter = translatedCircle.Location();
	double translatedX = center2D.X() + translationVector.X();
	CHECK(translatedX == translatedCenter.X());
	auto xAxis = circle2D.XAxis();
	auto directionAxis = xAxis.Direction();
	CHECK(directionAxis.X() == -1.0);
	CHECK(directionAxis.Y() == 0.0);
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] double SquaredDistance(const PointT<double, DIM>& p)	 @return The squared distance from the point to the circle
	 @param p The point
	 @brief Compute the squared distance from a point to the circle
,
 "output":#include <math/CircleT.hpp>
#include <common/CoordT.hpp>
#include <common/TransformationType.hpp>
#include <common/DirectionT.hpp>
#include <common/PointT.hpp>
#include <common/Precision.hpp>
#include <common/CoordT.hpp>
#include <common/TransformationType.hpp>
#include <topology/TopoEdge.hpp>
#include <modeling/MakeEdge.hpp>
#include <topology/TopoWire.hpp>
#include <modeling/MakeWire.hpp>
#include <geometry/GlobalProperty.hpp>
#include <topology/BRepGlobalProperty.hpp>
#include<iostream>
#include "catch.hpp" 
using namespace std;
using namespace AMCAX;
TEST_CASE("TestCircle3D", "[math][Circle3D]")
{
	AMCAX::Circle3 circle3D;
	AMCAX::Point3  center3D(0.0, 0.0, 0.0);
	double radius3D = 5.0;
	double tol = 0.1;
	circle3D.SetLocation(center3D);
	circle3D.SetRadius(radius3D);
	double area = circle3D.Area();
	auto axis = circle3D.Axis();
	AMCAX::Point3 expectedDirection(0.0, 0.0, 1.0);
	auto direction = axis.Direction();
	CHECK(area == Approx(78.5398));
	CHECK(direction.X() == Approx(expectedDirection.X()).margin(tol));
	CHECK(direction.Y() == Approx(expectedDirection.Y()).margin(tol));
	CHECK(direction.Z() == Approx(expectedDirection.Z()).margin(tol));
	std::vector <AMCAX::Point3> test3DPoints = {
		AMCAX::Point3(0.0, 0.0, 0.0),
		AMCAX::Point3(4.0, 0.0, 0.0),
	};
	for (const auto& point : test3DPoints)
	{
		double distanceToCenter = std::sqrt(std::pow(point.X() - center3D.X(), 2) + std::pow(point.Y() - center3D.Y(), 2) + std::pow(point.Z() - center3D.Z(), 2));
		bool expectedIsCircle = distanceToCenter <= 5.0 + tol;
		bool isInCircle = circle3D.Contains(point, tol);
		CHECK(!isInCircle == expectedIsCircle);
	}
	AMCAX::PointT<double, 3>  pointOutside(10.0, 0.0, 0.0);
	double expectedDistance = 5.0;
	CHECK(circle3D.Distance(pointOutside) == Approx(expectedDistance));
	double length = circle3D.Length();
	CHECK(length == Approx(31.4159));
	auto location = circle3D.Location();
	CHECK(location.X() == Approx(0.0));
	CHECK(location.Y() == Approx(0.0));
	CHECK(location.Z() == Approx(0.0));
	AMCAX::PointT<double, 3> mirrorPoint(1.0, 0.0, 0.0);
	circle3D.Mirror(mirrorPoint);
	auto mirroredLocation = circle3D.Location();
	CHECK(mirroredLocation.X() == Approx(2.0));
	CHECK(mirroredLocation.Y() == Approx(0.0));
	CHECK(mirroredLocation.Z() == Approx(0.0));
	auto position = circle3D.Position();   
	double r = circle3D.Radius();
	CHECK(r == 5.0);
	Direction3 zDirection(0.0, 0.0, 1.0);
	Axis3 zAxis(center3D, zDirection);
	Transformation3 rotation;
	rotation.SetRotation(zAxis, M_PI / 2);  
	Point3 newCenter1 = center3D.Transformed(rotation);
	CHECK(newCenter1.X() == 0.0);
	CHECK(newCenter1.Y() == 0.0);
	CHECK(newCenter1.Z() == 0.0);
	double angle = M_PI / 2;
	circle3D.Rotated(zAxis, angle);
	AMCAX::Frame3 frame = circle3D.Position();
	CHECK(frame.Location().X() == 2.0);
	CHECK(frame.Location().Y() == 0.0);
	CHECK(frame.Location().Z() == 0.0);
	double scale = 2.0;
	circle3D.Scale(center3D, scale);
	CHECK(circle3D.Radius() == radius3D * 2.0);
	AMCAX::PointT<double, 3> insidePoint(3.0, 4.0, 0.0);
	AMCAX::PointT<double, 3> onCirclePoint(5.0, 0.0, 0.0);
	AMCAX::PointT<double, 3> outsidePoint(8.0, 6.0, 0.0);
	double insideSquaredDistance = circle3D.SquaredDistance(insidePoint);
	double onCircleSquaredDistance = circle3D.SquaredDistance(onCirclePoint);
	double outsideSquaredDistance = circle3D.SquaredDistance(outsidePoint);
	CHECK(insideSquaredDistance == Approx(34.5378));
	CHECK(onCircleSquaredDistance == 81.0);
	CHECK(outsideSquaredDistance == Approx(7.7779));
	VectorT<double, 3> translationVector(5.0, 5.0, 0.0);
	circle3D.Translate(translationVector);
	CHECK(circle3D.Location().X() == 9.0);
	CHECK(circle3D.Location().Y() == 5.0);
	CHECK(circle3D.Location().Z() == 0.0);
	auto xAxis = circle3D.XAxis();
	auto yAxis = circle3D.YAxis();
	CHECK(xAxis.Direction().X() == Approx(-1.0));
	CHECK(yAxis.Direction().Y() == Approx(-1.0));
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":CircleS& Scale(const PointT<double, DIM>& p, double scale)	 @return The reference to self
	 @param scale The scale value
	 @param p The scaling center point
	 @brief Scale the circle by a center point
,
 "output":#include <math/CircleT.hpp>
#include <common/CoordT.hpp>
#include <common/TransformationType.hpp>
#include <common/DirectionT.hpp>
#include <common/PointT.hpp>
#include <common/Precision.hpp>
#include <common/CoordT.hpp>
#include <common/TransformationType.hpp>
#include <topology/TopoEdge.hpp>
#include <modeling/MakeEdge.hpp>
#include <topology/TopoWire.hpp>
#include <modeling/MakeWire.hpp>
#include <geometry/GlobalProperty.hpp>
#include <topology/BRepGlobalProperty.hpp>
#include<iostream>
#include "catch.hpp" 
using namespace std;
using namespace AMCAX;
TEST_CASE("TestCircle2D", "[math][Circle2D]")
{
	AMCAX::CircleT<double, 2> circle2D;
	AMCAX::Point2 center2D(0.0, 0.0);
	double redius2D = 5.0;
	double tol = 0.1;
	circle2D.SetLocation(center2D);
	circle2D.SetRadius(redius2D);
	double area2D = circle2D.Area();
	double length2D = circle2D.Length();
	AMCAX::Point2 retcenter2D = circle2D.Location();
	double retarea2D = M_PI * redius2D * redius2D;
	double retlength2D = 2 * M_PI * redius2D;
	std::cout << area2D << std::endl;
	std::cout << length2D << std::endl;
	std::cout << retcenter2D.X() << std::endl;
	std::cout << retcenter2D.Y() << std::endl;
	CHECK(area2D == retarea2D);
	CHECK(length2D == retlength2D);
	CHECK(retcenter2D.X() == center2D.X());
	CHECK(retcenter2D.Y() == center2D.Y());
	double a, b, c, d, e, f;
	circle2D.Coefficients(a, b, c, d, e, f);
	std::cout << a << std::endl;
	std::cout << b << std::endl;
	std::cout << c << std::endl;
	std::cout << d << std::endl;
	std::cout << e << std::endl;
	std::cout << f << std::endl;
	CHECK(a == 1);
	CHECK(b == 1);
	CHECK(c == 0);
	CHECK(d == 0);
	CHECK(e == 0);
	CHECK(f == -25);
	std::vector < AMCAX::Point2> testPoints = {
		AMCAX::Point2(3.0, 4.0),
		AMCAX::Point2(5.0, 0.0),
		AMCAX::Point2(4.9, 0.0),
		AMCAX::Point2(5.1, 0.0),
		AMCAX::Point2(6.0, 0.0)
	};
	for (const auto& point : testPoints)
	{
		double distanceToCenter = std::sqrt(point.X() * point.X() + point.Y() * point.Y());
		bool expectedIsInCircle = distanceToCenter <= 5.0 + tol;
		bool isInCircle = circle2D.Contains(point, tol);
		CHECK(isInCircle == expectedIsInCircle);
	}
	for (const auto& point : testPoints)
	{
		double distance = circle2D.Distance(point);
		double expectedDistance = std::abs(std::sqrt(std::pow(point.X() - center2D.X(), 2) + std::pow(point.Y() - center2D.Y(), 2)) - redius2D);
		CHECK(distance == expectedDistance);
	}
	AMCAX::AxisT<double, 2> mirrorAxis(AMCAX::Point2(0.0, 0.0), AMCAX::Direction2(0.0, 1.0));
	circle2D.Mirror(mirrorAxis);
	AMCAX::Point2 mirroredCenter = circle2D.Location();
	std::cout << "Mirrored circle center: (" << mirroredCenter.X() << ", " << mirroredCenter.Y() << ")" << std::endl;
	CHECK(mirroredCenter.X() == center2D.X());
	CHECK(mirroredCenter.Y() == center2D.Y());
	const AMCAX::FrameT<double, 2>& frame = circle2D.Position();
	AMCAX::Point2 rotationPoint(0.0, 0.0);
	double  rotationAngle = M_PI / 4;
	auto rotatedCircle = circle2D.Rotated(rotationPoint, rotationAngle);
	double cosAngle = cos(rotationAngle);
	double sinAngle = sin(rotationAngle);
	double newX = cosAngle * (center2D.X() - rotationPoint.X()) - sinAngle * (center2D.Y() - rotationPoint.Y()) + rotationPoint.X();
	double newY = sinAngle * (center2D.X() - rotationPoint.X()) + cosAngle * (center2D.Y() - rotationPoint.Y()) + rotationPoint.Y();
	auto rotatedCenter = rotatedCircle.Location();
	CHECK(newX == center2D.X());
	CHECK(newY == center2D.Y());
	AMCAX::Point2 scalingCenter(0.0, 0.0);
	double scalingFactor = 2.0;
	auto scaledCircle = circle2D.Scale(scalingCenter, scalingFactor);
	double scaledRadius = scaledCircle.Radius();
	double expectedScaledRadius = redius2D * scalingFactor;
	CHECK(std::abs(scaledRadius - expectedScaledRadius) < 1e-6);
	AMCAX::VectorT<double, 2> translationVector(2.0, 3.0);
	auto translatedCircle = circle2D.Translated(translationVector);
	auto translatedCenter = translatedCircle.Location();
	double translatedX = center2D.X() + translationVector.X();
	CHECK(translatedX == translatedCenter.X());
	auto xAxis = circle2D.XAxis();
	auto directionAxis = xAxis.Direction();
	CHECK(directionAxis.X() == -1.0);
	CHECK(directionAxis.Y() == 0.0);
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":void SetRadius(double r)	 @param r The radius
	 @brief Set the radius of the circle
,
 "output":#include<catch.hpp>
#include "testHelper.h"
#include<iostream>
#include <math/CircleT.hpp>
#include <common/AxisT.hpp>
#include <common/PointT.hpp>
TEST_CASE("CircleT Area and Length Test", "[CircleT]") {
    AMCAX::Circle2 circle2;
    circle2.SetRadius(5.0);
    CHECK(circle2.Area() == Approx(78.53982));
    CHECK(circle2.Length() == Approx(31.41593));
    AMCAX::Circle3 circle3;
    circle3.SetRadius(10.0);
    CHECK(circle3.Area() == Approx(314.15927));
    CHECK(circle3.Length() == Approx(62.83185));
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] double Radius()	 @return The radius
	 @brief Get the radius
,
 "output":#include<catch.hpp>
#include "testHelper.h"
#include<iostream>
#include <math/CircleT.hpp>
#include <common/AxisT.hpp>
#include <common/PointT.hpp>
TEST_CASE("CircleT Constructor Test", "[math][CircleT][P1]") {
	SECTION("2D Circle Construction") {
        AMCAX::Circle2 circle2;
        constexpr double maxr = std::numeric_limits<double>::max();
        CHECK(circle2.Radius() == Approx(maxr).epsilon(1e-15));
        CHECK(circle2.Area() == Approx(maxr * maxr * M_PI).epsilon(1e-15));
        double a, b, c, d, e, f;
        circle2.Coefficients(a, b, c, d, e, f);
        std::cout << a << std::endl;
        std::cout << b << std::endl;
        std::cout << c << std::endl;
        std::cout << d << std::endl;
        std::cout << e << std::endl;
        std::cout << f << std::endl;
        AMCAX::Point2 P(0.0, 1.0);
        double tolerance = 0.1;
        CHECK(circle2.Contains(P, tolerance)==false);
        CHECK(circle2.Distance(P) == Approx(maxr).epsilon(1e-15));
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] double Length()	 @return The length of the circle
	 @brief Get the length of the circle
,
 "output":#include<catch.hpp>
#include "testHelper.h"
#include<iostream>
#include <math/CircleT.hpp>
#include <common/AxisT.hpp>
#include <common/PointT.hpp>
TEST_CASE("case1: create a Cirecle", "[math][CircleT][P1]") {
	AMCAX::Point2 P(0.0,0.0);
	AMCAX::Direction2 D(1.0,0.0);
	AMCAX::Axis2  axis2(P, D);
	float radius = 5.0f;
	AMCAX::Circle2 circle2(axis2, radius, true);
	CHECK(circle2.Area() == radius * radius * M_PI); 
    double a, b, c, d, e, f;
    circle2.Coefficients(a, b, c, d, e, f);  
    double x = 0, y = 5;
    CHECK(a * x * x + b * y * y + c * x * y + d * x + e * y + f == Approx(0.0).epsilon(1e-15));
    double x1 = 5 * sqrt(2) / 2;
    double y1 = 5 * sqrt(2) / 2;
    double x2 = 6;
    double y2 = 0;
    double x3 = 5.5;
    double y3 = 6.1;
    AMCAX::Point2 P1(x1,y1);
    AMCAX::Point2 P2(x2, y2);
    AMCAX::Point2 P3(x3, y3);
    double tolerance1 = 0.1;
    double tolerance2 = 1.0;
    CHECK(circle2.Contains(P1, tolerance1) == true);
    CHECK(circle2.Contains(P2, tolerance2) == true);
    CHECK(circle2.Contains(P3, tolerance2) == false);
    CHECK(circle2.Distance(P1) == Approx(0.0).epsilon(1e-15));
    CHECK(circle2.Distance(P2) == Approx(1.0).epsilon(1e-15));
    CHECK(circle2.Length() == Approx(2*M_PI*radius).epsilon(1e-15));
    AMCAX::Point2 locationP = circle2.Location();
    CHECK(locationP.X() == Approx(0.0).epsilon(1e-15));
    CHECK(locationP.Y() == Approx(0.0).epsilon(1e-15));
    AMCAX::Point2 mirrorAxisPoint(1.0, 0.0);
    AMCAX::Direction2 mirrorAxisDirection(0.0, 1.0);
    AMCAX::Axis2 mirrorAxis(mirrorAxisPoint, mirrorAxisDirection);
    circle2.Mirror(mirrorAxis);
    CHECK(circle2.Length() == Approx(2 * M_PI * radius).epsilon(1e-15));
    AMCAX::Point2 locationPmirror = circle2.Location();
    CHECK(locationPmirror.X() == Approx(2.0).epsilon(1e-15));
    CHECK(locationPmirror.Y() == Approx(0.0).epsilon(1e-15));
    AMCAX::Point2 P4(7.0, 0.0);  
    CHECK(circle2.Contains(P4, tolerance2) == true);
    AMCAX::Point2 mirroredAxisPoint(1.0, 0.0);
    AMCAX::Direction2 mirroredAxisDirection(0.0, 1.0);
    AMCAX::Axis2 mirroedrAxis(mirroredAxisPoint, mirroredAxisDirection);
    AMCAX::Circle2 circle2mirrored = circle2.Mirrored(mirroedrAxis);
    CHECK(circle2mirrored.Length() == Approx(2 * M_PI * radius).epsilon(1e-15));
    AMCAX::Point2 locationPmirrored = circle2mirrored.Location();
    CHECK(locationPmirrored.X() == Approx(0.0).epsilon(1e-15));
    CHECK(locationPmirrored.Y() == Approx(0.0).epsilon(1e-15));
    AMCAX::Frame2 frame2mirrored = circle2mirrored.Position(); 
    CHECK(frame2mirrored.Location().X() == Approx(0.0).epsilon(1e-15));
    CHECK(frame2mirrored.Location().Y() == Approx(0.0).epsilon(1e-15));
    const double& radiusmirrored = circle2mirrored.Radius(); 
    CHECK(radiusmirrored == Approx(radius).epsilon(1e-15));
    circle2mirrored.Scale(P,0.5); 
    AMCAX::Point2 scaleP1(0.0,-2.5);
    CHECK(circle2mirrored.Contains(scaleP1, 0) == true);
    AMCAX::Circle2 circle2Scaled = circle2mirrored.Scale(P, 2); 
    AMCAX::Point2 scaledP1(0.0, 5.0);
    CHECK(circle2Scaled.Contains(scaledP1, 0) == true);
    AMCAX::Point2 rotateP(0.0,0.0);
    double angle = 90.0 * (2 * M_PI / 360.0);
    circle2.Rotate(rotateP, angle); 
    AMCAX::Point2 P5(0.0, -3.0);
    CHECK(circle2.Contains(P5, 0) == true);
    double angle2 = -180.0 * (2 * M_PI / 360.0);
    AMCAX::Circle2 rotatedCircle2 = circle2.Rotated(rotateP, angle2); 
    AMCAX::Point2 P6(0.0, 3.0);
    CHECK(rotatedCircle2.Contains(P6, 0) == true); 
    AMCAX::Point2 newP(0.0, 0.0);
    rotatedCircle2.SetLocation(newP);
    CHECK(rotatedCircle2.Contains(P1, 0) == true);
    std::cout << circle2.Length() << std::endl;
};
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] double Distance(const PointT<double, DIM>& p)	 @return The distance from the point to the circle
	 @param p The point
	 @brief Compute the distance from a point to the circle
,
 "output":#include<catch.hpp>
#include "testHelper.h"
#include<iostream>
#include <math/CircleT.hpp>
#include <common/AxisT.hpp>
#include <common/PointT.hpp>
TEST_CASE("case1: create a Cirecle", "[math][CircleT][P1]") {
	AMCAX::Point2 P(0.0,0.0);
	AMCAX::Direction2 D(1.0,0.0);
	AMCAX::Axis2  axis2(P, D);
	float radius = 5.0f;
	AMCAX::Circle2 circle2(axis2, radius, true);
	CHECK(circle2.Area() == radius * radius * M_PI); 
    double a, b, c, d, e, f;
    circle2.Coefficients(a, b, c, d, e, f);  
    double x = 0, y = 5;
    CHECK(a * x * x + b * y * y + c * x * y + d * x + e * y + f == Approx(0.0).epsilon(1e-15));
    double x1 = 5 * sqrt(2) / 2;
    double y1 = 5 * sqrt(2) / 2;
    double x2 = 6;
    double y2 = 0;
    double x3 = 5.5;
    double y3 = 6.1;
    AMCAX::Point2 P1(x1,y1);
    AMCAX::Point2 P2(x2, y2);
    AMCAX::Point2 P3(x3, y3);
    double tolerance1 = 0.1;
    double tolerance2 = 1.0;
    CHECK(circle2.Contains(P1, tolerance1) == true);
    CHECK(circle2.Contains(P2, tolerance2) == true);
    CHECK(circle2.Contains(P3, tolerance2) == false);
    CHECK(circle2.Distance(P1) == Approx(0.0).epsilon(1e-15));
    CHECK(circle2.Distance(P2) == Approx(1.0).epsilon(1e-15));
    CHECK(circle2.Length() == Approx(2*M_PI*radius).epsilon(1e-15));
    AMCAX::Point2 locationP = circle2.Location();
    CHECK(locationP.X() == Approx(0.0).epsilon(1e-15));
    CHECK(locationP.Y() == Approx(0.0).epsilon(1e-15));
    AMCAX::Point2 mirrorAxisPoint(1.0, 0.0);
    AMCAX::Direction2 mirrorAxisDirection(0.0, 1.0);
    AMCAX::Axis2 mirrorAxis(mirrorAxisPoint, mirrorAxisDirection);
    circle2.Mirror(mirrorAxis);
    CHECK(circle2.Length() == Approx(2 * M_PI * radius).epsilon(1e-15));
    AMCAX::Point2 locationPmirror = circle2.Location();
    CHECK(locationPmirror.X() == Approx(2.0).epsilon(1e-15));
    CHECK(locationPmirror.Y() == Approx(0.0).epsilon(1e-15));
    AMCAX::Point2 P4(7.0, 0.0);  
    CHECK(circle2.Contains(P4, tolerance2) == true);
    AMCAX::Point2 mirroredAxisPoint(1.0, 0.0);
    AMCAX::Direction2 mirroredAxisDirection(0.0, 1.0);
    AMCAX::Axis2 mirroedrAxis(mirroredAxisPoint, mirroredAxisDirection);
    AMCAX::Circle2 circle2mirrored = circle2.Mirrored(mirroedrAxis);
    CHECK(circle2mirrored.Length() == Approx(2 * M_PI * radius).epsilon(1e-15));
    AMCAX::Point2 locationPmirrored = circle2mirrored.Location();
    CHECK(locationPmirrored.X() == Approx(0.0).epsilon(1e-15));
    CHECK(locationPmirrored.Y() == Approx(0.0).epsilon(1e-15));
    AMCAX::Frame2 frame2mirrored = circle2mirrored.Position(); 
    CHECK(frame2mirrored.Location().X() == Approx(0.0).epsilon(1e-15));
    CHECK(frame2mirrored.Location().Y() == Approx(0.0).epsilon(1e-15));
    const double& radiusmirrored = circle2mirrored.Radius(); 
    CHECK(radiusmirrored == Approx(radius).epsilon(1e-15));
    circle2mirrored.Scale(P,0.5); 
    AMCAX::Point2 scaleP1(0.0,-2.5);
    CHECK(circle2mirrored.Contains(scaleP1, 0) == true);
    AMCAX::Circle2 circle2Scaled = circle2mirrored.Scale(P, 2); 
    AMCAX::Point2 scaledP1(0.0, 5.0);
    CHECK(circle2Scaled.Contains(scaledP1, 0) == true);
    AMCAX::Point2 rotateP(0.0,0.0);
    double angle = 90.0 * (2 * M_PI / 360.0);
    circle2.Rotate(rotateP, angle); 
    AMCAX::Point2 P5(0.0, -3.0);
    CHECK(circle2.Contains(P5, 0) == true);
    double angle2 = -180.0 * (2 * M_PI / 360.0);
    AMCAX::Circle2 rotatedCircle2 = circle2.Rotated(rotateP, angle2); 
    AMCAX::Point2 P6(0.0, 3.0);
    CHECK(rotatedCircle2.Contains(P6, 0) == true); 
    AMCAX::Point2 newP(0.0, 0.0);
    rotatedCircle2.SetLocation(newP);
    CHECK(rotatedCircle2.Contains(P1, 0) == true);
    std::cout << circle2.Length() << std::endl;
};
}
,
{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":void SetRadius(double r)	 @param r The radius
	 @brief Set the radius of the circle
,
 "output":#include<catch.hpp>
#include "testHelper.h"
#include<iostream>
#include <math/CircleT.hpp>
#include <common/AxisT.hpp>
#include <common/PointT.hpp>
TEST_CASE("CircleT Area and Length Test", "[CircleT]") {
    AMCAX::Circle2 circle2;
    circle2.SetRadius(5.0);
    CHECK(circle2.Area() == Approx(78.53982));
    CHECK(circle2.Length() == Approx(31.41593));
    AMCAX::Circle3 circle3;
    circle3.SetRadius(10.0);
    CHECK(circle3.Area() == Approx(314.15927));
    CHECK(circle3.Length() == Approx(62.83185));
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] double Radius()	 @return The radius
	 @brief Get the radius
,
 "output":#include<catch.hpp>
#include "testHelper.h"
#include<iostream>
#include <math/CircleT.hpp>
#include <common/AxisT.hpp>
#include <common/PointT.hpp>
TEST_CASE("CircleT Constructor Test", "[math][CircleT][P1]") {
	SECTION("2D Circle Construction") {
        AMCAX::Circle2 circle2;
        constexpr double maxr = std::numeric_limits<double>::max();
        CHECK(circle2.Radius() == Approx(maxr).epsilon(1e-15));
        CHECK(circle2.Area() == Approx(maxr * maxr * M_PI).epsilon(1e-15));
        double a, b, c, d, e, f;
        circle2.Coefficients(a, b, c, d, e, f);
        std::cout << a << std::endl;
        std::cout << b << std::endl;
        std::cout << c << std::endl;
        std::cout << d << std::endl;
        std::cout << e << std::endl;
        std::cout << f << std::endl;
        AMCAX::Point2 P(0.0, 1.0);
        double tolerance = 0.1;
        CHECK(circle2.Contains(P, tolerance)==false);
        CHECK(circle2.Distance(P) == Approx(maxr).epsilon(1e-15));
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] double Length()	 @return The length of the circle
	 @brief Get the length of the circle
,
 "output":#include<catch.hpp>
#include "testHelper.h"
#include<iostream>
#include <math/CircleT.hpp>
#include <common/AxisT.hpp>
#include <common/PointT.hpp>
TEST_CASE("case1: create a Cirecle", "[math][CircleT][P1]") {
	AMCAX::Point2 P(0.0,0.0);
	AMCAX::Direction2 D(1.0,0.0);
	AMCAX::Axis2  axis2(P, D);
	float radius = 5.0f;
	AMCAX::Circle2 circle2(axis2, radius, true);
	CHECK(circle2.Area() == radius * radius * M_PI); 
    double a, b, c, d, e, f;
    circle2.Coefficients(a, b, c, d, e, f);  
    double x = 0, y = 5;
    CHECK(a * x * x + b * y * y + c * x * y + d * x + e * y + f == Approx(0.0).epsilon(1e-15));
    double x1 = 5 * sqrt(2) / 2;
    double y1 = 5 * sqrt(2) / 2;
    double x2 = 6;
    double y2 = 0;
    double x3 = 5.5;
    double y3 = 6.1;
    AMCAX::Point2 P1(x1,y1);
    AMCAX::Point2 P2(x2, y2);
    AMCAX::Point2 P3(x3, y3);
    double tolerance1 = 0.1;
    double tolerance2 = 1.0;
    CHECK(circle2.Contains(P1, tolerance1) == true);
    CHECK(circle2.Contains(P2, tolerance2) == true);
    CHECK(circle2.Contains(P3, tolerance2) == false);
    CHECK(circle2.Distance(P1) == Approx(0.0).epsilon(1e-15));
    CHECK(circle2.Distance(P2) == Approx(1.0).epsilon(1e-15));
    CHECK(circle2.Length() == Approx(2*M_PI*radius).epsilon(1e-15));
    AMCAX::Point2 locationP = circle2.Location();
    CHECK(locationP.X() == Approx(0.0).epsilon(1e-15));
    CHECK(locationP.Y() == Approx(0.0).epsilon(1e-15));
    AMCAX::Point2 mirrorAxisPoint(1.0, 0.0);
    AMCAX::Direction2 mirrorAxisDirection(0.0, 1.0);
    AMCAX::Axis2 mirrorAxis(mirrorAxisPoint, mirrorAxisDirection);
    circle2.Mirror(mirrorAxis);
    CHECK(circle2.Length() == Approx(2 * M_PI * radius).epsilon(1e-15));
    AMCAX::Point2 locationPmirror = circle2.Location();
    CHECK(locationPmirror.X() == Approx(2.0).epsilon(1e-15));
    CHECK(locationPmirror.Y() == Approx(0.0).epsilon(1e-15));
    AMCAX::Point2 P4(7.0, 0.0);  
    CHECK(circle2.Contains(P4, tolerance2) == true);
    AMCAX::Point2 mirroredAxisPoint(1.0, 0.0);
    AMCAX::Direction2 mirroredAxisDirection(0.0, 1.0);
    AMCAX::Axis2 mirroedrAxis(mirroredAxisPoint, mirroredAxisDirection);
    AMCAX::Circle2 circle2mirrored = circle2.Mirrored(mirroedrAxis);
    CHECK(circle2mirrored.Length() == Approx(2 * M_PI * radius).epsilon(1e-15));
    AMCAX::Point2 locationPmirrored = circle2mirrored.Location();
    CHECK(locationPmirrored.X() == Approx(0.0).epsilon(1e-15));
    CHECK(locationPmirrored.Y() == Approx(0.0).epsilon(1e-15));
    AMCAX::Frame2 frame2mirrored = circle2mirrored.Position(); 
    CHECK(frame2mirrored.Location().X() == Approx(0.0).epsilon(1e-15));
    CHECK(frame2mirrored.Location().Y() == Approx(0.0).epsilon(1e-15));
    const double& radiusmirrored = circle2mirrored.Radius(); 
    CHECK(radiusmirrored == Approx(radius).epsilon(1e-15));
    circle2mirrored.Scale(P,0.5); 
    AMCAX::Point2 scaleP1(0.0,-2.5);
    CHECK(circle2mirrored.Contains(scaleP1, 0) == true);
    AMCAX::Circle2 circle2Scaled = circle2mirrored.Scale(P, 2); 
    AMCAX::Point2 scaledP1(0.0, 5.0);
    CHECK(circle2Scaled.Contains(scaledP1, 0) == true);
    AMCAX::Point2 rotateP(0.0,0.0);
    double angle = 90.0 * (2 * M_PI / 360.0);
    circle2.Rotate(rotateP, angle); 
    AMCAX::Point2 P5(0.0, -3.0);
    CHECK(circle2.Contains(P5, 0) == true);
    double angle2 = -180.0 * (2 * M_PI / 360.0);
    AMCAX::Circle2 rotatedCircle2 = circle2.Rotated(rotateP, angle2); 
    AMCAX::Point2 P6(0.0, 3.0);
    CHECK(rotatedCircle2.Contains(P6, 0) == true); 
    AMCAX::Point2 newP(0.0, 0.0);
    rotatedCircle2.SetLocation(newP);
    CHECK(rotatedCircle2.Contains(P1, 0) == true);
    std::cout << circle2.Length() << std::endl;
};
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] double Distance(const PointT<double, DIM>& p)	 @return The distance from the point to the circle
	 @param p The point
	 @brief Compute the distance from a point to the circle
,
 "output":#include<catch.hpp>
#include "testHelper.h"
#include<iostream>
#include <math/CircleT.hpp>
#include <common/AxisT.hpp>
#include <common/PointT.hpp>
TEST_CASE("case1: create a Cirecle", "[math][CircleT][P1]") {
	AMCAX::Point2 P(0.0,0.0);
	AMCAX::Direction2 D(1.0,0.0);
	AMCAX::Axis2  axis2(P, D);
	float radius = 5.0f;
	AMCAX::Circle2 circle2(axis2, radius, true);
	CHECK(circle2.Area() == radius * radius * M_PI); 
    double a, b, c, d, e, f;
    circle2.Coefficients(a, b, c, d, e, f);  
    double x = 0, y = 5;
    CHECK(a * x * x + b * y * y + c * x * y + d * x + e * y + f == Approx(0.0).epsilon(1e-15));
    double x1 = 5 * sqrt(2) / 2;
    double y1 = 5 * sqrt(2) / 2;
    double x2 = 6;
    double y2 = 0;
    double x3 = 5.5;
    double y3 = 6.1;
    AMCAX::Point2 P1(x1,y1);
    AMCAX::Point2 P2(x2, y2);
    AMCAX::Point2 P3(x3, y3);
    double tolerance1 = 0.1;
    double tolerance2 = 1.0;
    CHECK(circle2.Contains(P1, tolerance1) == true);
    CHECK(circle2.Contains(P2, tolerance2) == true);
    CHECK(circle2.Contains(P3, tolerance2) == false);
    CHECK(circle2.Distance(P1) == Approx(0.0).epsilon(1e-15));
    CHECK(circle2.Distance(P2) == Approx(1.0).epsilon(1e-15));
    CHECK(circle2.Length() == Approx(2*M_PI*radius).epsilon(1e-15));
    AMCAX::Point2 locationP = circle2.Location();
    CHECK(locationP.X() == Approx(0.0).epsilon(1e-15));
    CHECK(locationP.Y() == Approx(0.0).epsilon(1e-15));
    AMCAX::Point2 mirrorAxisPoint(1.0, 0.0);
    AMCAX::Direction2 mirrorAxisDirection(0.0, 1.0);
    AMCAX::Axis2 mirrorAxis(mirrorAxisPoint, mirrorAxisDirection);
    circle2.Mirror(mirrorAxis);
    CHECK(circle2.Length() == Approx(2 * M_PI * radius).epsilon(1e-15));
    AMCAX::Point2 locationPmirror = circle2.Location();
    CHECK(locationPmirror.X() == Approx(2.0).epsilon(1e-15));
    CHECK(locationPmirror.Y() == Approx(0.0).epsilon(1e-15));
    AMCAX::Point2 P4(7.0, 0.0);  
    CHECK(circle2.Contains(P4, tolerance2) == true);
    AMCAX::Point2 mirroredAxisPoint(1.0, 0.0);
    AMCAX::Direction2 mirroredAxisDirection(0.0, 1.0);
    AMCAX::Axis2 mirroedrAxis(mirroredAxisPoint, mirroredAxisDirection);
    AMCAX::Circle2 circle2mirrored = circle2.Mirrored(mirroedrAxis);
    CHECK(circle2mirrored.Length() == Approx(2 * M_PI * radius).epsilon(1e-15));
    AMCAX::Point2 locationPmirrored = circle2mirrored.Location();
    CHECK(locationPmirrored.X() == Approx(0.0).epsilon(1e-15));
    CHECK(locationPmirrored.Y() == Approx(0.0).epsilon(1e-15));
    AMCAX::Frame2 frame2mirrored = circle2mirrored.Position(); 
    CHECK(frame2mirrored.Location().X() == Approx(0.0).epsilon(1e-15));
    CHECK(frame2mirrored.Location().Y() == Approx(0.0).epsilon(1e-15));
    const double& radiusmirrored = circle2mirrored.Radius(); 
    CHECK(radiusmirrored == Approx(radius).epsilon(1e-15));
    circle2mirrored.Scale(P,0.5); 
    AMCAX::Point2 scaleP1(0.0,-2.5);
    CHECK(circle2mirrored.Contains(scaleP1, 0) == true);
    AMCAX::Circle2 circle2Scaled = circle2mirrored.Scale(P, 2); 
    AMCAX::Point2 scaledP1(0.0, 5.0);
    CHECK(circle2Scaled.Contains(scaledP1, 0) == true);
    AMCAX::Point2 rotateP(0.0,0.0);
    double angle = 90.0 * (2 * M_PI / 360.0);
    circle2.Rotate(rotateP, angle); 
    AMCAX::Point2 P5(0.0, -3.0);
    CHECK(circle2.Contains(P5, 0) == true);
    double angle2 = -180.0 * (2 * M_PI / 360.0);
    AMCAX::Circle2 rotatedCircle2 = circle2.Rotated(rotateP, angle2); 
    AMCAX::Point2 P6(0.0, 3.0);
    CHECK(rotatedCircle2.Contains(P6, 0) == true); 
    AMCAX::Point2 newP(0.0, 0.0);
    rotatedCircle2.SetLocation(newP);
    CHECK(rotatedCircle2.Contains(P1, 0) == true);
    std::cout << circle2.Length() << std::endl;
};
}
,
