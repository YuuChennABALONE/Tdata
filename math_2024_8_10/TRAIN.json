[
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] double Distance(const PointT<double, DIM>& p)\t @return The distance from the point to the circle\n\t @param p The point\n\t @brief Compute the distance from a point to the circle\n,\n",
      "output": "#include<catch.hpp>\n#include \"testHelper.h\"\n#include<iostream>\n#include <math/CircleT.hpp>\n#include <common/AxisT.hpp>\n#include <common/PointT.hpp>\nTEST_CASE(\"case1: create a Cirecle\", \"[math][CircleT][P1]\") {\n\tAMCAX::Point2 P(0.0,0.0);\n\tAMCAX::Direction2 D(1.0,0.0);\n\tAMCAX::Axis2  axis2(P, D);\n\tfloat radius = 5.0f;\n\tAMCAX::Circle2 circle2(axis2, radius, true);\n\tCHECK(circle2.Area() == radius * radius * M_PI); \n    double a, b, c, d, e, f;\n    circle2.Coefficients(a, b, c, d, e, f);  \n    double x = 0, y = 5;\n    CHECK(a * x * x + b * y * y + c * x * y + d * x + e * y + f == Approx(0.0).epsilon(1e-15));\n    double x1 = 5 * sqrt(2) / 2;\n    double y1 = 5 * sqrt(2) / 2;\n    double x2 = 6;\n    double y2 = 0;\n    double x3 = 5.5;\n    double y3 = 6.1;\n    AMCAX::Point2 P1(x1,y1);\n    AMCAX::Point2 P2(x2, y2);\n    AMCAX::Point2 P3(x3, y3);\n    double tolerance1 = 0.1;\n    double tolerance2 = 1.0;\n    CHECK(circle2.Contains(P1, tolerance1) == true);\n    CHECK(circle2.Contains(P2, tolerance2) == true);\n    CHECK(circle2.Contains(P3, tolerance2) == false);\n    CHECK(circle2.Distance(P1) == Approx(0.0).epsilon(1e-15));\n    CHECK(circle2.Distance(P2) == Approx(1.0).epsilon(1e-15));\n    CHECK(circle2.Length() == Approx(2*M_PI*radius).epsilon(1e-15));\n    AMCAX::Point2 locationP = circle2.Location();\n    CHECK(locationP.X() == Approx(0.0).epsilon(1e-15));\n    CHECK(locationP.Y() == Approx(0.0).epsilon(1e-15));\n    AMCAX::Point2 mirrorAxisPoint(1.0, 0.0);\n    AMCAX::Direction2 mirrorAxisDirection(0.0, 1.0);\n    AMCAX::Axis2 mirrorAxis(mirrorAxisPoint, mirrorAxisDirection);\n    circle2.Mirror(mirrorAxis);\n    CHECK(circle2.Length() == Approx(2 * M_PI * radius).epsilon(1e-15));\n    AMCAX::Point2 locationPmirror = circle2.Location();\n    CHECK(locationPmirror.X() == Approx(2.0).epsilon(1e-15));\n    CHECK(locationPmirror.Y() == Approx(0.0).epsilon(1e-15));\n    AMCAX::Point2 P4(7.0, 0.0);  \n    CHECK(circle2.Contains(P4, tolerance2) == true);\n    AMCAX::Point2 mirroredAxisPoint(1.0, 0.0);\n    AMCAX::Direction2 mirroredAxisDirection(0.0, 1.0);\n    AMCAX::Axis2 mirroedrAxis(mirroredAxisPoint, mirroredAxisDirection);\n    AMCAX::Circle2 circle2mirrored = circle2.Mirrored(mirroedrAxis);\n    CHECK(circle2mirrored.Length() == Approx(2 * M_PI * radius).epsilon(1e-15));\n    AMCAX::Point2 locationPmirrored = circle2mirrored.Location();\n    CHECK(locationPmirrored.X() == Approx(0.0).epsilon(1e-15));\n    CHECK(locationPmirrored.Y() == Approx(0.0).epsilon(1e-15));\n    AMCAX::Frame2 frame2mirrored = circle2mirrored.Position(); \n    CHECK(frame2mirrored.Location().X() == Approx(0.0).epsilon(1e-15));\n    CHECK(frame2mirrored.Location().Y() == Approx(0.0).epsilon(1e-15));\n    const double& radiusmirrored = circle2mirrored.Radius(); \n    CHECK(radiusmirrored == Approx(radius).epsilon(1e-15));\n    circle2mirrored.Scale(P,0.5); \n    AMCAX::Point2 scaleP1(0.0,-2.5);\n    CHECK(circle2mirrored.Contains(scaleP1, 0) == true);\n    AMCAX::Circle2 circle2Scaled = circle2mirrored.Scale(P, 2); \n    AMCAX::Point2 scaledP1(0.0, 5.0);\n    CHECK(circle2Scaled.Contains(scaledP1, 0) == true);\n    AMCAX::Point2 rotateP(0.0,0.0);\n    double angle = 90.0 * (2 * M_PI / 360.0);\n    circle2.Rotate(rotateP, angle); \n    AMCAX::Point2 P5(0.0, -3.0);\n    CHECK(circle2.Contains(P5, 0) == true);\n    double angle2 = -180.0 * (2 * M_PI / 360.0);\n    AMCAX::Circle2 rotatedCircle2 = circle2.Rotated(rotateP, angle2); \n    AMCAX::Point2 P6(0.0, 3.0);\n    CHECK(rotatedCircle2.Contains(P6, 0) == true); \n    AMCAX::Point2 newP(0.0, 0.0);\n    rotatedCircle2.SetLocation(newP);\n    CHECK(rotatedCircle2.Contains(P1, 0) == true);\n    std::cout << circle2.Length() << std::endl;\n};\n}\n,\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] double Length()\t @return The length of the circle\n\t @brief Get the length of the circle\n,\n",
      "output": "#include<catch.hpp>\n#include \"testHelper.h\"\n#include<iostream>\n#include <math/CircleT.hpp>\n#include <common/AxisT.hpp>\n#include <common/PointT.hpp>\nTEST_CASE(\"case1: create a Cirecle\", \"[math][CircleT][P1]\") {\n\tAMCAX::Point2 P(0.0,0.0);\n\tAMCAX::Direction2 D(1.0,0.0);\n\tAMCAX::Axis2  axis2(P, D);\n\tfloat radius = 5.0f;\n\tAMCAX::Circle2 circle2(axis2, radius, true);\n\tCHECK(circle2.Area() == radius * radius * M_PI); \n    double a, b, c, d, e, f;\n    circle2.Coefficients(a, b, c, d, e, f);  \n    double x = 0, y = 5;\n    CHECK(a * x * x + b * y * y + c * x * y + d * x + e * y + f == Approx(0.0).epsilon(1e-15));\n    double x1 = 5 * sqrt(2) / 2;\n    double y1 = 5 * sqrt(2) / 2;\n    double x2 = 6;\n    double y2 = 0;\n    double x3 = 5.5;\n    double y3 = 6.1;\n    AMCAX::Point2 P1(x1,y1);\n    AMCAX::Point2 P2(x2, y2);\n    AMCAX::Point2 P3(x3, y3);\n    double tolerance1 = 0.1;\n    double tolerance2 = 1.0;\n    CHECK(circle2.Contains(P1, tolerance1) == true);\n    CHECK(circle2.Contains(P2, tolerance2) == true);\n    CHECK(circle2.Contains(P3, tolerance2) == false);\n    CHECK(circle2.Distance(P1) == Approx(0.0).epsilon(1e-15));\n    CHECK(circle2.Distance(P2) == Approx(1.0).epsilon(1e-15));\n    CHECK(circle2.Length() == Approx(2*M_PI*radius).epsilon(1e-15));\n    AMCAX::Point2 locationP = circle2.Location();\n    CHECK(locationP.X() == Approx(0.0).epsilon(1e-15));\n    CHECK(locationP.Y() == Approx(0.0).epsilon(1e-15));\n    AMCAX::Point2 mirrorAxisPoint(1.0, 0.0);\n    AMCAX::Direction2 mirrorAxisDirection(0.0, 1.0);\n    AMCAX::Axis2 mirrorAxis(mirrorAxisPoint, mirrorAxisDirection);\n    circle2.Mirror(mirrorAxis);\n    CHECK(circle2.Length() == Approx(2 * M_PI * radius).epsilon(1e-15));\n    AMCAX::Point2 locationPmirror = circle2.Location();\n    CHECK(locationPmirror.X() == Approx(2.0).epsilon(1e-15));\n    CHECK(locationPmirror.Y() == Approx(0.0).epsilon(1e-15));\n    AMCAX::Point2 P4(7.0, 0.0);  \n    CHECK(circle2.Contains(P4, tolerance2) == true);\n    AMCAX::Point2 mirroredAxisPoint(1.0, 0.0);\n    AMCAX::Direction2 mirroredAxisDirection(0.0, 1.0);\n    AMCAX::Axis2 mirroedrAxis(mirroredAxisPoint, mirroredAxisDirection);\n    AMCAX::Circle2 circle2mirrored = circle2.Mirrored(mirroedrAxis);\n    CHECK(circle2mirrored.Length() == Approx(2 * M_PI * radius).epsilon(1e-15));\n    AMCAX::Point2 locationPmirrored = circle2mirrored.Location();\n    CHECK(locationPmirrored.X() == Approx(0.0).epsilon(1e-15));\n    CHECK(locationPmirrored.Y() == Approx(0.0).epsilon(1e-15));\n    AMCAX::Frame2 frame2mirrored = circle2mirrored.Position(); \n    CHECK(frame2mirrored.Location().X() == Approx(0.0).epsilon(1e-15));\n    CHECK(frame2mirrored.Location().Y() == Approx(0.0).epsilon(1e-15));\n    const double& radiusmirrored = circle2mirrored.Radius(); \n    CHECK(radiusmirrored == Approx(radius).epsilon(1e-15));\n    circle2mirrored.Scale(P,0.5); \n    AMCAX::Point2 scaleP1(0.0,-2.5);\n    CHECK(circle2mirrored.Contains(scaleP1, 0) == true);\n    AMCAX::Circle2 circle2Scaled = circle2mirrored.Scale(P, 2); \n    AMCAX::Point2 scaledP1(0.0, 5.0);\n    CHECK(circle2Scaled.Contains(scaledP1, 0) == true);\n    AMCAX::Point2 rotateP(0.0,0.0);\n    double angle = 90.0 * (2 * M_PI / 360.0);\n    circle2.Rotate(rotateP, angle); \n    AMCAX::Point2 P5(0.0, -3.0);\n    CHECK(circle2.Contains(P5, 0) == true);\n    double angle2 = -180.0 * (2 * M_PI / 360.0);\n    AMCAX::Circle2 rotatedCircle2 = circle2.Rotated(rotateP, angle2); \n    AMCAX::Point2 P6(0.0, 3.0);\n    CHECK(rotatedCircle2.Contains(P6, 0) == true); \n    AMCAX::Point2 newP(0.0, 0.0);\n    rotatedCircle2.SetLocation(newP);\n    CHECK(rotatedCircle2.Contains(P1, 0) == true);\n    std::cout << circle2.Length() << std::endl;\n}; "
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] double Radius()\t @return The radius\n\t @brief Get the radius\n,\n",
      "output": "#include<catch.hpp>\n#include \"testHelper.h\"\n#include<iostream>\n#include <math/CircleT.hpp>\n#include <common/AxisT.hpp>\n#include <common/PointT.hpp>\nTEST_CASE(\"CircleT Constructor Test\", \"[math][CircleT][P1]\") {\n\tSECTION(\"2D Circle Construction\") {\n        AMCAX::Circle2 circle2;\n        constexpr double maxr = std::numeric_limits<double>::max();\n        CHECK(circle2.Radius() == Approx(maxr).epsilon(1e-15));\n        CHECK(circle2.Area() == Approx(maxr * maxr * M_PI).epsilon(1e-15));\n        double a, b, c, d, e, f;\n        circle2.Coefficients(a, b, c, d, e, f);\n        std::cout << a << std::endl;\n        std::cout << b << std::endl;\n        std::cout << c << std::endl;\n        std::cout << d << std::endl;\n        std::cout << e << std::endl;\n        std::cout << f << std::endl;\n        AMCAX::Point2 P(0.0, 1.0);\n        double tolerance = 0.1;\n        CHECK(circle2.Contains(P, tolerance)==false);\n        CHECK(circle2.Distance(P) == Approx(maxr).epsilon(1e-15));\n    }} "
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "void SetRadius(double r)\t @param r The radius\n\t @brief Set the radius of the circle\n,\n",
      "output": "#include<catch.hpp>\n#include \"testHelper.h\"\n#include<iostream>\n#include <math/CircleT.hpp>\n#include <common/AxisT.hpp>\n#include <common/PointT.hpp>\nTEST_CASE(\"CircleT Area and Length Test\", \"[CircleT]\") {\n    AMCAX::Circle2 circle2;\n    circle2.SetRadius(5.0);\n    CHECK(circle2.Area() == Approx(78.53982));\n    CHECK(circle2.Length() == Approx(31.41593));\n    AMCAX::Circle3 circle3;\n    circle3.SetRadius(10.0);\n    CHECK(circle3.Area() == Approx(314.15927));\n    CHECK(circle3.Length() == Approx(62.83185));\n} "
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] double Distance(const PointT<double, DIM>& p)\t @return The distance from the point to the circle\n\t @param p The point\n\t @brief Compute the distance from a point to the circle\n,\n",
      "output": "#include<catch.hpp>\n#include \"testHelper.h\"\n#include<iostream>\n#include <math/CircleT.hpp>\n#include <common/AxisT.hpp>\n#include <common/PointT.hpp>\nTEST_CASE(\"case1: create a Cirecle\", \"[math][CircleT][P1]\") {\n\tAMCAX::Point2 P(0.0,0.0);\n\tAMCAX::Direction2 D(1.0,0.0);\n\tAMCAX::Axis2  axis2(P, D);\n\tfloat radius = 5.0f;\n\tAMCAX::Circle2 circle2(axis2, radius, true);\n\tCHECK(circle2.Area() == radius * radius * M_PI); \n    double a, b, c, d, e, f;\n    circle2.Coefficients(a, b, c, d, e, f);  \n    double x = 0, y = 5;\n    CHECK(a * x * x + b * y * y + c * x * y + d * x + e * y + f == Approx(0.0).epsilon(1e-15));\n    double x1 = 5 * sqrt(2) / 2;\n    double y1 = 5 * sqrt(2) / 2;\n    double x2 = 6;\n    double y2 = 0;\n    double x3 = 5.5;\n    double y3 = 6.1;\n    AMCAX::Point2 P1(x1,y1);\n    AMCAX::Point2 P2(x2, y2);\n    AMCAX::Point2 P3(x3, y3);\n    double tolerance1 = 0.1;\n    double tolerance2 = 1.0;\n    CHECK(circle2.Contains(P1, tolerance1) == true);\n    CHECK(circle2.Contains(P2, tolerance2) == true);\n    CHECK(circle2.Contains(P3, tolerance2) == false);\n    CHECK(circle2.Distance(P1) == Approx(0.0).epsilon(1e-15));\n    CHECK(circle2.Distance(P2) == Approx(1.0).epsilon(1e-15));\n    CHECK(circle2.Length() == Approx(2*M_PI*radius).epsilon(1e-15));\n    AMCAX::Point2 locationP = circle2.Location();\n    CHECK(locationP.X() == Approx(0.0).epsilon(1e-15));\n    CHECK(locationP.Y() == Approx(0.0).epsilon(1e-15));\n    AMCAX::Point2 mirrorAxisPoint(1.0, 0.0);\n    AMCAX::Direction2 mirrorAxisDirection(0.0, 1.0);\n    AMCAX::Axis2 mirrorAxis(mirrorAxisPoint, mirrorAxisDirection);\n    circle2.Mirror(mirrorAxis);\n    CHECK(circle2.Length() == Approx(2 * M_PI * radius).epsilon(1e-15));\n    AMCAX::Point2 locationPmirror = circle2.Location();\n    CHECK(locationPmirror.X() == Approx(2.0).epsilon(1e-15));\n    CHECK(locationPmirror.Y() == Approx(0.0).epsilon(1e-15));\n    AMCAX::Point2 P4(7.0, 0.0);  \n    CHECK(circle2.Contains(P4, tolerance2) == true);\n    AMCAX::Point2 mirroredAxisPoint(1.0, 0.0);\n    AMCAX::Direction2 mirroredAxisDirection(0.0, 1.0);\n    AMCAX::Axis2 mirroedrAxis(mirroredAxisPoint, mirroredAxisDirection);\n    AMCAX::Circle2 circle2mirrored = circle2.Mirrored(mirroedrAxis);\n    CHECK(circle2mirrored.Length() == Approx(2 * M_PI * radius).epsilon(1e-15));\n    AMCAX::Point2 locationPmirrored = circle2mirrored.Location();\n    CHECK(locationPmirrored.X() == Approx(0.0).epsilon(1e-15));\n    CHECK(locationPmirrored.Y() == Approx(0.0).epsilon(1e-15));\n    AMCAX::Frame2 frame2mirrored = circle2mirrored.Position(); \n    CHECK(frame2mirrored.Location().X() == Approx(0.0).epsilon(1e-15));\n    CHECK(frame2mirrored.Location().Y() == Approx(0.0).epsilon(1e-15));\n    const double& radiusmirrored = circle2mirrored.Radius(); \n    CHECK(radiusmirrored == Approx(radius).epsilon(1e-15));\n    circle2mirrored.Scale(P,0.5); \n    AMCAX::Point2 scaleP1(0.0,-2.5);\n    CHECK(circle2mirrored.Contains(scaleP1, 0) == true);\n    AMCAX::Circle2 circle2Scaled = circle2mirrored.Scale(P, 2); \n    AMCAX::Point2 scaledP1(0.0, 5.0);\n    CHECK(circle2Scaled.Contains(scaledP1, 0) == true);\n    AMCAX::Point2 rotateP(0.0,0.0);\n    double angle = 90.0 * (2 * M_PI / 360.0);\n    circle2.Rotate(rotateP, angle); \n    AMCAX::Point2 P5(0.0, -3.0);\n    CHECK(circle2.Contains(P5, 0) == true);\n    double angle2 = -180.0 * (2 * M_PI / 360.0);\n    AMCAX::Circle2 rotatedCircle2 = circle2.Rotated(rotateP, angle2); \n    AMCAX::Point2 P6(0.0, 3.0);\n    CHECK(rotatedCircle2.Contains(P6, 0) == true); \n    AMCAX::Point2 newP(0.0, 0.0);\n    rotatedCircle2.SetLocation(newP);\n    CHECK(rotatedCircle2.Contains(P1, 0) == true);\n    std::cout << circle2.Length() << std::endl;\n};\n}\n,\n{\n "
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] double Length()\t @return The length of the circle\n\t @brief Get the length of the circle\n,\n",
      "output": "#include<catch.hpp>\n#include \"testHelper.h\"\n#include<iostream>\n#include <math/CircleT.hpp>\n#include <common/AxisT.hpp>\n#include <common/PointT.hpp>\nTEST_CASE(\"case1: create a Cirecle\", \"[math][CircleT][P1]\") {\n\tAMCAX::Point2 P(0.0,0.0);\n\tAMCAX::Direction2 D(1.0,0.0);\n\tAMCAX::Axis2  axis2(P, D);\n\tfloat radius = 5.0f;\n\tAMCAX::Circle2 circle2(axis2, radius, true);\n\tCHECK(circle2.Area() == radius * radius * M_PI); \n    double a, b, c, d, e, f;\n    circle2.Coefficients(a, b, c, d, e, f);  \n    double x = 0, y = 5;\n    CHECK(a * x * x + b * y * y + c * x * y + d * x + e * y + f == Approx(0.0).epsilon(1e-15));\n    double x1 = 5 * sqrt(2) / 2;\n    double y1 = 5 * sqrt(2) / 2;\n    double x2 = 6;\n    double y2 = 0;\n    double x3 = 5.5;\n    double y3 = 6.1;\n    AMCAX::Point2 P1(x1,y1);\n    AMCAX::Point2 P2(x2, y2);\n    AMCAX::Point2 P3(x3, y3);\n    double tolerance1 = 0.1;\n    double tolerance2 = 1.0;\n    CHECK(circle2.Contains(P1, tolerance1) == true);\n    CHECK(circle2.Contains(P2, tolerance2) == true);\n    CHECK(circle2.Contains(P3, tolerance2) == false);\n    CHECK(circle2.Distance(P1) == Approx(0.0).epsilon(1e-15));\n    CHECK(circle2.Distance(P2) == Approx(1.0).epsilon(1e-15));\n    CHECK(circle2.Length() == Approx(2*M_PI*radius).epsilon(1e-15));\n    AMCAX::Point2 locationP = circle2.Location();\n    CHECK(locationP.X() == Approx(0.0).epsilon(1e-15));\n    CHECK(locationP.Y() == Approx(0.0).epsilon(1e-15));\n    AMCAX::Point2 mirrorAxisPoint(1.0, 0.0);\n    AMCAX::Direction2 mirrorAxisDirection(0.0, 1.0);\n    AMCAX::Axis2 mirrorAxis(mirrorAxisPoint, mirrorAxisDirection);\n    circle2.Mirror(mirrorAxis);\n    CHECK(circle2.Length() == Approx(2 * M_PI * radius).epsilon(1e-15));\n    AMCAX::Point2 locationPmirror = circle2.Location();\n    CHECK(locationPmirror.X() == Approx(2.0).epsilon(1e-15));\n    CHECK(locationPmirror.Y() == Approx(0.0).epsilon(1e-15));\n    AMCAX::Point2 P4(7.0, 0.0);  \n    CHECK(circle2.Contains(P4, tolerance2) == true);\n    AMCAX::Point2 mirroredAxisPoint(1.0, 0.0);\n    AMCAX::Direction2 mirroredAxisDirection(0.0, 1.0);\n    AMCAX::Axis2 mirroedrAxis(mirroredAxisPoint, mirroredAxisDirection);\n    AMCAX::Circle2 circle2mirrored = circle2.Mirrored(mirroedrAxis);\n    CHECK(circle2mirrored.Length() == Approx(2 * M_PI * radius).epsilon(1e-15));\n    AMCAX::Point2 locationPmirrored = circle2mirrored.Location();\n    CHECK(locationPmirrored.X() == Approx(0.0).epsilon(1e-15));\n    CHECK(locationPmirrored.Y() == Approx(0.0).epsilon(1e-15));\n    AMCAX::Frame2 frame2mirrored = circle2mirrored.Position(); \n    CHECK(frame2mirrored.Location().X() == Approx(0.0).epsilon(1e-15));\n    CHECK(frame2mirrored.Location().Y() == Approx(0.0).epsilon(1e-15));\n    const double& radiusmirrored = circle2mirrored.Radius(); \n    CHECK(radiusmirrored == Approx(radius).epsilon(1e-15));\n    circle2mirrored.Scale(P,0.5); \n    AMCAX::Point2 scaleP1(0.0,-2.5);\n    CHECK(circle2mirrored.Contains(scaleP1, 0) == true);\n    AMCAX::Circle2 circle2Scaled = circle2mirrored.Scale(P, 2); \n    AMCAX::Point2 scaledP1(0.0, 5.0);\n    CHECK(circle2Scaled.Contains(scaledP1, 0) == true);\n    AMCAX::Point2 rotateP(0.0,0.0);\n    double angle = 90.0 * (2 * M_PI / 360.0);\n    circle2.Rotate(rotateP, angle); \n    AMCAX::Point2 P5(0.0, -3.0);\n    CHECK(circle2.Contains(P5, 0) == true);\n    double angle2 = -180.0 * (2 * M_PI / 360.0);\n    AMCAX::Circle2 rotatedCircle2 = circle2.Rotated(rotateP, angle2); \n    AMCAX::Point2 P6(0.0, 3.0);\n    CHECK(rotatedCircle2.Contains(P6, 0) == true); \n    AMCAX::Point2 newP(0.0, 0.0);\n    rotatedCircle2.SetLocation(newP);\n    CHECK(rotatedCircle2.Contains(P1, 0) == true);\n    std::cout << circle2.Length() << std::endl;\n}; "
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] double Radius()\t @return The radius\n\t @brief Get the radius\n,\n",
      "output": "#include<catch.hpp>\n#include \"testHelper.h\"\n#include<iostream>\n#include <math/CircleT.hpp>\n#include <common/AxisT.hpp>\n#include <common/PointT.hpp>\nTEST_CASE(\"CircleT Constructor Test\", \"[math][CircleT][P1]\") {\n\tSECTION(\"2D Circle Construction\") {\n        AMCAX::Circle2 circle2;\n        constexpr double maxr = std::numeric_limits<double>::max();\n        CHECK(circle2.Radius() == Approx(maxr).epsilon(1e-15));\n        CHECK(circle2.Area() == Approx(maxr * maxr * M_PI).epsilon(1e-15));\n        double a, b, c, d, e, f;\n        circle2.Coefficients(a, b, c, d, e, f);\n        std::cout << a << std::endl;\n        std::cout << b << std::endl;\n        std::cout << c << std::endl;\n        std::cout << d << std::endl;\n        std::cout << e << std::endl;\n        std::cout << f << std::endl;\n        AMCAX::Point2 P(0.0, 1.0);\n        double tolerance = 0.1;\n        CHECK(circle2.Contains(P, tolerance)==false);\n        CHECK(circle2.Distance(P) == Approx(maxr).epsilon(1e-15));\n    }} "
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "void SetRadius(double r)\t @param r The radius\n\t @brief Set the radius of the circle\n,\n",
      "output": "#include<catch.hpp>\n#include \"testHelper.h\"\n#include<iostream>\n#include <math/CircleT.hpp>\n#include <common/AxisT.hpp>\n#include <common/PointT.hpp>\nTEST_CASE(\"CircleT Area and Length Test\", \"[CircleT]\") {\n    AMCAX::Circle2 circle2;\n    circle2.SetRadius(5.0);\n    CHECK(circle2.Area() == Approx(78.53982));\n    CHECK(circle2.Length() == Approx(31.41593));\n    AMCAX::Circle3 circle3;\n    circle3.SetRadius(10.0);\n    CHECK(circle3.Area() == Approx(314.15927));\n    CHECK(circle3.Length() == Approx(62.83185));\n} "
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "CircleS& Scale(const PointT<double, DIM>& p, double scale)\t @return The reference to self\n\t @param scale The scale value\n\t @param p The scaling center point\n\t @brief Scale the circle by a center point\n,\n",
      "output": "#include <math/CircleT.hpp>\n#include <common/CoordT.hpp>\n#include <common/TransformationType.hpp>\n#include <common/DirectionT.hpp>\n#include <common/PointT.hpp>\n#include <common/Precision.hpp>\n#include <common/CoordT.hpp>\n#include <common/TransformationType.hpp>\n#include <topology/TopoEdge.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <topology/TopoWire.hpp>\n#include <modeling/MakeWire.hpp>\n#include <geometry/GlobalProperty.hpp>\n#include <topology/BRepGlobalProperty.hpp>\n#include<iostream>\n#include \"catch.hpp\" \nusing namespace std;\nusing namespace AMCAX;\nTEST_CASE(\"TestCircle2D\", \"[math][Circle2D]\")\n{\n\tAMCAX::CircleT<double, 2> circle2D;\n\tAMCAX::Point2 center2D(0.0, 0.0);\n\tdouble redius2D = 5.0;\n\tdouble tol = 0.1;\n\tcircle2D.SetLocation(center2D);\n\tcircle2D.SetRadius(redius2D);\n\tdouble area2D = circle2D.Area();\n\tdouble length2D = circle2D.Length();\n\tAMCAX::Point2 retcenter2D = circle2D.Location();\n\tdouble retarea2D = M_PI * redius2D * redius2D;\n\tdouble retlength2D = 2 * M_PI * redius2D;\n\tstd::cout << area2D << std::endl;\n\tstd::cout << length2D << std::endl;\n\tstd::cout << retcenter2D.X() << std::endl;\n\tstd::cout << retcenter2D.Y() << std::endl;\n\tCHECK(area2D == retarea2D);\n\tCHECK(length2D == retlength2D);\n\tCHECK(retcenter2D.X() == center2D.X());\n\tCHECK(retcenter2D.Y() == center2D.Y());\n\tdouble a, b, c, d, e, f;\n\tcircle2D.Coefficients(a, b, c, d, e, f);\n\tstd::cout << a << std::endl;\n\tstd::cout << b << std::endl;\n\tstd::cout << c << std::endl;\n\tstd::cout << d << std::endl;\n\tstd::cout << e << std::endl;\n\tstd::cout << f << std::endl;\n\tCHECK(a == 1);\n\tCHECK(b == 1);\n\tCHECK(c == 0);\n\tCHECK(d == 0);\n\tCHECK(e == 0);\n\tCHECK(f == -25);\n\tstd::vector < AMCAX::Point2> testPoints = {\n\t\tAMCAX::Point2(3.0, 4.0),\n\t\tAMCAX::Point2(5.0, 0.0),\n\t\tAMCAX::Point2(4.9, 0.0),\n\t\tAMCAX::Point2(5.1, 0.0),\n\t\tAMCAX::Point2(6.0, 0.0)\n\t};\n\tfor (const auto& point : testPoints)\n\t{\n\t\tdouble distanceToCenter = std::sqrt(point.X() * point.X() + point.Y() * point.Y());\n\t\tbool expectedIsInCircle = distanceToCenter <= 5.0 + tol;\n\t\tbool isInCircle = circle2D.Contains(point, tol);\n\t\tCHECK(isInCircle == expectedIsInCircle);\n\t}\n\tfor (const auto& point : testPoints)\n\t{\n\t\tdouble distance = circle2D.Distance(point);\n\t\tdouble expectedDistance = std::abs(std::sqrt(std::pow(point.X() - center2D.X(), 2) + std::pow(point.Y() - center2D.Y(), 2)) - redius2D);\n\t\tCHECK(distance == expectedDistance);\n\t}\n\tAMCAX::AxisT<double, 2> mirrorAxis(AMCAX::Point2(0.0, 0.0), AMCAX::Direction2(0.0, 1.0));\n\tcircle2D.Mirror(mirrorAxis);\n\tAMCAX::Point2 mirroredCenter = circle2D.Location();\n\tstd::cout << \"Mirrored circle center: (\" << mirroredCenter.X() << \", \" << mirroredCenter.Y() << \")\" << std::endl;\n\tCHECK(mirroredCenter.X() == center2D.X());\n\tCHECK(mirroredCenter.Y() == center2D.Y());\n\tconst AMCAX::FrameT<double, 2>& frame = circle2D.Position();\n\tAMCAX::Point2 rotationPoint(0.0, 0.0);\n\tdouble  rotationAngle = M_PI / 4;\n\tauto rotatedCircle = circle2D.Rotated(rotationPoint, rotationAngle);\n\tdouble cosAngle = cos(rotationAngle);\n\tdouble sinAngle = sin(rotationAngle);\n\tdouble newX = cosAngle * (center2D.X() - rotationPoint.X()) - sinAngle * (center2D.Y() - rotationPoint.Y()) + rotationPoint.X();\n\tdouble newY = sinAngle * (center2D.X() - rotationPoint.X()) + cosAngle * (center2D.Y() - rotationPoint.Y()) + rotationPoint.Y();\n\tauto rotatedCenter = rotatedCircle.Location();\n\tCHECK(newX == center2D.X());\n\tCHECK(newY == center2D.Y());\n\tAMCAX::Point2 scalingCenter(0.0, 0.0);\n\tdouble scalingFactor = 2.0;\n\tauto scaledCircle = circle2D.Scale(scalingCenter, scalingFactor);\n\tdouble scaledRadius = scaledCircle.Radius();\n\tdouble expectedScaledRadius = redius2D * scalingFactor;\n\tCHECK(std::abs(scaledRadius - expectedScaledRadius) < 1e-6);\n\tAMCAX::VectorT<double, 2> translationVector(2.0, 3.0);\n\tauto translatedCircle = circle2D.Translated(translationVector);\n\tauto translatedCenter = translatedCircle.Location();\n\tdouble translatedX = center2D.X() + translationVector.X();\n\tCHECK(translatedX == translatedCenter.X());\n\tauto xAxis = circle2D.XAxis();\n\tauto directionAxis = xAxis.Direction();\n\tCHECK(directionAxis.X() == -1.0);\n\tCHECK(directionAxis.Y() == 0.0);\n} "
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] double SquaredDistance(const PointT<double, DIM>& p)\t @return The squared distance from the point to the circle\n\t @param p The point\n\t @brief Compute the squared distance from a point to the circle\n,\n",
      "output": "#include <math/CircleT.hpp>\n#include <common/CoordT.hpp>\n#include <common/TransformationType.hpp>\n#include <common/DirectionT.hpp>\n#include <common/PointT.hpp>\n#include <common/Precision.hpp>\n#include <common/CoordT.hpp>\n#include <common/TransformationType.hpp>\n#include <topology/TopoEdge.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <topology/TopoWire.hpp>\n#include <modeling/MakeWire.hpp>\n#include <geometry/GlobalProperty.hpp>\n#include <topology/BRepGlobalProperty.hpp>\n#include<iostream>\n#include \"catch.hpp\" \nusing namespace std;\nusing namespace AMCAX;\nTEST_CASE(\"TestCircle3D\", \"[math][Circle3D]\")\n{\n\tAMCAX::Circle3 circle3D;\n\tAMCAX::Point3  center3D(0.0, 0.0, 0.0);\n\tdouble radius3D = 5.0;\n\tdouble tol = 0.1;\n\tcircle3D.SetLocation(center3D);\n\tcircle3D.SetRadius(radius3D);\n\tdouble area = circle3D.Area();\n\tauto axis = circle3D.Axis();\n\tAMCAX::Point3 expectedDirection(0.0, 0.0, 1.0);\n\tauto direction = axis.Direction();\n\tCHECK(area == Approx(78.5398));\n\tCHECK(direction.X() == Approx(expectedDirection.X()).margin(tol));\n\tCHECK(direction.Y() == Approx(expectedDirection.Y()).margin(tol));\n\tCHECK(direction.Z() == Approx(expectedDirection.Z()).margin(tol));\n\tstd::vector <AMCAX::Point3> test3DPoints = {\n\t\tAMCAX::Point3(0.0, 0.0, 0.0),\n\t\tAMCAX::Point3(4.0, 0.0, 0.0),\n\t};\n\tfor (const auto& point : test3DPoints)\n\t{\n\t\tdouble distanceToCenter = std::sqrt(std::pow(point.X() - center3D.X(), 2) + std::pow(point.Y() - center3D.Y(), 2) + std::pow(point.Z() - center3D.Z(), 2));\n\t\tbool expectedIsCircle = distanceToCenter <= 5.0 + tol;\n\t\tbool isInCircle = circle3D.Contains(point, tol);\n\t\tCHECK(!isInCircle == expectedIsCircle);\n\t}\n\tAMCAX::PointT<double, 3>  pointOutside(10.0, 0.0, 0.0);\n\tdouble expectedDistance = 5.0;\n\tCHECK(circle3D.Distance(pointOutside) == Approx(expectedDistance));\n\tdouble length = circle3D.Length();\n\tCHECK(length == Approx(31.4159));\n\tauto location = circle3D.Location();\n\tCHECK(location.X() == Approx(0.0));\n\tCHECK(location.Y() == Approx(0.0));\n\tCHECK(location.Z() == Approx(0.0));\n\tAMCAX::PointT<double, 3> mirrorPoint(1.0, 0.0, 0.0);\n\tcircle3D.Mirror(mirrorPoint);\n\tauto mirroredLocation = circle3D.Location();\n\tCHECK(mirroredLocation.X() == Approx(2.0));\n\tCHECK(mirroredLocation.Y() == Approx(0.0));\n\tCHECK(mirroredLocation.Z() == Approx(0.0));\n\tauto position = circle3D.Position();   \n\tdouble r = circle3D.Radius();\n\tCHECK(r == 5.0);\n\tDirection3 zDirection(0.0, 0.0, 1.0);\n\tAxis3 zAxis(center3D, zDirection);\n\tTransformation3 rotation;\n\trotation.SetRotation(zAxis, M_PI / 2);  \n\tPoint3 newCenter1 = center3D.Transformed(rotation);\n\tCHECK(newCenter1.X() == 0.0);\n\tCHECK(newCenter1.Y() == 0.0);\n\tCHECK(newCenter1.Z() == 0.0);\n\tdouble angle = M_PI / 2;\n\tcircle3D.Rotated(zAxis, angle);\n\tAMCAX::Frame3 frame = circle3D.Position();\n\tCHECK(frame.Location().X() == 2.0);\n\tCHECK(frame.Location().Y() == 0.0);\n\tCHECK(frame.Location().Z() == 0.0);\n\tdouble scale = 2.0;\n\tcircle3D.Scale(center3D, scale);\n\tCHECK(circle3D.Radius() == radius3D * 2.0);\n\tAMCAX::PointT<double, 3> insidePoint(3.0, 4.0, 0.0);\n\tAMCAX::PointT<double, 3> onCirclePoint(5.0, 0.0, 0.0);\n\tAMCAX::PointT<double, 3> outsidePoint(8.0, 6.0, 0.0);\n\tdouble insideSquaredDistance = circle3D.SquaredDistance(insidePoint);\n\tdouble onCircleSquaredDistance = circle3D.SquaredDistance(onCirclePoint);\n\tdouble outsideSquaredDistance = circle3D.SquaredDistance(outsidePoint);\n\tCHECK(insideSquaredDistance == Approx(34.5378));\n\tCHECK(onCircleSquaredDistance == 81.0);\n\tCHECK(outsideSquaredDistance == Approx(7.7779));\n\tVectorT<double, 3> translationVector(5.0, 5.0, 0.0);\n\tcircle3D.Translate(translationVector);\n\tCHECK(circle3D.Location().X() == 9.0);\n\tCHECK(circle3D.Location().Y() == 5.0);\n\tCHECK(circle3D.Location().Z() == 0.0);\n\tauto xAxis = circle3D.XAxis();\n\tauto yAxis = circle3D.YAxis();\n\tCHECK(xAxis.Direction().X() == Approx(-1.0));\n\tCHECK(yAxis.Direction().Y() == Approx(-1.0));\n} "
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] double Distance(const PointT<double, DIM>& p)\t @return The distance from the point to the circle\n\t @param p The point\n\t @brief Compute the distance from a point to the circle\n,\n",
      "output": "#include <math/CircleT.hpp>\n#include <common/CoordT.hpp>\n#include <common/TransformationType.hpp>\n#include <common/DirectionT.hpp>\n#include <common/PointT.hpp>\n#include <common/Precision.hpp>\n#include <common/CoordT.hpp>\n#include <common/TransformationType.hpp>\n#include <topology/TopoEdge.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <topology/TopoWire.hpp>\n#include <modeling/MakeWire.hpp>\n#include <geometry/GlobalProperty.hpp>\n#include <topology/BRepGlobalProperty.hpp>\n#include<iostream>\n#include \"catch.hpp\" \nusing namespace std;\nusing namespace AMCAX;\nTEST_CASE(\"TestCircle2D\", \"[math][Circle2D]\")\n{\n\tAMCAX::CircleT<double, 2> circle2D;\n\tAMCAX::Point2 center2D(0.0, 0.0);\n\tdouble redius2D = 5.0;\n\tdouble tol = 0.1;\n\tcircle2D.SetLocation(center2D);\n\tcircle2D.SetRadius(redius2D);\n\tdouble area2D = circle2D.Area();\n\tdouble length2D = circle2D.Length();\n\tAMCAX::Point2 retcenter2D = circle2D.Location();\n\tdouble retarea2D = M_PI * redius2D * redius2D;\n\tdouble retlength2D = 2 * M_PI * redius2D;\n\tstd::cout << area2D << std::endl;\n\tstd::cout << length2D << std::endl;\n\tstd::cout << retcenter2D.X() << std::endl;\n\tstd::cout << retcenter2D.Y() << std::endl;\n\tCHECK(area2D == retarea2D);\n\tCHECK(length2D == retlength2D);\n\tCHECK(retcenter2D.X() == center2D.X());\n\tCHECK(retcenter2D.Y() == center2D.Y());\n\tdouble a, b, c, d, e, f;\n\tcircle2D.Coefficients(a, b, c, d, e, f);\n\tstd::cout << a << std::endl;\n\tstd::cout << b << std::endl;\n\tstd::cout << c << std::endl;\n\tstd::cout << d << std::endl;\n\tstd::cout << e << std::endl;\n\tstd::cout << f << std::endl;\n\tCHECK(a == 1);\n\tCHECK(b == 1);\n\tCHECK(c == 0);\n\tCHECK(d == 0);\n\tCHECK(e == 0);\n\tCHECK(f == -25);\n\tstd::vector < AMCAX::Point2> testPoints = {\n\t\tAMCAX::Point2(3.0, 4.0),\n\t\tAMCAX::Point2(5.0, 0.0),\n\t\tAMCAX::Point2(4.9, 0.0),\n\t\tAMCAX::Point2(5.1, 0.0),\n\t\tAMCAX::Point2(6.0, 0.0)\n\t};\n\tfor (const auto& point : testPoints)\n\t{\n\t\tdouble distanceToCenter = std::sqrt(point.X() * point.X() + point.Y() * point.Y());\n\t\tbool expectedIsInCircle = distanceToCenter <= 5.0 + tol;\n\t\tbool isInCircle = circle2D.Contains(point, tol);\n\t\tCHECK(isInCircle == expectedIsInCircle);\n\t}\n\tfor (const auto& point : testPoints)\n\t{\n\t\tdouble distance = circle2D.Distance(point);\n\t\tdouble expectedDistance = std::abs(std::sqrt(std::pow(point.X() - center2D.X(), 2) + std::pow(point.Y() - center2D.Y(), 2)) - redius2D);\n\t\tCHECK(distance == expectedDistance);\n\t}\n\tAMCAX::AxisT<double, 2> mirrorAxis(AMCAX::Point2(0.0, 0.0), AMCAX::Direction2(0.0, 1.0));\n\tcircle2D.Mirror(mirrorAxis);\n\tAMCAX::Point2 mirroredCenter = circle2D.Location();\n\tstd::cout << \"Mirrored circle center: (\" << mirroredCenter.X() << \", \" << mirroredCenter.Y() << \")\" << std::endl;\n\tCHECK(mirroredCenter.X() == center2D.X());\n\tCHECK(mirroredCenter.Y() == center2D.Y());\n\tconst AMCAX::FrameT<double, 2>& frame = circle2D.Position();\n\tAMCAX::Point2 rotationPoint(0.0, 0.0);\n\tdouble  rotationAngle = M_PI / 4;\n\tauto rotatedCircle = circle2D.Rotated(rotationPoint, rotationAngle);\n\tdouble cosAngle = cos(rotationAngle);\n\tdouble sinAngle = sin(rotationAngle);\n\tdouble newX = cosAngle * (center2D.X() - rotationPoint.X()) - sinAngle * (center2D.Y() - rotationPoint.Y()) + rotationPoint.X();\n\tdouble newY = sinAngle * (center2D.X() - rotationPoint.X()) + cosAngle * (center2D.Y() - rotationPoint.Y()) + rotationPoint.Y();\n\tauto rotatedCenter = rotatedCircle.Location();\n\tCHECK(newX == center2D.X());\n\tCHECK(newY == center2D.Y());\n\tAMCAX::Point2 scalingCenter(0.0, 0.0);\n\tdouble scalingFactor = 2.0;\n\tauto scaledCircle = circle2D.Scale(scalingCenter, scalingFactor);\n\tdouble scaledRadius = scaledCircle.Radius();\n\tdouble expectedScaledRadius = redius2D * scalingFactor;\n\tCHECK(std::abs(scaledRadius - expectedScaledRadius) < 1e-6);\n\tAMCAX::VectorT<double, 2> translationVector(2.0, 3.0);\n\tauto translatedCircle = circle2D.Translated(translationVector);\n\tauto translatedCenter = translatedCircle.Location();\n\tdouble translatedX = center2D.X() + translationVector.X();\n\tCHECK(translatedX == translatedCenter.X());\n\tauto xAxis = circle2D.XAxis();\n\tauto directionAxis = xAxis.Direction();\n\tCHECK(directionAxis.X() == -1.0);\n\tCHECK(directionAxis.Y() == 0.0);\n} "
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] double Length()\t @return The length of the circle\n\t @brief Get the length of the circle\n,\n",
      "output": "#include <math/CircleT.hpp>\n#include <common/CoordT.hpp>\n#include <common/TransformationType.hpp>\n#include <common/DirectionT.hpp>\n#include <common/PointT.hpp>\n#include <common/Precision.hpp>\n#include <common/CoordT.hpp>\n#include <common/TransformationType.hpp>\n#include <topology/TopoEdge.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <topology/TopoWire.hpp>\n#include <modeling/MakeWire.hpp>\n#include <geometry/GlobalProperty.hpp>\n#include <topology/BRepGlobalProperty.hpp>\n#include<iostream>\n#include \"catch.hpp\" \nusing namespace std;\nusing namespace AMCAX;\nTEST_CASE(\"TestCircle2D\", \"[math][Circle2D]\")\n{\n\tAMCAX::CircleT<double, 2> circle2D;\n\tAMCAX::Point2 center2D(0.0, 0.0);\n\tdouble redius2D = 5.0;\n\tdouble tol = 0.1;\n\tcircle2D.SetLocation(center2D);\n\tcircle2D.SetRadius(redius2D);\n\tdouble area2D = circle2D.Area();\n\tdouble length2D = circle2D.Length();\n\tAMCAX::Point2 retcenter2D = circle2D.Location();\n\tdouble retarea2D = M_PI * redius2D * redius2D;\n\tdouble retlength2D = 2 * M_PI * redius2D;\n\tstd::cout << area2D << std::endl;\n\tstd::cout << length2D << std::endl;\n\tstd::cout << retcenter2D.X() << std::endl;\n\tstd::cout << retcenter2D.Y() << std::endl;\n\tCHECK(area2D == retarea2D);\n\tCHECK(length2D == retlength2D);\n\tCHECK(retcenter2D.X() == center2D.X());\n\tCHECK(retcenter2D.Y() == center2D.Y());\n\tdouble a, b, c, d, e, f;\n\tcircle2D.Coefficients(a, b, c, d, e, f);\n\tstd::cout << a << std::endl;\n\tstd::cout << b << std::endl;\n\tstd::cout << c << std::endl;\n\tstd::cout << d << std::endl;\n\tstd::cout << e << std::endl;\n\tstd::cout << f << std::endl;\n\tCHECK(a == 1);\n\tCHECK(b == 1);\n\tCHECK(c == 0);\n\tCHECK(d == 0);\n\tCHECK(e == 0);\n\tCHECK(f == -25);\n\tstd::vector < AMCAX::Point2> testPoints = {\n\t\tAMCAX::Point2(3.0, 4.0),\n\t\tAMCAX::Point2(5.0, 0.0),\n\t\tAMCAX::Point2(4.9, 0.0),\n\t\tAMCAX::Point2(5.1, 0.0),\n\t\tAMCAX::Point2(6.0, 0.0)\n\t};\n\tfor (const auto& point : testPoints)\n\t{\n\t\tdouble distanceToCenter = std::sqrt(point.X() * point.X() + point.Y() * point.Y());\n\t\tbool expectedIsInCircle = distanceToCenter <= 5.0 + tol;\n\t\tbool isInCircle = circle2D.Contains(point, tol);\n\t\tCHECK(isInCircle == expectedIsInCircle);\n\t}\n\tfor (const auto& point : testPoints)\n\t{\n\t\tdouble distance = circle2D.Distance(point);\n\t\tdouble expectedDistance = std::abs(std::sqrt(std::pow(point.X() - center2D.X(), 2) + std::pow(point.Y() - center2D.Y(), 2)) - redius2D);\n\t\tCHECK(distance == expectedDistance);\n\t}\n\tAMCAX::AxisT<double, 2> mirrorAxis(AMCAX::Point2(0.0, 0.0), AMCAX::Direction2(0.0, 1.0));\n\tcircle2D.Mirror(mirrorAxis);\n\tAMCAX::Point2 mirroredCenter = circle2D.Location();\n\tstd::cout << \"Mirrored circle center: (\" << mirroredCenter.X() << \", \" << mirroredCenter.Y() << \")\" << std::endl;\n\tCHECK(mirroredCenter.X() == center2D.X());\n\tCHECK(mirroredCenter.Y() == center2D.Y());\n\tconst AMCAX::FrameT<double, 2>& frame = circle2D.Position();\n\tAMCAX::Point2 rotationPoint(0.0, 0.0);\n\tdouble  rotationAngle = M_PI / 4;\n\tauto rotatedCircle = circle2D.Rotated(rotationPoint, rotationAngle);\n\tdouble cosAngle = cos(rotationAngle);\n\tdouble sinAngle = sin(rotationAngle);\n\tdouble newX = cosAngle * (center2D.X() - rotationPoint.X()) - sinAngle * (center2D.Y() - rotationPoint.Y()) + rotationPoint.X();\n\tdouble newY = sinAngle * (center2D.X() - rotationPoint.X()) + cosAngle * (center2D.Y() - rotationPoint.Y()) + rotationPoint.Y();\n\tauto rotatedCenter = rotatedCircle.Location();\n\tCHECK(newX == center2D.X());\n\tCHECK(newY == center2D.Y());\n\tAMCAX::Point2 scalingCenter(0.0, 0.0);\n\tdouble scalingFactor = 2.0;\n\tauto scaledCircle = circle2D.Scale(scalingCenter, scalingFactor);\n\tdouble scaledRadius = scaledCircle.Radius();\n\tdouble expectedScaledRadius = redius2D * scalingFactor;\n\tCHECK(std::abs(scaledRadius - expectedScaledRadius) < 1e-6);\n\tAMCAX::VectorT<double, 2> translationVector(2.0, 3.0);\n\tauto translatedCircle = circle2D.Translated(translationVector);\n\tauto translatedCenter = translatedCircle.Location();\n\tdouble translatedX = center2D.X() + translationVector.X();\n\tCHECK(translatedX == translatedCenter.X());\n\tauto xAxis = circle2D.XAxis();\n\tauto directionAxis = xAxis.Direction();\n\tCHECK(directionAxis.X() == -1.0);\n\tCHECK(directionAxis.Y() == 0.0);\n} "
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] double Radius()\t @return The radius\n\t @brief Get the radius\n,\n",
      "output": "#include <math/CircleT.hpp>\n#include <common/CoordT.hpp>\n#include <common/TransformationType.hpp>\n#include <common/DirectionT.hpp>\n#include <common/PointT.hpp>\n#include <common/Precision.hpp>\n#include <common/CoordT.hpp>\n#include <common/TransformationType.hpp>\n#include <topology/TopoEdge.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <topology/TopoWire.hpp>\n#include <modeling/MakeWire.hpp>\n#include <geometry/GlobalProperty.hpp>\n#include <topology/BRepGlobalProperty.hpp>\n#include<iostream>\n#include \"catch.hpp\" \nusing namespace std;\nusing namespace AMCAX;\nTEST_CASE(\"TestCircle3D\", \"[math][Circle3D]\")\n{\n\tAMCAX::Circle3 circle3D;\n\tAMCAX::Point3  center3D(0.0, 0.0, 0.0);\n\tdouble radius3D = 5.0;\n\tdouble tol = 0.1;\n\tcircle3D.SetLocation(center3D);\n\tcircle3D.SetRadius(radius3D);\n\tdouble area = circle3D.Area();\n\tauto axis = circle3D.Axis();\n\tAMCAX::Point3 expectedDirection(0.0, 0.0, 1.0);\n\tauto direction = axis.Direction();\n\tCHECK(area == Approx(78.5398));\n\tCHECK(direction.X() == Approx(expectedDirection.X()).margin(tol));\n\tCHECK(direction.Y() == Approx(expectedDirection.Y()).margin(tol));\n\tCHECK(direction.Z() == Approx(expectedDirection.Z()).margin(tol));\n\tstd::vector <AMCAX::Point3> test3DPoints = {\n\t\tAMCAX::Point3(0.0, 0.0, 0.0),\n\t\tAMCAX::Point3(4.0, 0.0, 0.0),\n\t};\n\tfor (const auto& point : test3DPoints)\n\t{\n\t\tdouble distanceToCenter = std::sqrt(std::pow(point.X() - center3D.X(), 2) + std::pow(point.Y() - center3D.Y(), 2) + std::pow(point.Z() - center3D.Z(), 2));\n\t\tbool expectedIsCircle = distanceToCenter <= 5.0 + tol;\n\t\tbool isInCircle = circle3D.Contains(point, tol);\n\t\tCHECK(!isInCircle == expectedIsCircle);\n\t}\n\tAMCAX::PointT<double, 3>  pointOutside(10.0, 0.0, 0.0);\n\tdouble expectedDistance = 5.0;\n\tCHECK(circle3D.Distance(pointOutside) == Approx(expectedDistance));\n\tdouble length = circle3D.Length();\n\tCHECK(length == Approx(31.4159));\n\tauto location = circle3D.Location();\n\tCHECK(location.X() == Approx(0.0));\n\tCHECK(location.Y() == Approx(0.0));\n\tCHECK(location.Z() == Approx(0.0));\n\tAMCAX::PointT<double, 3> mirrorPoint(1.0, 0.0, 0.0);\n\tcircle3D.Mirror(mirrorPoint);\n\tauto mirroredLocation = circle3D.Location();\n\tCHECK(mirroredLocation.X() == Approx(2.0));\n\tCHECK(mirroredLocation.Y() == Approx(0.0));\n\tCHECK(mirroredLocation.Z() == Approx(0.0));\n\tauto position = circle3D.Position();   \n\tdouble r = circle3D.Radius();\n\tCHECK(r == 5.0);\n\tDirection3 zDirection(0.0, 0.0, 1.0);\n\tAxis3 zAxis(center3D, zDirection);\n\tTransformation3 rotation;\n\trotation.SetRotation(zAxis, M_PI / 2);  \n\tPoint3 newCenter1 = center3D.Transformed(rotation);\n\tCHECK(newCenter1.X() == 0.0);\n\tCHECK(newCenter1.Y() == 0.0);\n\tCHECK(newCenter1.Z() == 0.0);\n\tdouble angle = M_PI / 2;\n\tcircle3D.Rotated(zAxis, angle);\n\tAMCAX::Frame3 frame = circle3D.Position();\n\tCHECK(frame.Location().X() == 2.0);\n\tCHECK(frame.Location().Y() == 0.0);\n\tCHECK(frame.Location().Z() == 0.0);\n\tdouble scale = 2.0;\n\tcircle3D.Scale(center3D, scale);\n\tCHECK(circle3D.Radius() == radius3D * 2.0);\n\tAMCAX::PointT<double, 3> insidePoint(3.0, 4.0, 0.0);\n\tAMCAX::PointT<double, 3> onCirclePoint(5.0, 0.0, 0.0);\n\tAMCAX::PointT<double, 3> outsidePoint(8.0, 6.0, 0.0);\n\tdouble insideSquaredDistance = circle3D.SquaredDistance(insidePoint);\n\tdouble onCircleSquaredDistance = circle3D.SquaredDistance(onCirclePoint);\n\tdouble outsideSquaredDistance = circle3D.SquaredDistance(outsidePoint);\n\tCHECK(insideSquaredDistance == Approx(34.5378));\n\tCHECK(onCircleSquaredDistance == 81.0);\n\tCHECK(outsideSquaredDistance == Approx(7.7779));\n\tVectorT<double, 3> translationVector(5.0, 5.0, 0.0);\n\tcircle3D.Translate(translationVector);\n\tCHECK(circle3D.Location().X() == 9.0);\n\tCHECK(circle3D.Location().Y() == 5.0);\n\tCHECK(circle3D.Location().Z() == 0.0);\n\tauto xAxis = circle3D.XAxis();\n\tauto yAxis = circle3D.YAxis();\n\tCHECK(xAxis.Direction().X() == Approx(-1.0));\n\tCHECK(yAxis.Direction().Y() == Approx(-1.0));\n} "
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "void SetRadius(double r)\t @param r The radius\n\t @brief Set the radius of the circle\n,\n",
      "output": "#include <math/CircleT.hpp>\n#include <common/CoordT.hpp>\n#include <common/TransformationType.hpp>\n#include <common/DirectionT.hpp>\n#include <common/PointT.hpp>\n#include <common/Precision.hpp>\n#include <common/CoordT.hpp>\n#include <common/TransformationType.hpp>\n#include <topology/TopoEdge.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <topology/TopoWire.hpp>\n#include <modeling/MakeWire.hpp>\n#include <geometry/GlobalProperty.hpp>\n#include <topology/BRepGlobalProperty.hpp>\n#include<iostream>\n#include \"catch.hpp\" \nusing namespace std;\nusing namespace AMCAX;\nTEST_CASE(\"TestCircle2D\", \"[math][Circle2D]\")\n{\n\tAMCAX::CircleT<double, 2> circle2D;\n\tAMCAX::Point2 center2D(0.0, 0.0);\n\tdouble redius2D = 5.0;\n\tdouble tol = 0.1;\n\tcircle2D.SetLocation(center2D);\n\tcircle2D.SetRadius(redius2D);\n\tdouble area2D = circle2D.Area();\n\tdouble length2D = circle2D.Length();\n\tAMCAX::Point2 retcenter2D = circle2D.Location();\n\tdouble retarea2D = M_PI * redius2D * redius2D;\n\tdouble retlength2D = 2 * M_PI * redius2D;\n\tstd::cout << area2D << std::endl;\n\tstd::cout << length2D << std::endl;\n\tstd::cout << retcenter2D.X() << std::endl;\n\tstd::cout << retcenter2D.Y() << std::endl;\n\tCHECK(area2D == retarea2D);\n\tCHECK(length2D == retlength2D);\n\tCHECK(retcenter2D.X() == center2D.X());\n\tCHECK(retcenter2D.Y() == center2D.Y());\n\tdouble a, b, c, d, e, f;\n\tcircle2D.Coefficients(a, b, c, d, e, f);\n\tstd::cout << a << std::endl;\n\tstd::cout << b << std::endl;\n\tstd::cout << c << std::endl;\n\tstd::cout << d << std::endl;\n\tstd::cout << e << std::endl;\n\tstd::cout << f << std::endl;\n\tCHECK(a == 1);\n\tCHECK(b == 1);\n\tCHECK(c == 0);\n\tCHECK(d == 0);\n\tCHECK(e == 0);\n\tCHECK(f == -25);\n\tstd::vector < AMCAX::Point2> testPoints = {\n\t\tAMCAX::Point2(3.0, 4.0),\n\t\tAMCAX::Point2(5.0, 0.0),\n\t\tAMCAX::Point2(4.9, 0.0),\n\t\tAMCAX::Point2(5.1, 0.0),\n\t\tAMCAX::Point2(6.0, 0.0)\n\t};\n\tfor (const auto& point : testPoints)\n\t{\n\t\tdouble distanceToCenter = std::sqrt(point.X() * point.X() + point.Y() * point.Y());\n\t\tbool expectedIsInCircle = distanceToCenter <= 5.0 + tol;\n\t\tbool isInCircle = circle2D.Contains(point, tol);\n\t\tCHECK(isInCircle == expectedIsInCircle);\n\t}\n\tfor (const auto& point : testPoints)\n\t{\n\t\tdouble distance = circle2D.Distance(point);\n\t\tdouble expectedDistance = std::abs(std::sqrt(std::pow(point.X() - center2D.X(), 2) + std::pow(point.Y() - center2D.Y(), 2)) - redius2D);\n\t\tCHECK(distance == expectedDistance);\n\t}\n\tAMCAX::AxisT<double, 2> mirrorAxis(AMCAX::Point2(0.0, 0.0), AMCAX::Direction2(0.0, 1.0));\n\tcircle2D.Mirror(mirrorAxis);\n\tAMCAX::Point2 mirroredCenter = circle2D.Location();\n\tstd::cout << \"Mirrored circle center: (\" << mirroredCenter.X() << \", \" << mirroredCenter.Y() << \")\" << std::endl;\n\tCHECK(mirroredCenter.X() == center2D.X());\n\tCHECK(mirroredCenter.Y() == center2D.Y());\n\tconst AMCAX::FrameT<double, 2>& frame = circle2D.Position();\n\tAMCAX::Point2 rotationPoint(0.0, 0.0);\n\tdouble  rotationAngle = M_PI / 4;\n\tauto rotatedCircle = circle2D.Rotated(rotationPoint, rotationAngle);\n\tdouble cosAngle = cos(rotationAngle);\n\tdouble sinAngle = sin(rotationAngle);\n\tdouble newX = cosAngle * (center2D.X() - rotationPoint.X()) - sinAngle * (center2D.Y() - rotationPoint.Y()) + rotationPoint.X();\n\tdouble newY = sinAngle * (center2D.X() - rotationPoint.X()) + cosAngle * (center2D.Y() - rotationPoint.Y()) + rotationPoint.Y();\n\tauto rotatedCenter = rotatedCircle.Location();\n\tCHECK(newX == center2D.X());\n\tCHECK(newY == center2D.Y());\n\tAMCAX::Point2 scalingCenter(0.0, 0.0);\n\tdouble scalingFactor = 2.0;\n\tauto scaledCircle = circle2D.Scale(scalingCenter, scalingFactor);\n\tdouble scaledRadius = scaledCircle.Radius();\n\tdouble expectedScaledRadius = redius2D * scalingFactor;\n\tCHECK(std::abs(scaledRadius - expectedScaledRadius) < 1e-6);\n\tAMCAX::VectorT<double, 2> translationVector(2.0, 3.0);\n\tauto translatedCircle = circle2D.Translated(translationVector);\n\tauto translatedCenter = translatedCircle.Location();\n\tdouble translatedX = center2D.X() + translationVector.X();\n\tCHECK(translatedX == translatedCenter.X());\n\tauto xAxis = circle2D.XAxis();\n\tauto directionAxis = xAxis.Direction();\n\tCHECK(directionAxis.X() == -1.0);\n\tCHECK(directionAxis.Y() == 0.0);\n} "
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "CircleS& Scale(const PointT<double, DIM>& p, double scale)\t @return The reference to self\n\t @param scale The scale value\n\t @param p The scaling center point\n\t @brief Scale the circle by a center point\n,\n",
      "output": "#include <math/CircleT.hpp>\n#include <common/CoordT.hpp>\n#include <common/TransformationType.hpp>\n#include <common/DirectionT.hpp>\n#include <common/PointT.hpp>\n#include <common/Precision.hpp>\n#include <common/CoordT.hpp>\n#include <common/TransformationType.hpp>\n#include <topology/TopoEdge.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <topology/TopoWire.hpp>\n#include <modeling/MakeWire.hpp>\n#include <geometry/GlobalProperty.hpp>\n#include <topology/BRepGlobalProperty.hpp>\n#include<iostream>\n#include \"catch.hpp\" \nusing namespace std;\nusing namespace AMCAX;\nTEST_CASE(\"TestCircle2D\", \"[math][Circle2D]\")\n{\n\tAMCAX::CircleT<double, 2> circle2D;\n\tAMCAX::Point2 center2D(0.0, 0.0);\n\tdouble redius2D = 5.0;\n\tdouble tol = 0.1;\n\tcircle2D.SetLocation(center2D);\n\tcircle2D.SetRadius(redius2D);\n\tdouble area2D = circle2D.Area();\n\tdouble length2D = circle2D.Length();\n\tAMCAX::Point2 retcenter2D = circle2D.Location();\n\tdouble retarea2D = M_PI * redius2D * redius2D;\n\tdouble retlength2D = 2 * M_PI * redius2D;\n\tstd::cout << area2D << std::endl;\n\tstd::cout << length2D << std::endl;\n\tstd::cout << retcenter2D.X() << std::endl;\n\tstd::cout << retcenter2D.Y() << std::endl;\n\tCHECK(area2D == retarea2D);\n\tCHECK(length2D == retlength2D);\n\tCHECK(retcenter2D.X() == center2D.X());\n\tCHECK(retcenter2D.Y() == center2D.Y());\n\tdouble a, b, c, d, e, f;\n\tcircle2D.Coefficients(a, b, c, d, e, f);\n\tstd::cout << a << std::endl;\n\tstd::cout << b << std::endl;\n\tstd::cout << c << std::endl;\n\tstd::cout << d << std::endl;\n\tstd::cout << e << std::endl;\n\tstd::cout << f << std::endl;\n\tCHECK(a == 1);\n\tCHECK(b == 1);\n\tCHECK(c == 0);\n\tCHECK(d == 0);\n\tCHECK(e == 0);\n\tCHECK(f == -25);\n\tstd::vector < AMCAX::Point2> testPoints = {\n\t\tAMCAX::Point2(3.0, 4.0),\n\t\tAMCAX::Point2(5.0, 0.0),\n\t\tAMCAX::Point2(4.9, 0.0),\n\t\tAMCAX::Point2(5.1, 0.0),\n\t\tAMCAX::Point2(6.0, 0.0)\n\t};\n\tfor (const auto& point : testPoints)\n\t{\n\t\tdouble distanceToCenter = std::sqrt(point.X() * point.X() + point.Y() * point.Y());\n\t\tbool expectedIsInCircle = distanceToCenter <= 5.0 + tol;\n\t\tbool isInCircle = circle2D.Contains(point, tol);\n\t\tCHECK(isInCircle == expectedIsInCircle);\n\t}\n\tfor (const auto& point : testPoints)\n\t{\n\t\tdouble distance = circle2D.Distance(point);\n\t\tdouble expectedDistance = std::abs(std::sqrt(std::pow(point.X() - center2D.X(), 2) + std::pow(point.Y() - center2D.Y(), 2)) - redius2D);\n\t\tCHECK(distance == expectedDistance);\n\t}\n\tAMCAX::AxisT<double, 2> mirrorAxis(AMCAX::Point2(0.0, 0.0), AMCAX::Direction2(0.0, 1.0));\n\tcircle2D.Mirror(mirrorAxis);\n\tAMCAX::Point2 mirroredCenter = circle2D.Location();\n\tstd::cout << \"Mirrored circle center: (\" << mirroredCenter.X() << \", \" << mirroredCenter.Y() << \")\" << std::endl;\n\tCHECK(mirroredCenter.X() == center2D.X());\n\tCHECK(mirroredCenter.Y() == center2D.Y());\n\tconst AMCAX::FrameT<double, 2>& frame = circle2D.Position();\n\tAMCAX::Point2 rotationPoint(0.0, 0.0);\n\tdouble  rotationAngle = M_PI / 4;\n\tauto rotatedCircle = circle2D.Rotated(rotationPoint, rotationAngle);\n\tdouble cosAngle = cos(rotationAngle);\n\tdouble sinAngle = sin(rotationAngle);\n\tdouble newX = cosAngle * (center2D.X() - rotationPoint.X()) - sinAngle * (center2D.Y() - rotationPoint.Y()) + rotationPoint.X();\n\tdouble newY = sinAngle * (center2D.X() - rotationPoint.X()) + cosAngle * (center2D.Y() - rotationPoint.Y()) + rotationPoint.Y();\n\tauto rotatedCenter = rotatedCircle.Location();\n\tCHECK(newX == center2D.X());\n\tCHECK(newY == center2D.Y());\n\tAMCAX::Point2 scalingCenter(0.0, 0.0);\n\tdouble scalingFactor = 2.0;\n\tauto scaledCircle = circle2D.Scale(scalingCenter, scalingFactor);\n\tdouble scaledRadius = scaledCircle.Radius();\n\tdouble expectedScaledRadius = redius2D * scalingFactor;\n\tCHECK(std::abs(scaledRadius - expectedScaledRadius) < 1e-6);\n\tAMCAX::VectorT<double, 2> translationVector(2.0, 3.0);\n\tauto translatedCircle = circle2D.Translated(translationVector);\n\tauto translatedCenter = translatedCircle.Location();\n\tdouble translatedX = center2D.X() + translationVector.X();\n\tCHECK(translatedX == translatedCenter.X());\n\tauto xAxis = circle2D.XAxis();\n\tauto directionAxis = xAxis.Direction();\n\tCHECK(directionAxis.X() == -1.0);\n\tCHECK(directionAxis.Y() == 0.0);\n}\n}\n,\n{\n "
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] double SquaredDistance(const PointT<double, DIM>& p)\t @return The squared distance from the point to the circle\n\t @param p The point\n\t @brief Compute the squared distance from a point to the circle\n,\n",
      "output": "#include <math/CircleT.hpp>\n#include <common/CoordT.hpp>\n#include <common/TransformationType.hpp>\n#include <common/DirectionT.hpp>\n#include <common/PointT.hpp>\n#include <common/Precision.hpp>\n#include <common/CoordT.hpp>\n#include <common/TransformationType.hpp>\n#include <topology/TopoEdge.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <topology/TopoWire.hpp>\n#include <modeling/MakeWire.hpp>\n#include <geometry/GlobalProperty.hpp>\n#include <topology/BRepGlobalProperty.hpp>\n#include<iostream>\n#include \"catch.hpp\" \nusing namespace std;\nusing namespace AMCAX;\nTEST_CASE(\"TestCircle3D\", \"[math][Circle3D]\")\n{\n\tAMCAX::Circle3 circle3D;\n\tAMCAX::Point3  center3D(0.0, 0.0, 0.0);\n\tdouble radius3D = 5.0;\n\tdouble tol = 0.1;\n\tcircle3D.SetLocation(center3D);\n\tcircle3D.SetRadius(radius3D);\n\tdouble area = circle3D.Area();\n\tauto axis = circle3D.Axis();\n\tAMCAX::Point3 expectedDirection(0.0, 0.0, 1.0);\n\tauto direction = axis.Direction();\n\tCHECK(area == Approx(78.5398));\n\tCHECK(direction.X() == Approx(expectedDirection.X()).margin(tol));\n\tCHECK(direction.Y() == Approx(expectedDirection.Y()).margin(tol));\n\tCHECK(direction.Z() == Approx(expectedDirection.Z()).margin(tol));\n\tstd::vector <AMCAX::Point3> test3DPoints = {\n\t\tAMCAX::Point3(0.0, 0.0, 0.0),\n\t\tAMCAX::Point3(4.0, 0.0, 0.0),\n\t};\n\tfor (const auto& point : test3DPoints)\n\t{\n\t\tdouble distanceToCenter = std::sqrt(std::pow(point.X() - center3D.X(), 2) + std::pow(point.Y() - center3D.Y(), 2) + std::pow(point.Z() - center3D.Z(), 2));\n\t\tbool expectedIsCircle = distanceToCenter <= 5.0 + tol;\n\t\tbool isInCircle = circle3D.Contains(point, tol);\n\t\tCHECK(!isInCircle == expectedIsCircle);\n\t}\n\tAMCAX::PointT<double, 3>  pointOutside(10.0, 0.0, 0.0);\n\tdouble expectedDistance = 5.0;\n\tCHECK(circle3D.Distance(pointOutside) == Approx(expectedDistance));\n\tdouble length = circle3D.Length();\n\tCHECK(length == Approx(31.4159));\n\tauto location = circle3D.Location();\n\tCHECK(location.X() == Approx(0.0));\n\tCHECK(location.Y() == Approx(0.0));\n\tCHECK(location.Z() == Approx(0.0));\n\tAMCAX::PointT<double, 3> mirrorPoint(1.0, 0.0, 0.0);\n\tcircle3D.Mirror(mirrorPoint);\n\tauto mirroredLocation = circle3D.Location();\n\tCHECK(mirroredLocation.X() == Approx(2.0));\n\tCHECK(mirroredLocation.Y() == Approx(0.0));\n\tCHECK(mirroredLocation.Z() == Approx(0.0));\n\tauto position = circle3D.Position();   \n\tdouble r = circle3D.Radius();\n\tCHECK(r == 5.0);\n\tDirection3 zDirection(0.0, 0.0, 1.0);\n\tAxis3 zAxis(center3D, zDirection);\n\tTransformation3 rotation;\n\trotation.SetRotation(zAxis, M_PI / 2);  \n\tPoint3 newCenter1 = center3D.Transformed(rotation);\n\tCHECK(newCenter1.X() == 0.0);\n\tCHECK(newCenter1.Y() == 0.0);\n\tCHECK(newCenter1.Z() == 0.0);\n\tdouble angle = M_PI / 2;\n\tcircle3D.Rotated(zAxis, angle);\n\tAMCAX::Frame3 frame = circle3D.Position();\n\tCHECK(frame.Location().X() == 2.0);\n\tCHECK(frame.Location().Y() == 0.0);\n\tCHECK(frame.Location().Z() == 0.0);\n\tdouble scale = 2.0;\n\tcircle3D.Scale(center3D, scale);\n\tCHECK(circle3D.Radius() == radius3D * 2.0);\n\tAMCAX::PointT<double, 3> insidePoint(3.0, 4.0, 0.0);\n\tAMCAX::PointT<double, 3> onCirclePoint(5.0, 0.0, 0.0);\n\tAMCAX::PointT<double, 3> outsidePoint(8.0, 6.0, 0.0);\n\tdouble insideSquaredDistance = circle3D.SquaredDistance(insidePoint);\n\tdouble onCircleSquaredDistance = circle3D.SquaredDistance(onCirclePoint);\n\tdouble outsideSquaredDistance = circle3D.SquaredDistance(outsidePoint);\n\tCHECK(insideSquaredDistance == Approx(34.5378));\n\tCHECK(onCircleSquaredDistance == 81.0);\n\tCHECK(outsideSquaredDistance == Approx(7.7779));\n\tVectorT<double, 3> translationVector(5.0, 5.0, 0.0);\n\tcircle3D.Translate(translationVector);\n\tCHECK(circle3D.Location().X() == 9.0);\n\tCHECK(circle3D.Location().Y() == 5.0);\n\tCHECK(circle3D.Location().Z() == 0.0);\n\tauto xAxis = circle3D.XAxis();\n\tauto yAxis = circle3D.YAxis();\n\tCHECK(xAxis.Direction().X() == Approx(-1.0));\n\tCHECK(yAxis.Direction().Y() == Approx(-1.0));\n} "
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] double Distance(const PointT<double, DIM>& p)\t @return The distance from the point to the circle\n\t @param p The point\n\t @brief Compute the distance from a point to the circle\n,\n",
      "output": "#include <math/CircleT.hpp>\n#include <common/CoordT.hpp>\n#include <common/TransformationType.hpp>\n#include <common/DirectionT.hpp>\n#include <common/PointT.hpp>\n#include <common/Precision.hpp>\n#include <common/CoordT.hpp>\n#include <common/TransformationType.hpp>\n#include <topology/TopoEdge.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <topology/TopoWire.hpp>\n#include <modeling/MakeWire.hpp>\n#include <geometry/GlobalProperty.hpp>\n#include <topology/BRepGlobalProperty.hpp>\n#include<iostream>\n#include \"catch.hpp\" \nusing namespace std;\nusing namespace AMCAX;\nTEST_CASE(\"TestCircle2D\", \"[math][Circle2D]\")\n{\n\tAMCAX::CircleT<double, 2> circle2D;\n\tAMCAX::Point2 center2D(0.0, 0.0);\n\tdouble redius2D = 5.0;\n\tdouble tol = 0.1;\n\tcircle2D.SetLocation(center2D);\n\tcircle2D.SetRadius(redius2D);\n\tdouble area2D = circle2D.Area();\n\tdouble length2D = circle2D.Length();\n\tAMCAX::Point2 retcenter2D = circle2D.Location();\n\tdouble retarea2D = M_PI * redius2D * redius2D;\n\tdouble retlength2D = 2 * M_PI * redius2D;\n\tstd::cout << area2D << std::endl;\n\tstd::cout << length2D << std::endl;\n\tstd::cout << retcenter2D.X() << std::endl;\n\tstd::cout << retcenter2D.Y() << std::endl;\n\tCHECK(area2D == retarea2D);\n\tCHECK(length2D == retlength2D);\n\tCHECK(retcenter2D.X() == center2D.X());\n\tCHECK(retcenter2D.Y() == center2D.Y());\n\tdouble a, b, c, d, e, f;\n\tcircle2D.Coefficients(a, b, c, d, e, f);\n\tstd::cout << a << std::endl;\n\tstd::cout << b << std::endl;\n\tstd::cout << c << std::endl;\n\tstd::cout << d << std::endl;\n\tstd::cout << e << std::endl;\n\tstd::cout << f << std::endl;\n\tCHECK(a == 1);\n\tCHECK(b == 1);\n\tCHECK(c == 0);\n\tCHECK(d == 0);\n\tCHECK(e == 0);\n\tCHECK(f == -25);\n\tstd::vector < AMCAX::Point2> testPoints = {\n\t\tAMCAX::Point2(3.0, 4.0),\n\t\tAMCAX::Point2(5.0, 0.0),\n\t\tAMCAX::Point2(4.9, 0.0),\n\t\tAMCAX::Point2(5.1, 0.0),\n\t\tAMCAX::Point2(6.0, 0.0)\n\t};\n\tfor (const auto& point : testPoints)\n\t{\n\t\tdouble distanceToCenter = std::sqrt(point.X() * point.X() + point.Y() * point.Y());\n\t\tbool expectedIsInCircle = distanceToCenter <= 5.0 + tol;\n\t\tbool isInCircle = circle2D.Contains(point, tol);\n\t\tCHECK(isInCircle == expectedIsInCircle);\n\t}\n\tfor (const auto& point : testPoints)\n\t{\n\t\tdouble distance = circle2D.Distance(point);\n\t\tdouble expectedDistance = std::abs(std::sqrt(std::pow(point.X() - center2D.X(), 2) + std::pow(point.Y() - center2D.Y(), 2)) - redius2D);\n\t\tCHECK(distance == expectedDistance);\n\t}\n\tAMCAX::AxisT<double, 2> mirrorAxis(AMCAX::Point2(0.0, 0.0), AMCAX::Direction2(0.0, 1.0));\n\tcircle2D.Mirror(mirrorAxis);\n\tAMCAX::Point2 mirroredCenter = circle2D.Location();\n\tstd::cout << \"Mirrored circle center: (\" << mirroredCenter.X() << \", \" << mirroredCenter.Y() << \")\" << std::endl;\n\tCHECK(mirroredCenter.X() == center2D.X());\n\tCHECK(mirroredCenter.Y() == center2D.Y());\n\tconst AMCAX::FrameT<double, 2>& frame = circle2D.Position();\n\tAMCAX::Point2 rotationPoint(0.0, 0.0);\n\tdouble  rotationAngle = M_PI / 4;\n\tauto rotatedCircle = circle2D.Rotated(rotationPoint, rotationAngle);\n\tdouble cosAngle = cos(rotationAngle);\n\tdouble sinAngle = sin(rotationAngle);\n\tdouble newX = cosAngle * (center2D.X() - rotationPoint.X()) - sinAngle * (center2D.Y() - rotationPoint.Y()) + rotationPoint.X();\n\tdouble newY = sinAngle * (center2D.X() - rotationPoint.X()) + cosAngle * (center2D.Y() - rotationPoint.Y()) + rotationPoint.Y();\n\tauto rotatedCenter = rotatedCircle.Location();\n\tCHECK(newX == center2D.X());\n\tCHECK(newY == center2D.Y());\n\tAMCAX::Point2 scalingCenter(0.0, 0.0);\n\tdouble scalingFactor = 2.0;\n\tauto scaledCircle = circle2D.Scale(scalingCenter, scalingFactor);\n\tdouble scaledRadius = scaledCircle.Radius();\n\tdouble expectedScaledRadius = redius2D * scalingFactor;\n\tCHECK(std::abs(scaledRadius - expectedScaledRadius) < 1e-6);\n\tAMCAX::VectorT<double, 2> translationVector(2.0, 3.0);\n\tauto translatedCircle = circle2D.Translated(translationVector);\n\tauto translatedCenter = translatedCircle.Location();\n\tdouble translatedX = center2D.X() + translationVector.X();\n\tCHECK(translatedX == translatedCenter.X());\n\tauto xAxis = circle2D.XAxis();\n\tauto directionAxis = xAxis.Direction();\n\tCHECK(directionAxis.X() == -1.0);\n\tCHECK(directionAxis.Y() == 0.0);\n} "
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] double Radius()\t @return The radius\n\t @brief Get the radius\n,\n",
      "output": "#include <math/CircleT.hpp>\n#include <common/CoordT.hpp>\n#include <common/TransformationType.hpp>\n#include <common/DirectionT.hpp>\n#include <common/PointT.hpp>\n#include <common/Precision.hpp>\n#include <common/CoordT.hpp>\n#include <common/TransformationType.hpp>\n#include <topology/TopoEdge.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <topology/TopoWire.hpp>\n#include <modeling/MakeWire.hpp>\n#include <geometry/GlobalProperty.hpp>\n#include <topology/BRepGlobalProperty.hpp>\n#include<iostream>\n#include \"catch.hpp\" \nusing namespace std;\nusing namespace AMCAX;\nTEST_CASE(\"TestCircle3D\", \"[math][Circle3D]\")\n{\n\tAMCAX::Circle3 circle3D;\n\tAMCAX::Point3  center3D(0.0, 0.0, 0.0);\n\tdouble radius3D = 5.0;\n\tdouble tol = 0.1;\n\tcircle3D.SetLocation(center3D);\n\tcircle3D.SetRadius(radius3D);\n\tdouble area = circle3D.Area();\n\tauto axis = circle3D.Axis();\n\tAMCAX::Point3 expectedDirection(0.0, 0.0, 1.0);\n\tauto direction = axis.Direction();\n\tCHECK(area == Approx(78.5398));\n\tCHECK(direction.X() == Approx(expectedDirection.X()).margin(tol));\n\tCHECK(direction.Y() == Approx(expectedDirection.Y()).margin(tol));\n\tCHECK(direction.Z() == Approx(expectedDirection.Z()).margin(tol));\n\tstd::vector <AMCAX::Point3> test3DPoints = {\n\t\tAMCAX::Point3(0.0, 0.0, 0.0),\n\t\tAMCAX::Point3(4.0, 0.0, 0.0),\n\t};\n\tfor (const auto& point : test3DPoints)\n\t{\n\t\tdouble distanceToCenter = std::sqrt(std::pow(point.X() - center3D.X(), 2) + std::pow(point.Y() - center3D.Y(), 2) + std::pow(point.Z() - center3D.Z(), 2));\n\t\tbool expectedIsCircle = distanceToCenter <= 5.0 + tol;\n\t\tbool isInCircle = circle3D.Contains(point, tol);\n\t\tCHECK(!isInCircle == expectedIsCircle);\n\t}\n\tAMCAX::PointT<double, 3>  pointOutside(10.0, 0.0, 0.0);\n\tdouble expectedDistance = 5.0;\n\tCHECK(circle3D.Distance(pointOutside) == Approx(expectedDistance));\n\tdouble length = circle3D.Length();\n\tCHECK(length == Approx(31.4159));\n\tauto location = circle3D.Location();\n\tCHECK(location.X() == Approx(0.0));\n\tCHECK(location.Y() == Approx(0.0));\n\tCHECK(location.Z() == Approx(0.0));\n\tAMCAX::PointT<double, 3> mirrorPoint(1.0, 0.0, 0.0);\n\tcircle3D.Mirror(mirrorPoint);\n\tauto mirroredLocation = circle3D.Location();\n\tCHECK(mirroredLocation.X() == Approx(2.0));\n\tCHECK(mirroredLocation.Y() == Approx(0.0));\n\tCHECK(mirroredLocation.Z() == Approx(0.0));\n\tauto position = circle3D.Position();   \n\tdouble r = circle3D.Radius();\n\tCHECK(r == 5.0);\n\tDirection3 zDirection(0.0, 0.0, 1.0);\n\tAxis3 zAxis(center3D, zDirection);\n\tTransformation3 rotation;\n\trotation.SetRotation(zAxis, M_PI / 2);  \n\tPoint3 newCenter1 = center3D.Transformed(rotation);\n\tCHECK(newCenter1.X() == 0.0);\n\tCHECK(newCenter1.Y() == 0.0);\n\tCHECK(newCenter1.Z() == 0.0);\n\tdouble angle = M_PI / 2;\n\tcircle3D.Rotated(zAxis, angle);\n\tAMCAX::Frame3 frame = circle3D.Position();\n\tCHECK(frame.Location().X() == 2.0);\n\tCHECK(frame.Location().Y() == 0.0);\n\tCHECK(frame.Location().Z() == 0.0);\n\tdouble scale = 2.0;\n\tcircle3D.Scale(center3D, scale);\n\tCHECK(circle3D.Radius() == radius3D * 2.0);\n\tAMCAX::PointT<double, 3> insidePoint(3.0, 4.0, 0.0);\n\tAMCAX::PointT<double, 3> onCirclePoint(5.0, 0.0, 0.0);\n\tAMCAX::PointT<double, 3> outsidePoint(8.0, 6.0, 0.0);\n\tdouble insideSquaredDistance = circle3D.SquaredDistance(insidePoint);\n\tdouble onCircleSquaredDistance = circle3D.SquaredDistance(onCirclePoint);\n\tdouble outsideSquaredDistance = circle3D.SquaredDistance(outsidePoint);\n\tCHECK(insideSquaredDistance == Approx(34.5378));\n\tCHECK(onCircleSquaredDistance == 81.0);\n\tCHECK(outsideSquaredDistance == Approx(7.7779));\n\tVectorT<double, 3> translationVector(5.0, 5.0, 0.0);\n\tcircle3D.Translate(translationVector);\n\tCHECK(circle3D.Location().X() == 9.0);\n\tCHECK(circle3D.Location().Y() == 5.0);\n\tCHECK(circle3D.Location().Z() == 0.0);\n\tauto xAxis = circle3D.XAxis();\n\tauto yAxis = circle3D.YAxis();\n\tCHECK(xAxis.Direction().X() == Approx(-1.0));\n\tCHECK(yAxis.Direction().Y() == Approx(-1.0));\n} "
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "void SetRadius(double r)\t @param r The radius\n\t @brief Set the radius of the circle\n,\n",
      "output": "#include <math/CircleT.hpp>\n#include <common/CoordT.hpp>\n#include <common/TransformationType.hpp>\n#include <common/DirectionT.hpp>\n#include <common/PointT.hpp>\n#include <common/Precision.hpp>\n#include <common/CoordT.hpp>\n#include <common/TransformationType.hpp>\n#include <topology/TopoEdge.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <topology/TopoWire.hpp>\n#include <modeling/MakeWire.hpp>\n#include <geometry/GlobalProperty.hpp>\n#include <topology/BRepGlobalProperty.hpp>\n#include<iostream>\n#include \"catch.hpp\" \nusing namespace std;\nusing namespace AMCAX;\nTEST_CASE(\"TestCircle2D\", \"[math][Circle2D]\")\n{\n\tAMCAX::CircleT<double, 2> circle2D;\n\tAMCAX::Point2 center2D(0.0, 0.0);\n\tdouble redius2D = 5.0;\n\tdouble tol = 0.1;\n\tcircle2D.SetLocation(center2D);\n\tcircle2D.SetRadius(redius2D);\n\tdouble area2D = circle2D.Area();\n\tdouble length2D = circle2D.Length();\n\tAMCAX::Point2 retcenter2D = circle2D.Location();\n\tdouble retarea2D = M_PI * redius2D * redius2D;\n\tdouble retlength2D = 2 * M_PI * redius2D;\n\tstd::cout << area2D << std::endl;\n\tstd::cout << length2D << std::endl;\n\tstd::cout << retcenter2D.X() << std::endl;\n\tstd::cout << retcenter2D.Y() << std::endl;\n\tCHECK(area2D == retarea2D);\n\tCHECK(length2D == retlength2D);\n\tCHECK(retcenter2D.X() == center2D.X());\n\tCHECK(retcenter2D.Y() == center2D.Y());\n\tdouble a, b, c, d, e, f;\n\tcircle2D.Coefficients(a, b, c, d, e, f);\n\tstd::cout << a << std::endl;\n\tstd::cout << b << std::endl;\n\tstd::cout << c << std::endl;\n\tstd::cout << d << std::endl;\n\tstd::cout << e << std::endl;\n\tstd::cout << f << std::endl;\n\tCHECK(a == 1);\n\tCHECK(b == 1);\n\tCHECK(c == 0);\n\tCHECK(d == 0);\n\tCHECK(e == 0);\n\tCHECK(f == -25);\n\tstd::vector < AMCAX::Point2> testPoints = {\n\t\tAMCAX::Point2(3.0, 4.0),\n\t\tAMCAX::Point2(5.0, 0.0),\n\t\tAMCAX::Point2(4.9, 0.0),\n\t\tAMCAX::Point2(5.1, 0.0),\n\t\tAMCAX::Point2(6.0, 0.0)\n\t};\n\tfor (const auto& point : testPoints)\n\t{\n\t\tdouble distanceToCenter = std::sqrt(point.X() * point.X() + point.Y() * point.Y());\n\t\tbool expectedIsInCircle = distanceToCenter <= 5.0 + tol;\n\t\tbool isInCircle = circle2D.Contains(point, tol);\n\t\tCHECK(isInCircle == expectedIsInCircle);\n\t}\n\tfor (const auto& point : testPoints)\n\t{\n\t\tdouble distance = circle2D.Distance(point);\n\t\tdouble expectedDistance = std::abs(std::sqrt(std::pow(point.X() - center2D.X(), 2) + std::pow(point.Y() - center2D.Y(), 2)) - redius2D);\n\t\tCHECK(distance == expectedDistance);\n\t}\n\tAMCAX::AxisT<double, 2> mirrorAxis(AMCAX::Point2(0.0, 0.0), AMCAX::Direction2(0.0, 1.0));\n\tcircle2D.Mirror(mirrorAxis);\n\tAMCAX::Point2 mirroredCenter = circle2D.Location();\n\tstd::cout << \"Mirrored circle center: (\" << mirroredCenter.X() << \", \" << mirroredCenter.Y() << \")\" << std::endl;\n\tCHECK(mirroredCenter.X() == center2D.X());\n\tCHECK(mirroredCenter.Y() == center2D.Y());\n\tconst AMCAX::FrameT<double, 2>& frame = circle2D.Position();\n\tAMCAX::Point2 rotationPoint(0.0, 0.0);\n\tdouble  rotationAngle = M_PI / 4;\n\tauto rotatedCircle = circle2D.Rotated(rotationPoint, rotationAngle);\n\tdouble cosAngle = cos(rotationAngle);\n\tdouble sinAngle = sin(rotationAngle);\n\tdouble newX = cosAngle * (center2D.X() - rotationPoint.X()) - sinAngle * (center2D.Y() - rotationPoint.Y()) + rotationPoint.X();\n\tdouble newY = sinAngle * (center2D.X() - rotationPoint.X()) + cosAngle * (center2D.Y() - rotationPoint.Y()) + rotationPoint.Y();\n\tauto rotatedCenter = rotatedCircle.Location();\n\tCHECK(newX == center2D.X());\n\tCHECK(newY == center2D.Y());\n\tAMCAX::Point2 scalingCenter(0.0, 0.0);\n\tdouble scalingFactor = 2.0;\n\tauto scaledCircle = circle2D.Scale(scalingCenter, scalingFactor);\n\tdouble scaledRadius = scaledCircle.Radius();\n\tdouble expectedScaledRadius = redius2D * scalingFactor;\n\tCHECK(std::abs(scaledRadius - expectedScaledRadius) < 1e-6);\n\tAMCAX::VectorT<double, 2> translationVector(2.0, 3.0);\n\tauto translatedCircle = circle2D.Translated(translationVector);\n\tauto translatedCenter = translatedCircle.Location();\n\tdouble translatedX = center2D.X() + translationVector.X();\n\tCHECK(translatedX == translatedCenter.X());\n\tauto xAxis = circle2D.XAxis();\n\tauto directionAxis = xAxis.Direction();\n\tCHECK(directionAxis.X() == -1.0);\n\tCHECK(directionAxis.Y() == 0.0);\n} "
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API Cone& Transform(const Transformation3& tr)\t @return The reference to self\n\t @param tr The transformation\n\t @brief Transform the cone\n,\n",
      "output": "#include<iostream>\n#include \"catch.hpp\"\n#include <common/FrameT.hpp>\n#include <modeling/MakeFace.hpp>\n#include <common/AxisT.hpp>\n#include <common/FrameT.hpp>\n#include <common/VectorT.hpp>\n#include <math/Cone.hpp>\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"TestCone\", \"[math][Cone]\")\n{\n\tAMCAX::Frame3 frame;\n\tdouble radius = 5.0;\n\tdouble angle = M_PI / 4;\n\tAMCAX::Cone cone(frame, radius, angle);\n\tAMCAX::Point3 apex = cone.Apex();\n\tCHECK(apex.X() == 0.0);\n\tCHECK(apex.Y() == 0.0);\n\tCHECK(apex.Z() == Approx(-5.0));\n\tAMCAX::Axis3 axis = cone.Axis();\n\tstd::cout << axis.Direction().X() << std::endl;\n\tstd::cout << axis.Direction().Y() << std::endl;\n\tstd::cout << axis.Direction().Z() << std::endl;\n\tCHECK(axis.Direction().X() == 0.0);\n\tCHECK(axis.Direction().Y() == 0.0);\n\tCHECK(axis.Direction().Z() == 1.0);\n\tdouble a1, a2, a3, b1, b2, b3, c1, c2, c3, d;\n\tcone.Coefficients(a1, a2, a3, b1, b2, b3, c1, c2, c3, d);\n\tstd::cout << \"a1: \" << a1 << \", a2: \" << a2 << \", a3: \" << a3 << std::endl;\n\tstd::cout << \"b1: \" << b1 << \", b2: \" << b2 << \", b3: \" << b3 << std::endl;\n\tstd::cout << \"c1: \" << c1 << \", c2: \" << c2 << \", c3: \" << c3 << std::endl;\n\tstd::cout << \"d: \" << d << std::endl;\n\tCHECK(a1 == 1.0);\n\tCHECK(a2 == 1.0);\n\tCHECK(a3 == Approx(-1.0));\n\tCHECK(b1 == 0);\n\tCHECK(b2 == 0);\n\tCHECK(b3 == 0);\n\tCHECK(c1 == 0);\n\tCHECK(c2 == 0);\n\tCHECK(c3 == Approx(-5.0));\n\tCHECK(d == -25.0);\n\tCHECK(cone.IsDirect() == true);\n\tCHECK(cone.Location().X() == 0.0);\n\tCHECK(cone.Location().Y() == 0.0);\n\tCHECK(cone.Location().Z() == 0.0);\n\tAMCAX::PointT<double, 3>mirrorPoint(5.0, 0.0, 0.0);\n\tcone.Mirror(mirrorPoint);\n\tauto mirroredLocation = cone.Location();\n\tCHECK(mirroredLocation.X() == 10.0);\n\tCHECK(mirroredLocation.Y() == 0.0);\n\tCHECK(mirroredLocation.Z() == 0.0);\n\tAMCAX::Frame3 coneFrame = cone.Position();\n\tCHECK(frame.Location().X() == 0.0);\n\tCHECK(frame.Location().Y() == 0.0);\n\tCHECK(frame.Location().Z() == 0.0);\n\tCHECK(cone.Radius() == 5.0);\n\tdouble  scaleCone = 2.0;\n\tcone.Scale(cone.Location(), scaleCone);\n\tCHECK(cone.Radius() == radius * 2.0);\n\tdouble semiCone = cone.SemiAngle();\n\tCHECK(semiCone == Approx(0.785398));\n\tconst  Frame3& position = cone.Position();\n\tstd::cout << position.XAxis() << std::endl;\n\tstd::cout << position.YAxis() << std::endl;\n\tDirection3 zDirection(0.0, 0.0, 1.0);\n\tAMCAX::Point3  centerCone(0.0, 0.0, 0.0);\n\tAxis3 zAxis(centerCone, zDirection);\n\tcone.Rotated(zAxis, angle);\n\tAMCAX::Frame3 coneFrame2 = cone.Position();\n\tCHECK(coneFrame.Location().X() == 10.0);\n\tCHECK(coneFrame.Location().Y() == 0.0);\n\tCHECK(coneFrame.Location().Z() == 0.0);\n\tdouble scale = 2.0;\n\tcone.Scale(centerCone, scale);\n\tCHECK(cone.Radius() == radius * 4.0);\n\tdouble semiAngle = cone.SemiAngle();\n\tstd::cout << semiAngle << std::endl;\n\tCHECK(semiAngle == Approx(0.785398));\n\tVectorT<double, 3> translationVector(5.0, 5.0, 0.0);\n\tcone.Translate(translationVector);\n\tCHECK(cone.Location().X() == 25.0);\n\tCHECK(cone.Location().Y() == 5.0);\n\tCHECK(cone.Location().Z() == 0.0);\n\tauto xAxis = cone.XAxis();\n\tauto yAxis = cone.YAxis();\n\tCHECK(xAxis.Direction().X() == Approx(-1.0));\n\tCHECK(yAxis.Direction().Y() == Approx(-1.0));\n\tAMCAX::Transformation3 tr;\n\ttr.SetTranslation(Vector3(1.0, 2.0, 3.0));\n\tcone.Transform(tr);\n\tAxis3 newXAxis = cone.Position().XAxis();\n\tCHECK(newXAxis.Location().X() == 26.0);\n\tCHECK(newXAxis.Location().Y() == 7.0);\n\tCHECK(newXAxis.Location().Z() == 3.0);\n} "
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API Cone& Scale(const Point3& point, double scale)\t @return The reference to self\n\t @param scale The scale value\n\t @param point The scaling center point\n\t @brief Scale the cone by a point\n,\n",
      "output": "#include<iostream>\n#include \"catch.hpp\"\n#include <common/FrameT.hpp>\n#include <modeling/MakeFace.hpp>\n#include <common/AxisT.hpp>\n#include <common/FrameT.hpp>\n#include <common/VectorT.hpp>\n#include <math/Cone.hpp>\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"TestCone\", \"[math][Cone]\")\n{\n\tAMCAX::Frame3 frame;\n\tdouble radius = 5.0;\n\tdouble angle = M_PI / 4;\n\tAMCAX::Cone cone(frame, radius, angle);\n\tAMCAX::Point3 apex = cone.Apex();\n\tCHECK(apex.X() == 0.0);\n\tCHECK(apex.Y() == 0.0);\n\tCHECK(apex.Z() == Approx(-5.0));\n\tAMCAX::Axis3 axis = cone.Axis();\n\tstd::cout << axis.Direction().X() << std::endl;\n\tstd::cout << axis.Direction().Y() << std::endl;\n\tstd::cout << axis.Direction().Z() << std::endl;\n\tCHECK(axis.Direction().X() == 0.0);\n\tCHECK(axis.Direction().Y() == 0.0);\n\tCHECK(axis.Direction().Z() == 1.0);\n\tdouble a1, a2, a3, b1, b2, b3, c1, c2, c3, d;\n\tcone.Coefficients(a1, a2, a3, b1, b2, b3, c1, c2, c3, d);\n\tstd::cout << \"a1: \" << a1 << \", a2: \" << a2 << \", a3: \" << a3 << std::endl;\n\tstd::cout << \"b1: \" << b1 << \", b2: \" << b2 << \", b3: \" << b3 << std::endl;\n\tstd::cout << \"c1: \" << c1 << \", c2: \" << c2 << \", c3: \" << c3 << std::endl;\n\tstd::cout << \"d: \" << d << std::endl;\n\tCHECK(a1 == 1.0);\n\tCHECK(a2 == 1.0);\n\tCHECK(a3 == Approx(-1.0));\n\tCHECK(b1 == 0);\n\tCHECK(b2 == 0);\n\tCHECK(b3 == 0);\n\tCHECK(c1 == 0);\n\tCHECK(c2 == 0);\n\tCHECK(c3 == Approx(-5.0));\n\tCHECK(d == -25.0);\n\tCHECK(cone.IsDirect() == true);\n\tCHECK(cone.Location().X() == 0.0);\n\tCHECK(cone.Location().Y() == 0.0);\n\tCHECK(cone.Location().Z() == 0.0);\n\tAMCAX::PointT<double, 3>mirrorPoint(5.0, 0.0, 0.0);\n\tcone.Mirror(mirrorPoint);\n\tauto mirroredLocation = cone.Location();\n\tCHECK(mirroredLocation.X() == 10.0);\n\tCHECK(mirroredLocation.Y() == 0.0);\n\tCHECK(mirroredLocation.Z() == 0.0);\n\tAMCAX::Frame3 coneFrame = cone.Position();\n\tCHECK(frame.Location().X() == 0.0);\n\tCHECK(frame.Location().Y() == 0.0);\n\tCHECK(frame.Location().Z() == 0.0);\n\tCHECK(cone.Radius() == 5.0);\n\tdouble  scaleCone = 2.0;\n\tcone.Scale(cone.Location(), scaleCone);\n\tCHECK(cone.Radius() == radius * 2.0);\n\tdouble semiCone = cone.SemiAngle();\n\tCHECK(semiCone == Approx(0.785398));\n\tconst  Frame3& position = cone.Position();\n\tstd::cout << position.XAxis() << std::endl;\n\tstd::cout << position.YAxis() << std::endl;\n\tDirection3 zDirection(0.0, 0.0, 1.0);\n\tAMCAX::Point3  centerCone(0.0, 0.0, 0.0);\n\tAxis3 zAxis(centerCone, zDirection);\n\tcone.Rotated(zAxis, angle);\n\tAMCAX::Frame3 coneFrame2 = cone.Position();\n\tCHECK(coneFrame.Location().X() == 10.0);\n\tCHECK(coneFrame.Location().Y() == 0.0);\n\tCHECK(coneFrame.Location().Z() == 0.0);\n\tdouble scale = 2.0;\n\tcone.Scale(centerCone, scale);\n\tCHECK(cone.Radius() == radius * 4.0);\n\tdouble semiAngle = cone.SemiAngle();\n\tstd::cout << semiAngle << std::endl;\n\tCHECK(semiAngle == Approx(0.785398));\n\tVectorT<double, 3> translationVector(5.0, 5.0, 0.0);\n\tcone.Translate(translationVector);\n\tCHECK(cone.Location().X() == 25.0);\n\tCHECK(cone.Location().Y() == 5.0);\n\tCHECK(cone.Location().Z() == 0.0);\n\tauto xAxis = cone.XAxis();\n\tauto yAxis = cone.YAxis();\n\tCHECK(xAxis.Direction().X() == Approx(-1.0));\n\tCHECK(yAxis.Direction().Y() == Approx(-1.0));\n\tAMCAX::Transformation3 tr;\n\ttr.SetTranslation(Vector3(1.0, 2.0, 3.0));\n\tcone.Transform(tr);\n\tAxis3 newXAxis = cone.Position().XAxis();\n\tCHECK(newXAxis.Location().X() == 26.0);\n\tCHECK(newXAxis.Location().Y() == 7.0);\n\tCHECK(newXAxis.Location().Z() == 3.0);\n} "
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API Cone(const Frame3& frame, double r, double angle)\t @param angle The semi-angle\n\t @param r The reference radius\n\t @param frame The local frame\n\t @brief Construct from a local frame, a reference radius and a semi-angle\n,\n",
      "output": "#include<iostream>\n#include \"catch.hpp\"\n#include <common/FrameT.hpp>\n#include <modeling/MakeFace.hpp>\n#include <common/AxisT.hpp>\n#include <common/FrameT.hpp>\n#include <common/VectorT.hpp>\n#include <math/Cone.hpp>\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"TestCone\", \"[math][Cone]\")\n{\n\tAMCAX::Frame3 frame;\n\tdouble radius = 5.0;\n\tdouble angle = M_PI / 4;\n\tAMCAX::Cone cone(frame, radius, angle);\n\tAMCAX::Point3 apex = cone.Apex();\n\tCHECK(apex.X() == 0.0);\n\tCHECK(apex.Y() == 0.0);\n\tCHECK(apex.Z() == Approx(-5.0));\n\tAMCAX::Axis3 axis = cone.Axis();\n\tstd::cout << axis.Direction().X() << std::endl;\n\tstd::cout << axis.Direction().Y() << std::endl;\n\tstd::cout << axis.Direction().Z() << std::endl;\n\tCHECK(axis.Direction().X() == 0.0);\n\tCHECK(axis.Direction().Y() == 0.0);\n\tCHECK(axis.Direction().Z() == 1.0);\n\tdouble a1, a2, a3, b1, b2, b3, c1, c2, c3, d;\n\tcone.Coefficients(a1, a2, a3, b1, b2, b3, c1, c2, c3, d);\n\tstd::cout << \"a1: \" << a1 << \", a2: \" << a2 << \", a3: \" << a3 << std::endl;\n\tstd::cout << \"b1: \" << b1 << \", b2: \" << b2 << \", b3: \" << b3 << std::endl;\n\tstd::cout << \"c1: \" << c1 << \", c2: \" << c2 << \", c3: \" << c3 << std::endl;\n\tstd::cout << \"d: \" << d << std::endl;\n\tCHECK(a1 == 1.0);\n\tCHECK(a2 == 1.0);\n\tCHECK(a3 == Approx(-1.0));\n\tCHECK(b1 == 0);\n\tCHECK(b2 == 0);\n\tCHECK(b3 == 0);\n\tCHECK(c1 == 0);\n\tCHECK(c2 == 0);\n\tCHECK(c3 == Approx(-5.0));\n\tCHECK(d == -25.0);\n\tCHECK(cone.IsDirect() == true);\n\tCHECK(cone.Location().X() == 0.0);\n\tCHECK(cone.Location().Y() == 0.0);\n\tCHECK(cone.Location().Z() == 0.0);\n\tAMCAX::PointT<double, 3>mirrorPoint(5.0, 0.0, 0.0);\n\tcone.Mirror(mirrorPoint);\n\tauto mirroredLocation = cone.Location();\n\tCHECK(mirroredLocation.X() == 10.0);\n\tCHECK(mirroredLocation.Y() == 0.0);\n\tCHECK(mirroredLocation.Z() == 0.0);\n\tAMCAX::Frame3 coneFrame = cone.Position();\n\tCHECK(frame.Location().X() == 0.0);\n\tCHECK(frame.Location().Y() == 0.0);\n\tCHECK(frame.Location().Z() == 0.0);\n\tCHECK(cone.Radius() == 5.0);\n\tdouble  scaleCone = 2.0;\n\tcone.Scale(cone.Location(), scaleCone);\n\tCHECK(cone.Radius() == radius * 2.0);\n\tdouble semiCone = cone.SemiAngle();\n\tCHECK(semiCone == Approx(0.785398));\n\tconst  Frame3& position = cone.Position();\n\tstd::cout << position.XAxis() << std::endl;\n\tstd::cout << position.YAxis() << std::endl;\n\tDirection3 zDirection(0.0, 0.0, 1.0);\n\tAMCAX::Point3  centerCone(0.0, 0.0, 0.0);\n\tAxis3 zAxis(centerCone, zDirection);\n\tcone.Rotated(zAxis, angle);\n\tAMCAX::Frame3 coneFrame2 = cone.Position();\n\tCHECK(coneFrame.Location().X() == 10.0);\n\tCHECK(coneFrame.Location().Y() == 0.0);\n\tCHECK(coneFrame.Location().Z() == 0.0);\n\tdouble scale = 2.0;\n\tcone.Scale(centerCone, scale);\n\tCHECK(cone.Radius() == radius * 4.0);\n\tdouble semiAngle = cone.SemiAngle();\n\tstd::cout << semiAngle << std::endl;\n\tCHECK(semiAngle == Approx(0.785398));\n\tVectorT<double, 3> translationVector(5.0, 5.0, 0.0);\n\tcone.Translate(translationVector);\n\tCHECK(cone.Location().X() == 25.0);\n\tCHECK(cone.Location().Y() == 5.0);\n\tCHECK(cone.Location().Z() == 0.0);\n\tauto xAxis = cone.XAxis();\n\tauto yAxis = cone.YAxis();\n\tCHECK(xAxis.Direction().X() == Approx(-1.0));\n\tCHECK(yAxis.Direction().Y() == Approx(-1.0));\n\tAMCAX::Transformation3 tr;\n\ttr.SetTranslation(Vector3(1.0, 2.0, 3.0));\n\tcone.Transform(tr);\n\tAxis3 newXAxis = cone.Position().XAxis();\n\tCHECK(newXAxis.Location().X() == 26.0);\n\tCHECK(newXAxis.Location().Y() == 7.0);\n\tCHECK(newXAxis.Location().Z() == 3.0);\n} "
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] AMCAX_API double SemiAngle()\t @return The semi-angle\n\t @brief Get the semi-angle\n,\n",
      "output": "#include<iostream>\n#include \"catch.hpp\"\n#include <common/FrameT.hpp>\n#include <modeling/MakeFace.hpp>\n#include <common/AxisT.hpp>\n#include <common/FrameT.hpp>\n#include <common/VectorT.hpp>\n#include <math/Cone.hpp>\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"TestCone\", \"[math][Cone]\")\n{\n\tAMCAX::Frame3 frame;\n\tdouble radius = 5.0;\n\tdouble angle = M_PI / 4;\n\tAMCAX::Cone cone(frame, radius, angle);\n\tAMCAX::Point3 apex = cone.Apex();\n\tCHECK(apex.X() == 0.0);\n\tCHECK(apex.Y() == 0.0);\n\tCHECK(apex.Z() == Approx(-5.0));\n\tAMCAX::Axis3 axis = cone.Axis();\n\tstd::cout << axis.Direction().X() << std::endl;\n\tstd::cout << axis.Direction().Y() << std::endl;\n\tstd::cout << axis.Direction().Z() << std::endl;\n\tCHECK(axis.Direction().X() == 0.0);\n\tCHECK(axis.Direction().Y() == 0.0);\n\tCHECK(axis.Direction().Z() == 1.0);\n\tdouble a1, a2, a3, b1, b2, b3, c1, c2, c3, d;\n\tcone.Coefficients(a1, a2, a3, b1, b2, b3, c1, c2, c3, d);\n\tstd::cout << \"a1: \" << a1 << \", a2: \" << a2 << \", a3: \" << a3 << std::endl;\n\tstd::cout << \"b1: \" << b1 << \", b2: \" << b2 << \", b3: \" << b3 << std::endl;\n\tstd::cout << \"c1: \" << c1 << \", c2: \" << c2 << \", c3: \" << c3 << std::endl;\n\tstd::cout << \"d: \" << d << std::endl;\n\tCHECK(a1 == 1.0);\n\tCHECK(a2 == 1.0);\n\tCHECK(a3 == Approx(-1.0));\n\tCHECK(b1 == 0);\n\tCHECK(b2 == 0);\n\tCHECK(b3 == 0);\n\tCHECK(c1 == 0);\n\tCHECK(c2 == 0);\n\tCHECK(c3 == Approx(-5.0));\n\tCHECK(d == -25.0);\n\tCHECK(cone.IsDirect() == true);\n\tCHECK(cone.Location().X() == 0.0);\n\tCHECK(cone.Location().Y() == 0.0);\n\tCHECK(cone.Location().Z() == 0.0);\n\tAMCAX::PointT<double, 3>mirrorPoint(5.0, 0.0, 0.0);\n\tcone.Mirror(mirrorPoint);\n\tauto mirroredLocation = cone.Location();\n\tCHECK(mirroredLocation.X() == 10.0);\n\tCHECK(mirroredLocation.Y() == 0.0);\n\tCHECK(mirroredLocation.Z() == 0.0);\n\tAMCAX::Frame3 coneFrame = cone.Position();\n\tCHECK(frame.Location().X() == 0.0);\n\tCHECK(frame.Location().Y() == 0.0);\n\tCHECK(frame.Location().Z() == 0.0);\n\tCHECK(cone.Radius() == 5.0);\n\tdouble  scaleCone = 2.0;\n\tcone.Scale(cone.Location(), scaleCone);\n\tCHECK(cone.Radius() == radius * 2.0);\n\tdouble semiCone = cone.SemiAngle();\n\tCHECK(semiCone == Approx(0.785398));\n\tconst  Frame3& position = cone.Position();\n\tstd::cout << position.XAxis() << std::endl;\n\tstd::cout << position.YAxis() << std::endl;\n\tDirection3 zDirection(0.0, 0.0, 1.0);\n\tAMCAX::Point3  centerCone(0.0, 0.0, 0.0);\n\tAxis3 zAxis(centerCone, zDirection);\n\tcone.Rotated(zAxis, angle);\n\tAMCAX::Frame3 coneFrame2 = cone.Position();\n\tCHECK(coneFrame.Location().X() == 10.0);\n\tCHECK(coneFrame.Location().Y() == 0.0);\n\tCHECK(coneFrame.Location().Z() == 0.0);\n\tdouble scale = 2.0;\n\tcone.Scale(centerCone, scale);\n\tCHECK(cone.Radius() == radius * 4.0);\n\tdouble semiAngle = cone.SemiAngle();\n\tstd::cout << semiAngle << std::endl;\n\tCHECK(semiAngle == Approx(0.785398));\n\tVectorT<double, 3> translationVector(5.0, 5.0, 0.0);\n\tcone.Translate(translationVector);\n\tCHECK(cone.Location().X() == 25.0);\n\tCHECK(cone.Location().Y() == 5.0);\n\tCHECK(cone.Location().Z() == 0.0);\n\tauto xAxis = cone.XAxis();\n\tauto yAxis = cone.YAxis();\n\tCHECK(xAxis.Direction().X() == Approx(-1.0));\n\tCHECK(yAxis.Direction().Y() == Approx(-1.0));\n\tAMCAX::Transformation3 tr;\n\ttr.SetTranslation(Vector3(1.0, 2.0, 3.0));\n\tcone.Transform(tr);\n\tAxis3 newXAxis = cone.Position().XAxis();\n\tCHECK(newXAxis.Location().X() == 26.0);\n\tCHECK(newXAxis.Location().Y() == 7.0);\n\tCHECK(newXAxis.Location().Z() == 3.0);\n} "
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] AMCAX_API Point3 Apex()\t @return The apex point\n\t @brief Get the apex of the cone\n,\n",
      "output": "#include<iostream>\n#include \"catch.hpp\"\n#include <common/FrameT.hpp>\n#include <modeling/MakeFace.hpp>\n#include <common/AxisT.hpp>\n#include <common/FrameT.hpp>\n#include <common/VectorT.hpp>\n#include <math/Cone.hpp>\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"TestCone\", \"[math][Cone]\")\n{\n\tAMCAX::Frame3 frame;\n\tdouble radius = 5.0;\n\tdouble angle = M_PI / 4;\n\tAMCAX::Cone cone(frame, radius, angle);\n\tAMCAX::Point3 apex = cone.Apex();\n\tCHECK(apex.X() == 0.0);\n\tCHECK(apex.Y() == 0.0);\n\tCHECK(apex.Z() == Approx(-5.0));\n\tAMCAX::Axis3 axis = cone.Axis();\n\tstd::cout << axis.Direction().X() << std::endl;\n\tstd::cout << axis.Direction().Y() << std::endl;\n\tstd::cout << axis.Direction().Z() << std::endl;\n\tCHECK(axis.Direction().X() == 0.0);\n\tCHECK(axis.Direction().Y() == 0.0);\n\tCHECK(axis.Direction().Z() == 1.0);\n\tdouble a1, a2, a3, b1, b2, b3, c1, c2, c3, d;\n\tcone.Coefficients(a1, a2, a3, b1, b2, b3, c1, c2, c3, d);\n\tstd::cout << \"a1: \" << a1 << \", a2: \" << a2 << \", a3: \" << a3 << std::endl;\n\tstd::cout << \"b1: \" << b1 << \", b2: \" << b2 << \", b3: \" << b3 << std::endl;\n\tstd::cout << \"c1: \" << c1 << \", c2: \" << c2 << \", c3: \" << c3 << std::endl;\n\tstd::cout << \"d: \" << d << std::endl;\n\tCHECK(a1 == 1.0);\n\tCHECK(a2 == 1.0);\n\tCHECK(a3 == Approx(-1.0));\n\tCHECK(b1 == 0);\n\tCHECK(b2 == 0);\n\tCHECK(b3 == 0);\n\tCHECK(c1 == 0);\n\tCHECK(c2 == 0);\n\tCHECK(c3 == Approx(-5.0));\n\tCHECK(d == -25.0);\n\tCHECK(cone.IsDirect() == true);\n\tCHECK(cone.Location().X() == 0.0);\n\tCHECK(cone.Location().Y() == 0.0);\n\tCHECK(cone.Location().Z() == 0.0);\n\tAMCAX::PointT<double, 3>mirrorPoint(5.0, 0.0, 0.0);\n\tcone.Mirror(mirrorPoint);\n\tauto mirroredLocation = cone.Location();\n\tCHECK(mirroredLocation.X() == 10.0);\n\tCHECK(mirroredLocation.Y() == 0.0);\n\tCHECK(mirroredLocation.Z() == 0.0);\n\tAMCAX::Frame3 coneFrame = cone.Position();\n\tCHECK(frame.Location().X() == 0.0);\n\tCHECK(frame.Location().Y() == 0.0);\n\tCHECK(frame.Location().Z() == 0.0);\n\tCHECK(cone.Radius() == 5.0);\n\tdouble  scaleCone = 2.0;\n\tcone.Scale(cone.Location(), scaleCone);\n\tCHECK(cone.Radius() == radius * 2.0);\n\tdouble semiCone = cone.SemiAngle();\n\tCHECK(semiCone == Approx(0.785398));\n\tconst  Frame3& position = cone.Position();\n\tstd::cout << position.XAxis() << std::endl;\n\tstd::cout << position.YAxis() << std::endl;\n\tDirection3 zDirection(0.0, 0.0, 1.0);\n\tAMCAX::Point3  centerCone(0.0, 0.0, 0.0);\n\tAxis3 zAxis(centerCone, zDirection);\n\tcone.Rotated(zAxis, angle);\n\tAMCAX::Frame3 coneFrame2 = cone.Position();\n\tCHECK(coneFrame.Location().X() == 10.0);\n\tCHECK(coneFrame.Location().Y() == 0.0);\n\tCHECK(coneFrame.Location().Z() == 0.0);\n\tdouble scale = 2.0;\n\tcone.Scale(centerCone, scale);\n\tCHECK(cone.Radius() == radius * 4.0);\n\tdouble semiAngle = cone.SemiAngle();\n\tstd::cout << semiAngle << std::endl;\n\tCHECK(semiAngle == Approx(0.785398));\n\tVectorT<double, 3> translationVector(5.0, 5.0, 0.0);\n\tcone.Translate(translationVector);\n\tCHECK(cone.Location().X() == 25.0);\n\tCHECK(cone.Location().Y() == 5.0);\n\tCHECK(cone.Location().Z() == 0.0);\n\tauto xAxis = cone.XAxis();\n\tauto yAxis = cone.YAxis();\n\tCHECK(xAxis.Direction().X() == Approx(-1.0));\n\tCHECK(yAxis.Direction().Y() == Approx(-1.0));\n\tAMCAX::Transformation3 tr;\n\ttr.SetTranslation(Vector3(1.0, 2.0, 3.0));\n\tcone.Transform(tr);\n\tAxis3 newXAxis = cone.Position().XAxis();\n\tCHECK(newXAxis.Location().X() == 26.0);\n\tCHECK(newXAxis.Location().Y() == 7.0);\n\tCHECK(newXAxis.Location().Z() == 3.0);\n} "
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API int IsInOutOn(const Point2& p, double tol)\t @return 1: in; 0: on; -1: out\n\t @param tol The tolerance of the point\n\t @param p The test point\n\t @brief Check a point is in or out of the polygon\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <common/PointT.hpp>\n#include <math/Classifier2d.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"case3: Classifier2d \", \"[math][Classifier2d][P1]\") {\n    std::vector<Point2> pts = {\n        Point2(2.0, 0.0),\n        Point2(1.0, 1.0),\n        Point2(2.0, 2.0),\n        Point2(3.0, 2.0)\n    }; \n    double tolU = 0.1;\n    double tolV = 0.1;\n    double uMin = 0.0;\n    double vMin = 0.0;\n    double uMax = 2.5;\n    double vMax = 1.5;\n    Classifier2d classifier(pts, tolU, tolV, uMin, vMin, uMax, vMax);\n\tSECTION(\"IsInOutOn Point normal set\") {\n        Point2 OutPoint(0.0, 0.0);\n        Point2 OnPoint(1.0, 1.0);\n        Point2 AnothOnPoint(2.0, 2.0);\n        Point2 InPoint(2.0, 1.0);\n        CHECK(classifier.IsInOutOn(OutPoint,0.0) == -1);\n        CHECK(classifier.IsInOutOn(OnPoint,0.0) != 0);\n        CHECK(classifier.IsInOutOn(OnPoint, 1.0) == 0);\n        CHECK(classifier.IsInOutOn(AnothOnPoint, 1.0) == 0); \n        CHECK(classifier.IsInOutOn(InPoint,0.0) == 1);\n    }} "
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API int IsInOut(const Point2& p)\t @return 1: in; 0: on; -1: out\n\t @param p The test point\n\t @brief Check a point is in or out of the polygon\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <common/PointT.hpp>\n#include <math/Classifier2d.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"case1: Classifier2d \", \"[math][Classifier2d][P1]\") {\n    std::vector<Point2> pts = {\n        Point2(2.0, 0.0),\n        Point2(1.0, 1.0),\n        Point2(2.0, 2.0),\n        Point2(3.0, 2.0)\n    }; \n    double tolU = 0.1;\n    double tolV = 0.1;\n    double uMin = 0.0;\n    double vMin = 0.0;\n    double uMax = 2.5;\n    double vMax = 1.5;\n    Classifier2d classifier(pts, tolU, tolV, uMin, vMin, uMax, vMax);\n\tSECTION(\"IsInOut Point normal set\") {\n        Point2 OutPoint(0.0, 0.0);\n        Point2 OnPoint(1.0, 1.0);\n        Point2 InPoint(2.0, 1.0);\n        CHECK(classifier.IsInOut(OutPoint) == -1);\n        CHECK(classifier.IsInOut(OnPoint) == 0);\n        CHECK(classifier.IsInOut(InPoint) == 1);\n    }} "
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API Classifier2d(const std::vector<Point2>& pts, double tolU, double tolV, double uMin, double vMin, double uMax, double vMax)\t @param vMax The upper bound of v\n\t @param uMax The upper bound of u\n\t @param vMin The lower bound of v\n\t @param uMin The lower bound of u\n\t @param tolV The tolerance of v bound\n\t @param tolU The tolerance of u bound\n\t @param pts The points of a 2D closed polygon, the last point does not required to repeat the first point\n\t @details Require uMax > uMin, vMax > vMin, and at least 3 points\n\t @brief Construct from a 2D polygon and uv-bounds\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <common/PointT.hpp>\n#include <math/Classifier2d.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"case1: Classifier2d \", \"[math][Classifier2d][P1]\") {\n    std::vector<Point2> pts = {\n        Point2(2.0, 0.0),\n        Point2(1.0, 1.0),\n        Point2(2.0, 2.0),\n        Point2(3.0, 2.0)\n    }; \n    double tolU = 0.1;\n    double tolV = 0.1;\n    double uMin = 0.0;\n    double vMin = 0.0;\n    double uMax = 2.5;\n    double vMax = 1.5;\n    Classifier2d classifier(pts, tolU, tolV, uMin, vMin, uMax, vMax);\n\tSECTION(\"IsInOut Point normal set\") {\n        Point2 OutPoint(0.0, 0.0);\n        Point2 OnPoint(1.0, 1.0);\n        Point2 InPoint(2.0, 1.0);\n        CHECK(classifier.IsInOut(OutPoint) == -1);\n        CHECK(classifier.IsInOut(OnPoint) == 0);\n        CHECK(classifier.IsInOut(InPoint) == 1);\n    }} "
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API int IsInOutOn(const Point2& p, double tol)\t @return 1: in; 0: on; -1: out\n\t @param tol The tolerance of the point\n\t @param p The test point\n\t @brief Check a point is in or out of the polygon\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <common/PointT.hpp>\n#include <math/Classifier2d.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"case3: Classifier2d \", \"[math][Classifier2d][P1]\") {\n    std::vector<Point2> pts = {\n        Point2(2.0, 0.0),\n        Point2(1.0, 1.0),\n        Point2(2.0, 2.0),\n        Point2(3.0, 2.0)\n    }; \n    double tolU = 0.1;\n    double tolV = 0.1;\n    double uMin = 0.0;\n    double vMin = 0.0;\n    double uMax = 2.5;\n    double vMax = 1.5;\n    Classifier2d classifier(pts, tolU, tolV, uMin, vMin, uMax, vMax);\n\tSECTION(\"IsInOutOn Point normal set\") {\n        Point2 OutPoint(0.0, 0.0);\n        Point2 OnPoint(1.0, 1.0);\n        Point2 AnothOnPoint(2.0, 2.0);\n        Point2 InPoint(2.0, 1.0);\n        CHECK(classifier.IsInOutOn(OutPoint,0.0) == -1);\n        CHECK(classifier.IsInOutOn(OnPoint,0.0) != 0);\n        CHECK(classifier.IsInOutOn(OnPoint, 1.0) == 0);\n        CHECK(classifier.IsInOutOn(AnothOnPoint, 1.0) == 0); \n        CHECK(classifier.IsInOutOn(InPoint,0.0) == 1);\n    }}\n}\n,\n{\n "
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API int IsInOut(const Point2& p)\t @return 1: in; 0: on; -1: out\n\t @param p The test point\n\t @brief Check a point is in or out of the polygon\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <common/PointT.hpp>\n#include <math/Classifier2d.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"case1: Classifier2d \", \"[math][Classifier2d][P1]\") {\n    std::vector<Point2> pts = {\n        Point2(2.0, 0.0),\n        Point2(1.0, 1.0),\n        Point2(2.0, 2.0),\n        Point2(3.0, 2.0)\n    }; \n    double tolU = 0.1;\n    double tolV = 0.1;\n    double uMin = 0.0;\n    double vMin = 0.0;\n    double uMax = 2.5;\n    double vMax = 1.5;\n    Classifier2d classifier(pts, tolU, tolV, uMin, vMin, uMax, vMax);\n\tSECTION(\"IsInOut Point normal set\") {\n        Point2 OutPoint(0.0, 0.0);\n        Point2 OnPoint(1.0, 1.0);\n        Point2 InPoint(2.0, 1.0);\n        CHECK(classifier.IsInOut(OutPoint) == -1);\n        CHECK(classifier.IsInOut(OnPoint) == 0);\n        CHECK(classifier.IsInOut(InPoint) == 1);\n    }} "
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API Classifier2d(const std::vector<Point2>& pts, double tolU, double tolV, double uMin, double vMin, double uMax, double vMax)\t @param vMax The upper bound of v\n\t @param uMax The upper bound of u\n\t @param vMin The lower bound of v\n\t @param uMin The lower bound of u\n\t @param tolV The tolerance of v bound\n\t @param tolU The tolerance of u bound\n\t @param pts The points of a 2D closed polygon, the last point does not required to repeat the first point\n\t @details Require uMax > uMin, vMax > vMin, and at least 3 points\n\t @brief Construct from a 2D polygon and uv-bounds\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <common/PointT.hpp>\n#include <math/Classifier2d.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"case1: Classifier2d \", \"[math][Classifier2d][P1]\") {\n    std::vector<Point2> pts = {\n        Point2(2.0, 0.0),\n        Point2(1.0, 1.0),\n        Point2(2.0, 2.0),\n        Point2(3.0, 2.0)\n    }; \n    double tolU = 0.1;\n    double tolV = 0.1;\n    double uMin = 0.0;\n    double vMin = 0.0;\n    double uMax = 2.5;\n    double vMax = 1.5;\n    Classifier2d classifier(pts, tolU, tolV, uMin, vMin, uMax, vMax);\n\tSECTION(\"IsInOut Point normal set\") {\n        Point2 OutPoint(0.0, 0.0);\n        Point2 OnPoint(1.0, 1.0);\n        Point2 InPoint(2.0, 1.0);\n        CHECK(classifier.IsInOut(OutPoint) == -1);\n        CHECK(classifier.IsInOut(OnPoint) == 0);\n        CHECK(classifier.IsInOut(InPoint) == 1);\n    }} "
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API Cone& Transform(const Transformation3& tr)\t @return The reference to self\n\t @param tr The transformation\n\t @brief Transform the cone\n,\n",
      "output": "#include<iostream>\n#include \"catch.hpp\"\n#include <common/FrameT.hpp>\n#include <modeling/MakeFace.hpp>\n#include <common/AxisT.hpp>\n#include <common/FrameT.hpp>\n#include <common/VectorT.hpp>\n#include <math/Cone.hpp>\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"TestCone\", \"[math][Cone]\")\n{\n\tAMCAX::Frame3 frame;\n\tdouble radius = 5.0;\n\tdouble angle = M_PI / 4;\n\tAMCAX::Cone cone(frame, radius, angle);\n\tAMCAX::Point3 apex = cone.Apex();\n\tCHECK(apex.X() == 0.0);\n\tCHECK(apex.Y() == 0.0);\n\tCHECK(apex.Z() == Approx(-5.0));\n\tAMCAX::Axis3 axis = cone.Axis();\n\tstd::cout << axis.Direction().X() << std::endl;\n\tstd::cout << axis.Direction().Y() << std::endl;\n\tstd::cout << axis.Direction().Z() << std::endl;\n\tCHECK(axis.Direction().X() == 0.0);\n\tCHECK(axis.Direction().Y() == 0.0);\n\tCHECK(axis.Direction().Z() == 1.0);\n\tdouble a1, a2, a3, b1, b2, b3, c1, c2, c3, d;\n\tcone.Coefficients(a1, a2, a3, b1, b2, b3, c1, c2, c3, d);\n\tstd::cout << \"a1: \" << a1 << \", a2: \" << a2 << \", a3: \" << a3 << std::endl;\n\tstd::cout << \"b1: \" << b1 << \", b2: \" << b2 << \", b3: \" << b3 << std::endl;\n\tstd::cout << \"c1: \" << c1 << \", c2: \" << c2 << \", c3: \" << c3 << std::endl;\n\tstd::cout << \"d: \" << d << std::endl;\n\tCHECK(a1 == 1.0);\n\tCHECK(a2 == 1.0);\n\tCHECK(a3 == Approx(-1.0));\n\tCHECK(b1 == 0);\n\tCHECK(b2 == 0);\n\tCHECK(b3 == 0);\n\tCHECK(c1 == 0);\n\tCHECK(c2 == 0);\n\tCHECK(c3 == Approx(-5.0));\n\tCHECK(d == -25.0);\n\tCHECK(cone.IsDirect() == true);\n\tCHECK(cone.Location().X() == 0.0);\n\tCHECK(cone.Location().Y() == 0.0);\n\tCHECK(cone.Location().Z() == 0.0);\n\tAMCAX::PointT<double, 3>mirrorPoint(5.0, 0.0, 0.0);\n\tcone.Mirror(mirrorPoint);\n\tauto mirroredLocation = cone.Location();\n\tCHECK(mirroredLocation.X() == 10.0);\n\tCHECK(mirroredLocation.Y() == 0.0);\n\tCHECK(mirroredLocation.Z() == 0.0);\n\tAMCAX::Frame3 coneFrame = cone.Position();\n\tCHECK(frame.Location().X() == 0.0);\n\tCHECK(frame.Location().Y() == 0.0);\n\tCHECK(frame.Location().Z() == 0.0);\n\tCHECK(cone.Radius() == 5.0);\n\tdouble  scaleCone = 2.0;\n\tcone.Scale(cone.Location(), scaleCone);\n\tCHECK(cone.Radius() == radius * 2.0);\n\tdouble semiCone = cone.SemiAngle();\n\tCHECK(semiCone == Approx(0.785398));\n\tconst  Frame3& position = cone.Position();\n\tstd::cout << position.XAxis() << std::endl;\n\tstd::cout << position.YAxis() << std::endl;\n\tDirection3 zDirection(0.0, 0.0, 1.0);\n\tAMCAX::Point3  centerCone(0.0, 0.0, 0.0);\n\tAxis3 zAxis(centerCone, zDirection);\n\tcone.Rotated(zAxis, angle);\n\tAMCAX::Frame3 coneFrame2 = cone.Position();\n\tCHECK(coneFrame.Location().X() == 10.0);\n\tCHECK(coneFrame.Location().Y() == 0.0);\n\tCHECK(coneFrame.Location().Z() == 0.0);\n\tdouble scale = 2.0;\n\tcone.Scale(centerCone, scale);\n\tCHECK(cone.Radius() == radius * 4.0);\n\tdouble semiAngle = cone.SemiAngle();\n\tstd::cout << semiAngle << std::endl;\n\tCHECK(semiAngle == Approx(0.785398));\n\tVectorT<double, 3> translationVector(5.0, 5.0, 0.0);\n\tcone.Translate(translationVector);\n\tCHECK(cone.Location().X() == 25.0);\n\tCHECK(cone.Location().Y() == 5.0);\n\tCHECK(cone.Location().Z() == 0.0);\n\tauto xAxis = cone.XAxis();\n\tauto yAxis = cone.YAxis();\n\tCHECK(xAxis.Direction().X() == Approx(-1.0));\n\tCHECK(yAxis.Direction().Y() == Approx(-1.0));\n\tAMCAX::Transformation3 tr;\n\ttr.SetTranslation(Vector3(1.0, 2.0, 3.0));\n\tcone.Transform(tr);\n\tAxis3 newXAxis = cone.Position().XAxis();\n\tCHECK(newXAxis.Location().X() == 26.0);\n\tCHECK(newXAxis.Location().Y() == 7.0);\n\tCHECK(newXAxis.Location().Z() == 3.0);\n}\n}\n,\n{\n "
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API Cone& Scale(const Point3& point, double scale)\t @return The reference to self\n\t @param scale The scale value\n\t @param point The scaling center point\n\t @brief Scale the cone by a point\n,\n",
      "output": "#include<iostream>\n#include \"catch.hpp\"\n#include <common/FrameT.hpp>\n#include <modeling/MakeFace.hpp>\n#include <common/AxisT.hpp>\n#include <common/FrameT.hpp>\n#include <common/VectorT.hpp>\n#include <math/Cone.hpp>\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"TestCone\", \"[math][Cone]\")\n{\n\tAMCAX::Frame3 frame;\n\tdouble radius = 5.0;\n\tdouble angle = M_PI / 4;\n\tAMCAX::Cone cone(frame, radius, angle);\n\tAMCAX::Point3 apex = cone.Apex();\n\tCHECK(apex.X() == 0.0);\n\tCHECK(apex.Y() == 0.0);\n\tCHECK(apex.Z() == Approx(-5.0));\n\tAMCAX::Axis3 axis = cone.Axis();\n\tstd::cout << axis.Direction().X() << std::endl;\n\tstd::cout << axis.Direction().Y() << std::endl;\n\tstd::cout << axis.Direction().Z() << std::endl;\n\tCHECK(axis.Direction().X() == 0.0);\n\tCHECK(axis.Direction().Y() == 0.0);\n\tCHECK(axis.Direction().Z() == 1.0);\n\tdouble a1, a2, a3, b1, b2, b3, c1, c2, c3, d;\n\tcone.Coefficients(a1, a2, a3, b1, b2, b3, c1, c2, c3, d);\n\tstd::cout << \"a1: \" << a1 << \", a2: \" << a2 << \", a3: \" << a3 << std::endl;\n\tstd::cout << \"b1: \" << b1 << \", b2: \" << b2 << \", b3: \" << b3 << std::endl;\n\tstd::cout << \"c1: \" << c1 << \", c2: \" << c2 << \", c3: \" << c3 << std::endl;\n\tstd::cout << \"d: \" << d << std::endl;\n\tCHECK(a1 == 1.0);\n\tCHECK(a2 == 1.0);\n\tCHECK(a3 == Approx(-1.0));\n\tCHECK(b1 == 0);\n\tCHECK(b2 == 0);\n\tCHECK(b3 == 0);\n\tCHECK(c1 == 0);\n\tCHECK(c2 == 0);\n\tCHECK(c3 == Approx(-5.0));\n\tCHECK(d == -25.0);\n\tCHECK(cone.IsDirect() == true);\n\tCHECK(cone.Location().X() == 0.0);\n\tCHECK(cone.Location().Y() == 0.0);\n\tCHECK(cone.Location().Z() == 0.0);\n\tAMCAX::PointT<double, 3>mirrorPoint(5.0, 0.0, 0.0);\n\tcone.Mirror(mirrorPoint);\n\tauto mirroredLocation = cone.Location();\n\tCHECK(mirroredLocation.X() == 10.0);\n\tCHECK(mirroredLocation.Y() == 0.0);\n\tCHECK(mirroredLocation.Z() == 0.0);\n\tAMCAX::Frame3 coneFrame = cone.Position();\n\tCHECK(frame.Location().X() == 0.0);\n\tCHECK(frame.Location().Y() == 0.0);\n\tCHECK(frame.Location().Z() == 0.0);\n\tCHECK(cone.Radius() == 5.0);\n\tdouble  scaleCone = 2.0;\n\tcone.Scale(cone.Location(), scaleCone);\n\tCHECK(cone.Radius() == radius * 2.0);\n\tdouble semiCone = cone.SemiAngle();\n\tCHECK(semiCone == Approx(0.785398));\n\tconst  Frame3& position = cone.Position();\n\tstd::cout << position.XAxis() << std::endl;\n\tstd::cout << position.YAxis() << std::endl;\n\tDirection3 zDirection(0.0, 0.0, 1.0);\n\tAMCAX::Point3  centerCone(0.0, 0.0, 0.0);\n\tAxis3 zAxis(centerCone, zDirection);\n\tcone.Rotated(zAxis, angle);\n\tAMCAX::Frame3 coneFrame2 = cone.Position();\n\tCHECK(coneFrame.Location().X() == 10.0);\n\tCHECK(coneFrame.Location().Y() == 0.0);\n\tCHECK(coneFrame.Location().Z() == 0.0);\n\tdouble scale = 2.0;\n\tcone.Scale(centerCone, scale);\n\tCHECK(cone.Radius() == radius * 4.0);\n\tdouble semiAngle = cone.SemiAngle();\n\tstd::cout << semiAngle << std::endl;\n\tCHECK(semiAngle == Approx(0.785398));\n\tVectorT<double, 3> translationVector(5.0, 5.0, 0.0);\n\tcone.Translate(translationVector);\n\tCHECK(cone.Location().X() == 25.0);\n\tCHECK(cone.Location().Y() == 5.0);\n\tCHECK(cone.Location().Z() == 0.0);\n\tauto xAxis = cone.XAxis();\n\tauto yAxis = cone.YAxis();\n\tCHECK(xAxis.Direction().X() == Approx(-1.0));\n\tCHECK(yAxis.Direction().Y() == Approx(-1.0));\n\tAMCAX::Transformation3 tr;\n\ttr.SetTranslation(Vector3(1.0, 2.0, 3.0));\n\tcone.Transform(tr);\n\tAxis3 newXAxis = cone.Position().XAxis();\n\tCHECK(newXAxis.Location().X() == 26.0);\n\tCHECK(newXAxis.Location().Y() == 7.0);\n\tCHECK(newXAxis.Location().Z() == 3.0);\n} "
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API Cone(const Frame3& frame, double r, double angle)\t @param angle The semi-angle\n\t @param r The reference radius\n\t @param frame The local frame\n\t @brief Construct from a local frame, a reference radius and a semi-angle\n,\n",
      "output": "#include<iostream>\n#include \"catch.hpp\"\n#include <common/FrameT.hpp>\n#include <modeling/MakeFace.hpp>\n#include <common/AxisT.hpp>\n#include <common/FrameT.hpp>\n#include <common/VectorT.hpp>\n#include <math/Cone.hpp>\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"TestCone\", \"[math][Cone]\")\n{\n\tAMCAX::Frame3 frame;\n\tdouble radius = 5.0;\n\tdouble angle = M_PI / 4;\n\tAMCAX::Cone cone(frame, radius, angle);\n\tAMCAX::Point3 apex = cone.Apex();\n\tCHECK(apex.X() == 0.0);\n\tCHECK(apex.Y() == 0.0);\n\tCHECK(apex.Z() == Approx(-5.0));\n\tAMCAX::Axis3 axis = cone.Axis();\n\tstd::cout << axis.Direction().X() << std::endl;\n\tstd::cout << axis.Direction().Y() << std::endl;\n\tstd::cout << axis.Direction().Z() << std::endl;\n\tCHECK(axis.Direction().X() == 0.0);\n\tCHECK(axis.Direction().Y() == 0.0);\n\tCHECK(axis.Direction().Z() == 1.0);\n\tdouble a1, a2, a3, b1, b2, b3, c1, c2, c3, d;\n\tcone.Coefficients(a1, a2, a3, b1, b2, b3, c1, c2, c3, d);\n\tstd::cout << \"a1: \" << a1 << \", a2: \" << a2 << \", a3: \" << a3 << std::endl;\n\tstd::cout << \"b1: \" << b1 << \", b2: \" << b2 << \", b3: \" << b3 << std::endl;\n\tstd::cout << \"c1: \" << c1 << \", c2: \" << c2 << \", c3: \" << c3 << std::endl;\n\tstd::cout << \"d: \" << d << std::endl;\n\tCHECK(a1 == 1.0);\n\tCHECK(a2 == 1.0);\n\tCHECK(a3 == Approx(-1.0));\n\tCHECK(b1 == 0);\n\tCHECK(b2 == 0);\n\tCHECK(b3 == 0);\n\tCHECK(c1 == 0);\n\tCHECK(c2 == 0);\n\tCHECK(c3 == Approx(-5.0));\n\tCHECK(d == -25.0);\n\tCHECK(cone.IsDirect() == true);\n\tCHECK(cone.Location().X() == 0.0);\n\tCHECK(cone.Location().Y() == 0.0);\n\tCHECK(cone.Location().Z() == 0.0);\n\tAMCAX::PointT<double, 3>mirrorPoint(5.0, 0.0, 0.0);\n\tcone.Mirror(mirrorPoint);\n\tauto mirroredLocation = cone.Location();\n\tCHECK(mirroredLocation.X() == 10.0);\n\tCHECK(mirroredLocation.Y() == 0.0);\n\tCHECK(mirroredLocation.Z() == 0.0);\n\tAMCAX::Frame3 coneFrame = cone.Position();\n\tCHECK(frame.Location().X() == 0.0);\n\tCHECK(frame.Location().Y() == 0.0);\n\tCHECK(frame.Location().Z() == 0.0);\n\tCHECK(cone.Radius() == 5.0);\n\tdouble  scaleCone = 2.0;\n\tcone.Scale(cone.Location(), scaleCone);\n\tCHECK(cone.Radius() == radius * 2.0);\n\tdouble semiCone = cone.SemiAngle();\n\tCHECK(semiCone == Approx(0.785398));\n\tconst  Frame3& position = cone.Position();\n\tstd::cout << position.XAxis() << std::endl;\n\tstd::cout << position.YAxis() << std::endl;\n\tDirection3 zDirection(0.0, 0.0, 1.0);\n\tAMCAX::Point3  centerCone(0.0, 0.0, 0.0);\n\tAxis3 zAxis(centerCone, zDirection);\n\tcone.Rotated(zAxis, angle);\n\tAMCAX::Frame3 coneFrame2 = cone.Position();\n\tCHECK(coneFrame.Location().X() == 10.0);\n\tCHECK(coneFrame.Location().Y() == 0.0);\n\tCHECK(coneFrame.Location().Z() == 0.0);\n\tdouble scale = 2.0;\n\tcone.Scale(centerCone, scale);\n\tCHECK(cone.Radius() == radius * 4.0);\n\tdouble semiAngle = cone.SemiAngle();\n\tstd::cout << semiAngle << std::endl;\n\tCHECK(semiAngle == Approx(0.785398));\n\tVectorT<double, 3> translationVector(5.0, 5.0, 0.0);\n\tcone.Translate(translationVector);\n\tCHECK(cone.Location().X() == 25.0);\n\tCHECK(cone.Location().Y() == 5.0);\n\tCHECK(cone.Location().Z() == 0.0);\n\tauto xAxis = cone.XAxis();\n\tauto yAxis = cone.YAxis();\n\tCHECK(xAxis.Direction().X() == Approx(-1.0));\n\tCHECK(yAxis.Direction().Y() == Approx(-1.0));\n\tAMCAX::Transformation3 tr;\n\ttr.SetTranslation(Vector3(1.0, 2.0, 3.0));\n\tcone.Transform(tr);\n\tAxis3 newXAxis = cone.Position().XAxis();\n\tCHECK(newXAxis.Location().X() == 26.0);\n\tCHECK(newXAxis.Location().Y() == 7.0);\n\tCHECK(newXAxis.Location().Z() == 3.0);\n} "
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] AMCAX_API double SemiAngle()\t @return The semi-angle\n\t @brief Get the semi-angle\n,\n",
      "output": "#include<iostream>\n#include \"catch.hpp\"\n#include <common/FrameT.hpp>\n#include <modeling/MakeFace.hpp>\n#include <common/AxisT.hpp>\n#include <common/FrameT.hpp>\n#include <common/VectorT.hpp>\n#include <math/Cone.hpp>\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"TestCone\", \"[math][Cone]\")\n{\n\tAMCAX::Frame3 frame;\n\tdouble radius = 5.0;\n\tdouble angle = M_PI / 4;\n\tAMCAX::Cone cone(frame, radius, angle);\n\tAMCAX::Point3 apex = cone.Apex();\n\tCHECK(apex.X() == 0.0);\n\tCHECK(apex.Y() == 0.0);\n\tCHECK(apex.Z() == Approx(-5.0));\n\tAMCAX::Axis3 axis = cone.Axis();\n\tstd::cout << axis.Direction().X() << std::endl;\n\tstd::cout << axis.Direction().Y() << std::endl;\n\tstd::cout << axis.Direction().Z() << std::endl;\n\tCHECK(axis.Direction().X() == 0.0);\n\tCHECK(axis.Direction().Y() == 0.0);\n\tCHECK(axis.Direction().Z() == 1.0);\n\tdouble a1, a2, a3, b1, b2, b3, c1, c2, c3, d;\n\tcone.Coefficients(a1, a2, a3, b1, b2, b3, c1, c2, c3, d);\n\tstd::cout << \"a1: \" << a1 << \", a2: \" << a2 << \", a3: \" << a3 << std::endl;\n\tstd::cout << \"b1: \" << b1 << \", b2: \" << b2 << \", b3: \" << b3 << std::endl;\n\tstd::cout << \"c1: \" << c1 << \", c2: \" << c2 << \", c3: \" << c3 << std::endl;\n\tstd::cout << \"d: \" << d << std::endl;\n\tCHECK(a1 == 1.0);\n\tCHECK(a2 == 1.0);\n\tCHECK(a3 == Approx(-1.0));\n\tCHECK(b1 == 0);\n\tCHECK(b2 == 0);\n\tCHECK(b3 == 0);\n\tCHECK(c1 == 0);\n\tCHECK(c2 == 0);\n\tCHECK(c3 == Approx(-5.0));\n\tCHECK(d == -25.0);\n\tCHECK(cone.IsDirect() == true);\n\tCHECK(cone.Location().X() == 0.0);\n\tCHECK(cone.Location().Y() == 0.0);\n\tCHECK(cone.Location().Z() == 0.0);\n\tAMCAX::PointT<double, 3>mirrorPoint(5.0, 0.0, 0.0);\n\tcone.Mirror(mirrorPoint);\n\tauto mirroredLocation = cone.Location();\n\tCHECK(mirroredLocation.X() == 10.0);\n\tCHECK(mirroredLocation.Y() == 0.0);\n\tCHECK(mirroredLocation.Z() == 0.0);\n\tAMCAX::Frame3 coneFrame = cone.Position();\n\tCHECK(frame.Location().X() == 0.0);\n\tCHECK(frame.Location().Y() == 0.0);\n\tCHECK(frame.Location().Z() == 0.0);\n\tCHECK(cone.Radius() == 5.0);\n\tdouble  scaleCone = 2.0;\n\tcone.Scale(cone.Location(), scaleCone);\n\tCHECK(cone.Radius() == radius * 2.0);\n\tdouble semiCone = cone.SemiAngle();\n\tCHECK(semiCone == Approx(0.785398));\n\tconst  Frame3& position = cone.Position();\n\tstd::cout << position.XAxis() << std::endl;\n\tstd::cout << position.YAxis() << std::endl;\n\tDirection3 zDirection(0.0, 0.0, 1.0);\n\tAMCAX::Point3  centerCone(0.0, 0.0, 0.0);\n\tAxis3 zAxis(centerCone, zDirection);\n\tcone.Rotated(zAxis, angle);\n\tAMCAX::Frame3 coneFrame2 = cone.Position();\n\tCHECK(coneFrame.Location().X() == 10.0);\n\tCHECK(coneFrame.Location().Y() == 0.0);\n\tCHECK(coneFrame.Location().Z() == 0.0);\n\tdouble scale = 2.0;\n\tcone.Scale(centerCone, scale);\n\tCHECK(cone.Radius() == radius * 4.0);\n\tdouble semiAngle = cone.SemiAngle();\n\tstd::cout << semiAngle << std::endl;\n\tCHECK(semiAngle == Approx(0.785398));\n\tVectorT<double, 3> translationVector(5.0, 5.0, 0.0);\n\tcone.Translate(translationVector);\n\tCHECK(cone.Location().X() == 25.0);\n\tCHECK(cone.Location().Y() == 5.0);\n\tCHECK(cone.Location().Z() == 0.0);\n\tauto xAxis = cone.XAxis();\n\tauto yAxis = cone.YAxis();\n\tCHECK(xAxis.Direction().X() == Approx(-1.0));\n\tCHECK(yAxis.Direction().Y() == Approx(-1.0));\n\tAMCAX::Transformation3 tr;\n\ttr.SetTranslation(Vector3(1.0, 2.0, 3.0));\n\tcone.Transform(tr);\n\tAxis3 newXAxis = cone.Position().XAxis();\n\tCHECK(newXAxis.Location().X() == 26.0);\n\tCHECK(newXAxis.Location().Y() == 7.0);\n\tCHECK(newXAxis.Location().Z() == 3.0);\n} "
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] AMCAX_API Point3 Apex()\t @return The apex point\n\t @brief Get the apex of the cone\n,\n",
      "output": "#include<iostream>\n#include \"catch.hpp\"\n#include <common/FrameT.hpp>\n#include <modeling/MakeFace.hpp>\n#include <common/AxisT.hpp>\n#include <common/FrameT.hpp>\n#include <common/VectorT.hpp>\n#include <math/Cone.hpp>\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"TestCone\", \"[math][Cone]\")\n{\n\tAMCAX::Frame3 frame;\n\tdouble radius = 5.0;\n\tdouble angle = M_PI / 4;\n\tAMCAX::Cone cone(frame, radius, angle);\n\tAMCAX::Point3 apex = cone.Apex();\n\tCHECK(apex.X() == 0.0);\n\tCHECK(apex.Y() == 0.0);\n\tCHECK(apex.Z() == Approx(-5.0));\n\tAMCAX::Axis3 axis = cone.Axis();\n\tstd::cout << axis.Direction().X() << std::endl;\n\tstd::cout << axis.Direction().Y() << std::endl;\n\tstd::cout << axis.Direction().Z() << std::endl;\n\tCHECK(axis.Direction().X() == 0.0);\n\tCHECK(axis.Direction().Y() == 0.0);\n\tCHECK(axis.Direction().Z() == 1.0);\n\tdouble a1, a2, a3, b1, b2, b3, c1, c2, c3, d;\n\tcone.Coefficients(a1, a2, a3, b1, b2, b3, c1, c2, c3, d);\n\tstd::cout << \"a1: \" << a1 << \", a2: \" << a2 << \", a3: \" << a3 << std::endl;\n\tstd::cout << \"b1: \" << b1 << \", b2: \" << b2 << \", b3: \" << b3 << std::endl;\n\tstd::cout << \"c1: \" << c1 << \", c2: \" << c2 << \", c3: \" << c3 << std::endl;\n\tstd::cout << \"d: \" << d << std::endl;\n\tCHECK(a1 == 1.0);\n\tCHECK(a2 == 1.0);\n\tCHECK(a3 == Approx(-1.0));\n\tCHECK(b1 == 0);\n\tCHECK(b2 == 0);\n\tCHECK(b3 == 0);\n\tCHECK(c1 == 0);\n\tCHECK(c2 == 0);\n\tCHECK(c3 == Approx(-5.0));\n\tCHECK(d == -25.0);\n\tCHECK(cone.IsDirect() == true);\n\tCHECK(cone.Location().X() == 0.0);\n\tCHECK(cone.Location().Y() == 0.0);\n\tCHECK(cone.Location().Z() == 0.0);\n\tAMCAX::PointT<double, 3>mirrorPoint(5.0, 0.0, 0.0);\n\tcone.Mirror(mirrorPoint);\n\tauto mirroredLocation = cone.Location();\n\tCHECK(mirroredLocation.X() == 10.0);\n\tCHECK(mirroredLocation.Y() == 0.0);\n\tCHECK(mirroredLocation.Z() == 0.0);\n\tAMCAX::Frame3 coneFrame = cone.Position();\n\tCHECK(frame.Location().X() == 0.0);\n\tCHECK(frame.Location().Y() == 0.0);\n\tCHECK(frame.Location().Z() == 0.0);\n\tCHECK(cone.Radius() == 5.0);\n\tdouble  scaleCone = 2.0;\n\tcone.Scale(cone.Location(), scaleCone);\n\tCHECK(cone.Radius() == radius * 2.0);\n\tdouble semiCone = cone.SemiAngle();\n\tCHECK(semiCone == Approx(0.785398));\n\tconst  Frame3& position = cone.Position();\n\tstd::cout << position.XAxis() << std::endl;\n\tstd::cout << position.YAxis() << std::endl;\n\tDirection3 zDirection(0.0, 0.0, 1.0);\n\tAMCAX::Point3  centerCone(0.0, 0.0, 0.0);\n\tAxis3 zAxis(centerCone, zDirection);\n\tcone.Rotated(zAxis, angle);\n\tAMCAX::Frame3 coneFrame2 = cone.Position();\n\tCHECK(coneFrame.Location().X() == 10.0);\n\tCHECK(coneFrame.Location().Y() == 0.0);\n\tCHECK(coneFrame.Location().Z() == 0.0);\n\tdouble scale = 2.0;\n\tcone.Scale(centerCone, scale);\n\tCHECK(cone.Radius() == radius * 4.0);\n\tdouble semiAngle = cone.SemiAngle();\n\tstd::cout << semiAngle << std::endl;\n\tCHECK(semiAngle == Approx(0.785398));\n\tVectorT<double, 3> translationVector(5.0, 5.0, 0.0);\n\tcone.Translate(translationVector);\n\tCHECK(cone.Location().X() == 25.0);\n\tCHECK(cone.Location().Y() == 5.0);\n\tCHECK(cone.Location().Z() == 0.0);\n\tauto xAxis = cone.XAxis();\n\tauto yAxis = cone.YAxis();\n\tCHECK(xAxis.Direction().X() == Approx(-1.0));\n\tCHECK(yAxis.Direction().Y() == Approx(-1.0));\n\tAMCAX::Transformation3 tr;\n\ttr.SetTranslation(Vector3(1.0, 2.0, 3.0));\n\tcone.Transform(tr);\n\tAxis3 newXAxis = cone.Position().XAxis();\n\tCHECK(newXAxis.Location().X() == 26.0);\n\tCHECK(newXAxis.Location().Y() == 7.0);\n\tCHECK(newXAxis.Location().Z() == 3.0);\n} "
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static void AdjustPeriodic(double ufirst, double ulast, double precision, double& u1, double& u2)\t @param[in,out] u2 The second parameter to be adjust\n\t @param[in,out] u1 The first parameter to be adjust\n\t @param[in] precision The precision to check equality\n\t @param[in] ulast The upper bound of the period\n\t @param[in] ufirst The lower bound of the period\n\t          The parameter u2 is set in the range [u1, u1 + ulast - ufirst]\n\t @details The parameter u1 is set in the range [ufirst, ulast]\n\t @brief Adjust u1 and u2 to be in the period range.\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <common/PointT.hpp>\n#include <math/CurveCalculation.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"case1: CurveCalculation::AdjustPeriodic \", \"[math][CurveCalculation][P1]\") {\n\tdouble u1 = 0.0;\n\tdouble u2 = 2 * M_PI;\n\tdouble ufirst = 0.0;\n\tdouble ulast = 2 * M_PI; \n\tdouble precision = 0.001; \n\tAMCAX::CurveCalculation::AdjustPeriodic(ufirst, ulast, precision, u1, u2);\n\tCHECK(u1 == 0);\n\tCHECK(u2 == 2 * M_PI);\n} "
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] AMCAX_API static Vector2 D1(double u, const Circle2& circle)\t @return The first derivative vector\n\t @param circle The circle\n\t @param u The parameter\n\t @brief Compute the first derivative on a 2D circle at a parameter\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <common/PointT.hpp>\n#include <math/CurveCalculation.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <geometry/MakeArcOfHyperbola2d.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <modeling/MakeEdge2d.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"case1: CurveCalculation::D1() circle2[1/20] \", \"[math][CurveCalculation][P1][D1]\") {\n\tDirection2 initialDir(1.0, 0.0); \n\tFrame2 defaultFrame2(Point2(1.0, 1.0), initialDir); \n    double radius = 2.0;\n    AMCAX::Circle2 circle2(defaultFrame2,radius);\n\tSECTION(\"u =0\") {\n\t\tVector2 vector2 = CurveCalculation::D1(0.0, circle2);\n\t\tCHECK(vector2.X() == Approx(-0.0));\n\t\tCHECK(vector2.Y() == 2.0);\n\t}}\n}\n,\n{\n "
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static void D1(double u, const Line2& line, Point2& p, Vector2& v1)\t @param[out] v1 The first derivative\n\t @param[out] p The point\n\t @param[in] line The line\n\t @param[in] u The parameter\n\t @brief Compute the point and the first derivative on a 2D line at a parameter\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <common/PointT.hpp>\n#include <math/CurveCalculation.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <geometry/MakeArcOfHyperbola2d.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <modeling/MakeEdge2d.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"case1: CurveCalculation::D1() circle2[2/20] \", \"[math][CurveCalculation][P1][D1]\") {\n\tDirection2 initialDir(1.0, 0.0); \n\tFrame2 defaultFrame2(Point2(1.0, 1.0), initialDir); \n\tdouble radius = 2.0;\n\tAMCAX::Circle2 circle2(defaultFrame2, radius);\n\tPoint2 p;\n\tVector2 v;\n\tSECTION(\"u =0\") {\n\t\tCurveCalculation::D1(0.0, circle2,p,v);\n\t\tCHECK(p.X() == 3.0);\n\t\tCHECK(p.Y() == 1.0);\n\t\tCHECK(v.X() == Approx(0.0));\n\t\tCHECK(v.Y() == Approx(2.0));\n\t}} "
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] AMCAX_API static Vector2 D1(double u, const Line2& line)\t @return The first derivative vector\n\t @param line The line\n\t @param u The parameter\n\t @brief Compute the first derivative on a 2D line at a parameter\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <common/PointT.hpp>\n#include <math/CurveCalculation.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <geometry/MakeArcOfHyperbola2d.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <modeling/MakeEdge2d.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"case1: CurveCalculation::D1() circle2[1/20] \", \"[math][CurveCalculation][P1][D1]\") {\n\tDirection2 initialDir(1.0, 0.0); \n\tFrame2 defaultFrame2(Point2(1.0, 1.0), initialDir); \n    double radius = 2.0;\n    AMCAX::Circle2 circle2(defaultFrame2,radius);\n\tSECTION(\"u =0\") {\n\t\tVector2 vector2 = CurveCalculation::D1(0.0, circle2);\n\t\tCHECK(vector2.X() == Approx(-0.0));\n\t\tCHECK(vector2.Y() == 2.0);\n\t}} "
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static void D1(double u, const Hyperbola3& hyperbola, Point3& p, Vector3& v1)\t @param[out] v1 The first derivative\n\t @param[out] p The point\n\t @param[in] hyperbola The hyperbola\n\t @param[in] u The parameter\n\t @brief Compute the point and the first derivative on a 3D hyperbola at a parameter\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <common/PointT.hpp>\n#include <math/CurveCalculation.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <geometry/MakeArcOfHyperbola2d.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <modeling/MakeEdge2d.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"case1: CurveCalculation::D1() Hyperbola3 [12/20] \", \"[math][CurveCalculation][P1][D1]\") {\n\tDirection3 dir3(0.0, 0.0, 1.0);\n\tPoint3 point3(0.0, 0.0, 0.0);\n\tFrame3 frame3(point3, dir3);\n\tHyperbola3 hyperbola3(frame3, 5.0, 3.0); \n\tPoint3 p;\n\tVector3 v;\n\tCurveCalculation::D1(0.0, hyperbola3,p,v); \n\tCHECK(p.X() == 5.0);\n\tCHECK(p.Y() == 0.0);\n\tCHECK(p.Z() == 0.0);\n\tCHECK(v.X() == 0.0);\n\tCHECK(v.Y() == 3.0);\n\tCHECK(v.Z() == 0.0);\n} "
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] AMCAX_API static Vector3 D1(double u, const Hyperbola3& hyperbola)\t @return The first derivative vector\n\t @param hyperbola The hyperbola\n\t @param u The parameter\n\t @brief Compute the first derivative on a 3D hyperbola at a parameter\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <common/PointT.hpp>\n#include <math/CurveCalculation.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <geometry/MakeArcOfHyperbola2d.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <modeling/MakeEdge2d.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"case1: CurveCalculation::D1() Hyperbola3 [11/20] \", \"[math][CurveCalculation][P1][D1]\") {\n\tDirection3 dir3(0.0, 0.0, 1.0);\n\tPoint3 point3(0.0, 0.0, 0.0);\n\tFrame3 frame3(point3, dir3);\n\tHyperbola3 hyperbola3(frame3, 5.0, 3.0); \n\tVector3 vector3 = CurveCalculation::D1(0.0, hyperbola3); \n\tCHECK(vector3.X() == 0.0);\n\tCHECK(vector3.Y() == 3.0);\n\tCHECK(vector3.Z() == 0.0);\n} "
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static void D1(double u, const Parabola3& parabola, Point3& p, Vector3& v1)\t @param[out] v1 The first derivative\n\t @param[out] p The point\n\t @param[in] parabola The parabola\n\t @param[in] u The parameter\n\t @brief Compute the point and the first derivative on a 3D parabola at a parameter\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <common/PointT.hpp>\n#include <math/CurveCalculation.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <geometry/MakeArcOfHyperbola2d.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <modeling/MakeEdge2d.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"case1: CurveCalculation::D1() ellipse3 [8/20] \", \"[math][CurveCalculation][P1][D1]\") {\n\tDirection3 initialDir(0.0, 0.0, 1.0); \n\tFrame3 defaultFrame3(Point3(0.0, 0.0, 0.0), initialDir); \n\tEllipse3 ellipse3(defaultFrame3, 5.0, 3.0);\n\tPoint3 p;\n\tVector3 v;\n\tMakeEdge edge = MakeEdge(ellipse3);\n\tbool bWriteresult = OCCTIO::OCCTTool::Write(edge, OUTPUT_PATH_PREFIX\"ellipse3CurveCalculation_case1.brep\", true, 3);\n\tSECTION(\"u =0\") {\n\t\tCurveCalculation::D1(0.0, ellipse3,p,v);\n\t\tCHECK(p.X() == 5.0);\n\t\tCHECK(p.Y() == 0.0);\n\t\tCHECK(p.Z() == 0.0);\n\t\tCHECK(v.X() == Approx(0.0));\n\t\tCHECK(v.Y() == Approx(3.0));\n\t\tCHECK(v.Z() == Approx(0.0));\n\t}} "
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] AMCAX_API static Vector3 D1(double u, const Parabola3& parabola)\t @return The first derivative vector\n\t @param parabola The parabola\n\t @param u The parameter\n\t @brief Compute the first derivative on a 3D parabola at a parameter\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <common/PointT.hpp>\n#include <math/CurveCalculation.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <geometry/MakeArcOfHyperbola2d.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <modeling/MakeEdge2d.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"case1: CurveCalculation::D1() ellipse3 [7/20] \", \"[math][CurveCalculation][P1][D1]\") {\n\tDirection3 initialDir(0.0, 0.0, 1.0); \n\tFrame3 defaultFrame3(Point3(0.0, 0.0, 0.0), initialDir); \n\tEllipse3 ellipse3(defaultFrame3,5.0,3.0 );\n\tMakeEdge edge= MakeEdge(ellipse3);\n\tbool bWriteresult = OCCTIO::OCCTTool::Write(edge, OUTPUT_PATH_PREFIX\"ellipse3CurveCalculation_case1.brep\",true,3);\n\tSECTION(\"u = M_PI_2\") {\n\t\tVector3 vector3 = CurveCalculation::D1(M_PI_2, ellipse3);\n\t\tCHECK(vector3.X() == Approx(-5.0));\n\t\tCHECK(vector3.Y() == Approx(0.0).margin(1e-14));\n\t\tCHECK(vector3.Z() == Approx(0.0));\n\t}\n}} "
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static void D1(double u, const Ellipse3& ellipse, Point3& p, Vector3& v1)\t @param[out] v1 The first derivative\n\t @param[out] p The point\n\t @param[in] ellipse The ellipse\n\t @param[in] u The parameter\n\t @brief Compute the point and the first derivative on a 3D ellipse at a parameter\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <common/PointT.hpp>\n#include <math/CurveCalculation.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <geometry/MakeArcOfHyperbola2d.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <modeling/MakeEdge2d.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"case1: CurveCalculation::D1() ellipse3 [7/20] \", \"[math][CurveCalculation][P1][D1]\") {\n\tDirection3 initialDir(0.0, 0.0, 1.0); \n\tFrame3 defaultFrame3(Point3(0.0, 0.0, 0.0), initialDir); \n\tEllipse3 ellipse3(defaultFrame3,5.0,3.0 );\n\tMakeEdge edge= MakeEdge(ellipse3);\n\tbool bWriteresult = OCCTIO::OCCTTool::Write(edge, OUTPUT_PATH_PREFIX\"ellipse3CurveCalculation_case1.brep\",true,3);\n\tSECTION(\"u =0\") {\n\t\tVector3 vector3 = CurveCalculation::D1(0.0, ellipse3);\n\t\tCHECK(vector3.X() == Approx(0.0));\n\t\tCHECK(vector3.Y() == Approx(3.0));\n\t\tCHECK(vector3.Z() == Approx(0.0));\n\t}} "
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] AMCAX_API static Vector3 D1(double u, const Ellipse3& ellipse)\t @return The first derivative vector\n\t @param ellipse The ellipse\n\t @param u The parameter\n\t @brief Compute the first derivative on a 3D ellipse at a parameter\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <common/PointT.hpp>\n#include <math/CurveCalculation.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <geometry/MakeArcOfHyperbola2d.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <modeling/MakeEdge2d.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"case1: CurveCalculation::D1() ellipse3 [7/20] \", \"[math][CurveCalculation][P1][D1]\") {\n\tDirection3 initialDir(0.0, 0.0, 1.0); \n\tFrame3 defaultFrame3(Point3(0.0, 0.0, 0.0), initialDir); \n\tEllipse3 ellipse3(defaultFrame3,5.0,3.0 );\n\tMakeEdge edge= MakeEdge(ellipse3);\n\tbool bWriteresult = OCCTIO::OCCTTool::Write(edge, OUTPUT_PATH_PREFIX\"ellipse3CurveCalculation_case1.brep\",true,3);\n\tSECTION(\"u =0\") {\n\t\tVector3 vector3 = CurveCalculation::D1(0.0, ellipse3);\n\t\tCHECK(vector3.X() == Approx(0.0));\n\t\tCHECK(vector3.Y() == Approx(3.0));\n\t\tCHECK(vector3.Z() == Approx(0.0));\n\t}} "
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static void D1(double u, const Circle3& circle, Point3& p, Vector3& v1)\t @param[out] v1 The first derivative\n\t @param[out] p The point\n\t @param[in] circle The circle\n\t @param[in] u The parameter\n\t @brief Compute the point and the first derivative on a 3D circle at a parameter\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <common/PointT.hpp>\n#include <math/CurveCalculation.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <geometry/MakeArcOfHyperbola2d.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <modeling/MakeEdge2d.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"case1: CurveCalculation::D1() circle3[4/20] \", \"[math][CurveCalculation][P1][D1]\") {\n\tDirection3 initialDir(0.0, 0.0, 1.0);\n\tFrame3 defaultFrame3(Point3(1.0, 1.0, 0.0), initialDir);\n\tPoint3 p;\n\tVector3 v;\n\tdouble radius = 2.0; \n\tAMCAX::Circle3 circle3(defaultFrame3, radius);\n\tSECTION(\"u =0\") {\n\t\tCurveCalculation::D1(0.0, circle3,p,v);\n\t\tCHECK(p.X() == 3.0);\n\t\tCHECK(p.Y() == 1.0);\n\t\tCHECK(p.Z() == 0.0);\n\t\tCHECK(v.X() == Approx(0.0));\n\t\tCHECK(v.Y() == Approx(2.0));\n\t\tCHECK(v.Z() == Approx(0.0));\n\t}} "
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] AMCAX_API static Vector3 D1(double u, const Circle3& circle)\t @return The first derivative vector\n\t @param circle The circle\n\t @param u The parameter\n\t @brief Compute the first derivative on a 3D circle at a parameter\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <common/PointT.hpp>\n#include <math/CurveCalculation.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <geometry/MakeArcOfHyperbola2d.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <modeling/MakeEdge2d.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"case1: CurveCalculation::D1() circle3[3/20] \", \"[math][CurveCalculation][P1][D1]\") {\n\tDirection3 initialDir(0.0, 0.0, 1.0); \n\tFrame3 defaultFrame3(Point3(1.0, 0.0, 0.0), initialDir); \n\tdouble radius = 2.0; \n\tAMCAX::Circle3 circle3(defaultFrame3, radius);\n\tSECTION(\"u =0\") {\n\t\tVector3 vector3 = CurveCalculation::D1(0.0, circle3);\n\t\tCHECK(vector3.X() == Approx(0.0));\n\t\tCHECK(vector3.Y() == Approx(2.0));\n\t}} "
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static void D1(double u, const Line3& line, Point3& p, Vector3& v1)\t @param[out] v1 The first derivative\n\t @param[out] p The point\n\t @param[in] line The line\n\t @param[in] u The parameter\n\t @brief Compute the point and the first derivative on a 3D line at a parameter\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <common/PointT.hpp>\n#include <math/CurveCalculation.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <geometry/MakeArcOfHyperbola2d.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <modeling/MakeEdge2d.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"case1: CurveCalculation::D1() circle3[4/20] \", \"[math][CurveCalculation][P1][D1]\") {\n\tDirection3 initialDir(0.0, 0.0, 1.0);\n\tFrame3 defaultFrame3(Point3(1.0, 1.0, 0.0), initialDir);\n\tPoint3 p;\n\tVector3 v;\n\tdouble radius = 2.0; \n\tAMCAX::Circle3 circle3(defaultFrame3, radius);\n\tSECTION(\"u =0\") {\n\t\tCurveCalculation::D1(0.0, circle3,p,v);\n\t\tCHECK(p.X() == 3.0);\n\t\tCHECK(p.Y() == 1.0);\n\t\tCHECK(p.Z() == 0.0);\n\t\tCHECK(v.X() == Approx(0.0));\n\t\tCHECK(v.Y() == Approx(2.0));\n\t\tCHECK(v.Z() == Approx(0.0));\n\t}} "
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] AMCAX_API static Vector3 D1(double u, const Line3& line)\t @return The first derivative vector\n\t @param line The line\n\t @param u The parameter\n\t @brief Compute the first derivative on a 3D line at a parameter\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <common/PointT.hpp>\n#include <math/CurveCalculation.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <geometry/MakeArcOfHyperbola2d.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <modeling/MakeEdge2d.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"case1: CurveCalculation::D1() circle3[3/20] \", \"[math][CurveCalculation][P1][D1]\") {\n\tDirection3 initialDir(0.0, 0.0, 1.0); \n\tFrame3 defaultFrame3(Point3(1.0, 0.0, 0.0), initialDir); \n\tdouble radius = 2.0; \n\tAMCAX::Circle3 circle3(defaultFrame3, radius);\n\tSECTION(\"u =0\") {\n\t\tVector3 vector3 = CurveCalculation::D1(0.0, circle3);\n\t\tCHECK(vector3.X() == Approx(0.0));\n\t\tCHECK(vector3.Y() == Approx(2.0));\n\t}} "
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] AMCAX_API static Point2 D0(double u, const Hyperbola2& hyperbola)\t @return The resulting point\n\t @param hyperbola The hyperbola\n\t @param u The parameter\n\t @brief Compute the point on a 2D hyperbola at a parameter\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <common/PointT.hpp>\n#include <math/CurveCalculation.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <geometry/MakeArcOfHyperbola2d.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <modeling/MakeEdge2d.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"case1: CurveCalculation::D0() [5/10] \", \"[math][CurveCalculation][P1][D0]\") {\n\tAxis2 majorAxis;\n\tdouble major_radius = 5;\n\tdouble minor_radius = 3;\n\tHyperbola2 hyperbola(majorAxis, major_radius, minor_radius);\n\tPoint2 point2 = CurveCalculation::D0(0.0, hyperbola);\n\tCHECK(point2.X() == 5.0);\n\tCHECK(point2.Y() == 0.0);\n} "
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] AMCAX_API static Point2 D0(double u, const Parabola2& parabola)\t @return The resulting point\n\t @param parabola The parabola\n\t @param u The parameter\n\t @brief Compute the point on a 2D parabola at a parameter\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <common/PointT.hpp>\n#include <math/CurveCalculation.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <geometry/MakeArcOfHyperbola2d.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <modeling/MakeEdge2d.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"case1: CurveCalculation::D0() [9/10] \", \"[math][CurveCalculation][P1][D0]\") {\n\tAMCAX::Point2 P(0.0, 0.0);\n\tAMCAX::Direction2 D(1.0, 0.0);\n\tAMCAX::Axis2  axis2(P, D);\n\tdouble focal = 2.0;\n\tAMCAX::Parabola2 parabola2(axis2,focal );\n\tSECTION(\"u =0\") {  \n\t\tPoint2 point2 = CurveCalculation::D0(0.0, parabola2); \n\t\tCHECK(point2.X() == 0.0);\n\t\tCHECK(point2.Y() == 0.0);\n\t}} "
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] AMCAX_API static Point2 D0(double u, const Ellipse2& ellipse)\t @return The resulting point\n\t @param ellipse The ellipse\n\t @param u The parameter\n\t @brief Compute the point on a 2D ellipse at a parameter\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <common/PointT.hpp>\n#include <math/CurveCalculation.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <geometry/MakeArcOfHyperbola2d.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <modeling/MakeEdge2d.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"case1: CurveCalculation::D0() [3/10] \", \"[math][CurveCalculation][P1][D0]\") {\n\tAMCAX::Ellipse2 ellipse2(AMCAX::Axis2(AMCAX::Point2(0.0, 0.0), AMCAX::Direction2(1.0, 0.0)), 5.0, 3.0);\n\tPoint2 point2 = AMCAX::CurveCalculation::D0(M_PI_2, ellipse2);\n\tCHECK(point2.X() == Approx(0.0).margin(1e-12));\n\tCHECK(point2.Y() == 3.0);\n} "
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] AMCAX_API static Point2 D0(double u, const Circle2& circle)\t @return The resulting point\n\t @param circle The circle\n\t @param u The parameter\n\t @brief Compute the point on a 2D circle at a parameter\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <common/PointT.hpp>\n#include <math/CurveCalculation.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <geometry/MakeArcOfHyperbola2d.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <modeling/MakeEdge2d.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"case1: CurveCalculation::D0() [1/10] \", \"[math][CurveCalculation][P1][D0]\") {\n\tAMCAX::Point2 P(0.0, 0.0);\n\tAMCAX::Direction2 D(1.0, 0.0);\n\tAMCAX::Axis2  axis2(P, D);\n\tfloat radius = 2.0f;\n\tAMCAX::Circle2 circle2(axis2, radius, true);\n\tPoint2 point2 = AMCAX::CurveCalculation::D0(0.0, circle2);\n\tCHECK(point2.X() == 2.0);\n\tCHECK(point2.Y() == 0.0);\n} "
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] AMCAX_API static Point2 D0(double u, const Line2& line)\t @return The resulting point\n\t @param line The line\n\t @param u The parameter\n\t @brief Compute the point on a 2D line at a parameter\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <common/PointT.hpp>\n#include <math/CurveCalculation.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <geometry/MakeArcOfHyperbola2d.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <modeling/MakeEdge2d.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"case1: CurveCalculation::D0() [1/10] \", \"[math][CurveCalculation][P1][D0]\") {\n\tAMCAX::Point2 P(0.0, 0.0);\n\tAMCAX::Direction2 D(1.0, 0.0);\n\tAMCAX::Axis2  axis2(P, D);\n\tfloat radius = 2.0f;\n\tAMCAX::Circle2 circle2(axis2, radius, true);\n\tPoint2 point2 = AMCAX::CurveCalculation::D0(0.0, circle2);\n\tCHECK(point2.X() == 2.0);\n\tCHECK(point2.Y() == 0.0);\n} "
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] AMCAX_API static Point3 D0(double u, const Hyperbola3& hyperbola)\t @return The resulting point\n\t @param hyperbola The hyperbola\n\t @param u The parameter\n\t @brief Compute the point on a 3D hyperbola at a parameter\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <common/PointT.hpp>\n#include <math/CurveCalculation.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <geometry/MakeArcOfHyperbola2d.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <modeling/MakeEdge2d.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"case1: CurveCalculation::D0() [6/10] \", \"[math][CurveCalculation][P1][D0]\") {\n\tFrame3 fram3;\n\tdouble major_radius = 1000.0;\n\tdouble minor_radius = 10.0;\n\tHyperbola3 hyperbola(fram3, major_radius, minor_radius);\n\tPoint3 point3 = CurveCalculation::D0(0.0, hyperbola);\n\tCHECK(point3.X() == 1000.0);\n\tCHECK(point3.Y() == 0.0);\n\tCHECK(point3.Z() == 0.0);\n} "
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] AMCAX_API static Point3 D0(double u, const Parabola3& parabola)\t @return The resulting point\n\t @param parabola The parabola\n\t @param u The parameter\n\t @brief Compute the point on a 3D parabola at a parameter\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <common/PointT.hpp>\n#include <math/CurveCalculation.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <geometry/MakeArcOfHyperbola2d.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <modeling/MakeEdge2d.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"case1: CurveCalculation::D0() [10/10] \", \"[math][CurveCalculation][P1][D0]\") {\n\tPoint3 point3(0.0, 0.0, 0.0);\n\tDirection3 dir3(0.0, 0.0, 1.0);\n\tFrame3 fram3(point3, dir3);\n\tdouble focal = 2.0;\n\tParabola3 parabola3(fram3, focal);\n\tSECTION(\"u =0\") {\n\t\tPoint3 point3 = CurveCalculation::D0(0.0, parabola3);\n\t\tCHECK(point3.X() == 0.0);\n\t\tCHECK(point3.Y() == 0.0);\n\t\tCHECK(point3.Z() == 0.0);\n\t}} "
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] AMCAX_API static Point3 D0(double u, const Ellipse3& ellipse)\t @return The resulting point\n\t @param ellipse The ellipse\n\t @param u The parameter\n\t @brief Compute the point on a 3D ellipse at a parameter\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <common/PointT.hpp>\n#include <math/CurveCalculation.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <geometry/MakeArcOfHyperbola2d.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <modeling/MakeEdge2d.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"case1: CurveCalculation::D0() [4/10] \", \"[math][CurveCalculation][P1][D0]\") {\n\tFrame3 fram3 = Frame3(Point3(0.0, 0.0, 1.0), Direction3(0.0, 0.0, 1.0));\n\tAMCAX::Ellipse3 ellipse3(fram3, 5.0, 3.0);\n\tPoint3 point3 = AMCAX::CurveCalculation::D0(M_PI_2, ellipse3);\n\tCHECK(point3.X() == Approx(0.0).margin(1e-12));\n\tCHECK(point3.Y() == 3.0);\n\tCHECK(point3.Z() == 1.0);\n} "
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] AMCAX_API static Point3 D0(double u, const Circle3& circle)\t @return The resulting point\n\t @param circle The circle\n\t @param u The parameter\n\t @brief Compute the point on a 3D circle at a parameter\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <common/PointT.hpp>\n#include <math/CurveCalculation.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <geometry/MakeArcOfHyperbola2d.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <modeling/MakeEdge2d.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"case1: CurveCalculation::D0() [2/10] \", \"[math][CurveCalculation][P1][D0]\") {\n\tAMCAX::Circle3 circle3D;\n\tAMCAX::Point3  center3D(1.0, 1.0, 1.0);\n\tdouble radius3D = 5.0;\n\tdouble tol = 0.1;\n\tcircle3D.SetLocation(center3D);\n\tcircle3D.SetRadius(radius3D);\n\tPoint3 point3 = AMCAX::CurveCalculation::D0(M_PI_2, circle3D);\n\tCHECK(point3.X() == Approx(1.0));\n\tCHECK(point3.Y() == 6.0);\n\tCHECK(point3.Z() == 1.0);\n} "
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] AMCAX_API static Point3 D0(double u, const Line3& line)\t @return The resulting point\n\t @param line The line\n\t @param u The parameter\n\t @brief Compute the point on a 3D line at a parameter\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <common/PointT.hpp>\n#include <math/CurveCalculation.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <geometry/MakeArcOfHyperbola2d.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <modeling/MakeEdge2d.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"case1: CurveCalculation::D0() [6/10] \", \"[math][CurveCalculation][P1][D0]\") {\n\tFrame3 fram3;\n\tdouble major_radius = 1000.0;\n\tdouble minor_radius = 10.0;\n\tHyperbola3 hyperbola(fram3, major_radius, minor_radius);\n\tPoint3 point3 = CurveCalculation::D0(0.0, hyperbola);\n\tCHECK(point3.X() == 1000.0);\n\tCHECK(point3.Y() == 0.0);\n\tCHECK(point3.Z() == 0.0);\n} "
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static void AdjustPeriodic(double ufirst, double ulast, double precision, double& u1, double& u2)\t @param[in,out] u2 The second parameter to be adjust\n\t @param[in,out] u1 The first parameter to be adjust\n\t @param[in] precision The precision to check equality\n\t @param[in] ulast The upper bound of the period\n\t @param[in] ufirst The lower bound of the period\n\t          The parameter u2 is set in the range [u1, u1 + ulast - ufirst]\n\t @details The parameter u1 is set in the range [ufirst, ulast]\n\t @brief Adjust u1 and u2 to be in the period range.\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <common/PointT.hpp>\n#include <math/CurveCalculation.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"case1: CurveCalculation::AdjustPeriodic \", \"[math][CurveCalculation][P1]\") {\n\tdouble u1 = 0.0;\n\tdouble u2 = 2 * M_PI;\n\tdouble ufirst = 0.0;\n\tdouble ulast = 2 * M_PI; \n\tdouble precision = 0.001; \n\tAMCAX::CurveCalculation::AdjustPeriodic(ufirst, ulast, precision, u1, u2);\n\tCHECK(u1 == 0);\n\tCHECK(u2 == 2 * M_PI);\n}\n}\n,\n{\n "
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API Cylinder& Scale(const Point3& point, double scale)\t @return The reference to self\n\t @param scale The scale value\n\t @param point The scaling center point\n\t @brief Scale the cylinder by a point\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <common/FrameT.hpp>\n#include <modeling/MakeFace.hpp>\n#include <common/AxisT.hpp>\n#include <math/Cylinder.hpp>\n#include <common/VectorT.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <modeling/MakeCylinder.hpp>\n#include <iostream>\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case2:this is a case for Test Cylinder_Mirror&Mirrored/Rotate&Rotated/Scale&Scaled\", \"[math][Cylinder][P1]\")\n{\n\tPoint3 point_cy(6.0, 0.0, 0.0);\n\tDirection3 dir_cy(0.0, 0.0, 1.0);\n\tFrame3 frame_cy(point_cy, dir_cy);\n\tdouble radius_cy = 5.0;\n\tCylinder cylinder(frame_cy, radius_cy);\n\tSECTION(\"Scale\")\n\t{\n\t\tCylinder scale_cylinder = cylinder.Scale(point_cy, scale);\n\t\tCHECK(cylinder.Radius() == Approx(2.5));\n\t\tCHECK(cylinder.Location().X() == Approx(6.0));\n\t\tCHECK(cylinder.Location().Y() == Approx(0.0));\n\t\tCHECK(cylinder.Location().Z() == Approx(0.0));\n\t\tCHECK(cylinder.Axis().Direction().X() == 0.0);\n\t\tCHECK(cylinder.Axis().Direction().Y() == 0.0);\n\t\tCHECK(cylinder.Axis().Direction().Z() == 1.0);\n\t\tCHECK(scale_cylinder.Radius() == Approx(2.5));\n\t\tCHECK(scale_cylinder.Location().X() == Approx(6.0));\n\t\tCHECK(scale_cylinder.Location().Y() == Approx(0.0));\n\t\tCHECK(scale_cylinder.Location().Z() == Approx(0.0));\n\t\tCHECK(scale_cylinder.Axis().Direction().X() == 0.0);\n\t\tCHECK(scale_cylinder.Axis().Direction().Y() == 0.0);\n\t\tCHECK(scale_cylinder.Axis().Direction().Z() == 1.0);\n\t}\n\tscale = 2.0;} "
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API Cylinder(const Frame3& frame, double r)\t @param r The radius\n\t @param frame The local frame\n\t @brief Construct from a local frame and a radius\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <common/FrameT.hpp>\n#include <modeling/MakeFace.hpp>\n#include <common/AxisT.hpp>\n#include <math/Cylinder.hpp>\n#include <common/VectorT.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <modeling/MakeCylinder.hpp>\n#include <iostream>\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"bug1:Cylinder \", \"[math][Cylinder][fixbug]\")\n{\n\tPoint3 point_cy(6.0, 0.0, 0.0);\n\tDirection3 dir_cy(0.0, 0.0, 1.0);\n\tFrame3 frame_cy(point_cy, dir_cy);\n\tdouble radius_cy = 5.0;\n\tCylinder cylinder(frame_cy, radius_cy);\n\tdouble r = 0.0;\n\tSECTION(\"SetRadius1\")\n\t{\n\t\tcylinder.SetRadius(r);\n\t\tCHECK(cylinder.Radius() == Approx(0.0));\n\t}\n\tr = -1.0;\n\tstring str1;\n\tstring str2 = \"[_DomainError]\";} "
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "Cylinder()\t @brief Default constructor\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <common/FrameT.hpp>\n#include <modeling/MakeFace.hpp>\n#include <common/AxisT.hpp>\n#include <math/Cylinder.hpp>\n#include <common/VectorT.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <modeling/MakeCylinder.hpp>\n#include <iostream>\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Test Cylinder\", \"[math][Cylinder][P1]\")\n{\n\tFrame3 frame;\n\tdouble radius = 5.0;\n\tCylinder cylinder(frame, radius);\n\tSECTION(\"Cylinder\")\n\t{\n\t\tCHECK(cylinder.Radius() == Approx(radius));\n\t\tCHECK(cylinder.Location().X() == Approx(0.0));\n\t\tCHECK(cylinder.Location().Y() == Approx(0.0));\n\t\tCHECK(cylinder.Location().Z() == Approx(0.0));\n\t\tCylinder cylinder1;\n\t\tCHECK(cylinder1.Location().X() == Approx(0.0));\n\t\tCHECK(cylinder1.Location().Y() == Approx(0.0));\n\t\tCHECK(cylinder1.Location().Z() == Approx(0.0));\n\t}} "
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "EllipseS& Transform(const TransformationT<double, DIM>& tr)\t @return The reference to self\n\t @param tr The transformation\n\t @brief Transform the ellipse\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <common/FrameT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <math/EllipseT.hpp>\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case3:this is a case for Test-Ellipse2-Rotate\", \"[math][Ellipse2][P1]\")\n{\n\tPoint2 point1(6.0, 0.0);\n\tDirection2 dir1(0.0, 1.0);\n\tAxis2 axis1(point1, dir1);\n\tdouble major = 5.0;\n\tdouble minor = 4.0;\n\tbool isRight = true;\n\tEllipse2 ellipse(axis1, major, minor, isRight);\n\tdouble angle = M_PI_2;\n\tPoint2 point_temp(0.0, 0.0);\n\tSECTION(\"Transform\")\n\t{\n\t\tEllipse2 Transfor_ellipse = ellipse.Transform(tr);\n\t\tCHECK(ellipse.Location().X() == Approx(5.0));\n\t\tCHECK(ellipse.Location().Y() == Approx(-2.0));\n\t\tCHECK(ellipse.MajorRadius() == Approx(5.0));\n\t\tCHECK(ellipse.MinorRadius() == Approx(4.0));\n\t\tCHECK(Transfor_ellipse.Location().X() == Approx(5.0));\n\t\tCHECK(Transfor_ellipse.Location().Y() == Approx(-2.0));\n\t\tCHECK(Transfor_ellipse.MajorRadius() == Approx(5.0));\n\t\tCHECK(Transfor_ellipse.MinorRadius() == Approx(4.0));\n\t}}\n}\n,\n{\n "
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "EllipseS& Scale(const PointT<double, DIM>& point, double scale)\t @return The reference to self\n\t @param scale The scale value\n\t @param point The scaling center point\n\t @brief Scale the ellipse by a center point\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <common/FrameT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <math/EllipseT.hpp>\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case3:this is a case for Test-Ellipse2-Rotate\", \"[math][Ellipse2][P1]\")\n{\n\tPoint2 point1(6.0, 0.0);\n\tDirection2 dir1(0.0, 1.0);\n\tAxis2 axis1(point1, dir1);\n\tdouble major = 5.0;\n\tdouble minor = 4.0;\n\tbool isRight = true;\n\tEllipse2 ellipse(axis1, major, minor, isRight);\n\tdouble angle = M_PI_2;\n\tPoint2 point_temp(0.0, 0.0);\n\tSECTION(\"Scale\")\n\t{\n\t\tEllipse2 scale_ellipse = ellipse.Scale(point, scale);\n\t\tCHECK(ellipse.Location().X() == Approx(2.5));\n\t\tCHECK(ellipse.Location().Y() == Approx(-1.0));\n\t\tCHECK(ellipse.MajorRadius() == Approx(2.5));\n\t\tCHECK(ellipse.MinorRadius() == Approx(2.0));\n\t\tCHECK(scale_ellipse.Location().X() == Approx(2.5));\n\t\tCHECK(scale_ellipse.Location().Y() == Approx(-1.0));\n\t\tCHECK(scale_ellipse.MajorRadius() == Approx(2.5));\n\t\tCHECK(scale_ellipse.MinorRadius() == Approx(2.0));\n\t}\n\tscale = -2.0;} "
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] double Area()\t @return The area of the ellipse\n\t @brief Get the area of the ellipse\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <common/FrameT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <math/EllipseT.hpp>\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Test Ellipse2\", \"[math][Ellipse2][P1]\")\n{\n\tAxis2 axis;\n\tdouble major = 5.0;\n\tdouble minor = 4.0;\n\tbool isRight = true;\n\tEllipse2 ellipse(axis, major, minor, isRight);\n\tSECTION(\"Area\")\n\t{\n\t\tdouble S = ellipse.Area();\n\t\tCHECK(S == Approx(M_PI * major * minor));\n\t}} "
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] double Area()\t @return The area of the ellipse\n\t @brief Get the area of the ellipse\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <common/FrameT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <math/EllipseT.hpp>\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Test Ellipse3\", \"[math][Ellipse3][P1]\")\n{\n\tFrame3 frame;\n\tdouble major = 5.0;\n\tdouble minor = 4.0;\n\tEllipse3 ellipse(frame, major, minor);\n\tSECTION(\"Area\")\n\t{\n\t\tdouble S = ellipse.Area();\n\t\tCHECK(S == Approx(M_PI * major * minor));\n\t}}\n}\n,\n{\n "
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "HyperbolaS& Scale(const PointT<double, DIM>& point, double scale)\t @return The reference to self\n\t @param scale The scale value\n\t @param point The scaling center point\n\t @brief Scale the hyperbola by a center point\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <modeling/MakeFace.hpp>\n#include <common/AxisT.hpp>\n#include <math/HyperbolaT.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <common/VectorT.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <topology/TopoEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <common/TransformationT.hpp>\n#include <iostream>\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Hyperbola2\", \"[math][Hyperbola2][p1]\") {\n\tPoint2 point2_Hy(0.0, 0.0);\t\n\tDirection2 dir2_Hy(1.0, 0.0);\n\tAxis2 major2_Axis(point2_Hy, dir2_Hy);\n\tdouble major2 = 3.0, minor2 = 4.0;\n\tHyperbola2 hyperbola2d_ax(major2_Axis, major2, minor2, true);\n\tPoint2 point2_fr(1.0, 1.0);\n\tDirection2 dir2_fr(0.0, 1.0);\n\tFrame2 frame2(point2_fr, dir2_fr);\n\tHyperbola2 hyperbola2d_fr(frame2, major2, minor2);\n\tSECTION(\"Scale()\") {\t\t\n\t\tPoint2 point2(1.0, 1.0);\n\t\thyperbola2d_ax.Scale(point2, 0.5);\n\t\tCHECK(hyperbola2d_ax.Location().X() == Approx(0.5));\n\t\tCHECK(hyperbola2d_ax.Location().Y() == Approx(0.5));\n\t\tPoint3 point3(2.0, 0.5, 0.0);\n\t\tMakeEdge2d edge1(hyperbola2d_ax);\n\t\tCHECK(BRepClassificationTools::IsPointInOnEdge(edge1, point3, 0.001) == true);\n\t}}\n}\n,\n{\n "
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] HyperbolaS ConjugateBranch2()\t @return The negative conjugate hyperbola\n\t @brief Get the conjugate hyperbola on the negative side of the minor axis\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <modeling/MakeFace.hpp>\n#include <common/AxisT.hpp>\n#include <math/HyperbolaT.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <common/VectorT.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <topology/TopoEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <common/TransformationT.hpp>\n#include <iostream>\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Hyperbola2\", \"[math][Hyperbola2][p1]\") {\n\tPoint2 point2_Hy(0.0, 0.0);\t\n\tDirection2 dir2_Hy(1.0, 0.0);\n\tAxis2 major2_Axis(point2_Hy, dir2_Hy);\n\tdouble major2 = 3.0, minor2 = 4.0;\n\tHyperbola2 hyperbola2d_ax(major2_Axis, major2, minor2, true);\n\tPoint2 point2_fr(1.0, 1.0);\n\tDirection2 dir2_fr(0.0, 1.0);\n\tFrame2 frame2(point2_fr, dir2_fr);\n\tHyperbola2 hyperbola2d_fr(frame2, major2, minor2);\n\tSECTION(\"ConjugateBranch2()\") {\n\t\tPoint3 point1(0.0, -4.0, 0.0);\n\t\tPoint3 point2(9.0 / 4.0, -5.0, 0.0);\n\t\tHyperbola2 hyperbola2d_con = hyperbola2d_ax.ConjugateBranch2();\n\t\tMakeEdge2d edge1(hyperbola2d_con);\n\t\tCHECK(BRepClassificationTools::IsPointInOnEdge(edge1, point1, 0.001) == true);\n\t\tCHECK(BRepClassificationTools::IsPointInOnEdge(edge1, point2, 0.001) == true);\n\t\tdouble major2d_con = hyperbola2d_con.MajorRadius();\n\t\tdouble minor2d_con = hyperbola2d_con.MinorRadius();\n\t\tCHECK(major2d_con == Approx(4.0));\n\t\tCHECK(minor2d_con == Approx(3.0));\n\t}} "
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] AxisT<double, DIM> Asymptote2()\t @return The negative asymptote\n\t @brief Get the asymptote of the hyperbola with negative slope\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <modeling/MakeFace.hpp>\n#include <common/AxisT.hpp>\n#include <math/HyperbolaT.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <common/VectorT.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <topology/TopoEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <common/TransformationT.hpp>\n#include <iostream>\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Hyperbola2\", \"[math][Hyperbola2][p1]\") {\n\tPoint2 point2_Hy(0.0, 0.0);\t\n\tDirection2 dir2_Hy(1.0, 0.0);\n\tAxis2 major2_Axis(point2_Hy, dir2_Hy);\n\tdouble major2 = 3.0, minor2 = 4.0;\n\tHyperbola2 hyperbola2d_ax(major2_Axis, major2, minor2, true);\n\tPoint2 point2_fr(1.0, 1.0);\n\tDirection2 dir2_fr(0.0, 1.0);\n\tFrame2 frame2(point2_fr, dir2_fr);\n\tHyperbola2 hyperbola2d_fr(frame2, major2, minor2);\n\tSECTION(\"Asymptote2()\") {\t\n\t\tAxis2 axis2d_asy = hyperbola2d_ax.Asymptote2();\n\t\tCHECK(axis2d_asy.Direction().X() / axis2d_asy.Direction().Y() == Approx(-3.0 / 4.0));\n\t\tPoint3 point1(0.0, 0.0, 0.0);\n\t\tLine2 line2d_asy(axis2d_asy);\n\t\tMakeEdge2d edge1(line2d_asy);\n\t\tCHECK(BRepClassificationTools::IsPointInOnEdge(edge1, point1, 0.001) == true);\n\t}} "
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] AxisT<double, DIM> Asymptote1()\t @return The positive asymptote\n\t @brief Get the asymptote of the hyperbola with positive slope\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <modeling/MakeFace.hpp>\n#include <common/AxisT.hpp>\n#include <math/HyperbolaT.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <common/VectorT.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <topology/TopoEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <common/TransformationT.hpp>\n#include <iostream>\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Hyperbola2\", \"[math][Hyperbola2][p1]\") {\n\tPoint2 point2_Hy(0.0, 0.0);\t\n\tDirection2 dir2_Hy(1.0, 0.0);\n\tAxis2 major2_Axis(point2_Hy, dir2_Hy);\n\tdouble major2 = 3.0, minor2 = 4.0;\n\tHyperbola2 hyperbola2d_ax(major2_Axis, major2, minor2, true);\n\tPoint2 point2_fr(1.0, 1.0);\n\tDirection2 dir2_fr(0.0, 1.0);\n\tFrame2 frame2(point2_fr, dir2_fr);\n\tHyperbola2 hyperbola2d_fr(frame2, major2, minor2);\n\tSECTION(\"Asymptote1()\") {\n\t\tAxis2 axis2d_asy = hyperbola2d_ax.Asymptote1();\n\t\tCHECK(axis2d_asy.Direction().X()/ axis2d_asy.Direction().Y() == Approx(3.0/4.0));\n\t\tPoint3 point1(0.0, 0.0, 0.0);\n\t\tLine2 line2d_asy(axis2d_asy);\n\t\tMakeEdge2d edge1(line2d_asy);\n\t\tCHECK(BRepClassificationTools::IsPointInOnEdge(edge1, point1, 0.001) == true);\n\t}} "
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] double MinorRadius()\t @return The minor radius\n\t @brief Get the minor radius\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <modeling/MakeFace.hpp>\n#include <common/AxisT.hpp>\n#include <math/HyperbolaT.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <common/VectorT.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <topology/TopoEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <common/TransformationT.hpp>\n#include <iostream>\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Hyperbola2\", \"[math][Hyperbola2][p1]\") {\n\tPoint2 point2_Hy(0.0, 0.0);\t\n\tDirection2 dir2_Hy(1.0, 0.0);\n\tAxis2 major2_Axis(point2_Hy, dir2_Hy);\n\tdouble major2 = 3.0, minor2 = 4.0;\n\tHyperbola2 hyperbola2d_ax(major2_Axis, major2, minor2, true);\n\tPoint2 point2_fr(1.0, 1.0);\n\tDirection2 dir2_fr(0.0, 1.0);\n\tFrame2 frame2(point2_fr, dir2_fr);\n\tHyperbola2 hyperbola2d_fr(frame2, major2, minor2);\n\tSECTION(\"ConjugateBranch1()\") {\n\t\tPoint3 point1(0.0, 4.0, 0.0);\n\t\tPoint3 point2(9.0 / 4.0, 5.0, 0.0);\n\t\tHyperbola2 hyperbola2d_con = hyperbola2d_ax.ConjugateBranch1();\n\t\tMakeEdge2d edge1(hyperbola2d_con);\n\t\tCHECK(BRepClassificationTools::IsPointInOnEdge(edge1, point1, 0.001) == true);\n\t\tCHECK(BRepClassificationTools::IsPointInOnEdge(edge1, point2, 0.001) == true);\n\t\tdouble major2d_con = hyperbola2d_con.MajorRadius();\n\t\tdouble minor2d_con = hyperbola2d_con.MinorRadius();\n\t\tCHECK( major2d_con== Approx(4.0));\n\t\tCHECK(minor2d_con == Approx(3.0));\n\t}} "
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] double MajorRadius()\t @return The major radius\n\t @brief Get the major radius\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <modeling/MakeFace.hpp>\n#include <common/AxisT.hpp>\n#include <math/HyperbolaT.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <common/VectorT.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <topology/TopoEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <common/TransformationT.hpp>\n#include <iostream>\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Hyperbola2\", \"[math][Hyperbola2][p1]\") {\n\tPoint2 point2_Hy(0.0, 0.0);\t\n\tDirection2 dir2_Hy(1.0, 0.0);\n\tAxis2 major2_Axis(point2_Hy, dir2_Hy);\n\tdouble major2 = 3.0, minor2 = 4.0;\n\tHyperbola2 hyperbola2d_ax(major2_Axis, major2, minor2, true);\n\tPoint2 point2_fr(1.0, 1.0);\n\tDirection2 dir2_fr(0.0, 1.0);\n\tFrame2 frame2(point2_fr, dir2_fr);\n\tHyperbola2 hyperbola2d_fr(frame2, major2, minor2);\n\tSECTION(\"Default()\") {\n\t\tHyperbola2 hyperbola2d_de;\t\n\t\tCHECK(hyperbola2d_de.Location().X() == Approx(0.0));\n\t\tCHECK(hyperbola2d_de.Location().Y() == Approx(0.0));\n\t\thyperbola2d_de.SetMajorRadius(3.0);\n\t\thyperbola2d_de.SetMinorRadius(4.0);\n\t\tCHECK(hyperbola2d_de.MajorRadius() == Approx(3.0));\n\t\tCHECK(hyperbola2d_de.MinorRadius() == Approx(4.0));\n\t\tCHECK(hyperbola2d_de.Focal() == Approx(10.0));\n\t\tCHECK(hyperbola2d_de.Focus1().X() == Approx(5.0));\n\t\tCHECK(hyperbola2d_de.Focus1().Y() == Approx(0.0));\n\t}} "
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] PointT<double, DIM> Focus1()\t @return The positive focus\n\t @brief Get the focus on the positive side of the major axis\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <modeling/MakeFace.hpp>\n#include <common/AxisT.hpp>\n#include <math/HyperbolaT.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <common/VectorT.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <topology/TopoEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <common/TransformationT.hpp>\n#include <iostream>\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Hyperbola2\", \"[math][Hyperbola2][p1]\") {\n\tPoint2 point2_Hy(0.0, 0.0);\t\n\tDirection2 dir2_Hy(1.0, 0.0);\n\tAxis2 major2_Axis(point2_Hy, dir2_Hy);\n\tdouble major2 = 3.0, minor2 = 4.0;\n\tHyperbola2 hyperbola2d_ax(major2_Axis, major2, minor2, true);\n\tPoint2 point2_fr(1.0, 1.0);\n\tDirection2 dir2_fr(0.0, 1.0);\n\tFrame2 frame2(point2_fr, dir2_fr);\n\tHyperbola2 hyperbola2d_fr(frame2, major2, minor2);\n\tSECTION(\"Default()\") {\n\t\tHyperbola2 hyperbola2d_de;\t\n\t\tCHECK(hyperbola2d_de.Location().X() == Approx(0.0));\n\t\tCHECK(hyperbola2d_de.Location().Y() == Approx(0.0));\n\t\thyperbola2d_de.SetMajorRadius(3.0);\n\t\thyperbola2d_de.SetMinorRadius(4.0);\n\t\tCHECK(hyperbola2d_de.MajorRadius() == Approx(3.0));\n\t\tCHECK(hyperbola2d_de.MinorRadius() == Approx(4.0));\n\t\tCHECK(hyperbola2d_de.Focal() == Approx(10.0));\n\t\tCHECK(hyperbola2d_de.Focus1().X() == Approx(5.0));\n\t\tCHECK(hyperbola2d_de.Focus1().Y() == Approx(0.0));\n\t}} "
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "void SetMinorRadius(double r)\t @param r The new minor radius\n\t @brief Set the minor radius\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <modeling/MakeFace.hpp>\n#include <common/AxisT.hpp>\n#include <math/HyperbolaT.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <common/VectorT.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <topology/TopoEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <common/TransformationT.hpp>\n#include <iostream>\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Hyperbola2\", \"[math][Hyperbola2][p1]\") {\n\tPoint2 point2_Hy(0.0, 0.0);\t\n\tDirection2 dir2_Hy(1.0, 0.0);\n\tAxis2 major2_Axis(point2_Hy, dir2_Hy);\n\tdouble major2 = 3.0, minor2 = 4.0;\n\tHyperbola2 hyperbola2d_ax(major2_Axis, major2, minor2, true);\n\tPoint2 point2_fr(1.0, 1.0);\n\tDirection2 dir2_fr(0.0, 1.0);\n\tFrame2 frame2(point2_fr, dir2_fr);\n\tHyperbola2 hyperbola2d_fr(frame2, major2, minor2);\n\tSECTION(\"SetMinorRadius()\") {\n\t\thyperbola2d_ax.SetMinorRadius(3.0);\n\t\tCHECK(hyperbola2d_ax.Location().X() == Approx(0.0));\n\t\tCHECK(hyperbola2d_ax.Location().Y() == Approx(0.0));\n\t\tCHECK(hyperbola2d_ax.MajorRadius() == Approx(3.0));\n\t\tCHECK(hyperbola2d_ax.MinorRadius() == Approx(3.0));\n\t\tPoint3 point1(3.0, 0.0, 0.0);\n\t\tMakeEdge2d edge1(hyperbola2d_ax);\n\t\tCHECK(BRepClassificationTools::IsPointInOnEdge(edge1, point1, 0.001) == true);\n\t}} "
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "void SetMajorRadius(double r)\t @param r The new major radius\n\t @brief Set the major radius\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <modeling/MakeFace.hpp>\n#include <common/AxisT.hpp>\n#include <math/HyperbolaT.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <common/VectorT.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <topology/TopoEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <common/TransformationT.hpp>\n#include <iostream>\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Hyperbola2\", \"[math][Hyperbola2][p1]\") {\n\tPoint2 point2_Hy(0.0, 0.0);\t\n\tDirection2 dir2_Hy(1.0, 0.0);\n\tAxis2 major2_Axis(point2_Hy, dir2_Hy);\n\tdouble major2 = 3.0, minor2 = 4.0;\n\tHyperbola2 hyperbola2d_ax(major2_Axis, major2, minor2, true);\n\tPoint2 point2_fr(1.0, 1.0);\n\tDirection2 dir2_fr(0.0, 1.0);\n\tFrame2 frame2(point2_fr, dir2_fr);\n\tHyperbola2 hyperbola2d_fr(frame2, major2, minor2);\n\tSECTION(\"Default()\") {\n\t\tHyperbola2 hyperbola2d_de;\t\n\t\tCHECK(hyperbola2d_de.Location().X() == Approx(0.0));\n\t\tCHECK(hyperbola2d_de.Location().Y() == Approx(0.0));\n\t\thyperbola2d_de.SetMajorRadius(3.0);\n\t\thyperbola2d_de.SetMinorRadius(4.0);\n\t\tCHECK(hyperbola2d_de.MajorRadius() == Approx(3.0));\n\t\tCHECK(hyperbola2d_de.MinorRadius() == Approx(4.0));\n\t\tCHECK(hyperbola2d_de.Focal() == Approx(10.0));\n\t\tCHECK(hyperbola2d_de.Focus1().X() == Approx(5.0));\n\t\tCHECK(hyperbola2d_de.Focus1().Y() == Approx(0.0));\n\t}} "
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] AMCAX_API static Vector2 D1(double u, const Circle2& circle)\t @return The first derivative vector\n\t @param circle The circle\n\t @param u The parameter\n\t @brief Compute the first derivative on a 2D circle at a parameter\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <common/PointT.hpp>\n#include <math/CurveCalculation.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"case1: CurveCalculation::CircleD1 1/4 \", \"[math][CurveCalculation][P1][CircleD1]\") {\n\tDirection2 initialDir(1.0, 0.0); \n\tFrame2 defaultFrame2(Point2(1.0, 1.0), initialDir); \n\tdouble radius = 2.0; \n\tVector2 tangentAt0 = AMCAX::CurveCalculation::CircleD1(0.0, defaultFrame2, radius);\n\tVector2 tangentAt90Deg = AMCAX::CurveCalculation::CircleD1(M_PI_2, defaultFrame2, radius);\n\tVector2 tangentAt180Deg = AMCAX::CurveCalculation::CircleD1(M_PI, defaultFrame2, radius);\n\tVector2 tangentAt270Deg = AMCAX::CurveCalculation::CircleD1(3 * M_PI_2, defaultFrame2, radius);\n\tVector2 tangentAt360Deg = AMCAX::CurveCalculation::CircleD1(2 * M_PI, defaultFrame2, radius);\n\tCHECK(tangentAt0.X() == Approx(-0.0));\n\tCHECK(tangentAt0.Y() == Approx(2.0));\n\tCHECK(tangentAt90Deg.X() == Approx(-2.0));\n\tCHECK(tangentAt90Deg.Y() == Approx(0.0).margin(1e-14));\n\tCHECK(tangentAt180Deg.X() == Approx(-0.0).margin(1e-14));\n\tCHECK(tangentAt180Deg.Y() == Approx(-2.0));\n\tCHECK(tangentAt270Deg.X() == Approx(2.0));\n\tCHECK(tangentAt270Deg.Y() == Approx(-0.0).margin(1e-14));\n\tCHECK(tangentAt360Deg.X() == Approx(0.0).margin(1e-14));\n\tCHECK(tangentAt360Deg.Y() == Approx(2.0));\n\tstd::cout << \"Tangent at 0 deg: \" << tangentAt0 << std::endl;\n\tstd::cout << \"Tangent at 90 deg: \" << tangentAt90Deg << std::endl;\n\tstd::cout << \"Tangent at 180 deg: \" << tangentAt180Deg << std::endl;\n\tstd::cout << \"Tangent at 270 deg: \" << tangentAt270Deg << std::endl;\n\tstd::cout << \"Tangent at 360 deg: \" << tangentAt360Deg << std::endl;\n}\n}\n,\n{\n "
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "HyperbolaS& Scale(const PointT<double, DIM>& point, double scale)\t @return The reference to self\n\t @param scale The scale value\n\t @param point The scaling center point\n\t @brief Scale the hyperbola by a center point\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <modeling/MakeFace.hpp>\n#include <common/AxisT.hpp>\n#include <math/HyperbolaT.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <common/VectorT.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <topology/TopoEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <iostream>\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Hyperbola3\", \"[math][Hyperbola3][p1]\") {\n\tPoint3 point3_fr(0.0, 0.0, 1.0);\n\tDirection3 dir3_fr(0.0, 0.0, 1.0);\n\tFrame3 frame3(point3_fr, dir3_fr);\n\tdouble major3 = 3.0, minor3 = 4.0;\n\tHyperbola3 hyperbola3d_fr(frame3, major3, minor3);\n\tSECTION(\"Scale()\") {\t\t\n\t\tPoint3 point1(0.0, 0.0, 1.0);\n\t\thyperbola3d_fr.Scale(point1, 0.5);\n\t\tCHECK(hyperbola3d_fr.Location().X() == Approx(0.0));\n\t\tCHECK(hyperbola3d_fr.Location().Y() == Approx(0.0));\n\t\tCHECK(hyperbola3d_fr.Location().Z() == Approx(1.0));\n\t\tPoint3 point2(1.5, 0.0, 1.0);\n\t\tMakeEdge edge1(hyperbola3d_fr);\n\t\tCHECK(BRepClassificationTools::IsPointInOnEdge(edge1, point2, 0.001) == true);\n\t}} "
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] HyperbolaS ConjugateBranch2()\t @return The negative conjugate hyperbola\n\t @brief Get the conjugate hyperbola on the negative side of the minor axis\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <modeling/MakeFace.hpp>\n#include <common/AxisT.hpp>\n#include <math/HyperbolaT.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <common/VectorT.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <topology/TopoEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <iostream>\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Hyperbola3\", \"[math][Hyperbola3][p1]\") {\n\tPoint3 point3_fr(0.0, 0.0, 1.0);\n\tDirection3 dir3_fr(0.0, 0.0, 1.0);\n\tFrame3 frame3(point3_fr, dir3_fr);\n\tdouble major3 = 3.0, minor3 = 4.0;\n\tHyperbola3 hyperbola3d_fr(frame3, major3, minor3);\n\tSECTION(\"ConjugateBranch2()\") {\t\t\n\t\tHyperbola3 hyperbola3d_con = hyperbola3d_fr.ConjugateBranch2();\n\t\tCHECK(hyperbola3d_con.Location().X() == Approx(0.0));\n\t\tCHECK(hyperbola3d_con.Location().Y() == Approx(0.0));\n\t\tCHECK(hyperbola3d_con.Location().Z() == Approx(1.0));\n\t\tPoint3 point1(0.0, -4.0, 1.0);\n\t\tPoint3 point2(9.0 / 4.0, -5.0, 1.0);\n\t\tMakeEdge edge2(hyperbola3d_con);\n\t\tCHECK(BRepClassificationTools::IsPointInOnEdge(edge2, point1, 0.001) == true);\n\t\tCHECK(BRepClassificationTools::IsPointInOnEdge(edge2, point2, 0.001) == true);\n\t\tdouble major3d_con = hyperbola3d_con.MajorRadius();\n\t\tdouble minor3d_con = hyperbola3d_con.MinorRadius();\n\t\tCHECK(major3d_con == Approx(4.0));\n\t\tCHECK(minor3d_con == Approx(3.0));\n\t}} "
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] HyperbolaS ConjugateBranch1()\t @return The positive conjugate hyperbola\n\t @brief Get the conjugate hyperbola on the positive side of the minor axis\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <modeling/MakeFace.hpp>\n#include <common/AxisT.hpp>\n#include <math/HyperbolaT.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <common/VectorT.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <topology/TopoEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <iostream>\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Hyperbola3\", \"[math][Hyperbola3][p1]\") {\n\tPoint3 point3_fr(0.0, 0.0, 1.0);\n\tDirection3 dir3_fr(0.0, 0.0, 1.0);\n\tFrame3 frame3(point3_fr, dir3_fr);\n\tdouble major3 = 3.0, minor3 = 4.0;\n\tHyperbola3 hyperbola3d_fr(frame3, major3, minor3);\n\tSECTION(\"ConjugateBranch1()\") {\n\t\tHyperbola3 hyperbola3d_con = hyperbola3d_fr.ConjugateBranch1();\n\t\tCHECK(hyperbola3d_con.Location().X() == Approx(0.0));\n\t\tCHECK(hyperbola3d_con.Location().Y() == Approx(0.0));\n\t\tCHECK(hyperbola3d_con.Location().Z() == Approx(1.0));\n\t\tPoint3 point1(0.0, 4.0, 1.0);\n\t\tPoint3 point2(9.0 / 4.0, 5.0, 1.0);\n\t\tMakeEdge edge1(hyperbola3d_con);\n\t\tCHECK(BRepClassificationTools::IsPointInOnEdge(edge1, point1, 0.001) == true);\n\t\tCHECK(BRepClassificationTools::IsPointInOnEdge(edge1, point2, 0.001) == true);\n\t\tdouble major3d_con = hyperbola3d_con.MajorRadius();\n\t\tdouble minor3d_con = hyperbola3d_con.MinorRadius();\n\t\tCHECK(major3d_con == Approx(4.0));\n\t\tCHECK(minor3d_con == Approx(3.0));\n\t}} "
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] AxisT<double, DIM> Asymptote2()\t @return The negative asymptote\n\t @brief Get the asymptote of the hyperbola with negative slope\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <modeling/MakeFace.hpp>\n#include <common/AxisT.hpp>\n#include <math/HyperbolaT.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <common/VectorT.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <topology/TopoEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <iostream>\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Hyperbola3\", \"[math][Hyperbola3][p1]\") {\n\tPoint3 point3_fr(0.0, 0.0, 1.0);\n\tDirection3 dir3_fr(0.0, 0.0, 1.0);\n\tFrame3 frame3(point3_fr, dir3_fr);\n\tdouble major3 = 3.0, minor3 = 4.0;\n\tHyperbola3 hyperbola3d_fr(frame3, major3, minor3);\n\tSECTION(\"Asymptote2()\") {\n\t\tAxis3 axis3d_asy = hyperbola3d_fr.Asymptote2();\n\t\tCHECK(axis3d_asy.Direction().X() / axis3d_asy.Direction().Y() == Approx(-3.0 / 4.0));\n\t\tCHECK(axis3d_asy.Direction().Z() == Approx(0.0));\n\t\tPoint3 point1(0.0, 0.0, 1.0);\n\t\tLine3 line3d_asy(axis3d_asy);\n\t\tMakeEdge edge1(line3d_asy);\n\t\tCHECK(BRepClassificationTools::IsPointInOnEdge(edge1, point1, 0.001) == true);\n\t}} "
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] AxisT<double, DIM> Asymptote1()\t @return The positive asymptote\n\t @brief Get the asymptote of the hyperbola with positive slope\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <modeling/MakeFace.hpp>\n#include <common/AxisT.hpp>\n#include <math/HyperbolaT.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <common/VectorT.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <topology/TopoEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <iostream>\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Hyperbola3\", \"[math][Hyperbola3][p1]\") {\n\tPoint3 point3_fr(0.0, 0.0, 1.0);\n\tDirection3 dir3_fr(0.0, 0.0, 1.0);\n\tFrame3 frame3(point3_fr, dir3_fr);\n\tdouble major3 = 3.0, minor3 = 4.0;\n\tHyperbola3 hyperbola3d_fr(frame3, major3, minor3);\n\tSECTION(\"Asymptote1()\") {\n\t\tAxis3 axis3d_asy = hyperbola3d_fr.Asymptote1();\n\t\tCHECK(axis3d_asy.Direction().X() / axis3d_asy.Direction().Y() == Approx(3.0 / 4.0));\n\t\tCHECK(axis3d_asy.Direction().Z() == Approx(0.0));\n\t\tPoint3 point1(0.0, 0.0, 1.0);\n\t\tLine3 line3d_asy(axis3d_asy);\n\t\tMakeEdge edge1(line3d_asy);\n\t\tCHECK(BRepClassificationTools::IsPointInOnEdge(edge1, point1, 0.001) == true);\n\t}} "
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] double MinorRadius()\t @return The minor radius\n\t @brief Get the minor radius\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <modeling/MakeFace.hpp>\n#include <common/AxisT.hpp>\n#include <math/HyperbolaT.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <common/VectorT.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <topology/TopoEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <iostream>\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Hyperbola3\", \"[math][Hyperbola3][p1]\") {\n\tPoint3 point3_fr(0.0, 0.0, 1.0);\n\tDirection3 dir3_fr(0.0, 0.0, 1.0);\n\tFrame3 frame3(point3_fr, dir3_fr);\n\tdouble major3 = 3.0, minor3 = 4.0;\n\tHyperbola3 hyperbola3d_fr(frame3, major3, minor3);\n\tSECTION(\"MinorRadius()\") {\n\t\tCHECK(hyperbola3d_fr.MinorRadius() == Approx(4.0));\n\t}} "
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] double MajorRadius()\t @return The major radius\n\t @brief Get the major radius\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <modeling/MakeFace.hpp>\n#include <common/AxisT.hpp>\n#include <math/HyperbolaT.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <common/VectorT.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <topology/TopoEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <iostream>\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Hyperbola3\", \"[math][Hyperbola3][p1]\") {\n\tPoint3 point3_fr(0.0, 0.0, 1.0);\n\tDirection3 dir3_fr(0.0, 0.0, 1.0);\n\tFrame3 frame3(point3_fr, dir3_fr);\n\tdouble major3 = 3.0, minor3 = 4.0;\n\tHyperbola3 hyperbola3d_fr(frame3, major3, minor3);\n\tSECTION(\"ConjugateBranch1()\") {\n\t\tHyperbola3 hyperbola3d_con = hyperbola3d_fr.ConjugateBranch1();\n\t\tCHECK(hyperbola3d_con.Location().X() == Approx(0.0));\n\t\tCHECK(hyperbola3d_con.Location().Y() == Approx(0.0));\n\t\tCHECK(hyperbola3d_con.Location().Z() == Approx(1.0));\n\t\tPoint3 point1(0.0, 4.0, 1.0);\n\t\tPoint3 point2(9.0 / 4.0, 5.0, 1.0);\n\t\tMakeEdge edge1(hyperbola3d_con);\n\t\tCHECK(BRepClassificationTools::IsPointInOnEdge(edge1, point1, 0.001) == true);\n\t\tCHECK(BRepClassificationTools::IsPointInOnEdge(edge1, point2, 0.001) == true);\n\t\tdouble major3d_con = hyperbola3d_con.MajorRadius();\n\t\tdouble minor3d_con = hyperbola3d_con.MinorRadius();\n\t\tCHECK(major3d_con == Approx(4.0));\n\t\tCHECK(minor3d_con == Approx(3.0));\n\t}} "
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] PointT<double, DIM> Focus2()\t @return The negative focus\n\t @brief Get the focus on the negative side of the major axis\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <modeling/MakeFace.hpp>\n#include <common/AxisT.hpp>\n#include <math/HyperbolaT.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <common/VectorT.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <topology/TopoEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <iostream>\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Hyperbola3\", \"[math][Hyperbola3][p1]\") {\n\tPoint3 point3_fr(0.0, 0.0, 1.0);\n\tDirection3 dir3_fr(0.0, 0.0, 1.0);\n\tFrame3 frame3(point3_fr, dir3_fr);\n\tdouble major3 = 3.0, minor3 = 4.0;\n\tHyperbola3 hyperbola3d_fr(frame3, major3, minor3);\n\tSECTION(\"Focus2\") {\n\t\tPoint3 point3d_f1 = hyperbola3d_fr.Focus2();\n\t\tCHECK(point3d_f1.X() == Approx(-5.0));\n\t\tCHECK(point3d_f1.Y() == Approx(0.0));\n\t\tCHECK(point3d_f1.Z() == Approx(1.0));\n\t}} "
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] PointT<double, DIM> Focus1()\t @return The positive focus\n\t @brief Get the focus on the positive side of the major axis\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <modeling/MakeFace.hpp>\n#include <common/AxisT.hpp>\n#include <math/HyperbolaT.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <common/VectorT.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <topology/TopoEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <iostream>\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Hyperbola3\", \"[math][Hyperbola3][p1]\") {\n\tPoint3 point3_fr(0.0, 0.0, 1.0);\n\tDirection3 dir3_fr(0.0, 0.0, 1.0);\n\tFrame3 frame3(point3_fr, dir3_fr);\n\tdouble major3 = 3.0, minor3 = 4.0;\n\tHyperbola3 hyperbola3d_fr(frame3, major3, minor3);\n\tSECTION(\"Default()\") {\n\t\tHyperbola3 hyperbola3d_de;\t\n\t\tCHECK(hyperbola3d_de.Location().X() == Approx(0.0));\n\t\tCHECK(hyperbola3d_de.Location().Y() == Approx(0.0));\n\t\tCHECK(hyperbola3d_de.Location().Z() == Approx(0.0));\n\t\thyperbola3d_de.SetMajorRadius(3.0);\n\t\thyperbola3d_de.SetMinorRadius(4.0);\n\t\tCHECK(hyperbola3d_de.MajorRadius() == Approx(3.0));\n\t\tCHECK(hyperbola3d_de.MinorRadius() == Approx(4.0));\n\t\tCHECK(hyperbola3d_de.Focal() == Approx(10.0));\n\t\tCHECK(hyperbola3d_de.Focus1().X() == Approx(5.0));\n\t\tCHECK(hyperbola3d_de.Focus1().Y() == Approx(0.0));\n\t\tCHECK(hyperbola3d_de.Focus1().Z() == Approx(0.0));\n\t}} "
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] AxisT<double, DIM> Directrix2()\t @return The negative directrix\n\t @brief Get the directrix on the negative side of the major axis\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <modeling/MakeFace.hpp>\n#include <common/AxisT.hpp>\n#include <math/HyperbolaT.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <common/VectorT.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <topology/TopoEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <iostream>\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Hyperbola3\", \"[math][Hyperbola3][p1]\") {\n\tPoint3 point3_fr(0.0, 0.0, 1.0);\n\tDirection3 dir3_fr(0.0, 0.0, 1.0);\n\tFrame3 frame3(point3_fr, dir3_fr);\n\tdouble major3 = 3.0, minor3 = 4.0;\n\tHyperbola3 hyperbola3d_fr(frame3, major3, minor3);\n\tSECTION(\"Directrix2()\") {\n\t\tAxis3 axis3d_dir = hyperbola3d_fr.Directrix2();\n\t\tCHECK(axis3d_dir.Direction().X() == Approx(0.0));\n\t\tCHECK(axis3d_dir.Direction().Y() == Approx(1.0));\n\t\tCHECK(axis3d_dir.Direction().Z() == Approx(0.0));\n\t\tCHECK(axis3d_dir.Location().X() == Approx(-9.0 / 5.0));\n\t\tCHECK(axis3d_dir.Location().Y() == Approx(0.0));\n\t\tCHECK(axis3d_dir.Location().Z() == Approx(1.0));\n\t}} "
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] AxisT<double, DIM> Directrix1()\t @return The positive directrix\n\t @brief Get the directrix on the positive side of the major axis\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <modeling/MakeFace.hpp>\n#include <common/AxisT.hpp>\n#include <math/HyperbolaT.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <common/VectorT.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <topology/TopoEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <iostream>\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Hyperbola3\", \"[math][Hyperbola3][p1]\") {\n\tPoint3 point3_fr(0.0, 0.0, 1.0);\n\tDirection3 dir3_fr(0.0, 0.0, 1.0);\n\tFrame3 frame3(point3_fr, dir3_fr);\n\tdouble major3 = 3.0, minor3 = 4.0;\n\tHyperbola3 hyperbola3d_fr(frame3, major3, minor3);\n\tSECTION(\"Directrix1()\") {\n\t\tAxis3 axis3d_dir = hyperbola3d_fr.Directrix1();\n\t\tCHECK(axis3d_dir.Direction().X() == Approx(0.0));\n\t\tCHECK(axis3d_dir.Direction().Y() == Approx(1.0));\n\t\tCHECK(axis3d_dir.Direction().Z() == Approx(0.0));\n\t\tCHECK(axis3d_dir.Location().X() == Approx(9.0 / 5.0));\n\t\tCHECK(axis3d_dir.Location().Y() == Approx(0.0));\n\t\tCHECK(axis3d_dir.Location().Z() == Approx(1.0));\n\t}} "
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "void SetMinorRadius(double r)\t @param r The new minor radius\n\t @brief Set the minor radius\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <modeling/MakeFace.hpp>\n#include <common/AxisT.hpp>\n#include <math/HyperbolaT.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <common/VectorT.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <topology/TopoEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <iostream>\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Hyperbola3\", \"[math][Hyperbola3][p1]\") {\n\tPoint3 point3_fr(0.0, 0.0, 1.0);\n\tDirection3 dir3_fr(0.0, 0.0, 1.0);\n\tFrame3 frame3(point3_fr, dir3_fr);\n\tdouble major3 = 3.0, minor3 = 4.0;\n\tHyperbola3 hyperbola3d_fr(frame3, major3, minor3);\n\tSECTION(\"SetMinorRadius()\") {\n\t\thyperbola3d_fr.SetMinorRadius(3.0);\n\t\tCHECK(hyperbola3d_fr.Location().X() == Approx(0.0));\n\t\tCHECK(hyperbola3d_fr.Location().Y() == Approx(0.0));\n\t\tCHECK(hyperbola3d_fr.MajorRadius() == Approx(3.0));\n\t\tCHECK(hyperbola3d_fr.MinorRadius() == Approx(3.0));\n\t\tPoint3 point1(3.0, 0.0, 1.0);\n\t\tMakeEdge edge1(hyperbola3d_fr);\n\t\tCHECK(BRepClassificationTools::IsPointInOnEdge(edge1, point1, 0.001) == true);\n\t}} "
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "void SetMajorRadius(double r)\t @param r The new major radius\n\t @brief Set the major radius\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <modeling/MakeFace.hpp>\n#include <common/AxisT.hpp>\n#include <math/HyperbolaT.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <common/VectorT.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <topology/TopoEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <iostream>\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Hyperbola3\", \"[math][Hyperbola3][p1]\") {\n\tPoint3 point3_fr(0.0, 0.0, 1.0);\n\tDirection3 dir3_fr(0.0, 0.0, 1.0);\n\tFrame3 frame3(point3_fr, dir3_fr);\n\tdouble major3 = 3.0, minor3 = 4.0;\n\tHyperbola3 hyperbola3d_fr(frame3, major3, minor3);\n\tSECTION(\"Default()\") {\n\t\tHyperbola3 hyperbola3d_de;\t\n\t\tCHECK(hyperbola3d_de.Location().X() == Approx(0.0));\n\t\tCHECK(hyperbola3d_de.Location().Y() == Approx(0.0));\n\t\tCHECK(hyperbola3d_de.Location().Z() == Approx(0.0));\n\t\thyperbola3d_de.SetMajorRadius(3.0);\n\t\thyperbola3d_de.SetMinorRadius(4.0);\n\t\tCHECK(hyperbola3d_de.MajorRadius() == Approx(3.0));\n\t\tCHECK(hyperbola3d_de.MinorRadius() == Approx(4.0));\n\t\tCHECK(hyperbola3d_de.Focal() == Approx(10.0));\n\t\tCHECK(hyperbola3d_de.Focus1().X() == Approx(5.0));\n\t\tCHECK(hyperbola3d_de.Focus1().Y() == Approx(0.0));\n\t\tCHECK(hyperbola3d_de.Focus1().Z() == Approx(0.0));\n\t}} "
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] auto SquaredDistance(const Point3& p)\t @return The squared distance between the point and the line\n\t @param p The point\n\t @brief Compute the squared distance from a point to the line\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <math/LineT.hpp>\n#include <modeling/MakeEdge2d.hpp>\nusing AMCAX::Line2;\n#define ONE_RADIAN (M_PI / 180.)\nTEST_CASE(\"case1: Line basic interface test\", \"[math][Line2][p1]\")\n{\n\tSECTION(\"Distance and SquaredDistance test\")\n\t{\n\t\tauto pointToLine = [](const Point2& point, const Line2& line) {\n\t\t\tdouble a, b, c;\n\t\t\tline.Coefficients(a, b, c);\n\t\t\treturn std::fabs(a * point.X() + b * point.Y() + c);\n\t\t};\n\t\tauto lineToLine = [](const Line2& line1, const Line2& line2) {\n\t\t\tdouble a1, b1, c1, a2, b2, c2;\n\t\t\tline1.Coefficients(a1, b1, c1);\n\t\t\tline2.Coefficients(a2, b2, c2);\n\t\t\tif (a1 != a2 || b1 != b2) return 0.;\n\t\t\treturn std::fabs(c1 - c2);\n\t\t};\n\t\tLine2 line(3., 4., -30.);\n\t\tPoint2 point1(6., 3.);\n\t\tPoint2 point2(6., 2.);\n\t\tLine2 line2(3., 4., -29.);\n\t\tLine2 line3(2., 1., -99.);\n\t\tCHECK(line.Distance(point1) == Approx(pointToLine(point1, line)).margin(0.01));\n\t\tCHECK(line.SquaredDistance(point1) == Approx(pointToLine(point1, line) * pointToLine(point1, line)).margin(0.01));\n\t\tCHECK(line.Distance(point2) == Approx(pointToLine(point2, line)));\n\t\tCHECK(line.SquaredDistance(point2) == Approx(pointToLine(point2, line) * pointToLine(point2, line)).margin(0.01));\n\t\tCHECK(line.Distance(line2) == Approx(lineToLine(line, line2)));\n\t\tCHECK(line.SquaredDistance(line2) == Approx(lineToLine(line2, line) * lineToLine(line2, line)).margin(0.01));\n\t\tCHECK(line.Distance(line3) == Approx(lineToLine(line, line3)));\n\t\tCHECK(line.SquaredDistance(line3) == Approx(lineToLine(line3, line) * lineToLine(line3, line)).margin(0.01));\n\t}}\n}\n,\n{\n "
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] auto Distance(const Point3& p)\t @return The distance between the point and the line\n\t @param p The point\n\t @brief Compute the distance from a point to the line\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <math/LineT.hpp>\n#include <modeling/MakeEdge2d.hpp>\nusing AMCAX::Line2;\n#define ONE_RADIAN (M_PI / 180.)\nTEST_CASE(\"case2: Line base method Test\", \"[math][Line2][p1]\")\n{\n\tSECTION(\"Scale\")\n\t{\n\t\tLine2 line(Point2(0., -1.), Direction2());\n\t\tPoint2 point;\n\t\tdouble distance = line.Distance(point);\n\t\tLine2 lineScale1 = line.Scaled(point, 1.1);\n\t\tCHECK(lineScale1.Distance(point) > distance);\n\t\tCHECK(lineScale1.Contains(Point2(0., -1.1), 1e-5));\n\t\tLine2 lineScale2 = line.Scaled(point, 1.);\n\t\tCHECK(lineScale2.Distance(point) == Approx(distance).margin(1e-5));\n\t\tCHECK(lineScale2.Contains(Point2(0., -1.), 1e-5));\n\t\tLine2 lineScale3 = line.Scaled(point, 0.8);\n\t\tCHECK(lineScale3.Distance(point) < distance);\n\t\tCHECK(lineScale3.Contains(Point2(0., -0.8), 1e-5));\n\t\tLine2 lineScale4 = line.Scaled(point, 0.);\n\t\tline.SetDirection(Direction2(-1.0, 4.0));\n\t\tLine2 lineScale5 = line.Scaled(Point2(-1., 2.), 0.);\n\t\tCHECK(lineScale4.Contains(Point2(0., 0.), 1e-5));\n\t\tCHECK(lineScale4.Direction().IsEqual(Direction2(), 1e-6 * ONE_RADIAN));\n\t\tCHECK(lineScale5.Contains(Point2(-1., 2.), 1e-5));\n\t\tCHECK(lineScale5.Direction().IsEqual(Direction2(-1., 4.), 1e-6 * ONE_RADIAN));\n\t\tLine2 lineScale6 = line.Scaled(point, -1.);\n\t\tCHECK(lineScale6.Direction().IsEqual(Direction2(1., -4.), 1e-5 * ONE_RADIAN));\n\t}} "
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] LineS Rotated(const Point2& point, double angle)\t @return The rotated line\n\t @param angle The rotation angle\n\t @param point The rotation center point\n\t @brief Get the line rotated around a point with an angle in 2D\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <math/LineT.hpp>\n#include <modeling/MakeEdge2d.hpp>\nusing AMCAX::Line2;\n#define ONE_RADIAN (M_PI / 180.)\nTEST_CASE(\"case1: Line basic interface test\", \"[math][Line2][p1]\")\n{\n\tSECTION(\"Rotated Test\")\n\t{\n\t\tLine2 line(Point2(0., 1.), Direction2(1., 1.));  \n\t\tLine2 rotateLine = line.Rotated(Point2(), (3. / 4) * M_PI);  \n\t\tCHECK(rotateLine.Direction().X() == Approx(-1.).margin(1e-5));\n\t\tCHECK(rotateLine.Direction().Y() == Approx(0.).margin(1e-5));\n\t\tdouble a, b, c;\n\t\trotateLine.Coefficients(a, b, c);\n\t\tCHECK((c - b) == Approx(0.).margin(0.5));\n\t\tCHECK(line.Distance(Point2()) == rotateLine.Distance(Point2()));  \n\t\tTopoShape lineShape1 = MakeEdge2d(line);\n\t\tTopoShape lineShape2 = MakeEdge2d(rotateLine);\n\t\tREQUIRE(OCCTIO::OCCTTool::Write(lineShape1, OUTPUT_PATH_PREFIX\"Line2_Rotated_before_p1.brep\"));\n\t\tREQUIRE(OCCTIO::OCCTTool::Write(lineShape2, OUTPUT_PATH_PREFIX\"Line2_Rotated_later_p1.brep\"));\n\t}\n}} "
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "LineS& Rotate(const Point2& point, double angle)\t @return The reference to self\n\t @param angle The rotation angle\n\t @param point The rotation center point\n\t @brief Rotate the line around a point with an angle in 2D\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <math/LineT.hpp>\n#include <modeling/MakeEdge2d.hpp>\nusing AMCAX::Line2;\n#define ONE_RADIAN (M_PI / 180.)\nTEST_CASE(\"case1: Line basic interface test\", \"[math][Line2][p1]\")\n{\n\tSECTION(\"Rotate Test\")\n\t{\n\t\tLine2 line(Point2(0., 1.), Direction2(1., 1.));  \n\t\tLine2 line2(Point2(0., 1.), Direction2(1., 1.));  \n\t\tline.Rotate(Point2(), (5. / 4) * M_PI);  \n\t\tCHECK(line.Direction().X() == Approx(0.).margin(1e-5));\n\t\tCHECK(line.Direction().Y() == Approx(-1.).margin(1e-5));\n\t\tdouble a, b, c;\n\t\tline.Coefficients(a, b, c);\n\t\tCHECK((a + c) == Approx(0.).margin(0.5));\n\t\tCHECK(line2.Distance(Point2()) == line.Distance(Point2()));  \n\t\tCHECK(line.Contains(Point2(std::sqrt(2.) / 2., 0.), 1e-6) == true);\n\t}} "
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] LineS Normal(const Point2& p)\t @return The line passing through a point and perpendicular to the line\n\t @param p The point\n\t @brief Get a line passing through a point and perpendicular to the line\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <math/LineT.hpp>\n#include <modeling/MakeEdge2d.hpp>\nusing AMCAX::Line2;\n#define ONE_RADIAN (M_PI / 180.)\nTEST_CASE(\"case1: Line basic interface test\", \"[math][Line2][p1]\")\n{\n\tSECTION(\"Normal Test\")\n\t{\n\t\tLine2 line(3., 4., 5.);  \n\t\tLine2 normalLine = line.Normal(Point2(1., 5.));\n\t\tdouble a, b, c;\n\t\tnormalLine.Coefficients(a, b, c);\n\t\tCHECK((a * 3 + b * 4) == Approx(0.0).margin(0.1));\n\t\tCHECK((a * 1 + b * 5 + c) == Approx(0.0).margin(0.1));\n\t}} "
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] auto SquaredDistance(const LineS& l)\t @return The squared distance between two lines\n\t @param l The other line\n\t @brief Compute the squared distance between two lines\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <math/LineT.hpp>\n#include <modeling/MakeEdge2d.hpp>\nusing AMCAX::Line2;\n#define ONE_RADIAN (M_PI / 180.)\nTEST_CASE(\"case1: Line basic interface test\", \"[math][Line2][p1]\")\n{\n\tSECTION(\"Distance and SquaredDistance test\")\n\t{\n\t\tauto pointToLine = [](const Point2& point, const Line2& line) {\n\t\t\tdouble a, b, c;\n\t\t\tline.Coefficients(a, b, c);\n\t\t\treturn std::fabs(a * point.X() + b * point.Y() + c);\n\t\t};\n\t\tauto lineToLine = [](const Line2& line1, const Line2& line2) {\n\t\t\tdouble a1, b1, c1, a2, b2, c2;\n\t\t\tline1.Coefficients(a1, b1, c1);\n\t\t\tline2.Coefficients(a2, b2, c2);\n\t\t\tif (a1 != a2 || b1 != b2) return 0.;\n\t\t\treturn std::fabs(c1 - c2);\n\t\t};\n\t\tLine2 line(3., 4., -30.);\n\t\tPoint2 point1(6., 3.);\n\t\tPoint2 point2(6., 2.);\n\t\tLine2 line2(3., 4., -29.);\n\t\tLine2 line3(2., 1., -99.);\n\t\tCHECK(line.Distance(point1) == Approx(pointToLine(point1, line)).margin(0.01));\n\t\tCHECK(line.SquaredDistance(point1) == Approx(pointToLine(point1, line) * pointToLine(point1, line)).margin(0.01));\n\t\tCHECK(line.Distance(point2) == Approx(pointToLine(point2, line)));\n\t\tCHECK(line.SquaredDistance(point2) == Approx(pointToLine(point2, line) * pointToLine(point2, line)).margin(0.01));\n\t\tCHECK(line.Distance(line2) == Approx(lineToLine(line, line2)));\n\t\tCHECK(line.SquaredDistance(line2) == Approx(lineToLine(line2, line) * lineToLine(line2, line)).margin(0.01));\n\t\tCHECK(line.Distance(line3) == Approx(lineToLine(line, line3)));\n\t\tCHECK(line.SquaredDistance(line3) == Approx(lineToLine(line3, line) * lineToLine(line3, line)).margin(0.01));\n\t}} "
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] auto SquaredDistance(const Point2& p)\t @return The squared distance between the point and the line\n\t @param p The point\n\t @brief Compute the squared distance from a point to the line\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <math/LineT.hpp>\n#include <modeling/MakeEdge2d.hpp>\nusing AMCAX::Line2;\n#define ONE_RADIAN (M_PI / 180.)\nTEST_CASE(\"case1: Line basic interface test\", \"[math][Line2][p1]\")\n{\n\tSECTION(\"Distance and SquaredDistance test\")\n\t{\n\t\tauto pointToLine = [](const Point2& point, const Line2& line) {\n\t\t\tdouble a, b, c;\n\t\t\tline.Coefficients(a, b, c);\n\t\t\treturn std::fabs(a * point.X() + b * point.Y() + c);\n\t\t};\n\t\tauto lineToLine = [](const Line2& line1, const Line2& line2) {\n\t\t\tdouble a1, b1, c1, a2, b2, c2;\n\t\t\tline1.Coefficients(a1, b1, c1);\n\t\t\tline2.Coefficients(a2, b2, c2);\n\t\t\tif (a1 != a2 || b1 != b2) return 0.;\n\t\t\treturn std::fabs(c1 - c2);\n\t\t};\n\t\tLine2 line(3., 4., -30.);\n\t\tPoint2 point1(6., 3.);\n\t\tPoint2 point2(6., 2.);\n\t\tLine2 line2(3., 4., -29.);\n\t\tLine2 line3(2., 1., -99.);\n\t\tCHECK(line.Distance(point1) == Approx(pointToLine(point1, line)).margin(0.01));\n\t\tCHECK(line.SquaredDistance(point1) == Approx(pointToLine(point1, line) * pointToLine(point1, line)).margin(0.01));\n\t\tCHECK(line.Distance(point2) == Approx(pointToLine(point2, line)));\n\t\tCHECK(line.SquaredDistance(point2) == Approx(pointToLine(point2, line) * pointToLine(point2, line)).margin(0.01));\n\t\tCHECK(line.Distance(line2) == Approx(lineToLine(line, line2)));\n\t\tCHECK(line.SquaredDistance(line2) == Approx(lineToLine(line2, line) * lineToLine(line2, line)).margin(0.01));\n\t\tCHECK(line.Distance(line3) == Approx(lineToLine(line, line3)));\n\t\tCHECK(line.SquaredDistance(line3) == Approx(lineToLine(line3, line) * lineToLine(line3, line)).margin(0.01));\n\t}} "
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] auto Distance(const Point2& p)\t @return The distance between the point and the line\n\t @param p The point\n\t @brief Compute the distance from a point to the line\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <math/LineT.hpp>\n#include <modeling/MakeEdge2d.hpp>\nusing AMCAX::Line2;\n#define ONE_RADIAN (M_PI / 180.)\nTEST_CASE(\"case2: Line base method Test\", \"[math][Line2][p1]\")\n{\n\tSECTION(\"SetDirection\")\n\t{\n\t\tLine2 line(Point2(), Direction2(1., 1.));  \n\t\tCHECK(line.Direction().IsEqual(Direction2(1., 1.), 1e-5 * ONE_RADIAN));\n\t\tCHECK(line.Distance(Point2(1., 2.)) > 0.);\n\t\tline.SetDirection(Direction2(1., 2.));  \n\t\tCHECK(line.Direction().IsEqual(Direction2(1., 2.), 1e-5 * ONE_RADIAN));\n\t\tCHECK(line.Distance(Point2(1., 2.)) == Approx(0.).margin(1e-5));\n\t\tdouble a, b, c;\n\t\tline.Coefficients(a, b, c);\n\t\tCHECK(a == Approx(2. / std::sqrt(5)).margin(1e-5));\n\t\tCHECK(b == Approx(-1. / std::sqrt(5)).margin(1e-5));\n\t\tCHECK(c == Approx(0. / std::sqrt(5)).margin(1e-5));\n\t}} "
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "void Coefficients(double& a, double& b, double& c)\t @param[out] a,b,c The coefficients\n\t @brief The coefficients of the algebraic representation of the 2D line\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <math/LineT.hpp>\n#include <modeling/MakeEdge2d.hpp>\nusing AMCAX::Line2;\n#define ONE_RADIAN (M_PI / 180.)\n#include <catch.hpp>\n#include <testHelper.h>\n#include <math/LineT.hpp>\n#include <modeling/MakeEdge2d.hpp>\nusing AMCAX::Line2;\n#define ONE_RADIAN (M_PI / 180.) "
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "LineS(double a, double b, double c)\t @param a,b,c The coefficients\n\t @brief Construct from the algebraic coefficients of 2D line\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <math/LineT.hpp>\n#include <modeling/MakeEdge2d.hpp>\nusing AMCAX::Line2;\n#define ONE_RADIAN (M_PI / 180.)\nTEST_CASE(\"case1: Line basic interface test\", \"[math][Line2][p1]\")\n{\n\tSECTION(\"Parameterized constructor test\")\n\t{\n\t\tLine2 line1(Axis2(Point2(1., 0.), Direction2(2., 1.)));\n\t\tLine2 line2(Point2(1., 0.), Direction2(2., 1.));  \n\t\tLine2 line3(1, -2, -1);\n\t\tdouble a, b, c;\n\t\tline1.Coefficients(a, b, c);\n\t\tCHECK(a == Approx(1.0 / std::sqrt(5)));\n\t\tCHECK(b == Approx(-2.0 / std::sqrt(5)));\n\t\tCHECK(c == Approx(-1.0 / std::sqrt(5)));\n\t\tline2.Coefficients(a, b, c);\n\t\tCHECK(a == Approx(1.0 / std::sqrt(5)));\n\t\tCHECK(b == Approx(-2.0 / std::sqrt(5)));\n\t\tCHECK(c == Approx(-1.0 / std::sqrt(5)));\n\t\tline3.Coefficients(a, b, c);\n\t\tCHECK(a == Approx(1.0 / std::sqrt(5)));\n\t\tCHECK(b == Approx(-2.0 / std::sqrt(5)));\n\t\tCHECK(c == Approx(-1.0 / std::sqrt(5)));\n\t}} "
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "Derived& Reverse()\t @return The reference to self\n\t @brief Reverse the line direction\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <math/LineT.hpp>\n#include <modeling/MakeEdge2d.hpp>\nusing AMCAX::Line2;\n#define ONE_RADIAN (M_PI / 180.)\nTEST_CASE(\"case2: Line base method Test\", \"[math][Line2][p1]\")\n{\n\tSECTION(\"Reverse\")\n\t{\n\t\tLine2 line;\n\t\tline.Reverse();\n\t\tCHECK(line.Direction().IsEqual(Direction2(-1., 0.), 1e-5 * ONE_RADIAN));\n\t\tLine2 line2(Point2(), Direction2(-3., 98.));\n\t\tline2.Reverse();\n\t\tCHECK(line2.Direction().IsEqual(Direction2(3., -98.), 1e-5 * ONE_RADIAN));\n\t}} "
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] auto Angle(const LineBase& other)\t @return The angle between the line and the other line\n\t @param other The other line\n\t @brief Compute the angle between the line and the other line\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <math/LineT.hpp>\n#include <modeling/MakeEdge2d.hpp>\nusing AMCAX::Line2;\n#define ONE_RADIAN (M_PI / 180.)\nTEST_CASE(\"case2: Line base method Test\", \"[math][Line2][p1]\")\n{\n\tSECTION(\"Angle\")\n\t{\n\t\tLine2 line;\n\t\tLine2 line2(Point2(), Direction2(0., 1.));\n\t\tCHECK(line.Angle(line2) == Approx(M_PI_2));\n\t\tCHECK(line2.Angle(line) == Approx(-M_PI_2));\n\t\tLine2 line3(Point2(), Direction2(2., 3.));\n\t\tLine2 line4(Point2(), Direction2(5., -8.));\n\t\tCHECK(line4.Angle(line3) == Approx(\n\t\t\tstd::acos((2. * 5. + 3. * (-8.)) / (std::sqrt(4. + 9.) * std::sqrt(25. + 64.)))\n\t\t).margin(1e-5 * ONE_RADIAN));\n\t}} "
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] const DirectionT<double, DIM>& Direction()\t @return The direction of the line\n\t @brief Get the direction of the line\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <math/LineT.hpp>\n#include <modeling/MakeEdge2d.hpp>\nusing AMCAX::Line2;\n#define ONE_RADIAN (M_PI / 180.)\nTEST_CASE(\"case2: Line base method Test\", \"[math][Line2][p1]\")\n{\n\tSECTION(\"SetPosition\")\n\t{\n\t\tLine2 line;\n\t\tCHECK(line.Location().IsEqual(Point2(0., 0.), 1e-5));\n\t\tCHECK(line.Direction().IsEqual(Direction2(1., 0.), 1e-5 * ONE_RADIAN));\n\t\tAxis2 axis(Point2(2., 1.), Direction2(1., 1.));\n\t\tline.SetPosition(axis);  \n\t\tdouble a, b, c;\n\t\tline.Coefficients(a, b, c);\n\t\tCHECK(a == Approx(1. / std::sqrt(2)).margin(1e-5));\n\t\tCHECK(b == Approx(-1. / std::sqrt(2)).margin(1e-5));\n\t\tCHECK(c == Approx(-1. / std::sqrt(2)).margin(1e-5));\n\t}} "
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "void SetPosition(const AxisT<double, DIM>& axis)\t @param axis The axis\n\t @brief Set the axis of the line\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <math/LineT.hpp>\n#include <modeling/MakeEdge2d.hpp>\nusing AMCAX::Line2;\n#define ONE_RADIAN (M_PI / 180.)\nTEST_CASE(\"case2: Line base method Test\", \"[math][Line2][p1]\")\n{\n\tSECTION(\"SetPosition\")\n\t{\n\t\tLine2 line;\n\t\tCHECK(line.Location().IsEqual(Point2(0., 0.), 1e-5));\n\t\tCHECK(line.Direction().IsEqual(Direction2(1., 0.), 1e-5 * ONE_RADIAN));\n\t\tAxis2 axis(Point2(2., 1.), Direction2(1., 1.));\n\t\tline.SetPosition(axis);  \n\t\tdouble a, b, c;\n\t\tline.Coefficients(a, b, c);\n\t\tCHECK(a == Approx(1. / std::sqrt(2)).margin(1e-5));\n\t\tCHECK(b == Approx(-1. / std::sqrt(2)).margin(1e-5));\n\t\tCHECK(c == Approx(-1. / std::sqrt(2)).margin(1e-5));\n\t}} "
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "void SetDirection(const DirectionT<double, DIM>& dir)\t @param dir The line direction\n\t @brief Set the line direction\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <math/LineT.hpp>\n#include <modeling/MakeEdge2d.hpp>\nusing AMCAX::Line2;\n#define ONE_RADIAN (M_PI / 180.)\nTEST_CASE(\"case2: Line base method Test\", \"[math][Line2][p1]\")\n{\n\tSECTION(\"SetDirection\")\n\t{\n\t\tLine2 line(Point2(), Direction2(1., 1.));  \n\t\tCHECK(line.Direction().IsEqual(Direction2(1., 1.), 1e-5 * ONE_RADIAN));\n\t\tCHECK(line.Distance(Point2(1., 2.)) > 0.);\n\t\tline.SetDirection(Direction2(1., 2.));  \n\t\tCHECK(line.Direction().IsEqual(Direction2(1., 2.), 1e-5 * ONE_RADIAN));\n\t\tCHECK(line.Distance(Point2(1., 2.)) == Approx(0.).margin(1e-5));\n\t\tdouble a, b, c;\n\t\tline.Coefficients(a, b, c);\n\t\tCHECK(a == Approx(2. / std::sqrt(5)).margin(1e-5));\n\t\tCHECK(b == Approx(-1. / std::sqrt(5)).margin(1e-5));\n\t\tCHECK(c == Approx(0. / std::sqrt(5)).margin(1e-5));\n\t}} "
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "void SetLocation(const PointT<double, DIM>& point)\t @param point The location point\n\t @brief Set the location of the line\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <math/LineT.hpp>\n#include <modeling/MakeEdge2d.hpp>\nusing AMCAX::Line2;\n#define ONE_RADIAN (M_PI / 180.)\nTEST_CASE(\"case2: Line base method Test\", \"[math][Line2][p1]\")\n{\n\tSECTION(\"SetLocation\")\n\t{\n\t\tLine2 line(Point2(0., 0.), Direction2(1., 1.));  \n\t\tCHECK(line.Location().IsEqual(Point2(), 1e-5));\n\t\tline.SetLocation(Point2(2., 1.));  \n\t\tCHECK(line.Location().IsEqual(Point2(2., 1.), 1e-5));\n\t\tdouble a, b, c;\n\t\tline.Coefficients(a, b, c);\n\t\tCHECK(a == Approx(1. / std::sqrt(2)).margin(1e-5));\n\t\tCHECK(b == Approx(-1. / std::sqrt(2)).margin(1e-5));\n\t\tCHECK(c == Approx(-1. / std::sqrt(2)).margin(1e-5));\n\t}} "
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "Derived& Translate(const VectorT<double, DIM>& vec)\t @return The reference to self\n\t @param vec The translation vector\n\t @brief Translate the line by a vector\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <math/LineT.hpp>\n#include <modeling/MakeEdge2d.hpp>\nusing AMCAX::Line2;\n#define ONE_RADIAN (M_PI / 180.)\nTEST_CASE(\"case2: Line base method Test\", \"[math][Line2][p1]\")\n{\n\tSECTION(\"Translate Test\")\n\t{\n\t\tLine2 line;\n\t\tline.Translate(Vector2(2., 0.));  \n\t\tCHECK(line.Direction().IsEqual(Direction2(), 1e-5 * ONE_RADIAN));\n\t\tCHECK(line.Contains(Point2(2., 0.), 1e-5));\n\t\tLine2 translateLine = line.Translated(Point2(2., 0.), Point2(-10., 0.));\n\t\tCHECK(translateLine.Contains(Point2(-10., 0.), 1e-5));\n\t}\n}} "
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] Derived Scaled(const PointT<double, DIM>& point, double scale)\t @return The scaled line\n\t @param scale The scale value\n\t @param point The scaling center point\n\t @brief Get the line scaled by a point\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <math/LineT.hpp>\n#include <modeling/MakeEdge2d.hpp>\nusing AMCAX::Line2;\n#define ONE_RADIAN (M_PI / 180.)\nTEST_CASE(\"case2: Line base method Test\", \"[math][Line2][p1]\")\n{\n\tSECTION(\"Scale\")\n\t{\n\t\tLine2 line(Point2(0., -1.), Direction2());\n\t\tPoint2 point;\n\t\tdouble distance = line.Distance(point);\n\t\tLine2 lineScale1 = line.Scaled(point, 1.1);\n\t\tCHECK(lineScale1.Distance(point) > distance);\n\t\tCHECK(lineScale1.Contains(Point2(0., -1.1), 1e-5));\n\t\tLine2 lineScale2 = line.Scaled(point, 1.);\n\t\tCHECK(lineScale2.Distance(point) == Approx(distance).margin(1e-5));\n\t\tCHECK(lineScale2.Contains(Point2(0., -1.), 1e-5));\n\t\tLine2 lineScale3 = line.Scaled(point, 0.8);\n\t\tCHECK(lineScale3.Distance(point) < distance);\n\t\tCHECK(lineScale3.Contains(Point2(0., -0.8), 1e-5));\n\t\tLine2 lineScale4 = line.Scaled(point, 0.);\n\t\tline.SetDirection(Direction2(-1.0, 4.0));\n\t\tLine2 lineScale5 = line.Scaled(Point2(-1., 2.), 0.);\n\t\tCHECK(lineScale4.Contains(Point2(0., 0.), 1e-5));\n\t\tCHECK(lineScale4.Direction().IsEqual(Direction2(), 1e-6 * ONE_RADIAN));\n\t\tCHECK(lineScale5.Contains(Point2(-1., 2.), 1e-5));\n\t\tCHECK(lineScale5.Direction().IsEqual(Direction2(-1., 4.), 1e-6 * ONE_RADIAN));\n\t\tLine2 lineScale6 = line.Scaled(point, -1.);\n\t\tCHECK(lineScale6.Direction().IsEqual(Direction2(1., -4.), 1e-5 * ONE_RADIAN));\n\t}} "
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] const PointT<double, DIM>& Location()\t @return The location of the line\n\t @brief Get the location point of the line\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <math/LineT.hpp>\n#include <modeling/MakeEdge2d.hpp>\nusing AMCAX::Line2;\n#define ONE_RADIAN (M_PI / 180.)\nTEST_CASE(\"case1: Line basic interface test\", \"[math][Line2][p1]\")\n{\n\tSECTION(\"Parameterless constructor test\")\n\t{\n\t\tLine2 line;  \n\t\tCHECK(line.Location().IsEqual(Axis2().Location(), 0.001));\n\t\tCHECK(line.Direction().IsEqual(Axis2().Direction(), 1e-5 * ONE_RADIAN));\n\t}} "
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] bool Contains(const PointT<double, DIM>& p, double tol)\t @return True if the point is on the line under the tolerance\n\t @param tol The tolerance\n\t @param p The point\n\t @brief Does the line contain a point under a distance tolerance\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <math/LineT.hpp>\n#include <modeling/MakeEdge2d.hpp>\nusing AMCAX::Line2;\n#define ONE_RADIAN (M_PI / 180.)\nTEST_CASE(\"case2: Line base method Test\", \"[math][Line2][p1]\")\n{\n\tSECTION(\"Contains\")\n\t{\n\t\tLine2 line(Axis2(Point2(2., 1.), Direction2(1., 1.)));  \n\t\tPoint2 point1(2., 1.);  \n\t\tPoint2 point2(1., 1.);  \n\t\tCHECK(line.Contains(point1, 1e-5));\n\t\tCHECK_FALSE(line.Contains(point2, 1e-5));\n\t\tCHECK(line.Contains(point2, 1.));  \n\t}} "
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] LineS Rotated(const Axis3& axis, double angle)\t @return The rotated line\n\t @param angle The rotation angle\n\t @param axis The rotation axis\n\t @brief Get the line rotated around an axis with an angle in 3D\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <math/LineT.hpp>\n#include <math/Plane.hpp>\n#include <modeling/MakeFace.hpp>\n#include <modeling/MakeEdge.hpp>\nusing AMCAX::Line3;\nusing AMCAX::MakeEdge;\nusing AMCAX::MakeFace;\n#define ONE_RADIAN (M_PI / 180.)\n#define SQUARE(x) ((x) * (x))\nTEST_CASE(\"case1: Derived class interface unit testing\", \"[math][Line3][p1]\")\n{\n\tSECTION(\"Rotate\")\n\t{\n\t\tAxis3 axis(Point3(0., 0., 0.), Direction3(0., 1., 0.));\n\t\tLine3 line(Point3(0., 0., 0.), Direction3(1., 1., -1.));\n\t\tLine3 rotateLine = line.Rotated(axis, 90. * ONE_RADIAN);  \n\t\tTopoEdge edge1 = MakeEdge(line);\n\t\tTopoEdge edge2 = MakeEdge(rotateLine);\n\t\tTopoEdge edge3 = MakeEdge(Line3(axis));\n\t\tbool isWriteSuccess1 = AMCAX::OCCTIO::OCCTTool::Write(edge1, OUTPUT_PATH_PREFIX\"Line3_Rotate_line.brep\");\n\t\tbool isWriteSuccess2 = AMCAX::OCCTIO::OCCTTool::Write(edge2, OUTPUT_PATH_PREFIX\"Line3_Rotate_lineRotate.brep\");\n\t\tbool isWriteSuccess3 = AMCAX::OCCTIO::OCCTTool::Write(edge3, OUTPUT_PATH_PREFIX\"Line3_Rotate_axis.brep\");\n\t\tREQUIRE(isWriteSuccess1);\n\t\tREQUIRE(isWriteSuccess2);\n\t\tREQUIRE(isWriteSuccess3);\n\t\tauto pointToPoint = [](const Point3& p1, const Point3& p2) {\n\t\t\treturn std::sqrt(\n\t\t\t\tSQUARE(p1.X() - p2.X()) +\n\t\t\t\tSQUARE(p1.Y() - p2.Y()) +\n\t\t\t\tSQUARE(p1.Z() - p2.Z())\n\t\t\t);\n\t\t};\n\t\tCHECK(line.Distance(Line3(axis)) == Approx(rotateLine.Distance(Line3(axis))).margin(std::numeric_limits<double>::min()));\n\t\tCHECK(pointToPoint(line.Location(), Point3()) == Approx(pointToPoint(rotateLine.Location(), Point3())).margin(std::numeric_limits<double>::min()));\n\t\tPoint3 p(-1., 1., -1.);\n\t\tCHECK(rotateLine.Contains(p, 1e-6) == true);\n\t}\n}}\n}\n,\n{\n "
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "LineS& Mirror(const Frame3& frame)\t @return The reference to self\n\t @param frame The mirror frame\n\t @brief Mirror the line by a frame\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <math/LineT.hpp>\n#include <math/Plane.hpp>\n#include <modeling/MakeFace.hpp>\n#include <modeling/MakeEdge.hpp>\nusing AMCAX::Line3;\nusing AMCAX::MakeEdge;\nusing AMCAX::MakeFace;\n#define ONE_RADIAN (M_PI / 180.)\n#define SQUARE(x) ((x) * (x))\nTEST_CASE(\"case1: Derived class interface unit testing\", \"[math][Line3][p1]\")\n{\n\tSECTION(\"Mirror\")\n\t{\n\t\tLine3 line(Point3(1.0, 2.0, 3.0), Direction3(1.0, 0.0, 0.0));\n\t\tLine3 originalLine(Point3(1.0, 2.0, 3.0), Direction3(1.0, 0.0, 0.0));\n\t\tFrame3 frame(Point3(0.0, 0.0, 0.0), Direction3(0.0, 1.0, 0.0));\n\t\tline.Mirror(frame);\n\t\tCHECK(line.Distance(Point3(0.0, 0.0, 0.0)) == Approx(originalLine.Distance(Point3(0., 0., 0.))).margin(std::numeric_limits<double>::min()));\n\t\tDirection3 dir(originalLine.Location().X() - line.Location().X(),\n\t\t\t\t\t   originalLine.Location().Y() - line.Location().Y(),\n\t\t\t\t\t   originalLine.Location().Z() - line.Location().Z());\n\t\tCHECK(dir.IsParallel(Direction3(0.0, 1.0, 0.0), 1e-5 * ONE_RADIAN));\n\t\tLine3 line2(Point3(1.2, -4.6, 2.3), Direction3(1.8, 97.4, -12.8));\n\t\tFrame3 frame2(Point3(87.0, 2.3, 10.14), Direction3(-92.3, 2.6, 1.0));\n\t\tLine3 mirrorLine2 = line2.Mirrored(frame2);\n\t\tCHECK(line2.Distance(Point3(87.0, 2.3, 10.14)) == Approx(mirrorLine2.Distance(Point3(87.0, 2.3, 10.14))).margin(std::numeric_limits<double>::min()));\n\t\tDirection3 dir2(line2.Location().X() - mirrorLine2.Location().X(),\n\t\t\t\t\t    line2.Location().Y() - mirrorLine2.Location().Y(),\n\t\t\t\t\t    line2.Location().Z() - mirrorLine2.Location().Z());\n\t\tCHECK(dir2.IsParallel(Direction3(-92.3, 2.6, 1.0), 1e-5 * ONE_RADIAN));\n\t\tTopoFace face = MakeFace(Plane(frame2), 0., 4., 0., 4.);\n\t\tTopoEdge edgeLine2 = MakeEdge(line2, 0., 1.);\n\t\tTopoEdge edgeMirrorLine2 = MakeEdge(mirrorLine2, 0., 1.);\n\t\tAMCAX::OCCTIO::OCCTTool::Write(face, OUTPUT_PATH_PREFIX\"Line3_Mirror_face2.brep\");\n\t\tAMCAX::OCCTIO::OCCTTool::Write(edgeLine2, OUTPUT_PATH_PREFIX\"Line3_Mirror_edge.brep\");\n\t\tAMCAX::OCCTIO::OCCTTool::Write(edgeMirrorLine2, OUTPUT_PATH_PREFIX\"Line3_Mirror_Mirroredge.brep\");\n\t}} "
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] LineS Normal(const Point3& p)\t @return The line passing through a point and perpendicular to the line\n\t @param p The point\n\t @brief Get a line passing through a point and perpendicular to the line\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <math/LineT.hpp>\n#include <math/Plane.hpp>\n#include <modeling/MakeFace.hpp>\n#include <modeling/MakeEdge.hpp>\nusing AMCAX::Line3;\nusing AMCAX::MakeEdge;\nusing AMCAX::MakeFace;\n#define ONE_RADIAN (M_PI / 180.)\n#define SQUARE(x) ((x) * (x))\nTEST_CASE(\"case1: Derived class interface unit testing\", \"[math][Line3][p1]\")\n{\n\tSECTION(\"Normal\")\n\t{\n\t\tLine3 line(Point3(94., 32., 4.8), Direction3(2.65, 3.28, 5.14));\n\t\tLine3 line2 = line.Normal(Point3(2.1, 3.4, 11.2));\n\t\tCHECK(line.Direction().Dot(line2.Direction()) == Approx(0.).margin(1e-6));\n\t}} "
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] auto SquaredDistance(const Point3& p)\t @return The squared distance between the point and the line\n\t @param p The point\n\t @brief Compute the squared distance from a point to the line\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <math/LineT.hpp>\n#include <math/Plane.hpp>\n#include <modeling/MakeFace.hpp>\n#include <modeling/MakeEdge.hpp>\nusing AMCAX::Line3;\nusing AMCAX::MakeEdge;\nusing AMCAX::MakeFace;\n#define ONE_RADIAN (M_PI / 180.)\n#define SQUARE(x) ((x) * (x))\nTEST_CASE(\"case1: Derived class interface unit testing\", \"[math][Line3][p1]\")\n{\n\tSECTION(\"Distance and SquaredDistance\")\n\t{\n\t\tauto pointToLine = [](const Point3& p, const Line3& line) {\n\t\t\tconst Point3& p1 = line.Location();\n\t\t\tdouble dX = p1.X() - p.X();\n\t\t\tdouble dY = p1.Y() - p.Y();\n\t\t\tdouble dZ = p1.Z() - p.Z();\n\t\t\tdouble pp1Square = SQUARE(dX) + SQUARE(dY) + SQUARE(dZ);\n\t\t\tDirection3 dir(dX, dY, dZ);\n\t\t\tdouble cos = std::fabs(dir.Dot(line.Direction()));\n\t\t\treturn std::sqrt(pp1Square - SQUARE(cos*std::sqrt(pp1Square)));\n\t\t};\n\t\tauto lineToLine = [&pointToLine](const Line3& line1, const Line3& line2) {\n\t\t\tif (line1.Direction().IsParallel(line2.Direction(), std::numeric_limits<double>::min()))\n\t\t\t\treturn pointToLine(line1.Location(), line2);\n\t\t\tDirection3 line1Dir = line1.Direction();\n\t\t\tDirection3 line2Dir = line2.Direction();\n\t\t\tdouble x3 = line1Dir.Y() * line2Dir.Z() - line2Dir.Y() * line1Dir.Z();\n\t\t\tdouble y3 = -(line1Dir.X() * line2Dir.Z() - line2Dir.X() * line1Dir.Z());\n\t\t\tdouble z3 = line1Dir.X() * line2Dir.Y() - line2Dir.X() * line1Dir.Y();\n\t\t\tDirection3 line3Dir(x3, y3, z3);\n\t\t\tDirection3 line12Dir(line1.Location().X() - line2.Location().X(), \n\t\t\t\t\t\t\t\t line1.Location().Y() - line2.Location().Y(), line1.Location().Z() - line2.Location().Z());\n\t\t\treturn std::fabs(line3Dir.Dot(line12Dir));\n\t\t};\n\t\tLine3 line(Point3(99., 2., 33.), Direction3(2.3, 4.6, 9.8));\n\t\tCHECK(line.Distance(Point3(0., 1., 0.)) == Approx(pointToLine(Point3(0., 1., 0.), line)).margin(1e-5));\n\t\tLine3 line2(Point3(0., 0., 0.), Direction3(1., 0., 0.));\n\t\tLine3 line3(Point3(0., 1., 0.), Direction3(1., 0., 0.));\n\t\tCHECK(line2.Distance(line3) == Approx(lineToLine(line2, line3)).margin(std::numeric_limits<double>::min()));\n\t\tCHECK(line2.SquaredDistance(line3) == Approx(SQUARE(lineToLine(line2, line3))).margin(std::numeric_limits<double>::min()));\n\t\tLine3 line4(Point3(0., 0., 0.), Direction3(1., 0., 0.));\n\t\tLine3 line5(Point3(0., 1., 0.), Direction3(1., 1., 0.));\n\t\tCHECK(line4.Distance(line5) == Approx(lineToLine(line4, line5)).margin(std::numeric_limits<double>::min()));\n\t\tLine3 line6(Point3(0., 0., 0.), Direction3(0., 0., 1.));\n\t\tLine3 line7(Point3(0., 1., 0.), Direction3(1., 1., 0.));\n\t\tCHECK(line6.Distance(line7) == Approx(lineToLine(line6, line7)).margin(std::numeric_limits<double>::min()));\n\t}} "
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] auto Distance(const Point3& p)\t @return The distance between the point and the line\n\t @param p The point\n\t @brief Compute the distance from a point to the line\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <math/LineT.hpp>\n#include <math/Plane.hpp>\n#include <modeling/MakeFace.hpp>\n#include <modeling/MakeEdge.hpp>\nusing AMCAX::Line3;\nusing AMCAX::MakeEdge;\nusing AMCAX::MakeFace;\n#define ONE_RADIAN (M_PI / 180.)\n#define SQUARE(x) ((x) * (x))\nTEST_CASE(\"case1: Derived class interface unit testing\", \"[math][Line3][p1]\")\n{\n\tSECTION(\"Distance and SquaredDistance\")\n\t{\n\t\tauto pointToLine = [](const Point3& p, const Line3& line) {\n\t\t\tconst Point3& p1 = line.Location();\n\t\t\tdouble dX = p1.X() - p.X();\n\t\t\tdouble dY = p1.Y() - p.Y();\n\t\t\tdouble dZ = p1.Z() - p.Z();\n\t\t\tdouble pp1Square = SQUARE(dX) + SQUARE(dY) + SQUARE(dZ);\n\t\t\tDirection3 dir(dX, dY, dZ);\n\t\t\tdouble cos = std::fabs(dir.Dot(line.Direction()));\n\t\t\treturn std::sqrt(pp1Square - SQUARE(cos*std::sqrt(pp1Square)));\n\t\t};\n\t\tauto lineToLine = [&pointToLine](const Line3& line1, const Line3& line2) {\n\t\t\tif (line1.Direction().IsParallel(line2.Direction(), std::numeric_limits<double>::min()))\n\t\t\t\treturn pointToLine(line1.Location(), line2);\n\t\t\tDirection3 line1Dir = line1.Direction();\n\t\t\tDirection3 line2Dir = line2.Direction();\n\t\t\tdouble x3 = line1Dir.Y() * line2Dir.Z() - line2Dir.Y() * line1Dir.Z();\n\t\t\tdouble y3 = -(line1Dir.X() * line2Dir.Z() - line2Dir.X() * line1Dir.Z());\n\t\t\tdouble z3 = line1Dir.X() * line2Dir.Y() - line2Dir.X() * line1Dir.Y();\n\t\t\tDirection3 line3Dir(x3, y3, z3);\n\t\t\tDirection3 line12Dir(line1.Location().X() - line2.Location().X(), \n\t\t\t\t\t\t\t\t line1.Location().Y() - line2.Location().Y(), line1.Location().Z() - line2.Location().Z());\n\t\t\treturn std::fabs(line3Dir.Dot(line12Dir));\n\t\t};\n\t\tLine3 line(Point3(99., 2., 33.), Direction3(2.3, 4.6, 9.8));\n\t\tCHECK(line.Distance(Point3(0., 1., 0.)) == Approx(pointToLine(Point3(0., 1., 0.), line)).margin(1e-5));\n\t\tLine3 line2(Point3(0., 0., 0.), Direction3(1., 0., 0.));\n\t\tLine3 line3(Point3(0., 1., 0.), Direction3(1., 0., 0.));\n\t\tCHECK(line2.Distance(line3) == Approx(lineToLine(line2, line3)).margin(std::numeric_limits<double>::min()));\n\t\tCHECK(line2.SquaredDistance(line3) == Approx(SQUARE(lineToLine(line2, line3))).margin(std::numeric_limits<double>::min()));\n\t\tLine3 line4(Point3(0., 0., 0.), Direction3(1., 0., 0.));\n\t\tLine3 line5(Point3(0., 1., 0.), Direction3(1., 1., 0.));\n\t\tCHECK(line4.Distance(line5) == Approx(lineToLine(line4, line5)).margin(std::numeric_limits<double>::min()));\n\t\tLine3 line6(Point3(0., 0., 0.), Direction3(0., 0., 1.));\n\t\tLine3 line7(Point3(0., 1., 0.), Direction3(1., 1., 0.));\n\t\tCHECK(line6.Distance(line7) == Approx(lineToLine(line6, line7)).margin(std::numeric_limits<double>::min()));\n\t}} "
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] auto SquaredDistance(const LineS& l)\t @return The squared distance between two lines\n\t @param l The other line\n\t @brief Compute the squared distance between two lines\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <math/LineT.hpp>\n#include <math/Plane.hpp>\n#include <modeling/MakeFace.hpp>\n#include <modeling/MakeEdge.hpp>\nusing AMCAX::Line3;\nusing AMCAX::MakeEdge;\nusing AMCAX::MakeFace;\n#define ONE_RADIAN (M_PI / 180.)\n#define SQUARE(x) ((x) * (x))\nTEST_CASE(\"case1: Derived class interface unit testing\", \"[math][Line3][p1]\")\n{\n\tSECTION(\"Distance and SquaredDistance\")\n\t{\n\t\tauto pointToLine = [](const Point3& p, const Line3& line) {\n\t\t\tconst Point3& p1 = line.Location();\n\t\t\tdouble dX = p1.X() - p.X();\n\t\t\tdouble dY = p1.Y() - p.Y();\n\t\t\tdouble dZ = p1.Z() - p.Z();\n\t\t\tdouble pp1Square = SQUARE(dX) + SQUARE(dY) + SQUARE(dZ);\n\t\t\tDirection3 dir(dX, dY, dZ);\n\t\t\tdouble cos = std::fabs(dir.Dot(line.Direction()));\n\t\t\treturn std::sqrt(pp1Square - SQUARE(cos*std::sqrt(pp1Square)));\n\t\t};\n\t\tauto lineToLine = [&pointToLine](const Line3& line1, const Line3& line2) {\n\t\t\tif (line1.Direction().IsParallel(line2.Direction(), std::numeric_limits<double>::min()))\n\t\t\t\treturn pointToLine(line1.Location(), line2);\n\t\t\tDirection3 line1Dir = line1.Direction();\n\t\t\tDirection3 line2Dir = line2.Direction();\n\t\t\tdouble x3 = line1Dir.Y() * line2Dir.Z() - line2Dir.Y() * line1Dir.Z();\n\t\t\tdouble y3 = -(line1Dir.X() * line2Dir.Z() - line2Dir.X() * line1Dir.Z());\n\t\t\tdouble z3 = line1Dir.X() * line2Dir.Y() - line2Dir.X() * line1Dir.Y();\n\t\t\tDirection3 line3Dir(x3, y3, z3);\n\t\t\tDirection3 line12Dir(line1.Location().X() - line2.Location().X(), \n\t\t\t\t\t\t\t\t line1.Location().Y() - line2.Location().Y(), line1.Location().Z() - line2.Location().Z());\n\t\t\treturn std::fabs(line3Dir.Dot(line12Dir));\n\t\t};\n\t\tLine3 line(Point3(99., 2., 33.), Direction3(2.3, 4.6, 9.8));\n\t\tCHECK(line.Distance(Point3(0., 1., 0.)) == Approx(pointToLine(Point3(0., 1., 0.), line)).margin(1e-5));\n\t\tLine3 line2(Point3(0., 0., 0.), Direction3(1., 0., 0.));\n\t\tLine3 line3(Point3(0., 1., 0.), Direction3(1., 0., 0.));\n\t\tCHECK(line2.Distance(line3) == Approx(lineToLine(line2, line3)).margin(std::numeric_limits<double>::min()));\n\t\tCHECK(line2.SquaredDistance(line3) == Approx(SQUARE(lineToLine(line2, line3))).margin(std::numeric_limits<double>::min()));\n\t\tLine3 line4(Point3(0., 0., 0.), Direction3(1., 0., 0.));\n\t\tLine3 line5(Point3(0., 1., 0.), Direction3(1., 1., 0.));\n\t\tCHECK(line4.Distance(line5) == Approx(lineToLine(line4, line5)).margin(std::numeric_limits<double>::min()));\n\t\tLine3 line6(Point3(0., 0., 0.), Direction3(0., 0., 1.));\n\t\tLine3 line7(Point3(0., 1., 0.), Direction3(1., 1., 0.));\n\t\tCHECK(line6.Distance(line7) == Approx(lineToLine(line6, line7)).margin(std::numeric_limits<double>::min()));\n\t}} "
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] auto Distance(const LineS& l)\t @return The distance between two lines\n\t @param l The other line\n\t @brief Compute the distance between two lines\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <math/LineT.hpp>\n#include <math/Plane.hpp>\n#include <modeling/MakeFace.hpp>\n#include <modeling/MakeEdge.hpp>\nusing AMCAX::Line3;\nusing AMCAX::MakeEdge;\nusing AMCAX::MakeFace;\n#define ONE_RADIAN (M_PI / 180.)\n#define SQUARE(x) ((x) * (x))\nTEST_CASE(\"case1: Derived class interface unit testing\", \"[math][Line3][p1]\")\n{\n\tSECTION(\"Distance and SquaredDistance\")\n\t{\n\t\tauto pointToLine = [](const Point3& p, const Line3& line) {\n\t\t\tconst Point3& p1 = line.Location();\n\t\t\tdouble dX = p1.X() - p.X();\n\t\t\tdouble dY = p1.Y() - p.Y();\n\t\t\tdouble dZ = p1.Z() - p.Z();\n\t\t\tdouble pp1Square = SQUARE(dX) + SQUARE(dY) + SQUARE(dZ);\n\t\t\tDirection3 dir(dX, dY, dZ);\n\t\t\tdouble cos = std::fabs(dir.Dot(line.Direction()));\n\t\t\treturn std::sqrt(pp1Square - SQUARE(cos*std::sqrt(pp1Square)));\n\t\t};\n\t\tauto lineToLine = [&pointToLine](const Line3& line1, const Line3& line2) {\n\t\t\tif (line1.Direction().IsParallel(line2.Direction(), std::numeric_limits<double>::min()))\n\t\t\t\treturn pointToLine(line1.Location(), line2);\n\t\t\tDirection3 line1Dir = line1.Direction();\n\t\t\tDirection3 line2Dir = line2.Direction();\n\t\t\tdouble x3 = line1Dir.Y() * line2Dir.Z() - line2Dir.Y() * line1Dir.Z();\n\t\t\tdouble y3 = -(line1Dir.X() * line2Dir.Z() - line2Dir.X() * line1Dir.Z());\n\t\t\tdouble z3 = line1Dir.X() * line2Dir.Y() - line2Dir.X() * line1Dir.Y();\n\t\t\tDirection3 line3Dir(x3, y3, z3);\n\t\t\tDirection3 line12Dir(line1.Location().X() - line2.Location().X(), \n\t\t\t\t\t\t\t\t line1.Location().Y() - line2.Location().Y(), line1.Location().Z() - line2.Location().Z());\n\t\t\treturn std::fabs(line3Dir.Dot(line12Dir));\n\t\t};\n\t\tLine3 line(Point3(99., 2., 33.), Direction3(2.3, 4.6, 9.8));\n\t\tCHECK(line.Distance(Point3(0., 1., 0.)) == Approx(pointToLine(Point3(0., 1., 0.), line)).margin(1e-5));\n\t\tLine3 line2(Point3(0., 0., 0.), Direction3(1., 0., 0.));\n\t\tLine3 line3(Point3(0., 1., 0.), Direction3(1., 0., 0.));\n\t\tCHECK(line2.Distance(line3) == Approx(lineToLine(line2, line3)).margin(std::numeric_limits<double>::min()));\n\t\tCHECK(line2.SquaredDistance(line3) == Approx(SQUARE(lineToLine(line2, line3))).margin(std::numeric_limits<double>::min()));\n\t\tLine3 line4(Point3(0., 0., 0.), Direction3(1., 0., 0.));\n\t\tLine3 line5(Point3(0., 1., 0.), Direction3(1., 1., 0.));\n\t\tCHECK(line4.Distance(line5) == Approx(lineToLine(line4, line5)).margin(std::numeric_limits<double>::min()));\n\t\tLine3 line6(Point3(0., 0., 0.), Direction3(0., 0., 1.));\n\t\tLine3 line7(Point3(0., 1., 0.), Direction3(1., 1., 0.));\n\t\tCHECK(line6.Distance(line7) == Approx(lineToLine(line6, line7)).margin(std::numeric_limits<double>::min()));\n\t}} "
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] Derived Reversed()\t @return The line with reversed direction\n\t @brief Get the line with reversed direction\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <math/LineT.hpp>\n#include <math/Plane.hpp>\n#include <modeling/MakeFace.hpp>\n#include <modeling/MakeEdge.hpp>\nusing AMCAX::Line3;\nusing AMCAX::MakeEdge;\nusing AMCAX::MakeFace;\n#define ONE_RADIAN (M_PI / 180.)\n#define SQUARE(x) ((x) * (x))\nTEST_CASE(\"case2: Line3 base method Test\", \"[math][Line3][p1]\")\n{\n\tSECTION(\"Reverse\")\n\t{\n\t\tLine3 line(Point3(), Direction3(1., 1., 1.));\n\t\tLine3 reverseLine = line.Reversed();\n\t\tCHECK(reverseLine.Direction().IsEqual(Direction3(-1., -1., -1.), 1e-6 * ONE_RADIAN));\n\t}} "
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] auto Angle(const LineBase& other)\t @return The angle between the line and the other line\n\t @param other The other line\n\t @brief Compute the angle between the line and the other line\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <math/LineT.hpp>\n#include <math/Plane.hpp>\n#include <modeling/MakeFace.hpp>\n#include <modeling/MakeEdge.hpp>\nusing AMCAX::Line3;\nusing AMCAX::MakeEdge;\nusing AMCAX::MakeFace;\n#define ONE_RADIAN (M_PI / 180.)\n#define SQUARE(x) ((x) * (x))\nTEST_CASE(\"case2: Line3 base method Test\", \"[math][Line3][p1]\")\n{\n\tSECTION(\"Angle\")\n\t{\n\t\tLine3 line(Point3(0., 1., 0.), Direction3(1., 1., 1.));\n\t\tLine3 line2(Point3(0., 3.4, 0.), Direction3(2., -1., -1.5));\n\t\tCHECK(line.Angle(line2) == Approx(std::acos(line.Direction().Dot(line2.Direction()))).margin(1e-6 * ONE_RADIAN));\n\t}} "
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] const AxisT<double, DIM>& Position()\t @return The axis of the line\n\t @brief Get the axis of the line\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <math/LineT.hpp>\n#include <math/Plane.hpp>\n#include <modeling/MakeFace.hpp>\n#include <modeling/MakeEdge.hpp>\nusing AMCAX::Line3;\nusing AMCAX::MakeEdge;\nusing AMCAX::MakeFace;\n#define ONE_RADIAN (M_PI / 180.)\n#define SQUARE(x) ((x) * (x))\nTEST_CASE(\"case1: Derived class interface unit testing\", \"[math][Line3][p1]\")\n{\n\tSECTION(\"constructor\")\n\t{\n\t\tLine3 line;  \n\t\tCHECK(line.Location().IsEqual(Point3(0., 0., 0.), 1e-5));\n\t\tCHECK(line.Direction().IsEqual(Direction3(0., 0., 1.), 1e-5 * ONE_RADIAN));\n\t\tAxis3 axis(Point3(1., 1., 1.), Direction3(3., 3., 4.));\n\t\tLine3 line2(axis);\n\t\tCHECK(line2.Position().IsCoaxial(axis, 1e-5 * ONE_RADIAN, 1e-5));  \n\t\tLine3 line3(Point3(1., 2., 3.), Direction3(3., 2., 1.));\n\t\tCHECK(line3.Location().IsEqual(Point3(1., 2., 3.), 1e-5));\n\t\tCHECK(line3.Direction().IsEqual(Direction3(3., 2., 1.), 1e-5 * ONE_RADIAN));\n\t}} "
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] const DirectionT<double, DIM>& Direction()\t @return The direction of the line\n\t @brief Get the direction of the line\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <math/LineT.hpp>\n#include <math/Plane.hpp>\n#include <modeling/MakeFace.hpp>\n#include <modeling/MakeEdge.hpp>\nusing AMCAX::Line3;\nusing AMCAX::MakeEdge;\nusing AMCAX::MakeFace;\n#define ONE_RADIAN (M_PI / 180.)\n#define SQUARE(x) ((x) * (x))\nTEST_CASE(\"case1: Derived class interface unit testing\", \"[math][Line3][p1]\")\n{\n\tSECTION(\"constructor\")\n\t{\n\t\tLine3 line;  \n\t\tCHECK(line.Location().IsEqual(Point3(0., 0., 0.), 1e-5));\n\t\tCHECK(line.Direction().IsEqual(Direction3(0., 0., 1.), 1e-5 * ONE_RADIAN));\n\t\tAxis3 axis(Point3(1., 1., 1.), Direction3(3., 3., 4.));\n\t\tLine3 line2(axis);\n\t\tCHECK(line2.Position().IsCoaxial(axis, 1e-5 * ONE_RADIAN, 1e-5));  \n\t\tLine3 line3(Point3(1., 2., 3.), Direction3(3., 2., 1.));\n\t\tCHECK(line3.Location().IsEqual(Point3(1., 2., 3.), 1e-5));\n\t\tCHECK(line3.Direction().IsEqual(Direction3(3., 2., 1.), 1e-5 * ONE_RADIAN));\n\t}} "
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "void SetPosition(const AxisT<double, DIM>& axis)\t @param axis The axis\n\t @brief Set the axis of the line\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <math/LineT.hpp>\n#include <math/Plane.hpp>\n#include <modeling/MakeFace.hpp>\n#include <modeling/MakeEdge.hpp>\nusing AMCAX::Line3;\nusing AMCAX::MakeEdge;\nusing AMCAX::MakeFace;\n#define ONE_RADIAN (M_PI / 180.)\n#define SQUARE(x) ((x) * (x))\nTEST_CASE(\"case2: Line3 base method Test\", \"[math][Line3][p1]\")\n{\n\tSECTION(\"SetPosition\")\n\t{\n\t\tAxis3 axis(Point3(0.1, -2.3, 0.3), Direction3(1.2, -8.9, 3.));\n\t\tLine3 line;\n\t\tline.SetPosition(axis);\n\t\tCHECK(line.Location().IsEqual(axis.Location(), std::numeric_limits<double>::min()));\n\t\tCHECK(line.Direction().IsEqual(axis.Direction(), std::numeric_limits<double>::min()));\n\t}} "
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "void SetDirection(const DirectionT<double, DIM>& dir)\t @param dir The line direction\n\t @brief Set the line direction\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <math/LineT.hpp>\n#include <math/Plane.hpp>\n#include <modeling/MakeFace.hpp>\n#include <modeling/MakeEdge.hpp>\nusing AMCAX::Line3;\nusing AMCAX::MakeEdge;\nusing AMCAX::MakeFace;\n#define ONE_RADIAN (M_PI / 180.)\n#define SQUARE(x) ((x) * (x))\nTEST_CASE(\"case2: Line3 base method Test\", \"[math][Line3][p1]\")\n{\n\tSECTION(\"SetDirection\")\n\t{\n\t\tDirection3 dir(1., 1., 1.);\n\t\tLine3 line;\n\t\tline.SetDirection(dir);\n\t\tCHECK(line.Direction().IsEqual(dir, std::numeric_limits<double>::min()));\n\t}} "
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "void SetLocation(const PointT<double, DIM>& point)\t @param point The location point\n\t @brief Set the location of the line\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <math/LineT.hpp>\n#include <math/Plane.hpp>\n#include <modeling/MakeFace.hpp>\n#include <modeling/MakeEdge.hpp>\nusing AMCAX::Line3;\nusing AMCAX::MakeEdge;\nusing AMCAX::MakeFace;\n#define ONE_RADIAN (M_PI / 180.)\n#define SQUARE(x) ((x) * (x))\nTEST_CASE(\"case2: Line3 base method Test\", \"[math][Line3][p1]\")\n{\n\tSECTION(\"SetLocation\")\n\t{\n\t\tLine3 line(Point3(2., 3., 2.), Direction3(2., 3.4, -2.));\n\t\tline.SetLocation(Point3(1., -2., 8.));\n\t\tCHECK(line.Location().IsEqual(Point3(1., -2., 8.), std::numeric_limits<double>::min()));\n\t}} "
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] Derived Translated(const VectorT<double, DIM>& vec)\t @return The translated line\n\t @param vec The translation vector\n\t @brief Get the line translated by a vector\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <math/LineT.hpp>\n#include <math/Plane.hpp>\n#include <modeling/MakeFace.hpp>\n#include <modeling/MakeEdge.hpp>\nusing AMCAX::Line3;\nusing AMCAX::MakeEdge;\nusing AMCAX::MakeFace;\n#define ONE_RADIAN (M_PI / 180.)\n#define SQUARE(x) ((x) * (x))\nTEST_CASE(\"case2: Line3 base method Test\", \"[math][Line3][p1]\")\n{\n\tSECTION(\"Translate\")\n\t{\n\t\tLine3 line(Point3(), Direction3(1., 1., 1.));\n\t\tLine3 originalLine(Point3(), Direction3(1., 1., 1.));\n\t\tline.Translate(Point3(), Point3(0., 1., 0.));\n\t\tCHECK(originalLine.Direction().IsEqual(line.Direction(), 1e-6 * ONE_RADIAN));\n\t\tCHECK(line.Contains(Point3(0., 1., 0.), 1e-6));\n\t\tLine3 line2 = line.Translated(Vector3(Direction3(1., -1., 1.)));\n\t\tCHECK(line.Direction().IsEqual(line2.Direction(), 1e-6 * ONE_RADIAN));\n\t\tCHECK(line2.Contains(Point3(0. + 1. / std::sqrt(3.), 1 - 1. / std::sqrt(3.), 0. + 1. / std::sqrt(3.)), 1e-6));\n\t}\n}} "
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "Derived& Translate(const PointT<double, DIM>& p1, const PointT<double, DIM>& p2)\t @return The reference to self\n\t @param p2 The target point\n\t @param p1 The source point\n\t @brief Translate the line by a vector from a point to another point\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <math/LineT.hpp>\n#include <math/Plane.hpp>\n#include <modeling/MakeFace.hpp>\n#include <modeling/MakeEdge.hpp>\nusing AMCAX::Line3;\nusing AMCAX::MakeEdge;\nusing AMCAX::MakeFace;\n#define ONE_RADIAN (M_PI / 180.)\n#define SQUARE(x) ((x) * (x))\nTEST_CASE(\"case2: Line3 base method Test\", \"[math][Line3][p1]\")\n{\n\tSECTION(\"Translate\")\n\t{\n\t\tLine3 line(Point3(), Direction3(1., 1., 1.));\n\t\tLine3 originalLine(Point3(), Direction3(1., 1., 1.));\n\t\tline.Translate(Point3(), Point3(0., 1., 0.));\n\t\tCHECK(originalLine.Direction().IsEqual(line.Direction(), 1e-6 * ONE_RADIAN));\n\t\tCHECK(line.Contains(Point3(0., 1., 0.), 1e-6));\n\t\tLine3 line2 = line.Translated(Vector3(Direction3(1., -1., 1.)));\n\t\tCHECK(line.Direction().IsEqual(line2.Direction(), 1e-6 * ONE_RADIAN));\n\t\tCHECK(line2.Contains(Point3(0. + 1. / std::sqrt(3.), 1 - 1. / std::sqrt(3.), 0. + 1. / std::sqrt(3.)), 1e-6));\n\t}\n}} "
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] Derived Scaled(const PointT<double, DIM>& point, double scale)\t @return The scaled line\n\t @param scale The scale value\n\t @param point The scaling center point\n\t @brief Get the line scaled by a point\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <math/LineT.hpp>\n#include <math/Plane.hpp>\n#include <modeling/MakeFace.hpp>\n#include <modeling/MakeEdge.hpp>\nusing AMCAX::Line3;\nusing AMCAX::MakeEdge;\nusing AMCAX::MakeFace;\n#define ONE_RADIAN (M_PI / 180.)\n#define SQUARE(x) ((x) * (x))\nTEST_CASE(\"case2: Line3 base method Test\", \"[math][Line3][p1]\")\n{\n\tSECTION(\"Scale\")\n\t{\n\t\tLine3 line(Point3(), Direction3(0., 1., 0.));\n\t\tPoint3 point(1., 1., 0.);\n\t\tdouble originalDistance = line.Distance(point);\n\t\tLine3 line1 = line.Scaled(point, 1.1);\n\t\tCHECK(line1.Distance(point) > originalDistance);\n\t\tLine3 line2 = line.Scaled(point, 1.);\n\t\tCHECK(line2.Distance(point) == originalDistance);\n\t\tLine3 line3 = line.Scaled(point, 0.8);\n\t\tCHECK(line3.Distance(point) < originalDistance);\n\t\tLine3 line4 = line.Scaled(point, 0.);\n\t\tCHECK(line4.Contains(point, 1e-6));\n\t\tLine3 line5 = line.Scaled(point, -1.);\n\t\tCHECK(line5.Direction().IsEqual(Direction3(0., -1., 0.), 1e-6 * ONE_RADIAN));\n\t}} "
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] const PointT<double, DIM>& Location()\t @return The location of the line\n\t @brief Get the location point of the line\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <math/LineT.hpp>\n#include <math/Plane.hpp>\n#include <modeling/MakeFace.hpp>\n#include <modeling/MakeEdge.hpp>\nusing AMCAX::Line3;\nusing AMCAX::MakeEdge;\nusing AMCAX::MakeFace;\n#define ONE_RADIAN (M_PI / 180.)\n#define SQUARE(x) ((x) * (x))\nTEST_CASE(\"case1: Derived class interface unit testing\", \"[math][Line3][p1]\")\n{\n\tSECTION(\"constructor\")\n\t{\n\t\tLine3 line;  \n\t\tCHECK(line.Location().IsEqual(Point3(0., 0., 0.), 1e-5));\n\t\tCHECK(line.Direction().IsEqual(Direction3(0., 0., 1.), 1e-5 * ONE_RADIAN));\n\t\tAxis3 axis(Point3(1., 1., 1.), Direction3(3., 3., 4.));\n\t\tLine3 line2(axis);\n\t\tCHECK(line2.Position().IsCoaxial(axis, 1e-5 * ONE_RADIAN, 1e-5));  \n\t\tLine3 line3(Point3(1., 2., 3.), Direction3(3., 2., 1.));\n\t\tCHECK(line3.Location().IsEqual(Point3(1., 2., 3.), 1e-5));\n\t\tCHECK(line3.Direction().IsEqual(Direction3(3., 2., 1.), 1e-5 * ONE_RADIAN));\n\t}} "
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] bool Contains(const PointT<double, DIM>& p, double tol)\t @return True if the point is on the line under the tolerance\n\t @param tol The tolerance\n\t @param p The point\n\t @brief Does the line contain a point under a distance tolerance\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <math/LineT.hpp>\n#include <math/Plane.hpp>\n#include <modeling/MakeFace.hpp>\n#include <modeling/MakeEdge.hpp>\nusing AMCAX::Line3;\nusing AMCAX::MakeEdge;\nusing AMCAX::MakeFace;\n#define ONE_RADIAN (M_PI / 180.)\n#define SQUARE(x) ((x) * (x))\nTEST_CASE(\"case2: Line3 base method Test\", \"[math][Line3][p1]\")\n{\n\tSECTION(\"Translate\")\n\t{\n\t\tLine3 line(Point3(), Direction3(1., 1., 1.));\n\t\tLine3 originalLine(Point3(), Direction3(1., 1., 1.));\n\t\tline.Translate(Point3(), Point3(0., 1., 0.));\n\t\tCHECK(originalLine.Direction().IsEqual(line.Direction(), 1e-6 * ONE_RADIAN));\n\t\tCHECK(line.Contains(Point3(0., 1., 0.), 1e-6));\n\t\tLine3 line2 = line.Translated(Vector3(Direction3(1., -1., 1.)));\n\t\tCHECK(line.Direction().IsEqual(line2.Direction(), 1e-6 * ONE_RADIAN));\n\t\tCHECK(line2.Contains(Point3(0. + 1. / std::sqrt(3.), 1 - 1. / std::sqrt(3.), 0. + 1. / std::sqrt(3.)), 1e-6));\n\t}\n}} "
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] double SemilatusRectum()\t @return The semilatus rectum\n\t          Semilatus rectum = 2 * focalLength\n\t @details The semilatus rectum of parabola is half of the length of the chord through a focus parallel to the directrix.\n\t @brief Get the semilatus rectum of the parabola\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <geometry/Geom2Parabola.hpp>\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Test Geom2Parabola\", \"[math][Geom2Parabola][P1]\")\n{\n\tAxis2 axis;\n\tdouble focal = 5.0;\n\tbool isRight = true;\n\tGeom2Parabola g2p(axis, focal, isRight);\n\tSECTION(\"SemilatusRectum\")\n\t{\n\t\tdouble SR = g2p.SemilatusRectum();\n\t\tdouble sr = 2 * focal;\n\t\tCHECK(SR == sr);\n\t}\n}}\n}\n,\n{\n "
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] double FocalParameter()\t @return The focal parameter\n\t          Focal parameter = 2 * focalLength.\n\t @details The focal parameter of parabola is the distance from the focus to the directrix.\n\t @brief Get the focal parameter of the parabola\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <geometry/Geom2Parabola.hpp>\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Test Geom2Parabola\", \"[math][Geom2Parabola][P1]\")\n{\n\tAxis2 axis;\n\tdouble focal = 5.0;\n\tbool isRight = true;\n\tGeom2Parabola g2p(axis, focal, isRight);\n\tSECTION(\"FocalParameter\")\n\t{\n\t\tdouble FP = g2p.FocalParameter();\n\t\tdouble fp = 2 * focal;\n\t\tCHECK(FP == fp);\n\t}} "
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] double SemilatusRectum()\t @return The semilatus rectum\n\t          Semilatus rectum = 2 * focalLength\n\t @details The semilatus rectum of parabola is half of the length of the chord through a focus parallel to the directrix.\n\t @brief Get the semilatus rectum of the parabola\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <geometry/Geom3Parabola.hpp>\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Test Geom3Parabola\", \"[math][Geom3Parabola][P1]\")\n{\n\tFrame3 frame;\n\tdouble focal = 5.0;\n\tGeom3Parabola g3p(frame, focal);\n\tSECTION(\"SemilatusRectum\")\n\t{\n\t\tdouble SR = g3p.SemilatusRectum();\n\t\tdouble sr = 2 * focal;\n\t\tCHECK(SR == sr);\n\t}\n}}\n}\n,\n{\n "
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] double FocalParameter()\t @return The focal parameter\n\t          Focal parameter = 2 * focalLength.\n\t @details The focal parameter of parabola is the distance from the focus to the directrix.\n\t @brief Get the focal parameter of the parabola\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <geometry/Geom3Parabola.hpp>\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Test Geom3Parabola\", \"[math][Geom3Parabola][P1]\")\n{\n\tFrame3 frame;\n\tdouble focal = 5.0;\n\tGeom3Parabola g3p(frame, focal);\n\tSECTION(\"FocalParameter\")\n\t{\n\t\tdouble FP = g3p.FocalParameter();\n\t\tdouble fp = 2 * focal;\n\t\tCHECK(FP == fp);\n\t}} "
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] double SemilatusRectum()\t @return The semilatus rectum\n\t          Semilatus rectum = 2 * focalLength\n\t @details The semilatus rectum of parabola is half of the length of the chord through a focus parallel to the directrix.\n\t @brief Get the semilatus rectum of the parabola\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <math/ParabolaT.hpp>\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Test Parabola2\", \"[math][Parabola2][P1]\")\n{\n\tAxis2 axis;\n\tdouble focal = 5.0;\n\tbool isRight = true;\n\tParabola2 parabola(axis, focal, isRight);\n\tSECTION(\"SemilatusRectum\")\n\t{\n\t\tdouble SR = parabola.SemilatusRectum();\n\t\tdouble sr = 2 * focal;\n\t\tCHECK(SR == sr);\n\t}\n}}\n}\n,\n{\n "
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] double FocalParameter()\t @return The focal parameter\n\t          Focal parameter = 2 * focalLength.\n\t @details The focal parameter of parabola is the distance from the focus to the directrix.\n\t @brief Get the focal parameter of the parabola\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <math/ParabolaT.hpp>\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Test Parabola2\", \"[math][Parabola2][P1]\")\n{\n\tAxis2 axis;\n\tdouble focal = 5.0;\n\tbool isRight = true;\n\tParabola2 parabola(axis, focal, isRight);\n\tSECTION(\"FocalParameter\")\n\t{\n\t\tdouble FP = parabola.FocalParameter();\n\t\tdouble fp = 2 * focal;\n\t\tCHECK(FP == fp);\n\t}} "
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] double SemilatusRectum()\t @return The semilatus rectum\n\t          Semilatus rectum = 2 * focalLength\n\t @details The semilatus rectum of parabola is half of the length of the chord through a focus parallel to the directrix.\n\t @brief Get the semilatus rectum of the parabola\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <math/ParabolaT.hpp>\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Test Parabola3\", \"[math][Parabola3][P1]\")\n{\n\tFrame3 frame;\n\tdouble focal = 5.0;\n\tParabola3 parabola(frame, focal);\n\tSECTION(\"SemilatusRectum\")\n\t{\n\t\tdouble SR = parabola.SemilatusRectum();\n\t\tdouble sr = 2 * focal;\n\t\tCHECK(SR == sr);\n\t}\n}}\n}\n,\n{\n "
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] double FocalParameter()\t @return The focal parameter\n\t          Focal parameter = 2 * focalLength.\n\t @details The focal parameter of parabola is the distance from the focus to the directrix.\n\t @brief Get the focal parameter of the parabola\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <math/ParabolaT.hpp>\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Test Parabola3\", \"[math][Parabola3][P1]\")\n{\n\tFrame3 frame;\n\tdouble focal = 5.0;\n\tParabola3 parabola(frame, focal);\n\tSECTION(\"FocalParameter\")\n\t{\n\t\tdouble FP = parabola.FocalParameter();\n\t\tdouble fp = 2 * focal;\n\t\tCHECK(FP == fp);\n\t}} "
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] AMCAX_API bool Contains(const Point3& point, double tol)\t @return True if the distance between the point and the plane is under the distance tolerance\n\t @param tol The distance tolerance\n\t @param point The point\n\t @brief Determines whether the plane contains a point under a tolerance or not\n,\n",
      "output": "#include \"catch.hpp\"\n#include <testHelper.h>\n#include <math/Plane.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"case1: Plane construction and methods\", \"[math][Plane][p1]\") {\n\tSECTION(\"Contains methods\") {\n        std::function<bool(const Plane&, const Point3&)> pointInPlane = [](const Plane& plane, const Point3& point)->bool {\n            Point3 planePoint = plane.Location();  \n            Vector3 planeVector(planePoint, point);  \n            double a, b, c, d;\n            plane.Coefficients(a, b, c, d);\n            return planeVector.Dot(Vector3(a, b, c)) == 0;\n        };\n        Plane plane(0., 0., 1., -1.); \n        Point3 point(1., 1., 1.);\n        Point3 point2(1., 1., 2.);\n        Line3 line(Point3(1., 1., 1.), Direction3(1., 0., 0.));\n        Line3 line2(Point3(1., 1., 1.), Direction3(0., 0., 1.));  \n        Line3 line3(Point3(1., 1., 0.), Direction3(1., 0., 0.));\n        REQUIRE(plane.Contains(point, 1e-6) == pointInPlane(plane, point));\n        REQUIRE(plane.Contains(point2, 1e-6) == pointInPlane(plane, point2));\n        REQUIRE(plane.Contains(line, 1e-6, 1e-6));\n        REQUIRE_FALSE(plane.Contains(line2, 1e-6, 1e-6 * (M_PI / 180)));\n        REQUIRE_FALSE(plane.Contains(line3, 1e-6, 1e-6 * (M_PI / 180)));\n    }}\n}\n,\n{\n "
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] AMCAX_API double SquaredDistance(const Point3& point)\t @return The squared point-plane distance\n\t @param point The point\n\t @brief Compute the squared distance from a point to the plane\n,\n",
      "output": "#include \"catch.hpp\"\n#include <testHelper.h>\n#include <math/Plane.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"case1: Plane construction and methods\", \"[math][Plane][p1]\") {\n\tSECTION(\"Distance methods\") {\n        std::function<double(const Plane&, const Point3&)> pointToPlane = [](const Plane& plane, const Point3& point)->double {\n            double a, b, c, d;\n            plane.Coefficients(a, b, c, d);\n            return std::fabs(a * point.X() + b * point.Y() + c * point.Z() + d);\n        };\n        std::function<double(const Plane&, const Line3&)> lineToPlane = [](const Plane& plane, const Line3& line)->double {\n            Point3 point = line.Location();\n            double a, b, c, d;\n            plane.Coefficients(a, b, c, d);\n            if (line.Direction().Dot(Vector3(a, b, c)) != 0)  \n                return 0;\n            return std::fabs(a * point.X() + b * point.Y() + c * point.Z() + d);\n        };\n        std::function<double(const Plane&, const Plane&)> planeToPlane = [](const Plane& plane1, const Plane& plane2)->double {\n            double a1, b1, c1, d1, a2, b2, c2, d2;\n            plane1.Coefficients(a1, b1, c1, d1);\n            plane2.Coefficients(a2, b2, c2, d2);\n            if (a1 != a2 || b1 != b2 || c1 != c2) return 0;\n            return std::fabs(d1 - d2);\n        };\n        Plane plane(0., 0., 1., -1.); \n        Point3 point(1., 1., 2.);\n        Line3 line(Point3(1., 1., 3.), Direction3(0., 0., 1.));\n        Plane otherPlane1(0, 0, 1, -2); \n        Plane otherPlane2(1, 0, 1, -2); \n        REQUIRE(plane.Distance(point) == Approx(pointToPlane(plane, point)));\n        REQUIRE(plane.SquaredDistance(point) == Approx(pointToPlane(plane, point) * pointToPlane(plane, point)));\n        REQUIRE(plane.Distance(line) == Approx(lineToPlane(plane, line)));\n        REQUIRE(plane.SquaredDistance(line) == Approx(lineToPlane(plane, line) * lineToPlane(plane, line)));\n        REQUIRE(plane.Distance(otherPlane1) == Approx(planeToPlane(plane, otherPlane1)));\n        REQUIRE(plane.SquaredDistance(otherPlane1) == Approx(planeToPlane(plane, otherPlane1) * planeToPlane(plane, otherPlane1)));\n        REQUIRE(plane.Distance(otherPlane2) == Approx(planeToPlane(plane, otherPlane2)));\n        REQUIRE(plane.SquaredDistance(otherPlane2) == Approx(planeToPlane(plane, otherPlane2) * planeToPlane(plane, otherPlane2)));\n    }} "
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API Plane(double a, double b, double c, double d)\t @param a,b,c,d The coefficients\n\t @brief Construct from an algebraic representation: ax + by + cz + d = 0\n,\n",
      "output": "#include \"catch.hpp\"\n#include <testHelper.h>\n#include <math/Plane.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"case1: Plane construction and methods\", \"[math][Plane][p1]\") {\n\tSECTION(\"Construct from algebraic representation\") {\n        Plane plane(1., 1., 1., -3.);  \n        double a, b, c, d;\n        plane.Coefficients(a, b, c, d);  \n        REQUIRE(a == Approx(1./std::sqrt(3)).margin(0.001));\n        REQUIRE(b == Approx(1. / std::sqrt(3)).margin(0.001));\n        REQUIRE(c == Approx(1. / std::sqrt(3)).margin(0.001));\n        REQUIRE(d == Approx(-3. / std::sqrt(3)).margin(0.001));\n    }} "
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API Plane(const Point3& point, const Direction3& dir)\t @param dir The direction\n\t @param point The point\n\t @brief Construct from a point and a direction\n,\n",
      "output": "#include \"catch.hpp\"\n#include <testHelper.h>\n#include <math/Plane.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"case1: Plane construction and methods\", \"[math][Plane][p1]\") {\n\tSECTION(\"Construct from point and direction\") {\n        Point3 point(1., 1., 1.);\n        Direction3 dir(0., 0., 1.);\n        Plane plane(point, dir);  \n        Point3 point2(3., 4., 4.);\n        Direction3 dir2(2., 2., 1.);\n        Plane plane2(point2, dir2);  \n        double a, b, c, d;\n        plane.Coefficients(a, b, c, d);\n        double a2, b2, c2, d2;\n        plane2.Coefficients(a2, b2, c2, d2);\n        REQUIRE(a == Approx(0));\n        REQUIRE(b == Approx(0));\n        REQUIRE(c == Approx(1));\n        REQUIRE(d == Approx(-1));\n        REQUIRE(a2 == Approx(2./3).margin(0.0001));\n        REQUIRE(b2 == Approx(2./3).margin(0.0001));\n        REQUIRE(c2 == Approx(1./3).margin(0.0001));\n        REQUIRE(d2 == Approx(-6));\n    }} "
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API explicit Plane(const Frame3& frame)\t @param frame The local frame\n\t @brief Construct from a local frame, XOY plane\n,\n",
      "output": "#include \"catch.hpp\"\n#include <testHelper.h>\n#include <math/Plane.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"case1: Plane construction and methods\", \"[math][Plane][p1]\") {\n\tSECTION(\"Construct from frame\") {\n        Frame3 frame1(Point3(0.0, 0.0, 0.0), Direction3(0.0, 0.0, 1.0));\n        Frame3 frame2(Point3(1.0, 0.0, 0.0), Direction3(2.0, 1.0, 1.0));\n        Plane plane1(frame1);\n        Plane plane2(frame2);  \n        double a1, b1, c1, d1;\n        plane1.Coefficients(a1, b1, c1, d1);\n        double a2, b2, c2, d2;\n        plane2.Coefficients(a2, b2, c2, d2);\n        REQUIRE(a1 == Approx(0));\n        REQUIRE(b1 == Approx(0));\n        REQUIRE(c1 == Approx(1));\n        REQUIRE(d1 == Approx(0));\n        REQUIRE(a2 == Approx(2. / std::sqrt(6)));\n        REQUIRE(b2 == Approx(1. / std::sqrt(6)));\n        REQUIRE(c2 == Approx(1. / std::sqrt(6)));\n        REQUIRE(d2 == Approx(-2. / std::sqrt(6)));\n    }} "
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "Plane()\t Default constructor\n,\n",
      "output": "#include \"catch.hpp\"\n#include <testHelper.h>\n#include <math/Plane.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"case1: Plane construction and methods\", \"[math][Plane][p1]\") {\n\tSECTION(\"Default constructor\") {\n        Plane plane;\n        double a, b, c, d;\n        plane.Coefficients(a, b, c, d);\n        REQUIRE(a == Approx(0));\n        REQUIRE(b == Approx(0));\n        REQUIRE(c == Approx(1));\n        REQUIRE(d == Approx(0));\n    }} "
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API void Coefficients(double& a, double& b, double& c, double& d)\t @param[out] a,b,c,d The coefficients\n\t @brief Get coefficients of algebraic representation: ax + by + cz + d = 0\n,\n",
      "output": "#include \"catch.hpp\"\n#include <testHelper.h>\n#include <math/Plane.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"case1: Plane construction and methods\", \"[math][Plane][p1]\") {\n\tSECTION(\"Default constructor\") {\n        Plane plane;\n        double a, b, c, d;\n        plane.Coefficients(a, b, c, d);\n        REQUIRE(a == Approx(0));\n        REQUIRE(b == Approx(0));\n        REQUIRE(c == Approx(1));\n        REQUIRE(d == Approx(0));\n    }} "
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] AMCAX_API static Point3 CircleValue(double u, const Frame3& pos, double radius)\t @return The point\n\t @param radius The radius\n\t @param pos The local frame where the circle lies\n\t @param u The parameter\n\t @brief Compute the point on a 3D circle represented by a local frame and a radius at a parameter\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <common/PointT.hpp>\n#include <math/CurveCalculation.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"case1: CurveCalculation::CircleD2 3/4 \", \"[math][CurveCalculation][P1][CircleD2]\") {\n\tDirection3 initialDir(0.0, 0.0, 1.0); \n\tFrame3 defaultFrame3(Point3(1.0, 1.0, 0.0), initialDir); \n\tdouble radius = 2.0; \n\tVector3 tangentAt0 = AMCAX::CurveCalculation::CircleD2(0.0, defaultFrame3, radius);\n\tVector3 tangentAt90Deg = AMCAX::CurveCalculation::CircleD2(M_PI_2, defaultFrame3, radius);\n\tVector3 tangentAt180Deg = AMCAX::CurveCalculation::CircleD2(M_PI, defaultFrame3, radius);\n\tVector3 tangentAt270Deg = AMCAX::CurveCalculation::CircleD2(3 * M_PI_2, defaultFrame3, radius);\n\tVector3 tangentAt360Deg = AMCAX::CurveCalculation::CircleD2(2 * M_PI, defaultFrame3, radius);\n\tCHECK(tangentAt0.X() == Approx(-2.0));\n\tCHECK(tangentAt0.Y() == Approx(-0.0));\n\tCHECK(tangentAt0.Z() == Approx(0.0));\n\tCHECK(tangentAt90Deg.X() == Approx(-0.0).margin(1e-14));\n\tCHECK(tangentAt90Deg.Y() == Approx(-2.0).margin(1e-14));\n\tCHECK(tangentAt90Deg.Z() == Approx(0.0).margin(1e-14));\n\tCHECK(tangentAt180Deg.X() == Approx(2.0).margin(1e-14));\n\tCHECK(tangentAt180Deg.Y() == Approx(-0.0).margin(1e-14));\n\tCHECK(tangentAt180Deg.Z() == Approx(-0.0));\n\tCHECK(tangentAt270Deg.X() == Approx(0.0).margin(1e-14));\n\tCHECK(tangentAt270Deg.Y() == Approx(2.0).margin(1e-14));\n\tCHECK(tangentAt270Deg.Z() == Approx(0.0).margin(1e-14));\n\tCHECK(tangentAt360Deg.X() == Approx(-2.0).margin(1e-14));\n\tCHECK(tangentAt360Deg.Y() == Approx(0.0).margin(1e-14));\n\tCHECK(tangentAt360Deg.Z() == Approx(0.0).margin(1e-14));\n\tstd::cout << \"Tangent at 0 deg: \" << tangentAt0 << std::endl;\n\tstd::cout << \"Tangent at 90 deg: \" << tangentAt90Deg << std::endl;\n\tstd::cout << \"Tangent at 180 deg: \" << tangentAt180Deg << std::endl;\n\tstd::cout << \"Tangent at 270 deg: \" << tangentAt270Deg << std::endl;\n\tstd::cout << \"Tangent at 360 deg: \" << tangentAt360Deg << std::endl;\n}\n}\n,\n{\n "
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] AMCAX_API static Point2 CircleD0(double u, const Frame2& pos, double radius)\t @return The point\n\t @param radius The radius\n\t @param pos The local frame where the circle lies\n\t @param u The parameter\n\t @brief Compute the point on a 2D circle represented by a local frame and a radius at a parameter\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <common/PointT.hpp>\n#include <math/CurveCalculation.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"case1: CurveCalculation::CircleD0 1/2 \", \"[math][CurveCalculation][P1]\") {\n\tDirection2 defaultDirection(1.0,0.0); \n\tFrame2 defaultFrame2(Point2(0.0, 0.0), defaultDirection);\n\tdouble \tr = 3.0;\n\tdouble u = 4 * M_PI ; \n\tPoint2  pointOnCirecle = CurveCalculation::CircleD0(u, defaultFrame2, r);\n\tstd::cout << pointOnCirecle.X() << \" \" << pointOnCirecle.Y() << \" \"  << std::endl;\n\tCHECK(pointOnCirecle.X() == 3.0);\n\tCHECK(pointOnCirecle.Y() == Approx(0.0).margin(1e-14));\n\tCHECK(pointOnCirecle.X() * pointOnCirecle.X() + pointOnCirecle.Y() * pointOnCirecle.Y() == r * r);\n}\n}\n,\n{\n "
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] AMCAX_API static Point3 CircleD0(double u, const Frame3& pos, double radius)\t @return The point\n\t @param radius The radius\n\t @param pos The local frame where the circle lies\n\t @param u The parameter\n\t @brief Compute the point on a 3D circle represented by a local frame and a radius at a parameter\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <common/PointT.hpp>\n#include <math/CurveCalculation.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"case1: CurveCalculation::CircleD0 1/2 \", \"[math][CurveCalculation][P1]\") {\n\tDirection2 defaultDirection(1.0,0.0); \n\tFrame2 defaultFrame2(Point2(0.0, 0.0), defaultDirection);\n\tdouble \tr = 3.0;\n\tdouble u = 4 * M_PI ; \n\tPoint2  pointOnCirecle = CurveCalculation::CircleD0(u, defaultFrame2, r);\n\tstd::cout << pointOnCirecle.X() << \" \" << pointOnCirecle.Y() << \" \"  << std::endl;\n\tCHECK(pointOnCirecle.X() == 3.0);\n\tCHECK(pointOnCirecle.Y() == Approx(0.0).margin(1e-14));\n\tCHECK(pointOnCirecle.X() * pointOnCirecle.X() + pointOnCirecle.Y() * pointOnCirecle.Y() == r * r);\n} "
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] AMCAX_API static Point2 CircleValue(double u, const Frame2& pos, double radius)\t @return The point\n\t @param radius The radius\n\t @param pos The local frame where the circle lies\n\t @param u The parameter\n\t @brief Compute the point on a 2D circle represented by a local frame and a radius at a parameter\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <common/PointT.hpp>\n#include <math/CurveCalculation.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"case1: CurveCalculation::CircleValue()[1 / 2] \", \"[math][CurveCalculation][P1][CircleValue]\") {\n\tDirection2 defaultDirection(1.0, 0.0); \n\tFrame2 defaultFrame2(Point2(1.0, 1.0), defaultDirection);\n\tPoint2 point2 = AMCAX::CurveCalculation::CircleValue(0.0, defaultFrame2, 3.0);\n\tCHECK(point2.X() == 4.0);\n\tCHECK(point2.Y() == 1.0);\n} "
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] AMCAX_API static Vector2 CircleD1(double u, const Frame2& pos, double radius)\t @return The first derivative vector\n\t @param radius The radius\n\t @param pos The local frame where the circle lies\n\t @param u The parameter\n\t @brief Compute the first derivative on a 2D circle represented by a local frame and a radius at a parameter\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <common/PointT.hpp>\n#include <math/CurveCalculation.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"case1: CurveCalculation::CircleD1 1/4 \", \"[math][CurveCalculation][P1][CircleD1]\") {\n\tDirection2 initialDir(1.0, 0.0); \n\tFrame2 defaultFrame2(Point2(1.0, 1.0), initialDir); \n\tdouble radius = 2.0; \n\tVector2 tangentAt0 = AMCAX::CurveCalculation::CircleD1(0.0, defaultFrame2, radius);\n\tVector2 tangentAt90Deg = AMCAX::CurveCalculation::CircleD1(M_PI_2, defaultFrame2, radius);\n\tVector2 tangentAt180Deg = AMCAX::CurveCalculation::CircleD1(M_PI, defaultFrame2, radius);\n\tVector2 tangentAt270Deg = AMCAX::CurveCalculation::CircleD1(3 * M_PI_2, defaultFrame2, radius);\n\tVector2 tangentAt360Deg = AMCAX::CurveCalculation::CircleD1(2 * M_PI, defaultFrame2, radius);\n\tCHECK(tangentAt0.X() == Approx(-0.0));\n\tCHECK(tangentAt0.Y() == Approx(2.0));\n\tCHECK(tangentAt90Deg.X() == Approx(-2.0));\n\tCHECK(tangentAt90Deg.Y() == Approx(0.0).margin(1e-14));\n\tCHECK(tangentAt180Deg.X() == Approx(-0.0).margin(1e-14));\n\tCHECK(tangentAt180Deg.Y() == Approx(-2.0));\n\tCHECK(tangentAt270Deg.X() == Approx(2.0));\n\tCHECK(tangentAt270Deg.Y() == Approx(-0.0).margin(1e-14));\n\tCHECK(tangentAt360Deg.X() == Approx(0.0).margin(1e-14));\n\tCHECK(tangentAt360Deg.Y() == Approx(2.0));\n\tstd::cout << \"Tangent at 0 deg: \" << tangentAt0 << std::endl;\n\tstd::cout << \"Tangent at 90 deg: \" << tangentAt90Deg << std::endl;\n\tstd::cout << \"Tangent at 180 deg: \" << tangentAt180Deg << std::endl;\n\tstd::cout << \"Tangent at 270 deg: \" << tangentAt270Deg << std::endl;\n\tstd::cout << \"Tangent at 360 deg: \" << tangentAt360Deg << std::endl;\n}\n}\n,\n{\n "
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static void CircleD1(double u, const Frame3& pos, double radius, Point3& p, Vector3& v1)\t @param[out] v1 The first derivative\n\t @param[out] p The point\n\t @param[in] radius The radius\n\t @param[in] pos The local frame where the circle lies\n\t @param[in] u The parameter\n\t @brief Compute the point and the first derivative on a 3D circle represented by a local frame and a radius at a parameter\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <common/PointT.hpp>\n#include <math/CurveCalculation.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"case1: CurveCalculation::CircleD1 4/4 \", \"[math][CurveCalculation][P1][CircleD1]\") {\n\tDirection3 initialDir(0.0, 0.0,1.0);\n\tFrame3 defaultFrame3(Point3(1.0, 1.0,0.0), initialDir);\n\tdouble radius = 2.0;\n\tPoint3 p;\n\tVector3 v;\n\tSECTION(\"0 deg case\") {\n\t\tAMCAX::CurveCalculation::CircleD1(0.0, defaultFrame3, radius, p, v);\n\t\tCHECK(p.X() == 3.0);\n\t\tCHECK(p.Y() == 1.0);\n\t\tCHECK(p.Z() == 0.0);\n\t\tCHECK(v.X() == Approx(0.0));\n\t\tCHECK(v.Y() == Approx(2.0));\n\t\tCHECK(v.Z() == Approx(0.0));\n\t}} "
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] AMCAX_API static Vector3 CircleD1(double u, const Frame3& pos, double radius)\t @return The first derivative vector\n\t @param radius The radius\n\t @param pos The local frame where the circle lies\n\t @param u The parameter\n\t @brief Compute the first derivative on a 3D circle represented by a local frame and a radius at a parameter\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <common/PointT.hpp>\n#include <math/CurveCalculation.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"case1: CurveCalculation::CircleD1 3/4 \", \"[math][CurveCalculation][P1][CircleD1]\") {\n\tDirection3 initialDir(0.0, 0.0,1.0); \n\tFrame3 defaultFrame3(Point3(1.0, 0.0,0.0), initialDir); \n\tdouble radius = 2.0; \n\tVector3 tangentAt0 = AMCAX::CurveCalculation::CircleD1(0.0, defaultFrame3, radius);\n\tVector3 tangentAt90Deg = AMCAX::CurveCalculation::CircleD1(M_PI_2, defaultFrame3, radius);\n\tVector3 tangentAt180Deg = AMCAX::CurveCalculation::CircleD1(M_PI, defaultFrame3, radius);\n\tVector3 tangentAt270Deg = AMCAX::CurveCalculation::CircleD1(3 * M_PI_2, defaultFrame3, radius);\n\tVector3 tangentAt360Deg = AMCAX::CurveCalculation::CircleD1(2 * M_PI, defaultFrame3, radius);\n\tCHECK(tangentAt0.X() == Approx(0.0));\n\tCHECK(tangentAt0.Y() == Approx(2.0));\n\tCHECK(tangentAt90Deg.X() == Approx(-2.0));\n\tCHECK(tangentAt90Deg.Y() == Approx(0.0).margin(1e-14));\n\tCHECK(tangentAt180Deg.X() == Approx(0.0).margin(1e-14));\n\tCHECK(tangentAt180Deg.Y() == Approx(-2.0));\n\tCHECK(tangentAt270Deg.X() == Approx(2.0));\n\tCHECK(tangentAt270Deg.Y() == Approx(-0.0).margin(1e-14));\n\tCHECK(tangentAt360Deg.X() == Approx(0.0).margin(1e-14));\n\tCHECK(tangentAt360Deg.Y() == Approx(2.0));\n\tstd::cout << \"Tangent at 0 deg: \" << tangentAt0 << std::endl;\n\tstd::cout << \"Tangent at 90 deg: \" << tangentAt90Deg << std::endl;\n\tstd::cout << \"Tangent at 180 deg: \" << tangentAt180Deg << std::endl;\n\tstd::cout << \"Tangent at 270 deg: \" << tangentAt270Deg << std::endl;\n\tstd::cout << \"Tangent at 360 deg: \" << tangentAt360Deg << std::endl;\n} "
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static void CircleD2(double u, const Frame3& pos, double radius, Point3& p, Vector3& v1, Vector3& v2)\t @param[out] v2 The second derivative\n\t @param[out] v1 The first derivative\n\t @param[out] p The point\n\t @param[in] radius The radius\n\t @param[in] pos The local frame where the circle lies\n\t @param[in] u The parameter\n\t @brief Compute the point and the first two derivatives on a 3D circle represented by a local frame and a radius at a parameter\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <common/PointT.hpp>\n#include <math/CurveCalculation.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"case1: CurveCalculation::CircleD2 3/4 \", \"[math][CurveCalculation][P1][CircleD2]\") {\n\tDirection3 initialDir(0.0, 0.0, 1.0); \n\tFrame3 defaultFrame3(Point3(1.0, 1.0, 0.0), initialDir); \n\tdouble radius = 2.0; \n\tVector3 tangentAt0 = AMCAX::CurveCalculation::CircleD2(0.0, defaultFrame3, radius);\n\tVector3 tangentAt90Deg = AMCAX::CurveCalculation::CircleD2(M_PI_2, defaultFrame3, radius);\n\tVector3 tangentAt180Deg = AMCAX::CurveCalculation::CircleD2(M_PI, defaultFrame3, radius);\n\tVector3 tangentAt270Deg = AMCAX::CurveCalculation::CircleD2(3 * M_PI_2, defaultFrame3, radius);\n\tVector3 tangentAt360Deg = AMCAX::CurveCalculation::CircleD2(2 * M_PI, defaultFrame3, radius);\n\tCHECK(tangentAt0.X() == Approx(-2.0));\n\tCHECK(tangentAt0.Y() == Approx(-0.0));\n\tCHECK(tangentAt0.Z() == Approx(0.0));\n\tCHECK(tangentAt90Deg.X() == Approx(-0.0).margin(1e-14));\n\tCHECK(tangentAt90Deg.Y() == Approx(-2.0).margin(1e-14));\n\tCHECK(tangentAt90Deg.Z() == Approx(0.0).margin(1e-14));\n\tCHECK(tangentAt180Deg.X() == Approx(2.0).margin(1e-14));\n\tCHECK(tangentAt180Deg.Y() == Approx(-0.0).margin(1e-14));\n\tCHECK(tangentAt180Deg.Z() == Approx(-0.0));\n\tCHECK(tangentAt270Deg.X() == Approx(0.0).margin(1e-14));\n\tCHECK(tangentAt270Deg.Y() == Approx(2.0).margin(1e-14));\n\tCHECK(tangentAt270Deg.Z() == Approx(0.0).margin(1e-14));\n\tCHECK(tangentAt360Deg.X() == Approx(-2.0).margin(1e-14));\n\tCHECK(tangentAt360Deg.Y() == Approx(0.0).margin(1e-14));\n\tCHECK(tangentAt360Deg.Z() == Approx(0.0).margin(1e-14));\n\tstd::cout << \"Tangent at 0 deg: \" << tangentAt0 << std::endl;\n\tstd::cout << \"Tangent at 90 deg: \" << tangentAt90Deg << std::endl;\n\tstd::cout << \"Tangent at 180 deg: \" << tangentAt180Deg << std::endl;\n\tstd::cout << \"Tangent at 270 deg: \" << tangentAt270Deg << std::endl;\n\tstd::cout << \"Tangent at 360 deg: \" << tangentAt360Deg << std::endl;\n}\n}\n,\n{\n "
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] AMCAX_API static Vector3 CircleD2(double u, const Frame3& pos, double radius)\t @return The second derivative vector\n\t @param radius The radius\n\t @param pos The local frame where the circle lies\n\t @param u The parameter\n\t @brief Compute the second derivative on a 3D circle represented by a local frame and a radius at a parameter\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <common/PointT.hpp>\n#include <math/CurveCalculation.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"case1: CurveCalculation::CircleD2 3/4 \", \"[math][CurveCalculation][P1][CircleD2]\") {\n\tDirection3 initialDir(0.0, 0.0, 1.0); \n\tFrame3 defaultFrame3(Point3(1.0, 1.0, 0.0), initialDir); \n\tdouble radius = 2.0; \n\tVector3 tangentAt0 = AMCAX::CurveCalculation::CircleD2(0.0, defaultFrame3, radius);\n\tVector3 tangentAt90Deg = AMCAX::CurveCalculation::CircleD2(M_PI_2, defaultFrame3, radius);\n\tVector3 tangentAt180Deg = AMCAX::CurveCalculation::CircleD2(M_PI, defaultFrame3, radius);\n\tVector3 tangentAt270Deg = AMCAX::CurveCalculation::CircleD2(3 * M_PI_2, defaultFrame3, radius);\n\tVector3 tangentAt360Deg = AMCAX::CurveCalculation::CircleD2(2 * M_PI, defaultFrame3, radius);\n\tCHECK(tangentAt0.X() == Approx(-2.0));\n\tCHECK(tangentAt0.Y() == Approx(-0.0));\n\tCHECK(tangentAt0.Z() == Approx(0.0));\n\tCHECK(tangentAt90Deg.X() == Approx(-0.0).margin(1e-14));\n\tCHECK(tangentAt90Deg.Y() == Approx(-2.0).margin(1e-14));\n\tCHECK(tangentAt90Deg.Z() == Approx(0.0).margin(1e-14));\n\tCHECK(tangentAt180Deg.X() == Approx(2.0).margin(1e-14));\n\tCHECK(tangentAt180Deg.Y() == Approx(-0.0).margin(1e-14));\n\tCHECK(tangentAt180Deg.Z() == Approx(-0.0));\n\tCHECK(tangentAt270Deg.X() == Approx(0.0).margin(1e-14));\n\tCHECK(tangentAt270Deg.Y() == Approx(2.0).margin(1e-14));\n\tCHECK(tangentAt270Deg.Z() == Approx(0.0).margin(1e-14));\n\tCHECK(tangentAt360Deg.X() == Approx(-2.0).margin(1e-14));\n\tCHECK(tangentAt360Deg.Y() == Approx(0.0).margin(1e-14));\n\tCHECK(tangentAt360Deg.Z() == Approx(0.0).margin(1e-14));\n\tstd::cout << \"Tangent at 0 deg: \" << tangentAt0 << std::endl;\n\tstd::cout << \"Tangent at 90 deg: \" << tangentAt90Deg << std::endl;\n\tstd::cout << \"Tangent at 180 deg: \" << tangentAt180Deg << std::endl;\n\tstd::cout << \"Tangent at 270 deg: \" << tangentAt270Deg << std::endl;\n\tstd::cout << \"Tangent at 360 deg: \" << tangentAt360Deg << std::endl;\n} "
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static void CircleD1(double u, const Frame2& pos, double radius, Point2& p, Vector2& v1)\t @param[out] v1 The first derivative\n\t @param[out] p The point\n\t @param[in] radius The radius\n\t @param[in] pos The local frame where the circle lies\n\t @param[in] u The parameter\n\t @brief Compute the point and the first derivative on a 2D circle represented by a local frame and a radius at a parameter\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <common/PointT.hpp>\n#include <math/CurveCalculation.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"case1: CurveCalculation::CircleD1 1/4 \", \"[math][CurveCalculation][P1][CircleD1]\") {\n\tDirection2 initialDir(1.0, 0.0); \n\tFrame2 defaultFrame2(Point2(1.0, 1.0), initialDir); \n\tdouble radius = 2.0; \n\tVector2 tangentAt0 = AMCAX::CurveCalculation::CircleD1(0.0, defaultFrame2, radius);\n\tVector2 tangentAt90Deg = AMCAX::CurveCalculation::CircleD1(M_PI_2, defaultFrame2, radius);\n\tVector2 tangentAt180Deg = AMCAX::CurveCalculation::CircleD1(M_PI, defaultFrame2, radius);\n\tVector2 tangentAt270Deg = AMCAX::CurveCalculation::CircleD1(3 * M_PI_2, defaultFrame2, radius);\n\tVector2 tangentAt360Deg = AMCAX::CurveCalculation::CircleD1(2 * M_PI, defaultFrame2, radius);\n\tCHECK(tangentAt0.X() == Approx(-0.0));\n\tCHECK(tangentAt0.Y() == Approx(2.0));\n\tCHECK(tangentAt90Deg.X() == Approx(-2.0));\n\tCHECK(tangentAt90Deg.Y() == Approx(0.0).margin(1e-14));\n\tCHECK(tangentAt180Deg.X() == Approx(-0.0).margin(1e-14));\n\tCHECK(tangentAt180Deg.Y() == Approx(-2.0));\n\tCHECK(tangentAt270Deg.X() == Approx(2.0));\n\tCHECK(tangentAt270Deg.Y() == Approx(-0.0).margin(1e-14));\n\tCHECK(tangentAt360Deg.X() == Approx(0.0).margin(1e-14));\n\tCHECK(tangentAt360Deg.Y() == Approx(2.0));\n\tstd::cout << \"Tangent at 0 deg: \" << tangentAt0 << std::endl;\n\tstd::cout << \"Tangent at 90 deg: \" << tangentAt90Deg << std::endl;\n\tstd::cout << \"Tangent at 180 deg: \" << tangentAt180Deg << std::endl;\n\tstd::cout << \"Tangent at 270 deg: \" << tangentAt270Deg << std::endl;\n\tstd::cout << \"Tangent at 360 deg: \" << tangentAt360Deg << std::endl;\n} "
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] AMCAX_API static Vector3 CircleD3(double u, const Frame3& pos, double radius)\t @return The third derivative vector\n\t @param radius The radius\n\t @param pos The local frame where the circle lies\n\t @param u The parameter\n\t @brief Compute the third derivative on a 3D circle represented by a local frame and a radius at a parameter\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <common/PointT.hpp>\n#include <math/CurveCalculation.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"case1: CurveCalculation::CircleD3 3/4 \", \"[math][CurveCalculation][P1][CircleD3]\") {\n\tDirection3 initialDir(0.0, 0.0, 1.0); \n\tFrame3 defaultFrame3(Point3(1.0, 1.0, 0.0), initialDir); \n\tdouble radius = 2.0; \n\tVector3 tangentAt0 = AMCAX::CurveCalculation::CircleD3(0.0, defaultFrame3, radius);\n\tVector3 tangentAt90Deg = AMCAX::CurveCalculation::CircleD3(M_PI_2, defaultFrame3, radius);\n\tVector3 tangentAt180Deg = AMCAX::CurveCalculation::CircleD3(M_PI, defaultFrame3, radius);\n\tVector3 tangentAt270Deg = AMCAX::CurveCalculation::CircleD3(3 * M_PI_2, defaultFrame3, radius);\n\tVector3 tangentAt360Deg = AMCAX::CurveCalculation::CircleD3(2 * M_PI, defaultFrame3, radius);\n\tCHECK(tangentAt0.X() == Approx(0.0));\n\tCHECK(tangentAt0.Y() == Approx(-2.0));\n\tCHECK(tangentAt0.Z() == Approx(-0.0));\n\tCHECK(tangentAt90Deg.X() == Approx(2.0).margin(1e-14));\n\tCHECK(tangentAt90Deg.Y() == Approx(-0.0).margin(1e-14));\n\tCHECK(tangentAt90Deg.Z() == Approx(0.0).margin(1e-14));\n\tCHECK(tangentAt180Deg.X() == Approx(0.0).margin(1e-14));\n\tCHECK(tangentAt180Deg.Y() == Approx(2.0).margin(1e-14));\n\tCHECK(tangentAt180Deg.Z() == Approx(0.0));\n\tCHECK(tangentAt270Deg.X() == Approx(-2.0).margin(1e-14));\n\tCHECK(tangentAt270Deg.Y() == Approx(0.0).margin(1e-14));\n\tCHECK(tangentAt270Deg.Z() == Approx(0.0).margin(1e-14));\n\tCHECK(tangentAt360Deg.X() == Approx(-0.0).margin(1e-14));\n\tCHECK(tangentAt360Deg.Y() == Approx(-2.0).margin(1e-14));\n\tCHECK(tangentAt360Deg.Z() == Approx(0.0).margin(1e-14));\n\tstd::cout << \"Tangent at 0 deg: \" << tangentAt0 << std::endl;\n\tstd::cout << \"Tangent at 90 deg: \" << tangentAt90Deg << std::endl;\n\tstd::cout << \"Tangent at 180 deg: \" << tangentAt180Deg << std::endl;\n\tstd::cout << \"Tangent at 270 deg: \" << tangentAt270Deg << std::endl;\n\tstd::cout << \"Tangent at 360 deg: \" << tangentAt360Deg << std::endl;\n}\n}\n,\n{\n "
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static void CircleD2(double u, const Frame2& pos, double radius, Point2& p, Vector2& v1, Vector2& v2)\t @param[out] v2 The second derivative\n\t @param[out] v1 The first derivative\n\t @param[out] p The point\n\t @param[in] radius The radius\n\t @param[in] pos The local frame where the circle lies\n\t @param[in] u The parameter\n\t @brief Compute the point and the first two derivatives on a 2D circle represented by a local frame and a radius at a parameter\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <common/PointT.hpp>\n#include <math/CurveCalculation.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"case1: CurveCalculation::CircleD2 1/4 \", \"[math][CurveCalculation][P1][CircleD2]\") {\n\tDirection2 defaultDirection(1.0, 0.0); \n\tFrame2 defaultFrame2(Point2(0.0, 0.0), defaultDirection);\n\tdouble \tr = 2.0;\n\tdouble u = 0.0; \n\tVector2  vector2 = CurveCalculation::CircleD2(u, defaultFrame2, r); \n\tstd::cout << vector2.X() << \" \" << vector2.Y() << \" \" << std::endl;\n\tCHECK(vector2.X() == -2.0);\n\tCHECK(vector2.Y() == Approx(0.0).margin(1e-14));\n} "
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] AMCAX_API static Vector2 CircleD2(double u, const Frame2& pos, double radius)\t @return The second derivative vector\n\t @param radius The radius\n\t @param pos The local frame where the circle lies\n\t @param u The parameter\n\t @brief Compute the second derivative on a 2D circle represented by a local frame and a radius at a parameter\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <common/PointT.hpp>\n#include <math/CurveCalculation.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"case1: CurveCalculation::CircleD2 1/4 \", \"[math][CurveCalculation][P1][CircleD2]\") {\n\tDirection2 defaultDirection(1.0, 0.0); \n\tFrame2 defaultFrame2(Point2(0.0, 0.0), defaultDirection);\n\tdouble \tr = 2.0;\n\tdouble u = 0.0; \n\tVector2  vector2 = CurveCalculation::CircleD2(u, defaultFrame2, r); \n\tstd::cout << vector2.X() << \" \" << vector2.Y() << \" \" << std::endl;\n\tCHECK(vector2.X() == -2.0);\n\tCHECK(vector2.Y() == Approx(0.0).margin(1e-14));\n} "
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static void CircleD3(double u, const Frame2& pos, double radius, Point2& p, Vector2& v1, Vector2& v2, Vector2& v3)\t @param[out] v3 The third derivative\n\t @param[out] v2 The second derivative\n\t @param[out] v1 The first derivative\n\t @param[out] p The point\n\t @param[in] radius The radius\n\t @param[in] pos The local frame where the circle lies\n\t @param[in] u The parameter\n\t @brief Compute the point and the first three derivatives on a 2D circle represented by a local frame and a radius at a parameter\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <common/PointT.hpp>\n#include <math/CurveCalculation.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"case1: CurveCalculation::CircleD3 1/4 \", \"[math][CurveCalculation][P1][CircleD3]\") {\n\tDirection2 defaultDir2(1.0, 0.0);\n\tFrame2 defaultFrame2(Point2(1.0, 1.0), defaultDir2);\n\tdouble radius = 2.0;\n\tVector2 tangentAt0 = AMCAX::CurveCalculation::CircleD3(0.0, defaultFrame2, radius);\n\tVector2 tangentAt180 = AMCAX::CurveCalculation::CircleD3(M_PI, defaultFrame2, radius);\n\tVector2 tangentAt360 = AMCAX::CurveCalculation::CircleD3(2 * M_PI, defaultFrame2, radius);\n\tCHECK(tangentAt0.X() == 0.0);\n\tCHECK(tangentAt0.Y() == -2.0);\n\tCHECK(tangentAt180.X() == Approx(0.0).margin(1e-14));\n\tCHECK(tangentAt180.Y() == 2.0 );\n\tCHECK(tangentAt360.X() == Approx(0.0).margin(1e-14));\n\tCHECK(tangentAt360.Y() == -2.0 );\n}\n}\n,\n{\n "
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] AMCAX_API static Vector2 CircleD3(double u, const Frame2& pos, double radius)\t @return The third derivative vector\n\t @param radius The radius\n\t @param pos The local frame where the circle lies\n\t @param u The parameter\n\t @brief Compute the third derivative on a 2D circle represented by a local frame and a radius at a parameter\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <common/PointT.hpp>\n#include <math/CurveCalculation.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"case1: CurveCalculation::CircleD3 1/4 \", \"[math][CurveCalculation][P1][CircleD3]\") {\n\tDirection2 defaultDir2(1.0, 0.0);\n\tFrame2 defaultFrame2(Point2(1.0, 1.0), defaultDir2);\n\tdouble radius = 2.0;\n\tVector2 tangentAt0 = AMCAX::CurveCalculation::CircleD3(0.0, defaultFrame2, radius);\n\tVector2 tangentAt180 = AMCAX::CurveCalculation::CircleD3(M_PI, defaultFrame2, radius);\n\tVector2 tangentAt360 = AMCAX::CurveCalculation::CircleD3(2 * M_PI, defaultFrame2, radius);\n\tCHECK(tangentAt0.X() == 0.0);\n\tCHECK(tangentAt0.Y() == -2.0);\n\tCHECK(tangentAt180.X() == Approx(0.0).margin(1e-14));\n\tCHECK(tangentAt180.Y() == 2.0 );\n\tCHECK(tangentAt360.X() == Approx(0.0).margin(1e-14));\n\tCHECK(tangentAt360.Y() == -2.0 );\n} "
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static void CircleD3(double u, const Frame3& pos, double radius, Point3& p, Vector3& v1, Vector3& v2, Vector3& v3)\t @param[out] v3 The third derivative\n\t @param[out] v2 The second derivative\n\t @param[out] v1 The first derivative\n\t @param[out] p The point\n\t @param[in] radius The radius\n\t @param[in] pos The local frame where the circle lies\n\t @param[in] u The parameter\n\t @brief Compute the point and the first three derivatives on a 3D circle represented by a local frame and a radius at a parameter\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <common/PointT.hpp>\n#include <math/CurveCalculation.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"case1: CurveCalculation::CircleD3 3/4 \", \"[math][CurveCalculation][P1][CircleD3]\") {\n\tDirection3 initialDir(0.0, 0.0, 1.0); \n\tFrame3 defaultFrame3(Point3(1.0, 1.0, 0.0), initialDir); \n\tdouble radius = 2.0; \n\tVector3 tangentAt0 = AMCAX::CurveCalculation::CircleD3(0.0, defaultFrame3, radius);\n\tVector3 tangentAt90Deg = AMCAX::CurveCalculation::CircleD3(M_PI_2, defaultFrame3, radius);\n\tVector3 tangentAt180Deg = AMCAX::CurveCalculation::CircleD3(M_PI, defaultFrame3, radius);\n\tVector3 tangentAt270Deg = AMCAX::CurveCalculation::CircleD3(3 * M_PI_2, defaultFrame3, radius);\n\tVector3 tangentAt360Deg = AMCAX::CurveCalculation::CircleD3(2 * M_PI, defaultFrame3, radius);\n\tCHECK(tangentAt0.X() == Approx(0.0));\n\tCHECK(tangentAt0.Y() == Approx(-2.0));\n\tCHECK(tangentAt0.Z() == Approx(-0.0));\n\tCHECK(tangentAt90Deg.X() == Approx(2.0).margin(1e-14));\n\tCHECK(tangentAt90Deg.Y() == Approx(-0.0).margin(1e-14));\n\tCHECK(tangentAt90Deg.Z() == Approx(0.0).margin(1e-14));\n\tCHECK(tangentAt180Deg.X() == Approx(0.0).margin(1e-14));\n\tCHECK(tangentAt180Deg.Y() == Approx(2.0).margin(1e-14));\n\tCHECK(tangentAt180Deg.Z() == Approx(0.0));\n\tCHECK(tangentAt270Deg.X() == Approx(-2.0).margin(1e-14));\n\tCHECK(tangentAt270Deg.Y() == Approx(0.0).margin(1e-14));\n\tCHECK(tangentAt270Deg.Z() == Approx(0.0).margin(1e-14));\n\tCHECK(tangentAt360Deg.X() == Approx(-0.0).margin(1e-14));\n\tCHECK(tangentAt360Deg.Y() == Approx(-2.0).margin(1e-14));\n\tCHECK(tangentAt360Deg.Z() == Approx(0.0).margin(1e-14));\n\tstd::cout << \"Tangent at 0 deg: \" << tangentAt0 << std::endl;\n\tstd::cout << \"Tangent at 90 deg: \" << tangentAt90Deg << std::endl;\n\tstd::cout << \"Tangent at 180 deg: \" << tangentAt180Deg << std::endl;\n\tstd::cout << \"Tangent at 270 deg: \" << tangentAt270Deg << std::endl;\n\tstd::cout << \"Tangent at 360 deg: \" << tangentAt360Deg << std::endl;\n} "
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] AMCAX_API static Point3 D0(double u, const Line3& line)\t @return The resulting point\n\t @param line The line\n\t @param u The parameter\n\t @brief Compute the point on a 3D line at a parameter\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <common/PointT.hpp>\n#include <math/CurveCalculation.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <geometry/MakeArcOfHyperbola2d.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <modeling/MakeEdge2d.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"case1: CurveCalculation::D0() [6/10] \", \"[math][CurveCalculation][P1][D0]\") {\n\tFrame3 fram3;\n\tdouble major_radius = 1000.0;\n\tdouble minor_radius = 10.0;\n\tHyperbola3 hyperbola(fram3, major_radius, minor_radius);\n\tPoint3 point3 = CurveCalculation::D0(0.0, hyperbola);\n\tCHECK(point3.X() == 1000.0);\n\tCHECK(point3.Y() == 0.0);\n\tCHECK(point3.Z() == 0.0);\n}\n}\n,\n{\n "
    }]
    
    

    