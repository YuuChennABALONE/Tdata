  [
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API bool PerformProximityValue(double& hdProxDistance)\t @return true if perform successfully\n\t @param hdProxDistance The result approximate hausdorff distance\n\t @details The hausdorff distance H(S1, S2) = max(maxmin||S1 - S2||, maxmin||S2 - S1||);\n\t @brief Compute the approximate hausdorff distance with two shape\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <io/OBJTool.hpp>\n#include <modeling/TransformShape.hpp>\n#include <geometry/Geom3BezierCurve.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakePrism.hpp>\n#include <topology/TopoTool.hpp>\n#include <topology/TopoFace.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <topology/BRepExtremaProximityTool.hpp>\n#include <modeling/MakeBox.hpp>\n#include <geometry/Geom3BSplineCurve.hpp>\n#include <topology/TopoWire.hpp>\n#include <modeling/MakeWire.hpp>\n#include <offset/MakePipeShell.hpp>\n#include <topology/BRepExtremaDistShapeShape.hpp>\nusing namespace AMCAX;\nusing namespace std;\n#include<catch.hpp>\n#include<testHelper.h>\n#include <io/OBJTool.hpp>\n#include <modeling/TransformShape.hpp>\n#include <geometry/Geom3BezierCurve.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakePrism.hpp>\n#include <topology/TopoTool.hpp>\n#include <topology/TopoFace.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <topology/BRepExtremaProximityTool.hpp>\n#include <modeling/MakeBox.hpp>\n#include <geometry/Geom3BSplineCurve.hpp>\n#include <topology/TopoWire.hpp>\n#include <modeling/MakeWire.hpp>\n#include <offset/MakePipeShell.hpp>\n#include <topology/BRepExtremaDistShapeShape.hpp>\nusing namespace AMCAX;\nusing namespace std;\n;\n\tSECTION(\"Back translation=0.0\")\n\t{\n\t\tBRepExtremaProximityTool proxTool(shape1, shape2);\n\t\tbool r1 = proxTool.PerformOverlapFaces(overlapShape, tolerance);\n\t\tbool r2 = proxTool.PerformIntersectionFaces(intersectionShape, tolerance);\n\t\tbool r3 = proxTool.PerformProximityValue(tolMax);\n\t\tCHECK(r1 == true);\n\t\tCHECK(r2 == true);\n\t\tCHECK(r3 == true);\n\t\tCHECK(overlapShape.size() == 1);\n\t\tCHECK(intersectionShape.size() == 1);\n\t\tCHECK(tolMax == Approx(0.0));\n\t\tBRepExtremaDistShapeShape dist(shape1, shape2);\n\t\tCHECK(dist.Value() < tolerance);\n\t}}\n}\n,"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API bool PerformIntersectionFaces(std::vector<std::pair<TopoShape, TopoShape>>& facesInShape, const double tolerance = Precision::Confusion()\t @return true if two shape have intersecting faces\n\t @param tolerance The tolerance used for check intersection\n\t @param facesInShape The couple of faces which intersect with each other\n\t @brief Performs find intersecting faces of shape\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <io/OBJTool.hpp>\n#include <modeling/TransformShape.hpp>\n#include <geometry/Geom3BezierCurve.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakePrism.hpp>\n#include <topology/TopoTool.hpp>\n#include <topology/TopoFace.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <topology/BRepExtremaProximityTool.hpp>\n#include <modeling/MakeBox.hpp>\n#include <geometry/Geom3BSplineCurve.hpp>\n#include <topology/TopoWire.hpp>\n#include <modeling/MakeWire.hpp>\n#include <offset/MakePipeShell.hpp>\n#include <topology/BRepExtremaDistShapeShape.hpp>\nusing namespace AMCAX;\nusing namespace std;\n#include<catch.hpp>\n#include<testHelper.h>\n#include <io/OBJTool.hpp>\n#include <modeling/TransformShape.hpp>\n#include <geometry/Geom3BezierCurve.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakePrism.hpp>\n#include <topology/TopoTool.hpp>\n#include <topology/TopoFace.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <topology/BRepExtremaProximityTool.hpp>\n#include <modeling/MakeBox.hpp>\n#include <geometry/Geom3BSplineCurve.hpp>\n#include <topology/TopoWire.hpp>\n#include <modeling/MakeWire.hpp>\n#include <offset/MakePipeShell.hpp>\n#include <topology/BRepExtremaDistShapeShape.hpp>\nusing namespace AMCAX;\nusing namespace std;\n;\n\tSECTION(\"Back translation=0.9*tolerance\")\n\t{\n\t\ty = 0.0 + 0.9 * tolerance;\n\t\ttr1.SetTranslation(Point3(0.0, 0.0, 0.0), Point3(0.0, y, 0.0));\n\t\tTransformShape ts(shape2, tr1, false, false);\n\t\tBRepExtremaProximityTool proxTool(shape1, ts);\n\t\tbool r1 = proxTool.PerformOverlapFaces(overlapShape, tolerance);\n\t\tbool r2 = proxTool.PerformIntersectionFaces(intersectionShape, tolerance);\n\t\tbool r3 = proxTool.PerformProximityValue(tolMax);\n\t\tCHECK(r1 == true);\n\t\tCHECK(r2 == true);\n\t\tCHECK(r3 == true);\n\t\tCHECK(overlapShape.size() == 1);\n\t\tCHECK(intersectionShape.size() == 1);\n\t\tCHECK(tolMax == Approx(y));\n\t\tBRepExtremaDistShapeShape dist(shape1, ts);\n\t\tCHECK(dist.Value() < tolerance);\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API bool PerformOverlapFaces(std::vector<std::pair<TopoShape, TopoShape>>& facesInShape, const double tolerance = Precision::Confusion()\t @return true if two shape have overlapping faces\n\t @param tolerance The horizontal tolerance used for check overlaping\n\t @param facesInShape The couples of faces with overlapping areas\n\t @brief Performs find faces of shape with finite overlapping areas\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <io/OBJTool.hpp>\n#include <modeling/TransformShape.hpp>\n#include <geometry/Geom3BezierCurve.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakePrism.hpp>\n#include <topology/TopoTool.hpp>\n#include <topology/TopoFace.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <topology/BRepExtremaProximityTool.hpp>\n#include <modeling/MakeBox.hpp>\n#include <geometry/Geom3BSplineCurve.hpp>\n#include <topology/TopoWire.hpp>\n#include <modeling/MakeWire.hpp>\n#include <offset/MakePipeShell.hpp>\n#include <topology/BRepExtremaDistShapeShape.hpp>\nusing namespace AMCAX;\nusing namespace std;\n#include<catch.hpp>\n#include<testHelper.h>\n#include <io/OBJTool.hpp>\n#include <modeling/TransformShape.hpp>\n#include <geometry/Geom3BezierCurve.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakePrism.hpp>\n#include <topology/TopoTool.hpp>\n#include <topology/TopoFace.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <topology/BRepExtremaProximityTool.hpp>\n#include <modeling/MakeBox.hpp>\n#include <geometry/Geom3BSplineCurve.hpp>\n#include <topology/TopoWire.hpp>\n#include <modeling/MakeWire.hpp>\n#include <offset/MakePipeShell.hpp>\n#include <topology/BRepExtremaDistShapeShape.hpp>\nusing namespace AMCAX;\nusing namespace std;\n;\n\tSECTION(\"param = 0.0\")\n\t{\n\t\tparam = 0.0;\n\t\tBRepExtremaProximityTool proxTool(shape1, shape2);\n\t\tbool r1 = proxTool.PerformOverlapFaces(overlapShape, param);\n\t\tCHECK(r1 == true);\n\t\tCHECK(overlapShape.size() == 1);\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API void LoadShapes(const TopoShape& shape1, const TopoShape& shape2)\t @param shape2 The second shape\n\t @param shape1 The first shape\n\t @brief Load the shape of proximity tool\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <io/OBJTool.hpp>\n#include <modeling/TransformShape.hpp>\n#include <geometry/Geom3BezierCurve.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakePrism.hpp>\n#include <topology/TopoTool.hpp>\n#include <topology/TopoFace.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <topology/BRepExtremaProximityTool.hpp>\n#include <modeling/MakeBox.hpp>\n#include <geometry/Geom3BSplineCurve.hpp>\n#include <topology/TopoWire.hpp>\n#include <modeling/MakeWire.hpp>\n#include <offset/MakePipeShell.hpp>\n#include <topology/BRepExtremaDistShapeShape.hpp>\nusing namespace AMCAX;\nusing namespace std;\n#include<catch.hpp>\n#include<testHelper.h>\n#include <io/OBJTool.hpp>\n#include <modeling/TransformShape.hpp>\n#include <geometry/Geom3BezierCurve.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakePrism.hpp>\n#include <topology/TopoTool.hpp>\n#include <topology/TopoFace.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <topology/BRepExtremaProximityTool.hpp>\n#include <modeling/MakeBox.hpp>\n#include <geometry/Geom3BSplineCurve.hpp>\n#include <topology/TopoWire.hpp>\n#include <modeling/MakeWire.hpp>\n#include <offset/MakePipeShell.hpp>\n#include <topology/BRepExtremaDistShapeShape.hpp>\nusing namespace AMCAX;\nusing namespace std;\n;\n\tSECTION(\"Left translation=1.0\")\n\t{\n\t\tx = 0.0 - 1.0;\n\t\ttr1.SetTranslation(Point3(0.0, 0.0, 0.0), Point3(x, 0.0, 0.0));\n\t\tTransformShape ts(shape2, tr1, false, false);\n\t\tBRepExtremaProximityTool proxTool(shape1, ts);\n\t\tbool r1 = proxTool.PerformOverlapFaces(overlapShape, tolerance);\n\t\tbool r2 = proxTool.PerformIntersectionFaces(intersectionShape, tolerance);\n\t\tbool r3 = proxTool.PerformProximityValue(tolMax);\n\t\tCHECK(r1 == true);\n\t\tCHECK(r2 == true);\n\t\tCHECK(r3 == true);\n\t\tCHECK(overlapShape.size() == 1);\n\t\tCHECK(intersectionShape.size() == 1);\n\t\tCHECK(tolMax == Approx(-x));\n\t\tBRepExtremaDistShapeShape dist(shape1, ts);\n\t\tCHECK(dist.Value() < tolerance);\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API BRepExtremaProximityTool(const TopoShape& shape1, const TopoShape& shape2)\t @param shape2 The second shape\n\t @param shape1 The first shape\n\t @brief Construct proximity tool from two shapes\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <io/OBJTool.hpp>\n#include <modeling/TransformShape.hpp>\n#include <geometry/Geom3BezierCurve.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakePrism.hpp>\n#include <topology/TopoTool.hpp>\n#include <topology/TopoFace.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <topology/BRepExtremaProximityTool.hpp>\n#include <modeling/MakeBox.hpp>\n#include <geometry/Geom3BSplineCurve.hpp>\n#include <topology/TopoWire.hpp>\n#include <modeling/MakeWire.hpp>\n#include <offset/MakePipeShell.hpp>\n#include <topology/BRepExtremaDistShapeShape.hpp>\nusing namespace AMCAX;\nusing namespace std;\n#include<catch.hpp>\n#include<testHelper.h>\n#include <io/OBJTool.hpp>\n#include <modeling/TransformShape.hpp>\n#include <geometry/Geom3BezierCurve.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakePrism.hpp>\n#include <topology/TopoTool.hpp>\n#include <topology/TopoFace.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <topology/BRepExtremaProximityTool.hpp>\n#include <modeling/MakeBox.hpp>\n#include <geometry/Geom3BSplineCurve.hpp>\n#include <topology/TopoWire.hpp>\n#include <modeling/MakeWire.hpp>\n#include <offset/MakePipeShell.hpp>\n#include <topology/BRepExtremaDistShapeShape.hpp>\nusing namespace AMCAX;\nusing namespace std;\n;\n\tSECTION(\"param = 0.0\")\n\t{\n\t\tparam = 0.0;\n\t\tBRepExtremaProximityTool proxTool(shape1, shape2);\n\t\tbool r1 = proxTool.PerformOverlapFaces(overlapShape, param);\n\t\tCHECK(r1 == true);\n\t\tCHECK(overlapShape.size() == 1);\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API BRepExtremaProximityTool()\t @brief Empty constructor for proximity tool\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <io/OBJTool.hpp>\n#include <modeling/TransformShape.hpp>\n#include <geometry/Geom3BezierCurve.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakePrism.hpp>\n#include <topology/TopoTool.hpp>\n#include <topology/TopoFace.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <topology/BRepExtremaProximityTool.hpp>\n#include <modeling/MakeBox.hpp>\n#include <geometry/Geom3BSplineCurve.hpp>\n#include <topology/TopoWire.hpp>\n#include <modeling/MakeWire.hpp>\n#include <offset/MakePipeShell.hpp>\n#include <topology/BRepExtremaDistShapeShape.hpp>\nusing namespace AMCAX;\nusing namespace std;\n#include<catch.hpp>\n#include<testHelper.h>\n#include <io/OBJTool.hpp>\n#include <modeling/TransformShape.hpp>\n#include <geometry/Geom3BezierCurve.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakePrism.hpp>\n#include <topology/TopoTool.hpp>\n#include <topology/TopoFace.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <topology/BRepExtremaProximityTool.hpp>\n#include <modeling/MakeBox.hpp>\n#include <geometry/Geom3BSplineCurve.hpp>\n#include <topology/TopoWire.hpp>\n#include <modeling/MakeWire.hpp>\n#include <offset/MakePipeShell.hpp>\n#include <topology/BRepExtremaDistShapeShape.hpp>\nusing namespace AMCAX;\nusing namespace std;\n;\n\tSECTION(\"Back translation=0.9*tolerance\")\n\t{\n\t\ty = 0.0 + 0.9 * tolerance;\n\t\ttr1.SetTranslation(Point3(0.0, 0.0, 0.0), Point3(0.0, y, 0.0));\n\t\tTransformShape ts(shape2, tr1, false, false);\n\t\tBRepExtremaProximityTool proxTool(shape1, ts);\n\t\tbool r1 = proxTool.PerformOverlapFaces(overlapShape, tolerance);\n\t\tbool r2 = proxTool.PerformIntersectionFaces(intersectionShape, tolerance);\n\t\tbool r3 = proxTool.PerformProximityValue(tolMax);\n\t\tCHECK(r1 == true);\n\t\tCHECK(r2 == true);\n\t\tCHECK(r3 == true);\n\t\tCHECK(overlapShape.size() == 1);\n\t\tCHECK(intersectionShape.size() == 1);\n\t\tCHECK(tolMax == Approx(y));\n\t\tBRepExtremaDistShapeShape dist(shape1, ts);\n\t\tCHECK(dist.Value() < tolerance);\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API BRepExtremaProximityTool(const TopoShape& shape1, const TopoShape& shape2)\t @param shape2 The second shape\n\t @param shape1 The first shape\n\t @brief Construct proximity tool from two shapes\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <modeling/MakeBox.hpp>\n#include <modeling/MakeCylinder.hpp>\n#include <topology/BRepExtremaProximityTool.hpp>\n#include <io/OBJTool.hpp>\n#include <topology/TopoFace.hpp>\n#include <modeling/TransformShape.hpp>\n#include <topology/TopoExplorerTool.hpp>\n#include <modeling/MakeTorus.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <topology/BRepExtremaDistShapeShape.hpp>\nusing namespace AMCAX;\nusing namespace std;\n#include<catch.hpp>\n#include<testHelper.h>\n#include <modeling/MakeBox.hpp>\n#include <modeling/MakeCylinder.hpp>\n#include <topology/BRepExtremaProximityTool.hpp>\n#include <io/OBJTool.hpp>\n#include <topology/TopoFace.hpp>\n#include <modeling/TransformShape.hpp>\n#include <topology/TopoExplorerTool.hpp>\n#include <modeling/MakeTorus.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <topology/BRepExtremaDistShapeShape.hpp>\nusing namespace AMCAX;\nusing namespace std;\n;\n\tSECTION(\"Edge to Edge\")\n\t{\n\t\ttr1.SetTranslation(Point3(-1.0, 1.0, 0.0), Point3(0.0, 2.0, 0.0));\n\t\tTransformShape ts(shape1, tr1, false, false);\n\t\tBRepExtremaProximityTool proxTool(ts, shape2);\n\t\tbool r1 = proxTool.PerformOverlapFaces(overlapShape, tolerance);\n\t\tCHECK(r1 == false);\n\t\tCHECK(overlapShape.size() == 0);\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API bool PerformProximityValue(double& hdProxDistance)\t @return true if perform successfully\n\t @param hdProxDistance The result approximate hausdorff distance\n\t @details The hausdorff distance H(S1, S2) = max(maxmin||S1 - S2||, maxmin||S2 - S1||);\n\t @brief Compute the approximate hausdorff distance with two shape\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <modeling/MakeSphere.hpp>\n#include <topology/BRepExtremaProximityTool.hpp>\n#include <io/OBJTool.hpp>\n#include <modeling/TransformShape.hpp>\n#include <topology/TopoExplorerTool.hpp>\n#include <modeling/MakeCone.hpp>\n#include <modeling/MakeSphere.hpp>\n#include <topology/BRepExtremaDistShapeShape.hpp>\nusing namespace std;\n#include<catch.hpp>\n#include<testHelper.h>\n#include <modeling/MakeSphere.hpp>\n#include <topology/BRepExtremaProximityTool.hpp>\n#include <io/OBJTool.hpp>\n#include <modeling/TransformShape.hpp>\n#include <topology/TopoExplorerTool.hpp>\n#include <modeling/MakeCone.hpp>\n#include <modeling/MakeSphere.hpp>\n#include <topology/BRepExtremaDistShapeShape.hpp>\nusing namespace std;\n;\n\tSECTION(\"U Direction[Complete overlap]\")\n\t{\n\t\tBRepExtremaProximityTool proxTool(shape1, shape2);\n\t\tbool r1 = proxTool.PerformOverlapFaces(overlapShape, tolerance);\n\t\tbool r2 = proxTool.PerformIntersectionFaces(intersectionShape, tolerance);\n\t\tbool r3 = proxTool.PerformProximityValue(tolMax);\n\t\tCHECK(r1 == true);\n\t\tCHECK(r2 == true);\n\t\tCHECK(r3 == true);\n\t\tCHECK(overlapShape.size() == 1);\n\t\tCHECK(intersectionShape.size() == 1);\n\t\tCHECK(tolMax == Approx(0.0));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API bool PerformIntersectionFaces(std::vector<std::pair<TopoShape, TopoShape>>& facesInShape, const double tolerance = Precision::Confusion()\t @return true if two shape have intersecting faces\n\t @param tolerance The tolerance used for check intersection\n\t @param facesInShape The couple of faces which intersect with each other\n\t @brief Performs find intersecting faces of shape\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <modeling/MakeSphere.hpp>\n#include <topology/BRepExtremaProximityTool.hpp>\n#include <io/OBJTool.hpp>\n#include <modeling/TransformShape.hpp>\n#include <topology/TopoExplorerTool.hpp>\n#include <modeling/MakeCone.hpp>\n#include <modeling/MakeSphere.hpp>\n#include <topology/BRepExtremaDistShapeShape.hpp>\nusing namespace std;\n#include<catch.hpp>\n#include<testHelper.h>\n#include <modeling/MakeSphere.hpp>\n#include <topology/BRepExtremaProximityTool.hpp>\n#include <io/OBJTool.hpp>\n#include <modeling/TransformShape.hpp>\n#include <topology/TopoExplorerTool.hpp>\n#include <modeling/MakeCone.hpp>\n#include <modeling/MakeSphere.hpp>\n#include <topology/BRepExtremaDistShapeShape.hpp>\nusing namespace std;\n;\n\tSECTION(\"V Direction[Translation=8.0]\")\n\t{\n\t\tz = 8.0;\n\t\ttr1.SetTranslation(Point3(0.0, 0.0, 0.0), Point3(0.0, 6.0, z));\n\t\tTransformShape ts(shape2, tr1, false, false);\n\t\tBRepExtremaProximityTool proxTool(shape1, ts);\n\t\tbool r2 = proxTool.PerformIntersectionFaces(intersectionShape, tolerance);\n\t\tCHECK(r2 == true);\n\t\tCHECK(intersectionShape.size() == 1);\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API bool PerformOverlapFaces(std::vector<std::pair<TopoShape, TopoShape>>& facesInShape, const double tolerance = Precision::Confusion()\t @return true if two shape have overlapping faces\n\t @param tolerance The horizontal tolerance used for check overlaping\n\t @param facesInShape The couples of faces with overlapping areas\n\t @brief Performs find faces of shape with finite overlapping areas\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <modeling/MakeSphere.hpp>\n#include <topology/BRepExtremaProximityTool.hpp>\n#include <io/OBJTool.hpp>\n#include <modeling/TransformShape.hpp>\n#include <topology/TopoExplorerTool.hpp>\n#include <modeling/MakeCone.hpp>\n#include <modeling/MakeSphere.hpp>\n#include <topology/BRepExtremaDistShapeShape.hpp>\nusing namespace std;\n#include<catch.hpp>\n#include<testHelper.h>\n#include <modeling/MakeSphere.hpp>\n#include <topology/BRepExtremaProximityTool.hpp>\n#include <io/OBJTool.hpp>\n#include <modeling/TransformShape.hpp>\n#include <topology/TopoExplorerTool.hpp>\n#include <modeling/MakeCone.hpp>\n#include <modeling/MakeSphere.hpp>\n#include <topology/BRepExtremaDistShapeShape.hpp>\nusing namespace std;\n;\n\tSECTION(\"U Direction[angle=M_PI_2-0.1*tolerance]\")\n\t{\n\t\tangle = M_PI_2 - 0.1 * tolerance;\n\t\ttr.SetRotation(axis, angle);\n\t\tTransformShape ts(shape2, tr, false, false);\n\t\tBRepExtremaProximityTool proxTool(shape1, ts);\n\t\tbool r1 = proxTool.PerformOverlapFaces(overlapShape, tolerance);\n\t\tCHECK(r1 == true);\n\t\tCHECK(overlapShape.size() == 1);\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API void LoadShapes(const TopoShape& shape1, const TopoShape& shape2)\t @param shape2 The second shape\n\t @param shape1 The first shape\n\t @brief Load the shape of proximity tool\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <modeling/MakeSphere.hpp>\n#include <topology/BRepExtremaProximityTool.hpp>\n#include <io/OBJTool.hpp>\n#include <modeling/TransformShape.hpp>\n#include <topology/TopoExplorerTool.hpp>\n#include <modeling/MakeCone.hpp>\n#include <modeling/MakeSphere.hpp>\n#include <topology/BRepExtremaDistShapeShape.hpp>\nusing namespace std;\n#include<catch.hpp>\n#include<testHelper.h>\n#include <modeling/MakeSphere.hpp>\n#include <topology/BRepExtremaProximityTool.hpp>\n#include <io/OBJTool.hpp>\n#include <modeling/TransformShape.hpp>\n#include <topology/TopoExplorerTool.hpp>\n#include <modeling/MakeCone.hpp>\n#include <modeling/MakeSphere.hpp>\n#include <topology/BRepExtremaDistShapeShape.hpp>\nusing namespace std;\n;\n\tSECTION(\"Point to Point\")\n\t{\n\t\tangle = M_PI;\n\t\ttr1.SetRotation(axis, angle);\n\t\tTransformShape ts1(shape2, tr1, false, false);\n\t\ty = -1.0 + 2.0;\n\t\ttr.SetTranslation(Point3(0.0, -1.0, 1.0), Point3(0.0, y, 1.0));\n\t\tTransformShape ts(ts1, tr, false, false);\n\t\tBRepExtremaProximityTool proxTool(shape1, ts);\n\t\tbool r1 = proxTool.PerformOverlapFaces(overlapShape, tolerance);\n\t\tbool r2 = proxTool.PerformIntersectionFaces(intersectionShape, tolerance);\n\t\tbool r3 = proxTool.PerformProximityValue(tolMax);\n\t\tCHECK(r1 == false);\n\t\tCHECK(r2 == true);\n\t\tCHECK(r3 == true);\n\t\tCHECK(overlapShape.size() == 0);\n\t\tCHECK(intersectionShape.size() == 1);\n\t\tBRepExtremaDistShapeShape dist(shape1, ts);\n\t\tCHECK(dist.Value() < tolerance);\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API BRepExtremaProximityTool(const TopoShape& shape1, const TopoShape& shape2)\t @param shape2 The second shape\n\t @param shape1 The first shape\n\t @brief Construct proximity tool from two shapes\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <modeling/MakeSphere.hpp>\n#include <topology/BRepExtremaProximityTool.hpp>\n#include <io/OBJTool.hpp>\n#include <modeling/TransformShape.hpp>\n#include <topology/TopoExplorerTool.hpp>\n#include <modeling/MakeCone.hpp>\n#include <modeling/MakeSphere.hpp>\n#include <topology/BRepExtremaDistShapeShape.hpp>\nusing namespace std;\n#include<catch.hpp>\n#include<testHelper.h>\n#include <modeling/MakeSphere.hpp>\n#include <topology/BRepExtremaProximityTool.hpp>\n#include <io/OBJTool.hpp>\n#include <modeling/TransformShape.hpp>\n#include <topology/TopoExplorerTool.hpp>\n#include <modeling/MakeCone.hpp>\n#include <modeling/MakeSphere.hpp>\n#include <topology/BRepExtremaDistShapeShape.hpp>\nusing namespace std;\n;\n\tSECTION(\"point overlap\")\n\t{\n\t\tAxis3 axis(Point3(0.0, 0.0, 0.0), Direction3(1.0, 0.0, 0.0));\n\t\tangle = M_PI;\n\t\ttr.SetRotation(axis, angle);\n\t\tTransformShape ts(shape2, tr, false, false);\n\t\tBRepExtremaProximityTool proxTool(shape1, ts);\n\t\tbool r1 = proxTool.PerformOverlapFaces(overlapShape, tolerance);\n\t\tCHECK(r1 == false);\n\t\tCHECK(overlapShape.size() == 0);\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API BRepExtremaProximityTool()\t @brief Empty constructor for proximity tool\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <modeling/MakeSphere.hpp>\n#include <topology/BRepExtremaProximityTool.hpp>\n#include <io/OBJTool.hpp>\n#include <modeling/TransformShape.hpp>\n#include <topology/TopoExplorerTool.hpp>\n#include <modeling/MakeCone.hpp>\n#include <modeling/MakeSphere.hpp>\n#include <topology/BRepExtremaDistShapeShape.hpp>\nusing namespace std;\n#include<catch.hpp>\n#include<testHelper.h>\n#include <modeling/MakeSphere.hpp>\n#include <topology/BRepExtremaProximityTool.hpp>\n#include <io/OBJTool.hpp>\n#include <modeling/TransformShape.hpp>\n#include <topology/TopoExplorerTool.hpp>\n#include <modeling/MakeCone.hpp>\n#include <modeling/MakeSphere.hpp>\n#include <topology/BRepExtremaDistShapeShape.hpp>\nusing namespace std;\n;\n\tSECTION(\"Left Translation=2.0\")\n\t{\n\t\tx = 0.0 - 2.0;\n\t\ttr.SetTranslation(Point3(0.0, 1.0, 1.0), Point3(x, 1.0, 1.0));\n\t\tTransformShape ts(shape2, tr, false, false);\n\t\tBRepExtremaProximityTool proxTool(shape1, ts);\n\t\tbool r2 = proxTool.PerformIntersectionFaces(intersectionShape, tolerance);\n\t\tCHECK(r2 == true);\n\t\tCHECK(intersectionShape.size() == 1);\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API bool PerformProximityValue(double& hdProxDistance)\t @return true if perform successfully\n\t @param hdProxDistance The result approximate hausdorff distance\n\t @details The hausdorff distance H(S1, S2) = max(maxmin||S1 - S2||, maxmin||S2 - S1||);\n\t @brief Compute the approximate hausdorff distance with two shape\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <modeling/MakeVertex.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeWire.hpp>\n#include <modeling/MakeBox.hpp>\n#include <modeling/MakeCylinder.hpp>\n#include <topology/TopoCompSolid.hpp>\n#include <topology/TopoCompound.hpp>\n#include <topology/TopoFace.hpp>\n#include <topology/TopoSolid.hpp>\n#include <topology/TopoShell.hpp>\n#include <topology/TopoBuilder.hpp>\n#include <topology/TopoExplorerTool.hpp>\n#include <topology/BRepExtremaProximityTool.hpp>\n#include <io/OBJTool.hpp>\n#include <modeling/TransformShape.hpp>\n#include <topology/BRepExtremaDistShapeShape.hpp>\nusing namespace std;\n#include<catch.hpp>\n#include<testHelper.h>\n#include <modeling/MakeVertex.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeWire.hpp>\n#include <modeling/MakeBox.hpp>\n#include <modeling/MakeCylinder.hpp>\n#include <topology/TopoCompSolid.hpp>\n#include <topology/TopoCompound.hpp>\n#include <topology/TopoFace.hpp>\n#include <topology/TopoSolid.hpp>\n#include <topology/TopoShell.hpp>\n#include <topology/TopoBuilder.hpp>\n#include <topology/TopoExplorerTool.hpp>\n#include <topology/BRepExtremaProximityTool.hpp>\n#include <io/OBJTool.hpp>\n#include <modeling/TransformShape.hpp>\n#include <topology/BRepExtremaDistShapeShape.hpp>\nusing namespace std;\n;\n\tSECTION(\"Parametric Construction-TopoShape\")\n\t{\n\t\tTopoShape shape1 = MakeBox(Point3(0.0, 0.0, 0.0), Point3(2.0, 2.0, 1.0));\n\t\tTopoShape shape2 = MakeBox(Point3(1.0, 1.0, 0.0), Point3(3.0, 3.0, 1.0));\n\t\tBRepExtremaProximityTool proxTool(shape1, shape2);\n\t\tvector<pair<TopoShape, TopoShape>> overlapShape;\n\t\tvector<pair<TopoShape, TopoShape>> intersectionShape;\n\t\tbool r1 = proxTool.PerformOverlapFaces(overlapShape, tolerance);\n\t\tbool r2 = proxTool.PerformIntersectionFaces(intersectionShape, tolerance);\n\t\tbool r3 = proxTool.PerformProximityValue(tolMax);\n\t\tCHECK(r1 == true);\n\t\tCHECK(r2 == true);\n\t\tCHECK(r3 == true);\n\t\tCHECK(overlapShape.size() == 2);\n\t\tCHECK(intersectionShape.size() == 12);\n\t\tCHECK(tolMax == Approx(sqrt(2.0)));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API bool PerformIntersectionFaces(std::vector<std::pair<TopoShape, TopoShape>>& facesInShape, const double tolerance = Precision::Confusion()\t @return true if two shape have intersecting faces\n\t @param tolerance The tolerance used for check intersection\n\t @param facesInShape The couple of faces which intersect with each other\n\t @brief Performs find intersecting faces of shape\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <modeling/MakeVertex.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeWire.hpp>\n#include <modeling/MakeBox.hpp>\n#include <modeling/MakeCylinder.hpp>\n#include <topology/TopoCompSolid.hpp>\n#include <topology/TopoCompound.hpp>\n#include <topology/TopoFace.hpp>\n#include <topology/TopoSolid.hpp>\n#include <topology/TopoShell.hpp>\n#include <topology/TopoBuilder.hpp>\n#include <topology/TopoExplorerTool.hpp>\n#include <topology/BRepExtremaProximityTool.hpp>\n#include <io/OBJTool.hpp>\n#include <modeling/TransformShape.hpp>\n#include <topology/BRepExtremaDistShapeShape.hpp>\nusing namespace std;\n#include<catch.hpp>\n#include<testHelper.h>\n#include <modeling/MakeVertex.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeWire.hpp>\n#include <modeling/MakeBox.hpp>\n#include <modeling/MakeCylinder.hpp>\n#include <topology/TopoCompSolid.hpp>\n#include <topology/TopoCompound.hpp>\n#include <topology/TopoFace.hpp>\n#include <topology/TopoSolid.hpp>\n#include <topology/TopoShell.hpp>\n#include <topology/TopoBuilder.hpp>\n#include <topology/TopoExplorerTool.hpp>\n#include <topology/BRepExtremaProximityTool.hpp>\n#include <io/OBJTool.hpp>\n#include <modeling/TransformShape.hpp>\n#include <topology/BRepExtremaDistShapeShape.hpp>\nusing namespace std;\n;\n\tSECTION(\"horizontal translation[separate=3.0*tolerance] \")\n\t{\n\t\tx1 = 2.0 + 3.0 * tolerance;\n\t\tx2 = 4.0 + 3.0 * tolerance;\n\t\tMakeBox box2(Point3(x1, 0.0, 0.0), Point3(x2, 2.0, 1.0));\n\t\tTopoFace shape2 = box2.ZMinFace();\n\t\tproxTool.LoadShapes(shape1, shape2);\n\t\tbool r2 = proxTool.PerformIntersectionFaces(intersectionShape, tolerance);\n\t\tCHECK(r2 == false);\n\t\tCHECK(intersectionShape.size() == 0);\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API bool PerformOverlapFaces(std::vector<std::pair<TopoShape, TopoShape>>& facesInShape, const double tolerance = Precision::Confusion()\t @return true if two shape have overlapping faces\n\t @param tolerance The horizontal tolerance used for check overlaping\n\t @param facesInShape The couples of faces with overlapping areas\n\t @brief Performs find faces of shape with finite overlapping areas\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <modeling/MakeVertex.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeWire.hpp>\n#include <modeling/MakeBox.hpp>\n#include <modeling/MakeCylinder.hpp>\n#include <topology/TopoCompSolid.hpp>\n#include <topology/TopoCompound.hpp>\n#include <topology/TopoFace.hpp>\n#include <topology/TopoSolid.hpp>\n#include <topology/TopoShell.hpp>\n#include <topology/TopoBuilder.hpp>\n#include <topology/TopoExplorerTool.hpp>\n#include <topology/BRepExtremaProximityTool.hpp>\n#include <io/OBJTool.hpp>\n#include <modeling/TransformShape.hpp>\n#include <topology/BRepExtremaDistShapeShape.hpp>\nusing namespace std;\n#include<catch.hpp>\n#include<testHelper.h>\n#include <modeling/MakeVertex.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeWire.hpp>\n#include <modeling/MakeBox.hpp>\n#include <modeling/MakeCylinder.hpp>\n#include <topology/TopoCompSolid.hpp>\n#include <topology/TopoCompound.hpp>\n#include <topology/TopoFace.hpp>\n#include <topology/TopoSolid.hpp>\n#include <topology/TopoShell.hpp>\n#include <topology/TopoBuilder.hpp>\n#include <topology/TopoExplorerTool.hpp>\n#include <topology/BRepExtremaProximityTool.hpp>\n#include <io/OBJTool.hpp>\n#include <modeling/TransformShape.hpp>\n#include <topology/BRepExtremaDistShapeShape.hpp>\nusing namespace std;\n;\n\tSECTION(\"horizontal translation[overlap=0] \")\n\t{\n\t\tx1 = 2.0;\n\t\tx2 = 4.0;\n\t\tMakeBox box2(Point3(x1, 0.0, 0.0), Point3(x2, 2.0, 1.0));\n\t\tTopoFace shape2 = box2.ZMinFace();\n\t\tproxTool.LoadShapes(shape1, shape2);\n\t\tbool r1 = proxTool.PerformOverlapFaces(overlapShape, tolerance);\n\t\tCHECK(overlapShape.size() == 0);\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API void LoadShapes(const TopoShape& shape1, const TopoShape& shape2)\t @param shape2 The second shape\n\t @param shape1 The first shape\n\t @brief Load the shape of proximity tool\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <modeling/MakeVertex.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeWire.hpp>\n#include <modeling/MakeBox.hpp>\n#include <modeling/MakeCylinder.hpp>\n#include <topology/TopoCompSolid.hpp>\n#include <topology/TopoCompound.hpp>\n#include <topology/TopoFace.hpp>\n#include <topology/TopoSolid.hpp>\n#include <topology/TopoShell.hpp>\n#include <topology/TopoBuilder.hpp>\n#include <topology/TopoExplorerTool.hpp>\n#include <topology/BRepExtremaProximityTool.hpp>\n#include <io/OBJTool.hpp>\n#include <modeling/TransformShape.hpp>\n#include <topology/BRepExtremaDistShapeShape.hpp>\nusing namespace std;\n#include<catch.hpp>\n#include<testHelper.h>\n#include <modeling/MakeVertex.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeWire.hpp>\n#include <modeling/MakeBox.hpp>\n#include <modeling/MakeCylinder.hpp>\n#include <topology/TopoCompSolid.hpp>\n#include <topology/TopoCompound.hpp>\n#include <topology/TopoFace.hpp>\n#include <topology/TopoSolid.hpp>\n#include <topology/TopoShell.hpp>\n#include <topology/TopoBuilder.hpp>\n#include <topology/TopoExplorerTool.hpp>\n#include <topology/BRepExtremaProximityTool.hpp>\n#include <io/OBJTool.hpp>\n#include <modeling/TransformShape.hpp>\n#include <topology/BRepExtremaDistShapeShape.hpp>\nusing namespace std;\n;\n\tSECTION(\"LoadShapes-Null\")\n\t{\n\t\tTopoShape shape1;\n\t\tTopoShape shape2;\n\t\tBRepExtremaProximityTool proxTool;\n\t\tproxTool.LoadShapes(shape1, shape2);\n\t\tbool r3 = proxTool.PerformProximityValue(tolMax);\n\t\tCHECK(r3 == false);\n\t\tCHECK(tolMax == Approx(0.0));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API BRepExtremaProximityTool(const TopoShape& shape1, const TopoShape& shape2)\t @param shape2 The second shape\n\t @param shape1 The first shape\n\t @brief Construct proximity tool from two shapes\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <modeling/MakeVertex.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeWire.hpp>\n#include <modeling/MakeBox.hpp>\n#include <modeling/MakeCylinder.hpp>\n#include <topology/TopoCompSolid.hpp>\n#include <topology/TopoCompound.hpp>\n#include <topology/TopoFace.hpp>\n#include <topology/TopoSolid.hpp>\n#include <topology/TopoShell.hpp>\n#include <topology/TopoBuilder.hpp>\n#include <topology/TopoExplorerTool.hpp>\n#include <topology/BRepExtremaProximityTool.hpp>\n#include <io/OBJTool.hpp>\n#include <modeling/TransformShape.hpp>\n#include <topology/BRepExtremaDistShapeShape.hpp>\nusing namespace std;\n#include<catch.hpp>\n#include<testHelper.h>\n#include <modeling/MakeVertex.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeWire.hpp>\n#include <modeling/MakeBox.hpp>\n#include <modeling/MakeCylinder.hpp>\n#include <topology/TopoCompSolid.hpp>\n#include <topology/TopoCompound.hpp>\n#include <topology/TopoFace.hpp>\n#include <topology/TopoSolid.hpp>\n#include <topology/TopoShell.hpp>\n#include <topology/TopoBuilder.hpp>\n#include <topology/TopoExplorerTool.hpp>\n#include <topology/BRepExtremaProximityTool.hpp>\n#include <io/OBJTool.hpp>\n#include <modeling/TransformShape.hpp>\n#include <topology/BRepExtremaDistShapeShape.hpp>\nusing namespace std;\n;\n\tSECTION(\"Parametric Construction-Null\")\n\t{\n\t\tTopoShape shape1;\n\t\tTopoShape shape2;\n\t\tBRepExtremaProximityTool proxTool(shape1, shape2);\n\t\tbool r3 = proxTool.PerformProximityValue(tolMax);\n\t\tCHECK(r3 == false);\n\t\tCHECK(tolMax == Approx(0.0));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API BRepExtremaProximityTool()\t @brief Empty constructor for proximity tool\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <modeling/MakeVertex.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeWire.hpp>\n#include <modeling/MakeBox.hpp>\n#include <modeling/MakeCylinder.hpp>\n#include <topology/TopoCompSolid.hpp>\n#include <topology/TopoCompound.hpp>\n#include <topology/TopoFace.hpp>\n#include <topology/TopoSolid.hpp>\n#include <topology/TopoShell.hpp>\n#include <topology/TopoBuilder.hpp>\n#include <topology/TopoExplorerTool.hpp>\n#include <topology/BRepExtremaProximityTool.hpp>\n#include <io/OBJTool.hpp>\n#include <modeling/TransformShape.hpp>\n#include <topology/BRepExtremaDistShapeShape.hpp>\nusing namespace std;\n#include<catch.hpp>\n#include<testHelper.h>\n#include <modeling/MakeVertex.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeWire.hpp>\n#include <modeling/MakeBox.hpp>\n#include <modeling/MakeCylinder.hpp>\n#include <topology/TopoCompSolid.hpp>\n#include <topology/TopoCompound.hpp>\n#include <topology/TopoFace.hpp>\n#include <topology/TopoSolid.hpp>\n#include <topology/TopoShell.hpp>\n#include <topology/TopoBuilder.hpp>\n#include <topology/TopoExplorerTool.hpp>\n#include <topology/BRepExtremaProximityTool.hpp>\n#include <io/OBJTool.hpp>\n#include <modeling/TransformShape.hpp>\n#include <topology/BRepExtremaDistShapeShape.hpp>\nusing namespace std;\n;\n\tSECTION(\"Default Construction\")\n\t{\n\t\tBRepExtremaProximityTool proxTool;\n\t\tbool r3 = proxTool.PerformProximityValue(tolMax);\n\t\tCHECK(r3 == false);\n\t\tCHECK(tolMax == Approx(0.0));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static void AddToBox(const TopoShape& S, BoundingBox3& B, bool useTriangulation = true)\t @param[in] useTriangulation Does the computation use triangulation\n\t @param[in,out] B The bounding box\n\t @param[in] S The shape\n\t @brief Add a shape to a bounding box\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <common/BoundingBox3.hpp>\n#include <topology/BRepBoundingBox.hpp>\n#include <topology/TopoExplorerTool.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"NOTFIX bug1:  case1:this is a case for BoundingBox3\", \"[topology][BoundingBox3][bug]\") \n{\n\tTopoShape toposhape;\n\tOCCTIO::OCCTTool::Read(toposhape, INPUT_PATH_PREFIX\"topology/Lens_1.brep\");\n\tIndexSet<TopoShape> shapeFaces;\n\tTopoExplorerTool::MapShapes(toposhape, ShapeType::Face, shapeFaces);\n\tCHECK(shapeFaces.size() == 3);\n\tTopoShape shape1 = shapeFaces[1];\n\tOCCTIO::OCCTTool::Write(shape1, OUTPUT_PATH_PREFIX\"firstface.brep\");\n\tBoundingBox3 box3;\n\tBRepBoundingBox::AddToBox(shape1, box3);\n\tPoint3 pmin = box3.CornerMin(), pmax = box3.CornerMax();\n\tCHECK(pmin.X() == Approx(-1.0));\n\tCHECK(pmin.Y() == Approx(-1.0));\n\tCHECK(pmin.Z() == Approx(-0.5));\n\tCHECK(pmax.X() == Approx(1.0));\n\tCHECK(pmax.Y() == Approx(1.0));\n\tCHECK(pmax.Z() == Approx(-0.3));\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API bool WriteShape(const AMCAX::TopoShape& shape)\t @return True if the shape is written successfully, otherwise false.\n\t @param[in] shape The TopoShape object and related data to be translated and to be wrote into the STEP file.\n\t @brief Add a TopoShape to the exporting list.\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <step/StepWriter.hpp>\n#include <step/StepReader.hpp>\n#include<step/StepDataTool.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"bug1: WriteShape  \", \"[step][WriteShape][P1][fixbug]\") {\n\tAMCAX::TopoShape shapeRead;\n\tAMCAX::OCCTIO::OCCTTool::Read(shapeRead, INPUT_PATH_PREFIX\"tmploft.brep\");\n\tCHECK(shapeRead.IsNull() == false);\n\tAMCAX::STEP::StepWriter writer(OUTPUT_PATH_PREFIX\"tmploft.step\");\n\twriter.Init();\n\tbool bWriteShape = writer.WriteShape(shapeRead);\n\tCHECK(bWriteShape == true);\n\twriter.Done();\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API bool WriteShape(const std::shared_ptr<AMCAX::STEP::StepData>& shape)\t @return True if the shape is written successfully, otherwise false.\n\t @param[in] shape The TopoShape object and related data to be translated and to be wrote into the STEP file.\n\t @brief Add a StepData tree to the exporting list.\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <step/StepWriter.hpp>\n#include <step/StepReader.hpp>\n#include<step/StepDataTool.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"bug1: WriteShape  \", \"[step][WriteShape][P1][fixbug]\") {\n\tAMCAX::TopoShape shapeRead;\n\tAMCAX::OCCTIO::OCCTTool::Read(shapeRead, INPUT_PATH_PREFIX\"tmploft.brep\");\n\tCHECK(shapeRead.IsNull() == false);\n\tAMCAX::STEP::StepWriter writer(OUTPUT_PATH_PREFIX\"tmploft.step\");\n\twriter.Init();\n\tbool bWriteShape = writer.WriteShape(shapeRead);\n\tCHECK(bWriteShape == true);\n\twriter.Done();\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API StepMeshDataList<Traits>& GetShapes()\t @return The list of pointers of StepMeshData Trees.\n\t @brief Get the list of pointers of StepMeshData Trees.\n,\n",
      "output": "﻿#include<catch.hpp>\n#include<testHelper.h>\n#include <step/mesh/StepMesh.hpp>\n#include <step/mesh/StepMeshData.hpp>\n#include <step/mesh/StepMeshReader.hpp>\n#include <step/mesh/StepMeshProgress.hpp>\n#include <common/IndexSet.hpp>\n#include <topology/TopoExplorerTool.hpp>\n#include <fstream>\n#include <iostream>\n#include <filesystem>\nusing namespace AMCAX;\nusing namespace  AMCAX::STEP;\nTEST_CASE(\"case1:StepMeshReader  \", \"[step][StepMeshData][P1]\") {\n    StepMeshReader<AMCAX::Meshing::Mesh::TriSoupTraits_Coord> reader(INPUT_PATH_PREFIX\"tank.step\");\n    bool topoSuccess = reader.Read();\n    CHECK(topoSuccess == true);\n    bool meshSuccess = reader.ToMesh();\n    CHECK(meshSuccess == true);\n    StepMeshDataList<AMCAX::Meshing::Mesh::TriSoupTraits_Coord> container = reader.GetShapes();\n    for (auto& meshdata : container)\n    {\n        int nSolidCount = meshdata->SolidCount(true);\n        int nMeshCount = meshdata->MeshCount(true);\n        std::cout << \"SolidCount: \" << nSolidCount << \", \";\n        std::cout << \"MeshCount: \" << nMeshCount << std::endl;\n        CHECK(nSolidCount == nMeshCount);\n        CHECK(nSolidCount != 0);\n        CHECK(nMeshCount != 0);\n    }\n}\nvoid ProgressCallback(const STEP::StepMeshProgressState state,\n    const STEP::StepProgressCarrier c1,\n    const STEP::StepProgressCarrier c2)\n{\n    std::ofstream logFile(OUTPUT_PATH_PREFIX\"progress.txt\", std::ios::app); \n    if (logFile.is_open())\n    {\n        logFile << \"State: \" << state\n            << \" c1: \" << c1.payload.u64\n            << \" c2: \" << c2.payload.u64\n            << std::endl;\n        logFile.close(); \n    }\n    else\n    {\n        std::cerr << \"无法打开文件 progress.txt\" << std::endl;\n    }\n}\nnamespace fs = std::filesystem;\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API const StepMeshDataList<Traits>& GetShapes()\t @return The list of pointers of StepMeshData Trees.\n\t @brief Get the list of pointers of StepMeshData Trees.\n,\n",
      "output": "﻿#include<catch.hpp>\n#include<testHelper.h>\n#include <step/mesh/StepMesh.hpp>\n#include <step/mesh/StepMeshData.hpp>\n#include <step/mesh/StepMeshReader.hpp>\n#include <step/mesh/StepMeshProgress.hpp>\n#include <common/IndexSet.hpp>\n#include <topology/TopoExplorerTool.hpp>\n#include <fstream>\n#include <iostream>\n#include <filesystem>\nusing namespace AMCAX;\nusing namespace  AMCAX::STEP;\nTEST_CASE(\"case1:StepMeshReader  \", \"[step][StepMeshData][P1]\") {\n    StepMeshReader<AMCAX::Meshing::Mesh::TriSoupTraits_Coord> reader(INPUT_PATH_PREFIX\"tank.step\");\n    bool topoSuccess = reader.Read();\n    CHECK(topoSuccess == true);\n    bool meshSuccess = reader.ToMesh();\n    CHECK(meshSuccess == true);\n    StepMeshDataList<AMCAX::Meshing::Mesh::TriSoupTraits_Coord> container = reader.GetShapes();\n    for (auto& meshdata : container)\n    {\n        int nSolidCount = meshdata->SolidCount(true);\n        int nMeshCount = meshdata->MeshCount(true);\n        std::cout << \"SolidCount: \" << nSolidCount << \", \";\n        std::cout << \"MeshCount: \" << nMeshCount << std::endl;\n        CHECK(nSolidCount == nMeshCount);\n        CHECK(nSolidCount != 0);\n        CHECK(nMeshCount != 0);\n    }\n}\nvoid ProgressCallback(const STEP::StepMeshProgressState state,\n    const STEP::StepProgressCarrier c1,\n    const STEP::StepProgressCarrier c2)\n{\n    std::ofstream logFile(OUTPUT_PATH_PREFIX\"progress.txt\", std::ios::app); \n    if (logFile.is_open())\n    {\n        logFile << \"State: \" << state\n            << \" c1: \" << c1.payload.u64\n            << \" c2: \" << c2.payload.u64\n            << std::endl;\n        logFile.close(); \n    }\n    else\n    {\n        std::cerr << \"无法打开文件 progress.txt\" << std::endl;\n    }\n}\nnamespace fs = std::filesystem;\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API void SetProgressCallback(const StepMeshProgressCallback& callback)\t @param[in] callback The callback function for the progress of the STEP process.\n\t @brief Set the callback function for the progress of the STEP process.\n,\n",
      "output": "﻿#include<catch.hpp>\n#include<testHelper.h>\n#include <step/mesh/StepMesh.hpp>\n#include <step/mesh/StepMeshData.hpp>\n#include <step/mesh/StepMeshReader.hpp>\n#include <step/mesh/StepMeshProgress.hpp>\n#include <common/IndexSet.hpp>\n#include <topology/TopoExplorerTool.hpp>\n#include <fstream>\n#include <iostream>\n#include <filesystem>\nusing namespace AMCAX;\nusing namespace  AMCAX::STEP;\nTEST_CASE(\"case2:StepMeshReader \", \"[step][StepMeshData][P1]\") {\n    StepMeshReader<AMCAX::Meshing::Mesh::TriSoupTraits_Coord> reader(INPUT_PATH_PREFIX\"tank.step\");\n    reader.SetUnit(STEP::StepLengthUnit::PresetLengthUnit::FOOT); \n    fs::path logFilePath = OUTPUT_PATH_PREFIX\"progress.txt\";\n    if (fs::exists(logFilePath))\n    {\n        fs::remove(logFilePath);\n        std::cout << \"deleted progress.txt file\" << std::endl;\n    }\n    reader.SetProgressCallback(ProgressCallback);\n    bool topoSuccess = reader.Read();\n    CHECK(topoSuccess);\n    bool meshSuccess = reader.ToMesh();\n    CHECK(meshSuccess);\n    CHECK( containsStringInFile(OUTPUT_PATH_PREFIX\"progress.txt\", \"State: 0 c1: 0 c2: 0\") );\n    CHECK( containsStringInFile(OUTPUT_PATH_PREFIX\"progress.txt\", \"State: 1 c1: 0 c2: 0\") );\n    CHECK( containsStringInFile(OUTPUT_PATH_PREFIX\"progress.txt\", \"State: 2 c1: 0 c2: 0\") );\n    CHECK( containsStringInFile(OUTPUT_PATH_PREFIX\"progress.txt\", \"State: 3 c1: 0 c2: 0\") );\n    CHECK( containsStringInFile(OUTPUT_PATH_PREFIX\"progress.txt\", \"State: 4 c1: 0 c2: 0\") );\n    CHECK( containsStringInFile(OUTPUT_PATH_PREFIX\"progress.txt\", \"State: 5 c1: 0 c2: 19\") );\n    CHECK( containsStringInFile(OUTPUT_PATH_PREFIX\"progress.txt\", \"State: 6 c1: 1 c2: 19\") );\n    CHECK( containsStringInFile(OUTPUT_PATH_PREFIX\"progress.txt\", \"State: 6 c1: 19 c2: 19\") );\n    CHECK( containsStringInFile(OUTPUT_PATH_PREFIX\"progress.txt\", \"State: 7 c1: 19 c2: 19\") );\n    CHECK( containsStringInFile(OUTPUT_PATH_PREFIX\"progress.txt\", \"State: 8 c1: 0 c2: 0\") );\n    CHECK( containsStringInFile(OUTPUT_PATH_PREFIX\"progress.txt\", \"State: 9 c1: 0 c2: 0\") );\n    CHECK( containsStringInFile(OUTPUT_PATH_PREFIX\"progress.txt\", \"State: 10 c1: 0 c2: 0\") );\n    CHECK( containsStringInFile(OUTPUT_PATH_PREFIX\"progress.txt\", \"State: 512 c1: 0 c2: 0\") );\n    CHECK( containsStringInFile(OUTPUT_PATH_PREFIX\"progress.txt\", \"State: 513 c1: 0 c2: 0\") );\n    CHECK( containsStringInFile(OUTPUT_PATH_PREFIX\"progress.txt\", \"State: 514 c1: 0 c2: 0\") );\n    CHECK( containsStringInFile(OUTPUT_PATH_PREFIX\"progress.txt\", \"State: 515 c1: 0 c2: 54\") );\n    CHECK( containsStringInFile(OUTPUT_PATH_PREFIX\"progress.txt\", \"State: 516 c1: 1 c2: 54\") );\n    CHECK( containsStringInFile(OUTPUT_PATH_PREFIX\"progress.txt\", \"State: 516 c1: 54 c2: 54\") );\n    CHECK( containsStringInFile(OUTPUT_PATH_PREFIX\"progress.txt\", \"State: 517 c1: 0 c2: 0\") );\n    CHECK( containsStringInFile(OUTPUT_PATH_PREFIX\"progress.txt\", \"State: 518 c1: 0 c2: 0\") );\n    CHECK( containsStringInFile(OUTPUT_PATH_PREFIX\"progress.txt\", \"State: 519 c1: 0 c2: 0\") );\n    CHECK( containsStringInFile(OUTPUT_PATH_PREFIX\"progress.txt\", \"State: 520 c1: 0 c2: 0\") );\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] AMCAX_API static AMCAX::TopoShape MakeCompound(AMCAX::STEP::StepDataList& sdlist, bool inplace = false)\t @note   If the StepDataList contains only one shape object, the shape object itself will be returned.\n\t @return A TopoShape.\n\t @param  sdlist A StepDataList.\n\t @brief  Create a TopoShape from a StepDataList.\n,\n",
      "output": "#include <catch.hpp>\n#include<testHelper.h>\n#include <common/BoundingBox3.hpp>\n#include <topology/BRepBoundingBox.hpp>\n#include <step/StepReader.hpp>\n#include <step/StepDataTool.hpp>\n#include <io/ShapeTool.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"bug1: StepDataTool::ApplyTrsfInplace test bug:  \", \"[step][StepDataTool][bug]\")\n{\n\tOUTPUT_DIRECTORY(Step, ApplyTrsfInline);\n\tSTEP::StepReader reader(INPUT_PATH_PREFIX\"./step_data/bed214T.step\");\n\treader.Read();\n\tSTEP::StepDataList list = std::move(reader.GetShapes());\n\tSTEP::StepDataList sdlist = STEP::StepDataTool::ApplyTrsfInplace(list);\n\tTopoShape comp = STEP::StepDataTool::MakeCompound(sdlist);\n\tOCCTIO::OCCTTool::Write(comp, outdir + \"ApplyTrsfInplace_result.brep\");\n\tBoundingBox3 bbox3;\n\tBRepBoundingBox::AddToBox(comp, bbox3);\n\tPoint3 pmin = bbox3.CornerMin(), pmax = bbox3.CornerMax();\n\tdouble dis = pmin.Distance(pmax);\n\tCHECK(dis == Approx(3754.52));\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] AMCAX_API static AMCAX::TopoShape MakeCompound(std::shared_ptr<AMCAX::STEP::StepData>& root, bool inplace = false)\t @note   If the StepData tree contains only one shape object, the shape object itself will be returned.\n\t @return A TopoShape.\n\t @param  shape A StepData tree.\n\t @brief  Create a TopoShape from a StepData tree.\n,\n",
      "output": "#include <catch.hpp>\n#include<testHelper.h>\n#include <common/BoundingBox3.hpp>\n#include <topology/BRepBoundingBox.hpp>\n#include <step/StepReader.hpp>\n#include <step/StepDataTool.hpp>\n#include <io/ShapeTool.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"bug1: StepDataTool::ApplyTrsfInplace test bug:  \", \"[step][StepDataTool][bug]\")\n{\n\tOUTPUT_DIRECTORY(Step, ApplyTrsfInline);\n\tSTEP::StepReader reader(INPUT_PATH_PREFIX\"./step_data/bed214T.step\");\n\treader.Read();\n\tSTEP::StepDataList list = std::move(reader.GetShapes());\n\tSTEP::StepDataList sdlist = STEP::StepDataTool::ApplyTrsfInplace(list);\n\tTopoShape comp = STEP::StepDataTool::MakeCompound(sdlist);\n\tOCCTIO::OCCTTool::Write(comp, outdir + \"ApplyTrsfInplace_result.brep\");\n\tBoundingBox3 bbox3;\n\tBRepBoundingBox::AddToBox(comp, bbox3);\n\tPoint3 pmin = bbox3.CornerMin(), pmax = bbox3.CornerMax();\n\tdouble dis = pmin.Distance(pmax);\n\tCHECK(dis == Approx(3754.52));\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static AMCAX::STEP::StepDataList& FlattenInplace(AMCAX::STEP::StepDataList& shapes, bool unrolling = true)\t @return An array of StepData nodes, with all transformation applied to the definite shapes.\n\t @param  unrolling Whether each node is allowed to contain 0 or multiple shapes.\n\t @param  shapes An array of the StepData tree.\n\t @brief  Flatten a StepData tree into an one-dimensional array, inplace.\n,\n",
      "output": "#include <catch.hpp>\n#include<testHelper.h>\n#include <common/BoundingBox3.hpp>\n#include <topology/BRepBoundingBox.hpp>\n#include <step/StepReader.hpp>\n#include <step/StepDataTool.hpp>\n#include <io/ShapeTool.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"bug2: StepDataTool::FlattenInplace test bug:  \", \"[step][StepDataTool][bug]\")\n{\n\tOUTPUT_DIRECTORY(Step, ApplyTrsfInline);\n\tSTEP::StepReader reader(INPUT_PATH_PREFIX\"./step_data/bed214T.step\");\n\treader.Read();\n\tSTEP::StepDataList list = std::move(reader.GetShapes());\n\tSTEP::StepDataList sdlist = STEP::StepDataTool::FlattenInplace(list);\n\tTopoShape comp = STEP::StepDataTool::MakeCompound(sdlist);\n\tOCCTIO::OCCTTool::Write(comp, outdir + \"FlattenInplace_result.brep\");\n\tBoundingBox3 bbox3;\n\tBRepBoundingBox::AddToBox(comp, bbox3);\n\tPoint3 pmin = bbox3.CornerMin(), pmax = bbox3.CornerMax();\n\tdouble dis = pmin.Distance(pmax);\n\tCHECK(dis == Approx(3754.52));\n\tSTEP::StepReader reader1(INPUT_PATH_PREFIX\"./step_data/chip_FJ.step\");\n\treader1.Read();\n\tSTEP::StepDataList list1 = std::move(reader1.GetShapes());\n\tSTEP::StepDataList sdlist1 = STEP::StepDataTool::FlattenInplace(list1);\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static AMCAX::STEP::StepDataList& ApplyTrsfInplace(AMCAX::STEP::StepDataList& shapes)\t @return An of the StepData trees, with the structure unchanged, and transformation applied to the definite shapes.\n\t @param  shapes An array of the StepData tree.\n\t @brief  Apply the Transformations to the definite Shapes inplace.\n,\n",
      "output": "#include <catch.hpp>\n#include<testHelper.h>\n#include <common/BoundingBox3.hpp>\n#include <topology/BRepBoundingBox.hpp>\n#include <step/StepReader.hpp>\n#include <step/StepDataTool.hpp>\n#include <io/ShapeTool.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"bug1: StepDataTool::ApplyTrsfInplace test bug:  \", \"[step][StepDataTool][bug]\")\n{\n\tOUTPUT_DIRECTORY(Step, ApplyTrsfInline);\n\tSTEP::StepReader reader(INPUT_PATH_PREFIX\"./step_data/bed214T.step\");\n\treader.Read();\n\tSTEP::StepDataList list = std::move(reader.GetShapes());\n\tSTEP::StepDataList sdlist = STEP::StepDataTool::ApplyTrsfInplace(list);\n\tTopoShape comp = STEP::StepDataTool::MakeCompound(sdlist);\n\tOCCTIO::OCCTTool::Write(comp, outdir + \"ApplyTrsfInplace_result.brep\");\n\tBoundingBox3 bbox3;\n\tBRepBoundingBox::AddToBox(comp, bbox3);\n\tPoint3 pmin = bbox3.CornerMin(), pmax = bbox3.CornerMax();\n\tdouble dis = pmin.Distance(pmax);\n\tCHECK(dis == Approx(3754.52));\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API std::vector<AMCAX::TopoShape>& Shapes()\t @return A mutable reference to shapes in this product node.\n\t @brief Get the mutable reference to shapes in this product node.\n,\n",
      "output": "#include <catch.hpp>\n#include<testHelper.h>\n#include <step/StepData.hpp>\n#include <step/mesh/StepMeshData.hpp>\n#include <step/mesh/StepMeshReader.hpp>\nusing namespace AMCAX;\ntemplate<typename DataPtr>\nvoid traverse(const DataPtr& stepData, const int indent, std::ostream& ost)\n{\n\tfor (int i = 0; i < indent; ++i)\n\t{\n\t\tost << \"|   \";\n\t}\n\tost << stepData->ProductName() << ' ';\n\tost << '[' << stepData->Shapes().size() << ']' << ':' << ' ';\n\tfor (const auto& shape : stepData->Shapes())\n\t{\n\t\tost << stepData->PartColor()[shape].to_string() << ' ';\n\t}\n\tost << std::endl;\n\tfor (const auto& child : stepData->Children())\n\t{\n\t\ttraverse(child, indent + 1, ost);\n\t}\n}\n#include <catch.hpp>\n#include<testHelper.h>\n#include <step/StepData.hpp>\n#include <step/mesh/StepMeshData.hpp>\n#include <step/mesh/StepMeshReader.hpp>\nusing namespace AMCAX;\ntemplate<typename DataPtr>\nvoid traverse(const DataPtr& stepData, const int indent, std::ostream& ost)\n{\n\tfor (int i = 0; i < indent; ++i)\n\t{\n\t\tost << \"|   \";\n\t}\n\tost << stepData->ProductName() << ' ';\n\tost << '[' << stepData->Shapes().size() << ']' << ':' << ' ';\n\tfor (const auto& shape : stepData->Shapes())\n\t{\n\t\tost << stepData->PartColor()[shape].to_string() << ' ';\n\t}\n\tost << std::endl;\n\tfor (const auto& child : stepData->Children())\n\t{\n\t\ttraverse(child, indent + 1, ost);\n\t}\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API const std::vector<AMCAX::TopoShape>& Shapes()\t @return An immutable reference to the shapes in this product node.\n\t @brief Get the immutable reference to shapes in this product node.\n,\n",
      "output": "#include <catch.hpp>\n#include<testHelper.h>\n#include <step/StepData.hpp>\n#include <step/mesh/StepMeshData.hpp>\n#include <step/mesh/StepMeshReader.hpp>\nusing namespace AMCAX;\ntemplate<typename DataPtr>\nvoid traverse(const DataPtr& stepData, const int indent, std::ostream& ost)\n{\n\tfor (int i = 0; i < indent; ++i)\n\t{\n\t\tost << \"|   \";\n\t}\n\tost << stepData->ProductName() << ' ';\n\tost << '[' << stepData->Shapes().size() << ']' << ':' << ' ';\n\tfor (const auto& shape : stepData->Shapes())\n\t{\n\t\tost << stepData->PartColor()[shape].to_string() << ' ';\n\t}\n\tost << std::endl;\n\tfor (const auto& child : stepData->Children())\n\t{\n\t\ttraverse(child, indent + 1, ost);\n\t}\n}\n#include <catch.hpp>\n#include<testHelper.h>\n#include <step/StepData.hpp>\n#include <step/mesh/StepMeshData.hpp>\n#include <step/mesh/StepMeshReader.hpp>\nusing namespace AMCAX;\ntemplate<typename DataPtr>\nvoid traverse(const DataPtr& stepData, const int indent, std::ostream& ost)\n{\n\tfor (int i = 0; i < indent; ++i)\n\t{\n\t\tost << \"|   \";\n\t}\n\tost << stepData->ProductName() << ' ';\n\tost << '[' << stepData->Shapes().size() << ']' << ':' << ' ';\n\tfor (const auto& shape : stepData->Shapes())\n\t{\n\t\tost << stepData->PartColor()[shape].to_string() << ' ';\n\t}\n\tost << std::endl;\n\tfor (const auto& child : stepData->Children())\n\t{\n\t\ttraverse(child, indent + 1, ost);\n\t}\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API bool DoLoop(PolyMesh* mesh, size_t subtime)\t @return Thue if the subdivide is successful\n\t @param subtime The number of subdivision\n\t @param mesh The input triangle mesh \n\t @brief Do Loop subdivision\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelperBase.h>\n#include <common/FrameT.hpp>\n#include <polymeshAPI/MeshMakeCube.hpp>\n#include <polymeshAPI/MeshMakeCone.hpp>\n#include <polymeshAPI/MeshMakeCylinder.hpp>\n#include <polymeshAPI/MeshMakeSphere.hpp>\n#include <polymeshAPI/MeshSubdivideHE.hpp>\n#include <polymeshAPI/MeshSubdivideRender.hpp>\n#include <polymeshAPI/MeshTool.hpp>\n#include <polymesh/PolyMeshIO.hpp>\n#include <polymeshAPI/MeshCheck.hpp>\n#include <chrono>\nusing AMCAX::SubD::MeshSubdivideHE;\nusing AMCAX::SubD::MeshTool;\nusing AMCAX::SubD::MeshSubdivideRenderLoop;\nusing AMCAX::SubD::MeshMakeCube;\nusing AMCAX::SubD::MeshMakeCone;  \nusing AMCAX::SubD::MeshMakeCylinder;  \nusing AMCAX::SubD::MeshMakeSphere;  \nusing AMCAX::SubD::PolyMesh;\nusing AMCAX::Frame3;\nusing AMCAX::SubD::PolyMeshIO;\nstatic void WriteLoopToOBJ(const MeshSubdivideRenderLoop& subdive, std::string& fileName)\n{\n\tstd::ofstream file(fileName);\n\tauto mPoints = subdive.Points();\n\tfor (int i = 0; i < static_cast<int>(mPoints.size()); ++i)\n\t{\n\t\tfile << \"v \" << mPoints[i] << std::endl;\n\t}\n\tauto mFaces = subdive.Faces();\n\tfor (int i = 0; i < static_cast<int>(mFaces.size()); ++i)\n\t{\n\t\tconst std::array<int, 3>& face = mFaces[i];\n\t\tfile << \"f \" << face[0] + 1 << \" \" << face[1] + 1 << \" \" << face[2] + 1 << std::endl;\n\t}\n\tfile.close();\n}\nstatic bool CheckSubdivide(const PolyMesh* beginMesh, const MeshSubdivideRenderLoop& endRenderCC, int level = 1)\n{\n\tsize_t beginVertexNum = beginMesh->numVertices();\n\tsize_t beginEdgeNum = beginMesh->numEdges();\n\tsize_t beginPolygonNum = beginMesh->numPolygons();\n\tsize_t currentVertexNum = beginVertexNum, currentEdgeNum = beginEdgeNum, currentPolygonNum = beginPolygonNum;\n\tfor (int i = 0; i < level; ++i)\n\t{\n\t\tcurrentVertexNum = beginVertexNum + beginEdgeNum;\n\t\tcurrentEdgeNum = beginEdgeNum * 2 + 3 * beginPolygonNum;\n\t\tcurrentPolygonNum = 4 * beginPolygonNum;\n\t\tbeginVertexNum = currentVertexNum;\n\t\tbeginEdgeNum = currentEdgeNum;\n\t\tbeginPolygonNum = currentPolygonNum;\n\t}\n\treturn (endRenderCC.Faces().size() == currentPolygonNum) && (endRenderCC.Points().size() == currentVertexNum);\n}\nTEST_CASE(\"CASE1:MeshSubdivideRenderLoop Normal parameter test\", \"[polymeshAPI][SubD][MeshSubdivideRenderLoop][p1]\")\n{\n\tMeshMakeCube makeCube(Frame3(), 10, 10, 10, 10, 10, 10);\n\tPolyMesh* mesh = makeCube.BuildMesh();\n\tstd::string fileNameOBJ = OUTPUT_PATH_PREFIX\"polymeshAPI_MeshSubdivideRenderLoop_case1.obj\";\n\tMeshTool::MeshTriangles(mesh);  \n\tMeshSubdivideRenderLoop subdive;\n\tbool isLoopResult = subdive.DoLoop(mesh, 3);\n\tWriteLoopToOBJ(subdive, fileNameOBJ);\n\tdelete mesh;\n\tCHECK(isLoopResult == true);\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "MeshSubdivideRenderLoop()\t @brief Default constructor\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelperBase.h>\n#include <common/FrameT.hpp>\n#include <polymeshAPI/MeshMakeCube.hpp>\n#include <polymeshAPI/MeshMakeCone.hpp>\n#include <polymeshAPI/MeshMakeCylinder.hpp>\n#include <polymeshAPI/MeshMakeSphere.hpp>\n#include <polymeshAPI/MeshSubdivideHE.hpp>\n#include <polymeshAPI/MeshSubdivideRender.hpp>\n#include <polymeshAPI/MeshTool.hpp>\n#include <polymesh/PolyMeshIO.hpp>\n#include <polymeshAPI/MeshCheck.hpp>\n#include <chrono>\nusing AMCAX::SubD::MeshSubdivideHE;\nusing AMCAX::SubD::MeshTool;\nusing AMCAX::SubD::MeshSubdivideRenderLoop;\nusing AMCAX::SubD::MeshMakeCube;\nusing AMCAX::SubD::MeshMakeCone;  \nusing AMCAX::SubD::MeshMakeCylinder;  \nusing AMCAX::SubD::MeshMakeSphere;  \nusing AMCAX::SubD::PolyMesh;\nusing AMCAX::Frame3;\nusing AMCAX::SubD::PolyMeshIO;\nstatic void WriteLoopToOBJ(const MeshSubdivideRenderLoop& subdive, std::string& fileName)\n{\n\tstd::ofstream file(fileName);\n\tauto mPoints = subdive.Points();\n\tfor (int i = 0; i < static_cast<int>(mPoints.size()); ++i)\n\t{\n\t\tfile << \"v \" << mPoints[i] << std::endl;\n\t}\n\tauto mFaces = subdive.Faces();\n\tfor (int i = 0; i < static_cast<int>(mFaces.size()); ++i)\n\t{\n\t\tconst std::array<int, 3>& face = mFaces[i];\n\t\tfile << \"f \" << face[0] + 1 << \" \" << face[1] + 1 << \" \" << face[2] + 1 << std::endl;\n\t}\n\tfile.close();\n}\nstatic bool CheckSubdivide(const PolyMesh* beginMesh, const MeshSubdivideRenderLoop& endRenderCC, int level = 1)\n{\n\tsize_t beginVertexNum = beginMesh->numVertices();\n\tsize_t beginEdgeNum = beginMesh->numEdges();\n\tsize_t beginPolygonNum = beginMesh->numPolygons();\n\tsize_t currentVertexNum = beginVertexNum, currentEdgeNum = beginEdgeNum, currentPolygonNum = beginPolygonNum;\n\tfor (int i = 0; i < level; ++i)\n\t{\n\t\tcurrentVertexNum = beginVertexNum + beginEdgeNum;\n\t\tcurrentEdgeNum = beginEdgeNum * 2 + 3 * beginPolygonNum;\n\t\tcurrentPolygonNum = 4 * beginPolygonNum;\n\t\tbeginVertexNum = currentVertexNum;\n\t\tbeginEdgeNum = currentEdgeNum;\n\t\tbeginPolygonNum = currentPolygonNum;\n\t}\n\treturn (endRenderCC.Faces().size() == currentPolygonNum) && (endRenderCC.Points().size() == currentVertexNum);\n}\nTEST_CASE(\"CASE5: MeshSubdivideRenderLoop Different subdivision levels\", \"[polymeshAPI][SubD][MeshSubdivideRenderLoop][p1]\")\n{\n\tfor (int level = 1; level <= 5; ++level)\n\t{\n\t\tMeshMakeCube makeCube(Frame3(), 10, 10, 10, 10, 10, 10);\n\t\tPolyMesh* mesh = makeCube.BuildMesh();\n\t\tMeshTool::MeshTriangles(mesh);\n\t\tMeshSubdivideRenderLoop subdive;\n\t\tbool isLoopResult = subdive.DoLoop(mesh, level);\n\t\tstd::string fileNameOBJ = OUTPUT_PATH_PREFIX\"polymeshAPI_MeshSubdivideRenderLoop_level\" + std::to_string(level) + \"_case5.obj\";\n\t\tWriteLoopToOBJ(subdive, fileNameOBJ);\n\t\tCHECK(isLoopResult == true);\n\t\tCHECK(CheckSubdivide(mesh, subdive, level));\n\t\tdelete mesh;\n\t}\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API bool DoCatmullClark(PolyMesh* mesh, size_t subtime)\t @return Thue if the subdivide is successful\n\t @param subtime The number of subdivision\n\t @param mesh The input quadrilateral mesh \n\t @brief Do Catmull-Clark subdivision\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelperBase.h>\n#include <common/FrameT.hpp>\n#include <polymeshAPI/MeshMakeCube.hpp>\n#include <polymeshAPI/MeshMakeCone.hpp>\n#include <polymeshAPI/MeshMakeCylinder.hpp>\n#include <polymeshAPI/MeshMakeSphere.hpp>\n#include <polymeshAPI/MeshSubdivideHE.hpp>\n#include <polymeshAPI/MeshSubdivideRender.hpp>\n#include <polymeshAPI/MeshTool.hpp>\n#include <polymesh/PolyMeshIO.hpp>\n#include <chrono>\nusing AMCAX::SubD::MeshSubdivideHE;\nusing AMCAX::SubD::MeshTool;\nusing AMCAX::SubD::MeshSubdivideRenderCC;\nusing AMCAX::SubD::MeshMakeCube;\nusing AMCAX::SubD::MeshMakeCone;\nusing AMCAX::SubD::MeshMakeCylinder;\nusing AMCAX::SubD::MeshMakeSphere;\nusing AMCAX::SubD::PolyMesh;\nusing AMCAX::Frame3;\nusing AMCAX::SubD::PolyMeshIO;\nstatic void WriteCCToOBJ(const MeshSubdivideRenderCC& subdive, std::string& fileName)\n{\n\tstd::ofstream file(fileName);\n\tauto mPoints = subdive.Points();\n\tfor (int i = 0; i < static_cast<int>(mPoints.size()); ++i)\n\t{\n\t\tfile << \"v \" << mPoints[i] << std::endl;\n\t}\n\tauto mFaces = subdive.Faces();\n\tfor (int i = 0; i < static_cast<int>(mFaces.size()); ++i)\n\t{\n\t\tconst std::array<int, 4>& face = mFaces[i];\n\t\tfile << \"f \" << face[0] + 1 << \" \" << face[1] + 1 << \" \" << face[2] + 1 << \" \" << face[3] + 1 << std::endl;\n\t}\n\tfile.close();\n}\nstatic bool CheckSubdivide(const PolyMesh* beginMesh, const MeshSubdivideRenderCC& endRenderCC, int level = 1)\n{\n\tsize_t beginVertexNum = beginMesh->numVertices();\n\tsize_t beginEdgeNum = beginMesh->numEdges();\n\tsize_t beginPolygonNum = beginMesh->numPolygons();\n\tsize_t currentVertexNum = beginVertexNum, currentEdgeNum = beginEdgeNum, currentPolygonNum = beginPolygonNum;\n\tfor (int i = 0; i < level; ++i)\n\t{\n\t\tcurrentVertexNum = beginVertexNum + beginEdgeNum + beginPolygonNum;\n\t\tcurrentEdgeNum = beginEdgeNum * 2 + 4 * beginPolygonNum;\n\t\tcurrentPolygonNum = 4 * beginPolygonNum;\n\t\tbeginVertexNum = currentVertexNum;\n\t\tbeginEdgeNum = currentEdgeNum;\n\t\tbeginPolygonNum = currentPolygonNum;\n\t}\n\treturn (endRenderCC.Faces().size() == currentPolygonNum) && (endRenderCC.Points().size() == currentVertexNum);\n}\nstatic bool CheckSubdivide(size_t vertexNum, size_t edgeNum, size_t polygonNumconst, PolyMesh* endMesh, int level = 1)\n{\n\tsize_t beginVertexNum = vertexNum;\n\tsize_t beginEdgeNum = edgeNum;\n\tsize_t beginPolygonNum = polygonNumconst;\n\tsize_t currentVertexNum = beginVertexNum, currentEdgeNum = beginEdgeNum, currentPolygonNum = beginPolygonNum;\n\tfor (int i = 0; i < level; ++i)\n\t{\n\t\tcurrentVertexNum = beginVertexNum + beginEdgeNum + beginPolygonNum;\n\t\tcurrentEdgeNum = beginEdgeNum * 2 + 4 * beginPolygonNum;\n\t\tcurrentPolygonNum = 4 * beginPolygonNum;\n\t\tbeginVertexNum = currentVertexNum;\n\t\tbeginEdgeNum = currentEdgeNum;\n\t\tbeginPolygonNum = currentPolygonNum;\n\t}\n\treturn (endMesh->numPolygons() == currentPolygonNum) && (endMesh->numVertices() == currentVertexNum);\n}\n#if 0\n#endif\nTEST_CASE(\"CASE1:MeshSubdivideRenderCC Normal parameter test\", \"[polymeshAPI][SubD][MeshSubdivideRenderCC][p1]\")\n{\n\tMeshMakeCube makeCube(Frame3(), 10, 10, 10, 10, 10, 10);\n\tPolyMesh* mesh = makeCube.BuildMesh();\n\tstd::string fileNameOBJ = OUTPUT_PATH_PREFIX\"polymeshAPI_MeshSubdivideRenderCC_case1.obj\";\n\tMeshSubdivideHE::CatmullClark(mesh, 1);  \n\tMeshSubdivideRenderCC subdive;\n\tbool isCatmullClarkResult = subdive.DoCatmullClark(mesh, 3);\n\tWriteCCToOBJ(subdive, fileNameOBJ);\n\tdelete mesh;\n\tCHECK(isCatmullClarkResult == true);\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API explicit MeshMakeSphere(double r, size_t rseg = 8, size_t vseg = 4)\t @param vseg The number of segments in vertical, must >= 2\n\t @param rseg The number of segments in rotation, must >= 4\n\t @param r The radius\n\t @brief Construct from origin and radius\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelperBase.h>\n#include <polymeshAPI/MeshMakeSphere.hpp>\n#include <polymesh/PolyMeshIO.hpp>\n#include <polymeshAPI/MeshSubdivideHE.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"case1: MeshMakeSphere  \", \"[polymeshAPI][SubD][MeshMakeSphere][P1]\") {\n\tdouble r = 2.1;\n\tAMCAX::SubD::MeshMakeSphere sphere(r);\n\tAMCAX::SubD::PolyMesh* mesh = sphere.BuildMesh();\n\tCHECK(mesh != nullptr);\n\tAMCAX::SubD::MeshSubdivideHE::CatmullClark(mesh, 3);\n\tbool result = AMCAX::SubD::PolyMeshIO::WriteMesh(OUTPUT_PATH_PREFIX\"MeshMakeSphere_case01.obj\", mesh);\n\tCHECK(result == true);\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API MeshMakeCone(Frame3 frame, double r, double h, bool isBottom = true, size_t rseg = 8, size_t vseg = 4),\n",
      "output": "#include<catch.hpp>\n#include<testHelperBase.h>\n#include <polymeshAPI/MeshMakeCone.hpp>\n#include <polymesh/PolyMeshIO.hpp>\n#include <polymeshAPI/MeshSubdivideHE.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"case1:MeshMakeCone  \", \"[polymeshAPI][SubD][MeshMakeCone][P1]\") {\n\tdouble r = 1;\n\tdouble h = 1;\n\tSubD::MeshMakeCone meshmakeCone(r, h);\n\tAMCAX::SubD::PolyMesh* mesh = meshmakeCone.BuildMesh();\n\tCHECK(mesh != nullptr);\n\tAMCAX::SubD::MeshSubdivideHE::CatmullClark(mesh, 3);\n\tbool result = AMCAX::SubD::PolyMeshIO::WriteMesh(OUTPUT_PATH_PREFIX\"MeshMakeCone_case01.obj\", mesh);\n\tCHECK(result == true);\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API MeshMakeCone(double r, double h, bool isBottom = true, size_t rseg = 8, size_t vseg = 4),\n",
      "output": "#include<catch.hpp>\n#include<testHelperBase.h>\n#include <polymeshAPI/MeshMakeCone.hpp>\n#include <polymesh/PolyMeshIO.hpp>\n#include <polymeshAPI/MeshSubdivideHE.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"case1:MeshMakeCone  \", \"[polymeshAPI][SubD][MeshMakeCone][P1]\") {\n\tdouble r = 1;\n\tdouble h = 1;\n\tSubD::MeshMakeCone meshmakeCone(r, h);\n\tAMCAX::SubD::PolyMesh* mesh = meshmakeCone.BuildMesh();\n\tCHECK(mesh != nullptr);\n\tAMCAX::SubD::MeshSubdivideHE::CatmullClark(mesh, 3);\n\tbool result = AMCAX::SubD::PolyMeshIO::WriteMesh(OUTPUT_PATH_PREFIX\"MeshMakeCone_case01.obj\", mesh);\n\tCHECK(result == true);\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API explicit MakePipeShell(const TopoWire& spine)\t @param spine The spine wire\n\t @brief Construct from a spine wire. The default sweep method is corrected frenet.\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <modeling/MakeShape.hpp>\n#include <io/ShapeTool.hpp>\n#include <topology/TopoWire.hpp>\n#include <offset/MakePipeShell.hpp>\n#include <topomesh/BRepMeshIncrementalMesh.hpp>\n#include <io/OBJTool.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"bug1: MakePipeShell \", \"[offset][MakePipeShell][fixbug]\") \n{\n\tOUTPUT_DIRECTORY(offset, MakePipeShell);\n\tTopoShape shape1;\n\tShapeTool s1;\n\tbool result1 = s1.Read(shape1, INPUT_PATH_PREFIX\"./offset/spine(1).shape\", 0);\n\tCHECK(result1 == true);\n\tTopoWire spine = TopoCast::Wire(shape1);\n\tTopoShape shape2;\n\tShapeTool s2;\n\tbool result2 = s2.Read(shape2, INPUT_PATH_PREFIX\"./offset/profile(1).shape\",0);\n\tCHECK(result2 == true);\n\tTopoWire profile = TopoCast::Wire(shape2);\n\tMakePipeShell makePipe = MakePipeShell(spine);\n\tmakePipe.Add(profile);\n\tmakePipe.SetForceApproxC1(true);\n\tmakePipe.Build();\n\tTopoShape pipe = makePipe.Shape();\n\tOCCTIO::OCCTTool b;\n\tbool result3 = b.Write(pipe, outdir + \"pipeRes_OCC_true.brep\");\n\tCHECK(result3 == true);\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API void PerformBySimple(const TopoShape& s, double offsetValue)\t @param offsetValue The value of offset\n\t @param s The input face or shell\n\t @details The input must be a non-closed single face or a shell which only contain tangent faces.\n\t @brief Construct an offset shape using the simple algorithm without intersections computation\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <offset/MakeOffsetShape.hpp>\n#include <io/ShapeTool.hpp>\n#include <topomesh/BRepMeshIncrementalMesh.hpp>\n#include <io/OBJTool.hpp>\n#include <geometry/Geom3Curve.hpp>\n#include <topology/TopoTool.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"bug1: MakeOffset::PerformBySimple \", \"[offset][MakeOffsetShape][P1]\") {\n\tTopoShape shape;\n\tShapeTool::Read(shape, INPUT_PATH_PREFIX\"shell.txt\");\n\tbool bOCCToolWrite = OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX\"testResultTemp.brep\");\n\tCHECK(bOCCToolWrite == true);\n\tBRepMeshIncrementalMesh meshI(shape, 0.001, true);\n\tbool bWriteShape = OBJTool::WriteShape(shape, OUTPUT_PATH_PREFIX\"testResultTemp.obj\");\n\tCHECK(bWriteShape);\n\tMakeOffsetShape offsetMaker;\n\toffsetMaker.PerformBySimple(shape, 4.0);\n\tif (!offsetMaker.IsDone())\n\t{\n\t\tCHECK(offsetMaker.IsDone() == true);\n\t\tstd::cout << \"make Offset sample error\" << std::endl;\n\t}\n\telse\n\t{\n\t\tstd::cout << \"make Offset sample ok \" << std::endl;\n\t\tTopoShape result = offsetMaker.Shape();\n\t\tOCCTIO::OCCTTool::Write(result, OUTPUT_PATH_PREFIX\"testResult.brep\");\n\t\tBRepMeshIncrementalMesh meshR(result, 0.00001, true);\n\t\tOBJTool::WriteShape(result, OUTPUT_PATH_PREFIX\"testResult.obj\");\n\t\tint CheckContinuity = 0;\n\t\tint notCheckContinuity = 0;\n\t\tdouble cf, cl;\n\t\tfor (TopoExplorer ex(result, ShapeType::Edge); ex.More(); ex.Next())\n\t\t{\n\t\t\tauto &edge = TopoCast::Edge(ex.Current());\n\t\t\tstd::shared_ptr<Geom3Curve> c3d = TopoTool::Curve(edge, cf, cl);\n\t\t\tif (int(c3d->Continuity()) > 0) {\n\t\t\t\tCheckContinuity = CheckContinuity + 1;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tnotCheckContinuity = notCheckContinuity + 1;\n\t\t\t}\n\t\t}\n\t\tCHECK(CheckContinuity == 15);\n\t\tCHECK(notCheckContinuity == 1);\n\t}\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API void PerformWithEdgeAndLength(const TopoEdge& edge, double length)\t @param length The extend Length, > 0 means extending face outward\n\t @param edge The boundary edge belonging to the face\n\t @brief Extend the face using one edge by length\n,\n",
      "output": "﻿#include<catch.hpp>\n#include<testHelper.h>\n#include <topology/TopoExplorerTool.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeWire.hpp>\n#include <modeling/MakeFace.hpp>\n#include <offset/MakeFaceExtension.hpp>\n#include <topomesh/BRepMeshIncrementalMesh.hpp>\n#include <io/OBJTool.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <topology/TopoTool.hpp>\n#include <topology/TopoVertex.hpp>\nusing namespace AMCAX;\n﻿#include<catch.hpp>\n#include<testHelper.h>\n#include <topology/TopoExplorerTool.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeWire.hpp>\n#include <modeling/MakeFace.hpp>\n#include <offset/MakeFaceExtension.hpp>\n#include <topomesh/BRepMeshIncrementalMesh.hpp>\n#include <io/OBJTool.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <topology/TopoTool.hpp>\n#include <topology/TopoVertex.hpp>\nusing namespace AMCAX;\n;\n\tSECTION(\"check length = 0 isDone should always false\") {\n\t\tfor (size_t i = 0; i < fedge.size(); i++)\n\t\t{\n\t\t\tTopoEdge edge = static_cast<const TopoEdge&>(fedge[i]);\n\t\t\tmkExt.PerformWithEdgeAndLength(edge, 0.0);\n\t\t\tCHECK(mkExt.IsDone() == false);\n\t\t\t}\n\t\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static TopoShape Untrim(const TopoEdge& edge, const TopoFace& face)\t @return New face\n\t @param face Face to Untrim\n\t @param edge Edge to untrim\n\t\t\t5. replace the old wire with the new wire\n\t\t\t4. make new wire and judge orientation by the same edge of the two wires\n\n\t\t\t3. build new edges\n\n\t\t\t2. decide which part of the edges is remained\n\n\t\t\t1. judge whether the edges of the wire is on oriBound;\n\n\t The algorithm of making the untrim face in usual cases is:\n\n\t \n\n\t\t\tSince the untrim edge is on inner wire, just remove the inner wire.\n\n\t else \n\n\t\t\tPerform as the one wire case and add the other wires to the result.\n\n\t else if the untrim edge is on outer wire\n\n\t\t\t\tMake the untrim face by the algorithm illustrated below. (usual cases)\n\n\t\t\telse\n\n\t\t\t\tMake two untrim faces and judge which is required by select a point on untrim edge.\n\n\t\t\telse if the number of oriBound edges is 0:\n\n\t\t\t\treturn the face built by the whole surface.\n\n\t\t\telse if the number of non-oriBound edges is 0:\n\n\t\t\t\treturn the face built by the whole surface.\n\n\t\t\tif num of intersection points is less than 2 or the untrimm edge is the only edge of the wire: \n\n\t If face has one wire:\n\n\t\t\t3. the number of oriBound edges and non-oriBound edges.\n\n\t\t\t2. the number of intersection points with boundaries of wire containing untrim edge;\n\n\t\t\t1. number of wires;\n\n\t The cases are sort of complicated. It can be classified by:\n\n\t @brief Restore the trimmed face (by n edges) to its untrimmed state (trimmed by n-1 edges)\n\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <nurbs/NURBSAPIUntrim.hpp>\n#include <geometry/Geom3BSplineCurve.hpp>\n#include <topology/TopoFace.hpp>\n#include <topology/TopoEdge.hpp>\n#include <modeling/MakeWire.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakePrism.hpp>\n#include <geometry/Geom3Plane.hpp>\n#include <offset/MakePipeShell.hpp>\n#include <modeling/MakeFace.hpp>\n#include <boolean/BoolBRepCut.hpp>\n#include <io/STLTool.hpp>\n#include <topology/TopoTool.hpp>\n#include <geometry/GeomAPIProjectPointOnCurve3.hpp>\n#include <geometry/Geom3TrimmedSurface.hpp>\n#include <common/CartesianCoordinateSystem.hpp>\n#include <geometry/Geom3BSplineSurface.hpp>\n#include <topology/TopoVertex.hpp>\n#include <geometry/GeomAPIProjectPointOnSurface.hpp>\n#include <topology/BRepAdaptorCurve3.hpp>\n#include <nurbs/NURBSAPIReplaceEdge.hpp>\n#include <nurbs/NURBSAPITrim.hpp>\n#include <topology/TopoExplorerTool.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <topology/BRepExtremaDistShapeShape.hpp>\nusing namespace std;\nbool MakeDir(const std::string& dir)\n{\n\tif (!std::filesystem::exists(dir))\n\t{\n\t\tstd::filesystem::create_directories(dir.c_str());\n\t\treturn true;\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\nTEST_CASE(\"bug1: TestUntrim2CornerCase \", \"[nurbs][Untrim][fixbug]\")\n{\n\tOUTPUT_DIRECTORY(nurbs, Untrim/bug552);\n\tshared_ptr<Geom3Plane> gp = make_shared<Geom3Plane>(CartesianCoordinateSystem::XOY());\n\tshared_ptr<Geom3TrimmedSurface> tgp = make_shared<Geom3TrimmedSurface>(gp, -1.0, 1.0, -1.0, 1.0);\n\tTopoFace inputBasicFace = MakeFace(tgp, 1e-8).Face();\n\tTopoShape cutCylidner1 = MakePrism(MakeEdge(Circle3(Frame3(Point3(-1.0, -1.0, -1.0), Direction3(0.0, 0.0, 1.0), Direction3(1.0, 0.0, 0.0)), 2.0)), Vector3(0.0, 0.0, 2.0));\n\tTopoShape cutCylidner2 = MakePrism(MakeEdge(Circle3(Frame3(Point3(1.0, 1.0, -1.0), Direction3(0.0, 0.0, 1.0), Direction3(1.0, 0.0, 0.0)), 2.0)), Vector3(0.0, 0.0, 2.0));\n\tTopoShape cutCylidner3 = MakePrism(MakeEdge(Circle3(Frame3(Point3(-0.2, -0.2, -1.0), Direction3(0.0, 0.0, 1.0), Direction3(1.0, 0.0, 0.0)), 0.1)), Vector3(0.0, 0.0, 2.0));\n\tTopoShape cc = CutAndLeaveLargePart(inputBasicFace, cutCylidner1);\n\tTopoShape ccc = CutAndLeaveLargePart(cc, cutCylidner2);\n\tTopoShape cccc = CutAndLeaveLargePart(ccc, cutCylidner3);\n\tTopoFace inputFace = static_cast<const TopoFace&>(cccc);\n\tPoint3 refp3(-0.2, -0.2, 0.0);\n\tTopoEdge theEdge;\n\tdouble dist = 1e100;\n\tfor (TopoExplorer exe(inputFace, ShapeType::Edge); exe.More(); exe.Next())\n\t{\n\t\tTopoEdge cr = static_cast<const TopoEdge&>(exe.Current());\n\t\tBRepExtremaDistShapeShape shape(MakeVertex(refp3), cr);\n\t\tdouble crdist = shape.Value();\n\t    if (dist > crdist)\n\t\t\t{\n\t\t\t\tdist = crdist;\n\t\t\t\ttheEdge = cr;\n\t\t\t}\n\t\t}\n\tTopoShape result3 = NURBSAPIUntrim::Untrim(theEdge, static_cast<const TopoFace&>(inputFace));\n\tTopoShape f3 = CutAndLeaveLargePart(inputBasicFace, cutCylidner1);\n\tTopoShape cccc1 = CutAndLeaveLargePart(f3, cutCylidner2);\n\tGlobalProperty props1, props2, props3, props4, props5, props6, props7;\n\tdouble res3 = GetSurfaceProperties(result3, props3, true, false);\n\tdouble res33 = GetSurfaceProperties(cccc1, props7, true, false);\n\tCHECK(GetTopoCount(result3, ShapeType::Edge) == 2);\n\tCHECK(res3 == Approx(res33));\n\tOCCTIO::OCCTTool::Write(MakeVertex(refp3), outdir + \"refp3.brep\");\n\tOCCTIO::OCCTTool::Write(theEdge, outdir + \"theEdge.brep\");\n\tOCCTIO::OCCTTool::Write(inputFace, outdir + \"trimFace.brep\");\n\tOCCTIO::OCCTTool::Write(result3, outdir + \"untrimResult.brep\");\n\tOCCTIO::OCCTTool::Write(cccc1, outdir + \"src.brep\");\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static TopoShape Trim(const std::list<TopoShape>& cutter, const TopoShape& srcShape, const std::vector<double>& param, bool isViewPortIntersection, const Coord3& eyeOrDir)\t @return The trimmed shape\n\t @param eyeOrDir if isViewPortIntersection, it is the position of the camera (or eye), else it is the direction of parallel projection\n\t @param isViewPortIntersection Point projection or parallel projection\n\t If the srcShape is a TopoEdge, param.size = 1.  If the srcShape is a TopoFace, param.size = 2\n\t @param param The parameter to determin which part of the srcShape is deleted.\n\t @param srcShape The source shape which can be a TopoEdge or a TopoFace\n\t @param cutter The cutters consist of TopoEdges and TopoFaces\n\t @brief Trim a shape with cutters\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <nurbs/NURBSAPITrim.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <topology/TopoTool.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include <topology/BRepAdaptorCurve3.hpp>\n#include <geometry/GeomAPIProjectPointOnSurface.hpp>\n#include <nurbs/NURBSAPIUntrim.hpp>\n#include <topology/TopoExplorerTool.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <topology/BRepAdaptorCurve3.hpp>\n#include <topology/BRepExtremaDistShapeShape.hpp>\npair<Point3,Point3> NurbsReadAdaptorCurve(const TopoShape& shape)\n{\n\tpair<Point3, Point3> res;\n\tTopoExplorer ex(shape, ShapeType::Edge);\n\tTopoEdge e = static_cast<const TopoEdge&>(ex.Value());\n\tBRepAdaptorCurve3 brep(e);\n\tconst AdaptorGeom3Curve curve = brep.Curve();\n\tdouble u1 = curve.FirstParameter();\n\tdouble u2 = curve.LastParameter();\n\tres.first = curve.Value(u1);\n\tres.second = curve.Value(u2);\n\treturn res;\n}\nshared_ptr< Geom3Curve > NurbsReadTempCurve(const TopoShape& shape)\n{\n\tpair<Point3, Point3> res;\n\tTopoExplorer ex(shape, ShapeType::Edge);\n\tTopoEdge e = static_cast<const TopoEdge&>(ex.Value());\n\tdouble f = 0.0;\n\tdouble l = 0.0;\n\tshared_ptr< Geom3Curve > curve = TopoTool::Curve(e, f, l);\n\treturn curve;\n}\ndouble NurbsSampleAdaptorCurve(int num, double tol, const TopoShape& shape1, const TopoShape& shape2)\n{\n\tconst int nsample = num;\n\tTopoExplorer ex1(shape1, ShapeType::Edge);\n\tTopoEdge e1 = static_cast<const TopoEdge&>(ex1.Value());\n\tBRepAdaptorCurve3 brep1(e1);\n\tconst AdaptorGeom3Curve curve1 = brep1.Curve();\n\tTopoExplorer ex2(shape2, ShapeType::Edge);\n\tTopoEdge e2 = static_cast<const TopoEdge&>(ex2.Value());\n\tdouble fp1 = curve1.FirstParameter();\n\tdouble lp1 = curve1.LastParameter();\n\tdouble delta1 = abs((lp1 - fp1) / nsample);\n\tPoint3 p;\n\tint n = 0;\n\tfor (int i = 0; i < nsample; i++)\n\t{\n\t\tdouble t1 = fp1 + i * delta1;\n\t\tcurve1.D0(t1, p);\n\t\tBRepExtremaDistShapeShape shape(MakeVertex(p), e2);\n\t\tdouble dist = shape.Value();\n\t\tif (dist <= tol)\n\t\t{\n\t\t\tn++;\n\t\t}\n\t}\n\tdouble res = 1.0 * (num - n) / num;\n\treturn res;\n}\n#include<catch.hpp>\n#include<testHelper.h>\n#include <nurbs/NURBSAPITrim.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <topology/TopoTool.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include <topology/BRepAdaptorCurve3.hpp>\n#include <geometry/GeomAPIProjectPointOnSurface.hpp>\n#include <nurbs/NURBSAPIUntrim.hpp>\n#include <topology/TopoExplorerTool.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <topology/BRepAdaptorCurve3.hpp>\n#include <topology/BRepExtremaDistShapeShape.hpp>\npair<Point3,Point3> NurbsReadAdaptorCurve(const TopoShape& shape)\n{\n\tpair<Point3, Point3> res;\n\tTopoExplorer ex(shape, ShapeType::Edge);\n\tTopoEdge e = static_cast<const TopoEdge&>(ex.Value());\n\tBRepAdaptorCurve3 brep(e);\n\tconst AdaptorGeom3Curve curve = brep.Curve();\n\tdouble u1 = curve.FirstParameter();\n\tdouble u2 = curve.LastParameter();\n\tres.first = curve.Value(u1);\n\tres.second = curve.Value(u2);\n\treturn res;\n}\nshared_ptr< Geom3Curve > NurbsReadTempCurve(const TopoShape& shape)\n{\n\tpair<Point3, Point3> res;\n\tTopoExplorer ex(shape, ShapeType::Edge);\n\tTopoEdge e = static_cast<const TopoEdge&>(ex.Value());\n\tdouble f = 0.0;\n\tdouble l = 0.0;\n\tshared_ptr< Geom3Curve > curve = TopoTool::Curve(e, f, l);\n\treturn curve;\n}\ndouble NurbsSampleAdaptorCurve(int num, double tol, const TopoShape& shape1, const TopoShape& shape2)\n{\n\tconst int nsample = num;\n\tTopoExplorer ex1(shape1, ShapeType::Edge);\n\tTopoEdge e1 = static_cast<const TopoEdge&>(ex1.Value());\n\tBRepAdaptorCurve3 brep1(e1);\n\tconst AdaptorGeom3Curve curve1 = brep1.Curve();\n\tTopoExplorer ex2(shape2, ShapeType::Edge);\n\tTopoEdge e2 = static_cast<const TopoEdge&>(ex2.Value());\n\tdouble fp1 = curve1.FirstParameter();\n\tdouble lp1 = curve1.LastParameter();\n\tdouble delta1 = abs((lp1 - fp1) / nsample);\n\tPoint3 p;\n\tint n = 0;\n\tfor (int i = 0; i < nsample; i++)\n\t{\n\t\tdouble t1 = fp1 + i * delta1;\n\t\tcurve1.D0(t1, p);\n\t\tBRepExtremaDistShapeShape shape(MakeVertex(p), e2);\n\t\tdouble dist = shape.Value();\n\t\tif (dist <= tol)\n\t\t{\n\t\t\tn++;\n\t\t}\n\t}\n\tdouble res = 1.0 * (num - n) / num;\n\treturn res;\n;\n\tSECTION(\"TestTrim\")\n\t{\n\t\tOUTPUT_DIRECTORY(nurbs, Trim/TrimCurve);\n\t\tstd::string filedir = INPUT_PATH_PREFIX\"./TestNURBS/TestTrim/\";\n\t\tTopoShape cutterEdge = ReadBRepEdge(filedir + \"cutterEdge.brep\");\n\t\tTopoShape srcEdge = ReadBRepEdge(filedir + \"srcEdge.brep\");\n\t\tTopoShape cutterFace = ReadBRepFace(filedir + \"cutterFace.brep\");\n\t\tTopoShape srcFace = ReadBRepFace(filedir + \"srcFace.brep\");\n\t\tbool isCutterEdge = true;\n\t\tbool isSrcEdge = false;\n\t\tbool isEye = true;\n\t\tTopoShape srcShape = isSrcEdge ? srcEdge : srcFace;\n\t\tstd::list<TopoShape> cutterShape;\n\t\tif (isCutterEdge)\n\t\t{\n\t\t\tcutterShape.push_back(cutterEdge);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcutterShape.push_back(cutterFace);\n\t\t}\n\t\tCoord3 eyeOrDir(1.0, -1.0, 0.0);\n\t\tstd::vector<double> param;\n\t\tparam.push_back(0.1);\n\t\tparam.push_back(0.1);\n\t\tauto result = NURBSAPITrim::Trim(cutterShape, srcShape, param, isEye, eyeOrDir);\n\t\tTopoShape temp = ReadBRepFace(filedir + \"resultEdgeFaceEye.brep\");\n\t\tGlobalProperty props1, props2;\n\t\tdouble s1 = GetSurfaceProperties(result, props1, false, true);\n\t\tdouble s2 = GetSurfaceProperties(temp, props2, false, true);\n\t\tCHECK(s1 == Approx(s2).margin(1e-7));\n\t\tint num1 = GetTopoCount(result, ShapeType::Edge);\n\t\tint num2 = GetTopoCount(srcShape, ShapeType::Edge);\n\t\tCHECK(num1 == 5);\n\t\tCHECK(num2 == 4);\n\t\tIndexSet<TopoShape> solidEdges1, solidEdges2;\n\t\tTopoExplorerTool::MapShapes(result, ShapeType::Edge, solidEdges1);\n\t\tTopoExplorerTool::MapShapes(temp, ShapeType::Edge, solidEdges2);\n\t\tpair<Point3, Point3> pa1 = NurbsReadCurve(solidEdges1[0]);\n\t\tpair<Point3, Point3> pa2 = NurbsReadCurve(solidEdges2[0]);\n\t\tPoint3 sp1 = pa1.first;\n\t\tPoint3 sp2 = pa2.first;\n\t\tPoint3 ep1 = pa1.second;\n\t\tPoint3 ep2 = pa2.second;\n\t\tCHECK(sp1.IsEqual(sp2, 1e-7) == true);\n\t\tCHECK(ep1.IsEqual(ep2, 1e-7) == true);\n\t\tshared_ptr< Geom3Curve > cur1 = NurbsReadTempCurve(solidEdges1[0]);\n\t\tshared_ptr< Geom3Curve > cur2 = NurbsReadTempCurve(solidEdges2[0]);\n\t\tdouble res = NurbsSampleCurve(num, tol, cur1, cur2);\n\t\tCHECK(res <= ratio);\n\t\tOCCTIO::OCCTTool::Write(srcShape, outdir + \"src.brep\");\n\t\tOCCTIO::OCCTTool::Write(cutterEdge, outdir + \"cutterEdge.brep\");\n\t\tOCCTIO::OCCTTool::Write(solidEdges1[0], outdir + \"solidEdges1[0].brep\");\n\t\tOCCTIO::OCCTTool::Write(solidEdges2[0], outdir + \"solidEdges2[0].brep\");\n\t\tOCCTIO::OCCTTool::Write(MakeEdge(cur1), outdir + \"cur1.brep\");\n\t\tOCCTIO::OCCTTool::Write(MakeEdge(cur2), outdir + \"cur2.brep\");\n\t\tOCCTIO::OCCTTool::Write(result, outdir + \"result.brep\");\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static std::shared_ptr<Geom3BSplineSurface> RotationSweep( const std::shared_ptr<Geom3BSplineCurve>& profile, const std::shared_ptr<Geom3BSplineCurve>& spine, const Axis3& axis),\n",
      "output": "\n#include<catch.hpp>\n#include<testHelper.h>\n#include <filesystem>\n#include <fstream>\n#include <random>\n#include <sstream>\n#include <nurbs/NURBSAPIGetGeometry.hpp>\n#include <nurbs/NURBSAPIConicalSweep.hpp>\n#include <boolean/BoolBRepCut.hpp>\n#include <common/CartesianCoordinateSystem.hpp>\n#include <common/IndexMap.hpp>\n#include <common/QuaternionT.hpp>\n#include <geomAlgo/LawBSpline.hpp>\n#include <geomAlgo/LawConstant.hpp>\n#include <nurbs/NURBSAPISmooth.hpp>\n#include <geomAlgo/MakeConic2FromConstraints.hpp>\n#include <geometry/Adaptor3CurveOnSurface.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/AdaptorGeom3Surface.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2Circle.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/Geom2Hyperbola.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3BSplineCurve.hpp>\n#include <geometry/Geom3BSplineSurface.hpp>\n#include <geometry/Geom3Circle.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\n#include <geometry/Geom3Plane.hpp>\n#include <geometry/Geom3SphericalSurface.hpp>\n#include <geometry/Geom3Surface.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include <geometry/Geom3TrimmedSurface.hpp>\n#include <geometry/GeomAPIExtremaCurveCurve3.hpp>\n#include <geometry/GeomAPIProjectPointOnCurve2.hpp>\n#include <geometry/GeomAPIProjectPointOnCurve3.hpp>\n#include <geometry/GeomAPIProjectPointOnSurface.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/GlobalProperty.hpp>\n#include <healing/ShapeFixTool.hpp>\n#include <io/STLTool.hpp>\n#include <math/Sphere.hpp>\n#include <math/TriangularMesh.hpp>\n#include <modeling/CopyShape.hpp>\n#include <modeling/MakeBox.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeFace.hpp>\n#include <modeling/MakePrism.hpp>\n#include <modeling/MakeRevol.hpp>\n#include <modeling/MakeShapeTool.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <modeling/MakeWire.hpp>\n#include <modeling/TransformShape.hpp>\n#include <nurbs/NURBSAPIApprox.hpp>\n#include <nurbs/NURBSAPIBuildCurve.hpp>\n#include <nurbs/NURBSAPICircularSweep.hpp>\n#include <nurbs/NURBSAPIConvert.hpp>\n#include <nurbs/NURBSAPICurveNetworkSurface.hpp>\n#include <nurbs/NURBSAPIExplicitSweep.hpp>\n#include <nurbs/NURBSAPIExplode.hpp>\n#include <nurbs/NURBSAPIExtend.hpp>\n#include <nurbs/NURBSAPIInterpolate.hpp>\n#include <nurbs/NURBSAPIJoin.hpp>\n#include <nurbs/NURBSAPILinearSweep.hpp>\n#include <nurbs/NURBSAPILoft.hpp>\n#include <nurbs/NURBSAPIMakeNURBSFromBoundaries.hpp>\n#include <nurbs/NURBSAPIMatch.hpp>\n#include <nurbs/NURBSAPIModifyEndToPlane.hpp>\n#include <nurbs/NURBSAPIOffsetCurveOnSurface.hpp>\n#include <nurbs/NURBSAPIProject.hpp>\n#include <nurbs/NURBSAPIRebuild.hpp>\n#include <nurbs/NURBSAPIReplaceEdge.hpp>\n#include <nurbs/NURBSAPISweep.hpp>\n#include <nurbs/NURBSAPISweep2.hpp>\n#include <nurbs/NURBSAPISweepRotation.hpp>\n#include <nurbs/NURBSAPITrim.hpp>\n#include <nurbs/NURBSAPIUntrim.hpp>\n#include <nurbs/NURBSLinearSweepWithDraftDirectionLength.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <offset/MakePipe.hpp>\n#include <offset/MakePipeShell.hpp>\n#include <topology/BRepAdaptorCurve2.hpp>\n#include <topology/BRepAdaptorCurve3.hpp>\n#include <topology/BRepAdaptorSurface.hpp>\n#include <topology/BRepGlobalProperty.hpp>\n#include <topology/BRepTool.hpp>\n#include <topology/TopoBuilder.hpp>\n#include <topology/TopoCompound.hpp>\n#include <topology/TopoEdge.hpp>\n#include <topology/TopoExplorer.hpp>\n#include <topology/TopoExplorerTool.hpp>\n#include <topology/TopoFace.hpp>\n#include <topology/TopoShape.hpp>\n#include <topology/TopoShell.hpp>\n#include <topology/TopoTool.hpp>\n#include <topology/TopoVertex.hpp>\n#include <topology/TopoWire.hpp>\n#include <topology/WireExplorer.hpp>\n#include <topomesh/BRepMeshIncrementalMesh.hpp>\n#include <nurbs/NURBSAPIBlend.hpp>\n#include <topology/BRepExtremaDistShapeShape.hpp>\n#include <math/LineT.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/GeomAPIIntSurfaceSurface.hpp>\nusing namespace AMCAX;\n#include<catch.hpp>\n#include<testHelper.h>\n#include <filesystem>\n#include <fstream>\n#include <random>\n#include <sstream>\n#include <nurbs/NURBSAPIGetGeometry.hpp>\n#include <nurbs/NURBSAPIConicalSweep.hpp>\n#include <boolean/BoolBRepCut.hpp>\n#include <common/CartesianCoordinateSystem.hpp>\n#include <common/IndexMap.hpp>\n#include <common/QuaternionT.hpp>\n#include <geomAlgo/LawBSpline.hpp>\n#include <geomAlgo/LawConstant.hpp>\n#include <nurbs/NURBSAPISmooth.hpp>\n#include <geomAlgo/MakeConic2FromConstraints.hpp>\n#include <geometry/Adaptor3CurveOnSurface.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/AdaptorGeom3Surface.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2Circle.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/Geom2Hyperbola.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3BSplineCurve.hpp>\n#include <geometry/Geom3BSplineSurface.hpp>\n#include <geometry/Geom3Circle.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\n#include <geometry/Geom3Plane.hpp>\n#include <geometry/Geom3SphericalSurface.hpp>\n#include <geometry/Geom3Surface.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include <geometry/Geom3TrimmedSurface.hpp>\n#include <geometry/GeomAPIExtremaCurveCurve3.hpp>\n#include <geometry/GeomAPIProjectPointOnCurve2.hpp>\n#include <geometry/GeomAPIProjectPointOnCurve3.hpp>\n#include <geometry/GeomAPIProjectPointOnSurface.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/GlobalProperty.hpp>\n#include <healing/ShapeFixTool.hpp>\n#include <io/STLTool.hpp>\n#include <math/Sphere.hpp>\n#include <math/TriangularMesh.hpp>\n#include <modeling/CopyShape.hpp>\n#include <modeling/MakeBox.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeFace.hpp>\n#include <modeling/MakePrism.hpp>\n#include <modeling/MakeRevol.hpp>\n#include <modeling/MakeShapeTool.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <modeling/MakeWire.hpp>\n#include <modeling/TransformShape.hpp>\n#include <nurbs/NURBSAPIApprox.hpp>\n#include <nurbs/NURBSAPIBuildCurve.hpp>\n#include <nurbs/NURBSAPICircularSweep.hpp>\n#include <nurbs/NURBSAPIConvert.hpp>\n#include <nurbs/NURBSAPICurveNetworkSurface.hpp>\n#include <nurbs/NURBSAPIExplicitSweep.hpp>\n#include <nurbs/NURBSAPIExplode.hpp>\n#include <nurbs/NURBSAPIExtend.hpp>\n#include <nurbs/NURBSAPIInterpolate.hpp>\n#include <nurbs/NURBSAPIJoin.hpp>\n#include <nurbs/NURBSAPILinearSweep.hpp>\n#include <nurbs/NURBSAPILoft.hpp>\n#include <nurbs/NURBSAPIMakeNURBSFromBoundaries.hpp>\n#include <nurbs/NURBSAPIMatch.hpp>\n#include <nurbs/NURBSAPIModifyEndToPlane.hpp>\n#include <nurbs/NURBSAPIOffsetCurveOnSurface.hpp>\n#include <nurbs/NURBSAPIProject.hpp>\n#include <nurbs/NURBSAPIRebuild.hpp>\n#include <nurbs/NURBSAPIReplaceEdge.hpp>\n#include <nurbs/NURBSAPISweep.hpp>\n#include <nurbs/NURBSAPISweep2.hpp>\n#include <nurbs/NURBSAPISweepRotation.hpp>\n#include <nurbs/NURBSAPITrim.hpp>\n#include <nurbs/NURBSAPIUntrim.hpp>\n#include <nurbs/NURBSLinearSweepWithDraftDirectionLength.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <offset/MakePipe.hpp>\n#include <offset/MakePipeShell.hpp>\n#include <topology/BRepAdaptorCurve2.hpp>\n#include <topology/BRepAdaptorCurve3.hpp>\n#include <topology/BRepAdaptorSurface.hpp>\n#include <topology/BRepGlobalProperty.hpp>\n#include <topology/BRepTool.hpp>\n#include <topology/TopoBuilder.hpp>\n#include <topology/TopoCompound.hpp>\n#include <topology/TopoEdge.hpp>\n#include <topology/TopoExplorer.hpp>\n#include <topology/TopoExplorerTool.hpp>\n#include <topology/TopoFace.hpp>\n#include <topology/TopoShape.hpp>\n#include <topology/TopoShell.hpp>\n#include <topology/TopoTool.hpp>\n#include <topology/TopoVertex.hpp>\n#include <topology/TopoWire.hpp>\n#include <topology/WireExplorer.hpp>\n#include <topomesh/BRepMeshIncrementalMesh.hpp>\n#include <nurbs/NURBSAPIBlend.hpp>\n#include <topology/BRepExtremaDistShapeShape.hpp>\n#include <math/LineT.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/GeomAPIIntSurfaceSurface.hpp>\nusing namespace AMCAX;;\n\tSECTION(\"TestRotationSweepMore2()\")\n\t{\n\t\tstd::string filedir = INPUT_PATH_PREFIX \"/TestNURBS/TestRotationSweepMore2/\";\n\t\tstd::shared_ptr<Geom3BSplineCurve> spine = ReadBRepCurve(filedir + \"spine.brep\");\n\t\tstd::shared_ptr<Geom3BSplineCurve> profile = ReadBRepCurve(filedir + \"profile.brep\");\n\t\tCHECK(OCCTIO::OCCTTool::Write(MakeEdge(spine), OUTPUT_PATH_PREFIX \"TestRotationSweepMore_spine2.brep\"));\n\t\tCHECK(OCCTIO::OCCTTool::Write(MakeEdge(profile), OUTPUT_PATH_PREFIX \"TestRotationSweepMore_profile2.brep\"));\n\t\tPoint3 p(0.0, 0.0, 0.0);\n\t\tVector3 vec(0.0, 0.0, 5.0);\n\t\tAxis3 axis(p, Direction3(vec));\n\t\tauto surface1 = NURBSAPISweepRotation::RotationSweep( profile, spine, axis);\n\t\tCHECK(OCCTIO::OCCTTool::Write(MakeFace(surface1, 0.0), OUTPUT_PATH_PREFIX \"TestRotationSweepMore_result2.brep\"));\n\t\tCHECK(IsCurveOnSurf(100, 0.1, profile, surface1, 0.01));\n\t\tprofile->IncreaseDegree(11);\n\t\tCHECK(OCCTIO::OCCTTool::Write(MakeEdge(profile), OUTPUT_PATH_PREFIX \"TestRotationSweepMore_degree11profile.brep\"));\n\t\tauto surface11 = NURBSAPISweepRotation::RotationSweep( profile, spine, axis);\n\t\tCHECK(OCCTIO::OCCTTool::Write(MakeFace(surface11, 0.0), OUTPUT_PATH_PREFIX \"TestRotationSweepMore_degree11result2.brep\"));\n\t\tdouble bsp3s = GetSurfaceProperties(MakeFace(surface1, 0.0), g, true, true);\n\t\tdouble bsp4s = GetSurfaceProperties(MakeFace(surface11, 0.0), g, true, true);\n\t\tCHECK(bsp3s == Approx(bsp4s).margin(0.02));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static std::shared_ptr<Geom3BSplineSurface> RotationSweep( const std::shared_ptr<Geom3BSplineCurve>& profile, const std::shared_ptr<Geom3BSplineCurve>& spine, const Axis3& axis),\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeFace.hpp>\n#include <nurbs/NURBSAPIConvert.hpp>\n#include <topology/TopoTool.hpp>\n#include <nurbs/NURBSAPIExplicitSweep.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <nurbs/NURBSAPISweepRotation.hpp>\n#include <topology/BRepExtremaDistShapeShape.hpp>\n#include <topology/TopoExplorerTool.hpp>\nusing namespace AMCAX;\nnamespace\n{\n\tstd::shared_ptr<Geom3BSplineCurve> CurveChooser(const int id, const std::shared_ptr<Geom3BSplineCurve>& curve0, const std::shared_ptr<Geom3BSplineCurve>& curve1, const std::shared_ptr<Geom3BSplineCurve>& curve2)\n\t{\n\t\tstd::shared_ptr<Geom3BSplineCurve> result;\n\t\tswitch (id)\n\t\t{\n\t\tcase 0:\n\t\t{\n\t\t\tresult = curve0;\n\t\t\tbreak;\n\t\t}\n\t\tcase 1:\n\t\t{\n\t\t\tresult = curve1;\n\t\t\tbreak;\n\t\t}\n\t\tcase 2:\n\t\t{\n\t\t\tresult = curve2;\n\t\t\tbreak;\n\t\t}\n\t\t}\n\t\treturn result;\n\t}\n} \n#include<catch.hpp>\n#include<testHelper.h>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeFace.hpp>\n#include <nurbs/NURBSAPIConvert.hpp>\n#include <topology/TopoTool.hpp>\n#include <nurbs/NURBSAPIExplicitSweep.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <nurbs/NURBSAPISweepRotation.hpp>\n#include <topology/BRepExtremaDistShapeShape.hpp>\n#include <topology/TopoExplorerTool.hpp>\nusing namespace AMCAX;\nnamespace\n{\n\tstd::shared_ptr<Geom3BSplineCurve> CurveChooser(const int id, const std::shared_ptr<Geom3BSplineCurve>& curve0, const std::shared_ptr<Geom3BSplineCurve>& curve1, const std::shared_ptr<Geom3BSplineCurve>& curve2)\n\t{\n\t\tstd::shared_ptr<Geom3BSplineCurve> result;\n\t\tswitch (id)\n\t\t{\n\t\tcase 0:\n\t\t{\n\t\t\tresult = curve0;\n\t\t\tbreak;\n\t\t}\n\t\tcase 1:\n\t\t{\n\t\t\tresult = curve1;\n\t\t\tbreak;\n\t\t}\n\t\tcase 2:\n\t\t{\n\t\t\tresult = curve2;\n\t\t\tbreak;\n\t\t}\n\t\t}\n\t\treturn result;\n\t}\n;\n\tSECTION(\"TestRotationSweep()\")\t\n\tSECTION(\"TestRotationSweepPeriodic()\")\n\t{\n\t\tstd::string filedir = INPUT_PATH_PREFIX \"/TestNURBS/TestRotationSweepPeriodic/\";\n\t\tstd::shared_ptr<Geom3BSplineCurve> spine = ReadBRepCurve(filedir + \"spine.brep\");\n\t\tstd::shared_ptr<Geom3BSplineCurve> profile = ReadBRepCurve(filedir + \"profile.brep\");\n\t\tCHECK(OCCTIO::OCCTTool::Write(MakeEdge(spine), OUTPUT_PATH_PREFIX \"TestRotationSweepPeriodic_spine.brep\"));\n\t\tCHECK(OCCTIO::OCCTTool::Write(MakeEdge(profile), OUTPUT_PATH_PREFIX \"TestRotationSweepPeriodic_profile.brep\"));\n\t\tPoint3 p(21.1, 22.8, 0.0);\n\t\tVector3 vec(0.0, 0.0, 5.0);\n\t\tAxis3 axis(p, Direction3(vec));\n\t\tLine3 line(axis);\n\t\tauto surface = NURBSAPISweepRotation::RotationSweep(profile, spine, axis);\n\t\tCHECK(OCCTIO::OCCTTool::Write(MakeFace(surface, 0.0), OUTPUT_PATH_PREFIX \"TestRotationSweepPeriodic_result.brep\"));\n\t\tAMCAX::BRepExtremaDistShapeShape len1(MakeFace(surface, 0.0), MakeEdge(line));\n\t\tAMCAX::BRepExtremaDistShapeShape len2(MakeFace(surface, 0.0), MakeEdge(spine));\n\t\tCHECK(len1.Value() < 1.0);\n\t\tCHECK(len2.Value() < 1.0);\n\t\tCHECK(IsCurveOnSurf(1000, 0.1, profile, surface, 0.1));\n\t\tCHECK(IsCurveOnSurf(1000, 0.1, spine, surface, 0.1));\n\t\tspine->IncreaseDegree(11);\n\t\tprofile->IncreaseDegree(11);\n\t\tauto surface1 = NURBSAPISweepRotation::RotationSweep(profile, spine, axis);\n\t\tCHECK(OCCTIO::OCCTTool::Write(MakeFace(surface, 0.0), OUTPUT_PATH_PREFIX \"TestRotationSweepPeriodic_degree11result.brep\"));\n\t\tCHECK(surface1->UDegree() == 11);\n\t\tCHECK(surface1->VDegree() == 11);\n\t\tdouble bsp3s = GetSurfaceProperties(MakeFace(surface1, 0.0), g, true, true);\n\t\tdouble bsp4s = GetSurfaceProperties(MakeFace(surface, 0.0), g, true, true);\n\t\tCHECK(bsp3s == Approx(bsp4s).margin(0.1));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static std::vector<std::shared_ptr<Geom3BSplineSurface>> SweepTwoRails( const std::vector<NURBSCurveSection>& profile, const std::shared_ptr<Geom3BSplineCurve>& spine1, const std::shared_ptr<Geom3BSplineCurve>& spine2, double spine1RefParam, const std::vector<std::pair<int, double>>& spine1CorrParams, const std::vector<std::pair<int, double>>& spine2CorrParams, bool isClosedSweep, bool isAutoTwist),\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeFace.hpp>\n#include <nurbs/NURBSAPISweep2.hpp>\n#include <nurbs/NURBSAPIConvert.hpp>\n#include <topology/TopoTool.hpp>\n#include <nurbs/NURBSAPIExplicitSweep.hpp>\n#include <modeling/MakeVertex.hpp>\n#include<catch.hpp>\n#include<testHelper.h>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeFace.hpp>\n#include <nurbs/NURBSAPISweep2.hpp>\n#include <nurbs/NURBSAPIConvert.hpp>\n#include <topology/TopoTool.hpp>\n#include <nurbs/NURBSAPIExplicitSweep.hpp>\n#include <modeling/MakeVertex.hpp>\n;\n\tSECTION(\"TestSweep2moreover1()\")\n\t{\n\t\tstd::string filedir = INPUT_PATH_PREFIX \"/TestNURBS/TestSweep2moreover1/\";\n\t\tauto spine1 = ReadBRepCurve(filedir + \"spine1.brep\");\n\t\tauto spine2 = ReadBRepCurve(filedir + \"spine2.brep\");\n\t\tauto profile = ReadBRepCurve(filedir + \"profile1.brep\");\n\t\tPoint3 startPoint = spine1->StartPoint();\n\t\tPoint3 endPoint = spine2->StartPoint();\n\t\tPoint3 anchorPoint1(startPoint.X(), startPoint.Y(), startPoint.Z());\n\t\tPoint3 anchorPoint2(endPoint.X(), endPoint.Y(), endPoint.Z());\n\t\tDirection3 dir(1.00, 0.0,0.0);\n\t\tCHECK(OCCTIO::OCCTTool::Write(MakeEdge(spine1), OUTPUT_PATH_PREFIX \"TestSweep2moreover1_spine1.brep\"));\n\t\tCHECK(OCCTIO::OCCTTool::Write(MakeEdge(spine2), OUTPUT_PATH_PREFIX \"TestSweep2moreover1_spine2.brep\"));\n\t\tCHECK(OCCTIO::OCCTTool::Write(MakeEdge(profile), OUTPUT_PATH_PREFIX \"TestSweep2moreover1_profile.brep\"));\n\t\tCHECK(OCCTIO::OCCTTool::Write(MakeVertex(anchorPoint1), OUTPUT_PATH_PREFIX \"TestSweep2moreover1_anchorPoint1.brep\"));\n\t\tCHECK(OCCTIO::OCCTTool::Write(MakeVertex(anchorPoint2), OUTPUT_PATH_PREFIX \"TestSweep2moreover1_anchorPoint2.brep\"));\n\t\tauto [status, surface] = NURBSAPIExplicitSweep::SweepWithTwoGuideCurves(profile, spine1, spine2, anchorPoint2, anchorPoint1, spine1, spine1->FirstParameter(), spine1->LastParameter());\n\t\tauto surfaces = NURBSAPISweep2::SweepTwoRails(profile, spine1, spine2);\n\t\tstd::shared_ptr<Geom3BSplineSurface> result = surfaces[0];\n\t\tCHECK(OCCTIO::OCCTTool::Write(MakeFace(result, 0.0), OUTPUT_PATH_PREFIX \"TestSweep2moreover1_surface1.brep\"));\n\t\tCHECK(OCCTIO::OCCTTool::Write(MakeFace(surface, 0.0), OUTPUT_PATH_PREFIX \"TestSweep2moreover1_surface2.brep\"));\n\t\tCHECK(IsCurveOnSurf(100, 0.1, profile, surfaces[0], 0.01));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static std::vector<std::shared_ptr<Geom3BSplineSurface>> SweepTwoRails( const std::shared_ptr<Geom3BSplineCurve>& profile, const std::shared_ptr<Geom3BSplineCurve>& spine1, const std::shared_ptr<Geom3BSplineCurve>& spine2),\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeFace.hpp>\n#include <nurbs/NURBSAPISweep2.hpp>\n#include <nurbs/NURBSAPIConvert.hpp>\n#include <topology/TopoTool.hpp>\n#include <nurbs/NURBSAPIExplicitSweep.hpp>\n#include <modeling/MakeVertex.hpp>\n#include<catch.hpp>\n#include<testHelper.h>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeFace.hpp>\n#include <nurbs/NURBSAPISweep2.hpp>\n#include <nurbs/NURBSAPIConvert.hpp>\n#include <topology/TopoTool.hpp>\n#include <nurbs/NURBSAPIExplicitSweep.hpp>\n#include <modeling/MakeVertex.hpp>\n;\n\tSECTION(\"TestSweep2moreover1()\")\n\t{\n\t\tstd::string filedir = INPUT_PATH_PREFIX \"/TestNURBS/TestSweep2moreover1/\";\n\t\tauto spine1 = ReadBRepCurve(filedir + \"spine1.brep\");\n\t\tauto spine2 = ReadBRepCurve(filedir + \"spine2.brep\");\n\t\tauto profile = ReadBRepCurve(filedir + \"profile1.brep\");\n\t\tPoint3 startPoint = spine1->StartPoint();\n\t\tPoint3 endPoint = spine2->StartPoint();\n\t\tPoint3 anchorPoint1(startPoint.X(), startPoint.Y(), startPoint.Z());\n\t\tPoint3 anchorPoint2(endPoint.X(), endPoint.Y(), endPoint.Z());\n\t\tDirection3 dir(1.00, 0.0,0.0);\n\t\tCHECK(OCCTIO::OCCTTool::Write(MakeEdge(spine1), OUTPUT_PATH_PREFIX \"TestSweep2moreover1_spine1.brep\"));\n\t\tCHECK(OCCTIO::OCCTTool::Write(MakeEdge(spine2), OUTPUT_PATH_PREFIX \"TestSweep2moreover1_spine2.brep\"));\n\t\tCHECK(OCCTIO::OCCTTool::Write(MakeEdge(profile), OUTPUT_PATH_PREFIX \"TestSweep2moreover1_profile.brep\"));\n\t\tCHECK(OCCTIO::OCCTTool::Write(MakeVertex(anchorPoint1), OUTPUT_PATH_PREFIX \"TestSweep2moreover1_anchorPoint1.brep\"));\n\t\tCHECK(OCCTIO::OCCTTool::Write(MakeVertex(anchorPoint2), OUTPUT_PATH_PREFIX \"TestSweep2moreover1_anchorPoint2.brep\"));\n\t\tauto [status, surface] = NURBSAPIExplicitSweep::SweepWithTwoGuideCurves(profile, spine1, spine2, anchorPoint2, anchorPoint1, spine1, spine1->FirstParameter(), spine1->LastParameter());\n\t\tauto surfaces = NURBSAPISweep2::SweepTwoRails(profile, spine1, spine2);\n\t\tstd::shared_ptr<Geom3BSplineSurface> result = surfaces[0];\n\t\tCHECK(OCCTIO::OCCTTool::Write(MakeFace(result, 0.0), OUTPUT_PATH_PREFIX \"TestSweep2moreover1_surface1.brep\"));\n\t\tCHECK(OCCTIO::OCCTTool::Write(MakeFace(surface, 0.0), OUTPUT_PATH_PREFIX \"TestSweep2moreover1_surface2.brep\"));\n\t\tCHECK(IsCurveOnSurf(100, 0.1, profile, surfaces[0], 0.01));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static std::vector<std::shared_ptr<Geom3BSplineSurface>> SweepTwoRails( const std::vector<NURBSCurveSection>& profile, const std::shared_ptr<Geom3BSplineCurve>& spine1, const std::shared_ptr<Geom3BSplineCurve>& spine2, double spine1RefParam, const std::vector<std::pair<int, double>>& spine1CorrParams, const std::vector<std::pair<int, double>>& spine2CorrParams, bool isClosedSweep, bool isAutoTwist),\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <filesystem>\n#include <fstream>\n#include <random>\n#include <sstream>\n#include <nurbs/NURBSAPIGetGeometry.hpp>\n#include <nurbs/NURBSAPIConicalSweep.hpp>\n#include <boolean/BoolBRepCut.hpp>\n#include <common/CartesianCoordinateSystem.hpp>\n#include <common/IndexMap.hpp>\n#include <common/QuaternionT.hpp>\n#include <geomAlgo/LawBSpline.hpp>\n#include <geomAlgo/LawConstant.hpp>\n#include <nurbs/NURBSAPISmooth.hpp>\n#include <geomAlgo/MakeConic2FromConstraints.hpp>\n#include <geometry/Adaptor3CurveOnSurface.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/AdaptorGeom3Surface.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2Circle.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/Geom2Hyperbola.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3BSplineCurve.hpp>\n#include <geometry/Geom3BSplineSurface.hpp>\n#include <geometry/Geom3Circle.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\n#include <geometry/Geom3Plane.hpp>\n#include <geometry/Geom3SphericalSurface.hpp>\n#include <geometry/Geom3Surface.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include <geometry/Geom3TrimmedSurface.hpp>\n#include <geometry/GeomAPIExtremaCurveCurve3.hpp>\n#include <geometry/GeomAPIProjectPointOnCurve2.hpp>\n#include <geometry/GeomAPIProjectPointOnCurve3.hpp>\n#include <geometry/GeomAPIProjectPointOnSurface.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/GlobalProperty.hpp>\n#include <healing/ShapeFixTool.hpp>\n#include <io/STLTool.hpp>\n#include <math/Sphere.hpp>\n#include <math/TriangularMesh.hpp>\n#include <modeling/CopyShape.hpp>\n#include <modeling/MakeBox.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeFace.hpp>\n#include <modeling/MakePrism.hpp>\n#include <modeling/MakeRevol.hpp>\n#include <modeling/MakeShapeTool.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <modeling/MakeWire.hpp>\n#include <modeling/TransformShape.hpp>\n#include <nurbs/NURBSAPIApprox.hpp>\n#include <nurbs/NURBSAPIBuildCurve.hpp>\n#include <nurbs/NURBSAPICircularSweep.hpp>\n#include <nurbs/NURBSAPIConvert.hpp>\n#include <nurbs/NURBSAPICurveNetworkSurface.hpp>\n#include <nurbs/NURBSAPIExplicitSweep.hpp>\n#include <nurbs/NURBSAPIExplode.hpp>\n#include <nurbs/NURBSAPIExtend.hpp>\n#include <nurbs/NURBSAPIInterpolate.hpp>\n#include <nurbs/NURBSAPIJoin.hpp>\n#include <nurbs/NURBSAPILinearSweep.hpp>\n#include <nurbs/NURBSAPILoft.hpp>\n#include <nurbs/NURBSAPIMakeNURBSFromBoundaries.hpp>\n#include <nurbs/NURBSAPIMatch.hpp>\n#include <nurbs/NURBSAPIModifyEndToPlane.hpp>\n#include <nurbs/NURBSAPIOffsetCurveOnSurface.hpp>\n#include <nurbs/NURBSAPIProject.hpp>\n#include <nurbs/NURBSAPIRebuild.hpp>\n#include <nurbs/NURBSAPIReplaceEdge.hpp>\n#include <nurbs/NURBSAPISweep.hpp>\n#include <nurbs/NURBSAPISweep2.hpp>\n#include <nurbs/NURBSAPISweepRotation.hpp>\n#include <nurbs/NURBSAPITrim.hpp>\n#include <nurbs/NURBSAPIUntrim.hpp>\n#include <nurbs/NURBSLinearSweepWithDraftDirectionLength.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <offset/MakePipe.hpp>\n#include <offset/MakePipeShell.hpp>\n#include <topology/BRepAdaptorCurve2.hpp>\n#include <topology/BRepAdaptorCurve3.hpp>\n#include <topology/BRepAdaptorSurface.hpp>\n#include <topology/BRepGlobalProperty.hpp>\n#include <topology/BRepTool.hpp>\n#include <topology/TopoBuilder.hpp>\n#include <topology/TopoCompound.hpp>\n#include <topology/TopoEdge.hpp>\n#include <topology/TopoExplorer.hpp>\n#include <topology/TopoExplorerTool.hpp>\n#include <topology/TopoFace.hpp>\n#include <topology/TopoShape.hpp>\n#include <topology/TopoShell.hpp>\n#include <topology/TopoTool.hpp>\n#include <topology/TopoVertex.hpp>\n#include <topology/TopoWire.hpp>\n#include <topology/WireExplorer.hpp>\n#include <topomesh/BRepMeshIncrementalMesh.hpp>\n#include <nurbs/NURBSAPIBlend.hpp>\n#include <topology/BRepExtremaDistShapeShape.hpp>\n#include <math/LineT.hpp>\n#include <hatch/BRepClassificationTools.hpp>\nusing namespace AMCAX;\nnamespace\n{\n\tstd::shared_ptr<Geom3BSplineCurve> CurveChooser(const int id, const std::shared_ptr<Geom3BSplineCurve>& curve0, const std::shared_ptr<Geom3BSplineCurve>& curve1, const std::shared_ptr<Geom3BSplineCurve>& curve2)\n\t{\n\t\tstd::shared_ptr<Geom3BSplineCurve> result;\n\t\tswitch (id)\n\t\t{\n\t\tcase 0:\n\t\t{\n\t\t\tresult = curve0;\n\t\t\tbreak;\n\t\t}\n\t\tcase 1:\n\t\t{\n\t\t\tresult = curve1;\n\t\t\tbreak;\n\t\t}\n\t\tcase 2:\n\t\t{\n\t\t\tresult = curve2;\n\t\t\tbreak;\n\t\t}\n\t\t}\n\t\treturn result;\n\t}\n}\n#include<catch.hpp>\n#include<testHelper.h>\n#include <filesystem>\n#include <fstream>\n#include <random>\n#include <sstream>\n#include <nurbs/NURBSAPIGetGeometry.hpp>\n#include <nurbs/NURBSAPIConicalSweep.hpp>\n#include <boolean/BoolBRepCut.hpp>\n#include <common/CartesianCoordinateSystem.hpp>\n#include <common/IndexMap.hpp>\n#include <common/QuaternionT.hpp>\n#include <geomAlgo/LawBSpline.hpp>\n#include <geomAlgo/LawConstant.hpp>\n#include <nurbs/NURBSAPISmooth.hpp>\n#include <geomAlgo/MakeConic2FromConstraints.hpp>\n#include <geometry/Adaptor3CurveOnSurface.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/AdaptorGeom3Surface.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2Circle.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/Geom2Hyperbola.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3BSplineCurve.hpp>\n#include <geometry/Geom3BSplineSurface.hpp>\n#include <geometry/Geom3Circle.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\n#include <geometry/Geom3Plane.hpp>\n#include <geometry/Geom3SphericalSurface.hpp>\n#include <geometry/Geom3Surface.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include <geometry/Geom3TrimmedSurface.hpp>\n#include <geometry/GeomAPIExtremaCurveCurve3.hpp>\n#include <geometry/GeomAPIProjectPointOnCurve2.hpp>\n#include <geometry/GeomAPIProjectPointOnCurve3.hpp>\n#include <geometry/GeomAPIProjectPointOnSurface.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/GlobalProperty.hpp>\n#include <healing/ShapeFixTool.hpp>\n#include <io/STLTool.hpp>\n#include <math/Sphere.hpp>\n#include <math/TriangularMesh.hpp>\n#include <modeling/CopyShape.hpp>\n#include <modeling/MakeBox.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeFace.hpp>\n#include <modeling/MakePrism.hpp>\n#include <modeling/MakeRevol.hpp>\n#include <modeling/MakeShapeTool.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <modeling/MakeWire.hpp>\n#include <modeling/TransformShape.hpp>\n#include <nurbs/NURBSAPIApprox.hpp>\n#include <nurbs/NURBSAPIBuildCurve.hpp>\n#include <nurbs/NURBSAPICircularSweep.hpp>\n#include <nurbs/NURBSAPIConvert.hpp>\n#include <nurbs/NURBSAPICurveNetworkSurface.hpp>\n#include <nurbs/NURBSAPIExplicitSweep.hpp>\n#include <nurbs/NURBSAPIExplode.hpp>\n#include <nurbs/NURBSAPIExtend.hpp>\n#include <nurbs/NURBSAPIInterpolate.hpp>\n#include <nurbs/NURBSAPIJoin.hpp>\n#include <nurbs/NURBSAPILinearSweep.hpp>\n#include <nurbs/NURBSAPILoft.hpp>\n#include <nurbs/NURBSAPIMakeNURBSFromBoundaries.hpp>\n#include <nurbs/NURBSAPIMatch.hpp>\n#include <nurbs/NURBSAPIModifyEndToPlane.hpp>\n#include <nurbs/NURBSAPIOffsetCurveOnSurface.hpp>\n#include <nurbs/NURBSAPIProject.hpp>\n#include <nurbs/NURBSAPIRebuild.hpp>\n#include <nurbs/NURBSAPIReplaceEdge.hpp>\n#include <nurbs/NURBSAPISweep.hpp>\n#include <nurbs/NURBSAPISweep2.hpp>\n#include <nurbs/NURBSAPISweepRotation.hpp>\n#include <nurbs/NURBSAPITrim.hpp>\n#include <nurbs/NURBSAPIUntrim.hpp>\n#include <nurbs/NURBSLinearSweepWithDraftDirectionLength.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <offset/MakePipe.hpp>\n#include <offset/MakePipeShell.hpp>\n#include <topology/BRepAdaptorCurve2.hpp>\n#include <topology/BRepAdaptorCurve3.hpp>\n#include <topology/BRepAdaptorSurface.hpp>\n#include <topology/BRepGlobalProperty.hpp>\n#include <topology/BRepTool.hpp>\n#include <topology/TopoBuilder.hpp>\n#include <topology/TopoCompound.hpp>\n#include <topology/TopoEdge.hpp>\n#include <topology/TopoExplorer.hpp>\n#include <topology/TopoExplorerTool.hpp>\n#include <topology/TopoFace.hpp>\n#include <topology/TopoShape.hpp>\n#include <topology/TopoShell.hpp>\n#include <topology/TopoTool.hpp>\n#include <topology/TopoVertex.hpp>\n#include <topology/TopoWire.hpp>\n#include <topology/WireExplorer.hpp>\n#include <topomesh/BRepMeshIncrementalMesh.hpp>\n#include <nurbs/NURBSAPIBlend.hpp>\n#include <topology/BRepExtremaDistShapeShape.hpp>\n#include <math/LineT.hpp>\n#include <hatch/BRepClassificationTools.hpp>\nusing namespace AMCAX;\nnamespace\n{\n\tstd::shared_ptr<Geom3BSplineCurve> CurveChooser(const int id, const std::shared_ptr<Geom3BSplineCurve>& curve0, const std::shared_ptr<Geom3BSplineCurve>& curve1, const std::shared_ptr<Geom3BSplineCurve>& curve2)\n\t{\n\t\tstd::shared_ptr<Geom3BSplineCurve> result;\n\t\tswitch (id)\n\t\t{\n\t\tcase 0:\n\t\t{\n\t\t\tresult = curve0;\n\t\t\tbreak;\n\t\t}\n\t\tcase 1:\n\t\t{\n\t\t\tresult = curve1;\n\t\t\tbreak;\n\t\t}\n\t\tcase 2:\n\t\t{\n\t\t\tresult = curve2;\n\t\t\tbreak;\n\t\t}\n\t\t}\n\t\treturn result;\n\t}\n;\n\tSECTION(\"TestSweep2C0AllStraight()\")\t\n\t\t{\n\t\t\tstd::string filedir = INPUT_PATH_PREFIX \"/TestNURBS/TestSweep2C0AllStraight/\";\n\t\t\tstd::vector<NURBSCurveSection> profiles;\n\t\t\tstd::shared_ptr<Geom3BSplineCurve> profile0 = ReadBRepCurve(filedir + \"profile0.brep\");\n\t\t\tstd::shared_ptr<Geom3BSplineCurve> profile1 = ReadBRepCurve(filedir + \"profile1.brep\");\n\t\t\tstd::shared_ptr<Geom3BSplineCurve> profile2 = ReadBRepCurve(filedir + \"profile2.brep\");\n\t\t\tfor (int i = 0; i <= 2; i++)\n\t\t\t{\n\t\t\t\tprofiles.push_back(NURBSCurveSection(ReadBRepCurve(filedir + \"profile\" + std::to_string(i) + \".brep\")));\n\t\t\t}\n\t\t\tauto spine1 = ReadBRepCurve(filedir + \"spine1.brep\");\n\t\t\tauto spine2 = ReadBRepCurve(filedir + \"spine2.brep\");\n\t\t\tspine1->SetPeriodic();\n\t\t\tspine2->SetPeriodic();\n\t\t\tCHECK(OCCTIO::OCCTTool::Write(MakeEdge(spine1), OUTPUT_PATH_PREFIX \"TestSweep2C0AllStraight_spine1.brep\"));\n\t\t\tCHECK(OCCTIO::OCCTTool::Write(MakeEdge(spine2), OUTPUT_PATH_PREFIX \"TestSweep2C0AllStraight_spine2.brep\"));\n\t\t\tbool isAutoTwist = true;\n\t\t\tbool isClosedSweep = true;\n\t\t\tstd::vector<std::pair<int, double>> parm;\n\t\t\tauto bsp4 = NURBSAPISweep2::SweepTwoRails(profiles, spine1, spine2, 0.5, std::vector<std::pair<int, double>>(), std::vector<std::pair<int, double>>(), isClosedSweep, isAutoTwist);\n\t\t\tfor (int i = 0; i < static_cast<int>(bsp4.size()); i++)\n\t\t\t{\n\t\t\t\tCHECK(OCCTIO::OCCTTool::Write(MakeFace(bsp4[i], 0.0), OUTPUT_PATH_PREFIX \"TestSweep2C0AllStraight_face\" + std::to_string(i) + \".brep\"));\n\t\t\t}\n\t\t\tCHECK(IsCurveOnSurf(1000, 0.3, profile0, bsp4[3], 0.1));\n\t\t\tCHECK(IsCurveOnSurf(1000, 0.1, profile1, bsp4[3], 0.1));\n\t\t\tCHECK(IsCurveOnSurf(1000, 0.1, profile2, bsp4[0], 0.1));\n\t\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static std::vector<std::shared_ptr<Geom3BSplineSurface>> SweepTwoRails( const std::shared_ptr<Geom3BSplineCurve>& profile, const std::shared_ptr<Geom3BSplineCurve>& spine1, const std::shared_ptr<Geom3BSplineCurve>& spine2),\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <filesystem>\n#include <fstream>\n#include <random>\n#include <sstream>\n#include <nurbs/NURBSAPIGetGeometry.hpp>\n#include <nurbs/NURBSAPIConicalSweep.hpp>\n#include <boolean/BoolBRepCut.hpp>\n#include <common/CartesianCoordinateSystem.hpp>\n#include <common/IndexMap.hpp>\n#include <common/QuaternionT.hpp>\n#include <geomAlgo/LawBSpline.hpp>\n#include <geomAlgo/LawConstant.hpp>\n#include <nurbs/NURBSAPISmooth.hpp>\n#include <geomAlgo/MakeConic2FromConstraints.hpp>\n#include <geometry/Adaptor3CurveOnSurface.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/AdaptorGeom3Surface.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2Circle.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/Geom2Hyperbola.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3BSplineCurve.hpp>\n#include <geometry/Geom3BSplineSurface.hpp>\n#include <geometry/Geom3Circle.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\n#include <geometry/Geom3Plane.hpp>\n#include <geometry/Geom3SphericalSurface.hpp>\n#include <geometry/Geom3Surface.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include <geometry/Geom3TrimmedSurface.hpp>\n#include <geometry/GeomAPIExtremaCurveCurve3.hpp>\n#include <geometry/GeomAPIProjectPointOnCurve2.hpp>\n#include <geometry/GeomAPIProjectPointOnCurve3.hpp>\n#include <geometry/GeomAPIProjectPointOnSurface.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/GlobalProperty.hpp>\n#include <healing/ShapeFixTool.hpp>\n#include <io/STLTool.hpp>\n#include <math/Sphere.hpp>\n#include <math/TriangularMesh.hpp>\n#include <modeling/CopyShape.hpp>\n#include <modeling/MakeBox.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeFace.hpp>\n#include <modeling/MakePrism.hpp>\n#include <modeling/MakeRevol.hpp>\n#include <modeling/MakeShapeTool.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <modeling/MakeWire.hpp>\n#include <modeling/TransformShape.hpp>\n#include <nurbs/NURBSAPIApprox.hpp>\n#include <nurbs/NURBSAPIBuildCurve.hpp>\n#include <nurbs/NURBSAPICircularSweep.hpp>\n#include <nurbs/NURBSAPIConvert.hpp>\n#include <nurbs/NURBSAPICurveNetworkSurface.hpp>\n#include <nurbs/NURBSAPIExplicitSweep.hpp>\n#include <nurbs/NURBSAPIExplode.hpp>\n#include <nurbs/NURBSAPIExtend.hpp>\n#include <nurbs/NURBSAPIInterpolate.hpp>\n#include <nurbs/NURBSAPIJoin.hpp>\n#include <nurbs/NURBSAPILinearSweep.hpp>\n#include <nurbs/NURBSAPILoft.hpp>\n#include <nurbs/NURBSAPIMakeNURBSFromBoundaries.hpp>\n#include <nurbs/NURBSAPIMatch.hpp>\n#include <nurbs/NURBSAPIModifyEndToPlane.hpp>\n#include <nurbs/NURBSAPIOffsetCurveOnSurface.hpp>\n#include <nurbs/NURBSAPIProject.hpp>\n#include <nurbs/NURBSAPIRebuild.hpp>\n#include <nurbs/NURBSAPIReplaceEdge.hpp>\n#include <nurbs/NURBSAPISweep.hpp>\n#include <nurbs/NURBSAPISweep2.hpp>\n#include <nurbs/NURBSAPISweepRotation.hpp>\n#include <nurbs/NURBSAPITrim.hpp>\n#include <nurbs/NURBSAPIUntrim.hpp>\n#include <nurbs/NURBSLinearSweepWithDraftDirectionLength.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <offset/MakePipe.hpp>\n#include <offset/MakePipeShell.hpp>\n#include <topology/BRepAdaptorCurve2.hpp>\n#include <topology/BRepAdaptorCurve3.hpp>\n#include <topology/BRepAdaptorSurface.hpp>\n#include <topology/BRepGlobalProperty.hpp>\n#include <topology/BRepTool.hpp>\n#include <topology/TopoBuilder.hpp>\n#include <topology/TopoCompound.hpp>\n#include <topology/TopoEdge.hpp>\n#include <topology/TopoExplorer.hpp>\n#include <topology/TopoExplorerTool.hpp>\n#include <topology/TopoFace.hpp>\n#include <topology/TopoShape.hpp>\n#include <topology/TopoShell.hpp>\n#include <topology/TopoTool.hpp>\n#include <topology/TopoVertex.hpp>\n#include <topology/TopoWire.hpp>\n#include <topology/WireExplorer.hpp>\n#include <topomesh/BRepMeshIncrementalMesh.hpp>\n#include <nurbs/NURBSAPIBlend.hpp>\n#include <topology/BRepExtremaDistShapeShape.hpp>\n#include <math/LineT.hpp>\n#include <hatch/BRepClassificationTools.hpp>\nusing namespace AMCAX;\nnamespace\n{\n\tstd::shared_ptr<Geom3BSplineCurve> CurveChooser(const int id, const std::shared_ptr<Geom3BSplineCurve>& curve0, const std::shared_ptr<Geom3BSplineCurve>& curve1, const std::shared_ptr<Geom3BSplineCurve>& curve2)\n\t{\n\t\tstd::shared_ptr<Geom3BSplineCurve> result;\n\t\tswitch (id)\n\t\t{\n\t\tcase 0:\n\t\t{\n\t\t\tresult = curve0;\n\t\t\tbreak;\n\t\t}\n\t\tcase 1:\n\t\t{\n\t\t\tresult = curve1;\n\t\t\tbreak;\n\t\t}\n\t\tcase 2:\n\t\t{\n\t\t\tresult = curve2;\n\t\t\tbreak;\n\t\t}\n\t\t}\n\t\treturn result;\n\t}\n}\n#include<catch.hpp>\n#include<testHelper.h>\n#include <filesystem>\n#include <fstream>\n#include <random>\n#include <sstream>\n#include <nurbs/NURBSAPIGetGeometry.hpp>\n#include <nurbs/NURBSAPIConicalSweep.hpp>\n#include <boolean/BoolBRepCut.hpp>\n#include <common/CartesianCoordinateSystem.hpp>\n#include <common/IndexMap.hpp>\n#include <common/QuaternionT.hpp>\n#include <geomAlgo/LawBSpline.hpp>\n#include <geomAlgo/LawConstant.hpp>\n#include <nurbs/NURBSAPISmooth.hpp>\n#include <geomAlgo/MakeConic2FromConstraints.hpp>\n#include <geometry/Adaptor3CurveOnSurface.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/AdaptorGeom3Surface.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2Circle.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/Geom2Hyperbola.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3BSplineCurve.hpp>\n#include <geometry/Geom3BSplineSurface.hpp>\n#include <geometry/Geom3Circle.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\n#include <geometry/Geom3Plane.hpp>\n#include <geometry/Geom3SphericalSurface.hpp>\n#include <geometry/Geom3Surface.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include <geometry/Geom3TrimmedSurface.hpp>\n#include <geometry/GeomAPIExtremaCurveCurve3.hpp>\n#include <geometry/GeomAPIProjectPointOnCurve2.hpp>\n#include <geometry/GeomAPIProjectPointOnCurve3.hpp>\n#include <geometry/GeomAPIProjectPointOnSurface.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/GlobalProperty.hpp>\n#include <healing/ShapeFixTool.hpp>\n#include <io/STLTool.hpp>\n#include <math/Sphere.hpp>\n#include <math/TriangularMesh.hpp>\n#include <modeling/CopyShape.hpp>\n#include <modeling/MakeBox.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeFace.hpp>\n#include <modeling/MakePrism.hpp>\n#include <modeling/MakeRevol.hpp>\n#include <modeling/MakeShapeTool.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <modeling/MakeWire.hpp>\n#include <modeling/TransformShape.hpp>\n#include <nurbs/NURBSAPIApprox.hpp>\n#include <nurbs/NURBSAPIBuildCurve.hpp>\n#include <nurbs/NURBSAPICircularSweep.hpp>\n#include <nurbs/NURBSAPIConvert.hpp>\n#include <nurbs/NURBSAPICurveNetworkSurface.hpp>\n#include <nurbs/NURBSAPIExplicitSweep.hpp>\n#include <nurbs/NURBSAPIExplode.hpp>\n#include <nurbs/NURBSAPIExtend.hpp>\n#include <nurbs/NURBSAPIInterpolate.hpp>\n#include <nurbs/NURBSAPIJoin.hpp>\n#include <nurbs/NURBSAPILinearSweep.hpp>\n#include <nurbs/NURBSAPILoft.hpp>\n#include <nurbs/NURBSAPIMakeNURBSFromBoundaries.hpp>\n#include <nurbs/NURBSAPIMatch.hpp>\n#include <nurbs/NURBSAPIModifyEndToPlane.hpp>\n#include <nurbs/NURBSAPIOffsetCurveOnSurface.hpp>\n#include <nurbs/NURBSAPIProject.hpp>\n#include <nurbs/NURBSAPIRebuild.hpp>\n#include <nurbs/NURBSAPIReplaceEdge.hpp>\n#include <nurbs/NURBSAPISweep.hpp>\n#include <nurbs/NURBSAPISweep2.hpp>\n#include <nurbs/NURBSAPISweepRotation.hpp>\n#include <nurbs/NURBSAPITrim.hpp>\n#include <nurbs/NURBSAPIUntrim.hpp>\n#include <nurbs/NURBSLinearSweepWithDraftDirectionLength.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <offset/MakePipe.hpp>\n#include <offset/MakePipeShell.hpp>\n#include <topology/BRepAdaptorCurve2.hpp>\n#include <topology/BRepAdaptorCurve3.hpp>\n#include <topology/BRepAdaptorSurface.hpp>\n#include <topology/BRepGlobalProperty.hpp>\n#include <topology/BRepTool.hpp>\n#include <topology/TopoBuilder.hpp>\n#include <topology/TopoCompound.hpp>\n#include <topology/TopoEdge.hpp>\n#include <topology/TopoExplorer.hpp>\n#include <topology/TopoExplorerTool.hpp>\n#include <topology/TopoFace.hpp>\n#include <topology/TopoShape.hpp>\n#include <topology/TopoShell.hpp>\n#include <topology/TopoTool.hpp>\n#include <topology/TopoVertex.hpp>\n#include <topology/TopoWire.hpp>\n#include <topology/WireExplorer.hpp>\n#include <topomesh/BRepMeshIncrementalMesh.hpp>\n#include <nurbs/NURBSAPIBlend.hpp>\n#include <topology/BRepExtremaDistShapeShape.hpp>\n#include <math/LineT.hpp>\n#include <hatch/BRepClassificationTools.hpp>\nusing namespace AMCAX;\nnamespace\n{\n\tstd::shared_ptr<Geom3BSplineCurve> CurveChooser(const int id, const std::shared_ptr<Geom3BSplineCurve>& curve0, const std::shared_ptr<Geom3BSplineCurve>& curve1, const std::shared_ptr<Geom3BSplineCurve>& curve2)\n\t{\n\t\tstd::shared_ptr<Geom3BSplineCurve> result;\n\t\tswitch (id)\n\t\t{\n\t\tcase 0:\n\t\t{\n\t\t\tresult = curve0;\n\t\t\tbreak;\n\t\t}\n\t\tcase 1:\n\t\t{\n\t\t\tresult = curve1;\n\t\t\tbreak;\n\t\t}\n\t\tcase 2:\n\t\t{\n\t\t\tresult = curve2;\n\t\t\tbreak;\n\t\t}\n\t\t}\n\t\treturn result;\n\t}\n;\n\tSECTION(\"TestSweep2()\")\n\t\t{\n\t\t\tstd::shared_ptr<Geom3BSplineCurve> bsp1, bsp2, bsp3;\n\t\t\t{\n\t\t\t\tint deg = 3;\n\t\t\t\tstd::vector<Point3> poles;\n\t\t\t\tpoles.push_back(Point3(0.0, -1.0, 0.0));\n\t\t\t\tpoles.push_back(Point3(0.7, -0.7, 0.0));\n\t\t\t\tpoles.push_back(Point3(1.0, -0.3, 0.0));\n\t\t\t\tpoles.push_back(Point3(1.2, 0.0, -0.0));\n\t\t\t\tpoles.push_back(Point3(2.0, 0.3, -0.0));\n\t\t\t\tpoles.push_back(Point3(0.7, 1.7, -0.0));\n\t\t\t\tpoles.push_back(Point3(0.0, 1.0, 0.0));\n\t\t\t\tpoles.push_back(Point3(-0.7, 1.7, -0.0));\n\t\t\t\tpoles.push_back(Point3(-2.0, 0.3, -0.0));\n\t\t\t\tpoles.push_back(Point3(-1.2, 0.0, -0.0));\n\t\t\t\tpoles.push_back(Point3(-1.0, -0.3, 0.0));\n\t\t\t\tpoles.push_back(Point3(-0.7, -0.7, 0.0));\n\t\t\t\tpoles.push_back(Point3(0.0, -1.0, 0.0));\n\t\t\t\tstd::vector<double> weights;\n\t\t\t\tweights.push_back(0.9);\n\t\t\t\tweights.push_back(1.1);\n\t\t\t\tweights.push_back(1.2);\n\t\t\t\tweights.push_back(0.7);\n\t\t\t\tweights.push_back(1.5);\n\t\t\t\tweights.push_back(0.9);\n\t\t\t\tweights.push_back(1.2);\n\t\t\t\tweights.push_back(1.5);\n\t\t\t\tweights.push_back(0.8);\n\t\t\t\tweights.push_back(0.5);\n\t\t\t\tweights.push_back(1.1);\n\t\t\t\tweights.push_back(1.0);\n\t\t\t\tweights.push_back(1.3);\n\t\t\t\tint nknots = static_cast<int>(poles.size()) - deg + 1;\n\t\t\t\tstd::vector<double> knots(nknots);\n\t\t\t\tfor (int i = 0; i < nknots; i++)\n\t\t\t\t{\n\t\t\t\t\tknots[i] = (double)i / (double)(nknots - 1.0);\n\t\t\t\t}\n\t\t\t\tstd::vector<int> mults(nknots, 1);\n\t\t\t\tmults.front() = 4;\n\t\t\t\tmults.back() = 4;\n\t\t\t\tbsp1 = std::make_shared<Geom3BSplineCurve>(poles, weights, knots, mults, deg);\n\t\t\t}\n\t\t\t{\n\t\t\t\tint deg = 3;\n\t\t\t\tstd::vector<Point3> poles;\n\t\t\t\tpoles.push_back(Point3(0.0, 1.0, 0.0));\n\t\t\t\tpoles.push_back(Point3(0.0, 0.7, 0.0));\n\t\t\t\tpoles.push_back(Point3(0.0, 0.3, 0.5));\n\t\t\t\tpoles.push_back(Point3(0.0, 0.3, 1.0));\n\t\t\t\tstd::vector<double> weights;\n\t\t\t\tweights.push_back(0.9);\n\t\t\t\tweights.push_back(1.1);\n\t\t\t\tweights.push_back(1.2);\n\t\t\t\tweights.push_back(0.7);\n\t\t\t\tint nknots = static_cast<int>(poles.size()) - deg + 1;\n\t\t\t\tstd::vector<double> knots(nknots);\n\t\t\t\tfor (int i = 0; i < nknots; i++)\n\t\t\t\t{\n\t\t\t\t\tknots[i] = (double)i / (double)(nknots - 1.0);\n\t\t\t\t}\n\t\t\t\tstd::vector<int> mults(nknots, 1);\n\t\t\t\tmults.front() = 4;\n\t\t\t\tmults.back() = 4;\n\t\t\t\tbsp2 = std::make_shared<Geom3BSplineCurve>(poles, weights, knots, mults, 3);\n\t\t\t}\n\t\t\t{\n\t\t\t\tint deg = 3;\n\t\t\t\tstd::vector<Point3> poles;\n\t\t\t\tpoles.push_back(Point3(0.0, -1.0, 0.0));\n\t\t\t\tpoles.push_back(Point3(0.0, -0.5, 0.0));\n\t\t\t\tpoles.push_back(Point3(0.0, -0.2, 0.5));\n\t\t\t\tpoles.push_back(Point3(0.0, -0.2, 1.0));\n\t\t\t\tstd::vector<double> weights;\n\t\t\t\tweights.push_back(0.7);\n\t\t\t\tweights.push_back(1.5);\n\t\t\t\tweights.push_back(0.9);\n\t\t\t\tweights.push_back(1.2);\n\t\t\t\tint nknots = static_cast<int>(poles.size()) - deg + 1;\n\t\t\t\tstd::vector<double> knots(nknots);\n\t\t\t\tfor (int i = 0; i < nknots; i++)\n\t\t\t\t{\n\t\t\t\t\tknots[i] = (double)i / (double)(nknots - 1.0);\n\t\t\t\t}\n\t\t\t\tstd::vector<int> mults(nknots, 1);\n\t\t\t\tmults.front() = 4;\n\t\t\t\tmults.back() = 4;\n\t\t\t\tbsp3 = std::make_shared<Geom3BSplineCurve>(poles, weights, knots, mults, 3);\n\t\t\t}\n\t\t\tCHECK(OCCTIO::OCCTTool::Write(MakeEdge(bsp1), OUTPUT_PATH_PREFIX \"TestSweep2_profile.brep\"));\n\t\t\tCHECK(OCCTIO::OCCTTool::Write(MakeEdge(bsp2), OUTPUT_PATH_PREFIX \"TestSweep2_spine1.brep\"));\n\t\t\tCHECK(OCCTIO::OCCTTool::Write(MakeEdge(bsp3), OUTPUT_PATH_PREFIX \"TestSweep2_spine2.brep\"));\n\t\t\tauto bsp4 = NURBSAPISweep2::SweepTwoRails(bsp1, bsp2, bsp3);\n\t\t\tCHECK(OCCTIO::OCCTTool::Write(MakeFace(bsp4[0], 0.0), OUTPUT_PATH_PREFIX \"TestSweep2_result.brep\"));\n\t\t\tCHECK(bsp4.size() == 1);\n\t\t\tCHECK(IsCurveOnSurf(1000, 0.2, bsp1, bsp4[0], 0.1));\n\t\t\tCHECK(IsCurveOnSurf(1000, 0.2, bsp3, bsp4[0], 0.1));\n\t\t\tIndexSet<TopoShape> newshapeEdge1;\n\t\t\tTopoExplorerTool::MapShapes(MakeFace(bsp4[0], 0.0), ShapeType::Edge, newshapeEdge1);\n\t\t\tstd::cout << \"newshapeedge1=\" << newshapeEdge1.size() << std::endl;\n\t\t\tCHECK(OCCTIO::OCCTTool::Write(newshapeEdge1[2], OUTPUT_PATH_PREFIX \"TestSweep2_newshapeEdge1[2].brep\"));\n\t\t\tTopoExplorer ex0(newshapeEdge1[0], ShapeType::Edge);\n\t\t\tTopoExplorer ex1(newshapeEdge1[1], ShapeType::Edge);\n\t\t\tTopoExplorer ex2(newshapeEdge1[2], ShapeType::Edge);\n\t\t\tTopoEdge e0 = static_cast<const TopoEdge&>(ex0.Value());\n\t\t\tTopoEdge e1 = static_cast<const TopoEdge&>(ex1.Value());\n\t\t\tTopoEdge e2 = static_cast<const TopoEdge&>(ex2.Value());\n\t\t\tauto edge0 = NURBSAPIGetGeometry::GetCurve(e0);\n\t\t\tauto edge1 = NURBSAPIGetGeometry::GetCurve(e1);\n\t\t\tauto edge2 = NURBSAPIGetGeometry::GetCurve(e2);\n\t\t\tdouble n0 = NurbsSampleCurve(100, 0.15, edge0, bsp3);\n\t\t\tdouble n1 = NurbsSampleCurve(100, 0.15, edge1, bsp1);\n\t\t\tCHECK(n0 < 0.2);\n\t\t\tCHECK(n1 < 0.2);\n\t\t\tGlobalProperty g;\n\t\t\tbsp1->IncreaseDegree(11);\n\t\t\tbsp2->IncreaseDegree(11);\n\t\t\tbsp3->IncreaseDegree(11);\n\t\t\tauto bsp5 = NURBSAPISweep2::SweepTwoRails(bsp1, bsp2, bsp3);\n\t\t\tCHECK(IsCurveOnSurf(1000, 0.2, bsp1, bsp5[0], 0.1));\n\t\t\tCHECK(IsCurveOnSurf(1000, 0.2, bsp3, bsp5[0], 0.1));\n\t\t\tdouble bsp5s = GetSurfaceProperties(MakeFace(bsp5[0], 0.0), g, true, true);\n\t\t\tdouble bsp4s = GetSurfaceProperties(MakeFace(bsp4[0], 0.0), g, true, true);\n\t\t\tdouble bsp5v = GetVolumeProperties(MakeFace(bsp5[0], 0.0), g, true, true);\n\t\t\tdouble bsp4v = GetVolumeProperties(MakeFace(bsp4[0], 0.0), g, true, true);\n\t\t\tCHECK(bsp5s == Approx(bsp4s).margin(0.02));\n\t\t\tCHECK(bsp5v == Approx(bsp4v).margin(0.02));\n\t\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static std::vector<std::shared_ptr<Geom3BSplineSurface>> SweepOneRail( const std::vector<NURBSCurveSection>& profile, const std::shared_ptr<Geom3BSplineCurve>& spine, double spineRefParam, const std::vector<std::pair<int, double>>& spineCorrParams, bool isClosedSweep, bool isAutoTwist),\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeFace.hpp>\n#include <nurbs/NURBSAPIConvert.hpp>\n#include <topology/TopoTool.hpp>\n#include <nurbs/NURBSAPIExplicitSweep.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <nurbs/NURBSAPISweep.hpp>\n#include<catch.hpp>\n#include<testHelper.h>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeFace.hpp>\n#include <nurbs/NURBSAPIConvert.hpp>\n#include <topology/TopoTool.hpp>\n#include <nurbs/NURBSAPIExplicitSweep.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <nurbs/NURBSAPISweep.hpp>\n;\n\tSECTION(\"TestSweepMoreover1()\")\n\t{\n\t\tstd::string filedir = INPUT_PATH_PREFIX \"/TestNURBS/TestSweepMoreover1-2/\";\n\t\tauto spine = ReadBRepCurve(filedir + \"spine.brep\");\n\t\tstd::vector<NURBSCurveSection> profiles;\n\t\tfor (int i = 1; i <= 4; i++)\n\t\t{\n\t\t\tauto p = ReadBRepCurve(filedir + \"profile\" + std::to_string(i) + \".brep\");\n\t\t\tp->SetPeriodic();\n\t\t\tCHECK(OCCTIO::OCCTTool::Write(MakeEdge(p), OUTPUT_PATH_PREFIX \"TestSweepMoreover1_profile\" + std::to_string(i) + \".brep\"));\n\t\t\tprofiles.push_back(NURBSCurveSection(p));\n\t\t}\n\t\tCHECK(OCCTIO::OCCTTool::Write(MakeEdge(spine), OUTPUT_PATH_PREFIX \"TestSweepMoreover1_spine.brep\"));\n\t\tbool isClosedSweep = true;\n\t\tbool isAutoTwist = true;\n\t\tstd::vector<std::pair<int, double>> corrParams;\n\t\tauto surfaces = NURBSAPISweep::SweepOneRail(profiles, spine, 0.1, corrParams, isClosedSweep, isAutoTwist);\n\t\tstd::shared_ptr<Geom3BSplineSurface> result = surfaces[0];\n\t\tCHECK(OCCTIO::OCCTTool::Write(MakeFace(result, 0.0), OUTPUT_PATH_PREFIX \"TestSweepMoreover2_surface.brep\"));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static std::vector<std::shared_ptr<Geom3BSplineSurface>> SweepOneRail( const std::shared_ptr<Geom3BSplineCurve>& profile, const std::shared_ptr<Geom3BSplineCurve>& spine, double spineParam, bool isParallel),\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeFace.hpp>\n#include <nurbs/NURBSAPIConvert.hpp>\n#include <topology/TopoTool.hpp>\n#include <nurbs/NURBSAPIExplicitSweep.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <nurbs/NURBSAPISweep.hpp>\n#include<catch.hpp>\n#include<testHelper.h>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeFace.hpp>\n#include <nurbs/NURBSAPIConvert.hpp>\n#include <topology/TopoTool.hpp>\n#include <nurbs/NURBSAPIExplicitSweep.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <nurbs/NURBSAPISweep.hpp>\n;\n\tSECTION(\"TestSweepMoreover1()\")\n\t{\n\t\tstd::string filedir = INPUT_PATH_PREFIX \"/TestNURBS/TestSweepMoreover1-2/\";\n\t\tauto spine = ReadBRepCurve(filedir + \"spine.brep\");\n\t\tstd::vector<NURBSCurveSection> profiles;\n\t\tfor (int i = 1; i <= 4; i++)\n\t\t{\n\t\t\tauto p = ReadBRepCurve(filedir + \"profile\" + std::to_string(i) + \".brep\");\n\t\t\tp->SetPeriodic();\n\t\t\tCHECK(OCCTIO::OCCTTool::Write(MakeEdge(p), OUTPUT_PATH_PREFIX \"TestSweepMoreover1_profile\" + std::to_string(i) + \".brep\"));\n\t\t\tprofiles.push_back(NURBSCurveSection(p));\n\t\t}\n\t\tCHECK(OCCTIO::OCCTTool::Write(MakeEdge(spine), OUTPUT_PATH_PREFIX \"TestSweepMoreover1_spine.brep\"));\n\t\tbool isClosedSweep = true;\n\t\tbool isAutoTwist = true;\n\t\tstd::vector<std::pair<int, double>> corrParams;\n\t\tauto surfaces = NURBSAPISweep::SweepOneRail(profiles, spine, 0.1, corrParams, isClosedSweep, isAutoTwist);\n\t\tstd::shared_ptr<Geom3BSplineSurface> result = surfaces[0];\n\t\tCHECK(OCCTIO::OCCTTool::Write(MakeFace(result, 0.0), OUTPUT_PATH_PREFIX \"TestSweepMoreover2_surface.brep\"));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static std::vector<std::shared_ptr<Geom3BSplineSurface>> SweepOneRail( const std::shared_ptr<Geom3BSplineCurve>& profile, const std::shared_ptr<Geom3BSplineCurve>& spine, bool isParallel),\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeFace.hpp>\n#include <nurbs/NURBSAPIConvert.hpp>\n#include <topology/TopoTool.hpp>\n#include <nurbs/NURBSAPIExplicitSweep.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <nurbs/NURBSAPISweep.hpp>\n#include<catch.hpp>\n#include<testHelper.h>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeFace.hpp>\n#include <nurbs/NURBSAPIConvert.hpp>\n#include <topology/TopoTool.hpp>\n#include <nurbs/NURBSAPIExplicitSweep.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <nurbs/NURBSAPISweep.hpp>\n;\n\tSECTION(\"TestSweepMoreover2()\")\n\t{\n\t\tstd::string filedir = INPUT_PATH_PREFIX \"/TestNURBS/TestSweepMoreover2/\";\n\t\tauto spine = ReadBRepCurve(filedir + \"spine.brep\");\n\t\tauto profile = ReadBRepCurve(filedir + \"profile.brep\");\n\t\tCHECK(OCCTIO::OCCTTool::Write(MakeEdge(spine), OUTPUT_PATH_PREFIX \"TestSweepMoreover2_spine.brep\"));\n\t\tCHECK(OCCTIO::OCCTTool::Write(MakeEdge(profile), OUTPUT_PATH_PREFIX \"TestSweepMoreover2_spine.brep\"));\n\t\tauto surfaces = NURBSAPISweep::SweepOneRail(profile, spine, false);\n\t\tstd::shared_ptr<Geom3BSplineSurface> result = surfaces[0];\n\t\tCHECK(OCCTIO::OCCTTool::Write(MakeFace(result, 0.0), OUTPUT_PATH_PREFIX \"TestSweepMoreover2_surface.brep\"));\n\t\tCHECK(IsCurveOnSurf(100, 0.1, profile, surfaces[0], 0.01));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static std::vector<std::shared_ptr<Geom3BSplineSurface>> SweepOneRail( const std::vector<NURBSCurveSection>& profile, const std::shared_ptr<Geom3BSplineCurve>& spine, double spineRefParam, const std::vector<std::pair<int, double>>& spineCorrParams, bool isClosedSweep, bool isAutoTwist),\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <filesystem>\n#include <fstream>\n#include <random>\n#include <sstream>\n#include <nurbs/NURBSAPIGetGeometry.hpp>\n#include <nurbs/NURBSAPIConicalSweep.hpp>\n#include <boolean/BoolBRepCut.hpp>\n#include <common/CartesianCoordinateSystem.hpp>\n#include <common/IndexMap.hpp>\n#include <common/QuaternionT.hpp>\n#include <geomAlgo/LawBSpline.hpp>\n#include <geomAlgo/LawConstant.hpp>\n#include <nurbs/NURBSAPISmooth.hpp>\n#include <geomAlgo/MakeConic2FromConstraints.hpp>\n#include <geometry/Adaptor3CurveOnSurface.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/AdaptorGeom3Surface.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2Circle.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/Geom2Hyperbola.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3BSplineCurve.hpp>\n#include <geometry/Geom3BSplineSurface.hpp>\n#include <geometry/Geom3Circle.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\n#include <geometry/Geom3Plane.hpp>\n#include <geometry/Geom3SphericalSurface.hpp>\n#include <geometry/Geom3Surface.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include <geometry/Geom3TrimmedSurface.hpp>\n#include <geometry/GeomAPIExtremaCurveCurve3.hpp>\n#include <geometry/GeomAPIProjectPointOnCurve2.hpp>\n#include <geometry/GeomAPIProjectPointOnCurve3.hpp>\n#include <geometry/GeomAPIProjectPointOnSurface.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/GlobalProperty.hpp>\n#include <healing/ShapeFixTool.hpp>\n#include <io/STLTool.hpp>\n#include <math/Sphere.hpp>\n#include <math/TriangularMesh.hpp>\n#include <modeling/CopyShape.hpp>\n#include <modeling/MakeBox.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeFace.hpp>\n#include <modeling/MakePrism.hpp>\n#include <modeling/MakeRevol.hpp>\n#include <modeling/MakeShapeTool.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <modeling/MakeWire.hpp>\n#include <modeling/TransformShape.hpp>\n#include <nurbs/NURBSAPIApprox.hpp>\n#include <nurbs/NURBSAPIBuildCurve.hpp>\n#include <nurbs/NURBSAPICircularSweep.hpp>\n#include <nurbs/NURBSAPIConvert.hpp>\n#include <nurbs/NURBSAPICurveNetworkSurface.hpp>\n#include <nurbs/NURBSAPIExplicitSweep.hpp>\n#include <nurbs/NURBSAPIExplode.hpp>\n#include <nurbs/NURBSAPIExtend.hpp>\n#include <nurbs/NURBSAPIInterpolate.hpp>\n#include <nurbs/NURBSAPIJoin.hpp>\n#include <nurbs/NURBSAPILinearSweep.hpp>\n#include <nurbs/NURBSAPILoft.hpp>\n#include <nurbs/NURBSAPIMakeNURBSFromBoundaries.hpp>\n#include <nurbs/NURBSAPIMatch.hpp>\n#include <nurbs/NURBSAPIModifyEndToPlane.hpp>\n#include <nurbs/NURBSAPIOffsetCurveOnSurface.hpp>\n#include <nurbs/NURBSAPIProject.hpp>\n#include <nurbs/NURBSAPIRebuild.hpp>\n#include <nurbs/NURBSAPIReplaceEdge.hpp>\n#include <nurbs/NURBSAPISweep.hpp>\n#include <nurbs/NURBSAPISweep2.hpp>\n#include <nurbs/NURBSAPISweepRotation.hpp>\n#include <nurbs/NURBSAPITrim.hpp>\n#include <nurbs/NURBSAPIUntrim.hpp>\n#include <nurbs/NURBSLinearSweepWithDraftDirectionLength.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <offset/MakePipe.hpp>\n#include <offset/MakePipeShell.hpp>\n#include <topology/BRepAdaptorCurve2.hpp>\n#include <topology/BRepAdaptorCurve3.hpp>\n#include <topology/BRepAdaptorSurface.hpp>\n#include <topology/BRepGlobalProperty.hpp>\n#include <topology/BRepTool.hpp>\n#include <topology/TopoBuilder.hpp>\n#include <topology/TopoCompound.hpp>\n#include <topology/TopoEdge.hpp>\n#include <topology/TopoExplorer.hpp>\n#include <topology/TopoExplorerTool.hpp>\n#include <topology/TopoFace.hpp>\n#include <topology/TopoShape.hpp>\n#include <topology/TopoShell.hpp>\n#include <topology/TopoTool.hpp>\n#include <topology/TopoVertex.hpp>\n#include <topology/TopoWire.hpp>\n#include <topology/WireExplorer.hpp>\n#include <topomesh/BRepMeshIncrementalMesh.hpp>\n#include <nurbs/NURBSAPIBlend.hpp>\n#include <topology/BRepExtremaDistShapeShape.hpp>\n#include <math/LineT.hpp>\n#include <hatch/BRepClassificationTools.hpp>\nusing namespace AMCAX;\nnamespace\n{\n\tstd::shared_ptr<Geom3BSplineCurve> CurveChooser(const int id, const std::shared_ptr<Geom3BSplineCurve>& curve0, const std::shared_ptr<Geom3BSplineCurve>& curve1, const std::shared_ptr<Geom3BSplineCurve>& curve2)\n\t{\n\t\tstd::shared_ptr<Geom3BSplineCurve> result;\n\t\tswitch (id)\n\t\t{\n\t\tcase 0:\n\t\t{\n\t\t\tresult = curve0;\n\t\t\tbreak;\n\t\t}\n\t\tcase 1:\n\t\t{\n\t\t\tresult = curve1;\n\t\t\tbreak;\n\t\t}\n\t\tcase 2:\n\t\t{\n\t\t\tresult = curve2;\n\t\t\tbreak;\n\t\t}\n\t\t}\n\t\treturn result;\n\t}\n}\t\t\nGlobalProperty g;\n#include<catch.hpp>\n#include<testHelper.h>\n#include <filesystem>\n#include <fstream>\n#include <random>\n#include <sstream>\n#include <nurbs/NURBSAPIGetGeometry.hpp>\n#include <nurbs/NURBSAPIConicalSweep.hpp>\n#include <boolean/BoolBRepCut.hpp>\n#include <common/CartesianCoordinateSystem.hpp>\n#include <common/IndexMap.hpp>\n#include <common/QuaternionT.hpp>\n#include <geomAlgo/LawBSpline.hpp>\n#include <geomAlgo/LawConstant.hpp>\n#include <nurbs/NURBSAPISmooth.hpp>\n#include <geomAlgo/MakeConic2FromConstraints.hpp>\n#include <geometry/Adaptor3CurveOnSurface.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/AdaptorGeom3Surface.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2Circle.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/Geom2Hyperbola.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3BSplineCurve.hpp>\n#include <geometry/Geom3BSplineSurface.hpp>\n#include <geometry/Geom3Circle.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\n#include <geometry/Geom3Plane.hpp>\n#include <geometry/Geom3SphericalSurface.hpp>\n#include <geometry/Geom3Surface.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include <geometry/Geom3TrimmedSurface.hpp>\n#include <geometry/GeomAPIExtremaCurveCurve3.hpp>\n#include <geometry/GeomAPIProjectPointOnCurve2.hpp>\n#include <geometry/GeomAPIProjectPointOnCurve3.hpp>\n#include <geometry/GeomAPIProjectPointOnSurface.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/GlobalProperty.hpp>\n#include <healing/ShapeFixTool.hpp>\n#include <io/STLTool.hpp>\n#include <math/Sphere.hpp>\n#include <math/TriangularMesh.hpp>\n#include <modeling/CopyShape.hpp>\n#include <modeling/MakeBox.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeFace.hpp>\n#include <modeling/MakePrism.hpp>\n#include <modeling/MakeRevol.hpp>\n#include <modeling/MakeShapeTool.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <modeling/MakeWire.hpp>\n#include <modeling/TransformShape.hpp>\n#include <nurbs/NURBSAPIApprox.hpp>\n#include <nurbs/NURBSAPIBuildCurve.hpp>\n#include <nurbs/NURBSAPICircularSweep.hpp>\n#include <nurbs/NURBSAPIConvert.hpp>\n#include <nurbs/NURBSAPICurveNetworkSurface.hpp>\n#include <nurbs/NURBSAPIExplicitSweep.hpp>\n#include <nurbs/NURBSAPIExplode.hpp>\n#include <nurbs/NURBSAPIExtend.hpp>\n#include <nurbs/NURBSAPIInterpolate.hpp>\n#include <nurbs/NURBSAPIJoin.hpp>\n#include <nurbs/NURBSAPILinearSweep.hpp>\n#include <nurbs/NURBSAPILoft.hpp>\n#include <nurbs/NURBSAPIMakeNURBSFromBoundaries.hpp>\n#include <nurbs/NURBSAPIMatch.hpp>\n#include <nurbs/NURBSAPIModifyEndToPlane.hpp>\n#include <nurbs/NURBSAPIOffsetCurveOnSurface.hpp>\n#include <nurbs/NURBSAPIProject.hpp>\n#include <nurbs/NURBSAPIRebuild.hpp>\n#include <nurbs/NURBSAPIReplaceEdge.hpp>\n#include <nurbs/NURBSAPISweep.hpp>\n#include <nurbs/NURBSAPISweep2.hpp>\n#include <nurbs/NURBSAPISweepRotation.hpp>\n#include <nurbs/NURBSAPITrim.hpp>\n#include <nurbs/NURBSAPIUntrim.hpp>\n#include <nurbs/NURBSLinearSweepWithDraftDirectionLength.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <offset/MakePipe.hpp>\n#include <offset/MakePipeShell.hpp>\n#include <topology/BRepAdaptorCurve2.hpp>\n#include <topology/BRepAdaptorCurve3.hpp>\n#include <topology/BRepAdaptorSurface.hpp>\n#include <topology/BRepGlobalProperty.hpp>\n#include <topology/BRepTool.hpp>\n#include <topology/TopoBuilder.hpp>\n#include <topology/TopoCompound.hpp>\n#include <topology/TopoEdge.hpp>\n#include <topology/TopoExplorer.hpp>\n#include <topology/TopoExplorerTool.hpp>\n#include <topology/TopoFace.hpp>\n#include <topology/TopoShape.hpp>\n#include <topology/TopoShell.hpp>\n#include <topology/TopoTool.hpp>\n#include <topology/TopoVertex.hpp>\n#include <topology/TopoWire.hpp>\n#include <topology/WireExplorer.hpp>\n#include <topomesh/BRepMeshIncrementalMesh.hpp>\n#include <nurbs/NURBSAPIBlend.hpp>\n#include <topology/BRepExtremaDistShapeShape.hpp>\n#include <math/LineT.hpp>\n#include <hatch/BRepClassificationTools.hpp>\nusing namespace AMCAX;\nnamespace\n{\n\tstd::shared_ptr<Geom3BSplineCurve> CurveChooser(const int id, const std::shared_ptr<Geom3BSplineCurve>& curve0, const std::shared_ptr<Geom3BSplineCurve>& curve1, const std::shared_ptr<Geom3BSplineCurve>& curve2)\n\t{\n\t\tstd::shared_ptr<Geom3BSplineCurve> result;\n\t\tswitch (id)\n\t\t{\n\t\tcase 0:\n\t\t{\n\t\t\tresult = curve0;\n\t\t\tbreak;\n\t\t}\n\t\tcase 1:\n\t\t{\n\t\t\tresult = curve1;\n\t\t\tbreak;\n\t\t}\n\t\tcase 2:\n\t\t{\n\t\t\tresult = curve2;\n\t\t\tbreak;\n\t\t}\n\t\t}\n\t\treturn result;\n\t}\n;\n\tSECTION(\"TestSweepTest1()\")\n\t{\n\t\tstd::shared_ptr<Geom3BSplineCurve> bsp1, bsp2;\n\t\t{\n\t\t\tint deg = 3;\n\t\t\tstd::vector<Point3> poles;\n\t\t\tpoles.push_back(Point3(0.0, -1.0, 0.0));\n\t\t\tpoles.push_back(Point3(0.7, -0.7, 0.0));\n\t\t\tpoles.push_back(Point3(1.0, -0.3, 0.0));\n\t\t\tpoles.push_back(Point3(1.2, 0.0, 0.0));\n\t\t\tpoles.push_back(Point3(2.0, 0.3, 0.0));\n\t\t\tpoles.push_back(Point3(0.7, 1.7, 0.0));\n\t\t\tpoles.push_back(Point3(0.0, 1.0, 0.0));\n\t\t\tpoles.push_back(Point3(-0.7, 1.7, 0.0));\n\t\t\tpoles.push_back(Point3(-2.0, 0.3, 0.0));\n\t\t\tpoles.push_back(Point3(-1.2, 0.0, 0.0));\n\t\t\tpoles.push_back(Point3(-1.0, -0.3, 0.0));\n\t\t\tpoles.push_back(Point3(-0.7, -0.7, 0.0));\n\t\t\tpoles.push_back(Point3(0.0, -1.0, 0.0));\n\t\t\tstd::vector<double> weights;\n\t\t\tweights.push_back(1.0);\n\t\t\tweights.push_back(1.2);\n\t\t\tweights.push_back(1.3);\n\t\t\tweights.push_back(1.4);\n\t\t\tweights.push_back(1.5);\n\t\t\tweights.push_back(1.6);\n\t\t\tweights.push_back(1.7);\n\t\t\tweights.push_back(1.8);\n\t\t\tweights.push_back(1.9);\n\t\t\tweights.push_back(1.0);\n\t\t\tweights.push_back(1.1);\n\t\t\tweights.push_back(1.3);\n\t\t\tweights.push_back(1.0);\n\t\t\tint nknots = static_cast<int>(poles.size()) - deg + 1;\n\t\t\tstd::vector<double> knots(nknots);\n\t\t\tfor (int i = 0; i < nknots; i++)\n\t\t\t{\n\t\t\t\tknots[i] = (double)i / (double)(nknots - 1.0);\n\t\t\t}\n\t\t\tstd::vector<int> mults(nknots, 1);\n\t\t\tmults.front() = 4;\n\t\t\tmults.back() = 4;\n\t\t\tbsp1 = std::make_shared<Geom3BSplineCurve>(poles, weights, knots, mults, deg);\n\t\t\tCHECK(OCCTIO::OCCTTool::Write(MakeEdge(bsp1), OUTPUT_PATH_PREFIX \"TestSweepTest1_bsp1.brep\"));\n\t\t}\n\t\t{\n\t\t\tstd::vector<Point3> spinePoles;\n\t\t\tstd::vector<double> spineKnots(4);\n\t\t\tstd::vector<int> spineMults(4, 1);\n\t\t\tspinePoles.push_back(Point3(0.0, 1.0, 0.0));\n\t\t\tspinePoles.push_back(Point3(-0.1, -0.8, 1.0));\n\t\t\tspinePoles.push_back(Point3(0.1, -0.5, 2.0));\n\t\t\tspinePoles.push_back(Point3(0.2, -0.7, 3.0));\n\t\t\tspinePoles.push_back(Point3(0.1, -0.9, 3.5));\n\t\t\tspinePoles.push_back(Point3(0.0, -1.1, 4.5));\n\t\t\tstd::vector<double> weights;\n\t\t\tweights.push_back(1.4);\n\t\t\tweights.push_back(1.7);\n\t\t\tweights.push_back(1.1);\n\t\t\tweights.push_back(1.3);\n\t\t\tweights.push_back(1.0);\n\t\t\tweights.push_back(0.9);\n\t\t\tspineKnots[0] = 0;\n\t\t\tspineKnots[1] = 1.0 / 3.0;\n\t\t\tspineKnots[2] = 2.0 / 3.0;\n\t\t\tspineKnots[3] = 1;\n\t\t\tspineMults.front() = 4;\n\t\t\tspineMults.back() = 4;\n\t\t\tbsp2 = std::make_shared<Geom3BSplineCurve>(spinePoles, weights, spineKnots, spineMults, 3);\n\t\t\tCHECK(OCCTIO::OCCTTool::Write(MakeEdge(bsp2), OUTPUT_PATH_PREFIX \"TestSweepTest1_bsp2.brep\"));\n\t\t}\n\t\tbool isParallel = false;\n\t\tauto bsp3 = NURBSAPISweep::SweepOneRail(bsp1, bsp2, isParallel);\n\t\tfor (int i = 0; i < static_cast<int>(bsp3.size()); i++)\n\t\t{\n\t\t\tstd::string filename = OUTPUT_PATH_PREFIX \"TestSweepTest1_result\" + std::to_string(i) + \".brep\";\n\t\t\tCHECK(OCCTIO::OCCTTool::Write(MakeFace(bsp3[i], 0.0), filename.c_str()));\n\t\t}\n\t\tCHECK(bsp3.size() == 1);\n\t\tAMCAX::BRepExtremaDistShapeShape len(MakeEdge(bsp1), MakeFace(bsp3[0], 0.0));\n\t\tCHECK(len.Value() == Approx(0.0).margin(0.1));\n\t\tCHECK(IsCurveOnSurf(1000, 0.2, bsp1, bsp3[0], 0.2));\n\t\tbsp2->IncreaseDegree(25);\n\t\tbsp1->IncreaseDegree(25);\n\t\tauto bsp4 = NURBSAPISweep::SweepOneRail(bsp1, bsp2, isParallel);\n\t\tCHECK(OCCTIO::OCCTTool::Write(MakeFace(bsp4[0], 0.0), OUTPUT_PATH_PREFIX \"TestSweepTest1_degree25result.brep\"));\n\t\tAMCAX::BRepExtremaDistShapeShape len1(MakeEdge(bsp1), MakeFace(bsp4[0], 0.0));\n\t\tCHECK(len1.Value() == Approx(0.0).margin(0.1));\n\t\tCHECK(IsCurveOnSurf(1000, 0.2, bsp1, bsp4[0], 0.2));\n\t\tdouble bsp3s = GetSurfaceProperties(MakeFace(bsp3[0], 0.0), g, true, true);\n\t\tdouble bsp4s = GetSurfaceProperties(MakeFace(bsp4[0], 0.0), g, true, true);\n\t\tdouble bsp3v = GetVolumeProperties(MakeFace(bsp3[0], 0.0), g, true, true);\n\t\tdouble bsp4v = GetVolumeProperties(MakeFace(bsp4[0], 0.0), g, true, true);\n\t\tCHECK(bsp3s == Approx(bsp4s).margin(0.02));\n\t\tCHECK(bsp3v == Approx(bsp4v).margin(0.02));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static std::vector<std::shared_ptr<Geom3BSplineSurface>> SweepOneRail( const std::shared_ptr<Geom3BSplineCurve>& profile, const std::shared_ptr<Geom3BSplineCurve>& spine, double spineParam, bool isParallel),\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <filesystem>\n#include <fstream>\n#include <random>\n#include <sstream>\n#include <nurbs/NURBSAPIGetGeometry.hpp>\n#include <nurbs/NURBSAPIConicalSweep.hpp>\n#include <boolean/BoolBRepCut.hpp>\n#include <common/CartesianCoordinateSystem.hpp>\n#include <common/IndexMap.hpp>\n#include <common/QuaternionT.hpp>\n#include <geomAlgo/LawBSpline.hpp>\n#include <geomAlgo/LawConstant.hpp>\n#include <nurbs/NURBSAPISmooth.hpp>\n#include <geomAlgo/MakeConic2FromConstraints.hpp>\n#include <geometry/Adaptor3CurveOnSurface.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/AdaptorGeom3Surface.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2Circle.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/Geom2Hyperbola.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3BSplineCurve.hpp>\n#include <geometry/Geom3BSplineSurface.hpp>\n#include <geometry/Geom3Circle.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\n#include <geometry/Geom3Plane.hpp>\n#include <geometry/Geom3SphericalSurface.hpp>\n#include <geometry/Geom3Surface.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include <geometry/Geom3TrimmedSurface.hpp>\n#include <geometry/GeomAPIExtremaCurveCurve3.hpp>\n#include <geometry/GeomAPIProjectPointOnCurve2.hpp>\n#include <geometry/GeomAPIProjectPointOnCurve3.hpp>\n#include <geometry/GeomAPIProjectPointOnSurface.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/GlobalProperty.hpp>\n#include <healing/ShapeFixTool.hpp>\n#include <io/STLTool.hpp>\n#include <math/Sphere.hpp>\n#include <math/TriangularMesh.hpp>\n#include <modeling/CopyShape.hpp>\n#include <modeling/MakeBox.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeFace.hpp>\n#include <modeling/MakePrism.hpp>\n#include <modeling/MakeRevol.hpp>\n#include <modeling/MakeShapeTool.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <modeling/MakeWire.hpp>\n#include <modeling/TransformShape.hpp>\n#include <nurbs/NURBSAPIApprox.hpp>\n#include <nurbs/NURBSAPIBuildCurve.hpp>\n#include <nurbs/NURBSAPICircularSweep.hpp>\n#include <nurbs/NURBSAPIConvert.hpp>\n#include <nurbs/NURBSAPICurveNetworkSurface.hpp>\n#include <nurbs/NURBSAPIExplicitSweep.hpp>\n#include <nurbs/NURBSAPIExplode.hpp>\n#include <nurbs/NURBSAPIExtend.hpp>\n#include <nurbs/NURBSAPIInterpolate.hpp>\n#include <nurbs/NURBSAPIJoin.hpp>\n#include <nurbs/NURBSAPILinearSweep.hpp>\n#include <nurbs/NURBSAPILoft.hpp>\n#include <nurbs/NURBSAPIMakeNURBSFromBoundaries.hpp>\n#include <nurbs/NURBSAPIMatch.hpp>\n#include <nurbs/NURBSAPIModifyEndToPlane.hpp>\n#include <nurbs/NURBSAPIOffsetCurveOnSurface.hpp>\n#include <nurbs/NURBSAPIProject.hpp>\n#include <nurbs/NURBSAPIRebuild.hpp>\n#include <nurbs/NURBSAPIReplaceEdge.hpp>\n#include <nurbs/NURBSAPISweep.hpp>\n#include <nurbs/NURBSAPISweep2.hpp>\n#include <nurbs/NURBSAPISweepRotation.hpp>\n#include <nurbs/NURBSAPITrim.hpp>\n#include <nurbs/NURBSAPIUntrim.hpp>\n#include <nurbs/NURBSLinearSweepWithDraftDirectionLength.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <offset/MakePipe.hpp>\n#include <offset/MakePipeShell.hpp>\n#include <topology/BRepAdaptorCurve2.hpp>\n#include <topology/BRepAdaptorCurve3.hpp>\n#include <topology/BRepAdaptorSurface.hpp>\n#include <topology/BRepGlobalProperty.hpp>\n#include <topology/BRepTool.hpp>\n#include <topology/TopoBuilder.hpp>\n#include <topology/TopoCompound.hpp>\n#include <topology/TopoEdge.hpp>\n#include <topology/TopoExplorer.hpp>\n#include <topology/TopoExplorerTool.hpp>\n#include <topology/TopoFace.hpp>\n#include <topology/TopoShape.hpp>\n#include <topology/TopoShell.hpp>\n#include <topology/TopoTool.hpp>\n#include <topology/TopoVertex.hpp>\n#include <topology/TopoWire.hpp>\n#include <topology/WireExplorer.hpp>\n#include <topomesh/BRepMeshIncrementalMesh.hpp>\n#include <nurbs/NURBSAPIBlend.hpp>\n#include <topology/BRepExtremaDistShapeShape.hpp>\n#include <math/LineT.hpp>\n#include <hatch/BRepClassificationTools.hpp>\nusing namespace AMCAX;\nnamespace\n{\n\tstd::shared_ptr<Geom3BSplineCurve> CurveChooser(const int id, const std::shared_ptr<Geom3BSplineCurve>& curve0, const std::shared_ptr<Geom3BSplineCurve>& curve1, const std::shared_ptr<Geom3BSplineCurve>& curve2)\n\t{\n\t\tstd::shared_ptr<Geom3BSplineCurve> result;\n\t\tswitch (id)\n\t\t{\n\t\tcase 0:\n\t\t{\n\t\t\tresult = curve0;\n\t\t\tbreak;\n\t\t}\n\t\tcase 1:\n\t\t{\n\t\t\tresult = curve1;\n\t\t\tbreak;\n\t\t}\n\t\tcase 2:\n\t\t{\n\t\t\tresult = curve2;\n\t\t\tbreak;\n\t\t}\n\t\t}\n\t\treturn result;\n\t}\n}\t\t\nGlobalProperty g;\n#include<catch.hpp>\n#include<testHelper.h>\n#include <filesystem>\n#include <fstream>\n#include <random>\n#include <sstream>\n#include <nurbs/NURBSAPIGetGeometry.hpp>\n#include <nurbs/NURBSAPIConicalSweep.hpp>\n#include <boolean/BoolBRepCut.hpp>\n#include <common/CartesianCoordinateSystem.hpp>\n#include <common/IndexMap.hpp>\n#include <common/QuaternionT.hpp>\n#include <geomAlgo/LawBSpline.hpp>\n#include <geomAlgo/LawConstant.hpp>\n#include <nurbs/NURBSAPISmooth.hpp>\n#include <geomAlgo/MakeConic2FromConstraints.hpp>\n#include <geometry/Adaptor3CurveOnSurface.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/AdaptorGeom3Surface.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2Circle.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/Geom2Hyperbola.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3BSplineCurve.hpp>\n#include <geometry/Geom3BSplineSurface.hpp>\n#include <geometry/Geom3Circle.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\n#include <geometry/Geom3Plane.hpp>\n#include <geometry/Geom3SphericalSurface.hpp>\n#include <geometry/Geom3Surface.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include <geometry/Geom3TrimmedSurface.hpp>\n#include <geometry/GeomAPIExtremaCurveCurve3.hpp>\n#include <geometry/GeomAPIProjectPointOnCurve2.hpp>\n#include <geometry/GeomAPIProjectPointOnCurve3.hpp>\n#include <geometry/GeomAPIProjectPointOnSurface.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/GlobalProperty.hpp>\n#include <healing/ShapeFixTool.hpp>\n#include <io/STLTool.hpp>\n#include <math/Sphere.hpp>\n#include <math/TriangularMesh.hpp>\n#include <modeling/CopyShape.hpp>\n#include <modeling/MakeBox.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeFace.hpp>\n#include <modeling/MakePrism.hpp>\n#include <modeling/MakeRevol.hpp>\n#include <modeling/MakeShapeTool.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <modeling/MakeWire.hpp>\n#include <modeling/TransformShape.hpp>\n#include <nurbs/NURBSAPIApprox.hpp>\n#include <nurbs/NURBSAPIBuildCurve.hpp>\n#include <nurbs/NURBSAPICircularSweep.hpp>\n#include <nurbs/NURBSAPIConvert.hpp>\n#include <nurbs/NURBSAPICurveNetworkSurface.hpp>\n#include <nurbs/NURBSAPIExplicitSweep.hpp>\n#include <nurbs/NURBSAPIExplode.hpp>\n#include <nurbs/NURBSAPIExtend.hpp>\n#include <nurbs/NURBSAPIInterpolate.hpp>\n#include <nurbs/NURBSAPIJoin.hpp>\n#include <nurbs/NURBSAPILinearSweep.hpp>\n#include <nurbs/NURBSAPILoft.hpp>\n#include <nurbs/NURBSAPIMakeNURBSFromBoundaries.hpp>\n#include <nurbs/NURBSAPIMatch.hpp>\n#include <nurbs/NURBSAPIModifyEndToPlane.hpp>\n#include <nurbs/NURBSAPIOffsetCurveOnSurface.hpp>\n#include <nurbs/NURBSAPIProject.hpp>\n#include <nurbs/NURBSAPIRebuild.hpp>\n#include <nurbs/NURBSAPIReplaceEdge.hpp>\n#include <nurbs/NURBSAPISweep.hpp>\n#include <nurbs/NURBSAPISweep2.hpp>\n#include <nurbs/NURBSAPISweepRotation.hpp>\n#include <nurbs/NURBSAPITrim.hpp>\n#include <nurbs/NURBSAPIUntrim.hpp>\n#include <nurbs/NURBSLinearSweepWithDraftDirectionLength.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <offset/MakePipe.hpp>\n#include <offset/MakePipeShell.hpp>\n#include <topology/BRepAdaptorCurve2.hpp>\n#include <topology/BRepAdaptorCurve3.hpp>\n#include <topology/BRepAdaptorSurface.hpp>\n#include <topology/BRepGlobalProperty.hpp>\n#include <topology/BRepTool.hpp>\n#include <topology/TopoBuilder.hpp>\n#include <topology/TopoCompound.hpp>\n#include <topology/TopoEdge.hpp>\n#include <topology/TopoExplorer.hpp>\n#include <topology/TopoExplorerTool.hpp>\n#include <topology/TopoFace.hpp>\n#include <topology/TopoShape.hpp>\n#include <topology/TopoShell.hpp>\n#include <topology/TopoTool.hpp>\n#include <topology/TopoVertex.hpp>\n#include <topology/TopoWire.hpp>\n#include <topology/WireExplorer.hpp>\n#include <topomesh/BRepMeshIncrementalMesh.hpp>\n#include <nurbs/NURBSAPIBlend.hpp>\n#include <topology/BRepExtremaDistShapeShape.hpp>\n#include <math/LineT.hpp>\n#include <hatch/BRepClassificationTools.hpp>\nusing namespace AMCAX;\nnamespace\n{\n\tstd::shared_ptr<Geom3BSplineCurve> CurveChooser(const int id, const std::shared_ptr<Geom3BSplineCurve>& curve0, const std::shared_ptr<Geom3BSplineCurve>& curve1, const std::shared_ptr<Geom3BSplineCurve>& curve2)\n\t{\n\t\tstd::shared_ptr<Geom3BSplineCurve> result;\n\t\tswitch (id)\n\t\t{\n\t\tcase 0:\n\t\t{\n\t\t\tresult = curve0;\n\t\t\tbreak;\n\t\t}\n\t\tcase 1:\n\t\t{\n\t\t\tresult = curve1;\n\t\t\tbreak;\n\t\t}\n\t\tcase 2:\n\t\t{\n\t\t\tresult = curve2;\n\t\t\tbreak;\n\t\t}\n\t\t}\n\t\treturn result;\n\t}\n;\n\tSECTION(\"TestSweepTest1()\")\n\t{\n\t\tstd::shared_ptr<Geom3BSplineCurve> bsp1, bsp2;\n\t\t{\n\t\t\tint deg = 3;\n\t\t\tstd::vector<Point3> poles;\n\t\t\tpoles.push_back(Point3(0.0, -1.0, 0.0));\n\t\t\tpoles.push_back(Point3(0.7, -0.7, 0.0));\n\t\t\tpoles.push_back(Point3(1.0, -0.3, 0.0));\n\t\t\tpoles.push_back(Point3(1.2, 0.0, 0.0));\n\t\t\tpoles.push_back(Point3(2.0, 0.3, 0.0));\n\t\t\tpoles.push_back(Point3(0.7, 1.7, 0.0));\n\t\t\tpoles.push_back(Point3(0.0, 1.0, 0.0));\n\t\t\tpoles.push_back(Point3(-0.7, 1.7, 0.0));\n\t\t\tpoles.push_back(Point3(-2.0, 0.3, 0.0));\n\t\t\tpoles.push_back(Point3(-1.2, 0.0, 0.0));\n\t\t\tpoles.push_back(Point3(-1.0, -0.3, 0.0));\n\t\t\tpoles.push_back(Point3(-0.7, -0.7, 0.0));\n\t\t\tpoles.push_back(Point3(0.0, -1.0, 0.0));\n\t\t\tstd::vector<double> weights;\n\t\t\tweights.push_back(1.0);\n\t\t\tweights.push_back(1.2);\n\t\t\tweights.push_back(1.3);\n\t\t\tweights.push_back(1.4);\n\t\t\tweights.push_back(1.5);\n\t\t\tweights.push_back(1.6);\n\t\t\tweights.push_back(1.7);\n\t\t\tweights.push_back(1.8);\n\t\t\tweights.push_back(1.9);\n\t\t\tweights.push_back(1.0);\n\t\t\tweights.push_back(1.1);\n\t\t\tweights.push_back(1.3);\n\t\t\tweights.push_back(1.0);\n\t\t\tint nknots = static_cast<int>(poles.size()) - deg + 1;\n\t\t\tstd::vector<double> knots(nknots);\n\t\t\tfor (int i = 0; i < nknots; i++)\n\t\t\t{\n\t\t\t\tknots[i] = (double)i / (double)(nknots - 1.0);\n\t\t\t}\n\t\t\tstd::vector<int> mults(nknots, 1);\n\t\t\tmults.front() = 4;\n\t\t\tmults.back() = 4;\n\t\t\tbsp1 = std::make_shared<Geom3BSplineCurve>(poles, weights, knots, mults, deg);\n\t\t\tCHECK(OCCTIO::OCCTTool::Write(MakeEdge(bsp1), OUTPUT_PATH_PREFIX \"TestSweepTest1_bsp1.brep\"));\n\t\t}\n\t\t{\n\t\t\tstd::vector<Point3> spinePoles;\n\t\t\tstd::vector<double> spineKnots(4);\n\t\t\tstd::vector<int> spineMults(4, 1);\n\t\t\tspinePoles.push_back(Point3(0.0, 1.0, 0.0));\n\t\t\tspinePoles.push_back(Point3(-0.1, -0.8, 1.0));\n\t\t\tspinePoles.push_back(Point3(0.1, -0.5, 2.0));\n\t\t\tspinePoles.push_back(Point3(0.2, -0.7, 3.0));\n\t\t\tspinePoles.push_back(Point3(0.1, -0.9, 3.5));\n\t\t\tspinePoles.push_back(Point3(0.0, -1.1, 4.5));\n\t\t\tstd::vector<double> weights;\n\t\t\tweights.push_back(1.4);\n\t\t\tweights.push_back(1.7);\n\t\t\tweights.push_back(1.1);\n\t\t\tweights.push_back(1.3);\n\t\t\tweights.push_back(1.0);\n\t\t\tweights.push_back(0.9);\n\t\t\tspineKnots[0] = 0;\n\t\t\tspineKnots[1] = 1.0 / 3.0;\n\t\t\tspineKnots[2] = 2.0 / 3.0;\n\t\t\tspineKnots[3] = 1;\n\t\t\tspineMults.front() = 4;\n\t\t\tspineMults.back() = 4;\n\t\t\tbsp2 = std::make_shared<Geom3BSplineCurve>(spinePoles, weights, spineKnots, spineMults, 3);\n\t\t\tCHECK(OCCTIO::OCCTTool::Write(MakeEdge(bsp2), OUTPUT_PATH_PREFIX \"TestSweepTest1_bsp2.brep\"));\n\t\t}\n\t\tbool isParallel = false;\n\t\tauto bsp3 = NURBSAPISweep::SweepOneRail(bsp1, bsp2, isParallel);\n\t\tfor (int i = 0; i < static_cast<int>(bsp3.size()); i++)\n\t\t{\n\t\t\tstd::string filename = OUTPUT_PATH_PREFIX \"TestSweepTest1_result\" + std::to_string(i) + \".brep\";\n\t\t\tCHECK(OCCTIO::OCCTTool::Write(MakeFace(bsp3[i], 0.0), filename.c_str()));\n\t\t}\n\t\tCHECK(bsp3.size() == 1);\n\t\tAMCAX::BRepExtremaDistShapeShape len(MakeEdge(bsp1), MakeFace(bsp3[0], 0.0));\n\t\tCHECK(len.Value() == Approx(0.0).margin(0.1));\n\t\tCHECK(IsCurveOnSurf(1000, 0.2, bsp1, bsp3[0], 0.2));\n\t\tbsp2->IncreaseDegree(25);\n\t\tbsp1->IncreaseDegree(25);\n\t\tauto bsp4 = NURBSAPISweep::SweepOneRail(bsp1, bsp2, isParallel);\n\t\tCHECK(OCCTIO::OCCTTool::Write(MakeFace(bsp4[0], 0.0), OUTPUT_PATH_PREFIX \"TestSweepTest1_degree25result.brep\"));\n\t\tAMCAX::BRepExtremaDistShapeShape len1(MakeEdge(bsp1), MakeFace(bsp4[0], 0.0));\n\t\tCHECK(len1.Value() == Approx(0.0).margin(0.1));\n\t\tCHECK(IsCurveOnSurf(1000, 0.2, bsp1, bsp4[0], 0.2));\n\t\tdouble bsp3s = GetSurfaceProperties(MakeFace(bsp3[0], 0.0), g, true, true);\n\t\tdouble bsp4s = GetSurfaceProperties(MakeFace(bsp4[0], 0.0), g, true, true);\n\t\tdouble bsp3v = GetVolumeProperties(MakeFace(bsp3[0], 0.0), g, true, true);\n\t\tdouble bsp4v = GetVolumeProperties(MakeFace(bsp4[0], 0.0), g, true, true);\n\t\tCHECK(bsp3s == Approx(bsp4s).margin(0.02));\n\t\tCHECK(bsp3v == Approx(bsp4v).margin(0.02));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static std::vector<std::shared_ptr<Geom3BSplineSurface>> SweepOneRail( const std::shared_ptr<Geom3BSplineCurve>& profile, const std::shared_ptr<Geom3BSplineCurve>& spine, bool isParallel),\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <filesystem>\n#include <fstream>\n#include <random>\n#include <sstream>\n#include <nurbs/NURBSAPIGetGeometry.hpp>\n#include <nurbs/NURBSAPIConicalSweep.hpp>\n#include <boolean/BoolBRepCut.hpp>\n#include <common/CartesianCoordinateSystem.hpp>\n#include <common/IndexMap.hpp>\n#include <common/QuaternionT.hpp>\n#include <geomAlgo/LawBSpline.hpp>\n#include <geomAlgo/LawConstant.hpp>\n#include <nurbs/NURBSAPISmooth.hpp>\n#include <geomAlgo/MakeConic2FromConstraints.hpp>\n#include <geometry/Adaptor3CurveOnSurface.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/AdaptorGeom3Surface.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2Circle.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/Geom2Hyperbola.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3BSplineCurve.hpp>\n#include <geometry/Geom3BSplineSurface.hpp>\n#include <geometry/Geom3Circle.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\n#include <geometry/Geom3Plane.hpp>\n#include <geometry/Geom3SphericalSurface.hpp>\n#include <geometry/Geom3Surface.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include <geometry/Geom3TrimmedSurface.hpp>\n#include <geometry/GeomAPIExtremaCurveCurve3.hpp>\n#include <geometry/GeomAPIProjectPointOnCurve2.hpp>\n#include <geometry/GeomAPIProjectPointOnCurve3.hpp>\n#include <geometry/GeomAPIProjectPointOnSurface.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/GlobalProperty.hpp>\n#include <healing/ShapeFixTool.hpp>\n#include <io/STLTool.hpp>\n#include <math/Sphere.hpp>\n#include <math/TriangularMesh.hpp>\n#include <modeling/CopyShape.hpp>\n#include <modeling/MakeBox.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeFace.hpp>\n#include <modeling/MakePrism.hpp>\n#include <modeling/MakeRevol.hpp>\n#include <modeling/MakeShapeTool.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <modeling/MakeWire.hpp>\n#include <modeling/TransformShape.hpp>\n#include <nurbs/NURBSAPIApprox.hpp>\n#include <nurbs/NURBSAPIBuildCurve.hpp>\n#include <nurbs/NURBSAPICircularSweep.hpp>\n#include <nurbs/NURBSAPIConvert.hpp>\n#include <nurbs/NURBSAPICurveNetworkSurface.hpp>\n#include <nurbs/NURBSAPIExplicitSweep.hpp>\n#include <nurbs/NURBSAPIExplode.hpp>\n#include <nurbs/NURBSAPIExtend.hpp>\n#include <nurbs/NURBSAPIInterpolate.hpp>\n#include <nurbs/NURBSAPIJoin.hpp>\n#include <nurbs/NURBSAPILinearSweep.hpp>\n#include <nurbs/NURBSAPILoft.hpp>\n#include <nurbs/NURBSAPIMakeNURBSFromBoundaries.hpp>\n#include <nurbs/NURBSAPIMatch.hpp>\n#include <nurbs/NURBSAPIModifyEndToPlane.hpp>\n#include <nurbs/NURBSAPIOffsetCurveOnSurface.hpp>\n#include <nurbs/NURBSAPIProject.hpp>\n#include <nurbs/NURBSAPIRebuild.hpp>\n#include <nurbs/NURBSAPIReplaceEdge.hpp>\n#include <nurbs/NURBSAPISweep.hpp>\n#include <nurbs/NURBSAPISweep2.hpp>\n#include <nurbs/NURBSAPISweepRotation.hpp>\n#include <nurbs/NURBSAPITrim.hpp>\n#include <nurbs/NURBSAPIUntrim.hpp>\n#include <nurbs/NURBSLinearSweepWithDraftDirectionLength.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <offset/MakePipe.hpp>\n#include <offset/MakePipeShell.hpp>\n#include <topology/BRepAdaptorCurve2.hpp>\n#include <topology/BRepAdaptorCurve3.hpp>\n#include <topology/BRepAdaptorSurface.hpp>\n#include <topology/BRepGlobalProperty.hpp>\n#include <topology/BRepTool.hpp>\n#include <topology/TopoBuilder.hpp>\n#include <topology/TopoCompound.hpp>\n#include <topology/TopoEdge.hpp>\n#include <topology/TopoExplorer.hpp>\n#include <topology/TopoExplorerTool.hpp>\n#include <topology/TopoFace.hpp>\n#include <topology/TopoShape.hpp>\n#include <topology/TopoShell.hpp>\n#include <topology/TopoTool.hpp>\n#include <topology/TopoVertex.hpp>\n#include <topology/TopoWire.hpp>\n#include <topology/WireExplorer.hpp>\n#include <topomesh/BRepMeshIncrementalMesh.hpp>\n#include <nurbs/NURBSAPIBlend.hpp>\n#include <topology/BRepExtremaDistShapeShape.hpp>\n#include <math/LineT.hpp>\n#include <hatch/BRepClassificationTools.hpp>\nusing namespace AMCAX;\nnamespace\n{\n\tstd::shared_ptr<Geom3BSplineCurve> CurveChooser(const int id, const std::shared_ptr<Geom3BSplineCurve>& curve0, const std::shared_ptr<Geom3BSplineCurve>& curve1, const std::shared_ptr<Geom3BSplineCurve>& curve2)\n\t{\n\t\tstd::shared_ptr<Geom3BSplineCurve> result;\n\t\tswitch (id)\n\t\t{\n\t\tcase 0:\n\t\t{\n\t\t\tresult = curve0;\n\t\t\tbreak;\n\t\t}\n\t\tcase 1:\n\t\t{\n\t\t\tresult = curve1;\n\t\t\tbreak;\n\t\t}\n\t\tcase 2:\n\t\t{\n\t\t\tresult = curve2;\n\t\t\tbreak;\n\t\t}\n\t\t}\n\t\treturn result;\n\t}\n}\t\t\nGlobalProperty g;\n#include<catch.hpp>\n#include<testHelper.h>\n#include <filesystem>\n#include <fstream>\n#include <random>\n#include <sstream>\n#include <nurbs/NURBSAPIGetGeometry.hpp>\n#include <nurbs/NURBSAPIConicalSweep.hpp>\n#include <boolean/BoolBRepCut.hpp>\n#include <common/CartesianCoordinateSystem.hpp>\n#include <common/IndexMap.hpp>\n#include <common/QuaternionT.hpp>\n#include <geomAlgo/LawBSpline.hpp>\n#include <geomAlgo/LawConstant.hpp>\n#include <nurbs/NURBSAPISmooth.hpp>\n#include <geomAlgo/MakeConic2FromConstraints.hpp>\n#include <geometry/Adaptor3CurveOnSurface.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/AdaptorGeom3Surface.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2Circle.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/Geom2Hyperbola.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3BSplineCurve.hpp>\n#include <geometry/Geom3BSplineSurface.hpp>\n#include <geometry/Geom3Circle.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\n#include <geometry/Geom3Plane.hpp>\n#include <geometry/Geom3SphericalSurface.hpp>\n#include <geometry/Geom3Surface.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include <geometry/Geom3TrimmedSurface.hpp>\n#include <geometry/GeomAPIExtremaCurveCurve3.hpp>\n#include <geometry/GeomAPIProjectPointOnCurve2.hpp>\n#include <geometry/GeomAPIProjectPointOnCurve3.hpp>\n#include <geometry/GeomAPIProjectPointOnSurface.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/GlobalProperty.hpp>\n#include <healing/ShapeFixTool.hpp>\n#include <io/STLTool.hpp>\n#include <math/Sphere.hpp>\n#include <math/TriangularMesh.hpp>\n#include <modeling/CopyShape.hpp>\n#include <modeling/MakeBox.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeFace.hpp>\n#include <modeling/MakePrism.hpp>\n#include <modeling/MakeRevol.hpp>\n#include <modeling/MakeShapeTool.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <modeling/MakeWire.hpp>\n#include <modeling/TransformShape.hpp>\n#include <nurbs/NURBSAPIApprox.hpp>\n#include <nurbs/NURBSAPIBuildCurve.hpp>\n#include <nurbs/NURBSAPICircularSweep.hpp>\n#include <nurbs/NURBSAPIConvert.hpp>\n#include <nurbs/NURBSAPICurveNetworkSurface.hpp>\n#include <nurbs/NURBSAPIExplicitSweep.hpp>\n#include <nurbs/NURBSAPIExplode.hpp>\n#include <nurbs/NURBSAPIExtend.hpp>\n#include <nurbs/NURBSAPIInterpolate.hpp>\n#include <nurbs/NURBSAPIJoin.hpp>\n#include <nurbs/NURBSAPILinearSweep.hpp>\n#include <nurbs/NURBSAPILoft.hpp>\n#include <nurbs/NURBSAPIMakeNURBSFromBoundaries.hpp>\n#include <nurbs/NURBSAPIMatch.hpp>\n#include <nurbs/NURBSAPIModifyEndToPlane.hpp>\n#include <nurbs/NURBSAPIOffsetCurveOnSurface.hpp>\n#include <nurbs/NURBSAPIProject.hpp>\n#include <nurbs/NURBSAPIRebuild.hpp>\n#include <nurbs/NURBSAPIReplaceEdge.hpp>\n#include <nurbs/NURBSAPISweep.hpp>\n#include <nurbs/NURBSAPISweep2.hpp>\n#include <nurbs/NURBSAPISweepRotation.hpp>\n#include <nurbs/NURBSAPITrim.hpp>\n#include <nurbs/NURBSAPIUntrim.hpp>\n#include <nurbs/NURBSLinearSweepWithDraftDirectionLength.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <offset/MakePipe.hpp>\n#include <offset/MakePipeShell.hpp>\n#include <topology/BRepAdaptorCurve2.hpp>\n#include <topology/BRepAdaptorCurve3.hpp>\n#include <topology/BRepAdaptorSurface.hpp>\n#include <topology/BRepGlobalProperty.hpp>\n#include <topology/BRepTool.hpp>\n#include <topology/TopoBuilder.hpp>\n#include <topology/TopoCompound.hpp>\n#include <topology/TopoEdge.hpp>\n#include <topology/TopoExplorer.hpp>\n#include <topology/TopoExplorerTool.hpp>\n#include <topology/TopoFace.hpp>\n#include <topology/TopoShape.hpp>\n#include <topology/TopoShell.hpp>\n#include <topology/TopoTool.hpp>\n#include <topology/TopoVertex.hpp>\n#include <topology/TopoWire.hpp>\n#include <topology/WireExplorer.hpp>\n#include <topomesh/BRepMeshIncrementalMesh.hpp>\n#include <nurbs/NURBSAPIBlend.hpp>\n#include <topology/BRepExtremaDistShapeShape.hpp>\n#include <math/LineT.hpp>\n#include <hatch/BRepClassificationTools.hpp>\nusing namespace AMCAX;\nnamespace\n{\n\tstd::shared_ptr<Geom3BSplineCurve> CurveChooser(const int id, const std::shared_ptr<Geom3BSplineCurve>& curve0, const std::shared_ptr<Geom3BSplineCurve>& curve1, const std::shared_ptr<Geom3BSplineCurve>& curve2)\n\t{\n\t\tstd::shared_ptr<Geom3BSplineCurve> result;\n\t\tswitch (id)\n\t\t{\n\t\tcase 0:\n\t\t{\n\t\t\tresult = curve0;\n\t\t\tbreak;\n\t\t}\n\t\tcase 1:\n\t\t{\n\t\t\tresult = curve1;\n\t\t\tbreak;\n\t\t}\n\t\tcase 2:\n\t\t{\n\t\t\tresult = curve2;\n\t\t\tbreak;\n\t\t}\n\t\t}\n\t\treturn result;\n\t}\n;\n\tSECTION(\"TestSweepTest1()\")\n\t{\n\t\tstd::shared_ptr<Geom3BSplineCurve> bsp1, bsp2;\n\t\t{\n\t\t\tint deg = 3;\n\t\t\tstd::vector<Point3> poles;\n\t\t\tpoles.push_back(Point3(0.0, -1.0, 0.0));\n\t\t\tpoles.push_back(Point3(0.7, -0.7, 0.0));\n\t\t\tpoles.push_back(Point3(1.0, -0.3, 0.0));\n\t\t\tpoles.push_back(Point3(1.2, 0.0, 0.0));\n\t\t\tpoles.push_back(Point3(2.0, 0.3, 0.0));\n\t\t\tpoles.push_back(Point3(0.7, 1.7, 0.0));\n\t\t\tpoles.push_back(Point3(0.0, 1.0, 0.0));\n\t\t\tpoles.push_back(Point3(-0.7, 1.7, 0.0));\n\t\t\tpoles.push_back(Point3(-2.0, 0.3, 0.0));\n\t\t\tpoles.push_back(Point3(-1.2, 0.0, 0.0));\n\t\t\tpoles.push_back(Point3(-1.0, -0.3, 0.0));\n\t\t\tpoles.push_back(Point3(-0.7, -0.7, 0.0));\n\t\t\tpoles.push_back(Point3(0.0, -1.0, 0.0));\n\t\t\tstd::vector<double> weights;\n\t\t\tweights.push_back(1.0);\n\t\t\tweights.push_back(1.2);\n\t\t\tweights.push_back(1.3);\n\t\t\tweights.push_back(1.4);\n\t\t\tweights.push_back(1.5);\n\t\t\tweights.push_back(1.6);\n\t\t\tweights.push_back(1.7);\n\t\t\tweights.push_back(1.8);\n\t\t\tweights.push_back(1.9);\n\t\t\tweights.push_back(1.0);\n\t\t\tweights.push_back(1.1);\n\t\t\tweights.push_back(1.3);\n\t\t\tweights.push_back(1.0);\n\t\t\tint nknots = static_cast<int>(poles.size()) - deg + 1;\n\t\t\tstd::vector<double> knots(nknots);\n\t\t\tfor (int i = 0; i < nknots; i++)\n\t\t\t{\n\t\t\t\tknots[i] = (double)i / (double)(nknots - 1.0);\n\t\t\t}\n\t\t\tstd::vector<int> mults(nknots, 1);\n\t\t\tmults.front() = 4;\n\t\t\tmults.back() = 4;\n\t\t\tbsp1 = std::make_shared<Geom3BSplineCurve>(poles, weights, knots, mults, deg);\n\t\t\tCHECK(OCCTIO::OCCTTool::Write(MakeEdge(bsp1), OUTPUT_PATH_PREFIX \"TestSweepTest1_bsp1.brep\"));\n\t\t}\n\t\t{\n\t\t\tstd::vector<Point3> spinePoles;\n\t\t\tstd::vector<double> spineKnots(4);\n\t\t\tstd::vector<int> spineMults(4, 1);\n\t\t\tspinePoles.push_back(Point3(0.0, 1.0, 0.0));\n\t\t\tspinePoles.push_back(Point3(-0.1, -0.8, 1.0));\n\t\t\tspinePoles.push_back(Point3(0.1, -0.5, 2.0));\n\t\t\tspinePoles.push_back(Point3(0.2, -0.7, 3.0));\n\t\t\tspinePoles.push_back(Point3(0.1, -0.9, 3.5));\n\t\t\tspinePoles.push_back(Point3(0.0, -1.1, 4.5));\n\t\t\tstd::vector<double> weights;\n\t\t\tweights.push_back(1.4);\n\t\t\tweights.push_back(1.7);\n\t\t\tweights.push_back(1.1);\n\t\t\tweights.push_back(1.3);\n\t\t\tweights.push_back(1.0);\n\t\t\tweights.push_back(0.9);\n\t\t\tspineKnots[0] = 0;\n\t\t\tspineKnots[1] = 1.0 / 3.0;\n\t\t\tspineKnots[2] = 2.0 / 3.0;\n\t\t\tspineKnots[3] = 1;\n\t\t\tspineMults.front() = 4;\n\t\t\tspineMults.back() = 4;\n\t\t\tbsp2 = std::make_shared<Geom3BSplineCurve>(spinePoles, weights, spineKnots, spineMults, 3);\n\t\t\tCHECK(OCCTIO::OCCTTool::Write(MakeEdge(bsp2), OUTPUT_PATH_PREFIX \"TestSweepTest1_bsp2.brep\"));\n\t\t}\n\t\tbool isParallel = false;\n\t\tauto bsp3 = NURBSAPISweep::SweepOneRail(bsp1, bsp2, isParallel);\n\t\tfor (int i = 0; i < static_cast<int>(bsp3.size()); i++)\n\t\t{\n\t\t\tstd::string filename = OUTPUT_PATH_PREFIX \"TestSweepTest1_result\" + std::to_string(i) + \".brep\";\n\t\t\tCHECK(OCCTIO::OCCTTool::Write(MakeFace(bsp3[i], 0.0), filename.c_str()));\n\t\t}\n\t\tCHECK(bsp3.size() == 1);\n\t\tAMCAX::BRepExtremaDistShapeShape len(MakeEdge(bsp1), MakeFace(bsp3[0], 0.0));\n\t\tCHECK(len.Value() == Approx(0.0).margin(0.1));\n\t\tCHECK(IsCurveOnSurf(1000, 0.2, bsp1, bsp3[0], 0.2));\n\t\tbsp2->IncreaseDegree(25);\n\t\tbsp1->IncreaseDegree(25);\n\t\tauto bsp4 = NURBSAPISweep::SweepOneRail(bsp1, bsp2, isParallel);\n\t\tCHECK(OCCTIO::OCCTTool::Write(MakeFace(bsp4[0], 0.0), OUTPUT_PATH_PREFIX \"TestSweepTest1_degree25result.brep\"));\n\t\tAMCAX::BRepExtremaDistShapeShape len1(MakeEdge(bsp1), MakeFace(bsp4[0], 0.0));\n\t\tCHECK(len1.Value() == Approx(0.0).margin(0.1));\n\t\tCHECK(IsCurveOnSurf(1000, 0.2, bsp1, bsp4[0], 0.2));\n\t\tdouble bsp3s = GetSurfaceProperties(MakeFace(bsp3[0], 0.0), g, true, true);\n\t\tdouble bsp4s = GetSurfaceProperties(MakeFace(bsp4[0], 0.0), g, true, true);\n\t\tdouble bsp3v = GetVolumeProperties(MakeFace(bsp3[0], 0.0), g, true, true);\n\t\tdouble bsp4v = GetVolumeProperties(MakeFace(bsp4[0], 0.0), g, true, true);\n\t\tCHECK(bsp3s == Approx(bsp4s).margin(0.02));\n\t\tCHECK(bsp3v == Approx(bsp4v).margin(0.02));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static std::vector<std::shared_ptr<Geom3BSplineSurface>> SweepOneRail( const std::shared_ptr<Geom3BSplineCurve>& profile, const std::shared_ptr<Geom3BSplineCurve>& spine, double spineParam, bool isParallel),\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeFace.hpp>\n#include <nurbs/NURBSAPIConvert.hpp>\n#include <topology/TopoTool.hpp>\n#include <nurbs/NURBSAPIExplicitSweep.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <nurbs/NURBSAPISweepRotation.hpp>\n#include <topology/BRepExtremaDistShapeShape.hpp>\n#include <topology/TopoExplorerTool.hpp>\nusing namespace AMCAX;\nnamespace\n{\n\tstd::shared_ptr<Geom3BSplineCurve> CurveChooser(const int id, const std::shared_ptr<Geom3BSplineCurve>& curve0, const std::shared_ptr<Geom3BSplineCurve>& curve1, const std::shared_ptr<Geom3BSplineCurve>& curve2)\n\t{\n\t\tstd::shared_ptr<Geom3BSplineCurve> result;\n\t\tswitch (id)\n\t\t{\n\t\tcase 0:\n\t\t{\n\t\t\tresult = curve0;\n\t\t\tbreak;\n\t\t}\n\t\tcase 1:\n\t\t{\n\t\t\tresult = curve1;\n\t\t\tbreak;\n\t\t}\n\t\tcase 2:\n\t\t{\n\t\t\tresult = curve2;\n\t\t\tbreak;\n\t\t}\n\t\t}\n\t\treturn result;\n\t}\n} \n#include<catch.hpp>\n#include<testHelper.h>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeFace.hpp>\n#include <nurbs/NURBSAPIConvert.hpp>\n#include <topology/TopoTool.hpp>\n#include <nurbs/NURBSAPIExplicitSweep.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <nurbs/NURBSAPISweepRotation.hpp>\n#include <topology/BRepExtremaDistShapeShape.hpp>\n#include <topology/TopoExplorerTool.hpp>\nusing namespace AMCAX;\nnamespace\n{\n\tstd::shared_ptr<Geom3BSplineCurve> CurveChooser(const int id, const std::shared_ptr<Geom3BSplineCurve>& curve0, const std::shared_ptr<Geom3BSplineCurve>& curve1, const std::shared_ptr<Geom3BSplineCurve>& curve2)\n\t{\n\t\tstd::shared_ptr<Geom3BSplineCurve> result;\n\t\tswitch (id)\n\t\t{\n\t\tcase 0:\n\t\t{\n\t\t\tresult = curve0;\n\t\t\tbreak;\n\t\t}\n\t\tcase 1:\n\t\t{\n\t\t\tresult = curve1;\n\t\t\tbreak;\n\t\t}\n\t\tcase 2:\n\t\t{\n\t\t\tresult = curve2;\n\t\t\tbreak;\n\t\t}\n\t\t}\n\t\treturn result;\n\t}\n;\n\tSECTION(\"TestRotationSweep()\")\t\n\tSECTION(\"TestRotationSweepPeriodic()\")\n\t{\n\t\tstd::string filedir = INPUT_PATH_PREFIX \"/TestNURBS/TestRotationSweepPeriodic/\";\n\t\tstd::shared_ptr<Geom3BSplineCurve> spine = ReadBRepCurve(filedir + \"spine.brep\");\n\t\tstd::shared_ptr<Geom3BSplineCurve> profile = ReadBRepCurve(filedir + \"profile.brep\");\n\t\tCHECK(OCCTIO::OCCTTool::Write(MakeEdge(spine), OUTPUT_PATH_PREFIX \"TestRotationSweepPeriodic_spine.brep\"));\n\t\tCHECK(OCCTIO::OCCTTool::Write(MakeEdge(profile), OUTPUT_PATH_PREFIX \"TestRotationSweepPeriodic_profile.brep\"));\n\t\tPoint3 p(21.1, 22.8, 0.0);\n\t\tVector3 vec(0.0, 0.0, 5.0);\n\t\tAxis3 axis(p, Direction3(vec));\n\t\tLine3 line(axis);\n\t\tauto surface = NURBSAPISweepRotation::RotationSweep(profile, spine, axis);\n\t\tCHECK(OCCTIO::OCCTTool::Write(MakeFace(surface, 0.0), OUTPUT_PATH_PREFIX \"TestRotationSweepPeriodic_result.brep\"));\n\t\tAMCAX::BRepExtremaDistShapeShape len1(MakeFace(surface, 0.0), MakeEdge(line));\n\t\tAMCAX::BRepExtremaDistShapeShape len2(MakeFace(surface, 0.0), MakeEdge(spine));\n\t\tCHECK(len1.Value() < 1.0);\n\t\tCHECK(len2.Value() < 1.0);\n\t\tCHECK(IsCurveOnSurf(1000, 0.1, profile, surface, 0.1));\n\t\tCHECK(IsCurveOnSurf(1000, 0.1, spine, surface, 0.1));\n\t\tspine->IncreaseDegree(11);\n\t\tprofile->IncreaseDegree(11);\n\t\tauto surface1 = NURBSAPISweepRotation::RotationSweep(profile, spine, axis);\n\t\tCHECK(OCCTIO::OCCTTool::Write(MakeFace(surface, 0.0), OUTPUT_PATH_PREFIX \"TestRotationSweepPeriodic_degree11result.brep\"));\n\t\tCHECK(surface1->UDegree() == 11);\n\t\tCHECK(surface1->VDegree() == 11);\n\t\tdouble bsp3s = GetSurfaceProperties(MakeFace(surface1, 0.0), g, true, true);\n\t\tdouble bsp4s = GetSurfaceProperties(MakeFace(surface, 0.0), g, true, true);\n\t\tCHECK(bsp3s == Approx(bsp4s).margin(0.1));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static std::vector<std::shared_ptr<Geom3BSplineSurface>> SweepOneRail( const std::shared_ptr<Geom3BSplineCurve>& profile, const std::shared_ptr<Geom3BSplineCurve>& spine, bool isParallel),\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeFace.hpp>\n#include <nurbs/NURBSAPIConvert.hpp>\n#include <topology/TopoTool.hpp>\n#include <nurbs/NURBSAPIExplicitSweep.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <nurbs/NURBSAPISweepRotation.hpp>\n#include <topology/BRepExtremaDistShapeShape.hpp>\n#include <topology/TopoExplorerTool.hpp>\nusing namespace AMCAX;\nnamespace\n{\n\tstd::shared_ptr<Geom3BSplineCurve> CurveChooser(const int id, const std::shared_ptr<Geom3BSplineCurve>& curve0, const std::shared_ptr<Geom3BSplineCurve>& curve1, const std::shared_ptr<Geom3BSplineCurve>& curve2)\n\t{\n\t\tstd::shared_ptr<Geom3BSplineCurve> result;\n\t\tswitch (id)\n\t\t{\n\t\tcase 0:\n\t\t{\n\t\t\tresult = curve0;\n\t\t\tbreak;\n\t\t}\n\t\tcase 1:\n\t\t{\n\t\t\tresult = curve1;\n\t\t\tbreak;\n\t\t}\n\t\tcase 2:\n\t\t{\n\t\t\tresult = curve2;\n\t\t\tbreak;\n\t\t}\n\t\t}\n\t\treturn result;\n\t}\n} \n#include<catch.hpp>\n#include<testHelper.h>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeFace.hpp>\n#include <nurbs/NURBSAPIConvert.hpp>\n#include <topology/TopoTool.hpp>\n#include <nurbs/NURBSAPIExplicitSweep.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <nurbs/NURBSAPISweepRotation.hpp>\n#include <topology/BRepExtremaDistShapeShape.hpp>\n#include <topology/TopoExplorerTool.hpp>\nusing namespace AMCAX;\nnamespace\n{\n\tstd::shared_ptr<Geom3BSplineCurve> CurveChooser(const int id, const std::shared_ptr<Geom3BSplineCurve>& curve0, const std::shared_ptr<Geom3BSplineCurve>& curve1, const std::shared_ptr<Geom3BSplineCurve>& curve2)\n\t{\n\t\tstd::shared_ptr<Geom3BSplineCurve> result;\n\t\tswitch (id)\n\t\t{\n\t\tcase 0:\n\t\t{\n\t\t\tresult = curve0;\n\t\t\tbreak;\n\t\t}\n\t\tcase 1:\n\t\t{\n\t\t\tresult = curve1;\n\t\t\tbreak;\n\t\t}\n\t\tcase 2:\n\t\t{\n\t\t\tresult = curve2;\n\t\t\tbreak;\n\t\t}\n\t\t}\n\t\treturn result;\n\t}\n;\n\tSECTION(\"TestRotationSweep()\")\t\n\t{\n\t\tstd::string filedir = INPUT_PATH_PREFIX \"/TestNURBS/TestRotationSweep/\";\n\t\tstd::shared_ptr<Geom3BSplineCurve> spine = ReadBRepCurve(filedir + \"spine.brep\");\n\t\tstd::shared_ptr<Geom3BSplineCurve> profile = ReadBRepCurve(filedir + \"profile.brep\");\n\t\tCHECK(OCCTIO::OCCTTool::Write(MakeEdge(spine), OUTPUT_PATH_PREFIX \"TestRotationSweep_spine.brep\"));\n\t\tCHECK(OCCTIO::OCCTTool::Write(MakeEdge(profile), OUTPUT_PATH_PREFIX \"TestRotationSweep_profile.brep\"));\n\t\tPoint3 p(2.5, 2.5, 0.0);\n\t\tVector3 vec(0.0, 0.0, 10.0);\n\t\tAxis3 axis(p, Direction3(vec));\n\t\tauto surface1 = NURBSAPISweepRotation::RotationSweep(spine, profile, axis);\n\t\tCHECK(OCCTIO::OCCTTool::Write(MakeFace(surface1, 0.0), OUTPUT_PATH_PREFIX \"TestRotationSweep_result.brep\"));\n\t\tAMCAX::BRepExtremaDistShapeShape len3(MakeEdge(profile), MakeEdge(spine));\n\t\tAMCAX::BRepExtremaDistShapeShape len2(MakeFace(surface1, 0.0), MakeEdge(spine));\n\t\tGlobalProperty props;\n\t\tIndexSet<TopoShape> newshapeEdge1;\n\t\tstd::cout << \"newshapedege.size\" << newshapeEdge1.size() << endl;\n\t\tTopoExplorerTool::MapShapes(MakeFace(surface1, 0.0), ShapeType::Edge, newshapeEdge1);\n\t\tCHECK(OCCTIO::OCCTTool::Write(newshapeEdge1[0], OUTPUT_PATH_PREFIX \"TestRotationSweep_newshapeEdge1[0].brep\"));\n\t\tCHECK(OCCTIO::OCCTTool::Write(newshapeEdge1[1], OUTPUT_PATH_PREFIX \"TestRotationSweep_newshapeEdge1[1].brep\"));\n\t\tCHECK(OCCTIO::OCCTTool::Write(newshapeEdge1[2], OUTPUT_PATH_PREFIX \"TestRotationSweep_newshapeEdge1[2].brep\"));\n\t\tdouble\tn, t;\n\t\tcout << \" newshapeEdge1.size= \" << newshapeEdge1.size() << endl;\n\t\tfor (int i = 0; i < newshapeEdge1.size(); i++) {\n\t\t\tt = GetLinearProperties(newshapeEdge1[i], props, true, true);\n\t\t\tn = t + n;\n\t\t}\n\t\tcout << \" spine = \" << GetLinearProperties(MakeEdge(spine), props, true, true) << endl;\n\t\tcout << \" profile = \" << GetLinearProperties(MakeEdge(profile), props, true, true) << endl;\n\t\tCHECK(len2.Value() < 1.0);\n\t\tCHECK(IsCurveOnSurf(1000, 0.1, profile, surface1, 0.1));\n\t\tCHECK(IsCurveOnSurf(1000, 0.1, spine, surface1, 0.1));\n\t\t{\n\t\t\tspine->IncreaseDegree(7);\n\t\t\tprofile->IncreaseDegree(7);\n\t\t\tCHECK(OCCTIO::OCCTTool::Write(MakeEdge(profile), OUTPUT_PATH_PREFIX \"TestRotationSweep_degree11profile.brep\"));\n\t\t\tauto surface11 = NURBSAPISweepRotation::RotationSweep(spine, profile, axis);\n\t\t\tCHECK(surface11->UDegree() == 7);\n\t\t\tCHECK(surface11->VDegree() == 7);\n\t\t\tCHECK(OCCTIO::OCCTTool::Write(MakeFace(surface11, 0.0), OUTPUT_PATH_PREFIX \"TestRotationSweep_degree11result.brep\"));\n\t\t\tdouble bsp3s = GetSurfaceProperties(MakeFace(surface1, 0.0), g, true, true);\n\t\t\tdouble bsp4s = GetSurfaceProperties(MakeFace(surface11, 0.0), g, true, true);\n\t\t\tCHECK(bsp3s == Approx(bsp4s).margin(0.02));\n\t\t} \n\t\t{\n\t\t\tspine->IncreaseDegree(11);\n\t\t\tprofile->IncreaseDegree(11);\n\t\t\tCHECK(OCCTIO::OCCTTool::Write(MakeEdge(profile), OUTPUT_PATH_PREFIX \"TestRotationSweep_degree11profile.brep\"));\n\t\t\tauto surface11 = NURBSAPISweepRotation::RotationSweep(spine, profile, axis);\n\t\t\tCHECK(surface11->UDegree()==11);\n\t\t\tCHECK(surface11->VDegree()==11);\n\t\t\tCHECK(OCCTIO::OCCTTool::Write(MakeFace(surface11, 0.0), OUTPUT_PATH_PREFIX \"TestRotationSweep_degree11result.brep\"));\n\t\t\tdouble bsp3s = GetSurfaceProperties(MakeFace(surface1, 0.0), g, true, true);\n\t\t\tdouble bsp4s = GetSurfaceProperties(MakeFace(surface11, 0.0), g, true, true);\n\t\t\tCHECK(bsp3s == Approx(bsp4s).margin(0.02));\n\t\t}\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static std::tuple<bool, bool, std::shared_ptr<Geom3BSplineCurve>> SmoothCurve(const std::shared_ptr<Geom3BSplineCurve>& curve, double angularCorrection, double deviation)\t  The third is the smoothed curve.\n\t  The second is whether the smoothing operation succeeded;\n\t @return The first is whether the curve C0 tangent angular is below the angularCorrection;\n\t @param deviation The tolerance of smoothing\n\t the C0 points will be smoothed; Else it will return failure.\n\t the guide curve C0 points is below the parameter value,\n\t If the angular difference of the left derivative and the right derivative of\n\t @param angularCorrection The smooth sweeping angular correction of the guide curve in radians.\n\t @param curve The source curve\n\t @brief Smooth curve\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <filesystem>\n#include <fstream>\n#include <random>\n#include <sstream>\n#include <nurbs/NURBSAPIGetGeometry.hpp>\n#include <nurbs/NURBSAPIConicalSweep.hpp>\n#include <boolean/BoolBRepCut.hpp>\n#include <common/CartesianCoordinateSystem.hpp>\n#include <common/IndexMap.hpp>\n#include <common/QuaternionT.hpp>\n#include <geomAlgo/LawBSpline.hpp>\n#include <geomAlgo/LawConstant.hpp>\n#include <nurbs/NURBSAPISmooth.hpp>\n#include <geomAlgo/MakeConic2FromConstraints.hpp>\n#include <geometry/Adaptor3CurveOnSurface.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/AdaptorGeom3Surface.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2Circle.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/Geom2Hyperbola.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3BSplineCurve.hpp>\n#include <geometry/Geom3BSplineSurface.hpp>\n#include <geometry/Geom3Circle.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\n#include <geometry/Geom3Plane.hpp>\n#include <geometry/Geom3SphericalSurface.hpp>\n#include <geometry/Geom3Surface.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include <geometry/Geom3TrimmedSurface.hpp>\n#include <geometry/GeomAPIExtremaCurveCurve3.hpp>\n#include <geometry/GeomAPIProjectPointOnCurve2.hpp>\n#include <geometry/GeomAPIProjectPointOnCurve3.hpp>\n#include <geometry/GeomAPIProjectPointOnSurface.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/GlobalProperty.hpp>\n#include <healing/ShapeFixTool.hpp>\n#include <io/STLTool.hpp>\n#include <math/Sphere.hpp>\n#include <math/TriangularMesh.hpp>\n#include <modeling/CopyShape.hpp>\n#include <modeling/MakeBox.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeFace.hpp>\n#include <modeling/MakePrism.hpp>\n#include <modeling/MakeRevol.hpp>\n#include <modeling/MakeShapeTool.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <modeling/MakeWire.hpp>\n#include <modeling/TransformShape.hpp>\n#include <nurbs/NURBSAPIApprox.hpp>\n#include <nurbs/NURBSAPIBuildCurve.hpp>\n#include <nurbs/NURBSAPICircularSweep.hpp>\n#include <nurbs/NURBSAPIConvert.hpp>\n#include <nurbs/NURBSAPICurveNetworkSurface.hpp>\n#include <nurbs/NURBSAPIExplicitSweep.hpp>\n#include <nurbs/NURBSAPIExplode.hpp>\n#include <nurbs/NURBSAPIExtend.hpp>\n#include <nurbs/NURBSAPIInterpolate.hpp>\n#include <nurbs/NURBSAPIJoin.hpp>\n#include <nurbs/NURBSAPILinearSweep.hpp>\n#include <nurbs/NURBSAPILoft.hpp>\n#include <nurbs/NURBSAPIMakeNURBSFromBoundaries.hpp>\n#include <nurbs/NURBSAPIMatch.hpp>\n#include <nurbs/NURBSAPIModifyEndToPlane.hpp>\n#include <nurbs/NURBSAPIOffsetCurveOnSurface.hpp>\n#include <nurbs/NURBSAPIProject.hpp>\n#include <nurbs/NURBSAPIRebuild.hpp>\n#include <nurbs/NURBSAPIReplaceEdge.hpp>\n#include <nurbs/NURBSAPISweep.hpp>\n#include <nurbs/NURBSAPISweep2.hpp>\n#include <nurbs/NURBSAPISweepRotation.hpp>\n#include <nurbs/NURBSAPITrim.hpp>\n#include <nurbs/NURBSAPIUntrim.hpp>\n#include <nurbs/NURBSLinearSweepWithDraftDirectionLength.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <offset/MakePipe.hpp>\n#include <offset/MakePipeShell.hpp>\n#include <topology/BRepAdaptorCurve2.hpp>\n#include <topology/BRepAdaptorCurve3.hpp>\n#include <topology/BRepAdaptorSurface.hpp>\n#include <topology/BRepGlobalProperty.hpp>\n#include <topology/BRepTool.hpp>\n#include <topology/TopoBuilder.hpp>\n#include <topology/TopoCompound.hpp>\n#include <topology/TopoEdge.hpp>\n#include <topology/TopoExplorer.hpp>\n#include <topology/TopoExplorerTool.hpp>\n#include <topology/TopoFace.hpp>\n#include <topology/TopoShape.hpp>\n#include <topology/TopoShell.hpp>\n#include <topology/TopoTool.hpp>\n#include <topology/TopoVertex.hpp>\n#include <topology/TopoWire.hpp>\n#include <topology/WireExplorer.hpp>\n#include <topomesh/BRepMeshIncrementalMesh.hpp>\n#include <geometry/ComputePointsAbscissa.hpp>\n#include <nurbs/NURBSAPIBlend.hpp>\n#include <topology/BRepExtremaDistShapeShape.hpp>\n#include <math/LineT.hpp>\n#include <hatch/BRepClassificationTools.hpp>\nusing namespace AMCAX;\nnamespace\n{\n\tstd::shared_ptr<Geom3BSplineCurve> CurveChooser(const int id, const std::shared_ptr<Geom3BSplineCurve>& curve0, const std::shared_ptr<Geom3BSplineCurve>& curve1, const std::shared_ptr<Geom3BSplineCurve>& curve2)\n\t{\n\t\tstd::shared_ptr<Geom3BSplineCurve> result;\n\t\tswitch (id)\n\t\t{\n\t\tcase 0:\n\t\t{\n\t\t\tresult = curve0;\n\t\t\tbreak;\n\t\t}\n\t\tcase 1:\n\t\t{\n\t\t\tresult = curve1;\n\t\t\tbreak;\n\t\t}\n\t\tcase 2:\n\t\t{\n\t\t\tresult = curve2;\n\t\t\tbreak;\n\t\t}\n\t\t}\n\t\treturn result;\n\t}\n} \nGlobalProperty props;\n#include<catch.hpp>\n#include<testHelper.h>\n#include <filesystem>\n#include <fstream>\n#include <random>\n#include <sstream>\n#include <nurbs/NURBSAPIGetGeometry.hpp>\n#include <nurbs/NURBSAPIConicalSweep.hpp>\n#include <boolean/BoolBRepCut.hpp>\n#include <common/CartesianCoordinateSystem.hpp>\n#include <common/IndexMap.hpp>\n#include <common/QuaternionT.hpp>\n#include <geomAlgo/LawBSpline.hpp>\n#include <geomAlgo/LawConstant.hpp>\n#include <nurbs/NURBSAPISmooth.hpp>\n#include <geomAlgo/MakeConic2FromConstraints.hpp>\n#include <geometry/Adaptor3CurveOnSurface.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/AdaptorGeom3Surface.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2Circle.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/Geom2Hyperbola.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3BSplineCurve.hpp>\n#include <geometry/Geom3BSplineSurface.hpp>\n#include <geometry/Geom3Circle.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\n#include <geometry/Geom3Plane.hpp>\n#include <geometry/Geom3SphericalSurface.hpp>\n#include <geometry/Geom3Surface.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include <geometry/Geom3TrimmedSurface.hpp>\n#include <geometry/GeomAPIExtremaCurveCurve3.hpp>\n#include <geometry/GeomAPIProjectPointOnCurve2.hpp>\n#include <geometry/GeomAPIProjectPointOnCurve3.hpp>\n#include <geometry/GeomAPIProjectPointOnSurface.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/GlobalProperty.hpp>\n#include <healing/ShapeFixTool.hpp>\n#include <io/STLTool.hpp>\n#include <math/Sphere.hpp>\n#include <math/TriangularMesh.hpp>\n#include <modeling/CopyShape.hpp>\n#include <modeling/MakeBox.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeFace.hpp>\n#include <modeling/MakePrism.hpp>\n#include <modeling/MakeRevol.hpp>\n#include <modeling/MakeShapeTool.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <modeling/MakeWire.hpp>\n#include <modeling/TransformShape.hpp>\n#include <nurbs/NURBSAPIApprox.hpp>\n#include <nurbs/NURBSAPIBuildCurve.hpp>\n#include <nurbs/NURBSAPICircularSweep.hpp>\n#include <nurbs/NURBSAPIConvert.hpp>\n#include <nurbs/NURBSAPICurveNetworkSurface.hpp>\n#include <nurbs/NURBSAPIExplicitSweep.hpp>\n#include <nurbs/NURBSAPIExplode.hpp>\n#include <nurbs/NURBSAPIExtend.hpp>\n#include <nurbs/NURBSAPIInterpolate.hpp>\n#include <nurbs/NURBSAPIJoin.hpp>\n#include <nurbs/NURBSAPILinearSweep.hpp>\n#include <nurbs/NURBSAPILoft.hpp>\n#include <nurbs/NURBSAPIMakeNURBSFromBoundaries.hpp>\n#include <nurbs/NURBSAPIMatch.hpp>\n#include <nurbs/NURBSAPIModifyEndToPlane.hpp>\n#include <nurbs/NURBSAPIOffsetCurveOnSurface.hpp>\n#include <nurbs/NURBSAPIProject.hpp>\n#include <nurbs/NURBSAPIRebuild.hpp>\n#include <nurbs/NURBSAPIReplaceEdge.hpp>\n#include <nurbs/NURBSAPISweep.hpp>\n#include <nurbs/NURBSAPISweep2.hpp>\n#include <nurbs/NURBSAPISweepRotation.hpp>\n#include <nurbs/NURBSAPITrim.hpp>\n#include <nurbs/NURBSAPIUntrim.hpp>\n#include <nurbs/NURBSLinearSweepWithDraftDirectionLength.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <offset/MakePipe.hpp>\n#include <offset/MakePipeShell.hpp>\n#include <topology/BRepAdaptorCurve2.hpp>\n#include <topology/BRepAdaptorCurve3.hpp>\n#include <topology/BRepAdaptorSurface.hpp>\n#include <topology/BRepGlobalProperty.hpp>\n#include <topology/BRepTool.hpp>\n#include <topology/TopoBuilder.hpp>\n#include <topology/TopoCompound.hpp>\n#include <topology/TopoEdge.hpp>\n#include <topology/TopoExplorer.hpp>\n#include <topology/TopoExplorerTool.hpp>\n#include <topology/TopoFace.hpp>\n#include <topology/TopoShape.hpp>\n#include <topology/TopoShell.hpp>\n#include <topology/TopoTool.hpp>\n#include <topology/TopoVertex.hpp>\n#include <topology/TopoWire.hpp>\n#include <topology/WireExplorer.hpp>\n#include <topomesh/BRepMeshIncrementalMesh.hpp>\n#include <geometry/ComputePointsAbscissa.hpp>\n#include <nurbs/NURBSAPIBlend.hpp>\n#include <topology/BRepExtremaDistShapeShape.hpp>\n#include <math/LineT.hpp>\n#include <hatch/BRepClassificationTools.hpp>\nusing namespace AMCAX;\nnamespace\n{\n\tstd::shared_ptr<Geom3BSplineCurve> CurveChooser(const int id, const std::shared_ptr<Geom3BSplineCurve>& curve0, const std::shared_ptr<Geom3BSplineCurve>& curve1, const std::shared_ptr<Geom3BSplineCurve>& curve2)\n\t{\n\t\tstd::shared_ptr<Geom3BSplineCurve> result;\n\t\tswitch (id)\n\t\t{\n\t\tcase 0:\n\t\t{\n\t\t\tresult = curve0;\n\t\t\tbreak;\n\t\t}\n\t\tcase 1:\n\t\t{\n\t\t\tresult = curve1;\n\t\t\tbreak;\n\t\t}\n\t\tcase 2:\n\t\t{\n\t\t\tresult = curve2;\n\t\t\tbreak;\n\t\t}\n\t\t}\n\t\treturn result;\n\t}\n;\n\tSECTION(\"TestSmoothCurve2()\")\n\t{\n\t\tstd::string filedir = INPUT_PATH_PREFIX \"/TestNURBS/TestSmooth/\";\n\t\tauto c0 = ReadBRepCurve(filedir + \"curve1.brep\");\n\t\tauto c1 = ReadBRepCurve(filedir + \"curve2.brep\");\n\t\tstd::vector<std::shared_ptr<Geom3BSplineCurve>>curves;\n\t\tcurves.push_back(c0);\n\t\tcurves.push_back(c1);\n\t\tPoint3 p;\n\t\tc0->D0(c0->LastParameter(), p);\n\t\tCHECK(OCCTIO::OCCTTool::Write(MakeVertex(p), OUTPUT_PATH_PREFIX\"smooth2_p.brep\"));\n\t\tauto [sorted, isReverse, isPeriodic] = NURBSAPIJoin::JoinCurvePrepare(curves);\n\t\tauto joinedBSp = NURBSAPIJoin::JoinCurves(sorted, isReverse, isPeriodic);\n\t\tauto [isOK11, isOK12, smoothedCurve1] = NURBSAPISmooth::SmoothCurve(joinedBSp,  M_PI , 0.1);\n\t\tauto [isOK21, isOK22, smoothedCurve2] = NURBSAPISmooth::SmoothCurve(joinedBSp,  20.0*M_PI/180.0 , 0.1);\n\t\tauto [isOK31, isOK32, smoothedCurve3] = NURBSAPISmooth::SmoothCurve(joinedBSp,  M_PI , 0.01);\n\t\tCHECK(isOK11 == true);\n\t\tCHECK(isOK12 == true);\n\t\tCHECK(isOK21 == true);\n\t\tCHECK(isOK22 == true);\n\t\tCHECK(isOK31 == true);\n\t\tCHECK(isOK32 == true);\n\t\tif (isOK12 &&isOK22 &&isOK32  )\n\t\t{\n\t\t\tCHECK(OCCTIO::OCCTTool::Write(MakeEdge(smoothedCurve1), OUTPUT_PATH_PREFIX\"TestSmoothCurve2_result.brep\"));\n\t\t\tdouble t0 = GetLinearProperties(MakeEdge(smoothedCurve1), props, true, true);\n\t\t\tdouble t2 = GetLinearProperties(MakeEdge(smoothedCurve2), props, true, true);\n\t\t\tdouble t3 = GetLinearProperties(MakeEdge(smoothedCurve3), props, true, true);\n\t\t\tdouble t1 = GetLinearProperties(MakeEdge(c1), props, true, true) + GetLinearProperties(MakeEdge(c0), props, true, true);\n\t\t\tCHECK(t1 == Approx(t0).margin(0.1));\n\t\t\tCHECK(t1 == Approx(t2).margin(0.1));\n\t\t\tCHECK(t1 == Approx(t3).margin(0.1));\n\t\t\tdouble n11 = NurbsSampleCurve(100, 0.1, c1, smoothedCurve1);\n\t\t\tdouble n12 = NurbsSampleCurve(100, 0.1, c0, smoothedCurve1);\n\t\t\tCHECK(n11 == 0);\n\t\t\tCHECK(n12 == 0);\n\t\t\tdouble n21 = NurbsSampleCurve(100, 0.1, c1, smoothedCurve2);\n\t\t\tdouble n22 = NurbsSampleCurve(100, 0.1, c0, smoothedCurve2);\n\t\t\tCHECK(n21 == 0);\n\t\t\tCHECK(n22 == 0);\n\t\t\tdouble n31 = NurbsSampleCurve(100, 0.01, c1, smoothedCurve3);\n\t\t\tdouble n32 = NurbsSampleCurve(100, 0.01, c0, smoothedCurve3);\n\t\t\tCHECK(n31 == 0);\n\t\t\tCHECK(n32 == 0);\n\t\t}\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static TopoFace ReplaceEdgeWithLine(const TopoFace& face, const std::vector<TopoEdge>& edges)\t @return The new face\n\t @param edges Edges to be replaced\n\t @param face Face\n\t @brief Replace edges on face with a line\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <nurbs/NURBSAPIReplaceEdge.hpp>\n#include <modeling/MakeWire.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <offset/MakePipeShell.hpp>\n#include <modeling/MakePrism.hpp>\n#include <modeling/MakeFace.hpp>\n#include <geometry/Geom3Plane.hpp>\n#include <topology/TopoTool.hpp>\n#include <geometry/GeomAPIProjectPointOnCurve3.hpp>\n#include <topology/TopoExplorerTool.hpp>\n#include <nurbs/NURBSAPIUntrim.hpp>\n#include <topology/WireExplorer.hpp>\n#include <modeling/MakeVertex.hpp>\n#include<catch.hpp>\n#include<testHelper.h>\n#include <nurbs/NURBSAPIReplaceEdge.hpp>\n#include <modeling/MakeWire.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <offset/MakePipeShell.hpp>\n#include <modeling/MakePrism.hpp>\n#include <modeling/MakeFace.hpp>\n#include <geometry/Geom3Plane.hpp>\n#include <topology/TopoTool.hpp>\n#include <geometry/GeomAPIProjectPointOnCurve3.hpp>\n#include <topology/TopoExplorerTool.hpp>\n#include <nurbs/NURBSAPIUntrim.hpp>\n#include <topology/WireExplorer.hpp>\n#include <modeling/MakeVertex.hpp>\n;\n\tSECTION(\"TestReplaceEdge\")\n\t{\n\t\tOUTPUT_DIRECTORY(nurbs, ReplaceEdge/ReplaceEdge);\n\t\tstd::vector<Point3> profilePoles;\n\t\tstd::vector<double> profileKnots(3);\n\t\tstd::vector<int> profileMults(3, 1);\n\t\tprofilePoles.push_back(Point3(0.0, 0.0, 0.0));\n\t\tprofilePoles.push_back(Point3(1.0, -0.2, 0.1));\n\t\tprofilePoles.push_back(Point3(2.0, 0.1, -0.1));\n\t\tprofilePoles.push_back(Point3(3.0, -0.1, 0.0));\n\t\tprofilePoles.push_back(Point3(4.0, 0.1, 0.2));\n\t\tprofileKnots[0] = 0;\n\t\tprofileKnots[1] = 0.5;\n\t\tprofileKnots[2] = 1;\n\t\tprofileMults.front() = 4;\n\t\tprofileMults.back() = 4;\n\t\tstd::shared_ptr<Geom3BSplineCurve> profileCurve = std::make_shared<Geom3BSplineCurve>(profilePoles, profileKnots, profileMults, 3);\n\t\tstd::vector<Point3> spinePoles;\n\t\tstd::vector<double> spineKnots(4);\n\t\tstd::vector<int> spineMults(4, 1);\n\t\tspinePoles.push_back(Point3(0.0, 0.0, 0.0));\n\t\tspinePoles.push_back(Point3(-0.1, 1.0, -0.2));\n\t\tspinePoles.push_back(Point3(0.1, 2.0, -0.1));\n\t\tspinePoles.push_back(Point3(0.2, 3.0, 0.1));\n\t\tspinePoles.push_back(Point3(0.1, 4.0, 0.0));\n\t\tspinePoles.push_back(Point3(0.0, 5.0, -0.1));\n\t\tspineKnots[0] = 0;\n\t\tspineKnots[1] = 1.0 / 3.0;\n\t\tspineKnots[2] = 2.0 / 3.0;\n\t\tspineKnots[3] = 1;\n\t\tspineMults.front() = 4;\n\t\tspineMults.back() = 4;\n\t\tstd::shared_ptr<Geom3BSplineCurve> spineCurve = std::make_shared<Geom3BSplineCurve>(spinePoles, spineKnots, spineMults, 3);\n\t\tTopoWire profile = MakeWire(MakeEdge(profileCurve)).Wire();\n\t\tTopoWire spine = MakeWire(MakeEdge(spineCurve)).Wire();\n\t\tMakePipeShell pipeShell(spine);\n\t\tpipeShell.Add(profile);\n\t\tpipeShell.SetMode(Frame3());\n\t\tTopoShape pipe = pipeShell.Shape();\n\t\tTopoExplorer ex(pipe, ShapeType::Face);\n\t\tTopoFace inputBasicFace = static_cast<const TopoFace&>(ex.Current());\n\t\tTopoShape cutCylidner1 = MakePrism(MakeEdge(Circle3(Frame3(Point3(0.0, 0.0, -0.3), Direction3(0.0, 0.0, 1.0)), 1.0)), Vector3(0.1, 0.1, 1.0));\n\t\tTopoShape cutPlane1 = MakeFace(std::make_shared<Geom3Plane>(Frame3(Point3(0.6, 0.6, 0.0), Direction3(-0.3, -0.3, 0.0), Direction3(0.3, -0.3, 0.0))), -2.0, 2.0, -1.0, 1.0, 1e-8);\n\t\tTopoShape cutCylidner2 = MakePrism(MakeEdge(Circle3(Frame3(Point3(2.0, 2.0, -0.3), Direction3(0.0, 0.0, 1.0)), 0.1)), Vector3(0.1, 0.1, 1.0));\n\t\tTopoShape cutPlane2 = MakeFace(std::make_shared<Geom3Plane>(Frame3(Point3(0.6, 5.0, 0.0), Direction3(0.3, -0.3, 0.0), Direction3(0.3, 0.3, 0.0))), -2.0, 2.0, -1.0, 1.0, 1e-8);\n\t\tTopoShape cutPlane3 = MakeFace(std::make_shared<Geom3Plane>(Frame3(Point3(4.0, 5.0, 0.0), Direction3(-0.3, -0.3, 0.0), Direction3(0.3, -0.3, 0.0))), -2.0, 2.0, -1.0, 1.0, 1e-8);\n\t\tTopoShape cc = CutAndLeaveLargePart(inputBasicFace, cutCylidner1);\n\t\tTopoShape ccp = CutAndLeaveLargePart(cc, cutPlane1);\n\t\tTopoShape ccpc = CutAndLeaveLargePart(ccp, cutCylidner2);\n\t\tTopoShape ccpcp = CutAndLeaveLargePart(ccpc, cutPlane2);\n\t\tTopoShape ccpcpp = CutAndLeaveLargePart(ccpcp, cutPlane3);\n\t\tTopoFace inputFace = static_cast<const TopoFace&>(ccpcpp);\n\t\tThrow_Construction_Error_if(inputFace.IsNull(), \"it is not a face\");\n\t\tPoint3 refp(0.768477, 0.684154, -0.076058120);\n\t\tTopoEdge theEdge;\n\t\tdouble dist = 1e100;\n\t\tfor (TopoExplorer exe(inputFace, ShapeType::Edge); exe.More(); exe.Next())\n\t\t{\n\t\t\tTopoEdge cr = static_cast<const TopoEdge&>(exe.Current());\n\t\t\tdouble f, l;\n\t\t\tauto curve3 = TopoTool::Curve(cr, f, l);\n\t\t\tGeomAPIProjectPointOnCurve3 projector(refp, curve3, f, l);\n\t\t\tif (projector.NPoints())\n\t\t\t{\n\t\t\t\tdouble crdist = projector.LowerDistance();\n\t\t\t\tif (dist > crdist)\n\t\t\t\t{\n\t\t\t\t\tdist = crdist;\n\t\t\t\t\ttheEdge = cr;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tTopoVertex v1, v2;\n\t\tstd::vector<TopoEdge> deleteEdges;\n\t\tdeleteEdges.push_back(theEdge);\n\t\tIndexMap<TopoShape, std::list<TopoShape>> map;\n\t\tTopoExplorerTool::MapShapesAndUniqueAncestors(inputFace, ShapeType::Edge, ShapeType::Wire, map);\n\t\tTopoWire wire = static_cast<const TopoWire&>(map[theEdge].front());\n\t\tWireExplorer we(wire);\n\t\tTopoEdge firstEdge = static_cast<const TopoEdge&>(we.Current());\n\t\tif (firstEdge.IsSame(theEdge))\n\t\t{\n\t\t\tThrow_Construction_Error_if(!we.More(), \"only one edge\");\n\t\t\twe.Next();\n\t\t\tTopoEdge frontNeighbourEdge = static_cast<const TopoEdge&>(we.Current());\n\t\t\tv2 = TopoExplorerTool::LastVertex(frontNeighbourEdge, true);\n\t\t\tdeleteEdges.push_back(frontNeighbourEdge);\n\t\t\tTopoEdge lastEdge;\n\t\t\tfor (we.Next(); we.More(); we.Next())\n\t\t\t{\n\t\t\t\tlastEdge = static_cast<const TopoEdge&>(we.Current());\n\t\t\t}\n\t\t\tdeleteEdges.push_back(lastEdge);\n\t\t\tv1 = TopoExplorerTool::FirstVertex(lastEdge, true);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tTopoEdge frontNeighbourEdge, nextNeighbourEdge;\n\t\t\tfor (we.Next(); we.More(); we.Next())\n\t\t\t{\n\t\t\t\tTopoEdge crEdge = static_cast<const TopoEdge&>(we.Current());\n\t\t\t\tif (crEdge.IsSame(theEdge))\n\t\t\t\t{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tfrontNeighbourEdge = crEdge;\n\t\t\t\t}\n\t\t\t}\n\t\t\tdeleteEdges.push_back(frontNeighbourEdge);\n\t\t\twe.Next();\n\t\t\tnextNeighbourEdge = static_cast<const TopoEdge&>(we.Current());\n\t\t\tdeleteEdges.push_back(nextNeighbourEdge);\n\t\t\tv1 = TopoExplorerTool::FirstVertex(frontNeighbourEdge, true);\n\t\t\tv2 = TopoExplorerTool::LastVertex(nextNeighbourEdge, true);\n\t\t}\n        for (int i = 0; i < static_cast<int>(deleteEdges.size()); i++)\n\t\t{\n\t\t\tOCCTIO::OCCTTool::Write(deleteEdges[i], outdir + \"deleteEdges\" + std::to_string(i) +\".brep\");\n\t\t}\n\t\tTopoFace result = NURBSAPIReplaceEdge::ReplaceEdgeWithLine(inputFace, deleteEdges);\n\t\tint res1 = GetTopoCount(inputFace, ShapeType::Edge);\n\t\tint res2 = GetTopoCount(result, ShapeType::Edge);\n\t\tCHECK(res1 == 10);\n\t\tCHECK(res2 == 8);\n\t\tTopoShape shape1 = CutAndLeaveLargePart(inputBasicFace, cutPlane1);\n\t\tTopoShape shape2 = CutAndLeaveLargePart(shape1, cutCylidner2);\n\t\tTopoShape shape3 = CutAndLeaveLargePart(shape2, cutPlane2);\n\t\tTopoShape shape4 = CutAndLeaveLargePart(shape3, cutPlane3);\n\t\tGlobalProperty props1, props2;\n\t\tdouble s1 = GetSurfaceProperties(shape4, props1, false, true);\n\t\tdouble s2 = GetSurfaceProperties(result, props2, false, true);\n\t\tdouble tol = 0.1;\n\t\tdouble res3 = abs(s1 - s2);\n\t\tCHECK(res3 <= tol);\n\t\tIndexSet<TopoShape> solidEdges1, solidEdges2;\n\t\tTopoExplorerTool::MapShapes(shape4, ShapeType::Edge, solidEdges1);\n\t\tTopoExplorerTool::MapShapes(result, ShapeType::Edge, solidEdges2);\n\t\tpair<Point3, Point3> pa1 = NurbsReadCurve(solidEdges1[6]);\n\t\tpair<Point3, Point3> pa2 = NurbsReadCurve(solidEdges2[1]);\n\t\tPoint3 sp1 = pa1.first;\n\t\tPoint3 sp2 = pa2.first;\n\t\tPoint3 ep1 = pa1.second;\n\t\tPoint3 ep2 = pa2.second;\n\t\tCHECK(sp1.IsEqual(sp2, 1e-7) == true);\n\t\tCHECK(ep1.IsEqual(ep2, 1e-7) == true);\n\t\tint num = 1000;\n\t\tdouble tolGen = 1e-7;\n\t\tdouble res4 = NurbsSampleParameter(num, tolGen, solidEdges2[1], result);\n\t\tCHECK(res4 <= 0.1);\n\t\tOCCTIO::OCCTTool::Write(inputFace, outdir + \"src.brep\");\n\t\tOCCTIO::OCCTTool::Write(shape1, outdir + \"shape1.brep\");\n\t\tOCCTIO::OCCTTool::Write(shape4, outdir + \"shape4.brep\");\n\t\tOCCTIO::OCCTTool::Write(solidEdges1[6], outdir + \"edge1.brep\");\n\t\tOCCTIO::OCCTTool::Write(solidEdges2[1], outdir + \"edge2.brep\");\n\t\tOCCTIO::OCCTTool::Write(wire, outdir + \"wire.brep\");\n\t\tOCCTIO::OCCTTool::Write(result, outdir + \"result.brep\");\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static std::pair<std::shared_ptr<Geom3BSplineSurface>, double> RebuildSurface(const std::shared_ptr<Geom3BSplineSurface>& srcSurf, int targetUDeg, int targetVDeg, double tol)\t @return The rebuit surface and the error\n\t @param tol Target tolerance between source surface and result surface. It is usally set over 1e-2 to guarantee the time performance\n\t @param targetVDeg Target v degree\n\t @param targetUDeg Target u degree\n\t @param srcSurf Source surface\n\t @brief Rebuild surface with target degree and target tolerance\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <nurbs/NURBSAPIRebuild.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeFace.hpp>\n#include <nurbs/NURBSAPISweep.hpp>\n#include <topology/BRepExtremaDistShapeShape.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <nurbs/NURBSAPIBuildCurve.hpp>\ndouble NurbsCompareCurve(int num, const shared_ptr<Geom3Curve>& curve1, const shared_ptr<Geom3Curve>& curve2)\n{\n\tdouble maxdist = 0.0;\n\tconst int nsample = num;\n\tdouble fp1 = curve1->FirstParameter();\n\tdouble lp1 = curve1->LastParameter();\n\tdouble delta1 = abs((lp1 - fp1) / nsample);\n\tPoint3 p;\n\tint n = 0;\n\tfor (int i = 0; i < nsample; i++)\n\t{\n\t\tdouble t1 = fp1 + i * delta1;\n\t\tcurve1->D0(t1, p);\n\t\tTopoEdge edge = MakeEdge(curve2);\n\t\tBRepExtremaDistShapeShape shape(MakeVertex(p), edge);\n\t\tdouble dist = shape.Value();\n\t\tif (dist > maxdist)\n\t\t{\n\t\t\tmaxdist = dist;\n\t\t}\n\t}\n\treturn maxdist;\n}\ndouble NurbsCompareSurface(int num, const shared_ptr<Geom3Surface>& surf1, const shared_ptr<Geom3Surface>& surf2)\n{\n\tdouble maxdist = 0.0;\n\tconst int nsample = num;\n\tdouble fpu1 = surf1->FirstUParameter();\n\tdouble lpu1 = surf1->LastUParameter();\n\tdouble fpv1 = surf1->FirstVParameter();\n\tdouble lpv1 = surf1->LastVParameter();\n\tdouble deltaU1 = (lpu1 - fpu1) / nsample;\n\tdouble deltaV1 = (lpv1 - fpv1) / nsample;\n\tPoint3 p1;\n\tint n = 0;\n\tdouble tu1 = 0.0;\n\tdouble tv1 = 0.0;\n\tfor (int i = 0; i < nsample; i++)\n\t{\n\t\ttu1 = fpu1 + i * deltaU1;\n\t\tfor (int j = 0; j < nsample; j++)\n\t\t{\n\t\t\ttv1 = fpv1 + j * deltaV1;\n\t\t\tsurf1->D0(tu1, tv1, p1);\n\t\t\tTopoFace face = MakeFace(surf2, 0.0);\n\t\t\tBRepExtremaDistShapeShape shape(MakeVertex(p1), face);\n\t\t\tdouble dist = shape.Value();\n\t\t\tif (dist > maxdist)\n\t\t\t{\n\t\t\t\tmaxdist = dist;\n\t\t\t}\n\t\t}\n\t}\n\treturn maxdist;\n}\n#include<catch.hpp>\n#include<testHelper.h>\n#include <nurbs/NURBSAPIRebuild.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeFace.hpp>\n#include <nurbs/NURBSAPISweep.hpp>\n#include <topology/BRepExtremaDistShapeShape.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <nurbs/NURBSAPIBuildCurve.hpp>\ndouble NurbsCompareCurve(int num, const shared_ptr<Geom3Curve>& curve1, const shared_ptr<Geom3Curve>& curve2)\n{\n\tdouble maxdist = 0.0;\n\tconst int nsample = num;\n\tdouble fp1 = curve1->FirstParameter();\n\tdouble lp1 = curve1->LastParameter();\n\tdouble delta1 = abs((lp1 - fp1) / nsample);\n\tPoint3 p;\n\tint n = 0;\n\tfor (int i = 0; i < nsample; i++)\n\t{\n\t\tdouble t1 = fp1 + i * delta1;\n\t\tcurve1->D0(t1, p);\n\t\tTopoEdge edge = MakeEdge(curve2);\n\t\tBRepExtremaDistShapeShape shape(MakeVertex(p), edge);\n\t\tdouble dist = shape.Value();\n\t\tif (dist > maxdist)\n\t\t{\n\t\t\tmaxdist = dist;\n\t\t}\n\t}\n\treturn maxdist;\n}\ndouble NurbsCompareSurface(int num, const shared_ptr<Geom3Surface>& surf1, const shared_ptr<Geom3Surface>& surf2)\n{\n\tdouble maxdist = 0.0;\n\tconst int nsample = num;\n\tdouble fpu1 = surf1->FirstUParameter();\n\tdouble lpu1 = surf1->LastUParameter();\n\tdouble fpv1 = surf1->FirstVParameter();\n\tdouble lpv1 = surf1->LastVParameter();\n\tdouble deltaU1 = (lpu1 - fpu1) / nsample;\n\tdouble deltaV1 = (lpv1 - fpv1) / nsample;\n\tPoint3 p1;\n\tint n = 0;\n\tdouble tu1 = 0.0;\n\tdouble tv1 = 0.0;\n\tfor (int i = 0; i < nsample; i++)\n\t{\n\t\ttu1 = fpu1 + i * deltaU1;\n\t\tfor (int j = 0; j < nsample; j++)\n\t\t{\n\t\t\ttv1 = fpv1 + j * deltaV1;\n\t\t\tsurf1->D0(tu1, tv1, p1);\n\t\t\tTopoFace face = MakeFace(surf2, 0.0);\n\t\t\tBRepExtremaDistShapeShape shape(MakeVertex(p1), face);\n\t\t\tdouble dist = shape.Value();\n\t\t\tif (dist > maxdist)\n\t\t\t{\n\t\t\t\tmaxdist = dist;\n\t\t\t}\n\t\t}\n\t}\n\treturn maxdist;\n;\n\tSECTION(\"TestRebuildSurface\")\n\t{\n\t\tOUTPUT_DIRECTORY(nurbs, Rebuild/bug735/RebuildSurface);\n\t\tstd::shared_ptr<Geom3BSplineCurve> bsp1, bsp2;\n\t\t{\n\t\t\tint deg = 3;\n\t\t\tstd::vector<Point3> poles;\n\t\t\tpoles.push_back(Point3(0.0, -1.0, 0.0));\n\t\t\tpoles.push_back(Point3(0.7, -0.7, 0.0));\n\t\t\tpoles.push_back(Point3(1.0, -0.3, 0.0));\n\t\t\tpoles.push_back(Point3(1.2, 0.0, 0.0));\n\t\t\tpoles.push_back(Point3(2.0, 0.3, 0.0));\n\t\t\tpoles.push_back(Point3(0.7, 1.7, 0.0));\n\t\t\tpoles.push_back(Point3(0.0, 1.0, 0.0));\n\t\t\tstd::vector<double> weights;\n\t\t\tweights.push_back(1.0);\n\t\t\tweights.push_back(1.2);\n\t\t\tweights.push_back(1.5);\n\t\t\tweights.push_back(1.0);\n\t\t\tweights.push_back(1.1);\n\t\t\tweights.push_back(1.3);\n\t\t\tweights.push_back(1.0);\n\t\t\tint nknots = static_cast<int>(poles.size()) - deg + 1;\n\t\t\tstd::vector<double> knots(nknots);\n\t\t\tfor (int i = 0; i < nknots; i++)\n\t\t\t{\n\t\t\t\tknots[i] = (double)i / (double)(nknots - 1.0);\n\t\t\t}\n\t\t\tstd::vector<int> mults(nknots, 1);\n\t\t\tmults.front() = 4;\n\t\t\tmults.back() = 4;\n\t\t\tbsp1 = std::make_shared<Geom3BSplineCurve>(poles, weights, knots, mults, deg);\n\t\t}\n\t\t{\n\t\t\tstd::vector<Point3> spinePoles;\n\t\t\tstd::vector<double> spineKnots(4);\n\t\t\tstd::vector<int> spineMults(4, 1);\n\t\t\tspinePoles.push_back(Point3(0.0, -1.0, 0.0));\n\t\t\tspinePoles.push_back(Point3(-0.1, -0.8, 1.0));\n\t\t\tspinePoles.push_back(Point3(0.1, -0.5, 2.0));\n\t\t\tspinePoles.push_back(Point3(0.2, -0.7, 3.0));\n\t\t\tspinePoles.push_back(Point3(0.1, -0.9, 3.5));\n\t\t\tspinePoles.push_back(Point3(0.0, -1.1, 4.5));\n\t\t\tstd::vector<double> weights;\n\t\t\tweights.push_back(1.4);\n\t\t\tweights.push_back(1.7);\n\t\t\tweights.push_back(1.1);\n\t\t\tweights.push_back(1.3);\n\t\t\tweights.push_back(1.0);\n\t\t\tweights.push_back(0.9);\n\t\t\tspineKnots[0] = 0;\n\t\t\tspineKnots[1] = 1.0 / 3.0;\n\t\t\tspineKnots[2] = 2.0 / 3.0;\n\t\t\tspineKnots[3] = 1;\n\t\t\tspineMults.front() = 4;\n\t\t\tspineMults.back() = 4;\n\t\t\tbsp2 = std::make_shared<Geom3BSplineCurve>(spinePoles, weights, spineKnots, spineMults, 3);\n\t\t}\n\t\tbool isParallel = false;\n\t\tauto tmp = NURBSAPISweep::SweepOneRail(bsp1, bsp2, isParallel);\n\t\tconst auto& bsp3 = tmp[0];\n\t\tclock_t bg = clock();\n\t\tauto [oldbsp4, olderr] = NURBSAPIRebuild::RebuildSurface(bsp3, 3, 3, 20, 10);\n\t\tclock_t ed = clock();\n\t\tauto [bsp4, err] = NURBSAPIRebuild::RebuildSurface(bsp3, 11, 11, 30, 20);\n\t\tCHECK(bsp4->UDegree() == 11);\n\t\tCHECK(bsp4->VDegree() == 11);\n\t\tCHECK(bsp4->NUPoles() == 30);\n\t\tCHECK(bsp4->NVPoles() == 20);\n\t\tOCCTIO::OCCTTool::Write(MakeEdge(bsp1), outdir + \"bsp11.brep\");\n\t\tOCCTIO::OCCTTool::Write(MakeEdge(bsp2), outdir + \"bsp21.brep\");\n\t\tOCCTIO::OCCTTool::Write(MakeFace(bsp3, 0.0), outdir + \"src1.brep\");\n\t\tOCCTIO::OCCTTool::Write(MakeFace(bsp4, 0.0), outdir + \"result1.brep\");\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static std::pair<std::shared_ptr<Geom3BSplineSurface>, double> RebuildSurface(const std::shared_ptr<Geom3BSplineSurface>& srcSurf, int targetUDeg, int targetVDeg, int targetNUPoles, int targetNVPoles, const std::vector<double>& uknots, const std::vector<double>& vknots, const std::vector<int>& umults, const std::vector<int>& vmults)\t @return The rebuit surface and the error\n\t @param vmults Target v multipicities\n\t @param umults Target u multipicities\n\t @param vknots Target v knots\n\t @param uknots Target u knots\n\t @param targetNVPoles Target number of v poles\n\t @param targetNUPoles Target number of u poles\n\t @param targetVDeg Target v degree\n\t @param targetUDeg Target u degree\n\t @param srcSurf Source surface\n\t @brief Rebuild surface with target degree, target number of poles, target uv knots and mults\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <nurbs/NURBSAPIRebuild.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeFace.hpp>\n#include <nurbs/NURBSAPISweep.hpp>\n#include <topology/BRepExtremaDistShapeShape.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <nurbs/NURBSAPIBuildCurve.hpp>\ndouble NurbsCompareCurve(int num, const shared_ptr<Geom3Curve>& curve1, const shared_ptr<Geom3Curve>& curve2)\n{\n\tdouble maxdist = 0.0;\n\tconst int nsample = num;\n\tdouble fp1 = curve1->FirstParameter();\n\tdouble lp1 = curve1->LastParameter();\n\tdouble delta1 = abs((lp1 - fp1) / nsample);\n\tPoint3 p;\n\tint n = 0;\n\tfor (int i = 0; i < nsample; i++)\n\t{\n\t\tdouble t1 = fp1 + i * delta1;\n\t\tcurve1->D0(t1, p);\n\t\tTopoEdge edge = MakeEdge(curve2);\n\t\tBRepExtremaDistShapeShape shape(MakeVertex(p), edge);\n\t\tdouble dist = shape.Value();\n\t\tif (dist > maxdist)\n\t\t{\n\t\t\tmaxdist = dist;\n\t\t}\n\t}\n\treturn maxdist;\n}\ndouble NurbsCompareSurface(int num, const shared_ptr<Geom3Surface>& surf1, const shared_ptr<Geom3Surface>& surf2)\n{\n\tdouble maxdist = 0.0;\n\tconst int nsample = num;\n\tdouble fpu1 = surf1->FirstUParameter();\n\tdouble lpu1 = surf1->LastUParameter();\n\tdouble fpv1 = surf1->FirstVParameter();\n\tdouble lpv1 = surf1->LastVParameter();\n\tdouble deltaU1 = (lpu1 - fpu1) / nsample;\n\tdouble deltaV1 = (lpv1 - fpv1) / nsample;\n\tPoint3 p1;\n\tint n = 0;\n\tdouble tu1 = 0.0;\n\tdouble tv1 = 0.0;\n\tfor (int i = 0; i < nsample; i++)\n\t{\n\t\ttu1 = fpu1 + i * deltaU1;\n\t\tfor (int j = 0; j < nsample; j++)\n\t\t{\n\t\t\ttv1 = fpv1 + j * deltaV1;\n\t\t\tsurf1->D0(tu1, tv1, p1);\n\t\t\tTopoFace face = MakeFace(surf2, 0.0);\n\t\t\tBRepExtremaDistShapeShape shape(MakeVertex(p1), face);\n\t\t\tdouble dist = shape.Value();\n\t\t\tif (dist > maxdist)\n\t\t\t{\n\t\t\t\tmaxdist = dist;\n\t\t\t}\n\t\t}\n\t}\n\treturn maxdist;\n}\n#include<catch.hpp>\n#include<testHelper.h>\n#include <nurbs/NURBSAPIRebuild.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeFace.hpp>\n#include <nurbs/NURBSAPISweep.hpp>\n#include <topology/BRepExtremaDistShapeShape.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <nurbs/NURBSAPIBuildCurve.hpp>\ndouble NurbsCompareCurve(int num, const shared_ptr<Geom3Curve>& curve1, const shared_ptr<Geom3Curve>& curve2)\n{\n\tdouble maxdist = 0.0;\n\tconst int nsample = num;\n\tdouble fp1 = curve1->FirstParameter();\n\tdouble lp1 = curve1->LastParameter();\n\tdouble delta1 = abs((lp1 - fp1) / nsample);\n\tPoint3 p;\n\tint n = 0;\n\tfor (int i = 0; i < nsample; i++)\n\t{\n\t\tdouble t1 = fp1 + i * delta1;\n\t\tcurve1->D0(t1, p);\n\t\tTopoEdge edge = MakeEdge(curve2);\n\t\tBRepExtremaDistShapeShape shape(MakeVertex(p), edge);\n\t\tdouble dist = shape.Value();\n\t\tif (dist > maxdist)\n\t\t{\n\t\t\tmaxdist = dist;\n\t\t}\n\t}\n\treturn maxdist;\n}\ndouble NurbsCompareSurface(int num, const shared_ptr<Geom3Surface>& surf1, const shared_ptr<Geom3Surface>& surf2)\n{\n\tdouble maxdist = 0.0;\n\tconst int nsample = num;\n\tdouble fpu1 = surf1->FirstUParameter();\n\tdouble lpu1 = surf1->LastUParameter();\n\tdouble fpv1 = surf1->FirstVParameter();\n\tdouble lpv1 = surf1->LastVParameter();\n\tdouble deltaU1 = (lpu1 - fpu1) / nsample;\n\tdouble deltaV1 = (lpv1 - fpv1) / nsample;\n\tPoint3 p1;\n\tint n = 0;\n\tdouble tu1 = 0.0;\n\tdouble tv1 = 0.0;\n\tfor (int i = 0; i < nsample; i++)\n\t{\n\t\ttu1 = fpu1 + i * deltaU1;\n\t\tfor (int j = 0; j < nsample; j++)\n\t\t{\n\t\t\ttv1 = fpv1 + j * deltaV1;\n\t\t\tsurf1->D0(tu1, tv1, p1);\n\t\t\tTopoFace face = MakeFace(surf2, 0.0);\n\t\t\tBRepExtremaDistShapeShape shape(MakeVertex(p1), face);\n\t\t\tdouble dist = shape.Value();\n\t\t\tif (dist > maxdist)\n\t\t\t{\n\t\t\t\tmaxdist = dist;\n\t\t\t}\n\t\t}\n\t}\n\treturn maxdist;\n;\n\tSECTION(\"TestRebuildSurface\")\n\t{\n\t\tOUTPUT_DIRECTORY(nurbs, Rebuild/bug735/RebuildSurface);\n\t\tstd::shared_ptr<Geom3BSplineCurve> bsp1, bsp2;\n\t\t{\n\t\t\tint deg = 3;\n\t\t\tstd::vector<Point3> poles;\n\t\t\tpoles.push_back(Point3(0.0, -1.0, 0.0));\n\t\t\tpoles.push_back(Point3(0.7, -0.7, 0.0));\n\t\t\tpoles.push_back(Point3(1.0, -0.3, 0.0));\n\t\t\tpoles.push_back(Point3(1.2, 0.0, 0.0));\n\t\t\tpoles.push_back(Point3(2.0, 0.3, 0.0));\n\t\t\tpoles.push_back(Point3(0.7, 1.7, 0.0));\n\t\t\tpoles.push_back(Point3(0.0, 1.0, 0.0));\n\t\t\tstd::vector<double> weights;\n\t\t\tweights.push_back(1.0);\n\t\t\tweights.push_back(1.2);\n\t\t\tweights.push_back(1.5);\n\t\t\tweights.push_back(1.0);\n\t\t\tweights.push_back(1.1);\n\t\t\tweights.push_back(1.3);\n\t\t\tweights.push_back(1.0);\n\t\t\tint nknots = static_cast<int>(poles.size()) - deg + 1;\n\t\t\tstd::vector<double> knots(nknots);\n\t\t\tfor (int i = 0; i < nknots; i++)\n\t\t\t{\n\t\t\t\tknots[i] = (double)i / (double)(nknots - 1.0);\n\t\t\t}\n\t\t\tstd::vector<int> mults(nknots, 1);\n\t\t\tmults.front() = 4;\n\t\t\tmults.back() = 4;\n\t\t\tbsp1 = std::make_shared<Geom3BSplineCurve>(poles, weights, knots, mults, deg);\n\t\t}\n\t\t{\n\t\t\tstd::vector<Point3> spinePoles;\n\t\t\tstd::vector<double> spineKnots(4);\n\t\t\tstd::vector<int> spineMults(4, 1);\n\t\t\tspinePoles.push_back(Point3(0.0, -1.0, 0.0));\n\t\t\tspinePoles.push_back(Point3(-0.1, -0.8, 1.0));\n\t\t\tspinePoles.push_back(Point3(0.1, -0.5, 2.0));\n\t\t\tspinePoles.push_back(Point3(0.2, -0.7, 3.0));\n\t\t\tspinePoles.push_back(Point3(0.1, -0.9, 3.5));\n\t\t\tspinePoles.push_back(Point3(0.0, -1.1, 4.5));\n\t\t\tstd::vector<double> weights;\n\t\t\tweights.push_back(1.4);\n\t\t\tweights.push_back(1.7);\n\t\t\tweights.push_back(1.1);\n\t\t\tweights.push_back(1.3);\n\t\t\tweights.push_back(1.0);\n\t\t\tweights.push_back(0.9);\n\t\t\tspineKnots[0] = 0;\n\t\t\tspineKnots[1] = 1.0 / 3.0;\n\t\t\tspineKnots[2] = 2.0 / 3.0;\n\t\t\tspineKnots[3] = 1;\n\t\t\tspineMults.front() = 4;\n\t\t\tspineMults.back() = 4;\n\t\t\tbsp2 = std::make_shared<Geom3BSplineCurve>(spinePoles, weights, spineKnots, spineMults, 3);\n\t\t}\n\t\tbool isParallel = false;\n\t\tauto tmp = NURBSAPISweep::SweepOneRail(bsp1, bsp2, isParallel);\n\t\tconst auto& bsp3 = tmp[0];\n\t\tclock_t bg = clock();\n\t\tauto [oldbsp4, olderr] = NURBSAPIRebuild::RebuildSurface(bsp3, 3, 3, 20, 10);\n\t\tclock_t ed = clock();\n\t\tauto [bsp4, err] = NURBSAPIRebuild::RebuildSurface(bsp3, 11, 11, 30, 20);\n\t\tCHECK(bsp4->UDegree() == 11);\n\t\tCHECK(bsp4->VDegree() == 11);\n\t\tCHECK(bsp4->NUPoles() == 30);\n\t\tCHECK(bsp4->NVPoles() == 20);\n\t\tOCCTIO::OCCTTool::Write(MakeEdge(bsp1), outdir + \"bsp11.brep\");\n\t\tOCCTIO::OCCTTool::Write(MakeEdge(bsp2), outdir + \"bsp21.brep\");\n\t\tOCCTIO::OCCTTool::Write(MakeFace(bsp3, 0.0), outdir + \"src1.brep\");\n\t\tOCCTIO::OCCTTool::Write(MakeFace(bsp4, 0.0), outdir + \"result1.brep\");\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static std::pair<std::shared_ptr<Geom3BSplineSurface>, double> RebuildSurface(const std::shared_ptr<Geom3BSplineSurface>& srcSurf, int targetUDeg, int targetVDeg, int targetNUPoles, int targetNVPoles)\t @return The rebuit surface and the error\n\t @param targetNVPoles Target number of v poles\n\t @param targetNUPoles Target number of u poles\n\t @param targetVDeg Target v degree\n\t @param targetUDeg Target u degree\n\t @param srcSurf Source surface\n\t @brief Rebuild surface with target degree and target number of poles\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <nurbs/NURBSAPIRebuild.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeFace.hpp>\n#include <nurbs/NURBSAPISweep.hpp>\n#include <topology/BRepExtremaDistShapeShape.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <nurbs/NURBSAPIBuildCurve.hpp>\ndouble NurbsCompareCurve(int num, const shared_ptr<Geom3Curve>& curve1, const shared_ptr<Geom3Curve>& curve2)\n{\n\tdouble maxdist = 0.0;\n\tconst int nsample = num;\n\tdouble fp1 = curve1->FirstParameter();\n\tdouble lp1 = curve1->LastParameter();\n\tdouble delta1 = abs((lp1 - fp1) / nsample);\n\tPoint3 p;\n\tint n = 0;\n\tfor (int i = 0; i < nsample; i++)\n\t{\n\t\tdouble t1 = fp1 + i * delta1;\n\t\tcurve1->D0(t1, p);\n\t\tTopoEdge edge = MakeEdge(curve2);\n\t\tBRepExtremaDistShapeShape shape(MakeVertex(p), edge);\n\t\tdouble dist = shape.Value();\n\t\tif (dist > maxdist)\n\t\t{\n\t\t\tmaxdist = dist;\n\t\t}\n\t}\n\treturn maxdist;\n}\ndouble NurbsCompareSurface(int num, const shared_ptr<Geom3Surface>& surf1, const shared_ptr<Geom3Surface>& surf2)\n{\n\tdouble maxdist = 0.0;\n\tconst int nsample = num;\n\tdouble fpu1 = surf1->FirstUParameter();\n\tdouble lpu1 = surf1->LastUParameter();\n\tdouble fpv1 = surf1->FirstVParameter();\n\tdouble lpv1 = surf1->LastVParameter();\n\tdouble deltaU1 = (lpu1 - fpu1) / nsample;\n\tdouble deltaV1 = (lpv1 - fpv1) / nsample;\n\tPoint3 p1;\n\tint n = 0;\n\tdouble tu1 = 0.0;\n\tdouble tv1 = 0.0;\n\tfor (int i = 0; i < nsample; i++)\n\t{\n\t\ttu1 = fpu1 + i * deltaU1;\n\t\tfor (int j = 0; j < nsample; j++)\n\t\t{\n\t\t\ttv1 = fpv1 + j * deltaV1;\n\t\t\tsurf1->D0(tu1, tv1, p1);\n\t\t\tTopoFace face = MakeFace(surf2, 0.0);\n\t\t\tBRepExtremaDistShapeShape shape(MakeVertex(p1), face);\n\t\t\tdouble dist = shape.Value();\n\t\t\tif (dist > maxdist)\n\t\t\t{\n\t\t\t\tmaxdist = dist;\n\t\t\t}\n\t\t}\n\t}\n\treturn maxdist;\n}\n#include<catch.hpp>\n#include<testHelper.h>\n#include <nurbs/NURBSAPIRebuild.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeFace.hpp>\n#include <nurbs/NURBSAPISweep.hpp>\n#include <topology/BRepExtremaDistShapeShape.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <nurbs/NURBSAPIBuildCurve.hpp>\ndouble NurbsCompareCurve(int num, const shared_ptr<Geom3Curve>& curve1, const shared_ptr<Geom3Curve>& curve2)\n{\n\tdouble maxdist = 0.0;\n\tconst int nsample = num;\n\tdouble fp1 = curve1->FirstParameter();\n\tdouble lp1 = curve1->LastParameter();\n\tdouble delta1 = abs((lp1 - fp1) / nsample);\n\tPoint3 p;\n\tint n = 0;\n\tfor (int i = 0; i < nsample; i++)\n\t{\n\t\tdouble t1 = fp1 + i * delta1;\n\t\tcurve1->D0(t1, p);\n\t\tTopoEdge edge = MakeEdge(curve2);\n\t\tBRepExtremaDistShapeShape shape(MakeVertex(p), edge);\n\t\tdouble dist = shape.Value();\n\t\tif (dist > maxdist)\n\t\t{\n\t\t\tmaxdist = dist;\n\t\t}\n\t}\n\treturn maxdist;\n}\ndouble NurbsCompareSurface(int num, const shared_ptr<Geom3Surface>& surf1, const shared_ptr<Geom3Surface>& surf2)\n{\n\tdouble maxdist = 0.0;\n\tconst int nsample = num;\n\tdouble fpu1 = surf1->FirstUParameter();\n\tdouble lpu1 = surf1->LastUParameter();\n\tdouble fpv1 = surf1->FirstVParameter();\n\tdouble lpv1 = surf1->LastVParameter();\n\tdouble deltaU1 = (lpu1 - fpu1) / nsample;\n\tdouble deltaV1 = (lpv1 - fpv1) / nsample;\n\tPoint3 p1;\n\tint n = 0;\n\tdouble tu1 = 0.0;\n\tdouble tv1 = 0.0;\n\tfor (int i = 0; i < nsample; i++)\n\t{\n\t\ttu1 = fpu1 + i * deltaU1;\n\t\tfor (int j = 0; j < nsample; j++)\n\t\t{\n\t\t\ttv1 = fpv1 + j * deltaV1;\n\t\t\tsurf1->D0(tu1, tv1, p1);\n\t\t\tTopoFace face = MakeFace(surf2, 0.0);\n\t\t\tBRepExtremaDistShapeShape shape(MakeVertex(p1), face);\n\t\t\tdouble dist = shape.Value();\n\t\t\tif (dist > maxdist)\n\t\t\t{\n\t\t\t\tmaxdist = dist;\n\t\t\t}\n\t\t}\n\t}\n\treturn maxdist;\n;\n\tSECTION(\"TestRebuildSurface\")\n\t{\n\t\tOUTPUT_DIRECTORY(nurbs, Rebuild/bug735/RebuildSurface);\n\t\tstd::shared_ptr<Geom3BSplineCurve> bsp1, bsp2;\n\t\t{\n\t\t\tint deg = 3;\n\t\t\tstd::vector<Point3> poles;\n\t\t\tpoles.push_back(Point3(0.0, -1.0, 0.0));\n\t\t\tpoles.push_back(Point3(0.7, -0.7, 0.0));\n\t\t\tpoles.push_back(Point3(1.0, -0.3, 0.0));\n\t\t\tpoles.push_back(Point3(1.2, 0.0, 0.0));\n\t\t\tpoles.push_back(Point3(2.0, 0.3, 0.0));\n\t\t\tpoles.push_back(Point3(0.7, 1.7, 0.0));\n\t\t\tpoles.push_back(Point3(0.0, 1.0, 0.0));\n\t\t\tstd::vector<double> weights;\n\t\t\tweights.push_back(1.0);\n\t\t\tweights.push_back(1.2);\n\t\t\tweights.push_back(1.5);\n\t\t\tweights.push_back(1.0);\n\t\t\tweights.push_back(1.1);\n\t\t\tweights.push_back(1.3);\n\t\t\tweights.push_back(1.0);\n\t\t\tint nknots = static_cast<int>(poles.size()) - deg + 1;\n\t\t\tstd::vector<double> knots(nknots);\n\t\t\tfor (int i = 0; i < nknots; i++)\n\t\t\t{\n\t\t\t\tknots[i] = (double)i / (double)(nknots - 1.0);\n\t\t\t}\n\t\t\tstd::vector<int> mults(nknots, 1);\n\t\t\tmults.front() = 4;\n\t\t\tmults.back() = 4;\n\t\t\tbsp1 = std::make_shared<Geom3BSplineCurve>(poles, weights, knots, mults, deg);\n\t\t}\n\t\t{\n\t\t\tstd::vector<Point3> spinePoles;\n\t\t\tstd::vector<double> spineKnots(4);\n\t\t\tstd::vector<int> spineMults(4, 1);\n\t\t\tspinePoles.push_back(Point3(0.0, -1.0, 0.0));\n\t\t\tspinePoles.push_back(Point3(-0.1, -0.8, 1.0));\n\t\t\tspinePoles.push_back(Point3(0.1, -0.5, 2.0));\n\t\t\tspinePoles.push_back(Point3(0.2, -0.7, 3.0));\n\t\t\tspinePoles.push_back(Point3(0.1, -0.9, 3.5));\n\t\t\tspinePoles.push_back(Point3(0.0, -1.1, 4.5));\n\t\t\tstd::vector<double> weights;\n\t\t\tweights.push_back(1.4);\n\t\t\tweights.push_back(1.7);\n\t\t\tweights.push_back(1.1);\n\t\t\tweights.push_back(1.3);\n\t\t\tweights.push_back(1.0);\n\t\t\tweights.push_back(0.9);\n\t\t\tspineKnots[0] = 0;\n\t\t\tspineKnots[1] = 1.0 / 3.0;\n\t\t\tspineKnots[2] = 2.0 / 3.0;\n\t\t\tspineKnots[3] = 1;\n\t\t\tspineMults.front() = 4;\n\t\t\tspineMults.back() = 4;\n\t\t\tbsp2 = std::make_shared<Geom3BSplineCurve>(spinePoles, weights, spineKnots, spineMults, 3);\n\t\t}\n\t\tbool isParallel = false;\n\t\tauto tmp = NURBSAPISweep::SweepOneRail(bsp1, bsp2, isParallel);\n\t\tconst auto& bsp3 = tmp[0];\n\t\tclock_t bg = clock();\n\t\tauto [oldbsp4, olderr] = NURBSAPIRebuild::RebuildSurface(bsp3, 3, 3, 20, 10);\n\t\tclock_t ed = clock();\n\t\tauto [bsp4, err] = NURBSAPIRebuild::RebuildSurface(bsp3, 11, 11, 30, 20);\n\t\tCHECK(bsp4->UDegree() == 11);\n\t\tCHECK(bsp4->VDegree() == 11);\n\t\tCHECK(bsp4->NUPoles() == 30);\n\t\tCHECK(bsp4->NVPoles() == 20);\n\t\tOCCTIO::OCCTTool::Write(MakeEdge(bsp1), outdir + \"bsp11.brep\");\n\t\tOCCTIO::OCCTTool::Write(MakeEdge(bsp2), outdir + \"bsp21.brep\");\n\t\tOCCTIO::OCCTTool::Write(MakeFace(bsp3, 0.0), outdir + \"src1.brep\");\n\t\tOCCTIO::OCCTTool::Write(MakeFace(bsp4, 0.0), outdir + \"result1.brep\");\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static std::pair<std::shared_ptr<Geom2BSplineCurve>, double> RebuildCurve(const std::shared_ptr<Geom2BSplineCurve>& srcCurve, int targetDeg, double tol, bool isForceNonRational)\t @return The rebuilt curve and the error\n\t @param isForceNonRational Is result non-rational\n\t @param tol The tolerance of source curve and result curve. It is usally set over 1e-2 to guarantee the time performance\n\t @param targetDeg Target degree\n\t @param srcCurve Source curve\n\t @brief Rebuild 2d curve with target degree and target tolerance.\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <nurbs/NURBSAPIRebuild.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeFace.hpp>\n#include <nurbs/NURBSAPISweep.hpp>\n#include <topology/BRepExtremaDistShapeShape.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <nurbs/NURBSAPIBuildCurve.hpp>\ndouble NurbsCompareCurve(int num, const shared_ptr<Geom3Curve>& curve1, const shared_ptr<Geom3Curve>& curve2)\n{\n\tdouble maxdist = 0.0;\n\tconst int nsample = num;\n\tdouble fp1 = curve1->FirstParameter();\n\tdouble lp1 = curve1->LastParameter();\n\tdouble delta1 = abs((lp1 - fp1) / nsample);\n\tPoint3 p;\n\tint n = 0;\n\tfor (int i = 0; i < nsample; i++)\n\t{\n\t\tdouble t1 = fp1 + i * delta1;\n\t\tcurve1->D0(t1, p);\n\t\tTopoEdge edge = MakeEdge(curve2);\n\t\tBRepExtremaDistShapeShape shape(MakeVertex(p), edge);\n\t\tdouble dist = shape.Value();\n\t\tif (dist > maxdist)\n\t\t{\n\t\t\tmaxdist = dist;\n\t\t}\n\t}\n\treturn maxdist;\n}\ndouble NurbsCompareSurface(int num, const shared_ptr<Geom3Surface>& surf1, const shared_ptr<Geom3Surface>& surf2)\n{\n\tdouble maxdist = 0.0;\n\tconst int nsample = num;\n\tdouble fpu1 = surf1->FirstUParameter();\n\tdouble lpu1 = surf1->LastUParameter();\n\tdouble fpv1 = surf1->FirstVParameter();\n\tdouble lpv1 = surf1->LastVParameter();\n\tdouble deltaU1 = (lpu1 - fpu1) / nsample;\n\tdouble deltaV1 = (lpv1 - fpv1) / nsample;\n\tPoint3 p1;\n\tint n = 0;\n\tdouble tu1 = 0.0;\n\tdouble tv1 = 0.0;\n\tfor (int i = 0; i < nsample; i++)\n\t{\n\t\ttu1 = fpu1 + i * deltaU1;\n\t\tfor (int j = 0; j < nsample; j++)\n\t\t{\n\t\t\ttv1 = fpv1 + j * deltaV1;\n\t\t\tsurf1->D0(tu1, tv1, p1);\n\t\t\tTopoFace face = MakeFace(surf2, 0.0);\n\t\t\tBRepExtremaDistShapeShape shape(MakeVertex(p1), face);\n\t\t\tdouble dist = shape.Value();\n\t\t\tif (dist > maxdist)\n\t\t\t{\n\t\t\t\tmaxdist = dist;\n\t\t\t}\n\t\t}\n\t}\n\treturn maxdist;\n}\n#include<catch.hpp>\n#include<testHelper.h>\n#include <nurbs/NURBSAPIRebuild.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeFace.hpp>\n#include <nurbs/NURBSAPISweep.hpp>\n#include <topology/BRepExtremaDistShapeShape.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <nurbs/NURBSAPIBuildCurve.hpp>\ndouble NurbsCompareCurve(int num, const shared_ptr<Geom3Curve>& curve1, const shared_ptr<Geom3Curve>& curve2)\n{\n\tdouble maxdist = 0.0;\n\tconst int nsample = num;\n\tdouble fp1 = curve1->FirstParameter();\n\tdouble lp1 = curve1->LastParameter();\n\tdouble delta1 = abs((lp1 - fp1) / nsample);\n\tPoint3 p;\n\tint n = 0;\n\tfor (int i = 0; i < nsample; i++)\n\t{\n\t\tdouble t1 = fp1 + i * delta1;\n\t\tcurve1->D0(t1, p);\n\t\tTopoEdge edge = MakeEdge(curve2);\n\t\tBRepExtremaDistShapeShape shape(MakeVertex(p), edge);\n\t\tdouble dist = shape.Value();\n\t\tif (dist > maxdist)\n\t\t{\n\t\t\tmaxdist = dist;\n\t\t}\n\t}\n\treturn maxdist;\n}\ndouble NurbsCompareSurface(int num, const shared_ptr<Geom3Surface>& surf1, const shared_ptr<Geom3Surface>& surf2)\n{\n\tdouble maxdist = 0.0;\n\tconst int nsample = num;\n\tdouble fpu1 = surf1->FirstUParameter();\n\tdouble lpu1 = surf1->LastUParameter();\n\tdouble fpv1 = surf1->FirstVParameter();\n\tdouble lpv1 = surf1->LastVParameter();\n\tdouble deltaU1 = (lpu1 - fpu1) / nsample;\n\tdouble deltaV1 = (lpv1 - fpv1) / nsample;\n\tPoint3 p1;\n\tint n = 0;\n\tdouble tu1 = 0.0;\n\tdouble tv1 = 0.0;\n\tfor (int i = 0; i < nsample; i++)\n\t{\n\t\ttu1 = fpu1 + i * deltaU1;\n\t\tfor (int j = 0; j < nsample; j++)\n\t\t{\n\t\t\ttv1 = fpv1 + j * deltaV1;\n\t\t\tsurf1->D0(tu1, tv1, p1);\n\t\t\tTopoFace face = MakeFace(surf2, 0.0);\n\t\t\tBRepExtremaDistShapeShape shape(MakeVertex(p1), face);\n\t\t\tdouble dist = shape.Value();\n\t\t\tif (dist > maxdist)\n\t\t\t{\n\t\t\t\tmaxdist = dist;\n\t\t\t}\n\t\t}\n\t}\n\treturn maxdist;\n;\n\tSECTION(\"TestRebuildCurve\")\n\t{\n\t\tOUTPUT_DIRECTORY(nurbs, Rebuild/RebuildCurve);\n\t\tint deg = 3;\n\t\tstd::vector<Point3> poles;\n\t\tpoles.push_back(Point3(0., -1., 0.));\n\t\tpoles.push_back(Point3(.7, -.7, 0.));\n\t\tpoles.push_back(Point3(1., -.3, 0.));\n\t\tpoles.push_back(Point3(1.2, 0., 0.));\n\t\tpoles.push_back(Point3(2., .3, 0.));\n\t\tpoles.push_back(Point3(.7, 1.7, 0.));\n\t\tpoles.push_back(Point3(0., 1., 0.));\n\t\tstd::vector<double> weights;\n\t\tweights.push_back(0.8);\n\t\tweights.push_back(0.9);\n\t\tweights.push_back(1.1);\n\t\tweights.push_back(0.3);\n\t\tweights.push_back(0.6);\n\t\tweights.push_back(1.2);\n\t\tweights.push_back(0.8);\n\t\tint nknots = static_cast<int>(poles.size()) - deg + 1;\n\t\tstd::vector<double> knots(nknots);\n\t\tfor (int i = 0; i < nknots; i++)\n\t\t{\n\t\t\tknots[i] = (double)i / (double)(nknots - 1);\n\t\t}\n\t\tstd::vector<int> mults(nknots, 1);\n\t\tmults.front() = deg + 1;\n\t\tmults.back() = deg + 1;\n\t\tauto bsp = std::make_shared<Geom3BSplineCurve>(poles, weights, knots, mults, deg);\n\t\tauto [result, error] = NURBSAPIRebuild::RebuildCurve(bsp, 3, 15, false);\n\t\tCHECK(bsp->Degree() == 3);\n\t\tCHECK(bsp->NKnots() == 5);\n\t\tCHECK(bsp->NPoles() == 7);\n\t\tCHECK(result->Degree() == 3);\n\t\tCHECK(result->NKnots() == 13);\n\t\tCHECK(result->NPoles() == 15);\n\t\tdouble dist = NurbsCompareCurve(num, bsp, result);\n\t\tdouble res = abs(dist - error);\n\t\tCHECK(res <= val);\n\t\tOCCTIO::OCCTTool::Write(MakeEdge(bsp), outdir + \"src.brep\");\n\t\tOCCTIO::OCCTTool::Write(MakeEdge(result), outdir + \"result.brep\");\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static std::pair<std::shared_ptr<Geom3BSplineCurve>, double> RebuildCurve(const std::shared_ptr<Geom3BSplineCurve>& srcCurve, int targetDeg, double tol, bool isForceNonRational)\t @return The rebuilt curve and the error\n\t @param isForceNonRational Is result non-rational\n\t @param tol The tolerance of source curve and result curve. It is usally set over 1e-2 to guarantee the time performance\n\t @param targetDeg Target degree\n\t @param srcCurve Source curve\n\t @brief Rebuild curve with target degree and target tolerance.\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <nurbs/NURBSAPIRebuild.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeFace.hpp>\n#include <nurbs/NURBSAPISweep.hpp>\n#include <topology/BRepExtremaDistShapeShape.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <nurbs/NURBSAPIBuildCurve.hpp>\ndouble NurbsCompareCurve(int num, const shared_ptr<Geom3Curve>& curve1, const shared_ptr<Geom3Curve>& curve2)\n{\n\tdouble maxdist = 0.0;\n\tconst int nsample = num;\n\tdouble fp1 = curve1->FirstParameter();\n\tdouble lp1 = curve1->LastParameter();\n\tdouble delta1 = abs((lp1 - fp1) / nsample);\n\tPoint3 p;\n\tint n = 0;\n\tfor (int i = 0; i < nsample; i++)\n\t{\n\t\tdouble t1 = fp1 + i * delta1;\n\t\tcurve1->D0(t1, p);\n\t\tTopoEdge edge = MakeEdge(curve2);\n\t\tBRepExtremaDistShapeShape shape(MakeVertex(p), edge);\n\t\tdouble dist = shape.Value();\n\t\tif (dist > maxdist)\n\t\t{\n\t\t\tmaxdist = dist;\n\t\t}\n\t}\n\treturn maxdist;\n}\ndouble NurbsCompareSurface(int num, const shared_ptr<Geom3Surface>& surf1, const shared_ptr<Geom3Surface>& surf2)\n{\n\tdouble maxdist = 0.0;\n\tconst int nsample = num;\n\tdouble fpu1 = surf1->FirstUParameter();\n\tdouble lpu1 = surf1->LastUParameter();\n\tdouble fpv1 = surf1->FirstVParameter();\n\tdouble lpv1 = surf1->LastVParameter();\n\tdouble deltaU1 = (lpu1 - fpu1) / nsample;\n\tdouble deltaV1 = (lpv1 - fpv1) / nsample;\n\tPoint3 p1;\n\tint n = 0;\n\tdouble tu1 = 0.0;\n\tdouble tv1 = 0.0;\n\tfor (int i = 0; i < nsample; i++)\n\t{\n\t\ttu1 = fpu1 + i * deltaU1;\n\t\tfor (int j = 0; j < nsample; j++)\n\t\t{\n\t\t\ttv1 = fpv1 + j * deltaV1;\n\t\t\tsurf1->D0(tu1, tv1, p1);\n\t\t\tTopoFace face = MakeFace(surf2, 0.0);\n\t\t\tBRepExtremaDistShapeShape shape(MakeVertex(p1), face);\n\t\t\tdouble dist = shape.Value();\n\t\t\tif (dist > maxdist)\n\t\t\t{\n\t\t\t\tmaxdist = dist;\n\t\t\t}\n\t\t}\n\t}\n\treturn maxdist;\n}\n#include<catch.hpp>\n#include<testHelper.h>\n#include <nurbs/NURBSAPIRebuild.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeFace.hpp>\n#include <nurbs/NURBSAPISweep.hpp>\n#include <topology/BRepExtremaDistShapeShape.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <nurbs/NURBSAPIBuildCurve.hpp>\ndouble NurbsCompareCurve(int num, const shared_ptr<Geom3Curve>& curve1, const shared_ptr<Geom3Curve>& curve2)\n{\n\tdouble maxdist = 0.0;\n\tconst int nsample = num;\n\tdouble fp1 = curve1->FirstParameter();\n\tdouble lp1 = curve1->LastParameter();\n\tdouble delta1 = abs((lp1 - fp1) / nsample);\n\tPoint3 p;\n\tint n = 0;\n\tfor (int i = 0; i < nsample; i++)\n\t{\n\t\tdouble t1 = fp1 + i * delta1;\n\t\tcurve1->D0(t1, p);\n\t\tTopoEdge edge = MakeEdge(curve2);\n\t\tBRepExtremaDistShapeShape shape(MakeVertex(p), edge);\n\t\tdouble dist = shape.Value();\n\t\tif (dist > maxdist)\n\t\t{\n\t\t\tmaxdist = dist;\n\t\t}\n\t}\n\treturn maxdist;\n}\ndouble NurbsCompareSurface(int num, const shared_ptr<Geom3Surface>& surf1, const shared_ptr<Geom3Surface>& surf2)\n{\n\tdouble maxdist = 0.0;\n\tconst int nsample = num;\n\tdouble fpu1 = surf1->FirstUParameter();\n\tdouble lpu1 = surf1->LastUParameter();\n\tdouble fpv1 = surf1->FirstVParameter();\n\tdouble lpv1 = surf1->LastVParameter();\n\tdouble deltaU1 = (lpu1 - fpu1) / nsample;\n\tdouble deltaV1 = (lpv1 - fpv1) / nsample;\n\tPoint3 p1;\n\tint n = 0;\n\tdouble tu1 = 0.0;\n\tdouble tv1 = 0.0;\n\tfor (int i = 0; i < nsample; i++)\n\t{\n\t\ttu1 = fpu1 + i * deltaU1;\n\t\tfor (int j = 0; j < nsample; j++)\n\t\t{\n\t\t\ttv1 = fpv1 + j * deltaV1;\n\t\t\tsurf1->D0(tu1, tv1, p1);\n\t\t\tTopoFace face = MakeFace(surf2, 0.0);\n\t\t\tBRepExtremaDistShapeShape shape(MakeVertex(p1), face);\n\t\t\tdouble dist = shape.Value();\n\t\t\tif (dist > maxdist)\n\t\t\t{\n\t\t\t\tmaxdist = dist;\n\t\t\t}\n\t\t}\n\t}\n\treturn maxdist;\n;\n\tSECTION(\"TestRebuildCurve\")\n\t{\n\t\tOUTPUT_DIRECTORY(nurbs, Rebuild/RebuildCurve);\n\t\tint deg = 3;\n\t\tstd::vector<Point3> poles;\n\t\tpoles.push_back(Point3(0., -1., 0.));\n\t\tpoles.push_back(Point3(.7, -.7, 0.));\n\t\tpoles.push_back(Point3(1., -.3, 0.));\n\t\tpoles.push_back(Point3(1.2, 0., 0.));\n\t\tpoles.push_back(Point3(2., .3, 0.));\n\t\tpoles.push_back(Point3(.7, 1.7, 0.));\n\t\tpoles.push_back(Point3(0., 1., 0.));\n\t\tstd::vector<double> weights;\n\t\tweights.push_back(0.8);\n\t\tweights.push_back(0.9);\n\t\tweights.push_back(1.1);\n\t\tweights.push_back(0.3);\n\t\tweights.push_back(0.6);\n\t\tweights.push_back(1.2);\n\t\tweights.push_back(0.8);\n\t\tint nknots = static_cast<int>(poles.size()) - deg + 1;\n\t\tstd::vector<double> knots(nknots);\n\t\tfor (int i = 0; i < nknots; i++)\n\t\t{\n\t\t\tknots[i] = (double)i / (double)(nknots - 1);\n\t\t}\n\t\tstd::vector<int> mults(nknots, 1);\n\t\tmults.front() = deg + 1;\n\t\tmults.back() = deg + 1;\n\t\tauto bsp = std::make_shared<Geom3BSplineCurve>(poles, weights, knots, mults, deg);\n\t\tauto [result, error] = NURBSAPIRebuild::RebuildCurve(bsp, 3, 15, false);\n\t\tCHECK(bsp->Degree() == 3);\n\t\tCHECK(bsp->NKnots() == 5);\n\t\tCHECK(bsp->NPoles() == 7);\n\t\tCHECK(result->Degree() == 3);\n\t\tCHECK(result->NKnots() == 13);\n\t\tCHECK(result->NPoles() == 15);\n\t\tdouble dist = NurbsCompareCurve(num, bsp, result);\n\t\tdouble res = abs(dist - error);\n\t\tCHECK(res <= val);\n\t\tOCCTIO::OCCTTool::Write(MakeEdge(bsp), outdir + \"src.brep\");\n\t\tOCCTIO::OCCTTool::Write(MakeEdge(result), outdir + \"result.brep\");\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static std::pair<std::shared_ptr<Geom3BSplineCurve>, double> RebuildCurve(const std::shared_ptr<Geom3BSplineCurve>& srcCurve, int targetDeg, int targetNPoles, bool isForceNonRational, const std::vector<double>& knots, const std::vector<int>& mults)\t @return The rebuilt curve and the error\n\t @param mults Target mults\n\t @param knots Target knots\n\t @param isForceNonRational Is result non-rational\n\t @param targetNPoles Target number of poles\n\t @param targetDeg Target degree\n\t @param srcCurve Source curve\n\t @brief Rebuild curve with target degree, target number of poles, target uv knots and mults\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <nurbs/NURBSAPIRebuild.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeFace.hpp>\n#include <nurbs/NURBSAPISweep.hpp>\n#include <topology/BRepExtremaDistShapeShape.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <nurbs/NURBSAPIBuildCurve.hpp>\ndouble NurbsCompareCurve(int num, const shared_ptr<Geom3Curve>& curve1, const shared_ptr<Geom3Curve>& curve2)\n{\n\tdouble maxdist = 0.0;\n\tconst int nsample = num;\n\tdouble fp1 = curve1->FirstParameter();\n\tdouble lp1 = curve1->LastParameter();\n\tdouble delta1 = abs((lp1 - fp1) / nsample);\n\tPoint3 p;\n\tint n = 0;\n\tfor (int i = 0; i < nsample; i++)\n\t{\n\t\tdouble t1 = fp1 + i * delta1;\n\t\tcurve1->D0(t1, p);\n\t\tTopoEdge edge = MakeEdge(curve2);\n\t\tBRepExtremaDistShapeShape shape(MakeVertex(p), edge);\n\t\tdouble dist = shape.Value();\n\t\tif (dist > maxdist)\n\t\t{\n\t\t\tmaxdist = dist;\n\t\t}\n\t}\n\treturn maxdist;\n}\ndouble NurbsCompareSurface(int num, const shared_ptr<Geom3Surface>& surf1, const shared_ptr<Geom3Surface>& surf2)\n{\n\tdouble maxdist = 0.0;\n\tconst int nsample = num;\n\tdouble fpu1 = surf1->FirstUParameter();\n\tdouble lpu1 = surf1->LastUParameter();\n\tdouble fpv1 = surf1->FirstVParameter();\n\tdouble lpv1 = surf1->LastVParameter();\n\tdouble deltaU1 = (lpu1 - fpu1) / nsample;\n\tdouble deltaV1 = (lpv1 - fpv1) / nsample;\n\tPoint3 p1;\n\tint n = 0;\n\tdouble tu1 = 0.0;\n\tdouble tv1 = 0.0;\n\tfor (int i = 0; i < nsample; i++)\n\t{\n\t\ttu1 = fpu1 + i * deltaU1;\n\t\tfor (int j = 0; j < nsample; j++)\n\t\t{\n\t\t\ttv1 = fpv1 + j * deltaV1;\n\t\t\tsurf1->D0(tu1, tv1, p1);\n\t\t\tTopoFace face = MakeFace(surf2, 0.0);\n\t\t\tBRepExtremaDistShapeShape shape(MakeVertex(p1), face);\n\t\t\tdouble dist = shape.Value();\n\t\t\tif (dist > maxdist)\n\t\t\t{\n\t\t\t\tmaxdist = dist;\n\t\t\t}\n\t\t}\n\t}\n\treturn maxdist;\n}\n#include<catch.hpp>\n#include<testHelper.h>\n#include <nurbs/NURBSAPIRebuild.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeFace.hpp>\n#include <nurbs/NURBSAPISweep.hpp>\n#include <topology/BRepExtremaDistShapeShape.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <nurbs/NURBSAPIBuildCurve.hpp>\ndouble NurbsCompareCurve(int num, const shared_ptr<Geom3Curve>& curve1, const shared_ptr<Geom3Curve>& curve2)\n{\n\tdouble maxdist = 0.0;\n\tconst int nsample = num;\n\tdouble fp1 = curve1->FirstParameter();\n\tdouble lp1 = curve1->LastParameter();\n\tdouble delta1 = abs((lp1 - fp1) / nsample);\n\tPoint3 p;\n\tint n = 0;\n\tfor (int i = 0; i < nsample; i++)\n\t{\n\t\tdouble t1 = fp1 + i * delta1;\n\t\tcurve1->D0(t1, p);\n\t\tTopoEdge edge = MakeEdge(curve2);\n\t\tBRepExtremaDistShapeShape shape(MakeVertex(p), edge);\n\t\tdouble dist = shape.Value();\n\t\tif (dist > maxdist)\n\t\t{\n\t\t\tmaxdist = dist;\n\t\t}\n\t}\n\treturn maxdist;\n}\ndouble NurbsCompareSurface(int num, const shared_ptr<Geom3Surface>& surf1, const shared_ptr<Geom3Surface>& surf2)\n{\n\tdouble maxdist = 0.0;\n\tconst int nsample = num;\n\tdouble fpu1 = surf1->FirstUParameter();\n\tdouble lpu1 = surf1->LastUParameter();\n\tdouble fpv1 = surf1->FirstVParameter();\n\tdouble lpv1 = surf1->LastVParameter();\n\tdouble deltaU1 = (lpu1 - fpu1) / nsample;\n\tdouble deltaV1 = (lpv1 - fpv1) / nsample;\n\tPoint3 p1;\n\tint n = 0;\n\tdouble tu1 = 0.0;\n\tdouble tv1 = 0.0;\n\tfor (int i = 0; i < nsample; i++)\n\t{\n\t\ttu1 = fpu1 + i * deltaU1;\n\t\tfor (int j = 0; j < nsample; j++)\n\t\t{\n\t\t\ttv1 = fpv1 + j * deltaV1;\n\t\t\tsurf1->D0(tu1, tv1, p1);\n\t\t\tTopoFace face = MakeFace(surf2, 0.0);\n\t\t\tBRepExtremaDistShapeShape shape(MakeVertex(p1), face);\n\t\t\tdouble dist = shape.Value();\n\t\t\tif (dist > maxdist)\n\t\t\t{\n\t\t\t\tmaxdist = dist;\n\t\t\t}\n\t\t}\n\t}\n\treturn maxdist;\n;\n\tSECTION(\"TestRebuildCurve\")\n\t{\n\t\tOUTPUT_DIRECTORY(nurbs, Rebuild/RebuildCurve);\n\t\tint deg = 3;\n\t\tstd::vector<Point3> poles;\n\t\tpoles.push_back(Point3(0., -1., 0.));\n\t\tpoles.push_back(Point3(.7, -.7, 0.));\n\t\tpoles.push_back(Point3(1., -.3, 0.));\n\t\tpoles.push_back(Point3(1.2, 0., 0.));\n\t\tpoles.push_back(Point3(2., .3, 0.));\n\t\tpoles.push_back(Point3(.7, 1.7, 0.));\n\t\tpoles.push_back(Point3(0., 1., 0.));\n\t\tstd::vector<double> weights;\n\t\tweights.push_back(0.8);\n\t\tweights.push_back(0.9);\n\t\tweights.push_back(1.1);\n\t\tweights.push_back(0.3);\n\t\tweights.push_back(0.6);\n\t\tweights.push_back(1.2);\n\t\tweights.push_back(0.8);\n\t\tint nknots = static_cast<int>(poles.size()) - deg + 1;\n\t\tstd::vector<double> knots(nknots);\n\t\tfor (int i = 0; i < nknots; i++)\n\t\t{\n\t\t\tknots[i] = (double)i / (double)(nknots - 1);\n\t\t}\n\t\tstd::vector<int> mults(nknots, 1);\n\t\tmults.front() = deg + 1;\n\t\tmults.back() = deg + 1;\n\t\tauto bsp = std::make_shared<Geom3BSplineCurve>(poles, weights, knots, mults, deg);\n\t\tauto [result, error] = NURBSAPIRebuild::RebuildCurve(bsp, 3, 15, false);\n\t\tCHECK(bsp->Degree() == 3);\n\t\tCHECK(bsp->NKnots() == 5);\n\t\tCHECK(bsp->NPoles() == 7);\n\t\tCHECK(result->Degree() == 3);\n\t\tCHECK(result->NKnots() == 13);\n\t\tCHECK(result->NPoles() == 15);\n\t\tdouble dist = NurbsCompareCurve(num, bsp, result);\n\t\tdouble res = abs(dist - error);\n\t\tCHECK(res <= val);\n\t\tOCCTIO::OCCTTool::Write(MakeEdge(bsp), outdir + \"src.brep\");\n\t\tOCCTIO::OCCTTool::Write(MakeEdge(result), outdir + \"result.brep\");\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static std::pair<std::shared_ptr<Geom3BSplineCurve>, double> RebuildCurve(const std::shared_ptr<Geom3BSplineCurve>& srcCurve, int targetDeg, int targetNPoles, bool isForceNonRational)\t @return The rebuilt curve and the error\n\t @param isForceNonRational Is result non-rational\n\t @param targetNPoles Target number of poles\n\t @param targetDeg Target degree\n\t @param srcCurve Source curve\n\t @brief Rebuild curve with target degree and target number of poles\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <nurbs/NURBSAPIRebuild.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeFace.hpp>\n#include <nurbs/NURBSAPISweep.hpp>\n#include <topology/BRepExtremaDistShapeShape.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <nurbs/NURBSAPIBuildCurve.hpp>\ndouble NurbsCompareCurve(int num, const shared_ptr<Geom3Curve>& curve1, const shared_ptr<Geom3Curve>& curve2)\n{\n\tdouble maxdist = 0.0;\n\tconst int nsample = num;\n\tdouble fp1 = curve1->FirstParameter();\n\tdouble lp1 = curve1->LastParameter();\n\tdouble delta1 = abs((lp1 - fp1) / nsample);\n\tPoint3 p;\n\tint n = 0;\n\tfor (int i = 0; i < nsample; i++)\n\t{\n\t\tdouble t1 = fp1 + i * delta1;\n\t\tcurve1->D0(t1, p);\n\t\tTopoEdge edge = MakeEdge(curve2);\n\t\tBRepExtremaDistShapeShape shape(MakeVertex(p), edge);\n\t\tdouble dist = shape.Value();\n\t\tif (dist > maxdist)\n\t\t{\n\t\t\tmaxdist = dist;\n\t\t}\n\t}\n\treturn maxdist;\n}\ndouble NurbsCompareSurface(int num, const shared_ptr<Geom3Surface>& surf1, const shared_ptr<Geom3Surface>& surf2)\n{\n\tdouble maxdist = 0.0;\n\tconst int nsample = num;\n\tdouble fpu1 = surf1->FirstUParameter();\n\tdouble lpu1 = surf1->LastUParameter();\n\tdouble fpv1 = surf1->FirstVParameter();\n\tdouble lpv1 = surf1->LastVParameter();\n\tdouble deltaU1 = (lpu1 - fpu1) / nsample;\n\tdouble deltaV1 = (lpv1 - fpv1) / nsample;\n\tPoint3 p1;\n\tint n = 0;\n\tdouble tu1 = 0.0;\n\tdouble tv1 = 0.0;\n\tfor (int i = 0; i < nsample; i++)\n\t{\n\t\ttu1 = fpu1 + i * deltaU1;\n\t\tfor (int j = 0; j < nsample; j++)\n\t\t{\n\t\t\ttv1 = fpv1 + j * deltaV1;\n\t\t\tsurf1->D0(tu1, tv1, p1);\n\t\t\tTopoFace face = MakeFace(surf2, 0.0);\n\t\t\tBRepExtremaDistShapeShape shape(MakeVertex(p1), face);\n\t\t\tdouble dist = shape.Value();\n\t\t\tif (dist > maxdist)\n\t\t\t{\n\t\t\t\tmaxdist = dist;\n\t\t\t}\n\t\t}\n\t}\n\treturn maxdist;\n}\n#include<catch.hpp>\n#include<testHelper.h>\n#include <nurbs/NURBSAPIRebuild.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeFace.hpp>\n#include <nurbs/NURBSAPISweep.hpp>\n#include <topology/BRepExtremaDistShapeShape.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <nurbs/NURBSAPIBuildCurve.hpp>\ndouble NurbsCompareCurve(int num, const shared_ptr<Geom3Curve>& curve1, const shared_ptr<Geom3Curve>& curve2)\n{\n\tdouble maxdist = 0.0;\n\tconst int nsample = num;\n\tdouble fp1 = curve1->FirstParameter();\n\tdouble lp1 = curve1->LastParameter();\n\tdouble delta1 = abs((lp1 - fp1) / nsample);\n\tPoint3 p;\n\tint n = 0;\n\tfor (int i = 0; i < nsample; i++)\n\t{\n\t\tdouble t1 = fp1 + i * delta1;\n\t\tcurve1->D0(t1, p);\n\t\tTopoEdge edge = MakeEdge(curve2);\n\t\tBRepExtremaDistShapeShape shape(MakeVertex(p), edge);\n\t\tdouble dist = shape.Value();\n\t\tif (dist > maxdist)\n\t\t{\n\t\t\tmaxdist = dist;\n\t\t}\n\t}\n\treturn maxdist;\n}\ndouble NurbsCompareSurface(int num, const shared_ptr<Geom3Surface>& surf1, const shared_ptr<Geom3Surface>& surf2)\n{\n\tdouble maxdist = 0.0;\n\tconst int nsample = num;\n\tdouble fpu1 = surf1->FirstUParameter();\n\tdouble lpu1 = surf1->LastUParameter();\n\tdouble fpv1 = surf1->FirstVParameter();\n\tdouble lpv1 = surf1->LastVParameter();\n\tdouble deltaU1 = (lpu1 - fpu1) / nsample;\n\tdouble deltaV1 = (lpv1 - fpv1) / nsample;\n\tPoint3 p1;\n\tint n = 0;\n\tdouble tu1 = 0.0;\n\tdouble tv1 = 0.0;\n\tfor (int i = 0; i < nsample; i++)\n\t{\n\t\ttu1 = fpu1 + i * deltaU1;\n\t\tfor (int j = 0; j < nsample; j++)\n\t\t{\n\t\t\ttv1 = fpv1 + j * deltaV1;\n\t\t\tsurf1->D0(tu1, tv1, p1);\n\t\t\tTopoFace face = MakeFace(surf2, 0.0);\n\t\t\tBRepExtremaDistShapeShape shape(MakeVertex(p1), face);\n\t\t\tdouble dist = shape.Value();\n\t\t\tif (dist > maxdist)\n\t\t\t{\n\t\t\t\tmaxdist = dist;\n\t\t\t}\n\t\t}\n\t}\n\treturn maxdist;\n;\n\tSECTION(\"TestRebuildCurve\")\n\t{\n\t\tOUTPUT_DIRECTORY(nurbs, Rebuild/RebuildCurve);\n\t\tint deg = 3;\n\t\tstd::vector<Point3> poles;\n\t\tpoles.push_back(Point3(0., -1., 0.));\n\t\tpoles.push_back(Point3(.7, -.7, 0.));\n\t\tpoles.push_back(Point3(1., -.3, 0.));\n\t\tpoles.push_back(Point3(1.2, 0., 0.));\n\t\tpoles.push_back(Point3(2., .3, 0.));\n\t\tpoles.push_back(Point3(.7, 1.7, 0.));\n\t\tpoles.push_back(Point3(0., 1., 0.));\n\t\tstd::vector<double> weights;\n\t\tweights.push_back(0.8);\n\t\tweights.push_back(0.9);\n\t\tweights.push_back(1.1);\n\t\tweights.push_back(0.3);\n\t\tweights.push_back(0.6);\n\t\tweights.push_back(1.2);\n\t\tweights.push_back(0.8);\n\t\tint nknots = static_cast<int>(poles.size()) - deg + 1;\n\t\tstd::vector<double> knots(nknots);\n\t\tfor (int i = 0; i < nknots; i++)\n\t\t{\n\t\t\tknots[i] = (double)i / (double)(nknots - 1);\n\t\t}\n\t\tstd::vector<int> mults(nknots, 1);\n\t\tmults.front() = deg + 1;\n\t\tmults.back() = deg + 1;\n\t\tauto bsp = std::make_shared<Geom3BSplineCurve>(poles, weights, knots, mults, deg);\n\t\tauto [result, error] = NURBSAPIRebuild::RebuildCurve(bsp, 3, 15, false);\n\t\tCHECK(bsp->Degree() == 3);\n\t\tCHECK(bsp->NKnots() == 5);\n\t\tCHECK(bsp->NPoles() == 7);\n\t\tCHECK(result->Degree() == 3);\n\t\tCHECK(result->NKnots() == 13);\n\t\tCHECK(result->NPoles() == 15);\n\t\tdouble dist = NurbsCompareCurve(num, bsp, result);\n\t\tdouble res = abs(dist - error);\n\t\tCHECK(res <= val);\n\t\tOCCTIO::OCCTTool::Write(MakeEdge(bsp), outdir + \"src.brep\");\n\t\tOCCTIO::OCCTTool::Write(MakeEdge(result), outdir + \"result.brep\");\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static std::pair<std::vector<std::pair<std::shared_ptr<Geom3Curve>, std::shared_ptr<Geom2Curve>>>, std::vector<std::pair<Point3, Point2>>> NURBSProjectCurveOnSurface(const std::shared_ptr<Geom3Curve>& curve, const std::shared_ptr<Geom3Surface>& surf, const Direction3& dir),\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <nurbs/NURBSAPIProject.hpp>\n#include <geometry/Geom3SphericalSurface.hpp>\n#include <common/CartesianCoordinateSystem.hpp>\n#include <modeling/MakeFace.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <nurbs/NURBSAPIConvert.hpp>\nTEST_CASE(\"bug1: testNURBSAPIProject \", \"[nurbs][Project][fixbug]\")\n{\n\tOUTPUT_DIRECTORY(nurbs, Project/bug692);\n\tstd::shared_ptr<Geom3SphericalSurface> sphere = std::make_shared<Geom3SphericalSurface>(CartesianCoordinateSystem::XOY(), 3);\n\tstd::vector<Point3> poles;\n\tpoles.push_back(Point3(0., -1., 0.));\n\tpoles.push_back(Point3(.7, -.7, 0.));\n\tpoles.push_back(Point3(1., -.3, 0.));\n\tpoles.push_back(Point3(1.2, 0., 0.));\n\tpoles.push_back(Point3(2., .3, 0.));\n\tpoles.push_back(Point3(.7, 1.7, 0.));\n\tpoles.push_back(Point3(0., 1., 0.));\n\tstd::vector<double> weights;\n\tweights.push_back(0.9);\n\tweights.push_back(1.25);\n\tweights.push_back(1.5);\n\tweights.push_back(0.75);\n\tweights.push_back(1.2);\n\tweights.push_back(1.1);\n\tweights.push_back(1.3);\n\tstd::vector<double> knots;\n\tknots.push_back(0.);\n\tknots.push_back(.25);\n\tknots.push_back(.5);\n\tknots.push_back(.75);\n\tknots.push_back(1.);\n\tstd::vector<int> mults(5, 1);\n\tmults.front() = 4;\n\tmults.back() = 4;\n\tstd::shared_ptr<Geom3BSplineCurve> bsp = std::make_shared<Geom3BSplineCurve>(poles, weights, knots, mults, 3);\n\tTransformation3 trsf;\n\ttrsf.SetDisplacement(CartesianCoordinateSystem::XOY(), Frame3(Point3(-4.0, 0.0, 0.0), Direction3(1.0, 0.0, 0.0), Direction3(0.0, 1.0, 0.0)));\n\tbsp->Transform(trsf);\n\tbool isParallel = false;\t\n\tint num = 1000;\n\tdouble ratio = 0.1;\n\tbool res1, res2;\n\tif (!isParallel)\n\t{\n\t\tauto [lines, points] = NURBSAPIProject::NURBSProjectCurveOnSurface(bsp, sphere, Point3(-10.0, 0.0, 0.0));\n\t\tres1 = IsCurveOnSurf(num, ratio, lines[0].first, sphere, -1.0);\n\t\tCHECK(res1 == true);\n\t\tfor (int i = 0; i < static_cast<int>(lines.size()); i++)\n\t\t{\n\t\t\tOCCTIO::OCCTTool::Write(MakeEdge(lines[i].first), outdir + \"result\" + std::to_string(i) + \".brep\");\n\t\t}\n\t\tfor (int i = 0; i < static_cast<int>(points.size()); i++)\n\t\t{\n\t\t\tOCCTIO::OCCTTool::Write(MakeVertex(points[i].first), outdir + \"pResult\" + std::to_string(i) + \".brep\");\n\t\t}\n\t}\n\telse\n\t{\n\t\tauto [lines, points] = NURBSAPIProject::NURBSProjectCurveOnSurface(bsp, sphere, Direction3(1.0, 0.0, 0.0));\n\t\tfor (int i = 0; i < static_cast<int>(lines.size()); i++)\n\t\t{\n\t\t\tOCCTIO::OCCTTool::Write(MakeEdge(lines[i].first), outdir + \"linesResult\" + std::to_string(i) + \".brep\");\n\t\t}\n\t\tfor (int i = 0; i < static_cast<int>(points.size()); i++)\n\t\t{\n\t\t\tOCCTIO::OCCTTool::Write(MakeVertex(points[i].first), outdir + \"pointResult\" + std::to_string(i) + \".brep\");\n\t\t}\n\t}\n\tOCCTIO::OCCTTool::Write(MakeEdge(bsp), outdir + \"src.brep\");\n\tOCCTIO::OCCTTool::Write(MakeVertex(Point3(-10.0, 0.0, 0.0)), outdir + \"point.brep\");\n\tOCCTIO::OCCTTool::Write(MakeFace(sphere, 0.0), outdir + \"sphere.brep\");\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static std::pair<std::vector<std::pair<std::shared_ptr<Geom3Curve>, std::shared_ptr<Geom2Curve>>>, std::vector<std::pair<Point3, Point2>>> NURBSProjectCurveOnSurface(const std::shared_ptr<Geom3Curve>& curve, const std::shared_ptr<Geom3Surface>& surf, const Point3& pt),\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <nurbs/NURBSAPIProject.hpp>\n#include <geometry/Geom3SphericalSurface.hpp>\n#include <common/CartesianCoordinateSystem.hpp>\n#include <modeling/MakeFace.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <nurbs/NURBSAPIConvert.hpp>\nTEST_CASE(\"bug1: testNURBSAPIProject \", \"[nurbs][Project][fixbug]\")\n{\n\tOUTPUT_DIRECTORY(nurbs, Project/bug692);\n\tstd::shared_ptr<Geom3SphericalSurface> sphere = std::make_shared<Geom3SphericalSurface>(CartesianCoordinateSystem::XOY(), 3);\n\tstd::vector<Point3> poles;\n\tpoles.push_back(Point3(0., -1., 0.));\n\tpoles.push_back(Point3(.7, -.7, 0.));\n\tpoles.push_back(Point3(1., -.3, 0.));\n\tpoles.push_back(Point3(1.2, 0., 0.));\n\tpoles.push_back(Point3(2., .3, 0.));\n\tpoles.push_back(Point3(.7, 1.7, 0.));\n\tpoles.push_back(Point3(0., 1., 0.));\n\tstd::vector<double> weights;\n\tweights.push_back(0.9);\n\tweights.push_back(1.25);\n\tweights.push_back(1.5);\n\tweights.push_back(0.75);\n\tweights.push_back(1.2);\n\tweights.push_back(1.1);\n\tweights.push_back(1.3);\n\tstd::vector<double> knots;\n\tknots.push_back(0.);\n\tknots.push_back(.25);\n\tknots.push_back(.5);\n\tknots.push_back(.75);\n\tknots.push_back(1.);\n\tstd::vector<int> mults(5, 1);\n\tmults.front() = 4;\n\tmults.back() = 4;\n\tstd::shared_ptr<Geom3BSplineCurve> bsp = std::make_shared<Geom3BSplineCurve>(poles, weights, knots, mults, 3);\n\tTransformation3 trsf;\n\ttrsf.SetDisplacement(CartesianCoordinateSystem::XOY(), Frame3(Point3(-4.0, 0.0, 0.0), Direction3(1.0, 0.0, 0.0), Direction3(0.0, 1.0, 0.0)));\n\tbsp->Transform(trsf);\n\tbool isParallel = false;\t\n\tint num = 1000;\n\tdouble ratio = 0.1;\n\tbool res1, res2;\n\tif (!isParallel)\n\t{\n\t\tauto [lines, points] = NURBSAPIProject::NURBSProjectCurveOnSurface(bsp, sphere, Point3(-10.0, 0.0, 0.0));\n\t\tres1 = IsCurveOnSurf(num, ratio, lines[0].first, sphere, -1.0);\n\t\tCHECK(res1 == true);\n\t\tfor (int i = 0; i < static_cast<int>(lines.size()); i++)\n\t\t{\n\t\t\tOCCTIO::OCCTTool::Write(MakeEdge(lines[i].first), outdir + \"result\" + std::to_string(i) + \".brep\");\n\t\t}\n\t\tfor (int i = 0; i < static_cast<int>(points.size()); i++)\n\t\t{\n\t\t\tOCCTIO::OCCTTool::Write(MakeVertex(points[i].first), outdir + \"pResult\" + std::to_string(i) + \".brep\");\n\t\t}\n\t}\n\telse\n\t{\n\t\tauto [lines, points] = NURBSAPIProject::NURBSProjectCurveOnSurface(bsp, sphere, Direction3(1.0, 0.0, 0.0));\n\t\tfor (int i = 0; i < static_cast<int>(lines.size()); i++)\n\t\t{\n\t\t\tOCCTIO::OCCTTool::Write(MakeEdge(lines[i].first), outdir + \"linesResult\" + std::to_string(i) + \".brep\");\n\t\t}\n\t\tfor (int i = 0; i < static_cast<int>(points.size()); i++)\n\t\t{\n\t\t\tOCCTIO::OCCTTool::Write(MakeVertex(points[i].first), outdir + \"pointResult\" + std::to_string(i) + \".brep\");\n\t\t}\n\t}\n\tOCCTIO::OCCTTool::Write(MakeEdge(bsp), outdir + \"src.brep\");\n\tOCCTIO::OCCTTool::Write(MakeVertex(Point3(-10.0, 0.0, 0.0)), outdir + \"point.brep\");\n\tOCCTIO::OCCTTool::Write(MakeFace(sphere, 0.0), outdir + \"sphere.brep\");\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static std::pair<std::vector<std::shared_ptr<Geom3Curve>>, std::vector<Point3>> OffsetCurveOnSurfaceToPoint( const TopoEdge& edge, const TopoFace& face, const Point2& point),\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <nurbs/NURBSAPIOffsetCurveOnSurface.hpp>\n#include <geometry/Geom3BSplineCurve.hpp>\n#include <modeling/MakeWire.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <offset/MakePipeShell.hpp>\n#include <topology/TopoTool.hpp>\n#include <geometry/Geom3BSplineSurface.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <healing/ShapeFixTool.hpp>\n#include <modeling/MakeFace.hpp>\n#include <geometry/GeomAPIProjectPointOnCurve3.hpp>\n#include <geometry/GeomAPIProjectPointOnCurve2.hpp>\n#include <nurbs/NURBSAPIConvert.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <hatch/BRepClassificationTools.hpp>\nstd::shared_ptr<Geom3BSplineSurface> GenerateTestSurface(const int id)\n{\n\tstd::shared_ptr<Geom3BSplineSurface> bspSurf;\n\tswitch (id)\n\t{\n\tcase 0:\n\t{\n\t\tstd::vector<Point3> profilePoles;\n\t\tstd::vector<double> profileKnots(3);\n\t\tstd::vector<int> profileMults(3, 1);\n\t\tprofilePoles.push_back(Point3(0.0, 0.0, 0.0));\n\t\tprofilePoles.push_back(Point3(1.0, -0.2, 0.1));\n\t\tprofilePoles.push_back(Point3(2.0, 0.1, -0.1));\n\t\tprofilePoles.push_back(Point3(3.0, -0.1, 0.0));\n\t\tprofilePoles.push_back(Point3(4.0, 0.1, 0.2));\n\t\tprofileKnots[0] = 0;\n\t\tprofileKnots[1] = 0.5;\n\t\tprofileKnots[2] = 1;\n\t\tprofileMults.front() = 4;\n\t\tprofileMults.back() = 4;\n\t\tstd::shared_ptr<Geom3BSplineCurve> profileCurve = std::make_shared<Geom3BSplineCurve>(profilePoles, profileKnots, profileMults, 3);\n\t\tstd::vector<Point3> spinePoles;\n\t\tstd::vector<double> spineKnots(4);\n\t\tstd::vector<int> spineMults(4, 1);\n\t\tspinePoles.push_back(Point3(0.0, 0.0, 0.0));\n\t\tspinePoles.push_back(Point3(-0.1, 1.0, -0.2));\n\t\tspinePoles.push_back(Point3(0.1, 2.0, -0.1));\n\t\tspinePoles.push_back(Point3(0.2, 3.0, 0.1));\n\t\tspinePoles.push_back(Point3(0.1, 4.0, 0.0));\n\t\tspinePoles.push_back(Point3(0.0, 5.0, -0.1));\n\t\tspineKnots[0] = 0;\n\t\tspineKnots[1] = 1.0 / 3.0;\n\t\tspineKnots[2] = 2.0 / 3.0;\n\t\tspineKnots[3] = 1;\n\t\tspineMults.front() = 4;\n\t\tspineMults.back() = 4;\n\t\tstd::shared_ptr<Geom3BSplineCurve> spineCurve = std::make_shared<Geom3BSplineCurve>(spinePoles, spineKnots, spineMults, 3);\n\t\tTopoWire profile = MakeWire(MakeEdge(profileCurve)).Wire();\n\t\tTopoWire spine = MakeWire(MakeEdge(spineCurve)).Wire();\n\t\tMakePipeShell pipeShell(spine);\n\t\tpipeShell.Add(profile);\n\t\tpipeShell.SetMode(Frame3());\n\t\tTopoShape pipe = pipeShell.Shape();\n\t\tTopoExplorer ex(pipe, ShapeType::Face);\n\t\tTopoFace inputBasicFace = static_cast<const TopoFace&>(ex.Current());\n\t\tshared_ptr<Geom3Surface> surf = TopoTool::Surface(inputBasicFace);\n\t\tshared_ptr<Geom3BSplineSurface> bspSurf = NURBSAPIConvert::ToBSpline(surf);\n\t\tbreak;\n\t}\n\tcase 1:\n\t{\n\t\tArray2<Point3> poles(2, 5);\n\t\tpoles(0, 0) = Point3(0.0, 0.0, 0.0);\n\t\tpoles(0, 1) = Point3(1.0, -0.2, 0.1);\n\t\tpoles(0, 2) = Point3(2.0, 0.1, -0.1);\n\t\tpoles(0, 3) = Point3(3.0, -0.1, 0.0);\n\t\tpoles(0, 4) = Point3(4.0, 0.1, 0.2);\n\t\tpoles(1, 0) = Point3(0.0, 1.0, -0.1);\n\t\tpoles(1, 1) = Point3(1.0, 0.8, 0.0);\n\t\tpoles(1, 2) = Point3(2.0, 1.1, -0.2);\n\t\tpoles(1, 3) = Point3(3.0, 0.9, -0.1);\n\t\tpoles(1, 4) = Point3(4.0, 1.1, 0.1);\n\t\tstd::vector<double> vKnots(3);\n\t\tstd::vector<int> vMults(3, 1);\n\t\tvKnots[0] = 0;\n\t\tvKnots[1] = 0.5;\n\t\tvKnots[2] = 1;\n\t\tvMults.front() = 4;\n\t\tvMults.back() = 4;\n\t\tstd::vector<double> uKnots(2);\n\t\tstd::vector<int> uMults(2, 1);\n\t\tuKnots[0] = 0;\n\t\tuKnots[1] = 1;\n\t\tuMults.front() = 2;\n\t\tuMults.back() = 2;\n\t\tbspSurf = std::make_shared<Geom3BSplineSurface>(poles, uKnots, vKnots, uMults, vMults, 1, 3);\n\t\tTransformation3 trsf;\n\t\ttrsf.SetTranslationPart(Vector3(0.0, -6.0, 0.0));\n\t\tbspSurf->Transform(trsf);\n\t\tbreak;\n\t}\n\tcase 2:\n\t{\n\t\tstd::vector<Point3> profilePoles;\n\t\tstd::vector<double> profileKnots(4);\n\t\tstd::vector<int> profileMults(4, 1);\n\t\tprofilePoles.push_back(Point3(0.0, 0.0, 0.0));\n\t\tprofilePoles.push_back(Point3(1.0, -2.0, -3.0));\n\t\tprofilePoles.push_back(Point3(2.0, 1.0, 2.0));\n\t\tprofilePoles.push_back(Point3(3.0, -1.0, -1.0));\n\t\tprofilePoles.push_back(Point3(4.0, -3.0, 3.0));\n\t\tprofilePoles.push_back(Point3(5.0, 0.0, 1.0));\n\t\tprofileKnots[0] = 0;\n\t\tprofileKnots[1] = 1.0 / 3.0;\n\t\tprofileKnots[2] = 2.0 / 3.0;\n\t\tprofileKnots[3] = 1;\n\t\tprofileMults.front() = 4;\n\t\tprofileMults.back() = 4;\n\t\tstd::shared_ptr<Geom3BSplineCurve> profileCurve = std::make_shared<Geom3BSplineCurve>(profilePoles, profileKnots, profileMults, 3);\n\t\tstd::vector<Point3> spinePoles;\n\t\tstd::vector<double> spineKnots(4);\n\t\tstd::vector<int> spineMults(4, 1);\n\t\tspinePoles.push_back(Point3(0.0, 0.0, 0.0));\n\t\tspinePoles.push_back(Point3(-0.1, 1.0, -1.0));\n\t\tspinePoles.push_back(Point3(0.1, -2.0, -2.0));\n\t\tspinePoles.push_back(Point3(0.2, -3.0, -3.0));\n\t\tspinePoles.push_back(Point3(0.1, -4.0, -4.0));\n\t\tspinePoles.push_back(Point3(0.0, -2.5, -5.0));\n\t\tspinePoles.push_back(Point3(0.1, -1.0, -6.0));\n\t\tspinePoles.push_back(Point3(0.0, 0.0, -7.0));\n\t\tspineKnots[0] = 0;\n\t\tspineKnots[1] = 1.0 / 3.0;\n\t\tspineKnots[2] = 2.0 / 3.0;\n\t\tspineKnots[3] = 1;\n\t\tspineMults.front() = 6;\n\t\tspineMults.back() = 6;\n\t\tshared_ptr<Geom3BSplineCurve> spineCurve = make_shared<Geom3BSplineCurve>(spinePoles, spineKnots, spineMults, 5);\n\t\tTopoWire profile = MakeWire(MakeEdge(profileCurve)).Wire();\n\t\tTopoWire spine = MakeWire(MakeEdge(spineCurve)).Wire();\n\t\tMakePipeShell pipeShell(spine);\n\t\tpipeShell.Add(profile);\n\t\tpipeShell.SetMode(Frame3());\n\t\tTopoShape pipe = pipeShell.Shape();\n\t\tTopoExplorer ex(pipe, ShapeType::Face);\n\t\tTopoFace inputBasicFace = static_cast<const TopoFace&>(ex.Current());\n\t\tshared_ptr<Geom3Surface> surf = TopoTool::Surface(inputBasicFace);\n\t\tshared_ptr<Geom3BSplineSurface> bspSurf = NURBSAPIConvert::ToBSpline(surf);\n\t\tTransformation3 trsf;\n\t\ttrsf.SetTranslationPart(Vector3(-6.0, 0.0, 0.0));\n\t\tbspSurf->Transform(trsf);\n\t\tbreak;\n\t}\n\t}\n\treturn bspSurf;\n}\nTEST_CASE(\"Not Fix bug1: TestOffsetCurveFailedCase \", \"[nurbs][Offset][bug]\")\n{\n\tOUTPUT_DIRECTORY(nurbs, OffsetCurveOnSurface/bug794);\n\tTopoEdge edge = ReadBRepEdge(INPUT_PATH_PREFIX\"/TestNURBS/TestOffsetCurveFailedCase/curve.brep\");\n\tTopoFace face = ReadBRepFace(INPUT_PATH_PREFIX\"/TestNURBS/TestOffsetCurveFailedCase/face.brep\");\n\tPoint2 uv(0.5, 0.5);\n\tshared_ptr<Geom3Surface> s = TopoTool::Surface(face);\n\tauto [curves1, points1] = NURBSAPIOffsetCurveOnSurface::OffsetCurveOnSurfaceToPoint(edge, face, uv);\n\tfor (size_t i = 0; i < curves1.size(); i++)\n\t{\n\t\tOCCTIO::OCCTTool::Write(MakeEdge(curves1[i]), outdir + \"result1\" + to_string(i) + \".brep\");\n\t}\n\tdouble tol = -1.0;\n\tPoint3 uv1(uv.X(), uv.Y(), 0.0);\n\tTopoEdge e = MakeEdge(curves1[0]);\n\tbool res1 = BRepClassificationTools::IsPointInOnEdge(e, uv1, tol);\n\tCHECK(res1 == true);\n\tPoint2 uv2(0.6, 0.3);\n\tauto [curves, points] = NURBSAPIOffsetCurveOnSurface::OffsetCurveOnSurfaceToPoint(edge, face, uv2);\n\tfor (size_t i = 0; i < curves.size(); i++)\n\t{\n\t\tOCCTIO::OCCTTool::Write(MakeEdge(curves[i]), outdir + \"result2\" + to_string(i) + \".brep\");\n\t}\n\tPoint3 uv22(uv2.X(), uv2.Y(), 0.0);\n\tTopoEdge e2 = MakeEdge(curves[0]);\n\tbool res4 = BRepClassificationTools::IsPointInOnEdge(e2, uv22, tol);\n\tCHECK(res4 == true);\n\tOCCTIO::OCCTTool::Write(MakeVertex(uv1), outdir + \"refp1.brep\");\n\tOCCTIO::OCCTTool::Write(MakeVertex(uv22), outdir + \"refp2.brep\");\n\tOCCTIO::OCCTTool::Write(edge, outdir + \"edge.brep\");\n\tOCCTIO::OCCTTool::Write(face, outdir + \"face.brep\");\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static std::pair<std::vector<std::shared_ptr<Geom3Curve>>, std::vector<Point3>> OffsetCurveOnSurface( const TopoEdge& edge, const TopoFace& face, double offset, bool reverse),\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <nurbs/NURBSAPIOffsetCurveOnSurface.hpp>\n#include <geometry/Geom3BSplineCurve.hpp>\n#include <modeling/MakeWire.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <offset/MakePipeShell.hpp>\n#include <topology/TopoTool.hpp>\n#include <geometry/Geom3BSplineSurface.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <healing/ShapeFixTool.hpp>\n#include <modeling/MakeFace.hpp>\n#include <geometry/GeomAPIProjectPointOnCurve3.hpp>\n#include <geometry/GeomAPIProjectPointOnCurve2.hpp>\n#include <nurbs/NURBSAPIConvert.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <hatch/BRepClassificationTools.hpp>\nstd::shared_ptr<Geom3BSplineSurface> GenerateTestSurface(const int id)\n{\n\tstd::shared_ptr<Geom3BSplineSurface> bspSurf;\n\tswitch (id)\n\t{\n\tcase 0:\n\t{\n\t\tstd::vector<Point3> profilePoles;\n\t\tstd::vector<double> profileKnots(3);\n\t\tstd::vector<int> profileMults(3, 1);\n\t\tprofilePoles.push_back(Point3(0.0, 0.0, 0.0));\n\t\tprofilePoles.push_back(Point3(1.0, -0.2, 0.1));\n\t\tprofilePoles.push_back(Point3(2.0, 0.1, -0.1));\n\t\tprofilePoles.push_back(Point3(3.0, -0.1, 0.0));\n\t\tprofilePoles.push_back(Point3(4.0, 0.1, 0.2));\n\t\tprofileKnots[0] = 0;\n\t\tprofileKnots[1] = 0.5;\n\t\tprofileKnots[2] = 1;\n\t\tprofileMults.front() = 4;\n\t\tprofileMults.back() = 4;\n\t\tstd::shared_ptr<Geom3BSplineCurve> profileCurve = std::make_shared<Geom3BSplineCurve>(profilePoles, profileKnots, profileMults, 3);\n\t\tstd::vector<Point3> spinePoles;\n\t\tstd::vector<double> spineKnots(4);\n\t\tstd::vector<int> spineMults(4, 1);\n\t\tspinePoles.push_back(Point3(0.0, 0.0, 0.0));\n\t\tspinePoles.push_back(Point3(-0.1, 1.0, -0.2));\n\t\tspinePoles.push_back(Point3(0.1, 2.0, -0.1));\n\t\tspinePoles.push_back(Point3(0.2, 3.0, 0.1));\n\t\tspinePoles.push_back(Point3(0.1, 4.0, 0.0));\n\t\tspinePoles.push_back(Point3(0.0, 5.0, -0.1));\n\t\tspineKnots[0] = 0;\n\t\tspineKnots[1] = 1.0 / 3.0;\n\t\tspineKnots[2] = 2.0 / 3.0;\n\t\tspineKnots[3] = 1;\n\t\tspineMults.front() = 4;\n\t\tspineMults.back() = 4;\n\t\tstd::shared_ptr<Geom3BSplineCurve> spineCurve = std::make_shared<Geom3BSplineCurve>(spinePoles, spineKnots, spineMults, 3);\n\t\tTopoWire profile = MakeWire(MakeEdge(profileCurve)).Wire();\n\t\tTopoWire spine = MakeWire(MakeEdge(spineCurve)).Wire();\n\t\tMakePipeShell pipeShell(spine);\n\t\tpipeShell.Add(profile);\n\t\tpipeShell.SetMode(Frame3());\n\t\tTopoShape pipe = pipeShell.Shape();\n\t\tTopoExplorer ex(pipe, ShapeType::Face);\n\t\tTopoFace inputBasicFace = static_cast<const TopoFace&>(ex.Current());\n\t\tshared_ptr<Geom3Surface> surf = TopoTool::Surface(inputBasicFace);\n\t\tshared_ptr<Geom3BSplineSurface> bspSurf = NURBSAPIConvert::ToBSpline(surf);\n\t\tbreak;\n\t}\n\tcase 1:\n\t{\n\t\tArray2<Point3> poles(2, 5);\n\t\tpoles(0, 0) = Point3(0.0, 0.0, 0.0);\n\t\tpoles(0, 1) = Point3(1.0, -0.2, 0.1);\n\t\tpoles(0, 2) = Point3(2.0, 0.1, -0.1);\n\t\tpoles(0, 3) = Point3(3.0, -0.1, 0.0);\n\t\tpoles(0, 4) = Point3(4.0, 0.1, 0.2);\n\t\tpoles(1, 0) = Point3(0.0, 1.0, -0.1);\n\t\tpoles(1, 1) = Point3(1.0, 0.8, 0.0);\n\t\tpoles(1, 2) = Point3(2.0, 1.1, -0.2);\n\t\tpoles(1, 3) = Point3(3.0, 0.9, -0.1);\n\t\tpoles(1, 4) = Point3(4.0, 1.1, 0.1);\n\t\tstd::vector<double> vKnots(3);\n\t\tstd::vector<int> vMults(3, 1);\n\t\tvKnots[0] = 0;\n\t\tvKnots[1] = 0.5;\n\t\tvKnots[2] = 1;\n\t\tvMults.front() = 4;\n\t\tvMults.back() = 4;\n\t\tstd::vector<double> uKnots(2);\n\t\tstd::vector<int> uMults(2, 1);\n\t\tuKnots[0] = 0;\n\t\tuKnots[1] = 1;\n\t\tuMults.front() = 2;\n\t\tuMults.back() = 2;\n\t\tbspSurf = std::make_shared<Geom3BSplineSurface>(poles, uKnots, vKnots, uMults, vMults, 1, 3);\n\t\tTransformation3 trsf;\n\t\ttrsf.SetTranslationPart(Vector3(0.0, -6.0, 0.0));\n\t\tbspSurf->Transform(trsf);\n\t\tbreak;\n\t}\n\tcase 2:\n\t{\n\t\tstd::vector<Point3> profilePoles;\n\t\tstd::vector<double> profileKnots(4);\n\t\tstd::vector<int> profileMults(4, 1);\n\t\tprofilePoles.push_back(Point3(0.0, 0.0, 0.0));\n\t\tprofilePoles.push_back(Point3(1.0, -2.0, -3.0));\n\t\tprofilePoles.push_back(Point3(2.0, 1.0, 2.0));\n\t\tprofilePoles.push_back(Point3(3.0, -1.0, -1.0));\n\t\tprofilePoles.push_back(Point3(4.0, -3.0, 3.0));\n\t\tprofilePoles.push_back(Point3(5.0, 0.0, 1.0));\n\t\tprofileKnots[0] = 0;\n\t\tprofileKnots[1] = 1.0 / 3.0;\n\t\tprofileKnots[2] = 2.0 / 3.0;\n\t\tprofileKnots[3] = 1;\n\t\tprofileMults.front() = 4;\n\t\tprofileMults.back() = 4;\n\t\tstd::shared_ptr<Geom3BSplineCurve> profileCurve = std::make_shared<Geom3BSplineCurve>(profilePoles, profileKnots, profileMults, 3);\n\t\tstd::vector<Point3> spinePoles;\n\t\tstd::vector<double> spineKnots(4);\n\t\tstd::vector<int> spineMults(4, 1);\n\t\tspinePoles.push_back(Point3(0.0, 0.0, 0.0));\n\t\tspinePoles.push_back(Point3(-0.1, 1.0, -1.0));\n\t\tspinePoles.push_back(Point3(0.1, -2.0, -2.0));\n\t\tspinePoles.push_back(Point3(0.2, -3.0, -3.0));\n\t\tspinePoles.push_back(Point3(0.1, -4.0, -4.0));\n\t\tspinePoles.push_back(Point3(0.0, -2.5, -5.0));\n\t\tspinePoles.push_back(Point3(0.1, -1.0, -6.0));\n\t\tspinePoles.push_back(Point3(0.0, 0.0, -7.0));\n\t\tspineKnots[0] = 0;\n\t\tspineKnots[1] = 1.0 / 3.0;\n\t\tspineKnots[2] = 2.0 / 3.0;\n\t\tspineKnots[3] = 1;\n\t\tspineMults.front() = 6;\n\t\tspineMults.back() = 6;\n\t\tshared_ptr<Geom3BSplineCurve> spineCurve = make_shared<Geom3BSplineCurve>(spinePoles, spineKnots, spineMults, 5);\n\t\tTopoWire profile = MakeWire(MakeEdge(profileCurve)).Wire();\n\t\tTopoWire spine = MakeWire(MakeEdge(spineCurve)).Wire();\n\t\tMakePipeShell pipeShell(spine);\n\t\tpipeShell.Add(profile);\n\t\tpipeShell.SetMode(Frame3());\n\t\tTopoShape pipe = pipeShell.Shape();\n\t\tTopoExplorer ex(pipe, ShapeType::Face);\n\t\tTopoFace inputBasicFace = static_cast<const TopoFace&>(ex.Current());\n\t\tshared_ptr<Geom3Surface> surf = TopoTool::Surface(inputBasicFace);\n\t\tshared_ptr<Geom3BSplineSurface> bspSurf = NURBSAPIConvert::ToBSpline(surf);\n\t\tTransformation3 trsf;\n\t\ttrsf.SetTranslationPart(Vector3(-6.0, 0.0, 0.0));\n\t\tbspSurf->Transform(trsf);\n\t\tbreak;\n\t}\n\t}\n\treturn bspSurf;\n}\nTEST_CASE(\"case1: this is a test for TestOffsetCurveOnSurface1\", \"[nurbs][Offset][P1]\")\n{\n\tOUTPUT_DIRECTORY(nurbs, OffsetCurveOnSurface/OffsetCurveOnSurface1);\n\tshared_ptr<Geom3BSplineSurface> surf = GenerateTestSurface(1);\n\tint deg = 3;\n\tstd::vector<Point2> poles;\n\tpoles.push_back(Point2(0.0, 0.2));\n\tpoles.push_back(Point2(0.1, 0.35));\n\tpoles.push_back(Point2(0.25, 0.13));\n\tpoles.push_back(Point2(0.35, 0.07));\n\tpoles.push_back(Point2(0.43, 0.2));\n\tpoles.push_back(Point2(0.5, 0.21));\n\tpoles.push_back(Point2(0.6, 0.17));\n\tpoles.push_back(Point2(0.7, 0.21));\n\tstd::vector<double> weights;\n\tweights.push_back(0.8);\n\tweights.push_back(0.9);\n\tweights.push_back(1.1);\n\tweights.push_back(0.7);\n\tweights.push_back(1.2);\n\tweights.push_back(1.0);\n\tweights.push_back(1.3);\n\tweights.push_back(0.7);\n\tstd::vector<double> knots(static_cast<int>(poles.size()) - deg + 1);\n\tfor (int i = 0; i < static_cast<int>(knots.size()); i++)\n\t{\n\t\tknots[i] = (double)i / (double)(static_cast<int>(poles.size()) - 1);\n\t}\n\tstd::vector<int> mults(knots.size(), 1);\n\tmults.front() = deg + 1;\n\tmults.back() = deg + 1;\n\tshared_ptr<Geom2BSplineCurve> bsp = std::make_shared<Geom2BSplineCurve>(poles, weights, knots, mults, deg);\n\tTopoEdge edge = MakeEdge(bsp, surf);\n\tShapeFixTool::FixEdgeAddCurve(edge);\n\tdouble fp, lp;\n\tshared_ptr<Geom3Curve> c3d = TopoTool::Curve(edge, fp, lp);\n\tOCCTIO::OCCTTool::Write(edge, outdir + \"edge.brep\");\n\tOCCTIO::OCCTTool::Write(MakeEdge(c3d), outdir + \"c3d.brep\");\n\tTopoFace face = MakeFace(surf, Precision::Confusion());\n\t{\n\t\tdouble offset = 0.1;\n\t\tbool reverse = true;\n\t\tauto [curves, points] = NURBSAPIOffsetCurveOnSurface::OffsetCurveOnSurface(edge, face, offset, reverse);\n\t\tint NSample = 100;\n\t\tdouble maxDist = Precision::NegativeInfinity();\n\t\tdouble minDist = Precision::PositiveInfinity();\n\t\tPoint3 refFirstPoint, refLastPoint;\n\t\tc3d->D0(c3d->FirstParameter(), refFirstPoint);\n\t\tc3d->D0(c3d->LastParameter(), refLastPoint);\n\t\tfor (int i = 0; i < static_cast<int>(curves.size()); i++)\n\t\t{\n\t\t\tfp = curves[i]->FirstParameter();\n\t\t\tlp = curves[i]->LastParameter();\n\t\t\tdouble delta = (lp - fp) / (double)(NSample - 1);\n\t\t\tfor (int j = 0; j < NSample; j++)\n\t\t\t{\n\t\t\t\tdouble t = fp + j * delta;\n\t\t\t\tPoint3 p;\n\t\t\t\tcurves[i]->D0(t, p);\n\t\t\t\tGeomAPIProjectPointOnCurve3 projector(p, c3d);\n\t\t\t\tdouble crdist;\n\t\t\t\tif (projector.NPoints())\n\t\t\t\t{\n\t\t\t\t\tcrdist = projector.LowerDistance();\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tcrdist = std::min(p.Distance(refFirstPoint), p.Distance(refLastPoint));\n\t\t\t\t}\n\t\t\t\tmaxDist = std::max(maxDist, crdist);\n\t\t\t\tminDist = std::min(minDist, crdist);\n\t\t\t}\n\t\t\tOCCTIO::OCCTTool::Write(MakeEdge(curves[i]), outdir + \"curves\" + to_string(i) + \".brep\");\n\t\t}\n\t\tint num = 1000;\n\t\tdouble ratio = 0.01;\n\t\tfor (int i = 0; i < static_cast<int>(curves.size()); i++)\n\t\t{\n\t\t\tbool res1 = IsCurveOnSurf(num, ratio, curves[i], surf);\n\t\t\tCHECK(res1 == true);\n\t\t}\n\t\tOCCTIO::OCCTTool::Write(edge, outdir + \"edge.brep\");\n\t\tOCCTIO::OCCTTool::Write(face, outdir + \"face.brep\");\n\t}\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static std::shared_ptr<Geom3BSplineSurface> SurfaceToPlaneG0(const std::shared_ptr<Geom3BSplineSurface>& surf, bool isUIso, bool isFront, const std::shared_ptr<Geom3Plane>& plane)\t @return The result surface\n\t @param plane The plane\n\t @param isFront Front or back end\n\t @param isUIso U end or v end\n\t @param surf The source surface\n\t @brief Make the surface end G0 to the plane.\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <nurbs/NURBSAPIModifyEndToPlane.hpp>\n#include <offset/MakePipe.hpp>\n#include <geometry/Geom3TrimmedSurface.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeFace.hpp>\n#include <geometry/Geom3BSplineCurve.hpp>\n#include <geometry/Geom3Plane.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <modeling/MakeWire.hpp>\n#include <topology/TopoTool.hpp>\n#include <topology/TopoExplorerTool.hpp>\n#include <nurbs/NURBSAPIConvert.hpp>\nTEST_CASE(\"case1: this is a test for TestSymmetrySurf\", \"[nurbs][ModifyEndToPlane][P1]\")\n{\n\tOUTPUT_DIRECTORY(nurbs, ModifyEndToPlane/SymmetrySurf);\n\tstd::vector<Point3> profilePoles;\n\tstd::vector<double> profileKnots(3);\n\tstd::vector<int> profileMults(3, 1);\n\tprofilePoles.push_back(Point3(0.0, 0.0, 0.0));\n\tprofilePoles.push_back(Point3(1.0, -0.2, 0.0));\n\tprofilePoles.push_back(Point3(2.0, 0.1, 0.0));\n\tprofilePoles.push_back(Point3(2.3, -0.1, 0.0));\n\tprofilePoles.push_back(Point3(2.9, 0.1, 0.0));\n\tprofileKnots[0] = 0;\n\tprofileKnots[1] = 0.5;\n\tprofileKnots[2] = 1;\n\tprofileMults.front() = 4;\n\tprofileMults.back() = 4;\n\tstd::shared_ptr<Geom3BSplineCurve> profile = std::make_shared<Geom3BSplineCurve>(profilePoles, profileKnots, profileMults, 3);\n\tstd::vector<Point3> spinePoles;\n\tstd::vector<double> spineKnots(4);\n\tstd::vector<int> spineMults(4, 1);\n\tspinePoles.push_back(Point3(0.0, 0.0, 0.0));\n\tspinePoles.push_back(Point3(0.0, 0.0, 1.0));\n\tspinePoles.push_back(Point3(0.0, 0.2, 1.5));\n\tspinePoles.push_back(Point3(0.0, 0.5, 2.0));\n\tspinePoles.push_back(Point3(0.0, 1.0, 2.3));\n\tspinePoles.push_back(Point3(0.0, 1.6, 2.3));\n\tspineKnots[0] = 0;\n\tspineKnots[1] = 1.0 / 3.0;\n\tspineKnots[2] = 2.0 / 3.0;\n\tspineKnots[3] = 1;\n\tspineMults.front() = 4;\n\tspineMults.back() = 4;\n\tstd::shared_ptr<Geom3BSplineCurve> spine = std::make_shared<Geom3BSplineCurve>(spinePoles, spineKnots, spineMults, 3);\n\tTopoShape pipe = MakePipe(MakeWire(MakeEdge(spine)), MakeWire(MakeEdge(profile))).Shape();\n\tTopoExplorer ex(pipe, ShapeType::Face);\n\tshared_ptr <Geom3Plane> tp1 = std::make_shared<Geom3Plane>(Point3(-3.2, 0.0, 0.0), Direction3(1.0, 0.1, 0.0));\n\tshared_ptr<Geom3TrimmedSurface> trimtp1 = std::make_shared<Geom3TrimmedSurface>(tp1, -10.0, 10.0, -10.0, 10.0);\n\tshared_ptr <Geom3Plane> tp2 = std::make_shared<Geom3Plane>(Point3(3.1, 0.0, 0.0), Direction3(1.0, 0.0, 0.0));\n\tshared_ptr<Geom3TrimmedSurface> trimtp2 = std::make_shared<Geom3TrimmedSurface>(tp2, -10.0, 10.0, -10.0, 10.0);\n\tshared_ptr<Geom3BSplineSurface> surface = NURBSAPIConvert::ToBSpline(TopoTool::Surface(static_cast<const TopoFace&>(ex.Current())));\n\tshared_ptr<Geom3BSplineSurface> sG0 = NURBSAPIModifyEndToPlane::SurfaceToPlaneG0(surface, true, true, tp1);\n\tshared_ptr<Geom3BSplineSurface> sG1 = NURBSAPIModifyEndToPlane::SurfaceToPlaneG1(surface, true, false, tp2);\n\tCHECK(GetTopoCount(MakeFace(sG0, 0.0), ShapeType::Edge) == 4);\n\tCHECK(GetTopoCount(MakeFace(sG1, 0.0), ShapeType::Edge) == 4);\n\tIndexSet<TopoShape>newshapeEdge1, newshapeEdge2;\n\tTopoExplorerTool::MapShapes(MakeFace(sG0, 0.0), ShapeType::Edge, newshapeEdge1);\n\tTopoExplorerTool::MapShapes(MakeFace(sG1, 0.0), ShapeType::Edge, newshapeEdge2);\n\tCHECK(newshapeEdge1.size() == 4);\n\tCHECK(newshapeEdge2.size() == 4);\n\tdouble first = 0.0;\n\tdouble last = 0.0;\n\tint num = 1000;\n\tdouble ratio = 0.0;\n\tdouble tol = 0.0;\n\tshared_ptr<Geom3BSplineCurve> curve1 = NURBSAPIConvert::ToBSpline(TopoTool::Curve(static_cast<const TopoEdge&>(newshapeEdge1[0]), first, last));\n\tshared_ptr<Geom3BSplineCurve> curve2 = NURBSAPIConvert::ToBSpline(TopoTool::Curve(static_cast<const TopoEdge&>(newshapeEdge2[2]), first, last));\n\tbool res1 = IsCurveOnSurf(num, ratio, curve1, trimtp1, -1.0);\n\tbool res2 = IsCurveOnSurf(num, ratio, curve2, trimtp2, -1.0);\n\tCHECK(res1 == true);\n\tCHECK(res2 == true);\n\tdouble fu1 = surface->LastUParameter();\n\tdouble fu2 = surface->FirstUParameter();\n\tdouble fu3 = sG0->LastUParameter();\n\tdouble fu4 = sG1->FirstUParameter();\n\tshared_ptr<Geom3Curve> f1 = surface->UIso(fu1);\n\tshared_ptr<Geom3Curve> f2 = surface->UIso(fu2);\n\tshared_ptr<Geom3Curve> f3 = sG0->UIso(fu3);\n\tshared_ptr<Geom3Curve> f4 = sG1->UIso(fu4);\n\tdouble refTol = 1e-1;\n\tratio = 0.1;\n\tdouble res3 = NurbsSampleCurve(num, refTol, f3, f1);\n\tdouble res4 = NurbsSampleCurve(num, refTol, f4, f2);\n\tCHECK(res3 <= ratio);\n\tCHECK(res4 <= ratio);\n\tOCCTIO::OCCTTool::Write(MakeFace(surface,0.0), outdir + \"surface.brep\");\n\tOCCTIO::OCCTTool::Write(MakeFace(trimtp1, 0.0), outdir + \"trimtp1 .brep\");\n\tOCCTIO::OCCTTool::Write(MakeFace(trimtp2, 0.0), outdir + \"trimtp2.brep\");\n\tOCCTIO::OCCTTool::Write(MakeFace(sG0, 0.0), outdir + \"sG0.brep\");\n\tOCCTIO::OCCTTool::Write(MakeFace(sG1, 0.0), outdir + \"sG1.brep\");\n\tOCCTIO::OCCTTool::Write(MakeEdge(curve1), outdir + \"curve1.brep\");\n\tOCCTIO::OCCTTool::Write(MakeEdge(curve2), outdir + \"curve2.brep\"); \n\tOCCTIO::OCCTTool::Write(MakeEdge(f1), outdir + \"f1.brep\");\n\tOCCTIO::OCCTTool::Write(MakeEdge(f2), outdir + \"f2.brep\");\n\tOCCTIO::OCCTTool::Write(MakeEdge(f3), outdir + \"f3.brep\");\n\tOCCTIO::OCCTTool::Write(MakeEdge(f4), outdir + \"f4.brep\");\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static std::vector<TopoFace> MatchFace( const TopoFace& face1, const TopoEdge& edge1, const TopoFace& face2, const TopoEdge& edge2, ContinuityType connectCont, int otherEndCont, bool isPrecise, const std::vector<double>& tol, std::vector<double>& params, bool isEachOther, const NURBSMatchSurfConfig& surf1Config, const NURBSMatchSurfConfig& surf2Config),\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <nurbs/NURBSAPIMatch.hpp>\n#include <topology/TopoEdge.hpp>\n#include <topology/TopoTool.hpp>\n#include <nurbs/NURBSAPISweep.hpp>\n#include <nurbs/NURBSAPIRebuild.hpp>\n#include <modeling/MakeWire.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <offset/MakePipeShell.hpp>\n#include <geometry/Geom3BSplineSurface.hpp>\n#include <topology/TopoVertex.hpp>\n#include <topomesh/BRepMeshIncrementalMesh.hpp>\n#include <geometry/GeomAPIProjectPointOnCurve3.hpp>\n#include <modeling/TransformShape.hpp>\n#include <nurbs/NURBSAPIMatch.hpp>\n#include <modeling/MakeFace.hpp>\n#include <nurbs/NURBSAPIConvert.hpp>\n#include <topology/TopoExplorerTool.hpp>\n#include <modeling/MakeVertex.hpp>\nusing namespace AMCAX;\nstd::shared_ptr<Geom3BSplineSurface> GenerateTestSurface11(const int id)\n{\n\tstd::shared_ptr<Geom3BSplineSurface> bspSurf;\n\tswitch (id)\n\t{\n\tcase 0:\n\t{\n\t\tstd::vector<Point3> profilePoles;\n\t\tstd::vector<double> profileKnots(3);\n\t\tstd::vector<int> profileMults(3, 1);\n\t\tprofilePoles.push_back(Point3(0.0, 0.0, 0.0));\n\t\tprofilePoles.push_back(Point3(1.0, -0.2, 0.1));\n\t\tprofilePoles.push_back(Point3(2.0, 0.1, -0.1));\n\t\tprofilePoles.push_back(Point3(3.0, -0.1, 0.0));\n\t\tprofilePoles.push_back(Point3(4.0, 0.1, 0.2));\n\t\tprofileKnots[0] = 0;\n\t\tprofileKnots[1] = 0.5;\n\t\tprofileKnots[2] = 1;\n\t\tprofileMults.front() = 4;\n\t\tprofileMults.back() = 4;\n\t\tstd::shared_ptr<Geom3BSplineCurve> profileCurve = std::make_shared<Geom3BSplineCurve>(profilePoles, profileKnots, profileMults, 3);\n\t\tstd::vector<Point3> spinePoles;\n\t\tstd::vector<double> spineKnots(4);\n\t\tstd::vector<int> spineMults(4, 1);\n\t\tspinePoles.push_back(Point3(0.0, 0.0, 0.0));\n\t\tspinePoles.push_back(Point3(-0.1, 1.0, -0.2));\n\t\tspinePoles.push_back(Point3(0.1, 2.0, -0.1));\n\t\tspinePoles.push_back(Point3(0.2, 3.0, 0.1));\n\t\tspinePoles.push_back(Point3(0.1, 4.0, 0.0));\n\t\tspinePoles.push_back(Point3(0.0, 5.0, -0.1));\n\t\tspineKnots[0] = 0;\n\t\tspineKnots[1] = 1.0 / 3.0;\n\t\tspineKnots[2] = 2.0 / 3.0;\n\t\tspineKnots[3] = 1;\n\t\tspineMults.front() = 4;\n\t\tspineMults.back() = 4;\n\t\tstd::shared_ptr<Geom3BSplineCurve> spineCurve = std::make_shared<Geom3BSplineCurve>(spinePoles, spineKnots, spineMults, 3);\n\t\tTopoWire profile = MakeWire(MakeEdge(profileCurve)).Wire();\n\t\tTopoWire spine = MakeWire(MakeEdge(spineCurve)).Wire();\n\t\tMakePipeShell pipeShell(spine);\n\t\tpipeShell.Add(profile);\n\t\tpipeShell.SetMode(Frame3());\n\t\tTopoShape pipe = pipeShell.Shape();\n\t\tTopoExplorer ex(pipe, ShapeType::Face);\n\t\tTopoFace inputBasicFace = static_cast<const TopoFace&>(ex.Current());\n\t\tauto surf = TopoTool::Surface(inputBasicFace);\n\t\tbspSurf = NURBSAPIConvert::ToBSpline(surf);\n\t\tbreak;\n\t}\n\tcase 1:\n\t{\n\t\tArray2<Point3> poles(2, 5);\n\t\tpoles(0, 0) = Point3(0.0, 0.0, 0.0);\n\t\tpoles(0, 1) = Point3(1.0, -0.2, 0.1);\n\t\tpoles(0, 2) = Point3(2.0, 0.1, -0.1);\n\t\tpoles(0, 3) = Point3(3.0, -0.1, 0.0);\n\t\tpoles(0, 4) = Point3(4.0, 0.1, 0.2);\n\t\tpoles(1, 0) = Point3(0.0, 1.0, -0.1);\n\t\tpoles(1, 1) = Point3(1.0, 0.8, 0.0);\n\t\tpoles(1, 2) = Point3(2.0, 1.1, -0.2);\n\t\tpoles(1, 3) = Point3(3.0, 0.9, -0.1);\n\t\tpoles(1, 4) = Point3(4.0, 1.1, 0.1);\n\t\tstd::vector<double> vKnots(3);\n\t\tstd::vector<int> vMults(3, 1);\n\t\tvKnots[0] = 0;\n\t\tvKnots[1] = 0.5;\n\t\tvKnots[2] = 1;\n\t\tvMults.front() = 4;\n\t\tvMults.back() = 4;\n\t\tstd::vector<double> uKnots(2);\n\t\tstd::vector<int> uMults(2, 1);\n\t\tuKnots[0] = 0;\n\t\tuKnots[1] = 1;\n\t\tuMults.front() = 2;\n\t\tuMults.back() = 2;\n\t\tbspSurf = std::make_shared<Geom3BSplineSurface>(poles, uKnots, vKnots, uMults, vMults, 1, 3);\n\t\tTransformation3 trsf;\n\t\ttrsf.SetTranslationPart(Vector3(0.0, -6.0, 0.0));\n\t\tbspSurf->Transform(trsf);\n\t\tbreak;\n\t}\n\tcase 2:\n\t{\n\t\tstd::vector<Point3> profilePoles;\n\t\tstd::vector<double> profileKnots(4);\n\t\tstd::vector<int> profileMults(4, 1);\n\t\tprofilePoles.push_back(Point3(0.0, 0.0, 0.0));\n\t\tprofilePoles.push_back(Point3(1.0, -2.0, -3.0));\n\t\tprofilePoles.push_back(Point3(2.0, 1.0, 2.0));\n\t\tprofilePoles.push_back(Point3(3.0, -1.0, -1.0));\n\t\tprofilePoles.push_back(Point3(4.0, -3.0, 3.0));\n\t\tprofilePoles.push_back(Point3(5.0, 0.0, 1.0));\n\t\tprofileKnots[0] = 0;\n\t\tprofileKnots[1] = 1.0 / 3.0;\n\t\tprofileKnots[2] = 2.0 / 3.0;\n\t\tprofileKnots[3] = 1;\n\t\tprofileMults.front() = 4;\n\t\tprofileMults.back() = 4;\n\t\tstd::shared_ptr<Geom3BSplineCurve> profileCurve = std::make_shared<Geom3BSplineCurve>(profilePoles, profileKnots, profileMults, 3);\n\t\tstd::vector<Point3> spinePoles;\n\t\tstd::vector<double> spineKnots(4);\n\t\tstd::vector<int> spineMults(4, 1);\n\t\tspinePoles.push_back(Point3(0.0, 0.0, 0.0));\n\t\tspinePoles.push_back(Point3(-0.1, 1.0, -1.0));\n\t\tspinePoles.push_back(Point3(0.1, -2.0, -2.0));\n\t\tspinePoles.push_back(Point3(0.2, -3.0, -3.0));\n\t\tspinePoles.push_back(Point3(0.1, -4.0, -4.0));\n\t\tspinePoles.push_back(Point3(0.0, -2.5, -5.0));\n\t\tspinePoles.push_back(Point3(0.1, -1.0, -6.0));\n\t\tspinePoles.push_back(Point3(0.0, 0.0, -7.0));\n\t\tspineKnots[0] = 0;\n\t\tspineKnots[1] = 1.0 / 3.0;\n\t\tspineKnots[2] = 2.0 / 3.0;\n\t\tspineKnots[3] = 1;\n\t\tspineMults.front() = 6;\n\t\tspineMults.back() = 6;\n\t\tshared_ptr<Geom3BSplineCurve> spineCurve = std::make_shared<Geom3BSplineCurve>(spinePoles, spineKnots, spineMults, 5);\n\t\tTopoWire profile = MakeWire(MakeEdge(profileCurve)).Wire();\n\t\tTopoWire spine = MakeWire(MakeEdge(spineCurve)).Wire();\n\t\tMakePipeShell pipeShell(spine);\n\t\tpipeShell.Add(profile);\n\t\tpipeShell.SetMode(Frame3());\n\t\tTopoShape pipe = pipeShell.Shape();\n\t\tTopoExplorer ex(pipe, ShapeType::Face);\n\t\tTopoFace inputBasicFace = static_cast<const TopoFace&>(ex.Current());\n\t\tshared_ptr<Geom3Surface> surf = TopoTool::Surface(inputBasicFace);\n\t\tshared_ptr<Geom3BSplineSurface>  bspSurf = NURBSAPIConvert::ToBSpline(surf);\n\t\tTransformation3 trsf;\n\t\ttrsf.SetTranslationPart(Vector3(-6.0, 0.0, 0.0));\n\t\tbspSurf->Transform(trsf);\n\t\tbreak;\n\t}\n\t}\n\treturn bspSurf;\n}\n#include<catch.hpp>\n#include<testHelper.h>\n#include <nurbs/NURBSAPIMatch.hpp>\n#include <topology/TopoEdge.hpp>\n#include <topology/TopoTool.hpp>\n#include <nurbs/NURBSAPISweep.hpp>\n#include <nurbs/NURBSAPIRebuild.hpp>\n#include <modeling/MakeWire.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <offset/MakePipeShell.hpp>\n#include <geometry/Geom3BSplineSurface.hpp>\n#include <topology/TopoVertex.hpp>\n#include <topomesh/BRepMeshIncrementalMesh.hpp>\n#include <geometry/GeomAPIProjectPointOnCurve3.hpp>\n#include <modeling/TransformShape.hpp>\n#include <nurbs/NURBSAPIMatch.hpp>\n#include <modeling/MakeFace.hpp>\n#include <nurbs/NURBSAPIConvert.hpp>\n#include <topology/TopoExplorerTool.hpp>\n#include <modeling/MakeVertex.hpp>\nusing namespace AMCAX;\nstd::shared_ptr<Geom3BSplineSurface> GenerateTestSurface11(const int id)\n{\n\tstd::shared_ptr<Geom3BSplineSurface> bspSurf;\n\tswitch (id)\n\t{\n\tcase 0:\n\t{\n\t\tstd::vector<Point3> profilePoles;\n\t\tstd::vector<double> profileKnots(3);\n\t\tstd::vector<int> profileMults(3, 1);\n\t\tprofilePoles.push_back(Point3(0.0, 0.0, 0.0));\n\t\tprofilePoles.push_back(Point3(1.0, -0.2, 0.1));\n\t\tprofilePoles.push_back(Point3(2.0, 0.1, -0.1));\n\t\tprofilePoles.push_back(Point3(3.0, -0.1, 0.0));\n\t\tprofilePoles.push_back(Point3(4.0, 0.1, 0.2));\n\t\tprofileKnots[0] = 0;\n\t\tprofileKnots[1] = 0.5;\n\t\tprofileKnots[2] = 1;\n\t\tprofileMults.front() = 4;\n\t\tprofileMults.back() = 4;\n\t\tstd::shared_ptr<Geom3BSplineCurve> profileCurve = std::make_shared<Geom3BSplineCurve>(profilePoles, profileKnots, profileMults, 3);\n\t\tstd::vector<Point3> spinePoles;\n\t\tstd::vector<double> spineKnots(4);\n\t\tstd::vector<int> spineMults(4, 1);\n\t\tspinePoles.push_back(Point3(0.0, 0.0, 0.0));\n\t\tspinePoles.push_back(Point3(-0.1, 1.0, -0.2));\n\t\tspinePoles.push_back(Point3(0.1, 2.0, -0.1));\n\t\tspinePoles.push_back(Point3(0.2, 3.0, 0.1));\n\t\tspinePoles.push_back(Point3(0.1, 4.0, 0.0));\n\t\tspinePoles.push_back(Point3(0.0, 5.0, -0.1));\n\t\tspineKnots[0] = 0;\n\t\tspineKnots[1] = 1.0 / 3.0;\n\t\tspineKnots[2] = 2.0 / 3.0;\n\t\tspineKnots[3] = 1;\n\t\tspineMults.front() = 4;\n\t\tspineMults.back() = 4;\n\t\tstd::shared_ptr<Geom3BSplineCurve> spineCurve = std::make_shared<Geom3BSplineCurve>(spinePoles, spineKnots, spineMults, 3);\n\t\tTopoWire profile = MakeWire(MakeEdge(profileCurve)).Wire();\n\t\tTopoWire spine = MakeWire(MakeEdge(spineCurve)).Wire();\n\t\tMakePipeShell pipeShell(spine);\n\t\tpipeShell.Add(profile);\n\t\tpipeShell.SetMode(Frame3());\n\t\tTopoShape pipe = pipeShell.Shape();\n\t\tTopoExplorer ex(pipe, ShapeType::Face);\n\t\tTopoFace inputBasicFace = static_cast<const TopoFace&>(ex.Current());\n\t\tauto surf = TopoTool::Surface(inputBasicFace);\n\t\tbspSurf = NURBSAPIConvert::ToBSpline(surf);\n\t\tbreak;\n\t}\n\tcase 1:\n\t{\n\t\tArray2<Point3> poles(2, 5);\n\t\tpoles(0, 0) = Point3(0.0, 0.0, 0.0);\n\t\tpoles(0, 1) = Point3(1.0, -0.2, 0.1);\n\t\tpoles(0, 2) = Point3(2.0, 0.1, -0.1);\n\t\tpoles(0, 3) = Point3(3.0, -0.1, 0.0);\n\t\tpoles(0, 4) = Point3(4.0, 0.1, 0.2);\n\t\tpoles(1, 0) = Point3(0.0, 1.0, -0.1);\n\t\tpoles(1, 1) = Point3(1.0, 0.8, 0.0);\n\t\tpoles(1, 2) = Point3(2.0, 1.1, -0.2);\n\t\tpoles(1, 3) = Point3(3.0, 0.9, -0.1);\n\t\tpoles(1, 4) = Point3(4.0, 1.1, 0.1);\n\t\tstd::vector<double> vKnots(3);\n\t\tstd::vector<int> vMults(3, 1);\n\t\tvKnots[0] = 0;\n\t\tvKnots[1] = 0.5;\n\t\tvKnots[2] = 1;\n\t\tvMults.front() = 4;\n\t\tvMults.back() = 4;\n\t\tstd::vector<double> uKnots(2);\n\t\tstd::vector<int> uMults(2, 1);\n\t\tuKnots[0] = 0;\n\t\tuKnots[1] = 1;\n\t\tuMults.front() = 2;\n\t\tuMults.back() = 2;\n\t\tbspSurf = std::make_shared<Geom3BSplineSurface>(poles, uKnots, vKnots, uMults, vMults, 1, 3);\n\t\tTransformation3 trsf;\n\t\ttrsf.SetTranslationPart(Vector3(0.0, -6.0, 0.0));\n\t\tbspSurf->Transform(trsf);\n\t\tbreak;\n\t}\n\tcase 2:\n\t{\n\t\tstd::vector<Point3> profilePoles;\n\t\tstd::vector<double> profileKnots(4);\n\t\tstd::vector<int> profileMults(4, 1);\n\t\tprofilePoles.push_back(Point3(0.0, 0.0, 0.0));\n\t\tprofilePoles.push_back(Point3(1.0, -2.0, -3.0));\n\t\tprofilePoles.push_back(Point3(2.0, 1.0, 2.0));\n\t\tprofilePoles.push_back(Point3(3.0, -1.0, -1.0));\n\t\tprofilePoles.push_back(Point3(4.0, -3.0, 3.0));\n\t\tprofilePoles.push_back(Point3(5.0, 0.0, 1.0));\n\t\tprofileKnots[0] = 0;\n\t\tprofileKnots[1] = 1.0 / 3.0;\n\t\tprofileKnots[2] = 2.0 / 3.0;\n\t\tprofileKnots[3] = 1;\n\t\tprofileMults.front() = 4;\n\t\tprofileMults.back() = 4;\n\t\tstd::shared_ptr<Geom3BSplineCurve> profileCurve = std::make_shared<Geom3BSplineCurve>(profilePoles, profileKnots, profileMults, 3);\n\t\tstd::vector<Point3> spinePoles;\n\t\tstd::vector<double> spineKnots(4);\n\t\tstd::vector<int> spineMults(4, 1);\n\t\tspinePoles.push_back(Point3(0.0, 0.0, 0.0));\n\t\tspinePoles.push_back(Point3(-0.1, 1.0, -1.0));\n\t\tspinePoles.push_back(Point3(0.1, -2.0, -2.0));\n\t\tspinePoles.push_back(Point3(0.2, -3.0, -3.0));\n\t\tspinePoles.push_back(Point3(0.1, -4.0, -4.0));\n\t\tspinePoles.push_back(Point3(0.0, -2.5, -5.0));\n\t\tspinePoles.push_back(Point3(0.1, -1.0, -6.0));\n\t\tspinePoles.push_back(Point3(0.0, 0.0, -7.0));\n\t\tspineKnots[0] = 0;\n\t\tspineKnots[1] = 1.0 / 3.0;\n\t\tspineKnots[2] = 2.0 / 3.0;\n\t\tspineKnots[3] = 1;\n\t\tspineMults.front() = 6;\n\t\tspineMults.back() = 6;\n\t\tshared_ptr<Geom3BSplineCurve> spineCurve = std::make_shared<Geom3BSplineCurve>(spinePoles, spineKnots, spineMults, 5);\n\t\tTopoWire profile = MakeWire(MakeEdge(profileCurve)).Wire();\n\t\tTopoWire spine = MakeWire(MakeEdge(spineCurve)).Wire();\n\t\tMakePipeShell pipeShell(spine);\n\t\tpipeShell.Add(profile);\n\t\tpipeShell.SetMode(Frame3());\n\t\tTopoShape pipe = pipeShell.Shape();\n\t\tTopoExplorer ex(pipe, ShapeType::Face);\n\t\tTopoFace inputBasicFace = static_cast<const TopoFace&>(ex.Current());\n\t\tshared_ptr<Geom3Surface> surf = TopoTool::Surface(inputBasicFace);\n\t\tshared_ptr<Geom3BSplineSurface>  bspSurf = NURBSAPIConvert::ToBSpline(surf);\n\t\tTransformation3 trsf;\n\t\ttrsf.SetTranslationPart(Vector3(-6.0, 0.0, 0.0));\n\t\tbspSurf->Transform(trsf);\n\t\tbreak;\n\t}\n\t}\n\treturn bspSurf;\n;\n\tSECTION(\"MatchTrimmedSurface\")\n\t {\n\t\t OUTPUT_DIRECTORY(nurbs, Match/MatchFace/MatchTrimmedSurface);\n\t\t string filedir = INPUT_PATH_PREFIX\"./TestNURBS/TestMatchTrimmedSurface/\";\n\t\t TopoFace f1 = ReadBRepFace(filedir + \"surf1.brep\");\n\t\t TopoFace f2 = ReadBRepFace(filedir + \"surf2.brep\");\n\t\t Point3 p1, p2;\n\t\t bool isSurf1TrimmedEdge = true;\n\t\t bool isSurf2TrimmedEdge = true;\n\t\t if (isSurf1TrimmedEdge)\n\t\t {\n\t\t\t p1 = ReadBRepPoint(filedir + \"tptS1.brep\");\n\t\t }\n\t\t else\n\t\t {\n\t\t\t p1 = ReadBRepPoint(filedir + \"nptS1.brep\");\n\t\t }\n\t\t if (isSurf2TrimmedEdge)\n\t\t {\n\t\t\t p2 = ReadBRepPoint(filedir + \"tptS2.brep\");\n\t\t }\n\t\t else\n\t\t {\n\t\t\t p2 = ReadBRepPoint(filedir + \"nptS2.brep\");\n\t\t }\n\t\t auto [d1, e1] = NearestEdge(p1, f1);\n\t\t auto [d2, e2] = NearestEdge(p2, f2);\n\t\t ContinuityType cont = ContinuityType::G2;\n\t\t int otherEndCont = 0;\n\t\t NURBSMatchSurfConfig config;\n\t\t bool isPrecise = true;\n\t\t std::vector<double> tol;\n\t\t tol.push_back(0.001);\n\t\t tol.push_back(0.1);\n\t\t tol.push_back(0.05);\n\t\t std::vector<double> params(2, 1.0);\n\t\t auto result = NURBSAPIMatch::MatchFace(f1, e1, f2, e2, cont, otherEndCont, isPrecise, tol, params, false, config, config);\n\t\t OCCTIO::OCCTTool::Write(f1, outdir + \"f1.brep\");\n\t\t OCCTIO::OCCTTool::Write(f2, outdir + \"f2.brep\");\n\t\t OCCTIO::OCCTTool::Write(MakeVertex(p1), outdir + \"p1.brep\");\n\t\t OCCTIO::OCCTTool::Write(MakeVertex(p2), outdir + \"p2.brep\");\n\t\t OCCTIO::OCCTTool::Write(e1, outdir + \"e1.brep\");\n\t\t OCCTIO::OCCTTool::Write(e2, outdir + \"e2.brep\");\n\t }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static std::vector<std::shared_ptr<Geom3BSplineSurface>> MatchSurf( const std::shared_ptr<Geom3BSplineSurface> surf, bool isModifyU, bool isFront, const std::shared_ptr<Geom3BSplineSurface>& targetSurf, bool isTargetU, bool isTargetFront, ContinuityType connectCont, int otherEndCont, bool isPrecise, const std::vector<double>& tol, std::vector<double>& params, bool isEachOther, const NURBSMatchSurfConfig& surfConfig, const NURBSMatchSurfConfig& targetSurfConfig),\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <nurbs/NURBSAPIMatch.hpp>\n#include <topology/TopoEdge.hpp>\n#include <topology/TopoTool.hpp>\n#include <nurbs/NURBSAPISweep.hpp>\n#include <nurbs/NURBSAPIRebuild.hpp>\n#include <modeling/MakeWire.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <offset/MakePipeShell.hpp>\n#include <geometry/Geom3BSplineSurface.hpp>\n#include <topology/TopoVertex.hpp>\n#include <topomesh/BRepMeshIncrementalMesh.hpp>\n#include <geometry/GeomAPIProjectPointOnCurve3.hpp>\n#include <modeling/TransformShape.hpp>\n#include <nurbs/NURBSAPIMatch.hpp>\n#include <modeling/MakeFace.hpp>\n#include <nurbs/NURBSAPIConvert.hpp>\n#include <topology/TopoExplorerTool.hpp>\n#include <modeling/MakeVertex.hpp>\nusing namespace AMCAX;\nstd::shared_ptr<Geom3BSplineSurface> GenerateTestSurface11(const int id)\n{\n\tstd::shared_ptr<Geom3BSplineSurface> bspSurf;\n\tswitch (id)\n\t{\n\tcase 0:\n\t{\n\t\tstd::vector<Point3> profilePoles;\n\t\tstd::vector<double> profileKnots(3);\n\t\tstd::vector<int> profileMults(3, 1);\n\t\tprofilePoles.push_back(Point3(0.0, 0.0, 0.0));\n\t\tprofilePoles.push_back(Point3(1.0, -0.2, 0.1));\n\t\tprofilePoles.push_back(Point3(2.0, 0.1, -0.1));\n\t\tprofilePoles.push_back(Point3(3.0, -0.1, 0.0));\n\t\tprofilePoles.push_back(Point3(4.0, 0.1, 0.2));\n\t\tprofileKnots[0] = 0;\n\t\tprofileKnots[1] = 0.5;\n\t\tprofileKnots[2] = 1;\n\t\tprofileMults.front() = 4;\n\t\tprofileMults.back() = 4;\n\t\tstd::shared_ptr<Geom3BSplineCurve> profileCurve = std::make_shared<Geom3BSplineCurve>(profilePoles, profileKnots, profileMults, 3);\n\t\tstd::vector<Point3> spinePoles;\n\t\tstd::vector<double> spineKnots(4);\n\t\tstd::vector<int> spineMults(4, 1);\n\t\tspinePoles.push_back(Point3(0.0, 0.0, 0.0));\n\t\tspinePoles.push_back(Point3(-0.1, 1.0, -0.2));\n\t\tspinePoles.push_back(Point3(0.1, 2.0, -0.1));\n\t\tspinePoles.push_back(Point3(0.2, 3.0, 0.1));\n\t\tspinePoles.push_back(Point3(0.1, 4.0, 0.0));\n\t\tspinePoles.push_back(Point3(0.0, 5.0, -0.1));\n\t\tspineKnots[0] = 0;\n\t\tspineKnots[1] = 1.0 / 3.0;\n\t\tspineKnots[2] = 2.0 / 3.0;\n\t\tspineKnots[3] = 1;\n\t\tspineMults.front() = 4;\n\t\tspineMults.back() = 4;\n\t\tstd::shared_ptr<Geom3BSplineCurve> spineCurve = std::make_shared<Geom3BSplineCurve>(spinePoles, spineKnots, spineMults, 3);\n\t\tTopoWire profile = MakeWire(MakeEdge(profileCurve)).Wire();\n\t\tTopoWire spine = MakeWire(MakeEdge(spineCurve)).Wire();\n\t\tMakePipeShell pipeShell(spine);\n\t\tpipeShell.Add(profile);\n\t\tpipeShell.SetMode(Frame3());\n\t\tTopoShape pipe = pipeShell.Shape();\n\t\tTopoExplorer ex(pipe, ShapeType::Face);\n\t\tTopoFace inputBasicFace = static_cast<const TopoFace&>(ex.Current());\n\t\tauto surf = TopoTool::Surface(inputBasicFace);\n\t\tbspSurf = NURBSAPIConvert::ToBSpline(surf);\n\t\tbreak;\n\t}\n\tcase 1:\n\t{\n\t\tArray2<Point3> poles(2, 5);\n\t\tpoles(0, 0) = Point3(0.0, 0.0, 0.0);\n\t\tpoles(0, 1) = Point3(1.0, -0.2, 0.1);\n\t\tpoles(0, 2) = Point3(2.0, 0.1, -0.1);\n\t\tpoles(0, 3) = Point3(3.0, -0.1, 0.0);\n\t\tpoles(0, 4) = Point3(4.0, 0.1, 0.2);\n\t\tpoles(1, 0) = Point3(0.0, 1.0, -0.1);\n\t\tpoles(1, 1) = Point3(1.0, 0.8, 0.0);\n\t\tpoles(1, 2) = Point3(2.0, 1.1, -0.2);\n\t\tpoles(1, 3) = Point3(3.0, 0.9, -0.1);\n\t\tpoles(1, 4) = Point3(4.0, 1.1, 0.1);\n\t\tstd::vector<double> vKnots(3);\n\t\tstd::vector<int> vMults(3, 1);\n\t\tvKnots[0] = 0;\n\t\tvKnots[1] = 0.5;\n\t\tvKnots[2] = 1;\n\t\tvMults.front() = 4;\n\t\tvMults.back() = 4;\n\t\tstd::vector<double> uKnots(2);\n\t\tstd::vector<int> uMults(2, 1);\n\t\tuKnots[0] = 0;\n\t\tuKnots[1] = 1;\n\t\tuMults.front() = 2;\n\t\tuMults.back() = 2;\n\t\tbspSurf = std::make_shared<Geom3BSplineSurface>(poles, uKnots, vKnots, uMults, vMults, 1, 3);\n\t\tTransformation3 trsf;\n\t\ttrsf.SetTranslationPart(Vector3(0.0, -6.0, 0.0));\n\t\tbspSurf->Transform(trsf);\n\t\tbreak;\n\t}\n\tcase 2:\n\t{\n\t\tstd::vector<Point3> profilePoles;\n\t\tstd::vector<double> profileKnots(4);\n\t\tstd::vector<int> profileMults(4, 1);\n\t\tprofilePoles.push_back(Point3(0.0, 0.0, 0.0));\n\t\tprofilePoles.push_back(Point3(1.0, -2.0, -3.0));\n\t\tprofilePoles.push_back(Point3(2.0, 1.0, 2.0));\n\t\tprofilePoles.push_back(Point3(3.0, -1.0, -1.0));\n\t\tprofilePoles.push_back(Point3(4.0, -3.0, 3.0));\n\t\tprofilePoles.push_back(Point3(5.0, 0.0, 1.0));\n\t\tprofileKnots[0] = 0;\n\t\tprofileKnots[1] = 1.0 / 3.0;\n\t\tprofileKnots[2] = 2.0 / 3.0;\n\t\tprofileKnots[3] = 1;\n\t\tprofileMults.front() = 4;\n\t\tprofileMults.back() = 4;\n\t\tstd::shared_ptr<Geom3BSplineCurve> profileCurve = std::make_shared<Geom3BSplineCurve>(profilePoles, profileKnots, profileMults, 3);\n\t\tstd::vector<Point3> spinePoles;\n\t\tstd::vector<double> spineKnots(4);\n\t\tstd::vector<int> spineMults(4, 1);\n\t\tspinePoles.push_back(Point3(0.0, 0.0, 0.0));\n\t\tspinePoles.push_back(Point3(-0.1, 1.0, -1.0));\n\t\tspinePoles.push_back(Point3(0.1, -2.0, -2.0));\n\t\tspinePoles.push_back(Point3(0.2, -3.0, -3.0));\n\t\tspinePoles.push_back(Point3(0.1, -4.0, -4.0));\n\t\tspinePoles.push_back(Point3(0.0, -2.5, -5.0));\n\t\tspinePoles.push_back(Point3(0.1, -1.0, -6.0));\n\t\tspinePoles.push_back(Point3(0.0, 0.0, -7.0));\n\t\tspineKnots[0] = 0;\n\t\tspineKnots[1] = 1.0 / 3.0;\n\t\tspineKnots[2] = 2.0 / 3.0;\n\t\tspineKnots[3] = 1;\n\t\tspineMults.front() = 6;\n\t\tspineMults.back() = 6;\n\t\tshared_ptr<Geom3BSplineCurve> spineCurve = std::make_shared<Geom3BSplineCurve>(spinePoles, spineKnots, spineMults, 5);\n\t\tTopoWire profile = MakeWire(MakeEdge(profileCurve)).Wire();\n\t\tTopoWire spine = MakeWire(MakeEdge(spineCurve)).Wire();\n\t\tMakePipeShell pipeShell(spine);\n\t\tpipeShell.Add(profile);\n\t\tpipeShell.SetMode(Frame3());\n\t\tTopoShape pipe = pipeShell.Shape();\n\t\tTopoExplorer ex(pipe, ShapeType::Face);\n\t\tTopoFace inputBasicFace = static_cast<const TopoFace&>(ex.Current());\n\t\tshared_ptr<Geom3Surface> surf = TopoTool::Surface(inputBasicFace);\n\t\tshared_ptr<Geom3BSplineSurface>  bspSurf = NURBSAPIConvert::ToBSpline(surf);\n\t\tTransformation3 trsf;\n\t\ttrsf.SetTranslationPart(Vector3(-6.0, 0.0, 0.0));\n\t\tbspSurf->Transform(trsf);\n\t\tbreak;\n\t}\n\t}\n\treturn bspSurf;\n}\n#include<catch.hpp>\n#include<testHelper.h>\n#include <nurbs/NURBSAPIMatch.hpp>\n#include <topology/TopoEdge.hpp>\n#include <topology/TopoTool.hpp>\n#include <nurbs/NURBSAPISweep.hpp>\n#include <nurbs/NURBSAPIRebuild.hpp>\n#include <modeling/MakeWire.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <offset/MakePipeShell.hpp>\n#include <geometry/Geom3BSplineSurface.hpp>\n#include <topology/TopoVertex.hpp>\n#include <topomesh/BRepMeshIncrementalMesh.hpp>\n#include <geometry/GeomAPIProjectPointOnCurve3.hpp>\n#include <modeling/TransformShape.hpp>\n#include <nurbs/NURBSAPIMatch.hpp>\n#include <modeling/MakeFace.hpp>\n#include <nurbs/NURBSAPIConvert.hpp>\n#include <topology/TopoExplorerTool.hpp>\n#include <modeling/MakeVertex.hpp>\nusing namespace AMCAX;\nstd::shared_ptr<Geom3BSplineSurface> GenerateTestSurface11(const int id)\n{\n\tstd::shared_ptr<Geom3BSplineSurface> bspSurf;\n\tswitch (id)\n\t{\n\tcase 0:\n\t{\n\t\tstd::vector<Point3> profilePoles;\n\t\tstd::vector<double> profileKnots(3);\n\t\tstd::vector<int> profileMults(3, 1);\n\t\tprofilePoles.push_back(Point3(0.0, 0.0, 0.0));\n\t\tprofilePoles.push_back(Point3(1.0, -0.2, 0.1));\n\t\tprofilePoles.push_back(Point3(2.0, 0.1, -0.1));\n\t\tprofilePoles.push_back(Point3(3.0, -0.1, 0.0));\n\t\tprofilePoles.push_back(Point3(4.0, 0.1, 0.2));\n\t\tprofileKnots[0] = 0;\n\t\tprofileKnots[1] = 0.5;\n\t\tprofileKnots[2] = 1;\n\t\tprofileMults.front() = 4;\n\t\tprofileMults.back() = 4;\n\t\tstd::shared_ptr<Geom3BSplineCurve> profileCurve = std::make_shared<Geom3BSplineCurve>(profilePoles, profileKnots, profileMults, 3);\n\t\tstd::vector<Point3> spinePoles;\n\t\tstd::vector<double> spineKnots(4);\n\t\tstd::vector<int> spineMults(4, 1);\n\t\tspinePoles.push_back(Point3(0.0, 0.0, 0.0));\n\t\tspinePoles.push_back(Point3(-0.1, 1.0, -0.2));\n\t\tspinePoles.push_back(Point3(0.1, 2.0, -0.1));\n\t\tspinePoles.push_back(Point3(0.2, 3.0, 0.1));\n\t\tspinePoles.push_back(Point3(0.1, 4.0, 0.0));\n\t\tspinePoles.push_back(Point3(0.0, 5.0, -0.1));\n\t\tspineKnots[0] = 0;\n\t\tspineKnots[1] = 1.0 / 3.0;\n\t\tspineKnots[2] = 2.0 / 3.0;\n\t\tspineKnots[3] = 1;\n\t\tspineMults.front() = 4;\n\t\tspineMults.back() = 4;\n\t\tstd::shared_ptr<Geom3BSplineCurve> spineCurve = std::make_shared<Geom3BSplineCurve>(spinePoles, spineKnots, spineMults, 3);\n\t\tTopoWire profile = MakeWire(MakeEdge(profileCurve)).Wire();\n\t\tTopoWire spine = MakeWire(MakeEdge(spineCurve)).Wire();\n\t\tMakePipeShell pipeShell(spine);\n\t\tpipeShell.Add(profile);\n\t\tpipeShell.SetMode(Frame3());\n\t\tTopoShape pipe = pipeShell.Shape();\n\t\tTopoExplorer ex(pipe, ShapeType::Face);\n\t\tTopoFace inputBasicFace = static_cast<const TopoFace&>(ex.Current());\n\t\tauto surf = TopoTool::Surface(inputBasicFace);\n\t\tbspSurf = NURBSAPIConvert::ToBSpline(surf);\n\t\tbreak;\n\t}\n\tcase 1:\n\t{\n\t\tArray2<Point3> poles(2, 5);\n\t\tpoles(0, 0) = Point3(0.0, 0.0, 0.0);\n\t\tpoles(0, 1) = Point3(1.0, -0.2, 0.1);\n\t\tpoles(0, 2) = Point3(2.0, 0.1, -0.1);\n\t\tpoles(0, 3) = Point3(3.0, -0.1, 0.0);\n\t\tpoles(0, 4) = Point3(4.0, 0.1, 0.2);\n\t\tpoles(1, 0) = Point3(0.0, 1.0, -0.1);\n\t\tpoles(1, 1) = Point3(1.0, 0.8, 0.0);\n\t\tpoles(1, 2) = Point3(2.0, 1.1, -0.2);\n\t\tpoles(1, 3) = Point3(3.0, 0.9, -0.1);\n\t\tpoles(1, 4) = Point3(4.0, 1.1, 0.1);\n\t\tstd::vector<double> vKnots(3);\n\t\tstd::vector<int> vMults(3, 1);\n\t\tvKnots[0] = 0;\n\t\tvKnots[1] = 0.5;\n\t\tvKnots[2] = 1;\n\t\tvMults.front() = 4;\n\t\tvMults.back() = 4;\n\t\tstd::vector<double> uKnots(2);\n\t\tstd::vector<int> uMults(2, 1);\n\t\tuKnots[0] = 0;\n\t\tuKnots[1] = 1;\n\t\tuMults.front() = 2;\n\t\tuMults.back() = 2;\n\t\tbspSurf = std::make_shared<Geom3BSplineSurface>(poles, uKnots, vKnots, uMults, vMults, 1, 3);\n\t\tTransformation3 trsf;\n\t\ttrsf.SetTranslationPart(Vector3(0.0, -6.0, 0.0));\n\t\tbspSurf->Transform(trsf);\n\t\tbreak;\n\t}\n\tcase 2:\n\t{\n\t\tstd::vector<Point3> profilePoles;\n\t\tstd::vector<double> profileKnots(4);\n\t\tstd::vector<int> profileMults(4, 1);\n\t\tprofilePoles.push_back(Point3(0.0, 0.0, 0.0));\n\t\tprofilePoles.push_back(Point3(1.0, -2.0, -3.0));\n\t\tprofilePoles.push_back(Point3(2.0, 1.0, 2.0));\n\t\tprofilePoles.push_back(Point3(3.0, -1.0, -1.0));\n\t\tprofilePoles.push_back(Point3(4.0, -3.0, 3.0));\n\t\tprofilePoles.push_back(Point3(5.0, 0.0, 1.0));\n\t\tprofileKnots[0] = 0;\n\t\tprofileKnots[1] = 1.0 / 3.0;\n\t\tprofileKnots[2] = 2.0 / 3.0;\n\t\tprofileKnots[3] = 1;\n\t\tprofileMults.front() = 4;\n\t\tprofileMults.back() = 4;\n\t\tstd::shared_ptr<Geom3BSplineCurve> profileCurve = std::make_shared<Geom3BSplineCurve>(profilePoles, profileKnots, profileMults, 3);\n\t\tstd::vector<Point3> spinePoles;\n\t\tstd::vector<double> spineKnots(4);\n\t\tstd::vector<int> spineMults(4, 1);\n\t\tspinePoles.push_back(Point3(0.0, 0.0, 0.0));\n\t\tspinePoles.push_back(Point3(-0.1, 1.0, -1.0));\n\t\tspinePoles.push_back(Point3(0.1, -2.0, -2.0));\n\t\tspinePoles.push_back(Point3(0.2, -3.0, -3.0));\n\t\tspinePoles.push_back(Point3(0.1, -4.0, -4.0));\n\t\tspinePoles.push_back(Point3(0.0, -2.5, -5.0));\n\t\tspinePoles.push_back(Point3(0.1, -1.0, -6.0));\n\t\tspinePoles.push_back(Point3(0.0, 0.0, -7.0));\n\t\tspineKnots[0] = 0;\n\t\tspineKnots[1] = 1.0 / 3.0;\n\t\tspineKnots[2] = 2.0 / 3.0;\n\t\tspineKnots[3] = 1;\n\t\tspineMults.front() = 6;\n\t\tspineMults.back() = 6;\n\t\tshared_ptr<Geom3BSplineCurve> spineCurve = std::make_shared<Geom3BSplineCurve>(spinePoles, spineKnots, spineMults, 5);\n\t\tTopoWire profile = MakeWire(MakeEdge(profileCurve)).Wire();\n\t\tTopoWire spine = MakeWire(MakeEdge(spineCurve)).Wire();\n\t\tMakePipeShell pipeShell(spine);\n\t\tpipeShell.Add(profile);\n\t\tpipeShell.SetMode(Frame3());\n\t\tTopoShape pipe = pipeShell.Shape();\n\t\tTopoExplorer ex(pipe, ShapeType::Face);\n\t\tTopoFace inputBasicFace = static_cast<const TopoFace&>(ex.Current());\n\t\tshared_ptr<Geom3Surface> surf = TopoTool::Surface(inputBasicFace);\n\t\tshared_ptr<Geom3BSplineSurface>  bspSurf = NURBSAPIConvert::ToBSpline(surf);\n\t\tTransformation3 trsf;\n\t\ttrsf.SetTranslationPart(Vector3(-6.0, 0.0, 0.0));\n\t\tbspSurf->Transform(trsf);\n\t\tbreak;\n\t}\n\t}\n\treturn bspSurf;\n;\n\tSECTION(\"MatchSurf1\")\n\t {\n\t\t OUTPUT_DIRECTORY(nurbs, Match/MatchSurf/MatchSurf1);\n\t\t string filedir = INPUT_PATH_PREFIX\"./TestNURBS/TestMatchSurf/\";\n\t\t shared_ptr<Geom3BSplineSurface> surface1 = ReadBRepSurface(filedir + \"surface1.brep\");\n\t\t shared_ptr<Geom3BSplineSurface> surface2 = ReadBRepSurface(filedir + \"surface2.brep\");\n\t\t bool isU1 = false, isFront1 = false, isU2 = false, isFront2 = true;\n\t\t ContinuityType cont = ContinuityType::G2; \n\t\t int otherEndCont = 0;\t\t\t\t\t  \n\t\t bool isAutoReverse = true;\n\t\t bool isPrecise = true;\n\t\t vector<double> tol;\n\t\t tol.push_back(0.001);\n\t\t tol.push_back(M_PI / 180.0);\n\t\t tol.push_back(0.0005);\n\t\t bool isEachOther = false;\n\t\t NURBSMatchSurfConfig config;\n\t\t config.isOrientationFixed = !isAutoReverse;\n\t\t vector<double> params;\n\t\t auto bspSurf3 = NURBSAPIMatch::MatchSurf(surface2, isU2, isFront2, surface1, isU1, isFront1, cont, otherEndCont, isPrecise, tol, params, isEachOther, config, config);\n\t\t for (const auto& s : bspSurf3)\n\t\t {\n\t\t\t OCCTIO::OCCTTool::Write(MakeFace(s, 0.0), outdir + \"result.brep\");\n\t\t }\n\t\t double f1 = surface1->LastVParameter();\n\t\t double f2 = surface2->LastVParameter();\n\t\t double f3 = bspSurf3[0]->FirstVParameter();\n\t\t double f4 = bspSurf3[0]->LastVParameter();\n\t\t shared_ptr<Geom3Curve> fu1 = surface1->VIso(f1);\n\t\t shared_ptr<Geom3Curve> fu2 = surface2->VIso(f2);\n\t\t shared_ptr<Geom3Curve> fu3 = bspSurf3[0]->VIso(f3);\n\t\t shared_ptr<Geom3Curve> fu4 = bspSurf3[0]->VIso(f4);\n\t\t int num = 1000;\n\t\t double resTol = 1e-3;\n\t\t double ratio = 0.1;\n\t\t double res1 = NurbsSampleCurve(num, resTol, fu3, fu1);\n\t\t double res2 = NurbsSampleCurve(num, resTol, fu4, fu2);\n\t\t CHECK(res1 <= ratio);\n\t\t CHECK(res2 <= ratio);\n\t\t OCCTIO::OCCTTool::Write(MakeEdge(fu1), outdir + \"fu1.brep\");\n\t\t OCCTIO::OCCTTool::Write(MakeEdge(fu2), outdir + \"fu2.brep\");\n\t\t OCCTIO::OCCTTool::Write(MakeEdge(fu3), outdir + \"fu3.brep\");\n\t\t OCCTIO::OCCTTool::Write(MakeEdge(fu4), outdir + \"fu4.brep\");\n\t\t OCCTIO::OCCTTool::Write(MakeFace(surface1, 0.0), outdir + \"surface1.brep\");\n\t\t OCCTIO::OCCTTool::Write(MakeFace(surface2, 0.0), outdir + \"surface2.brep\");\n\t }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static std::shared_ptr<Geom3BSplineCurve> MatchCurve( ContinuityType cont, const std::shared_ptr<Geom3BSplineCurve>& curve, bool isFront, const std::shared_ptr<Geom3BSplineCurve>& targetCurve, bool isTargetFront, int otherEndCont),\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <nurbs/NURBSAPIMatch.hpp>\n#include <topology/TopoEdge.hpp>\n#include <topology/TopoTool.hpp>\n#include <nurbs/NURBSAPISweep.hpp>\n#include <nurbs/NURBSAPIRebuild.hpp>\n#include <modeling/MakeWire.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <offset/MakePipeShell.hpp>\n#include <geometry/Geom3BSplineSurface.hpp>\n#include <topology/TopoVertex.hpp>\n#include <topomesh/BRepMeshIncrementalMesh.hpp>\n#include <geometry/GeomAPIProjectPointOnCurve3.hpp>\n#include <modeling/TransformShape.hpp>\n#include <nurbs/NURBSAPIMatch.hpp>\n#include <modeling/MakeFace.hpp>\n#include <nurbs/NURBSAPIConvert.hpp>\n#include <topology/TopoExplorerTool.hpp>\n#include <modeling/MakeVertex.hpp>\nusing namespace AMCAX;\nstd::shared_ptr<Geom3BSplineSurface> GenerateTestSurface11(const int id)\n{\n\tstd::shared_ptr<Geom3BSplineSurface> bspSurf;\n\tswitch (id)\n\t{\n\tcase 0:\n\t{\n\t\tstd::vector<Point3> profilePoles;\n\t\tstd::vector<double> profileKnots(3);\n\t\tstd::vector<int> profileMults(3, 1);\n\t\tprofilePoles.push_back(Point3(0.0, 0.0, 0.0));\n\t\tprofilePoles.push_back(Point3(1.0, -0.2, 0.1));\n\t\tprofilePoles.push_back(Point3(2.0, 0.1, -0.1));\n\t\tprofilePoles.push_back(Point3(3.0, -0.1, 0.0));\n\t\tprofilePoles.push_back(Point3(4.0, 0.1, 0.2));\n\t\tprofileKnots[0] = 0;\n\t\tprofileKnots[1] = 0.5;\n\t\tprofileKnots[2] = 1;\n\t\tprofileMults.front() = 4;\n\t\tprofileMults.back() = 4;\n\t\tstd::shared_ptr<Geom3BSplineCurve> profileCurve = std::make_shared<Geom3BSplineCurve>(profilePoles, profileKnots, profileMults, 3);\n\t\tstd::vector<Point3> spinePoles;\n\t\tstd::vector<double> spineKnots(4);\n\t\tstd::vector<int> spineMults(4, 1);\n\t\tspinePoles.push_back(Point3(0.0, 0.0, 0.0));\n\t\tspinePoles.push_back(Point3(-0.1, 1.0, -0.2));\n\t\tspinePoles.push_back(Point3(0.1, 2.0, -0.1));\n\t\tspinePoles.push_back(Point3(0.2, 3.0, 0.1));\n\t\tspinePoles.push_back(Point3(0.1, 4.0, 0.0));\n\t\tspinePoles.push_back(Point3(0.0, 5.0, -0.1));\n\t\tspineKnots[0] = 0;\n\t\tspineKnots[1] = 1.0 / 3.0;\n\t\tspineKnots[2] = 2.0 / 3.0;\n\t\tspineKnots[3] = 1;\n\t\tspineMults.front() = 4;\n\t\tspineMults.back() = 4;\n\t\tstd::shared_ptr<Geom3BSplineCurve> spineCurve = std::make_shared<Geom3BSplineCurve>(spinePoles, spineKnots, spineMults, 3);\n\t\tTopoWire profile = MakeWire(MakeEdge(profileCurve)).Wire();\n\t\tTopoWire spine = MakeWire(MakeEdge(spineCurve)).Wire();\n\t\tMakePipeShell pipeShell(spine);\n\t\tpipeShell.Add(profile);\n\t\tpipeShell.SetMode(Frame3());\n\t\tTopoShape pipe = pipeShell.Shape();\n\t\tTopoExplorer ex(pipe, ShapeType::Face);\n\t\tTopoFace inputBasicFace = static_cast<const TopoFace&>(ex.Current());\n\t\tauto surf = TopoTool::Surface(inputBasicFace);\n\t\tbspSurf = NURBSAPIConvert::ToBSpline(surf);\n\t\tbreak;\n\t}\n\tcase 1:\n\t{\n\t\tArray2<Point3> poles(2, 5);\n\t\tpoles(0, 0) = Point3(0.0, 0.0, 0.0);\n\t\tpoles(0, 1) = Point3(1.0, -0.2, 0.1);\n\t\tpoles(0, 2) = Point3(2.0, 0.1, -0.1);\n\t\tpoles(0, 3) = Point3(3.0, -0.1, 0.0);\n\t\tpoles(0, 4) = Point3(4.0, 0.1, 0.2);\n\t\tpoles(1, 0) = Point3(0.0, 1.0, -0.1);\n\t\tpoles(1, 1) = Point3(1.0, 0.8, 0.0);\n\t\tpoles(1, 2) = Point3(2.0, 1.1, -0.2);\n\t\tpoles(1, 3) = Point3(3.0, 0.9, -0.1);\n\t\tpoles(1, 4) = Point3(4.0, 1.1, 0.1);\n\t\tstd::vector<double> vKnots(3);\n\t\tstd::vector<int> vMults(3, 1);\n\t\tvKnots[0] = 0;\n\t\tvKnots[1] = 0.5;\n\t\tvKnots[2] = 1;\n\t\tvMults.front() = 4;\n\t\tvMults.back() = 4;\n\t\tstd::vector<double> uKnots(2);\n\t\tstd::vector<int> uMults(2, 1);\n\t\tuKnots[0] = 0;\n\t\tuKnots[1] = 1;\n\t\tuMults.front() = 2;\n\t\tuMults.back() = 2;\n\t\tbspSurf = std::make_shared<Geom3BSplineSurface>(poles, uKnots, vKnots, uMults, vMults, 1, 3);\n\t\tTransformation3 trsf;\n\t\ttrsf.SetTranslationPart(Vector3(0.0, -6.0, 0.0));\n\t\tbspSurf->Transform(trsf);\n\t\tbreak;\n\t}\n\tcase 2:\n\t{\n\t\tstd::vector<Point3> profilePoles;\n\t\tstd::vector<double> profileKnots(4);\n\t\tstd::vector<int> profileMults(4, 1);\n\t\tprofilePoles.push_back(Point3(0.0, 0.0, 0.0));\n\t\tprofilePoles.push_back(Point3(1.0, -2.0, -3.0));\n\t\tprofilePoles.push_back(Point3(2.0, 1.0, 2.0));\n\t\tprofilePoles.push_back(Point3(3.0, -1.0, -1.0));\n\t\tprofilePoles.push_back(Point3(4.0, -3.0, 3.0));\n\t\tprofilePoles.push_back(Point3(5.0, 0.0, 1.0));\n\t\tprofileKnots[0] = 0;\n\t\tprofileKnots[1] = 1.0 / 3.0;\n\t\tprofileKnots[2] = 2.0 / 3.0;\n\t\tprofileKnots[3] = 1;\n\t\tprofileMults.front() = 4;\n\t\tprofileMults.back() = 4;\n\t\tstd::shared_ptr<Geom3BSplineCurve> profileCurve = std::make_shared<Geom3BSplineCurve>(profilePoles, profileKnots, profileMults, 3);\n\t\tstd::vector<Point3> spinePoles;\n\t\tstd::vector<double> spineKnots(4);\n\t\tstd::vector<int> spineMults(4, 1);\n\t\tspinePoles.push_back(Point3(0.0, 0.0, 0.0));\n\t\tspinePoles.push_back(Point3(-0.1, 1.0, -1.0));\n\t\tspinePoles.push_back(Point3(0.1, -2.0, -2.0));\n\t\tspinePoles.push_back(Point3(0.2, -3.0, -3.0));\n\t\tspinePoles.push_back(Point3(0.1, -4.0, -4.0));\n\t\tspinePoles.push_back(Point3(0.0, -2.5, -5.0));\n\t\tspinePoles.push_back(Point3(0.1, -1.0, -6.0));\n\t\tspinePoles.push_back(Point3(0.0, 0.0, -7.0));\n\t\tspineKnots[0] = 0;\n\t\tspineKnots[1] = 1.0 / 3.0;\n\t\tspineKnots[2] = 2.0 / 3.0;\n\t\tspineKnots[3] = 1;\n\t\tspineMults.front() = 6;\n\t\tspineMults.back() = 6;\n\t\tshared_ptr<Geom3BSplineCurve> spineCurve = std::make_shared<Geom3BSplineCurve>(spinePoles, spineKnots, spineMults, 5);\n\t\tTopoWire profile = MakeWire(MakeEdge(profileCurve)).Wire();\n\t\tTopoWire spine = MakeWire(MakeEdge(spineCurve)).Wire();\n\t\tMakePipeShell pipeShell(spine);\n\t\tpipeShell.Add(profile);\n\t\tpipeShell.SetMode(Frame3());\n\t\tTopoShape pipe = pipeShell.Shape();\n\t\tTopoExplorer ex(pipe, ShapeType::Face);\n\t\tTopoFace inputBasicFace = static_cast<const TopoFace&>(ex.Current());\n\t\tshared_ptr<Geom3Surface> surf = TopoTool::Surface(inputBasicFace);\n\t\tshared_ptr<Geom3BSplineSurface>  bspSurf = NURBSAPIConvert::ToBSpline(surf);\n\t\tTransformation3 trsf;\n\t\ttrsf.SetTranslationPart(Vector3(-6.0, 0.0, 0.0));\n\t\tbspSurf->Transform(trsf);\n\t\tbreak;\n\t}\n\t}\n\treturn bspSurf;\n}\n#include<catch.hpp>\n#include<testHelper.h>\n#include <nurbs/NURBSAPIMatch.hpp>\n#include <topology/TopoEdge.hpp>\n#include <topology/TopoTool.hpp>\n#include <nurbs/NURBSAPISweep.hpp>\n#include <nurbs/NURBSAPIRebuild.hpp>\n#include <modeling/MakeWire.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <offset/MakePipeShell.hpp>\n#include <geometry/Geom3BSplineSurface.hpp>\n#include <topology/TopoVertex.hpp>\n#include <topomesh/BRepMeshIncrementalMesh.hpp>\n#include <geometry/GeomAPIProjectPointOnCurve3.hpp>\n#include <modeling/TransformShape.hpp>\n#include <nurbs/NURBSAPIMatch.hpp>\n#include <modeling/MakeFace.hpp>\n#include <nurbs/NURBSAPIConvert.hpp>\n#include <topology/TopoExplorerTool.hpp>\n#include <modeling/MakeVertex.hpp>\nusing namespace AMCAX;\nstd::shared_ptr<Geom3BSplineSurface> GenerateTestSurface11(const int id)\n{\n\tstd::shared_ptr<Geom3BSplineSurface> bspSurf;\n\tswitch (id)\n\t{\n\tcase 0:\n\t{\n\t\tstd::vector<Point3> profilePoles;\n\t\tstd::vector<double> profileKnots(3);\n\t\tstd::vector<int> profileMults(3, 1);\n\t\tprofilePoles.push_back(Point3(0.0, 0.0, 0.0));\n\t\tprofilePoles.push_back(Point3(1.0, -0.2, 0.1));\n\t\tprofilePoles.push_back(Point3(2.0, 0.1, -0.1));\n\t\tprofilePoles.push_back(Point3(3.0, -0.1, 0.0));\n\t\tprofilePoles.push_back(Point3(4.0, 0.1, 0.2));\n\t\tprofileKnots[0] = 0;\n\t\tprofileKnots[1] = 0.5;\n\t\tprofileKnots[2] = 1;\n\t\tprofileMults.front() = 4;\n\t\tprofileMults.back() = 4;\n\t\tstd::shared_ptr<Geom3BSplineCurve> profileCurve = std::make_shared<Geom3BSplineCurve>(profilePoles, profileKnots, profileMults, 3);\n\t\tstd::vector<Point3> spinePoles;\n\t\tstd::vector<double> spineKnots(4);\n\t\tstd::vector<int> spineMults(4, 1);\n\t\tspinePoles.push_back(Point3(0.0, 0.0, 0.0));\n\t\tspinePoles.push_back(Point3(-0.1, 1.0, -0.2));\n\t\tspinePoles.push_back(Point3(0.1, 2.0, -0.1));\n\t\tspinePoles.push_back(Point3(0.2, 3.0, 0.1));\n\t\tspinePoles.push_back(Point3(0.1, 4.0, 0.0));\n\t\tspinePoles.push_back(Point3(0.0, 5.0, -0.1));\n\t\tspineKnots[0] = 0;\n\t\tspineKnots[1] = 1.0 / 3.0;\n\t\tspineKnots[2] = 2.0 / 3.0;\n\t\tspineKnots[3] = 1;\n\t\tspineMults.front() = 4;\n\t\tspineMults.back() = 4;\n\t\tstd::shared_ptr<Geom3BSplineCurve> spineCurve = std::make_shared<Geom3BSplineCurve>(spinePoles, spineKnots, spineMults, 3);\n\t\tTopoWire profile = MakeWire(MakeEdge(profileCurve)).Wire();\n\t\tTopoWire spine = MakeWire(MakeEdge(spineCurve)).Wire();\n\t\tMakePipeShell pipeShell(spine);\n\t\tpipeShell.Add(profile);\n\t\tpipeShell.SetMode(Frame3());\n\t\tTopoShape pipe = pipeShell.Shape();\n\t\tTopoExplorer ex(pipe, ShapeType::Face);\n\t\tTopoFace inputBasicFace = static_cast<const TopoFace&>(ex.Current());\n\t\tauto surf = TopoTool::Surface(inputBasicFace);\n\t\tbspSurf = NURBSAPIConvert::ToBSpline(surf);\n\t\tbreak;\n\t}\n\tcase 1:\n\t{\n\t\tArray2<Point3> poles(2, 5);\n\t\tpoles(0, 0) = Point3(0.0, 0.0, 0.0);\n\t\tpoles(0, 1) = Point3(1.0, -0.2, 0.1);\n\t\tpoles(0, 2) = Point3(2.0, 0.1, -0.1);\n\t\tpoles(0, 3) = Point3(3.0, -0.1, 0.0);\n\t\tpoles(0, 4) = Point3(4.0, 0.1, 0.2);\n\t\tpoles(1, 0) = Point3(0.0, 1.0, -0.1);\n\t\tpoles(1, 1) = Point3(1.0, 0.8, 0.0);\n\t\tpoles(1, 2) = Point3(2.0, 1.1, -0.2);\n\t\tpoles(1, 3) = Point3(3.0, 0.9, -0.1);\n\t\tpoles(1, 4) = Point3(4.0, 1.1, 0.1);\n\t\tstd::vector<double> vKnots(3);\n\t\tstd::vector<int> vMults(3, 1);\n\t\tvKnots[0] = 0;\n\t\tvKnots[1] = 0.5;\n\t\tvKnots[2] = 1;\n\t\tvMults.front() = 4;\n\t\tvMults.back() = 4;\n\t\tstd::vector<double> uKnots(2);\n\t\tstd::vector<int> uMults(2, 1);\n\t\tuKnots[0] = 0;\n\t\tuKnots[1] = 1;\n\t\tuMults.front() = 2;\n\t\tuMults.back() = 2;\n\t\tbspSurf = std::make_shared<Geom3BSplineSurface>(poles, uKnots, vKnots, uMults, vMults, 1, 3);\n\t\tTransformation3 trsf;\n\t\ttrsf.SetTranslationPart(Vector3(0.0, -6.0, 0.0));\n\t\tbspSurf->Transform(trsf);\n\t\tbreak;\n\t}\n\tcase 2:\n\t{\n\t\tstd::vector<Point3> profilePoles;\n\t\tstd::vector<double> profileKnots(4);\n\t\tstd::vector<int> profileMults(4, 1);\n\t\tprofilePoles.push_back(Point3(0.0, 0.0, 0.0));\n\t\tprofilePoles.push_back(Point3(1.0, -2.0, -3.0));\n\t\tprofilePoles.push_back(Point3(2.0, 1.0, 2.0));\n\t\tprofilePoles.push_back(Point3(3.0, -1.0, -1.0));\n\t\tprofilePoles.push_back(Point3(4.0, -3.0, 3.0));\n\t\tprofilePoles.push_back(Point3(5.0, 0.0, 1.0));\n\t\tprofileKnots[0] = 0;\n\t\tprofileKnots[1] = 1.0 / 3.0;\n\t\tprofileKnots[2] = 2.0 / 3.0;\n\t\tprofileKnots[3] = 1;\n\t\tprofileMults.front() = 4;\n\t\tprofileMults.back() = 4;\n\t\tstd::shared_ptr<Geom3BSplineCurve> profileCurve = std::make_shared<Geom3BSplineCurve>(profilePoles, profileKnots, profileMults, 3);\n\t\tstd::vector<Point3> spinePoles;\n\t\tstd::vector<double> spineKnots(4);\n\t\tstd::vector<int> spineMults(4, 1);\n\t\tspinePoles.push_back(Point3(0.0, 0.0, 0.0));\n\t\tspinePoles.push_back(Point3(-0.1, 1.0, -1.0));\n\t\tspinePoles.push_back(Point3(0.1, -2.0, -2.0));\n\t\tspinePoles.push_back(Point3(0.2, -3.0, -3.0));\n\t\tspinePoles.push_back(Point3(0.1, -4.0, -4.0));\n\t\tspinePoles.push_back(Point3(0.0, -2.5, -5.0));\n\t\tspinePoles.push_back(Point3(0.1, -1.0, -6.0));\n\t\tspinePoles.push_back(Point3(0.0, 0.0, -7.0));\n\t\tspineKnots[0] = 0;\n\t\tspineKnots[1] = 1.0 / 3.0;\n\t\tspineKnots[2] = 2.0 / 3.0;\n\t\tspineKnots[3] = 1;\n\t\tspineMults.front() = 6;\n\t\tspineMults.back() = 6;\n\t\tshared_ptr<Geom3BSplineCurve> spineCurve = std::make_shared<Geom3BSplineCurve>(spinePoles, spineKnots, spineMults, 5);\n\t\tTopoWire profile = MakeWire(MakeEdge(profileCurve)).Wire();\n\t\tTopoWire spine = MakeWire(MakeEdge(spineCurve)).Wire();\n\t\tMakePipeShell pipeShell(spine);\n\t\tpipeShell.Add(profile);\n\t\tpipeShell.SetMode(Frame3());\n\t\tTopoShape pipe = pipeShell.Shape();\n\t\tTopoExplorer ex(pipe, ShapeType::Face);\n\t\tTopoFace inputBasicFace = static_cast<const TopoFace&>(ex.Current());\n\t\tshared_ptr<Geom3Surface> surf = TopoTool::Surface(inputBasicFace);\n\t\tshared_ptr<Geom3BSplineSurface>  bspSurf = NURBSAPIConvert::ToBSpline(surf);\n\t\tTransformation3 trsf;\n\t\ttrsf.SetTranslationPart(Vector3(-6.0, 0.0, 0.0));\n\t\tbspSurf->Transform(trsf);\n\t\tbreak;\n\t}\n\t}\n\treturn bspSurf;\n;\n\tSECTION(\"MatchSurf1\")\n\t{\n\t\tOUTPUT_DIRECTORY(nurbs, Match/bug777/MatchSurf/MatchSurf1);\n\t\tstring filedir = INPUT_PATH_PREFIX\"./TestNURBS/TestMatchSurf/\";\n\t\tshared_ptr<Geom3BSplineSurface> surface1 = ReadBRepSurface(filedir + \"surface1.brep\");\n\t\tshared_ptr<Geom3BSplineSurface> surface2 = ReadBRepSurface(filedir + \"surface2.brep\");\n\t\tbool isU1 = false, isFront1 = false, isU2 = false, isFront2 = true;\n\t\tContinuityType cont = ContinuityType::G2; \n\t\tint otherEndCont = 0;\t\t\t\t\t  \n\t\tbool isAutoReverse = true;\n\t\tbool isPrecise = true;\n\t\tvector<double> tol;\n\t\ttol.push_back(0.001);\n\t\ttol.push_back(M_PI / 180.0);\n\t\ttol.push_back(0.0005);\n\t\tbool isEachOther = false;\n\t\tNURBSMatchSurfConfig config;\n\t\tconfig.isOrientationFixed = !isAutoReverse;\n\t\tvector<double> params;\n\t\tauto oldbspSurf3 = NURBSAPIMatch::MatchSurf(surface2, isU2, isFront2, surface1, isU1, isFront1, cont, otherEndCont, isPrecise, tol, params, isEachOther, config, config);\n\t\tfor (const auto& s : oldbspSurf3)\n\t\t{\n\t\t\tOCCTIO::OCCTTool::Write(MakeFace(s, 0.0), outdir + \"result.brep\");\n\t\t}\n\t\tint refDeg = 11;\n\t\tshared_ptr<Geom3BSplineSurface> surface1Inc = std::dynamic_pointer_cast<Geom3BSplineSurface>(surface1->Copy());\n\t\tsurface1Inc->IncreaseDegree(refDeg, refDeg);\n\t\tshared_ptr<Geom3BSplineSurface> surface2Inc = std::dynamic_pointer_cast<Geom3BSplineSurface>(surface2->Copy());\n\t\tsurface2Inc->IncreaseDegree(refDeg, refDeg);\n\t\tauto bspSurf3 = NURBSAPIMatch::MatchSurf(surface2Inc, isU2, isFront2, surface1Inc, isU1, isFront1, cont, otherEndCont, isPrecise, tol, params, isEachOther, config, config);\n\t\tCHECK(surface1Inc->UDegree() == refDeg);\n\t\tCHECK(surface1Inc->VDegree() == refDeg);\n\t\tCHECK(surface2Inc->UDegree() == refDeg);\n\t\tCHECK(surface2Inc->VDegree() == refDeg);\n\t\tCHECK(bspSurf3[0]->UDegree() == refDeg);\n\t\tCHECK(bspSurf3[0]->VDegree() == refDeg);\n\t\tdouble f1 = surface1->LastVParameter();\n\t\tdouble f2 = surface2->LastVParameter();\n\t\tdouble f3 = bspSurf3[0]->FirstVParameter();\n\t\tdouble f4 = bspSurf3[0]->LastVParameter();\n\t\tshared_ptr<Geom3Curve> fu11 = surface1->VIso(f1);\n\t\tshared_ptr<Geom3Curve> fu22 = surface2->VIso(f2);\n\t\tshared_ptr<Geom3Curve> fu33 = bspSurf3[0]->VIso(f3);\n\t\tshared_ptr<Geom3Curve> fu44 = bspSurf3[0]->VIso(f4);\n\t\tdouble resTol = 1e-3;\n\t\tdouble res1 = NurbsSampleCurve(num, resTol, fu33, fu11);\n\t\tdouble res2 = NurbsSampleCurve(num, resTol, fu44, fu22);\n\t\tCHECK(res1 <= ratio);\n\t\tCHECK(res2 <= ratio);\n\t\tOCCTIO::OCCTTool::Write(MakeEdge(fu11), outdir + \"fu11.brep\");\n\t\tOCCTIO::OCCTTool::Write(MakeEdge(fu22), outdir + \"fu22.brep\");\n\t\tOCCTIO::OCCTTool::Write(MakeEdge(fu33), outdir + \"fu33.brep\");\n\t\tOCCTIO::OCCTTool::Write(MakeEdge(fu44), outdir + \"fu44.brep\");\n\t\tOCCTIO::OCCTTool::Write(MakeFace(surface1, 0.0), outdir + \"surface1.brep\");\n\t\tOCCTIO::OCCTTool::Write(MakeFace(surface2, 0.0), outdir + \"surface2.brep\");\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static std::vector<TopoFace> MatchFace( const TopoFace& face1, const TopoEdge& edge1, const TopoFace& face2, const TopoEdge& edge2, ContinuityType connectCont, int otherEndCont, bool isPrecise, const std::vector<double>& tol, std::vector<double>& params, bool isEachOther, const NURBSMatchSurfConfig& surf1Config, const NURBSMatchSurfConfig& surf2Config),\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <nurbs/NURBSAPIMatch.hpp>\n#include <topology/TopoEdge.hpp>\n#include <topology/TopoTool.hpp>\n#include <nurbs/NURBSAPISweep.hpp>\n#include <nurbs/NURBSAPIRebuild.hpp>\n#include <modeling/MakeWire.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <offset/MakePipeShell.hpp>\n#include <geometry/Geom3BSplineSurface.hpp>\n#include <topology/TopoVertex.hpp>\n#include <topomesh/BRepMeshIncrementalMesh.hpp>\n#include <geometry/GeomAPIProjectPointOnCurve3.hpp>\n#include <modeling/TransformShape.hpp>\n#include <nurbs/NURBSAPIMatch.hpp>\n#include <modeling/MakeFace.hpp>\n#include <nurbs/NURBSAPIConvert.hpp>\n#include <topology/TopoExplorerTool.hpp>\n#include <modeling/MakeVertex.hpp>\nusing namespace AMCAX;\nstd::shared_ptr<Geom3BSplineSurface> GenerateTestSurface1(const int id)\n{\n\tstd::shared_ptr<Geom3BSplineSurface> bspSurf;\n\tswitch (id)\n\t{\n\tcase 0:\n\t{\n\t\tstd::vector<Point3> profilePoles;\n\t\tstd::vector<double> profileKnots(3);\n\t\tstd::vector<int> profileMults(3, 1);\n\t\tprofilePoles.push_back(Point3(0.0, 0.0, 0.0));\n\t\tprofilePoles.push_back(Point3(1.0, -0.2, 0.1));\n\t\tprofilePoles.push_back(Point3(2.0, 0.1, -0.1));\n\t\tprofilePoles.push_back(Point3(3.0, -0.1, 0.0));\n\t\tprofilePoles.push_back(Point3(4.0, 0.1, 0.2));\n\t\tprofileKnots[0] = 0;\n\t\tprofileKnots[1] = 0.5;\n\t\tprofileKnots[2] = 1;\n\t\tprofileMults.front() = 4;\n\t\tprofileMults.back() = 4;\n\t\tstd::shared_ptr<Geom3BSplineCurve> profileCurve = std::make_shared<Geom3BSplineCurve>(profilePoles, profileKnots, profileMults, 3);\n\t\tstd::vector<Point3> spinePoles;\n\t\tstd::vector<double> spineKnots(4);\n\t\tstd::vector<int> spineMults(4, 1);\n\t\tspinePoles.push_back(Point3(0.0, 0.0, 0.0));\n\t\tspinePoles.push_back(Point3(-0.1, 1.0, -0.2));\n\t\tspinePoles.push_back(Point3(0.1, 2.0, -0.1));\n\t\tspinePoles.push_back(Point3(0.2, 3.0, 0.1));\n\t\tspinePoles.push_back(Point3(0.1, 4.0, 0.0));\n\t\tspinePoles.push_back(Point3(0.0, 5.0, -0.1));\n\t\tspineKnots[0] = 0;\n\t\tspineKnots[1] = 1.0 / 3.0;\n\t\tspineKnots[2] = 2.0 / 3.0;\n\t\tspineKnots[3] = 1;\n\t\tspineMults.front() = 4;\n\t\tspineMults.back() = 4;\n\t\tstd::shared_ptr<Geom3BSplineCurve> spineCurve = std::make_shared<Geom3BSplineCurve>(spinePoles, spineKnots, spineMults, 3);\n\t\tTopoWire profile = MakeWire(MakeEdge(profileCurve)).Wire();\n\t\tTopoWire spine = MakeWire(MakeEdge(spineCurve)).Wire();\n\t\tMakePipeShell pipeShell(spine);\n\t\tpipeShell.Add(profile);\n\t\tpipeShell.SetMode(Frame3());\n\t\tTopoShape pipe = pipeShell.Shape();\n\t\tTopoExplorer ex(pipe, ShapeType::Face);\n\t\tTopoFace inputBasicFace = static_cast<const TopoFace&>(ex.Current());\n\t\tauto surf = TopoTool::Surface(inputBasicFace);\n\t\tbspSurf = NURBSAPIConvert::ToBSpline(surf);\n\t\tbreak;\n\t}\n\tcase 1:\n\t{\n\t\tArray2<Point3> poles(2, 5);\n\t\tpoles(0, 0) = Point3(0.0, 0.0, 0.0);\n\t\tpoles(0, 1) = Point3(1.0, -0.2, 0.1);\n\t\tpoles(0, 2) = Point3(2.0, 0.1, -0.1);\n\t\tpoles(0, 3) = Point3(3.0, -0.1, 0.0);\n\t\tpoles(0, 4) = Point3(4.0, 0.1, 0.2);\n\t\tpoles(1, 0) = Point3(0.0, 1.0, -0.1);\n\t\tpoles(1, 1) = Point3(1.0, 0.8, 0.0);\n\t\tpoles(1, 2) = Point3(2.0, 1.1, -0.2);\n\t\tpoles(1, 3) = Point3(3.0, 0.9, -0.1);\n\t\tpoles(1, 4) = Point3(4.0, 1.1, 0.1);\n\t\tstd::vector<double> vKnots(3);\n\t\tstd::vector<int> vMults(3, 1);\n\t\tvKnots[0] = 0;\n\t\tvKnots[1] = 0.5;\n\t\tvKnots[2] = 1;\n\t\tvMults.front() = 4;\n\t\tvMults.back() = 4;\n\t\tstd::vector<double> uKnots(2);\n\t\tstd::vector<int> uMults(2, 1);\n\t\tuKnots[0] = 0;\n\t\tuKnots[1] = 1;\n\t\tuMults.front() = 2;\n\t\tuMults.back() = 2;\n\t\tbspSurf = std::make_shared<Geom3BSplineSurface>(poles, uKnots, vKnots, uMults, vMults, 1, 3);\n\t\tTransformation3 trsf;\n\t\ttrsf.SetTranslationPart(Vector3(0.0, -6.0, 0.0));\n\t\tbspSurf->Transform(trsf);\n\t\tbreak;\n\t}\n\tcase 2:\n\t{\n\t\tstd::vector<Point3> profilePoles;\n\t\tstd::vector<double> profileKnots(4);\n\t\tstd::vector<int> profileMults(4, 1);\n\t\tprofilePoles.push_back(Point3(0.0, 0.0, 0.0));\n\t\tprofilePoles.push_back(Point3(1.0, -2.0, -3.0));\n\t\tprofilePoles.push_back(Point3(2.0, 1.0, 2.0));\n\t\tprofilePoles.push_back(Point3(3.0, -1.0, -1.0));\n\t\tprofilePoles.push_back(Point3(4.0, -3.0, 3.0));\n\t\tprofilePoles.push_back(Point3(5.0, 0.0, 1.0));\n\t\tprofileKnots[0] = 0;\n\t\tprofileKnots[1] = 1.0 / 3.0;\n\t\tprofileKnots[2] = 2.0 / 3.0;\n\t\tprofileKnots[3] = 1;\n\t\tprofileMults.front() = 4;\n\t\tprofileMults.back() = 4;\n\t\tstd::shared_ptr<Geom3BSplineCurve> profileCurve = std::make_shared<Geom3BSplineCurve>(profilePoles, profileKnots, profileMults, 3);\n\t\tstd::vector<Point3> spinePoles;\n\t\tstd::vector<double> spineKnots(4);\n\t\tstd::vector<int> spineMults(4, 1);\n\t\tspinePoles.push_back(Point3(0.0, 0.0, 0.0));\n\t\tspinePoles.push_back(Point3(-0.1, 1.0, -1.0));\n\t\tspinePoles.push_back(Point3(0.1, -2.0, -2.0));\n\t\tspinePoles.push_back(Point3(0.2, -3.0, -3.0));\n\t\tspinePoles.push_back(Point3(0.1, -4.0, -4.0));\n\t\tspinePoles.push_back(Point3(0.0, -2.5, -5.0));\n\t\tspinePoles.push_back(Point3(0.1, -1.0, -6.0));\n\t\tspinePoles.push_back(Point3(0.0, 0.0, -7.0));\n\t\tspineKnots[0] = 0;\n\t\tspineKnots[1] = 1.0 / 3.0;\n\t\tspineKnots[2] = 2.0 / 3.0;\n\t\tspineKnots[3] = 1;\n\t\tspineMults.front() = 6;\n\t\tspineMults.back() = 6;\n\t\tshared_ptr<Geom3BSplineCurve> spineCurve = std::make_shared<Geom3BSplineCurve>(spinePoles, spineKnots, spineMults, 5);\n\t\tTopoWire profile = MakeWire(MakeEdge(profileCurve)).Wire();\n\t\tTopoWire spine = MakeWire(MakeEdge(spineCurve)).Wire();\n\t\tMakePipeShell pipeShell(spine);\n\t\tpipeShell.Add(profile);\n\t\tpipeShell.SetMode(Frame3());\n\t\tTopoShape pipe = pipeShell.Shape();\n\t\tTopoExplorer ex(pipe, ShapeType::Face);\n\t\tTopoFace inputBasicFace = static_cast<const TopoFace&>(ex.Current());\n\t\tshared_ptr<Geom3Surface> surf = TopoTool::Surface(inputBasicFace);\n\t\tshared_ptr<Geom3BSplineSurface>  bspSurf = NURBSAPIConvert::ToBSpline(surf);\n\t\tTransformation3 trsf;\n\t\ttrsf.SetTranslationPart(Vector3(-6.0, 0.0, 0.0));\n\t\tbspSurf->Transform(trsf);\n\t\tbreak;\n\t}\n\t}\n\treturn bspSurf;\n}\nTEST_CASE(\"bug2: TestMatchTrimmedSurface \", \"[nurbs][Match][fixbug]\")\n{\n\tOUTPUT_DIRECTORY(nurbs, Match/bug590);\n\tstring filedir = INPUT_PATH_PREFIX\"./TestNURBS/TestMatchTrimmedSurface/\";\n\tTopoFace f1 = ReadBRepFace(filedir + \"surf1.brep\");\n\tTopoFace f2 = ReadBRepFace(filedir + \"surf2.brep\");\n\tPoint3 p1, p2;\n\tbool isSurf1TrimmedEdge = true;\n\tbool isSurf2TrimmedEdge = true;\n\tif (isSurf1TrimmedEdge)\n\t{\n\t\tp1 = ReadBRepPoint(filedir + \"tptS1.brep\");\n\t}\n\telse\n\t{\n\t\tp1 = ReadBRepPoint(filedir + \"nptS1.brep\");\n\t}\n\tif (isSurf2TrimmedEdge)\n\t{\n\t\tp2 = ReadBRepPoint(filedir + \"tptS2.brep\");\n\t}\n\telse\n\t{\n\t\tp2 = ReadBRepPoint(filedir + \"nptS2.brep\");\n\t}\n\tauto [d1, e1] = NearestEdge(p1, f1);\n\tauto [d2, e2] = NearestEdge(p2, f2);\n\tContinuityType cont = ContinuityType::G2;\n\tint otherEndCont = 0;\n\tNURBSMatchSurfConfig config;\n\tbool isPrecise = true;\n\tstd::vector<double> tol;\n\ttol.push_back(0.001);\n\ttol.push_back(0.1);\n\ttol.push_back(0.05);\n\tstd::vector<double> params(2, 1.0);\n\tauto result = NURBSAPIMatch::MatchFace(f1, e1, f2, e2, cont, otherEndCont, isPrecise, tol, params, false, config, config);\n\tdouble f = 0.0;\n\tdouble l = 0.0;\n\tshared_ptr< Geom3Curve > curve2 = TopoTool::Curve(e2, f, l);\n\tshared_ptr< Geom3Surface > src = TopoTool::Surface(f1);\n\tshared_ptr< Geom3Surface > surface = TopoTool::Surface(result[0]);\n\tdouble srcfpv = src->FirstVParameter();\n\tdouble fpv = surface->FirstVParameter();\n\tdouble lpv = surface->LastVParameter();\n\tshared_ptr<Geom3Curve> srcfv = src->VIso(srcfpv);\n\tshared_ptr<Geom3Curve> fv = surface->VIso(fpv);\n\tshared_ptr<Geom3Curve> lv = surface->VIso(lpv);\n\tint num = 1000;\n\tdouble resTol = 1e-3;\n\tdouble ratio = 0.1;\n\tdouble res1 = NurbsSampleCurve(num, resTol, srcfv, fv);\n\tdouble res2 = NurbsSampleCurve(num, resTol, curve2, lv);\n\tCHECK(res1 <= ratio);\n\tCHECK(res2 <= ratio);\n\tOCCTIO::OCCTTool::Write(MakeEdge(srcfv), outdir + \"srcfv.brep\");\n\tOCCTIO::OCCTTool::Write(MakeEdge(fv), outdir + \"fv.brep\");\n\tOCCTIO::OCCTTool::Write(MakeEdge(lv), outdir + \"lv.brep\");\n\tOCCTIO::OCCTTool::Write(f1, outdir + \"f1.brep\");\n\tOCCTIO::OCCTTool::Write(f2, outdir + \"f2.brep\");\n\tOCCTIO::OCCTTool::Write(MakeVertex(p1), outdir + \"p1.brep\");\n\tOCCTIO::OCCTTool::Write(MakeVertex(p2), outdir + \"p2.brep\");\n\tOCCTIO::OCCTTool::Write(e1, outdir + \"e1.brep\");\n\tOCCTIO::OCCTTool::Write(e2, outdir + \"e2.brep\");\n\tOCCTIO::OCCTTool::Write(result.front(), outdir + \"result.brep\");\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static std::vector<std::shared_ptr<Geom3BSplineSurface>> MatchSurf( const std::shared_ptr<Geom3BSplineSurface> surf, bool isModifyU, bool isFront, const std::shared_ptr<Geom3BSplineSurface>& targetSurf, bool isTargetU, bool isTargetFront, ContinuityType connectCont, int otherEndCont, bool isPrecise, const std::vector<double>& tol, std::vector<double>& params, bool isEachOther, const NURBSMatchSurfConfig& surfConfig, const NURBSMatchSurfConfig& targetSurfConfig),\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <nurbs/NURBSAPIMatch.hpp>\n#include <topology/TopoEdge.hpp>\n#include <topology/TopoTool.hpp>\n#include <nurbs/NURBSAPISweep.hpp>\n#include <nurbs/NURBSAPIRebuild.hpp>\n#include <modeling/MakeWire.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <offset/MakePipeShell.hpp>\n#include <geometry/Geom3BSplineSurface.hpp>\n#include <topology/TopoVertex.hpp>\n#include <topomesh/BRepMeshIncrementalMesh.hpp>\n#include <geometry/GeomAPIProjectPointOnCurve3.hpp>\n#include <modeling/TransformShape.hpp>\n#include <nurbs/NURBSAPIMatch.hpp>\n#include <modeling/MakeFace.hpp>\n#include <nurbs/NURBSAPIConvert.hpp>\n#include <topology/TopoExplorerTool.hpp>\n#include <modeling/MakeVertex.hpp>\nusing namespace AMCAX;\nstd::shared_ptr<Geom3BSplineSurface> GenerateTestSurface1(const int id)\n{\n\tstd::shared_ptr<Geom3BSplineSurface> bspSurf;\n\tswitch (id)\n\t{\n\tcase 0:\n\t{\n\t\tstd::vector<Point3> profilePoles;\n\t\tstd::vector<double> profileKnots(3);\n\t\tstd::vector<int> profileMults(3, 1);\n\t\tprofilePoles.push_back(Point3(0.0, 0.0, 0.0));\n\t\tprofilePoles.push_back(Point3(1.0, -0.2, 0.1));\n\t\tprofilePoles.push_back(Point3(2.0, 0.1, -0.1));\n\t\tprofilePoles.push_back(Point3(3.0, -0.1, 0.0));\n\t\tprofilePoles.push_back(Point3(4.0, 0.1, 0.2));\n\t\tprofileKnots[0] = 0;\n\t\tprofileKnots[1] = 0.5;\n\t\tprofileKnots[2] = 1;\n\t\tprofileMults.front() = 4;\n\t\tprofileMults.back() = 4;\n\t\tstd::shared_ptr<Geom3BSplineCurve> profileCurve = std::make_shared<Geom3BSplineCurve>(profilePoles, profileKnots, profileMults, 3);\n\t\tstd::vector<Point3> spinePoles;\n\t\tstd::vector<double> spineKnots(4);\n\t\tstd::vector<int> spineMults(4, 1);\n\t\tspinePoles.push_back(Point3(0.0, 0.0, 0.0));\n\t\tspinePoles.push_back(Point3(-0.1, 1.0, -0.2));\n\t\tspinePoles.push_back(Point3(0.1, 2.0, -0.1));\n\t\tspinePoles.push_back(Point3(0.2, 3.0, 0.1));\n\t\tspinePoles.push_back(Point3(0.1, 4.0, 0.0));\n\t\tspinePoles.push_back(Point3(0.0, 5.0, -0.1));\n\t\tspineKnots[0] = 0;\n\t\tspineKnots[1] = 1.0 / 3.0;\n\t\tspineKnots[2] = 2.0 / 3.0;\n\t\tspineKnots[3] = 1;\n\t\tspineMults.front() = 4;\n\t\tspineMults.back() = 4;\n\t\tstd::shared_ptr<Geom3BSplineCurve> spineCurve = std::make_shared<Geom3BSplineCurve>(spinePoles, spineKnots, spineMults, 3);\n\t\tTopoWire profile = MakeWire(MakeEdge(profileCurve)).Wire();\n\t\tTopoWire spine = MakeWire(MakeEdge(spineCurve)).Wire();\n\t\tMakePipeShell pipeShell(spine);\n\t\tpipeShell.Add(profile);\n\t\tpipeShell.SetMode(Frame3());\n\t\tTopoShape pipe = pipeShell.Shape();\n\t\tTopoExplorer ex(pipe, ShapeType::Face);\n\t\tTopoFace inputBasicFace = static_cast<const TopoFace&>(ex.Current());\n\t\tauto surf = TopoTool::Surface(inputBasicFace);\n\t\tbspSurf = NURBSAPIConvert::ToBSpline(surf);\n\t\tbreak;\n\t}\n\tcase 1:\n\t{\n\t\tArray2<Point3> poles(2, 5);\n\t\tpoles(0, 0) = Point3(0.0, 0.0, 0.0);\n\t\tpoles(0, 1) = Point3(1.0, -0.2, 0.1);\n\t\tpoles(0, 2) = Point3(2.0, 0.1, -0.1);\n\t\tpoles(0, 3) = Point3(3.0, -0.1, 0.0);\n\t\tpoles(0, 4) = Point3(4.0, 0.1, 0.2);\n\t\tpoles(1, 0) = Point3(0.0, 1.0, -0.1);\n\t\tpoles(1, 1) = Point3(1.0, 0.8, 0.0);\n\t\tpoles(1, 2) = Point3(2.0, 1.1, -0.2);\n\t\tpoles(1, 3) = Point3(3.0, 0.9, -0.1);\n\t\tpoles(1, 4) = Point3(4.0, 1.1, 0.1);\n\t\tstd::vector<double> vKnots(3);\n\t\tstd::vector<int> vMults(3, 1);\n\t\tvKnots[0] = 0;\n\t\tvKnots[1] = 0.5;\n\t\tvKnots[2] = 1;\n\t\tvMults.front() = 4;\n\t\tvMults.back() = 4;\n\t\tstd::vector<double> uKnots(2);\n\t\tstd::vector<int> uMults(2, 1);\n\t\tuKnots[0] = 0;\n\t\tuKnots[1] = 1;\n\t\tuMults.front() = 2;\n\t\tuMults.back() = 2;\n\t\tbspSurf = std::make_shared<Geom3BSplineSurface>(poles, uKnots, vKnots, uMults, vMults, 1, 3);\n\t\tTransformation3 trsf;\n\t\ttrsf.SetTranslationPart(Vector3(0.0, -6.0, 0.0));\n\t\tbspSurf->Transform(trsf);\n\t\tbreak;\n\t}\n\tcase 2:\n\t{\n\t\tstd::vector<Point3> profilePoles;\n\t\tstd::vector<double> profileKnots(4);\n\t\tstd::vector<int> profileMults(4, 1);\n\t\tprofilePoles.push_back(Point3(0.0, 0.0, 0.0));\n\t\tprofilePoles.push_back(Point3(1.0, -2.0, -3.0));\n\t\tprofilePoles.push_back(Point3(2.0, 1.0, 2.0));\n\t\tprofilePoles.push_back(Point3(3.0, -1.0, -1.0));\n\t\tprofilePoles.push_back(Point3(4.0, -3.0, 3.0));\n\t\tprofilePoles.push_back(Point3(5.0, 0.0, 1.0));\n\t\tprofileKnots[0] = 0;\n\t\tprofileKnots[1] = 1.0 / 3.0;\n\t\tprofileKnots[2] = 2.0 / 3.0;\n\t\tprofileKnots[3] = 1;\n\t\tprofileMults.front() = 4;\n\t\tprofileMults.back() = 4;\n\t\tstd::shared_ptr<Geom3BSplineCurve> profileCurve = std::make_shared<Geom3BSplineCurve>(profilePoles, profileKnots, profileMults, 3);\n\t\tstd::vector<Point3> spinePoles;\n\t\tstd::vector<double> spineKnots(4);\n\t\tstd::vector<int> spineMults(4, 1);\n\t\tspinePoles.push_back(Point3(0.0, 0.0, 0.0));\n\t\tspinePoles.push_back(Point3(-0.1, 1.0, -1.0));\n\t\tspinePoles.push_back(Point3(0.1, -2.0, -2.0));\n\t\tspinePoles.push_back(Point3(0.2, -3.0, -3.0));\n\t\tspinePoles.push_back(Point3(0.1, -4.0, -4.0));\n\t\tspinePoles.push_back(Point3(0.0, -2.5, -5.0));\n\t\tspinePoles.push_back(Point3(0.1, -1.0, -6.0));\n\t\tspinePoles.push_back(Point3(0.0, 0.0, -7.0));\n\t\tspineKnots[0] = 0;\n\t\tspineKnots[1] = 1.0 / 3.0;\n\t\tspineKnots[2] = 2.0 / 3.0;\n\t\tspineKnots[3] = 1;\n\t\tspineMults.front() = 6;\n\t\tspineMults.back() = 6;\n\t\tshared_ptr<Geom3BSplineCurve> spineCurve = std::make_shared<Geom3BSplineCurve>(spinePoles, spineKnots, spineMults, 5);\n\t\tTopoWire profile = MakeWire(MakeEdge(profileCurve)).Wire();\n\t\tTopoWire spine = MakeWire(MakeEdge(spineCurve)).Wire();\n\t\tMakePipeShell pipeShell(spine);\n\t\tpipeShell.Add(profile);\n\t\tpipeShell.SetMode(Frame3());\n\t\tTopoShape pipe = pipeShell.Shape();\n\t\tTopoExplorer ex(pipe, ShapeType::Face);\n\t\tTopoFace inputBasicFace = static_cast<const TopoFace&>(ex.Current());\n\t\tshared_ptr<Geom3Surface> surf = TopoTool::Surface(inputBasicFace);\n\t\tshared_ptr<Geom3BSplineSurface>  bspSurf = NURBSAPIConvert::ToBSpline(surf);\n\t\tTransformation3 trsf;\n\t\ttrsf.SetTranslationPart(Vector3(-6.0, 0.0, 0.0));\n\t\tbspSurf->Transform(trsf);\n\t\tbreak;\n\t}\n\t}\n\treturn bspSurf;\n}\nTEST_CASE(\"bug1: TestMatchSurf2 \", \"[nurbs][Match][fixbug]\")\n{\n\tOUTPUT_DIRECTORY(nurbs, Match/bug589);\n\tContinuityType cont1 = ContinuityType::G2;\n\tbool isU1 = false;\n\tbool isFront1 = true;\n\tint surf1ID = 0;\n\tshared_ptr<Geom3BSplineSurface> bsp1 = GenerateTestSurface1(surf1ID);\n\tint nupoles = 5;\n\tint udeg = 3;\n\tint nuknots = nupoles - udeg + 1;\n\tint nvpoles = isU1 ? bsp1->NVPoles() : bsp1->NUPoles();\n\tint vdeg = isU1 ? bsp1->VDegree() : bsp1->UDegree();\n\tint nvknots = nvpoles - vdeg + 1;\n\tArray2<Point3> poles(nupoles, nvpoles);\n\tfor (int i = 0; i < nupoles; i++)\n\t{\n\t\tfor (int j = 0; j < nvpoles; j++)\n\t\t{\n\t\t\tpoles(i, j).SetCoord((double)i, (double)j, 0.0);\n\t\t}\n\t}\n\tstd::vector<double> uknots(nuknots), vknots(nvknots);\n\tfor (int i = 0; i < nuknots; i++)\n\t{\n\t\tuknots[i] = (double)i / (double)(nuknots - 1);\n\t}\n\tfor (int i = 0; i < nvknots; i++)\n\t{\n\t\tvknots[i] = (double)i / (double)(nvknots - 1);\n\t}\n\tvector<int> umults(nuknots, 1), vmults(nvknots, 1);\n\tumults.front() = udeg + 1;\n\tumults.back() = udeg + 1;\n\tvmults.front() = vdeg + 1;\n\tvmults.back() = vdeg + 1;\n\tshared_ptr<Geom3BSplineSurface> bsp2 = make_shared<Geom3BSplineSurface>(poles, uknots, vknots, umults, vmults, udeg, vdeg);\n\tTransformation3 trsf;\n\ttrsf.SetTranslationPart(Vector3(0.0, 0.0, 5.0));\n\tbsp2->Transform(trsf);\n\tbool isU2 = true;\n\tbool isFront2 = true;\n\tNURBSMatchSurfConfig config;\n\tvector<double> params;\n\tauto bspSurf3 = NURBSAPIMatch::MatchSurf(bsp2, isU2, isFront2, bsp1, isU1, isFront1, cont1, 0, false, vector<double>(), params, false, config, config);\n\tdouble f1 = bsp1->FirstVParameter();\n\tdouble f2 = bsp2->LastUParameter();\n\tdouble f3 = bspSurf3[0]->FirstUParameter();\n\tdouble f4 = bspSurf3[0]->LastUParameter();\n\tshared_ptr<Geom3Curve> fu1 = bsp1->VIso(f1);\n\tshared_ptr<Geom3Curve> fu2 = bsp2->UIso(f2);\n\tshared_ptr<Geom3Curve> fu3 = bspSurf3[0]->UIso(f3);\n\tshared_ptr<Geom3Curve> fu4 = bspSurf3[0]->UIso(f4);\n\tint num = 1000;\n\tdouble resTol = 1e-3;\n\tdouble ratio = 0.1;\n\tdouble res1 = NurbsSampleCurve(num, resTol, fu3, fu1);\n\tdouble res2 = NurbsSampleCurve(num, resTol, fu4, fu2);\n\tCHECK(res1 <= ratio);\n\tCHECK(res2 <= ratio);\n\tOCCTIO::OCCTTool::Write(MakeFace(bsp1, 0.0), outdir + \"bsp1.brep\");\n\tOCCTIO::OCCTTool::Write(MakeFace(bsp2, 0.0), outdir + \"bsp2.brep\");\n\tOCCTIO::OCCTTool::Write(MakeEdge(fu1), outdir + \"fu1.brep\"); \n\tOCCTIO::OCCTTool::Write(MakeEdge(fu2), outdir + \"fu2.brep\");\n\tOCCTIO::OCCTTool::Write(MakeEdge(fu3), outdir + \"fu3.brep\");\n\tOCCTIO::OCCTTool::Write(MakeEdge(fu4), outdir + \"fu4.brep\");\n\tOCCTIO::OCCTTool::Write(MakeFace(bspSurf3.front(), 0.0), outdir + \"Result.brep\");\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static std::pair<std::shared_ptr<Geom3BSplineCurve>, std::shared_ptr<Geom3BSplineCurve>> MatchCurveWithEachOther( ContinuityType cont, const std::shared_ptr<Geom3BSplineCurve>& curve, bool isFront, const std::shared_ptr<Geom3BSplineCurve>& targetCurve, bool isTargetFront, int otherEndCont, std::vector<double>& params),\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <nurbs/NURBSAPIMatch.hpp>\n#include <topology/TopoEdge.hpp>\n#include <topology/TopoTool.hpp>\n#include <nurbs/NURBSAPISweep.hpp>\n#include <nurbs/NURBSAPIRebuild.hpp>\n#include <modeling/MakeWire.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <offset/MakePipeShell.hpp>\n#include <geometry/Geom3BSplineSurface.hpp>\n#include <topology/TopoVertex.hpp>\n#include <topomesh/BRepMeshIncrementalMesh.hpp>\n#include <geometry/GeomAPIProjectPointOnCurve3.hpp>\n#include <modeling/TransformShape.hpp>\n#include <nurbs/NURBSAPIMatch.hpp>\n#include <modeling/MakeFace.hpp>\n#include <nurbs/NURBSAPIConvert.hpp>\n#include <topology/TopoExplorerTool.hpp>\n#include <modeling/MakeVertex.hpp>\nusing namespace AMCAX;\nstd::shared_ptr<Geom3BSplineSurface> GenerateTestSurface1(const int id)\n{\n\tstd::shared_ptr<Geom3BSplineSurface> bspSurf;\n\tswitch (id)\n\t{\n\tcase 0:\n\t{\n\t\tstd::vector<Point3> profilePoles;\n\t\tstd::vector<double> profileKnots(3);\n\t\tstd::vector<int> profileMults(3, 1);\n\t\tprofilePoles.push_back(Point3(0.0, 0.0, 0.0));\n\t\tprofilePoles.push_back(Point3(1.0, -0.2, 0.1));\n\t\tprofilePoles.push_back(Point3(2.0, 0.1, -0.1));\n\t\tprofilePoles.push_back(Point3(3.0, -0.1, 0.0));\n\t\tprofilePoles.push_back(Point3(4.0, 0.1, 0.2));\n\t\tprofileKnots[0] = 0;\n\t\tprofileKnots[1] = 0.5;\n\t\tprofileKnots[2] = 1;\n\t\tprofileMults.front() = 4;\n\t\tprofileMults.back() = 4;\n\t\tstd::shared_ptr<Geom3BSplineCurve> profileCurve = std::make_shared<Geom3BSplineCurve>(profilePoles, profileKnots, profileMults, 3);\n\t\tstd::vector<Point3> spinePoles;\n\t\tstd::vector<double> spineKnots(4);\n\t\tstd::vector<int> spineMults(4, 1);\n\t\tspinePoles.push_back(Point3(0.0, 0.0, 0.0));\n\t\tspinePoles.push_back(Point3(-0.1, 1.0, -0.2));\n\t\tspinePoles.push_back(Point3(0.1, 2.0, -0.1));\n\t\tspinePoles.push_back(Point3(0.2, 3.0, 0.1));\n\t\tspinePoles.push_back(Point3(0.1, 4.0, 0.0));\n\t\tspinePoles.push_back(Point3(0.0, 5.0, -0.1));\n\t\tspineKnots[0] = 0;\n\t\tspineKnots[1] = 1.0 / 3.0;\n\t\tspineKnots[2] = 2.0 / 3.0;\n\t\tspineKnots[3] = 1;\n\t\tspineMults.front() = 4;\n\t\tspineMults.back() = 4;\n\t\tstd::shared_ptr<Geom3BSplineCurve> spineCurve = std::make_shared<Geom3BSplineCurve>(spinePoles, spineKnots, spineMults, 3);\n\t\tTopoWire profile = MakeWire(MakeEdge(profileCurve)).Wire();\n\t\tTopoWire spine = MakeWire(MakeEdge(spineCurve)).Wire();\n\t\tMakePipeShell pipeShell(spine);\n\t\tpipeShell.Add(profile);\n\t\tpipeShell.SetMode(Frame3());\n\t\tTopoShape pipe = pipeShell.Shape();\n\t\tTopoExplorer ex(pipe, ShapeType::Face);\n\t\tTopoFace inputBasicFace = static_cast<const TopoFace&>(ex.Current());\n\t\tauto surf = TopoTool::Surface(inputBasicFace);\n\t\tbspSurf = NURBSAPIConvert::ToBSpline(surf);\n\t\tbreak;\n\t}\n\tcase 1:\n\t{\n\t\tArray2<Point3> poles(2, 5);\n\t\tpoles(0, 0) = Point3(0.0, 0.0, 0.0);\n\t\tpoles(0, 1) = Point3(1.0, -0.2, 0.1);\n\t\tpoles(0, 2) = Point3(2.0, 0.1, -0.1);\n\t\tpoles(0, 3) = Point3(3.0, -0.1, 0.0);\n\t\tpoles(0, 4) = Point3(4.0, 0.1, 0.2);\n\t\tpoles(1, 0) = Point3(0.0, 1.0, -0.1);\n\t\tpoles(1, 1) = Point3(1.0, 0.8, 0.0);\n\t\tpoles(1, 2) = Point3(2.0, 1.1, -0.2);\n\t\tpoles(1, 3) = Point3(3.0, 0.9, -0.1);\n\t\tpoles(1, 4) = Point3(4.0, 1.1, 0.1);\n\t\tstd::vector<double> vKnots(3);\n\t\tstd::vector<int> vMults(3, 1);\n\t\tvKnots[0] = 0;\n\t\tvKnots[1] = 0.5;\n\t\tvKnots[2] = 1;\n\t\tvMults.front() = 4;\n\t\tvMults.back() = 4;\n\t\tstd::vector<double> uKnots(2);\n\t\tstd::vector<int> uMults(2, 1);\n\t\tuKnots[0] = 0;\n\t\tuKnots[1] = 1;\n\t\tuMults.front() = 2;\n\t\tuMults.back() = 2;\n\t\tbspSurf = std::make_shared<Geom3BSplineSurface>(poles, uKnots, vKnots, uMults, vMults, 1, 3);\n\t\tTransformation3 trsf;\n\t\ttrsf.SetTranslationPart(Vector3(0.0, -6.0, 0.0));\n\t\tbspSurf->Transform(trsf);\n\t\tbreak;\n\t}\n\tcase 2:\n\t{\n\t\tstd::vector<Point3> profilePoles;\n\t\tstd::vector<double> profileKnots(4);\n\t\tstd::vector<int> profileMults(4, 1);\n\t\tprofilePoles.push_back(Point3(0.0, 0.0, 0.0));\n\t\tprofilePoles.push_back(Point3(1.0, -2.0, -3.0));\n\t\tprofilePoles.push_back(Point3(2.0, 1.0, 2.0));\n\t\tprofilePoles.push_back(Point3(3.0, -1.0, -1.0));\n\t\tprofilePoles.push_back(Point3(4.0, -3.0, 3.0));\n\t\tprofilePoles.push_back(Point3(5.0, 0.0, 1.0));\n\t\tprofileKnots[0] = 0;\n\t\tprofileKnots[1] = 1.0 / 3.0;\n\t\tprofileKnots[2] = 2.0 / 3.0;\n\t\tprofileKnots[3] = 1;\n\t\tprofileMults.front() = 4;\n\t\tprofileMults.back() = 4;\n\t\tstd::shared_ptr<Geom3BSplineCurve> profileCurve = std::make_shared<Geom3BSplineCurve>(profilePoles, profileKnots, profileMults, 3);\n\t\tstd::vector<Point3> spinePoles;\n\t\tstd::vector<double> spineKnots(4);\n\t\tstd::vector<int> spineMults(4, 1);\n\t\tspinePoles.push_back(Point3(0.0, 0.0, 0.0));\n\t\tspinePoles.push_back(Point3(-0.1, 1.0, -1.0));\n\t\tspinePoles.push_back(Point3(0.1, -2.0, -2.0));\n\t\tspinePoles.push_back(Point3(0.2, -3.0, -3.0));\n\t\tspinePoles.push_back(Point3(0.1, -4.0, -4.0));\n\t\tspinePoles.push_back(Point3(0.0, -2.5, -5.0));\n\t\tspinePoles.push_back(Point3(0.1, -1.0, -6.0));\n\t\tspinePoles.push_back(Point3(0.0, 0.0, -7.0));\n\t\tspineKnots[0] = 0;\n\t\tspineKnots[1] = 1.0 / 3.0;\n\t\tspineKnots[2] = 2.0 / 3.0;\n\t\tspineKnots[3] = 1;\n\t\tspineMults.front() = 6;\n\t\tspineMults.back() = 6;\n\t\tshared_ptr<Geom3BSplineCurve> spineCurve = std::make_shared<Geom3BSplineCurve>(spinePoles, spineKnots, spineMults, 5);\n\t\tTopoWire profile = MakeWire(MakeEdge(profileCurve)).Wire();\n\t\tTopoWire spine = MakeWire(MakeEdge(spineCurve)).Wire();\n\t\tMakePipeShell pipeShell(spine);\n\t\tpipeShell.Add(profile);\n\t\tpipeShell.SetMode(Frame3());\n\t\tTopoShape pipe = pipeShell.Shape();\n\t\tTopoExplorer ex(pipe, ShapeType::Face);\n\t\tTopoFace inputBasicFace = static_cast<const TopoFace&>(ex.Current());\n\t\tshared_ptr<Geom3Surface> surf = TopoTool::Surface(inputBasicFace);\n\t\tshared_ptr<Geom3BSplineSurface>  bspSurf = NURBSAPIConvert::ToBSpline(surf);\n\t\tTransformation3 trsf;\n\t\ttrsf.SetTranslationPart(Vector3(-6.0, 0.0, 0.0));\n\t\tbspSurf->Transform(trsf);\n\t\tbreak;\n\t}\n\t}\n\treturn bspSurf;\n}\nTEST_CASE(\"bug2: TestMatchTrimmedSurface \", \"[nurbs][Match][fixbug]\")\n{\n\tOUTPUT_DIRECTORY(nurbs, Match/bug590);\n\tstring filedir = INPUT_PATH_PREFIX\"./TestNURBS/TestMatchTrimmedSurface/\";\n\tTopoFace f1 = ReadBRepFace(filedir + \"surf1.brep\");\n\tTopoFace f2 = ReadBRepFace(filedir + \"surf2.brep\");\n\tPoint3 p1, p2;\n\tbool isSurf1TrimmedEdge = true;\n\tbool isSurf2TrimmedEdge = true;\n\tif (isSurf1TrimmedEdge)\n\t{\n\t\tp1 = ReadBRepPoint(filedir + \"tptS1.brep\");\n\t}\n\telse\n\t{\n\t\tp1 = ReadBRepPoint(filedir + \"nptS1.brep\");\n\t}\n\tif (isSurf2TrimmedEdge)\n\t{\n\t\tp2 = ReadBRepPoint(filedir + \"tptS2.brep\");\n\t}\n\telse\n\t{\n\t\tp2 = ReadBRepPoint(filedir + \"nptS2.brep\");\n\t}\n\tauto [d1, e1] = NearestEdge(p1, f1);\n\tauto [d2, e2] = NearestEdge(p2, f2);\n\tContinuityType cont = ContinuityType::G2;\n\tint otherEndCont = 0;\n\tNURBSMatchSurfConfig config;\n\tbool isPrecise = true;\n\tstd::vector<double> tol;\n\ttol.push_back(0.001);\n\ttol.push_back(0.1);\n\ttol.push_back(0.05);\n\tstd::vector<double> params(2, 1.0);\n\tauto result = NURBSAPIMatch::MatchFace(f1, e1, f2, e2, cont, otherEndCont, isPrecise, tol, params, false, config, config);\n\tdouble f = 0.0;\n\tdouble l = 0.0;\n\tshared_ptr< Geom3Curve > curve2 = TopoTool::Curve(e2, f, l);\n\tshared_ptr< Geom3Surface > src = TopoTool::Surface(f1);\n\tshared_ptr< Geom3Surface > surface = TopoTool::Surface(result[0]);\n\tdouble srcfpv = src->FirstVParameter();\n\tdouble fpv = surface->FirstVParameter();\n\tdouble lpv = surface->LastVParameter();\n\tshared_ptr<Geom3Curve> srcfv = src->VIso(srcfpv);\n\tshared_ptr<Geom3Curve> fv = surface->VIso(fpv);\n\tshared_ptr<Geom3Curve> lv = surface->VIso(lpv);\n\tint num = 1000;\n\tdouble resTol = 1e-3;\n\tdouble ratio = 0.1;\n\tdouble res1 = NurbsSampleCurve(num, resTol, srcfv, fv);\n\tdouble res2 = NurbsSampleCurve(num, resTol, curve2, lv);\n\tCHECK(res1 <= ratio);\n\tCHECK(res2 <= ratio);\n\tOCCTIO::OCCTTool::Write(MakeEdge(srcfv), outdir + \"srcfv.brep\");\n\tOCCTIO::OCCTTool::Write(MakeEdge(fv), outdir + \"fv.brep\");\n\tOCCTIO::OCCTTool::Write(MakeEdge(lv), outdir + \"lv.brep\");\n\tOCCTIO::OCCTTool::Write(f1, outdir + \"f1.brep\");\n\tOCCTIO::OCCTTool::Write(f2, outdir + \"f2.brep\");\n\tOCCTIO::OCCTTool::Write(MakeVertex(p1), outdir + \"p1.brep\");\n\tOCCTIO::OCCTTool::Write(MakeVertex(p2), outdir + \"p2.brep\");\n\tOCCTIO::OCCTTool::Write(e1, outdir + \"e1.brep\");\n\tOCCTIO::OCCTTool::Write(e2, outdir + \"e2.brep\");\n\tOCCTIO::OCCTTool::Write(result.front(), outdir + \"result.brep\");\n;\n\tSECTION(\"MatchCurveWithEachOther\")\n\t{\n\t\tstring filedir = INPUT_PATH_PREFIX\"./TestNURBS/TestMatchCurve/\";\n\t\tstring filedir1 = INPUT_PATH_PREFIX\"./TestNURBS/TestMatchCurve/Rhino/\";\n\t\tstring filedir2 = INPUT_PATH_PREFIX\"./TestNURBS/TestMatchCurve/Rhino/stepEachOther/\";\n\t\tshared_ptr<Geom3BSplineCurve> bsp1 = ReadBRepCurve(filedir + \"curve1.brep\");\n\t\tshared_ptr<Geom3BSplineCurve> bsp2 = ReadBRepCurve(filedir + \"curve2.brep\");\n\t\t OUTPUT_DIRECTORY(nurbs, Match/MatchCurve/MatchCurveWithEachOther);\n\t\t auto nbsp1 = NURBSAPIMatch::MatchCurveWithEachOther(ContinuityType::C0, bsp1, true, bsp2, true, 0);\n\t\t auto nbsp2 = NURBSAPIMatch::MatchCurveWithEachOther(ContinuityType::C0, bsp1, false, bsp2, true, 0);\n\t\t auto nbsp3 = NURBSAPIMatch::MatchCurveWithEachOther(ContinuityType::C0, bsp1, true, bsp2, false, 0);\n\t\t auto nbsp4 = NURBSAPIMatch::MatchCurveWithEachOther(ContinuityType::C0, bsp1, false, bsp2, false, 0);\n\t\t auto nbsp5 = NURBSAPIMatch::MatchCurveWithEachOther(ContinuityType::G1, bsp1, true, bsp2, true, 0);\n\t\t auto nbsp6 = NURBSAPIMatch::MatchCurveWithEachOther(ContinuityType::G1, bsp1, false, bsp2, true, 0);\n\t\t auto nbsp7 = NURBSAPIMatch::MatchCurveWithEachOther(ContinuityType::G1, bsp1, true, bsp2, false, 0);\n\t\t auto nbsp8 = NURBSAPIMatch::MatchCurveWithEachOther(ContinuityType::G1, bsp1, false, bsp2, false, 0);\n\t\t auto nbsp9 = NURBSAPIMatch::MatchCurveWithEachOther(ContinuityType::G2, bsp1, true, bsp2, true, 0);\n\t\t auto nbsp10 = NURBSAPIMatch::MatchCurveWithEachOther(ContinuityType::G2, bsp1, false, bsp2, true, 0);\n\t\t auto nbsp11 = NURBSAPIMatch::MatchCurveWithEachOther(ContinuityType::G2, bsp1, true, bsp2, false, 0);\n\t\t auto nbsp12 = NURBSAPIMatch::MatchCurveWithEachOther(ContinuityType::G2, bsp1, false, bsp2, false, 0);\n\t\t shared_ptr<Geom3BSplineCurve> bsp1C0res1 = ReadBRepCurve(filedir2 + \"bsp1C0truetrue.brep\");\n\t\t shared_ptr<Geom3BSplineCurve> bsp1C0res2 = ReadBRepCurve(filedir2 + \"bsp1C0falsetrue.brep\");\n\t\t shared_ptr<Geom3BSplineCurve> bsp1C0res3 = ReadBRepCurve(filedir2 + \"bsp1C0truefalse.brep\");\n\t\t shared_ptr<Geom3BSplineCurve> bsp1C0res4 = ReadBRepCurve(filedir2 + \"bsp1C0falsefalse.brep\");\n\t\t shared_ptr<Geom3BSplineCurve> bsp1G1res1 = ReadBRepCurve(filedir2 + \"bsp1G1truetrue.brep\");\n\t\t shared_ptr<Geom3BSplineCurve> bsp1G1res2 = ReadBRepCurve(filedir2 + \"bsp1G1falsetrue.brep\");\n\t\t shared_ptr<Geom3BSplineCurve> bsp1G1res3 = ReadBRepCurve(filedir2 + \"bsp1G1truefalse.brep\");\n\t\t shared_ptr<Geom3BSplineCurve> bsp1G1res4 = ReadBRepCurve(filedir2 + \"bsp1G1falsefalse.brep\");\n\t\t shared_ptr<Geom3BSplineCurve> bsp1G2res1 = ReadBRepCurve(filedir2 + \"bsp1G2truetrue.brep\");\n\t\t shared_ptr<Geom3BSplineCurve> bsp1G2res2 = ReadBRepCurve(filedir2 + \"bsp1G2falsetrue.brep\");\n\t\t shared_ptr<Geom3BSplineCurve> bsp1G2res3 = ReadBRepCurve(filedir2 + \"bsp1G2truefalse.brep\");\n\t\t shared_ptr<Geom3BSplineCurve> bsp1G2res4 = ReadBRepCurve(filedir2 + \"bsp1G2falsefalse.brep\");\n\t\t shared_ptr<Geom3BSplineCurve> bsp2C0res1 = ReadBRepCurve(filedir2 + \"bsp2C0truetrue.brep\");\n\t\t shared_ptr<Geom3BSplineCurve> bsp2C0res2 = ReadBRepCurve(filedir2 + \"bsp2C0falsetrue.brep\");\n\t\t shared_ptr<Geom3BSplineCurve> bsp2C0res3 = ReadBRepCurve(filedir2 + \"bsp2C0truefalse.brep\");\n\t\t shared_ptr<Geom3BSplineCurve> bsp2C0res4 = ReadBRepCurve(filedir2 + \"bsp2C0falsefalse.brep\");\n\t\t shared_ptr<Geom3BSplineCurve> bsp2G1res1 = ReadBRepCurve(filedir2 + \"bsp2G1truetrue.brep\");\n\t\t shared_ptr<Geom3BSplineCurve> bsp2G1res2 = ReadBRepCurve(filedir2 + \"bsp2G1falsetrue.brep\");\n\t\t shared_ptr<Geom3BSplineCurve> bsp2G1res3 = ReadBRepCurve(filedir2 + \"bsp2G1truefalse.brep\");\n\t\t shared_ptr<Geom3BSplineCurve> bsp2G1res4 = ReadBRepCurve(filedir2 + \"bsp2G1falsefalse.brep\");\n\t\t shared_ptr<Geom3BSplineCurve> bsp2G2res1 = ReadBRepCurve(filedir2 + \"bsp2G2truetrue.brep\");\n\t\t shared_ptr<Geom3BSplineCurve> bsp2G2res2 = ReadBRepCurve(filedir2 + \"bsp2G2falsetrue.brep\");\n\t\t shared_ptr<Geom3BSplineCurve> bsp2G2res3 = ReadBRepCurve(filedir2 + \"bsp2G2truefalse.brep\");\n\t\t shared_ptr<Geom3BSplineCurve> bsp2G2res4 = ReadBRepCurve(filedir2 + \"bsp2G2falsefalse.brep\");\n\t\t CHECK(nbsp1.first->NKnots() == bsp1C0res1->NKnots());\n\t\t CHECK(nbsp1.second->NKnots() == bsp2C0res1->NKnots());\n\t\t CHECK((nbsp1.first->StartPoint()).X() == Approx((nbsp1.second->StartPoint()).X()));\n\t\t CHECK((nbsp1.first->StartPoint()).Y() == Approx((nbsp1.second->StartPoint()).Y()));\n\t\t CHECK((nbsp1.first->StartPoint()).Z() == Approx((nbsp1.second->StartPoint()).Z()));\n\t\t CHECK((nbsp1.first->EndPoint()).X() == Approx((bsp1->EndPoint()).X()));\n\t\t CHECK((nbsp1.first->EndPoint()).Y() == Approx((bsp1->EndPoint()).Y()));\n\t\t CHECK((nbsp1.first->EndPoint()).Z() == Approx((bsp1->EndPoint()).Z()));\n\t\t CHECK((nbsp1.second->EndPoint()).X() == Approx((bsp2->EndPoint()).X()));\n\t\t CHECK((nbsp1.second->EndPoint()).Y() == Approx((bsp2->EndPoint()).Y()));\n\t\t CHECK((nbsp1.second->EndPoint()).Z() == Approx((bsp2->EndPoint()).Z()));\n\t\t CHECK(nbsp2.first->NKnots() == bsp1C0res2->NKnots());\n\t\t CHECK(nbsp2.second->NKnots() == bsp2C0res2->NKnots());\n\t\t CHECK((nbsp2.first->EndPoint()).X() == Approx((nbsp2.second->StartPoint()).X()));\n\t\t CHECK((nbsp2.first->EndPoint()).Y() == Approx((nbsp2.second->StartPoint()).Y()));\n\t\t CHECK((nbsp2.first->EndPoint()).Z() == Approx((nbsp2.second->StartPoint()).Z()));\n\t\t CHECK((nbsp2.first->StartPoint()).X() == Approx((bsp1->StartPoint()).X()));\n\t\t CHECK((nbsp2.first->StartPoint()).Y() == Approx((bsp1->StartPoint()).Y()));\n\t\t CHECK((nbsp2.first->StartPoint()).Z() == Approx((bsp1->StartPoint()).Z()));\n\t\t CHECK((nbsp2.second->EndPoint()).X() == Approx((bsp2->EndPoint()).X()));\n\t\t CHECK((nbsp2.second->EndPoint()).Y() == Approx((bsp2->EndPoint()).Y()));\n\t\t CHECK((nbsp2.second->EndPoint()).Z() == Approx((bsp2->EndPoint()).Z()));\n\t\t CHECK(nbsp3.first->NKnots() == bsp1C0res3->NKnots());\n\t\t CHECK(nbsp3.second->NKnots() == bsp2C0res3->NKnots());\n\t\t CHECK((nbsp3.first->StartPoint()).X() == Approx((nbsp3.second->EndPoint()).X()));\n\t\t CHECK((nbsp3.first->StartPoint()).Y() == Approx((nbsp3.second->EndPoint()).Y()));\n\t\t CHECK((nbsp3.first->StartPoint()).Z() == Approx((nbsp3.second->EndPoint()).Z()));\n\t\t CHECK((nbsp3.first->EndPoint()).X() == Approx((bsp1->EndPoint()).X()));\n\t\t CHECK((nbsp3.first->EndPoint()).Y() == Approx((bsp1->EndPoint()).Y()));\n\t\t CHECK((nbsp3.first->EndPoint()).Z() == Approx((bsp1->EndPoint()).Z()));\n\t\t CHECK((nbsp3.second->StartPoint()).X() == Approx((bsp2->StartPoint()).X()));\n\t\t CHECK((nbsp3.second->StartPoint()).Y() == Approx((bsp2->StartPoint()).Y()));\n\t\t CHECK((nbsp3.second->StartPoint()).Z() == Approx((bsp2->StartPoint()).Z()));\n\t\t CHECK(nbsp4.first->NKnots() == bsp1C0res4->NKnots());\n\t\t CHECK(nbsp4.second->NKnots() == bsp2C0res4->NKnots());\n\t\t CHECK((nbsp4.first->EndPoint()).X() == Approx((nbsp4.second->EndPoint()).X()));\n\t\t CHECK((nbsp4.first->EndPoint()).Y() == Approx((nbsp4.second->EndPoint()).Y()));\n\t\t CHECK((nbsp4.first->EndPoint()).Z() == Approx((nbsp4.second->EndPoint()).Z()));\n\t\t CHECK((nbsp4.first->StartPoint()).X() == Approx((bsp1->StartPoint()).X()));\n\t\t CHECK((nbsp4.first->StartPoint()).Y() == Approx((bsp1->StartPoint()).Y()));\n\t\t CHECK((nbsp4.first->StartPoint()).Z() == Approx((bsp1->StartPoint()).Z()));\n\t\t CHECK((nbsp4.second->StartPoint()).X() == Approx((bsp2->StartPoint()).X()));\n\t\t CHECK((nbsp4.second->StartPoint()).Y() == Approx((bsp2->StartPoint()).Y()));\n\t\t CHECK((nbsp4.second->StartPoint()).Z() == Approx((bsp2->StartPoint()).Z()));\n\t\t CHECK(nbsp5.first->NKnots() == bsp1G1res1->NKnots());\n\t\t CHECK(nbsp5.second->NKnots() == bsp2G1res1->NKnots());\n\t\t CHECK((nbsp5.first->StartPoint()).X() == Approx((nbsp5.second->StartPoint()).X()));\n\t\t CHECK((nbsp5.first->StartPoint()).Y() == Approx((nbsp5.second->StartPoint()).Y()));\n\t\t CHECK((nbsp5.first->StartPoint()).Z() == Approx((nbsp5.second->StartPoint()).Z()));\n\t\t CHECK((nbsp5.first->EndPoint()).X() == Approx((bsp1->EndPoint()).X()));\n\t\t CHECK((nbsp5.first->EndPoint()).Y() == Approx((bsp1->EndPoint()).Y()));\n\t\t CHECK((nbsp5.first->EndPoint()).Z() == Approx((bsp1->EndPoint()).Z()));\n\t\t CHECK((nbsp5.second->EndPoint()).X() == Approx((bsp2->EndPoint()).X()));\n\t\t CHECK((nbsp5.second->EndPoint()).Y() == Approx((bsp2->EndPoint()).Y()));\n\t\t CHECK((nbsp5.second->EndPoint()).Z() == Approx((bsp2->EndPoint()).Z()));\n\t\t CHECK(nbsp6.first->NKnots() == bsp1G1res2->NKnots());\n\t\t CHECK(nbsp6.second->NKnots() == bsp2G1res2->NKnots());\n\t\t CHECK((nbsp6.first->EndPoint()).X() == Approx((nbsp6.second->StartPoint()).X()));\n\t\t CHECK((nbsp6.first->EndPoint()).Y() == Approx((nbsp6.second->StartPoint()).Y()));\n\t\t CHECK((nbsp6.first->EndPoint()).Z() == Approx((nbsp6.second->StartPoint()).Z()));\n\t\t CHECK((nbsp6.first->StartPoint()).X() == Approx((bsp1->StartPoint()).X()));\n\t\t CHECK((nbsp6.first->StartPoint()).Y() == Approx((bsp1->StartPoint()).Y()));\n\t\t CHECK((nbsp6.first->StartPoint()).Z() == Approx((bsp1->StartPoint()).Z()));\n\t\t CHECK((nbsp6.second->EndPoint()).X() == Approx((bsp2->EndPoint()).X()));\n\t\t CHECK((nbsp6.second->EndPoint()).Y() == Approx((bsp2->EndPoint()).Y()));\n\t\t CHECK((nbsp6.second->EndPoint()).Z() == Approx((bsp2->EndPoint()).Z()));\n\t\t CHECK(nbsp7.first->NKnots() == bsp1G1res3->NKnots());\n\t\t CHECK(nbsp7.second->NKnots() == bsp2G1res3->NKnots());\n\t\t CHECK((nbsp7.first->StartPoint()).X() == Approx((nbsp7.second->EndPoint()).X()));\n\t\t CHECK((nbsp7.first->StartPoint()).Y() == Approx((nbsp7.second->EndPoint()).Y()));\n\t\t CHECK((nbsp7.first->StartPoint()).Z() == Approx((nbsp7.second->EndPoint()).Z()));\n\t\t CHECK((nbsp7.first->EndPoint()).X() == Approx((bsp1->EndPoint()).X()));\n\t\t CHECK((nbsp7.first->EndPoint()).Y() == Approx((bsp1->EndPoint()).Y()));\n\t\t CHECK((nbsp7.first->EndPoint()).Z() == Approx((bsp1->EndPoint()).Z()));\n\t\t CHECK((nbsp7.second->StartPoint()).X() == Approx((bsp2->StartPoint()).X()));\n\t\t CHECK((nbsp7.second->StartPoint()).Y() == Approx((bsp2->StartPoint()).Y()));\n\t\t CHECK((nbsp7.second->StartPoint()).Z() == Approx((bsp2->StartPoint()).Z()));\n\t\t CHECK(nbsp8.first->NKnots() == bsp1G1res4->NKnots());\n\t\t CHECK(nbsp8.second->NKnots() == bsp2G1res4->NKnots());\n\t\t CHECK((nbsp8.first->EndPoint()).X() == Approx((nbsp8.second->EndPoint()).X()));\n\t\t CHECK((nbsp8.first->EndPoint()).Y() == Approx((nbsp8.second->EndPoint()).Y()));\n\t\t CHECK((nbsp8.first->EndPoint()).Z() == Approx((nbsp8.second->EndPoint()).Z()));\n\t\t CHECK((nbsp8.first->StartPoint()).X() == Approx((bsp1->StartPoint()).X()));\n\t\t CHECK((nbsp8.first->StartPoint()).Y() == Approx((bsp1->StartPoint()).Y()));\n\t\t CHECK((nbsp8.first->StartPoint()).Z() == Approx((bsp1->StartPoint()).Z()));\n\t\t CHECK((nbsp8.second->StartPoint()).X() == Approx((bsp2->StartPoint()).X()));\n\t\t CHECK((nbsp8.second->StartPoint()).Y() == Approx((bsp2->StartPoint()).Y()));\n\t\t CHECK((nbsp8.second->StartPoint()).Z() == Approx((bsp2->StartPoint()).Z()));\n\t\t CHECK(nbsp9.first->NKnots() == bsp1G2res1->NKnots());\n\t\t CHECK(nbsp9.second->NKnots() == bsp2G2res1->NKnots());\n\t\t CHECK((nbsp9.first->StartPoint()).X() == Approx((nbsp9.second->StartPoint()).X()));\n\t\t CHECK((nbsp9.first->StartPoint()).Y() == Approx((nbsp9.second->StartPoint()).Y()));\n\t\t CHECK((nbsp9.first->StartPoint()).Z() == Approx((nbsp9.second->StartPoint()).Z()));\n\t\t CHECK((nbsp9.first->EndPoint()).X() == Approx((bsp1->EndPoint()).X()));\n\t\t CHECK((nbsp9.first->EndPoint()).Y() == Approx((bsp1->EndPoint()).Y()));\n\t\t CHECK((nbsp9.first->EndPoint()).Z() == Approx((bsp1->EndPoint()).Z()));\n\t\t CHECK((nbsp9.second->EndPoint()).X() == Approx((bsp2->EndPoint()).X()));\n\t\t CHECK((nbsp9.second->EndPoint()).Y() == Approx((bsp2->EndPoint()).Y()));\n\t\t CHECK((nbsp9.second->EndPoint()).Z() == Approx((bsp2->EndPoint()).Z()));\n\t\t CHECK(nbsp10.first->NKnots() == bsp1G2res2->NKnots());\n\t\t CHECK(nbsp10.second->NKnots() == bsp2G2res2->NKnots());\n\t\t CHECK((nbsp10.first->EndPoint()).X() == Approx((nbsp10.second->StartPoint()).X()));\n\t\t CHECK((nbsp10.first->EndPoint()).Y() == Approx((nbsp10.second->StartPoint()).Y()));\n\t\t CHECK((nbsp10.first->EndPoint()).Z() == Approx((nbsp10.second->StartPoint()).Z()));\n\t\t CHECK((nbsp10.first->StartPoint()).X() == Approx((bsp1->StartPoint()).X()));\n\t\t CHECK((nbsp10.first->StartPoint()).Y() == Approx((bsp1->StartPoint()).Y()));\n\t\t CHECK((nbsp10.first->StartPoint()).Z() == Approx((bsp1->StartPoint()).Z()));\n\t\t CHECK((nbsp10.second->EndPoint()).X() == Approx((bsp2->EndPoint()).X()));\n\t\t CHECK((nbsp10.second->EndPoint()).Y() == Approx((bsp2->EndPoint()).Y()));\n\t\t CHECK((nbsp10.second->EndPoint()).Z() == Approx((bsp2->EndPoint()).Z()));\n\t\t CHECK(nbsp11.first->NKnots() == bsp1G2res3->NKnots());\n\t\t CHECK(nbsp11.second->NKnots() == bsp2G2res3->NKnots());\n\t\t CHECK((nbsp11.first->StartPoint()).X() == Approx((nbsp11.second->EndPoint()).X()));\n\t\t CHECK((nbsp11.first->StartPoint()).Y() == Approx((nbsp11.second->EndPoint()).Y()));\n\t\t CHECK((nbsp11.first->StartPoint()).Z() == Approx((nbsp11.second->EndPoint()).Z()));\n\t\t CHECK((nbsp11.first->EndPoint()).X() == Approx((bsp1->EndPoint()).X()));\n\t\t CHECK((nbsp11.first->EndPoint()).Y() == Approx((bsp1->EndPoint()).Y()));\n\t\t CHECK((nbsp11.first->EndPoint()).Z() == Approx((bsp1->EndPoint()).Z()));\n\t\t CHECK((nbsp11.second->StartPoint()).X() == Approx((bsp2->StartPoint()).X()));\n\t\t CHECK((nbsp11.second->StartPoint()).Y() == Approx((bsp2->StartPoint()).Y()));\n\t\t CHECK((nbsp11.second->StartPoint()).Z() == Approx((bsp2->StartPoint()).Z()));\n\t\t CHECK(nbsp12.first->NKnots() == bsp1G2res4->NKnots());\n\t\t CHECK(nbsp12.second->NKnots() == bsp2G2res4->NKnots());\n\t\t CHECK((nbsp12.first->EndPoint()).X() == Approx((nbsp12.second->EndPoint()).X()));\n\t\t CHECK((nbsp12.first->EndPoint()).Y() == Approx((nbsp12.second->EndPoint()).Y()));\n\t\t CHECK((nbsp12.first->EndPoint()).Z() == Approx((nbsp12.second->EndPoint()).Z()));\n\t\t CHECK((nbsp12.first->StartPoint()).X() == Approx((bsp1->StartPoint()).X()));\n\t\t CHECK((nbsp12.first->StartPoint()).Y() == Approx((bsp1->StartPoint()).Y()));\n\t\t CHECK((nbsp12.first->StartPoint()).Z() == Approx((bsp1->StartPoint()).Z()));\n\t\t CHECK((nbsp12.second->StartPoint()).X() == Approx((bsp2->StartPoint()).X()));\n\t\t CHECK((nbsp12.second->StartPoint()).Y() == Approx((bsp2->StartPoint()).Y()));\n\t\t CHECK((nbsp12.second->StartPoint()).Z() == Approx((bsp2->StartPoint()).Z()));\n\t\t OCCTIO::OCCTTool::Write(MakeEdge(bsp1), outdir + \"bsp1.brep\");\n\t\t OCCTIO::OCCTTool::Write(MakeEdge(bsp2), outdir + \"bsp2.brep\");\n\t\t OCCTIO::OCCTTool::Write(MakeEdge(nbsp1.first), outdir + \"f1.brep\");\n\t\t OCCTIO::OCCTTool::Write(MakeEdge(nbsp1.second), outdir + \"s1.brep\");\n\t\t OCCTIO::OCCTTool::Write(MakeEdge(nbsp2.first), outdir + \"f2.brep\");\n\t\t OCCTIO::OCCTTool::Write(MakeEdge(nbsp2.second), outdir + \"s2.brep\");\n\t\t OCCTIO::OCCTTool::Write(MakeEdge(nbsp3.first), outdir + \"f3.brep\");\n\t\t OCCTIO::OCCTTool::Write(MakeEdge(nbsp3.second), outdir + \"s3.brep\");\n\t\t OCCTIO::OCCTTool::Write(MakeEdge(nbsp4.first), outdir + \"f4.brep\");\n\t\t OCCTIO::OCCTTool::Write(MakeEdge(nbsp4.second), outdir + \"s4.brep\");\n\t\t OCCTIO::OCCTTool::Write(MakeEdge(nbsp5.first), outdir + \"f5.brep\");\n\t\t OCCTIO::OCCTTool::Write(MakeEdge(nbsp5.second), outdir + \"s5.brep\");\n\t\t OCCTIO::OCCTTool::Write(MakeEdge(nbsp6.first), outdir + \"f6.brep\");\n\t\t OCCTIO::OCCTTool::Write(MakeEdge(nbsp6.second), outdir + \"s6.brep\");\n\t\t OCCTIO::OCCTTool::Write(MakeEdge(nbsp7.first), outdir + \"f7.brep\");\n\t\t OCCTIO::OCCTTool::Write(MakeEdge(nbsp7.second), outdir + \"s7.brep\");\n\t\t OCCTIO::OCCTTool::Write(MakeEdge(nbsp8.first), outdir + \"f8.brep\");\n\t\t OCCTIO::OCCTTool::Write(MakeEdge(nbsp8.second), outdir + \"s8.brep\");\n\t\t OCCTIO::OCCTTool::Write(MakeEdge(nbsp9.first), outdir + \"f9.brep\");\n\t\t OCCTIO::OCCTTool::Write(MakeEdge(nbsp9.second), outdir + \"s9.brep\");\n\t\t OCCTIO::OCCTTool::Write(MakeEdge(nbsp10.first), outdir + \"f10.brep\");\n\t\t OCCTIO::OCCTTool::Write(MakeEdge(nbsp10.second), outdir + \"s10.brep\");\n\t\t OCCTIO::OCCTTool::Write(MakeEdge(nbsp11.first), outdir + \"f11.brep\");\n\t\t OCCTIO::OCCTTool::Write(MakeEdge(nbsp11.second), outdir + \"s11.brep\");\n\t\t OCCTIO::OCCTTool::Write(MakeEdge(nbsp12.first), outdir + \"f12.brep\");\n\t\t OCCTIO::OCCTTool::Write(MakeEdge(nbsp12.second), outdir + \"s12.brep\");\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static std::pair<std::shared_ptr<Geom3BSplineCurve>, std::shared_ptr<Geom3BSplineCurve>> MatchCurveWithEachOther( ContinuityType cont, const std::shared_ptr<Geom3BSplineCurve>& curve, bool isFront, const std::shared_ptr<Geom3BSplineCurve>& targetCurve, bool isTargetFront, int otherEndCont),\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <nurbs/NURBSAPIMatch.hpp>\n#include <topology/TopoEdge.hpp>\n#include <topology/TopoTool.hpp>\n#include <nurbs/NURBSAPISweep.hpp>\n#include <nurbs/NURBSAPIRebuild.hpp>\n#include <modeling/MakeWire.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <offset/MakePipeShell.hpp>\n#include <geometry/Geom3BSplineSurface.hpp>\n#include <topology/TopoVertex.hpp>\n#include <topomesh/BRepMeshIncrementalMesh.hpp>\n#include <geometry/GeomAPIProjectPointOnCurve3.hpp>\n#include <modeling/TransformShape.hpp>\n#include <nurbs/NURBSAPIMatch.hpp>\n#include <modeling/MakeFace.hpp>\n#include <nurbs/NURBSAPIConvert.hpp>\n#include <topology/TopoExplorerTool.hpp>\n#include <modeling/MakeVertex.hpp>\nusing namespace AMCAX;\nstd::shared_ptr<Geom3BSplineSurface> GenerateTestSurface1(const int id)\n{\n\tstd::shared_ptr<Geom3BSplineSurface> bspSurf;\n\tswitch (id)\n\t{\n\tcase 0:\n\t{\n\t\tstd::vector<Point3> profilePoles;\n\t\tstd::vector<double> profileKnots(3);\n\t\tstd::vector<int> profileMults(3, 1);\n\t\tprofilePoles.push_back(Point3(0.0, 0.0, 0.0));\n\t\tprofilePoles.push_back(Point3(1.0, -0.2, 0.1));\n\t\tprofilePoles.push_back(Point3(2.0, 0.1, -0.1));\n\t\tprofilePoles.push_back(Point3(3.0, -0.1, 0.0));\n\t\tprofilePoles.push_back(Point3(4.0, 0.1, 0.2));\n\t\tprofileKnots[0] = 0;\n\t\tprofileKnots[1] = 0.5;\n\t\tprofileKnots[2] = 1;\n\t\tprofileMults.front() = 4;\n\t\tprofileMults.back() = 4;\n\t\tstd::shared_ptr<Geom3BSplineCurve> profileCurve = std::make_shared<Geom3BSplineCurve>(profilePoles, profileKnots, profileMults, 3);\n\t\tstd::vector<Point3> spinePoles;\n\t\tstd::vector<double> spineKnots(4);\n\t\tstd::vector<int> spineMults(4, 1);\n\t\tspinePoles.push_back(Point3(0.0, 0.0, 0.0));\n\t\tspinePoles.push_back(Point3(-0.1, 1.0, -0.2));\n\t\tspinePoles.push_back(Point3(0.1, 2.0, -0.1));\n\t\tspinePoles.push_back(Point3(0.2, 3.0, 0.1));\n\t\tspinePoles.push_back(Point3(0.1, 4.0, 0.0));\n\t\tspinePoles.push_back(Point3(0.0, 5.0, -0.1));\n\t\tspineKnots[0] = 0;\n\t\tspineKnots[1] = 1.0 / 3.0;\n\t\tspineKnots[2] = 2.0 / 3.0;\n\t\tspineKnots[3] = 1;\n\t\tspineMults.front() = 4;\n\t\tspineMults.back() = 4;\n\t\tstd::shared_ptr<Geom3BSplineCurve> spineCurve = std::make_shared<Geom3BSplineCurve>(spinePoles, spineKnots, spineMults, 3);\n\t\tTopoWire profile = MakeWire(MakeEdge(profileCurve)).Wire();\n\t\tTopoWire spine = MakeWire(MakeEdge(spineCurve)).Wire();\n\t\tMakePipeShell pipeShell(spine);\n\t\tpipeShell.Add(profile);\n\t\tpipeShell.SetMode(Frame3());\n\t\tTopoShape pipe = pipeShell.Shape();\n\t\tTopoExplorer ex(pipe, ShapeType::Face);\n\t\tTopoFace inputBasicFace = static_cast<const TopoFace&>(ex.Current());\n\t\tauto surf = TopoTool::Surface(inputBasicFace);\n\t\tbspSurf = NURBSAPIConvert::ToBSpline(surf);\n\t\tbreak;\n\t}\n\tcase 1:\n\t{\n\t\tArray2<Point3> poles(2, 5);\n\t\tpoles(0, 0) = Point3(0.0, 0.0, 0.0);\n\t\tpoles(0, 1) = Point3(1.0, -0.2, 0.1);\n\t\tpoles(0, 2) = Point3(2.0, 0.1, -0.1);\n\t\tpoles(0, 3) = Point3(3.0, -0.1, 0.0);\n\t\tpoles(0, 4) = Point3(4.0, 0.1, 0.2);\n\t\tpoles(1, 0) = Point3(0.0, 1.0, -0.1);\n\t\tpoles(1, 1) = Point3(1.0, 0.8, 0.0);\n\t\tpoles(1, 2) = Point3(2.0, 1.1, -0.2);\n\t\tpoles(1, 3) = Point3(3.0, 0.9, -0.1);\n\t\tpoles(1, 4) = Point3(4.0, 1.1, 0.1);\n\t\tstd::vector<double> vKnots(3);\n\t\tstd::vector<int> vMults(3, 1);\n\t\tvKnots[0] = 0;\n\t\tvKnots[1] = 0.5;\n\t\tvKnots[2] = 1;\n\t\tvMults.front() = 4;\n\t\tvMults.back() = 4;\n\t\tstd::vector<double> uKnots(2);\n\t\tstd::vector<int> uMults(2, 1);\n\t\tuKnots[0] = 0;\n\t\tuKnots[1] = 1;\n\t\tuMults.front() = 2;\n\t\tuMults.back() = 2;\n\t\tbspSurf = std::make_shared<Geom3BSplineSurface>(poles, uKnots, vKnots, uMults, vMults, 1, 3);\n\t\tTransformation3 trsf;\n\t\ttrsf.SetTranslationPart(Vector3(0.0, -6.0, 0.0));\n\t\tbspSurf->Transform(trsf);\n\t\tbreak;\n\t}\n\tcase 2:\n\t{\n\t\tstd::vector<Point3> profilePoles;\n\t\tstd::vector<double> profileKnots(4);\n\t\tstd::vector<int> profileMults(4, 1);\n\t\tprofilePoles.push_back(Point3(0.0, 0.0, 0.0));\n\t\tprofilePoles.push_back(Point3(1.0, -2.0, -3.0));\n\t\tprofilePoles.push_back(Point3(2.0, 1.0, 2.0));\n\t\tprofilePoles.push_back(Point3(3.0, -1.0, -1.0));\n\t\tprofilePoles.push_back(Point3(4.0, -3.0, 3.0));\n\t\tprofilePoles.push_back(Point3(5.0, 0.0, 1.0));\n\t\tprofileKnots[0] = 0;\n\t\tprofileKnots[1] = 1.0 / 3.0;\n\t\tprofileKnots[2] = 2.0 / 3.0;\n\t\tprofileKnots[3] = 1;\n\t\tprofileMults.front() = 4;\n\t\tprofileMults.back() = 4;\n\t\tstd::shared_ptr<Geom3BSplineCurve> profileCurve = std::make_shared<Geom3BSplineCurve>(profilePoles, profileKnots, profileMults, 3);\n\t\tstd::vector<Point3> spinePoles;\n\t\tstd::vector<double> spineKnots(4);\n\t\tstd::vector<int> spineMults(4, 1);\n\t\tspinePoles.push_back(Point3(0.0, 0.0, 0.0));\n\t\tspinePoles.push_back(Point3(-0.1, 1.0, -1.0));\n\t\tspinePoles.push_back(Point3(0.1, -2.0, -2.0));\n\t\tspinePoles.push_back(Point3(0.2, -3.0, -3.0));\n\t\tspinePoles.push_back(Point3(0.1, -4.0, -4.0));\n\t\tspinePoles.push_back(Point3(0.0, -2.5, -5.0));\n\t\tspinePoles.push_back(Point3(0.1, -1.0, -6.0));\n\t\tspinePoles.push_back(Point3(0.0, 0.0, -7.0));\n\t\tspineKnots[0] = 0;\n\t\tspineKnots[1] = 1.0 / 3.0;\n\t\tspineKnots[2] = 2.0 / 3.0;\n\t\tspineKnots[3] = 1;\n\t\tspineMults.front() = 6;\n\t\tspineMults.back() = 6;\n\t\tshared_ptr<Geom3BSplineCurve> spineCurve = std::make_shared<Geom3BSplineCurve>(spinePoles, spineKnots, spineMults, 5);\n\t\tTopoWire profile = MakeWire(MakeEdge(profileCurve)).Wire();\n\t\tTopoWire spine = MakeWire(MakeEdge(spineCurve)).Wire();\n\t\tMakePipeShell pipeShell(spine);\n\t\tpipeShell.Add(profile);\n\t\tpipeShell.SetMode(Frame3());\n\t\tTopoShape pipe = pipeShell.Shape();\n\t\tTopoExplorer ex(pipe, ShapeType::Face);\n\t\tTopoFace inputBasicFace = static_cast<const TopoFace&>(ex.Current());\n\t\tshared_ptr<Geom3Surface> surf = TopoTool::Surface(inputBasicFace);\n\t\tshared_ptr<Geom3BSplineSurface>  bspSurf = NURBSAPIConvert::ToBSpline(surf);\n\t\tTransformation3 trsf;\n\t\ttrsf.SetTranslationPart(Vector3(-6.0, 0.0, 0.0));\n\t\tbspSurf->Transform(trsf);\n\t\tbreak;\n\t}\n\t}\n\treturn bspSurf;\n}\nTEST_CASE(\"bug2: TestMatchTrimmedSurface \", \"[nurbs][Match][fixbug]\")\n{\n\tOUTPUT_DIRECTORY(nurbs, Match/bug590);\n\tstring filedir = INPUT_PATH_PREFIX\"./TestNURBS/TestMatchTrimmedSurface/\";\n\tTopoFace f1 = ReadBRepFace(filedir + \"surf1.brep\");\n\tTopoFace f2 = ReadBRepFace(filedir + \"surf2.brep\");\n\tPoint3 p1, p2;\n\tbool isSurf1TrimmedEdge = true;\n\tbool isSurf2TrimmedEdge = true;\n\tif (isSurf1TrimmedEdge)\n\t{\n\t\tp1 = ReadBRepPoint(filedir + \"tptS1.brep\");\n\t}\n\telse\n\t{\n\t\tp1 = ReadBRepPoint(filedir + \"nptS1.brep\");\n\t}\n\tif (isSurf2TrimmedEdge)\n\t{\n\t\tp2 = ReadBRepPoint(filedir + \"tptS2.brep\");\n\t}\n\telse\n\t{\n\t\tp2 = ReadBRepPoint(filedir + \"nptS2.brep\");\n\t}\n\tauto [d1, e1] = NearestEdge(p1, f1);\n\tauto [d2, e2] = NearestEdge(p2, f2);\n\tContinuityType cont = ContinuityType::G2;\n\tint otherEndCont = 0;\n\tNURBSMatchSurfConfig config;\n\tbool isPrecise = true;\n\tstd::vector<double> tol;\n\ttol.push_back(0.001);\n\ttol.push_back(0.1);\n\ttol.push_back(0.05);\n\tstd::vector<double> params(2, 1.0);\n\tauto result = NURBSAPIMatch::MatchFace(f1, e1, f2, e2, cont, otherEndCont, isPrecise, tol, params, false, config, config);\n\tdouble f = 0.0;\n\tdouble l = 0.0;\n\tshared_ptr< Geom3Curve > curve2 = TopoTool::Curve(e2, f, l);\n\tshared_ptr< Geom3Surface > src = TopoTool::Surface(f1);\n\tshared_ptr< Geom3Surface > surface = TopoTool::Surface(result[0]);\n\tdouble srcfpv = src->FirstVParameter();\n\tdouble fpv = surface->FirstVParameter();\n\tdouble lpv = surface->LastVParameter();\n\tshared_ptr<Geom3Curve> srcfv = src->VIso(srcfpv);\n\tshared_ptr<Geom3Curve> fv = surface->VIso(fpv);\n\tshared_ptr<Geom3Curve> lv = surface->VIso(lpv);\n\tint num = 1000;\n\tdouble resTol = 1e-3;\n\tdouble ratio = 0.1;\n\tdouble res1 = NurbsSampleCurve(num, resTol, srcfv, fv);\n\tdouble res2 = NurbsSampleCurve(num, resTol, curve2, lv);\n\tCHECK(res1 <= ratio);\n\tCHECK(res2 <= ratio);\n\tOCCTIO::OCCTTool::Write(MakeEdge(srcfv), outdir + \"srcfv.brep\");\n\tOCCTIO::OCCTTool::Write(MakeEdge(fv), outdir + \"fv.brep\");\n\tOCCTIO::OCCTTool::Write(MakeEdge(lv), outdir + \"lv.brep\");\n\tOCCTIO::OCCTTool::Write(f1, outdir + \"f1.brep\");\n\tOCCTIO::OCCTTool::Write(f2, outdir + \"f2.brep\");\n\tOCCTIO::OCCTTool::Write(MakeVertex(p1), outdir + \"p1.brep\");\n\tOCCTIO::OCCTTool::Write(MakeVertex(p2), outdir + \"p2.brep\");\n\tOCCTIO::OCCTTool::Write(e1, outdir + \"e1.brep\");\n\tOCCTIO::OCCTTool::Write(e2, outdir + \"e2.brep\");\n\tOCCTIO::OCCTTool::Write(result.front(), outdir + \"result.brep\");\n;\n\tSECTION(\"MatchCurveWithEachOther\")\n\t{\n\t\tstring filedir = INPUT_PATH_PREFIX\"./TestNURBS/TestMatchCurve/\";\n\t\tstring filedir1 = INPUT_PATH_PREFIX\"./TestNURBS/TestMatchCurve/Rhino/\";\n\t\tstring filedir2 = INPUT_PATH_PREFIX\"./TestNURBS/TestMatchCurve/Rhino/stepEachOther/\";\n\t\tshared_ptr<Geom3BSplineCurve> bsp1 = ReadBRepCurve(filedir + \"curve1.brep\");\n\t\tshared_ptr<Geom3BSplineCurve> bsp2 = ReadBRepCurve(filedir + \"curve2.brep\");\n\t\t OUTPUT_DIRECTORY(nurbs, Match/MatchCurve/MatchCurveWithEachOther);\n\t\t auto nbsp1 = NURBSAPIMatch::MatchCurveWithEachOther(ContinuityType::C0, bsp1, true, bsp2, true, 0);\n\t\t auto nbsp2 = NURBSAPIMatch::MatchCurveWithEachOther(ContinuityType::C0, bsp1, false, bsp2, true, 0);\n\t\t auto nbsp3 = NURBSAPIMatch::MatchCurveWithEachOther(ContinuityType::C0, bsp1, true, bsp2, false, 0);\n\t\t auto nbsp4 = NURBSAPIMatch::MatchCurveWithEachOther(ContinuityType::C0, bsp1, false, bsp2, false, 0);\n\t\t auto nbsp5 = NURBSAPIMatch::MatchCurveWithEachOther(ContinuityType::G1, bsp1, true, bsp2, true, 0);\n\t\t auto nbsp6 = NURBSAPIMatch::MatchCurveWithEachOther(ContinuityType::G1, bsp1, false, bsp2, true, 0);\n\t\t auto nbsp7 = NURBSAPIMatch::MatchCurveWithEachOther(ContinuityType::G1, bsp1, true, bsp2, false, 0);\n\t\t auto nbsp8 = NURBSAPIMatch::MatchCurveWithEachOther(ContinuityType::G1, bsp1, false, bsp2, false, 0);\n\t\t auto nbsp9 = NURBSAPIMatch::MatchCurveWithEachOther(ContinuityType::G2, bsp1, true, bsp2, true, 0);\n\t\t auto nbsp10 = NURBSAPIMatch::MatchCurveWithEachOther(ContinuityType::G2, bsp1, false, bsp2, true, 0);\n\t\t auto nbsp11 = NURBSAPIMatch::MatchCurveWithEachOther(ContinuityType::G2, bsp1, true, bsp2, false, 0);\n\t\t auto nbsp12 = NURBSAPIMatch::MatchCurveWithEachOther(ContinuityType::G2, bsp1, false, bsp2, false, 0);\n\t\t shared_ptr<Geom3BSplineCurve> bsp1C0res1 = ReadBRepCurve(filedir2 + \"bsp1C0truetrue.brep\");\n\t\t shared_ptr<Geom3BSplineCurve> bsp1C0res2 = ReadBRepCurve(filedir2 + \"bsp1C0falsetrue.brep\");\n\t\t shared_ptr<Geom3BSplineCurve> bsp1C0res3 = ReadBRepCurve(filedir2 + \"bsp1C0truefalse.brep\");\n\t\t shared_ptr<Geom3BSplineCurve> bsp1C0res4 = ReadBRepCurve(filedir2 + \"bsp1C0falsefalse.brep\");\n\t\t shared_ptr<Geom3BSplineCurve> bsp1G1res1 = ReadBRepCurve(filedir2 + \"bsp1G1truetrue.brep\");\n\t\t shared_ptr<Geom3BSplineCurve> bsp1G1res2 = ReadBRepCurve(filedir2 + \"bsp1G1falsetrue.brep\");\n\t\t shared_ptr<Geom3BSplineCurve> bsp1G1res3 = ReadBRepCurve(filedir2 + \"bsp1G1truefalse.brep\");\n\t\t shared_ptr<Geom3BSplineCurve> bsp1G1res4 = ReadBRepCurve(filedir2 + \"bsp1G1falsefalse.brep\");\n\t\t shared_ptr<Geom3BSplineCurve> bsp1G2res1 = ReadBRepCurve(filedir2 + \"bsp1G2truetrue.brep\");\n\t\t shared_ptr<Geom3BSplineCurve> bsp1G2res2 = ReadBRepCurve(filedir2 + \"bsp1G2falsetrue.brep\");\n\t\t shared_ptr<Geom3BSplineCurve> bsp1G2res3 = ReadBRepCurve(filedir2 + \"bsp1G2truefalse.brep\");\n\t\t shared_ptr<Geom3BSplineCurve> bsp1G2res4 = ReadBRepCurve(filedir2 + \"bsp1G2falsefalse.brep\");\n\t\t shared_ptr<Geom3BSplineCurve> bsp2C0res1 = ReadBRepCurve(filedir2 + \"bsp2C0truetrue.brep\");\n\t\t shared_ptr<Geom3BSplineCurve> bsp2C0res2 = ReadBRepCurve(filedir2 + \"bsp2C0falsetrue.brep\");\n\t\t shared_ptr<Geom3BSplineCurve> bsp2C0res3 = ReadBRepCurve(filedir2 + \"bsp2C0truefalse.brep\");\n\t\t shared_ptr<Geom3BSplineCurve> bsp2C0res4 = ReadBRepCurve(filedir2 + \"bsp2C0falsefalse.brep\");\n\t\t shared_ptr<Geom3BSplineCurve> bsp2G1res1 = ReadBRepCurve(filedir2 + \"bsp2G1truetrue.brep\");\n\t\t shared_ptr<Geom3BSplineCurve> bsp2G1res2 = ReadBRepCurve(filedir2 + \"bsp2G1falsetrue.brep\");\n\t\t shared_ptr<Geom3BSplineCurve> bsp2G1res3 = ReadBRepCurve(filedir2 + \"bsp2G1truefalse.brep\");\n\t\t shared_ptr<Geom3BSplineCurve> bsp2G1res4 = ReadBRepCurve(filedir2 + \"bsp2G1falsefalse.brep\");\n\t\t shared_ptr<Geom3BSplineCurve> bsp2G2res1 = ReadBRepCurve(filedir2 + \"bsp2G2truetrue.brep\");\n\t\t shared_ptr<Geom3BSplineCurve> bsp2G2res2 = ReadBRepCurve(filedir2 + \"bsp2G2falsetrue.brep\");\n\t\t shared_ptr<Geom3BSplineCurve> bsp2G2res3 = ReadBRepCurve(filedir2 + \"bsp2G2truefalse.brep\");\n\t\t shared_ptr<Geom3BSplineCurve> bsp2G2res4 = ReadBRepCurve(filedir2 + \"bsp2G2falsefalse.brep\");\n\t\t CHECK(nbsp1.first->NKnots() == bsp1C0res1->NKnots());\n\t\t CHECK(nbsp1.second->NKnots() == bsp2C0res1->NKnots());\n\t\t CHECK((nbsp1.first->StartPoint()).X() == Approx((nbsp1.second->StartPoint()).X()));\n\t\t CHECK((nbsp1.first->StartPoint()).Y() == Approx((nbsp1.second->StartPoint()).Y()));\n\t\t CHECK((nbsp1.first->StartPoint()).Z() == Approx((nbsp1.second->StartPoint()).Z()));\n\t\t CHECK((nbsp1.first->EndPoint()).X() == Approx((bsp1->EndPoint()).X()));\n\t\t CHECK((nbsp1.first->EndPoint()).Y() == Approx((bsp1->EndPoint()).Y()));\n\t\t CHECK((nbsp1.first->EndPoint()).Z() == Approx((bsp1->EndPoint()).Z()));\n\t\t CHECK((nbsp1.second->EndPoint()).X() == Approx((bsp2->EndPoint()).X()));\n\t\t CHECK((nbsp1.second->EndPoint()).Y() == Approx((bsp2->EndPoint()).Y()));\n\t\t CHECK((nbsp1.second->EndPoint()).Z() == Approx((bsp2->EndPoint()).Z()));\n\t\t CHECK(nbsp2.first->NKnots() == bsp1C0res2->NKnots());\n\t\t CHECK(nbsp2.second->NKnots() == bsp2C0res2->NKnots());\n\t\t CHECK((nbsp2.first->EndPoint()).X() == Approx((nbsp2.second->StartPoint()).X()));\n\t\t CHECK((nbsp2.first->EndPoint()).Y() == Approx((nbsp2.second->StartPoint()).Y()));\n\t\t CHECK((nbsp2.first->EndPoint()).Z() == Approx((nbsp2.second->StartPoint()).Z()));\n\t\t CHECK((nbsp2.first->StartPoint()).X() == Approx((bsp1->StartPoint()).X()));\n\t\t CHECK((nbsp2.first->StartPoint()).Y() == Approx((bsp1->StartPoint()).Y()));\n\t\t CHECK((nbsp2.first->StartPoint()).Z() == Approx((bsp1->StartPoint()).Z()));\n\t\t CHECK((nbsp2.second->EndPoint()).X() == Approx((bsp2->EndPoint()).X()));\n\t\t CHECK((nbsp2.second->EndPoint()).Y() == Approx((bsp2->EndPoint()).Y()));\n\t\t CHECK((nbsp2.second->EndPoint()).Z() == Approx((bsp2->EndPoint()).Z()));\n\t\t CHECK(nbsp3.first->NKnots() == bsp1C0res3->NKnots());\n\t\t CHECK(nbsp3.second->NKnots() == bsp2C0res3->NKnots());\n\t\t CHECK((nbsp3.first->StartPoint()).X() == Approx((nbsp3.second->EndPoint()).X()));\n\t\t CHECK((nbsp3.first->StartPoint()).Y() == Approx((nbsp3.second->EndPoint()).Y()));\n\t\t CHECK((nbsp3.first->StartPoint()).Z() == Approx((nbsp3.second->EndPoint()).Z()));\n\t\t CHECK((nbsp3.first->EndPoint()).X() == Approx((bsp1->EndPoint()).X()));\n\t\t CHECK((nbsp3.first->EndPoint()).Y() == Approx((bsp1->EndPoint()).Y()));\n\t\t CHECK((nbsp3.first->EndPoint()).Z() == Approx((bsp1->EndPoint()).Z()));\n\t\t CHECK((nbsp3.second->StartPoint()).X() == Approx((bsp2->StartPoint()).X()));\n\t\t CHECK((nbsp3.second->StartPoint()).Y() == Approx((bsp2->StartPoint()).Y()));\n\t\t CHECK((nbsp3.second->StartPoint()).Z() == Approx((bsp2->StartPoint()).Z()));\n\t\t CHECK(nbsp4.first->NKnots() == bsp1C0res4->NKnots());\n\t\t CHECK(nbsp4.second->NKnots() == bsp2C0res4->NKnots());\n\t\t CHECK((nbsp4.first->EndPoint()).X() == Approx((nbsp4.second->EndPoint()).X()));\n\t\t CHECK((nbsp4.first->EndPoint()).Y() == Approx((nbsp4.second->EndPoint()).Y()));\n\t\t CHECK((nbsp4.first->EndPoint()).Z() == Approx((nbsp4.second->EndPoint()).Z()));\n\t\t CHECK((nbsp4.first->StartPoint()).X() == Approx((bsp1->StartPoint()).X()));\n\t\t CHECK((nbsp4.first->StartPoint()).Y() == Approx((bsp1->StartPoint()).Y()));\n\t\t CHECK((nbsp4.first->StartPoint()).Z() == Approx((bsp1->StartPoint()).Z()));\n\t\t CHECK((nbsp4.second->StartPoint()).X() == Approx((bsp2->StartPoint()).X()));\n\t\t CHECK((nbsp4.second->StartPoint()).Y() == Approx((bsp2->StartPoint()).Y()));\n\t\t CHECK((nbsp4.second->StartPoint()).Z() == Approx((bsp2->StartPoint()).Z()));\n\t\t CHECK(nbsp5.first->NKnots() == bsp1G1res1->NKnots());\n\t\t CHECK(nbsp5.second->NKnots() == bsp2G1res1->NKnots());\n\t\t CHECK((nbsp5.first->StartPoint()).X() == Approx((nbsp5.second->StartPoint()).X()));\n\t\t CHECK((nbsp5.first->StartPoint()).Y() == Approx((nbsp5.second->StartPoint()).Y()));\n\t\t CHECK((nbsp5.first->StartPoint()).Z() == Approx((nbsp5.second->StartPoint()).Z()));\n\t\t CHECK((nbsp5.first->EndPoint()).X() == Approx((bsp1->EndPoint()).X()));\n\t\t CHECK((nbsp5.first->EndPoint()).Y() == Approx((bsp1->EndPoint()).Y()));\n\t\t CHECK((nbsp5.first->EndPoint()).Z() == Approx((bsp1->EndPoint()).Z()));\n\t\t CHECK((nbsp5.second->EndPoint()).X() == Approx((bsp2->EndPoint()).X()));\n\t\t CHECK((nbsp5.second->EndPoint()).Y() == Approx((bsp2->EndPoint()).Y()));\n\t\t CHECK((nbsp5.second->EndPoint()).Z() == Approx((bsp2->EndPoint()).Z()));\n\t\t CHECK(nbsp6.first->NKnots() == bsp1G1res2->NKnots());\n\t\t CHECK(nbsp6.second->NKnots() == bsp2G1res2->NKnots());\n\t\t CHECK((nbsp6.first->EndPoint()).X() == Approx((nbsp6.second->StartPoint()).X()));\n\t\t CHECK((nbsp6.first->EndPoint()).Y() == Approx((nbsp6.second->StartPoint()).Y()));\n\t\t CHECK((nbsp6.first->EndPoint()).Z() == Approx((nbsp6.second->StartPoint()).Z()));\n\t\t CHECK((nbsp6.first->StartPoint()).X() == Approx((bsp1->StartPoint()).X()));\n\t\t CHECK((nbsp6.first->StartPoint()).Y() == Approx((bsp1->StartPoint()).Y()));\n\t\t CHECK((nbsp6.first->StartPoint()).Z() == Approx((bsp1->StartPoint()).Z()));\n\t\t CHECK((nbsp6.second->EndPoint()).X() == Approx((bsp2->EndPoint()).X()));\n\t\t CHECK((nbsp6.second->EndPoint()).Y() == Approx((bsp2->EndPoint()).Y()));\n\t\t CHECK((nbsp6.second->EndPoint()).Z() == Approx((bsp2->EndPoint()).Z()));\n\t\t CHECK(nbsp7.first->NKnots() == bsp1G1res3->NKnots());\n\t\t CHECK(nbsp7.second->NKnots() == bsp2G1res3->NKnots());\n\t\t CHECK((nbsp7.first->StartPoint()).X() == Approx((nbsp7.second->EndPoint()).X()));\n\t\t CHECK((nbsp7.first->StartPoint()).Y() == Approx((nbsp7.second->EndPoint()).Y()));\n\t\t CHECK((nbsp7.first->StartPoint()).Z() == Approx((nbsp7.second->EndPoint()).Z()));\n\t\t CHECK((nbsp7.first->EndPoint()).X() == Approx((bsp1->EndPoint()).X()));\n\t\t CHECK((nbsp7.first->EndPoint()).Y() == Approx((bsp1->EndPoint()).Y()));\n\t\t CHECK((nbsp7.first->EndPoint()).Z() == Approx((bsp1->EndPoint()).Z()));\n\t\t CHECK((nbsp7.second->StartPoint()).X() == Approx((bsp2->StartPoint()).X()));\n\t\t CHECK((nbsp7.second->StartPoint()).Y() == Approx((bsp2->StartPoint()).Y()));\n\t\t CHECK((nbsp7.second->StartPoint()).Z() == Approx((bsp2->StartPoint()).Z()));\n\t\t CHECK(nbsp8.first->NKnots() == bsp1G1res4->NKnots());\n\t\t CHECK(nbsp8.second->NKnots() == bsp2G1res4->NKnots());\n\t\t CHECK((nbsp8.first->EndPoint()).X() == Approx((nbsp8.second->EndPoint()).X()));\n\t\t CHECK((nbsp8.first->EndPoint()).Y() == Approx((nbsp8.second->EndPoint()).Y()));\n\t\t CHECK((nbsp8.first->EndPoint()).Z() == Approx((nbsp8.second->EndPoint()).Z()));\n\t\t CHECK((nbsp8.first->StartPoint()).X() == Approx((bsp1->StartPoint()).X()));\n\t\t CHECK((nbsp8.first->StartPoint()).Y() == Approx((bsp1->StartPoint()).Y()));\n\t\t CHECK((nbsp8.first->StartPoint()).Z() == Approx((bsp1->StartPoint()).Z()));\n\t\t CHECK((nbsp8.second->StartPoint()).X() == Approx((bsp2->StartPoint()).X()));\n\t\t CHECK((nbsp8.second->StartPoint()).Y() == Approx((bsp2->StartPoint()).Y()));\n\t\t CHECK((nbsp8.second->StartPoint()).Z() == Approx((bsp2->StartPoint()).Z()));\n\t\t CHECK(nbsp9.first->NKnots() == bsp1G2res1->NKnots());\n\t\t CHECK(nbsp9.second->NKnots() == bsp2G2res1->NKnots());\n\t\t CHECK((nbsp9.first->StartPoint()).X() == Approx((nbsp9.second->StartPoint()).X()));\n\t\t CHECK((nbsp9.first->StartPoint()).Y() == Approx((nbsp9.second->StartPoint()).Y()));\n\t\t CHECK((nbsp9.first->StartPoint()).Z() == Approx((nbsp9.second->StartPoint()).Z()));\n\t\t CHECK((nbsp9.first->EndPoint()).X() == Approx((bsp1->EndPoint()).X()));\n\t\t CHECK((nbsp9.first->EndPoint()).Y() == Approx((bsp1->EndPoint()).Y()));\n\t\t CHECK((nbsp9.first->EndPoint()).Z() == Approx((bsp1->EndPoint()).Z()));\n\t\t CHECK((nbsp9.second->EndPoint()).X() == Approx((bsp2->EndPoint()).X()));\n\t\t CHECK((nbsp9.second->EndPoint()).Y() == Approx((bsp2->EndPoint()).Y()));\n\t\t CHECK((nbsp9.second->EndPoint()).Z() == Approx((bsp2->EndPoint()).Z()));\n\t\t CHECK(nbsp10.first->NKnots() == bsp1G2res2->NKnots());\n\t\t CHECK(nbsp10.second->NKnots() == bsp2G2res2->NKnots());\n\t\t CHECK((nbsp10.first->EndPoint()).X() == Approx((nbsp10.second->StartPoint()).X()));\n\t\t CHECK((nbsp10.first->EndPoint()).Y() == Approx((nbsp10.second->StartPoint()).Y()));\n\t\t CHECK((nbsp10.first->EndPoint()).Z() == Approx((nbsp10.second->StartPoint()).Z()));\n\t\t CHECK((nbsp10.first->StartPoint()).X() == Approx((bsp1->StartPoint()).X()));\n\t\t CHECK((nbsp10.first->StartPoint()).Y() == Approx((bsp1->StartPoint()).Y()));\n\t\t CHECK((nbsp10.first->StartPoint()).Z() == Approx((bsp1->StartPoint()).Z()));\n\t\t CHECK((nbsp10.second->EndPoint()).X() == Approx((bsp2->EndPoint()).X()));\n\t\t CHECK((nbsp10.second->EndPoint()).Y() == Approx((bsp2->EndPoint()).Y()));\n\t\t CHECK((nbsp10.second->EndPoint()).Z() == Approx((bsp2->EndPoint()).Z()));\n\t\t CHECK(nbsp11.first->NKnots() == bsp1G2res3->NKnots());\n\t\t CHECK(nbsp11.second->NKnots() == bsp2G2res3->NKnots());\n\t\t CHECK((nbsp11.first->StartPoint()).X() == Approx((nbsp11.second->EndPoint()).X()));\n\t\t CHECK((nbsp11.first->StartPoint()).Y() == Approx((nbsp11.second->EndPoint()).Y()));\n\t\t CHECK((nbsp11.first->StartPoint()).Z() == Approx((nbsp11.second->EndPoint()).Z()));\n\t\t CHECK((nbsp11.first->EndPoint()).X() == Approx((bsp1->EndPoint()).X()));\n\t\t CHECK((nbsp11.first->EndPoint()).Y() == Approx((bsp1->EndPoint()).Y()));\n\t\t CHECK((nbsp11.first->EndPoint()).Z() == Approx((bsp1->EndPoint()).Z()));\n\t\t CHECK((nbsp11.second->StartPoint()).X() == Approx((bsp2->StartPoint()).X()));\n\t\t CHECK((nbsp11.second->StartPoint()).Y() == Approx((bsp2->StartPoint()).Y()));\n\t\t CHECK((nbsp11.second->StartPoint()).Z() == Approx((bsp2->StartPoint()).Z()));\n\t\t CHECK(nbsp12.first->NKnots() == bsp1G2res4->NKnots());\n\t\t CHECK(nbsp12.second->NKnots() == bsp2G2res4->NKnots());\n\t\t CHECK((nbsp12.first->EndPoint()).X() == Approx((nbsp12.second->EndPoint()).X()));\n\t\t CHECK((nbsp12.first->EndPoint()).Y() == Approx((nbsp12.second->EndPoint()).Y()));\n\t\t CHECK((nbsp12.first->EndPoint()).Z() == Approx((nbsp12.second->EndPoint()).Z()));\n\t\t CHECK((nbsp12.first->StartPoint()).X() == Approx((bsp1->StartPoint()).X()));\n\t\t CHECK((nbsp12.first->StartPoint()).Y() == Approx((bsp1->StartPoint()).Y()));\n\t\t CHECK((nbsp12.first->StartPoint()).Z() == Approx((bsp1->StartPoint()).Z()));\n\t\t CHECK((nbsp12.second->StartPoint()).X() == Approx((bsp2->StartPoint()).X()));\n\t\t CHECK((nbsp12.second->StartPoint()).Y() == Approx((bsp2->StartPoint()).Y()));\n\t\t CHECK((nbsp12.second->StartPoint()).Z() == Approx((bsp2->StartPoint()).Z()));\n\t\t OCCTIO::OCCTTool::Write(MakeEdge(bsp1), outdir + \"bsp1.brep\");\n\t\t OCCTIO::OCCTTool::Write(MakeEdge(bsp2), outdir + \"bsp2.brep\");\n\t\t OCCTIO::OCCTTool::Write(MakeEdge(nbsp1.first), outdir + \"f1.brep\");\n\t\t OCCTIO::OCCTTool::Write(MakeEdge(nbsp1.second), outdir + \"s1.brep\");\n\t\t OCCTIO::OCCTTool::Write(MakeEdge(nbsp2.first), outdir + \"f2.brep\");\n\t\t OCCTIO::OCCTTool::Write(MakeEdge(nbsp2.second), outdir + \"s2.brep\");\n\t\t OCCTIO::OCCTTool::Write(MakeEdge(nbsp3.first), outdir + \"f3.brep\");\n\t\t OCCTIO::OCCTTool::Write(MakeEdge(nbsp3.second), outdir + \"s3.brep\");\n\t\t OCCTIO::OCCTTool::Write(MakeEdge(nbsp4.first), outdir + \"f4.brep\");\n\t\t OCCTIO::OCCTTool::Write(MakeEdge(nbsp4.second), outdir + \"s4.brep\");\n\t\t OCCTIO::OCCTTool::Write(MakeEdge(nbsp5.first), outdir + \"f5.brep\");\n\t\t OCCTIO::OCCTTool::Write(MakeEdge(nbsp5.second), outdir + \"s5.brep\");\n\t\t OCCTIO::OCCTTool::Write(MakeEdge(nbsp6.first), outdir + \"f6.brep\");\n\t\t OCCTIO::OCCTTool::Write(MakeEdge(nbsp6.second), outdir + \"s6.brep\");\n\t\t OCCTIO::OCCTTool::Write(MakeEdge(nbsp7.first), outdir + \"f7.brep\");\n\t\t OCCTIO::OCCTTool::Write(MakeEdge(nbsp7.second), outdir + \"s7.brep\");\n\t\t OCCTIO::OCCTTool::Write(MakeEdge(nbsp8.first), outdir + \"f8.brep\");\n\t\t OCCTIO::OCCTTool::Write(MakeEdge(nbsp8.second), outdir + \"s8.brep\");\n\t\t OCCTIO::OCCTTool::Write(MakeEdge(nbsp9.first), outdir + \"f9.brep\");\n\t\t OCCTIO::OCCTTool::Write(MakeEdge(nbsp9.second), outdir + \"s9.brep\");\n\t\t OCCTIO::OCCTTool::Write(MakeEdge(nbsp10.first), outdir + \"f10.brep\");\n\t\t OCCTIO::OCCTTool::Write(MakeEdge(nbsp10.second), outdir + \"s10.brep\");\n\t\t OCCTIO::OCCTTool::Write(MakeEdge(nbsp11.first), outdir + \"f11.brep\");\n\t\t OCCTIO::OCCTTool::Write(MakeEdge(nbsp11.second), outdir + \"s11.brep\");\n\t\t OCCTIO::OCCTTool::Write(MakeEdge(nbsp12.first), outdir + \"f12.brep\");\n\t\t OCCTIO::OCCTTool::Write(MakeEdge(nbsp12.second), outdir + \"s12.brep\");\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static std::shared_ptr<Geom3BSplineCurve> MatchCurve( ContinuityType cont, const std::shared_ptr<Geom3BSplineCurve>& curve, bool isFront, const std::shared_ptr<Geom3BSplineCurve>& targetCurve, bool isTargetFront, int otherEndCont, std::vector<double>& params),\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <nurbs/NURBSAPIMatch.hpp>\n#include <topology/TopoEdge.hpp>\n#include <topology/TopoTool.hpp>\n#include <nurbs/NURBSAPISweep.hpp>\n#include <nurbs/NURBSAPIRebuild.hpp>\n#include <modeling/MakeWire.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <offset/MakePipeShell.hpp>\n#include <geometry/Geom3BSplineSurface.hpp>\n#include <topology/TopoVertex.hpp>\n#include <topomesh/BRepMeshIncrementalMesh.hpp>\n#include <geometry/GeomAPIProjectPointOnCurve3.hpp>\n#include <modeling/TransformShape.hpp>\n#include <nurbs/NURBSAPIMatch.hpp>\n#include <modeling/MakeFace.hpp>\n#include <nurbs/NURBSAPIConvert.hpp>\n#include <topology/TopoExplorerTool.hpp>\n#include <modeling/MakeVertex.hpp>\nusing namespace AMCAX;\nstd::shared_ptr<Geom3BSplineSurface> GenerateTestSurface1(const int id)\n{\n\tstd::shared_ptr<Geom3BSplineSurface> bspSurf;\n\tswitch (id)\n\t{\n\tcase 0:\n\t{\n\t\tstd::vector<Point3> profilePoles;\n\t\tstd::vector<double> profileKnots(3);\n\t\tstd::vector<int> profileMults(3, 1);\n\t\tprofilePoles.push_back(Point3(0.0, 0.0, 0.0));\n\t\tprofilePoles.push_back(Point3(1.0, -0.2, 0.1));\n\t\tprofilePoles.push_back(Point3(2.0, 0.1, -0.1));\n\t\tprofilePoles.push_back(Point3(3.0, -0.1, 0.0));\n\t\tprofilePoles.push_back(Point3(4.0, 0.1, 0.2));\n\t\tprofileKnots[0] = 0;\n\t\tprofileKnots[1] = 0.5;\n\t\tprofileKnots[2] = 1;\n\t\tprofileMults.front() = 4;\n\t\tprofileMults.back() = 4;\n\t\tstd::shared_ptr<Geom3BSplineCurve> profileCurve = std::make_shared<Geom3BSplineCurve>(profilePoles, profileKnots, profileMults, 3);\n\t\tstd::vector<Point3> spinePoles;\n\t\tstd::vector<double> spineKnots(4);\n\t\tstd::vector<int> spineMults(4, 1);\n\t\tspinePoles.push_back(Point3(0.0, 0.0, 0.0));\n\t\tspinePoles.push_back(Point3(-0.1, 1.0, -0.2));\n\t\tspinePoles.push_back(Point3(0.1, 2.0, -0.1));\n\t\tspinePoles.push_back(Point3(0.2, 3.0, 0.1));\n\t\tspinePoles.push_back(Point3(0.1, 4.0, 0.0));\n\t\tspinePoles.push_back(Point3(0.0, 5.0, -0.1));\n\t\tspineKnots[0] = 0;\n\t\tspineKnots[1] = 1.0 / 3.0;\n\t\tspineKnots[2] = 2.0 / 3.0;\n\t\tspineKnots[3] = 1;\n\t\tspineMults.front() = 4;\n\t\tspineMults.back() = 4;\n\t\tstd::shared_ptr<Geom3BSplineCurve> spineCurve = std::make_shared<Geom3BSplineCurve>(spinePoles, spineKnots, spineMults, 3);\n\t\tTopoWire profile = MakeWire(MakeEdge(profileCurve)).Wire();\n\t\tTopoWire spine = MakeWire(MakeEdge(spineCurve)).Wire();\n\t\tMakePipeShell pipeShell(spine);\n\t\tpipeShell.Add(profile);\n\t\tpipeShell.SetMode(Frame3());\n\t\tTopoShape pipe = pipeShell.Shape();\n\t\tTopoExplorer ex(pipe, ShapeType::Face);\n\t\tTopoFace inputBasicFace = static_cast<const TopoFace&>(ex.Current());\n\t\tauto surf = TopoTool::Surface(inputBasicFace);\n\t\tbspSurf = NURBSAPIConvert::ToBSpline(surf);\n\t\tbreak;\n\t}\n\tcase 1:\n\t{\n\t\tArray2<Point3> poles(2, 5);\n\t\tpoles(0, 0) = Point3(0.0, 0.0, 0.0);\n\t\tpoles(0, 1) = Point3(1.0, -0.2, 0.1);\n\t\tpoles(0, 2) = Point3(2.0, 0.1, -0.1);\n\t\tpoles(0, 3) = Point3(3.0, -0.1, 0.0);\n\t\tpoles(0, 4) = Point3(4.0, 0.1, 0.2);\n\t\tpoles(1, 0) = Point3(0.0, 1.0, -0.1);\n\t\tpoles(1, 1) = Point3(1.0, 0.8, 0.0);\n\t\tpoles(1, 2) = Point3(2.0, 1.1, -0.2);\n\t\tpoles(1, 3) = Point3(3.0, 0.9, -0.1);\n\t\tpoles(1, 4) = Point3(4.0, 1.1, 0.1);\n\t\tstd::vector<double> vKnots(3);\n\t\tstd::vector<int> vMults(3, 1);\n\t\tvKnots[0] = 0;\n\t\tvKnots[1] = 0.5;\n\t\tvKnots[2] = 1;\n\t\tvMults.front() = 4;\n\t\tvMults.back() = 4;\n\t\tstd::vector<double> uKnots(2);\n\t\tstd::vector<int> uMults(2, 1);\n\t\tuKnots[0] = 0;\n\t\tuKnots[1] = 1;\n\t\tuMults.front() = 2;\n\t\tuMults.back() = 2;\n\t\tbspSurf = std::make_shared<Geom3BSplineSurface>(poles, uKnots, vKnots, uMults, vMults, 1, 3);\n\t\tTransformation3 trsf;\n\t\ttrsf.SetTranslationPart(Vector3(0.0, -6.0, 0.0));\n\t\tbspSurf->Transform(trsf);\n\t\tbreak;\n\t}\n\tcase 2:\n\t{\n\t\tstd::vector<Point3> profilePoles;\n\t\tstd::vector<double> profileKnots(4);\n\t\tstd::vector<int> profileMults(4, 1);\n\t\tprofilePoles.push_back(Point3(0.0, 0.0, 0.0));\n\t\tprofilePoles.push_back(Point3(1.0, -2.0, -3.0));\n\t\tprofilePoles.push_back(Point3(2.0, 1.0, 2.0));\n\t\tprofilePoles.push_back(Point3(3.0, -1.0, -1.0));\n\t\tprofilePoles.push_back(Point3(4.0, -3.0, 3.0));\n\t\tprofilePoles.push_back(Point3(5.0, 0.0, 1.0));\n\t\tprofileKnots[0] = 0;\n\t\tprofileKnots[1] = 1.0 / 3.0;\n\t\tprofileKnots[2] = 2.0 / 3.0;\n\t\tprofileKnots[3] = 1;\n\t\tprofileMults.front() = 4;\n\t\tprofileMults.back() = 4;\n\t\tstd::shared_ptr<Geom3BSplineCurve> profileCurve = std::make_shared<Geom3BSplineCurve>(profilePoles, profileKnots, profileMults, 3);\n\t\tstd::vector<Point3> spinePoles;\n\t\tstd::vector<double> spineKnots(4);\n\t\tstd::vector<int> spineMults(4, 1);\n\t\tspinePoles.push_back(Point3(0.0, 0.0, 0.0));\n\t\tspinePoles.push_back(Point3(-0.1, 1.0, -1.0));\n\t\tspinePoles.push_back(Point3(0.1, -2.0, -2.0));\n\t\tspinePoles.push_back(Point3(0.2, -3.0, -3.0));\n\t\tspinePoles.push_back(Point3(0.1, -4.0, -4.0));\n\t\tspinePoles.push_back(Point3(0.0, -2.5, -5.0));\n\t\tspinePoles.push_back(Point3(0.1, -1.0, -6.0));\n\t\tspinePoles.push_back(Point3(0.0, 0.0, -7.0));\n\t\tspineKnots[0] = 0;\n\t\tspineKnots[1] = 1.0 / 3.0;\n\t\tspineKnots[2] = 2.0 / 3.0;\n\t\tspineKnots[3] = 1;\n\t\tspineMults.front() = 6;\n\t\tspineMults.back() = 6;\n\t\tshared_ptr<Geom3BSplineCurve> spineCurve = std::make_shared<Geom3BSplineCurve>(spinePoles, spineKnots, spineMults, 5);\n\t\tTopoWire profile = MakeWire(MakeEdge(profileCurve)).Wire();\n\t\tTopoWire spine = MakeWire(MakeEdge(spineCurve)).Wire();\n\t\tMakePipeShell pipeShell(spine);\n\t\tpipeShell.Add(profile);\n\t\tpipeShell.SetMode(Frame3());\n\t\tTopoShape pipe = pipeShell.Shape();\n\t\tTopoExplorer ex(pipe, ShapeType::Face);\n\t\tTopoFace inputBasicFace = static_cast<const TopoFace&>(ex.Current());\n\t\tshared_ptr<Geom3Surface> surf = TopoTool::Surface(inputBasicFace);\n\t\tshared_ptr<Geom3BSplineSurface>  bspSurf = NURBSAPIConvert::ToBSpline(surf);\n\t\tTransformation3 trsf;\n\t\ttrsf.SetTranslationPart(Vector3(-6.0, 0.0, 0.0));\n\t\tbspSurf->Transform(trsf);\n\t\tbreak;\n\t}\n\t}\n\treturn bspSurf;\n}\nTEST_CASE(\"bug2: TestMatchTrimmedSurface \", \"[nurbs][Match][fixbug]\")\n{\n\tOUTPUT_DIRECTORY(nurbs, Match/bug590);\n\tstring filedir = INPUT_PATH_PREFIX\"./TestNURBS/TestMatchTrimmedSurface/\";\n\tTopoFace f1 = ReadBRepFace(filedir + \"surf1.brep\");\n\tTopoFace f2 = ReadBRepFace(filedir + \"surf2.brep\");\n\tPoint3 p1, p2;\n\tbool isSurf1TrimmedEdge = true;\n\tbool isSurf2TrimmedEdge = true;\n\tif (isSurf1TrimmedEdge)\n\t{\n\t\tp1 = ReadBRepPoint(filedir + \"tptS1.brep\");\n\t}\n\telse\n\t{\n\t\tp1 = ReadBRepPoint(filedir + \"nptS1.brep\");\n\t}\n\tif (isSurf2TrimmedEdge)\n\t{\n\t\tp2 = ReadBRepPoint(filedir + \"tptS2.brep\");\n\t}\n\telse\n\t{\n\t\tp2 = ReadBRepPoint(filedir + \"nptS2.brep\");\n\t}\n\tauto [d1, e1] = NearestEdge(p1, f1);\n\tauto [d2, e2] = NearestEdge(p2, f2);\n\tContinuityType cont = ContinuityType::G2;\n\tint otherEndCont = 0;\n\tNURBSMatchSurfConfig config;\n\tbool isPrecise = true;\n\tstd::vector<double> tol;\n\ttol.push_back(0.001);\n\ttol.push_back(0.1);\n\ttol.push_back(0.05);\n\tstd::vector<double> params(2, 1.0);\n\tauto result = NURBSAPIMatch::MatchFace(f1, e1, f2, e2, cont, otherEndCont, isPrecise, tol, params, false, config, config);\n\tdouble f = 0.0;\n\tdouble l = 0.0;\n\tshared_ptr< Geom3Curve > curve2 = TopoTool::Curve(e2, f, l);\n\tshared_ptr< Geom3Surface > src = TopoTool::Surface(f1);\n\tshared_ptr< Geom3Surface > surface = TopoTool::Surface(result[0]);\n\tdouble srcfpv = src->FirstVParameter();\n\tdouble fpv = surface->FirstVParameter();\n\tdouble lpv = surface->LastVParameter();\n\tshared_ptr<Geom3Curve> srcfv = src->VIso(srcfpv);\n\tshared_ptr<Geom3Curve> fv = surface->VIso(fpv);\n\tshared_ptr<Geom3Curve> lv = surface->VIso(lpv);\n\tint num = 1000;\n\tdouble resTol = 1e-3;\n\tdouble ratio = 0.1;\n\tdouble res1 = NurbsSampleCurve(num, resTol, srcfv, fv);\n\tdouble res2 = NurbsSampleCurve(num, resTol, curve2, lv);\n\tCHECK(res1 <= ratio);\n\tCHECK(res2 <= ratio);\n\tOCCTIO::OCCTTool::Write(MakeEdge(srcfv), outdir + \"srcfv.brep\");\n\tOCCTIO::OCCTTool::Write(MakeEdge(fv), outdir + \"fv.brep\");\n\tOCCTIO::OCCTTool::Write(MakeEdge(lv), outdir + \"lv.brep\");\n\tOCCTIO::OCCTTool::Write(f1, outdir + \"f1.brep\");\n\tOCCTIO::OCCTTool::Write(f2, outdir + \"f2.brep\");\n\tOCCTIO::OCCTTool::Write(MakeVertex(p1), outdir + \"p1.brep\");\n\tOCCTIO::OCCTTool::Write(MakeVertex(p2), outdir + \"p2.brep\");\n\tOCCTIO::OCCTTool::Write(e1, outdir + \"e1.brep\");\n\tOCCTIO::OCCTTool::Write(e2, outdir + \"e2.brep\");\n\tOCCTIO::OCCTTool::Write(result.front(), outdir + \"result.brep\");\n;\n\tSECTION(\"MatchCurve1\")\n\t{\n\t\tOUTPUT_DIRECTORY(nurbs, Match/bug725/MatchCurve/MatchCurve1);\n\t\tstring filedir = INPUT_PATH_PREFIX\"./TestNURBS/TestMatchCurve/\";\n\t\tshared_ptr<Geom3BSplineCurve> bsp1 = ReadBRepCurve(filedir + \"curve1.brep\");\n\t\tshared_ptr<Geom3BSplineCurve> bsp2 = ReadBRepCurve(filedir + \"curve2.brep\");\n\t\tshared_ptr<Geom3BSplineCurve> oldnbsp1 = NURBSAPIMatch::MatchCurve(ContinuityType::C0, bsp1, true, bsp2, true, 0); \n\t\tshared_ptr<Geom3BSplineCurve> oldnbsp2 = NURBSAPIMatch::MatchCurve(ContinuityType::C0, bsp1, false, bsp2, true, 0);\n\t\tshared_ptr<Geom3BSplineCurve> oldnbsp3 = NURBSAPIMatch::MatchCurve(ContinuityType::C0, bsp1, true, bsp2, false, 0);\n\t\tshared_ptr<Geom3BSplineCurve> oldnbsp4 = NURBSAPIMatch::MatchCurve(ContinuityType::C0, bsp1, false, bsp2, false, 0);\n\t\tshared_ptr<Geom3BSplineCurve> oldnbsp5 = NURBSAPIMatch::MatchCurve(ContinuityType::G1, bsp1, true, bsp2, true, 0);\n\t\tshared_ptr<Geom3BSplineCurve> oldnbsp6 = NURBSAPIMatch::MatchCurve(ContinuityType::G1, bsp1, false, bsp2, true, 0);\n\t\tshared_ptr<Geom3BSplineCurve> oldnbsp7 = NURBSAPIMatch::MatchCurve(ContinuityType::G1, bsp1, true, bsp2, false, 0);\n\t\tshared_ptr<Geom3BSplineCurve> oldnbsp8 = NURBSAPIMatch::MatchCurve(ContinuityType::G1, bsp1, false, bsp2, false, 0);\n\t\tshared_ptr<Geom3BSplineCurve> oldnbsp9 = NURBSAPIMatch::MatchCurve(ContinuityType::G2, bsp1, true, bsp2, true, 0);\n\t\tshared_ptr<Geom3BSplineCurve> oldnbsp10 = NURBSAPIMatch::MatchCurve(ContinuityType::G2, bsp1, false, bsp2, true, 0);\n\t\tshared_ptr<Geom3BSplineCurve> oldnbsp11 = NURBSAPIMatch::MatchCurve(ContinuityType::G2, bsp1, true, bsp2, false, 0);\n\t\tshared_ptr<Geom3BSplineCurve> oldnbsp12 = NURBSAPIMatch::MatchCurve(ContinuityType::G2, bsp1, false, bsp2, false, 0);\n\t\tshared_ptr<Geom3BSplineCurve> bsp1Inc = std::dynamic_pointer_cast<Geom3BSplineCurve>(bsp1->Copy());\n\t\tshared_ptr<Geom3BSplineCurve> bsp2Inc = std::dynamic_pointer_cast<Geom3BSplineCurve>(bsp2->Copy());\n\t\tbsp1Inc->IncreaseDegree(refDeg);\n\t\tbsp2Inc->IncreaseDegree(refDeg);\n\t\tshared_ptr<Geom3BSplineCurve> nbsp1 = NURBSAPIMatch::MatchCurve(ContinuityType::C0, bsp1Inc, true, bsp2Inc, true, 0); \n\t\tshared_ptr<Geom3BSplineCurve> nbsp2 = NURBSAPIMatch::MatchCurve(ContinuityType::C0, bsp1Inc, false, bsp2Inc, true, 0);\n\t\tshared_ptr<Geom3BSplineCurve> nbsp3 = NURBSAPIMatch::MatchCurve(ContinuityType::C0, bsp1Inc, true, bsp2Inc, false, 0);\n\t\tshared_ptr<Geom3BSplineCurve> nbsp4 = NURBSAPIMatch::MatchCurve(ContinuityType::C0, bsp1Inc, false, bsp2Inc, false, 0);\n\t\tshared_ptr<Geom3BSplineCurve> nbsp5 = NURBSAPIMatch::MatchCurve(ContinuityType::G1, bsp1Inc, true, bsp2Inc, true, 0);\n\t\tshared_ptr<Geom3BSplineCurve> nbsp6 = NURBSAPIMatch::MatchCurve(ContinuityType::G1, bsp1Inc, false, bsp2Inc, true, 0);\n\t\tshared_ptr<Geom3BSplineCurve> nbsp7 = NURBSAPIMatch::MatchCurve(ContinuityType::G1, bsp1Inc, true, bsp2Inc, false, 0);\n\t\tshared_ptr<Geom3BSplineCurve> nbsp8 = NURBSAPIMatch::MatchCurve(ContinuityType::G1, bsp1Inc, false, bsp2Inc, false, 0);\n\t\tshared_ptr<Geom3BSplineCurve> nbsp9 = NURBSAPIMatch::MatchCurve(ContinuityType::G2, bsp1Inc, true, bsp2Inc, true, 0);\n\t\tshared_ptr<Geom3BSplineCurve> nbsp10 = NURBSAPIMatch::MatchCurve(ContinuityType::G2, bsp1Inc, false, bsp2Inc, true, 0);\n\t\tshared_ptr<Geom3BSplineCurve> nbsp11 = NURBSAPIMatch::MatchCurve(ContinuityType::G2, bsp1Inc, true, bsp2Inc, false, 0);\n\t\tshared_ptr<Geom3BSplineCurve> nbsp12 = NURBSAPIMatch::MatchCurve(ContinuityType::G2, bsp1Inc, false, bsp2Inc, false, 0);\n\t\tdouble res1 = NurbsSampleCurve(num, refTol, oldnbsp1, nbsp1);\n\t\tdouble res2 = NurbsSampleCurve(num, refTol, oldnbsp2, nbsp2);\n\t\tdouble res3 = NurbsSampleCurve(num, refTol, oldnbsp3, nbsp3);\n\t\tdouble res4 = NurbsSampleCurve(num, refTol, oldnbsp4, nbsp4);\n\t\tdouble res5 = NurbsSampleCurve(num, refTol, oldnbsp5, nbsp5);\n\t\tdouble res6 = NurbsSampleCurve(num, refTol, oldnbsp6, nbsp6);\n\t\tdouble res7 = NurbsSampleCurve(num, refTol, oldnbsp7, nbsp7);\n\t\tdouble res8 = NurbsSampleCurve(num, refTol, oldnbsp8, nbsp8);\n\t\tdouble res9 = NurbsSampleCurve(num, refTol, oldnbsp9, nbsp9);\n\t\tdouble res10 = NurbsSampleCurve(num, refTol, oldnbsp10, nbsp10);\n\t\tdouble res11 = NurbsSampleCurve(num, refTol, oldnbsp11, nbsp11);\n\t\tdouble res12 = NurbsSampleCurve(num, refTol, oldnbsp12, nbsp12);\n\t\tOCCTIO::OCCTTool::Write(MakeEdge(bsp1), outdir + \"bsp1.brep\");\n\t\tOCCTIO::OCCTTool::Write(MakeEdge(bsp2), outdir + \"bsp2.brep\");\n\t\tOCCTIO::OCCTTool::Write(MakeEdge(bsp1Inc), outdir + \"bsp1Inc.brep\");\n\t\tOCCTIO::OCCTTool::Write(MakeEdge(bsp2Inc), outdir + \"bsp2Inc.brep\");\n\t\tOCCTIO::OCCTTool::Write(MakeEdge(oldnbsp1), outdir + \"oldresult.brep\");\n\t\tOCCTIO::OCCTTool::Write(MakeEdge(nbsp1), outdir + \"result.brep\");\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static std::shared_ptr<Geom3BSplineCurve> MatchCurve( ContinuityType cont, const std::shared_ptr<Geom3BSplineCurve>& curve, bool isFront, const std::shared_ptr<Geom3BSplineCurve>& targetCurve, bool isTargetFront, int otherEndCont),\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <nurbs/NURBSAPIMatch.hpp>\n#include <topology/TopoEdge.hpp>\n#include <topology/TopoTool.hpp>\n#include <nurbs/NURBSAPISweep.hpp>\n#include <nurbs/NURBSAPIRebuild.hpp>\n#include <modeling/MakeWire.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <offset/MakePipeShell.hpp>\n#include <geometry/Geom3BSplineSurface.hpp>\n#include <topology/TopoVertex.hpp>\n#include <topomesh/BRepMeshIncrementalMesh.hpp>\n#include <geometry/GeomAPIProjectPointOnCurve3.hpp>\n#include <modeling/TransformShape.hpp>\n#include <nurbs/NURBSAPIMatch.hpp>\n#include <modeling/MakeFace.hpp>\n#include <nurbs/NURBSAPIConvert.hpp>\n#include <topology/TopoExplorerTool.hpp>\n#include <modeling/MakeVertex.hpp>\nusing namespace AMCAX;\nstd::shared_ptr<Geom3BSplineSurface> GenerateTestSurface1(const int id)\n{\n\tstd::shared_ptr<Geom3BSplineSurface> bspSurf;\n\tswitch (id)\n\t{\n\tcase 0:\n\t{\n\t\tstd::vector<Point3> profilePoles;\n\t\tstd::vector<double> profileKnots(3);\n\t\tstd::vector<int> profileMults(3, 1);\n\t\tprofilePoles.push_back(Point3(0.0, 0.0, 0.0));\n\t\tprofilePoles.push_back(Point3(1.0, -0.2, 0.1));\n\t\tprofilePoles.push_back(Point3(2.0, 0.1, -0.1));\n\t\tprofilePoles.push_back(Point3(3.0, -0.1, 0.0));\n\t\tprofilePoles.push_back(Point3(4.0, 0.1, 0.2));\n\t\tprofileKnots[0] = 0;\n\t\tprofileKnots[1] = 0.5;\n\t\tprofileKnots[2] = 1;\n\t\tprofileMults.front() = 4;\n\t\tprofileMults.back() = 4;\n\t\tstd::shared_ptr<Geom3BSplineCurve> profileCurve = std::make_shared<Geom3BSplineCurve>(profilePoles, profileKnots, profileMults, 3);\n\t\tstd::vector<Point3> spinePoles;\n\t\tstd::vector<double> spineKnots(4);\n\t\tstd::vector<int> spineMults(4, 1);\n\t\tspinePoles.push_back(Point3(0.0, 0.0, 0.0));\n\t\tspinePoles.push_back(Point3(-0.1, 1.0, -0.2));\n\t\tspinePoles.push_back(Point3(0.1, 2.0, -0.1));\n\t\tspinePoles.push_back(Point3(0.2, 3.0, 0.1));\n\t\tspinePoles.push_back(Point3(0.1, 4.0, 0.0));\n\t\tspinePoles.push_back(Point3(0.0, 5.0, -0.1));\n\t\tspineKnots[0] = 0;\n\t\tspineKnots[1] = 1.0 / 3.0;\n\t\tspineKnots[2] = 2.0 / 3.0;\n\t\tspineKnots[3] = 1;\n\t\tspineMults.front() = 4;\n\t\tspineMults.back() = 4;\n\t\tstd::shared_ptr<Geom3BSplineCurve> spineCurve = std::make_shared<Geom3BSplineCurve>(spinePoles, spineKnots, spineMults, 3);\n\t\tTopoWire profile = MakeWire(MakeEdge(profileCurve)).Wire();\n\t\tTopoWire spine = MakeWire(MakeEdge(spineCurve)).Wire();\n\t\tMakePipeShell pipeShell(spine);\n\t\tpipeShell.Add(profile);\n\t\tpipeShell.SetMode(Frame3());\n\t\tTopoShape pipe = pipeShell.Shape();\n\t\tTopoExplorer ex(pipe, ShapeType::Face);\n\t\tTopoFace inputBasicFace = static_cast<const TopoFace&>(ex.Current());\n\t\tauto surf = TopoTool::Surface(inputBasicFace);\n\t\tbspSurf = NURBSAPIConvert::ToBSpline(surf);\n\t\tbreak;\n\t}\n\tcase 1:\n\t{\n\t\tArray2<Point3> poles(2, 5);\n\t\tpoles(0, 0) = Point3(0.0, 0.0, 0.0);\n\t\tpoles(0, 1) = Point3(1.0, -0.2, 0.1);\n\t\tpoles(0, 2) = Point3(2.0, 0.1, -0.1);\n\t\tpoles(0, 3) = Point3(3.0, -0.1, 0.0);\n\t\tpoles(0, 4) = Point3(4.0, 0.1, 0.2);\n\t\tpoles(1, 0) = Point3(0.0, 1.0, -0.1);\n\t\tpoles(1, 1) = Point3(1.0, 0.8, 0.0);\n\t\tpoles(1, 2) = Point3(2.0, 1.1, -0.2);\n\t\tpoles(1, 3) = Point3(3.0, 0.9, -0.1);\n\t\tpoles(1, 4) = Point3(4.0, 1.1, 0.1);\n\t\tstd::vector<double> vKnots(3);\n\t\tstd::vector<int> vMults(3, 1);\n\t\tvKnots[0] = 0;\n\t\tvKnots[1] = 0.5;\n\t\tvKnots[2] = 1;\n\t\tvMults.front() = 4;\n\t\tvMults.back() = 4;\n\t\tstd::vector<double> uKnots(2);\n\t\tstd::vector<int> uMults(2, 1);\n\t\tuKnots[0] = 0;\n\t\tuKnots[1] = 1;\n\t\tuMults.front() = 2;\n\t\tuMults.back() = 2;\n\t\tbspSurf = std::make_shared<Geom3BSplineSurface>(poles, uKnots, vKnots, uMults, vMults, 1, 3);\n\t\tTransformation3 trsf;\n\t\ttrsf.SetTranslationPart(Vector3(0.0, -6.0, 0.0));\n\t\tbspSurf->Transform(trsf);\n\t\tbreak;\n\t}\n\tcase 2:\n\t{\n\t\tstd::vector<Point3> profilePoles;\n\t\tstd::vector<double> profileKnots(4);\n\t\tstd::vector<int> profileMults(4, 1);\n\t\tprofilePoles.push_back(Point3(0.0, 0.0, 0.0));\n\t\tprofilePoles.push_back(Point3(1.0, -2.0, -3.0));\n\t\tprofilePoles.push_back(Point3(2.0, 1.0, 2.0));\n\t\tprofilePoles.push_back(Point3(3.0, -1.0, -1.0));\n\t\tprofilePoles.push_back(Point3(4.0, -3.0, 3.0));\n\t\tprofilePoles.push_back(Point3(5.0, 0.0, 1.0));\n\t\tprofileKnots[0] = 0;\n\t\tprofileKnots[1] = 1.0 / 3.0;\n\t\tprofileKnots[2] = 2.0 / 3.0;\n\t\tprofileKnots[3] = 1;\n\t\tprofileMults.front() = 4;\n\t\tprofileMults.back() = 4;\n\t\tstd::shared_ptr<Geom3BSplineCurve> profileCurve = std::make_shared<Geom3BSplineCurve>(profilePoles, profileKnots, profileMults, 3);\n\t\tstd::vector<Point3> spinePoles;\n\t\tstd::vector<double> spineKnots(4);\n\t\tstd::vector<int> spineMults(4, 1);\n\t\tspinePoles.push_back(Point3(0.0, 0.0, 0.0));\n\t\tspinePoles.push_back(Point3(-0.1, 1.0, -1.0));\n\t\tspinePoles.push_back(Point3(0.1, -2.0, -2.0));\n\t\tspinePoles.push_back(Point3(0.2, -3.0, -3.0));\n\t\tspinePoles.push_back(Point3(0.1, -4.0, -4.0));\n\t\tspinePoles.push_back(Point3(0.0, -2.5, -5.0));\n\t\tspinePoles.push_back(Point3(0.1, -1.0, -6.0));\n\t\tspinePoles.push_back(Point3(0.0, 0.0, -7.0));\n\t\tspineKnots[0] = 0;\n\t\tspineKnots[1] = 1.0 / 3.0;\n\t\tspineKnots[2] = 2.0 / 3.0;\n\t\tspineKnots[3] = 1;\n\t\tspineMults.front() = 6;\n\t\tspineMults.back() = 6;\n\t\tshared_ptr<Geom3BSplineCurve> spineCurve = std::make_shared<Geom3BSplineCurve>(spinePoles, spineKnots, spineMults, 5);\n\t\tTopoWire profile = MakeWire(MakeEdge(profileCurve)).Wire();\n\t\tTopoWire spine = MakeWire(MakeEdge(spineCurve)).Wire();\n\t\tMakePipeShell pipeShell(spine);\n\t\tpipeShell.Add(profile);\n\t\tpipeShell.SetMode(Frame3());\n\t\tTopoShape pipe = pipeShell.Shape();\n\t\tTopoExplorer ex(pipe, ShapeType::Face);\n\t\tTopoFace inputBasicFace = static_cast<const TopoFace&>(ex.Current());\n\t\tshared_ptr<Geom3Surface> surf = TopoTool::Surface(inputBasicFace);\n\t\tshared_ptr<Geom3BSplineSurface>  bspSurf = NURBSAPIConvert::ToBSpline(surf);\n\t\tTransformation3 trsf;\n\t\ttrsf.SetTranslationPart(Vector3(-6.0, 0.0, 0.0));\n\t\tbspSurf->Transform(trsf);\n\t\tbreak;\n\t}\n\t}\n\treturn bspSurf;\n}\nTEST_CASE(\"bug2: TestMatchTrimmedSurface \", \"[nurbs][Match][fixbug]\")\n{\n\tOUTPUT_DIRECTORY(nurbs, Match/bug590);\n\tstring filedir = INPUT_PATH_PREFIX\"./TestNURBS/TestMatchTrimmedSurface/\";\n\tTopoFace f1 = ReadBRepFace(filedir + \"surf1.brep\");\n\tTopoFace f2 = ReadBRepFace(filedir + \"surf2.brep\");\n\tPoint3 p1, p2;\n\tbool isSurf1TrimmedEdge = true;\n\tbool isSurf2TrimmedEdge = true;\n\tif (isSurf1TrimmedEdge)\n\t{\n\t\tp1 = ReadBRepPoint(filedir + \"tptS1.brep\");\n\t}\n\telse\n\t{\n\t\tp1 = ReadBRepPoint(filedir + \"nptS1.brep\");\n\t}\n\tif (isSurf2TrimmedEdge)\n\t{\n\t\tp2 = ReadBRepPoint(filedir + \"tptS2.brep\");\n\t}\n\telse\n\t{\n\t\tp2 = ReadBRepPoint(filedir + \"nptS2.brep\");\n\t}\n\tauto [d1, e1] = NearestEdge(p1, f1);\n\tauto [d2, e2] = NearestEdge(p2, f2);\n\tContinuityType cont = ContinuityType::G2;\n\tint otherEndCont = 0;\n\tNURBSMatchSurfConfig config;\n\tbool isPrecise = true;\n\tstd::vector<double> tol;\n\ttol.push_back(0.001);\n\ttol.push_back(0.1);\n\ttol.push_back(0.05);\n\tstd::vector<double> params(2, 1.0);\n\tauto result = NURBSAPIMatch::MatchFace(f1, e1, f2, e2, cont, otherEndCont, isPrecise, tol, params, false, config, config);\n\tdouble f = 0.0;\n\tdouble l = 0.0;\n\tshared_ptr< Geom3Curve > curve2 = TopoTool::Curve(e2, f, l);\n\tshared_ptr< Geom3Surface > src = TopoTool::Surface(f1);\n\tshared_ptr< Geom3Surface > surface = TopoTool::Surface(result[0]);\n\tdouble srcfpv = src->FirstVParameter();\n\tdouble fpv = surface->FirstVParameter();\n\tdouble lpv = surface->LastVParameter();\n\tshared_ptr<Geom3Curve> srcfv = src->VIso(srcfpv);\n\tshared_ptr<Geom3Curve> fv = surface->VIso(fpv);\n\tshared_ptr<Geom3Curve> lv = surface->VIso(lpv);\n\tint num = 1000;\n\tdouble resTol = 1e-3;\n\tdouble ratio = 0.1;\n\tdouble res1 = NurbsSampleCurve(num, resTol, srcfv, fv);\n\tdouble res2 = NurbsSampleCurve(num, resTol, curve2, lv);\n\tCHECK(res1 <= ratio);\n\tCHECK(res2 <= ratio);\n\tOCCTIO::OCCTTool::Write(MakeEdge(srcfv), outdir + \"srcfv.brep\");\n\tOCCTIO::OCCTTool::Write(MakeEdge(fv), outdir + \"fv.brep\");\n\tOCCTIO::OCCTTool::Write(MakeEdge(lv), outdir + \"lv.brep\");\n\tOCCTIO::OCCTTool::Write(f1, outdir + \"f1.brep\");\n\tOCCTIO::OCCTTool::Write(f2, outdir + \"f2.brep\");\n\tOCCTIO::OCCTTool::Write(MakeVertex(p1), outdir + \"p1.brep\");\n\tOCCTIO::OCCTTool::Write(MakeVertex(p2), outdir + \"p2.brep\");\n\tOCCTIO::OCCTTool::Write(e1, outdir + \"e1.brep\");\n\tOCCTIO::OCCTTool::Write(e2, outdir + \"e2.brep\");\n\tOCCTIO::OCCTTool::Write(result.front(), outdir + \"result.brep\");\n;\n\tSECTION(\"MatchCurve1\")\n\t{\n\t\tOUTPUT_DIRECTORY(nurbs, Match/bug725/MatchCurve/MatchCurve1);\n\t\tstring filedir = INPUT_PATH_PREFIX\"./TestNURBS/TestMatchCurve/\";\n\t\tshared_ptr<Geom3BSplineCurve> bsp1 = ReadBRepCurve(filedir + \"curve1.brep\");\n\t\tshared_ptr<Geom3BSplineCurve> bsp2 = ReadBRepCurve(filedir + \"curve2.brep\");\n\t\tshared_ptr<Geom3BSplineCurve> oldnbsp1 = NURBSAPIMatch::MatchCurve(ContinuityType::C0, bsp1, true, bsp2, true, 0); \n\t\tshared_ptr<Geom3BSplineCurve> oldnbsp2 = NURBSAPIMatch::MatchCurve(ContinuityType::C0, bsp1, false, bsp2, true, 0);\n\t\tshared_ptr<Geom3BSplineCurve> oldnbsp3 = NURBSAPIMatch::MatchCurve(ContinuityType::C0, bsp1, true, bsp2, false, 0);\n\t\tshared_ptr<Geom3BSplineCurve> oldnbsp4 = NURBSAPIMatch::MatchCurve(ContinuityType::C0, bsp1, false, bsp2, false, 0);\n\t\tshared_ptr<Geom3BSplineCurve> oldnbsp5 = NURBSAPIMatch::MatchCurve(ContinuityType::G1, bsp1, true, bsp2, true, 0);\n\t\tshared_ptr<Geom3BSplineCurve> oldnbsp6 = NURBSAPIMatch::MatchCurve(ContinuityType::G1, bsp1, false, bsp2, true, 0);\n\t\tshared_ptr<Geom3BSplineCurve> oldnbsp7 = NURBSAPIMatch::MatchCurve(ContinuityType::G1, bsp1, true, bsp2, false, 0);\n\t\tshared_ptr<Geom3BSplineCurve> oldnbsp8 = NURBSAPIMatch::MatchCurve(ContinuityType::G1, bsp1, false, bsp2, false, 0);\n\t\tshared_ptr<Geom3BSplineCurve> oldnbsp9 = NURBSAPIMatch::MatchCurve(ContinuityType::G2, bsp1, true, bsp2, true, 0);\n\t\tshared_ptr<Geom3BSplineCurve> oldnbsp10 = NURBSAPIMatch::MatchCurve(ContinuityType::G2, bsp1, false, bsp2, true, 0);\n\t\tshared_ptr<Geom3BSplineCurve> oldnbsp11 = NURBSAPIMatch::MatchCurve(ContinuityType::G2, bsp1, true, bsp2, false, 0);\n\t\tshared_ptr<Geom3BSplineCurve> oldnbsp12 = NURBSAPIMatch::MatchCurve(ContinuityType::G2, bsp1, false, bsp2, false, 0);\n\t\tshared_ptr<Geom3BSplineCurve> bsp1Inc = std::dynamic_pointer_cast<Geom3BSplineCurve>(bsp1->Copy());\n\t\tshared_ptr<Geom3BSplineCurve> bsp2Inc = std::dynamic_pointer_cast<Geom3BSplineCurve>(bsp2->Copy());\n\t\tbsp1Inc->IncreaseDegree(refDeg);\n\t\tbsp2Inc->IncreaseDegree(refDeg);\n\t\tshared_ptr<Geom3BSplineCurve> nbsp1 = NURBSAPIMatch::MatchCurve(ContinuityType::C0, bsp1Inc, true, bsp2Inc, true, 0); \n\t\tshared_ptr<Geom3BSplineCurve> nbsp2 = NURBSAPIMatch::MatchCurve(ContinuityType::C0, bsp1Inc, false, bsp2Inc, true, 0);\n\t\tshared_ptr<Geom3BSplineCurve> nbsp3 = NURBSAPIMatch::MatchCurve(ContinuityType::C0, bsp1Inc, true, bsp2Inc, false, 0);\n\t\tshared_ptr<Geom3BSplineCurve> nbsp4 = NURBSAPIMatch::MatchCurve(ContinuityType::C0, bsp1Inc, false, bsp2Inc, false, 0);\n\t\tshared_ptr<Geom3BSplineCurve> nbsp5 = NURBSAPIMatch::MatchCurve(ContinuityType::G1, bsp1Inc, true, bsp2Inc, true, 0);\n\t\tshared_ptr<Geom3BSplineCurve> nbsp6 = NURBSAPIMatch::MatchCurve(ContinuityType::G1, bsp1Inc, false, bsp2Inc, true, 0);\n\t\tshared_ptr<Geom3BSplineCurve> nbsp7 = NURBSAPIMatch::MatchCurve(ContinuityType::G1, bsp1Inc, true, bsp2Inc, false, 0);\n\t\tshared_ptr<Geom3BSplineCurve> nbsp8 = NURBSAPIMatch::MatchCurve(ContinuityType::G1, bsp1Inc, false, bsp2Inc, false, 0);\n\t\tshared_ptr<Geom3BSplineCurve> nbsp9 = NURBSAPIMatch::MatchCurve(ContinuityType::G2, bsp1Inc, true, bsp2Inc, true, 0);\n\t\tshared_ptr<Geom3BSplineCurve> nbsp10 = NURBSAPIMatch::MatchCurve(ContinuityType::G2, bsp1Inc, false, bsp2Inc, true, 0);\n\t\tshared_ptr<Geom3BSplineCurve> nbsp11 = NURBSAPIMatch::MatchCurve(ContinuityType::G2, bsp1Inc, true, bsp2Inc, false, 0);\n\t\tshared_ptr<Geom3BSplineCurve> nbsp12 = NURBSAPIMatch::MatchCurve(ContinuityType::G2, bsp1Inc, false, bsp2Inc, false, 0);\n\t\tdouble res1 = NurbsSampleCurve(num, refTol, oldnbsp1, nbsp1);\n\t\tdouble res2 = NurbsSampleCurve(num, refTol, oldnbsp2, nbsp2);\n\t\tdouble res3 = NurbsSampleCurve(num, refTol, oldnbsp3, nbsp3);\n\t\tdouble res4 = NurbsSampleCurve(num, refTol, oldnbsp4, nbsp4);\n\t\tdouble res5 = NurbsSampleCurve(num, refTol, oldnbsp5, nbsp5);\n\t\tdouble res6 = NurbsSampleCurve(num, refTol, oldnbsp6, nbsp6);\n\t\tdouble res7 = NurbsSampleCurve(num, refTol, oldnbsp7, nbsp7);\n\t\tdouble res8 = NurbsSampleCurve(num, refTol, oldnbsp8, nbsp8);\n\t\tdouble res9 = NurbsSampleCurve(num, refTol, oldnbsp9, nbsp9);\n\t\tdouble res10 = NurbsSampleCurve(num, refTol, oldnbsp10, nbsp10);\n\t\tdouble res11 = NurbsSampleCurve(num, refTol, oldnbsp11, nbsp11);\n\t\tdouble res12 = NurbsSampleCurve(num, refTol, oldnbsp12, nbsp12);\n\t\tOCCTIO::OCCTTool::Write(MakeEdge(bsp1), outdir + \"bsp1.brep\");\n\t\tOCCTIO::OCCTTool::Write(MakeEdge(bsp2), outdir + \"bsp2.brep\");\n\t\tOCCTIO::OCCTTool::Write(MakeEdge(bsp1Inc), outdir + \"bsp1Inc.brep\");\n\t\tOCCTIO::OCCTTool::Write(MakeEdge(bsp2Inc), outdir + \"bsp2Inc.brep\");\n\t\tOCCTIO::OCCTTool::Write(MakeEdge(oldnbsp1), outdir + \"oldresult.brep\");\n\t\tOCCTIO::OCCTTool::Write(MakeEdge(nbsp1), outdir + \"result.brep\");\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static std::shared_ptr<Geom3BSplineSurface> MakeSurf(const std::vector<std::shared_ptr<Geom3BSplineCurve>>& boundCurves, bool isParallel)\t @return The surface\n\t @param isParallel Are the result surface isocurves parallel to boundary curves\n\t @param boundCurves The boundary curves\n\t @brief Given 2 or 3 or 4 boundaries, make a surface\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <nurbs/NURBSAPIMakeNURBSFromBoundaries.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeFace.hpp>\n#include <topology/BRepExtremaDistShapeShape.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <topology/TopoExplorerTool.hpp>\n#include<catch.hpp>\n#include<testHelper.h>\n#include <nurbs/NURBSAPIMakeNURBSFromBoundaries.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeFace.hpp>\n#include <topology/BRepExtremaDistShapeShape.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <topology/TopoExplorerTool.hpp>\n;\n\tSECTION(\"TestMakeSurf\")\n\t{\n\t\tOUTPUT_DIRECTORY(nurbs, MakeNURBSFromBoundaries);\n\t\tstd::shared_ptr<Geom3BSplineCurve> vbsp1, vbsp2, hbsp1, hbsp2;\n\t\t{\n\t\t\tint deg = 3;\n\t\t\tstd::vector<Point3> poles;\n\t\t\tpoles.push_back(Point3(0.0, -1.0, 0.1));\n\t\t\tpoles.push_back(Point3(0.07, -0.7, 0.2));\n\t\t\tpoles.push_back(Point3(0.1, -0.3, 0.1));\n\t\t\tpoles.push_back(Point3(0.12, 0.0, -0.1));\n\t\t\tpoles.push_back(Point3(0.20, 0.3, -0.2));\n\t\t\tpoles.push_back(Point3(0.07, 0.7, -0.3));\n\t\t\tpoles.push_back(Point3(0.0, 1.0, 0.0));\n\t\t\tint nknots = static_cast<int>(poles.size()) - deg + 1;\n\t\t\tstd::vector<double> knots(nknots);\n\t\t\tfor (int i = 0; i < nknots; i++)\n\t\t\t{\n\t\t\t\tknots[i] = (double)i / (double)(nknots - 1.0);\n\t\t\t}\n\t\t\tstd::vector<int> mults(nknots, 1);\n\t\t\tmults.front() = deg + 1;\n\t\t\tmults.back() = deg + 1;\n\t\t\tvbsp1 = std::make_shared<Geom3BSplineCurve>(poles, knots, mults, deg);\n\t\t}\n\t\t{\n\t\t\tint deg = 3;\n\t\t\tstd::vector<Point3> poles;\n\t\t\tpoles.push_back(Point3(4.0, -1.5, -0.1));\n\t\t\tpoles.push_back(Point3(4.1, -1.3, -0.2));\n\t\t\tpoles.push_back(Point3(4.15, -0.8, -0.1));\n\t\t\tpoles.push_back(Point3(3.83, -0.2, 0.1));\n\t\t\tpoles.push_back(Point3(3.48, 0.1, 0.2));\n\t\t\tpoles.push_back(Point3(3.0, 1.0, 0.1));\n\t\t\tint nknots = static_cast<int>(poles.size()) - deg + 1;\n\t\t\tstd::vector<double> knots(nknots);\n\t\t\tfor (int i = 0; i < nknots; i++)\n\t\t\t{\n\t\t\t\tknots[i] = (double)i / (double)(nknots - 1.0);\n\t\t\t}\n\t\t\tstd::vector<int> mults(nknots, 1);\n\t\t\tmults.front() = deg + 1;\n\t\t\tmults.back() = deg + 1;\n\t\t\tvbsp2 = std::make_shared<Geom3BSplineCurve>(poles, knots, mults, deg);\n\t\t}\n\t\t{\n\t\t\tint deg = 3;\n\t\t\tstd::vector<Point3> poles;\n\t\t\tpoles.push_back(Point3(0.0, -1.0, 0.1));\n\t\t\tpoles.push_back(Point3(0.9, -1.5, -0.1));\n\t\t\tpoles.push_back(Point3(3.0, -1.8, 0.1));\n\t\t\tpoles.push_back(Point3(4.0, -1.5, -0.1));\n\t\t\tint nknots = static_cast<int>(poles.size()) - deg + 1;\n\t\t\tstd::vector<double> knots(nknots);\n\t\t\tfor (int i = 0; i < nknots; i++)\n\t\t\t{\n\t\t\t\tknots[i] = (double)i / (double)(nknots - 1.0);\n\t\t\t}\n\t\t\tstd::vector<int> mults(nknots, 1);\n\t\t\tmults.front() = deg + 1;\n\t\t\tmults.back() = deg + 1;\n\t\t\thbsp1 = std::make_shared<Geom3BSplineCurve>(poles, knots, mults, deg);\n\t\t}\n\t\t{\n\t\t\tint deg = 3;\n\t\t\tstd::vector<Point3> poles;\n\t\t\tpoles.push_back(Point3(0.0, 1.0, 0.0));\n\t\t\tpoles.push_back(Point3(0.9, 0.15, -0.1));\n\t\t\tpoles.push_back(Point3(1.7, 0.05, 0.1));\n\t\t\tpoles.push_back(Point3(2.7, 0.3, -0.1));\n\t\t\tpoles.push_back(Point3(3.0, 1.0, 0.1));\n\t\t\tint nknots = static_cast<int>(poles.size()) - deg + 1;\n\t\t\tstd::vector<double> knots(nknots);\n\t\t\tfor (int i = 0; i < nknots; i++)\n\t\t\t{\n\t\t\t\tknots[i] = (double)i / (double)(nknots - 1.0);\n\t\t\t}\n\t\t\tstd::vector<int> mults(nknots, 1);\n\t\t\tmults.front() = deg + 1;\n\t\t\tmults.back() = deg + 1;\n\t\t\thbsp2 = std::make_shared<Geom3BSplineCurve>(poles, knots, mults, deg);\n\t\t}\n\t\tstd::vector<std::shared_ptr<Geom3BSplineCurve>> curves;\n\t\tcurves.push_back(vbsp1);\n\t\tcurves.push_back(vbsp2);\n\t\tcurves.push_back(hbsp1);\n\t\tcurves.push_back(hbsp2);\n\t\tauto surf = NURBSAPIMakeNURBSFromBoundaries::MakeSurf(curves, false);\n\t\tint nums = GetTopoCount(MakeFace(surf, 0.0), ShapeType::Face);\n\t\tCHECK(nums == 1);\n\t\tdouble fpu = surf->FirstUParameter();\n\t\tdouble fpv = surf->FirstVParameter();\n\t\tdouble lpu = surf->LastUParameter();\n\t\tdouble lpv = surf->LastVParameter();\n\t\tshared_ptr<Geom3Curve> fu = surf->UIso(fpu);\n\t\tshared_ptr<Geom3Curve> fv = surf->VIso(fpv);\n\t\tshared_ptr<Geom3Curve> lu = surf->UIso(lpu);\n\t\tshared_ptr<Geom3Curve> lv = surf->VIso(lpv);\n\t\tPoint3 p1, p2, p3, p4, p5, p6, p7, p8;\n\t\tdouble fusp = fu->FirstParameter();\n\t\tdouble fuep = fu->LastParameter();\n\t\tdouble fvsp = fv->FirstParameter();\n\t\tdouble fvep = fv->LastParameter();\n\t\tdouble lusp = lu->FirstParameter();\n\t\tdouble luep = lu->LastParameter();\n\t\tdouble lvsp = lv->FirstParameter();\n\t\tdouble lvep = lv->LastParameter();\n\t\tPoint3 p11, p22, p33, p44, p55, p66, p77, p88;\n\t\tdouble fusp2 = vbsp1->FirstParameter();\n\t\tdouble fuep2 = vbsp1->LastParameter();\n\t\tdouble fvsp2 = hbsp1->FirstParameter();\n\t\tdouble fvep2 = hbsp1->LastParameter();\n\t\tdouble lusp2 = vbsp2->FirstParameter();\n\t\tdouble luep2 = vbsp2->LastParameter();\n\t\tdouble lvsp2 = hbsp2->FirstParameter();\n\t\tdouble lvep2 = hbsp2->LastParameter();\n\t\tfu->D0(fusp, p1);\n\t\tfu->D0(fuep, p2);\n\t\tfv->D0(fvsp, p3);\n\t\tfv->D0(fvep, p4);\n\t\tlu->D0(lusp, p5);\n\t\tlu->D0(luep, p6);\n\t\tlv->D0(lvsp, p7);\n\t\tlv->D0(lvep, p8);\n\t\tvbsp1->D0(fusp2, p11);\n\t\tvbsp1->D0(fuep2, p22);\n\t\thbsp1->D0(fvsp2, p33);\n\t\thbsp1->D0(fvep2, p44);\n\t\tvbsp2->D0(lusp2, p55);\n\t\tvbsp2->D0(luep2, p66);\n\t\thbsp2->D0(lvsp2, p77);\n\t\thbsp2->D0(lvep2, p88);\n\t\tdouble refTol = 5e-3;\n\t\tCHECK(abs(p1.X() - p11.X()) <= refTol);\n\t\tCHECK(abs(p1.Y() - p11.Y()) <= refTol);\n\t\tCHECK(abs(p1.Z() - p11.Z()) <= refTol);\n\t\tCHECK(abs(p2.X() - p22.X()) <= refTol);\n\t\tCHECK(abs(p2.Y() - p22.Y()) <= refTol);\n\t\tCHECK(abs(p2.Z() - p22.Z()) <= refTol);\n\t\tCHECK(abs(p3.X() - p33.X()) <= refTol);\n\t\tCHECK(abs(p3.Y() - p33.Y()) <= refTol);\n\t\tCHECK(abs(p3.Z() - p33.Z()) <= refTol);\n\t\tCHECK(abs(p4.X() - p44.X()) <= refTol);\n\t\tCHECK(abs(p4.Y() - p44.Y()) <= refTol);\n\t\tCHECK(abs(p4.Z() - p44.Z()) <= refTol);\n\t\tCHECK(abs(p5.X() - p55.X()) <= refTol);\n\t\tCHECK(abs(p5.Y() - p55.Y()) <= refTol);\n\t\tCHECK(abs(p5.Z() - p55.Z()) <= refTol);\n\t\tCHECK(abs(p6.X() - p66.X()) <= refTol);\n\t\tCHECK(abs(p6.Y() - p66.Y()) <= refTol);\n\t\tCHECK(abs(p6.Z() - p66.Z()) <= refTol);\n\t\tCHECK(abs(p7.X() - p77.X()) <= refTol);\n\t\tCHECK(abs(p7.Y() - p77.Y()) <= refTol);\n\t\tCHECK(abs(p7.Z() - p77.Z()) <= refTol);\n\t\tCHECK(abs(p8.X() - p88.X()) <= refTol);\n\t\tCHECK(abs(p8.Y() - p88.Y()) <= refTol);\n\t\tCHECK(abs(p8.Z() - p88.Z()) <= refTol);\n\t\tint num = 1000;\n\t\tdouble tol = 5e-3;\n\t\tdouble ratio = 0.1;\n\t\tdouble res1 = NurbsSampleCurve(num, tol, vbsp1, fu);\n\t\tdouble res2 = NurbsSampleCurve(num, tol, vbsp2, lu);\n\t\tdouble res3 = NurbsSampleCurve(num, tol, hbsp1, fv);\n\t\tdouble res4 = NurbsSampleCurve(num, tol, hbsp2, lv);\n\t\tCHECK(res1 <= ratio);\n\t\tCHECK(res2 <= ratio); \n\t\tCHECK(res3 <= ratio);\n\t\tCHECK(res4 <= ratio);\n\t\tOCCTIO::OCCTTool::Write(MakeEdge(vbsp1), outdir + \"curve1.brep\");\n\t\tOCCTIO::OCCTTool::Write(MakeEdge(vbsp2), outdir + \"curve2.brep\");\n\t\tOCCTIO::OCCTTool::Write(MakeEdge(hbsp1), outdir + \"curve3.brep\");\n\t\tOCCTIO::OCCTTool::Write(MakeEdge(hbsp2), outdir + \"curve4.brep\");\n\t\tOCCTIO::OCCTTool::Write(MakeEdge(fu), outdir + \"fu.brep\");\n\t\tOCCTIO::OCCTTool::Write(MakeEdge(lu), outdir + \"lu.brep\");\n\t\tOCCTIO::OCCTTool::Write(MakeEdge(fv), outdir + \"fv.brep\");\n\t\tOCCTIO::OCCTTool::Write(MakeEdge(lv), outdir + \"lv.brep\");\n\t\tOCCTIO::OCCTTool::Write(MakeFace(surf, 0.0), outdir + \"result.brep\");\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static std::shared_ptr<Geom3BSplineSurface> MakeLoft(const std::vector<NURBSCurveSection>& sections, bool isClosedLofting = false, NURBSLoftSurfaceStype stype = NURBSLoftSurfaceStype::Standard, ApproxParameterizationType ptype = ApproxParameterizationType::Centripetal)\t @return The loft surface\n\t @param ptype Parameterization type\n\t @param stype The type of surface building such as interpolate, approx. It determines the error between surface and curves.\n\t @param isClosedLofting Is surface closed\n\t @param sections Curves with begin parameter and is reverse flag\n\t @brief Make lofting (section curves -> a surface)\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <nurbs/NURBSAPILoft.hpp>\n#include <geometry/Geom3BSplineCurve.hpp>\n#include <geometry/Geom3BSplineSurface.hpp>\n#include <nurbs/NURBSAPICurveNetworkSurface.hpp>\n#include <topology/TopoEdge.hpp>\n#include <topology/TopoTool.hpp>\n#include <nurbs/NURBSAPILoft.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeFace.hpp>\n#include <topology/BRepExtremaDistShapeShape.hpp>\n#include <geometry/GeomAPIProjectPointOnSurface.hpp>\nusing namespace std;\ndouble NurbsSampleCurveOnSurface1(int num, double tol, const shared_ptr<Geom3Curve>& curve, const shared_ptr<Geom3Surface>& surf)\n{\n\tconst int nsample = num;\n\tdouble fp1 = curve->FirstParameter();\n\tdouble lp1 = curve->LastParameter();\n\tdouble delta1 = (lp1 - fp1) / nsample;\n\tPoint3 p;\n\tint n = 0;\n\tfor (int i = 0; i < nsample; i++)\n\t{\n\t\tdouble t1 = fp1 + i * delta1;\n\t\tcurve->D0(t1, p);\n\t\tGeomAPIProjectPointOnSurface projector(p, surf);\n\t\tdouble dis = projector.LowerDistance();\n\t\tif (dis <= tol)\n\t\t{\n\t\t\tn++;\n\t\t}\n\t}\n\tdouble res = 1.0 * (num - n) / num;\n\treturn res;\n}\nvector< shared_ptr<Geom3BSplineCurve>> ConstructBSplineCurve1()\n{\n\tvector<shared_ptr<Geom3BSplineCurve>> vec;\n\tstd::vector<bool> isVRational(4, true);\n\tisVRational[1] = false;\n\tstd::shared_ptr<Geom3BSplineCurve> vbsp1, vbsp2, vbsp3, vbsp4;\n\t{\n\t\tint deg = 3;\n\t\tstd::vector<Point3> poles;\n\t\tpoles.push_back(Point3(0.0, -1.0, 0.1));\n\t\tpoles.push_back(Point3(0.07, -0.7, 0.2));\n\t\tpoles.push_back(Point3(0.1, -0.3, 0.1));\n\t\tpoles.push_back(Point3(0.12, 0.0, -0.1));\n\t\tpoles.push_back(Point3(0.20, 0.3, -0.2));\n\t\tpoles.push_back(Point3(0.07, 0.7, -0.3));\n\t\tpoles.push_back(Point3(0.0, 1.0, 0.0));\n\t\tstd::vector<double> weights;\n\t\tweights.push_back(0.5);\n\t\tweights.push_back(1.5);\n\t\tweights.push_back(1.2);\n\t\tweights.push_back(0.5);\n\t\tweights.push_back(0.7);\n\t\tweights.push_back(0.9);\n\t\tweights.push_back(0.4);\n\t\tint nknots = static_cast<int>(poles.size()) - deg + 1;\n\t\tstd::vector<double> knots(nknots);\n\t\tfor (int i = 0; i < nknots; i++)\n\t\t{\n\t\t\tknots[i] = (double)i / (double)(nknots - 1.0);\n\t\t}\n\t\tstd::vector<int> mults(nknots, 1);\n\t\tmults.front() = deg + 1;\n\t\tmults.back() = deg + 1;\n\t\tif (isVRational[0])\n\t\t{\n\t\t\tvbsp1 = std::make_shared<Geom3BSplineCurve>(poles, weights, knots, mults, deg);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvbsp1 = std::make_shared<Geom3BSplineCurve>(poles, knots, mults, deg);\n\t\t}\n\t}\n\t{\n\t\tint deg = 3;\n\t\tstd::vector<Point3> poles;\n\t\tpoles.push_back(Point3(2.0, -2.0, -0.1));\n\t\tpoles.push_back(Point3(2.1, -1.3, -0.2));\n\t\tpoles.push_back(Point3(2.15, -0.8, -0.1));\n\t\tpoles.push_back(Point3(1.83, -0.2, 0.1));\n\t\tpoles.push_back(Point3(1.48, 0.1, 0.2));\n\t\tpoles.push_back(Point3(1.0, 1.0, 0.1));\n\t\tstd::vector<double> weights;\n\t\tweights.push_back(0.5);\n\t\tweights.push_back(1.5);\n\t\tweights.push_back(1.2);\n\t\tweights.push_back(0.5);\n\t\tweights.push_back(1.2);\n\t\tweights.push_back(0.5);\n\t\tint nknots = static_cast<int>(poles.size()) - deg + 1;\n\t\tstd::vector<double> knots(nknots);\n\t\tfor (int i = 0; i < nknots; i++)\n\t\t{\n\t\t\tknots[i] = (double)i / (double)(nknots - 1.0);\n\t\t}\n\t\tstd::vector<int> mults(nknots, 1);\n\t\tmults.front() = deg + 1;\n\t\tmults.back() = deg + 1;\n\t\tif (isVRational[1])\n\t\t{\n\t\t\tvbsp2 = std::make_shared<Geom3BSplineCurve>(poles, weights, knots, mults, deg);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvbsp2 = std::make_shared<Geom3BSplineCurve>(poles, knots, mults, deg);\n\t\t}\n\t}\n\t{\n\t\tint deg = 3;\n\t\tstd::vector<Point3> poles;\n\t\tpoles.push_back(Point3(3.0, -2.0, 0.1));\n\t\tpoles.push_back(Point3(3.07, -1.3, 0.2));\n\t\tpoles.push_back(Point3(3.1, -0.3, 0.1));\n\t\tpoles.push_back(Point3(3.12, 0.0, -0.1));\n\t\tpoles.push_back(Point3(3.0, 0.3, -0.2));\n\t\tpoles.push_back(Point3(2.57, 0.7, -0.3));\n\t\tpoles.push_back(Point3(2.2, 1.0, 0.0));\n\t\tstd::vector<double> weights;\n\t\tweights.push_back(0.7);\n\t\tweights.push_back(1.5);\n\t\tweights.push_back(1.2);\n\t\tweights.push_back(0.5);\n\t\tweights.push_back(1.2);\n\t\tweights.push_back(0.8);\n\t\tweights.push_back(1.3);\n\t\tint nknots = static_cast<int>(poles.size()) - deg + 1;\n\t\tstd::vector<double> knots(nknots);\n\t\tfor (int i = 0; i < nknots; i++)\n\t\t{\n\t\t\tknots[i] = (double)i / (double)(nknots - 1.0);\n\t\t}\n\t\tstd::vector<int> mults(nknots, 1);\n\t\tmults.front() = deg + 1;\n\t\tmults.back() = deg + 1;\n\t\tif (isVRational[2])\n\t\t{\n\t\t\tvbsp3 = std::make_shared<Geom3BSplineCurve>(poles, weights, knots, mults, deg);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvbsp3 = std::make_shared<Geom3BSplineCurve>(poles, knots, mults, deg);\n\t\t}\n\t}\n\t{\n\t\tint deg = 3;\n\t\tstd::vector<Point3> poles;\n\t\tpoles.push_back(Point3(4.0, -1.5, -0.1));\n\t\tpoles.push_back(Point3(4.1, -1.3, -0.2));\n\t\tpoles.push_back(Point3(4.15, -0.8, -0.1));\n\t\tpoles.push_back(Point3(3.83, -0.2, 0.1));\n\t\tpoles.push_back(Point3(3.48, 0.1, 0.2));\n\t\tpoles.push_back(Point3(3.0, 1.0, 0.1));\n\t\tstd::vector<double> weights;\n\t\tweights.push_back(1.5);\n\t\tweights.push_back(0.7);\n\t\tweights.push_back(1.2);\n\t\tweights.push_back(0.8);\n\t\tweights.push_back(1.2);\n\t\tweights.push_back(1.3);\n\t\tint nknots = static_cast<int>(poles.size()) - deg + 1;\n\t\tstd::vector<double> knots(nknots);\n\t\tfor (int i = 0; i < nknots; i++)\n\t\t{\n\t\t\tknots[i] = (double)i / (double)(nknots - 1.0);\n\t\t}\n\t\tstd::vector<int> mults(nknots, 1);\n\t\tmults.front() = deg + 1;\n\t\tmults.back() = deg + 1;\n\t\tif (isVRational[3])\n\t\t{\n\t\t\tvbsp4 = std::make_shared<Geom3BSplineCurve>(poles, weights, knots, mults, deg);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvbsp4 = std::make_shared<Geom3BSplineCurve>(poles, knots, mults, deg);\n\t\t}\n\t}\n\tvec.push_back(vbsp1);\n\tvec.push_back(vbsp2);\n\tvec.push_back(vbsp3);\n\tvec.push_back(vbsp4);\n\treturn vec;\n}\nTEST_CASE(\"bug1: MakeLoft \", \"[nurbs][Loft][fixbug]\")\n{\n\tOUTPUT_DIRECTORY(nurbs, Loft/bug570);\n\tstd::vector<NURBSCurveSection> sections;\n\tstd::vector<shared_ptr<Geom3BSplineCurve>> curve;\n\tint deg = 3;\n\tdouble sqrt32 = std::sqrt(3.0) / 2.0;\n\tstd::vector<Point3> poles;\n\tpoles.push_back(Point3(-4.0, 0.0, 1.0));\n\tpoles.push_back(Point3(-3.0, 0.0, -0.5));\n\tpoles.push_back(Point3(sqrt32 - 4.0, 0.0, 0.5));\n\tpoles.push_back(Point3(-4.0, 0.0, 1.0));\n\tpoles.push_back(Point3(-sqrt32 - 4, 0.0, 0.5));\n\tpoles.push_back(Point3(-sqrt32 - 4, 0.0, -0.5));\n\tstd::vector<double> weights;\n\tweights.push_back(1.1);\n\tweights.push_back(0.8);\n\tweights.push_back(1.7);\n\tweights.push_back(1.3);\n\tweights.push_back(0.9);\n\tweights.push_back(1.0);\n\tstd::vector<double> knots(static_cast<int>(poles.size()) + 1);\n\tfor (int i = 0; i < static_cast<int>(knots.size()); i++)\n\t{\n\t\tknots[i] = (double)i / (double)(static_cast<int>(knots.size()) - 1);\n\t}\n\tknots[1] += 0.1;\n\tstd::vector<int> mults(knots.size(), 1);\n\tstd::shared_ptr<Geom3BSplineCurve> basicCurve = std::make_shared<Geom3BSplineCurve>(poles, weights, knots, mults, deg, true);\n\tint nsec = 7;\n\tfor (int i = 0; i < nsec; i++)\n\t{\n\t\tauto crCurve = std::dynamic_pointer_cast<Geom3BSplineCurve>(basicCurve->Copy());\n\t\tint pid = i % crCurve->NPoles();\n\t\tcrCurve->SetPole(pid, Point3(crCurve->Pole(pid).Coord() + Coord3(0.1, 0.1, 0.1)));\n\t\tTransformation3 trans;\n\t\ttrans.SetRotation(Axis3(Point3(0.0, 0.0, 0.0), Direction3(0.0, 0.0, 1.0)), 2 * M_PI * i / (double)nsec);\n\t\tcrCurve->Transform(trans);\n\t\tsections.push_back(NURBSCurveSection(crCurve, i * 0.2, false));\n\t\tOCCTIO::OCCTTool::Write(MakeEdge(crCurve), outdir + \"crCurve\" + to_string(i) + \".brep\");\n\t\tcurve.push_back(crCurve);\n\t}\n\tbool isClosedLofting = true;\n\tNURBSLoftSurfaceStype stype = NURBSLoftSurfaceStype::Standard;\n\tApproxParameterizationType ptype = ApproxParameterizationType::Centripetal;\n\tshared_ptr<Geom3BSplineSurface> surf = NURBSAPILoft::MakeLoft(sections, isClosedLofting, stype, ptype);\n\tPoint3 p;\n\tsurf->D0(surf->FirstUParameter(), surf->FirstVParameter(), p);\n\tOCCTIO::OCCTTool::Write(MakeFace(surf, 0.0), outdir + \"surf.brep\");\n\tint num = 1000;\n\tdouble tol = 0.1;\n\tdouble ratio = 0.1;\n\tdouble res1 = NurbsSampleCurveOnSurface1(num, tol, curve[0], surf);\n\tdouble res2 = NurbsSampleCurveOnSurface1(num, tol, curve[1], surf);\n\tdouble res3 = NurbsSampleCurveOnSurface1(num, tol, curve[2], surf);\n\tdouble res4 = NurbsSampleCurveOnSurface1(num, tol, curve[3], surf);\n\tdouble res5 = NurbsSampleCurveOnSurface1(num, tol, curve[4], surf);\n\tdouble res6 = NurbsSampleCurveOnSurface1(num, tol, curve[5], surf);\n\tdouble res7 = NurbsSampleCurveOnSurface1(num, tol, curve[6], surf);\n\tCHECK(res1 <= ratio);\n\tCHECK(res2 <= ratio);\n\tCHECK(res3 <= ratio);\n\tCHECK(res4 <= ratio);\n\tCHECK(res5 <= ratio);\n\tCHECK(res6 <= ratio);\n\tCHECK(res7 <= ratio);\n\tTopoEdge edge1 = MakeEdge(curve[0]);\n\tTopoEdge edge2 = MakeEdge(curve[1]);\n\tTopoEdge edge3 = MakeEdge(curve[2]);\n\tTopoEdge edge4 = MakeEdge(curve[3]);\n\tTopoEdge edge5 = MakeEdge(curve[4]);\n\tTopoEdge edge6 = MakeEdge(curve[5]);\n\tTopoEdge edge7 = MakeEdge(curve[6]);\n\tTopoShape surface = MakeFace(surf, 0.0);\n\tBRepExtremaDistShapeShape dist1(edge1, surface);\n\tBRepExtremaDistShapeShape dist2(edge2, surface);\n\tBRepExtremaDistShapeShape dist3(edge3, surface);\n\tBRepExtremaDistShapeShape dist4(edge4, surface);\n\tBRepExtremaDistShapeShape dist5(edge5, surface);\n\tBRepExtremaDistShapeShape dist6(edge6, surface);\n\tBRepExtremaDistShapeShape dist7(edge7, surface);\n\tdouble tolgen = 1e-4;\n\tCHECK(dist1.Value() < tolgen);\n\tCHECK(dist2.Value() < tolgen);\n\tCHECK(dist3.Value() < tolgen);\n\tCHECK(dist4.Value() < tolgen);\n\tCHECK(dist5.Value() < tolgen);\n\tCHECK(dist6.Value() < tolgen);\n\tCHECK(dist7.Value() < tolgen);\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static std::pair<NURBSSweepStatus, std::vector<std::shared_ptr<Geom3BSplineSurface>>> SweepWithTwoTangencySurfaces(const std::shared_ptr<Geom3BSplineCurve>& spine, const std::shared_ptr<Geom3BSplineSurface>& tangencySurface1, const std::shared_ptr<Geom3BSplineSurface>& tangencySurface2, double spineLeftBound, double spineRightBound),\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <filesystem>\n#include <fstream>\n#include <random>\n#include <sstream>\n#include <nurbs/NURBSAPIGetGeometry.hpp>\n#include <nurbs/NURBSAPIConicalSweep.hpp>\n#include <boolean/BoolBRepCut.hpp>\n#include <common/CartesianCoordinateSystem.hpp>\n#include <common/IndexMap.hpp>\n#include <common/QuaternionT.hpp>\n#include <geomAlgo/LawBSpline.hpp>\n#include <geomAlgo/LawConstant.hpp>\n#include <nurbs/NURBSAPISmooth.hpp>\n#include <geomAlgo/MakeConic2FromConstraints.hpp>\n#include <geometry/Adaptor3CurveOnSurface.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/AdaptorGeom3Surface.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2Circle.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/Geom2Hyperbola.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3BSplineCurve.hpp>\n#include <geometry/Geom3BSplineSurface.hpp>\n#include <geometry/Geom3Circle.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\n#include <geometry/Geom3Plane.hpp>\n#include <geometry/Geom3SphericalSurface.hpp>\n#include <geometry/Geom3Surface.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include <geometry/Geom3TrimmedSurface.hpp>\n#include <geometry/GeomAPIExtremaCurveCurve3.hpp>\n#include <geometry/GeomAPIProjectPointOnCurve2.hpp>\n#include <geometry/GeomAPIProjectPointOnCurve3.hpp>\n#include <geometry/GeomAPIProjectPointOnSurface.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/GlobalProperty.hpp>\n#include <healing/ShapeFixTool.hpp>\n#include <io/STLTool.hpp>\n#include <math/Sphere.hpp>\n#include <math/TriangularMesh.hpp>\n#include <modeling/CopyShape.hpp>\n#include <modeling/MakeBox.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeFace.hpp>\n#include <modeling/MakePrism.hpp>\n#include <modeling/MakeRevol.hpp>\n#include <modeling/MakeShapeTool.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <modeling/MakeWire.hpp>\n#include <modeling/TransformShape.hpp>\n#include <nurbs/NURBSAPIApprox.hpp>\n#include <nurbs/NURBSAPIBuildCurve.hpp>\n#include <nurbs/NURBSAPICircularSweep.hpp>\n#include <nurbs/NURBSAPIConvert.hpp>\n#include <nurbs/NURBSAPICurveNetworkSurface.hpp>\n#include <nurbs/NURBSAPIExplicitSweep.hpp>\n#include <nurbs/NURBSAPIExplode.hpp>\n#include <nurbs/NURBSAPIExtend.hpp>\n#include <nurbs/NURBSAPIInterpolate.hpp>\n#include <nurbs/NURBSAPIJoin.hpp>\n#include <nurbs/NURBSAPILinearSweep.hpp>\n#include <nurbs/NURBSAPILoft.hpp>\n#include <nurbs/NURBSAPIMakeNURBSFromBoundaries.hpp>\n#include <nurbs/NURBSAPIMatch.hpp>\n#include <nurbs/NURBSAPIModifyEndToPlane.hpp>\n#include <nurbs/NURBSAPIOffsetCurveOnSurface.hpp>\n#include <nurbs/NURBSAPIProject.hpp>\n#include <nurbs/NURBSAPIRebuild.hpp>\n#include <nurbs/NURBSAPIReplaceEdge.hpp>\n#include <nurbs/NURBSAPISweep.hpp>\n#include <nurbs/NURBSAPISweep2.hpp>\n#include <nurbs/NURBSAPISweepRotation.hpp>\n#include <nurbs/NURBSAPITrim.hpp>\n#include <nurbs/NURBSAPIUntrim.hpp>\n#include <nurbs/NURBSLinearSweepWithDraftDirectionLength.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <offset/MakePipe.hpp>\n#include <offset/MakePipeShell.hpp>\n#include <topology/BRepAdaptorCurve2.hpp>\n#include <topology/BRepAdaptorCurve3.hpp>\n#include <topology/BRepAdaptorSurface.hpp>\n#include <topology/BRepGlobalProperty.hpp>\n#include <topology/BRepTool.hpp>\n#include <topology/TopoBuilder.hpp>\n#include <topology/TopoCompound.hpp>\n#include <topology/TopoEdge.hpp>\n#include <topology/TopoExplorer.hpp>\n#include <topology/TopoExplorerTool.hpp>\n#include <topology/TopoFace.hpp>\n#include <topology/TopoShape.hpp>\n#include <topology/TopoShell.hpp>\n#include <topology/TopoTool.hpp>\n#include <topology/TopoVertex.hpp>\n#include <topology/TopoWire.hpp>\n#include <topology/WireExplorer.hpp>\n#include <topomesh/BRepMeshIncrementalMesh.hpp>\n#include <nurbs/NURBSAPIBlend.hpp>\n#include <topology/BRepExtremaDistShapeShape.hpp>\n#include <math/LineT.hpp>\n#include <hatch/BRepClassificationTools.hpp>\nusing namespace AMCAX;\nnamespace\n{\n\tstd::shared_ptr<Geom3BSplineCurve> CurveChooser(const int id, const std::shared_ptr<Geom3BSplineCurve>& curve0, const std::shared_ptr<Geom3BSplineCurve>& curve1, const std::shared_ptr<Geom3BSplineCurve>& curve2)\n\t{\n\t\tstd::shared_ptr<Geom3BSplineCurve> result;\n\t\tswitch (id)\n\t\t{\n\t\tcase 0:\n\t\t{\n\t\t\tresult = curve0;\n\t\t\tbreak;\n\t\t}\n\t\tcase 1:\n\t\t{\n\t\t\tresult = curve1;\n\t\t\tbreak;\n\t\t}\n\t\tcase 2:\n\t\t{\n\t\t\tresult = curve2;\n\t\t\tbreak;\n\t\t}\n\t\t}\n\t\treturn result;\n\t}\n} \n#include<catch.hpp>\n#include<testHelper.h>\n#include <filesystem>\n#include <fstream>\n#include <random>\n#include <sstream>\n#include <nurbs/NURBSAPIGetGeometry.hpp>\n#include <nurbs/NURBSAPIConicalSweep.hpp>\n#include <boolean/BoolBRepCut.hpp>\n#include <common/CartesianCoordinateSystem.hpp>\n#include <common/IndexMap.hpp>\n#include <common/QuaternionT.hpp>\n#include <geomAlgo/LawBSpline.hpp>\n#include <geomAlgo/LawConstant.hpp>\n#include <nurbs/NURBSAPISmooth.hpp>\n#include <geomAlgo/MakeConic2FromConstraints.hpp>\n#include <geometry/Adaptor3CurveOnSurface.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/AdaptorGeom3Surface.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2Circle.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/Geom2Hyperbola.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3BSplineCurve.hpp>\n#include <geometry/Geom3BSplineSurface.hpp>\n#include <geometry/Geom3Circle.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\n#include <geometry/Geom3Plane.hpp>\n#include <geometry/Geom3SphericalSurface.hpp>\n#include <geometry/Geom3Surface.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include <geometry/Geom3TrimmedSurface.hpp>\n#include <geometry/GeomAPIExtremaCurveCurve3.hpp>\n#include <geometry/GeomAPIProjectPointOnCurve2.hpp>\n#include <geometry/GeomAPIProjectPointOnCurve3.hpp>\n#include <geometry/GeomAPIProjectPointOnSurface.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/GlobalProperty.hpp>\n#include <healing/ShapeFixTool.hpp>\n#include <io/STLTool.hpp>\n#include <math/Sphere.hpp>\n#include <math/TriangularMesh.hpp>\n#include <modeling/CopyShape.hpp>\n#include <modeling/MakeBox.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeFace.hpp>\n#include <modeling/MakePrism.hpp>\n#include <modeling/MakeRevol.hpp>\n#include <modeling/MakeShapeTool.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <modeling/MakeWire.hpp>\n#include <modeling/TransformShape.hpp>\n#include <nurbs/NURBSAPIApprox.hpp>\n#include <nurbs/NURBSAPIBuildCurve.hpp>\n#include <nurbs/NURBSAPICircularSweep.hpp>\n#include <nurbs/NURBSAPIConvert.hpp>\n#include <nurbs/NURBSAPICurveNetworkSurface.hpp>\n#include <nurbs/NURBSAPIExplicitSweep.hpp>\n#include <nurbs/NURBSAPIExplode.hpp>\n#include <nurbs/NURBSAPIExtend.hpp>\n#include <nurbs/NURBSAPIInterpolate.hpp>\n#include <nurbs/NURBSAPIJoin.hpp>\n#include <nurbs/NURBSAPILinearSweep.hpp>\n#include <nurbs/NURBSAPILoft.hpp>\n#include <nurbs/NURBSAPIMakeNURBSFromBoundaries.hpp>\n#include <nurbs/NURBSAPIMatch.hpp>\n#include <nurbs/NURBSAPIModifyEndToPlane.hpp>\n#include <nurbs/NURBSAPIOffsetCurveOnSurface.hpp>\n#include <nurbs/NURBSAPIProject.hpp>\n#include <nurbs/NURBSAPIRebuild.hpp>\n#include <nurbs/NURBSAPIReplaceEdge.hpp>\n#include <nurbs/NURBSAPISweep.hpp>\n#include <nurbs/NURBSAPISweep2.hpp>\n#include <nurbs/NURBSAPISweepRotation.hpp>\n#include <nurbs/NURBSAPITrim.hpp>\n#include <nurbs/NURBSAPIUntrim.hpp>\n#include <nurbs/NURBSLinearSweepWithDraftDirectionLength.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <offset/MakePipe.hpp>\n#include <offset/MakePipeShell.hpp>\n#include <topology/BRepAdaptorCurve2.hpp>\n#include <topology/BRepAdaptorCurve3.hpp>\n#include <topology/BRepAdaptorSurface.hpp>\n#include <topology/BRepGlobalProperty.hpp>\n#include <topology/BRepTool.hpp>\n#include <topology/TopoBuilder.hpp>\n#include <topology/TopoCompound.hpp>\n#include <topology/TopoEdge.hpp>\n#include <topology/TopoExplorer.hpp>\n#include <topology/TopoExplorerTool.hpp>\n#include <topology/TopoFace.hpp>\n#include <topology/TopoShape.hpp>\n#include <topology/TopoShell.hpp>\n#include <topology/TopoTool.hpp>\n#include <topology/TopoVertex.hpp>\n#include <topology/TopoWire.hpp>\n#include <topology/WireExplorer.hpp>\n#include <topomesh/BRepMeshIncrementalMesh.hpp>\n#include <nurbs/NURBSAPIBlend.hpp>\n#include <topology/BRepExtremaDistShapeShape.hpp>\n#include <math/LineT.hpp>\n#include <hatch/BRepClassificationTools.hpp>\nusing namespace AMCAX;\nnamespace\n{\n\tstd::shared_ptr<Geom3BSplineCurve> CurveChooser(const int id, const std::shared_ptr<Geom3BSplineCurve>& curve0, const std::shared_ptr<Geom3BSplineCurve>& curve1, const std::shared_ptr<Geom3BSplineCurve>& curve2)\n\t{\n\t\tstd::shared_ptr<Geom3BSplineCurve> result;\n\t\tswitch (id)\n\t\t{\n\t\tcase 0:\n\t\t{\n\t\t\tresult = curve0;\n\t\t\tbreak;\n\t\t}\n\t\tcase 1:\n\t\t{\n\t\t\tresult = curve1;\n\t\t\tbreak;\n\t\t}\n\t\tcase 2:\n\t\t{\n\t\t\tresult = curve2;\n\t\t\tbreak;\n\t\t}\n\t\t}\n\t\treturn result;\n\t}\n;\n\tSECTION(\"TestLinearSweepWithTwoTangencySurfaces()\")\n\t{\n\t\tstd::string filedir1 = OUTPUT_PATH_PREFIX;\n\t\tstd::string filedir = INPUT_PATH_PREFIX \"/TestNURBS/TestLinearSweepWithTwoTangencySurfaces/\";\n\t\tauto spine = ReadBRepCurve(filedir + \"spine.brep\");\n\t\tCHECK(OCCTIO::OCCTTool::Write(MakeEdge(spine), OUTPUT_PATH_PREFIX \"TestLinearSweepWithTwoTangencySurfaces_spine.brep\"));\n\t\tauto surf1 = ReadBRepSurface(filedir + \"surf1.brep\");\n\t\tCHECK(OCCTIO::OCCTTool::Write(MakeFace(surf1, 0.0), OUTPUT_PATH_PREFIX \"TestLinearSweepWithTwoTangencySurfaces_surf1.brep\"));\n\t\tauto surf2 = ReadBRepSurface(filedir + \"surf2.brep\");\n\t\tCHECK(OCCTIO::OCCTTool::Write(MakeFace(surf2, 0.0), OUTPUT_PATH_PREFIX \"TestLinearSweepWithTwoTangencySurfaces_surf2.brep\"));\n\t\tauto [status, result] = NURBSAPILinearSweep::SweepWithTwoTangencySurfaces(spine, surf1, surf2, spine->FirstParameter(), spine->LastParameter());\n\t\tCHECK(status == NURBSSweepStatus::Success);\n\t\tif (status == NURBSSweepStatus::Success && !result.empty())\n\t\t{\n\t\t\tCHECK(OCCTIO::OCCTTool::Write(MakeFace(result.front(), 0.0), OUTPUT_PATH_PREFIX \"TestLinearSweepWithTwoTangencySurfaces_result.brep\"));\n\t\t}\n\t\tCHECK(result.size() == 1);\n\t\tIndexSet<TopoShape> newshapeEdge1;\n\t\tstd::cout << \"newshapedege.size\" << newshapeEdge1.size() << endl;\n\t\tTopoExplorerTool::MapShapes(MakeFace(result.front(), 0.0), ShapeType::Edge, newshapeEdge1);\n\t\tCHECK(OCCTIO::OCCTTool::Write(newshapeEdge1[0], OUTPUT_PATH_PREFIX \"TestLinearSweepWithTwoTangencySurfaces_newshapeEdge1[0].brep\"));\n\t\tCHECK(OCCTIO::OCCTTool::Write(newshapeEdge1[2], OUTPUT_PATH_PREFIX \"TestLinearSweepWithTwoTangencySurfaces_newshapeEdge1[2].brep\"));\n\t\tauto edge0 = ReadBRepCurve(filedir1 + \"TestLinearSweepWithTwoTangencySurfaces_newshapeEdge1[0].brep\");\n\t\tauto edge1 = ReadBRepCurve(filedir1 + \"TestLinearSweepWithTwoTangencySurfaces_newshapeEdge1[2].brep\");\n\t\tauto surface = ReadBRepSurface(filedir1 + \"TestLinearSweepWithTwoTangencySurfaces_result.brep\");\n\t\tAMCAX::BRepExtremaDistShapeShape len1(newshapeEdge1[0], MakeFace(surf1, 0.0));\n\t\tAMCAX::BRepExtremaDistShapeShape len2(newshapeEdge1[2], MakeFace(surf2, 0.0));\n\t\tCHECK(IsSurfTangent(100, 0.1, edge0, surf1, surface, 20, 180));\n\t\tCHECK(IsSurfTangent(100, 0.1, edge1, surf2, surface, 20, 0));\n\t\tCHECK(len1.Value() == Approx(0.0).margin(0.1));\n\t\tCHECK(len2.Value() == Approx(0.0).margin(0.1));\n\t\tsurf1->IncreaseDegree(11, 11);\n\t\tsurf2->IncreaseDegree(11, 11);\n\t\tspine->IncreaseDegree(11);\n\t\tauto [status1, result1] = NURBSAPILinearSweep::SweepWithTwoTangencySurfaces(spine, surf1, surf2, spine->FirstParameter(), spine->LastParameter());\n\t\tCHECK(status1 == NURBSSweepStatus::Success);\n\t\tif (status1 == NURBSSweepStatus::Success && !result1.empty())\n\t\t{\n\t\t\tCHECK(OCCTIO::OCCTTool::Write(MakeFace(result1.front(), 0.0), OUTPUT_PATH_PREFIX \"TestLinearSweepWithTwoTangencySurfaces_degree11result.brep\"));\n\t\t\tCHECK(IsSurfTangent(100, 0.1, edge0, surf1, surface, 20, 180));\n\t\t\tCHECK(IsSurfTangent(100, 0.1, edge1, surf2, surface, 20, 0));\n\t\t\tCHECK(len1.Value() == Approx(0.0).margin(0.1));\n\t\t\tCHECK(len2.Value() == Approx(0.0).margin(0.1));\n\t\t\tdouble bsp3s = GetSurfaceProperties(MakeFace(result1[0], 0.0), g, true, true);\n\t\t\tdouble bsp4s = GetSurfaceProperties(MakeFace(result[0], 0.0), g, true, true);\n\t\t\tCHECK(bsp3s == Approx(bsp4s).margin(0.02));\n\t\t}\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static std::pair<NURBSSweepStatus, std::vector<std::shared_ptr<Geom3BSplineSurface>>> SweepWithDraftDirection(const std::shared_ptr<Geom3BSplineCurve>& guide, const Direction3& draftDirection, const LawFunction& angleLaw, const NURBSLinearSweepWithDraftDirectionLength& length1, const NURBSLinearSweepWithDraftDirectionLength& length2),\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <filesystem>\n#include <fstream>\n#include <random>\n#include <sstream>\n#include <nurbs/NURBSAPIGetGeometry.hpp>\n#include <nurbs/NURBSAPIConicalSweep.hpp>\n#include <boolean/BoolBRepCut.hpp>\n#include <common/CartesianCoordinateSystem.hpp>\n#include <common/IndexMap.hpp>\n#include <common/QuaternionT.hpp>\n#include <geomAlgo/LawBSpline.hpp>\n#include <geomAlgo/LawConstant.hpp>\n#include <nurbs/NURBSAPISmooth.hpp>\n#include <geomAlgo/MakeConic2FromConstraints.hpp>\n#include <geometry/Adaptor3CurveOnSurface.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/AdaptorGeom3Surface.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2Circle.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/Geom2Hyperbola.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3BSplineCurve.hpp>\n#include <geometry/Geom3BSplineSurface.hpp>\n#include <geometry/Geom3Circle.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\n#include <geometry/Geom3Plane.hpp>\n#include <geometry/Geom3SphericalSurface.hpp>\n#include <geometry/Geom3Surface.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include <geometry/Geom3TrimmedSurface.hpp>\n#include <geometry/GeomAPIExtremaCurveCurve3.hpp>\n#include <geometry/GeomAPIProjectPointOnCurve2.hpp>\n#include <geometry/GeomAPIProjectPointOnCurve3.hpp>\n#include <geometry/GeomAPIProjectPointOnSurface.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/GlobalProperty.hpp>\n#include <healing/ShapeFixTool.hpp>\n#include <io/STLTool.hpp>\n#include <math/Sphere.hpp>\n#include <math/TriangularMesh.hpp>\n#include <modeling/CopyShape.hpp>\n#include <modeling/MakeBox.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeFace.hpp>\n#include <modeling/MakePrism.hpp>\n#include <modeling/MakeRevol.hpp>\n#include <modeling/MakeShapeTool.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <modeling/MakeWire.hpp>\n#include <modeling/TransformShape.hpp>\n#include <nurbs/NURBSAPIApprox.hpp>\n#include <nurbs/NURBSAPIBuildCurve.hpp>\n#include <nurbs/NURBSAPICircularSweep.hpp>\n#include <nurbs/NURBSAPIConvert.hpp>\n#include <nurbs/NURBSAPICurveNetworkSurface.hpp>\n#include <nurbs/NURBSAPIExplicitSweep.hpp>\n#include <nurbs/NURBSAPIExplode.hpp>\n#include <nurbs/NURBSAPIExtend.hpp>\n#include <nurbs/NURBSAPIInterpolate.hpp>\n#include <nurbs/NURBSAPIJoin.hpp>\n#include <nurbs/NURBSAPILinearSweep.hpp>\n#include <nurbs/NURBSAPILoft.hpp>\n#include <nurbs/NURBSAPIMakeNURBSFromBoundaries.hpp>\n#include <nurbs/NURBSAPIMatch.hpp>\n#include <nurbs/NURBSAPIModifyEndToPlane.hpp>\n#include <nurbs/NURBSAPIOffsetCurveOnSurface.hpp>\n#include <nurbs/NURBSAPIProject.hpp>\n#include <nurbs/NURBSAPIRebuild.hpp>\n#include <nurbs/NURBSAPIReplaceEdge.hpp>\n#include <nurbs/NURBSAPISweep.hpp>\n#include <nurbs/NURBSAPISweep2.hpp>\n#include <nurbs/NURBSAPISweepRotation.hpp>\n#include <nurbs/NURBSAPITrim.hpp>\n#include <nurbs/NURBSAPIUntrim.hpp>\n#include <nurbs/NURBSLinearSweepWithDraftDirectionLength.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <offset/MakePipe.hpp>\n#include <offset/MakePipeShell.hpp>\n#include <topology/BRepAdaptorCurve2.hpp>\n#include <topology/BRepAdaptorCurve3.hpp>\n#include <topology/BRepAdaptorSurface.hpp>\n#include <topology/BRepGlobalProperty.hpp>\n#include <topology/BRepTool.hpp>\n#include <topology/TopoBuilder.hpp>\n#include <topology/TopoCompound.hpp>\n#include <topology/TopoEdge.hpp>\n#include <topology/TopoExplorer.hpp>\n#include <topology/TopoExplorerTool.hpp>\n#include <topology/TopoFace.hpp>\n#include <topology/TopoShape.hpp>\n#include <topology/TopoShell.hpp>\n#include <topology/TopoTool.hpp>\n#include <topology/TopoVertex.hpp>\n#include <topology/TopoWire.hpp>\n#include <topology/WireExplorer.hpp>\n#include <topomesh/BRepMeshIncrementalMesh.hpp>\n#include <nurbs/NURBSAPIBlend.hpp>\n#include <topology/BRepExtremaDistShapeShape.hpp>\n#include <math/LineT.hpp>\n#include <hatch/BRepClassificationTools.hpp>\nusing namespace AMCAX;\nnamespace\n{\n\tstd::shared_ptr<Geom3BSplineCurve> CurveChooser(const int id, const std::shared_ptr<Geom3BSplineCurve>& curve0, const std::shared_ptr<Geom3BSplineCurve>& curve1, const std::shared_ptr<Geom3BSplineCurve>& curve2)\n\t{\n\t\tstd::shared_ptr<Geom3BSplineCurve> result;\n\t\tswitch (id)\n\t\t{\n\t\tcase 0:\n\t\t{\n\t\t\tresult = curve0;\n\t\t\tbreak;\n\t\t}\n\t\tcase 1:\n\t\t{\n\t\t\tresult = curve1;\n\t\t\tbreak;\n\t\t}\n\t\tcase 2:\n\t\t{\n\t\t\tresult = curve2;\n\t\t\tbreak;\n\t\t}\n\t\t}\n\t\treturn result;\n\t}\n} \n#include<catch.hpp>\n#include<testHelper.h>\n#include <filesystem>\n#include <fstream>\n#include <random>\n#include <sstream>\n#include <nurbs/NURBSAPIGetGeometry.hpp>\n#include <nurbs/NURBSAPIConicalSweep.hpp>\n#include <boolean/BoolBRepCut.hpp>\n#include <common/CartesianCoordinateSystem.hpp>\n#include <common/IndexMap.hpp>\n#include <common/QuaternionT.hpp>\n#include <geomAlgo/LawBSpline.hpp>\n#include <geomAlgo/LawConstant.hpp>\n#include <nurbs/NURBSAPISmooth.hpp>\n#include <geomAlgo/MakeConic2FromConstraints.hpp>\n#include <geometry/Adaptor3CurveOnSurface.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/AdaptorGeom3Surface.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2Circle.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/Geom2Hyperbola.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3BSplineCurve.hpp>\n#include <geometry/Geom3BSplineSurface.hpp>\n#include <geometry/Geom3Circle.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\n#include <geometry/Geom3Plane.hpp>\n#include <geometry/Geom3SphericalSurface.hpp>\n#include <geometry/Geom3Surface.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include <geometry/Geom3TrimmedSurface.hpp>\n#include <geometry/GeomAPIExtremaCurveCurve3.hpp>\n#include <geometry/GeomAPIProjectPointOnCurve2.hpp>\n#include <geometry/GeomAPIProjectPointOnCurve3.hpp>\n#include <geometry/GeomAPIProjectPointOnSurface.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/GlobalProperty.hpp>\n#include <healing/ShapeFixTool.hpp>\n#include <io/STLTool.hpp>\n#include <math/Sphere.hpp>\n#include <math/TriangularMesh.hpp>\n#include <modeling/CopyShape.hpp>\n#include <modeling/MakeBox.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeFace.hpp>\n#include <modeling/MakePrism.hpp>\n#include <modeling/MakeRevol.hpp>\n#include <modeling/MakeShapeTool.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <modeling/MakeWire.hpp>\n#include <modeling/TransformShape.hpp>\n#include <nurbs/NURBSAPIApprox.hpp>\n#include <nurbs/NURBSAPIBuildCurve.hpp>\n#include <nurbs/NURBSAPICircularSweep.hpp>\n#include <nurbs/NURBSAPIConvert.hpp>\n#include <nurbs/NURBSAPICurveNetworkSurface.hpp>\n#include <nurbs/NURBSAPIExplicitSweep.hpp>\n#include <nurbs/NURBSAPIExplode.hpp>\n#include <nurbs/NURBSAPIExtend.hpp>\n#include <nurbs/NURBSAPIInterpolate.hpp>\n#include <nurbs/NURBSAPIJoin.hpp>\n#include <nurbs/NURBSAPILinearSweep.hpp>\n#include <nurbs/NURBSAPILoft.hpp>\n#include <nurbs/NURBSAPIMakeNURBSFromBoundaries.hpp>\n#include <nurbs/NURBSAPIMatch.hpp>\n#include <nurbs/NURBSAPIModifyEndToPlane.hpp>\n#include <nurbs/NURBSAPIOffsetCurveOnSurface.hpp>\n#include <nurbs/NURBSAPIProject.hpp>\n#include <nurbs/NURBSAPIRebuild.hpp>\n#include <nurbs/NURBSAPIReplaceEdge.hpp>\n#include <nurbs/NURBSAPISweep.hpp>\n#include <nurbs/NURBSAPISweep2.hpp>\n#include <nurbs/NURBSAPISweepRotation.hpp>\n#include <nurbs/NURBSAPITrim.hpp>\n#include <nurbs/NURBSAPIUntrim.hpp>\n#include <nurbs/NURBSLinearSweepWithDraftDirectionLength.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <offset/MakePipe.hpp>\n#include <offset/MakePipeShell.hpp>\n#include <topology/BRepAdaptorCurve2.hpp>\n#include <topology/BRepAdaptorCurve3.hpp>\n#include <topology/BRepAdaptorSurface.hpp>\n#include <topology/BRepGlobalProperty.hpp>\n#include <topology/BRepTool.hpp>\n#include <topology/TopoBuilder.hpp>\n#include <topology/TopoCompound.hpp>\n#include <topology/TopoEdge.hpp>\n#include <topology/TopoExplorer.hpp>\n#include <topology/TopoExplorerTool.hpp>\n#include <topology/TopoFace.hpp>\n#include <topology/TopoShape.hpp>\n#include <topology/TopoShell.hpp>\n#include <topology/TopoTool.hpp>\n#include <topology/TopoVertex.hpp>\n#include <topology/TopoWire.hpp>\n#include <topology/WireExplorer.hpp>\n#include <topomesh/BRepMeshIncrementalMesh.hpp>\n#include <nurbs/NURBSAPIBlend.hpp>\n#include <topology/BRepExtremaDistShapeShape.hpp>\n#include <math/LineT.hpp>\n#include <hatch/BRepClassificationTools.hpp>\nusing namespace AMCAX;\nnamespace\n{\n\tstd::shared_ptr<Geom3BSplineCurve> CurveChooser(const int id, const std::shared_ptr<Geom3BSplineCurve>& curve0, const std::shared_ptr<Geom3BSplineCurve>& curve1, const std::shared_ptr<Geom3BSplineCurve>& curve2)\n\t{\n\t\tstd::shared_ptr<Geom3BSplineCurve> result;\n\t\tswitch (id)\n\t\t{\n\t\tcase 0:\n\t\t{\n\t\t\tresult = curve0;\n\t\t\tbreak;\n\t\t}\n\t\tcase 1:\n\t\t{\n\t\t\tresult = curve1;\n\t\t\tbreak;\n\t\t}\n\t\tcase 2:\n\t\t{\n\t\t\tresult = curve2;\n\t\t\tbreak;\n\t\t}\n\t\t}\n\t\treturn result;\n\t}\n;\n\tSECTION(\"TestLinearSweepWithDraftDirection()\")\n\t{\n\t\tstd::string filedir = INPUT_PATH_PREFIX \"/TestNURBS/TestLinearSweepWithDraftDirection/\";\n\t\tauto curve = ReadBRepCurve(filedir + \"curve.brep\");\n\t\tCHECK(OCCTIO::OCCTTool::Write(MakeEdge(curve), OUTPUT_PATH_PREFIX \"TestLinearSweepWithDraftDirection_curve.brep\"));\n\t\tDirection3 draftDirection(0.0, 0.0, 1.0);\n\t\tLawConstant angleLaw;\n\t\tangleLaw.Set(M_PI_4 * 0.5, 0.0, 1.0);\n\t\tauto surf1 = ReadBRepSurface(filedir + \"surf1.brep\");\n\t\tNURBSLinearSweepWithDraftDirectionLength standard(NURBSLinearSweepWithDraftDirectionLengthType::Standard, 3.0, surf1);\n\t\tauto [status, result] = NURBSAPILinearSweep::SweepWithDraftDirection(curve, draftDirection, angleLaw, standard, standard);\n\t\tCHECK(status == NURBSSweepStatus::Success);\n\t\tif (status == NURBSSweepStatus::Success)\n\t\t{\n\t\t\tconst auto& surf = result[1];\n\t\t\tCHECK(OCCTIO::OCCTTool::Write(MakeFace(surf, 0.0), OUTPUT_PATH_PREFIX \"TestLinearSweepWithDraftDirection_result.brep\"));\n\t\t\tCHECK(OCCTIO::OCCTTool::Write(MakeFace(result[0], 0.0), OUTPUT_PATH_PREFIX \"TestLinearSweepWithDraftDirection_result0.brep\"));\n\t\t\tCHECK(OCCTIO::OCCTTool::Write(MakeFace(result[2], 0.0), OUTPUT_PATH_PREFIX \"TestLinearSweepWithDraftDirection_result2.brep\"));\n\t\t\tCHECK(OCCTIO::OCCTTool::Write(MakeFace(result[3], 0.0), OUTPUT_PATH_PREFIX \"TestLinearSweepWithDraftDirection_result3.brep\"));\n\t\t\tTopoShape face = MakeFace(surf, Precision::Confusion());\n\t\t\tCHECK(IsCurveOnSurf(1000, 0.2, curve, result[1], 0.2));\n\t\t\tAMCAX::BRepExtremaDistShapeShape len1(MakeEdge(curve), MakeFace(result[1], 0.0));\n\t\t\tCHECK(len1.Value() < 0.1);\n\t\t}\n\t\tcurve->IncreaseDegree(11);\n\t\tauto [status1, result1] = NURBSAPILinearSweep::SweepWithDraftDirection(curve, draftDirection, angleLaw, standard, standard);\n\t\tCHECK(status1 == NURBSSweepStatus::Success);\n\t\tif (status1 == NURBSSweepStatus::Success)\n\t\t{\n\t\t\tconst auto& surf = result1[1];\n\t\t\tCHECK(OCCTIO::OCCTTool::Write(MakeFace(surf, 0.0), OUTPUT_PATH_PREFIX \"TestLinearSweepWithDraftDirection_degree11result.brep\"));\n\t\t\tTopoShape face = MakeFace(surf, Precision::Confusion());\n\t\t\tCHECK(IsCurveOnSurf(1000, 0.2, curve, result1[1], 0.2));\n\t\t\tAMCAX::BRepExtremaDistShapeShape len1(MakeEdge(curve), MakeFace(result1[1], 0.0));\n\t\t\tCHECK(len1.Value() < 0.1);\n\t\t\tdouble bsp3s = GetSurfaceProperties(MakeFace(result1[1], 0.0), g, true, true);\n\t\t\tdouble bsp4s = GetSurfaceProperties(MakeFace(result[1], 0.0), g, true, true);\n\t\t\tCHECK(bsp3s == Approx(bsp4s).margin(0.02));\n\t\t}\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static std::pair<NURBSSweepStatus, std::vector<std::shared_ptr<Geom3BSplineSurface>>> SweepWithTangencySurface(const std::shared_ptr<Geom3BSplineCurve>& guide, const std::shared_ptr<Geom3BSplineSurface>& tangencySurface, const std::shared_ptr<Geom3BSplineCurve>& spine, double spineLeftBound, double spineRightBound),\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <filesystem>\n#include <fstream>\n#include <random>\n#include <sstream>\n#include <nurbs/NURBSAPIGetGeometry.hpp>\n#include <nurbs/NURBSAPIConicalSweep.hpp>\n#include <boolean/BoolBRepCut.hpp>\n#include <common/CartesianCoordinateSystem.hpp>\n#include <common/IndexMap.hpp>\n#include <common/QuaternionT.hpp>\n#include <geomAlgo/LawBSpline.hpp>\n#include <geomAlgo/LawConstant.hpp>\n#include <nurbs/NURBSAPISmooth.hpp>\n#include <geomAlgo/MakeConic2FromConstraints.hpp>\n#include <geometry/Adaptor3CurveOnSurface.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/AdaptorGeom3Surface.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2Circle.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/Geom2Hyperbola.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3BSplineCurve.hpp>\n#include <geometry/Geom3BSplineSurface.hpp>\n#include <geometry/Geom3Circle.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\n#include <geometry/Geom3Plane.hpp>\n#include <geometry/Geom3SphericalSurface.hpp>\n#include <geometry/Geom3Surface.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include <geometry/Geom3TrimmedSurface.hpp>\n#include <geometry/GeomAPIExtremaCurveCurve3.hpp>\n#include <geometry/GeomAPIProjectPointOnCurve2.hpp>\n#include <geometry/GeomAPIProjectPointOnCurve3.hpp>\n#include <geometry/GeomAPIProjectPointOnSurface.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/GlobalProperty.hpp>\n#include <healing/ShapeFixTool.hpp>\n#include <io/STLTool.hpp>\n#include <math/Sphere.hpp>\n#include <math/TriangularMesh.hpp>\n#include <modeling/CopyShape.hpp>\n#include <modeling/MakeBox.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeFace.hpp>\n#include <modeling/MakePrism.hpp>\n#include <modeling/MakeRevol.hpp>\n#include <modeling/MakeShapeTool.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <modeling/MakeWire.hpp>\n#include <modeling/TransformShape.hpp>\n#include <nurbs/NURBSAPIApprox.hpp>\n#include <nurbs/NURBSAPIBuildCurve.hpp>\n#include <nurbs/NURBSAPICircularSweep.hpp>\n#include <nurbs/NURBSAPIConvert.hpp>\n#include <nurbs/NURBSAPICurveNetworkSurface.hpp>\n#include <nurbs/NURBSAPIExplicitSweep.hpp>\n#include <nurbs/NURBSAPIExplode.hpp>\n#include <nurbs/NURBSAPIExtend.hpp>\n#include <nurbs/NURBSAPIInterpolate.hpp>\n#include <nurbs/NURBSAPIJoin.hpp>\n#include <nurbs/NURBSAPILinearSweep.hpp>\n#include <nurbs/NURBSAPILoft.hpp>\n#include <nurbs/NURBSAPIMakeNURBSFromBoundaries.hpp>\n#include <nurbs/NURBSAPIMatch.hpp>\n#include <nurbs/NURBSAPIModifyEndToPlane.hpp>\n#include <nurbs/NURBSAPIOffsetCurveOnSurface.hpp>\n#include <nurbs/NURBSAPIProject.hpp>\n#include <nurbs/NURBSAPIRebuild.hpp>\n#include <nurbs/NURBSAPIReplaceEdge.hpp>\n#include <nurbs/NURBSAPISweep.hpp>\n#include <nurbs/NURBSAPISweep2.hpp>\n#include <nurbs/NURBSAPISweepRotation.hpp>\n#include <nurbs/NURBSAPITrim.hpp>\n#include <nurbs/NURBSAPIUntrim.hpp>\n#include <nurbs/NURBSLinearSweepWithDraftDirectionLength.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <offset/MakePipe.hpp>\n#include <offset/MakePipeShell.hpp>\n#include <topology/BRepAdaptorCurve2.hpp>\n#include <topology/BRepAdaptorCurve3.hpp>\n#include <topology/BRepAdaptorSurface.hpp>\n#include <topology/BRepGlobalProperty.hpp>\n#include <topology/BRepTool.hpp>\n#include <topology/TopoBuilder.hpp>\n#include <topology/TopoCompound.hpp>\n#include <topology/TopoEdge.hpp>\n#include <topology/TopoExplorer.hpp>\n#include <topology/TopoExplorerTool.hpp>\n#include <topology/TopoFace.hpp>\n#include <topology/TopoShape.hpp>\n#include <topology/TopoShell.hpp>\n#include <topology/TopoTool.hpp>\n#include <topology/TopoVertex.hpp>\n#include <topology/TopoWire.hpp>\n#include <topology/WireExplorer.hpp>\n#include <topomesh/BRepMeshIncrementalMesh.hpp>\n#include <nurbs/NURBSAPIBlend.hpp>\n#include <topology/BRepExtremaDistShapeShape.hpp>\n#include <math/LineT.hpp>\n#include <hatch/BRepClassificationTools.hpp>\nusing namespace AMCAX;\nnamespace\n{\n\tstd::shared_ptr<Geom3BSplineCurve> CurveChooser(const int id, const std::shared_ptr<Geom3BSplineCurve>& curve0, const std::shared_ptr<Geom3BSplineCurve>& curve1, const std::shared_ptr<Geom3BSplineCurve>& curve2)\n\t{\n\t\tstd::shared_ptr<Geom3BSplineCurve> result;\n\t\tswitch (id)\n\t\t{\n\t\tcase 0:\n\t\t{\n\t\t\tresult = curve0;\n\t\t\tbreak;\n\t\t}\n\t\tcase 1:\n\t\t{\n\t\t\tresult = curve1;\n\t\t\tbreak;\n\t\t}\n\t\tcase 2:\n\t\t{\n\t\t\tresult = curve2;\n\t\t\tbreak;\n\t\t}\n\t\t}\n\t\treturn result;\n\t}\n} \n#include<catch.hpp>\n#include<testHelper.h>\n#include <filesystem>\n#include <fstream>\n#include <random>\n#include <sstream>\n#include <nurbs/NURBSAPIGetGeometry.hpp>\n#include <nurbs/NURBSAPIConicalSweep.hpp>\n#include <boolean/BoolBRepCut.hpp>\n#include <common/CartesianCoordinateSystem.hpp>\n#include <common/IndexMap.hpp>\n#include <common/QuaternionT.hpp>\n#include <geomAlgo/LawBSpline.hpp>\n#include <geomAlgo/LawConstant.hpp>\n#include <nurbs/NURBSAPISmooth.hpp>\n#include <geomAlgo/MakeConic2FromConstraints.hpp>\n#include <geometry/Adaptor3CurveOnSurface.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/AdaptorGeom3Surface.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2Circle.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/Geom2Hyperbola.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3BSplineCurve.hpp>\n#include <geometry/Geom3BSplineSurface.hpp>\n#include <geometry/Geom3Circle.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\n#include <geometry/Geom3Plane.hpp>\n#include <geometry/Geom3SphericalSurface.hpp>\n#include <geometry/Geom3Surface.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include <geometry/Geom3TrimmedSurface.hpp>\n#include <geometry/GeomAPIExtremaCurveCurve3.hpp>\n#include <geometry/GeomAPIProjectPointOnCurve2.hpp>\n#include <geometry/GeomAPIProjectPointOnCurve3.hpp>\n#include <geometry/GeomAPIProjectPointOnSurface.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/GlobalProperty.hpp>\n#include <healing/ShapeFixTool.hpp>\n#include <io/STLTool.hpp>\n#include <math/Sphere.hpp>\n#include <math/TriangularMesh.hpp>\n#include <modeling/CopyShape.hpp>\n#include <modeling/MakeBox.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeFace.hpp>\n#include <modeling/MakePrism.hpp>\n#include <modeling/MakeRevol.hpp>\n#include <modeling/MakeShapeTool.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <modeling/MakeWire.hpp>\n#include <modeling/TransformShape.hpp>\n#include <nurbs/NURBSAPIApprox.hpp>\n#include <nurbs/NURBSAPIBuildCurve.hpp>\n#include <nurbs/NURBSAPICircularSweep.hpp>\n#include <nurbs/NURBSAPIConvert.hpp>\n#include <nurbs/NURBSAPICurveNetworkSurface.hpp>\n#include <nurbs/NURBSAPIExplicitSweep.hpp>\n#include <nurbs/NURBSAPIExplode.hpp>\n#include <nurbs/NURBSAPIExtend.hpp>\n#include <nurbs/NURBSAPIInterpolate.hpp>\n#include <nurbs/NURBSAPIJoin.hpp>\n#include <nurbs/NURBSAPILinearSweep.hpp>\n#include <nurbs/NURBSAPILoft.hpp>\n#include <nurbs/NURBSAPIMakeNURBSFromBoundaries.hpp>\n#include <nurbs/NURBSAPIMatch.hpp>\n#include <nurbs/NURBSAPIModifyEndToPlane.hpp>\n#include <nurbs/NURBSAPIOffsetCurveOnSurface.hpp>\n#include <nurbs/NURBSAPIProject.hpp>\n#include <nurbs/NURBSAPIRebuild.hpp>\n#include <nurbs/NURBSAPIReplaceEdge.hpp>\n#include <nurbs/NURBSAPISweep.hpp>\n#include <nurbs/NURBSAPISweep2.hpp>\n#include <nurbs/NURBSAPISweepRotation.hpp>\n#include <nurbs/NURBSAPITrim.hpp>\n#include <nurbs/NURBSAPIUntrim.hpp>\n#include <nurbs/NURBSLinearSweepWithDraftDirectionLength.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <offset/MakePipe.hpp>\n#include <offset/MakePipeShell.hpp>\n#include <topology/BRepAdaptorCurve2.hpp>\n#include <topology/BRepAdaptorCurve3.hpp>\n#include <topology/BRepAdaptorSurface.hpp>\n#include <topology/BRepGlobalProperty.hpp>\n#include <topology/BRepTool.hpp>\n#include <topology/TopoBuilder.hpp>\n#include <topology/TopoCompound.hpp>\n#include <topology/TopoEdge.hpp>\n#include <topology/TopoExplorer.hpp>\n#include <topology/TopoExplorerTool.hpp>\n#include <topology/TopoFace.hpp>\n#include <topology/TopoShape.hpp>\n#include <topology/TopoShell.hpp>\n#include <topology/TopoTool.hpp>\n#include <topology/TopoVertex.hpp>\n#include <topology/TopoWire.hpp>\n#include <topology/WireExplorer.hpp>\n#include <topomesh/BRepMeshIncrementalMesh.hpp>\n#include <nurbs/NURBSAPIBlend.hpp>\n#include <topology/BRepExtremaDistShapeShape.hpp>\n#include <math/LineT.hpp>\n#include <hatch/BRepClassificationTools.hpp>\nusing namespace AMCAX;\nnamespace\n{\n\tstd::shared_ptr<Geom3BSplineCurve> CurveChooser(const int id, const std::shared_ptr<Geom3BSplineCurve>& curve0, const std::shared_ptr<Geom3BSplineCurve>& curve1, const std::shared_ptr<Geom3BSplineCurve>& curve2)\n\t{\n\t\tstd::shared_ptr<Geom3BSplineCurve> result;\n\t\tswitch (id)\n\t\t{\n\t\tcase 0:\n\t\t{\n\t\t\tresult = curve0;\n\t\t\tbreak;\n\t\t}\n\t\tcase 1:\n\t\t{\n\t\t\tresult = curve1;\n\t\t\tbreak;\n\t\t}\n\t\tcase 2:\n\t\t{\n\t\t\tresult = curve2;\n\t\t\tbreak;\n\t\t}\n\t\t}\n\t\treturn result;\n\t}\n;\n\tSECTION(\"TestLinearSweepWithTangencySurface2()\")\n\t{\n\t\tstd::string filedir = INPUT_PATH_PREFIX \"/TestNURBS/TestLinearSweepWithTangencySurface2/\";\n\t\tstd::string filedir1 = OUTPUT_PATH_PREFIX;\n\t\tauto curve = ReadBRepCurve(filedir + \"curve.brep\");\n\t\tCHECK(OCCTIO::OCCTTool::Write(MakeEdge(curve), OUTPUT_PATH_PREFIX \"TestLinearSweepWithTangencySurface2_curve.brep\"));\n\t\tauto surface = ReadBRepSurface(filedir + \"surface.brep\");\n\t\tCHECK(OCCTIO::OCCTTool::Write(MakeFace(surface, 0.0), OUTPUT_PATH_PREFIX \"TestLinearSweepWithTangencySurface2_surface.brep\"));\n\t\tclock_t bg = clock();\n\t\tauto [status, resultSurfaces] = NURBSAPILinearSweep::SweepWithTangencySurface(curve, surface, curve, curve->FirstParameter(), curve->LastParameter());\n\t\tclock_t ed = clock();\n\t\tstd::cout << \"time = \" << ed - bg << \"ms\" << std::endl;\n\t\tCHECK(status == NURBSSweepStatus::Success);\n\t\tif (status == NURBSSweepStatus::Success)\n\t\t{\n\t\t\tTopoCompound comp;\n\t\t\tTopoBuilder builder;\n\t\t\tbuilder.MakeCompound(comp);\n\t\t\tfor (const auto& srf : resultSurfaces)\n\t\t\t{\n\t\t\t\tbuilder.Add(comp, MakeFace(srf, Precision::Confusion()));\n\t\t\t}\n\t\t\tCHECK(OCCTIO::OCCTTool::Write(comp, OUTPUT_PATH_PREFIX \"TestLinearSweepWithTangencySurface2_result.brep\"));\n\t\t\tIndexSet<TopoShape> newshapeEdge1;\n\t\t\tTopoExplorerTool::MapShapes(comp, ShapeType::Edge, newshapeEdge1);\n\t\t\tstd::cout << \"newshapedege.size\" << newshapeEdge1.size() << endl;\n\t\t\tCHECK(OCCTIO::OCCTTool::Write(newshapeEdge1[2], OUTPUT_PATH_PREFIX \"TestLinearSweepWithTangencySurface2_newshapeEdge1[2].brep\"));\n\t\t\tCHECK(OCCTIO::OCCTTool::Write(newshapeEdge1[6], OUTPUT_PATH_PREFIX \"TestLinearSweepWithTangencySurface2_newshapeEdge1[6].brep\"));\n\t\t\tauto edge0 = ReadBRepCurve(filedir1 + \"TestLinearSweepWithTangencySurface2_newshapeEdge1[2].brep\");\n\t\t\tauto edge1 = ReadBRepCurve(filedir1 + \"TestLinearSweepWithTangencySurface2_newshapeEdge1[6].brep\");\n\t\t\tauto surfaces = ReadBRepSurface(filedir1 + \"TestLinearSweepWithTangencySurface2_result.brep\");\n\t\t\tCHECK(IsSurfTangent(100, 0.1, edge0, surface, resultSurfaces.front(), 20, 0));\n\t\t\tCHECK(IsSurfTangent(100, 0.1, edge1, surface, resultSurfaces.back(), 20, 180));\n\t\t}\n\t\tCHECK(IsCurveOnSurf(1000, 0.1, curve, resultSurfaces.front(), 0.1));\n\t\tCHECK(IsCurveOnSurf(1000, 0.1, curve, resultSurfaces.back(), 0.1));\n\t\tIndexSet<TopoShape> newshapeEdge1, newshapeEdge2;\n\t\tTopoExplorerTool::MapShapes(MakeFace(resultSurfaces.front(), 0.0), ShapeType::Edge, newshapeEdge1);\n\t\tTopoExplorerTool::MapShapes(MakeFace(resultSurfaces.back(), 0.0), ShapeType::Edge, newshapeEdge2);\n\t\tAMCAX::BRepExtremaDistShapeShape len1(newshapeEdge1[2], MakeFace(surface, 0.0));\n\t\tAMCAX::BRepExtremaDistShapeShape len2(newshapeEdge2[2], MakeFace(surface, 0.0));\n\t\tCHECK(len1.Value() == Approx(0.0).margin(0.1));\n\t\tCHECK(len2.Value() == Approx(0.0).margin(0.1));\n\t\tcurve->IncreaseDegree(5);\n\t\tsurface->IncreaseDegree(5, 5);\n\t\tauto [status1, resultSurfaces1] = NURBSAPILinearSweep::SweepWithTangencySurface(curve, surface, curve, curve->FirstParameter(), curve->LastParameter());\n\t\tCHECK(status == NURBSSweepStatus::Success);\n\t\tCHECK(IsCurveOnSurf(1000, 0.1, curve, resultSurfaces1.front(), 0.1));\n\t\tCHECK(IsCurveOnSurf(1000, 0.1, curve, resultSurfaces1.back(), 0.1));\n\t\tdouble bsp3s = GetSurfaceProperties(MakeFace(resultSurfaces1.front(), 0.0), g, true, true);\n\t\tdouble bsp4s = GetSurfaceProperties(MakeFace(resultSurfaces.front(), 0.0), g, true, true);\n\t\tCHECK(bsp3s == Approx(bsp4s).margin(0.02));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static std::pair<NURBSSweepStatus, std::vector<std::shared_ptr<Geom3BSplineSurface>>> SweepWithReferenceCurve(const std::shared_ptr<Geom3BSplineCurve>& guide, const std::shared_ptr<Geom3BSplineCurve>& reference, const LawFunction& angleLaw, const LawFunction& length1Law, const LawFunction& length2Law, const std::shared_ptr<Geom3BSplineCurve>& spine, double spineLeftBound, double spineRightBound),\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <filesystem>\n#include <fstream>\n#include <random>\n#include <sstream>\n#include <nurbs/NURBSAPIGetGeometry.hpp>\n#include <nurbs/NURBSAPIConicalSweep.hpp>\n#include <boolean/BoolBRepCut.hpp>\n#include <common/CartesianCoordinateSystem.hpp>\n#include <common/IndexMap.hpp>\n#include <common/QuaternionT.hpp>\n#include <geomAlgo/LawBSpline.hpp>\n#include <geomAlgo/LawConstant.hpp>\n#include <nurbs/NURBSAPISmooth.hpp>\n#include <geomAlgo/MakeConic2FromConstraints.hpp>\n#include <geometry/Adaptor3CurveOnSurface.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/AdaptorGeom3Surface.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2Circle.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/Geom2Hyperbola.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3BSplineCurve.hpp>\n#include <geometry/Geom3BSplineSurface.hpp>\n#include <geometry/Geom3Circle.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\n#include <geometry/Geom3Plane.hpp>\n#include <geometry/Geom3SphericalSurface.hpp>\n#include <geometry/Geom3Surface.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include <geometry/Geom3TrimmedSurface.hpp>\n#include <geometry/GeomAPIExtremaCurveCurve3.hpp>\n#include <geometry/GeomAPIProjectPointOnCurve2.hpp>\n#include <geometry/GeomAPIProjectPointOnCurve3.hpp>\n#include <geometry/GeomAPIProjectPointOnSurface.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/GlobalProperty.hpp>\n#include <healing/ShapeFixTool.hpp>\n#include <io/STLTool.hpp>\n#include <math/Sphere.hpp>\n#include <math/TriangularMesh.hpp>\n#include <modeling/CopyShape.hpp>\n#include <modeling/MakeBox.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeFace.hpp>\n#include <modeling/MakePrism.hpp>\n#include <modeling/MakeRevol.hpp>\n#include <modeling/MakeShapeTool.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <modeling/MakeWire.hpp>\n#include <modeling/TransformShape.hpp>\n#include <nurbs/NURBSAPIApprox.hpp>\n#include <nurbs/NURBSAPIBuildCurve.hpp>\n#include <nurbs/NURBSAPICircularSweep.hpp>\n#include <nurbs/NURBSAPIConvert.hpp>\n#include <nurbs/NURBSAPICurveNetworkSurface.hpp>\n#include <nurbs/NURBSAPIExplicitSweep.hpp>\n#include <nurbs/NURBSAPIExplode.hpp>\n#include <nurbs/NURBSAPIExtend.hpp>\n#include <nurbs/NURBSAPIInterpolate.hpp>\n#include <nurbs/NURBSAPIJoin.hpp>\n#include <nurbs/NURBSAPILinearSweep.hpp>\n#include <nurbs/NURBSAPILoft.hpp>\n#include <nurbs/NURBSAPIMakeNURBSFromBoundaries.hpp>\n#include <nurbs/NURBSAPIMatch.hpp>\n#include <nurbs/NURBSAPIModifyEndToPlane.hpp>\n#include <nurbs/NURBSAPIOffsetCurveOnSurface.hpp>\n#include <nurbs/NURBSAPIProject.hpp>\n#include <nurbs/NURBSAPIRebuild.hpp>\n#include <nurbs/NURBSAPIReplaceEdge.hpp>\n#include <nurbs/NURBSAPISweep.hpp>\n#include <nurbs/NURBSAPISweep2.hpp>\n#include <nurbs/NURBSAPISweepRotation.hpp>\n#include <nurbs/NURBSAPITrim.hpp>\n#include <nurbs/NURBSAPIUntrim.hpp>\n#include <nurbs/NURBSLinearSweepWithDraftDirectionLength.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <offset/MakePipe.hpp>\n#include <offset/MakePipeShell.hpp>\n#include <topology/BRepAdaptorCurve2.hpp>\n#include <topology/BRepAdaptorCurve3.hpp>\n#include <topology/BRepAdaptorSurface.hpp>\n#include <topology/BRepGlobalProperty.hpp>\n#include <topology/BRepTool.hpp>\n#include <topology/TopoBuilder.hpp>\n#include <topology/TopoCompound.hpp>\n#include <topology/TopoEdge.hpp>\n#include <topology/TopoExplorer.hpp>\n#include <topology/TopoExplorerTool.hpp>\n#include <topology/TopoFace.hpp>\n#include <topology/TopoShape.hpp>\n#include <topology/TopoShell.hpp>\n#include <topology/TopoTool.hpp>\n#include <topology/TopoVertex.hpp>\n#include <topology/TopoWire.hpp>\n#include <topology/WireExplorer.hpp>\n#include <topomesh/BRepMeshIncrementalMesh.hpp>\n#include <nurbs/NURBSAPIBlend.hpp>\n#include <topology/BRepExtremaDistShapeShape.hpp>\n#include <math/LineT.hpp>\n#include <hatch/BRepClassificationTools.hpp>\nusing namespace AMCAX;\nnamespace\n{\n\tstd::shared_ptr<Geom3BSplineCurve> CurveChooser(const int id, const std::shared_ptr<Geom3BSplineCurve>& curve0, const std::shared_ptr<Geom3BSplineCurve>& curve1, const std::shared_ptr<Geom3BSplineCurve>& curve2)\n\t{\n\t\tstd::shared_ptr<Geom3BSplineCurve> result;\n\t\tswitch (id)\n\t\t{\n\t\tcase 0:\n\t\t{\n\t\t\tresult = curve0;\n\t\t\tbreak;\n\t\t}\n\t\tcase 1:\n\t\t{\n\t\t\tresult = curve1;\n\t\t\tbreak;\n\t\t}\n\t\tcase 2:\n\t\t{\n\t\t\tresult = curve2;\n\t\t\tbreak;\n\t\t}\n\t\t}\n\t\treturn result;\n\t}\n} \n#include<catch.hpp>\n#include<testHelper.h>\n#include <filesystem>\n#include <fstream>\n#include <random>\n#include <sstream>\n#include <nurbs/NURBSAPIGetGeometry.hpp>\n#include <nurbs/NURBSAPIConicalSweep.hpp>\n#include <boolean/BoolBRepCut.hpp>\n#include <common/CartesianCoordinateSystem.hpp>\n#include <common/IndexMap.hpp>\n#include <common/QuaternionT.hpp>\n#include <geomAlgo/LawBSpline.hpp>\n#include <geomAlgo/LawConstant.hpp>\n#include <nurbs/NURBSAPISmooth.hpp>\n#include <geomAlgo/MakeConic2FromConstraints.hpp>\n#include <geometry/Adaptor3CurveOnSurface.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/AdaptorGeom3Surface.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2Circle.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/Geom2Hyperbola.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3BSplineCurve.hpp>\n#include <geometry/Geom3BSplineSurface.hpp>\n#include <geometry/Geom3Circle.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\n#include <geometry/Geom3Plane.hpp>\n#include <geometry/Geom3SphericalSurface.hpp>\n#include <geometry/Geom3Surface.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include <geometry/Geom3TrimmedSurface.hpp>\n#include <geometry/GeomAPIExtremaCurveCurve3.hpp>\n#include <geometry/GeomAPIProjectPointOnCurve2.hpp>\n#include <geometry/GeomAPIProjectPointOnCurve3.hpp>\n#include <geometry/GeomAPIProjectPointOnSurface.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/GlobalProperty.hpp>\n#include <healing/ShapeFixTool.hpp>\n#include <io/STLTool.hpp>\n#include <math/Sphere.hpp>\n#include <math/TriangularMesh.hpp>\n#include <modeling/CopyShape.hpp>\n#include <modeling/MakeBox.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeFace.hpp>\n#include <modeling/MakePrism.hpp>\n#include <modeling/MakeRevol.hpp>\n#include <modeling/MakeShapeTool.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <modeling/MakeWire.hpp>\n#include <modeling/TransformShape.hpp>\n#include <nurbs/NURBSAPIApprox.hpp>\n#include <nurbs/NURBSAPIBuildCurve.hpp>\n#include <nurbs/NURBSAPICircularSweep.hpp>\n#include <nurbs/NURBSAPIConvert.hpp>\n#include <nurbs/NURBSAPICurveNetworkSurface.hpp>\n#include <nurbs/NURBSAPIExplicitSweep.hpp>\n#include <nurbs/NURBSAPIExplode.hpp>\n#include <nurbs/NURBSAPIExtend.hpp>\n#include <nurbs/NURBSAPIInterpolate.hpp>\n#include <nurbs/NURBSAPIJoin.hpp>\n#include <nurbs/NURBSAPILinearSweep.hpp>\n#include <nurbs/NURBSAPILoft.hpp>\n#include <nurbs/NURBSAPIMakeNURBSFromBoundaries.hpp>\n#include <nurbs/NURBSAPIMatch.hpp>\n#include <nurbs/NURBSAPIModifyEndToPlane.hpp>\n#include <nurbs/NURBSAPIOffsetCurveOnSurface.hpp>\n#include <nurbs/NURBSAPIProject.hpp>\n#include <nurbs/NURBSAPIRebuild.hpp>\n#include <nurbs/NURBSAPIReplaceEdge.hpp>\n#include <nurbs/NURBSAPISweep.hpp>\n#include <nurbs/NURBSAPISweep2.hpp>\n#include <nurbs/NURBSAPISweepRotation.hpp>\n#include <nurbs/NURBSAPITrim.hpp>\n#include <nurbs/NURBSAPIUntrim.hpp>\n#include <nurbs/NURBSLinearSweepWithDraftDirectionLength.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <offset/MakePipe.hpp>\n#include <offset/MakePipeShell.hpp>\n#include <topology/BRepAdaptorCurve2.hpp>\n#include <topology/BRepAdaptorCurve3.hpp>\n#include <topology/BRepAdaptorSurface.hpp>\n#include <topology/BRepGlobalProperty.hpp>\n#include <topology/BRepTool.hpp>\n#include <topology/TopoBuilder.hpp>\n#include <topology/TopoCompound.hpp>\n#include <topology/TopoEdge.hpp>\n#include <topology/TopoExplorer.hpp>\n#include <topology/TopoExplorerTool.hpp>\n#include <topology/TopoFace.hpp>\n#include <topology/TopoShape.hpp>\n#include <topology/TopoShell.hpp>\n#include <topology/TopoTool.hpp>\n#include <topology/TopoVertex.hpp>\n#include <topology/TopoWire.hpp>\n#include <topology/WireExplorer.hpp>\n#include <topomesh/BRepMeshIncrementalMesh.hpp>\n#include <nurbs/NURBSAPIBlend.hpp>\n#include <topology/BRepExtremaDistShapeShape.hpp>\n#include <math/LineT.hpp>\n#include <hatch/BRepClassificationTools.hpp>\nusing namespace AMCAX;\nnamespace\n{\n\tstd::shared_ptr<Geom3BSplineCurve> CurveChooser(const int id, const std::shared_ptr<Geom3BSplineCurve>& curve0, const std::shared_ptr<Geom3BSplineCurve>& curve1, const std::shared_ptr<Geom3BSplineCurve>& curve2)\n\t{\n\t\tstd::shared_ptr<Geom3BSplineCurve> result;\n\t\tswitch (id)\n\t\t{\n\t\tcase 0:\n\t\t{\n\t\t\tresult = curve0;\n\t\t\tbreak;\n\t\t}\n\t\tcase 1:\n\t\t{\n\t\t\tresult = curve1;\n\t\t\tbreak;\n\t\t}\n\t\tcase 2:\n\t\t{\n\t\t\tresult = curve2;\n\t\t\tbreak;\n\t\t}\n\t\t}\n\t\treturn result;\n\t}\n;\n\tSECTION(\"TestLinearSweepWithReferenceCurve2()\")\n\t{\n\t\tstd::string filedir = INPUT_PATH_PREFIX \"/TestNURBS/TestLinearSweepWithReferenceCurve2/\";\n\t\tauto guide = ReadBRepCurve(filedir + \"guide.brep\");\n\t\tCHECK(OCCTIO::OCCTTool::Write(MakeEdge(guide), OUTPUT_PATH_PREFIX \"TestLinearSweepWithReferenceCurve2_guide.brep\"));\n\t\tauto ref = ReadBRepCurve(filedir + \"reference.brep\");\n\t\tCHECK(OCCTIO::OCCTTool::Write(MakeEdge(ref), OUTPUT_PATH_PREFIX \"TestLinearSweepWithReferenceCurve2_ref.brep\"));\n\t\tauto spine = guide;\n\t\tLawConstant degreeLaw;\n\t\tdegreeLaw.Set(M_PI / 3.0, 0.0, 1.0);\n\t\tLawConstant length1Law;\n\t\tlength1Law.Set(3, 0.0, 1.0);\n\t\tLawConstant length2Law;\n\t\tlength2Law.Set(3, 0.0, 1.0);\n\t\tauto [status, surfaces] = NURBSAPILinearSweep::SweepWithReferenceCurve(guide, ref, degreeLaw, length1Law, length2Law, spine, spine->FirstParameter(), spine->LastParameter());\n\t\tCHECK(status == NURBSSweepStatus::Success);\n\t\tif (status == NURBSSweepStatus::Success)\n\t\t{\n\t\t\tCHECK(OCCTIO::OCCTTool::Write(MakeFace(surfaces.front(), 0.0), OUTPUT_PATH_PREFIX \"TestLinearSweepWithReferenceCurve2_result.brep\"));\n\t\t\tCHECK(OCCTIO::OCCTTool::Write(MakeFace(surfaces[1], 0.0), OUTPUT_PATH_PREFIX \"TestLinearSweepWithReferenceCurve2_result1.brep\"));\n\t\t\tCHECK(OCCTIO::OCCTTool::Write(MakeFace(surfaces[2], 0.0), OUTPUT_PATH_PREFIX \"TestLinearSweepWithReferenceCurve2_result2.brep\"));\n\t\t}\n\t\tCHECK(IsCurveOnSurf(1000, 0.1, guide, surfaces.front(), 0.1));\n\t\tIndexSet<TopoShape> newshapeEdge1;\n\t\tTopoExplorerTool::MapShapes(MakeFace(surfaces.front(), 0.0), ShapeType::Edge, newshapeEdge1);\n\t\tAMCAX::BRepExtremaDistShapeShape len1(newshapeEdge1[0], MakeEdge(guide));\n\t\tAMCAX::BRepExtremaDistShapeShape len2(newshapeEdge1[2], MakeEdge(guide));\n\t\tCHECK(len1.Value() == Approx(3.0).margin(0.1));\n\t\tCHECK(len2.Value() == Approx(3.0).margin(0.1));\n\t\tguide->IncreaseDegree(11);\n\t\tref->IncreaseDegree(11);\n\t\tspine->IncreaseDegree(11);\n\t\tauto [status1, surfaces1] = NURBSAPILinearSweep::SweepWithReferenceCurve(guide, ref, degreeLaw, length1Law, length2Law, spine, spine->FirstParameter(), spine->LastParameter());\n\t\tCHECK(status1 == NURBSSweepStatus::Success);\n\t\tif (status1 == NURBSSweepStatus::Success)\n\t\t{\n\t\t\tdouble bsp3s = GetSurfaceProperties(MakeFace(surfaces1.front(), 0.0), g, true, true);\n\t\t\tdouble bsp4s = GetSurfaceProperties(MakeFace(surfaces.front(), 0.0), g, true, true);\n\t\t\tCHECK(bsp3s == Approx(bsp4s).margin(0.02));\n\t\t}\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static std::pair<NURBSSweepStatus, std::vector<std::shared_ptr<Geom3BSplineSurface>>> SweepWithReferenceSurface(const std::shared_ptr<Geom3BSplineCurve>& guide, const std::shared_ptr<Geom3BSplineSurface>& reference, const LawFunction& angleLaw, const LawFunction& length1Law, const LawFunction& length2Law, const std::shared_ptr<Geom3BSplineCurve>& spine, double spineLeftBound, double spineRightBound),\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <filesystem>\n#include <fstream>\n#include <random>\n#include <sstream>\n#include <nurbs/NURBSAPIGetGeometry.hpp>\n#include <nurbs/NURBSAPIConicalSweep.hpp>\n#include <boolean/BoolBRepCut.hpp>\n#include <common/CartesianCoordinateSystem.hpp>\n#include <common/IndexMap.hpp>\n#include <common/QuaternionT.hpp>\n#include <geomAlgo/LawBSpline.hpp>\n#include <geomAlgo/LawConstant.hpp>\n#include <nurbs/NURBSAPISmooth.hpp>\n#include <geomAlgo/MakeConic2FromConstraints.hpp>\n#include <geometry/Adaptor3CurveOnSurface.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/AdaptorGeom3Surface.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2Circle.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/Geom2Hyperbola.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3BSplineCurve.hpp>\n#include <geometry/Geom3BSplineSurface.hpp>\n#include <geometry/Geom3Circle.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\n#include <geometry/Geom3Plane.hpp>\n#include <geometry/Geom3SphericalSurface.hpp>\n#include <geometry/Geom3Surface.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include <geometry/Geom3TrimmedSurface.hpp>\n#include <geometry/GeomAPIExtremaCurveCurve3.hpp>\n#include <geometry/GeomAPIProjectPointOnCurve2.hpp>\n#include <geometry/GeomAPIProjectPointOnCurve3.hpp>\n#include <geometry/GeomAPIProjectPointOnSurface.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/GlobalProperty.hpp>\n#include <healing/ShapeFixTool.hpp>\n#include <io/STLTool.hpp>\n#include <math/Sphere.hpp>\n#include <math/TriangularMesh.hpp>\n#include <modeling/CopyShape.hpp>\n#include <modeling/MakeBox.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeFace.hpp>\n#include <modeling/MakePrism.hpp>\n#include <modeling/MakeRevol.hpp>\n#include <modeling/MakeShapeTool.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <modeling/MakeWire.hpp>\n#include <modeling/TransformShape.hpp>\n#include <nurbs/NURBSAPIApprox.hpp>\n#include <nurbs/NURBSAPIBuildCurve.hpp>\n#include <nurbs/NURBSAPICircularSweep.hpp>\n#include <nurbs/NURBSAPIConvert.hpp>\n#include <nurbs/NURBSAPICurveNetworkSurface.hpp>\n#include <nurbs/NURBSAPIExplicitSweep.hpp>\n#include <nurbs/NURBSAPIExplode.hpp>\n#include <nurbs/NURBSAPIExtend.hpp>\n#include <nurbs/NURBSAPIInterpolate.hpp>\n#include <nurbs/NURBSAPIJoin.hpp>\n#include <nurbs/NURBSAPILinearSweep.hpp>\n#include <nurbs/NURBSAPILoft.hpp>\n#include <nurbs/NURBSAPIMakeNURBSFromBoundaries.hpp>\n#include <nurbs/NURBSAPIMatch.hpp>\n#include <nurbs/NURBSAPIModifyEndToPlane.hpp>\n#include <nurbs/NURBSAPIOffsetCurveOnSurface.hpp>\n#include <nurbs/NURBSAPIProject.hpp>\n#include <nurbs/NURBSAPIRebuild.hpp>\n#include <nurbs/NURBSAPIReplaceEdge.hpp>\n#include <nurbs/NURBSAPISweep.hpp>\n#include <nurbs/NURBSAPISweep2.hpp>\n#include <nurbs/NURBSAPISweepRotation.hpp>\n#include <nurbs/NURBSAPITrim.hpp>\n#include <nurbs/NURBSAPIUntrim.hpp>\n#include <nurbs/NURBSLinearSweepWithDraftDirectionLength.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <offset/MakePipe.hpp>\n#include <offset/MakePipeShell.hpp>\n#include <topology/BRepAdaptorCurve2.hpp>\n#include <topology/BRepAdaptorCurve3.hpp>\n#include <topology/BRepAdaptorSurface.hpp>\n#include <topology/BRepGlobalProperty.hpp>\n#include <topology/BRepTool.hpp>\n#include <topology/TopoBuilder.hpp>\n#include <topology/TopoCompound.hpp>\n#include <topology/TopoEdge.hpp>\n#include <topology/TopoExplorer.hpp>\n#include <topology/TopoExplorerTool.hpp>\n#include <topology/TopoFace.hpp>\n#include <topology/TopoShape.hpp>\n#include <topology/TopoShell.hpp>\n#include <topology/TopoTool.hpp>\n#include <topology/TopoVertex.hpp>\n#include <topology/TopoWire.hpp>\n#include <topology/WireExplorer.hpp>\n#include <topomesh/BRepMeshIncrementalMesh.hpp>\n#include <nurbs/NURBSAPIBlend.hpp>\n#include <topology/BRepExtremaDistShapeShape.hpp>\n#include <math/LineT.hpp>\n#include <hatch/BRepClassificationTools.hpp>\nusing namespace AMCAX;\nnamespace\n{\n\tstd::shared_ptr<Geom3BSplineCurve> CurveChooser(const int id, const std::shared_ptr<Geom3BSplineCurve>& curve0, const std::shared_ptr<Geom3BSplineCurve>& curve1, const std::shared_ptr<Geom3BSplineCurve>& curve2)\n\t{\n\t\tstd::shared_ptr<Geom3BSplineCurve> result;\n\t\tswitch (id)\n\t\t{\n\t\tcase 0:\n\t\t{\n\t\t\tresult = curve0;\n\t\t\tbreak;\n\t\t}\n\t\tcase 1:\n\t\t{\n\t\t\tresult = curve1;\n\t\t\tbreak;\n\t\t}\n\t\tcase 2:\n\t\t{\n\t\t\tresult = curve2;\n\t\t\tbreak;\n\t\t}\n\t\t}\n\t\treturn result;\n\t}\n} \n#include<catch.hpp>\n#include<testHelper.h>\n#include <filesystem>\n#include <fstream>\n#include <random>\n#include <sstream>\n#include <nurbs/NURBSAPIGetGeometry.hpp>\n#include <nurbs/NURBSAPIConicalSweep.hpp>\n#include <boolean/BoolBRepCut.hpp>\n#include <common/CartesianCoordinateSystem.hpp>\n#include <common/IndexMap.hpp>\n#include <common/QuaternionT.hpp>\n#include <geomAlgo/LawBSpline.hpp>\n#include <geomAlgo/LawConstant.hpp>\n#include <nurbs/NURBSAPISmooth.hpp>\n#include <geomAlgo/MakeConic2FromConstraints.hpp>\n#include <geometry/Adaptor3CurveOnSurface.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/AdaptorGeom3Surface.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2Circle.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/Geom2Hyperbola.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3BSplineCurve.hpp>\n#include <geometry/Geom3BSplineSurface.hpp>\n#include <geometry/Geom3Circle.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\n#include <geometry/Geom3Plane.hpp>\n#include <geometry/Geom3SphericalSurface.hpp>\n#include <geometry/Geom3Surface.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include <geometry/Geom3TrimmedSurface.hpp>\n#include <geometry/GeomAPIExtremaCurveCurve3.hpp>\n#include <geometry/GeomAPIProjectPointOnCurve2.hpp>\n#include <geometry/GeomAPIProjectPointOnCurve3.hpp>\n#include <geometry/GeomAPIProjectPointOnSurface.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/GlobalProperty.hpp>\n#include <healing/ShapeFixTool.hpp>\n#include <io/STLTool.hpp>\n#include <math/Sphere.hpp>\n#include <math/TriangularMesh.hpp>\n#include <modeling/CopyShape.hpp>\n#include <modeling/MakeBox.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeFace.hpp>\n#include <modeling/MakePrism.hpp>\n#include <modeling/MakeRevol.hpp>\n#include <modeling/MakeShapeTool.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <modeling/MakeWire.hpp>\n#include <modeling/TransformShape.hpp>\n#include <nurbs/NURBSAPIApprox.hpp>\n#include <nurbs/NURBSAPIBuildCurve.hpp>\n#include <nurbs/NURBSAPICircularSweep.hpp>\n#include <nurbs/NURBSAPIConvert.hpp>\n#include <nurbs/NURBSAPICurveNetworkSurface.hpp>\n#include <nurbs/NURBSAPIExplicitSweep.hpp>\n#include <nurbs/NURBSAPIExplode.hpp>\n#include <nurbs/NURBSAPIExtend.hpp>\n#include <nurbs/NURBSAPIInterpolate.hpp>\n#include <nurbs/NURBSAPIJoin.hpp>\n#include <nurbs/NURBSAPILinearSweep.hpp>\n#include <nurbs/NURBSAPILoft.hpp>\n#include <nurbs/NURBSAPIMakeNURBSFromBoundaries.hpp>\n#include <nurbs/NURBSAPIMatch.hpp>\n#include <nurbs/NURBSAPIModifyEndToPlane.hpp>\n#include <nurbs/NURBSAPIOffsetCurveOnSurface.hpp>\n#include <nurbs/NURBSAPIProject.hpp>\n#include <nurbs/NURBSAPIRebuild.hpp>\n#include <nurbs/NURBSAPIReplaceEdge.hpp>\n#include <nurbs/NURBSAPISweep.hpp>\n#include <nurbs/NURBSAPISweep2.hpp>\n#include <nurbs/NURBSAPISweepRotation.hpp>\n#include <nurbs/NURBSAPITrim.hpp>\n#include <nurbs/NURBSAPIUntrim.hpp>\n#include <nurbs/NURBSLinearSweepWithDraftDirectionLength.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <offset/MakePipe.hpp>\n#include <offset/MakePipeShell.hpp>\n#include <topology/BRepAdaptorCurve2.hpp>\n#include <topology/BRepAdaptorCurve3.hpp>\n#include <topology/BRepAdaptorSurface.hpp>\n#include <topology/BRepGlobalProperty.hpp>\n#include <topology/BRepTool.hpp>\n#include <topology/TopoBuilder.hpp>\n#include <topology/TopoCompound.hpp>\n#include <topology/TopoEdge.hpp>\n#include <topology/TopoExplorer.hpp>\n#include <topology/TopoExplorerTool.hpp>\n#include <topology/TopoFace.hpp>\n#include <topology/TopoShape.hpp>\n#include <topology/TopoShell.hpp>\n#include <topology/TopoTool.hpp>\n#include <topology/TopoVertex.hpp>\n#include <topology/TopoWire.hpp>\n#include <topology/WireExplorer.hpp>\n#include <topomesh/BRepMeshIncrementalMesh.hpp>\n#include <nurbs/NURBSAPIBlend.hpp>\n#include <topology/BRepExtremaDistShapeShape.hpp>\n#include <math/LineT.hpp>\n#include <hatch/BRepClassificationTools.hpp>\nusing namespace AMCAX;\nnamespace\n{\n\tstd::shared_ptr<Geom3BSplineCurve> CurveChooser(const int id, const std::shared_ptr<Geom3BSplineCurve>& curve0, const std::shared_ptr<Geom3BSplineCurve>& curve1, const std::shared_ptr<Geom3BSplineCurve>& curve2)\n\t{\n\t\tstd::shared_ptr<Geom3BSplineCurve> result;\n\t\tswitch (id)\n\t\t{\n\t\tcase 0:\n\t\t{\n\t\t\tresult = curve0;\n\t\t\tbreak;\n\t\t}\n\t\tcase 1:\n\t\t{\n\t\t\tresult = curve1;\n\t\t\tbreak;\n\t\t}\n\t\tcase 2:\n\t\t{\n\t\t\tresult = curve2;\n\t\t\tbreak;\n\t\t}\n\t\t}\n\t\treturn result;\n\t}\n;\n\tSECTION(\"TestLinearSweepWithReferenceSurface()\")\n\t{\n\t\tstd::string filedir = INPUT_PATH_PREFIX \"/TestNURBS/TestLinearSweepWithReferenceSurface/\";\n\t\tauto guide = ReadBRepCurve(filedir + \"guide.brep\");\n\t\tCHECK(OCCTIO::OCCTTool::Write(MakeEdge(guide), OUTPUT_PATH_PREFIX \"TestLinearSweepWithReferenceSurface_guide.brep\"));\n\t\tauto surface = ReadBRepSurface(filedir + \"surface.brep\");\n\t\tCHECK(OCCTIO::OCCTTool::Write(MakeFace(surface, 0.0), OUTPUT_PATH_PREFIX \"TestLinearSweepWithReferenceSurface_surface.brep\"));\n\t\tLawConstant degreeLaw;\n\t\tdegreeLaw.Set(M_PI_4, 0.0, 1.0);\n\t\tLawConstant length1Law;\n\t\tlength1Law.Set(3, 0.0, 1.0);\n\t\tLawConstant length2Law;\n\t\tlength2Law.Set(5, 0.0, 1.0);\n\t\tauto [status, surfaces] = NURBSAPILinearSweep::SweepWithReferenceSurface(guide, surface, degreeLaw, length1Law, length2Law, guide, guide->FirstParameter(), guide->LastParameter());\n\t\tCHECK(status == NURBSSweepStatus::Success);\n\t\tif (status == NURBSSweepStatus::Success)\n\t\t{\n\t\t\tCHECK(OCCTIO::OCCTTool::Write(MakeFace(surfaces.front(), 0.0), OUTPUT_PATH_PREFIX \"TestLinearSweepWithReferenceSurface_result.brep\"));\n\t\t\tCHECK(IsCurveOnSurf(1000, 0.1, guide, surface));\n\t\t\tCHECK(IsCurveOnSurf(1000, 0.1, guide, surfaces.front()));\n\t\t\tIndexSet<TopoShape> newshapeEdge1;\n\t\t\tTopoExplorerTool::MapShapes(MakeFace(surfaces.front(), 0.0), ShapeType::Edge, newshapeEdge1);\n\t\t\tAMCAX::BRepExtremaDistShapeShape len1(newshapeEdge1[0], MakeEdge(guide));\n\t\t\tAMCAX::BRepExtremaDistShapeShape len2(newshapeEdge1[2], MakeEdge(guide));\n\t\t\tCHECK(len1.Value() == Approx(3.0).margin(0.1));\n\t\t\tCHECK(len2.Value() == Approx(5.0).margin(0.1));\n\t\t}\n\t\tguide->IncreaseDegree(11);\n\t\tsurface->IncreaseDegree(11,11);\n\t\tauto [status1, surfaces1] = NURBSAPILinearSweep::SweepWithReferenceSurface(guide, surface, degreeLaw, length1Law, length2Law, guide, guide->FirstParameter(), guide->LastParameter());\n\t\tCHECK(status1 == NURBSSweepStatus::Success);\n\t\tif (status1 == NURBSSweepStatus::Success)\n\t\t{\n\t\t\tCHECK(OCCTIO::OCCTTool::Write(MakeFace(surfaces1.front(), 0.0), OUTPUT_PATH_PREFIX \"TestLinearSweepWithReferenceSurface_degree11result.brep\"));\n\t\t\tCHECK(IsCurveOnSurf(1000, 0.1, guide, surface));\n\t\t\tCHECK(IsCurveOnSurf(1000, 0.1, guide, surfaces1.front()));\n\t\t\tIndexSet<TopoShape> newshapeEdge1;\n\t\t\tTopoExplorerTool::MapShapes(MakeFace(surfaces1.front(), 0.0), ShapeType::Edge, newshapeEdge1);\n\t\t\tAMCAX::BRepExtremaDistShapeShape len1(newshapeEdge1[0], MakeEdge(guide));\n\t\t\tAMCAX::BRepExtremaDistShapeShape len2(newshapeEdge1[2], MakeEdge(guide));\n\t\t\tCHECK(len1.Value() == Approx(3.0).margin(0.1));\n\t\t\tCHECK(len2.Value() == Approx(5.0).margin(0.1));\n\t\t\tdouble bsp3s = GetSurfaceProperties(MakeFace(surfaces1.front(), 0.0), g, true, true);\n\t\t\tdouble bsp4s = GetSurfaceProperties(MakeFace(surfaces.front(), 0.0), g, true, true);\n\t\t\tCHECK(bsp3s == Approx(bsp4s).margin(0.02));\n\t\t}\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static std::pair<NURBSSweepStatus, std::shared_ptr<Geom3BSplineSurface>> SweepWithLimitAndMiddle(const std::shared_ptr<Geom3BSplineCurve>& guide1, const std::shared_ptr<Geom3BSplineCurve>& guide2, const std::shared_ptr<Geom3BSplineCurve>& spine, double spineLeftBound, double spineRightBound),\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <filesystem>\n#include <fstream>\n#include <random>\n#include <sstream>\n#include <nurbs/NURBSAPIGetGeometry.hpp>\n#include <nurbs/NURBSAPIConicalSweep.hpp>\n#include <boolean/BoolBRepCut.hpp>\n#include <common/CartesianCoordinateSystem.hpp>\n#include <common/IndexMap.hpp>\n#include <common/QuaternionT.hpp>\n#include <geomAlgo/LawBSpline.hpp>\n#include <geomAlgo/LawConstant.hpp>\n#include <nurbs/NURBSAPISmooth.hpp>\n#include <geomAlgo/MakeConic2FromConstraints.hpp>\n#include <geometry/Adaptor3CurveOnSurface.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/AdaptorGeom3Surface.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2Circle.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/Geom2Hyperbola.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3BSplineCurve.hpp>\n#include <geometry/Geom3BSplineSurface.hpp>\n#include <geometry/Geom3Circle.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\n#include <geometry/Geom3Plane.hpp>\n#include <geometry/Geom3SphericalSurface.hpp>\n#include <geometry/Geom3Surface.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include <geometry/Geom3TrimmedSurface.hpp>\n#include <geometry/GeomAPIExtremaCurveCurve3.hpp>\n#include <geometry/GeomAPIProjectPointOnCurve2.hpp>\n#include <geometry/GeomAPIProjectPointOnCurve3.hpp>\n#include <geometry/GeomAPIProjectPointOnSurface.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/GlobalProperty.hpp>\n#include <healing/ShapeFixTool.hpp>\n#include <io/STLTool.hpp>\n#include <math/Sphere.hpp>\n#include <math/TriangularMesh.hpp>\n#include <modeling/CopyShape.hpp>\n#include <modeling/MakeBox.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeFace.hpp>\n#include <modeling/MakePrism.hpp>\n#include <modeling/MakeRevol.hpp>\n#include <modeling/MakeShapeTool.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <modeling/MakeWire.hpp>\n#include <modeling/TransformShape.hpp>\n#include <nurbs/NURBSAPIApprox.hpp>\n#include <nurbs/NURBSAPIBuildCurve.hpp>\n#include <nurbs/NURBSAPICircularSweep.hpp>\n#include <nurbs/NURBSAPIConvert.hpp>\n#include <nurbs/NURBSAPICurveNetworkSurface.hpp>\n#include <nurbs/NURBSAPIExplicitSweep.hpp>\n#include <nurbs/NURBSAPIExplode.hpp>\n#include <nurbs/NURBSAPIExtend.hpp>\n#include <nurbs/NURBSAPIInterpolate.hpp>\n#include <nurbs/NURBSAPIJoin.hpp>\n#include <nurbs/NURBSAPILinearSweep.hpp>\n#include <nurbs/NURBSAPILoft.hpp>\n#include <nurbs/NURBSAPIMakeNURBSFromBoundaries.hpp>\n#include <nurbs/NURBSAPIMatch.hpp>\n#include <nurbs/NURBSAPIModifyEndToPlane.hpp>\n#include <nurbs/NURBSAPIOffsetCurveOnSurface.hpp>\n#include <nurbs/NURBSAPIProject.hpp>\n#include <nurbs/NURBSAPIRebuild.hpp>\n#include <nurbs/NURBSAPIReplaceEdge.hpp>\n#include <nurbs/NURBSAPISweep.hpp>\n#include <nurbs/NURBSAPISweep2.hpp>\n#include <nurbs/NURBSAPISweepRotation.hpp>\n#include <nurbs/NURBSAPITrim.hpp>\n#include <nurbs/NURBSAPIUntrim.hpp>\n#include <nurbs/NURBSLinearSweepWithDraftDirectionLength.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <offset/MakePipe.hpp>\n#include <offset/MakePipeShell.hpp>\n#include <topology/BRepAdaptorCurve2.hpp>\n#include <topology/BRepAdaptorCurve3.hpp>\n#include <topology/BRepAdaptorSurface.hpp>\n#include <topology/BRepGlobalProperty.hpp>\n#include <topology/BRepTool.hpp>\n#include <topology/TopoBuilder.hpp>\n#include <topology/TopoCompound.hpp>\n#include <topology/TopoEdge.hpp>\n#include <topology/TopoExplorer.hpp>\n#include <topology/TopoExplorerTool.hpp>\n#include <topology/TopoFace.hpp>\n#include <topology/TopoShape.hpp>\n#include <topology/TopoShell.hpp>\n#include <topology/TopoTool.hpp>\n#include <topology/TopoVertex.hpp>\n#include <topology/TopoWire.hpp>\n#include <topology/WireExplorer.hpp>\n#include <topomesh/BRepMeshIncrementalMesh.hpp>\n#include <nurbs/NURBSAPIBlend.hpp>\n#include <topology/BRepExtremaDistShapeShape.hpp>\n#include <math/LineT.hpp>\n#include <hatch/BRepClassificationTools.hpp>\nusing namespace AMCAX;\nnamespace\n{\n\tstd::shared_ptr<Geom3BSplineCurve> CurveChooser(const int id, const std::shared_ptr<Geom3BSplineCurve>& curve0, const std::shared_ptr<Geom3BSplineCurve>& curve1, const std::shared_ptr<Geom3BSplineCurve>& curve2)\n\t{\n\t\tstd::shared_ptr<Geom3BSplineCurve> result;\n\t\tswitch (id)\n\t\t{\n\t\tcase 0:\n\t\t{\n\t\t\tresult = curve0;\n\t\t\tbreak;\n\t\t}\n\t\tcase 1:\n\t\t{\n\t\t\tresult = curve1;\n\t\t\tbreak;\n\t\t}\n\t\tcase 2:\n\t\t{\n\t\t\tresult = curve2;\n\t\t\tbreak;\n\t\t}\n\t\t}\n\t\treturn result;\n\t}\n} \n#include<catch.hpp>\n#include<testHelper.h>\n#include <filesystem>\n#include <fstream>\n#include <random>\n#include <sstream>\n#include <nurbs/NURBSAPIGetGeometry.hpp>\n#include <nurbs/NURBSAPIConicalSweep.hpp>\n#include <boolean/BoolBRepCut.hpp>\n#include <common/CartesianCoordinateSystem.hpp>\n#include <common/IndexMap.hpp>\n#include <common/QuaternionT.hpp>\n#include <geomAlgo/LawBSpline.hpp>\n#include <geomAlgo/LawConstant.hpp>\n#include <nurbs/NURBSAPISmooth.hpp>\n#include <geomAlgo/MakeConic2FromConstraints.hpp>\n#include <geometry/Adaptor3CurveOnSurface.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/AdaptorGeom3Surface.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2Circle.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/Geom2Hyperbola.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3BSplineCurve.hpp>\n#include <geometry/Geom3BSplineSurface.hpp>\n#include <geometry/Geom3Circle.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\n#include <geometry/Geom3Plane.hpp>\n#include <geometry/Geom3SphericalSurface.hpp>\n#include <geometry/Geom3Surface.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include <geometry/Geom3TrimmedSurface.hpp>\n#include <geometry/GeomAPIExtremaCurveCurve3.hpp>\n#include <geometry/GeomAPIProjectPointOnCurve2.hpp>\n#include <geometry/GeomAPIProjectPointOnCurve3.hpp>\n#include <geometry/GeomAPIProjectPointOnSurface.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/GlobalProperty.hpp>\n#include <healing/ShapeFixTool.hpp>\n#include <io/STLTool.hpp>\n#include <math/Sphere.hpp>\n#include <math/TriangularMesh.hpp>\n#include <modeling/CopyShape.hpp>\n#include <modeling/MakeBox.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeFace.hpp>\n#include <modeling/MakePrism.hpp>\n#include <modeling/MakeRevol.hpp>\n#include <modeling/MakeShapeTool.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <modeling/MakeWire.hpp>\n#include <modeling/TransformShape.hpp>\n#include <nurbs/NURBSAPIApprox.hpp>\n#include <nurbs/NURBSAPIBuildCurve.hpp>\n#include <nurbs/NURBSAPICircularSweep.hpp>\n#include <nurbs/NURBSAPIConvert.hpp>\n#include <nurbs/NURBSAPICurveNetworkSurface.hpp>\n#include <nurbs/NURBSAPIExplicitSweep.hpp>\n#include <nurbs/NURBSAPIExplode.hpp>\n#include <nurbs/NURBSAPIExtend.hpp>\n#include <nurbs/NURBSAPIInterpolate.hpp>\n#include <nurbs/NURBSAPIJoin.hpp>\n#include <nurbs/NURBSAPILinearSweep.hpp>\n#include <nurbs/NURBSAPILoft.hpp>\n#include <nurbs/NURBSAPIMakeNURBSFromBoundaries.hpp>\n#include <nurbs/NURBSAPIMatch.hpp>\n#include <nurbs/NURBSAPIModifyEndToPlane.hpp>\n#include <nurbs/NURBSAPIOffsetCurveOnSurface.hpp>\n#include <nurbs/NURBSAPIProject.hpp>\n#include <nurbs/NURBSAPIRebuild.hpp>\n#include <nurbs/NURBSAPIReplaceEdge.hpp>\n#include <nurbs/NURBSAPISweep.hpp>\n#include <nurbs/NURBSAPISweep2.hpp>\n#include <nurbs/NURBSAPISweepRotation.hpp>\n#include <nurbs/NURBSAPITrim.hpp>\n#include <nurbs/NURBSAPIUntrim.hpp>\n#include <nurbs/NURBSLinearSweepWithDraftDirectionLength.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <offset/MakePipe.hpp>\n#include <offset/MakePipeShell.hpp>\n#include <topology/BRepAdaptorCurve2.hpp>\n#include <topology/BRepAdaptorCurve3.hpp>\n#include <topology/BRepAdaptorSurface.hpp>\n#include <topology/BRepGlobalProperty.hpp>\n#include <topology/BRepTool.hpp>\n#include <topology/TopoBuilder.hpp>\n#include <topology/TopoCompound.hpp>\n#include <topology/TopoEdge.hpp>\n#include <topology/TopoExplorer.hpp>\n#include <topology/TopoExplorerTool.hpp>\n#include <topology/TopoFace.hpp>\n#include <topology/TopoShape.hpp>\n#include <topology/TopoShell.hpp>\n#include <topology/TopoTool.hpp>\n#include <topology/TopoVertex.hpp>\n#include <topology/TopoWire.hpp>\n#include <topology/WireExplorer.hpp>\n#include <topomesh/BRepMeshIncrementalMesh.hpp>\n#include <nurbs/NURBSAPIBlend.hpp>\n#include <topology/BRepExtremaDistShapeShape.hpp>\n#include <math/LineT.hpp>\n#include <hatch/BRepClassificationTools.hpp>\nusing namespace AMCAX;\nnamespace\n{\n\tstd::shared_ptr<Geom3BSplineCurve> CurveChooser(const int id, const std::shared_ptr<Geom3BSplineCurve>& curve0, const std::shared_ptr<Geom3BSplineCurve>& curve1, const std::shared_ptr<Geom3BSplineCurve>& curve2)\n\t{\n\t\tstd::shared_ptr<Geom3BSplineCurve> result;\n\t\tswitch (id)\n\t\t{\n\t\tcase 0:\n\t\t{\n\t\t\tresult = curve0;\n\t\t\tbreak;\n\t\t}\n\t\tcase 1:\n\t\t{\n\t\t\tresult = curve1;\n\t\t\tbreak;\n\t\t}\n\t\tcase 2:\n\t\t{\n\t\t\tresult = curve2;\n\t\t\tbreak;\n\t\t}\n\t\t}\n\t\treturn result;\n\t}\n;\n\tSECTION(\"TestLinearSweepWithLimitAndMiddle()\")\n\t{\n\t\tstd::string filedir = INPUT_PATH_PREFIX \"/TestNURBS/TestLinearSweepWithLimitAndMiddle/\";\n\t\tauto guide1 = ReadBRepCurve(filedir + \"guide1.brep\");\n\t\tCHECK(OCCTIO::OCCTTool::Write(MakeEdge(guide1), OUTPUT_PATH_PREFIX \"TestLinearSweepWithLimitAndMiddle_guide1.brep\"));\n\t\tauto guide2 = ReadBRepCurve(filedir + \"guide2.brep\");\n\t\tCHECK(OCCTIO::OCCTTool::Write(MakeEdge(guide2), OUTPUT_PATH_PREFIX \"TestLinearSweepWithLimitAndMiddle_guide2.brep\"));\n\t\tauto spineFP = ReadBRepPoint(filedir + \"spineFP.brep\");\n\t\tauto spineLP = ReadBRepPoint(filedir + \"spineLP.brep\");\n\t\tstd::vector<Point3> poles;\n\t\tpoles.push_back(spineFP);\n\t\tpoles.push_back(spineLP);\n\t\tauto spine = NURBSAPIBuildCurve::BuildCurve(poles, 1, false);\n\t\tCHECK(OCCTIO::OCCTTool::Write(MakeEdge(spine), OUTPUT_PATH_PREFIX \"TestLinearSweepWithLimitAndMiddle_spine.brep\"));\n\t\tauto [status, surface] = NURBSAPILinearSweep::SweepWithLimitAndMiddle(guide1, guide2, spine, spine->FirstParameter(), spine->LastParameter());\n\t\tCHECK(status == NURBSSweepStatus::Success);\n\t\tif (status == NURBSSweepStatus::Success)\n\t\t{\n\t\t\tCHECK(OCCTIO::OCCTTool::Write(MakeFace(surface, 0.0), OUTPUT_PATH_PREFIX \"TestLinearSweepWithLimitAndMiddle_result.brep\"));\n\t\t\tCHECK(IsCurveOnSurf(1000, 0.6, guide1, surface, 0.1));\n\t\t\tCHECK(IsCurveOnSurf(1000, 0.6, guide2, surface, 0.1));\n\t\t\tAMCAX::BRepExtremaDistShapeShape len1(MakeFace(surface, 0.0), MakeEdge(guide1));\n\t\t\tAMCAX::BRepExtremaDistShapeShape len2(MakeFace(surface, 0.0), MakeEdge(guide2));\n\t\t\tCHECK(len1.Value() == Approx(0.0).margin(0.1));\n\t\t\tCHECK(len2.Value() == Approx(0.0).margin(0.1));\n\t\t}\n\t\tguide1->IncreaseDegree(5);\n\t\tguide2->IncreaseDegree(5);\n\t\tspine->IncreaseDegree(5);\n\t\tauto [status1, surface1] = NURBSAPILinearSweep::SweepWithLimitAndMiddle(guide1, guide2, spine, spine->FirstParameter(), spine->LastParameter());\n\t\tCHECK(status1 == NURBSSweepStatus::Success);\n\t\tif (status1 == NURBSSweepStatus::Success)\n\t\t{\n\t\t\tCHECK(OCCTIO::OCCTTool::Write(MakeFace(surface1, 0.0), OUTPUT_PATH_PREFIX \"TestLinearSweepWithLimitAndMiddle_degree5result.brep\"));\n\t\t\tCHECK(IsCurveOnSurf(1000, 0.6, guide1, surface1, 0.1));\n\t\t\tCHECK(IsCurveOnSurf(1000, 0.6, guide2, surface1, 0.1));\n\t\t\tAMCAX::BRepExtremaDistShapeShape len1(MakeFace(surface1, 0.0), MakeEdge(guide1));\n\t\t\tAMCAX::BRepExtremaDistShapeShape len2(MakeFace(surface1, 0.0), MakeEdge(guide2));\n\t\t\tCHECK(len1.Value() == Approx(0.0).margin(0.1));\n\t\t\tCHECK(len2.Value() == Approx(0.0).margin(0.1));\n\t\t\tdouble bsp3s = GetSurfaceProperties(MakeFace(surface1, 0.0), g, true, true);\n\t\t\tdouble bsp4s = GetSurfaceProperties(MakeFace(surface, 0.0), g, true, true);\n\t\t\tCHECK(bsp3s == Approx(bsp4s).margin(0.02));\n\t\t}\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static std::pair<NURBSSweepStatus, std::shared_ptr<Geom3BSplineSurface>> SweepWithTwoLimits(const std::shared_ptr<Geom3BSplineCurve>& guide1, const std::shared_ptr<Geom3BSplineCurve>& guide2, const std::shared_ptr<Geom3BSplineCurve>& spine, double spineLeftBound, double spineRightBound, const LawFunction& length1Law, const LawFunction& length2Law),\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <filesystem>\n#include <fstream>\n#include <random>\n#include <sstream>\n#include <nurbs/NURBSAPIGetGeometry.hpp>\n#include <nurbs/NURBSAPIConicalSweep.hpp>\n#include <boolean/BoolBRepCut.hpp>\n#include <common/CartesianCoordinateSystem.hpp>\n#include <common/IndexMap.hpp>\n#include <common/QuaternionT.hpp>\n#include <geomAlgo/LawBSpline.hpp>\n#include <geomAlgo/LawConstant.hpp>\n#include <nurbs/NURBSAPISmooth.hpp>\n#include <geomAlgo/MakeConic2FromConstraints.hpp>\n#include <geometry/Adaptor3CurveOnSurface.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/AdaptorGeom3Surface.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2Circle.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/Geom2Hyperbola.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3BSplineCurve.hpp>\n#include <geometry/Geom3BSplineSurface.hpp>\n#include <geometry/Geom3Circle.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\n#include <geometry/Geom3Plane.hpp>\n#include <geometry/Geom3SphericalSurface.hpp>\n#include <geometry/Geom3Surface.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include <geometry/Geom3TrimmedSurface.hpp>\n#include <geometry/GeomAPIExtremaCurveCurve3.hpp>\n#include <geometry/GeomAPIProjectPointOnCurve2.hpp>\n#include <geometry/GeomAPIProjectPointOnCurve3.hpp>\n#include <geometry/GeomAPIProjectPointOnSurface.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/GlobalProperty.hpp>\n#include <healing/ShapeFixTool.hpp>\n#include <io/STLTool.hpp>\n#include <math/Sphere.hpp>\n#include <math/TriangularMesh.hpp>\n#include <modeling/CopyShape.hpp>\n#include <modeling/MakeBox.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeFace.hpp>\n#include <modeling/MakePrism.hpp>\n#include <modeling/MakeRevol.hpp>\n#include <modeling/MakeShapeTool.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <modeling/MakeWire.hpp>\n#include <modeling/TransformShape.hpp>\n#include <nurbs/NURBSAPIApprox.hpp>\n#include <nurbs/NURBSAPIBuildCurve.hpp>\n#include <nurbs/NURBSAPICircularSweep.hpp>\n#include <nurbs/NURBSAPIConvert.hpp>\n#include <nurbs/NURBSAPICurveNetworkSurface.hpp>\n#include <nurbs/NURBSAPIExplicitSweep.hpp>\n#include <nurbs/NURBSAPIExplode.hpp>\n#include <nurbs/NURBSAPIExtend.hpp>\n#include <nurbs/NURBSAPIInterpolate.hpp>\n#include <nurbs/NURBSAPIJoin.hpp>\n#include <nurbs/NURBSAPILinearSweep.hpp>\n#include <nurbs/NURBSAPILoft.hpp>\n#include <nurbs/NURBSAPIMakeNURBSFromBoundaries.hpp>\n#include <nurbs/NURBSAPIMatch.hpp>\n#include <nurbs/NURBSAPIModifyEndToPlane.hpp>\n#include <nurbs/NURBSAPIOffsetCurveOnSurface.hpp>\n#include <nurbs/NURBSAPIProject.hpp>\n#include <nurbs/NURBSAPIRebuild.hpp>\n#include <nurbs/NURBSAPIReplaceEdge.hpp>\n#include <nurbs/NURBSAPISweep.hpp>\n#include <nurbs/NURBSAPISweep2.hpp>\n#include <nurbs/NURBSAPISweepRotation.hpp>\n#include <nurbs/NURBSAPITrim.hpp>\n#include <nurbs/NURBSAPIUntrim.hpp>\n#include <nurbs/NURBSLinearSweepWithDraftDirectionLength.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <offset/MakePipe.hpp>\n#include <offset/MakePipeShell.hpp>\n#include <topology/BRepAdaptorCurve2.hpp>\n#include <topology/BRepAdaptorCurve3.hpp>\n#include <topology/BRepAdaptorSurface.hpp>\n#include <topology/BRepGlobalProperty.hpp>\n#include <topology/BRepTool.hpp>\n#include <topology/TopoBuilder.hpp>\n#include <topology/TopoCompound.hpp>\n#include <topology/TopoEdge.hpp>\n#include <topology/TopoExplorer.hpp>\n#include <topology/TopoExplorerTool.hpp>\n#include <topology/TopoFace.hpp>\n#include <topology/TopoShape.hpp>\n#include <topology/TopoShell.hpp>\n#include <topology/TopoTool.hpp>\n#include <topology/TopoVertex.hpp>\n#include <topology/TopoWire.hpp>\n#include <topology/WireExplorer.hpp>\n#include <topomesh/BRepMeshIncrementalMesh.hpp>\n#include <nurbs/NURBSAPIBlend.hpp>\n#include <topology/BRepExtremaDistShapeShape.hpp>\n#include <math/LineT.hpp>\n#include <hatch/BRepClassificationTools.hpp>\nusing namespace AMCAX;\nnamespace\n{\n\tstd::shared_ptr<Geom3BSplineCurve> CurveChooser(const int id, const std::shared_ptr<Geom3BSplineCurve>& curve0, const std::shared_ptr<Geom3BSplineCurve>& curve1, const std::shared_ptr<Geom3BSplineCurve>& curve2)\n\t{\n\t\tstd::shared_ptr<Geom3BSplineCurve> result;\n\t\tswitch (id)\n\t\t{\n\t\tcase 0:\n\t\t{\n\t\t\tresult = curve0;\n\t\t\tbreak;\n\t\t}\n\t\tcase 1:\n\t\t{\n\t\t\tresult = curve1;\n\t\t\tbreak;\n\t\t}\n\t\tcase 2:\n\t\t{\n\t\t\tresult = curve2;\n\t\t\tbreak;\n\t\t}\n\t\t}\n\t\treturn result;\n\t}\n} \n#include<catch.hpp>\n#include<testHelper.h>\n#include <filesystem>\n#include <fstream>\n#include <random>\n#include <sstream>\n#include <nurbs/NURBSAPIGetGeometry.hpp>\n#include <nurbs/NURBSAPIConicalSweep.hpp>\n#include <boolean/BoolBRepCut.hpp>\n#include <common/CartesianCoordinateSystem.hpp>\n#include <common/IndexMap.hpp>\n#include <common/QuaternionT.hpp>\n#include <geomAlgo/LawBSpline.hpp>\n#include <geomAlgo/LawConstant.hpp>\n#include <nurbs/NURBSAPISmooth.hpp>\n#include <geomAlgo/MakeConic2FromConstraints.hpp>\n#include <geometry/Adaptor3CurveOnSurface.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/AdaptorGeom3Surface.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2Circle.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/Geom2Hyperbola.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3BSplineCurve.hpp>\n#include <geometry/Geom3BSplineSurface.hpp>\n#include <geometry/Geom3Circle.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\n#include <geometry/Geom3Plane.hpp>\n#include <geometry/Geom3SphericalSurface.hpp>\n#include <geometry/Geom3Surface.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include <geometry/Geom3TrimmedSurface.hpp>\n#include <geometry/GeomAPIExtremaCurveCurve3.hpp>\n#include <geometry/GeomAPIProjectPointOnCurve2.hpp>\n#include <geometry/GeomAPIProjectPointOnCurve3.hpp>\n#include <geometry/GeomAPIProjectPointOnSurface.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/GlobalProperty.hpp>\n#include <healing/ShapeFixTool.hpp>\n#include <io/STLTool.hpp>\n#include <math/Sphere.hpp>\n#include <math/TriangularMesh.hpp>\n#include <modeling/CopyShape.hpp>\n#include <modeling/MakeBox.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeFace.hpp>\n#include <modeling/MakePrism.hpp>\n#include <modeling/MakeRevol.hpp>\n#include <modeling/MakeShapeTool.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <modeling/MakeWire.hpp>\n#include <modeling/TransformShape.hpp>\n#include <nurbs/NURBSAPIApprox.hpp>\n#include <nurbs/NURBSAPIBuildCurve.hpp>\n#include <nurbs/NURBSAPICircularSweep.hpp>\n#include <nurbs/NURBSAPIConvert.hpp>\n#include <nurbs/NURBSAPICurveNetworkSurface.hpp>\n#include <nurbs/NURBSAPIExplicitSweep.hpp>\n#include <nurbs/NURBSAPIExplode.hpp>\n#include <nurbs/NURBSAPIExtend.hpp>\n#include <nurbs/NURBSAPIInterpolate.hpp>\n#include <nurbs/NURBSAPIJoin.hpp>\n#include <nurbs/NURBSAPILinearSweep.hpp>\n#include <nurbs/NURBSAPILoft.hpp>\n#include <nurbs/NURBSAPIMakeNURBSFromBoundaries.hpp>\n#include <nurbs/NURBSAPIMatch.hpp>\n#include <nurbs/NURBSAPIModifyEndToPlane.hpp>\n#include <nurbs/NURBSAPIOffsetCurveOnSurface.hpp>\n#include <nurbs/NURBSAPIProject.hpp>\n#include <nurbs/NURBSAPIRebuild.hpp>\n#include <nurbs/NURBSAPIReplaceEdge.hpp>\n#include <nurbs/NURBSAPISweep.hpp>\n#include <nurbs/NURBSAPISweep2.hpp>\n#include <nurbs/NURBSAPISweepRotation.hpp>\n#include <nurbs/NURBSAPITrim.hpp>\n#include <nurbs/NURBSAPIUntrim.hpp>\n#include <nurbs/NURBSLinearSweepWithDraftDirectionLength.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <offset/MakePipe.hpp>\n#include <offset/MakePipeShell.hpp>\n#include <topology/BRepAdaptorCurve2.hpp>\n#include <topology/BRepAdaptorCurve3.hpp>\n#include <topology/BRepAdaptorSurface.hpp>\n#include <topology/BRepGlobalProperty.hpp>\n#include <topology/BRepTool.hpp>\n#include <topology/TopoBuilder.hpp>\n#include <topology/TopoCompound.hpp>\n#include <topology/TopoEdge.hpp>\n#include <topology/TopoExplorer.hpp>\n#include <topology/TopoExplorerTool.hpp>\n#include <topology/TopoFace.hpp>\n#include <topology/TopoShape.hpp>\n#include <topology/TopoShell.hpp>\n#include <topology/TopoTool.hpp>\n#include <topology/TopoVertex.hpp>\n#include <topology/TopoWire.hpp>\n#include <topology/WireExplorer.hpp>\n#include <topomesh/BRepMeshIncrementalMesh.hpp>\n#include <nurbs/NURBSAPIBlend.hpp>\n#include <topology/BRepExtremaDistShapeShape.hpp>\n#include <math/LineT.hpp>\n#include <hatch/BRepClassificationTools.hpp>\nusing namespace AMCAX;\nnamespace\n{\n\tstd::shared_ptr<Geom3BSplineCurve> CurveChooser(const int id, const std::shared_ptr<Geom3BSplineCurve>& curve0, const std::shared_ptr<Geom3BSplineCurve>& curve1, const std::shared_ptr<Geom3BSplineCurve>& curve2)\n\t{\n\t\tstd::shared_ptr<Geom3BSplineCurve> result;\n\t\tswitch (id)\n\t\t{\n\t\tcase 0:\n\t\t{\n\t\t\tresult = curve0;\n\t\t\tbreak;\n\t\t}\n\t\tcase 1:\n\t\t{\n\t\t\tresult = curve1;\n\t\t\tbreak;\n\t\t}\n\t\tcase 2:\n\t\t{\n\t\t\tresult = curve2;\n\t\t\tbreak;\n\t\t}\n\t\t}\n\t\treturn result;\n\t}\n;\n\tSECTION(\"TestLinearSweepWithTwoLimits()\")\n\t{\n\t\tstd::string filedir = INPUT_PATH_PREFIX \"/TestNURBS/TestLinearSweepWithTwoLimits/\";\n\t\tauto guide1 = ReadBRepCurve(filedir + \"guide1.brep\");\n\t\tCHECK(OCCTIO::OCCTTool::Write(MakeEdge(guide1), OUTPUT_PATH_PREFIX \"TestLinearSweepWithTwoLimits_guide1.brep\"));\n\t\tauto guide2 = ReadBRepCurve(filedir + \"guide2.brep\");\n\t\tCHECK(OCCTIO::OCCTTool::Write(MakeEdge(guide2), OUTPUT_PATH_PREFIX \"TestLinearSweepWithTwoLimits_guide2.brep\"));\n\t\tauto spineFP = ReadBRepPoint(filedir + \"spineFP.brep\");\n\t\tauto spineLP = ReadBRepPoint(filedir + \"spineLP.brep\");\n\t\tstd::vector<Point3> poles;\n\t\tpoles.push_back(spineFP);\n\t\tpoles.push_back(spineLP);\n\t\tauto spine = NURBSAPIBuildCurve::BuildCurve(poles, 1, false);\n\t\tCHECK(OCCTIO::OCCTTool::Write(MakeEdge(spine), OUTPUT_PATH_PREFIX \"TestLinearSweepWithTwoLimits_spine.brep\"));\n\t\tLawConstant law1;\n\t\tlaw1.Set(0.1, 0.0, 1.0);\n\t\tLawConstant law2;\n\t\tlaw2.Set(0.2, 0.0, 1.0);\n\t\tauto [status, surface] = NURBSAPILinearSweep::SweepWithTwoLimits(guide1, guide2, spine, spine->FirstParameter(), spine->LastParameter(), law1, law2);\n\t\tCHECK(status == NURBSSweepStatus::Success);\n\t\tif (status == NURBSSweepStatus::Success)\n\t\t{\n\t\t\tCHECK(OCCTIO::OCCTTool::Write(MakeFace(surface, 0.0), OUTPUT_PATH_PREFIX \"TestLinearSweepWithTwoLimits_result.brep\"));\n\t\t\tCHECK(IsCurveOnSurf(1000, 0.3, guide1, surface, 0.2));\n\t\t\tCHECK(IsCurveOnSurf(1000, 0.2, guide2, surface, 0.2));\n\t\t\tAMCAX::BRepExtremaDistShapeShape len1(MakeFace(surface, 0.0), MakeEdge(guide1));\n\t\t\tAMCAX::BRepExtremaDistShapeShape len2(MakeFace(surface, 0.0), MakeEdge(guide2));\n\t\t\tCHECK(len1.Value() == Approx(0.0).margin(0.1));\n\t\t\tCHECK(len2.Value() == Approx(0.0).margin(0.1));\n\t\t}\n\t\tguide1->IncreaseDegree(11);\n\t\tguide2->IncreaseDegree(11);\n\t\tspine->IncreaseDegree(11);\n\t\tauto [status1, surface1] = NURBSAPILinearSweep::SweepWithTwoLimits(guide1, guide2, spine, spine->FirstParameter(), spine->LastParameter(), law1, law2);\n\t\tCHECK(status1 == NURBSSweepStatus::Success);\n\t\tif (status1 == NURBSSweepStatus::Success)\n\t\t{\n\t\t\tCHECK(OCCTIO::OCCTTool::Write(MakeFace(surface1, 0.0), OUTPUT_PATH_PREFIX \"TestLinearSweepWithTwoLimits_rdegree11esult.brep\"));\n\t\t\tCHECK(IsCurveOnSurf(1000, 0.3, guide1, surface1, 0.2));\n\t\t\tCHECK(IsCurveOnSurf(1000, 0.2, guide2, surface1, 0.2));\n\t\t\tAMCAX::BRepExtremaDistShapeShape len1(MakeFace(surface1, 0.0), MakeEdge(guide1));\n\t\t\tAMCAX::BRepExtremaDistShapeShape len2(MakeFace(surface1, 0.0), MakeEdge(guide2));\n\t\t\tCHECK(len1.Value() == Approx(0.0).margin(0.1));\n\t\t\tCHECK(len2.Value() == Approx(0.0).margin(0.1));\n\t\t\tdouble bsp3s = GetSurfaceProperties(MakeFace(surface1, 0.0), g, true, true);\n\t\t\tdouble bsp4s = GetSurfaceProperties(MakeFace(surface1, 0.0), g, true, true);\n\t\t\tCHECK(bsp3s == Approx(bsp4s).margin(0.02));\n\t\t}\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static std::pair<bool, std::shared_ptr<Geom3BSplineSurface>> JoinSurfaces( const std::vector<std::shared_ptr<Geom3BSplineSurface>>& surfaces, const std::vector<bool>& isUIso, const std::vector<bool>& isFrontBackReverse, const std::vector<bool>& isIsoReverse, bool isUPeriodic, bool isVPeriodic),\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <nurbs/NURBSAPIJoin.hpp>\n#include <topology/TopoEdge.hpp>\n#include <topology/TopoTool.hpp>\n#include <nurbs/NURBSAPIExplode.hpp>\n#include <common/Precision.hpp>\n#include <common/CartesianCoordinateSystem.hpp>\n#include <geometry/Geom3BSplineCurve.hpp>\n#include <nurbs/NURBSAPIJoin.hpp>\n#include <geometry/Geom3BSplineCurve.hpp>\n#include <geometry/Geom3BSplineSurface.hpp>\n#include <topology/TopoFace.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeFace.hpp>\n#include <nurbs/NURBSAPIInterpolate.hpp>\nTEST_CASE(\"bug1: JoinCurve http :\n{\n\tOUTPUT_DIRECTORY(nurbs, Join/bug468);\n\tdouble eps = 1e-4;\n\tstring filedir = INPUT_PATH_PREFIX\"./TestNURBS/TestJoinSurface/\";\n\tstd::vector<std::shared_ptr<Geom3BSplineSurface>> surfaces;\n\tsurfaces.push_back(ReadBRepSurface(filedir + \"surface0.brep\"));\n\tsurfaces.push_back(ReadBRepSurface(filedir + \"surface1.brep\"));\n\tsurfaces.push_back(ReadBRepSurface(filedir + \"surface2.brep\"));\n\tsurfaces.push_back(ReadBRepSurface(filedir + \"surface3.brep\"));\n\tauto [sortedSurfaces, isUIso, isFrontBackReverse, isIsoReverse, isLocalUPeriodic, isLocalVPeriodic] = NURBSAPIJoin::JoinSurfacesPrepare(surfaces, 0.0001);\n\tauto [isSucceed, result] = NURBSAPIJoin::JoinSurfaces(sortedSurfaces, isUIso, isFrontBackReverse, isIsoReverse, isLocalUPeriodic, isLocalVPeriodic);\n\tThrow_Construction_Error_if(!isSucceed, \"failed\");\n\tauto explodeResult = NURBSAPIExplode::ExplodeSurface(result);\n\tTopoShape f1 = MakeFace(surfaces[0], 0.0);\n\tTopoShape f2 = MakeFace(surfaces[1], 0.0);\n\tTopoShape f3 = MakeFace(surfaces[2], 0.0);\n\tTopoShape f4 = MakeFace(surfaces[3], 0.0);\n\tTopoShape f = MakeFace(result, 0.0);\n\tGlobalProperty props1, props2, props3, props4, props5, props6, props7, props8;\n\tdouble surf1 = GetSurfaceProperties(f1, props1, true, false);\n\tdouble surf2 = GetSurfaceProperties(f2, props2, true, false);\n\tdouble surf3 = GetSurfaceProperties(f3, props3, true, false);\n\tdouble surf4 = GetSurfaceProperties(f4, props4, true, false);\n\tdouble surface = GetSurfacePropertiesEps(f, props5, eps, true);\n\tdouble surf = surf1 + surf2 + surf3 + surf4;\n\tdouble dif = abs(surface - surf);\n\tCHECK(GetTopoCount(MakeFace(result, 0.0), ShapeType::Face) == 1);\n\tCHECK(dif < 0.1);\n\tOCCTIO::OCCTTool::Write(MakeFace(surfaces[0], 0.0), outdir + \"surf1.brep\");\n\tOCCTIO::OCCTTool::Write(MakeFace(surfaces[1], 0.0), outdir + \"surf2.brep\");\n\tOCCTIO::OCCTTool::Write(MakeFace(surfaces[2], 0.0), outdir + \"surf3.brep\");\n\tOCCTIO::OCCTTool::Write(MakeFace(surfaces[3], 0.0), outdir + \"surf4.brep\");\n\tOCCTIO::OCCTTool::Write(MakeFace(result, 0.0), outdir + \"joinSurf.brep\");\n}\n#include<catch.hpp>\n#include<testHelper.h>\n#include <nurbs/NURBSAPIJoin.hpp>\n#include <topology/TopoEdge.hpp>\n#include <topology/TopoTool.hpp>\n#include <nurbs/NURBSAPIExplode.hpp>\n#include <common/Precision.hpp>\n#include <common/CartesianCoordinateSystem.hpp>\n#include <geometry/Geom3BSplineCurve.hpp>\n#include <nurbs/NURBSAPIJoin.hpp>\n#include <geometry/Geom3BSplineCurve.hpp>\n#include <geometry/Geom3BSplineSurface.hpp>\n#include <topology/TopoFace.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeFace.hpp>\n#include <nurbs/NURBSAPIInterpolate.hpp>\nTEST_CASE(\"bug1: JoinCurve http :\n{\n\tOUTPUT_DIRECTORY(nurbs, Join/bug468);\n\tdouble eps = 1e-4;\n\tstring filedir = INPUT_PATH_PREFIX\"./TestNURBS/TestJoinSurface/\";\n\tstd::vector<std::shared_ptr<Geom3BSplineSurface>> surfaces;\n\tsurfaces.push_back(ReadBRepSurface(filedir + \"surface0.brep\"));\n\tsurfaces.push_back(ReadBRepSurface(filedir + \"surface1.brep\"));\n\tsurfaces.push_back(ReadBRepSurface(filedir + \"surface2.brep\"));\n\tsurfaces.push_back(ReadBRepSurface(filedir + \"surface3.brep\"));\n\tauto [sortedSurfaces, isUIso, isFrontBackReverse, isIsoReverse, isLocalUPeriodic, isLocalVPeriodic] = NURBSAPIJoin::JoinSurfacesPrepare(surfaces, 0.0001);\n\tauto [isSucceed, result] = NURBSAPIJoin::JoinSurfaces(sortedSurfaces, isUIso, isFrontBackReverse, isIsoReverse, isLocalUPeriodic, isLocalVPeriodic);\n\tThrow_Construction_Error_if(!isSucceed, \"failed\");\n\tauto explodeResult = NURBSAPIExplode::ExplodeSurface(result);\n\tTopoShape f1 = MakeFace(surfaces[0], 0.0);\n\tTopoShape f2 = MakeFace(surfaces[1], 0.0);\n\tTopoShape f3 = MakeFace(surfaces[2], 0.0);\n\tTopoShape f4 = MakeFace(surfaces[3], 0.0);\n\tTopoShape f = MakeFace(result, 0.0);\n\tGlobalProperty props1, props2, props3, props4, props5, props6, props7, props8;\n\tdouble surf1 = GetSurfaceProperties(f1, props1, true, false);\n\tdouble surf2 = GetSurfaceProperties(f2, props2, true, false);\n\tdouble surf3 = GetSurfaceProperties(f3, props3, true, false);\n\tdouble surf4 = GetSurfaceProperties(f4, props4, true, false);\n\tdouble surface = GetSurfacePropertiesEps(f, props5, eps, true);\n\tdouble surf = surf1 + surf2 + surf3 + surf4;\n\tdouble dif = abs(surface - surf);\n\tCHECK(GetTopoCount(MakeFace(result, 0.0), ShapeType::Face) == 1);\n\tCHECK(dif < 0.1);\n\tOCCTIO::OCCTTool::Write(MakeFace(surfaces[0], 0.0), outdir + \"surf1.brep\");\n\tOCCTIO::OCCTTool::Write(MakeFace(surfaces[1], 0.0), outdir + \"surf2.brep\");\n\tOCCTIO::OCCTTool::Write(MakeFace(surfaces[2], 0.0), outdir + \"surf3.brep\");\n\tOCCTIO::OCCTTool::Write(MakeFace(surfaces[3], 0.0), outdir + \"surf4.brep\");\n\tOCCTIO::OCCTTool::Write(MakeFace(result, 0.0), outdir + \"joinSurf.brep\");\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static std::pair<bool, std::shared_ptr<Geom3BSplineSurface>> JoinSurfaces( const std::shared_ptr<Geom3BSplineSurface>& surface1, const std::shared_ptr<Geom3BSplineSurface>& surface2, bool isSurface1UIso, bool isSurface2UIso, bool isSurface1FrontBackReverse, bool isSurface2FrontBackReverse, bool isSurface1IsoReverse, bool isSurface2IsoReverse, bool isUPeriodic, bool isVPeriodic),\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <nurbs/NURBSAPIJoin.hpp>\n#include <topology/TopoEdge.hpp>\n#include <topology/TopoTool.hpp>\n#include <nurbs/NURBSAPIExplode.hpp>\n#include <common/Precision.hpp>\n#include <common/CartesianCoordinateSystem.hpp>\n#include <geometry/Geom3BSplineCurve.hpp>\n#include <nurbs/NURBSAPIJoin.hpp>\n#include <geometry/Geom3BSplineCurve.hpp>\n#include <geometry/Geom3BSplineSurface.hpp>\n#include <topology/TopoFace.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeFace.hpp>\n#include <nurbs/NURBSAPIInterpolate.hpp>\nTEST_CASE(\"bug1: JoinCurve http :\n{\n\tOUTPUT_DIRECTORY(nurbs, Join/bug468);\n\tdouble eps = 1e-4;\n\tstring filedir = INPUT_PATH_PREFIX\"./TestNURBS/TestJoinSurface/\";\n\tstd::vector<std::shared_ptr<Geom3BSplineSurface>> surfaces;\n\tsurfaces.push_back(ReadBRepSurface(filedir + \"surface0.brep\"));\n\tsurfaces.push_back(ReadBRepSurface(filedir + \"surface1.brep\"));\n\tsurfaces.push_back(ReadBRepSurface(filedir + \"surface2.brep\"));\n\tsurfaces.push_back(ReadBRepSurface(filedir + \"surface3.brep\"));\n\tauto [sortedSurfaces, isUIso, isFrontBackReverse, isIsoReverse, isLocalUPeriodic, isLocalVPeriodic] = NURBSAPIJoin::JoinSurfacesPrepare(surfaces, 0.0001);\n\tauto [isSucceed, result] = NURBSAPIJoin::JoinSurfaces(sortedSurfaces, isUIso, isFrontBackReverse, isIsoReverse, isLocalUPeriodic, isLocalVPeriodic);\n\tThrow_Construction_Error_if(!isSucceed, \"failed\");\n\tauto explodeResult = NURBSAPIExplode::ExplodeSurface(result);\n\tTopoShape f1 = MakeFace(surfaces[0], 0.0);\n\tTopoShape f2 = MakeFace(surfaces[1], 0.0);\n\tTopoShape f3 = MakeFace(surfaces[2], 0.0);\n\tTopoShape f4 = MakeFace(surfaces[3], 0.0);\n\tTopoShape f = MakeFace(result, 0.0);\n\tGlobalProperty props1, props2, props3, props4, props5, props6, props7, props8;\n\tdouble surf1 = GetSurfaceProperties(f1, props1, true, false);\n\tdouble surf2 = GetSurfaceProperties(f2, props2, true, false);\n\tdouble surf3 = GetSurfaceProperties(f3, props3, true, false);\n\tdouble surf4 = GetSurfaceProperties(f4, props4, true, false);\n\tdouble surface = GetSurfacePropertiesEps(f, props5, eps, true);\n\tdouble surf = surf1 + surf2 + surf3 + surf4;\n\tdouble dif = abs(surface - surf);\n\tCHECK(GetTopoCount(MakeFace(result, 0.0), ShapeType::Face) == 1);\n\tCHECK(dif < 0.1);\n\tOCCTIO::OCCTTool::Write(MakeFace(surfaces[0], 0.0), outdir + \"surf1.brep\");\n\tOCCTIO::OCCTTool::Write(MakeFace(surfaces[1], 0.0), outdir + \"surf2.brep\");\n\tOCCTIO::OCCTTool::Write(MakeFace(surfaces[2], 0.0), outdir + \"surf3.brep\");\n\tOCCTIO::OCCTTool::Write(MakeFace(surfaces[3], 0.0), outdir + \"surf4.brep\");\n\tOCCTIO::OCCTTool::Write(MakeFace(result, 0.0), outdir + \"joinSurf.brep\");\n}\n#include<catch.hpp>\n#include<testHelper.h>\n#include <nurbs/NURBSAPIJoin.hpp>\n#include <topology/TopoEdge.hpp>\n#include <topology/TopoTool.hpp>\n#include <nurbs/NURBSAPIExplode.hpp>\n#include <common/Precision.hpp>\n#include <common/CartesianCoordinateSystem.hpp>\n#include <geometry/Geom3BSplineCurve.hpp>\n#include <nurbs/NURBSAPIJoin.hpp>\n#include <geometry/Geom3BSplineCurve.hpp>\n#include <geometry/Geom3BSplineSurface.hpp>\n#include <topology/TopoFace.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeFace.hpp>\n#include <nurbs/NURBSAPIInterpolate.hpp>\nTEST_CASE(\"bug1: JoinCurve http :\n{\n\tOUTPUT_DIRECTORY(nurbs, Join/bug468);\n\tdouble eps = 1e-4;\n\tstring filedir = INPUT_PATH_PREFIX\"./TestNURBS/TestJoinSurface/\";\n\tstd::vector<std::shared_ptr<Geom3BSplineSurface>> surfaces;\n\tsurfaces.push_back(ReadBRepSurface(filedir + \"surface0.brep\"));\n\tsurfaces.push_back(ReadBRepSurface(filedir + \"surface1.brep\"));\n\tsurfaces.push_back(ReadBRepSurface(filedir + \"surface2.brep\"));\n\tsurfaces.push_back(ReadBRepSurface(filedir + \"surface3.brep\"));\n\tauto [sortedSurfaces, isUIso, isFrontBackReverse, isIsoReverse, isLocalUPeriodic, isLocalVPeriodic] = NURBSAPIJoin::JoinSurfacesPrepare(surfaces, 0.0001);\n\tauto [isSucceed, result] = NURBSAPIJoin::JoinSurfaces(sortedSurfaces, isUIso, isFrontBackReverse, isIsoReverse, isLocalUPeriodic, isLocalVPeriodic);\n\tThrow_Construction_Error_if(!isSucceed, \"failed\");\n\tauto explodeResult = NURBSAPIExplode::ExplodeSurface(result);\n\tTopoShape f1 = MakeFace(surfaces[0], 0.0);\n\tTopoShape f2 = MakeFace(surfaces[1], 0.0);\n\tTopoShape f3 = MakeFace(surfaces[2], 0.0);\n\tTopoShape f4 = MakeFace(surfaces[3], 0.0);\n\tTopoShape f = MakeFace(result, 0.0);\n\tGlobalProperty props1, props2, props3, props4, props5, props6, props7, props8;\n\tdouble surf1 = GetSurfaceProperties(f1, props1, true, false);\n\tdouble surf2 = GetSurfaceProperties(f2, props2, true, false);\n\tdouble surf3 = GetSurfaceProperties(f3, props3, true, false);\n\tdouble surf4 = GetSurfaceProperties(f4, props4, true, false);\n\tdouble surface = GetSurfacePropertiesEps(f, props5, eps, true);\n\tdouble surf = surf1 + surf2 + surf3 + surf4;\n\tdouble dif = abs(surface - surf);\n\tCHECK(GetTopoCount(MakeFace(result, 0.0), ShapeType::Face) == 1);\n\tCHECK(dif < 0.1);\n\tOCCTIO::OCCTTool::Write(MakeFace(surfaces[0], 0.0), outdir + \"surf1.brep\");\n\tOCCTIO::OCCTTool::Write(MakeFace(surfaces[1], 0.0), outdir + \"surf2.brep\");\n\tOCCTIO::OCCTTool::Write(MakeFace(surfaces[2], 0.0), outdir + \"surf3.brep\");\n\tOCCTIO::OCCTTool::Write(MakeFace(surfaces[3], 0.0), outdir + \"surf4.brep\");\n\tOCCTIO::OCCTTool::Write(MakeFace(result, 0.0), outdir + \"joinSurf.brep\");\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static std::tuple<std::vector<std::shared_ptr<Geom3BSplineSurface>>, std::vector<bool>, std::vector<bool>, std::vector<bool>, bool, bool> JoinSurfacesPrepare(const std::vector<std::shared_ptr<Geom3BSplineSurface>>& surfaces, double tol),\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <nurbs/NURBSAPIJoin.hpp>\n#include <topology/TopoEdge.hpp>\n#include <topology/TopoTool.hpp>\n#include <nurbs/NURBSAPIExplode.hpp>\n#include <common/Precision.hpp>\n#include <common/CartesianCoordinateSystem.hpp>\n#include <geometry/Geom3BSplineCurve.hpp>\n#include <nurbs/NURBSAPIJoin.hpp>\n#include <geometry/Geom3BSplineCurve.hpp>\n#include <geometry/Geom3BSplineSurface.hpp>\n#include <topology/TopoFace.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeFace.hpp>\n#include <nurbs/NURBSAPIInterpolate.hpp>\nTEST_CASE(\"bug1: JoinCurve http :\n{\n\tOUTPUT_DIRECTORY(nurbs, Join/bug468);\n\tdouble eps = 1e-4;\n\tstring filedir = INPUT_PATH_PREFIX\"./TestNURBS/TestJoinSurface/\";\n\tstd::vector<std::shared_ptr<Geom3BSplineSurface>> surfaces;\n\tsurfaces.push_back(ReadBRepSurface(filedir + \"surface0.brep\"));\n\tsurfaces.push_back(ReadBRepSurface(filedir + \"surface1.brep\"));\n\tsurfaces.push_back(ReadBRepSurface(filedir + \"surface2.brep\"));\n\tsurfaces.push_back(ReadBRepSurface(filedir + \"surface3.brep\"));\n\tauto [sortedSurfaces, isUIso, isFrontBackReverse, isIsoReverse, isLocalUPeriodic, isLocalVPeriodic] = NURBSAPIJoin::JoinSurfacesPrepare(surfaces, 0.0001);\n\tauto [isSucceed, result] = NURBSAPIJoin::JoinSurfaces(sortedSurfaces, isUIso, isFrontBackReverse, isIsoReverse, isLocalUPeriodic, isLocalVPeriodic);\n\tThrow_Construction_Error_if(!isSucceed, \"failed\");\n\tauto explodeResult = NURBSAPIExplode::ExplodeSurface(result);\n\tTopoShape f1 = MakeFace(surfaces[0], 0.0);\n\tTopoShape f2 = MakeFace(surfaces[1], 0.0);\n\tTopoShape f3 = MakeFace(surfaces[2], 0.0);\n\tTopoShape f4 = MakeFace(surfaces[3], 0.0);\n\tTopoShape f = MakeFace(result, 0.0);\n\tGlobalProperty props1, props2, props3, props4, props5, props6, props7, props8;\n\tdouble surf1 = GetSurfaceProperties(f1, props1, true, false);\n\tdouble surf2 = GetSurfaceProperties(f2, props2, true, false);\n\tdouble surf3 = GetSurfaceProperties(f3, props3, true, false);\n\tdouble surf4 = GetSurfaceProperties(f4, props4, true, false);\n\tdouble surface = GetSurfacePropertiesEps(f, props5, eps, true);\n\tdouble surf = surf1 + surf2 + surf3 + surf4;\n\tdouble dif = abs(surface - surf);\n\tCHECK(GetTopoCount(MakeFace(result, 0.0), ShapeType::Face) == 1);\n\tCHECK(dif < 0.1);\n\tOCCTIO::OCCTTool::Write(MakeFace(surfaces[0], 0.0), outdir + \"surf1.brep\");\n\tOCCTIO::OCCTTool::Write(MakeFace(surfaces[1], 0.0), outdir + \"surf2.brep\");\n\tOCCTIO::OCCTTool::Write(MakeFace(surfaces[2], 0.0), outdir + \"surf3.brep\");\n\tOCCTIO::OCCTTool::Write(MakeFace(surfaces[3], 0.0), outdir + \"surf4.brep\");\n\tOCCTIO::OCCTTool::Write(MakeFace(result, 0.0), outdir + \"joinSurf.brep\");\n}\n#include<catch.hpp>\n#include<testHelper.h>\n#include <nurbs/NURBSAPIJoin.hpp>\n#include <topology/TopoEdge.hpp>\n#include <topology/TopoTool.hpp>\n#include <nurbs/NURBSAPIExplode.hpp>\n#include <common/Precision.hpp>\n#include <common/CartesianCoordinateSystem.hpp>\n#include <geometry/Geom3BSplineCurve.hpp>\n#include <nurbs/NURBSAPIJoin.hpp>\n#include <geometry/Geom3BSplineCurve.hpp>\n#include <geometry/Geom3BSplineSurface.hpp>\n#include <topology/TopoFace.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeFace.hpp>\n#include <nurbs/NURBSAPIInterpolate.hpp>\nTEST_CASE(\"bug1: JoinCurve http :\n{\n\tOUTPUT_DIRECTORY(nurbs, Join/bug468);\n\tdouble eps = 1e-4;\n\tstring filedir = INPUT_PATH_PREFIX\"./TestNURBS/TestJoinSurface/\";\n\tstd::vector<std::shared_ptr<Geom3BSplineSurface>> surfaces;\n\tsurfaces.push_back(ReadBRepSurface(filedir + \"surface0.brep\"));\n\tsurfaces.push_back(ReadBRepSurface(filedir + \"surface1.brep\"));\n\tsurfaces.push_back(ReadBRepSurface(filedir + \"surface2.brep\"));\n\tsurfaces.push_back(ReadBRepSurface(filedir + \"surface3.brep\"));\n\tauto [sortedSurfaces, isUIso, isFrontBackReverse, isIsoReverse, isLocalUPeriodic, isLocalVPeriodic] = NURBSAPIJoin::JoinSurfacesPrepare(surfaces, 0.0001);\n\tauto [isSucceed, result] = NURBSAPIJoin::JoinSurfaces(sortedSurfaces, isUIso, isFrontBackReverse, isIsoReverse, isLocalUPeriodic, isLocalVPeriodic);\n\tThrow_Construction_Error_if(!isSucceed, \"failed\");\n\tauto explodeResult = NURBSAPIExplode::ExplodeSurface(result);\n\tTopoShape f1 = MakeFace(surfaces[0], 0.0);\n\tTopoShape f2 = MakeFace(surfaces[1], 0.0);\n\tTopoShape f3 = MakeFace(surfaces[2], 0.0);\n\tTopoShape f4 = MakeFace(surfaces[3], 0.0);\n\tTopoShape f = MakeFace(result, 0.0);\n\tGlobalProperty props1, props2, props3, props4, props5, props6, props7, props8;\n\tdouble surf1 = GetSurfaceProperties(f1, props1, true, false);\n\tdouble surf2 = GetSurfaceProperties(f2, props2, true, false);\n\tdouble surf3 = GetSurfaceProperties(f3, props3, true, false);\n\tdouble surf4 = GetSurfaceProperties(f4, props4, true, false);\n\tdouble surface = GetSurfacePropertiesEps(f, props5, eps, true);\n\tdouble surf = surf1 + surf2 + surf3 + surf4;\n\tdouble dif = abs(surface - surf);\n\tCHECK(GetTopoCount(MakeFace(result, 0.0), ShapeType::Face) == 1);\n\tCHECK(dif < 0.1);\n\tOCCTIO::OCCTTool::Write(MakeFace(surfaces[0], 0.0), outdir + \"surf1.brep\");\n\tOCCTIO::OCCTTool::Write(MakeFace(surfaces[1], 0.0), outdir + \"surf2.brep\");\n\tOCCTIO::OCCTTool::Write(MakeFace(surfaces[2], 0.0), outdir + \"surf3.brep\");\n\tOCCTIO::OCCTTool::Write(MakeFace(surfaces[3], 0.0), outdir + \"surf4.brep\");\n\tOCCTIO::OCCTTool::Write(MakeFace(result, 0.0), outdir + \"joinSurf.brep\");\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static std::shared_ptr<Geom3BSplineCurve> JoinCurves( const std::vector<std::shared_ptr<Geom3BSplineCurve>>& curves, const std::vector<bool>& isReverse, bool isPeriodic),\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <nurbs/NURBSAPIJoin.hpp>\n#include <topology/TopoEdge.hpp>\n#include <topology/TopoTool.hpp>\n#include <nurbs/NURBSAPIExplode.hpp>\n#include <common/Precision.hpp>\n#include <common/CartesianCoordinateSystem.hpp>\n#include <geometry/Geom3BSplineCurve.hpp>\n#include <nurbs/NURBSAPIJoin.hpp>\n#include <geometry/Geom3BSplineCurve.hpp>\n#include <geometry/Geom3BSplineSurface.hpp>\n#include <topology/TopoFace.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeFace.hpp>\n#include <nurbs/NURBSAPIInterpolate.hpp>\nTEST_CASE(\"bug1: JoinCurve http :\n{\n\tOUTPUT_DIRECTORY(nurbs, Join/bug468);\n\tdouble eps = 1e-4;\n\tstring filedir = INPUT_PATH_PREFIX\"./TestNURBS/TestJoinSurface/\";\n\tstd::vector<std::shared_ptr<Geom3BSplineSurface>> surfaces;\n\tsurfaces.push_back(ReadBRepSurface(filedir + \"surface0.brep\"));\n\tsurfaces.push_back(ReadBRepSurface(filedir + \"surface1.brep\"));\n\tsurfaces.push_back(ReadBRepSurface(filedir + \"surface2.brep\"));\n\tsurfaces.push_back(ReadBRepSurface(filedir + \"surface3.brep\"));\n\tauto [sortedSurfaces, isUIso, isFrontBackReverse, isIsoReverse, isLocalUPeriodic, isLocalVPeriodic] = NURBSAPIJoin::JoinSurfacesPrepare(surfaces, 0.0001);\n\tauto [isSucceed, result] = NURBSAPIJoin::JoinSurfaces(sortedSurfaces, isUIso, isFrontBackReverse, isIsoReverse, isLocalUPeriodic, isLocalVPeriodic);\n\tThrow_Construction_Error_if(!isSucceed, \"failed\");\n\tauto explodeResult = NURBSAPIExplode::ExplodeSurface(result);\n\tTopoShape f1 = MakeFace(surfaces[0], 0.0);\n\tTopoShape f2 = MakeFace(surfaces[1], 0.0);\n\tTopoShape f3 = MakeFace(surfaces[2], 0.0);\n\tTopoShape f4 = MakeFace(surfaces[3], 0.0);\n\tTopoShape f = MakeFace(result, 0.0);\n\tGlobalProperty props1, props2, props3, props4, props5, props6, props7, props8;\n\tdouble surf1 = GetSurfaceProperties(f1, props1, true, false);\n\tdouble surf2 = GetSurfaceProperties(f2, props2, true, false);\n\tdouble surf3 = GetSurfaceProperties(f3, props3, true, false);\n\tdouble surf4 = GetSurfaceProperties(f4, props4, true, false);\n\tdouble surface = GetSurfacePropertiesEps(f, props5, eps, true);\n\tdouble surf = surf1 + surf2 + surf3 + surf4;\n\tdouble dif = abs(surface - surf);\n\tCHECK(GetTopoCount(MakeFace(result, 0.0), ShapeType::Face) == 1);\n\tCHECK(dif < 0.1);\n\tOCCTIO::OCCTTool::Write(MakeFace(surfaces[0], 0.0), outdir + \"surf1.brep\");\n\tOCCTIO::OCCTTool::Write(MakeFace(surfaces[1], 0.0), outdir + \"surf2.brep\");\n\tOCCTIO::OCCTTool::Write(MakeFace(surfaces[2], 0.0), outdir + \"surf3.brep\");\n\tOCCTIO::OCCTTool::Write(MakeFace(surfaces[3], 0.0), outdir + \"surf4.brep\");\n\tOCCTIO::OCCTTool::Write(MakeFace(result, 0.0), outdir + \"joinSurf.brep\");\n}\n#include<catch.hpp>\n#include<testHelper.h>\n#include <nurbs/NURBSAPIJoin.hpp>\n#include <topology/TopoEdge.hpp>\n#include <topology/TopoTool.hpp>\n#include <nurbs/NURBSAPIExplode.hpp>\n#include <common/Precision.hpp>\n#include <common/CartesianCoordinateSystem.hpp>\n#include <geometry/Geom3BSplineCurve.hpp>\n#include <nurbs/NURBSAPIJoin.hpp>\n#include <geometry/Geom3BSplineCurve.hpp>\n#include <geometry/Geom3BSplineSurface.hpp>\n#include <topology/TopoFace.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeFace.hpp>\n#include <nurbs/NURBSAPIInterpolate.hpp>\nTEST_CASE(\"bug1: JoinCurve http :\n{\n\tOUTPUT_DIRECTORY(nurbs, Join/bug468);\n\tdouble eps = 1e-4;\n\tstring filedir = INPUT_PATH_PREFIX\"./TestNURBS/TestJoinSurface/\";\n\tstd::vector<std::shared_ptr<Geom3BSplineSurface>> surfaces;\n\tsurfaces.push_back(ReadBRepSurface(filedir + \"surface0.brep\"));\n\tsurfaces.push_back(ReadBRepSurface(filedir + \"surface1.brep\"));\n\tsurfaces.push_back(ReadBRepSurface(filedir + \"surface2.brep\"));\n\tsurfaces.push_back(ReadBRepSurface(filedir + \"surface3.brep\"));\n\tauto [sortedSurfaces, isUIso, isFrontBackReverse, isIsoReverse, isLocalUPeriodic, isLocalVPeriodic] = NURBSAPIJoin::JoinSurfacesPrepare(surfaces, 0.0001);\n\tauto [isSucceed, result] = NURBSAPIJoin::JoinSurfaces(sortedSurfaces, isUIso, isFrontBackReverse, isIsoReverse, isLocalUPeriodic, isLocalVPeriodic);\n\tThrow_Construction_Error_if(!isSucceed, \"failed\");\n\tauto explodeResult = NURBSAPIExplode::ExplodeSurface(result);\n\tTopoShape f1 = MakeFace(surfaces[0], 0.0);\n\tTopoShape f2 = MakeFace(surfaces[1], 0.0);\n\tTopoShape f3 = MakeFace(surfaces[2], 0.0);\n\tTopoShape f4 = MakeFace(surfaces[3], 0.0);\n\tTopoShape f = MakeFace(result, 0.0);\n\tGlobalProperty props1, props2, props3, props4, props5, props6, props7, props8;\n\tdouble surf1 = GetSurfaceProperties(f1, props1, true, false);\n\tdouble surf2 = GetSurfaceProperties(f2, props2, true, false);\n\tdouble surf3 = GetSurfaceProperties(f3, props3, true, false);\n\tdouble surf4 = GetSurfaceProperties(f4, props4, true, false);\n\tdouble surface = GetSurfacePropertiesEps(f, props5, eps, true);\n\tdouble surf = surf1 + surf2 + surf3 + surf4;\n\tdouble dif = abs(surface - surf);\n\tCHECK(GetTopoCount(MakeFace(result, 0.0), ShapeType::Face) == 1);\n\tCHECK(dif < 0.1);\n\tOCCTIO::OCCTTool::Write(MakeFace(surfaces[0], 0.0), outdir + \"surf1.brep\");\n\tOCCTIO::OCCTTool::Write(MakeFace(surfaces[1], 0.0), outdir + \"surf2.brep\");\n\tOCCTIO::OCCTTool::Write(MakeFace(surfaces[2], 0.0), outdir + \"surf3.brep\");\n\tOCCTIO::OCCTTool::Write(MakeFace(surfaces[3], 0.0), outdir + \"surf4.brep\");\n\tOCCTIO::OCCTTool::Write(MakeFace(result, 0.0), outdir + \"joinSurf.brep\");\n;\n\tSECTION(\"isPeriodic\")\n\t{\n\t\tOUTPUT_DIRECTORY(nurbs, Join/JoinCurve1);\n\t\tfilename = \"periodicCurve\";\n\t\tstd::vector<std::shared_ptr<Geom3BSplineCurve>> curves;\n\t\tfor (int i = 0; i < 3; i++)\n\t\t{\n\t\t\tcurves.push_back(ReadBRepCurve(filedir + filename + std::to_string(i) + \".brep\"));\n\t\t}\n\t\tauto [sortedCurves, isReverse, isResultPeriodic] = NURBSAPIJoin::JoinCurvePrepare(curves, 0.0001);\n\t\tauto results = NURBSAPIJoin::JoinCurves(sortedCurves, isReverse, isResultPeriodic);\n\t\tint nresults = static_cast<int>(results.size());\n\t\tfor (int i = 0; i < nresults; i++)\n\t\t{\n\t\t\tOCCTIO::OCCTTool::Write(MakeEdge(results[i]), outdir + \"joinCurve\" + to_string(i) + \".brep\");\n\t\t}\n\t\tauto explodeResult = NURBSAPIExplode::ExplodeCurve(results.front());\n\t\tint expResults = static_cast<int>(explodeResult.size());\n\t\tfor (int j = 0; j < expResults; j++)\n\t\t{\n\t\t\tOCCTIO::OCCTTool::Write(MakeEdge(explodeResult[j]), outdir + \"expCurve\" + to_string(j) + \".brep\");\n\t\t}\n\t\tCHECK(results.size() == 1);\n\t\tCHECK(explodeResult.size() == 3);\n\t\tPoint3 p1, p2, p3, p4;\n\t\tp1 = curves[0]->StartPoint();\n\t\tp2 = curves[2]->EndPoint();\n\t\tp3 = results[0]->StartPoint();\n\t\tp4 = results[0]->EndPoint();\n\t\tCHECK(p1.X() == Approx(p3.X()));\n\t\tCHECK(p1.Y() == Approx(p3.Y()));\n\t\tCHECK(p1.Z() == Approx(p3.Z()));\n\t\tCHECK(p2.X() == Approx(p4.X()));\n\t\tCHECK(p2.Y() == Approx(p4.Y()));\n\t\tCHECK(p2.Z() == Approx(p4.Z()));\n\t\tTopoShape c1 = MakeEdge(curves[0]);\n\t\tTopoShape c2 = MakeEdge(curves[1]);\n\t\tTopoShape c3 = MakeEdge(curves[2]);\n\t\tTopoShape c = MakeEdge(results[0]);\n\t\tTopoShape e1 = MakeEdge(explodeResult[0]);\n\t\tTopoShape e2 = MakeEdge(explodeResult[1]);\n\t\tTopoShape e3 = MakeEdge(explodeResult[2]);\n\t\tGlobalProperty props1, props2, props3, props4, props5, props6, props7;\n\t\tdouble len1 = GetLinearProperties(c1, props1, true, false);\n\t\tdouble len2 = GetLinearProperties(c2, props2, true, false);\n\t\tdouble len3 = GetLinearProperties(c3, props3, true, false);\n\t\tdouble joinLen = GetLinearProperties(c, props4, true, false);\n\t\tdouble exLen1 = GetLinearProperties(e1, props5, true, false);\n\t\tdouble exLen2 = GetLinearProperties(e2, props6, true, false);\n\t\tdouble exLen3 = GetLinearProperties(e3, props7, true, false);\n\t\tdouble cuvLen = len1 + len2 + len3;\n\t\tdouble len = abs(cuvLen - joinLen);\n\t\tdouble len11 = abs(len1 - exLen1);\n\t\tdouble len22 = abs(len2 - exLen2);\n\t\tdouble len33 = abs(len3 - exLen3);\n\t\tCHECK(len < 0.1);\n\t\tCHECK(len11 < 0.1);\n\t\tCHECK(len22 < 0.1);\n\t\tCHECK(len33 < 0.1);\n\t\tdouble res1 = NurbsSampleCurve(num, sTol,  curves[0], explodeResult[0]);\n\t\tdouble res2 = NurbsSampleCurve(num, sTol,  curves[1], explodeResult[1]);\n\t\tdouble res3 = NurbsSampleCurve(num, sTol,  curves[2], explodeResult[2]);\n\t\tCHECK(res1 <= ratio);\n\t\tCHECK(res2 <= ratio);\n\t\tCHECK(res3 <= ratio);\n\t\tdouble res4 = NurbsSampleCurve(num, sTol, curves[0], results[0]);\n\t\tdouble res5 = NurbsSampleCurve(num, sTol, curves[1], results[0]);\n\t\tdouble res6 = NurbsSampleCurve(num, sTol, curves[2], results[0]);\n\t\tCHECK(res4 <= ratio);\n\t\tCHECK(res5 <= ratio);\n\t\tCHECK(res6 <= ratio);\n\t\tOCCTIO::OCCTTool::Write(MakeEdge(curves[0]), outdir + \"curve0.brep\");\n\t\tOCCTIO::OCCTTool::Write(MakeEdge(curves[1]), outdir + \"curve1.brep\");\n\t\tOCCTIO::OCCTTool::Write(MakeEdge(curves[2]), outdir + \"curve2.brep\");\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static std::vector<std::shared_ptr<Geom3BSplineCurve>> JoinCurves( const std::vector<std::vector<std::shared_ptr<Geom3BSplineCurve>>>& curves, const std::vector<std::vector<bool>>& isReverse, const std::vector<bool>& isPeriodic),\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <nurbs/NURBSAPIJoin.hpp>\n#include <topology/TopoEdge.hpp>\n#include <topology/TopoTool.hpp>\n#include <nurbs/NURBSAPIExplode.hpp>\n#include <common/Precision.hpp>\n#include <common/CartesianCoordinateSystem.hpp>\n#include <geometry/Geom3BSplineCurve.hpp>\n#include <nurbs/NURBSAPIJoin.hpp>\n#include <geometry/Geom3BSplineCurve.hpp>\n#include <geometry/Geom3BSplineSurface.hpp>\n#include <topology/TopoFace.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeFace.hpp>\n#include <nurbs/NURBSAPIInterpolate.hpp>\nTEST_CASE(\"bug1: JoinCurve http :\n{\n\tOUTPUT_DIRECTORY(nurbs, Join/bug468);\n\tdouble eps = 1e-4;\n\tstring filedir = INPUT_PATH_PREFIX\"./TestNURBS/TestJoinSurface/\";\n\tstd::vector<std::shared_ptr<Geom3BSplineSurface>> surfaces;\n\tsurfaces.push_back(ReadBRepSurface(filedir + \"surface0.brep\"));\n\tsurfaces.push_back(ReadBRepSurface(filedir + \"surface1.brep\"));\n\tsurfaces.push_back(ReadBRepSurface(filedir + \"surface2.brep\"));\n\tsurfaces.push_back(ReadBRepSurface(filedir + \"surface3.brep\"));\n\tauto [sortedSurfaces, isUIso, isFrontBackReverse, isIsoReverse, isLocalUPeriodic, isLocalVPeriodic] = NURBSAPIJoin::JoinSurfacesPrepare(surfaces, 0.0001);\n\tauto [isSucceed, result] = NURBSAPIJoin::JoinSurfaces(sortedSurfaces, isUIso, isFrontBackReverse, isIsoReverse, isLocalUPeriodic, isLocalVPeriodic);\n\tThrow_Construction_Error_if(!isSucceed, \"failed\");\n\tauto explodeResult = NURBSAPIExplode::ExplodeSurface(result);\n\tTopoShape f1 = MakeFace(surfaces[0], 0.0);\n\tTopoShape f2 = MakeFace(surfaces[1], 0.0);\n\tTopoShape f3 = MakeFace(surfaces[2], 0.0);\n\tTopoShape f4 = MakeFace(surfaces[3], 0.0);\n\tTopoShape f = MakeFace(result, 0.0);\n\tGlobalProperty props1, props2, props3, props4, props5, props6, props7, props8;\n\tdouble surf1 = GetSurfaceProperties(f1, props1, true, false);\n\tdouble surf2 = GetSurfaceProperties(f2, props2, true, false);\n\tdouble surf3 = GetSurfaceProperties(f3, props3, true, false);\n\tdouble surf4 = GetSurfaceProperties(f4, props4, true, false);\n\tdouble surface = GetSurfacePropertiesEps(f, props5, eps, true);\n\tdouble surf = surf1 + surf2 + surf3 + surf4;\n\tdouble dif = abs(surface - surf);\n\tCHECK(GetTopoCount(MakeFace(result, 0.0), ShapeType::Face) == 1);\n\tCHECK(dif < 0.1);\n\tOCCTIO::OCCTTool::Write(MakeFace(surfaces[0], 0.0), outdir + \"surf1.brep\");\n\tOCCTIO::OCCTTool::Write(MakeFace(surfaces[1], 0.0), outdir + \"surf2.brep\");\n\tOCCTIO::OCCTTool::Write(MakeFace(surfaces[2], 0.0), outdir + \"surf3.brep\");\n\tOCCTIO::OCCTTool::Write(MakeFace(surfaces[3], 0.0), outdir + \"surf4.brep\");\n\tOCCTIO::OCCTTool::Write(MakeFace(result, 0.0), outdir + \"joinSurf.brep\");\n}\n#include<catch.hpp>\n#include<testHelper.h>\n#include <nurbs/NURBSAPIJoin.hpp>\n#include <topology/TopoEdge.hpp>\n#include <topology/TopoTool.hpp>\n#include <nurbs/NURBSAPIExplode.hpp>\n#include <common/Precision.hpp>\n#include <common/CartesianCoordinateSystem.hpp>\n#include <geometry/Geom3BSplineCurve.hpp>\n#include <nurbs/NURBSAPIJoin.hpp>\n#include <geometry/Geom3BSplineCurve.hpp>\n#include <geometry/Geom3BSplineSurface.hpp>\n#include <topology/TopoFace.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeFace.hpp>\n#include <nurbs/NURBSAPIInterpolate.hpp>\nTEST_CASE(\"bug1: JoinCurve http :\n{\n\tOUTPUT_DIRECTORY(nurbs, Join/bug468);\n\tdouble eps = 1e-4;\n\tstring filedir = INPUT_PATH_PREFIX\"./TestNURBS/TestJoinSurface/\";\n\tstd::vector<std::shared_ptr<Geom3BSplineSurface>> surfaces;\n\tsurfaces.push_back(ReadBRepSurface(filedir + \"surface0.brep\"));\n\tsurfaces.push_back(ReadBRepSurface(filedir + \"surface1.brep\"));\n\tsurfaces.push_back(ReadBRepSurface(filedir + \"surface2.brep\"));\n\tsurfaces.push_back(ReadBRepSurface(filedir + \"surface3.brep\"));\n\tauto [sortedSurfaces, isUIso, isFrontBackReverse, isIsoReverse, isLocalUPeriodic, isLocalVPeriodic] = NURBSAPIJoin::JoinSurfacesPrepare(surfaces, 0.0001);\n\tauto [isSucceed, result] = NURBSAPIJoin::JoinSurfaces(sortedSurfaces, isUIso, isFrontBackReverse, isIsoReverse, isLocalUPeriodic, isLocalVPeriodic);\n\tThrow_Construction_Error_if(!isSucceed, \"failed\");\n\tauto explodeResult = NURBSAPIExplode::ExplodeSurface(result);\n\tTopoShape f1 = MakeFace(surfaces[0], 0.0);\n\tTopoShape f2 = MakeFace(surfaces[1], 0.0);\n\tTopoShape f3 = MakeFace(surfaces[2], 0.0);\n\tTopoShape f4 = MakeFace(surfaces[3], 0.0);\n\tTopoShape f = MakeFace(result, 0.0);\n\tGlobalProperty props1, props2, props3, props4, props5, props6, props7, props8;\n\tdouble surf1 = GetSurfaceProperties(f1, props1, true, false);\n\tdouble surf2 = GetSurfaceProperties(f2, props2, true, false);\n\tdouble surf3 = GetSurfaceProperties(f3, props3, true, false);\n\tdouble surf4 = GetSurfaceProperties(f4, props4, true, false);\n\tdouble surface = GetSurfacePropertiesEps(f, props5, eps, true);\n\tdouble surf = surf1 + surf2 + surf3 + surf4;\n\tdouble dif = abs(surface - surf);\n\tCHECK(GetTopoCount(MakeFace(result, 0.0), ShapeType::Face) == 1);\n\tCHECK(dif < 0.1);\n\tOCCTIO::OCCTTool::Write(MakeFace(surfaces[0], 0.0), outdir + \"surf1.brep\");\n\tOCCTIO::OCCTTool::Write(MakeFace(surfaces[1], 0.0), outdir + \"surf2.brep\");\n\tOCCTIO::OCCTTool::Write(MakeFace(surfaces[2], 0.0), outdir + \"surf3.brep\");\n\tOCCTIO::OCCTTool::Write(MakeFace(surfaces[3], 0.0), outdir + \"surf4.brep\");\n\tOCCTIO::OCCTTool::Write(MakeFace(result, 0.0), outdir + \"joinSurf.brep\");\n;\n\tSECTION(\"isPeriodic\")\n\t{\n\t\tOUTPUT_DIRECTORY(nurbs, Join/JoinCurve1);\n\t\tfilename = \"periodicCurve\";\n\t\tstd::vector<std::shared_ptr<Geom3BSplineCurve>> curves;\n\t\tfor (int i = 0; i < 3; i++)\n\t\t{\n\t\t\tcurves.push_back(ReadBRepCurve(filedir + filename + std::to_string(i) + \".brep\"));\n\t\t}\n\t\tauto [sortedCurves, isReverse, isResultPeriodic] = NURBSAPIJoin::JoinCurvePrepare(curves, 0.0001);\n\t\tauto results = NURBSAPIJoin::JoinCurves(sortedCurves, isReverse, isResultPeriodic);\n\t\tint nresults = static_cast<int>(results.size());\n\t\tfor (int i = 0; i < nresults; i++)\n\t\t{\n\t\t\tOCCTIO::OCCTTool::Write(MakeEdge(results[i]), outdir + \"joinCurve\" + to_string(i) + \".brep\");\n\t\t}\n\t\tauto explodeResult = NURBSAPIExplode::ExplodeCurve(results.front());\n\t\tint expResults = static_cast<int>(explodeResult.size());\n\t\tfor (int j = 0; j < expResults; j++)\n\t\t{\n\t\t\tOCCTIO::OCCTTool::Write(MakeEdge(explodeResult[j]), outdir + \"expCurve\" + to_string(j) + \".brep\");\n\t\t}\n\t\tCHECK(results.size() == 1);\n\t\tCHECK(explodeResult.size() == 3);\n\t\tPoint3 p1, p2, p3, p4;\n\t\tp1 = curves[0]->StartPoint();\n\t\tp2 = curves[2]->EndPoint();\n\t\tp3 = results[0]->StartPoint();\n\t\tp4 = results[0]->EndPoint();\n\t\tCHECK(p1.X() == Approx(p3.X()));\n\t\tCHECK(p1.Y() == Approx(p3.Y()));\n\t\tCHECK(p1.Z() == Approx(p3.Z()));\n\t\tCHECK(p2.X() == Approx(p4.X()));\n\t\tCHECK(p2.Y() == Approx(p4.Y()));\n\t\tCHECK(p2.Z() == Approx(p4.Z()));\n\t\tTopoShape c1 = MakeEdge(curves[0]);\n\t\tTopoShape c2 = MakeEdge(curves[1]);\n\t\tTopoShape c3 = MakeEdge(curves[2]);\n\t\tTopoShape c = MakeEdge(results[0]);\n\t\tTopoShape e1 = MakeEdge(explodeResult[0]);\n\t\tTopoShape e2 = MakeEdge(explodeResult[1]);\n\t\tTopoShape e3 = MakeEdge(explodeResult[2]);\n\t\tGlobalProperty props1, props2, props3, props4, props5, props6, props7;\n\t\tdouble len1 = GetLinearProperties(c1, props1, true, false);\n\t\tdouble len2 = GetLinearProperties(c2, props2, true, false);\n\t\tdouble len3 = GetLinearProperties(c3, props3, true, false);\n\t\tdouble joinLen = GetLinearProperties(c, props4, true, false);\n\t\tdouble exLen1 = GetLinearProperties(e1, props5, true, false);\n\t\tdouble exLen2 = GetLinearProperties(e2, props6, true, false);\n\t\tdouble exLen3 = GetLinearProperties(e3, props7, true, false);\n\t\tdouble cuvLen = len1 + len2 + len3;\n\t\tdouble len = abs(cuvLen - joinLen);\n\t\tdouble len11 = abs(len1 - exLen1);\n\t\tdouble len22 = abs(len2 - exLen2);\n\t\tdouble len33 = abs(len3 - exLen3);\n\t\tCHECK(len < 0.1);\n\t\tCHECK(len11 < 0.1);\n\t\tCHECK(len22 < 0.1);\n\t\tCHECK(len33 < 0.1);\n\t\tdouble res1 = NurbsSampleCurve(num, sTol,  curves[0], explodeResult[0]);\n\t\tdouble res2 = NurbsSampleCurve(num, sTol,  curves[1], explodeResult[1]);\n\t\tdouble res3 = NurbsSampleCurve(num, sTol,  curves[2], explodeResult[2]);\n\t\tCHECK(res1 <= ratio);\n\t\tCHECK(res2 <= ratio);\n\t\tCHECK(res3 <= ratio);\n\t\tdouble res4 = NurbsSampleCurve(num, sTol, curves[0], results[0]);\n\t\tdouble res5 = NurbsSampleCurve(num, sTol, curves[1], results[0]);\n\t\tdouble res6 = NurbsSampleCurve(num, sTol, curves[2], results[0]);\n\t\tCHECK(res4 <= ratio);\n\t\tCHECK(res5 <= ratio);\n\t\tCHECK(res6 <= ratio);\n\t\tOCCTIO::OCCTTool::Write(MakeEdge(curves[0]), outdir + \"curve0.brep\");\n\t\tOCCTIO::OCCTTool::Write(MakeEdge(curves[1]), outdir + \"curve1.brep\");\n\t\tOCCTIO::OCCTTool::Write(MakeEdge(curves[2]), outdir + \"curve2.brep\");\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static std::pair<std::shared_ptr<Geom3BSplineCurve>, std::shared_ptr<Geom2BSplineCurve>> JoinCurves( const std::vector<std::shared_ptr<Geom3BSplineCurve>>& curves, const std::vector<std::shared_ptr<Geom2BSplineCurve>>& curve2ds, const std::vector<bool>& isReverse, bool isPeriodic),\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <nurbs/NURBSAPIJoin.hpp>\n#include <topology/TopoEdge.hpp>\n#include <topology/TopoTool.hpp>\n#include <nurbs/NURBSAPIExplode.hpp>\n#include <common/Precision.hpp>\n#include <common/CartesianCoordinateSystem.hpp>\n#include <geometry/Geom3BSplineCurve.hpp>\n#include <nurbs/NURBSAPIJoin.hpp>\n#include <geometry/Geom3BSplineCurve.hpp>\n#include <geometry/Geom3BSplineSurface.hpp>\n#include <topology/TopoFace.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeFace.hpp>\n#include <nurbs/NURBSAPIInterpolate.hpp>\nTEST_CASE(\"bug1: JoinCurve http :\n{\n\tOUTPUT_DIRECTORY(nurbs, Join/bug468);\n\tdouble eps = 1e-4;\n\tstring filedir = INPUT_PATH_PREFIX\"./TestNURBS/TestJoinSurface/\";\n\tstd::vector<std::shared_ptr<Geom3BSplineSurface>> surfaces;\n\tsurfaces.push_back(ReadBRepSurface(filedir + \"surface0.brep\"));\n\tsurfaces.push_back(ReadBRepSurface(filedir + \"surface1.brep\"));\n\tsurfaces.push_back(ReadBRepSurface(filedir + \"surface2.brep\"));\n\tsurfaces.push_back(ReadBRepSurface(filedir + \"surface3.brep\"));\n\tauto [sortedSurfaces, isUIso, isFrontBackReverse, isIsoReverse, isLocalUPeriodic, isLocalVPeriodic] = NURBSAPIJoin::JoinSurfacesPrepare(surfaces, 0.0001);\n\tauto [isSucceed, result] = NURBSAPIJoin::JoinSurfaces(sortedSurfaces, isUIso, isFrontBackReverse, isIsoReverse, isLocalUPeriodic, isLocalVPeriodic);\n\tThrow_Construction_Error_if(!isSucceed, \"failed\");\n\tauto explodeResult = NURBSAPIExplode::ExplodeSurface(result);\n\tTopoShape f1 = MakeFace(surfaces[0], 0.0);\n\tTopoShape f2 = MakeFace(surfaces[1], 0.0);\n\tTopoShape f3 = MakeFace(surfaces[2], 0.0);\n\tTopoShape f4 = MakeFace(surfaces[3], 0.0);\n\tTopoShape f = MakeFace(result, 0.0);\n\tGlobalProperty props1, props2, props3, props4, props5, props6, props7, props8;\n\tdouble surf1 = GetSurfaceProperties(f1, props1, true, false);\n\tdouble surf2 = GetSurfaceProperties(f2, props2, true, false);\n\tdouble surf3 = GetSurfaceProperties(f3, props3, true, false);\n\tdouble surf4 = GetSurfaceProperties(f4, props4, true, false);\n\tdouble surface = GetSurfacePropertiesEps(f, props5, eps, true);\n\tdouble surf = surf1 + surf2 + surf3 + surf4;\n\tdouble dif = abs(surface - surf);\n\tCHECK(GetTopoCount(MakeFace(result, 0.0), ShapeType::Face) == 1);\n\tCHECK(dif < 0.1);\n\tOCCTIO::OCCTTool::Write(MakeFace(surfaces[0], 0.0), outdir + \"surf1.brep\");\n\tOCCTIO::OCCTTool::Write(MakeFace(surfaces[1], 0.0), outdir + \"surf2.brep\");\n\tOCCTIO::OCCTTool::Write(MakeFace(surfaces[2], 0.0), outdir + \"surf3.brep\");\n\tOCCTIO::OCCTTool::Write(MakeFace(surfaces[3], 0.0), outdir + \"surf4.brep\");\n\tOCCTIO::OCCTTool::Write(MakeFace(result, 0.0), outdir + \"joinSurf.brep\");\n}\n#include<catch.hpp>\n#include<testHelper.h>\n#include <nurbs/NURBSAPIJoin.hpp>\n#include <topology/TopoEdge.hpp>\n#include <topology/TopoTool.hpp>\n#include <nurbs/NURBSAPIExplode.hpp>\n#include <common/Precision.hpp>\n#include <common/CartesianCoordinateSystem.hpp>\n#include <geometry/Geom3BSplineCurve.hpp>\n#include <nurbs/NURBSAPIJoin.hpp>\n#include <geometry/Geom3BSplineCurve.hpp>\n#include <geometry/Geom3BSplineSurface.hpp>\n#include <topology/TopoFace.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeFace.hpp>\n#include <nurbs/NURBSAPIInterpolate.hpp>\nTEST_CASE(\"bug1: JoinCurve http :\n{\n\tOUTPUT_DIRECTORY(nurbs, Join/bug468);\n\tdouble eps = 1e-4;\n\tstring filedir = INPUT_PATH_PREFIX\"./TestNURBS/TestJoinSurface/\";\n\tstd::vector<std::shared_ptr<Geom3BSplineSurface>> surfaces;\n\tsurfaces.push_back(ReadBRepSurface(filedir + \"surface0.brep\"));\n\tsurfaces.push_back(ReadBRepSurface(filedir + \"surface1.brep\"));\n\tsurfaces.push_back(ReadBRepSurface(filedir + \"surface2.brep\"));\n\tsurfaces.push_back(ReadBRepSurface(filedir + \"surface3.brep\"));\n\tauto [sortedSurfaces, isUIso, isFrontBackReverse, isIsoReverse, isLocalUPeriodic, isLocalVPeriodic] = NURBSAPIJoin::JoinSurfacesPrepare(surfaces, 0.0001);\n\tauto [isSucceed, result] = NURBSAPIJoin::JoinSurfaces(sortedSurfaces, isUIso, isFrontBackReverse, isIsoReverse, isLocalUPeriodic, isLocalVPeriodic);\n\tThrow_Construction_Error_if(!isSucceed, \"failed\");\n\tauto explodeResult = NURBSAPIExplode::ExplodeSurface(result);\n\tTopoShape f1 = MakeFace(surfaces[0], 0.0);\n\tTopoShape f2 = MakeFace(surfaces[1], 0.0);\n\tTopoShape f3 = MakeFace(surfaces[2], 0.0);\n\tTopoShape f4 = MakeFace(surfaces[3], 0.0);\n\tTopoShape f = MakeFace(result, 0.0);\n\tGlobalProperty props1, props2, props3, props4, props5, props6, props7, props8;\n\tdouble surf1 = GetSurfaceProperties(f1, props1, true, false);\n\tdouble surf2 = GetSurfaceProperties(f2, props2, true, false);\n\tdouble surf3 = GetSurfaceProperties(f3, props3, true, false);\n\tdouble surf4 = GetSurfaceProperties(f4, props4, true, false);\n\tdouble surface = GetSurfacePropertiesEps(f, props5, eps, true);\n\tdouble surf = surf1 + surf2 + surf3 + surf4;\n\tdouble dif = abs(surface - surf);\n\tCHECK(GetTopoCount(MakeFace(result, 0.0), ShapeType::Face) == 1);\n\tCHECK(dif < 0.1);\n\tOCCTIO::OCCTTool::Write(MakeFace(surfaces[0], 0.0), outdir + \"surf1.brep\");\n\tOCCTIO::OCCTTool::Write(MakeFace(surfaces[1], 0.0), outdir + \"surf2.brep\");\n\tOCCTIO::OCCTTool::Write(MakeFace(surfaces[2], 0.0), outdir + \"surf3.brep\");\n\tOCCTIO::OCCTTool::Write(MakeFace(surfaces[3], 0.0), outdir + \"surf4.brep\");\n\tOCCTIO::OCCTTool::Write(MakeFace(result, 0.0), outdir + \"joinSurf.brep\");\n;\n\tSECTION(\"isPeriodic\")\n\t{\n\t\tOUTPUT_DIRECTORY(nurbs, Join/JoinCurve1);\n\t\tfilename = \"periodicCurve\";\n\t\tstd::vector<std::shared_ptr<Geom3BSplineCurve>> curves;\n\t\tfor (int i = 0; i < 3; i++)\n\t\t{\n\t\t\tcurves.push_back(ReadBRepCurve(filedir + filename + std::to_string(i) + \".brep\"));\n\t\t}\n\t\tauto [sortedCurves, isReverse, isResultPeriodic] = NURBSAPIJoin::JoinCurvePrepare(curves, 0.0001);\n\t\tauto results = NURBSAPIJoin::JoinCurves(sortedCurves, isReverse, isResultPeriodic);\n\t\tint nresults = static_cast<int>(results.size());\n\t\tfor (int i = 0; i < nresults; i++)\n\t\t{\n\t\t\tOCCTIO::OCCTTool::Write(MakeEdge(results[i]), outdir + \"joinCurve\" + to_string(i) + \".brep\");\n\t\t}\n\t\tauto explodeResult = NURBSAPIExplode::ExplodeCurve(results.front());\n\t\tint expResults = static_cast<int>(explodeResult.size());\n\t\tfor (int j = 0; j < expResults; j++)\n\t\t{\n\t\t\tOCCTIO::OCCTTool::Write(MakeEdge(explodeResult[j]), outdir + \"expCurve\" + to_string(j) + \".brep\");\n\t\t}\n\t\tCHECK(results.size() == 1);\n\t\tCHECK(explodeResult.size() == 3);\n\t\tPoint3 p1, p2, p3, p4;\n\t\tp1 = curves[0]->StartPoint();\n\t\tp2 = curves[2]->EndPoint();\n\t\tp3 = results[0]->StartPoint();\n\t\tp4 = results[0]->EndPoint();\n\t\tCHECK(p1.X() == Approx(p3.X()));\n\t\tCHECK(p1.Y() == Approx(p3.Y()));\n\t\tCHECK(p1.Z() == Approx(p3.Z()));\n\t\tCHECK(p2.X() == Approx(p4.X()));\n\t\tCHECK(p2.Y() == Approx(p4.Y()));\n\t\tCHECK(p2.Z() == Approx(p4.Z()));\n\t\tTopoShape c1 = MakeEdge(curves[0]);\n\t\tTopoShape c2 = MakeEdge(curves[1]);\n\t\tTopoShape c3 = MakeEdge(curves[2]);\n\t\tTopoShape c = MakeEdge(results[0]);\n\t\tTopoShape e1 = MakeEdge(explodeResult[0]);\n\t\tTopoShape e2 = MakeEdge(explodeResult[1]);\n\t\tTopoShape e3 = MakeEdge(explodeResult[2]);\n\t\tGlobalProperty props1, props2, props3, props4, props5, props6, props7;\n\t\tdouble len1 = GetLinearProperties(c1, props1, true, false);\n\t\tdouble len2 = GetLinearProperties(c2, props2, true, false);\n\t\tdouble len3 = GetLinearProperties(c3, props3, true, false);\n\t\tdouble joinLen = GetLinearProperties(c, props4, true, false);\n\t\tdouble exLen1 = GetLinearProperties(e1, props5, true, false);\n\t\tdouble exLen2 = GetLinearProperties(e2, props6, true, false);\n\t\tdouble exLen3 = GetLinearProperties(e3, props7, true, false);\n\t\tdouble cuvLen = len1 + len2 + len3;\n\t\tdouble len = abs(cuvLen - joinLen);\n\t\tdouble len11 = abs(len1 - exLen1);\n\t\tdouble len22 = abs(len2 - exLen2);\n\t\tdouble len33 = abs(len3 - exLen3);\n\t\tCHECK(len < 0.1);\n\t\tCHECK(len11 < 0.1);\n\t\tCHECK(len22 < 0.1);\n\t\tCHECK(len33 < 0.1);\n\t\tdouble res1 = NurbsSampleCurve(num, sTol,  curves[0], explodeResult[0]);\n\t\tdouble res2 = NurbsSampleCurve(num, sTol,  curves[1], explodeResult[1]);\n\t\tdouble res3 = NurbsSampleCurve(num, sTol,  curves[2], explodeResult[2]);\n\t\tCHECK(res1 <= ratio);\n\t\tCHECK(res2 <= ratio);\n\t\tCHECK(res3 <= ratio);\n\t\tdouble res4 = NurbsSampleCurve(num, sTol, curves[0], results[0]);\n\t\tdouble res5 = NurbsSampleCurve(num, sTol, curves[1], results[0]);\n\t\tdouble res6 = NurbsSampleCurve(num, sTol, curves[2], results[0]);\n\t\tCHECK(res4 <= ratio);\n\t\tCHECK(res5 <= ratio);\n\t\tCHECK(res6 <= ratio);\n\t\tOCCTIO::OCCTTool::Write(MakeEdge(curves[0]), outdir + \"curve0.brep\");\n\t\tOCCTIO::OCCTTool::Write(MakeEdge(curves[1]), outdir + \"curve1.brep\");\n\t\tOCCTIO::OCCTTool::Write(MakeEdge(curves[2]), outdir + \"curve2.brep\");\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static std::shared_ptr<Geom3BSplineCurve> InterpolatePoints(const std::vector<Point3>& points, int degree = 3, bool isClosed = false, ApproxParameterizationType ptype = ApproxParameterizationType::ChordLength)\t @return The curve\n\t @param ptype Parameterization type\n\t @param isClosed Is the curve closed\n\t @param degree Curve degree\n\t @param points Data points\n\t @brief The curve which interpolate the points is constructed\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <nurbs/NURBSAPIInterpolate.hpp>\n#include <nurbs/NURBSAPIApprox.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <topology/BRepExtremaDistShapeShape.hpp>\n#include <geometry/GeomAPIProjectPointOnCurve3.hpp>\n#include <nurbs/NURBSAPIBuildCurve.hpp>\n#include<catch.hpp>\n#include<testHelper.h>\n#include <nurbs/NURBSAPIInterpolate.hpp>\n#include <nurbs/NURBSAPIApprox.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <topology/BRepExtremaDistShapeShape.hpp>\n#include <geometry/GeomAPIProjectPointOnCurve3.hpp>\n#include <nurbs/NURBSAPIBuildCurve.hpp>\n;\n\tSECTION(\"TestApproxInterpolatePeriodicCurve\")\n\t{\n\t\tOUTPUT_DIRECTORY(nurbs, Interpolate/ApproxInterpolatePeriodicCurve);\n\t\tstd::vector<Point3> points;\n\t\tPoint3 p1(0.0, -0.7, 0.0);\n\t\tPoint3 p2(0.2, -0.6, 0.0);\n\t\tPoint3 p3(0.5, 0.0, 0.0);\n\t\tPoint3 p4(0.7, 0.1, 0.0);\n\t\tPoint3 p5(0.5, 0.3, 0.0);\n\t\tPoint3 p6(0.3, 0.7, 0.0);\n\t\tPoint3 p7(0.0, 0.8, 0.0);\n\t\tPoint3 p8(-0.3, 0.9, 0.0);\n\t\tPoint3 p9(-0.8, 0.5, 0.0);\n\t\tPoint3 p10(-0.7, 0.1, 0.0);\n\t\tPoint3 p11(-0.6, -0.2, 0.0);\n\t\tPoint3 p12(-0.3, -0.7, 0.0);\n\t\tpoints.push_back(p1);\n\t\tpoints.push_back(p2);\n\t\tpoints.push_back(p3);\n\t\tpoints.push_back(p4);\n\t\tpoints.push_back(p5);\n\t\tpoints.push_back(p6);\n\t\tpoints.push_back(p7);\n\t\tpoints.push_back(p8);\n\t\tpoints.push_back(p9);\n\t\tpoints.push_back(p10);\n\t\tpoints.push_back(p11);\n\t\tpoints.push_back(p12);\n\t\tApproxParameterizationType ptype = ApproxParameterizationType::Centripetal;\n\t\tbool isPeriodic = true;\n\t\tauto curve1 = NURBSAPIApprox::ApproxPoints(points, 3, 7, isPeriodic, ptype);\n\t\tauto curve2 = NURBSAPIInterpolate::InterpolatePoints(points, 3, isPeriodic, ptype);\n\t\tPoint3 sp = curve2->StartPoint();\n\t\tPoint3 ep = curve2->EndPoint();\n\t\tCHECK(sp.X() == Approx(0.0).margin(1e-7));\n\t\tCHECK(sp.Y() == Approx(-0.7).margin(1e-7));\n\t\tCHECK(sp.Z() == Approx(0.0).margin(1e-7));\n\t\tCHECK(ep.X() == Approx(sp.X()).margin(1e-7));\n\t\tCHECK(ep.Y() == sp.Y());\n\t\tCHECK(ep.Z() == sp.Z());\n\t\tTopoVertex v1 = MakeVertex(p1);\n\t\tTopoVertex v2 = MakeVertex(p2);\n\t\tTopoVertex v3 = MakeVertex(p3);\n\t\tTopoVertex v4 = MakeVertex(p4);\n\t\tTopoVertex v5 = MakeVertex(p5);\n\t\tTopoVertex v6 = MakeVertex(p6);\n\t\tTopoVertex v7 = MakeVertex(p7);\n\t\tTopoVertex v8 = MakeVertex(p8);\n\t\tTopoVertex v9 = MakeVertex(p9);\n\t\tTopoVertex v10 = MakeVertex(p10);\n\t\tTopoVertex v11 = MakeVertex(p11);\n\t\tTopoVertex v12 = MakeVertex(p12);\n\t\tTopoEdge edge2 = MakeEdge(curve2);\n\t\tBRepExtremaDistShapeShape dist1(v1, edge2);\n\t\tBRepExtremaDistShapeShape dist2(v2, edge2);\n\t\tBRepExtremaDistShapeShape dist3(v3, edge2);\n\t\tBRepExtremaDistShapeShape dist4(v4, edge2);\n\t\tBRepExtremaDistShapeShape dist5(v5, edge2);\n\t\tBRepExtremaDistShapeShape dist6(v6, edge2);\n\t\tBRepExtremaDistShapeShape dist7(v7, edge2);\n\t\tBRepExtremaDistShapeShape dist8(v8, edge2);\n\t\tBRepExtremaDistShapeShape dist9(v9, edge2);\n\t\tBRepExtremaDistShapeShape dist10(v10, edge2);\n\t\tBRepExtremaDistShapeShape dist11(v11, edge2);\n\t\tBRepExtremaDistShapeShape dist12(v12, edge2);\n\t\tCHECK(dist1.Value() <= Approx(tol));\n\t\tCHECK(dist2.Value() <= Approx(tol));\n\t\tCHECK(dist3.Value() <= Approx(tol));\n\t\tCHECK(dist4.Value() <= Approx(tol));\n\t\tCHECK(dist5.Value() <= Approx(tol));\n\t\tCHECK(dist6.Value() <= Approx(tol));\n\t\tCHECK(dist7.Value() <= Approx(tol));\n\t\tCHECK(dist8.Value() <= Approx(tol));\n\t\tCHECK(dist9.Value() <= Approx(tol));\n\t\tCHECK(dist10.Value() <= Approx(tol));\n\t\tCHECK(dist11.Value() <= Approx(tol));\n\t\tCHECK(dist12.Value() <= Approx(tol));\n\t\tCHECK(curve1->Degree() == 3);\n\t\tCHECK(curve1->NPoles() == 7);\n\t\tCHECK(curve1->IsClosed() == true);\n\t\tCHECK(curve1->IsPeriodic() == true);\n\t\tfor (int i = 0; i < points.size(); i++)\n\t\t{\n\t\t\tdouble maxValue = -1.0;\n\t\t\tbool res;\n\t\t\tGeomAPIProjectPointOnCurve3 prop(points[i], curve2);\n\t\t\tdouble param = prop.LowerDistanceParameter();\n\t\t\tif (maxValue > param)\n\t\t\t{\n\t\t\t\tres = false;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tmaxValue = param;\n\t\t\t\tres = true;\n\t\t\t}\n\t\t\tCHECK(res == true);\n\t\t}\n\t\tOCCTIO::OCCTTool::Write(MakeVertex(points[0]), outdir + \"p1.brep\");\n\t\tOCCTIO::OCCTTool::Write(MakeVertex(points[1]), outdir + \"p2.brep\");\n\t\tOCCTIO::OCCTTool::Write(MakeVertex(points[2]), outdir + \"p3.brep\");\n\t\tOCCTIO::OCCTTool::Write(MakeVertex(points[3]), outdir + \"p4.brep\");\n\t\tOCCTIO::OCCTTool::Write(MakeVertex(points[4]), outdir + \"p5.brep\");\n\t\tOCCTIO::OCCTTool::Write(MakeVertex(points[5]), outdir + \"p6.brep\");\n\t\tOCCTIO::OCCTTool::Write(MakeVertex(points[6]), outdir + \"p7.brep\");\n\t\tOCCTIO::OCCTTool::Write(MakeVertex(points[7]), outdir + \"p8.brep\");\n\t\tOCCTIO::OCCTTool::Write(MakeVertex(points[8]), outdir + \"p9.brep\");\n\t\tOCCTIO::OCCTTool::Write(MakeVertex(points[9]), outdir + \"p10.brep\");\n\t\tOCCTIO::OCCTTool::Write(MakeVertex(points[10]), outdir + \"p11.brep\");\n\t\tOCCTIO::OCCTTool::Write(MakeVertex(points[11]), outdir + \"p12.brep\");\n\t\tOCCTIO::OCCTTool::Write(MakeEdge(curve2), outdir + \"result.brep\");\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static std::shared_ptr<Geom3Surface> GetSurface(const TopoFace& face)\t @return The trimmed surface\n\t @param face The face\n\t @brief Get not infinite surface from the face such as part of a plane or cylinder\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <nurbs/NURBSAPIGetGeometry.hpp>\n#include <topology/TopoEdge.hpp>\n#include <topology/TopoFace.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <math/CircleT.hpp>\n#include <math/EllipseT.hpp>\n#include <math/HyperbolaT.hpp>\n#include <modeling/MakeFace.hpp>\n#include <math/Plane.hpp>\n#include <math/Cylinder.hpp>\n#include <math/Cone.hpp>\n#include <math/Sphere.hpp>\n#include <math/Torus.hpp>\n#include<catch.hpp>\n#include<testHelper.h>\n#include <nurbs/NURBSAPIGetGeometry.hpp>\n#include <topology/TopoEdge.hpp>\n#include <topology/TopoFace.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <math/CircleT.hpp>\n#include <math/EllipseT.hpp>\n#include <math/HyperbolaT.hpp>\n#include <modeling/MakeFace.hpp>\n#include <math/Plane.hpp>\n#include <math/Cylinder.hpp>\n#include <math/Cone.hpp>\n#include <math/Sphere.hpp>\n#include <math/Torus.hpp>\n;\n\tSECTION(\"Plane\")\n\t{\n\t\tPlane p;\n\t\tTopoFace face = MakeFace(p, 0.0, 1.0, 2.0, 3.0);\n\t\tshared_ptr<Geom3Surface> surface = NURBSAPIGetGeometry::GetSurface(face);\n\t\tdouble u1 = surface->FirstUParameter();\n\t\tdouble u2 = surface->LastUParameter();\n\t\tdouble v1 = surface->FirstVParameter();\n\t\tdouble v2 = surface->LastVParameter();\n\t\tCHECK(u1 == Approx(0.0));\n\t\tCHECK(u2 == Approx(1.0));\n\t\tOCCTIO::OCCTTool::Write(face, outdir + \"Plane.brep\");\n        OCCTIO::OCCTTool::Write(MakeFace(surface, 0.0), outdir + \"geomPlane.brep\");\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static std::shared_ptr<Geom3Curve> GetCurve(const TopoEdge& edge)\t @return The trimmed curve\n\t @param edge The edge\n\t @brief Get not infinite curve from the edge such as part of a line\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <nurbs/NURBSAPIGetGeometry.hpp>\n#include <topology/TopoEdge.hpp>\n#include <topology/TopoFace.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <math/CircleT.hpp>\n#include <math/EllipseT.hpp>\n#include <math/HyperbolaT.hpp>\n#include <modeling/MakeFace.hpp>\n#include <math/Plane.hpp>\n#include <math/Cylinder.hpp>\n#include <math/Cone.hpp>\n#include <math/Sphere.hpp>\n#include <math/Torus.hpp>\n#include<catch.hpp>\n#include<testHelper.h>\n#include <nurbs/NURBSAPIGetGeometry.hpp>\n#include <topology/TopoEdge.hpp>\n#include <topology/TopoFace.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <math/CircleT.hpp>\n#include <math/EllipseT.hpp>\n#include <math/HyperbolaT.hpp>\n#include <modeling/MakeFace.hpp>\n#include <math/Plane.hpp>\n#include <math/Cylinder.hpp>\n#include <math/Cone.hpp>\n#include <math/Sphere.hpp>\n#include <math/Torus.hpp>\n;\n\tSECTION(\"Line\")\n\t{\n\t\tLine3 line;\n\t\tTopoEdge edge = MakeEdge(line);\n\t\tCHECK_THROWS_AS(NURBSAPIGetGeometry::GetCurve(edge), _DomainError);\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static std::shared_ptr<Geom3Surface> ExtendSurfToPoint(const std::shared_ptr<Geom3Surface>& surf, bool isU, bool isFront, const Point3& pt)\t @return New surface\n\t @param pt Point\n\t @param isFront Extend front or back\n\t @param isU Extend u or v\n\t @param surf Surface\n\t The degree of the surface, the size of the extended direction (u or v) knots and poles are not changed.\n\t The original surface is part of new surface.\n\t @brief Extend surface to a point.\n,\n",
      "output": "﻿#include<catch.hpp>\n#include<testHelper.h>\n#include <nurbs/NURBSAPIExtend.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <modeling/MakeFace.hpp>\n#include <topology/BRepExtremaDistShapeShape.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/Geom3Plane.hpp>\n#include <geometry/Geom3TrimmedSurface.hpp>\n#include <nurbs/NURBSAPIConvert.hpp>\n#include <nurbs/NURBSAPIBuildCurve.hpp>\n#include <geomAlgo/LawBSpline.hpp>\n#include <offset/MakePipe.hpp>\n#include <modeling/MakeWire.hpp>\n#include <topology/TopoTool.hpp>\n#include <topology/TopoExplorerTool.hpp>\n#include <geometry/GeomAPIProjectPointOnCurve3.hpp>\n#include <geometry/GeomAPIProjectPointOnSurface.hpp>\ndouble NurbsExtendSample3(int num, double len, double tol, const shared_ptr<Geom3Curve>& curve1, const shared_ptr<Geom3Curve>& curve2)\n{\n\tconst int nsample = num;\n\tdouble fp1 = curve1->FirstParameter();\n\tdouble lp1 = curve1->LastParameter();\n\tdouble delta1 = (lp1 - fp1) / nsample;\n\tPoint3 p;\n\tint n = 0;\n\tfor (int i = 0; i < nsample; i++)\n\t{\n\t\tdouble t1 = fp1 + i * delta1;\n\t\tcurve1->D0(t1, p);\n\t\tTopoVertex vt = MakeVertex(p);\n\t\tTopoEdge edge = MakeEdge(curve2);\n\t\tBRepExtremaDistShapeShape dist(vt, edge);\n\t\tdouble dis = abs(dist.Value() - len);\n\t\tif (dis <= tol)\n\t\t{\n\t\t\tn++;\n\t\t}\n\t}\n\tdouble res = 1.0 * (num - n) / num;\n\treturn res;\n}\nshared_ptr<Geom3Surface> ConstructExtendSurface3()\n{\n\tstd::vector<Point3> profilePoles;\n\tstd::vector<double> profileKnots(3);\n\tstd::vector<int> profileMults(3, 1);\n\tprofilePoles.push_back(Point3(0.0, 0.0, 0.0));\n\tprofilePoles.push_back(Point3(1.0, -0.2, 0.0));\n\tprofilePoles.push_back(Point3(2.0, 0.1, 0.0));\n\tprofilePoles.push_back(Point3(2.3, -0.1, 0.0));\n\tprofilePoles.push_back(Point3(2.9, 0.1, 0.0));\n\tprofileKnots[0] = 0;\n\tprofileKnots[1] = 0.5;\n\tprofileKnots[2] = 1;\n\tprofileMults.front() = 4;\n\tprofileMults.back() = 4;\n\tstd::shared_ptr<Geom3BSplineCurve> profile = std::make_shared<Geom3BSplineCurve>(profilePoles, profileKnots, profileMults, 3);\n\tstd::vector<Point3> spinePoles;\n\tstd::vector<double> spineKnots(4);\n\tstd::vector<int> spineMults(4, 1);\n\tspinePoles.push_back(Point3(0.0, 0.0, 0.0));\n\tspinePoles.push_back(Point3(0.0, 0.0, 1.0));\n\tspinePoles.push_back(Point3(0.0, 0.2, 1.5));\n\tspinePoles.push_back(Point3(0.0, 0.5, 2.0));\n\tspinePoles.push_back(Point3(0.0, 1.0, 2.3));\n\tspinePoles.push_back(Point3(0.0, 1.6, 2.3));\n\tspineKnots[0] = 0;\n\tspineKnots[1] = 1.0 / 3.0;\n\tspineKnots[2] = 2.0 / 3.0;\n\tspineKnots[3] = 1;\n\tspineMults.front() = 4;\n\tspineMults.back() = 4;\n\tstd::shared_ptr<Geom3BSplineCurve> spine = std::make_shared<Geom3BSplineCurve>(spinePoles, spineKnots, spineMults, 3);\n\tTopoShape pipe = MakePipe(MakeWire(MakeEdge(spine)), MakeWire(MakeEdge(profile))).Shape();\n\tTopoExplorer ex(pipe, ShapeType::Face);\n\tstd::shared_ptr<Geom3Surface> surface = TopoTool::Surface(static_cast<const TopoFace&>(ex.Current()));\n\treturn surface;\n}\nshared_ptr<Geom3Surface> ConstructExtendPeriodicSurf3()\n{\n\tstd::vector<Point3> profilePoles;\n\tprofilePoles.push_back(Point3(0.0, 0.0, 0.0));\n\tprofilePoles.push_back(Point3(1.0, -1.0, 0.0));\n\tprofilePoles.push_back(Point3(2.0, -1.5, 0.0));\n\tprofilePoles.push_back(Point3(2.3, -1.0, 0.0));\n\tprofilePoles.push_back(Point3(2.9, 0.0, 0.0));\n\tprofilePoles.push_back(Point3(2.3, 0.9, 0.0));\n\tprofilePoles.push_back(Point3(2.1, 1.6, 0.0));\n\tprofilePoles.push_back(Point3(1.0, 1.0, 0.0));\n\tstd::vector<double> profileKnots(profilePoles.size() + 1);\n\tfor (int i = 0; i < static_cast<int>(profileKnots.size()); i++)\n\t{\n\t\tprofileKnots[i] = (double)i / (double)(profilePoles.size());\n\t}\n\tprofileKnots[1] += 1.0 / (double)(3 * profilePoles.size());\n\tstd::vector<int> profileMults(profileKnots.size(), 1);\n\tstd::shared_ptr<Geom3BSplineCurve> profile = std::make_shared<Geom3BSplineCurve>(profilePoles, profileKnots, profileMults, 3, true);\n\tstd::vector<Point3> spinePoles;\n\tstd::vector<double> spineKnots(4);\n\tstd::vector<int> spineMults(4, 1);\n\tspinePoles.push_back(Point3(0.0, 0.0, 0.0));\n\tspinePoles.push_back(Point3(0.0, 0.0, 1.0));\n\tspinePoles.push_back(Point3(0.0, 0.2, 1.5));\n\tspinePoles.push_back(Point3(0.0, 0.5, 2.0));\n\tspinePoles.push_back(Point3(0.0, 1.0, 2.3));\n\tspinePoles.push_back(Point3(0.0, 1.6, 2.3));\n\tspineKnots[0] = 0;\n\tspineKnots[1] = 1.0 / 3.0;\n\tspineKnots[2] = 2.0 / 3.0;\n\tspineKnots[3] = 1;\n\tspineMults.front() = 4;\n\tspineMults.back() = 4;\n\tstd::shared_ptr<Geom3BSplineCurve> spine = std::make_shared<Geom3BSplineCurve>(spinePoles, spineKnots, spineMults, 3);\n\tTopoShape pipe = MakePipe(MakeWire(MakeEdge(spine)), MakeWire(MakeEdge(profile))).Shape();\n\tTopoExplorer ex(pipe, ShapeType::Face);\n\tstd::shared_ptr<Geom3Surface> surface = TopoTool::Surface(static_cast<const TopoFace&>(ex.Current()));\n\treturn surface;\n}\n﻿#include<catch.hpp>\n#include<testHelper.h>\n#include <nurbs/NURBSAPIExtend.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <modeling/MakeFace.hpp>\n#include <topology/BRepExtremaDistShapeShape.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/Geom3Plane.hpp>\n#include <geometry/Geom3TrimmedSurface.hpp>\n#include <nurbs/NURBSAPIConvert.hpp>\n#include <nurbs/NURBSAPIBuildCurve.hpp>\n#include <geomAlgo/LawBSpline.hpp>\n#include <offset/MakePipe.hpp>\n#include <modeling/MakeWire.hpp>\n#include <topology/TopoTool.hpp>\n#include <topology/TopoExplorerTool.hpp>\n#include <geometry/GeomAPIProjectPointOnCurve3.hpp>\n#include <geometry/GeomAPIProjectPointOnSurface.hpp>\ndouble NurbsExtendSample3(int num, double len, double tol, const shared_ptr<Geom3Curve>& curve1, const shared_ptr<Geom3Curve>& curve2)\n{\n\tconst int nsample = num;\n\tdouble fp1 = curve1->FirstParameter();\n\tdouble lp1 = curve1->LastParameter();\n\tdouble delta1 = (lp1 - fp1) / nsample;\n\tPoint3 p;\n\tint n = 0;\n\tfor (int i = 0; i < nsample; i++)\n\t{\n\t\tdouble t1 = fp1 + i * delta1;\n\t\tcurve1->D0(t1, p);\n\t\tTopoVertex vt = MakeVertex(p);\n\t\tTopoEdge edge = MakeEdge(curve2);\n\t\tBRepExtremaDistShapeShape dist(vt, edge);\n\t\tdouble dis = abs(dist.Value() - len);\n\t\tif (dis <= tol)\n\t\t{\n\t\t\tn++;\n\t\t}\n\t}\n\tdouble res = 1.0 * (num - n) / num;\n\treturn res;\n}\nshared_ptr<Geom3Surface> ConstructExtendSurface3()\n{\n\tstd::vector<Point3> profilePoles;\n\tstd::vector<double> profileKnots(3);\n\tstd::vector<int> profileMults(3, 1);\n\tprofilePoles.push_back(Point3(0.0, 0.0, 0.0));\n\tprofilePoles.push_back(Point3(1.0, -0.2, 0.0));\n\tprofilePoles.push_back(Point3(2.0, 0.1, 0.0));\n\tprofilePoles.push_back(Point3(2.3, -0.1, 0.0));\n\tprofilePoles.push_back(Point3(2.9, 0.1, 0.0));\n\tprofileKnots[0] = 0;\n\tprofileKnots[1] = 0.5;\n\tprofileKnots[2] = 1;\n\tprofileMults.front() = 4;\n\tprofileMults.back() = 4;\n\tstd::shared_ptr<Geom3BSplineCurve> profile = std::make_shared<Geom3BSplineCurve>(profilePoles, profileKnots, profileMults, 3);\n\tstd::vector<Point3> spinePoles;\n\tstd::vector<double> spineKnots(4);\n\tstd::vector<int> spineMults(4, 1);\n\tspinePoles.push_back(Point3(0.0, 0.0, 0.0));\n\tspinePoles.push_back(Point3(0.0, 0.0, 1.0));\n\tspinePoles.push_back(Point3(0.0, 0.2, 1.5));\n\tspinePoles.push_back(Point3(0.0, 0.5, 2.0));\n\tspinePoles.push_back(Point3(0.0, 1.0, 2.3));\n\tspinePoles.push_back(Point3(0.0, 1.6, 2.3));\n\tspineKnots[0] = 0;\n\tspineKnots[1] = 1.0 / 3.0;\n\tspineKnots[2] = 2.0 / 3.0;\n\tspineKnots[3] = 1;\n\tspineMults.front() = 4;\n\tspineMults.back() = 4;\n\tstd::shared_ptr<Geom3BSplineCurve> spine = std::make_shared<Geom3BSplineCurve>(spinePoles, spineKnots, spineMults, 3);\n\tTopoShape pipe = MakePipe(MakeWire(MakeEdge(spine)), MakeWire(MakeEdge(profile))).Shape();\n\tTopoExplorer ex(pipe, ShapeType::Face);\n\tstd::shared_ptr<Geom3Surface> surface = TopoTool::Surface(static_cast<const TopoFace&>(ex.Current()));\n\treturn surface;\n}\nshared_ptr<Geom3Surface> ConstructExtendPeriodicSurf3()\n{\n\tstd::vector<Point3> profilePoles;\n\tprofilePoles.push_back(Point3(0.0, 0.0, 0.0));\n\tprofilePoles.push_back(Point3(1.0, -1.0, 0.0));\n\tprofilePoles.push_back(Point3(2.0, -1.5, 0.0));\n\tprofilePoles.push_back(Point3(2.3, -1.0, 0.0));\n\tprofilePoles.push_back(Point3(2.9, 0.0, 0.0));\n\tprofilePoles.push_back(Point3(2.3, 0.9, 0.0));\n\tprofilePoles.push_back(Point3(2.1, 1.6, 0.0));\n\tprofilePoles.push_back(Point3(1.0, 1.0, 0.0));\n\tstd::vector<double> profileKnots(profilePoles.size() + 1);\n\tfor (int i = 0; i < static_cast<int>(profileKnots.size()); i++)\n\t{\n\t\tprofileKnots[i] = (double)i / (double)(profilePoles.size());\n\t}\n\tprofileKnots[1] += 1.0 / (double)(3 * profilePoles.size());\n\tstd::vector<int> profileMults(profileKnots.size(), 1);\n\tstd::shared_ptr<Geom3BSplineCurve> profile = std::make_shared<Geom3BSplineCurve>(profilePoles, profileKnots, profileMults, 3, true);\n\tstd::vector<Point3> spinePoles;\n\tstd::vector<double> spineKnots(4);\n\tstd::vector<int> spineMults(4, 1);\n\tspinePoles.push_back(Point3(0.0, 0.0, 0.0));\n\tspinePoles.push_back(Point3(0.0, 0.0, 1.0));\n\tspinePoles.push_back(Point3(0.0, 0.2, 1.5));\n\tspinePoles.push_back(Point3(0.0, 0.5, 2.0));\n\tspinePoles.push_back(Point3(0.0, 1.0, 2.3));\n\tspinePoles.push_back(Point3(0.0, 1.6, 2.3));\n\tspineKnots[0] = 0;\n\tspineKnots[1] = 1.0 / 3.0;\n\tspineKnots[2] = 2.0 / 3.0;\n\tspineKnots[3] = 1;\n\tspineMults.front() = 4;\n\tspineMults.back() = 4;\n\tstd::shared_ptr<Geom3BSplineCurve> spine = std::make_shared<Geom3BSplineCurve>(spinePoles, spineKnots, spineMults, 3);\n\tTopoShape pipe = MakePipe(MakeWire(MakeEdge(spine)), MakeWire(MakeEdge(profile))).Shape();\n\tTopoExplorer ex(pipe, ShapeType::Face);\n\tstd::shared_ptr<Geom3Surface> surface = TopoTool::Surface(static_cast<const TopoFace&>(ex.Current()));\n\treturn surface;\n;\n\tSECTION(\"ExtendPeriodicSurf2\")\n\t{\n\t\tOUTPUT_DIRECTORY(nurbs, Extend/IncreaseDegree/ExtendSurf/ExtendPeriodicSurf2);\n\t\tPoint3 p(1.0, -0.2, -0.2);\n\t\tauto srcSurf = NURBSAPIExtend::ExtendSurfToPoint(surface, false, true, p);\n\t\tauto pointvf = NURBSAPIExtend::ExtendSurfToPoint(surfaceInc, false, true, p);\n\t\tshared_ptr<Geom3BSplineSurface> bspSurf2 = NURBSAPIConvert::ToBSpline(pointvf);\n\t\tCHECK(bspSurf2->UDegree() == refDeg);\n\t\tCHECK(bspSurf2->VDegree() == refDeg);\n\t\tCHECK(bspSurf2->NUKnots() == ukNum);\n\t\tCHECK(bspSurf2->NVKnots() == vkNum);\n\t\tGeomAPIProjectPointOnSurface proj(p, pointvf);\n\t\tPoint3 pp = proj.NearestPoint();\n\t\tdouble fpv2 = pointvf->FirstVParameter();\n\t\tshared_ptr<Geom3Curve> fv2 = pointvf->VIso(fpv2);\n\t\tTopoEdge edge2 = MakeEdge(fv2);\n\t\tbool res1 = BRepClassificationTools::IsPointInOnEdge(edge2, pp, 1e-3);\n\t\tCHECK(res1 == true);  \n\t\tdouble fppu1 = srcSurf->FirstUParameter();\n\t\tdouble fppv1 = srcSurf->FirstVParameter();\n\t\tdouble lppu1 = srcSurf->LastUParameter();\n\t\tdouble lppv1 = srcSurf->LastVParameter();\n\t\tshared_ptr<Geom3Curve> fuu1 = srcSurf->UIso(fppu1);\n\t\tshared_ptr<Geom3Curve> fvv1 = srcSurf->VIso(fppv1);\n\t\tshared_ptr<Geom3Curve> luu1 = srcSurf->UIso(lppu1);\n\t\tshared_ptr<Geom3Curve> lvv1 = srcSurf->VIso(lppv1);\n\t\tdouble fppu2 = pointvf->FirstUParameter();\n\t\tdouble fppv2 = pointvf->FirstVParameter();\n\t\tdouble lppu2 = pointvf->LastUParameter();\n\t\tdouble lppv2 = pointvf->LastVParameter();\n\t\tshared_ptr<Geom3Curve> fuu2 = pointvf->UIso(fppu2);\n\t\tshared_ptr<Geom3Curve> fvv2 = pointvf->VIso(fppv2);\n\t\tshared_ptr<Geom3Curve> luu2 = pointvf->UIso(lppu2);\n\t\tshared_ptr<Geom3Curve> lvv2 = pointvf->VIso(lppv2);\n\t\tdouble res3 = NurbsSampleCurve(num, refTol, fuu1, fuu2);\n\t\tdouble res4 = NurbsSampleCurve(num, refTol, fvv1, fvv2);\n\t\tdouble res5 = NurbsSampleCurve(num, refTol, luu1, luu2);\n\t\tdouble res6 = NurbsSampleCurve(num, refTol, lvv1, lvv2);\n\t\tCHECK(res3 <= ratio);\n\t\tCHECK(res4 <= ratio);\n\t\tCHECK(res5 <= ratio);\n\t\tCHECK(res6 <= ratio);\n\t\tTopoFace face = MakeFace(srcSurf, 0.0);\n\t\tTopoFace faceInc = MakeFace(pointvf, 0.0);\n\t\tGlobalProperty props1, props2;\n\t\tdouble s1 = GetSurfaceProperties(face, props1, true, false);\n\t\tdouble s2 = GetSurfaceProperties(faceInc, props2, true, false);\n\t\tCHECK(abs(s1 - s2) <= refTol);\n\t\tOCCTIO::OCCTTool::Write(MakeVertex(p), outdir + \"refp.brep\");\n\t\tOCCTIO::OCCTTool::Write(MakeEdge(fv), outdir + \"curve1.brep\");\n\t\tOCCTIO::OCCTTool::Write(MakeEdge(fv2), outdir + \"curve2.brep\");\n\t\tOCCTIO::OCCTTool::Write(MakeFace(surface, 0.0), outdir + \"src.brep\");\n\t\tOCCTIO::OCCTTool::Write(MakeFace(surfaceInc, 0.0), outdir + \"srcInc.brep\");\n\t\tOCCTIO::OCCTTool::Write(MakeFace(pointvf, 0.0), outdir + \"result.brep\");\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static std::shared_ptr<Geom3Surface> ExtendSurfPerpendicularToPlane(const std::shared_ptr<Geom3Surface>& surf, bool isExtendU, bool isFront, const std::shared_ptr<Geom3Plane>& plane)\t @return New surface\n\t @param plane Plane\n\t @param isFront Extend front or back\n\t @param isExtendU Extend u or v\n\t @param surf Surf\n\t The degree of surface is not changed but the size of the extended direction (u or v) knots and poles increase 1.\n\t The original surface is part of new surface.\n\t @brief Extend surface to plane and the end of surface is always perpendicular to the plane, which can be used in mirror to fix the gap.\n,\n",
      "output": "﻿#include<catch.hpp>\n#include<testHelper.h>\n#include <nurbs/NURBSAPIExtend.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <modeling/MakeFace.hpp>\n#include <topology/BRepExtremaDistShapeShape.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/Geom3Plane.hpp>\n#include <geometry/Geom3TrimmedSurface.hpp>\n#include <nurbs/NURBSAPIConvert.hpp>\n#include <nurbs/NURBSAPIBuildCurve.hpp>\n#include <geomAlgo/LawBSpline.hpp>\n#include <offset/MakePipe.hpp>\n#include <modeling/MakeWire.hpp>\n#include <topology/TopoTool.hpp>\n#include <topology/TopoExplorerTool.hpp>\n#include <geometry/GeomAPIProjectPointOnCurve3.hpp>\n#include <geometry/GeomAPIProjectPointOnSurface.hpp>\ndouble NurbsExtendSample3(int num, double len, double tol, const shared_ptr<Geom3Curve>& curve1, const shared_ptr<Geom3Curve>& curve2)\n{\n\tconst int nsample = num;\n\tdouble fp1 = curve1->FirstParameter();\n\tdouble lp1 = curve1->LastParameter();\n\tdouble delta1 = (lp1 - fp1) / nsample;\n\tPoint3 p;\n\tint n = 0;\n\tfor (int i = 0; i < nsample; i++)\n\t{\n\t\tdouble t1 = fp1 + i * delta1;\n\t\tcurve1->D0(t1, p);\n\t\tTopoVertex vt = MakeVertex(p);\n\t\tTopoEdge edge = MakeEdge(curve2);\n\t\tBRepExtremaDistShapeShape dist(vt, edge);\n\t\tdouble dis = abs(dist.Value() - len);\n\t\tif (dis <= tol)\n\t\t{\n\t\t\tn++;\n\t\t}\n\t}\n\tdouble res = 1.0 * (num - n) / num;\n\treturn res;\n}\nshared_ptr<Geom3Surface> ConstructExtendSurface3()\n{\n\tstd::vector<Point3> profilePoles;\n\tstd::vector<double> profileKnots(3);\n\tstd::vector<int> profileMults(3, 1);\n\tprofilePoles.push_back(Point3(0.0, 0.0, 0.0));\n\tprofilePoles.push_back(Point3(1.0, -0.2, 0.0));\n\tprofilePoles.push_back(Point3(2.0, 0.1, 0.0));\n\tprofilePoles.push_back(Point3(2.3, -0.1, 0.0));\n\tprofilePoles.push_back(Point3(2.9, 0.1, 0.0));\n\tprofileKnots[0] = 0;\n\tprofileKnots[1] = 0.5;\n\tprofileKnots[2] = 1;\n\tprofileMults.front() = 4;\n\tprofileMults.back() = 4;\n\tstd::shared_ptr<Geom3BSplineCurve> profile = std::make_shared<Geom3BSplineCurve>(profilePoles, profileKnots, profileMults, 3);\n\tstd::vector<Point3> spinePoles;\n\tstd::vector<double> spineKnots(4);\n\tstd::vector<int> spineMults(4, 1);\n\tspinePoles.push_back(Point3(0.0, 0.0, 0.0));\n\tspinePoles.push_back(Point3(0.0, 0.0, 1.0));\n\tspinePoles.push_back(Point3(0.0, 0.2, 1.5));\n\tspinePoles.push_back(Point3(0.0, 0.5, 2.0));\n\tspinePoles.push_back(Point3(0.0, 1.0, 2.3));\n\tspinePoles.push_back(Point3(0.0, 1.6, 2.3));\n\tspineKnots[0] = 0;\n\tspineKnots[1] = 1.0 / 3.0;\n\tspineKnots[2] = 2.0 / 3.0;\n\tspineKnots[3] = 1;\n\tspineMults.front() = 4;\n\tspineMults.back() = 4;\n\tstd::shared_ptr<Geom3BSplineCurve> spine = std::make_shared<Geom3BSplineCurve>(spinePoles, spineKnots, spineMults, 3);\n\tTopoShape pipe = MakePipe(MakeWire(MakeEdge(spine)), MakeWire(MakeEdge(profile))).Shape();\n\tTopoExplorer ex(pipe, ShapeType::Face);\n\tstd::shared_ptr<Geom3Surface> surface = TopoTool::Surface(static_cast<const TopoFace&>(ex.Current()));\n\treturn surface;\n}\nshared_ptr<Geom3Surface> ConstructExtendPeriodicSurf3()\n{\n\tstd::vector<Point3> profilePoles;\n\tprofilePoles.push_back(Point3(0.0, 0.0, 0.0));\n\tprofilePoles.push_back(Point3(1.0, -1.0, 0.0));\n\tprofilePoles.push_back(Point3(2.0, -1.5, 0.0));\n\tprofilePoles.push_back(Point3(2.3, -1.0, 0.0));\n\tprofilePoles.push_back(Point3(2.9, 0.0, 0.0));\n\tprofilePoles.push_back(Point3(2.3, 0.9, 0.0));\n\tprofilePoles.push_back(Point3(2.1, 1.6, 0.0));\n\tprofilePoles.push_back(Point3(1.0, 1.0, 0.0));\n\tstd::vector<double> profileKnots(profilePoles.size() + 1);\n\tfor (int i = 0; i < static_cast<int>(profileKnots.size()); i++)\n\t{\n\t\tprofileKnots[i] = (double)i / (double)(profilePoles.size());\n\t}\n\tprofileKnots[1] += 1.0 / (double)(3 * profilePoles.size());\n\tstd::vector<int> profileMults(profileKnots.size(), 1);\n\tstd::shared_ptr<Geom3BSplineCurve> profile = std::make_shared<Geom3BSplineCurve>(profilePoles, profileKnots, profileMults, 3, true);\n\tstd::vector<Point3> spinePoles;\n\tstd::vector<double> spineKnots(4);\n\tstd::vector<int> spineMults(4, 1);\n\tspinePoles.push_back(Point3(0.0, 0.0, 0.0));\n\tspinePoles.push_back(Point3(0.0, 0.0, 1.0));\n\tspinePoles.push_back(Point3(0.0, 0.2, 1.5));\n\tspinePoles.push_back(Point3(0.0, 0.5, 2.0));\n\tspinePoles.push_back(Point3(0.0, 1.0, 2.3));\n\tspinePoles.push_back(Point3(0.0, 1.6, 2.3));\n\tspineKnots[0] = 0;\n\tspineKnots[1] = 1.0 / 3.0;\n\tspineKnots[2] = 2.0 / 3.0;\n\tspineKnots[3] = 1;\n\tspineMults.front() = 4;\n\tspineMults.back() = 4;\n\tstd::shared_ptr<Geom3BSplineCurve> spine = std::make_shared<Geom3BSplineCurve>(spinePoles, spineKnots, spineMults, 3);\n\tTopoShape pipe = MakePipe(MakeWire(MakeEdge(spine)), MakeWire(MakeEdge(profile))).Shape();\n\tTopoExplorer ex(pipe, ShapeType::Face);\n\tstd::shared_ptr<Geom3Surface> surface = TopoTool::Surface(static_cast<const TopoFace&>(ex.Current()));\n\treturn surface;\n}\n﻿#include<catch.hpp>\n#include<testHelper.h>\n#include <nurbs/NURBSAPIExtend.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <modeling/MakeFace.hpp>\n#include <topology/BRepExtremaDistShapeShape.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/Geom3Plane.hpp>\n#include <geometry/Geom3TrimmedSurface.hpp>\n#include <nurbs/NURBSAPIConvert.hpp>\n#include <nurbs/NURBSAPIBuildCurve.hpp>\n#include <geomAlgo/LawBSpline.hpp>\n#include <offset/MakePipe.hpp>\n#include <modeling/MakeWire.hpp>\n#include <topology/TopoTool.hpp>\n#include <topology/TopoExplorerTool.hpp>\n#include <geometry/GeomAPIProjectPointOnCurve3.hpp>\n#include <geometry/GeomAPIProjectPointOnSurface.hpp>\ndouble NurbsExtendSample3(int num, double len, double tol, const shared_ptr<Geom3Curve>& curve1, const shared_ptr<Geom3Curve>& curve2)\n{\n\tconst int nsample = num;\n\tdouble fp1 = curve1->FirstParameter();\n\tdouble lp1 = curve1->LastParameter();\n\tdouble delta1 = (lp1 - fp1) / nsample;\n\tPoint3 p;\n\tint n = 0;\n\tfor (int i = 0; i < nsample; i++)\n\t{\n\t\tdouble t1 = fp1 + i * delta1;\n\t\tcurve1->D0(t1, p);\n\t\tTopoVertex vt = MakeVertex(p);\n\t\tTopoEdge edge = MakeEdge(curve2);\n\t\tBRepExtremaDistShapeShape dist(vt, edge);\n\t\tdouble dis = abs(dist.Value() - len);\n\t\tif (dis <= tol)\n\t\t{\n\t\t\tn++;\n\t\t}\n\t}\n\tdouble res = 1.0 * (num - n) / num;\n\treturn res;\n}\nshared_ptr<Geom3Surface> ConstructExtendSurface3()\n{\n\tstd::vector<Point3> profilePoles;\n\tstd::vector<double> profileKnots(3);\n\tstd::vector<int> profileMults(3, 1);\n\tprofilePoles.push_back(Point3(0.0, 0.0, 0.0));\n\tprofilePoles.push_back(Point3(1.0, -0.2, 0.0));\n\tprofilePoles.push_back(Point3(2.0, 0.1, 0.0));\n\tprofilePoles.push_back(Point3(2.3, -0.1, 0.0));\n\tprofilePoles.push_back(Point3(2.9, 0.1, 0.0));\n\tprofileKnots[0] = 0;\n\tprofileKnots[1] = 0.5;\n\tprofileKnots[2] = 1;\n\tprofileMults.front() = 4;\n\tprofileMults.back() = 4;\n\tstd::shared_ptr<Geom3BSplineCurve> profile = std::make_shared<Geom3BSplineCurve>(profilePoles, profileKnots, profileMults, 3);\n\tstd::vector<Point3> spinePoles;\n\tstd::vector<double> spineKnots(4);\n\tstd::vector<int> spineMults(4, 1);\n\tspinePoles.push_back(Point3(0.0, 0.0, 0.0));\n\tspinePoles.push_back(Point3(0.0, 0.0, 1.0));\n\tspinePoles.push_back(Point3(0.0, 0.2, 1.5));\n\tspinePoles.push_back(Point3(0.0, 0.5, 2.0));\n\tspinePoles.push_back(Point3(0.0, 1.0, 2.3));\n\tspinePoles.push_back(Point3(0.0, 1.6, 2.3));\n\tspineKnots[0] = 0;\n\tspineKnots[1] = 1.0 / 3.0;\n\tspineKnots[2] = 2.0 / 3.0;\n\tspineKnots[3] = 1;\n\tspineMults.front() = 4;\n\tspineMults.back() = 4;\n\tstd::shared_ptr<Geom3BSplineCurve> spine = std::make_shared<Geom3BSplineCurve>(spinePoles, spineKnots, spineMults, 3);\n\tTopoShape pipe = MakePipe(MakeWire(MakeEdge(spine)), MakeWire(MakeEdge(profile))).Shape();\n\tTopoExplorer ex(pipe, ShapeType::Face);\n\tstd::shared_ptr<Geom3Surface> surface = TopoTool::Surface(static_cast<const TopoFace&>(ex.Current()));\n\treturn surface;\n}\nshared_ptr<Geom3Surface> ConstructExtendPeriodicSurf3()\n{\n\tstd::vector<Point3> profilePoles;\n\tprofilePoles.push_back(Point3(0.0, 0.0, 0.0));\n\tprofilePoles.push_back(Point3(1.0, -1.0, 0.0));\n\tprofilePoles.push_back(Point3(2.0, -1.5, 0.0));\n\tprofilePoles.push_back(Point3(2.3, -1.0, 0.0));\n\tprofilePoles.push_back(Point3(2.9, 0.0, 0.0));\n\tprofilePoles.push_back(Point3(2.3, 0.9, 0.0));\n\tprofilePoles.push_back(Point3(2.1, 1.6, 0.0));\n\tprofilePoles.push_back(Point3(1.0, 1.0, 0.0));\n\tstd::vector<double> profileKnots(profilePoles.size() + 1);\n\tfor (int i = 0; i < static_cast<int>(profileKnots.size()); i++)\n\t{\n\t\tprofileKnots[i] = (double)i / (double)(profilePoles.size());\n\t}\n\tprofileKnots[1] += 1.0 / (double)(3 * profilePoles.size());\n\tstd::vector<int> profileMults(profileKnots.size(), 1);\n\tstd::shared_ptr<Geom3BSplineCurve> profile = std::make_shared<Geom3BSplineCurve>(profilePoles, profileKnots, profileMults, 3, true);\n\tstd::vector<Point3> spinePoles;\n\tstd::vector<double> spineKnots(4);\n\tstd::vector<int> spineMults(4, 1);\n\tspinePoles.push_back(Point3(0.0, 0.0, 0.0));\n\tspinePoles.push_back(Point3(0.0, 0.0, 1.0));\n\tspinePoles.push_back(Point3(0.0, 0.2, 1.5));\n\tspinePoles.push_back(Point3(0.0, 0.5, 2.0));\n\tspinePoles.push_back(Point3(0.0, 1.0, 2.3));\n\tspinePoles.push_back(Point3(0.0, 1.6, 2.3));\n\tspineKnots[0] = 0;\n\tspineKnots[1] = 1.0 / 3.0;\n\tspineKnots[2] = 2.0 / 3.0;\n\tspineKnots[3] = 1;\n\tspineMults.front() = 4;\n\tspineMults.back() = 4;\n\tstd::shared_ptr<Geom3BSplineCurve> spine = std::make_shared<Geom3BSplineCurve>(spinePoles, spineKnots, spineMults, 3);\n\tTopoShape pipe = MakePipe(MakeWire(MakeEdge(spine)), MakeWire(MakeEdge(profile))).Shape();\n\tTopoExplorer ex(pipe, ShapeType::Face);\n\tstd::shared_ptr<Geom3Surface> surface = TopoTool::Surface(static_cast<const TopoFace&>(ex.Current()));\n\treturn surface;\n;\n\tSECTION(\"ExtendSurfPerpendicularToPlane1\")\n\t{\n\t\tOUTPUT_DIRECTORY(nurbs, Extend/bug752/ExtendSurfPerpendicularToPlane1);\n\t\tshared_ptr<Geom3Plane> plane = make_shared<Geom3Plane>(Point3(-0.2, 0.0, 0.0), Direction3(1.0, 0.0, 0.0));\n\t\tauto srcSurf = NURBSAPIExtend::ExtendSurfPerpendicularToPlane(surface, true, true, plane);\n\t\tauto planeuf = NURBSAPIExtend::ExtendSurfPerpendicularToPlane(surfaceInc, true, true, plane);\n\t\tshared_ptr<Geom3TrimmedSurface>trimSurf = std::make_shared<Geom3TrimmedSurface>(plane, -2.0, 2.0, -2.0, 2.0);\n\t\tdouble fpv1 = planeuf->FirstVParameter();\n\t\tshared_ptr<Geom3Curve> fv1 = planeuf->VIso(fpv1);\n\t\tPoint3 p1;\n\t\tVector3 vec;\n\t\tdouble fs = fv1->FirstParameter();\n\t\tfv1->D1(fs, p1, vec);\n\t\tAxis3 axis = plane->Axis();\n\t\tbool res = axis.Direction().IsParallel(Direction3(vec), Precision::Angular());\n\t\tCHECK(res == true);\n\t\tdouble fpu1 = planeuf->FirstUParameter();\n\t\tshared_ptr<Geom3Curve> fu1 = planeuf->UIso(fpu1);\n\t\tbool res1 = IsCurveOnSurf(num, ratio, fu1, plane, -1.0);\n\t\tCHECK(res1 == true);\n\t\tdouble fppu1 = srcSurf->FirstUParameter();\n\t\tdouble fppv1 = srcSurf->FirstVParameter();\n\t\tdouble lppu1 = srcSurf->LastUParameter();\n\t\tdouble lppv1 = srcSurf->LastVParameter();\n\t\tshared_ptr<Geom3Curve> fuu1 = srcSurf->UIso(fppu1);\n\t\tshared_ptr<Geom3Curve> fvv1 = srcSurf->VIso(fppv1);\n\t\tshared_ptr<Geom3Curve> luu1 = srcSurf->UIso(lppu1);\n\t\tshared_ptr<Geom3Curve> lvv1 = srcSurf->VIso(lppv1);\n\t\tdouble fppu2 = planeuf->FirstUParameter();\n\t\tdouble fppv2 = planeuf->FirstVParameter();\n\t\tdouble lppu2 = planeuf->LastUParameter();\n\t\tdouble lppv2 = planeuf->LastVParameter();\n\t\tshared_ptr<Geom3Curve> fuu2 = planeuf->UIso(fppu2);\n\t\tshared_ptr<Geom3Curve> fvv2 = planeuf->VIso(fppv2);\n\t\tshared_ptr<Geom3Curve> luu2 = planeuf->UIso(lppu2);\n\t\tshared_ptr<Geom3Curve> lvv2 = planeuf->VIso(lppv2);\n\t\tdouble res3 = NurbsSampleCurve(num, refTol, fuu1, fuu2);\n\t\tdouble res4 = NurbsSampleCurve(num, refTol, fvv1, fvv2);\n\t\tdouble res5 = NurbsSampleCurve(num, refTol, luu1, luu2);\n\t\tdouble res6 = NurbsSampleCurve(num, refTol, lvv1, lvv2);\n\t\tCHECK(res3 <= ratio);\n\t\tCHECK(res4 <= ratio);\n\t\tCHECK(res5 <= ratio);\n\t\tCHECK(res6 <= ratio);\n\t\tOCCTIO::OCCTTool::Write(MakeEdge(fu), outdir + \"curve1.brep\");\n\t\tOCCTIO::OCCTTool::Write(MakeEdge(fu1), outdir + \"curve2.brep\");\n\t\tOCCTIO::OCCTTool::Write(MakeFace(trimSurf, 0.0), outdir + \"trimSurf.brep\");\n\t\tOCCTIO::OCCTTool::Write(MakeFace(surface, 0.0), outdir + \"src.brep\");\n\t\tOCCTIO::OCCTTool::Write(MakeFace(surfaceInc, 0.0), outdir + \"srcInc.brep\");\n\t\tOCCTIO::OCCTTool::Write(MakeFace(srcSurf, 0.0), outdir + \"oldresult.brep\");\n\t\tOCCTIO::OCCTTool::Write(MakeFace(planeuf, 0.0), outdir + \"result.brep\");\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static std::shared_ptr<Geom3Surface> ExtendSurfPerpendicularToPlane(const std::shared_ptr<Geom3Surface>& surf, const std::shared_ptr<Geom3Plane>& plane)\t @return New surface\n\t @param plane Plane\n\t @param surf Surf\n\t The degree of surface is not changed but the size of the extended direction (u or v) knots and poles increase 1.\n\t The original surface is part of new surface.\n\t @brief Extend surface to plane and the surface end which is closer to plane is always perpendicular to the plane, which can be used in mirror to fix the gap.\n,\n",
      "output": "﻿#include<catch.hpp>\n#include<testHelper.h>\n#include <nurbs/NURBSAPIExtend.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <modeling/MakeFace.hpp>\n#include <topology/BRepExtremaDistShapeShape.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/Geom3Plane.hpp>\n#include <geometry/Geom3TrimmedSurface.hpp>\n#include <nurbs/NURBSAPIConvert.hpp>\n#include <nurbs/NURBSAPIBuildCurve.hpp>\n#include <geomAlgo/LawBSpline.hpp>\n#include <offset/MakePipe.hpp>\n#include <modeling/MakeWire.hpp>\n#include <topology/TopoTool.hpp>\n#include <topology/TopoExplorerTool.hpp>\n#include <geometry/GeomAPIProjectPointOnCurve3.hpp>\n#include <geometry/GeomAPIProjectPointOnSurface.hpp>\ndouble NurbsExtendSample3(int num, double len, double tol, const shared_ptr<Geom3Curve>& curve1, const shared_ptr<Geom3Curve>& curve2)\n{\n\tconst int nsample = num;\n\tdouble fp1 = curve1->FirstParameter();\n\tdouble lp1 = curve1->LastParameter();\n\tdouble delta1 = (lp1 - fp1) / nsample;\n\tPoint3 p;\n\tint n = 0;\n\tfor (int i = 0; i < nsample; i++)\n\t{\n\t\tdouble t1 = fp1 + i * delta1;\n\t\tcurve1->D0(t1, p);\n\t\tTopoVertex vt = MakeVertex(p);\n\t\tTopoEdge edge = MakeEdge(curve2);\n\t\tBRepExtremaDistShapeShape dist(vt, edge);\n\t\tdouble dis = abs(dist.Value() - len);\n\t\tif (dis <= tol)\n\t\t{\n\t\t\tn++;\n\t\t}\n\t}\n\tdouble res = 1.0 * (num - n) / num;\n\treturn res;\n}\nshared_ptr<Geom3Surface> ConstructExtendSurface3()\n{\n\tstd::vector<Point3> profilePoles;\n\tstd::vector<double> profileKnots(3);\n\tstd::vector<int> profileMults(3, 1);\n\tprofilePoles.push_back(Point3(0.0, 0.0, 0.0));\n\tprofilePoles.push_back(Point3(1.0, -0.2, 0.0));\n\tprofilePoles.push_back(Point3(2.0, 0.1, 0.0));\n\tprofilePoles.push_back(Point3(2.3, -0.1, 0.0));\n\tprofilePoles.push_back(Point3(2.9, 0.1, 0.0));\n\tprofileKnots[0] = 0;\n\tprofileKnots[1] = 0.5;\n\tprofileKnots[2] = 1;\n\tprofileMults.front() = 4;\n\tprofileMults.back() = 4;\n\tstd::shared_ptr<Geom3BSplineCurve> profile = std::make_shared<Geom3BSplineCurve>(profilePoles, profileKnots, profileMults, 3);\n\tstd::vector<Point3> spinePoles;\n\tstd::vector<double> spineKnots(4);\n\tstd::vector<int> spineMults(4, 1);\n\tspinePoles.push_back(Point3(0.0, 0.0, 0.0));\n\tspinePoles.push_back(Point3(0.0, 0.0, 1.0));\n\tspinePoles.push_back(Point3(0.0, 0.2, 1.5));\n\tspinePoles.push_back(Point3(0.0, 0.5, 2.0));\n\tspinePoles.push_back(Point3(0.0, 1.0, 2.3));\n\tspinePoles.push_back(Point3(0.0, 1.6, 2.3));\n\tspineKnots[0] = 0;\n\tspineKnots[1] = 1.0 / 3.0;\n\tspineKnots[2] = 2.0 / 3.0;\n\tspineKnots[3] = 1;\n\tspineMults.front() = 4;\n\tspineMults.back() = 4;\n\tstd::shared_ptr<Geom3BSplineCurve> spine = std::make_shared<Geom3BSplineCurve>(spinePoles, spineKnots, spineMults, 3);\n\tTopoShape pipe = MakePipe(MakeWire(MakeEdge(spine)), MakeWire(MakeEdge(profile))).Shape();\n\tTopoExplorer ex(pipe, ShapeType::Face);\n\tstd::shared_ptr<Geom3Surface> surface = TopoTool::Surface(static_cast<const TopoFace&>(ex.Current()));\n\treturn surface;\n}\nshared_ptr<Geom3Surface> ConstructExtendPeriodicSurf3()\n{\n\tstd::vector<Point3> profilePoles;\n\tprofilePoles.push_back(Point3(0.0, 0.0, 0.0));\n\tprofilePoles.push_back(Point3(1.0, -1.0, 0.0));\n\tprofilePoles.push_back(Point3(2.0, -1.5, 0.0));\n\tprofilePoles.push_back(Point3(2.3, -1.0, 0.0));\n\tprofilePoles.push_back(Point3(2.9, 0.0, 0.0));\n\tprofilePoles.push_back(Point3(2.3, 0.9, 0.0));\n\tprofilePoles.push_back(Point3(2.1, 1.6, 0.0));\n\tprofilePoles.push_back(Point3(1.0, 1.0, 0.0));\n\tstd::vector<double> profileKnots(profilePoles.size() + 1);\n\tfor (int i = 0; i < static_cast<int>(profileKnots.size()); i++)\n\t{\n\t\tprofileKnots[i] = (double)i / (double)(profilePoles.size());\n\t}\n\tprofileKnots[1] += 1.0 / (double)(3 * profilePoles.size());\n\tstd::vector<int> profileMults(profileKnots.size(), 1);\n\tstd::shared_ptr<Geom3BSplineCurve> profile = std::make_shared<Geom3BSplineCurve>(profilePoles, profileKnots, profileMults, 3, true);\n\tstd::vector<Point3> spinePoles;\n\tstd::vector<double> spineKnots(4);\n\tstd::vector<int> spineMults(4, 1);\n\tspinePoles.push_back(Point3(0.0, 0.0, 0.0));\n\tspinePoles.push_back(Point3(0.0, 0.0, 1.0));\n\tspinePoles.push_back(Point3(0.0, 0.2, 1.5));\n\tspinePoles.push_back(Point3(0.0, 0.5, 2.0));\n\tspinePoles.push_back(Point3(0.0, 1.0, 2.3));\n\tspinePoles.push_back(Point3(0.0, 1.6, 2.3));\n\tspineKnots[0] = 0;\n\tspineKnots[1] = 1.0 / 3.0;\n\tspineKnots[2] = 2.0 / 3.0;\n\tspineKnots[3] = 1;\n\tspineMults.front() = 4;\n\tspineMults.back() = 4;\n\tstd::shared_ptr<Geom3BSplineCurve> spine = std::make_shared<Geom3BSplineCurve>(spinePoles, spineKnots, spineMults, 3);\n\tTopoShape pipe = MakePipe(MakeWire(MakeEdge(spine)), MakeWire(MakeEdge(profile))).Shape();\n\tTopoExplorer ex(pipe, ShapeType::Face);\n\tstd::shared_ptr<Geom3Surface> surface = TopoTool::Surface(static_cast<const TopoFace&>(ex.Current()));\n\treturn surface;\n}\n﻿#include<catch.hpp>\n#include<testHelper.h>\n#include <nurbs/NURBSAPIExtend.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <modeling/MakeFace.hpp>\n#include <topology/BRepExtremaDistShapeShape.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/Geom3Plane.hpp>\n#include <geometry/Geom3TrimmedSurface.hpp>\n#include <nurbs/NURBSAPIConvert.hpp>\n#include <nurbs/NURBSAPIBuildCurve.hpp>\n#include <geomAlgo/LawBSpline.hpp>\n#include <offset/MakePipe.hpp>\n#include <modeling/MakeWire.hpp>\n#include <topology/TopoTool.hpp>\n#include <topology/TopoExplorerTool.hpp>\n#include <geometry/GeomAPIProjectPointOnCurve3.hpp>\n#include <geometry/GeomAPIProjectPointOnSurface.hpp>\ndouble NurbsExtendSample3(int num, double len, double tol, const shared_ptr<Geom3Curve>& curve1, const shared_ptr<Geom3Curve>& curve2)\n{\n\tconst int nsample = num;\n\tdouble fp1 = curve1->FirstParameter();\n\tdouble lp1 = curve1->LastParameter();\n\tdouble delta1 = (lp1 - fp1) / nsample;\n\tPoint3 p;\n\tint n = 0;\n\tfor (int i = 0; i < nsample; i++)\n\t{\n\t\tdouble t1 = fp1 + i * delta1;\n\t\tcurve1->D0(t1, p);\n\t\tTopoVertex vt = MakeVertex(p);\n\t\tTopoEdge edge = MakeEdge(curve2);\n\t\tBRepExtremaDistShapeShape dist(vt, edge);\n\t\tdouble dis = abs(dist.Value() - len);\n\t\tif (dis <= tol)\n\t\t{\n\t\t\tn++;\n\t\t}\n\t}\n\tdouble res = 1.0 * (num - n) / num;\n\treturn res;\n}\nshared_ptr<Geom3Surface> ConstructExtendSurface3()\n{\n\tstd::vector<Point3> profilePoles;\n\tstd::vector<double> profileKnots(3);\n\tstd::vector<int> profileMults(3, 1);\n\tprofilePoles.push_back(Point3(0.0, 0.0, 0.0));\n\tprofilePoles.push_back(Point3(1.0, -0.2, 0.0));\n\tprofilePoles.push_back(Point3(2.0, 0.1, 0.0));\n\tprofilePoles.push_back(Point3(2.3, -0.1, 0.0));\n\tprofilePoles.push_back(Point3(2.9, 0.1, 0.0));\n\tprofileKnots[0] = 0;\n\tprofileKnots[1] = 0.5;\n\tprofileKnots[2] = 1;\n\tprofileMults.front() = 4;\n\tprofileMults.back() = 4;\n\tstd::shared_ptr<Geom3BSplineCurve> profile = std::make_shared<Geom3BSplineCurve>(profilePoles, profileKnots, profileMults, 3);\n\tstd::vector<Point3> spinePoles;\n\tstd::vector<double> spineKnots(4);\n\tstd::vector<int> spineMults(4, 1);\n\tspinePoles.push_back(Point3(0.0, 0.0, 0.0));\n\tspinePoles.push_back(Point3(0.0, 0.0, 1.0));\n\tspinePoles.push_back(Point3(0.0, 0.2, 1.5));\n\tspinePoles.push_back(Point3(0.0, 0.5, 2.0));\n\tspinePoles.push_back(Point3(0.0, 1.0, 2.3));\n\tspinePoles.push_back(Point3(0.0, 1.6, 2.3));\n\tspineKnots[0] = 0;\n\tspineKnots[1] = 1.0 / 3.0;\n\tspineKnots[2] = 2.0 / 3.0;\n\tspineKnots[3] = 1;\n\tspineMults.front() = 4;\n\tspineMults.back() = 4;\n\tstd::shared_ptr<Geom3BSplineCurve> spine = std::make_shared<Geom3BSplineCurve>(spinePoles, spineKnots, spineMults, 3);\n\tTopoShape pipe = MakePipe(MakeWire(MakeEdge(spine)), MakeWire(MakeEdge(profile))).Shape();\n\tTopoExplorer ex(pipe, ShapeType::Face);\n\tstd::shared_ptr<Geom3Surface> surface = TopoTool::Surface(static_cast<const TopoFace&>(ex.Current()));\n\treturn surface;\n}\nshared_ptr<Geom3Surface> ConstructExtendPeriodicSurf3()\n{\n\tstd::vector<Point3> profilePoles;\n\tprofilePoles.push_back(Point3(0.0, 0.0, 0.0));\n\tprofilePoles.push_back(Point3(1.0, -1.0, 0.0));\n\tprofilePoles.push_back(Point3(2.0, -1.5, 0.0));\n\tprofilePoles.push_back(Point3(2.3, -1.0, 0.0));\n\tprofilePoles.push_back(Point3(2.9, 0.0, 0.0));\n\tprofilePoles.push_back(Point3(2.3, 0.9, 0.0));\n\tprofilePoles.push_back(Point3(2.1, 1.6, 0.0));\n\tprofilePoles.push_back(Point3(1.0, 1.0, 0.0));\n\tstd::vector<double> profileKnots(profilePoles.size() + 1);\n\tfor (int i = 0; i < static_cast<int>(profileKnots.size()); i++)\n\t{\n\t\tprofileKnots[i] = (double)i / (double)(profilePoles.size());\n\t}\n\tprofileKnots[1] += 1.0 / (double)(3 * profilePoles.size());\n\tstd::vector<int> profileMults(profileKnots.size(), 1);\n\tstd::shared_ptr<Geom3BSplineCurve> profile = std::make_shared<Geom3BSplineCurve>(profilePoles, profileKnots, profileMults, 3, true);\n\tstd::vector<Point3> spinePoles;\n\tstd::vector<double> spineKnots(4);\n\tstd::vector<int> spineMults(4, 1);\n\tspinePoles.push_back(Point3(0.0, 0.0, 0.0));\n\tspinePoles.push_back(Point3(0.0, 0.0, 1.0));\n\tspinePoles.push_back(Point3(0.0, 0.2, 1.5));\n\tspinePoles.push_back(Point3(0.0, 0.5, 2.0));\n\tspinePoles.push_back(Point3(0.0, 1.0, 2.3));\n\tspinePoles.push_back(Point3(0.0, 1.6, 2.3));\n\tspineKnots[0] = 0;\n\tspineKnots[1] = 1.0 / 3.0;\n\tspineKnots[2] = 2.0 / 3.0;\n\tspineKnots[3] = 1;\n\tspineMults.front() = 4;\n\tspineMults.back() = 4;\n\tstd::shared_ptr<Geom3BSplineCurve> spine = std::make_shared<Geom3BSplineCurve>(spinePoles, spineKnots, spineMults, 3);\n\tTopoShape pipe = MakePipe(MakeWire(MakeEdge(spine)), MakeWire(MakeEdge(profile))).Shape();\n\tTopoExplorer ex(pipe, ShapeType::Face);\n\tstd::shared_ptr<Geom3Surface> surface = TopoTool::Surface(static_cast<const TopoFace&>(ex.Current()));\n\treturn surface;\n;\n\tSECTION(\"ExtendSurfPerpendicularToPlane4\")\n\t{\n\t\tOUTPUT_DIRECTORY(nurbs, Extend/ExtendSurf/ExtendSurfPerpendicularToPlane4);\n\t\tshared_ptr<Geom3Plane> plane = make_shared<Geom3Plane>(Point3(0.0, 1.8, 0.0), Direction3(0.0, 1.0, 0.0));\n\t\tauto planevl = NURBSAPIExtend::ExtendSurfPerpendicularToPlane(surface, false, false, plane);\n\t\tshared_ptr<Geom3TrimmedSurface>trimSurf = std::make_shared<Geom3TrimmedSurface>(plane, -5.0, 5.0, -5.0, 5.0);\n\t\tshared_ptr<Geom3BSplineSurface> bspSurf2 = NURBSAPIConvert::ToBSpline(planevl);\n\t\tCHECK(bspSurf2->UDegree() == udeg);\n\t\tCHECK(bspSurf2->NUPoles() == upNum);\n\t\tCHECK(bspSurf2->NUKnots() == ukNum);\n\t\tdouble lpu1 = planevl->LastUParameter();\n\t\tshared_ptr<Geom3Curve> lu1 = planevl->UIso(lpu1);\n\t\tPoint3 p1;\n\t\tVector3 vec;\n\t\tdouble ls = lu1->LastParameter();\n\t\tlu1->D1(ls, p1, vec);\n\t\tAxis3 axis = plane->Axis();\n\t\tbool res = axis.Direction().IsParallel(Direction3(vec), Precision::Angular());\n\t\tdouble lpv1 = planevl->LastVParameter();\n\t\tshared_ptr<Geom3Curve> lv1 = planevl->VIso(lpv1);\n\t\tbool res1 = IsCurveOnSurf(num, ratio, lv1, plane, -1.0);\n\t\tCHECK(res1 == true);\n\t\tOCCTIO::OCCTTool::Write(MakeEdge(lv), outdir + \"curve1.brep\");\n\t\tOCCTIO::OCCTTool::Write(MakeEdge(lv1), outdir + \"curve2.brep\");\n\t\tOCCTIO::OCCTTool::Write(MakeFace(trimSurf, 0.0), outdir + \"trimSurf.brep\");\n\t\tOCCTIO::OCCTTool::Write(MakeFace(surface, 0.0), outdir + \"src.brep\");\n\t\tOCCTIO::OCCTTool::Write(MakeFace(planevl, 0.0), outdir + \"result.brep\");\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static std::shared_ptr<Geom3Surface> ExtendSurfByAverageLength(const std::shared_ptr<Geom3Surface>& surf, bool isExtendU, bool isFront, double averageLength, double tol = 1e-3)\t @return New surface\n\t @param tol The tolerance\n\t @param averageLength The average extend length\n\t @param isFront Extend front or back\n\t @param isExtendU Extend u direction or v direction\n\t @param surf Surface\n\t If new patch needed, refer to GeometryTool.\n\t The degree and the number of poles and knots are not changed.\n\t The original surface is part of new surface.\n\t @brief Extend surface with specified average 3D length.\n,\n",
      "output": "﻿#include<catch.hpp>\n#include<testHelper.h>\n#include <nurbs/NURBSAPIExtend.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <modeling/MakeFace.hpp>\n#include <topology/BRepExtremaDistShapeShape.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/Geom3Plane.hpp>\n#include <geometry/Geom3TrimmedSurface.hpp>\n#include <nurbs/NURBSAPIConvert.hpp>\n#include <nurbs/NURBSAPIBuildCurve.hpp>\n#include <geomAlgo/LawBSpline.hpp>\n#include <offset/MakePipe.hpp>\n#include <modeling/MakeWire.hpp>\n#include <topology/TopoTool.hpp>\n#include <topology/TopoExplorerTool.hpp>\n#include <geometry/GeomAPIProjectPointOnCurve3.hpp>\n#include <geometry/GeomAPIProjectPointOnSurface.hpp>\ndouble NurbsExtendSample2(int num, double len, double tol, const shared_ptr<Geom3Curve>& curve1, const shared_ptr<Geom3Curve>& curve2)\n{\n\tconst int nsample = num;\n\tdouble fp1 = curve1->FirstParameter();\n\tdouble lp1 = curve1->LastParameter();\n\tdouble delta1 = (lp1 - fp1) / nsample;\n\tPoint3 p;\n\tint n = 0;\n\tfor (int i = 0; i < nsample; i++)\n\t{\n\t\tdouble t1 = fp1 + i * delta1;\n\t\tcurve1->D0(t1, p);\n\t\tTopoVertex vt = MakeVertex(p);\n\t\tTopoEdge edge = MakeEdge(curve2);\n\t\tBRepExtremaDistShapeShape dist(vt, edge);\n\t\tdouble dis = abs(dist.Value() - len);\n\t\tif (dis <= tol)\n\t\t{\n\t\t\tn++;\n\t\t}\n\t}\n\tdouble res = 1.0 * (num - n) / num;\n\treturn res;\n}\nshared_ptr<Geom3Surface> ConstructExtendSurface2()\n{\n\tstd::vector<Point3> profilePoles;\n\tstd::vector<double> profileKnots(3);\n\tstd::vector<int> profileMults(3, 1);\n\tprofilePoles.push_back(Point3(0.0, 0.0, 0.0));\n\tprofilePoles.push_back(Point3(1.0, -0.2, 0.0));\n\tprofilePoles.push_back(Point3(2.0, 0.1, 0.0));\n\tprofilePoles.push_back(Point3(2.3, -0.1, 0.0));\n\tprofilePoles.push_back(Point3(2.9, 0.1, 0.0));\n\tprofileKnots[0] = 0;\n\tprofileKnots[1] = 0.5;\n\tprofileKnots[2] = 1;\n\tprofileMults.front() = 4;\n\tprofileMults.back() = 4;\n\tstd::shared_ptr<Geom3BSplineCurve> profile = std::make_shared<Geom3BSplineCurve>(profilePoles, profileKnots, profileMults, 3);\n\tstd::vector<Point3> spinePoles;\n\tstd::vector<double> spineKnots(4);\n\tstd::vector<int> spineMults(4, 1);\n\tspinePoles.push_back(Point3(0.0, 0.0, 0.0));\n\tspinePoles.push_back(Point3(0.0, 0.0, 1.0));\n\tspinePoles.push_back(Point3(0.0, 0.2, 1.5));\n\tspinePoles.push_back(Point3(0.0, 0.5, 2.0));\n\tspinePoles.push_back(Point3(0.0, 1.0, 2.3));\n\tspinePoles.push_back(Point3(0.0, 1.6, 2.3));\n\tspineKnots[0] = 0;\n\tspineKnots[1] = 1.0 / 3.0;\n\tspineKnots[2] = 2.0 / 3.0;\n\tspineKnots[3] = 1;\n\tspineMults.front() = 4;\n\tspineMults.back() = 4;\n\tstd::shared_ptr<Geom3BSplineCurve> spine = std::make_shared<Geom3BSplineCurve>(spinePoles, spineKnots, spineMults, 3);\n\tTopoShape pipe = MakePipe(MakeWire(MakeEdge(spine)), MakeWire(MakeEdge(profile))).Shape();\n\tTopoExplorer ex(pipe, ShapeType::Face);\n\tstd::shared_ptr<Geom3Surface> surface = TopoTool::Surface(static_cast<const TopoFace&>(ex.Current()));\n\treturn surface;\n}\n﻿#include<catch.hpp>\n#include<testHelper.h>\n#include <nurbs/NURBSAPIExtend.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <modeling/MakeFace.hpp>\n#include <topology/BRepExtremaDistShapeShape.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/Geom3Plane.hpp>\n#include <geometry/Geom3TrimmedSurface.hpp>\n#include <nurbs/NURBSAPIConvert.hpp>\n#include <nurbs/NURBSAPIBuildCurve.hpp>\n#include <geomAlgo/LawBSpline.hpp>\n#include <offset/MakePipe.hpp>\n#include <modeling/MakeWire.hpp>\n#include <topology/TopoTool.hpp>\n#include <topology/TopoExplorerTool.hpp>\n#include <geometry/GeomAPIProjectPointOnCurve3.hpp>\n#include <geometry/GeomAPIProjectPointOnSurface.hpp>\ndouble NurbsExtendSample2(int num, double len, double tol, const shared_ptr<Geom3Curve>& curve1, const shared_ptr<Geom3Curve>& curve2)\n{\n\tconst int nsample = num;\n\tdouble fp1 = curve1->FirstParameter();\n\tdouble lp1 = curve1->LastParameter();\n\tdouble delta1 = (lp1 - fp1) / nsample;\n\tPoint3 p;\n\tint n = 0;\n\tfor (int i = 0; i < nsample; i++)\n\t{\n\t\tdouble t1 = fp1 + i * delta1;\n\t\tcurve1->D0(t1, p);\n\t\tTopoVertex vt = MakeVertex(p);\n\t\tTopoEdge edge = MakeEdge(curve2);\n\t\tBRepExtremaDistShapeShape dist(vt, edge);\n\t\tdouble dis = abs(dist.Value() - len);\n\t\tif (dis <= tol)\n\t\t{\n\t\t\tn++;\n\t\t}\n\t}\n\tdouble res = 1.0 * (num - n) / num;\n\treturn res;\n}\nshared_ptr<Geom3Surface> ConstructExtendSurface2()\n{\n\tstd::vector<Point3> profilePoles;\n\tstd::vector<double> profileKnots(3);\n\tstd::vector<int> profileMults(3, 1);\n\tprofilePoles.push_back(Point3(0.0, 0.0, 0.0));\n\tprofilePoles.push_back(Point3(1.0, -0.2, 0.0));\n\tprofilePoles.push_back(Point3(2.0, 0.1, 0.0));\n\tprofilePoles.push_back(Point3(2.3, -0.1, 0.0));\n\tprofilePoles.push_back(Point3(2.9, 0.1, 0.0));\n\tprofileKnots[0] = 0;\n\tprofileKnots[1] = 0.5;\n\tprofileKnots[2] = 1;\n\tprofileMults.front() = 4;\n\tprofileMults.back() = 4;\n\tstd::shared_ptr<Geom3BSplineCurve> profile = std::make_shared<Geom3BSplineCurve>(profilePoles, profileKnots, profileMults, 3);\n\tstd::vector<Point3> spinePoles;\n\tstd::vector<double> spineKnots(4);\n\tstd::vector<int> spineMults(4, 1);\n\tspinePoles.push_back(Point3(0.0, 0.0, 0.0));\n\tspinePoles.push_back(Point3(0.0, 0.0, 1.0));\n\tspinePoles.push_back(Point3(0.0, 0.2, 1.5));\n\tspinePoles.push_back(Point3(0.0, 0.5, 2.0));\n\tspinePoles.push_back(Point3(0.0, 1.0, 2.3));\n\tspinePoles.push_back(Point3(0.0, 1.6, 2.3));\n\tspineKnots[0] = 0;\n\tspineKnots[1] = 1.0 / 3.0;\n\tspineKnots[2] = 2.0 / 3.0;\n\tspineKnots[3] = 1;\n\tspineMults.front() = 4;\n\tspineMults.back() = 4;\n\tstd::shared_ptr<Geom3BSplineCurve> spine = std::make_shared<Geom3BSplineCurve>(spinePoles, spineKnots, spineMults, 3);\n\tTopoShape pipe = MakePipe(MakeWire(MakeEdge(spine)), MakeWire(MakeEdge(profile))).Shape();\n\tTopoExplorer ex(pipe, ShapeType::Face);\n\tstd::shared_ptr<Geom3Surface> surface = TopoTool::Surface(static_cast<const TopoFace&>(ex.Current()));\n\treturn surface;\n;\n\tSECTION(\"ExtendSurfByAverageLength1\")\n\t{\n\t\tOUTPUT_DIRECTORY(nurbs, Extend/ExtendSurf/ExtendSurfByAverageLength1);\n\t\tauto lengthsurf = NURBSAPIExtend::ExtendSurfByAverageLength(surface, true, true, len);\n\t\tshared_ptr<Geom3BSplineSurface> bspSurf2 = NURBSAPIConvert::ToBSpline(lengthsurf);\n\t\tCHECK(bspSurf2->UDegree() == udeg);\n\t\tCHECK(bspSurf2->VDegree() == vdeg);\n\t\tCHECK(bspSurf2->NUPoles() == upNum);\n\t\tCHECK(bspSurf2->NVPoles() == vpNum);\n\t\tCHECK(bspSurf2->NUKnots() == ukNum);\n\t\tCHECK(bspSurf2->NVKnots() == vkNum);\n\t\tdouble fpu11 = lengthsurf->FirstUParameter();\n\t\tshared_ptr<Geom3Curve> fu11 = lengthsurf->UIso(fpu11);\n\t\tdouble res1 = NurbsExtendSample2(num, len, tol, fu, fu11);\n\t\tCHECK(res1 <= ratio);\n\t\tOCCTIO::OCCTTool::Write(MakeEdge(fu), outdir + \"curve1.brep\");\n\t\tOCCTIO::OCCTTool::Write(MakeEdge(fu11), outdir + \"curve2.brep\");\n\t\tOCCTIO::OCCTTool::Write(MakeFace(surface, 0.0), outdir + \"src.brep\");\n\t\tOCCTIO::OCCTTool::Write(MakeFace(lengthsurf, 0.0), outdir + \"result.brep\");\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static std::shared_ptr<Geom3Surface> ExtendSurfToPoint(const std::shared_ptr<Geom3Surface>& surf, bool isU, bool isFront, const Point3& pt)\t @return New surface\n\t @param pt Point\n\t @param isFront Extend front or back\n\t @param isU Extend u or v\n\t @param surf Surface\n\t The degree of the surface, the size of the extended direction (u or v) knots and poles are not changed.\n\t The original surface is part of new surface.\n\t @brief Extend surface to a point.\n,\n",
      "output": "﻿#include<catch.hpp>\n#include<testHelper.h>\n#include <nurbs/NURBSAPIExtend.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <modeling/MakeFace.hpp>\n#include <topology/BRepExtremaDistShapeShape.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/Geom3Plane.hpp>\n#include <geometry/Geom3TrimmedSurface.hpp>\n#include <nurbs/NURBSAPIConvert.hpp>\n#include <nurbs/NURBSAPIBuildCurve.hpp>\n#include <geomAlgo/LawBSpline.hpp>\n#include <offset/MakePipe.hpp>\n#include <modeling/MakeWire.hpp>\n#include <topology/TopoTool.hpp>\n#include <topology/TopoExplorerTool.hpp>\n#include <geometry/GeomAPIProjectPointOnCurve3.hpp>\n#include <geometry/GeomAPIProjectPointOnSurface.hpp>\ndouble NurbsExtendSample2(int num, double len, double tol, const shared_ptr<Geom3Curve>& curve1, const shared_ptr<Geom3Curve>& curve2)\n{\n\tconst int nsample = num;\n\tdouble fp1 = curve1->FirstParameter();\n\tdouble lp1 = curve1->LastParameter();\n\tdouble delta1 = (lp1 - fp1) / nsample;\n\tPoint3 p;\n\tint n = 0;\n\tfor (int i = 0; i < nsample; i++)\n\t{\n\t\tdouble t1 = fp1 + i * delta1;\n\t\tcurve1->D0(t1, p);\n\t\tTopoVertex vt = MakeVertex(p);\n\t\tTopoEdge edge = MakeEdge(curve2);\n\t\tBRepExtremaDistShapeShape dist(vt, edge);\n\t\tdouble dis = abs(dist.Value() - len);\n\t\tif (dis <= tol)\n\t\t{\n\t\t\tn++;\n\t\t}\n\t}\n\tdouble res = 1.0 * (num - n) / num;\n\treturn res;\n}\nshared_ptr<Geom3Surface> ConstructExtendSurface2()\n{\n\tstd::vector<Point3> profilePoles;\n\tstd::vector<double> profileKnots(3);\n\tstd::vector<int> profileMults(3, 1);\n\tprofilePoles.push_back(Point3(0.0, 0.0, 0.0));\n\tprofilePoles.push_back(Point3(1.0, -0.2, 0.0));\n\tprofilePoles.push_back(Point3(2.0, 0.1, 0.0));\n\tprofilePoles.push_back(Point3(2.3, -0.1, 0.0));\n\tprofilePoles.push_back(Point3(2.9, 0.1, 0.0));\n\tprofileKnots[0] = 0;\n\tprofileKnots[1] = 0.5;\n\tprofileKnots[2] = 1;\n\tprofileMults.front() = 4;\n\tprofileMults.back() = 4;\n\tstd::shared_ptr<Geom3BSplineCurve> profile = std::make_shared<Geom3BSplineCurve>(profilePoles, profileKnots, profileMults, 3);\n\tstd::vector<Point3> spinePoles;\n\tstd::vector<double> spineKnots(4);\n\tstd::vector<int> spineMults(4, 1);\n\tspinePoles.push_back(Point3(0.0, 0.0, 0.0));\n\tspinePoles.push_back(Point3(0.0, 0.0, 1.0));\n\tspinePoles.push_back(Point3(0.0, 0.2, 1.5));\n\tspinePoles.push_back(Point3(0.0, 0.5, 2.0));\n\tspinePoles.push_back(Point3(0.0, 1.0, 2.3));\n\tspinePoles.push_back(Point3(0.0, 1.6, 2.3));\n\tspineKnots[0] = 0;\n\tspineKnots[1] = 1.0 / 3.0;\n\tspineKnots[2] = 2.0 / 3.0;\n\tspineKnots[3] = 1;\n\tspineMults.front() = 4;\n\tspineMults.back() = 4;\n\tstd::shared_ptr<Geom3BSplineCurve> spine = std::make_shared<Geom3BSplineCurve>(spinePoles, spineKnots, spineMults, 3);\n\tTopoShape pipe = MakePipe(MakeWire(MakeEdge(spine)), MakeWire(MakeEdge(profile))).Shape();\n\tTopoExplorer ex(pipe, ShapeType::Face);\n\tstd::shared_ptr<Geom3Surface> surface = TopoTool::Surface(static_cast<const TopoFace&>(ex.Current()));\n\treturn surface;\n}\n﻿#include<catch.hpp>\n#include<testHelper.h>\n#include <nurbs/NURBSAPIExtend.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <modeling/MakeFace.hpp>\n#include <topology/BRepExtremaDistShapeShape.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/Geom3Plane.hpp>\n#include <geometry/Geom3TrimmedSurface.hpp>\n#include <nurbs/NURBSAPIConvert.hpp>\n#include <nurbs/NURBSAPIBuildCurve.hpp>\n#include <geomAlgo/LawBSpline.hpp>\n#include <offset/MakePipe.hpp>\n#include <modeling/MakeWire.hpp>\n#include <topology/TopoTool.hpp>\n#include <topology/TopoExplorerTool.hpp>\n#include <geometry/GeomAPIProjectPointOnCurve3.hpp>\n#include <geometry/GeomAPIProjectPointOnSurface.hpp>\ndouble NurbsExtendSample2(int num, double len, double tol, const shared_ptr<Geom3Curve>& curve1, const shared_ptr<Geom3Curve>& curve2)\n{\n\tconst int nsample = num;\n\tdouble fp1 = curve1->FirstParameter();\n\tdouble lp1 = curve1->LastParameter();\n\tdouble delta1 = (lp1 - fp1) / nsample;\n\tPoint3 p;\n\tint n = 0;\n\tfor (int i = 0; i < nsample; i++)\n\t{\n\t\tdouble t1 = fp1 + i * delta1;\n\t\tcurve1->D0(t1, p);\n\t\tTopoVertex vt = MakeVertex(p);\n\t\tTopoEdge edge = MakeEdge(curve2);\n\t\tBRepExtremaDistShapeShape dist(vt, edge);\n\t\tdouble dis = abs(dist.Value() - len);\n\t\tif (dis <= tol)\n\t\t{\n\t\t\tn++;\n\t\t}\n\t}\n\tdouble res = 1.0 * (num - n) / num;\n\treturn res;\n}\nshared_ptr<Geom3Surface> ConstructExtendSurface2()\n{\n\tstd::vector<Point3> profilePoles;\n\tstd::vector<double> profileKnots(3);\n\tstd::vector<int> profileMults(3, 1);\n\tprofilePoles.push_back(Point3(0.0, 0.0, 0.0));\n\tprofilePoles.push_back(Point3(1.0, -0.2, 0.0));\n\tprofilePoles.push_back(Point3(2.0, 0.1, 0.0));\n\tprofilePoles.push_back(Point3(2.3, -0.1, 0.0));\n\tprofilePoles.push_back(Point3(2.9, 0.1, 0.0));\n\tprofileKnots[0] = 0;\n\tprofileKnots[1] = 0.5;\n\tprofileKnots[2] = 1;\n\tprofileMults.front() = 4;\n\tprofileMults.back() = 4;\n\tstd::shared_ptr<Geom3BSplineCurve> profile = std::make_shared<Geom3BSplineCurve>(profilePoles, profileKnots, profileMults, 3);\n\tstd::vector<Point3> spinePoles;\n\tstd::vector<double> spineKnots(4);\n\tstd::vector<int> spineMults(4, 1);\n\tspinePoles.push_back(Point3(0.0, 0.0, 0.0));\n\tspinePoles.push_back(Point3(0.0, 0.0, 1.0));\n\tspinePoles.push_back(Point3(0.0, 0.2, 1.5));\n\tspinePoles.push_back(Point3(0.0, 0.5, 2.0));\n\tspinePoles.push_back(Point3(0.0, 1.0, 2.3));\n\tspinePoles.push_back(Point3(0.0, 1.6, 2.3));\n\tspineKnots[0] = 0;\n\tspineKnots[1] = 1.0 / 3.0;\n\tspineKnots[2] = 2.0 / 3.0;\n\tspineKnots[3] = 1;\n\tspineMults.front() = 4;\n\tspineMults.back() = 4;\n\tstd::shared_ptr<Geom3BSplineCurve> spine = std::make_shared<Geom3BSplineCurve>(spinePoles, spineKnots, spineMults, 3);\n\tTopoShape pipe = MakePipe(MakeWire(MakeEdge(spine)), MakeWire(MakeEdge(profile))).Shape();\n\tTopoExplorer ex(pipe, ShapeType::Face);\n\tstd::shared_ptr<Geom3Surface> surface = TopoTool::Surface(static_cast<const TopoFace&>(ex.Current()));\n\treturn surface;\n;\n\tSECTION(\"ExtendSurfToPoint1\")\n\t{\n\t\tOUTPUT_DIRECTORY(nurbs, Extend/ExtendSurf/ExtendSurfToPoint1);\n\t\tPoint3 target(-1.2, 0.5, 1.0);\n\t\tauto pointuf = NURBSAPIExtend::ExtendSurfToPoint(surface, true, true, target);\n\t\tshared_ptr<Geom3BSplineSurface> bspSurf2 = NURBSAPIConvert::ToBSpline(pointuf);\n\t\tCHECK(bspSurf2->UDegree() == udeg);\n\t\tCHECK(bspSurf2->VDegree() == vdeg);\n\t\tCHECK(bspSurf2->NUPoles() == upNum);\n\t\tCHECK(bspSurf2->NVPoles() == vpNum);\n\t\tCHECK(bspSurf2->NUKnots() == ukNum);\n\t\tCHECK(bspSurf2->NVKnots() == vkNum);\n\t\tGeomAPIProjectPointOnSurface proj(target, pointuf);\n\t\tPoint3 pp = proj.NearestPoint();\n\t\tdouble fpu2 = pointuf->FirstUParameter();\n\t\tshared_ptr<Geom3Curve> fu2 = pointuf->UIso(fpu2);\n\t\tTopoEdge edge2 = MakeEdge(fu2);\n\t\tbool res1 = BRepClassificationTools::IsPointInOnEdge(edge2, pp, 1e-3);\n\t\tCHECK(res1 == true);\n\t\tOCCTIO::OCCTTool::Write(MakeVertex(target), outdir + \"refp.brep\");\n\t\tOCCTIO::OCCTTool::Write(MakeEdge(fu), outdir + \"fu.brep\");\n\t\tOCCTIO::OCCTTool::Write(MakeEdge(fu2), outdir + \"fu2.brep\");\n\t\tOCCTIO::OCCTTool::Write(MakeVertex(pp), outdir + \"pp.brep\");\n\t\tOCCTIO::OCCTTool::Write(MakeFace(surface, 0.0), outdir + \"src.brep\");\n\t\tOCCTIO::OCCTTool::Write(MakeFace(pointuf, 0.0), outdir + \"result.brep\");\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static std::shared_ptr<Geom3Curve> ExtendCurveToDynamicPoint(const std::shared_ptr<Geom3Curve>& curve, bool isFront, const Point3& pt)\t @return New curve\n\t @param pt Point\n\t @param isFront Extend front or back\n\t @param curve Curve\n\t The degree is not changed but the number of poles and knots increase 1.\n\t The original curve is part of new curve.\n\t @brief Extend curve to a point.\n,\n",
      "output": "﻿#include<catch.hpp>\n#include<testHelper.h>\n#include <nurbs/NURBSAPIExtend.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <modeling/MakeFace.hpp>\n#include <topology/BRepExtremaDistShapeShape.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/Geom3Plane.hpp>\n#include <geometry/Geom3TrimmedSurface.hpp>\n#include <nurbs/NURBSAPIConvert.hpp>\n#include <nurbs/NURBSAPIBuildCurve.hpp>\n#include <geomAlgo/LawBSpline.hpp>\n#include <offset/MakePipe.hpp>\n#include <modeling/MakeWire.hpp>\n#include <topology/TopoTool.hpp>\n#include <topology/TopoExplorerTool.hpp>\n#include <geometry/GeomAPIProjectPointOnCurve3.hpp>\n#include <geometry/GeomAPIProjectPointOnSurface.hpp>\ndouble NurbsExtendSample2(int num, double len, double tol, const shared_ptr<Geom3Curve>& curve1, const shared_ptr<Geom3Curve>& curve2)\n{\n\tconst int nsample = num;\n\tdouble fp1 = curve1->FirstParameter();\n\tdouble lp1 = curve1->LastParameter();\n\tdouble delta1 = (lp1 - fp1) / nsample;\n\tPoint3 p;\n\tint n = 0;\n\tfor (int i = 0; i < nsample; i++)\n\t{\n\t\tdouble t1 = fp1 + i * delta1;\n\t\tcurve1->D0(t1, p);\n\t\tTopoVertex vt = MakeVertex(p);\n\t\tTopoEdge edge = MakeEdge(curve2);\n\t\tBRepExtremaDistShapeShape dist(vt, edge);\n\t\tdouble dis = abs(dist.Value() - len);\n\t\tif (dis <= tol)\n\t\t{\n\t\t\tn++;\n\t\t}\n\t}\n\tdouble res = 1.0 * (num - n) / num;\n\treturn res;\n}\nshared_ptr<Geom3Surface> ConstructExtendSurface2()\n{\n\tstd::vector<Point3> profilePoles;\n\tstd::vector<double> profileKnots(3);\n\tstd::vector<int> profileMults(3, 1);\n\tprofilePoles.push_back(Point3(0.0, 0.0, 0.0));\n\tprofilePoles.push_back(Point3(1.0, -0.2, 0.0));\n\tprofilePoles.push_back(Point3(2.0, 0.1, 0.0));\n\tprofilePoles.push_back(Point3(2.3, -0.1, 0.0));\n\tprofilePoles.push_back(Point3(2.9, 0.1, 0.0));\n\tprofileKnots[0] = 0;\n\tprofileKnots[1] = 0.5;\n\tprofileKnots[2] = 1;\n\tprofileMults.front() = 4;\n\tprofileMults.back() = 4;\n\tstd::shared_ptr<Geom3BSplineCurve> profile = std::make_shared<Geom3BSplineCurve>(profilePoles, profileKnots, profileMults, 3);\n\tstd::vector<Point3> spinePoles;\n\tstd::vector<double> spineKnots(4);\n\tstd::vector<int> spineMults(4, 1);\n\tspinePoles.push_back(Point3(0.0, 0.0, 0.0));\n\tspinePoles.push_back(Point3(0.0, 0.0, 1.0));\n\tspinePoles.push_back(Point3(0.0, 0.2, 1.5));\n\tspinePoles.push_back(Point3(0.0, 0.5, 2.0));\n\tspinePoles.push_back(Point3(0.0, 1.0, 2.3));\n\tspinePoles.push_back(Point3(0.0, 1.6, 2.3));\n\tspineKnots[0] = 0;\n\tspineKnots[1] = 1.0 / 3.0;\n\tspineKnots[2] = 2.0 / 3.0;\n\tspineKnots[3] = 1;\n\tspineMults.front() = 4;\n\tspineMults.back() = 4;\n\tstd::shared_ptr<Geom3BSplineCurve> spine = std::make_shared<Geom3BSplineCurve>(spinePoles, spineKnots, spineMults, 3);\n\tTopoShape pipe = MakePipe(MakeWire(MakeEdge(spine)), MakeWire(MakeEdge(profile))).Shape();\n\tTopoExplorer ex(pipe, ShapeType::Face);\n\tstd::shared_ptr<Geom3Surface> surface = TopoTool::Surface(static_cast<const TopoFace&>(ex.Current()));\n\treturn surface;\n}\n﻿#include<catch.hpp>\n#include<testHelper.h>\n#include <nurbs/NURBSAPIExtend.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <modeling/MakeFace.hpp>\n#include <topology/BRepExtremaDistShapeShape.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/Geom3Plane.hpp>\n#include <geometry/Geom3TrimmedSurface.hpp>\n#include <nurbs/NURBSAPIConvert.hpp>\n#include <nurbs/NURBSAPIBuildCurve.hpp>\n#include <geomAlgo/LawBSpline.hpp>\n#include <offset/MakePipe.hpp>\n#include <modeling/MakeWire.hpp>\n#include <topology/TopoTool.hpp>\n#include <topology/TopoExplorerTool.hpp>\n#include <geometry/GeomAPIProjectPointOnCurve3.hpp>\n#include <geometry/GeomAPIProjectPointOnSurface.hpp>\ndouble NurbsExtendSample2(int num, double len, double tol, const shared_ptr<Geom3Curve>& curve1, const shared_ptr<Geom3Curve>& curve2)\n{\n\tconst int nsample = num;\n\tdouble fp1 = curve1->FirstParameter();\n\tdouble lp1 = curve1->LastParameter();\n\tdouble delta1 = (lp1 - fp1) / nsample;\n\tPoint3 p;\n\tint n = 0;\n\tfor (int i = 0; i < nsample; i++)\n\t{\n\t\tdouble t1 = fp1 + i * delta1;\n\t\tcurve1->D0(t1, p);\n\t\tTopoVertex vt = MakeVertex(p);\n\t\tTopoEdge edge = MakeEdge(curve2);\n\t\tBRepExtremaDistShapeShape dist(vt, edge);\n\t\tdouble dis = abs(dist.Value() - len);\n\t\tif (dis <= tol)\n\t\t{\n\t\t\tn++;\n\t\t}\n\t}\n\tdouble res = 1.0 * (num - n) / num;\n\treturn res;\n}\nshared_ptr<Geom3Surface> ConstructExtendSurface2()\n{\n\tstd::vector<Point3> profilePoles;\n\tstd::vector<double> profileKnots(3);\n\tstd::vector<int> profileMults(3, 1);\n\tprofilePoles.push_back(Point3(0.0, 0.0, 0.0));\n\tprofilePoles.push_back(Point3(1.0, -0.2, 0.0));\n\tprofilePoles.push_back(Point3(2.0, 0.1, 0.0));\n\tprofilePoles.push_back(Point3(2.3, -0.1, 0.0));\n\tprofilePoles.push_back(Point3(2.9, 0.1, 0.0));\n\tprofileKnots[0] = 0;\n\tprofileKnots[1] = 0.5;\n\tprofileKnots[2] = 1;\n\tprofileMults.front() = 4;\n\tprofileMults.back() = 4;\n\tstd::shared_ptr<Geom3BSplineCurve> profile = std::make_shared<Geom3BSplineCurve>(profilePoles, profileKnots, profileMults, 3);\n\tstd::vector<Point3> spinePoles;\n\tstd::vector<double> spineKnots(4);\n\tstd::vector<int> spineMults(4, 1);\n\tspinePoles.push_back(Point3(0.0, 0.0, 0.0));\n\tspinePoles.push_back(Point3(0.0, 0.0, 1.0));\n\tspinePoles.push_back(Point3(0.0, 0.2, 1.5));\n\tspinePoles.push_back(Point3(0.0, 0.5, 2.0));\n\tspinePoles.push_back(Point3(0.0, 1.0, 2.3));\n\tspinePoles.push_back(Point3(0.0, 1.6, 2.3));\n\tspineKnots[0] = 0;\n\tspineKnots[1] = 1.0 / 3.0;\n\tspineKnots[2] = 2.0 / 3.0;\n\tspineKnots[3] = 1;\n\tspineMults.front() = 4;\n\tspineMults.back() = 4;\n\tstd::shared_ptr<Geom3BSplineCurve> spine = std::make_shared<Geom3BSplineCurve>(spinePoles, spineKnots, spineMults, 3);\n\tTopoShape pipe = MakePipe(MakeWire(MakeEdge(spine)), MakeWire(MakeEdge(profile))).Shape();\n\tTopoExplorer ex(pipe, ShapeType::Face);\n\tstd::shared_ptr<Geom3Surface> surface = TopoTool::Surface(static_cast<const TopoFace&>(ex.Current()));\n\treturn surface;\n;\n\tSECTION(\"TestExtendDynamic\")\n\t{\n\t\tOUTPUT_DIRECTORY(nurbs, Extend/bug747/ExtendCurveDynamic/ExtendDynamic);\n\t\tint num = 1000;\n\t\tdouble ratio = 0.1;\n\t\tdouble refTol = DEFAULT_TOLERANCE;\n\t\tint refDeg = INCREASE_DEGREE;\n\t\tauto src1 = ReadBRepCurve(INPUT_PATH_PREFIX\"/TestNURBS/TestExtendDynamic/src1.brep\");\n\t\tauto targetPoint1 = ReadBRepPoint(INPUT_PATH_PREFIX\"/TestNURBS/TestExtendDynamic/target1.brep\");\n\t\tLawBSpline srcw1(src1->Weights(), src1->Knots(), src1->Multiplicities(), src1->Degree(), src1->IsPeriodic());\n\t\tdouble src1weight, rhi1weight, src2weight, rhi2weight, src1dw, rhi1dw, src2dw, rhi2dw, src1dw2, rhi1dw2, src2dw2, rhi2dw2;\n\t\tdouble t1 = src1->LastParameter() - 0.01;\n\t\tsrcw1.D2(t1, src1weight, src1dw, src1dw2);\n\t\tint degree1 = src1->Degree();\n\t\tint pNum1 = src1->NPoles();\n\t\tint kNum1 = src1->NKnots();\n\t\tdouble f1 = src1->FirstParameter();\n\t\tdouble l1 = src1->LastParameter();\n\t\tPoint3 sp1 = src1->Value(f1);\n\t\tPoint3 ep1 = src1->Value(l1);\n\t\tshared_ptr<Geom3BSplineCurve> src1Inc = std::dynamic_pointer_cast<Geom3BSplineCurve>(src1->Copy());\n\t\tsrc1Inc->IncreaseDegree(refDeg);\n\t\tauto extended1 = NURBSAPIExtend::ExtendCurveToDynamicPoint(src1, false, targetPoint1);\n\t\tdouble fp1 = extended1->FirstParameter();\n\t\tdouble lp1 = extended1->LastParameter();\n\t\tPoint3 p1 = extended1->Value(fp1);\n\t\tPoint3 p2 = extended1->Value(lp1);\n\t\tauto extended1Inc = NURBSAPIExtend::ExtendCurveToDynamicPoint(src1Inc, false, targetPoint1);\n\t\tshared_ptr<Geom3BSplineCurve> bspCurve1Inc = NURBSAPIConvert::ToBSpline(extended1Inc);\n\t\tCHECK(bspCurve1Inc->Degree() == refDeg);\n\t\tCHECK(bspCurve1Inc->NKnots() == (kNum1 + 1));\n\t\tdouble fp1Inc = extended1Inc->FirstParameter();\n\t\tdouble lp1Inc = extended1Inc->LastParameter();\n\t\tPoint3 p1Inc = extended1Inc->Value(fp1Inc);\n\t\tPoint3 p2Inc = extended1Inc->Value(lp1Inc);\n\t\tCHECK(p1Inc.X() == Approx(sp1.X()));\n\t\tCHECK(p1Inc.Y() == Approx(sp1.Y()));\n\t\tCHECK(p1Inc.Z() == Approx(sp1.Z()));\n\t\tCHECK(p2Inc.X() == Approx(targetPoint1.X()));\n\t\tCHECK(p2Inc.Y() == Approx(targetPoint1.Y()));\n\t\tCHECK(p2Inc.Z() == Approx(targetPoint1.Z()));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static std::shared_ptr<Geom3Surface> ExtendSurfByAverageLength(const std::shared_ptr<Geom3Surface>& surf, bool isExtendU, bool isFront, double averageLength, double tol = 1e-3)\t @return New surface\n\t @param tol The tolerance\n\t @param averageLength The average extend length\n\t @param isFront Extend front or back\n\t @param isExtendU Extend u direction or v direction\n\t @param surf Surface\n\t If new patch needed, refer to GeometryTool.\n\t The degree and the number of poles and knots are not changed.\n\t The original surface is part of new surface.\n\t @brief Extend surface with specified average 3D length.\n,\n",
      "output": "﻿#include<catch.hpp>\n#include<testHelper.h>\n#include <nurbs/NURBSAPIExtend.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <modeling/MakeFace.hpp>\n#include <topology/BRepExtremaDistShapeShape.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/Geom3Plane.hpp>\n#include <geometry/Geom3TrimmedSurface.hpp>\n#include <nurbs/NURBSAPIConvert.hpp>\n#include <nurbs/NURBSAPIBuildCurve.hpp>\n#include <geomAlgo/LawBSpline.hpp>\n#include <offset/MakePipe.hpp>\n#include <modeling/MakeWire.hpp>\n#include <topology/TopoTool.hpp>\n#include <topology/TopoExplorerTool.hpp>\n#include <geometry/GeomAPIProjectPointOnCurve3.hpp>\n#include <geometry/GeomAPIProjectPointOnSurface.hpp>\ndouble NurbsExtendSample(int num, double len, double tol, const shared_ptr<Geom3Curve>& curve1, const shared_ptr<Geom3Curve>& curve2)\n{\n\tconst int nsample = num;\n\tdouble fp1 = curve1->FirstParameter();\n\tdouble lp1 = curve1->LastParameter();\n\tdouble delta1 = (lp1 - fp1) / nsample;\n\tPoint3 p;\n\tint n = 0;\n\tfor (int i = 0; i < nsample; i++)\n\t{\n\t\tdouble t1 = fp1 + i * delta1;\n\t\tcurve1->D0(t1, p);\n\t\tTopoVertex vt = MakeVertex(p);\n\t\tTopoEdge edge = MakeEdge(curve2);\n\t\tBRepExtremaDistShapeShape dist(vt, edge);\n\t\tdouble dis = abs(dist.Value() - len);\n\t\tif (dis <= tol)\n\t\t{\n\t\t\tn++;\n\t\t}\n\t}\n\tdouble res = 1.0 * (num - n) / num;\n\treturn res;\n}\nshared_ptr<Geom3Surface> ConstructExtendSurface()\n{\n\tstd::vector<Point3> profilePoles;\n\tstd::vector<double> profileKnots(3);\n\tstd::vector<int> profileMults(3, 1);\n\tprofilePoles.push_back(Point3(0.0, 0.0, 0.0));\n\tprofilePoles.push_back(Point3(1.0, -0.2, 0.0));\n\tprofilePoles.push_back(Point3(2.0, 0.1, 0.0));\n\tprofilePoles.push_back(Point3(2.3, -0.1, 0.0));\n\tprofilePoles.push_back(Point3(2.9, 0.1, 0.0));\n\tprofileKnots[0] = 0;\n\tprofileKnots[1] = 0.5;\n\tprofileKnots[2] = 1;\n\tprofileMults.front() = 4;\n\tprofileMults.back() = 4;\n\tstd::shared_ptr<Geom3BSplineCurve> profile = std::make_shared<Geom3BSplineCurve>(profilePoles, profileKnots, profileMults, 3);\n\tstd::vector<Point3> spinePoles;\n\tstd::vector<double> spineKnots(4);\n\tstd::vector<int> spineMults(4, 1);\n\tspinePoles.push_back(Point3(0.0, 0.0, 0.0));\n\tspinePoles.push_back(Point3(0.0, 0.0, 1.0));\n\tspinePoles.push_back(Point3(0.0, 0.2, 1.5));\n\tspinePoles.push_back(Point3(0.0, 0.5, 2.0));\n\tspinePoles.push_back(Point3(0.0, 1.0, 2.3));\n\tspinePoles.push_back(Point3(0.0, 1.6, 2.3));\n\tspineKnots[0] = 0;\n\tspineKnots[1] = 1.0 / 3.0;\n\tspineKnots[2] = 2.0 / 3.0;\n\tspineKnots[3] = 1;\n\tspineMults.front() = 4;\n\tspineMults.back() = 4;\n\tstd::shared_ptr<Geom3BSplineCurve> spine = std::make_shared<Geom3BSplineCurve>(spinePoles, spineKnots, spineMults, 3);\n\tTopoShape pipe = MakePipe(MakeWire(MakeEdge(spine)), MakeWire(MakeEdge(profile))).Shape();\n\tTopoExplorer ex(pipe, ShapeType::Face);\n\tstd::shared_ptr<Geom3Surface> surface = TopoTool::Surface(static_cast<const TopoFace&>(ex.Current()));\n\treturn surface;\n}\nshared_ptr<Geom3Surface> ConstructExtendPeriodicSurf()\n{\n\tstd::vector<Point3> profilePoles;\n\tprofilePoles.push_back(Point3(0.0, 0.0, 0.0));\n\tprofilePoles.push_back(Point3(1.0, -1.0, 0.0));\n\tprofilePoles.push_back(Point3(2.0, -1.5, 0.0));\n\tprofilePoles.push_back(Point3(2.3, -1.0, 0.0));\n\tprofilePoles.push_back(Point3(2.9, 0.0, 0.0));\n\tprofilePoles.push_back(Point3(2.3, 0.9, 0.0));\n\tprofilePoles.push_back(Point3(2.1, 1.6, 0.0));\n\tprofilePoles.push_back(Point3(1.0, 1.0, 0.0));\n\tstd::vector<double> profileKnots(profilePoles.size() + 1);\n\tfor (int i = 0; i < static_cast<int>(profileKnots.size()); i++)\n\t{\n\t\tprofileKnots[i] = (double)i / (double)(profilePoles.size());\n\t}\n\tprofileKnots[1] += 1.0 / (double)(3 * profilePoles.size());\n\tstd::vector<int> profileMults(profileKnots.size(), 1);\n\tstd::shared_ptr<Geom3BSplineCurve> profile = std::make_shared<Geom3BSplineCurve>(profilePoles, profileKnots, profileMults, 3, true);\n\tstd::vector<Point3> spinePoles;\n\tstd::vector<double> spineKnots(4);\n\tstd::vector<int> spineMults(4, 1);\n\tspinePoles.push_back(Point3(0.0, 0.0, 0.0));\n\tspinePoles.push_back(Point3(0.0, 0.0, 1.0));\n\tspinePoles.push_back(Point3(0.0, 0.2, 1.5));\n\tspinePoles.push_back(Point3(0.0, 0.5, 2.0));\n\tspinePoles.push_back(Point3(0.0, 1.0, 2.3));\n\tspinePoles.push_back(Point3(0.0, 1.6, 2.3));\n\tspineKnots[0] = 0;\n\tspineKnots[1] = 1.0 / 3.0;\n\tspineKnots[2] = 2.0 / 3.0;\n\tspineKnots[3] = 1;\n\tspineMults.front() = 4;\n\tspineMults.back() = 4;\n\tstd::shared_ptr<Geom3BSplineCurve> spine = std::make_shared<Geom3BSplineCurve>(spinePoles, spineKnots, spineMults, 3);\n\tTopoShape pipe = MakePipe(MakeWire(MakeEdge(spine)), MakeWire(MakeEdge(profile))).Shape();\n\tTopoExplorer ex(pipe, ShapeType::Face);\n\tstd::shared_ptr<Geom3Surface> surface = TopoTool::Surface(static_cast<const TopoFace&>(ex.Current()));\n\treturn surface;\n}\nTEST_CASE(\"bug2:ExtendPeriodicSurf \", \"[nurbs][Extend][fixbug]\")\n{\n\tOUTPUT_DIRECTORY(nurbs, Extend/bug612);\n\tint num = 1000;\n\tdouble tol = 1e-4;\n\tdouble ratio = 0.01;\n\tdouble refTol = DEFAULT_TOLERANCE;\n\tstd::vector<Point3> profilePoles;\n\tprofilePoles.push_back(Point3(0.0, 0.0, 0.0));\n\tprofilePoles.push_back(Point3(1.0, -1.0, 0.0));\n\tprofilePoles.push_back(Point3(2.0, -1.5, 0.0));\n\tprofilePoles.push_back(Point3(2.3, -1.0, 0.0));\n\tprofilePoles.push_back(Point3(2.9, 0.0, 0.0));\n\tprofilePoles.push_back(Point3(2.3, 0.9, 0.0));\n\tprofilePoles.push_back(Point3(2.1, 1.6, 0.0));\n\tprofilePoles.push_back(Point3(1.0, 1.0, 0.0));\n\tstd::vector<double> profileKnots(profilePoles.size() + 1);\n\tfor (int i = 0; i < static_cast<int>(profileKnots.size()); i++)\n\t{\n\t\tprofileKnots[i] = (double)i / (double)(profilePoles.size());\n\t}\n\tprofileKnots[1] += 1.0 / (double)(3 * profilePoles.size());\n\tstd::vector<int> profileMults(profileKnots.size(), 1);\n\tstd::shared_ptr<Geom3BSplineCurve> profile = std::make_shared<Geom3BSplineCurve>(profilePoles, profileKnots, profileMults, 3, true);\n\tstd::vector<Point3> spinePoles;\n\tstd::vector<double> spineKnots(4);\n\tstd::vector<int> spineMults(4, 1);\n\tspinePoles.push_back(Point3(0.0, 0.0, 0.0));\n\tspinePoles.push_back(Point3(0.0, 0.0, 1.0));\n\tspinePoles.push_back(Point3(0.0, 0.2, 1.5));\n\tspinePoles.push_back(Point3(0.0, 0.5, 2.0));\n\tspinePoles.push_back(Point3(0.0, 1.0, 2.3));\n\tspinePoles.push_back(Point3(0.0, 1.6, 2.3));\n\tspineKnots[0] = 0;\n\tspineKnots[1] = 1.0 / 3.0;\n\tspineKnots[2] = 2.0 / 3.0;\n\tspineKnots[3] = 1;\n\tspineMults.front() = 4;\n\tspineMults.back() = 4;\n\tstd::shared_ptr<Geom3BSplineCurve> spine = std::make_shared<Geom3BSplineCurve>(spinePoles, spineKnots, spineMults, 3);\n\tTopoShape pipe = MakePipe(MakeWire(MakeEdge(spine)), MakeWire(MakeEdge(profile))).Shape();\n\tTopoExplorer ex(pipe, ShapeType::Face);\n\tstd::shared_ptr<Geom3Surface> surface = TopoTool::Surface(static_cast<const TopoFace&>(ex.Current()));\n\tshared_ptr<Geom3BSplineSurface> bspSurf = NURBSAPIConvert::ToBSpline(surface);\n\tint udeg = bspSurf->UDegree();\n\tint vdeg = bspSurf->VDegree();\n\tint upNum = bspSurf->NUPoles();\n\tint vpNum = bspSurf->NVPoles();\n\tint ukNum = bspSurf->NUKnots();\n\tint vkNum = bspSurf->NVKnots();\n\tdouble fpu = surface->FirstUParameter();\n\tdouble fpv = surface->FirstVParameter();\n\tdouble lpu = surface->LastUParameter();\n\tdouble lpv = surface->LastVParameter();\n\tshared_ptr<Geom3Curve> fu = surface->UIso(fpu);\n\tshared_ptr<Geom3Curve> fv = surface->VIso(fpv);\n\tshared_ptr<Geom3Curve> lu = surface->UIso(lpu);\n\tshared_ptr<Geom3Curve> lv = surface->VIso(lpv);\n\tauto plane = std::make_shared<Geom3Plane>(Point3(0.0, 0.0, -5.3), Direction3(0.0, 0.0, 1.0));\n\tauto planevf = NURBSAPIExtend::ExtendSurfPerpendicularToPlane(surface, false, true, plane);\n\tshared_ptr<Geom3TrimmedSurface>trimSurf = std::make_shared<Geom3TrimmedSurface>(plane, -10.0, 10.0, -10.0, 10.0);\n\tshared_ptr<Geom3BSplineSurface> bspSurf2 = NURBSAPIConvert::ToBSpline(planevf);\n\tCHECK(bspSurf2->UDegree() == udeg);\n\tCHECK(bspSurf2->VDegree() == vdeg);\n\tCHECK(bspSurf2->NUPoles() == upNum);\n\tCHECK(bspSurf2->NVPoles() == (vpNum + 1));\n\tCHECK(bspSurf2->NUKnots() == ukNum);\n\tCHECK(bspSurf2->NVKnots() == (vkNum + 1));\n\tdouble fpv2 = planevf->FirstVParameter();\n\tshared_ptr<Geom3Curve> fv2 = planevf->VIso(fpv2);\n\tbool res2 = IsCurveOnSurf(num, ratio, fv2, plane, -1.0);\n\tCHECK(res2 == true);\n\tOCCTIO::OCCTTool::Write(MakeFace(trimSurf, 0.0), outdir + \"trimSurf.brep\");\n\tOCCTIO::OCCTTool::Write(MakeFace(surface, 0.0), outdir + \"src.brep\");\n\tOCCTIO::OCCTTool::Write(MakeFace(planevf, 0.0), outdir + \"result.brep\");\n;\n\tSECTION(\"ExtendSurfByAverageLength3\")\n\t{\n\t\tOUTPUT_DIRECTORY(nurbs, Extend/bug614/ExtendSurfByAverageLength3);\n\t\tauto lengthvf = NURBSAPIExtend::ExtendSurfByAverageLength(surface, false, true, len);\n\t\tshared_ptr<Geom3BSplineSurface> bspSurf2 = NURBSAPIConvert::ToBSpline(lengthvf);\n\t\tCHECK(bspSurf2->VDegree() == vdeg);\n\t\tCHECK(bspSurf2->NVPoles() == vpNum);\n\t\tCHECK(bspSurf2->NVKnots() == vkNum);\n\t\tdouble fpv1 = lengthvf->FirstVParameter();\n\t\tshared_ptr<Geom3Curve> fv1 = lengthvf->VIso(fpv1);\n\t\tOCCTIO::OCCTTool::Write(MakeEdge(fv), outdir + \"curve1.brep\");\n\t\tOCCTIO::OCCTTool::Write(MakeEdge(fv1), outdir + \"curve2.brep\");\n\t\tOCCTIO::OCCTTool::Write(MakeFace(surface, 0.0), outdir + \"src.brep\");\n\t\tOCCTIO::OCCTTool::Write(MakeFace(lengthvf, 0.0), outdir + \"result.brep\");\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static std::shared_ptr<Geom3Surface> ExtendSurfToPoint(const std::shared_ptr<Geom3Surface>& surf, bool isU, bool isFront, const Point3& pt)\t @return New surface\n\t @param pt Point\n\t @param isFront Extend front or back\n\t @param isU Extend u or v\n\t @param surf Surface\n\t The degree of the surface, the size of the extended direction (u or v) knots and poles are not changed.\n\t The original surface is part of new surface.\n\t @brief Extend surface to a point.\n,\n",
      "output": "﻿#include<catch.hpp>\n#include<testHelper.h>\n#include <nurbs/NURBSAPIExtend.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <modeling/MakeFace.hpp>\n#include <topology/BRepExtremaDistShapeShape.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/Geom3Plane.hpp>\n#include <geometry/Geom3TrimmedSurface.hpp>\n#include <nurbs/NURBSAPIConvert.hpp>\n#include <nurbs/NURBSAPIBuildCurve.hpp>\n#include <geomAlgo/LawBSpline.hpp>\n#include <offset/MakePipe.hpp>\n#include <modeling/MakeWire.hpp>\n#include <topology/TopoTool.hpp>\n#include <topology/TopoExplorerTool.hpp>\n#include <geometry/GeomAPIProjectPointOnCurve3.hpp>\n#include <geometry/GeomAPIProjectPointOnSurface.hpp>\ndouble NurbsExtendSample(int num, double len, double tol, const shared_ptr<Geom3Curve>& curve1, const shared_ptr<Geom3Curve>& curve2)\n{\n\tconst int nsample = num;\n\tdouble fp1 = curve1->FirstParameter();\n\tdouble lp1 = curve1->LastParameter();\n\tdouble delta1 = (lp1 - fp1) / nsample;\n\tPoint3 p;\n\tint n = 0;\n\tfor (int i = 0; i < nsample; i++)\n\t{\n\t\tdouble t1 = fp1 + i * delta1;\n\t\tcurve1->D0(t1, p);\n\t\tTopoVertex vt = MakeVertex(p);\n\t\tTopoEdge edge = MakeEdge(curve2);\n\t\tBRepExtremaDistShapeShape dist(vt, edge);\n\t\tdouble dis = abs(dist.Value() - len);\n\t\tif (dis <= tol)\n\t\t{\n\t\t\tn++;\n\t\t}\n\t}\n\tdouble res = 1.0 * (num - n) / num;\n\treturn res;\n}\nshared_ptr<Geom3Surface> ConstructExtendSurface()\n{\n\tstd::vector<Point3> profilePoles;\n\tstd::vector<double> profileKnots(3);\n\tstd::vector<int> profileMults(3, 1);\n\tprofilePoles.push_back(Point3(0.0, 0.0, 0.0));\n\tprofilePoles.push_back(Point3(1.0, -0.2, 0.0));\n\tprofilePoles.push_back(Point3(2.0, 0.1, 0.0));\n\tprofilePoles.push_back(Point3(2.3, -0.1, 0.0));\n\tprofilePoles.push_back(Point3(2.9, 0.1, 0.0));\n\tprofileKnots[0] = 0;\n\tprofileKnots[1] = 0.5;\n\tprofileKnots[2] = 1;\n\tprofileMults.front() = 4;\n\tprofileMults.back() = 4;\n\tstd::shared_ptr<Geom3BSplineCurve> profile = std::make_shared<Geom3BSplineCurve>(profilePoles, profileKnots, profileMults, 3);\n\tstd::vector<Point3> spinePoles;\n\tstd::vector<double> spineKnots(4);\n\tstd::vector<int> spineMults(4, 1);\n\tspinePoles.push_back(Point3(0.0, 0.0, 0.0));\n\tspinePoles.push_back(Point3(0.0, 0.0, 1.0));\n\tspinePoles.push_back(Point3(0.0, 0.2, 1.5));\n\tspinePoles.push_back(Point3(0.0, 0.5, 2.0));\n\tspinePoles.push_back(Point3(0.0, 1.0, 2.3));\n\tspinePoles.push_back(Point3(0.0, 1.6, 2.3));\n\tspineKnots[0] = 0;\n\tspineKnots[1] = 1.0 / 3.0;\n\tspineKnots[2] = 2.0 / 3.0;\n\tspineKnots[3] = 1;\n\tspineMults.front() = 4;\n\tspineMults.back() = 4;\n\tstd::shared_ptr<Geom3BSplineCurve> spine = std::make_shared<Geom3BSplineCurve>(spinePoles, spineKnots, spineMults, 3);\n\tTopoShape pipe = MakePipe(MakeWire(MakeEdge(spine)), MakeWire(MakeEdge(profile))).Shape();\n\tTopoExplorer ex(pipe, ShapeType::Face);\n\tstd::shared_ptr<Geom3Surface> surface = TopoTool::Surface(static_cast<const TopoFace&>(ex.Current()));\n\treturn surface;\n}\nshared_ptr<Geom3Surface> ConstructExtendPeriodicSurf()\n{\n\tstd::vector<Point3> profilePoles;\n\tprofilePoles.push_back(Point3(0.0, 0.0, 0.0));\n\tprofilePoles.push_back(Point3(1.0, -1.0, 0.0));\n\tprofilePoles.push_back(Point3(2.0, -1.5, 0.0));\n\tprofilePoles.push_back(Point3(2.3, -1.0, 0.0));\n\tprofilePoles.push_back(Point3(2.9, 0.0, 0.0));\n\tprofilePoles.push_back(Point3(2.3, 0.9, 0.0));\n\tprofilePoles.push_back(Point3(2.1, 1.6, 0.0));\n\tprofilePoles.push_back(Point3(1.0, 1.0, 0.0));\n\tstd::vector<double> profileKnots(profilePoles.size() + 1);\n\tfor (int i = 0; i < static_cast<int>(profileKnots.size()); i++)\n\t{\n\t\tprofileKnots[i] = (double)i / (double)(profilePoles.size());\n\t}\n\tprofileKnots[1] += 1.0 / (double)(3 * profilePoles.size());\n\tstd::vector<int> profileMults(profileKnots.size(), 1);\n\tstd::shared_ptr<Geom3BSplineCurve> profile = std::make_shared<Geom3BSplineCurve>(profilePoles, profileKnots, profileMults, 3, true);\n\tstd::vector<Point3> spinePoles;\n\tstd::vector<double> spineKnots(4);\n\tstd::vector<int> spineMults(4, 1);\n\tspinePoles.push_back(Point3(0.0, 0.0, 0.0));\n\tspinePoles.push_back(Point3(0.0, 0.0, 1.0));\n\tspinePoles.push_back(Point3(0.0, 0.2, 1.5));\n\tspinePoles.push_back(Point3(0.0, 0.5, 2.0));\n\tspinePoles.push_back(Point3(0.0, 1.0, 2.3));\n\tspinePoles.push_back(Point3(0.0, 1.6, 2.3));\n\tspineKnots[0] = 0;\n\tspineKnots[1] = 1.0 / 3.0;\n\tspineKnots[2] = 2.0 / 3.0;\n\tspineKnots[3] = 1;\n\tspineMults.front() = 4;\n\tspineMults.back() = 4;\n\tstd::shared_ptr<Geom3BSplineCurve> spine = std::make_shared<Geom3BSplineCurve>(spinePoles, spineKnots, spineMults, 3);\n\tTopoShape pipe = MakePipe(MakeWire(MakeEdge(spine)), MakeWire(MakeEdge(profile))).Shape();\n\tTopoExplorer ex(pipe, ShapeType::Face);\n\tstd::shared_ptr<Geom3Surface> surface = TopoTool::Surface(static_cast<const TopoFace&>(ex.Current()));\n\treturn surface;\n}\nTEST_CASE(\"bug2:ExtendPeriodicSurf \", \"[nurbs][Extend][fixbug]\")\n{\n\tOUTPUT_DIRECTORY(nurbs, Extend/bug612);\n\tint num = 1000;\n\tdouble tol = 1e-4;\n\tdouble ratio = 0.01;\n\tdouble refTol = DEFAULT_TOLERANCE;\n\tstd::vector<Point3> profilePoles;\n\tprofilePoles.push_back(Point3(0.0, 0.0, 0.0));\n\tprofilePoles.push_back(Point3(1.0, -1.0, 0.0));\n\tprofilePoles.push_back(Point3(2.0, -1.5, 0.0));\n\tprofilePoles.push_back(Point3(2.3, -1.0, 0.0));\n\tprofilePoles.push_back(Point3(2.9, 0.0, 0.0));\n\tprofilePoles.push_back(Point3(2.3, 0.9, 0.0));\n\tprofilePoles.push_back(Point3(2.1, 1.6, 0.0));\n\tprofilePoles.push_back(Point3(1.0, 1.0, 0.0));\n\tstd::vector<double> profileKnots(profilePoles.size() + 1);\n\tfor (int i = 0; i < static_cast<int>(profileKnots.size()); i++)\n\t{\n\t\tprofileKnots[i] = (double)i / (double)(profilePoles.size());\n\t}\n\tprofileKnots[1] += 1.0 / (double)(3 * profilePoles.size());\n\tstd::vector<int> profileMults(profileKnots.size(), 1);\n\tstd::shared_ptr<Geom3BSplineCurve> profile = std::make_shared<Geom3BSplineCurve>(profilePoles, profileKnots, profileMults, 3, true);\n\tstd::vector<Point3> spinePoles;\n\tstd::vector<double> spineKnots(4);\n\tstd::vector<int> spineMults(4, 1);\n\tspinePoles.push_back(Point3(0.0, 0.0, 0.0));\n\tspinePoles.push_back(Point3(0.0, 0.0, 1.0));\n\tspinePoles.push_back(Point3(0.0, 0.2, 1.5));\n\tspinePoles.push_back(Point3(0.0, 0.5, 2.0));\n\tspinePoles.push_back(Point3(0.0, 1.0, 2.3));\n\tspinePoles.push_back(Point3(0.0, 1.6, 2.3));\n\tspineKnots[0] = 0;\n\tspineKnots[1] = 1.0 / 3.0;\n\tspineKnots[2] = 2.0 / 3.0;\n\tspineKnots[3] = 1;\n\tspineMults.front() = 4;\n\tspineMults.back() = 4;\n\tstd::shared_ptr<Geom3BSplineCurve> spine = std::make_shared<Geom3BSplineCurve>(spinePoles, spineKnots, spineMults, 3);\n\tTopoShape pipe = MakePipe(MakeWire(MakeEdge(spine)), MakeWire(MakeEdge(profile))).Shape();\n\tTopoExplorer ex(pipe, ShapeType::Face);\n\tstd::shared_ptr<Geom3Surface> surface = TopoTool::Surface(static_cast<const TopoFace&>(ex.Current()));\n\tshared_ptr<Geom3BSplineSurface> bspSurf = NURBSAPIConvert::ToBSpline(surface);\n\tint udeg = bspSurf->UDegree();\n\tint vdeg = bspSurf->VDegree();\n\tint upNum = bspSurf->NUPoles();\n\tint vpNum = bspSurf->NVPoles();\n\tint ukNum = bspSurf->NUKnots();\n\tint vkNum = bspSurf->NVKnots();\n\tdouble fpu = surface->FirstUParameter();\n\tdouble fpv = surface->FirstVParameter();\n\tdouble lpu = surface->LastUParameter();\n\tdouble lpv = surface->LastVParameter();\n\tshared_ptr<Geom3Curve> fu = surface->UIso(fpu);\n\tshared_ptr<Geom3Curve> fv = surface->VIso(fpv);\n\tshared_ptr<Geom3Curve> lu = surface->UIso(lpu);\n\tshared_ptr<Geom3Curve> lv = surface->VIso(lpv);\n\tauto plane = std::make_shared<Geom3Plane>(Point3(0.0, 0.0, -5.3), Direction3(0.0, 0.0, 1.0));\n\tauto planevf = NURBSAPIExtend::ExtendSurfPerpendicularToPlane(surface, false, true, plane);\n\tshared_ptr<Geom3TrimmedSurface>trimSurf = std::make_shared<Geom3TrimmedSurface>(plane, -10.0, 10.0, -10.0, 10.0);\n\tshared_ptr<Geom3BSplineSurface> bspSurf2 = NURBSAPIConvert::ToBSpline(planevf);\n\tCHECK(bspSurf2->UDegree() == udeg);\n\tCHECK(bspSurf2->VDegree() == vdeg);\n\tCHECK(bspSurf2->NUPoles() == upNum);\n\tCHECK(bspSurf2->NVPoles() == (vpNum + 1));\n\tCHECK(bspSurf2->NUKnots() == ukNum);\n\tCHECK(bspSurf2->NVKnots() == (vkNum + 1));\n\tdouble fpv2 = planevf->FirstVParameter();\n\tshared_ptr<Geom3Curve> fv2 = planevf->VIso(fpv2);\n\tbool res2 = IsCurveOnSurf(num, ratio, fv2, plane, -1.0);\n\tCHECK(res2 == true);\n\tOCCTIO::OCCTTool::Write(MakeFace(trimSurf, 0.0), outdir + \"trimSurf.brep\");\n\tOCCTIO::OCCTTool::Write(MakeFace(surface, 0.0), outdir + \"src.brep\");\n\tOCCTIO::OCCTTool::Write(MakeFace(planevf, 0.0), outdir + \"result.brep\");\n;\n\tSECTION(\"ExtendSurfToPoint3\")\n\t{\n\t\tOUTPUT_DIRECTORY(nurbs, Extend/bug614/ExtendSurfToPoint3);\n\t\tPoint3 target(1.0, -0.2, -0.2);\n\t\tauto pointvf = NURBSAPIExtend::ExtendSurfToPoint(surface, false, true, target);\n\t\tshared_ptr<Geom3BSplineSurface> bspSurf2 = NURBSAPIConvert::ToBSpline(pointvf);\n\t\tCHECK(bspSurf2->VDegree() == vdeg);\n\t\tCHECK(bspSurf2->NVPoles() == vpNum);\n\t\tCHECK(bspSurf2->NVKnots() == vkNum);\n\t\tdouble fpv1 = pointvf->FirstVParameter();\n\t\tshared_ptr<Geom3Curve> fv1 = pointvf->VIso(fpv1);\n\t\tOCCTIO::OCCTTool::Write(MakeEdge(fv), outdir + \"curve1.brep\");\n\t\tOCCTIO::OCCTTool::Write(MakeEdge(fv1), outdir + \"curve2.brep\");\n\t\tOCCTIO::OCCTTool::Write(MakeVertex(target), outdir + \"refp.brep\");\n\t\tOCCTIO::OCCTTool::Write(MakeFace(surface, 0.0), outdir + \"src.brep\");\n\t\tOCCTIO::OCCTTool::Write(MakeFace(pointvf, 0.0), outdir + \"result.brep\");\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static std::shared_ptr<Geom3Curve> ExtendCurveToPoint(const std::shared_ptr<Geom3Curve>& curve, bool isFront, const Point3& pt)\t @return New curve\n\t @param pt Point\n\t @param isFront Extend front or back\n\t @param curve Curve\n\t The degree and the number of poles and knots are not changed.\n\t The original curve is part of new curve.\n\t @brief Extend curve to a point.\n,\n",
      "output": "﻿#include<catch.hpp>\n#include<testHelper.h>\n#include <nurbs/NURBSAPIExtend.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <modeling/MakeFace.hpp>\n#include <topology/BRepExtremaDistShapeShape.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/Geom3Plane.hpp>\n#include <geometry/Geom3TrimmedSurface.hpp>\n#include <nurbs/NURBSAPIConvert.hpp>\n#include <nurbs/NURBSAPIBuildCurve.hpp>\n#include <geomAlgo/LawBSpline.hpp>\n#include <offset/MakePipe.hpp>\n#include <modeling/MakeWire.hpp>\n#include <topology/TopoTool.hpp>\n#include <topology/TopoExplorerTool.hpp>\n#include <geometry/GeomAPIProjectPointOnCurve3.hpp>\n#include <geometry/GeomAPIProjectPointOnSurface.hpp>\ndouble NurbsExtendSample(int num, double len, double tol, const shared_ptr<Geom3Curve>& curve1, const shared_ptr<Geom3Curve>& curve2)\n{\n\tconst int nsample = num;\n\tdouble fp1 = curve1->FirstParameter();\n\tdouble lp1 = curve1->LastParameter();\n\tdouble delta1 = (lp1 - fp1) / nsample;\n\tPoint3 p;\n\tint n = 0;\n\tfor (int i = 0; i < nsample; i++)\n\t{\n\t\tdouble t1 = fp1 + i * delta1;\n\t\tcurve1->D0(t1, p);\n\t\tTopoVertex vt = MakeVertex(p);\n\t\tTopoEdge edge = MakeEdge(curve2);\n\t\tBRepExtremaDistShapeShape dist(vt, edge);\n\t\tdouble dis = abs(dist.Value() - len);\n\t\tif (dis <= tol)\n\t\t{\n\t\t\tn++;\n\t\t}\n\t}\n\tdouble res = 1.0 * (num - n) / num;\n\treturn res;\n}\nshared_ptr<Geom3Surface> ConstructExtendSurface()\n{\n\tstd::vector<Point3> profilePoles;\n\tstd::vector<double> profileKnots(3);\n\tstd::vector<int> profileMults(3, 1);\n\tprofilePoles.push_back(Point3(0.0, 0.0, 0.0));\n\tprofilePoles.push_back(Point3(1.0, -0.2, 0.0));\n\tprofilePoles.push_back(Point3(2.0, 0.1, 0.0));\n\tprofilePoles.push_back(Point3(2.3, -0.1, 0.0));\n\tprofilePoles.push_back(Point3(2.9, 0.1, 0.0));\n\tprofileKnots[0] = 0;\n\tprofileKnots[1] = 0.5;\n\tprofileKnots[2] = 1;\n\tprofileMults.front() = 4;\n\tprofileMults.back() = 4;\n\tstd::shared_ptr<Geom3BSplineCurve> profile = std::make_shared<Geom3BSplineCurve>(profilePoles, profileKnots, profileMults, 3);\n\tstd::vector<Point3> spinePoles;\n\tstd::vector<double> spineKnots(4);\n\tstd::vector<int> spineMults(4, 1);\n\tspinePoles.push_back(Point3(0.0, 0.0, 0.0));\n\tspinePoles.push_back(Point3(0.0, 0.0, 1.0));\n\tspinePoles.push_back(Point3(0.0, 0.2, 1.5));\n\tspinePoles.push_back(Point3(0.0, 0.5, 2.0));\n\tspinePoles.push_back(Point3(0.0, 1.0, 2.3));\n\tspinePoles.push_back(Point3(0.0, 1.6, 2.3));\n\tspineKnots[0] = 0;\n\tspineKnots[1] = 1.0 / 3.0;\n\tspineKnots[2] = 2.0 / 3.0;\n\tspineKnots[3] = 1;\n\tspineMults.front() = 4;\n\tspineMults.back() = 4;\n\tstd::shared_ptr<Geom3BSplineCurve> spine = std::make_shared<Geom3BSplineCurve>(spinePoles, spineKnots, spineMults, 3);\n\tTopoShape pipe = MakePipe(MakeWire(MakeEdge(spine)), MakeWire(MakeEdge(profile))).Shape();\n\tTopoExplorer ex(pipe, ShapeType::Face);\n\tstd::shared_ptr<Geom3Surface> surface = TopoTool::Surface(static_cast<const TopoFace&>(ex.Current()));\n\treturn surface;\n}\nshared_ptr<Geom3Surface> ConstructExtendPeriodicSurf()\n{\n\tstd::vector<Point3> profilePoles;\n\tprofilePoles.push_back(Point3(0.0, 0.0, 0.0));\n\tprofilePoles.push_back(Point3(1.0, -1.0, 0.0));\n\tprofilePoles.push_back(Point3(2.0, -1.5, 0.0));\n\tprofilePoles.push_back(Point3(2.3, -1.0, 0.0));\n\tprofilePoles.push_back(Point3(2.9, 0.0, 0.0));\n\tprofilePoles.push_back(Point3(2.3, 0.9, 0.0));\n\tprofilePoles.push_back(Point3(2.1, 1.6, 0.0));\n\tprofilePoles.push_back(Point3(1.0, 1.0, 0.0));\n\tstd::vector<double> profileKnots(profilePoles.size() + 1);\n\tfor (int i = 0; i < static_cast<int>(profileKnots.size()); i++)\n\t{\n\t\tprofileKnots[i] = (double)i / (double)(profilePoles.size());\n\t}\n\tprofileKnots[1] += 1.0 / (double)(3 * profilePoles.size());\n\tstd::vector<int> profileMults(profileKnots.size(), 1);\n\tstd::shared_ptr<Geom3BSplineCurve> profile = std::make_shared<Geom3BSplineCurve>(profilePoles, profileKnots, profileMults, 3, true);\n\tstd::vector<Point3> spinePoles;\n\tstd::vector<double> spineKnots(4);\n\tstd::vector<int> spineMults(4, 1);\n\tspinePoles.push_back(Point3(0.0, 0.0, 0.0));\n\tspinePoles.push_back(Point3(0.0, 0.0, 1.0));\n\tspinePoles.push_back(Point3(0.0, 0.2, 1.5));\n\tspinePoles.push_back(Point3(0.0, 0.5, 2.0));\n\tspinePoles.push_back(Point3(0.0, 1.0, 2.3));\n\tspinePoles.push_back(Point3(0.0, 1.6, 2.3));\n\tspineKnots[0] = 0;\n\tspineKnots[1] = 1.0 / 3.0;\n\tspineKnots[2] = 2.0 / 3.0;\n\tspineKnots[3] = 1;\n\tspineMults.front() = 4;\n\tspineMults.back() = 4;\n\tstd::shared_ptr<Geom3BSplineCurve> spine = std::make_shared<Geom3BSplineCurve>(spinePoles, spineKnots, spineMults, 3);\n\tTopoShape pipe = MakePipe(MakeWire(MakeEdge(spine)), MakeWire(MakeEdge(profile))).Shape();\n\tTopoExplorer ex(pipe, ShapeType::Face);\n\tstd::shared_ptr<Geom3Surface> surface = TopoTool::Surface(static_cast<const TopoFace&>(ex.Current()));\n\treturn surface;\n}\nTEST_CASE(\"bug7: ExtendPeriodicSurf3 \", \"[nurbs][Extend][fixbug]\")\n{\n\tOUTPUT_DIRECTORY(nurbs, Extend/bug689/ExtendPeriodicSurf3);\n\tshared_ptr<Geom3Surface> surface = ConstructExtendPeriodicSurf();\n\tauto plane = std::make_shared<Geom3Plane>(Point3(0.0, 0.0, -5.3), Direction3(0.0, 0.0, 1.0));\n\tauto planevf = NURBSAPIExtend::ExtendSurfPerpendicularToPlane(surface, false, true, plane);\n\tshared_ptr<Geom3TrimmedSurface>trimSurf = std::make_shared<Geom3TrimmedSurface>(plane, -10.0, 10.0, -10.0, 10.0);\n\tdouble fpv1 = planevf->FirstUParameter();\n\tshared_ptr<Geom3Curve> fv1 = planevf->UIso(fpv1);\n\tPoint3 p1;\n\tVector3 vec;\n\tdouble fs = fv1->FirstParameter();\n\tfv1->D1(fs, p1, vec);\n\tAxis3 axis = plane->Axis();\n\tbool res = axis.Direction().IsParallel(Direction3(vec), Precision::Angular());\n\tCHECK(res == true);\n\tOCCTIO::OCCTTool::Write(MakeEdge(fv1), outdir + \"curve2.brep\");\n\tOCCTIO::OCCTTool::Write(MakeFace(trimSurf, 0.0), outdir + \"trimSurf.brep\");\n\tOCCTIO::OCCTTool::Write(MakeFace(surface, 0.0), outdir + \"src.brep\");\n\tOCCTIO::OCCTTool::Write(MakeFace(planevf, 0.0), outdir + \"result.brep\");\n;\n\tSECTION(\"TestExtendCurveToPoint\")\n\t{\n\t\tOUTPUT_DIRECTORY(nurbs, Extend/ExtendCurve/ExtendCurveToPoint);\n\t\tPoint3 target(-3.0, -2.0, 0.0);\n\t\tauto n3bsp = NURBSAPIExtend::ExtendCurveToPoint(bsp, true, target);\n\t\tshared_ptr<Geom3BSplineCurve> bspCurve = NURBSAPIConvert::ToBSpline(n3bsp);\n\t\tCHECK(bspCurve->Degree() == degree);\n\t\tCHECK(bspCurve->NPoles() == pNum);\n\t\tCHECK(bspCurve->NKnots() == kNum);\n\t\tdouble fp1 = n3bsp->FirstParameter();\n\t\tdouble lp1 = n3bsp->LastParameter();\n\t\tPoint3 p1 = n3bsp->Value(fp1);\n\t\tPoint3 p2 = n3bsp->Value(lp1);\n\t\tCHECK(abs(p1.X() - target.X()) <= distTol);\n\t\tCHECK(abs(p1.Y() - target.Y()) <= distTol);\n\t\tCHECK(abs(p1.Z() - target.Z()) <= distTol);\n\t\tCHECK(p2.X() == ep.X());\n\t\tCHECK(p2.Y() == ep.Y());\n\t\tCHECK(p2.Z() == ep.Z());\n\t\tOCCTIO::OCCTTool::Write(MakeVertex(sp), outdir + \"sp.brep\");\n\t\tOCCTIO::OCCTTool::Write(MakeVertex(ep), outdir + \"ep.brep\");\n\t\tOCCTIO::OCCTTool::Write(MakeVertex(p1), outdir + \"p1.brep\");\n\t\tOCCTIO::OCCTTool::Write(MakeVertex(p2), outdir + \"p2.brep\");\n\t\tOCCTIO::OCCTTool::Write(MakeEdge(bsp), outdir + \"src.brep\");\n\t\tOCCTIO::OCCTTool::Write(MakeVertex(target), outdir + \"target.brep\");\n\t\tOCCTIO::OCCTTool::Write(MakeEdge(n3bsp), outdir + \"result.brep\");\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static std::shared_ptr<Geom3Curve> ExtendCurveToDynamicPoint(const std::shared_ptr<Geom3Curve>& curve, bool isFront, const Point3& pt)\t @return New curve\n\t @param pt Point\n\t @param isFront Extend front or back\n\t @param curve Curve\n\t The degree is not changed but the number of poles and knots increase 1.\n\t The original curve is part of new curve.\n\t @brief Extend curve to a point.\n,\n",
      "output": "﻿#include<catch.hpp>\n#include<testHelper.h>\n#include <nurbs/NURBSAPIExtend.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <modeling/MakeFace.hpp>\n#include <topology/BRepExtremaDistShapeShape.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/Geom3Plane.hpp>\n#include <geometry/Geom3TrimmedSurface.hpp>\n#include <nurbs/NURBSAPIConvert.hpp>\n#include <nurbs/NURBSAPIBuildCurve.hpp>\n#include <geomAlgo/LawBSpline.hpp>\n#include <offset/MakePipe.hpp>\n#include <modeling/MakeWire.hpp>\n#include <topology/TopoTool.hpp>\n#include <topology/TopoExplorerTool.hpp>\n#include <geometry/GeomAPIProjectPointOnCurve3.hpp>\n#include <geometry/GeomAPIProjectPointOnSurface.hpp>\ndouble NurbsExtendSample(int num, double len, double tol, const shared_ptr<Geom3Curve>& curve1, const shared_ptr<Geom3Curve>& curve2)\n{\n\tconst int nsample = num;\n\tdouble fp1 = curve1->FirstParameter();\n\tdouble lp1 = curve1->LastParameter();\n\tdouble delta1 = (lp1 - fp1) / nsample;\n\tPoint3 p;\n\tint n = 0;\n\tfor (int i = 0; i < nsample; i++)\n\t{\n\t\tdouble t1 = fp1 + i * delta1;\n\t\tcurve1->D0(t1, p);\n\t\tTopoVertex vt = MakeVertex(p);\n\t\tTopoEdge edge = MakeEdge(curve2);\n\t\tBRepExtremaDistShapeShape dist(vt, edge);\n\t\tdouble dis = abs(dist.Value() - len);\n\t\tif (dis <= tol)\n\t\t{\n\t\t\tn++;\n\t\t}\n\t}\n\tdouble res = 1.0 * (num - n) / num;\n\treturn res;\n}\nshared_ptr<Geom3Surface> ConstructExtendSurface()\n{\n\tstd::vector<Point3> profilePoles;\n\tstd::vector<double> profileKnots(3);\n\tstd::vector<int> profileMults(3, 1);\n\tprofilePoles.push_back(Point3(0.0, 0.0, 0.0));\n\tprofilePoles.push_back(Point3(1.0, -0.2, 0.0));\n\tprofilePoles.push_back(Point3(2.0, 0.1, 0.0));\n\tprofilePoles.push_back(Point3(2.3, -0.1, 0.0));\n\tprofilePoles.push_back(Point3(2.9, 0.1, 0.0));\n\tprofileKnots[0] = 0;\n\tprofileKnots[1] = 0.5;\n\tprofileKnots[2] = 1;\n\tprofileMults.front() = 4;\n\tprofileMults.back() = 4;\n\tstd::shared_ptr<Geom3BSplineCurve> profile = std::make_shared<Geom3BSplineCurve>(profilePoles, profileKnots, profileMults, 3);\n\tstd::vector<Point3> spinePoles;\n\tstd::vector<double> spineKnots(4);\n\tstd::vector<int> spineMults(4, 1);\n\tspinePoles.push_back(Point3(0.0, 0.0, 0.0));\n\tspinePoles.push_back(Point3(0.0, 0.0, 1.0));\n\tspinePoles.push_back(Point3(0.0, 0.2, 1.5));\n\tspinePoles.push_back(Point3(0.0, 0.5, 2.0));\n\tspinePoles.push_back(Point3(0.0, 1.0, 2.3));\n\tspinePoles.push_back(Point3(0.0, 1.6, 2.3));\n\tspineKnots[0] = 0;\n\tspineKnots[1] = 1.0 / 3.0;\n\tspineKnots[2] = 2.0 / 3.0;\n\tspineKnots[3] = 1;\n\tspineMults.front() = 4;\n\tspineMults.back() = 4;\n\tstd::shared_ptr<Geom3BSplineCurve> spine = std::make_shared<Geom3BSplineCurve>(spinePoles, spineKnots, spineMults, 3);\n\tTopoShape pipe = MakePipe(MakeWire(MakeEdge(spine)), MakeWire(MakeEdge(profile))).Shape();\n\tTopoExplorer ex(pipe, ShapeType::Face);\n\tstd::shared_ptr<Geom3Surface> surface = TopoTool::Surface(static_cast<const TopoFace&>(ex.Current()));\n\treturn surface;\n}\nshared_ptr<Geom3Surface> ConstructExtendPeriodicSurf()\n{\n\tstd::vector<Point3> profilePoles;\n\tprofilePoles.push_back(Point3(0.0, 0.0, 0.0));\n\tprofilePoles.push_back(Point3(1.0, -1.0, 0.0));\n\tprofilePoles.push_back(Point3(2.0, -1.5, 0.0));\n\tprofilePoles.push_back(Point3(2.3, -1.0, 0.0));\n\tprofilePoles.push_back(Point3(2.9, 0.0, 0.0));\n\tprofilePoles.push_back(Point3(2.3, 0.9, 0.0));\n\tprofilePoles.push_back(Point3(2.1, 1.6, 0.0));\n\tprofilePoles.push_back(Point3(1.0, 1.0, 0.0));\n\tstd::vector<double> profileKnots(profilePoles.size() + 1);\n\tfor (int i = 0; i < static_cast<int>(profileKnots.size()); i++)\n\t{\n\t\tprofileKnots[i] = (double)i / (double)(profilePoles.size());\n\t}\n\tprofileKnots[1] += 1.0 / (double)(3 * profilePoles.size());\n\tstd::vector<int> profileMults(profileKnots.size(), 1);\n\tstd::shared_ptr<Geom3BSplineCurve> profile = std::make_shared<Geom3BSplineCurve>(profilePoles, profileKnots, profileMults, 3, true);\n\tstd::vector<Point3> spinePoles;\n\tstd::vector<double> spineKnots(4);\n\tstd::vector<int> spineMults(4, 1);\n\tspinePoles.push_back(Point3(0.0, 0.0, 0.0));\n\tspinePoles.push_back(Point3(0.0, 0.0, 1.0));\n\tspinePoles.push_back(Point3(0.0, 0.2, 1.5));\n\tspinePoles.push_back(Point3(0.0, 0.5, 2.0));\n\tspinePoles.push_back(Point3(0.0, 1.0, 2.3));\n\tspinePoles.push_back(Point3(0.0, 1.6, 2.3));\n\tspineKnots[0] = 0;\n\tspineKnots[1] = 1.0 / 3.0;\n\tspineKnots[2] = 2.0 / 3.0;\n\tspineKnots[3] = 1;\n\tspineMults.front() = 4;\n\tspineMults.back() = 4;\n\tstd::shared_ptr<Geom3BSplineCurve> spine = std::make_shared<Geom3BSplineCurve>(spinePoles, spineKnots, spineMults, 3);\n\tTopoShape pipe = MakePipe(MakeWire(MakeEdge(spine)), MakeWire(MakeEdge(profile))).Shape();\n\tTopoExplorer ex(pipe, ShapeType::Face);\n\tstd::shared_ptr<Geom3Surface> surface = TopoTool::Surface(static_cast<const TopoFace&>(ex.Current()));\n\treturn surface;\n}\nTEST_CASE(\"bug7: ExtendPeriodicSurf3 \", \"[nurbs][Extend][fixbug]\")\n{\n\tOUTPUT_DIRECTORY(nurbs, Extend/bug689/ExtendPeriodicSurf3);\n\tshared_ptr<Geom3Surface> surface = ConstructExtendPeriodicSurf();\n\tauto plane = std::make_shared<Geom3Plane>(Point3(0.0, 0.0, -5.3), Direction3(0.0, 0.0, 1.0));\n\tauto planevf = NURBSAPIExtend::ExtendSurfPerpendicularToPlane(surface, false, true, plane);\n\tshared_ptr<Geom3TrimmedSurface>trimSurf = std::make_shared<Geom3TrimmedSurface>(plane, -10.0, 10.0, -10.0, 10.0);\n\tdouble fpv1 = planevf->FirstUParameter();\n\tshared_ptr<Geom3Curve> fv1 = planevf->UIso(fpv1);\n\tPoint3 p1;\n\tVector3 vec;\n\tdouble fs = fv1->FirstParameter();\n\tfv1->D1(fs, p1, vec);\n\tAxis3 axis = plane->Axis();\n\tbool res = axis.Direction().IsParallel(Direction3(vec), Precision::Angular());\n\tCHECK(res == true);\n\tOCCTIO::OCCTTool::Write(MakeEdge(fv1), outdir + \"curve2.brep\");\n\tOCCTIO::OCCTTool::Write(MakeFace(trimSurf, 0.0), outdir + \"trimSurf.brep\");\n\tOCCTIO::OCCTTool::Write(MakeFace(surface, 0.0), outdir + \"src.brep\");\n\tOCCTIO::OCCTTool::Write(MakeFace(planevf, 0.0), outdir + \"result.brep\");\n;\n\tSECTION(\"TestExtendDynamic\")\n\t{\n\t\tOUTPUT_DIRECTORY(nurbs, Extend/bug711/ExtendDynamic);\n\t\tint num = 1000;\n\t\tdouble ratio = 0.1;\n\t\tdouble refTol = DEFAULT_TOLERANCE;\n\t\tint refDeg = INCREASE_DEGREE;\n\t\tauto src2 = ReadBRepCurve(INPUT_PATH_PREFIX\"/TestNURBS/TestExtendDynamic/src2.brep\");\n\t\tauto targetPoint2 = ReadBRepPoint(INPUT_PATH_PREFIX\"/TestNURBS/TestExtendDynamic/target2.brep\");\n\t\tLawBSpline srcw2(src2->Weights(), src2->Knots(), src2->Multiplicities(), src2->Degree(), src2->IsPeriodic());\n\t\tdouble src2weight, src2dw, src2dw2;\n\t\tdouble t2 = src2->FirstParameter() + 0.01;\n\t\tsrcw2.D2(t2, src2weight, src2dw, src2dw2);\n\t\tshared_ptr<Geom3BSplineCurve> src2Inc = std::dynamic_pointer_cast<Geom3BSplineCurve>(src2->Copy());\n\t\tsrc2Inc->IncreaseDegree(refDeg);\n\t\tauto extended2 = NURBSAPIExtend::ExtendCurveToDynamicPoint(src2, true, targetPoint2);\n\t\tauto extended2Inc = NURBSAPIExtend::ExtendCurveToDynamicPoint(src2Inc, true, targetPoint2);\n\t\tshared_ptr<Geom3BSplineCurve> bspCurve2 = NURBSAPIConvert::ToBSpline(extended2);\n\t\tshared_ptr<Geom3BSplineCurve> bspCurve2Inc = NURBSAPIConvert::ToBSpline(extended2Inc);\n\t\tCHECK(bspCurve2Inc->Degree() == refDeg);\n\t\tCHECK(bspCurve2Inc->NKnots() == bspCurve2->NKnots());\n\t\tdouble lp = extended2->LastParameter();\n\t\tPoint3 ep2 = extended2->Value(lp);\n\t\tdouble fp2Inc = extended2Inc->FirstParameter();\n\t\tdouble lp2Inc = extended2Inc->LastParameter();\n\t\tPoint3 p3Inc = extended2Inc->Value(fp2Inc);\n\t\tPoint3 p4Inc = extended2Inc->Value(lp2Inc);\n\t\tCHECK(p3Inc.X() == Approx(targetPoint2.X()));\n\t\tCHECK(p3Inc.Y() == Approx(targetPoint2.Y()));\n\t\tCHECK(p3Inc.Z() == Approx(targetPoint2.Z()));\n\t\tCHECK(p4Inc.X() == Approx(ep2.X()));\n\t\tCHECK(p4Inc.Y() == Approx(ep2.Y()));\n\t\tCHECK(p4Inc.Z() == Approx(ep2.Z()));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static std::shared_ptr<Geom3Surface> ExtendSurfPerpendicularToPlane(const std::shared_ptr<Geom3Surface>& surf, bool isExtendU, bool isFront, const std::shared_ptr<Geom3Plane>& plane)\t @return New surface\n\t @param plane Plane\n\t @param isFront Extend front or back\n\t @param isExtendU Extend u or v\n\t @param surf Surf\n\t The degree of surface is not changed but the size of the extended direction (u or v) knots and poles increase 1.\n\t The original surface is part of new surface.\n\t @brief Extend surface to plane and the end of surface is always perpendicular to the plane, which can be used in mirror to fix the gap.\n,\n",
      "output": "﻿#include<catch.hpp>\n#include<testHelper.h>\n#include <nurbs/NURBSAPIExtend.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <modeling/MakeFace.hpp>\n#include <topology/BRepExtremaDistShapeShape.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/Geom3Plane.hpp>\n#include <geometry/Geom3TrimmedSurface.hpp>\n#include <nurbs/NURBSAPIConvert.hpp>\n#include <nurbs/NURBSAPIBuildCurve.hpp>\n#include <geomAlgo/LawBSpline.hpp>\n#include <offset/MakePipe.hpp>\n#include <modeling/MakeWire.hpp>\n#include <topology/TopoTool.hpp>\n#include <topology/TopoExplorerTool.hpp>\n#include <geometry/GeomAPIProjectPointOnCurve3.hpp>\n#include <geometry/GeomAPIProjectPointOnSurface.hpp>\ndouble NurbsExtendSample(int num, double len, double tol, const shared_ptr<Geom3Curve>& curve1, const shared_ptr<Geom3Curve>& curve2)\n{\n\tconst int nsample = num;\n\tdouble fp1 = curve1->FirstParameter();\n\tdouble lp1 = curve1->LastParameter();\n\tdouble delta1 = (lp1 - fp1) / nsample;\n\tPoint3 p;\n\tint n = 0;\n\tfor (int i = 0; i < nsample; i++)\n\t{\n\t\tdouble t1 = fp1 + i * delta1;\n\t\tcurve1->D0(t1, p);\n\t\tTopoVertex vt = MakeVertex(p);\n\t\tTopoEdge edge = MakeEdge(curve2);\n\t\tBRepExtremaDistShapeShape dist(vt, edge);\n\t\tdouble dis = abs(dist.Value() - len);\n\t\tif (dis <= tol)\n\t\t{\n\t\t\tn++;\n\t\t}\n\t}\n\tdouble res = 1.0 * (num - n) / num;\n\treturn res;\n}\nshared_ptr<Geom3Surface> ConstructExtendSurface()\n{\n\tstd::vector<Point3> profilePoles;\n\tstd::vector<double> profileKnots(3);\n\tstd::vector<int> profileMults(3, 1);\n\tprofilePoles.push_back(Point3(0.0, 0.0, 0.0));\n\tprofilePoles.push_back(Point3(1.0, -0.2, 0.0));\n\tprofilePoles.push_back(Point3(2.0, 0.1, 0.0));\n\tprofilePoles.push_back(Point3(2.3, -0.1, 0.0));\n\tprofilePoles.push_back(Point3(2.9, 0.1, 0.0));\n\tprofileKnots[0] = 0;\n\tprofileKnots[1] = 0.5;\n\tprofileKnots[2] = 1;\n\tprofileMults.front() = 4;\n\tprofileMults.back() = 4;\n\tstd::shared_ptr<Geom3BSplineCurve> profile = std::make_shared<Geom3BSplineCurve>(profilePoles, profileKnots, profileMults, 3);\n\tstd::vector<Point3> spinePoles;\n\tstd::vector<double> spineKnots(4);\n\tstd::vector<int> spineMults(4, 1);\n\tspinePoles.push_back(Point3(0.0, 0.0, 0.0));\n\tspinePoles.push_back(Point3(0.0, 0.0, 1.0));\n\tspinePoles.push_back(Point3(0.0, 0.2, 1.5));\n\tspinePoles.push_back(Point3(0.0, 0.5, 2.0));\n\tspinePoles.push_back(Point3(0.0, 1.0, 2.3));\n\tspinePoles.push_back(Point3(0.0, 1.6, 2.3));\n\tspineKnots[0] = 0;\n\tspineKnots[1] = 1.0 / 3.0;\n\tspineKnots[2] = 2.0 / 3.0;\n\tspineKnots[3] = 1;\n\tspineMults.front() = 4;\n\tspineMults.back() = 4;\n\tstd::shared_ptr<Geom3BSplineCurve> spine = std::make_shared<Geom3BSplineCurve>(spinePoles, spineKnots, spineMults, 3);\n\tTopoShape pipe = MakePipe(MakeWire(MakeEdge(spine)), MakeWire(MakeEdge(profile))).Shape();\n\tTopoExplorer ex(pipe, ShapeType::Face);\n\tstd::shared_ptr<Geom3Surface> surface = TopoTool::Surface(static_cast<const TopoFace&>(ex.Current()));\n\treturn surface;\n}\nshared_ptr<Geom3Surface> ConstructExtendPeriodicSurf()\n{\n\tstd::vector<Point3> profilePoles;\n\tprofilePoles.push_back(Point3(0.0, 0.0, 0.0));\n\tprofilePoles.push_back(Point3(1.0, -1.0, 0.0));\n\tprofilePoles.push_back(Point3(2.0, -1.5, 0.0));\n\tprofilePoles.push_back(Point3(2.3, -1.0, 0.0));\n\tprofilePoles.push_back(Point3(2.9, 0.0, 0.0));\n\tprofilePoles.push_back(Point3(2.3, 0.9, 0.0));\n\tprofilePoles.push_back(Point3(2.1, 1.6, 0.0));\n\tprofilePoles.push_back(Point3(1.0, 1.0, 0.0));\n\tstd::vector<double> profileKnots(profilePoles.size() + 1);\n\tfor (int i = 0; i < static_cast<int>(profileKnots.size()); i++)\n\t{\n\t\tprofileKnots[i] = (double)i / (double)(profilePoles.size());\n\t}\n\tprofileKnots[1] += 1.0 / (double)(3 * profilePoles.size());\n\tstd::vector<int> profileMults(profileKnots.size(), 1);\n\tstd::shared_ptr<Geom3BSplineCurve> profile = std::make_shared<Geom3BSplineCurve>(profilePoles, profileKnots, profileMults, 3, true);\n\tstd::vector<Point3> spinePoles;\n\tstd::vector<double> spineKnots(4);\n\tstd::vector<int> spineMults(4, 1);\n\tspinePoles.push_back(Point3(0.0, 0.0, 0.0));\n\tspinePoles.push_back(Point3(0.0, 0.0, 1.0));\n\tspinePoles.push_back(Point3(0.0, 0.2, 1.5));\n\tspinePoles.push_back(Point3(0.0, 0.5, 2.0));\n\tspinePoles.push_back(Point3(0.0, 1.0, 2.3));\n\tspinePoles.push_back(Point3(0.0, 1.6, 2.3));\n\tspineKnots[0] = 0;\n\tspineKnots[1] = 1.0 / 3.0;\n\tspineKnots[2] = 2.0 / 3.0;\n\tspineKnots[3] = 1;\n\tspineMults.front() = 4;\n\tspineMults.back() = 4;\n\tstd::shared_ptr<Geom3BSplineCurve> spine = std::make_shared<Geom3BSplineCurve>(spinePoles, spineKnots, spineMults, 3);\n\tTopoShape pipe = MakePipe(MakeWire(MakeEdge(spine)), MakeWire(MakeEdge(profile))).Shape();\n\tTopoExplorer ex(pipe, ShapeType::Face);\n\tstd::shared_ptr<Geom3Surface> surface = TopoTool::Surface(static_cast<const TopoFace&>(ex.Current()));\n\treturn surface;\n}\nTEST_CASE(\"bug2:ExtendPeriodicSurf \", \"[nurbs][Extend][fixbug]\")\n{\n\tOUTPUT_DIRECTORY(nurbs, Extend/bug612);\n\tint num = 1000;\n\tdouble tol = 1e-4;\n\tdouble ratio = 0.01;\n\tdouble refTol = DEFAULT_TOLERANCE;\n\tstd::vector<Point3> profilePoles;\n\tprofilePoles.push_back(Point3(0.0, 0.0, 0.0));\n\tprofilePoles.push_back(Point3(1.0, -1.0, 0.0));\n\tprofilePoles.push_back(Point3(2.0, -1.5, 0.0));\n\tprofilePoles.push_back(Point3(2.3, -1.0, 0.0));\n\tprofilePoles.push_back(Point3(2.9, 0.0, 0.0));\n\tprofilePoles.push_back(Point3(2.3, 0.9, 0.0));\n\tprofilePoles.push_back(Point3(2.1, 1.6, 0.0));\n\tprofilePoles.push_back(Point3(1.0, 1.0, 0.0));\n\tstd::vector<double> profileKnots(profilePoles.size() + 1);\n\tfor (int i = 0; i < static_cast<int>(profileKnots.size()); i++)\n\t{\n\t\tprofileKnots[i] = (double)i / (double)(profilePoles.size());\n\t}\n\tprofileKnots[1] += 1.0 / (double)(3 * profilePoles.size());\n\tstd::vector<int> profileMults(profileKnots.size(), 1);\n\tstd::shared_ptr<Geom3BSplineCurve> profile = std::make_shared<Geom3BSplineCurve>(profilePoles, profileKnots, profileMults, 3, true);\n\tstd::vector<Point3> spinePoles;\n\tstd::vector<double> spineKnots(4);\n\tstd::vector<int> spineMults(4, 1);\n\tspinePoles.push_back(Point3(0.0, 0.0, 0.0));\n\tspinePoles.push_back(Point3(0.0, 0.0, 1.0));\n\tspinePoles.push_back(Point3(0.0, 0.2, 1.5));\n\tspinePoles.push_back(Point3(0.0, 0.5, 2.0));\n\tspinePoles.push_back(Point3(0.0, 1.0, 2.3));\n\tspinePoles.push_back(Point3(0.0, 1.6, 2.3));\n\tspineKnots[0] = 0;\n\tspineKnots[1] = 1.0 / 3.0;\n\tspineKnots[2] = 2.0 / 3.0;\n\tspineKnots[3] = 1;\n\tspineMults.front() = 4;\n\tspineMults.back() = 4;\n\tstd::shared_ptr<Geom3BSplineCurve> spine = std::make_shared<Geom3BSplineCurve>(spinePoles, spineKnots, spineMults, 3);\n\tTopoShape pipe = MakePipe(MakeWire(MakeEdge(spine)), MakeWire(MakeEdge(profile))).Shape();\n\tTopoExplorer ex(pipe, ShapeType::Face);\n\tstd::shared_ptr<Geom3Surface> surface = TopoTool::Surface(static_cast<const TopoFace&>(ex.Current()));\n\tshared_ptr<Geom3BSplineSurface> bspSurf = NURBSAPIConvert::ToBSpline(surface);\n\tint udeg = bspSurf->UDegree();\n\tint vdeg = bspSurf->VDegree();\n\tint upNum = bspSurf->NUPoles();\n\tint vpNum = bspSurf->NVPoles();\n\tint ukNum = bspSurf->NUKnots();\n\tint vkNum = bspSurf->NVKnots();\n\tdouble fpu = surface->FirstUParameter();\n\tdouble fpv = surface->FirstVParameter();\n\tdouble lpu = surface->LastUParameter();\n\tdouble lpv = surface->LastVParameter();\n\tshared_ptr<Geom3Curve> fu = surface->UIso(fpu);\n\tshared_ptr<Geom3Curve> fv = surface->VIso(fpv);\n\tshared_ptr<Geom3Curve> lu = surface->UIso(lpu);\n\tshared_ptr<Geom3Curve> lv = surface->VIso(lpv);\n\tauto plane = std::make_shared<Geom3Plane>(Point3(0.0, 0.0, -5.3), Direction3(0.0, 0.0, 1.0));\n\tauto planevf = NURBSAPIExtend::ExtendSurfPerpendicularToPlane(surface, false, true, plane);\n\tshared_ptr<Geom3TrimmedSurface>trimSurf = std::make_shared<Geom3TrimmedSurface>(plane, -10.0, 10.0, -10.0, 10.0);\n\tshared_ptr<Geom3BSplineSurface> bspSurf2 = NURBSAPIConvert::ToBSpline(planevf);\n\tCHECK(bspSurf2->UDegree() == udeg);\n\tCHECK(bspSurf2->VDegree() == vdeg);\n\tCHECK(bspSurf2->NUPoles() == upNum);\n\tCHECK(bspSurf2->NVPoles() == (vpNum + 1));\n\tCHECK(bspSurf2->NUKnots() == ukNum);\n\tCHECK(bspSurf2->NVKnots() == (vkNum + 1));\n\tdouble fpv2 = planevf->FirstVParameter();\n\tshared_ptr<Geom3Curve> fv2 = planevf->VIso(fpv2);\n\tbool res2 = IsCurveOnSurf(num, ratio, fv2, plane, -1.0);\n\tCHECK(res2 == true);\n\tOCCTIO::OCCTTool::Write(MakeFace(trimSurf, 0.0), outdir + \"trimSurf.brep\");\n\tOCCTIO::OCCTTool::Write(MakeFace(surface, 0.0), outdir + \"src.brep\");\n\tOCCTIO::OCCTTool::Write(MakeFace(planevf, 0.0), outdir + \"result.brep\");\n;\n\tSECTION(\"ExtendSurfPerpendicularToPlane4\")\n\t{\n\t\tOUTPUT_DIRECTORY(nurbs, Extend/bug614/ExtendSurfPerpendicularToPlane4);\n\t\tshared_ptr<Geom3Plane> plane = make_shared<Geom3Plane>(Point3(0.0, 1.8, 0.0), Direction3(0.0, 1.0, 0.0));\n\t\tauto planevl = NURBSAPIExtend::ExtendSurfPerpendicularToPlane(surface, false, false, plane);\n\t\tshared_ptr<Geom3TrimmedSurface>trimSurf = std::make_shared<Geom3TrimmedSurface>(plane, -5.0, 5.0, -5.0, 5.0);\n\t\tshared_ptr<Geom3BSplineSurface> bspSurf2 = NURBSAPIConvert::ToBSpline(planevl);\n\t\tCHECK(bspSurf2->VDegree() == vdeg);\n\t\tCHECK(bspSurf2->NVPoles() == (vpNum + 1));\n\t\tCHECK(bspSurf2->NVKnots() == (vkNum + 1));\n\t\tOCCTIO::OCCTTool::Write(MakeFace(trimSurf, 0.0), outdir + \"trimSurf.brep\");\n\t\tOCCTIO::OCCTTool::Write(MakeFace(surface, 0.0), outdir + \"src.brep\");\n\t\tOCCTIO::OCCTTool::Write(MakeFace(planevl, 0.0), outdir + \"result.brep\");\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static std::shared_ptr<Geom3Surface> ExtendSurfPerpendicularToPlane(const std::shared_ptr<Geom3Surface>& surf, const std::shared_ptr<Geom3Plane>& plane)\t @return New surface\n\t @param plane Plane\n\t @param surf Surf\n\t The degree of surface is not changed but the size of the extended direction (u or v) knots and poles increase 1.\n\t The original surface is part of new surface.\n\t @brief Extend surface to plane and the surface end which is closer to plane is always perpendicular to the plane, which can be used in mirror to fix the gap.\n,\n",
      "output": "﻿#include<catch.hpp>\n#include<testHelper.h>\n#include <nurbs/NURBSAPIExtend.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <modeling/MakeFace.hpp>\n#include <topology/BRepExtremaDistShapeShape.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/Geom3Plane.hpp>\n#include <geometry/Geom3TrimmedSurface.hpp>\n#include <nurbs/NURBSAPIConvert.hpp>\n#include <nurbs/NURBSAPIBuildCurve.hpp>\n#include <geomAlgo/LawBSpline.hpp>\n#include <offset/MakePipe.hpp>\n#include <modeling/MakeWire.hpp>\n#include <topology/TopoTool.hpp>\n#include <topology/TopoExplorerTool.hpp>\n#include <geometry/GeomAPIProjectPointOnCurve3.hpp>\n#include <geometry/GeomAPIProjectPointOnSurface.hpp>\ndouble NurbsExtendSample(int num, double len, double tol, const shared_ptr<Geom3Curve>& curve1, const shared_ptr<Geom3Curve>& curve2)\n{\n\tconst int nsample = num;\n\tdouble fp1 = curve1->FirstParameter();\n\tdouble lp1 = curve1->LastParameter();\n\tdouble delta1 = (lp1 - fp1) / nsample;\n\tPoint3 p;\n\tint n = 0;\n\tfor (int i = 0; i < nsample; i++)\n\t{\n\t\tdouble t1 = fp1 + i * delta1;\n\t\tcurve1->D0(t1, p);\n\t\tTopoVertex vt = MakeVertex(p);\n\t\tTopoEdge edge = MakeEdge(curve2);\n\t\tBRepExtremaDistShapeShape dist(vt, edge);\n\t\tdouble dis = abs(dist.Value() - len);\n\t\tif (dis <= tol)\n\t\t{\n\t\t\tn++;\n\t\t}\n\t}\n\tdouble res = 1.0 * (num - n) / num;\n\treturn res;\n}\nshared_ptr<Geom3Surface> ConstructExtendSurface()\n{\n\tstd::vector<Point3> profilePoles;\n\tstd::vector<double> profileKnots(3);\n\tstd::vector<int> profileMults(3, 1);\n\tprofilePoles.push_back(Point3(0.0, 0.0, 0.0));\n\tprofilePoles.push_back(Point3(1.0, -0.2, 0.0));\n\tprofilePoles.push_back(Point3(2.0, 0.1, 0.0));\n\tprofilePoles.push_back(Point3(2.3, -0.1, 0.0));\n\tprofilePoles.push_back(Point3(2.9, 0.1, 0.0));\n\tprofileKnots[0] = 0;\n\tprofileKnots[1] = 0.5;\n\tprofileKnots[2] = 1;\n\tprofileMults.front() = 4;\n\tprofileMults.back() = 4;\n\tstd::shared_ptr<Geom3BSplineCurve> profile = std::make_shared<Geom3BSplineCurve>(profilePoles, profileKnots, profileMults, 3);\n\tstd::vector<Point3> spinePoles;\n\tstd::vector<double> spineKnots(4);\n\tstd::vector<int> spineMults(4, 1);\n\tspinePoles.push_back(Point3(0.0, 0.0, 0.0));\n\tspinePoles.push_back(Point3(0.0, 0.0, 1.0));\n\tspinePoles.push_back(Point3(0.0, 0.2, 1.5));\n\tspinePoles.push_back(Point3(0.0, 0.5, 2.0));\n\tspinePoles.push_back(Point3(0.0, 1.0, 2.3));\n\tspinePoles.push_back(Point3(0.0, 1.6, 2.3));\n\tspineKnots[0] = 0;\n\tspineKnots[1] = 1.0 / 3.0;\n\tspineKnots[2] = 2.0 / 3.0;\n\tspineKnots[3] = 1;\n\tspineMults.front() = 4;\n\tspineMults.back() = 4;\n\tstd::shared_ptr<Geom3BSplineCurve> spine = std::make_shared<Geom3BSplineCurve>(spinePoles, spineKnots, spineMults, 3);\n\tTopoShape pipe = MakePipe(MakeWire(MakeEdge(spine)), MakeWire(MakeEdge(profile))).Shape();\n\tTopoExplorer ex(pipe, ShapeType::Face);\n\tstd::shared_ptr<Geom3Surface> surface = TopoTool::Surface(static_cast<const TopoFace&>(ex.Current()));\n\treturn surface;\n}\nshared_ptr<Geom3Surface> ConstructExtendPeriodicSurf()\n{\n\tstd::vector<Point3> profilePoles;\n\tprofilePoles.push_back(Point3(0.0, 0.0, 0.0));\n\tprofilePoles.push_back(Point3(1.0, -1.0, 0.0));\n\tprofilePoles.push_back(Point3(2.0, -1.5, 0.0));\n\tprofilePoles.push_back(Point3(2.3, -1.0, 0.0));\n\tprofilePoles.push_back(Point3(2.9, 0.0, 0.0));\n\tprofilePoles.push_back(Point3(2.3, 0.9, 0.0));\n\tprofilePoles.push_back(Point3(2.1, 1.6, 0.0));\n\tprofilePoles.push_back(Point3(1.0, 1.0, 0.0));\n\tstd::vector<double> profileKnots(profilePoles.size() + 1);\n\tfor (int i = 0; i < static_cast<int>(profileKnots.size()); i++)\n\t{\n\t\tprofileKnots[i] = (double)i / (double)(profilePoles.size());\n\t}\n\tprofileKnots[1] += 1.0 / (double)(3 * profilePoles.size());\n\tstd::vector<int> profileMults(profileKnots.size(), 1);\n\tstd::shared_ptr<Geom3BSplineCurve> profile = std::make_shared<Geom3BSplineCurve>(profilePoles, profileKnots, profileMults, 3, true);\n\tstd::vector<Point3> spinePoles;\n\tstd::vector<double> spineKnots(4);\n\tstd::vector<int> spineMults(4, 1);\n\tspinePoles.push_back(Point3(0.0, 0.0, 0.0));\n\tspinePoles.push_back(Point3(0.0, 0.0, 1.0));\n\tspinePoles.push_back(Point3(0.0, 0.2, 1.5));\n\tspinePoles.push_back(Point3(0.0, 0.5, 2.0));\n\tspinePoles.push_back(Point3(0.0, 1.0, 2.3));\n\tspinePoles.push_back(Point3(0.0, 1.6, 2.3));\n\tspineKnots[0] = 0;\n\tspineKnots[1] = 1.0 / 3.0;\n\tspineKnots[2] = 2.0 / 3.0;\n\tspineKnots[3] = 1;\n\tspineMults.front() = 4;\n\tspineMults.back() = 4;\n\tstd::shared_ptr<Geom3BSplineCurve> spine = std::make_shared<Geom3BSplineCurve>(spinePoles, spineKnots, spineMults, 3);\n\tTopoShape pipe = MakePipe(MakeWire(MakeEdge(spine)), MakeWire(MakeEdge(profile))).Shape();\n\tTopoExplorer ex(pipe, ShapeType::Face);\n\tstd::shared_ptr<Geom3Surface> surface = TopoTool::Surface(static_cast<const TopoFace&>(ex.Current()));\n\treturn surface;\n}\nTEST_CASE(\"bug7: ExtendPeriodicSurf3 \", \"[nurbs][Extend][fixbug]\")\n{\n\tOUTPUT_DIRECTORY(nurbs, Extend/bug689/ExtendPeriodicSurf3);\n\tshared_ptr<Geom3Surface> surface = ConstructExtendPeriodicSurf();\n\tauto plane = std::make_shared<Geom3Plane>(Point3(0.0, 0.0, -5.3), Direction3(0.0, 0.0, 1.0));\n\tauto planevf = NURBSAPIExtend::ExtendSurfPerpendicularToPlane(surface, false, true, plane);\n\tshared_ptr<Geom3TrimmedSurface>trimSurf = std::make_shared<Geom3TrimmedSurface>(plane, -10.0, 10.0, -10.0, 10.0);\n\tdouble fpv1 = planevf->FirstUParameter();\n\tshared_ptr<Geom3Curve> fv1 = planevf->UIso(fpv1);\n\tPoint3 p1;\n\tVector3 vec;\n\tdouble fs = fv1->FirstParameter();\n\tfv1->D1(fs, p1, vec);\n\tAxis3 axis = plane->Axis();\n\tbool res = axis.Direction().IsParallel(Direction3(vec), Precision::Angular());\n\tCHECK(res == true);\n\tOCCTIO::OCCTTool::Write(MakeEdge(fv1), outdir + \"curve2.brep\");\n\tOCCTIO::OCCTTool::Write(MakeFace(trimSurf, 0.0), outdir + \"trimSurf.brep\");\n\tOCCTIO::OCCTTool::Write(MakeFace(surface, 0.0), outdir + \"src.brep\");\n\tOCCTIO::OCCTTool::Write(MakeFace(planevf, 0.0), outdir + \"result.brep\");\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static std::shared_ptr<Geom3Curve> ExtendCurvePerpendicularToPlane(const std::shared_ptr<Geom3Curve>& curve, bool isFront, const std::shared_ptr<Geom3Plane>& plane)\t @return New curve\n\t @param plane Plane\n\t @param isFront Extend front or back\n\t @param curve Curve\n\t The degree of curve is not changed but the size of knots and poles increase 1.\n\t The original curve is part of new curve.\n\t @brief Extend curve to plane and the end of curve is perpendicular to the plane, which can be used in mirror to fix the gap.\n,\n",
      "output": "﻿#include<catch.hpp>\n#include<testHelper.h>\n#include <nurbs/NURBSAPIExtend.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <modeling/MakeFace.hpp>\n#include <topology/BRepExtremaDistShapeShape.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/Geom3Plane.hpp>\n#include <geometry/Geom3TrimmedSurface.hpp>\n#include <nurbs/NURBSAPIConvert.hpp>\n#include <nurbs/NURBSAPIBuildCurve.hpp>\n#include <geomAlgo/LawBSpline.hpp>\n#include <offset/MakePipe.hpp>\n#include <modeling/MakeWire.hpp>\n#include <topology/TopoTool.hpp>\n#include <topology/TopoExplorerTool.hpp>\n#include <geometry/GeomAPIProjectPointOnCurve3.hpp>\n#include <geometry/GeomAPIProjectPointOnSurface.hpp>\ndouble NurbsExtendSample(int num, double len, double tol, const shared_ptr<Geom3Curve>& curve1, const shared_ptr<Geom3Curve>& curve2)\n{\n\tconst int nsample = num;\n\tdouble fp1 = curve1->FirstParameter();\n\tdouble lp1 = curve1->LastParameter();\n\tdouble delta1 = (lp1 - fp1) / nsample;\n\tPoint3 p;\n\tint n = 0;\n\tfor (int i = 0; i < nsample; i++)\n\t{\n\t\tdouble t1 = fp1 + i * delta1;\n\t\tcurve1->D0(t1, p);\n\t\tTopoVertex vt = MakeVertex(p);\n\t\tTopoEdge edge = MakeEdge(curve2);\n\t\tBRepExtremaDistShapeShape dist(vt, edge);\n\t\tdouble dis = abs(dist.Value() - len);\n\t\tif (dis <= tol)\n\t\t{\n\t\t\tn++;\n\t\t}\n\t}\n\tdouble res = 1.0 * (num - n) / num;\n\treturn res;\n}\nshared_ptr<Geom3Surface> ConstructExtendSurface()\n{\n\tstd::vector<Point3> profilePoles;\n\tstd::vector<double> profileKnots(3);\n\tstd::vector<int> profileMults(3, 1);\n\tprofilePoles.push_back(Point3(0.0, 0.0, 0.0));\n\tprofilePoles.push_back(Point3(1.0, -0.2, 0.0));\n\tprofilePoles.push_back(Point3(2.0, 0.1, 0.0));\n\tprofilePoles.push_back(Point3(2.3, -0.1, 0.0));\n\tprofilePoles.push_back(Point3(2.9, 0.1, 0.0));\n\tprofileKnots[0] = 0;\n\tprofileKnots[1] = 0.5;\n\tprofileKnots[2] = 1;\n\tprofileMults.front() = 4;\n\tprofileMults.back() = 4;\n\tstd::shared_ptr<Geom3BSplineCurve> profile = std::make_shared<Geom3BSplineCurve>(profilePoles, profileKnots, profileMults, 3);\n\tstd::vector<Point3> spinePoles;\n\tstd::vector<double> spineKnots(4);\n\tstd::vector<int> spineMults(4, 1);\n\tspinePoles.push_back(Point3(0.0, 0.0, 0.0));\n\tspinePoles.push_back(Point3(0.0, 0.0, 1.0));\n\tspinePoles.push_back(Point3(0.0, 0.2, 1.5));\n\tspinePoles.push_back(Point3(0.0, 0.5, 2.0));\n\tspinePoles.push_back(Point3(0.0, 1.0, 2.3));\n\tspinePoles.push_back(Point3(0.0, 1.6, 2.3));\n\tspineKnots[0] = 0;\n\tspineKnots[1] = 1.0 / 3.0;\n\tspineKnots[2] = 2.0 / 3.0;\n\tspineKnots[3] = 1;\n\tspineMults.front() = 4;\n\tspineMults.back() = 4;\n\tstd::shared_ptr<Geom3BSplineCurve> spine = std::make_shared<Geom3BSplineCurve>(spinePoles, spineKnots, spineMults, 3);\n\tTopoShape pipe = MakePipe(MakeWire(MakeEdge(spine)), MakeWire(MakeEdge(profile))).Shape();\n\tTopoExplorer ex(pipe, ShapeType::Face);\n\tstd::shared_ptr<Geom3Surface> surface = TopoTool::Surface(static_cast<const TopoFace&>(ex.Current()));\n\treturn surface;\n}\nshared_ptr<Geom3Surface> ConstructExtendPeriodicSurf()\n{\n\tstd::vector<Point3> profilePoles;\n\tprofilePoles.push_back(Point3(0.0, 0.0, 0.0));\n\tprofilePoles.push_back(Point3(1.0, -1.0, 0.0));\n\tprofilePoles.push_back(Point3(2.0, -1.5, 0.0));\n\tprofilePoles.push_back(Point3(2.3, -1.0, 0.0));\n\tprofilePoles.push_back(Point3(2.9, 0.0, 0.0));\n\tprofilePoles.push_back(Point3(2.3, 0.9, 0.0));\n\tprofilePoles.push_back(Point3(2.1, 1.6, 0.0));\n\tprofilePoles.push_back(Point3(1.0, 1.0, 0.0));\n\tstd::vector<double> profileKnots(profilePoles.size() + 1);\n\tfor (int i = 0; i < static_cast<int>(profileKnots.size()); i++)\n\t{\n\t\tprofileKnots[i] = (double)i / (double)(profilePoles.size());\n\t}\n\tprofileKnots[1] += 1.0 / (double)(3 * profilePoles.size());\n\tstd::vector<int> profileMults(profileKnots.size(), 1);\n\tstd::shared_ptr<Geom3BSplineCurve> profile = std::make_shared<Geom3BSplineCurve>(profilePoles, profileKnots, profileMults, 3, true);\n\tstd::vector<Point3> spinePoles;\n\tstd::vector<double> spineKnots(4);\n\tstd::vector<int> spineMults(4, 1);\n\tspinePoles.push_back(Point3(0.0, 0.0, 0.0));\n\tspinePoles.push_back(Point3(0.0, 0.0, 1.0));\n\tspinePoles.push_back(Point3(0.0, 0.2, 1.5));\n\tspinePoles.push_back(Point3(0.0, 0.5, 2.0));\n\tspinePoles.push_back(Point3(0.0, 1.0, 2.3));\n\tspinePoles.push_back(Point3(0.0, 1.6, 2.3));\n\tspineKnots[0] = 0;\n\tspineKnots[1] = 1.0 / 3.0;\n\tspineKnots[2] = 2.0 / 3.0;\n\tspineKnots[3] = 1;\n\tspineMults.front() = 4;\n\tspineMults.back() = 4;\n\tstd::shared_ptr<Geom3BSplineCurve> spine = std::make_shared<Geom3BSplineCurve>(spinePoles, spineKnots, spineMults, 3);\n\tTopoShape pipe = MakePipe(MakeWire(MakeEdge(spine)), MakeWire(MakeEdge(profile))).Shape();\n\tTopoExplorer ex(pipe, ShapeType::Face);\n\tstd::shared_ptr<Geom3Surface> surface = TopoTool::Surface(static_cast<const TopoFace&>(ex.Current()));\n\treturn surface;\n}\nTEST_CASE(\"bug7: ExtendPeriodicSurf3 \", \"[nurbs][Extend][fixbug]\")\n{\n\tOUTPUT_DIRECTORY(nurbs, Extend/bug689/ExtendPeriodicSurf3);\n\tshared_ptr<Geom3Surface> surface = ConstructExtendPeriodicSurf();\n\tauto plane = std::make_shared<Geom3Plane>(Point3(0.0, 0.0, -5.3), Direction3(0.0, 0.0, 1.0));\n\tauto planevf = NURBSAPIExtend::ExtendSurfPerpendicularToPlane(surface, false, true, plane);\n\tshared_ptr<Geom3TrimmedSurface>trimSurf = std::make_shared<Geom3TrimmedSurface>(plane, -10.0, 10.0, -10.0, 10.0);\n\tdouble fpv1 = planevf->FirstUParameter();\n\tshared_ptr<Geom3Curve> fv1 = planevf->UIso(fpv1);\n\tPoint3 p1;\n\tVector3 vec;\n\tdouble fs = fv1->FirstParameter();\n\tfv1->D1(fs, p1, vec);\n\tAxis3 axis = plane->Axis();\n\tbool res = axis.Direction().IsParallel(Direction3(vec), Precision::Angular());\n\tCHECK(res == true);\n\tOCCTIO::OCCTTool::Write(MakeEdge(fv1), outdir + \"curve2.brep\");\n\tOCCTIO::OCCTTool::Write(MakeFace(trimSurf, 0.0), outdir + \"trimSurf.brep\");\n\tOCCTIO::OCCTTool::Write(MakeFace(surface, 0.0), outdir + \"src.brep\");\n\tOCCTIO::OCCTTool::Write(MakeFace(planevf, 0.0), outdir + \"result.brep\");\n;\n\tSECTION(\"ExtendCurvePerpendicularToPlane2\")\n\t{\n\t\tOUTPUT_DIRECTORY(nurbs, Extend/IncreaseDegree/ExtendCurve/ExtendCurvePerpendicularToPlane2);\n\t\tauto plane2 = std::make_shared<Geom3Plane>(Point3(0.0, -1.2, 0.0), Direction3(0.0, 1.0, 0.0));\n\t\tauto n5bsp = NURBSAPIExtend::ExtendCurvePerpendicularToPlane(bsp, plane2);\n\t\tshared_ptr<Geom3TrimmedSurface>trimtp2 = std::make_shared<Geom3TrimmedSurface>(plane2, -2.0, 2.0, -2.0, 2.0);\n\t\tdouble fp = n5bsp->FirstParameter();\n\t\tdouble lp = n5bsp->LastParameter();\n\t\tPoint3 p1 = n5bsp->Value(fp);\n\t\tPoint3 p2 = n5bsp->Value(lp);\n\t\tauto n5bspInc = NURBSAPIExtend::ExtendCurvePerpendicularToPlane(bspInc, plane2);\n\t\tshared_ptr<Geom3BSplineCurve> bspCurveInc = NURBSAPIConvert::ToBSpline(n5bspInc);\n\t\tCHECK(bspCurveInc->Degree() == refDeg);\n\t\tCHECK(bspCurveInc->NKnots() == (kNum + 1));\n\t\tdouble fpInc = n5bspInc->FirstParameter();\n\t\tdouble lpInc = n5bspInc->LastParameter();\n\t\tPoint3 p1Inc = n5bspInc->Value(fpInc);\n\t\tPoint3 p2Inc = n5bspInc->Value(lpInc);\n\t\tCHECK(p2Inc.X() == Approx(ep.X()));\n\t\tCHECK(p2Inc.Y() == Approx(ep.Y()));\n\t\tCHECK(p2Inc.Z() == Approx(ep.Z()));\n\t\tbool res11 = BRepClassificationTools::IsPointInFace(MakeFace(trimtp2, 0.0), p1Inc);\n\t\tCHECK(res11 == true);\n\t\tPoint3 p3Inc;\n\t\tVector3 vecInc;\n\t\tn5bspInc->D1(fpInc, p3Inc, vecInc);\n\t\tAxis3 axisInc = plane2->Axis();\n\t\tbool res22 = axisInc.Direction().IsParallel(Direction3(vecInc), Precision::Angular());\n\t\tCHECK(res22 == true);\n\t\tdouble res33 = NurbsSampleCurve(num, refTol, n5bsp, n5bspInc);\n\t\tCHECK(res33 <= ratio);\n\t\tOCCTIO::OCCTTool::Write(MakeVertex(sp), outdir + \"sp.brep\");\n\t\tOCCTIO::OCCTTool::Write(MakeVertex(ep), outdir + \"ep.brep\");\n\t\tOCCTIO::OCCTTool::Write(MakeVertex(p1), outdir + \"p1.brep\");\n\t\tOCCTIO::OCCTTool::Write(MakeVertex(p2), outdir + \"p2.brep\");\n\t\tOCCTIO::OCCTTool::Write(MakeEdge(bsp), outdir + \"src.brep\");\n\t\tOCCTIO::OCCTTool::Write(MakeFace(trimtp2, 0.0), outdir + \"trimtp2.brep\");\n\t\tOCCTIO::OCCTTool::Write(MakeEdge(n5bsp), outdir + \"result.brep\");\n\t\tOCCTIO::OCCTTool::Write(MakeEdge(n5bspInc), outdir + \"resultInc.brep\");\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static std::shared_ptr<Geom3Curve> ExtendCurvePerpendicularToPlane(const std::shared_ptr<Geom3Curve>& curve, const std::shared_ptr<Geom3Plane>& plane)\t @return New curve\n\t @param plane Plane\n\t @param curve Curve\n\t The degree of curve is not changed but the size of knots and poles increase 1.\n\t The original curve is part of new curve.\n\t @brief Extend curve to plane and the curve end which is closer to plane is perpendicular to the plane, which can be used in mirror to fix the gap.\n,\n",
      "output": "﻿#include<catch.hpp>\n#include<testHelper.h>\n#include <nurbs/NURBSAPIExtend.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <modeling/MakeFace.hpp>\n#include <topology/BRepExtremaDistShapeShape.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/Geom3Plane.hpp>\n#include <geometry/Geom3TrimmedSurface.hpp>\n#include <nurbs/NURBSAPIConvert.hpp>\n#include <nurbs/NURBSAPIBuildCurve.hpp>\n#include <geomAlgo/LawBSpline.hpp>\n#include <offset/MakePipe.hpp>\n#include <modeling/MakeWire.hpp>\n#include <topology/TopoTool.hpp>\n#include <topology/TopoExplorerTool.hpp>\n#include <geometry/GeomAPIProjectPointOnCurve3.hpp>\n#include <geometry/GeomAPIProjectPointOnSurface.hpp>\ndouble NurbsExtendSample(int num, double len, double tol, const shared_ptr<Geom3Curve>& curve1, const shared_ptr<Geom3Curve>& curve2)\n{\n\tconst int nsample = num;\n\tdouble fp1 = curve1->FirstParameter();\n\tdouble lp1 = curve1->LastParameter();\n\tdouble delta1 = (lp1 - fp1) / nsample;\n\tPoint3 p;\n\tint n = 0;\n\tfor (int i = 0; i < nsample; i++)\n\t{\n\t\tdouble t1 = fp1 + i * delta1;\n\t\tcurve1->D0(t1, p);\n\t\tTopoVertex vt = MakeVertex(p);\n\t\tTopoEdge edge = MakeEdge(curve2);\n\t\tBRepExtremaDistShapeShape dist(vt, edge);\n\t\tdouble dis = abs(dist.Value() - len);\n\t\tif (dis <= tol)\n\t\t{\n\t\t\tn++;\n\t\t}\n\t}\n\tdouble res = 1.0 * (num - n) / num;\n\treturn res;\n}\nshared_ptr<Geom3Surface> ConstructExtendSurface()\n{\n\tstd::vector<Point3> profilePoles;\n\tstd::vector<double> profileKnots(3);\n\tstd::vector<int> profileMults(3, 1);\n\tprofilePoles.push_back(Point3(0.0, 0.0, 0.0));\n\tprofilePoles.push_back(Point3(1.0, -0.2, 0.0));\n\tprofilePoles.push_back(Point3(2.0, 0.1, 0.0));\n\tprofilePoles.push_back(Point3(2.3, -0.1, 0.0));\n\tprofilePoles.push_back(Point3(2.9, 0.1, 0.0));\n\tprofileKnots[0] = 0;\n\tprofileKnots[1] = 0.5;\n\tprofileKnots[2] = 1;\n\tprofileMults.front() = 4;\n\tprofileMults.back() = 4;\n\tstd::shared_ptr<Geom3BSplineCurve> profile = std::make_shared<Geom3BSplineCurve>(profilePoles, profileKnots, profileMults, 3);\n\tstd::vector<Point3> spinePoles;\n\tstd::vector<double> spineKnots(4);\n\tstd::vector<int> spineMults(4, 1);\n\tspinePoles.push_back(Point3(0.0, 0.0, 0.0));\n\tspinePoles.push_back(Point3(0.0, 0.0, 1.0));\n\tspinePoles.push_back(Point3(0.0, 0.2, 1.5));\n\tspinePoles.push_back(Point3(0.0, 0.5, 2.0));\n\tspinePoles.push_back(Point3(0.0, 1.0, 2.3));\n\tspinePoles.push_back(Point3(0.0, 1.6, 2.3));\n\tspineKnots[0] = 0;\n\tspineKnots[1] = 1.0 / 3.0;\n\tspineKnots[2] = 2.0 / 3.0;\n\tspineKnots[3] = 1;\n\tspineMults.front() = 4;\n\tspineMults.back() = 4;\n\tstd::shared_ptr<Geom3BSplineCurve> spine = std::make_shared<Geom3BSplineCurve>(spinePoles, spineKnots, spineMults, 3);\n\tTopoShape pipe = MakePipe(MakeWire(MakeEdge(spine)), MakeWire(MakeEdge(profile))).Shape();\n\tTopoExplorer ex(pipe, ShapeType::Face);\n\tstd::shared_ptr<Geom3Surface> surface = TopoTool::Surface(static_cast<const TopoFace&>(ex.Current()));\n\treturn surface;\n}\nshared_ptr<Geom3Surface> ConstructExtendPeriodicSurf()\n{\n\tstd::vector<Point3> profilePoles;\n\tprofilePoles.push_back(Point3(0.0, 0.0, 0.0));\n\tprofilePoles.push_back(Point3(1.0, -1.0, 0.0));\n\tprofilePoles.push_back(Point3(2.0, -1.5, 0.0));\n\tprofilePoles.push_back(Point3(2.3, -1.0, 0.0));\n\tprofilePoles.push_back(Point3(2.9, 0.0, 0.0));\n\tprofilePoles.push_back(Point3(2.3, 0.9, 0.0));\n\tprofilePoles.push_back(Point3(2.1, 1.6, 0.0));\n\tprofilePoles.push_back(Point3(1.0, 1.0, 0.0));\n\tstd::vector<double> profileKnots(profilePoles.size() + 1);\n\tfor (int i = 0; i < static_cast<int>(profileKnots.size()); i++)\n\t{\n\t\tprofileKnots[i] = (double)i / (double)(profilePoles.size());\n\t}\n\tprofileKnots[1] += 1.0 / (double)(3 * profilePoles.size());\n\tstd::vector<int> profileMults(profileKnots.size(), 1);\n\tstd::shared_ptr<Geom3BSplineCurve> profile = std::make_shared<Geom3BSplineCurve>(profilePoles, profileKnots, profileMults, 3, true);\n\tstd::vector<Point3> spinePoles;\n\tstd::vector<double> spineKnots(4);\n\tstd::vector<int> spineMults(4, 1);\n\tspinePoles.push_back(Point3(0.0, 0.0, 0.0));\n\tspinePoles.push_back(Point3(0.0, 0.0, 1.0));\n\tspinePoles.push_back(Point3(0.0, 0.2, 1.5));\n\tspinePoles.push_back(Point3(0.0, 0.5, 2.0));\n\tspinePoles.push_back(Point3(0.0, 1.0, 2.3));\n\tspinePoles.push_back(Point3(0.0, 1.6, 2.3));\n\tspineKnots[0] = 0;\n\tspineKnots[1] = 1.0 / 3.0;\n\tspineKnots[2] = 2.0 / 3.0;\n\tspineKnots[3] = 1;\n\tspineMults.front() = 4;\n\tspineMults.back() = 4;\n\tstd::shared_ptr<Geom3BSplineCurve> spine = std::make_shared<Geom3BSplineCurve>(spinePoles, spineKnots, spineMults, 3);\n\tTopoShape pipe = MakePipe(MakeWire(MakeEdge(spine)), MakeWire(MakeEdge(profile))).Shape();\n\tTopoExplorer ex(pipe, ShapeType::Face);\n\tstd::shared_ptr<Geom3Surface> surface = TopoTool::Surface(static_cast<const TopoFace&>(ex.Current()));\n\treturn surface;\n}\nTEST_CASE(\"bug7: ExtendPeriodicSurf3 \", \"[nurbs][Extend][fixbug]\")\n{\n\tOUTPUT_DIRECTORY(nurbs, Extend/bug689/ExtendPeriodicSurf3);\n\tshared_ptr<Geom3Surface> surface = ConstructExtendPeriodicSurf();\n\tauto plane = std::make_shared<Geom3Plane>(Point3(0.0, 0.0, -5.3), Direction3(0.0, 0.0, 1.0));\n\tauto planevf = NURBSAPIExtend::ExtendSurfPerpendicularToPlane(surface, false, true, plane);\n\tshared_ptr<Geom3TrimmedSurface>trimSurf = std::make_shared<Geom3TrimmedSurface>(plane, -10.0, 10.0, -10.0, 10.0);\n\tdouble fpv1 = planevf->FirstUParameter();\n\tshared_ptr<Geom3Curve> fv1 = planevf->UIso(fpv1);\n\tPoint3 p1;\n\tVector3 vec;\n\tdouble fs = fv1->FirstParameter();\n\tfv1->D1(fs, p1, vec);\n\tAxis3 axis = plane->Axis();\n\tbool res = axis.Direction().IsParallel(Direction3(vec), Precision::Angular());\n\tCHECK(res == true);\n\tOCCTIO::OCCTTool::Write(MakeEdge(fv1), outdir + \"curve2.brep\");\n\tOCCTIO::OCCTTool::Write(MakeFace(trimSurf, 0.0), outdir + \"trimSurf.brep\");\n\tOCCTIO::OCCTTool::Write(MakeFace(surface, 0.0), outdir + \"src.brep\");\n\tOCCTIO::OCCTTool::Write(MakeFace(planevf, 0.0), outdir + \"result.brep\");\n;\n\tSECTION(\"ExtendCurvePerpendicularToPlane1\")\n\t{\n\t\tOUTPUT_DIRECTORY(nurbs, Extend/ExtendCurve/ExtendCurvePerpendicularToPlane1);\n\t\tauto plane1 = std::make_shared<Geom3Plane>(Point3(0.0, 1.2, 0.0), Direction3(0.0, 1.0, 0.0));\n\t\tauto n4bsp = NURBSAPIExtend::ExtendCurvePerpendicularToPlane(bsp, plane1);\n\t\tshared_ptr<Geom3TrimmedSurface>trimtp1 = std::make_shared<Geom3TrimmedSurface>(plane1, -2.0, 2.0, -2.0, 2.0);\n\t\tshared_ptr<Geom3BSplineCurve> bspCurve = NURBSAPIConvert::ToBSpline(n4bsp);\n\t\tCHECK(bspCurve->Degree() == degree);\n\t\tCHECK(bspCurve->NPoles() == (pNum + 1));\n\t\tCHECK(bspCurve->NKnots() == (kNum + 1));\n\t\tdouble fp = n4bsp->FirstParameter();\n\t\tdouble lp = n4bsp->LastParameter();\n\t\tPoint3 p1 = n4bsp->Value(fp);\n\t\tPoint3 p2 = n4bsp->Value(lp);\n\t\tCHECK(p1.X() == sp.X());\n\t\tCHECK(p1.Y() == sp.Y());\n\t\tCHECK(p1.Z() == sp.Z());\n\t\tbool res1 = BRepClassificationTools::IsPointInFace(MakeFace(trimtp1, 0.0), p2);\n\t\tCHECK(res1 == true);\n\t\tPoint3 p3;\n\t\tVector3 vec;\n\t\tn4bsp->D1(lp, p3, vec);\n\t\tAxis3 axis = plane1->Axis();\n\t\tbool res2 = axis.Direction().IsParallel(Direction3(vec), Precision::Angular());\n\t\tCHECK(res2 == true);\n\t\tOCCTIO::OCCTTool::Write(MakeVertex(sp), outdir + \"sp.brep\");\n\t\tOCCTIO::OCCTTool::Write(MakeVertex(ep), outdir + \"ep.brep\");\n\t\tOCCTIO::OCCTTool::Write(MakeVertex(p1), outdir + \"p1.brep\");\n\t\tOCCTIO::OCCTTool::Write(MakeVertex(p2), outdir + \"p2.brep\");\n\t\tOCCTIO::OCCTTool::Write(MakeEdge(bsp), outdir + \"src.brep\");\n\t\tOCCTIO::OCCTTool::Write(MakeFace(trimtp1, 0.0), outdir + \"trimtp1.brep\");\n\t\tOCCTIO::OCCTTool::Write(MakeEdge(n4bsp), outdir + \"result.brep\");\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static Array2<std::shared_ptr<Geom3BSplineSurface>> ExplodeSurface(const std::shared_ptr<Geom3BSplineSurface>& surface)\t @return The result surfaces\n\t @param surface The given surface\n\t @brief Explode a surface into patches at C0 isocurves\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <nurbs/NURBSAPIExplode.hpp>\n#include <topology/TopoEdge.hpp>\n#include <topology/TopoTool.hpp>\n#include <nurbs/NURBSAPIJoin.hpp>\n#include <nurbs/NURBSAPIExplode.hpp>\n#include <geometry/Geom3BSplineCurve.hpp>\n#include <geometry/Geom3BSplineSurface.hpp>\n#include <topology/TopoFace.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeFace.hpp>\n#include<catch.hpp>\n#include<testHelper.h>\n#include <nurbs/NURBSAPIExplode.hpp>\n#include <topology/TopoEdge.hpp>\n#include <topology/TopoTool.hpp>\n#include <nurbs/NURBSAPIJoin.hpp>\n#include <nurbs/NURBSAPIExplode.hpp>\n#include <geometry/Geom3BSplineCurve.hpp>\n#include <geometry/Geom3BSplineSurface.hpp>\n#include <topology/TopoFace.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeFace.hpp>\n;\n\tSECTION(\"isUPeriodic+nonVPeriodic\")\n\t{\n\t\tOUTPUT_DIRECTORY(nurbs, Explode/ExplodeSurface3);\n\t\tstring filedir = INPUT_PATH_PREFIX\"./TestNURBS/TestJoinSurface/\";\n\t\tstd::vector<std::shared_ptr<Geom3BSplineSurface>> surfaces;\n\t\tsurfaces.push_back(ReadBRepSurface(filedir + \"surface0.brep\"));\n\t\tsurfaces.push_back(ReadBRepSurface(filedir + \"surface1.brep\"));\n\t\tsurfaces.push_back(ReadBRepSurface(filedir + \"surface2.brep\"));\n\t\tsurfaces.push_back(ReadBRepSurface(filedir + \"surface3.brep\"));\n\t\tauto [sortedSurfaces, isUIso, isFrontBackReverse, isIsoReverse, isLocalUPeriodic, isLocalVPeriodic] = NURBSAPIJoin::JoinSurfacesPrepare(surfaces, 0.0001);\n\t\tauto [isSucceed, result] = NURBSAPIJoin::JoinSurfaces(sortedSurfaces, isUIso, isFrontBackReverse, isIsoReverse, isLocalUPeriodic, isLocalVPeriodic);\n\t\tThrow_Construction_Error_if(!isSucceed, \"failed\");\n\t\tCHECK(isSucceed == true);\n\t\tauto explodeResult = NURBSAPIExplode::ExplodeSurface(result);\n\t\tint row = explodeResult.NRow();\n\t\tint col = explodeResult.NCol();\n\t\tfor (int i = 0; i < row; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < col; j++)\n\t\t\t{\n\t\t\t\tOCCTIO::OCCTTool::Write(MakeFace(explodeResult(i, j), 0.0), outdir +  \"expSurface\" + to_string(i) + to_string(j) +\".brep\");\n\t\t\t}\n\t\t}\n\t\tCHECK(row*col == 4);\n\t\tTopoShape f1 = MakeFace(surfaces[0],0.0);\n\t\tTopoShape f2 = MakeFace(surfaces[1], 0.0);\n\t\tTopoShape f3 = MakeFace(surfaces[2], 0.0);\n\t\tTopoShape f4 = MakeFace(surfaces[3], 0.0);\n\t\tTopoShape f = MakeFace(result,0.0);\n\t\tTopoShape exp1 = MakeFace(explodeResult(0, 0), 0.0);\n\t\tTopoShape exp2 = MakeFace(explodeResult(1, 0), 0.0);\n\t\tTopoShape exp3 = MakeFace(explodeResult(2, 0), 0.0);\n\t\tTopoShape exp4 = MakeFace(explodeResult(3, 0), 0.0);\n\t\tGlobalProperty props1, props2, props3, props4, props5, props6, props7, props8;\n\t\tdouble surf1 = GetSurfaceProperties(f1, props1, true, false);\n\t\tdouble surf2 = GetSurfaceProperties(f2, props2, true, false);\n\t\tdouble surf3 = GetSurfaceProperties(f3, props3, true, false);\n\t\tdouble surf4 = GetSurfaceProperties(f4, props4, true, false);\n\t\tdouble surface = GetSurfaceProperties(f, props5, true, false);\n\t\tdouble exSurf1 = GetSurfaceProperties(exp1, props5, true, false);\n\t\tdouble exSurf2 = GetSurfaceProperties(exp2, props6, true, false);\n\t\tdouble exSurf3 = GetSurfaceProperties(exp3, props7, true, false);\n\t\tdouble exSurf4 = GetSurfaceProperties(exp4, props8, true, false);\n\t\tdouble surf = surf1 + surf2 + surf3 + surf4;\n\t\tdouble dif = abs(surface - surf);\n\t\tdouble dif1 = abs(surf1 - exSurf1);\n\t\tdouble dif2 = abs(surf2 - exSurf2);\n\t\tdouble dif3 = abs(surf3 - exSurf3);\n\t\tdouble dif4 = abs(surf4 - exSurf4);\n\t\tCHECK(dif1 < 0.1);\n\t\tCHECK(dif2 < 0.1);\n\t\tCHECK(dif3 < 0.1);\n\t\tCHECK(dif4 < 0.1);\n\t\tdouble res1 = NurbsSampleSurface(num, sTol, surfaces[0], explodeResult(0, 0));\n\t\tdouble res2 = NurbsSampleSurface(num, sTol, surfaces[1], explodeResult(1, 0));\n\t\tdouble res3 = NurbsSampleSurface(num, sTol, surfaces[2], explodeResult(2, 0));\n\t\tdouble res4 = NurbsSampleSurface(num, sTol, surfaces[3], explodeResult(3, 0));\n\t\tCHECK(res1 <= ratio);\n\t\tCHECK(res2 <= ratio);\n\t\tCHECK(res3 <= ratio);\n\t\tCHECK(res4 <= ratio);\n\t\tOCCTIO::OCCTTool::Write(MakeFace(surfaces[0], 0.0), outdir + \"surf1.brep\");\n\t\tOCCTIO::OCCTTool::Write(MakeFace(surfaces[1], 0.0), outdir + \"surf2.brep\");\n\t\tOCCTIO::OCCTTool::Write(MakeFace(surfaces[2], 0.0), outdir + \"surf3.brep\");\n\t\tOCCTIO::OCCTTool::Write(MakeFace(surfaces[3], 0.0), outdir + \"surf4.brep\");\n\t\tOCCTIO::OCCTTool::Write(MakeFace(result, 0.0), outdir + \"joinSurface.brep\");\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static std::vector<std::shared_ptr<Geom3BSplineCurve>> ExplodeCurve(const std::shared_ptr<Geom3BSplineCurve>& curve)\t @return The result curves\n\t @param curve The given curve\n\t @brief Explode a curve into curves at C0 points\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <nurbs/NURBSAPIExplode.hpp>\n#include <topology/TopoEdge.hpp>\n#include <topology/TopoTool.hpp>\n#include <nurbs/NURBSAPIJoin.hpp>\n#include <nurbs/NURBSAPIExplode.hpp>\n#include <geometry/Geom3BSplineCurve.hpp>\n#include <geometry/Geom3BSplineSurface.hpp>\n#include <topology/TopoFace.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeFace.hpp>\n#include<catch.hpp>\n#include<testHelper.h>\n#include <nurbs/NURBSAPIExplode.hpp>\n#include <topology/TopoEdge.hpp>\n#include <topology/TopoTool.hpp>\n#include <nurbs/NURBSAPIJoin.hpp>\n#include <nurbs/NURBSAPIExplode.hpp>\n#include <geometry/Geom3BSplineCurve.hpp>\n#include <geometry/Geom3BSplineSurface.hpp>\n#include <topology/TopoFace.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeFace.hpp>\n;\n\tSECTION(\"isPeriodic\")\n\t{\n\t\tOUTPUT_DIRECTORY(nurbs, Explode/ExplodeCurve1);\n\t\tfilename = \"periodicCurve\";\n\t\tstd::vector<std::shared_ptr<Geom3BSplineCurve>> curves;\n\t\tfor (int i = 0; i < 3; i++)\n\t\t{\n\t\t\tcurves.push_back(ReadBRepCurve(filedir + filename + std::to_string(i) + \".brep\"));\n\t\t}\n\t\tauto [sortedCurves, isReverse, isResultPeriodic] = NURBSAPIJoin::JoinCurvePrepare(curves, 0.0001);\n\t\tauto results = NURBSAPIJoin::JoinCurves(sortedCurves, isReverse, isResultPeriodic);\n\t\tint nresults = static_cast<int>(results.size());\n\t\tfor (int i = 0; i < nresults; i++)\n\t\t{\n\t\t\tOCCTIO::OCCTTool::Write(MakeEdge(results[i]), outdir + \"joinCurve\" + to_string(i) + \".brep\");\n\t\t}\n\t\tauto explodeResult = NURBSAPIExplode::ExplodeCurve(results.front());\n\t\tint expResults = static_cast<int>(explodeResult.size());\n\t\tfor (int j = 0; j < expResults; j++)\n\t\t{\n\t\t\tOCCTIO::OCCTTool::Write(MakeEdge(explodeResult[j]), outdir + \"expCurve\" + to_string(j) + \".brep\");\n\t\t}\n\t\tCHECK(results.size() == 1);\n\t\tCHECK(explodeResult.size() == 3);\n\t\tPoint3 p1, p2, p3, p4;\n\t\tp1 = curves[0]->StartPoint();\n\t\tp2 = curves[2]->EndPoint();\n\t\tp3 = results[0]->StartPoint();\n\t\tp4 = results[0]->EndPoint();\n\t\tCHECK(p1.X() == Approx(p3.X()));\n\t\tCHECK(p1.Y() == Approx(p3.Y()));\n\t\tCHECK(p1.Z() == Approx(p3.Z()));\n\t\tCHECK(p2.X() == Approx(p4.X()));\n\t\tCHECK(p2.Y() == Approx(p4.Y()));\n\t\tCHECK(p2.Z() == Approx(p4.Z()));\n\t\tTopoShape c1 = MakeEdge(curves[0]);\n\t\tTopoShape c2 = MakeEdge(curves[1]);\n\t\tTopoShape c3 = MakeEdge(curves[2]);\n\t\tTopoShape c = MakeEdge(results[0]);\n\t\tTopoShape e1 = MakeEdge(explodeResult[0]);\n\t\tTopoShape e2 = MakeEdge(explodeResult[1]);\n\t\tTopoShape e3 = MakeEdge(explodeResult[2]);\n\t\tGlobalProperty props1, props2, props3, props4, props5, props6, props7;\n\t\tdouble len1 = GetLinearProperties(c1, props1, true, false);\n\t\tdouble len2 = GetLinearProperties(c2, props2, true, false);\n\t\tdouble len3 = GetLinearProperties(c3, props3, true, false);\n\t\tdouble joinLen = GetLinearProperties(c, props4, true, false);\n\t\tdouble exLen1 = GetLinearProperties(e1, props5, true, false);\n\t\tdouble exLen2 = GetLinearProperties(e2, props6, true, false);\n\t\tdouble exLen3 = GetLinearProperties(e3, props7, true, false);\n\t\tdouble cuvLen = len1 + len2 + len3;\n\t\tdouble len = abs(cuvLen - joinLen);\n\t\tdouble len11 = abs(len1 - exLen1);\n\t\tdouble len22 = abs(len2 - exLen2);\n\t\tdouble len33 = abs(len3 - exLen3);\n\t\tCHECK(len < 0.1);\n\t\tCHECK(len11 < 0.1);\n\t\tCHECK(len22 < 0.1);\n\t\tCHECK(len33 < 0.1);\n\t\tdouble res1 = NurbsSampleCurve(num, sTol, curves[0], explodeResult[0]);\n\t\tdouble res2 = NurbsSampleCurve(num, sTol, curves[1], explodeResult[1]);\n\t\tdouble res3 = NurbsSampleCurve(num, sTol, curves[2], explodeResult[2]);\n\t\tCHECK(res1 <= ratio);\n\t\tCHECK(res2 <= ratio);\n\t\tCHECK(res3 <= ratio);\n\t\tOCCTIO::OCCTTool::Write(MakeEdge(curves[0]), outdir + \"curve0.brep\");\n\t\tOCCTIO::OCCTTool::Write(MakeEdge(curves[1]), outdir + \"curve1.brep\");\n\t\tOCCTIO::OCCTTool::Write(MakeEdge(curves[2]), outdir + \"curve2.brep\");\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static std::pair<NURBSSweepStatus, std::vector<std::shared_ptr<Geom3BSplineSurface>>> SweepWithPullingDirection( const std::shared_ptr<Geom3BSplineCurve>& profile, const std::shared_ptr<Geom3BSplineCurve>& guide, const Direction3& direction, const LawFunction& angleLawFunc, const std::shared_ptr<Geom3BSplineCurve>& spine, double spineLeftBound, double spineRightBound),\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <filesystem>\n#include <fstream>\n#include <random>\n#include <sstream>\n#include <nurbs/NURBSAPIGetGeometry.hpp>\n#include <nurbs/NURBSAPIConicalSweep.hpp>\n#include <boolean/BoolBRepCut.hpp>\n#include <common/CartesianCoordinateSystem.hpp>\n#include <common/IndexMap.hpp>\n#include <common/QuaternionT.hpp>\n#include <geomAlgo/LawBSpline.hpp>\n#include <geomAlgo/LawConstant.hpp>\n#include <nurbs/NURBSAPISmooth.hpp>\n#include <geomAlgo/MakeConic2FromConstraints.hpp>\n#include <geometry/Adaptor3CurveOnSurface.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/AdaptorGeom3Surface.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2Circle.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/Geom2Hyperbola.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3BSplineCurve.hpp>\n#include <geometry/Geom3BSplineSurface.hpp>\n#include <geometry/Geom3Circle.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\n#include <geometry/Geom3Plane.hpp>\n#include <geometry/Geom3SphericalSurface.hpp>\n#include <geometry/Geom3Surface.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include <geometry/Geom3TrimmedSurface.hpp>\n#include <geometry/GeomAPIExtremaCurveCurve3.hpp>\n#include <geometry/GeomAPIProjectPointOnCurve2.hpp>\n#include <geometry/GeomAPIProjectPointOnCurve3.hpp>\n#include <geometry/GeomAPIProjectPointOnSurface.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/GlobalProperty.hpp>\n#include <healing/ShapeFixTool.hpp>\n#include <io/STLTool.hpp>\n#include <math/Sphere.hpp>\n#include <math/TriangularMesh.hpp>\n#include <modeling/CopyShape.hpp>\n#include <modeling/MakeBox.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeFace.hpp>\n#include <modeling/MakePrism.hpp>\n#include <modeling/MakeRevol.hpp>\n#include <modeling/MakeShapeTool.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <modeling/MakeWire.hpp>\n#include <modeling/TransformShape.hpp>\n#include <nurbs/NURBSAPIApprox.hpp>\n#include <nurbs/NURBSAPIBuildCurve.hpp>\n#include <nurbs/NURBSAPICircularSweep.hpp>\n#include <nurbs/NURBSAPIConvert.hpp>\n#include <nurbs/NURBSAPICurveNetworkSurface.hpp>\n#include <nurbs/NURBSAPIExplicitSweep.hpp>\n#include <nurbs/NURBSAPIExplode.hpp>\n#include <nurbs/NURBSAPIExtend.hpp>\n#include <nurbs/NURBSAPIInterpolate.hpp>\n#include <nurbs/NURBSAPIJoin.hpp>\n#include <nurbs/NURBSAPILinearSweep.hpp>\n#include <nurbs/NURBSAPILoft.hpp>\n#include <nurbs/NURBSAPIMakeNURBSFromBoundaries.hpp>\n#include <nurbs/NURBSAPIMatch.hpp>\n#include <nurbs/NURBSAPIModifyEndToPlane.hpp>\n#include <nurbs/NURBSAPIOffsetCurveOnSurface.hpp>\n#include <nurbs/NURBSAPIProject.hpp>\n#include <nurbs/NURBSAPIRebuild.hpp>\n#include <nurbs/NURBSAPIReplaceEdge.hpp>\n#include <nurbs/NURBSAPISweep.hpp>\n#include <nurbs/NURBSAPISweep2.hpp>\n#include <nurbs/NURBSAPISweepRotation.hpp>\n#include <nurbs/NURBSAPITrim.hpp>\n#include <nurbs/NURBSAPIUntrim.hpp>\n#include <nurbs/NURBSLinearSweepWithDraftDirectionLength.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <offset/MakePipe.hpp>\n#include <offset/MakePipeShell.hpp>\n#include <topology/BRepAdaptorCurve2.hpp>\n#include <topology/BRepAdaptorCurve3.hpp>\n#include <topology/BRepAdaptorSurface.hpp>\n#include <topology/BRepGlobalProperty.hpp>\n#include <topology/BRepTool.hpp>\n#include <topology/TopoBuilder.hpp>\n#include <topology/TopoCompound.hpp>\n#include <topology/TopoEdge.hpp>\n#include <topology/TopoExplorer.hpp>\n#include <topology/TopoExplorerTool.hpp>\n#include <topology/TopoFace.hpp>\n#include <topology/TopoShape.hpp>\n#include <topology/TopoShell.hpp>\n#include <topology/TopoTool.hpp>\n#include <topology/TopoVertex.hpp>\n#include <topology/TopoWire.hpp>\n#include <topology/WireExplorer.hpp>\n#include <topomesh/BRepMeshIncrementalMesh.hpp>\n#include <nurbs/NURBSAPIBlend.hpp>\n#include <topology/BRepExtremaDistShapeShape.hpp>\n#include <math/LineT.hpp>\n#include <hatch/BRepClassificationTools.hpp>\nusing namespace AMCAX;\nnamespace\n{\n\tstd::shared_ptr<Geom3BSplineCurve> CurveChooser(const int id, const std::shared_ptr<Geom3BSplineCurve>& curve0, const std::shared_ptr<Geom3BSplineCurve>& curve1, const std::shared_ptr<Geom3BSplineCurve>& curve2)\n\t{\n\t\tstd::shared_ptr<Geom3BSplineCurve> result;\n\t\tswitch (id)\n\t\t{\n\t\tcase 0:\n\t\t{\n\t\t\tresult = curve0;\n\t\t\tbreak;\n\t\t}\n\t\tcase 1:\n\t\t{\n\t\t\tresult = curve1;\n\t\t\tbreak;\n\t\t}\n\t\tcase 2:\n\t\t{\n\t\t\tresult = curve2;\n\t\t\tbreak;\n\t\t}\n\t\t}\n\t\treturn result;\n\t}\n} \n#include<catch.hpp>\n#include<testHelper.h>\n#include <filesystem>\n#include <fstream>\n#include <random>\n#include <sstream>\n#include <nurbs/NURBSAPIGetGeometry.hpp>\n#include <nurbs/NURBSAPIConicalSweep.hpp>\n#include <boolean/BoolBRepCut.hpp>\n#include <common/CartesianCoordinateSystem.hpp>\n#include <common/IndexMap.hpp>\n#include <common/QuaternionT.hpp>\n#include <geomAlgo/LawBSpline.hpp>\n#include <geomAlgo/LawConstant.hpp>\n#include <nurbs/NURBSAPISmooth.hpp>\n#include <geomAlgo/MakeConic2FromConstraints.hpp>\n#include <geometry/Adaptor3CurveOnSurface.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/AdaptorGeom3Surface.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2Circle.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/Geom2Hyperbola.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3BSplineCurve.hpp>\n#include <geometry/Geom3BSplineSurface.hpp>\n#include <geometry/Geom3Circle.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\n#include <geometry/Geom3Plane.hpp>\n#include <geometry/Geom3SphericalSurface.hpp>\n#include <geometry/Geom3Surface.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include <geometry/Geom3TrimmedSurface.hpp>\n#include <geometry/GeomAPIExtremaCurveCurve3.hpp>\n#include <geometry/GeomAPIProjectPointOnCurve2.hpp>\n#include <geometry/GeomAPIProjectPointOnCurve3.hpp>\n#include <geometry/GeomAPIProjectPointOnSurface.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/GlobalProperty.hpp>\n#include <healing/ShapeFixTool.hpp>\n#include <io/STLTool.hpp>\n#include <math/Sphere.hpp>\n#include <math/TriangularMesh.hpp>\n#include <modeling/CopyShape.hpp>\n#include <modeling/MakeBox.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeFace.hpp>\n#include <modeling/MakePrism.hpp>\n#include <modeling/MakeRevol.hpp>\n#include <modeling/MakeShapeTool.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <modeling/MakeWire.hpp>\n#include <modeling/TransformShape.hpp>\n#include <nurbs/NURBSAPIApprox.hpp>\n#include <nurbs/NURBSAPIBuildCurve.hpp>\n#include <nurbs/NURBSAPICircularSweep.hpp>\n#include <nurbs/NURBSAPIConvert.hpp>\n#include <nurbs/NURBSAPICurveNetworkSurface.hpp>\n#include <nurbs/NURBSAPIExplicitSweep.hpp>\n#include <nurbs/NURBSAPIExplode.hpp>\n#include <nurbs/NURBSAPIExtend.hpp>\n#include <nurbs/NURBSAPIInterpolate.hpp>\n#include <nurbs/NURBSAPIJoin.hpp>\n#include <nurbs/NURBSAPILinearSweep.hpp>\n#include <nurbs/NURBSAPILoft.hpp>\n#include <nurbs/NURBSAPIMakeNURBSFromBoundaries.hpp>\n#include <nurbs/NURBSAPIMatch.hpp>\n#include <nurbs/NURBSAPIModifyEndToPlane.hpp>\n#include <nurbs/NURBSAPIOffsetCurveOnSurface.hpp>\n#include <nurbs/NURBSAPIProject.hpp>\n#include <nurbs/NURBSAPIRebuild.hpp>\n#include <nurbs/NURBSAPIReplaceEdge.hpp>\n#include <nurbs/NURBSAPISweep.hpp>\n#include <nurbs/NURBSAPISweep2.hpp>\n#include <nurbs/NURBSAPISweepRotation.hpp>\n#include <nurbs/NURBSAPITrim.hpp>\n#include <nurbs/NURBSAPIUntrim.hpp>\n#include <nurbs/NURBSLinearSweepWithDraftDirectionLength.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <offset/MakePipe.hpp>\n#include <offset/MakePipeShell.hpp>\n#include <topology/BRepAdaptorCurve2.hpp>\n#include <topology/BRepAdaptorCurve3.hpp>\n#include <topology/BRepAdaptorSurface.hpp>\n#include <topology/BRepGlobalProperty.hpp>\n#include <topology/BRepTool.hpp>\n#include <topology/TopoBuilder.hpp>\n#include <topology/TopoCompound.hpp>\n#include <topology/TopoEdge.hpp>\n#include <topology/TopoExplorer.hpp>\n#include <topology/TopoExplorerTool.hpp>\n#include <topology/TopoFace.hpp>\n#include <topology/TopoShape.hpp>\n#include <topology/TopoShell.hpp>\n#include <topology/TopoTool.hpp>\n#include <topology/TopoVertex.hpp>\n#include <topology/TopoWire.hpp>\n#include <topology/WireExplorer.hpp>\n#include <topomesh/BRepMeshIncrementalMesh.hpp>\n#include <nurbs/NURBSAPIBlend.hpp>\n#include <topology/BRepExtremaDistShapeShape.hpp>\n#include <math/LineT.hpp>\n#include <hatch/BRepClassificationTools.hpp>\nusing namespace AMCAX;\nnamespace\n{\n\tstd::shared_ptr<Geom3BSplineCurve> CurveChooser(const int id, const std::shared_ptr<Geom3BSplineCurve>& curve0, const std::shared_ptr<Geom3BSplineCurve>& curve1, const std::shared_ptr<Geom3BSplineCurve>& curve2)\n\t{\n\t\tstd::shared_ptr<Geom3BSplineCurve> result;\n\t\tswitch (id)\n\t\t{\n\t\tcase 0:\n\t\t{\n\t\t\tresult = curve0;\n\t\t\tbreak;\n\t\t}\n\t\tcase 1:\n\t\t{\n\t\t\tresult = curve1;\n\t\t\tbreak;\n\t\t}\n\t\tcase 2:\n\t\t{\n\t\t\tresult = curve2;\n\t\t\tbreak;\n\t\t}\n\t\t}\n\t\treturn result;\n\t}\n;\n\tSECTION(\"TestExplicitSweepWithPullingDirection()\")\n\t{\n\t\tstd::string filedir = INPUT_PATH_PREFIX \"/TestNURBS/TestExplicitSweepWithPullingDirection/\";\n\t\tauto guide = ReadBRepCurve(filedir + \"guide.brep\");\n\t\tCHECK(OCCTIO::OCCTTool::Write(MakeEdge(guide), OUTPUT_PATH_PREFIX \"TestExplicitSweepWithPullingDirection_guide.brep\"));\n\t\tauto profile = ReadBRepCurve(filedir + \"profile.brep\");\n\t\tCHECK(OCCTIO::OCCTTool::Write(MakeEdge(profile), OUTPUT_PATH_PREFIX \"TestExplicitSweepWithPullingDirection_profile.brep\"));\n\t\tauto spineLineEdge = ReadBRepEdge(filedir + \"spine.brep\");\n\t\tdouble fp, lp;\n\t\tauto spineLine = TopoTool::Curve(spineLineEdge, fp, lp);\n\t\tauto spine = NURBSAPIConvert::ToBSpline(std::make_shared<Geom3TrimmedCurve>(spineLine, 0, 3));\n\t\tCHECK(OCCTIO::OCCTTool::Write(MakeEdge(spine), OUTPUT_PATH_PREFIX \"TestExplicitSweepWithPullingDirection_spine.brep\"));\n\t\tauto pullingDirectionEdge = ReadBRepEdge(filedir + \"pullingDirection.brep\");\n\t\tauto dirCurve = TopoTool::Curve(pullingDirectionEdge, fp, lp);\n\t\tPoint3 p1, p2;\n\t\tVector3 d1, d2;\n\t\tdirCurve->D1(0.0, p1, d1);\n\t\tdirCurve->D1(1.0, p2, d2);\n\t\tDirection3 pullingDirection(d1);\n\t\tLawConstant law;\n\t\tlaw.Set(0.0, 0.0, 1.0);\n\t\tauto [status, surfaces] = NURBSAPIExplicitSweep::SweepWithPullingDirection(profile, guide, pullingDirection, law, spine, spine->FirstParameter(), spine->LastParameter());\n\t\tCHECK(status == NURBSSweepStatus::Success);\n\t\tif (status == NURBSSweepStatus::Success)\n\t\t{\n\t\t\tfor (int i = 0; i < surfaces.size(); i++)\n\t\t\t{\n\t\t\t\tCHECK(OCCTIO::OCCTTool::Write(MakeFace(surfaces[i], 0.0), OUTPUT_PATH_PREFIX \"TestExplicitSweepWithPullingDirection_result\" + std::to_string(i) + \".brep\"));\n\t\t\t\tCHECK(IsCurveOnSurf(1000, 0.3, guide, surfaces[i], 0.1));\n\t\t\t\tAMCAX::BRepExtremaDistShapeShape len1(MakeFace(surfaces[i], 0.0), MakeEdge(guide));\n\t\t\t\tAMCAX::BRepExtremaDistShapeShape len2(MakeFace(surfaces[i], 0.0), MakeEdge(profile));\n\t\t\t\tCHECK(len1.Value() == Approx(0.0).margin(0.1));\n\t\t\t\tCHECK(len2.Value() == Approx(0.0).margin(0.1));\n\t\t\t\tif (i < 2) {\n\t\t\t\t\tCHECK(IsCurveOnSurf(1000, 0.1, profile, surfaces[i], 0.1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprofile->IncreaseDegree(5);\n\t\tguide->IncreaseDegree(5);\n\t\tspine->IncreaseDegree(5);\n\t\tauto [status1, surfaces1] = NURBSAPIExplicitSweep::SweepWithPullingDirection(profile, guide, pullingDirection, law, spine, spine->FirstParameter(), spine->LastParameter());\n\t\tCHECK(status1 == NURBSSweepStatus::Success);\n\t\tif (status1 == NURBSSweepStatus::Success)\n\t\t{\n\t\t\tfor (int i = 0; i < surfaces1.size(); i++)\n\t\t\t{\n\t\t\t\tCHECK(OCCTIO::OCCTTool::Write(MakeFace(surfaces1[i], 0.0), OUTPUT_PATH_PREFIX \"TestExplicitSweepWithPullingDirection_degree5result\" + std::to_string(i) + \".brep\"));\n\t\t\t\tCHECK(IsCurveOnSurf(1000, 0.3, guide, surfaces1[i], 0.1));\n\t\t\t\tAMCAX::BRepExtremaDistShapeShape len1(MakeFace(surfaces1[i], 0.0), MakeEdge(guide));\n\t\t\t\tAMCAX::BRepExtremaDistShapeShape len2(MakeFace(surfaces1[i], 0.0), MakeEdge(profile));\n\t\t\t\tCHECK(len1.Value() == Approx(0.0).margin(0.1));\n\t\t\t\tCHECK(len2.Value() == Approx(0.0).margin(0.1));\n\t\t\t\tif (i < 2) {\n\t\t\t\t\tCHECK(IsCurveOnSurf(1000, 0.1, profile, surfaces1[i], 0.1));\n\t\t\t\t\tdouble bsp3s = GetSurfaceProperties(MakeFace(surfaces1[i], 0.0), g, true, true);\n\t\t\t\t\tdouble bsp4s = GetSurfaceProperties(MakeFace(surfaces[i], 0.0), g, true, true);\n\t\t\t\t\tCHECK(bsp3s == Approx(bsp4s).margin(0.02));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static std::pair<NURBSSweepStatus, std::shared_ptr<Geom3BSplineSurface>> SweepWithTwoGuideCurves( const std::shared_ptr<Geom3BSplineCurve>& profile, const std::shared_ptr<Geom3BSplineCurve>& guide1, const std::shared_ptr<Geom3BSplineCurve>& guide2, Point3 anchorPoint, const Direction3& anchorDirection, const std::shared_ptr<Geom3BSplineCurve>& spine, double spineLeftBound, double spineRightBound),\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <filesystem>\n#include <fstream>\n#include <random>\n#include <sstream>\n#include <nurbs/NURBSAPIGetGeometry.hpp>\n#include <nurbs/NURBSAPIConicalSweep.hpp>\n#include <boolean/BoolBRepCut.hpp>\n#include <common/CartesianCoordinateSystem.hpp>\n#include <common/IndexMap.hpp>\n#include <common/QuaternionT.hpp>\n#include <geomAlgo/LawBSpline.hpp>\n#include <geomAlgo/LawConstant.hpp>\n#include <nurbs/NURBSAPISmooth.hpp>\n#include <geomAlgo/MakeConic2FromConstraints.hpp>\n#include <geometry/Adaptor3CurveOnSurface.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/AdaptorGeom3Surface.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2Circle.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/Geom2Hyperbola.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3BSplineCurve.hpp>\n#include <geometry/Geom3BSplineSurface.hpp>\n#include <geometry/Geom3Circle.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\n#include <geometry/Geom3Plane.hpp>\n#include <geometry/Geom3SphericalSurface.hpp>\n#include <geometry/Geom3Surface.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include <geometry/Geom3TrimmedSurface.hpp>\n#include <geometry/GeomAPIExtremaCurveCurve3.hpp>\n#include <geometry/GeomAPIProjectPointOnCurve2.hpp>\n#include <geometry/GeomAPIProjectPointOnCurve3.hpp>\n#include <geometry/GeomAPIProjectPointOnSurface.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/GlobalProperty.hpp>\n#include <healing/ShapeFixTool.hpp>\n#include <io/STLTool.hpp>\n#include <math/Sphere.hpp>\n#include <math/TriangularMesh.hpp>\n#include <modeling/CopyShape.hpp>\n#include <modeling/MakeBox.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeFace.hpp>\n#include <modeling/MakePrism.hpp>\n#include <modeling/MakeRevol.hpp>\n#include <modeling/MakeShapeTool.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <modeling/MakeWire.hpp>\n#include <modeling/TransformShape.hpp>\n#include <nurbs/NURBSAPIApprox.hpp>\n#include <nurbs/NURBSAPIBuildCurve.hpp>\n#include <nurbs/NURBSAPICircularSweep.hpp>\n#include <nurbs/NURBSAPIConvert.hpp>\n#include <nurbs/NURBSAPICurveNetworkSurface.hpp>\n#include <nurbs/NURBSAPIExplicitSweep.hpp>\n#include <nurbs/NURBSAPIExplode.hpp>\n#include <nurbs/NURBSAPIExtend.hpp>\n#include <nurbs/NURBSAPIInterpolate.hpp>\n#include <nurbs/NURBSAPIJoin.hpp>\n#include <nurbs/NURBSAPILinearSweep.hpp>\n#include <nurbs/NURBSAPILoft.hpp>\n#include <nurbs/NURBSAPIMakeNURBSFromBoundaries.hpp>\n#include <nurbs/NURBSAPIMatch.hpp>\n#include <nurbs/NURBSAPIModifyEndToPlane.hpp>\n#include <nurbs/NURBSAPIOffsetCurveOnSurface.hpp>\n#include <nurbs/NURBSAPIProject.hpp>\n#include <nurbs/NURBSAPIRebuild.hpp>\n#include <nurbs/NURBSAPIReplaceEdge.hpp>\n#include <nurbs/NURBSAPISweep.hpp>\n#include <nurbs/NURBSAPISweep2.hpp>\n#include <nurbs/NURBSAPISweepRotation.hpp>\n#include <nurbs/NURBSAPITrim.hpp>\n#include <nurbs/NURBSAPIUntrim.hpp>\n#include <nurbs/NURBSLinearSweepWithDraftDirectionLength.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <offset/MakePipe.hpp>\n#include <offset/MakePipeShell.hpp>\n#include <topology/BRepAdaptorCurve2.hpp>\n#include <topology/BRepAdaptorCurve3.hpp>\n#include <topology/BRepAdaptorSurface.hpp>\n#include <topology/BRepGlobalProperty.hpp>\n#include <topology/BRepTool.hpp>\n#include <topology/TopoBuilder.hpp>\n#include <topology/TopoCompound.hpp>\n#include <topology/TopoEdge.hpp>\n#include <topology/TopoExplorer.hpp>\n#include <topology/TopoExplorerTool.hpp>\n#include <topology/TopoFace.hpp>\n#include <topology/TopoShape.hpp>\n#include <topology/TopoShell.hpp>\n#include <topology/TopoTool.hpp>\n#include <topology/TopoVertex.hpp>\n#include <topology/TopoWire.hpp>\n#include <topology/WireExplorer.hpp>\n#include <topomesh/BRepMeshIncrementalMesh.hpp>\n#include <nurbs/NURBSAPIBlend.hpp>\n#include <topology/BRepExtremaDistShapeShape.hpp>\n#include <math/LineT.hpp>\n#include <hatch/BRepClassificationTools.hpp>\nusing namespace AMCAX;\nnamespace\n{\n\tstd::shared_ptr<Geom3BSplineCurve> CurveChooser(const int id, const std::shared_ptr<Geom3BSplineCurve>& curve0, const std::shared_ptr<Geom3BSplineCurve>& curve1, const std::shared_ptr<Geom3BSplineCurve>& curve2)\n\t{\n\t\tstd::shared_ptr<Geom3BSplineCurve> result;\n\t\tswitch (id)\n\t\t{\n\t\tcase 0:\n\t\t{\n\t\t\tresult = curve0;\n\t\t\tbreak;\n\t\t}\n\t\tcase 1:\n\t\t{\n\t\t\tresult = curve1;\n\t\t\tbreak;\n\t\t}\n\t\tcase 2:\n\t\t{\n\t\t\tresult = curve2;\n\t\t\tbreak;\n\t\t}\n\t\t}\n\t\treturn result;\n\t}\n} \n#include<catch.hpp>\n#include<testHelper.h>\n#include <filesystem>\n#include <fstream>\n#include <random>\n#include <sstream>\n#include <nurbs/NURBSAPIGetGeometry.hpp>\n#include <nurbs/NURBSAPIConicalSweep.hpp>\n#include <boolean/BoolBRepCut.hpp>\n#include <common/CartesianCoordinateSystem.hpp>\n#include <common/IndexMap.hpp>\n#include <common/QuaternionT.hpp>\n#include <geomAlgo/LawBSpline.hpp>\n#include <geomAlgo/LawConstant.hpp>\n#include <nurbs/NURBSAPISmooth.hpp>\n#include <geomAlgo/MakeConic2FromConstraints.hpp>\n#include <geometry/Adaptor3CurveOnSurface.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/AdaptorGeom3Surface.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2Circle.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/Geom2Hyperbola.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3BSplineCurve.hpp>\n#include <geometry/Geom3BSplineSurface.hpp>\n#include <geometry/Geom3Circle.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\n#include <geometry/Geom3Plane.hpp>\n#include <geometry/Geom3SphericalSurface.hpp>\n#include <geometry/Geom3Surface.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include <geometry/Geom3TrimmedSurface.hpp>\n#include <geometry/GeomAPIExtremaCurveCurve3.hpp>\n#include <geometry/GeomAPIProjectPointOnCurve2.hpp>\n#include <geometry/GeomAPIProjectPointOnCurve3.hpp>\n#include <geometry/GeomAPIProjectPointOnSurface.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/GlobalProperty.hpp>\n#include <healing/ShapeFixTool.hpp>\n#include <io/STLTool.hpp>\n#include <math/Sphere.hpp>\n#include <math/TriangularMesh.hpp>\n#include <modeling/CopyShape.hpp>\n#include <modeling/MakeBox.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeFace.hpp>\n#include <modeling/MakePrism.hpp>\n#include <modeling/MakeRevol.hpp>\n#include <modeling/MakeShapeTool.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <modeling/MakeWire.hpp>\n#include <modeling/TransformShape.hpp>\n#include <nurbs/NURBSAPIApprox.hpp>\n#include <nurbs/NURBSAPIBuildCurve.hpp>\n#include <nurbs/NURBSAPICircularSweep.hpp>\n#include <nurbs/NURBSAPIConvert.hpp>\n#include <nurbs/NURBSAPICurveNetworkSurface.hpp>\n#include <nurbs/NURBSAPIExplicitSweep.hpp>\n#include <nurbs/NURBSAPIExplode.hpp>\n#include <nurbs/NURBSAPIExtend.hpp>\n#include <nurbs/NURBSAPIInterpolate.hpp>\n#include <nurbs/NURBSAPIJoin.hpp>\n#include <nurbs/NURBSAPILinearSweep.hpp>\n#include <nurbs/NURBSAPILoft.hpp>\n#include <nurbs/NURBSAPIMakeNURBSFromBoundaries.hpp>\n#include <nurbs/NURBSAPIMatch.hpp>\n#include <nurbs/NURBSAPIModifyEndToPlane.hpp>\n#include <nurbs/NURBSAPIOffsetCurveOnSurface.hpp>\n#include <nurbs/NURBSAPIProject.hpp>\n#include <nurbs/NURBSAPIRebuild.hpp>\n#include <nurbs/NURBSAPIReplaceEdge.hpp>\n#include <nurbs/NURBSAPISweep.hpp>\n#include <nurbs/NURBSAPISweep2.hpp>\n#include <nurbs/NURBSAPISweepRotation.hpp>\n#include <nurbs/NURBSAPITrim.hpp>\n#include <nurbs/NURBSAPIUntrim.hpp>\n#include <nurbs/NURBSLinearSweepWithDraftDirectionLength.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <offset/MakePipe.hpp>\n#include <offset/MakePipeShell.hpp>\n#include <topology/BRepAdaptorCurve2.hpp>\n#include <topology/BRepAdaptorCurve3.hpp>\n#include <topology/BRepAdaptorSurface.hpp>\n#include <topology/BRepGlobalProperty.hpp>\n#include <topology/BRepTool.hpp>\n#include <topology/TopoBuilder.hpp>\n#include <topology/TopoCompound.hpp>\n#include <topology/TopoEdge.hpp>\n#include <topology/TopoExplorer.hpp>\n#include <topology/TopoExplorerTool.hpp>\n#include <topology/TopoFace.hpp>\n#include <topology/TopoShape.hpp>\n#include <topology/TopoShell.hpp>\n#include <topology/TopoTool.hpp>\n#include <topology/TopoVertex.hpp>\n#include <topology/TopoWire.hpp>\n#include <topology/WireExplorer.hpp>\n#include <topomesh/BRepMeshIncrementalMesh.hpp>\n#include <nurbs/NURBSAPIBlend.hpp>\n#include <topology/BRepExtremaDistShapeShape.hpp>\n#include <math/LineT.hpp>\n#include <hatch/BRepClassificationTools.hpp>\nusing namespace AMCAX;\nnamespace\n{\n\tstd::shared_ptr<Geom3BSplineCurve> CurveChooser(const int id, const std::shared_ptr<Geom3BSplineCurve>& curve0, const std::shared_ptr<Geom3BSplineCurve>& curve1, const std::shared_ptr<Geom3BSplineCurve>& curve2)\n\t{\n\t\tstd::shared_ptr<Geom3BSplineCurve> result;\n\t\tswitch (id)\n\t\t{\n\t\tcase 0:\n\t\t{\n\t\t\tresult = curve0;\n\t\t\tbreak;\n\t\t}\n\t\tcase 1:\n\t\t{\n\t\t\tresult = curve1;\n\t\t\tbreak;\n\t\t}\n\t\tcase 2:\n\t\t{\n\t\t\tresult = curve2;\n\t\t\tbreak;\n\t\t}\n\t\t}\n\t\treturn result;\n\t}\n;\n\tSECTION(\"TestExplicitSweepWithTwoGuideCurvesTwoPoints()\")\n\t{\n\t\tstd::string filedir = INPUT_PATH_PREFIX \"/TestNURBS/TestExplicitSweepWithTwoGuideCurvesTwoPoints/\";\n\t\tauto profile = ReadBRepCurve(filedir + \"profile.brep\");\n\t\tCHECK(OCCTIO::OCCTTool::Write(MakeEdge(profile), OUTPUT_PATH_PREFIX \"TestExplicitSweepWithTwoGuideCurvesTwoPoints_profile.brep\"));\n\t\tauto guide1 = ReadBRepCurve(filedir + \"guide1.brep\");\n\t\tCHECK(OCCTIO::OCCTTool::Write(MakeEdge(guide1), OUTPUT_PATH_PREFIX \"TestExplicitSweepWithTwoGuideCurvesTwoPoints_guide1.brep\"));\n\t\tauto guide2 = ReadBRepCurve(filedir + \"guide2.brep\");\n\t\tCHECK(OCCTIO::OCCTTool::Write(MakeEdge(guide2), OUTPUT_PATH_PREFIX \"TestExplicitSweepWithTwoGuideCurvesTwoPoints_guide2.brep\"));\n\t\tauto anchorPoint1 = ReadBRepPoint(filedir + \"point1.brep\");\n\t\tauto anchorPoint2 = ReadBRepPoint(filedir + \"point2.brep\");\n\t\tCHECK(OCCTIO::OCCTTool::Write(MakeVertex(anchorPoint1), OUTPUT_PATH_PREFIX \"TestExplicitSweepWithTwoGuideCurvesTwoPoints_point1.brep\"));\n\t\tCHECK(OCCTIO::OCCTTool::Write(MakeVertex(anchorPoint2), OUTPUT_PATH_PREFIX \"TestExplicitSweepWithTwoGuideCurvesTwoPoints_point2.brep\"));\n\t\tauto [status, surface] = NURBSAPIExplicitSweep::SweepWithTwoGuideCurves(profile, guide1, guide2, anchorPoint1, anchorPoint2, guide1, guide1->FirstParameter(), guide1->LastParameter());\n\t\tCHECK(status == NURBSSweepStatus::Success);\n\t\tif (status == NURBSSweepStatus::Success)\n\t\t{\n\t\t\tCHECK(OCCTIO::OCCTTool::Write(MakeFace(surface, 0.0), OUTPUT_PATH_PREFIX \"TestExplicitSweepWithTwoGuideCurvesTwoPoints_result.brep\"));\n\t\t\tAMCAX::BRepExtremaDistShapeShape len1(MakeFace(surface, 0.0), MakeEdge(guide1));\n\t\t\tAMCAX::BRepExtremaDistShapeShape len2(MakeFace(surface, 0.0), MakeEdge(guide2));\n\t\t\tAMCAX::BRepExtremaDistShapeShape len3(MakeFace(surface, 0.0), MakeEdge(profile));\n\t\t\tCHECK(len1.Value() == Approx(0.0).margin(0.1));\n\t\t\tCHECK(len2.Value() == Approx(0.0).margin(0.1));\n\t\t\tCHECK(len3.Value() == Approx(0.0).margin(0.1));\n\t\t}\n\t\tprofile->IncreaseDegree(11);\n\t\tguide1->IncreaseDegree(11);\n\t\tguide2->IncreaseDegree(11);\n\t\tauto [status1, surface1] = NURBSAPIExplicitSweep::SweepWithTwoGuideCurves(profile, guide1, guide2, anchorPoint1, anchorPoint2, guide1, guide1->FirstParameter(), guide1->LastParameter());\n\t\tCHECK(status1 == NURBSSweepStatus::Success);\n\t\tif (status1 == NURBSSweepStatus::Success)\n\t\t{\n\t\t\tCHECK(OCCTIO::OCCTTool::Write(MakeFace(surface1, 0.0), OUTPUT_PATH_PREFIX \"TestExplicitSweepWithTwoGuideCurvesTwoPoints_degree11result.brep\"));\n\t\t\tAMCAX::BRepExtremaDistShapeShape len1(MakeFace(surface1, 0.0), MakeEdge(guide1));\n\t\t\tAMCAX::BRepExtremaDistShapeShape len2(MakeFace(surface1, 0.0), MakeEdge(guide2));\n\t\t\tAMCAX::BRepExtremaDistShapeShape len3(MakeFace(surface1, 0.0), MakeEdge(profile));\n\t\t\tCHECK(len1.Value() == Approx(0.0).margin(0.1));\n\t\t\tCHECK(len2.Value() == Approx(0.0).margin(0.1));\n\t\t\tCHECK(len3.Value() == Approx(0.0).margin(0.1));\n\t\t\tdouble bsp3s = GetSurfaceProperties(MakeFace(surface1, 0.0), g, true, true);\n\t\t\tdouble bsp4s = GetSurfaceProperties(MakeFace(surface, 0.0), g, true, true);\n\t\t\tCHECK(bsp3s == Approx(bsp4s).margin(0.04));\n\t\t}\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static std::pair<NURBSSweepStatus, std::shared_ptr<Geom3BSplineSurface>> SweepWithTwoGuideCurves( const std::shared_ptr<Geom3BSplineCurve>& profile, const std::shared_ptr<Geom3BSplineCurve>& guide1, const std::shared_ptr<Geom3BSplineCurve>& guide2, Point3 anchorPoint1, Point3 anchorPoint2, const std::shared_ptr<Geom3BSplineCurve>& spine, double spineLeftBound, double spineRightBound),\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <filesystem>\n#include <fstream>\n#include <random>\n#include <sstream>\n#include <nurbs/NURBSAPIGetGeometry.hpp>\n#include <nurbs/NURBSAPIConicalSweep.hpp>\n#include <boolean/BoolBRepCut.hpp>\n#include <common/CartesianCoordinateSystem.hpp>\n#include <common/IndexMap.hpp>\n#include <common/QuaternionT.hpp>\n#include <geomAlgo/LawBSpline.hpp>\n#include <geomAlgo/LawConstant.hpp>\n#include <nurbs/NURBSAPISmooth.hpp>\n#include <geomAlgo/MakeConic2FromConstraints.hpp>\n#include <geometry/Adaptor3CurveOnSurface.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/AdaptorGeom3Surface.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2Circle.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/Geom2Hyperbola.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3BSplineCurve.hpp>\n#include <geometry/Geom3BSplineSurface.hpp>\n#include <geometry/Geom3Circle.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\n#include <geometry/Geom3Plane.hpp>\n#include <geometry/Geom3SphericalSurface.hpp>\n#include <geometry/Geom3Surface.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include <geometry/Geom3TrimmedSurface.hpp>\n#include <geometry/GeomAPIExtremaCurveCurve3.hpp>\n#include <geometry/GeomAPIProjectPointOnCurve2.hpp>\n#include <geometry/GeomAPIProjectPointOnCurve3.hpp>\n#include <geometry/GeomAPIProjectPointOnSurface.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/GlobalProperty.hpp>\n#include <healing/ShapeFixTool.hpp>\n#include <io/STLTool.hpp>\n#include <math/Sphere.hpp>\n#include <math/TriangularMesh.hpp>\n#include <modeling/CopyShape.hpp>\n#include <modeling/MakeBox.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeFace.hpp>\n#include <modeling/MakePrism.hpp>\n#include <modeling/MakeRevol.hpp>\n#include <modeling/MakeShapeTool.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <modeling/MakeWire.hpp>\n#include <modeling/TransformShape.hpp>\n#include <nurbs/NURBSAPIApprox.hpp>\n#include <nurbs/NURBSAPIBuildCurve.hpp>\n#include <nurbs/NURBSAPICircularSweep.hpp>\n#include <nurbs/NURBSAPIConvert.hpp>\n#include <nurbs/NURBSAPICurveNetworkSurface.hpp>\n#include <nurbs/NURBSAPIExplicitSweep.hpp>\n#include <nurbs/NURBSAPIExplode.hpp>\n#include <nurbs/NURBSAPIExtend.hpp>\n#include <nurbs/NURBSAPIInterpolate.hpp>\n#include <nurbs/NURBSAPIJoin.hpp>\n#include <nurbs/NURBSAPILinearSweep.hpp>\n#include <nurbs/NURBSAPILoft.hpp>\n#include <nurbs/NURBSAPIMakeNURBSFromBoundaries.hpp>\n#include <nurbs/NURBSAPIMatch.hpp>\n#include <nurbs/NURBSAPIModifyEndToPlane.hpp>\n#include <nurbs/NURBSAPIOffsetCurveOnSurface.hpp>\n#include <nurbs/NURBSAPIProject.hpp>\n#include <nurbs/NURBSAPIRebuild.hpp>\n#include <nurbs/NURBSAPIReplaceEdge.hpp>\n#include <nurbs/NURBSAPISweep.hpp>\n#include <nurbs/NURBSAPISweep2.hpp>\n#include <nurbs/NURBSAPISweepRotation.hpp>\n#include <nurbs/NURBSAPITrim.hpp>\n#include <nurbs/NURBSAPIUntrim.hpp>\n#include <nurbs/NURBSLinearSweepWithDraftDirectionLength.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <offset/MakePipe.hpp>\n#include <offset/MakePipeShell.hpp>\n#include <topology/BRepAdaptorCurve2.hpp>\n#include <topology/BRepAdaptorCurve3.hpp>\n#include <topology/BRepAdaptorSurface.hpp>\n#include <topology/BRepGlobalProperty.hpp>\n#include <topology/BRepTool.hpp>\n#include <topology/TopoBuilder.hpp>\n#include <topology/TopoCompound.hpp>\n#include <topology/TopoEdge.hpp>\n#include <topology/TopoExplorer.hpp>\n#include <topology/TopoExplorerTool.hpp>\n#include <topology/TopoFace.hpp>\n#include <topology/TopoShape.hpp>\n#include <topology/TopoShell.hpp>\n#include <topology/TopoTool.hpp>\n#include <topology/TopoVertex.hpp>\n#include <topology/TopoWire.hpp>\n#include <topology/WireExplorer.hpp>\n#include <topomesh/BRepMeshIncrementalMesh.hpp>\n#include <nurbs/NURBSAPIBlend.hpp>\n#include <topology/BRepExtremaDistShapeShape.hpp>\n#include <math/LineT.hpp>\n#include <hatch/BRepClassificationTools.hpp>\nusing namespace AMCAX;\nnamespace\n{\n\tstd::shared_ptr<Geom3BSplineCurve> CurveChooser(const int id, const std::shared_ptr<Geom3BSplineCurve>& curve0, const std::shared_ptr<Geom3BSplineCurve>& curve1, const std::shared_ptr<Geom3BSplineCurve>& curve2)\n\t{\n\t\tstd::shared_ptr<Geom3BSplineCurve> result;\n\t\tswitch (id)\n\t\t{\n\t\tcase 0:\n\t\t{\n\t\t\tresult = curve0;\n\t\t\tbreak;\n\t\t}\n\t\tcase 1:\n\t\t{\n\t\t\tresult = curve1;\n\t\t\tbreak;\n\t\t}\n\t\tcase 2:\n\t\t{\n\t\t\tresult = curve2;\n\t\t\tbreak;\n\t\t}\n\t\t}\n\t\treturn result;\n\t}\n} \n#include<catch.hpp>\n#include<testHelper.h>\n#include <filesystem>\n#include <fstream>\n#include <random>\n#include <sstream>\n#include <nurbs/NURBSAPIGetGeometry.hpp>\n#include <nurbs/NURBSAPIConicalSweep.hpp>\n#include <boolean/BoolBRepCut.hpp>\n#include <common/CartesianCoordinateSystem.hpp>\n#include <common/IndexMap.hpp>\n#include <common/QuaternionT.hpp>\n#include <geomAlgo/LawBSpline.hpp>\n#include <geomAlgo/LawConstant.hpp>\n#include <nurbs/NURBSAPISmooth.hpp>\n#include <geomAlgo/MakeConic2FromConstraints.hpp>\n#include <geometry/Adaptor3CurveOnSurface.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/AdaptorGeom3Surface.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2Circle.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/Geom2Hyperbola.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3BSplineCurve.hpp>\n#include <geometry/Geom3BSplineSurface.hpp>\n#include <geometry/Geom3Circle.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\n#include <geometry/Geom3Plane.hpp>\n#include <geometry/Geom3SphericalSurface.hpp>\n#include <geometry/Geom3Surface.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include <geometry/Geom3TrimmedSurface.hpp>\n#include <geometry/GeomAPIExtremaCurveCurve3.hpp>\n#include <geometry/GeomAPIProjectPointOnCurve2.hpp>\n#include <geometry/GeomAPIProjectPointOnCurve3.hpp>\n#include <geometry/GeomAPIProjectPointOnSurface.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/GlobalProperty.hpp>\n#include <healing/ShapeFixTool.hpp>\n#include <io/STLTool.hpp>\n#include <math/Sphere.hpp>\n#include <math/TriangularMesh.hpp>\n#include <modeling/CopyShape.hpp>\n#include <modeling/MakeBox.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeFace.hpp>\n#include <modeling/MakePrism.hpp>\n#include <modeling/MakeRevol.hpp>\n#include <modeling/MakeShapeTool.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <modeling/MakeWire.hpp>\n#include <modeling/TransformShape.hpp>\n#include <nurbs/NURBSAPIApprox.hpp>\n#include <nurbs/NURBSAPIBuildCurve.hpp>\n#include <nurbs/NURBSAPICircularSweep.hpp>\n#include <nurbs/NURBSAPIConvert.hpp>\n#include <nurbs/NURBSAPICurveNetworkSurface.hpp>\n#include <nurbs/NURBSAPIExplicitSweep.hpp>\n#include <nurbs/NURBSAPIExplode.hpp>\n#include <nurbs/NURBSAPIExtend.hpp>\n#include <nurbs/NURBSAPIInterpolate.hpp>\n#include <nurbs/NURBSAPIJoin.hpp>\n#include <nurbs/NURBSAPILinearSweep.hpp>\n#include <nurbs/NURBSAPILoft.hpp>\n#include <nurbs/NURBSAPIMakeNURBSFromBoundaries.hpp>\n#include <nurbs/NURBSAPIMatch.hpp>\n#include <nurbs/NURBSAPIModifyEndToPlane.hpp>\n#include <nurbs/NURBSAPIOffsetCurveOnSurface.hpp>\n#include <nurbs/NURBSAPIProject.hpp>\n#include <nurbs/NURBSAPIRebuild.hpp>\n#include <nurbs/NURBSAPIReplaceEdge.hpp>\n#include <nurbs/NURBSAPISweep.hpp>\n#include <nurbs/NURBSAPISweep2.hpp>\n#include <nurbs/NURBSAPISweepRotation.hpp>\n#include <nurbs/NURBSAPITrim.hpp>\n#include <nurbs/NURBSAPIUntrim.hpp>\n#include <nurbs/NURBSLinearSweepWithDraftDirectionLength.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <offset/MakePipe.hpp>\n#include <offset/MakePipeShell.hpp>\n#include <topology/BRepAdaptorCurve2.hpp>\n#include <topology/BRepAdaptorCurve3.hpp>\n#include <topology/BRepAdaptorSurface.hpp>\n#include <topology/BRepGlobalProperty.hpp>\n#include <topology/BRepTool.hpp>\n#include <topology/TopoBuilder.hpp>\n#include <topology/TopoCompound.hpp>\n#include <topology/TopoEdge.hpp>\n#include <topology/TopoExplorer.hpp>\n#include <topology/TopoExplorerTool.hpp>\n#include <topology/TopoFace.hpp>\n#include <topology/TopoShape.hpp>\n#include <topology/TopoShell.hpp>\n#include <topology/TopoTool.hpp>\n#include <topology/TopoVertex.hpp>\n#include <topology/TopoWire.hpp>\n#include <topology/WireExplorer.hpp>\n#include <topomesh/BRepMeshIncrementalMesh.hpp>\n#include <nurbs/NURBSAPIBlend.hpp>\n#include <topology/BRepExtremaDistShapeShape.hpp>\n#include <math/LineT.hpp>\n#include <hatch/BRepClassificationTools.hpp>\nusing namespace AMCAX;\nnamespace\n{\n\tstd::shared_ptr<Geom3BSplineCurve> CurveChooser(const int id, const std::shared_ptr<Geom3BSplineCurve>& curve0, const std::shared_ptr<Geom3BSplineCurve>& curve1, const std::shared_ptr<Geom3BSplineCurve>& curve2)\n\t{\n\t\tstd::shared_ptr<Geom3BSplineCurve> result;\n\t\tswitch (id)\n\t\t{\n\t\tcase 0:\n\t\t{\n\t\t\tresult = curve0;\n\t\t\tbreak;\n\t\t}\n\t\tcase 1:\n\t\t{\n\t\t\tresult = curve1;\n\t\t\tbreak;\n\t\t}\n\t\tcase 2:\n\t\t{\n\t\t\tresult = curve2;\n\t\t\tbreak;\n\t\t}\n\t\t}\n\t\treturn result;\n\t}\n;\n\tSECTION(\"TestExplicitSweepWithTwoGuideCurvesTwoPoints()\")\n\t{\n\t\tstd::string filedir = INPUT_PATH_PREFIX \"/TestNURBS/TestExplicitSweepWithTwoGuideCurvesTwoPoints/\";\n\t\tauto profile = ReadBRepCurve(filedir + \"profile.brep\");\n\t\tCHECK(OCCTIO::OCCTTool::Write(MakeEdge(profile), OUTPUT_PATH_PREFIX \"TestExplicitSweepWithTwoGuideCurvesTwoPoints_profile.brep\"));\n\t\tauto guide1 = ReadBRepCurve(filedir + \"guide1.brep\");\n\t\tCHECK(OCCTIO::OCCTTool::Write(MakeEdge(guide1), OUTPUT_PATH_PREFIX \"TestExplicitSweepWithTwoGuideCurvesTwoPoints_guide1.brep\"));\n\t\tauto guide2 = ReadBRepCurve(filedir + \"guide2.brep\");\n\t\tCHECK(OCCTIO::OCCTTool::Write(MakeEdge(guide2), OUTPUT_PATH_PREFIX \"TestExplicitSweepWithTwoGuideCurvesTwoPoints_guide2.brep\"));\n\t\tauto anchorPoint1 = ReadBRepPoint(filedir + \"point1.brep\");\n\t\tauto anchorPoint2 = ReadBRepPoint(filedir + \"point2.brep\");\n\t\tCHECK(OCCTIO::OCCTTool::Write(MakeVertex(anchorPoint1), OUTPUT_PATH_PREFIX \"TestExplicitSweepWithTwoGuideCurvesTwoPoints_point1.brep\"));\n\t\tCHECK(OCCTIO::OCCTTool::Write(MakeVertex(anchorPoint2), OUTPUT_PATH_PREFIX \"TestExplicitSweepWithTwoGuideCurvesTwoPoints_point2.brep\"));\n\t\tauto [status, surface] = NURBSAPIExplicitSweep::SweepWithTwoGuideCurves(profile, guide1, guide2, anchorPoint1, anchorPoint2, guide1, guide1->FirstParameter(), guide1->LastParameter());\n\t\tCHECK(status == NURBSSweepStatus::Success);\n\t\tif (status == NURBSSweepStatus::Success)\n\t\t{\n\t\t\tCHECK(OCCTIO::OCCTTool::Write(MakeFace(surface, 0.0), OUTPUT_PATH_PREFIX \"TestExplicitSweepWithTwoGuideCurvesTwoPoints_result.brep\"));\n\t\t\tAMCAX::BRepExtremaDistShapeShape len1(MakeFace(surface, 0.0), MakeEdge(guide1));\n\t\t\tAMCAX::BRepExtremaDistShapeShape len2(MakeFace(surface, 0.0), MakeEdge(guide2));\n\t\t\tAMCAX::BRepExtremaDistShapeShape len3(MakeFace(surface, 0.0), MakeEdge(profile));\n\t\t\tCHECK(len1.Value() == Approx(0.0).margin(0.1));\n\t\t\tCHECK(len2.Value() == Approx(0.0).margin(0.1));\n\t\t\tCHECK(len3.Value() == Approx(0.0).margin(0.1));\n\t\t}\n\t\tprofile->IncreaseDegree(11);\n\t\tguide1->IncreaseDegree(11);\n\t\tguide2->IncreaseDegree(11);\n\t\tauto [status1, surface1] = NURBSAPIExplicitSweep::SweepWithTwoGuideCurves(profile, guide1, guide2, anchorPoint1, anchorPoint2, guide1, guide1->FirstParameter(), guide1->LastParameter());\n\t\tCHECK(status1 == NURBSSweepStatus::Success);\n\t\tif (status1 == NURBSSweepStatus::Success)\n\t\t{\n\t\t\tCHECK(OCCTIO::OCCTTool::Write(MakeFace(surface1, 0.0), OUTPUT_PATH_PREFIX \"TestExplicitSweepWithTwoGuideCurvesTwoPoints_degree11result.brep\"));\n\t\t\tAMCAX::BRepExtremaDistShapeShape len1(MakeFace(surface1, 0.0), MakeEdge(guide1));\n\t\t\tAMCAX::BRepExtremaDistShapeShape len2(MakeFace(surface1, 0.0), MakeEdge(guide2));\n\t\t\tAMCAX::BRepExtremaDistShapeShape len3(MakeFace(surface1, 0.0), MakeEdge(profile));\n\t\t\tCHECK(len1.Value() == Approx(0.0).margin(0.1));\n\t\t\tCHECK(len2.Value() == Approx(0.0).margin(0.1));\n\t\t\tCHECK(len3.Value() == Approx(0.0).margin(0.1));\n\t\t\tdouble bsp3s = GetSurfaceProperties(MakeFace(surface1, 0.0), g, true, true);\n\t\t\tdouble bsp4s = GetSurfaceProperties(MakeFace(surface, 0.0), g, true, true);\n\t\t\tCHECK(bsp3s == Approx(bsp4s).margin(0.04));\n\t\t}\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static std::pair<NURBSSweepStatus, std::vector<std::shared_ptr<Geom3BSplineSurface>>> SweepWithReferenceSurface( const std::shared_ptr<Geom3BSplineCurve>& profile, const std::shared_ptr<Geom3BSplineCurve>& guide, const std::shared_ptr<Geom3BSplineSurface>& reference, const LawFunction& angleLawFunc, const std::shared_ptr<Geom3BSplineCurve>& spine, double spineLeftBound, double spineRightBound),\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <filesystem>\n#include <fstream>\n#include <random>\n#include <sstream>\n#include <nurbs/NURBSAPIGetGeometry.hpp>\n#include <nurbs/NURBSAPIConicalSweep.hpp>\n#include <boolean/BoolBRepCut.hpp>\n#include <common/CartesianCoordinateSystem.hpp>\n#include <common/IndexMap.hpp>\n#include <common/QuaternionT.hpp>\n#include <geomAlgo/LawBSpline.hpp>\n#include <geomAlgo/LawConstant.hpp>\n#include <nurbs/NURBSAPISmooth.hpp>\n#include <geomAlgo/MakeConic2FromConstraints.hpp>\n#include <geometry/Adaptor3CurveOnSurface.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/AdaptorGeom3Surface.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2Circle.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/Geom2Hyperbola.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3BSplineCurve.hpp>\n#include <geometry/Geom3BSplineSurface.hpp>\n#include <geometry/Geom3Circle.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\n#include <geometry/Geom3Plane.hpp>\n#include <geometry/Geom3SphericalSurface.hpp>\n#include <geometry/Geom3Surface.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include <geometry/Geom3TrimmedSurface.hpp>\n#include <geometry/GeomAPIExtremaCurveCurve3.hpp>\n#include <geometry/GeomAPIProjectPointOnCurve2.hpp>\n#include <geometry/GeomAPIProjectPointOnCurve3.hpp>\n#include <geometry/GeomAPIProjectPointOnSurface.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/GlobalProperty.hpp>\n#include <healing/ShapeFixTool.hpp>\n#include <io/STLTool.hpp>\n#include <math/Sphere.hpp>\n#include <math/TriangularMesh.hpp>\n#include <modeling/CopyShape.hpp>\n#include <modeling/MakeBox.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeFace.hpp>\n#include <modeling/MakePrism.hpp>\n#include <modeling/MakeRevol.hpp>\n#include <modeling/MakeShapeTool.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <modeling/MakeWire.hpp>\n#include <modeling/TransformShape.hpp>\n#include <nurbs/NURBSAPIApprox.hpp>\n#include <nurbs/NURBSAPIBuildCurve.hpp>\n#include <nurbs/NURBSAPICircularSweep.hpp>\n#include <nurbs/NURBSAPIConvert.hpp>\n#include <nurbs/NURBSAPICurveNetworkSurface.hpp>\n#include <nurbs/NURBSAPIExplicitSweep.hpp>\n#include <nurbs/NURBSAPIExplode.hpp>\n#include <nurbs/NURBSAPIExtend.hpp>\n#include <nurbs/NURBSAPIInterpolate.hpp>\n#include <nurbs/NURBSAPIJoin.hpp>\n#include <nurbs/NURBSAPILinearSweep.hpp>\n#include <nurbs/NURBSAPILoft.hpp>\n#include <nurbs/NURBSAPIMakeNURBSFromBoundaries.hpp>\n#include <nurbs/NURBSAPIMatch.hpp>\n#include <nurbs/NURBSAPIModifyEndToPlane.hpp>\n#include <nurbs/NURBSAPIOffsetCurveOnSurface.hpp>\n#include <nurbs/NURBSAPIProject.hpp>\n#include <nurbs/NURBSAPIRebuild.hpp>\n#include <nurbs/NURBSAPIReplaceEdge.hpp>\n#include <nurbs/NURBSAPISweep.hpp>\n#include <nurbs/NURBSAPISweep2.hpp>\n#include <nurbs/NURBSAPISweepRotation.hpp>\n#include <nurbs/NURBSAPITrim.hpp>\n#include <nurbs/NURBSAPIUntrim.hpp>\n#include <nurbs/NURBSLinearSweepWithDraftDirectionLength.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <offset/MakePipe.hpp>\n#include <offset/MakePipeShell.hpp>\n#include <topology/BRepAdaptorCurve2.hpp>\n#include <topology/BRepAdaptorCurve3.hpp>\n#include <topology/BRepAdaptorSurface.hpp>\n#include <topology/BRepGlobalProperty.hpp>\n#include <topology/BRepTool.hpp>\n#include <topology/TopoBuilder.hpp>\n#include <topology/TopoCompound.hpp>\n#include <topology/TopoEdge.hpp>\n#include <topology/TopoExplorer.hpp>\n#include <topology/TopoExplorerTool.hpp>\n#include <topology/TopoFace.hpp>\n#include <topology/TopoShape.hpp>\n#include <topology/TopoShell.hpp>\n#include <topology/TopoTool.hpp>\n#include <topology/TopoVertex.hpp>\n#include <topology/TopoWire.hpp>\n#include <topology/WireExplorer.hpp>\n#include <topomesh/BRepMeshIncrementalMesh.hpp>\n#include <nurbs/NURBSAPIBlend.hpp>\n#include <topology/BRepExtremaDistShapeShape.hpp>\n#include <math/LineT.hpp>\n#include <hatch/BRepClassificationTools.hpp>\nusing namespace AMCAX;\nnamespace\n{\n\tstd::shared_ptr<Geom3BSplineCurve> CurveChooser(const int id, const std::shared_ptr<Geom3BSplineCurve>& curve0, const std::shared_ptr<Geom3BSplineCurve>& curve1, const std::shared_ptr<Geom3BSplineCurve>& curve2)\n\t{\n\t\tstd::shared_ptr<Geom3BSplineCurve> result;\n\t\tswitch (id)\n\t\t{\n\t\tcase 0:\n\t\t{\n\t\t\tresult = curve0;\n\t\t\tbreak;\n\t\t}\n\t\tcase 1:\n\t\t{\n\t\t\tresult = curve1;\n\t\t\tbreak;\n\t\t}\n\t\tcase 2:\n\t\t{\n\t\t\tresult = curve2;\n\t\t\tbreak;\n\t\t}\n\t\t}\n\t\treturn result;\n\t}\n} \n#include<catch.hpp>\n#include<testHelper.h>\n#include <filesystem>\n#include <fstream>\n#include <random>\n#include <sstream>\n#include <nurbs/NURBSAPIGetGeometry.hpp>\n#include <nurbs/NURBSAPIConicalSweep.hpp>\n#include <boolean/BoolBRepCut.hpp>\n#include <common/CartesianCoordinateSystem.hpp>\n#include <common/IndexMap.hpp>\n#include <common/QuaternionT.hpp>\n#include <geomAlgo/LawBSpline.hpp>\n#include <geomAlgo/LawConstant.hpp>\n#include <nurbs/NURBSAPISmooth.hpp>\n#include <geomAlgo/MakeConic2FromConstraints.hpp>\n#include <geometry/Adaptor3CurveOnSurface.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/AdaptorGeom3Surface.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2Circle.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/Geom2Hyperbola.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3BSplineCurve.hpp>\n#include <geometry/Geom3BSplineSurface.hpp>\n#include <geometry/Geom3Circle.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\n#include <geometry/Geom3Plane.hpp>\n#include <geometry/Geom3SphericalSurface.hpp>\n#include <geometry/Geom3Surface.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include <geometry/Geom3TrimmedSurface.hpp>\n#include <geometry/GeomAPIExtremaCurveCurve3.hpp>\n#include <geometry/GeomAPIProjectPointOnCurve2.hpp>\n#include <geometry/GeomAPIProjectPointOnCurve3.hpp>\n#include <geometry/GeomAPIProjectPointOnSurface.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/GlobalProperty.hpp>\n#include <healing/ShapeFixTool.hpp>\n#include <io/STLTool.hpp>\n#include <math/Sphere.hpp>\n#include <math/TriangularMesh.hpp>\n#include <modeling/CopyShape.hpp>\n#include <modeling/MakeBox.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeFace.hpp>\n#include <modeling/MakePrism.hpp>\n#include <modeling/MakeRevol.hpp>\n#include <modeling/MakeShapeTool.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <modeling/MakeWire.hpp>\n#include <modeling/TransformShape.hpp>\n#include <nurbs/NURBSAPIApprox.hpp>\n#include <nurbs/NURBSAPIBuildCurve.hpp>\n#include <nurbs/NURBSAPICircularSweep.hpp>\n#include <nurbs/NURBSAPIConvert.hpp>\n#include <nurbs/NURBSAPICurveNetworkSurface.hpp>\n#include <nurbs/NURBSAPIExplicitSweep.hpp>\n#include <nurbs/NURBSAPIExplode.hpp>\n#include <nurbs/NURBSAPIExtend.hpp>\n#include <nurbs/NURBSAPIInterpolate.hpp>\n#include <nurbs/NURBSAPIJoin.hpp>\n#include <nurbs/NURBSAPILinearSweep.hpp>\n#include <nurbs/NURBSAPILoft.hpp>\n#include <nurbs/NURBSAPIMakeNURBSFromBoundaries.hpp>\n#include <nurbs/NURBSAPIMatch.hpp>\n#include <nurbs/NURBSAPIModifyEndToPlane.hpp>\n#include <nurbs/NURBSAPIOffsetCurveOnSurface.hpp>\n#include <nurbs/NURBSAPIProject.hpp>\n#include <nurbs/NURBSAPIRebuild.hpp>\n#include <nurbs/NURBSAPIReplaceEdge.hpp>\n#include <nurbs/NURBSAPISweep.hpp>\n#include <nurbs/NURBSAPISweep2.hpp>\n#include <nurbs/NURBSAPISweepRotation.hpp>\n#include <nurbs/NURBSAPITrim.hpp>\n#include <nurbs/NURBSAPIUntrim.hpp>\n#include <nurbs/NURBSLinearSweepWithDraftDirectionLength.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <offset/MakePipe.hpp>\n#include <offset/MakePipeShell.hpp>\n#include <topology/BRepAdaptorCurve2.hpp>\n#include <topology/BRepAdaptorCurve3.hpp>\n#include <topology/BRepAdaptorSurface.hpp>\n#include <topology/BRepGlobalProperty.hpp>\n#include <topology/BRepTool.hpp>\n#include <topology/TopoBuilder.hpp>\n#include <topology/TopoCompound.hpp>\n#include <topology/TopoEdge.hpp>\n#include <topology/TopoExplorer.hpp>\n#include <topology/TopoExplorerTool.hpp>\n#include <topology/TopoFace.hpp>\n#include <topology/TopoShape.hpp>\n#include <topology/TopoShell.hpp>\n#include <topology/TopoTool.hpp>\n#include <topology/TopoVertex.hpp>\n#include <topology/TopoWire.hpp>\n#include <topology/WireExplorer.hpp>\n#include <topomesh/BRepMeshIncrementalMesh.hpp>\n#include <nurbs/NURBSAPIBlend.hpp>\n#include <topology/BRepExtremaDistShapeShape.hpp>\n#include <math/LineT.hpp>\n#include <hatch/BRepClassificationTools.hpp>\nusing namespace AMCAX;\nnamespace\n{\n\tstd::shared_ptr<Geom3BSplineCurve> CurveChooser(const int id, const std::shared_ptr<Geom3BSplineCurve>& curve0, const std::shared_ptr<Geom3BSplineCurve>& curve1, const std::shared_ptr<Geom3BSplineCurve>& curve2)\n\t{\n\t\tstd::shared_ptr<Geom3BSplineCurve> result;\n\t\tswitch (id)\n\t\t{\n\t\tcase 0:\n\t\t{\n\t\t\tresult = curve0;\n\t\t\tbreak;\n\t\t}\n\t\tcase 1:\n\t\t{\n\t\t\tresult = curve1;\n\t\t\tbreak;\n\t\t}\n\t\tcase 2:\n\t\t{\n\t\t\tresult = curve2;\n\t\t\tbreak;\n\t\t}\n\t\t}\n\t\treturn result;\n\t}\n;\n\tSECTION(\"TestExplicitSweepWithReferenceSurface()\")\n\t{\n\t\tstd::string filedir = INPUT_PATH_PREFIX \"/TestNURBS/TestExplicitSweepWithReferenceSurface/\";\n\t\tauto surface = ReadBRepSurface(filedir + \"surface.brep\");\n\t\tCHECK(OCCTIO::OCCTTool::Write(MakeFace(surface, 0.0), OUTPUT_PATH_PREFIX \"TestExplicitSweepWithReferenceSurface_surface.brep\"));\n\t\tauto profile = ReadBRepCurve(filedir + \"profile.brep\");\n\t\tCHECK(OCCTIO::OCCTTool::Write(MakeEdge(profile), OUTPUT_PATH_PREFIX \"TestExplicitSweepWithReferenceSurface_profile.brep\"));\n\t\tCHECK(OCCTIO::OCCTTool::Write(MakeVertex(profile->Pole(0)), OUTPUT_PATH_PREFIX \"TestExplicitSweepWithReferenceSurface_pole.brep\"));\n\t\tauto guide = ReadBRepCurve(filedir + \"guide.brep\");\n\t\tCHECK(OCCTIO::OCCTTool::Write(MakeEdge(guide), OUTPUT_PATH_PREFIX \"TestExplicitSweepWithReferenceSurface_guide.brep\"));\n\t\tLawConstant law;\n\t\tlaw.Set(0.0, 0.0, 1.0);\n\t\tauto [status, surfaces] = NURBSAPIExplicitSweep::SweepWithReferenceSurface(profile, guide, surface, law, guide, guide->FirstParameter(), guide->LastParameter());\n\t\tCHECK(status == NURBSSweepStatus::Success);\n\t\tif (status == NURBSSweepStatus::Success)\n\t\t{\n\t\t\tCHECK(OCCTIO::OCCTTool::Write(MakeFace(surfaces.front(), 0.0), OUTPUT_PATH_PREFIX \"TestExplicitSweepWithReferenceSurface_result.brep\"));\n\t\t\tCHECK(IsCurveOnSurf(1000, 0.1, guide, surfaces[0], 0.1));\n\t\t\tCHECK(IsCurveOnSurf(1000, 0.1, profile, surfaces[0], 0.1));\n\t\t\tAMCAX::BRepExtremaDistShapeShape len1(MakeFace(surfaces[0], 0.0), MakeEdge(guide));\n\t\t\tAMCAX::BRepExtremaDistShapeShape len2(MakeFace(surfaces[0], 0.0), MakeEdge(profile));\n\t\t\tAMCAX::BRepExtremaDistShapeShape len3(MakeFace(surfaces[0], 0.0), MakeFace(surface, 0.0));\n\t\t\tCHECK(len1.Value() == Approx(0.0).margin(0.1));\n\t\t\tCHECK(len2.Value() == Approx(0.0).margin(0.1));\n\t\t\tCHECK(len3.Value() == Approx(0.0).margin(0.1));\n\t\t\tIndexSet<TopoShape> newshapeEdge1;\n\t\t\tTopoExplorerTool::MapShapes(MakeFace(surfaces.front(), 0.0), ShapeType::Edge, newshapeEdge1);\n\t\t\tstd::cout << \"newshapeedge1=\" << newshapeEdge1.size() << std::endl;\n\t\t\tTopoExplorer ex0(newshapeEdge1[1], ShapeType::Edge);\n\t\t\tTopoExplorer ex1(newshapeEdge1[3], ShapeType::Edge);\n\t\t\tTopoEdge e0 = static_cast<const TopoEdge&>(ex0.Value());\n\t\t\tTopoEdge e1 = static_cast<const TopoEdge&>(ex1.Value());\n\t\t\tauto edge0 = NURBSAPIGetGeometry::GetCurve(e0);\n\t\t\tauto edge1 = NURBSAPIGetGeometry::GetCurve(e1);\n\t\t\tdouble n0 = NurbsSampleCurve(100, 0.15, edge0, profile);\n\t\t\tCHECK(n0 < 0.2);\n\t\t\tprofile->IncreaseDegree(11);\n\t\t\tguide->IncreaseDegree(11);\n\t\t\tsurface->IncreaseDegree(11,11);\n\t\t\tauto [status1, surfaces1] = NURBSAPIExplicitSweep::SweepWithReferenceSurface(profile, guide, surface, law, guide, guide->FirstParameter(), guide->LastParameter());\n\t\t\tCHECK(status1 == NURBSSweepStatus::Success);\n\t\t\tif (status1 == NURBSSweepStatus::Success)\n\t\t\t{\n\t\t\t\tCHECK(OCCTIO::OCCTTool::Write(MakeFace(surfaces.front(), 0.0), OUTPUT_PATH_PREFIX \"TestExplicitSweepWithReferenceSurface_degree11result.brep\"));\n\t\t\t\tCHECK(IsCurveOnSurf(1000, 0.1, guide, surfaces[0], 0.1));\n\t\t\t\tCHECK(IsCurveOnSurf(1000, 0.1, profile, surfaces[0], 0.1));\n\t\t\t\tAMCAX::BRepExtremaDistShapeShape len1(MakeFace(surfaces[0], 0.0), MakeEdge(guide));\n\t\t\t\tAMCAX::BRepExtremaDistShapeShape len2(MakeFace(surfaces[0], 0.0), MakeEdge(profile));\n\t\t\t\tAMCAX::BRepExtremaDistShapeShape len3(MakeFace(surfaces[0], 0.0), MakeFace(surface, 0.0));\n\t\t\t\tCHECK(len1.Value() == Approx(0.0).margin(0.1));\n\t\t\t\tCHECK(len2.Value() == Approx(0.0).margin(0.1));\n\t\t\t\tCHECK(len3.Value() == Approx(0.0).margin(0.1));\n\t\t\t\tdouble bsp3s = GetSurfaceProperties(MakeFace(surfaces1[0], 0.0), g, true, true);\n\t\t\t\tdouble bsp4s = GetSurfaceProperties(MakeFace(surfaces[0], 0.0), g, true, true);\n\t\t\t\tCHECK(bsp3s == Approx(bsp4s).margin(0.02));\n\t\t\t}\n\t\t}\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static std::shared_ptr<Geom3BSplineSurface> CurveNetworkSurfaceGordon(const std::vector<std::shared_ptr<Geom3BSplineCurve>>& verticalCurves, const std::vector<std::shared_ptr<Geom3BSplineCurve>>& horizontalCurves)\t @return The Gordon surface which go through the curves\n\t @param horizontalCurves Horizontal network curves\n\t @param verticalCurves Vertical network curves\n\t @brief Coons-Gordon surface\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <nurbs/NURBSAPICurveNetworkSurface.hpp>\n#include <topology/TopoEdge.hpp>\n#include <topology/TopoTool.hpp>\n#include <modeling/MakeFace.hpp>\n#include <nurbs/NURBSAPILoft.hpp>\n#include <common/Precision.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <geometry/Geom3BSplineCurve.hpp>\n#include <geometry/Geom3BSplineSurface.hpp>\n#include <topology/BRepExtremaDistShapeShape.hpp>\n#include <topology/TopoExplorerTool.hpp>\n#include <geometry/GeomAPIProjectPointOnSurface.hpp>\nusing namespace std;\nusing namespace AMCAX;\ndouble NurbsSampleCurveOnSurface(int num, double tol, const shared_ptr<Geom3Curve>& curve, const shared_ptr<Geom3Surface>& surf)\n{\n\tconst int nsample = num;\n\tdouble fp1 = curve->FirstParameter();\n\tdouble lp1 = curve->LastParameter();\n\tdouble delta1 = (lp1 - fp1) / nsample;\n\tPoint3 p;\n\tint n = 0;\n\tfor (int i = 0; i < nsample; i++)\n\t{\n\t\tdouble t1 = fp1 + i * delta1;\n\t\tcurve->D0(t1, p);\n\t\tGeomAPIProjectPointOnSurface projector(p, surf);\n\t\tdouble dis = projector.LowerDistance();\n\t\tif (dis <= tol)\n\t\t{\n\t\t\tn++;\n\t\t}\n\t}\n\tdouble res = 1.0 * (num - n) / num;\n\treturn res;\n}\nvector< shared_ptr<Geom3BSplineCurve>> ConstructBSplineCurve()\n{\n\tvector<shared_ptr<Geom3BSplineCurve>> vec;\n\tshared_ptr<Geom3BSplineCurve> vbsp1, vbsp2, vbsp3, vbsp4, hbsp1, hbsp2, hbsp3;\n\t{\n\t\tint deg = 3;\n\t\tstd::vector<Point3> poles;\n\t\tpoles.push_back(Point3(0.0, -1.0, 0.1));\n\t\tpoles.push_back(Point3(0.07, -0.7, 0.2));\n\t\tpoles.push_back(Point3(0.1, -0.3, 0.1));\n\t\tpoles.push_back(Point3(0.12, 0.0, -0.1));\n\t\tpoles.push_back(Point3(0.20, 0.3, -0.2));\n\t\tpoles.push_back(Point3(0.07, 0.7, -0.3));\n\t\tpoles.push_back(Point3(0.0, 1.0, 0.0));\n\t\tint nknots = static_cast<int>(poles.size()) - deg + 1;\n\t\tstd::vector<double> knots(nknots);\n\t\tfor (int i = 0; i < nknots; i++)\n\t\t{\n\t\t\tknots[i] = (double)i / (double)(nknots - 1.0);\n\t\t}\n\t\tstd::vector<int> mults(nknots, 1);\n\t\tmults.front() = deg + 1;\n\t\tmults.back() = deg + 1;\n\t\tvbsp1 = std::make_shared<Geom3BSplineCurve>(poles, knots, mults, deg);\n\t}\n\t{\n\t\tint deg = 3;\n\t\tstd::vector<Point3> poles;\n\t\tpoles.push_back(Point3(2.0, -2.0, -0.1));\n\t\tpoles.push_back(Point3(2.1, -1.3, -0.2));\n\t\tpoles.push_back(Point3(2.15, -0.8, -0.1));\n\t\tpoles.push_back(Point3(1.83, -0.2, 0.1));\n\t\tpoles.push_back(Point3(1.48, 0.1, 0.2));\n\t\tpoles.push_back(Point3(1.0, 1.0, 0.1));\n\t\tint nknots = static_cast<int>(poles.size()) - deg + 1;\n\t\tstd::vector<double> knots(nknots);\n\t\tfor (int i = 0; i < nknots; i++)\n\t\t{\n\t\t\tknots[i] = (double)i / (double)(nknots - 1.0);\n\t\t}\n\t\tstd::vector<int> mults(nknots, 1);\n\t\tmults.front() = deg + 1;\n\t\tmults.back() = deg + 1;\n\t\tvbsp2 = std::make_shared<Geom3BSplineCurve>(poles, knots, mults, deg);\n\t}\n\t{\n\t\tint deg = 3;\n\t\tstd::vector<Point3> poles;\n\t\tpoles.push_back(Point3(3.0, -2.0, 0.1));\n\t\tpoles.push_back(Point3(3.07, -1.3, 0.2));\n\t\tpoles.push_back(Point3(3.1, -0.3, 0.1));\n\t\tpoles.push_back(Point3(3.12, 0.0, -0.1));\n\t\tpoles.push_back(Point3(3.0, 0.3, -0.2));\n\t\tpoles.push_back(Point3(2.57, 0.7, -0.3));\n\t\tpoles.push_back(Point3(2.2, 1.0, 0.0));\n\t\tint nknots = static_cast<int>(poles.size()) - deg + 1;\n\t\tstd::vector<double> knots(nknots);\n\t\tfor (int i = 0; i < nknots; i++)\n\t\t{\n\t\t\tknots[i] = (double)i / (double)(nknots - 1.0);\n\t\t}\n\t\tstd::vector<int> mults(nknots, 1);\n\t\tmults.front() = deg + 1;\n\t\tmults.back() = deg + 1;\n\t\tvbsp3 = std::make_shared<Geom3BSplineCurve>(poles, knots, mults, deg);\n\t}\n\t{\n\t\tint deg = 3;\n\t\tstd::vector<Point3> poles;\n\t\tpoles.push_back(Point3(4.0, -1.5, -0.1));\n\t\tpoles.push_back(Point3(4.1, -1.3, -0.2));\n\t\tpoles.push_back(Point3(4.15, -0.8, -0.1));\n\t\tpoles.push_back(Point3(3.83, -0.2, 0.1));\n\t\tpoles.push_back(Point3(3.48, 0.1, 0.2));\n\t\tpoles.push_back(Point3(3.0, 1.0, 0.1));\n\t\tint nknots = static_cast<int>(poles.size()) - deg + 1;\n\t\tstd::vector<double> knots(nknots);\n\t\tfor (int i = 0; i < nknots; i++)\n\t\t{\n\t\t\tknots[i] = (double)i / (double)(nknots - 1.0);\n\t\t}\n\t\tstd::vector<int> mults(nknots, 1);\n\t\tmults.front() = deg + 1;\n\t\tmults.back() = deg + 1;\n\t\tvbsp4 = std::make_shared<Geom3BSplineCurve>(poles, knots, mults, deg);\n\t}\n\t{\n\t\tint deg = 3;\n\t\tstd::vector<Point3> poles;\n\t\tpoles.push_back(Point3(0.0, -1.0, 0.1));\n\t\tpoles.push_back(Point3(0.9, -1.5, -0.1));\n\t\tpoles.push_back(Point3(3.0, -1.8, 0.1));\n\t\tpoles.push_back(Point3(4.0, -1.5, -0.1));\n\t\tint nknots = static_cast<int>(poles.size()) - deg + 1;\n\t\tstd::vector<double> knots(nknots);\n\t\tfor (int i = 0; i < nknots; i++)\n\t\t{\n\t\t\tknots[i] = (double)i / (double)(nknots - 1.0);\n\t\t}\n\t\tstd::vector<int> mults(nknots, 1);\n\t\tmults.front() = deg + 1;\n\t\tmults.back() = deg + 1;\n\t\thbsp1 = std::make_shared<Geom3BSplineCurve>(poles, knots, mults, deg);\n\t}\n\t{\n\t\tint deg = 3;\n\t\tstd::vector<Point3> poles;\n\t\tpoles.push_back(Point3(0.0, 0.0, 0.0));\n\t\tpoles.push_back(Point3(1.2, -1.15, -0.1));\n\t\tpoles.push_back(Point3(2.7, -1.05, 0.1));\n\t\tpoles.push_back(Point3(3.7, -1.3, -0.1));\n\t\tpoles.push_back(Point3(5.0, -1.0, 0.1));\n\t\tint nknots = static_cast<int>(poles.size()) - deg + 1;\n\t\tstd::vector<double> knots(nknots);\n\t\tfor (int i = 0; i < nknots; i++)\n\t\t{\n\t\t\tknots[i] = (double)i / (double)(nknots - 1.0);\n\t\t}\n\t\tstd::vector<int> mults(nknots, 1);\n\t\tmults.front() = deg + 1;\n\t\tmults.back() = deg + 1;\n\t\thbsp2 = std::make_shared<Geom3BSplineCurve>(poles, knots, mults, deg);\n\t}\n\t{\n\t\tint deg = 3;\n\t\tvector<Point3> poles;\n\t\tpoles.push_back(Point3(0.0, 1.0, 0.0));\n\t\tpoles.push_back(Point3(0.9, 0.15, -0.1));\n\t\tpoles.push_back(Point3(1.7, 0.05, 0.1));\n\t\tpoles.push_back(Point3(2.7, 0.3, -0.1));\n\t\tpoles.push_back(Point3(3.0, 1.0, 0.1));\n\t\tint nknots = static_cast<int>(poles.size()) - deg + 1;\n\t\tvector<double> knots(nknots);\n\t\tfor (int i = 0; i < nknots; i++)\n\t\t{\n\t\t\tknots[i] = (double)i / (double)(nknots - 1.0);\n\t\t}\n\t\tvector<int> mults(nknots, 1);\n\t\tmults.front() = deg + 1;\n\t\tmults.back() = deg + 1;\n\t\thbsp3 = make_shared<Geom3BSplineCurve>(poles, knots, mults, deg);\n\t}\n\tvec.push_back(vbsp1);\n\tvec.push_back(vbsp2);\n\tvec.push_back(vbsp3);\n\tvec.push_back(vbsp4);\n\tvec.push_back(hbsp1);\n\tvec.push_back(hbsp2);\n\tvec.push_back(hbsp3);\n\treturn vec;\n}\nTEST_CASE(\"bug1: CurveNetworkSurface \", \"[nurbs][CurveNetworkSurface][fixbug]\")\n{\n\tOUTPUT_DIRECTORY(nurbs, CurveNetworkSurface/bug464);\n\tdouble refTol = 0.1;\n\tvector< shared_ptr<Geom3BSplineCurve>> vec = ConstructBSplineCurve();\n\tTopoEdge edge1 = MakeEdge(vec[0]);\n\tTopoEdge edge2 = MakeEdge(vec[1]);\n\tTopoEdge edge3 = MakeEdge(vec[2]);\n\tTopoEdge edge4 = MakeEdge(vec[3]);\n\tTopoEdge edge5 = MakeEdge(vec[4]);\n\tTopoEdge edge6 = MakeEdge(vec[5]);\n\tTopoEdge edge7 = MakeEdge(vec[6]);\n\tvector<shared_ptr<Geom3BSplineCurve>> horizontalCurves, verticalCurves;\n\tverticalCurves.push_back(vec[0]);\n\tverticalCurves.push_back(vec[1]);\n\tverticalCurves.push_back(vec[2]);\n\tverticalCurves.push_back(vec[3]);\n\thorizontalCurves.push_back(vec[4]);\n\thorizontalCurves.push_back(vec[5]);\n\thorizontalCurves.push_back(vec[6]);\n\tshared_ptr<Geom3BSplineSurface> surf = NURBSAPICurveNetworkSurface::CurveNetworkSurfaceGordon(verticalCurves, horizontalCurves);\n\tTopoShape surface = MakeFace(surf, 0.0);\n\tBRepExtremaDistShapeShape dist1(edge1, surface);\n\tBRepExtremaDistShapeShape dist2(edge2, surface);\n\tBRepExtremaDistShapeShape dist3(edge3, surface);\n\tBRepExtremaDistShapeShape dist4(edge4, surface);\n\tBRepExtremaDistShapeShape dist5(edge5, surface);\n\tBRepExtremaDistShapeShape dist6(edge6, surface);\n\tBRepExtremaDistShapeShape dist7(edge7, surface);\n\tCHECK(dist3.Value() <= Approx(refTol));\n\tCHECK(dist4.Value() <= Approx(refTol));\n\tCHECK(dist7.Value() <= Approx(refTol));\n\tOCCTIO::OCCTTool::Write(MakeEdge(vec[0]), outdir + \"vbsp1.brep\");\n\tOCCTIO::OCCTTool::Write(MakeEdge(vec[1]), outdir + \"vbsp2.brep\");\n\tOCCTIO::OCCTTool::Write(MakeEdge(vec[2]), outdir + \"vbsp3.brep\");\n\tOCCTIO::OCCTTool::Write(MakeEdge(vec[3]), outdir + \"vbsp4.brep\");\n\tOCCTIO::OCCTTool::Write(MakeEdge(vec[4]), outdir + \"hbsp1.brep\");\n\tOCCTIO::OCCTTool::Write(MakeEdge(vec[5]), outdir + \"hbsp2.brep\");\n\tOCCTIO::OCCTTool::Write(MakeEdge(vec[6]), outdir + \"hbsp3.brep\");\n\tOCCTIO::OCCTTool::Write(surface, outdir + \"surfResult.brep\");\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static std::vector<std::pair<double, bool>> CalcParamCorrespondece( const std::vector<std::shared_ptr<Geom3Curve>>& curves, bool isPeriodic, bool isConsiderReverse),\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <nurbs/NURBSAPICorrespondence.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <topology/TopoExplorerTool.hpp>\n#include <nurbs/NURBSAPIConvert.hpp>\nusing namespace std;\n#include<catch.hpp>\n#include<testHelper.h>\n#include <nurbs/NURBSAPICorrespondence.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <topology/TopoExplorerTool.hpp>\n#include <nurbs/NURBSAPIConvert.hpp>\nusing namespace std;\n;\n\tSECTION(\"isPeriodic+isConsiderReverse\")\n\t{\n\t\tbool isPeriodic = true;\n\t\tbool isConsiderReverse = true;\n\t\tvector<pair<double, bool>> corrs = NURBSAPICorrespondence::CalcParamCorrespondece(curves, isPeriodic, isConsiderReverse);\n\t\tCHECK(corrs[0].first == 0.0);\n\t\tCHECK(corrs[0].second == false);\n\t\tCHECK(corrs[1].first > 0.0);\n\t\tCHECK(corrs[1].second == true);\n\t\tCHECK(corrs[2].first > 0.0);\n\t\tCHECK(corrs[2].second == true);\n\t\tCHECK(corrs[3].first > 0.0);\n\t\tCHECK(corrs[3].second == true);\n\t\tCHECK(corrs[4].first > 0.0);\n\t\tCHECK(corrs[4].second == true);\n\t\tCHECK(corrs[5].first > 0.0);\n\t\tCHECK(corrs[5].second == true);\n\t\tCHECK(corrs[6].first > 0.0);\n\t\tCHECK(corrs[6].second == true);\n\t\tCHECK(corrs.size() == 7);\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static std::vector<std::shared_ptr<Geom3BezierCurve>> ToBezier(const std::shared_ptr<Geom3BSplineCurve>& curve)\t @return Result Bezier curves\n\t @param curve The BSpline curve\n\t @brief Convert a BSpline curve to Bezier curves\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include<common/Exception.hpp>\n#include <nurbs/NURBSAPIConvert.hpp>\n#include <topology/TopoEdge.hpp>\n#include <topology/TopoTool.hpp>\n#include <topology/TopoVertex.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include <geometry/Geom3BSplineCurve.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeFace.hpp>\n#include <geometry/Geom3Circle.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3BezierCurve.hpp>\n#include <geometry/Geom3Ellipse.hpp>\n#include <geometry/Geom3Hyperbola.hpp>\n#include <geometry/Geom3Parabola.hpp>\n#include <geometry/Geom3SphericalSurface.hpp>\n#include <math/Sphere.hpp>\n#include <geometry/Geom3Surface.hpp>\n#include <geometry/Geom3BSplineSurface.hpp>\n#include <geometry/Geom3TrimmedSurface.hpp>\n#include <geometry/Geom3ElementarySurface.hpp>\n#include <geometry/Geom3OffsetSurface.hpp>\n#include <geometry/Geom3SweptSurface.hpp>\n#include <geometry/Geom3SurfaceOfExtrusion.hpp>\n#include <geometry/Geom3BezierSurface.hpp>\n#include <math/Cone.hpp>\n#include <geometry/Geom3ConicalSurface.hpp>\n#include <geometry/Geom3CylindricalSurface.hpp>\n#include <geometry/Geom3Plane.hpp>\n#include <geometry/Geom3ToroidalSurface.hpp>\n#include <geometry/Geom3SurfaceOfExtrusion.hpp>\n#include <geometry/Geom3SurfaceOfRevolution.hpp>\nusing namespace std;\nusing namespace AMCAX;\ndouble NurbsLinearCurve(const shared_ptr<Geom3Curve>& curve1, const shared_ptr<Geom3BSplineCurve>& curve2)\n{\n    TopoShape edge1 = MakeEdge(curve1);\n    TopoShape edge2 = MakeEdge(curve2);\n    GlobalProperty props1, props2;\n    double len1 = GetLinearProperties(edge1, props1, true, false);\n    double len2 = GetLinearProperties(edge2, props2, true, false);\n    double len = abs(len1 - len2);\n    return len;\n}\ndouble NurbsSurfaceResult(const shared_ptr<Geom3Surface>& surface1, const shared_ptr<Geom3BSplineSurface>& surface2)\n{\n    TopoFace f1 = MakeFace(surface1, 0.0);\n    TopoFace f2 = MakeFace(surface2, 0.0);\n    GlobalProperty props1, props2;\n    double s1 = GetSurfaceProperties(f1, props1, true, false);\n    double s2 = GetSurfaceProperties(f2, props2, true, false);\n    double res = abs(s1 - s2);\n    return res;\n}\nTEST_CASE(\"case1: this is a test for ConvertToBezierCurve\", \"[nurbs][convert][P1]\")\n{\n    OUTPUT_DIRECTORY(nurbs, Convert/convertBezierCurve);\n    vector<Point3> poles;\n    poles.push_back(Point3(0.0, -1.0, 0.0));\n    poles.push_back(Point3(0.7, -0.7, 0.0));\n    poles.push_back(Point3(1.0, -0.3, 0.0));\n    poles.push_back(Point3(1.2, 0.0, 0.0));\n    poles.push_back(Point3(2.0, 0.3, 0.0));\n    poles.push_back(Point3(0.7, 1.7, 0.0));\n    poles.push_back(Point3(0.0, 1.0, 0.0));\n    vector<double> knots;\n    knots.push_back(0.0);\n    knots.push_back(0.25);\n    knots.push_back(0.5);\n    knots.push_back(0.75);\n    knots.push_back(1.0);\n    vector<int> mults(5, 1);\n    mults.front() = 4;\n    mults.back() = 4;\n    shared_ptr<Geom3BSplineCurve> curve;\n    curve = make_shared<Geom3BSplineCurve>(poles, knots, mults, 3, false);\n\tvector<shared_ptr<Geom3BezierCurve>> beziers = NURBSAPIConvert::ToBezier(curve);\n    TopoShape edge1 = MakeEdge(beziers[0]);\n    TopoShape edge2 = MakeEdge(beziers[1]);\n    TopoShape edge3 = MakeEdge(beziers[2]);\n    TopoShape edge4 = MakeEdge(beziers[3]);\n    TopoShape edge = MakeEdge(curve);\n    GlobalProperty props1, props2, props3, props4;\n    double len1 = GetLinearProperties(edge1, props1, true, false);\n    double len2 = GetLinearProperties(edge2, props2, true, false);\n    double len3 = GetLinearProperties(edge3, props2, true, false);\n    double len4 = GetLinearProperties(edge4, props2, true, false);\n    double bspLen = GetLinearProperties(edge, props2, true, false);\n    double bezLen = len1 + len2 + len3 + len4;\n    double len = abs(bspLen - bezLen);\n    CHECK(beziers.size() == 4);\n    CHECK(len < 0.1);\n    CHECK(curve->Type() == CurveType::BSplineCurve);\n    CHECK(beziers[0]->Type() == CurveType::BezierCurve);\n    OCCTIO::OCCTTool::Write(MakeEdge(curve), outdir + \"curve.brep\");\n    OCCTIO::OCCTTool::Write(MakeEdge(beziers[0]), outdir + \"beziers0.brep\");\n    OCCTIO::OCCTTool::Write(MakeEdge(beziers[1]), outdir + \"beziers1.brep\");\n    OCCTIO::OCCTTool::Write(MakeEdge(beziers[2]), outdir + \"beziers2.brep\");\n    OCCTIO::OCCTTool::Write(MakeEdge(beziers[3]), outdir + \"beziers3.brep\");\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static std::shared_ptr<Geom3BSplineSurface> ToBSpline(const std::shared_ptr<Geom3Surface>& surface)\t @return BSpline surface\n\t @param surface The given surface\n\t @brief Convert a common surface to a BSpline surface\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include<common/Exception.hpp>\n#include <nurbs/NURBSAPIConvert.hpp>\n#include <topology/TopoEdge.hpp>\n#include <topology/TopoTool.hpp>\n#include <topology/TopoVertex.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include <geometry/Geom3BSplineCurve.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeFace.hpp>\n#include <geometry/Geom3Circle.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3BezierCurve.hpp>\n#include <geometry/Geom3Ellipse.hpp>\n#include <geometry/Geom3Hyperbola.hpp>\n#include <geometry/Geom3Parabola.hpp>\n#include <geometry/Geom3SphericalSurface.hpp>\n#include <math/Sphere.hpp>\n#include <geometry/Geom3Surface.hpp>\n#include <geometry/Geom3BSplineSurface.hpp>\n#include <geometry/Geom3TrimmedSurface.hpp>\n#include <geometry/Geom3ElementarySurface.hpp>\n#include <geometry/Geom3OffsetSurface.hpp>\n#include <geometry/Geom3SweptSurface.hpp>\n#include <geometry/Geom3SurfaceOfExtrusion.hpp>\n#include <geometry/Geom3BezierSurface.hpp>\n#include <math/Cone.hpp>\n#include <geometry/Geom3ConicalSurface.hpp>\n#include <geometry/Geom3CylindricalSurface.hpp>\n#include <geometry/Geom3Plane.hpp>\n#include <geometry/Geom3ToroidalSurface.hpp>\n#include <geometry/Geom3SurfaceOfExtrusion.hpp>\n#include <geometry/Geom3SurfaceOfRevolution.hpp>\nusing namespace std;\nusing namespace AMCAX;\ndouble NurbsLinearCurve(const shared_ptr<Geom3Curve>& curve1, const shared_ptr<Geom3BSplineCurve>& curve2)\n{\n    TopoShape edge1 = MakeEdge(curve1);\n    TopoShape edge2 = MakeEdge(curve2);\n    GlobalProperty props1, props2;\n    double len1 = GetLinearProperties(edge1, props1, true, false);\n    double len2 = GetLinearProperties(edge2, props2, true, false);\n    double len = abs(len1 - len2);\n    return len;\n}\ndouble NurbsSurfaceResult(const shared_ptr<Geom3Surface>& surface1, const shared_ptr<Geom3BSplineSurface>& surface2)\n{\n    TopoFace f1 = MakeFace(surface1, 0.0);\n    TopoFace f2 = MakeFace(surface2, 0.0);\n    GlobalProperty props1, props2;\n    double s1 = GetSurfaceProperties(f1, props1, true, false);\n    double s2 = GetSurfaceProperties(f2, props2, true, false);\n    double res = abs(s1 - s2);\n    return res;\n}\nTEST_CASE(\"bug2: ConvertToBSplineCurve \", \"[nurbs][convert][fixbug]\")\n{\n    double res;\n    double tol = 3.5;\n    shared_ptr<Geom3ToroidalSurface> surf;\n    surf = make_shared<Geom3ToroidalSurface>(Frame3(), 5.0, 4.0);\n    shared_ptr<Geom3BSplineSurface> bspSurf = NURBSAPIConvert::ToBSpline(surf);\n    double u1 = surf->FirstUParameter();\n    double u2 = surf->LastUParameter();\n    double v1 = surf->FirstVParameter();\n    double v2 = surf->LastVParameter();\n    double u11 = bspSurf->FirstUParameter();\n    double u22 = bspSurf->LastUParameter();\n    double v11 = bspSurf->FirstVParameter();\n    double v22 = bspSurf->LastVParameter();\n    CHECK(u1 == u11);\n    CHECK(u2 == u22);\n    CHECK(v1 == v11);\n    CHECK(v2 == v22);\n    res = NurbsSurfaceResult(surf, bspSurf);\n    CHECK(res <= tol);\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static std::shared_ptr<Geom3BSplineCurve> ToBSpline(const std::shared_ptr<Geom3Curve>& curve)\t @return Result BSpline curve\n\t @param curve The given curve\n\t @brief Convert a common curve to a BSpline curve\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include<common/Exception.hpp>\n#include <nurbs/NURBSAPIConvert.hpp>\n#include <topology/TopoEdge.hpp>\n#include <topology/TopoTool.hpp>\n#include <topology/TopoVertex.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include <geometry/Geom3BSplineCurve.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeFace.hpp>\n#include <geometry/Geom3Circle.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3BezierCurve.hpp>\n#include <geometry/Geom3Ellipse.hpp>\n#include <geometry/Geom3Hyperbola.hpp>\n#include <geometry/Geom3Parabola.hpp>\n#include <geometry/Geom3SphericalSurface.hpp>\n#include <math/Sphere.hpp>\n#include <geometry/Geom3Surface.hpp>\n#include <geometry/Geom3BSplineSurface.hpp>\n#include <geometry/Geom3TrimmedSurface.hpp>\n#include <geometry/Geom3ElementarySurface.hpp>\n#include <geometry/Geom3OffsetSurface.hpp>\n#include <geometry/Geom3SweptSurface.hpp>\n#include <geometry/Geom3SurfaceOfExtrusion.hpp>\n#include <geometry/Geom3BezierSurface.hpp>\n#include <math/Cone.hpp>\n#include <geometry/Geom3ConicalSurface.hpp>\n#include <geometry/Geom3CylindricalSurface.hpp>\n#include <geometry/Geom3Plane.hpp>\n#include <geometry/Geom3ToroidalSurface.hpp>\n#include <geometry/Geom3SurfaceOfExtrusion.hpp>\n#include <geometry/Geom3SurfaceOfRevolution.hpp>\nusing namespace std;\nusing namespace AMCAX;\ndouble NurbsLinearCurve(const shared_ptr<Geom3Curve>& curve1, const shared_ptr<Geom3BSplineCurve>& curve2)\n{\n    TopoShape edge1 = MakeEdge(curve1);\n    TopoShape edge2 = MakeEdge(curve2);\n    GlobalProperty props1, props2;\n    double len1 = GetLinearProperties(edge1, props1, true, false);\n    double len2 = GetLinearProperties(edge2, props2, true, false);\n    double len = abs(len1 - len2);\n    return len;\n}\ndouble NurbsSurfaceResult(const shared_ptr<Geom3Surface>& surface1, const shared_ptr<Geom3BSplineSurface>& surface2)\n{\n    TopoFace f1 = MakeFace(surface1, 0.0);\n    TopoFace f2 = MakeFace(surface2, 0.0);\n    GlobalProperty props1, props2;\n    double s1 = GetSurfaceProperties(f1, props1, true, false);\n    double s2 = GetSurfaceProperties(f2, props2, true, false);\n    double res = abs(s1 - s2);\n    return res;\n}\nTEST_CASE(\"bug3: ConvertToBSplineCurve \", \"[nurbs][convert][fixbug]\")\n{\n    double res;\n    double tol = 0.1;\n    Point3 p(0.0, 0.0, 0.0);\n    Direction3 dir(0.0, 0.0, 1.0);\n    Direction3 dir1(1.0, 0.0, 0.0);\n    shared_ptr<Geom3Curve> curve;\n    curve = make_shared<Geom3Circle>(Frame3(p, dir), 1.0);\n    shared_ptr<Geom3TrimmedCurve> TrimmedCurve = make_shared<Geom3TrimmedCurve>(curve, 0.0, M_PI);\n    Axis3 axis(p, dir1);\n    shared_ptr<Geom3SurfaceOfRevolution> surf;\n    surf = make_shared<Geom3SurfaceOfRevolution>(TrimmedCurve, axis);\n    shared_ptr<Geom3BSplineSurface> bspSurf = NURBSAPIConvert::ToBSpline(surf);\n    res = NurbsSurfaceResult(surf, bspSurf);\n    CHECK(res <= tol);\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static std::pair<NURBSSweepStatus, std::vector<std::shared_ptr<Geom3BSplineSurface>>> SweepWithCurveOnTangencySurface(const std::shared_ptr<Geom3BSplineCurve>& guide, const std::shared_ptr<Geom3BSplineSurface>& tangencySurface, const LawFunction& radiusLaw, const LawFunction& angleLaw1, const LawFunction& angleLaw2, const std::shared_ptr<Geom3BSplineCurve>& spine, double spineLeftBound, double spineRightBound),\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <filesystem>\n#include <fstream>\n#include <random>\n#include <sstream>\n#include <nurbs/NURBSAPIGetGeometry.hpp>\n#include <nurbs/NURBSAPIConicalSweep.hpp>\n#include <boolean/BoolBRepCut.hpp>\n#include <common/CartesianCoordinateSystem.hpp>\n#include <common/IndexMap.hpp>\n#include <common/QuaternionT.hpp>\n#include <geomAlgo/LawBSpline.hpp>\n#include <geomAlgo/LawConstant.hpp>\n#include <nurbs/NURBSAPISmooth.hpp>\n#include <geomAlgo/MakeConic2FromConstraints.hpp>\n#include <geometry/Adaptor3CurveOnSurface.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/AdaptorGeom3Surface.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2Circle.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/Geom2Hyperbola.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3BSplineCurve.hpp>\n#include <geometry/Geom3BSplineSurface.hpp>\n#include <geometry/Geom3Circle.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\n#include <geometry/Geom3Plane.hpp>\n#include <geometry/Geom3SphericalSurface.hpp>\n#include <geometry/Geom3Surface.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include <geometry/Geom3TrimmedSurface.hpp>\n#include <geometry/GeomAPIExtremaCurveCurve3.hpp>\n#include <geometry/GeomAPIProjectPointOnCurve2.hpp>\n#include <geometry/GeomAPIProjectPointOnCurve3.hpp>\n#include <geometry/GeomAPIProjectPointOnSurface.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/GlobalProperty.hpp>\n#include <healing/ShapeFixTool.hpp>\n#include <io/STLTool.hpp>\n#include <math/Sphere.hpp>\n#include <math/TriangularMesh.hpp>\n#include <modeling/CopyShape.hpp>\n#include <modeling/MakeBox.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeFace.hpp>\n#include <modeling/MakePrism.hpp>\n#include <modeling/MakeRevol.hpp>\n#include <modeling/MakeShapeTool.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <modeling/MakeWire.hpp>\n#include <modeling/TransformShape.hpp>\n#include <nurbs/NURBSAPIApprox.hpp>\n#include <nurbs/NURBSAPIBuildCurve.hpp>\n#include <nurbs/NURBSAPICircularSweep.hpp>\n#include <nurbs/NURBSAPIConvert.hpp>\n#include <nurbs/NURBSAPICurveNetworkSurface.hpp>\n#include <nurbs/NURBSAPIExplicitSweep.hpp>\n#include <nurbs/NURBSAPIExplode.hpp>\n#include <nurbs/NURBSAPIExtend.hpp>\n#include <nurbs/NURBSAPIInterpolate.hpp>\n#include <nurbs/NURBSAPIJoin.hpp>\n#include <nurbs/NURBSAPILinearSweep.hpp>\n#include <nurbs/NURBSAPILoft.hpp>\n#include <nurbs/NURBSAPIMakeNURBSFromBoundaries.hpp>\n#include <nurbs/NURBSAPIMatch.hpp>\n#include <nurbs/NURBSAPIModifyEndToPlane.hpp>\n#include <nurbs/NURBSAPIOffsetCurveOnSurface.hpp>\n#include <nurbs/NURBSAPIProject.hpp>\n#include <nurbs/NURBSAPIRebuild.hpp>\n#include <nurbs/NURBSAPIReplaceEdge.hpp>\n#include <nurbs/NURBSAPISweep.hpp>\n#include <nurbs/NURBSAPISweep2.hpp>\n#include <nurbs/NURBSAPISweepRotation.hpp>\n#include <nurbs/NURBSAPITrim.hpp>\n#include <nurbs/NURBSAPIUntrim.hpp>\n#include <nurbs/NURBSLinearSweepWithDraftDirectionLength.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <offset/MakePipe.hpp>\n#include <offset/MakePipeShell.hpp>\n#include <topology/BRepAdaptorCurve2.hpp>\n#include <topology/BRepAdaptorCurve3.hpp>\n#include <topology/BRepAdaptorSurface.hpp>\n#include <topology/BRepGlobalProperty.hpp>\n#include <topology/BRepTool.hpp>\n#include <topology/TopoBuilder.hpp>\n#include <topology/TopoCompound.hpp>\n#include <topology/TopoEdge.hpp>\n#include <topology/TopoExplorer.hpp>\n#include <topology/TopoExplorerTool.hpp>\n#include <topology/TopoFace.hpp>\n#include <topology/TopoShape.hpp>\n#include <topology/TopoShell.hpp>\n#include <topology/TopoTool.hpp>\n#include <topology/TopoVertex.hpp>\n#include <topology/TopoWire.hpp>\n#include <topology/WireExplorer.hpp>\n#include <topomesh/BRepMeshIncrementalMesh.hpp>\n#include <nurbs/NURBSAPIBlend.hpp>\n#include <topology/BRepExtremaDistShapeShape.hpp>\n#include <math/LineT.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/GeomAPIIntSurfaceSurface.hpp>\nusing namespace AMCAX;\nnamespace\n{\n\tstd::shared_ptr<Geom3BSplineCurve> CurveChooser(const int id, const std::shared_ptr<Geom3BSplineCurve>& curve0, const std::shared_ptr<Geom3BSplineCurve>& curve1, const std::shared_ptr<Geom3BSplineCurve>& curve2)\n\t{\n\t\tstd::shared_ptr<Geom3BSplineCurve> result;\n\t\tswitch (id)\n\t\t{\n\t\tcase 0:\n\t\t{\n\t\t\tresult = curve0;\n\t\t\tbreak;\n\t\t}\n\t\tcase 1:\n\t\t{\n\t\t\tresult = curve1;\n\t\t\tbreak;\n\t\t}\n\t\tcase 2:\n\t\t{\n\t\t\tresult = curve2;\n\t\t\tbreak;\n\t\t}\n\t\t}\n\t\treturn result;\n\t}\n} \n#include<catch.hpp>\n#include<testHelper.h>\n#include <filesystem>\n#include <fstream>\n#include <random>\n#include <sstream>\n#include <nurbs/NURBSAPIGetGeometry.hpp>\n#include <nurbs/NURBSAPIConicalSweep.hpp>\n#include <boolean/BoolBRepCut.hpp>\n#include <common/CartesianCoordinateSystem.hpp>\n#include <common/IndexMap.hpp>\n#include <common/QuaternionT.hpp>\n#include <geomAlgo/LawBSpline.hpp>\n#include <geomAlgo/LawConstant.hpp>\n#include <nurbs/NURBSAPISmooth.hpp>\n#include <geomAlgo/MakeConic2FromConstraints.hpp>\n#include <geometry/Adaptor3CurveOnSurface.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/AdaptorGeom3Surface.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2Circle.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/Geom2Hyperbola.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3BSplineCurve.hpp>\n#include <geometry/Geom3BSplineSurface.hpp>\n#include <geometry/Geom3Circle.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\n#include <geometry/Geom3Plane.hpp>\n#include <geometry/Geom3SphericalSurface.hpp>\n#include <geometry/Geom3Surface.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include <geometry/Geom3TrimmedSurface.hpp>\n#include <geometry/GeomAPIExtremaCurveCurve3.hpp>\n#include <geometry/GeomAPIProjectPointOnCurve2.hpp>\n#include <geometry/GeomAPIProjectPointOnCurve3.hpp>\n#include <geometry/GeomAPIProjectPointOnSurface.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/GlobalProperty.hpp>\n#include <healing/ShapeFixTool.hpp>\n#include <io/STLTool.hpp>\n#include <math/Sphere.hpp>\n#include <math/TriangularMesh.hpp>\n#include <modeling/CopyShape.hpp>\n#include <modeling/MakeBox.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeFace.hpp>\n#include <modeling/MakePrism.hpp>\n#include <modeling/MakeRevol.hpp>\n#include <modeling/MakeShapeTool.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <modeling/MakeWire.hpp>\n#include <modeling/TransformShape.hpp>\n#include <nurbs/NURBSAPIApprox.hpp>\n#include <nurbs/NURBSAPIBuildCurve.hpp>\n#include <nurbs/NURBSAPICircularSweep.hpp>\n#include <nurbs/NURBSAPIConvert.hpp>\n#include <nurbs/NURBSAPICurveNetworkSurface.hpp>\n#include <nurbs/NURBSAPIExplicitSweep.hpp>\n#include <nurbs/NURBSAPIExplode.hpp>\n#include <nurbs/NURBSAPIExtend.hpp>\n#include <nurbs/NURBSAPIInterpolate.hpp>\n#include <nurbs/NURBSAPIJoin.hpp>\n#include <nurbs/NURBSAPILinearSweep.hpp>\n#include <nurbs/NURBSAPILoft.hpp>\n#include <nurbs/NURBSAPIMakeNURBSFromBoundaries.hpp>\n#include <nurbs/NURBSAPIMatch.hpp>\n#include <nurbs/NURBSAPIModifyEndToPlane.hpp>\n#include <nurbs/NURBSAPIOffsetCurveOnSurface.hpp>\n#include <nurbs/NURBSAPIProject.hpp>\n#include <nurbs/NURBSAPIRebuild.hpp>\n#include <nurbs/NURBSAPIReplaceEdge.hpp>\n#include <nurbs/NURBSAPISweep.hpp>\n#include <nurbs/NURBSAPISweep2.hpp>\n#include <nurbs/NURBSAPISweepRotation.hpp>\n#include <nurbs/NURBSAPITrim.hpp>\n#include <nurbs/NURBSAPIUntrim.hpp>\n#include <nurbs/NURBSLinearSweepWithDraftDirectionLength.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <offset/MakePipe.hpp>\n#include <offset/MakePipeShell.hpp>\n#include <topology/BRepAdaptorCurve2.hpp>\n#include <topology/BRepAdaptorCurve3.hpp>\n#include <topology/BRepAdaptorSurface.hpp>\n#include <topology/BRepGlobalProperty.hpp>\n#include <topology/BRepTool.hpp>\n#include <topology/TopoBuilder.hpp>\n#include <topology/TopoCompound.hpp>\n#include <topology/TopoEdge.hpp>\n#include <topology/TopoExplorer.hpp>\n#include <topology/TopoExplorerTool.hpp>\n#include <topology/TopoFace.hpp>\n#include <topology/TopoShape.hpp>\n#include <topology/TopoShell.hpp>\n#include <topology/TopoTool.hpp>\n#include <topology/TopoVertex.hpp>\n#include <topology/TopoWire.hpp>\n#include <topology/WireExplorer.hpp>\n#include <topomesh/BRepMeshIncrementalMesh.hpp>\n#include <nurbs/NURBSAPIBlend.hpp>\n#include <topology/BRepExtremaDistShapeShape.hpp>\n#include <math/LineT.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/GeomAPIIntSurfaceSurface.hpp>\nusing namespace AMCAX;\nnamespace\n{\n\tstd::shared_ptr<Geom3BSplineCurve> CurveChooser(const int id, const std::shared_ptr<Geom3BSplineCurve>& curve0, const std::shared_ptr<Geom3BSplineCurve>& curve1, const std::shared_ptr<Geom3BSplineCurve>& curve2)\n\t{\n\t\tstd::shared_ptr<Geom3BSplineCurve> result;\n\t\tswitch (id)\n\t\t{\n\t\tcase 0:\n\t\t{\n\t\t\tresult = curve0;\n\t\t\tbreak;\n\t\t}\n\t\tcase 1:\n\t\t{\n\t\t\tresult = curve1;\n\t\t\tbreak;\n\t\t}\n\t\tcase 2:\n\t\t{\n\t\t\tresult = curve2;\n\t\t\tbreak;\n\t\t}\n\t\t}\n\t\treturn result;\n\t}\n;\n\tSECTION(\"TestCircularSweepWithCurveOnTangencySurface()\")\t\n\t\t{\n\t\t\tstd::string filedir(INPUT_PATH_PREFIX \"/TestNURBS/TestCircularSweepWithCurveOnTangencySurface/\");\n\t\t\tauto guide = ReadBRepCurve(filedir + \"guide.brep\");\n\t\t\tauto surface = ReadBRepSurface(filedir + \"surface.brep\");\n\t\t\tauto spine = ReadBRepCurve(filedir + \"spine.brep\");\n\t\t\tCHECK(OCCTIO::OCCTTool::Write(MakeEdge(guide), OUTPUT_PATH_PREFIX \"TestCircularSweepWithCurveOnTangencySurface_guide.brep\"));\n\t\t\tCHECK(OCCTIO::OCCTTool::Write(MakeEdge(spine), OUTPUT_PATH_PREFIX \"TestCircularSweepWithCurveOnTangencySurface_spine.brep\"));\n\t\t\tCHECK(OCCTIO::OCCTTool::Write(MakeFace(surface, 0.0), OUTPUT_PATH_PREFIX \"TestCircularSweepWithCurveOnTangencySurface_surface.brep\"));\n\t\t\tLawConstant radiusLaw, angleLaw1, angleLaw2;\n\t\t\tradiusLaw.Set(10.0, 0.0, 1.0);\n\t\t\tangleLaw1.Set(0.0, 0.0, 1.0);\n\t\t\tangleLaw2.Set(M_PI_2, 0.0, 1.0);\n\t\t\tauto [status, surfaces] = NURBSAPICircularSweep::SweepWithCurveOnTangencySurface(guide, surface, radiusLaw, angleLaw1, angleLaw2, spine, spine->FirstParameter(), spine->LastParameter());\n\t\t\tCHECK(status == NURBSSweepStatus::Success);\n\t\t\tif (status == NURBSSweepStatus::Success && !surfaces.empty())\n\t\t\t{\n\t\t\t\tint nsurfaces = static_cast<int>(surfaces.size());\n\t\t\t\tfor (int i = 0; i < nsurfaces; i++)\n\t\t\t\t{\n\t\t\t\t\tCHECK(OCCTIO::OCCTTool::Write(MakeFace(surfaces[i], 0.0), OUTPUT_PATH_PREFIX \"TestCircularSweepWithCurveOnTangencySurface_result\" + std::to_string(i) + \".brep\"));\n\t\t\t\t\tCHECK(IsCurveOnSurf(1000, 0.1, guide, surfaces[i], 0.5));\n\t\t\t\t\tAMCAX::BRepExtremaDistShapeShape len(MakeFace(surface, 0.0), MakeFace(surfaces[i], 0.0));\n\t\t\t\t\tAMCAX::BRepExtremaDistShapeShape len1(MakeFace(surfaces[i], 0.0), MakeEdge(guide));\n\t\t\t\t\tCHECK(len1.Value() < 1.0);\n\t\t\t\t\tCHECK(len.Value() < 0.1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tstd::string filedir1 = OUTPUT_PATH_PREFIX;\n\t\t\tIndexSet<TopoShape> newshapeEdge1;\n\t\t\tIndexSet<TopoShape> newshapeEdge2;\n\t\t\tTopoExplorerTool::MapShapes(MakeFace(surfaces[0], 0.0), ShapeType::Edge, newshapeEdge1);\n\t\t\tTopoExplorerTool::MapShapes(MakeFace(surfaces[1], 0.0), ShapeType::Edge, newshapeEdge2);\n\t\t\tstd::cout << \"newshapedege.size\" << newshapeEdge1.size() << endl;\n\t\t\tCHECK(OCCTIO::OCCTTool::Write(newshapeEdge1[0], OUTPUT_PATH_PREFIX \"TestCircularSweepWithCurveOnTangencySurface_newshapeEdge1[0].brep\"));\n\t\t\tCHECK(OCCTIO::OCCTTool::Write(newshapeEdge2[1], OUTPUT_PATH_PREFIX \"TestCircularSweepWithCurveOnTangencySurface_newshapeEdge2[1].brep\"));\n\t\t\tCHECK(OCCTIO::OCCTTool::Write(newshapeEdge2[2], OUTPUT_PATH_PREFIX \"TestCircularSweepWithCurveOnTangencySurface_newshapeEdge2[2].brep\"));\n\t\t\tCHECK(OCCTIO::OCCTTool::Write(newshapeEdge2[0], OUTPUT_PATH_PREFIX \"TestCircularSweepWithCurveOnTangencySurface_newshapeEdge2[0].brep\"));\n\t\t\tCHECK(OCCTIO::OCCTTool::Write(newshapeEdge2[3], OUTPUT_PATH_PREFIX \"TestCircularSweepWithCurveOnTangencySurface_newshapeEdge2[3].brep\"));\n\t\t\tauto edge0 = ReadBRepCurve(filedir1 + \"TestCircularSweepWithCurveOnTangencySurface_newshapeEdge1[0].brep\");\n\t\t\tauto edge1 = ReadBRepCurve(filedir1 + \"TestCircularSweepWithCurveOnTangencySurface_newshapeEdge2[0].brep\");\n\t\t\tCHECK(IsSurfTangent(100, 0.6, edge0, surface, surfaces[0], 20, 0));\n\t\t\tCHECK(IsSurfTangent(100, 0.6, edge1, surface, surfaces[0], 20, 0));\n\t\t\tguide->IncreaseDegree(5);\n\t\t\tspine->IncreaseDegree(5);\n\t\t\tsurface->IncreaseDegree(5, 5);\n\t\t\tauto [status1, surfaces1] = NURBSAPICircularSweep::SweepWithCurveOnTangencySurface(guide, surface, radiusLaw, angleLaw1, angleLaw2, spine, spine->FirstParameter(), spine->LastParameter());\n\t\t\tCHECK(status1 == NURBSSweepStatus::Success);\n\t\t\tif (status1 == NURBSSweepStatus::Success && !surfaces.empty())\n\t\t\t{\n\t\t\t\tint nsurfaces = static_cast<int>(surfaces.size());\n\t\t\t\tfor (int i = 0; i < nsurfaces; i++)\n\t\t\t\t{\n\t\t\t\t\tCHECK(OCCTIO::OCCTTool::Write(MakeFace(surfaces1[i], 0.0), OUTPUT_PATH_PREFIX \"TestCircularSweepWithCurveOnTangencySurface_degree5result\" + std::to_string(i) + \".brep\"));\n\t\t\t\t\tCHECK(IsCurveOnSurf(1000, 0.1, guide, surfaces1[i], 0.5));\n\t\t\t\t\tdouble bsp3s = GetSurfaceProperties(MakeFace(surfaces1[i], 0.0), g, true, true);\n\t\t\t\t\tdouble bsp4s = GetSurfaceProperties(MakeFace(surfaces[i], 0.0), g, true, true);\n\t\t\t\t\tCHECK(bsp3s == Approx(bsp4s).margin(0.02));\n\t\t\t\t}\n\t\t\t}\n\t\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static std::pair<NURBSSweepStatus, std::vector<std::shared_ptr<Geom3BSplineSurface>>> SweepWithOneGuideAndTangencySurface(const std::shared_ptr<Geom3BSplineCurve>& guide, const std::shared_ptr<Geom3BSplineSurface>& tangencySurface, const LawFunction& radiusLaw, const std::shared_ptr<Geom3BSplineCurve>& spine, double spineLeftBound, double spineRightBound),\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <filesystem>\n#include <fstream>\n#include <random>\n#include <sstream>\n#include <nurbs/NURBSAPIGetGeometry.hpp>\n#include <nurbs/NURBSAPIConicalSweep.hpp>\n#include <boolean/BoolBRepCut.hpp>\n#include <common/CartesianCoordinateSystem.hpp>\n#include <common/IndexMap.hpp>\n#include <common/QuaternionT.hpp>\n#include <geomAlgo/LawBSpline.hpp>\n#include <geomAlgo/LawConstant.hpp>\n#include <nurbs/NURBSAPISmooth.hpp>\n#include <geomAlgo/MakeConic2FromConstraints.hpp>\n#include <geometry/Adaptor3CurveOnSurface.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/AdaptorGeom3Surface.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2Circle.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/Geom2Hyperbola.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3BSplineCurve.hpp>\n#include <geometry/Geom3BSplineSurface.hpp>\n#include <geometry/Geom3Circle.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\n#include <geometry/Geom3Plane.hpp>\n#include <geometry/Geom3SphericalSurface.hpp>\n#include <geometry/Geom3Surface.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include <geometry/Geom3TrimmedSurface.hpp>\n#include <geometry/GeomAPIExtremaCurveCurve3.hpp>\n#include <geometry/GeomAPIProjectPointOnCurve2.hpp>\n#include <geometry/GeomAPIProjectPointOnCurve3.hpp>\n#include <geometry/GeomAPIProjectPointOnSurface.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/GlobalProperty.hpp>\n#include <healing/ShapeFixTool.hpp>\n#include <io/STLTool.hpp>\n#include <math/Sphere.hpp>\n#include <math/TriangularMesh.hpp>\n#include <modeling/CopyShape.hpp>\n#include <modeling/MakeBox.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeFace.hpp>\n#include <modeling/MakePrism.hpp>\n#include <modeling/MakeRevol.hpp>\n#include <modeling/MakeShapeTool.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <modeling/MakeWire.hpp>\n#include <modeling/TransformShape.hpp>\n#include <nurbs/NURBSAPIApprox.hpp>\n#include <nurbs/NURBSAPIBuildCurve.hpp>\n#include <nurbs/NURBSAPICircularSweep.hpp>\n#include <nurbs/NURBSAPIConvert.hpp>\n#include <nurbs/NURBSAPICurveNetworkSurface.hpp>\n#include <nurbs/NURBSAPIExplicitSweep.hpp>\n#include <nurbs/NURBSAPIExplode.hpp>\n#include <nurbs/NURBSAPIExtend.hpp>\n#include <nurbs/NURBSAPIInterpolate.hpp>\n#include <nurbs/NURBSAPIJoin.hpp>\n#include <nurbs/NURBSAPILinearSweep.hpp>\n#include <nurbs/NURBSAPILoft.hpp>\n#include <nurbs/NURBSAPIMakeNURBSFromBoundaries.hpp>\n#include <nurbs/NURBSAPIMatch.hpp>\n#include <nurbs/NURBSAPIModifyEndToPlane.hpp>\n#include <nurbs/NURBSAPIOffsetCurveOnSurface.hpp>\n#include <nurbs/NURBSAPIProject.hpp>\n#include <nurbs/NURBSAPIRebuild.hpp>\n#include <nurbs/NURBSAPIReplaceEdge.hpp>\n#include <nurbs/NURBSAPISweep.hpp>\n#include <nurbs/NURBSAPISweep2.hpp>\n#include <nurbs/NURBSAPISweepRotation.hpp>\n#include <nurbs/NURBSAPITrim.hpp>\n#include <nurbs/NURBSAPIUntrim.hpp>\n#include <nurbs/NURBSLinearSweepWithDraftDirectionLength.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <offset/MakePipe.hpp>\n#include <offset/MakePipeShell.hpp>\n#include <topology/BRepAdaptorCurve2.hpp>\n#include <topology/BRepAdaptorCurve3.hpp>\n#include <topology/BRepAdaptorSurface.hpp>\n#include <topology/BRepGlobalProperty.hpp>\n#include <topology/BRepTool.hpp>\n#include <topology/TopoBuilder.hpp>\n#include <topology/TopoCompound.hpp>\n#include <topology/TopoEdge.hpp>\n#include <topology/TopoExplorer.hpp>\n#include <topology/TopoExplorerTool.hpp>\n#include <topology/TopoFace.hpp>\n#include <topology/TopoShape.hpp>\n#include <topology/TopoShell.hpp>\n#include <topology/TopoTool.hpp>\n#include <topology/TopoVertex.hpp>\n#include <topology/TopoWire.hpp>\n#include <topology/WireExplorer.hpp>\n#include <topomesh/BRepMeshIncrementalMesh.hpp>\n#include <nurbs/NURBSAPIBlend.hpp>\n#include <topology/BRepExtremaDistShapeShape.hpp>\n#include <math/LineT.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/GeomAPIIntSurfaceSurface.hpp>\nusing namespace AMCAX;\nnamespace\n{\n\tstd::shared_ptr<Geom3BSplineCurve> CurveChooser(const int id, const std::shared_ptr<Geom3BSplineCurve>& curve0, const std::shared_ptr<Geom3BSplineCurve>& curve1, const std::shared_ptr<Geom3BSplineCurve>& curve2)\n\t{\n\t\tstd::shared_ptr<Geom3BSplineCurve> result;\n\t\tswitch (id)\n\t\t{\n\t\tcase 0:\n\t\t{\n\t\t\tresult = curve0;\n\t\t\tbreak;\n\t\t}\n\t\tcase 1:\n\t\t{\n\t\t\tresult = curve1;\n\t\t\tbreak;\n\t\t}\n\t\tcase 2:\n\t\t{\n\t\t\tresult = curve2;\n\t\t\tbreak;\n\t\t}\n\t\t}\n\t\treturn result;\n\t}\n} \n#include<catch.hpp>\n#include<testHelper.h>\n#include <filesystem>\n#include <fstream>\n#include <random>\n#include <sstream>\n#include <nurbs/NURBSAPIGetGeometry.hpp>\n#include <nurbs/NURBSAPIConicalSweep.hpp>\n#include <boolean/BoolBRepCut.hpp>\n#include <common/CartesianCoordinateSystem.hpp>\n#include <common/IndexMap.hpp>\n#include <common/QuaternionT.hpp>\n#include <geomAlgo/LawBSpline.hpp>\n#include <geomAlgo/LawConstant.hpp>\n#include <nurbs/NURBSAPISmooth.hpp>\n#include <geomAlgo/MakeConic2FromConstraints.hpp>\n#include <geometry/Adaptor3CurveOnSurface.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/AdaptorGeom3Surface.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2Circle.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/Geom2Hyperbola.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3BSplineCurve.hpp>\n#include <geometry/Geom3BSplineSurface.hpp>\n#include <geometry/Geom3Circle.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\n#include <geometry/Geom3Plane.hpp>\n#include <geometry/Geom3SphericalSurface.hpp>\n#include <geometry/Geom3Surface.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include <geometry/Geom3TrimmedSurface.hpp>\n#include <geometry/GeomAPIExtremaCurveCurve3.hpp>\n#include <geometry/GeomAPIProjectPointOnCurve2.hpp>\n#include <geometry/GeomAPIProjectPointOnCurve3.hpp>\n#include <geometry/GeomAPIProjectPointOnSurface.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/GlobalProperty.hpp>\n#include <healing/ShapeFixTool.hpp>\n#include <io/STLTool.hpp>\n#include <math/Sphere.hpp>\n#include <math/TriangularMesh.hpp>\n#include <modeling/CopyShape.hpp>\n#include <modeling/MakeBox.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeFace.hpp>\n#include <modeling/MakePrism.hpp>\n#include <modeling/MakeRevol.hpp>\n#include <modeling/MakeShapeTool.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <modeling/MakeWire.hpp>\n#include <modeling/TransformShape.hpp>\n#include <nurbs/NURBSAPIApprox.hpp>\n#include <nurbs/NURBSAPIBuildCurve.hpp>\n#include <nurbs/NURBSAPICircularSweep.hpp>\n#include <nurbs/NURBSAPIConvert.hpp>\n#include <nurbs/NURBSAPICurveNetworkSurface.hpp>\n#include <nurbs/NURBSAPIExplicitSweep.hpp>\n#include <nurbs/NURBSAPIExplode.hpp>\n#include <nurbs/NURBSAPIExtend.hpp>\n#include <nurbs/NURBSAPIInterpolate.hpp>\n#include <nurbs/NURBSAPIJoin.hpp>\n#include <nurbs/NURBSAPILinearSweep.hpp>\n#include <nurbs/NURBSAPILoft.hpp>\n#include <nurbs/NURBSAPIMakeNURBSFromBoundaries.hpp>\n#include <nurbs/NURBSAPIMatch.hpp>\n#include <nurbs/NURBSAPIModifyEndToPlane.hpp>\n#include <nurbs/NURBSAPIOffsetCurveOnSurface.hpp>\n#include <nurbs/NURBSAPIProject.hpp>\n#include <nurbs/NURBSAPIRebuild.hpp>\n#include <nurbs/NURBSAPIReplaceEdge.hpp>\n#include <nurbs/NURBSAPISweep.hpp>\n#include <nurbs/NURBSAPISweep2.hpp>\n#include <nurbs/NURBSAPISweepRotation.hpp>\n#include <nurbs/NURBSAPITrim.hpp>\n#include <nurbs/NURBSAPIUntrim.hpp>\n#include <nurbs/NURBSLinearSweepWithDraftDirectionLength.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <offset/MakePipe.hpp>\n#include <offset/MakePipeShell.hpp>\n#include <topology/BRepAdaptorCurve2.hpp>\n#include <topology/BRepAdaptorCurve3.hpp>\n#include <topology/BRepAdaptorSurface.hpp>\n#include <topology/BRepGlobalProperty.hpp>\n#include <topology/BRepTool.hpp>\n#include <topology/TopoBuilder.hpp>\n#include <topology/TopoCompound.hpp>\n#include <topology/TopoEdge.hpp>\n#include <topology/TopoExplorer.hpp>\n#include <topology/TopoExplorerTool.hpp>\n#include <topology/TopoFace.hpp>\n#include <topology/TopoShape.hpp>\n#include <topology/TopoShell.hpp>\n#include <topology/TopoTool.hpp>\n#include <topology/TopoVertex.hpp>\n#include <topology/TopoWire.hpp>\n#include <topology/WireExplorer.hpp>\n#include <topomesh/BRepMeshIncrementalMesh.hpp>\n#include <nurbs/NURBSAPIBlend.hpp>\n#include <topology/BRepExtremaDistShapeShape.hpp>\n#include <math/LineT.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/GeomAPIIntSurfaceSurface.hpp>\nusing namespace AMCAX;\nnamespace\n{\n\tstd::shared_ptr<Geom3BSplineCurve> CurveChooser(const int id, const std::shared_ptr<Geom3BSplineCurve>& curve0, const std::shared_ptr<Geom3BSplineCurve>& curve1, const std::shared_ptr<Geom3BSplineCurve>& curve2)\n\t{\n\t\tstd::shared_ptr<Geom3BSplineCurve> result;\n\t\tswitch (id)\n\t\t{\n\t\tcase 0:\n\t\t{\n\t\t\tresult = curve0;\n\t\t\tbreak;\n\t\t}\n\t\tcase 1:\n\t\t{\n\t\t\tresult = curve1;\n\t\t\tbreak;\n\t\t}\n\t\tcase 2:\n\t\t{\n\t\t\tresult = curve2;\n\t\t\tbreak;\n\t\t}\n\t\t}\n\t\treturn result;\n\t}\n;\n\tSECTION(\"TestCircularSweepWithOneGuideAndTangencySurface()\")\n\t\t{\n\t\t\tstd::string filedir(INPUT_PATH_PREFIX \"/TestNURBS/TestCircularSweepWithOneGuideAndTangencySurface/\");\n\t\t\tauto guide = ReadBRepCurve(filedir + \"guide.brep\");\n\t\t\tauto surface = ReadBRepSurface(filedir + \"surface.brep\");\n\t\t\tauto spine = ReadBRepCurve(filedir + \"spine.brep\");\n\t\t\tCHECK(OCCTIO::OCCTTool::Write(MakeEdge(guide), OUTPUT_PATH_PREFIX \"TestCircularSweepWithOneGuideAndTangencySurface_guide.brep\"));\n\t\t\tCHECK(OCCTIO::OCCTTool::Write(MakeEdge(spine), OUTPUT_PATH_PREFIX \"TestCircularSweepWithOneGuideAndTangencySurface_spine.brep\"));\n\t\t\tCHECK(OCCTIO::OCCTTool::Write(MakeFace(surface, 0.0), OUTPUT_PATH_PREFIX \"TestCircularSweepWithOneGuideAndTangencySurface_surface.brep\"));\n\t\t\tLawConstant radiusLaw;\n\t\t\tradiusLaw.Set(10.0, 0.0, 1.0);\n\t\t\tclock_t bg = clock();\n\t\t\tauto [status, surfaces] = NURBSAPICircularSweep::SweepWithOneGuideAndTangencySurface(guide, surface, radiusLaw, spine, spine->FirstParameter(), spine->LastParameter());\n\t\t\tGlobalProperty g;\n\t\t\tclock_t ed = clock();\n\t\t\tstd::cout << \"time = \" << ed - bg << \"ms\" << std::endl;\n\t\t\tCHECK(status == NURBSSweepStatus::Success);\n\t\t\tif (status == NURBSSweepStatus::Success && !surfaces.empty())\n\t\t\t{\n\t\t\t\tint nsurfaces = static_cast<int>(surfaces.size());\n\t\t\t\tfor (int i = 0; i < nsurfaces; i++)\n\t\t\t\t{\n\t\t\t\t\tAMCAX::BRepExtremaDistShapeShape len(MakeFace(surface, 0.0), MakeFace(surfaces[i], 0.0));\n\t\t\t\t\tAMCAX::BRepExtremaDistShapeShape len1(MakeFace(surfaces[i], 0.0), MakeEdge(guide));\n\t\t\t\t\tCHECK(len.Value() < 0.1);\n\t\t\t\t\tCHECK(len1.Value() < 0.1);\n\t\t\t\t\tCHECK(OCCTIO::OCCTTool::Write(MakeFace(surfaces[i], 0.0), OUTPUT_PATH_PREFIX \"TestCircularSweepWithOneGuideAndTangencySurface_result\" + std::to_string(i) + \".brep\"));\n\t\t\t\t}\n\t\t\t}\n\t\t\tstd::string filedir1 = OUTPUT_PATH_PREFIX;\n\t\t\tIndexSet<TopoShape> newshapeEdge0;\n\t\t\tIndexSet<TopoShape> newshapeEdge1;\n\t\t\tIndexSet<TopoShape> newshapeEdge2;\n\t\t\tIndexSet<TopoShape> newshapeEdge3;\n\t\t\tTopoExplorerTool::MapShapes(MakeFace(surfaces[0], 0.0), ShapeType::Edge, newshapeEdge0);\n\t\t\tTopoExplorerTool::MapShapes(MakeFace(surfaces[1], 0.0), ShapeType::Edge, newshapeEdge1);\n\t\t\tTopoExplorerTool::MapShapes(MakeFace(surfaces[2], 0.0), ShapeType::Edge, newshapeEdge2);\n\t\t\tTopoExplorerTool::MapShapes(MakeFace(surfaces[3], 0.0), ShapeType::Edge, newshapeEdge3);\n\t\t\tstd::cout << \"newshapedege.size\" << newshapeEdge1.size() << endl;\n\t\t\tCHECK(OCCTIO::OCCTTool::Write(newshapeEdge0[0], OUTPUT_PATH_PREFIX \"TestCircularSweepWithOneGuideAndTangencySurface_newshapeEdge0[0].brep\"));\n\t\t\tCHECK(OCCTIO::OCCTTool::Write(newshapeEdge1[2], OUTPUT_PATH_PREFIX \"TestCircularSweepWithOneGuideAndTangencySurface_newshapeEdge1[2].brep\"));\n\t\t\tCHECK(OCCTIO::OCCTTool::Write(newshapeEdge2[0], OUTPUT_PATH_PREFIX \"TestCircularSweepWithOneGuideAndTangencySurface_newshapeEdge2[0].brep\"));\n\t\t\tCHECK(OCCTIO::OCCTTool::Write(newshapeEdge3[0], OUTPUT_PATH_PREFIX \"TestCircularSweepWithOneGuideAndTangencySurface_newshapeEdge3[0].brep\"));\n\t\t\tauto edge0 = ReadBRepCurve(filedir1 + \"TestCircularSweepWithOneGuideAndTangencySurface_newshapeEdge0[0].brep\");\n\t\t\tauto edge1 = ReadBRepCurve(filedir1 + \"TestCircularSweepWithOneGuideAndTangencySurface_newshapeEdge1[2].brep\");\n\t\t\tauto edge2 = ReadBRepCurve(filedir1 + \"TestCircularSweepWithOneGuideAndTangencySurface_newshapeEdge2[0].brep\");\n\t\t\tauto edge3 = ReadBRepCurve(filedir1 + \"TestCircularSweepWithOneGuideAndTangencySurface_newshapeEdge3[0].brep\");\n\t\t\tCHECK(IsSurfTangent(100, 0.6, edge0, surface, surfaces[0], 20, 0));\n\t\t\tCHECK(IsSurfTangent(100, 0.6, edge1, surface, surfaces[1], 20, 180));\n\t\t\tCHECK(IsSurfTangent(100, 0.6, edge2, surface, surfaces[2], 20, 180));\n\t\t\tCHECK(IsSurfTangent(100, 0.6, edge3, surface, surfaces[3], 20, 0));\n\t\t\tguide->IncreaseDegree(11);\n\t\t\tspine->IncreaseDegree(11);\n\t\t\tsurface->IncreaseDegree(11, 11);\n\t\t\tauto [status1, surfaces1] = NURBSAPICircularSweep::SweepWithOneGuideAndTangencySurface(guide, surface, radiusLaw, spine, spine->FirstParameter(), spine->LastParameter());\n\t\t\tCHECK(status1 == NURBSSweepStatus::Success);\n\t\t\tif (status1 == NURBSSweepStatus::Success && !surfaces.empty())\n\t\t\t{\n\t\t\t\tint nsurfaces = static_cast<int>(surfaces.size());\n\t\t\t\tfor (int i = 0; i < nsurfaces; i++)\n\t\t\t\t{\n\t\t\t\t\tCHECK(OCCTIO::OCCTTool::Write(MakeFace(surfaces1[i], 0.0), OUTPUT_PATH_PREFIX \"TestCircularSweepWithOneGuideAndTangencySurface_degree11result\" + std::to_string(i) + \".brep\"));\n\t\t\t\t\tdouble bsp3s = GetSurfaceProperties(MakeFace(surfaces1[i], 0.0), g, true, true);\n\t\t\t\t\tdouble bsp4s = GetSurfaceProperties(MakeFace(surfaces[i], 0.0), g, true, true);\n\t\t\t\t\tCHECK(bsp3s == Approx(bsp4s).margin(0.02));\n\t\t\t\t}\n\t\t\t}\n\t\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static std::pair<NURBSSweepStatus, std::vector<std::shared_ptr<Geom3BSplineSurface>>> SweepWithTwoGuidesAndTangencySurface(const std::shared_ptr<Geom3BSplineCurve>& limitCurveWithTangency, const std::shared_ptr<Geom3BSplineSurface>& tangencySurface, const std::shared_ptr<Geom3BSplineCurve>& limitCurve, const std::shared_ptr<Geom3BSplineCurve>& spine, double spineLeftBound, double spineRightBound),\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <filesystem>\n#include <fstream>\n#include <random>\n#include <sstream>\n#include <nurbs/NURBSAPIGetGeometry.hpp>\n#include <nurbs/NURBSAPIConicalSweep.hpp>\n#include <boolean/BoolBRepCut.hpp>\n#include <common/CartesianCoordinateSystem.hpp>\n#include <common/IndexMap.hpp>\n#include <common/QuaternionT.hpp>\n#include <geomAlgo/LawBSpline.hpp>\n#include <geomAlgo/LawConstant.hpp>\n#include <nurbs/NURBSAPISmooth.hpp>\n#include <geomAlgo/MakeConic2FromConstraints.hpp>\n#include <geometry/Adaptor3CurveOnSurface.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/AdaptorGeom3Surface.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2Circle.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/Geom2Hyperbola.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3BSplineCurve.hpp>\n#include <geometry/Geom3BSplineSurface.hpp>\n#include <geometry/Geom3Circle.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\n#include <geometry/Geom3Plane.hpp>\n#include <geometry/Geom3SphericalSurface.hpp>\n#include <geometry/Geom3Surface.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include <geometry/Geom3TrimmedSurface.hpp>\n#include <geometry/GeomAPIExtremaCurveCurve3.hpp>\n#include <geometry/GeomAPIProjectPointOnCurve2.hpp>\n#include <geometry/GeomAPIProjectPointOnCurve3.hpp>\n#include <geometry/GeomAPIProjectPointOnSurface.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/GlobalProperty.hpp>\n#include <healing/ShapeFixTool.hpp>\n#include <io/STLTool.hpp>\n#include <math/Sphere.hpp>\n#include <math/TriangularMesh.hpp>\n#include <modeling/CopyShape.hpp>\n#include <modeling/MakeBox.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeFace.hpp>\n#include <modeling/MakePrism.hpp>\n#include <modeling/MakeRevol.hpp>\n#include <modeling/MakeShapeTool.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <modeling/MakeWire.hpp>\n#include <modeling/TransformShape.hpp>\n#include <nurbs/NURBSAPIApprox.hpp>\n#include <nurbs/NURBSAPIBuildCurve.hpp>\n#include <nurbs/NURBSAPICircularSweep.hpp>\n#include <nurbs/NURBSAPIConvert.hpp>\n#include <nurbs/NURBSAPICurveNetworkSurface.hpp>\n#include <nurbs/NURBSAPIExplicitSweep.hpp>\n#include <nurbs/NURBSAPIExplode.hpp>\n#include <nurbs/NURBSAPIExtend.hpp>\n#include <nurbs/NURBSAPIInterpolate.hpp>\n#include <nurbs/NURBSAPIJoin.hpp>\n#include <nurbs/NURBSAPILinearSweep.hpp>\n#include <nurbs/NURBSAPILoft.hpp>\n#include <nurbs/NURBSAPIMakeNURBSFromBoundaries.hpp>\n#include <nurbs/NURBSAPIMatch.hpp>\n#include <nurbs/NURBSAPIModifyEndToPlane.hpp>\n#include <nurbs/NURBSAPIOffsetCurveOnSurface.hpp>\n#include <nurbs/NURBSAPIProject.hpp>\n#include <nurbs/NURBSAPIRebuild.hpp>\n#include <nurbs/NURBSAPIReplaceEdge.hpp>\n#include <nurbs/NURBSAPISweep.hpp>\n#include <nurbs/NURBSAPISweep2.hpp>\n#include <nurbs/NURBSAPISweepRotation.hpp>\n#include <nurbs/NURBSAPITrim.hpp>\n#include <nurbs/NURBSAPIUntrim.hpp>\n#include <nurbs/NURBSLinearSweepWithDraftDirectionLength.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <offset/MakePipe.hpp>\n#include <offset/MakePipeShell.hpp>\n#include <topology/BRepAdaptorCurve2.hpp>\n#include <topology/BRepAdaptorCurve3.hpp>\n#include <topology/BRepAdaptorSurface.hpp>\n#include <topology/BRepGlobalProperty.hpp>\n#include <topology/BRepTool.hpp>\n#include <topology/TopoBuilder.hpp>\n#include <topology/TopoCompound.hpp>\n#include <topology/TopoEdge.hpp>\n#include <topology/TopoExplorer.hpp>\n#include <topology/TopoExplorerTool.hpp>\n#include <topology/TopoFace.hpp>\n#include <topology/TopoShape.hpp>\n#include <topology/TopoShell.hpp>\n#include <topology/TopoTool.hpp>\n#include <topology/TopoVertex.hpp>\n#include <topology/TopoWire.hpp>\n#include <topology/WireExplorer.hpp>\n#include <topomesh/BRepMeshIncrementalMesh.hpp>\n#include <nurbs/NURBSAPIBlend.hpp>\n#include <topology/BRepExtremaDistShapeShape.hpp>\n#include <math/LineT.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/GeomAPIIntSurfaceSurface.hpp>\nusing namespace AMCAX;\nnamespace\n{\n\tstd::shared_ptr<Geom3BSplineCurve> CurveChooser(const int id, const std::shared_ptr<Geom3BSplineCurve>& curve0, const std::shared_ptr<Geom3BSplineCurve>& curve1, const std::shared_ptr<Geom3BSplineCurve>& curve2)\n\t{\n\t\tstd::shared_ptr<Geom3BSplineCurve> result;\n\t\tswitch (id)\n\t\t{\n\t\tcase 0:\n\t\t{\n\t\t\tresult = curve0;\n\t\t\tbreak;\n\t\t}\n\t\tcase 1:\n\t\t{\n\t\t\tresult = curve1;\n\t\t\tbreak;\n\t\t}\n\t\tcase 2:\n\t\t{\n\t\t\tresult = curve2;\n\t\t\tbreak;\n\t\t}\n\t\t}\n\t\treturn result;\n\t}\n} \n#include<catch.hpp>\n#include<testHelper.h>\n#include <filesystem>\n#include <fstream>\n#include <random>\n#include <sstream>\n#include <nurbs/NURBSAPIGetGeometry.hpp>\n#include <nurbs/NURBSAPIConicalSweep.hpp>\n#include <boolean/BoolBRepCut.hpp>\n#include <common/CartesianCoordinateSystem.hpp>\n#include <common/IndexMap.hpp>\n#include <common/QuaternionT.hpp>\n#include <geomAlgo/LawBSpline.hpp>\n#include <geomAlgo/LawConstant.hpp>\n#include <nurbs/NURBSAPISmooth.hpp>\n#include <geomAlgo/MakeConic2FromConstraints.hpp>\n#include <geometry/Adaptor3CurveOnSurface.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/AdaptorGeom3Surface.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2Circle.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/Geom2Hyperbola.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3BSplineCurve.hpp>\n#include <geometry/Geom3BSplineSurface.hpp>\n#include <geometry/Geom3Circle.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\n#include <geometry/Geom3Plane.hpp>\n#include <geometry/Geom3SphericalSurface.hpp>\n#include <geometry/Geom3Surface.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include <geometry/Geom3TrimmedSurface.hpp>\n#include <geometry/GeomAPIExtremaCurveCurve3.hpp>\n#include <geometry/GeomAPIProjectPointOnCurve2.hpp>\n#include <geometry/GeomAPIProjectPointOnCurve3.hpp>\n#include <geometry/GeomAPIProjectPointOnSurface.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/GlobalProperty.hpp>\n#include <healing/ShapeFixTool.hpp>\n#include <io/STLTool.hpp>\n#include <math/Sphere.hpp>\n#include <math/TriangularMesh.hpp>\n#include <modeling/CopyShape.hpp>\n#include <modeling/MakeBox.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeFace.hpp>\n#include <modeling/MakePrism.hpp>\n#include <modeling/MakeRevol.hpp>\n#include <modeling/MakeShapeTool.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <modeling/MakeWire.hpp>\n#include <modeling/TransformShape.hpp>\n#include <nurbs/NURBSAPIApprox.hpp>\n#include <nurbs/NURBSAPIBuildCurve.hpp>\n#include <nurbs/NURBSAPICircularSweep.hpp>\n#include <nurbs/NURBSAPIConvert.hpp>\n#include <nurbs/NURBSAPICurveNetworkSurface.hpp>\n#include <nurbs/NURBSAPIExplicitSweep.hpp>\n#include <nurbs/NURBSAPIExplode.hpp>\n#include <nurbs/NURBSAPIExtend.hpp>\n#include <nurbs/NURBSAPIInterpolate.hpp>\n#include <nurbs/NURBSAPIJoin.hpp>\n#include <nurbs/NURBSAPILinearSweep.hpp>\n#include <nurbs/NURBSAPILoft.hpp>\n#include <nurbs/NURBSAPIMakeNURBSFromBoundaries.hpp>\n#include <nurbs/NURBSAPIMatch.hpp>\n#include <nurbs/NURBSAPIModifyEndToPlane.hpp>\n#include <nurbs/NURBSAPIOffsetCurveOnSurface.hpp>\n#include <nurbs/NURBSAPIProject.hpp>\n#include <nurbs/NURBSAPIRebuild.hpp>\n#include <nurbs/NURBSAPIReplaceEdge.hpp>\n#include <nurbs/NURBSAPISweep.hpp>\n#include <nurbs/NURBSAPISweep2.hpp>\n#include <nurbs/NURBSAPISweepRotation.hpp>\n#include <nurbs/NURBSAPITrim.hpp>\n#include <nurbs/NURBSAPIUntrim.hpp>\n#include <nurbs/NURBSLinearSweepWithDraftDirectionLength.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <offset/MakePipe.hpp>\n#include <offset/MakePipeShell.hpp>\n#include <topology/BRepAdaptorCurve2.hpp>\n#include <topology/BRepAdaptorCurve3.hpp>\n#include <topology/BRepAdaptorSurface.hpp>\n#include <topology/BRepGlobalProperty.hpp>\n#include <topology/BRepTool.hpp>\n#include <topology/TopoBuilder.hpp>\n#include <topology/TopoCompound.hpp>\n#include <topology/TopoEdge.hpp>\n#include <topology/TopoExplorer.hpp>\n#include <topology/TopoExplorerTool.hpp>\n#include <topology/TopoFace.hpp>\n#include <topology/TopoShape.hpp>\n#include <topology/TopoShell.hpp>\n#include <topology/TopoTool.hpp>\n#include <topology/TopoVertex.hpp>\n#include <topology/TopoWire.hpp>\n#include <topology/WireExplorer.hpp>\n#include <topomesh/BRepMeshIncrementalMesh.hpp>\n#include <nurbs/NURBSAPIBlend.hpp>\n#include <topology/BRepExtremaDistShapeShape.hpp>\n#include <math/LineT.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/GeomAPIIntSurfaceSurface.hpp>\nusing namespace AMCAX;\nnamespace\n{\n\tstd::shared_ptr<Geom3BSplineCurve> CurveChooser(const int id, const std::shared_ptr<Geom3BSplineCurve>& curve0, const std::shared_ptr<Geom3BSplineCurve>& curve1, const std::shared_ptr<Geom3BSplineCurve>& curve2)\n\t{\n\t\tstd::shared_ptr<Geom3BSplineCurve> result;\n\t\tswitch (id)\n\t\t{\n\t\tcase 0:\n\t\t{\n\t\t\tresult = curve0;\n\t\t\tbreak;\n\t\t}\n\t\tcase 1:\n\t\t{\n\t\t\tresult = curve1;\n\t\t\tbreak;\n\t\t}\n\t\tcase 2:\n\t\t{\n\t\t\tresult = curve2;\n\t\t\tbreak;\n\t\t}\n\t\t}\n\t\treturn result;\n\t}\n;\n\tSECTION(\"TestCircularSweepWithTwoGuidesAndTangencySurface()\")\n\t{\n\t\tstd::string filedir(INPUT_PATH_PREFIX \"/TestNURBS/TestCircularSweepWithTwoGuidesAndTangencySurface/\");\n\t\tauto guide1 = ReadBRepCurve(filedir + \"guide1.brep\");\n\t\tauto guide2 = ReadBRepCurve(filedir + \"guide2.brep\");\n\t\tauto surface = ReadBRepSurface(filedir + \"surface.brep\");\n\t\tauto spine = ReadBRepCurve(filedir + \"spine.brep\");\n\t\tCHECK(OCCTIO::OCCTTool::Write(MakeEdge(guide1), OUTPUT_PATH_PREFIX \"TestCircularSweepWithTwoGuidesAndTangencySurface_guide1.brep\"));\n\t\tCHECK(OCCTIO::OCCTTool::Write(MakeEdge(guide2), OUTPUT_PATH_PREFIX \"TestCircularSweepWithTwoGuidesAndTangencySurface_guide2.brep\"));\n\t\tCHECK(OCCTIO::OCCTTool::Write(MakeEdge(spine), OUTPUT_PATH_PREFIX \"TestCircularSweepWithTwoGuidesAndTangencySurface_spine.brep\"));\n\t\tCHECK(OCCTIO::OCCTTool::Write(MakeFace(surface, 0.0), OUTPUT_PATH_PREFIX \"TestCircularSweepWithTwoGuidesAndTangencySurface_surface.brep\"));\n\t\tauto [status, surfaces] = NURBSAPICircularSweep::SweepWithTwoGuidesAndTangencySurface(guide1, surface, guide2, spine, spine->FirstParameter(), spine->LastParameter());\n\t\tCHECK(status == NURBSSweepStatus::Success);\n\t\tif (status == NURBSSweepStatus::Success && !surfaces.empty())\n\t\t{\n\t\t\tCHECK(surfaces.size() == Approx(2.0));\n\t\t\tfor (int i = 0; i < surfaces.size(); i++) {\n\t\t\t\tCHECK(OCCTIO::OCCTTool::Write(MakeFace(surfaces[i], 0.0), OUTPUT_PATH_PREFIX \"TestCircularSweepWithTwoGuidesAndTangencySurface_result\" + std::to_string(i) + \".brep\"));\n\t\t\t\tAMCAX::BRepExtremaDistShapeShape len1(MakeEdge(guide1), MakeFace(surfaces[i], 0.0));\n\t\t\t\tAMCAX::BRepExtremaDistShapeShape len2(MakeEdge(guide2), MakeFace(surfaces[i], 0.0));\n\t\t\t\tAMCAX::BRepExtremaDistShapeShape len3(MakeFace(surface, 0.0), MakeFace(surfaces[i], 0.0));\n\t\t\t\tCHECK(len1.Value() < 0.1);\n\t\t\t\tCHECK(len2.Value() < 0.1);\n\t\t\t\tCHECK(len3.Value() < 0.1);\n\t\t\t\tCHECK(IsCurveOnSurf(100, 0.3, guide1, surfaces[i], 0.1));\n\t\t\t\tCHECK(IsCurveOnSurf(100, 0.3, guide2, surfaces[i], 0.1));\n\t\t\t}\n\t\t}\n\t\t\tCHECK(IsSurfTangent(100, 0.6, guide1, surface, surfaces[0], 20, 180));\n\t\t\tCHECK(IsSurfTangent(100, 0.6, guide1, surface, surfaces[1], 20, 180));\n\t\t\tguide1->IncreaseDegree(11);\n\t\t\tguide2->IncreaseDegree(11);\n\t\t\tspine->IncreaseDegree(11);\n\t\t\tsurface->IncreaseDegree(11, 11);\n\t\t\tauto [status1, surfaces1] = NURBSAPICircularSweep::SweepWithTwoGuidesAndTangencySurface(guide1, surface, guide2, spine, spine->FirstParameter(), spine->LastParameter());\n\t\t\tCHECK(status1 == NURBSSweepStatus::Success);\n\t\t\tif (status1 == NURBSSweepStatus::Success && !surfaces1.empty())\n\t\t\t{\n\t\t\t\tCHECK(surfaces1.size() == Approx(2.0));\n\t\t\t\tfor (int i = 0; i < surfaces1.size(); i++) {\n\t\t\t\t\tCHECK(OCCTIO::OCCTTool::Write(MakeFace(surfaces1[i], 0.0), OUTPUT_PATH_PREFIX \"TestCircularSweepWithTwoGuidesAndTangencySurface_result\" + std::to_string(i) + \".brep\"));\n\t\t\t\t\tAMCAX::BRepExtremaDistShapeShape len1(MakeEdge(guide1), MakeFace(surfaces1[i], 0.0));\n\t\t\t\t\tAMCAX::BRepExtremaDistShapeShape len2(MakeEdge(guide2), MakeFace(surfaces1[i], 0.0));\n\t\t\t\t\tAMCAX::BRepExtremaDistShapeShape len3(MakeFace(surface, 0.0), MakeFace(surfaces1[i], 0.0));\n\t\t\t\t\tCHECK(len1.Value() < 0.1);\n\t\t\t\t\tCHECK(len2.Value() < 0.1);\n\t\t\t\t\tCHECK(len3.Value() < 0.1);\n\t\t\t\t\tCHECK(IsCurveOnSurf(100, 0.3, guide1, surfaces1[i], 0.1));\n\t\t\t\t\tCHECK(IsCurveOnSurf(100, 0.3, guide2, surfaces1[i], 0.1));\n\t\t\t\t\tdouble bsp3s = GetSurfaceProperties(MakeFace(surfaces1[i], 0.0), g, true, true);\n\t\t\t\t\tdouble bsp4s = GetSurfaceProperties(MakeFace(surfaces[i], 0.0), g, true, true);\n\t\t\t\t\tCHECK(bsp3s == Approx(bsp4s).margin(0.02));\n\t\t\t\t}\n\t\t\t}\n\t\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static std::pair<NURBSSweepStatus, std::vector<std::shared_ptr<Geom3BSplineSurface>>> SweepWithTwoGuidesAndRadius(const std::shared_ptr<Geom3BSplineCurve>& guide1, const std::shared_ptr<Geom3BSplineCurve>& guide2, const LawFunction& radiusLaw, const std::shared_ptr<Geom3BSplineCurve>& spine, double spineLeftBound, double spineRightBound),\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <filesystem>\n#include <fstream>\n#include <random>\n#include <sstream>\n#include <nurbs/NURBSAPIGetGeometry.hpp>\n#include <nurbs/NURBSAPIConicalSweep.hpp>\n#include <boolean/BoolBRepCut.hpp>\n#include <common/CartesianCoordinateSystem.hpp>\n#include <common/IndexMap.hpp>\n#include <common/QuaternionT.hpp>\n#include <geomAlgo/LawBSpline.hpp>\n#include <geomAlgo/LawConstant.hpp>\n#include <nurbs/NURBSAPISmooth.hpp>\n#include <geomAlgo/MakeConic2FromConstraints.hpp>\n#include <geometry/Adaptor3CurveOnSurface.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/AdaptorGeom3Surface.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2Circle.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/Geom2Hyperbola.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3BSplineCurve.hpp>\n#include <geometry/Geom3BSplineSurface.hpp>\n#include <geometry/Geom3Circle.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\n#include <geometry/Geom3Plane.hpp>\n#include <geometry/Geom3SphericalSurface.hpp>\n#include <geometry/Geom3Surface.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include <geometry/Geom3TrimmedSurface.hpp>\n#include <geometry/GeomAPIExtremaCurveCurve3.hpp>\n#include <geometry/GeomAPIProjectPointOnCurve2.hpp>\n#include <geometry/GeomAPIProjectPointOnCurve3.hpp>\n#include <geometry/GeomAPIProjectPointOnSurface.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/GlobalProperty.hpp>\n#include <healing/ShapeFixTool.hpp>\n#include <io/STLTool.hpp>\n#include <math/Sphere.hpp>\n#include <math/TriangularMesh.hpp>\n#include <modeling/CopyShape.hpp>\n#include <modeling/MakeBox.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeFace.hpp>\n#include <modeling/MakePrism.hpp>\n#include <modeling/MakeRevol.hpp>\n#include <modeling/MakeShapeTool.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <modeling/MakeWire.hpp>\n#include <modeling/TransformShape.hpp>\n#include <nurbs/NURBSAPIApprox.hpp>\n#include <nurbs/NURBSAPIBuildCurve.hpp>\n#include <nurbs/NURBSAPICircularSweep.hpp>\n#include <nurbs/NURBSAPIConvert.hpp>\n#include <nurbs/NURBSAPICurveNetworkSurface.hpp>\n#include <nurbs/NURBSAPIExplicitSweep.hpp>\n#include <nurbs/NURBSAPIExplode.hpp>\n#include <nurbs/NURBSAPIExtend.hpp>\n#include <nurbs/NURBSAPIInterpolate.hpp>\n#include <nurbs/NURBSAPIJoin.hpp>\n#include <nurbs/NURBSAPILinearSweep.hpp>\n#include <nurbs/NURBSAPILoft.hpp>\n#include <nurbs/NURBSAPIMakeNURBSFromBoundaries.hpp>\n#include <nurbs/NURBSAPIMatch.hpp>\n#include <nurbs/NURBSAPIModifyEndToPlane.hpp>\n#include <nurbs/NURBSAPIOffsetCurveOnSurface.hpp>\n#include <nurbs/NURBSAPIProject.hpp>\n#include <nurbs/NURBSAPIRebuild.hpp>\n#include <nurbs/NURBSAPIReplaceEdge.hpp>\n#include <nurbs/NURBSAPISweep.hpp>\n#include <nurbs/NURBSAPISweep2.hpp>\n#include <nurbs/NURBSAPISweepRotation.hpp>\n#include <nurbs/NURBSAPITrim.hpp>\n#include <nurbs/NURBSAPIUntrim.hpp>\n#include <nurbs/NURBSLinearSweepWithDraftDirectionLength.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <offset/MakePipe.hpp>\n#include <offset/MakePipeShell.hpp>\n#include <topology/BRepAdaptorCurve2.hpp>\n#include <topology/BRepAdaptorCurve3.hpp>\n#include <topology/BRepAdaptorSurface.hpp>\n#include <topology/BRepGlobalProperty.hpp>\n#include <topology/BRepTool.hpp>\n#include <topology/TopoBuilder.hpp>\n#include <topology/TopoCompound.hpp>\n#include <topology/TopoEdge.hpp>\n#include <topology/TopoExplorer.hpp>\n#include <topology/TopoExplorerTool.hpp>\n#include <topology/TopoFace.hpp>\n#include <topology/TopoShape.hpp>\n#include <topology/TopoShell.hpp>\n#include <topology/TopoTool.hpp>\n#include <topology/TopoVertex.hpp>\n#include <topology/TopoWire.hpp>\n#include <topology/WireExplorer.hpp>\n#include <topomesh/BRepMeshIncrementalMesh.hpp>\n#include <nurbs/NURBSAPIBlend.hpp>\n#include <topology/BRepExtremaDistShapeShape.hpp>\n#include <math/LineT.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/GeomAPIIntSurfaceSurface.hpp>\nusing namespace AMCAX;\nnamespace\n{\n\tstd::shared_ptr<Geom3BSplineCurve> CurveChooser(const int id, const std::shared_ptr<Geom3BSplineCurve>& curve0, const std::shared_ptr<Geom3BSplineCurve>& curve1, const std::shared_ptr<Geom3BSplineCurve>& curve2)\n\t{\n\t\tstd::shared_ptr<Geom3BSplineCurve> result;\n\t\tswitch (id)\n\t\t{\n\t\tcase 0:\n\t\t{\n\t\t\tresult = curve0;\n\t\t\tbreak;\n\t\t}\n\t\tcase 1:\n\t\t{\n\t\t\tresult = curve1;\n\t\t\tbreak;\n\t\t}\n\t\tcase 2:\n\t\t{\n\t\t\tresult = curve2;\n\t\t\tbreak;\n\t\t}\n\t\t}\n\t\treturn result;\n\t}\n} \n#include<catch.hpp>\n#include<testHelper.h>\n#include <filesystem>\n#include <fstream>\n#include <random>\n#include <sstream>\n#include <nurbs/NURBSAPIGetGeometry.hpp>\n#include <nurbs/NURBSAPIConicalSweep.hpp>\n#include <boolean/BoolBRepCut.hpp>\n#include <common/CartesianCoordinateSystem.hpp>\n#include <common/IndexMap.hpp>\n#include <common/QuaternionT.hpp>\n#include <geomAlgo/LawBSpline.hpp>\n#include <geomAlgo/LawConstant.hpp>\n#include <nurbs/NURBSAPISmooth.hpp>\n#include <geomAlgo/MakeConic2FromConstraints.hpp>\n#include <geometry/Adaptor3CurveOnSurface.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/AdaptorGeom3Surface.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2Circle.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/Geom2Hyperbola.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3BSplineCurve.hpp>\n#include <geometry/Geom3BSplineSurface.hpp>\n#include <geometry/Geom3Circle.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\n#include <geometry/Geom3Plane.hpp>\n#include <geometry/Geom3SphericalSurface.hpp>\n#include <geometry/Geom3Surface.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include <geometry/Geom3TrimmedSurface.hpp>\n#include <geometry/GeomAPIExtremaCurveCurve3.hpp>\n#include <geometry/GeomAPIProjectPointOnCurve2.hpp>\n#include <geometry/GeomAPIProjectPointOnCurve3.hpp>\n#include <geometry/GeomAPIProjectPointOnSurface.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/GlobalProperty.hpp>\n#include <healing/ShapeFixTool.hpp>\n#include <io/STLTool.hpp>\n#include <math/Sphere.hpp>\n#include <math/TriangularMesh.hpp>\n#include <modeling/CopyShape.hpp>\n#include <modeling/MakeBox.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeFace.hpp>\n#include <modeling/MakePrism.hpp>\n#include <modeling/MakeRevol.hpp>\n#include <modeling/MakeShapeTool.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <modeling/MakeWire.hpp>\n#include <modeling/TransformShape.hpp>\n#include <nurbs/NURBSAPIApprox.hpp>\n#include <nurbs/NURBSAPIBuildCurve.hpp>\n#include <nurbs/NURBSAPICircularSweep.hpp>\n#include <nurbs/NURBSAPIConvert.hpp>\n#include <nurbs/NURBSAPICurveNetworkSurface.hpp>\n#include <nurbs/NURBSAPIExplicitSweep.hpp>\n#include <nurbs/NURBSAPIExplode.hpp>\n#include <nurbs/NURBSAPIExtend.hpp>\n#include <nurbs/NURBSAPIInterpolate.hpp>\n#include <nurbs/NURBSAPIJoin.hpp>\n#include <nurbs/NURBSAPILinearSweep.hpp>\n#include <nurbs/NURBSAPILoft.hpp>\n#include <nurbs/NURBSAPIMakeNURBSFromBoundaries.hpp>\n#include <nurbs/NURBSAPIMatch.hpp>\n#include <nurbs/NURBSAPIModifyEndToPlane.hpp>\n#include <nurbs/NURBSAPIOffsetCurveOnSurface.hpp>\n#include <nurbs/NURBSAPIProject.hpp>\n#include <nurbs/NURBSAPIRebuild.hpp>\n#include <nurbs/NURBSAPIReplaceEdge.hpp>\n#include <nurbs/NURBSAPISweep.hpp>\n#include <nurbs/NURBSAPISweep2.hpp>\n#include <nurbs/NURBSAPISweepRotation.hpp>\n#include <nurbs/NURBSAPITrim.hpp>\n#include <nurbs/NURBSAPIUntrim.hpp>\n#include <nurbs/NURBSLinearSweepWithDraftDirectionLength.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <offset/MakePipe.hpp>\n#include <offset/MakePipeShell.hpp>\n#include <topology/BRepAdaptorCurve2.hpp>\n#include <topology/BRepAdaptorCurve3.hpp>\n#include <topology/BRepAdaptorSurface.hpp>\n#include <topology/BRepGlobalProperty.hpp>\n#include <topology/BRepTool.hpp>\n#include <topology/TopoBuilder.hpp>\n#include <topology/TopoCompound.hpp>\n#include <topology/TopoEdge.hpp>\n#include <topology/TopoExplorer.hpp>\n#include <topology/TopoExplorerTool.hpp>\n#include <topology/TopoFace.hpp>\n#include <topology/TopoShape.hpp>\n#include <topology/TopoShell.hpp>\n#include <topology/TopoTool.hpp>\n#include <topology/TopoVertex.hpp>\n#include <topology/TopoWire.hpp>\n#include <topology/WireExplorer.hpp>\n#include <topomesh/BRepMeshIncrementalMesh.hpp>\n#include <nurbs/NURBSAPIBlend.hpp>\n#include <topology/BRepExtremaDistShapeShape.hpp>\n#include <math/LineT.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/GeomAPIIntSurfaceSurface.hpp>\nusing namespace AMCAX;\nnamespace\n{\n\tstd::shared_ptr<Geom3BSplineCurve> CurveChooser(const int id, const std::shared_ptr<Geom3BSplineCurve>& curve0, const std::shared_ptr<Geom3BSplineCurve>& curve1, const std::shared_ptr<Geom3BSplineCurve>& curve2)\n\t{\n\t\tstd::shared_ptr<Geom3BSplineCurve> result;\n\t\tswitch (id)\n\t\t{\n\t\tcase 0:\n\t\t{\n\t\t\tresult = curve0;\n\t\t\tbreak;\n\t\t}\n\t\tcase 1:\n\t\t{\n\t\t\tresult = curve1;\n\t\t\tbreak;\n\t\t}\n\t\tcase 2:\n\t\t{\n\t\t\tresult = curve2;\n\t\t\tbreak;\n\t\t}\n\t\t}\n\t\treturn result;\n\t}\n;\n\tSECTION(\"TestCircularSweepWithTwoGuidesAndRadius()\")\n\t{\n\t\tstd::string filedir(INPUT_PATH_PREFIX \"/TestNURBS/TestCircularSweepWithTwoGuidesAndRadius/\");\n\t\tauto guide1 = ReadBRepCurve(filedir + \"guide1.brep\");\n\t\tauto guide2 = ReadBRepCurve(filedir + \"guide2.brep\");\n\t\tauto spine = ReadBRepCurve(filedir + \"spine.brep\");\n\t\tCHECK(OCCTIO::OCCTTool::Write(MakeEdge(guide1), OUTPUT_PATH_PREFIX \"TestCircularSweepWithTwoGuidesAndRadius_guide1.brep\"));\n\t\tCHECK(OCCTIO::OCCTTool::Write(MakeEdge(guide2), OUTPUT_PATH_PREFIX \"TestCircularSweepWithTwoGuidesAndRadius_guide2.brep\"));\n\t\tCHECK(OCCTIO::OCCTTool::Write(MakeEdge(spine), OUTPUT_PATH_PREFIX \"TestCircularSweepWithTwoGuidesAndRadius_spine.brep\"));\n\t\tLawConstant radiusLaw;\n\t\tradiusLaw.Set(10.0, 0.0, 1.0);\n\t\tauto [status, surfaces] = NURBSAPICircularSweep::SweepWithTwoGuidesAndRadius(guide1, guide2, radiusLaw, spine, spine->FirstParameter(), spine->LastParameter());\n\t\tCHECK(status == NURBSSweepStatus::Success);\n\t\tif (status == NURBSSweepStatus::Success && !surfaces.empty())\n\t\t{\n\t\t\tCHECK(OCCTIO::OCCTTool::Write(MakeFace(surfaces.front(), 0.0), OUTPUT_PATH_PREFIX \"TestCircularSweepWithTwoGuidesAndRadius_result.brep\"));\n\t\t\tfor (int i = 0; i < surfaces.size(); i++)\n\t\t\t{\n\t\t\t\tCHECK(OCCTIO::OCCTTool::Write(MakeFace(surfaces[i], 0.0), OUTPUT_PATH_PREFIX \"TestCircularSweepWithTwoGuidesAndRadius_result\" + std::to_string(i) + \".brep\"));\n\t\t\t\tAMCAX::BRepExtremaDistShapeShape len1(MakeEdge(guide1), MakeFace(surfaces[i], 0.0));\n\t\t\t\tAMCAX::BRepExtremaDistShapeShape len2(MakeFace(surfaces[i], 0.0), MakeEdge(guide2));\n\t\t\t\tAMCAX::BRepExtremaDistShapeShape len3(MakeFace(surfaces[i], 0.0), MakeEdge(spine));\n\t\t\t\tCHECK(len1.Value() < 0.1);\n\t\t\t\tCHECK(len2.Value() < 0.1);\n\t\t\t\tCHECK(IsCurveOnSurf(1000, 0.1, guide1, surfaces[i], 0.1));\n\t\t\t\tCHECK(IsCurveOnSurf(1000, 0.1, guide2, surfaces[i], 0.1));\n\t\t\t}\n\t\t}\n\t\tspine->IncreaseDegree(11);\n\t\tguide1->IncreaseDegree(11);\n\t\tguide2->IncreaseDegree(11);\n\t\tauto [status1, surfaces1] = NURBSAPICircularSweep::SweepWithTwoGuidesAndRadius(guide1, guide2, radiusLaw, spine, spine->FirstParameter(), spine->LastParameter());\n\t\tCHECK(status1 == NURBSSweepStatus::Success);\n\t\tfor (int i = 0; i < surfaces.size(); i++)\n\t\t{\n\t\t\tCHECK(OCCTIO::OCCTTool::Write(MakeFace(surfaces[i], 0.0), OUTPUT_PATH_PREFIX \"TestCircularSweepWithTwoGuidesAndRadius_degree11result\" + std::to_string(i) + \".brep\"));\n\t\t\tdouble bsp3s = GetSurfaceProperties(MakeFace(surfaces1[i], 0.0), g, true, true);\n\t\t\tdouble bsp4s = GetSurfaceProperties(MakeFace(surfaces[i], 0.0), g, true, true);\n\t\t\tCHECK(bsp3s == Approx(bsp4s).margin(0.02));\n\t\t}\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static std::pair<NURBSSweepStatus, std::shared_ptr<Geom3BSplineSurface>> SweepWithThreeGuides(const std::shared_ptr<Geom3BSplineCurve>& guide1, const std::shared_ptr<Geom3BSplineCurve>& guide2, const std::shared_ptr<Geom3BSplineCurve>& guide3, const std::shared_ptr<Geom3BSplineCurve>& spine, double spineLeftBound, double spineRightBound),\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <filesystem>\n#include <fstream>\n#include <random>\n#include <sstream>\n#include <nurbs/NURBSAPIGetGeometry.hpp>\n#include <nurbs/NURBSAPIConicalSweep.hpp>\n#include <boolean/BoolBRepCut.hpp>\n#include <common/CartesianCoordinateSystem.hpp>\n#include <common/IndexMap.hpp>\n#include <common/QuaternionT.hpp>\n#include <geomAlgo/LawBSpline.hpp>\n#include <geomAlgo/LawConstant.hpp>\n#include <nurbs/NURBSAPISmooth.hpp>\n#include <geomAlgo/MakeConic2FromConstraints.hpp>\n#include <geometry/Adaptor3CurveOnSurface.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/AdaptorGeom3Surface.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2Circle.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/Geom2Hyperbola.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3BSplineCurve.hpp>\n#include <geometry/Geom3BSplineSurface.hpp>\n#include <geometry/Geom3Circle.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\n#include <geometry/Geom3Plane.hpp>\n#include <geometry/Geom3SphericalSurface.hpp>\n#include <geometry/Geom3Surface.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include <geometry/Geom3TrimmedSurface.hpp>\n#include <geometry/GeomAPIExtremaCurveCurve3.hpp>\n#include <geometry/GeomAPIProjectPointOnCurve2.hpp>\n#include <geometry/GeomAPIProjectPointOnCurve3.hpp>\n#include <geometry/GeomAPIProjectPointOnSurface.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/GlobalProperty.hpp>\n#include <healing/ShapeFixTool.hpp>\n#include <io/STLTool.hpp>\n#include <math/Sphere.hpp>\n#include <math/TriangularMesh.hpp>\n#include <modeling/CopyShape.hpp>\n#include <modeling/MakeBox.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeFace.hpp>\n#include <modeling/MakePrism.hpp>\n#include <modeling/MakeRevol.hpp>\n#include <modeling/MakeShapeTool.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <modeling/MakeWire.hpp>\n#include <modeling/TransformShape.hpp>\n#include <nurbs/NURBSAPIApprox.hpp>\n#include <nurbs/NURBSAPIBuildCurve.hpp>\n#include <nurbs/NURBSAPICircularSweep.hpp>\n#include <nurbs/NURBSAPIConvert.hpp>\n#include <nurbs/NURBSAPICurveNetworkSurface.hpp>\n#include <nurbs/NURBSAPIExplicitSweep.hpp>\n#include <nurbs/NURBSAPIExplode.hpp>\n#include <nurbs/NURBSAPIExtend.hpp>\n#include <nurbs/NURBSAPIInterpolate.hpp>\n#include <nurbs/NURBSAPIJoin.hpp>\n#include <nurbs/NURBSAPILinearSweep.hpp>\n#include <nurbs/NURBSAPILoft.hpp>\n#include <nurbs/NURBSAPIMakeNURBSFromBoundaries.hpp>\n#include <nurbs/NURBSAPIMatch.hpp>\n#include <nurbs/NURBSAPIModifyEndToPlane.hpp>\n#include <nurbs/NURBSAPIOffsetCurveOnSurface.hpp>\n#include <nurbs/NURBSAPIProject.hpp>\n#include <nurbs/NURBSAPIRebuild.hpp>\n#include <nurbs/NURBSAPIReplaceEdge.hpp>\n#include <nurbs/NURBSAPISweep.hpp>\n#include <nurbs/NURBSAPISweep2.hpp>\n#include <nurbs/NURBSAPISweepRotation.hpp>\n#include <nurbs/NURBSAPITrim.hpp>\n#include <nurbs/NURBSAPIUntrim.hpp>\n#include <nurbs/NURBSLinearSweepWithDraftDirectionLength.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <offset/MakePipe.hpp>\n#include <offset/MakePipeShell.hpp>\n#include <topology/BRepAdaptorCurve2.hpp>\n#include <topology/BRepAdaptorCurve3.hpp>\n#include <topology/BRepAdaptorSurface.hpp>\n#include <topology/BRepGlobalProperty.hpp>\n#include <topology/BRepTool.hpp>\n#include <topology/TopoBuilder.hpp>\n#include <topology/TopoCompound.hpp>\n#include <topology/TopoEdge.hpp>\n#include <topology/TopoExplorer.hpp>\n#include <topology/TopoExplorerTool.hpp>\n#include <topology/TopoFace.hpp>\n#include <topology/TopoShape.hpp>\n#include <topology/TopoShell.hpp>\n#include <topology/TopoTool.hpp>\n#include <topology/TopoVertex.hpp>\n#include <topology/TopoWire.hpp>\n#include <topology/WireExplorer.hpp>\n#include <topomesh/BRepMeshIncrementalMesh.hpp>\n#include <nurbs/NURBSAPIBlend.hpp>\n#include <topology/BRepExtremaDistShapeShape.hpp>\n#include <math/LineT.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/GeomAPIIntSurfaceSurface.hpp>\nusing namespace AMCAX;\nnamespace\n{\n\tstd::shared_ptr<Geom3BSplineCurve> CurveChooser(const int id, const std::shared_ptr<Geom3BSplineCurve>& curve0, const std::shared_ptr<Geom3BSplineCurve>& curve1, const std::shared_ptr<Geom3BSplineCurve>& curve2)\n\t{\n\t\tstd::shared_ptr<Geom3BSplineCurve> result;\n\t\tswitch (id)\n\t\t{\n\t\tcase 0:\n\t\t{\n\t\t\tresult = curve0;\n\t\t\tbreak;\n\t\t}\n\t\tcase 1:\n\t\t{\n\t\t\tresult = curve1;\n\t\t\tbreak;\n\t\t}\n\t\tcase 2:\n\t\t{\n\t\t\tresult = curve2;\n\t\t\tbreak;\n\t\t}\n\t\t}\n\t\treturn result;\n\t}\n} \n#include<catch.hpp>\n#include<testHelper.h>\n#include <filesystem>\n#include <fstream>\n#include <random>\n#include <sstream>\n#include <nurbs/NURBSAPIGetGeometry.hpp>\n#include <nurbs/NURBSAPIConicalSweep.hpp>\n#include <boolean/BoolBRepCut.hpp>\n#include <common/CartesianCoordinateSystem.hpp>\n#include <common/IndexMap.hpp>\n#include <common/QuaternionT.hpp>\n#include <geomAlgo/LawBSpline.hpp>\n#include <geomAlgo/LawConstant.hpp>\n#include <nurbs/NURBSAPISmooth.hpp>\n#include <geomAlgo/MakeConic2FromConstraints.hpp>\n#include <geometry/Adaptor3CurveOnSurface.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/AdaptorGeom3Surface.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2Circle.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/Geom2Hyperbola.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3BSplineCurve.hpp>\n#include <geometry/Geom3BSplineSurface.hpp>\n#include <geometry/Geom3Circle.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\n#include <geometry/Geom3Plane.hpp>\n#include <geometry/Geom3SphericalSurface.hpp>\n#include <geometry/Geom3Surface.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include <geometry/Geom3TrimmedSurface.hpp>\n#include <geometry/GeomAPIExtremaCurveCurve3.hpp>\n#include <geometry/GeomAPIProjectPointOnCurve2.hpp>\n#include <geometry/GeomAPIProjectPointOnCurve3.hpp>\n#include <geometry/GeomAPIProjectPointOnSurface.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/GlobalProperty.hpp>\n#include <healing/ShapeFixTool.hpp>\n#include <io/STLTool.hpp>\n#include <math/Sphere.hpp>\n#include <math/TriangularMesh.hpp>\n#include <modeling/CopyShape.hpp>\n#include <modeling/MakeBox.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeFace.hpp>\n#include <modeling/MakePrism.hpp>\n#include <modeling/MakeRevol.hpp>\n#include <modeling/MakeShapeTool.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <modeling/MakeWire.hpp>\n#include <modeling/TransformShape.hpp>\n#include <nurbs/NURBSAPIApprox.hpp>\n#include <nurbs/NURBSAPIBuildCurve.hpp>\n#include <nurbs/NURBSAPICircularSweep.hpp>\n#include <nurbs/NURBSAPIConvert.hpp>\n#include <nurbs/NURBSAPICurveNetworkSurface.hpp>\n#include <nurbs/NURBSAPIExplicitSweep.hpp>\n#include <nurbs/NURBSAPIExplode.hpp>\n#include <nurbs/NURBSAPIExtend.hpp>\n#include <nurbs/NURBSAPIInterpolate.hpp>\n#include <nurbs/NURBSAPIJoin.hpp>\n#include <nurbs/NURBSAPILinearSweep.hpp>\n#include <nurbs/NURBSAPILoft.hpp>\n#include <nurbs/NURBSAPIMakeNURBSFromBoundaries.hpp>\n#include <nurbs/NURBSAPIMatch.hpp>\n#include <nurbs/NURBSAPIModifyEndToPlane.hpp>\n#include <nurbs/NURBSAPIOffsetCurveOnSurface.hpp>\n#include <nurbs/NURBSAPIProject.hpp>\n#include <nurbs/NURBSAPIRebuild.hpp>\n#include <nurbs/NURBSAPIReplaceEdge.hpp>\n#include <nurbs/NURBSAPISweep.hpp>\n#include <nurbs/NURBSAPISweep2.hpp>\n#include <nurbs/NURBSAPISweepRotation.hpp>\n#include <nurbs/NURBSAPITrim.hpp>\n#include <nurbs/NURBSAPIUntrim.hpp>\n#include <nurbs/NURBSLinearSweepWithDraftDirectionLength.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <offset/MakePipe.hpp>\n#include <offset/MakePipeShell.hpp>\n#include <topology/BRepAdaptorCurve2.hpp>\n#include <topology/BRepAdaptorCurve3.hpp>\n#include <topology/BRepAdaptorSurface.hpp>\n#include <topology/BRepGlobalProperty.hpp>\n#include <topology/BRepTool.hpp>\n#include <topology/TopoBuilder.hpp>\n#include <topology/TopoCompound.hpp>\n#include <topology/TopoEdge.hpp>\n#include <topology/TopoExplorer.hpp>\n#include <topology/TopoExplorerTool.hpp>\n#include <topology/TopoFace.hpp>\n#include <topology/TopoShape.hpp>\n#include <topology/TopoShell.hpp>\n#include <topology/TopoTool.hpp>\n#include <topology/TopoVertex.hpp>\n#include <topology/TopoWire.hpp>\n#include <topology/WireExplorer.hpp>\n#include <topomesh/BRepMeshIncrementalMesh.hpp>\n#include <nurbs/NURBSAPIBlend.hpp>\n#include <topology/BRepExtremaDistShapeShape.hpp>\n#include <math/LineT.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/GeomAPIIntSurfaceSurface.hpp>\nusing namespace AMCAX;\nnamespace\n{\n\tstd::shared_ptr<Geom3BSplineCurve> CurveChooser(const int id, const std::shared_ptr<Geom3BSplineCurve>& curve0, const std::shared_ptr<Geom3BSplineCurve>& curve1, const std::shared_ptr<Geom3BSplineCurve>& curve2)\n\t{\n\t\tstd::shared_ptr<Geom3BSplineCurve> result;\n\t\tswitch (id)\n\t\t{\n\t\tcase 0:\n\t\t{\n\t\t\tresult = curve0;\n\t\t\tbreak;\n\t\t}\n\t\tcase 1:\n\t\t{\n\t\t\tresult = curve1;\n\t\t\tbreak;\n\t\t}\n\t\tcase 2:\n\t\t{\n\t\t\tresult = curve2;\n\t\t\tbreak;\n\t\t}\n\t\t}\n\t\treturn result;\n\t}\n;\n\tSECTION(\"TestCircularSweepWithThreeGuides()\")\n\t{\n\t\tstd::string filedir(INPUT_PATH_PREFIX \"/TestNURBS/TestCircularSweepWithThreeGuides/\");\n\t\tauto guide1 = ReadBRepCurve(filedir + \"guide1.brep\");\n\t\tauto guide2 = ReadBRepCurve(filedir + \"guide2.brep\");\n\t\tauto guide3 = ReadBRepCurve(filedir + \"guide3.brep\");\n\t\tauto spine = ReadBRepCurve(filedir + \"spine.brep\");\n\t\tCHECK(OCCTIO::OCCTTool::Write(MakeEdge(guide1), OUTPUT_PATH_PREFIX \"TestCircularSweepWithThreeGuides_guide1.brep\"));\n\t\tCHECK(OCCTIO::OCCTTool::Write(MakeEdge(guide2), OUTPUT_PATH_PREFIX \"TestCircularSweepWithThreeGuides_guide2.brep\"));\n\t\tCHECK(OCCTIO::OCCTTool::Write(MakeEdge(guide3), OUTPUT_PATH_PREFIX \"TestCircularSweepWithThreeGuides_guide3.brep\"));\n\t\tCHECK(OCCTIO::OCCTTool::Write(MakeEdge(spine), OUTPUT_PATH_PREFIX \"TestCircularSweepWithThreeGuides_spine.brep\"));\n\t\tauto [status, surface] = NURBSAPICircularSweep::SweepWithThreeGuides(guide1, guide2, guide3, spine, spine->FirstParameter(), spine->LastParameter());\n\t\tCHECK(status == NURBSSweepStatus::Success);\n\t\tif (status == NURBSSweepStatus::Success && surface)\n\t\t{\n\t\t\tCHECK(OCCTIO::OCCTTool::Write(MakeFace(surface, 0.0), OUTPUT_PATH_PREFIX \"TestCircularSweepWithThreeGuides_result.brep\"));\n\t\t\tAMCAX::BRepExtremaDistShapeShape len1(MakeEdge(guide1), MakeFace(surface, 0.0));\n\t\t\tAMCAX::BRepExtremaDistShapeShape len2(MakeFace(surface, 0.0), MakeEdge(guide2));\n\t\t\tAMCAX::BRepExtremaDistShapeShape len3(MakeFace(surface, 0.0), MakeEdge(guide3));\n\t\t\tAMCAX::BRepExtremaDistShapeShape len4(MakeFace(surface, 0.0), MakeEdge(spine));\n\t\t\tCHECK(len1.Value() < 0.1);\n\t\t\tCHECK(len2.Value() < 0.1);\n\t\t\tCHECK(len3.Value() < 0.1);\n\t\t\tCHECK(IsCurveOnSurf(1000, 0.1, guide1, surface, 0.1));\n\t\t\tCHECK(IsCurveOnSurf(1000, 0.1, guide2, surface, 0.1));\n\t\t\tCHECK(IsCurveOnSurf(1000, 0.1, guide3, surface, 0.1));\n\t\t\tIndexSet<TopoShape> newshapeEdge1;\n\t\t\tTopoExplorerTool::MapShapes(MakeFace(surface, 0.0), ShapeType::Edge, newshapeEdge1);\n\t\t\tTopoExplorer ex0(newshapeEdge1[0], ShapeType::Edge);\n\t\t\tTopoExplorer ex1(newshapeEdge1[2], ShapeType::Edge);\n\t\t\tTopoEdge e0 = static_cast<const TopoEdge&>(ex0.Value());\n\t\t\tTopoEdge e1 = static_cast<const TopoEdge&>(ex1.Value());\n\t\t\tauto edge0 = NURBSAPIGetGeometry::GetCurve(e0);\n\t\t\tauto edge1 = NURBSAPIGetGeometry::GetCurve(e1);\n\t\t\tdouble n0 = NurbsSampleCurve(100, 0.1, edge0, guide1);\n\t\t\tdouble n1 = NurbsSampleCurve(100, 0.1, edge1, guide3);\n\t\t\tCHECK(n0 < 0.2);\n\t\t\tCHECK(n1 < 0.2);\n\t\t}\n\t\tspine->IncreaseDegree(5);\n\t\tguide1->IncreaseDegree(5);\n\t\tguide2->IncreaseDegree(5);\n\t\tguide3->IncreaseDegree(5);\n\t\tauto [status1, surface1] = NURBSAPICircularSweep::SweepWithThreeGuides(guide1, guide2, guide3, spine, spine->FirstParameter(), spine->LastParameter());\n\t\tCHECK(status1 == NURBSSweepStatus::Success);\n\t\tif (status1 == NURBSSweepStatus::Success && surface)\n\t\t{\n\t\t\tAMCAX::BRepExtremaDistShapeShape len11(MakeEdge(guide1), MakeFace(surface1, 0.0));\n\t\t\tAMCAX::BRepExtremaDistShapeShape len12(MakeFace(surface1, 0.0), MakeEdge(guide2));\n\t\t\tAMCAX::BRepExtremaDistShapeShape len13(MakeFace(surface1, 0.0), MakeEdge(guide3));\n\t\t\tAMCAX::BRepExtremaDistShapeShape len14(MakeFace(surface1, 0.0), MakeEdge(spine));\n\t\t\tCHECK(len11.Value() < 0.1);\n\t\t\tCHECK(len12.Value() < 0.1);\n\t\t\tCHECK(len13.Value() < 0.1);\n\t\t\tCHECK(IsCurveOnSurf(1000, 0.1, guide1, surface1, 0.1));\n\t\t\tCHECK(IsCurveOnSurf(1000, 0.1, guide2, surface1, 0.1));\n\t\t\tCHECK(IsCurveOnSurf(1000, 0.1, guide3, surface1, 0.1));\n\t\t\tdouble bsp3s = GetSurfaceProperties(MakeFace(surface1, 0.0), g, true, true);\n\t\t\tdouble bsp4s = GetSurfaceProperties(MakeFace(surface, 0.0), g, true, true);\n\t\t\tCHECK(bsp3s == Approx(bsp4s).margin(0.1));\n\t\t}\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static std::shared_ptr<Geom3BSplineCurve> BuildCurve(const std::vector<Point3>& poles, const std::vector<double>& weights, int degree, bool isPeriodic)\t @return The built curve. If building curve is failed, return nullptr\n\t @param isPeriodic Whether the curve is periodic or not\n\t @param degree The curve degree\n\t @param weights Curve weights\n\t @param poles Curve poles. If it is a periodic curve, don't include the point at the end that repeats the first point\n\t @brief Build NURBS curve\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <nurbs/NURBSAPIBuildCurve.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <nurbs/NURBSAPIExtend.hpp>\n#include <geomAlgo/LawConstant.hpp>\n#include <nurbs/NURBSAPILinearSweep.hpp>\n#include <modeling/MakeFace.hpp>\nstd::shared_ptr<AMCAX::Geom3BSplineCurve> BuildBSpCurve(const std::vector<AMCAX::Point3>& poles, int degree, bool isPeriodic)\n{\n\tint npoles = static_cast<int>(poles.size());\n\tif (isPeriodic)\n\t{\n\t\treturn AMCAX::NURBSAPIBuildCurve::BuildCurve(poles, std::min(degree, npoles), true);\n\t}\n\telse\n\t{\n\t\treturn AMCAX::NURBSAPIBuildCurve::BuildCurve(poles, std::min(degree, npoles - 1), false);\n\t}\n}\n#include<catch.hpp>\n#include<testHelper.h>\n#include <nurbs/NURBSAPIBuildCurve.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <nurbs/NURBSAPIExtend.hpp>\n#include <geomAlgo/LawConstant.hpp>\n#include <nurbs/NURBSAPILinearSweep.hpp>\n#include <modeling/MakeFace.hpp>\nstd::shared_ptr<AMCAX::Geom3BSplineCurve> BuildBSpCurve(const std::vector<AMCAX::Point3>& poles, int degree, bool isPeriodic)\n{\n\tint npoles = static_cast<int>(poles.size());\n\tif (isPeriodic)\n\t{\n\t\treturn AMCAX::NURBSAPIBuildCurve::BuildCurve(poles, std::min(degree, npoles), true);\n\t}\n\telse\n\t{\n\t\treturn AMCAX::NURBSAPIBuildCurve::BuildCurve(poles, std::min(degree, npoles - 1), false);\n\t}\n;\n\tSECTION(\"TestBuildCurve()\")\n\t{\n\t\tOUTPUT_DIRECTORY(nurbs, BuildCurve/BuildCurve);\n\t\tstd::vector<Point3> poles;\n\t\tPoint3 p1(0.0, 0.0, 0.0);\n\t\tPoint3 p2(-0.1, 1.0, -0.2);\n\t\tPoint3 p3(0.1, 2.0, -0.1);\n\t\tPoint3 p4(0.2, 3.0, 0.1);\n\t\tPoint3 p5(0.1, 4.0, 0.0);\n\t\tPoint3 p6(0.0, 5.0, -0.1);\n\t\tpoles.push_back(p1);\n\t\tpoles.push_back(p2);\n\t\tpoles.push_back(p3);\n\t\tpoles.push_back(p4);\n\t\tpoles.push_back(p5);\n\t\tpoles.push_back(p6);\n\t\tbool isPeriodic = false;\n\t\tint degree = NURBSAPIBuildCurve::ValidMaxDegree(static_cast<int>(poles.size()), isPeriodic);\n\t\tdegree = std::min(3, degree);\n\t\tauto curve = NURBSAPIBuildCurve::BuildCurve(poles, degree, isPeriodic);\n\t\tPoint3 sp1 = curve->StartPoint();\n\t\tPoint3 ep1 = curve->EndPoint();\n\t\tCHECK(sp1.X() == Approx(p1.X()));\n\t\tCHECK(sp1.Y() == Approx(p1.Y()));\n\t\tCHECK(sp1.Z() == Approx(p1.Z()));\n\t\tCHECK(ep1.X() == Approx(p6.X()).margin(1e-7));\n\t\tCHECK(ep1.Y() == Approx(p6.Y()).margin(1e-7));\n\t\tCHECK(ep1.Z() == Approx(p6.Z()).margin(1e-7));\n\t\tCHECK(curve->Degree() == degree);\n\t\tCHECK(curve->NPoles() == 6);\n\t\tCHECK(curve->IsPeriodic() == false);\n\t\tvector<Point3> vec = curve->Poles();\n\t\tCHECK(vec.size() == 6);\n\t\tCHECK(vec[0].X() == Approx(p1.X()));\n\t\tCHECK(vec[0].Y() == Approx(p1.Y()));\n\t\tCHECK(vec[0].Z() == Approx(p1.Z()));\n\t\tCHECK(vec[1].X() == Approx(p2.X()));\n\t\tCHECK(vec[1].Y() == Approx(p2.Y()));\n\t\tCHECK(vec[1].Z() == Approx(p2.Z()));\n\t\tCHECK(vec[2].X() == Approx(p3.X()));\n\t\tCHECK(vec[2].Y() == Approx(p3.Y()));\n\t\tCHECK(vec[2].Z() == Approx(p3.Z()));\n\t\tCHECK(vec[3].X() == Approx(p4.X()));\n\t\tCHECK(vec[3].Y() == Approx(p4.Y()));\n\t\tCHECK(vec[3].Z() == Approx(p4.Z()));\n\t\tCHECK(vec[4].X() == Approx(p5.X()));\n\t\tCHECK(vec[4].Y() == Approx(p5.Y()));\n\t\tCHECK(vec[4].Z() == Approx(p5.Z()));\n\t\tCHECK(vec[5].X() == Approx(p6.X()));\n\t\tCHECK(vec[5].Y() == Approx(p6.Y()));\n\t\tCHECK(vec[5].Z() == Approx(p6.Z()));\n\t\tOCCTIO::OCCTTool::Write(MakeVertex(p1), outdir + \"p1.brep\");\n\t\tOCCTIO::OCCTTool::Write(MakeVertex(p2), outdir + \"p2.brep\");\n\t\tOCCTIO::OCCTTool::Write(MakeVertex(p3), outdir + \"p3.brep\");\n\t\tOCCTIO::OCCTTool::Write(MakeVertex(p4), outdir + \"p4.brep\");\n\t\tOCCTIO::OCCTTool::Write(MakeVertex(p5), outdir + \"p5.brep\");\n\t\tOCCTIO::OCCTTool::Write(MakeVertex(p6), outdir + \"p6.brep\");\n\t\tOCCTIO::OCCTTool::Write(MakeEdge(curve), outdir + \"result.brep\");\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static std::shared_ptr<Geom3BSplineCurve> BuildCurve(const std::vector<Point3>& poles, int degree, bool isPeriodic)\t @return The built curve. If building curve is failed, return nullptr\n\t @param isPeriodic Whether the curve is periodic or not\n\t @param degree The curve degree\n\t @param poles Curve poles. If it is a periodic curve, don't include the point at the end that repeats the first point\n\t @brief Build BSpline curve\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <nurbs/NURBSAPIBuildCurve.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <nurbs/NURBSAPIExtend.hpp>\n#include <geomAlgo/LawConstant.hpp>\n#include <nurbs/NURBSAPILinearSweep.hpp>\n#include <modeling/MakeFace.hpp>\nstd::shared_ptr<AMCAX::Geom3BSplineCurve> BuildBSpCurve(const std::vector<AMCAX::Point3>& poles, int degree, bool isPeriodic)\n{\n\tint npoles = static_cast<int>(poles.size());\n\tif (isPeriodic)\n\t{\n\t\treturn AMCAX::NURBSAPIBuildCurve::BuildCurve(poles, std::min(degree, npoles), true);\n\t}\n\telse\n\t{\n\t\treturn AMCAX::NURBSAPIBuildCurve::BuildCurve(poles, std::min(degree, npoles - 1), false);\n\t}\n}\n#include<catch.hpp>\n#include<testHelper.h>\n#include <nurbs/NURBSAPIBuildCurve.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <nurbs/NURBSAPIExtend.hpp>\n#include <geomAlgo/LawConstant.hpp>\n#include <nurbs/NURBSAPILinearSweep.hpp>\n#include <modeling/MakeFace.hpp>\nstd::shared_ptr<AMCAX::Geom3BSplineCurve> BuildBSpCurve(const std::vector<AMCAX::Point3>& poles, int degree, bool isPeriodic)\n{\n\tint npoles = static_cast<int>(poles.size());\n\tif (isPeriodic)\n\t{\n\t\treturn AMCAX::NURBSAPIBuildCurve::BuildCurve(poles, std::min(degree, npoles), true);\n\t}\n\telse\n\t{\n\t\treturn AMCAX::NURBSAPIBuildCurve::BuildCurve(poles, std::min(degree, npoles - 1), false);\n\t}\n;\n\tSECTION(\"TestBuildCurve()\")\n\t{\n\t\tOUTPUT_DIRECTORY(nurbs, BuildCurve/BuildCurve);\n\t\tstd::vector<Point3> poles;\n\t\tPoint3 p1(0.0, 0.0, 0.0);\n\t\tPoint3 p2(-0.1, 1.0, -0.2);\n\t\tPoint3 p3(0.1, 2.0, -0.1);\n\t\tPoint3 p4(0.2, 3.0, 0.1);\n\t\tPoint3 p5(0.1, 4.0, 0.0);\n\t\tPoint3 p6(0.0, 5.0, -0.1);\n\t\tpoles.push_back(p1);\n\t\tpoles.push_back(p2);\n\t\tpoles.push_back(p3);\n\t\tpoles.push_back(p4);\n\t\tpoles.push_back(p5);\n\t\tpoles.push_back(p6);\n\t\tbool isPeriodic = false;\n\t\tint degree = NURBSAPIBuildCurve::ValidMaxDegree(static_cast<int>(poles.size()), isPeriodic);\n\t\tdegree = std::min(3, degree);\n\t\tauto curve = NURBSAPIBuildCurve::BuildCurve(poles, degree, isPeriodic);\n\t\tPoint3 sp1 = curve->StartPoint();\n\t\tPoint3 ep1 = curve->EndPoint();\n\t\tCHECK(sp1.X() == Approx(p1.X()));\n\t\tCHECK(sp1.Y() == Approx(p1.Y()));\n\t\tCHECK(sp1.Z() == Approx(p1.Z()));\n\t\tCHECK(ep1.X() == Approx(p6.X()).margin(1e-7));\n\t\tCHECK(ep1.Y() == Approx(p6.Y()).margin(1e-7));\n\t\tCHECK(ep1.Z() == Approx(p6.Z()).margin(1e-7));\n\t\tCHECK(curve->Degree() == degree);\n\t\tCHECK(curve->NPoles() == 6);\n\t\tCHECK(curve->IsPeriodic() == false);\n\t\tvector<Point3> vec = curve->Poles();\n\t\tCHECK(vec.size() == 6);\n\t\tCHECK(vec[0].X() == Approx(p1.X()));\n\t\tCHECK(vec[0].Y() == Approx(p1.Y()));\n\t\tCHECK(vec[0].Z() == Approx(p1.Z()));\n\t\tCHECK(vec[1].X() == Approx(p2.X()));\n\t\tCHECK(vec[1].Y() == Approx(p2.Y()));\n\t\tCHECK(vec[1].Z() == Approx(p2.Z()));\n\t\tCHECK(vec[2].X() == Approx(p3.X()));\n\t\tCHECK(vec[2].Y() == Approx(p3.Y()));\n\t\tCHECK(vec[2].Z() == Approx(p3.Z()));\n\t\tCHECK(vec[3].X() == Approx(p4.X()));\n\t\tCHECK(vec[3].Y() == Approx(p4.Y()));\n\t\tCHECK(vec[3].Z() == Approx(p4.Z()));\n\t\tCHECK(vec[4].X() == Approx(p5.X()));\n\t\tCHECK(vec[4].Y() == Approx(p5.Y()));\n\t\tCHECK(vec[4].Z() == Approx(p5.Z()));\n\t\tCHECK(vec[5].X() == Approx(p6.X()));\n\t\tCHECK(vec[5].Y() == Approx(p6.Y()));\n\t\tCHECK(vec[5].Z() == Approx(p6.Z()));\n\t\tOCCTIO::OCCTTool::Write(MakeVertex(p1), outdir + \"p1.brep\");\n\t\tOCCTIO::OCCTTool::Write(MakeVertex(p2), outdir + \"p2.brep\");\n\t\tOCCTIO::OCCTTool::Write(MakeVertex(p3), outdir + \"p3.brep\");\n\t\tOCCTIO::OCCTTool::Write(MakeVertex(p4), outdir + \"p4.brep\");\n\t\tOCCTIO::OCCTTool::Write(MakeVertex(p5), outdir + \"p5.brep\");\n\t\tOCCTIO::OCCTTool::Write(MakeVertex(p6), outdir + \"p6.brep\");\n\t\tOCCTIO::OCCTTool::Write(MakeEdge(curve), outdir + \"result.brep\");\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static std::shared_ptr<Geom3BSplineSurface> BlendSurfaces( const std::shared_ptr<Geom3BSplineSurface>& surf1, bool isUIso1, bool isFront1, ContinuityType cont1, std::vector<double>& parameters1, const std::shared_ptr<Geom3BSplineSurface>& surf2, bool isUIso2, bool isFront2, ContinuityType cont2, std::vector<double>& parameters2, bool autoReverse, bool isPrecise, const std::vector<double>& tol),\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <nurbs/NURBSAPIBlend.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <topology/BRepExtremaDistShapeShape.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <modeling/MakeFace.hpp>\n#include <topology/BRepAdaptorCurve3.hpp>\n#include <topology/TopoTool.hpp>\n#include <io/ShapeTool.hpp>\n#include <topology/TopoTool.hpp>\n#include <topology/TopoCast.hpp>\n#include <geometry/Geom3Surface.hpp>\n#include <geometry/Geom3BSplineSurface.hpp>\n#include <nurbs/NURBSAPIConvert.hpp>\n#include <nurbs/NURBSAPIGetGeometry.hpp>\n#include <topology/TopoExplorer.hpp>\n#include <topology/TopoExplorerTool.hpp>\n#include <geometry/Geom3CurveLocalProperty.hpp>\n#include <geometry/GeomAPIProjectPointOnCurve3.hpp>\ndouble NURBSSampleEdge1(int num, double tol, const shared_ptr<Geom3Curve>& curve, const TopoEdge& edge)\n{\n\tdouble fpu1 = curve->FirstParameter();\n\tdouble lpu1 = curve->LastParameter();\n\tdouble delta = (lpu1 - fpu1) / num;\n\tPoint3 p;\n\tint n = 0;\n\tfor (int i = 0; i < num; i++) {\n\t\tdouble t = fpu1 + i * delta;\n\t\tcurve->D0(t, p);\n\t\tif (BRepClassificationTools::IsPointInOnEdge(edge, p, tol))\n\t\t{\n\t\t\tn++;\n\t\t}\n\t}\n\tdouble r1 = 1.0 * (num - n) / num;\n\treturn r1;\n}\nTopoEdge ChooseSimilarEdge1(const TopoShape& shape, const TopoEdge& edge)\n{\n\tint nsample = 1000;\n\tPoint3 p1, p2;\n\tBRepAdaptorCurve3 refC(edge);\n\tdouble refFp = refC.FirstParameter();\n\tdouble refLp = refC.LastParameter();\n\tfor (TopoExplorer ex(shape, ShapeType::Edge); ex.More(); ex.Next())\n\t{\n\t\tconst TopoEdge& cre = static_cast<const TopoEdge&>((ex.Current()));\n\t\tBRepAdaptorCurve3 crC(edge);\n\t\tdouble crFp = crC.FirstParameter();\n\t\tdouble crLp = crC.LastParameter();\n\t\tif (std::abs(refFp - crFp) < 0.001 && std::abs(refLp - crLp) < 0.001)\n\t\t{\n\t\t\tbool isOK = true;\n\t\t\tfor (int i = 0; i < nsample; i++)\n\t\t\t{\n\t\t\t\tdouble t1 = refFp + i * (refLp - refFp) / (nsample - 1);\n\t\t\t\tdouble t2 = crFp + i * (crLp - crFp) / (nsample - 1);\n\t\t\t\trefC.D0(t1, p1);\n\t\t\t\tcrC.D0(t2, p2);\n\t\t\t\tif (p1.Distance(p2) > 0.001)\n\t\t\t\t{\n\t\t\t\t\tisOK = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (isOK)\n\t\t\t{\n\t\t\t\treturn cre;\n\t\t\t}\n\t\t}\n\t}\n\tTopoEdge e;\n\treturn e;\n}\n#include<catch.hpp>\n#include<testHelper.h>\n#include <nurbs/NURBSAPIBlend.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <topology/BRepExtremaDistShapeShape.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <modeling/MakeFace.hpp>\n#include <topology/BRepAdaptorCurve3.hpp>\n#include <topology/TopoTool.hpp>\n#include <io/ShapeTool.hpp>\n#include <topology/TopoTool.hpp>\n#include <topology/TopoCast.hpp>\n#include <geometry/Geom3Surface.hpp>\n#include <geometry/Geom3BSplineSurface.hpp>\n#include <nurbs/NURBSAPIConvert.hpp>\n#include <nurbs/NURBSAPIGetGeometry.hpp>\n#include <topology/TopoExplorer.hpp>\n#include <topology/TopoExplorerTool.hpp>\n#include <geometry/Geom3CurveLocalProperty.hpp>\n#include <geometry/GeomAPIProjectPointOnCurve3.hpp>\ndouble NURBSSampleEdge1(int num, double tol, const shared_ptr<Geom3Curve>& curve, const TopoEdge& edge)\n{\n\tdouble fpu1 = curve->FirstParameter();\n\tdouble lpu1 = curve->LastParameter();\n\tdouble delta = (lpu1 - fpu1) / num;\n\tPoint3 p;\n\tint n = 0;\n\tfor (int i = 0; i < num; i++) {\n\t\tdouble t = fpu1 + i * delta;\n\t\tcurve->D0(t, p);\n\t\tif (BRepClassificationTools::IsPointInOnEdge(edge, p, tol))\n\t\t{\n\t\t\tn++;\n\t\t}\n\t}\n\tdouble r1 = 1.0 * (num - n) / num;\n\treturn r1;\n}\nTopoEdge ChooseSimilarEdge1(const TopoShape& shape, const TopoEdge& edge)\n{\n\tint nsample = 1000;\n\tPoint3 p1, p2;\n\tBRepAdaptorCurve3 refC(edge);\n\tdouble refFp = refC.FirstParameter();\n\tdouble refLp = refC.LastParameter();\n\tfor (TopoExplorer ex(shape, ShapeType::Edge); ex.More(); ex.Next())\n\t{\n\t\tconst TopoEdge& cre = static_cast<const TopoEdge&>((ex.Current()));\n\t\tBRepAdaptorCurve3 crC(edge);\n\t\tdouble crFp = crC.FirstParameter();\n\t\tdouble crLp = crC.LastParameter();\n\t\tif (std::abs(refFp - crFp) < 0.001 && std::abs(refLp - crLp) < 0.001)\n\t\t{\n\t\t\tbool isOK = true;\n\t\t\tfor (int i = 0; i < nsample; i++)\n\t\t\t{\n\t\t\t\tdouble t1 = refFp + i * (refLp - refFp) / (nsample - 1);\n\t\t\t\tdouble t2 = crFp + i * (crLp - crFp) / (nsample - 1);\n\t\t\t\trefC.D0(t1, p1);\n\t\t\t\tcrC.D0(t2, p2);\n\t\t\t\tif (p1.Distance(p2) > 0.001)\n\t\t\t\t{\n\t\t\t\t\tisOK = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (isOK)\n\t\t\t{\n\t\t\t\treturn cre;\n\t\t\t}\n\t\t}\n\t}\n\tTopoEdge e;\n\treturn e;\n;\n\tSECTION(\"ContinuityType::C0\")\n\t{\n\t\tContinuityType cont1 = ContinuityType::C0;\n\t\tContinuityType cont2 = ContinuityType::C0;\n\t\tbool isU1 = false;\n\t\tbool isU2 = false;\n\t\tSECTION(\"isFront:true+true\")\n\t\t{\n\t\t\tbool isFront1 = true;\n\t\t\tbool isFront2 = true;\n\t\t\tCHECK_THROWS_AS(NURBSAPIBlend::BlendSurfaces(surf1, isU1, isFront1, cont1, params1, surf2, isU2, isFront2, cont2, params2, isAutoReverse, isPrecise, tol), _DomainError);\n\t\t}\n\t\tSECTION(\"isFront:false+true\")\n\t\t{\n\t\t\tbool isFront1 = false;\n\t\t\tbool isFront2 = true;\n\t\t\tCHECK_THROWS_AS(NURBSAPIBlend::BlendSurfaces(surf1, isU1, isFront1, cont1, params1, surf2, isU2, isFront2, cont2, params2, isAutoReverse, isPrecise, tol), _DomainError);\n\t\t}\n\t\tSECTION(\"isFront:true+false\")\n\t\t{\n\t\t\tbool isFront1 = true;\n\t\t\tbool isFront2 = false;\n\t\t\tCHECK_THROWS_AS(NURBSAPIBlend::BlendSurfaces(surf1, isU1, isFront1, cont1, params1, surf2, isU2, isFront2, cont2, params2, isAutoReverse, isPrecise, tol), _DomainError);\n\t\t}\n\t\tSECTION(\"isFront:false+false\")\n\t\t{\n\t\t\tbool isFront1 = false;\n\t\t\tbool isFront2 = false;\n\t\t\tCHECK_THROWS_AS(NURBSAPIBlend::BlendSurfaces(surf1, isU1, isFront1, cont1, params1, surf2, isU2, isFront2, cont2, params2, isAutoReverse, isPrecise, tol), _DomainError);\n\t\t}\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static std::shared_ptr<Geom3BSplineCurve> BlendCurves( const std::shared_ptr<Geom3BSplineCurve>& curve1, bool isFront1, ContinuityType cont1, std::vector<double>& parameters1, const std::shared_ptr<Geom3BSplineCurve>& curve2, bool isFront2, ContinuityType cont2, std::vector<double>& parameters2),\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <nurbs/NURBSAPIBlend.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <topology/BRepExtremaDistShapeShape.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <modeling/MakeFace.hpp>\n#include <topology/BRepAdaptorCurve3.hpp>\n#include <topology/TopoTool.hpp>\n#include <io/ShapeTool.hpp>\n#include <topology/TopoTool.hpp>\n#include <topology/TopoCast.hpp>\n#include <geometry/Geom3Surface.hpp>\n#include <geometry/Geom3BSplineSurface.hpp>\n#include <nurbs/NURBSAPIConvert.hpp>\n#include <nurbs/NURBSAPIGetGeometry.hpp>\n#include <topology/TopoExplorer.hpp>\n#include <topology/TopoExplorerTool.hpp>\n#include <geometry/Geom3CurveLocalProperty.hpp>\n#include<catch.hpp>\n#include<testHelper.h>\n#include <nurbs/NURBSAPIBlend.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <topology/BRepExtremaDistShapeShape.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <modeling/MakeFace.hpp>\n#include <topology/BRepAdaptorCurve3.hpp>\n#include <topology/TopoTool.hpp>\n#include <io/ShapeTool.hpp>\n#include <topology/TopoTool.hpp>\n#include <topology/TopoCast.hpp>\n#include <geometry/Geom3Surface.hpp>\n#include <geometry/Geom3BSplineSurface.hpp>\n#include <nurbs/NURBSAPIConvert.hpp>\n#include <nurbs/NURBSAPIGetGeometry.hpp>\n#include <topology/TopoExplorer.hpp>\n#include <topology/TopoExplorerTool.hpp>\n#include <geometry/Geom3CurveLocalProperty.hpp>\n;\n\tSECTION(\"false+true\")\n\t{\n\t\tOUTPUT_DIRECTORY(nurbs, Blend/Extend/bug792);\n\t\tbool isFront1 = false;\n\t\tbool isFront2 = true;\n\t\tauto bsp3 = NURBSAPIBlend::BlendCurves(bsp1, isFront1, cont1, params1, bsp2, isFront2, cont2, params2);\n\t\tdouble fp3 = bsp3->FirstParameter();\n\t\tPoint3 p3;\n\t\tVector3 sv3;\n\t\tbsp3->D1(fp3, p3, sv3);\n\t\tbool res1 = Direction3(sv3).IsParallel(Direction3(ev1), Precision::Angular());\n\t\tCHECK(res1 == true);\n\t\tOCCTIO::OCCTTool::Write(MakeVertex(p3), outdir + \"p3.brep\");\n\t\tOCCTIO::OCCTTool::Write(MakeVertex(pp1), outdir + \"pp1.brep\");\n\t\tOCCTIO::OCCTTool::Write(MakeEdge(bsp1), outdir + \"src1.brep\");\n\t\tOCCTIO::OCCTTool::Write(MakeEdge(bsp2), outdir + \"src2.brep\");\n\t\tOCCTIO::OCCTTool::Write(MakeEdge(bsp3), outdir + \"result.brep\");\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static std::shared_ptr<Geom3BSplineCurve> BlendCurves( const std::shared_ptr<Geom3BSplineCurve>& curve1, bool isFront1, ContinuityType cont1, const std::shared_ptr<Geom3BSplineCurve>& curve2, bool isFront2, ContinuityType cont2),\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <nurbs/NURBSAPIBlend.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <topology/BRepExtremaDistShapeShape.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <modeling/MakeFace.hpp>\n#include <topology/BRepAdaptorCurve3.hpp>\n#include <topology/TopoTool.hpp>\n#include <io/ShapeTool.hpp>\n#include <topology/TopoTool.hpp>\n#include <topology/TopoCast.hpp>\n#include <geometry/Geom3Surface.hpp>\n#include <geometry/Geom3BSplineSurface.hpp>\n#include <nurbs/NURBSAPIConvert.hpp>\n#include <nurbs/NURBSAPIGetGeometry.hpp>\n#include <topology/TopoExplorer.hpp>\n#include <topology/TopoExplorerTool.hpp>\n#include <geometry/Geom3CurveLocalProperty.hpp>\n#include<catch.hpp>\n#include<testHelper.h>\n#include <nurbs/NURBSAPIBlend.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <topology/BRepExtremaDistShapeShape.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <modeling/MakeFace.hpp>\n#include <topology/BRepAdaptorCurve3.hpp>\n#include <topology/TopoTool.hpp>\n#include <io/ShapeTool.hpp>\n#include <topology/TopoTool.hpp>\n#include <topology/TopoCast.hpp>\n#include <geometry/Geom3Surface.hpp>\n#include <geometry/Geom3BSplineSurface.hpp>\n#include <nurbs/NURBSAPIConvert.hpp>\n#include <nurbs/NURBSAPIGetGeometry.hpp>\n#include <topology/TopoExplorer.hpp>\n#include <topology/TopoExplorerTool.hpp>\n#include <geometry/Geom3CurveLocalProperty.hpp>\n;\n\tSECTION(\"ContinuityType::C0\")\n\t{\n\t\tauto cont1 = ContinuityType::C0;\n\t\tauto cont2 = ContinuityType::C0;\n\t\tSECTION(\"true+true\")\n\t\t{\n\t\t\tOUTPUT_DIRECTORY(nurbs, Blend/Extend/BlendCurves1/C0/tt);\n\t\t\tbool isFront1 = true;\n\t\t\tbool isFront2 = true;\n\t\t\tauto bsp3 = NURBSAPIBlend::BlendCurves(bsp1, isFront1, cont1, bsp2, isFront2, cont2);\n\t\t\tPoint3 sp3 = bsp3->StartPoint();\n\t\t\tPoint3 ep3 = bsp3->EndPoint();\n\t\t\tCHECK(sp3.X() == Approx(sp1.X()).margin(1e-7));\n\t\t\tCHECK(sp3.Y() == Approx(sp1.Y()));\n\t\t\tCHECK(sp3.Z() == Approx(sp1.Z()));\n\t\t\tCHECK(ep3.X() == Approx(sp2.X()).margin(1e-7));\n\t\t\tCHECK(ep3.Y() == Approx(sp2.Y()).margin(1e-7));\n\t\t\tCHECK(ep3.Z() == Approx(sp2.Z()).margin(1e-7));\n\t\t\tOCCTIO::OCCTTool::Write(MakeVertex(sp1), outdir + \"sp1.brep\");\n\t\t\tOCCTIO::OCCTTool::Write(MakeVertex(ep1), outdir + \"ep1.brep\");\n\t\t\tOCCTIO::OCCTTool::Write(MakeVertex(sp2), outdir + \"sp2.brep\");\n\t\t\tOCCTIO::OCCTTool::Write(MakeVertex(ep2), outdir + \"ep2.brep\");\n\t\t\tOCCTIO::OCCTTool::Write(MakeVertex(sp3), outdir + \"sp3.brep\");\n\t\t\tOCCTIO::OCCTTool::Write(MakeVertex(ep3), outdir + \"ep3.brep\");\n\t\t\tOCCTIO::OCCTTool::Write(MakeEdge(bsp1), outdir + \"src1.brep\");\n\t\t\tOCCTIO::OCCTTool::Write(MakeEdge(bsp2), outdir + \"src2.brep\");\n\t\t\tOCCTIO::OCCTTool::Write(MakeEdge(bsp3), outdir + \"result.brep\");\n\t\t}\n\t\tSECTION(\"false+true\")\n\t\t{\n\t\t\tOUTPUT_DIRECTORY(nurbs, Blend/Extend/BlendCurves1/C0/ft);\n\t\t\tbool isFront1 = false;\n\t\t\tbool isFront2 = true;\n\t\t\tauto bsp3 = NURBSAPIBlend::BlendCurves(bsp1, isFront1, cont1, bsp2, isFront2, cont2);\n\t\t\tPoint3 sp3 = bsp3->StartPoint();\n\t\t\tPoint3 ep3 = bsp3->EndPoint();\n\t\t\tCHECK(sp3.X() == Approx(ep1.X()).margin(1e-7));\n\t\t\tCHECK(sp3.Y() == Approx(ep1.Y()));\n\t\t\tCHECK(sp3.Z() == Approx(ep1.Z()));\n\t\t\tCHECK(ep3.X() == Approx(sp2.X()).margin(1e-7));\n\t\t\tCHECK(ep3.Y() == Approx(sp2.Y()).margin(1e-7));\n\t\t\tCHECK(ep3.Z() == Approx(sp2.Z()).margin(1e-7));\n\t\t\tOCCTIO::OCCTTool::Write(MakeVertex(sp1), outdir + \"sp1.brep\");\n\t\t\tOCCTIO::OCCTTool::Write(MakeVertex(ep1), outdir + \"ep1.brep\");\n\t\t\tOCCTIO::OCCTTool::Write(MakeVertex(sp2), outdir + \"sp2.brep\");\n\t\t\tOCCTIO::OCCTTool::Write(MakeVertex(ep2), outdir + \"ep2.brep\");\n\t\t\tOCCTIO::OCCTTool::Write(MakeVertex(sp3), outdir + \"sp3.brep\");\n\t\t\tOCCTIO::OCCTTool::Write(MakeVertex(ep3), outdir + \"ep3.brep\");\n\t\t\tOCCTIO::OCCTTool::Write(MakeEdge(bsp1), outdir + \"src1.brep\");\n\t\t\tOCCTIO::OCCTTool::Write(MakeEdge(bsp2), outdir + \"src2.brep\");\n\t\t\tOCCTIO::OCCTTool::Write(MakeEdge(bsp3), outdir + \"result.brep\");\n\t\t}\n\t\tSECTION(\"true+false\")\n\t\t{\n\t\t\tOUTPUT_DIRECTORY(nurbs, Blend/Extend/BlendCurves1/C0/tf);\n\t\t\tbool isFront1 = true;\n\t\t\tbool isFront2 = false;\n\t\t\tauto bsp3 = NURBSAPIBlend::BlendCurves(bsp1, isFront1, cont1, bsp2, isFront2, cont2);\n\t\t\tPoint3 sp3 = bsp3->StartPoint();\n\t\t\tPoint3 ep3 = bsp3->EndPoint();\n\t\t\tCHECK(sp3.X() == Approx(sp1.X()).margin(1e-7));\n\t\t\tCHECK(sp3.Y() == Approx(sp1.Y()));\n\t\t\tCHECK(sp3.Z() == Approx(sp1.Z()));\n\t\t\tCHECK(ep3.X() == Approx(ep2.X()).margin(1e-7));\n\t\t\tCHECK(ep3.Y() == Approx(ep2.Y()).margin(1e-7));\n\t\t\tCHECK(ep3.Z() == Approx(ep2.Z()).margin(1e-7));\n\t\t\tOCCTIO::OCCTTool::Write(MakeVertex(sp1), outdir + \"sp1.brep\");\n\t\t\tOCCTIO::OCCTTool::Write(MakeVertex(ep1), outdir + \"ep1.brep\");\n\t\t\tOCCTIO::OCCTTool::Write(MakeVertex(sp2), outdir + \"sp2.brep\");\n\t\t\tOCCTIO::OCCTTool::Write(MakeVertex(ep2), outdir + \"ep2.brep\");\n\t\t\tOCCTIO::OCCTTool::Write(MakeVertex(sp3), outdir + \"sp3.brep\");\n\t\t\tOCCTIO::OCCTTool::Write(MakeVertex(ep3), outdir + \"ep3.brep\");\n\t\t\tOCCTIO::OCCTTool::Write(MakeEdge(bsp1), outdir + \"src1.brep\");\n\t\t\tOCCTIO::OCCTTool::Write(MakeEdge(bsp2), outdir + \"src2.brep\");\n\t\t\tOCCTIO::OCCTTool::Write(MakeEdge(bsp3), outdir + \"result.brep\");\n\t\t}\n\t\tSECTION(\"false+false\")\n\t\t{\n\t\t\tOUTPUT_DIRECTORY(nurbs, Blend/Extend/BlendCurves1/C0/ff);\n\t\t\tbool isFront1 = false;\n\t\t\tbool isFront2 = false;\n\t\t\tauto bsp3 = NURBSAPIBlend::BlendCurves(bsp1, isFront1, cont1, bsp2, isFront2, cont2);\n\t\t\tPoint3 sp3 = bsp3->StartPoint();\n\t\t\tPoint3 ep3 = bsp3->EndPoint();\n\t\t\tCHECK(sp3.X() == Approx(ep1.X()).margin(1e-7));\n\t\t\tCHECK(sp3.Y() == Approx(ep1.Y()));\n\t\t\tCHECK(sp3.Z() == Approx(ep1.Z()));\n\t\t\tCHECK(ep3.X() == Approx(ep2.X()).margin(1e-7));\n\t\t\tCHECK(ep3.Y() == Approx(ep2.Y()).margin(1e-7));\n\t\t\tCHECK(ep3.Z() == Approx(ep2.Z()).margin(1e-7));\n\t\t\tOCCTIO::OCCTTool::Write(MakeVertex(sp1), outdir + \"sp1.brep\");\n\t\t\tOCCTIO::OCCTTool::Write(MakeVertex(ep1), outdir + \"ep1.brep\");\n\t\t\tOCCTIO::OCCTTool::Write(MakeVertex(sp2), outdir + \"sp2.brep\");\n\t\t\tOCCTIO::OCCTTool::Write(MakeVertex(ep2), outdir + \"ep2.brep\");\n\t\t\tOCCTIO::OCCTTool::Write(MakeVertex(sp3), outdir + \"sp3.brep\");\n\t\t\tOCCTIO::OCCTTool::Write(MakeVertex(ep3), outdir + \"ep3.brep\");\n\t\t\tOCCTIO::OCCTTool::Write(MakeEdge(bsp1), outdir + \"src1.brep\");\n\t\t\tOCCTIO::OCCTTool::Write(MakeEdge(bsp2), outdir + \"src2.brep\");\n\t\t\tOCCTIO::OCCTTool::Write(MakeEdge(bsp3), outdir + \"result.brep\");\n\t\t}\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static std::shared_ptr<Geom3BSplineSurface> BlendFaces( const TopoFace& face1, const TopoEdge& edge1, ContinuityType cont1, std::vector<double>& parameters1, const TopoFace& face2, const TopoEdge& edge2, ContinuityType cont2, std::vector<double>& parameters2, bool autoReverse, bool isPrecise, const std::vector<double>& tol),\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <nurbs/NURBSAPIBlend.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <topology/BRepExtremaDistShapeShape.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <modeling/MakeFace.hpp>\n#include <topology/BRepAdaptorCurve3.hpp>\n#include <topology/TopoTool.hpp>\n#include <io/ShapeTool.hpp>\n#include <topology/TopoTool.hpp>\n#include <topology/TopoCast.hpp>\n#include <geometry/Geom3Surface.hpp>\n#include <geometry/Geom3BSplineSurface.hpp>\n#include <nurbs/NURBSAPIConvert.hpp>\n#include <nurbs/NURBSAPIGetGeometry.hpp>\n#include <topology/TopoExplorer.hpp>\n#include <topology/TopoExplorerTool.hpp>\ndouble NURBSSampleEdge(int num, double tol, const shared_ptr<Geom3Curve>& curve, const TopoEdge& edge)\n{\n\tdouble fpu1 = curve->FirstParameter();\n\tdouble lpu1 = curve->LastParameter();\n\tdouble delta = (lpu1 - fpu1) / num;\n\tPoint3 p;\n\tint n = 0;\n\tfor (int i = 0; i < num; i++) {\n\t\tdouble t = fpu1 + i * delta;\n\t\tcurve->D0(t, p);\n\t\tif (BRepClassificationTools::IsPointInOnEdge(edge, p, tol))\n\t\t{\n\t\t\tn++;\n\t\t}\n\t}\n\tdouble r1 = 1.0 * (num - n) / num;\n\treturn r1;\n}\nTopoEdge ChooseSimilarEdge(const TopoShape& shape, const TopoEdge& edge)\n{\n\tint nsample = 1000;\n\tPoint3 p1, p2;\n\tBRepAdaptorCurve3 refC(edge);\n\tdouble refFp = refC.FirstParameter();\n\tdouble refLp = refC.LastParameter();\n\tfor (TopoExplorer ex(shape, ShapeType::Edge); ex.More(); ex.Next())\n\t{\n\t\tconst TopoEdge& cre = static_cast<const TopoEdge&>((ex.Current()));\n\t\tBRepAdaptorCurve3 crC(edge);\n\t\tdouble crFp = crC.FirstParameter();\n\t\tdouble crLp = crC.LastParameter();\n\t\tif (std::abs(refFp - crFp) < 0.001 && std::abs(refLp - crLp) < 0.001)\n\t\t{\n\t\t\tbool isOK = true;\n\t\t\tfor (int i = 0; i < nsample; i++)\n\t\t\t{\n\t\t\t\tdouble t1 = refFp + i * (refLp - refFp) / (nsample - 1);\n\t\t\t\tdouble t2 = crFp + i * (crLp - crFp) / (nsample - 1);\n\t\t\t\trefC.D0(t1, p1);\n\t\t\t\tcrC.D0(t2, p2);\n\t\t\t\tif (p1.Distance(p2) > 0.001)\n\t\t\t\t{\n\t\t\t\t\tisOK = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (isOK)\n\t\t\t{\n\t\t\t\treturn cre;\n\t\t\t}\n\t\t}\n\t}\n\tTopoEdge e;\n\treturn e;\n}\nTEST_CASE(\"bug1: TestBridgeTrimmedPeriodicFace \", \"[nurbs][Blend][fixbug]\")\n{\n\tstd::string filedir = INPUT_PATH_PREFIX \"/TestNURBS/TestBridgeTrimmedPeriodicFaces/\";\n\tTopoFace f1 = ReadBRepFace(filedir + \"face1.brep\");\n\tTopoFace f2 = ReadBRepFace(filedir + \"face2.brep\");\n\tPoint3 p1 = ReadBRepPoint(filedir + \"pt1.brep\");\n\tPoint3 p2 = ReadBRepPoint(filedir + \"pt2.brep\");\n\tauto [d1, e1] = NearestEdge(p1, f1);\n\tauto [d2, e2] = NearestEdge(p2, f2);\n\tContinuityType cont1 = ContinuityType::G2;\n\tContinuityType cont2 = ContinuityType::G2;\n\tbool isPrecise = true;\n\tstd::vector<double> tol;\n\ttol.push_back(0.001);\n\ttol.push_back(0.01);\n\ttol.push_back(0.01);\n\tstd::vector<double> params(2, 1.0);\n\tbool autoReverse = true;\n\tauto result = NURBSAPIBlend::BlendFaces(f1, e1, cont1, params, f2, e2, cont2, params, autoReverse, isPrecise, tol);\n\tBRepExtremaDistShapeShape dist1(f1, MakeFace(result, 0.0));\n\tBRepExtremaDistShapeShape dist2(f2, MakeFace(result, 0.0));\n\tCHECK(dist1.Value() == Approx(0.0).margin(0.1));\n\tCHECK(dist2.Value() == Approx(0.0).margin(0.1));\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static std::shared_ptr<Geom3BSplineSurface> BlendSurfaces( const std::shared_ptr<Geom3BSplineSurface>& surf1, bool isUIso1, bool isFront1, ContinuityType cont1, std::vector<double>& parameters1, const std::shared_ptr<Geom3BSplineSurface>& surf2, bool isUIso2, bool isFront2, ContinuityType cont2, std::vector<double>& parameters2, bool autoReverse, bool isPrecise, const std::vector<double>& tol),\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <nurbs/NURBSAPIBlend.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <topology/BRepExtremaDistShapeShape.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <modeling/MakeFace.hpp>\n#include <topology/BRepAdaptorCurve3.hpp>\n#include <topology/TopoTool.hpp>\n#include <io/ShapeTool.hpp>\n#include <topology/TopoTool.hpp>\n#include <topology/TopoCast.hpp>\n#include <geometry/Geom3Surface.hpp>\n#include <geometry/Geom3BSplineSurface.hpp>\n#include <nurbs/NURBSAPIConvert.hpp>\n#include <nurbs/NURBSAPIGetGeometry.hpp>\n#include <topology/TopoExplorer.hpp>\n#include <topology/TopoExplorerTool.hpp>\ndouble NURBSSampleEdge(int num, double tol, const shared_ptr<Geom3Curve>& curve, const TopoEdge& edge)\n{\n\tdouble fpu1 = curve->FirstParameter();\n\tdouble lpu1 = curve->LastParameter();\n\tdouble delta = (lpu1 - fpu1) / num;\n\tPoint3 p;\n\tint n = 0;\n\tfor (int i = 0; i < num; i++) {\n\t\tdouble t = fpu1 + i * delta;\n\t\tcurve->D0(t, p);\n\t\tif (BRepClassificationTools::IsPointInOnEdge(edge, p, tol))\n\t\t{\n\t\t\tn++;\n\t\t}\n\t}\n\tdouble r1 = 1.0 * (num - n) / num;\n\treturn r1;\n}\nTopoEdge ChooseSimilarEdge(const TopoShape& shape, const TopoEdge& edge)\n{\n\tint nsample = 1000;\n\tPoint3 p1, p2;\n\tBRepAdaptorCurve3 refC(edge);\n\tdouble refFp = refC.FirstParameter();\n\tdouble refLp = refC.LastParameter();\n\tfor (TopoExplorer ex(shape, ShapeType::Edge); ex.More(); ex.Next())\n\t{\n\t\tconst TopoEdge& cre = static_cast<const TopoEdge&>((ex.Current()));\n\t\tBRepAdaptorCurve3 crC(edge);\n\t\tdouble crFp = crC.FirstParameter();\n\t\tdouble crLp = crC.LastParameter();\n\t\tif (std::abs(refFp - crFp) < 0.001 && std::abs(refLp - crLp) < 0.001)\n\t\t{\n\t\t\tbool isOK = true;\n\t\t\tfor (int i = 0; i < nsample; i++)\n\t\t\t{\n\t\t\t\tdouble t1 = refFp + i * (refLp - refFp) / (nsample - 1);\n\t\t\t\tdouble t2 = crFp + i * (crLp - crFp) / (nsample - 1);\n\t\t\t\trefC.D0(t1, p1);\n\t\t\t\tcrC.D0(t2, p2);\n\t\t\t\tif (p1.Distance(p2) > 0.001)\n\t\t\t\t{\n\t\t\t\t\tisOK = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (isOK)\n\t\t\t{\n\t\t\t\treturn cre;\n\t\t\t}\n\t\t}\n\t}\n\tTopoEdge e;\n\treturn e;\n}\nTEST_CASE(\"bug4:testBlendFaces \", \"[nurbs][Blend][fixbug]\")\n{\n\tint num = 1000;\n\tdouble ratio = 0.1;\n\tdouble refTol = DEFAULT_TOLERANCE;\n\tOUTPUT_DIRECTORY(nurbs, Blend/bug737/testBlendFaces2);\n\tstd::string filedir = INPUT_PATH_PREFIX \"/TestNURBS/TestBlendFaces/\";\n\tTopoFace f1 = ReadBRepFace(filedir + \"surfaceShapeFrom1.brep\");\n\tTopoFace f2 = ReadBRepFace(filedir + \"surfaceShapeFrom2.brep\");\n\tvector<TopoEdge>vec1;\n\tvector<TopoEdge>vec2;\n\tfor (TopoExplorer exp(f1, ShapeType::Edge); exp.More(); exp.Next())\n\t{\n\t\tTopoEdge c1 = static_cast<const TopoEdge&>(exp.Current());\n\t\tvec1.push_back(c1);\n\t}\n\tfor (TopoExplorer expE(f2, ShapeType::Edge); expE.More(); expE.Next())\n\t{\n\t\tTopoEdge c2 = static_cast<const TopoEdge&>(expE.Current());\n\t\tvec2.push_back(c2);\n\t}\n\tCHECK(vec1.size() == 4);\n\tCHECK(vec2.size() == 4);\n\tvector<double>parameters1 = { 1.0, 1.0 };\n\tvector<double>parameters2 = { 1.0, 1.0 };\n\tvector<double>tol = { 0.001, 0.1 * M_PI / 180.0, 0.05 };\n\tdouble res1, res2, res3, res4;\n\tfor (int i = 0; i < vec1.size(); i++)\n\t{\n\t\tfor (int j = 0; j < vec2.size(); j++)\n\t\t{\n\t\t\tshared_ptr<Geom3BSplineSurface> blendSurfaceG1 = NURBSAPIBlend::BlendFaces(f1, vec1[i], ContinuityType::G1, parameters1, f2, vec2[j], ContinuityType::G1, parameters2, true, true, tol);\n\t\t\tBRepExtremaDistShapeShape dist1(f1, MakeFace(blendSurfaceG1, 0.0));\n\t\t\tBRepExtremaDistShapeShape dist2(f2, MakeFace(blendSurfaceG1, 0.0));\n\t\t\tCHECK(dist1.Value() == Approx(0.0).margin(0.1));\n\t\t\tCHECK(dist2.Value() == Approx(0.0).margin(0.1));\n\t\t\tint count = GetTopoCount(MakeFace(blendSurfaceG1, 0.0), ShapeType::Edge);\n\t\t\tCHECK(count == 4);\n\t\t\tshared_ptr<Geom3Curve> u1;\n\t\t\tshared_ptr<Geom3Curve> u2;\n\t\t\tdouble first = blendSurfaceG1->FirstUParameter();\n\t\t\tu1 = blendSurfaceG1->UIso(first);\n\t\t\tdouble last = blendSurfaceG1->LastUParameter();\n\t\t\tu2 = blendSurfaceG1->UIso(last);\n\t\t\tres1 = NURBSSampleEdge(num, refTol, u1, vec1[i]);\n\t\t\tres2 = NURBSSampleEdge(num, refTol, u2, vec2[j]);\n\t\t\tCHECK(res1 <= ratio);\n\t\t\tCHECK(res2 <= ratio);\n\t\t\tshared_ptr<Geom3BSplineSurface> blendSurfaceG2 = NURBSAPIBlend::BlendFaces(f1, vec1[i], ContinuityType::G2, parameters1, f2, vec2[j], ContinuityType::G2, parameters2, true, true, tol);\n\t\t\tBRepExtremaDistShapeShape dist3(f1, MakeFace(blendSurfaceG2, 0.0));\n\t\t\tBRepExtremaDistShapeShape dist4(f2, MakeFace(blendSurfaceG2, 0.0));\n\t\t\tCHECK(dist3.Value() == Approx(0.0).margin(0.1));\n\t\t\tCHECK(dist4.Value() == Approx(0.0).margin(0.1));\n\t\t\tint count2 = GetTopoCount(MakeFace(blendSurfaceG2, 0.0), ShapeType::Edge);\n\t\t\tCHECK(count2 == 4);\n\t\t\tshared_ptr<Geom3Curve> u3;\n\t\t\tshared_ptr<Geom3Curve> u4;\n\t\t\tdouble first2 = blendSurfaceG2->FirstUParameter();\n\t\t\tu3 = blendSurfaceG2->UIso(first2);\n\t\t\tdouble last2 = blendSurfaceG2->LastUParameter();\n\t\t\tu4 = blendSurfaceG2->UIso(last2);\n\t\t\tres3 = NURBSSampleEdge(num, refTol, u3, vec1[i]);\n\t\t\tres4 = NURBSSampleEdge(num, refTol, u4, vec2[j]);\n\t\t\tCHECK(res3 <= ratio);\n\t\t\tCHECK(res4 <= ratio);\n\t\t\tOCCTIO::OCCTTool::Write(MakeFace(blendSurfaceG1, 0.0), outdir + \"G1-result\" + to_string(i + 1) + to_string(j + 1) + \".brep\");\n\t\t\tOCCTIO::OCCTTool::Write(MakeFace(blendSurfaceG2, 0.0), outdir + \"G2-result\" + to_string(i + 1) + to_string(j + 1) + \".brep\");\n\t\t}\n\t}\n\tOCCTIO::OCCTTool::Write(f1, outdir + \"f1.brep\");\n\tOCCTIO::OCCTTool::Write(f2, outdir + \"f2.brep\");\n\tOCCTIO::OCCTTool::Write(vec1[0], outdir + \"e1.brep\");\n\tOCCTIO::OCCTTool::Write(vec1[1], outdir + \"e2.brep\");\n\tOCCTIO::OCCTTool::Write(vec1[2], outdir + \"e3.brep\");\n\tOCCTIO::OCCTTool::Write(vec1[3], outdir + \"e4.brep\");\n\tOCCTIO::OCCTTool::Write(vec2[0], outdir + \"e11.brep\");\n\tOCCTIO::OCCTTool::Write(vec2[1], outdir + \"e22.brep\");\n\tOCCTIO::OCCTTool::Write(vec2[2], outdir + \"e33.brep\");\n\tOCCTIO::OCCTTool::Write(vec2[3], outdir + \"e44.brep\");\n;\n\tSECTION(\"testBlendSurf\")\n\t{\n\t\tOUTPUT_DIRECTORY(nurbs, Blend/BlendSurf);\n\t\tbool isPrecise = true;\n\t\tauto cont1 = ContinuityType::G2;\n\t\tauto cont2 = ContinuityType::G2;\n\t\tbool isU1 = true;\n\t\tbool isU2 = true;\n\t\tbool isFront1 = false;\n\t\tbool isFront2 = false;\n\t\tstd::vector<double> param1, param2;\n\t\tstd::shared_ptr<Geom3BSplineSurface> surface1 = ReadBRepSurface(INPUT_PATH_PREFIX\"/TestNURBS/TestBlendSurf/surface1.brep\");\n\t\tstd::shared_ptr<Geom3BSplineSurface> surface2 = ReadBRepSurface(INPUT_PATH_PREFIX\"/TestNURBS/TestBlendSurf/surface2.brep\");\n\t\tstd::shared_ptr<Geom3BSplineSurface> bsp3;\n\t\tauto bsp1 = std::dynamic_pointer_cast<Geom3BSplineSurface>(surface1);\n\t\tauto bsp2 = std::dynamic_pointer_cast<Geom3BSplineSurface>(surface2);\n\t\tstd::vector<double> tol(3);\n\t\ttol[0] = 1e-3;\n\t\ttol[1] = M_PI / 180.0;\n\t\ttol[2] = 0.05;\n\t\tbsp3 = NURBSAPIBlend::BlendSurfaces(surface1, isU1, isFront1, cont1, param1, surface2, isU2, isFront2, cont2, param2, true, isPrecise, tol);\n\t\tBRepExtremaDistShapeShape dist1(MakeFace(surface1, 0.0), MakeFace(bsp3, 0.0));\n\t\tBRepExtremaDistShapeShape dist2(MakeFace(surface2, 0.0), MakeFace(bsp3, 0.0));\n\t\tCHECK(dist1.Value() == Approx(0.0).margin(0.1));\n\t\tCHECK(dist2.Value() == Approx(0.0).margin(0.1));\n\t\tdouble fpu1 = bsp3->FirstUParameter();\n\t\tdouble lpu1 = bsp3->LastUParameter();\n\t\tshared_ptr<Geom3Curve> u1 = bsp3->UIso(fpu1);\n\t\tshared_ptr<Geom3Curve> u2 = bsp3->UIso(lpu1);\n\t\tdouble f1 = surface1->LastUParameter();\n\t\tdouble f2 = surface2->LastUParameter();\n\t\tshared_ptr<Geom3Curve> c1 = surface1->UIso(f1);\n\t\tshared_ptr<Geom3Curve> c2 = surface2->UIso(f2);\n\t\tbool res1 = IsCurveOnSurf(num, ratio, u1, surface1);\n\t\tbool res2 = IsCurveOnSurf(num, ratio, u2, surface2);\n\t\tCHECK(res1 == true);\n\t\tCHECK(res2 == true);\n\t\tdouble res3 = NurbsSampleCurve(num, refTol, c1, u1);\n\t\tdouble res4 = NurbsSampleCurve(num, refTol, c2, u2);\n\t\tCHECK(res3 <= ratio);\n\t\tCHECK(res4 <= ratio);\n\t\tOCCTIO::OCCTTool::Write(MakeEdge(u1), outdir + \"u1.brep\");\n\t\tOCCTIO::OCCTTool::Write(MakeEdge(u2), outdir + \"u2.brep\");\n\t\tOCCTIO::OCCTTool::Write(MakeEdge(c1), outdir + \"c1.brep\");\n\t\tOCCTIO::OCCTTool::Write(MakeEdge(c2), outdir + \"c2.brep\");\n\t\tOCCTIO::OCCTTool::Write(MakeFace(surface1, 0.0), outdir + \"src1.brep\");\n\t\tOCCTIO::OCCTTool::Write(MakeFace(surface2, 0.0), outdir + \"src2.brep\");\n\t\tOCCTIO::OCCTTool::Write(MakeFace(bsp3, 0.0), outdir + \"result.brep\");\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static std::shared_ptr<Geom3BSplineCurve> BlendCurves( const std::shared_ptr<Geom3BSplineCurve>& curve1, bool isFront1, ContinuityType cont1, std::vector<double>& parameters1, const std::shared_ptr<Geom3BSplineCurve>& curve2, bool isFront2, ContinuityType cont2, std::vector<double>& parameters2),\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <nurbs/NURBSAPIBlend.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <topology/BRepExtremaDistShapeShape.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <modeling/MakeFace.hpp>\n#include <topology/BRepAdaptorCurve3.hpp>\n#include <topology/TopoTool.hpp>\n#include <io/ShapeTool.hpp>\n#include <topology/TopoTool.hpp>\n#include <topology/TopoCast.hpp>\n#include <geometry/Geom3Surface.hpp>\n#include <geometry/Geom3BSplineSurface.hpp>\n#include <nurbs/NURBSAPIConvert.hpp>\n#include <nurbs/NURBSAPIGetGeometry.hpp>\n#include <topology/TopoExplorer.hpp>\n#include <topology/TopoExplorerTool.hpp>\ndouble NURBSSampleEdge(int num, double tol, const shared_ptr<Geom3Curve>& curve, const TopoEdge& edge)\n{\n\tdouble fpu1 = curve->FirstParameter();\n\tdouble lpu1 = curve->LastParameter();\n\tdouble delta = (lpu1 - fpu1) / num;\n\tPoint3 p;\n\tint n = 0;\n\tfor (int i = 0; i < num; i++) {\n\t\tdouble t = fpu1 + i * delta;\n\t\tcurve->D0(t, p);\n\t\tif (BRepClassificationTools::IsPointInOnEdge(edge, p, tol))\n\t\t{\n\t\t\tn++;\n\t\t}\n\t}\n\tdouble r1 = 1.0 * (num - n) / num;\n\treturn r1;\n}\nTopoEdge ChooseSimilarEdge(const TopoShape& shape, const TopoEdge& edge)\n{\n\tint nsample = 1000;\n\tPoint3 p1, p2;\n\tBRepAdaptorCurve3 refC(edge);\n\tdouble refFp = refC.FirstParameter();\n\tdouble refLp = refC.LastParameter();\n\tfor (TopoExplorer ex(shape, ShapeType::Edge); ex.More(); ex.Next())\n\t{\n\t\tconst TopoEdge& cre = static_cast<const TopoEdge&>((ex.Current()));\n\t\tBRepAdaptorCurve3 crC(edge);\n\t\tdouble crFp = crC.FirstParameter();\n\t\tdouble crLp = crC.LastParameter();\n\t\tif (std::abs(refFp - crFp) < 0.001 && std::abs(refLp - crLp) < 0.001)\n\t\t{\n\t\t\tbool isOK = true;\n\t\t\tfor (int i = 0; i < nsample; i++)\n\t\t\t{\n\t\t\t\tdouble t1 = refFp + i * (refLp - refFp) / (nsample - 1);\n\t\t\t\tdouble t2 = crFp + i * (crLp - crFp) / (nsample - 1);\n\t\t\t\trefC.D0(t1, p1);\n\t\t\t\tcrC.D0(t2, p2);\n\t\t\t\tif (p1.Distance(p2) > 0.001)\n\t\t\t\t{\n\t\t\t\t\tisOK = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (isOK)\n\t\t\t{\n\t\t\t\treturn cre;\n\t\t\t}\n\t\t}\n\t}\n\tTopoEdge e;\n\treturn e;\n}\nTEST_CASE(\"bug1: TestBridgeTrimmedPeriodicFace \", \"[nurbs][Blend][fixbug]\")\n{\n\tstd::string filedir = INPUT_PATH_PREFIX \"/TestNURBS/TestBridgeTrimmedPeriodicFaces/\";\n\tTopoFace f1 = ReadBRepFace(filedir + \"face1.brep\");\n\tTopoFace f2 = ReadBRepFace(filedir + \"face2.brep\");\n\tPoint3 p1 = ReadBRepPoint(filedir + \"pt1.brep\");\n\tPoint3 p2 = ReadBRepPoint(filedir + \"pt2.brep\");\n\tauto [d1, e1] = NearestEdge(p1, f1);\n\tauto [d2, e2] = NearestEdge(p2, f2);\n\tContinuityType cont1 = ContinuityType::G2;\n\tContinuityType cont2 = ContinuityType::G2;\n\tbool isPrecise = true;\n\tstd::vector<double> tol;\n\ttol.push_back(0.001);\n\ttol.push_back(0.01);\n\ttol.push_back(0.01);\n\tstd::vector<double> params(2, 1.0);\n\tbool autoReverse = true;\n\tauto result = NURBSAPIBlend::BlendFaces(f1, e1, cont1, params, f2, e2, cont2, params, autoReverse, isPrecise, tol);\n\tBRepExtremaDistShapeShape dist1(f1, MakeFace(result, 0.0));\n\tBRepExtremaDistShapeShape dist2(f2, MakeFace(result, 0.0));\n\tCHECK(dist1.Value() == Approx(0.0).margin(0.1));\n\tCHECK(dist2.Value() == Approx(0.0).margin(0.1));\n;\n\tSECTION(\"TestBridgeCurve2\")\n\t{\n\t\tOUTPUT_DIRECTORY(nurbs, Blend/bug680/BridgeCurve2);\n\t\tstd::string filedir = INPUT_PATH_PREFIX \"/TestNURBS/TestBridgeCurve2/\";\n\t\tauto curve1 = ReadBRepCurve(filedir + \"curve1.brep\");\n\t\tauto curve2 = ReadBRepCurve(filedir + \"curve2.brep\");\n\t\tauto bridge = NURBSAPIBlend::BlendCurves(curve1, false, ContinuityType::G2, curve2, true, ContinuityType::G2);\n\t\tPoint3 sp1 = curve1->StartPoint();\n\t\tPoint3 ep1 = curve1->EndPoint();\n\t\tPoint3 sp2 = curve2->StartPoint();\n\t\tPoint3 ep2 = curve2->EndPoint();\n\t\tPoint3 sp3 = bridge->StartPoint();\n\t\tPoint3 ep3 = bridge->EndPoint();\n\t\tCHECK(sp3.X() == Approx(ep1.X()).margin(1e-7));\n\t\tCHECK(sp3.Y() == Approx(ep1.Y()));\n\t\tCHECK(sp3.Z() == Approx(ep1.Z()));\n\t\tCHECK(ep3.X() == Approx(sp2.X()).margin(1e-7));\n\t\tCHECK(ep3.Y() == Approx(sp2.Y()).margin(1e-7));\n\t\tCHECK(ep3.Z() == Approx(sp2.Z()).margin(1e-7));\n\t\tauto curve = ReadBRepCurve(filedir + \"Rhino/rhinoResult.brep\");\n\t\tdouble res = NurbsSampleCurve(num, refTol, bridge, curve);\n\t\tOCCTIO::OCCTTool::Write(MakeEdge(curve1), outdir + \"src1.brep\");\n\t\tOCCTIO::OCCTTool::Write(MakeEdge(curve2), outdir + \"src2.brep\");\n\t\tOCCTIO::OCCTTool::Write(MakeEdge(bridge), outdir + \"result.brep\");\n\t\tOCCTIO::OCCTTool::Write(MakeEdge(curve), outdir + \"rhinoResult.brep\");\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static std::shared_ptr<Geom3BSplineCurve> BlendCurves( const std::shared_ptr<Geom3BSplineCurve>& curve1, bool isFront1, ContinuityType cont1, const std::shared_ptr<Geom3BSplineCurve>& curve2, bool isFront2, ContinuityType cont2),\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <nurbs/NURBSAPIBlend.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <topology/BRepExtremaDistShapeShape.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <modeling/MakeFace.hpp>\n#include <topology/BRepAdaptorCurve3.hpp>\n#include <topology/TopoTool.hpp>\n#include <io/ShapeTool.hpp>\n#include <topology/TopoTool.hpp>\n#include <topology/TopoCast.hpp>\n#include <geometry/Geom3Surface.hpp>\n#include <geometry/Geom3BSplineSurface.hpp>\n#include <nurbs/NURBSAPIConvert.hpp>\n#include <nurbs/NURBSAPIGetGeometry.hpp>\n#include <topology/TopoExplorer.hpp>\n#include <topology/TopoExplorerTool.hpp>\ndouble NURBSSampleEdge(int num, double tol, const shared_ptr<Geom3Curve>& curve, const TopoEdge& edge)\n{\n\tdouble fpu1 = curve->FirstParameter();\n\tdouble lpu1 = curve->LastParameter();\n\tdouble delta = (lpu1 - fpu1) / num;\n\tPoint3 p;\n\tint n = 0;\n\tfor (int i = 0; i < num; i++) {\n\t\tdouble t = fpu1 + i * delta;\n\t\tcurve->D0(t, p);\n\t\tif (BRepClassificationTools::IsPointInOnEdge(edge, p, tol))\n\t\t{\n\t\t\tn++;\n\t\t}\n\t}\n\tdouble r1 = 1.0 * (num - n) / num;\n\treturn r1;\n}\nTopoEdge ChooseSimilarEdge(const TopoShape& shape, const TopoEdge& edge)\n{\n\tint nsample = 1000;\n\tPoint3 p1, p2;\n\tBRepAdaptorCurve3 refC(edge);\n\tdouble refFp = refC.FirstParameter();\n\tdouble refLp = refC.LastParameter();\n\tfor (TopoExplorer ex(shape, ShapeType::Edge); ex.More(); ex.Next())\n\t{\n\t\tconst TopoEdge& cre = static_cast<const TopoEdge&>((ex.Current()));\n\t\tBRepAdaptorCurve3 crC(edge);\n\t\tdouble crFp = crC.FirstParameter();\n\t\tdouble crLp = crC.LastParameter();\n\t\tif (std::abs(refFp - crFp) < 0.001 && std::abs(refLp - crLp) < 0.001)\n\t\t{\n\t\t\tbool isOK = true;\n\t\t\tfor (int i = 0; i < nsample; i++)\n\t\t\t{\n\t\t\t\tdouble t1 = refFp + i * (refLp - refFp) / (nsample - 1);\n\t\t\t\tdouble t2 = crFp + i * (crLp - crFp) / (nsample - 1);\n\t\t\t\trefC.D0(t1, p1);\n\t\t\t\tcrC.D0(t2, p2);\n\t\t\t\tif (p1.Distance(p2) > 0.001)\n\t\t\t\t{\n\t\t\t\t\tisOK = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (isOK)\n\t\t\t{\n\t\t\t\treturn cre;\n\t\t\t}\n\t\t}\n\t}\n\tTopoEdge e;\n\treturn e;\n}\nTEST_CASE(\"bug1: TestBridgeTrimmedPeriodicFace \", \"[nurbs][Blend][fixbug]\")\n{\n\tstd::string filedir = INPUT_PATH_PREFIX \"/TestNURBS/TestBridgeTrimmedPeriodicFaces/\";\n\tTopoFace f1 = ReadBRepFace(filedir + \"face1.brep\");\n\tTopoFace f2 = ReadBRepFace(filedir + \"face2.brep\");\n\tPoint3 p1 = ReadBRepPoint(filedir + \"pt1.brep\");\n\tPoint3 p2 = ReadBRepPoint(filedir + \"pt2.brep\");\n\tauto [d1, e1] = NearestEdge(p1, f1);\n\tauto [d2, e2] = NearestEdge(p2, f2);\n\tContinuityType cont1 = ContinuityType::G2;\n\tContinuityType cont2 = ContinuityType::G2;\n\tbool isPrecise = true;\n\tstd::vector<double> tol;\n\ttol.push_back(0.001);\n\ttol.push_back(0.01);\n\ttol.push_back(0.01);\n\tstd::vector<double> params(2, 1.0);\n\tbool autoReverse = true;\n\tauto result = NURBSAPIBlend::BlendFaces(f1, e1, cont1, params, f2, e2, cont2, params, autoReverse, isPrecise, tol);\n\tBRepExtremaDistShapeShape dist1(f1, MakeFace(result, 0.0));\n\tBRepExtremaDistShapeShape dist2(f2, MakeFace(result, 0.0));\n\tCHECK(dist1.Value() == Approx(0.0).margin(0.1));\n\tCHECK(dist2.Value() == Approx(0.0).margin(0.1));\n;\n\tSECTION(\"TestBridgeCurve2\")\n\t{\n\t\tOUTPUT_DIRECTORY(nurbs, Blend/bug680/BridgeCurve2);\n\t\tstd::string filedir = INPUT_PATH_PREFIX \"/TestNURBS/TestBridgeCurve2/\";\n\t\tauto curve1 = ReadBRepCurve(filedir + \"curve1.brep\");\n\t\tauto curve2 = ReadBRepCurve(filedir + \"curve2.brep\");\n\t\tauto bridge = NURBSAPIBlend::BlendCurves(curve1, false, ContinuityType::G2, curve2, true, ContinuityType::G2);\n\t\tPoint3 sp1 = curve1->StartPoint();\n\t\tPoint3 ep1 = curve1->EndPoint();\n\t\tPoint3 sp2 = curve2->StartPoint();\n\t\tPoint3 ep2 = curve2->EndPoint();\n\t\tPoint3 sp3 = bridge->StartPoint();\n\t\tPoint3 ep3 = bridge->EndPoint();\n\t\tCHECK(sp3.X() == Approx(ep1.X()).margin(1e-7));\n\t\tCHECK(sp3.Y() == Approx(ep1.Y()));\n\t\tCHECK(sp3.Z() == Approx(ep1.Z()));\n\t\tCHECK(ep3.X() == Approx(sp2.X()).margin(1e-7));\n\t\tCHECK(ep3.Y() == Approx(sp2.Y()).margin(1e-7));\n\t\tCHECK(ep3.Z() == Approx(sp2.Z()).margin(1e-7));\n\t\tauto curve = ReadBRepCurve(filedir + \"Rhino/rhinoResult.brep\");\n\t\tdouble res = NurbsSampleCurve(num, refTol, bridge, curve);\n\t\tOCCTIO::OCCTTool::Write(MakeEdge(curve1), outdir + \"src1.brep\");\n\t\tOCCTIO::OCCTTool::Write(MakeEdge(curve2), outdir + \"src2.brep\");\n\t\tOCCTIO::OCCTTool::Write(MakeEdge(bridge), outdir + \"result.brep\");\n\t\tOCCTIO::OCCTTool::Write(MakeEdge(curve), outdir + \"rhinoResult.brep\");\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static std::shared_ptr<Geom3BSplineCurve> ApproxPoints(const std::vector<Point3>& points, int degree, int npoles, bool isClosed = false, ApproxParameterizationType ptype = ApproxParameterizationType::ChordLength)\t @return curve\n\t @param ptype parameterization type\n\t @param isClosed Is curve closed\n\t @param npoles Target number of poles\n\t @param degree Target degree\n\t @param points Data points to be approximated\n\t @brief Approx points to a curve\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <nurbs/NURBSAPIApprox.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <nurbs/NURBSAPIInterpolate.hpp>\n#include <topology/BRepExtremaDistShapeShape.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <nurbs/NURBSAPIBuildCurve.hpp>\n#include<catch.hpp>\n#include<testHelper.h>\n#include <nurbs/NURBSAPIApprox.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <nurbs/NURBSAPIInterpolate.hpp>\n#include <topology/BRepExtremaDistShapeShape.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <nurbs/NURBSAPIBuildCurve.hpp>\n;\n\tSECTION(\"TestApproxPoints\")\n\t{\n\t\tOUTPUT_DIRECTORY(nurbs, Approxs/ApproxPoints);\n\t\tstd::vector<Point3> points;\n\t\tPoint3 p1(0.0, 0.0, 0.0);\n\t\tPoint3 p2(-0.1, 1.0, -0.2);\n\t\tPoint3 p3(0.1, 2.0, -0.1);\n\t\tPoint3 p4(0.2, 3.0, 0.1);\n\t\tPoint3 p5(0.1, 4.0, 0.0);\n\t\tPoint3 p6(0.0, 5.0, -0.1);\n\t\tpoints.push_back(p1);\n\t\tpoints.push_back(p2);\n\t\tpoints.push_back(p3);\n\t\tpoints.push_back(p4);\n\t\tpoints.push_back(p5);\n\t\tpoints.push_back(p6);\n\t\tint degree = 3;\n\t\tint npoles = 5;\n\t\tauto curve = NURBSAPIApprox::ApproxPoints(points, degree, npoles);\n\t\tTopoVertex v1 = MakeVertex(p1);\n\t\tTopoVertex v2 = MakeVertex(p2);\n\t\tTopoVertex v3 = MakeVertex(p3);\n\t\tTopoVertex v4 = MakeVertex(p4);\n\t\tTopoVertex v5 = MakeVertex(p5);\n\t\tTopoVertex v6 = MakeVertex(p6);\n\t\tTopoEdge edge = MakeEdge(curve);\n\t\tBRepExtremaDistShapeShape dist1(v1, edge);\n\t\tBRepExtremaDistShapeShape dist2(v2, edge);\n\t\tBRepExtremaDistShapeShape dist3(v3, edge);\n\t\tBRepExtremaDistShapeShape dist4(v4, edge);\n\t\tBRepExtremaDistShapeShape dist5(v5, edge);\n\t\tBRepExtremaDistShapeShape dist6(v6, edge);\n\t\tCHECK(dist1.Value() <= Approx(refTol));\n\t\tCHECK(dist2.Value() <= Approx(refTol));\n\t\tCHECK(dist3.Value() <= Approx(refTol));\n\t\tCHECK(dist4.Value() <= Approx(refTol));\n\t\tCHECK(dist5.Value() <= Approx(refTol));\n\t\tCHECK(dist6.Value() <= Approx(refTol));\n\t\tPoint3 sp = curve->StartPoint();\n\t\tPoint3 ep = curve->EndPoint();\n\t\tCHECK(sp.X() == p1.X());\n\t\tCHECK(sp.Y() == p1.Y());\n\t\tCHECK(sp.Z() == p1.Z());\n\t\tCHECK(ep.X() == p6.X());\n\t\tCHECK(ep.Y() == p6.Y());\n\t\tCHECK(ep.Z() == p6.Z());\n\t\tCHECK(curve->Degree() == 3);\n\t\tCHECK(curve->NPoles() == 5);\n\t\tCHECK(curve->IsClosed() == false);\n\t\tCHECK(curve->IsPeriodic() == false);\n\t\tOCCTIO::OCCTTool::Write(v1, outdir + \"v1.brep\");\n\t\tOCCTIO::OCCTTool::Write(v2, outdir + \"v2.brep\");\n\t\tOCCTIO::OCCTTool::Write(v3, outdir + \"v3.brep\");\n\t\tOCCTIO::OCCTTool::Write(v4, outdir + \"v4.brep\");\n\t\tOCCTIO::OCCTTool::Write(v5, outdir + \"v5.brep\");\n\t\tOCCTIO::OCCTTool::Write(v6, outdir + \"v6.brep\");\n\t\tOCCTIO::OCCTTool::Write(edge, outdir + \"result.brep\");\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API TransformShape(const TopoShape& s, const Transformation3& tr, bool copyGeom = false, bool copyMesh = false)\t @param copyMesh Whether the mesh of the shape is copied\n\t @param copyGeom Whether the geometry of the shape is copied\n\t @param tr The transformation\n\t @param s The shape\n\t @brief Construct from a shape with a transformation\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <common/PointT.hpp>\n#include <modeling/MakeSphere.hpp>\n#include <modeling/TransformShape.hpp>\n#include <topomesh/BRepMeshIncrementalMesh.hpp>\n#include <modeling/MakeShapeTool.hpp>\n#include <common/TransformationT.hpp>\n#include <common/CartesianCoordinateSystem.hpp>\n#include <common/GeneralTransformationT.hpp>\n#include <modeling/GeneralTransformShape.hpp>\n#include <geometry/GlobalProperty.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <topology/BRepGlobalProperty.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"bug1: TransformShape  \", \"[modeling][TransformShape][fixbug]\") {\n\tTopoShape s = MakeSphere(1.0);\n\tBRepMeshIncrementalMesh mesher(s, 0.005, true);\n\tMakeShapeTool::EnsureNormalConsistency(s);\n\tTransformation3 tr;\n\ttr.SetRotation(CartesianCoordinateSystem::OZ(), M_PI_2);\n\ts = TransformShape(s, tr, true, true);\n\tCHECK(s.IsNull() == false);\n\tCHECK(s.Type() == AMCAX::ShapeType::Solid);\n\tGlobalProperty prop;\n\tBRepGlobalProperty::VolumeProperties(s, prop);\n\tCHECK(prop.Mass() == Approx(4.1887902048).epsilon(1e-11));\n\tPoint3 vP = prop.CenterOfMass();\n#ifndef WIN_CASE\n\tCHECK(vP.X() == Approx(0.0).margin(1e-12));\n\tCHECK(vP.Y() == Approx(0.0).margin(1e-12));\n\tCHECK(vP.Z() == Approx(0.0).margin(1e-12));\n#else\n\tCHECK(vP.X() == Approx(-4.0938241231662633e-18).epsilon(1e-12));\n\tCHECK(vP.Y() == Approx(-6.1820277995281757e-17).epsilon(1e-12));\n\tCHECK(vP.Z() == Approx(-3.1794228708137405e-17).epsilon(1e-12)); \n#endif\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API explicit TransformShape(const Transformation3& tr)\t @param tr The transformation\n\t @brief Construct from a transformation\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <common/PointT.hpp>\n#include <modeling/MakeSphere.hpp>\n#include <modeling/TransformShape.hpp>\n#include <topomesh/BRepMeshIncrementalMesh.hpp>\n#include <modeling/MakeShapeTool.hpp>\n#include <common/TransformationT.hpp>\n#include <common/CartesianCoordinateSystem.hpp>\n#include <common/GeneralTransformationT.hpp>\n#include <modeling/GeneralTransformShape.hpp>\n#include <geometry/GlobalProperty.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <topology/BRepGlobalProperty.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"bug1: TransformShape  \", \"[modeling][TransformShape][fixbug]\") {\n\tTopoShape s = MakeSphere(1.0);\n\tBRepMeshIncrementalMesh mesher(s, 0.005, true);\n\tMakeShapeTool::EnsureNormalConsistency(s);\n\tTransformation3 tr;\n\ttr.SetRotation(CartesianCoordinateSystem::OZ(), M_PI_2);\n\ts = TransformShape(s, tr, true, true);\n\tCHECK(s.IsNull() == false);\n\tCHECK(s.Type() == AMCAX::ShapeType::Solid);\n\tGlobalProperty prop;\n\tBRepGlobalProperty::VolumeProperties(s, prop);\n\tCHECK(prop.Mass() == Approx(4.1887902048).epsilon(1e-11));\n\tPoint3 vP = prop.CenterOfMass();\n#ifndef WIN_CASE\n\tCHECK(vP.X() == Approx(0.0).margin(1e-12));\n\tCHECK(vP.Y() == Approx(0.0).margin(1e-12));\n\tCHECK(vP.Z() == Approx(0.0).margin(1e-12));\n#else\n\tCHECK(vP.X() == Approx(-4.0938241231662633e-18).epsilon(1e-12));\n\tCHECK(vP.Y() == Approx(-6.1820277995281757e-17).epsilon(1e-12));\n\tCHECK(vP.Z() == Approx(-3.1794228708137405e-17).epsilon(1e-12)); \n#endif\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static TopoShape SewShape(const std::list<TopoShape>& shapes, double tolerance)\t @return The sewed shape\n\t @param tolerance The tolerance\n\t @param shapes The shapes to be sewed\n\t          If some edges do not coincide, the related faces remain unsewed.\n\t @details The border edges are merged to common edges under a given tolerance.\n\t @brief Sew faces to a shell\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <modeling/MakeShapeTool.hpp>\n#include<modeling/MakeFace.hpp>\n#include<math/Plane.hpp>\n#include <common/CartesianCoordinateSystem.hpp>\n#include <topology/TopoExplorerTool.hpp>\nTEST_CASE(\"case1-1: MakeShapeTool::SewShape \", \"[modeling][MakeShapeTool][SewShape][P1]\")\n{\n\tstd::list<TopoShape> shapes;\n\tshapes.push_back(MakeFace(Plane(), 0.0, 1.0, 0.0, 1.0));\n\tshapes.push_back(MakeFace(Plane(Frame3(Point3(1.0, 0.0, 0.0), CartesianCoordinateSystem::DX(), -CartesianCoordinateSystem::DZ())), 0.0, 1.0, 0.0, 1.0));\n\tTopoShape result = MakeShapeTool::SewShape(shapes, Precision::Confusion());\n\tCHECK(OCCTIO::OCCTTool::Write(result, OUTPUT_PATH_PREFIX\"SewShapetest1-0.brep\"));\n\tIndexSet<TopoShape> sf1, sf2, sf3;\n\tCHECK(GetTopoToolCount(result, AMCAX::ShapeType::Shell, sf1) == 1);\n\tCHECK(GetTopoToolCount(result, AMCAX::ShapeType::Compound, sf2) == 0);\n\tCHECK(GetTopoToolCount(result, AMCAX::ShapeType::Face, sf3) == 2);\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API MakeRightPrism(const Point3& baseLocation, const std::vector<Point3>& basepoints, const Point3& apex)\t @param apex A point on the top plane\n\t @param basepoints The base points that are projected onto the base plane\n\t @param baseLocation The location of the base plane\n\t @details The base plane are determined by the location point and the first two base points\n\t @brief Construct a right prism with a given location on the base plane\n,\n",
      "output": "SECTION(\"baseLocationP and  p1 is same\") {\n        Point3 baseLocationP(-1.0, 0.0, 0.0);\n        Point3 p1(0.0, 0.0, 0.0);\n        Point3 p2(3.0, 0.0, 0.0);\n        Point3 p3(1.0, -1.0, -10.0);\n        Point3 apex(1., 2., 5.);\n        std::vector<Point3> basepoints = { p1,p2,p3 };\n        CHECK_THROWS_AS(AMCAX::MakeRightPrism(baseLocationP, basepoints, apex), AMCAX::_ConstructionError);\n    ;\n\tSECTION(\"p1=p2\") {\n        Point3 p1(-1.0, 0.0, 0.0);\n        Point3 p2(-1.0, 0.0, 0.0);\n        Point3 p3(2.0, 1.0, 0.0);\n        Point3 p4(1.0, -1.0, 0.0);\n        Point3 apex(2.0, 2.0, -4.5);\n        std::vector<Point3> points = { p1, p2, p3,p4 };\n        CHECK_THROWS_AS( AMCAX::MakeRightPrism(p1, p2, p3, p4, apex),AMCAX::_ConstructionError);\n    }}\nSECTION(\"baseLocationP and  p1 is same\") {\n        Point3 baseLocationP(-1.0, 0.0, 0.0);\n        Point3 p1(0.0, 0.0, 0.0);\n        Point3 p2(3.0, 0.0, 0.0);\n        Point3 p3(1.0, -1.0, -10.0);\n        Point3 apex(1., 2., 5.);\n        std::vector<Point3> basepoints = { p1,p2,p3 };\n        CHECK_THROWS_AS(AMCAX::MakeRightPrism(baseLocationP, basepoints, apex), AMCAX::_ConstructionError);\n    ;\n\tSECTION(\"4 points not on the XY. \") {\n        Point3 p0(0.0, 0.0, 0.0);\n        Direction3 dir3(0.0, 0.0, 1.0);\n        Frame3 fram3(p0, dir3);\n        Point3 p1(-1.0, 0.0, 0.0);\n        Point3 p2(1.0, -4.0, -2.0);\n        Point3 p3(2.0, 0.0, -1.0);\n        Point3 p4(1., 3., -1.0);\n        std::vector<Point3> basepoints = { p1,p2,p3,p4 };\n        Point3 apex(0., 0., 5.0);\n        TopoShape shape = AMCAX::MakeRightPrism(fram3, basepoints, apex);\n        AMCAX::GlobalProperty props;\n        CHECK(GetSurfaceProperties(shape, props, true, false) == Approx(97.8153525812));\n        CHECK(GetVolumeProperties(shape, props, true, false) == Approx(52.5));\n        Point3 p11(-1.0, 0.0, 0.0);\n        Point3 p21(2.0, 0.0, 0.0);\n        Point3 p31(1., 3., 0.0);\n        Point3 p41(1., -4., 0.0);\n        Point3 apex1(0., 0., 0.0);\n        std::vector<Point3> points2 = { p11,p21,p31,p41,apex1 };\n        CHECK(shape.Type() == ShapeType::Solid);\n        CHECK(OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX\"MakeRightPrism7_case01.brep\"));\n        TopoSolid solid = AMCAX::TopoCast::Solid(shape);\n        for (const Point3& p : points2) {\n            bool isPointOnSolid = AMCAX::BRepClassificationTools::IsPointInOnSolid(solid, p);\n            CHECK(isPointOnSolid == true);\n        }\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API MakeRightPrism(const Frame3& frame, const std::vector<Point3>& basepoints, const Point3& apex)\t @param apex A point on the top plane\n\t @param basepoints Points that are projected onto the base plane\n\t @param frame The frame of base plane\n\t @brief Construct a right prism with a given base plane frame\n,\n",
      "output": "SECTION(\"baseLocationP and  p1 is same\") {\n        Point3 baseLocationP(-1.0, 0.0, 0.0);\n        Point3 p1(0.0, 0.0, 0.0);\n        Point3 p2(3.0, 0.0, 0.0);\n        Point3 p3(1.0, -1.0, -10.0);\n        Point3 apex(1., 2., 5.);\n        std::vector<Point3> basepoints = { p1,p2,p3 };\n        CHECK_THROWS_AS(AMCAX::MakeRightPrism(baseLocationP, basepoints, apex), AMCAX::_ConstructionError);\n    ;\n\tSECTION(\"p1=p2\") {\n        Point3 p1(-1.0, 0.0, 0.0);\n        Point3 p2(-1.0, 0.0, 0.0);\n        Point3 p3(2.0, 1.0, 0.0);\n        Point3 p4(1.0, -1.0, 0.0);\n        Point3 apex(2.0, 2.0, -4.5);\n        std::vector<Point3> points = { p1, p2, p3,p4 };\n        CHECK_THROWS_AS( AMCAX::MakeRightPrism(p1, p2, p3, p4, apex),AMCAX::_ConstructionError);\n    }}\nSECTION(\"baseLocationP and  p1 is same\") {\n        Point3 baseLocationP(-1.0, 0.0, 0.0);\n        Point3 p1(0.0, 0.0, 0.0);\n        Point3 p2(3.0, 0.0, 0.0);\n        Point3 p3(1.0, -1.0, -10.0);\n        Point3 apex(1., 2., 5.);\n        std::vector<Point3> basepoints = { p1,p2,p3 };\n        CHECK_THROWS_AS(AMCAX::MakeRightPrism(baseLocationP, basepoints, apex), AMCAX::_ConstructionError);\n    ;\n\tSECTION(\"default fram3\") {\n        TopoShape shape = AMCAX::MakeRightPrism(fram3, radius, nside, height);\n        AMCAX::GlobalProperty props;\n        CHECK(GetSurfaceProperties(shape, props, true, false) == Approx(301.4548102606));\n        CHECK(GetVolumeProperties(shape, props, true, false) == Approx(367.3657826828));\n        CHECK(shape.Type() == ShapeType::Solid);\n        OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX\"MakeRightPrism4_01.brep\");\n        TopoSolid solid = AMCAX::TopoCast::Solid(shape);\n        Point3 p1(0.0, 0.0, 0.0);\n        Point3 p2(4.04508, -2.93893, 5.0);\n        Point3 p3(-1.54508, 4.75528, 0.);\n        Point3 p4(-4.045085, -2.938926, 2.837605);\n        std::vector<Point3> points = { p1,p2,p3,p4 };\n        for (const Point3& p : points) {\n            bool isPointOnSolid = AMCAX::BRepClassificationTools::IsPointInOnSolid(solid, p);\n            CHECK(isPointOnSolid == true);\n        }\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API MakeRightPrism(const Frame3& frame, const Point3& p1, const Point3& p2, const Point3& p3, const Point3& p4, const Point3& apex)\t @param apex A point on the top plane\n\t @param p1,p2,p3,p4 Points that are projected onto the base plane\n\t @param frame The frame of base plane\n\t @brief Construct a right quadrilateral prism with a given plane frame\n,\n",
      "output": "SECTION(\"baseLocationP and  p1 is same\") {\n        Point3 baseLocationP(-1.0, 0.0, 0.0);\n        Point3 p1(0.0, 0.0, 0.0);\n        Point3 p2(3.0, 0.0, 0.0);\n        Point3 p3(1.0, -1.0, -10.0);\n        Point3 apex(1., 2., 5.);\n        std::vector<Point3> basepoints = { p1,p2,p3 };\n        CHECK_THROWS_AS(AMCAX::MakeRightPrism(baseLocationP, basepoints, apex), AMCAX::_ConstructionError);\n    ;\n\tSECTION(\"p1=p2\") {\n        Point3 p1(-1.0, 0.0, 0.0);\n        Point3 p2(-1.0, 0.0, 0.0);\n        Point3 p3(2.0, 1.0, 0.0);\n        Point3 p4(1.0, -1.0, 0.0);\n        Point3 apex(2.0, 2.0, -4.5);\n        std::vector<Point3> points = { p1, p2, p3,p4 };\n        CHECK_THROWS_AS( AMCAX::MakeRightPrism(p1, p2, p3, p4, apex),AMCAX::_ConstructionError);\n    }}\nSECTION(\"baseLocationP and  p1 is same\") {\n        Point3 baseLocationP(-1.0, 0.0, 0.0);\n        Point3 p1(0.0, 0.0, 0.0);\n        Point3 p2(3.0, 0.0, 0.0);\n        Point3 p3(1.0, -1.0, -10.0);\n        Point3 apex(1., 2., 5.);\n        std::vector<Point3> basepoints = { p1,p2,p3 };\n        CHECK_THROWS_AS(AMCAX::MakeRightPrism(baseLocationP, basepoints, apex), AMCAX::_ConstructionError);\n    ;\n\tSECTION(\"4 points on same line\") {\n        Point3 p1(-1.0, 0.0, 0.0);\n        Point3 p2(0.0, 0.0, 0.0);\n        Point3 p3(2.0, 0.0, 0.0);\n        Point3 p4(4.0, 0.0, 0.0);\n        Point3 apex(2.0, 2.0, -4.5);\n        std::vector<Point3> points = { p1, p2, p3,p4 };\n        CHECK_THROWS_AS(AMCAX::MakeRightPrism(p1, p2, p3, p4, apex), AMCAX::_ConstructionError);\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API MakeRightPrism(const Frame3& frame, const Point3& p1, const Point3& p2, const Point3& p3, const Point3& apex)\t @param apex A point on the top plane\n\t @param p1,p2,p3 Points that are projected onto the base plane\n\t @param frame The frame of base plane\n\t @brief Construct a right triangular prism with a given plane frame\n,\n",
      "output": "SECTION(\"baseLocationP and  p1 is same\") {\n        Point3 baseLocationP(-1.0, 0.0, 0.0);\n        Point3 p1(0.0, 0.0, 0.0);\n        Point3 p2(3.0, 0.0, 0.0);\n        Point3 p3(1.0, -1.0, -10.0);\n        Point3 apex(1., 2., 5.);\n        std::vector<Point3> basepoints = { p1,p2,p3 };\n        CHECK_THROWS_AS(AMCAX::MakeRightPrism(baseLocationP, basepoints, apex), AMCAX::_ConstructionError);\n    ;\n\tSECTION(\"p1=p2\") {\n        Point3 p1(-1.0, 0.0, 0.0);\n        Point3 p2(-1.0, 0.0, 0.0);\n        Point3 p3(2.0, 1.0, 0.0);\n        Point3 p4(1.0, -1.0, 0.0);\n        Point3 apex(2.0, 2.0, -4.5);\n        std::vector<Point3> points = { p1, p2, p3,p4 };\n        CHECK_THROWS_AS( AMCAX::MakeRightPrism(p1, p2, p3, p4, apex),AMCAX::_ConstructionError);\n    }}\nSECTION(\"baseLocationP and  p1 is same\") {\n        Point3 baseLocationP(-1.0, 0.0, 0.0);\n        Point3 p1(0.0, 0.0, 0.0);\n        Point3 p2(3.0, 0.0, 0.0);\n        Point3 p3(1.0, -1.0, -10.0);\n        Point3 apex(1., 2., 5.);\n        std::vector<Point3> basepoints = { p1,p2,p3 };\n        CHECK_THROWS_AS(AMCAX::MakeRightPrism(baseLocationP, basepoints, apex), AMCAX::_ConstructionError);\n    ;\n\tSECTION(\"p1=p2\") {\n        Point3 p1(-1.0, 0.0, 0.0);\n        Point3 p2(-1.0, 0.0, 0.0);\n        Point3 p3(2.0, 1.0, 0.0);\n        Point3 p4(1.0, -1.0, 0.0);\n        Point3 apex(2.0, 2.0, -4.5);\n        std::vector<Point3> points = { p1, p2, p3,p4 };\n        CHECK_THROWS_AS( AMCAX::MakeRightPrism(p1, p2, p3, p4, apex),AMCAX::_ConstructionError);\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API MakeRightPrism(const Frame3& frame, double radius, int nside, double height)\t @param height Height of the polygon\n\t @param nside Number of sides of the base polygon\n\t @param radius Radius of the circumcircle of the base polygon\n\t @param frame The local coordinate system\n\t @brief Construct a right regular prism\n,\n",
      "output": "SECTION(\"baseLocationP and  p1 is same\") {\n        Point3 baseLocationP(-1.0, 0.0, 0.0);\n        Point3 p1(0.0, 0.0, 0.0);\n        Point3 p2(3.0, 0.0, 0.0);\n        Point3 p3(1.0, -1.0, -10.0);\n        Point3 apex(1., 2., 5.);\n        std::vector<Point3> basepoints = { p1,p2,p3 };\n        CHECK_THROWS_AS(AMCAX::MakeRightPrism(baseLocationP, basepoints, apex), AMCAX::_ConstructionError);\n    ;\n\tSECTION(\"p1=p2\") {\n        Point3 p1(-1.0, 0.0, 0.0);\n        Point3 p2(-1.0, 0.0, 0.0);\n        Point3 p3(2.0, 1.0, 0.0);\n        Point3 p4(1.0, -1.0, 0.0);\n        Point3 apex(2.0, 2.0, -4.5);\n        std::vector<Point3> points = { p1, p2, p3,p4 };\n        CHECK_THROWS_AS( AMCAX::MakeRightPrism(p1, p2, p3, p4, apex),AMCAX::_ConstructionError);\n    }}\nSECTION(\"baseLocationP and  p1 is same\") {\n        Point3 baseLocationP(-1.0, 0.0, 0.0);\n        Point3 p1(0.0, 0.0, 0.0);\n        Point3 p2(3.0, 0.0, 0.0);\n        Point3 p3(1.0, -1.0, -10.0);\n        Point3 apex(1., 2., 5.);\n        std::vector<Point3> basepoints = { p1,p2,p3 };\n        CHECK_THROWS_AS(AMCAX::MakeRightPrism(baseLocationP, basepoints, apex), AMCAX::_ConstructionError);\n    ;\n\tSECTION(\"default fram3\") {\n        TopoShape shape = AMCAX::MakeRightPrism(fram3, radius, nside, height);\n        AMCAX::GlobalProperty props;\n        CHECK(GetSurfaceProperties(shape, props, true, false) == Approx(301.4548102606));\n        CHECK(GetVolumeProperties(shape, props, true, false) == Approx(367.3657826828));\n        CHECK(shape.Type() == ShapeType::Solid);\n        OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX\"MakeRightPrism4_01.brep\");\n        TopoSolid solid = AMCAX::TopoCast::Solid(shape);\n        Point3 p1(0.0, 0.0, 0.0);\n        Point3 p2(4.04508, -2.93893, 5.0);\n        Point3 p3(-1.54508, 4.75528, 0.);\n        Point3 p4(-4.045085, -2.938926, 2.837605);\n        std::vector<Point3> points = { p1,p2,p3,p4 };\n        for (const Point3& p : points) {\n            bool isPointOnSolid = AMCAX::BRepClassificationTools::IsPointInOnSolid(solid, p);\n            CHECK(isPointOnSolid == true);\n        }\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API MakeRightPrism(const std::vector<Point3>& basepoints, const Point3& apex)\t @param apex A point on the top plane\n\t @param basepoints Points on the base plane\n\t @brief Construct a right prism with base points and a point on the top plane\n,\n",
      "output": "SECTION(\"baseLocationP and  p1 is same\") {\n        Point3 baseLocationP(-1.0, 0.0, 0.0);\n        Point3 p1(0.0, 0.0, 0.0);\n        Point3 p2(3.0, 0.0, 0.0);\n        Point3 p3(1.0, -1.0, -10.0);\n        Point3 apex(1., 2., 5.);\n        std::vector<Point3> basepoints = { p1,p2,p3 };\n        CHECK_THROWS_AS(AMCAX::MakeRightPrism(baseLocationP, basepoints, apex), AMCAX::_ConstructionError);\n    ;\n\tSECTION(\"p1=p2\") {\n        Point3 p1(-1.0, 0.0, 0.0);\n        Point3 p2(-1.0, 0.0, 0.0);\n        Point3 p3(2.0, 1.0, 0.0);\n        Point3 p4(1.0, -1.0, 0.0);\n        Point3 apex(2.0, 2.0, -4.5);\n        std::vector<Point3> points = { p1, p2, p3,p4 };\n        CHECK_THROWS_AS( AMCAX::MakeRightPrism(p1, p2, p3, p4, apex),AMCAX::_ConstructionError);\n    }}\nSECTION(\"baseLocationP and  p1 is same\") {\n        Point3 baseLocationP(-1.0, 0.0, 0.0);\n        Point3 p1(0.0, 0.0, 0.0);\n        Point3 p2(3.0, 0.0, 0.0);\n        Point3 p3(1.0, -1.0, -10.0);\n        Point3 apex(1., 2., 5.);\n        std::vector<Point3> basepoints = { p1,p2,p3 };\n        CHECK_THROWS_AS(AMCAX::MakeRightPrism(baseLocationP, basepoints, apex), AMCAX::_ConstructionError);\n    ;\n\tSECTION(\"4 points not on the XY. \") {\n        Point3 p0(0.0, 0.0, 0.0);\n        Direction3 dir3(0.0, 0.0, 1.0);\n        Frame3 fram3(p0, dir3);\n        Point3 p1(-1.0, 0.0, 0.0);\n        Point3 p2(1.0, -4.0, -2.0);\n        Point3 p3(2.0, 0.0, -1.0);\n        Point3 p4(1., 3., -1.0);\n        std::vector<Point3> basepoints = { p1,p2,p3,p4 };\n        Point3 apex(0., 0., 5.0);\n        TopoShape shape = AMCAX::MakeRightPrism(fram3, basepoints, apex);\n        AMCAX::GlobalProperty props;\n        CHECK(GetSurfaceProperties(shape, props, true, false) == Approx(97.8153525812));\n        CHECK(GetVolumeProperties(shape, props, true, false) == Approx(52.5));\n        Point3 p11(-1.0, 0.0, 0.0);\n        Point3 p21(2.0, 0.0, 0.0);\n        Point3 p31(1., 3., 0.0);\n        Point3 p41(1., -4., 0.0);\n        Point3 apex1(0., 0., 0.0);\n        std::vector<Point3> points2 = { p11,p21,p31,p41,apex1 };\n        CHECK(shape.Type() == ShapeType::Solid);\n        CHECK(OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX\"MakeRightPrism7_case01.brep\"));\n        TopoSolid solid = AMCAX::TopoCast::Solid(shape);\n        for (const Point3& p : points2) {\n            bool isPointOnSolid = AMCAX::BRepClassificationTools::IsPointInOnSolid(solid, p);\n            CHECK(isPointOnSolid == true);\n        }\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API MakeRightPrism(const Point3& p1, const Point3& p2, const Point3& p3, const Point3& p4, const Point3& apex)\t @param apex A point on the top plane\n\t @param p1,p2,p3,p4 Points on the base plane\n\t @brief Construct a right quadrilateral prism\n,\n",
      "output": "SECTION(\"baseLocationP and  p1 is same\") {\n        Point3 baseLocationP(-1.0, 0.0, 0.0);\n        Point3 p1(0.0, 0.0, 0.0);\n        Point3 p2(3.0, 0.0, 0.0);\n        Point3 p3(1.0, -1.0, -10.0);\n        Point3 apex(1., 2., 5.);\n        std::vector<Point3> basepoints = { p1,p2,p3 };\n        CHECK_THROWS_AS(AMCAX::MakeRightPrism(baseLocationP, basepoints, apex), AMCAX::_ConstructionError);\n    ;\n\tSECTION(\"p1=p2\") {\n        Point3 p1(-1.0, 0.0, 0.0);\n        Point3 p2(-1.0, 0.0, 0.0);\n        Point3 p3(2.0, 1.0, 0.0);\n        Point3 p4(1.0, -1.0, 0.0);\n        Point3 apex(2.0, 2.0, -4.5);\n        std::vector<Point3> points = { p1, p2, p3,p4 };\n        CHECK_THROWS_AS( AMCAX::MakeRightPrism(p1, p2, p3, p4, apex),AMCAX::_ConstructionError);\n    }}\nSECTION(\"baseLocationP and  p1 is same\") {\n        Point3 baseLocationP(-1.0, 0.0, 0.0);\n        Point3 p1(0.0, 0.0, 0.0);\n        Point3 p2(3.0, 0.0, 0.0);\n        Point3 p3(1.0, -1.0, -10.0);\n        Point3 apex(1., 2., 5.);\n        std::vector<Point3> basepoints = { p1,p2,p3 };\n        CHECK_THROWS_AS(AMCAX::MakeRightPrism(baseLocationP, basepoints, apex), AMCAX::_ConstructionError);\n    ;\n\tSECTION(\"p1=p2\") {\n        Point3 p1(-1.0, 0.0, 0.0);\n        Point3 p2(-1.0, 0.0, 0.0);\n        Point3 p3(2.0, 1.0, 0.0);\n        Point3 p4(1.0, -1.0, 0.0);\n        Point3 apex(2.0, 2.0, -4.5);\n        std::vector<Point3> points = { p1, p2, p3,p4 };\n        CHECK_THROWS_AS( AMCAX::MakeRightPrism(p1, p2, p3, p4, apex),AMCAX::_ConstructionError);\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API MakeRightPrism(const Point3& p1, const Point3& p2, const Point3& p3, const Point3& apex)\t @param apex A point on the top plane\n\t @param p1,p2,p3 Points on the base plane\n\t @brief Construct a right triangular prism\n,\n",
      "output": "SECTION(\"baseLocationP and  p1 is same\") {\n        Point3 baseLocationP(-1.0, 0.0, 0.0);\n        Point3 p1(0.0, 0.0, 0.0);\n        Point3 p2(3.0, 0.0, 0.0);\n        Point3 p3(1.0, -1.0, -10.0);\n        Point3 apex(1., 2., 5.);\n        std::vector<Point3> basepoints = { p1,p2,p3 };\n        CHECK_THROWS_AS(AMCAX::MakeRightPrism(baseLocationP, basepoints, apex), AMCAX::_ConstructionError);\n    ;\n\tSECTION(\"p1=p2\") {\n        Point3 p1(-1.0, 0.0, 0.0);\n        Point3 p2(-1.0, 0.0, 0.0);\n        Point3 p3(2.0, 1.0, 0.0);\n        Point3 p4(1.0, -1.0, 0.0);\n        Point3 apex(2.0, 2.0, -4.5);\n        std::vector<Point3> points = { p1, p2, p3,p4 };\n        CHECK_THROWS_AS( AMCAX::MakeRightPrism(p1, p2, p3, p4, apex),AMCAX::_ConstructionError);\n    }}\nSECTION(\"baseLocationP and  p1 is same\") {\n        Point3 baseLocationP(-1.0, 0.0, 0.0);\n        Point3 p1(0.0, 0.0, 0.0);\n        Point3 p2(3.0, 0.0, 0.0);\n        Point3 p3(1.0, -1.0, -10.0);\n        Point3 apex(1., 2., 5.);\n        std::vector<Point3> basepoints = { p1,p2,p3 };\n        CHECK_THROWS_AS(AMCAX::MakeRightPrism(baseLocationP, basepoints, apex), AMCAX::_ConstructionError);\n    ;\n\tSECTION(\"p1=p2\") {\n        Point3 p1(-1.0, 0.0, 0.0);\n        Point3 p2(-1.0, 0.0, 0.0);\n        Point3 p3(2.0, 1.0, 0.0);\n        Point3 p4(1.0, -1.0, 0.0);\n        Point3 apex(2.0, 2.0, -4.5);\n        std::vector<Point3> points = { p1, p2, p3,p4 };\n        CHECK_THROWS_AS( AMCAX::MakeRightPrism(p1, p2, p3, p4, apex),AMCAX::_ConstructionError);\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API MakeRevol(const TopoShape& s, const Axis3& a, bool copy = false)\t @param copy Whether copy the base shape\n\t @param a The rotation axis\n\t @param s The base shape\n\t @brief Construct from a base shape and a rotation axis\n,\n",
      "output": "#include <catch.hpp>\n#include<testHelper.h>\n#include <modeling/MakeRevol.hpp>\n#include <common/PointT.hpp>\n#include <topology/TopoVertex.hpp>\n#include <common/CartesianCoordinateSystem.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <topology/TopoBuilder.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <common/IndexSet.hpp>\n#include <topology/TopoExplorerTool.hpp>\n#include <topology/TopoTool.hpp>\n#include <topology/TopoCast.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"BUG1:create MakeRevol bug   \", \"[modeling][MakeRevol][fixbug][P1]\") {\n\tPoint3 p(1.0, 0.0, 0.0);\n\tTopoVertex v0 = MakeVertex(p);\n\tTopoShape e = MakeRevol(v0, CartesianCoordinateSystem::OZ(), M_PI_2);\n\tTopoShape f = MakeRevol(e, CartesianCoordinateSystem::OX(), M_PI_2);\n\tIndexSet<TopoShape> vertices;\n\tTopoExplorerTool::MapShapes(f, ShapeType::Vertex, vertices);\n\tstd::cout << TopoTool::Tolerance(TopoCast::Vertex(vertices[0])) << std::endl;\n\tCHECK(TopoTool::Tolerance(TopoCast::Vertex(vertices[0])) == 1e-07);\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API MakeRevol(const TopoShape& s, const Axis3& a, double d, bool copy = false)\t @param copy Whether copy the base shape\n\t @param d The rotation angle\n\t @param a The rotation axis\n\t @param s The base shape\n\t @brief Construct from a base shape, a rotation axis and a rotation angle\n,\n",
      "output": "#include <catch.hpp>\n#include<testHelper.h>\n#include <modeling/MakeRevol.hpp>\n#include <common/PointT.hpp>\n#include <topology/TopoVertex.hpp>\n#include <common/CartesianCoordinateSystem.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <topology/TopoBuilder.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <common/IndexSet.hpp>\n#include <topology/TopoExplorerTool.hpp>\n#include <topology/TopoTool.hpp>\n#include <topology/TopoCast.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"BUG1:create MakeRevol bug   \", \"[modeling][MakeRevol][fixbug][P1]\") {\n\tPoint3 p(1.0, 0.0, 0.0);\n\tTopoVertex v0 = MakeVertex(p);\n\tTopoShape e = MakeRevol(v0, CartesianCoordinateSystem::OZ(), M_PI_2);\n\tTopoShape f = MakeRevol(e, CartesianCoordinateSystem::OX(), M_PI_2);\n\tIndexSet<TopoShape> vertices;\n\tTopoExplorerTool::MapShapes(f, ShapeType::Vertex, vertices);\n\tstd::cout << TopoTool::Tolerance(TopoCast::Vertex(vertices[0])) << std::endl;\n\tCHECK(TopoTool::Tolerance(TopoCast::Vertex(vertices[0])) == 1e-07);\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API MakePyramid(const Point3& baseLocation, const std::vector<Point3>& basepoints, const Point3& apex)\t @param apex Apex point\n\t @param basepoints The base points that are projected onto the base plane\n\t @param baseLocation The location of the base plane\n\t @details The base plane are determined by the location point and the first two base points\n\t @brief Construct a pyramid with a given location on the base plane\n,\n",
      "output": "SECTION(\"baseLocationP and  p1 is same\") {\n        Point3 baseLocationP(-1.0, 0.0, 0.0);\n        Point3 p1(0.0, 0.0, 0.0);\n        Point3 p2(3.0, 0.0, 0.0);\n        Point3 p3(1.0, -1.0, -10.0);\n        Point3 apex(1., 2., 5.);\n        std::vector<Point3> basepoints = { p1,p2,p3 };\n        CHECK_THROWS_AS(AMCAX::MakePyramid(baseLocationP, basepoints, apex), AMCAX::_ConstructionError);\n    ;\n\tSECTION(\"apex in the bottom face  \")\n    {\n        Point3 apex(0.0, 0.0, 0.0);\n        std::vector<Point3> points = { p1, p2, p3,p4,apex };\n        TopoShape shape = AMCAX::MakePyramid(p1, p2, p3, p4, apex);\n        AMCAX::GlobalProperty props;\n        CHECK(GetSurfaceProperties(shape, props, true, false) == Approx(30.0));\n        CHECK(GetVolumeProperties(shape, props, true, false) == Approx(0.0));\n        CHECK(shape.Type() == ShapeType::Solid);\n        OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX\"MakePyramid2_case03.brep\");\n        TopoSolid solid = AMCAX::TopoCast::Solid(shape);\n        for (const Point3& p : points) {\n            bool isPointOnSolid = AMCAX::BRepClassificationTools::IsPointInOnSolid(solid, p);\n            CHECK(isPointOnSolid == true);\n        }\n    }}\nSECTION(\"baseLocationP and  p1 is same\") {\n        Point3 baseLocationP(-1.0, 0.0, 0.0);\n        Point3 p1(0.0, 0.0, 0.0);\n        Point3 p2(3.0, 0.0, 0.0);\n        Point3 p3(1.0, -1.0, -10.0);\n        Point3 apex(1., 2., 5.);\n        std::vector<Point3> basepoints = { p1,p2,p3 };\n        CHECK_THROWS_AS(AMCAX::MakePyramid(baseLocationP, basepoints, apex), AMCAX::_ConstructionError);\n    ;\n\tSECTION(\"2 point is same in vector points\") {\n        Point3 p3(1.0, -3.0, 0.0);\n        Point3 apex(5.0, 3.0, 4.5);\n        std::vector<Point3> points = { p1, p2,p3 };\n        CHECK_THROWS_AS(AMCAX::MakePyramid(points, apex), AMCAX::_ConstructionError);\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API MakePyramid(const Frame3& frame, const std::vector<Point3>& basepoints, const Point3& apex)\t @param apex Apex point\n\t @param basepoints Points that are projected onto the base plane\n\t @param frame The frame of base plane\n\t @brief Construct a pyramid with a given base plane frame\n,\n",
      "output": "SECTION(\"baseLocationP and  p1 is same\") {\n        Point3 baseLocationP(-1.0, 0.0, 0.0);\n        Point3 p1(0.0, 0.0, 0.0);\n        Point3 p2(3.0, 0.0, 0.0);\n        Point3 p3(1.0, -1.0, -10.0);\n        Point3 apex(1., 2., 5.);\n        std::vector<Point3> basepoints = { p1,p2,p3 };\n        CHECK_THROWS_AS(AMCAX::MakePyramid(baseLocationP, basepoints, apex), AMCAX::_ConstructionError);\n    ;\n\tSECTION(\"apex in the bottom face  \")\n    {\n        Point3 apex(0.0, 0.0, 0.0);\n        std::vector<Point3> points = { p1, p2, p3,p4,apex };\n        TopoShape shape = AMCAX::MakePyramid(p1, p2, p3, p4, apex);\n        AMCAX::GlobalProperty props;\n        CHECK(GetSurfaceProperties(shape, props, true, false) == Approx(30.0));\n        CHECK(GetVolumeProperties(shape, props, true, false) == Approx(0.0));\n        CHECK(shape.Type() == ShapeType::Solid);\n        OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX\"MakePyramid2_case03.brep\");\n        TopoSolid solid = AMCAX::TopoCast::Solid(shape);\n        for (const Point3& p : points) {\n            bool isPointOnSolid = AMCAX::BRepClassificationTools::IsPointInOnSolid(solid, p);\n            CHECK(isPointOnSolid == true);\n        }\n    }}\nSECTION(\"baseLocationP and  p1 is same\") {\n        Point3 baseLocationP(-1.0, 0.0, 0.0);\n        Point3 p1(0.0, 0.0, 0.0);\n        Point3 p2(3.0, 0.0, 0.0);\n        Point3 p3(1.0, -1.0, -10.0);\n        Point3 apex(1., 2., 5.);\n        std::vector<Point3> basepoints = { p1,p2,p3 };\n        CHECK_THROWS_AS(AMCAX::MakePyramid(baseLocationP, basepoints, apex), AMCAX::_ConstructionError);\n    ;\n\tSECTION(\"2 point is same in vector points\") {\n        Point3 p3(1.0, -3.0, 0.0);\n        Point3 apex(5.0, 3.0, 4.5);\n        std::vector<Point3> points = { p1, p2,p3 };\n        CHECK_THROWS_AS(AMCAX::MakePyramid(points, apex), AMCAX::_ConstructionError);\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API MakePyramid(const Frame3& frame, const Point3& p1, const Point3& p2, const Point3& p3, const Point3& p4, const Point3& apex)\t @param apex Apex point\n\t @param p1,p2,p3,p4 Points that are projected onto the base plane\n\t @param frame The frame of base plane\n\t @brief Construct a quadrilateral pyramid with a given plane frame\n,\n",
      "output": "SECTION(\"baseLocationP and  p1 is same\") {\n        Point3 baseLocationP(-1.0, 0.0, 0.0);\n        Point3 p1(0.0, 0.0, 0.0);\n        Point3 p2(3.0, 0.0, 0.0);\n        Point3 p3(1.0, -1.0, -10.0);\n        Point3 apex(1., 2., 5.);\n        std::vector<Point3> basepoints = { p1,p2,p3 };\n        CHECK_THROWS_AS(AMCAX::MakePyramid(baseLocationP, basepoints, apex), AMCAX::_ConstructionError);\n    ;\n\tSECTION(\"apex in the bottom face  \")\n    {\n        Point3 apex(0.0, 0.0, 0.0);\n        std::vector<Point3> points = { p1, p2, p3,p4,apex };\n        TopoShape shape = AMCAX::MakePyramid(p1, p2, p3, p4, apex);\n        AMCAX::GlobalProperty props;\n        CHECK(GetSurfaceProperties(shape, props, true, false) == Approx(30.0));\n        CHECK(GetVolumeProperties(shape, props, true, false) == Approx(0.0));\n        CHECK(shape.Type() == ShapeType::Solid);\n        OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX\"MakePyramid2_case03.brep\");\n        TopoSolid solid = AMCAX::TopoCast::Solid(shape);\n        for (const Point3& p : points) {\n            bool isPointOnSolid = AMCAX::BRepClassificationTools::IsPointInOnSolid(solid, p);\n            CHECK(isPointOnSolid == true);\n        }\n    }}\nSECTION(\"baseLocationP and  p1 is same\") {\n        Point3 baseLocationP(-1.0, 0.0, 0.0);\n        Point3 p1(0.0, 0.0, 0.0);\n        Point3 p2(3.0, 0.0, 0.0);\n        Point3 p3(1.0, -1.0, -10.0);\n        Point3 apex(1., 2., 5.);\n        std::vector<Point3> basepoints = { p1,p2,p3 };\n        CHECK_THROWS_AS(AMCAX::MakePyramid(baseLocationP, basepoints, apex), AMCAX::_ConstructionError);\n    ;\n\tSECTION(\"4 points not on the XY. \") {\n        Point3 p0(0.0, 0.0, 0.0);\n        Direction3 dir3(0.0, 0.0, 1.0);\n        Frame3 fram3(p0, dir3);\n        Point3 p1(-1.0, 0.0, 0.0);\n        Point3 p2(1.0,-4.0,-2.0);\n        Point3 p3(2.0, 0.0, -1.0);\n        Point3 p4(1., 3., -1.0);\n        std::vector<Point3> points = { p1,p2,p3,p4 };\n        Point3 apex(0., 0., 5.0);\n        TopoShape shape = AMCAX::MakePyramid(fram3, p1, p2, p3,p4,apex);\n        AMCAX::GlobalProperty props;\n        CHECK(GetSurfaceProperties(shape, props, true, false) == Approx(50.5080895892));\n        CHECK(GetVolumeProperties(shape, props, true, false) == Approx(17.5));\n        Point3 p11(-1.0, 0.0, 0.0);\n        Point3 p21(2.0, 0.0, 0.0);\n        Point3 p31(1., 3., 0.0);\n        Point3 p41(1., -4., 0.0);\n        Point3 apex1(0., 0., 0.0);\n        std::vector<Point3> points2 = { p11,p21,p31,p41,apex1 };\n        CHECK(shape.Type() == ShapeType::Solid);\n        CHECK(OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX\"MakePyramid6_case01.brep\"));\n        TopoSolid solid = AMCAX::TopoCast::Solid(shape);\n        for (const Point3& p : points2) {\n            bool isPointOnSolid = AMCAX::BRepClassificationTools::IsPointInOnSolid(solid, p);\n            CHECK(isPointOnSolid == true);\n        }\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API MakePyramid(const Frame3& frame, const Point3& p1, const Point3& p2, const Point3& p3, const Point3& apex)\t @param apex Apex point\n\t @param p1,p2,p3 Points that are projected onto the base plane\n\t @param frame The frame of base plane\n\t @brief Construct a tetrahedron with a given plane frame\n,\n",
      "output": "SECTION(\"baseLocationP and  p1 is same\") {\n        Point3 baseLocationP(-1.0, 0.0, 0.0);\n        Point3 p1(0.0, 0.0, 0.0);\n        Point3 p2(3.0, 0.0, 0.0);\n        Point3 p3(1.0, -1.0, -10.0);\n        Point3 apex(1., 2., 5.);\n        std::vector<Point3> basepoints = { p1,p2,p3 };\n        CHECK_THROWS_AS(AMCAX::MakePyramid(baseLocationP, basepoints, apex), AMCAX::_ConstructionError);\n    ;\n\tSECTION(\"apex in the bottom face  \")\n    {\n        Point3 apex(0.0, 0.0, 0.0);\n        std::vector<Point3> points = { p1, p2, p3,p4,apex };\n        TopoShape shape = AMCAX::MakePyramid(p1, p2, p3, p4, apex);\n        AMCAX::GlobalProperty props;\n        CHECK(GetSurfaceProperties(shape, props, true, false) == Approx(30.0));\n        CHECK(GetVolumeProperties(shape, props, true, false) == Approx(0.0));\n        CHECK(shape.Type() == ShapeType::Solid);\n        OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX\"MakePyramid2_case03.brep\");\n        TopoSolid solid = AMCAX::TopoCast::Solid(shape);\n        for (const Point3& p : points) {\n            bool isPointOnSolid = AMCAX::BRepClassificationTools::IsPointInOnSolid(solid, p);\n            CHECK(isPointOnSolid == true);\n        }\n    }}\nSECTION(\"baseLocationP and  p1 is same\") {\n        Point3 baseLocationP(-1.0, 0.0, 0.0);\n        Point3 p1(0.0, 0.0, 0.0);\n        Point3 p2(3.0, 0.0, 0.0);\n        Point3 p3(1.0, -1.0, -10.0);\n        Point3 apex(1., 2., 5.);\n        std::vector<Point3> basepoints = { p1,p2,p3 };\n        CHECK_THROWS_AS(AMCAX::MakePyramid(baseLocationP, basepoints, apex), AMCAX::_ConstructionError);\n    ;\n\tSECTION(\"fram3(point3,Direct3)\") {\n        Point3 p(1.0, 1.0, 1.0);\n        Direction3 dir3(1.0, 1.0, 1.0);\n        Frame3 fram3(p, dir3);\n        TopoShape shape = AMCAX::MakePyramid(fram3, radius, nside, height);\n        AMCAX::GlobalProperty props;\n        CHECK(GetSurfaceProperties(shape, props, true, false) == Approx(180.0870564616));\n        CHECK(GetVolumeProperties(shape, props, true, false) == Approx(122.4552608943));\n        CHECK(shape.Type() == ShapeType::Solid);\n        CHECK(OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX\"MakePyramid4_case03.brep\"));\n        TopoSolid solid = AMCAX::TopoCast::Solid(shape);\n        Point3 p1(3.88675, 3.88675, 3.88675);\n        Point3 p2(1.0, 1.0, 1.0);\n        Point3 p3(3.46687, 0.807266, 3.44647);\n        std::vector<Point3> points = { p1,p2,p3 };\n        for (const Point3& p : points) {\n            bool isPointOnSolid = AMCAX::BRepClassificationTools::IsPointInOnSolid(solid, p);\n            CHECK(isPointOnSolid == true);\n        }\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API MakePyramid(const Frame3& frame, double radius, int nside, double height)\t @param height Height of the polygon\n\t @param nside Number of sides of the base polygon\n\t @param radius Radius of the circumcircle of the base polygon\n\t @param frame The local coordinate system\n\t @brief Construct a regular pyramid\n,\n",
      "output": "SECTION(\"baseLocationP and  p1 is same\") {\n        Point3 baseLocationP(-1.0, 0.0, 0.0);\n        Point3 p1(0.0, 0.0, 0.0);\n        Point3 p2(3.0, 0.0, 0.0);\n        Point3 p3(1.0, -1.0, -10.0);\n        Point3 apex(1., 2., 5.);\n        std::vector<Point3> basepoints = { p1,p2,p3 };\n        CHECK_THROWS_AS(AMCAX::MakePyramid(baseLocationP, basepoints, apex), AMCAX::_ConstructionError);\n    ;\n\tSECTION(\"apex in the bottom face  \")\n    {\n        Point3 apex(0.0, 0.0, 0.0);\n        std::vector<Point3> points = { p1, p2, p3,p4,apex };\n        TopoShape shape = AMCAX::MakePyramid(p1, p2, p3, p4, apex);\n        AMCAX::GlobalProperty props;\n        CHECK(GetSurfaceProperties(shape, props, true, false) == Approx(30.0));\n        CHECK(GetVolumeProperties(shape, props, true, false) == Approx(0.0));\n        CHECK(shape.Type() == ShapeType::Solid);\n        OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX\"MakePyramid2_case03.brep\");\n        TopoSolid solid = AMCAX::TopoCast::Solid(shape);\n        for (const Point3& p : points) {\n            bool isPointOnSolid = AMCAX::BRepClassificationTools::IsPointInOnSolid(solid, p);\n            CHECK(isPointOnSolid == true);\n        }\n    }}\nSECTION(\"baseLocationP and  p1 is same\") {\n        Point3 baseLocationP(-1.0, 0.0, 0.0);\n        Point3 p1(0.0, 0.0, 0.0);\n        Point3 p2(3.0, 0.0, 0.0);\n        Point3 p3(1.0, -1.0, -10.0);\n        Point3 apex(1., 2., 5.);\n        std::vector<Point3> basepoints = { p1,p2,p3 };\n        CHECK_THROWS_AS(AMCAX::MakePyramid(baseLocationP, basepoints, apex), AMCAX::_ConstructionError);\n    ;\n\tSECTION(\"fram3(point3,Direct3)\") {\n        Point3 p(1.0, 1.0, 1.0);\n        Direction3 dir3(1.0, 1.0, 1.0);\n        Frame3 fram3(p, dir3);\n        TopoShape shape = AMCAX::MakePyramid(fram3, radius, nside, height);\n        AMCAX::GlobalProperty props;\n        CHECK(GetSurfaceProperties(shape, props, true, false) == Approx(180.0870564616));\n        CHECK(GetVolumeProperties(shape, props, true, false) == Approx(122.4552608943));\n        CHECK(shape.Type() == ShapeType::Solid);\n        CHECK(OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX\"MakePyramid4_case03.brep\"));\n        TopoSolid solid = AMCAX::TopoCast::Solid(shape);\n        Point3 p1(3.88675, 3.88675, 3.88675);\n        Point3 p2(1.0, 1.0, 1.0);\n        Point3 p3(3.46687, 0.807266, 3.44647);\n        std::vector<Point3> points = { p1,p2,p3 };\n        for (const Point3& p : points) {\n            bool isPointOnSolid = AMCAX::BRepClassificationTools::IsPointInOnSolid(solid, p);\n            CHECK(isPointOnSolid == true);\n        }\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API MakePyramid(const Point3& p1, const Point3& p2, const Point3& p3, const Point3& p4, const Point3& apex)\t @param apex Apex point\n\t @param p1,p2,p3,p4 Points on the base plane\n\t @brief Construct a quadrilateral pyramid\n,\n",
      "output": "SECTION(\"baseLocationP and  p1 is same\") {\n        Point3 baseLocationP(-1.0, 0.0, 0.0);\n        Point3 p1(0.0, 0.0, 0.0);\n        Point3 p2(3.0, 0.0, 0.0);\n        Point3 p3(1.0, -1.0, -10.0);\n        Point3 apex(1., 2., 5.);\n        std::vector<Point3> basepoints = { p1,p2,p3 };\n        CHECK_THROWS_AS(AMCAX::MakePyramid(baseLocationP, basepoints, apex), AMCAX::_ConstructionError);\n    ;\n\tSECTION(\"apex in the bottom face  \")\n    {\n        Point3 apex(0.0, 0.0, 0.0);\n        std::vector<Point3> points = { p1, p2, p3,p4,apex };\n        TopoShape shape = AMCAX::MakePyramid(p1, p2, p3, p4, apex);\n        AMCAX::GlobalProperty props;\n        CHECK(GetSurfaceProperties(shape, props, true, false) == Approx(30.0));\n        CHECK(GetVolumeProperties(shape, props, true, false) == Approx(0.0));\n        CHECK(shape.Type() == ShapeType::Solid);\n        OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX\"MakePyramid2_case03.brep\");\n        TopoSolid solid = AMCAX::TopoCast::Solid(shape);\n        for (const Point3& p : points) {\n            bool isPointOnSolid = AMCAX::BRepClassificationTools::IsPointInOnSolid(solid, p);\n            CHECK(isPointOnSolid == true);\n        }\n    }}\nSECTION(\"baseLocationP and  p1 is same\") {\n        Point3 baseLocationP(-1.0, 0.0, 0.0);\n        Point3 p1(0.0, 0.0, 0.0);\n        Point3 p2(3.0, 0.0, 0.0);\n        Point3 p3(1.0, -1.0, -10.0);\n        Point3 apex(1., 2., 5.);\n        std::vector<Point3> basepoints = { p1,p2,p3 };\n        CHECK_THROWS_AS(AMCAX::MakePyramid(baseLocationP, basepoints, apex), AMCAX::_ConstructionError);\n    ;\n\tSECTION(\"apex in the bottom face  \")\n    {\n        Point3 apex(0.0, 0.0, 0.0);\n        std::vector<Point3> points = { p1, p2, p3,p4,apex };\n        TopoShape shape = AMCAX::MakePyramid(p1, p2, p3, p4, apex);\n        AMCAX::GlobalProperty props;\n        CHECK(GetSurfaceProperties(shape, props, true, false) == Approx(30.0));\n        CHECK(GetVolumeProperties(shape, props, true, false) == Approx(0.0));\n        CHECK(shape.Type() == ShapeType::Solid);\n        OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX\"MakePyramid2_case03.brep\");\n        TopoSolid solid = AMCAX::TopoCast::Solid(shape);\n        for (const Point3& p : points) {\n            bool isPointOnSolid = AMCAX::BRepClassificationTools::IsPointInOnSolid(solid, p);\n            CHECK(isPointOnSolid == true);\n        }\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API MakePyramid(const Point3& p1, const Point3& p2, const Point3& p3, const Point3& apex)\t @param apex Apex point\n\t @param p1,p2,p3 Points on the base plane\n\t @brief Construct a tetrahedron\n,\n",
      "output": "SECTION(\"baseLocationP and  p1 is same\") {\n        Point3 baseLocationP(-1.0, 0.0, 0.0);\n        Point3 p1(0.0, 0.0, 0.0);\n        Point3 p2(3.0, 0.0, 0.0);\n        Point3 p3(1.0, -1.0, -10.0);\n        Point3 apex(1., 2., 5.);\n        std::vector<Point3> basepoints = { p1,p2,p3 };\n        CHECK_THROWS_AS(AMCAX::MakePyramid(baseLocationP, basepoints, apex), AMCAX::_ConstructionError);\n    ;\n\tSECTION(\"apex in the bottom face  \")\n    {\n        Point3 apex(0.0, 0.0, 0.0);\n        std::vector<Point3> points = { p1, p2, p3,p4,apex };\n        TopoShape shape = AMCAX::MakePyramid(p1, p2, p3, p4, apex);\n        AMCAX::GlobalProperty props;\n        CHECK(GetSurfaceProperties(shape, props, true, false) == Approx(30.0));\n        CHECK(GetVolumeProperties(shape, props, true, false) == Approx(0.0));\n        CHECK(shape.Type() == ShapeType::Solid);\n        OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX\"MakePyramid2_case03.brep\");\n        TopoSolid solid = AMCAX::TopoCast::Solid(shape);\n        for (const Point3& p : points) {\n            bool isPointOnSolid = AMCAX::BRepClassificationTools::IsPointInOnSolid(solid, p);\n            CHECK(isPointOnSolid == true);\n        }\n    }}\nSECTION(\"baseLocationP and  p1 is same\") {\n        Point3 baseLocationP(-1.0, 0.0, 0.0);\n        Point3 p1(0.0, 0.0, 0.0);\n        Point3 p2(3.0, 0.0, 0.0);\n        Point3 p3(1.0, -1.0, -10.0);\n        Point3 apex(1., 2., 5.);\n        std::vector<Point3> basepoints = { p1,p2,p3 };\n        CHECK_THROWS_AS(AMCAX::MakePyramid(baseLocationP, basepoints, apex), AMCAX::_ConstructionError);\n    ;\n\tSECTION(\"radius = 0\") {\n        radius = 0.0;\n        CHECK_THROWS_AS( AMCAX::MakePyramid(fram3, radius, nside, height),AMCAX::_ConstructionError );\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API void Add(const Point3& p)\t @param p The point\n\t @brief Add a new point to the polygon\n,\n",
      "output": "#include<catch.hpp>\n#include<iostream>\n#include <modeling/MakePolygon.hpp>\n#include <topology/TopoVertex.hpp>\n#include <topology/TopoEdge.hpp>\n#include <topology/TopoExplorerTool.hpp>\n#include <topology/TopoShape.hpp>\n#include <topology/TopoTool.hpp>\nTEST_CASE(\"void AMCAX::MakePolygon::Add(const Point3 & p) - case1 add valid 3D point\", \"[modeling][MakePolygon][P1]\") {\n        AMCAX::Point3 p1(1.0, 2.0, 3.0);\n        AMCAX::Point3 p2(4.1, 5.1, 6.1);\n        AMCAX::MakePolygon polygon(p1, p2);\n        bool lastAdded1 = polygon.Added();\n        CHECK(lastAdded1 == true);\n        const AMCAX::TopoEdge &lastEdge = polygon.Edge();\n        CHECK(lastEdge.IsNull() == false);\n        CHECK(lastEdge.NChildren() == 2);\n        CHECK(lastEdge.Type() == AMCAX::ShapeType::Edge);\n        AMCAX::TopoVertex v1,v2;\n        AMCAX::TopoExplorerTool::Vertices(lastEdge, v1, v2,false);\n        CHECK_FALSE(v1.IsNull());\n        CHECK_FALSE(v2.IsNull());\n        CHECK(v1.Type() == AMCAX::ShapeType::Vertex);\n        CHECK(v2.Type() == AMCAX::ShapeType::Vertex);\n        AMCAX::Point3 vpoint1;\n        vpoint1 = AMCAX::TopoTool::Point(v1);\n        CHECK(vpoint1.X() == 1.0);\n        CHECK(vpoint1.Y() == 2.0);\n        CHECK(vpoint1.Z() == 3.0);\n        AMCAX::Point3 p3(4.1, 5.1, 6.1);\n        polygon.Add(p3);\n        bool lastAdded2 = polygon.Added();\n        CHECK(lastAdded2 == false);\n        AMCAX::Point3 p4(7.0, 8.0, 9.0);\n        polygon.Add(p4);\n        bool lastAdded3 = polygon.Added();\n        CHECK(lastAdded3 == true);\n}\n#include<catch.hpp>\n#include<iostream>\n#include <modeling/MakePolygon.hpp>\n#include <topology/TopoVertex.hpp>\n#include <topology/TopoEdge.hpp>\n#include <topology/TopoExplorerTool.hpp>\n#include <topology/TopoShape.hpp>\n#include <topology/TopoTool.hpp>\nTEST_CASE(\"void AMCAX::MakePolygon::Add(const Point3 & p) - case1 add valid 3D point\", \"[modeling][MakePolygon][P1]\") {\n        AMCAX::Point3 p1(1.0, 2.0, 3.0);\n        AMCAX::Point3 p2(4.1, 5.1, 6.1);\n        AMCAX::MakePolygon polygon(p1, p2);\n        bool lastAdded1 = polygon.Added();\n        CHECK(lastAdded1 == true);\n        const AMCAX::TopoEdge &lastEdge = polygon.Edge();\n        CHECK(lastEdge.IsNull() == false);\n        CHECK(lastEdge.NChildren() == 2);\n        CHECK(lastEdge.Type() == AMCAX::ShapeType::Edge);\n        AMCAX::TopoVertex v1,v2;\n        AMCAX::TopoExplorerTool::Vertices(lastEdge, v1, v2,false);\n        CHECK_FALSE(v1.IsNull());\n        CHECK_FALSE(v2.IsNull());\n        CHECK(v1.Type() == AMCAX::ShapeType::Vertex);\n        CHECK(v2.Type() == AMCAX::ShapeType::Vertex);\n        AMCAX::Point3 vpoint1;\n        vpoint1 = AMCAX::TopoTool::Point(v1);\n        CHECK(vpoint1.X() == 1.0);\n        CHECK(vpoint1.Y() == 2.0);\n        CHECK(vpoint1.Z() == 3.0);\n        AMCAX::Point3 p3(4.1, 5.1, 6.1);\n        polygon.Add(p3);\n        bool lastAdded2 = polygon.Added();\n        CHECK(lastAdded2 == false);\n        AMCAX::Point3 p4(7.0, 8.0, 9.0);\n        polygon.Add(p4);\n        bool lastAdded3 = polygon.Added();\n        CHECK(lastAdded3 == true);\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API MakePolygon(const Point3& p1, const Point3& p2)\t @param p2 The second point\n\t @param p1 The first point\n\t @brief Construct from two points\n,\n",
      "output": "#include<catch.hpp>\n#include<iostream>\n#include <modeling/MakePolygon.hpp>\n#include <topology/TopoVertex.hpp>\n#include <topology/TopoEdge.hpp>\n#include <topology/TopoExplorerTool.hpp>\n#include <topology/TopoShape.hpp>\n#include <topology/TopoTool.hpp>\nTEST_CASE(\"void AMCAX::MakePolygon::Add(const Point3 & p) - case1 add valid 3D point\", \"[modeling][MakePolygon][P1]\") {\n        AMCAX::Point3 p1(1.0, 2.0, 3.0);\n        AMCAX::Point3 p2(4.1, 5.1, 6.1);\n        AMCAX::MakePolygon polygon(p1, p2);\n        bool lastAdded1 = polygon.Added();\n        CHECK(lastAdded1 == true);\n        const AMCAX::TopoEdge &lastEdge = polygon.Edge();\n        CHECK(lastEdge.IsNull() == false);\n        CHECK(lastEdge.NChildren() == 2);\n        CHECK(lastEdge.Type() == AMCAX::ShapeType::Edge);\n        AMCAX::TopoVertex v1,v2;\n        AMCAX::TopoExplorerTool::Vertices(lastEdge, v1, v2,false);\n        CHECK_FALSE(v1.IsNull());\n        CHECK_FALSE(v2.IsNull());\n        CHECK(v1.Type() == AMCAX::ShapeType::Vertex);\n        CHECK(v2.Type() == AMCAX::ShapeType::Vertex);\n        AMCAX::Point3 vpoint1;\n        vpoint1 = AMCAX::TopoTool::Point(v1);\n        CHECK(vpoint1.X() == 1.0);\n        CHECK(vpoint1.Y() == 2.0);\n        CHECK(vpoint1.Z() == 3.0);\n        AMCAX::Point3 p3(4.1, 5.1, 6.1);\n        polygon.Add(p3);\n        bool lastAdded2 = polygon.Added();\n        CHECK(lastAdded2 == false);\n        AMCAX::Point3 p4(7.0, 8.0, 9.0);\n        polygon.Add(p4);\n        bool lastAdded3 = polygon.Added();\n        CHECK(lastAdded3 == true);\n}\nTEST_CASE(\"MakePolygon Invalid input points\", \"[modeling][MakePolygon][P3]\") {\n        AMCAX::Point3 p1(0.0, 0.0, 0.0);\n        AMCAX::MakePolygon polygon(p1, p1);\n        bool lastAdded = polygon.Added();\n        CHECK(lastAdded == false);\n    }\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API MakeTorus(const Frame3& frame, double r1, double r2, double angle1, double angle2, double angle)\t @param angle The rotation angle\n\t @param angle2 The end angle\n\t @param angle1 The start angle\n\t @param r2 The minor radius\n\t @param r1 The major radius\n\t @param frame The local coordinate system\n\t @brief Construct from a local coordinate system, a major radius, a minor radius, two angles that forms an arc of the section circle and a rotation angle\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <modeling/MakeTorus.hpp>\n#include <common/CartesianCoordinateSystem.hpp>\n#include <topology/TopoBuilder.hpp>\nTEST_CASE(\"bug1: MakeTorus   \", \"[modeling][MakeTorus][P1][fixbug]\")\n{\n\tstd::vector<TopoShape> shapes;\n\tconstexpr double major = 3.0;\n\tconstexpr double minor = 1.0;\n\tauto addshape = [&](double angle1, double angle2, double angle)\n\t{\n\t\tFrame3 frame(Point3(0.0, 0.0, static_cast<double>(shapes.size()) * 3.0), CartesianCoordinateSystem::DZ());\n\t\tshapes.push_back(MakeTorus(frame, major, minor, angle1, angle2, angle));\n\t};\n\taddshape(0.0, 2.0 * M_PI, 2.0 * M_PI);\n\taddshape(0.0, 2.0 * M_PI, M_PI_2);\n\taddshape(0.0, M_PI, 2.0 * M_PI);\n\taddshape(M_PI_2, 3.0 * M_PI_2, 2.0 * M_PI);\n\taddshape(M_PI, 2.0 * M_PI, 2.0 * M_PI);\n\taddshape(-M_PI_2, M_PI_2, 2.0 * M_PI);\n\taddshape(M_PI_4, M_PI_4 * 3, 2.0 * M_PI);\n\taddshape(M_PI_4 * 3, M_PI_4 * 5, 2.0 * M_PI);\n\taddshape(M_PI_4 * 5, M_PI_4 * 7, 2.0 * M_PI);\n\taddshape(-M_PI_4, M_PI_4, 2.0 * M_PI);\n\taddshape(0.0, M_PI_2, M_PI_2);\n\tTopoShape result;\n\tTopoBuilder b;\n\tb.MakeCompound(TopoCast::Compound(result));\n\tfor (const auto& s : shapes)\n\t{\n\t\tb.Add(result, s);\n\t}\n\tCHECK( OCCTIO::OCCTTool::Write(result, OUTPUT_PATH_PREFIX\"MakeTorus_bug445.brep\"));\n\tAMCAX::GlobalProperty props1, props2;\n\tCHECK(GetSurfaceProperties(result, props1, true, false) == Approx(831.9798765859));\n\tCHECK(GetVolumeProperties(result, props2, true, false) == Approx(255.8996));\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API MakeTorus(const Frame3& frame, double r1, double r2, double angle1, double angle2)\t @param angle2 The end angle\n\t @param angle1 The start angle\n\t @param r2 The minor radius\n\t @param r1 The major radius\n\t @param frame The local coordinate system\n\t @brief Construct from a local coordinate system, a major radius, a minor radius and two angles that forms an arc of the section circle\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <modeling/MakeTorus.hpp>\n#include <common/CartesianCoordinateSystem.hpp>\n#include <topology/TopoBuilder.hpp>\nTEST_CASE(\"bug1: MakeTorus   \", \"[modeling][MakeTorus][P1][fixbug]\")\n{\n\tstd::vector<TopoShape> shapes;\n\tconstexpr double major = 3.0;\n\tconstexpr double minor = 1.0;\n\tauto addshape = [&](double angle1, double angle2, double angle)\n\t{\n\t\tFrame3 frame(Point3(0.0, 0.0, static_cast<double>(shapes.size()) * 3.0), CartesianCoordinateSystem::DZ());\n\t\tshapes.push_back(MakeTorus(frame, major, minor, angle1, angle2, angle));\n\t};\n\taddshape(0.0, 2.0 * M_PI, 2.0 * M_PI);\n\taddshape(0.0, 2.0 * M_PI, M_PI_2);\n\taddshape(0.0, M_PI, 2.0 * M_PI);\n\taddshape(M_PI_2, 3.0 * M_PI_2, 2.0 * M_PI);\n\taddshape(M_PI, 2.0 * M_PI, 2.0 * M_PI);\n\taddshape(-M_PI_2, M_PI_2, 2.0 * M_PI);\n\taddshape(M_PI_4, M_PI_4 * 3, 2.0 * M_PI);\n\taddshape(M_PI_4 * 3, M_PI_4 * 5, 2.0 * M_PI);\n\taddshape(M_PI_4 * 5, M_PI_4 * 7, 2.0 * M_PI);\n\taddshape(-M_PI_4, M_PI_4, 2.0 * M_PI);\n\taddshape(0.0, M_PI_2, M_PI_2);\n\tTopoShape result;\n\tTopoBuilder b;\n\tb.MakeCompound(TopoCast::Compound(result));\n\tfor (const auto& s : shapes)\n\t{\n\t\tb.Add(result, s);\n\t}\n\tCHECK( OCCTIO::OCCTTool::Write(result, OUTPUT_PATH_PREFIX\"MakeTorus_bug445.brep\"));\n\tAMCAX::GlobalProperty props1, props2;\n\tCHECK(GetSurfaceProperties(result, props1, true, false) == Approx(831.9798765859));\n\tCHECK(GetVolumeProperties(result, props2, true, false) == Approx(255.8996));\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API MakeTorus(double r1, double r2, double angle1, double angle2, double angle)\t @param angle The rotation angle\n\t @param angle2 The end angle\n\t @param angle1 The start angle\n\t @param r2 The minor radius\n\t @param r1 The major radius\n\t @brief Construct from a major radius, a minor radius, two angles that forms an arc of the section circle and a rotation angle\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <modeling/MakeTorus.hpp>\n#include <common/CartesianCoordinateSystem.hpp>\n#include <topology/TopoBuilder.hpp>\nTEST_CASE(\"bug1: MakeTorus   \", \"[modeling][MakeTorus][P1][fixbug]\")\n{\n\tstd::vector<TopoShape> shapes;\n\tconstexpr double major = 3.0;\n\tconstexpr double minor = 1.0;\n\tauto addshape = [&](double angle1, double angle2, double angle)\n\t{\n\t\tFrame3 frame(Point3(0.0, 0.0, static_cast<double>(shapes.size()) * 3.0), CartesianCoordinateSystem::DZ());\n\t\tshapes.push_back(MakeTorus(frame, major, minor, angle1, angle2, angle));\n\t};\n\taddshape(0.0, 2.0 * M_PI, 2.0 * M_PI);\n\taddshape(0.0, 2.0 * M_PI, M_PI_2);\n\taddshape(0.0, M_PI, 2.0 * M_PI);\n\taddshape(M_PI_2, 3.0 * M_PI_2, 2.0 * M_PI);\n\taddshape(M_PI, 2.0 * M_PI, 2.0 * M_PI);\n\taddshape(-M_PI_2, M_PI_2, 2.0 * M_PI);\n\taddshape(M_PI_4, M_PI_4 * 3, 2.0 * M_PI);\n\taddshape(M_PI_4 * 3, M_PI_4 * 5, 2.0 * M_PI);\n\taddshape(M_PI_4 * 5, M_PI_4 * 7, 2.0 * M_PI);\n\taddshape(-M_PI_4, M_PI_4, 2.0 * M_PI);\n\taddshape(0.0, M_PI_2, M_PI_2);\n\tTopoShape result;\n\tTopoBuilder b;\n\tb.MakeCompound(TopoCast::Compound(result));\n\tfor (const auto& s : shapes)\n\t{\n\t\tb.Add(result, s);\n\t}\n\tCHECK( OCCTIO::OCCTTool::Write(result, OUTPUT_PATH_PREFIX\"MakeTorus_bug445.brep\"));\n\tAMCAX::GlobalProperty props1, props2;\n\tCHECK(GetSurfaceProperties(result, props1, true, false) == Approx(831.9798765859));\n\tCHECK(GetVolumeProperties(result, props2, true, false) == Approx(255.8996));\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API MakeTorus(double r1, double r2, double angle1, double angle2)\t @param angle2 The end angle\n\t @param angle1 The start angle\n\t @param r2 The minor radius\n\t @param r1 The major radius\n\t @brief Construct from a major radius, a minor radius and two angles that forms an arc of the section circle\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <modeling/MakeTorus.hpp>\n#include <common/CartesianCoordinateSystem.hpp>\n#include <topology/TopoBuilder.hpp>\nTEST_CASE(\"bug1: MakeTorus   \", \"[modeling][MakeTorus][P1][fixbug]\")\n{\n\tstd::vector<TopoShape> shapes;\n\tconstexpr double major = 3.0;\n\tconstexpr double minor = 1.0;\n\tauto addshape = [&](double angle1, double angle2, double angle)\n\t{\n\t\tFrame3 frame(Point3(0.0, 0.0, static_cast<double>(shapes.size()) * 3.0), CartesianCoordinateSystem::DZ());\n\t\tshapes.push_back(MakeTorus(frame, major, minor, angle1, angle2, angle));\n\t};\n\taddshape(0.0, 2.0 * M_PI, 2.0 * M_PI);\n\taddshape(0.0, 2.0 * M_PI, M_PI_2);\n\taddshape(0.0, M_PI, 2.0 * M_PI);\n\taddshape(M_PI_2, 3.0 * M_PI_2, 2.0 * M_PI);\n\taddshape(M_PI, 2.0 * M_PI, 2.0 * M_PI);\n\taddshape(-M_PI_2, M_PI_2, 2.0 * M_PI);\n\taddshape(M_PI_4, M_PI_4 * 3, 2.0 * M_PI);\n\taddshape(M_PI_4 * 3, M_PI_4 * 5, 2.0 * M_PI);\n\taddshape(M_PI_4 * 5, M_PI_4 * 7, 2.0 * M_PI);\n\taddshape(-M_PI_4, M_PI_4, 2.0 * M_PI);\n\taddshape(0.0, M_PI_2, M_PI_2);\n\tTopoShape result;\n\tTopoBuilder b;\n\tb.MakeCompound(TopoCast::Compound(result));\n\tfor (const auto& s : shapes)\n\t{\n\t\tb.Add(result, s);\n\t}\n\tCHECK( OCCTIO::OCCTTool::Write(result, OUTPUT_PATH_PREFIX\"MakeTorus_bug445.brep\"));\n\tAMCAX::GlobalProperty props1, props2;\n\tCHECK(GetSurfaceProperties(result, props1, true, false) == Approx(831.9798765859));\n\tCHECK(GetVolumeProperties(result, props2, true, false) == Approx(255.8996));\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API MakeTorus(double r1, double r2)\t @param r2 The minor radius\n\t @param r1 The major radius\n\t @brief Construct from a major radius and a minor radius\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <modeling/MakeTorus.hpp>\n#include <common/CartesianCoordinateSystem.hpp>\n#include <topology/TopoBuilder.hpp>\nTEST_CASE(\"bug1: MakeTorus   \", \"[modeling][MakeTorus][P1][fixbug]\")\n{\n\tstd::vector<TopoShape> shapes;\n\tconstexpr double major = 3.0;\n\tconstexpr double minor = 1.0;\n\tauto addshape = [&](double angle1, double angle2, double angle)\n\t{\n\t\tFrame3 frame(Point3(0.0, 0.0, static_cast<double>(shapes.size()) * 3.0), CartesianCoordinateSystem::DZ());\n\t\tshapes.push_back(MakeTorus(frame, major, minor, angle1, angle2, angle));\n\t};\n\taddshape(0.0, 2.0 * M_PI, 2.0 * M_PI);\n\taddshape(0.0, 2.0 * M_PI, M_PI_2);\n\taddshape(0.0, M_PI, 2.0 * M_PI);\n\taddshape(M_PI_2, 3.0 * M_PI_2, 2.0 * M_PI);\n\taddshape(M_PI, 2.0 * M_PI, 2.0 * M_PI);\n\taddshape(-M_PI_2, M_PI_2, 2.0 * M_PI);\n\taddshape(M_PI_4, M_PI_4 * 3, 2.0 * M_PI);\n\taddshape(M_PI_4 * 3, M_PI_4 * 5, 2.0 * M_PI);\n\taddshape(M_PI_4 * 5, M_PI_4 * 7, 2.0 * M_PI);\n\taddshape(-M_PI_4, M_PI_4, 2.0 * M_PI);\n\taddshape(0.0, M_PI_2, M_PI_2);\n\tTopoShape result;\n\tTopoBuilder b;\n\tb.MakeCompound(TopoCast::Compound(result));\n\tfor (const auto& s : shapes)\n\t{\n\t\tb.Add(result, s);\n\t}\n\tCHECK( OCCTIO::OCCTTool::Write(result, OUTPUT_PATH_PREFIX\"MakeTorus_bug445.brep\"));\n\tAMCAX::GlobalProperty props1, props2;\n\tCHECK(GetSurfaceProperties(result, props1, true, false) == Approx(831.9798765859));\n\tCHECK(GetVolumeProperties(result, props2, true, false) == Approx(255.8996));\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API const TopoFace& ZMinFace()\t @return The Z-min face\n\t @brief Get the face on Z minimum\n,\n",
      "output": "#include <modeling/MakeBox.hpp>\n#include<catch.hpp>\n#include<testHelper.h>\n#include <modeling/MakeBox.hpp>\n#include <modeling/MakeCylinder.hpp>\n#include <topology/BRepExtremaProximityTool.hpp>\n#include <io/OBJTool.hpp>\n#include <topology/TopoFace.hpp>\n#include <modeling/TransformShape.hpp>\n#include <topology/TopoExplorerTool.hpp>\n#include <modeling/MakeTorus.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <topology/BRepExtremaDistShapeShape.hpp>\nusing namespace AMCAX;\n#include <modeling/MakeBox.hpp>\n#include<catch.hpp>\n#include<testHelper.h>\n#include <modeling/MakeBox.hpp>\n#include <modeling/MakeCylinder.hpp>\n#include <topology/BRepExtremaProximityTool.hpp>\n#include <io/OBJTool.hpp>\n#include <topology/TopoFace.hpp>\n#include <modeling/TransformShape.hpp>\n#include <topology/TopoExplorerTool.hpp>\n#include <modeling/MakeTorus.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <topology/BRepExtremaDistShapeShape.hpp>\nusing namespace AMCAX;\n;\n\tSECTION(\"Box1\") {\n\t\tOUTPUT_DIRECTORY(topology, OverlapFaces);\n\t\tMakeBox box(3.0, 2.0,2.0);\n\t\tTopoShape box2= box.Shape();\n\t\tbox.Init(4.0, 5.0, 6.0);\n\t\tTopoFace shape = box.XMinFace(); \n\t\tTopoFace shape1 = box.ZMinFace(); \n\t\tTopoShape shape2 = box; \n\t\tTopoShape shapeV = box;\n\t\tAMCAX::GlobalProperty prop1;\n\t\tdouble s_sahpe = GetSurfaceProperties(shape, prop1, true, false);\n\t\tdouble s_sahpe1 = GetSurfaceProperties(shape1, prop1, true, false);\n\t\tdouble s_sahpe2 = GetSurfaceProperties(shape2, prop1, true, false);\n\t\tdouble v_sahpe = GetVolumeProperties(shapeV, prop1, true, false);\n\t\tCHECK(s_sahpe == Approx(30.0).margin(1e-12));\n\t\tCHECK(s_sahpe1 == Approx(20.0).margin(1e-12));\n\t\tCHECK(s_sahpe2 == Approx(148.0).margin(1e-12));\n\t\tCHECK(v_sahpe == Approx(120.0).margin(1e-12));\n\t\tCHECK( OCCTIO::OCCTTool::Write(box, outdir + \"MakeBox1.brep\"));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API const TopoFace& YMinFace()\t @return The Y-min face\n\t @brief Get the face on Y minimum\n,\n",
      "output": "#include <modeling/MakeBox.hpp>\n#include<catch.hpp>\n#include<testHelper.h>\n#include <modeling/MakeBox.hpp>\n#include <modeling/MakeCylinder.hpp>\n#include <topology/BRepExtremaProximityTool.hpp>\n#include <io/OBJTool.hpp>\n#include <topology/TopoFace.hpp>\n#include <modeling/TransformShape.hpp>\n#include <topology/TopoExplorerTool.hpp>\n#include <modeling/MakeTorus.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <topology/BRepExtremaDistShapeShape.hpp>\nusing namespace AMCAX;\n#include <modeling/MakeBox.hpp>\n#include<catch.hpp>\n#include<testHelper.h>\n#include <modeling/MakeBox.hpp>\n#include <modeling/MakeCylinder.hpp>\n#include <topology/BRepExtremaProximityTool.hpp>\n#include <io/OBJTool.hpp>\n#include <topology/TopoFace.hpp>\n#include <modeling/TransformShape.hpp>\n#include <topology/TopoExplorerTool.hpp>\n#include <modeling/MakeTorus.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <topology/BRepExtremaDistShapeShape.hpp>\nusing namespace AMCAX;\n;\n\tSECTION(\"Box2\") \n\t{\n\t\tOUTPUT_DIRECTORY(topology, OverlapFaces);\n\t\tMakeBox box2(Point3(1.0, 1.0, 1.0), 3.0, 3.0, 3.0);\n\t\tMakeBox box3;\n\t\tbox3.Init(Point3(1.0, 1.0, 1.0), 3.0, 3.0, 3.0);\n\t\tTopoFace shape1 = box2.XMinFace();\n\t\tTopoFace shape2 = box2.XMaxFace();\n\t\tTopoFace shape3 = box2.YMinFace();\n\t\tTopoFace shape4 = box2.YMaxFace();\n\t\tTopoFace shape5 = box2.ZMinFace();\n\t\tTopoFace shape6 = box2.ZMaxFace();\n\t\tTopoShape shape = box2;\n\t\tTopoFace shape_1 = box3.XMinFace();\n\t\tTopoFace shape_2 = box3.XMaxFace();\n\t\tTopoFace shape_3 = box3.YMinFace();\n\t\tTopoFace shape_4 = box3.YMaxFace();\n\t\tTopoFace shape_5 = box3.ZMinFace();\n\t\tTopoFace shape_6 = box3.ZMaxFace();\n\t\tAMCAX::GlobalProperty prop1;\n\t\tdouble s_sahpe1 = GetSurfaceProperties(shape1, prop1, true, false);\n\t\tdouble s_sahpe2 = GetSurfaceProperties(shape2, prop1, true, false);\n\t\tdouble s_sahpe3 = GetSurfaceProperties(shape3, prop1, true, false);\n\t\tdouble s_sahpe4 = GetSurfaceProperties(shape4, prop1, true, false);\n\t\tdouble s_sahpe5 = GetSurfaceProperties(shape5, prop1, true, false);\n\t\tdouble s_sahpe6 = GetSurfaceProperties(shape6, prop1, true, false);\n\t\tdouble s_sahpe  = GetSurfaceProperties(shape, prop1, true, false);\n\t\tdouble v_sahpe = GetVolumeProperties(shape, prop1, true, false);\n\t\tBRepClassificationTools brep;\n\t\tbool r1 = brep.IsPointInOnFace(shape1, Point3(1.0, 2.0, 2.0), -1.0);\n\t\tbool r2 = brep.IsPointInOnFace(shape2, Point3(4.0, 2.0, 2.0), -1.0);\n\t\tbool r3 = brep.IsPointInOnFace(shape3, Point3(2.0, 1.0, 2.0), -1.0);\n\t\tbool r33 = brep.IsPointInOnFace(shape3, Point3(0.0, 1.0, 0.5), -1.0);\n\t\tbool r4 = brep.IsPointInOnFace(shape4, Point3(2.0, 4.0, 2.0), -1.0);\n\t\tbool r5 = brep.IsPointInOnFace(shape5, Point3(2.0, 2.0, 1.0), -1.0);\n\t\tbool r6 = brep.IsPointInOnFace(shape6, Point3(2.0, 2.0, 4.0), -1.0);\n\t\tdouble s_shape_1 = GetSurfaceProperties(shape_1, prop1, true, false);\n\t\tdouble s_shape_2 = GetSurfaceProperties(shape_2, prop1, true, false);\n\t\tdouble s_shape_3 = GetSurfaceProperties(shape_3, prop1, true, false);\n\t\tdouble s_shape_4 = GetSurfaceProperties(shape_4, prop1, true, false);\n\t\tdouble s_shape_5 = GetSurfaceProperties(shape_5, prop1, true, false);\n\t\tdouble s_shape_6 = GetSurfaceProperties(shape_6, prop1, true, false);\n\t\tbool r_1 = brep.IsPointInOnFace(shape_1, Point3(1.0, 2.0, 2.0), -1.0);\n\t\tbool r_2 = brep.IsPointInOnFace(shape_2, Point3(4.0, 2.0, 2.0), -1.0);\n\t\tbool r_3 = brep.IsPointInOnFace(shape_3, Point3(2.0, 1.0, 2.0), -1.0);\n\t\tbool r_33 = brep.IsPointInOnFace(shape_3, Point3(0.0, 1.0, 0.5), -1.0);\n\t\tbool r_4 = brep.IsPointInOnFace(shape_4, Point3(2.0, 4.0, 2.0), -1.0);\n\t\tbool r_5 = brep.IsPointInOnFace(shape_5, Point3(2.0, 2.0, 1.0), -1.0);\n\t\tbool r_6 = brep.IsPointInOnFace(shape_6, Point3(2.0, 2.0, 4.0), -1.0);\n\t\tCHECK(s_sahpe1 == Approx(9.0).margin(1e-12));\n\t\tCHECK(s_sahpe2 == Approx(9.0).margin(1e-12));\n\t\tCHECK(s_sahpe3 == Approx(9.0).margin(1e-12));\n\t\tCHECK(s_sahpe4 == Approx(9.0).margin(1e-12));\n\t\tCHECK(s_sahpe5 == Approx(9.0).margin(1e-12));\n\t\tCHECK(s_sahpe6 == Approx(9.0).margin(1e-12));\n\t\tCHECK(v_sahpe == Approx(27.0).margin(1e-12));\n\t\tCHECK(s_sahpe  == s_sahpe1+ s_sahpe2+ s_sahpe3+s_sahpe4+s_sahpe5+s_sahpe6);\n\t\tCHECK(s_sahpe1 == s_shape_1);\n\t\tCHECK(s_sahpe2 == s_shape_2);\n\t\tCHECK(s_sahpe3 == s_shape_3);\n\t\tCHECK(s_sahpe4 == s_shape_4);\n\t\tCHECK(s_sahpe5 == s_shape_5);\n\t\tCHECK(s_sahpe6 == s_shape_6);\n\t\tCHECK(r1 == true);\n\t\tCHECK(r2 == true);\n\t\tCHECK(r3 == true);\n\t\tCHECK(r33 == false);\n\t\tCHECK(r4 == true);\n\t\tCHECK(r5 == true);\n\t\tCHECK(r6 == true);\n\t\tCHECK(r_1 == true);\n\t\tCHECK(r_2 == true);\n\t\tCHECK(r_3 == true);\n\t\tCHECK(r_33 == false);\n\t\tCHECK(r_4 == true);\n\t\tCHECK(r_5 == true);\n\t\tCHECK(r_6 == true);\n\t\tCHECK(OCCTIO::OCCTTool::Write(box2, outdir + \"MakeBox2.brep\"));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API const TopoFace& XMinFace()\t @return The X-min face\n\t @brief Get the face on X minimum\n,\n",
      "output": "#include <modeling/MakeBox.hpp>\n#include<catch.hpp>\n#include<testHelper.h>\n#include <modeling/MakeBox.hpp>\n#include <modeling/MakeCylinder.hpp>\n#include <topology/BRepExtremaProximityTool.hpp>\n#include <io/OBJTool.hpp>\n#include <topology/TopoFace.hpp>\n#include <modeling/TransformShape.hpp>\n#include <topology/TopoExplorerTool.hpp>\n#include <modeling/MakeTorus.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <topology/BRepExtremaDistShapeShape.hpp>\nusing namespace AMCAX;\n#include <modeling/MakeBox.hpp>\n#include<catch.hpp>\n#include<testHelper.h>\n#include <modeling/MakeBox.hpp>\n#include <modeling/MakeCylinder.hpp>\n#include <topology/BRepExtremaProximityTool.hpp>\n#include <io/OBJTool.hpp>\n#include <topology/TopoFace.hpp>\n#include <modeling/TransformShape.hpp>\n#include <topology/TopoExplorerTool.hpp>\n#include <modeling/MakeTorus.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <topology/BRepExtremaDistShapeShape.hpp>\nusing namespace AMCAX;\n;\n\tSECTION(\"Box1\") {\n\t\tOUTPUT_DIRECTORY(topology, OverlapFaces);\n\t\tMakeBox box(3.0, 2.0,2.0);\n\t\tTopoShape box2= box.Shape();\n\t\tbox.Init(4.0, 5.0, 6.0);\n\t\tTopoFace shape = box.XMinFace(); \n\t\tTopoFace shape1 = box.ZMinFace(); \n\t\tTopoShape shape2 = box; \n\t\tTopoShape shapeV = box;\n\t\tAMCAX::GlobalProperty prop1;\n\t\tdouble s_sahpe = GetSurfaceProperties(shape, prop1, true, false);\n\t\tdouble s_sahpe1 = GetSurfaceProperties(shape1, prop1, true, false);\n\t\tdouble s_sahpe2 = GetSurfaceProperties(shape2, prop1, true, false);\n\t\tdouble v_sahpe = GetVolumeProperties(shapeV, prop1, true, false);\n\t\tCHECK(s_sahpe == Approx(30.0).margin(1e-12));\n\t\tCHECK(s_sahpe1 == Approx(20.0).margin(1e-12));\n\t\tCHECK(s_sahpe2 == Approx(148.0).margin(1e-12));\n\t\tCHECK(v_sahpe == Approx(120.0).margin(1e-12));\n\t\tCHECK( OCCTIO::OCCTTool::Write(box, outdir + \"MakeBox1.brep\"));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API void Init(const Frame3& frame, double dx, double dy, double dz)\t @param dx,dy,dz The size\n\t @param frame The local coordinate system\n\t @brief Initialize and construct from a local coordinate system and size\n,\n",
      "output": "#include <modeling/MakeBox.hpp>\n#include<catch.hpp>\n#include<testHelper.h>\n#include <modeling/MakeBox.hpp>\n#include <modeling/MakeCylinder.hpp>\n#include <topology/BRepExtremaProximityTool.hpp>\n#include <io/OBJTool.hpp>\n#include <topology/TopoFace.hpp>\n#include <modeling/TransformShape.hpp>\n#include <topology/TopoExplorerTool.hpp>\n#include <modeling/MakeTorus.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <topology/BRepExtremaDistShapeShape.hpp>\nusing namespace AMCAX;\n#include <modeling/MakeBox.hpp>\n#include<catch.hpp>\n#include<testHelper.h>\n#include <modeling/MakeBox.hpp>\n#include <modeling/MakeCylinder.hpp>\n#include <topology/BRepExtremaProximityTool.hpp>\n#include <io/OBJTool.hpp>\n#include <topology/TopoFace.hpp>\n#include <modeling/TransformShape.hpp>\n#include <topology/TopoExplorerTool.hpp>\n#include <modeling/MakeTorus.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <topology/BRepExtremaDistShapeShape.hpp>\nusing namespace AMCAX;\n;\n\tSECTION(\"Box4\")\n\t{\n\t\tOUTPUT_DIRECTORY(topology, OverlapFaces);\n\t\tFrame3 frame(Point3(0.0, 0.0, 0.0),Direction3(1.0, 1.0, 1.0));\n\t\tMakeBox box2(frame, 3.0, 3.0, 3.0);\n\t\tMakeBox box3;\n\t\tbox3.Init(frame, 3.0, 3.0, 3.0);\n\t\tTopoFace shape1 = box2.XMinFace();\n\t\tTopoFace shape2 = box2.XMaxFace();\n\t\tTopoFace shape3 = box2.YMinFace();\n\t\tTopoFace shape4 = box2.YMaxFace();\n\t\tTopoFace shape5 = box2.ZMinFace();\n\t\tTopoFace shape6 = box2.ZMaxFace();\n\t\tTopoShape shape = box2;\n\t\tTopoFace shape_1 = box3.XMinFace();\n\t\tTopoFace shape_2 = box3.XMaxFace();\n\t\tTopoFace shape_3 = box3.YMinFace();\n\t\tTopoFace shape_4 = box3.YMaxFace();\n\t\tTopoFace shape_5 = box3.ZMinFace();\n\t\tTopoFace shape_6 = box3.ZMaxFace();\n\t\tAMCAX::GlobalProperty prop1;\n\t\tdouble s_sahpe1 = GetSurfaceProperties(shape1, prop1, true, false);\n\t\tdouble s_sahpe2 = GetSurfaceProperties(shape2, prop1, true, false);\n\t\tdouble s_sahpe3 = GetSurfaceProperties(shape3, prop1, true, false);\n\t\tdouble s_sahpe4 = GetSurfaceProperties(shape4, prop1, true, false);\n\t\tdouble s_sahpe5 = GetSurfaceProperties(shape5, prop1, true, false);\n\t\tdouble s_sahpe6 = GetSurfaceProperties(shape6, prop1, true, false);\n\t\tdouble s_sahpe = GetSurfaceProperties(shape, prop1, true, false);\n\t\tdouble v_sahpe = GetVolumeProperties(shape, prop1, true, false);\n\t\tBRepClassificationTools brep;\n\t\tbool r1 = brep.IsPointInOnFace(shape1, Point3(0.471005 , 1.580366 , 0.471005));\n\t\tbool r2 = brep.IsPointInOnFace(shape2, Point3(2.276501 , 1.893133 , -1.966139), -1.0);\n\t\tbool r3 = brep.IsPointInOnFace(shape3, Point3(1.595268 ,0.992078 ,0.388888), -1.0);\n\t\tbool r33 = brep.IsPointInOnFace(shape3, Point3(0.0, 1.0, 0.5), -1.0);\n\t\tbool r4 = brep.IsPointInOnFace(shape4, Point3(0.913586 , 3.603864 , - 1.054327), -1.0);\n\t\tbool r5 = brep.IsPointInOnFace(shape5, Point3(0.169491 , 0.796305 , -0.965796), -1.0);\n\t\tbool r6 = brep.IsPointInOnFace(shape6, Point3(1.633739, 2.302035, 1.260379), -1.0);\n\t\tdouble s_shape_1 = GetSurfaceProperties(shape_1, prop1, true, false);\n\t\tdouble s_shape_2 = GetSurfaceProperties(shape_2, prop1, true, false);\n\t\tdouble s_shape_3 = GetSurfaceProperties(shape_3, prop1, true, false);\n\t\tdouble s_shape_4 = GetSurfaceProperties(shape_4, prop1, true, false);\n\t\tdouble s_shape_5 = GetSurfaceProperties(shape_5, prop1, true, false);\n\t\tdouble s_shape_6 = GetSurfaceProperties(shape_6, prop1, true, false);\n\t\tbool r_1 = brep.IsPointInOnFace(shape_1, Point3(0.471005, 1.580366, 0.471005), -1.0);\n\t\tbool r_2 = brep.IsPointInOnFace(shape_2, Point3(2.276501, 1.893133, -1.966139), -1.0);\n\t\tbool r_3 = brep.IsPointInOnFace(shape_3, Point3(1.595268, 0.992078, 0.388888), -1.0);\n\t\tbool r_33 = brep.IsPointInOnFace(shape_3, Point3(0.0, 1.0, 0.5), -1.0);\n\t\tbool r_4 = brep.IsPointInOnFace(shape_4, Point3(0.913586, 3.603864, -1.054327), -1.0);\n\t\tbool r_5 = brep.IsPointInOnFace(shape_5, Point3(0.169491, 0.796305, -0.965796), -1.0);\n\t\tbool r_6 = brep.IsPointInOnFace(shape_6, Point3(1.633739, 2.302035, 1.260379), -1.0);\n\t\tCHECK(s_sahpe1 == Approx(9.0).margin(1e-12));\n\t\tCHECK(s_sahpe2 == Approx(9.0).margin(1e-12));\n\t\tCHECK(s_sahpe3 == Approx(9.0).margin(1e-12));\n\t\tCHECK(s_sahpe4 == Approx(9.0).margin(1e-12));\n\t\tCHECK(s_sahpe5 == Approx(9.0).margin(1e-12)); \n\t\tCHECK(s_sahpe6 == Approx(9.0).margin(1e-12));\n\t\tCHECK(v_sahpe == Approx(27.0).margin(1e-12));\n\t\tCHECK(s_sahpe == s_sahpe1 + s_sahpe2 + s_sahpe3 + s_sahpe4 + s_sahpe5 + s_sahpe6);\n\t\tCHECK(s_sahpe1 == s_shape_1);\n\t\tCHECK(s_sahpe2 == s_shape_2);\n\t\tCHECK(s_sahpe3 == s_shape_3);\n\t\tCHECK(s_sahpe4 == s_shape_4);\n\t\tCHECK(s_sahpe5 == s_shape_5);\n\t\tCHECK(s_sahpe6 == s_shape_6);\n\t\tCHECK(r1 == true);\n\t\tCHECK(r2 == true);\n\t\tCHECK(r3 == true);\n\t\tCHECK(r33 == false);\n\t\tCHECK(r4 == true);\n\t\tCHECK(r5 == true);\n\t\tCHECK(r6 == true);\n\t\tCHECK(r_1 == true);\n\t\tCHECK(r_2 == true);\n\t\tCHECK(r_3 == true);\n\t\tCHECK(r_33 == false);\n\t\tCHECK(r_4 == true);\n\t\tCHECK(r_5 == true);\n\t\tCHECK(r_6 == true);\n\t\tCHECK(OCCTIO::OCCTTool::Write(box2, outdir + \"MakeBox4.brep\"));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API void Init(const Point3& p1, const Point3& p2)\t @param p2 The second point\n\t @param p1 The first point\n\t @brief Initialize and construct from two diagonal corner points\n,\n",
      "output": "#include <modeling/MakeBox.hpp>\n#include<catch.hpp>\n#include<testHelper.h>\n#include <modeling/MakeBox.hpp>\n#include <modeling/MakeCylinder.hpp>\n#include <topology/BRepExtremaProximityTool.hpp>\n#include <io/OBJTool.hpp>\n#include <topology/TopoFace.hpp>\n#include <modeling/TransformShape.hpp>\n#include <topology/TopoExplorerTool.hpp>\n#include <modeling/MakeTorus.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <topology/BRepExtremaDistShapeShape.hpp>\nusing namespace AMCAX;\n#include <modeling/MakeBox.hpp>\n#include<catch.hpp>\n#include<testHelper.h>\n#include <modeling/MakeBox.hpp>\n#include <modeling/MakeCylinder.hpp>\n#include <topology/BRepExtremaProximityTool.hpp>\n#include <io/OBJTool.hpp>\n#include <topology/TopoFace.hpp>\n#include <modeling/TransformShape.hpp>\n#include <topology/TopoExplorerTool.hpp>\n#include <modeling/MakeTorus.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <topology/BRepExtremaDistShapeShape.hpp>\nusing namespace AMCAX;\n;\n\tSECTION(\"Box3\")\n\t{\n\t\tOUTPUT_DIRECTORY(topology, OverlapFaces);\n\t\tMakeBox box2(Point3(-2.0, -2.0, -2.0), Point3(2.0,2.0,2.0));\n\t\tMakeBox box3;\n\t\tbox3.Init(Point3(-2.0, -2.0, -2.0), Point3(2.0, 2.0, 2.0));\n\t\tTopoFace shape1 = box2.XMinFace();\n\t\tTopoFace shape2 = box2.XMaxFace();\n\t\tTopoFace shape3 = box2.YMinFace();\n\t\tTopoFace shape4 = box2.YMaxFace();\n\t\tTopoFace shape5 = box2.ZMinFace();\n\t\tTopoFace shape6 = box2.ZMaxFace();\n\t\tTopoShape shape = box2;\n\t\tTopoFace shape_1 = box3.XMinFace();\n\t\tTopoFace shape_2 = box3.XMaxFace();\n\t\tTopoFace shape_3 = box3.YMinFace();\n\t\tTopoFace shape_4 = box3.YMaxFace();\n\t\tTopoFace shape_5 = box3.ZMinFace();\n\t\tTopoFace shape_6 = box3.ZMaxFace();\n\t\tAMCAX::GlobalProperty prop1;\n\t\tdouble s_sahpe1 = GetSurfaceProperties(shape1, prop1, true, false);\n\t\tdouble s_sahpe2 = GetSurfaceProperties(shape2, prop1, true, false);\n\t\tdouble s_sahpe3 = GetSurfaceProperties(shape3, prop1, true, false);\n\t\tdouble s_sahpe4 = GetSurfaceProperties(shape4, prop1, true, false);\n\t\tdouble s_sahpe5 = GetSurfaceProperties(shape5, prop1, true, false);\n\t\tdouble s_sahpe6 = GetSurfaceProperties(shape6, prop1, true, false);\n\t\tdouble s_sahpe = GetSurfaceProperties(shape, prop1, true, false);\n\t\tdouble v_sahpe = GetVolumeProperties(shape, prop1, true, false);\n\t\tBRepClassificationTools brep;\n\t\tbool r1 = brep.IsPointInOnFace(shape1, Point3(-2.0, 0.0, 0.0), -1.0);\n\t\tbool r2 = brep.IsPointInOnFace(shape2, Point3(2.0, 0.0, 0.0), -1.0);\n\t\tbool r3 = brep.IsPointInOnFace(shape3, Point3(0.0, -2.0, 0.0), -1.0);\n\t\tbool r33 = brep.IsPointInOnFace(shape3, Point3(1.0, 0.5, 3.0), -1.0);\n\t\tbool r4 = brep.IsPointInOnFace(shape4, Point3(0.0, 2.0, 0.0), -1.0);\n\t\tbool r5 = brep.IsPointInOnFace(shape5, Point3(0.0, 0.0, -2.0), -1.0);\n\t\tbool r6 = brep.IsPointInOnFace(shape6, Point3(0.0, 0.0, 2.0), -1.0);\n\t\tdouble s_shape_1 = GetSurfaceProperties(shape_1, prop1, true, false);\n\t\tdouble s_shape_2 = GetSurfaceProperties(shape_2, prop1, true, false);\n\t\tdouble s_shape_3 = GetSurfaceProperties(shape_3, prop1, true, false);\n\t\tdouble s_shape_4 = GetSurfaceProperties(shape_4, prop1, true, false);\n\t\tdouble s_shape_5 = GetSurfaceProperties(shape_5, prop1, true, false);\n\t\tdouble s_shape_6 = GetSurfaceProperties(shape_6, prop1, true, false);\n\t\tbool r_1 = brep.IsPointInOnFace(shape_1, Point3(-2.0, 0.0, 0.0), -1.0);\n\t\tbool r_2 = brep.IsPointInOnFace(shape_2, Point3(2.0, 0.0, 0.0), -1.0);\n\t\tbool r_3 = brep.IsPointInOnFace(shape_3, Point3(0.0, -2.0, 0.0), -1.0);\n\t\tbool r_33 = brep.IsPointInOnFace(shape_3, Point3(1.0, 0.5, 3.0), -1.0);\n\t\tbool r_4 = brep.IsPointInOnFace(shape_4, Point3(0.0, 2.0, 0.0), -1.0);\n\t\tbool r_5 = brep.IsPointInOnFace(shape_5, Point3(0.0, 0.0, -2.0), -1.0);\n\t\tbool r_6 = brep.IsPointInOnFace(shape_6, Point3(0.0, 0.0, 2.0), -1.0);\n\t\tCHECK(s_sahpe1 == Approx(16.0).margin(1e-12));\n\t\tCHECK(s_sahpe2 == Approx(16.0).margin(1e-12));\n\t\tCHECK(s_sahpe3 == Approx(16.0).margin(1e-12));\n\t\tCHECK(s_sahpe4 == Approx(16.0).margin(1e-12));\n\t\tCHECK(s_sahpe5 == Approx(16.0).margin(1e-12));\n\t\tCHECK(s_sahpe6 == Approx(16.0).margin(1e-12));\n\t\tCHECK(v_sahpe == Approx(64.0).margin(1e-12));\n\t\tCHECK(s_sahpe == s_sahpe1 + s_sahpe2 + s_sahpe3 + s_sahpe4 + s_sahpe5 + s_sahpe6);\n\t\tCHECK(s_sahpe1 == s_shape_1);\n\t\tCHECK(s_sahpe2 == s_shape_2);\n\t\tCHECK(s_sahpe3 == s_shape_3);\n\t\tCHECK(s_sahpe4 == s_shape_4);\n\t\tCHECK(s_sahpe5 == s_shape_5);\n\t\tCHECK(s_sahpe6 == s_shape_6);\n\t\tCHECK(r1 == true);\n\t\tCHECK(r2 == true);\n\t\tCHECK(r3 == true);\n\t\tCHECK(r33 == false);\n\t\tCHECK(r4 == true);\n\t\tCHECK(r5 == true);\n\t\tCHECK(r6 == true);\n\t\tCHECK(r_1 == true);\n\t\tCHECK(r_2 == true);\n\t\tCHECK(r_3 == true);\n\t\tCHECK(r_33 == false);\n\t\tCHECK(r_4 == true);\n\t\tCHECK(r_5 == true);\n\t\tCHECK(r_6 == true);\n\t\tCHECK(OCCTIO::OCCTTool::Write(box2, outdir + \"MakeBox3.brep\"));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API void Init(const Point3& p, double dx, double dy, double dz)\t @param dx,dy,dz The size\n\t @param p The corner point\n\t @brief Initialize and construct from a corner point and its size\n,\n",
      "output": "#include <modeling/MakeBox.hpp>\n#include<catch.hpp>\n#include<testHelper.h>\n#include <modeling/MakeBox.hpp>\n#include <modeling/MakeCylinder.hpp>\n#include <topology/BRepExtremaProximityTool.hpp>\n#include <io/OBJTool.hpp>\n#include <topology/TopoFace.hpp>\n#include <modeling/TransformShape.hpp>\n#include <topology/TopoExplorerTool.hpp>\n#include <modeling/MakeTorus.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <topology/BRepExtremaDistShapeShape.hpp>\nusing namespace AMCAX;\n#include <modeling/MakeBox.hpp>\n#include<catch.hpp>\n#include<testHelper.h>\n#include <modeling/MakeBox.hpp>\n#include <modeling/MakeCylinder.hpp>\n#include <topology/BRepExtremaProximityTool.hpp>\n#include <io/OBJTool.hpp>\n#include <topology/TopoFace.hpp>\n#include <modeling/TransformShape.hpp>\n#include <topology/TopoExplorerTool.hpp>\n#include <modeling/MakeTorus.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <topology/BRepExtremaDistShapeShape.hpp>\nusing namespace AMCAX;\n;\n\tSECTION(\"Box2\") \n\t{\n\t\tOUTPUT_DIRECTORY(topology, OverlapFaces);\n\t\tMakeBox box2(Point3(1.0, 1.0, 1.0), 3.0, 3.0, 3.0);\n\t\tMakeBox box3;\n\t\tbox3.Init(Point3(1.0, 1.0, 1.0), 3.0, 3.0, 3.0);\n\t\tTopoFace shape1 = box2.XMinFace();\n\t\tTopoFace shape2 = box2.XMaxFace();\n\t\tTopoFace shape3 = box2.YMinFace();\n\t\tTopoFace shape4 = box2.YMaxFace();\n\t\tTopoFace shape5 = box2.ZMinFace();\n\t\tTopoFace shape6 = box2.ZMaxFace();\n\t\tTopoShape shape = box2;\n\t\tTopoFace shape_1 = box3.XMinFace();\n\t\tTopoFace shape_2 = box3.XMaxFace();\n\t\tTopoFace shape_3 = box3.YMinFace();\n\t\tTopoFace shape_4 = box3.YMaxFace();\n\t\tTopoFace shape_5 = box3.ZMinFace();\n\t\tTopoFace shape_6 = box3.ZMaxFace();\n\t\tAMCAX::GlobalProperty prop1;\n\t\tdouble s_sahpe1 = GetSurfaceProperties(shape1, prop1, true, false);\n\t\tdouble s_sahpe2 = GetSurfaceProperties(shape2, prop1, true, false);\n\t\tdouble s_sahpe3 = GetSurfaceProperties(shape3, prop1, true, false);\n\t\tdouble s_sahpe4 = GetSurfaceProperties(shape4, prop1, true, false);\n\t\tdouble s_sahpe5 = GetSurfaceProperties(shape5, prop1, true, false);\n\t\tdouble s_sahpe6 = GetSurfaceProperties(shape6, prop1, true, false);\n\t\tdouble s_sahpe  = GetSurfaceProperties(shape, prop1, true, false);\n\t\tdouble v_sahpe = GetVolumeProperties(shape, prop1, true, false);\n\t\tBRepClassificationTools brep;\n\t\tbool r1 = brep.IsPointInOnFace(shape1, Point3(1.0, 2.0, 2.0), -1.0);\n\t\tbool r2 = brep.IsPointInOnFace(shape2, Point3(4.0, 2.0, 2.0), -1.0);\n\t\tbool r3 = brep.IsPointInOnFace(shape3, Point3(2.0, 1.0, 2.0), -1.0);\n\t\tbool r33 = brep.IsPointInOnFace(shape3, Point3(0.0, 1.0, 0.5), -1.0);\n\t\tbool r4 = brep.IsPointInOnFace(shape4, Point3(2.0, 4.0, 2.0), -1.0);\n\t\tbool r5 = brep.IsPointInOnFace(shape5, Point3(2.0, 2.0, 1.0), -1.0);\n\t\tbool r6 = brep.IsPointInOnFace(shape6, Point3(2.0, 2.0, 4.0), -1.0);\n\t\tdouble s_shape_1 = GetSurfaceProperties(shape_1, prop1, true, false);\n\t\tdouble s_shape_2 = GetSurfaceProperties(shape_2, prop1, true, false);\n\t\tdouble s_shape_3 = GetSurfaceProperties(shape_3, prop1, true, false);\n\t\tdouble s_shape_4 = GetSurfaceProperties(shape_4, prop1, true, false);\n\t\tdouble s_shape_5 = GetSurfaceProperties(shape_5, prop1, true, false);\n\t\tdouble s_shape_6 = GetSurfaceProperties(shape_6, prop1, true, false);\n\t\tbool r_1 = brep.IsPointInOnFace(shape_1, Point3(1.0, 2.0, 2.0), -1.0);\n\t\tbool r_2 = brep.IsPointInOnFace(shape_2, Point3(4.0, 2.0, 2.0), -1.0);\n\t\tbool r_3 = brep.IsPointInOnFace(shape_3, Point3(2.0, 1.0, 2.0), -1.0);\n\t\tbool r_33 = brep.IsPointInOnFace(shape_3, Point3(0.0, 1.0, 0.5), -1.0);\n\t\tbool r_4 = brep.IsPointInOnFace(shape_4, Point3(2.0, 4.0, 2.0), -1.0);\n\t\tbool r_5 = brep.IsPointInOnFace(shape_5, Point3(2.0, 2.0, 1.0), -1.0);\n\t\tbool r_6 = brep.IsPointInOnFace(shape_6, Point3(2.0, 2.0, 4.0), -1.0);\n\t\tCHECK(s_sahpe1 == Approx(9.0).margin(1e-12));\n\t\tCHECK(s_sahpe2 == Approx(9.0).margin(1e-12));\n\t\tCHECK(s_sahpe3 == Approx(9.0).margin(1e-12));\n\t\tCHECK(s_sahpe4 == Approx(9.0).margin(1e-12));\n\t\tCHECK(s_sahpe5 == Approx(9.0).margin(1e-12));\n\t\tCHECK(s_sahpe6 == Approx(9.0).margin(1e-12));\n\t\tCHECK(v_sahpe == Approx(27.0).margin(1e-12));\n\t\tCHECK(s_sahpe  == s_sahpe1+ s_sahpe2+ s_sahpe3+s_sahpe4+s_sahpe5+s_sahpe6);\n\t\tCHECK(s_sahpe1 == s_shape_1);\n\t\tCHECK(s_sahpe2 == s_shape_2);\n\t\tCHECK(s_sahpe3 == s_shape_3);\n\t\tCHECK(s_sahpe4 == s_shape_4);\n\t\tCHECK(s_sahpe5 == s_shape_5);\n\t\tCHECK(s_sahpe6 == s_shape_6);\n\t\tCHECK(r1 == true);\n\t\tCHECK(r2 == true);\n\t\tCHECK(r3 == true);\n\t\tCHECK(r33 == false);\n\t\tCHECK(r4 == true);\n\t\tCHECK(r5 == true);\n\t\tCHECK(r6 == true);\n\t\tCHECK(r_1 == true);\n\t\tCHECK(r_2 == true);\n\t\tCHECK(r_3 == true);\n\t\tCHECK(r_33 == false);\n\t\tCHECK(r_4 == true);\n\t\tCHECK(r_5 == true);\n\t\tCHECK(r_6 == true);\n\t\tCHECK(OCCTIO::OCCTTool::Write(box2, outdir + \"MakeBox2.brep\"));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API void Init(double dx, double dy, double dz)\t @param dx,dy,dz The size\n\t @brief Initialize and construct from its size in x, y, z directions\n,\n",
      "output": "#include <modeling/MakeBox.hpp>\n#include<catch.hpp>\n#include<testHelper.h>\n#include <modeling/MakeBox.hpp>\n#include <modeling/MakeCylinder.hpp>\n#include <topology/BRepExtremaProximityTool.hpp>\n#include <io/OBJTool.hpp>\n#include <topology/TopoFace.hpp>\n#include <modeling/TransformShape.hpp>\n#include <topology/TopoExplorerTool.hpp>\n#include <modeling/MakeTorus.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <topology/BRepExtremaDistShapeShape.hpp>\nusing namespace AMCAX;\n#include <modeling/MakeBox.hpp>\n#include<catch.hpp>\n#include<testHelper.h>\n#include <modeling/MakeBox.hpp>\n#include <modeling/MakeCylinder.hpp>\n#include <topology/BRepExtremaProximityTool.hpp>\n#include <io/OBJTool.hpp>\n#include <topology/TopoFace.hpp>\n#include <modeling/TransformShape.hpp>\n#include <topology/TopoExplorerTool.hpp>\n#include <modeling/MakeTorus.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <topology/BRepExtremaDistShapeShape.hpp>\nusing namespace AMCAX;\n;\n\tSECTION(\"Box1\") {\n\t\tOUTPUT_DIRECTORY(topology, OverlapFaces);\n\t\tMakeBox box(3.0, 2.0,2.0);\n\t\tTopoShape box2= box.Shape();\n\t\tbox.Init(4.0, 5.0, 6.0);\n\t\tTopoFace shape = box.XMinFace(); \n\t\tTopoFace shape1 = box.ZMinFace(); \n\t\tTopoShape shape2 = box; \n\t\tTopoShape shapeV = box;\n\t\tAMCAX::GlobalProperty prop1;\n\t\tdouble s_sahpe = GetSurfaceProperties(shape, prop1, true, false);\n\t\tdouble s_sahpe1 = GetSurfaceProperties(shape1, prop1, true, false);\n\t\tdouble s_sahpe2 = GetSurfaceProperties(shape2, prop1, true, false);\n\t\tdouble v_sahpe = GetVolumeProperties(shapeV, prop1, true, false);\n\t\tCHECK(s_sahpe == Approx(30.0).margin(1e-12));\n\t\tCHECK(s_sahpe1 == Approx(20.0).margin(1e-12));\n\t\tCHECK(s_sahpe2 == Approx(148.0).margin(1e-12));\n\t\tCHECK(v_sahpe == Approx(120.0).margin(1e-12));\n\t\tCHECK( OCCTIO::OCCTTool::Write(box, outdir + \"MakeBox1.brep\"));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API MakeBox(const Frame3& frame, double dx, double dy, double dz)\t @param dx,dy,dz The size\n\t @param frame The local coordinate system\n\t @brief Construct from a local coordinate system and size\n,\n",
      "output": "#include <modeling/MakeBox.hpp>\n#include<catch.hpp>\n#include<testHelper.h>\n#include <modeling/MakeBox.hpp>\n#include <modeling/MakeCylinder.hpp>\n#include <topology/BRepExtremaProximityTool.hpp>\n#include <io/OBJTool.hpp>\n#include <topology/TopoFace.hpp>\n#include <modeling/TransformShape.hpp>\n#include <topology/TopoExplorerTool.hpp>\n#include <modeling/MakeTorus.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <topology/BRepExtremaDistShapeShape.hpp>\nusing namespace AMCAX;\n#include <modeling/MakeBox.hpp>\n#include<catch.hpp>\n#include<testHelper.h>\n#include <modeling/MakeBox.hpp>\n#include <modeling/MakeCylinder.hpp>\n#include <topology/BRepExtremaProximityTool.hpp>\n#include <io/OBJTool.hpp>\n#include <topology/TopoFace.hpp>\n#include <modeling/TransformShape.hpp>\n#include <topology/TopoExplorerTool.hpp>\n#include <modeling/MakeTorus.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <topology/BRepExtremaDistShapeShape.hpp>\nusing namespace AMCAX;\n;\n\tSECTION(\"Box2\") \n\t{\n\t\tOUTPUT_DIRECTORY(topology, OverlapFaces);\n\t\tMakeBox box2(Point3(1.0, 1.0, 1.0), 3.0, 3.0, 3.0);\n\t\tMakeBox box3;\n\t\tbox3.Init(Point3(1.0, 1.0, 1.0), 3.0, 3.0, 3.0);\n\t\tTopoFace shape1 = box2.XMinFace();\n\t\tTopoFace shape2 = box2.XMaxFace();\n\t\tTopoFace shape3 = box2.YMinFace();\n\t\tTopoFace shape4 = box2.YMaxFace();\n\t\tTopoFace shape5 = box2.ZMinFace();\n\t\tTopoFace shape6 = box2.ZMaxFace();\n\t\tTopoShape shape = box2;\n\t\tTopoFace shape_1 = box3.XMinFace();\n\t\tTopoFace shape_2 = box3.XMaxFace();\n\t\tTopoFace shape_3 = box3.YMinFace();\n\t\tTopoFace shape_4 = box3.YMaxFace();\n\t\tTopoFace shape_5 = box3.ZMinFace();\n\t\tTopoFace shape_6 = box3.ZMaxFace();\n\t\tAMCAX::GlobalProperty prop1;\n\t\tdouble s_sahpe1 = GetSurfaceProperties(shape1, prop1, true, false);\n\t\tdouble s_sahpe2 = GetSurfaceProperties(shape2, prop1, true, false);\n\t\tdouble s_sahpe3 = GetSurfaceProperties(shape3, prop1, true, false);\n\t\tdouble s_sahpe4 = GetSurfaceProperties(shape4, prop1, true, false);\n\t\tdouble s_sahpe5 = GetSurfaceProperties(shape5, prop1, true, false);\n\t\tdouble s_sahpe6 = GetSurfaceProperties(shape6, prop1, true, false);\n\t\tdouble s_sahpe  = GetSurfaceProperties(shape, prop1, true, false);\n\t\tdouble v_sahpe = GetVolumeProperties(shape, prop1, true, false);\n\t\tBRepClassificationTools brep;\n\t\tbool r1 = brep.IsPointInOnFace(shape1, Point3(1.0, 2.0, 2.0), -1.0);\n\t\tbool r2 = brep.IsPointInOnFace(shape2, Point3(4.0, 2.0, 2.0), -1.0);\n\t\tbool r3 = brep.IsPointInOnFace(shape3, Point3(2.0, 1.0, 2.0), -1.0);\n\t\tbool r33 = brep.IsPointInOnFace(shape3, Point3(0.0, 1.0, 0.5), -1.0);\n\t\tbool r4 = brep.IsPointInOnFace(shape4, Point3(2.0, 4.0, 2.0), -1.0);\n\t\tbool r5 = brep.IsPointInOnFace(shape5, Point3(2.0, 2.0, 1.0), -1.0);\n\t\tbool r6 = brep.IsPointInOnFace(shape6, Point3(2.0, 2.0, 4.0), -1.0);\n\t\tdouble s_shape_1 = GetSurfaceProperties(shape_1, prop1, true, false);\n\t\tdouble s_shape_2 = GetSurfaceProperties(shape_2, prop1, true, false);\n\t\tdouble s_shape_3 = GetSurfaceProperties(shape_3, prop1, true, false);\n\t\tdouble s_shape_4 = GetSurfaceProperties(shape_4, prop1, true, false);\n\t\tdouble s_shape_5 = GetSurfaceProperties(shape_5, prop1, true, false);\n\t\tdouble s_shape_6 = GetSurfaceProperties(shape_6, prop1, true, false);\n\t\tbool r_1 = brep.IsPointInOnFace(shape_1, Point3(1.0, 2.0, 2.0), -1.0);\n\t\tbool r_2 = brep.IsPointInOnFace(shape_2, Point3(4.0, 2.0, 2.0), -1.0);\n\t\tbool r_3 = brep.IsPointInOnFace(shape_3, Point3(2.0, 1.0, 2.0), -1.0);\n\t\tbool r_33 = brep.IsPointInOnFace(shape_3, Point3(0.0, 1.0, 0.5), -1.0);\n\t\tbool r_4 = brep.IsPointInOnFace(shape_4, Point3(2.0, 4.0, 2.0), -1.0);\n\t\tbool r_5 = brep.IsPointInOnFace(shape_5, Point3(2.0, 2.0, 1.0), -1.0);\n\t\tbool r_6 = brep.IsPointInOnFace(shape_6, Point3(2.0, 2.0, 4.0), -1.0);\n\t\tCHECK(s_sahpe1 == Approx(9.0).margin(1e-12));\n\t\tCHECK(s_sahpe2 == Approx(9.0).margin(1e-12));\n\t\tCHECK(s_sahpe3 == Approx(9.0).margin(1e-12));\n\t\tCHECK(s_sahpe4 == Approx(9.0).margin(1e-12));\n\t\tCHECK(s_sahpe5 == Approx(9.0).margin(1e-12));\n\t\tCHECK(s_sahpe6 == Approx(9.0).margin(1e-12));\n\t\tCHECK(v_sahpe == Approx(27.0).margin(1e-12));\n\t\tCHECK(s_sahpe  == s_sahpe1+ s_sahpe2+ s_sahpe3+s_sahpe4+s_sahpe5+s_sahpe6);\n\t\tCHECK(s_sahpe1 == s_shape_1);\n\t\tCHECK(s_sahpe2 == s_shape_2);\n\t\tCHECK(s_sahpe3 == s_shape_3);\n\t\tCHECK(s_sahpe4 == s_shape_4);\n\t\tCHECK(s_sahpe5 == s_shape_5);\n\t\tCHECK(s_sahpe6 == s_shape_6);\n\t\tCHECK(r1 == true);\n\t\tCHECK(r2 == true);\n\t\tCHECK(r3 == true);\n\t\tCHECK(r33 == false);\n\t\tCHECK(r4 == true);\n\t\tCHECK(r5 == true);\n\t\tCHECK(r6 == true);\n\t\tCHECK(r_1 == true);\n\t\tCHECK(r_2 == true);\n\t\tCHECK(r_3 == true);\n\t\tCHECK(r_33 == false);\n\t\tCHECK(r_4 == true);\n\t\tCHECK(r_5 == true);\n\t\tCHECK(r_6 == true);\n\t\tCHECK(OCCTIO::OCCTTool::Write(box2, outdir + \"MakeBox2.brep\"));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API MakeBox(const Point3& p1, const Point3& p2)\t @param p2 The second point\n\t @param p1 The first point\n\t @brief Construct from two diagonal corner points\n,\n",
      "output": "#include <modeling/MakeBox.hpp>\n#include<catch.hpp>\n#include<testHelper.h>\n#include <modeling/MakeBox.hpp>\n#include <modeling/MakeCylinder.hpp>\n#include <topology/BRepExtremaProximityTool.hpp>\n#include <io/OBJTool.hpp>\n#include <topology/TopoFace.hpp>\n#include <modeling/TransformShape.hpp>\n#include <topology/TopoExplorerTool.hpp>\n#include <modeling/MakeTorus.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <topology/BRepExtremaDistShapeShape.hpp>\nusing namespace AMCAX;\n#include <modeling/MakeBox.hpp>\n#include<catch.hpp>\n#include<testHelper.h>\n#include <modeling/MakeBox.hpp>\n#include <modeling/MakeCylinder.hpp>\n#include <topology/BRepExtremaProximityTool.hpp>\n#include <io/OBJTool.hpp>\n#include <topology/TopoFace.hpp>\n#include <modeling/TransformShape.hpp>\n#include <topology/TopoExplorerTool.hpp>\n#include <modeling/MakeTorus.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <topology/BRepExtremaDistShapeShape.hpp>\nusing namespace AMCAX;\n;\n\tSECTION(\"Box3\")\n\t{\n\t\tOUTPUT_DIRECTORY(topology, OverlapFaces);\n\t\tMakeBox box2(Point3(-2.0, -2.0, -2.0), Point3(2.0,2.0,2.0));\n\t\tMakeBox box3;\n\t\tbox3.Init(Point3(-2.0, -2.0, -2.0), Point3(2.0, 2.0, 2.0));\n\t\tTopoFace shape1 = box2.XMinFace();\n\t\tTopoFace shape2 = box2.XMaxFace();\n\t\tTopoFace shape3 = box2.YMinFace();\n\t\tTopoFace shape4 = box2.YMaxFace();\n\t\tTopoFace shape5 = box2.ZMinFace();\n\t\tTopoFace shape6 = box2.ZMaxFace();\n\t\tTopoShape shape = box2;\n\t\tTopoFace shape_1 = box3.XMinFace();\n\t\tTopoFace shape_2 = box3.XMaxFace();\n\t\tTopoFace shape_3 = box3.YMinFace();\n\t\tTopoFace shape_4 = box3.YMaxFace();\n\t\tTopoFace shape_5 = box3.ZMinFace();\n\t\tTopoFace shape_6 = box3.ZMaxFace();\n\t\tAMCAX::GlobalProperty prop1;\n\t\tdouble s_sahpe1 = GetSurfaceProperties(shape1, prop1, true, false);\n\t\tdouble s_sahpe2 = GetSurfaceProperties(shape2, prop1, true, false);\n\t\tdouble s_sahpe3 = GetSurfaceProperties(shape3, prop1, true, false);\n\t\tdouble s_sahpe4 = GetSurfaceProperties(shape4, prop1, true, false);\n\t\tdouble s_sahpe5 = GetSurfaceProperties(shape5, prop1, true, false);\n\t\tdouble s_sahpe6 = GetSurfaceProperties(shape6, prop1, true, false);\n\t\tdouble s_sahpe = GetSurfaceProperties(shape, prop1, true, false);\n\t\tdouble v_sahpe = GetVolumeProperties(shape, prop1, true, false);\n\t\tBRepClassificationTools brep;\n\t\tbool r1 = brep.IsPointInOnFace(shape1, Point3(-2.0, 0.0, 0.0), -1.0);\n\t\tbool r2 = brep.IsPointInOnFace(shape2, Point3(2.0, 0.0, 0.0), -1.0);\n\t\tbool r3 = brep.IsPointInOnFace(shape3, Point3(0.0, -2.0, 0.0), -1.0);\n\t\tbool r33 = brep.IsPointInOnFace(shape3, Point3(1.0, 0.5, 3.0), -1.0);\n\t\tbool r4 = brep.IsPointInOnFace(shape4, Point3(0.0, 2.0, 0.0), -1.0);\n\t\tbool r5 = brep.IsPointInOnFace(shape5, Point3(0.0, 0.0, -2.0), -1.0);\n\t\tbool r6 = brep.IsPointInOnFace(shape6, Point3(0.0, 0.0, 2.0), -1.0);\n\t\tdouble s_shape_1 = GetSurfaceProperties(shape_1, prop1, true, false);\n\t\tdouble s_shape_2 = GetSurfaceProperties(shape_2, prop1, true, false);\n\t\tdouble s_shape_3 = GetSurfaceProperties(shape_3, prop1, true, false);\n\t\tdouble s_shape_4 = GetSurfaceProperties(shape_4, prop1, true, false);\n\t\tdouble s_shape_5 = GetSurfaceProperties(shape_5, prop1, true, false);\n\t\tdouble s_shape_6 = GetSurfaceProperties(shape_6, prop1, true, false);\n\t\tbool r_1 = brep.IsPointInOnFace(shape_1, Point3(-2.0, 0.0, 0.0), -1.0);\n\t\tbool r_2 = brep.IsPointInOnFace(shape_2, Point3(2.0, 0.0, 0.0), -1.0);\n\t\tbool r_3 = brep.IsPointInOnFace(shape_3, Point3(0.0, -2.0, 0.0), -1.0);\n\t\tbool r_33 = brep.IsPointInOnFace(shape_3, Point3(1.0, 0.5, 3.0), -1.0);\n\t\tbool r_4 = brep.IsPointInOnFace(shape_4, Point3(0.0, 2.0, 0.0), -1.0);\n\t\tbool r_5 = brep.IsPointInOnFace(shape_5, Point3(0.0, 0.0, -2.0), -1.0);\n\t\tbool r_6 = brep.IsPointInOnFace(shape_6, Point3(0.0, 0.0, 2.0), -1.0);\n\t\tCHECK(s_sahpe1 == Approx(16.0).margin(1e-12));\n\t\tCHECK(s_sahpe2 == Approx(16.0).margin(1e-12));\n\t\tCHECK(s_sahpe3 == Approx(16.0).margin(1e-12));\n\t\tCHECK(s_sahpe4 == Approx(16.0).margin(1e-12));\n\t\tCHECK(s_sahpe5 == Approx(16.0).margin(1e-12));\n\t\tCHECK(s_sahpe6 == Approx(16.0).margin(1e-12));\n\t\tCHECK(v_sahpe == Approx(64.0).margin(1e-12));\n\t\tCHECK(s_sahpe == s_sahpe1 + s_sahpe2 + s_sahpe3 + s_sahpe4 + s_sahpe5 + s_sahpe6);\n\t\tCHECK(s_sahpe1 == s_shape_1);\n\t\tCHECK(s_sahpe2 == s_shape_2);\n\t\tCHECK(s_sahpe3 == s_shape_3);\n\t\tCHECK(s_sahpe4 == s_shape_4);\n\t\tCHECK(s_sahpe5 == s_shape_5);\n\t\tCHECK(s_sahpe6 == s_shape_6);\n\t\tCHECK(r1 == true);\n\t\tCHECK(r2 == true);\n\t\tCHECK(r3 == true);\n\t\tCHECK(r33 == false);\n\t\tCHECK(r4 == true);\n\t\tCHECK(r5 == true);\n\t\tCHECK(r6 == true);\n\t\tCHECK(r_1 == true);\n\t\tCHECK(r_2 == true);\n\t\tCHECK(r_3 == true);\n\t\tCHECK(r_33 == false);\n\t\tCHECK(r_4 == true);\n\t\tCHECK(r_5 == true);\n\t\tCHECK(r_6 == true);\n\t\tCHECK(OCCTIO::OCCTTool::Write(box2, outdir + \"MakeBox3.brep\"));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API MakeBox(const Point3& p, double dx, double dy, double dz)\t @param dx,dy,dz The size\n\t @param p The corner point\n\t @brief Construct from a corner point and its size\n,\n",
      "output": "#include <modeling/MakeBox.hpp>\n#include<catch.hpp>\n#include<testHelper.h>\n#include <modeling/MakeBox.hpp>\n#include <modeling/MakeCylinder.hpp>\n#include <topology/BRepExtremaProximityTool.hpp>\n#include <io/OBJTool.hpp>\n#include <topology/TopoFace.hpp>\n#include <modeling/TransformShape.hpp>\n#include <topology/TopoExplorerTool.hpp>\n#include <modeling/MakeTorus.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <topology/BRepExtremaDistShapeShape.hpp>\nusing namespace AMCAX;\n#include <modeling/MakeBox.hpp>\n#include<catch.hpp>\n#include<testHelper.h>\n#include <modeling/MakeBox.hpp>\n#include <modeling/MakeCylinder.hpp>\n#include <topology/BRepExtremaProximityTool.hpp>\n#include <io/OBJTool.hpp>\n#include <topology/TopoFace.hpp>\n#include <modeling/TransformShape.hpp>\n#include <topology/TopoExplorerTool.hpp>\n#include <modeling/MakeTorus.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <topology/BRepExtremaDistShapeShape.hpp>\nusing namespace AMCAX;\n;\n\tSECTION(\"Box2\") \n\t{\n\t\tOUTPUT_DIRECTORY(topology, OverlapFaces);\n\t\tMakeBox box2(Point3(1.0, 1.0, 1.0), 3.0, 3.0, 3.0);\n\t\tMakeBox box3;\n\t\tbox3.Init(Point3(1.0, 1.0, 1.0), 3.0, 3.0, 3.0);\n\t\tTopoFace shape1 = box2.XMinFace();\n\t\tTopoFace shape2 = box2.XMaxFace();\n\t\tTopoFace shape3 = box2.YMinFace();\n\t\tTopoFace shape4 = box2.YMaxFace();\n\t\tTopoFace shape5 = box2.ZMinFace();\n\t\tTopoFace shape6 = box2.ZMaxFace();\n\t\tTopoShape shape = box2;\n\t\tTopoFace shape_1 = box3.XMinFace();\n\t\tTopoFace shape_2 = box3.XMaxFace();\n\t\tTopoFace shape_3 = box3.YMinFace();\n\t\tTopoFace shape_4 = box3.YMaxFace();\n\t\tTopoFace shape_5 = box3.ZMinFace();\n\t\tTopoFace shape_6 = box3.ZMaxFace();\n\t\tAMCAX::GlobalProperty prop1;\n\t\tdouble s_sahpe1 = GetSurfaceProperties(shape1, prop1, true, false);\n\t\tdouble s_sahpe2 = GetSurfaceProperties(shape2, prop1, true, false);\n\t\tdouble s_sahpe3 = GetSurfaceProperties(shape3, prop1, true, false);\n\t\tdouble s_sahpe4 = GetSurfaceProperties(shape4, prop1, true, false);\n\t\tdouble s_sahpe5 = GetSurfaceProperties(shape5, prop1, true, false);\n\t\tdouble s_sahpe6 = GetSurfaceProperties(shape6, prop1, true, false);\n\t\tdouble s_sahpe  = GetSurfaceProperties(shape, prop1, true, false);\n\t\tdouble v_sahpe = GetVolumeProperties(shape, prop1, true, false);\n\t\tBRepClassificationTools brep;\n\t\tbool r1 = brep.IsPointInOnFace(shape1, Point3(1.0, 2.0, 2.0), -1.0);\n\t\tbool r2 = brep.IsPointInOnFace(shape2, Point3(4.0, 2.0, 2.0), -1.0);\n\t\tbool r3 = brep.IsPointInOnFace(shape3, Point3(2.0, 1.0, 2.0), -1.0);\n\t\tbool r33 = brep.IsPointInOnFace(shape3, Point3(0.0, 1.0, 0.5), -1.0);\n\t\tbool r4 = brep.IsPointInOnFace(shape4, Point3(2.0, 4.0, 2.0), -1.0);\n\t\tbool r5 = brep.IsPointInOnFace(shape5, Point3(2.0, 2.0, 1.0), -1.0);\n\t\tbool r6 = brep.IsPointInOnFace(shape6, Point3(2.0, 2.0, 4.0), -1.0);\n\t\tdouble s_shape_1 = GetSurfaceProperties(shape_1, prop1, true, false);\n\t\tdouble s_shape_2 = GetSurfaceProperties(shape_2, prop1, true, false);\n\t\tdouble s_shape_3 = GetSurfaceProperties(shape_3, prop1, true, false);\n\t\tdouble s_shape_4 = GetSurfaceProperties(shape_4, prop1, true, false);\n\t\tdouble s_shape_5 = GetSurfaceProperties(shape_5, prop1, true, false);\n\t\tdouble s_shape_6 = GetSurfaceProperties(shape_6, prop1, true, false);\n\t\tbool r_1 = brep.IsPointInOnFace(shape_1, Point3(1.0, 2.0, 2.0), -1.0);\n\t\tbool r_2 = brep.IsPointInOnFace(shape_2, Point3(4.0, 2.0, 2.0), -1.0);\n\t\tbool r_3 = brep.IsPointInOnFace(shape_3, Point3(2.0, 1.0, 2.0), -1.0);\n\t\tbool r_33 = brep.IsPointInOnFace(shape_3, Point3(0.0, 1.0, 0.5), -1.0);\n\t\tbool r_4 = brep.IsPointInOnFace(shape_4, Point3(2.0, 4.0, 2.0), -1.0);\n\t\tbool r_5 = brep.IsPointInOnFace(shape_5, Point3(2.0, 2.0, 1.0), -1.0);\n\t\tbool r_6 = brep.IsPointInOnFace(shape_6, Point3(2.0, 2.0, 4.0), -1.0);\n\t\tCHECK(s_sahpe1 == Approx(9.0).margin(1e-12));\n\t\tCHECK(s_sahpe2 == Approx(9.0).margin(1e-12));\n\t\tCHECK(s_sahpe3 == Approx(9.0).margin(1e-12));\n\t\tCHECK(s_sahpe4 == Approx(9.0).margin(1e-12));\n\t\tCHECK(s_sahpe5 == Approx(9.0).margin(1e-12));\n\t\tCHECK(s_sahpe6 == Approx(9.0).margin(1e-12));\n\t\tCHECK(v_sahpe == Approx(27.0).margin(1e-12));\n\t\tCHECK(s_sahpe  == s_sahpe1+ s_sahpe2+ s_sahpe3+s_sahpe4+s_sahpe5+s_sahpe6);\n\t\tCHECK(s_sahpe1 == s_shape_1);\n\t\tCHECK(s_sahpe2 == s_shape_2);\n\t\tCHECK(s_sahpe3 == s_shape_3);\n\t\tCHECK(s_sahpe4 == s_shape_4);\n\t\tCHECK(s_sahpe5 == s_shape_5);\n\t\tCHECK(s_sahpe6 == s_shape_6);\n\t\tCHECK(r1 == true);\n\t\tCHECK(r2 == true);\n\t\tCHECK(r3 == true);\n\t\tCHECK(r33 == false);\n\t\tCHECK(r4 == true);\n\t\tCHECK(r5 == true);\n\t\tCHECK(r6 == true);\n\t\tCHECK(r_1 == true);\n\t\tCHECK(r_2 == true);\n\t\tCHECK(r_3 == true);\n\t\tCHECK(r_33 == false);\n\t\tCHECK(r_4 == true);\n\t\tCHECK(r_5 == true);\n\t\tCHECK(r_6 == true);\n\t\tCHECK(OCCTIO::OCCTTool::Write(box2, outdir + \"MakeBox2.brep\"));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API MakeBox(double dx, double dy, double dz)\t @param dx,dy,dz The size\n\t @brief Construct from its size in x, y, z directions\n,\n",
      "output": "#include <modeling/MakeBox.hpp>\n#include<catch.hpp>\n#include<testHelper.h>\n#include <modeling/MakeBox.hpp>\n#include <modeling/MakeCylinder.hpp>\n#include <topology/BRepExtremaProximityTool.hpp>\n#include <io/OBJTool.hpp>\n#include <topology/TopoFace.hpp>\n#include <modeling/TransformShape.hpp>\n#include <topology/TopoExplorerTool.hpp>\n#include <modeling/MakeTorus.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <topology/BRepExtremaDistShapeShape.hpp>\nusing namespace AMCAX;\n#include <modeling/MakeBox.hpp>\n#include<catch.hpp>\n#include<testHelper.h>\n#include <modeling/MakeBox.hpp>\n#include <modeling/MakeCylinder.hpp>\n#include <topology/BRepExtremaProximityTool.hpp>\n#include <io/OBJTool.hpp>\n#include <topology/TopoFace.hpp>\n#include <modeling/TransformShape.hpp>\n#include <topology/TopoExplorerTool.hpp>\n#include <modeling/MakeTorus.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <topology/BRepExtremaDistShapeShape.hpp>\nusing namespace AMCAX;\n;\n\tSECTION(\"Box1\") {\n\t\tOUTPUT_DIRECTORY(topology, OverlapFaces);\n\t\tMakeBox box(3.0, 2.0,2.0);\n\t\tTopoShape box2= box.Shape();\n\t\tbox.Init(4.0, 5.0, 6.0);\n\t\tTopoFace shape = box.XMinFace(); \n\t\tTopoFace shape1 = box.ZMinFace(); \n\t\tTopoShape shape2 = box; \n\t\tTopoShape shapeV = box;\n\t\tAMCAX::GlobalProperty prop1;\n\t\tdouble s_sahpe = GetSurfaceProperties(shape, prop1, true, false);\n\t\tdouble s_sahpe1 = GetSurfaceProperties(shape1, prop1, true, false);\n\t\tdouble s_sahpe2 = GetSurfaceProperties(shape2, prop1, true, false);\n\t\tdouble v_sahpe = GetVolumeProperties(shapeV, prop1, true, false);\n\t\tCHECK(s_sahpe == Approx(30.0).margin(1e-12));\n\t\tCHECK(s_sahpe1 == Approx(20.0).margin(1e-12));\n\t\tCHECK(s_sahpe2 == Approx(148.0).margin(1e-12));\n\t\tCHECK(v_sahpe == Approx(120.0).margin(1e-12));\n\t\tCHECK( OCCTIO::OCCTTool::Write(box, outdir + \"MakeBox1.brep\"));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API GeneralTransformShape(const TopoShape& s, const GeneralTransformation3& t, bool copy = false)\t @param copy Whether the geometry of the shape is copied\n\t @param t The general transformation\n\t @param s The shape\n\t @brief Transform a shape by a general transformation\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <common/PointT.hpp>\n#include <modeling/MakeSphere.hpp>\n#include <modeling/TransformShape.hpp>\n#include <topomesh/BRepMeshIncrementalMesh.hpp>\n#include <modeling/MakeShapeTool.hpp>\n#include <common/TransformationT.hpp>\n#include <common/CartesianCoordinateSystem.hpp>\n#include <common/GeneralTransformationT.hpp>\n#include <modeling/GeneralTransformShape.hpp>\n#include <geometry/GlobalProperty.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <topology/BRepGlobalProperty.hpp>\n#include <geometry/Geom3BSplineCurve.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <topology/TopoTool.hpp>\n#include <topology/BRepAdaptorCurve3.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"bug1: GeneralTransformShape  \", \"[modeling][GeneralTransformShape][fixbug]\") {\n\tTopoShape s = MakeSphere(1.0);\n\tBRepMeshIncrementalMesh mesher(s, 0.005, true);\n\tMakeShapeTool::EnsureNormalConsistency(s);\n\tGeneralTransformation3 tr;\n\ttr.SetAffinity(Frame3(), 5.0);\n\ts = GeneralTransformShape(s, tr);\n\tCHECK(s.Type() == AMCAX::ShapeType::Solid);\n\tCHECK(s.IsNull() == false);\n\tGlobalProperty prop;\n\tBRepGlobalProperty::VolumeProperties(s, prop);\n\tCHECK(prop.Mass() == Approx(20.934791259).epsilon(1e-11));\n\tPoint3 vP = prop.CenterOfMass();\n#ifndef WIN_CASE\n\tCHECK(vP.X() == Approx(0.0).margin(1e-3));\n\tCHECK(vP.Y() == Approx(0.0).margin(1e-12));\n\tCHECK(vP.Z() == Approx(0.0).margin(1e-12));\n#else\n\tCHECK(vP.X() == Approx(-2.2218808037914858e-04).epsilon(1e-12));\n\tCHECK(vP.Y() == Approx(-1.0782779568197278e-16).epsilon(1e-12));\n\tCHECK(vP.Z() == Approx(-1.6920954211916623e-16).epsilon(1e-12));\n#endif\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API explicit GeneralTransformShape(const GeneralTransformation3& t)\t @param t The general transformation\n\t @brief Construct from a general transformation\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <common/PointT.hpp>\n#include <modeling/MakeSphere.hpp>\n#include <modeling/TransformShape.hpp>\n#include <topomesh/BRepMeshIncrementalMesh.hpp>\n#include <modeling/MakeShapeTool.hpp>\n#include <common/TransformationT.hpp>\n#include <common/CartesianCoordinateSystem.hpp>\n#include <common/GeneralTransformationT.hpp>\n#include <modeling/GeneralTransformShape.hpp>\n#include <geometry/GlobalProperty.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <topology/BRepGlobalProperty.hpp>\n#include <geometry/Geom3BSplineCurve.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <topology/TopoTool.hpp>\n#include <topology/BRepAdaptorCurve3.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"bug1: GeneralTransformShape  \", \"[modeling][GeneralTransformShape][fixbug]\") {\n\tTopoShape s = MakeSphere(1.0);\n\tBRepMeshIncrementalMesh mesher(s, 0.005, true);\n\tMakeShapeTool::EnsureNormalConsistency(s);\n\tGeneralTransformation3 tr;\n\ttr.SetAffinity(Frame3(), 5.0);\n\ts = GeneralTransformShape(s, tr);\n\tCHECK(s.Type() == AMCAX::ShapeType::Solid);\n\tCHECK(s.IsNull() == false);\n\tGlobalProperty prop;\n\tBRepGlobalProperty::VolumeProperties(s, prop);\n\tCHECK(prop.Mass() == Approx(20.934791259).epsilon(1e-11));\n\tPoint3 vP = prop.CenterOfMass();\n#ifndef WIN_CASE\n\tCHECK(vP.X() == Approx(0.0).margin(1e-3));\n\tCHECK(vP.Y() == Approx(0.0).margin(1e-12));\n\tCHECK(vP.Z() == Approx(0.0).margin(1e-12));\n#else\n\tCHECK(vP.X() == Approx(-2.2218808037914858e-04).epsilon(1e-12));\n\tCHECK(vP.Y() == Approx(-1.0782779568197278e-16).epsilon(1e-12));\n\tCHECK(vP.Z() == Approx(-1.6920954211916623e-16).epsilon(1e-12));\n#endif\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAXMeshing_API void Union()\t @brief apply (3)UNION and (4)put result to output mesh.\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelperBase.h>\n#include \"mesh/TriSoup.hpp\"\n#include \"meshModeling/MeshBoolean.hpp\"\n#include \"mesh/io/OBJReader.hpp\"\n#include \"mesh/io/OBJWriter.hpp\"\n#include \"mesh/io/STLReader.hpp\"\n#include \"mesh/io/STLWriter.hpp\"\n#ifdef AMCAXMeshing_Enable_CommonTraits\nusing TriSoupTraits = AMCAX::Meshing::Mesh::TriSoupTraits_Coord;\n#endif\nusing EIAC = AMCAX::Meshing::Geometry::EIAC;\nusing Points = typename TriSoupTraits::Points;\nusing Triangles = typename TriSoupTraits::Triangles;\nusing OBJReader = AMCAX::Meshing::Mesh::OBJReader<TriSoupTraits>;\nusing OBJWriter = AMCAX::Meshing::Mesh::OBJWriter<TriSoupTraits>;\nusing STLReader = AMCAX::Meshing::Mesh::STLReader<TriSoupTraits>;\nusing STLWriter = AMCAX::Meshing::Mesh::STLWriter<TriSoupTraits>;\nusing IOOptions = AMCAX::Meshing::Mesh::IOOptions;\nusing MeshBoolean = AMCAX::Meshing::Boolean::MeshBoolean<EIAC, TriSoupTraits>;\ntemplate <typename Traits>\nstruct SourceFaceInfo\n{\n    using iTriangle = typename Traits::Triangle;\n    using ti_t = std::remove_reference_t<decltype(std::declval<iTriangle>()[0])>;\n    std::vector<std::pair<ti_t, ti_t>> face_ids;\n};\nvoid read_mesh1(const std::string& filename, Points& points,\n    Triangles& triangles, IOOptions& io_options)\n{\n    if (AMCAX::Meshing::ends_with(filename, \".obj\"))\n    {\n        OBJReader reader;\n        reader.read(filename, io_options);\n        points = std::move(reader.m_points);\n        triangles = std::move(reader.m_triangles);\n    }\n    else if (AMCAX::Meshing::ends_with(filename, \".stl\"))\n    {\n        STLReader reader;\n        reader.read(filename, io_options);\n        points = std::move(reader.m_points);\n        triangles = std::move(reader.m_triangles);\n    }\n}\nvoid write_mesh1(const std::string& filename, const Points& points,\n    const Triangles& triangles, IOOptions& io_options)\n{\n    if (AMCAX::Meshing::ends_with(filename, \".obj\"))\n    {\n        OBJWriter writer;\n        writer.m_points = std::move(points);\n        writer.m_triangles = std::move(triangles);\n        writer.write(filename, io_options, 10);\n    }\n    else if (AMCAX::Meshing::ends_with(filename, \".stl\"))\n    {\n        STLWriter writer;\n        writer.m_points = std::move(points);\n        writer.m_triangles = std::move(triangles);\n        writer.write(filename, io_options, 10);\n    }\n};\nTEST_CASE(\"case1: test MeshBoolean_MeshBoolean Algorithm\", \"[meshModeling][MeshBoolean1]\")\n{\n\tOUTPUT_DIRECTORY(MeshBoolean, MeshBoolean);\n    constexpr size_t InputMeshNum = 2;\n    IOOptions io_options;\n    io_options.vertex_has_point = true;\n\tstd::vector<Points>    points(InputMeshNum);\n\tstd::vector<Triangles> triangles(InputMeshNum);\n\tPoints                 result_points;\n\tTriangles              result_triangles;\n    for (int num = 0; num < 5; num++)\n    {\n        read_mesh1(INPUT_PATH_PREFIX\"./meshModeling_data/MeshBoolean_data/bunny1.stl\", points[0], triangles[0], io_options);\n        read_mesh1(INPUT_PATH_PREFIX\"./meshModeling_data/MeshBoolean_data/cow1.stl\", points[1], triangles[1], io_options);\n        std::cout << \"open file\" << std::endl;\n\t\tMeshBoolean boolean(true);\n\t\tboolean.addTriMeshAsInput(points[0], triangles[0]);\n\t\tboolean.addTriMeshAsInput(points[1], triangles[1]);\n\t\tboolean.setTriMeshAsOutput(result_points, result_triangles);\n\t    boolean.computeLabels();\n\t    boolean.Union();\n        const auto& souce_face_infos = boolean.getSourceFaceInfo();\n        std::vector<Points>               res_source_pts(InputMeshNum);\n        std::vector<Triangles>            res_source_tris(InputMeshNum);\n        std::vector<std::vector<uint8_t>> source_face_visited(InputMeshNum);\n        std::vector<std::vector<int>>     v2v(InputMeshNum);\n        for (int m_id = 0; m_id < InputMeshNum; ++m_id)\n        {\n            source_face_visited[m_id].resize(triangles[m_id].size(), false);\n            v2v[m_id].resize(points[m_id].size(), -1);\n        }\n        std::array<int, InputMeshNum> v_off{};\n        for (const auto& face_info : souce_face_infos)\n        {\n            for (const auto& info : face_info.face_ids)\n            {\n                if (!source_face_visited[info.first][info.second])\n                {\n                    const auto& tri = triangles[info.first][info.second];\n                    for (auto fv_id : tri)\n                    {\n                        if (v2v[info.first][fv_id] == -1)\n                        {\n                            res_source_pts[info.first].emplace_back(points[info.first][fv_id]);\n                            v2v[info.first][fv_id] = v_off[info.first];\n                            ++v_off[info.first];\n                        }\n                    }\n                    res_source_tris[info.first].emplace_back(v2v[info.first][tri[0]], v2v[info.first][tri[1]], v2v[info.first][tri[2]]);\n                    source_face_visited[info.first][info.second] = true;\n                }\n            }\n        }\n        for (int m_id = 0; m_id < InputMeshNum; ++m_id)\n        {\n            int res_union_ptsNum, res_union_trisNum, res_source_ptsNum, res_source_trisNum;\n            switch (m_id)\n            {\n            case 0:\n                res_union_ptsNum = result_points.size();\n                res_union_trisNum = result_triangles.size();\n                CHECK(res_union_ptsNum == 13219);\n                CHECK(res_union_trisNum == 26438);\n                res_source_ptsNum = res_source_pts[m_id].size();\n                res_source_trisNum = res_source_tris[m_id].size();\n                CHECK(res_source_ptsNum == 10329);\n                CHECK(res_source_trisNum == 20271);\n                break;\n            case 1:\n                res_source_ptsNum = res_source_pts[m_id].size();\n                res_source_trisNum = res_source_tris[m_id].size();\n                CHECK(res_source_ptsNum == 2276);\n                CHECK(res_source_trisNum == 4363);\n                break;\n            default:\n                break;\n            }\n            make_file_writable(outdir + \"AMCAXMeshing_Union_SourceFace\" + std::to_string(m_id) + \".stl\");\n            write_mesh1(outdir + \"AMCAXMeshing_Union_Face\" + \".stl\", result_points, result_triangles, io_options);\n            write_mesh1(outdir + \"AMCAXMeshing_Union_SourceFace\" + std::to_string(m_id) + \".stl\", res_source_pts[m_id], res_source_tris[m_id], io_options);\n        }\n    }\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAXMeshing_API MeshBoolean(bool         _verbose, unsigned int _thread_num = std::thread::hardware_concurrency(),\n",
      "output": "#include<catch.hpp>\n#include<testHelperBase.h>\n#define AMCAXMeshing_Enable_EigenTraits\n#define AMCAXMeshing_Enable_CommonTraits\n#define AMCAXMeshing_Disable_StandardTraits\n#include \"mesh/TriSoup.hpp\"\n#include \"meshModeling/MeshBoolean.hpp\"\n#include \"mesh/io/OBJReader.hpp\"\n#include \"mesh/io/OBJWriter.hpp\"\n#include \"mesh/io/STLReader.hpp\"\n#include \"mesh/io/STLWriter.hpp\"\n#ifdef AMCAXMeshing_Enable_CommonTraits\nusing TriSoupTraits = AMCAX::Meshing::Mesh::TriSoupTraits_Coord;\n#endif\nusing EIAC = AMCAX::Meshing::Geometry::EIAC;\nusing Points = typename TriSoupTraits::Points;\nusing Triangles = typename TriSoupTraits::Triangles;\nusing OBJReader = AMCAX::Meshing::Mesh::OBJReader<TriSoupTraits>;\nusing OBJWriter = AMCAX::Meshing::Mesh::OBJWriter<TriSoupTraits>;\nusing STLReader = AMCAX::Meshing::Mesh::STLReader<TriSoupTraits>;\nusing STLWriter = AMCAX::Meshing::Mesh::STLWriter<TriSoupTraits>;\nusing IOOptions = AMCAX::Meshing::Mesh::IOOptions;\nusing MeshBoolean = AMCAX::Meshing::Boolean::MeshBoolean<EIAC, TriSoupTraits>;\ntemplate <typename TriIndexT>\nstruct InterSegments\n{\n    using ti_t = TriIndexT;\n    std::vector<ti_t> vertex_ids;\n    bool closed;\n};\nvoid read_mesh2(const std::string& filename, Points& points,\n    Triangles& triangles, IOOptions& io_options)\n{\n    if (AMCAX::Meshing::ends_with(filename, \".obj\"))\n    {\n        OBJReader reader;\n        reader.read(filename, io_options);\n        points = std::move(reader.m_points);\n        triangles = std::move(reader.m_triangles);\n    }\n    else if (AMCAX::Meshing::ends_with(filename, \".stl\"))\n    {\n        STLReader reader;\n        reader.read(filename, io_options);\n        points = std::move(reader.m_points);\n        triangles = std::move(reader.m_triangles);\n    }\n}\nvoid write_mesh2(const std::string& filename, const Points& points,\n    const Triangles& triangles, IOOptions& io_options)\n{\n    if (AMCAX::Meshing::ends_with(filename, \".obj\"))\n    {\n        OBJWriter writer;\n        writer.m_points = std::move(points);\n        writer.m_triangles = std::move(triangles);\n        writer.write(filename, io_options, 10);\n    }\n    else if (AMCAX::Meshing::ends_with(filename, \".stl\"))\n    {\n        STLWriter writer;\n        writer.m_points = std::move(points);\n        writer.m_triangles = std::move(triangles);\n        writer.write(filename, io_options, 10);\n    }\n};\nTEST_CASE(\"bug1: MeshBoolean_InterSegments \", \"[meshModeling][MeshBoolean_InterSegments][bug]\")\n{\n    OUTPUT_DIRECTORY(MeshBoolean, InterSegments_bug);\n    IOOptions io_options;\n    io_options.vertex_has_point = true;\n    Points      points1, points2, points3, points11, points22, points33, result_points, result_points11;\n    Triangles   triangles1, triangles2, triangles3, triangles11, triangles22, triangles33, result_triangles, result_triangles11;\n    read_mesh2(INPUT_PATH_PREFIX\"./meshModeling_data/MeshBoolean_data/cow1.stl\", points1, triangles1, io_options);\n    read_mesh2(INPUT_PATH_PREFIX\"./meshModeling_data/MeshBoolean_data/bunny1.stl\", points2, triangles2, io_options);\n    read_mesh2(INPUT_PATH_PREFIX\"./meshModeling_data/MeshBoolean_data/cow1.stl\", points3, triangles3, io_options);\n    read_mesh2(INPUT_PATH_PREFIX\"./meshModeling_data/MeshBoolean_data/cow1.obj\", points11, triangles11, io_options);\n    read_mesh2(INPUT_PATH_PREFIX\"./meshModeling_data/MeshBoolean_data/bunny1.obj\", points22, triangles22, io_options);\n    read_mesh2(INPUT_PATH_PREFIX\"./meshModeling_data/MeshBoolean_data/cow1.obj\", points33, triangles33, io_options);\n    MeshBoolean boolean(true);\n    MeshBoolean boolean11(true);\n    boolean.addTriMeshAsInput(points1, triangles1);\n    boolean.addTriMeshAsInput(points2, triangles2);\n    boolean.addTriMeshAsInput(points3, triangles3);\n    boolean.setTriMeshAsOutput(result_points, result_triangles);\n    boolean.computeLabels();\n    boolean.computeInterSegments();\n    boolean.Subtraction();\n    boolean11.addTriMeshAsInput(points11, triangles11);\n    boolean11.addTriMeshAsInput(points22, triangles22);\n    boolean11.addTriMeshAsInput(points33, triangles33);\n    boolean11.setTriMeshAsOutput(result_points11, result_triangles11);\n    boolean11.computeLabels();\n    boolean11.computeInterSegments();\n    boolean11.Subtraction();\n    const auto& inter_segs = boolean.getInterSegments();\n    const auto& inter_segs11 = boolean11.getInterSegments();\n    for (size_t s_id = 0; s_id < inter_segs.size(); ++s_id)\n    {\n        std::ofstream ofs(outdir + \"stl_\"+std::to_string(s_id) + \".obj\");\n        size_t v_num = inter_segs[s_id].vertex_ids.size();\n        ofs << \"# v_num: \" << v_num << std::endl;\n        size_t l_num = inter_segs[s_id].closed ? inter_segs[s_id].vertex_ids.size() : inter_segs[s_id].vertex_ids.size() - 1;\n        ofs << \"# l_num: \" << l_num << std::endl;\n        ofs << std::endl;\n        for (auto v_id : inter_segs[s_id].vertex_ids)\n        {\n            ofs << \"v \" << result_points[v_id].x() << \" \" << result_points[v_id].y() << \" \" << result_points[v_id].z() << std::endl;\n        }\n        ofs << std::endl;\n        for (size_t i = 0; i < inter_segs[s_id].vertex_ids.size() - 1; ++i)\n        {\n            ofs << \"l \" << i + 1 << \" \" << i + 2 << std::endl;\n        }\n        if (inter_segs[s_id].closed)\n        {\n            ofs << \"l \" << inter_segs[s_id].vertex_ids.size() << \" \" << 1 << std::endl;\n        }\n        ofs.close();\n        write_mesh2(outdir + \"InterSubtraction.stl\", result_points, result_triangles, io_options);\n    }\n    for (size_t s_id = 0; s_id < inter_segs11.size(); ++s_id)\n    {\n        std::ofstream ofs(outdir + \"obj_\"+std::to_string(s_id) + \".obj\");\n        size_t v_num = inter_segs11[s_id].vertex_ids.size();\n        ofs << \"# v_num: \" << v_num << std::endl;\n        size_t l_num = inter_segs11[s_id].closed ? inter_segs11[s_id].vertex_ids.size() : inter_segs11[s_id].vertex_ids.size() - 1;\n        ofs << \"# l_num: \" << l_num << std::endl;\n        ofs << std::endl;\n        for (auto v_id : inter_segs11[s_id].vertex_ids)\n        {\n            ofs << \"v \" << result_points11[v_id].x() << \" \" << result_points11[v_id].y() << \" \" << result_points11[v_id].z() << std::endl;\n        }\n        ofs << std::endl;\n        for (size_t i = 0; i < inter_segs11[s_id].vertex_ids.size() - 1; ++i)\n        {\n            ofs << \"l \" << i + 1 << \" \" << i + 2 << std::endl;\n        }\n        if (inter_segs11[s_id].closed)\n        {\n            ofs << \"l \" << inter_segs11[s_id].vertex_ids.size() << \" \" << 1 << std::endl;\n        }\n        ofs.close();\n        write_mesh2(outdir + \"InterSubtraction.obj\", result_points11, result_triangles11, io_options);\n    }\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAXMeshing_API void Union()\t @brief apply (3)UNION and (4)put result to output mesh.\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelperBase.h>\n#define AMCAXMeshing_Enable_CommonTraits\n#define AMCAXMeshing_Disable_StandardTraits\n#define AMCAXMeshing_Enable_EigenTraits\n#include \"mesh/io/OBJReader.hpp\"\n#include \"mesh/io/OBJWriter.hpp\"\n#include \"mesh/io/STLReader.hpp\"\n#include \"mesh/io/STLWriter.hpp\"\n#include \"meshModeling/MeshBoolean.hpp\"\n#include \"meshModeling/TriMeshRepair.hpp\"\n#include \"meshModeling/MeshParameterization.hpp\"\nusing EIAC = AMCAX::Meshing::Geometry::EIAC;\nusing TriSoupTraits = AMCAX::Meshing::Mesh::TriSoupTraits_Coord;\nusing Points = typename TriSoupTraits::Points;\nusing Triangles = typename TriSoupTraits::Triangles;\nusing OBJReader = AMCAX::Meshing::Mesh::OBJReader<TriSoupTraits>;\nusing OBJWriter = AMCAX::Meshing::Mesh::OBJWriter<TriSoupTraits>;\nusing STLReader = AMCAX::Meshing::Mesh::STLReader<TriSoupTraits>;\nusing STLWriter = AMCAX::Meshing::Mesh::STLWriter<TriSoupTraits>;\nusing IOOptions = AMCAX::Meshing::Mesh::IOOptions;\nusing MeshBoolean = AMCAX::Meshing::Boolean::MeshBoolean<EIAC, TriSoupTraits>;\nvoid read_mesh11(const std::string& filename, Points& points,Triangles& triangles, IOOptions& io_options)\n{\n\tif (AMCAX::Meshing::ends_with(filename, \".obj\"))\n\t{\n\t\tOBJReader reader;\n\t\treader.read(filename, io_options);\n\t\tpoints = std::move(reader.m_points);\n\t\ttriangles = std::move(reader.m_triangles);\n\t}\n\telse if (AMCAX::Meshing::ends_with(filename, \".stl\"))\n\t{\n\t\tSTLReader reader;\n\t\treader.read(filename, io_options);\n\t\tpoints = std::move(reader.m_points);\n\t\ttriangles = std::move(reader.m_triangles);\n\t}\n}\nvoid write_mesh11(const std::string& filename, const Points& points,const Triangles& triangles, IOOptions& io_options)\n{\n\tOBJWriter writer;\n\twriter.m_points = std::move(points);\n\twriter.m_triangles = std::move(triangles);\n\tbool bWriteObj = writer.write(filename, io_options, 10);\n\tCHECK(bWriteObj == true);\n};\nTEST_CASE(\"case1: MeshBoolean_MeshBoolean  \", \"[meshModeling][MeshBoolean][P1]\")\n{\n\tOUTPUT_DIRECTORY(Boolean, Boolean);\n\tIOOptions io_options;\n\tio_options.vertex_has_point = true;\n\tPoints    points1, points2, result_points;\n\tTriangles triangles1, triangles2, result_triangles;\n\tread_mesh11(INPUT_PATH_PREFIX\"./meshModeling_data/MeshBoolean_data/bunny25k.obj\", points1, triangles1, io_options);\n\tread_mesh11(INPUT_PATH_PREFIX\"./meshModeling_data/MeshBoolean_data/cow.obj\", points2, triangles2, io_options);\n\tMeshBoolean boolean( true);\n\tboolean.addTriMeshAsInput(points1, triangles1);\n\tboolean.addTriMeshAsInput(points2, triangles2);\n\tboolean.setTriMeshAsOutput(result_points, result_triangles);\n\tboolean.computeLabels();\n\t{\n\t\tboolean.Union();\n\t\tmake_file_writable(outdir + \"AMCAXMeshing_Union.obj\");\n\t\twrite_mesh11(outdir + \"AMCAXMeshing_Union.obj\", result_points,\n\t\t\tresult_triangles, io_options);\n\t}\n\t{\n\t\tboolean.Intersection();\n\t\tmake_file_writable(outdir + \"AMCAXMeshing_Intersection.obj\");\n\t\twrite_mesh11(outdir + \"AMCAXMeshing_Intersection.obj\", result_points,\n\t\t\tresult_triangles, io_options);\n\t}\n\t{\n\t\tboolean.Xor();\n\t\tmake_file_writable(outdir + \"AMCAXMeshing_Xor.obj\");\n\t\twrite_mesh11(outdir + \"AMCAXMeshing_Xor.obj\", result_points, result_triangles,\n\t\t\tio_options);\n\t}\n\t{\n\t\tboolean.Subtraction();\n\t\tmake_file_writable(outdir + \"AMCAXMeshing_Subtraction.obj\");\n\t\twrite_mesh11(outdir + \"AMCAXMeshing_Subtraction.obj\", result_points,\n\t\t\tresult_triangles, io_options);\n\t}\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "HyperbolaS& Transform(const TransformationT<double, DIM>& tr)\t @return The reference to self\n\t @param tr The transformation\n\t @brief Transform the hyperbola\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <modeling/MakeFace.hpp>\n#include <common/AxisT.hpp>\n#include <math/HyperbolaT.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <common/VectorT.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <topology/TopoEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <iostream>\nusing namespace AMCAX;\nusing namespace std;\n#include <catch.hpp>\n#include <testHelper.h>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <modeling/MakeFace.hpp>\n#include <common/AxisT.hpp>\n#include <math/HyperbolaT.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <common/VectorT.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <topology/TopoEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <iostream>\nusing namespace AMCAX;\nusing namespace std;\n;\n\tSECTION(\"Transform()\") {\n\t\tVector3 v1(1.0, 1.0, 1.0);\n\t\tTransformation3 trans;\n\t\ttrans.SetTranslation(v1);\n\t\thyperbola3d_fr.Transform(trans);\n\t\tCHECK(hyperbola3d_fr.Location().X() == Approx(1.0));\n\t\tCHECK(hyperbola3d_fr.Location().Y() == Approx(1.0));\n\t\tCHECK(hyperbola3d_fr.Location().Z() == Approx(2.0));\n\t\tCHECK(hyperbola3d_fr.MajorRadius() == Approx(3.0));\n\t\tCHECK(hyperbola3d_fr.MinorRadius() == Approx(4.0));\n\t\tPoint3 point1(4.0, 1.0, 2.0);\n\t\tMakeEdge edge1(hyperbola3d_fr);\n\t\tCHECK(BRepClassificationTools::IsPointInOnEdge(edge1, point1, 0.001) == true);\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "HyperbolaS& Scale(const PointT<double, DIM>& point, double scale)\t @return The reference to self\n\t @param scale The scale value\n\t @param point The scaling center point\n\t @brief Scale the hyperbola by a center point\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <modeling/MakeFace.hpp>\n#include <common/AxisT.hpp>\n#include <math/HyperbolaT.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <common/VectorT.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <topology/TopoEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <iostream>\nusing namespace AMCAX;\nusing namespace std;\n#include <catch.hpp>\n#include <testHelper.h>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <modeling/MakeFace.hpp>\n#include <common/AxisT.hpp>\n#include <math/HyperbolaT.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <common/VectorT.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <topology/TopoEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <iostream>\nusing namespace AMCAX;\nusing namespace std;\n;\n\tSECTION(\"Scale()\") {\t\t\n\t\tPoint3 point1(0.0, 0.0, 1.0);\n\t\thyperbola3d_fr.Scale(point1, 0.5);\n\t\tCHECK(hyperbola3d_fr.Location().X() == Approx(0.0));\n\t\tCHECK(hyperbola3d_fr.Location().Y() == Approx(0.0));\n\t\tCHECK(hyperbola3d_fr.Location().Z() == Approx(1.0));\n\t\tPoint3 point2(1.5, 0.0, 1.0);\n\t\tMakeEdge edge1(hyperbola3d_fr);\n\t\tCHECK(BRepClassificationTools::IsPointInOnEdge(edge1, point2, 0.001) == true);\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] HyperbolaS OtherBranch()\t @return The hyperbola of the other branch\n\t @brief Get the other branch of the hyperbola\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <modeling/MakeFace.hpp>\n#include <common/AxisT.hpp>\n#include <math/HyperbolaT.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <common/VectorT.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <topology/TopoEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <iostream>\nusing namespace AMCAX;\nusing namespace std;\n#include <catch.hpp>\n#include <testHelper.h>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <modeling/MakeFace.hpp>\n#include <common/AxisT.hpp>\n#include <math/HyperbolaT.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <common/VectorT.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <topology/TopoEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <iostream>\nusing namespace AMCAX;\nusing namespace std;\n;\n\tSECTION(\"OtherBranch()\") {\n\t\tHyperbola3 hyperbola3d_fr_ob = hyperbola3d_fr.OtherBranch();\n\t\tPoint3 point3d_m(0.0, 0.0, 0.0);\n\t\tPoint3 point2(-3.0, 0.0, 1.0);\n\t\tMakeEdge edge2(hyperbola3d_fr_ob);\n\t\tCHECK(BRepClassificationTools::IsPointInOnEdge(edge2, point2, 0.001) == true);\n\t\tCHECK(hyperbola3d_fr_ob.MajorRadius() == Approx(3.0));\n\t\tCHECK(hyperbola3d_fr_ob.MinorRadius() == Approx(4.0));\n\t\tCHECK(hyperbola3d_fr_ob.Location().X() == Approx(0.0));\n\t\tCHECK(hyperbola3d_fr_ob.Location().Y() == Approx(0.0));\n\t\tCHECK(hyperbola3d_fr_ob.Location().Z() == Approx(1.0));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] HyperbolaS ConjugateBranch2()\t @return The negative conjugate hyperbola\n\t @brief Get the conjugate hyperbola on the negative side of the minor axis\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <modeling/MakeFace.hpp>\n#include <common/AxisT.hpp>\n#include <math/HyperbolaT.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <common/VectorT.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <topology/TopoEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <iostream>\nusing namespace AMCAX;\nusing namespace std;\n#include <catch.hpp>\n#include <testHelper.h>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <modeling/MakeFace.hpp>\n#include <common/AxisT.hpp>\n#include <math/HyperbolaT.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <common/VectorT.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <topology/TopoEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <iostream>\nusing namespace AMCAX;\nusing namespace std;\n;\n\tSECTION(\"ConjugateBranch2()\") {\t\t\n\t\tHyperbola3 hyperbola3d_con = hyperbola3d_fr.ConjugateBranch2();\n\t\tCHECK(hyperbola3d_con.Location().X() == Approx(0.0));\n\t\tCHECK(hyperbola3d_con.Location().Y() == Approx(0.0));\n\t\tCHECK(hyperbola3d_con.Location().Z() == Approx(1.0));\n\t\tPoint3 point1(0.0, -4.0, 1.0);\n\t\tPoint3 point2(9.0 / 4.0, -5.0, 1.0);\n\t\tMakeEdge edge2(hyperbola3d_con);\n\t\tCHECK(BRepClassificationTools::IsPointInOnEdge(edge2, point1, 0.001) == true);\n\t\tCHECK(BRepClassificationTools::IsPointInOnEdge(edge2, point2, 0.001) == true);\n\t\tdouble major3d_con = hyperbola3d_con.MajorRadius();\n\t\tdouble minor3d_con = hyperbola3d_con.MinorRadius();\n\t\tCHECK(major3d_con == Approx(4.0));\n\t\tCHECK(minor3d_con == Approx(3.0));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] HyperbolaS ConjugateBranch1()\t @return The positive conjugate hyperbola\n\t @brief Get the conjugate hyperbola on the positive side of the minor axis\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <modeling/MakeFace.hpp>\n#include <common/AxisT.hpp>\n#include <math/HyperbolaT.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <common/VectorT.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <topology/TopoEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <iostream>\nusing namespace AMCAX;\nusing namespace std;\n#include <catch.hpp>\n#include <testHelper.h>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <modeling/MakeFace.hpp>\n#include <common/AxisT.hpp>\n#include <math/HyperbolaT.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <common/VectorT.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <topology/TopoEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <iostream>\nusing namespace AMCAX;\nusing namespace std;\n;\n\tSECTION(\"ConjugateBranch1()\") {\n\t\tHyperbola3 hyperbola3d_con = hyperbola3d_fr.ConjugateBranch1();\n\t\tCHECK(hyperbola3d_con.Location().X() == Approx(0.0));\n\t\tCHECK(hyperbola3d_con.Location().Y() == Approx(0.0));\n\t\tCHECK(hyperbola3d_con.Location().Z() == Approx(1.0));\n\t\tPoint3 point1(0.0, 4.0, 1.0);\n\t\tPoint3 point2(9.0 / 4.0, 5.0, 1.0);\n\t\tMakeEdge edge1(hyperbola3d_con);\n\t\tCHECK(BRepClassificationTools::IsPointInOnEdge(edge1, point1, 0.001) == true);\n\t\tCHECK(BRepClassificationTools::IsPointInOnEdge(edge1, point2, 0.001) == true);\n\t\tdouble major3d_con = hyperbola3d_con.MajorRadius();\n\t\tdouble minor3d_con = hyperbola3d_con.MinorRadius();\n\t\tCHECK(major3d_con == Approx(4.0));\n\t\tCHECK(minor3d_con == Approx(3.0));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] AxisT<double, DIM> Asymptote2()\t @return The negative asymptote\n\t @brief Get the asymptote of the hyperbola with negative slope\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <modeling/MakeFace.hpp>\n#include <common/AxisT.hpp>\n#include <math/HyperbolaT.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <common/VectorT.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <topology/TopoEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <iostream>\nusing namespace AMCAX;\nusing namespace std;\n#include <catch.hpp>\n#include <testHelper.h>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <modeling/MakeFace.hpp>\n#include <common/AxisT.hpp>\n#include <math/HyperbolaT.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <common/VectorT.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <topology/TopoEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <iostream>\nusing namespace AMCAX;\nusing namespace std;\n;\n\tSECTION(\"Asymptote2()\") {\n\t\tAxis3 axis3d_asy = hyperbola3d_fr.Asymptote2();\n\t\tCHECK(axis3d_asy.Direction().X() / axis3d_asy.Direction().Y() == Approx(-3.0 / 4.0));\n\t\tCHECK(axis3d_asy.Direction().Z() == Approx(0.0));\n\t\tPoint3 point1(0.0, 0.0, 1.0);\n\t\tLine3 line3d_asy(axis3d_asy);\n\t\tMakeEdge edge1(line3d_asy);\n\t\tCHECK(BRepClassificationTools::IsPointInOnEdge(edge1, point1, 0.001) == true);\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] AxisT<double, DIM> Asymptote1()\t @return The positive asymptote\n\t @brief Get the asymptote of the hyperbola with positive slope\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <modeling/MakeFace.hpp>\n#include <common/AxisT.hpp>\n#include <math/HyperbolaT.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <common/VectorT.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <topology/TopoEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <iostream>\nusing namespace AMCAX;\nusing namespace std;\n#include <catch.hpp>\n#include <testHelper.h>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <modeling/MakeFace.hpp>\n#include <common/AxisT.hpp>\n#include <math/HyperbolaT.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <common/VectorT.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <topology/TopoEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <iostream>\nusing namespace AMCAX;\nusing namespace std;\n;\n\tSECTION(\"Asymptote1()\") {\n\t\tAxis3 axis3d_asy = hyperbola3d_fr.Asymptote1();\n\t\tCHECK(axis3d_asy.Direction().X() / axis3d_asy.Direction().Y() == Approx(3.0 / 4.0));\n\t\tCHECK(axis3d_asy.Direction().Z() == Approx(0.0));\n\t\tPoint3 point1(0.0, 0.0, 1.0);\n\t\tLine3 line3d_asy(axis3d_asy);\n\t\tMakeEdge edge1(line3d_asy);\n\t\tCHECK(BRepClassificationTools::IsPointInOnEdge(edge1, point1, 0.001) == true);\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] double MinorRadius()\t @return The minor radius\n\t @brief Get the minor radius\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <modeling/MakeFace.hpp>\n#include <common/AxisT.hpp>\n#include <math/HyperbolaT.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <common/VectorT.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <topology/TopoEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <iostream>\nusing namespace AMCAX;\nusing namespace std;\n#include <catch.hpp>\n#include <testHelper.h>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <modeling/MakeFace.hpp>\n#include <common/AxisT.hpp>\n#include <math/HyperbolaT.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <common/VectorT.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <topology/TopoEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <iostream>\nusing namespace AMCAX;\nusing namespace std;\n;\n\tSECTION(\"ConjugateBranch1()\") {\n\t\tHyperbola3 hyperbola3d_con = hyperbola3d_fr.ConjugateBranch1();\n\t\tCHECK(hyperbola3d_con.Location().X() == Approx(0.0));\n\t\tCHECK(hyperbola3d_con.Location().Y() == Approx(0.0));\n\t\tCHECK(hyperbola3d_con.Location().Z() == Approx(1.0));\n\t\tPoint3 point1(0.0, 4.0, 1.0);\n\t\tPoint3 point2(9.0 / 4.0, 5.0, 1.0);\n\t\tMakeEdge edge1(hyperbola3d_con);\n\t\tCHECK(BRepClassificationTools::IsPointInOnEdge(edge1, point1, 0.001) == true);\n\t\tCHECK(BRepClassificationTools::IsPointInOnEdge(edge1, point2, 0.001) == true);\n\t\tdouble major3d_con = hyperbola3d_con.MajorRadius();\n\t\tdouble minor3d_con = hyperbola3d_con.MinorRadius();\n\t\tCHECK(major3d_con == Approx(4.0));\n\t\tCHECK(minor3d_con == Approx(3.0));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] double MajorRadius()\t @return The major radius\n\t @brief Get the major radius\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <modeling/MakeFace.hpp>\n#include <common/AxisT.hpp>\n#include <math/HyperbolaT.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <common/VectorT.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <topology/TopoEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <iostream>\nusing namespace AMCAX;\nusing namespace std;\n#include <catch.hpp>\n#include <testHelper.h>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <modeling/MakeFace.hpp>\n#include <common/AxisT.hpp>\n#include <math/HyperbolaT.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <common/VectorT.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <topology/TopoEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <iostream>\nusing namespace AMCAX;\nusing namespace std;\n;\n\tSECTION(\"Default()\") {\n\t\tHyperbola3 hyperbola3d_de;\t\n\t\tCHECK(hyperbola3d_de.Location().X() == Approx(0.0));\n\t\tCHECK(hyperbola3d_de.Location().Y() == Approx(0.0));\n\t\tCHECK(hyperbola3d_de.Location().Z() == Approx(0.0));\n\t\thyperbola3d_de.SetMajorRadius(3.0);\n\t\thyperbola3d_de.SetMinorRadius(4.0);\n\t\tCHECK(hyperbola3d_de.MajorRadius() == Approx(3.0));\n\t\tCHECK(hyperbola3d_de.MinorRadius() == Approx(4.0));\n\t\tCHECK(hyperbola3d_de.Focal() == Approx(10.0));\n\t\tCHECK(hyperbola3d_de.Focus1().X() == Approx(5.0));\n\t\tCHECK(hyperbola3d_de.Focus1().Y() == Approx(0.0));\n\t\tCHECK(hyperbola3d_de.Focus1().Z() == Approx(0.0));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] PointT<double, DIM> Focus2()\t @return The negative focus\n\t @brief Get the focus on the negative side of the major axis\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <modeling/MakeFace.hpp>\n#include <common/AxisT.hpp>\n#include <math/HyperbolaT.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <common/VectorT.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <topology/TopoEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <iostream>\nusing namespace AMCAX;\nusing namespace std;\n#include <catch.hpp>\n#include <testHelper.h>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <modeling/MakeFace.hpp>\n#include <common/AxisT.hpp>\n#include <math/HyperbolaT.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <common/VectorT.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <topology/TopoEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <iostream>\nusing namespace AMCAX;\nusing namespace std;\n;\n\tSECTION(\"Focus2\") {\n\t\tPoint3 point3d_f1 = hyperbola3d_fr.Focus2();\n\t\tCHECK(point3d_f1.X() == Approx(-5.0));\n\t\tCHECK(point3d_f1.Y() == Approx(0.0));\n\t\tCHECK(point3d_f1.Z() == Approx(1.0));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] PointT<double, DIM> Focus1()\t @return The positive focus\n\t @brief Get the focus on the positive side of the major axis\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <modeling/MakeFace.hpp>\n#include <common/AxisT.hpp>\n#include <math/HyperbolaT.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <common/VectorT.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <topology/TopoEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <iostream>\nusing namespace AMCAX;\nusing namespace std;\n#include <catch.hpp>\n#include <testHelper.h>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <modeling/MakeFace.hpp>\n#include <common/AxisT.hpp>\n#include <math/HyperbolaT.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <common/VectorT.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <topology/TopoEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <iostream>\nusing namespace AMCAX;\nusing namespace std;\n;\n\tSECTION(\"Default()\") {\n\t\tHyperbola3 hyperbola3d_de;\t\n\t\tCHECK(hyperbola3d_de.Location().X() == Approx(0.0));\n\t\tCHECK(hyperbola3d_de.Location().Y() == Approx(0.0));\n\t\tCHECK(hyperbola3d_de.Location().Z() == Approx(0.0));\n\t\thyperbola3d_de.SetMajorRadius(3.0);\n\t\thyperbola3d_de.SetMinorRadius(4.0);\n\t\tCHECK(hyperbola3d_de.MajorRadius() == Approx(3.0));\n\t\tCHECK(hyperbola3d_de.MinorRadius() == Approx(4.0));\n\t\tCHECK(hyperbola3d_de.Focal() == Approx(10.0));\n\t\tCHECK(hyperbola3d_de.Focus1().X() == Approx(5.0));\n\t\tCHECK(hyperbola3d_de.Focus1().Y() == Approx(0.0));\n\t\tCHECK(hyperbola3d_de.Focus1().Z() == Approx(0.0));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] double Eccentricity()\t @return The eccentricity\n\t @brief Get the eccentricity of the ellipse\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <modeling/MakeFace.hpp>\n#include <common/AxisT.hpp>\n#include <math/HyperbolaT.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <common/VectorT.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <topology/TopoEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <iostream>\nusing namespace AMCAX;\nusing namespace std;\n#include <catch.hpp>\n#include <testHelper.h>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <modeling/MakeFace.hpp>\n#include <common/AxisT.hpp>\n#include <math/HyperbolaT.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <common/VectorT.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <topology/TopoEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <iostream>\nusing namespace AMCAX;\nusing namespace std;\n;\n\tSECTION(\"Eccentricity()\") {\n\t\tdouble e = hyperbola3d_fr.Eccentricity();\n\t\tCHECK(e == Approx(5.0 / 3.0));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] AxisT<double, DIM> Directrix2()\t @return The negative directrix\n\t @brief Get the directrix on the negative side of the major axis\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <modeling/MakeFace.hpp>\n#include <common/AxisT.hpp>\n#include <math/HyperbolaT.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <common/VectorT.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <topology/TopoEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <iostream>\nusing namespace AMCAX;\nusing namespace std;\n#include <catch.hpp>\n#include <testHelper.h>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <modeling/MakeFace.hpp>\n#include <common/AxisT.hpp>\n#include <math/HyperbolaT.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <common/VectorT.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <topology/TopoEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <iostream>\nusing namespace AMCAX;\nusing namespace std;\n;\n\tSECTION(\"Directrix2()\") {\n\t\tAxis3 axis3d_dir = hyperbola3d_fr.Directrix2();\n\t\tCHECK(axis3d_dir.Direction().X() == Approx(0.0));\n\t\tCHECK(axis3d_dir.Direction().Y() == Approx(1.0));\n\t\tCHECK(axis3d_dir.Direction().Z() == Approx(0.0));\n\t\tCHECK(axis3d_dir.Location().X() == Approx(-9.0 / 5.0));\n\t\tCHECK(axis3d_dir.Location().Y() == Approx(0.0));\n\t\tCHECK(axis3d_dir.Location().Z() == Approx(1.0));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] AxisT<double, DIM> Directrix1()\t @return The positive directrix\n\t @brief Get the directrix on the positive side of the major axis\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <modeling/MakeFace.hpp>\n#include <common/AxisT.hpp>\n#include <math/HyperbolaT.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <common/VectorT.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <topology/TopoEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <iostream>\nusing namespace AMCAX;\nusing namespace std;\n#include <catch.hpp>\n#include <testHelper.h>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <modeling/MakeFace.hpp>\n#include <common/AxisT.hpp>\n#include <math/HyperbolaT.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <common/VectorT.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <topology/TopoEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <iostream>\nusing namespace AMCAX;\nusing namespace std;\n;\n\tSECTION(\"Directrix1()\") {\n\t\tAxis3 axis3d_dir = hyperbola3d_fr.Directrix1();\n\t\tCHECK(axis3d_dir.Direction().X() == Approx(0.0));\n\t\tCHECK(axis3d_dir.Direction().Y() == Approx(1.0));\n\t\tCHECK(axis3d_dir.Direction().Z() == Approx(0.0));\n\t\tCHECK(axis3d_dir.Location().X() == Approx(9.0 / 5.0));\n\t\tCHECK(axis3d_dir.Location().Y() == Approx(0.0));\n\t\tCHECK(axis3d_dir.Location().Z() == Approx(1.0));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "void SetMinorRadius(double r)\t @param r The new minor radius\n\t @brief Set the minor radius\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <modeling/MakeFace.hpp>\n#include <common/AxisT.hpp>\n#include <math/HyperbolaT.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <common/VectorT.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <topology/TopoEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <iostream>\nusing namespace AMCAX;\nusing namespace std;\n#include <catch.hpp>\n#include <testHelper.h>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <modeling/MakeFace.hpp>\n#include <common/AxisT.hpp>\n#include <math/HyperbolaT.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <common/VectorT.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <topology/TopoEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <iostream>\nusing namespace AMCAX;\nusing namespace std;\n;\n\tSECTION(\"Default()\") {\n\t\tHyperbola3 hyperbola3d_de;\t\n\t\tCHECK(hyperbola3d_de.Location().X() == Approx(0.0));\n\t\tCHECK(hyperbola3d_de.Location().Y() == Approx(0.0));\n\t\tCHECK(hyperbola3d_de.Location().Z() == Approx(0.0));\n\t\thyperbola3d_de.SetMajorRadius(3.0);\n\t\thyperbola3d_de.SetMinorRadius(4.0);\n\t\tCHECK(hyperbola3d_de.MajorRadius() == Approx(3.0));\n\t\tCHECK(hyperbola3d_de.MinorRadius() == Approx(4.0));\n\t\tCHECK(hyperbola3d_de.Focal() == Approx(10.0));\n\t\tCHECK(hyperbola3d_de.Focus1().X() == Approx(5.0));\n\t\tCHECK(hyperbola3d_de.Focus1().Y() == Approx(0.0));\n\t\tCHECK(hyperbola3d_de.Focus1().Z() == Approx(0.0));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "void SetMajorRadius(double r)\t @param r The new major radius\n\t @brief Set the major radius\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <modeling/MakeFace.hpp>\n#include <common/AxisT.hpp>\n#include <math/HyperbolaT.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <common/VectorT.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <topology/TopoEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <iostream>\nusing namespace AMCAX;\nusing namespace std;\n#include <catch.hpp>\n#include <testHelper.h>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <modeling/MakeFace.hpp>\n#include <common/AxisT.hpp>\n#include <math/HyperbolaT.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <common/VectorT.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <topology/TopoEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <iostream>\nusing namespace AMCAX;\nusing namespace std;\n;\n\tSECTION(\"Default()\") {\n\t\tHyperbola3 hyperbola3d_de;\t\n\t\tCHECK(hyperbola3d_de.Location().X() == Approx(0.0));\n\t\tCHECK(hyperbola3d_de.Location().Y() == Approx(0.0));\n\t\tCHECK(hyperbola3d_de.Location().Z() == Approx(0.0));\n\t\thyperbola3d_de.SetMajorRadius(3.0);\n\t\thyperbola3d_de.SetMinorRadius(4.0);\n\t\tCHECK(hyperbola3d_de.MajorRadius() == Approx(3.0));\n\t\tCHECK(hyperbola3d_de.MinorRadius() == Approx(4.0));\n\t\tCHECK(hyperbola3d_de.Focal() == Approx(10.0));\n\t\tCHECK(hyperbola3d_de.Focus1().X() == Approx(5.0));\n\t\tCHECK(hyperbola3d_de.Focus1().Y() == Approx(0.0));\n\t\tCHECK(hyperbola3d_de.Focus1().Z() == Approx(0.0));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "HyperbolaS& Transform(const TransformationT<double, DIM>& tr)\t @return The reference to self\n\t @param tr The transformation\n\t @brief Transform the hyperbola\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <modeling/MakeFace.hpp>\n#include <common/AxisT.hpp>\n#include <math/HyperbolaT.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <common/VectorT.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <topology/TopoEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <common/TransformationT.hpp>\n#include <iostream>\nusing namespace AMCAX;\nusing namespace std;\n#include <catch.hpp>\n#include <testHelper.h>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <modeling/MakeFace.hpp>\n#include <common/AxisT.hpp>\n#include <math/HyperbolaT.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <common/VectorT.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <topology/TopoEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <common/TransformationT.hpp>\n#include <iostream>\nusing namespace AMCAX;\nusing namespace std;\n;\n\tSECTION(\"Transform()\") {\n\t\tVector2 v1(1.0, 1.0);\n\t\tTransformation2 trans;\n\t\ttrans.SetTranslation(v1);\n\t\thyperbola2d_ax.Transform(trans);\n\t\tCHECK(hyperbola2d_ax.Location().X() == Approx(1.0));\n\t\tCHECK(hyperbola2d_ax.Location().Y() == Approx(1.0));\n\t\tCHECK(hyperbola2d_ax.MajorRadius() == Approx(3.0));\n\t\tCHECK(hyperbola2d_ax.MinorRadius() == Approx(4.0));\n\t\tPoint3 point2(4.0, 1.0, 0.0);\n\t\tMakeEdge2d edge1(hyperbola2d_ax);\n\t\tCHECK(BRepClassificationTools::IsPointInOnEdge(edge1, point2, 0.001) == true);\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "HyperbolaS& Scale(const PointT<double, DIM>& point, double scale)\t @return The reference to self\n\t @param scale The scale value\n\t @param point The scaling center point\n\t @brief Scale the hyperbola by a center point\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <modeling/MakeFace.hpp>\n#include <common/AxisT.hpp>\n#include <math/HyperbolaT.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <common/VectorT.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <topology/TopoEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <common/TransformationT.hpp>\n#include <iostream>\nusing namespace AMCAX;\nusing namespace std;\n#include <catch.hpp>\n#include <testHelper.h>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <modeling/MakeFace.hpp>\n#include <common/AxisT.hpp>\n#include <math/HyperbolaT.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <common/VectorT.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <topology/TopoEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <common/TransformationT.hpp>\n#include <iostream>\nusing namespace AMCAX;\nusing namespace std;\n;\n\tSECTION(\"Scale()\") {\t\t\n\t\tPoint2 point1(0.0, 0.0);\n\t\thyperbola2d_ax.Scale(point1, 0.5);\n\t\tCHECK(hyperbola2d_ax.Location().X() == Approx(0.0));\n\t\tCHECK(hyperbola2d_ax.Location().Y() == Approx(0.0));\n\t\tPoint3 point3(1.5, 0.0, 0.0);\n\t\tMakeEdge2d edge1(hyperbola2d_ax);\t\n\t\tCHECK(BRepClassificationTools::IsPointInOnEdge(edge1, point3, 0.001) == true);\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] HyperbolaS OtherBranch()\t @return The hyperbola of the other branch\n\t @brief Get the other branch of the hyperbola\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <modeling/MakeFace.hpp>\n#include <common/AxisT.hpp>\n#include <math/HyperbolaT.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <common/VectorT.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <topology/TopoEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <common/TransformationT.hpp>\n#include <iostream>\nusing namespace AMCAX;\nusing namespace std;\n#include <catch.hpp>\n#include <testHelper.h>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <modeling/MakeFace.hpp>\n#include <common/AxisT.hpp>\n#include <math/HyperbolaT.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <common/VectorT.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <topology/TopoEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <common/TransformationT.hpp>\n#include <iostream>\nusing namespace AMCAX;\nusing namespace std;\n;\n\tSECTION(\"OtherBranch()\") {\n\t\tHyperbola2 hyperbola2d_ax_ob = hyperbola2d_ax.OtherBranch();\n\t\tPoint2 point2d_m(0.0, 0.0);\n\t\tPoint3 point1(-3.0, 0.0, 0.0);\n\t\tMakeEdge2d edge1(hyperbola2d_ax_ob);\n\t\tCHECK(BRepClassificationTools::IsPointInOnEdge(edge1, point1, 0.001) == true);\n\t\tCHECK(hyperbola2d_ax_ob.MajorRadius() == Approx(3.0));\n\t\tCHECK(hyperbola2d_ax_ob.MinorRadius() == Approx(4.0));\n\t\tCHECK(hyperbola2d_ax_ob.Location().X() == Approx(0.0));\n\t\tCHECK(hyperbola2d_ax_ob.Location().Y() == Approx(0.0));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] HyperbolaS ConjugateBranch2()\t @return The negative conjugate hyperbola\n\t @brief Get the conjugate hyperbola on the negative side of the minor axis\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <modeling/MakeFace.hpp>\n#include <common/AxisT.hpp>\n#include <math/HyperbolaT.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <common/VectorT.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <topology/TopoEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <common/TransformationT.hpp>\n#include <iostream>\nusing namespace AMCAX;\nusing namespace std;\n#include <catch.hpp>\n#include <testHelper.h>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <modeling/MakeFace.hpp>\n#include <common/AxisT.hpp>\n#include <math/HyperbolaT.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <common/VectorT.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <topology/TopoEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <common/TransformationT.hpp>\n#include <iostream>\nusing namespace AMCAX;\nusing namespace std;\n;\n\tSECTION(\"ConjugateBranch2()\") {\n\t\tPoint3 point1(0.0, -4.0, 0.0);\n\t\tPoint3 point2(9.0 / 4.0, -5.0, 0.0);\n\t\tHyperbola2 hyperbola2d_con = hyperbola2d_ax.ConjugateBranch2();\n\t\tMakeEdge2d edge1(hyperbola2d_con);\n\t\tCHECK(BRepClassificationTools::IsPointInOnEdge(edge1, point1, 0.001) == true);\n\t\tCHECK(BRepClassificationTools::IsPointInOnEdge(edge1, point2, 0.001) == true);\n\t\tdouble major2d_con = hyperbola2d_con.MajorRadius();\n\t\tdouble minor2d_con = hyperbola2d_con.MinorRadius();\n\t\tCHECK(major2d_con == Approx(4.0));\n\t\tCHECK(minor2d_con == Approx(3.0));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] HyperbolaS ConjugateBranch1()\t @return The positive conjugate hyperbola\n\t @brief Get the conjugate hyperbola on the positive side of the minor axis\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <modeling/MakeFace.hpp>\n#include <common/AxisT.hpp>\n#include <math/HyperbolaT.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <common/VectorT.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <topology/TopoEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <common/TransformationT.hpp>\n#include <iostream>\nusing namespace AMCAX;\nusing namespace std;\n#include <catch.hpp>\n#include <testHelper.h>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <modeling/MakeFace.hpp>\n#include <common/AxisT.hpp>\n#include <math/HyperbolaT.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <common/VectorT.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <topology/TopoEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <common/TransformationT.hpp>\n#include <iostream>\nusing namespace AMCAX;\nusing namespace std;\n;\n\tSECTION(\"ConjugateBranch1()\") {\n\t\tPoint3 point1(0.0, 4.0, 0.0);\n\t\tPoint3 point2(9.0 / 4.0, 5.0, 0.0);\n\t\tHyperbola2 hyperbola2d_con = hyperbola2d_ax.ConjugateBranch1();\n\t\tMakeEdge2d edge1(hyperbola2d_con);\n\t\tCHECK(BRepClassificationTools::IsPointInOnEdge(edge1, point1, 0.001) == true);\n\t\tCHECK(BRepClassificationTools::IsPointInOnEdge(edge1, point2, 0.001) == true);\n\t\tdouble major2d_con = hyperbola2d_con.MajorRadius();\n\t\tdouble minor2d_con = hyperbola2d_con.MinorRadius();\n\t\tCHECK( major2d_con== Approx(4.0));\n\t\tCHECK(minor2d_con == Approx(3.0));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] AxisT<double, DIM> Asymptote2()\t @return The negative asymptote\n\t @brief Get the asymptote of the hyperbola with negative slope\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <modeling/MakeFace.hpp>\n#include <common/AxisT.hpp>\n#include <math/HyperbolaT.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <common/VectorT.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <topology/TopoEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <common/TransformationT.hpp>\n#include <iostream>\nusing namespace AMCAX;\nusing namespace std;\n#include <catch.hpp>\n#include <testHelper.h>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <modeling/MakeFace.hpp>\n#include <common/AxisT.hpp>\n#include <math/HyperbolaT.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <common/VectorT.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <topology/TopoEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <common/TransformationT.hpp>\n#include <iostream>\nusing namespace AMCAX;\nusing namespace std;\n;\n\tSECTION(\"Asymptote2()\") {\t\n\t\tAxis2 axis2d_asy = hyperbola2d_ax.Asymptote2();\n\t\tCHECK(axis2d_asy.Direction().X() / axis2d_asy.Direction().Y() == Approx(-3.0 / 4.0));\n\t\tPoint3 point1(0.0, 0.0, 0.0);\n\t\tLine2 line2d_asy(axis2d_asy);\n\t\tMakeEdge2d edge1(line2d_asy);\n\t\tCHECK(BRepClassificationTools::IsPointInOnEdge(edge1, point1, 0.001) == true);\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] AxisT<double, DIM> Asymptote1()\t @return The positive asymptote\n\t @brief Get the asymptote of the hyperbola with positive slope\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <modeling/MakeFace.hpp>\n#include <common/AxisT.hpp>\n#include <math/HyperbolaT.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <common/VectorT.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <topology/TopoEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <common/TransformationT.hpp>\n#include <iostream>\nusing namespace AMCAX;\nusing namespace std;\n#include <catch.hpp>\n#include <testHelper.h>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <modeling/MakeFace.hpp>\n#include <common/AxisT.hpp>\n#include <math/HyperbolaT.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <common/VectorT.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <topology/TopoEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <common/TransformationT.hpp>\n#include <iostream>\nusing namespace AMCAX;\nusing namespace std;\n;\n\tSECTION(\"Asymptote1()\") {\n\t\tAxis2 axis2d_asy = hyperbola2d_ax.Asymptote1();\n\t\tCHECK(axis2d_asy.Direction().X()/ axis2d_asy.Direction().Y() == Approx(3.0/4.0));\n\t\tPoint3 point1(0.0, 0.0, 0.0);\n\t\tLine2 line2d_asy(axis2d_asy);\n\t\tMakeEdge2d edge1(line2d_asy);\n\t\tCHECK(BRepClassificationTools::IsPointInOnEdge(edge1, point1, 0.001) == true);\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] double MinorRadius()\t @return The minor radius\n\t @brief Get the minor radius\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <modeling/MakeFace.hpp>\n#include <common/AxisT.hpp>\n#include <math/HyperbolaT.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <common/VectorT.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <topology/TopoEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <common/TransformationT.hpp>\n#include <iostream>\nusing namespace AMCAX;\nusing namespace std;\n#include <catch.hpp>\n#include <testHelper.h>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <modeling/MakeFace.hpp>\n#include <common/AxisT.hpp>\n#include <math/HyperbolaT.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <common/VectorT.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <topology/TopoEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <common/TransformationT.hpp>\n#include <iostream>\nusing namespace AMCAX;\nusing namespace std;\n;\n\tSECTION(\"Default()\") {\n\t\tHyperbola2 hyperbola2d_de;\t\n\t\tCHECK(hyperbola2d_de.Location().X() == Approx(0.0));\n\t\tCHECK(hyperbola2d_de.Location().Y() == Approx(0.0));\n\t\thyperbola2d_de.SetMajorRadius(3.0);\n\t\thyperbola2d_de.SetMinorRadius(4.0);\n\t\tCHECK(hyperbola2d_de.MajorRadius() == Approx(3.0));\n\t\tCHECK(hyperbola2d_de.MinorRadius() == Approx(4.0));\n\t\tCHECK(hyperbola2d_de.Focal() == Approx(10.0));\n\t\tCHECK(hyperbola2d_de.Focus1().X() == Approx(5.0));\n\t\tCHECK(hyperbola2d_de.Focus1().Y() == Approx(0.0));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] double MajorRadius()\t @return The major radius\n\t @brief Get the major radius\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <modeling/MakeFace.hpp>\n#include <common/AxisT.hpp>\n#include <math/HyperbolaT.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <common/VectorT.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <topology/TopoEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <common/TransformationT.hpp>\n#include <iostream>\nusing namespace AMCAX;\nusing namespace std;\n#include <catch.hpp>\n#include <testHelper.h>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <modeling/MakeFace.hpp>\n#include <common/AxisT.hpp>\n#include <math/HyperbolaT.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <common/VectorT.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <topology/TopoEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <common/TransformationT.hpp>\n#include <iostream>\nusing namespace AMCAX;\nusing namespace std;\n;\n\tSECTION(\"ConjugateBranch1()\") {\n\t\tPoint3 point1(0.0, 4.0, 0.0);\n\t\tPoint3 point2(9.0 / 4.0, 5.0, 0.0);\n\t\tHyperbola2 hyperbola2d_con = hyperbola2d_ax.ConjugateBranch1();\n\t\tMakeEdge2d edge1(hyperbola2d_con);\n\t\tCHECK(BRepClassificationTools::IsPointInOnEdge(edge1, point1, 0.001) == true);\n\t\tCHECK(BRepClassificationTools::IsPointInOnEdge(edge1, point2, 0.001) == true);\n\t\tdouble major2d_con = hyperbola2d_con.MajorRadius();\n\t\tdouble minor2d_con = hyperbola2d_con.MinorRadius();\n\t\tCHECK( major2d_con== Approx(4.0));\n\t\tCHECK(minor2d_con == Approx(3.0));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] PointT<double, DIM> Focus2()\t @return The negative focus\n\t @brief Get the focus on the negative side of the major axis\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <modeling/MakeFace.hpp>\n#include <common/AxisT.hpp>\n#include <math/HyperbolaT.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <common/VectorT.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <topology/TopoEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <common/TransformationT.hpp>\n#include <iostream>\nusing namespace AMCAX;\nusing namespace std;\n#include <catch.hpp>\n#include <testHelper.h>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <modeling/MakeFace.hpp>\n#include <common/AxisT.hpp>\n#include <math/HyperbolaT.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <common/VectorT.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <topology/TopoEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <common/TransformationT.hpp>\n#include <iostream>\nusing namespace AMCAX;\nusing namespace std;\n;\n\tSECTION(\"Focus2\") {\n\t\tPoint2 point2d_f1 = hyperbola2d_ax.Focus2();\n\t\tCHECK(point2d_f1.X() == Approx(-5.0));\n\t\tCHECK(point2d_f1.Y() == Approx(0.0));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] PointT<double, DIM> Focus1()\t @return The positive focus\n\t @brief Get the focus on the positive side of the major axis\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <modeling/MakeFace.hpp>\n#include <common/AxisT.hpp>\n#include <math/HyperbolaT.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <common/VectorT.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <topology/TopoEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <common/TransformationT.hpp>\n#include <iostream>\nusing namespace AMCAX;\nusing namespace std;\n#include <catch.hpp>\n#include <testHelper.h>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <modeling/MakeFace.hpp>\n#include <common/AxisT.hpp>\n#include <math/HyperbolaT.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <common/VectorT.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <topology/TopoEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <common/TransformationT.hpp>\n#include <iostream>\nusing namespace AMCAX;\nusing namespace std;\n;\n\tSECTION(\"Default()\") {\n\t\tHyperbola2 hyperbola2d_de;\t\n\t\tCHECK(hyperbola2d_de.Location().X() == Approx(0.0));\n\t\tCHECK(hyperbola2d_de.Location().Y() == Approx(0.0));\n\t\thyperbola2d_de.SetMajorRadius(3.0);\n\t\thyperbola2d_de.SetMinorRadius(4.0);\n\t\tCHECK(hyperbola2d_de.MajorRadius() == Approx(3.0));\n\t\tCHECK(hyperbola2d_de.MinorRadius() == Approx(4.0));\n\t\tCHECK(hyperbola2d_de.Focal() == Approx(10.0));\n\t\tCHECK(hyperbola2d_de.Focus1().X() == Approx(5.0));\n\t\tCHECK(hyperbola2d_de.Focus1().Y() == Approx(0.0));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] double Eccentricity()\t @return The eccentricity\n\t @brief Get the eccentricity of the ellipse\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <modeling/MakeFace.hpp>\n#include <common/AxisT.hpp>\n#include <math/HyperbolaT.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <common/VectorT.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <topology/TopoEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <common/TransformationT.hpp>\n#include <iostream>\nusing namespace AMCAX;\nusing namespace std;\n#include <catch.hpp>\n#include <testHelper.h>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <modeling/MakeFace.hpp>\n#include <common/AxisT.hpp>\n#include <math/HyperbolaT.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <common/VectorT.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <topology/TopoEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <common/TransformationT.hpp>\n#include <iostream>\nusing namespace AMCAX;\nusing namespace std;\n;\n\tSECTION(\"Eccentricity()\") {\t\n\t\tdouble e = hyperbola2d_ax.Eccentricity();\n\t\tCHECK(e == Approx(5.0 / 3.0));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] AxisT<double, DIM> Directrix2()\t @return The negative directrix\n\t @brief Get the directrix on the negative side of the major axis\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <modeling/MakeFace.hpp>\n#include <common/AxisT.hpp>\n#include <math/HyperbolaT.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <common/VectorT.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <topology/TopoEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <common/TransformationT.hpp>\n#include <iostream>\nusing namespace AMCAX;\nusing namespace std;\n#include <catch.hpp>\n#include <testHelper.h>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <modeling/MakeFace.hpp>\n#include <common/AxisT.hpp>\n#include <math/HyperbolaT.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <common/VectorT.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <topology/TopoEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <common/TransformationT.hpp>\n#include <iostream>\nusing namespace AMCAX;\nusing namespace std;\n;\n\tSECTION(\"Directrix()\") {\n\t\tAxis2 axis2d_dir = hyperbola2d_ax.Directrix2();\n\t\tCHECK(axis2d_dir.Direction().X() == Approx(0.0));\n\t\tCHECK(axis2d_dir.Direction().Y() == Approx(1.0));\n\t\tCHECK(axis2d_dir.Location().X() == Approx(-9.0 / 5.0));\n\t\tCHECK(axis2d_dir.Location().Y() == Approx(0.0));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] AxisT<double, DIM> Directrix1()\t @return The positive directrix\n\t @brief Get the directrix on the positive side of the major axis\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <modeling/MakeFace.hpp>\n#include <common/AxisT.hpp>\n#include <math/HyperbolaT.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <common/VectorT.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <topology/TopoEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <common/TransformationT.hpp>\n#include <iostream>\nusing namespace AMCAX;\nusing namespace std;\n#include <catch.hpp>\n#include <testHelper.h>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <modeling/MakeFace.hpp>\n#include <common/AxisT.hpp>\n#include <math/HyperbolaT.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <common/VectorT.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <topology/TopoEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <common/TransformationT.hpp>\n#include <iostream>\nusing namespace AMCAX;\nusing namespace std;\n;\n\tSECTION(\"Directrix1()\") {\t\n\t\tAxis2 axis2d_dir = hyperbola2d_ax.Directrix1();\n\t\tCHECK(axis2d_dir.Direction().X() == Approx(0.0));\n\t\tCHECK(axis2d_dir.Direction().Y() == Approx(1.0));\n\t\tCHECK(axis2d_dir.Location().X() == Approx(9.0/5.0));\n\t\tCHECK(axis2d_dir.Location().Y() == Approx(0.0));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "void SetMinorRadius(double r)\t @param r The new minor radius\n\t @brief Set the minor radius\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <modeling/MakeFace.hpp>\n#include <common/AxisT.hpp>\n#include <math/HyperbolaT.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <common/VectorT.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <topology/TopoEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <common/TransformationT.hpp>\n#include <iostream>\nusing namespace AMCAX;\nusing namespace std;\n#include <catch.hpp>\n#include <testHelper.h>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <modeling/MakeFace.hpp>\n#include <common/AxisT.hpp>\n#include <math/HyperbolaT.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <common/VectorT.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <topology/TopoEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <common/TransformationT.hpp>\n#include <iostream>\nusing namespace AMCAX;\nusing namespace std;\n;\n\tSECTION(\"SetMinorRadius()\") {\n\t\thyperbola2d_ax.SetMinorRadius(3.0);\n\t\tCHECK(hyperbola2d_ax.Location().X() == Approx(0.0));\n\t\tCHECK(hyperbola2d_ax.Location().Y() == Approx(0.0));\n\t\tCHECK(hyperbola2d_ax.MajorRadius() == Approx(3.0));\n\t\tCHECK(hyperbola2d_ax.MinorRadius() == Approx(3.0));\n\t\tPoint3 point1(3.0, 0.0, 0.0);\n\t\tMakeEdge2d edge1(hyperbola2d_ax);\n\t\tCHECK(BRepClassificationTools::IsPointInOnEdge(edge1, point1, 0.001) == true);\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "void SetMajorRadius(double r)\t @param r The new major radius\n\t @brief Set the major radius\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <modeling/MakeFace.hpp>\n#include <common/AxisT.hpp>\n#include <math/HyperbolaT.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <common/VectorT.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <topology/TopoEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <common/TransformationT.hpp>\n#include <iostream>\nusing namespace AMCAX;\nusing namespace std;\n#include <catch.hpp>\n#include <testHelper.h>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <modeling/MakeFace.hpp>\n#include <common/AxisT.hpp>\n#include <math/HyperbolaT.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <common/VectorT.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <topology/TopoEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <common/TransformationT.hpp>\n#include <iostream>\nusing namespace AMCAX;\nusing namespace std;\n;\n\tSECTION(\"Default()\") {\n\t\tHyperbola2 hyperbola2d_de;\t\n\t\tCHECK(hyperbola2d_de.Location().X() == Approx(0.0));\n\t\tCHECK(hyperbola2d_de.Location().Y() == Approx(0.0));\n\t\thyperbola2d_de.SetMajorRadius(3.0);\n\t\thyperbola2d_de.SetMinorRadius(4.0);\n\t\tCHECK(hyperbola2d_de.MajorRadius() == Approx(3.0));\n\t\tCHECK(hyperbola2d_de.MinorRadius() == Approx(4.0));\n\t\tCHECK(hyperbola2d_de.Focal() == Approx(10.0));\n\t\tCHECK(hyperbola2d_de.Focus1().X() == Approx(5.0));\n\t\tCHECK(hyperbola2d_de.Focus1().Y() == Approx(0.0));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API Cylinder& Transform(const Transformation3& tr)\t @return The reference to self\n\t @param tr The transformation\n\t @brief Transform the cylinder\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <common/FrameT.hpp>\n#include <modeling/MakeFace.hpp>\n#include <common/AxisT.hpp>\n#include <math/Cylinder.hpp>\n#include <common/VectorT.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <modeling/MakeCylinder.hpp>\n#include <iostream>\nusing namespace AMCAX;\nusing namespace std;\n#include <catch.hpp>\n#include <testHelper.h>\n#include <common/FrameT.hpp>\n#include <modeling/MakeFace.hpp>\n#include <common/AxisT.hpp>\n#include <math/Cylinder.hpp>\n#include <common/VectorT.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <modeling/MakeCylinder.hpp>\n#include <iostream>\nusing namespace AMCAX;\nusing namespace std;\n;\n\tSECTION(\"Transform\")\n\t{\n\t\tCylinder Transform_cylinder = cylinder.Transform(tr);\n\t\tCHECK(cylinder.Radius() == Approx(radius_cy));\n\t\tCHECK(cylinder.Location().X() == Approx(4.0));\n\t\tCHECK(cylinder.Location().Y() == Approx(3.0));\n\t\tCHECK(cylinder.Location().Z() == Approx(2.0));\n\t\tCHECK(cylinder.Axis().Direction().X() == Approx(0.0));\n\t\tCHECK(cylinder.Axis().Direction().Y() == Approx(0.0));\n\t\tCHECK(cylinder.Axis().Direction().Z() == Approx(1.0));\n\t\tCHECK(Transform_cylinder.Radius() == Approx(radius_cy));\n\t\tCHECK(Transform_cylinder.Location().X() == Approx(4.0));\n\t\tCHECK(Transform_cylinder.Location().Y() == Approx(3.0));\n\t\tCHECK(Transform_cylinder.Location().Z() == Approx(2.0));\n\t\tCHECK(Transform_cylinder.Axis().Direction().X() == Approx(0.0));\n\t\tCHECK(Transform_cylinder.Axis().Direction().Y() == Approx(0.0));\n\t\tCHECK(Transform_cylinder.Axis().Direction().Z() == Approx(1.0));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API Cylinder& Scale(const Point3& point, double scale)\t @return The reference to self\n\t @param scale The scale value\n\t @param point The scaling center point\n\t @brief Scale the cylinder by a point\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <common/FrameT.hpp>\n#include <modeling/MakeFace.hpp>\n#include <common/AxisT.hpp>\n#include <math/Cylinder.hpp>\n#include <common/VectorT.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <modeling/MakeCylinder.hpp>\n#include <iostream>\nusing namespace AMCAX;\nusing namespace std;\n#include <catch.hpp>\n#include <testHelper.h>\n#include <common/FrameT.hpp>\n#include <modeling/MakeFace.hpp>\n#include <common/AxisT.hpp>\n#include <math/Cylinder.hpp>\n#include <common/VectorT.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <modeling/MakeCylinder.hpp>\n#include <iostream>\nusing namespace AMCAX;\nusing namespace std;\n;\n\tSECTION(\"Scale\")\n\t{\n\t\tCylinder scale_cylinder = cylinder.Scale(point_cy, scale);\n\t\tCHECK(cylinder.Radius() == Approx(2.5));\n\t\tCHECK(cylinder.Location().X() == Approx(6.0));\n\t\tCHECK(cylinder.Location().Y() == Approx(0.0));\n\t\tCHECK(cylinder.Location().Z() == Approx(0.0));\n\t\tCHECK(cylinder.Axis().Direction().X() == 0.0);\n\t\tCHECK(cylinder.Axis().Direction().Y() == 0.0);\n\t\tCHECK(cylinder.Axis().Direction().Z() == 1.0);\n\t\tCHECK(scale_cylinder.Radius() == Approx(2.5));\n\t\tCHECK(scale_cylinder.Location().X() == Approx(6.0));\n\t\tCHECK(scale_cylinder.Location().Y() == Approx(0.0));\n\t\tCHECK(scale_cylinder.Location().Z() == Approx(0.0));\n\t\tCHECK(scale_cylinder.Axis().Direction().X() == 0.0);\n\t\tCHECK(scale_cylinder.Axis().Direction().Y() == 0.0);\n\t\tCHECK(scale_cylinder.Axis().Direction().Z() == 1.0);\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API Cylinder(const Frame3& frame, double r)\t @param r The radius\n\t @param frame The local frame\n\t @brief Construct from a local frame and a radius\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <common/FrameT.hpp>\n#include <modeling/MakeFace.hpp>\n#include <common/AxisT.hpp>\n#include <math/Cylinder.hpp>\n#include <common/VectorT.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <modeling/MakeCylinder.hpp>\n#include <iostream>\nusing namespace AMCAX;\nusing namespace std;\n#include <catch.hpp>\n#include <testHelper.h>\n#include <common/FrameT.hpp>\n#include <modeling/MakeFace.hpp>\n#include <common/AxisT.hpp>\n#include <math/Cylinder.hpp>\n#include <common/VectorT.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <modeling/MakeCylinder.hpp>\n#include <iostream>\nusing namespace AMCAX;\nusing namespace std;\n;\n\tSECTION(\"IsDirect\")\n\t{\n\t\tbool isDirect = cylinder.IsDirect();\n\t\tCHECK(isDirect == true);\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static void CircleD3(double u, const Frame3& pos, double radius, Point3& p, Vector3& v1, Vector3& v2, Vector3& v3)\t @param[out] v3 The third derivative\n\t @param[out] v2 The second derivative\n\t @param[out] v1 The first derivative\n\t @param[out] p The point\n\t @param[in] radius The radius\n\t @param[in] pos The local frame where the circle lies\n\t @param[in] u The parameter\n\t @brief Compute the point and the first three derivatives on a 3D circle represented by a local frame and a radius at a parameter\n,\n",
      "output": "SECTION(\"u = M_PI\") {\n\t\tCurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);\n\t\tCHECK(p.X() == -1.0);\n\t\tCHECK(p.Y() == Approx(1.0));\n\t\tCHECK(p.Z() == 0.0);\n\t\tCHECK(v1.X() == Approx(0.0).margin(1e-14));\n\t\tCHECK(v1.Y() == Approx(-2.0));\n\t\tCHECK(v1.Z() == Approx(0.0));\n\t\tCHECK(v2.X() == Approx(2.0));\n\t\tCHECK(v2.Y() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v2.Z() == Approx(0.0));\n\t\tCHECK(v3.X() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v3.Y() == Approx(2.0));\n\t\tCHECK(v3.Z() == Approx(0.0));\n\t;\n\tSECTION(\"from (1.0,0.0) POS enlarge 999 length\") {\n\t\tPoint2 point2 = CurveCalculation::D0(999.0, line2); \n\t\tCHECK(point2.X() == 1000.0);\n\t\tCHECK(point2.Y() == 0.0);\n\t}}\nSECTION(\"u = M_PI\") {\n\t\tCurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);\n\t\tCHECK(p.X() == -1.0);\n\t\tCHECK(p.Y() == Approx(1.0));\n\t\tCHECK(p.Z() == 0.0);\n\t\tCHECK(v1.X() == Approx(0.0).margin(1e-14));\n\t\tCHECK(v1.Y() == Approx(-2.0));\n\t\tCHECK(v1.Z() == Approx(0.0));\n\t\tCHECK(v2.X() == Approx(2.0));\n\t\tCHECK(v2.Y() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v2.Z() == Approx(0.0));\n\t\tCHECK(v3.X() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v3.Y() == Approx(2.0));\n\t\tCHECK(v3.Z() == Approx(0.0));\n\t;\n\tSECTION(\"u =0\") {  \n\t\tPoint2 point2 = CurveCalculation::D0(0.0, parabola2); \n\t\tCHECK(point2.X() == 0.0);\n\t\tCHECK(point2.Y() == 0.0);\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static void D3(double u, const Hyperbola2& hyperbola, Point2& p, Vector2& v1, Vector2& v2, Vector2& v3)\t @param[out] v3 The third derivative\n\t @param[out] v2 The second derivative\n\t @param[out] v1 The first derivative\n\t @param[out] p The point\n\t @param[in] hyperbola The hyperbola\n\t @param[in] u The parameter\n\t @brief Compute the point and the first three derivatives on a 2D hyperbola at a parameter\n,\n",
      "output": "SECTION(\"u = M_PI\") {\n\t\tCurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);\n\t\tCHECK(p.X() == -1.0);\n\t\tCHECK(p.Y() == Approx(1.0));\n\t\tCHECK(p.Z() == 0.0);\n\t\tCHECK(v1.X() == Approx(0.0).margin(1e-14));\n\t\tCHECK(v1.Y() == Approx(-2.0));\n\t\tCHECK(v1.Z() == Approx(0.0));\n\t\tCHECK(v2.X() == Approx(2.0));\n\t\tCHECK(v2.Y() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v2.Z() == Approx(0.0));\n\t\tCHECK(v3.X() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v3.Y() == Approx(2.0));\n\t\tCHECK(v3.Z() == Approx(0.0));\n\t;\n\tSECTION(\"from (1.0,0.0) POS enlarge 999 length\") {\n\t\tPoint2 point2 = CurveCalculation::D0(999.0, line2); \n\t\tCHECK(point2.X() == 1000.0);\n\t\tCHECK(point2.Y() == 0.0);\n\t}}\nSECTION(\"u = M_PI\") {\n\t\tCurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);\n\t\tCHECK(p.X() == -1.0);\n\t\tCHECK(p.Y() == Approx(1.0));\n\t\tCHECK(p.Z() == 0.0);\n\t\tCHECK(v1.X() == Approx(0.0).margin(1e-14));\n\t\tCHECK(v1.Y() == Approx(-2.0));\n\t\tCHECK(v1.Z() == Approx(0.0));\n\t\tCHECK(v2.X() == Approx(2.0));\n\t\tCHECK(v2.Y() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v2.Z() == Approx(0.0));\n\t\tCHECK(v3.X() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v3.Y() == Approx(2.0));\n\t\tCHECK(v3.Z() == Approx(0.0));\n\t;\n\tSECTION(\"from (1.0,0.0) POS enlarge 999 length\") {\n\t\tPoint2 point2 = CurveCalculation::D0(999.0, line2); \n\t\tCHECK(point2.X() == 1000.0);\n\t\tCHECK(point2.Y() == 0.0);\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] AMCAX_API static Vector2 D3(double u, const Hyperbola2& hyperbola)\t @return The third derivative vector\n\t @param hyperbola The hyperbola\n\t @param u The parameter\n\t @brief Compute the third derivative on a 2D hyperbola at a parameter\n,\n",
      "output": "SECTION(\"u = M_PI\") {\n\t\tCurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);\n\t\tCHECK(p.X() == -1.0);\n\t\tCHECK(p.Y() == Approx(1.0));\n\t\tCHECK(p.Z() == 0.0);\n\t\tCHECK(v1.X() == Approx(0.0).margin(1e-14));\n\t\tCHECK(v1.Y() == Approx(-2.0));\n\t\tCHECK(v1.Z() == Approx(0.0));\n\t\tCHECK(v2.X() == Approx(2.0));\n\t\tCHECK(v2.Y() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v2.Z() == Approx(0.0));\n\t\tCHECK(v3.X() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v3.Y() == Approx(2.0));\n\t\tCHECK(v3.Z() == Approx(0.0));\n\t;\n\tSECTION(\"from (1.0,0.0) POS enlarge 999 length\") {\n\t\tPoint2 point2 = CurveCalculation::D0(999.0, line2); \n\t\tCHECK(point2.X() == 1000.0);\n\t\tCHECK(point2.Y() == 0.0);\n\t}}\nSECTION(\"u = M_PI\") {\n\t\tCurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);\n\t\tCHECK(p.X() == -1.0);\n\t\tCHECK(p.Y() == Approx(1.0));\n\t\tCHECK(p.Z() == 0.0);\n\t\tCHECK(v1.X() == Approx(0.0).margin(1e-14));\n\t\tCHECK(v1.Y() == Approx(-2.0));\n\t\tCHECK(v1.Z() == Approx(0.0));\n\t\tCHECK(v2.X() == Approx(2.0));\n\t\tCHECK(v2.Y() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v2.Z() == Approx(0.0));\n\t\tCHECK(v3.X() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v3.Y() == Approx(2.0));\n\t\tCHECK(v3.Z() == Approx(0.0));\n\t;\n\tSECTION(\"u =0\") {\n\t\tCurveCalculation::D3(0.0, circle2, p, v1, v2,v3);\n\t\tCHECK(p.X() == 3.0);\n\t\tCHECK(p.Y() == 1.0);\n\t\tCHECK(v1.X() == 0.0);\n\t\tCHECK(v1.Y() == 2.0);\n\t\tCHECK(v2.X() == -2.0);\n\t\tCHECK(v2.Y() == 0.0);\n\t\tCHECK(v3.X() == 0.0);\n\t\tCHECK(v3.Y() == -2.0);\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static void D3(double u, const Parabola2& parabola, Point2& p, Vector2& v1, Vector2& v2, Vector2& v3)\t @param[out] v3 The third derivative\n\t @param[out] v2 The second derivative\n\t @param[out] v1 The first derivative\n\t @param[out] p The point\n\t @param[in] parabola The parabola\n\t @param[in] u The parameter\n\t @brief Compute the point and the first three derivatives on a 2D parabola at a parameter\n,\n",
      "output": "SECTION(\"u = M_PI\") {\n\t\tCurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);\n\t\tCHECK(p.X() == -1.0);\n\t\tCHECK(p.Y() == Approx(1.0));\n\t\tCHECK(p.Z() == 0.0);\n\t\tCHECK(v1.X() == Approx(0.0).margin(1e-14));\n\t\tCHECK(v1.Y() == Approx(-2.0));\n\t\tCHECK(v1.Z() == Approx(0.0));\n\t\tCHECK(v2.X() == Approx(2.0));\n\t\tCHECK(v2.Y() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v2.Z() == Approx(0.0));\n\t\tCHECK(v3.X() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v3.Y() == Approx(2.0));\n\t\tCHECK(v3.Z() == Approx(0.0));\n\t;\n\tSECTION(\"from (1.0,0.0) POS enlarge 999 length\") {\n\t\tPoint2 point2 = CurveCalculation::D0(999.0, line2); \n\t\tCHECK(point2.X() == 1000.0);\n\t\tCHECK(point2.Y() == 0.0);\n\t}}\nSECTION(\"u = M_PI\") {\n\t\tCurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);\n\t\tCHECK(p.X() == -1.0);\n\t\tCHECK(p.Y() == Approx(1.0));\n\t\tCHECK(p.Z() == 0.0);\n\t\tCHECK(v1.X() == Approx(0.0).margin(1e-14));\n\t\tCHECK(v1.Y() == Approx(-2.0));\n\t\tCHECK(v1.Z() == Approx(0.0));\n\t\tCHECK(v2.X() == Approx(2.0));\n\t\tCHECK(v2.Y() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v2.Z() == Approx(0.0));\n\t\tCHECK(v3.X() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v3.Y() == Approx(2.0));\n\t\tCHECK(v3.Z() == Approx(0.0));\n\t;\n\tSECTION(\"from (1.0,0.0) POS enlarge 999 length\") {\n\t\tPoint2 point2 = CurveCalculation::D0(999.0, line2); \n\t\tCHECK(point2.X() == 1000.0);\n\t\tCHECK(point2.Y() == 0.0);\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] AMCAX_API static Vector2 D3(double u, const Parabola2& parabola)\t @return The third derivative vector\n\t @param parabola The parabola\n\t @param u The parameter\n\t @brief Compute the third derivative on a 2D parabola at a parameter\n,\n",
      "output": "SECTION(\"u = M_PI\") {\n\t\tCurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);\n\t\tCHECK(p.X() == -1.0);\n\t\tCHECK(p.Y() == Approx(1.0));\n\t\tCHECK(p.Z() == 0.0);\n\t\tCHECK(v1.X() == Approx(0.0).margin(1e-14));\n\t\tCHECK(v1.Y() == Approx(-2.0));\n\t\tCHECK(v1.Z() == Approx(0.0));\n\t\tCHECK(v2.X() == Approx(2.0));\n\t\tCHECK(v2.Y() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v2.Z() == Approx(0.0));\n\t\tCHECK(v3.X() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v3.Y() == Approx(2.0));\n\t\tCHECK(v3.Z() == Approx(0.0));\n\t;\n\tSECTION(\"from (1.0,0.0) POS enlarge 999 length\") {\n\t\tPoint2 point2 = CurveCalculation::D0(999.0, line2); \n\t\tCHECK(point2.X() == 1000.0);\n\t\tCHECK(point2.Y() == 0.0);\n\t}}\nSECTION(\"u = M_PI\") {\n\t\tCurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);\n\t\tCHECK(p.X() == -1.0);\n\t\tCHECK(p.Y() == Approx(1.0));\n\t\tCHECK(p.Z() == 0.0);\n\t\tCHECK(v1.X() == Approx(0.0).margin(1e-14));\n\t\tCHECK(v1.Y() == Approx(-2.0));\n\t\tCHECK(v1.Z() == Approx(0.0));\n\t\tCHECK(v2.X() == Approx(2.0));\n\t\tCHECK(v2.Y() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v2.Z() == Approx(0.0));\n\t\tCHECK(v3.X() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v3.Y() == Approx(2.0));\n\t\tCHECK(v3.Z() == Approx(0.0));\n\t;\n\tSECTION(\"u =0\") {  \n\t\tPoint2 point2 = CurveCalculation::D0(0.0, parabola2);\n\t\tCHECK(point2.X() == 0.0);\n\t\tCHECK(point2.Y() == 0.0);\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static void D3(double u, const Ellipse2& ellipse, Point2& p, Vector2& v1, Vector2& v2, Vector2& v3)\t @param[out] v3 The third derivative\n\t @param[out] v2 The second derivative\n\t @param[out] v1 The first derivative\n\t @param[out] p The point\n\t @param[in] ellipse The ellipse\n\t @param[in] u The parameter\n\t @brief Compute the point and the first three derivatives on a 2D ellipse at a parameter\n,\n",
      "output": "SECTION(\"u = M_PI\") {\n\t\tCurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);\n\t\tCHECK(p.X() == -1.0);\n\t\tCHECK(p.Y() == Approx(1.0));\n\t\tCHECK(p.Z() == 0.0);\n\t\tCHECK(v1.X() == Approx(0.0).margin(1e-14));\n\t\tCHECK(v1.Y() == Approx(-2.0));\n\t\tCHECK(v1.Z() == Approx(0.0));\n\t\tCHECK(v2.X() == Approx(2.0));\n\t\tCHECK(v2.Y() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v2.Z() == Approx(0.0));\n\t\tCHECK(v3.X() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v3.Y() == Approx(2.0));\n\t\tCHECK(v3.Z() == Approx(0.0));\n\t;\n\tSECTION(\"from (1.0,0.0) POS enlarge 999 length\") {\n\t\tPoint2 point2 = CurveCalculation::D0(999.0, line2); \n\t\tCHECK(point2.X() == 1000.0);\n\t\tCHECK(point2.Y() == 0.0);\n\t}}\nSECTION(\"u = M_PI\") {\n\t\tCurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);\n\t\tCHECK(p.X() == -1.0);\n\t\tCHECK(p.Y() == Approx(1.0));\n\t\tCHECK(p.Z() == 0.0);\n\t\tCHECK(v1.X() == Approx(0.0).margin(1e-14));\n\t\tCHECK(v1.Y() == Approx(-2.0));\n\t\tCHECK(v1.Z() == Approx(0.0));\n\t\tCHECK(v2.X() == Approx(2.0));\n\t\tCHECK(v2.Y() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v2.Z() == Approx(0.0));\n\t\tCHECK(v3.X() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v3.Y() == Approx(2.0));\n\t\tCHECK(v3.Z() == Approx(0.0));\n\t;\n\tSECTION(\"from (1.0,0.0) POS enlarge 999 length\") {\n\t\tPoint2 point2 = CurveCalculation::D0(999.0, line2); \n\t\tCHECK(point2.X() == 1000.0);\n\t\tCHECK(point2.Y() == 0.0);\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] AMCAX_API static Vector2 D3(double u, const Ellipse2& ellipse)\t @return The third derivative vector\n\t @param ellipse The ellipse\n\t @param u The parameter\n\t @brief Compute the third derivative on a 2D ellipse at a parameter\n,\n",
      "output": "SECTION(\"u = M_PI\") {\n\t\tCurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);\n\t\tCHECK(p.X() == -1.0);\n\t\tCHECK(p.Y() == Approx(1.0));\n\t\tCHECK(p.Z() == 0.0);\n\t\tCHECK(v1.X() == Approx(0.0).margin(1e-14));\n\t\tCHECK(v1.Y() == Approx(-2.0));\n\t\tCHECK(v1.Z() == Approx(0.0));\n\t\tCHECK(v2.X() == Approx(2.0));\n\t\tCHECK(v2.Y() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v2.Z() == Approx(0.0));\n\t\tCHECK(v3.X() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v3.Y() == Approx(2.0));\n\t\tCHECK(v3.Z() == Approx(0.0));\n\t;\n\tSECTION(\"from (1.0,0.0) POS enlarge 999 length\") {\n\t\tPoint2 point2 = CurveCalculation::D0(999.0, line2); \n\t\tCHECK(point2.X() == 1000.0);\n\t\tCHECK(point2.Y() == 0.0);\n\t}}\nSECTION(\"u = M_PI\") {\n\t\tCurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);\n\t\tCHECK(p.X() == -1.0);\n\t\tCHECK(p.Y() == Approx(1.0));\n\t\tCHECK(p.Z() == 0.0);\n\t\tCHECK(v1.X() == Approx(0.0).margin(1e-14));\n\t\tCHECK(v1.Y() == Approx(-2.0));\n\t\tCHECK(v1.Z() == Approx(0.0));\n\t\tCHECK(v2.X() == Approx(2.0));\n\t\tCHECK(v2.Y() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v2.Z() == Approx(0.0));\n\t\tCHECK(v3.X() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v3.Y() == Approx(2.0));\n\t\tCHECK(v3.Z() == Approx(0.0));\n\t;\n\tSECTION(\"u =0\") {\n\t\tCurveCalculation::D3(0.0, circle2, p, v1, v2,v3);\n\t\tCHECK(p.X() == 3.0);\n\t\tCHECK(p.Y() == 1.0);\n\t\tCHECK(v1.X() == 0.0);\n\t\tCHECK(v1.Y() == 2.0);\n\t\tCHECK(v2.X() == -2.0);\n\t\tCHECK(v2.Y() == 0.0);\n\t\tCHECK(v3.X() == 0.0);\n\t\tCHECK(v3.Y() == -2.0);\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static void D3(double u, const Circle2& circle, Point2& p, Vector2& v1, Vector2& v2, Vector2& v3)\t @param[out] v3 The third derivative\n\t @param[out] v2 The second derivative\n\t @param[out] v1 The first derivative\n\t @param[out] p The point\n\t @param[in] circle The circle\n\t @param[in] u The parameter\n\t @brief Compute the point and the first three derivatives on a 2D circle at a parameter\n,\n",
      "output": "SECTION(\"u = M_PI\") {\n\t\tCurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);\n\t\tCHECK(p.X() == -1.0);\n\t\tCHECK(p.Y() == Approx(1.0));\n\t\tCHECK(p.Z() == 0.0);\n\t\tCHECK(v1.X() == Approx(0.0).margin(1e-14));\n\t\tCHECK(v1.Y() == Approx(-2.0));\n\t\tCHECK(v1.Z() == Approx(0.0));\n\t\tCHECK(v2.X() == Approx(2.0));\n\t\tCHECK(v2.Y() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v2.Z() == Approx(0.0));\n\t\tCHECK(v3.X() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v3.Y() == Approx(2.0));\n\t\tCHECK(v3.Z() == Approx(0.0));\n\t;\n\tSECTION(\"from (1.0,0.0) POS enlarge 999 length\") {\n\t\tPoint2 point2 = CurveCalculation::D0(999.0, line2); \n\t\tCHECK(point2.X() == 1000.0);\n\t\tCHECK(point2.Y() == 0.0);\n\t}}\nSECTION(\"u = M_PI\") {\n\t\tCurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);\n\t\tCHECK(p.X() == -1.0);\n\t\tCHECK(p.Y() == Approx(1.0));\n\t\tCHECK(p.Z() == 0.0);\n\t\tCHECK(v1.X() == Approx(0.0).margin(1e-14));\n\t\tCHECK(v1.Y() == Approx(-2.0));\n\t\tCHECK(v1.Z() == Approx(0.0));\n\t\tCHECK(v2.X() == Approx(2.0));\n\t\tCHECK(v2.Y() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v2.Z() == Approx(0.0));\n\t\tCHECK(v3.X() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v3.Y() == Approx(2.0));\n\t\tCHECK(v3.Z() == Approx(0.0));\n\t;\n\tSECTION(\"from (1.0,0.0) POS enlarge 999 length\") {\n\t\tPoint2 point2 = CurveCalculation::D0(999.0, line2); \n\t\tCHECK(point2.X() == 1000.0);\n\t\tCHECK(point2.Y() == 0.0);\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] AMCAX_API static Vector2 D3(double u, const Circle2& circle)\t @return The third derivative vector\n\t @param circle The circle\n\t @param u The parameter\n\t @brief Compute the third derivative on a 2D circle at a parameter\n,\n",
      "output": "SECTION(\"u = M_PI\") {\n\t\tCurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);\n\t\tCHECK(p.X() == -1.0);\n\t\tCHECK(p.Y() == Approx(1.0));\n\t\tCHECK(p.Z() == 0.0);\n\t\tCHECK(v1.X() == Approx(0.0).margin(1e-14));\n\t\tCHECK(v1.Y() == Approx(-2.0));\n\t\tCHECK(v1.Z() == Approx(0.0));\n\t\tCHECK(v2.X() == Approx(2.0));\n\t\tCHECK(v2.Y() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v2.Z() == Approx(0.0));\n\t\tCHECK(v3.X() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v3.Y() == Approx(2.0));\n\t\tCHECK(v3.Z() == Approx(0.0));\n\t;\n\tSECTION(\"from (1.0,0.0) POS enlarge 999 length\") {\n\t\tPoint2 point2 = CurveCalculation::D0(999.0, line2); \n\t\tCHECK(point2.X() == 1000.0);\n\t\tCHECK(point2.Y() == 0.0);\n\t}}\nSECTION(\"u = M_PI\") {\n\t\tCurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);\n\t\tCHECK(p.X() == -1.0);\n\t\tCHECK(p.Y() == Approx(1.0));\n\t\tCHECK(p.Z() == 0.0);\n\t\tCHECK(v1.X() == Approx(0.0).margin(1e-14));\n\t\tCHECK(v1.Y() == Approx(-2.0));\n\t\tCHECK(v1.Z() == Approx(0.0));\n\t\tCHECK(v2.X() == Approx(2.0));\n\t\tCHECK(v2.Y() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v2.Z() == Approx(0.0));\n\t\tCHECK(v3.X() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v3.Y() == Approx(2.0));\n\t\tCHECK(v3.Z() == Approx(0.0));\n\t;\n\tSECTION(\"from (1.0,0.0) POS enlarge 999 length\") {\n\t\tPoint2 point2 = CurveCalculation::D0(999.0, line2); \n\t\tCHECK(point2.X() == 1000.0);\n\t\tCHECK(point2.Y() == 0.0);\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static void D3(double u, const Line2& line, Point2& p, Vector2& v1, Vector2& v2, Vector2& v3)\t @param[out] v3 The third derivative\n\t @param[out] v2 The second derivative\n\t @param[out] v1 The first derivative\n\t @param[out] p The point\n\t @param[in] line The line\n\t @param[in] u The parameter\n\t @brief Compute the point and the first three derivatives on a 2D line at a parameter\n,\n",
      "output": "SECTION(\"u = M_PI\") {\n\t\tCurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);\n\t\tCHECK(p.X() == -1.0);\n\t\tCHECK(p.Y() == Approx(1.0));\n\t\tCHECK(p.Z() == 0.0);\n\t\tCHECK(v1.X() == Approx(0.0).margin(1e-14));\n\t\tCHECK(v1.Y() == Approx(-2.0));\n\t\tCHECK(v1.Z() == Approx(0.0));\n\t\tCHECK(v2.X() == Approx(2.0));\n\t\tCHECK(v2.Y() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v2.Z() == Approx(0.0));\n\t\tCHECK(v3.X() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v3.Y() == Approx(2.0));\n\t\tCHECK(v3.Z() == Approx(0.0));\n\t;\n\tSECTION(\"from (1.0,0.0) POS enlarge 999 length\") {\n\t\tPoint2 point2 = CurveCalculation::D0(999.0, line2); \n\t\tCHECK(point2.X() == 1000.0);\n\t\tCHECK(point2.Y() == 0.0);\n\t}}\nSECTION(\"u = M_PI\") {\n\t\tCurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);\n\t\tCHECK(p.X() == -1.0);\n\t\tCHECK(p.Y() == Approx(1.0));\n\t\tCHECK(p.Z() == 0.0);\n\t\tCHECK(v1.X() == Approx(0.0).margin(1e-14));\n\t\tCHECK(v1.Y() == Approx(-2.0));\n\t\tCHECK(v1.Z() == Approx(0.0));\n\t\tCHECK(v2.X() == Approx(2.0));\n\t\tCHECK(v2.Y() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v2.Z() == Approx(0.0));\n\t\tCHECK(v3.X() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v3.Y() == Approx(2.0));\n\t\tCHECK(v3.Z() == Approx(0.0));\n\t;\n\tSECTION(\"from (1.0,0.0) POS enlarge 999 length\") {\n\t\tPoint2 point2 = CurveCalculation::D0(999.0, line2); \n\t\tCHECK(point2.X() == 1000.0);\n\t\tCHECK(point2.Y() == 0.0);\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] AMCAX_API static Vector2 D3(double u, const Line2& line)\t @return The third derivative vector\n\t @param line The line\n\t @param u The parameter\n\t @brief Compute the third derivative on a 2D line at a parameter\n,\n",
      "output": "SECTION(\"u = M_PI\") {\n\t\tCurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);\n\t\tCHECK(p.X() == -1.0);\n\t\tCHECK(p.Y() == Approx(1.0));\n\t\tCHECK(p.Z() == 0.0);\n\t\tCHECK(v1.X() == Approx(0.0).margin(1e-14));\n\t\tCHECK(v1.Y() == Approx(-2.0));\n\t\tCHECK(v1.Z() == Approx(0.0));\n\t\tCHECK(v2.X() == Approx(2.0));\n\t\tCHECK(v2.Y() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v2.Z() == Approx(0.0));\n\t\tCHECK(v3.X() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v3.Y() == Approx(2.0));\n\t\tCHECK(v3.Z() == Approx(0.0));\n\t;\n\tSECTION(\"from (1.0,0.0) POS enlarge 999 length\") {\n\t\tPoint2 point2 = CurveCalculation::D0(999.0, line2); \n\t\tCHECK(point2.X() == 1000.0);\n\t\tCHECK(point2.Y() == 0.0);\n\t}}\nSECTION(\"u = M_PI\") {\n\t\tCurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);\n\t\tCHECK(p.X() == -1.0);\n\t\tCHECK(p.Y() == Approx(1.0));\n\t\tCHECK(p.Z() == 0.0);\n\t\tCHECK(v1.X() == Approx(0.0).margin(1e-14));\n\t\tCHECK(v1.Y() == Approx(-2.0));\n\t\tCHECK(v1.Z() == Approx(0.0));\n\t\tCHECK(v2.X() == Approx(2.0));\n\t\tCHECK(v2.Y() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v2.Z() == Approx(0.0));\n\t\tCHECK(v3.X() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v3.Y() == Approx(2.0));\n\t\tCHECK(v3.Z() == Approx(0.0));\n\t;\n\tSECTION(\"u =0\") {\n\t\tPoint2 point2 = CurveCalculation::D0(0.0, parabola2);\n\t\tCHECK(point2.X() == 0.0);\n\t\tCHECK(point2.Y() == 0.0);\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static void D3(double u, const Hyperbola3& hyperbola, Point3& p, Vector3& v1, Vector3& v2, Vector3& v3)\t @param[out] v3 The third derivative\n\t @param[out] v2 The second derivative\n\t @param[out] v1 The first derivative\n\t @param[out] p The point\n\t @param[in] hyperbola The hyperbola\n\t @param[in] u The parameter\n\t @brief Compute the point and the first three derivatives on a 3D hyperbola at a parameter\n,\n",
      "output": "SECTION(\"u = M_PI\") {\n\t\tCurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);\n\t\tCHECK(p.X() == -1.0);\n\t\tCHECK(p.Y() == Approx(1.0));\n\t\tCHECK(p.Z() == 0.0);\n\t\tCHECK(v1.X() == Approx(0.0).margin(1e-14));\n\t\tCHECK(v1.Y() == Approx(-2.0));\n\t\tCHECK(v1.Z() == Approx(0.0));\n\t\tCHECK(v2.X() == Approx(2.0));\n\t\tCHECK(v2.Y() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v2.Z() == Approx(0.0));\n\t\tCHECK(v3.X() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v3.Y() == Approx(2.0));\n\t\tCHECK(v3.Z() == Approx(0.0));\n\t;\n\tSECTION(\"from (1.0,0.0) POS enlarge 999 length\") {\n\t\tPoint2 point2 = CurveCalculation::D0(999.0, line2); \n\t\tCHECK(point2.X() == 1000.0);\n\t\tCHECK(point2.Y() == 0.0);\n\t}}\nSECTION(\"u = M_PI\") {\n\t\tCurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);\n\t\tCHECK(p.X() == -1.0);\n\t\tCHECK(p.Y() == Approx(1.0));\n\t\tCHECK(p.Z() == 0.0);\n\t\tCHECK(v1.X() == Approx(0.0).margin(1e-14));\n\t\tCHECK(v1.Y() == Approx(-2.0));\n\t\tCHECK(v1.Z() == Approx(0.0));\n\t\tCHECK(v2.X() == Approx(2.0));\n\t\tCHECK(v2.Y() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v2.Z() == Approx(0.0));\n\t\tCHECK(v3.X() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v3.Y() == Approx(2.0));\n\t\tCHECK(v3.Z() == Approx(0.0));\n\t;\n\tSECTION(\"from (1.0,0.0) POS enlarge 999 length\") {\n\t\tPoint2 point2 = CurveCalculation::D0(999.0, line2); \n\t\tCHECK(point2.X() == 1000.0);\n\t\tCHECK(point2.Y() == 0.0);\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] AMCAX_API static Vector3 D3(double u, const Hyperbola3& hyperbola)\t @return The third derivative vector\n\t @param hyperbola The hyperbola\n\t @param u The parameter\n\t @brief Compute the third derivative on a 3D hyperbola at a parameter\n,\n",
      "output": "SECTION(\"u = M_PI\") {\n\t\tCurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);\n\t\tCHECK(p.X() == -1.0);\n\t\tCHECK(p.Y() == Approx(1.0));\n\t\tCHECK(p.Z() == 0.0);\n\t\tCHECK(v1.X() == Approx(0.0).margin(1e-14));\n\t\tCHECK(v1.Y() == Approx(-2.0));\n\t\tCHECK(v1.Z() == Approx(0.0));\n\t\tCHECK(v2.X() == Approx(2.0));\n\t\tCHECK(v2.Y() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v2.Z() == Approx(0.0));\n\t\tCHECK(v3.X() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v3.Y() == Approx(2.0));\n\t\tCHECK(v3.Z() == Approx(0.0));\n\t;\n\tSECTION(\"from (1.0,0.0) POS enlarge 999 length\") {\n\t\tPoint2 point2 = CurveCalculation::D0(999.0, line2); \n\t\tCHECK(point2.X() == 1000.0);\n\t\tCHECK(point2.Y() == 0.0);\n\t}}\nSECTION(\"u = M_PI\") {\n\t\tCurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);\n\t\tCHECK(p.X() == -1.0);\n\t\tCHECK(p.Y() == Approx(1.0));\n\t\tCHECK(p.Z() == 0.0);\n\t\tCHECK(v1.X() == Approx(0.0).margin(1e-14));\n\t\tCHECK(v1.Y() == Approx(-2.0));\n\t\tCHECK(v1.Z() == Approx(0.0));\n\t\tCHECK(v2.X() == Approx(2.0));\n\t\tCHECK(v2.Y() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v2.Z() == Approx(0.0));\n\t\tCHECK(v3.X() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v3.Y() == Approx(2.0));\n\t\tCHECK(v3.Z() == Approx(0.0));\n\t;\n\tSECTION(\"u =0\") {\n\t\tCurveCalculation::D3(0.0, circle2, p, v1, v2,v3);\n\t\tCHECK(p.X() == 3.0);\n\t\tCHECK(p.Y() == 1.0);\n\t\tCHECK(v1.X() == 0.0);\n\t\tCHECK(v1.Y() == 2.0);\n\t\tCHECK(v2.X() == -2.0);\n\t\tCHECK(v2.Y() == 0.0);\n\t\tCHECK(v3.X() == 0.0);\n\t\tCHECK(v3.Y() == -2.0);\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static void D3(double u, const Parabola3& parabola, Point3& p, Vector3& v1, Vector3& v2, Vector3& v3)\t @param[out] v3 The third derivative\n\t @param[out] v2 The second derivative\n\t @param[out] v1 The first derivative\n\t @param[out] p The point\n\t @param[in] parabola The parabola\n\t @param[in] u The parameter\n\t @brief Compute the point and the first three derivatives on a 3D parabola at a parameter\n,\n",
      "output": "SECTION(\"u = M_PI\") {\n\t\tCurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);\n\t\tCHECK(p.X() == -1.0);\n\t\tCHECK(p.Y() == Approx(1.0));\n\t\tCHECK(p.Z() == 0.0);\n\t\tCHECK(v1.X() == Approx(0.0).margin(1e-14));\n\t\tCHECK(v1.Y() == Approx(-2.0));\n\t\tCHECK(v1.Z() == Approx(0.0));\n\t\tCHECK(v2.X() == Approx(2.0));\n\t\tCHECK(v2.Y() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v2.Z() == Approx(0.0));\n\t\tCHECK(v3.X() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v3.Y() == Approx(2.0));\n\t\tCHECK(v3.Z() == Approx(0.0));\n\t;\n\tSECTION(\"from (1.0,0.0) POS enlarge 999 length\") {\n\t\tPoint2 point2 = CurveCalculation::D0(999.0, line2); \n\t\tCHECK(point2.X() == 1000.0);\n\t\tCHECK(point2.Y() == 0.0);\n\t}}\nSECTION(\"u = M_PI\") {\n\t\tCurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);\n\t\tCHECK(p.X() == -1.0);\n\t\tCHECK(p.Y() == Approx(1.0));\n\t\tCHECK(p.Z() == 0.0);\n\t\tCHECK(v1.X() == Approx(0.0).margin(1e-14));\n\t\tCHECK(v1.Y() == Approx(-2.0));\n\t\tCHECK(v1.Z() == Approx(0.0));\n\t\tCHECK(v2.X() == Approx(2.0));\n\t\tCHECK(v2.Y() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v2.Z() == Approx(0.0));\n\t\tCHECK(v3.X() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v3.Y() == Approx(2.0));\n\t\tCHECK(v3.Z() == Approx(0.0));\n\t;\n\tSECTION(\"from (1.0,0.0) POS enlarge 999 length\") {\n\t\tPoint2 point2 = CurveCalculation::D0(999.0, line2); \n\t\tCHECK(point2.X() == 1000.0);\n\t\tCHECK(point2.Y() == 0.0);\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] AMCAX_API static Vector3 D3(double u, const Parabola3& parabola)\t @return The third derivative vector\n\t @param parabola The parabola\n\t @param u The parameter\n\t @brief Compute the third derivative on a 3D parabola at a parameter\n,\n",
      "output": "SECTION(\"u = M_PI\") {\n\t\tCurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);\n\t\tCHECK(p.X() == -1.0);\n\t\tCHECK(p.Y() == Approx(1.0));\n\t\tCHECK(p.Z() == 0.0);\n\t\tCHECK(v1.X() == Approx(0.0).margin(1e-14));\n\t\tCHECK(v1.Y() == Approx(-2.0));\n\t\tCHECK(v1.Z() == Approx(0.0));\n\t\tCHECK(v2.X() == Approx(2.0));\n\t\tCHECK(v2.Y() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v2.Z() == Approx(0.0));\n\t\tCHECK(v3.X() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v3.Y() == Approx(2.0));\n\t\tCHECK(v3.Z() == Approx(0.0));\n\t;\n\tSECTION(\"from (1.0,0.0) POS enlarge 999 length\") {\n\t\tPoint2 point2 = CurveCalculation::D0(999.0, line2); \n\t\tCHECK(point2.X() == 1000.0);\n\t\tCHECK(point2.Y() == 0.0);\n\t}}\nSECTION(\"u = M_PI\") {\n\t\tCurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);\n\t\tCHECK(p.X() == -1.0);\n\t\tCHECK(p.Y() == Approx(1.0));\n\t\tCHECK(p.Z() == 0.0);\n\t\tCHECK(v1.X() == Approx(0.0).margin(1e-14));\n\t\tCHECK(v1.Y() == Approx(-2.0));\n\t\tCHECK(v1.Z() == Approx(0.0));\n\t\tCHECK(v2.X() == Approx(2.0));\n\t\tCHECK(v2.Y() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v2.Z() == Approx(0.0));\n\t\tCHECK(v3.X() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v3.Y() == Approx(2.0));\n\t\tCHECK(v3.Z() == Approx(0.0));\n\t;\n\tSECTION(\"u =0\") {\n\t\tCurveCalculation::D3(0.0, circle2, p, v1, v2,v3);\n\t\tCHECK(p.X() == 3.0);\n\t\tCHECK(p.Y() == 1.0);\n\t\tCHECK(v1.X() == 0.0);\n\t\tCHECK(v1.Y() == 2.0);\n\t\tCHECK(v2.X() == -2.0);\n\t\tCHECK(v2.Y() == 0.0);\n\t\tCHECK(v3.X() == 0.0);\n\t\tCHECK(v3.Y() == -2.0);\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static void D3(double u, const Ellipse3& ellipse, Point3& p, Vector3& v1, Vector3& v2, Vector3& v3)\t @param[out] v3 The third derivative\n\t @param[out] v2 The second derivative\n\t @param[out] v1 The first derivative\n\t @param[out] p The point\n\t @param[in] ellipse The ellipse\n\t @param[in] u The parameter\n\t @brief Compute the point and the first three derivatives on a 3D ellipse at a parameter\n,\n",
      "output": "SECTION(\"u = M_PI\") {\n\t\tCurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);\n\t\tCHECK(p.X() == -1.0);\n\t\tCHECK(p.Y() == Approx(1.0));\n\t\tCHECK(p.Z() == 0.0);\n\t\tCHECK(v1.X() == Approx(0.0).margin(1e-14));\n\t\tCHECK(v1.Y() == Approx(-2.0));\n\t\tCHECK(v1.Z() == Approx(0.0));\n\t\tCHECK(v2.X() == Approx(2.0));\n\t\tCHECK(v2.Y() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v2.Z() == Approx(0.0));\n\t\tCHECK(v3.X() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v3.Y() == Approx(2.0));\n\t\tCHECK(v3.Z() == Approx(0.0));\n\t;\n\tSECTION(\"from (1.0,0.0) POS enlarge 999 length\") {\n\t\tPoint2 point2 = CurveCalculation::D0(999.0, line2); \n\t\tCHECK(point2.X() == 1000.0);\n\t\tCHECK(point2.Y() == 0.0);\n\t}}\nSECTION(\"u = M_PI\") {\n\t\tCurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);\n\t\tCHECK(p.X() == -1.0);\n\t\tCHECK(p.Y() == Approx(1.0));\n\t\tCHECK(p.Z() == 0.0);\n\t\tCHECK(v1.X() == Approx(0.0).margin(1e-14));\n\t\tCHECK(v1.Y() == Approx(-2.0));\n\t\tCHECK(v1.Z() == Approx(0.0));\n\t\tCHECK(v2.X() == Approx(2.0));\n\t\tCHECK(v2.Y() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v2.Z() == Approx(0.0));\n\t\tCHECK(v3.X() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v3.Y() == Approx(2.0));\n\t\tCHECK(v3.Z() == Approx(0.0));\n\t;\n\tSECTION(\"from (1.0,0.0) POS enlarge 999 length\") {\n\t\tPoint2 point2 = CurveCalculation::D0(999.0, line2); \n\t\tCHECK(point2.X() == 1000.0);\n\t\tCHECK(point2.Y() == 0.0);\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] AMCAX_API static Vector3 D3(double u, const Ellipse3& ellipse)\t @return The third derivative vector\n\t @param ellipse The ellipse\n\t @param u The parameter\n\t @brief Compute the third derivative on a 3D ellipse at a parameter\n,\n",
      "output": "SECTION(\"u = M_PI\") {\n\t\tCurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);\n\t\tCHECK(p.X() == -1.0);\n\t\tCHECK(p.Y() == Approx(1.0));\n\t\tCHECK(p.Z() == 0.0);\n\t\tCHECK(v1.X() == Approx(0.0).margin(1e-14));\n\t\tCHECK(v1.Y() == Approx(-2.0));\n\t\tCHECK(v1.Z() == Approx(0.0));\n\t\tCHECK(v2.X() == Approx(2.0));\n\t\tCHECK(v2.Y() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v2.Z() == Approx(0.0));\n\t\tCHECK(v3.X() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v3.Y() == Approx(2.0));\n\t\tCHECK(v3.Z() == Approx(0.0));\n\t;\n\tSECTION(\"from (1.0,0.0) POS enlarge 999 length\") {\n\t\tPoint2 point2 = CurveCalculation::D0(999.0, line2); \n\t\tCHECK(point2.X() == 1000.0);\n\t\tCHECK(point2.Y() == 0.0);\n\t}}\nSECTION(\"u = M_PI\") {\n\t\tCurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);\n\t\tCHECK(p.X() == -1.0);\n\t\tCHECK(p.Y() == Approx(1.0));\n\t\tCHECK(p.Z() == 0.0);\n\t\tCHECK(v1.X() == Approx(0.0).margin(1e-14));\n\t\tCHECK(v1.Y() == Approx(-2.0));\n\t\tCHECK(v1.Z() == Approx(0.0));\n\t\tCHECK(v2.X() == Approx(2.0));\n\t\tCHECK(v2.Y() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v2.Z() == Approx(0.0));\n\t\tCHECK(v3.X() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v3.Y() == Approx(2.0));\n\t\tCHECK(v3.Z() == Approx(0.0));\n\t;\n\tSECTION(\"+999\") {\n\t\tPoint3 point3 = CurveCalculation::D0(999.0, line3);\n\t\tCHECK(point3.X() == 1000.0);\n\t\tCHECK(point3.Y() == 0.0);\n\t\tCHECK(point3.Z() == 0.0);\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static void D3(double u, const Circle3& circle, Point3& p, Vector3& v1, Vector3& v2, Vector3& v3)\t @param[out] v3 The third derivative\n\t @param[out] v2 The second derivative\n\t @param[out] v1 The first derivative\n\t @param[out] p The point\n\t @param[in] circle The circle\n\t @param[in] u The parameter\n\t @brief Compute the point and the first three derivatives on a 3D circle at a parameter\n,\n",
      "output": "SECTION(\"u = M_PI\") {\n\t\tCurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);\n\t\tCHECK(p.X() == -1.0);\n\t\tCHECK(p.Y() == Approx(1.0));\n\t\tCHECK(p.Z() == 0.0);\n\t\tCHECK(v1.X() == Approx(0.0).margin(1e-14));\n\t\tCHECK(v1.Y() == Approx(-2.0));\n\t\tCHECK(v1.Z() == Approx(0.0));\n\t\tCHECK(v2.X() == Approx(2.0));\n\t\tCHECK(v2.Y() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v2.Z() == Approx(0.0));\n\t\tCHECK(v3.X() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v3.Y() == Approx(2.0));\n\t\tCHECK(v3.Z() == Approx(0.0));\n\t;\n\tSECTION(\"from (1.0,0.0) POS enlarge 999 length\") {\n\t\tPoint2 point2 = CurveCalculation::D0(999.0, line2); \n\t\tCHECK(point2.X() == 1000.0);\n\t\tCHECK(point2.Y() == 0.0);\n\t}}\nSECTION(\"u = M_PI\") {\n\t\tCurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);\n\t\tCHECK(p.X() == -1.0);\n\t\tCHECK(p.Y() == Approx(1.0));\n\t\tCHECK(p.Z() == 0.0);\n\t\tCHECK(v1.X() == Approx(0.0).margin(1e-14));\n\t\tCHECK(v1.Y() == Approx(-2.0));\n\t\tCHECK(v1.Z() == Approx(0.0));\n\t\tCHECK(v2.X() == Approx(2.0));\n\t\tCHECK(v2.Y() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v2.Z() == Approx(0.0));\n\t\tCHECK(v3.X() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v3.Y() == Approx(2.0));\n\t\tCHECK(v3.Z() == Approx(0.0));\n\t;\n\tSECTION(\"from (1.0,0.0) POS enlarge 999 length\") {\n\t\tPoint2 point2 = CurveCalculation::D0(999.0, line2); \n\t\tCHECK(point2.X() == 1000.0);\n\t\tCHECK(point2.Y() == 0.0);\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] AMCAX_API static Vector3 D3(double u, const Circle3& circle)\t @return The third derivative vector\n\t @param circle The circle\n\t @param u The parameter\n\t @brief Compute the third derivative on a 3D circle at a parameter\n,\n",
      "output": "SECTION(\"u = M_PI\") {\n\t\tCurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);\n\t\tCHECK(p.X() == -1.0);\n\t\tCHECK(p.Y() == Approx(1.0));\n\t\tCHECK(p.Z() == 0.0);\n\t\tCHECK(v1.X() == Approx(0.0).margin(1e-14));\n\t\tCHECK(v1.Y() == Approx(-2.0));\n\t\tCHECK(v1.Z() == Approx(0.0));\n\t\tCHECK(v2.X() == Approx(2.0));\n\t\tCHECK(v2.Y() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v2.Z() == Approx(0.0));\n\t\tCHECK(v3.X() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v3.Y() == Approx(2.0));\n\t\tCHECK(v3.Z() == Approx(0.0));\n\t;\n\tSECTION(\"from (1.0,0.0) POS enlarge 999 length\") {\n\t\tPoint2 point2 = CurveCalculation::D0(999.0, line2); \n\t\tCHECK(point2.X() == 1000.0);\n\t\tCHECK(point2.Y() == 0.0);\n\t}}\nSECTION(\"u = M_PI\") {\n\t\tCurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);\n\t\tCHECK(p.X() == -1.0);\n\t\tCHECK(p.Y() == Approx(1.0));\n\t\tCHECK(p.Z() == 0.0);\n\t\tCHECK(v1.X() == Approx(0.0).margin(1e-14));\n\t\tCHECK(v1.Y() == Approx(-2.0));\n\t\tCHECK(v1.Z() == Approx(0.0));\n\t\tCHECK(v2.X() == Approx(2.0));\n\t\tCHECK(v2.Y() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v2.Z() == Approx(0.0));\n\t\tCHECK(v3.X() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v3.Y() == Approx(2.0));\n\t\tCHECK(v3.Z() == Approx(0.0));\n\t;\n\tSECTION(\"from (1.0,0.0) POS enlarge 999 length\") {\n\t\tPoint2 point2 = CurveCalculation::D0(999.0, line2); \n\t\tCHECK(point2.X() == 1000.0);\n\t\tCHECK(point2.Y() == 0.0);\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static void D3(double u, const Line3& line, Point3& p, Vector3& v1, Vector3& v2, Vector3& v3)\t @param[out] v3 The third derivative\n\t @param[out] v2 The second derivative\n\t @param[out] v1 The first derivative\n\t @param[out] p The point\n\t @param[in] line The line\n\t @param[in] u The parameter\n\t @brief Compute the point and the first three derivatives on a 3D line at a parameter\n,\n",
      "output": "SECTION(\"u = M_PI\") {\n\t\tCurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);\n\t\tCHECK(p.X() == -1.0);\n\t\tCHECK(p.Y() == Approx(1.0));\n\t\tCHECK(p.Z() == 0.0);\n\t\tCHECK(v1.X() == Approx(0.0).margin(1e-14));\n\t\tCHECK(v1.Y() == Approx(-2.0));\n\t\tCHECK(v1.Z() == Approx(0.0));\n\t\tCHECK(v2.X() == Approx(2.0));\n\t\tCHECK(v2.Y() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v2.Z() == Approx(0.0));\n\t\tCHECK(v3.X() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v3.Y() == Approx(2.0));\n\t\tCHECK(v3.Z() == Approx(0.0));\n\t;\n\tSECTION(\"from (1.0,0.0) POS enlarge 999 length\") {\n\t\tPoint2 point2 = CurveCalculation::D0(999.0, line2); \n\t\tCHECK(point2.X() == 1000.0);\n\t\tCHECK(point2.Y() == 0.0);\n\t}}\nSECTION(\"u = M_PI\") {\n\t\tCurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);\n\t\tCHECK(p.X() == -1.0);\n\t\tCHECK(p.Y() == Approx(1.0));\n\t\tCHECK(p.Z() == 0.0);\n\t\tCHECK(v1.X() == Approx(0.0).margin(1e-14));\n\t\tCHECK(v1.Y() == Approx(-2.0));\n\t\tCHECK(v1.Z() == Approx(0.0));\n\t\tCHECK(v2.X() == Approx(2.0));\n\t\tCHECK(v2.Y() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v2.Z() == Approx(0.0));\n\t\tCHECK(v3.X() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v3.Y() == Approx(2.0));\n\t\tCHECK(v3.Z() == Approx(0.0));\n\t;\n\tSECTION(\"from (1.0,0.0) POS enlarge 999 length\") {\n\t\tPoint2 point2 = CurveCalculation::D0(999.0, line2); \n\t\tCHECK(point2.X() == 1000.0);\n\t\tCHECK(point2.Y() == 0.0);\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] AMCAX_API static Vector3 D3(double u, const Line3& line)\t @return The third derivative vector\n\t @param line The line\n\t @param u The parameter\n\t @brief Compute the third derivative on a 3D line at a parameter\n,\n",
      "output": "SECTION(\"u = M_PI\") {\n\t\tCurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);\n\t\tCHECK(p.X() == -1.0);\n\t\tCHECK(p.Y() == Approx(1.0));\n\t\tCHECK(p.Z() == 0.0);\n\t\tCHECK(v1.X() == Approx(0.0).margin(1e-14));\n\t\tCHECK(v1.Y() == Approx(-2.0));\n\t\tCHECK(v1.Z() == Approx(0.0));\n\t\tCHECK(v2.X() == Approx(2.0));\n\t\tCHECK(v2.Y() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v2.Z() == Approx(0.0));\n\t\tCHECK(v3.X() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v3.Y() == Approx(2.0));\n\t\tCHECK(v3.Z() == Approx(0.0));\n\t;\n\tSECTION(\"from (1.0,0.0) POS enlarge 999 length\") {\n\t\tPoint2 point2 = CurveCalculation::D0(999.0, line2); \n\t\tCHECK(point2.X() == 1000.0);\n\t\tCHECK(point2.Y() == 0.0);\n\t}}\nSECTION(\"u = M_PI\") {\n\t\tCurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);\n\t\tCHECK(p.X() == -1.0);\n\t\tCHECK(p.Y() == Approx(1.0));\n\t\tCHECK(p.Z() == 0.0);\n\t\tCHECK(v1.X() == Approx(0.0).margin(1e-14));\n\t\tCHECK(v1.Y() == Approx(-2.0));\n\t\tCHECK(v1.Z() == Approx(0.0));\n\t\tCHECK(v2.X() == Approx(2.0));\n\t\tCHECK(v2.Y() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v2.Z() == Approx(0.0));\n\t\tCHECK(v3.X() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v3.Y() == Approx(2.0));\n\t\tCHECK(v3.Z() == Approx(0.0));\n\t;\n\tSECTION(\"u =0\") {\n\t\tCurveCalculation::D3(0.0, circle2, p, v1, v2,v3);\n\t\tCHECK(p.X() == 3.0);\n\t\tCHECK(p.Y() == 1.0);\n\t\tCHECK(v1.X() == 0.0);\n\t\tCHECK(v1.Y() == 2.0);\n\t\tCHECK(v2.X() == -2.0);\n\t\tCHECK(v2.Y() == 0.0);\n\t\tCHECK(v3.X() == 0.0);\n\t\tCHECK(v3.Y() == -2.0);\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static void D2(double u, const Hyperbola2& hyperbola, Point2& p, Vector2& v1, Vector2& v2)\t @param[out] v2 The second derivative\n\t @param[out] v1 The first derivative\n\t @param[out] p The point\n\t @param[in] hyperbola The hyperbola\n\t @param[in] u The parameter\n\t @brief Compute the point and the first two derivatives on a 2D hyperbola at a parameter\n,\n",
      "output": "SECTION(\"u = M_PI\") {\n\t\tCurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);\n\t\tCHECK(p.X() == -1.0);\n\t\tCHECK(p.Y() == Approx(1.0));\n\t\tCHECK(p.Z() == 0.0);\n\t\tCHECK(v1.X() == Approx(0.0).margin(1e-14));\n\t\tCHECK(v1.Y() == Approx(-2.0));\n\t\tCHECK(v1.Z() == Approx(0.0));\n\t\tCHECK(v2.X() == Approx(2.0));\n\t\tCHECK(v2.Y() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v2.Z() == Approx(0.0));\n\t\tCHECK(v3.X() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v3.Y() == Approx(2.0));\n\t\tCHECK(v3.Z() == Approx(0.0));\n\t;\n\tSECTION(\"from (1.0,0.0) POS enlarge 999 length\") {\n\t\tPoint2 point2 = CurveCalculation::D0(999.0, line2); \n\t\tCHECK(point2.X() == 1000.0);\n\t\tCHECK(point2.Y() == 0.0);\n\t}}\nSECTION(\"u = M_PI\") {\n\t\tCurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);\n\t\tCHECK(p.X() == -1.0);\n\t\tCHECK(p.Y() == Approx(1.0));\n\t\tCHECK(p.Z() == 0.0);\n\t\tCHECK(v1.X() == Approx(0.0).margin(1e-14));\n\t\tCHECK(v1.Y() == Approx(-2.0));\n\t\tCHECK(v1.Z() == Approx(0.0));\n\t\tCHECK(v2.X() == Approx(2.0));\n\t\tCHECK(v2.Y() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v2.Z() == Approx(0.0));\n\t\tCHECK(v3.X() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v3.Y() == Approx(2.0));\n\t\tCHECK(v3.Z() == Approx(0.0));\n\t;\n\tSECTION(\"u = M_PI\") {\n\t\tCurveCalculation::D2(M_PI, circle2, p, v1,v2);\n\t\tCHECK(p.X() == -1.0);\n\t\tCHECK(p.Y() == Approx(1.0));\n\t\tCHECK(v1.X() == Approx(0.0).margin(1e-12) );\n\t\tCHECK(v1.Y() == -2.0);\n\t\tCHECK(v2.X() == 2.0);\n\t\tCHECK(v2.Y() == Approx(0.0).margin(1e-11));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] AMCAX_API static Vector2 D2(double u, const Hyperbola2& hyperbola)\t @return The second derivative vector\n\t @param hyperbola The hyperbola\n\t @param u The parameter\n\t @brief Compute the second derivative on a 2D hyperbola at a parameter\n,\n",
      "output": "SECTION(\"u = M_PI\") {\n\t\tCurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);\n\t\tCHECK(p.X() == -1.0);\n\t\tCHECK(p.Y() == Approx(1.0));\n\t\tCHECK(p.Z() == 0.0);\n\t\tCHECK(v1.X() == Approx(0.0).margin(1e-14));\n\t\tCHECK(v1.Y() == Approx(-2.0));\n\t\tCHECK(v1.Z() == Approx(0.0));\n\t\tCHECK(v2.X() == Approx(2.0));\n\t\tCHECK(v2.Y() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v2.Z() == Approx(0.0));\n\t\tCHECK(v3.X() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v3.Y() == Approx(2.0));\n\t\tCHECK(v3.Z() == Approx(0.0));\n\t;\n\tSECTION(\"from (1.0,0.0) POS enlarge 999 length\") {\n\t\tPoint2 point2 = CurveCalculation::D0(999.0, line2); \n\t\tCHECK(point2.X() == 1000.0);\n\t\tCHECK(point2.Y() == 0.0);\n\t}}\nSECTION(\"u = M_PI\") {\n\t\tCurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);\n\t\tCHECK(p.X() == -1.0);\n\t\tCHECK(p.Y() == Approx(1.0));\n\t\tCHECK(p.Z() == 0.0);\n\t\tCHECK(v1.X() == Approx(0.0).margin(1e-14));\n\t\tCHECK(v1.Y() == Approx(-2.0));\n\t\tCHECK(v1.Z() == Approx(0.0));\n\t\tCHECK(v2.X() == Approx(2.0));\n\t\tCHECK(v2.Y() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v2.Z() == Approx(0.0));\n\t\tCHECK(v3.X() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v3.Y() == Approx(2.0));\n\t\tCHECK(v3.Z() == Approx(0.0));\n\t;\n\tSECTION(\"u = M_PI\") {\n\t\tVector2 vector2 = CurveCalculation::D2(M_PI, circle2);\n\t\tCHECK(vector2.X() == 2.0);\n\t\tCHECK(vector2.Y() == Approx(0.0).margin(1e-11));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static void D2(double u, const Parabola2& parabola, Point2& p, Vector2& v1, Vector2& v2)\t @param[out] v2 The second derivative\n\t @param[out] v1 The first derivative\n\t @param[out] p The point\n\t @param[in] parabola The parabola\n\t @param[in] u The parameter\n\t @brief Compute the point and the first two derivatives on a 2D parabola at a parameter\n,\n",
      "output": "SECTION(\"u = M_PI\") {\n\t\tCurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);\n\t\tCHECK(p.X() == -1.0);\n\t\tCHECK(p.Y() == Approx(1.0));\n\t\tCHECK(p.Z() == 0.0);\n\t\tCHECK(v1.X() == Approx(0.0).margin(1e-14));\n\t\tCHECK(v1.Y() == Approx(-2.0));\n\t\tCHECK(v1.Z() == Approx(0.0));\n\t\tCHECK(v2.X() == Approx(2.0));\n\t\tCHECK(v2.Y() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v2.Z() == Approx(0.0));\n\t\tCHECK(v3.X() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v3.Y() == Approx(2.0));\n\t\tCHECK(v3.Z() == Approx(0.0));\n\t;\n\tSECTION(\"from (1.0,0.0) POS enlarge 999 length\") {\n\t\tPoint2 point2 = CurveCalculation::D0(999.0, line2); \n\t\tCHECK(point2.X() == 1000.0);\n\t\tCHECK(point2.Y() == 0.0);\n\t}}\nSECTION(\"u = M_PI\") {\n\t\tCurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);\n\t\tCHECK(p.X() == -1.0);\n\t\tCHECK(p.Y() == Approx(1.0));\n\t\tCHECK(p.Z() == 0.0);\n\t\tCHECK(v1.X() == Approx(0.0).margin(1e-14));\n\t\tCHECK(v1.Y() == Approx(-2.0));\n\t\tCHECK(v1.Z() == Approx(0.0));\n\t\tCHECK(v2.X() == Approx(2.0));\n\t\tCHECK(v2.Y() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v2.Z() == Approx(0.0));\n\t\tCHECK(v3.X() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v3.Y() == Approx(2.0));\n\t\tCHECK(v3.Z() == Approx(0.0));\n\t;\n\tSECTION(\"u = M_PI\") {\n\t\tCurveCalculation::D2(M_PI, circle2, p, v1,v2);\n\t\tCHECK(p.X() == -1.0);\n\t\tCHECK(p.Y() == Approx(1.0));\n\t\tCHECK(v1.X() == Approx(0.0).margin(1e-12) );\n\t\tCHECK(v1.Y() == -2.0);\n\t\tCHECK(v2.X() == 2.0);\n\t\tCHECK(v2.Y() == Approx(0.0).margin(1e-11));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] AMCAX_API static Vector2 D2(double u, const Parabola2& parabola)\t @return The second derivative vector\n\t @param parabola The parabola\n\t @param u The parameter\n\t @brief Compute the second derivative on a 2D parabola at a parameter\n,\n",
      "output": "SECTION(\"u = M_PI\") {\n\t\tCurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);\n\t\tCHECK(p.X() == -1.0);\n\t\tCHECK(p.Y() == Approx(1.0));\n\t\tCHECK(p.Z() == 0.0);\n\t\tCHECK(v1.X() == Approx(0.0).margin(1e-14));\n\t\tCHECK(v1.Y() == Approx(-2.0));\n\t\tCHECK(v1.Z() == Approx(0.0));\n\t\tCHECK(v2.X() == Approx(2.0));\n\t\tCHECK(v2.Y() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v2.Z() == Approx(0.0));\n\t\tCHECK(v3.X() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v3.Y() == Approx(2.0));\n\t\tCHECK(v3.Z() == Approx(0.0));\n\t;\n\tSECTION(\"from (1.0,0.0) POS enlarge 999 length\") {\n\t\tPoint2 point2 = CurveCalculation::D0(999.0, line2); \n\t\tCHECK(point2.X() == 1000.0);\n\t\tCHECK(point2.Y() == 0.0);\n\t}}\nSECTION(\"u = M_PI\") {\n\t\tCurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);\n\t\tCHECK(p.X() == -1.0);\n\t\tCHECK(p.Y() == Approx(1.0));\n\t\tCHECK(p.Z() == 0.0);\n\t\tCHECK(v1.X() == Approx(0.0).margin(1e-14));\n\t\tCHECK(v1.Y() == Approx(-2.0));\n\t\tCHECK(v1.Z() == Approx(0.0));\n\t\tCHECK(v2.X() == Approx(2.0));\n\t\tCHECK(v2.Y() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v2.Z() == Approx(0.0));\n\t\tCHECK(v3.X() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v3.Y() == Approx(2.0));\n\t\tCHECK(v3.Z() == Approx(0.0));\n\t;\n\tSECTION(\"u = M_PI\") {\n\t\tVector2 vector2 = CurveCalculation::D2(M_PI, circle2);\n\t\tCHECK(vector2.X() == 2.0);\n\t\tCHECK(vector2.Y() == Approx(0.0).margin(1e-11));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static void D2(double u, const Ellipse2& ellipse, Point2& p, Vector2& v1, Vector2& v2)\t @param[out] v2 The second derivative\n\t @param[out] v1 The first derivative\n\t @param[out] p The point\n\t @param[in] ellipse The ellipse\n\t @param[in] u The parameter\n\t @brief Compute the point and the first two derivatives on a 2D ellipse at a parameter\n,\n",
      "output": "SECTION(\"u = M_PI\") {\n\t\tCurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);\n\t\tCHECK(p.X() == -1.0);\n\t\tCHECK(p.Y() == Approx(1.0));\n\t\tCHECK(p.Z() == 0.0);\n\t\tCHECK(v1.X() == Approx(0.0).margin(1e-14));\n\t\tCHECK(v1.Y() == Approx(-2.0));\n\t\tCHECK(v1.Z() == Approx(0.0));\n\t\tCHECK(v2.X() == Approx(2.0));\n\t\tCHECK(v2.Y() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v2.Z() == Approx(0.0));\n\t\tCHECK(v3.X() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v3.Y() == Approx(2.0));\n\t\tCHECK(v3.Z() == Approx(0.0));\n\t;\n\tSECTION(\"from (1.0,0.0) POS enlarge 999 length\") {\n\t\tPoint2 point2 = CurveCalculation::D0(999.0, line2); \n\t\tCHECK(point2.X() == 1000.0);\n\t\tCHECK(point2.Y() == 0.0);\n\t}}\nSECTION(\"u = M_PI\") {\n\t\tCurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);\n\t\tCHECK(p.X() == -1.0);\n\t\tCHECK(p.Y() == Approx(1.0));\n\t\tCHECK(p.Z() == 0.0);\n\t\tCHECK(v1.X() == Approx(0.0).margin(1e-14));\n\t\tCHECK(v1.Y() == Approx(-2.0));\n\t\tCHECK(v1.Z() == Approx(0.0));\n\t\tCHECK(v2.X() == Approx(2.0));\n\t\tCHECK(v2.Y() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v2.Z() == Approx(0.0));\n\t\tCHECK(v3.X() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v3.Y() == Approx(2.0));\n\t\tCHECK(v3.Z() == Approx(0.0));\n\t;\n\tSECTION(\"u = M_PI\") {\n\t\tCurveCalculation::D2(M_PI, circle2, p, v1,v2);\n\t\tCHECK(p.X() == -1.0);\n\t\tCHECK(p.Y() == Approx(1.0));\n\t\tCHECK(v1.X() == Approx(0.0).margin(1e-12) );\n\t\tCHECK(v1.Y() == -2.0);\n\t\tCHECK(v2.X() == 2.0);\n\t\tCHECK(v2.Y() == Approx(0.0).margin(1e-11));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] AMCAX_API static Vector2 D2(double u, const Ellipse2& ellipse)\t @return The second derivative vector\n\t @param ellipse The ellipse\n\t @param u The parameter\n\t @brief Compute the second derivative on a 2D ellipse at a parameter\n,\n",
      "output": "SECTION(\"u = M_PI\") {\n\t\tCurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);\n\t\tCHECK(p.X() == -1.0);\n\t\tCHECK(p.Y() == Approx(1.0));\n\t\tCHECK(p.Z() == 0.0);\n\t\tCHECK(v1.X() == Approx(0.0).margin(1e-14));\n\t\tCHECK(v1.Y() == Approx(-2.0));\n\t\tCHECK(v1.Z() == Approx(0.0));\n\t\tCHECK(v2.X() == Approx(2.0));\n\t\tCHECK(v2.Y() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v2.Z() == Approx(0.0));\n\t\tCHECK(v3.X() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v3.Y() == Approx(2.0));\n\t\tCHECK(v3.Z() == Approx(0.0));\n\t;\n\tSECTION(\"from (1.0,0.0) POS enlarge 999 length\") {\n\t\tPoint2 point2 = CurveCalculation::D0(999.0, line2); \n\t\tCHECK(point2.X() == 1000.0);\n\t\tCHECK(point2.Y() == 0.0);\n\t}}\nSECTION(\"u = M_PI\") {\n\t\tCurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);\n\t\tCHECK(p.X() == -1.0);\n\t\tCHECK(p.Y() == Approx(1.0));\n\t\tCHECK(p.Z() == 0.0);\n\t\tCHECK(v1.X() == Approx(0.0).margin(1e-14));\n\t\tCHECK(v1.Y() == Approx(-2.0));\n\t\tCHECK(v1.Z() == Approx(0.0));\n\t\tCHECK(v2.X() == Approx(2.0));\n\t\tCHECK(v2.Y() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v2.Z() == Approx(0.0));\n\t\tCHECK(v3.X() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v3.Y() == Approx(2.0));\n\t\tCHECK(v3.Z() == Approx(0.0));\n\t;\n\tSECTION(\"u = M_PI\") {\n\t\tVector2 vector2 = CurveCalculation::D2(M_PI, circle2);\n\t\tCHECK(vector2.X() == 2.0);\n\t\tCHECK(vector2.Y() == Approx(0.0).margin(1e-11));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static void D2(double u, const Circle2& circle, Point2& p, Vector2& v1, Vector2& v2)\t @param[out] v2 The second derivative\n\t @param[out] v1 The first derivative\n\t @param[out] p The point\n\t @param[in] circle The circle\n\t @param[in] u The parameter\n\t @brief Compute the point and the first two derivatives on a 2D circle at a parameter\n,\n",
      "output": "SECTION(\"u = M_PI\") {\n\t\tCurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);\n\t\tCHECK(p.X() == -1.0);\n\t\tCHECK(p.Y() == Approx(1.0));\n\t\tCHECK(p.Z() == 0.0);\n\t\tCHECK(v1.X() == Approx(0.0).margin(1e-14));\n\t\tCHECK(v1.Y() == Approx(-2.0));\n\t\tCHECK(v1.Z() == Approx(0.0));\n\t\tCHECK(v2.X() == Approx(2.0));\n\t\tCHECK(v2.Y() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v2.Z() == Approx(0.0));\n\t\tCHECK(v3.X() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v3.Y() == Approx(2.0));\n\t\tCHECK(v3.Z() == Approx(0.0));\n\t;\n\tSECTION(\"from (1.0,0.0) POS enlarge 999 length\") {\n\t\tPoint2 point2 = CurveCalculation::D0(999.0, line2); \n\t\tCHECK(point2.X() == 1000.0);\n\t\tCHECK(point2.Y() == 0.0);\n\t}}\nSECTION(\"u = M_PI\") {\n\t\tCurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);\n\t\tCHECK(p.X() == -1.0);\n\t\tCHECK(p.Y() == Approx(1.0));\n\t\tCHECK(p.Z() == 0.0);\n\t\tCHECK(v1.X() == Approx(0.0).margin(1e-14));\n\t\tCHECK(v1.Y() == Approx(-2.0));\n\t\tCHECK(v1.Z() == Approx(0.0));\n\t\tCHECK(v2.X() == Approx(2.0));\n\t\tCHECK(v2.Y() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v2.Z() == Approx(0.0));\n\t\tCHECK(v3.X() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v3.Y() == Approx(2.0));\n\t\tCHECK(v3.Z() == Approx(0.0));\n\t;\n\tSECTION(\"u = M_PI\") {\n\t\tCurveCalculation::D2(M_PI, circle2, p, v1,v2);\n\t\tCHECK(p.X() == -1.0);\n\t\tCHECK(p.Y() == Approx(1.0));\n\t\tCHECK(v1.X() == Approx(0.0).margin(1e-12) );\n\t\tCHECK(v1.Y() == -2.0);\n\t\tCHECK(v2.X() == 2.0);\n\t\tCHECK(v2.Y() == Approx(0.0).margin(1e-11));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] AMCAX_API static Vector2 D2(double u, const Circle2& circle)\t @return The second derivative vector\n\t @param circle The circle\n\t @param u The parameter\n\t @brief Compute the second derivative on a 2D circle at a parameter\n,\n",
      "output": "SECTION(\"u = M_PI\") {\n\t\tCurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);\n\t\tCHECK(p.X() == -1.0);\n\t\tCHECK(p.Y() == Approx(1.0));\n\t\tCHECK(p.Z() == 0.0);\n\t\tCHECK(v1.X() == Approx(0.0).margin(1e-14));\n\t\tCHECK(v1.Y() == Approx(-2.0));\n\t\tCHECK(v1.Z() == Approx(0.0));\n\t\tCHECK(v2.X() == Approx(2.0));\n\t\tCHECK(v2.Y() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v2.Z() == Approx(0.0));\n\t\tCHECK(v3.X() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v3.Y() == Approx(2.0));\n\t\tCHECK(v3.Z() == Approx(0.0));\n\t;\n\tSECTION(\"from (1.0,0.0) POS enlarge 999 length\") {\n\t\tPoint2 point2 = CurveCalculation::D0(999.0, line2); \n\t\tCHECK(point2.X() == 1000.0);\n\t\tCHECK(point2.Y() == 0.0);\n\t}}\nSECTION(\"u = M_PI\") {\n\t\tCurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);\n\t\tCHECK(p.X() == -1.0);\n\t\tCHECK(p.Y() == Approx(1.0));\n\t\tCHECK(p.Z() == 0.0);\n\t\tCHECK(v1.X() == Approx(0.0).margin(1e-14));\n\t\tCHECK(v1.Y() == Approx(-2.0));\n\t\tCHECK(v1.Z() == Approx(0.0));\n\t\tCHECK(v2.X() == Approx(2.0));\n\t\tCHECK(v2.Y() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v2.Z() == Approx(0.0));\n\t\tCHECK(v3.X() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v3.Y() == Approx(2.0));\n\t\tCHECK(v3.Z() == Approx(0.0));\n\t;\n\tSECTION(\"u = M_PI\") {\n\t\tVector2 vector2 = CurveCalculation::D2(M_PI, circle2);\n\t\tCHECK(vector2.X() == 2.0);\n\t\tCHECK(vector2.Y() == Approx(0.0).margin(1e-11));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static void D2(double u, const Line2& line, Point2& p, Vector2& v1, Vector2& v2)\t @param[out] v2 The second derivative\n\t @param[out] v1 The first derivative\n\t @param[out] p The point\n\t @param[in] line The line\n\t @param[in] u The parameter\n\t @brief Compute the point and the first two derivatives on a 2D line at a parameter\n,\n",
      "output": "SECTION(\"u = M_PI\") {\n\t\tCurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);\n\t\tCHECK(p.X() == -1.0);\n\t\tCHECK(p.Y() == Approx(1.0));\n\t\tCHECK(p.Z() == 0.0);\n\t\tCHECK(v1.X() == Approx(0.0).margin(1e-14));\n\t\tCHECK(v1.Y() == Approx(-2.0));\n\t\tCHECK(v1.Z() == Approx(0.0));\n\t\tCHECK(v2.X() == Approx(2.0));\n\t\tCHECK(v2.Y() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v2.Z() == Approx(0.0));\n\t\tCHECK(v3.X() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v3.Y() == Approx(2.0));\n\t\tCHECK(v3.Z() == Approx(0.0));\n\t;\n\tSECTION(\"from (1.0,0.0) POS enlarge 999 length\") {\n\t\tPoint2 point2 = CurveCalculation::D0(999.0, line2); \n\t\tCHECK(point2.X() == 1000.0);\n\t\tCHECK(point2.Y() == 0.0);\n\t}}\nSECTION(\"u = M_PI\") {\n\t\tCurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);\n\t\tCHECK(p.X() == -1.0);\n\t\tCHECK(p.Y() == Approx(1.0));\n\t\tCHECK(p.Z() == 0.0);\n\t\tCHECK(v1.X() == Approx(0.0).margin(1e-14));\n\t\tCHECK(v1.Y() == Approx(-2.0));\n\t\tCHECK(v1.Z() == Approx(0.0));\n\t\tCHECK(v2.X() == Approx(2.0));\n\t\tCHECK(v2.Y() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v2.Z() == Approx(0.0));\n\t\tCHECK(v3.X() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v3.Y() == Approx(2.0));\n\t\tCHECK(v3.Z() == Approx(0.0));\n\t;\n\tSECTION(\"u = M_PI\") {\n\t\tCurveCalculation::D2(M_PI, circle2, p, v1,v2);\n\t\tCHECK(p.X() == -1.0);\n\t\tCHECK(p.Y() == Approx(1.0));\n\t\tCHECK(v1.X() == Approx(0.0).margin(1e-12) );\n\t\tCHECK(v1.Y() == -2.0);\n\t\tCHECK(v2.X() == 2.0);\n\t\tCHECK(v2.Y() == Approx(0.0).margin(1e-11));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] AMCAX_API static Vector2 D2(double u, const Line2& line)\t @return The second derivative vector\n\t @param line The line\n\t @param u The parameter\n\t @brief Compute the second derivative on a 2D line at a parameter\n,\n",
      "output": "SECTION(\"u = M_PI\") {\n\t\tCurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);\n\t\tCHECK(p.X() == -1.0);\n\t\tCHECK(p.Y() == Approx(1.0));\n\t\tCHECK(p.Z() == 0.0);\n\t\tCHECK(v1.X() == Approx(0.0).margin(1e-14));\n\t\tCHECK(v1.Y() == Approx(-2.0));\n\t\tCHECK(v1.Z() == Approx(0.0));\n\t\tCHECK(v2.X() == Approx(2.0));\n\t\tCHECK(v2.Y() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v2.Z() == Approx(0.0));\n\t\tCHECK(v3.X() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v3.Y() == Approx(2.0));\n\t\tCHECK(v3.Z() == Approx(0.0));\n\t;\n\tSECTION(\"from (1.0,0.0) POS enlarge 999 length\") {\n\t\tPoint2 point2 = CurveCalculation::D0(999.0, line2); \n\t\tCHECK(point2.X() == 1000.0);\n\t\tCHECK(point2.Y() == 0.0);\n\t}}\nSECTION(\"u = M_PI\") {\n\t\tCurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);\n\t\tCHECK(p.X() == -1.0);\n\t\tCHECK(p.Y() == Approx(1.0));\n\t\tCHECK(p.Z() == 0.0);\n\t\tCHECK(v1.X() == Approx(0.0).margin(1e-14));\n\t\tCHECK(v1.Y() == Approx(-2.0));\n\t\tCHECK(v1.Z() == Approx(0.0));\n\t\tCHECK(v2.X() == Approx(2.0));\n\t\tCHECK(v2.Y() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v2.Z() == Approx(0.0));\n\t\tCHECK(v3.X() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v3.Y() == Approx(2.0));\n\t\tCHECK(v3.Z() == Approx(0.0));\n\t;\n\tSECTION(\"u =0\") {\n\t\tVector2 vector2 = CurveCalculation::D2(0.0, circle2);\n\t\tCHECK(vector2.X() == -2.0);\n\t\tCHECK(vector2.Y() == 0.0);\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static void D2(double u, const Hyperbola3& hyperbola, Point3& p, Vector3& v1, Vector3& v2)\t @param[out] v2 The second derivative\n\t @param[out] v1 The first derivative\n\t @param[out] p The point\n\t @param[in] hyperbola The hyperbola\n\t @param[in] u The parameter\n\t @brief Compute the point and the first two derivatives on a 3D hyperbola at a parameter\n,\n",
      "output": "SECTION(\"u = M_PI\") {\n\t\tCurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);\n\t\tCHECK(p.X() == -1.0);\n\t\tCHECK(p.Y() == Approx(1.0));\n\t\tCHECK(p.Z() == 0.0);\n\t\tCHECK(v1.X() == Approx(0.0).margin(1e-14));\n\t\tCHECK(v1.Y() == Approx(-2.0));\n\t\tCHECK(v1.Z() == Approx(0.0));\n\t\tCHECK(v2.X() == Approx(2.0));\n\t\tCHECK(v2.Y() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v2.Z() == Approx(0.0));\n\t\tCHECK(v3.X() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v3.Y() == Approx(2.0));\n\t\tCHECK(v3.Z() == Approx(0.0));\n\t;\n\tSECTION(\"from (1.0,0.0) POS enlarge 999 length\") {\n\t\tPoint2 point2 = CurveCalculation::D0(999.0, line2); \n\t\tCHECK(point2.X() == 1000.0);\n\t\tCHECK(point2.Y() == 0.0);\n\t}}\nSECTION(\"u = M_PI\") {\n\t\tCurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);\n\t\tCHECK(p.X() == -1.0);\n\t\tCHECK(p.Y() == Approx(1.0));\n\t\tCHECK(p.Z() == 0.0);\n\t\tCHECK(v1.X() == Approx(0.0).margin(1e-14));\n\t\tCHECK(v1.Y() == Approx(-2.0));\n\t\tCHECK(v1.Z() == Approx(0.0));\n\t\tCHECK(v2.X() == Approx(2.0));\n\t\tCHECK(v2.Y() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v2.Z() == Approx(0.0));\n\t\tCHECK(v3.X() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v3.Y() == Approx(2.0));\n\t\tCHECK(v3.Z() == Approx(0.0));\n\t;\n\tSECTION(\"u = M_PI\") {\n\t\tCurveCalculation::D2(M_PI, circle2, p, v1,v2);\n\t\tCHECK(p.X() == -1.0);\n\t\tCHECK(p.Y() == Approx(1.0));\n\t\tCHECK(v1.X() == Approx(0.0).margin(1e-12) );\n\t\tCHECK(v1.Y() == -2.0);\n\t\tCHECK(v2.X() == 2.0);\n\t\tCHECK(v2.Y() == Approx(0.0).margin(1e-11));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] AMCAX_API static Vector3 D2(double u, const Hyperbola3& hyperbola)\t @return The second derivative vector\n\t @param hyperbola The hyperbola\n\t @param u The parameter\n\t @brief Compute the second derivative on a 3D hyperbola at a parameter\n,\n",
      "output": "SECTION(\"u = M_PI\") {\n\t\tCurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);\n\t\tCHECK(p.X() == -1.0);\n\t\tCHECK(p.Y() == Approx(1.0));\n\t\tCHECK(p.Z() == 0.0);\n\t\tCHECK(v1.X() == Approx(0.0).margin(1e-14));\n\t\tCHECK(v1.Y() == Approx(-2.0));\n\t\tCHECK(v1.Z() == Approx(0.0));\n\t\tCHECK(v2.X() == Approx(2.0));\n\t\tCHECK(v2.Y() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v2.Z() == Approx(0.0));\n\t\tCHECK(v3.X() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v3.Y() == Approx(2.0));\n\t\tCHECK(v3.Z() == Approx(0.0));\n\t;\n\tSECTION(\"from (1.0,0.0) POS enlarge 999 length\") {\n\t\tPoint2 point2 = CurveCalculation::D0(999.0, line2); \n\t\tCHECK(point2.X() == 1000.0);\n\t\tCHECK(point2.Y() == 0.0);\n\t}}\nSECTION(\"u = M_PI\") {\n\t\tCurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);\n\t\tCHECK(p.X() == -1.0);\n\t\tCHECK(p.Y() == Approx(1.0));\n\t\tCHECK(p.Z() == 0.0);\n\t\tCHECK(v1.X() == Approx(0.0).margin(1e-14));\n\t\tCHECK(v1.Y() == Approx(-2.0));\n\t\tCHECK(v1.Z() == Approx(0.0));\n\t\tCHECK(v2.X() == Approx(2.0));\n\t\tCHECK(v2.Y() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v2.Z() == Approx(0.0));\n\t\tCHECK(v3.X() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v3.Y() == Approx(2.0));\n\t\tCHECK(v3.Z() == Approx(0.0));\n\t;\n\tSECTION(\"u = M_PI\") {\n\t\tCurveCalculation::D2(M_PI, circle2, p, v1,v2);\n\t\tCHECK(p.X() == -1.0);\n\t\tCHECK(p.Y() == Approx(1.0));\n\t\tCHECK(v1.X() == Approx(0.0).margin(1e-12) );\n\t\tCHECK(v1.Y() == -2.0);\n\t\tCHECK(v2.X() == 2.0);\n\t\tCHECK(v2.Y() == Approx(0.0).margin(1e-11));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static void D2(double u, const Parabola3& parabola, Point3& p, Vector3& v1, Vector3& v2)\t @param[out] v2 The second derivative\n\t @param[out] v1 The first derivative\n\t @param[out] p The point\n\t @param[in] parabola The parabola\n\t @param[in] u The parameter\n\t @brief Compute the point and the first two derivatives on a 3D parabola at a parameter\n,\n",
      "output": "SECTION(\"u = M_PI\") {\n\t\tCurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);\n\t\tCHECK(p.X() == -1.0);\n\t\tCHECK(p.Y() == Approx(1.0));\n\t\tCHECK(p.Z() == 0.0);\n\t\tCHECK(v1.X() == Approx(0.0).margin(1e-14));\n\t\tCHECK(v1.Y() == Approx(-2.0));\n\t\tCHECK(v1.Z() == Approx(0.0));\n\t\tCHECK(v2.X() == Approx(2.0));\n\t\tCHECK(v2.Y() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v2.Z() == Approx(0.0));\n\t\tCHECK(v3.X() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v3.Y() == Approx(2.0));\n\t\tCHECK(v3.Z() == Approx(0.0));\n\t;\n\tSECTION(\"from (1.0,0.0) POS enlarge 999 length\") {\n\t\tPoint2 point2 = CurveCalculation::D0(999.0, line2); \n\t\tCHECK(point2.X() == 1000.0);\n\t\tCHECK(point2.Y() == 0.0);\n\t}}\nSECTION(\"u = M_PI\") {\n\t\tCurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);\n\t\tCHECK(p.X() == -1.0);\n\t\tCHECK(p.Y() == Approx(1.0));\n\t\tCHECK(p.Z() == 0.0);\n\t\tCHECK(v1.X() == Approx(0.0).margin(1e-14));\n\t\tCHECK(v1.Y() == Approx(-2.0));\n\t\tCHECK(v1.Z() == Approx(0.0));\n\t\tCHECK(v2.X() == Approx(2.0));\n\t\tCHECK(v2.Y() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v2.Z() == Approx(0.0));\n\t\tCHECK(v3.X() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v3.Y() == Approx(2.0));\n\t\tCHECK(v3.Z() == Approx(0.0));\n\t;\n\tSECTION(\"u = M_PI\") {\n\t\tCurveCalculation::D2(M_PI, circle2, p, v1,v2);\n\t\tCHECK(p.X() == -1.0);\n\t\tCHECK(p.Y() == Approx(1.0));\n\t\tCHECK(v1.X() == Approx(0.0).margin(1e-12) );\n\t\tCHECK(v1.Y() == -2.0);\n\t\tCHECK(v2.X() == 2.0);\n\t\tCHECK(v2.Y() == Approx(0.0).margin(1e-11));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] AMCAX_API static Vector3 D2(double u, const Parabola3& parabola)\t @return The second derivative vector\n\t @param parabola The parabola\n\t @param u The parameter\n\t @brief Compute the second derivative on a 3D parabola at a parameter\n,\n",
      "output": "SECTION(\"u = M_PI\") {\n\t\tCurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);\n\t\tCHECK(p.X() == -1.0);\n\t\tCHECK(p.Y() == Approx(1.0));\n\t\tCHECK(p.Z() == 0.0);\n\t\tCHECK(v1.X() == Approx(0.0).margin(1e-14));\n\t\tCHECK(v1.Y() == Approx(-2.0));\n\t\tCHECK(v1.Z() == Approx(0.0));\n\t\tCHECK(v2.X() == Approx(2.0));\n\t\tCHECK(v2.Y() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v2.Z() == Approx(0.0));\n\t\tCHECK(v3.X() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v3.Y() == Approx(2.0));\n\t\tCHECK(v3.Z() == Approx(0.0));\n\t;\n\tSECTION(\"from (1.0,0.0) POS enlarge 999 length\") {\n\t\tPoint2 point2 = CurveCalculation::D0(999.0, line2); \n\t\tCHECK(point2.X() == 1000.0);\n\t\tCHECK(point2.Y() == 0.0);\n\t}}\nSECTION(\"u = M_PI\") {\n\t\tCurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);\n\t\tCHECK(p.X() == -1.0);\n\t\tCHECK(p.Y() == Approx(1.0));\n\t\tCHECK(p.Z() == 0.0);\n\t\tCHECK(v1.X() == Approx(0.0).margin(1e-14));\n\t\tCHECK(v1.Y() == Approx(-2.0));\n\t\tCHECK(v1.Z() == Approx(0.0));\n\t\tCHECK(v2.X() == Approx(2.0));\n\t\tCHECK(v2.Y() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v2.Z() == Approx(0.0));\n\t\tCHECK(v3.X() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v3.Y() == Approx(2.0));\n\t\tCHECK(v3.Z() == Approx(0.0));\n\t;\n\tSECTION(\"u = M_PI\") {\n\t\tCurveCalculation::D2(M_PI, circle2, p, v1,v2);\n\t\tCHECK(p.X() == -1.0);\n\t\tCHECK(p.Y() == Approx(1.0));\n\t\tCHECK(v1.X() == Approx(0.0).margin(1e-12) );\n\t\tCHECK(v1.Y() == -2.0);\n\t\tCHECK(v2.X() == 2.0);\n\t\tCHECK(v2.Y() == Approx(0.0).margin(1e-11));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] AMCAX_API static Vector3 D2(double u, const Ellipse3& ellipse)\t @return The second derivative vector\n\t @param ellipse The ellipse\n\t @param u The parameter\n\t @brief Compute the second derivative on a 3D ellipse at a parameter\n,\n",
      "output": "SECTION(\"u = M_PI\") {\n\t\tCurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);\n\t\tCHECK(p.X() == -1.0);\n\t\tCHECK(p.Y() == Approx(1.0));\n\t\tCHECK(p.Z() == 0.0);\n\t\tCHECK(v1.X() == Approx(0.0).margin(1e-14));\n\t\tCHECK(v1.Y() == Approx(-2.0));\n\t\tCHECK(v1.Z() == Approx(0.0));\n\t\tCHECK(v2.X() == Approx(2.0));\n\t\tCHECK(v2.Y() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v2.Z() == Approx(0.0));\n\t\tCHECK(v3.X() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v3.Y() == Approx(2.0));\n\t\tCHECK(v3.Z() == Approx(0.0));\n\t;\n\tSECTION(\"from (1.0,0.0) POS enlarge 999 length\") {\n\t\tPoint2 point2 = CurveCalculation::D0(999.0, line2); \n\t\tCHECK(point2.X() == 1000.0);\n\t\tCHECK(point2.Y() == 0.0);\n\t}}\nSECTION(\"u = M_PI\") {\n\t\tCurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);\n\t\tCHECK(p.X() == -1.0);\n\t\tCHECK(p.Y() == Approx(1.0));\n\t\tCHECK(p.Z() == 0.0);\n\t\tCHECK(v1.X() == Approx(0.0).margin(1e-14));\n\t\tCHECK(v1.Y() == Approx(-2.0));\n\t\tCHECK(v1.Z() == Approx(0.0));\n\t\tCHECK(v2.X() == Approx(2.0));\n\t\tCHECK(v2.Y() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v2.Z() == Approx(0.0));\n\t\tCHECK(v3.X() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v3.Y() == Approx(2.0));\n\t\tCHECK(v3.Z() == Approx(0.0));\n\t;\n\tSECTION(\"u = M_PI\") {\n\t\tCurveCalculation::D2(M_PI, circle2, p, v1,v2);\n\t\tCHECK(p.X() == -1.0);\n\t\tCHECK(p.Y() == Approx(1.0));\n\t\tCHECK(v1.X() == Approx(0.0).margin(1e-12) );\n\t\tCHECK(v1.Y() == -2.0);\n\t\tCHECK(v2.X() == 2.0);\n\t\tCHECK(v2.Y() == Approx(0.0).margin(1e-11));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static void D2(double u, const Circle3& circle, Point3& p, Vector3& v1, Vector3& v2)\t @param[out] v2 The second derivative\n\t @param[out] v1 The first derivative\n\t @param[out] p The point\n\t @param[in] circle The circle\n\t @param[in] u The parameter\n\t @brief Compute the point and the first two derivatives on a 3D circle at a parameter\n,\n",
      "output": "SECTION(\"u = M_PI\") {\n\t\tCurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);\n\t\tCHECK(p.X() == -1.0);\n\t\tCHECK(p.Y() == Approx(1.0));\n\t\tCHECK(p.Z() == 0.0);\n\t\tCHECK(v1.X() == Approx(0.0).margin(1e-14));\n\t\tCHECK(v1.Y() == Approx(-2.0));\n\t\tCHECK(v1.Z() == Approx(0.0));\n\t\tCHECK(v2.X() == Approx(2.0));\n\t\tCHECK(v2.Y() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v2.Z() == Approx(0.0));\n\t\tCHECK(v3.X() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v3.Y() == Approx(2.0));\n\t\tCHECK(v3.Z() == Approx(0.0));\n\t;\n\tSECTION(\"from (1.0,0.0) POS enlarge 999 length\") {\n\t\tPoint2 point2 = CurveCalculation::D0(999.0, line2); \n\t\tCHECK(point2.X() == 1000.0);\n\t\tCHECK(point2.Y() == 0.0);\n\t}}\nSECTION(\"u = M_PI\") {\n\t\tCurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);\n\t\tCHECK(p.X() == -1.0);\n\t\tCHECK(p.Y() == Approx(1.0));\n\t\tCHECK(p.Z() == 0.0);\n\t\tCHECK(v1.X() == Approx(0.0).margin(1e-14));\n\t\tCHECK(v1.Y() == Approx(-2.0));\n\t\tCHECK(v1.Z() == Approx(0.0));\n\t\tCHECK(v2.X() == Approx(2.0));\n\t\tCHECK(v2.Y() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v2.Z() == Approx(0.0));\n\t\tCHECK(v3.X() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v3.Y() == Approx(2.0));\n\t\tCHECK(v3.Z() == Approx(0.0));\n\t;\n\tSECTION(\"u = M_PI\") {\n\t\tCurveCalculation::D2(M_PI, circle2, p, v1,v2);\n\t\tCHECK(p.X() == -1.0);\n\t\tCHECK(p.Y() == Approx(1.0));\n\t\tCHECK(v1.X() == Approx(0.0).margin(1e-12) );\n\t\tCHECK(v1.Y() == -2.0);\n\t\tCHECK(v2.X() == 2.0);\n\t\tCHECK(v2.Y() == Approx(0.0).margin(1e-11));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] AMCAX_API static Vector3 D2(double u, const Circle3& circle)\t @return The second derivative vector\n\t @param circle The circle\n\t @param u The parameter\n\t @brief Compute the second derivative on a 3D circle at a parameter\n,\n",
      "output": "SECTION(\"u = M_PI\") {\n\t\tCurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);\n\t\tCHECK(p.X() == -1.0);\n\t\tCHECK(p.Y() == Approx(1.0));\n\t\tCHECK(p.Z() == 0.0);\n\t\tCHECK(v1.X() == Approx(0.0).margin(1e-14));\n\t\tCHECK(v1.Y() == Approx(-2.0));\n\t\tCHECK(v1.Z() == Approx(0.0));\n\t\tCHECK(v2.X() == Approx(2.0));\n\t\tCHECK(v2.Y() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v2.Z() == Approx(0.0));\n\t\tCHECK(v3.X() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v3.Y() == Approx(2.0));\n\t\tCHECK(v3.Z() == Approx(0.0));\n\t;\n\tSECTION(\"from (1.0,0.0) POS enlarge 999 length\") {\n\t\tPoint2 point2 = CurveCalculation::D0(999.0, line2); \n\t\tCHECK(point2.X() == 1000.0);\n\t\tCHECK(point2.Y() == 0.0);\n\t}}\nSECTION(\"u = M_PI\") {\n\t\tCurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);\n\t\tCHECK(p.X() == -1.0);\n\t\tCHECK(p.Y() == Approx(1.0));\n\t\tCHECK(p.Z() == 0.0);\n\t\tCHECK(v1.X() == Approx(0.0).margin(1e-14));\n\t\tCHECK(v1.Y() == Approx(-2.0));\n\t\tCHECK(v1.Z() == Approx(0.0));\n\t\tCHECK(v2.X() == Approx(2.0));\n\t\tCHECK(v2.Y() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v2.Z() == Approx(0.0));\n\t\tCHECK(v3.X() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v3.Y() == Approx(2.0));\n\t\tCHECK(v3.Z() == Approx(0.0));\n\t;\n\tSECTION(\"u = M_PI\") {\n\t\tCurveCalculation::D2(M_PI, circle2, p, v1,v2);\n\t\tCHECK(p.X() == -1.0);\n\t\tCHECK(p.Y() == Approx(1.0));\n\t\tCHECK(v1.X() == Approx(0.0).margin(1e-12) );\n\t\tCHECK(v1.Y() == -2.0);\n\t\tCHECK(v2.X() == 2.0);\n\t\tCHECK(v2.Y() == Approx(0.0).margin(1e-11));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static void D2(double u, const Line3& line, Point3& p, Vector3& v1, Vector3& v2)\t @param[out] v2 The second derivative\n\t @param[out] v1 The first derivative\n\t @param[out] p The point\n\t @param[in] line The line\n\t @param[in] u The parameter\n\t @brief Compute the point and the first two derivatives on a 3D line at a parameter\n,\n",
      "output": "SECTION(\"u = M_PI\") {\n\t\tCurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);\n\t\tCHECK(p.X() == -1.0);\n\t\tCHECK(p.Y() == Approx(1.0));\n\t\tCHECK(p.Z() == 0.0);\n\t\tCHECK(v1.X() == Approx(0.0).margin(1e-14));\n\t\tCHECK(v1.Y() == Approx(-2.0));\n\t\tCHECK(v1.Z() == Approx(0.0));\n\t\tCHECK(v2.X() == Approx(2.0));\n\t\tCHECK(v2.Y() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v2.Z() == Approx(0.0));\n\t\tCHECK(v3.X() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v3.Y() == Approx(2.0));\n\t\tCHECK(v3.Z() == Approx(0.0));\n\t;\n\tSECTION(\"from (1.0,0.0) POS enlarge 999 length\") {\n\t\tPoint2 point2 = CurveCalculation::D0(999.0, line2); \n\t\tCHECK(point2.X() == 1000.0);\n\t\tCHECK(point2.Y() == 0.0);\n\t}}\nSECTION(\"u = M_PI\") {\n\t\tCurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);\n\t\tCHECK(p.X() == -1.0);\n\t\tCHECK(p.Y() == Approx(1.0));\n\t\tCHECK(p.Z() == 0.0);\n\t\tCHECK(v1.X() == Approx(0.0).margin(1e-14));\n\t\tCHECK(v1.Y() == Approx(-2.0));\n\t\tCHECK(v1.Z() == Approx(0.0));\n\t\tCHECK(v2.X() == Approx(2.0));\n\t\tCHECK(v2.Y() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v2.Z() == Approx(0.0));\n\t\tCHECK(v3.X() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v3.Y() == Approx(2.0));\n\t\tCHECK(v3.Z() == Approx(0.0));\n\t;\n\tSECTION(\"u = M_PI\") {\n\t\tCurveCalculation::D2(M_PI, circle2, p, v1,v2);\n\t\tCHECK(p.X() == -1.0);\n\t\tCHECK(p.Y() == Approx(1.0));\n\t\tCHECK(v1.X() == Approx(0.0).margin(1e-12) );\n\t\tCHECK(v1.Y() == -2.0);\n\t\tCHECK(v2.X() == 2.0);\n\t\tCHECK(v2.Y() == Approx(0.0).margin(1e-11));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] AMCAX_API static Vector3 D2(double u, const Line3& line)\t @return The second derivative vector\n\t @param line The line\n\t @param u The parameter\n\t @brief Compute the second derivative on a 3D line at a parameter\n,\n",
      "output": "SECTION(\"u = M_PI\") {\n\t\tCurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);\n\t\tCHECK(p.X() == -1.0);\n\t\tCHECK(p.Y() == Approx(1.0));\n\t\tCHECK(p.Z() == 0.0);\n\t\tCHECK(v1.X() == Approx(0.0).margin(1e-14));\n\t\tCHECK(v1.Y() == Approx(-2.0));\n\t\tCHECK(v1.Z() == Approx(0.0));\n\t\tCHECK(v2.X() == Approx(2.0));\n\t\tCHECK(v2.Y() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v2.Z() == Approx(0.0));\n\t\tCHECK(v3.X() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v3.Y() == Approx(2.0));\n\t\tCHECK(v3.Z() == Approx(0.0));\n\t;\n\tSECTION(\"from (1.0,0.0) POS enlarge 999 length\") {\n\t\tPoint2 point2 = CurveCalculation::D0(999.0, line2); \n\t\tCHECK(point2.X() == 1000.0);\n\t\tCHECK(point2.Y() == 0.0);\n\t}}\nSECTION(\"u = M_PI\") {\n\t\tCurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);\n\t\tCHECK(p.X() == -1.0);\n\t\tCHECK(p.Y() == Approx(1.0));\n\t\tCHECK(p.Z() == 0.0);\n\t\tCHECK(v1.X() == Approx(0.0).margin(1e-14));\n\t\tCHECK(v1.Y() == Approx(-2.0));\n\t\tCHECK(v1.Z() == Approx(0.0));\n\t\tCHECK(v2.X() == Approx(2.0));\n\t\tCHECK(v2.Y() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v2.Z() == Approx(0.0));\n\t\tCHECK(v3.X() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v3.Y() == Approx(2.0));\n\t\tCHECK(v3.Z() == Approx(0.0));\n\t;\n\tSECTION(\"u = M_PI\") {\n\t\tCurveCalculation::D2(M_PI, circle2, p, v1,v2);\n\t\tCHECK(p.X() == -1.0);\n\t\tCHECK(p.Y() == Approx(1.0));\n\t\tCHECK(v1.X() == Approx(0.0).margin(1e-12) );\n\t\tCHECK(v1.Y() == -2.0);\n\t\tCHECK(v2.X() == 2.0);\n\t\tCHECK(v2.Y() == Approx(0.0).margin(1e-11));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static void D1(double u, const Hyperbola2& hyperbola, Point2& p, Vector2& v1)\t @param[out] v1 The first derivative\n\t @param[out] p The point\n\t @param[in] hyperbola The hyperbola\n\t @param[in] u The parameter\n\t @brief Compute the point and the first derivative on a 2D hyperbola at a parameter\n,\n",
      "output": "SECTION(\"u = M_PI\") {\n\t\tCurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);\n\t\tCHECK(p.X() == -1.0);\n\t\tCHECK(p.Y() == Approx(1.0));\n\t\tCHECK(p.Z() == 0.0);\n\t\tCHECK(v1.X() == Approx(0.0).margin(1e-14));\n\t\tCHECK(v1.Y() == Approx(-2.0));\n\t\tCHECK(v1.Z() == Approx(0.0));\n\t\tCHECK(v2.X() == Approx(2.0));\n\t\tCHECK(v2.Y() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v2.Z() == Approx(0.0));\n\t\tCHECK(v3.X() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v3.Y() == Approx(2.0));\n\t\tCHECK(v3.Z() == Approx(0.0));\n\t;\n\tSECTION(\"from (1.0,0.0) POS enlarge 999 length\") {\n\t\tPoint2 point2 = CurveCalculation::D0(999.0, line2); \n\t\tCHECK(point2.X() == 1000.0);\n\t\tCHECK(point2.Y() == 0.0);\n\t}}\nSECTION(\"u = M_PI\") {\n\t\tCurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);\n\t\tCHECK(p.X() == -1.0);\n\t\tCHECK(p.Y() == Approx(1.0));\n\t\tCHECK(p.Z() == 0.0);\n\t\tCHECK(v1.X() == Approx(0.0).margin(1e-14));\n\t\tCHECK(v1.Y() == Approx(-2.0));\n\t\tCHECK(v1.Z() == Approx(0.0));\n\t\tCHECK(v2.X() == Approx(2.0));\n\t\tCHECK(v2.Y() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v2.Z() == Approx(0.0));\n\t\tCHECK(v3.X() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v3.Y() == Approx(2.0));\n\t\tCHECK(v3.Z() == Approx(0.0));\n\t;\n\tSECTION(\"u = M_PI\") {\n\t\tCurveCalculation::D1(M_PI, circle2,p,v);\n\t\tCHECK(p.X() == -1.0);\n\t\tCHECK(p.Y() == Approx(1.0));\n\t\tCHECK(v.X() == Approx(0.0).margin(1e-14));\n\t\tCHECK(v.Y() == Approx(-2.0));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static void D1(double u, const Parabola2& parabola, Point2& p, Vector2& v1)\t @param[out] v1 The first derivative\n\t @param[out] p The point\n\t @param[in] parabola The parabola\n\t @param[in] u The parameter\n\t @brief Compute the point and the first derivative on a 2D parabola at a parameter\n,\n",
      "output": "SECTION(\"u = M_PI\") {\n\t\tCurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);\n\t\tCHECK(p.X() == -1.0);\n\t\tCHECK(p.Y() == Approx(1.0));\n\t\tCHECK(p.Z() == 0.0);\n\t\tCHECK(v1.X() == Approx(0.0).margin(1e-14));\n\t\tCHECK(v1.Y() == Approx(-2.0));\n\t\tCHECK(v1.Z() == Approx(0.0));\n\t\tCHECK(v2.X() == Approx(2.0));\n\t\tCHECK(v2.Y() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v2.Z() == Approx(0.0));\n\t\tCHECK(v3.X() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v3.Y() == Approx(2.0));\n\t\tCHECK(v3.Z() == Approx(0.0));\n\t;\n\tSECTION(\"from (1.0,0.0) POS enlarge 999 length\") {\n\t\tPoint2 point2 = CurveCalculation::D0(999.0, line2); \n\t\tCHECK(point2.X() == 1000.0);\n\t\tCHECK(point2.Y() == 0.0);\n\t}}\nSECTION(\"u = M_PI\") {\n\t\tCurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);\n\t\tCHECK(p.X() == -1.0);\n\t\tCHECK(p.Y() == Approx(1.0));\n\t\tCHECK(p.Z() == 0.0);\n\t\tCHECK(v1.X() == Approx(0.0).margin(1e-14));\n\t\tCHECK(v1.Y() == Approx(-2.0));\n\t\tCHECK(v1.Z() == Approx(0.0));\n\t\tCHECK(v2.X() == Approx(2.0));\n\t\tCHECK(v2.Y() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v2.Z() == Approx(0.0));\n\t\tCHECK(v3.X() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v3.Y() == Approx(2.0));\n\t\tCHECK(v3.Z() == Approx(0.0));\n\t;\n\tSECTION(\"u = M_PI\") {\n\t\tCurveCalculation::D1(M_PI, circle2,p,v);\n\t\tCHECK(p.X() == -1.0);\n\t\tCHECK(p.Y() == Approx(1.0));\n\t\tCHECK(v.X() == Approx(0.0).margin(1e-14));\n\t\tCHECK(v.Y() == Approx(-2.0));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] AMCAX_API static Vector2 D1(double u, const Parabola2& parabola)\t @return The first derivative vector\n\t @param parabola The parabola\n\t @param u The parameter\n\t @brief Compute the first derivative on a 2D parabola at a parameter\n,\n",
      "output": "SECTION(\"u = M_PI\") {\n\t\tCurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);\n\t\tCHECK(p.X() == -1.0);\n\t\tCHECK(p.Y() == Approx(1.0));\n\t\tCHECK(p.Z() == 0.0);\n\t\tCHECK(v1.X() == Approx(0.0).margin(1e-14));\n\t\tCHECK(v1.Y() == Approx(-2.0));\n\t\tCHECK(v1.Z() == Approx(0.0));\n\t\tCHECK(v2.X() == Approx(2.0));\n\t\tCHECK(v2.Y() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v2.Z() == Approx(0.0));\n\t\tCHECK(v3.X() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v3.Y() == Approx(2.0));\n\t\tCHECK(v3.Z() == Approx(0.0));\n\t;\n\tSECTION(\"from (1.0,0.0) POS enlarge 999 length\") {\n\t\tPoint2 point2 = CurveCalculation::D0(999.0, line2); \n\t\tCHECK(point2.X() == 1000.0);\n\t\tCHECK(point2.Y() == 0.0);\n\t}}\nSECTION(\"u = M_PI\") {\n\t\tCurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);\n\t\tCHECK(p.X() == -1.0);\n\t\tCHECK(p.Y() == Approx(1.0));\n\t\tCHECK(p.Z() == 0.0);\n\t\tCHECK(v1.X() == Approx(0.0).margin(1e-14));\n\t\tCHECK(v1.Y() == Approx(-2.0));\n\t\tCHECK(v1.Z() == Approx(0.0));\n\t\tCHECK(v2.X() == Approx(2.0));\n\t\tCHECK(v2.Y() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v2.Z() == Approx(0.0));\n\t\tCHECK(v3.X() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v3.Y() == Approx(2.0));\n\t\tCHECK(v3.Z() == Approx(0.0));\n\t;\n\tSECTION(\"u = M_PI\") {\n\t\tVector2 vector2 = CurveCalculation::D1(M_PI, circle2);\n\t\tCHECK(vector2.X() == Approx(-0.0).margin(1e-12));\n\t\tCHECK(vector2.Y() == -2.0);\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static void D1(double u, const Ellipse2& ellipse, Point2& p, Vector2& v1)\t @param[out] v1 The first derivative\n\t @param[out] p The point\n\t @param[in] ellipse The ellipse\n\t @param[in] u The parameter\n\t @brief Compute the point and the first derivative on a 2D ellipse at a parameter\n,\n",
      "output": "SECTION(\"u = M_PI\") {\n\t\tCurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);\n\t\tCHECK(p.X() == -1.0);\n\t\tCHECK(p.Y() == Approx(1.0));\n\t\tCHECK(p.Z() == 0.0);\n\t\tCHECK(v1.X() == Approx(0.0).margin(1e-14));\n\t\tCHECK(v1.Y() == Approx(-2.0));\n\t\tCHECK(v1.Z() == Approx(0.0));\n\t\tCHECK(v2.X() == Approx(2.0));\n\t\tCHECK(v2.Y() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v2.Z() == Approx(0.0));\n\t\tCHECK(v3.X() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v3.Y() == Approx(2.0));\n\t\tCHECK(v3.Z() == Approx(0.0));\n\t;\n\tSECTION(\"from (1.0,0.0) POS enlarge 999 length\") {\n\t\tPoint2 point2 = CurveCalculation::D0(999.0, line2); \n\t\tCHECK(point2.X() == 1000.0);\n\t\tCHECK(point2.Y() == 0.0);\n\t}}\nSECTION(\"u = M_PI\") {\n\t\tCurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);\n\t\tCHECK(p.X() == -1.0);\n\t\tCHECK(p.Y() == Approx(1.0));\n\t\tCHECK(p.Z() == 0.0);\n\t\tCHECK(v1.X() == Approx(0.0).margin(1e-14));\n\t\tCHECK(v1.Y() == Approx(-2.0));\n\t\tCHECK(v1.Z() == Approx(0.0));\n\t\tCHECK(v2.X() == Approx(2.0));\n\t\tCHECK(v2.Y() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v2.Z() == Approx(0.0));\n\t\tCHECK(v3.X() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v3.Y() == Approx(2.0));\n\t\tCHECK(v3.Z() == Approx(0.0));\n\t;\n\tSECTION(\"u = M_PI\") {\n\t\tCurveCalculation::D1(M_PI, circle2,p,v);\n\t\tCHECK(p.X() == -1.0);\n\t\tCHECK(p.Y() == Approx(1.0));\n\t\tCHECK(v.X() == Approx(0.0).margin(1e-14));\n\t\tCHECK(v.Y() == Approx(-2.0));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] AMCAX_API static Vector2 D1(double u, const Ellipse2& ellipse)\t @return The first derivative vector\n\t @param ellipse The ellipse\n\t @param u The parameter\n\t @brief Compute the first derivative on a 2D ellipse at a parameter\n,\n",
      "output": "SECTION(\"u = M_PI\") {\n\t\tCurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);\n\t\tCHECK(p.X() == -1.0);\n\t\tCHECK(p.Y() == Approx(1.0));\n\t\tCHECK(p.Z() == 0.0);\n\t\tCHECK(v1.X() == Approx(0.0).margin(1e-14));\n\t\tCHECK(v1.Y() == Approx(-2.0));\n\t\tCHECK(v1.Z() == Approx(0.0));\n\t\tCHECK(v2.X() == Approx(2.0));\n\t\tCHECK(v2.Y() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v2.Z() == Approx(0.0));\n\t\tCHECK(v3.X() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v3.Y() == Approx(2.0));\n\t\tCHECK(v3.Z() == Approx(0.0));\n\t;\n\tSECTION(\"from (1.0,0.0) POS enlarge 999 length\") {\n\t\tPoint2 point2 = CurveCalculation::D0(999.0, line2); \n\t\tCHECK(point2.X() == 1000.0);\n\t\tCHECK(point2.Y() == 0.0);\n\t}}\nSECTION(\"u = M_PI\") {\n\t\tCurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);\n\t\tCHECK(p.X() == -1.0);\n\t\tCHECK(p.Y() == Approx(1.0));\n\t\tCHECK(p.Z() == 0.0);\n\t\tCHECK(v1.X() == Approx(0.0).margin(1e-14));\n\t\tCHECK(v1.Y() == Approx(-2.0));\n\t\tCHECK(v1.Z() == Approx(0.0));\n\t\tCHECK(v2.X() == Approx(2.0));\n\t\tCHECK(v2.Y() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v2.Z() == Approx(0.0));\n\t\tCHECK(v3.X() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v3.Y() == Approx(2.0));\n\t\tCHECK(v3.Z() == Approx(0.0));\n\t;\n\tSECTION(\"u = M_PI\") {\n\t\tVector2 vector2 = CurveCalculation::D1(M_PI, circle2);\n\t\tCHECK(vector2.X() == Approx(-0.0).margin(1e-12));\n\t\tCHECK(vector2.Y() == -2.0);\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static void D1(double u, const Circle2& circle, Point2& p, Vector2& v1)\t @param[out] v1 The first derivative\n\t @param[out] p The point\n\t @param[in] circle The circle\n\t @param[in] u The parameter\n\t @brief Compute the point and the first derivative on a 2D circle at a parameter\n,\n",
      "output": "SECTION(\"u = M_PI\") {\n\t\tCurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);\n\t\tCHECK(p.X() == -1.0);\n\t\tCHECK(p.Y() == Approx(1.0));\n\t\tCHECK(p.Z() == 0.0);\n\t\tCHECK(v1.X() == Approx(0.0).margin(1e-14));\n\t\tCHECK(v1.Y() == Approx(-2.0));\n\t\tCHECK(v1.Z() == Approx(0.0));\n\t\tCHECK(v2.X() == Approx(2.0));\n\t\tCHECK(v2.Y() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v2.Z() == Approx(0.0));\n\t\tCHECK(v3.X() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v3.Y() == Approx(2.0));\n\t\tCHECK(v3.Z() == Approx(0.0));\n\t;\n\tSECTION(\"from (1.0,0.0) POS enlarge 999 length\") {\n\t\tPoint2 point2 = CurveCalculation::D0(999.0, line2); \n\t\tCHECK(point2.X() == 1000.0);\n\t\tCHECK(point2.Y() == 0.0);\n\t}}\nSECTION(\"u = M_PI\") {\n\t\tCurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);\n\t\tCHECK(p.X() == -1.0);\n\t\tCHECK(p.Y() == Approx(1.0));\n\t\tCHECK(p.Z() == 0.0);\n\t\tCHECK(v1.X() == Approx(0.0).margin(1e-14));\n\t\tCHECK(v1.Y() == Approx(-2.0));\n\t\tCHECK(v1.Z() == Approx(0.0));\n\t\tCHECK(v2.X() == Approx(2.0));\n\t\tCHECK(v2.Y() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v2.Z() == Approx(0.0));\n\t\tCHECK(v3.X() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v3.Y() == Approx(2.0));\n\t\tCHECK(v3.Z() == Approx(0.0));\n\t;\n\tSECTION(\"u = M_PI\") {\n\t\tCurveCalculation::D1(M_PI, circle2,p,v);\n\t\tCHECK(p.X() == -1.0);\n\t\tCHECK(p.Y() == Approx(1.0));\n\t\tCHECK(v.X() == Approx(0.0).margin(1e-14));\n\t\tCHECK(v.Y() == Approx(-2.0));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] AMCAX_API static Vector2 D1(double u, const Circle2& circle)\t @return The first derivative vector\n\t @param circle The circle\n\t @param u The parameter\n\t @brief Compute the first derivative on a 2D circle at a parameter\n,\n",
      "output": "SECTION(\"u = M_PI\") {\n\t\tCurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);\n\t\tCHECK(p.X() == -1.0);\n\t\tCHECK(p.Y() == Approx(1.0));\n\t\tCHECK(p.Z() == 0.0);\n\t\tCHECK(v1.X() == Approx(0.0).margin(1e-14));\n\t\tCHECK(v1.Y() == Approx(-2.0));\n\t\tCHECK(v1.Z() == Approx(0.0));\n\t\tCHECK(v2.X() == Approx(2.0));\n\t\tCHECK(v2.Y() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v2.Z() == Approx(0.0));\n\t\tCHECK(v3.X() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v3.Y() == Approx(2.0));\n\t\tCHECK(v3.Z() == Approx(0.0));\n\t;\n\tSECTION(\"from (1.0,0.0) POS enlarge 999 length\") {\n\t\tPoint2 point2 = CurveCalculation::D0(999.0, line2); \n\t\tCHECK(point2.X() == 1000.0);\n\t\tCHECK(point2.Y() == 0.0);\n\t}}\nSECTION(\"u = M_PI\") {\n\t\tCurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);\n\t\tCHECK(p.X() == -1.0);\n\t\tCHECK(p.Y() == Approx(1.0));\n\t\tCHECK(p.Z() == 0.0);\n\t\tCHECK(v1.X() == Approx(0.0).margin(1e-14));\n\t\tCHECK(v1.Y() == Approx(-2.0));\n\t\tCHECK(v1.Z() == Approx(0.0));\n\t\tCHECK(v2.X() == Approx(2.0));\n\t\tCHECK(v2.Y() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v2.Z() == Approx(0.0));\n\t\tCHECK(v3.X() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v3.Y() == Approx(2.0));\n\t\tCHECK(v3.Z() == Approx(0.0));\n\t;\n\tSECTION(\"u = M_PI\") {\n\t\tVector2 vector2 = CurveCalculation::D1(M_PI, circle2);\n\t\tCHECK(vector2.X() == Approx(-0.0).margin(1e-12));\n\t\tCHECK(vector2.Y() == -2.0);\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static void D1(double u, const Line2& line, Point2& p, Vector2& v1)\t @param[out] v1 The first derivative\n\t @param[out] p The point\n\t @param[in] line The line\n\t @param[in] u The parameter\n\t @brief Compute the point and the first derivative on a 2D line at a parameter\n,\n",
      "output": "SECTION(\"u = M_PI\") {\n\t\tCurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);\n\t\tCHECK(p.X() == -1.0);\n\t\tCHECK(p.Y() == Approx(1.0));\n\t\tCHECK(p.Z() == 0.0);\n\t\tCHECK(v1.X() == Approx(0.0).margin(1e-14));\n\t\tCHECK(v1.Y() == Approx(-2.0));\n\t\tCHECK(v1.Z() == Approx(0.0));\n\t\tCHECK(v2.X() == Approx(2.0));\n\t\tCHECK(v2.Y() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v2.Z() == Approx(0.0));\n\t\tCHECK(v3.X() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v3.Y() == Approx(2.0));\n\t\tCHECK(v3.Z() == Approx(0.0));\n\t;\n\tSECTION(\"from (1.0,0.0) POS enlarge 999 length\") {\n\t\tPoint2 point2 = CurveCalculation::D0(999.0, line2); \n\t\tCHECK(point2.X() == 1000.0);\n\t\tCHECK(point2.Y() == 0.0);\n\t}}\nSECTION(\"u = M_PI\") {\n\t\tCurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);\n\t\tCHECK(p.X() == -1.0);\n\t\tCHECK(p.Y() == Approx(1.0));\n\t\tCHECK(p.Z() == 0.0);\n\t\tCHECK(v1.X() == Approx(0.0).margin(1e-14));\n\t\tCHECK(v1.Y() == Approx(-2.0));\n\t\tCHECK(v1.Z() == Approx(0.0));\n\t\tCHECK(v2.X() == Approx(2.0));\n\t\tCHECK(v2.Y() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v2.Z() == Approx(0.0));\n\t\tCHECK(v3.X() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v3.Y() == Approx(2.0));\n\t\tCHECK(v3.Z() == Approx(0.0));\n\t;\n\tSECTION(\"u = M_PI\") {\n\t\tCurveCalculation::D1(M_PI, circle2,p,v);\n\t\tCHECK(p.X() == -1.0);\n\t\tCHECK(p.Y() == Approx(1.0));\n\t\tCHECK(v.X() == Approx(0.0).margin(1e-14));\n\t\tCHECK(v.Y() == Approx(-2.0));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] AMCAX_API static Vector2 D1(double u, const Line2& line)\t @return The first derivative vector\n\t @param line The line\n\t @param u The parameter\n\t @brief Compute the first derivative on a 2D line at a parameter\n,\n",
      "output": "SECTION(\"u = M_PI\") {\n\t\tCurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);\n\t\tCHECK(p.X() == -1.0);\n\t\tCHECK(p.Y() == Approx(1.0));\n\t\tCHECK(p.Z() == 0.0);\n\t\tCHECK(v1.X() == Approx(0.0).margin(1e-14));\n\t\tCHECK(v1.Y() == Approx(-2.0));\n\t\tCHECK(v1.Z() == Approx(0.0));\n\t\tCHECK(v2.X() == Approx(2.0));\n\t\tCHECK(v2.Y() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v2.Z() == Approx(0.0));\n\t\tCHECK(v3.X() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v3.Y() == Approx(2.0));\n\t\tCHECK(v3.Z() == Approx(0.0));\n\t;\n\tSECTION(\"from (1.0,0.0) POS enlarge 999 length\") {\n\t\tPoint2 point2 = CurveCalculation::D0(999.0, line2); \n\t\tCHECK(point2.X() == 1000.0);\n\t\tCHECK(point2.Y() == 0.0);\n\t}}\nSECTION(\"u = M_PI\") {\n\t\tCurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);\n\t\tCHECK(p.X() == -1.0);\n\t\tCHECK(p.Y() == Approx(1.0));\n\t\tCHECK(p.Z() == 0.0);\n\t\tCHECK(v1.X() == Approx(0.0).margin(1e-14));\n\t\tCHECK(v1.Y() == Approx(-2.0));\n\t\tCHECK(v1.Z() == Approx(0.0));\n\t\tCHECK(v2.X() == Approx(2.0));\n\t\tCHECK(v2.Y() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v2.Z() == Approx(0.0));\n\t\tCHECK(v3.X() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v3.Y() == Approx(2.0));\n\t\tCHECK(v3.Z() == Approx(0.0));\n\t;\n\tSECTION(\"u = M_PI\") {\n\t\tVector2 vector2 = CurveCalculation::D1(M_PI, circle2);\n\t\tCHECK(vector2.X() == Approx(-0.0).margin(1e-12));\n\t\tCHECK(vector2.Y() == -2.0);\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static void D1(double u, const Hyperbola3& hyperbola, Point3& p, Vector3& v1)\t @param[out] v1 The first derivative\n\t @param[out] p The point\n\t @param[in] hyperbola The hyperbola\n\t @param[in] u The parameter\n\t @brief Compute the point and the first derivative on a 3D hyperbola at a parameter\n,\n",
      "output": "SECTION(\"u = M_PI\") {\n\t\tCurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);\n\t\tCHECK(p.X() == -1.0);\n\t\tCHECK(p.Y() == Approx(1.0));\n\t\tCHECK(p.Z() == 0.0);\n\t\tCHECK(v1.X() == Approx(0.0).margin(1e-14));\n\t\tCHECK(v1.Y() == Approx(-2.0));\n\t\tCHECK(v1.Z() == Approx(0.0));\n\t\tCHECK(v2.X() == Approx(2.0));\n\t\tCHECK(v2.Y() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v2.Z() == Approx(0.0));\n\t\tCHECK(v3.X() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v3.Y() == Approx(2.0));\n\t\tCHECK(v3.Z() == Approx(0.0));\n\t;\n\tSECTION(\"from (1.0,0.0) POS enlarge 999 length\") {\n\t\tPoint2 point2 = CurveCalculation::D0(999.0, line2); \n\t\tCHECK(point2.X() == 1000.0);\n\t\tCHECK(point2.Y() == 0.0);\n\t}}\nSECTION(\"u = M_PI\") {\n\t\tCurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);\n\t\tCHECK(p.X() == -1.0);\n\t\tCHECK(p.Y() == Approx(1.0));\n\t\tCHECK(p.Z() == 0.0);\n\t\tCHECK(v1.X() == Approx(0.0).margin(1e-14));\n\t\tCHECK(v1.Y() == Approx(-2.0));\n\t\tCHECK(v1.Z() == Approx(0.0));\n\t\tCHECK(v2.X() == Approx(2.0));\n\t\tCHECK(v2.Y() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v2.Z() == Approx(0.0));\n\t\tCHECK(v3.X() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v3.Y() == Approx(2.0));\n\t\tCHECK(v3.Z() == Approx(0.0));\n\t;\n\tSECTION(\"u = M_PI\") {\n\t\tCurveCalculation::D1(M_PI, circle2,p,v);\n\t\tCHECK(p.X() == -1.0);\n\t\tCHECK(p.Y() == Approx(1.0));\n\t\tCHECK(v.X() == Approx(0.0).margin(1e-14));\n\t\tCHECK(v.Y() == Approx(-2.0));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] AMCAX_API static Vector3 D1(double u, const Hyperbola3& hyperbola)\t @return The first derivative vector\n\t @param hyperbola The hyperbola\n\t @param u The parameter\n\t @brief Compute the first derivative on a 3D hyperbola at a parameter\n,\n",
      "output": "SECTION(\"u = M_PI\") {\n\t\tCurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);\n\t\tCHECK(p.X() == -1.0);\n\t\tCHECK(p.Y() == Approx(1.0));\n\t\tCHECK(p.Z() == 0.0);\n\t\tCHECK(v1.X() == Approx(0.0).margin(1e-14));\n\t\tCHECK(v1.Y() == Approx(-2.0));\n\t\tCHECK(v1.Z() == Approx(0.0));\n\t\tCHECK(v2.X() == Approx(2.0));\n\t\tCHECK(v2.Y() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v2.Z() == Approx(0.0));\n\t\tCHECK(v3.X() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v3.Y() == Approx(2.0));\n\t\tCHECK(v3.Z() == Approx(0.0));\n\t;\n\tSECTION(\"from (1.0,0.0) POS enlarge 999 length\") {\n\t\tPoint2 point2 = CurveCalculation::D0(999.0, line2); \n\t\tCHECK(point2.X() == 1000.0);\n\t\tCHECK(point2.Y() == 0.0);\n\t}}\nSECTION(\"u = M_PI\") {\n\t\tCurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);\n\t\tCHECK(p.X() == -1.0);\n\t\tCHECK(p.Y() == Approx(1.0));\n\t\tCHECK(p.Z() == 0.0);\n\t\tCHECK(v1.X() == Approx(0.0).margin(1e-14));\n\t\tCHECK(v1.Y() == Approx(-2.0));\n\t\tCHECK(v1.Z() == Approx(0.0));\n\t\tCHECK(v2.X() == Approx(2.0));\n\t\tCHECK(v2.Y() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v2.Z() == Approx(0.0));\n\t\tCHECK(v3.X() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v3.Y() == Approx(2.0));\n\t\tCHECK(v3.Z() == Approx(0.0));\n\t;\n\tSECTION(\"u = M_PI\") {\n\t\tVector3 vector3 = CurveCalculation::D1(M_PI, circle3);\n\t\tCHECK(vector3.X() == Approx(0.0).margin(1e-14));\n\t\tCHECK(vector3.Y() == Approx(-2.0));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static void D1(double u, const Parabola3& parabola, Point3& p, Vector3& v1)\t @param[out] v1 The first derivative\n\t @param[out] p The point\n\t @param[in] parabola The parabola\n\t @param[in] u The parameter\n\t @brief Compute the point and the first derivative on a 3D parabola at a parameter\n,\n",
      "output": "SECTION(\"u = M_PI\") {\n\t\tCurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);\n\t\tCHECK(p.X() == -1.0);\n\t\tCHECK(p.Y() == Approx(1.0));\n\t\tCHECK(p.Z() == 0.0);\n\t\tCHECK(v1.X() == Approx(0.0).margin(1e-14));\n\t\tCHECK(v1.Y() == Approx(-2.0));\n\t\tCHECK(v1.Z() == Approx(0.0));\n\t\tCHECK(v2.X() == Approx(2.0));\n\t\tCHECK(v2.Y() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v2.Z() == Approx(0.0));\n\t\tCHECK(v3.X() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v3.Y() == Approx(2.0));\n\t\tCHECK(v3.Z() == Approx(0.0));\n\t;\n\tSECTION(\"from (1.0,0.0) POS enlarge 999 length\") {\n\t\tPoint2 point2 = CurveCalculation::D0(999.0, line2); \n\t\tCHECK(point2.X() == 1000.0);\n\t\tCHECK(point2.Y() == 0.0);\n\t}}\nSECTION(\"u = M_PI\") {\n\t\tCurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);\n\t\tCHECK(p.X() == -1.0);\n\t\tCHECK(p.Y() == Approx(1.0));\n\t\tCHECK(p.Z() == 0.0);\n\t\tCHECK(v1.X() == Approx(0.0).margin(1e-14));\n\t\tCHECK(v1.Y() == Approx(-2.0));\n\t\tCHECK(v1.Z() == Approx(0.0));\n\t\tCHECK(v2.X() == Approx(2.0));\n\t\tCHECK(v2.Y() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v2.Z() == Approx(0.0));\n\t\tCHECK(v3.X() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v3.Y() == Approx(2.0));\n\t\tCHECK(v3.Z() == Approx(0.0));\n\t;\n\tSECTION(\"u = M_PI\") {\n\t\tCurveCalculation::D1(M_PI, circle2,p,v);\n\t\tCHECK(p.X() == -1.0);\n\t\tCHECK(p.Y() == Approx(1.0));\n\t\tCHECK(v.X() == Approx(0.0).margin(1e-14));\n\t\tCHECK(v.Y() == Approx(-2.0));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] AMCAX_API static Vector3 D1(double u, const Parabola3& parabola)\t @return The first derivative vector\n\t @param parabola The parabola\n\t @param u The parameter\n\t @brief Compute the first derivative on a 3D parabola at a parameter\n,\n",
      "output": "SECTION(\"u = M_PI\") {\n\t\tCurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);\n\t\tCHECK(p.X() == -1.0);\n\t\tCHECK(p.Y() == Approx(1.0));\n\t\tCHECK(p.Z() == 0.0);\n\t\tCHECK(v1.X() == Approx(0.0).margin(1e-14));\n\t\tCHECK(v1.Y() == Approx(-2.0));\n\t\tCHECK(v1.Z() == Approx(0.0));\n\t\tCHECK(v2.X() == Approx(2.0));\n\t\tCHECK(v2.Y() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v2.Z() == Approx(0.0));\n\t\tCHECK(v3.X() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v3.Y() == Approx(2.0));\n\t\tCHECK(v3.Z() == Approx(0.0));\n\t;\n\tSECTION(\"from (1.0,0.0) POS enlarge 999 length\") {\n\t\tPoint2 point2 = CurveCalculation::D0(999.0, line2); \n\t\tCHECK(point2.X() == 1000.0);\n\t\tCHECK(point2.Y() == 0.0);\n\t}}\nSECTION(\"u = M_PI\") {\n\t\tCurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);\n\t\tCHECK(p.X() == -1.0);\n\t\tCHECK(p.Y() == Approx(1.0));\n\t\tCHECK(p.Z() == 0.0);\n\t\tCHECK(v1.X() == Approx(0.0).margin(1e-14));\n\t\tCHECK(v1.Y() == Approx(-2.0));\n\t\tCHECK(v1.Z() == Approx(0.0));\n\t\tCHECK(v2.X() == Approx(2.0));\n\t\tCHECK(v2.Y() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v2.Z() == Approx(0.0));\n\t\tCHECK(v3.X() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v3.Y() == Approx(2.0));\n\t\tCHECK(v3.Z() == Approx(0.0));\n\t;\n\tSECTION(\"u = M_PI\") {\n\t\tVector3 vector3 = CurveCalculation::D1(M_PI, circle3);\n\t\tCHECK(vector3.X() == Approx(0.0).margin(1e-14));\n\t\tCHECK(vector3.Y() == Approx(-2.0));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static void D1(double u, const Ellipse3& ellipse, Point3& p, Vector3& v1)\t @param[out] v1 The first derivative\n\t @param[out] p The point\n\t @param[in] ellipse The ellipse\n\t @param[in] u The parameter\n\t @brief Compute the point and the first derivative on a 3D ellipse at a parameter\n,\n",
      "output": "SECTION(\"u = M_PI\") {\n\t\tCurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);\n\t\tCHECK(p.X() == -1.0);\n\t\tCHECK(p.Y() == Approx(1.0));\n\t\tCHECK(p.Z() == 0.0);\n\t\tCHECK(v1.X() == Approx(0.0).margin(1e-14));\n\t\tCHECK(v1.Y() == Approx(-2.0));\n\t\tCHECK(v1.Z() == Approx(0.0));\n\t\tCHECK(v2.X() == Approx(2.0));\n\t\tCHECK(v2.Y() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v2.Z() == Approx(0.0));\n\t\tCHECK(v3.X() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v3.Y() == Approx(2.0));\n\t\tCHECK(v3.Z() == Approx(0.0));\n\t;\n\tSECTION(\"from (1.0,0.0) POS enlarge 999 length\") {\n\t\tPoint2 point2 = CurveCalculation::D0(999.0, line2); \n\t\tCHECK(point2.X() == 1000.0);\n\t\tCHECK(point2.Y() == 0.0);\n\t}}\nSECTION(\"u = M_PI\") {\n\t\tCurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);\n\t\tCHECK(p.X() == -1.0);\n\t\tCHECK(p.Y() == Approx(1.0));\n\t\tCHECK(p.Z() == 0.0);\n\t\tCHECK(v1.X() == Approx(0.0).margin(1e-14));\n\t\tCHECK(v1.Y() == Approx(-2.0));\n\t\tCHECK(v1.Z() == Approx(0.0));\n\t\tCHECK(v2.X() == Approx(2.0));\n\t\tCHECK(v2.Y() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v2.Z() == Approx(0.0));\n\t\tCHECK(v3.X() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v3.Y() == Approx(2.0));\n\t\tCHECK(v3.Z() == Approx(0.0));\n\t;\n\tSECTION(\"u = M_PI\") {\n\t\tCurveCalculation::D1(M_PI, circle2,p,v);\n\t\tCHECK(p.X() == -1.0);\n\t\tCHECK(p.Y() == Approx(1.0));\n\t\tCHECK(v.X() == Approx(0.0).margin(1e-14));\n\t\tCHECK(v.Y() == Approx(-2.0));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] AMCAX_API static Vector3 D1(double u, const Ellipse3& ellipse)\t @return The first derivative vector\n\t @param ellipse The ellipse\n\t @param u The parameter\n\t @brief Compute the first derivative on a 3D ellipse at a parameter\n,\n",
      "output": "SECTION(\"u = M_PI\") {\n\t\tCurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);\n\t\tCHECK(p.X() == -1.0);\n\t\tCHECK(p.Y() == Approx(1.0));\n\t\tCHECK(p.Z() == 0.0);\n\t\tCHECK(v1.X() == Approx(0.0).margin(1e-14));\n\t\tCHECK(v1.Y() == Approx(-2.0));\n\t\tCHECK(v1.Z() == Approx(0.0));\n\t\tCHECK(v2.X() == Approx(2.0));\n\t\tCHECK(v2.Y() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v2.Z() == Approx(0.0));\n\t\tCHECK(v3.X() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v3.Y() == Approx(2.0));\n\t\tCHECK(v3.Z() == Approx(0.0));\n\t;\n\tSECTION(\"from (1.0,0.0) POS enlarge 999 length\") {\n\t\tPoint2 point2 = CurveCalculation::D0(999.0, line2); \n\t\tCHECK(point2.X() == 1000.0);\n\t\tCHECK(point2.Y() == 0.0);\n\t}}\nSECTION(\"u = M_PI\") {\n\t\tCurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);\n\t\tCHECK(p.X() == -1.0);\n\t\tCHECK(p.Y() == Approx(1.0));\n\t\tCHECK(p.Z() == 0.0);\n\t\tCHECK(v1.X() == Approx(0.0).margin(1e-14));\n\t\tCHECK(v1.Y() == Approx(-2.0));\n\t\tCHECK(v1.Z() == Approx(0.0));\n\t\tCHECK(v2.X() == Approx(2.0));\n\t\tCHECK(v2.Y() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v2.Z() == Approx(0.0));\n\t\tCHECK(v3.X() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v3.Y() == Approx(2.0));\n\t\tCHECK(v3.Z() == Approx(0.0));\n\t;\n\tSECTION(\"u = M_PI\") {\n\t\tVector3 vector3 = CurveCalculation::D1(M_PI, circle3);\n\t\tCHECK(vector3.X() == Approx(0.0).margin(1e-14));\n\t\tCHECK(vector3.Y() == Approx(-2.0));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static void D1(double u, const Circle3& circle, Point3& p, Vector3& v1)\t @param[out] v1 The first derivative\n\t @param[out] p The point\n\t @param[in] circle The circle\n\t @param[in] u The parameter\n\t @brief Compute the point and the first derivative on a 3D circle at a parameter\n,\n",
      "output": "SECTION(\"u = M_PI\") {\n\t\tCurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);\n\t\tCHECK(p.X() == -1.0);\n\t\tCHECK(p.Y() == Approx(1.0));\n\t\tCHECK(p.Z() == 0.0);\n\t\tCHECK(v1.X() == Approx(0.0).margin(1e-14));\n\t\tCHECK(v1.Y() == Approx(-2.0));\n\t\tCHECK(v1.Z() == Approx(0.0));\n\t\tCHECK(v2.X() == Approx(2.0));\n\t\tCHECK(v2.Y() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v2.Z() == Approx(0.0));\n\t\tCHECK(v3.X() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v3.Y() == Approx(2.0));\n\t\tCHECK(v3.Z() == Approx(0.0));\n\t;\n\tSECTION(\"from (1.0,0.0) POS enlarge 999 length\") {\n\t\tPoint2 point2 = CurveCalculation::D0(999.0, line2); \n\t\tCHECK(point2.X() == 1000.0);\n\t\tCHECK(point2.Y() == 0.0);\n\t}}\nSECTION(\"u = M_PI\") {\n\t\tCurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);\n\t\tCHECK(p.X() == -1.0);\n\t\tCHECK(p.Y() == Approx(1.0));\n\t\tCHECK(p.Z() == 0.0);\n\t\tCHECK(v1.X() == Approx(0.0).margin(1e-14));\n\t\tCHECK(v1.Y() == Approx(-2.0));\n\t\tCHECK(v1.Z() == Approx(0.0));\n\t\tCHECK(v2.X() == Approx(2.0));\n\t\tCHECK(v2.Y() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v2.Z() == Approx(0.0));\n\t\tCHECK(v3.X() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v3.Y() == Approx(2.0));\n\t\tCHECK(v3.Z() == Approx(0.0));\n\t;\n\tSECTION(\"u = M_PI\") {\n\t\tCurveCalculation::D1(M_PI, circle2,p,v);\n\t\tCHECK(p.X() == -1.0);\n\t\tCHECK(p.Y() == Approx(1.0));\n\t\tCHECK(v.X() == Approx(0.0).margin(1e-14));\n\t\tCHECK(v.Y() == Approx(-2.0));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] AMCAX_API static Vector3 D1(double u, const Circle3& circle)\t @return The first derivative vector\n\t @param circle The circle\n\t @param u The parameter\n\t @brief Compute the first derivative on a 3D circle at a parameter\n,\n",
      "output": "SECTION(\"u = M_PI\") {\n\t\tCurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);\n\t\tCHECK(p.X() == -1.0);\n\t\tCHECK(p.Y() == Approx(1.0));\n\t\tCHECK(p.Z() == 0.0);\n\t\tCHECK(v1.X() == Approx(0.0).margin(1e-14));\n\t\tCHECK(v1.Y() == Approx(-2.0));\n\t\tCHECK(v1.Z() == Approx(0.0));\n\t\tCHECK(v2.X() == Approx(2.0));\n\t\tCHECK(v2.Y() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v2.Z() == Approx(0.0));\n\t\tCHECK(v3.X() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v3.Y() == Approx(2.0));\n\t\tCHECK(v3.Z() == Approx(0.0));\n\t;\n\tSECTION(\"from (1.0,0.0) POS enlarge 999 length\") {\n\t\tPoint2 point2 = CurveCalculation::D0(999.0, line2); \n\t\tCHECK(point2.X() == 1000.0);\n\t\tCHECK(point2.Y() == 0.0);\n\t}}\nSECTION(\"u = M_PI\") {\n\t\tCurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);\n\t\tCHECK(p.X() == -1.0);\n\t\tCHECK(p.Y() == Approx(1.0));\n\t\tCHECK(p.Z() == 0.0);\n\t\tCHECK(v1.X() == Approx(0.0).margin(1e-14));\n\t\tCHECK(v1.Y() == Approx(-2.0));\n\t\tCHECK(v1.Z() == Approx(0.0));\n\t\tCHECK(v2.X() == Approx(2.0));\n\t\tCHECK(v2.Y() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v2.Z() == Approx(0.0));\n\t\tCHECK(v3.X() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v3.Y() == Approx(2.0));\n\t\tCHECK(v3.Z() == Approx(0.0));\n\t;\n\tSECTION(\"u = M_PI\") {\n\t\tVector3 vector3 = CurveCalculation::D1(M_PI, circle3);\n\t\tCHECK(vector3.X() == Approx(0.0).margin(1e-14));\n\t\tCHECK(vector3.Y() == Approx(-2.0));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static void D1(double u, const Line3& line, Point3& p, Vector3& v1)\t @param[out] v1 The first derivative\n\t @param[out] p The point\n\t @param[in] line The line\n\t @param[in] u The parameter\n\t @brief Compute the point and the first derivative on a 3D line at a parameter\n,\n",
      "output": "SECTION(\"u = M_PI\") {\n\t\tCurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);\n\t\tCHECK(p.X() == -1.0);\n\t\tCHECK(p.Y() == Approx(1.0));\n\t\tCHECK(p.Z() == 0.0);\n\t\tCHECK(v1.X() == Approx(0.0).margin(1e-14));\n\t\tCHECK(v1.Y() == Approx(-2.0));\n\t\tCHECK(v1.Z() == Approx(0.0));\n\t\tCHECK(v2.X() == Approx(2.0));\n\t\tCHECK(v2.Y() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v2.Z() == Approx(0.0));\n\t\tCHECK(v3.X() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v3.Y() == Approx(2.0));\n\t\tCHECK(v3.Z() == Approx(0.0));\n\t;\n\tSECTION(\"from (1.0,0.0) POS enlarge 999 length\") {\n\t\tPoint2 point2 = CurveCalculation::D0(999.0, line2); \n\t\tCHECK(point2.X() == 1000.0);\n\t\tCHECK(point2.Y() == 0.0);\n\t}}\nSECTION(\"u = M_PI\") {\n\t\tCurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);\n\t\tCHECK(p.X() == -1.0);\n\t\tCHECK(p.Y() == Approx(1.0));\n\t\tCHECK(p.Z() == 0.0);\n\t\tCHECK(v1.X() == Approx(0.0).margin(1e-14));\n\t\tCHECK(v1.Y() == Approx(-2.0));\n\t\tCHECK(v1.Z() == Approx(0.0));\n\t\tCHECK(v2.X() == Approx(2.0));\n\t\tCHECK(v2.Y() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v2.Z() == Approx(0.0));\n\t\tCHECK(v3.X() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v3.Y() == Approx(2.0));\n\t\tCHECK(v3.Z() == Approx(0.0));\n\t;\n\tSECTION(\"u = M_PI\") {\n\t\tCurveCalculation::D1(M_PI, circle2,p,v);\n\t\tCHECK(p.X() == -1.0);\n\t\tCHECK(p.Y() == Approx(1.0));\n\t\tCHECK(v.X() == Approx(0.0).margin(1e-14));\n\t\tCHECK(v.Y() == Approx(-2.0));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] AMCAX_API static Vector3 D1(double u, const Line3& line)\t @return The first derivative vector\n\t @param line The line\n\t @param u The parameter\n\t @brief Compute the first derivative on a 3D line at a parameter\n,\n",
      "output": "SECTION(\"u = M_PI\") {\n\t\tCurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);\n\t\tCHECK(p.X() == -1.0);\n\t\tCHECK(p.Y() == Approx(1.0));\n\t\tCHECK(p.Z() == 0.0);\n\t\tCHECK(v1.X() == Approx(0.0).margin(1e-14));\n\t\tCHECK(v1.Y() == Approx(-2.0));\n\t\tCHECK(v1.Z() == Approx(0.0));\n\t\tCHECK(v2.X() == Approx(2.0));\n\t\tCHECK(v2.Y() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v2.Z() == Approx(0.0));\n\t\tCHECK(v3.X() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v3.Y() == Approx(2.0));\n\t\tCHECK(v3.Z() == Approx(0.0));\n\t;\n\tSECTION(\"from (1.0,0.0) POS enlarge 999 length\") {\n\t\tPoint2 point2 = CurveCalculation::D0(999.0, line2); \n\t\tCHECK(point2.X() == 1000.0);\n\t\tCHECK(point2.Y() == 0.0);\n\t}}\nSECTION(\"u = M_PI\") {\n\t\tCurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);\n\t\tCHECK(p.X() == -1.0);\n\t\tCHECK(p.Y() == Approx(1.0));\n\t\tCHECK(p.Z() == 0.0);\n\t\tCHECK(v1.X() == Approx(0.0).margin(1e-14));\n\t\tCHECK(v1.Y() == Approx(-2.0));\n\t\tCHECK(v1.Z() == Approx(0.0));\n\t\tCHECK(v2.X() == Approx(2.0));\n\t\tCHECK(v2.Y() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v2.Z() == Approx(0.0));\n\t\tCHECK(v3.X() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v3.Y() == Approx(2.0));\n\t\tCHECK(v3.Z() == Approx(0.0));\n\t;\n\tSECTION(\"u = M_PI\") {\n\t\tCurveCalculation::D1(M_PI, circle2,p,v);\n\t\tCHECK(p.X() == -1.0);\n\t\tCHECK(p.Y() == Approx(1.0));\n\t\tCHECK(v.X() == Approx(0.0).margin(1e-14));\n\t\tCHECK(v.Y() == Approx(-2.0));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] AMCAX_API static Point2 D0(double u, const Hyperbola2& hyperbola)\t @return The resulting point\n\t @param hyperbola The hyperbola\n\t @param u The parameter\n\t @brief Compute the point on a 2D hyperbola at a parameter\n,\n",
      "output": "SECTION(\"u = M_PI\") {\n\t\tCurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);\n\t\tCHECK(p.X() == -1.0);\n\t\tCHECK(p.Y() == Approx(1.0));\n\t\tCHECK(p.Z() == 0.0);\n\t\tCHECK(v1.X() == Approx(0.0).margin(1e-14));\n\t\tCHECK(v1.Y() == Approx(-2.0));\n\t\tCHECK(v1.Z() == Approx(0.0));\n\t\tCHECK(v2.X() == Approx(2.0));\n\t\tCHECK(v2.Y() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v2.Z() == Approx(0.0));\n\t\tCHECK(v3.X() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v3.Y() == Approx(2.0));\n\t\tCHECK(v3.Z() == Approx(0.0));\n\t;\n\tSECTION(\"from (1.0,0.0) POS enlarge 999 length\") {\n\t\tPoint2 point2 = CurveCalculation::D0(999.0, line2); \n\t\tCHECK(point2.X() == 1000.0);\n\t\tCHECK(point2.Y() == 0.0);\n\t}}\nSECTION(\"u = M_PI\") {\n\t\tCurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);\n\t\tCHECK(p.X() == -1.0);\n\t\tCHECK(p.Y() == Approx(1.0));\n\t\tCHECK(p.Z() == 0.0);\n\t\tCHECK(v1.X() == Approx(0.0).margin(1e-14));\n\t\tCHECK(v1.Y() == Approx(-2.0));\n\t\tCHECK(v1.Z() == Approx(0.0));\n\t\tCHECK(v2.X() == Approx(2.0));\n\t\tCHECK(v2.Y() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v2.Z() == Approx(0.0));\n\t\tCHECK(v3.X() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v3.Y() == Approx(2.0));\n\t\tCHECK(v3.Z() == Approx(0.0));\n\t;\n\tSECTION(\"+999\") {\n\t\tPoint3 point3 = CurveCalculation::D0(999.0, line3);\n\t\tCHECK(point3.X() == 1000.0);\n\t\tCHECK(point3.Y() == 0.0);\n\t\tCHECK(point3.Z() == 0.0);\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] AMCAX_API static Point2 D0(double u, const Parabola2& parabola)\t @return The resulting point\n\t @param parabola The parabola\n\t @param u The parameter\n\t @brief Compute the point on a 2D parabola at a parameter\n,\n",
      "output": "SECTION(\"u = M_PI\") {\n\t\tCurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);\n\t\tCHECK(p.X() == -1.0);\n\t\tCHECK(p.Y() == Approx(1.0));\n\t\tCHECK(p.Z() == 0.0);\n\t\tCHECK(v1.X() == Approx(0.0).margin(1e-14));\n\t\tCHECK(v1.Y() == Approx(-2.0));\n\t\tCHECK(v1.Z() == Approx(0.0));\n\t\tCHECK(v2.X() == Approx(2.0));\n\t\tCHECK(v2.Y() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v2.Z() == Approx(0.0));\n\t\tCHECK(v3.X() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v3.Y() == Approx(2.0));\n\t\tCHECK(v3.Z() == Approx(0.0));\n\t;\n\tSECTION(\"from (1.0,0.0) POS enlarge 999 length\") {\n\t\tPoint2 point2 = CurveCalculation::D0(999.0, line2); \n\t\tCHECK(point2.X() == 1000.0);\n\t\tCHECK(point2.Y() == 0.0);\n\t}}\nSECTION(\"u = M_PI\") {\n\t\tCurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);\n\t\tCHECK(p.X() == -1.0);\n\t\tCHECK(p.Y() == Approx(1.0));\n\t\tCHECK(p.Z() == 0.0);\n\t\tCHECK(v1.X() == Approx(0.0).margin(1e-14));\n\t\tCHECK(v1.Y() == Approx(-2.0));\n\t\tCHECK(v1.Z() == Approx(0.0));\n\t\tCHECK(v2.X() == Approx(2.0));\n\t\tCHECK(v2.Y() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v2.Z() == Approx(0.0));\n\t\tCHECK(v3.X() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v3.Y() == Approx(2.0));\n\t\tCHECK(v3.Z() == Approx(0.0));\n\t;\n\tSECTION(\"u = 4\") {\n\t\tPoint2 point2 = CurveCalculation::D0(4, parabola2); \n\t\tCHECK(point2.X() == 2.0);\n\t\tCHECK(point2.Y() == 4.0);\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] AMCAX_API static Point3 D0(double u, const Parabola3& parabola)\t @return The resulting point\n\t @param parabola The parabola\n\t @param u The parameter\n\t @brief Compute the point on a 3D parabola at a parameter\n,\n",
      "output": "SECTION(\"u = M_PI\") {\n\t\tCurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);\n\t\tCHECK(p.X() == -1.0);\n\t\tCHECK(p.Y() == Approx(1.0));\n\t\tCHECK(p.Z() == 0.0);\n\t\tCHECK(v1.X() == Approx(0.0).margin(1e-14));\n\t\tCHECK(v1.Y() == Approx(-2.0));\n\t\tCHECK(v1.Z() == Approx(0.0));\n\t\tCHECK(v2.X() == Approx(2.0));\n\t\tCHECK(v2.Y() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v2.Z() == Approx(0.0));\n\t\tCHECK(v3.X() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v3.Y() == Approx(2.0));\n\t\tCHECK(v3.Z() == Approx(0.0));\n\t;\n\tSECTION(\"from (1.0,0.0) POS enlarge 999 length\") {\n\t\tPoint2 point2 = CurveCalculation::D0(999.0, line2); \n\t\tCHECK(point2.X() == 1000.0);\n\t\tCHECK(point2.Y() == 0.0);\n\t}}\nSECTION(\"u = M_PI\") {\n\t\tCurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);\n\t\tCHECK(p.X() == -1.0);\n\t\tCHECK(p.Y() == Approx(1.0));\n\t\tCHECK(p.Z() == 0.0);\n\t\tCHECK(v1.X() == Approx(0.0).margin(1e-14));\n\t\tCHECK(v1.Y() == Approx(-2.0));\n\t\tCHECK(v1.Z() == Approx(0.0));\n\t\tCHECK(v2.X() == Approx(2.0));\n\t\tCHECK(v2.Y() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v2.Z() == Approx(0.0));\n\t\tCHECK(v3.X() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v3.Y() == Approx(2.0));\n\t\tCHECK(v3.Z() == Approx(0.0));\n\t;\n\tSECTION(\"+999\") {\n\t\tPoint3 point3 = CurveCalculation::D0(999.0, line3);\n\t\tCHECK(point3.X() == 1000.0);\n\t\tCHECK(point3.Y() == 0.0);\n\t\tCHECK(point3.Z() == 0.0);\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] AMCAX_API static Point3 D0(double u, const Circle3& circle)\t @return The resulting point\n\t @param circle The circle\n\t @param u The parameter\n\t @brief Compute the point on a 3D circle at a parameter\n,\n",
      "output": "SECTION(\"u = M_PI\") {\n\t\tCurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);\n\t\tCHECK(p.X() == -1.0);\n\t\tCHECK(p.Y() == Approx(1.0));\n\t\tCHECK(p.Z() == 0.0);\n\t\tCHECK(v1.X() == Approx(0.0).margin(1e-14));\n\t\tCHECK(v1.Y() == Approx(-2.0));\n\t\tCHECK(v1.Z() == Approx(0.0));\n\t\tCHECK(v2.X() == Approx(2.0));\n\t\tCHECK(v2.Y() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v2.Z() == Approx(0.0));\n\t\tCHECK(v3.X() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v3.Y() == Approx(2.0));\n\t\tCHECK(v3.Z() == Approx(0.0));\n\t;\n\tSECTION(\"from (1.0,0.0) POS enlarge 999 length\") {\n\t\tPoint2 point2 = CurveCalculation::D0(999.0, line2); \n\t\tCHECK(point2.X() == 1000.0);\n\t\tCHECK(point2.Y() == 0.0);\n\t}}\nSECTION(\"u = M_PI\") {\n\t\tCurveCalculation::D3(M_PI, circle3, p, v1, v2,v3);\n\t\tCHECK(p.X() == -1.0);\n\t\tCHECK(p.Y() == Approx(1.0));\n\t\tCHECK(p.Z() == 0.0);\n\t\tCHECK(v1.X() == Approx(0.0).margin(1e-14));\n\t\tCHECK(v1.Y() == Approx(-2.0));\n\t\tCHECK(v1.Z() == Approx(0.0));\n\t\tCHECK(v2.X() == Approx(2.0));\n\t\tCHECK(v2.Y() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v2.Z() == Approx(0.0));\n\t\tCHECK(v3.X() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v3.Y() == Approx(2.0));\n\t\tCHECK(v3.Z() == Approx(0.0));\n\t;\n\tSECTION(\"u = 4\") {\n\t\tPoint3 point3 = CurveCalculation::D0(4, parabola3);\n\t\tCHECK(point3.X() == 2.0);\n\t\tCHECK(point3.Y() == 4.0);\n\t\tCHECK(point3.Z() == 0.0);\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] AMCAX_API static Vector2 CircleDN(double u, const Frame2& pos, double radius, int n)\t @return The n-th derivative vector\n\t @param n The order of derivative\n\t @param radius The radius\n\t @param pos The local frame where the circle lies\n\t @param u The parameter\n\t @brief Compute the n-th derivative on a 2D circle represented by a local frame and a radius at a parameter\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <common/PointT.hpp>\n#include <math/CurveCalculation.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"case1: CurveCalculation::CircleD3 3/4 \", \"[math][CurveCalculation][P1][CircleD3]\") {\n\tDirection3 initialDir(0.0, 0.0, 1.0); \n\tFrame3 defaultFrame3(Point3(1.0, 1.0, 0.0), initialDir); \n\tdouble radius = 2.0; \n\tVector3 tangentAt0 = AMCAX::CurveCalculation::CircleD3(0.0, defaultFrame3, radius);\n\tVector3 tangentAt90Deg = AMCAX::CurveCalculation::CircleD3(M_PI_2, defaultFrame3, radius);\n\tVector3 tangentAt180Deg = AMCAX::CurveCalculation::CircleD3(M_PI, defaultFrame3, radius);\n\tVector3 tangentAt270Deg = AMCAX::CurveCalculation::CircleD3(3 * M_PI_2, defaultFrame3, radius);\n\tVector3 tangentAt360Deg = AMCAX::CurveCalculation::CircleD3(2 * M_PI, defaultFrame3, radius);\n\tCHECK(tangentAt0.X() == Approx(0.0));\n\tCHECK(tangentAt0.Y() == Approx(-2.0));\n\tCHECK(tangentAt0.Z() == Approx(-0.0));\n\tCHECK(tangentAt90Deg.X() == Approx(2.0).margin(1e-14));\n\tCHECK(tangentAt90Deg.Y() == Approx(-0.0).margin(1e-14));\n\tCHECK(tangentAt90Deg.Z() == Approx(0.0).margin(1e-14));\n\tCHECK(tangentAt180Deg.X() == Approx(0.0).margin(1e-14));\n\tCHECK(tangentAt180Deg.Y() == Approx(2.0).margin(1e-14));\n\tCHECK(tangentAt180Deg.Z() == Approx(0.0));\n\tCHECK(tangentAt270Deg.X() == Approx(-2.0).margin(1e-14));\n\tCHECK(tangentAt270Deg.Y() == Approx(0.0).margin(1e-14));\n\tCHECK(tangentAt270Deg.Z() == Approx(0.0).margin(1e-14));\n\tCHECK(tangentAt360Deg.X() == Approx(-0.0).margin(1e-14));\n\tCHECK(tangentAt360Deg.Y() == Approx(-2.0).margin(1e-14));\n\tCHECK(tangentAt360Deg.Z() == Approx(0.0).margin(1e-14));\n\tstd::cout << \"Tangent at 0 deg: \" << tangentAt0 << std::endl;\n\tstd::cout << \"Tangent at 90 deg: \" << tangentAt90Deg << std::endl;\n\tstd::cout << \"Tangent at 180 deg: \" << tangentAt180Deg << std::endl;\n\tstd::cout << \"Tangent at 270 deg: \" << tangentAt270Deg << std::endl;\n\tstd::cout << \"Tangent at 360 deg: \" << tangentAt360Deg << std::endl;\n;\n\tSECTION(\"2 derivative vector\") {\n\t\tVector2  vector2 = CurveCalculation::CircleDN(u, defaultFrame2, r, 2); \n\t\tstd::cout << vector2.X() << \" \" << vector2.Y() << \" \" << std::endl;\n\t\tCHECK(vector2.X() == -2.0);\n\t\tCHECK(vector2.Y() == Approx(0.0).margin(1e-14));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] AMCAX_API static Vector3 CircleDN(double u, const Frame3& pos, double radius, int n)\t @return The n-th derivative vector\n\t @param n The order of derivative\n\t @param radius The radius\n\t @param pos The local frame where the circle lies\n\t @param u The parameter\n\t @brief Compute the n-th derivative on a 3D circle represented by a local frame and a radius at a parameter\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <common/PointT.hpp>\n#include <math/CurveCalculation.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"case1: CurveCalculation::CircleD3 3/4 \", \"[math][CurveCalculation][P1][CircleD3]\") {\n\tDirection3 initialDir(0.0, 0.0, 1.0); \n\tFrame3 defaultFrame3(Point3(1.0, 1.0, 0.0), initialDir); \n\tdouble radius = 2.0; \n\tVector3 tangentAt0 = AMCAX::CurveCalculation::CircleD3(0.0, defaultFrame3, radius);\n\tVector3 tangentAt90Deg = AMCAX::CurveCalculation::CircleD3(M_PI_2, defaultFrame3, radius);\n\tVector3 tangentAt180Deg = AMCAX::CurveCalculation::CircleD3(M_PI, defaultFrame3, radius);\n\tVector3 tangentAt270Deg = AMCAX::CurveCalculation::CircleD3(3 * M_PI_2, defaultFrame3, radius);\n\tVector3 tangentAt360Deg = AMCAX::CurveCalculation::CircleD3(2 * M_PI, defaultFrame3, radius);\n\tCHECK(tangentAt0.X() == Approx(0.0));\n\tCHECK(tangentAt0.Y() == Approx(-2.0));\n\tCHECK(tangentAt0.Z() == Approx(-0.0));\n\tCHECK(tangentAt90Deg.X() == Approx(2.0).margin(1e-14));\n\tCHECK(tangentAt90Deg.Y() == Approx(-0.0).margin(1e-14));\n\tCHECK(tangentAt90Deg.Z() == Approx(0.0).margin(1e-14));\n\tCHECK(tangentAt180Deg.X() == Approx(0.0).margin(1e-14));\n\tCHECK(tangentAt180Deg.Y() == Approx(2.0).margin(1e-14));\n\tCHECK(tangentAt180Deg.Z() == Approx(0.0));\n\tCHECK(tangentAt270Deg.X() == Approx(-2.0).margin(1e-14));\n\tCHECK(tangentAt270Deg.Y() == Approx(0.0).margin(1e-14));\n\tCHECK(tangentAt270Deg.Z() == Approx(0.0).margin(1e-14));\n\tCHECK(tangentAt360Deg.X() == Approx(-0.0).margin(1e-14));\n\tCHECK(tangentAt360Deg.Y() == Approx(-2.0).margin(1e-14));\n\tCHECK(tangentAt360Deg.Z() == Approx(0.0).margin(1e-14));\n\tstd::cout << \"Tangent at 0 deg: \" << tangentAt0 << std::endl;\n\tstd::cout << \"Tangent at 90 deg: \" << tangentAt90Deg << std::endl;\n\tstd::cout << \"Tangent at 180 deg: \" << tangentAt180Deg << std::endl;\n\tstd::cout << \"Tangent at 270 deg: \" << tangentAt270Deg << std::endl;\n\tstd::cout << \"Tangent at 360 deg: \" << tangentAt360Deg << std::endl;\n;\n\tSECTION(\"2 derivative vector\") {\n\t\tVector3  vector3 = CurveCalculation::CircleDN(u, defaultFrame3, radius, 2); \n\t\tstd::cout << vector3.X() << \" \" << vector3.Y() << \" \" << std::endl;\n\t\tCHECK(vector3.X() == -2.0);\n\t\tCHECK(vector3.Y() == Approx(0.0).margin(1e-14));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static void CircleD3(double u, const Frame2& pos, double radius, Point2& p, Vector2& v1, Vector2& v2, Vector2& v3)\t @param[out] v3 The third derivative\n\t @param[out] v2 The second derivative\n\t @param[out] v1 The first derivative\n\t @param[out] p The point\n\t @param[in] radius The radius\n\t @param[in] pos The local frame where the circle lies\n\t @param[in] u The parameter\n\t @brief Compute the point and the first three derivatives on a 2D circle represented by a local frame and a radius at a parameter\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <common/PointT.hpp>\n#include <math/CurveCalculation.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"case1: CurveCalculation::CircleD3 1/4 \", \"[math][CurveCalculation][P1][CircleD3]\") {\n\tDirection2 defaultDir2(1.0, 0.0);\n\tFrame2 defaultFrame2(Point2(1.0, 1.0), defaultDir2);\n\tdouble radius = 2.0;\n\tVector2 tangentAt0 = AMCAX::CurveCalculation::CircleD3(0.0, defaultFrame2, radius);\n\tVector2 tangentAt180 = AMCAX::CurveCalculation::CircleD3(M_PI, defaultFrame2, radius);\n\tVector2 tangentAt360 = AMCAX::CurveCalculation::CircleD3(2 * M_PI, defaultFrame2, radius);\n\tCHECK(tangentAt0.X() == 0.0);\n\tCHECK(tangentAt0.Y() == -2.0);\n\tCHECK(tangentAt180.X() == Approx(0.0).margin(1e-14));\n\tCHECK(tangentAt180.Y() == 2.0 );\n\tCHECK(tangentAt360.X() == Approx(0.0).margin(1e-14));\n\tCHECK(tangentAt360.Y() == -2.0 );\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] AMCAX_API static Vector2 CircleD3(double u, const Frame2& pos, double radius)\t @return The third derivative vector\n\t @param radius The radius\n\t @param pos The local frame where the circle lies\n\t @param u The parameter\n\t @brief Compute the third derivative on a 2D circle represented by a local frame and a radius at a parameter\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <common/PointT.hpp>\n#include <math/CurveCalculation.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"case1: CurveCalculation::CircleD3 1/4 \", \"[math][CurveCalculation][P1][CircleD3]\") {\n\tDirection2 defaultDir2(1.0, 0.0);\n\tFrame2 defaultFrame2(Point2(1.0, 1.0), defaultDir2);\n\tdouble radius = 2.0;\n\tVector2 tangentAt0 = AMCAX::CurveCalculation::CircleD3(0.0, defaultFrame2, radius);\n\tVector2 tangentAt180 = AMCAX::CurveCalculation::CircleD3(M_PI, defaultFrame2, radius);\n\tVector2 tangentAt360 = AMCAX::CurveCalculation::CircleD3(2 * M_PI, defaultFrame2, radius);\n\tCHECK(tangentAt0.X() == 0.0);\n\tCHECK(tangentAt0.Y() == -2.0);\n\tCHECK(tangentAt180.X() == Approx(0.0).margin(1e-14));\n\tCHECK(tangentAt180.Y() == 2.0 );\n\tCHECK(tangentAt360.X() == Approx(0.0).margin(1e-14));\n\tCHECK(tangentAt360.Y() == -2.0 );\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static void CircleD3(double u, const Frame3& pos, double radius, Point3& p, Vector3& v1, Vector3& v2, Vector3& v3)\t @param[out] v3 The third derivative\n\t @param[out] v2 The second derivative\n\t @param[out] v1 The first derivative\n\t @param[out] p The point\n\t @param[in] radius The radius\n\t @param[in] pos The local frame where the circle lies\n\t @param[in] u The parameter\n\t @brief Compute the point and the first three derivatives on a 3D circle represented by a local frame and a radius at a parameter\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <common/PointT.hpp>\n#include <math/CurveCalculation.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"case1: CurveCalculation::CircleD3 3/4 \", \"[math][CurveCalculation][P1][CircleD3]\") {\n\tDirection3 initialDir(0.0, 0.0, 1.0); \n\tFrame3 defaultFrame3(Point3(1.0, 1.0, 0.0), initialDir); \n\tdouble radius = 2.0; \n\tVector3 tangentAt0 = AMCAX::CurveCalculation::CircleD3(0.0, defaultFrame3, radius);\n\tVector3 tangentAt90Deg = AMCAX::CurveCalculation::CircleD3(M_PI_2, defaultFrame3, radius);\n\tVector3 tangentAt180Deg = AMCAX::CurveCalculation::CircleD3(M_PI, defaultFrame3, radius);\n\tVector3 tangentAt270Deg = AMCAX::CurveCalculation::CircleD3(3 * M_PI_2, defaultFrame3, radius);\n\tVector3 tangentAt360Deg = AMCAX::CurveCalculation::CircleD3(2 * M_PI, defaultFrame3, radius);\n\tCHECK(tangentAt0.X() == Approx(0.0));\n\tCHECK(tangentAt0.Y() == Approx(-2.0));\n\tCHECK(tangentAt0.Z() == Approx(-0.0));\n\tCHECK(tangentAt90Deg.X() == Approx(2.0).margin(1e-14));\n\tCHECK(tangentAt90Deg.Y() == Approx(-0.0).margin(1e-14));\n\tCHECK(tangentAt90Deg.Z() == Approx(0.0).margin(1e-14));\n\tCHECK(tangentAt180Deg.X() == Approx(0.0).margin(1e-14));\n\tCHECK(tangentAt180Deg.Y() == Approx(2.0).margin(1e-14));\n\tCHECK(tangentAt180Deg.Z() == Approx(0.0));\n\tCHECK(tangentAt270Deg.X() == Approx(-2.0).margin(1e-14));\n\tCHECK(tangentAt270Deg.Y() == Approx(0.0).margin(1e-14));\n\tCHECK(tangentAt270Deg.Z() == Approx(0.0).margin(1e-14));\n\tCHECK(tangentAt360Deg.X() == Approx(-0.0).margin(1e-14));\n\tCHECK(tangentAt360Deg.Y() == Approx(-2.0).margin(1e-14));\n\tCHECK(tangentAt360Deg.Z() == Approx(0.0).margin(1e-14));\n\tstd::cout << \"Tangent at 0 deg: \" << tangentAt0 << std::endl;\n\tstd::cout << \"Tangent at 90 deg: \" << tangentAt90Deg << std::endl;\n\tstd::cout << \"Tangent at 180 deg: \" << tangentAt180Deg << std::endl;\n\tstd::cout << \"Tangent at 270 deg: \" << tangentAt270Deg << std::endl;\n\tstd::cout << \"Tangent at 360 deg: \" << tangentAt360Deg << std::endl;\n;\n\tSECTION(\"0 deg case\") {\n\t\tAMCAX::CurveCalculation::CircleD3(0.0, defaultFrame3, radius, p, v1, v2, v3);\n\t\tCHECK(p.X() == 3.0);\n\t\tCHECK(p.Y() == 1.0);\n\t\tCHECK(p.Z() == 0.0);\n\t\tCHECK(v1.X() == Approx(0.0));\n\t\tCHECK(v1.Y() == Approx(2.0));\n\t\tCHECK(v1.Z() == Approx(0.0));\n\t\tCHECK(v2.X() == Approx(-2.0));\n\t\tCHECK(v2.Y() == Approx(0.0));\n\t\tCHECK(v2.Z() == Approx(0.0));\n\t\tCHECK(v3.X() == Approx(0.0));\n\t\tCHECK(v3.Y() == Approx(-2.0).margin(1e-14));\n\t\tCHECK(v3.Z() == Approx(-0.0));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] AMCAX_API static Vector3 CircleD3(double u, const Frame3& pos, double radius)\t @return The third derivative vector\n\t @param radius The radius\n\t @param pos The local frame where the circle lies\n\t @param u The parameter\n\t @brief Compute the third derivative on a 3D circle represented by a local frame and a radius at a parameter\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <common/PointT.hpp>\n#include <math/CurveCalculation.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"case1: CurveCalculation::CircleD3 3/4 \", \"[math][CurveCalculation][P1][CircleD3]\") {\n\tDirection3 initialDir(0.0, 0.0, 1.0); \n\tFrame3 defaultFrame3(Point3(1.0, 1.0, 0.0), initialDir); \n\tdouble radius = 2.0; \n\tVector3 tangentAt0 = AMCAX::CurveCalculation::CircleD3(0.0, defaultFrame3, radius);\n\tVector3 tangentAt90Deg = AMCAX::CurveCalculation::CircleD3(M_PI_2, defaultFrame3, radius);\n\tVector3 tangentAt180Deg = AMCAX::CurveCalculation::CircleD3(M_PI, defaultFrame3, radius);\n\tVector3 tangentAt270Deg = AMCAX::CurveCalculation::CircleD3(3 * M_PI_2, defaultFrame3, radius);\n\tVector3 tangentAt360Deg = AMCAX::CurveCalculation::CircleD3(2 * M_PI, defaultFrame3, radius);\n\tCHECK(tangentAt0.X() == Approx(0.0));\n\tCHECK(tangentAt0.Y() == Approx(-2.0));\n\tCHECK(tangentAt0.Z() == Approx(-0.0));\n\tCHECK(tangentAt90Deg.X() == Approx(2.0).margin(1e-14));\n\tCHECK(tangentAt90Deg.Y() == Approx(-0.0).margin(1e-14));\n\tCHECK(tangentAt90Deg.Z() == Approx(0.0).margin(1e-14));\n\tCHECK(tangentAt180Deg.X() == Approx(0.0).margin(1e-14));\n\tCHECK(tangentAt180Deg.Y() == Approx(2.0).margin(1e-14));\n\tCHECK(tangentAt180Deg.Z() == Approx(0.0));\n\tCHECK(tangentAt270Deg.X() == Approx(-2.0).margin(1e-14));\n\tCHECK(tangentAt270Deg.Y() == Approx(0.0).margin(1e-14));\n\tCHECK(tangentAt270Deg.Z() == Approx(0.0).margin(1e-14));\n\tCHECK(tangentAt360Deg.X() == Approx(-0.0).margin(1e-14));\n\tCHECK(tangentAt360Deg.Y() == Approx(-2.0).margin(1e-14));\n\tCHECK(tangentAt360Deg.Z() == Approx(0.0).margin(1e-14));\n\tstd::cout << \"Tangent at 0 deg: \" << tangentAt0 << std::endl;\n\tstd::cout << \"Tangent at 90 deg: \" << tangentAt90Deg << std::endl;\n\tstd::cout << \"Tangent at 180 deg: \" << tangentAt180Deg << std::endl;\n\tstd::cout << \"Tangent at 270 deg: \" << tangentAt270Deg << std::endl;\n\tstd::cout << \"Tangent at 360 deg: \" << tangentAt360Deg << std::endl;\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static void CircleD2(double u, const Frame2& pos, double radius, Point2& p, Vector2& v1, Vector2& v2)\t @param[out] v2 The second derivative\n\t @param[out] v1 The first derivative\n\t @param[out] p The point\n\t @param[in] radius The radius\n\t @param[in] pos The local frame where the circle lies\n\t @param[in] u The parameter\n\t @brief Compute the point and the first two derivatives on a 2D circle represented by a local frame and a radius at a parameter\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <common/PointT.hpp>\n#include <math/CurveCalculation.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"case1: CurveCalculation::CircleD2 2/4 \", \"[math][CurveCalculation][P1][CircleD2]\") {\n\tDirection2 defaultDirection(1.0, 0.0);\n\tFrame2 defaultFrame2(Point2(1.0, 1.0), defaultDirection);\n\tdouble r = 3.0;\n\tdouble u = 0.0;\n\tVector2 v1;\n\tVector2 v2;\n\tPoint2 p;\n\tCurveCalculation::CircleD2(u, defaultFrame2, r, p, v1, v2);\n\tCHECK(p.X() == 4.0);\n\tCHECK(p.Y() == 1.0 );\n\tCHECK(v1.X() == 0.0 );\n\tCHECK(v1.Y() == 3.0);\n\tCHECK(v2.X() == -3.0);\n\tCHECK(v2.Y() == 0.0);\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] AMCAX_API static Vector2 CircleD2(double u, const Frame2& pos, double radius)\t @return The second derivative vector\n\t @param radius The radius\n\t @param pos The local frame where the circle lies\n\t @param u The parameter\n\t @brief Compute the second derivative on a 2D circle represented by a local frame and a radius at a parameter\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <common/PointT.hpp>\n#include <math/CurveCalculation.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"case1: CurveCalculation::CircleD2 1/4 \", \"[math][CurveCalculation][P1][CircleD2]\") {\n\tDirection2 defaultDirection(1.0, 0.0); \n\tFrame2 defaultFrame2(Point2(0.0, 0.0), defaultDirection);\n\tdouble \tr = 2.0;\n\tdouble u = 0.0; \n\tVector2  vector2 = CurveCalculation::CircleD2(u, defaultFrame2, r); \n\tstd::cout << vector2.X() << \" \" << vector2.Y() << \" \" << std::endl;\n\tCHECK(vector2.X() == -2.0);\n\tCHECK(vector2.Y() == Approx(0.0).margin(1e-14));\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static void CircleD2(double u, const Frame3& pos, double radius, Point3& p, Vector3& v1, Vector3& v2)\t @param[out] v2 The second derivative\n\t @param[out] v1 The first derivative\n\t @param[out] p The point\n\t @param[in] radius The radius\n\t @param[in] pos The local frame where the circle lies\n\t @param[in] u The parameter\n\t @brief Compute the point and the first two derivatives on a 3D circle represented by a local frame and a radius at a parameter\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <common/PointT.hpp>\n#include <math/CurveCalculation.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"case1: CurveCalculation::CircleD2 3/4 \", \"[math][CurveCalculation][P1][CircleD2]\") {\n\tDirection3 initialDir(0.0, 0.0, 1.0); \n\tFrame3 defaultFrame3(Point3(1.0, 1.0, 0.0), initialDir); \n\tdouble radius = 2.0; \n\tVector3 tangentAt0 = AMCAX::CurveCalculation::CircleD2(0.0, defaultFrame3, radius);\n\tVector3 tangentAt90Deg = AMCAX::CurveCalculation::CircleD2(M_PI_2, defaultFrame3, radius);\n\tVector3 tangentAt180Deg = AMCAX::CurveCalculation::CircleD2(M_PI, defaultFrame3, radius);\n\tVector3 tangentAt270Deg = AMCAX::CurveCalculation::CircleD2(3 * M_PI_2, defaultFrame3, radius);\n\tVector3 tangentAt360Deg = AMCAX::CurveCalculation::CircleD2(2 * M_PI, defaultFrame3, radius);\n\tCHECK(tangentAt0.X() == Approx(-2.0));\n\tCHECK(tangentAt0.Y() == Approx(-0.0));\n\tCHECK(tangentAt0.Z() == Approx(0.0));\n\tCHECK(tangentAt90Deg.X() == Approx(-0.0).margin(1e-14));\n\tCHECK(tangentAt90Deg.Y() == Approx(-2.0).margin(1e-14));\n\tCHECK(tangentAt90Deg.Z() == Approx(0.0).margin(1e-14));\n\tCHECK(tangentAt180Deg.X() == Approx(2.0).margin(1e-14));\n\tCHECK(tangentAt180Deg.Y() == Approx(-0.0).margin(1e-14));\n\tCHECK(tangentAt180Deg.Z() == Approx(-0.0));\n\tCHECK(tangentAt270Deg.X() == Approx(0.0).margin(1e-14));\n\tCHECK(tangentAt270Deg.Y() == Approx(2.0).margin(1e-14));\n\tCHECK(tangentAt270Deg.Z() == Approx(0.0).margin(1e-14));\n\tCHECK(tangentAt360Deg.X() == Approx(-2.0).margin(1e-14));\n\tCHECK(tangentAt360Deg.Y() == Approx(0.0).margin(1e-14));\n\tCHECK(tangentAt360Deg.Z() == Approx(0.0).margin(1e-14));\n\tstd::cout << \"Tangent at 0 deg: \" << tangentAt0 << std::endl;\n\tstd::cout << \"Tangent at 90 deg: \" << tangentAt90Deg << std::endl;\n\tstd::cout << \"Tangent at 180 deg: \" << tangentAt180Deg << std::endl;\n\tstd::cout << \"Tangent at 270 deg: \" << tangentAt270Deg << std::endl;\n\tstd::cout << \"Tangent at 360 deg: \" << tangentAt360Deg << std::endl;\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] AMCAX_API static Vector3 CircleD2(double u, const Frame3& pos, double radius)\t @return The second derivative vector\n\t @param radius The radius\n\t @param pos The local frame where the circle lies\n\t @param u The parameter\n\t @brief Compute the second derivative on a 3D circle represented by a local frame and a radius at a parameter\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <common/PointT.hpp>\n#include <math/CurveCalculation.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"case1: CurveCalculation::CircleD2 3/4 \", \"[math][CurveCalculation][P1][CircleD2]\") {\n\tDirection3 initialDir(0.0, 0.0, 1.0); \n\tFrame3 defaultFrame3(Point3(1.0, 1.0, 0.0), initialDir); \n\tdouble radius = 2.0; \n\tVector3 tangentAt0 = AMCAX::CurveCalculation::CircleD2(0.0, defaultFrame3, radius);\n\tVector3 tangentAt90Deg = AMCAX::CurveCalculation::CircleD2(M_PI_2, defaultFrame3, radius);\n\tVector3 tangentAt180Deg = AMCAX::CurveCalculation::CircleD2(M_PI, defaultFrame3, radius);\n\tVector3 tangentAt270Deg = AMCAX::CurveCalculation::CircleD2(3 * M_PI_2, defaultFrame3, radius);\n\tVector3 tangentAt360Deg = AMCAX::CurveCalculation::CircleD2(2 * M_PI, defaultFrame3, radius);\n\tCHECK(tangentAt0.X() == Approx(-2.0));\n\tCHECK(tangentAt0.Y() == Approx(-0.0));\n\tCHECK(tangentAt0.Z() == Approx(0.0));\n\tCHECK(tangentAt90Deg.X() == Approx(-0.0).margin(1e-14));\n\tCHECK(tangentAt90Deg.Y() == Approx(-2.0).margin(1e-14));\n\tCHECK(tangentAt90Deg.Z() == Approx(0.0).margin(1e-14));\n\tCHECK(tangentAt180Deg.X() == Approx(2.0).margin(1e-14));\n\tCHECK(tangentAt180Deg.Y() == Approx(-0.0).margin(1e-14));\n\tCHECK(tangentAt180Deg.Z() == Approx(-0.0));\n\tCHECK(tangentAt270Deg.X() == Approx(0.0).margin(1e-14));\n\tCHECK(tangentAt270Deg.Y() == Approx(2.0).margin(1e-14));\n\tCHECK(tangentAt270Deg.Z() == Approx(0.0).margin(1e-14));\n\tCHECK(tangentAt360Deg.X() == Approx(-2.0).margin(1e-14));\n\tCHECK(tangentAt360Deg.Y() == Approx(0.0).margin(1e-14));\n\tCHECK(tangentAt360Deg.Z() == Approx(0.0).margin(1e-14));\n\tstd::cout << \"Tangent at 0 deg: \" << tangentAt0 << std::endl;\n\tstd::cout << \"Tangent at 90 deg: \" << tangentAt90Deg << std::endl;\n\tstd::cout << \"Tangent at 180 deg: \" << tangentAt180Deg << std::endl;\n\tstd::cout << \"Tangent at 270 deg: \" << tangentAt270Deg << std::endl;\n\tstd::cout << \"Tangent at 360 deg: \" << tangentAt360Deg << std::endl;\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static void CircleD1(double u, const Frame2& pos, double radius, Point2& p, Vector2& v1)\t @param[out] v1 The first derivative\n\t @param[out] p The point\n\t @param[in] radius The radius\n\t @param[in] pos The local frame where the circle lies\n\t @param[in] u The parameter\n\t @brief Compute the point and the first derivative on a 2D circle represented by a local frame and a radius at a parameter\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <common/PointT.hpp>\n#include <math/CurveCalculation.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"case1: CurveCalculation::CircleD1 1/4 \", \"[math][CurveCalculation][P1][CircleD1]\") {\n\tDirection2 initialDir(1.0, 0.0); \n\tFrame2 defaultFrame2(Point2(1.0, 1.0), initialDir); \n\tdouble radius = 2.0; \n\tVector2 tangentAt0 = AMCAX::CurveCalculation::CircleD1(0.0, defaultFrame2, radius);\n\tVector2 tangentAt90Deg = AMCAX::CurveCalculation::CircleD1(M_PI_2, defaultFrame2, radius);\n\tVector2 tangentAt180Deg = AMCAX::CurveCalculation::CircleD1(M_PI, defaultFrame2, radius);\n\tVector2 tangentAt270Deg = AMCAX::CurveCalculation::CircleD1(3 * M_PI_2, defaultFrame2, radius);\n\tVector2 tangentAt360Deg = AMCAX::CurveCalculation::CircleD1(2 * M_PI, defaultFrame2, radius);\n\tCHECK(tangentAt0.X() == Approx(-0.0));\n\tCHECK(tangentAt0.Y() == Approx(2.0));\n\tCHECK(tangentAt90Deg.X() == Approx(-2.0));\n\tCHECK(tangentAt90Deg.Y() == Approx(0.0).margin(1e-14));\n\tCHECK(tangentAt180Deg.X() == Approx(-0.0).margin(1e-14));\n\tCHECK(tangentAt180Deg.Y() == Approx(-2.0));\n\tCHECK(tangentAt270Deg.X() == Approx(2.0));\n\tCHECK(tangentAt270Deg.Y() == Approx(-0.0).margin(1e-14));\n\tCHECK(tangentAt360Deg.X() == Approx(0.0).margin(1e-14));\n\tCHECK(tangentAt360Deg.Y() == Approx(2.0));\n\tstd::cout << \"Tangent at 0 deg: \" << tangentAt0 << std::endl;\n\tstd::cout << \"Tangent at 90 deg: \" << tangentAt90Deg << std::endl;\n\tstd::cout << \"Tangent at 180 deg: \" << tangentAt180Deg << std::endl;\n\tstd::cout << \"Tangent at 270 deg: \" << tangentAt270Deg << std::endl;\n\tstd::cout << \"Tangent at 360 deg: \" << tangentAt360Deg << std::endl;\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] AMCAX_API static Vector2 CircleD1(double u, const Frame2& pos, double radius)\t @return The first derivative vector\n\t @param radius The radius\n\t @param pos The local frame where the circle lies\n\t @param u The parameter\n\t @brief Compute the first derivative on a 2D circle represented by a local frame and a radius at a parameter\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <common/PointT.hpp>\n#include <math/CurveCalculation.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"case1: CurveCalculation::CircleD1 1/4 \", \"[math][CurveCalculation][P1][CircleD1]\") {\n\tDirection2 initialDir(1.0, 0.0); \n\tFrame2 defaultFrame2(Point2(1.0, 1.0), initialDir); \n\tdouble radius = 2.0; \n\tVector2 tangentAt0 = AMCAX::CurveCalculation::CircleD1(0.0, defaultFrame2, radius);\n\tVector2 tangentAt90Deg = AMCAX::CurveCalculation::CircleD1(M_PI_2, defaultFrame2, radius);\n\tVector2 tangentAt180Deg = AMCAX::CurveCalculation::CircleD1(M_PI, defaultFrame2, radius);\n\tVector2 tangentAt270Deg = AMCAX::CurveCalculation::CircleD1(3 * M_PI_2, defaultFrame2, radius);\n\tVector2 tangentAt360Deg = AMCAX::CurveCalculation::CircleD1(2 * M_PI, defaultFrame2, radius);\n\tCHECK(tangentAt0.X() == Approx(-0.0));\n\tCHECK(tangentAt0.Y() == Approx(2.0));\n\tCHECK(tangentAt90Deg.X() == Approx(-2.0));\n\tCHECK(tangentAt90Deg.Y() == Approx(0.0).margin(1e-14));\n\tCHECK(tangentAt180Deg.X() == Approx(-0.0).margin(1e-14));\n\tCHECK(tangentAt180Deg.Y() == Approx(-2.0));\n\tCHECK(tangentAt270Deg.X() == Approx(2.0));\n\tCHECK(tangentAt270Deg.Y() == Approx(-0.0).margin(1e-14));\n\tCHECK(tangentAt360Deg.X() == Approx(0.0).margin(1e-14));\n\tCHECK(tangentAt360Deg.Y() == Approx(2.0));\n\tstd::cout << \"Tangent at 0 deg: \" << tangentAt0 << std::endl;\n\tstd::cout << \"Tangent at 90 deg: \" << tangentAt90Deg << std::endl;\n\tstd::cout << \"Tangent at 180 deg: \" << tangentAt180Deg << std::endl;\n\tstd::cout << \"Tangent at 270 deg: \" << tangentAt270Deg << std::endl;\n\tstd::cout << \"Tangent at 360 deg: \" << tangentAt360Deg << std::endl;\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static void CircleD1(double u, const Frame3& pos, double radius, Point3& p, Vector3& v1)\t @param[out] v1 The first derivative\n\t @param[out] p The point\n\t @param[in] radius The radius\n\t @param[in] pos The local frame where the circle lies\n\t @param[in] u The parameter\n\t @brief Compute the point and the first derivative on a 3D circle represented by a local frame and a radius at a parameter\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <common/PointT.hpp>\n#include <math/CurveCalculation.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"case2: CurveCalculation::CircleD1 1/4 \", \"[math][CurveCalculation][P1][CircleD1]\") {\n\tDirection2 initialDir(1.0, 0.0); \n\tFrame2 defaultFrame2(Point2(0.0, 0.0), initialDir); \n\tdouble radius = 2.0; \n\tVector2 tangentAt0 = AMCAX::CurveCalculation::CircleD1(0.0, defaultFrame2, radius);\n\tVector2 tangentAt90Deg = AMCAX::CurveCalculation::CircleD1(M_PI_2, defaultFrame2, radius);\n\tVector2 tangentAt180Deg = AMCAX::CurveCalculation::CircleD1(M_PI, defaultFrame2, radius);\n\tVector2 tangentAt270Deg = AMCAX::CurveCalculation::CircleD1(3 * M_PI_2, defaultFrame2, radius);\n\tVector2 tangentAt360Deg = AMCAX::CurveCalculation::CircleD1(2 * M_PI, defaultFrame2, radius);\n\tCHECK(tangentAt0.X() == Approx(0.0));\n\tCHECK(tangentAt0.Y() == Approx(2.0));\n\tCHECK(tangentAt90Deg.X() == Approx(-2.0));\n\tCHECK(tangentAt90Deg.Y() == Approx(0.0).margin(1e-14));\n\tCHECK(tangentAt180Deg.X() == Approx(0.0).margin(1e-14));\n\tCHECK(tangentAt180Deg.Y() == Approx(-2.0));\n\tCHECK(tangentAt270Deg.X() == Approx(2.0));\n\tCHECK(tangentAt270Deg.Y() == Approx(-0.0).margin(1e-14));\n\tCHECK(tangentAt360Deg.X() == Approx(0.0).margin(1e-14));\n\tCHECK(tangentAt360Deg.Y() == Approx(2.0));\n\tstd::cout << \"Tangent at 0 deg: \" << tangentAt0 << std::endl;\n\tstd::cout << \"Tangent at 90 deg: \" << tangentAt90Deg << std::endl;\n\tstd::cout << \"Tangent at 180 deg: \" << tangentAt180Deg << std::endl;\n\tstd::cout << \"Tangent at 270 deg: \" << tangentAt270Deg << std::endl;\n\tstd::cout << \"Tangent at 360 deg: \" << tangentAt360Deg << std::endl;\n;\n\tSECTION(\"0 deg case\") {\n\t\tAMCAX::CurveCalculation::CircleD1(0.0, defaultFrame2,radius, p, v);\n\t\tCHECK(p.X() == 3.0);\n\t\tCHECK(p.Y() == 1.0);\n\t\tCHECK(v.X() == Approx(0.0));\n\t\tCHECK(v.Y() == Approx(2.0));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] AMCAX_API static Vector3 CircleD1(double u, const Frame3& pos, double radius)\t @return The first derivative vector\n\t @param radius The radius\n\t @param pos The local frame where the circle lies\n\t @param u The parameter\n\t @brief Compute the first derivative on a 3D circle represented by a local frame and a radius at a parameter\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <common/PointT.hpp>\n#include <math/CurveCalculation.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"case1: CurveCalculation::CircleD1 1/4 \", \"[math][CurveCalculation][P1][CircleD1]\") {\n\tDirection2 initialDir(1.0, 0.0); \n\tFrame2 defaultFrame2(Point2(1.0, 1.0), initialDir); \n\tdouble radius = 2.0; \n\tVector2 tangentAt0 = AMCAX::CurveCalculation::CircleD1(0.0, defaultFrame2, radius);\n\tVector2 tangentAt90Deg = AMCAX::CurveCalculation::CircleD1(M_PI_2, defaultFrame2, radius);\n\tVector2 tangentAt180Deg = AMCAX::CurveCalculation::CircleD1(M_PI, defaultFrame2, radius);\n\tVector2 tangentAt270Deg = AMCAX::CurveCalculation::CircleD1(3 * M_PI_2, defaultFrame2, radius);\n\tVector2 tangentAt360Deg = AMCAX::CurveCalculation::CircleD1(2 * M_PI, defaultFrame2, radius);\n\tCHECK(tangentAt0.X() == Approx(-0.0));\n\tCHECK(tangentAt0.Y() == Approx(2.0));\n\tCHECK(tangentAt90Deg.X() == Approx(-2.0));\n\tCHECK(tangentAt90Deg.Y() == Approx(0.0).margin(1e-14));\n\tCHECK(tangentAt180Deg.X() == Approx(-0.0).margin(1e-14));\n\tCHECK(tangentAt180Deg.Y() == Approx(-2.0));\n\tCHECK(tangentAt270Deg.X() == Approx(2.0));\n\tCHECK(tangentAt270Deg.Y() == Approx(-0.0).margin(1e-14));\n\tCHECK(tangentAt360Deg.X() == Approx(0.0).margin(1e-14));\n\tCHECK(tangentAt360Deg.Y() == Approx(2.0));\n\tstd::cout << \"Tangent at 0 deg: \" << tangentAt0 << std::endl;\n\tstd::cout << \"Tangent at 90 deg: \" << tangentAt90Deg << std::endl;\n\tstd::cout << \"Tangent at 180 deg: \" << tangentAt180Deg << std::endl;\n\tstd::cout << \"Tangent at 270 deg: \" << tangentAt270Deg << std::endl;\n\tstd::cout << \"Tangent at 360 deg: \" << tangentAt360Deg << std::endl;\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] AMCAX_API static Point2 CircleD0(double u, const Frame2& pos, double radius)\t @return The point\n\t @param radius The radius\n\t @param pos The local frame where the circle lies\n\t @param u The parameter\n\t @brief Compute the point on a 2D circle represented by a local frame and a radius at a parameter\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <common/PointT.hpp>\n#include <math/CurveCalculation.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"case1: CurveCalculation::CircleD0 1/2 \", \"[math][CurveCalculation][P1]\") {\n\tDirection2 defaultDirection(1.0,0.0); \n\tFrame2 defaultFrame2(Point2(0.0, 0.0), defaultDirection);\n\tdouble \tr = 3.0;\n\tdouble u = 4 * M_PI ; \n\tPoint2  pointOnCirecle = CurveCalculation::CircleD0(u, defaultFrame2, r);\n\tstd::cout << pointOnCirecle.X() << \" \" << pointOnCirecle.Y() << \" \"  << std::endl;\n\tCHECK(pointOnCirecle.X() == 3.0);\n\tCHECK(pointOnCirecle.Y() == Approx(0.0).margin(1e-14));\n\tCHECK(pointOnCirecle.X() * pointOnCirecle.X() + pointOnCirecle.Y() * pointOnCirecle.Y() == r * r);\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] AMCAX_API static Point3 CircleD0(double u, const Frame3& pos, double radius)\t @return The point\n\t @param radius The radius\n\t @param pos The local frame where the circle lies\n\t @param u The parameter\n\t @brief Compute the point on a 3D circle represented by a local frame and a radius at a parameter\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <common/PointT.hpp>\n#include <math/CurveCalculation.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"case1: CurveCalculation::CircleD0 2/2 \", \"[math][CurveCalculation][P1]\") {\n\tDirection3 defaultDirection(-1.0, 0.0,0.0); \n\tFrame3 defaultFrame3(Point3(1.0, 0.0,0.0), defaultDirection);\n\tdouble \tr = 3.0;\n\tdouble u = 2 * M_PI / 4; \n\tPoint3  pointOnCirecle = CurveCalculation::CircleD0(u, defaultFrame3, r);\n\tstd::cout << pointOnCirecle.X() << \" \" << pointOnCirecle.Y() << \" \" << pointOnCirecle.Y() << std::endl;\n\tCHECK(pointOnCirecle.X() == Approx(1.0).epsilon(1e-12));\n\tCHECK(pointOnCirecle.Y() == -3.0);\n\tCHECK((pointOnCirecle.X() - 1.0) * (pointOnCirecle.X() - 1.0) + pointOnCirecle.Y() * pointOnCirecle.Y() == r * r);\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] AMCAX_API static Point2 CircleValue(double u, const Frame2& pos, double radius)\t @return The point\n\t @param radius The radius\n\t @param pos The local frame where the circle lies\n\t @param u The parameter\n\t @brief Compute the point on a 2D circle represented by a local frame and a radius at a parameter\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <common/PointT.hpp>\n#include <math/CurveCalculation.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"case1: CurveCalculation::CircleD3 1/4 \", \"[math][CurveCalculation][P1][CircleD3]\") {\n\tDirection2 defaultDir2(1.0, 0.0);\n\tFrame2 defaultFrame2(Point2(1.0, 1.0), defaultDir2);\n\tdouble radius = 2.0;\n\tVector2 tangentAt0 = AMCAX::CurveCalculation::CircleD3(0.0, defaultFrame2, radius);\n\tVector2 tangentAt180 = AMCAX::CurveCalculation::CircleD3(M_PI, defaultFrame2, radius);\n\tVector2 tangentAt360 = AMCAX::CurveCalculation::CircleD3(2 * M_PI, defaultFrame2, radius);\n\tCHECK(tangentAt0.X() == 0.0);\n\tCHECK(tangentAt0.Y() == -2.0);\n\tCHECK(tangentAt180.X() == Approx(0.0).margin(1e-14));\n\tCHECK(tangentAt180.Y() == 2.0 );\n\tCHECK(tangentAt360.X() == Approx(0.0).margin(1e-14));\n\tCHECK(tangentAt360.Y() == -2.0 );\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] AMCAX_API static Point3 CircleValue(double u, const Frame3& pos, double radius)\t @return The point\n\t @param radius The radius\n\t @param pos The local frame where the circle lies\n\t @param u The parameter\n\t @brief Compute the point on a 3D circle represented by a local frame and a radius at a parameter\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <common/PointT.hpp>\n#include <math/CurveCalculation.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"case1: CurveCalculation::CircleD1 3/4 \", \"[math][CurveCalculation][P1][CircleD1]\") {\n\tDirection3 initialDir(0.0, 0.0,1.0); \n\tFrame3 defaultFrame3(Point3(1.0, 0.0,0.0), initialDir); \n\tdouble radius = 2.0; \n\tVector3 tangentAt0 = AMCAX::CurveCalculation::CircleD1(0.0, defaultFrame3, radius);\n\tVector3 tangentAt90Deg = AMCAX::CurveCalculation::CircleD1(M_PI_2, defaultFrame3, radius);\n\tVector3 tangentAt180Deg = AMCAX::CurveCalculation::CircleD1(M_PI, defaultFrame3, radius);\n\tVector3 tangentAt270Deg = AMCAX::CurveCalculation::CircleD1(3 * M_PI_2, defaultFrame3, radius);\n\tVector3 tangentAt360Deg = AMCAX::CurveCalculation::CircleD1(2 * M_PI, defaultFrame3, radius);\n\tCHECK(tangentAt0.X() == Approx(0.0));\n\tCHECK(tangentAt0.Y() == Approx(2.0));\n\tCHECK(tangentAt90Deg.X() == Approx(-2.0));\n\tCHECK(tangentAt90Deg.Y() == Approx(0.0).margin(1e-14));\n\tCHECK(tangentAt180Deg.X() == Approx(0.0).margin(1e-14));\n\tCHECK(tangentAt180Deg.Y() == Approx(-2.0));\n\tCHECK(tangentAt270Deg.X() == Approx(2.0));\n\tCHECK(tangentAt270Deg.Y() == Approx(-0.0).margin(1e-14));\n\tCHECK(tangentAt360Deg.X() == Approx(0.0).margin(1e-14));\n\tCHECK(tangentAt360Deg.Y() == Approx(2.0));\n\tstd::cout << \"Tangent at 0 deg: \" << tangentAt0 << std::endl;\n\tstd::cout << \"Tangent at 90 deg: \" << tangentAt90Deg << std::endl;\n\tstd::cout << \"Tangent at 180 deg: \" << tangentAt180Deg << std::endl;\n\tstd::cout << \"Tangent at 270 deg: \" << tangentAt270Deg << std::endl;\n\tstd::cout << \"Tangent at 360 deg: \" << tangentAt360Deg << std::endl;\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static void D3(double u, const Circle2& circle, Point2& p, Vector2& v1, Vector2& v2, Vector2& v3)\t @param[out] v3 The third derivative\n\t @param[out] v2 The second derivative\n\t @param[out] v1 The first derivative\n\t @param[out] p The point\n\t @param[in] circle The circle\n\t @param[in] u The parameter\n\t @brief Compute the point and the first three derivatives on a 2D circle at a parameter\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <common/PointT.hpp>\n#include <math/CurveCalculation.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"case1: CurveCalculation::CircleD3 1/4 \", \"[math][CurveCalculation][P1][CircleD3]\") {\n\tDirection2 defaultDir2(1.0, 0.0);\n\tFrame2 defaultFrame2(Point2(1.0, 1.0), defaultDir2);\n\tdouble radius = 2.0;\n\tVector2 tangentAt0 = AMCAX::CurveCalculation::CircleD3(0.0, defaultFrame2, radius);\n\tVector2 tangentAt180 = AMCAX::CurveCalculation::CircleD3(M_PI, defaultFrame2, radius);\n\tVector2 tangentAt360 = AMCAX::CurveCalculation::CircleD3(2 * M_PI, defaultFrame2, radius);\n\tCHECK(tangentAt0.X() == 0.0);\n\tCHECK(tangentAt0.Y() == -2.0);\n\tCHECK(tangentAt180.X() == Approx(0.0).margin(1e-14));\n\tCHECK(tangentAt180.Y() == 2.0 );\n\tCHECK(tangentAt360.X() == Approx(0.0).margin(1e-14));\n\tCHECK(tangentAt360.Y() == -2.0 );\n;\n\tSECTION(\"360 deg case\") {\n\t\tAMCAX::CurveCalculation::CircleD3(2*M_PI, defaultFrame2, radius, p, v1, v2, v3);\n\t\tCHECK(p.X() == 3.0);\n\t\tCHECK(p.Y() == Approx(1.0).margin(1e-14));\n\t\tCHECK(v1.X() == Approx(0.0).margin(1e-14));\n\t\tCHECK(v1.Y() == Approx(2.0));\n\t\tCHECK(v2.X() == Approx(-2.0).margin(1e-14));\n\t\tCHECK(v2.Y() == Approx(0.0).margin(1e-14));\n\t\tCHECK(v3.X() == Approx(-0.0).margin(1e-14));\n\t\tCHECK(v3.Y() == Approx(-2.0));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static void D3(double u, const Line2& line, Point2& p, Vector2& v1, Vector2& v2, Vector2& v3)\t @param[out] v3 The third derivative\n\t @param[out] v2 The second derivative\n\t @param[out] v1 The first derivative\n\t @param[out] p The point\n\t @param[in] line The line\n\t @param[in] u The parameter\n\t @brief Compute the point and the first three derivatives on a 2D line at a parameter\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <common/PointT.hpp>\n#include <math/CurveCalculation.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"case1: CurveCalculation::CircleD3 1/4 \", \"[math][CurveCalculation][P1][CircleD3]\") {\n\tDirection2 defaultDir2(1.0, 0.0);\n\tFrame2 defaultFrame2(Point2(1.0, 1.0), defaultDir2);\n\tdouble radius = 2.0;\n\tVector2 tangentAt0 = AMCAX::CurveCalculation::CircleD3(0.0, defaultFrame2, radius);\n\tVector2 tangentAt180 = AMCAX::CurveCalculation::CircleD3(M_PI, defaultFrame2, radius);\n\tVector2 tangentAt360 = AMCAX::CurveCalculation::CircleD3(2 * M_PI, defaultFrame2, radius);\n\tCHECK(tangentAt0.X() == 0.0);\n\tCHECK(tangentAt0.Y() == -2.0);\n\tCHECK(tangentAt180.X() == Approx(0.0).margin(1e-14));\n\tCHECK(tangentAt180.Y() == 2.0 );\n\tCHECK(tangentAt360.X() == Approx(0.0).margin(1e-14));\n\tCHECK(tangentAt360.Y() == -2.0 );\n;\n\tSECTION(\"360 deg case\") {\n\t\tAMCAX::CurveCalculation::CircleD3(2*M_PI, defaultFrame2, radius, p, v1, v2, v3);\n\t\tCHECK(p.X() == 3.0);\n\t\tCHECK(p.Y() == Approx(1.0).margin(1e-14));\n\t\tCHECK(v1.X() == Approx(0.0).margin(1e-14));\n\t\tCHECK(v1.Y() == Approx(2.0));\n\t\tCHECK(v2.X() == Approx(-2.0).margin(1e-14));\n\t\tCHECK(v2.Y() == Approx(0.0).margin(1e-14));\n\t\tCHECK(v3.X() == Approx(-0.0).margin(1e-14));\n\t\tCHECK(v3.Y() == Approx(-2.0));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static void D3(double u, const Circle3& circle, Point3& p, Vector3& v1, Vector3& v2, Vector3& v3)\t @param[out] v3 The third derivative\n\t @param[out] v2 The second derivative\n\t @param[out] v1 The first derivative\n\t @param[out] p The point\n\t @param[in] circle The circle\n\t @param[in] u The parameter\n\t @brief Compute the point and the first three derivatives on a 3D circle at a parameter\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <common/PointT.hpp>\n#include <math/CurveCalculation.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"case1: CurveCalculation::CircleD3 3/4 \", \"[math][CurveCalculation][P1][CircleD3]\") {\n\tDirection3 initialDir(0.0, 0.0, 1.0); \n\tFrame3 defaultFrame3(Point3(1.0, 1.0, 0.0), initialDir); \n\tdouble radius = 2.0; \n\tVector3 tangentAt0 = AMCAX::CurveCalculation::CircleD3(0.0, defaultFrame3, radius);\n\tVector3 tangentAt90Deg = AMCAX::CurveCalculation::CircleD3(M_PI_2, defaultFrame3, radius);\n\tVector3 tangentAt180Deg = AMCAX::CurveCalculation::CircleD3(M_PI, defaultFrame3, radius);\n\tVector3 tangentAt270Deg = AMCAX::CurveCalculation::CircleD3(3 * M_PI_2, defaultFrame3, radius);\n\tVector3 tangentAt360Deg = AMCAX::CurveCalculation::CircleD3(2 * M_PI, defaultFrame3, radius);\n\tCHECK(tangentAt0.X() == Approx(0.0));\n\tCHECK(tangentAt0.Y() == Approx(-2.0));\n\tCHECK(tangentAt0.Z() == Approx(-0.0));\n\tCHECK(tangentAt90Deg.X() == Approx(2.0).margin(1e-14));\n\tCHECK(tangentAt90Deg.Y() == Approx(-0.0).margin(1e-14));\n\tCHECK(tangentAt90Deg.Z() == Approx(0.0).margin(1e-14));\n\tCHECK(tangentAt180Deg.X() == Approx(0.0).margin(1e-14));\n\tCHECK(tangentAt180Deg.Y() == Approx(2.0).margin(1e-14));\n\tCHECK(tangentAt180Deg.Z() == Approx(0.0));\n\tCHECK(tangentAt270Deg.X() == Approx(-2.0).margin(1e-14));\n\tCHECK(tangentAt270Deg.Y() == Approx(0.0).margin(1e-14));\n\tCHECK(tangentAt270Deg.Z() == Approx(0.0).margin(1e-14));\n\tCHECK(tangentAt360Deg.X() == Approx(-0.0).margin(1e-14));\n\tCHECK(tangentAt360Deg.Y() == Approx(-2.0).margin(1e-14));\n\tCHECK(tangentAt360Deg.Z() == Approx(0.0).margin(1e-14));\n\tstd::cout << \"Tangent at 0 deg: \" << tangentAt0 << std::endl;\n\tstd::cout << \"Tangent at 90 deg: \" << tangentAt90Deg << std::endl;\n\tstd::cout << \"Tangent at 180 deg: \" << tangentAt180Deg << std::endl;\n\tstd::cout << \"Tangent at 270 deg: \" << tangentAt270Deg << std::endl;\n\tstd::cout << \"Tangent at 360 deg: \" << tangentAt360Deg << std::endl;\n;\n\tSECTION(\"90 deg case\") {\n\t\tAMCAX::CurveCalculation::CircleD3(M_PI_2, defaultFrame3, radius, p, v1, v2, v3);\n\t\tCHECK(p.X() == Approx(1.0));\n\t\tCHECK(p.Y() == 3.0);\n\t\tCHECK(p.Z() == 0.0);\n\t\tCHECK(v1.X() == Approx(-2.0));\n\t\tCHECK(v1.Y() == Approx(0.0).margin(1e-14));\n\t\tCHECK(v1.Z() == Approx(0.0).margin(1e-14));\n\t\tCHECK(v2.X() == Approx(0.0).margin(1e-14));\n\t\tCHECK(v2.Y() == Approx(-2.0));\n\t\tCHECK(v2.Z() == Approx(0.0));\n\t\tCHECK(v3.X() == Approx(2.0));\n\t\tCHECK(v3.Y() == Approx(-0.0).margin(1e-14));\n\t\tCHECK(v3.Z() == Approx(-0.0));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static void D2(double u, const Circle2& circle, Point2& p, Vector2& v1, Vector2& v2)\t @param[out] v2 The second derivative\n\t @param[out] v1 The first derivative\n\t @param[out] p The point\n\t @param[in] circle The circle\n\t @param[in] u The parameter\n\t @brief Compute the point and the first two derivatives on a 2D circle at a parameter\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <common/PointT.hpp>\n#include <math/CurveCalculation.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"case1: CurveCalculation::CircleD2 3/4 \", \"[math][CurveCalculation][P1][CircleD2]\") {\n\tDirection3 initialDir(0.0, 0.0, 1.0); \n\tFrame3 defaultFrame3(Point3(1.0, 1.0, 0.0), initialDir); \n\tdouble radius = 2.0; \n\tVector3 tangentAt0 = AMCAX::CurveCalculation::CircleD2(0.0, defaultFrame3, radius);\n\tVector3 tangentAt90Deg = AMCAX::CurveCalculation::CircleD2(M_PI_2, defaultFrame3, radius);\n\tVector3 tangentAt180Deg = AMCAX::CurveCalculation::CircleD2(M_PI, defaultFrame3, radius);\n\tVector3 tangentAt270Deg = AMCAX::CurveCalculation::CircleD2(3 * M_PI_2, defaultFrame3, radius);\n\tVector3 tangentAt360Deg = AMCAX::CurveCalculation::CircleD2(2 * M_PI, defaultFrame3, radius);\n\tCHECK(tangentAt0.X() == Approx(-2.0));\n\tCHECK(tangentAt0.Y() == Approx(-0.0));\n\tCHECK(tangentAt0.Z() == Approx(0.0));\n\tCHECK(tangentAt90Deg.X() == Approx(-0.0).margin(1e-14));\n\tCHECK(tangentAt90Deg.Y() == Approx(-2.0).margin(1e-14));\n\tCHECK(tangentAt90Deg.Z() == Approx(0.0).margin(1e-14));\n\tCHECK(tangentAt180Deg.X() == Approx(2.0).margin(1e-14));\n\tCHECK(tangentAt180Deg.Y() == Approx(-0.0).margin(1e-14));\n\tCHECK(tangentAt180Deg.Z() == Approx(-0.0));\n\tCHECK(tangentAt270Deg.X() == Approx(0.0).margin(1e-14));\n\tCHECK(tangentAt270Deg.Y() == Approx(2.0).margin(1e-14));\n\tCHECK(tangentAt270Deg.Z() == Approx(0.0).margin(1e-14));\n\tCHECK(tangentAt360Deg.X() == Approx(-2.0).margin(1e-14));\n\tCHECK(tangentAt360Deg.Y() == Approx(0.0).margin(1e-14));\n\tCHECK(tangentAt360Deg.Z() == Approx(0.0).margin(1e-14));\n\tstd::cout << \"Tangent at 0 deg: \" << tangentAt0 << std::endl;\n\tstd::cout << \"Tangent at 90 deg: \" << tangentAt90Deg << std::endl;\n\tstd::cout << \"Tangent at 180 deg: \" << tangentAt180Deg << std::endl;\n\tstd::cout << \"Tangent at 270 deg: \" << tangentAt270Deg << std::endl;\n\tstd::cout << \"Tangent at 360 deg: \" << tangentAt360Deg << std::endl;\n;\n\tSECTION(\"90 deg case\") {\n\t\tAMCAX::CurveCalculation::CircleD2(M_PI_2, defaultFrame3, radius, p, v1, v2);\n\t\tCHECK(p.X() == Approx(1.0));\n\t\tCHECK(p.Y() == 3.0);\n\t\tCHECK(p.Z() == 0.0);\n\t\tCHECK(v1.X() == Approx(-2.0));\n\t\tCHECK(v1.Y() == Approx(0.0).margin(1e-14));\n\t\tCHECK(v1.Z() == Approx(0.0).margin(1e-14));\n\t\tCHECK(v2.X() == Approx(0.0).margin(1e-14));\n\t\tCHECK(v2.Y() == Approx(-2.0));\n\t\tCHECK(v2.Z() == Approx(0.0));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static void D2(double u, const Circle3& circle, Point3& p, Vector3& v1, Vector3& v2)\t @param[out] v2 The second derivative\n\t @param[out] v1 The first derivative\n\t @param[out] p The point\n\t @param[in] circle The circle\n\t @param[in] u The parameter\n\t @brief Compute the point and the first two derivatives on a 3D circle at a parameter\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <common/PointT.hpp>\n#include <math/CurveCalculation.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"case1: CurveCalculation::CircleD2 3/4 \", \"[math][CurveCalculation][P1][CircleD2]\") {\n\tDirection3 initialDir(0.0, 0.0, 1.0); \n\tFrame3 defaultFrame3(Point3(1.0, 1.0, 0.0), initialDir); \n\tdouble radius = 2.0; \n\tVector3 tangentAt0 = AMCAX::CurveCalculation::CircleD2(0.0, defaultFrame3, radius);\n\tVector3 tangentAt90Deg = AMCAX::CurveCalculation::CircleD2(M_PI_2, defaultFrame3, radius);\n\tVector3 tangentAt180Deg = AMCAX::CurveCalculation::CircleD2(M_PI, defaultFrame3, radius);\n\tVector3 tangentAt270Deg = AMCAX::CurveCalculation::CircleD2(3 * M_PI_2, defaultFrame3, radius);\n\tVector3 tangentAt360Deg = AMCAX::CurveCalculation::CircleD2(2 * M_PI, defaultFrame3, radius);\n\tCHECK(tangentAt0.X() == Approx(-2.0));\n\tCHECK(tangentAt0.Y() == Approx(-0.0));\n\tCHECK(tangentAt0.Z() == Approx(0.0));\n\tCHECK(tangentAt90Deg.X() == Approx(-0.0).margin(1e-14));\n\tCHECK(tangentAt90Deg.Y() == Approx(-2.0).margin(1e-14));\n\tCHECK(tangentAt90Deg.Z() == Approx(0.0).margin(1e-14));\n\tCHECK(tangentAt180Deg.X() == Approx(2.0).margin(1e-14));\n\tCHECK(tangentAt180Deg.Y() == Approx(-0.0).margin(1e-14));\n\tCHECK(tangentAt180Deg.Z() == Approx(-0.0));\n\tCHECK(tangentAt270Deg.X() == Approx(0.0).margin(1e-14));\n\tCHECK(tangentAt270Deg.Y() == Approx(2.0).margin(1e-14));\n\tCHECK(tangentAt270Deg.Z() == Approx(0.0).margin(1e-14));\n\tCHECK(tangentAt360Deg.X() == Approx(-2.0).margin(1e-14));\n\tCHECK(tangentAt360Deg.Y() == Approx(0.0).margin(1e-14));\n\tCHECK(tangentAt360Deg.Z() == Approx(0.0).margin(1e-14));\n\tstd::cout << \"Tangent at 0 deg: \" << tangentAt0 << std::endl;\n\tstd::cout << \"Tangent at 90 deg: \" << tangentAt90Deg << std::endl;\n\tstd::cout << \"Tangent at 180 deg: \" << tangentAt180Deg << std::endl;\n\tstd::cout << \"Tangent at 270 deg: \" << tangentAt270Deg << std::endl;\n\tstd::cout << \"Tangent at 360 deg: \" << tangentAt360Deg << std::endl;\n;\n\tSECTION(\"90 deg case\") {\n\t\tAMCAX::CurveCalculation::CircleD2(M_PI_2, defaultFrame3, radius, p, v1, v2);\n\t\tCHECK(p.X() == Approx(1.0));\n\t\tCHECK(p.Y() == 3.0);\n\t\tCHECK(p.Z() == 0.0);\n\t\tCHECK(v1.X() == Approx(-2.0));\n\t\tCHECK(v1.Y() == Approx(0.0).margin(1e-14));\n\t\tCHECK(v1.Z() == Approx(0.0).margin(1e-14));\n\t\tCHECK(v2.X() == Approx(0.0).margin(1e-14));\n\t\tCHECK(v2.Y() == Approx(-2.0));\n\t\tCHECK(v2.Z() == Approx(0.0));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static void D2(double u, const Line3& line, Point3& p, Vector3& v1, Vector3& v2)\t @param[out] v2 The second derivative\n\t @param[out] v1 The first derivative\n\t @param[out] p The point\n\t @param[in] line The line\n\t @param[in] u The parameter\n\t @brief Compute the point and the first two derivatives on a 3D line at a parameter\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <common/PointT.hpp>\n#include <math/CurveCalculation.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"case1: CurveCalculation::CircleD2 3/4 \", \"[math][CurveCalculation][P1][CircleD2]\") {\n\tDirection3 initialDir(0.0, 0.0, 1.0); \n\tFrame3 defaultFrame3(Point3(1.0, 1.0, 0.0), initialDir); \n\tdouble radius = 2.0; \n\tVector3 tangentAt0 = AMCAX::CurveCalculation::CircleD2(0.0, defaultFrame3, radius);\n\tVector3 tangentAt90Deg = AMCAX::CurveCalculation::CircleD2(M_PI_2, defaultFrame3, radius);\n\tVector3 tangentAt180Deg = AMCAX::CurveCalculation::CircleD2(M_PI, defaultFrame3, radius);\n\tVector3 tangentAt270Deg = AMCAX::CurveCalculation::CircleD2(3 * M_PI_2, defaultFrame3, radius);\n\tVector3 tangentAt360Deg = AMCAX::CurveCalculation::CircleD2(2 * M_PI, defaultFrame3, radius);\n\tCHECK(tangentAt0.X() == Approx(-2.0));\n\tCHECK(tangentAt0.Y() == Approx(-0.0));\n\tCHECK(tangentAt0.Z() == Approx(0.0));\n\tCHECK(tangentAt90Deg.X() == Approx(-0.0).margin(1e-14));\n\tCHECK(tangentAt90Deg.Y() == Approx(-2.0).margin(1e-14));\n\tCHECK(tangentAt90Deg.Z() == Approx(0.0).margin(1e-14));\n\tCHECK(tangentAt180Deg.X() == Approx(2.0).margin(1e-14));\n\tCHECK(tangentAt180Deg.Y() == Approx(-0.0).margin(1e-14));\n\tCHECK(tangentAt180Deg.Z() == Approx(-0.0));\n\tCHECK(tangentAt270Deg.X() == Approx(0.0).margin(1e-14));\n\tCHECK(tangentAt270Deg.Y() == Approx(2.0).margin(1e-14));\n\tCHECK(tangentAt270Deg.Z() == Approx(0.0).margin(1e-14));\n\tCHECK(tangentAt360Deg.X() == Approx(-2.0).margin(1e-14));\n\tCHECK(tangentAt360Deg.Y() == Approx(0.0).margin(1e-14));\n\tCHECK(tangentAt360Deg.Z() == Approx(0.0).margin(1e-14));\n\tstd::cout << \"Tangent at 0 deg: \" << tangentAt0 << std::endl;\n\tstd::cout << \"Tangent at 90 deg: \" << tangentAt90Deg << std::endl;\n\tstd::cout << \"Tangent at 180 deg: \" << tangentAt180Deg << std::endl;\n\tstd::cout << \"Tangent at 270 deg: \" << tangentAt270Deg << std::endl;\n\tstd::cout << \"Tangent at 360 deg: \" << tangentAt360Deg << std::endl;\n;\n\tSECTION(\"90 deg case\") {\n\t\tAMCAX::CurveCalculation::CircleD2(M_PI_2, defaultFrame3, radius, p, v1, v2);\n\t\tCHECK(p.X() == Approx(1.0));\n\t\tCHECK(p.Y() == 3.0);\n\t\tCHECK(p.Z() == 0.0);\n\t\tCHECK(v1.X() == Approx(-2.0));\n\t\tCHECK(v1.Y() == Approx(0.0).margin(1e-14));\n\t\tCHECK(v1.Z() == Approx(0.0).margin(1e-14));\n\t\tCHECK(v2.X() == Approx(0.0).margin(1e-14));\n\t\tCHECK(v2.Y() == Approx(-2.0));\n\t\tCHECK(v2.Z() == Approx(0.0));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] AMCAX_API static Vector2 D1(double u, const Circle2& circle)\t @return The first derivative vector\n\t @param circle The circle\n\t @param u The parameter\n\t @brief Compute the first derivative on a 2D circle at a parameter\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <common/PointT.hpp>\n#include <math/CurveCalculation.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"case1: CurveCalculation::CircleD1 1/4 \", \"[math][CurveCalculation][P1][CircleD1]\") {\n\tDirection2 initialDir(1.0, 0.0); \n\tFrame2 defaultFrame2(Point2(1.0, 1.0), initialDir); \n\tdouble radius = 2.0; \n\tVector2 tangentAt0 = AMCAX::CurveCalculation::CircleD1(0.0, defaultFrame2, radius);\n\tVector2 tangentAt90Deg = AMCAX::CurveCalculation::CircleD1(M_PI_2, defaultFrame2, radius);\n\tVector2 tangentAt180Deg = AMCAX::CurveCalculation::CircleD1(M_PI, defaultFrame2, radius);\n\tVector2 tangentAt270Deg = AMCAX::CurveCalculation::CircleD1(3 * M_PI_2, defaultFrame2, radius);\n\tVector2 tangentAt360Deg = AMCAX::CurveCalculation::CircleD1(2 * M_PI, defaultFrame2, radius);\n\tCHECK(tangentAt0.X() == Approx(-0.0));\n\tCHECK(tangentAt0.Y() == Approx(2.0));\n\tCHECK(tangentAt90Deg.X() == Approx(-2.0));\n\tCHECK(tangentAt90Deg.Y() == Approx(0.0).margin(1e-14));\n\tCHECK(tangentAt180Deg.X() == Approx(-0.0).margin(1e-14));\n\tCHECK(tangentAt180Deg.Y() == Approx(-2.0));\n\tCHECK(tangentAt270Deg.X() == Approx(2.0));\n\tCHECK(tangentAt270Deg.Y() == Approx(-0.0).margin(1e-14));\n\tCHECK(tangentAt360Deg.X() == Approx(0.0).margin(1e-14));\n\tCHECK(tangentAt360Deg.Y() == Approx(2.0));\n\tstd::cout << \"Tangent at 0 deg: \" << tangentAt0 << std::endl;\n\tstd::cout << \"Tangent at 90 deg: \" << tangentAt90Deg << std::endl;\n\tstd::cout << \"Tangent at 180 deg: \" << tangentAt180Deg << std::endl;\n\tstd::cout << \"Tangent at 270 deg: \" << tangentAt270Deg << std::endl;\n\tstd::cout << \"Tangent at 360 deg: \" << tangentAt360Deg << std::endl;\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static void AdjustPeriodic(double ufirst, double ulast, double precision, double& u1, double& u2)\t @param[in,out] u2 The second parameter to be adjust\n\t @param[in,out] u1 The first parameter to be adjust\n\t @param[in] precision The precision to check equality\n\t @param[in] ulast The upper bound of the period\n\t @param[in] ufirst The lower bound of the period\n\t          The parameter u2 is set in the range [u1, u1 + ulast - ufirst]\n\t @details The parameter u1 is set in the range [ufirst, ulast]\n\t @brief Adjust u1 and u2 to be in the period range.\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <common/PointT.hpp>\n#include <math/CurveCalculation.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"case1: CurveCalculation::AdjustPeriodic \", \"[math][CurveCalculation][P1]\") {\n\tdouble u1 = 0.0;\n\tdouble u2 = 2 * M_PI;\n\tdouble ufirst = 0.0;\n\tdouble ulast = 2 * M_PI; \n\tdouble precision = 0.001; \n\tAMCAX::CurveCalculation::AdjustPeriodic(ufirst, ulast, precision, u1, u2);\n\tCHECK(u1 == 0);\n\tCHECK(u2 == 2 * M_PI);\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API int IsInOutOn(const Point2& p, double tol)\t @return 1: in; 0: on; -1: out\n\t @param tol The tolerance of the point\n\t @param p The test point\n\t @brief Check a point is in or out of the polygon\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <common/PointT.hpp>\n#include <math/Classifier2d.hpp>\nusing namespace AMCAX;\n#include<catch.hpp>\n#include<testHelper.h>\n#include <common/PointT.hpp>\n#include <math/Classifier2d.hpp>\nusing namespace AMCAX;\n;\n\tSECTION(\"IsInOut Point normal set\") {\n        Point2 OutPoint(0.0, 0.0);\n        Point2 OnPoint(1.0, 1.0);\n        Point2 InPoint(2.0, 1.0);\n        CHECK(classifier.IsInOut(OutPoint) == -1);\n        CHECK(classifier.IsInOut(OnPoint) == 0);\n        CHECK(classifier.IsInOut(InPoint) == 1);\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API int IsInOut(const Point2& p)\t @return 1: in; 0: on; -1: out\n\t @param p The test point\n\t @brief Check a point is in or out of the polygon\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <common/PointT.hpp>\n#include <math/Classifier2d.hpp>\nusing namespace AMCAX;\n#include<catch.hpp>\n#include<testHelper.h>\n#include <common/PointT.hpp>\n#include <math/Classifier2d.hpp>\nusing namespace AMCAX;\n;\n\tSECTION(\"IsInOut Point normal set\") {\n        Point2 OutPoint(0.0, 0.0);\n        Point2 OnPoint(1.0, 1.0);\n        Point2 InPoint(2.0, 1.0);\n        CHECK(classifier.IsInOut(OutPoint) == -1);\n        CHECK(classifier.IsInOut(OnPoint) == 0);\n        CHECK(classifier.IsInOut(InPoint) == 1);\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API Classifier2d(const std::vector<Point2>& pts, double tolU, double tolV, double uMin, double vMin, double uMax, double vMax)\t @param vMax The upper bound of v\n\t @param uMax The upper bound of u\n\t @param vMin The lower bound of v\n\t @param uMin The lower bound of u\n\t @param tolV The tolerance of v bound\n\t @param tolU The tolerance of u bound\n\t @param pts The points of a 2D closed polygon, the last point does not required to repeat the first point\n\t @details Require uMax > uMin, vMax > vMin, and at least 3 points\n\t @brief Construct from a 2D polygon and uv-bounds\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <common/PointT.hpp>\n#include <math/Classifier2d.hpp>\nusing namespace AMCAX;\n#include<catch.hpp>\n#include<testHelper.h>\n#include <common/PointT.hpp>\n#include <math/Classifier2d.hpp>\nusing namespace AMCAX;\n;\n\tSECTION(\"IsInOut Point normal set2 \") {\n        Point2 OutPoint(2.5, 1.9);\n        Point2 OnPoint(1.5, 0.5);\n        Point2 InPoint(1.5, 1.0); \n        Point2 AnothInPoint(2.0, 1.5); \n        CHECK(classifier.IsInOut(OutPoint) == -1);\n        CHECK(classifier.IsInOut(OnPoint) == 0);\n        CHECK(classifier.IsInOut(InPoint) == 1);\n        CHECK(classifier.IsInOut(AnothInPoint) == 1);\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] LineS Rotated(const Axis3& axis, double angle)\t @return The rotated line\n\t @param angle The rotation angle\n\t @param axis The rotation axis\n\t @brief Get the line rotated around an axis with an angle in 3D\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <math/LineT.hpp>\n#include <math/Plane.hpp>\n#include <modeling/MakeFace.hpp>\n#include <modeling/MakeEdge.hpp>\nusing AMCAX::Line3;\nusing AMCAX::MakeEdge;\nusing AMCAX::MakeFace;\n#define ONE_RADIAN (M_PI / 180.)\n#define SQUARE(x) ((x) * (x))\n#include <catch.hpp>\n#include <testHelper.h>\n#include <math/LineT.hpp>\n#include <math/Plane.hpp>\n#include <modeling/MakeFace.hpp>\n#include <modeling/MakeEdge.hpp>\nusing AMCAX::Line3;\nusing AMCAX::MakeEdge;\nusing AMCAX::MakeFace;\n#define ONE_RADIAN (M_PI / 180.)\n#define SQUARE(x) ((x) * (x))\n;\n\tSECTION(\"Rotate\")\n\t{\n\t\tAxis3 axis(Point3(0., 0., 0.), Direction3(0., 1., 0.));\n\t\tLine3 line(Point3(0., 0., 0.), Direction3(1., 1., -1.));\n\t\tLine3 rotateLine = line.Rotated(axis, 90. * ONE_RADIAN);  \n\t\tTopoEdge edge1 = MakeEdge(line);\n\t\tTopoEdge edge2 = MakeEdge(rotateLine);\n\t\tTopoEdge edge3 = MakeEdge(Line3(axis));\n\t\tbool isWriteSuccess1 = AMCAX::OCCTIO::OCCTTool::Write(edge1, OUTPUT_PATH_PREFIX\"Line3_Rotate_line.brep\");\n\t\tbool isWriteSuccess2 = AMCAX::OCCTIO::OCCTTool::Write(edge2, OUTPUT_PATH_PREFIX\"Line3_Rotate_lineRotate.brep\");\n\t\tbool isWriteSuccess3 = AMCAX::OCCTIO::OCCTTool::Write(edge3, OUTPUT_PATH_PREFIX\"Line3_Rotate_axis.brep\");\n\t\tREQUIRE(isWriteSuccess1);\n\t\tREQUIRE(isWriteSuccess2);\n\t\tREQUIRE(isWriteSuccess3);\n\t\tauto pointToPoint = [](const Point3& p1, const Point3& p2) {\n\t\t\treturn std::sqrt(\n\t\t\t\tSQUARE(p1.X() - p2.X()) +\n\t\t\t\tSQUARE(p1.Y() - p2.Y()) +\n\t\t\t\tSQUARE(p1.Z() - p2.Z())\n\t\t\t);\n\t\t};\n\t\tCHECK(line.Distance(Line3(axis)) == Approx(rotateLine.Distance(Line3(axis))).margin(std::numeric_limits<double>::min()));\n\t\tCHECK(pointToPoint(line.Location(), Point3()) == Approx(pointToPoint(rotateLine.Location(), Point3())).margin(std::numeric_limits<double>::min()));\n\t\tPoint3 p(-1., 1., -1.);\n\t\tCHECK(rotateLine.Contains(p, 1e-6) == true);\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] LineS Mirrored(const Frame3& frame)\t @return The mirrored line\n\t @param frame The mirror frame\n\t @brief Get the line mirrored by a frame\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <math/LineT.hpp>\n#include <math/Plane.hpp>\n#include <modeling/MakeFace.hpp>\n#include <modeling/MakeEdge.hpp>\nusing AMCAX::Line3;\nusing AMCAX::MakeEdge;\nusing AMCAX::MakeFace;\n#define ONE_RADIAN (M_PI / 180.)\n#define SQUARE(x) ((x) * (x))\n#include <catch.hpp>\n#include <testHelper.h>\n#include <math/LineT.hpp>\n#include <math/Plane.hpp>\n#include <modeling/MakeFace.hpp>\n#include <modeling/MakeEdge.hpp>\nusing AMCAX::Line3;\nusing AMCAX::MakeEdge;\nusing AMCAX::MakeFace;\n#define ONE_RADIAN (M_PI / 180.)\n#define SQUARE(x) ((x) * (x))\n;\n\tSECTION(\"Mirror\")\n\t{\n\t\tLine3 line(Point3(1.0, 2.0, 3.0), Direction3(1.0, 0.0, 0.0));\n\t\tLine3 originalLine(Point3(1.0, 2.0, 3.0), Direction3(1.0, 0.0, 0.0));\n\t\tFrame3 frame(Point3(0.0, 0.0, 0.0), Direction3(0.0, 1.0, 0.0));\n\t\tline.Mirror(frame);\n\t\tCHECK(line.Distance(Point3(0.0, 0.0, 0.0)) == Approx(originalLine.Distance(Point3(0., 0., 0.))).margin(std::numeric_limits<double>::min()));\n\t\tDirection3 dir(originalLine.Location().X() - line.Location().X(),\n\t\t\t\t\t   originalLine.Location().Y() - line.Location().Y(),\n\t\t\t\t\t   originalLine.Location().Z() - line.Location().Z());\n\t\tCHECK(dir.IsParallel(Direction3(0.0, 1.0, 0.0), 1e-5 * ONE_RADIAN));\n\t\tLine3 line2(Point3(1.2, -4.6, 2.3), Direction3(1.8, 97.4, -12.8));\n\t\tFrame3 frame2(Point3(87.0, 2.3, 10.14), Direction3(-92.3, 2.6, 1.0));\n\t\tLine3 mirrorLine2 = line2.Mirrored(frame2);\n\t\tCHECK(line2.Distance(Point3(87.0, 2.3, 10.14)) == Approx(mirrorLine2.Distance(Point3(87.0, 2.3, 10.14))).margin(std::numeric_limits<double>::min()));\n\t\tDirection3 dir2(line2.Location().X() - mirrorLine2.Location().X(),\n\t\t\t\t\t    line2.Location().Y() - mirrorLine2.Location().Y(),\n\t\t\t\t\t    line2.Location().Z() - mirrorLine2.Location().Z());\n\t\tCHECK(dir2.IsParallel(Direction3(-92.3, 2.6, 1.0), 1e-5 * ONE_RADIAN));\n\t\tTopoFace face = MakeFace(Plane(frame2), 0., 4., 0., 4.);\n\t\tTopoEdge edgeLine2 = MakeEdge(line2, 0., 1.);\n\t\tTopoEdge edgeMirrorLine2 = MakeEdge(mirrorLine2, 0., 1.);\n\t\tAMCAX::OCCTIO::OCCTTool::Write(face, OUTPUT_PATH_PREFIX\"Line3_Mirror_face2.brep\");\n\t\tAMCAX::OCCTIO::OCCTTool::Write(edgeLine2, OUTPUT_PATH_PREFIX\"Line3_Mirror_edge.brep\");\n\t\tAMCAX::OCCTIO::OCCTTool::Write(edgeMirrorLine2, OUTPUT_PATH_PREFIX\"Line3_Mirror_Mirroredge.brep\");\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "LineS& Mirror(const Frame3& frame)\t @return The reference to self\n\t @param frame The mirror frame\n\t @brief Mirror the line by a frame\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <math/LineT.hpp>\n#include <math/Plane.hpp>\n#include <modeling/MakeFace.hpp>\n#include <modeling/MakeEdge.hpp>\nusing AMCAX::Line3;\nusing AMCAX::MakeEdge;\nusing AMCAX::MakeFace;\n#define ONE_RADIAN (M_PI / 180.)\n#define SQUARE(x) ((x) * (x))\n#include <catch.hpp>\n#include <testHelper.h>\n#include <math/LineT.hpp>\n#include <math/Plane.hpp>\n#include <modeling/MakeFace.hpp>\n#include <modeling/MakeEdge.hpp>\nusing AMCAX::Line3;\nusing AMCAX::MakeEdge;\nusing AMCAX::MakeFace;\n#define ONE_RADIAN (M_PI / 180.)\n#define SQUARE(x) ((x) * (x))\n;\n\tSECTION(\"Mirror\")\n\t{\n\t\tLine3 line(Point3(1.0, 2.0, 3.0), Direction3(1.0, 0.0, 0.0));\n\t\tLine3 originalLine(Point3(1.0, 2.0, 3.0), Direction3(1.0, 0.0, 0.0));\n\t\tFrame3 frame(Point3(0.0, 0.0, 0.0), Direction3(0.0, 1.0, 0.0));\n\t\tline.Mirror(frame);\n\t\tCHECK(line.Distance(Point3(0.0, 0.0, 0.0)) == Approx(originalLine.Distance(Point3(0., 0., 0.))).margin(std::numeric_limits<double>::min()));\n\t\tDirection3 dir(originalLine.Location().X() - line.Location().X(),\n\t\t\t\t\t   originalLine.Location().Y() - line.Location().Y(),\n\t\t\t\t\t   originalLine.Location().Z() - line.Location().Z());\n\t\tCHECK(dir.IsParallel(Direction3(0.0, 1.0, 0.0), 1e-5 * ONE_RADIAN));\n\t\tLine3 line2(Point3(1.2, -4.6, 2.3), Direction3(1.8, 97.4, -12.8));\n\t\tFrame3 frame2(Point3(87.0, 2.3, 10.14), Direction3(-92.3, 2.6, 1.0));\n\t\tLine3 mirrorLine2 = line2.Mirrored(frame2);\n\t\tCHECK(line2.Distance(Point3(87.0, 2.3, 10.14)) == Approx(mirrorLine2.Distance(Point3(87.0, 2.3, 10.14))).margin(std::numeric_limits<double>::min()));\n\t\tDirection3 dir2(line2.Location().X() - mirrorLine2.Location().X(),\n\t\t\t\t\t    line2.Location().Y() - mirrorLine2.Location().Y(),\n\t\t\t\t\t    line2.Location().Z() - mirrorLine2.Location().Z());\n\t\tCHECK(dir2.IsParallel(Direction3(-92.3, 2.6, 1.0), 1e-5 * ONE_RADIAN));\n\t\tTopoFace face = MakeFace(Plane(frame2), 0., 4., 0., 4.);\n\t\tTopoEdge edgeLine2 = MakeEdge(line2, 0., 1.);\n\t\tTopoEdge edgeMirrorLine2 = MakeEdge(mirrorLine2, 0., 1.);\n\t\tAMCAX::OCCTIO::OCCTTool::Write(face, OUTPUT_PATH_PREFIX\"Line3_Mirror_face2.brep\");\n\t\tAMCAX::OCCTIO::OCCTTool::Write(edgeLine2, OUTPUT_PATH_PREFIX\"Line3_Mirror_edge.brep\");\n\t\tAMCAX::OCCTIO::OCCTTool::Write(edgeMirrorLine2, OUTPUT_PATH_PREFIX\"Line3_Mirror_Mirroredge.brep\");\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] LineS Normal(const Point3& p)\t @return The line passing through a point and perpendicular to the line\n\t @param p The point\n\t @brief Get a line passing through a point and perpendicular to the line\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <math/LineT.hpp>\n#include <math/Plane.hpp>\n#include <modeling/MakeFace.hpp>\n#include <modeling/MakeEdge.hpp>\nusing AMCAX::Line3;\nusing AMCAX::MakeEdge;\nusing AMCAX::MakeFace;\n#define ONE_RADIAN (M_PI / 180.)\n#define SQUARE(x) ((x) * (x))\n#include <catch.hpp>\n#include <testHelper.h>\n#include <math/LineT.hpp>\n#include <math/Plane.hpp>\n#include <modeling/MakeFace.hpp>\n#include <modeling/MakeEdge.hpp>\nusing AMCAX::Line3;\nusing AMCAX::MakeEdge;\nusing AMCAX::MakeFace;\n#define ONE_RADIAN (M_PI / 180.)\n#define SQUARE(x) ((x) * (x))\n;\n\tSECTION(\"Normal\")\n\t{\n\t\tLine3 line(Point3(94., 32., 4.8), Direction3(2.65, 3.28, 5.14));\n\t\tLine3 line2 = line.Normal(Point3(2.1, 3.4, 11.2));\n\t\tCHECK(line.Direction().Dot(line2.Direction()) == Approx(0.).margin(1e-6));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] auto Distance(const Point3& p)\t @return The distance between the point and the line\n\t @param p The point\n\t @brief Compute the distance from a point to the line\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <math/LineT.hpp>\n#include <math/Plane.hpp>\n#include <modeling/MakeFace.hpp>\n#include <modeling/MakeEdge.hpp>\nusing AMCAX::Line3;\nusing AMCAX::MakeEdge;\nusing AMCAX::MakeFace;\n#define ONE_RADIAN (M_PI / 180.)\n#define SQUARE(x) ((x) * (x))\n#include <catch.hpp>\n#include <testHelper.h>\n#include <math/LineT.hpp>\n#include <math/Plane.hpp>\n#include <modeling/MakeFace.hpp>\n#include <modeling/MakeEdge.hpp>\nusing AMCAX::Line3;\nusing AMCAX::MakeEdge;\nusing AMCAX::MakeFace;\n#define ONE_RADIAN (M_PI / 180.)\n#define SQUARE(x) ((x) * (x))\n;\n\tSECTION(\"Mirror\")\n\t{\n\t\tLine3 line(Point3(1.0, 2.0, 3.0), Direction3(1.0, 0.0, 0.0));\n\t\tLine3 originalLine(Point3(1.0, 2.0, 3.0), Direction3(1.0, 0.0, 0.0));\n\t\tFrame3 frame(Point3(0.0, 0.0, 0.0), Direction3(0.0, 1.0, 0.0));\n\t\tline.Mirror(frame);\n\t\tCHECK(line.Distance(Point3(0.0, 0.0, 0.0)) == Approx(originalLine.Distance(Point3(0., 0., 0.))).margin(std::numeric_limits<double>::min()));\n\t\tDirection3 dir(originalLine.Location().X() - line.Location().X(),\n\t\t\t\t\t   originalLine.Location().Y() - line.Location().Y(),\n\t\t\t\t\t   originalLine.Location().Z() - line.Location().Z());\n\t\tCHECK(dir.IsParallel(Direction3(0.0, 1.0, 0.0), 1e-5 * ONE_RADIAN));\n\t\tLine3 line2(Point3(1.2, -4.6, 2.3), Direction3(1.8, 97.4, -12.8));\n\t\tFrame3 frame2(Point3(87.0, 2.3, 10.14), Direction3(-92.3, 2.6, 1.0));\n\t\tLine3 mirrorLine2 = line2.Mirrored(frame2);\n\t\tCHECK(line2.Distance(Point3(87.0, 2.3, 10.14)) == Approx(mirrorLine2.Distance(Point3(87.0, 2.3, 10.14))).margin(std::numeric_limits<double>::min()));\n\t\tDirection3 dir2(line2.Location().X() - mirrorLine2.Location().X(),\n\t\t\t\t\t    line2.Location().Y() - mirrorLine2.Location().Y(),\n\t\t\t\t\t    line2.Location().Z() - mirrorLine2.Location().Z());\n\t\tCHECK(dir2.IsParallel(Direction3(-92.3, 2.6, 1.0), 1e-5 * ONE_RADIAN));\n\t\tTopoFace face = MakeFace(Plane(frame2), 0., 4., 0., 4.);\n\t\tTopoEdge edgeLine2 = MakeEdge(line2, 0., 1.);\n\t\tTopoEdge edgeMirrorLine2 = MakeEdge(mirrorLine2, 0., 1.);\n\t\tAMCAX::OCCTIO::OCCTTool::Write(face, OUTPUT_PATH_PREFIX\"Line3_Mirror_face2.brep\");\n\t\tAMCAX::OCCTIO::OCCTTool::Write(edgeLine2, OUTPUT_PATH_PREFIX\"Line3_Mirror_edge.brep\");\n\t\tAMCAX::OCCTIO::OCCTTool::Write(edgeMirrorLine2, OUTPUT_PATH_PREFIX\"Line3_Mirror_Mirroredge.brep\");\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] LineS Normal(const Point2& p)\t @return The line passing through a point and perpendicular to the line\n\t @param p The point\n\t @brief Get a line passing through a point and perpendicular to the line\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <math/LineT.hpp>\n#include <math/Plane.hpp>\n#include <modeling/MakeFace.hpp>\n#include <modeling/MakeEdge.hpp>\nusing AMCAX::Line3;\nusing AMCAX::MakeEdge;\nusing AMCAX::MakeFace;\n#define ONE_RADIAN (M_PI / 180.)\n#define SQUARE(x) ((x) * (x))\n#include <catch.hpp>\n#include <testHelper.h>\n#include <math/LineT.hpp>\n#include <math/Plane.hpp>\n#include <modeling/MakeFace.hpp>\n#include <modeling/MakeEdge.hpp>\nusing AMCAX::Line3;\nusing AMCAX::MakeEdge;\nusing AMCAX::MakeFace;\n#define ONE_RADIAN (M_PI / 180.)\n#define SQUARE(x) ((x) * (x))\n;\n\tSECTION(\"Normal\")\n\t{\n\t\tLine3 line(Point3(94., 32., 4.8), Direction3(2.65, 3.28, 5.14));\n\t\tLine3 line2 = line.Normal(Point3(2.1, 3.4, 11.2));\n\t\tCHECK(line.Direction().Dot(line2.Direction()) == Approx(0.).margin(1e-6));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] auto SquaredDistance(const LineS& l)\t @return The squared distance between two lines\n\t @param l The other line\n\t @brief Compute the squared distance between two lines\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <math/LineT.hpp>\n#include <math/Plane.hpp>\n#include <modeling/MakeFace.hpp>\n#include <modeling/MakeEdge.hpp>\nusing AMCAX::Line3;\nusing AMCAX::MakeEdge;\nusing AMCAX::MakeFace;\n#define ONE_RADIAN (M_PI / 180.)\n#define SQUARE(x) ((x) * (x))\n#include <catch.hpp>\n#include <testHelper.h>\n#include <math/LineT.hpp>\n#include <math/Plane.hpp>\n#include <modeling/MakeFace.hpp>\n#include <modeling/MakeEdge.hpp>\nusing AMCAX::Line3;\nusing AMCAX::MakeEdge;\nusing AMCAX::MakeFace;\n#define ONE_RADIAN (M_PI / 180.)\n#define SQUARE(x) ((x) * (x))\n;\n\tSECTION(\"Distance and SquaredDistance\")\n\t{\n\t\tauto pointToLine = [](const Point3& p, const Line3& line) {\n\t\t\tconst Point3& p1 = line.Location();\n\t\t\tdouble dX = p1.X() - p.X();\n\t\t\tdouble dY = p1.Y() - p.Y();\n\t\t\tdouble dZ = p1.Z() - p.Z();\n\t\t\tdouble pp1Square = SQUARE(dX) + SQUARE(dY) + SQUARE(dZ);\n\t\t\tDirection3 dir(dX, dY, dZ);\n\t\t\tdouble cos = std::fabs(dir.Dot(line.Direction()));\n\t\t\treturn std::sqrt(pp1Square - SQUARE(cos*std::sqrt(pp1Square)));\n\t\t};\n\t\tauto lineToLine = [&pointToLine](const Line3& line1, const Line3& line2) {\n\t\t\tif (line1.Direction().IsParallel(line2.Direction(), std::numeric_limits<double>::min()))\n\t\t\t\treturn pointToLine(line1.Location(), line2);\n\t\t\tDirection3 line1Dir = line1.Direction();\n\t\t\tDirection3 line2Dir = line2.Direction();\n\t\t\tdouble x3 = line1Dir.Y() * line2Dir.Z() - line2Dir.Y() * line1Dir.Z();\n\t\t\tdouble y3 = -(line1Dir.X() * line2Dir.Z() - line2Dir.X() * line1Dir.Z());\n\t\t\tdouble z3 = line1Dir.X() * line2Dir.Y() - line2Dir.X() * line1Dir.Y();\n\t\t\tDirection3 line3Dir(x3, y3, z3);\n\t\t\tDirection3 line12Dir(line1.Location().X() - line2.Location().X(), \n\t\t\t\t\t\t\t\t line1.Location().Y() - line2.Location().Y(), line1.Location().Z() - line2.Location().Z());\n\t\t\treturn std::fabs(line3Dir.Dot(line12Dir));\n\t\t};\n\t\tLine3 line(Point3(99., 2., 33.), Direction3(2.3, 4.6, 9.8));\n\t\tCHECK(line.Distance(Point3(0., 1., 0.)) == Approx(pointToLine(Point3(0., 1., 0.), line)).margin(1e-5));\n\t\tLine3 line2(Point3(0., 0., 0.), Direction3(1., 0., 0.));\n\t\tLine3 line3(Point3(0., 1., 0.), Direction3(1., 0., 0.));\n\t\tCHECK(line2.Distance(line3) == Approx(lineToLine(line2, line3)).margin(std::numeric_limits<double>::min()));\n\t\tCHECK(line2.SquaredDistance(line3) == Approx(SQUARE(lineToLine(line2, line3))).margin(std::numeric_limits<double>::min()));\n\t\tLine3 line4(Point3(0., 0., 0.), Direction3(1., 0., 0.));\n\t\tLine3 line5(Point3(0., 1., 0.), Direction3(1., 1., 0.));\n\t\tCHECK(line4.Distance(line5) == Approx(lineToLine(line4, line5)).margin(std::numeric_limits<double>::min()));\n\t\tLine3 line6(Point3(0., 0., 0.), Direction3(0., 0., 1.));\n\t\tLine3 line7(Point3(0., 1., 0.), Direction3(1., 1., 0.));\n\t\tCHECK(line6.Distance(line7) == Approx(lineToLine(line6, line7)).margin(std::numeric_limits<double>::min()));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] auto Distance(const LineS& l)\t @return The distance between two lines\n\t @param l The other line\n\t @brief Compute the distance between two lines\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <math/LineT.hpp>\n#include <math/Plane.hpp>\n#include <modeling/MakeFace.hpp>\n#include <modeling/MakeEdge.hpp>\nusing AMCAX::Line3;\nusing AMCAX::MakeEdge;\nusing AMCAX::MakeFace;\n#define ONE_RADIAN (M_PI / 180.)\n#define SQUARE(x) ((x) * (x))\n#include <catch.hpp>\n#include <testHelper.h>\n#include <math/LineT.hpp>\n#include <math/Plane.hpp>\n#include <modeling/MakeFace.hpp>\n#include <modeling/MakeEdge.hpp>\nusing AMCAX::Line3;\nusing AMCAX::MakeEdge;\nusing AMCAX::MakeFace;\n#define ONE_RADIAN (M_PI / 180.)\n#define SQUARE(x) ((x) * (x))\n;\n\tSECTION(\"Distance and SquaredDistance\")\n\t{\n\t\tauto pointToLine = [](const Point3& p, const Line3& line) {\n\t\t\tconst Point3& p1 = line.Location();\n\t\t\tdouble dX = p1.X() - p.X();\n\t\t\tdouble dY = p1.Y() - p.Y();\n\t\t\tdouble dZ = p1.Z() - p.Z();\n\t\t\tdouble pp1Square = SQUARE(dX) + SQUARE(dY) + SQUARE(dZ);\n\t\t\tDirection3 dir(dX, dY, dZ);\n\t\t\tdouble cos = std::fabs(dir.Dot(line.Direction()));\n\t\t\treturn std::sqrt(pp1Square - SQUARE(cos*std::sqrt(pp1Square)));\n\t\t};\n\t\tauto lineToLine = [&pointToLine](const Line3& line1, const Line3& line2) {\n\t\t\tif (line1.Direction().IsParallel(line2.Direction(), std::numeric_limits<double>::min()))\n\t\t\t\treturn pointToLine(line1.Location(), line2);\n\t\t\tDirection3 line1Dir = line1.Direction();\n\t\t\tDirection3 line2Dir = line2.Direction();\n\t\t\tdouble x3 = line1Dir.Y() * line2Dir.Z() - line2Dir.Y() * line1Dir.Z();\n\t\t\tdouble y3 = -(line1Dir.X() * line2Dir.Z() - line2Dir.X() * line1Dir.Z());\n\t\t\tdouble z3 = line1Dir.X() * line2Dir.Y() - line2Dir.X() * line1Dir.Y();\n\t\t\tDirection3 line3Dir(x3, y3, z3);\n\t\t\tDirection3 line12Dir(line1.Location().X() - line2.Location().X(), \n\t\t\t\t\t\t\t\t line1.Location().Y() - line2.Location().Y(), line1.Location().Z() - line2.Location().Z());\n\t\t\treturn std::fabs(line3Dir.Dot(line12Dir));\n\t\t};\n\t\tLine3 line(Point3(99., 2., 33.), Direction3(2.3, 4.6, 9.8));\n\t\tCHECK(line.Distance(Point3(0., 1., 0.)) == Approx(pointToLine(Point3(0., 1., 0.), line)).margin(1e-5));\n\t\tLine3 line2(Point3(0., 0., 0.), Direction3(1., 0., 0.));\n\t\tLine3 line3(Point3(0., 1., 0.), Direction3(1., 0., 0.));\n\t\tCHECK(line2.Distance(line3) == Approx(lineToLine(line2, line3)).margin(std::numeric_limits<double>::min()));\n\t\tCHECK(line2.SquaredDistance(line3) == Approx(SQUARE(lineToLine(line2, line3))).margin(std::numeric_limits<double>::min()));\n\t\tLine3 line4(Point3(0., 0., 0.), Direction3(1., 0., 0.));\n\t\tLine3 line5(Point3(0., 1., 0.), Direction3(1., 1., 0.));\n\t\tCHECK(line4.Distance(line5) == Approx(lineToLine(line4, line5)).margin(std::numeric_limits<double>::min()));\n\t\tLine3 line6(Point3(0., 0., 0.), Direction3(0., 0., 1.));\n\t\tLine3 line7(Point3(0., 1., 0.), Direction3(1., 1., 0.));\n\t\tCHECK(line6.Distance(line7) == Approx(lineToLine(line6, line7)).margin(std::numeric_limits<double>::min()));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] auto Distance(const Point2& p)\t @return The distance between the point and the line\n\t @param p The point\n\t @brief Compute the distance from a point to the line\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <math/LineT.hpp>\n#include <math/Plane.hpp>\n#include <modeling/MakeFace.hpp>\n#include <modeling/MakeEdge.hpp>\nusing AMCAX::Line3;\nusing AMCAX::MakeEdge;\nusing AMCAX::MakeFace;\n#define ONE_RADIAN (M_PI / 180.)\n#define SQUARE(x) ((x) * (x))\n#include <catch.hpp>\n#include <testHelper.h>\n#include <math/LineT.hpp>\n#include <math/Plane.hpp>\n#include <modeling/MakeFace.hpp>\n#include <modeling/MakeEdge.hpp>\nusing AMCAX::Line3;\nusing AMCAX::MakeEdge;\nusing AMCAX::MakeFace;\n#define ONE_RADIAN (M_PI / 180.)\n#define SQUARE(x) ((x) * (x))\n;\n\tSECTION(\"Transform\")\n\t{\n\t\tLine3 line(Point3(), Direction3(0., 1., 0.));\n\t\tTransformation3 translationTransform;\n\t\ttranslationTransform.SetTranslation(Point3(0., 0., 0.), Point3(1., 1., 1.));  \n\t\tLine3 translationLine = line.Transformed(translationTransform);\n\t\tCHECK(translationLine.Direction().IsEqual(line.Direction(), 1e-6 * ONE_RADIAN));\n\t\tCHECK(translationLine.Contains(Point3(1., 1., 1.), 1e-6));\n\t\tTransformation3 rotationTransfrom;\n\t\trotationTransfrom.SetRotation(Axis3(Point3(), Direction3(1., 0., 0.)), 90. * ONE_RADIAN);  \n\t\tLine3 rotationLine = line.Transformed(rotationTransfrom);\n\t\tCHECK(rotationLine.Direction().IsEqual(Direction3(0., 0., 1.), 1e-6 * ONE_RADIAN));\n\t\tCHECK(rotationLine.Contains(Point3(0., 0., 3.), 1e-6) == true);\n\t\tTransformation3 scaleTransfrom;\n\t\tscaleTransfrom.SetScale(Point3(1., 0., 1.), -1.); \n\t\tLine3 scaleLine = line.Transformed(scaleTransfrom);\n\t\tCHECK(line.Distance(Point3(1., 0., 1.)) == scaleLine.Distance(Point3(1., 0., 1.)));\n\t\tCHECK(scaleLine.Direction().IsEqual(Direction3(0., -1., 0.), 1e-6*ONE_RADIAN));\n\t\tTransformation3 mirrorTransfrom;\n\t\tmirrorTransfrom.SetMirror(Frame3(Point3(0., 0., 0.), Direction3(1., 0., 0.)));\n\t\tLine3 mirrorLine = line.Transformed(mirrorTransfrom);\n\t\tCHECK(line.Distance(Point3(0., 0., 0.)) == mirrorLine.Distance(Point3(0., 0., 0.)));\n\t\tAMCAX::OCCTIO::OCCTTool::Write(MakeEdge(line), OUTPUT_PATH_PREFIX\"Line3_Transform_InitialLine.brep\");\n\t\tTransformation3 CombinedTransfrom = scaleTransfrom * mirrorTransfrom* translationTransform * rotationTransfrom;  \n\t\tline.Transform(CombinedTransfrom);\n\t\tAMCAX::OCCTIO::OCCTTool::Write(MakeEdge(line), OUTPUT_PATH_PREFIX\"Line3_Transform_transformLine.brep\");\n\t\tCHECK(line.Contains(Point3(3., -1., 1.), 1e-6) == true);\n\t\tCHECK(line.Direction().IsEqual(Direction3(0., 0., -1.), 1e-6 * ONE_RADIAN));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] Derived Reversed()\t @return The line with reversed direction\n\t @brief Get the line with reversed direction\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <math/LineT.hpp>\n#include <math/Plane.hpp>\n#include <modeling/MakeFace.hpp>\n#include <modeling/MakeEdge.hpp>\nusing AMCAX::Line3;\nusing AMCAX::MakeEdge;\nusing AMCAX::MakeFace;\n#define ONE_RADIAN (M_PI / 180.)\n#define SQUARE(x) ((x) * (x))\n#include <catch.hpp>\n#include <testHelper.h>\n#include <math/LineT.hpp>\n#include <math/Plane.hpp>\n#include <modeling/MakeFace.hpp>\n#include <modeling/MakeEdge.hpp>\nusing AMCAX::Line3;\nusing AMCAX::MakeEdge;\nusing AMCAX::MakeFace;\n#define ONE_RADIAN (M_PI / 180.)\n#define SQUARE(x) ((x) * (x))\n;\n\tSECTION(\"Reverse\")\n\t{\n\t\tLine3 line(Point3(), Direction3(1., 1., 1.));\n\t\tLine3 reverseLine = line.Reversed();\n\t\tCHECK(reverseLine.Direction().IsEqual(Direction3(-1., -1., -1.), 1e-6 * ONE_RADIAN));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] auto Angle(const LineBase& other)\t @return The angle between the line and the other line\n\t @param other The other line\n\t @brief Compute the angle between the line and the other line\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <math/LineT.hpp>\n#include <math/Plane.hpp>\n#include <modeling/MakeFace.hpp>\n#include <modeling/MakeEdge.hpp>\nusing AMCAX::Line3;\nusing AMCAX::MakeEdge;\nusing AMCAX::MakeFace;\n#define ONE_RADIAN (M_PI / 180.)\n#define SQUARE(x) ((x) * (x))\n#include <catch.hpp>\n#include <testHelper.h>\n#include <math/LineT.hpp>\n#include <math/Plane.hpp>\n#include <modeling/MakeFace.hpp>\n#include <modeling/MakeEdge.hpp>\nusing AMCAX::Line3;\nusing AMCAX::MakeEdge;\nusing AMCAX::MakeFace;\n#define ONE_RADIAN (M_PI / 180.)\n#define SQUARE(x) ((x) * (x))\n;\n\tSECTION(\"Angle\")\n\t{\n\t\tLine3 line(Point3(0., 1., 0.), Direction3(1., 1., 1.));\n\t\tLine3 line2(Point3(0., 3.4, 0.), Direction3(2., -1., -1.5));\n\t\tCHECK(line.Angle(line2) == Approx(std::acos(line.Direction().Dot(line2.Direction()))).margin(1e-6 * ONE_RADIAN));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] const AxisT<double, DIM>& Position()\t @return The axis of the line\n\t @brief Get the axis of the line\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <math/LineT.hpp>\n#include <math/Plane.hpp>\n#include <modeling/MakeFace.hpp>\n#include <modeling/MakeEdge.hpp>\nusing AMCAX::Line3;\nusing AMCAX::MakeEdge;\nusing AMCAX::MakeFace;\n#define ONE_RADIAN (M_PI / 180.)\n#define SQUARE(x) ((x) * (x))\n#include <catch.hpp>\n#include <testHelper.h>\n#include <math/LineT.hpp>\n#include <math/Plane.hpp>\n#include <modeling/MakeFace.hpp>\n#include <modeling/MakeEdge.hpp>\nusing AMCAX::Line3;\nusing AMCAX::MakeEdge;\nusing AMCAX::MakeFace;\n#define ONE_RADIAN (M_PI / 180.)\n#define SQUARE(x) ((x) * (x))\n;\n\tSECTION(\"constructor\")\n\t{\n\t\tLine3 line;  \n\t\tCHECK(line.Location().IsEqual(Point3(0., 0., 0.), 1e-5));\n\t\tCHECK(line.Direction().IsEqual(Direction3(0., 0., 1.), 1e-5 * ONE_RADIAN));\n\t\tAxis3 axis(Point3(1., 1., 1.), Direction3(3., 3., 4.));\n\t\tLine3 line2(axis);\n\t\tCHECK(line2.Position().IsCoaxial(axis, 1e-5 * ONE_RADIAN, 1e-5));  \n\t\tLine3 line3(Point3(1., 2., 3.), Direction3(3., 2., 1.));\n\t\tCHECK(line3.Location().IsEqual(Point3(1., 2., 3.), 1e-5));\n\t\tCHECK(line3.Direction().IsEqual(Direction3(3., 2., 1.), 1e-5 * ONE_RADIAN));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] const DirectionT<double, DIM>& Direction()\t @return The direction of the line\n\t @brief Get the direction of the line\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <math/LineT.hpp>\n#include <math/Plane.hpp>\n#include <modeling/MakeFace.hpp>\n#include <modeling/MakeEdge.hpp>\nusing AMCAX::Line3;\nusing AMCAX::MakeEdge;\nusing AMCAX::MakeFace;\n#define ONE_RADIAN (M_PI / 180.)\n#define SQUARE(x) ((x) * (x))\n#include <catch.hpp>\n#include <testHelper.h>\n#include <math/LineT.hpp>\n#include <math/Plane.hpp>\n#include <modeling/MakeFace.hpp>\n#include <modeling/MakeEdge.hpp>\nusing AMCAX::Line3;\nusing AMCAX::MakeEdge;\nusing AMCAX::MakeFace;\n#define ONE_RADIAN (M_PI / 180.)\n#define SQUARE(x) ((x) * (x))\n;\n\tSECTION(\"constructor\")\n\t{\n\t\tLine3 line;  \n\t\tCHECK(line.Location().IsEqual(Point3(0., 0., 0.), 1e-5));\n\t\tCHECK(line.Direction().IsEqual(Direction3(0., 0., 1.), 1e-5 * ONE_RADIAN));\n\t\tAxis3 axis(Point3(1., 1., 1.), Direction3(3., 3., 4.));\n\t\tLine3 line2(axis);\n\t\tCHECK(line2.Position().IsCoaxial(axis, 1e-5 * ONE_RADIAN, 1e-5));  \n\t\tLine3 line3(Point3(1., 2., 3.), Direction3(3., 2., 1.));\n\t\tCHECK(line3.Location().IsEqual(Point3(1., 2., 3.), 1e-5));\n\t\tCHECK(line3.Direction().IsEqual(Direction3(3., 2., 1.), 1e-5 * ONE_RADIAN));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "void SetPosition(const AxisT<double, DIM>& axis)\t @param axis The axis\n\t @brief Set the axis of the line\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <math/LineT.hpp>\n#include <math/Plane.hpp>\n#include <modeling/MakeFace.hpp>\n#include <modeling/MakeEdge.hpp>\nusing AMCAX::Line3;\nusing AMCAX::MakeEdge;\nusing AMCAX::MakeFace;\n#define ONE_RADIAN (M_PI / 180.)\n#define SQUARE(x) ((x) * (x))\n#include <catch.hpp>\n#include <testHelper.h>\n#include <math/LineT.hpp>\n#include <math/Plane.hpp>\n#include <modeling/MakeFace.hpp>\n#include <modeling/MakeEdge.hpp>\nusing AMCAX::Line3;\nusing AMCAX::MakeEdge;\nusing AMCAX::MakeFace;\n#define ONE_RADIAN (M_PI / 180.)\n#define SQUARE(x) ((x) * (x))\n;\n\tSECTION(\"SetPosition\")\n\t{\n\t\tAxis3 axis(Point3(0.1, -2.3, 0.3), Direction3(1.2, -8.9, 3.));\n\t\tLine3 line;\n\t\tline.SetPosition(axis);\n\t\tCHECK(line.Location().IsEqual(axis.Location(), std::numeric_limits<double>::min()));\n\t\tCHECK(line.Direction().IsEqual(axis.Direction(), std::numeric_limits<double>::min()));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "void SetDirection(const DirectionT<double, DIM>& dir)\t @param dir The line direction\n\t @brief Set the line direction\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <math/LineT.hpp>\n#include <math/Plane.hpp>\n#include <modeling/MakeFace.hpp>\n#include <modeling/MakeEdge.hpp>\nusing AMCAX::Line3;\nusing AMCAX::MakeEdge;\nusing AMCAX::MakeFace;\n#define ONE_RADIAN (M_PI / 180.)\n#define SQUARE(x) ((x) * (x))\n#include <catch.hpp>\n#include <testHelper.h>\n#include <math/LineT.hpp>\n#include <math/Plane.hpp>\n#include <modeling/MakeFace.hpp>\n#include <modeling/MakeEdge.hpp>\nusing AMCAX::Line3;\nusing AMCAX::MakeEdge;\nusing AMCAX::MakeFace;\n#define ONE_RADIAN (M_PI / 180.)\n#define SQUARE(x) ((x) * (x))\n;\n\tSECTION(\"SetDirection\")\n\t{\n\t\tDirection3 dir(1., 1., 1.);\n\t\tLine3 line;\n\t\tline.SetDirection(dir);\n\t\tCHECK(line.Direction().IsEqual(dir, std::numeric_limits<double>::min()));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "void SetLocation(const PointT<double, DIM>& point)\t @param point The location point\n\t @brief Set the location of the line\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <math/LineT.hpp>\n#include <math/Plane.hpp>\n#include <modeling/MakeFace.hpp>\n#include <modeling/MakeEdge.hpp>\nusing AMCAX::Line3;\nusing AMCAX::MakeEdge;\nusing AMCAX::MakeFace;\n#define ONE_RADIAN (M_PI / 180.)\n#define SQUARE(x) ((x) * (x))\n#include <catch.hpp>\n#include <testHelper.h>\n#include <math/LineT.hpp>\n#include <math/Plane.hpp>\n#include <modeling/MakeFace.hpp>\n#include <modeling/MakeEdge.hpp>\nusing AMCAX::Line3;\nusing AMCAX::MakeEdge;\nusing AMCAX::MakeFace;\n#define ONE_RADIAN (M_PI / 180.)\n#define SQUARE(x) ((x) * (x))\n;\n\tSECTION(\"SetLocation\")\n\t{\n\t\tLine3 line(Point3(2., 3., 2.), Direction3(2., 3.4, -2.));\n\t\tline.SetLocation(Point3(1., -2., 8.));\n\t\tCHECK(line.Location().IsEqual(Point3(1., -2., 8.), std::numeric_limits<double>::min()));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] Derived Translated(const PointT<double, DIM>& p1, const PointT<double, DIM>& p2)\t @return The translated line\n\t @param p2 The target point\n\t @param p1 The source point\n\t @brief Get the line translated by a vector from a point to another point\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <math/LineT.hpp>\n#include <math/Plane.hpp>\n#include <modeling/MakeFace.hpp>\n#include <modeling/MakeEdge.hpp>\nusing AMCAX::Line3;\nusing AMCAX::MakeEdge;\nusing AMCAX::MakeFace;\n#define ONE_RADIAN (M_PI / 180.)\n#define SQUARE(x) ((x) * (x))\n#include <catch.hpp>\n#include <testHelper.h>\n#include <math/LineT.hpp>\n#include <math/Plane.hpp>\n#include <modeling/MakeFace.hpp>\n#include <modeling/MakeEdge.hpp>\nusing AMCAX::Line3;\nusing AMCAX::MakeEdge;\nusing AMCAX::MakeFace;\n#define ONE_RADIAN (M_PI / 180.)\n#define SQUARE(x) ((x) * (x))\n;\n\tSECTION(\"Translate\")\n\t{\n\t\tLine3 line(Point3(), Direction3(1., 1., 1.));\n\t\tLine3 originalLine(Point3(), Direction3(1., 1., 1.));\n\t\tline.Translate(Point3(), Point3(0., 1., 0.));\n\t\tCHECK(originalLine.Direction().IsEqual(line.Direction(), 1e-6 * ONE_RADIAN));\n\t\tCHECK(line.Contains(Point3(0., 1., 0.), 1e-6));\n\t\tLine3 line2 = line.Translated(Vector3(Direction3(1., -1., 1.)));\n\t\tCHECK(line.Direction().IsEqual(line2.Direction(), 1e-6 * ONE_RADIAN));\n\t\tCHECK(line2.Contains(Point3(0. + 1. / std::sqrt(3.), 1 - 1. / std::sqrt(3.), 0. + 1. / std::sqrt(3.)), 1e-6));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] Derived Translated(const VectorT<double, DIM>& vec)\t @return The translated line\n\t @param vec The translation vector\n\t @brief Get the line translated by a vector\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <math/LineT.hpp>\n#include <math/Plane.hpp>\n#include <modeling/MakeFace.hpp>\n#include <modeling/MakeEdge.hpp>\nusing AMCAX::Line3;\nusing AMCAX::MakeEdge;\nusing AMCAX::MakeFace;\n#define ONE_RADIAN (M_PI / 180.)\n#define SQUARE(x) ((x) * (x))\n#include <catch.hpp>\n#include <testHelper.h>\n#include <math/LineT.hpp>\n#include <math/Plane.hpp>\n#include <modeling/MakeFace.hpp>\n#include <modeling/MakeEdge.hpp>\nusing AMCAX::Line3;\nusing AMCAX::MakeEdge;\nusing AMCAX::MakeFace;\n#define ONE_RADIAN (M_PI / 180.)\n#define SQUARE(x) ((x) * (x))\n;\n\tSECTION(\"Translate\")\n\t{\n\t\tLine3 line(Point3(), Direction3(1., 1., 1.));\n\t\tLine3 originalLine(Point3(), Direction3(1., 1., 1.));\n\t\tline.Translate(Point3(), Point3(0., 1., 0.));\n\t\tCHECK(originalLine.Direction().IsEqual(line.Direction(), 1e-6 * ONE_RADIAN));\n\t\tCHECK(line.Contains(Point3(0., 1., 0.), 1e-6));\n\t\tLine3 line2 = line.Translated(Vector3(Direction3(1., -1., 1.)));\n\t\tCHECK(line.Direction().IsEqual(line2.Direction(), 1e-6 * ONE_RADIAN));\n\t\tCHECK(line2.Contains(Point3(0. + 1. / std::sqrt(3.), 1 - 1. / std::sqrt(3.), 0. + 1. / std::sqrt(3.)), 1e-6));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "Derived& Translate(const PointT<double, DIM>& p1, const PointT<double, DIM>& p2)\t @return The reference to self\n\t @param p2 The target point\n\t @param p1 The source point\n\t @brief Translate the line by a vector from a point to another point\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <math/LineT.hpp>\n#include <math/Plane.hpp>\n#include <modeling/MakeFace.hpp>\n#include <modeling/MakeEdge.hpp>\nusing AMCAX::Line3;\nusing AMCAX::MakeEdge;\nusing AMCAX::MakeFace;\n#define ONE_RADIAN (M_PI / 180.)\n#define SQUARE(x) ((x) * (x))\n#include <catch.hpp>\n#include <testHelper.h>\n#include <math/LineT.hpp>\n#include <math/Plane.hpp>\n#include <modeling/MakeFace.hpp>\n#include <modeling/MakeEdge.hpp>\nusing AMCAX::Line3;\nusing AMCAX::MakeEdge;\nusing AMCAX::MakeFace;\n#define ONE_RADIAN (M_PI / 180.)\n#define SQUARE(x) ((x) * (x))\n;\n\tSECTION(\"Translate\")\n\t{\n\t\tLine3 line(Point3(), Direction3(1., 1., 1.));\n\t\tLine3 originalLine(Point3(), Direction3(1., 1., 1.));\n\t\tline.Translate(Point3(), Point3(0., 1., 0.));\n\t\tCHECK(originalLine.Direction().IsEqual(line.Direction(), 1e-6 * ONE_RADIAN));\n\t\tCHECK(line.Contains(Point3(0., 1., 0.), 1e-6));\n\t\tLine3 line2 = line.Translated(Vector3(Direction3(1., -1., 1.)));\n\t\tCHECK(line.Direction().IsEqual(line2.Direction(), 1e-6 * ONE_RADIAN));\n\t\tCHECK(line2.Contains(Point3(0. + 1. / std::sqrt(3.), 1 - 1. / std::sqrt(3.), 0. + 1. / std::sqrt(3.)), 1e-6));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] Derived Transformed(const TransformationT<double, DIM>& tr)\t @return The transformed line\n\t @param tr The transformation\n\t @brief Get the transformed line\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <math/LineT.hpp>\n#include <math/Plane.hpp>\n#include <modeling/MakeFace.hpp>\n#include <modeling/MakeEdge.hpp>\nusing AMCAX::Line3;\nusing AMCAX::MakeEdge;\nusing AMCAX::MakeFace;\n#define ONE_RADIAN (M_PI / 180.)\n#define SQUARE(x) ((x) * (x))\n#include <catch.hpp>\n#include <testHelper.h>\n#include <math/LineT.hpp>\n#include <math/Plane.hpp>\n#include <modeling/MakeFace.hpp>\n#include <modeling/MakeEdge.hpp>\nusing AMCAX::Line3;\nusing AMCAX::MakeEdge;\nusing AMCAX::MakeFace;\n#define ONE_RADIAN (M_PI / 180.)\n#define SQUARE(x) ((x) * (x))\n;\n\tSECTION(\"Transform\")\n\t{\n\t\tLine3 line(Point3(), Direction3(0., 1., 0.));\n\t\tTransformation3 translationTransform;\n\t\ttranslationTransform.SetTranslation(Point3(0., 0., 0.), Point3(1., 1., 1.));  \n\t\tLine3 translationLine = line.Transformed(translationTransform);\n\t\tCHECK(translationLine.Direction().IsEqual(line.Direction(), 1e-6 * ONE_RADIAN));\n\t\tCHECK(translationLine.Contains(Point3(1., 1., 1.), 1e-6));\n\t\tTransformation3 rotationTransfrom;\n\t\trotationTransfrom.SetRotation(Axis3(Point3(), Direction3(1., 0., 0.)), 90. * ONE_RADIAN);  \n\t\tLine3 rotationLine = line.Transformed(rotationTransfrom);\n\t\tCHECK(rotationLine.Direction().IsEqual(Direction3(0., 0., 1.), 1e-6 * ONE_RADIAN));\n\t\tCHECK(rotationLine.Contains(Point3(0., 0., 3.), 1e-6) == true);\n\t\tTransformation3 scaleTransfrom;\n\t\tscaleTransfrom.SetScale(Point3(1., 0., 1.), -1.); \n\t\tLine3 scaleLine = line.Transformed(scaleTransfrom);\n\t\tCHECK(line.Distance(Point3(1., 0., 1.)) == scaleLine.Distance(Point3(1., 0., 1.)));\n\t\tCHECK(scaleLine.Direction().IsEqual(Direction3(0., -1., 0.), 1e-6*ONE_RADIAN));\n\t\tTransformation3 mirrorTransfrom;\n\t\tmirrorTransfrom.SetMirror(Frame3(Point3(0., 0., 0.), Direction3(1., 0., 0.)));\n\t\tLine3 mirrorLine = line.Transformed(mirrorTransfrom);\n\t\tCHECK(line.Distance(Point3(0., 0., 0.)) == mirrorLine.Distance(Point3(0., 0., 0.)));\n\t\tAMCAX::OCCTIO::OCCTTool::Write(MakeEdge(line), OUTPUT_PATH_PREFIX\"Line3_Transform_InitialLine.brep\");\n\t\tTransformation3 CombinedTransfrom = scaleTransfrom * mirrorTransfrom* translationTransform * rotationTransfrom;  \n\t\tline.Transform(CombinedTransfrom);\n\t\tAMCAX::OCCTIO::OCCTTool::Write(MakeEdge(line), OUTPUT_PATH_PREFIX\"Line3_Transform_transformLine.brep\");\n\t\tCHECK(line.Contains(Point3(3., -1., 1.), 1e-6) == true);\n\t\tCHECK(line.Direction().IsEqual(Direction3(0., 0., -1.), 1e-6 * ONE_RADIAN));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] Derived Scaled(const PointT<double, DIM>& point, double scale)\t @return The scaled line\n\t @param scale The scale value\n\t @param point The scaling center point\n\t @brief Get the line scaled by a point\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <math/LineT.hpp>\n#include <math/Plane.hpp>\n#include <modeling/MakeFace.hpp>\n#include <modeling/MakeEdge.hpp>\nusing AMCAX::Line3;\nusing AMCAX::MakeEdge;\nusing AMCAX::MakeFace;\n#define ONE_RADIAN (M_PI / 180.)\n#define SQUARE(x) ((x) * (x))\n#include <catch.hpp>\n#include <testHelper.h>\n#include <math/LineT.hpp>\n#include <math/Plane.hpp>\n#include <modeling/MakeFace.hpp>\n#include <modeling/MakeEdge.hpp>\nusing AMCAX::Line3;\nusing AMCAX::MakeEdge;\nusing AMCAX::MakeFace;\n#define ONE_RADIAN (M_PI / 180.)\n#define SQUARE(x) ((x) * (x))\n;\n\tSECTION(\"Scale\")\n\t{\n\t\tLine3 line(Point3(), Direction3(0., 1., 0.));\n\t\tPoint3 point(1., 1., 0.);\n\t\tdouble originalDistance = line.Distance(point);\n\t\tLine3 line1 = line.Scaled(point, 1.1);\n\t\tCHECK(line1.Distance(point) > originalDistance);\n\t\tLine3 line2 = line.Scaled(point, 1.);\n\t\tCHECK(line2.Distance(point) == originalDistance);\n\t\tLine3 line3 = line.Scaled(point, 0.8);\n\t\tCHECK(line3.Distance(point) < originalDistance);\n\t\tLine3 line4 = line.Scaled(point, 0.);\n\t\tCHECK(line4.Contains(point, 1e-6));\n\t\tLine3 line5 = line.Scaled(point, -1.);\n\t\tCHECK(line5.Direction().IsEqual(Direction3(0., -1., 0.), 1e-6 * ONE_RADIAN));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "Derived& Scale(const PointT<double, DIM>& point, double scale)\t @return The reference to self\n\t @param scale The scale value\n\t @param point The scaling center point\n\t @brief Scale the line by a point\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <math/LineT.hpp>\n#include <math/Plane.hpp>\n#include <modeling/MakeFace.hpp>\n#include <modeling/MakeEdge.hpp>\nusing AMCAX::Line3;\nusing AMCAX::MakeEdge;\nusing AMCAX::MakeFace;\n#define ONE_RADIAN (M_PI / 180.)\n#define SQUARE(x) ((x) * (x))\n#include <catch.hpp>\n#include <testHelper.h>\n#include <math/LineT.hpp>\n#include <math/Plane.hpp>\n#include <modeling/MakeFace.hpp>\n#include <modeling/MakeEdge.hpp>\nusing AMCAX::Line3;\nusing AMCAX::MakeEdge;\nusing AMCAX::MakeFace;\n#define ONE_RADIAN (M_PI / 180.)\n#define SQUARE(x) ((x) * (x))\n;\n\tSECTION(\"Scale\")\n\t{\n\t\tLine3 line(Point3(), Direction3(0., 1., 0.));\n\t\tPoint3 point(1., 1., 0.);\n\t\tdouble originalDistance = line.Distance(point);\n\t\tLine3 line1 = line.Scaled(point, 1.1);\n\t\tCHECK(line1.Distance(point) > originalDistance);\n\t\tLine3 line2 = line.Scaled(point, 1.);\n\t\tCHECK(line2.Distance(point) == originalDistance);\n\t\tLine3 line3 = line.Scaled(point, 0.8);\n\t\tCHECK(line3.Distance(point) < originalDistance);\n\t\tLine3 line4 = line.Scaled(point, 0.);\n\t\tCHECK(line4.Contains(point, 1e-6));\n\t\tLine3 line5 = line.Scaled(point, -1.);\n\t\tCHECK(line5.Direction().IsEqual(Direction3(0., -1., 0.), 1e-6 * ONE_RADIAN));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] const PointT<double, DIM>& Location()\t @return The location of the line\n\t @brief Get the location point of the line\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <math/LineT.hpp>\n#include <math/Plane.hpp>\n#include <modeling/MakeFace.hpp>\n#include <modeling/MakeEdge.hpp>\nusing AMCAX::Line3;\nusing AMCAX::MakeEdge;\nusing AMCAX::MakeFace;\n#define ONE_RADIAN (M_PI / 180.)\n#define SQUARE(x) ((x) * (x))\n#include <catch.hpp>\n#include <testHelper.h>\n#include <math/LineT.hpp>\n#include <math/Plane.hpp>\n#include <modeling/MakeFace.hpp>\n#include <modeling/MakeEdge.hpp>\nusing AMCAX::Line3;\nusing AMCAX::MakeEdge;\nusing AMCAX::MakeFace;\n#define ONE_RADIAN (M_PI / 180.)\n#define SQUARE(x) ((x) * (x))\n;\n\tSECTION(\"constructor\")\n\t{\n\t\tLine3 line;  \n\t\tCHECK(line.Location().IsEqual(Point3(0., 0., 0.), 1e-5));\n\t\tCHECK(line.Direction().IsEqual(Direction3(0., 0., 1.), 1e-5 * ONE_RADIAN));\n\t\tAxis3 axis(Point3(1., 1., 1.), Direction3(3., 3., 4.));\n\t\tLine3 line2(axis);\n\t\tCHECK(line2.Position().IsCoaxial(axis, 1e-5 * ONE_RADIAN, 1e-5));  \n\t\tLine3 line3(Point3(1., 2., 3.), Direction3(3., 2., 1.));\n\t\tCHECK(line3.Location().IsEqual(Point3(1., 2., 3.), 1e-5));\n\t\tCHECK(line3.Direction().IsEqual(Direction3(3., 2., 1.), 1e-5 * ONE_RADIAN));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] bool Contains(const PointT<double, DIM>& p, double tol)\t @return True if the point is on the line under the tolerance\n\t @param tol The tolerance\n\t @param p The point\n\t @brief Does the line contain a point under a distance tolerance\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <math/LineT.hpp>\n#include <math/Plane.hpp>\n#include <modeling/MakeFace.hpp>\n#include <modeling/MakeEdge.hpp>\nusing AMCAX::Line3;\nusing AMCAX::MakeEdge;\nusing AMCAX::MakeFace;\n#define ONE_RADIAN (M_PI / 180.)\n#define SQUARE(x) ((x) * (x))\n#include <catch.hpp>\n#include <testHelper.h>\n#include <math/LineT.hpp>\n#include <math/Plane.hpp>\n#include <modeling/MakeFace.hpp>\n#include <modeling/MakeEdge.hpp>\nusing AMCAX::Line3;\nusing AMCAX::MakeEdge;\nusing AMCAX::MakeFace;\n#define ONE_RADIAN (M_PI / 180.)\n#define SQUARE(x) ((x) * (x))\n;\n\tSECTION(\"Scale\")\n\t{\n\t\tLine3 line(Point3(), Direction3(0., 1., 0.));\n\t\tPoint3 point(1., 1., 0.);\n\t\tdouble originalDistance = line.Distance(point);\n\t\tLine3 line1 = line.Scaled(point, 1.1);\n\t\tCHECK(line1.Distance(point) > originalDistance);\n\t\tLine3 line2 = line.Scaled(point, 1.);\n\t\tCHECK(line2.Distance(point) == originalDistance);\n\t\tLine3 line3 = line.Scaled(point, 0.8);\n\t\tCHECK(line3.Distance(point) < originalDistance);\n\t\tLine3 line4 = line.Scaled(point, 0.);\n\t\tCHECK(line4.Contains(point, 1e-6));\n\t\tLine3 line5 = line.Scaled(point, -1.);\n\t\tCHECK(line5.Direction().IsEqual(Direction3(0., -1., 0.), 1e-6 * ONE_RADIAN));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] auto SquaredDistance(const Point3& p)\t @return The squared distance between the point and the line\n\t @param p The point\n\t @brief Compute the squared distance from a point to the line\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <math/LineT.hpp>\n#include <modeling/MakeEdge2d.hpp>\nusing AMCAX::Line2;\n#define ONE_RADIAN (M_PI / 180.)\n#include <catch.hpp>\n#include <testHelper.h>\n#include <math/LineT.hpp>\n#include <modeling/MakeEdge2d.hpp>\nusing AMCAX::Line2;\n#define ONE_RADIAN (M_PI / 180.)\n;\n\tSECTION(\"Distance and SquaredDistance test\")\n\t{\n\t\tauto pointToLine = [](const Point2& point, const Line2& line) {\n\t\t\tdouble a, b, c;\n\t\t\tline.Coefficients(a, b, c);\n\t\t\treturn std::fabs(a * point.X() + b * point.Y() + c);\n\t\t};\n\t\tauto lineToLine = [](const Line2& line1, const Line2& line2) {\n\t\t\tdouble a1, b1, c1, a2, b2, c2;\n\t\t\tline1.Coefficients(a1, b1, c1);\n\t\t\tline2.Coefficients(a2, b2, c2);\n\t\t\tif (a1 != a2 || b1 != b2) return 0.;\n\t\t\treturn std::fabs(c1 - c2);\n\t\t};\n\t\tLine2 line(3., 4., -30.);\n\t\tPoint2 point1(6., 3.);\n\t\tPoint2 point2(6., 2.);\n\t\tLine2 line2(3., 4., -29.);\n\t\tLine2 line3(2., 1., -99.);\n\t\tCHECK(line.Distance(point1) == Approx(pointToLine(point1, line)).margin(0.01));\n\t\tCHECK(line.SquaredDistance(point1) == Approx(pointToLine(point1, line) * pointToLine(point1, line)).margin(0.01));\n\t\tCHECK(line.Distance(point2) == Approx(pointToLine(point2, line)));\n\t\tCHECK(line.SquaredDistance(point2) == Approx(pointToLine(point2, line) * pointToLine(point2, line)).margin(0.01));\n\t\tCHECK(line.Distance(line2) == Approx(lineToLine(line, line2)));\n\t\tCHECK(line.SquaredDistance(line2) == Approx(lineToLine(line2, line) * lineToLine(line2, line)).margin(0.01));\n\t\tCHECK(line.Distance(line3) == Approx(lineToLine(line, line3)));\n\t\tCHECK(line.SquaredDistance(line3) == Approx(lineToLine(line3, line) * lineToLine(line3, line)).margin(0.01));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] LineS Rotated(const Point2& point, double angle)\t @return The rotated line\n\t @param angle The rotation angle\n\t @param point The rotation center point\n\t @brief Get the line rotated around a point with an angle in 2D\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <math/LineT.hpp>\n#include <modeling/MakeEdge2d.hpp>\nusing AMCAX::Line2;\n#define ONE_RADIAN (M_PI / 180.)\n#include <catch.hpp>\n#include <testHelper.h>\n#include <math/LineT.hpp>\n#include <modeling/MakeEdge2d.hpp>\nusing AMCAX::Line2;\n#define ONE_RADIAN (M_PI / 180.)\n;\n\tSECTION(\"Rotated Test\")\n\t{\n\t\tLine2 line(Point2(0., 1.), Direction2(1., 1.));  \n\t\tLine2 rotateLine = line.Rotated(Point2(), (3. / 4) * M_PI);  \n\t\tCHECK(rotateLine.Direction().X() == Approx(-1.).margin(1e-5));\n\t\tCHECK(rotateLine.Direction().Y() == Approx(0.).margin(1e-5));\n\t\tdouble a, b, c;\n\t\trotateLine.Coefficients(a, b, c);\n\t\tCHECK((c - b) == Approx(0.).margin(0.5));\n\t\tCHECK(line.Distance(Point2()) == rotateLine.Distance(Point2()));  \n\t\tTopoShape lineShape1 = MakeEdge2d(line);\n\t\tTopoShape lineShape2 = MakeEdge2d(rotateLine);\n\t\tREQUIRE(OCCTIO::OCCTTool::Write(lineShape1, OUTPUT_PATH_PREFIX\"Line2_Rotated_before_p1.brep\"));\n\t\tREQUIRE(OCCTIO::OCCTTool::Write(lineShape2, OUTPUT_PATH_PREFIX\"Line2_Rotated_later_p1.brep\"));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "LineS& Rotate(const Point2& point, double angle)\t @return The reference to self\n\t @param angle The rotation angle\n\t @param point The rotation center point\n\t @brief Rotate the line around a point with an angle in 2D\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <math/LineT.hpp>\n#include <modeling/MakeEdge2d.hpp>\nusing AMCAX::Line2;\n#define ONE_RADIAN (M_PI / 180.)\n#include <catch.hpp>\n#include <testHelper.h>\n#include <math/LineT.hpp>\n#include <modeling/MakeEdge2d.hpp>\nusing AMCAX::Line2;\n#define ONE_RADIAN (M_PI / 180.)\n;\n\tSECTION(\"Rotate Test\")\n\t{\n\t\tLine2 line(Point2(0., 1.), Direction2(1., 1.));  \n\t\tLine2 line2(Point2(0., 1.), Direction2(1., 1.));  \n\t\tline.Rotate(Point2(), (5. / 4) * M_PI);  \n\t\tCHECK(line.Direction().X() == Approx(0.).margin(1e-5));\n\t\tCHECK(line.Direction().Y() == Approx(-1.).margin(1e-5));\n\t\tdouble a, b, c;\n\t\tline.Coefficients(a, b, c);\n\t\tCHECK((a + c) == Approx(0.).margin(0.5));\n\t\tCHECK(line2.Distance(Point2()) == line.Distance(Point2()));  \n\t\tCHECK(line.Contains(Point2(std::sqrt(2.) / 2., 0.), 1e-6) == true);\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] LineS Normal(const Point2& p)\t @return The line passing through a point and perpendicular to the line\n\t @param p The point\n\t @brief Get a line passing through a point and perpendicular to the line\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <math/LineT.hpp>\n#include <modeling/MakeEdge2d.hpp>\nusing AMCAX::Line2;\n#define ONE_RADIAN (M_PI / 180.)\n#include <catch.hpp>\n#include <testHelper.h>\n#include <math/LineT.hpp>\n#include <modeling/MakeEdge2d.hpp>\nusing AMCAX::Line2;\n#define ONE_RADIAN (M_PI / 180.)\n;\n\tSECTION(\"Normal Test\")\n\t{\n\t\tLine2 line(3., 4., 5.);  \n\t\tLine2 normalLine = line.Normal(Point2(1., 5.));\n\t\tdouble a, b, c;\n\t\tnormalLine.Coefficients(a, b, c);\n\t\tCHECK((a * 3 + b * 4) == Approx(0.0).margin(0.1));\n\t\tCHECK((a * 1 + b * 5 + c) == Approx(0.0).margin(0.1));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] auto SquaredDistance(const LineS& l)\t @return The squared distance between two lines\n\t @param l The other line\n\t @brief Compute the squared distance between two lines\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <math/LineT.hpp>\n#include <modeling/MakeEdge2d.hpp>\nusing AMCAX::Line2;\n#define ONE_RADIAN (M_PI / 180.)\n#include <catch.hpp>\n#include <testHelper.h>\n#include <math/LineT.hpp>\n#include <modeling/MakeEdge2d.hpp>\nusing AMCAX::Line2;\n#define ONE_RADIAN (M_PI / 180.)\n;\n\tSECTION(\"Distance and SquaredDistance test\")\n\t{\n\t\tauto pointToLine = [](const Point2& point, const Line2& line) {\n\t\t\tdouble a, b, c;\n\t\t\tline.Coefficients(a, b, c);\n\t\t\treturn std::fabs(a * point.X() + b * point.Y() + c);\n\t\t};\n\t\tauto lineToLine = [](const Line2& line1, const Line2& line2) {\n\t\t\tdouble a1, b1, c1, a2, b2, c2;\n\t\t\tline1.Coefficients(a1, b1, c1);\n\t\t\tline2.Coefficients(a2, b2, c2);\n\t\t\tif (a1 != a2 || b1 != b2) return 0.;\n\t\t\treturn std::fabs(c1 - c2);\n\t\t};\n\t\tLine2 line(3., 4., -30.);\n\t\tPoint2 point1(6., 3.);\n\t\tPoint2 point2(6., 2.);\n\t\tLine2 line2(3., 4., -29.);\n\t\tLine2 line3(2., 1., -99.);\n\t\tCHECK(line.Distance(point1) == Approx(pointToLine(point1, line)).margin(0.01));\n\t\tCHECK(line.SquaredDistance(point1) == Approx(pointToLine(point1, line) * pointToLine(point1, line)).margin(0.01));\n\t\tCHECK(line.Distance(point2) == Approx(pointToLine(point2, line)));\n\t\tCHECK(line.SquaredDistance(point2) == Approx(pointToLine(point2, line) * pointToLine(point2, line)).margin(0.01));\n\t\tCHECK(line.Distance(line2) == Approx(lineToLine(line, line2)));\n\t\tCHECK(line.SquaredDistance(line2) == Approx(lineToLine(line2, line) * lineToLine(line2, line)).margin(0.01));\n\t\tCHECK(line.Distance(line3) == Approx(lineToLine(line, line3)));\n\t\tCHECK(line.SquaredDistance(line3) == Approx(lineToLine(line3, line) * lineToLine(line3, line)).margin(0.01));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] auto SquaredDistance(const Point2& p)\t @return The squared distance between the point and the line\n\t @param p The point\n\t @brief Compute the squared distance from a point to the line\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <math/LineT.hpp>\n#include <modeling/MakeEdge2d.hpp>\nusing AMCAX::Line2;\n#define ONE_RADIAN (M_PI / 180.)\n#include <catch.hpp>\n#include <testHelper.h>\n#include <math/LineT.hpp>\n#include <modeling/MakeEdge2d.hpp>\nusing AMCAX::Line2;\n#define ONE_RADIAN (M_PI / 180.)\n;\n\tSECTION(\"Distance and SquaredDistance test\")\n\t{\n\t\tauto pointToLine = [](const Point2& point, const Line2& line) {\n\t\t\tdouble a, b, c;\n\t\t\tline.Coefficients(a, b, c);\n\t\t\treturn std::fabs(a * point.X() + b * point.Y() + c);\n\t\t};\n\t\tauto lineToLine = [](const Line2& line1, const Line2& line2) {\n\t\t\tdouble a1, b1, c1, a2, b2, c2;\n\t\t\tline1.Coefficients(a1, b1, c1);\n\t\t\tline2.Coefficients(a2, b2, c2);\n\t\t\tif (a1 != a2 || b1 != b2) return 0.;\n\t\t\treturn std::fabs(c1 - c2);\n\t\t};\n\t\tLine2 line(3., 4., -30.);\n\t\tPoint2 point1(6., 3.);\n\t\tPoint2 point2(6., 2.);\n\t\tLine2 line2(3., 4., -29.);\n\t\tLine2 line3(2., 1., -99.);\n\t\tCHECK(line.Distance(point1) == Approx(pointToLine(point1, line)).margin(0.01));\n\t\tCHECK(line.SquaredDistance(point1) == Approx(pointToLine(point1, line) * pointToLine(point1, line)).margin(0.01));\n\t\tCHECK(line.Distance(point2) == Approx(pointToLine(point2, line)));\n\t\tCHECK(line.SquaredDistance(point2) == Approx(pointToLine(point2, line) * pointToLine(point2, line)).margin(0.01));\n\t\tCHECK(line.Distance(line2) == Approx(lineToLine(line, line2)));\n\t\tCHECK(line.SquaredDistance(line2) == Approx(lineToLine(line2, line) * lineToLine(line2, line)).margin(0.01));\n\t\tCHECK(line.Distance(line3) == Approx(lineToLine(line, line3)));\n\t\tCHECK(line.SquaredDistance(line3) == Approx(lineToLine(line3, line) * lineToLine(line3, line)).margin(0.01));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] auto Distance(const Point2& p)\t @return The distance between the point and the line\n\t @param p The point\n\t @brief Compute the distance from a point to the line\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <math/LineT.hpp>\n#include <modeling/MakeEdge2d.hpp>\nusing AMCAX::Line2;\n#define ONE_RADIAN (M_PI / 180.)\n#include <catch.hpp>\n#include <testHelper.h>\n#include <math/LineT.hpp>\n#include <modeling/MakeEdge2d.hpp>\nusing AMCAX::Line2;\n#define ONE_RADIAN (M_PI / 180.)\n;\n\tSECTION(\"SetDirection\")\n\t{\n\t\tLine2 line(Point2(), Direction2(1., 1.));  \n\t\tCHECK(line.Direction().IsEqual(Direction2(1., 1.), 1e-5 * ONE_RADIAN));\n\t\tCHECK(line.Distance(Point2(1., 2.)) > 0.);\n\t\tline.SetDirection(Direction2(1., 2.));  \n\t\tCHECK(line.Direction().IsEqual(Direction2(1., 2.), 1e-5 * ONE_RADIAN));\n\t\tCHECK(line.Distance(Point2(1., 2.)) == Approx(0.).margin(1e-5));\n\t\tdouble a, b, c;\n\t\tline.Coefficients(a, b, c);\n\t\tCHECK(a == Approx(2. / std::sqrt(5)).margin(1e-5));\n\t\tCHECK(b == Approx(-1. / std::sqrt(5)).margin(1e-5));\n\t\tCHECK(c == Approx(0. / std::sqrt(5)).margin(1e-5));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "void Coefficients(double& a, double& b, double& c)\t @param[out] a,b,c The coefficients\n\t @brief The coefficients of the algebraic representation of the 2D line\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <math/LineT.hpp>\n#include <modeling/MakeEdge2d.hpp>\nusing AMCAX::Line2;\n#define ONE_RADIAN (M_PI / 180.)\n#include <catch.hpp>\n#include <testHelper.h>\n#include <math/LineT.hpp>\n#include <modeling/MakeEdge2d.hpp>\nusing AMCAX::Line2;\n#define ONE_RADIAN (M_PI / 180.)\n;\n\tSECTION(\"Parameterized constructor test\")\n\t{\n\t\tLine2 line1(Axis2(Point2(1., 0.), Direction2(2., 1.)));\n\t\tLine2 line2(Point2(1., 0.), Direction2(2., 1.));  \n\t\tLine2 line3(1, -2, -1);\n\t\tdouble a, b, c;\n\t\tline1.Coefficients(a, b, c);\n\t\tCHECK(a == Approx(1.0 / std::sqrt(5)));\n\t\tCHECK(b == Approx(-2.0 / std::sqrt(5)));\n\t\tCHECK(c == Approx(-1.0 / std::sqrt(5)));\n\t\tline2.Coefficients(a, b, c);\n\t\tCHECK(a == Approx(1.0 / std::sqrt(5)));\n\t\tCHECK(b == Approx(-2.0 / std::sqrt(5)));\n\t\tCHECK(c == Approx(-1.0 / std::sqrt(5)));\n\t\tline3.Coefficients(a, b, c);\n\t\tCHECK(a == Approx(1.0 / std::sqrt(5)));\n\t\tCHECK(b == Approx(-2.0 / std::sqrt(5)));\n\t\tCHECK(c == Approx(-1.0 / std::sqrt(5)));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "LineS(double a, double b, double c)\t @param a,b,c The coefficients\n\t @brief Construct from the algebraic coefficients of 2D line\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <math/LineT.hpp>\n#include <modeling/MakeEdge2d.hpp>\nusing AMCAX::Line2;\n#define ONE_RADIAN (M_PI / 180.)\n#include <catch.hpp>\n#include <testHelper.h>\n#include <math/LineT.hpp>\n#include <modeling/MakeEdge2d.hpp>\nusing AMCAX::Line2;\n#define ONE_RADIAN (M_PI / 180.)\n;\n\tSECTION(\"Normal Test\")\n\t{\n\t\tLine2 line(3., 4., 5.);  \n\t\tLine2 normalLine = line.Normal(Point2(1., 5.));\n\t\tdouble a, b, c;\n\t\tnormalLine.Coefficients(a, b, c);\n\t\tCHECK((a * 3 + b * 4) == Approx(0.0).margin(0.1));\n\t\tCHECK((a * 1 + b * 5 + c) == Approx(0.0).margin(0.1));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "Derived& Reverse()\t @return The reference to self\n\t @brief Reverse the line direction\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <math/LineT.hpp>\n#include <modeling/MakeEdge2d.hpp>\nusing AMCAX::Line2;\n#define ONE_RADIAN (M_PI / 180.)\n#include <catch.hpp>\n#include <testHelper.h>\n#include <math/LineT.hpp>\n#include <modeling/MakeEdge2d.hpp>\nusing AMCAX::Line2;\n#define ONE_RADIAN (M_PI / 180.)\n;\n\tSECTION(\"Reverse\")\n\t{\n\t\tLine2 line;\n\t\tline.Reverse();\n\t\tCHECK(line.Direction().IsEqual(Direction2(-1., 0.), 1e-5 * ONE_RADIAN));\n\t\tLine2 line2(Point2(), Direction2(-3., 98.));\n\t\tline2.Reverse();\n\t\tCHECK(line2.Direction().IsEqual(Direction2(3., -98.), 1e-5 * ONE_RADIAN));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] auto Angle(const LineBase& other)\t @return The angle between the line and the other line\n\t @param other The other line\n\t @brief Compute the angle between the line and the other line\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <math/LineT.hpp>\n#include <modeling/MakeEdge2d.hpp>\nusing AMCAX::Line2;\n#define ONE_RADIAN (M_PI / 180.)\n#include <catch.hpp>\n#include <testHelper.h>\n#include <math/LineT.hpp>\n#include <modeling/MakeEdge2d.hpp>\nusing AMCAX::Line2;\n#define ONE_RADIAN (M_PI / 180.)\n;\n\tSECTION(\"Angle\")\n\t{\n\t\tLine2 line;\n\t\tLine2 line2(Point2(), Direction2(0., 1.));\n\t\tCHECK(line.Angle(line2) == Approx(M_PI_2));\n\t\tCHECK(line2.Angle(line) == Approx(-M_PI_2));\n\t\tLine2 line3(Point2(), Direction2(2., 3.));\n\t\tLine2 line4(Point2(), Direction2(5., -8.));\n\t\tCHECK(line4.Angle(line3) == Approx(\n\t\t\tstd::acos((2. * 5. + 3. * (-8.)) / (std::sqrt(4. + 9.) * std::sqrt(25. + 64.)))\n\t\t).margin(1e-5 * ONE_RADIAN));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] const DirectionT<double, DIM>& Direction()\t @return The direction of the line\n\t @brief Get the direction of the line\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <math/LineT.hpp>\n#include <modeling/MakeEdge2d.hpp>\nusing AMCAX::Line2;\n#define ONE_RADIAN (M_PI / 180.)\n#include <catch.hpp>\n#include <testHelper.h>\n#include <math/LineT.hpp>\n#include <modeling/MakeEdge2d.hpp>\nusing AMCAX::Line2;\n#define ONE_RADIAN (M_PI / 180.)\n;\n\tSECTION(\"SetDirection\")\n\t{\n\t\tLine2 line(Point2(), Direction2(1., 1.));  \n\t\tCHECK(line.Direction().IsEqual(Direction2(1., 1.), 1e-5 * ONE_RADIAN));\n\t\tCHECK(line.Distance(Point2(1., 2.)) > 0.);\n\t\tline.SetDirection(Direction2(1., 2.));  \n\t\tCHECK(line.Direction().IsEqual(Direction2(1., 2.), 1e-5 * ONE_RADIAN));\n\t\tCHECK(line.Distance(Point2(1., 2.)) == Approx(0.).margin(1e-5));\n\t\tdouble a, b, c;\n\t\tline.Coefficients(a, b, c);\n\t\tCHECK(a == Approx(2. / std::sqrt(5)).margin(1e-5));\n\t\tCHECK(b == Approx(-1. / std::sqrt(5)).margin(1e-5));\n\t\tCHECK(c == Approx(0. / std::sqrt(5)).margin(1e-5));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "void SetPosition(const AxisT<double, DIM>& axis)\t @param axis The axis\n\t @brief Set the axis of the line\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <math/LineT.hpp>\n#include <modeling/MakeEdge2d.hpp>\nusing AMCAX::Line2;\n#define ONE_RADIAN (M_PI / 180.)\n#include <catch.hpp>\n#include <testHelper.h>\n#include <math/LineT.hpp>\n#include <modeling/MakeEdge2d.hpp>\nusing AMCAX::Line2;\n#define ONE_RADIAN (M_PI / 180.)\n;\n\tSECTION(\"SetPosition\")\n\t{\n\t\tLine2 line;\n\t\tCHECK(line.Location().IsEqual(Point2(0., 0.), 1e-5));\n\t\tCHECK(line.Direction().IsEqual(Direction2(1., 0.), 1e-5 * ONE_RADIAN));\n\t\tAxis2 axis(Point2(2., 1.), Direction2(1., 1.));\n\t\tline.SetPosition(axis);  \n\t\tdouble a, b, c;\n\t\tline.Coefficients(a, b, c);\n\t\tCHECK(a == Approx(1. / std::sqrt(2)).margin(1e-5));\n\t\tCHECK(b == Approx(-1. / std::sqrt(2)).margin(1e-5));\n\t\tCHECK(c == Approx(-1. / std::sqrt(2)).margin(1e-5));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "void SetDirection(const DirectionT<double, DIM>& dir)\t @param dir The line direction\n\t @brief Set the line direction\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <math/LineT.hpp>\n#include <modeling/MakeEdge2d.hpp>\nusing AMCAX::Line2;\n#define ONE_RADIAN (M_PI / 180.)\n#include <catch.hpp>\n#include <testHelper.h>\n#include <math/LineT.hpp>\n#include <modeling/MakeEdge2d.hpp>\nusing AMCAX::Line2;\n#define ONE_RADIAN (M_PI / 180.)\n;\n\tSECTION(\"SetDirection\")\n\t{\n\t\tLine2 line(Point2(), Direction2(1., 1.));  \n\t\tCHECK(line.Direction().IsEqual(Direction2(1., 1.), 1e-5 * ONE_RADIAN));\n\t\tCHECK(line.Distance(Point2(1., 2.)) > 0.);\n\t\tline.SetDirection(Direction2(1., 2.));  \n\t\tCHECK(line.Direction().IsEqual(Direction2(1., 2.), 1e-5 * ONE_RADIAN));\n\t\tCHECK(line.Distance(Point2(1., 2.)) == Approx(0.).margin(1e-5));\n\t\tdouble a, b, c;\n\t\tline.Coefficients(a, b, c);\n\t\tCHECK(a == Approx(2. / std::sqrt(5)).margin(1e-5));\n\t\tCHECK(b == Approx(-1. / std::sqrt(5)).margin(1e-5));\n\t\tCHECK(c == Approx(0. / std::sqrt(5)).margin(1e-5));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "void SetLocation(const PointT<double, DIM>& point)\t @param point The location point\n\t @brief Set the location of the line\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <math/LineT.hpp>\n#include <modeling/MakeEdge2d.hpp>\nusing AMCAX::Line2;\n#define ONE_RADIAN (M_PI / 180.)\n#include <catch.hpp>\n#include <testHelper.h>\n#include <math/LineT.hpp>\n#include <modeling/MakeEdge2d.hpp>\nusing AMCAX::Line2;\n#define ONE_RADIAN (M_PI / 180.)\n;\n\tSECTION(\"SetLocation\")\n\t{\n\t\tLine2 line(Point2(0., 0.), Direction2(1., 1.));  \n\t\tCHECK(line.Location().IsEqual(Point2(), 1e-5));\n\t\tline.SetLocation(Point2(2., 1.));  \n\t\tCHECK(line.Location().IsEqual(Point2(2., 1.), 1e-5));\n\t\tdouble a, b, c;\n\t\tline.Coefficients(a, b, c);\n\t\tCHECK(a == Approx(1. / std::sqrt(2)).margin(1e-5));\n\t\tCHECK(b == Approx(-1. / std::sqrt(2)).margin(1e-5));\n\t\tCHECK(c == Approx(-1. / std::sqrt(2)).margin(1e-5));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] Derived Translated(const PointT<double, DIM>& p1, const PointT<double, DIM>& p2)\t @return The translated line\n\t @param p2 The target point\n\t @param p1 The source point\n\t @brief Get the line translated by a vector from a point to another point\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <math/LineT.hpp>\n#include <modeling/MakeEdge2d.hpp>\nusing AMCAX::Line2;\n#define ONE_RADIAN (M_PI / 180.)\n#include <catch.hpp>\n#include <testHelper.h>\n#include <math/LineT.hpp>\n#include <modeling/MakeEdge2d.hpp>\nusing AMCAX::Line2;\n#define ONE_RADIAN (M_PI / 180.)\n;\n\tSECTION(\"Translate Test\")\n\t{\n\t\tLine2 line;\n\t\tline.Translate(Vector2(2., 0.));  \n\t\tCHECK(line.Direction().IsEqual(Direction2(), 1e-5 * ONE_RADIAN));\n\t\tCHECK(line.Contains(Point2(2., 0.), 1e-5));\n\t\tLine2 translateLine = line.Translated(Point2(2., 0.), Point2(-10., 0.));\n\t\tCHECK(translateLine.Contains(Point2(-10., 0.), 1e-5));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "Derived& Translate(const VectorT<double, DIM>& vec)\t @return The reference to self\n\t @param vec The translation vector\n\t @brief Translate the line by a vector\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <math/LineT.hpp>\n#include <modeling/MakeEdge2d.hpp>\nusing AMCAX::Line2;\n#define ONE_RADIAN (M_PI / 180.)\n#include <catch.hpp>\n#include <testHelper.h>\n#include <math/LineT.hpp>\n#include <modeling/MakeEdge2d.hpp>\nusing AMCAX::Line2;\n#define ONE_RADIAN (M_PI / 180.)\n;\n\tSECTION(\"Translate Test\")\n\t{\n\t\tLine2 line;\n\t\tline.Translate(Vector2(2., 0.));  \n\t\tCHECK(line.Direction().IsEqual(Direction2(), 1e-5 * ONE_RADIAN));\n\t\tCHECK(line.Contains(Point2(2., 0.), 1e-5));\n\t\tLine2 translateLine = line.Translated(Point2(2., 0.), Point2(-10., 0.));\n\t\tCHECK(translateLine.Contains(Point2(-10., 0.), 1e-5));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] Derived Scaled(const PointT<double, DIM>& point, double scale)\t @return The scaled line\n\t @param scale The scale value\n\t @param point The scaling center point\n\t @brief Get the line scaled by a point\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <math/LineT.hpp>\n#include <modeling/MakeEdge2d.hpp>\nusing AMCAX::Line2;\n#define ONE_RADIAN (M_PI / 180.)\n#include <catch.hpp>\n#include <testHelper.h>\n#include <math/LineT.hpp>\n#include <modeling/MakeEdge2d.hpp>\nusing AMCAX::Line2;\n#define ONE_RADIAN (M_PI / 180.)\n;\n\tSECTION(\"Scale\")\n\t{\n\t\tLine2 line(Point2(0., -1.), Direction2());\n\t\tPoint2 point;\n\t\tdouble distance = line.Distance(point);\n\t\tLine2 lineScale1 = line.Scaled(point, 1.1);\n\t\tCHECK(lineScale1.Distance(point) > distance);\n\t\tCHECK(lineScale1.Contains(Point2(0., -1.1), 1e-5));\n\t\tLine2 lineScale2 = line.Scaled(point, 1.);\n\t\tCHECK(lineScale2.Distance(point) == Approx(distance).margin(1e-5));\n\t\tCHECK(lineScale2.Contains(Point2(0., -1.), 1e-5));\n\t\tLine2 lineScale3 = line.Scaled(point, 0.8);\n\t\tCHECK(lineScale3.Distance(point) < distance);\n\t\tCHECK(lineScale3.Contains(Point2(0., -0.8), 1e-5));\n\t\tLine2 lineScale4 = line.Scaled(point, 0.);\n\t\tline.SetDirection(Direction2(-1.0, 4.0));\n\t\tLine2 lineScale5 = line.Scaled(Point2(-1., 2.), 0.);\n\t\tCHECK(lineScale4.Contains(Point2(0., 0.), 1e-5));\n\t\tCHECK(lineScale4.Direction().IsEqual(Direction2(), 1e-6 * ONE_RADIAN));\n\t\tCHECK(lineScale5.Contains(Point2(-1., 2.), 1e-5));\n\t\tCHECK(lineScale5.Direction().IsEqual(Direction2(-1., 4.), 1e-6 * ONE_RADIAN));\n\t\tLine2 lineScale6 = line.Scaled(point, -1.);\n\t\tCHECK(lineScale6.Direction().IsEqual(Direction2(1., -4.), 1e-5 * ONE_RADIAN));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] const PointT<double, DIM>& Location()\t @return The location of the line\n\t @brief Get the location point of the line\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <math/LineT.hpp>\n#include <modeling/MakeEdge2d.hpp>\nusing AMCAX::Line2;\n#define ONE_RADIAN (M_PI / 180.)\n#include <catch.hpp>\n#include <testHelper.h>\n#include <math/LineT.hpp>\n#include <modeling/MakeEdge2d.hpp>\nusing AMCAX::Line2;\n#define ONE_RADIAN (M_PI / 180.)\n;\n\tSECTION(\"SetPosition\")\n\t{\n\t\tLine2 line;\n\t\tCHECK(line.Location().IsEqual(Point2(0., 0.), 1e-5));\n\t\tCHECK(line.Direction().IsEqual(Direction2(1., 0.), 1e-5 * ONE_RADIAN));\n\t\tAxis2 axis(Point2(2., 1.), Direction2(1., 1.));\n\t\tline.SetPosition(axis);  \n\t\tdouble a, b, c;\n\t\tline.Coefficients(a, b, c);\n\t\tCHECK(a == Approx(1. / std::sqrt(2)).margin(1e-5));\n\t\tCHECK(b == Approx(-1. / std::sqrt(2)).margin(1e-5));\n\t\tCHECK(c == Approx(-1. / std::sqrt(2)).margin(1e-5));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] bool Contains(const PointT<double, DIM>& p, double tol)\t @return True if the point is on the line under the tolerance\n\t @param tol The tolerance\n\t @param p The point\n\t @brief Does the line contain a point under a distance tolerance\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <math/LineT.hpp>\n#include <modeling/MakeEdge2d.hpp>\nusing AMCAX::Line2;\n#define ONE_RADIAN (M_PI / 180.)\n#include <catch.hpp>\n#include <testHelper.h>\n#include <math/LineT.hpp>\n#include <modeling/MakeEdge2d.hpp>\nusing AMCAX::Line2;\n#define ONE_RADIAN (M_PI / 180.)\n;\n\tSECTION(\"Contains\")\n\t{\n\t\tLine2 line(Axis2(Point2(2., 1.), Direction2(1., 1.)));  \n\t\tPoint2 point1(2., 1.);  \n\t\tPoint2 point2(1., 1.);  \n\t\tCHECK(line.Contains(point1, 1e-5));\n\t\tCHECK_FALSE(line.Contains(point2, 1e-5));\n\t\tCHECK(line.Contains(point2, 1.));  \n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] double SemilatusRectum()\t @return The semilatus rectum\n\t          Semilatus rectum = 2 * focalLength\n\t @details The semilatus rectum of parabola is half of the length of the chord through a focus parallel to the directrix.\n\t @brief Get the semilatus rectum of the parabola\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <math/ParabolaT.hpp>\nusing namespace AMCAX;\nusing namespace std;\n#include <catch.hpp>\n#include <testHelper.h>\n#include <math/ParabolaT.hpp>\nusing namespace AMCAX;\nusing namespace std;\n;\n\tSECTION(\"SemilatusRectum\")\n\t{\n\t\tdouble SR = parabola.SemilatusRectum();\n\t\tdouble sr = 2 * focal;\n\t\tCHECK(SR == sr);\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] double FocalParameter()\t @return The focal parameter\n\t          Focal parameter = 2 * focalLength.\n\t @details The focal parameter of parabola is the distance from the focus to the directrix.\n\t @brief Get the focal parameter of the parabola\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <math/ParabolaT.hpp>\nusing namespace AMCAX;\nusing namespace std;\n#include <catch.hpp>\n#include <testHelper.h>\n#include <math/ParabolaT.hpp>\nusing namespace AMCAX;\nusing namespace std;\n;\n\tSECTION(\"FocalParameter\")\n\t{\n\t\tdouble FP = parabola.FocalParameter();\n\t\tdouble fp = 2 * focal;\n\t\tCHECK(FP == fp);\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] double SemilatusRectum()\t @return The semilatus rectum\n\t          Semilatus rectum = 2 * focalLength\n\t @details The semilatus rectum of parabola is half of the length of the chord through a focus parallel to the directrix.\n\t @brief Get the semilatus rectum of the parabola\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <math/ParabolaT.hpp>\nusing namespace AMCAX;\nusing namespace std;\n#include <catch.hpp>\n#include <testHelper.h>\n#include <math/ParabolaT.hpp>\nusing namespace AMCAX;\nusing namespace std;\n;\n\tSECTION(\"SemilatusRectum\")\n\t{\n\t\tdouble SR = parabola.SemilatusRectum();\n\t\tdouble sr = 2 * focal;\n\t\tCHECK(SR == sr);\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] double FocalParameter()\t @return The focal parameter\n\t          Focal parameter = 2 * focalLength.\n\t @details The focal parameter of parabola is the distance from the focus to the directrix.\n\t @brief Get the focal parameter of the parabola\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <math/ParabolaT.hpp>\nusing namespace AMCAX;\nusing namespace std;\n#include <catch.hpp>\n#include <testHelper.h>\n#include <math/ParabolaT.hpp>\nusing namespace AMCAX;\nusing namespace std;\n;\n\tSECTION(\"FocalParameter\")\n\t{\n\t\tdouble FP = parabola.FocalParameter();\n\t\tdouble fp = 2 * focal;\n\t\tCHECK(FP == fp);\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] double SemilatusRectum()\t @return The semilatus rectum\n\t          Semilatus rectum = 2 * focalLength\n\t @details The semilatus rectum of parabola is half of the length of the chord through a focus parallel to the directrix.\n\t @brief Get the semilatus rectum of the parabola\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <geometry/Geom3Parabola.hpp>\nusing namespace AMCAX;\nusing namespace std;\n#include <catch.hpp>\n#include <testHelper.h>\n#include <geometry/Geom3Parabola.hpp>\nusing namespace AMCAX;\nusing namespace std;\n;\n\tSECTION(\"SemilatusRectum\")\n\t{\n\t\tdouble SR = g3p.SemilatusRectum();\n\t\tdouble sr = 2 * focal;\n\t\tCHECK(SR == sr);\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] double SemilatusRectum()\t @return The semilatus rectum\n\t          Semilatus rectum = 2 * focalLength\n\t @details The semilatus rectum of parabola is half of the length of the chord through a focus parallel to the directrix.\n\t @brief Get the semilatus rectum of the parabola\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <geometry/Geom2Parabola.hpp>\nusing namespace AMCAX;\nusing namespace std;\n#include <catch.hpp>\n#include <testHelper.h>\n#include <geometry/Geom2Parabola.hpp>\nusing namespace AMCAX;\nusing namespace std;\n;\n\tSECTION(\"SemilatusRectum\")\n\t{\n\t\tdouble SR = g2p.SemilatusRectum();\n\t\tdouble sr = 2 * focal;\n\t\tCHECK(SR == sr);\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "EllipseS& Transform(const TransformationT<double, DIM>& tr)\t @return The reference to self\n\t @param tr The transformation\n\t @brief Transform the ellipse\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <common/FrameT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <math/EllipseT.hpp>\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"bug1:Ellipse3 bug \", \"[math][Ellipse3][bug]\")\n{\n\tFrame3 frame;\n\tdouble major = 4.0;\n\tdouble minor = 5.0;\n\tstring str1;\n\tstring str2 = \"[_DomainError]\";\n\ttry\n\t{\n\t\tEllipse3 ellipse(frame, major, minor);\n\t}\n\tcatch (exception& e)\n\t{\n\t\tstr1 = e.what();\n\t}\n\tCHECK(str1 == str2);\n;\n\tSECTION(\"Transform\")\n\t{\n\t\tEllipse3 Transfor_ellipse = ellipse.Transform(tr);\n\t\tCHECK(ellipse.Location().X() == Approx(5.0));\n\t\tCHECK(ellipse.Location().Y() == Approx(-2.0));\n\t\tCHECK(ellipse.Location().Z() == Approx(3.0));\n\t\tCHECK(ellipse.Axis().Direction().X() == Approx(0.0));\n\t\tCHECK(ellipse.Axis().Direction().Y() == Approx(0.0));\n\t\tCHECK(ellipse.Axis().Direction().Z() == Approx(1.0));\n\t\tCHECK(Transfor_ellipse.Location().X() == Approx(5.0));\n\t\tCHECK(Transfor_ellipse.Location().Y() == Approx(-2.0));\n\t\tCHECK(Transfor_ellipse.Location().Z() == Approx(3.0));\n\t\tCHECK(Transfor_ellipse.Axis().Direction().X() == Approx(0.0));\n\t\tCHECK(Transfor_ellipse.Axis().Direction().Y() == Approx(0.0));\n\t\tCHECK(Transfor_ellipse.Axis().Direction().Z() == Approx(1.0));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "EllipseS& Scale(const PointT<double, DIM>& point, double scale)\t @return The reference to self\n\t @param scale The scale value\n\t @param point The scaling center point\n\t @brief Scale the ellipse by a center point\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <common/FrameT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <math/EllipseT.hpp>\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"bug1:Ellipse3 bug \", \"[math][Ellipse3][bug]\")\n{\n\tFrame3 frame;\n\tdouble major = 4.0;\n\tdouble minor = 5.0;\n\tstring str1;\n\tstring str2 = \"[_DomainError]\";\n\ttry\n\t{\n\t\tEllipse3 ellipse(frame, major, minor);\n\t}\n\tcatch (exception& e)\n\t{\n\t\tstr1 = e.what();\n\t}\n\tCHECK(str1 == str2);\n;\n\tSECTION(\"Scale\")\n\t{\n\t\tEllipse3 scale_ellipse = ellipse.Scale(point, scale);\n\t\tCHECK(ellipse.Location().X() == Approx(6.0));\n\t\tCHECK(ellipse.Location().Y() == Approx(0.0));\n\t\tCHECK(ellipse.Location().Z() == Approx(6.0));\n\t\tCHECK(ellipse.MajorRadius() == Approx(2.5));\n\t\tCHECK(ellipse.MinorRadius() == Approx(2.0));\n\t\tCHECK(scale_ellipse.Location().X() == Approx(6.0));\n\t\tCHECK(scale_ellipse.Location().Y() == Approx(0.0));\n\t\tCHECK(scale_ellipse.Location().Z() == Approx(6.0));\n\t\tCHECK(scale_ellipse.MajorRadius() == Approx(2.5));\n\t\tCHECK(scale_ellipse.MinorRadius() == Approx(2.0));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] double Area()\t @return The area of the ellipse\n\t @brief Get the area of the ellipse\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <common/FrameT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <math/EllipseT.hpp>\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"bug1:Ellipse3 bug \", \"[math][Ellipse3][bug]\")\n{\n\tFrame3 frame;\n\tdouble major = 4.0;\n\tdouble minor = 5.0;\n\tstring str1;\n\tstring str2 = \"[_DomainError]\";\n\ttry\n\t{\n\t\tEllipse3 ellipse(frame, major, minor);\n\t}\n\tcatch (exception& e)\n\t{\n\t\tstr1 = e.what();\n\t}\n\tCHECK(str1 == str2);\n;\n\tSECTION(\"Area\")\n\t{\n\t\tdouble S = ellipse.Area();\n\t\tCHECK(S == Approx(M_PI * major * minor));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "EllipseS& Transform(const TransformationT<double, DIM>& tr)\t @return The reference to self\n\t @param tr The transformation\n\t @brief Transform the ellipse\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <common/FrameT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <math/EllipseT.hpp>\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"bug1:Ellipse2 bug \", \"[math][Ellipse2][bug]\")\n{\n\tAxis2 axis;\n\tdouble major = 4.0;\n\tdouble minor = 5.0;\n\tbool isRight = true;\n\tstring str1;\n\tstring str2 = \"[_DomainError]\";\n\ttry\n\t{\n\t\tEllipse2 ellipse(axis, major, minor, isRight);\n\t}\n\tcatch (exception& e)\n\t{\n\t\tstr1 = e.what();\n\t}\n\tCHECK(str1 == str2);\n;\n\tSECTION(\"Transform\")\n\t{\n\t\tEllipse2 Transfor_ellipse = ellipse.Transform(tr);\n\t\tCHECK(ellipse.Location().X() == Approx(5.0));\n\t\tCHECK(ellipse.Location().Y() == Approx(-2.0));\n\t\tCHECK(ellipse.MajorRadius() == Approx(5.0));\n\t\tCHECK(ellipse.MinorRadius() == Approx(4.0));\n\t\tCHECK(Transfor_ellipse.Location().X() == Approx(5.0));\n\t\tCHECK(Transfor_ellipse.Location().Y() == Approx(-2.0));\n\t\tCHECK(Transfor_ellipse.MajorRadius() == Approx(5.0));\n\t\tCHECK(Transfor_ellipse.MinorRadius() == Approx(4.0));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "EllipseS& Scale(const PointT<double, DIM>& point, double scale)\t @return The reference to self\n\t @param scale The scale value\n\t @param point The scaling center point\n\t @brief Scale the ellipse by a center point\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <common/FrameT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <math/EllipseT.hpp>\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"bug1:Ellipse2 bug \", \"[math][Ellipse2][bug]\")\n{\n\tAxis2 axis;\n\tdouble major = 4.0;\n\tdouble minor = 5.0;\n\tbool isRight = true;\n\tstring str1;\n\tstring str2 = \"[_DomainError]\";\n\ttry\n\t{\n\t\tEllipse2 ellipse(axis, major, minor, isRight);\n\t}\n\tcatch (exception& e)\n\t{\n\t\tstr1 = e.what();\n\t}\n\tCHECK(str1 == str2);\n;\n\tSECTION(\"Scale\")\n\t{\n\t\tEllipse2 scale_ellipse = ellipse.Scale(point, scale);\n\t\tCHECK(ellipse.Location().X() == Approx(2.5));\n\t\tCHECK(ellipse.Location().Y() == Approx(-1.0));\n\t\tCHECK(ellipse.MajorRadius() == Approx(2.5));\n\t\tCHECK(ellipse.MinorRadius() == Approx(2.0));\n\t\tCHECK(scale_ellipse.Location().X() == Approx(2.5));\n\t\tCHECK(scale_ellipse.Location().Y() == Approx(-1.0));\n\t\tCHECK(scale_ellipse.MajorRadius() == Approx(2.5));\n\t\tCHECK(scale_ellipse.MinorRadius() == Approx(2.0));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] double Area()\t @return The area of the ellipse\n\t @brief Get the area of the ellipse\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <common/FrameT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <math/EllipseT.hpp>\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"bug1:Ellipse2 bug \", \"[math][Ellipse2][bug]\")\n{\n\tAxis2 axis;\n\tdouble major = 4.0;\n\tdouble minor = 5.0;\n\tbool isRight = true;\n\tstring str1;\n\tstring str2 = \"[_DomainError]\";\n\ttry\n\t{\n\t\tEllipse2 ellipse(axis, major, minor, isRight);\n\t}\n\tcatch (exception& e)\n\t{\n\t\tstr1 = e.what();\n\t}\n\tCHECK(str1 == str2);\n;\n\tSECTION(\"Area\")\n\t{\n\t\tdouble S = ellipse.Area();\n\t\tCHECK(S == Approx(M_PI * major * minor));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "CircleS& Scale(const PointT<double, DIM>& p, double scale)\t @return The reference to self\n\t @param scale The scale value\n\t @param p The scaling center point\n\t @brief Scale the circle by a center point\n,\n",
      "output": "#include <math/CircleT.hpp>\n#include <common/CoordT.hpp>\n#include <common/TransformationType.hpp>\n#include <common/DirectionT.hpp>\n#include <common/PointT.hpp>\n#include <common/Precision.hpp>\n#include <common/CoordT.hpp>\n#include <common/TransformationType.hpp>\n#include <topology/TopoEdge.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <topology/TopoWire.hpp>\n#include <modeling/MakeWire.hpp>\n#include <geometry/GlobalProperty.hpp>\n#include <topology/BRepGlobalProperty.hpp>\n#include<iostream>\n#include \"catch.hpp\" \nusing namespace std;\nusing namespace AMCAX;\nTEST_CASE(\"TestCircle2D\", \"[math][Circle2D]\")\n{\n\tAMCAX::CircleT<double, 2> circle2D;\n\tAMCAX::Point2 center2D(0.0, 0.0);\n\tdouble redius2D = 5.0;\n\tdouble tol = 0.1;\n\tcircle2D.SetLocation(center2D);\n\tcircle2D.SetRadius(redius2D);\n\tdouble area2D = circle2D.Area();\n\tdouble length2D = circle2D.Length();\n\tAMCAX::Point2 retcenter2D = circle2D.Location();\n\tdouble retarea2D = M_PI * redius2D * redius2D;\n\tdouble retlength2D = 2 * M_PI * redius2D;\n\tstd::cout << area2D << std::endl;\n\tstd::cout << length2D << std::endl;\n\tstd::cout << retcenter2D.X() << std::endl;\n\tstd::cout << retcenter2D.Y() << std::endl;\n\tCHECK(area2D == retarea2D);\n\tCHECK(length2D == retlength2D);\n\tCHECK(retcenter2D.X() == center2D.X());\n\tCHECK(retcenter2D.Y() == center2D.Y());\n\tdouble a, b, c, d, e, f;\n\tcircle2D.Coefficients(a, b, c, d, e, f);\n\tstd::cout << a << std::endl;\n\tstd::cout << b << std::endl;\n\tstd::cout << c << std::endl;\n\tstd::cout << d << std::endl;\n\tstd::cout << e << std::endl;\n\tstd::cout << f << std::endl;\n\tCHECK(a == 1);\n\tCHECK(b == 1);\n\tCHECK(c == 0);\n\tCHECK(d == 0);\n\tCHECK(e == 0);\n\tCHECK(f == -25);\n\tstd::vector < AMCAX::Point2> testPoints = {\n\t\tAMCAX::Point2(3.0, 4.0),\n\t\tAMCAX::Point2(5.0, 0.0),\n\t\tAMCAX::Point2(4.9, 0.0),\n\t\tAMCAX::Point2(5.1, 0.0),\n\t\tAMCAX::Point2(6.0, 0.0)\n\t};\n\tfor (const auto& point : testPoints)\n\t{\n\t\tdouble distanceToCenter = std::sqrt(point.X() * point.X() + point.Y() * point.Y());\n\t\tbool expectedIsInCircle = distanceToCenter <= 5.0 + tol;\n\t\tbool isInCircle = circle2D.Contains(point, tol);\n\t\tCHECK(isInCircle == expectedIsInCircle);\n\t}\n\tfor (const auto& point : testPoints)\n\t{\n\t\tdouble distance = circle2D.Distance(point);\n\t\tdouble expectedDistance = std::abs(std::sqrt(std::pow(point.X() - center2D.X(), 2) + std::pow(point.Y() - center2D.Y(), 2)) - redius2D);\n\t\tCHECK(distance == expectedDistance);\n\t}\n\tAMCAX::AxisT<double, 2> mirrorAxis(AMCAX::Point2(0.0, 0.0), AMCAX::Direction2(0.0, 1.0));\n\tcircle2D.Mirror(mirrorAxis);\n\tAMCAX::Point2 mirroredCenter = circle2D.Location();\n\tstd::cout << \"Mirrored circle center: (\" << mirroredCenter.X() << \", \" << mirroredCenter.Y() << \")\" << std::endl;\n\tCHECK(mirroredCenter.X() == center2D.X());\n\tCHECK(mirroredCenter.Y() == center2D.Y());\n\tconst AMCAX::FrameT<double, 2>& frame = circle2D.Position();\n\tAMCAX::Point2 rotationPoint(0.0, 0.0);\n\tdouble  rotationAngle = M_PI / 4;\n\tauto rotatedCircle = circle2D.Rotated(rotationPoint, rotationAngle);\n\tdouble cosAngle = cos(rotationAngle);\n\tdouble sinAngle = sin(rotationAngle);\n\tdouble newX = cosAngle * (center2D.X() - rotationPoint.X()) - sinAngle * (center2D.Y() - rotationPoint.Y()) + rotationPoint.X();\n\tdouble newY = sinAngle * (center2D.X() - rotationPoint.X()) + cosAngle * (center2D.Y() - rotationPoint.Y()) + rotationPoint.Y();\n\tauto rotatedCenter = rotatedCircle.Location();\n\tCHECK(newX == center2D.X());\n\tCHECK(newY == center2D.Y());\n\tAMCAX::Point2 scalingCenter(0.0, 0.0);\n\tdouble scalingFactor = 2.0;\n\tauto scaledCircle = circle2D.Scale(scalingCenter, scalingFactor);\n\tdouble scaledRadius = scaledCircle.Radius();\n\tdouble expectedScaledRadius = redius2D * scalingFactor;\n\tCHECK(std::abs(scaledRadius - expectedScaledRadius) < 1e-6);\n\tAMCAX::VectorT<double, 2> translationVector(2.0, 3.0);\n\tauto translatedCircle = circle2D.Translated(translationVector);\n\tauto translatedCenter = translatedCircle.Location();\n\tdouble translatedX = center2D.X() + translationVector.X();\n\tCHECK(translatedX == translatedCenter.X());\n\tauto xAxis = circle2D.XAxis();\n\tauto directionAxis = xAxis.Direction();\n\tCHECK(directionAxis.X() == -1.0);\n\tCHECK(directionAxis.Y() == 0.0);\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] double SquaredDistance(const PointT<double, DIM>& p)\t @return The squared distance from the point to the circle\n\t @param p The point\n\t @brief Compute the squared distance from a point to the circle\n,\n",
      "output": "#include <math/CircleT.hpp>\n#include <common/CoordT.hpp>\n#include <common/TransformationType.hpp>\n#include <common/DirectionT.hpp>\n#include <common/PointT.hpp>\n#include <common/Precision.hpp>\n#include <common/CoordT.hpp>\n#include <common/TransformationType.hpp>\n#include <topology/TopoEdge.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <topology/TopoWire.hpp>\n#include <modeling/MakeWire.hpp>\n#include <geometry/GlobalProperty.hpp>\n#include <topology/BRepGlobalProperty.hpp>\n#include<iostream>\n#include \"catch.hpp\" \nusing namespace std;\nusing namespace AMCAX;\nTEST_CASE(\"TestCircle3D\", \"[math][Circle3D]\")\n{\n\tAMCAX::Circle3 circle3D;\n\tAMCAX::Point3  center3D(0.0, 0.0, 0.0);\n\tdouble radius3D = 5.0;\n\tdouble tol = 0.1;\n\tcircle3D.SetLocation(center3D);\n\tcircle3D.SetRadius(radius3D);\n\tdouble area = circle3D.Area();\n\tauto axis = circle3D.Axis();\n\tAMCAX::Point3 expectedDirection(0.0, 0.0, 1.0);\n\tauto direction = axis.Direction();\n\tCHECK(area == Approx(78.5398));\n\tCHECK(direction.X() == Approx(expectedDirection.X()).margin(tol));\n\tCHECK(direction.Y() == Approx(expectedDirection.Y()).margin(tol));\n\tCHECK(direction.Z() == Approx(expectedDirection.Z()).margin(tol));\n\tstd::vector <AMCAX::Point3> test3DPoints = {\n\t\tAMCAX::Point3(0.0, 0.0, 0.0),\n\t\tAMCAX::Point3(4.0, 0.0, 0.0),\n\t};\n\tfor (const auto& point : test3DPoints)\n\t{\n\t\tdouble distanceToCenter = std::sqrt(std::pow(point.X() - center3D.X(), 2) + std::pow(point.Y() - center3D.Y(), 2) + std::pow(point.Z() - center3D.Z(), 2));\n\t\tbool expectedIsCircle = distanceToCenter <= 5.0 + tol;\n\t\tbool isInCircle = circle3D.Contains(point, tol);\n\t\tCHECK(!isInCircle == expectedIsCircle);\n\t}\n\tAMCAX::PointT<double, 3>  pointOutside(10.0, 0.0, 0.0);\n\tdouble expectedDistance = 5.0;\n\tCHECK(circle3D.Distance(pointOutside) == Approx(expectedDistance));\n\tdouble length = circle3D.Length();\n\tCHECK(length == Approx(31.4159));\n\tauto location = circle3D.Location();\n\tCHECK(location.X() == Approx(0.0));\n\tCHECK(location.Y() == Approx(0.0));\n\tCHECK(location.Z() == Approx(0.0));\n\tAMCAX::PointT<double, 3> mirrorPoint(1.0, 0.0, 0.0);\n\tcircle3D.Mirror(mirrorPoint);\n\tauto mirroredLocation = circle3D.Location();\n\tCHECK(mirroredLocation.X() == Approx(2.0));\n\tCHECK(mirroredLocation.Y() == Approx(0.0));\n\tCHECK(mirroredLocation.Z() == Approx(0.0));\n\tauto position = circle3D.Position();   \n\tdouble r = circle3D.Radius();\n\tCHECK(r == 5.0);\n\tDirection3 zDirection(0.0, 0.0, 1.0);\n\tAxis3 zAxis(center3D, zDirection);\n\tTransformation3 rotation;\n\trotation.SetRotation(zAxis, M_PI / 2);  \n\tPoint3 newCenter1 = center3D.Transformed(rotation);\n\tCHECK(newCenter1.X() == 0.0);\n\tCHECK(newCenter1.Y() == 0.0);\n\tCHECK(newCenter1.Z() == 0.0);\n\tdouble angle = M_PI / 2;\n\tcircle3D.Rotated(zAxis, angle);\n\tAMCAX::Frame3 frame = circle3D.Position();\n\tCHECK(frame.Location().X() == 2.0);\n\tCHECK(frame.Location().Y() == 0.0);\n\tCHECK(frame.Location().Z() == 0.0);\n\tdouble scale = 2.0;\n\tcircle3D.Scale(center3D, scale);\n\tCHECK(circle3D.Radius() == radius3D * 2.0);\n\tAMCAX::PointT<double, 3> insidePoint(3.0, 4.0, 0.0);\n\tAMCAX::PointT<double, 3> onCirclePoint(5.0, 0.0, 0.0);\n\tAMCAX::PointT<double, 3> outsidePoint(8.0, 6.0, 0.0);\n\tdouble insideSquaredDistance = circle3D.SquaredDistance(insidePoint);\n\tdouble onCircleSquaredDistance = circle3D.SquaredDistance(onCirclePoint);\n\tdouble outsideSquaredDistance = circle3D.SquaredDistance(outsidePoint);\n\tCHECK(insideSquaredDistance == Approx(34.5378));\n\tCHECK(onCircleSquaredDistance == 81.0);\n\tCHECK(outsideSquaredDistance == Approx(7.7779));\n\tVectorT<double, 3> translationVector(5.0, 5.0, 0.0);\n\tcircle3D.Translate(translationVector);\n\tCHECK(circle3D.Location().X() == 9.0);\n\tCHECK(circle3D.Location().Y() == 5.0);\n\tCHECK(circle3D.Location().Z() == 0.0);\n\tauto xAxis = circle3D.XAxis();\n\tauto yAxis = circle3D.YAxis();\n\tCHECK(xAxis.Direction().X() == Approx(-1.0));\n\tCHECK(yAxis.Direction().Y() == Approx(-1.0));\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] double Distance(const PointT<double, DIM>& p)\t @return The distance from the point to the circle\n\t @param p The point\n\t @brief Compute the distance from a point to the circle\n,\n",
      "output": "#include <math/CircleT.hpp>\n#include <common/CoordT.hpp>\n#include <common/TransformationType.hpp>\n#include <common/DirectionT.hpp>\n#include <common/PointT.hpp>\n#include <common/Precision.hpp>\n#include <common/CoordT.hpp>\n#include <common/TransformationType.hpp>\n#include <topology/TopoEdge.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <topology/TopoWire.hpp>\n#include <modeling/MakeWire.hpp>\n#include <geometry/GlobalProperty.hpp>\n#include <topology/BRepGlobalProperty.hpp>\n#include<iostream>\n#include \"catch.hpp\" \nusing namespace std;\nusing namespace AMCAX;\nTEST_CASE(\"TestCircle3D\", \"[math][Circle3D]\")\n{\n\tAMCAX::Circle3 circle3D;\n\tAMCAX::Point3  center3D(0.0, 0.0, 0.0);\n\tdouble radius3D = 5.0;\n\tdouble tol = 0.1;\n\tcircle3D.SetLocation(center3D);\n\tcircle3D.SetRadius(radius3D);\n\tdouble area = circle3D.Area();\n\tauto axis = circle3D.Axis();\n\tAMCAX::Point3 expectedDirection(0.0, 0.0, 1.0);\n\tauto direction = axis.Direction();\n\tCHECK(area == Approx(78.5398));\n\tCHECK(direction.X() == Approx(expectedDirection.X()).margin(tol));\n\tCHECK(direction.Y() == Approx(expectedDirection.Y()).margin(tol));\n\tCHECK(direction.Z() == Approx(expectedDirection.Z()).margin(tol));\n\tstd::vector <AMCAX::Point3> test3DPoints = {\n\t\tAMCAX::Point3(0.0, 0.0, 0.0),\n\t\tAMCAX::Point3(4.0, 0.0, 0.0),\n\t};\n\tfor (const auto& point : test3DPoints)\n\t{\n\t\tdouble distanceToCenter = std::sqrt(std::pow(point.X() - center3D.X(), 2) + std::pow(point.Y() - center3D.Y(), 2) + std::pow(point.Z() - center3D.Z(), 2));\n\t\tbool expectedIsCircle = distanceToCenter <= 5.0 + tol;\n\t\tbool isInCircle = circle3D.Contains(point, tol);\n\t\tCHECK(!isInCircle == expectedIsCircle);\n\t}\n\tAMCAX::PointT<double, 3>  pointOutside(10.0, 0.0, 0.0);\n\tdouble expectedDistance = 5.0;\n\tCHECK(circle3D.Distance(pointOutside) == Approx(expectedDistance));\n\tdouble length = circle3D.Length();\n\tCHECK(length == Approx(31.4159));\n\tauto location = circle3D.Location();\n\tCHECK(location.X() == Approx(0.0));\n\tCHECK(location.Y() == Approx(0.0));\n\tCHECK(location.Z() == Approx(0.0));\n\tAMCAX::PointT<double, 3> mirrorPoint(1.0, 0.0, 0.0);\n\tcircle3D.Mirror(mirrorPoint);\n\tauto mirroredLocation = circle3D.Location();\n\tCHECK(mirroredLocation.X() == Approx(2.0));\n\tCHECK(mirroredLocation.Y() == Approx(0.0));\n\tCHECK(mirroredLocation.Z() == Approx(0.0));\n\tauto position = circle3D.Position();   \n\tdouble r = circle3D.Radius();\n\tCHECK(r == 5.0);\n\tDirection3 zDirection(0.0, 0.0, 1.0);\n\tAxis3 zAxis(center3D, zDirection);\n\tTransformation3 rotation;\n\trotation.SetRotation(zAxis, M_PI / 2);  \n\tPoint3 newCenter1 = center3D.Transformed(rotation);\n\tCHECK(newCenter1.X() == 0.0);\n\tCHECK(newCenter1.Y() == 0.0);\n\tCHECK(newCenter1.Z() == 0.0);\n\tdouble angle = M_PI / 2;\n\tcircle3D.Rotated(zAxis, angle);\n\tAMCAX::Frame3 frame = circle3D.Position();\n\tCHECK(frame.Location().X() == 2.0);\n\tCHECK(frame.Location().Y() == 0.0);\n\tCHECK(frame.Location().Z() == 0.0);\n\tdouble scale = 2.0;\n\tcircle3D.Scale(center3D, scale);\n\tCHECK(circle3D.Radius() == radius3D * 2.0);\n\tAMCAX::PointT<double, 3> insidePoint(3.0, 4.0, 0.0);\n\tAMCAX::PointT<double, 3> onCirclePoint(5.0, 0.0, 0.0);\n\tAMCAX::PointT<double, 3> outsidePoint(8.0, 6.0, 0.0);\n\tdouble insideSquaredDistance = circle3D.SquaredDistance(insidePoint);\n\tdouble onCircleSquaredDistance = circle3D.SquaredDistance(onCirclePoint);\n\tdouble outsideSquaredDistance = circle3D.SquaredDistance(outsidePoint);\n\tCHECK(insideSquaredDistance == Approx(34.5378));\n\tCHECK(onCircleSquaredDistance == 81.0);\n\tCHECK(outsideSquaredDistance == Approx(7.7779));\n\tVectorT<double, 3> translationVector(5.0, 5.0, 0.0);\n\tcircle3D.Translate(translationVector);\n\tCHECK(circle3D.Location().X() == 9.0);\n\tCHECK(circle3D.Location().Y() == 5.0);\n\tCHECK(circle3D.Location().Z() == 0.0);\n\tauto xAxis = circle3D.XAxis();\n\tauto yAxis = circle3D.YAxis();\n\tCHECK(xAxis.Direction().X() == Approx(-1.0));\n\tCHECK(yAxis.Direction().Y() == Approx(-1.0));\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] double Length()\t @return The length of the circle\n\t @brief Get the length of the circle\n,\n",
      "output": "#include <math/CircleT.hpp>\n#include <common/CoordT.hpp>\n#include <common/TransformationType.hpp>\n#include <common/DirectionT.hpp>\n#include <common/PointT.hpp>\n#include <common/Precision.hpp>\n#include <common/CoordT.hpp>\n#include <common/TransformationType.hpp>\n#include <topology/TopoEdge.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <topology/TopoWire.hpp>\n#include <modeling/MakeWire.hpp>\n#include <geometry/GlobalProperty.hpp>\n#include <topology/BRepGlobalProperty.hpp>\n#include<iostream>\n#include \"catch.hpp\" \nusing namespace std;\nusing namespace AMCAX;\nTEST_CASE(\"TestCircle2D\", \"[math][Circle2D]\")\n{\n\tAMCAX::CircleT<double, 2> circle2D;\n\tAMCAX::Point2 center2D(0.0, 0.0);\n\tdouble redius2D = 5.0;\n\tdouble tol = 0.1;\n\tcircle2D.SetLocation(center2D);\n\tcircle2D.SetRadius(redius2D);\n\tdouble area2D = circle2D.Area();\n\tdouble length2D = circle2D.Length();\n\tAMCAX::Point2 retcenter2D = circle2D.Location();\n\tdouble retarea2D = M_PI * redius2D * redius2D;\n\tdouble retlength2D = 2 * M_PI * redius2D;\n\tstd::cout << area2D << std::endl;\n\tstd::cout << length2D << std::endl;\n\tstd::cout << retcenter2D.X() << std::endl;\n\tstd::cout << retcenter2D.Y() << std::endl;\n\tCHECK(area2D == retarea2D);\n\tCHECK(length2D == retlength2D);\n\tCHECK(retcenter2D.X() == center2D.X());\n\tCHECK(retcenter2D.Y() == center2D.Y());\n\tdouble a, b, c, d, e, f;\n\tcircle2D.Coefficients(a, b, c, d, e, f);\n\tstd::cout << a << std::endl;\n\tstd::cout << b << std::endl;\n\tstd::cout << c << std::endl;\n\tstd::cout << d << std::endl;\n\tstd::cout << e << std::endl;\n\tstd::cout << f << std::endl;\n\tCHECK(a == 1);\n\tCHECK(b == 1);\n\tCHECK(c == 0);\n\tCHECK(d == 0);\n\tCHECK(e == 0);\n\tCHECK(f == -25);\n\tstd::vector < AMCAX::Point2> testPoints = {\n\t\tAMCAX::Point2(3.0, 4.0),\n\t\tAMCAX::Point2(5.0, 0.0),\n\t\tAMCAX::Point2(4.9, 0.0),\n\t\tAMCAX::Point2(5.1, 0.0),\n\t\tAMCAX::Point2(6.0, 0.0)\n\t};\n\tfor (const auto& point : testPoints)\n\t{\n\t\tdouble distanceToCenter = std::sqrt(point.X() * point.X() + point.Y() * point.Y());\n\t\tbool expectedIsInCircle = distanceToCenter <= 5.0 + tol;\n\t\tbool isInCircle = circle2D.Contains(point, tol);\n\t\tCHECK(isInCircle == expectedIsInCircle);\n\t}\n\tfor (const auto& point : testPoints)\n\t{\n\t\tdouble distance = circle2D.Distance(point);\n\t\tdouble expectedDistance = std::abs(std::sqrt(std::pow(point.X() - center2D.X(), 2) + std::pow(point.Y() - center2D.Y(), 2)) - redius2D);\n\t\tCHECK(distance == expectedDistance);\n\t}\n\tAMCAX::AxisT<double, 2> mirrorAxis(AMCAX::Point2(0.0, 0.0), AMCAX::Direction2(0.0, 1.0));\n\tcircle2D.Mirror(mirrorAxis);\n\tAMCAX::Point2 mirroredCenter = circle2D.Location();\n\tstd::cout << \"Mirrored circle center: (\" << mirroredCenter.X() << \", \" << mirroredCenter.Y() << \")\" << std::endl;\n\tCHECK(mirroredCenter.X() == center2D.X());\n\tCHECK(mirroredCenter.Y() == center2D.Y());\n\tconst AMCAX::FrameT<double, 2>& frame = circle2D.Position();\n\tAMCAX::Point2 rotationPoint(0.0, 0.0);\n\tdouble  rotationAngle = M_PI / 4;\n\tauto rotatedCircle = circle2D.Rotated(rotationPoint, rotationAngle);\n\tdouble cosAngle = cos(rotationAngle);\n\tdouble sinAngle = sin(rotationAngle);\n\tdouble newX = cosAngle * (center2D.X() - rotationPoint.X()) - sinAngle * (center2D.Y() - rotationPoint.Y()) + rotationPoint.X();\n\tdouble newY = sinAngle * (center2D.X() - rotationPoint.X()) + cosAngle * (center2D.Y() - rotationPoint.Y()) + rotationPoint.Y();\n\tauto rotatedCenter = rotatedCircle.Location();\n\tCHECK(newX == center2D.X());\n\tCHECK(newY == center2D.Y());\n\tAMCAX::Point2 scalingCenter(0.0, 0.0);\n\tdouble scalingFactor = 2.0;\n\tauto scaledCircle = circle2D.Scale(scalingCenter, scalingFactor);\n\tdouble scaledRadius = scaledCircle.Radius();\n\tdouble expectedScaledRadius = redius2D * scalingFactor;\n\tCHECK(std::abs(scaledRadius - expectedScaledRadius) < 1e-6);\n\tAMCAX::VectorT<double, 2> translationVector(2.0, 3.0);\n\tauto translatedCircle = circle2D.Translated(translationVector);\n\tauto translatedCenter = translatedCircle.Location();\n\tdouble translatedX = center2D.X() + translationVector.X();\n\tCHECK(translatedX == translatedCenter.X());\n\tauto xAxis = circle2D.XAxis();\n\tauto directionAxis = xAxis.Direction();\n\tCHECK(directionAxis.X() == -1.0);\n\tCHECK(directionAxis.Y() == 0.0);\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] double Radius()\t @return The radius\n\t @brief Get the radius\n,\n",
      "output": "#include <math/CircleT.hpp>\n#include <common/CoordT.hpp>\n#include <common/TransformationType.hpp>\n#include <common/DirectionT.hpp>\n#include <common/PointT.hpp>\n#include <common/Precision.hpp>\n#include <common/CoordT.hpp>\n#include <common/TransformationType.hpp>\n#include <topology/TopoEdge.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <topology/TopoWire.hpp>\n#include <modeling/MakeWire.hpp>\n#include <geometry/GlobalProperty.hpp>\n#include <topology/BRepGlobalProperty.hpp>\n#include<iostream>\n#include \"catch.hpp\" \nusing namespace std;\nusing namespace AMCAX;\nTEST_CASE(\"TestCircle3D\", \"[math][Circle3D]\")\n{\n\tAMCAX::Circle3 circle3D;\n\tAMCAX::Point3  center3D(0.0, 0.0, 0.0);\n\tdouble radius3D = 5.0;\n\tdouble tol = 0.1;\n\tcircle3D.SetLocation(center3D);\n\tcircle3D.SetRadius(radius3D);\n\tdouble area = circle3D.Area();\n\tauto axis = circle3D.Axis();\n\tAMCAX::Point3 expectedDirection(0.0, 0.0, 1.0);\n\tauto direction = axis.Direction();\n\tCHECK(area == Approx(78.5398));\n\tCHECK(direction.X() == Approx(expectedDirection.X()).margin(tol));\n\tCHECK(direction.Y() == Approx(expectedDirection.Y()).margin(tol));\n\tCHECK(direction.Z() == Approx(expectedDirection.Z()).margin(tol));\n\tstd::vector <AMCAX::Point3> test3DPoints = {\n\t\tAMCAX::Point3(0.0, 0.0, 0.0),\n\t\tAMCAX::Point3(4.0, 0.0, 0.0),\n\t};\n\tfor (const auto& point : test3DPoints)\n\t{\n\t\tdouble distanceToCenter = std::sqrt(std::pow(point.X() - center3D.X(), 2) + std::pow(point.Y() - center3D.Y(), 2) + std::pow(point.Z() - center3D.Z(), 2));\n\t\tbool expectedIsCircle = distanceToCenter <= 5.0 + tol;\n\t\tbool isInCircle = circle3D.Contains(point, tol);\n\t\tCHECK(!isInCircle == expectedIsCircle);\n\t}\n\tAMCAX::PointT<double, 3>  pointOutside(10.0, 0.0, 0.0);\n\tdouble expectedDistance = 5.0;\n\tCHECK(circle3D.Distance(pointOutside) == Approx(expectedDistance));\n\tdouble length = circle3D.Length();\n\tCHECK(length == Approx(31.4159));\n\tauto location = circle3D.Location();\n\tCHECK(location.X() == Approx(0.0));\n\tCHECK(location.Y() == Approx(0.0));\n\tCHECK(location.Z() == Approx(0.0));\n\tAMCAX::PointT<double, 3> mirrorPoint(1.0, 0.0, 0.0);\n\tcircle3D.Mirror(mirrorPoint);\n\tauto mirroredLocation = circle3D.Location();\n\tCHECK(mirroredLocation.X() == Approx(2.0));\n\tCHECK(mirroredLocation.Y() == Approx(0.0));\n\tCHECK(mirroredLocation.Z() == Approx(0.0));\n\tauto position = circle3D.Position();   \n\tdouble r = circle3D.Radius();\n\tCHECK(r == 5.0);\n\tDirection3 zDirection(0.0, 0.0, 1.0);\n\tAxis3 zAxis(center3D, zDirection);\n\tTransformation3 rotation;\n\trotation.SetRotation(zAxis, M_PI / 2);  \n\tPoint3 newCenter1 = center3D.Transformed(rotation);\n\tCHECK(newCenter1.X() == 0.0);\n\tCHECK(newCenter1.Y() == 0.0);\n\tCHECK(newCenter1.Z() == 0.0);\n\tdouble angle = M_PI / 2;\n\tcircle3D.Rotated(zAxis, angle);\n\tAMCAX::Frame3 frame = circle3D.Position();\n\tCHECK(frame.Location().X() == 2.0);\n\tCHECK(frame.Location().Y() == 0.0);\n\tCHECK(frame.Location().Z() == 0.0);\n\tdouble scale = 2.0;\n\tcircle3D.Scale(center3D, scale);\n\tCHECK(circle3D.Radius() == radius3D * 2.0);\n\tAMCAX::PointT<double, 3> insidePoint(3.0, 4.0, 0.0);\n\tAMCAX::PointT<double, 3> onCirclePoint(5.0, 0.0, 0.0);\n\tAMCAX::PointT<double, 3> outsidePoint(8.0, 6.0, 0.0);\n\tdouble insideSquaredDistance = circle3D.SquaredDistance(insidePoint);\n\tdouble onCircleSquaredDistance = circle3D.SquaredDistance(onCirclePoint);\n\tdouble outsideSquaredDistance = circle3D.SquaredDistance(outsidePoint);\n\tCHECK(insideSquaredDistance == Approx(34.5378));\n\tCHECK(onCircleSquaredDistance == 81.0);\n\tCHECK(outsideSquaredDistance == Approx(7.7779));\n\tVectorT<double, 3> translationVector(5.0, 5.0, 0.0);\n\tcircle3D.Translate(translationVector);\n\tCHECK(circle3D.Location().X() == 9.0);\n\tCHECK(circle3D.Location().Y() == 5.0);\n\tCHECK(circle3D.Location().Z() == 0.0);\n\tauto xAxis = circle3D.XAxis();\n\tauto yAxis = circle3D.YAxis();\n\tCHECK(xAxis.Direction().X() == Approx(-1.0));\n\tCHECK(yAxis.Direction().Y() == Approx(-1.0));\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "void SetRadius(double r)\t @param r The radius\n\t @brief Set the radius of the circle\n,\n",
      "output": "#include <math/CircleT.hpp>\n#include <common/CoordT.hpp>\n#include <common/TransformationType.hpp>\n#include <common/DirectionT.hpp>\n#include <common/PointT.hpp>\n#include <common/Precision.hpp>\n#include <common/CoordT.hpp>\n#include <common/TransformationType.hpp>\n#include <topology/TopoEdge.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <topology/TopoWire.hpp>\n#include <modeling/MakeWire.hpp>\n#include <geometry/GlobalProperty.hpp>\n#include <topology/BRepGlobalProperty.hpp>\n#include<iostream>\n#include \"catch.hpp\" \nusing namespace std;\nusing namespace AMCAX;\nTEST_CASE(\"TestCircle2D\", \"[math][Circle2D]\")\n{\n\tAMCAX::CircleT<double, 2> circle2D;\n\tAMCAX::Point2 center2D(0.0, 0.0);\n\tdouble redius2D = 5.0;\n\tdouble tol = 0.1;\n\tcircle2D.SetLocation(center2D);\n\tcircle2D.SetRadius(redius2D);\n\tdouble area2D = circle2D.Area();\n\tdouble length2D = circle2D.Length();\n\tAMCAX::Point2 retcenter2D = circle2D.Location();\n\tdouble retarea2D = M_PI * redius2D * redius2D;\n\tdouble retlength2D = 2 * M_PI * redius2D;\n\tstd::cout << area2D << std::endl;\n\tstd::cout << length2D << std::endl;\n\tstd::cout << retcenter2D.X() << std::endl;\n\tstd::cout << retcenter2D.Y() << std::endl;\n\tCHECK(area2D == retarea2D);\n\tCHECK(length2D == retlength2D);\n\tCHECK(retcenter2D.X() == center2D.X());\n\tCHECK(retcenter2D.Y() == center2D.Y());\n\tdouble a, b, c, d, e, f;\n\tcircle2D.Coefficients(a, b, c, d, e, f);\n\tstd::cout << a << std::endl;\n\tstd::cout << b << std::endl;\n\tstd::cout << c << std::endl;\n\tstd::cout << d << std::endl;\n\tstd::cout << e << std::endl;\n\tstd::cout << f << std::endl;\n\tCHECK(a == 1);\n\tCHECK(b == 1);\n\tCHECK(c == 0);\n\tCHECK(d == 0);\n\tCHECK(e == 0);\n\tCHECK(f == -25);\n\tstd::vector < AMCAX::Point2> testPoints = {\n\t\tAMCAX::Point2(3.0, 4.0),\n\t\tAMCAX::Point2(5.0, 0.0),\n\t\tAMCAX::Point2(4.9, 0.0),\n\t\tAMCAX::Point2(5.1, 0.0),\n\t\tAMCAX::Point2(6.0, 0.0)\n\t};\n\tfor (const auto& point : testPoints)\n\t{\n\t\tdouble distanceToCenter = std::sqrt(point.X() * point.X() + point.Y() * point.Y());\n\t\tbool expectedIsInCircle = distanceToCenter <= 5.0 + tol;\n\t\tbool isInCircle = circle2D.Contains(point, tol);\n\t\tCHECK(isInCircle == expectedIsInCircle);\n\t}\n\tfor (const auto& point : testPoints)\n\t{\n\t\tdouble distance = circle2D.Distance(point);\n\t\tdouble expectedDistance = std::abs(std::sqrt(std::pow(point.X() - center2D.X(), 2) + std::pow(point.Y() - center2D.Y(), 2)) - redius2D);\n\t\tCHECK(distance == expectedDistance);\n\t}\n\tAMCAX::AxisT<double, 2> mirrorAxis(AMCAX::Point2(0.0, 0.0), AMCAX::Direction2(0.0, 1.0));\n\tcircle2D.Mirror(mirrorAxis);\n\tAMCAX::Point2 mirroredCenter = circle2D.Location();\n\tstd::cout << \"Mirrored circle center: (\" << mirroredCenter.X() << \", \" << mirroredCenter.Y() << \")\" << std::endl;\n\tCHECK(mirroredCenter.X() == center2D.X());\n\tCHECK(mirroredCenter.Y() == center2D.Y());\n\tconst AMCAX::FrameT<double, 2>& frame = circle2D.Position();\n\tAMCAX::Point2 rotationPoint(0.0, 0.0);\n\tdouble  rotationAngle = M_PI / 4;\n\tauto rotatedCircle = circle2D.Rotated(rotationPoint, rotationAngle);\n\tdouble cosAngle = cos(rotationAngle);\n\tdouble sinAngle = sin(rotationAngle);\n\tdouble newX = cosAngle * (center2D.X() - rotationPoint.X()) - sinAngle * (center2D.Y() - rotationPoint.Y()) + rotationPoint.X();\n\tdouble newY = sinAngle * (center2D.X() - rotationPoint.X()) + cosAngle * (center2D.Y() - rotationPoint.Y()) + rotationPoint.Y();\n\tauto rotatedCenter = rotatedCircle.Location();\n\tCHECK(newX == center2D.X());\n\tCHECK(newY == center2D.Y());\n\tAMCAX::Point2 scalingCenter(0.0, 0.0);\n\tdouble scalingFactor = 2.0;\n\tauto scaledCircle = circle2D.Scale(scalingCenter, scalingFactor);\n\tdouble scaledRadius = scaledCircle.Radius();\n\tdouble expectedScaledRadius = redius2D * scalingFactor;\n\tCHECK(std::abs(scaledRadius - expectedScaledRadius) < 1e-6);\n\tAMCAX::VectorT<double, 2> translationVector(2.0, 3.0);\n\tauto translatedCircle = circle2D.Translated(translationVector);\n\tauto translatedCenter = translatedCircle.Location();\n\tdouble translatedX = center2D.X() + translationVector.X();\n\tCHECK(translatedX == translatedCenter.X());\n\tauto xAxis = circle2D.XAxis();\n\tauto directionAxis = xAxis.Direction();\n\tCHECK(directionAxis.X() == -1.0);\n\tCHECK(directionAxis.Y() == 0.0);\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] double Length()\t @return The length of the circle\n\t @brief Get the length of the circle\n,\n",
      "output": "#include<catch.hpp>\n#include \"testHelper.h\"\n#include<iostream>\n#include <math/CircleT.hpp>\n#include <common/AxisT.hpp>\n#include <common/PointT.hpp>\nTEST_CASE(\"case1: create a Cirecle\", \"[math][CircleT][P1]\") {\n\tAMCAX::Point2 P(0.0,0.0);\n\tAMCAX::Direction2 D(1.0,0.0);\n\tAMCAX::Axis2  axis2(P, D);\n\tfloat radius = 5.0f;\n\tAMCAX::Circle2 circle2(axis2, radius, true);\n\tCHECK(circle2.Area() == radius * radius * M_PI); \n    double a, b, c, d, e, f;\n    circle2.Coefficients(a, b, c, d, e, f);  \n    double x = 0, y = 5;\n    CHECK(a * x * x + b * y * y + c * x * y + d * x + e * y + f == Approx(0.0).epsilon(1e-15));\n    double x1 = 5 * sqrt(2) / 2;\n    double y1 = 5 * sqrt(2) / 2;\n    double x2 = 6;\n    double y2 = 0;\n    double x3 = 5.5;\n    double y3 = 6.1;\n    AMCAX::Point2 P1(x1,y1);\n    AMCAX::Point2 P2(x2, y2);\n    AMCAX::Point2 P3(x3, y3);\n    double tolerance1 = 0.1;\n    double tolerance2 = 1.0;\n    CHECK(circle2.Contains(P1, tolerance1) == true);\n    CHECK(circle2.Contains(P2, tolerance2) == true);\n    CHECK(circle2.Contains(P3, tolerance2) == false);\n    CHECK(circle2.Distance(P1) == Approx(0.0).epsilon(1e-15));\n    CHECK(circle2.Distance(P2) == Approx(1.0).epsilon(1e-15));\n    CHECK(circle2.Length() == Approx(2*M_PI*radius).epsilon(1e-15));\n    AMCAX::Point2 locationP = circle2.Location();\n    CHECK(locationP.X() == Approx(0.0).epsilon(1e-15));\n    CHECK(locationP.Y() == Approx(0.0).epsilon(1e-15));\n    AMCAX::Point2 mirrorAxisPoint(1.0, 0.0);\n    AMCAX::Direction2 mirrorAxisDirection(0.0, 1.0);\n    AMCAX::Axis2 mirrorAxis(mirrorAxisPoint, mirrorAxisDirection);\n    circle2.Mirror(mirrorAxis);\n    CHECK(circle2.Length() == Approx(2 * M_PI * radius).epsilon(1e-15));\n    AMCAX::Point2 locationPmirror = circle2.Location();\n    CHECK(locationPmirror.X() == Approx(2.0).epsilon(1e-15));\n    CHECK(locationPmirror.Y() == Approx(0.0).epsilon(1e-15));\n    AMCAX::Point2 P4(7.0, 0.0);  \n    CHECK(circle2.Contains(P4, tolerance2) == true);\n    AMCAX::Point2 mirroredAxisPoint(1.0, 0.0);\n    AMCAX::Direction2 mirroredAxisDirection(0.0, 1.0);\n    AMCAX::Axis2 mirroedrAxis(mirroredAxisPoint, mirroredAxisDirection);\n    AMCAX::Circle2 circle2mirrored = circle2.Mirrored(mirroedrAxis);\n    CHECK(circle2mirrored.Length() == Approx(2 * M_PI * radius).epsilon(1e-15));\n    AMCAX::Point2 locationPmirrored = circle2mirrored.Location();\n    CHECK(locationPmirrored.X() == Approx(0.0).epsilon(1e-15));\n    CHECK(locationPmirrored.Y() == Approx(0.0).epsilon(1e-15));\n    AMCAX::Frame2 frame2mirrored = circle2mirrored.Position(); \n    CHECK(frame2mirrored.Location().X() == Approx(0.0).epsilon(1e-15));\n    CHECK(frame2mirrored.Location().Y() == Approx(0.0).epsilon(1e-15));\n    const double& radiusmirrored = circle2mirrored.Radius(); \n    CHECK(radiusmirrored == Approx(radius).epsilon(1e-15));\n    circle2mirrored.Scale(P,0.5); \n    AMCAX::Point2 scaleP1(0.0,-2.5);\n    CHECK(circle2mirrored.Contains(scaleP1, 0) == true);\n    AMCAX::Circle2 circle2Scaled = circle2mirrored.Scale(P, 2); \n    AMCAX::Point2 scaledP1(0.0, 5.0);\n    CHECK(circle2Scaled.Contains(scaledP1, 0) == true);\n    AMCAX::Point2 rotateP(0.0,0.0);\n    double angle = 90.0 * (2 * M_PI / 360.0);\n    circle2.Rotate(rotateP, angle); \n    AMCAX::Point2 P5(0.0, -3.0);\n    CHECK(circle2.Contains(P5, 0) == true);\n    double angle2 = -180.0 * (2 * M_PI / 360.0);\n    AMCAX::Circle2 rotatedCircle2 = circle2.Rotated(rotateP, angle2); \n    AMCAX::Point2 P6(0.0, 3.0);\n    CHECK(rotatedCircle2.Contains(P6, 0) == true); \n    AMCAX::Point2 newP(0.0, 0.0);\n    rotatedCircle2.SetLocation(newP);\n    CHECK(rotatedCircle2.Contains(P1, 0) == true);\n    std::cout << circle2.Length() << std::endl;\n};\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "void SetRadius(double r)\t @param r The radius\n\t @brief Set the radius of the circle\n,\n",
      "output": "#include<catch.hpp>\n#include \"testHelper.h\"\n#include<iostream>\n#include <math/CircleT.hpp>\n#include <common/AxisT.hpp>\n#include <common/PointT.hpp>\nTEST_CASE(\"CircleT Area and Length Test\", \"[CircleT]\") {\n    AMCAX::Circle2 circle2;\n    circle2.SetRadius(5.0);\n    CHECK(circle2.Area() == Approx(78.53982));\n    CHECK(circle2.Length() == Approx(31.41593));\n    AMCAX::Circle3 circle3;\n    circle3.SetRadius(10.0);\n    CHECK(circle3.Area() == Approx(314.15927));\n    CHECK(circle3.Length() == Approx(62.83185));\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static bool Read(TopoShape& s, std::istream& is)\t @return True if the input process is succeed\n\t @param[in,out] is The input stream\n\t @param[out] s The shape\n\t @brief Read a shape from a stream\n,\n",
      "output": "#include <catch.hpp>\n#include<testHelper.h>\n#include <topology/TopoShape.hpp>\n#include <occtio/OCCTTool.hpp>\nstatic bool ComparisonFields(const std::string& file1, const std::string& file2, const std::string& fields)\n{\n\tifstream file1Stream(file1);\n\tifstream file2Stream(file2);\n\tif (file1Stream.is_open() == false || file2Stream.is_open() == false)\n\t{\n\t\tfile1Stream.close();\n\t\tfile2Stream.close();\n\t\treturn false;\n\t}\n\tstd::string line1, line2;\n\twhile (std::getline(file1Stream, line1))\n\t{\n\t\tif (line1.find(fields) != std::string::npos) break;\n\t}\n\twhile (std::getline(file2Stream, line2))\n\t{\n\t\tif (line2.find(fields) != std::string::npos) break;\n\t}\n\tfile1Stream.close();\n\tfile2Stream.close();\n\treturn line1 == line2;\n}\nTEST_CASE(\"CASE1:Check occtio read and write normal brep file function with different param \", \"[occtio][OCCTTool][p1][XXX]\") {\n\tAMCAX::TopoShape shape;\n\tbool isReadSuccess = AMCAX::OCCTIO::OCCTTool::Read(shape, INPUT_PATH_PREFIX\"occtio/occtio_read_I_brephaveMesh-case1.brep\");\n\tbool isWriteSuccess1f = AMCAX::OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f1-f-case1.brep\", false, 1);\n\tbool isWriteSuccess2f = AMCAX::OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f2-f-case1.brep\", false, 2);\n\tbool isWriteSuccess3f = AMCAX::OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f3-f-case1.brep\", false, 3);\n\tbool isWriteSuccess1t = AMCAX::OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f1-t-case1.brep\", true, 1);\n\tbool isWriteSuccess2t = AMCAX::OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f2-t-case1.brep\", true, 2);\n\tbool isWriteSuccess3t = AMCAX::OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f3-t-case1.brep\", true, 3);\n\tCHECK(isReadSuccess == true);\n\tCHECK(isWriteSuccess1f == true);\n\tCHECK(isWriteSuccess2f == true);\n\tCHECK(isWriteSuccess3f == true);\n\tCHECK(containsStringInFile(OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f1-f-case1.brep\", \"Triangulations 0\") == true);\n\tCHECK(containsStringInFile(OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f1-f-case1.brep\", \"CASCADE Topology V1, (c) Matra-Datavision\") == true);\n\tCHECK(containsStringInFile(OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f2-f-case1.brep\", \"Triangulations 0\") == true);\n\tCHECK(containsStringInFile(OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f2-f-case1.brep\", \"CASCADE Topology V2, (c) Matra-Datavision\") == true);\n\tCHECK(containsStringInFile(OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f3-f-case1.brep\", \"Triangulations 0\") == true);\n\tCHECK(containsStringInFile(OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f3-f-case1.brep\", \"CASCADE Topology V3, (c) Open Cascade\") == true);\n\tCHECK(isWriteSuccess1t == true);\n\tCHECK(isWriteSuccess2t == true);\n\tCHECK(isWriteSuccess3t == true);\n\tCHECK(containsStringInFile(OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f1-t-case1.brep\", \"Triangulations 0\") == false);\n\tCHECK(containsStringInFile(OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f1-t-case1.brep\", \"CASCADE Topology V1, (c) Matra-Datavision\") == true);\n\tCHECK(containsStringInFile(OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f2-t-case1.brep\", \"Triangulations 0\") == false);\n\tCHECK(containsStringInFile(OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f2-t-case1.brep\", \"CASCADE Topology V2, (c) Matra-Datavision\") == true);\n\tCHECK(containsStringInFile(OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f3-t-case1.brep\", \"Triangulations 0\") == false);\n\tCHECK(containsStringInFile(OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f3-t-case1.brep\", \"CASCADE Topology V3, (c) Open Cascade\") == true);\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static bool Write(const TopoShape& s, const std::string& file, bool withTriangles, int format = 3)\t @return True if the output process is succeed\n\t @param format The format version\n\t @param withTriangles Determine whether writing the triangular mesh of the shape\n\t @param file The output file\n\t @param s The shape\n\t @brief Write a shape to a file\n,\n",
      "output": "#include <catch.hpp>\n#include<testHelper.h>\n#include <topology/TopoShape.hpp>\n#include <occtio/OCCTTool.hpp>\nstatic bool ComparisonFields(const std::string& file1, const std::string& file2, const std::string& fields)\n{\n\tifstream file1Stream(file1);\n\tifstream file2Stream(file2);\n\tif (file1Stream.is_open() == false || file2Stream.is_open() == false)\n\t{\n\t\tfile1Stream.close();\n\t\tfile2Stream.close();\n\t\treturn false;\n\t}\n\tstd::string line1, line2;\n\twhile (std::getline(file1Stream, line1))\n\t{\n\t\tif (line1.find(fields) != std::string::npos) break;\n\t}\n\twhile (std::getline(file2Stream, line2))\n\t{\n\t\tif (line2.find(fields) != std::string::npos) break;\n\t}\n\tfile1Stream.close();\n\tfile2Stream.close();\n\treturn line1 == line2;\n}\nTEST_CASE(\"CASE1:Check occtio read and write normal brep file function with different param \", \"[occtio][OCCTTool][p1][XXX]\") {\n\tAMCAX::TopoShape shape;\n\tbool isReadSuccess = AMCAX::OCCTIO::OCCTTool::Read(shape, INPUT_PATH_PREFIX\"occtio/occtio_read_I_brephaveMesh-case1.brep\");\n\tbool isWriteSuccess1f = AMCAX::OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f1-f-case1.brep\", false, 1);\n\tbool isWriteSuccess2f = AMCAX::OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f2-f-case1.brep\", false, 2);\n\tbool isWriteSuccess3f = AMCAX::OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f3-f-case1.brep\", false, 3);\n\tbool isWriteSuccess1t = AMCAX::OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f1-t-case1.brep\", true, 1);\n\tbool isWriteSuccess2t = AMCAX::OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f2-t-case1.brep\", true, 2);\n\tbool isWriteSuccess3t = AMCAX::OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f3-t-case1.brep\", true, 3);\n\tCHECK(isReadSuccess == true);\n\tCHECK(isWriteSuccess1f == true);\n\tCHECK(isWriteSuccess2f == true);\n\tCHECK(isWriteSuccess3f == true);\n\tCHECK(containsStringInFile(OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f1-f-case1.brep\", \"Triangulations 0\") == true);\n\tCHECK(containsStringInFile(OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f1-f-case1.brep\", \"CASCADE Topology V1, (c) Matra-Datavision\") == true);\n\tCHECK(containsStringInFile(OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f2-f-case1.brep\", \"Triangulations 0\") == true);\n\tCHECK(containsStringInFile(OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f2-f-case1.brep\", \"CASCADE Topology V2, (c) Matra-Datavision\") == true);\n\tCHECK(containsStringInFile(OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f3-f-case1.brep\", \"Triangulations 0\") == true);\n\tCHECK(containsStringInFile(OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f3-f-case1.brep\", \"CASCADE Topology V3, (c) Open Cascade\") == true);\n\tCHECK(isWriteSuccess1t == true);\n\tCHECK(isWriteSuccess2t == true);\n\tCHECK(isWriteSuccess3t == true);\n\tCHECK(containsStringInFile(OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f1-t-case1.brep\", \"Triangulations 0\") == false);\n\tCHECK(containsStringInFile(OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f1-t-case1.brep\", \"CASCADE Topology V1, (c) Matra-Datavision\") == true);\n\tCHECK(containsStringInFile(OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f2-t-case1.brep\", \"Triangulations 0\") == false);\n\tCHECK(containsStringInFile(OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f2-t-case1.brep\", \"CASCADE Topology V2, (c) Matra-Datavision\") == true);\n\tCHECK(containsStringInFile(OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f3-t-case1.brep\", \"Triangulations 0\") == false);\n\tCHECK(containsStringInFile(OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f3-t-case1.brep\", \"CASCADE Topology V3, (c) Open Cascade\") == true);\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static bool Write(const TopoShape& s, const std::string& file, int format = 3)\t @return True if the output process is succeed\n\t @param format The format version\n\t @param file The output file\n\t @param s The shape\n\t @brief Write a shape to a file\n,\n",
      "output": "#include <catch.hpp>\n#include<testHelper.h>\n#include <topology/TopoShape.hpp>\n#include <occtio/OCCTTool.hpp>\nstatic bool ComparisonFields(const std::string& file1, const std::string& file2, const std::string& fields)\n{\n\tifstream file1Stream(file1);\n\tifstream file2Stream(file2);\n\tif (file1Stream.is_open() == false || file2Stream.is_open() == false)\n\t{\n\t\tfile1Stream.close();\n\t\tfile2Stream.close();\n\t\treturn false;\n\t}\n\tstd::string line1, line2;\n\twhile (std::getline(file1Stream, line1))\n\t{\n\t\tif (line1.find(fields) != std::string::npos) break;\n\t}\n\twhile (std::getline(file2Stream, line2))\n\t{\n\t\tif (line2.find(fields) != std::string::npos) break;\n\t}\n\tfile1Stream.close();\n\tfile2Stream.close();\n\treturn line1 == line2;\n}\nTEST_CASE(\"CASE1:Check occtio read and write normal brep file function with different param \", \"[occtio][OCCTTool][p1][XXX]\") {\n\tAMCAX::TopoShape shape;\n\tbool isReadSuccess = AMCAX::OCCTIO::OCCTTool::Read(shape, INPUT_PATH_PREFIX\"occtio/occtio_read_I_brephaveMesh-case1.brep\");\n\tbool isWriteSuccess1f = AMCAX::OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f1-f-case1.brep\", false, 1);\n\tbool isWriteSuccess2f = AMCAX::OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f2-f-case1.brep\", false, 2);\n\tbool isWriteSuccess3f = AMCAX::OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f3-f-case1.brep\", false, 3);\n\tbool isWriteSuccess1t = AMCAX::OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f1-t-case1.brep\", true, 1);\n\tbool isWriteSuccess2t = AMCAX::OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f2-t-case1.brep\", true, 2);\n\tbool isWriteSuccess3t = AMCAX::OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f3-t-case1.brep\", true, 3);\n\tCHECK(isReadSuccess == true);\n\tCHECK(isWriteSuccess1f == true);\n\tCHECK(isWriteSuccess2f == true);\n\tCHECK(isWriteSuccess3f == true);\n\tCHECK(containsStringInFile(OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f1-f-case1.brep\", \"Triangulations 0\") == true);\n\tCHECK(containsStringInFile(OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f1-f-case1.brep\", \"CASCADE Topology V1, (c) Matra-Datavision\") == true);\n\tCHECK(containsStringInFile(OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f2-f-case1.brep\", \"Triangulations 0\") == true);\n\tCHECK(containsStringInFile(OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f2-f-case1.brep\", \"CASCADE Topology V2, (c) Matra-Datavision\") == true);\n\tCHECK(containsStringInFile(OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f3-f-case1.brep\", \"Triangulations 0\") == true);\n\tCHECK(containsStringInFile(OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f3-f-case1.brep\", \"CASCADE Topology V3, (c) Open Cascade\") == true);\n\tCHECK(isWriteSuccess1t == true);\n\tCHECK(isWriteSuccess2t == true);\n\tCHECK(isWriteSuccess3t == true);\n\tCHECK(containsStringInFile(OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f1-t-case1.brep\", \"Triangulations 0\") == false);\n\tCHECK(containsStringInFile(OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f1-t-case1.brep\", \"CASCADE Topology V1, (c) Matra-Datavision\") == true);\n\tCHECK(containsStringInFile(OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f2-t-case1.brep\", \"Triangulations 0\") == false);\n\tCHECK(containsStringInFile(OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f2-t-case1.brep\", \"CASCADE Topology V2, (c) Matra-Datavision\") == true);\n\tCHECK(containsStringInFile(OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f3-t-case1.brep\", \"Triangulations 0\") == false);\n\tCHECK(containsStringInFile(OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f3-t-case1.brep\", \"CASCADE Topology V3, (c) Open Cascade\") == true);\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static bool Write(const TopoShape& s, std::ostream& os, bool withTriangles, int format = 3)\t @return True if the output process is succeed\n\t @param[in] format The format version\n\t @param[in] withTriangles Determine whether writing the triangular mesh of the shape\n\t @param[in,out] os The output stream\n\t @param[in] s The shape\n\t @brief Wrtie a shape to a stream\n,\n",
      "output": "#include <catch.hpp>\n#include<testHelper.h>\n#include <topology/TopoShape.hpp>\n#include <occtio/OCCTTool.hpp>\nstatic bool ComparisonFields(const std::string& file1, const std::string& file2, const std::string& fields)\n{\n\tifstream file1Stream(file1);\n\tifstream file2Stream(file2);\n\tif (file1Stream.is_open() == false || file2Stream.is_open() == false)\n\t{\n\t\tfile1Stream.close();\n\t\tfile2Stream.close();\n\t\treturn false;\n\t}\n\tstd::string line1, line2;\n\twhile (std::getline(file1Stream, line1))\n\t{\n\t\tif (line1.find(fields) != std::string::npos) break;\n\t}\n\twhile (std::getline(file2Stream, line2))\n\t{\n\t\tif (line2.find(fields) != std::string::npos) break;\n\t}\n\tfile1Stream.close();\n\tfile2Stream.close();\n\treturn line1 == line2;\n}\nTEST_CASE(\"CASE1:Check occtio read and write normal brep file function with different param \", \"[occtio][OCCTTool][p1][XXX]\") {\n\tAMCAX::TopoShape shape;\n\tbool isReadSuccess = AMCAX::OCCTIO::OCCTTool::Read(shape, INPUT_PATH_PREFIX\"occtio/occtio_read_I_brephaveMesh-case1.brep\");\n\tbool isWriteSuccess1f = AMCAX::OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f1-f-case1.brep\", false, 1);\n\tbool isWriteSuccess2f = AMCAX::OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f2-f-case1.brep\", false, 2);\n\tbool isWriteSuccess3f = AMCAX::OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f3-f-case1.brep\", false, 3);\n\tbool isWriteSuccess1t = AMCAX::OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f1-t-case1.brep\", true, 1);\n\tbool isWriteSuccess2t = AMCAX::OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f2-t-case1.brep\", true, 2);\n\tbool isWriteSuccess3t = AMCAX::OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f3-t-case1.brep\", true, 3);\n\tCHECK(isReadSuccess == true);\n\tCHECK(isWriteSuccess1f == true);\n\tCHECK(isWriteSuccess2f == true);\n\tCHECK(isWriteSuccess3f == true);\n\tCHECK(containsStringInFile(OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f1-f-case1.brep\", \"Triangulations 0\") == true);\n\tCHECK(containsStringInFile(OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f1-f-case1.brep\", \"CASCADE Topology V1, (c) Matra-Datavision\") == true);\n\tCHECK(containsStringInFile(OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f2-f-case1.brep\", \"Triangulations 0\") == true);\n\tCHECK(containsStringInFile(OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f2-f-case1.brep\", \"CASCADE Topology V2, (c) Matra-Datavision\") == true);\n\tCHECK(containsStringInFile(OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f3-f-case1.brep\", \"Triangulations 0\") == true);\n\tCHECK(containsStringInFile(OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f3-f-case1.brep\", \"CASCADE Topology V3, (c) Open Cascade\") == true);\n\tCHECK(isWriteSuccess1t == true);\n\tCHECK(isWriteSuccess2t == true);\n\tCHECK(isWriteSuccess3t == true);\n\tCHECK(containsStringInFile(OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f1-t-case1.brep\", \"Triangulations 0\") == false);\n\tCHECK(containsStringInFile(OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f1-t-case1.brep\", \"CASCADE Topology V1, (c) Matra-Datavision\") == true);\n\tCHECK(containsStringInFile(OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f2-t-case1.brep\", \"Triangulations 0\") == false);\n\tCHECK(containsStringInFile(OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f2-t-case1.brep\", \"CASCADE Topology V2, (c) Matra-Datavision\") == true);\n\tCHECK(containsStringInFile(OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f3-t-case1.brep\", \"Triangulations 0\") == false);\n\tCHECK(containsStringInFile(OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f3-t-case1.brep\", \"CASCADE Topology V3, (c) Open Cascade\") == true);\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static bool Write(const TopoShape& s, std::ostream& os, int format = 3)\t @return True if the output process is succeed\n\t @param[in] format The format version\n\t @param[in,out] os The output stream\n\t @param[in] s The shape\n\t @brief Write a shape to a stream\n,\n",
      "output": "#include <catch.hpp>\n#include<testHelper.h>\n#include <topology/TopoShape.hpp>\n#include <occtio/OCCTTool.hpp>\nstatic bool ComparisonFields(const std::string& file1, const std::string& file2, const std::string& fields)\n{\n\tifstream file1Stream(file1);\n\tifstream file2Stream(file2);\n\tif (file1Stream.is_open() == false || file2Stream.is_open() == false)\n\t{\n\t\tfile1Stream.close();\n\t\tfile2Stream.close();\n\t\treturn false;\n\t}\n\tstd::string line1, line2;\n\twhile (std::getline(file1Stream, line1))\n\t{\n\t\tif (line1.find(fields) != std::string::npos) break;\n\t}\n\twhile (std::getline(file2Stream, line2))\n\t{\n\t\tif (line2.find(fields) != std::string::npos) break;\n\t}\n\tfile1Stream.close();\n\tfile2Stream.close();\n\treturn line1 == line2;\n}\nTEST_CASE(\"CASE1:Check occtio read and write normal brep file function with different param \", \"[occtio][OCCTTool][p1][XXX]\") {\n\tAMCAX::TopoShape shape;\n\tbool isReadSuccess = AMCAX::OCCTIO::OCCTTool::Read(shape, INPUT_PATH_PREFIX\"occtio/occtio_read_I_brephaveMesh-case1.brep\");\n\tbool isWriteSuccess1f = AMCAX::OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f1-f-case1.brep\", false, 1);\n\tbool isWriteSuccess2f = AMCAX::OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f2-f-case1.brep\", false, 2);\n\tbool isWriteSuccess3f = AMCAX::OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f3-f-case1.brep\", false, 3);\n\tbool isWriteSuccess1t = AMCAX::OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f1-t-case1.brep\", true, 1);\n\tbool isWriteSuccess2t = AMCAX::OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f2-t-case1.brep\", true, 2);\n\tbool isWriteSuccess3t = AMCAX::OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f3-t-case1.brep\", true, 3);\n\tCHECK(isReadSuccess == true);\n\tCHECK(isWriteSuccess1f == true);\n\tCHECK(isWriteSuccess2f == true);\n\tCHECK(isWriteSuccess3f == true);\n\tCHECK(containsStringInFile(OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f1-f-case1.brep\", \"Triangulations 0\") == true);\n\tCHECK(containsStringInFile(OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f1-f-case1.brep\", \"CASCADE Topology V1, (c) Matra-Datavision\") == true);\n\tCHECK(containsStringInFile(OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f2-f-case1.brep\", \"Triangulations 0\") == true);\n\tCHECK(containsStringInFile(OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f2-f-case1.brep\", \"CASCADE Topology V2, (c) Matra-Datavision\") == true);\n\tCHECK(containsStringInFile(OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f3-f-case1.brep\", \"Triangulations 0\") == true);\n\tCHECK(containsStringInFile(OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f3-f-case1.brep\", \"CASCADE Topology V3, (c) Open Cascade\") == true);\n\tCHECK(isWriteSuccess1t == true);\n\tCHECK(isWriteSuccess2t == true);\n\tCHECK(isWriteSuccess3t == true);\n\tCHECK(containsStringInFile(OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f1-t-case1.brep\", \"Triangulations 0\") == false);\n\tCHECK(containsStringInFile(OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f1-t-case1.brep\", \"CASCADE Topology V1, (c) Matra-Datavision\") == true);\n\tCHECK(containsStringInFile(OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f2-t-case1.brep\", \"Triangulations 0\") == false);\n\tCHECK(containsStringInFile(OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f2-t-case1.brep\", \"CASCADE Topology V2, (c) Matra-Datavision\") == true);\n\tCHECK(containsStringInFile(OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f3-t-case1.brep\", \"Triangulations 0\") == false);\n\tCHECK(containsStringInFile(OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f3-t-case1.brep\", \"CASCADE Topology V3, (c) Open Cascade\") == true);\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static bool Read(TopoShape& s, const std::string& file)\t @return True if the input process is succeed\n\t @param file The input file\n\t @param s The shape\n\t @brief Read a shape from a file\n,\n",
      "output": "#include <catch.hpp>\n#include<testHelper.h>\n#include <topology/TopoShape.hpp>\n#include <occtio/OCCTTool.hpp>\nstatic bool ComparisonFields(const std::string& file1, const std::string& file2, const std::string& fields)\n{\n\tifstream file1Stream(file1);\n\tifstream file2Stream(file2);\n\tif (file1Stream.is_open() == false || file2Stream.is_open() == false)\n\t{\n\t\tfile1Stream.close();\n\t\tfile2Stream.close();\n\t\treturn false;\n\t}\n\tstd::string line1, line2;\n\twhile (std::getline(file1Stream, line1))\n\t{\n\t\tif (line1.find(fields) != std::string::npos) break;\n\t}\n\twhile (std::getline(file2Stream, line2))\n\t{\n\t\tif (line2.find(fields) != std::string::npos) break;\n\t}\n\tfile1Stream.close();\n\tfile2Stream.close();\n\treturn line1 == line2;\n}\nTEST_CASE(\"CASE2:Check occio read and write abnormal param brep file function \", \"[occtio][OCCTTool][p1][XXX]\") {\n\tAMCAX::TopoShape shape;\n\tbool isReadSuccess = AMCAX::OCCTIO::OCCTTool::Read(shape, INPUT_PATH_PREFIX\"occtio/occtio_read_I_brephaveMesh-case1.brep\");\n\tbool isReadSuccess1 = AMCAX::OCCTIO::OCCTTool::Read(shape, INPUT_PATH_PREFIX\"occtio/occtio_read_I_brephaveMesh-case1.brep\");\n\tbool isWriteSuccessf = AMCAX::OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f0-f-case2.brep\", false, 0);\n\tbool isWriteSuccess4f = AMCAX::OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh2-f4-f-case2.brep\", false, -999);\n\tbool isWriteSuccesst = AMCAX::OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f0-t-case2.brep\", true, 0);\n\tbool isWriteSuccess4t = AMCAX::OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f4-t-case2.brep\", true, 9999.99);\n\tCHECK(isReadSuccess == true);\n\tCHECK(isWriteSuccessf == false);\n\tCHECK(isWriteSuccess4f == false);\n\tCHECK(isWriteSuccesst == false);\n\tCHECK(isWriteSuccess4t == false);\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static TopoShape FixShape(const TopoShape& shape, double prec, double maxTol)\t @return Fixed Shape\n\t @param maxTol The global max tolerance used when the algorithm needs to check the tolerance\n\t @param prec The global precision used when the algorithm needs to check the precision\n\t @param shape Input shape\n\t @brief Try to repair the shape to a valid shape\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <healing/ShapeFixTool.hpp>\n#include <common/Precision.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"bug1: ShapeFixTool \", \"[healing][ShapeFixTool][fixbug]\") {\n\tAMCAX::TopoShape readshape;\n\tAMCAX::OCCTIO::OCCTTool::Read(readshape, INPUT_PATH_PREFIX\"FixShape-Crash.brep\");\n\treadshape = AMCAX::ShapeFixTool::FixShape(readshape, AMCAX::Precision::Confusion(), 1E-1);\n\tAMCAX::OCCTIO::OCCTTool::Write(readshape, OUTPUT_PATH_PREFIX\"ShapeFixTool_O_FixedShape.brep\");\n\tGlobalProperty prop;\n\tBRepGlobalProperty::VolumeProperties(readshape, prop);\n\tCHECK(prop.Mass() == Approx(16486799.3305680156).epsilon(1e-2));\n\tPoint3 vP = prop.CenterOfMass();\n\tCHECK(vP.X() == Approx(-260.8706721039).epsilon(1e-2));\n\tCHECK(vP.Y() == Approx(-154.6717940115).epsilon(1e-2));\n\tCHECK(vP.Z() == Approx(-0.1139512307).epsilon(1e-2));\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API explicit BRepFaceClassifier(const TopoFace& f)\t @param f The input face\n\t @brief Construct from the face to be processed\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <hatch/BRepFaceClassifier.hpp>\n#include <common/FrameT.hpp>\n#include <math/CircleT.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeWire.hpp>\n#include <modeling/MakeFace.hpp>\n#include <boolean/BoolBRepFuse.hpp>\n#include <common/IndexSet.hpp>\n#include <topology/TopoExplorerTool.hpp>\nusing namespace AMCAX;\nTopoFace WrenchFace()\n{\n\tFrame3 fm1(Point3(0., 0., 0.), Direction3(0., 0., 1.0));\n\tCircle3 c1 = Circle3(fm1, 2.);\n\tTopoEdge ec1 = MakeEdge(c1);\n\tTopoWire wc1 = MakeWire(ec1);\n\tTopoFace F1 = MakeFace(wc1);\n\tTopoEdge edge1 = MakeEdge(Point3(-4., -1.0, 0.0), Point3(4., -1.0, 0.0));\n\tTopoEdge edge2 = MakeEdge(Point3(4., -1.0, 0.0), Point3(4., 1.0, 0.0));\n\tTopoEdge edge3 = MakeEdge(Point3(4., 1.0, 0.0), Point3(-4., 1.0, 0.0));\n\tTopoEdge edge4 = MakeEdge(Point3(-4., 1.0, 0.0), Point3(-4., -1.0, 0.0));\n\tTopoWire wireR = MakeWire(edge1, edge2, edge3, edge4);\n\tTopoFace F3 = MakeFace(wireR);\n\tBoolBRepFuse fuse(F1, F3);\n\tfuse.Build();\n\tfuse.SimplifyResult();\n\tTopoShape res = fuse.Shape();\n\tIndexSet<TopoShape> resFaces;\n\tTopoExplorerTool::MapShapes(res, ShapeType::Face, resFaces);\n\tstd::cout << resFaces.size() << std::endl;\n\tTopoFace face = static_cast<const TopoFace&>(resFaces[0]);\n\treturn face;\n}\nbool ImpInWrenchFace(const Point2& pt)\n{\n\tbool isFaceIn1 = pt.X() * pt.X() + pt.Y() * pt.Y() < 2 * 2;\n\tbool isFaceIn2 = pt.X() > -4 && pt.X() < 4 && pt.Y() > -1 && pt.Y() < 1;\n\treturn isFaceIn1 || isFaceIn2;\n}\nPoint2 SampleMethodFace()\n{\n\tdouble x = (double)rand() / RAND_MAX * 10 - 5;\n\tdouble y = (double)rand() / RAND_MAX * 5 - 2.0;\n\treturn Point2(x, y);\n}\nTEST_CASE(\"case1: BRepFaceClassifier 3.6.0 added API. \", \"[hatch][BRepFaceClassifier][P1]\") {\n\t\tTopoFace face = WrenchFace();\n\t\tBRepFaceClassifier classify(face);\n\t\tint n = 10000;\n\t\tint inSize = 0, intime = 0, ontime = 0;\n\t\tfor (int i = 0; i < n; ++i)\n\t\t{\n\t\t\tPoint2 pt = SampleMethodFace();\n\t\t\tbool isIn = ImpInWrenchFace(pt);\n\t\t\tclassify.Perform(pt, Precision::Confusion());\n\t\t\tbool isCIn = classify.State() == StateType::In;\n\t\t\tbool isCon = classify.State() == StateType::On;\n\t\t\tif (isIn)\n\t\t\t{\n\t\t\t\tinSize++;\n\t\t\t\tif (isCIn)\n\t\t\t\t{\n\t\t\t\t\tintime++;\n\t\t\t\t}\n\t\t\t\tif (isCon)\n\t\t\t\t{\n\t\t\t\t\tontime++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tstd::cout << inSize << \" \" << intime << \" \" << ontime << std::endl;\n\t\tCHECK(inSize == (intime + ontime));\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static bool IsSolidBounded(const TopoSolid& s)\t @return True if the solid and the solid is bounded (The infinite point is outside);\n\t @param s The solid\n\t @brief Classify whether the solid is bounded (The infinite point is outside)\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <io/ShapeTool.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <topology/TopoShape.hpp>\n#include <topology/TopoSolid.hpp>\n#include <modeling/MakeSolid.hpp>\n#include <modeling/MakeCylinder.hpp>\n#include <boolean/BoolBRepFuse.hpp>\n#include <boolean/BoolBRepCut.hpp>\n#include <topomesh/BRepMeshIncrementalMesh.hpp>\n#include <io/OBJTool.hpp>\n#include <hatch/BRepSolidClassifier.hpp>\n#include <healing/ShapeFixTool.hpp>\nusing namespace AMCAX;\nbool ImpInSolid1(const Point3& pt)\n{\n\tPoint3 pc1(849.32865292949998, -105.60711735517, 528.53715478963011);\n\tCoord3 cs1 = pt.Coord() - pc1.Coord();\n\tbool isSolidIn1 = pt.Y() < 29.654882644830003 && pt.Y() > -105.60711735517 && (cs1.X() * cs1.X() + cs1.Z() * cs1.Z()) < 5.415 * 5.415;\n\tPoint3 pc2(849.32865292763006, 12.992882644829002, 528.53715479109997);\n\tCoord3 cs2 = pt.Coord() - pc2.Coord();\n\tbool isSolidIn2 = pt.Z() < 543.83715479110003 && pt.Z() > 528.53715479109997 && (cs2.X() * cs2.X() + cs2.Y() * cs2.Y()) < 5.415 * 5.415;\n\treturn isSolidIn1 || isSolidIn2;\n}\nPoint3 SampleMethodCircle1()\n{\n\tdouble u = (double)rand() / RAND_MAX * 4 - 0.5;\n\tdouble r = (double)rand() / RAND_MAX * 0.00002 + 5.41499;\n\tdouble x = 849.32865292949998 + r * std::cos(u);\n\tdouble z = 528.53715478963011 + r * std::sin(u);\n\tdouble y = (double)rand() / RAND_MAX * 136 - 106;\n\treturn Point3(x, y, z);\n}\nTEST_CASE(\"bug: BRepClassificationTools::IsSolidBounded  related :\", \"[hatch][BRepClassificationTools][fixbug]\") {\n\tAMCAX::TopoShape readshape;\n\tbool readstatus = AMCAX::OCCTIO::OCCTTool::Read(readshape, INPUT_PATH_PREFIX\"0000-beforeFixShape.brep\");\n\tCHECK(readstatus == true);\n\treadshape = AMCAX::ShapeFixTool::FixShape(readshape, AMCAX::Precision::Confusion(), 1E-1);\n\tAMCAX::TopoSolid readsolid = AMCAX::MakeSolid(AMCAX::TopoCast::Shell(readshape));\n\tCHECK(AMCAX::BRepClassificationTools::IsSolidBounded(readsolid) == true);\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API MakeGeom3Ellipse(const Point3& s1, const Point3& s2, const Point3& center)\t @param center The center point\n\t @param s2 The point on the minor axis\n\t @param s1 The point on the major axis\n\t @brief Construct an ellipse from two points on the major and minor axis, and a center point\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/MakeGeom3Ellipse.hpp>\n#include <common/DirectionT.hpp>\n#include <common/PointT.hpp>\n#include <common/Precision.hpp>\n#include <topology/TopoEdge.hpp>\n#include <topology/TopoWire.hpp>\n#include <topology/TopoFace.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeWire.hpp>\n#include <modeling/MakeFace.hpp>\n#include <modeling/MakePrism.hpp>\n#include <topomesh/BRepMeshIncrementalMesh.hpp>\n#include <topology/TopoExplorerTool.hpp>\n#include <topology/TopoExplorer.hpp>\n#include <topology/TopoCast.hpp>\n#include <topology/TopoTool.hpp>\n#include <math/TriangularMesh.hpp>\nusing namespace AMCAX;\n#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/MakeGeom3Ellipse.hpp>\n#include <common/DirectionT.hpp>\n#include <common/PointT.hpp>\n#include <common/Precision.hpp>\n#include <topology/TopoEdge.hpp>\n#include <topology/TopoWire.hpp>\n#include <topology/TopoFace.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeWire.hpp>\n#include <modeling/MakeFace.hpp>\n#include <modeling/MakePrism.hpp>\n#include <topomesh/BRepMeshIncrementalMesh.hpp>\n#include <topology/TopoExplorerTool.hpp>\n#include <topology/TopoExplorer.hpp>\n#include <topology/TopoCast.hpp>\n#include <topology/TopoTool.hpp>\n#include <math/TriangularMesh.hpp>\nusing namespace AMCAX;\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API MakeGeom3Ellipse(const Frame3& frame, double majorRadius, double minorRadius)\t @param minorRadius The minor radius\n\t @param majorRadius The major radius\n\t @param frame The local frame\n\t @brief Construct an ellipse from a local frame, a major radius and a minor radius\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/MakeGeom3Ellipse.hpp>\n#include <common/DirectionT.hpp>\n#include <common/PointT.hpp>\n#include <common/Precision.hpp>\n#include <topology/TopoEdge.hpp>\n#include <topology/TopoWire.hpp>\n#include <topology/TopoFace.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeWire.hpp>\n#include <modeling/MakeFace.hpp>\n#include <modeling/MakePrism.hpp>\n#include <topomesh/BRepMeshIncrementalMesh.hpp>\n#include <topology/TopoExplorerTool.hpp>\n#include <topology/TopoExplorer.hpp>\n#include <topology/TopoCast.hpp>\n#include <topology/TopoTool.hpp>\n#include <math/TriangularMesh.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"bug1: MakeGeom3Ellipse \", \"[geometry][MakeGeom3Ellipse][fixbug]\") {\n\tMakeGeom3Ellipse makeEllipse(Frame3(), 3.0, 1.0);\n\tstd::shared_ptr<Geom3Curve> curve = makeEllipse.Value();\n\tTopoEdge e = MakeEdge(curve);\n\tTopoWire w = MakeWire(e);\n\tTopoFace f = MakeFace(w);\n\tTopoShape s = MakePrism(f, Vector3(0.0, 0.0, 1.0));\n\tBRepMeshIncrementalMesh mesher(s, 0.005, true);\n\tint counttest = 0;\n\tfor (TopoExplorer ex(s, ShapeType::Face); ex.More(); ex.Next())\n\t{\n\t\tconst auto& face = TopoCast::Face(ex.Current());\n\t\tTopoLocation l;\n\t\tauto tri = TopoTool::Triangulation(face, l);\n\t\tCHECK(tri); \n\t\tif (tri)\n\t\t{\n\t\t\tcounttest = counttest + 1;\n\t\t\tif (counttest == 1)\n\t\t\t{\n\t\t\t\tCHECK(tri->NVertices() == 84);\n\t\t\t\tCHECK(tri->NTriangles() == 82);\n\t\t\t}\n\t\t\tif (counttest == 2)\n\t\t\t{\n\t\t\t\tCHECK(tri->NVertices() == 41);\n\t\t\t\tCHECK(tri->NTriangles() == 39);\n\t\t\t}\n\t\t\tif (counttest == 3)\n\t\t\t{\n\t\t\t\tCHECK(tri->NVertices() == 41);\n\t\t\t\tCHECK(tri->NTriangles() == 39);\n\t\t\t}\n\t\t}\n\t}\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API explicit MakeGeom3Ellipse(const Ellipse3& e)\t @param e The ellipse\n\t @brief Construct from an ellipse\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/MakeGeom3Ellipse.hpp>\n#include <common/DirectionT.hpp>\n#include <common/PointT.hpp>\n#include <common/Precision.hpp>\n#include <topology/TopoEdge.hpp>\n#include <topology/TopoWire.hpp>\n#include <topology/TopoFace.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeWire.hpp>\n#include <modeling/MakeFace.hpp>\n#include <modeling/MakePrism.hpp>\n#include <topomesh/BRepMeshIncrementalMesh.hpp>\n#include <topology/TopoExplorerTool.hpp>\n#include <topology/TopoExplorer.hpp>\n#include <topology/TopoCast.hpp>\n#include <topology/TopoTool.hpp>\n#include <math/TriangularMesh.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"bug1: MakeGeom3Ellipse \", \"[geometry][MakeGeom3Ellipse][fixbug]\") {\n\tMakeGeom3Ellipse makeEllipse(Frame3(), 3.0, 1.0);\n\tstd::shared_ptr<Geom3Curve> curve = makeEllipse.Value();\n\tTopoEdge e = MakeEdge(curve);\n\tTopoWire w = MakeWire(e);\n\tTopoFace f = MakeFace(w);\n\tTopoShape s = MakePrism(f, Vector3(0.0, 0.0, 1.0));\n\tBRepMeshIncrementalMesh mesher(s, 0.005, true);\n\tint counttest = 0;\n\tfor (TopoExplorer ex(s, ShapeType::Face); ex.More(); ex.Next())\n\t{\n\t\tconst auto& face = TopoCast::Face(ex.Current());\n\t\tTopoLocation l;\n\t\tauto tri = TopoTool::Triangulation(face, l);\n\t\tCHECK(tri); \n\t\tif (tri)\n\t\t{\n\t\t\tcounttest = counttest + 1;\n\t\t\tif (counttest == 1)\n\t\t\t{\n\t\t\t\tCHECK(tri->NVertices() == 84);\n\t\t\t\tCHECK(tri->NTriangles() == 82);\n\t\t\t}\n\t\t\tif (counttest == 2)\n\t\t\t{\n\t\t\t\tCHECK(tri->NVertices() == 41);\n\t\t\t\tCHECK(tri->NTriangles() == 39);\n\t\t\t}\n\t\t\tif (counttest == 3)\n\t\t\t{\n\t\t\t\tCHECK(tri->NVertices() == 41);\n\t\t\t\tCHECK(tri->NTriangles() == 39);\n\t\t\t}\n\t\t}\n\t}\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API MakeArcOfCircle2d(const Point2& p1, const Vector2& v, const Point2& p2)\t @param p2 The end point\n\t @param v The tangent vector at p1\n\t @param p1 The start point\n\t @brief Construct an arc of circle from two points p1, p2 and a tangent vector v at p1\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <common/VectorT.hpp>\n#include <common/PointT.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/MakeArcOfCircle2d.hpp>\n#include <sstream>\nusing namespace AMCAX;\nTEST_CASE(\"bug1: MakeArcOfCircle2d  add 1 cases\", \"[geomAlgo][MakeArcOfCircle2d][fixbug]\") {\n\tstd::stringstream output;\n\tstd::shared_ptr<Geom2TrimmedCurve> c = MakeArcOfCircle2d(Point2(0.0, 1.0), Vector2(1.0, 0.0), Point2(1.0, 0.0));\n\tstd::cout << *c << std::endl;\n\toutput << *c << std::endl;\n\tauto case1 = output.str();\n\tauto expect1 = \"8 4.71239 6.28319\";\n\tauto expect2 = \"2 0 -0 1 0 0 -1 1\";\n\tCHECK(case1.find(expect1) != std::string::npos);\n\tCHECK(case1.find(expect2) != std::string::npos);\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API MakeArcOfCircle2d(const Point2& p1, const Point2& p2, const Point2& p3)\t @param p3 The end point\n\t @param p2 The middle point\n\t @param p1 The start point\n\t @brief Construct an arc of circle from three points p1, p2, p3\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <common/VectorT.hpp>\n#include <common/PointT.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/MakeArcOfCircle2d.hpp>\n#include <sstream>\nusing namespace AMCAX;\nTEST_CASE(\"bug1: MakeArcOfCircle2d  add 1 cases\", \"[geomAlgo][MakeArcOfCircle2d][fixbug]\") {\n\tstd::stringstream output;\n\tstd::shared_ptr<Geom2TrimmedCurve> c = MakeArcOfCircle2d(Point2(0.0, 1.0), Vector2(1.0, 0.0), Point2(1.0, 0.0));\n\tstd::cout << *c << std::endl;\n\toutput << *c << std::endl;\n\tauto case1 = output.str();\n\tauto expect1 = \"8 4.71239 6.28319\";\n\tauto expect2 = \"2 0 -0 1 0 0 -1 1\";\n\tCHECK(case1.find(expect1) != std::string::npos);\n\tCHECK(case1.find(expect2) != std::string::npos);\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static bool IsPlanarCurve(const std::shared_ptr<Geom3Curve>& c, Plane& plane, double tol = 1.0e-7)\t @return True if the curve is a planar curve\n\t @param tol The tolerance\n\t @param plane The plane found when the curve is planar curve\n\t @param c The input curve\n\t @details If the input curve, such as a line, is on more than one plane, it will return the plane in which any one is located\n\t @brief Check if a 3D curve is a planar curve, and if it is planar, find the plane\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/Geom2BezierCurve.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/MakeArcOfCircle2d.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <modeling/MakeEdge.hpp>\n#include<modeling/MakeEdge2d.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\n#include <geometry/Geom3Circle.hpp>\nusing namespace AMCAX;\nstd::shared_ptr<Geom2BezierCurve> MakeBezierCurve2d()\n{\n\tstd::vector<Point2> poles(4);\n\tpoles[0].SetCoord(1.0, 0.0);\n\tpoles[1].SetCoord(2.0, 1.0);\n\tpoles[2].SetCoord(3.0, -1.0);\n\tpoles[3].SetCoord(4.0, 0.0);\n\treturn std::make_shared<Geom2BezierCurve>(poles);\n}\nstd::shared_ptr<Geom2BSplineCurve> MakeBSplineCurve2d()\n{\n\tstd::vector<Point2> poles(7);\n\tpoles[0].SetCoord(0.5, 0.5);\n\tpoles[1].SetCoord(1.0, 3.0);\n\tpoles[2].SetCoord(3.0, 1.0);\n\tpoles[3].SetCoord(3.8, 2.0);\n\tpoles[4].SetCoord(2.5, 3.5);\n\tpoles[5].SetCoord(1.0, 0.5);\n\tpoles[6].SetCoord(0.3, 2.0);\n\tstd::vector<double> knots = { 0.0, 0.25, 0.5, 0.75, 1.0 };\n\tstd::vector<int> mults = { 4, 1, 1, 1, 4 };\n\treturn std::make_shared<Geom2BSplineCurve>(poles, knots, mults, 3);\n}\nstd::shared_ptr<Geom3BSplineCurve> MakeBSplineCurve3d(int degree, bool rational)\n{\n\tif (degree == 3)\n\t{\n\t\tstd::vector<Point3> poles(7);\n\t\tpoles[0].SetCoord(0.5, 0.5, 0.3);\n\t\tpoles[1].SetCoord(1.0, 3.0, 0.4);\n\t\tpoles[2].SetCoord(3.0, 1.0, 0.1);\n\t\tpoles[3].SetCoord(3.8, 2.0, 0.6);\n\t\tpoles[4].SetCoord(2.5, 3.5, 0.8);\n\t\tpoles[5].SetCoord(1.0, 0.5, 0.9);\n\t\tpoles[6].SetCoord(0.3, 2.0, 0.5);\n\t\tstd::vector<double> weights = { 1.0, 2.0, 3.0, 4.0, 3.0, 2.0, 1.0 };\n\t\tstd::vector<double> knots = { 0.0, 0.25, 0.5, 1.0 };\n\t\tstd::vector<int> mults = { 4, 1, 2, 4 };\n\t\treturn rational ? std::make_shared<Geom3BSplineCurve>(poles, weights, knots, mults, 3)\n\t\t\t: std::make_shared<Geom3BSplineCurve>(poles, knots, mults, 3);\n\t}\n\telse if (degree == 2)\n\t{\n\t\tstd::vector<Point3> poles(6);\n\t\tpoles[0].SetCoord(0.5, 0.5, 0.3);\n\t\tpoles[1].SetCoord(1.0, 3.0, 0.4);\n\t\tpoles[2].SetCoord(3.0, 1.0, 0.1);\n\t\tpoles[3].SetCoord(3.8, 2.0, 0.6);\n\t\tpoles[4].SetCoord(2.5, 3.5, 0.8);\n\t\tpoles[5].SetCoord(1.0, 0.5, 0.9);\n\t\tstd::vector<double> weights = { 1.0, 2.0, 3.0, 4.0, 3.0, 2.0 };\n\t\tstd::vector<double> knots = { 0.0, 0.25, 0.5, 1.0 };\n\t\tstd::vector<int> mults = { 3, 1, 2, 3 };\n\t\treturn rational ? std::make_shared<Geom3BSplineCurve>(poles, weights, knots, mults, 2)\n\t\t\t: std::make_shared<Geom3BSplineCurve>(poles, knots, mults, 2);\n\t}\n\treturn nullptr;\n}\nTEST_CASE(\"case2: IsPlanarCurve dev case \", \"[geometry][IsPlanarCurve][P1]\")\n{\n\tshared_ptr<Geom3BSplineCurve> curve3 = MakeBSplineCurve3d(3,true) ;\n\tPlane plane;\n\tCHECK(GeometryTool::IsPlanarCurve(curve3, plane) == false);\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API explicit GeomAPIIntCurveCurve2(const std::shared_ptr<Geom2Curve>& c1, double tol = 1.0e-6)\t @param tol The tolerance for computing self-intersection\n\t @param c1 The curve\n\t @brief Construct from one curve for finding self-intersections\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <sstream>\n#include <geometry/GeomAPIIntCurveCurve2.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <common/PointT.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"bug1: GeomAPIIntCurveCurve2  add 1 cases\", \"[geometry][GeomAPIIntCurveCurve2][fixbug]\") {\n\tstd::shared_ptr<Geom2BSplineCurve> bs1 = std::make_shared<Geom2BSplineCurve>();\n\tstd::shared_ptr<Geom2BSplineCurve> bs2 = std::make_shared<Geom2BSplineCurve>();\n\tstd::string str1 = \"7 0 0 3 118 116 0.32094859236148043 1.01737460557672743 0.32206087674542322 1.01734745284654182 0.32382938579023346 1.01745552974970388 0.32622057752030481 1.01788932455950976 0.32814024437537276 1.01839643017089987 0.33002743385020250 1.01906060903165452 0.33185490242395432 1.01986927403602690 0.33356030574937923 1.02078382513330879 0.33505523022905437 1.02172426942215600 0.33630356053380972 1.02261635998227951 0.33727879099865676 1.02338700329485177 0.33824387261988464 1.02421002336103761 0.33987143181385676 1.02571995716873454 0.34214827935107528 1.02826048315421636 0.34461603767621785 1.03183954355064644 0.34665036808905569 1.03570920433382874 0.34820760193471290 1.03964073803085988 0.34933771881337422 1.04355887677937265 0.35009685624211401 1.04745091431990089 0.35052967495496640 1.05132419100513896 0.35066857936404372 1.05518894219017056 0.35052557522962369 1.05904245911643380 0.35008366013718967 1.06287636600114777 0.34929841370764381 1.06667869354746858 0.34813822094610908 1.07042299939338448 0.34675750395147792 1.07412664136932645 0.34534310541281921 1.07786690172476352 0.34358161112094421 1.08147777823012681 0.34192774635989071 1.08514486567176727 0.34024883979957521 1.08877932697709046 0.33856258005747963 1.09239630776272234 0.33684922584157972 1.09599070530577980 0.33511401239025801 1.09956576491048708 0.33335775759028152 1.10312101734871382 0.33158157690922768 1.10665621463276231 0.32978475270252700 1.11017051339371275 0.32796684236813672 1.11366345386663435 0.32612725706778090 1.11713471339148707 0.32426602655273468 1.12058421069008607 0.32238317488364737 1.12401188835076016 0.32047891905305792 1.12741748347385329 0.31855350786840358 1.13080068581386772 0.31660697714151498 1.13416123619352938 0.31463922025518198 1.13749923563291944 0.31264987984545162 1.14081514934997053 0.31063848196500760 1.14410959402646872 0.30860463164217128 1.14738321401338195 0.30654793927361806 1.15063653610177630 0.30446802732993405 1.15386990664646771 0.30236451953097970 1.15708359051903131 0.30023708628717172 1.16027763956461594 0.29808538476977109 1.16345202237806822 0.29590934129126883 1.16660648017917135 0.29370889405197392 1.16974079885919968 0.29148391413490155 1.17285470277829651 0.28923416621699150 1.17594813233618023 0.28695938621068906 1.17902112690429606 0.28465933895561080 1.18207371247860404 0.28233386645185193 1.18510589143436862 0.27998289479713001 1.18811761370470093 0.27760632123816548 1.19110879993250829 0.27520390350264767 1.19407947381928281 0.27277523052158237 1.19702979458848002 0.27031974327907626 1.19995999134850062 0.26783696716142708 1.20287004707951173 0.26532688195672521 1.20575953789980805 0.26278972678816304 1.20862781671414088 0.26022529469643624 1.21147474893699236 0.25763217763048496 1.21430150477218790 0.25500825126397131 1.21710994249041904 0.25235292985377017 1.21990005059103868 0.24966926670272568 1.22266796329330352 0.24696150391975732 1.22540882939352413 0.24423004526152650 1.22812190210150329 0.24146125706394184 1.23081996151861128 0.23861784080316129 1.23353765899792966 0.23566141121739081 1.23630795850379083 0.23313267974624646 1.23863075403103817 0.23108077081313610 1.24048682151979905 0.22951564660225790 1.24188808346222479 0.22785243018268259 1.24336238482365724 0.22603998536410663 1.24495322387069107 0.22406854105345719 1.24666425686480453 0.22194392374121000 1.24848570059305053 0.21966929759239204 1.25041206987825992 0.21725182330646176 1.25242961584586521 0.21469769930661789 1.25453321201678158 0.21201305169290471 1.25670455099802481 0.20919423964305814 1.25892740388225111 0.20624946264626334 1.26119206481064094 0.20318480037069683 1.26348679862854585 0.20000837020587425 1.26579929017010295 0.19672786860887337 1.26811801505294564 0.19336384906039994 1.27045063232052602 0.18992974310269095 1.27279484301208434 0.18643645229630731 1.27514361933883413 0.18288284026026952 1.27747988214753017 0.17926432420455884 1.27979154638979287 0.17557650128119320 1.28206361390544510 0.17182058886568480 1.28428512148975549 0.16804984196678602 1.28645557821983747 0.16432856924206579 1.28857394891545374 0.16070988708733733 1.29064090195652370 0.15717518220101778 1.29262871928824441 0.15369583278895632 1.29452720045016001 0.15026398879500619 1.29632707889676935 0.14689767435611573 1.29803910611286755 0.14368667318979397 1.29963940415365520 0.14066793270237543 1.30110806215344477 0.13786588940702740 1.30241800503027294 0.13522308508227587 1.30359724798135068 0.13268958893136670 1.30462396744174369 0.13022457745464813 1.30549794019590903 0.12782549497702861 1.30621459673763263 0.12551678736811231 1.30677267551026310 0.12264034969535306 1.30729452653584777 0.12051776185100731 1.30747541630908004 0.11912669923861925 1.30748468412943986 0.00000000000000000 4 0.00332678777314067 1 0.00530015559541836 1 0.00728182036673812 1 0.00927733380420748 1 0.01129573787307914 1 0.01327102124276026 1 0.01507750651120846 1 0.01659037664031113 1 0.01787187841143642 1 0.01880519345805253 1 0.02039488120903255 1 0.02452963651417061 1 0.02900897063209700 1 0.03340295596517878 1 0.03761684169382203 1 0.04167362563339645 1 0.04561938121714045 1 0.04949884613367380 1 0.05335394957604591 1 0.05721079085185987 1 0.06105670932975029 1 0.06491896046411526 1 0.06884011522460366 1 0.07280266881291077 1 0.07677853454115921 1 0.08082727159450992 1 0.08484703393156430 1 0.08884800850224144 1 0.09283736315162679 1 0.09681928451811667 1 0.10079344442245329 1 0.10475903456581770 1 0.10871533221895527 1 0.11266230101625047 1 0.11659995734938959 1 0.12052830686968952 1 0.12444792190998373 1 0.12835862681996368 1 0.13226049935437312 1 0.13615329767464079 1 0.14003667398886835 1 0.14391115976349200 1 0.14777767334262687 1 0.15163719748113480 1 0.15549084375107922 1 0.15933948557025243 1 0.16318380109489106 1 0.16702443368061037 1 0.17086206197732215 1 0.17469676853931951 1 0.17852903287965541 1 0.18235853795986209 1 0.18618547107174704 1 0.19001029311391093 1 0.19383342115543040 1 0.19765535049879729 1 0.20147647336026475 1 0.20529702393677510 1 0.20911722784810613 1 0.21293746918119616 1 0.21675849605951392 1 0.22058118324198547 1 0.22440637655431431 1 0.22823412013034025 1 0.23206350223258385 1 0.23589437276278422 1 0.23972883230279066 1 0.24357130772232163 1 0.24742464110863499 1 0.25128370603023881 1 0.25513705909052109 1 0.25898297113943686 1 0.26283319300761221 1 0.26673478756179048 1 0.27078270046115210 1 0.27498764230925066 1 0.27703550353465400 1 0.27908314380440813 1 0.28128986356810332 1 0.28370321223532124 1 0.28631785618959721 1 0.28912103899968400 1 0.29209869219406109 1 0.29526001444575162 1 0.29856723628509552 1 0.30202524340776099 1 0.30561830049238314 1 0.30933640124059564 1 0.31316962603536763 1 0.31710368845632919 1 0.32112310784334058 1 0.32522104893482329 1 0.32938444032265624 1 0.33359681084096160 1 0.33784938027078792 1 0.34214253792603233 1 0.34647801531348960 1 0.35084331838884097 1 0.35523312810758656 1 0.35953028089402317 1 0.36368926465670970 1 0.36773529430744634 1 0.37169603595072809 1 0.37557957415417503 1 0.37936041511409840 1 0.38302581855344769 1 0.38634253837102683 1 0.38943124796238249 1 0.39230486518080748 1 0.39502350628500010 1 0.39762992993310575 1 0.40014797436892702 1 0.40253156052235123 1 0.40475213727501114 1 0.40891189273334161 4\";\n\tstd::string str2 = \"7 0 0 3 118 116 0.44698587761425512 1.01737460557672743 0.44586770461012754 1.01734792256404072 0.44408669680926910 1.01745649198371058 0.44167433575859827 1.01788973448550668 0.43973012306214176 1.01839676158274872 0.43781512528503469 1.01906078430998237 0.43595772107855257 1.01986941991017832 0.43422167753434071 1.02078367982801188 0.43270019179331992 1.02172276730688871 0.43143529102668837 1.02260881639260637 0.43047395316133663 1.02337915724656336 0.42956918011417972 1.02417518983407696 0.42818486699350283 1.02596609318184684 0.42535867595845256 1.02808829688484948 0.42284370487027889 1.03193726498772675 0.42029420450207700 1.03578860458891087 0.41779215915839102 1.03971518009696795 0.41524996629274769 1.04360952276868124 0.41268259846706867 1.04748256529635642 0.41009244215779894 1.05134004607881448 0.40748344575385259 1.05519270420095079 0.40486605902395167 1.05904184662506151 0.40221826431976609 1.06286057810161427 0.39954731386633807 1.06664354970287856 0.39685998643058945 1.07039722937908555 0.39415205518567858 1.07412233241535748 0.39142459506816268 1.07782095032413006 0.38867831705369166 1.08149595009323263 0.38591346143208760 1.08514964980580220 0.38313020259072789 1.08878346979564511 0.38032844124366111 1.09239780218286464 0.37750825751929029 1.09599269297900204 0.37466975732311525 1.09956803650327561 0.37181298113969291 1.10312349001628252 0.36893792871143949 1.10665859650325404 0.36604460396156768 1.11017278012274700 0.36313313466979064 1.11366550770546358 0.36020385654578302 1.11713665503127646 0.35725711512561398 1.12058603617284369 0.35429324377611354 1.12401373368655166 0.35131230158758986 1.12741939957610104 0.34831421468687968 1.13080262402140796 0.34529890614255510 1.13416313676223202 0.34226629246633017 1.13750078799254517 0.33921704684458587 1.14081632451049253 0.33615179652790328 1.14411040925898311 0.33307117902797256 1.14738370759211961 0.32997572188237095 1.15063676015840910 0.32686583766548316 1.15386986351118148 0.32374192911050353 1.15708326206532552 0.32060452465855971 1.16027718535470581 0.31745360371300196 1.16345153388182476 0.31428913900094868 1.16660594252951411 0.31111112410899561 1.16974020701489989 0.30791955045097874 1.17285394667146026 0.30471460628308072 1.17594719675858417 0.30149648916692096 1.17901999285247383 0.29826547554743049 1.18207244366664344 0.29502169193428479 1.18510458595828827 0.29176503889034477 1.18811625270052801 0.28849545711393992 1.19110735246150123 0.28521287446926513 1.19407776448826497 0.28191760121088905 1.19702778959143030 0.27860991172799571 1.19995767798350750 0.27529017147185769 1.20286775332443230 0.27195821134041676 1.20575742910935957 0.26861365400632170 1.20862591999664737 0.26525581006410243 1.21147208574228693 0.26188571532285843 1.21429744804454320 0.25850537979441068 1.21710464921168948 0.25511712957007160 1.21989678109210420 0.25171762413613974 1.22266823849310202 0.24830072265899519 1.22540963473078257 0.24486605329372579 1.22811942696225307 0.24141572018592131 1.23080424790172627 0.23796057988059283 1.23349025995382422 0.23455481289528443 1.23625809731511249 0.23178384866187560 1.23861884218329443 0.22958637070091326 1.24049429822100898 0.22792095077852323 1.24183892665189632 0.22633085712869647 1.24330474335321250 0.22482706539293790 1.24489950308425112 0.22341229813088337 1.24661390687506479 0.22209453169097026 1.24843902517094874 0.22087888937927413 1.25036828651214238 0.21977124333451431 1.25238938953827761 0.21877814583739183 1.25449449573067429 0.21790282053379528 1.25666553458695951 0.21714464814126716 1.25889056843647418 0.21650897231276728 1.26115706505645897 0.21599821380382661 1.26345359947659142 0.21561431786668875 1.26576891766763566 0.21535790133274418 1.26809712034575073 0.21523156999800702 1.27043621478677027 0.21523493789335055 1.27278382859372918 0.21536761702246404 1.27513094567987695 0.21562960091705158 1.27746540211106607 0.21601986302685286 1.27977480962963663 0.21653701136757098 1.28204820066314440 0.21718164535537912 1.28428355977126407 0.21795318927362628 1.28647141444648527 0.21885182671844836 1.28860254299760535 0.21987018385314080 1.29066214545958857 0.22100473503305496 1.29264388729952517 0.22225426990375063 1.29454179066819441 0.22361918358992602 1.29635228361390098 0.22510542017288909 1.29807648877092108 0.22668582626421535 1.29967791748795536 0.22833572049978873 1.30113992652563426 0.23002054288496601 1.30245118636949164 0.23175614453859494 1.30361712921158590 0.23353904515484103 1.30463669825309792 0.23536790944712538 1.30550821214031298 0.23723013129137352 1.30622515706156905 0.23909802022459714 1.30677963590280544 0.24158931746901185 1.30731428646199599 0.24348144169383945 1.30748511863814065 0.24475247407226391 1.30748468412943986 0.00000000000000000 4 0.00334434293035562 1 0.00533825930397336 1 0.00734412586267121 1 0.00936623440575543 1 0.01141256205459959 1 0.01341573096600146 1 0.01524709020284723 1 0.01677336277701813 1 0.01804490068923616 1 0.01894326352103789 1 0.02037993823386658 1 0.02480566898074880 1 0.02939205655814846 1 0.03404043378943207 1 0.03869805978018042 1 0.04334980332413108 1 0.04799487443159717 1 0.05263737365801836 1 0.05728913631958347 1 0.06195364423015201 1 0.06660152728460191 1 0.07122956329812886 1 0.07584610283920201 1 0.08045084571229059 1 0.08504550471877484 1 0.08963256787874113 1 0.09421407873103112 1 0.09879117107574811 1 0.10336422781387057 1 0.10793330889559200 1 0.11249839490034602 1 0.11705945929549585 1 0.12161613091223618 1 0.12616821278487000 1 0.13071541215010135 1 0.13525724181627602 1 0.13979405378099050 1 0.14432538686178745 1 0.14885137954117900 1 0.15337193703905613 1 0.15788673904588241 1 0.16239626042792893 1 0.16690070771036525 1 0.17140021344792761 1 0.17589510396468730 1 0.18038552504431565 1 0.18487151865902063 1 0.18935308684053462 1 0.19383026236900400 1 0.19830276789454376 1 0.20277103974370816 1 0.20723457084840083 1 0.21169339151646616 1 0.21614758290681596 1 0.22059709488399620 1 0.22504193032631326 1 0.22948214264998190 1 0.23391784916535033 1 0.23834913245589026 1 0.24277612072013041 1 0.24719890919114179 1 0.25161757662768108 1 0.25603221057958453 1 0.26044282613505232 1 0.26484890217770901 1 0.26925063819864326 1 0.27364813118187725 1 0.27804209715833189 1 0.28243253716855193 1 0.28681951085634216 1 0.29120020890283443 1 0.29557446914500052 1 0.29994411461100146 1 0.30431579875993647 1 0.30870332268475420 1 0.31310853612917888 1 0.31523624508228770 1 0.31737014111002310 1 0.31952856178681960 1 0.32171830465981011 1 0.32394102970905830 1 0.32619217521253946 1 0.32846706602101300 1 0.33077763413829298 1 0.33310205916533187 1 0.33544576479270716 1 0.33779655322040053 1 0.34015052354015518 1 0.34250407705161767 1 0.34485099381932000 1 0.34718783135835085 1 0.34952735554083242 1 0.35187486439618521 1 0.35422711580943594 1 0.35657637606518838 1 0.35891858548088795 1 0.36124990679045155 1 0.36356703547085450 1 0.36589411785453302 1 0.36820554269186456 1 0.37050138589761700 1 0.37278277874756854 1 0.37505181955993466 1 0.37731379776658153 1 0.37958010527703534 1 0.38187591368213569 1 0.38405827564667433 1 0.38618898795548318 1 0.38827607822097537 1 0.39032555279796965 1 0.39234499730597777 1 0.39434796008648582 1 0.39630575790533801 1 0.39818438284552959 1 0.40198436891082029 4\";\n\tstd::istringstream iss1(str1);\n\tstd::istringstream iss2(str2);\n\tiss1 >> *bs1;\n\tiss2 >> *bs2;\n\tGeomAPIIntCurveCurve2 icc(bs1, bs2, 1e-12);\n\tCHECK(icc.NPoints() == 2);\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API GeomAPIIntCurveCurve2(const std::shared_ptr<Geom2Curve>& c1, const std::shared_ptr<Geom2Curve>& c2, double tol = 1.0e-6)\t @param tol The tolerance for computing intersection\n\t @param c2 The second curve\n\t @param c1 The first curve\n\t @brief Construct from two curves\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <sstream>\n#include <geometry/GeomAPIIntCurveCurve2.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <common/PointT.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"bug1: GeomAPIIntCurveCurve2  add 1 cases\", \"[geometry][GeomAPIIntCurveCurve2][fixbug]\") {\n\tstd::shared_ptr<Geom2BSplineCurve> bs1 = std::make_shared<Geom2BSplineCurve>();\n\tstd::shared_ptr<Geom2BSplineCurve> bs2 = std::make_shared<Geom2BSplineCurve>();\n\tstd::string str1 = \"7 0 0 3 118 116 0.32094859236148043 1.01737460557672743 0.32206087674542322 1.01734745284654182 0.32382938579023346 1.01745552974970388 0.32622057752030481 1.01788932455950976 0.32814024437537276 1.01839643017089987 0.33002743385020250 1.01906060903165452 0.33185490242395432 1.01986927403602690 0.33356030574937923 1.02078382513330879 0.33505523022905437 1.02172426942215600 0.33630356053380972 1.02261635998227951 0.33727879099865676 1.02338700329485177 0.33824387261988464 1.02421002336103761 0.33987143181385676 1.02571995716873454 0.34214827935107528 1.02826048315421636 0.34461603767621785 1.03183954355064644 0.34665036808905569 1.03570920433382874 0.34820760193471290 1.03964073803085988 0.34933771881337422 1.04355887677937265 0.35009685624211401 1.04745091431990089 0.35052967495496640 1.05132419100513896 0.35066857936404372 1.05518894219017056 0.35052557522962369 1.05904245911643380 0.35008366013718967 1.06287636600114777 0.34929841370764381 1.06667869354746858 0.34813822094610908 1.07042299939338448 0.34675750395147792 1.07412664136932645 0.34534310541281921 1.07786690172476352 0.34358161112094421 1.08147777823012681 0.34192774635989071 1.08514486567176727 0.34024883979957521 1.08877932697709046 0.33856258005747963 1.09239630776272234 0.33684922584157972 1.09599070530577980 0.33511401239025801 1.09956576491048708 0.33335775759028152 1.10312101734871382 0.33158157690922768 1.10665621463276231 0.32978475270252700 1.11017051339371275 0.32796684236813672 1.11366345386663435 0.32612725706778090 1.11713471339148707 0.32426602655273468 1.12058421069008607 0.32238317488364737 1.12401188835076016 0.32047891905305792 1.12741748347385329 0.31855350786840358 1.13080068581386772 0.31660697714151498 1.13416123619352938 0.31463922025518198 1.13749923563291944 0.31264987984545162 1.14081514934997053 0.31063848196500760 1.14410959402646872 0.30860463164217128 1.14738321401338195 0.30654793927361806 1.15063653610177630 0.30446802732993405 1.15386990664646771 0.30236451953097970 1.15708359051903131 0.30023708628717172 1.16027763956461594 0.29808538476977109 1.16345202237806822 0.29590934129126883 1.16660648017917135 0.29370889405197392 1.16974079885919968 0.29148391413490155 1.17285470277829651 0.28923416621699150 1.17594813233618023 0.28695938621068906 1.17902112690429606 0.28465933895561080 1.18207371247860404 0.28233386645185193 1.18510589143436862 0.27998289479713001 1.18811761370470093 0.27760632123816548 1.19110879993250829 0.27520390350264767 1.19407947381928281 0.27277523052158237 1.19702979458848002 0.27031974327907626 1.19995999134850062 0.26783696716142708 1.20287004707951173 0.26532688195672521 1.20575953789980805 0.26278972678816304 1.20862781671414088 0.26022529469643624 1.21147474893699236 0.25763217763048496 1.21430150477218790 0.25500825126397131 1.21710994249041904 0.25235292985377017 1.21990005059103868 0.24966926670272568 1.22266796329330352 0.24696150391975732 1.22540882939352413 0.24423004526152650 1.22812190210150329 0.24146125706394184 1.23081996151861128 0.23861784080316129 1.23353765899792966 0.23566141121739081 1.23630795850379083 0.23313267974624646 1.23863075403103817 0.23108077081313610 1.24048682151979905 0.22951564660225790 1.24188808346222479 0.22785243018268259 1.24336238482365724 0.22603998536410663 1.24495322387069107 0.22406854105345719 1.24666425686480453 0.22194392374121000 1.24848570059305053 0.21966929759239204 1.25041206987825992 0.21725182330646176 1.25242961584586521 0.21469769930661789 1.25453321201678158 0.21201305169290471 1.25670455099802481 0.20919423964305814 1.25892740388225111 0.20624946264626334 1.26119206481064094 0.20318480037069683 1.26348679862854585 0.20000837020587425 1.26579929017010295 0.19672786860887337 1.26811801505294564 0.19336384906039994 1.27045063232052602 0.18992974310269095 1.27279484301208434 0.18643645229630731 1.27514361933883413 0.18288284026026952 1.27747988214753017 0.17926432420455884 1.27979154638979287 0.17557650128119320 1.28206361390544510 0.17182058886568480 1.28428512148975549 0.16804984196678602 1.28645557821983747 0.16432856924206579 1.28857394891545374 0.16070988708733733 1.29064090195652370 0.15717518220101778 1.29262871928824441 0.15369583278895632 1.29452720045016001 0.15026398879500619 1.29632707889676935 0.14689767435611573 1.29803910611286755 0.14368667318979397 1.29963940415365520 0.14066793270237543 1.30110806215344477 0.13786588940702740 1.30241800503027294 0.13522308508227587 1.30359724798135068 0.13268958893136670 1.30462396744174369 0.13022457745464813 1.30549794019590903 0.12782549497702861 1.30621459673763263 0.12551678736811231 1.30677267551026310 0.12264034969535306 1.30729452653584777 0.12051776185100731 1.30747541630908004 0.11912669923861925 1.30748468412943986 0.00000000000000000 4 0.00332678777314067 1 0.00530015559541836 1 0.00728182036673812 1 0.00927733380420748 1 0.01129573787307914 1 0.01327102124276026 1 0.01507750651120846 1 0.01659037664031113 1 0.01787187841143642 1 0.01880519345805253 1 0.02039488120903255 1 0.02452963651417061 1 0.02900897063209700 1 0.03340295596517878 1 0.03761684169382203 1 0.04167362563339645 1 0.04561938121714045 1 0.04949884613367380 1 0.05335394957604591 1 0.05721079085185987 1 0.06105670932975029 1 0.06491896046411526 1 0.06884011522460366 1 0.07280266881291077 1 0.07677853454115921 1 0.08082727159450992 1 0.08484703393156430 1 0.08884800850224144 1 0.09283736315162679 1 0.09681928451811667 1 0.10079344442245329 1 0.10475903456581770 1 0.10871533221895527 1 0.11266230101625047 1 0.11659995734938959 1 0.12052830686968952 1 0.12444792190998373 1 0.12835862681996368 1 0.13226049935437312 1 0.13615329767464079 1 0.14003667398886835 1 0.14391115976349200 1 0.14777767334262687 1 0.15163719748113480 1 0.15549084375107922 1 0.15933948557025243 1 0.16318380109489106 1 0.16702443368061037 1 0.17086206197732215 1 0.17469676853931951 1 0.17852903287965541 1 0.18235853795986209 1 0.18618547107174704 1 0.19001029311391093 1 0.19383342115543040 1 0.19765535049879729 1 0.20147647336026475 1 0.20529702393677510 1 0.20911722784810613 1 0.21293746918119616 1 0.21675849605951392 1 0.22058118324198547 1 0.22440637655431431 1 0.22823412013034025 1 0.23206350223258385 1 0.23589437276278422 1 0.23972883230279066 1 0.24357130772232163 1 0.24742464110863499 1 0.25128370603023881 1 0.25513705909052109 1 0.25898297113943686 1 0.26283319300761221 1 0.26673478756179048 1 0.27078270046115210 1 0.27498764230925066 1 0.27703550353465400 1 0.27908314380440813 1 0.28128986356810332 1 0.28370321223532124 1 0.28631785618959721 1 0.28912103899968400 1 0.29209869219406109 1 0.29526001444575162 1 0.29856723628509552 1 0.30202524340776099 1 0.30561830049238314 1 0.30933640124059564 1 0.31316962603536763 1 0.31710368845632919 1 0.32112310784334058 1 0.32522104893482329 1 0.32938444032265624 1 0.33359681084096160 1 0.33784938027078792 1 0.34214253792603233 1 0.34647801531348960 1 0.35084331838884097 1 0.35523312810758656 1 0.35953028089402317 1 0.36368926465670970 1 0.36773529430744634 1 0.37169603595072809 1 0.37557957415417503 1 0.37936041511409840 1 0.38302581855344769 1 0.38634253837102683 1 0.38943124796238249 1 0.39230486518080748 1 0.39502350628500010 1 0.39762992993310575 1 0.40014797436892702 1 0.40253156052235123 1 0.40475213727501114 1 0.40891189273334161 4\";\n\tstd::string str2 = \"7 0 0 3 118 116 0.44698587761425512 1.01737460557672743 0.44586770461012754 1.01734792256404072 0.44408669680926910 1.01745649198371058 0.44167433575859827 1.01788973448550668 0.43973012306214176 1.01839676158274872 0.43781512528503469 1.01906078430998237 0.43595772107855257 1.01986941991017832 0.43422167753434071 1.02078367982801188 0.43270019179331992 1.02172276730688871 0.43143529102668837 1.02260881639260637 0.43047395316133663 1.02337915724656336 0.42956918011417972 1.02417518983407696 0.42818486699350283 1.02596609318184684 0.42535867595845256 1.02808829688484948 0.42284370487027889 1.03193726498772675 0.42029420450207700 1.03578860458891087 0.41779215915839102 1.03971518009696795 0.41524996629274769 1.04360952276868124 0.41268259846706867 1.04748256529635642 0.41009244215779894 1.05134004607881448 0.40748344575385259 1.05519270420095079 0.40486605902395167 1.05904184662506151 0.40221826431976609 1.06286057810161427 0.39954731386633807 1.06664354970287856 0.39685998643058945 1.07039722937908555 0.39415205518567858 1.07412233241535748 0.39142459506816268 1.07782095032413006 0.38867831705369166 1.08149595009323263 0.38591346143208760 1.08514964980580220 0.38313020259072789 1.08878346979564511 0.38032844124366111 1.09239780218286464 0.37750825751929029 1.09599269297900204 0.37466975732311525 1.09956803650327561 0.37181298113969291 1.10312349001628252 0.36893792871143949 1.10665859650325404 0.36604460396156768 1.11017278012274700 0.36313313466979064 1.11366550770546358 0.36020385654578302 1.11713665503127646 0.35725711512561398 1.12058603617284369 0.35429324377611354 1.12401373368655166 0.35131230158758986 1.12741939957610104 0.34831421468687968 1.13080262402140796 0.34529890614255510 1.13416313676223202 0.34226629246633017 1.13750078799254517 0.33921704684458587 1.14081632451049253 0.33615179652790328 1.14411040925898311 0.33307117902797256 1.14738370759211961 0.32997572188237095 1.15063676015840910 0.32686583766548316 1.15386986351118148 0.32374192911050353 1.15708326206532552 0.32060452465855971 1.16027718535470581 0.31745360371300196 1.16345153388182476 0.31428913900094868 1.16660594252951411 0.31111112410899561 1.16974020701489989 0.30791955045097874 1.17285394667146026 0.30471460628308072 1.17594719675858417 0.30149648916692096 1.17901999285247383 0.29826547554743049 1.18207244366664344 0.29502169193428479 1.18510458595828827 0.29176503889034477 1.18811625270052801 0.28849545711393992 1.19110735246150123 0.28521287446926513 1.19407776448826497 0.28191760121088905 1.19702778959143030 0.27860991172799571 1.19995767798350750 0.27529017147185769 1.20286775332443230 0.27195821134041676 1.20575742910935957 0.26861365400632170 1.20862591999664737 0.26525581006410243 1.21147208574228693 0.26188571532285843 1.21429744804454320 0.25850537979441068 1.21710464921168948 0.25511712957007160 1.21989678109210420 0.25171762413613974 1.22266823849310202 0.24830072265899519 1.22540963473078257 0.24486605329372579 1.22811942696225307 0.24141572018592131 1.23080424790172627 0.23796057988059283 1.23349025995382422 0.23455481289528443 1.23625809731511249 0.23178384866187560 1.23861884218329443 0.22958637070091326 1.24049429822100898 0.22792095077852323 1.24183892665189632 0.22633085712869647 1.24330474335321250 0.22482706539293790 1.24489950308425112 0.22341229813088337 1.24661390687506479 0.22209453169097026 1.24843902517094874 0.22087888937927413 1.25036828651214238 0.21977124333451431 1.25238938953827761 0.21877814583739183 1.25449449573067429 0.21790282053379528 1.25666553458695951 0.21714464814126716 1.25889056843647418 0.21650897231276728 1.26115706505645897 0.21599821380382661 1.26345359947659142 0.21561431786668875 1.26576891766763566 0.21535790133274418 1.26809712034575073 0.21523156999800702 1.27043621478677027 0.21523493789335055 1.27278382859372918 0.21536761702246404 1.27513094567987695 0.21562960091705158 1.27746540211106607 0.21601986302685286 1.27977480962963663 0.21653701136757098 1.28204820066314440 0.21718164535537912 1.28428355977126407 0.21795318927362628 1.28647141444648527 0.21885182671844836 1.28860254299760535 0.21987018385314080 1.29066214545958857 0.22100473503305496 1.29264388729952517 0.22225426990375063 1.29454179066819441 0.22361918358992602 1.29635228361390098 0.22510542017288909 1.29807648877092108 0.22668582626421535 1.29967791748795536 0.22833572049978873 1.30113992652563426 0.23002054288496601 1.30245118636949164 0.23175614453859494 1.30361712921158590 0.23353904515484103 1.30463669825309792 0.23536790944712538 1.30550821214031298 0.23723013129137352 1.30622515706156905 0.23909802022459714 1.30677963590280544 0.24158931746901185 1.30731428646199599 0.24348144169383945 1.30748511863814065 0.24475247407226391 1.30748468412943986 0.00000000000000000 4 0.00334434293035562 1 0.00533825930397336 1 0.00734412586267121 1 0.00936623440575543 1 0.01141256205459959 1 0.01341573096600146 1 0.01524709020284723 1 0.01677336277701813 1 0.01804490068923616 1 0.01894326352103789 1 0.02037993823386658 1 0.02480566898074880 1 0.02939205655814846 1 0.03404043378943207 1 0.03869805978018042 1 0.04334980332413108 1 0.04799487443159717 1 0.05263737365801836 1 0.05728913631958347 1 0.06195364423015201 1 0.06660152728460191 1 0.07122956329812886 1 0.07584610283920201 1 0.08045084571229059 1 0.08504550471877484 1 0.08963256787874113 1 0.09421407873103112 1 0.09879117107574811 1 0.10336422781387057 1 0.10793330889559200 1 0.11249839490034602 1 0.11705945929549585 1 0.12161613091223618 1 0.12616821278487000 1 0.13071541215010135 1 0.13525724181627602 1 0.13979405378099050 1 0.14432538686178745 1 0.14885137954117900 1 0.15337193703905613 1 0.15788673904588241 1 0.16239626042792893 1 0.16690070771036525 1 0.17140021344792761 1 0.17589510396468730 1 0.18038552504431565 1 0.18487151865902063 1 0.18935308684053462 1 0.19383026236900400 1 0.19830276789454376 1 0.20277103974370816 1 0.20723457084840083 1 0.21169339151646616 1 0.21614758290681596 1 0.22059709488399620 1 0.22504193032631326 1 0.22948214264998190 1 0.23391784916535033 1 0.23834913245589026 1 0.24277612072013041 1 0.24719890919114179 1 0.25161757662768108 1 0.25603221057958453 1 0.26044282613505232 1 0.26484890217770901 1 0.26925063819864326 1 0.27364813118187725 1 0.27804209715833189 1 0.28243253716855193 1 0.28681951085634216 1 0.29120020890283443 1 0.29557446914500052 1 0.29994411461100146 1 0.30431579875993647 1 0.30870332268475420 1 0.31310853612917888 1 0.31523624508228770 1 0.31737014111002310 1 0.31952856178681960 1 0.32171830465981011 1 0.32394102970905830 1 0.32619217521253946 1 0.32846706602101300 1 0.33077763413829298 1 0.33310205916533187 1 0.33544576479270716 1 0.33779655322040053 1 0.34015052354015518 1 0.34250407705161767 1 0.34485099381932000 1 0.34718783135835085 1 0.34952735554083242 1 0.35187486439618521 1 0.35422711580943594 1 0.35657637606518838 1 0.35891858548088795 1 0.36124990679045155 1 0.36356703547085450 1 0.36589411785453302 1 0.36820554269186456 1 0.37050138589761700 1 0.37278277874756854 1 0.37505181955993466 1 0.37731379776658153 1 0.37958010527703534 1 0.38187591368213569 1 0.38405827564667433 1 0.38618898795548318 1 0.38827607822097537 1 0.39032555279796965 1 0.39234499730597777 1 0.39434796008648582 1 0.39630575790533801 1 0.39818438284552959 1 0.40198436891082029 4\";\n\tstd::istringstream iss1(str1);\n\tstd::istringstream iss2(str2);\n\tiss1 >> *bs1;\n\tiss2 >> *bs2;\n\tGeomAPIIntCurveCurve2 icc(bs1, bs2, 1e-12);\n\tCHECK(icc.NPoints() == 2);\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] AMCAX_API bool Contains(const Point3& point, double tol)\t @return True if the distance between the point and the plane is under the distance tolerance\n\t @param tol The distance tolerance\n\t @param point The point\n\t @brief Determines whether the plane contains a point under a tolerance or not\n,\n",
      "output": "#include \"catch.hpp\"\n#include <testHelper.h>\n#include <math/Plane.hpp>\nusing namespace AMCAX;\n#include \"catch.hpp\"\n#include <testHelper.h>\n#include <math/Plane.hpp>\nusing namespace AMCAX;\n;\n\tSECTION(\"Contains methods\") {\n        std::function<bool(const Plane&, const Point3&)> pointInPlane = [](const Plane& plane, const Point3& point)->bool {\n            Point3 planePoint = plane.Location();  \n            Vector3 planeVector(planePoint, point);  \n            double a, b, c, d;\n            plane.Coefficients(a, b, c, d);\n            return planeVector.Dot(Vector3(a, b, c)) == 0;\n        };\n        Plane plane(0., 0., 1., -1.); \n        Point3 point(1., 1., 1.);\n        Point3 point2(1., 1., 2.);\n        Line3 line(Point3(1., 1., 1.), Direction3(1., 0., 0.));\n        Line3 line2(Point3(1., 1., 1.), Direction3(0., 0., 1.));  \n        Line3 line3(Point3(1., 1., 0.), Direction3(1., 0., 0.));\n        REQUIRE(plane.Contains(point, 1e-6) == pointInPlane(plane, point));\n        REQUIRE(plane.Contains(point2, 1e-6) == pointInPlane(plane, point2));\n        REQUIRE(plane.Contains(line, 1e-6, 1e-6));\n        REQUIRE_FALSE(plane.Contains(line2, 1e-6, 1e-6 * (M_PI / 180)));\n        REQUIRE_FALSE(plane.Contains(line3, 1e-6, 1e-6 * (M_PI / 180)));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API Plane(double a, double b, double c, double d)\t @param a,b,c,d The coefficients\n\t @brief Construct from an algebraic representation: ax + by + cz + d = 0\n,\n",
      "output": "#include \"catch.hpp\"\n#include <testHelper.h>\n#include <math/Plane.hpp>\nusing namespace AMCAX;\n#include \"catch.hpp\"\n#include <testHelper.h>\n#include <math/Plane.hpp>\nusing namespace AMCAX;\n;\n\tSECTION(\"Construct from frame\") {\n        Frame3 frame1(Point3(0.0, 0.0, 0.0), Direction3(0.0, 0.0, 1.0));\n        Frame3 frame2(Point3(1.0, 0.0, 0.0), Direction3(2.0, 1.0, 1.0));\n        Plane plane1(frame1);\n        Plane plane2(frame2);  \n        double a1, b1, c1, d1;\n        plane1.Coefficients(a1, b1, c1, d1);\n        double a2, b2, c2, d2;\n        plane2.Coefficients(a2, b2, c2, d2);\n        REQUIRE(a1 == Approx(0));\n        REQUIRE(b1 == Approx(0));\n        REQUIRE(c1 == Approx(1));\n        REQUIRE(d1 == Approx(0));\n        REQUIRE(a2 == Approx(2. / std::sqrt(6)));\n        REQUIRE(b2 == Approx(1. / std::sqrt(6)));\n        REQUIRE(c2 == Approx(1. / std::sqrt(6)));\n        REQUIRE(d2 == Approx(-2. / std::sqrt(6)));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API Plane(const Point3& point, const Direction3& dir)\t @param dir The direction\n\t @param point The point\n\t @brief Construct from a point and a direction\n,\n",
      "output": "#include \"catch.hpp\"\n#include <testHelper.h>\n#include <math/Plane.hpp>\nusing namespace AMCAX;\n#include \"catch.hpp\"\n#include <testHelper.h>\n#include <math/Plane.hpp>\nusing namespace AMCAX;\n;\n\tSECTION(\"Construct from point and direction\") {\n        Point3 point(1., 1., 1.);\n        Direction3 dir(0., 0., 1.);\n        Plane plane(point, dir);  \n        Point3 point2(3., 4., 4.);\n        Direction3 dir2(2., 2., 1.);\n        Plane plane2(point2, dir2);  \n        double a, b, c, d;\n        plane.Coefficients(a, b, c, d);\n        double a2, b2, c2, d2;\n        plane2.Coefficients(a2, b2, c2, d2);\n        REQUIRE(a == Approx(0));\n        REQUIRE(b == Approx(0));\n        REQUIRE(c == Approx(1));\n        REQUIRE(d == Approx(-1));\n        REQUIRE(a2 == Approx(2./3).margin(0.0001));\n        REQUIRE(b2 == Approx(2./3).margin(0.0001));\n        REQUIRE(c2 == Approx(1./3).margin(0.0001));\n        REQUIRE(d2 == Approx(-6));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API explicit Plane(const Frame3& frame)\t @param frame The local frame\n\t @brief Construct from a local frame, XOY plane\n,\n",
      "output": "#include \"catch.hpp\"\n#include <testHelper.h>\n#include <math/Plane.hpp>\nusing namespace AMCAX;\n#include \"catch.hpp\"\n#include <testHelper.h>\n#include <math/Plane.hpp>\nusing namespace AMCAX;\n;\n\tSECTION(\"Construct from frame\") {\n        Frame3 frame1(Point3(0.0, 0.0, 0.0), Direction3(0.0, 0.0, 1.0));\n        Frame3 frame2(Point3(1.0, 0.0, 0.0), Direction3(2.0, 1.0, 1.0));\n        Plane plane1(frame1);\n        Plane plane2(frame2);  \n        double a1, b1, c1, d1;\n        plane1.Coefficients(a1, b1, c1, d1);\n        double a2, b2, c2, d2;\n        plane2.Coefficients(a2, b2, c2, d2);\n        REQUIRE(a1 == Approx(0));\n        REQUIRE(b1 == Approx(0));\n        REQUIRE(c1 == Approx(1));\n        REQUIRE(d1 == Approx(0));\n        REQUIRE(a2 == Approx(2. / std::sqrt(6)));\n        REQUIRE(b2 == Approx(1. / std::sqrt(6)));\n        REQUIRE(c2 == Approx(1. / std::sqrt(6)));\n        REQUIRE(d2 == Approx(-2. / std::sqrt(6)));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "Plane()\t Default constructor\n,\n",
      "output": "#include \"catch.hpp\"\n#include <testHelper.h>\n#include <math/Plane.hpp>\nusing namespace AMCAX;\n#include \"catch.hpp\"\n#include <testHelper.h>\n#include <math/Plane.hpp>\nusing namespace AMCAX;\n;\n\tSECTION(\"Default constructor\") {\n        Plane plane;\n        double a, b, c, d;\n        plane.Coefficients(a, b, c, d);\n        REQUIRE(a == Approx(0));\n        REQUIRE(b == Approx(0));\n        REQUIRE(c == Approx(1));\n        REQUIRE(d == Approx(0));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API void Coefficients(double& a, double& b, double& c, double& d)\t @param[out] a,b,c,d The coefficients\n\t @brief Get coefficients of algebraic representation: ax + by + cz + d = 0\n,\n",
      "output": "#include \"catch.hpp\"\n#include <testHelper.h>\n#include <math/Plane.hpp>\nusing namespace AMCAX;\n#include \"catch.hpp\"\n#include <testHelper.h>\n#include <math/Plane.hpp>\nusing namespace AMCAX;\n;\n\tSECTION(\"Default constructor\") {\n        Plane plane;\n        double a, b, c, d;\n        plane.Coefficients(a, b, c, d);\n        REQUIRE(a == Approx(0));\n        REQUIRE(b == Approx(0));\n        REQUIRE(c == Approx(1));\n        REQUIRE(d == Approx(0));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API Geom3Hyperbola(const Frame3& frame, double major, double minor)\t @param minor The minor radius\n\t @param major The major radius\n\t @param frame The local frame\n\t @brief Construct from a local frame, a major radius and a minor radius\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <math/EllipseT.hpp>\n#include <geometry/Geom3Hyperbola.hpp>\nusing namespace AMCAX;\nusing namespace std;\n#include <catch.hpp>\n#include <testHelper.h>\n#include <math/EllipseT.hpp>\n#include <geometry/Geom3Hyperbola.hpp>\nusing namespace AMCAX;\nusing namespace std;\n;\n\tSECTION(\"FocalParameter\")\n\t{\n\t\tdouble FP = g3h.FocalParameter();\n\t\tdouble focal = 2 * sqrt(major * major + minor * minor);\n\t\tdouble fp = 2 * minor * minor / focal;;\n\t\tCHECK(FP == fp);\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API Geom3Ellipse(const Frame3& frame, double major, double minor)\t @param minor The minor radius\n\t @param major The major radius\n\t @param frame The local frame\n\t @brief Construct from a local frame, a major radius and a minor radius\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/MakeGeom3Ellipse.hpp>\n#include <common/DirectionT.hpp>\n#include <common/PointT.hpp>\n#include <common/Precision.hpp>\n#include <topology/TopoEdge.hpp>\n#include <topology/TopoWire.hpp>\n#include <topology/TopoFace.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeWire.hpp>\n#include <modeling/MakeFace.hpp>\n#include <modeling/MakePrism.hpp>\n#include <topomesh/BRepMeshIncrementalMesh.hpp>\n#include <topology/TopoExplorerTool.hpp>\n#include <topology/TopoExplorer.hpp>\n#include <topology/TopoCast.hpp>\n#include <topology/TopoTool.hpp>\n#include <math/TriangularMesh.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"bug1: MakeGeom3Ellipse \", \"[geometry][MakeGeom3Ellipse][fixbug]\") {\n\tMakeGeom3Ellipse makeEllipse(Frame3(), 3.0, 1.0);\n\tstd::shared_ptr<Geom3Curve> curve = makeEllipse.Value();\n\tTopoEdge e = MakeEdge(curve);\n\tTopoWire w = MakeWire(e);\n\tTopoFace f = MakeFace(w);\n\tTopoShape s = MakePrism(f, Vector3(0.0, 0.0, 1.0));\n\tBRepMeshIncrementalMesh mesher(s, 0.005, true);\n\tint counttest = 0;\n\tfor (TopoExplorer ex(s, ShapeType::Face); ex.More(); ex.Next())\n\t{\n\t\tconst auto& face = TopoCast::Face(ex.Current());\n\t\tTopoLocation l;\n\t\tauto tri = TopoTool::Triangulation(face, l);\n\t\tCHECK(tri); \n\t\tif (tri)\n\t\t{\n\t\t\tcounttest = counttest + 1;\n\t\t\tif (counttest == 1)\n\t\t\t{\n\t\t\t\tCHECK(tri->NVertices() == 84);\n\t\t\t\tCHECK(tri->NTriangles() == 82);\n\t\t\t}\n\t\t\tif (counttest == 2)\n\t\t\t{\n\t\t\t\tCHECK(tri->NVertices() == 41);\n\t\t\t\tCHECK(tri->NTriangles() == 39);\n\t\t\t}\n\t\t\tif (counttest == 3)\n\t\t\t{\n\t\t\t\tCHECK(tri->NVertices() == 41);\n\t\t\t\tCHECK(tri->NTriangles() == 39);\n\t\t\t}\n\t\t}\n\t}\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API Geom3Ellipse(const Frame3& frame, double major, double minor)\t @param minor The minor radius\n\t @param major The major radius\n\t @param frame The local frame\n\t @brief Construct from a local frame, a major radius and a minor radius\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <common/FrameT.hpp>\n#include <math/EllipseT.hpp>\n#include <geometry/Geom3Ellipse.hpp>\nusing namespace AMCAX;\nusing namespace std;\n#include <catch.hpp>\n#include <testHelper.h>\n#include <common/FrameT.hpp>\n#include <math/EllipseT.hpp>\n#include <geometry/Geom3Ellipse.hpp>\nusing namespace AMCAX;\nusing namespace std;\n;\n\tSECTION(\"SemilatusRectum\")\n\t{\n\t\tdouble SR = g3e.SemilatusRectum();\n\t\tdouble sr = minor * minor / major;\n\t\tCHECK(SR == sr);\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API Cone& Transform(const Transformation3& tr)\t @return The reference to self\n\t @param tr The transformation\n\t @brief Transform the cone\n,\n",
      "output": "#include<iostream>\n#include \"catch.hpp\"\n#include <common/FrameT.hpp>\n#include <modeling/MakeFace.hpp>\n#include <common/AxisT.hpp>\n#include <common/FrameT.hpp>\n#include <common/VectorT.hpp>\n#include <math/Cone.hpp>\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"TestCone\", \"[math][Cone]\")\n{\n\tAMCAX::Frame3 frame;\n\tdouble radius = 5.0;\n\tdouble angle = M_PI / 4;\n\tAMCAX::Cone cone(frame, radius, angle);\n\tAMCAX::Point3 apex = cone.Apex();\n\tCHECK(apex.X() == 0.0);\n\tCHECK(apex.Y() == 0.0);\n\tCHECK(apex.Z() == Approx(-5.0));\n\tAMCAX::Axis3 axis = cone.Axis();\n\tstd::cout << axis.Direction().X() << std::endl;\n\tstd::cout << axis.Direction().Y() << std::endl;\n\tstd::cout << axis.Direction().Z() << std::endl;\n\tCHECK(axis.Direction().X() == 0.0);\n\tCHECK(axis.Direction().Y() == 0.0);\n\tCHECK(axis.Direction().Z() == 1.0);\n\tdouble a1, a2, a3, b1, b2, b3, c1, c2, c3, d;\n\tcone.Coefficients(a1, a2, a3, b1, b2, b3, c1, c2, c3, d);\n\tstd::cout << \"a1: \" << a1 << \", a2: \" << a2 << \", a3: \" << a3 << std::endl;\n\tstd::cout << \"b1: \" << b1 << \", b2: \" << b2 << \", b3: \" << b3 << std::endl;\n\tstd::cout << \"c1: \" << c1 << \", c2: \" << c2 << \", c3: \" << c3 << std::endl;\n\tstd::cout << \"d: \" << d << std::endl;\n\tCHECK(a1 == 1.0);\n\tCHECK(a2 == 1.0);\n\tCHECK(a3 == Approx(-1.0));\n\tCHECK(b1 == 0);\n\tCHECK(b2 == 0);\n\tCHECK(b3 == 0);\n\tCHECK(c1 == 0);\n\tCHECK(c2 == 0);\n\tCHECK(c3 == Approx(-5.0));\n\tCHECK(d == -25.0);\n\tCHECK(cone.IsDirect() == true);\n\tCHECK(cone.Location().X() == 0.0);\n\tCHECK(cone.Location().Y() == 0.0);\n\tCHECK(cone.Location().Z() == 0.0);\n\tAMCAX::PointT<double, 3>mirrorPoint(5.0, 0.0, 0.0);\n\tcone.Mirror(mirrorPoint);\n\tauto mirroredLocation = cone.Location();\n\tCHECK(mirroredLocation.X() == 10.0);\n\tCHECK(mirroredLocation.Y() == 0.0);\n\tCHECK(mirroredLocation.Z() == 0.0);\n\tAMCAX::Frame3 coneFrame = cone.Position();\n\tCHECK(frame.Location().X() == 0.0);\n\tCHECK(frame.Location().Y() == 0.0);\n\tCHECK(frame.Location().Z() == 0.0);\n\tCHECK(cone.Radius() == 5.0);\n\tdouble  scaleCone = 2.0;\n\tcone.Scale(cone.Location(), scaleCone);\n\tCHECK(cone.Radius() == radius * 2.0);\n\tdouble semiCone = cone.SemiAngle();\n\tCHECK(semiCone == Approx(0.785398));\n\tconst  Frame3& position = cone.Position();\n\tstd::cout << position.XAxis() << std::endl;\n\tstd::cout << position.YAxis() << std::endl;\n\tDirection3 zDirection(0.0, 0.0, 1.0);\n\tAMCAX::Point3  centerCone(0.0, 0.0, 0.0);\n\tAxis3 zAxis(centerCone, zDirection);\n\tcone.Rotated(zAxis, angle);\n\tAMCAX::Frame3 coneFrame2 = cone.Position();\n\tCHECK(coneFrame.Location().X() == 10.0);\n\tCHECK(coneFrame.Location().Y() == 0.0);\n\tCHECK(coneFrame.Location().Z() == 0.0);\n\tdouble scale = 2.0;\n\tcone.Scale(centerCone, scale);\n\tCHECK(cone.Radius() == radius * 4.0);\n\tdouble semiAngle = cone.SemiAngle();\n\tstd::cout << semiAngle << std::endl;\n\tCHECK(semiAngle == Approx(0.785398));\n\tVectorT<double, 3> translationVector(5.0, 5.0, 0.0);\n\tcone.Translate(translationVector);\n\tCHECK(cone.Location().X() == 25.0);\n\tCHECK(cone.Location().Y() == 5.0);\n\tCHECK(cone.Location().Z() == 0.0);\n\tauto xAxis = cone.XAxis();\n\tauto yAxis = cone.YAxis();\n\tCHECK(xAxis.Direction().X() == Approx(-1.0));\n\tCHECK(yAxis.Direction().Y() == Approx(-1.0));\n\tAMCAX::Transformation3 tr;\n\ttr.SetTranslation(Vector3(1.0, 2.0, 3.0));\n\tcone.Transform(tr);\n\tAxis3 newXAxis = cone.Position().XAxis();\n\tCHECK(newXAxis.Location().X() == 26.0);\n\tCHECK(newXAxis.Location().Y() == 7.0);\n\tCHECK(newXAxis.Location().Z() == 3.0);\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API Cone& Scale(const Point3& point, double scale)\t @return The reference to self\n\t @param scale The scale value\n\t @param point The scaling center point\n\t @brief Scale the cone by a point\n,\n",
      "output": "#include<iostream>\n#include \"catch.hpp\"\n#include <common/FrameT.hpp>\n#include <modeling/MakeFace.hpp>\n#include <common/AxisT.hpp>\n#include <common/FrameT.hpp>\n#include <common/VectorT.hpp>\n#include <math/Cone.hpp>\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"TestCone\", \"[math][Cone]\")\n{\n\tAMCAX::Frame3 frame;\n\tdouble radius = 5.0;\n\tdouble angle = M_PI / 4;\n\tAMCAX::Cone cone(frame, radius, angle);\n\tAMCAX::Point3 apex = cone.Apex();\n\tCHECK(apex.X() == 0.0);\n\tCHECK(apex.Y() == 0.0);\n\tCHECK(apex.Z() == Approx(-5.0));\n\tAMCAX::Axis3 axis = cone.Axis();\n\tstd::cout << axis.Direction().X() << std::endl;\n\tstd::cout << axis.Direction().Y() << std::endl;\n\tstd::cout << axis.Direction().Z() << std::endl;\n\tCHECK(axis.Direction().X() == 0.0);\n\tCHECK(axis.Direction().Y() == 0.0);\n\tCHECK(axis.Direction().Z() == 1.0);\n\tdouble a1, a2, a3, b1, b2, b3, c1, c2, c3, d;\n\tcone.Coefficients(a1, a2, a3, b1, b2, b3, c1, c2, c3, d);\n\tstd::cout << \"a1: \" << a1 << \", a2: \" << a2 << \", a3: \" << a3 << std::endl;\n\tstd::cout << \"b1: \" << b1 << \", b2: \" << b2 << \", b3: \" << b3 << std::endl;\n\tstd::cout << \"c1: \" << c1 << \", c2: \" << c2 << \", c3: \" << c3 << std::endl;\n\tstd::cout << \"d: \" << d << std::endl;\n\tCHECK(a1 == 1.0);\n\tCHECK(a2 == 1.0);\n\tCHECK(a3 == Approx(-1.0));\n\tCHECK(b1 == 0);\n\tCHECK(b2 == 0);\n\tCHECK(b3 == 0);\n\tCHECK(c1 == 0);\n\tCHECK(c2 == 0);\n\tCHECK(c3 == Approx(-5.0));\n\tCHECK(d == -25.0);\n\tCHECK(cone.IsDirect() == true);\n\tCHECK(cone.Location().X() == 0.0);\n\tCHECK(cone.Location().Y() == 0.0);\n\tCHECK(cone.Location().Z() == 0.0);\n\tAMCAX::PointT<double, 3>mirrorPoint(5.0, 0.0, 0.0);\n\tcone.Mirror(mirrorPoint);\n\tauto mirroredLocation = cone.Location();\n\tCHECK(mirroredLocation.X() == 10.0);\n\tCHECK(mirroredLocation.Y() == 0.0);\n\tCHECK(mirroredLocation.Z() == 0.0);\n\tAMCAX::Frame3 coneFrame = cone.Position();\n\tCHECK(frame.Location().X() == 0.0);\n\tCHECK(frame.Location().Y() == 0.0);\n\tCHECK(frame.Location().Z() == 0.0);\n\tCHECK(cone.Radius() == 5.0);\n\tdouble  scaleCone = 2.0;\n\tcone.Scale(cone.Location(), scaleCone);\n\tCHECK(cone.Radius() == radius * 2.0);\n\tdouble semiCone = cone.SemiAngle();\n\tCHECK(semiCone == Approx(0.785398));\n\tconst  Frame3& position = cone.Position();\n\tstd::cout << position.XAxis() << std::endl;\n\tstd::cout << position.YAxis() << std::endl;\n\tDirection3 zDirection(0.0, 0.0, 1.0);\n\tAMCAX::Point3  centerCone(0.0, 0.0, 0.0);\n\tAxis3 zAxis(centerCone, zDirection);\n\tcone.Rotated(zAxis, angle);\n\tAMCAX::Frame3 coneFrame2 = cone.Position();\n\tCHECK(coneFrame.Location().X() == 10.0);\n\tCHECK(coneFrame.Location().Y() == 0.0);\n\tCHECK(coneFrame.Location().Z() == 0.0);\n\tdouble scale = 2.0;\n\tcone.Scale(centerCone, scale);\n\tCHECK(cone.Radius() == radius * 4.0);\n\tdouble semiAngle = cone.SemiAngle();\n\tstd::cout << semiAngle << std::endl;\n\tCHECK(semiAngle == Approx(0.785398));\n\tVectorT<double, 3> translationVector(5.0, 5.0, 0.0);\n\tcone.Translate(translationVector);\n\tCHECK(cone.Location().X() == 25.0);\n\tCHECK(cone.Location().Y() == 5.0);\n\tCHECK(cone.Location().Z() == 0.0);\n\tauto xAxis = cone.XAxis();\n\tauto yAxis = cone.YAxis();\n\tCHECK(xAxis.Direction().X() == Approx(-1.0));\n\tCHECK(yAxis.Direction().Y() == Approx(-1.0));\n\tAMCAX::Transformation3 tr;\n\ttr.SetTranslation(Vector3(1.0, 2.0, 3.0));\n\tcone.Transform(tr);\n\tAxis3 newXAxis = cone.Position().XAxis();\n\tCHECK(newXAxis.Location().X() == 26.0);\n\tCHECK(newXAxis.Location().Y() == 7.0);\n\tCHECK(newXAxis.Location().Z() == 3.0);\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API Cone(const Frame3& frame, double r, double angle)\t @param angle The semi-angle\n\t @param r The reference radius\n\t @param frame The local frame\n\t @brief Construct from a local frame, a reference radius and a semi-angle\n,\n",
      "output": "#include<iostream>\n#include \"catch.hpp\"\n#include <common/FrameT.hpp>\n#include <modeling/MakeFace.hpp>\n#include <common/AxisT.hpp>\n#include <common/FrameT.hpp>\n#include <common/VectorT.hpp>\n#include <math/Cone.hpp>\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"TestCone\", \"[math][Cone]\")\n{\n\tAMCAX::Frame3 frame;\n\tdouble radius = 5.0;\n\tdouble angle = M_PI / 4;\n\tAMCAX::Cone cone(frame, radius, angle);\n\tAMCAX::Point3 apex = cone.Apex();\n\tCHECK(apex.X() == 0.0);\n\tCHECK(apex.Y() == 0.0);\n\tCHECK(apex.Z() == Approx(-5.0));\n\tAMCAX::Axis3 axis = cone.Axis();\n\tstd::cout << axis.Direction().X() << std::endl;\n\tstd::cout << axis.Direction().Y() << std::endl;\n\tstd::cout << axis.Direction().Z() << std::endl;\n\tCHECK(axis.Direction().X() == 0.0);\n\tCHECK(axis.Direction().Y() == 0.0);\n\tCHECK(axis.Direction().Z() == 1.0);\n\tdouble a1, a2, a3, b1, b2, b3, c1, c2, c3, d;\n\tcone.Coefficients(a1, a2, a3, b1, b2, b3, c1, c2, c3, d);\n\tstd::cout << \"a1: \" << a1 << \", a2: \" << a2 << \", a3: \" << a3 << std::endl;\n\tstd::cout << \"b1: \" << b1 << \", b2: \" << b2 << \", b3: \" << b3 << std::endl;\n\tstd::cout << \"c1: \" << c1 << \", c2: \" << c2 << \", c3: \" << c3 << std::endl;\n\tstd::cout << \"d: \" << d << std::endl;\n\tCHECK(a1 == 1.0);\n\tCHECK(a2 == 1.0);\n\tCHECK(a3 == Approx(-1.0));\n\tCHECK(b1 == 0);\n\tCHECK(b2 == 0);\n\tCHECK(b3 == 0);\n\tCHECK(c1 == 0);\n\tCHECK(c2 == 0);\n\tCHECK(c3 == Approx(-5.0));\n\tCHECK(d == -25.0);\n\tCHECK(cone.IsDirect() == true);\n\tCHECK(cone.Location().X() == 0.0);\n\tCHECK(cone.Location().Y() == 0.0);\n\tCHECK(cone.Location().Z() == 0.0);\n\tAMCAX::PointT<double, 3>mirrorPoint(5.0, 0.0, 0.0);\n\tcone.Mirror(mirrorPoint);\n\tauto mirroredLocation = cone.Location();\n\tCHECK(mirroredLocation.X() == 10.0);\n\tCHECK(mirroredLocation.Y() == 0.0);\n\tCHECK(mirroredLocation.Z() == 0.0);\n\tAMCAX::Frame3 coneFrame = cone.Position();\n\tCHECK(frame.Location().X() == 0.0);\n\tCHECK(frame.Location().Y() == 0.0);\n\tCHECK(frame.Location().Z() == 0.0);\n\tCHECK(cone.Radius() == 5.0);\n\tdouble  scaleCone = 2.0;\n\tcone.Scale(cone.Location(), scaleCone);\n\tCHECK(cone.Radius() == radius * 2.0);\n\tdouble semiCone = cone.SemiAngle();\n\tCHECK(semiCone == Approx(0.785398));\n\tconst  Frame3& position = cone.Position();\n\tstd::cout << position.XAxis() << std::endl;\n\tstd::cout << position.YAxis() << std::endl;\n\tDirection3 zDirection(0.0, 0.0, 1.0);\n\tAMCAX::Point3  centerCone(0.0, 0.0, 0.0);\n\tAxis3 zAxis(centerCone, zDirection);\n\tcone.Rotated(zAxis, angle);\n\tAMCAX::Frame3 coneFrame2 = cone.Position();\n\tCHECK(coneFrame.Location().X() == 10.0);\n\tCHECK(coneFrame.Location().Y() == 0.0);\n\tCHECK(coneFrame.Location().Z() == 0.0);\n\tdouble scale = 2.0;\n\tcone.Scale(centerCone, scale);\n\tCHECK(cone.Radius() == radius * 4.0);\n\tdouble semiAngle = cone.SemiAngle();\n\tstd::cout << semiAngle << std::endl;\n\tCHECK(semiAngle == Approx(0.785398));\n\tVectorT<double, 3> translationVector(5.0, 5.0, 0.0);\n\tcone.Translate(translationVector);\n\tCHECK(cone.Location().X() == 25.0);\n\tCHECK(cone.Location().Y() == 5.0);\n\tCHECK(cone.Location().Z() == 0.0);\n\tauto xAxis = cone.XAxis();\n\tauto yAxis = cone.YAxis();\n\tCHECK(xAxis.Direction().X() == Approx(-1.0));\n\tCHECK(yAxis.Direction().Y() == Approx(-1.0));\n\tAMCAX::Transformation3 tr;\n\ttr.SetTranslation(Vector3(1.0, 2.0, 3.0));\n\tcone.Transform(tr);\n\tAxis3 newXAxis = cone.Position().XAxis();\n\tCHECK(newXAxis.Location().X() == 26.0);\n\tCHECK(newXAxis.Location().Y() == 7.0);\n\tCHECK(newXAxis.Location().Z() == 3.0);\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] AMCAX_API double SemiAngle()\t @return The semi-angle\n\t @brief Get the semi-angle\n,\n",
      "output": "#include<iostream>\n#include \"catch.hpp\"\n#include <common/FrameT.hpp>\n#include <modeling/MakeFace.hpp>\n#include <common/AxisT.hpp>\n#include <common/FrameT.hpp>\n#include <common/VectorT.hpp>\n#include <math/Cone.hpp>\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"TestCone\", \"[math][Cone]\")\n{\n\tAMCAX::Frame3 frame;\n\tdouble radius = 5.0;\n\tdouble angle = M_PI / 4;\n\tAMCAX::Cone cone(frame, radius, angle);\n\tAMCAX::Point3 apex = cone.Apex();\n\tCHECK(apex.X() == 0.0);\n\tCHECK(apex.Y() == 0.0);\n\tCHECK(apex.Z() == Approx(-5.0));\n\tAMCAX::Axis3 axis = cone.Axis();\n\tstd::cout << axis.Direction().X() << std::endl;\n\tstd::cout << axis.Direction().Y() << std::endl;\n\tstd::cout << axis.Direction().Z() << std::endl;\n\tCHECK(axis.Direction().X() == 0.0);\n\tCHECK(axis.Direction().Y() == 0.0);\n\tCHECK(axis.Direction().Z() == 1.0);\n\tdouble a1, a2, a3, b1, b2, b3, c1, c2, c3, d;\n\tcone.Coefficients(a1, a2, a3, b1, b2, b3, c1, c2, c3, d);\n\tstd::cout << \"a1: \" << a1 << \", a2: \" << a2 << \", a3: \" << a3 << std::endl;\n\tstd::cout << \"b1: \" << b1 << \", b2: \" << b2 << \", b3: \" << b3 << std::endl;\n\tstd::cout << \"c1: \" << c1 << \", c2: \" << c2 << \", c3: \" << c3 << std::endl;\n\tstd::cout << \"d: \" << d << std::endl;\n\tCHECK(a1 == 1.0);\n\tCHECK(a2 == 1.0);\n\tCHECK(a3 == Approx(-1.0));\n\tCHECK(b1 == 0);\n\tCHECK(b2 == 0);\n\tCHECK(b3 == 0);\n\tCHECK(c1 == 0);\n\tCHECK(c2 == 0);\n\tCHECK(c3 == Approx(-5.0));\n\tCHECK(d == -25.0);\n\tCHECK(cone.IsDirect() == true);\n\tCHECK(cone.Location().X() == 0.0);\n\tCHECK(cone.Location().Y() == 0.0);\n\tCHECK(cone.Location().Z() == 0.0);\n\tAMCAX::PointT<double, 3>mirrorPoint(5.0, 0.0, 0.0);\n\tcone.Mirror(mirrorPoint);\n\tauto mirroredLocation = cone.Location();\n\tCHECK(mirroredLocation.X() == 10.0);\n\tCHECK(mirroredLocation.Y() == 0.0);\n\tCHECK(mirroredLocation.Z() == 0.0);\n\tAMCAX::Frame3 coneFrame = cone.Position();\n\tCHECK(frame.Location().X() == 0.0);\n\tCHECK(frame.Location().Y() == 0.0);\n\tCHECK(frame.Location().Z() == 0.0);\n\tCHECK(cone.Radius() == 5.0);\n\tdouble  scaleCone = 2.0;\n\tcone.Scale(cone.Location(), scaleCone);\n\tCHECK(cone.Radius() == radius * 2.0);\n\tdouble semiCone = cone.SemiAngle();\n\tCHECK(semiCone == Approx(0.785398));\n\tconst  Frame3& position = cone.Position();\n\tstd::cout << position.XAxis() << std::endl;\n\tstd::cout << position.YAxis() << std::endl;\n\tDirection3 zDirection(0.0, 0.0, 1.0);\n\tAMCAX::Point3  centerCone(0.0, 0.0, 0.0);\n\tAxis3 zAxis(centerCone, zDirection);\n\tcone.Rotated(zAxis, angle);\n\tAMCAX::Frame3 coneFrame2 = cone.Position();\n\tCHECK(coneFrame.Location().X() == 10.0);\n\tCHECK(coneFrame.Location().Y() == 0.0);\n\tCHECK(coneFrame.Location().Z() == 0.0);\n\tdouble scale = 2.0;\n\tcone.Scale(centerCone, scale);\n\tCHECK(cone.Radius() == radius * 4.0);\n\tdouble semiAngle = cone.SemiAngle();\n\tstd::cout << semiAngle << std::endl;\n\tCHECK(semiAngle == Approx(0.785398));\n\tVectorT<double, 3> translationVector(5.0, 5.0, 0.0);\n\tcone.Translate(translationVector);\n\tCHECK(cone.Location().X() == 25.0);\n\tCHECK(cone.Location().Y() == 5.0);\n\tCHECK(cone.Location().Z() == 0.0);\n\tauto xAxis = cone.XAxis();\n\tauto yAxis = cone.YAxis();\n\tCHECK(xAxis.Direction().X() == Approx(-1.0));\n\tCHECK(yAxis.Direction().Y() == Approx(-1.0));\n\tAMCAX::Transformation3 tr;\n\ttr.SetTranslation(Vector3(1.0, 2.0, 3.0));\n\tcone.Transform(tr);\n\tAxis3 newXAxis = cone.Position().XAxis();\n\tCHECK(newXAxis.Location().X() == 26.0);\n\tCHECK(newXAxis.Location().Y() == 7.0);\n\tCHECK(newXAxis.Location().Z() == 3.0);\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] AMCAX_API Point3 Apex()\t @return The apex point\n\t @brief Get the apex of the cone\n,\n",
      "output": "#include<iostream>\n#include \"catch.hpp\"\n#include <common/FrameT.hpp>\n#include <modeling/MakeFace.hpp>\n#include <common/AxisT.hpp>\n#include <common/FrameT.hpp>\n#include <common/VectorT.hpp>\n#include <math/Cone.hpp>\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"TestCone\", \"[math][Cone]\")\n{\n\tAMCAX::Frame3 frame;\n\tdouble radius = 5.0;\n\tdouble angle = M_PI / 4;\n\tAMCAX::Cone cone(frame, radius, angle);\n\tAMCAX::Point3 apex = cone.Apex();\n\tCHECK(apex.X() == 0.0);\n\tCHECK(apex.Y() == 0.0);\n\tCHECK(apex.Z() == Approx(-5.0));\n\tAMCAX::Axis3 axis = cone.Axis();\n\tstd::cout << axis.Direction().X() << std::endl;\n\tstd::cout << axis.Direction().Y() << std::endl;\n\tstd::cout << axis.Direction().Z() << std::endl;\n\tCHECK(axis.Direction().X() == 0.0);\n\tCHECK(axis.Direction().Y() == 0.0);\n\tCHECK(axis.Direction().Z() == 1.0);\n\tdouble a1, a2, a3, b1, b2, b3, c1, c2, c3, d;\n\tcone.Coefficients(a1, a2, a3, b1, b2, b3, c1, c2, c3, d);\n\tstd::cout << \"a1: \" << a1 << \", a2: \" << a2 << \", a3: \" << a3 << std::endl;\n\tstd::cout << \"b1: \" << b1 << \", b2: \" << b2 << \", b3: \" << b3 << std::endl;\n\tstd::cout << \"c1: \" << c1 << \", c2: \" << c2 << \", c3: \" << c3 << std::endl;\n\tstd::cout << \"d: \" << d << std::endl;\n\tCHECK(a1 == 1.0);\n\tCHECK(a2 == 1.0);\n\tCHECK(a3 == Approx(-1.0));\n\tCHECK(b1 == 0);\n\tCHECK(b2 == 0);\n\tCHECK(b3 == 0);\n\tCHECK(c1 == 0);\n\tCHECK(c2 == 0);\n\tCHECK(c3 == Approx(-5.0));\n\tCHECK(d == -25.0);\n\tCHECK(cone.IsDirect() == true);\n\tCHECK(cone.Location().X() == 0.0);\n\tCHECK(cone.Location().Y() == 0.0);\n\tCHECK(cone.Location().Z() == 0.0);\n\tAMCAX::PointT<double, 3>mirrorPoint(5.0, 0.0, 0.0);\n\tcone.Mirror(mirrorPoint);\n\tauto mirroredLocation = cone.Location();\n\tCHECK(mirroredLocation.X() == 10.0);\n\tCHECK(mirroredLocation.Y() == 0.0);\n\tCHECK(mirroredLocation.Z() == 0.0);\n\tAMCAX::Frame3 coneFrame = cone.Position();\n\tCHECK(frame.Location().X() == 0.0);\n\tCHECK(frame.Location().Y() == 0.0);\n\tCHECK(frame.Location().Z() == 0.0);\n\tCHECK(cone.Radius() == 5.0);\n\tdouble  scaleCone = 2.0;\n\tcone.Scale(cone.Location(), scaleCone);\n\tCHECK(cone.Radius() == radius * 2.0);\n\tdouble semiCone = cone.SemiAngle();\n\tCHECK(semiCone == Approx(0.785398));\n\tconst  Frame3& position = cone.Position();\n\tstd::cout << position.XAxis() << std::endl;\n\tstd::cout << position.YAxis() << std::endl;\n\tDirection3 zDirection(0.0, 0.0, 1.0);\n\tAMCAX::Point3  centerCone(0.0, 0.0, 0.0);\n\tAxis3 zAxis(centerCone, zDirection);\n\tcone.Rotated(zAxis, angle);\n\tAMCAX::Frame3 coneFrame2 = cone.Position();\n\tCHECK(coneFrame.Location().X() == 10.0);\n\tCHECK(coneFrame.Location().Y() == 0.0);\n\tCHECK(coneFrame.Location().Z() == 0.0);\n\tdouble scale = 2.0;\n\tcone.Scale(centerCone, scale);\n\tCHECK(cone.Radius() == radius * 4.0);\n\tdouble semiAngle = cone.SemiAngle();\n\tstd::cout << semiAngle << std::endl;\n\tCHECK(semiAngle == Approx(0.785398));\n\tVectorT<double, 3> translationVector(5.0, 5.0, 0.0);\n\tcone.Translate(translationVector);\n\tCHECK(cone.Location().X() == 25.0);\n\tCHECK(cone.Location().Y() == 5.0);\n\tCHECK(cone.Location().Z() == 0.0);\n\tauto xAxis = cone.XAxis();\n\tauto yAxis = cone.YAxis();\n\tCHECK(xAxis.Direction().X() == Approx(-1.0));\n\tCHECK(yAxis.Direction().Y() == Approx(-1.0));\n\tAMCAX::Transformation3 tr;\n\ttr.SetTranslation(Vector3(1.0, 2.0, 3.0));\n\tcone.Transform(tr);\n\tAxis3 newXAxis = cone.Position().XAxis();\n\tCHECK(newXAxis.Location().X() == 26.0);\n\tCHECK(newXAxis.Location().Y() == 7.0);\n\tCHECK(newXAxis.Location().Z() == 3.0);\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API Geom3ConicalSurface(const Frame3& frame, double r, double angle)\t @param angle The semi-angle\n\t @param r The reference radius\n\t @param frame The local frame\n\t @brief Construct from a local frame, a reference radius and a semi-angle\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <common/PointT.hpp>\n#include <math/CurveCalculation.hpp>\n#include <geometry/Geom3ConicalSurface.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"case1: Geom3ConicalSurface::CircleD1 1/4 \", \"[math][Geom3ConicalSurface][P1][CircleD1]\") {\n\tDirection3 initialDir(0.0, 0.0, 1.0); \n\tFrame3 defaultFrame3(Point3(1.0, 1.0, 0.0), initialDir);\n\tAMCAX::Geom3ConicalSurface suface(defaultFrame3, 5.0, 1);\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API Geom3BSplineSurface(const Array2<Point3>& pts, const Array2<double>& weights, const std::vector<double>& uKnots, const std::vector<double>& vKnots, const std::vector<int>& uMults, const std::vector<int>& vMults, int uDegree, int vDegree, bool uPeriodic = false, bool vPeriodic = false)\t @param vPeriodic Set whether the surface is periodic along the v direction\n\t @param uPeriodic Set whether the surface is periodic along the u direction\n\t @param vDegree The v degree\n\t @param uDegree The u degree\n\t @param vMults The v multiplicities\n\t @param uMults The u multiplicities\n\t @param vKnots The v knots\n\t @param uKnots The u knots\n\t @param weights The weights\n\t @param pts The poles\n\t @brief Construct a rational B spline surface from poles, knots and multiplicities\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <modeling/MakeFace.hpp>\n#include <geometry/Geom3BSplineSurface.hpp>\n#include <topology/TopoFace.hpp>\n#include <topology/TopoTool.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"bug1: Geom3BSplineSurface::InsertUKnot() \", \"[geometry][Geom3BSplineSurface][fixbug]\") {\n\tTopoFace face;\n\tOCCTIO::OCCTTool::Read(face, INPUT_PATH_PREFIX\"face.brep\");\n\tauto surf = TopoTool::Surface(face);\n\tauto bsp = std::dynamic_pointer_cast<Geom3BSplineSurface>(surf);\n\tbsp->InsertUKnot(0.23, 1, 0.0, true);\n\tbool bWriteresult = OCCTIO::OCCTTool::Write(face, OUTPUT_PATH_PREFIX\"result.brep\");\n\tCHECK(bWriteresult == true);\n}\nTEST_CASE(\"case1: Geom3BSplineSurface::Geom3BSplineSurface() \", \"[geometry][Geom3BSplineSurface][p1]\") {\n\tArray2<Point3> poles(5, 4);\n\tpoles(0, 0).SetCoord(0.0, 0.0, 0.0);\n\tpoles(0, 1).SetCoord(0.0, 1.1, 2.0);\n\tpoles(0, 2).SetCoord(0.0, 2.3, 1.0);\n\tpoles(0, 3).SetCoord(0.0, 3.1, 1.5);\n\tpoles(1, 0).SetCoord(1.1, 0.1, 2.0);\n\tpoles(1, 1).SetCoord(1.2, 1.0, 0.0);\n\tpoles(1, 2).SetCoord(1.3, 2.1, -1.0);\n\tpoles(1, 3).SetCoord(1.23, 3.04, 1.32);\n\tpoles(2, 0).SetCoord(2.3, 0.1, -2.0);\n\tpoles(2, 1).SetCoord(2.1, 1.4, 2.0);\n\tpoles(2, 2).SetCoord(2.2, 2.1, 1.0);\n\tpoles(2, 3).SetCoord(2.23, 3.22, 1.26);\n\tpoles(3, 0).SetCoord(3.13, 0.2, 0.0);\n\tpoles(3, 1).SetCoord(3.12, 1.1, 0.0);\n\tpoles(3, 2).SetCoord(3.21, 2.1, 1.0);\n\tpoles(3, 3).SetCoord(3.33, 3.21, -1.2);\n\tpoles(4, 0).SetCoord(4.9, 4.93, 0.31);\n\tpoles(4, 1).SetCoord(5.3, 4.73, 0.33);\n\tpoles(4, 2).SetCoord(5.1, 4.43, -1.31);\n\tpoles(4, 3).SetCoord(9.2, 4.65, 3.31);\n\tstd::vector<double> uknots = { 0.0, 0.5, 1.0 };\n\tstd::vector<int> umults = { 4, 1, 4 };\n\tstd::vector<double> vknots = { 0.0, 0.5, 1.0 };\n\tstd::vector<int> vmults = { 3, 1, 3 };\n\tstd::shared_ptr<Geom3BSplineSurface> s = std::make_shared<Geom3BSplineSurface>(poles, uknots, vknots, umults, vmults, 3, 2);\n\tTopoFace face = MakeFace(s,0.001);\n\tbool bWriteresult = OCCTIO::OCCTTool::Write(face, OUTPUT_PATH_PREFIX\"Geom3BSplineSurface_case1.brep\");\n\tCHECK(bWriteresult == true);\n\tAMCAX::GlobalProperty prop;\n\tAMCAX::BRepGlobalProperty::SurfaceProperties(face, prop);\n\tCHECK(prop.Mass() == Approx( 21.3633));\n}\n#include<catch.hpp>\n#include<testHelper.h>\n#include <modeling/MakeFace.hpp>\n#include <geometry/Geom3BSplineSurface.hpp>\n#include <topology/TopoFace.hpp>\n#include <topology/TopoTool.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"bug1: Geom3BSplineSurface::InsertUKnot() \", \"[geometry][Geom3BSplineSurface][fixbug]\") {\n\tTopoFace face;\n\tOCCTIO::OCCTTool::Read(face, INPUT_PATH_PREFIX\"face.brep\");\n\tauto surf = TopoTool::Surface(face);\n\tauto bsp = std::dynamic_pointer_cast<Geom3BSplineSurface>(surf);\n\tbsp->InsertUKnot(0.23, 1, 0.0, true);\n\tbool bWriteresult = OCCTIO::OCCTTool::Write(face, OUTPUT_PATH_PREFIX\"result.brep\");\n\tCHECK(bWriteresult == true);\n}\nTEST_CASE(\"case1: Geom3BSplineSurface::Geom3BSplineSurface() \", \"[geometry][Geom3BSplineSurface][p1]\") {\n\tArray2<Point3> poles(5, 4);\n\tpoles(0, 0).SetCoord(0.0, 0.0, 0.0);\n\tpoles(0, 1).SetCoord(0.0, 1.1, 2.0);\n\tpoles(0, 2).SetCoord(0.0, 2.3, 1.0);\n\tpoles(0, 3).SetCoord(0.0, 3.1, 1.5);\n\tpoles(1, 0).SetCoord(1.1, 0.1, 2.0);\n\tpoles(1, 1).SetCoord(1.2, 1.0, 0.0);\n\tpoles(1, 2).SetCoord(1.3, 2.1, -1.0);\n\tpoles(1, 3).SetCoord(1.23, 3.04, 1.32);\n\tpoles(2, 0).SetCoord(2.3, 0.1, -2.0);\n\tpoles(2, 1).SetCoord(2.1, 1.4, 2.0);\n\tpoles(2, 2).SetCoord(2.2, 2.1, 1.0);\n\tpoles(2, 3).SetCoord(2.23, 3.22, 1.26);\n\tpoles(3, 0).SetCoord(3.13, 0.2, 0.0);\n\tpoles(3, 1).SetCoord(3.12, 1.1, 0.0);\n\tpoles(3, 2).SetCoord(3.21, 2.1, 1.0);\n\tpoles(3, 3).SetCoord(3.33, 3.21, -1.2);\n\tpoles(4, 0).SetCoord(4.9, 4.93, 0.31);\n\tpoles(4, 1).SetCoord(5.3, 4.73, 0.33);\n\tpoles(4, 2).SetCoord(5.1, 4.43, -1.31);\n\tpoles(4, 3).SetCoord(9.2, 4.65, 3.31);\n\tstd::vector<double> uknots = { 0.0, 0.5, 1.0 };\n\tstd::vector<int> umults = { 4, 1, 4 };\n\tstd::vector<double> vknots = { 0.0, 0.5, 1.0 };\n\tstd::vector<int> vmults = { 3, 1, 3 };\n\tstd::shared_ptr<Geom3BSplineSurface> s = std::make_shared<Geom3BSplineSurface>(poles, uknots, vknots, umults, vmults, 3, 2);\n\tTopoFace face = MakeFace(s,0.001);\n\tbool bWriteresult = OCCTIO::OCCTTool::Write(face, OUTPUT_PATH_PREFIX\"Geom3BSplineSurface_case1.brep\");\n\tCHECK(bWriteresult == true);\n\tAMCAX::GlobalProperty prop;\n\tAMCAX::BRepGlobalProperty::SurfaceProperties(face, prop);\n\tCHECK(prop.Mass() == Approx( 21.3633));\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API Geom3BSplineSurface(const Array2<Point3>& pts, const std::vector<double>& uKnots, const std::vector<double>& vKnots, const std::vector<int>& uMults, const std::vector<int>& vMults, int uDegree, int vDegree, bool uPeriodic = false, bool vPeriodic = false)\t @param vPeriodic Set whether the surface is periodic along the v direction\n\t @param uPeriodic Set whether the surface is periodic along the u direction\n\t @param vDegree The v degree\n\t @param uDegree The u degree\n\t @param vMults The v multiplicities\n\t @param uMults The u multiplicities\n\t @param vKnots The v knots\n\t @param uKnots The u knots\n\t @param pts The poles\n\t @brief Construct a B spline surface from poles, knots and multiplicities\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <modeling/MakeFace.hpp>\n#include <geometry/Geom3BSplineSurface.hpp>\n#include <topology/TopoFace.hpp>\n#include <topology/TopoTool.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"bug1: Geom3BSplineSurface::InsertUKnot() \", \"[geometry][Geom3BSplineSurface][fixbug]\") {\n\tTopoFace face;\n\tOCCTIO::OCCTTool::Read(face, INPUT_PATH_PREFIX\"face.brep\");\n\tauto surf = TopoTool::Surface(face);\n\tauto bsp = std::dynamic_pointer_cast<Geom3BSplineSurface>(surf);\n\tbsp->InsertUKnot(0.23, 1, 0.0, true);\n\tbool bWriteresult = OCCTIO::OCCTTool::Write(face, OUTPUT_PATH_PREFIX\"result.brep\");\n\tCHECK(bWriteresult == true);\n}\nTEST_CASE(\"case1: Geom3BSplineSurface::Geom3BSplineSurface() \", \"[geometry][Geom3BSplineSurface][p1]\") {\n\tArray2<Point3> poles(5, 4);\n\tpoles(0, 0).SetCoord(0.0, 0.0, 0.0);\n\tpoles(0, 1).SetCoord(0.0, 1.1, 2.0);\n\tpoles(0, 2).SetCoord(0.0, 2.3, 1.0);\n\tpoles(0, 3).SetCoord(0.0, 3.1, 1.5);\n\tpoles(1, 0).SetCoord(1.1, 0.1, 2.0);\n\tpoles(1, 1).SetCoord(1.2, 1.0, 0.0);\n\tpoles(1, 2).SetCoord(1.3, 2.1, -1.0);\n\tpoles(1, 3).SetCoord(1.23, 3.04, 1.32);\n\tpoles(2, 0).SetCoord(2.3, 0.1, -2.0);\n\tpoles(2, 1).SetCoord(2.1, 1.4, 2.0);\n\tpoles(2, 2).SetCoord(2.2, 2.1, 1.0);\n\tpoles(2, 3).SetCoord(2.23, 3.22, 1.26);\n\tpoles(3, 0).SetCoord(3.13, 0.2, 0.0);\n\tpoles(3, 1).SetCoord(3.12, 1.1, 0.0);\n\tpoles(3, 2).SetCoord(3.21, 2.1, 1.0);\n\tpoles(3, 3).SetCoord(3.33, 3.21, -1.2);\n\tpoles(4, 0).SetCoord(4.9, 4.93, 0.31);\n\tpoles(4, 1).SetCoord(5.3, 4.73, 0.33);\n\tpoles(4, 2).SetCoord(5.1, 4.43, -1.31);\n\tpoles(4, 3).SetCoord(9.2, 4.65, 3.31);\n\tstd::vector<double> uknots = { 0.0, 0.5, 1.0 };\n\tstd::vector<int> umults = { 4, 1, 4 };\n\tstd::vector<double> vknots = { 0.0, 0.5, 1.0 };\n\tstd::vector<int> vmults = { 3, 1, 3 };\n\tstd::shared_ptr<Geom3BSplineSurface> s = std::make_shared<Geom3BSplineSurface>(poles, uknots, vknots, umults, vmults, 3, 2);\n\tTopoFace face = MakeFace(s,0.001);\n\tbool bWriteresult = OCCTIO::OCCTTool::Write(face, OUTPUT_PATH_PREFIX\"Geom3BSplineSurface_case1.brep\");\n\tCHECK(bWriteresult == true);\n\tAMCAX::GlobalProperty prop;\n\tAMCAX::BRepGlobalProperty::SurfaceProperties(face, prop);\n\tCHECK(prop.Mass() == Approx( 21.3633));\n}\n#include<catch.hpp>\n#include<testHelper.h>\n#include <modeling/MakeFace.hpp>\n#include <geometry/Geom3BSplineSurface.hpp>\n#include <topology/TopoFace.hpp>\n#include <topology/TopoTool.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"bug1: Geom3BSplineSurface::InsertUKnot() \", \"[geometry][Geom3BSplineSurface][fixbug]\") {\n\tTopoFace face;\n\tOCCTIO::OCCTTool::Read(face, INPUT_PATH_PREFIX\"face.brep\");\n\tauto surf = TopoTool::Surface(face);\n\tauto bsp = std::dynamic_pointer_cast<Geom3BSplineSurface>(surf);\n\tbsp->InsertUKnot(0.23, 1, 0.0, true);\n\tbool bWriteresult = OCCTIO::OCCTTool::Write(face, OUTPUT_PATH_PREFIX\"result.brep\");\n\tCHECK(bWriteresult == true);\n}\nTEST_CASE(\"case1: Geom3BSplineSurface::Geom3BSplineSurface() \", \"[geometry][Geom3BSplineSurface][p1]\") {\n\tArray2<Point3> poles(5, 4);\n\tpoles(0, 0).SetCoord(0.0, 0.0, 0.0);\n\tpoles(0, 1).SetCoord(0.0, 1.1, 2.0);\n\tpoles(0, 2).SetCoord(0.0, 2.3, 1.0);\n\tpoles(0, 3).SetCoord(0.0, 3.1, 1.5);\n\tpoles(1, 0).SetCoord(1.1, 0.1, 2.0);\n\tpoles(1, 1).SetCoord(1.2, 1.0, 0.0);\n\tpoles(1, 2).SetCoord(1.3, 2.1, -1.0);\n\tpoles(1, 3).SetCoord(1.23, 3.04, 1.32);\n\tpoles(2, 0).SetCoord(2.3, 0.1, -2.0);\n\tpoles(2, 1).SetCoord(2.1, 1.4, 2.0);\n\tpoles(2, 2).SetCoord(2.2, 2.1, 1.0);\n\tpoles(2, 3).SetCoord(2.23, 3.22, 1.26);\n\tpoles(3, 0).SetCoord(3.13, 0.2, 0.0);\n\tpoles(3, 1).SetCoord(3.12, 1.1, 0.0);\n\tpoles(3, 2).SetCoord(3.21, 2.1, 1.0);\n\tpoles(3, 3).SetCoord(3.33, 3.21, -1.2);\n\tpoles(4, 0).SetCoord(4.9, 4.93, 0.31);\n\tpoles(4, 1).SetCoord(5.3, 4.73, 0.33);\n\tpoles(4, 2).SetCoord(5.1, 4.43, -1.31);\n\tpoles(4, 3).SetCoord(9.2, 4.65, 3.31);\n\tstd::vector<double> uknots = { 0.0, 0.5, 1.0 };\n\tstd::vector<int> umults = { 4, 1, 4 };\n\tstd::vector<double> vknots = { 0.0, 0.5, 1.0 };\n\tstd::vector<int> vmults = { 3, 1, 3 };\n\tstd::shared_ptr<Geom3BSplineSurface> s = std::make_shared<Geom3BSplineSurface>(poles, uknots, vknots, umults, vmults, 3, 2);\n\tTopoFace face = MakeFace(s,0.001);\n\tbool bWriteresult = OCCTIO::OCCTTool::Write(face, OUTPUT_PATH_PREFIX\"Geom3BSplineSurface_case1.brep\");\n\tCHECK(bWriteresult == true);\n\tAMCAX::GlobalProperty prop;\n\tAMCAX::BRepGlobalProperty::SurfaceProperties(face, prop);\n\tCHECK(prop.Mass() == Approx( 21.3633));\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API Geom3BSplineSurface()\t @details A default surface is a unit square\n\t @brief Default constructor\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <modeling/MakeFace.hpp>\n#include <geometry/Geom3BSplineSurface.hpp>\n#include <topology/TopoFace.hpp>\n#include <topology/TopoTool.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"bug1: Geom3BSplineSurface::InsertUKnot() \", \"[geometry][Geom3BSplineSurface][fixbug]\") {\n\tTopoFace face;\n\tOCCTIO::OCCTTool::Read(face, INPUT_PATH_PREFIX\"face.brep\");\n\tauto surf = TopoTool::Surface(face);\n\tauto bsp = std::dynamic_pointer_cast<Geom3BSplineSurface>(surf);\n\tbsp->InsertUKnot(0.23, 1, 0.0, true);\n\tbool bWriteresult = OCCTIO::OCCTTool::Write(face, OUTPUT_PATH_PREFIX\"result.brep\");\n\tCHECK(bWriteresult == true);\n}\nTEST_CASE(\"case1: Geom3BSplineSurface::Geom3BSplineSurface() \", \"[geometry][Geom3BSplineSurface][p1]\") {\n\tArray2<Point3> poles(5, 4);\n\tpoles(0, 0).SetCoord(0.0, 0.0, 0.0);\n\tpoles(0, 1).SetCoord(0.0, 1.1, 2.0);\n\tpoles(0, 2).SetCoord(0.0, 2.3, 1.0);\n\tpoles(0, 3).SetCoord(0.0, 3.1, 1.5);\n\tpoles(1, 0).SetCoord(1.1, 0.1, 2.0);\n\tpoles(1, 1).SetCoord(1.2, 1.0, 0.0);\n\tpoles(1, 2).SetCoord(1.3, 2.1, -1.0);\n\tpoles(1, 3).SetCoord(1.23, 3.04, 1.32);\n\tpoles(2, 0).SetCoord(2.3, 0.1, -2.0);\n\tpoles(2, 1).SetCoord(2.1, 1.4, 2.0);\n\tpoles(2, 2).SetCoord(2.2, 2.1, 1.0);\n\tpoles(2, 3).SetCoord(2.23, 3.22, 1.26);\n\tpoles(3, 0).SetCoord(3.13, 0.2, 0.0);\n\tpoles(3, 1).SetCoord(3.12, 1.1, 0.0);\n\tpoles(3, 2).SetCoord(3.21, 2.1, 1.0);\n\tpoles(3, 3).SetCoord(3.33, 3.21, -1.2);\n\tpoles(4, 0).SetCoord(4.9, 4.93, 0.31);\n\tpoles(4, 1).SetCoord(5.3, 4.73, 0.33);\n\tpoles(4, 2).SetCoord(5.1, 4.43, -1.31);\n\tpoles(4, 3).SetCoord(9.2, 4.65, 3.31);\n\tstd::vector<double> uknots = { 0.0, 0.5, 1.0 };\n\tstd::vector<int> umults = { 4, 1, 4 };\n\tstd::vector<double> vknots = { 0.0, 0.5, 1.0 };\n\tstd::vector<int> vmults = { 3, 1, 3 };\n\tstd::shared_ptr<Geom3BSplineSurface> s = std::make_shared<Geom3BSplineSurface>(poles, uknots, vknots, umults, vmults, 3, 2);\n\tTopoFace face = MakeFace(s,0.001);\n\tbool bWriteresult = OCCTIO::OCCTTool::Write(face, OUTPUT_PATH_PREFIX\"Geom3BSplineSurface_case1.brep\");\n\tCHECK(bWriteresult == true);\n\tAMCAX::GlobalProperty prop;\n\tAMCAX::BRepGlobalProperty::SurfaceProperties(face, prop);\n\tCHECK(prop.Mass() == Approx( 21.3633));\n}\n#include<catch.hpp>\n#include<testHelper.h>\n#include <modeling/MakeFace.hpp>\n#include <geometry/Geom3BSplineSurface.hpp>\n#include <topology/TopoFace.hpp>\n#include <topology/TopoTool.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"bug1: Geom3BSplineSurface::InsertUKnot() \", \"[geometry][Geom3BSplineSurface][fixbug]\") {\n\tTopoFace face;\n\tOCCTIO::OCCTTool::Read(face, INPUT_PATH_PREFIX\"face.brep\");\n\tauto surf = TopoTool::Surface(face);\n\tauto bsp = std::dynamic_pointer_cast<Geom3BSplineSurface>(surf);\n\tbsp->InsertUKnot(0.23, 1, 0.0, true);\n\tbool bWriteresult = OCCTIO::OCCTTool::Write(face, OUTPUT_PATH_PREFIX\"result.brep\");\n\tCHECK(bWriteresult == true);\n}\nTEST_CASE(\"case1: Geom3BSplineSurface::Geom3BSplineSurface() \", \"[geometry][Geom3BSplineSurface][p1]\") {\n\tArray2<Point3> poles(5, 4);\n\tpoles(0, 0).SetCoord(0.0, 0.0, 0.0);\n\tpoles(0, 1).SetCoord(0.0, 1.1, 2.0);\n\tpoles(0, 2).SetCoord(0.0, 2.3, 1.0);\n\tpoles(0, 3).SetCoord(0.0, 3.1, 1.5);\n\tpoles(1, 0).SetCoord(1.1, 0.1, 2.0);\n\tpoles(1, 1).SetCoord(1.2, 1.0, 0.0);\n\tpoles(1, 2).SetCoord(1.3, 2.1, -1.0);\n\tpoles(1, 3).SetCoord(1.23, 3.04, 1.32);\n\tpoles(2, 0).SetCoord(2.3, 0.1, -2.0);\n\tpoles(2, 1).SetCoord(2.1, 1.4, 2.0);\n\tpoles(2, 2).SetCoord(2.2, 2.1, 1.0);\n\tpoles(2, 3).SetCoord(2.23, 3.22, 1.26);\n\tpoles(3, 0).SetCoord(3.13, 0.2, 0.0);\n\tpoles(3, 1).SetCoord(3.12, 1.1, 0.0);\n\tpoles(3, 2).SetCoord(3.21, 2.1, 1.0);\n\tpoles(3, 3).SetCoord(3.33, 3.21, -1.2);\n\tpoles(4, 0).SetCoord(4.9, 4.93, 0.31);\n\tpoles(4, 1).SetCoord(5.3, 4.73, 0.33);\n\tpoles(4, 2).SetCoord(5.1, 4.43, -1.31);\n\tpoles(4, 3).SetCoord(9.2, 4.65, 3.31);\n\tstd::vector<double> uknots = { 0.0, 0.5, 1.0 };\n\tstd::vector<int> umults = { 4, 1, 4 };\n\tstd::vector<double> vknots = { 0.0, 0.5, 1.0 };\n\tstd::vector<int> vmults = { 3, 1, 3 };\n\tstd::shared_ptr<Geom3BSplineSurface> s = std::make_shared<Geom3BSplineSurface>(poles, uknots, vknots, umults, vmults, 3, 2);\n\tTopoFace face = MakeFace(s,0.001);\n\tbool bWriteresult = OCCTIO::OCCTTool::Write(face, OUTPUT_PATH_PREFIX\"Geom3BSplineSurface_case1.brep\");\n\tCHECK(bWriteresult == true);\n\tAMCAX::GlobalProperty prop;\n\tAMCAX::BRepGlobalProperty::SurfaceProperties(face, prop);\n\tCHECK(prop.Mass() == Approx( 21.3633));\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API Geom3BSplineCurve(const std::vector<Point3>& pts, const std::vector<double>& weights, const std::vector<double>& knots, const std::vector<int>& multiplicities, int degree, bool isPeriodic = false, bool checkRational = true)\t @param checkRational To check whether the weights are rational\n\t @param isPeriodic Set the curve is periodic or not\n\t @param degree The degree of curve\n\t @param multiplicities The multiplicities\n\t @param knots The knots\n\t @param weights The weights\n\t @param pts The points\n\t @brief Construct a rational B spline curve from point, weights, knots and multiplicities with a given degree\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/Geom3BSplineCurve.hpp>\n#include <geometry/Geom3BSplineSurface.hpp>\n#include <topology/TopoFace.hpp>\n#include <topology/TopoTool.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"bug1: Geom3BSplineCurve \", \"[geometry][Geom3BSplineCurve][fixbug]\") {\n\tstd::stringstream output1,output2;\n\tstd::vector<Point3> poles{ Point3(0.0, 0.0, 0.0), Point3(0.0, 1.0, 0.0), Point3(0.0, 2.0, 0.0), Point3(0.0, 3.0, 0.0), Point3(0.0, 4.0, 0.0) };\n\tstd::vector<double> knots{ 0.0, 1.0, 2.0, 3.0 };\n\tstd::vector<int> mults{ 2, 2, 2, 2 };\n\tauto bc = std::make_shared<Geom3BSplineCurve>(poles, knots, mults, 2);\n\tdouble last = bc->LastParameter();\n\tstd::cout << bc->Value(last) << '\n';\n\tstd::cout << bc->DN(last, 0) << '\n';\n\toutput1 << bc->Value(last) << '\n';\n\toutput2 << bc->DN(last, 0) << '\n';\n\tauto case1 = output1.str();\n\tauto case2 = output2.str();\n\tauto expectValue = \"0 3 0\";\n\tauto expectDN = \"0 3 0\";\n\tCHECK(case1.find(expectValue) != std::string::npos);\n\tCHECK(case2.find(expectDN) != std::string::npos);\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API Geom3BSplineCurve(const std::vector<Point3>& pts, const std::vector<double>& knots, const std::vector<int>& multiplicities, int degree, bool isPeriodic = false)\t @param isPeriodic Set the curve is periodic or not\n\t @param degree The degree of curve\n\t @param multiplicities The multiplicities\n\t @param knots The knots\n\t @param pts The points\n\t @brief Construct a B spline curve from points, knots and multiplicities with a given degree\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/Geom3BSplineCurve.hpp>\n#include <geometry/Geom3BSplineSurface.hpp>\n#include <topology/TopoFace.hpp>\n#include <topology/TopoTool.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"bug1: Geom3BSplineCurve \", \"[geometry][Geom3BSplineCurve][fixbug]\") {\n\tstd::stringstream output1,output2;\n\tstd::vector<Point3> poles{ Point3(0.0, 0.0, 0.0), Point3(0.0, 1.0, 0.0), Point3(0.0, 2.0, 0.0), Point3(0.0, 3.0, 0.0), Point3(0.0, 4.0, 0.0) };\n\tstd::vector<double> knots{ 0.0, 1.0, 2.0, 3.0 };\n\tstd::vector<int> mults{ 2, 2, 2, 2 };\n\tauto bc = std::make_shared<Geom3BSplineCurve>(poles, knots, mults, 2);\n\tdouble last = bc->LastParameter();\n\tstd::cout << bc->Value(last) << '\n';\n\tstd::cout << bc->DN(last, 0) << '\n';\n\toutput1 << bc->Value(last) << '\n';\n\toutput2 << bc->DN(last, 0) << '\n';\n\tauto case1 = output1.str();\n\tauto case2 = output2.str();\n\tauto expectValue = \"0 3 0\";\n\tauto expectDN = \"0 3 0\";\n\tCHECK(case1.find(expectValue) != std::string::npos);\n\tCHECK(case2.find(expectDN) != std::string::npos);\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API Geom2Parabola(const Axis2& axis, double focal, bool isRight = true)\t @param isRight Is the local frame right-handed\n\t @param focal The focal length\n\t @param axis The axis\n\t @brief Construct from an axis and a focal length\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <geometry/Geom2Parabola.hpp>\nusing namespace AMCAX;\nusing namespace std;\n#include <catch.hpp>\n#include <testHelper.h>\n#include <geometry/Geom2Parabola.hpp>\nusing namespace AMCAX;\nusing namespace std;\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API Geom2Hyperbola(const Frame2& frame, double major, double minor)\t @param minor The minor radius\n\t @param major The major radius\n\t @param frame The local frame\n\t @brief Construct from a local frame, a major radius and a minor radius\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <math/EllipseT.hpp>\n#include <geometry/Geom2Hyperbola.hpp>\nusing namespace AMCAX;\nusing namespace std;\n#include <catch.hpp>\n#include <testHelper.h>\n#include <math/EllipseT.hpp>\n#include <geometry/Geom2Hyperbola.hpp>\nusing namespace AMCAX;\nusing namespace std;\n;\n\tSECTION(\"FocalParameter\")\n\t{\n\t\tdouble FP = g2h.FocalParameter();\n\t\tdouble focal = 2 * sqrt(major * major + minor * minor);\n\t\tdouble fp = 2 * minor * minor / focal;;\n\t\tCHECK(FP == fp);\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API Geom3Parabola(const Axis3& directrix, const Point3& focus)\t @param focus The focus\n\t @param directrix The directrix\n\t @brief Construct from a directrix and a focus\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <geometry/Geom3Parabola.hpp>\nusing namespace AMCAX;\nusing namespace std;\n#include <catch.hpp>\n#include <testHelper.h>\n#include <geometry/Geom3Parabola.hpp>\nusing namespace AMCAX;\nusing namespace std;\n;\n\tSECTION(\"SemilatusRectum\")\n\t{\n\t\tdouble SR = g3p.SemilatusRectum();\n\t\tdouble sr = 2 * focal;\n\t\tCHECK(SR == sr);\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API Geom3Parabola(const Frame3& frame, double focal)\t @param focal The focal length\n\t @param frame The local frame\n\t @brief Construct from a local frame and a focal length\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <geometry/Geom3Parabola.hpp>\nusing namespace AMCAX;\nusing namespace std;\n#include <catch.hpp>\n#include <testHelper.h>\n#include <geometry/Geom3Parabola.hpp>\nusing namespace AMCAX;\nusing namespace std;\n;\n\tSECTION(\"FocalParameter\")\n\t{\n\t\tdouble FP = g3p.FocalParameter();\n\t\tdouble fp = 2 * focal;\n\t\tCHECK(FP == fp);\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "Geom3Parabola()\t @brief Default constructor\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <geometry/Geom3Parabola.hpp>\nusing namespace AMCAX;\nusing namespace std;\n#include <catch.hpp>\n#include <testHelper.h>\n#include <geometry/Geom3Parabola.hpp>\nusing namespace AMCAX;\nusing namespace std;\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] AMCAX_API double SemilatusRectum()\t @return The semilatus rectum\n\t          Semilatus rectum = 2 * focalLength\n\t @details The semilatus rectum of parabola is half of the length of the chord through a focus parallel to the directrix.\n\t @brief Get the semilatus rectum of the parabola\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <geometry/Geom3Parabola.hpp>\nusing namespace AMCAX;\nusing namespace std;\n#include <catch.hpp>\n#include <testHelper.h>\n#include <geometry/Geom3Parabola.hpp>\nusing namespace AMCAX;\nusing namespace std;\n;\n\tSECTION(\"SemilatusRectum\")\n\t{\n\t\tdouble SR = g3p.SemilatusRectum();\n\t\tdouble sr = 2 * focal;\n\t\tCHECK(SR == sr);\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API Geom2Ellipse(const Axis2& majorAxis, double major, double minor, bool isRight)\t @param isRight Is the local frame right-handed\n\t @param minor The minor radius\n\t @param major The major radius\n\t @param majorAxis The axis\n\t @brief Construct from an axis, a major radius and a minor radius\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <math/EllipseT.hpp>\n#include <geometry/Geom2Ellipse.hpp>\nusing namespace AMCAX;\nusing namespace std;\n#include <catch.hpp>\n#include <testHelper.h>\n#include <math/EllipseT.hpp>\n#include <geometry/Geom2Ellipse.hpp>\nusing namespace AMCAX;\nusing namespace std;\n;\n\tSECTION(\"SemilatusRectum\")\n\t{\n\t\tdouble SR = g2e.SemilatusRectum();\n\t\tdouble sr = minor * minor / major;\n\t\tCHECK(SR == sr);\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API double Parameter()\t @return The parameter of the point\n\t @brief Get the parameter of the point\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/MakeGeom2Circle.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/ComputePointsAbscissa.hpp>\n#include <geometry/MakeGeom2Hyperbola.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/MakeGeom2Ellipse.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/AdaptorGeom3Curve.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <geometry/MakeGeom3Hyperbola.hpp>\n#include <geometry/MakeGeom3Ellipse.hpp>\nTEST_CASE(\"bug1: ComputePointsAbscissa \", \"[geometry][ComputePointsAbscissa][fixbug]\")\n{\n    double r = 0.0;\n    std::shared_ptr<Geom2Curve> c = MakeGeom2Circle(Point2(0.0, 0.0), 0.0).Value();\n    AdaptorGeom2Curve circle(c);\n    ComputePointsAbscissa cpa(circle, 0.0, 0.0);\n    double angle1 = 0;\n    double x = r * cos(angle1);\n    double y = r * sin(angle1);\n    double param = cpa.Parameter();\n    Point2 s = circle.Value(param);\n    Point2 s1(x, y);\n    CHECK(angle1 == cpa.Parameter());\n    CHECK(s.X() == s1.X());\n    CHECK(s.Y() == s1.Y());\n    CHECK(ComputePointsAbscissa::Length(circle) == 0.0);\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API ComputePointsAbscissa(const Adaptor2Curve& c, double abscissa, double u0, double ui, double tol)\t @param tol The tolerance\n\t @param ui The initial guess of the parameter\n\t @param u0 The starting parameter\n\t @param abscissa The arc length\n\t @param c The curve\n\t @brief Compute the parameter of a point on a 2D curve with given arc length, an initial guess, and a tolerance\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/MakeGeom2Circle.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/ComputePointsAbscissa.hpp>\n#include <geometry/MakeGeom2Hyperbola.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/MakeGeom2Ellipse.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/AdaptorGeom3Curve.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <geometry/MakeGeom3Hyperbola.hpp>\n#include <geometry/MakeGeom3Ellipse.hpp>\n#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/MakeGeom2Circle.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/ComputePointsAbscissa.hpp>\n#include <geometry/MakeGeom2Hyperbola.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/MakeGeom2Ellipse.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/AdaptorGeom3Curve.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <geometry/MakeGeom3Hyperbola.hpp>\n#include <geometry/MakeGeom3Ellipse.hpp>\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API ComputePointsAbscissa(const Adaptor3Curve& c, double abscissa, double u0, double ui, double tol)\t @param tol The tolerance\n\t @param ui The initial guess of the parameter\n\t @param u0 The starting parameter\n\t @param abscissa The arc length\n\t @param c The curve\n\t @brief Compute the parameter of a point on a 3D curve with given arc length, an initial guess, and a tolerance\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/MakeGeom2Circle.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/ComputePointsAbscissa.hpp>\n#include <geometry/MakeGeom2Hyperbola.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/MakeGeom2Ellipse.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/AdaptorGeom3Curve.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <geometry/MakeGeom3Hyperbola.hpp>\n#include <geometry/MakeGeom3Ellipse.hpp>\nTEST_CASE(\"bug1: ComputePointsAbscissa \", \"[geometry][ComputePointsAbscissa][fixbug]\")\n{\n    double r = 0.0;\n    std::shared_ptr<Geom2Curve> c = MakeGeom2Circle(Point2(0.0, 0.0), 0.0).Value();\n    AdaptorGeom2Curve circle(c);\n    ComputePointsAbscissa cpa(circle, 0.0, 0.0);\n    double angle1 = 0;\n    double x = r * cos(angle1);\n    double y = r * sin(angle1);\n    double param = cpa.Parameter();\n    Point2 s = circle.Value(param);\n    Point2 s1(x, y);\n    CHECK(angle1 == cpa.Parameter());\n    CHECK(s.X() == s1.X());\n    CHECK(s.Y() == s1.Y());\n    CHECK(ComputePointsAbscissa::Length(circle) == 0.0);\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API ComputePointsAbscissa(const Adaptor2Curve& c, double abscissa, double u0, double ui)\t @param ui The initial guess of the parameter\n\t @param u0 The starting parameter\n\t @param abscissa The arc length\n\t @param c The curve\n\t @brief Compute the parameter of a point on a 2D curve with given arc length and an initial guess\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/MakeGeom2Circle.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/ComputePointsAbscissa.hpp>\n#include <geometry/MakeGeom2Hyperbola.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/MakeGeom2Ellipse.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/AdaptorGeom3Curve.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <geometry/MakeGeom3Hyperbola.hpp>\n#include <geometry/MakeGeom3Ellipse.hpp>\nTEST_CASE(\"bug1: ComputePointsAbscissa \", \"[geometry][ComputePointsAbscissa][fixbug]\")\n{\n    double r = 0.0;\n    std::shared_ptr<Geom2Curve> c = MakeGeom2Circle(Point2(0.0, 0.0), 0.0).Value();\n    AdaptorGeom2Curve circle(c);\n    ComputePointsAbscissa cpa(circle, 0.0, 0.0);\n    double angle1 = 0;\n    double x = r * cos(angle1);\n    double y = r * sin(angle1);\n    double param = cpa.Parameter();\n    Point2 s = circle.Value(param);\n    Point2 s1(x, y);\n    CHECK(angle1 == cpa.Parameter());\n    CHECK(s.X() == s1.X());\n    CHECK(s.Y() == s1.Y());\n    CHECK(ComputePointsAbscissa::Length(circle) == 0.0);\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API ComputePointsAbscissa(const Adaptor3Curve& c, double abscissa, double u0, double ui)\t @param ui The initial guess of the parameter\n\t @param u0 The starting parameter\n\t @param abscissa The arc length\n\t @param c The curve\n\t @brief Compute the parameter of a point on a 3D curve with given arc length and an initial guess\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/MakeGeom2Circle.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/ComputePointsAbscissa.hpp>\n#include <geometry/MakeGeom2Hyperbola.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/MakeGeom2Ellipse.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/AdaptorGeom3Curve.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <geometry/MakeGeom3Hyperbola.hpp>\n#include <geometry/MakeGeom3Ellipse.hpp>\nTEST_CASE(\"bug1: ComputePointsAbscissa \", \"[geometry][ComputePointsAbscissa][fixbug]\")\n{\n    double r = 0.0;\n    std::shared_ptr<Geom2Curve> c = MakeGeom2Circle(Point2(0.0, 0.0), 0.0).Value();\n    AdaptorGeom2Curve circle(c);\n    ComputePointsAbscissa cpa(circle, 0.0, 0.0);\n    double angle1 = 0;\n    double x = r * cos(angle1);\n    double y = r * sin(angle1);\n    double param = cpa.Parameter();\n    Point2 s = circle.Value(param);\n    Point2 s1(x, y);\n    CHECK(angle1 == cpa.Parameter());\n    CHECK(s.X() == s1.X());\n    CHECK(s.Y() == s1.Y());\n    CHECK(ComputePointsAbscissa::Length(circle) == 0.0);\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API ComputePointsAbscissa(const Adaptor2Curve& c, double abscissa, double u0)\t @param u0 The starting parameter\n\t @param abscissa The arc length\n\t @param c The curve\n\t @brief Compute the parameter of a point on a 2D curve with given arc length\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/MakeGeom2Circle.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/ComputePointsAbscissa.hpp>\n#include <geometry/MakeGeom2Hyperbola.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/MakeGeom2Ellipse.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/AdaptorGeom3Curve.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <geometry/MakeGeom3Hyperbola.hpp>\n#include <geometry/MakeGeom3Ellipse.hpp>\n#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/MakeGeom2Circle.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/ComputePointsAbscissa.hpp>\n#include <geometry/MakeGeom2Hyperbola.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/MakeGeom2Ellipse.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/AdaptorGeom3Curve.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <geometry/MakeGeom3Hyperbola.hpp>\n#include <geometry/MakeGeom3Ellipse.hpp>\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API ComputePointsAbscissa(const Adaptor3Curve& c, double abscissa, double u0)\t @param u0 The starting parameter\n\t @param abscissa The arc length\n\t @param c The curve\n\t @brief Compute the parameter of a point on a 3D curve with given arc length\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/MakeGeom2Circle.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/ComputePointsAbscissa.hpp>\n#include <geometry/MakeGeom2Hyperbola.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/MakeGeom2Ellipse.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/AdaptorGeom3Curve.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <geometry/MakeGeom3Hyperbola.hpp>\n#include <geometry/MakeGeom3Ellipse.hpp>\nTEST_CASE(\"bug1: ComputePointsAbscissa \", \"[geometry][ComputePointsAbscissa][fixbug]\")\n{\n    double r = 0.0;\n    std::shared_ptr<Geom2Curve> c = MakeGeom2Circle(Point2(0.0, 0.0), 0.0).Value();\n    AdaptorGeom2Curve circle(c);\n    ComputePointsAbscissa cpa(circle, 0.0, 0.0);\n    double angle1 = 0;\n    double x = r * cos(angle1);\n    double y = r * sin(angle1);\n    double param = cpa.Parameter();\n    Point2 s = circle.Value(param);\n    Point2 s1(x, y);\n    CHECK(angle1 == cpa.Parameter());\n    CHECK(s.X() == s1.X());\n    CHECK(s.Y() == s1.Y());\n    CHECK(ComputePointsAbscissa::Length(circle) == 0.0);\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API ComputePointsAbscissa(double tol, const Adaptor2Curve& c, double abscissa, double u0)\t @param u0 The starting parameter\n\t @param abscissa The arc length\n\t @param c The curve\n\t @param tol The tolerance\n\t @brief Compute the parameter of a point on a 2D curve with given arc length and a tolerance\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/MakeGeom2Circle.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/ComputePointsAbscissa.hpp>\n#include <geometry/MakeGeom2Hyperbola.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/MakeGeom2Ellipse.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/AdaptorGeom3Curve.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <geometry/MakeGeom3Hyperbola.hpp>\n#include <geometry/MakeGeom3Ellipse.hpp>\nTEST_CASE(\"bug1: ComputePointsAbscissa \", \"[geometry][ComputePointsAbscissa][fixbug]\")\n{\n    double r = 0.0;\n    std::shared_ptr<Geom2Curve> c = MakeGeom2Circle(Point2(0.0, 0.0), 0.0).Value();\n    AdaptorGeom2Curve circle(c);\n    ComputePointsAbscissa cpa(circle, 0.0, 0.0);\n    double angle1 = 0;\n    double x = r * cos(angle1);\n    double y = r * sin(angle1);\n    double param = cpa.Parameter();\n    Point2 s = circle.Value(param);\n    Point2 s1(x, y);\n    CHECK(angle1 == cpa.Parameter());\n    CHECK(s.X() == s1.X());\n    CHECK(s.Y() == s1.Y());\n    CHECK(ComputePointsAbscissa::Length(circle) == 0.0);\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API ComputePointsAbscissa(double tol, const Adaptor3Curve& c, double abscissa, double u0)\t @param u0 The starting parameter\n\t @param abscissa The arc length\n\t @param c The curve\n\t @param tol The tolerance\n\t @brief Compute the parameter of a point on a 3D curve with given arc length and a tolerance\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/MakeGeom2Circle.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/ComputePointsAbscissa.hpp>\n#include <geometry/MakeGeom2Hyperbola.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/MakeGeom2Ellipse.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/AdaptorGeom3Curve.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <geometry/MakeGeom3Hyperbola.hpp>\n#include <geometry/MakeGeom3Ellipse.hpp>\nTEST_CASE(\"bug1: ComputePointsAbscissa \", \"[geometry][ComputePointsAbscissa][fixbug]\")\n{\n    double r = 0.0;\n    std::shared_ptr<Geom2Curve> c = MakeGeom2Circle(Point2(0.0, 0.0), 0.0).Value();\n    AdaptorGeom2Curve circle(c);\n    ComputePointsAbscissa cpa(circle, 0.0, 0.0);\n    double angle1 = 0;\n    double x = r * cos(angle1);\n    double y = r * sin(angle1);\n    double param = cpa.Parameter();\n    Point2 s = circle.Value(param);\n    Point2 s1(x, y);\n    CHECK(angle1 == cpa.Parameter());\n    CHECK(s.X() == s1.X());\n    CHECK(s.Y() == s1.Y());\n    CHECK(ComputePointsAbscissa::Length(circle) == 0.0);\n;\n\tSECTION(\"arc length, initial guess parameters and tolerances-3D\")\n{\n    Frame3 frame;\n    double major = 5.0;\n    double minor = 4.0;\n    bool isRight = true;\n    std::shared_ptr< Geom3Hyperbola >h1 = MakeGeom3Hyperbola(frame, major, minor);\n    AdaptorGeom3Curve hyperbola(h1);\n    ComputePointsAbscissa cpa3(hyperbola, 1.0, 0.0, 0.5,Precision::Confusion());\n    double L = 1.0;\n    double param3 = cpa3.Parameter();\n    Point3 point1(hyperbola.Value(param3));\n    CHECK(cpa3.Parameter());\n    MakeEdge edge1(h1, 0.0, param3);\n    CHECK(BRepClassificationTools::IsPointInOnEdge(edge1, point1, 0.001) == true);\n    CHECK(cpa3.Parameter());\n    CHECK(ComputePointsAbscissa::Length(hyperbola, 0.0, param3) == Approx(L).margin(1e-2));\n    CHECK(ComputePointsAbscissa::Length(hyperbola, 0.0, param3, Precision::Confusion()) == Approx(L).margin(1e-2));\n}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static double Length(const Adaptor2Curve& c)\t @return The length of a curve\n\t @param c The curve\n\t @brief Compute the length of a 2D curve\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/MakeGeom2Circle.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/ComputePointsAbscissa.hpp>\n#include <geometry/MakeGeom3Circle.hpp>\n#include <geometry/AdaptorGeom3Curve.hpp>\n#include <geometry/MakeGeom2Hyperbola.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/MakeGeom2Ellipse.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <geometry/MakeGeom3Ellipse.hpp>\n#include <geometry/MakeGeom3Hyperbola.hpp>\n#include <geometry/Geom2Line.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include<modeling/MakeEdge.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/MakeGeom2Parabola.hpp>\n#include <geometry/MakeGeom3Parabola.hpp>\n#include <geometry/Geom2BezierCurve.hpp>\n#include <geometry/Geom3BezierCurve.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2OffsetCurve.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\n#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/MakeGeom2Circle.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/ComputePointsAbscissa.hpp>\n#include <geometry/MakeGeom3Circle.hpp>\n#include <geometry/AdaptorGeom3Curve.hpp>\n#include <geometry/MakeGeom2Hyperbola.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/MakeGeom2Ellipse.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <geometry/MakeGeom3Ellipse.hpp>\n#include <geometry/MakeGeom3Hyperbola.hpp>\n#include <geometry/Geom2Line.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include<modeling/MakeEdge.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/MakeGeom2Parabola.hpp>\n#include <geometry/MakeGeom3Parabola.hpp>\n#include <geometry/Geom2BezierCurve.hpp>\n#include <geometry/Geom3BezierCurve.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2OffsetCurve.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\n;\n\tSECTION(\"offset curve\")\n    {\n        double r = 2.0;\n        std::shared_ptr<Geom2Curve> c = MakeGeom2Circle(Point2(0.0, 0.0), 2.0).Value();\n        shared_ptr<Geom2OffsetCurve> curve;\n        double offset = -1.0;\n        curve = make_shared<Geom2OffsetCurve>(c, offset);\n        double r2 = r + offset;\n        double p = 2 * M_PI * r2;\n        double l = 0.0;\n        AdaptorGeom2Curve offs(curve);\n        ComputePointsAbscissa cpa8(offs, 0.0, 0.0);\n        double angle1 = l / r2;\n        double x = r2 * cos(angle1);\n        double y = r2 * sin(angle1);\n        double param8 = cpa8.Parameter();\n        Point2 s = offs.Value(param8);\n        Point2 s1(x, y);\n        CHECK(p == ComputePointsAbscissa::Length(offs));\n        CHECK(angle1 == cpa8.Parameter());\n        CHECK(s.X() == s1.X());\n        CHECK(s.Y() == s1.Y());\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API double Parameter()\t @return The parameter of the point\n\t @brief Get the parameter of the point\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/MakeGeom2Circle.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/ComputePointsAbscissa.hpp>\n#include <geometry/MakeGeom3Circle.hpp>\n#include <geometry/AdaptorGeom3Curve.hpp>\n#include <geometry/MakeGeom2Hyperbola.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/MakeGeom2Ellipse.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <geometry/MakeGeom3Ellipse.hpp>\n#include <geometry/MakeGeom3Hyperbola.hpp>\n#include <geometry/Geom2Line.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include<modeling/MakeEdge.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/MakeGeom2Parabola.hpp>\n#include <geometry/MakeGeom3Parabola.hpp>\n#include <geometry/Geom2BezierCurve.hpp>\n#include <geometry/Geom3BezierCurve.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2OffsetCurve.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\n#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/MakeGeom2Circle.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/ComputePointsAbscissa.hpp>\n#include <geometry/MakeGeom3Circle.hpp>\n#include <geometry/AdaptorGeom3Curve.hpp>\n#include <geometry/MakeGeom2Hyperbola.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/MakeGeom2Ellipse.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <geometry/MakeGeom3Ellipse.hpp>\n#include <geometry/MakeGeom3Hyperbola.hpp>\n#include <geometry/Geom2Line.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include<modeling/MakeEdge.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/MakeGeom2Parabola.hpp>\n#include <geometry/MakeGeom3Parabola.hpp>\n#include <geometry/Geom2BezierCurve.hpp>\n#include <geometry/Geom3BezierCurve.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2OffsetCurve.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\n;\n\tSECTION(\"line\")\n    {\n        shared_ptr<Geom2Line> line;\n        line = make_shared<Geom2Line>(Point2(0.0, 0.0), Direction2(1.0, 0.0));\n        shared_ptr<Geom2TrimmedCurve> TrimmedCurve = make_shared<Geom2TrimmedCurve>(line, 0.0, 6.0);\n        AdaptorGeom2Curve line1(TrimmedCurve);\n        ComputePointsAbscissa cpa4(line1, 0.0, 0.0);\n        double param4 = cpa4.Parameter();\n        double x = 0.0;\n        double y = 0.0;\n        Point2 s5 = line1.Value(param4);\n        Point2 s6(x, y);\n        CHECK(cpa4.Parameter() == 0.0);\n        CHECK(s5.X() == s6.X());\n        CHECK(s5.Y() == s6.Y());\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API ComputePointsAbscissa(const Adaptor2Curve& c, double abscissa, double u0, double ui, double tol)\t @param tol The tolerance\n\t @param ui The initial guess of the parameter\n\t @param u0 The starting parameter\n\t @param abscissa The arc length\n\t @param c The curve\n\t @brief Compute the parameter of a point on a 2D curve with given arc length, an initial guess, and a tolerance\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/MakeGeom2Circle.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/ComputePointsAbscissa.hpp>\n#include <geometry/MakeGeom3Circle.hpp>\n#include <geometry/AdaptorGeom3Curve.hpp>\n#include <geometry/MakeGeom2Hyperbola.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/MakeGeom2Ellipse.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <geometry/MakeGeom3Ellipse.hpp>\n#include <geometry/MakeGeom3Hyperbola.hpp>\n#include <geometry/Geom2Line.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include<modeling/MakeEdge.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/MakeGeom2Parabola.hpp>\n#include <geometry/MakeGeom3Parabola.hpp>\n#include <geometry/Geom2BezierCurve.hpp>\n#include <geometry/Geom3BezierCurve.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2OffsetCurve.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\n#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/MakeGeom2Circle.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/ComputePointsAbscissa.hpp>\n#include <geometry/MakeGeom3Circle.hpp>\n#include <geometry/AdaptorGeom3Curve.hpp>\n#include <geometry/MakeGeom2Hyperbola.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/MakeGeom2Ellipse.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <geometry/MakeGeom3Ellipse.hpp>\n#include <geometry/MakeGeom3Hyperbola.hpp>\n#include <geometry/Geom2Line.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include<modeling/MakeEdge.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/MakeGeom2Parabola.hpp>\n#include <geometry/MakeGeom3Parabola.hpp>\n#include <geometry/Geom2BezierCurve.hpp>\n#include <geometry/Geom3BezierCurve.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2OffsetCurve.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\n;\n\tSECTION(\"circle\")\n    {\n        double r = 2.0;\n        double l = 0.0;\n        std::shared_ptr<Geom2Curve> c = MakeGeom2Circle(Point2(0.0, 0.0), 2.0).Value();\n        AdaptorGeom2Curve circle(c);\n        ComputePointsAbscissa cpa(circle, 0.0, 0.0);\n        double angle1 = l / r;\n        double x = r * cos(angle1);\n        double y = r * sin(angle1);\n        double param = cpa.Parameter();\n        Point2 s = circle.Value(param);\n        Point2 s1(x, y);\n        CHECK(angle1 == cpa.Parameter());\n        CHECK(s.X() == s1.X());\n        CHECK(s.Y() == s1.Y());\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API ComputePointsAbscissa(const Adaptor3Curve& c, double abscissa, double u0, double ui, double tol)\t @param tol The tolerance\n\t @param ui The initial guess of the parameter\n\t @param u0 The starting parameter\n\t @param abscissa The arc length\n\t @param c The curve\n\t @brief Compute the parameter of a point on a 3D curve with given arc length, an initial guess, and a tolerance\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/MakeGeom2Circle.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/ComputePointsAbscissa.hpp>\n#include <geometry/MakeGeom3Circle.hpp>\n#include <geometry/AdaptorGeom3Curve.hpp>\n#include <geometry/MakeGeom2Hyperbola.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/MakeGeom2Ellipse.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <geometry/MakeGeom3Ellipse.hpp>\n#include <geometry/MakeGeom3Hyperbola.hpp>\n#include <geometry/Geom2Line.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include<modeling/MakeEdge.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/MakeGeom2Parabola.hpp>\n#include <geometry/MakeGeom3Parabola.hpp>\n#include <geometry/Geom2BezierCurve.hpp>\n#include <geometry/Geom3BezierCurve.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2OffsetCurve.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\n#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/MakeGeom2Circle.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/ComputePointsAbscissa.hpp>\n#include <geometry/MakeGeom3Circle.hpp>\n#include <geometry/AdaptorGeom3Curve.hpp>\n#include <geometry/MakeGeom2Hyperbola.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/MakeGeom2Ellipse.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <geometry/MakeGeom3Ellipse.hpp>\n#include <geometry/MakeGeom3Hyperbola.hpp>\n#include <geometry/Geom2Line.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include<modeling/MakeEdge.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/MakeGeom2Parabola.hpp>\n#include <geometry/MakeGeom3Parabola.hpp>\n#include <geometry/Geom2BezierCurve.hpp>\n#include <geometry/Geom3BezierCurve.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2OffsetCurve.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\n;\n\tSECTION(\"circle\")\n    {\n        double r = 2.0;\n        double l = 0.0;\n        std::shared_ptr<Geom2Curve> c = MakeGeom2Circle(Point2(0.0, 0.0), 2.0).Value();\n        AdaptorGeom2Curve circle(c);\n        ComputePointsAbscissa cpa(circle, 0.0, 0.0);\n        double angle1 = l / r;\n        double x = r * cos(angle1);\n        double y = r * sin(angle1);\n        double param = cpa.Parameter();\n        Point2 s = circle.Value(param);\n        Point2 s1(x, y);\n        CHECK(angle1 == cpa.Parameter());\n        CHECK(s.X() == s1.X());\n        CHECK(s.Y() == s1.Y());\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API ComputePointsAbscissa(const Adaptor2Curve& c, double abscissa, double u0, double ui)\t @param ui The initial guess of the parameter\n\t @param u0 The starting parameter\n\t @param abscissa The arc length\n\t @param c The curve\n\t @brief Compute the parameter of a point on a 2D curve with given arc length and an initial guess\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/MakeGeom2Circle.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/ComputePointsAbscissa.hpp>\n#include <geometry/MakeGeom3Circle.hpp>\n#include <geometry/AdaptorGeom3Curve.hpp>\n#include <geometry/MakeGeom2Hyperbola.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/MakeGeom2Ellipse.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <geometry/MakeGeom3Ellipse.hpp>\n#include <geometry/MakeGeom3Hyperbola.hpp>\n#include <geometry/Geom2Line.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include<modeling/MakeEdge.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/MakeGeom2Parabola.hpp>\n#include <geometry/MakeGeom3Parabola.hpp>\n#include <geometry/Geom2BezierCurve.hpp>\n#include <geometry/Geom3BezierCurve.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2OffsetCurve.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\n#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/MakeGeom2Circle.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/ComputePointsAbscissa.hpp>\n#include <geometry/MakeGeom3Circle.hpp>\n#include <geometry/AdaptorGeom3Curve.hpp>\n#include <geometry/MakeGeom2Hyperbola.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/MakeGeom2Ellipse.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <geometry/MakeGeom3Ellipse.hpp>\n#include <geometry/MakeGeom3Hyperbola.hpp>\n#include <geometry/Geom2Line.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include<modeling/MakeEdge.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/MakeGeom2Parabola.hpp>\n#include <geometry/MakeGeom3Parabola.hpp>\n#include <geometry/Geom2BezierCurve.hpp>\n#include <geometry/Geom3BezierCurve.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2OffsetCurve.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\n;\n\tSECTION(\"circle\")\n    {\n        double r = 2.0;\n        double l = 0.0;\n        std::shared_ptr<Geom2Curve> c = MakeGeom2Circle(Point2(0.0, 0.0), 2.0).Value();\n        AdaptorGeom2Curve circle(c);\n        ComputePointsAbscissa cpa(circle, 0.0, 0.0);\n        double angle1 = l / r;\n        double x = r * cos(angle1);\n        double y = r * sin(angle1);\n        double param = cpa.Parameter();\n        Point2 s = circle.Value(param);\n        Point2 s1(x, y);\n        CHECK(angle1 == cpa.Parameter());\n        CHECK(s.X() == s1.X());\n        CHECK(s.Y() == s1.Y());\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API ComputePointsAbscissa(const Adaptor3Curve& c, double abscissa, double u0, double ui)\t @param ui The initial guess of the parameter\n\t @param u0 The starting parameter\n\t @param abscissa The arc length\n\t @param c The curve\n\t @brief Compute the parameter of a point on a 3D curve with given arc length and an initial guess\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/MakeGeom2Circle.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/ComputePointsAbscissa.hpp>\n#include <geometry/MakeGeom3Circle.hpp>\n#include <geometry/AdaptorGeom3Curve.hpp>\n#include <geometry/MakeGeom2Hyperbola.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/MakeGeom2Ellipse.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <geometry/MakeGeom3Ellipse.hpp>\n#include <geometry/MakeGeom3Hyperbola.hpp>\n#include <geometry/Geom2Line.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include<modeling/MakeEdge.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/MakeGeom2Parabola.hpp>\n#include <geometry/MakeGeom3Parabola.hpp>\n#include <geometry/Geom2BezierCurve.hpp>\n#include <geometry/Geom3BezierCurve.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2OffsetCurve.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\n#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/MakeGeom2Circle.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/ComputePointsAbscissa.hpp>\n#include <geometry/MakeGeom3Circle.hpp>\n#include <geometry/AdaptorGeom3Curve.hpp>\n#include <geometry/MakeGeom2Hyperbola.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/MakeGeom2Ellipse.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <geometry/MakeGeom3Ellipse.hpp>\n#include <geometry/MakeGeom3Hyperbola.hpp>\n#include <geometry/Geom2Line.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include<modeling/MakeEdge.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/MakeGeom2Parabola.hpp>\n#include <geometry/MakeGeom3Parabola.hpp>\n#include <geometry/Geom2BezierCurve.hpp>\n#include <geometry/Geom3BezierCurve.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2OffsetCurve.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\n;\n\tSECTION(\"circle\")\n    {\n        double r = 2.0;\n        double l = 0.0;\n        std::shared_ptr<Geom2Curve> c = MakeGeom2Circle(Point2(0.0, 0.0), 2.0).Value();\n        AdaptorGeom2Curve circle(c);\n        ComputePointsAbscissa cpa(circle, 0.0, 0.0);\n        double angle1 = l / r;\n        double x = r * cos(angle1);\n        double y = r * sin(angle1);\n        double param = cpa.Parameter();\n        Point2 s = circle.Value(param);\n        Point2 s1(x, y);\n        CHECK(angle1 == cpa.Parameter());\n        CHECK(s.X() == s1.X());\n        CHECK(s.Y() == s1.Y());\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API ComputePointsAbscissa(const Adaptor2Curve& c, double abscissa, double u0)\t @param u0 The starting parameter\n\t @param abscissa The arc length\n\t @param c The curve\n\t @brief Compute the parameter of a point on a 2D curve with given arc length\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/MakeGeom2Circle.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/ComputePointsAbscissa.hpp>\n#include <geometry/MakeGeom3Circle.hpp>\n#include <geometry/AdaptorGeom3Curve.hpp>\n#include <geometry/MakeGeom2Hyperbola.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/MakeGeom2Ellipse.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <geometry/MakeGeom3Ellipse.hpp>\n#include <geometry/MakeGeom3Hyperbola.hpp>\n#include <geometry/Geom2Line.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include<modeling/MakeEdge.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/MakeGeom2Parabola.hpp>\n#include <geometry/MakeGeom3Parabola.hpp>\n#include <geometry/Geom2BezierCurve.hpp>\n#include <geometry/Geom3BezierCurve.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2OffsetCurve.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\n#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/MakeGeom2Circle.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/ComputePointsAbscissa.hpp>\n#include <geometry/MakeGeom3Circle.hpp>\n#include <geometry/AdaptorGeom3Curve.hpp>\n#include <geometry/MakeGeom2Hyperbola.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/MakeGeom2Ellipse.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <geometry/MakeGeom3Ellipse.hpp>\n#include <geometry/MakeGeom3Hyperbola.hpp>\n#include <geometry/Geom2Line.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include<modeling/MakeEdge.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/MakeGeom2Parabola.hpp>\n#include <geometry/MakeGeom3Parabola.hpp>\n#include <geometry/Geom2BezierCurve.hpp>\n#include <geometry/Geom3BezierCurve.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2OffsetCurve.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\n;\n\tSECTION(\"circle\")\n    {\n        double r = 2.0;\n        double l = 0.0;\n        std::shared_ptr<Geom2Curve> c = MakeGeom2Circle(Point2(0.0, 0.0), 2.0).Value();\n        AdaptorGeom2Curve circle(c);\n        ComputePointsAbscissa cpa(circle, 0.0, 0.0);\n        double angle1 = l / r;\n        double x = r * cos(angle1);\n        double y = r * sin(angle1);\n        double param = cpa.Parameter();\n        Point2 s = circle.Value(param);\n        Point2 s1(x, y);\n        CHECK(angle1 == cpa.Parameter());\n        CHECK(s.X() == s1.X());\n        CHECK(s.Y() == s1.Y());\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API ComputePointsAbscissa(const Adaptor3Curve& c, double abscissa, double u0)\t @param u0 The starting parameter\n\t @param abscissa The arc length\n\t @param c The curve\n\t @brief Compute the parameter of a point on a 3D curve with given arc length\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/MakeGeom2Circle.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/ComputePointsAbscissa.hpp>\n#include <geometry/MakeGeom3Circle.hpp>\n#include <geometry/AdaptorGeom3Curve.hpp>\n#include <geometry/MakeGeom2Hyperbola.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/MakeGeom2Ellipse.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <geometry/MakeGeom3Ellipse.hpp>\n#include <geometry/MakeGeom3Hyperbola.hpp>\n#include <geometry/Geom2Line.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include<modeling/MakeEdge.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/MakeGeom2Parabola.hpp>\n#include <geometry/MakeGeom3Parabola.hpp>\n#include <geometry/Geom2BezierCurve.hpp>\n#include <geometry/Geom3BezierCurve.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2OffsetCurve.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\n#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/MakeGeom2Circle.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/ComputePointsAbscissa.hpp>\n#include <geometry/MakeGeom3Circle.hpp>\n#include <geometry/AdaptorGeom3Curve.hpp>\n#include <geometry/MakeGeom2Hyperbola.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/MakeGeom2Ellipse.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <geometry/MakeGeom3Ellipse.hpp>\n#include <geometry/MakeGeom3Hyperbola.hpp>\n#include <geometry/Geom2Line.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include<modeling/MakeEdge.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/MakeGeom2Parabola.hpp>\n#include <geometry/MakeGeom3Parabola.hpp>\n#include <geometry/Geom2BezierCurve.hpp>\n#include <geometry/Geom3BezierCurve.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2OffsetCurve.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\n;\n\tSECTION(\"circle\")\n    {\n        double r = 2.0;\n        double l = 0.0;\n        std::shared_ptr<Geom2Curve> c = MakeGeom2Circle(Point2(0.0, 0.0), 2.0).Value();\n        AdaptorGeom2Curve circle(c);\n        ComputePointsAbscissa cpa(circle, 0.0, 0.0);\n        double angle1 = l / r;\n        double x = r * cos(angle1);\n        double y = r * sin(angle1);\n        double param = cpa.Parameter();\n        Point2 s = circle.Value(param);\n        Point2 s1(x, y);\n        CHECK(angle1 == cpa.Parameter());\n        CHECK(s.X() == s1.X());\n        CHECK(s.Y() == s1.Y());\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API ComputePointsAbscissa(double tol, const Adaptor2Curve& c, double abscissa, double u0)\t @param u0 The starting parameter\n\t @param abscissa The arc length\n\t @param c The curve\n\t @param tol The tolerance\n\t @brief Compute the parameter of a point on a 2D curve with given arc length and a tolerance\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/MakeGeom2Circle.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/ComputePointsAbscissa.hpp>\n#include <geometry/MakeGeom3Circle.hpp>\n#include <geometry/AdaptorGeom3Curve.hpp>\n#include <geometry/MakeGeom2Hyperbola.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/MakeGeom2Ellipse.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <geometry/MakeGeom3Ellipse.hpp>\n#include <geometry/MakeGeom3Hyperbola.hpp>\n#include <geometry/Geom2Line.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include<modeling/MakeEdge.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/MakeGeom2Parabola.hpp>\n#include <geometry/MakeGeom3Parabola.hpp>\n#include <geometry/Geom2BezierCurve.hpp>\n#include <geometry/Geom3BezierCurve.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2OffsetCurve.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\n#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/MakeGeom2Circle.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/ComputePointsAbscissa.hpp>\n#include <geometry/MakeGeom3Circle.hpp>\n#include <geometry/AdaptorGeom3Curve.hpp>\n#include <geometry/MakeGeom2Hyperbola.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/MakeGeom2Ellipse.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <geometry/MakeGeom3Ellipse.hpp>\n#include <geometry/MakeGeom3Hyperbola.hpp>\n#include <geometry/Geom2Line.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include<modeling/MakeEdge.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/MakeGeom2Parabola.hpp>\n#include <geometry/MakeGeom3Parabola.hpp>\n#include <geometry/Geom2BezierCurve.hpp>\n#include <geometry/Geom3BezierCurve.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2OffsetCurve.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\n;\n\tSECTION(\"circle\")\n    {\n        double r = 2.0;\n        double l = 0.0;\n        std::shared_ptr<Geom2Curve> c = MakeGeom2Circle(Point2(0.0, 0.0), 2.0).Value();\n        AdaptorGeom2Curve circle(c);\n        ComputePointsAbscissa cpa(circle, 0.0, 0.0);\n        double angle1 = l / r;\n        double x = r * cos(angle1);\n        double y = r * sin(angle1);\n        double param = cpa.Parameter();\n        Point2 s = circle.Value(param);\n        Point2 s1(x, y);\n        CHECK(angle1 == cpa.Parameter());\n        CHECK(s.X() == s1.X());\n        CHECK(s.Y() == s1.Y());\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API ComputePointsAbscissa(double tol, const Adaptor3Curve& c, double abscissa, double u0)\t @param u0 The starting parameter\n\t @param abscissa The arc length\n\t @param c The curve\n\t @param tol The tolerance\n\t @brief Compute the parameter of a point on a 3D curve with given arc length and a tolerance\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/MakeGeom2Circle.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/ComputePointsAbscissa.hpp>\n#include <geometry/MakeGeom3Circle.hpp>\n#include <geometry/AdaptorGeom3Curve.hpp>\n#include <geometry/MakeGeom2Hyperbola.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/MakeGeom2Ellipse.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <geometry/MakeGeom3Ellipse.hpp>\n#include <geometry/MakeGeom3Hyperbola.hpp>\n#include <geometry/Geom2Line.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include<modeling/MakeEdge.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/MakeGeom2Parabola.hpp>\n#include <geometry/MakeGeom3Parabola.hpp>\n#include <geometry/Geom2BezierCurve.hpp>\n#include <geometry/Geom3BezierCurve.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2OffsetCurve.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\n#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/MakeGeom2Circle.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/ComputePointsAbscissa.hpp>\n#include <geometry/MakeGeom3Circle.hpp>\n#include <geometry/AdaptorGeom3Curve.hpp>\n#include <geometry/MakeGeom2Hyperbola.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/MakeGeom2Ellipse.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <geometry/MakeGeom3Ellipse.hpp>\n#include <geometry/MakeGeom3Hyperbola.hpp>\n#include <geometry/Geom2Line.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include<modeling/MakeEdge.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/MakeGeom2Parabola.hpp>\n#include <geometry/MakeGeom3Parabola.hpp>\n#include <geometry/Geom2BezierCurve.hpp>\n#include <geometry/Geom3BezierCurve.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2OffsetCurve.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\n;\n\tSECTION(\"circle\")\n    {\n        double r = 2.0;\n        double l = 0.0;\n        std::shared_ptr<Geom2Curve> c = MakeGeom2Circle(Point2(0.0, 0.0), 2.0).Value();\n        AdaptorGeom2Curve circle(c);\n        ComputePointsAbscissa cpa(circle, 0.0, 0.0);\n        double angle1 = l / r;\n        double x = r * cos(angle1);\n        double y = r * sin(angle1);\n        double param = cpa.Parameter();\n        Point2 s = circle.Value(param);\n        Point2 s1(x, y);\n        CHECK(angle1 == cpa.Parameter());\n        CHECK(s.X() == s1.X());\n        CHECK(s.Y() == s1.Y());\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API double Parameter()\t @return The parameter of the point\n\t @brief Get the parameter of the point\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/MakeGeom2Circle.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/ComputePointsAbscissa.hpp>\n#include <geometry/MakeGeom3Circle.hpp>\n#include <geometry/AdaptorGeom3Curve.hpp>\n#include <geometry/MakeGeom2Hyperbola.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/MakeGeom2Ellipse.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <geometry/MakeGeom3Ellipse.hpp>\n#include <geometry/MakeGeom3Hyperbola.hpp>\n#include <geometry/Geom2Line.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include<modeling/MakeEdge.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/MakeGeom2Parabola.hpp>\n#include <geometry/MakeGeom3Parabola.hpp>\n#include <geometry/Geom2BezierCurve.hpp>\n#include <geometry/Geom3BezierCurve.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2OffsetCurve.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\n#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/MakeGeom2Circle.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/ComputePointsAbscissa.hpp>\n#include <geometry/MakeGeom3Circle.hpp>\n#include <geometry/AdaptorGeom3Curve.hpp>\n#include <geometry/MakeGeom2Hyperbola.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/MakeGeom2Ellipse.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <geometry/MakeGeom3Ellipse.hpp>\n#include <geometry/MakeGeom3Hyperbola.hpp>\n#include <geometry/Geom2Line.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include<modeling/MakeEdge.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/MakeGeom2Parabola.hpp>\n#include <geometry/MakeGeom3Parabola.hpp>\n#include <geometry/Geom2BezierCurve.hpp>\n#include <geometry/Geom3BezierCurve.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2OffsetCurve.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\n;\n\tSECTION(\"line\")\n    {\n        shared_ptr<Geom2Line> line;\n        line = make_shared<Geom2Line>(Point2(0.0, 0.0), Direction2(1.0, 0.0));\n        shared_ptr<Geom2TrimmedCurve> TrimmedCurve = make_shared<Geom2TrimmedCurve>(line, 0.0, 6.0);\n        AdaptorGeom2Curve line1(TrimmedCurve);\n        ComputePointsAbscissa cpa4(line1, 8.0, 0.0);\n        double param4 = cpa4.Parameter();\n        double x = 8.0;\n        double y = 0.0;\n        Point2 s5 = line1.Value(param4);\n        Point2 s6(x, y);\n        CHECK(cpa4.Parameter() == 8.0);\n        CHECK(s5.X() == s6.X());\n        CHECK(s5.Y() == s6.Y());\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API ComputePointsAbscissa(const Adaptor2Curve& c, double abscissa, double u0, double ui, double tol)\t @param tol The tolerance\n\t @param ui The initial guess of the parameter\n\t @param u0 The starting parameter\n\t @param abscissa The arc length\n\t @param c The curve\n\t @brief Compute the parameter of a point on a 2D curve with given arc length, an initial guess, and a tolerance\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/MakeGeom2Circle.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/ComputePointsAbscissa.hpp>\n#include <geometry/MakeGeom3Circle.hpp>\n#include <geometry/AdaptorGeom3Curve.hpp>\n#include <geometry/MakeGeom2Hyperbola.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/MakeGeom2Ellipse.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <geometry/MakeGeom3Ellipse.hpp>\n#include <geometry/MakeGeom3Hyperbola.hpp>\n#include <geometry/Geom2Line.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include<modeling/MakeEdge.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/MakeGeom2Parabola.hpp>\n#include <geometry/MakeGeom3Parabola.hpp>\n#include <geometry/Geom2BezierCurve.hpp>\n#include <geometry/Geom3BezierCurve.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2OffsetCurve.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\n#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/MakeGeom2Circle.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/ComputePointsAbscissa.hpp>\n#include <geometry/MakeGeom3Circle.hpp>\n#include <geometry/AdaptorGeom3Curve.hpp>\n#include <geometry/MakeGeom2Hyperbola.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/MakeGeom2Ellipse.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <geometry/MakeGeom3Ellipse.hpp>\n#include <geometry/MakeGeom3Hyperbola.hpp>\n#include <geometry/Geom2Line.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include<modeling/MakeEdge.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/MakeGeom2Parabola.hpp>\n#include <geometry/MakeGeom3Parabola.hpp>\n#include <geometry/Geom2BezierCurve.hpp>\n#include <geometry/Geom3BezierCurve.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2OffsetCurve.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\n;\n\tSECTION(\"circle\")\n    {\n        double r = 2.0;\n        double l = 19;\n        std::shared_ptr<Geom2Curve> c = MakeGeom2Circle(Point2(0.0, 0.0), 2.0).Value();\n        AdaptorGeom2Curve circle(c);\n        ComputePointsAbscissa cpa(circle, l, 0.0);\n        double angle1 = l / r;\n        double x = r * cos(angle1);\n        double y = r * sin(angle1);\n        double param = cpa.Parameter();\n        Point2 s = circle.Value(param);\n        Point2 s1(x, y);\n        CHECK(angle1 == cpa.Parameter());\n        CHECK(s.X() == s1.X());\n        CHECK(s.Y() == s1.Y());\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API ComputePointsAbscissa(const Adaptor3Curve& c, double abscissa, double u0, double ui, double tol)\t @param tol The tolerance\n\t @param ui The initial guess of the parameter\n\t @param u0 The starting parameter\n\t @param abscissa The arc length\n\t @param c The curve\n\t @brief Compute the parameter of a point on a 3D curve with given arc length, an initial guess, and a tolerance\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/MakeGeom2Circle.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/ComputePointsAbscissa.hpp>\n#include <geometry/MakeGeom3Circle.hpp>\n#include <geometry/AdaptorGeom3Curve.hpp>\n#include <geometry/MakeGeom2Hyperbola.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/MakeGeom2Ellipse.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <geometry/MakeGeom3Ellipse.hpp>\n#include <geometry/MakeGeom3Hyperbola.hpp>\n#include <geometry/Geom2Line.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include<modeling/MakeEdge.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/MakeGeom2Parabola.hpp>\n#include <geometry/MakeGeom3Parabola.hpp>\n#include <geometry/Geom2BezierCurve.hpp>\n#include <geometry/Geom3BezierCurve.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2OffsetCurve.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\n#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/MakeGeom2Circle.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/ComputePointsAbscissa.hpp>\n#include <geometry/MakeGeom3Circle.hpp>\n#include <geometry/AdaptorGeom3Curve.hpp>\n#include <geometry/MakeGeom2Hyperbola.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/MakeGeom2Ellipse.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <geometry/MakeGeom3Ellipse.hpp>\n#include <geometry/MakeGeom3Hyperbola.hpp>\n#include <geometry/Geom2Line.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include<modeling/MakeEdge.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/MakeGeom2Parabola.hpp>\n#include <geometry/MakeGeom3Parabola.hpp>\n#include <geometry/Geom2BezierCurve.hpp>\n#include <geometry/Geom3BezierCurve.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2OffsetCurve.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\n;\n\tSECTION(\"circle\")\n    {\n        double r = 2.0;\n        double l = 19;\n        std::shared_ptr<Geom2Curve> c = MakeGeom2Circle(Point2(0.0, 0.0), 2.0).Value();\n        AdaptorGeom2Curve circle(c);\n        ComputePointsAbscissa cpa(circle, l, 0.0);\n        double angle1 = l / r;\n        double x = r * cos(angle1);\n        double y = r * sin(angle1);\n        double param = cpa.Parameter();\n        Point2 s = circle.Value(param);\n        Point2 s1(x, y);\n        CHECK(angle1 == cpa.Parameter());\n        CHECK(s.X() == s1.X());\n        CHECK(s.Y() == s1.Y());\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API ComputePointsAbscissa(const Adaptor2Curve& c, double abscissa, double u0, double ui)\t @param ui The initial guess of the parameter\n\t @param u0 The starting parameter\n\t @param abscissa The arc length\n\t @param c The curve\n\t @brief Compute the parameter of a point on a 2D curve with given arc length and an initial guess\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/MakeGeom2Circle.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/ComputePointsAbscissa.hpp>\n#include <geometry/MakeGeom3Circle.hpp>\n#include <geometry/AdaptorGeom3Curve.hpp>\n#include <geometry/MakeGeom2Hyperbola.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/MakeGeom2Ellipse.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <geometry/MakeGeom3Ellipse.hpp>\n#include <geometry/MakeGeom3Hyperbola.hpp>\n#include <geometry/Geom2Line.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include<modeling/MakeEdge.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/MakeGeom2Parabola.hpp>\n#include <geometry/MakeGeom3Parabola.hpp>\n#include <geometry/Geom2BezierCurve.hpp>\n#include <geometry/Geom3BezierCurve.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2OffsetCurve.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\n#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/MakeGeom2Circle.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/ComputePointsAbscissa.hpp>\n#include <geometry/MakeGeom3Circle.hpp>\n#include <geometry/AdaptorGeom3Curve.hpp>\n#include <geometry/MakeGeom2Hyperbola.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/MakeGeom2Ellipse.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <geometry/MakeGeom3Ellipse.hpp>\n#include <geometry/MakeGeom3Hyperbola.hpp>\n#include <geometry/Geom2Line.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include<modeling/MakeEdge.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/MakeGeom2Parabola.hpp>\n#include <geometry/MakeGeom3Parabola.hpp>\n#include <geometry/Geom2BezierCurve.hpp>\n#include <geometry/Geom3BezierCurve.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2OffsetCurve.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\n;\n\tSECTION(\"circle\")\n    {\n        double r = 2.0;\n        double l = 19;\n        std::shared_ptr<Geom2Curve> c = MakeGeom2Circle(Point2(0.0, 0.0), 2.0).Value();\n        AdaptorGeom2Curve circle(c);\n        ComputePointsAbscissa cpa(circle, l, 0.0);\n        double angle1 = l / r;\n        double x = r * cos(angle1);\n        double y = r * sin(angle1);\n        double param = cpa.Parameter();\n        Point2 s = circle.Value(param);\n        Point2 s1(x, y);\n        CHECK(angle1 == cpa.Parameter());\n        CHECK(s.X() == s1.X());\n        CHECK(s.Y() == s1.Y());\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API ComputePointsAbscissa(const Adaptor3Curve& c, double abscissa, double u0, double ui)\t @param ui The initial guess of the parameter\n\t @param u0 The starting parameter\n\t @param abscissa The arc length\n\t @param c The curve\n\t @brief Compute the parameter of a point on a 3D curve with given arc length and an initial guess\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/MakeGeom2Circle.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/ComputePointsAbscissa.hpp>\n#include <geometry/MakeGeom3Circle.hpp>\n#include <geometry/AdaptorGeom3Curve.hpp>\n#include <geometry/MakeGeom2Hyperbola.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/MakeGeom2Ellipse.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <geometry/MakeGeom3Ellipse.hpp>\n#include <geometry/MakeGeom3Hyperbola.hpp>\n#include <geometry/Geom2Line.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include<modeling/MakeEdge.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/MakeGeom2Parabola.hpp>\n#include <geometry/MakeGeom3Parabola.hpp>\n#include <geometry/Geom2BezierCurve.hpp>\n#include <geometry/Geom3BezierCurve.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2OffsetCurve.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\n#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/MakeGeom2Circle.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/ComputePointsAbscissa.hpp>\n#include <geometry/MakeGeom3Circle.hpp>\n#include <geometry/AdaptorGeom3Curve.hpp>\n#include <geometry/MakeGeom2Hyperbola.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/MakeGeom2Ellipse.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <geometry/MakeGeom3Ellipse.hpp>\n#include <geometry/MakeGeom3Hyperbola.hpp>\n#include <geometry/Geom2Line.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include<modeling/MakeEdge.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/MakeGeom2Parabola.hpp>\n#include <geometry/MakeGeom3Parabola.hpp>\n#include <geometry/Geom2BezierCurve.hpp>\n#include <geometry/Geom3BezierCurve.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2OffsetCurve.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\n;\n\tSECTION(\"circle\")\n    {\n        double r = 2.0;\n        double l = 19;\n        std::shared_ptr<Geom2Curve> c = MakeGeom2Circle(Point2(0.0, 0.0), 2.0).Value();\n        AdaptorGeom2Curve circle(c);\n        ComputePointsAbscissa cpa(circle, l, 0.0);\n        double angle1 = l / r;\n        double x = r * cos(angle1);\n        double y = r * sin(angle1);\n        double param = cpa.Parameter();\n        Point2 s = circle.Value(param);\n        Point2 s1(x, y);\n        CHECK(angle1 == cpa.Parameter());\n        CHECK(s.X() == s1.X());\n        CHECK(s.Y() == s1.Y());\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API ComputePointsAbscissa(const Adaptor2Curve& c, double abscissa, double u0)\t @param u0 The starting parameter\n\t @param abscissa The arc length\n\t @param c The curve\n\t @brief Compute the parameter of a point on a 2D curve with given arc length\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/MakeGeom2Circle.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/ComputePointsAbscissa.hpp>\n#include <geometry/MakeGeom3Circle.hpp>\n#include <geometry/AdaptorGeom3Curve.hpp>\n#include <geometry/MakeGeom2Hyperbola.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/MakeGeom2Ellipse.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <geometry/MakeGeom3Ellipse.hpp>\n#include <geometry/MakeGeom3Hyperbola.hpp>\n#include <geometry/Geom2Line.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include<modeling/MakeEdge.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/MakeGeom2Parabola.hpp>\n#include <geometry/MakeGeom3Parabola.hpp>\n#include <geometry/Geom2BezierCurve.hpp>\n#include <geometry/Geom3BezierCurve.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2OffsetCurve.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\n#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/MakeGeom2Circle.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/ComputePointsAbscissa.hpp>\n#include <geometry/MakeGeom3Circle.hpp>\n#include <geometry/AdaptorGeom3Curve.hpp>\n#include <geometry/MakeGeom2Hyperbola.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/MakeGeom2Ellipse.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <geometry/MakeGeom3Ellipse.hpp>\n#include <geometry/MakeGeom3Hyperbola.hpp>\n#include <geometry/Geom2Line.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include<modeling/MakeEdge.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/MakeGeom2Parabola.hpp>\n#include <geometry/MakeGeom3Parabola.hpp>\n#include <geometry/Geom2BezierCurve.hpp>\n#include <geometry/Geom3BezierCurve.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2OffsetCurve.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\n;\n\tSECTION(\"circle\")\n    {\n        double r = 2.0;\n        double l = 19;\n        std::shared_ptr<Geom2Curve> c = MakeGeom2Circle(Point2(0.0, 0.0), 2.0).Value();\n        AdaptorGeom2Curve circle(c);\n        ComputePointsAbscissa cpa(circle, l, 0.0);\n        double angle1 = l / r;\n        double x = r * cos(angle1);\n        double y = r * sin(angle1);\n        double param = cpa.Parameter();\n        Point2 s = circle.Value(param);\n        Point2 s1(x, y);\n        CHECK(angle1 == cpa.Parameter());\n        CHECK(s.X() == s1.X());\n        CHECK(s.Y() == s1.Y());\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API ComputePointsAbscissa(const Adaptor3Curve& c, double abscissa, double u0)\t @param u0 The starting parameter\n\t @param abscissa The arc length\n\t @param c The curve\n\t @brief Compute the parameter of a point on a 3D curve with given arc length\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/MakeGeom2Circle.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/ComputePointsAbscissa.hpp>\n#include <geometry/MakeGeom3Circle.hpp>\n#include <geometry/AdaptorGeom3Curve.hpp>\n#include <geometry/MakeGeom2Hyperbola.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/MakeGeom2Ellipse.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <geometry/MakeGeom3Ellipse.hpp>\n#include <geometry/MakeGeom3Hyperbola.hpp>\n#include <geometry/Geom2Line.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include<modeling/MakeEdge.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/MakeGeom2Parabola.hpp>\n#include <geometry/MakeGeom3Parabola.hpp>\n#include <geometry/Geom2BezierCurve.hpp>\n#include <geometry/Geom3BezierCurve.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2OffsetCurve.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\n#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/MakeGeom2Circle.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/ComputePointsAbscissa.hpp>\n#include <geometry/MakeGeom3Circle.hpp>\n#include <geometry/AdaptorGeom3Curve.hpp>\n#include <geometry/MakeGeom2Hyperbola.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/MakeGeom2Ellipse.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <geometry/MakeGeom3Ellipse.hpp>\n#include <geometry/MakeGeom3Hyperbola.hpp>\n#include <geometry/Geom2Line.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include<modeling/MakeEdge.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/MakeGeom2Parabola.hpp>\n#include <geometry/MakeGeom3Parabola.hpp>\n#include <geometry/Geom2BezierCurve.hpp>\n#include <geometry/Geom3BezierCurve.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2OffsetCurve.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\n;\n\tSECTION(\"circle\")\n    {\n        double r = 2.0;\n        double l = 19;\n        std::shared_ptr<Geom2Curve> c = MakeGeom2Circle(Point2(0.0, 0.0), 2.0).Value();\n        AdaptorGeom2Curve circle(c);\n        ComputePointsAbscissa cpa(circle, l, 0.0);\n        double angle1 = l / r;\n        double x = r * cos(angle1);\n        double y = r * sin(angle1);\n        double param = cpa.Parameter();\n        Point2 s = circle.Value(param);\n        Point2 s1(x, y);\n        CHECK(angle1 == cpa.Parameter());\n        CHECK(s.X() == s1.X());\n        CHECK(s.Y() == s1.Y());\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API ComputePointsAbscissa(double tol, const Adaptor2Curve& c, double abscissa, double u0)\t @param u0 The starting parameter\n\t @param abscissa The arc length\n\t @param c The curve\n\t @param tol The tolerance\n\t @brief Compute the parameter of a point on a 2D curve with given arc length and a tolerance\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/MakeGeom2Circle.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/ComputePointsAbscissa.hpp>\n#include <geometry/MakeGeom3Circle.hpp>\n#include <geometry/AdaptorGeom3Curve.hpp>\n#include <geometry/MakeGeom2Hyperbola.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/MakeGeom2Ellipse.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <geometry/MakeGeom3Ellipse.hpp>\n#include <geometry/MakeGeom3Hyperbola.hpp>\n#include <geometry/Geom2Line.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include<modeling/MakeEdge.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/MakeGeom2Parabola.hpp>\n#include <geometry/MakeGeom3Parabola.hpp>\n#include <geometry/Geom2BezierCurve.hpp>\n#include <geometry/Geom3BezierCurve.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2OffsetCurve.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\n#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/MakeGeom2Circle.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/ComputePointsAbscissa.hpp>\n#include <geometry/MakeGeom3Circle.hpp>\n#include <geometry/AdaptorGeom3Curve.hpp>\n#include <geometry/MakeGeom2Hyperbola.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/MakeGeom2Ellipse.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <geometry/MakeGeom3Ellipse.hpp>\n#include <geometry/MakeGeom3Hyperbola.hpp>\n#include <geometry/Geom2Line.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include<modeling/MakeEdge.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/MakeGeom2Parabola.hpp>\n#include <geometry/MakeGeom3Parabola.hpp>\n#include <geometry/Geom2BezierCurve.hpp>\n#include <geometry/Geom3BezierCurve.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2OffsetCurve.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\n;\n\tSECTION(\"circle\")\n    {\n        double r = 2.0;\n        double l = 19;\n        std::shared_ptr<Geom2Curve> c = MakeGeom2Circle(Point2(0.0, 0.0), 2.0).Value();\n        AdaptorGeom2Curve circle(c);\n        ComputePointsAbscissa cpa(circle, l, 0.0);\n        double angle1 = l / r;\n        double x = r * cos(angle1);\n        double y = r * sin(angle1);\n        double param = cpa.Parameter();\n        Point2 s = circle.Value(param);\n        Point2 s1(x, y);\n        CHECK(angle1 == cpa.Parameter());\n        CHECK(s.X() == s1.X());\n        CHECK(s.Y() == s1.Y());\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API ComputePointsAbscissa(double tol, const Adaptor3Curve& c, double abscissa, double u0)\t @param u0 The starting parameter\n\t @param abscissa The arc length\n\t @param c The curve\n\t @param tol The tolerance\n\t @brief Compute the parameter of a point on a 3D curve with given arc length and a tolerance\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/MakeGeom2Circle.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/ComputePointsAbscissa.hpp>\n#include <geometry/MakeGeom3Circle.hpp>\n#include <geometry/AdaptorGeom3Curve.hpp>\n#include <geometry/MakeGeom2Hyperbola.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/MakeGeom2Ellipse.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <geometry/MakeGeom3Ellipse.hpp>\n#include <geometry/MakeGeom3Hyperbola.hpp>\n#include <geometry/Geom2Line.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include<modeling/MakeEdge.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/MakeGeom2Parabola.hpp>\n#include <geometry/MakeGeom3Parabola.hpp>\n#include <geometry/Geom2BezierCurve.hpp>\n#include <geometry/Geom3BezierCurve.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2OffsetCurve.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\n#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/MakeGeom2Circle.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/ComputePointsAbscissa.hpp>\n#include <geometry/MakeGeom3Circle.hpp>\n#include <geometry/AdaptorGeom3Curve.hpp>\n#include <geometry/MakeGeom2Hyperbola.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/MakeGeom2Ellipse.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <geometry/MakeGeom3Ellipse.hpp>\n#include <geometry/MakeGeom3Hyperbola.hpp>\n#include <geometry/Geom2Line.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include<modeling/MakeEdge.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/MakeGeom2Parabola.hpp>\n#include <geometry/MakeGeom3Parabola.hpp>\n#include <geometry/Geom2BezierCurve.hpp>\n#include <geometry/Geom3BezierCurve.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2OffsetCurve.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\n;\n\tSECTION(\"circle\")\n    {\n        double r = 2.0;\n        double l = 19;\n        std::shared_ptr<Geom2Curve> c = MakeGeom2Circle(Point2(0.0, 0.0), 2.0).Value();\n        AdaptorGeom2Curve circle(c);\n        ComputePointsAbscissa cpa(circle, l, 0.0);\n        double angle1 = l / r;\n        double x = r * cos(angle1);\n        double y = r * sin(angle1);\n        double param = cpa.Parameter();\n        Point2 s = circle.Value(param);\n        Point2 s1(x, y);\n        CHECK(angle1 == cpa.Parameter());\n        CHECK(s.X() == s1.X());\n        CHECK(s.Y() == s1.Y());\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static double Length(const Adaptor3Curve& c, double tol)\t @return The length of a curve\n\t @param tol The tolerance\n\t @param c The curve\n\t @brief Compute the length of a 3D curve with a tolerance\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/MakeGeom2Circle.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/ComputePointsAbscissa.hpp>\n#include <geometry/MakeGeom3Circle.hpp>\n#include <geometry/AdaptorGeom3Curve.hpp>\n#include <geometry/MakeGeom2Hyperbola.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/MakeGeom2Ellipse.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <geometry/MakeGeom3Ellipse.hpp>\n#include <geometry/MakeGeom3Hyperbola.hpp>\n#include <geometry/Geom2Line.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include<modeling/MakeEdge.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/MakeGeom2Parabola.hpp>\n#include <geometry/MakeGeom3Parabola.hpp>\n#include <geometry/Geom2BezierCurve.hpp>\n#include <geometry/Geom3BezierCurve.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2OffsetCurve.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\n#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/MakeGeom2Circle.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/ComputePointsAbscissa.hpp>\n#include <geometry/MakeGeom3Circle.hpp>\n#include <geometry/AdaptorGeom3Curve.hpp>\n#include <geometry/MakeGeom2Hyperbola.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/MakeGeom2Ellipse.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <geometry/MakeGeom3Ellipse.hpp>\n#include <geometry/MakeGeom3Hyperbola.hpp>\n#include <geometry/Geom2Line.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include<modeling/MakeEdge.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/MakeGeom2Parabola.hpp>\n#include <geometry/MakeGeom3Parabola.hpp>\n#include <geometry/Geom2BezierCurve.hpp>\n#include <geometry/Geom3BezierCurve.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2OffsetCurve.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\n;\n\tSECTION(\"offset curve\")\n    {\n        double r = 2.0;\n        std::shared_ptr<Geom2Curve> c = MakeGeom2Circle(Point2(0.0, 0.0), 2.0).Value();\n        shared_ptr<Geom2OffsetCurve> curve;\n        double offset = -1.0;\n        curve = make_shared<Geom2OffsetCurve>(c, offset);\n        double r2 = r + offset;\n        double p = 2 * M_PI * r2;\n        double l = -2.0;\n        AdaptorGeom2Curve offs(curve);\n        ComputePointsAbscissa cpa8(Precision::Confusion(), offs, -2.0, 0.0);\n        double angle1 = l / r2;\n        double x = r2 * cos(angle1);\n        double y = r2 * sin(angle1);\n        double param8 = cpa8.Parameter();\n        Point2 s = offs.Value(param8);\n        Point2 s1(x, y);\n        CHECK(p == ComputePointsAbscissa::Length(offs, Precision::Confusion()));\n        CHECK(angle1 == Approx(cpa8.Parameter()).margin(1e-2));\n        CHECK(s.X() == Approx(s1.X()).margin(1e-2));\n        CHECK(s.Y() == Approx(s1.Y()).margin(1e-2));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static double Length(const Adaptor3Curve& c)\t @return The length of a curve\n\t @param c The curve\n\t @brief Compute the length of a 3D curve\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/MakeGeom2Circle.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/ComputePointsAbscissa.hpp>\n#include <geometry/MakeGeom3Circle.hpp>\n#include <geometry/AdaptorGeom3Curve.hpp>\n#include <geometry/MakeGeom2Hyperbola.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/MakeGeom2Ellipse.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <geometry/MakeGeom3Ellipse.hpp>\n#include <geometry/MakeGeom3Hyperbola.hpp>\n#include <geometry/Geom2Line.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include<modeling/MakeEdge.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/MakeGeom2Parabola.hpp>\n#include <geometry/MakeGeom3Parabola.hpp>\n#include <geometry/Geom2BezierCurve.hpp>\n#include <geometry/Geom3BezierCurve.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2OffsetCurve.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\n#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/MakeGeom2Circle.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/ComputePointsAbscissa.hpp>\n#include <geometry/MakeGeom3Circle.hpp>\n#include <geometry/AdaptorGeom3Curve.hpp>\n#include <geometry/MakeGeom2Hyperbola.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/MakeGeom2Ellipse.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <geometry/MakeGeom3Ellipse.hpp>\n#include <geometry/MakeGeom3Hyperbola.hpp>\n#include <geometry/Geom2Line.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include<modeling/MakeEdge.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/MakeGeom2Parabola.hpp>\n#include <geometry/MakeGeom3Parabola.hpp>\n#include <geometry/Geom2BezierCurve.hpp>\n#include <geometry/Geom3BezierCurve.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2OffsetCurve.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\n;\n\tSECTION(\"offset curve\")\n    {\n        double r = 2.0;\n        std::shared_ptr<Geom2Curve> c = MakeGeom2Circle(Point2(0.0, 0.0), 2.0).Value();\n        shared_ptr<Geom2OffsetCurve> curve;\n        double offset = -1.0;\n        curve = make_shared<Geom2OffsetCurve>(c, offset);\n        double r2 = r + offset;\n        double p = 2 * M_PI * r2;\n        double l = -2.0;\n        AdaptorGeom2Curve offs(curve);\n        ComputePointsAbscissa cpa8(Precision::Confusion(), offs, -2.0, 0.0);\n        double angle1 = l / r2;\n        double x = r2 * cos(angle1);\n        double y = r2 * sin(angle1);\n        double param8 = cpa8.Parameter();\n        Point2 s = offs.Value(param8);\n        Point2 s1(x, y);\n        CHECK(p == ComputePointsAbscissa::Length(offs, Precision::Confusion()));\n        CHECK(angle1 == Approx(cpa8.Parameter()).margin(1e-2));\n        CHECK(s.X() == Approx(s1.X()).margin(1e-2));\n        CHECK(s.Y() == Approx(s1.Y()).margin(1e-2));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API double Parameter()\t @return The parameter of the point\n\t @brief Get the parameter of the point\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/MakeGeom2Circle.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/ComputePointsAbscissa.hpp>\n#include <geometry/MakeGeom3Circle.hpp>\n#include <geometry/AdaptorGeom3Curve.hpp>\n#include <geometry/MakeGeom2Hyperbola.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/MakeGeom2Ellipse.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <geometry/MakeGeom3Ellipse.hpp>\n#include <geometry/MakeGeom3Hyperbola.hpp>\n#include <geometry/Geom2Line.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include<modeling/MakeEdge.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/MakeGeom2Parabola.hpp>\n#include <geometry/MakeGeom3Parabola.hpp>\n#include <geometry/Geom2BezierCurve.hpp>\n#include <geometry/Geom3BezierCurve.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2OffsetCurve.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\n#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/MakeGeom2Circle.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/ComputePointsAbscissa.hpp>\n#include <geometry/MakeGeom3Circle.hpp>\n#include <geometry/AdaptorGeom3Curve.hpp>\n#include <geometry/MakeGeom2Hyperbola.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/MakeGeom2Ellipse.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <geometry/MakeGeom3Ellipse.hpp>\n#include <geometry/MakeGeom3Hyperbola.hpp>\n#include <geometry/Geom2Line.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include<modeling/MakeEdge.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/MakeGeom2Parabola.hpp>\n#include <geometry/MakeGeom3Parabola.hpp>\n#include <geometry/Geom2BezierCurve.hpp>\n#include <geometry/Geom3BezierCurve.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2OffsetCurve.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\n;\n\tSECTION(\"circle\")\n    {\n        double r = 2.0;\n        double l = -1.0;\n        std::shared_ptr<Geom2Curve> c = MakeGeom2Circle(Point2(0.0, 0.0), 2.0).Value();\n        AdaptorGeom2Curve circle(c);\n        ComputePointsAbscissa cpa(circle, -1.0, 0.0);\n        double angle1 = l / r;\n        double x = r * cos(angle1);\n        double y = r * sin(angle1);\n        double param = cpa.Parameter();\n        Point2 s = circle.Value(param);\n        Point2 s1(x, y);\n        CHECK(angle1 == cpa.Parameter());\n        CHECK(s.X() == s1.X());\n        CHECK(s.Y() == s1.Y());\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API ComputePointsAbscissa(const Adaptor2Curve& c, double abscissa, double u0, double ui, double tol)\t @param tol The tolerance\n\t @param ui The initial guess of the parameter\n\t @param u0 The starting parameter\n\t @param abscissa The arc length\n\t @param c The curve\n\t @brief Compute the parameter of a point on a 2D curve with given arc length, an initial guess, and a tolerance\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/MakeGeom2Circle.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/ComputePointsAbscissa.hpp>\n#include <geometry/MakeGeom3Circle.hpp>\n#include <geometry/AdaptorGeom3Curve.hpp>\n#include <geometry/MakeGeom2Hyperbola.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/MakeGeom2Ellipse.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <geometry/MakeGeom3Ellipse.hpp>\n#include <geometry/MakeGeom3Hyperbola.hpp>\n#include <geometry/Geom2Line.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include<modeling/MakeEdge.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/MakeGeom2Parabola.hpp>\n#include <geometry/MakeGeom3Parabola.hpp>\n#include <geometry/Geom2BezierCurve.hpp>\n#include <geometry/Geom3BezierCurve.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2OffsetCurve.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\n#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/MakeGeom2Circle.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/ComputePointsAbscissa.hpp>\n#include <geometry/MakeGeom3Circle.hpp>\n#include <geometry/AdaptorGeom3Curve.hpp>\n#include <geometry/MakeGeom2Hyperbola.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/MakeGeom2Ellipse.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <geometry/MakeGeom3Ellipse.hpp>\n#include <geometry/MakeGeom3Hyperbola.hpp>\n#include <geometry/Geom2Line.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include<modeling/MakeEdge.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/MakeGeom2Parabola.hpp>\n#include <geometry/MakeGeom3Parabola.hpp>\n#include <geometry/Geom2BezierCurve.hpp>\n#include <geometry/Geom3BezierCurve.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2OffsetCurve.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\n;\n\tSECTION(\"circle\")\n    {\n        double r = 2.0;\n        double l = -1.0;\n        std::shared_ptr<Geom2Curve> c = MakeGeom2Circle(Point2(0.0, 0.0), 2.0).Value();\n        AdaptorGeom2Curve circle(c);\n        ComputePointsAbscissa cpa(circle, -1.0, 0.0);\n        double angle1 = l / r;\n        double x = r * cos(angle1);\n        double y = r * sin(angle1);\n        double param = cpa.Parameter();\n        Point2 s = circle.Value(param);\n        Point2 s1(x, y);\n        CHECK(angle1 == cpa.Parameter());\n        CHECK(s.X() == s1.X());\n        CHECK(s.Y() == s1.Y());\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API ComputePointsAbscissa(const Adaptor3Curve& c, double abscissa, double u0, double ui, double tol)\t @param tol The tolerance\n\t @param ui The initial guess of the parameter\n\t @param u0 The starting parameter\n\t @param abscissa The arc length\n\t @param c The curve\n\t @brief Compute the parameter of a point on a 3D curve with given arc length, an initial guess, and a tolerance\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/MakeGeom2Circle.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/ComputePointsAbscissa.hpp>\n#include <geometry/MakeGeom3Circle.hpp>\n#include <geometry/AdaptorGeom3Curve.hpp>\n#include <geometry/MakeGeom2Hyperbola.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/MakeGeom2Ellipse.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <geometry/MakeGeom3Ellipse.hpp>\n#include <geometry/MakeGeom3Hyperbola.hpp>\n#include <geometry/Geom2Line.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include<modeling/MakeEdge.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/MakeGeom2Parabola.hpp>\n#include <geometry/MakeGeom3Parabola.hpp>\n#include <geometry/Geom2BezierCurve.hpp>\n#include <geometry/Geom3BezierCurve.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2OffsetCurve.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\n#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/MakeGeom2Circle.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/ComputePointsAbscissa.hpp>\n#include <geometry/MakeGeom3Circle.hpp>\n#include <geometry/AdaptorGeom3Curve.hpp>\n#include <geometry/MakeGeom2Hyperbola.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/MakeGeom2Ellipse.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <geometry/MakeGeom3Ellipse.hpp>\n#include <geometry/MakeGeom3Hyperbola.hpp>\n#include <geometry/Geom2Line.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include<modeling/MakeEdge.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/MakeGeom2Parabola.hpp>\n#include <geometry/MakeGeom3Parabola.hpp>\n#include <geometry/Geom2BezierCurve.hpp>\n#include <geometry/Geom3BezierCurve.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2OffsetCurve.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\n;\n\tSECTION(\"circle\")\n    {\n        double r = 2.0;\n        double l = -1.0;\n        std::shared_ptr<Geom2Curve> c = MakeGeom2Circle(Point2(0.0, 0.0), 2.0).Value();\n        AdaptorGeom2Curve circle(c);\n        ComputePointsAbscissa cpa(circle, -1.0, 0.0);\n        double angle1 = l / r;\n        double x = r * cos(angle1);\n        double y = r * sin(angle1);\n        double param = cpa.Parameter();\n        Point2 s = circle.Value(param);\n        Point2 s1(x, y);\n        CHECK(angle1 == cpa.Parameter());\n        CHECK(s.X() == s1.X());\n        CHECK(s.Y() == s1.Y());\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API ComputePointsAbscissa(const Adaptor2Curve& c, double abscissa, double u0, double ui)\t @param ui The initial guess of the parameter\n\t @param u0 The starting parameter\n\t @param abscissa The arc length\n\t @param c The curve\n\t @brief Compute the parameter of a point on a 2D curve with given arc length and an initial guess\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/MakeGeom2Circle.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/ComputePointsAbscissa.hpp>\n#include <geometry/MakeGeom3Circle.hpp>\n#include <geometry/AdaptorGeom3Curve.hpp>\n#include <geometry/MakeGeom2Hyperbola.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/MakeGeom2Ellipse.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <geometry/MakeGeom3Ellipse.hpp>\n#include <geometry/MakeGeom3Hyperbola.hpp>\n#include <geometry/Geom2Line.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include<modeling/MakeEdge.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/MakeGeom2Parabola.hpp>\n#include <geometry/MakeGeom3Parabola.hpp>\n#include <geometry/Geom2BezierCurve.hpp>\n#include <geometry/Geom3BezierCurve.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2OffsetCurve.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\n#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/MakeGeom2Circle.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/ComputePointsAbscissa.hpp>\n#include <geometry/MakeGeom3Circle.hpp>\n#include <geometry/AdaptorGeom3Curve.hpp>\n#include <geometry/MakeGeom2Hyperbola.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/MakeGeom2Ellipse.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <geometry/MakeGeom3Ellipse.hpp>\n#include <geometry/MakeGeom3Hyperbola.hpp>\n#include <geometry/Geom2Line.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include<modeling/MakeEdge.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/MakeGeom2Parabola.hpp>\n#include <geometry/MakeGeom3Parabola.hpp>\n#include <geometry/Geom2BezierCurve.hpp>\n#include <geometry/Geom3BezierCurve.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2OffsetCurve.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\n;\n\tSECTION(\"circle\")\n    {\n        double r = 2.0;\n        double l = -1.0;\n        std::shared_ptr<Geom2Curve> c = MakeGeom2Circle(Point2(0.0, 0.0), 2.0).Value();\n        AdaptorGeom2Curve circle(c);\n        ComputePointsAbscissa cpa(circle, -1.0, 0.0);\n        double angle1 = l / r;\n        double x = r * cos(angle1);\n        double y = r * sin(angle1);\n        double param = cpa.Parameter();\n        Point2 s = circle.Value(param);\n        Point2 s1(x, y);\n        CHECK(angle1 == cpa.Parameter());\n        CHECK(s.X() == s1.X());\n        CHECK(s.Y() == s1.Y());\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API ComputePointsAbscissa(const Adaptor3Curve& c, double abscissa, double u0, double ui)\t @param ui The initial guess of the parameter\n\t @param u0 The starting parameter\n\t @param abscissa The arc length\n\t @param c The curve\n\t @brief Compute the parameter of a point on a 3D curve with given arc length and an initial guess\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/MakeGeom2Circle.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/ComputePointsAbscissa.hpp>\n#include <geometry/MakeGeom3Circle.hpp>\n#include <geometry/AdaptorGeom3Curve.hpp>\n#include <geometry/MakeGeom2Hyperbola.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/MakeGeom2Ellipse.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <geometry/MakeGeom3Ellipse.hpp>\n#include <geometry/MakeGeom3Hyperbola.hpp>\n#include <geometry/Geom2Line.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include<modeling/MakeEdge.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/MakeGeom2Parabola.hpp>\n#include <geometry/MakeGeom3Parabola.hpp>\n#include <geometry/Geom2BezierCurve.hpp>\n#include <geometry/Geom3BezierCurve.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2OffsetCurve.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\n#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/MakeGeom2Circle.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/ComputePointsAbscissa.hpp>\n#include <geometry/MakeGeom3Circle.hpp>\n#include <geometry/AdaptorGeom3Curve.hpp>\n#include <geometry/MakeGeom2Hyperbola.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/MakeGeom2Ellipse.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <geometry/MakeGeom3Ellipse.hpp>\n#include <geometry/MakeGeom3Hyperbola.hpp>\n#include <geometry/Geom2Line.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include<modeling/MakeEdge.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/MakeGeom2Parabola.hpp>\n#include <geometry/MakeGeom3Parabola.hpp>\n#include <geometry/Geom2BezierCurve.hpp>\n#include <geometry/Geom3BezierCurve.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2OffsetCurve.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\n;\n\tSECTION(\"circle\")\n    {\n        double r = 2.0;\n        double l = -1.0;\n        std::shared_ptr<Geom2Curve> c = MakeGeom2Circle(Point2(0.0, 0.0), 2.0).Value();\n        AdaptorGeom2Curve circle(c);\n        ComputePointsAbscissa cpa(circle, -1.0, 0.0);\n        double angle1 = l / r;\n        double x = r * cos(angle1);\n        double y = r * sin(angle1);\n        double param = cpa.Parameter();\n        Point2 s = circle.Value(param);\n        Point2 s1(x, y);\n        CHECK(angle1 == cpa.Parameter());\n        CHECK(s.X() == s1.X());\n        CHECK(s.Y() == s1.Y());\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API ComputePointsAbscissa(const Adaptor2Curve& c, double abscissa, double u0)\t @param u0 The starting parameter\n\t @param abscissa The arc length\n\t @param c The curve\n\t @brief Compute the parameter of a point on a 2D curve with given arc length\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/MakeGeom2Circle.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/ComputePointsAbscissa.hpp>\n#include <geometry/MakeGeom3Circle.hpp>\n#include <geometry/AdaptorGeom3Curve.hpp>\n#include <geometry/MakeGeom2Hyperbola.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/MakeGeom2Ellipse.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <geometry/MakeGeom3Ellipse.hpp>\n#include <geometry/MakeGeom3Hyperbola.hpp>\n#include <geometry/Geom2Line.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include<modeling/MakeEdge.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/MakeGeom2Parabola.hpp>\n#include <geometry/MakeGeom3Parabola.hpp>\n#include <geometry/Geom2BezierCurve.hpp>\n#include <geometry/Geom3BezierCurve.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2OffsetCurve.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\n#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/MakeGeom2Circle.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/ComputePointsAbscissa.hpp>\n#include <geometry/MakeGeom3Circle.hpp>\n#include <geometry/AdaptorGeom3Curve.hpp>\n#include <geometry/MakeGeom2Hyperbola.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/MakeGeom2Ellipse.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <geometry/MakeGeom3Ellipse.hpp>\n#include <geometry/MakeGeom3Hyperbola.hpp>\n#include <geometry/Geom2Line.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include<modeling/MakeEdge.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/MakeGeom2Parabola.hpp>\n#include <geometry/MakeGeom3Parabola.hpp>\n#include <geometry/Geom2BezierCurve.hpp>\n#include <geometry/Geom3BezierCurve.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2OffsetCurve.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\n;\n\tSECTION(\"circle\")\n    {\n        double r = 2.0;\n        double l = -1.0;\n        std::shared_ptr<Geom2Curve> c = MakeGeom2Circle(Point2(0.0, 0.0), 2.0).Value();\n        AdaptorGeom2Curve circle(c);\n        ComputePointsAbscissa cpa(circle, -1.0, 0.0);\n        double angle1 = l / r;\n        double x = r * cos(angle1);\n        double y = r * sin(angle1);\n        double param = cpa.Parameter();\n        Point2 s = circle.Value(param);\n        Point2 s1(x, y);\n        CHECK(angle1 == cpa.Parameter());\n        CHECK(s.X() == s1.X());\n        CHECK(s.Y() == s1.Y());\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API ComputePointsAbscissa(const Adaptor3Curve& c, double abscissa, double u0)\t @param u0 The starting parameter\n\t @param abscissa The arc length\n\t @param c The curve\n\t @brief Compute the parameter of a point on a 3D curve with given arc length\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/MakeGeom2Circle.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/ComputePointsAbscissa.hpp>\n#include <geometry/MakeGeom3Circle.hpp>\n#include <geometry/AdaptorGeom3Curve.hpp>\n#include <geometry/MakeGeom2Hyperbola.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/MakeGeom2Ellipse.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <geometry/MakeGeom3Ellipse.hpp>\n#include <geometry/MakeGeom3Hyperbola.hpp>\n#include <geometry/Geom2Line.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include<modeling/MakeEdge.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/MakeGeom2Parabola.hpp>\n#include <geometry/MakeGeom3Parabola.hpp>\n#include <geometry/Geom2BezierCurve.hpp>\n#include <geometry/Geom3BezierCurve.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2OffsetCurve.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\n#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/MakeGeom2Circle.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/ComputePointsAbscissa.hpp>\n#include <geometry/MakeGeom3Circle.hpp>\n#include <geometry/AdaptorGeom3Curve.hpp>\n#include <geometry/MakeGeom2Hyperbola.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/MakeGeom2Ellipse.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <geometry/MakeGeom3Ellipse.hpp>\n#include <geometry/MakeGeom3Hyperbola.hpp>\n#include <geometry/Geom2Line.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include<modeling/MakeEdge.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/MakeGeom2Parabola.hpp>\n#include <geometry/MakeGeom3Parabola.hpp>\n#include <geometry/Geom2BezierCurve.hpp>\n#include <geometry/Geom3BezierCurve.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2OffsetCurve.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\n;\n\tSECTION(\"circle\")\n    {\n        double r = 2.0;\n        double l = -1.0;\n        std::shared_ptr<Geom2Curve> c = MakeGeom2Circle(Point2(0.0, 0.0), 2.0).Value();\n        AdaptorGeom2Curve circle(c);\n        ComputePointsAbscissa cpa(circle, -1.0, 0.0);\n        double angle1 = l / r;\n        double x = r * cos(angle1);\n        double y = r * sin(angle1);\n        double param = cpa.Parameter();\n        Point2 s = circle.Value(param);\n        Point2 s1(x, y);\n        CHECK(angle1 == cpa.Parameter());\n        CHECK(s.X() == s1.X());\n        CHECK(s.Y() == s1.Y());\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API ComputePointsAbscissa(double tol, const Adaptor2Curve& c, double abscissa, double u0)\t @param u0 The starting parameter\n\t @param abscissa The arc length\n\t @param c The curve\n\t @param tol The tolerance\n\t @brief Compute the parameter of a point on a 2D curve with given arc length and a tolerance\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/MakeGeom2Circle.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/ComputePointsAbscissa.hpp>\n#include <geometry/MakeGeom3Circle.hpp>\n#include <geometry/AdaptorGeom3Curve.hpp>\n#include <geometry/MakeGeom2Hyperbola.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/MakeGeom2Ellipse.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <geometry/MakeGeom3Ellipse.hpp>\n#include <geometry/MakeGeom3Hyperbola.hpp>\n#include <geometry/Geom2Line.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include<modeling/MakeEdge.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/MakeGeom2Parabola.hpp>\n#include <geometry/MakeGeom3Parabola.hpp>\n#include <geometry/Geom2BezierCurve.hpp>\n#include <geometry/Geom3BezierCurve.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2OffsetCurve.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\n#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/MakeGeom2Circle.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/ComputePointsAbscissa.hpp>\n#include <geometry/MakeGeom3Circle.hpp>\n#include <geometry/AdaptorGeom3Curve.hpp>\n#include <geometry/MakeGeom2Hyperbola.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/MakeGeom2Ellipse.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <geometry/MakeGeom3Ellipse.hpp>\n#include <geometry/MakeGeom3Hyperbola.hpp>\n#include <geometry/Geom2Line.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include<modeling/MakeEdge.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/MakeGeom2Parabola.hpp>\n#include <geometry/MakeGeom3Parabola.hpp>\n#include <geometry/Geom2BezierCurve.hpp>\n#include <geometry/Geom3BezierCurve.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2OffsetCurve.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\n;\n\tSECTION(\"circle\")\n    {\n        double r = 2.0;\n        double l = -1.0;\n        std::shared_ptr<Geom2Curve> c = MakeGeom2Circle(Point2(0.0, 0.0), 2.0).Value();\n        AdaptorGeom2Curve circle(c);\n        ComputePointsAbscissa cpa(circle, -1.0, 0.0);\n        double angle1 = l / r;\n        double x = r * cos(angle1);\n        double y = r * sin(angle1);\n        double param = cpa.Parameter();\n        Point2 s = circle.Value(param);\n        Point2 s1(x, y);\n        CHECK(angle1 == cpa.Parameter());\n        CHECK(s.X() == s1.X());\n        CHECK(s.Y() == s1.Y());\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API ComputePointsAbscissa(double tol, const Adaptor3Curve& c, double abscissa, double u0)\t @param u0 The starting parameter\n\t @param abscissa The arc length\n\t @param c The curve\n\t @param tol The tolerance\n\t @brief Compute the parameter of a point on a 3D curve with given arc length and a tolerance\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/MakeGeom2Circle.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/ComputePointsAbscissa.hpp>\n#include <geometry/MakeGeom3Circle.hpp>\n#include <geometry/AdaptorGeom3Curve.hpp>\n#include <geometry/MakeGeom2Hyperbola.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/MakeGeom2Ellipse.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <geometry/MakeGeom3Ellipse.hpp>\n#include <geometry/MakeGeom3Hyperbola.hpp>\n#include <geometry/Geom2Line.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include<modeling/MakeEdge.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/MakeGeom2Parabola.hpp>\n#include <geometry/MakeGeom3Parabola.hpp>\n#include <geometry/Geom2BezierCurve.hpp>\n#include <geometry/Geom3BezierCurve.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2OffsetCurve.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\n#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/MakeGeom2Circle.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/ComputePointsAbscissa.hpp>\n#include <geometry/MakeGeom3Circle.hpp>\n#include <geometry/AdaptorGeom3Curve.hpp>\n#include <geometry/MakeGeom2Hyperbola.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/MakeGeom2Ellipse.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <geometry/MakeGeom3Ellipse.hpp>\n#include <geometry/MakeGeom3Hyperbola.hpp>\n#include <geometry/Geom2Line.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include<modeling/MakeEdge.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/MakeGeom2Parabola.hpp>\n#include <geometry/MakeGeom3Parabola.hpp>\n#include <geometry/Geom2BezierCurve.hpp>\n#include <geometry/Geom3BezierCurve.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2OffsetCurve.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\n;\n\tSECTION(\"circle\")\n    {\n        double r = 2.0;\n        double l = -1.0;\n        std::shared_ptr<Geom2Curve> c = MakeGeom2Circle(Point2(0.0, 0.0), 2.0).Value();\n        AdaptorGeom2Curve circle(c);\n        ComputePointsAbscissa cpa(circle, -1.0, 0.0);\n        double angle1 = l / r;\n        double x = r * cos(angle1);\n        double y = r * sin(angle1);\n        double param = cpa.Parameter();\n        Point2 s = circle.Value(param);\n        Point2 s1(x, y);\n        CHECK(angle1 == cpa.Parameter());\n        CHECK(s.X() == s1.X());\n        CHECK(s.Y() == s1.Y());\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static double Length(const Adaptor2Curve& c, double u1, double u2, double tol)\t @return The length of a curve in a given interval\n\t @param tol The tolerance\n\t @param u2 The last parameter\n\t @param u1 The first parameter\n\t @param c The curve\n\t @brief Compute the length of a 2D curve in a given interval with a tolerance\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/MakeGeom2Circle.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/ComputePointsAbscissa.hpp>\n#include <geometry/MakeGeom3Circle.hpp>\n#include <geometry/AdaptorGeom3Curve.hpp>\n#include <geometry/MakeGeom2Hyperbola.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/MakeGeom2Ellipse.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <geometry/MakeGeom3Ellipse.hpp>\n#include <geometry/MakeGeom3Hyperbola.hpp>\n#include <geometry/Geom2Line.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include<modeling/MakeEdge.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/MakeGeom2Parabola.hpp>\n#include <geometry/MakeGeom3Parabola.hpp>\n#include <geometry/Geom2BezierCurve.hpp>\n#include <geometry/Geom3BezierCurve.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2OffsetCurve.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\n#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/MakeGeom2Circle.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/ComputePointsAbscissa.hpp>\n#include <geometry/MakeGeom3Circle.hpp>\n#include <geometry/AdaptorGeom3Curve.hpp>\n#include <geometry/MakeGeom2Hyperbola.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/MakeGeom2Ellipse.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <geometry/MakeGeom3Ellipse.hpp>\n#include <geometry/MakeGeom3Hyperbola.hpp>\n#include <geometry/Geom2Line.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include<modeling/MakeEdge.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/MakeGeom2Parabola.hpp>\n#include <geometry/MakeGeom3Parabola.hpp>\n#include <geometry/Geom2BezierCurve.hpp>\n#include <geometry/Geom3BezierCurve.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2OffsetCurve.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\n;\n\tSECTION(\"circle\")\n    {\n        double r = 3.0;\n        double l = 2.0;\n        std::shared_ptr<Geom2Curve> c = MakeGeom2Circle(Point2(0.0, 0.0), 3.0).Value();\n        AdaptorGeom2Curve circle(c);\n        ComputePointsAbscissa cpa(circle, 2.0, 0.0, 1.5, Precision::Confusion());\n        double angle1 = l / r;\n        std::cout << \"ԲĽǵĻֵΪ\" << \": \" << angle1 << '\n';\n        double x = r * cos(angle1);\n        double y = r * sin(angle1);\n        std::cout << \"xֵΪ\" << \": \" << x << '\n';\n        std::cout << \"yֵΪ\" << \": \" << y << '\n';\n        double param = cpa.Parameter();\n        if (cpa.IsDone())\n        {\n            std::cout << param << \": \" << circle.Value(param) << '\n';\n        }\n        Point2 s = circle.Value(param);\n        Point2 s1(x, y);\n        std::cout << s << std::endl;\n        CHECK(s.X() == s1.X());\n        CHECK(s.Y() == s1.Y());\n        std::cout << \"ڶά߳Ϊ\" << ComputePointsAbscissa::Length(circle, 0.0, 0.666667) << '\n';\n        std::cout << \"ݲĶά߳Ϊ\" << ComputePointsAbscissa::Length(circle, 0.0, 0.666667, Precision::Confusion()) << '\n';\n        CHECK(angle1 == cpa.Parameter());\n        CHECK(ComputePointsAbscissa::Length(circle, 0.0, 0.6666666667) == Approx(l).margin(1e-2));\n        CHECK(ComputePointsAbscissa::Length(circle, 0.0, 0.6666666667, Precision::Confusion()) == Approx(l).margin(1e-2));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static double Length(const Adaptor3Curve& c, double u1, double u2, double tol)\t @return The length of a curve in a given interval\n\t @param tol The tolerance\n\t @param u2 The last parameter\n\t @param u1 The first parameter\n\t @param c The curve\n\t @brief Compute the length of a 3D curve in a given interval with a tolerance\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/MakeGeom2Circle.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/ComputePointsAbscissa.hpp>\n#include <geometry/MakeGeom3Circle.hpp>\n#include <geometry/AdaptorGeom3Curve.hpp>\n#include <geometry/MakeGeom2Hyperbola.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/MakeGeom2Ellipse.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <geometry/MakeGeom3Ellipse.hpp>\n#include <geometry/MakeGeom3Hyperbola.hpp>\n#include <geometry/Geom2Line.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include<modeling/MakeEdge.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/MakeGeom2Parabola.hpp>\n#include <geometry/MakeGeom3Parabola.hpp>\n#include <geometry/Geom2BezierCurve.hpp>\n#include <geometry/Geom3BezierCurve.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2OffsetCurve.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\n#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/MakeGeom2Circle.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/ComputePointsAbscissa.hpp>\n#include <geometry/MakeGeom3Circle.hpp>\n#include <geometry/AdaptorGeom3Curve.hpp>\n#include <geometry/MakeGeom2Hyperbola.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/MakeGeom2Ellipse.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <geometry/MakeGeom3Ellipse.hpp>\n#include <geometry/MakeGeom3Hyperbola.hpp>\n#include <geometry/Geom2Line.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include<modeling/MakeEdge.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/MakeGeom2Parabola.hpp>\n#include <geometry/MakeGeom3Parabola.hpp>\n#include <geometry/Geom2BezierCurve.hpp>\n#include <geometry/Geom3BezierCurve.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2OffsetCurve.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\n;\n\tSECTION(\"circle\")\n    {\n        double r = 3.0;\n        double l = 2.0;\n        std::shared_ptr<Geom2Curve> c = MakeGeom2Circle(Point2(0.0, 0.0), 3.0).Value();\n        AdaptorGeom2Curve circle(c);\n        ComputePointsAbscissa cpa(circle, 2.0, 0.0, 1.5, Precision::Confusion());\n        double angle1 = l / r;\n        std::cout << \"ԲĽǵĻֵΪ\" << \": \" << angle1 << '\n';\n        double x = r * cos(angle1);\n        double y = r * sin(angle1);\n        std::cout << \"xֵΪ\" << \": \" << x << '\n';\n        std::cout << \"yֵΪ\" << \": \" << y << '\n';\n        double param = cpa.Parameter();\n        if (cpa.IsDone())\n        {\n            std::cout << param << \": \" << circle.Value(param) << '\n';\n        }\n        Point2 s = circle.Value(param);\n        Point2 s1(x, y);\n        std::cout << s << std::endl;\n        CHECK(s.X() == s1.X());\n        CHECK(s.Y() == s1.Y());\n        std::cout << \"ڶά߳Ϊ\" << ComputePointsAbscissa::Length(circle, 0.0, 0.666667) << '\n';\n        std::cout << \"ݲĶά߳Ϊ\" << ComputePointsAbscissa::Length(circle, 0.0, 0.666667, Precision::Confusion()) << '\n';\n        CHECK(angle1 == cpa.Parameter());\n        CHECK(ComputePointsAbscissa::Length(circle, 0.0, 0.6666666667) == Approx(l).margin(1e-2));\n        CHECK(ComputePointsAbscissa::Length(circle, 0.0, 0.6666666667, Precision::Confusion()) == Approx(l).margin(1e-2));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static double Length(const Adaptor2Curve& c, double u1, double u2)\t @return The length of a curve in a given interval\n\t @param u2 The last parameter\n\t @param u1 The first parameter\n\t @param c The curve\n\t @brief Compute the length of a 2D curve in a given interval\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/MakeGeom2Circle.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/ComputePointsAbscissa.hpp>\n#include <geometry/MakeGeom3Circle.hpp>\n#include <geometry/AdaptorGeom3Curve.hpp>\n#include <geometry/MakeGeom2Hyperbola.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/MakeGeom2Ellipse.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <geometry/MakeGeom3Ellipse.hpp>\n#include <geometry/MakeGeom3Hyperbola.hpp>\n#include <geometry/Geom2Line.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include<modeling/MakeEdge.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/MakeGeom2Parabola.hpp>\n#include <geometry/MakeGeom3Parabola.hpp>\n#include <geometry/Geom2BezierCurve.hpp>\n#include <geometry/Geom3BezierCurve.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2OffsetCurve.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\n#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/MakeGeom2Circle.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/ComputePointsAbscissa.hpp>\n#include <geometry/MakeGeom3Circle.hpp>\n#include <geometry/AdaptorGeom3Curve.hpp>\n#include <geometry/MakeGeom2Hyperbola.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/MakeGeom2Ellipse.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <geometry/MakeGeom3Ellipse.hpp>\n#include <geometry/MakeGeom3Hyperbola.hpp>\n#include <geometry/Geom2Line.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include<modeling/MakeEdge.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/MakeGeom2Parabola.hpp>\n#include <geometry/MakeGeom3Parabola.hpp>\n#include <geometry/Geom2BezierCurve.hpp>\n#include <geometry/Geom3BezierCurve.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2OffsetCurve.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\n;\n\tSECTION(\"line\")\n    {\n        shared_ptr<Geom2Line> line;\n        line = make_shared<Geom2Line>(Point2(0.0, 0.0), Direction2(1.0, 0.0));\n        shared_ptr<Geom2TrimmedCurve> TrimmedCurve = make_shared<Geom2TrimmedCurve>(line, 0.0, 6.0);\n        AdaptorGeom2Curve line1(TrimmedCurve);\n        ComputePointsAbscissa cpa4(line1, 2.0, 0.0, 2.0, Precision::Confusion());\n        double param4 = cpa4.Parameter();\n        if (cpa4.IsDone())\n        {\n            std::cout << param4 << \": \" << line1.Value(param4) << '\n';\n        }\n        double x = 2.0;\n        double y = 0.0;\n        Point2 s5 = line1.Value(param4);\n        Point2 s6(x, y);\n        std::cout << s5 << std::endl;\n        CHECK(cpa4.Parameter() == 2.0);\n        CHECK(s5.X() == s6.X());\n        CHECK(s5.Y() == s6.Y());\n        std::cout << \"ڶά߳Ϊ\" << ComputePointsAbscissa::Length(line1, 0.0, 2.0) << '\n';\n        std::cout << \"ݲĶά߳Ϊ\" << ComputePointsAbscissa::Length(line1, 0.0, 3.0, Precision::Confusion()) << '\n';\n        CHECK(ComputePointsAbscissa::Length(line1, 0.0, 2.0) == 2.0);\n        CHECK(ComputePointsAbscissa::Length(line1, 0.0, 3.0, Precision::Confusion()) == 3.0);\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static double Length(const Adaptor3Curve& c, double u1, double u2)\t @return The length of a curve in a given interval\n\t @param u2 The last parameter\n\t @param u1 The first parameter\n\t @param c The curve\n\t @brief Compute the length of a 3D curve in a given interval\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/MakeGeom2Circle.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/ComputePointsAbscissa.hpp>\n#include <geometry/MakeGeom3Circle.hpp>\n#include <geometry/AdaptorGeom3Curve.hpp>\n#include <geometry/MakeGeom2Hyperbola.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/MakeGeom2Ellipse.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <geometry/MakeGeom3Ellipse.hpp>\n#include <geometry/MakeGeom3Hyperbola.hpp>\n#include <geometry/Geom2Line.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include<modeling/MakeEdge.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/MakeGeom2Parabola.hpp>\n#include <geometry/MakeGeom3Parabola.hpp>\n#include <geometry/Geom2BezierCurve.hpp>\n#include <geometry/Geom3BezierCurve.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2OffsetCurve.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\n#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/MakeGeom2Circle.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/ComputePointsAbscissa.hpp>\n#include <geometry/MakeGeom3Circle.hpp>\n#include <geometry/AdaptorGeom3Curve.hpp>\n#include <geometry/MakeGeom2Hyperbola.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/MakeGeom2Ellipse.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <geometry/MakeGeom3Ellipse.hpp>\n#include <geometry/MakeGeom3Hyperbola.hpp>\n#include <geometry/Geom2Line.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include<modeling/MakeEdge.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/MakeGeom2Parabola.hpp>\n#include <geometry/MakeGeom3Parabola.hpp>\n#include <geometry/Geom2BezierCurve.hpp>\n#include <geometry/Geom3BezierCurve.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2OffsetCurve.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\n;\n\tSECTION(\"line\")\n    {\n        shared_ptr<Geom2Line> line;\n        line = make_shared<Geom2Line>(Point2(0.0, 0.0), Direction2(1.0, 0.0));\n        shared_ptr<Geom2TrimmedCurve> TrimmedCurve = make_shared<Geom2TrimmedCurve>(line, 0.0, 6.0);\n        AdaptorGeom2Curve line1(TrimmedCurve);\n        ComputePointsAbscissa cpa4(line1, 2.0, 0.0, 2.0, Precision::Confusion());\n        double param4 = cpa4.Parameter();\n        if (cpa4.IsDone())\n        {\n            std::cout << param4 << \": \" << line1.Value(param4) << '\n';\n        }\n        double x = 2.0;\n        double y = 0.0;\n        Point2 s5 = line1.Value(param4);\n        Point2 s6(x, y);\n        std::cout << s5 << std::endl;\n        CHECK(cpa4.Parameter() == 2.0);\n        CHECK(s5.X() == s6.X());\n        CHECK(s5.Y() == s6.Y());\n        std::cout << \"ڶά߳Ϊ\" << ComputePointsAbscissa::Length(line1, 0.0, 2.0) << '\n';\n        std::cout << \"ݲĶά߳Ϊ\" << ComputePointsAbscissa::Length(line1, 0.0, 3.0, Precision::Confusion()) << '\n';\n        CHECK(ComputePointsAbscissa::Length(line1, 0.0, 2.0) == 2.0);\n        CHECK(ComputePointsAbscissa::Length(line1, 0.0, 3.0, Precision::Confusion()) == 3.0);\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static double Length(const Adaptor2Curve& c, double tol)\t @return The length of a curve\n\t @param tol The tolerance\n\t @param c The curve\n\t @brief Compute the length of a 2D curve with a tolerance\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/MakeGeom2Circle.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/ComputePointsAbscissa.hpp>\n#include <geometry/MakeGeom3Circle.hpp>\n#include <geometry/AdaptorGeom3Curve.hpp>\n#include <geometry/MakeGeom2Hyperbola.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/MakeGeom2Ellipse.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <geometry/MakeGeom3Ellipse.hpp>\n#include <geometry/MakeGeom3Hyperbola.hpp>\n#include <geometry/Geom2Line.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include<modeling/MakeEdge.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/MakeGeom2Parabola.hpp>\n#include <geometry/MakeGeom3Parabola.hpp>\n#include <geometry/Geom2BezierCurve.hpp>\n#include <geometry/Geom3BezierCurve.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2OffsetCurve.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\n#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/MakeGeom2Circle.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/ComputePointsAbscissa.hpp>\n#include <geometry/MakeGeom3Circle.hpp>\n#include <geometry/AdaptorGeom3Curve.hpp>\n#include <geometry/MakeGeom2Hyperbola.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/MakeGeom2Ellipse.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <geometry/MakeGeom3Ellipse.hpp>\n#include <geometry/MakeGeom3Hyperbola.hpp>\n#include <geometry/Geom2Line.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include<modeling/MakeEdge.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/MakeGeom2Parabola.hpp>\n#include <geometry/MakeGeom3Parabola.hpp>\n#include <geometry/Geom2BezierCurve.hpp>\n#include <geometry/Geom3BezierCurve.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2OffsetCurve.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\n;\n\tSECTION(\"circle\")\n    {\n        double r = 3.0;\n        double l = 2.0;\n        std::shared_ptr<Geom2Curve> c = MakeGeom2Circle(Point2(0.0, 0.0), 3.0).Value();\n        AdaptorGeom2Curve circle(c);\n        ComputePointsAbscissa cpa(Precision::Confusion(), circle, 2.0, 0.0);\n        double angle1 = l / r;\n        std::cout << \"ԲĽǵĻֵΪ\" << \": \" << angle1 << '\n';\n        double x = r * cos(angle1);\n        double y = r * sin(angle1);\n        std::cout << \"xֵΪ\" << \": \" << x << '\n';\n        std::cout << \"yֵΪ\" << \": \" << y << '\n';\n        double param = cpa.Parameter();\n        if (cpa.IsDone())\n        {\n            std::cout << param << \": \" << circle.Value(param) << '\n';\n        }\n        double p = 2 * M_PI * r;\n        std::cout << \"߳Ϊ\" << ComputePointsAbscissa::Length(circle, Precision::Confusion()) << '\n';\n        Point2 s = circle.Value(param);\n        Point2 s1(x, y);\n        std::cout << s << std::endl;\n        CHECK(s.X() == s1.X());\n        CHECK(s.Y() == s1.Y());\n        CHECK(ComputePointsAbscissa::Length(circle, Precision::Confusion()) == p);\n        CHECK(angle1 == cpa.Parameter());\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static double Length(const Adaptor3Curve& c, double tol)\t @return The length of a curve\n\t @param tol The tolerance\n\t @param c The curve\n\t @brief Compute the length of a 3D curve with a tolerance\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/MakeGeom2Circle.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/ComputePointsAbscissa.hpp>\n#include <geometry/MakeGeom3Circle.hpp>\n#include <geometry/AdaptorGeom3Curve.hpp>\n#include <geometry/MakeGeom2Hyperbola.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/MakeGeom2Ellipse.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <geometry/MakeGeom3Ellipse.hpp>\n#include <geometry/MakeGeom3Hyperbola.hpp>\n#include <geometry/Geom2Line.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include<modeling/MakeEdge.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/MakeGeom2Parabola.hpp>\n#include <geometry/MakeGeom3Parabola.hpp>\n#include <geometry/Geom2BezierCurve.hpp>\n#include <geometry/Geom3BezierCurve.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2OffsetCurve.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\n#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/MakeGeom2Circle.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/ComputePointsAbscissa.hpp>\n#include <geometry/MakeGeom3Circle.hpp>\n#include <geometry/AdaptorGeom3Curve.hpp>\n#include <geometry/MakeGeom2Hyperbola.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/MakeGeom2Ellipse.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <geometry/MakeGeom3Ellipse.hpp>\n#include <geometry/MakeGeom3Hyperbola.hpp>\n#include <geometry/Geom2Line.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include<modeling/MakeEdge.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/MakeGeom2Parabola.hpp>\n#include <geometry/MakeGeom3Parabola.hpp>\n#include <geometry/Geom2BezierCurve.hpp>\n#include <geometry/Geom3BezierCurve.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2OffsetCurve.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\n;\n\tSECTION(\"circle\")\n    {\n        double r = 3.0;\n        double l = 2.0;\n        std::shared_ptr<Geom2Curve> c = MakeGeom2Circle(Point2(0.0, 0.0), 3.0).Value();\n        AdaptorGeom2Curve circle(c);\n        ComputePointsAbscissa cpa(Precision::Confusion(), circle, 2.0, 0.0);\n        double angle1 = l / r;\n        std::cout << \"ԲĽǵĻֵΪ\" << \": \" << angle1 << '\n';\n        double x = r * cos(angle1);\n        double y = r * sin(angle1);\n        std::cout << \"xֵΪ\" << \": \" << x << '\n';\n        std::cout << \"yֵΪ\" << \": \" << y << '\n';\n        double param = cpa.Parameter();\n        if (cpa.IsDone())\n        {\n            std::cout << param << \": \" << circle.Value(param) << '\n';\n        }\n        double p = 2 * M_PI * r;\n        std::cout << \"߳Ϊ\" << ComputePointsAbscissa::Length(circle, Precision::Confusion()) << '\n';\n        Point2 s = circle.Value(param);\n        Point2 s1(x, y);\n        std::cout << s << std::endl;\n        CHECK(s.X() == s1.X());\n        CHECK(s.Y() == s1.Y());\n        CHECK(ComputePointsAbscissa::Length(circle, Precision::Confusion()) == p);\n        CHECK(angle1 == cpa.Parameter());\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static double Length(const Adaptor2Curve& c)\t @return The length of a curve\n\t @param c The curve\n\t @brief Compute the length of a 2D curve\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/MakeGeom2Circle.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/ComputePointsAbscissa.hpp>\n#include <geometry/MakeGeom3Circle.hpp>\n#include <geometry/AdaptorGeom3Curve.hpp>\n#include <geometry/MakeGeom2Hyperbola.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/MakeGeom2Ellipse.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <geometry/MakeGeom3Ellipse.hpp>\n#include <geometry/MakeGeom3Hyperbola.hpp>\n#include <geometry/Geom2Line.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include<modeling/MakeEdge.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/MakeGeom2Parabola.hpp>\n#include <geometry/MakeGeom3Parabola.hpp>\n#include <geometry/Geom2BezierCurve.hpp>\n#include <geometry/Geom3BezierCurve.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2OffsetCurve.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\n#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/MakeGeom2Circle.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/ComputePointsAbscissa.hpp>\n#include <geometry/MakeGeom3Circle.hpp>\n#include <geometry/AdaptorGeom3Curve.hpp>\n#include <geometry/MakeGeom2Hyperbola.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/MakeGeom2Ellipse.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <geometry/MakeGeom3Ellipse.hpp>\n#include <geometry/MakeGeom3Hyperbola.hpp>\n#include <geometry/Geom2Line.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include<modeling/MakeEdge.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/MakeGeom2Parabola.hpp>\n#include <geometry/MakeGeom3Parabola.hpp>\n#include <geometry/Geom2BezierCurve.hpp>\n#include <geometry/Geom3BezierCurve.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2OffsetCurve.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\n;\n\tSECTION(\"line\")\n    {\n        shared_ptr<Geom2Line> line;\n        line = make_shared<Geom2Line>(Point2(0.0, 0.0), Direction2(1.0, 0.0));\n        shared_ptr<Geom2TrimmedCurve> TrimmedCurve = make_shared<Geom2TrimmedCurve>(line, 0.0, 6.0);\n        AdaptorGeom2Curve line1(TrimmedCurve);\n        ComputePointsAbscissa cpa4(line1, 2.0, 0.0);\n        double param4 = cpa4.Parameter();\n        if (cpa4.IsDone())\n        {\n            std::cout << param4 << \": \" << line1.Value(param4) << '\n';\n        }\n        double x = 2.0;\n        double y = 0.0;\n        Point2 s5 = line1.Value(param4);\n        Point2 s6(x, y);\n        std::cout << s5 << std::endl;\n        CHECK(cpa4.Parameter() == 2.0);\n        CHECK(s5.X() == s6.X());\n        CHECK(s5.Y() == s6.Y());\n        std::cout << \"߳Ϊ\" << ComputePointsAbscissa::Length(line1) << '\n';\n        CHECK(ComputePointsAbscissa::Length(line1) == 6.0);\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static double Length(const Adaptor3Curve& c)\t @return The length of a curve\n\t @param c The curve\n\t @brief Compute the length of a 3D curve\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/MakeGeom2Circle.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/ComputePointsAbscissa.hpp>\n#include <geometry/MakeGeom3Circle.hpp>\n#include <geometry/AdaptorGeom3Curve.hpp>\n#include <geometry/MakeGeom2Hyperbola.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/MakeGeom2Ellipse.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <geometry/MakeGeom3Ellipse.hpp>\n#include <geometry/MakeGeom3Hyperbola.hpp>\n#include <geometry/Geom2Line.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include<modeling/MakeEdge.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/MakeGeom2Parabola.hpp>\n#include <geometry/MakeGeom3Parabola.hpp>\n#include <geometry/Geom2BezierCurve.hpp>\n#include <geometry/Geom3BezierCurve.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2OffsetCurve.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\n#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/MakeGeom2Circle.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/ComputePointsAbscissa.hpp>\n#include <geometry/MakeGeom3Circle.hpp>\n#include <geometry/AdaptorGeom3Curve.hpp>\n#include <geometry/MakeGeom2Hyperbola.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/MakeGeom2Ellipse.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <geometry/MakeGeom3Ellipse.hpp>\n#include <geometry/MakeGeom3Hyperbola.hpp>\n#include <geometry/Geom2Line.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include<modeling/MakeEdge.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/MakeGeom2Parabola.hpp>\n#include <geometry/MakeGeom3Parabola.hpp>\n#include <geometry/Geom2BezierCurve.hpp>\n#include <geometry/Geom3BezierCurve.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2OffsetCurve.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\n;\n\tSECTION(\"line\")\n    {\n        shared_ptr<Geom2Line> line;\n        line = make_shared<Geom2Line>(Point2(0.0, 0.0), Direction2(1.0, 0.0));\n        shared_ptr<Geom2TrimmedCurve> TrimmedCurve = make_shared<Geom2TrimmedCurve>(line, 0.0, 6.0);\n        AdaptorGeom2Curve line1(TrimmedCurve);\n        ComputePointsAbscissa cpa4(Precision::Confusion(), line1, 2.0, 0.0);\n        double param4 = cpa4.Parameter();\n        if (cpa4.IsDone())\n        {\n            std::cout << param4 << \": \" << line1.Value(param4) << '\n';\n        }\n        double x = 2.0;\n        double y = 0.0;\n        Point2 s5 = line1.Value(param4);\n        Point2 s6(x, y);\n        std::cout << s5 << std::endl;\n        CHECK(cpa4.Parameter() == 2.0);\n        CHECK(s5.X() == s6.X());\n        CHECK(s5.Y() == s6.Y());\n        std::cout << \"߳Ϊ\" << ComputePointsAbscissa::Length(line1, Precision::Confusion()) << '\n';\n        CHECK(ComputePointsAbscissa::Length(line1, Precision::Confusion()) == 6.0);\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API double Parameter()\t @return The parameter of the point\n\t @brief Get the parameter of the point\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/MakeGeom2Circle.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/ComputePointsAbscissa.hpp>\n#include <geometry/MakeGeom3Circle.hpp>\n#include <geometry/AdaptorGeom3Curve.hpp>\n#include <geometry/MakeGeom2Hyperbola.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/MakeGeom2Ellipse.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <geometry/MakeGeom3Ellipse.hpp>\n#include <geometry/MakeGeom3Hyperbola.hpp>\n#include <geometry/Geom2Line.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include<modeling/MakeEdge.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/MakeGeom2Parabola.hpp>\n#include <geometry/MakeGeom3Parabola.hpp>\n#include <geometry/Geom2BezierCurve.hpp>\n#include <geometry/Geom3BezierCurve.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2OffsetCurve.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\n#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/MakeGeom2Circle.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/ComputePointsAbscissa.hpp>\n#include <geometry/MakeGeom3Circle.hpp>\n#include <geometry/AdaptorGeom3Curve.hpp>\n#include <geometry/MakeGeom2Hyperbola.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/MakeGeom2Ellipse.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <geometry/MakeGeom3Ellipse.hpp>\n#include <geometry/MakeGeom3Hyperbola.hpp>\n#include <geometry/Geom2Line.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include<modeling/MakeEdge.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/MakeGeom2Parabola.hpp>\n#include <geometry/MakeGeom3Parabola.hpp>\n#include <geometry/Geom2BezierCurve.hpp>\n#include <geometry/Geom3BezierCurve.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2OffsetCurve.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\n;\n\tSECTION(\"line\")\n    {\n        shared_ptr<Geom2Line> line;\n        line = make_shared<Geom2Line>(Point2(0.0, 0.0), Direction2(1.0, 0.0));\n        shared_ptr<Geom2TrimmedCurve> TrimmedCurve = make_shared<Geom2TrimmedCurve>(line, 0.0, 6.0);\n        AdaptorGeom2Curve line1(TrimmedCurve);\n        ComputePointsAbscissa cpa4(line1, 2.0, 0.0);\n        double param4 = cpa4.Parameter();\n        if (cpa4.IsDone())\n        {\n            std::cout << param4 << \": \" << line1.Value(param4) << '\n';\n        }\n        double x = 2.0;\n        double y = 0.0;\n        Point2 s5 = line1.Value(param4);\n        Point2 s6(x, y);\n        std::cout << s5 << std::endl;\n        CHECK(cpa4.Parameter() == 2.0);\n        CHECK(s5.X() == s6.X());\n        CHECK(s5.Y() == s6.Y());\n        std::cout << \"߳Ϊ\" << ComputePointsAbscissa::Length(line1) << '\n';\n        CHECK(ComputePointsAbscissa::Length(line1) == 6.0);\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API ComputePointsAbscissa(const Adaptor2Curve& c, double abscissa, double u0, double ui, double tol)\t @param tol The tolerance\n\t @param ui The initial guess of the parameter\n\t @param u0 The starting parameter\n\t @param abscissa The arc length\n\t @param c The curve\n\t @brief Compute the parameter of a point on a 2D curve with given arc length, an initial guess, and a tolerance\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/MakeGeom2Circle.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/ComputePointsAbscissa.hpp>\n#include <geometry/MakeGeom3Circle.hpp>\n#include <geometry/AdaptorGeom3Curve.hpp>\n#include <geometry/MakeGeom2Hyperbola.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/MakeGeom2Ellipse.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <geometry/MakeGeom3Ellipse.hpp>\n#include <geometry/MakeGeom3Hyperbola.hpp>\n#include <geometry/Geom2Line.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include<modeling/MakeEdge.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/MakeGeom2Parabola.hpp>\n#include <geometry/MakeGeom3Parabola.hpp>\n#include <geometry/Geom2BezierCurve.hpp>\n#include <geometry/Geom3BezierCurve.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2OffsetCurve.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\n#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/MakeGeom2Circle.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/ComputePointsAbscissa.hpp>\n#include <geometry/MakeGeom3Circle.hpp>\n#include <geometry/AdaptorGeom3Curve.hpp>\n#include <geometry/MakeGeom2Hyperbola.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/MakeGeom2Ellipse.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <geometry/MakeGeom3Ellipse.hpp>\n#include <geometry/MakeGeom3Hyperbola.hpp>\n#include <geometry/Geom2Line.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include<modeling/MakeEdge.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/MakeGeom2Parabola.hpp>\n#include <geometry/MakeGeom3Parabola.hpp>\n#include <geometry/Geom2BezierCurve.hpp>\n#include <geometry/Geom3BezierCurve.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2OffsetCurve.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\n;\n\tSECTION(\"circle\")\n    {\n        double r = 2.0;\n        double l = 1.0;\n        std::shared_ptr<Geom2Curve> c = MakeGeom2Circle(Point2(0.0, 0.0), 2.0).Value();\n        AdaptorGeom2Curve circle(c);\n        ComputePointsAbscissa cpa(circle, 1.0, 0.0);\n        double angle1 = l / r;\n        std::cout << \"ԲĽǵĻֵΪ\" << \": \" << angle1 << '\n';\n        double x = r * cos(angle1);\n        double y = r * sin(angle1);\n        std::cout << \"xֵΪ\" << \": \" << x << '\n';\n        std::cout << \"yֵΪ\" << \": \" << y << '\n';\n        double param = cpa.Parameter();\n        if (cpa.IsDone())\n        {\n            std::cout << param << \": \" << circle.Value(param) << '\n';\n        }\n        double p = 2 * M_PI * r;\n        std::cout << \"߳Ϊ\" << ComputePointsAbscissa::Length(circle) << '\n';\n        Point2 s = circle.Value(param);\n        Point2 s1(x, y);\n        std::cout << s << std::endl;\n        CHECK(p == ComputePointsAbscissa::Length(circle));\n        CHECK(angle1 == cpa.Parameter());\n        CHECK(s.X() == s1.X());\n        CHECK(s.Y() == s1.Y());\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API ComputePointsAbscissa(const Adaptor3Curve& c, double abscissa, double u0, double ui, double tol)\t @param tol The tolerance\n\t @param ui The initial guess of the parameter\n\t @param u0 The starting parameter\n\t @param abscissa The arc length\n\t @param c The curve\n\t @brief Compute the parameter of a point on a 3D curve with given arc length, an initial guess, and a tolerance\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/MakeGeom2Circle.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/ComputePointsAbscissa.hpp>\n#include <geometry/MakeGeom3Circle.hpp>\n#include <geometry/AdaptorGeom3Curve.hpp>\n#include <geometry/MakeGeom2Hyperbola.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/MakeGeom2Ellipse.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <geometry/MakeGeom3Ellipse.hpp>\n#include <geometry/MakeGeom3Hyperbola.hpp>\n#include <geometry/Geom2Line.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include<modeling/MakeEdge.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/MakeGeom2Parabola.hpp>\n#include <geometry/MakeGeom3Parabola.hpp>\n#include <geometry/Geom2BezierCurve.hpp>\n#include <geometry/Geom3BezierCurve.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2OffsetCurve.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\n#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/MakeGeom2Circle.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/ComputePointsAbscissa.hpp>\n#include <geometry/MakeGeom3Circle.hpp>\n#include <geometry/AdaptorGeom3Curve.hpp>\n#include <geometry/MakeGeom2Hyperbola.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/MakeGeom2Ellipse.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <geometry/MakeGeom3Ellipse.hpp>\n#include <geometry/MakeGeom3Hyperbola.hpp>\n#include <geometry/Geom2Line.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include<modeling/MakeEdge.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/MakeGeom2Parabola.hpp>\n#include <geometry/MakeGeom3Parabola.hpp>\n#include <geometry/Geom2BezierCurve.hpp>\n#include <geometry/Geom3BezierCurve.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2OffsetCurve.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\n;\n\tSECTION(\"ellipse\")\n    {\n        Axis2 axis;\n        double major = 5.0;\n        double minor = 4.0;\n        bool isRight = true;\n        std::shared_ptr< Geom2Ellipse >g2e = MakeGeom2Ellipse(axis, major, minor, isRight);\n        AdaptorGeom2Curve ellipse(g2e);\n        double t = minor / major;\n        std::cout << \"t\" << t << '\n';\n        double T = 3.15129643210828;\n        double L = T * (minor + major);\n        std::cout << \"L\" << L << '\n';\n        ComputePointsAbscissa cpa2(ellipse, L, 0.0);\n        double param2 = cpa2.Parameter();\n        if (cpa2.IsDone())\n        {\n            std::cout << param2 << \": \" << ellipse.Value(param2) << '\n';\n        }\n        Point2 s2 = ellipse.Value(param2);\n        Point2 s3(5.0, 0.0);\n        std::cout << s2 << std::endl;\n        CHECK(s2.X() == Approx(s3.X()).margin(1e-2));\n        CHECK(s2.Y() == Approx(s3.Y()).margin(1e-2));\n        std::cout << \"߳Ϊ\" << ComputePointsAbscissa::Length(ellipse) << '\n';\n        CHECK(ComputePointsAbscissa::Length(ellipse) == Approx(L).margin(1e-2));\n        CHECK(cpa2.Parameter() == Approx(2 * M_PI).margin(1e-2));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API ComputePointsAbscissa(const Adaptor2Curve& c, double abscissa, double u0, double ui)\t @param ui The initial guess of the parameter\n\t @param u0 The starting parameter\n\t @param abscissa The arc length\n\t @param c The curve\n\t @brief Compute the parameter of a point on a 2D curve with given arc length and an initial guess\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/MakeGeom2Circle.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/ComputePointsAbscissa.hpp>\n#include <geometry/MakeGeom3Circle.hpp>\n#include <geometry/AdaptorGeom3Curve.hpp>\n#include <geometry/MakeGeom2Hyperbola.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/MakeGeom2Ellipse.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <geometry/MakeGeom3Ellipse.hpp>\n#include <geometry/MakeGeom3Hyperbola.hpp>\n#include <geometry/Geom2Line.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include<modeling/MakeEdge.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/MakeGeom2Parabola.hpp>\n#include <geometry/MakeGeom3Parabola.hpp>\n#include <geometry/Geom2BezierCurve.hpp>\n#include <geometry/Geom3BezierCurve.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2OffsetCurve.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\n#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/MakeGeom2Circle.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/ComputePointsAbscissa.hpp>\n#include <geometry/MakeGeom3Circle.hpp>\n#include <geometry/AdaptorGeom3Curve.hpp>\n#include <geometry/MakeGeom2Hyperbola.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/MakeGeom2Ellipse.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <geometry/MakeGeom3Ellipse.hpp>\n#include <geometry/MakeGeom3Hyperbola.hpp>\n#include <geometry/Geom2Line.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include<modeling/MakeEdge.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/MakeGeom2Parabola.hpp>\n#include <geometry/MakeGeom3Parabola.hpp>\n#include <geometry/Geom2BezierCurve.hpp>\n#include <geometry/Geom3BezierCurve.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2OffsetCurve.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\n;\n\tSECTION(\"ellipse\")\n    {\n        Axis2 axis;\n        double major = 5.0;\n        double minor = 4.0;\n        bool isRight = true;\n        std::shared_ptr< Geom2Ellipse >g2e = MakeGeom2Ellipse(axis, major, minor, isRight);\n        AdaptorGeom2Curve ellipse(g2e);\n        double t = minor / major;\n        std::cout << \"t\" << t << '\n';\n        double T = 3.15129643210828;\n        double L = T * (minor + major);\n        std::cout << \"L\" << L << '\n';\n        ComputePointsAbscissa cpa2(ellipse, L, 0.0);\n        double param2 = cpa2.Parameter();\n        if (cpa2.IsDone())\n        {\n            std::cout << param2 << \": \" << ellipse.Value(param2) << '\n';\n        }\n        Point2 s2 = ellipse.Value(param2);\n        Point2 s3(5.0, 0.0);\n        std::cout << s2 << std::endl;\n        CHECK(s2.X() == Approx(s3.X()).margin(1e-2));\n        CHECK(s2.Y() == Approx(s3.Y()).margin(1e-2));\n        std::cout << \"߳Ϊ\" << ComputePointsAbscissa::Length(ellipse) << '\n';\n        CHECK(ComputePointsAbscissa::Length(ellipse) == Approx(L).margin(1e-2));\n        CHECK(cpa2.Parameter() == Approx(2 * M_PI).margin(1e-2));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API ComputePointsAbscissa(const Adaptor3Curve& c, double abscissa, double u0, double ui)\t @param ui The initial guess of the parameter\n\t @param u0 The starting parameter\n\t @param abscissa The arc length\n\t @param c The curve\n\t @brief Compute the parameter of a point on a 3D curve with given arc length and an initial guess\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/MakeGeom2Circle.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/ComputePointsAbscissa.hpp>\n#include <geometry/MakeGeom3Circle.hpp>\n#include <geometry/AdaptorGeom3Curve.hpp>\n#include <geometry/MakeGeom2Hyperbola.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/MakeGeom2Ellipse.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <geometry/MakeGeom3Ellipse.hpp>\n#include <geometry/MakeGeom3Hyperbola.hpp>\n#include <geometry/Geom2Line.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include<modeling/MakeEdge.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/MakeGeom2Parabola.hpp>\n#include <geometry/MakeGeom3Parabola.hpp>\n#include <geometry/Geom2BezierCurve.hpp>\n#include <geometry/Geom3BezierCurve.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2OffsetCurve.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\n#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/MakeGeom2Circle.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/ComputePointsAbscissa.hpp>\n#include <geometry/MakeGeom3Circle.hpp>\n#include <geometry/AdaptorGeom3Curve.hpp>\n#include <geometry/MakeGeom2Hyperbola.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/MakeGeom2Ellipse.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <geometry/MakeGeom3Ellipse.hpp>\n#include <geometry/MakeGeom3Hyperbola.hpp>\n#include <geometry/Geom2Line.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include<modeling/MakeEdge.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/MakeGeom2Parabola.hpp>\n#include <geometry/MakeGeom3Parabola.hpp>\n#include <geometry/Geom2BezierCurve.hpp>\n#include <geometry/Geom3BezierCurve.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2OffsetCurve.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\n;\n\tSECTION(\"ellipse\")\n    {\n        Axis2 axis;\n        double major = 5.0;\n        double minor = 4.0;\n        bool isRight = true;\n        std::shared_ptr< Geom2Ellipse >g2e = MakeGeom2Ellipse(axis, major, minor, isRight);\n        AdaptorGeom2Curve ellipse(g2e);\n        double t = minor / major;\n        std::cout << \"t\" << t << '\n';\n        double T = 3.15129643210828;\n        double L = T * (minor + major);\n        std::cout << \"L\" << L << '\n';\n        ComputePointsAbscissa cpa2(ellipse, L, 0.0);\n        double param2 = cpa2.Parameter();\n        if (cpa2.IsDone())\n        {\n            std::cout << param2 << \": \" << ellipse.Value(param2) << '\n';\n        }\n        Point2 s2 = ellipse.Value(param2);\n        Point2 s3(5.0, 0.0);\n        std::cout << s2 << std::endl;\n        CHECK(s2.X() == Approx(s3.X()).margin(1e-2));\n        CHECK(s2.Y() == Approx(s3.Y()).margin(1e-2));\n        std::cout << \"߳Ϊ\" << ComputePointsAbscissa::Length(ellipse) << '\n';\n        CHECK(ComputePointsAbscissa::Length(ellipse) == Approx(L).margin(1e-2));\n        CHECK(cpa2.Parameter() == Approx(2 * M_PI).margin(1e-2));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API ComputePointsAbscissa(const Adaptor2Curve& c, double abscissa, double u0)\t @param u0 The starting parameter\n\t @param abscissa The arc length\n\t @param c The curve\n\t @brief Compute the parameter of a point on a 2D curve with given arc length\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/MakeGeom2Circle.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/ComputePointsAbscissa.hpp>\n#include <geometry/MakeGeom3Circle.hpp>\n#include <geometry/AdaptorGeom3Curve.hpp>\n#include <geometry/MakeGeom2Hyperbola.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/MakeGeom2Ellipse.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <geometry/MakeGeom3Ellipse.hpp>\n#include <geometry/MakeGeom3Hyperbola.hpp>\n#include <geometry/Geom2Line.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include<modeling/MakeEdge.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/MakeGeom2Parabola.hpp>\n#include <geometry/MakeGeom3Parabola.hpp>\n#include <geometry/Geom2BezierCurve.hpp>\n#include <geometry/Geom3BezierCurve.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2OffsetCurve.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\n#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/MakeGeom2Circle.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/ComputePointsAbscissa.hpp>\n#include <geometry/MakeGeom3Circle.hpp>\n#include <geometry/AdaptorGeom3Curve.hpp>\n#include <geometry/MakeGeom2Hyperbola.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/MakeGeom2Ellipse.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <geometry/MakeGeom3Ellipse.hpp>\n#include <geometry/MakeGeom3Hyperbola.hpp>\n#include <geometry/Geom2Line.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include<modeling/MakeEdge.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/MakeGeom2Parabola.hpp>\n#include <geometry/MakeGeom3Parabola.hpp>\n#include <geometry/Geom2BezierCurve.hpp>\n#include <geometry/Geom3BezierCurve.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2OffsetCurve.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\n;\n\tSECTION(\"circle\")\n    {\n        double r = 2.0;\n        double l = 1.0;\n        std::shared_ptr<Geom2Curve> c = MakeGeom2Circle(Point2(0.0, 0.0), 2.0).Value();\n        AdaptorGeom2Curve circle(c);\n        ComputePointsAbscissa cpa(circle, 1.0, 0.0);\n        double angle1 = l / r;\n        std::cout << \"ԲĽǵĻֵΪ\" << \": \" << angle1 << '\n';\n        double x = r * cos(angle1);\n        double y = r * sin(angle1);\n        std::cout << \"xֵΪ\" << \": \" << x << '\n';\n        std::cout << \"yֵΪ\" << \": \" << y << '\n';\n        double param = cpa.Parameter();\n        if (cpa.IsDone())\n        {\n            std::cout << param << \": \" << circle.Value(param) << '\n';\n        }\n        double p = 2 * M_PI * r;\n        std::cout << \"߳Ϊ\" << ComputePointsAbscissa::Length(circle) << '\n';\n        Point2 s = circle.Value(param);\n        Point2 s1(x, y);\n        std::cout << s << std::endl;\n        CHECK(p == ComputePointsAbscissa::Length(circle));\n        CHECK(angle1 == cpa.Parameter());\n        CHECK(s.X() == s1.X());\n        CHECK(s.Y() == s1.Y());\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API ComputePointsAbscissa(const Adaptor3Curve& c, double abscissa, double u0)\t @param u0 The starting parameter\n\t @param abscissa The arc length\n\t @param c The curve\n\t @brief Compute the parameter of a point on a 3D curve with given arc length\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/MakeGeom2Circle.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/ComputePointsAbscissa.hpp>\n#include <geometry/MakeGeom3Circle.hpp>\n#include <geometry/AdaptorGeom3Curve.hpp>\n#include <geometry/MakeGeom2Hyperbola.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/MakeGeom2Ellipse.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <geometry/MakeGeom3Ellipse.hpp>\n#include <geometry/MakeGeom3Hyperbola.hpp>\n#include <geometry/Geom2Line.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include<modeling/MakeEdge.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/MakeGeom2Parabola.hpp>\n#include <geometry/MakeGeom3Parabola.hpp>\n#include <geometry/Geom2BezierCurve.hpp>\n#include <geometry/Geom3BezierCurve.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2OffsetCurve.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\n#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/MakeGeom2Circle.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/ComputePointsAbscissa.hpp>\n#include <geometry/MakeGeom3Circle.hpp>\n#include <geometry/AdaptorGeom3Curve.hpp>\n#include <geometry/MakeGeom2Hyperbola.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/MakeGeom2Ellipse.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <geometry/MakeGeom3Ellipse.hpp>\n#include <geometry/MakeGeom3Hyperbola.hpp>\n#include <geometry/Geom2Line.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include<modeling/MakeEdge.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/MakeGeom2Parabola.hpp>\n#include <geometry/MakeGeom3Parabola.hpp>\n#include <geometry/Geom2BezierCurve.hpp>\n#include <geometry/Geom3BezierCurve.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2OffsetCurve.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\n;\n\tSECTION(\"circle\")\n    {\n        double r = 2.0;\n        double l = 1.0;\n        std::shared_ptr<Geom2Curve> c = MakeGeom2Circle(Point2(0.0, 0.0), 2.0).Value();\n        AdaptorGeom2Curve circle(c);\n        ComputePointsAbscissa cpa(circle, 1.0, 0.0);\n        double angle1 = l / r;\n        std::cout << \"ԲĽǵĻֵΪ\" << \": \" << angle1 << '\n';\n        double x = r * cos(angle1);\n        double y = r * sin(angle1);\n        std::cout << \"xֵΪ\" << \": \" << x << '\n';\n        std::cout << \"yֵΪ\" << \": \" << y << '\n';\n        double param = cpa.Parameter();\n        if (cpa.IsDone())\n        {\n            std::cout << param << \": \" << circle.Value(param) << '\n';\n        }\n        double p = 2 * M_PI * r;\n        std::cout << \"߳Ϊ\" << ComputePointsAbscissa::Length(circle) << '\n';\n        Point2 s = circle.Value(param);\n        Point2 s1(x, y);\n        std::cout << s << std::endl;\n        CHECK(p == ComputePointsAbscissa::Length(circle));\n        CHECK(angle1 == cpa.Parameter());\n        CHECK(s.X() == s1.X());\n        CHECK(s.Y() == s1.Y());\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API ComputePointsAbscissa(double tol, const Adaptor2Curve& c, double abscissa, double u0)\t @param u0 The starting parameter\n\t @param abscissa The arc length\n\t @param c The curve\n\t @param tol The tolerance\n\t @brief Compute the parameter of a point on a 2D curve with given arc length and a tolerance\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/MakeGeom2Circle.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/ComputePointsAbscissa.hpp>\n#include <geometry/MakeGeom3Circle.hpp>\n#include <geometry/AdaptorGeom3Curve.hpp>\n#include <geometry/MakeGeom2Hyperbola.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/MakeGeom2Ellipse.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <geometry/MakeGeom3Ellipse.hpp>\n#include <geometry/MakeGeom3Hyperbola.hpp>\n#include <geometry/Geom2Line.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include<modeling/MakeEdge.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/MakeGeom2Parabola.hpp>\n#include <geometry/MakeGeom3Parabola.hpp>\n#include <geometry/Geom2BezierCurve.hpp>\n#include <geometry/Geom3BezierCurve.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2OffsetCurve.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\n#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/MakeGeom2Circle.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/ComputePointsAbscissa.hpp>\n#include <geometry/MakeGeom3Circle.hpp>\n#include <geometry/AdaptorGeom3Curve.hpp>\n#include <geometry/MakeGeom2Hyperbola.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/MakeGeom2Ellipse.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <geometry/MakeGeom3Ellipse.hpp>\n#include <geometry/MakeGeom3Hyperbola.hpp>\n#include <geometry/Geom2Line.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include<modeling/MakeEdge.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/MakeGeom2Parabola.hpp>\n#include <geometry/MakeGeom3Parabola.hpp>\n#include <geometry/Geom2BezierCurve.hpp>\n#include <geometry/Geom3BezierCurve.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2OffsetCurve.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\n;\n\tSECTION(\"circle\")\n    {\n        double r = 2.0;\n        double l = 1.0;\n        std::shared_ptr<Geom2Curve> c = MakeGeom2Circle(Point2(0.0, 0.0), 2.0).Value();\n        AdaptorGeom2Curve circle(c);\n        ComputePointsAbscissa cpa(circle, 1.0, 0.0);\n        double angle1 = l / r;\n        std::cout << \"ԲĽǵĻֵΪ\" << \": \" << angle1 << '\n';\n        double x = r * cos(angle1);\n        double y = r * sin(angle1);\n        std::cout << \"xֵΪ\" << \": \" << x << '\n';\n        std::cout << \"yֵΪ\" << \": \" << y << '\n';\n        double param = cpa.Parameter();\n        if (cpa.IsDone())\n        {\n            std::cout << param << \": \" << circle.Value(param) << '\n';\n        }\n        double p = 2 * M_PI * r;\n        std::cout << \"߳Ϊ\" << ComputePointsAbscissa::Length(circle) << '\n';\n        Point2 s = circle.Value(param);\n        Point2 s1(x, y);\n        std::cout << s << std::endl;\n        CHECK(p == ComputePointsAbscissa::Length(circle));\n        CHECK(angle1 == cpa.Parameter());\n        CHECK(s.X() == s1.X());\n        CHECK(s.Y() == s1.Y());\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API ComputePointsAbscissa(double tol, const Adaptor3Curve& c, double abscissa, double u0)\t @param u0 The starting parameter\n\t @param abscissa The arc length\n\t @param c The curve\n\t @param tol The tolerance\n\t @brief Compute the parameter of a point on a 3D curve with given arc length and a tolerance\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/MakeGeom2Circle.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/ComputePointsAbscissa.hpp>\n#include <geometry/MakeGeom3Circle.hpp>\n#include <geometry/AdaptorGeom3Curve.hpp>\n#include <geometry/MakeGeom2Hyperbola.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/MakeGeom2Ellipse.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <geometry/MakeGeom3Ellipse.hpp>\n#include <geometry/MakeGeom3Hyperbola.hpp>\n#include <geometry/Geom2Line.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include<modeling/MakeEdge.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/MakeGeom2Parabola.hpp>\n#include <geometry/MakeGeom3Parabola.hpp>\n#include <geometry/Geom2BezierCurve.hpp>\n#include <geometry/Geom3BezierCurve.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2OffsetCurve.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\n#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/MakeGeom2Circle.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/ComputePointsAbscissa.hpp>\n#include <geometry/MakeGeom3Circle.hpp>\n#include <geometry/AdaptorGeom3Curve.hpp>\n#include <geometry/MakeGeom2Hyperbola.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/MakeGeom2Ellipse.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <geometry/MakeGeom3Ellipse.hpp>\n#include <geometry/MakeGeom3Hyperbola.hpp>\n#include <geometry/Geom2Line.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include<modeling/MakeEdge.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/MakeGeom2Parabola.hpp>\n#include <geometry/MakeGeom3Parabola.hpp>\n#include <geometry/Geom2BezierCurve.hpp>\n#include <geometry/Geom3BezierCurve.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2OffsetCurve.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\n;\n\tSECTION(\"circle\")\n    {\n        double r = 2.0;\n        double l = 1.0;\n        std::shared_ptr<Geom2Curve> c = MakeGeom2Circle(Point2(0.0, 0.0), 2.0).Value();\n        AdaptorGeom2Curve circle(c);\n        ComputePointsAbscissa cpa(circle, 1.0, 0.0);\n        double angle1 = l / r;\n        std::cout << \"ԲĽǵĻֵΪ\" << \": \" << angle1 << '\n';\n        double x = r * cos(angle1);\n        double y = r * sin(angle1);\n        std::cout << \"xֵΪ\" << \": \" << x << '\n';\n        std::cout << \"yֵΪ\" << \": \" << y << '\n';\n        double param = cpa.Parameter();\n        if (cpa.IsDone())\n        {\n            std::cout << param << \": \" << circle.Value(param) << '\n';\n        }\n        double p = 2 * M_PI * r;\n        std::cout << \"߳Ϊ\" << ComputePointsAbscissa::Length(circle) << '\n';\n        Point2 s = circle.Value(param);\n        Point2 s1(x, y);\n        std::cout << s << std::endl;\n        CHECK(p == ComputePointsAbscissa::Length(circle));\n        CHECK(angle1 == cpa.Parameter());\n        CHECK(s.X() == s1.X());\n        CHECK(s.Y() == s1.Y());\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API explicit MakeConic2FromConstraints(const std::vector<Conic2Constraint>& constraints)\t @param constraints The constraints of the conic. It is supported that the constraints contain 5 points, 4 points and 1 tangent, 3 points and 2 tangent\n\t @brief Build by point and tangent constraints. The number of constraints must be 5 in total and the start and the end point constraints are required\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <geomAlgo/MakeConic2FromConstraints.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <math/HyperbolaT.hpp>\n#include <geometry/Geom2Hyperbola.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/Geom2Circle.hpp>\n#include <geometry/GeomAPIProjectPointOnCurve3.hpp>\n#include <topology/BRepExtremaDistShapeShape.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <modeling/MakeEdge.hpp>\n#include<catch.hpp>\n#include<testHelper.h>\n#include <geomAlgo/MakeConic2FromConstraints.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <math/HyperbolaT.hpp>\n#include <geometry/Geom2Hyperbola.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/Geom2Circle.hpp>\n#include <geometry/GeomAPIProjectPointOnCurve3.hpp>\n#include <topology/BRepExtremaDistShapeShape.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <modeling/MakeEdge.hpp>\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API MakeConic2FromConstraints(const Conic2Constraint& startConstraint, const Conic2Constraint& endConstraint, double parameter)\t @param parameter The parameter to determine type and shape of the conic, valid range is (0.0, 1.0): ellipse if (0.0, 0.5), parabola if {0.5}, hyperbola if (0.5, 1.0)\n\t @param endConstraint The end point and tangent\n\t @param startConstraint The start point and tangent\n\t @brief Build by ending points and tangents and a parameter\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <geomAlgo/MakeConic2FromConstraints.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <math/HyperbolaT.hpp>\n#include <geometry/Geom2Hyperbola.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/Geom2Circle.hpp>\n#include <geometry/GeomAPIProjectPointOnCurve3.hpp>\n#include <topology/BRepExtremaDistShapeShape.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <modeling/MakeEdge.hpp>\nTEST_CASE(\"bug1: MakeConic2FromConstraints \", \"[geomAlgo][MakeConic2FromConstraints][fixbug]\")\n{\n\tPoint2 a(0.0, 0.0);\n\tPoint2 b(1.0, 1.0);\n\tVector2 da(-0.5, 0.5);\n\tVector2 db(1.0, -0.2);\n\tPoint3 a1(a.X(), a.Y(), 0.0);\n\tPoint3 b1(b.X(), b.Y(), 0.0);\n\tVector3 da1(da.X(), da.Y(), 0.0);\n\tVector3 db1(db.X(), db.Y(), 0.0);\n\tConic2Constraint ca(a, da);\n\tConic2Constraint cb(b, db);\n\tMakeConic2FromConstraints mc2fc(ca, cb, 0.0);\n\tshared_ptr<Geom3Curve> curve;\n\tcurve = GeometryTool::To3d(Frame3(), mc2fc.Curve2d());\n\tCHECK(mc2fc.Curve2d() == nullptr);\n\tCHECK(curve == nullptr);\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "Conic2Constraint(const Point2& point, const Vector2& tangent)\t @param tangent The tangent vector constraint\n\t @param point The point constraint\n\t @brief Construct from point and tangent constraints\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <geomAlgo/MakeConic2FromConstraints.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <math/HyperbolaT.hpp>\n#include <geometry/Geom2Hyperbola.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/Geom2Circle.hpp>\n#include <geometry/GeomAPIProjectPointOnCurve3.hpp>\n#include <topology/BRepExtremaDistShapeShape.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <modeling/MakeEdge.hpp>\nTEST_CASE(\"bug2: MakeConic2FromConstraints \", \"[geomAlgo][MakeConic2FromConstraints][fixbug]\")\n{\n\tOUTPUT_DIRECTORY(nurbs, Constraints/bug496);\n\tPoint2 a(0.0, 0.0);\n\tPoint2 b(1.0, 1.0);\n\tVector2 da(-0.5, 0.5);\n\tVector2 db(1.0, -0.2);\n\tPoint3 a1(a.X(), a.Y(), 0.0);\n\tPoint3 b1(b.X(), b.Y(), 0.0);\n\tVector3 da1(da.X(), da.Y(), 0.0);\n\tVector3 db1(db.X(), db.Y(), 0.0);\n\tConic2Constraint ca(a, da);\n\tConic2Constraint cb(b, db);\n\tdouble parameter = 0.05 * 4;\n\tMakeConic2FromConstraints mc2fc(ca, cb, parameter);\n\tconst auto& coefficients = mc2fc.Coefficients();\n\tshared_ptr<Geom3Curve> curve;\n\tcurve = GeometryTool::To3d(Frame3(), mc2fc.Curve2d());\n\tdouble tol = -1.0;\n\tTopoEdge edge = MakeEdge(curve);\n\tbool res2 = BRepClassificationTools::IsPointInOnEdge(edge, b1, tol);\n\tCHECK(res2 == true);\n\tOCCTIO::OCCTTool::Write(MakeEdge(curve), outdir + \"curve.brep\");\n\tOCCTIO::OCCTTool::Write(MakeVertex(a1), outdir + \"a1.brep\");\n\tOCCTIO::OCCTTool::Write(MakeVertex(b1), outdir + \"b1.brep\");\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API virtual void Bounds(double& fp, double& lp)\t @param[out] lp The second parameter\n\t @param[out] fp The first parameter\n\t @brief Get the parametric bounds\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include<geomAlgo/LawConstant.hpp>\n#include<geomAlgo/LawFunction.hpp>\nusing namespace std;\n#include<catch.hpp>\n#include<testHelper.h>\n#include<geomAlgo/LawConstant.hpp>\n#include<geomAlgo/LawFunction.hpp>\nusing namespace std;;\n\tSECTION(\"Default\")\n\t{\n\t\tLawConstant cons1;\n\t\tdouble fp = 0.0;\n\t\tdouble lp = 0.0;\n\t\tcons1.Bounds(fp, lp);\n\t\tCHECK(cons1.Value(1.0) == Approx(0.0));\n\t\tCHECK(fp == Approx(0.0));\n\t\tCHECK(lp == Approx(0.0));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API virtual std::shared_ptr<LawFunction> Trim(double fp, double lp, double tol)\t @return The new law\n\t @param tol The given tolerance, not all laws use this parameter\n\t @param lp The second parameter\n\t @param fp The first parameter\n\t @brief Get the trimmed law of this\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include<geomAlgo/LawConstant.hpp>\n#include<geomAlgo/LawFunction.hpp>\nusing namespace std;\n#include<catch.hpp>\n#include<testHelper.h>\n#include<geomAlgo/LawConstant.hpp>\n#include<geomAlgo/LawFunction.hpp>\nusing namespace std;;\n\tSECTION(\"Trim\")\n\t{\n\t\tshared_ptr<LawFunction>tr;\n\t\tdouble fp = 1.0;\n\t\tdouble lp = 5.0;\n\t\tdouble tol = 0.1;\n\t\tdouble fp1 = 0.0;\n\t\tdouble lp1 = 0.0;\n\t\ttr = cons.Trim(fp, lp, tol);\n\t\ttr->Bounds(fp1, lp1);\n\t\tCHECK(fp1 == fp);\n\t\tCHECK(lp1 == lp);\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API virtual void D2(double x, double& f, double& d, double& d2)\t @param[out] d2 The function second derivative\n\t @param[out] d The function first derivative\n\t @param[out] f The function value\n\t @param[in] x The given parameter\n\t @brief Get the function second derivative at the given parameter\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include<geomAlgo/LawConstant.hpp>\n#include<geomAlgo/LawFunction.hpp>\nusing namespace std;\n#include<catch.hpp>\n#include<testHelper.h>\n#include<geomAlgo/LawConstant.hpp>\n#include<geomAlgo/LawFunction.hpp>\nusing namespace std;;\n\tSECTION(\"D2\")\n\t{\n\t\tdouble x = 1.0;\n\t\tdouble f, d, d2;\n\t\tcons.D2(x, f, d, d2);\n\t\tCHECK(f == Approx(2.0));\n\t\tCHECK(d == Approx(0.0));\n\t\tCHECK(d2 == Approx(0.0));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API virtual void D1(double x, double& f, double& d)\t @param[out] d The function first derivative\n\t @param[out] f The function value\n\t @param[in] x The given parameter\n\t @brief Get the function first derivative at the given parameter\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include<geomAlgo/LawConstant.hpp>\n#include<geomAlgo/LawFunction.hpp>\nusing namespace std;\n#include<catch.hpp>\n#include<testHelper.h>\n#include<geomAlgo/LawConstant.hpp>\n#include<geomAlgo/LawFunction.hpp>\nusing namespace std;;\n\tSECTION(\"D1\")\n\t{\n\t\tdouble x = 1.0;\n\t\tdouble f = 0.0; \n\t\tdouble d = 0.0;\n\t\tcons.D1(x, f, d);\n\t\tCHECK(f == Approx(2.0));\n\t\tCHECK(d == Approx(0.0));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API virtual double Value(double x)\t @return The function value\n\t @param x The given parameter\n\t @brief Get the function value at the given parameter\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include<geomAlgo/LawConstant.hpp>\n#include<geomAlgo/LawFunction.hpp>\nusing namespace std;\n#include<catch.hpp>\n#include<testHelper.h>\n#include<geomAlgo/LawConstant.hpp>\n#include<geomAlgo/LawFunction.hpp>\nusing namespace std;;\n\tSECTION(\"Value\")\n\t{\n\t\tdouble value = cons.Value(1.0);\n\t\tCHECK(value == Approx(2.0));\n\t\tdouble value1 = cons.Value(15.0);\n\t\tCHECK(value1 == Approx(2.0));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API virtual void Intervals(std::vector<double>& t, ContinuityType s)\t @param[in] s The given continuity\n\t @param[out] t The array to store the parameters\n\t @brief Get the bounding parameters of the intervals of the given continuity\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include<geomAlgo/LawConstant.hpp>\n#include<geomAlgo/LawFunction.hpp>\nusing namespace std;\n#include<catch.hpp>\n#include<testHelper.h>\n#include<geomAlgo/LawConstant.hpp>\n#include<geomAlgo/LawFunction.hpp>\nusing namespace std;;\n\tSECTION(\"NIntervals\")\n\t{\n\t\tint num1 = cons.NIntervals(ContinuityType::C0);\n\t\tint num2 = cons.NIntervals(ContinuityType::G1);\n\t\tint num3 = cons.NIntervals(ContinuityType::C1);\n\t\tint num4 = cons.NIntervals(ContinuityType::G2);\n\t\tint num5 = cons.NIntervals(ContinuityType::C2);\n\t\tint num6 = cons.NIntervals(ContinuityType::C3);\n\t\tint num7 = cons.NIntervals(ContinuityType::CN);\n\t\tCHECK(num1 == 1);\n\t\tCHECK(num2 == 1);\n\t\tCHECK(num3 == 1);\n\t\tCHECK(num4 == 1);\n\t\tCHECK(num5 == 1);\n\t\tCHECK(num6 == 1);\n\t\tCHECK(num7 == 1);\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API virtual int NIntervals(ContinuityType s)\t @return The number of intervals\n\t @param s The given continuity\n\t @brief Get the number of intervals divided by parameters at which the curve continuity is lower than the given continuity\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include<geomAlgo/LawConstant.hpp>\n#include<geomAlgo/LawFunction.hpp>\nusing namespace std;\n#include<catch.hpp>\n#include<testHelper.h>\n#include<geomAlgo/LawConstant.hpp>\n#include<geomAlgo/LawFunction.hpp>\nusing namespace std;;\n\tSECTION(\"NIntervals\")\n\t{\n\t\tint num1 = cons.NIntervals(ContinuityType::C0);\n\t\tint num2 = cons.NIntervals(ContinuityType::G1);\n\t\tint num3 = cons.NIntervals(ContinuityType::C1);\n\t\tint num4 = cons.NIntervals(ContinuityType::G2);\n\t\tint num5 = cons.NIntervals(ContinuityType::C2);\n\t\tint num6 = cons.NIntervals(ContinuityType::C3);\n\t\tint num7 = cons.NIntervals(ContinuityType::CN);\n\t\tCHECK(num1 == 1);\n\t\tCHECK(num2 == 1);\n\t\tCHECK(num3 == 1);\n\t\tCHECK(num4 == 1);\n\t\tCHECK(num5 == 1);\n\t\tCHECK(num6 == 1);\n\t\tCHECK(num7 == 1);\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API GccCircle3Tangent(const Point2& point1, const Point2& point2, const Point2& point3, double tolerance)\t @param tolerance The tolerance\n\t @param point3 The third point\n\t @param point2 The second point\n\t @param point1 The first point\n\t @brief Construct a circle passing through three points\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <geomAlgo/GccCircle3Tangent.hpp>\n#include <geometry/Geom2Curve.hpp>\n#include <geometry/MakeGeom2Line.hpp>\n#include <geometry/MakeGeom2Circle.hpp>\n#include <geomAlgo/GccEntity.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geomAlgo/GccEntity.hpp>\n#include <geomAlgo/GccQualifiedCurve.hpp>\n#include <sstream>\nusing namespace AMCAX;\nTEST_CASE(\"bug1: GccCircle3Tangent  add 48 cases\", \"[geomAlgo][GccCircle3Tangent][fixbug]\") {\n\tstd::shared_ptr<Geom2Curve> l = MakeGeom2Line(Point2(0.0, 0.0), Point2(1.0, 0.0)).Value();\n\tstd::shared_ptr<Geom2Curve> c1 = MakeGeom2Circle(Point2(0.0, 3.0), 2.0).Value();\n\tstd::shared_ptr<Geom2Curve> c2 = MakeGeom2Circle(Point2(4.0, 3.0), 2.0).Value();\n\tAdaptorGeom2Curve line(l);\n\tAdaptorGeom2Curve circle1(c1);\n\tAdaptorGeom2Curve circle2(c2);\n\tauto lineEnclosed = GccEntity::Enclosed(line);\n\tauto lineOutside = GccEntity::Outside(line);\n\tauto lineUnqualified = GccEntity::Unqualified(line);\n\tauto circle1Enclosed = GccEntity::Enclosed(circle1);\n\tauto circle1Enclosing = GccEntity::Enclosing(circle1);\n\tauto circle1Outside = GccEntity::Outside(circle1);\n\tauto circle1Unqualified = GccEntity::Unqualified(circle1);\n\tauto circle2Enclosed = GccEntity::Enclosed(circle2);\n\tauto circle2Enclosing = GccEntity::Enclosing(circle2);\n\tauto circle2Outside = GccEntity::Outside(circle2);\n\tauto circle2Unqualified = GccEntity::Unqualified(circle2);\n\tauto gccl = GccEntity::Enclosed(AdaptorGeom2Curve(l));\n\tauto gccc1 = GccEntity::Enclosing(AdaptorGeom2Curve(c1));\n\tauto gccc2 = GccEntity::Outside(AdaptorGeom2Curve(c2));\n\tauto c3t = [](const GccQualifiedCurve& gccc1, const GccQualifiedCurve& gccc2, const GccQualifiedCurve& gccl)\n\t{\n\t\tstd::stringstream output;\n\t\tGccCircle3Tangent gcc(gccc1, gccc2, gccl, Precision::Confusion(), 0.0, 0.0, 0.0);\n\t\tstd::cout << \"Test case: \" << GccEntity::PositionToString(gccc1.Qualifier()) << ' ' << GccEntity::PositionToString(gccc2.Qualifier()) << ' ' << GccEntity::PositionToString(gccl.Qualifier()) << std::endl;\n\t\tstd::cout << \"Solution: \" << gcc.NSolutions() << std::endl;\n\t\toutput << \"Test case: \" << GccEntity::PositionToString(gccc1.Qualifier()) << ' ' << GccEntity::PositionToString(gccc2.Qualifier()) << ' ' << GccEntity::PositionToString(gccl.Qualifier()) << std::endl;\n\t\toutput << \"Solution: \" << gcc.NSolutions() << std::endl;\n\t\tif (gcc.IsDone())\n\t\t{\n\t\t\tfor (int i = 0; i < gcc.NSolutions(); i++)\n\t\t\t{\n\t\t\t\tGccPosition q1, q2, q3;\n\t\t\t\tgcc.Qualifier(i, q1, q2, q3);\n\t\t\t\toutput << i << \": \" << *MakeGeom2Circle(gcc.Solution(i)).Value() << std::endl;\n\t\t\t\toutput << \"  \" << GccEntity::PositionToString(q1) << ' ' << GccEntity::PositionToString(q2) << ' ' << GccEntity::PositionToString(q3) << std::endl;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tstd::cout << \"gcc.IsDone is False\" << std::endl;\n\t\t\toutput << \"gcc.IsDone is False\" << std::endl;\n\t\t}\n\t\treturn output.str();\n\t};\n\tauto case1 = c3t(circle1Enclosed, circle2Enclosed, lineEnclosed);\n\tauto expect1 = \"Test case: Enclosed Enclosed Enclosed\nSolution: 0\n\";\n\tCHECK(case1.find(expect1) != std::string::npos);\n\tauto case2 = c3t(circle1Enclosed, circle2Enclosed, lineOutside);\n\tauto expect2 = \"Test case: Enclosed Enclosed Outside\nSolution: 0\n\";\n\tCHECK(case2.find(expect2) != std::string::npos);\n\tauto case3 = c3t(circle1Enclosed, circle2Enclosed, lineUnqualified);\n\tauto expect3 = \"Test case: Enclosed Enclosed Unqualified\nSolution: 0\n\";\n\tCHECK(case3.find(expect3) != std::string::npos);\n\tauto case4 = c3t(circle1Enclosed, circle2Enclosing, lineEnclosed);\n\tauto expect4 = \"Test case: Enclosed Enclosing Enclosed\nSolution: 0\n\";\n\tCHECK(case4.find(expect4) != std::string::npos);\n\tauto case5 = c3t(circle1Enclosed, circle2Enclosing, lineOutside);\n\tauto expect5 = \"Test case: Enclosed Enclosing Outside\nSolution: 0\n\";\n\tCHECK(case5.find(expect5) != std::string::npos);\n\tauto case6 = c3t(circle1Enclosed, circle2Enclosing, lineUnqualified);\n\tauto expect6 = \"Test case: Enclosed Enclosing Unqualified\nSolution: 0\n\";\n\tCHECK(case6.find(expect6) != std::string::npos);\n\tauto case7 = c3t(circle1Enclosed, circle2Outside, lineEnclosed);\n\tauto expect7 = \"Test case: Enclosed Outside Enclosed\nSolution: 0\n\";\n\tCHECK(case7.find(expect7) != std::string::npos);\n\tauto case8 = c3t(circle1Enclosed, circle2Outside, lineOutside);\n\tauto expect8 = \"Test case: Enclosed Outside Outside\nSolution: 0\n\";\n\tCHECK(case8.find(expect8) != std::string::npos);\n\tauto case9 = c3t(circle1Enclosed, circle2Outside, lineUnqualified);\n\tauto expect9 = \"Test case: Enclosed Outside Unqualified\nSolution: 0\n\";\n\tCHECK(case9.find(expect9) != std::string::npos);\n\tauto case10 = c3t(circle1Enclosed, circle2Unqualified, lineEnclosed);\n\tauto expect10 = \"Test case: Enclosed Unqualified Enclosed\nSolution: 0\n\";\n\tCHECK(case10.find(expect10) != std::string::npos);\n\tauto case11 = c3t(circle1Enclosed, circle2Unqualified, lineOutside);\n\tauto expect11 = \"Test case: Enclosed Unqualified Outside\nSolution: 0\n\";\n\tCHECK(case11.find(expect11) != std::string::npos);\n\tauto case12 = c3t(circle1Enclosed, circle2Unqualified, lineUnqualified);\n\tauto expect12 = \"Test case: Enclosed Unqualified Unqualified\nSolution: 0\n\";\n\tCHECK(case12.find(expect12) != std::string::npos);\n\tauto case13 = c3t(circle1Enclosing, circle2Enclosed, lineEnclosed);\n\tauto expect13 = \"Test case: Enclosing Enclosed Enclosed\nSolution: 0\n\";\n\tCHECK(case13.find(expect13) != std::string::npos);\n\tauto case14 = c3t(circle1Enclosing, circle2Enclosed, lineOutside);\n\tauto expect14 = \"Test case: Enclosing Enclosed Outside\nSolution: 0\n\";\n\tCHECK(case14.find(expect14) != std::string::npos);\n\tauto case15 = c3t(circle1Enclosing, circle2Enclosed, lineUnqualified);\n\tauto expect15 = \"Test case: Enclosing Enclosed Unqualified\nSolution: 0\n\";\n\tCHECK(case15.find(expect15) != std::string::npos);\n\tauto case16 = c3t(circle1Enclosing, circle2Enclosing, lineEnclosed);\n\tauto expect16 = \"Test case: Enclosing Enclosing Enclosed\nSolution: 1\n0: 2 2 4.5 1 0 -0 1 4.5\n  Enclosing Enclosing Enclosed\n\";\n\tCHECK(case16.find(expect16) != std::string::npos);\n\tauto case17 = c3t(circle1Enclosing, circle2Enclosing, lineOutside);\n\tauto expect17 = \"Test case: Enclosing Enclosing Outside\nSolution: 0\n\";\n\tCHECK(case17.find(expect17) != std::string::npos);\n\tauto case18 = c3t(circle1Enclosing, circle2Enclosing, lineUnqualified);\n\tauto expect18 = \"Test case: Enclosing Enclosing Unqualified\nSolution: 1\n0: 2 2 4.5 1 0 -0 1 4.5\n  Enclosing Enclosing Enclosed\n\";\n\tCHECK(case18.find(expect18) != std::string::npos);\n\tauto case19 = c3t(circle1Enclosing, circle2Outside, lineEnclosed);\n\tauto expect19 = \"Test case: Enclosing Outside Enclosed\nSolution: 1\n0: 2 -1 3 1 0 -0 1 3\n  Enclosing Outside Enclosed\n\";\n\tCHECK(case19.find(expect19) != std::string::npos);\n\tauto case20 = c3t(circle1Enclosing, circle2Outside, lineOutside);\n\tauto expect20 = \"Test case: Enclosing Outside Outside\nSolution: 0\n\";\n\tCHECK(case20.find(expect20) != std::string::npos);\n\tauto case21 = c3t(circle1Enclosing, circle2Outside, lineUnqualified);\n\tauto expect21 = \"Test case: Enclosing Outside Unqualified\nSolution: 1\n0: 2 -1 3 1 0 -0 1 3\n  Enclosing Outside Enclosed\n\";\n\tCHECK(case21.find(expect21) != std::string::npos);\n\tauto case22 = c3t(circle1Enclosing, circle2Unqualified, lineEnclosed);\n\tauto expect22 = \"Test case: Enclosing Unqualified Enclosed\nSolution: 2\n0: 2 -1 3 1 0 -0 1 3\n  Enclosing Outside Enclosed\n1: 2 2 4.5 1 0 -0 1 4.5\n  Enclosing Enclosing Enclosed\n\";\n\tCHECK(case22.find(expect22) != std::string::npos);\n\tauto case23 = c3t(circle1Enclosing, circle2Unqualified, lineOutside);\n\tauto expect23 = \"Test case: Enclosing Unqualified Outside\nSolution: 0\n\";\n\tCHECK(case23.find(expect23) != std::string::npos);\n\tauto case24 = c3t(circle1Enclosing, circle2Unqualified, lineUnqualified);\n\tauto expect24 = \"Test case: Enclosing Unqualified Unqualified\nSolution: 2\n0: 2 -1 3 1 0 -0 1 3\n  Enclosing Outside Enclosed\n1: 2 2 4.5 1 0 -0 1 4.5\n  Enclosing Enclosing Enclosed\n\";\n\tCHECK(case24.find(expect24) != std::string::npos);\n\tauto case25 = c3t(circle1Outside, circle2Enclosed, lineEnclosed);\n\tauto expect25 = \"Test case: Outside Enclosed Enclosed\nSolution: 0\n\";\n\tCHECK(case25.find(expect25) != std::string::npos);\n\tauto case26 = c3t(circle1Outside, circle2Enclosed, lineOutside);\n\tauto expect26 = \"Test case: Outside Enclosed Outside\nSolution: 0\n\";\n\tCHECK(case26.find(expect26) != std::string::npos);\n\tauto case27 = c3t(circle1Outside, circle2Enclosed, lineUnqualified);\n\tauto expect27 = \"Test case: Outside Enclosed Unqualified\nSolution: 0\n\";\n\tCHECK(case27.find(expect27) != std::string::npos);\n\tauto case28 = c3t(circle1Outside, circle2Enclosing, lineEnclosed);\n\tauto expect28 = \"Test case: Outside Enclosing Enclosed\nSolution: 1\n0: 2 5 3 1 0 -0 1 3\n  Outside Enclosing Enclosed\n\";\n\tCHECK(case28.find(expect28) != std::string::npos);\n\tauto case29 = c3t(circle1Outside, circle2Enclosing, lineOutside);\n\tauto expect29 = \"Test case: Outside Enclosing Outside\nSolution: 0\n\";\n\tCHECK(case29.find(expect29) != std::string::npos);\n\tauto case30 = c3t(circle1Outside, circle2Enclosing, lineUnqualified);\n\tauto expect30 = \"Test case: Outside Enclosing Unqualified\nSolution: 1\n0: 2 5 3 1 0 -0 1 3\n  Outside Enclosing Enclosed\n\";\n\tCHECK(case30.find(expect30) != std::string::npos);\n\tauto case31 = c3t(circle1Outside, circle2Outside, lineEnclosed);\n\tauto expect31 = \"Test case: Outside Outside Enclosed\nSolution: 1\n0: 2 2 0.9 1 0 -0 1 0.9\n  Outside Outside Enclosed\n\";\n\tCHECK(case31.find(expect31) != std::string::npos);\n\tauto case32 = c3t(circle1Outside, circle2Outside, lineOutside);\n\tauto expect32 = \"Test case: Outside Outside Outside\nSolution: 0\n\";\n\tCHECK(case32.find(expect32) != std::string::npos);\n\tauto case33 = c3t(circle1Outside, circle2Outside, lineUnqualified);\n\tauto expect33 = \"Test case: Outside Outside Unqualified\nSolution: 1\n0: 2 2 0.9 1 0 -0 1 0.9\n  Outside Outside Enclosed\n\";\n\tCHECK(case33.find(expect33) != std::string::npos);\n\tauto case34 = c3t(circle1Outside, circle2Unqualified, lineEnclosed);\n\tauto expect34 = \"Test case: Outside Unqualified Enclosed\nSolution: 2\n0: 2 2 0.9 1 0 -0 1 0.9\n  Outside Outside Enclosed\n1: 2 5 3 1 0 -0 1 3\n  Outside Enclosing Enclosed\n\";\n\tCHECK(case34.find(expect34) != std::string::npos);\n\tauto case35 = c3t(circle1Outside, circle2Unqualified, lineOutside);\n\tauto expect35 = \"Test case: Outside Unqualified Outside\nSolution: 0\n\";\n\tCHECK(case35.find(expect35) != std::string::npos);\n\tauto case36 = c3t(circle1Outside, circle2Unqualified, lineUnqualified);\n\tauto expect36 = \"Test case: Outside Unqualified Unqualified\nSolution: 2\n0: 2 2 0.9 1 0 -0 1 0.9\n  Outside Outside Enclosed\n1: 2 5 3 1 0 -0 1 3\n  Outside Enclosing Enclosed\n\";\n\tCHECK(case36.find(expect36) != std::string::npos);\n\tauto case37 = c3t(circle1Unqualified, circle2Enclosed, lineEnclosed);\n\tauto expect37 = \"Test case: Unqualified Enclosed Enclosed\nSolution: 0\n\";\n\tCHECK(case37.find(expect37) != std::string::npos);\n\tauto case38 = c3t(circle1Unqualified, circle2Enclosed, lineOutside);\n\tauto expect38 = \"Test case: Unqualified Enclosed Outside\nSolution: 0\n\";\n\tCHECK(case38.find(expect38) != std::string::npos);\n\tauto case39 = c3t(circle1Unqualified, circle2Enclosed, lineUnqualified);\n\tauto expect39 = \"Test case: Unqualified Enclosed Unqualified\nSolution: 0\n\";\n\tCHECK(case39.find(expect39) != std::string::npos);\n\tauto case40 = c3t(circle1Unqualified, circle2Enclosing, lineEnclosed);\n\tauto expect40 = \"Test case: Unqualified Enclosing Enclosed\nSolution: 2\n0: 2 5 3 1 0 -0 1 3\n  Outside Enclosing Enclosed\n1: 2 2 4.5 1 0 -0 1 4.5\n  Enclosing Enclosing Enclosed\n\";\n\tCHECK(case40.find(expect40) != std::string::npos);\n\tauto case41 = c3t(circle1Unqualified, circle2Enclosing, lineOutside);\n\tauto expect41 = \"Test case: Unqualified Enclosing Outside\nSolution: 0\n\";\n\tCHECK(case41.find(expect41) != std::string::npos);\n\tauto case42 = c3t(circle1Unqualified, circle2Enclosing, lineUnqualified);\n\tauto expect42 = \"Test case: Unqualified Enclosing Unqualified\nSolution: 2\n0: 2 5 3 1 0 -0 1 3\n  Outside Enclosing Enclosed\n1: 2 2 4.5 1 0 -0 1 4.5\n  Enclosing Enclosing Enclosed\n\";\n\tCHECK(case42.find(expect42) != std::string::npos);\n\tauto case43 = c3t(circle1Unqualified, circle2Outside, lineEnclosed);\n\tauto expect43 = \"Test case: Unqualified Outside Enclosed\nSolution: 2\n0: 2 2 0.9 1 0 -0 1 0.9\n  Outside Outside Enclosed\n1: 2 -1 3 1 0 -0 1 3\n  Enclosing Outside Enclosed\n\";\n\tCHECK(case43.find(expect43) != std::string::npos);\n\tauto case44 = c3t(circle1Unqualified, circle2Outside, lineOutside);\n\tauto expect44 = \"Test case: Unqualified Outside Outside\nSolution: 0\n\";\n\tCHECK(case44.find(expect44) != std::string::npos);\n\tauto case45 = c3t(circle1Unqualified, circle2Outside, lineUnqualified);\n\tauto expect45 = \"Test case: Unqualified Outside Unqualified\nSolution: 2\n0: 2 2 0.9 1 0 -0 1 0.9\n  Outside Outside Enclosed\n1: 2 -1 3 1 0 -0 1 3\n  Enclosing Outside Enclosed\n\";\n\tCHECK(case45.find(expect45) != std::string::npos);\n\tauto case46 = c3t(circle1Unqualified, circle2Unqualified, lineEnclosed);\n\tauto expect46 = \"Test case: Unqualified Unqualified Enclosed\nSolution: 4\n0: 2 2 0.9 1 0 -0 1 0.9\n  Outside Outside Enclosed\n1: 2 5 3 1 0 -0 1 3\n  Outside Enclosing Enclosed\n2: 2 -1 3 1 0 -0 1 3\n  Enclosing Outside Enclosed\n3: 2 2 4.5 1 0 -0 1 4.5\n  Enclosing Enclosing Enclosed\n\";\n\tCHECK(case46.find(expect46) != std::string::npos);\n\tauto case47 = c3t(circle1Unqualified, circle2Unqualified, lineOutside);\n\tauto expect47 = \"Test case: Unqualified Unqualified Outside\nSolution: 0\n\";\n\tCHECK(case47.find(expect47) != std::string::npos);\n\tauto case48 = c3t(circle1Unqualified, circle2Unqualified, lineUnqualified);\n\tauto expect48 = \"Test case: Unqualified Unqualified Unqualified\nSolution: 4\n0: 2 2 0.9 1 0 -0 1 0.9\n  Outside Outside Enclosed\n1: 2 5 3 1 0 -0 1 3\n  Outside Enclosing Enclosed\n2: 2 -1 3 1 0 -0 1 3\n  Enclosing Outside Enclosed\n3: 2 2 4.5 1 0 -0 1 4.5\n  Enclosing Enclosing Enclosed\";\n\tCHECK(case48.find(expect48) != std::string::npos);\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API GccCircle3Tangent(const GccQualifiedCurve& qualified1, const Point2& point1, const Point2& point2, double tolerance, double parameter1)\t @param parameter1 The initial guess of the parameter on the curve\n\t @param tolerance The tolerance\n\t @param point2 The second point\n\t @param point1 The first point\n\t @param qualified1 The tangent curve\n\t @brief Construct a circle tangent to a curve and passing throught two points\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <geomAlgo/GccCircle3Tangent.hpp>\n#include <geometry/Geom2Curve.hpp>\n#include <geometry/MakeGeom2Line.hpp>\n#include <geometry/MakeGeom2Circle.hpp>\n#include <geomAlgo/GccEntity.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geomAlgo/GccEntity.hpp>\n#include <geomAlgo/GccQualifiedCurve.hpp>\n#include <sstream>\nusing namespace AMCAX;\nTEST_CASE(\"bug1: GccCircle3Tangent  add 48 cases\", \"[geomAlgo][GccCircle3Tangent][fixbug]\") {\n\tstd::shared_ptr<Geom2Curve> l = MakeGeom2Line(Point2(0.0, 0.0), Point2(1.0, 0.0)).Value();\n\tstd::shared_ptr<Geom2Curve> c1 = MakeGeom2Circle(Point2(0.0, 3.0), 2.0).Value();\n\tstd::shared_ptr<Geom2Curve> c2 = MakeGeom2Circle(Point2(4.0, 3.0), 2.0).Value();\n\tAdaptorGeom2Curve line(l);\n\tAdaptorGeom2Curve circle1(c1);\n\tAdaptorGeom2Curve circle2(c2);\n\tauto lineEnclosed = GccEntity::Enclosed(line);\n\tauto lineOutside = GccEntity::Outside(line);\n\tauto lineUnqualified = GccEntity::Unqualified(line);\n\tauto circle1Enclosed = GccEntity::Enclosed(circle1);\n\tauto circle1Enclosing = GccEntity::Enclosing(circle1);\n\tauto circle1Outside = GccEntity::Outside(circle1);\n\tauto circle1Unqualified = GccEntity::Unqualified(circle1);\n\tauto circle2Enclosed = GccEntity::Enclosed(circle2);\n\tauto circle2Enclosing = GccEntity::Enclosing(circle2);\n\tauto circle2Outside = GccEntity::Outside(circle2);\n\tauto circle2Unqualified = GccEntity::Unqualified(circle2);\n\tauto gccl = GccEntity::Enclosed(AdaptorGeom2Curve(l));\n\tauto gccc1 = GccEntity::Enclosing(AdaptorGeom2Curve(c1));\n\tauto gccc2 = GccEntity::Outside(AdaptorGeom2Curve(c2));\n\tauto c3t = [](const GccQualifiedCurve& gccc1, const GccQualifiedCurve& gccc2, const GccQualifiedCurve& gccl)\n\t{\n\t\tstd::stringstream output;\n\t\tGccCircle3Tangent gcc(gccc1, gccc2, gccl, Precision::Confusion(), 0.0, 0.0, 0.0);\n\t\tstd::cout << \"Test case: \" << GccEntity::PositionToString(gccc1.Qualifier()) << ' ' << GccEntity::PositionToString(gccc2.Qualifier()) << ' ' << GccEntity::PositionToString(gccl.Qualifier()) << std::endl;\n\t\tstd::cout << \"Solution: \" << gcc.NSolutions() << std::endl;\n\t\toutput << \"Test case: \" << GccEntity::PositionToString(gccc1.Qualifier()) << ' ' << GccEntity::PositionToString(gccc2.Qualifier()) << ' ' << GccEntity::PositionToString(gccl.Qualifier()) << std::endl;\n\t\toutput << \"Solution: \" << gcc.NSolutions() << std::endl;\n\t\tif (gcc.IsDone())\n\t\t{\n\t\t\tfor (int i = 0; i < gcc.NSolutions(); i++)\n\t\t\t{\n\t\t\t\tGccPosition q1, q2, q3;\n\t\t\t\tgcc.Qualifier(i, q1, q2, q3);\n\t\t\t\toutput << i << \": \" << *MakeGeom2Circle(gcc.Solution(i)).Value() << std::endl;\n\t\t\t\toutput << \"  \" << GccEntity::PositionToString(q1) << ' ' << GccEntity::PositionToString(q2) << ' ' << GccEntity::PositionToString(q3) << std::endl;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tstd::cout << \"gcc.IsDone is False\" << std::endl;\n\t\t\toutput << \"gcc.IsDone is False\" << std::endl;\n\t\t}\n\t\treturn output.str();\n\t};\n\tauto case1 = c3t(circle1Enclosed, circle2Enclosed, lineEnclosed);\n\tauto expect1 = \"Test case: Enclosed Enclosed Enclosed\nSolution: 0\n\";\n\tCHECK(case1.find(expect1) != std::string::npos);\n\tauto case2 = c3t(circle1Enclosed, circle2Enclosed, lineOutside);\n\tauto expect2 = \"Test case: Enclosed Enclosed Outside\nSolution: 0\n\";\n\tCHECK(case2.find(expect2) != std::string::npos);\n\tauto case3 = c3t(circle1Enclosed, circle2Enclosed, lineUnqualified);\n\tauto expect3 = \"Test case: Enclosed Enclosed Unqualified\nSolution: 0\n\";\n\tCHECK(case3.find(expect3) != std::string::npos);\n\tauto case4 = c3t(circle1Enclosed, circle2Enclosing, lineEnclosed);\n\tauto expect4 = \"Test case: Enclosed Enclosing Enclosed\nSolution: 0\n\";\n\tCHECK(case4.find(expect4) != std::string::npos);\n\tauto case5 = c3t(circle1Enclosed, circle2Enclosing, lineOutside);\n\tauto expect5 = \"Test case: Enclosed Enclosing Outside\nSolution: 0\n\";\n\tCHECK(case5.find(expect5) != std::string::npos);\n\tauto case6 = c3t(circle1Enclosed, circle2Enclosing, lineUnqualified);\n\tauto expect6 = \"Test case: Enclosed Enclosing Unqualified\nSolution: 0\n\";\n\tCHECK(case6.find(expect6) != std::string::npos);\n\tauto case7 = c3t(circle1Enclosed, circle2Outside, lineEnclosed);\n\tauto expect7 = \"Test case: Enclosed Outside Enclosed\nSolution: 0\n\";\n\tCHECK(case7.find(expect7) != std::string::npos);\n\tauto case8 = c3t(circle1Enclosed, circle2Outside, lineOutside);\n\tauto expect8 = \"Test case: Enclosed Outside Outside\nSolution: 0\n\";\n\tCHECK(case8.find(expect8) != std::string::npos);\n\tauto case9 = c3t(circle1Enclosed, circle2Outside, lineUnqualified);\n\tauto expect9 = \"Test case: Enclosed Outside Unqualified\nSolution: 0\n\";\n\tCHECK(case9.find(expect9) != std::string::npos);\n\tauto case10 = c3t(circle1Enclosed, circle2Unqualified, lineEnclosed);\n\tauto expect10 = \"Test case: Enclosed Unqualified Enclosed\nSolution: 0\n\";\n\tCHECK(case10.find(expect10) != std::string::npos);\n\tauto case11 = c3t(circle1Enclosed, circle2Unqualified, lineOutside);\n\tauto expect11 = \"Test case: Enclosed Unqualified Outside\nSolution: 0\n\";\n\tCHECK(case11.find(expect11) != std::string::npos);\n\tauto case12 = c3t(circle1Enclosed, circle2Unqualified, lineUnqualified);\n\tauto expect12 = \"Test case: Enclosed Unqualified Unqualified\nSolution: 0\n\";\n\tCHECK(case12.find(expect12) != std::string::npos);\n\tauto case13 = c3t(circle1Enclosing, circle2Enclosed, lineEnclosed);\n\tauto expect13 = \"Test case: Enclosing Enclosed Enclosed\nSolution: 0\n\";\n\tCHECK(case13.find(expect13) != std::string::npos);\n\tauto case14 = c3t(circle1Enclosing, circle2Enclosed, lineOutside);\n\tauto expect14 = \"Test case: Enclosing Enclosed Outside\nSolution: 0\n\";\n\tCHECK(case14.find(expect14) != std::string::npos);\n\tauto case15 = c3t(circle1Enclosing, circle2Enclosed, lineUnqualified);\n\tauto expect15 = \"Test case: Enclosing Enclosed Unqualified\nSolution: 0\n\";\n\tCHECK(case15.find(expect15) != std::string::npos);\n\tauto case16 = c3t(circle1Enclosing, circle2Enclosing, lineEnclosed);\n\tauto expect16 = \"Test case: Enclosing Enclosing Enclosed\nSolution: 1\n0: 2 2 4.5 1 0 -0 1 4.5\n  Enclosing Enclosing Enclosed\n\";\n\tCHECK(case16.find(expect16) != std::string::npos);\n\tauto case17 = c3t(circle1Enclosing, circle2Enclosing, lineOutside);\n\tauto expect17 = \"Test case: Enclosing Enclosing Outside\nSolution: 0\n\";\n\tCHECK(case17.find(expect17) != std::string::npos);\n\tauto case18 = c3t(circle1Enclosing, circle2Enclosing, lineUnqualified);\n\tauto expect18 = \"Test case: Enclosing Enclosing Unqualified\nSolution: 1\n0: 2 2 4.5 1 0 -0 1 4.5\n  Enclosing Enclosing Enclosed\n\";\n\tCHECK(case18.find(expect18) != std::string::npos);\n\tauto case19 = c3t(circle1Enclosing, circle2Outside, lineEnclosed);\n\tauto expect19 = \"Test case: Enclosing Outside Enclosed\nSolution: 1\n0: 2 -1 3 1 0 -0 1 3\n  Enclosing Outside Enclosed\n\";\n\tCHECK(case19.find(expect19) != std::string::npos);\n\tauto case20 = c3t(circle1Enclosing, circle2Outside, lineOutside);\n\tauto expect20 = \"Test case: Enclosing Outside Outside\nSolution: 0\n\";\n\tCHECK(case20.find(expect20) != std::string::npos);\n\tauto case21 = c3t(circle1Enclosing, circle2Outside, lineUnqualified);\n\tauto expect21 = \"Test case: Enclosing Outside Unqualified\nSolution: 1\n0: 2 -1 3 1 0 -0 1 3\n  Enclosing Outside Enclosed\n\";\n\tCHECK(case21.find(expect21) != std::string::npos);\n\tauto case22 = c3t(circle1Enclosing, circle2Unqualified, lineEnclosed);\n\tauto expect22 = \"Test case: Enclosing Unqualified Enclosed\nSolution: 2\n0: 2 -1 3 1 0 -0 1 3\n  Enclosing Outside Enclosed\n1: 2 2 4.5 1 0 -0 1 4.5\n  Enclosing Enclosing Enclosed\n\";\n\tCHECK(case22.find(expect22) != std::string::npos);\n\tauto case23 = c3t(circle1Enclosing, circle2Unqualified, lineOutside);\n\tauto expect23 = \"Test case: Enclosing Unqualified Outside\nSolution: 0\n\";\n\tCHECK(case23.find(expect23) != std::string::npos);\n\tauto case24 = c3t(circle1Enclosing, circle2Unqualified, lineUnqualified);\n\tauto expect24 = \"Test case: Enclosing Unqualified Unqualified\nSolution: 2\n0: 2 -1 3 1 0 -0 1 3\n  Enclosing Outside Enclosed\n1: 2 2 4.5 1 0 -0 1 4.5\n  Enclosing Enclosing Enclosed\n\";\n\tCHECK(case24.find(expect24) != std::string::npos);\n\tauto case25 = c3t(circle1Outside, circle2Enclosed, lineEnclosed);\n\tauto expect25 = \"Test case: Outside Enclosed Enclosed\nSolution: 0\n\";\n\tCHECK(case25.find(expect25) != std::string::npos);\n\tauto case26 = c3t(circle1Outside, circle2Enclosed, lineOutside);\n\tauto expect26 = \"Test case: Outside Enclosed Outside\nSolution: 0\n\";\n\tCHECK(case26.find(expect26) != std::string::npos);\n\tauto case27 = c3t(circle1Outside, circle2Enclosed, lineUnqualified);\n\tauto expect27 = \"Test case: Outside Enclosed Unqualified\nSolution: 0\n\";\n\tCHECK(case27.find(expect27) != std::string::npos);\n\tauto case28 = c3t(circle1Outside, circle2Enclosing, lineEnclosed);\n\tauto expect28 = \"Test case: Outside Enclosing Enclosed\nSolution: 1\n0: 2 5 3 1 0 -0 1 3\n  Outside Enclosing Enclosed\n\";\n\tCHECK(case28.find(expect28) != std::string::npos);\n\tauto case29 = c3t(circle1Outside, circle2Enclosing, lineOutside);\n\tauto expect29 = \"Test case: Outside Enclosing Outside\nSolution: 0\n\";\n\tCHECK(case29.find(expect29) != std::string::npos);\n\tauto case30 = c3t(circle1Outside, circle2Enclosing, lineUnqualified);\n\tauto expect30 = \"Test case: Outside Enclosing Unqualified\nSolution: 1\n0: 2 5 3 1 0 -0 1 3\n  Outside Enclosing Enclosed\n\";\n\tCHECK(case30.find(expect30) != std::string::npos);\n\tauto case31 = c3t(circle1Outside, circle2Outside, lineEnclosed);\n\tauto expect31 = \"Test case: Outside Outside Enclosed\nSolution: 1\n0: 2 2 0.9 1 0 -0 1 0.9\n  Outside Outside Enclosed\n\";\n\tCHECK(case31.find(expect31) != std::string::npos);\n\tauto case32 = c3t(circle1Outside, circle2Outside, lineOutside);\n\tauto expect32 = \"Test case: Outside Outside Outside\nSolution: 0\n\";\n\tCHECK(case32.find(expect32) != std::string::npos);\n\tauto case33 = c3t(circle1Outside, circle2Outside, lineUnqualified);\n\tauto expect33 = \"Test case: Outside Outside Unqualified\nSolution: 1\n0: 2 2 0.9 1 0 -0 1 0.9\n  Outside Outside Enclosed\n\";\n\tCHECK(case33.find(expect33) != std::string::npos);\n\tauto case34 = c3t(circle1Outside, circle2Unqualified, lineEnclosed);\n\tauto expect34 = \"Test case: Outside Unqualified Enclosed\nSolution: 2\n0: 2 2 0.9 1 0 -0 1 0.9\n  Outside Outside Enclosed\n1: 2 5 3 1 0 -0 1 3\n  Outside Enclosing Enclosed\n\";\n\tCHECK(case34.find(expect34) != std::string::npos);\n\tauto case35 = c3t(circle1Outside, circle2Unqualified, lineOutside);\n\tauto expect35 = \"Test case: Outside Unqualified Outside\nSolution: 0\n\";\n\tCHECK(case35.find(expect35) != std::string::npos);\n\tauto case36 = c3t(circle1Outside, circle2Unqualified, lineUnqualified);\n\tauto expect36 = \"Test case: Outside Unqualified Unqualified\nSolution: 2\n0: 2 2 0.9 1 0 -0 1 0.9\n  Outside Outside Enclosed\n1: 2 5 3 1 0 -0 1 3\n  Outside Enclosing Enclosed\n\";\n\tCHECK(case36.find(expect36) != std::string::npos);\n\tauto case37 = c3t(circle1Unqualified, circle2Enclosed, lineEnclosed);\n\tauto expect37 = \"Test case: Unqualified Enclosed Enclosed\nSolution: 0\n\";\n\tCHECK(case37.find(expect37) != std::string::npos);\n\tauto case38 = c3t(circle1Unqualified, circle2Enclosed, lineOutside);\n\tauto expect38 = \"Test case: Unqualified Enclosed Outside\nSolution: 0\n\";\n\tCHECK(case38.find(expect38) != std::string::npos);\n\tauto case39 = c3t(circle1Unqualified, circle2Enclosed, lineUnqualified);\n\tauto expect39 = \"Test case: Unqualified Enclosed Unqualified\nSolution: 0\n\";\n\tCHECK(case39.find(expect39) != std::string::npos);\n\tauto case40 = c3t(circle1Unqualified, circle2Enclosing, lineEnclosed);\n\tauto expect40 = \"Test case: Unqualified Enclosing Enclosed\nSolution: 2\n0: 2 5 3 1 0 -0 1 3\n  Outside Enclosing Enclosed\n1: 2 2 4.5 1 0 -0 1 4.5\n  Enclosing Enclosing Enclosed\n\";\n\tCHECK(case40.find(expect40) != std::string::npos);\n\tauto case41 = c3t(circle1Unqualified, circle2Enclosing, lineOutside);\n\tauto expect41 = \"Test case: Unqualified Enclosing Outside\nSolution: 0\n\";\n\tCHECK(case41.find(expect41) != std::string::npos);\n\tauto case42 = c3t(circle1Unqualified, circle2Enclosing, lineUnqualified);\n\tauto expect42 = \"Test case: Unqualified Enclosing Unqualified\nSolution: 2\n0: 2 5 3 1 0 -0 1 3\n  Outside Enclosing Enclosed\n1: 2 2 4.5 1 0 -0 1 4.5\n  Enclosing Enclosing Enclosed\n\";\n\tCHECK(case42.find(expect42) != std::string::npos);\n\tauto case43 = c3t(circle1Unqualified, circle2Outside, lineEnclosed);\n\tauto expect43 = \"Test case: Unqualified Outside Enclosed\nSolution: 2\n0: 2 2 0.9 1 0 -0 1 0.9\n  Outside Outside Enclosed\n1: 2 -1 3 1 0 -0 1 3\n  Enclosing Outside Enclosed\n\";\n\tCHECK(case43.find(expect43) != std::string::npos);\n\tauto case44 = c3t(circle1Unqualified, circle2Outside, lineOutside);\n\tauto expect44 = \"Test case: Unqualified Outside Outside\nSolution: 0\n\";\n\tCHECK(case44.find(expect44) != std::string::npos);\n\tauto case45 = c3t(circle1Unqualified, circle2Outside, lineUnqualified);\n\tauto expect45 = \"Test case: Unqualified Outside Unqualified\nSolution: 2\n0: 2 2 0.9 1 0 -0 1 0.9\n  Outside Outside Enclosed\n1: 2 -1 3 1 0 -0 1 3\n  Enclosing Outside Enclosed\n\";\n\tCHECK(case45.find(expect45) != std::string::npos);\n\tauto case46 = c3t(circle1Unqualified, circle2Unqualified, lineEnclosed);\n\tauto expect46 = \"Test case: Unqualified Unqualified Enclosed\nSolution: 4\n0: 2 2 0.9 1 0 -0 1 0.9\n  Outside Outside Enclosed\n1: 2 5 3 1 0 -0 1 3\n  Outside Enclosing Enclosed\n2: 2 -1 3 1 0 -0 1 3\n  Enclosing Outside Enclosed\n3: 2 2 4.5 1 0 -0 1 4.5\n  Enclosing Enclosing Enclosed\n\";\n\tCHECK(case46.find(expect46) != std::string::npos);\n\tauto case47 = c3t(circle1Unqualified, circle2Unqualified, lineOutside);\n\tauto expect47 = \"Test case: Unqualified Unqualified Outside\nSolution: 0\n\";\n\tCHECK(case47.find(expect47) != std::string::npos);\n\tauto case48 = c3t(circle1Unqualified, circle2Unqualified, lineUnqualified);\n\tauto expect48 = \"Test case: Unqualified Unqualified Unqualified\nSolution: 4\n0: 2 2 0.9 1 0 -0 1 0.9\n  Outside Outside Enclosed\n1: 2 5 3 1 0 -0 1 3\n  Outside Enclosing Enclosed\n2: 2 -1 3 1 0 -0 1 3\n  Enclosing Outside Enclosed\n3: 2 2 4.5 1 0 -0 1 4.5\n  Enclosing Enclosing Enclosed\";\n\tCHECK(case48.find(expect48) != std::string::npos);\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API GccCircle3Tangent(const GccQualifiedCurve& qualified1, const GccQualifiedCurve& qualified2, const Point2& point, double tolerance, double parameter1, double parameter2)\t @param parameter2 The initial guess of the parameter on the second curve\n\t @param parameter1 The initial guess of the parameter on the first curve\n\t @param tolerance The tolerance\n\t @param point The point that the circle passes through\n\t @param qualified2 The second curve\n\t @param qualified1 The first curve\n\t @brief Construct a circle tangent to two curves and passing through a point\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <geomAlgo/GccCircle3Tangent.hpp>\n#include <geometry/Geom2Curve.hpp>\n#include <geometry/MakeGeom2Line.hpp>\n#include <geometry/MakeGeom2Circle.hpp>\n#include <geomAlgo/GccEntity.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geomAlgo/GccEntity.hpp>\n#include <geomAlgo/GccQualifiedCurve.hpp>\n#include <sstream>\nusing namespace AMCAX;\nTEST_CASE(\"bug1: GccCircle3Tangent  add 48 cases\", \"[geomAlgo][GccCircle3Tangent][fixbug]\") {\n\tstd::shared_ptr<Geom2Curve> l = MakeGeom2Line(Point2(0.0, 0.0), Point2(1.0, 0.0)).Value();\n\tstd::shared_ptr<Geom2Curve> c1 = MakeGeom2Circle(Point2(0.0, 3.0), 2.0).Value();\n\tstd::shared_ptr<Geom2Curve> c2 = MakeGeom2Circle(Point2(4.0, 3.0), 2.0).Value();\n\tAdaptorGeom2Curve line(l);\n\tAdaptorGeom2Curve circle1(c1);\n\tAdaptorGeom2Curve circle2(c2);\n\tauto lineEnclosed = GccEntity::Enclosed(line);\n\tauto lineOutside = GccEntity::Outside(line);\n\tauto lineUnqualified = GccEntity::Unqualified(line);\n\tauto circle1Enclosed = GccEntity::Enclosed(circle1);\n\tauto circle1Enclosing = GccEntity::Enclosing(circle1);\n\tauto circle1Outside = GccEntity::Outside(circle1);\n\tauto circle1Unqualified = GccEntity::Unqualified(circle1);\n\tauto circle2Enclosed = GccEntity::Enclosed(circle2);\n\tauto circle2Enclosing = GccEntity::Enclosing(circle2);\n\tauto circle2Outside = GccEntity::Outside(circle2);\n\tauto circle2Unqualified = GccEntity::Unqualified(circle2);\n\tauto gccl = GccEntity::Enclosed(AdaptorGeom2Curve(l));\n\tauto gccc1 = GccEntity::Enclosing(AdaptorGeom2Curve(c1));\n\tauto gccc2 = GccEntity::Outside(AdaptorGeom2Curve(c2));\n\tauto c3t = [](const GccQualifiedCurve& gccc1, const GccQualifiedCurve& gccc2, const GccQualifiedCurve& gccl)\n\t{\n\t\tstd::stringstream output;\n\t\tGccCircle3Tangent gcc(gccc1, gccc2, gccl, Precision::Confusion(), 0.0, 0.0, 0.0);\n\t\tstd::cout << \"Test case: \" << GccEntity::PositionToString(gccc1.Qualifier()) << ' ' << GccEntity::PositionToString(gccc2.Qualifier()) << ' ' << GccEntity::PositionToString(gccl.Qualifier()) << std::endl;\n\t\tstd::cout << \"Solution: \" << gcc.NSolutions() << std::endl;\n\t\toutput << \"Test case: \" << GccEntity::PositionToString(gccc1.Qualifier()) << ' ' << GccEntity::PositionToString(gccc2.Qualifier()) << ' ' << GccEntity::PositionToString(gccl.Qualifier()) << std::endl;\n\t\toutput << \"Solution: \" << gcc.NSolutions() << std::endl;\n\t\tif (gcc.IsDone())\n\t\t{\n\t\t\tfor (int i = 0; i < gcc.NSolutions(); i++)\n\t\t\t{\n\t\t\t\tGccPosition q1, q2, q3;\n\t\t\t\tgcc.Qualifier(i, q1, q2, q3);\n\t\t\t\toutput << i << \": \" << *MakeGeom2Circle(gcc.Solution(i)).Value() << std::endl;\n\t\t\t\toutput << \"  \" << GccEntity::PositionToString(q1) << ' ' << GccEntity::PositionToString(q2) << ' ' << GccEntity::PositionToString(q3) << std::endl;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tstd::cout << \"gcc.IsDone is False\" << std::endl;\n\t\t\toutput << \"gcc.IsDone is False\" << std::endl;\n\t\t}\n\t\treturn output.str();\n\t};\n\tauto case1 = c3t(circle1Enclosed, circle2Enclosed, lineEnclosed);\n\tauto expect1 = \"Test case: Enclosed Enclosed Enclosed\nSolution: 0\n\";\n\tCHECK(case1.find(expect1) != std::string::npos);\n\tauto case2 = c3t(circle1Enclosed, circle2Enclosed, lineOutside);\n\tauto expect2 = \"Test case: Enclosed Enclosed Outside\nSolution: 0\n\";\n\tCHECK(case2.find(expect2) != std::string::npos);\n\tauto case3 = c3t(circle1Enclosed, circle2Enclosed, lineUnqualified);\n\tauto expect3 = \"Test case: Enclosed Enclosed Unqualified\nSolution: 0\n\";\n\tCHECK(case3.find(expect3) != std::string::npos);\n\tauto case4 = c3t(circle1Enclosed, circle2Enclosing, lineEnclosed);\n\tauto expect4 = \"Test case: Enclosed Enclosing Enclosed\nSolution: 0\n\";\n\tCHECK(case4.find(expect4) != std::string::npos);\n\tauto case5 = c3t(circle1Enclosed, circle2Enclosing, lineOutside);\n\tauto expect5 = \"Test case: Enclosed Enclosing Outside\nSolution: 0\n\";\n\tCHECK(case5.find(expect5) != std::string::npos);\n\tauto case6 = c3t(circle1Enclosed, circle2Enclosing, lineUnqualified);\n\tauto expect6 = \"Test case: Enclosed Enclosing Unqualified\nSolution: 0\n\";\n\tCHECK(case6.find(expect6) != std::string::npos);\n\tauto case7 = c3t(circle1Enclosed, circle2Outside, lineEnclosed);\n\tauto expect7 = \"Test case: Enclosed Outside Enclosed\nSolution: 0\n\";\n\tCHECK(case7.find(expect7) != std::string::npos);\n\tauto case8 = c3t(circle1Enclosed, circle2Outside, lineOutside);\n\tauto expect8 = \"Test case: Enclosed Outside Outside\nSolution: 0\n\";\n\tCHECK(case8.find(expect8) != std::string::npos);\n\tauto case9 = c3t(circle1Enclosed, circle2Outside, lineUnqualified);\n\tauto expect9 = \"Test case: Enclosed Outside Unqualified\nSolution: 0\n\";\n\tCHECK(case9.find(expect9) != std::string::npos);\n\tauto case10 = c3t(circle1Enclosed, circle2Unqualified, lineEnclosed);\n\tauto expect10 = \"Test case: Enclosed Unqualified Enclosed\nSolution: 0\n\";\n\tCHECK(case10.find(expect10) != std::string::npos);\n\tauto case11 = c3t(circle1Enclosed, circle2Unqualified, lineOutside);\n\tauto expect11 = \"Test case: Enclosed Unqualified Outside\nSolution: 0\n\";\n\tCHECK(case11.find(expect11) != std::string::npos);\n\tauto case12 = c3t(circle1Enclosed, circle2Unqualified, lineUnqualified);\n\tauto expect12 = \"Test case: Enclosed Unqualified Unqualified\nSolution: 0\n\";\n\tCHECK(case12.find(expect12) != std::string::npos);\n\tauto case13 = c3t(circle1Enclosing, circle2Enclosed, lineEnclosed);\n\tauto expect13 = \"Test case: Enclosing Enclosed Enclosed\nSolution: 0\n\";\n\tCHECK(case13.find(expect13) != std::string::npos);\n\tauto case14 = c3t(circle1Enclosing, circle2Enclosed, lineOutside);\n\tauto expect14 = \"Test case: Enclosing Enclosed Outside\nSolution: 0\n\";\n\tCHECK(case14.find(expect14) != std::string::npos);\n\tauto case15 = c3t(circle1Enclosing, circle2Enclosed, lineUnqualified);\n\tauto expect15 = \"Test case: Enclosing Enclosed Unqualified\nSolution: 0\n\";\n\tCHECK(case15.find(expect15) != std::string::npos);\n\tauto case16 = c3t(circle1Enclosing, circle2Enclosing, lineEnclosed);\n\tauto expect16 = \"Test case: Enclosing Enclosing Enclosed\nSolution: 1\n0: 2 2 4.5 1 0 -0 1 4.5\n  Enclosing Enclosing Enclosed\n\";\n\tCHECK(case16.find(expect16) != std::string::npos);\n\tauto case17 = c3t(circle1Enclosing, circle2Enclosing, lineOutside);\n\tauto expect17 = \"Test case: Enclosing Enclosing Outside\nSolution: 0\n\";\n\tCHECK(case17.find(expect17) != std::string::npos);\n\tauto case18 = c3t(circle1Enclosing, circle2Enclosing, lineUnqualified);\n\tauto expect18 = \"Test case: Enclosing Enclosing Unqualified\nSolution: 1\n0: 2 2 4.5 1 0 -0 1 4.5\n  Enclosing Enclosing Enclosed\n\";\n\tCHECK(case18.find(expect18) != std::string::npos);\n\tauto case19 = c3t(circle1Enclosing, circle2Outside, lineEnclosed);\n\tauto expect19 = \"Test case: Enclosing Outside Enclosed\nSolution: 1\n0: 2 -1 3 1 0 -0 1 3\n  Enclosing Outside Enclosed\n\";\n\tCHECK(case19.find(expect19) != std::string::npos);\n\tauto case20 = c3t(circle1Enclosing, circle2Outside, lineOutside);\n\tauto expect20 = \"Test case: Enclosing Outside Outside\nSolution: 0\n\";\n\tCHECK(case20.find(expect20) != std::string::npos);\n\tauto case21 = c3t(circle1Enclosing, circle2Outside, lineUnqualified);\n\tauto expect21 = \"Test case: Enclosing Outside Unqualified\nSolution: 1\n0: 2 -1 3 1 0 -0 1 3\n  Enclosing Outside Enclosed\n\";\n\tCHECK(case21.find(expect21) != std::string::npos);\n\tauto case22 = c3t(circle1Enclosing, circle2Unqualified, lineEnclosed);\n\tauto expect22 = \"Test case: Enclosing Unqualified Enclosed\nSolution: 2\n0: 2 -1 3 1 0 -0 1 3\n  Enclosing Outside Enclosed\n1: 2 2 4.5 1 0 -0 1 4.5\n  Enclosing Enclosing Enclosed\n\";\n\tCHECK(case22.find(expect22) != std::string::npos);\n\tauto case23 = c3t(circle1Enclosing, circle2Unqualified, lineOutside);\n\tauto expect23 = \"Test case: Enclosing Unqualified Outside\nSolution: 0\n\";\n\tCHECK(case23.find(expect23) != std::string::npos);\n\tauto case24 = c3t(circle1Enclosing, circle2Unqualified, lineUnqualified);\n\tauto expect24 = \"Test case: Enclosing Unqualified Unqualified\nSolution: 2\n0: 2 -1 3 1 0 -0 1 3\n  Enclosing Outside Enclosed\n1: 2 2 4.5 1 0 -0 1 4.5\n  Enclosing Enclosing Enclosed\n\";\n\tCHECK(case24.find(expect24) != std::string::npos);\n\tauto case25 = c3t(circle1Outside, circle2Enclosed, lineEnclosed);\n\tauto expect25 = \"Test case: Outside Enclosed Enclosed\nSolution: 0\n\";\n\tCHECK(case25.find(expect25) != std::string::npos);\n\tauto case26 = c3t(circle1Outside, circle2Enclosed, lineOutside);\n\tauto expect26 = \"Test case: Outside Enclosed Outside\nSolution: 0\n\";\n\tCHECK(case26.find(expect26) != std::string::npos);\n\tauto case27 = c3t(circle1Outside, circle2Enclosed, lineUnqualified);\n\tauto expect27 = \"Test case: Outside Enclosed Unqualified\nSolution: 0\n\";\n\tCHECK(case27.find(expect27) != std::string::npos);\n\tauto case28 = c3t(circle1Outside, circle2Enclosing, lineEnclosed);\n\tauto expect28 = \"Test case: Outside Enclosing Enclosed\nSolution: 1\n0: 2 5 3 1 0 -0 1 3\n  Outside Enclosing Enclosed\n\";\n\tCHECK(case28.find(expect28) != std::string::npos);\n\tauto case29 = c3t(circle1Outside, circle2Enclosing, lineOutside);\n\tauto expect29 = \"Test case: Outside Enclosing Outside\nSolution: 0\n\";\n\tCHECK(case29.find(expect29) != std::string::npos);\n\tauto case30 = c3t(circle1Outside, circle2Enclosing, lineUnqualified);\n\tauto expect30 = \"Test case: Outside Enclosing Unqualified\nSolution: 1\n0: 2 5 3 1 0 -0 1 3\n  Outside Enclosing Enclosed\n\";\n\tCHECK(case30.find(expect30) != std::string::npos);\n\tauto case31 = c3t(circle1Outside, circle2Outside, lineEnclosed);\n\tauto expect31 = \"Test case: Outside Outside Enclosed\nSolution: 1\n0: 2 2 0.9 1 0 -0 1 0.9\n  Outside Outside Enclosed\n\";\n\tCHECK(case31.find(expect31) != std::string::npos);\n\tauto case32 = c3t(circle1Outside, circle2Outside, lineOutside);\n\tauto expect32 = \"Test case: Outside Outside Outside\nSolution: 0\n\";\n\tCHECK(case32.find(expect32) != std::string::npos);\n\tauto case33 = c3t(circle1Outside, circle2Outside, lineUnqualified);\n\tauto expect33 = \"Test case: Outside Outside Unqualified\nSolution: 1\n0: 2 2 0.9 1 0 -0 1 0.9\n  Outside Outside Enclosed\n\";\n\tCHECK(case33.find(expect33) != std::string::npos);\n\tauto case34 = c3t(circle1Outside, circle2Unqualified, lineEnclosed);\n\tauto expect34 = \"Test case: Outside Unqualified Enclosed\nSolution: 2\n0: 2 2 0.9 1 0 -0 1 0.9\n  Outside Outside Enclosed\n1: 2 5 3 1 0 -0 1 3\n  Outside Enclosing Enclosed\n\";\n\tCHECK(case34.find(expect34) != std::string::npos);\n\tauto case35 = c3t(circle1Outside, circle2Unqualified, lineOutside);\n\tauto expect35 = \"Test case: Outside Unqualified Outside\nSolution: 0\n\";\n\tCHECK(case35.find(expect35) != std::string::npos);\n\tauto case36 = c3t(circle1Outside, circle2Unqualified, lineUnqualified);\n\tauto expect36 = \"Test case: Outside Unqualified Unqualified\nSolution: 2\n0: 2 2 0.9 1 0 -0 1 0.9\n  Outside Outside Enclosed\n1: 2 5 3 1 0 -0 1 3\n  Outside Enclosing Enclosed\n\";\n\tCHECK(case36.find(expect36) != std::string::npos);\n\tauto case37 = c3t(circle1Unqualified, circle2Enclosed, lineEnclosed);\n\tauto expect37 = \"Test case: Unqualified Enclosed Enclosed\nSolution: 0\n\";\n\tCHECK(case37.find(expect37) != std::string::npos);\n\tauto case38 = c3t(circle1Unqualified, circle2Enclosed, lineOutside);\n\tauto expect38 = \"Test case: Unqualified Enclosed Outside\nSolution: 0\n\";\n\tCHECK(case38.find(expect38) != std::string::npos);\n\tauto case39 = c3t(circle1Unqualified, circle2Enclosed, lineUnqualified);\n\tauto expect39 = \"Test case: Unqualified Enclosed Unqualified\nSolution: 0\n\";\n\tCHECK(case39.find(expect39) != std::string::npos);\n\tauto case40 = c3t(circle1Unqualified, circle2Enclosing, lineEnclosed);\n\tauto expect40 = \"Test case: Unqualified Enclosing Enclosed\nSolution: 2\n0: 2 5 3 1 0 -0 1 3\n  Outside Enclosing Enclosed\n1: 2 2 4.5 1 0 -0 1 4.5\n  Enclosing Enclosing Enclosed\n\";\n\tCHECK(case40.find(expect40) != std::string::npos);\n\tauto case41 = c3t(circle1Unqualified, circle2Enclosing, lineOutside);\n\tauto expect41 = \"Test case: Unqualified Enclosing Outside\nSolution: 0\n\";\n\tCHECK(case41.find(expect41) != std::string::npos);\n\tauto case42 = c3t(circle1Unqualified, circle2Enclosing, lineUnqualified);\n\tauto expect42 = \"Test case: Unqualified Enclosing Unqualified\nSolution: 2\n0: 2 5 3 1 0 -0 1 3\n  Outside Enclosing Enclosed\n1: 2 2 4.5 1 0 -0 1 4.5\n  Enclosing Enclosing Enclosed\n\";\n\tCHECK(case42.find(expect42) != std::string::npos);\n\tauto case43 = c3t(circle1Unqualified, circle2Outside, lineEnclosed);\n\tauto expect43 = \"Test case: Unqualified Outside Enclosed\nSolution: 2\n0: 2 2 0.9 1 0 -0 1 0.9\n  Outside Outside Enclosed\n1: 2 -1 3 1 0 -0 1 3\n  Enclosing Outside Enclosed\n\";\n\tCHECK(case43.find(expect43) != std::string::npos);\n\tauto case44 = c3t(circle1Unqualified, circle2Outside, lineOutside);\n\tauto expect44 = \"Test case: Unqualified Outside Outside\nSolution: 0\n\";\n\tCHECK(case44.find(expect44) != std::string::npos);\n\tauto case45 = c3t(circle1Unqualified, circle2Outside, lineUnqualified);\n\tauto expect45 = \"Test case: Unqualified Outside Unqualified\nSolution: 2\n0: 2 2 0.9 1 0 -0 1 0.9\n  Outside Outside Enclosed\n1: 2 -1 3 1 0 -0 1 3\n  Enclosing Outside Enclosed\n\";\n\tCHECK(case45.find(expect45) != std::string::npos);\n\tauto case46 = c3t(circle1Unqualified, circle2Unqualified, lineEnclosed);\n\tauto expect46 = \"Test case: Unqualified Unqualified Enclosed\nSolution: 4\n0: 2 2 0.9 1 0 -0 1 0.9\n  Outside Outside Enclosed\n1: 2 5 3 1 0 -0 1 3\n  Outside Enclosing Enclosed\n2: 2 -1 3 1 0 -0 1 3\n  Enclosing Outside Enclosed\n3: 2 2 4.5 1 0 -0 1 4.5\n  Enclosing Enclosing Enclosed\n\";\n\tCHECK(case46.find(expect46) != std::string::npos);\n\tauto case47 = c3t(circle1Unqualified, circle2Unqualified, lineOutside);\n\tauto expect47 = \"Test case: Unqualified Unqualified Outside\nSolution: 0\n\";\n\tCHECK(case47.find(expect47) != std::string::npos);\n\tauto case48 = c3t(circle1Unqualified, circle2Unqualified, lineUnqualified);\n\tauto expect48 = \"Test case: Unqualified Unqualified Unqualified\nSolution: 4\n0: 2 2 0.9 1 0 -0 1 0.9\n  Outside Outside Enclosed\n1: 2 5 3 1 0 -0 1 3\n  Outside Enclosing Enclosed\n2: 2 -1 3 1 0 -0 1 3\n  Enclosing Outside Enclosed\n3: 2 2 4.5 1 0 -0 1 4.5\n  Enclosing Enclosing Enclosed\";\n\tCHECK(case48.find(expect48) != std::string::npos);\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API GccCircle3Tangent(const GccQualifiedCurve& qualified1, const GccQualifiedCurve& qualified2, const GccQualifiedCurve& qualified3, double tolerance, double parameter1, double parameter2, double parameter3)\t @param parameter3 The initial guess of the parameter on the third curve\n\t @param parameter2 The initial guess of the parameter on the second curve\n\t @param parameter1 The initial guess of the parameter on the first curve\n\t @param tolerance The tolerance\n\t @param qualified3 The third curve\n\t @param qualified2 The second curve\n\t @param qualified1 The first curve\n\t @brief Construct a circle tangent to three curves\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <geomAlgo/GccCircle3Tangent.hpp>\n#include <geometry/Geom2Curve.hpp>\n#include <geometry/MakeGeom2Line.hpp>\n#include <geometry/MakeGeom2Circle.hpp>\n#include <geomAlgo/GccEntity.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geomAlgo/GccEntity.hpp>\n#include <geomAlgo/GccQualifiedCurve.hpp>\n#include <sstream>\nusing namespace AMCAX;\nTEST_CASE(\"bug1: GccCircle3Tangent  add 48 cases\", \"[geomAlgo][GccCircle3Tangent][fixbug]\") {\n\tstd::shared_ptr<Geom2Curve> l = MakeGeom2Line(Point2(0.0, 0.0), Point2(1.0, 0.0)).Value();\n\tstd::shared_ptr<Geom2Curve> c1 = MakeGeom2Circle(Point2(0.0, 3.0), 2.0).Value();\n\tstd::shared_ptr<Geom2Curve> c2 = MakeGeom2Circle(Point2(4.0, 3.0), 2.0).Value();\n\tAdaptorGeom2Curve line(l);\n\tAdaptorGeom2Curve circle1(c1);\n\tAdaptorGeom2Curve circle2(c2);\n\tauto lineEnclosed = GccEntity::Enclosed(line);\n\tauto lineOutside = GccEntity::Outside(line);\n\tauto lineUnqualified = GccEntity::Unqualified(line);\n\tauto circle1Enclosed = GccEntity::Enclosed(circle1);\n\tauto circle1Enclosing = GccEntity::Enclosing(circle1);\n\tauto circle1Outside = GccEntity::Outside(circle1);\n\tauto circle1Unqualified = GccEntity::Unqualified(circle1);\n\tauto circle2Enclosed = GccEntity::Enclosed(circle2);\n\tauto circle2Enclosing = GccEntity::Enclosing(circle2);\n\tauto circle2Outside = GccEntity::Outside(circle2);\n\tauto circle2Unqualified = GccEntity::Unqualified(circle2);\n\tauto gccl = GccEntity::Enclosed(AdaptorGeom2Curve(l));\n\tauto gccc1 = GccEntity::Enclosing(AdaptorGeom2Curve(c1));\n\tauto gccc2 = GccEntity::Outside(AdaptorGeom2Curve(c2));\n\tauto c3t = [](const GccQualifiedCurve& gccc1, const GccQualifiedCurve& gccc2, const GccQualifiedCurve& gccl)\n\t{\n\t\tstd::stringstream output;\n\t\tGccCircle3Tangent gcc(gccc1, gccc2, gccl, Precision::Confusion(), 0.0, 0.0, 0.0);\n\t\tstd::cout << \"Test case: \" << GccEntity::PositionToString(gccc1.Qualifier()) << ' ' << GccEntity::PositionToString(gccc2.Qualifier()) << ' ' << GccEntity::PositionToString(gccl.Qualifier()) << std::endl;\n\t\tstd::cout << \"Solution: \" << gcc.NSolutions() << std::endl;\n\t\toutput << \"Test case: \" << GccEntity::PositionToString(gccc1.Qualifier()) << ' ' << GccEntity::PositionToString(gccc2.Qualifier()) << ' ' << GccEntity::PositionToString(gccl.Qualifier()) << std::endl;\n\t\toutput << \"Solution: \" << gcc.NSolutions() << std::endl;\n\t\tif (gcc.IsDone())\n\t\t{\n\t\t\tfor (int i = 0; i < gcc.NSolutions(); i++)\n\t\t\t{\n\t\t\t\tGccPosition q1, q2, q3;\n\t\t\t\tgcc.Qualifier(i, q1, q2, q3);\n\t\t\t\toutput << i << \": \" << *MakeGeom2Circle(gcc.Solution(i)).Value() << std::endl;\n\t\t\t\toutput << \"  \" << GccEntity::PositionToString(q1) << ' ' << GccEntity::PositionToString(q2) << ' ' << GccEntity::PositionToString(q3) << std::endl;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tstd::cout << \"gcc.IsDone is False\" << std::endl;\n\t\t\toutput << \"gcc.IsDone is False\" << std::endl;\n\t\t}\n\t\treturn output.str();\n\t};\n\tauto case1 = c3t(circle1Enclosed, circle2Enclosed, lineEnclosed);\n\tauto expect1 = \"Test case: Enclosed Enclosed Enclosed\nSolution: 0\n\";\n\tCHECK(case1.find(expect1) != std::string::npos);\n\tauto case2 = c3t(circle1Enclosed, circle2Enclosed, lineOutside);\n\tauto expect2 = \"Test case: Enclosed Enclosed Outside\nSolution: 0\n\";\n\tCHECK(case2.find(expect2) != std::string::npos);\n\tauto case3 = c3t(circle1Enclosed, circle2Enclosed, lineUnqualified);\n\tauto expect3 = \"Test case: Enclosed Enclosed Unqualified\nSolution: 0\n\";\n\tCHECK(case3.find(expect3) != std::string::npos);\n\tauto case4 = c3t(circle1Enclosed, circle2Enclosing, lineEnclosed);\n\tauto expect4 = \"Test case: Enclosed Enclosing Enclosed\nSolution: 0\n\";\n\tCHECK(case4.find(expect4) != std::string::npos);\n\tauto case5 = c3t(circle1Enclosed, circle2Enclosing, lineOutside);\n\tauto expect5 = \"Test case: Enclosed Enclosing Outside\nSolution: 0\n\";\n\tCHECK(case5.find(expect5) != std::string::npos);\n\tauto case6 = c3t(circle1Enclosed, circle2Enclosing, lineUnqualified);\n\tauto expect6 = \"Test case: Enclosed Enclosing Unqualified\nSolution: 0\n\";\n\tCHECK(case6.find(expect6) != std::string::npos);\n\tauto case7 = c3t(circle1Enclosed, circle2Outside, lineEnclosed);\n\tauto expect7 = \"Test case: Enclosed Outside Enclosed\nSolution: 0\n\";\n\tCHECK(case7.find(expect7) != std::string::npos);\n\tauto case8 = c3t(circle1Enclosed, circle2Outside, lineOutside);\n\tauto expect8 = \"Test case: Enclosed Outside Outside\nSolution: 0\n\";\n\tCHECK(case8.find(expect8) != std::string::npos);\n\tauto case9 = c3t(circle1Enclosed, circle2Outside, lineUnqualified);\n\tauto expect9 = \"Test case: Enclosed Outside Unqualified\nSolution: 0\n\";\n\tCHECK(case9.find(expect9) != std::string::npos);\n\tauto case10 = c3t(circle1Enclosed, circle2Unqualified, lineEnclosed);\n\tauto expect10 = \"Test case: Enclosed Unqualified Enclosed\nSolution: 0\n\";\n\tCHECK(case10.find(expect10) != std::string::npos);\n\tauto case11 = c3t(circle1Enclosed, circle2Unqualified, lineOutside);\n\tauto expect11 = \"Test case: Enclosed Unqualified Outside\nSolution: 0\n\";\n\tCHECK(case11.find(expect11) != std::string::npos);\n\tauto case12 = c3t(circle1Enclosed, circle2Unqualified, lineUnqualified);\n\tauto expect12 = \"Test case: Enclosed Unqualified Unqualified\nSolution: 0\n\";\n\tCHECK(case12.find(expect12) != std::string::npos);\n\tauto case13 = c3t(circle1Enclosing, circle2Enclosed, lineEnclosed);\n\tauto expect13 = \"Test case: Enclosing Enclosed Enclosed\nSolution: 0\n\";\n\tCHECK(case13.find(expect13) != std::string::npos);\n\tauto case14 = c3t(circle1Enclosing, circle2Enclosed, lineOutside);\n\tauto expect14 = \"Test case: Enclosing Enclosed Outside\nSolution: 0\n\";\n\tCHECK(case14.find(expect14) != std::string::npos);\n\tauto case15 = c3t(circle1Enclosing, circle2Enclosed, lineUnqualified);\n\tauto expect15 = \"Test case: Enclosing Enclosed Unqualified\nSolution: 0\n\";\n\tCHECK(case15.find(expect15) != std::string::npos);\n\tauto case16 = c3t(circle1Enclosing, circle2Enclosing, lineEnclosed);\n\tauto expect16 = \"Test case: Enclosing Enclosing Enclosed\nSolution: 1\n0: 2 2 4.5 1 0 -0 1 4.5\n  Enclosing Enclosing Enclosed\n\";\n\tCHECK(case16.find(expect16) != std::string::npos);\n\tauto case17 = c3t(circle1Enclosing, circle2Enclosing, lineOutside);\n\tauto expect17 = \"Test case: Enclosing Enclosing Outside\nSolution: 0\n\";\n\tCHECK(case17.find(expect17) != std::string::npos);\n\tauto case18 = c3t(circle1Enclosing, circle2Enclosing, lineUnqualified);\n\tauto expect18 = \"Test case: Enclosing Enclosing Unqualified\nSolution: 1\n0: 2 2 4.5 1 0 -0 1 4.5\n  Enclosing Enclosing Enclosed\n\";\n\tCHECK(case18.find(expect18) != std::string::npos);\n\tauto case19 = c3t(circle1Enclosing, circle2Outside, lineEnclosed);\n\tauto expect19 = \"Test case: Enclosing Outside Enclosed\nSolution: 1\n0: 2 -1 3 1 0 -0 1 3\n  Enclosing Outside Enclosed\n\";\n\tCHECK(case19.find(expect19) != std::string::npos);\n\tauto case20 = c3t(circle1Enclosing, circle2Outside, lineOutside);\n\tauto expect20 = \"Test case: Enclosing Outside Outside\nSolution: 0\n\";\n\tCHECK(case20.find(expect20) != std::string::npos);\n\tauto case21 = c3t(circle1Enclosing, circle2Outside, lineUnqualified);\n\tauto expect21 = \"Test case: Enclosing Outside Unqualified\nSolution: 1\n0: 2 -1 3 1 0 -0 1 3\n  Enclosing Outside Enclosed\n\";\n\tCHECK(case21.find(expect21) != std::string::npos);\n\tauto case22 = c3t(circle1Enclosing, circle2Unqualified, lineEnclosed);\n\tauto expect22 = \"Test case: Enclosing Unqualified Enclosed\nSolution: 2\n0: 2 -1 3 1 0 -0 1 3\n  Enclosing Outside Enclosed\n1: 2 2 4.5 1 0 -0 1 4.5\n  Enclosing Enclosing Enclosed\n\";\n\tCHECK(case22.find(expect22) != std::string::npos);\n\tauto case23 = c3t(circle1Enclosing, circle2Unqualified, lineOutside);\n\tauto expect23 = \"Test case: Enclosing Unqualified Outside\nSolution: 0\n\";\n\tCHECK(case23.find(expect23) != std::string::npos);\n\tauto case24 = c3t(circle1Enclosing, circle2Unqualified, lineUnqualified);\n\tauto expect24 = \"Test case: Enclosing Unqualified Unqualified\nSolution: 2\n0: 2 -1 3 1 0 -0 1 3\n  Enclosing Outside Enclosed\n1: 2 2 4.5 1 0 -0 1 4.5\n  Enclosing Enclosing Enclosed\n\";\n\tCHECK(case24.find(expect24) != std::string::npos);\n\tauto case25 = c3t(circle1Outside, circle2Enclosed, lineEnclosed);\n\tauto expect25 = \"Test case: Outside Enclosed Enclosed\nSolution: 0\n\";\n\tCHECK(case25.find(expect25) != std::string::npos);\n\tauto case26 = c3t(circle1Outside, circle2Enclosed, lineOutside);\n\tauto expect26 = \"Test case: Outside Enclosed Outside\nSolution: 0\n\";\n\tCHECK(case26.find(expect26) != std::string::npos);\n\tauto case27 = c3t(circle1Outside, circle2Enclosed, lineUnqualified);\n\tauto expect27 = \"Test case: Outside Enclosed Unqualified\nSolution: 0\n\";\n\tCHECK(case27.find(expect27) != std::string::npos);\n\tauto case28 = c3t(circle1Outside, circle2Enclosing, lineEnclosed);\n\tauto expect28 = \"Test case: Outside Enclosing Enclosed\nSolution: 1\n0: 2 5 3 1 0 -0 1 3\n  Outside Enclosing Enclosed\n\";\n\tCHECK(case28.find(expect28) != std::string::npos);\n\tauto case29 = c3t(circle1Outside, circle2Enclosing, lineOutside);\n\tauto expect29 = \"Test case: Outside Enclosing Outside\nSolution: 0\n\";\n\tCHECK(case29.find(expect29) != std::string::npos);\n\tauto case30 = c3t(circle1Outside, circle2Enclosing, lineUnqualified);\n\tauto expect30 = \"Test case: Outside Enclosing Unqualified\nSolution: 1\n0: 2 5 3 1 0 -0 1 3\n  Outside Enclosing Enclosed\n\";\n\tCHECK(case30.find(expect30) != std::string::npos);\n\tauto case31 = c3t(circle1Outside, circle2Outside, lineEnclosed);\n\tauto expect31 = \"Test case: Outside Outside Enclosed\nSolution: 1\n0: 2 2 0.9 1 0 -0 1 0.9\n  Outside Outside Enclosed\n\";\n\tCHECK(case31.find(expect31) != std::string::npos);\n\tauto case32 = c3t(circle1Outside, circle2Outside, lineOutside);\n\tauto expect32 = \"Test case: Outside Outside Outside\nSolution: 0\n\";\n\tCHECK(case32.find(expect32) != std::string::npos);\n\tauto case33 = c3t(circle1Outside, circle2Outside, lineUnqualified);\n\tauto expect33 = \"Test case: Outside Outside Unqualified\nSolution: 1\n0: 2 2 0.9 1 0 -0 1 0.9\n  Outside Outside Enclosed\n\";\n\tCHECK(case33.find(expect33) != std::string::npos);\n\tauto case34 = c3t(circle1Outside, circle2Unqualified, lineEnclosed);\n\tauto expect34 = \"Test case: Outside Unqualified Enclosed\nSolution: 2\n0: 2 2 0.9 1 0 -0 1 0.9\n  Outside Outside Enclosed\n1: 2 5 3 1 0 -0 1 3\n  Outside Enclosing Enclosed\n\";\n\tCHECK(case34.find(expect34) != std::string::npos);\n\tauto case35 = c3t(circle1Outside, circle2Unqualified, lineOutside);\n\tauto expect35 = \"Test case: Outside Unqualified Outside\nSolution: 0\n\";\n\tCHECK(case35.find(expect35) != std::string::npos);\n\tauto case36 = c3t(circle1Outside, circle2Unqualified, lineUnqualified);\n\tauto expect36 = \"Test case: Outside Unqualified Unqualified\nSolution: 2\n0: 2 2 0.9 1 0 -0 1 0.9\n  Outside Outside Enclosed\n1: 2 5 3 1 0 -0 1 3\n  Outside Enclosing Enclosed\n\";\n\tCHECK(case36.find(expect36) != std::string::npos);\n\tauto case37 = c3t(circle1Unqualified, circle2Enclosed, lineEnclosed);\n\tauto expect37 = \"Test case: Unqualified Enclosed Enclosed\nSolution: 0\n\";\n\tCHECK(case37.find(expect37) != std::string::npos);\n\tauto case38 = c3t(circle1Unqualified, circle2Enclosed, lineOutside);\n\tauto expect38 = \"Test case: Unqualified Enclosed Outside\nSolution: 0\n\";\n\tCHECK(case38.find(expect38) != std::string::npos);\n\tauto case39 = c3t(circle1Unqualified, circle2Enclosed, lineUnqualified);\n\tauto expect39 = \"Test case: Unqualified Enclosed Unqualified\nSolution: 0\n\";\n\tCHECK(case39.find(expect39) != std::string::npos);\n\tauto case40 = c3t(circle1Unqualified, circle2Enclosing, lineEnclosed);\n\tauto expect40 = \"Test case: Unqualified Enclosing Enclosed\nSolution: 2\n0: 2 5 3 1 0 -0 1 3\n  Outside Enclosing Enclosed\n1: 2 2 4.5 1 0 -0 1 4.5\n  Enclosing Enclosing Enclosed\n\";\n\tCHECK(case40.find(expect40) != std::string::npos);\n\tauto case41 = c3t(circle1Unqualified, circle2Enclosing, lineOutside);\n\tauto expect41 = \"Test case: Unqualified Enclosing Outside\nSolution: 0\n\";\n\tCHECK(case41.find(expect41) != std::string::npos);\n\tauto case42 = c3t(circle1Unqualified, circle2Enclosing, lineUnqualified);\n\tauto expect42 = \"Test case: Unqualified Enclosing Unqualified\nSolution: 2\n0: 2 5 3 1 0 -0 1 3\n  Outside Enclosing Enclosed\n1: 2 2 4.5 1 0 -0 1 4.5\n  Enclosing Enclosing Enclosed\n\";\n\tCHECK(case42.find(expect42) != std::string::npos);\n\tauto case43 = c3t(circle1Unqualified, circle2Outside, lineEnclosed);\n\tauto expect43 = \"Test case: Unqualified Outside Enclosed\nSolution: 2\n0: 2 2 0.9 1 0 -0 1 0.9\n  Outside Outside Enclosed\n1: 2 -1 3 1 0 -0 1 3\n  Enclosing Outside Enclosed\n\";\n\tCHECK(case43.find(expect43) != std::string::npos);\n\tauto case44 = c3t(circle1Unqualified, circle2Outside, lineOutside);\n\tauto expect44 = \"Test case: Unqualified Outside Outside\nSolution: 0\n\";\n\tCHECK(case44.find(expect44) != std::string::npos);\n\tauto case45 = c3t(circle1Unqualified, circle2Outside, lineUnqualified);\n\tauto expect45 = \"Test case: Unqualified Outside Unqualified\nSolution: 2\n0: 2 2 0.9 1 0 -0 1 0.9\n  Outside Outside Enclosed\n1: 2 -1 3 1 0 -0 1 3\n  Enclosing Outside Enclosed\n\";\n\tCHECK(case45.find(expect45) != std::string::npos);\n\tauto case46 = c3t(circle1Unqualified, circle2Unqualified, lineEnclosed);\n\tauto expect46 = \"Test case: Unqualified Unqualified Enclosed\nSolution: 4\n0: 2 2 0.9 1 0 -0 1 0.9\n  Outside Outside Enclosed\n1: 2 5 3 1 0 -0 1 3\n  Outside Enclosing Enclosed\n2: 2 -1 3 1 0 -0 1 3\n  Enclosing Outside Enclosed\n3: 2 2 4.5 1 0 -0 1 4.5\n  Enclosing Enclosing Enclosed\n\";\n\tCHECK(case46.find(expect46) != std::string::npos);\n\tauto case47 = c3t(circle1Unqualified, circle2Unqualified, lineOutside);\n\tauto expect47 = \"Test case: Unqualified Unqualified Outside\nSolution: 0\n\";\n\tCHECK(case47.find(expect47) != std::string::npos);\n\tauto case48 = c3t(circle1Unqualified, circle2Unqualified, lineUnqualified);\n\tauto expect48 = \"Test case: Unqualified Unqualified Unqualified\nSolution: 4\n0: 2 2 0.9 1 0 -0 1 0.9\n  Outside Outside Enclosed\n1: 2 5 3 1 0 -0 1 3\n  Outside Enclosing Enclosed\n2: 2 -1 3 1 0 -0 1 3\n  Enclosing Outside Enclosed\n3: 2 2 4.5 1 0 -0 1 4.5\n  Enclosing Enclosing Enclosed\";\n\tCHECK(case48.find(expect48) != std::string::npos);\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API MakeFace(const Sphere& s, const TopoWire& w, bool inside = true)\t @param inside Whether the face is inside the wire\n\t @param w The wire\n\t @param s The sphere\n\t @brief Construct from a sphere and a wire\n,\n",
      "output": "﻿#include<catch.hpp>\n#include<testHelper.h>\n#include <topology/TopoExplorerTool.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeWire.hpp>\n#include <modeling/MakeFace.hpp>\n#include <offset/MakeFaceExtension.hpp>\n#include <topomesh/BRepMeshIncrementalMesh.hpp>\n#include <io/OBJTool.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <topology/TopoTool.hpp>\n#include <topology/TopoVertex.hpp>\nusing namespace AMCAX;\n﻿#include<catch.hpp>\n#include<testHelper.h>\n#include <topology/TopoExplorerTool.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeWire.hpp>\n#include <modeling/MakeFace.hpp>\n#include <offset/MakeFaceExtension.hpp>\n#include <topomesh/BRepMeshIncrementalMesh.hpp>\n#include <io/OBJTool.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <topology/TopoTool.hpp>\n#include <topology/TopoVertex.hpp>\nusing namespace AMCAX;\n;\n\tSECTION(\"check length = 1\") {\n\t\tfor (size_t i = 0; i < fedge.size(); i++)\n\t\t{\n\t\t\tstd::cout << \"i = \" << i << std::endl;\n\t\t\tTopoEdge edge = static_cast<const TopoEdge&>(fedge[i]);\n\t\t\tmkExt.PerformWithEdgeAndLength(edge, 1.0);\n\t\t\tCHECK(mkExt.IsDone() == true);\n\t\t\tTopoShape newshape = mkExt.Shape();\n\t\t\tTopoFace newface = TopoCast::Face(newshape);\n\t\t\tIndexSet<TopoShape> fedge2;\n\t\t\tTopoExplorerTool::MapShapes(newface, ShapeType::Edge, fedge2);\n\t\t\tPoint3 p,p2,p3;\n\t\t\tdouble tol = 0.01;\n\t\t\tswitch (i)\n\t\t\t{\n\t\t\tcase 0: \n\t\t\t\tp = Point3(10.0, -1.0, 1.0);\n\t\t\t\tp2 = Point3(10.3, -1.0, 1.0);\n\t\t\t\tp3 = Point3(-10.1, -0.3, 1.0);\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tp = Point3(11.05, 0.0, 1.0);\n\t\t\t\tp2 = Point3(10.0, 3.15, 1.0);\n\t\t\t\tp3 = Point3(9.4, 5.0, 1.0);\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tp = Point3(0.0, 7.0, 1.0);\n\t\t\t\tp2 = Point3(-7.5, 7.0, 1.0);\n\t\t\t\tp3 = Point3(7.4, 7.01, 1.0);\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tp = Point3(-10.05, 3.0, 1.0);\n\t\t\t\tp2 = Point3(-11.0, 0.15, 1.0);\n\t\t\t\tp3 = Point3(9.8, 0.6, 1.0);\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t\tp = Point3(0.0, 2.5, 1.0);\n\t\t\t\tp2 = Point3(-4.2, 2.5, 1.0);\n\t\t\t\tp3 = Point3(4.3, 2.55, 1.0);\n\t\t\t\tbreak;\n\t\t\tcase 5:\n\t\t\t\tp = Point3(2.8, 3.0, 1.0);\n\t\t\t\tp2 = Point3(3.7, 1.65, 1.0);\n\t\t\t\tp3 = Point3(1.9, 4.35, 1.0);\n\t\t\t\tbreak;\n\t\t\tcase 6:\n\t\t\t\tp = Point3(0.0, 3.5, 1.0);\n\t\t\t\tp2 = Point3(3.5, 3.5, 1.0);\n\t\t\t\tp3 = Point3(-3.61, 3.50, 1.0);\n\t\t\t\tbreak;\n\t\t\tcase 7:\n\t\t\t\tp = Point3(-2.8, 3.0, 1.0);\n\t\t\t\tp2 = Point3(-9.98, 0.048, 1.0);\n\t\t\t\tp3 = Point3(-8.0, 5.97, 1.0);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tp = Point3(-999.0, -9999.0, -9999.0);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbool isOn = false;\n\t\t\tbool isOn2 = false;\n\t\t\tbool isOn3 = false;\n\t\t\tint matchNum = 0;\n\t\t\tfor (int j = 0; j < fedge2.size(); ++j)\n\t\t\t{\n\t\t\t\tTopoEdge newEdge = static_cast<const TopoEdge&>(fedge2[j]);\n\t\t\t\tisOn = BRepClassificationTools::IsPointInOnEdge(newEdge, p, tol);\n\t\t\t\tisOn2 = BRepClassificationTools::IsPointInOnEdge(newEdge, p2, tol);\n\t\t\t\tisOn3 = BRepClassificationTools::IsPointInOnEdge(newEdge, p3, tol);\n\t\t\t\tif (isOn)\n\t\t\t\t{\n\t\t\t\t\tmatchNum = matchNum + 1;\n\t\t\t\t}\n\t\t\t\tif (isOn2)\n\t\t\t\t{\n\t\t\t\t\tmatchNum = matchNum + 1;\n\t\t\t\t}\n\t\t\t\tif (isOn3)\n\t\t\t\t{\n\t\t\t\t\tmatchNum = matchNum + 1;\n\t\t\t\t}\t\t\t\t\n\t\t\t}\n\t\t\tCHECK(matchNum == 3);\n\t\t\t}\n\t\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API MakeFace(const std::shared_ptr<Geom3Surface>& s, double tolDegen)\t @param tolDegen The tolerance\n\t @param s The surface\n\t @brief Construct from a surface with tolerance for degenerated edges\n,\n",
      "output": "﻿#include<catch.hpp>\n#include<testHelper.h>\n#include <topology/TopoExplorerTool.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeWire.hpp>\n#include <modeling/MakeFace.hpp>\n#include <offset/MakeFaceExtension.hpp>\n#include <topomesh/BRepMeshIncrementalMesh.hpp>\n#include <io/OBJTool.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <topology/TopoTool.hpp>\n#include <topology/TopoVertex.hpp>\nusing namespace AMCAX;\n﻿#include<catch.hpp>\n#include<testHelper.h>\n#include <topology/TopoExplorerTool.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeWire.hpp>\n#include <modeling/MakeFace.hpp>\n#include <offset/MakeFaceExtension.hpp>\n#include <topomesh/BRepMeshIncrementalMesh.hpp>\n#include <io/OBJTool.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <topology/TopoTool.hpp>\n#include <topology/TopoVertex.hpp>\nusing namespace AMCAX;\n;\n\tSECTION(\"check length = 1\") {\n\t\tfor (size_t i = 0; i < fedge.size(); i++)\n\t\t{\n\t\t\tstd::cout << \"i = \" << i << std::endl;\n\t\t\tTopoEdge edge = static_cast<const TopoEdge&>(fedge[i]);\n\t\t\tmkExt.PerformWithEdgeAndLength(edge, 1.0);\n\t\t\tCHECK(mkExt.IsDone() == true);\n\t\t\tTopoShape newshape = mkExt.Shape();\n\t\t\tTopoFace newface = TopoCast::Face(newshape);\n\t\t\tIndexSet<TopoShape> fedge2;\n\t\t\tTopoExplorerTool::MapShapes(newface, ShapeType::Edge, fedge2);\n\t\t\tPoint3 p,p2,p3;\n\t\t\tdouble tol = 0.01;\n\t\t\tswitch (i)\n\t\t\t{\n\t\t\tcase 0: \n\t\t\t\tp = Point3(10.0, -1.0, 1.0);\n\t\t\t\tp2 = Point3(10.3, -1.0, 1.0);\n\t\t\t\tp3 = Point3(-10.1, -0.3, 1.0);\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tp = Point3(11.05, 0.0, 1.0);\n\t\t\t\tp2 = Point3(10.0, 3.15, 1.0);\n\t\t\t\tp3 = Point3(9.4, 5.0, 1.0);\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tp = Point3(0.0, 7.0, 1.0);\n\t\t\t\tp2 = Point3(-7.5, 7.0, 1.0);\n\t\t\t\tp3 = Point3(7.4, 7.01, 1.0);\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tp = Point3(-10.05, 3.0, 1.0);\n\t\t\t\tp2 = Point3(-11.0, 0.15, 1.0);\n\t\t\t\tp3 = Point3(9.8, 0.6, 1.0);\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t\tp = Point3(0.0, 2.5, 1.0);\n\t\t\t\tp2 = Point3(-4.2, 2.5, 1.0);\n\t\t\t\tp3 = Point3(4.3, 2.55, 1.0);\n\t\t\t\tbreak;\n\t\t\tcase 5:\n\t\t\t\tp = Point3(2.8, 3.0, 1.0);\n\t\t\t\tp2 = Point3(3.7, 1.65, 1.0);\n\t\t\t\tp3 = Point3(1.9, 4.35, 1.0);\n\t\t\t\tbreak;\n\t\t\tcase 6:\n\t\t\t\tp = Point3(0.0, 3.5, 1.0);\n\t\t\t\tp2 = Point3(3.5, 3.5, 1.0);\n\t\t\t\tp3 = Point3(-3.61, 3.50, 1.0);\n\t\t\t\tbreak;\n\t\t\tcase 7:\n\t\t\t\tp = Point3(-2.8, 3.0, 1.0);\n\t\t\t\tp2 = Point3(-9.98, 0.048, 1.0);\n\t\t\t\tp3 = Point3(-8.0, 5.97, 1.0);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tp = Point3(-999.0, -9999.0, -9999.0);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbool isOn = false;\n\t\t\tbool isOn2 = false;\n\t\t\tbool isOn3 = false;\n\t\t\tint matchNum = 0;\n\t\t\tfor (int j = 0; j < fedge2.size(); ++j)\n\t\t\t{\n\t\t\t\tTopoEdge newEdge = static_cast<const TopoEdge&>(fedge2[j]);\n\t\t\t\tisOn = BRepClassificationTools::IsPointInOnEdge(newEdge, p, tol);\n\t\t\t\tisOn2 = BRepClassificationTools::IsPointInOnEdge(newEdge, p2, tol);\n\t\t\t\tisOn3 = BRepClassificationTools::IsPointInOnEdge(newEdge, p3, tol);\n\t\t\t\tif (isOn)\n\t\t\t\t{\n\t\t\t\t\tmatchNum = matchNum + 1;\n\t\t\t\t}\n\t\t\t\tif (isOn2)\n\t\t\t\t{\n\t\t\t\t\tmatchNum = matchNum + 1;\n\t\t\t\t}\n\t\t\t\tif (isOn3)\n\t\t\t\t{\n\t\t\t\t\tmatchNum = matchNum + 1;\n\t\t\t\t}\t\t\t\t\n\t\t\t}\n\t\t\tCHECK(matchNum == 3);\n\t\t\t}\n\t\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API explicit MakeFace(const TopoFace& f)\t @param f The face\n\t @brief construct from a face\n,\n",
      "output": "﻿#include<catch.hpp>\n#include<testHelper.h>\n#include <topology/TopoExplorerTool.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeWire.hpp>\n#include <modeling/MakeFace.hpp>\n#include <offset/MakeFaceExtension.hpp>\n#include <topomesh/BRepMeshIncrementalMesh.hpp>\n#include <io/OBJTool.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <topology/TopoTool.hpp>\n#include <topology/TopoVertex.hpp>\nusing namespace AMCAX;\n﻿#include<catch.hpp>\n#include<testHelper.h>\n#include <topology/TopoExplorerTool.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeWire.hpp>\n#include <modeling/MakeFace.hpp>\n#include <offset/MakeFaceExtension.hpp>\n#include <topomesh/BRepMeshIncrementalMesh.hpp>\n#include <io/OBJTool.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <topology/TopoTool.hpp>\n#include <topology/TopoVertex.hpp>\nusing namespace AMCAX;\n;\n\tSECTION(\"check length = 1\") {\n\t\tfor (size_t i = 0; i < fedge.size(); i++)\n\t\t{\n\t\t\tstd::cout << \"i = \" << i << std::endl;\n\t\t\tTopoEdge edge = static_cast<const TopoEdge&>(fedge[i]);\n\t\t\tmkExt.PerformWithEdgeAndLength(edge, 1.0);\n\t\t\tCHECK(mkExt.IsDone() == true);\n\t\t\tTopoShape newshape = mkExt.Shape();\n\t\t\tTopoFace newface = TopoCast::Face(newshape);\n\t\t\tIndexSet<TopoShape> fedge2;\n\t\t\tTopoExplorerTool::MapShapes(newface, ShapeType::Edge, fedge2);\n\t\t\tPoint3 p,p2,p3;\n\t\t\tdouble tol = 0.01;\n\t\t\tswitch (i)\n\t\t\t{\n\t\t\tcase 0: \n\t\t\t\tp = Point3(10.0, -1.0, 1.0);\n\t\t\t\tp2 = Point3(10.3, -1.0, 1.0);\n\t\t\t\tp3 = Point3(-10.1, -0.3, 1.0);\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tp = Point3(11.05, 0.0, 1.0);\n\t\t\t\tp2 = Point3(10.0, 3.15, 1.0);\n\t\t\t\tp3 = Point3(9.4, 5.0, 1.0);\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tp = Point3(0.0, 7.0, 1.0);\n\t\t\t\tp2 = Point3(-7.5, 7.0, 1.0);\n\t\t\t\tp3 = Point3(7.4, 7.01, 1.0);\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tp = Point3(-10.05, 3.0, 1.0);\n\t\t\t\tp2 = Point3(-11.0, 0.15, 1.0);\n\t\t\t\tp3 = Point3(9.8, 0.6, 1.0);\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t\tp = Point3(0.0, 2.5, 1.0);\n\t\t\t\tp2 = Point3(-4.2, 2.5, 1.0);\n\t\t\t\tp3 = Point3(4.3, 2.55, 1.0);\n\t\t\t\tbreak;\n\t\t\tcase 5:\n\t\t\t\tp = Point3(2.8, 3.0, 1.0);\n\t\t\t\tp2 = Point3(3.7, 1.65, 1.0);\n\t\t\t\tp3 = Point3(1.9, 4.35, 1.0);\n\t\t\t\tbreak;\n\t\t\tcase 6:\n\t\t\t\tp = Point3(0.0, 3.5, 1.0);\n\t\t\t\tp2 = Point3(3.5, 3.5, 1.0);\n\t\t\t\tp3 = Point3(-3.61, 3.50, 1.0);\n\t\t\t\tbreak;\n\t\t\tcase 7:\n\t\t\t\tp = Point3(-2.8, 3.0, 1.0);\n\t\t\t\tp2 = Point3(-9.98, 0.048, 1.0);\n\t\t\t\tp3 = Point3(-8.0, 5.97, 1.0);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tp = Point3(-999.0, -9999.0, -9999.0);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbool isOn = false;\n\t\t\tbool isOn2 = false;\n\t\t\tbool isOn3 = false;\n\t\t\tint matchNum = 0;\n\t\t\tfor (int j = 0; j < fedge2.size(); ++j)\n\t\t\t{\n\t\t\t\tTopoEdge newEdge = static_cast<const TopoEdge&>(fedge2[j]);\n\t\t\t\tisOn = BRepClassificationTools::IsPointInOnEdge(newEdge, p, tol);\n\t\t\t\tisOn2 = BRepClassificationTools::IsPointInOnEdge(newEdge, p2, tol);\n\t\t\t\tisOn3 = BRepClassificationTools::IsPointInOnEdge(newEdge, p3, tol);\n\t\t\t\tif (isOn)\n\t\t\t\t{\n\t\t\t\t\tmatchNum = matchNum + 1;\n\t\t\t\t}\n\t\t\t\tif (isOn2)\n\t\t\t\t{\n\t\t\t\t\tmatchNum = matchNum + 1;\n\t\t\t\t}\n\t\t\t\tif (isOn3)\n\t\t\t\t{\n\t\t\t\t\tmatchNum = matchNum + 1;\n\t\t\t\t}\t\t\t\t\n\t\t\t}\n\t\t\tCHECK(matchNum == 3);\n\t\t\t}\n\t\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API MakeFace(const std::shared_ptr<Geom3Surface>& s, const TopoWire& w, bool inside = true)\t @param inside Whether the face is inside the wire\n\t @param w The wire\n\t @param s The surface\n\t @brief Construct from a surface and a wire\n,\n",
      "output": "#include <catch.hpp>\n#include \"testHelper.h\"\n#include<iostream>\n#include <common/PointT.hpp>\n#include <topology/TopoEdge.hpp>\n#include <modeling/MakeWire.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <topology/TopoWire.hpp>\n#include <topology/TopoShape.hpp>\n#include <topology/TopoFace.hpp>\n#include <modeling/MakeFace.hpp>\nAMCAX::TopoFace crashbug1() {\n    double h1 = 7., h2 = 3.;\n    AMCAX::Point2 p1(0., h1 / 2.0), p2(30., h2 / 2.0), p3(30., -h2 / 2.0), p4(0., -h1 / 2.0);\n    std::vector<AMCAX::Point2> v_p;\n    v_p.push_back(p1);\n    v_p.push_back(p2);\n    v_p.push_back(p3);\n    v_p.push_back(p4);\n    AMCAX::TopoEdge e;\n    std::list<AMCAX::TopoShape> edges_polygon;\n    for (int i = 1; i < v_p.size(); i++) {\n        e = AMCAX::MakeEdge2d(v_p[i - 1], v_p[i]);\n        edges_polygon.push_back(e);\n    }\n    e = AMCAX::MakeEdge2d(v_p[3], v_p[0]);\n    edges_polygon.push_back(e);\n    AMCAX::MakeWire mkw;\n    mkw.Add(edges_polygon);\n    AMCAX::TopoWire w_poly = mkw;\n    AMCAX::TopoFace f_poly = AMCAX::MakeFace(w_poly, true);\n    return f_poly;\n}\nTEST_CASE(\"BUG1:Call MakeFace(const TopoWire& w, bool onlyPlane = false) crash \", \"[modeling][MakeFace][fixbug][P1]\") {\n    AMCAX::TopoFace topoFace = crashbug1();\n    CHECK(topoFace.IsNull() == false);\n    CHECK(topoFace.Type() == AMCAX::ShapeType::Face);\n    CHECK(topoFace.NChildren() == 1);\n}\n#include <catch.hpp>\n#include \"testHelper.h\"\n#include<iostream>\n#include <common/PointT.hpp>\n#include <topology/TopoEdge.hpp>\n#include <modeling/MakeWire.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <topology/TopoWire.hpp>\n#include <topology/TopoShape.hpp>\n#include <topology/TopoFace.hpp>\n#include <modeling/MakeFace.hpp>\nAMCAX::TopoFace crashbug1() {\n    double h1 = 7., h2 = 3.;\n    AMCAX::Point2 p1(0., h1 / 2.0), p2(30., h2 / 2.0), p3(30., -h2 / 2.0), p4(0., -h1 / 2.0);\n    std::vector<AMCAX::Point2> v_p;\n    v_p.push_back(p1);\n    v_p.push_back(p2);\n    v_p.push_back(p3);\n    v_p.push_back(p4);\n    AMCAX::TopoEdge e;\n    std::list<AMCAX::TopoShape> edges_polygon;\n    for (int i = 1; i < v_p.size(); i++) {\n        e = AMCAX::MakeEdge2d(v_p[i - 1], v_p[i]);\n        edges_polygon.push_back(e);\n    }\n    e = AMCAX::MakeEdge2d(v_p[3], v_p[0]);\n    edges_polygon.push_back(e);\n    AMCAX::MakeWire mkw;\n    mkw.Add(edges_polygon);\n    AMCAX::TopoWire w_poly = mkw;\n    AMCAX::TopoFace f_poly = AMCAX::MakeFace(w_poly, true);\n    return f_poly;\n}\nTEST_CASE(\"BUG1:Call MakeFace(const TopoWire& w, bool onlyPlane = false) crash \", \"[modeling][MakeFace][fixbug][P1]\") {\n    AMCAX::TopoFace topoFace = crashbug1();\n    CHECK(topoFace.IsNull() == false);\n    CHECK(topoFace.Type() == AMCAX::ShapeType::Face);\n    CHECK(topoFace.NChildren() == 1);\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API MakeFace(const Torus& t, const TopoWire& w, bool inside = true)\t @param inside Whether the face is inside the wire\n\t @param w The wire\n\t @param t The torus\n\t @brief Construct from a torus and a wire\n,\n",
      "output": "#include <catch.hpp>\n#include \"testHelper.h\"\n#include<iostream>\n#include <common/PointT.hpp>\n#include <topology/TopoEdge.hpp>\n#include <modeling/MakeWire.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <topology/TopoWire.hpp>\n#include <topology/TopoShape.hpp>\n#include <topology/TopoFace.hpp>\n#include <modeling/MakeFace.hpp>\nAMCAX::TopoFace crashbug1() {\n    double h1 = 7., h2 = 3.;\n    AMCAX::Point2 p1(0., h1 / 2.0), p2(30., h2 / 2.0), p3(30., -h2 / 2.0), p4(0., -h1 / 2.0);\n    std::vector<AMCAX::Point2> v_p;\n    v_p.push_back(p1);\n    v_p.push_back(p2);\n    v_p.push_back(p3);\n    v_p.push_back(p4);\n    AMCAX::TopoEdge e;\n    std::list<AMCAX::TopoShape> edges_polygon;\n    for (int i = 1; i < v_p.size(); i++) {\n        e = AMCAX::MakeEdge2d(v_p[i - 1], v_p[i]);\n        edges_polygon.push_back(e);\n    }\n    e = AMCAX::MakeEdge2d(v_p[3], v_p[0]);\n    edges_polygon.push_back(e);\n    AMCAX::MakeWire mkw;\n    mkw.Add(edges_polygon);\n    AMCAX::TopoWire w_poly = mkw;\n    AMCAX::TopoFace f_poly = AMCAX::MakeFace(w_poly, true);\n    return f_poly;\n}\nTEST_CASE(\"BUG1:Call MakeFace(const TopoWire& w, bool onlyPlane = false) crash \", \"[modeling][MakeFace][fixbug][P1]\") {\n    AMCAX::TopoFace topoFace = crashbug1();\n    CHECK(topoFace.IsNull() == false);\n    CHECK(topoFace.Type() == AMCAX::ShapeType::Face);\n    CHECK(topoFace.NChildren() == 1);\n}\n#include <catch.hpp>\n#include \"testHelper.h\"\n#include<iostream>\n#include <common/PointT.hpp>\n#include <topology/TopoEdge.hpp>\n#include <modeling/MakeWire.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <topology/TopoWire.hpp>\n#include <topology/TopoShape.hpp>\n#include <topology/TopoFace.hpp>\n#include <modeling/MakeFace.hpp>\nAMCAX::TopoFace crashbug1() {\n    double h1 = 7., h2 = 3.;\n    AMCAX::Point2 p1(0., h1 / 2.0), p2(30., h2 / 2.0), p3(30., -h2 / 2.0), p4(0., -h1 / 2.0);\n    std::vector<AMCAX::Point2> v_p;\n    v_p.push_back(p1);\n    v_p.push_back(p2);\n    v_p.push_back(p3);\n    v_p.push_back(p4);\n    AMCAX::TopoEdge e;\n    std::list<AMCAX::TopoShape> edges_polygon;\n    for (int i = 1; i < v_p.size(); i++) {\n        e = AMCAX::MakeEdge2d(v_p[i - 1], v_p[i]);\n        edges_polygon.push_back(e);\n    }\n    e = AMCAX::MakeEdge2d(v_p[3], v_p[0]);\n    edges_polygon.push_back(e);\n    AMCAX::MakeWire mkw;\n    mkw.Add(edges_polygon);\n    AMCAX::TopoWire w_poly = mkw;\n    AMCAX::TopoFace f_poly = AMCAX::MakeFace(w_poly, true);\n    return f_poly;\n}\nTEST_CASE(\"BUG1:Call MakeFace(const TopoWire& w, bool onlyPlane = false) crash \", \"[modeling][MakeFace][fixbug][P1]\") {\n    AMCAX::TopoFace topoFace = crashbug1();\n    CHECK(topoFace.IsNull() == false);\n    CHECK(topoFace.Type() == AMCAX::ShapeType::Face);\n    CHECK(topoFace.NChildren() == 1);\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API MakeFace(const Cone& c, const TopoWire& w, bool inside = true)\t @param inside Whether the face is inside the wire\n\t @param w The wire\n\t @param c The cone\n\t @brief Construct from a cone and a wire\n,\n",
      "output": "#include <catch.hpp>\n#include \"testHelper.h\"\n#include<iostream>\n#include <common/PointT.hpp>\n#include <topology/TopoEdge.hpp>\n#include <modeling/MakeWire.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <topology/TopoWire.hpp>\n#include <topology/TopoShape.hpp>\n#include <topology/TopoFace.hpp>\n#include <modeling/MakeFace.hpp>\nAMCAX::TopoFace crashbug1() {\n    double h1 = 7., h2 = 3.;\n    AMCAX::Point2 p1(0., h1 / 2.0), p2(30., h2 / 2.0), p3(30., -h2 / 2.0), p4(0., -h1 / 2.0);\n    std::vector<AMCAX::Point2> v_p;\n    v_p.push_back(p1);\n    v_p.push_back(p2);\n    v_p.push_back(p3);\n    v_p.push_back(p4);\n    AMCAX::TopoEdge e;\n    std::list<AMCAX::TopoShape> edges_polygon;\n    for (int i = 1; i < v_p.size(); i++) {\n        e = AMCAX::MakeEdge2d(v_p[i - 1], v_p[i]);\n        edges_polygon.push_back(e);\n    }\n    e = AMCAX::MakeEdge2d(v_p[3], v_p[0]);\n    edges_polygon.push_back(e);\n    AMCAX::MakeWire mkw;\n    mkw.Add(edges_polygon);\n    AMCAX::TopoWire w_poly = mkw;\n    AMCAX::TopoFace f_poly = AMCAX::MakeFace(w_poly, true);\n    return f_poly;\n}\nTEST_CASE(\"BUG1:Call MakeFace(const TopoWire& w, bool onlyPlane = false) crash \", \"[modeling][MakeFace][fixbug][P1]\") {\n    AMCAX::TopoFace topoFace = crashbug1();\n    CHECK(topoFace.IsNull() == false);\n    CHECK(topoFace.Type() == AMCAX::ShapeType::Face);\n    CHECK(topoFace.NChildren() == 1);\n}\n#include <catch.hpp>\n#include \"testHelper.h\"\n#include<iostream>\n#include <common/PointT.hpp>\n#include <topology/TopoEdge.hpp>\n#include <modeling/MakeWire.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <topology/TopoWire.hpp>\n#include <topology/TopoShape.hpp>\n#include <topology/TopoFace.hpp>\n#include <modeling/MakeFace.hpp>\nAMCAX::TopoFace crashbug1() {\n    double h1 = 7., h2 = 3.;\n    AMCAX::Point2 p1(0., h1 / 2.0), p2(30., h2 / 2.0), p3(30., -h2 / 2.0), p4(0., -h1 / 2.0);\n    std::vector<AMCAX::Point2> v_p;\n    v_p.push_back(p1);\n    v_p.push_back(p2);\n    v_p.push_back(p3);\n    v_p.push_back(p4);\n    AMCAX::TopoEdge e;\n    std::list<AMCAX::TopoShape> edges_polygon;\n    for (int i = 1; i < v_p.size(); i++) {\n        e = AMCAX::MakeEdge2d(v_p[i - 1], v_p[i]);\n        edges_polygon.push_back(e);\n    }\n    e = AMCAX::MakeEdge2d(v_p[3], v_p[0]);\n    edges_polygon.push_back(e);\n    AMCAX::MakeWire mkw;\n    mkw.Add(edges_polygon);\n    AMCAX::TopoWire w_poly = mkw;\n    AMCAX::TopoFace f_poly = AMCAX::MakeFace(w_poly, true);\n    return f_poly;\n}\nTEST_CASE(\"BUG1:Call MakeFace(const TopoWire& w, bool onlyPlane = false) crash \", \"[modeling][MakeFace][fixbug][P1]\") {\n    AMCAX::TopoFace topoFace = crashbug1();\n    CHECK(topoFace.IsNull() == false);\n    CHECK(topoFace.Type() == AMCAX::ShapeType::Face);\n    CHECK(topoFace.NChildren() == 1);\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API MakeFace(const Plane& p, const TopoWire& w, bool inside = true)\t @param inside Whether the face is inside the wire\n\t @param w The wire\n\t @param p The plane\n\t @brief Construct from a plane and a wire\n,\n",
      "output": "#include <catch.hpp>\n#include \"testHelper.h\"\n#include<iostream>\n#include <common/PointT.hpp>\n#include <topology/TopoEdge.hpp>\n#include <modeling/MakeWire.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <topology/TopoWire.hpp>\n#include <topology/TopoShape.hpp>\n#include <topology/TopoFace.hpp>\n#include <modeling/MakeFace.hpp>\nAMCAX::TopoFace crashbug1() {\n    double h1 = 7., h2 = 3.;\n    AMCAX::Point2 p1(0., h1 / 2.0), p2(30., h2 / 2.0), p3(30., -h2 / 2.0), p4(0., -h1 / 2.0);\n    std::vector<AMCAX::Point2> v_p;\n    v_p.push_back(p1);\n    v_p.push_back(p2);\n    v_p.push_back(p3);\n    v_p.push_back(p4);\n    AMCAX::TopoEdge e;\n    std::list<AMCAX::TopoShape> edges_polygon;\n    for (int i = 1; i < v_p.size(); i++) {\n        e = AMCAX::MakeEdge2d(v_p[i - 1], v_p[i]);\n        edges_polygon.push_back(e);\n    }\n    e = AMCAX::MakeEdge2d(v_p[3], v_p[0]);\n    edges_polygon.push_back(e);\n    AMCAX::MakeWire mkw;\n    mkw.Add(edges_polygon);\n    AMCAX::TopoWire w_poly = mkw;\n    AMCAX::TopoFace f_poly = AMCAX::MakeFace(w_poly, true);\n    return f_poly;\n}\nTEST_CASE(\"BUG1:Call MakeFace(const TopoWire& w, bool onlyPlane = false) crash \", \"[modeling][MakeFace][fixbug][P1]\") {\n    AMCAX::TopoFace topoFace = crashbug1();\n    CHECK(topoFace.IsNull() == false);\n    CHECK(topoFace.Type() == AMCAX::ShapeType::Face);\n    CHECK(topoFace.NChildren() == 1);\n}\n#include <catch.hpp>\n#include \"testHelper.h\"\n#include<iostream>\n#include <common/PointT.hpp>\n#include <topology/TopoEdge.hpp>\n#include <modeling/MakeWire.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <topology/TopoWire.hpp>\n#include <topology/TopoShape.hpp>\n#include <topology/TopoFace.hpp>\n#include <modeling/MakeFace.hpp>\nAMCAX::TopoFace crashbug1() {\n    double h1 = 7., h2 = 3.;\n    AMCAX::Point2 p1(0., h1 / 2.0), p2(30., h2 / 2.0), p3(30., -h2 / 2.0), p4(0., -h1 / 2.0);\n    std::vector<AMCAX::Point2> v_p;\n    v_p.push_back(p1);\n    v_p.push_back(p2);\n    v_p.push_back(p3);\n    v_p.push_back(p4);\n    AMCAX::TopoEdge e;\n    std::list<AMCAX::TopoShape> edges_polygon;\n    for (int i = 1; i < v_p.size(); i++) {\n        e = AMCAX::MakeEdge2d(v_p[i - 1], v_p[i]);\n        edges_polygon.push_back(e);\n    }\n    e = AMCAX::MakeEdge2d(v_p[3], v_p[0]);\n    edges_polygon.push_back(e);\n    AMCAX::MakeWire mkw;\n    mkw.Add(edges_polygon);\n    AMCAX::TopoWire w_poly = mkw;\n    AMCAX::TopoFace f_poly = AMCAX::MakeFace(w_poly, true);\n    return f_poly;\n}\nTEST_CASE(\"BUG1:Call MakeFace(const TopoWire& w, bool onlyPlane = false) crash \", \"[modeling][MakeFace][fixbug][P1]\") {\n    AMCAX::TopoFace topoFace = crashbug1();\n    CHECK(topoFace.IsNull() == false);\n    CHECK(topoFace.Type() == AMCAX::ShapeType::Face);\n    CHECK(topoFace.NChildren() == 1);\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API explicit MakeFace(const TopoWire& w, bool onlyPlane = false)\t @param onlyPlane If true, the surface will be a plane\n\t @param w The wire\n\t @brief Construct from a wire\n,\n",
      "output": "#include <catch.hpp>\n#include \"testHelper.h\"\n#include<iostream>\n#include <common/PointT.hpp>\n#include <topology/TopoEdge.hpp>\n#include <modeling/MakeWire.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <topology/TopoWire.hpp>\n#include <topology/TopoShape.hpp>\n#include <topology/TopoFace.hpp>\n#include <modeling/MakeFace.hpp>\nAMCAX::TopoFace crashbug1() {\n    double h1 = 7., h2 = 3.;\n    AMCAX::Point2 p1(0., h1 / 2.0), p2(30., h2 / 2.0), p3(30., -h2 / 2.0), p4(0., -h1 / 2.0);\n    std::vector<AMCAX::Point2> v_p;\n    v_p.push_back(p1);\n    v_p.push_back(p2);\n    v_p.push_back(p3);\n    v_p.push_back(p4);\n    AMCAX::TopoEdge e;\n    std::list<AMCAX::TopoShape> edges_polygon;\n    for (int i = 1; i < v_p.size(); i++) {\n        e = AMCAX::MakeEdge2d(v_p[i - 1], v_p[i]);\n        edges_polygon.push_back(e);\n    }\n    e = AMCAX::MakeEdge2d(v_p[3], v_p[0]);\n    edges_polygon.push_back(e);\n    AMCAX::MakeWire mkw;\n    mkw.Add(edges_polygon);\n    AMCAX::TopoWire w_poly = mkw;\n    AMCAX::TopoFace f_poly = AMCAX::MakeFace(w_poly, true);\n    return f_poly;\n}\nTEST_CASE(\"BUG1:Call MakeFace(const TopoWire& w, bool onlyPlane = false) crash \", \"[modeling][MakeFace][fixbug][P1]\") {\n    AMCAX::TopoFace topoFace = crashbug1();\n    CHECK(topoFace.IsNull() == false);\n    CHECK(topoFace.Type() == AMCAX::ShapeType::Face);\n    CHECK(topoFace.NChildren() == 1);\n}\n#include <catch.hpp>\n#include \"testHelper.h\"\n#include<iostream>\n#include <common/PointT.hpp>\n#include <topology/TopoEdge.hpp>\n#include <modeling/MakeWire.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <topology/TopoWire.hpp>\n#include <topology/TopoShape.hpp>\n#include <topology/TopoFace.hpp>\n#include <modeling/MakeFace.hpp>\nAMCAX::TopoFace crashbug1() {\n    double h1 = 7., h2 = 3.;\n    AMCAX::Point2 p1(0., h1 / 2.0), p2(30., h2 / 2.0), p3(30., -h2 / 2.0), p4(0., -h1 / 2.0);\n    std::vector<AMCAX::Point2> v_p;\n    v_p.push_back(p1);\n    v_p.push_back(p2);\n    v_p.push_back(p3);\n    v_p.push_back(p4);\n    AMCAX::TopoEdge e;\n    std::list<AMCAX::TopoShape> edges_polygon;\n    for (int i = 1; i < v_p.size(); i++) {\n        e = AMCAX::MakeEdge2d(v_p[i - 1], v_p[i]);\n        edges_polygon.push_back(e);\n    }\n    e = AMCAX::MakeEdge2d(v_p[3], v_p[0]);\n    edges_polygon.push_back(e);\n    AMCAX::MakeWire mkw;\n    mkw.Add(edges_polygon);\n    AMCAX::TopoWire w_poly = mkw;\n    AMCAX::TopoFace f_poly = AMCAX::MakeFace(w_poly, true);\n    return f_poly;\n}\nTEST_CASE(\"BUG1:Call MakeFace(const TopoWire& w, bool onlyPlane = false) crash \", \"[modeling][MakeFace][fixbug][P1]\") {\n    AMCAX::TopoFace topoFace = crashbug1();\n    CHECK(topoFace.IsNull() == false);\n    CHECK(topoFace.Type() == AMCAX::ShapeType::Face);\n    CHECK(topoFace.NChildren() == 1);\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar> [[nodiscard]] PointT Translated(const VectorT<OtherScalar, DIM>& vec),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.1\nusing namespace AMCAX;\nusing namespace std;\n#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.1\nusing namespace AMCAX;\nusing namespace std;\n;\n\tSECTION(\"Translate(vec)\") {\n        PointT<double, 3> p1(1.0, 2.0, 3.0);\n        VectorT<double, 3> v1(2.0, 3.0, 4.0);\n        PointT<double, 3> p2(3.0, 5.0, 7.0);\n        CHECK(p1.Translated(v1).IsEqual(p2, tol));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, typename OtherScalar2> PointT& Translate(const PointT<OtherScalar, DIM>& p1, const PointT<OtherScalar2, DIM>& p2),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.1\nusing namespace AMCAX;\nusing namespace std;\n#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.1\nusing namespace AMCAX;\nusing namespace std;\n;\n\tSECTION(\"Translate(p1, p2)\") {\n        PointT<double, 3> p1(1.0, 2.0, 3.0);\n        PointT<double, 3> p2(2.0, 3.0, 4.0);\n        PointT<double, 3> p3(4.0, 2.0, 3.0);\n        PointT<double, 3> p4(3.0, 1.0, 2.0);\n        CHECK(p1.Translated(p2, p3).IsEqual(p4, tol));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar> PointT& Translate(const VectorT<OtherScalar, DIM>& vec),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.1\nusing namespace AMCAX;\nusing namespace std;\n#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.1\nusing namespace AMCAX;\nusing namespace std;\n;\n\tSECTION(\"Translate(vec)\") {\n        PointT<double, 3> p1(1.0, 2.0, 3.0);\n        VectorT<double, 3> v1(2.0, 3.0, 4.0);\n        PointT<double, 3> p2(3.0, 5.0, 7.0);\n        CHECK(p1.Translated(v1).IsEqual(p2, tol));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, int DIM2 = DIM, std::enable_if_t<DIM2 == 3, int> = 0> [[nodiscard]] PointT Mirrored(const FrameT<OtherScalar, DIM>& frame),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.1\nusing namespace AMCAX;\nusing namespace std;\n#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.1\nusing namespace AMCAX;\nusing namespace std;\n;\n\tSECTION(\"Mirror(point) 3D\") {\n        PointT<double, 3> p1(1.0, 2.0, 3.0);\n        PointT<double, 3> p2(2.0, 4.0, 5.0);\n        PointT<double, 3> p3(3.0, 6.0, 7.0);\n        CHECK(p1.Mirrored(p2).IsEqual(p3, tol));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar> [[nodiscard]] PointT Mirrored(const AxisT<OtherScalar, DIM>& axis),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.1\nusing namespace AMCAX;\nusing namespace std;\n#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.1\nusing namespace AMCAX;\nusing namespace std;\n;\n\tSECTION(\"Mirror(point) 3D\") {\n        PointT<double, 3> p1(1.0, 2.0, 3.0);\n        PointT<double, 3> p2(2.0, 4.0, 5.0);\n        PointT<double, 3> p3(3.0, 6.0, 7.0);\n        CHECK(p1.Mirrored(p2).IsEqual(p3, tol));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar> [[nodiscard]] PointT Mirrored(const PointT<OtherScalar, DIM>& p),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.1\nusing namespace AMCAX;\nusing namespace std;\n#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.1\nusing namespace AMCAX;\nusing namespace std;\n;\n\tSECTION(\"Mirror(point) 3D\") {\n        PointT<double, 3> p1(1.0, 2.0, 3.0);\n        PointT<double, 3> p2(2.0, 4.0, 5.0);\n        PointT<double, 3> p3(3.0, 6.0, 7.0);\n        CHECK(p1.Mirrored(p2).IsEqual(p3, tol));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, int DIM2 = DIM, std::enable_if_t<DIM2 == 3, int> = 0> PointT& Mirror(const FrameT<OtherScalar, DIM>& frame),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.1\nusing namespace AMCAX;\nusing namespace std;\n#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.1\nusing namespace AMCAX;\nusing namespace std;\n;\n\tSECTION(\"Mirror(frame) 3D\") {\n        PointT<double, 3> p1(1.0, 2.0, 3.0);\n        PointT<double, 3> p2(2.0, 3.0, 4.0);\n        DirectionT<double, 3> d(7.0, 3.0, 2.0);\n        FrameT<double, 3> f(p2, d);\n        PointT<double, 3> p3(115.0 / 31.0, 98.0 / 31.0, 117.0 / 31.0);\n        CHECK(p1.Mirrored(f).IsEqual(p3, tol));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar> PointT& Mirror(const AxisT<OtherScalar, DIM>& axis),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.1\nusing namespace AMCAX;\nusing namespace std;\n#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.1\nusing namespace AMCAX;\nusing namespace std;\n;\n\tSECTION(\"Mirror(axis) 3D\") {\n        PointT<double, 3> p1(1.0, 2.0, 3.0);\n        PointT<double, 3> p2(2.0, 3.0, 4.0);\n        DirectionT<double, 3> d(7.0, 3.0, 2.0);\n        AxisT<double, 3> a(p2, d);\n        PointT<double, 3> p3(9.0 / 31.0, 88.0 / 31.0, 131.0 / 31.0);\n        CHECK(p1.Mirrored(a).IsEqual(p3, tol));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar> PointT& Mirror(const PointT<OtherScalar, DIM>& p),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.1\nusing namespace AMCAX;\nusing namespace std;\n#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.1\nusing namespace AMCAX;\nusing namespace std;\n;\n\tSECTION(\"Mirror(axis) 3D\") {\n        PointT<double, 3> p1(1.0, 2.0, 3.0);\n        PointT<double, 3> p2(2.0, 3.0, 4.0);\n        DirectionT<double, 3> d(7.0, 3.0, 2.0);\n        AxisT<double, 3> a(p2, d);\n        PointT<double, 3> p3(9.0 / 31.0, 88.0 / 31.0, 131.0 / 31.0);\n        CHECK(p1.Mirrored(a).IsEqual(p3, tol));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar> [[nodiscard]] auto SquaredDistance(const PointT<OtherScalar, DIM>& other),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.1\nusing namespace AMCAX;\nusing namespace std;\n#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.1\nusing namespace AMCAX;\nusing namespace std;\n;\n\tSECTION(\"SquaredDistance\") {\n        PointT<double, 3> p1(1.0, 2.0, 3.0);\n        PointT<double, 3> p2(1.1, 2.2, 3.3);\n        CHECK(p1.SquaredDistance(p2) == Approx(0.14));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar> [[nodiscard]] auto Distance(const PointT<OtherScalar, DIM>& other),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.1\nusing namespace AMCAX;\nusing namespace std;\n#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.1\nusing namespace AMCAX;\nusing namespace std;\n;\n\tSECTION(\"Distance\") {\n        PointT<double, 3> p1(1.0, 2.0, 3.0);\n        PointT<double, 3> p2(1.4, 2.5, 3.6);\n        CHECK(p1.Distance(p2) == sqrt(0.77));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, typename OtherScalar2> [[nodiscard]] bool IsEqual(const PointT<OtherScalar, DIM>& other, const OtherScalar2& tol),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.1\nusing namespace AMCAX;\nusing namespace std;\n#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.1\nusing namespace AMCAX;\nusing namespace std;\n;\n\tSECTION(\"Default constructor\",\"[1]\") {\n        Point3  p1;\n        Point3  p2(0.0, 0.0, 0.0);\n        CHECK(p1.IsEqual(p2, tol));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "void SetCoord(const CoordType& v)\t @param v The coordinate\n\t @brief Set the coordinate of point\n,\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.1\nusing namespace AMCAX;\nusing namespace std;\n#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.1\nusing namespace AMCAX;\nusing namespace std;\n;\n\tSECTION(\"SetCoord(x, y, z)\") {\n        Point3 result;\n        result.SetCoord(1.0, 2.0, 3.0);\n        Point3 expected(1.0, 2.0, 3.0);\n        CHECK(result.IsEqual(expected, tol));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "explicit PointT(const CoordType& v)\t @param v The coordinate\n\t @brief Construct from a coordinate\n,\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.1\nusing namespace AMCAX;\nusing namespace std;\n#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.1\nusing namespace AMCAX;\nusing namespace std;\n;\n\tSECTION(\"Constructor\",\"[2]\") {\n        Coord3 v(1.0, 2.0, 3.0);\n        Point3 result(v);\n        Point3 expected(1.0, 2.0, 3.0);\n        CHECK(result.IsEqual(expected, tol));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar> [[nodiscard]] PointT Mirrored(const AxisT<OtherScalar, DIM>& axis),\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <iostream>\n#define tol 0.001\nusing namespace AMCAX;\nusing namespace std;\n#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <iostream>\n#define tol 0.001\nusing namespace AMCAX;\nusing namespace std;\n;\n\tSECTION(\"Mirror(point) 2D\") {\n        PointT<double, 2> p1(1.0, 2.0);\n        PointT<double, 2> p2(2.0, 4.0);\n        PointT<double, 2> p3(3.0, 6.0);\n        CHECK(p1.Mirrored(p2).IsEqual(p3, tol));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar> PointT& Mirror(const AxisT<OtherScalar, DIM>& axis),\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <iostream>\n#define tol 0.001\nusing namespace AMCAX;\nusing namespace std;\n#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <iostream>\n#define tol 0.001\nusing namespace AMCAX;\nusing namespace std;\n;\n\tSECTION(\"Mirror(axis) 2D\") {\n        PointT<double, 2> p1(1.0, 2.0);\n        PointT<double, 2> p2(2.0, 3.0);\n        DirectionT<double, 2> d(7.0, 3.0);\n        AxisT<double, 2> a(p2, d);\n        PointT<double, 2> p3(17.0 / 29.0, 86.0 / 29.0);\n        CHECK(p1.Mirrored(a).IsEqual(p3, tol));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar> PointT& Mirror(const PointT<OtherScalar, DIM>& p),\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <iostream>\n#define tol 0.001\nusing namespace AMCAX;\nusing namespace std;\n#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <iostream>\n#define tol 0.001\nusing namespace AMCAX;\nusing namespace std;\n;\n\tSECTION(\"Mirror(axis) 2D\") {\n        PointT<double, 2> p1(1.0, 2.0);\n        PointT<double, 2> p2(2.0, 3.0);\n        DirectionT<double, 2> d(7.0, 3.0);\n        AxisT<double, 2> a(p2, d);\n        PointT<double, 2> p3(17.0 / 29.0, 86.0 / 29.0);\n        CHECK(p1.Mirrored(a).IsEqual(p3, tol));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, typename OtherScalar2> [[nodiscard]] bool IsEqual(const PointT<OtherScalar, DIM>& other, const OtherScalar2& tol),\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <iostream>\n#define tol 0.001\nusing namespace AMCAX;\nusing namespace std;\n#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <iostream>\n#define tol 0.001\nusing namespace AMCAX;\nusing namespace std;\n;\n\tSECTION(\"Mirror(point) 2D\") {\n        PointT<double, 2> p1(1.0, 2.0);\n        PointT<double, 2> p2(2.0, 4.0);\n        PointT<double, 2> p3(3.0, 6.0);\n        CHECK(p1.Mirrored(p2).IsEqual(p3, tol));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar> void Transform(CoordT<OtherScalar, DIM>& coord),\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T>\nbool IsEqual(const T& result, const T& expected)\n{\n\treturn result == expected;\n}\nbool IsEqual(const double& result, const double& expected)\n{\n\treturn std::fabs(result - expected) <= 1e-6;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)\n{\n\tfor (int i = 0; i < DIM; i++)\n\t{\n\t\tif (!IsEqual(result[i], expected[i]))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int ROW, int COL>\nbool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)\n{\n\tfor (int i = 0; i < ROW; i++)\n\t{\n\t\tfor (int j = 0; j < COL; j++)\n\t\t{\n\t\t\tif (!IsEqual(result(i, j), expected(i, j)))\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)\n{\n\treturn IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());\n}\n#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T>\nbool IsEqual(const T& result, const T& expected)\n{\n\treturn result == expected;\n}\nbool IsEqual(const double& result, const double& expected)\n{\n\treturn std::fabs(result - expected) <= 1e-6;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)\n{\n\tfor (int i = 0; i < DIM; i++)\n\t{\n\t\tif (!IsEqual(result[i], expected[i]))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int ROW, int COL>\nbool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)\n{\n\tfor (int i = 0; i < ROW; i++)\n\t{\n\t\tfor (int j = 0; j < COL; j++)\n\t\t{\n\t\t\tif (!IsEqual(result(i, j), expected(i, j)))\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)\n{\n\treturn IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());\n;\n\tSECTION(\"SetMirror point 3D\") {\n\t\tTransformationT<double, 3> tr;\n\t\tPointT<double, 3> p(1.0, 2.0, 3.0);\n\t\ttr.SetMirror(p);\n\t\tCoordT<double, 3> p2(0.0, 1.0, 2.0);\n\t\ttr.Transform(p2);\n\t\tCoordT<double, 3> p3(2.0, 3.0, 4.0);\n\t\tCHECK(IsEqual(p2, p3));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] TransformationT Powered(int power)\t @return The power of transformation\n\t @param power The exponential\n\t @brief Get the power of transformation\n,\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T>\nbool IsEqual(const T& result, const T& expected)\n{\n\treturn result == expected;\n}\nbool IsEqual(const double& result, const double& expected)\n{\n\treturn std::fabs(result - expected) <= 1e-6;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)\n{\n\tfor (int i = 0; i < DIM; i++)\n\t{\n\t\tif (!IsEqual(result[i], expected[i]))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int ROW, int COL>\nbool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)\n{\n\tfor (int i = 0; i < ROW; i++)\n\t{\n\t\tfor (int j = 0; j < COL; j++)\n\t\t{\n\t\t\tif (!IsEqual(result(i, j), expected(i, j)))\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)\n{\n\treturn IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());\n}\n#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T>\nbool IsEqual(const T& result, const T& expected)\n{\n\treturn result == expected;\n}\nbool IsEqual(const double& result, const double& expected)\n{\n\treturn std::fabs(result - expected) <= 1e-6;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)\n{\n\tfor (int i = 0; i < DIM; i++)\n\t{\n\t\tif (!IsEqual(result[i], expected[i]))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int ROW, int COL>\nbool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)\n{\n\tfor (int i = 0; i < ROW; i++)\n\t{\n\t\tfor (int j = 0; j < COL; j++)\n\t\t{\n\t\t\tif (!IsEqual(result(i, j), expected(i, j)))\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)\n{\n\treturn IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());\n;\n\tSECTION(\"Power\") {\n\t\tTransformationT<double, 3> tr;\n\t\ttr.SetRotation(Axis3(Point3(1.0, 2.0, 3.0), Direction3(1.0, 1.0, 1.0)), M_PI_2);\n\t\tTransformationT<double, 3> tr2;\n\t\ttr2.SetRotation(Axis3(Point3(1.0, 2.0, 3.0), Direction3(1.0, 1.0, 1.0)), M_PI);\n\t\tCHECK(IsEqual(tr.Powered(2), tr2));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "TransformationT& Power(int power)\t @return The reference to self\n\t @param power The exponential\n\t @brief Power of transformation\n,\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T>\nbool IsEqual(const T& result, const T& expected)\n{\n\treturn result == expected;\n}\nbool IsEqual(const double& result, const double& expected)\n{\n\treturn std::fabs(result - expected) <= 1e-6;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)\n{\n\tfor (int i = 0; i < DIM; i++)\n\t{\n\t\tif (!IsEqual(result[i], expected[i]))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int ROW, int COL>\nbool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)\n{\n\tfor (int i = 0; i < ROW; i++)\n\t{\n\t\tfor (int j = 0; j < COL; j++)\n\t\t{\n\t\t\tif (!IsEqual(result(i, j), expected(i, j)))\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)\n{\n\treturn IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());\n}\n#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T>\nbool IsEqual(const T& result, const T& expected)\n{\n\treturn result == expected;\n}\nbool IsEqual(const double& result, const double& expected)\n{\n\treturn std::fabs(result - expected) <= 1e-6;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)\n{\n\tfor (int i = 0; i < DIM; i++)\n\t{\n\t\tif (!IsEqual(result[i], expected[i]))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int ROW, int COL>\nbool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)\n{\n\tfor (int i = 0; i < ROW; i++)\n\t{\n\t\tfor (int j = 0; j < COL; j++)\n\t\t{\n\t\t\tif (!IsEqual(result(i, j), expected(i, j)))\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)\n{\n\treturn IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());\n;\n\tSECTION(\"Power\") {\n\t\tTransformationT<double, 3> tr;\n\t\ttr.SetRotation(Axis3(Point3(1.0, 2.0, 3.0), Direction3(1.0, 1.0, 1.0)), M_PI_2);\n\t\tTransformationT<double, 3> tr2;\n\t\ttr2.SetRotation(Axis3(Point3(1.0, 2.0, 3.0), Direction3(1.0, 1.0, 1.0)), M_PI);\n\t\tCHECK(IsEqual(tr.Powered(2), tr2));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar> [[nodiscard]] TransformationT LeftMultiplied(const TransformationT<OtherScalar, DIM>& other),\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T>\nbool IsEqual(const T& result, const T& expected)\n{\n\treturn result == expected;\n}\nbool IsEqual(const double& result, const double& expected)\n{\n\treturn std::fabs(result - expected) <= 1e-6;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)\n{\n\tfor (int i = 0; i < DIM; i++)\n\t{\n\t\tif (!IsEqual(result[i], expected[i]))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int ROW, int COL>\nbool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)\n{\n\tfor (int i = 0; i < ROW; i++)\n\t{\n\t\tfor (int j = 0; j < COL; j++)\n\t\t{\n\t\t\tif (!IsEqual(result(i, j), expected(i, j)))\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)\n{\n\treturn IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());\n}\n#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T>\nbool IsEqual(const T& result, const T& expected)\n{\n\treturn result == expected;\n}\nbool IsEqual(const double& result, const double& expected)\n{\n\treturn std::fabs(result - expected) <= 1e-6;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)\n{\n\tfor (int i = 0; i < DIM; i++)\n\t{\n\t\tif (!IsEqual(result[i], expected[i]))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int ROW, int COL>\nbool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)\n{\n\tfor (int i = 0; i < ROW; i++)\n\t{\n\t\tfor (int j = 0; j < COL; j++)\n\t\t{\n\t\t\tif (!IsEqual(result(i, j), expected(i, j)))\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)\n{\n\treturn IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());\n;\n\tSECTION(\"LeftMultiply\") {\n\t\tTransformationT<double, 3> tr;\n\t\ttr.SetRotation(Axis3(Point3(1.0, 2.0, 3.0), Direction3(1.0, 1.0, 1.0)), M_PI_2);\n\t\tTransformationT<double, 3> tr2;\n\t\ttr2.SetRotation(Axis3(Point3(2.0, 3.0, 4.0), Direction3(1.0, 1.0, 2.0)), M_PI_2);\n\t\tCHECK(IsEqual(tr * tr2, tr2.LeftMultiplied(tr)));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar> TransformationT& LeftMultiply(const TransformationT<OtherScalar, DIM>& other),\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T>\nbool IsEqual(const T& result, const T& expected)\n{\n\treturn result == expected;\n}\nbool IsEqual(const double& result, const double& expected)\n{\n\treturn std::fabs(result - expected) <= 1e-6;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)\n{\n\tfor (int i = 0; i < DIM; i++)\n\t{\n\t\tif (!IsEqual(result[i], expected[i]))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int ROW, int COL>\nbool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)\n{\n\tfor (int i = 0; i < ROW; i++)\n\t{\n\t\tfor (int j = 0; j < COL; j++)\n\t\t{\n\t\t\tif (!IsEqual(result(i, j), expected(i, j)))\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)\n{\n\treturn IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());\n}\n#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T>\nbool IsEqual(const T& result, const T& expected)\n{\n\treturn result == expected;\n}\nbool IsEqual(const double& result, const double& expected)\n{\n\treturn std::fabs(result - expected) <= 1e-6;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)\n{\n\tfor (int i = 0; i < DIM; i++)\n\t{\n\t\tif (!IsEqual(result[i], expected[i]))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int ROW, int COL>\nbool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)\n{\n\tfor (int i = 0; i < ROW; i++)\n\t{\n\t\tfor (int j = 0; j < COL; j++)\n\t\t{\n\t\t\tif (!IsEqual(result(i, j), expected(i, j)))\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)\n{\n\treturn IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());\n;\n\tSECTION(\"LeftMultiply\") {\n\t\tTransformationT<double, 3> tr;\n\t\ttr.SetRotation(Axis3(Point3(1.0, 2.0, 3.0), Direction3(1.0, 1.0, 1.0)), M_PI_2);\n\t\tTransformationT<double, 3> tr2;\n\t\ttr2.SetRotation(Axis3(Point3(2.0, 3.0, 4.0), Direction3(1.0, 1.0, 2.0)), M_PI_2);\n\t\tCHECK(IsEqual(tr * tr2, tr2.LeftMultiplied(tr)));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "TransformationT& Invert()\t @return The reference to self\n\t @brief Invert the transformation\n,\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T>\nbool IsEqual(const T& result, const T& expected)\n{\n\treturn result == expected;\n}\nbool IsEqual(const double& result, const double& expected)\n{\n\treturn std::fabs(result - expected) <= 1e-6;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)\n{\n\tfor (int i = 0; i < DIM; i++)\n\t{\n\t\tif (!IsEqual(result[i], expected[i]))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int ROW, int COL>\nbool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)\n{\n\tfor (int i = 0; i < ROW; i++)\n\t{\n\t\tfor (int j = 0; j < COL; j++)\n\t\t{\n\t\t\tif (!IsEqual(result(i, j), expected(i, j)))\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)\n{\n\treturn IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());\n}\n#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T>\nbool IsEqual(const T& result, const T& expected)\n{\n\treturn result == expected;\n}\nbool IsEqual(const double& result, const double& expected)\n{\n\treturn std::fabs(result - expected) <= 1e-6;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)\n{\n\tfor (int i = 0; i < DIM; i++)\n\t{\n\t\tif (!IsEqual(result[i], expected[i]))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int ROW, int COL>\nbool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)\n{\n\tfor (int i = 0; i < ROW; i++)\n\t{\n\t\tfor (int j = 0; j < COL; j++)\n\t\t{\n\t\t\tif (!IsEqual(result(i, j), expected(i, j)))\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)\n{\n\treturn IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());\n;\n\tSECTION(\"Invert\") {\n\t\tTransformationT<double, 3> tr;\n\t\ttr.SetRotation(Axis3(Point3(1.0, 2.0, 3.0), Direction3(1.0, 1.0, 1.0)), M_PI_2);\n\t\ttr.Invert();\n\t\tTransformationT<double, 3> tr2;\n\t\ttr2.SetRotation(Axis3(Point3(1.0, 2.0, 3.0), Direction3(1.0, 1.0, 1.0)), -M_PI_2);\n\t\tCHECK(IsEqual(tr, tr2));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] const MatrixT<Scalar, DIM, DIM>& HVectorialPart()\t @return The homogeneous matrix\n\t @brief Get the homogeneous vectorial part of the transformation, i.e. the rotation matrix\n,\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T>\nbool IsEqual(const T& result, const T& expected)\n{\n\treturn result == expected;\n}\nbool IsEqual(const double& result, const double& expected)\n{\n\treturn std::fabs(result - expected) <= 1e-6;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)\n{\n\tfor (int i = 0; i < DIM; i++)\n\t{\n\t\tif (!IsEqual(result[i], expected[i]))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int ROW, int COL>\nbool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)\n{\n\tfor (int i = 0; i < ROW; i++)\n\t{\n\t\tfor (int j = 0; j < COL; j++)\n\t\t{\n\t\t\tif (!IsEqual(result(i, j), expected(i, j)))\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)\n{\n\treturn IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());\n}\n#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T>\nbool IsEqual(const T& result, const T& expected)\n{\n\treturn result == expected;\n}\nbool IsEqual(const double& result, const double& expected)\n{\n\treturn std::fabs(result - expected) <= 1e-6;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)\n{\n\tfor (int i = 0; i < DIM; i++)\n\t{\n\t\tif (!IsEqual(result[i], expected[i]))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int ROW, int COL>\nbool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)\n{\n\tfor (int i = 0; i < ROW; i++)\n\t{\n\t\tfor (int j = 0; j < COL; j++)\n\t\t{\n\t\t\tif (!IsEqual(result(i, j), expected(i, j)))\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)\n{\n\treturn IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());\n;\n\tSECTION(\"default constructor 3D\") {\n\t\tTransformationT<double, 3> tr;\n\t\tMatrixT<double, 3, 3> mat;\n\t\tmat.SetIdentity();\n\t\tCoordT<double, 3> c;\n\t\tdouble scale = 1.0;\n\t\tCHECK(IsEqual(tr.ScaleFactor(), scale));\n\t\tCHECK(IsEqual(tr.Type(), TransformationType::Identity));\n\t\tCHECK(IsEqual(tr.HVectorialPart(), mat));\n\t\tCHECK(IsEqual(tr.TranslationPart(), c));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, typename OtherScalar2, int DIM2 = DIM, typename = typename std::enable_if_t<DIM2 == 3>> void GetRotation(CoordT<OtherScalar, DIM>& axis, OtherScalar2& angle),\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T>\nbool IsEqual(const T& result, const T& expected)\n{\n\treturn result == expected;\n}\nbool IsEqual(const double& result, const double& expected)\n{\n\treturn std::fabs(result - expected) <= 1e-6;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)\n{\n\tfor (int i = 0; i < DIM; i++)\n\t{\n\t\tif (!IsEqual(result[i], expected[i]))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int ROW, int COL>\nbool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)\n{\n\tfor (int i = 0; i < ROW; i++)\n\t{\n\t\tfor (int j = 0; j < COL; j++)\n\t\t{\n\t\t\tif (!IsEqual(result(i, j), expected(i, j)))\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)\n{\n\treturn IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());\n}\n#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T>\nbool IsEqual(const T& result, const T& expected)\n{\n\treturn result == expected;\n}\nbool IsEqual(const double& result, const double& expected)\n{\n\treturn std::fabs(result - expected) <= 1e-6;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)\n{\n\tfor (int i = 0; i < DIM; i++)\n\t{\n\t\tif (!IsEqual(result[i], expected[i]))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int ROW, int COL>\nbool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)\n{\n\tfor (int i = 0; i < ROW; i++)\n\t{\n\t\tfor (int j = 0; j < COL; j++)\n\t\t{\n\t\t\tif (!IsEqual(result(i, j), expected(i, j)))\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)\n{\n\treturn IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());\n;\n\tSECTION(\"GetRotation\") {\n\t\tTransformationT<double, 3> tr;\n\t\ttr.SetRotation(Axis3(Point3(1.0, 2.0, 3.0), Direction3(1.0, 1.0, 1.0)), M_PI_2);\n\t\tCoordT<double, 3> axis;\n\t\tdouble angle;\n\t\ttr.GetRotation(axis, angle);\n\t\tCoordT<double, 3> axis2(1.0 / std::sqrt(3.0));\n\t\tdouble angle2 = M_PI_2;\n\t\tCHECK(IsEqual(axis, axis2));\n\t\tCHECK(IsEqual(angle, angle2));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] Scalar ScaleFactor()\t @return The scale factor\n\t @brief Get the scale factor of the transformation\n,\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T>\nbool IsEqual(const T& result, const T& expected)\n{\n\treturn result == expected;\n}\nbool IsEqual(const double& result, const double& expected)\n{\n\treturn std::fabs(result - expected) <= 1e-6;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)\n{\n\tfor (int i = 0; i < DIM; i++)\n\t{\n\t\tif (!IsEqual(result[i], expected[i]))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int ROW, int COL>\nbool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)\n{\n\tfor (int i = 0; i < ROW; i++)\n\t{\n\t\tfor (int j = 0; j < COL; j++)\n\t\t{\n\t\t\tif (!IsEqual(result(i, j), expected(i, j)))\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)\n{\n\treturn IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());\n}\n#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T>\nbool IsEqual(const T& result, const T& expected)\n{\n\treturn result == expected;\n}\nbool IsEqual(const double& result, const double& expected)\n{\n\treturn std::fabs(result - expected) <= 1e-6;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)\n{\n\tfor (int i = 0; i < DIM; i++)\n\t{\n\t\tif (!IsEqual(result[i], expected[i]))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int ROW, int COL>\nbool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)\n{\n\tfor (int i = 0; i < ROW; i++)\n\t{\n\t\tfor (int j = 0; j < COL; j++)\n\t\t{\n\t\t\tif (!IsEqual(result(i, j), expected(i, j)))\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)\n{\n\treturn IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());\n;\n\tSECTION(\"default constructor 3D\") {\n\t\tTransformationT<double, 3> tr;\n\t\tMatrixT<double, 3, 3> mat;\n\t\tmat.SetIdentity();\n\t\tCoordT<double, 3> c;\n\t\tdouble scale = 1.0;\n\t\tCHECK(IsEqual(tr.ScaleFactor(), scale));\n\t\tCHECK(IsEqual(tr.Type(), TransformationType::Identity));\n\t\tCHECK(IsEqual(tr.HVectorialPart(), mat));\n\t\tCHECK(IsEqual(tr.TranslationPart(), c));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "void SetType(const TransformationType& t)\t @param t The new type of transformation\n\t @brief Set the type of transformation\n,\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T>\nbool IsEqual(const T& result, const T& expected)\n{\n\treturn result == expected;\n}\nbool IsEqual(const double& result, const double& expected)\n{\n\treturn std::fabs(result - expected) <= 1e-6;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)\n{\n\tfor (int i = 0; i < DIM; i++)\n\t{\n\t\tif (!IsEqual(result[i], expected[i]))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int ROW, int COL>\nbool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)\n{\n\tfor (int i = 0; i < ROW; i++)\n\t{\n\t\tfor (int j = 0; j < COL; j++)\n\t\t{\n\t\t\tif (!IsEqual(result(i, j), expected(i, j)))\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)\n{\n\treturn IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());\n}\n#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T>\nbool IsEqual(const T& result, const T& expected)\n{\n\treturn result == expected;\n}\nbool IsEqual(const double& result, const double& expected)\n{\n\treturn std::fabs(result - expected) <= 1e-6;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)\n{\n\tfor (int i = 0; i < DIM; i++)\n\t{\n\t\tif (!IsEqual(result[i], expected[i]))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int ROW, int COL>\nbool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)\n{\n\tfor (int i = 0; i < ROW; i++)\n\t{\n\t\tfor (int j = 0; j < COL; j++)\n\t\t{\n\t\t\tif (!IsEqual(result(i, j), expected(i, j)))\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)\n{\n\treturn IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());\n;\n\tSECTION(\"SetValues 3D\") {\n\t\tTransformationT<double, 3> tr;\n\t\tdouble a = 1.0 / 3.0;\n\t\tdouble b = 1.0 / 3.0 - 1.0 / std::sqrt(3.0);\n\t\tdouble c = 1.0 / 3.0 + 1.0 / std::sqrt(3.0);\n\t\ttr.SetValues(a, b, c, -1.0 - 1.0 / std::sqrt(3.0), c, a, b, 2.0 / std::sqrt(3.0), b, c, a, 1.0 - 1.0 / std::sqrt(3.0));\n\t\ttr.SetType(TransformationType::Rotation);\n\t\tTransformationT<double, 3> tr2;\n\t\ttr2.SetRotation(Axis3(Point3(1.0, 2.0, 3.0), Direction3(1.0, 1.0, 1.0)), M_PI_2);\n\t\tCHECK(IsEqual(tr, tr2));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar> void SetTranslationPart(const VectorT<OtherScalar, DIM>& vec),\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T>\nbool IsEqual(const T& result, const T& expected)\n{\n\treturn result == expected;\n}\nbool IsEqual(const double& result, const double& expected)\n{\n\treturn std::fabs(result - expected) <= 1e-6;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)\n{\n\tfor (int i = 0; i < DIM; i++)\n\t{\n\t\tif (!IsEqual(result[i], expected[i]))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int ROW, int COL>\nbool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)\n{\n\tfor (int i = 0; i < ROW; i++)\n\t{\n\t\tfor (int j = 0; j < COL; j++)\n\t\t{\n\t\t\tif (!IsEqual(result(i, j), expected(i, j)))\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)\n{\n\treturn IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());\n}\n#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T>\nbool IsEqual(const T& result, const T& expected)\n{\n\treturn result == expected;\n}\nbool IsEqual(const double& result, const double& expected)\n{\n\treturn std::fabs(result - expected) <= 1e-6;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)\n{\n\tfor (int i = 0; i < DIM; i++)\n\t{\n\t\tif (!IsEqual(result[i], expected[i]))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int ROW, int COL>\nbool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)\n{\n\tfor (int i = 0; i < ROW; i++)\n\t{\n\t\tfor (int j = 0; j < COL; j++)\n\t\t{\n\t\t\tif (!IsEqual(result(i, j), expected(i, j)))\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)\n{\n\treturn IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());\n;\n\tSECTION(\"SetTranslationPart 2D\") {\n\t\tTransformationT<double, 2> tr;\n\t\ttr.SetRotation(PointT<double, 2>(2.0, 3.0), M_PI_2);\n\t\ttr.SetTranslationPart(VectorT<double, 2>(1.0, 2.0));\n\t\tCoordT<double, 2> p(1.0, 2.0);\n\t\ttr.Transform(p);\n\t\tCoordT<double, 2> p2(-1.0, 3.0);\n\t\tCHECK(IsEqual(p, p2));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, typename OtherScalar2> void SetTranslation(const PointT<OtherScalar, DIM>& p1, const PointT<OtherScalar2, DIM>& p2),\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T>\nbool IsEqual(const T& result, const T& expected)\n{\n\treturn result == expected;\n}\nbool IsEqual(const double& result, const double& expected)\n{\n\treturn std::fabs(result - expected) <= 1e-6;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)\n{\n\tfor (int i = 0; i < DIM; i++)\n\t{\n\t\tif (!IsEqual(result[i], expected[i]))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int ROW, int COL>\nbool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)\n{\n\tfor (int i = 0; i < ROW; i++)\n\t{\n\t\tfor (int j = 0; j < COL; j++)\n\t\t{\n\t\t\tif (!IsEqual(result(i, j), expected(i, j)))\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)\n{\n\treturn IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());\n}\n#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T>\nbool IsEqual(const T& result, const T& expected)\n{\n\treturn result == expected;\n}\nbool IsEqual(const double& result, const double& expected)\n{\n\treturn std::fabs(result - expected) <= 1e-6;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)\n{\n\tfor (int i = 0; i < DIM; i++)\n\t{\n\t\tif (!IsEqual(result[i], expected[i]))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int ROW, int COL>\nbool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)\n{\n\tfor (int i = 0; i < ROW; i++)\n\t{\n\t\tfor (int j = 0; j < COL; j++)\n\t\t{\n\t\t\tif (!IsEqual(result(i, j), expected(i, j)))\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)\n{\n\treturn IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());\n;\n\tSECTION(\"SetTranslation point 2D\") {\n\t\tTransformationT<double, 2> tr;\n\t\ttr.SetTranslation(PointT<double, 2>(1.0, 2.0), PointT<double, 2>(3.0, 4.0));\n\t\tCoordT<double, 2> p(3.0, -1.0);\n\t\ttr.Transform(p);\n\t\tCoordT<double, 2> p2(5.0, 1.0);\n\t\tCHECK(IsEqual(p, p2));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar> void SetTranslation(const VectorT<OtherScalar, DIM>& vec),\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T>\nbool IsEqual(const T& result, const T& expected)\n{\n\treturn result == expected;\n}\nbool IsEqual(const double& result, const double& expected)\n{\n\treturn std::fabs(result - expected) <= 1e-6;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)\n{\n\tfor (int i = 0; i < DIM; i++)\n\t{\n\t\tif (!IsEqual(result[i], expected[i]))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int ROW, int COL>\nbool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)\n{\n\tfor (int i = 0; i < ROW; i++)\n\t{\n\t\tfor (int j = 0; j < COL; j++)\n\t\t{\n\t\t\tif (!IsEqual(result(i, j), expected(i, j)))\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)\n{\n\treturn IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());\n}\n#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T>\nbool IsEqual(const T& result, const T& expected)\n{\n\treturn result == expected;\n}\nbool IsEqual(const double& result, const double& expected)\n{\n\treturn std::fabs(result - expected) <= 1e-6;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)\n{\n\tfor (int i = 0; i < DIM; i++)\n\t{\n\t\tif (!IsEqual(result[i], expected[i]))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int ROW, int COL>\nbool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)\n{\n\tfor (int i = 0; i < ROW; i++)\n\t{\n\t\tfor (int j = 0; j < COL; j++)\n\t\t{\n\t\t\tif (!IsEqual(result(i, j), expected(i, j)))\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)\n{\n\treturn IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());\n;\n\tSECTION(\"SetTranslation vector 2D\") {\n\t\tTransformationT<double, 2> tr;\n\t\ttr.SetTranslation(VectorT<double, 2>(1.0, 2.0));\n\t\tCoordT<double, 2> p(1.0, 2.0);\n\t\ttr.Transform(p);\n\t\tCoordT<double, 2> p2(2.0, 4.0);\n\t\tCHECK(IsEqual(p, p2));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, int DIM2 = DIM, typename = typename std::enable_if_t<DIM2 == 3>> void SetTransformation(const FrameT<OtherScalar, DIM>& frameTo),\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T>\nbool IsEqual(const T& result, const T& expected)\n{\n\treturn result == expected;\n}\nbool IsEqual(const double& result, const double& expected)\n{\n\treturn std::fabs(result - expected) <= 1e-6;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)\n{\n\tfor (int i = 0; i < DIM; i++)\n\t{\n\t\tif (!IsEqual(result[i], expected[i]))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int ROW, int COL>\nbool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)\n{\n\tfor (int i = 0; i < ROW; i++)\n\t{\n\t\tfor (int j = 0; j < COL; j++)\n\t\t{\n\t\t\tif (!IsEqual(result(i, j), expected(i, j)))\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)\n{\n\treturn IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());\n}\n#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T>\nbool IsEqual(const T& result, const T& expected)\n{\n\treturn result == expected;\n}\nbool IsEqual(const double& result, const double& expected)\n{\n\treturn std::fabs(result - expected) <= 1e-6;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)\n{\n\tfor (int i = 0; i < DIM; i++)\n\t{\n\t\tif (!IsEqual(result[i], expected[i]))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int ROW, int COL>\nbool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)\n{\n\tfor (int i = 0; i < ROW; i++)\n\t{\n\t\tfor (int j = 0; j < COL; j++)\n\t\t{\n\t\t\tif (!IsEqual(result(i, j), expected(i, j)))\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)\n{\n\treturn IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());\n;\n\tSECTION(\"SetTransformation 3D\") {\t\n\t\tFrameT<double, 3> f1(PointT<double, 3>(1.0, 2.0, 3.0), DirectionT<double, 3>(4.0, 5.0, 6.0), DirectionT<double, 3>(-3.0, -5.0, 1.0));\n\t\tFrameT<double, 3> f2(PointT<double, 3>(3.0, 1.0, -1.0), DirectionT<double, 3>(1.0, 5.0, -3.0), DirectionT<double, 3>(2.0, -2.0, 2.0));\n\t\tTransformationT<double, 3> tr;\n\t\ttr.SetTransformation(f1, f2);\n\t\tCoordT<double, 3> p(4.0, 1.0, 3.0);\n\t\ttr.Transform(p);\n\t\tCoordT<double, 3> p2(54.0 / std::sqrt(770.0) - 232.0 / (34.0 * std::sqrt(1155.0)) + 100.0 / (34.0 * std::sqrt(15.0)) - 2.0 / std::sqrt(10.0),\n\t\t\t-72.0 / (7.0 * std::sqrt(22.0)) - 1744.0 / (238.0 * std::sqrt(33.0)) + 94.0 / (34.0 * std::sqrt(21.0)) - 16.0 / std::sqrt(14.0),\n\t\t\t33.0 / (7.0 * std::sqrt(55.0)) - 8184.0 / (119.0 * std::sqrt(330.0)) - 60.0 / (17.0 * std::sqrt(210.0)) - 9.0 / std::sqrt(35.0));\n\t\tCHECK(IsEqual(p, p2));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, int DIM2 = DIM, typename = typename std::enable_if_t<DIM2 == 2>> void SetTransformation(const AxisT<OtherScalar, DIM>& axisTo),\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T>\nbool IsEqual(const T& result, const T& expected)\n{\n\treturn result == expected;\n}\nbool IsEqual(const double& result, const double& expected)\n{\n\treturn std::fabs(result - expected) <= 1e-6;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)\n{\n\tfor (int i = 0; i < DIM; i++)\n\t{\n\t\tif (!IsEqual(result[i], expected[i]))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int ROW, int COL>\nbool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)\n{\n\tfor (int i = 0; i < ROW; i++)\n\t{\n\t\tfor (int j = 0; j < COL; j++)\n\t\t{\n\t\t\tif (!IsEqual(result(i, j), expected(i, j)))\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)\n{\n\treturn IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());\n}\n#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T>\nbool IsEqual(const T& result, const T& expected)\n{\n\treturn result == expected;\n}\nbool IsEqual(const double& result, const double& expected)\n{\n\treturn std::fabs(result - expected) <= 1e-6;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)\n{\n\tfor (int i = 0; i < DIM; i++)\n\t{\n\t\tif (!IsEqual(result[i], expected[i]))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int ROW, int COL>\nbool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)\n{\n\tfor (int i = 0; i < ROW; i++)\n\t{\n\t\tfor (int j = 0; j < COL; j++)\n\t\t{\n\t\t\tif (!IsEqual(result(i, j), expected(i, j)))\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)\n{\n\treturn IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());\n;\n\tSECTION(\"SetTransformation 3D\") {\n\t\tFrameT<double, 3> f1(PointT<double, 3>(1.0, 2.0, 3.0), DirectionT<double, 3>(4.0, 5.0, 6.0), DirectionT<double, 3>(-3.0, -5.0, 1.0));\n\t\tTransformationT<double, 3> tr;\n\t\ttr.SetTransformation(f1);\n\t\tCoordT<double, 3> p(4.0, 1.0, 3.0);\n\t\ttr.Transform(p);\n\t\tCoordT<double, 3> p2(-91.0 / (17.0 * std::sqrt(462.0)), 127.0 / (17.0 * std::sqrt(6.0)), 7.0 / std::sqrt(77.0));\n\t\tCHECK(IsEqual(p, p2));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, typename OtherScalar2, int DIM2 = DIM, typename = typename std::enable_if_t<DIM2 == 3>> void SetTransformation(const FrameT<OtherScalar, DIM>& frameFrom, const FrameT<OtherScalar2, DIM>& frameTo),\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T>\nbool IsEqual(const T& result, const T& expected)\n{\n\treturn result == expected;\n}\nbool IsEqual(const double& result, const double& expected)\n{\n\treturn std::fabs(result - expected) <= 1e-6;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)\n{\n\tfor (int i = 0; i < DIM; i++)\n\t{\n\t\tif (!IsEqual(result[i], expected[i]))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int ROW, int COL>\nbool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)\n{\n\tfor (int i = 0; i < ROW; i++)\n\t{\n\t\tfor (int j = 0; j < COL; j++)\n\t\t{\n\t\t\tif (!IsEqual(result(i, j), expected(i, j)))\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)\n{\n\treturn IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());\n}\n#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T>\nbool IsEqual(const T& result, const T& expected)\n{\n\treturn result == expected;\n}\nbool IsEqual(const double& result, const double& expected)\n{\n\treturn std::fabs(result - expected) <= 1e-6;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)\n{\n\tfor (int i = 0; i < DIM; i++)\n\t{\n\t\tif (!IsEqual(result[i], expected[i]))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int ROW, int COL>\nbool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)\n{\n\tfor (int i = 0; i < ROW; i++)\n\t{\n\t\tfor (int j = 0; j < COL; j++)\n\t\t{\n\t\t\tif (!IsEqual(result(i, j), expected(i, j)))\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)\n{\n\treturn IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());\n;\n\tSECTION(\"SetTransformation 3D\") {\t\n\t\tFrameT<double, 3> f1(PointT<double, 3>(1.0, 2.0, 3.0), DirectionT<double, 3>(4.0, 5.0, 6.0), DirectionT<double, 3>(-3.0, -5.0, 1.0));\n\t\tFrameT<double, 3> f2(PointT<double, 3>(3.0, 1.0, -1.0), DirectionT<double, 3>(1.0, 5.0, -3.0), DirectionT<double, 3>(2.0, -2.0, 2.0));\n\t\tTransformationT<double, 3> tr;\n\t\ttr.SetTransformation(f1, f2);\n\t\tCoordT<double, 3> p(4.0, 1.0, 3.0);\n\t\ttr.Transform(p);\n\t\tCoordT<double, 3> p2(54.0 / std::sqrt(770.0) - 232.0 / (34.0 * std::sqrt(1155.0)) + 100.0 / (34.0 * std::sqrt(15.0)) - 2.0 / std::sqrt(10.0),\n\t\t\t-72.0 / (7.0 * std::sqrt(22.0)) - 1744.0 / (238.0 * std::sqrt(33.0)) + 94.0 / (34.0 * std::sqrt(21.0)) - 16.0 / std::sqrt(14.0),\n\t\t\t33.0 / (7.0 * std::sqrt(55.0)) - 8184.0 / (119.0 * std::sqrt(330.0)) - 60.0 / (17.0 * std::sqrt(210.0)) - 9.0 / std::sqrt(35.0));\n\t\tCHECK(IsEqual(p, p2));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, typename OtherScalar2, int DIM2 = DIM, typename = typename std::enable_if_t<DIM2 == 3>> void SetDisplacement(const FrameT<OtherScalar, DIM>& frameFrom, const FrameT<OtherScalar2, DIM>& frameTo),\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T>\nbool IsEqual(const T& result, const T& expected)\n{\n\treturn result == expected;\n}\nbool IsEqual(const double& result, const double& expected)\n{\n\treturn std::fabs(result - expected) <= 1e-6;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)\n{\n\tfor (int i = 0; i < DIM; i++)\n\t{\n\t\tif (!IsEqual(result[i], expected[i]))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int ROW, int COL>\nbool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)\n{\n\tfor (int i = 0; i < ROW; i++)\n\t{\n\t\tfor (int j = 0; j < COL; j++)\n\t\t{\n\t\t\tif (!IsEqual(result(i, j), expected(i, j)))\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)\n{\n\treturn IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());\n}\n#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T>\nbool IsEqual(const T& result, const T& expected)\n{\n\treturn result == expected;\n}\nbool IsEqual(const double& result, const double& expected)\n{\n\treturn std::fabs(result - expected) <= 1e-6;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)\n{\n\tfor (int i = 0; i < DIM; i++)\n\t{\n\t\tif (!IsEqual(result[i], expected[i]))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int ROW, int COL>\nbool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)\n{\n\tfor (int i = 0; i < ROW; i++)\n\t{\n\t\tfor (int j = 0; j < COL; j++)\n\t\t{\n\t\t\tif (!IsEqual(result(i, j), expected(i, j)))\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)\n{\n\treturn IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());\n;\n\tSECTION(\"SetDisplacement\") {\n\t\tFrameT<double, 3> f1(PointT<double, 3>(1.0, 2.0, 3.0), DirectionT<double, 3>(4.0, 5.0, 6.0), DirectionT<double, 3>(-3.0, -5.0, 1.0));\n\t\tFrameT<double, 3> f2(PointT<double, 3>(3.0, 1.0, -1.0), DirectionT<double, 3>(1.0, 5.0, -3.0), DirectionT<double, 3>(2.0, -2.0, 2.0));\n\t\tTransformationT<double, 3> tr;\n\t\ttr.SetDisplacement(f1, f2);\n\t\tCoordT<double, 3> p(4.0, 1.0, 3.0);\n\t\ttr.Transform(p);\n\t\tCoordT<double, 3> p2(7.0 / (7.0 * std::sqrt(55.0)) - 273.0 / (34.0 * std::sqrt(1155.0)) + 127.0 / (34.0 * std::sqrt(21.0)) + 3.0,\n\t\t\t35.0 / (7.0 * std::sqrt(55.0)) - 254.0 / (34.0 * std::sqrt(21.0)) + 1.0,\n\t\t\t-21.0 / (7.0 * std::sqrt(55.0)) - 91.0 / (34.0 * std::sqrt(1155.0)) - 381.0 / (34.0 * std::sqrt(21.0)) - 1.0);\n\t\tCHECK(IsEqual(p, p2));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, typename OtherScalar2> void SetScale(const PointT<OtherScalar, DIM>& point, const OtherScalar2& s),\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T>\nbool IsEqual(const T& result, const T& expected)\n{\n\treturn result == expected;\n}\nbool IsEqual(const double& result, const double& expected)\n{\n\treturn std::fabs(result - expected) <= 1e-6;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)\n{\n\tfor (int i = 0; i < DIM; i++)\n\t{\n\t\tif (!IsEqual(result[i], expected[i]))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int ROW, int COL>\nbool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)\n{\n\tfor (int i = 0; i < ROW; i++)\n\t{\n\t\tfor (int j = 0; j < COL; j++)\n\t\t{\n\t\t\tif (!IsEqual(result(i, j), expected(i, j)))\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)\n{\n\treturn IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());\n}\n#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T>\nbool IsEqual(const T& result, const T& expected)\n{\n\treturn result == expected;\n}\nbool IsEqual(const double& result, const double& expected)\n{\n\treturn std::fabs(result - expected) <= 1e-6;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)\n{\n\tfor (int i = 0; i < DIM; i++)\n\t{\n\t\tif (!IsEqual(result[i], expected[i]))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int ROW, int COL>\nbool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)\n{\n\tfor (int i = 0; i < ROW; i++)\n\t{\n\t\tfor (int j = 0; j < COL; j++)\n\t\t{\n\t\t\tif (!IsEqual(result(i, j), expected(i, j)))\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)\n{\n\treturn IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());\n;\n\tSECTION(\"SetScale 3D\") {\n\t\tTransformationT<double, 3> tr;\n\t\ttr.SetScale(PointT<double, 3>(2.0, 3.0, 4.0), 1.5);\n\t\tCoordT<double, 3> p(1.0, 2.0, 3.0);\n\t\ttr.Transform(p);\n\t\tCoordT<double, 3> p2(0.5, 1.5, 2.5);\n\t\tCHECK(IsEqual(p, p2));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, int DIM2 = DIM, typename = typename std::enable_if_t<DIM2 == 3>> void SetRotationPart(const QuaternionT<OtherScalar>& q),\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T>\nbool IsEqual(const T& result, const T& expected)\n{\n\treturn result == expected;\n}\nbool IsEqual(const double& result, const double& expected)\n{\n\treturn std::fabs(result - expected) <= 1e-6;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)\n{\n\tfor (int i = 0; i < DIM; i++)\n\t{\n\t\tif (!IsEqual(result[i], expected[i]))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int ROW, int COL>\nbool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)\n{\n\tfor (int i = 0; i < ROW; i++)\n\t{\n\t\tfor (int j = 0; j < COL; j++)\n\t\t{\n\t\t\tif (!IsEqual(result(i, j), expected(i, j)))\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)\n{\n\treturn IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());\n}\n#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T>\nbool IsEqual(const T& result, const T& expected)\n{\n\treturn result == expected;\n}\nbool IsEqual(const double& result, const double& expected)\n{\n\treturn std::fabs(result - expected) <= 1e-6;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)\n{\n\tfor (int i = 0; i < DIM; i++)\n\t{\n\t\tif (!IsEqual(result[i], expected[i]))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int ROW, int COL>\nbool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)\n{\n\tfor (int i = 0; i < ROW; i++)\n\t{\n\t\tfor (int j = 0; j < COL; j++)\n\t\t{\n\t\t\tif (!IsEqual(result(i, j), expected(i, j)))\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)\n{\n\treturn IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());\n;\n\tSECTION(\"SetRotationPart quaternion\") {\n\t\tTransformationT<double, 3> tr;\n\t\ttr.SetTranslation(VectorT<double, 3>(2.0 / 3.0, 2.0 / 3.0, 4.0 / 3.0));\n\t\tQuaternionT<double> q(std::sqrt(3.0) / 6.0, std::sqrt(3.0) / 6.0, std::sqrt(3.0) / 3.0, std::sqrt(2.0) / 2.0);\n\t\ttr.SetRotationPart(q);\n\t\tCoordT<double, 3> p(-1.0, -1.0, -1.0);\n\t\ttr.Transform(p);\n\t\tCoordT<double, 3> p2(std::sqrt(6.0) / 6.0, -std::sqrt(6.0) / 6.0, 0.0);\n\t\tCHECK(IsEqual(p, p2));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, int DIM2 = DIM, typename = typename std::enable_if_t<DIM2 == 3>> void SetRotation(const QuaternionT<OtherScalar>& q),\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T>\nbool IsEqual(const T& result, const T& expected)\n{\n\treturn result == expected;\n}\nbool IsEqual(const double& result, const double& expected)\n{\n\treturn std::fabs(result - expected) <= 1e-6;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)\n{\n\tfor (int i = 0; i < DIM; i++)\n\t{\n\t\tif (!IsEqual(result[i], expected[i]))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int ROW, int COL>\nbool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)\n{\n\tfor (int i = 0; i < ROW; i++)\n\t{\n\t\tfor (int j = 0; j < COL; j++)\n\t\t{\n\t\t\tif (!IsEqual(result(i, j), expected(i, j)))\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)\n{\n\treturn IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());\n}\n#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T>\nbool IsEqual(const T& result, const T& expected)\n{\n\treturn result == expected;\n}\nbool IsEqual(const double& result, const double& expected)\n{\n\treturn std::fabs(result - expected) <= 1e-6;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)\n{\n\tfor (int i = 0; i < DIM; i++)\n\t{\n\t\tif (!IsEqual(result[i], expected[i]))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int ROW, int COL>\nbool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)\n{\n\tfor (int i = 0; i < ROW; i++)\n\t{\n\t\tfor (int j = 0; j < COL; j++)\n\t\t{\n\t\t\tif (!IsEqual(result(i, j), expected(i, j)))\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)\n{\n\treturn IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());\n;\n\tSECTION(\"SetRotation quaternion\") {\n\t\tTransformationT<double, 3> tr;\n\t\tQuaternionT<double> q(std::sqrt(3.0) / 6.0, std::sqrt(3.0) / 6.0, std::sqrt(3.0) / 3.0, std::sqrt(2.0) / 2.0);\n\t\ttr.SetRotation(q);\n\t\tCoordT<double, 3> p(-1.0, -1.0, -1.0);\n\t\ttr.Transform(p);\n\t\tCoordT<double, 3> p2((-4.0 + std::sqrt(6.0)) / 6.0, (-4.0 - std::sqrt(6.0)) / 6.0, -4.0 / 3.0);\n\t\tCHECK(IsEqual(p, p2));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, typename OtherScalar2, int DIM2 = DIM, typename = typename std::enable_if_t<DIM2 == 3>> void SetRotation(const AxisT<OtherScalar, DIM>& axis, const OtherScalar2& angle),\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T>\nbool IsEqual(const T& result, const T& expected)\n{\n\treturn result == expected;\n}\nbool IsEqual(const double& result, const double& expected)\n{\n\treturn std::fabs(result - expected) <= 1e-6;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)\n{\n\tfor (int i = 0; i < DIM; i++)\n\t{\n\t\tif (!IsEqual(result[i], expected[i]))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int ROW, int COL>\nbool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)\n{\n\tfor (int i = 0; i < ROW; i++)\n\t{\n\t\tfor (int j = 0; j < COL; j++)\n\t\t{\n\t\t\tif (!IsEqual(result(i, j), expected(i, j)))\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)\n{\n\treturn IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());\n}\n#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T>\nbool IsEqual(const T& result, const T& expected)\n{\n\treturn result == expected;\n}\nbool IsEqual(const double& result, const double& expected)\n{\n\treturn std::fabs(result - expected) <= 1e-6;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)\n{\n\tfor (int i = 0; i < DIM; i++)\n\t{\n\t\tif (!IsEqual(result[i], expected[i]))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int ROW, int COL>\nbool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)\n{\n\tfor (int i = 0; i < ROW; i++)\n\t{\n\t\tfor (int j = 0; j < COL; j++)\n\t\t{\n\t\t\tif (!IsEqual(result(i, j), expected(i, j)))\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)\n{\n\treturn IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());\n;\n\tSECTION(\"SetRotation axis\") {\n\t\tTransformationT<double, 3> tr;\n\t\tAxisT<double, 3> a(PointT<double, 3>(2.0, 3.0, 4.0), DirectionT<double, 3>(1.0, 1.0, 2.0));\n\t\ttr.SetRotation(a, M_PI_2);\n\t\tCoordT<double, 3> p(1.0, 2.0, 3.0);\n\t\ttr.Transform(p);\n\t\tCoordT<double, 3> p2((8.0 + std::sqrt(6.0)) / 6.0, (14.0 - std::sqrt(6.0)) / 6.0, 8.0 / 3.0);\n\t\tCHECK(IsEqual(p, p2));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, typename OtherScalar2, int DIM2 = DIM, typename = typename std::enable_if_t<DIM2 == 2>> void SetRotation(const PointT<OtherScalar, DIM>& point, const OtherScalar2& angle),\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T>\nbool IsEqual(const T& result, const T& expected)\n{\n\treturn result == expected;\n}\nbool IsEqual(const double& result, const double& expected)\n{\n\treturn std::fabs(result - expected) <= 1e-6;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)\n{\n\tfor (int i = 0; i < DIM; i++)\n\t{\n\t\tif (!IsEqual(result[i], expected[i]))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int ROW, int COL>\nbool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)\n{\n\tfor (int i = 0; i < ROW; i++)\n\t{\n\t\tfor (int j = 0; j < COL; j++)\n\t\t{\n\t\t\tif (!IsEqual(result(i, j), expected(i, j)))\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)\n{\n\treturn IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());\n}\n#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T>\nbool IsEqual(const T& result, const T& expected)\n{\n\treturn result == expected;\n}\nbool IsEqual(const double& result, const double& expected)\n{\n\treturn std::fabs(result - expected) <= 1e-6;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)\n{\n\tfor (int i = 0; i < DIM; i++)\n\t{\n\t\tif (!IsEqual(result[i], expected[i]))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int ROW, int COL>\nbool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)\n{\n\tfor (int i = 0; i < ROW; i++)\n\t{\n\t\tfor (int j = 0; j < COL; j++)\n\t\t{\n\t\t\tif (!IsEqual(result(i, j), expected(i, j)))\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)\n{\n\treturn IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());\n;\n\tSECTION(\"SetRotation point\") {\n\t\tTransformationT<double, 2> tr;\n\t\ttr.SetRotation(PointT<double, 2>(2.0, 3.0), M_PI_2);\n\t\tCoordT<double, 2> p(1.0, 2.0);\n\t\ttr.Transform(p);\n\t\tCoordT<double, 2> p2(3.0, 2.0);\n\t\tCHECK(IsEqual(p, p2));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, int DIM2 = DIM, std::enable_if_t<DIM2 == 3, int> = 0> void SetMirror(const FrameT<OtherScalar, DIM>& frame),\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T>\nbool IsEqual(const T& result, const T& expected)\n{\n\treturn result == expected;\n}\nbool IsEqual(const double& result, const double& expected)\n{\n\treturn std::fabs(result - expected) <= 1e-6;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)\n{\n\tfor (int i = 0; i < DIM; i++)\n\t{\n\t\tif (!IsEqual(result[i], expected[i]))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int ROW, int COL>\nbool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)\n{\n\tfor (int i = 0; i < ROW; i++)\n\t{\n\t\tfor (int j = 0; j < COL; j++)\n\t\t{\n\t\t\tif (!IsEqual(result(i, j), expected(i, j)))\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)\n{\n\treturn IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());\n}\n#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T>\nbool IsEqual(const T& result, const T& expected)\n{\n\treturn result == expected;\n}\nbool IsEqual(const double& result, const double& expected)\n{\n\treturn std::fabs(result - expected) <= 1e-6;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)\n{\n\tfor (int i = 0; i < DIM; i++)\n\t{\n\t\tif (!IsEqual(result[i], expected[i]))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int ROW, int COL>\nbool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)\n{\n\tfor (int i = 0; i < ROW; i++)\n\t{\n\t\tfor (int j = 0; j < COL; j++)\n\t\t{\n\t\t\tif (!IsEqual(result(i, j), expected(i, j)))\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)\n{\n\treturn IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());\n;\n\tSECTION(\"SetMirror point 3D\") {\n\t\tTransformationT<double, 3> tr;\n\t\tPointT<double, 3> p(1.0, 2.0, 3.0);\n\t\ttr.SetMirror(p);\n\t\tCoordT<double, 3> p2(0.0, 1.0, 2.0);\n\t\ttr.Transform(p2);\n\t\tCoordT<double, 3> p3(2.0, 3.0, 4.0);\n\t\tCHECK(IsEqual(p2, p3));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar> void SetMirror(const AxisT<OtherScalar, DIM>& axis),\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T>\nbool IsEqual(const T& result, const T& expected)\n{\n\treturn result == expected;\n}\nbool IsEqual(const double& result, const double& expected)\n{\n\treturn std::fabs(result - expected) <= 1e-6;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)\n{\n\tfor (int i = 0; i < DIM; i++)\n\t{\n\t\tif (!IsEqual(result[i], expected[i]))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int ROW, int COL>\nbool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)\n{\n\tfor (int i = 0; i < ROW; i++)\n\t{\n\t\tfor (int j = 0; j < COL; j++)\n\t\t{\n\t\t\tif (!IsEqual(result(i, j), expected(i, j)))\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)\n{\n\treturn IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());\n}\n#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T>\nbool IsEqual(const T& result, const T& expected)\n{\n\treturn result == expected;\n}\nbool IsEqual(const double& result, const double& expected)\n{\n\treturn std::fabs(result - expected) <= 1e-6;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)\n{\n\tfor (int i = 0; i < DIM; i++)\n\t{\n\t\tif (!IsEqual(result[i], expected[i]))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int ROW, int COL>\nbool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)\n{\n\tfor (int i = 0; i < ROW; i++)\n\t{\n\t\tfor (int j = 0; j < COL; j++)\n\t\t{\n\t\t\tif (!IsEqual(result(i, j), expected(i, j)))\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)\n{\n\treturn IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());\n;\n\tSECTION(\"SetMirror axis 3D\") {\n\t\tTransformationT<double, 3> tr;\n\t\tAxisT<double, 3> axis(PointT<double, 3>(2.0, 3.0, 4.0), DirectionT<double, 3>(7.0, 3.0, 2.0));\n\t\ttr.SetMirror(axis);\n\t\tCoordT<double, 3> p(1.0, 2.0, 3.0);\n\t\ttr.Transform(p);\n\t\tCoordT<double, 3> p2(9.0 / 31.0, 88.0 / 31.0, 131.0 / 31.0);\n\t\tCHECK(IsEqual(p, p2));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar> void SetMirror(const PointT<OtherScalar, DIM>& point),\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T>\nbool IsEqual(const T& result, const T& expected)\n{\n\treturn result == expected;\n}\nbool IsEqual(const double& result, const double& expected)\n{\n\treturn std::fabs(result - expected) <= 1e-6;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)\n{\n\tfor (int i = 0; i < DIM; i++)\n\t{\n\t\tif (!IsEqual(result[i], expected[i]))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int ROW, int COL>\nbool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)\n{\n\tfor (int i = 0; i < ROW; i++)\n\t{\n\t\tfor (int j = 0; j < COL; j++)\n\t\t{\n\t\t\tif (!IsEqual(result(i, j), expected(i, j)))\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)\n{\n\treturn IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());\n}\n#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T>\nbool IsEqual(const T& result, const T& expected)\n{\n\treturn result == expected;\n}\nbool IsEqual(const double& result, const double& expected)\n{\n\treturn std::fabs(result - expected) <= 1e-6;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)\n{\n\tfor (int i = 0; i < DIM; i++)\n\t{\n\t\tif (!IsEqual(result[i], expected[i]))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int ROW, int COL>\nbool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)\n{\n\tfor (int i = 0; i < ROW; i++)\n\t{\n\t\tfor (int j = 0; j < COL; j++)\n\t\t{\n\t\t\tif (!IsEqual(result(i, j), expected(i, j)))\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)\n{\n\treturn IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());\n;\n\tSECTION(\"SetMirror point 3D\") {\n\t\tTransformationT<double, 3> tr;\n\t\tPointT<double, 3> p(1.0, 2.0, 3.0);\n\t\ttr.SetMirror(p);\n\t\tCoordT<double, 3> p2(0.0, 1.0, 2.0);\n\t\ttr.Transform(p2);\n\t\tCoordT<double, 3> p3(2.0, 3.0, 4.0);\n\t\tCHECK(IsEqual(p2, p3));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, int OtherDIM> explicit TransformationT(const TransformationT<OtherScalar, OtherDIM>& trans),\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T>\nbool IsEqual(const T& result, const T& expected)\n{\n\treturn result == expected;\n}\nbool IsEqual(const double& result, const double& expected)\n{\n\treturn std::fabs(result - expected) <= 1e-6;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)\n{\n\tfor (int i = 0; i < DIM; i++)\n\t{\n\t\tif (!IsEqual(result[i], expected[i]))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int ROW, int COL>\nbool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)\n{\n\tfor (int i = 0; i < ROW; i++)\n\t{\n\t\tfor (int j = 0; j < COL; j++)\n\t\t{\n\t\t\tif (!IsEqual(result(i, j), expected(i, j)))\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)\n{\n\treturn IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());\n}\n#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T>\nbool IsEqual(const T& result, const T& expected)\n{\n\treturn result == expected;\n}\nbool IsEqual(const double& result, const double& expected)\n{\n\treturn std::fabs(result - expected) <= 1e-6;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)\n{\n\tfor (int i = 0; i < DIM; i++)\n\t{\n\t\tif (!IsEqual(result[i], expected[i]))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int ROW, int COL>\nbool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)\n{\n\tfor (int i = 0; i < ROW; i++)\n\t{\n\t\tfor (int j = 0; j < COL; j++)\n\t\t{\n\t\t\tif (!IsEqual(result(i, j), expected(i, j)))\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)\n{\n\treturn IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());\n;\n\tSECTION(\"Construct 3 dimension from 2 dimension\") {\n\t\tTransformationT<double, 2> tr;\n\t\ttr.SetValues(3.0, 2.0, 3.0, 4.0, 5.0, 6.0);\n\t\tTransformationT<double, 3> tr2(tr);\n\t\tTransformationT<double, 3> tr3;\n\t\ttr3.SetValues(3.0, 2.0, 0.0, 3.0, 4.0, 5.0, 0.0, 6.0, 0.0, 0.0, std::sqrt(7.0), 0.0);\n\t\tCHECK(IsEqual(tr2, tr3));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "constexpr TransformationT()\t @details The default transformation is the identity transformation\n\t @brief Default constructor\n,\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T>\nbool IsEqual(const T& result, const T& expected)\n{\n\treturn result == expected;\n}\nbool IsEqual(const double& result, const double& expected)\n{\n\treturn std::fabs(result - expected) <= 1e-6;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)\n{\n\tfor (int i = 0; i < DIM; i++)\n\t{\n\t\tif (!IsEqual(result[i], expected[i]))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int ROW, int COL>\nbool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)\n{\n\tfor (int i = 0; i < ROW; i++)\n\t{\n\t\tfor (int j = 0; j < COL; j++)\n\t\t{\n\t\t\tif (!IsEqual(result(i, j), expected(i, j)))\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)\n{\n\treturn IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());\n}\n#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T>\nbool IsEqual(const T& result, const T& expected)\n{\n\treturn result == expected;\n}\nbool IsEqual(const double& result, const double& expected)\n{\n\treturn std::fabs(result - expected) <= 1e-6;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)\n{\n\tfor (int i = 0; i < DIM; i++)\n\t{\n\t\tif (!IsEqual(result[i], expected[i]))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int ROW, int COL>\nbool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)\n{\n\tfor (int i = 0; i < ROW; i++)\n\t{\n\t\tfor (int j = 0; j < COL; j++)\n\t\t{\n\t\t\tif (!IsEqual(result(i, j), expected(i, j)))\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)\n{\n\treturn IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());\n;\n\tSECTION(\"default constructor 3D\") {\n\t\tTransformationT<double, 3> tr;\n\t\tMatrixT<double, 3, 3> mat;\n\t\tmat.SetIdentity();\n\t\tCoordT<double, 3> c;\n\t\tdouble scale = 1.0;\n\t\tCHECK(IsEqual(tr.ScaleFactor(), scale));\n\t\tCHECK(IsEqual(tr.Type(), TransformationType::Identity));\n\t\tCHECK(IsEqual(tr.HVectorialPart(), mat));\n\t\tCHECK(IsEqual(tr.TranslationPart(), c));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] const CoordT<Scalar, DIM>& TranslationPart()\t @return The translation part\n\t @brief Get the translation part of the transformation\n,\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T>\nbool IsEqual(const T& result, const T& expected)\n{\n\treturn result == expected;\n}\nbool IsEqual(const double& result, const double& expected)\n{\n\treturn std::fabs(result - expected) <= 1e-6;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)\n{\n\tfor (int i = 0; i < DIM; i++)\n\t{\n\t\tif (!IsEqual(result[i], expected[i]))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int ROW, int COL>\nbool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)\n{\n\tfor (int i = 0; i < ROW; i++)\n\t{\n\t\tfor (int j = 0; j < COL; j++)\n\t\t{\n\t\t\tif (!IsEqual(result(i, j), expected(i, j)))\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)\n{\n\treturn IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());\n}\n#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T>\nbool IsEqual(const T& result, const T& expected)\n{\n\treturn result == expected;\n}\nbool IsEqual(const double& result, const double& expected)\n{\n\treturn std::fabs(result - expected) <= 1e-6;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)\n{\n\tfor (int i = 0; i < DIM; i++)\n\t{\n\t\tif (!IsEqual(result[i], expected[i]))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int ROW, int COL>\nbool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)\n{\n\tfor (int i = 0; i < ROW; i++)\n\t{\n\t\tfor (int j = 0; j < COL; j++)\n\t\t{\n\t\t\tif (!IsEqual(result(i, j), expected(i, j)))\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)\n{\n\treturn IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());\n;\n\tSECTION(\"default constructor 3D\") {\n\t\tTransformationT<double, 3> tr;\n\t\tMatrixT<double, 3, 3> mat;\n\t\tmat.SetIdentity();\n\t\tCoordT<double, 3> c;\n\t\tdouble scale = 1.0;\n\t\tCHECK(IsEqual(tr.ScaleFactor(), scale));\n\t\tCHECK(IsEqual(tr.Type(), TransformationType::Identity));\n\t\tCHECK(IsEqual(tr.HVectorialPart(), mat));\n\t\tCHECK(IsEqual(tr.TranslationPart(), c));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] TransformationType Type()\t @return The transformation type\n\t @brief Get the type of the transformation\n,\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T>\nbool IsEqual(const T& result, const T& expected)\n{\n\treturn result == expected;\n}\nbool IsEqual(const double& result, const double& expected)\n{\n\treturn std::fabs(result - expected) <= 1e-6;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)\n{\n\tfor (int i = 0; i < DIM; i++)\n\t{\n\t\tif (!IsEqual(result[i], expected[i]))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int ROW, int COL>\nbool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)\n{\n\tfor (int i = 0; i < ROW; i++)\n\t{\n\t\tfor (int j = 0; j < COL; j++)\n\t\t{\n\t\t\tif (!IsEqual(result(i, j), expected(i, j)))\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)\n{\n\treturn IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());\n}\n#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T>\nbool IsEqual(const T& result, const T& expected)\n{\n\treturn result == expected;\n}\nbool IsEqual(const double& result, const double& expected)\n{\n\treturn std::fabs(result - expected) <= 1e-6;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)\n{\n\tfor (int i = 0; i < DIM; i++)\n\t{\n\t\tif (!IsEqual(result[i], expected[i]))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int ROW, int COL>\nbool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)\n{\n\tfor (int i = 0; i < ROW; i++)\n\t{\n\t\tfor (int j = 0; j < COL; j++)\n\t\t{\n\t\t\tif (!IsEqual(result(i, j), expected(i, j)))\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)\n{\n\treturn IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());\n;\n\tSECTION(\"default constructor 3D\") {\n\t\tTransformationT<double, 3> tr;\n\t\tMatrixT<double, 3, 3> mat;\n\t\tmat.SetIdentity();\n\t\tCoordT<double, 3> c;\n\t\tdouble scale = 1.0;\n\t\tCHECK(IsEqual(tr.ScaleFactor(), scale));\n\t\tCHECK(IsEqual(tr.Type(), TransformationType::Identity));\n\t\tCHECK(IsEqual(tr.HVectorialPart(), mat));\n\t\tCHECK(IsEqual(tr.TranslationPart(), c));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar> void Transform(CoordT<OtherScalar, DIM>& coord),\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T>\nstatic bool IsEqual(const T& result, const T& expected)\n{\n\treturn result == expected;\n}\nstatic bool IsEqual(const double& result, const double& expected)\n{\n\treturn std::fabs(result - expected) <= 1e-15;\n}\ntemplate<typename T, int DIM>\nstatic bool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)\n{\n\tfor (int i = 0; i < DIM; i++)\n\t{\n\t\tif (!IsEqual(result[i], expected[i]))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int ROW, int COL>\nstatic bool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)\n{\n\tfor (int i = 0; i < ROW; i++)\n\t{\n\t\tfor (int j = 0; j < COL; j++)\n\t\t{\n\t\t\tif (!IsEqual(result(i, j), expected(i, j)))\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)\n{\n\treturn IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());\n}\n#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T>\nstatic bool IsEqual(const T& result, const T& expected)\n{\n\treturn result == expected;\n}\nstatic bool IsEqual(const double& result, const double& expected)\n{\n\treturn std::fabs(result - expected) <= 1e-15;\n}\ntemplate<typename T, int DIM>\nstatic bool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)\n{\n\tfor (int i = 0; i < DIM; i++)\n\t{\n\t\tif (!IsEqual(result[i], expected[i]))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int ROW, int COL>\nstatic bool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)\n{\n\tfor (int i = 0; i < ROW; i++)\n\t{\n\t\tfor (int j = 0; j < COL; j++)\n\t\t{\n\t\t\tif (!IsEqual(result(i, j), expected(i, j)))\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)\n{\n\treturn IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());\n;\n\tSECTION(\"SetMirror axis 2D\") {\n\t\tTransformationT<double, 2> tr;\n\t\tAxisT<double, 2> axis(PointT<double, 2>(2.0, 3.0), DirectionT<double, 2>(7.0, 3.0));\n\t\ttr.SetMirror(axis);\n\t\tCoordT<double, 2> p(1.0, 2.0);\n\t\ttr.Transform(p);\n\t\tCoordT<double, 2> p2(17.0 / 29.0, 86.0 / 29.0);\n\t\tCHECK(IsEqual(p, p2));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] const MatrixT<Scalar, DIM, DIM>& HVectorialPart()\t @return The homogeneous matrix\n\t @brief Get the homogeneous vectorial part of the transformation, i.e. the rotation matrix\n,\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T>\nstatic bool IsEqual(const T& result, const T& expected)\n{\n\treturn result == expected;\n}\nstatic bool IsEqual(const double& result, const double& expected)\n{\n\treturn std::fabs(result - expected) <= 1e-15;\n}\ntemplate<typename T, int DIM>\nstatic bool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)\n{\n\tfor (int i = 0; i < DIM; i++)\n\t{\n\t\tif (!IsEqual(result[i], expected[i]))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int ROW, int COL>\nstatic bool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)\n{\n\tfor (int i = 0; i < ROW; i++)\n\t{\n\t\tfor (int j = 0; j < COL; j++)\n\t\t{\n\t\t\tif (!IsEqual(result(i, j), expected(i, j)))\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)\n{\n\treturn IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());\n}\n#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T>\nstatic bool IsEqual(const T& result, const T& expected)\n{\n\treturn result == expected;\n}\nstatic bool IsEqual(const double& result, const double& expected)\n{\n\treturn std::fabs(result - expected) <= 1e-15;\n}\ntemplate<typename T, int DIM>\nstatic bool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)\n{\n\tfor (int i = 0; i < DIM; i++)\n\t{\n\t\tif (!IsEqual(result[i], expected[i]))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int ROW, int COL>\nstatic bool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)\n{\n\tfor (int i = 0; i < ROW; i++)\n\t{\n\t\tfor (int j = 0; j < COL; j++)\n\t\t{\n\t\t\tif (!IsEqual(result(i, j), expected(i, j)))\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)\n{\n\treturn IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());\n;\n\tSECTION(\"default constructor 2D\") {\n\t\tTransformationT<double, 2> tr;\n\t\tMatrixT<double, 2, 2> mat;\n\t\tmat.SetIdentity();\n\t\tCoordT<double, 2> c;\n\t\tdouble scale = 1.0;\n\t\tCHECK(IsEqual(tr.ScaleFactor(), scale));\n\t\tCHECK(IsEqual(tr.Type(), TransformationType::Identity));\n\t\tCHECK(IsEqual(tr.HVectorialPart(), mat));\n\t\tCHECK(IsEqual(tr.TranslationPart(), c));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] Scalar ScaleFactor()\t @return The scale factor\n\t @brief Get the scale factor of the transformation\n,\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T>\nstatic bool IsEqual(const T& result, const T& expected)\n{\n\treturn result == expected;\n}\nstatic bool IsEqual(const double& result, const double& expected)\n{\n\treturn std::fabs(result - expected) <= 1e-15;\n}\ntemplate<typename T, int DIM>\nstatic bool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)\n{\n\tfor (int i = 0; i < DIM; i++)\n\t{\n\t\tif (!IsEqual(result[i], expected[i]))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int ROW, int COL>\nstatic bool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)\n{\n\tfor (int i = 0; i < ROW; i++)\n\t{\n\t\tfor (int j = 0; j < COL; j++)\n\t\t{\n\t\t\tif (!IsEqual(result(i, j), expected(i, j)))\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)\n{\n\treturn IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());\n}\n#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T>\nstatic bool IsEqual(const T& result, const T& expected)\n{\n\treturn result == expected;\n}\nstatic bool IsEqual(const double& result, const double& expected)\n{\n\treturn std::fabs(result - expected) <= 1e-15;\n}\ntemplate<typename T, int DIM>\nstatic bool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)\n{\n\tfor (int i = 0; i < DIM; i++)\n\t{\n\t\tif (!IsEqual(result[i], expected[i]))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int ROW, int COL>\nstatic bool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)\n{\n\tfor (int i = 0; i < ROW; i++)\n\t{\n\t\tfor (int j = 0; j < COL; j++)\n\t\t{\n\t\t\tif (!IsEqual(result(i, j), expected(i, j)))\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)\n{\n\treturn IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());\n;\n\tSECTION(\"default constructor 2D\") {\n\t\tTransformationT<double, 2> tr;\n\t\tMatrixT<double, 2, 2> mat;\n\t\tmat.SetIdentity();\n\t\tCoordT<double, 2> c;\n\t\tdouble scale = 1.0;\n\t\tCHECK(IsEqual(tr.ScaleFactor(), scale));\n\t\tCHECK(IsEqual(tr.Type(), TransformationType::Identity));\n\t\tCHECK(IsEqual(tr.HVectorialPart(), mat));\n\t\tCHECK(IsEqual(tr.TranslationPart(), c));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, int DIM2 = DIM, typename = typename std::enable_if_t<DIM2 == 2>> void SetTransformation(const AxisT<OtherScalar, DIM>& axisTo),\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T>\nstatic bool IsEqual(const T& result, const T& expected)\n{\n\treturn result == expected;\n}\nstatic bool IsEqual(const double& result, const double& expected)\n{\n\treturn std::fabs(result - expected) <= 1e-15;\n}\ntemplate<typename T, int DIM>\nstatic bool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)\n{\n\tfor (int i = 0; i < DIM; i++)\n\t{\n\t\tif (!IsEqual(result[i], expected[i]))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int ROW, int COL>\nstatic bool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)\n{\n\tfor (int i = 0; i < ROW; i++)\n\t{\n\t\tfor (int j = 0; j < COL; j++)\n\t\t{\n\t\t\tif (!IsEqual(result(i, j), expected(i, j)))\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)\n{\n\treturn IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());\n}\n#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T>\nstatic bool IsEqual(const T& result, const T& expected)\n{\n\treturn result == expected;\n}\nstatic bool IsEqual(const double& result, const double& expected)\n{\n\treturn std::fabs(result - expected) <= 1e-15;\n}\ntemplate<typename T, int DIM>\nstatic bool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)\n{\n\tfor (int i = 0; i < DIM; i++)\n\t{\n\t\tif (!IsEqual(result[i], expected[i]))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int ROW, int COL>\nstatic bool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)\n{\n\tfor (int i = 0; i < ROW; i++)\n\t{\n\t\tfor (int j = 0; j < COL; j++)\n\t\t{\n\t\t\tif (!IsEqual(result(i, j), expected(i, j)))\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)\n{\n\treturn IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());\n;\n\tSECTION(\"SetTransformation 2D\") {\n\t\tAxis2 a1(PointT<double, 2>(1.0, 2.0), DirectionT<double, 2>(3.0, 4.0));\n\t\tTransformationT<double, 2> tr;\n\t\ttr.SetTransformation(a1);\n\t\tCoordT<double, 2> p(4.0, 1.0);\n\t\ttr.Transform(p);\n\t\tCoordT<double, 2> p2(1.0, -3.0);\n\t\tCHECK(IsEqual(p, p2));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, typename OtherScalar2, int DIM2 = DIM, typename = typename std::enable_if_t<DIM2 == 2>> void SetTransformation(const AxisT<OtherScalar, DIM>& axisFrom, const AxisT<OtherScalar2, DIM>& axisTo),\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T>\nstatic bool IsEqual(const T& result, const T& expected)\n{\n\treturn result == expected;\n}\nstatic bool IsEqual(const double& result, const double& expected)\n{\n\treturn std::fabs(result - expected) <= 1e-15;\n}\ntemplate<typename T, int DIM>\nstatic bool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)\n{\n\tfor (int i = 0; i < DIM; i++)\n\t{\n\t\tif (!IsEqual(result[i], expected[i]))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int ROW, int COL>\nstatic bool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)\n{\n\tfor (int i = 0; i < ROW; i++)\n\t{\n\t\tfor (int j = 0; j < COL; j++)\n\t\t{\n\t\t\tif (!IsEqual(result(i, j), expected(i, j)))\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)\n{\n\treturn IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());\n}\n#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T>\nstatic bool IsEqual(const T& result, const T& expected)\n{\n\treturn result == expected;\n}\nstatic bool IsEqual(const double& result, const double& expected)\n{\n\treturn std::fabs(result - expected) <= 1e-15;\n}\ntemplate<typename T, int DIM>\nstatic bool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)\n{\n\tfor (int i = 0; i < DIM; i++)\n\t{\n\t\tif (!IsEqual(result[i], expected[i]))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int ROW, int COL>\nstatic bool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)\n{\n\tfor (int i = 0; i < ROW; i++)\n\t{\n\t\tfor (int j = 0; j < COL; j++)\n\t\t{\n\t\t\tif (!IsEqual(result(i, j), expected(i, j)))\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)\n{\n\treturn IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());\n;\n\tSECTION(\"SetTransformation 2D\") {\n\t\tAxis2 a1(PointT<double, 2>(1.0, 2.0), DirectionT<double, 2>(3.0, 4.0));\n\t\tAxis2 a2(PointT<double, 2>(3.0, 1.0), DirectionT<double, 2>(1.0, 5.0));\n\t\tTransformationT<double, 2> tr;\n\t\ttr.SetTransformation(a1, a2);\n\t\tCoordT<double, 2> p(4.0, 1.0);\n\t\ttr.Transform(p);\n\t\tCoordT<double, 2> p2(118.0 / (5.0 * std::sqrt(26.0)), 34.0 / (5.0 * std::sqrt(26.0)));\n\t\tCHECK(IsEqual(p, p2));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, typename OtherScalar2> void SetScale(const PointT<OtherScalar, DIM>& point, const OtherScalar2& s),\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T>\nstatic bool IsEqual(const T& result, const T& expected)\n{\n\treturn result == expected;\n}\nstatic bool IsEqual(const double& result, const double& expected)\n{\n\treturn std::fabs(result - expected) <= 1e-15;\n}\ntemplate<typename T, int DIM>\nstatic bool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)\n{\n\tfor (int i = 0; i < DIM; i++)\n\t{\n\t\tif (!IsEqual(result[i], expected[i]))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int ROW, int COL>\nstatic bool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)\n{\n\tfor (int i = 0; i < ROW; i++)\n\t{\n\t\tfor (int j = 0; j < COL; j++)\n\t\t{\n\t\t\tif (!IsEqual(result(i, j), expected(i, j)))\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)\n{\n\treturn IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());\n}\n#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T>\nstatic bool IsEqual(const T& result, const T& expected)\n{\n\treturn result == expected;\n}\nstatic bool IsEqual(const double& result, const double& expected)\n{\n\treturn std::fabs(result - expected) <= 1e-15;\n}\ntemplate<typename T, int DIM>\nstatic bool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)\n{\n\tfor (int i = 0; i < DIM; i++)\n\t{\n\t\tif (!IsEqual(result[i], expected[i]))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int ROW, int COL>\nstatic bool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)\n{\n\tfor (int i = 0; i < ROW; i++)\n\t{\n\t\tfor (int j = 0; j < COL; j++)\n\t\t{\n\t\t\tif (!IsEqual(result(i, j), expected(i, j)))\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)\n{\n\treturn IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());\n;\n\tSECTION(\"SetScale 2D\") {\n\t\tTransformationT<double, 2> tr;\n\t\ttr.SetScale(PointT<double, 2>(2.0, 3.0), 1.5);\n\t\tCoordT<double, 2> p(1.0, 2.0);\n\t\ttr.Transform(p);\n\t\tCoordT<double, 2> p2(0.5, 1.5);\n\t\tCHECK(IsEqual(p, p2));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar> void SetMirror(const AxisT<OtherScalar, DIM>& axis),\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T>\nstatic bool IsEqual(const T& result, const T& expected)\n{\n\treturn result == expected;\n}\nstatic bool IsEqual(const double& result, const double& expected)\n{\n\treturn std::fabs(result - expected) <= 1e-15;\n}\ntemplate<typename T, int DIM>\nstatic bool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)\n{\n\tfor (int i = 0; i < DIM; i++)\n\t{\n\t\tif (!IsEqual(result[i], expected[i]))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int ROW, int COL>\nstatic bool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)\n{\n\tfor (int i = 0; i < ROW; i++)\n\t{\n\t\tfor (int j = 0; j < COL; j++)\n\t\t{\n\t\t\tif (!IsEqual(result(i, j), expected(i, j)))\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)\n{\n\treturn IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());\n}\n#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T>\nstatic bool IsEqual(const T& result, const T& expected)\n{\n\treturn result == expected;\n}\nstatic bool IsEqual(const double& result, const double& expected)\n{\n\treturn std::fabs(result - expected) <= 1e-15;\n}\ntemplate<typename T, int DIM>\nstatic bool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)\n{\n\tfor (int i = 0; i < DIM; i++)\n\t{\n\t\tif (!IsEqual(result[i], expected[i]))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int ROW, int COL>\nstatic bool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)\n{\n\tfor (int i = 0; i < ROW; i++)\n\t{\n\t\tfor (int j = 0; j < COL; j++)\n\t\t{\n\t\t\tif (!IsEqual(result(i, j), expected(i, j)))\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)\n{\n\treturn IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());\n;\n\tSECTION(\"SetMirror axis 2D\") {\n\t\tTransformationT<double, 2> tr;\n\t\tAxisT<double, 2> axis(PointT<double, 2>(2.0, 3.0), DirectionT<double, 2>(7.0, 3.0));\n\t\ttr.SetMirror(axis);\n\t\tCoordT<double, 2> p(1.0, 2.0);\n\t\ttr.Transform(p);\n\t\tCoordT<double, 2> p2(17.0 / 29.0, 86.0 / 29.0);\n\t\tCHECK(IsEqual(p, p2));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar> void SetMirror(const PointT<OtherScalar, DIM>& point),\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T>\nstatic bool IsEqual(const T& result, const T& expected)\n{\n\treturn result == expected;\n}\nstatic bool IsEqual(const double& result, const double& expected)\n{\n\treturn std::fabs(result - expected) <= 1e-15;\n}\ntemplate<typename T, int DIM>\nstatic bool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)\n{\n\tfor (int i = 0; i < DIM; i++)\n\t{\n\t\tif (!IsEqual(result[i], expected[i]))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int ROW, int COL>\nstatic bool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)\n{\n\tfor (int i = 0; i < ROW; i++)\n\t{\n\t\tfor (int j = 0; j < COL; j++)\n\t\t{\n\t\t\tif (!IsEqual(result(i, j), expected(i, j)))\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)\n{\n\treturn IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());\n}\n#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T>\nstatic bool IsEqual(const T& result, const T& expected)\n{\n\treturn result == expected;\n}\nstatic bool IsEqual(const double& result, const double& expected)\n{\n\treturn std::fabs(result - expected) <= 1e-15;\n}\ntemplate<typename T, int DIM>\nstatic bool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)\n{\n\tfor (int i = 0; i < DIM; i++)\n\t{\n\t\tif (!IsEqual(result[i], expected[i]))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int ROW, int COL>\nstatic bool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)\n{\n\tfor (int i = 0; i < ROW; i++)\n\t{\n\t\tfor (int j = 0; j < COL; j++)\n\t\t{\n\t\t\tif (!IsEqual(result(i, j), expected(i, j)))\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)\n{\n\treturn IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());\n;\n\tSECTION(\"SetMirror axis 2D\") {\n\t\tTransformationT<double, 2> tr;\n\t\tAxisT<double, 2> axis(PointT<double, 2>(2.0, 3.0), DirectionT<double, 2>(7.0, 3.0));\n\t\ttr.SetMirror(axis);\n\t\tCoordT<double, 2> p(1.0, 2.0);\n\t\ttr.Transform(p);\n\t\tCoordT<double, 2> p2(17.0 / 29.0, 86.0 / 29.0);\n\t\tCHECK(IsEqual(p, p2));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] const CoordT<Scalar, DIM>& TranslationPart()\t @return The translation part\n\t @brief Get the translation part of the transformation\n,\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T>\nstatic bool IsEqual(const T& result, const T& expected)\n{\n\treturn result == expected;\n}\nstatic bool IsEqual(const double& result, const double& expected)\n{\n\treturn std::fabs(result - expected) <= 1e-15;\n}\ntemplate<typename T, int DIM>\nstatic bool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)\n{\n\tfor (int i = 0; i < DIM; i++)\n\t{\n\t\tif (!IsEqual(result[i], expected[i]))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int ROW, int COL>\nstatic bool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)\n{\n\tfor (int i = 0; i < ROW; i++)\n\t{\n\t\tfor (int j = 0; j < COL; j++)\n\t\t{\n\t\t\tif (!IsEqual(result(i, j), expected(i, j)))\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)\n{\n\treturn IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());\n}\n#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T>\nstatic bool IsEqual(const T& result, const T& expected)\n{\n\treturn result == expected;\n}\nstatic bool IsEqual(const double& result, const double& expected)\n{\n\treturn std::fabs(result - expected) <= 1e-15;\n}\ntemplate<typename T, int DIM>\nstatic bool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)\n{\n\tfor (int i = 0; i < DIM; i++)\n\t{\n\t\tif (!IsEqual(result[i], expected[i]))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int ROW, int COL>\nstatic bool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)\n{\n\tfor (int i = 0; i < ROW; i++)\n\t{\n\t\tfor (int j = 0; j < COL; j++)\n\t\t{\n\t\t\tif (!IsEqual(result(i, j), expected(i, j)))\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)\n{\n\treturn IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());\n;\n\tSECTION(\"default constructor 2D\") {\n\t\tTransformationT<double, 2> tr;\n\t\tMatrixT<double, 2, 2> mat;\n\t\tmat.SetIdentity();\n\t\tCoordT<double, 2> c;\n\t\tdouble scale = 1.0;\n\t\tCHECK(IsEqual(tr.ScaleFactor(), scale));\n\t\tCHECK(IsEqual(tr.Type(), TransformationType::Identity));\n\t\tCHECK(IsEqual(tr.HVectorialPart(), mat));\n\t\tCHECK(IsEqual(tr.TranslationPart(), c));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] TransformationType Type()\t @return The transformation type\n\t @brief Get the type of the transformation\n,\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T>\nstatic bool IsEqual(const T& result, const T& expected)\n{\n\treturn result == expected;\n}\nstatic bool IsEqual(const double& result, const double& expected)\n{\n\treturn std::fabs(result - expected) <= 1e-15;\n}\ntemplate<typename T, int DIM>\nstatic bool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)\n{\n\tfor (int i = 0; i < DIM; i++)\n\t{\n\t\tif (!IsEqual(result[i], expected[i]))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int ROW, int COL>\nstatic bool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)\n{\n\tfor (int i = 0; i < ROW; i++)\n\t{\n\t\tfor (int j = 0; j < COL; j++)\n\t\t{\n\t\t\tif (!IsEqual(result(i, j), expected(i, j)))\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)\n{\n\treturn IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());\n}\n#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T>\nstatic bool IsEqual(const T& result, const T& expected)\n{\n\treturn result == expected;\n}\nstatic bool IsEqual(const double& result, const double& expected)\n{\n\treturn std::fabs(result - expected) <= 1e-15;\n}\ntemplate<typename T, int DIM>\nstatic bool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)\n{\n\tfor (int i = 0; i < DIM; i++)\n\t{\n\t\tif (!IsEqual(result[i], expected[i]))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int ROW, int COL>\nstatic bool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)\n{\n\tfor (int i = 0; i < ROW; i++)\n\t{\n\t\tfor (int j = 0; j < COL; j++)\n\t\t{\n\t\t\tif (!IsEqual(result(i, j), expected(i, j)))\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)\n{\n\treturn IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());\n;\n\tSECTION(\"default constructor 2D\") {\n\t\tTransformationT<double, 2> tr;\n\t\tMatrixT<double, 2, 2> mat;\n\t\tmat.SetIdentity();\n\t\tCoordT<double, 2> c;\n\t\tdouble scale = 1.0;\n\t\tCHECK(IsEqual(tr.ScaleFactor(), scale));\n\t\tCHECK(IsEqual(tr.Type(), TransformationType::Identity));\n\t\tCHECK(IsEqual(tr.HVectorialPart(), mat));\n\t\tCHECK(IsEqual(tr.TranslationPart(), c));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar> [[nodiscard]] VectorT Scaled(const OtherScalar& scale),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\n#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\n;\n\tSECTION(\"Scale\") {\n        VectorT<double, 3> p1(1.0, 2.0, 3.0);\n        VectorT<double, 3> p3(1.5, 3.0, 4.5);\n        CHECK(p1.Scaled(1.5).IsEqual(p3, tolDis, tolAng));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, typename OtherScalar2, int DIM2 = DIM, typename = typename std::enable_if_t<DIM2 == 3>> [[nodiscard]] VectorT Rotated(const AxisT<OtherScalar, DIM>& axis, const OtherScalar2& angle),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\n#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\n;\n\tSECTION(\"Rotate 3D\") {\n        VectorT<double, 3> p1(1.0, 2.0, 3.0);\n        PointT<double, 3> p2(2.0, 3.0, 4.0);\n        DirectionT<double, 3> d(1.0, 1.0, 2.0);\n        AxisT<double, 3> a(p2, d);\n        VectorT<double, 3> p3((9.0 - std::sqrt(6.0)) / 6.0, (9.0 - std::sqrt(6.0)) / 6.0, 3.0 + 1.0 / std::sqrt(6.0));\n        CHECK(p1.Rotated(a, M_PI_2).IsEqual(p3, tolDis, tolAng));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, int DIM2 = DIM, std::enable_if_t<DIM2 == 3, int> = 0> [[nodiscard]] VectorT Mirrored(const FrameT<OtherScalar, DIM>& frame),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\n#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\n;\n\tSECTION(\"Mirror(point) 3D\") {\n        VectorT<double, 3> p1(1.0, 2.0, 3.0);\n        VectorT<double, 3> p2(2.0, 4.0, 5.0);\n        VectorT<double, 3> p3(11.0 / 9.0, 22.0 / 9.0, 23.0 / 9.0);\n        CHECK(p1.Mirrored(p2).IsEqual(p3, tolDis, tolAng));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar> [[nodiscard]] VectorT Mirrored(const AxisT<OtherScalar, DIM>& axis),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\n#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\n;\n\tSECTION(\"Mirror(point) 3D\") {\n        VectorT<double, 3> p1(1.0, 2.0, 3.0);\n        VectorT<double, 3> p2(2.0, 4.0, 5.0);\n        VectorT<double, 3> p3(11.0 / 9.0, 22.0 / 9.0, 23.0 / 9.0);\n        CHECK(p1.Mirrored(p2).IsEqual(p3, tolDis, tolAng));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar> [[nodiscard]] VectorT Mirrored(const VectorT<OtherScalar, DIM>& p),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\n#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\n;\n\tSECTION(\"Mirror(point) 3D\") {\n        VectorT<double, 3> p1(1.0, 2.0, 3.0);\n        VectorT<double, 3> p2(2.0, 4.0, 5.0);\n        VectorT<double, 3> p3(11.0 / 9.0, 22.0 / 9.0, 23.0 / 9.0);\n        CHECK(p1.Mirrored(p2).IsEqual(p3, tolDis, tolAng));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, int DIM2 = DIM, std::enable_if_t<DIM2 == 3, int> = 0> VectorT& Mirror(const FrameT<OtherScalar, DIM>& frame),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\n#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\n;\n\tSECTION(\"Mirror(axis) 3D\") {\n        VectorT<double, 3> p1(1.0, 2.0, 3.0);\n        PointT<double, 3> p2(2.0, 3.0, 4.0);\n        DirectionT<double, 3> d(7.0, 3.0, 2.0);\n        AxisT<double, 3> a(p2, d);\n        VectorT<double, 3> p3(102.0 / 31.0, -5.0 / 31.0, -55.0 / 31.0);\n        CHECK(p1.Mirrored(a).IsEqual(p3, tolDis, tolAng));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar> VectorT& Mirror(const AxisT<OtherScalar, DIM>& axis),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\n#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\n;\n\tSECTION(\"Mirror(axis) 3D\") {\n        VectorT<double, 3> p1(1.0, 2.0, 3.0);\n        PointT<double, 3> p2(2.0, 3.0, 4.0);\n        DirectionT<double, 3> d(7.0, 3.0, 2.0);\n        AxisT<double, 3> a(p2, d);\n        VectorT<double, 3> p3(102.0 / 31.0, -5.0 / 31.0, -55.0 / 31.0);\n        CHECK(p1.Mirrored(a).IsEqual(p3, tolDis, tolAng));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar> VectorT& Mirror(const VectorT<OtherScalar, DIM>& p),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\n#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\n;\n\tSECTION(\"Mirror(axis) 3D\") {\n        VectorT<double, 3> p1(1.0, 2.0, 3.0);\n        PointT<double, 3> p2(2.0, 3.0, 4.0);\n        DirectionT<double, 3> d(7.0, 3.0, 2.0);\n        AxisT<double, 3> a(p2, d);\n        VectorT<double, 3> p3(102.0 / 31.0, -5.0 / 31.0, -55.0 / 31.0);\n        CHECK(p1.Mirrored(a).IsEqual(p3, tolDis, tolAng));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "VectorT& Reverse()\t @return The reference to self\n\t @brief Reverse the vector\n,\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\n#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\n;\n\tSECTION(\"Reverse\") {\n        VectorT<double, 3> v1(1.0, 2.0, 2.0);\n        VectorT<double, 3> v2(-1.0, -2.0, -2.0);\n        CHECK(v1.IsEqual(-v2, tolDis, tolAng));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] VectorT Normalized()\t @return The normalized vector\n\t @brief Get the normalized vector\n,\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\n#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\n;\n\tSECTION(\"Normalize\") {\n        VectorT<double, 3> v1(1.0, 2.0, 2.0);\n        VectorT<double, 3> v2(1.0 / 3.0, 2.0 / 3.0, 2.0 / 3.0);\n        CHECK(v1.Normalized().IsEqual(v2, tolDis, tolAng));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "VectorT& Normalize()\t @return The reference to self\n\t @brief Normalize the vector\n,\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\n#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\n;\n\tSECTION(\"Normalize\") {\n        VectorT<double, 3> v1(1.0, 2.0, 2.0);\n        VectorT<double, 3> v2(1.0 / 3.0, 2.0 / 3.0, 2.0 / 3.0);\n        CHECK(v1.Normalized().IsEqual(v2, tolDis, tolAng));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar> [[nodiscard]] auto Cross(const VectorT<OtherScalar, DIM>& other),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\n#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\n;\n\tSECTION(\"Cross 3D\") {\n        VectorT<double, 3> v1(1.0, 2.0, 3.0);\n        VectorT<double, 3> v2(2.0, 3.0, 4.0);\n        VectorT<double, 3> v3(-1.0, 2.0, -1.0);\n        CHECK(v1.Cross(v2).IsEqual(v3, tolDis, tolAng));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] double SquaredNorm()\t @return The squared norm of vector\n\t @brief Get the squared norm of vector\n,\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\n#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\n;\n\tSECTION(\"SquaredNorm\") {\n        VectorT<double, 3> v1(1.0, 2.0, 3.0);\n        CHECK(v1.SquaredNorm() == Approx(14.0));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, typename OtherScalar2, int DIM2 = DIM, typename = typename std::enable_if_t<DIM2 == 3>> [[nodiscard]] Scalar AngleWithRef(const VectorT<OtherScalar, DIM>& other, const VectorT<OtherScalar2, DIM>& ref),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\n#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\n;\n\tSECTION(\"AngleWithRef\") {\n        VectorT<double, 3> v1(1.0, 2.0, 3.0);\n        VectorT<double, 3> v2(-3.0, 2.0, -1.0);\n        VectorT<double, 3> v3(1.0, 1.0, 1.0);\n        CHECK(v1.AngleWithRef(v2, v3) == -acos(-1.0 / 7.0));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, int DIM2 = DIM, std::enable_if_t<DIM2 == 3, int> = 0> [[nodiscard]] auto Angle(const VectorT<OtherScalar, DIM>& other),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\n#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\n;\n\tSECTION(\"Angle 3D\") {\n        VectorT<double, 3> v1(1.0, 2.0, 3.0);\n        VectorT<double, 3> v2(-3.0, 2.0, -1.0);\n        CHECK(v1.Angle(v2) == acos(-1.0 / 7.0));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, int DIM2 = DIM, std::enable_if_t<DIM2 == 2, int> = 0> [[nodiscard]] auto Angle(const VectorT<OtherScalar, DIM>& other),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\n#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\n;\n\tSECTION(\"Angle 3D\") {\n        VectorT<double, 3> v1(1.0, 2.0, 3.0);\n        VectorT<double, 3> v2(-3.0, 2.0, -1.0);\n        CHECK(v1.Angle(v2) == acos(-1.0 / 7.0));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, typename OtherScalar2> [[nodiscard]] bool IsParallel(const VectorT<OtherScalar, DIM>& other, const OtherScalar2& tol),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\n#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\n;\n\tSECTION(\"IsParallel\") {\n        VectorT<double, 3> v1(1.0, 2.0, 3.0);\n        VectorT<double, 3> v2(-1.0, -2.0, -3.01);\n        CHECK(v1.IsParallel(v2, tolDis) == false);\n        CHECK(v1.IsParallel(v2, 0.1) == true);\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, typename OtherScalar2> [[nodiscard]] bool IsOpposite(const VectorT<OtherScalar, DIM>& other, const OtherScalar2& tol),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\n#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\n;\n\tSECTION(\"IsOpposite\") {\n        VectorT<double, 3> v1(1.0, 2.0, 3.0);\n        VectorT<double, 3> v2(-1.0, -2.0, -3.01);\n        CHECK(v1.IsOpposite(v2, tolDis) == false);\n        CHECK(v1.IsOpposite(v2, 0.1) == true);\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, typename OtherScalar2> [[nodiscard]] bool IsNormal(const VectorT<OtherScalar, DIM>& other, const OtherScalar2& tol),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\n#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\n;\n\tSECTION(\"IsNormal\") {\n        VectorT<double, 3> v1(1.0, 2.0, 3.0);\n        VectorT<double, 3> v2(-4.0, -1.0, 2.01);\n        CHECK(v1.IsNormal(v2, 0.001) == false);\n        CHECK(v1.IsNormal(v2, 0.1) == true);\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, typename OtherScalar2, typename OtherScalar3> [[nodiscard]] bool IsEqual(const VectorT<OtherScalar, DIM>& other, const OtherScalar2& tolDis, const OtherScalar3& tolAng),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\n#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\n;\n\tSECTION(\"Default constructor\") {\n        VectorT<double, 3> p1;\n        VectorT<double, 3> p2(0.0, 0.0, 0.0);\n        CHECK(p1.IsEqual(p2, tolDis, tolAng));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar> void SetCoord(const CoordT<OtherScalar, DIM>& v),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\n#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\n;\n\tSECTION(\"SetCoord(v)\") {\n        VectorT<double, 3> result;\n        result.SetCoord(CoordT<double, 3>(1.0, 2.0, 3.0));\n        VectorT<double, 3> expected(1.0, 2.0, 3.0);\n        CHECK(result.IsEqual(expected, tolDis, tolAng));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename... T> void SetCoord(T... vs),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\n#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\n;\n\tSECTION(\"SetCoord(x, y, z)\") {\n        VectorT<double, 3> result;\n        result.SetCoord(1.0, 2.0, 3.0);\n        VectorT<double, 3> expected(1.0, 2.0, 3.0);\n        CHECK(result.IsEqual(expected, tolDis, tolAng));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, typename OtherScalar2> VectorT(const PointT<OtherScalar, DIM>& p1, const PointT<OtherScalar2, DIM>& p2),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\n#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\n;\n\tSECTION(\"Constructor from two points\") {\n        PointT<double, 3> p1(1.0, 2.0, 3.0);\n        PointT<double, 3> p2(2.0, 3.0, 4.0);\n        VectorT<double, 3> result(p1, p2);\n        VectorT<double, 3> expected(1.0, 1.0, 1.0);\n        CHECK(result.IsEqual(expected, tolDis, tolAng));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename... T> explicit VectorT(T... vs),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\n#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\n;\n\tSECTION(\"Default constructor\") {\n        VectorT<double, 3> p1;\n        VectorT<double, 3> p2(0.0, 0.0, 0.0);\n        CHECK(p1.IsEqual(p2, tolDis, tolAng));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar> explicit VectorT(const CoordT<OtherScalar, DIM>& v),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\n#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\n;\n\tSECTION(\"Default constructor\") {\n        VectorT<double, 3> p1;\n        VectorT<double, 3> p2(0.0, 0.0, 0.0);\n        CHECK(p1.IsEqual(p2, tolDis, tolAng));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar> explicit VectorT(const DirectionT<OtherScalar, DIM>& dir),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\n#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\n;\n\tSECTION(\"Default constructor\") {\n        VectorT<double, 3> p1;\n        VectorT<double, 3> p2(0.0, 0.0, 0.0);\n        CHECK(p1.IsEqual(p2, tolDis, tolAng));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "VectorT()\t @details The default vector is (0, 0, ..., 0)\n\t @brief The default constructor\n,\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\n#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\n;\n\tSECTION(\"Default constructor\") {\n        VectorT<double, 3> p1;\n        VectorT<double, 3> p2(0.0, 0.0, 0.0);\n        CHECK(p1.IsEqual(p2, tolDis, tolAng));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] auto Norm()\t @return The norm of vector\n\t @brief Get the norm of vector\n,\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\n#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\n;\n\tSECTION(\"Norm\") {\n        VectorT<double, 3> v1(1.0, 2.0, 3.0);\n        CHECK(v1.Norm() == sqrt(14.0));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar> [[nodiscard]] auto Dot(const VectorT<OtherScalar, DIM>& other),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\n#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\n;\n\tSECTION(\"Dot\") {\n        VectorT<double, 4> v1(1.0, 2.0, 3.0, 4.0);\n        VectorT<double, 4> v2(3.0, 4.0, 1.0, 2.0);\n        CHECK(v1.Dot(v2) == Approx(22.0));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, int DIM2 = DIM, typename = typename std::enable_if_t<DIM2 == 2>> [[nodiscard]] VectorT Rotated(const OtherScalar& angle),\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\n#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\n;\n\tSECTION(\"Rotate 2D\") {\n        VectorT<double, 2> p1(1.0, 2.0);\n        VectorT<double, 2> p3(-2.0, 1.0);\n        CHECK(p1.Rotated(M_PI_2).IsEqual(p3, tolDis, tolAng));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, int DIM2 = DIM, typename = typename std::enable_if_t<DIM2 == 2>> VectorT& Rotate(const OtherScalar& angle),\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\n#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\n;\n\tSECTION(\"Rotate 2D\") {\n        VectorT<double, 2> p1(1.0, 2.0);\n        VectorT<double, 2> p3(-2.0, 1.0);\n        CHECK(p1.Rotated(M_PI_2).IsEqual(p3, tolDis, tolAng));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar> [[nodiscard]] VectorT Mirrored(const AxisT<OtherScalar, DIM>& axis),\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\n#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\n;\n\tSECTION(\"Mirror(axis) 2D\") {\n        VectorT<double, 2> p1(1.0, 2.0);\n        PointT<double, 2> p2(2.0, 3.0);\n        DirectionT<double, 2> d(7.0, 3.0);\n        AxisT<double, 2> a(p2, d);\n        VectorT<double, 2> p3(62.0 / 29.0, -19.0 / 29.0);\n        CHECK(p1.Mirrored(a).IsEqual(p3, tolDis, tolAng));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar> [[nodiscard]] VectorT Mirrored(const VectorT<OtherScalar, DIM>& p),\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\n#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\n;\n\tSECTION(\"Mirror(axis) 2D\") {\n        VectorT<double, 2> p1(1.0, 2.0);\n        PointT<double, 2> p2(2.0, 3.0);\n        DirectionT<double, 2> d(7.0, 3.0);\n        AxisT<double, 2> a(p2, d);\n        VectorT<double, 2> p3(62.0 / 29.0, -19.0 / 29.0);\n        CHECK(p1.Mirrored(a).IsEqual(p3, tolDis, tolAng));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar> VectorT& Mirror(const AxisT<OtherScalar, DIM>& axis),\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\n#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\n;\n\tSECTION(\"Mirror(axis) 2D\") {\n        VectorT<double, 2> p1(1.0, 2.0);\n        PointT<double, 2> p2(2.0, 3.0);\n        DirectionT<double, 2> d(7.0, 3.0);\n        AxisT<double, 2> a(p2, d);\n        VectorT<double, 2> p3(62.0 / 29.0, -19.0 / 29.0);\n        CHECK(p1.Mirrored(a).IsEqual(p3, tolDis, tolAng));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar> VectorT& Mirror(const VectorT<OtherScalar, DIM>& p),\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\n#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\n;\n\tSECTION(\"Mirror(point) 2D\") {\n        VectorT<double, 2> p1(1.0, 2.0);\n        VectorT<double, 2> p2(2.0, 3.0);\n        VectorT<double, 2> p3(19.0 / 13.0, 22.0 / 13.0);\n        CHECK(p1.Mirrored(p2).IsEqual(p3, tolDis, tolAng));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar> [[nodiscard]] auto Cross(const VectorT<OtherScalar, DIM>& other),\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\n#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\n;\n\tSECTION(\"Cross 2D\") {\n        VectorT<double, 2> v1(1.0, 2.0);\n        VectorT<double, 2> v2(2.0, 3.0);\n        CHECK(v1.Cross(v2) == -1.0);\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, int DIM2 = DIM, std::enable_if_t<DIM2 == 2, int> = 0> [[nodiscard]] auto Angle(const VectorT<OtherScalar, DIM>& other),\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\n#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\n;\n\tSECTION(\"Angle 2D\") {\n        VectorT<double, 2> v1(1.0, 3.0);\n        VectorT<double, 2> v2(-1.0, 2.0);\n        CHECK(v1.Angle(v2) == Approx(acos(M_SQRT1_2)));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, typename OtherScalar2, typename OtherScalar3> [[nodiscard]] bool IsEqual(const VectorT<OtherScalar, DIM>& other, const OtherScalar2& tolDis, const OtherScalar3& tolAng),\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\n#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\n;\n\tSECTION(\"Mirror(point) 2D\") {\n        VectorT<double, 2> p1(1.0, 2.0);\n        VectorT<double, 2> p2(2.0, 3.0);\n        VectorT<double, 2> p3(19.0 / 13.0, 22.0 / 13.0);\n        CHECK(p1.Mirrored(p2).IsEqual(p3, tolDis, tolAng));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename... T> explicit VectorT(T... vs),\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\n#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\n;\n\tSECTION(\"Angle 2D\") {\n        VectorT<double, 2> v1(1.0, 3.0);\n        VectorT<double, 2> v2(-1.0, 2.0);\n        CHECK(v1.Angle(v2) == Approx(acos(M_SQRT1_2)));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar> explicit VectorT(const CoordT<OtherScalar, DIM>& v),\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\n#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\n;\n\tSECTION(\"Mirror(point) 2D\") {\n        VectorT<double, 2> p1(1.0, 2.0);\n        VectorT<double, 2> p2(2.0, 3.0);\n        VectorT<double, 2> p3(19.0 / 13.0, 22.0 / 13.0);\n        CHECK(p1.Mirrored(p2).IsEqual(p3, tolDis, tolAng));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar> explicit VectorT(const DirectionT<OtherScalar, DIM>& dir),\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\n#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\n;\n\tSECTION(\"Mirror(axis) 2D\") {\n        VectorT<double, 2> p1(1.0, 2.0);\n        PointT<double, 2> p2(2.0, 3.0);\n        DirectionT<double, 2> d(7.0, 3.0);\n        AxisT<double, 2> a(p2, d);\n        VectorT<double, 2> p3(62.0 / 29.0, -19.0 / 29.0);\n        CHECK(p1.Mirrored(a).IsEqual(p3, tolDis, tolAng));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, typename OtherScalar2, int DIM2 = DIM, typename = typename std::enable_if_t<DIM2 == 3>> [[nodiscard]] DirectionT Rotated(const AxisT<OtherScalar, DIM>& axis, const OtherScalar2& angle),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\n#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\n;\n\tSECTION(\"Rotate 3D\") {\n            DirectionT<double, 3> p1(1.0, 2.0, 3.0);\n            PointT<double, 3> p2(2.0, 3.0, 4.0);\n            DirectionT<double, 3> d(1.0, 1.0, 2.0);\n            AxisT<double, 3> a(p2, d);\n            DirectionT<double, 3> p3((9.0 - std::sqrt(6.0)) / 6.0, (9.0 - std::sqrt(6.0)) / 6.0, 3.0 + 1.0 / std::sqrt(6.0));\n            CHECK(p1.Rotated(a, M_PI_2).IsEqual(p3, tol));\n        }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, typename OtherScalar2, int DIM2 = DIM, typename = typename std::enable_if_t<DIM2 == 3>> DirectionT& Rotate(const AxisT<OtherScalar, DIM>& axis, const OtherScalar2& angle),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\n#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\n;\n\tSECTION(\"Rotate 3D\") {\n            DirectionT<double, 3> p1(1.0, 2.0, 3.0);\n            PointT<double, 3> p2(2.0, 3.0, 4.0);\n            DirectionT<double, 3> d(1.0, 1.0, 2.0);\n            AxisT<double, 3> a(p2, d);\n            DirectionT<double, 3> p3((9.0 - std::sqrt(6.0)) / 6.0, (9.0 - std::sqrt(6.0)) / 6.0, 3.0 + 1.0 / std::sqrt(6.0));\n            CHECK(p1.Rotated(a, M_PI_2).IsEqual(p3, tol));\n        }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, int DIM2 = DIM, std::enable_if_t<DIM2 == 3, int> = 0> [[nodiscard]] DirectionT Mirrored(const FrameT<OtherScalar, DIM>& frame),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\n#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\n;\n\tSECTION(\"Mirror(point) 3D\") {\n        DirectionT<double, 3> p1(1.0, 2.0, 3.0);\n        DirectionT<double, 3> p2(2.0, 4.0, 5.0);\n        DirectionT<double, 3> p3(11.0 / 9.0, 22.0 / 9.0, 23.0 / 9.0);\n        CHECK(p1.Mirrored(p2).IsEqual(p3, tol));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar> [[nodiscard]] DirectionT Mirrored(const AxisT<OtherScalar, DIM>& axis),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\n#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\n;\n\tSECTION(\"Mirror(point) 3D\") {\n        DirectionT<double, 3> p1(1.0, 2.0, 3.0);\n        DirectionT<double, 3> p2(2.0, 4.0, 5.0);\n        DirectionT<double, 3> p3(11.0 / 9.0, 22.0 / 9.0, 23.0 / 9.0);\n        CHECK(p1.Mirrored(p2).IsEqual(p3, tol));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar> [[nodiscard]] DirectionT Mirrored(const DirectionT<OtherScalar, DIM>& dir),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\n#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\n;\n\tSECTION(\"Mirror(axis) 3D\") {\n        DirectionT<double, 3> p1(1.0, 2.0, 3.0);\n        PointT<double, 3> p2(2.0, 3.0, 4.0);\n        DirectionT<double, 3> d(7.0, 3.0, 2.0);\n        AxisT<double, 3> a(p2, d);\n        DirectionT<double, 3> p3(102.0 / 31.0, -5.0 / 31.0, -55.0 / 31.0);\n        CHECK(p1.Mirrored(a).IsEqual(p3, tol));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, int DIM2 = DIM, std::enable_if_t<DIM2 == 3, int> = 0> DirectionT& Mirror(const FrameT<OtherScalar, DIM>& frame),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\n#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\n;\n\tSECTION(\"Mirror(axis) 3D\") {\n        DirectionT<double, 3> p1(1.0, 2.0, 3.0);\n        PointT<double, 3> p2(2.0, 3.0, 4.0);\n        DirectionT<double, 3> d(7.0, 3.0, 2.0);\n        AxisT<double, 3> a(p2, d);\n        DirectionT<double, 3> p3(102.0 / 31.0, -5.0 / 31.0, -55.0 / 31.0);\n        CHECK(p1.Mirrored(a).IsEqual(p3, tol));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar> DirectionT& Mirror(const AxisT<OtherScalar, DIM>& axis),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\n#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\n;\n\tSECTION(\"Mirror(axis) 3D\") {\n        DirectionT<double, 3> p1(1.0, 2.0, 3.0);\n        PointT<double, 3> p2(2.0, 3.0, 4.0);\n        DirectionT<double, 3> d(7.0, 3.0, 2.0);\n        AxisT<double, 3> a(p2, d);\n        DirectionT<double, 3> p3(102.0 / 31.0, -5.0 / 31.0, -55.0 / 31.0);\n        CHECK(p1.Mirrored(a).IsEqual(p3, tol));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar> DirectionT& Mirror(const DirectionT<OtherScalar, DIM>& dir),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\n#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\n;\n\tSECTION(\"Mirror(frame) 3D\") {\n        DirectionT<double, 3> p1(1.0, 2.0, 3.0);\n        PointT<double, 3> p2(2.0, 3.0, 4.0);\n        DirectionT<double, 3> d(7.0, 3.0, 2.0);\n        FrameT<double, 3> f(p2, d);\n        DirectionT<double, 3> p3(-102.0 / 31.0, 5.0 / 31.0, 55.0 / 31.0);\n        CHECK(p1.Mirrored(f).IsEqual(p3, tol));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "DirectionT& Reverse()\t @return The reference to self\n\t @brief Reverse the direction\n,\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\n#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\n;\n\tSECTION(\"Reverse\") {\n        DirectionT<double, 3> v1(1.0, 2.0, 2.0);\n        DirectionT<double, 3> v2(-1.0, -2.0, -2.0);\n        CHECK(v1.IsEqual(-v2, tol));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar> [[nodiscard]] auto Cross(const DirectionT<OtherScalar, DIM>& other),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\n#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\n;\n\tSECTION(\"Cross 3D\") {\n        DirectionT<double, 3> v1(1.0, 2.0, 3.0);\n        DirectionT<double, 3> v2(2.0, 3.0, 4.0);\n        CoordT<double, 3> v3(-1.0 / std::sqrt(6.0), 2.0 / std::sqrt(6.0), -1.0 / std::sqrt(6.0));\n        CHECK(v1.Cross(v2).Coord().IsEqual(v3, tol));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, typename OtherScalar2, int DIM2 = DIM, typename = typename std::enable_if_t<DIM2 == 3>> [[nodiscard]] auto AngleWithRef(const DirectionT<OtherScalar, DIM>& other, const DirectionT<OtherScalar2, DIM>& ref),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\n#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\n;\n\tSECTION(\"AngleWithRef\") {\n        DirectionT<double, 3> v1(1.0, 2.0, 3.0);\n        DirectionT<double, 3> v2(-3.0, 2.0, -1.0);\n        DirectionT<double, 3> v3(1.0, 1.0, 1.0);\n        CHECK(v1.AngleWithRef(v2, v3) == Approx(-acos(-1.0 / 7.0)));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, int DIM2 = DIM, std::enable_if_t<DIM2 == 3, int> = 0> [[nodiscard]] auto Angle(const DirectionT<OtherScalar, DIM>& other),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\n#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\n;\n\tSECTION(\"Angle 3D\") {\n        DirectionT<double, 3> v1(1.0, 2.0, 3.0);\n        DirectionT<double, 3> v2(-3.0, 2.0, -1.0);\n        CHECK(v1.Angle(v2) == acos(-1.0 / 7.0));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, int DIM2 = DIM, std::enable_if_t<DIM2 == 2, int> = 0> [[nodiscard]] auto Angle(const DirectionT<OtherScalar, DIM>& other),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\n#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\n;\n\tSECTION(\"Angle 3D\") {\n        DirectionT<double, 3> v1(1.0, 2.0, 3.0);\n        DirectionT<double, 3> v2(-3.0, 2.0, -1.0);\n        CHECK(v1.Angle(v2) == acos(-1.0 / 7.0));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, typename OtherScalar2> [[nodiscard]] bool IsParallel(const DirectionT<OtherScalar, DIM>& other, const OtherScalar2& tol),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\n#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\n;\n\tSECTION(\"IsParallel\"){\n        DirectionT<double, 3> v1(1.0, 2.0, 3.0);\n        DirectionT<double, 3> v2(-1.0, -2.0, -3.01);\n        CHECK(v1.IsParallel(v2, tol) == false);\n        CHECK(v1.IsParallel(v2, 0.1));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, typename OtherScalar2> [[nodiscard]] bool IsOpposite(const DirectionT<OtherScalar, DIM>& other, const OtherScalar2& tol),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\n#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\n;\n\tSECTION(\"IsOpposite\") {\n        DirectionT<double, 3> v1(1.0, 2.0, 3.0);\n        DirectionT<double, 3> v2(-1.0, -2.0, -3.01);\n        CHECK(v1.IsOpposite(v2, 0.1));\n        CHECK(v1.IsOpposite(v2, tol) == false);\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, typename OtherScalar2> [[nodiscard]] bool IsNormal(const DirectionT<OtherScalar, DIM>& other, const OtherScalar2& tol),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\n#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\n;\n\tSECTION(\"IsNormal\") {\n        DirectionT<double, 3> v1(1.0, 2.0, 3.0);\n        DirectionT<double, 3> v2(-4.0, -1.0, 2.01);\n        CHECK(v1.IsNormal(v2, tol) == false);\n        CHECK(v1.IsNormal(v2, 0.1));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, typename OtherScalar2> [[nodiscard]] bool IsEqual(const DirectionT<OtherScalar, DIM>& other, const OtherScalar2& tol),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\n#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\n;\n\tSECTION(\"Default constructor\") {\n        DirectionT<double, 3> p1;\n        DirectionT<double, 3> p2(1.0, 0.0, 0.0);\n        CHECK(p1.IsEqual(p2, tol));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, typename = typename std::enable_if_t<DIM >= 4 && std::is_convertible_v<OtherScalar, Scalar>>> void SetW(const OtherScalar& w),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\n#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\n;\n\tSECTION(\"SetX, SetY, SetZ, SetW\"){\n        DirectionT<double, 4> result;\n        result.SetX(1);\n        result.SetY(2);\n        result.SetZ(3);\n        result.SetW(4);\n        CoordT<double, 4> expected(1.0 / sqrt(850.0), 2.0 / sqrt(850.0), 3.0 / sqrt(170), 4.0 / sqrt(17));\n        CHECK(result.X() == Approx(1.0 / sqrt(850.0)));\n        CHECK(result.Y() == Approx(2.0 / sqrt(850.0)));\n        CHECK(result.Z() == Approx(3.0 / sqrt(170.0)));\n        CHECK(result.W() == Approx(4.0 / sqrt(17.0)));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, typename = typename std::enable_if_t<DIM >= 2 && std::is_convertible_v<OtherScalar, Scalar>>> void SetY(const OtherScalar& y),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\n#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\n;\n\tSECTION(\"SetX, SetY, SetZ, SetW\"){\n        DirectionT<double, 4> result;\n        result.SetX(1);\n        result.SetY(2);\n        result.SetZ(3);\n        result.SetW(4);\n        CoordT<double, 4> expected(1.0 / sqrt(850.0), 2.0 / sqrt(850.0), 3.0 / sqrt(170), 4.0 / sqrt(17));\n        CHECK(result.X() == Approx(1.0 / sqrt(850.0)));\n        CHECK(result.Y() == Approx(2.0 / sqrt(850.0)));\n        CHECK(result.Z() == Approx(3.0 / sqrt(170.0)));\n        CHECK(result.W() == Approx(4.0 / sqrt(17.0)));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, typename = typename std::enable_if_t<DIM >= 1 && std::is_convertible_v<OtherScalar, Scalar>>> void SetX(const OtherScalar& x),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\n#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\n;\n\tSECTION(\"SetX, SetY, SetZ, SetW\"){\n        DirectionT<double, 4> result;\n        result.SetX(1);\n        result.SetY(2);\n        result.SetZ(3);\n        result.SetW(4);\n        CoordT<double, 4> expected(1.0 / sqrt(850.0), 2.0 / sqrt(850.0), 3.0 / sqrt(170), 4.0 / sqrt(17));\n        CHECK(result.X() == Approx(1.0 / sqrt(850.0)));\n        CHECK(result.Y() == Approx(2.0 / sqrt(850.0)));\n        CHECK(result.Z() == Approx(3.0 / sqrt(170.0)));\n        CHECK(result.W() == Approx(4.0 / sqrt(17.0)));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename... T> void SetCoord(T... vs),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\n#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\n;\n\tSECTION(\"SetCoord(x, y, z)\") {\n        DirectionT<double, 3> result;\n        result.SetCoord(1.0, 2.0, 3.0);\n        CoordT<double, 3> expected(1.0 / sqrt(14.0), 2.0 / sqrt(14.0), 3.0 / sqrt(14.0));\n        CHECK(result.Coord().IsEqual(expected, tol));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename... T> explicit DirectionT(T... vs),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\n#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\n;\n\tSECTION(\"Default constructor\") {\n        DirectionT<double, 3> p1;\n        DirectionT<double, 3> p2(1.0, 0.0, 0.0);\n        CHECK(p1.IsEqual(p2, tol));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar> explicit DirectionT(const CoordT<OtherScalar, DIM>& v),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\n#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\n;\n\tSECTION(\"Constructor from vector\") {\n        VectorT<double, 3> v(1.0, 2.0, 3.0);\n        DirectionT<double, 3> result(v);\n        CoordT<double, 3> expected(1.0 / sqrt(14.0), 2.0 / sqrt(14.0), 3.0 / sqrt(14.0));\n        CHECK(result.Coord().IsEqual(expected, tol));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar> explicit DirectionT(const VectorT<OtherScalar, DIM>& vec),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\n#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\n;\n\tSECTION(\"Default constructor\") {\n        DirectionT<double, 3> p1;\n        DirectionT<double, 3> p2(1.0, 0.0, 0.0);\n        CHECK(p1.IsEqual(p2, tol));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "DirectionT()\t @details Default direction is (1, 0, ... , 0)\n\t @brief Default constructor\n,\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\n#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\n;\n\tSECTION(\"Default constructor\") {\n        DirectionT<double, 3> p1;\n        DirectionT<double, 3> p2(1.0, 0.0, 0.0);\n        CHECK(p1.IsEqual(p2, tol));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, int DIM2 = DIM, typename = typename std::enable_if_t<DIM2 == 2>> [[nodiscard]] DirectionT Rotated(const OtherScalar& angle),\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\n#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\n;\n\tSECTION(\"Rotate 2D\") {\n        DirectionT<double, 2> p1(1.0, 2.0);\n        DirectionT<double, 2> p3(-2.0, 1.0);\n        CHECK(p1.Rotated(M_PI_2).IsEqual(p3, tol));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, int DIM2 = DIM, typename = typename std::enable_if_t<DIM2 == 2>> DirectionT& Rotate(const OtherScalar& angle),\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\n#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\n;\n\tSECTION(\"Rotate 2D\") {\n        DirectionT<double, 2> p1(1.0, 2.0);\n        DirectionT<double, 2> p3(-2.0, 1.0);\n        CHECK(p1.Rotated(M_PI_2).IsEqual(p3, tol));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar> [[nodiscard]] DirectionT Mirrored(const AxisT<OtherScalar, DIM>& axis),\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\n#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\n;\n\tSECTION(\"Mirror(point) 2D\") {\n        DirectionT<double, 2> p1(1.0, 2.0);\n        DirectionT<double, 2> p2(2.0, 3.0);\n        DirectionT<double, 2> p3(19.0 / 13.0, 22.0 / 13.0);\n        CHECK(p1.Mirrored(p2).IsEqual(p3, tol));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar> [[nodiscard]] DirectionT Mirrored(const DirectionT<OtherScalar, DIM>& dir),\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\n#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\n;\n\tSECTION(\"Mirror(axis) 2D\") {\n        DirectionT<double, 2> p1(1.0, 2.0);\n        PointT<double, 2> p2(2.0, 3.0);\n        DirectionT<double, 2> d(7.0, 3.0);\n        AxisT<double, 2> a(p2, d);\n        DirectionT<double, 2> p3(62.0 / 29.0, -19.0 / 29.0);\n        CHECK(p1.Mirrored(a).IsEqual(p3, tol));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar> DirectionT& Mirror(const AxisT<OtherScalar, DIM>& axis),\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\n#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\n;\n\tSECTION(\"Mirror(axis) 2D\") {\n        DirectionT<double, 2> p1(1.0, 2.0);\n        PointT<double, 2> p2(2.0, 3.0);\n        DirectionT<double, 2> d(7.0, 3.0);\n        AxisT<double, 2> a(p2, d);\n        DirectionT<double, 2> p3(62.0 / 29.0, -19.0 / 29.0);\n        CHECK(p1.Mirrored(a).IsEqual(p3, tol));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar> [[nodiscard]] auto Cross(const DirectionT<OtherScalar, DIM>& other),\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\n#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\n;\n\tSECTION(\"Cross 2D\") {\n        DirectionT<double, 2> v1(1.0, 2.0);\n        DirectionT<double, 2> v2(2.0, 3.0);\n        CHECK(v1.Cross(v2) == Approx(-1.0/sqrt(65.0)));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, int DIM2 = DIM, std::enable_if_t<DIM2 == 2, int> = 0> [[nodiscard]] auto Angle(const DirectionT<OtherScalar, DIM>& other),\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\n#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\n;\n\tSECTION(\"Angle 2D\") {\n        DirectionT<double, 2> v1(1.0, 3.0);\n        DirectionT<double, 2> v2(-1.0, 2.0);\n        CHECK(v1.Angle(v2) == Approx(acos(M_SQRT1_2)));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, typename OtherScalar2> [[nodiscard]] bool IsEqual(const DirectionT<OtherScalar, DIM>& other, const OtherScalar2& tol),\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\n#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\n;\n\tSECTION(\"Mirror(point) 2D\") {\n        DirectionT<double, 2> p1(1.0, 2.0);\n        DirectionT<double, 2> p2(2.0, 3.0);\n        DirectionT<double, 2> p3(19.0 / 13.0, 22.0 / 13.0);\n        CHECK(p1.Mirrored(p2).IsEqual(p3, tol));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename... T> explicit DirectionT(T... vs),\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\n#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\n;\n\tSECTION(\"Angle 2D\") {\n        DirectionT<double, 2> v1(1.0, 3.0);\n        DirectionT<double, 2> v2(-1.0, 2.0);\n        CHECK(v1.Angle(v2) == Approx(acos(M_SQRT1_2)));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar> explicit DirectionT(const CoordT<OtherScalar, DIM>& v),\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\n#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\n;\n\tSECTION(\"Mirror(point) 2D\") {\n        DirectionT<double, 2> p1(1.0, 2.0);\n        DirectionT<double, 2> p2(2.0, 3.0);\n        DirectionT<double, 2> p3(19.0 / 13.0, 22.0 / 13.0);\n        CHECK(p1.Mirrored(p2).IsEqual(p3, tol));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar> explicit DirectionT(const VectorT<OtherScalar, DIM>& vec),\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\n#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\n;\n\tSECTION(\"Mirror(point) 2D\") {\n        DirectionT<double, 2> p1(1.0, 2.0);\n        DirectionT<double, 2> p2(2.0, 3.0);\n        DirectionT<double, 2> p3(19.0 / 13.0, 22.0 / 13.0);\n        CHECK(p1.Mirrored(p2).IsEqual(p3, tol));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "DirectionT()\t @details Default direction is (1, 0, ... , 0)\n\t @brief Default constructor\n,\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\n#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\n;\n\tSECTION(\"Mirror(point) 2D\") {\n        DirectionT<double, 2> p1(1.0, 2.0);\n        DirectionT<double, 2> p2(2.0, 3.0);\n        DirectionT<double, 2> p3(19.0 / 13.0, 22.0 / 13.0);\n        CHECK(p1.Mirrored(p2).IsEqual(p3, tol));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, typename OtherScalar2> [[nodiscard]] FrameT Translated(const PointT<OtherScalar, DIM>& p1, const PointT<OtherScalar2, DIM>& p2),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {\n\treturn result.Location().IsEqual(expected.Location(), tol) &&\n\t\tresult.Direction().IsEqual(expected.Direction(), tol);\n}\n#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {\n\treturn result.Location().IsEqual(expected.Location(), tol) &&\n\t\tresult.Direction().IsEqual(expected.Direction(), tol);\n;\n\tSECTION(\"IsCoplanar frame\"){\n\t\tPointT<double, 3> p(1.0, -1.0, 0.0);\n\t\tPointT<double, 3> p2(1.0, 2.0, -2.0);\n\t\tPointT<double, 3> p3(1.0, 2.0, -1.0);\n\t\tDirectionT<double, 3> dz(1.0, 2.0, 3.0);\n\t\tDirectionT<double, 3> dz2(1.0, 2.0, 3.1);\n\t\tFrameT<double, 3> f1(p, dz);\n\t\tFrameT<double, 3> f2(p2, dz);\n\t\tFrameT<double, 3> f3(p3, dz);\n\t\tFrameT<double, 3> f4(p2, dz2);\n\t\tCHECK(f1.IsCoplanar(f2, 1e-6, 1e-6) == true);\n\t\tCHECK(f1.IsCoplanar(f3, 1e-6, 1e-6) == false);\n\t\tCHECK(f1.IsCoplanar(f4, 1e-6, 1e-6) == false);\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar> [[nodiscard]] FrameT Translated(const VectorT<OtherScalar, DIM>& vec),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {\n\treturn result.Location().IsEqual(expected.Location(), tol) &&\n\t\tresult.Direction().IsEqual(expected.Direction(), tol);\n}\n#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {\n\treturn result.Location().IsEqual(expected.Location(), tol) &&\n\t\tresult.Direction().IsEqual(expected.Direction(), tol);\n;\n\tSECTION(\"Translate vector 3D\"){\n\t\tPointT<double, 3> p(1.0, -1.0, 0.0);\n\t\tDirectionT<double, 3> dz(1.0, 2.0, 3.0);\n\t\tFrameT<double, 3> f1(p, dz);\n\t\tVectorT<double, 3> v(2.0, 3.0, -1.0);\n\t\tPointT<double, 3> p2(3.0, 2.0, -1.0);\n\t\tFrameT<double, 3> f2(p2, dz);\n\t\tCHECK(IsEqual(f1.Translated(v), f2));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar> FrameT& Translate(const VectorT<OtherScalar, DIM>& vec),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {\n\treturn result.Location().IsEqual(expected.Location(), tol) &&\n\t\tresult.Direction().IsEqual(expected.Direction(), tol);\n}\n#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {\n\treturn result.Location().IsEqual(expected.Location(), tol) &&\n\t\tresult.Direction().IsEqual(expected.Direction(), tol);\n;\n\tSECTION(\"Translate vector 3D\"){\n\t\tPointT<double, 3> p(1.0, -1.0, 0.0);\n\t\tDirectionT<double, 3> dz(1.0, 2.0, 3.0);\n\t\tFrameT<double, 3> f1(p, dz);\n\t\tVectorT<double, 3> v(2.0, 3.0, -1.0);\n\t\tPointT<double, 3> p2(3.0, 2.0, -1.0);\n\t\tFrameT<double, 3> f2(p2, dz);\n\t\tCHECK(IsEqual(f1.Translated(v), f2));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, typename OtherScalar2> [[nodiscard]] FrameT Scaled(const PointT<OtherScalar, DIM>& point, const OtherScalar2& scale),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {\n\treturn result.Location().IsEqual(expected.Location(), tol) &&\n\t\tresult.Direction().IsEqual(expected.Direction(), tol);\n}\n#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {\n\treturn result.Location().IsEqual(expected.Location(), tol) &&\n\t\tresult.Direction().IsEqual(expected.Direction(), tol);\n;\n\tSECTION(\"Scale 3D\"){\n\t\tPointT<double, 3> p(1.0, -1.0, 0.0);\n\t\tDirectionT<double, 3> dz(1.0, 2.0, 3.0);\n\t\tFrameT<double, 3> f1(p, dz);\n\t\tPointT<double, 3> p2(1.0, 2.0, 3.0);\n\t\tPointT<double, 3> p3(1.0, -2.5, -1.5);\n\t\tFrameT<double, 3> f2(p3, dz);\n\t\tCHECK(IsEqual(f1.Scaled(p2, 1.5), f2));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, typename OtherScalar2, int DIM2 = DIM, typename = typename std::enable_if_t<DIM2 == 3>> [[nodiscard]] FrameT Rotated(const AxisT<OtherScalar, DIM>& a, const OtherScalar2& angle),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {\n\treturn result.Location().IsEqual(expected.Location(), tol) &&\n\t\tresult.Direction().IsEqual(expected.Direction(), tol);\n}\n#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {\n\treturn result.Location().IsEqual(expected.Location(), tol) &&\n\t\tresult.Direction().IsEqual(expected.Direction(), tol);\n;\n\tSECTION(\"Rotate 3D\"){\n\t\tPointT<double, 3> p(1.0, -1.0, 0.0);\n\t\tDirectionT<double, 3> dz(1.0, 2.0, 3.0);\n\t\tFrameT<double, 3> f1(p, dz);\n\t\tPointT<double, 3> p2(1.0, 2.0, 3.0);\n\t\tDirectionT<double, 3> dz2(3.0, 2.0, 1.0);\n\t\tAxisT<double, 3> axis(p2, dz2);\n\t\tPointT<double, 3> p3(-3.0 / sqrt(14.0) - 13.0 / 14.0, 9.0 / std::sqrt(14.0) + 10.0 / 14.0, -9.0 / std::sqrt(14.0) + 33.0 / 14.0);\n\t\tDirectionT<double, 3> dz3(4.0 / sqrt(14.0) + 15.0 / 7.0, -8.0 / sqrt(14.0) + 10.0 / 7.0, 4.0 / sqrt(14.0) + 5.0 / 7.0);\n\t\tDirectionT<double, 3> dx3(-7.0 / sqrt(14.0) + 6.0 / 7.0, 6.0 / sqrt(14.0) + 4.0 / 7.0, 9.0 / sqrt(14.0) + 2.0 / 7.0);\n\t\tFrameT<double, 3> f2(p3, dz3, dx3);\n\t\tFrameT<double, 3> f3 = f1.Rotated(axis, M_PI_2);\n\t\tCHECK(IsEqual(f3, f2));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, typename OtherScalar2, int DIM2 = DIM, typename = typename std::enable_if_t<DIM2 == 2>> [[nodiscard]] FrameT Rotated(const PointT<OtherScalar, DIM>& point, const OtherScalar2& angle),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {\n\treturn result.Location().IsEqual(expected.Location(), tol) &&\n\t\tresult.Direction().IsEqual(expected.Direction(), tol);\n}\n#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {\n\treturn result.Location().IsEqual(expected.Location(), tol) &&\n\t\tresult.Direction().IsEqual(expected.Direction(), tol);\n;\n\tSECTION(\"Rotate 3D\"){\n\t\tPointT<double, 3> p(1.0, -1.0, 0.0);\n\t\tDirectionT<double, 3> dz(1.0, 2.0, 3.0);\n\t\tFrameT<double, 3> f1(p, dz);\n\t\tPointT<double, 3> p2(1.0, 2.0, 3.0);\n\t\tDirectionT<double, 3> dz2(3.0, 2.0, 1.0);\n\t\tAxisT<double, 3> axis(p2, dz2);\n\t\tPointT<double, 3> p3(-3.0 / sqrt(14.0) - 13.0 / 14.0, 9.0 / std::sqrt(14.0) + 10.0 / 14.0, -9.0 / std::sqrt(14.0) + 33.0 / 14.0);\n\t\tDirectionT<double, 3> dz3(4.0 / sqrt(14.0) + 15.0 / 7.0, -8.0 / sqrt(14.0) + 10.0 / 7.0, 4.0 / sqrt(14.0) + 5.0 / 7.0);\n\t\tDirectionT<double, 3> dx3(-7.0 / sqrt(14.0) + 6.0 / 7.0, 6.0 / sqrt(14.0) + 4.0 / 7.0, 9.0 / sqrt(14.0) + 2.0 / 7.0);\n\t\tFrameT<double, 3> f2(p3, dz3, dx3);\n\t\tFrameT<double, 3> f3 = f1.Rotated(axis, M_PI_2);\n\t\tCHECK(IsEqual(f3, f2));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, typename OtherScalar2, int DIM2 = DIM, typename = typename std::enable_if_t<DIM2 == 3>> FrameT& Rotate(const AxisT<OtherScalar, DIM>& a, const OtherScalar2& angle),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {\n\treturn result.Location().IsEqual(expected.Location(), tol) &&\n\t\tresult.Direction().IsEqual(expected.Direction(), tol);\n}\n#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {\n\treturn result.Location().IsEqual(expected.Location(), tol) &&\n\t\tresult.Direction().IsEqual(expected.Direction(), tol);\n;\n\tSECTION(\"Rotate 3D\"){\n\t\tPointT<double, 3> p(1.0, -1.0, 0.0);\n\t\tDirectionT<double, 3> dz(1.0, 2.0, 3.0);\n\t\tFrameT<double, 3> f1(p, dz);\n\t\tPointT<double, 3> p2(1.0, 2.0, 3.0);\n\t\tDirectionT<double, 3> dz2(3.0, 2.0, 1.0);\n\t\tAxisT<double, 3> axis(p2, dz2);\n\t\tPointT<double, 3> p3(-3.0 / sqrt(14.0) - 13.0 / 14.0, 9.0 / std::sqrt(14.0) + 10.0 / 14.0, -9.0 / std::sqrt(14.0) + 33.0 / 14.0);\n\t\tDirectionT<double, 3> dz3(4.0 / sqrt(14.0) + 15.0 / 7.0, -8.0 / sqrt(14.0) + 10.0 / 7.0, 4.0 / sqrt(14.0) + 5.0 / 7.0);\n\t\tDirectionT<double, 3> dx3(-7.0 / sqrt(14.0) + 6.0 / 7.0, 6.0 / sqrt(14.0) + 4.0 / 7.0, 9.0 / sqrt(14.0) + 2.0 / 7.0);\n\t\tFrameT<double, 3> f2(p3, dz3, dx3);\n\t\tFrameT<double, 3> f3 = f1.Rotated(axis, M_PI_2);\n\t\tCHECK(IsEqual(f3, f2));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, int DIM2 = DIM, std::enable_if_t<DIM2 == 3, int> = 0> [[nodiscard]] FrameT Mirrored(const FrameT<OtherScalar, DIM>& frame),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {\n\treturn result.Location().IsEqual(expected.Location(), tol) &&\n\t\tresult.Direction().IsEqual(expected.Direction(), tol);\n}\n#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {\n\treturn result.Location().IsEqual(expected.Location(), tol) &&\n\t\tresult.Direction().IsEqual(expected.Direction(), tol);\n;\n\tSECTION(\"Mirror point 3D\"){\n\t\tPointT<double, 3> p(1.0, -1.0, 0.0);\n\t\tPointT<double, 3> p2(1.0, 2.0, -2.0);\n\t\tPointT<double, 3> p3(1.0, 5.0, -4.0);\n\t\tDirectionT<double, 3> dz(1.0, 2.0, 3.0);\n\t\tFrameT<double, 3> f1(p, dz);\n\t\tDirectionT<double, 3> dz2(-1.0, -2.0, -3.0);\n\t\tDirectionT<double, 3> dx2(0.0, -3.0, 2.0);\n\t\tFrameT<double, 3> f2(p3, dz2, dx2);\n\t\tFrameT<double, 3> f3 = f1.Mirrored(p2);\n\t\tCHECK(f3.Location().IsEqual(p3, tol));\n\t\tCHECK(f3.Direction().IsEqual(dz2, tol));\n\t\tCHECK(f3.XDirection().IsEqual(dx2, tol));\n\t\tCHECK(f3.YDirection().IsEqual(dx2.Cross(dz2), tol));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar> [[nodiscard]] FrameT Mirrored(const AxisT<OtherScalar, DIM>& a),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {\n\treturn result.Location().IsEqual(expected.Location(), tol) &&\n\t\tresult.Direction().IsEqual(expected.Direction(), tol);\n}\n#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {\n\treturn result.Location().IsEqual(expected.Location(), tol) &&\n\t\tresult.Direction().IsEqual(expected.Direction(), tol);\n;\n\tSECTION(\"Mirror point 3D\"){\n\t\tPointT<double, 3> p(1.0, -1.0, 0.0);\n\t\tPointT<double, 3> p2(1.0, 2.0, -2.0);\n\t\tPointT<double, 3> p3(1.0, 5.0, -4.0);\n\t\tDirectionT<double, 3> dz(1.0, 2.0, 3.0);\n\t\tFrameT<double, 3> f1(p, dz);\n\t\tDirectionT<double, 3> dz2(-1.0, -2.0, -3.0);\n\t\tDirectionT<double, 3> dx2(0.0, -3.0, 2.0);\n\t\tFrameT<double, 3> f2(p3, dz2, dx2);\n\t\tFrameT<double, 3> f3 = f1.Mirrored(p2);\n\t\tCHECK(f3.Location().IsEqual(p3, tol));\n\t\tCHECK(f3.Direction().IsEqual(dz2, tol));\n\t\tCHECK(f3.XDirection().IsEqual(dx2, tol));\n\t\tCHECK(f3.YDirection().IsEqual(dx2.Cross(dz2), tol));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar> [[nodiscard]] FrameT Mirrored(const PointT<OtherScalar, DIM>& point),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {\n\treturn result.Location().IsEqual(expected.Location(), tol) &&\n\t\tresult.Direction().IsEqual(expected.Direction(), tol);\n}\n#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {\n\treturn result.Location().IsEqual(expected.Location(), tol) &&\n\t\tresult.Direction().IsEqual(expected.Direction(), tol);\n;\n\tSECTION(\"Mirror point 3D\"){\n\t\tPointT<double, 3> p(1.0, -1.0, 0.0);\n\t\tPointT<double, 3> p2(1.0, 2.0, -2.0);\n\t\tPointT<double, 3> p3(1.0, 5.0, -4.0);\n\t\tDirectionT<double, 3> dz(1.0, 2.0, 3.0);\n\t\tFrameT<double, 3> f1(p, dz);\n\t\tDirectionT<double, 3> dz2(-1.0, -2.0, -3.0);\n\t\tDirectionT<double, 3> dx2(0.0, -3.0, 2.0);\n\t\tFrameT<double, 3> f2(p3, dz2, dx2);\n\t\tFrameT<double, 3> f3 = f1.Mirrored(p2);\n\t\tCHECK(f3.Location().IsEqual(p3, tol));\n\t\tCHECK(f3.Direction().IsEqual(dz2, tol));\n\t\tCHECK(f3.XDirection().IsEqual(dx2, tol));\n\t\tCHECK(f3.YDirection().IsEqual(dx2.Cross(dz2), tol));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar> FrameT& Mirror(const PointT<OtherScalar, DIM>& point),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {\n\treturn result.Location().IsEqual(expected.Location(), tol) &&\n\t\tresult.Direction().IsEqual(expected.Direction(), tol);\n}\n#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {\n\treturn result.Location().IsEqual(expected.Location(), tol) &&\n\t\tresult.Direction().IsEqual(expected.Direction(), tol);\n;\n\tSECTION(\"Mirror point 3D\"){\n\t\tPointT<double, 3> p(1.0, -1.0, 0.0);\n\t\tPointT<double, 3> p2(1.0, 2.0, -2.0);\n\t\tPointT<double, 3> p3(1.0, 5.0, -4.0);\n\t\tDirectionT<double, 3> dz(1.0, 2.0, 3.0);\n\t\tFrameT<double, 3> f1(p, dz);\n\t\tDirectionT<double, 3> dz2(-1.0, -2.0, -3.0);\n\t\tDirectionT<double, 3> dx2(0.0, -3.0, 2.0);\n\t\tFrameT<double, 3> f2(p3, dz2, dx2);\n\t\tFrameT<double, 3> f3 = f1.Mirrored(p2);\n\t\tCHECK(f3.Location().IsEqual(p3, tol));\n\t\tCHECK(f3.Direction().IsEqual(dz2, tol));\n\t\tCHECK(f3.XDirection().IsEqual(dx2, tol));\n\t\tCHECK(f3.YDirection().IsEqual(dx2.Cross(dz2), tol));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, typename OtherScalar2, typename OtherScalar3, int DIM2 = DIM, typename = typename std::enable_if_t<DIM2 == 3>> [[nodiscard]] bool IsCoplanar(const AxisT<OtherScalar, DIM>& a, const OtherScalar2& distol, const OtherScalar3& angtol),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {\n\treturn result.Location().IsEqual(expected.Location(), tol) &&\n\t\tresult.Direction().IsEqual(expected.Direction(), tol);\n}\n#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {\n\treturn result.Location().IsEqual(expected.Location(), tol) &&\n\t\tresult.Direction().IsEqual(expected.Direction(), tol);\n;\n\tSECTION(\"IsCoplanar frame\"){\n\t\tPointT<double, 3> p(1.0, -1.0, 0.0);\n\t\tPointT<double, 3> p2(1.0, 2.0, -2.0);\n\t\tPointT<double, 3> p3(1.0, 2.0, -1.0);\n\t\tDirectionT<double, 3> dz(1.0, 2.0, 3.0);\n\t\tDirectionT<double, 3> dz2(1.0, 2.0, 3.1);\n\t\tFrameT<double, 3> f1(p, dz);\n\t\tFrameT<double, 3> f2(p2, dz);\n\t\tFrameT<double, 3> f3(p3, dz);\n\t\tFrameT<double, 3> f4(p2, dz2);\n\t\tCHECK(f1.IsCoplanar(f2, 1e-6, 1e-6) == true);\n\t\tCHECK(f1.IsCoplanar(f3, 1e-6, 1e-6) == false);\n\t\tCHECK(f1.IsCoplanar(f4, 1e-6, 1e-6) == false);\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, typename OtherScalar2, typename OtherScalar3, int DIM2 = DIM, typename = typename std::enable_if_t<DIM2 == 3>> [[nodiscard]] bool IsCoplanar(const FrameT<OtherScalar, DIM>& other, const OtherScalar2& distol, const OtherScalar3& angtol),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {\n\treturn result.Location().IsEqual(expected.Location(), tol) &&\n\t\tresult.Direction().IsEqual(expected.Direction(), tol);\n}\n#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {\n\treturn result.Location().IsEqual(expected.Location(), tol) &&\n\t\tresult.Direction().IsEqual(expected.Direction(), tol);\n;\n\tSECTION(\"IsCoplanar frame\"){\n\t\tPointT<double, 3> p(1.0, -1.0, 0.0);\n\t\tPointT<double, 3> p2(1.0, 2.0, -2.0);\n\t\tPointT<double, 3> p3(1.0, 2.0, -1.0);\n\t\tDirectionT<double, 3> dz(1.0, 2.0, 3.0);\n\t\tDirectionT<double, 3> dz2(1.0, 2.0, 3.1);\n\t\tFrameT<double, 3> f1(p, dz);\n\t\tFrameT<double, 3> f2(p2, dz);\n\t\tFrameT<double, 3> f3(p3, dz);\n\t\tFrameT<double, 3> f4(p2, dz2);\n\t\tCHECK(f1.IsCoplanar(f2, 1e-6, 1e-6) == true);\n\t\tCHECK(f1.IsCoplanar(f3, 1e-6, 1e-6) == false);\n\t\tCHECK(f1.IsCoplanar(f4, 1e-6, 1e-6) == false);\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<int DIM2 = DIM, typename = typename std::enable_if_t<DIM2 >= 2>> [[nodiscard]] const DirectionT<Scalar, DIM>& YDirection(),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {\n\treturn result.Location().IsEqual(expected.Location(), tol) &&\n\t\tresult.Direction().IsEqual(expected.Direction(), tol);\n}\n#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {\n\treturn result.Location().IsEqual(expected.Location(), tol) &&\n\t\tresult.Direction().IsEqual(expected.Direction(), tol);\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<int DIM2 = DIM, typename = typename std::enable_if_t<DIM2 >= 1>> [[nodiscard]] const DirectionT<Scalar, DIM>& XDirection(),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {\n\treturn result.Location().IsEqual(expected.Location(), tol) &&\n\t\tresult.Direction().IsEqual(expected.Direction(), tol);\n}\n#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {\n\treturn result.Location().IsEqual(expected.Location(), tol) &&\n\t\tresult.Direction().IsEqual(expected.Direction(), tol);\n;\n\tSECTION(\"XDirection\"){\n\t\tPointT<double, 3> p(1.0, 2.0, 3.0);\n\t\tDirectionT<double, 3> dz(1.0, 2.0, 3.0);\n\t\tDirectionT<double, 3> dx(0.0, 3.0, -2.0);\n\t\tFrameT<double, 3> f1(p, dz);\n\t\tCHECK(f1.XDirection().IsEqual(dx, tol));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<int DIM2 = DIM, typename = typename std::enable_if_t<DIM2 >= 2>> [[nodiscard]] AxisT<Scalar, DIM> YAxis(),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {\n\treturn result.Location().IsEqual(expected.Location(), tol) &&\n\t\tresult.Direction().IsEqual(expected.Direction(), tol);\n}\n#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {\n\treturn result.Location().IsEqual(expected.Location(), tol) &&\n\t\tresult.Direction().IsEqual(expected.Direction(), tol);\n;\n\tSECTION(\"YAxis\"){\n\t\tPointT<double, 3> p(1.0, 2.0, 3.0);\n\t\tDirectionT<double, 3> dz(1.0, 2.0, 3.0);\n\t\tDirectionT<double, 3> dx(0.0, 3.0, -2.0);\n\t\tDirectionT<double, 3> dy(-13.0, 2.0, 3.0);\n\t\tFrameT<double, 3> f1(p, dz);\n\t\tCHECK(IsEqual(f1.YAxis(), AxisT<double, 3>(p, dy)));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, int DIM2 = DIM, std::enable_if_t<DIM2 == 3, int> = 0> void SetYDirection(const DirectionT<OtherScalar, DIM>& y),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {\n\treturn result.Location().IsEqual(expected.Location(), tol) &&\n\t\tresult.Direction().IsEqual(expected.Direction(), tol);\n}\n#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {\n\treturn result.Location().IsEqual(expected.Location(), tol) &&\n\t\tresult.Direction().IsEqual(expected.Direction(), tol);\n;\n\tSECTION(\"SetYDirection 3D\"){\n\t\tPointT<double, 3> p(0.0, 1.0, 2.0);\n\t\tDirectionT<double, 3> dz(1.0, 2.0, 3.0);\n\t\tDirectionT<double, 3> dx(-1.0, -1.0, 1.0);\n\t\tDirectionT<double, 3> dy2(-13.0, 2.0, 3.0);\n\t\tFrameT<double, 3> f1(p, dz);\n\t\tFrameT<double, 3> f2(p, dz, dx);\n\t\tf2.SetYDirection(dy2);\n\t\tCHECK(IsEqual(f1, f2));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, int DIM2 = DIM, std::enable_if_t<DIM2 == 2, int> = 0> void SetYDirection(const DirectionT<OtherScalar, DIM>& y),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {\n\treturn result.Location().IsEqual(expected.Location(), tol) &&\n\t\tresult.Direction().IsEqual(expected.Direction(), tol);\n}\n#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {\n\treturn result.Location().IsEqual(expected.Location(), tol) &&\n\t\tresult.Direction().IsEqual(expected.Direction(), tol);\n;\n\tSECTION(\"SetYDirection 3D\"){\n\t\tPointT<double, 3> p(0.0, 1.0, 2.0);\n\t\tDirectionT<double, 3> dz(1.0, 2.0, 3.0);\n\t\tDirectionT<double, 3> dx(-1.0, -1.0, 1.0);\n\t\tDirectionT<double, 3> dy2(-13.0, 2.0, 3.0);\n\t\tFrameT<double, 3> f1(p, dz);\n\t\tFrameT<double, 3> f2(p, dz, dx);\n\t\tf2.SetYDirection(dy2);\n\t\tCHECK(IsEqual(f1, f2));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, int DIM2 = DIM, std::enable_if_t<DIM2 == 3, int> = 0> void SetXDirection(const DirectionT<OtherScalar, DIM>& x),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {\n\treturn result.Location().IsEqual(expected.Location(), tol) &&\n\t\tresult.Direction().IsEqual(expected.Direction(), tol);\n}\n#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {\n\treturn result.Location().IsEqual(expected.Location(), tol) &&\n\t\tresult.Direction().IsEqual(expected.Direction(), tol);\n;\n\tSECTION(\"SetXDirection 3D\"){\n\t\tPointT<double, 3> p(0.0, 1.0, 2.0);\n\t\tDirectionT<double, 3> dz(1.0, 2.0, 3.0);\n\t\tDirectionT<double, 3> dx(-1.0, -1.0, 1.0);\n\t\tDirectionT<double, 3> dx2(0.0, 3.0, -2.0);\n\t\tFrameT<double, 3> f1(p, dz);\n\t\tFrameT<double, 3> f2(p, dz, dx);\n\t\tf2.SetXDirection(dx2);\n\t\tCHECK(IsEqual(f1, f2));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, int DIM2 = DIM, std::enable_if_t<DIM2 == 2, int> = 0> void SetXDirection(const DirectionT<OtherScalar, DIM>& x),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {\n\treturn result.Location().IsEqual(expected.Location(), tol) &&\n\t\tresult.Direction().IsEqual(expected.Direction(), tol);\n}\n#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {\n\treturn result.Location().IsEqual(expected.Location(), tol) &&\n\t\tresult.Direction().IsEqual(expected.Direction(), tol);\n;\n\tSECTION(\"SetXDirection 3D\"){\n\t\tPointT<double, 3> p(0.0, 1.0, 2.0);\n\t\tDirectionT<double, 3> dz(1.0, 2.0, 3.0);\n\t\tDirectionT<double, 3> dx(-1.0, -1.0, 1.0);\n\t\tDirectionT<double, 3> dx2(0.0, 3.0, -2.0);\n\t\tFrameT<double, 3> f1(p, dz);\n\t\tFrameT<double, 3> f2(p, dz, dx);\n\t\tf2.SetXDirection(dx2);\n\t\tCHECK(IsEqual(f1, f2));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, int DIM2 = DIM, typename = typename std::enable_if_t<DIM2 == 3>> void SetDirection(const DirectionT<OtherScalar, DIM>& dir),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {\n\treturn result.Location().IsEqual(expected.Location(), tol) &&\n\t\tresult.Direction().IsEqual(expected.Direction(), tol);\n}\n#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {\n\treturn result.Location().IsEqual(expected.Location(), tol) &&\n\t\tresult.Direction().IsEqual(expected.Direction(), tol);\n;\n\tSECTION(\"SetDirection 3D\"){\n\t\tPointT<double, 3> p(0.0, 1.0, 2.0);\n\t\tDirectionT<double, 3> dz(1.0, 2.0, 3.0);\n\t\tDirectionT<double, 3> dz2(2.3, 2.6, 3.3);\n\t\tDirectionT<double, 3> dx(0.0, 3.0, -2.0);\n\t\tFrameT<double, 3> f1(p, dz);\n\t\tFrameT<double, 3> f2(p, dz2);\n\t\tf2.SetDirection(dz);\n\t\tf2.SetXDirection(dx);\n\t\tCHECK(IsEqual(f1, f2));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, typename OtherScalar2, int DIM2 = DIM, std::enable_if_t<DIM2 == 3, int> = 0> FrameT(const PointT<OtherScalar, DIM>& point, const DirectionT<OtherScalar2, DIM>& dir),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {\n\treturn result.Location().IsEqual(expected.Location(), tol) &&\n\t\tresult.Direction().IsEqual(expected.Direction(), tol);\n}\n#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {\n\treturn result.Location().IsEqual(expected.Location(), tol) &&\n\t\tresult.Direction().IsEqual(expected.Direction(), tol);\n;\n\tSECTION(\"SetDirection 3D\"){\n\t\tPointT<double, 3> p(0.0, 1.0, 2.0);\n\t\tDirectionT<double, 3> dz(1.0, 2.0, 3.0);\n\t\tDirectionT<double, 3> dz2(2.3, 2.6, 3.3);\n\t\tDirectionT<double, 3> dx(0.0, 3.0, -2.0);\n\t\tFrameT<double, 3> f1(p, dz);\n\t\tFrameT<double, 3> f2(p, dz2);\n\t\tf2.SetDirection(dz);\n\t\tf2.SetXDirection(dx);\n\t\tCHECK(IsEqual(f1, f2));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, typename OtherScalar2, typename OtherScalar3, int DIM2 = DIM, std::enable_if_t<DIM2 == 3, int> = 0> FrameT(const PointT<OtherScalar, DIM>& point, const DirectionT<OtherScalar2, DIM>& normal, const DirectionT<OtherScalar3, DIM>& x),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {\n\treturn result.Location().IsEqual(expected.Location(), tol) &&\n\t\tresult.Direction().IsEqual(expected.Direction(), tol);\n}\n#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {\n\treturn result.Location().IsEqual(expected.Location(), tol) &&\n\t\tresult.Direction().IsEqual(expected.Direction(), tol);\n;\n\tSECTION(\"Translate point 3D\"){\n\t\tPointT<double, 3> p(1.0, -1.0, 0.0);\n\t\tDirectionT<double, 3> dz(1.0, 2.0, 3.0);\n\t\tFrameT<double, 3> f1(p, dz);\n\t\tPointT<double, 3> p2(1.0, 2.0, 3.0);\n\t\tPointT<double, 3> p3(2.0, 3.0, 5.0);\n\t\tPointT<double, 3> p4(2.0, 0.0, 2.0);\n\t\tFrameT<double, 3> f2(p4, dz);\n\t\tCHECK(IsEqual(f1.Translated(p2, p3), f2));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, typename OtherScalar2, typename OtherScalar3, int DIM2 = DIM, std::enable_if_t<DIM2 == 2, int> = 0> FrameT(const PointT<OtherScalar, DIM>& point, const DirectionT<OtherScalar2, DIM>& xdir, const DirectionT<OtherScalar3, DIM>& ydir),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {\n\treturn result.Location().IsEqual(expected.Location(), tol) &&\n\t\tresult.Direction().IsEqual(expected.Direction(), tol);\n}\n#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {\n\treturn result.Location().IsEqual(expected.Location(), tol) &&\n\t\tresult.Direction().IsEqual(expected.Direction(), tol);\n;\n\tSECTION(\"Default constructor\"){\n\t\tFrameT<double, 3> f1;\n\t\tPointT<double, 3> p(0.0, 0.0, 0.0);\n\t\tDirectionT<double, 3> dz(0.0, 0.0, 1.0);\n\t\tDirectionT<double, 3> dx(1.0, 0.0, 0.0);\n\t\tFrameT<double, 3> f2(p, dz, dx);\n\t\tCHECK(IsEqual(f1, f2));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] const PointT<Scalar, DIM>& Location()\t @return The location\n\t @brief Get the location\n,\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {\n\treturn result.Location().IsEqual(expected.Location(), tol) &&\n\t\tresult.Direction().IsEqual(expected.Direction(), tol);\n}\n#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {\n\treturn result.Location().IsEqual(expected.Location(), tol) &&\n\t\tresult.Direction().IsEqual(expected.Direction(), tol);\n;\n\tSECTION(\"Location\"){\n\t\tPointT<double, 3> p(1.0, 2.0, 3.0);\n\t\tDirectionT<double, 3> dz(1.0, 2.0, 3.0);\n\t\tFrameT<double, 3> f1(p, dz);\n\t\tCHECK(f1.Location().IsEqual(p, tol));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar> void SetLocation(const PointT<OtherScalar, DIM>& point),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {\n\treturn result.Location().IsEqual(expected.Location(), tol) &&\n\t\tresult.Direction().IsEqual(expected.Direction(), tol);\n}\n#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {\n\treturn result.Location().IsEqual(expected.Location(), tol) &&\n\t\tresult.Direction().IsEqual(expected.Direction(), tol);\n;\n\tSECTION(\"SetLocation\"){\n\t\tPointT<double, 3> p(0.0, 1.0, 2.0);\n\t\tDirectionT<double, 3> dz(1.0, 2.0, 3.0);\n\t\tDirectionT<double, 3> dx(0.0, 3.0, -2.0);\n\t\tFrameT<double, 3> f1(p, dz);\n\t\tPointT<double, 3> p2(1.0, 2.0, 3.0);\n\t\tFrameT<double, 3> f2(p2, dz, dx);\n\t\tf2.SetLocation(p);\n\t\tCHECK(IsEqual(f1, f2));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, typename OtherScalar2> [[nodiscard]] FrameT Translated(const PointT<OtherScalar, DIM>& p1, const PointT<OtherScalar2, DIM>& p2),\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\n#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n;\n\tSECTION(\"Translate vector 2D\") {\n\t\tPointT<double, 2> p(1.0, 2.0);\n\t\tDirectionT<double, 2> d(1.0, 3.0);\n\t\tFrameT<double, 2> f1(p, d);\n\t\tVectorT<double, 2> v(2.0, 3.0);\n\t\tPointT<double, 2> p2(3.0, 5.0);\n\t\tFrameT<double, 2> f2(p2, d);\n\t\tCHECK(IsEqual(f1.Translated(v), f2));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar> [[nodiscard]] FrameT Translated(const VectorT<OtherScalar, DIM>& vec),\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\n#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n;\n\tSECTION(\"Translate vector 2D\") {\n\t\tPointT<double, 2> p(1.0, 2.0);\n\t\tDirectionT<double, 2> d(1.0, 3.0);\n\t\tFrameT<double, 2> f1(p, d);\n\t\tVectorT<double, 2> v(2.0, 3.0);\n\t\tPointT<double, 2> p2(3.0, 5.0);\n\t\tFrameT<double, 2> f2(p2, d);\n\t\tCHECK(IsEqual(f1.Translated(v), f2));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, typename OtherScalar2> [[nodiscard]] FrameT Scaled(const PointT<OtherScalar, DIM>& point, const OtherScalar2& scale),\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\n#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n;\n\tSECTION(\"Scale 2D\") {\n\t\tPointT<double, 2> p(1.0, 2.0);\n\t\tDirectionT<double, 2> d(1.0, 3.0);\n\t\tFrameT<double, 2> f1(p, d);\n\t\tPointT<double, 2> p2(2.0, 3.0);\n\t\tPointT<double, 2> p3(0.5, 1.5);\n\t\tFrameT<double, 2> f2(p3, d);\n\t\tCHECK(IsEqual(f1.Scaled(p2, 1.5), f2));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, typename OtherScalar2, int DIM2 = DIM, typename = typename std::enable_if_t<DIM2 == 2>> [[nodiscard]] FrameT Rotated(const PointT<OtherScalar, DIM>& point, const OtherScalar2& angle),\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\n#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n;\n\tSECTION(\"Construction 2D\") {\n\t\tPointT<double, 2> p(0.0, 0.0);\n\t\tDirectionT<double, 2> dx(1.0, 0.0);\n\t\tDirectionT<double, 2> dy(0.0, 1.0);\n\t\tFrameT<double, 2> f1;\n\t\tFrameT<double, 2> f2(p, dx, dy);\n\t\tCHECK(IsEqual(f1, f2));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar> [[nodiscard]] FrameT Mirrored(const AxisT<OtherScalar, DIM>& a),\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\n#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n;\n\tSECTION(\"Mirror point 2D\") {\n\t\tPointT<double, 2> p(1.0, 2.0);\n\t\tDirectionT<double, 2> d(1.0, 3.0);\n\t\tFrameT<double, 2> f1(p, d);\n\t\tPointT<double, 2> p2(2.0, 3.0);\n\t\tPointT<double, 2> p3(3.0, 4.0);\n\t\tDirectionT<double, 2> d2(-1.0, -3.0);\n\t\tFrameT<double, 2> f2(p3, d2);\n\t\tCHECK(IsEqual(f1.Mirrored(p2), f2));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar> [[nodiscard]] FrameT Mirrored(const PointT<OtherScalar, DIM>& point),\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\n#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n;\n\tSECTION(\"Mirror point 2D\") {\n\t\tPointT<double, 2> p(1.0, 2.0);\n\t\tDirectionT<double, 2> d(1.0, 3.0);\n\t\tFrameT<double, 2> f1(p, d);\n\t\tPointT<double, 2> p2(2.0, 3.0);\n\t\tPointT<double, 2> p3(3.0, 4.0);\n\t\tDirectionT<double, 2> d2(-1.0, -3.0);\n\t\tFrameT<double, 2> f2(p3, d2);\n\t\tCHECK(IsEqual(f1.Mirrored(p2), f2));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar> FrameT& Mirror(const AxisT<OtherScalar, DIM>& a),\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\n#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n;\n\tSECTION(\"Mirror point 2D\") {\n\t\tPointT<double, 2> p(1.0, 2.0);\n\t\tDirectionT<double, 2> d(1.0, 3.0);\n\t\tFrameT<double, 2> f1(p, d);\n\t\tPointT<double, 2> p2(2.0, 3.0);\n\t\tPointT<double, 2> p3(3.0, 4.0);\n\t\tDirectionT<double, 2> d2(-1.0, -3.0);\n\t\tFrameT<double, 2> f2(p3, d2);\n\t\tCHECK(IsEqual(f1.Mirrored(p2), f2));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar> FrameT& Mirror(const PointT<OtherScalar, DIM>& point),\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\n#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n;\n\tSECTION(\"Mirror point 2D\") {\n\t\tPointT<double, 2> p(1.0, 2.0);\n\t\tDirectionT<double, 2> d(1.0, 3.0);\n\t\tFrameT<double, 2> f1(p, d);\n\t\tPointT<double, 2> p2(2.0, 3.0);\n\t\tPointT<double, 2> p3(3.0, 4.0);\n\t\tDirectionT<double, 2> d2(-1.0, -3.0);\n\t\tFrameT<double, 2> f2(p3, d2);\n\t\tCHECK(IsEqual(f1.Mirrored(p2), f2));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<int DIM2 = DIM, typename = typename std::enable_if_t<DIM2 >= 2>> [[nodiscard]] const DirectionT<Scalar, DIM>& YDirection(),\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\n#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, int DIM2 = DIM, std::enable_if_t<DIM2 == 2, int> = 0> void SetYDirection(const DirectionT<OtherScalar, DIM>& y),\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\n#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n;\n\tSECTION(\"Construction 2D\") {\n\t\tPointT<double, 2> p(0.0, 0.0);\n\t\tDirectionT<double, 2> dx(1.0, 0.0);\n\t\tDirectionT<double, 2> dy(0.0, 1.0);\n\t\tFrameT<double, 2> f1;\n\t\tFrameT<double, 2> f2(p, dx, dy);\n\t\tCHECK(IsEqual(f1, f2));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, int DIM2 = DIM, std::enable_if_t<DIM2 == 2, int> = 0> void SetXDirection(const DirectionT<OtherScalar, DIM>& x),\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\n#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n;\n\tSECTION(\"SetXDirection 2D\") {\n\t\tPointT<double, 2> p(1.0, 2.0);\n\t\tDirectionT<double, 2> dx(1.0, 3.0);\n\t\tFrameT<double, 2> f1(p, dx);\n\t\tDirectionT<double, 2> dx2(-1.0, -2.0);\n\t\tFrameT<double, 2> f2(p, dx2);\n\t\tf2.SetXDirection(dx);\n\t\tCHECK(IsEqual(f1, f2));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, int DIM2 = DIM, std::enable_if_t<DIM2 == 2, int> = 0> void SetYAxis(const AxisT<OtherScalar, DIM>& axis),\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\n#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n;\n\tSECTION(\"SetYAxis 2D\") {\n\t\tPointT<double, 2> p(1.0, 2.0);\n\t\tPointT<double, 2> p2(3.0, 1.0);\n\t\tDirectionT<double, 2> dx(1.0, 3.0);\n\t\tDirectionT<double, 2> dy(-3.0, 1.0);\n\t\tFrameT<double, 2> f1(p, dx);\n\t\tDirectionT<double, 2> dx2(-1.0, -2.0);\n\t\tFrameT<double, 2> f2(p2, dx2);\n\t\tAxisT<double, 2> axis(p, dy);\n\t\tf2.SetYAxis(axis);\n\t\tCHECK(IsEqual(f1, f2));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, int DIM2 = DIM, std::enable_if_t<DIM2 == 2, int> = 0> void SetXAxis(const AxisT<OtherScalar, DIM>& axis),\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\n#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n;\n\tSECTION(\"SetXAxis 2D\") {\n\t\tPointT<double, 2> p(1.0, 2.0);\n\t\tPointT<double, 2> p2(3.0, 1.0);\n\t\tDirectionT<double, 2> dx(1.0, 3.0);\n\t\tFrameT<double, 2> f1(p, dx);\n\t\tDirectionT<double, 2> dx2(-1.0, -2.0);\n\t\tFrameT<double, 2> f2(p2, dx2);\n\t\tAxisT<double, 2> axis(p, dx);\n\t\tf2.SetXAxis(axis);\n\t\tCHECK(IsEqual(f1, f2));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, typename OtherScalar2, int DIM2 = DIM, std::enable_if_t<DIM2 == 3, int> = 0> FrameT(const PointT<OtherScalar, DIM>& point, const DirectionT<OtherScalar2, DIM>& dir),\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\n#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n;\n\tSECTION(\"Mirror point 2D\") {\n\t\tPointT<double, 2> p(1.0, 2.0);\n\t\tDirectionT<double, 2> d(1.0, 3.0);\n\t\tFrameT<double, 2> f1(p, d);\n\t\tPointT<double, 2> p2(2.0, 3.0);\n\t\tPointT<double, 2> p3(3.0, 4.0);\n\t\tDirectionT<double, 2> d2(-1.0, -3.0);\n\t\tFrameT<double, 2> f2(p3, d2);\n\t\tCHECK(IsEqual(f1.Mirrored(p2), f2));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, int DIM2 = DIM, std::enable_if_t<DIM2 == 2, int> = 0> explicit FrameT(const AxisT<OtherScalar, DIM>& axis, bool isright = true),\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\n#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n;\n\tSECTION(\"Construction 2D\") {\n\t\tPointT<double, 2> p(0.0, 0.0);\n\t\tDirectionT<double, 2> dx(1.0, 0.0);\n\t\tDirectionT<double, 2> dy(0.0, 1.0);\n\t\tFrameT<double, 2> f1;\n\t\tFrameT<double, 2> f2(p, dx, dy);\n\t\tCHECK(IsEqual(f1, f2));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, typename OtherScalar2, int DIM2 = DIM, std::enable_if_t<DIM2 == 2, int> = 0> FrameT(const PointT<OtherScalar, DIM>& point, const DirectionT<OtherScalar2, DIM>& xdir, bool isright = true),\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\n#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n;\n\tSECTION(\"Construction 2D\") {\n\t\tPointT<double, 2> p(0.0, 0.0);\n\t\tDirectionT<double, 2> dx(1.0, 0.0);\n\t\tDirectionT<double, 2> dy(0.0, 1.0);\n\t\tFrameT<double, 2> f1;\n\t\tFrameT<double, 2> f2(p, dx, dy);\n\t\tCHECK(IsEqual(f1, f2));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, typename OtherScalar2, typename OtherScalar3, int DIM2 = DIM, std::enable_if_t<DIM2 == 2, int> = 0> FrameT(const PointT<OtherScalar, DIM>& point, const DirectionT<OtherScalar2, DIM>& xdir, const DirectionT<OtherScalar3, DIM>& ydir),\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\n#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n;\n\tSECTION(\"Construction 2D\") {\n\t\tPointT<double, 2> p(0.0, 0.0);\n\t\tDirectionT<double, 2> dx(1.0, 0.0);\n\t\tDirectionT<double, 2> dy(0.0, 1.0);\n\t\tFrameT<double, 2> f1;\n\t\tFrameT<double, 2> f2(p, dx, dy);\n\t\tCHECK(IsEqual(f1, f2));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] const PointT<Scalar, DIM>& Location()\t @return The location\n\t @brief Get the location\n,\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\n#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n;\n\tSECTION(\"SetYAxis 2D\") {\n\t\tPointT<double, 2> p(1.0, 2.0);\n\t\tPointT<double, 2> p2(3.0, 1.0);\n\t\tDirectionT<double, 2> dx(1.0, 3.0);\n\t\tDirectionT<double, 2> dy(-3.0, 1.0);\n\t\tFrameT<double, 2> f1(p, dx);\n\t\tDirectionT<double, 2> dx2(-1.0, -2.0);\n\t\tFrameT<double, 2> f2(p2, dx2);\n\t\tAxisT<double, 2> axis(p, dy);\n\t\tf2.SetYAxis(axis);\n\t\tCHECK(IsEqual(f1, f2));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, typename OtherScalar2> [[nodiscard]] AxisT Translated(const PointT<OtherScalar, DIM>& p1, const PointT<OtherScalar2, DIM>& p2),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected){\n\treturn result.Location().IsEqual(expected.Location(), tol) &&\n\t\tresult.Direction().IsEqual(expected.Direction(), tol);\n}\n#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected){\n\treturn result.Location().IsEqual(expected.Location(), tol) &&\n\t\tresult.Direction().IsEqual(expected.Direction(), tol);\n;\n\tSECTION(\"Translate(p1, p2) 3D\"){\n\t\tAxisT<double, 3> a1(PointT<double, 3>(1.0, 2.0, 3.0), DirectionT<double, 3>{1.0, 2.0, 3.0});\n\t\tPointT<double, 3> p1(2.0, 3.0, 4.0);\n\t\tPointT<double, 3> p2(4.0, 2.0, 3.0);\n\t\tAxisT<double, 3> a2(PointT<double, 3>(3.0, 1.0, 2.0), DirectionT<double, 3>{1.0, 2.0, 3.0});\n\t\tCHECK(IsEqual(a1.Translated(p1, p2), a2));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, typename OtherScalar2> [[nodiscard]] AxisT Scaled(const PointT<OtherScalar, DIM> point, const OtherScalar2& scale),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected){\n\treturn result.Location().IsEqual(expected.Location(), tol) &&\n\t\tresult.Direction().IsEqual(expected.Direction(), tol);\n}\n#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected){\n\treturn result.Location().IsEqual(expected.Location(), tol) &&\n\t\tresult.Direction().IsEqual(expected.Direction(), tol);\n;\n\tSECTION(\"Scale 3D\"){\n\t\tAxisT<double, 3> a1(PointT<double, 3>{1.0, 2.0, 3.0}, DirectionT<double, 3>{1.0, 2.0, 3.0});\n\t\tPointT<double, 3> p(2.0, 3.0, 4.0);\n\t\tAxisT<double, 3> a2(PointT<double, 3>{0.5, 1.5, 2.5}, DirectionT<double, 3>{1.0, 2.0, 3.0});\n\t\tCHECK(IsEqual(a1.Scaled(p, 1.5), a2));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, int DIM2 = DIM, std::enable_if_t<DIM2 == 3, int> = 0> [[nodiscard]] AxisT Mirrored(const FrameT<OtherScalar, DIM>& frame),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected){\n\treturn result.Location().IsEqual(expected.Location(), tol) &&\n\t\tresult.Direction().IsEqual(expected.Direction(), tol);\n}\n#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected){\n\treturn result.Location().IsEqual(expected.Location(), tol) &&\n\t\tresult.Direction().IsEqual(expected.Direction(), tol);\n;\n\tSECTION(\"Mirror(axis) 3D\"){\n\t\tAxisT<double, 3> a1(PointT<double, 3>{1.0, 2.0, 3.0}, DirectionT<double, 3>{1.0, 2.0, 3.0});\n\t\tAxisT<double, 3> a2(PointT<double, 3>{2.0, 3.0, 4.0}, DirectionT<double, 3>{7.0, 3.0, 2.0});\n\t\tAxisT<double, 3> a3(PointT<double, 3>{9.0 / 31.0, 88.0 / 31.0, 131.0 / 31.0}, DirectionT<double, 3>{102.0 / 31.0, -5.0 / 31.0, -55.0 / 31.0});\n\t\tCHECK(IsEqual(a1.Mirrored(a2), a3));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar> [[nodiscard]] AxisT Mirrored(const AxisT<OtherScalar, DIM>& axis),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected){\n\treturn result.Location().IsEqual(expected.Location(), tol) &&\n\t\tresult.Direction().IsEqual(expected.Direction(), tol);\n}\n#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected){\n\treturn result.Location().IsEqual(expected.Location(), tol) &&\n\t\tresult.Direction().IsEqual(expected.Direction(), tol);\n;\n\tSECTION(\"Mirror(point) 3D\"){\n\t\tAxisT<double, 3> a1(PointT<double, 3>{1.0, 2.0, 3.0}, DirectionT<double, 3>{1.0, 1.0, 1.0});\n\t\tPointT<double, 3> p(2.0, 4.0, 5.0);\n\t\tAxisT<double, 3> a2(PointT<double, 3>{3.0, 6.0, 7.0}, DirectionT<double, 3>{-1.0, -1.0, -1.0});\n\t\tCHECK(IsEqual(a1.Mirrored(p), a2));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar> [[nodiscard]] AxisT Mirrored(const PointT<OtherScalar, DIM>& point),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected){\n\treturn result.Location().IsEqual(expected.Location(), tol) &&\n\t\tresult.Direction().IsEqual(expected.Direction(), tol);\n}\n#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected){\n\treturn result.Location().IsEqual(expected.Location(), tol) &&\n\t\tresult.Direction().IsEqual(expected.Direction(), tol);\n;\n\tSECTION(\"Mirror(point) 3D\"){\n\t\tAxisT<double, 3> a1(PointT<double, 3>{1.0, 2.0, 3.0}, DirectionT<double, 3>{1.0, 1.0, 1.0});\n\t\tPointT<double, 3> p(2.0, 4.0, 5.0);\n\t\tAxisT<double, 3> a2(PointT<double, 3>{3.0, 6.0, 7.0}, DirectionT<double, 3>{-1.0, -1.0, -1.0});\n\t\tCHECK(IsEqual(a1.Mirrored(p), a2));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, int DIM2 = DIM, std::enable_if_t<DIM2 == 3, int> = 0> AxisT& Mirror(const FrameT<OtherScalar, DIM>& frame),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected){\n\treturn result.Location().IsEqual(expected.Location(), tol) &&\n\t\tresult.Direction().IsEqual(expected.Direction(), tol);\n}\n#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected){\n\treturn result.Location().IsEqual(expected.Location(), tol) &&\n\t\tresult.Direction().IsEqual(expected.Direction(), tol);\n;\n\tSECTION(\"Mirror(frame) 3D\"){\n\t\tAxisT<double, 3> a1(PointT<double, 3>{1.0, 2.0, 3.0}, DirectionT<double, 3>{1.0, 2.0, 3.0});\n\t\tFrameT<double, 3> f(PointT<double, 3>{2.0, 3.0, 4.0}, DirectionT<double, 3>{7.0, 3.0, 2.0});\n\t\tAxisT<double, 3> a2(PointT<double, 3>{115.0 / 31.0, 98.0 / 31.0, 117.0 / 31.0}, DirectionT<double, 3>{-102.0 / 31.0, 5.0 / 31.0, 55.0 / 31.0});\n\t\tCHECK(IsEqual(a1.Mirror(f), a2));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar> AxisT& Mirror(const PointT<OtherScalar, DIM>& point),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected){\n\treturn result.Location().IsEqual(expected.Location(), tol) &&\n\t\tresult.Direction().IsEqual(expected.Direction(), tol);\n}\n#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected){\n\treturn result.Location().IsEqual(expected.Location(), tol) &&\n\t\tresult.Direction().IsEqual(expected.Direction(), tol);\n;\n\tSECTION(\"Mirror(point) 3D\"){\n\t\tAxisT<double, 3> a1(PointT<double, 3>{1.0, 2.0, 3.0}, DirectionT<double, 3>{1.0, 1.0, 1.0});\n\t\tPointT<double, 3> p(2.0, 4.0, 5.0);\n\t\tAxisT<double, 3> a2(PointT<double, 3>{3.0, 6.0, 7.0}, DirectionT<double, 3>{-1.0, -1.0, -1.0});\n\t\tCHECK(IsEqual(a1.Mirrored(p), a2));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar> [[nodiscard]] double Angle(const AxisT<OtherScalar, DIM>& other),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected){\n\treturn result.Location().IsEqual(expected.Location(), tol) &&\n\t\tresult.Direction().IsEqual(expected.Direction(), tol);\n}\n#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected){\n\treturn result.Location().IsEqual(expected.Location(), tol) &&\n\t\tresult.Direction().IsEqual(expected.Direction(), tol);\n;\n\tSECTION(\"Angle\"){\n\t\tAxisT<double, 3> a1(PointT<double, 3>{0.0, 0.0, 0.0}, DirectionT<double, 3>{1.0, 2.0, 1.0});\n\t\tAxisT<double, 3> a2(PointT<double, 3>{2.0, 4.0, 3.0}, DirectionT<double, 3>{-1.0, 1.0, -1.0});\n\t\tCHECK(a1.Angle(a2) == M_PI_2);\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, typename OtherScalar2, typename OtherScalar3, int DIM2 = DIM, std::enable_if_t<DIM2 == 3, int> = 0> [[nodiscard]] bool IsCoaxial(const AxisT<OtherScalar, DIM>& other, const OtherScalar2& angtol, const OtherScalar3& distol),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected){\n\treturn result.Location().IsEqual(expected.Location(), tol) &&\n\t\tresult.Direction().IsEqual(expected.Direction(), tol);\n}\n#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected){\n\treturn result.Location().IsEqual(expected.Location(), tol) &&\n\t\tresult.Direction().IsEqual(expected.Direction(), tol);\n;\n\tSECTION(\"IsCoaxial 3D\"){\n\t\tAxisT<double, 3> a1(PointT<double, 3>{0.0, 0.0, 0.0}, DirectionT<double, 3>{1.0, 2.0, 3.0});\n\t\tAxisT<double, 3> a2(PointT<double, 3>{2.0, 4.0, 6.0}, DirectionT<double, 3>{1.0, 2.0, 3.0});\n\t\tAxisT<double, 3> a3(PointT<double, 3>{2.0, 4.0, 6.0}, DirectionT<double, 3>{2.0, 2.0, 3.0});\n\t\tAxisT<double, 3> a4(PointT<double, 3>{1.0, 4.0, 6.0}, DirectionT<double, 3>{1.0, 2.0, 3.0});\n\t\tCHECK(a1.IsCoaxial(a2, 1e-6, 1e-6) == true);\n\t\tCHECK(a1.IsCoaxial(a3, 1e-6, 1e-6) == false);\n\t\tCHECK(a1.IsCoaxial(a4, 1e-6, 1e-6) == false);\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, typename OtherScalar2, typename OtherScalar3, int DIM2 = DIM, std::enable_if_t<DIM2 == 2, int> = 0> [[nodiscard]] bool IsCoaxial(const AxisT<OtherScalar, DIM>& other, const OtherScalar2& angtol, const OtherScalar3& distol),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected){\n\treturn result.Location().IsEqual(expected.Location(), tol) &&\n\t\tresult.Direction().IsEqual(expected.Direction(), tol);\n}\n#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected){\n\treturn result.Location().IsEqual(expected.Location(), tol) &&\n\t\tresult.Direction().IsEqual(expected.Direction(), tol);\n;\n\tSECTION(\"IsCoaxial 3D\"){\n\t\tAxisT<double, 3> a1(PointT<double, 3>{0.0, 0.0, 0.0}, DirectionT<double, 3>{1.0, 2.0, 3.0});\n\t\tAxisT<double, 3> a2(PointT<double, 3>{2.0, 4.0, 6.0}, DirectionT<double, 3>{1.0, 2.0, 3.0});\n\t\tAxisT<double, 3> a3(PointT<double, 3>{2.0, 4.0, 6.0}, DirectionT<double, 3>{2.0, 2.0, 3.0});\n\t\tAxisT<double, 3> a4(PointT<double, 3>{1.0, 4.0, 6.0}, DirectionT<double, 3>{1.0, 2.0, 3.0});\n\t\tCHECK(a1.IsCoaxial(a2, 1e-6, 1e-6) == true);\n\t\tCHECK(a1.IsCoaxial(a3, 1e-6, 1e-6) == false);\n\t\tCHECK(a1.IsCoaxial(a4, 1e-6, 1e-6) == false);\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar> void SetDirection(const DirectionT<OtherScalar, DIM>& dir),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected){\n\treturn result.Location().IsEqual(expected.Location(), tol) &&\n\t\tresult.Direction().IsEqual(expected.Direction(), tol);\n}\n#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected){\n\treturn result.Location().IsEqual(expected.Location(), tol) &&\n\t\tresult.Direction().IsEqual(expected.Direction(), tol);\n;\n\tSECTION(\"SetDirection\"){\n\t\tAxisT<double, 3> a1;\n\t\tDirectionT<double, 3> d(1.0, 2.0, 3.0);\n\t\ta1.SetDirection(d);\n\t\tAxisT<double, 3> a2(PointT<double, 3>{0.0, 0.0, 0.0}, d);\n\t\tCHECK(IsEqual(a1, a2));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, typename OtherScalar2> AxisT(const PointT<OtherScalar, DIM>& point, const DirectionT<OtherScalar2, DIM>& dir),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected){\n\treturn result.Location().IsEqual(expected.Location(), tol) &&\n\t\tresult.Direction().IsEqual(expected.Direction(), tol);\n}\n#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected){\n\treturn result.Location().IsEqual(expected.Location(), tol) &&\n\t\tresult.Direction().IsEqual(expected.Direction(), tol);\n;\n\tSECTION(\"Translate(p1, p2) 3D\"){\n\t\tAxisT<double, 3> a1(PointT<double, 3>(1.0, 2.0, 3.0), DirectionT<double, 3>{1.0, 2.0, 3.0});\n\t\tPointT<double, 3> p1(2.0, 3.0, 4.0);\n\t\tPointT<double, 3> p2(4.0, 2.0, 3.0);\n\t\tAxisT<double, 3> a2(PointT<double, 3>(3.0, 1.0, 2.0), DirectionT<double, 3>{1.0, 2.0, 3.0});\n\t\tCHECK(IsEqual(a1.Translated(p1, p2), a2));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AxisT()\t @details The default location is (0, 0, 0). In 2D, the default direction is (1, 0); in 3D, the default direction is (0, 0, 1).\n\t @brief Default constructor\n,\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected){\n\treturn result.Location().IsEqual(expected.Location(), tol) &&\n\t\tresult.Direction().IsEqual(expected.Direction(), tol);\n}\n#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected){\n\treturn result.Location().IsEqual(expected.Location(), tol) &&\n\t\tresult.Direction().IsEqual(expected.Direction(), tol);\n;\n\tSECTION(\"default constructor 3D\"){\n\t\tAxisT<double, 3> a1;\n\t\tAxisT<double, 3> a2(PointT<double, 3>{0.0, 0.0, 0.0}, DirectionT<double, 3>{0.0, 0.0, 1.0});\n\t\tCHECK(IsEqual(a1, a2));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, typename OtherScalar2> [[nodiscard]] AxisT Translated(const PointT<OtherScalar, DIM>& p1, const PointT<OtherScalar2, DIM>& p2),\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {\n\treturn result.Location().IsEqual(expected.Location(), tol) &&\n\t\tresult.Direction().IsEqual(expected.Direction(), tol);\n}\n#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {\n\treturn result.Location().IsEqual(expected.Location(), tol) &&\n\t\tresult.Direction().IsEqual(expected.Direction(), tol);\n;\n\tSECTION(\"Translate(p1, p2) 2D\") {\n\t\tAxisT<double, 2> a1(PointT<double, 2>(1.0, 2.0), DirectionT<double, 2>{1.0, 2.0});\n\t\tPointT<double, 2> p1(2.0, 3.0);\n\t\tPointT<double, 2> p2(4.0, 2.0);\n\t\tAxisT<double, 2> a2(PointT<double, 2>(3.0, 1.0), DirectionT<double, 2>{1.0, 2.0});\n\t\tCHECK(IsEqual(a1.Translated(p1, p2), a2));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar> [[nodiscard]] AxisT Translated(const VectorT<OtherScalar, DIM>& vec),\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {\n\treturn result.Location().IsEqual(expected.Location(), tol) &&\n\t\tresult.Direction().IsEqual(expected.Direction(), tol);\n}\n#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {\n\treturn result.Location().IsEqual(expected.Location(), tol) &&\n\t\tresult.Direction().IsEqual(expected.Direction(), tol);\n;\n\tSECTION(\"Translate(vec) 2D\") {\n\t\tAxisT<double, 2> a1(PointT<double, 2>(1.0, 2.0), DirectionT<double, 2>{1.0, 2.0});\n\t\tVectorT<double, 2> v(2.0, 3.0);\n\t\tAxisT<double, 2> a2(PointT<double, 2>(3.0, 5.0), DirectionT<double, 2>{1.0, 2.0});\n\t\tCHECK(IsEqual(a1.Translated(v), a2));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, typename OtherScalar2, int DIM2 = DIM, typename = typename std::enable_if_t<DIM2 == 2>> [[nodiscard]] AxisT Rotated(const PointT<OtherScalar, DIM>& point, const OtherScalar2& angle),\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {\n\treturn result.Location().IsEqual(expected.Location(), tol) &&\n\t\tresult.Direction().IsEqual(expected.Direction(), tol);\n}\n#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {\n\treturn result.Location().IsEqual(expected.Location(), tol) &&\n\t\tresult.Direction().IsEqual(expected.Direction(), tol);\n;\n\tSECTION(\"Rotate 2D\") {\n\t\tAxisT<double, 2> a1(PointT<double, 2>{1.0, 2.0}, DirectionT<double, 2>{1.0, 2.0});\n\t\tPointT<double, 2> p(2.0, 3.0);\n\t\tAxisT<double, 2> a2(PointT<double, 2>{3.0, 2.0}, DirectionT<double, 2>{-2.0, 1.0});\n\t\tCHECK(IsEqual(a1.Rotated(p, M_PI_2), a2));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar> [[nodiscard]] AxisT Mirrored(const AxisT<OtherScalar, DIM>& axis),\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {\n\treturn result.Location().IsEqual(expected.Location(), tol) &&\n\t\tresult.Direction().IsEqual(expected.Direction(), tol);\n}\n#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {\n\treturn result.Location().IsEqual(expected.Location(), tol) &&\n\t\tresult.Direction().IsEqual(expected.Direction(), tol);\n;\n\tSECTION(\"Mirror(point) 2D\") {\n\t\tAxisT<double, 2> a1(PointT<double, 2>{1.0, 2.0}, DirectionT<double, 2>{1.0, 1.0});\n\t\tPointT<double, 2> p(3.0, 4.0);\n\t\tAxisT<double, 2> a2(PointT<double, 2>{5.0, 6.0}, DirectionT<double, 2>{-1.0, -1.0});\n\t\tCHECK(IsEqual(a1.Mirrored(p), a2));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar> [[nodiscard]] AxisT Mirrored(const PointT<OtherScalar, DIM>& point),\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {\n\treturn result.Location().IsEqual(expected.Location(), tol) &&\n\t\tresult.Direction().IsEqual(expected.Direction(), tol);\n}\n#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {\n\treturn result.Location().IsEqual(expected.Location(), tol) &&\n\t\tresult.Direction().IsEqual(expected.Direction(), tol);\n;\n\tSECTION(\"Mirror(axis) 2D\") {\n\t\tAxisT<double, 2> a1(PointT<double, 2>{1.0, 2.0}, DirectionT<double, 2>{1.0, 2.0});\n\t\tAxisT<double, 2> a2(PointT<double, 2>{2.0, 2.0}, DirectionT<double, 2>{1.0, 1.0});\n\t\tAxisT<double, 2> a3(PointT<double, 2>{2.0, 1.0}, DirectionT<double, 2>{2.0, 1.0});\n\t\tCHECK(IsEqual(a1.Mirrored(a2), a3));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar> AxisT& Mirror(const PointT<OtherScalar, DIM>& point),\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {\n\treturn result.Location().IsEqual(expected.Location(), tol) &&\n\t\tresult.Direction().IsEqual(expected.Direction(), tol);\n}\n#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {\n\treturn result.Location().IsEqual(expected.Location(), tol) &&\n\t\tresult.Direction().IsEqual(expected.Direction(), tol);\n;\n\tSECTION(\"Mirror(point) 2D\") {\n\t\tAxisT<double, 2> a1(PointT<double, 2>{1.0, 2.0}, DirectionT<double, 2>{1.0, 1.0});\n\t\tPointT<double, 2> p(3.0, 4.0);\n\t\tAxisT<double, 2> a2(PointT<double, 2>{5.0, 6.0}, DirectionT<double, 2>{-1.0, -1.0});\n\t\tCHECK(IsEqual(a1.Mirrored(p), a2));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, typename OtherScalar2, typename OtherScalar3, int DIM2 = DIM, std::enable_if_t<DIM2 == 2, int> = 0> [[nodiscard]] bool IsCoaxial(const AxisT<OtherScalar, DIM>& other, const OtherScalar2& angtol, const OtherScalar3& distol),\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {\n\treturn result.Location().IsEqual(expected.Location(), tol) &&\n\t\tresult.Direction().IsEqual(expected.Direction(), tol);\n}\n#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {\n\treturn result.Location().IsEqual(expected.Location(), tol) &&\n\t\tresult.Direction().IsEqual(expected.Direction(), tol);\n;\n\tSECTION(\"IsCoaxial 2D\") {\n\t\tAxisT<double, 2> a1(PointT<double, 2>{0.0, 0.0}, DirectionT<double, 2>{1.0, 2.0});\n\t\tAxisT<double, 2> a2(PointT<double, 2>{2.0, 4.0}, DirectionT<double, 2>{1.0, 2.0});\n\t\tAxisT<double, 2> a3(PointT<double, 2>{2.0, 4.0}, DirectionT<double, 2>{2.0, 2.0});\n\t\tAxisT<double, 2> a4(PointT<double, 2>{1.0, 4.0}, DirectionT<double, 2>{1.0, 2.0});\n\t\tCHECK(a1.IsCoaxial(a2, 1e-6, 1e-6) == true);\n\t\tCHECK(a1.IsCoaxial(a3, 1e-6, 1e-6) == false);\n\t\tCHECK(a1.IsCoaxial(a4, 1e-6, 1e-6) == false);\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, typename OtherScalar2> AxisT(const PointT<OtherScalar, DIM>& point, const DirectionT<OtherScalar2, DIM>& dir),\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {\n\treturn result.Location().IsEqual(expected.Location(), tol) &&\n\t\tresult.Direction().IsEqual(expected.Direction(), tol);\n}\n#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {\n\treturn result.Location().IsEqual(expected.Location(), tol) &&\n\t\tresult.Direction().IsEqual(expected.Direction(), tol);\n;\n\tSECTION(\"Rotate 2D\") {\n\t\tAxisT<double, 2> a1(PointT<double, 2>{1.0, 2.0}, DirectionT<double, 2>{1.0, 2.0});\n\t\tPointT<double, 2> p(2.0, 3.0);\n\t\tAxisT<double, 2> a2(PointT<double, 2>{3.0, 2.0}, DirectionT<double, 2>{-2.0, 1.0});\n\t\tCHECK(IsEqual(a1.Rotated(p, M_PI_2), a2));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API void SimplifyResult(bool isUnfiyEdges = true, bool isUnifyFaces = true, double angularTol = Precision::Angular()\t @param angularTol The angular tolerance for checking parallel\n\t @param isUnifyFaces Set whether unify faces\n\t @param isUnfiyEdges Set whether unify edges\n\t @brief Simplify the boolean result, remove redundant edges and faces\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <boolean/BoolBuilder.hpp>\n#include <modeling/MakeBox.hpp>\n#include <boolean/BoolBRepFuse.hpp>\n#include <common/IndexSet.hpp>\n#include <topology/TopoExplorerTool.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"case1: BoolBuilder added SimplifyResult() API at 3.6.0. \", \"[boolean][BoolBuilder][P1]\") {\n\tTopoShape box1 = MakeBox(Point3(0., 0., 0.), Point3(2., 2., 2.));\n\tTopoShape box2 = MakeBox(Point3(1., 1., 0.), Point3(3., 3., 2.));\n\tBoolBRepFuse fuse(box1, box2);\n\tTopoShape shape1 = fuse.Shape();\n\tfuse.SimplifyResult();\n\tTopoShape shape2 = fuse.Shape();\n\tIndexSet<TopoShape> shape1Faces, shape2Faces;\n\tTopoExplorerTool::MapShapes(shape1, ShapeType::Face, shape1Faces);\n\tTopoExplorerTool::MapShapes(shape2, ShapeType::Face, shape2Faces);\n\tstd::cout << shape1Faces.size() << \"  \" << shape2Faces.size() << std::endl;\n\tCHECK(shape1Faces.size() == 14);\n\tCHECK(shape2Faces.size() == 10);\n}\n#include<catch.hpp>\n#include<testHelper.h>\n#include <boolean/BoolBuilder.hpp>\n#include <modeling/MakeBox.hpp>\n#include <boolean/BoolBRepFuse.hpp>\n#include <common/IndexSet.hpp>\n#include <topology/TopoExplorerTool.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"case1: BoolBuilder added SimplifyResult() API at 3.6.0. \", \"[boolean][BoolBuilder][P1]\") {\n\tTopoShape box1 = MakeBox(Point3(0., 0., 0.), Point3(2., 2., 2.));\n\tTopoShape box2 = MakeBox(Point3(1., 1., 0.), Point3(3., 3., 2.));\n\tBoolBRepFuse fuse(box1, box2);\n\tTopoShape shape1 = fuse.Shape();\n\tfuse.SimplifyResult();\n\tTopoShape shape2 = fuse.Shape();\n\tIndexSet<TopoShape> shape1Faces, shape2Faces;\n\tTopoExplorerTool::MapShapes(shape1, ShapeType::Face, shape1Faces);\n\tTopoExplorerTool::MapShapes(shape2, ShapeType::Face, shape2Faces);\n\tstd::cout << shape1Faces.size() << \"  \" << shape2Faces.size() << std::endl;\n\tCHECK(shape1Faces.size() == 14);\n\tCHECK(shape2Faces.size() == 10);\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API BoolBRepSection(const std::shared_ptr<Geom3Surface>& s1, const std::shared_ptr<Geom3Surface>& s2, bool perfomNow = true)\t @param perfomNow If true, the operation is performed immediately; if false, the Build() function has to be called manually\n\t @param s2 The tool surface\n\t @param s1 The argument surface\n\t @brief Special case: compute the section of two surfaces\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <boolean/BoolBRepSection.hpp>\n#include <common/CartesianCoordinateSystem.hpp>\n#include <math/LineT.hpp>\n#include <modeling/MakePrism.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeFace.hpp>\n#include <geometry/Geom3BezierCurve.hpp>\n#include <modeling/MakeRevol.hpp>\n#include <geometry/Geom3CylindricalSurface.hpp>\n#include <topology/TopoTool.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"bug1: BoolBRepSection \", \"[boolean][BoolBRepSection][fixbug]\")\n{\n\tLine3 line(CartesianCoordinateSystem::OZ());\n\tTopoShape infinitePlane1 = MakePrism(MakeEdge(line, 0.0, 1.0), Direction3(-1.0, 0.0, 0.0), false);\n\tTopoShape infinitePlane2 = MakePrism(MakeEdge(line, 0.0, 1.0), Direction3(1.0, 0.0, 0.0), false);\n\tTopoShape infinitePlane3 = MakePrism(MakeEdge(line, 0.0, 1.0), Direction3(0.0, 1.0, 0.0), false);\n\tTopoShape infinitePlane4 = MakePrism(MakeEdge(line, 0.0, 1.0), Direction3(0.0, -1.0, 0.0), false);\n\tstd::vector<Point3> poles{ Point3(1.0, 0.0, 0.0), Point3(0.8, 0.0, 0.5), Point3(1.0, 0.0, 1.0) };\n\tauto bz = std::make_shared<Geom3BezierCurve>(poles);\n\tTopoEdge e2 = MakeEdge(bz);\n\tTopoShape revolshape = MakeRevol(e2, CartesianCoordinateSystem::OZ());\n\tauto surface1 = std::make_shared<Geom3CylindricalSurface>(Frame3(), 1.0);\n\tauto surface2 = TopoTool::Surface(TopoCast::Face(revolshape));\n\tTopoShape result1 = BoolBRepSection(infinitePlane1, surface2); \n\tTopoShape result2 = BoolBRepSection(infinitePlane2, surface2); \n\tTopoShape result3 = BoolBRepSection(infinitePlane3, surface2); \n\tTopoShape result4 = BoolBRepSection(infinitePlane4, surface2); \n\tGlobalProperty prop1, prop2, prop3, prop4 ;\n\tCHECK( GetLinearProperties(result1, prop1, true, false) == Approx(1.0260606301));\n\tCHECK( GetLinearProperties(result2, prop1, true, false) == Approx(1.0260606301));\n\tCHECK( GetLinearProperties(result3, prop1, true, false) == Approx(1.0260606301));\n\tCHECK( GetLinearProperties(result4, prop1, true, false) == Approx(1.0260606301));\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API BoolBRepSection(const std::shared_ptr<Geom3Surface>& surface, const TopoShape& s2, bool perfomNow = true)\t @param perfomNow If true, the operation is performed immediately; if false, the Build() function has to be called manually\n\t @param s2 The tool shape\n\t @param surface The argument surface\n\t @brief Special case: compute the section of a surface and a shape\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <boolean/BoolBRepSection.hpp>\n#include <common/CartesianCoordinateSystem.hpp>\n#include <math/LineT.hpp>\n#include <modeling/MakePrism.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeFace.hpp>\n#include <geometry/Geom3BezierCurve.hpp>\n#include <modeling/MakeRevol.hpp>\n#include <geometry/Geom3CylindricalSurface.hpp>\n#include <topology/TopoTool.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"bug1: BoolBRepSection \", \"[boolean][BoolBRepSection][fixbug]\")\n{\n\tLine3 line(CartesianCoordinateSystem::OZ());\n\tTopoShape infinitePlane1 = MakePrism(MakeEdge(line, 0.0, 1.0), Direction3(-1.0, 0.0, 0.0), false);\n\tTopoShape infinitePlane2 = MakePrism(MakeEdge(line, 0.0, 1.0), Direction3(1.0, 0.0, 0.0), false);\n\tTopoShape infinitePlane3 = MakePrism(MakeEdge(line, 0.0, 1.0), Direction3(0.0, 1.0, 0.0), false);\n\tTopoShape infinitePlane4 = MakePrism(MakeEdge(line, 0.0, 1.0), Direction3(0.0, -1.0, 0.0), false);\n\tstd::vector<Point3> poles{ Point3(1.0, 0.0, 0.0), Point3(0.8, 0.0, 0.5), Point3(1.0, 0.0, 1.0) };\n\tauto bz = std::make_shared<Geom3BezierCurve>(poles);\n\tTopoEdge e2 = MakeEdge(bz);\n\tTopoShape revolshape = MakeRevol(e2, CartesianCoordinateSystem::OZ());\n\tauto surface1 = std::make_shared<Geom3CylindricalSurface>(Frame3(), 1.0);\n\tauto surface2 = TopoTool::Surface(TopoCast::Face(revolshape));\n\tTopoShape result1 = BoolBRepSection(infinitePlane1, surface2); \n\tTopoShape result2 = BoolBRepSection(infinitePlane2, surface2); \n\tTopoShape result3 = BoolBRepSection(infinitePlane3, surface2); \n\tTopoShape result4 = BoolBRepSection(infinitePlane4, surface2); \n\tGlobalProperty prop1, prop2, prop3, prop4 ;\n\tCHECK( GetLinearProperties(result1, prop1, true, false) == Approx(1.0260606301));\n\tCHECK( GetLinearProperties(result2, prop1, true, false) == Approx(1.0260606301));\n\tCHECK( GetLinearProperties(result3, prop1, true, false) == Approx(1.0260606301));\n\tCHECK( GetLinearProperties(result4, prop1, true, false) == Approx(1.0260606301));\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API BoolBRepSection(const TopoShape& s1, const std::shared_ptr<Geom3Surface>& surface, bool perfomNow = true)\t @param perfomNow If true, the operation is performed immediately; if false, the Build() function has to be called manually\n\t @param surface The tool surface\n\t @param s1 The argument shape\n\t @brief Special case: compute the section of a shape and a surface\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <boolean/BoolBRepSection.hpp>\n#include <common/CartesianCoordinateSystem.hpp>\n#include <math/LineT.hpp>\n#include <modeling/MakePrism.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeFace.hpp>\n#include <geometry/Geom3BezierCurve.hpp>\n#include <modeling/MakeRevol.hpp>\n#include <geometry/Geom3CylindricalSurface.hpp>\n#include <topology/TopoTool.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"bug1: BoolBRepSection \", \"[boolean][BoolBRepSection][fixbug]\")\n{\n\tLine3 line(CartesianCoordinateSystem::OZ());\n\tTopoShape infinitePlane1 = MakePrism(MakeEdge(line, 0.0, 1.0), Direction3(-1.0, 0.0, 0.0), false);\n\tTopoShape infinitePlane2 = MakePrism(MakeEdge(line, 0.0, 1.0), Direction3(1.0, 0.0, 0.0), false);\n\tTopoShape infinitePlane3 = MakePrism(MakeEdge(line, 0.0, 1.0), Direction3(0.0, 1.0, 0.0), false);\n\tTopoShape infinitePlane4 = MakePrism(MakeEdge(line, 0.0, 1.0), Direction3(0.0, -1.0, 0.0), false);\n\tstd::vector<Point3> poles{ Point3(1.0, 0.0, 0.0), Point3(0.8, 0.0, 0.5), Point3(1.0, 0.0, 1.0) };\n\tauto bz = std::make_shared<Geom3BezierCurve>(poles);\n\tTopoEdge e2 = MakeEdge(bz);\n\tTopoShape revolshape = MakeRevol(e2, CartesianCoordinateSystem::OZ());\n\tauto surface1 = std::make_shared<Geom3CylindricalSurface>(Frame3(), 1.0);\n\tauto surface2 = TopoTool::Surface(TopoCast::Face(revolshape));\n\tTopoShape result1 = BoolBRepSection(infinitePlane1, surface2); \n\tTopoShape result2 = BoolBRepSection(infinitePlane2, surface2); \n\tTopoShape result3 = BoolBRepSection(infinitePlane3, surface2); \n\tTopoShape result4 = BoolBRepSection(infinitePlane4, surface2); \n\tGlobalProperty prop1, prop2, prop3, prop4 ;\n\tCHECK( GetLinearProperties(result1, prop1, true, false) == Approx(1.0260606301));\n\tCHECK( GetLinearProperties(result2, prop1, true, false) == Approx(1.0260606301));\n\tCHECK( GetLinearProperties(result3, prop1, true, false) == Approx(1.0260606301));\n\tCHECK( GetLinearProperties(result4, prop1, true, false) == Approx(1.0260606301));\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API BoolBRepSection(const TopoShape& s1, const Plane& p1, bool perfomNow = true)\t @param perfomNow If true, the operation is performed immediately; if false, the Build() function has to be called manually\n\t @param p1 The tool plane\n\t @param s1 The argument shape\n\t @brief Special case: compute the section of a shape and an infinite plane\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <boolean/BoolBRepSection.hpp>\n#include <common/CartesianCoordinateSystem.hpp>\n#include <math/LineT.hpp>\n#include <modeling/MakePrism.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeFace.hpp>\n#include <geometry/Geom3BezierCurve.hpp>\n#include <modeling/MakeRevol.hpp>\n#include <geometry/Geom3CylindricalSurface.hpp>\n#include <topology/TopoTool.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"bug1: BoolBRepSection \", \"[boolean][BoolBRepSection][fixbug]\")\n{\n\tLine3 line(CartesianCoordinateSystem::OZ());\n\tTopoShape infinitePlane1 = MakePrism(MakeEdge(line, 0.0, 1.0), Direction3(-1.0, 0.0, 0.0), false);\n\tTopoShape infinitePlane2 = MakePrism(MakeEdge(line, 0.0, 1.0), Direction3(1.0, 0.0, 0.0), false);\n\tTopoShape infinitePlane3 = MakePrism(MakeEdge(line, 0.0, 1.0), Direction3(0.0, 1.0, 0.0), false);\n\tTopoShape infinitePlane4 = MakePrism(MakeEdge(line, 0.0, 1.0), Direction3(0.0, -1.0, 0.0), false);\n\tstd::vector<Point3> poles{ Point3(1.0, 0.0, 0.0), Point3(0.8, 0.0, 0.5), Point3(1.0, 0.0, 1.0) };\n\tauto bz = std::make_shared<Geom3BezierCurve>(poles);\n\tTopoEdge e2 = MakeEdge(bz);\n\tTopoShape revolshape = MakeRevol(e2, CartesianCoordinateSystem::OZ());\n\tauto surface1 = std::make_shared<Geom3CylindricalSurface>(Frame3(), 1.0);\n\tauto surface2 = TopoTool::Surface(TopoCast::Face(revolshape));\n\tTopoShape result1 = BoolBRepSection(infinitePlane1, surface2); \n\tTopoShape result2 = BoolBRepSection(infinitePlane2, surface2); \n\tTopoShape result3 = BoolBRepSection(infinitePlane3, surface2); \n\tTopoShape result4 = BoolBRepSection(infinitePlane4, surface2); \n\tGlobalProperty prop1, prop2, prop3, prop4 ;\n\tCHECK( GetLinearProperties(result1, prop1, true, false) == Approx(1.0260606301));\n\tCHECK( GetLinearProperties(result2, prop1, true, false) == Approx(1.0260606301));\n\tCHECK( GetLinearProperties(result3, prop1, true, false) == Approx(1.0260606301));\n\tCHECK( GetLinearProperties(result4, prop1, true, false) == Approx(1.0260606301));\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API BoolBRepSection(const TopoShape& s1, const TopoShape& s2, bool perfomNow = true)\t @param perfomNow If true, the operation is performed immediately; if false, the Build() function has to be called manually\n\t @param s2 The tool shape\n\t @param s1 The argument shape\n\t @brief Compute the section of two shapes\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <boolean/BoolBRepSection.hpp>\n#include <common/CartesianCoordinateSystem.hpp>\n#include <math/LineT.hpp>\n#include <modeling/MakePrism.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeFace.hpp>\n#include <geometry/Geom3BezierCurve.hpp>\n#include <modeling/MakeRevol.hpp>\n#include <geometry/Geom3CylindricalSurface.hpp>\n#include <topology/TopoTool.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"bug1: BoolBRepSection \", \"[boolean][BoolBRepSection][fixbug]\")\n{\n\tLine3 line(CartesianCoordinateSystem::OZ());\n\tTopoShape infinitePlane1 = MakePrism(MakeEdge(line, 0.0, 1.0), Direction3(-1.0, 0.0, 0.0), false);\n\tTopoShape infinitePlane2 = MakePrism(MakeEdge(line, 0.0, 1.0), Direction3(1.0, 0.0, 0.0), false);\n\tTopoShape infinitePlane3 = MakePrism(MakeEdge(line, 0.0, 1.0), Direction3(0.0, 1.0, 0.0), false);\n\tTopoShape infinitePlane4 = MakePrism(MakeEdge(line, 0.0, 1.0), Direction3(0.0, -1.0, 0.0), false);\n\tstd::vector<Point3> poles{ Point3(1.0, 0.0, 0.0), Point3(0.8, 0.0, 0.5), Point3(1.0, 0.0, 1.0) };\n\tauto bz = std::make_shared<Geom3BezierCurve>(poles);\n\tTopoEdge e2 = MakeEdge(bz);\n\tTopoShape revolshape = MakeRevol(e2, CartesianCoordinateSystem::OZ());\n\tauto surface1 = std::make_shared<Geom3CylindricalSurface>(Frame3(), 1.0);\n\tauto surface2 = TopoTool::Surface(TopoCast::Face(revolshape));\n\tTopoShape result1 = BoolBRepSection(infinitePlane1, surface2); \n\tTopoShape result2 = BoolBRepSection(infinitePlane2, surface2); \n\tTopoShape result3 = BoolBRepSection(infinitePlane3, surface2); \n\tTopoShape result4 = BoolBRepSection(infinitePlane4, surface2); \n\tGlobalProperty prop1, prop2, prop3, prop4 ;\n\tCHECK( GetLinearProperties(result1, prop1, true, false) == Approx(1.0260606301));\n\tCHECK( GetLinearProperties(result2, prop1, true, false) == Approx(1.0260606301));\n\tCHECK( GetLinearProperties(result3, prop1, true, false) == Approx(1.0260606301));\n\tCHECK( GetLinearProperties(result4, prop1, true, false) == Approx(1.0260606301));\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API BoolBRepSection()\t @details Only set the type of boolean operation to section\n\t @brief Default constructor\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <boolean/BoolBRepSection.hpp>\n#include <common/CartesianCoordinateSystem.hpp>\n#include <math/LineT.hpp>\n#include <modeling/MakePrism.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeFace.hpp>\n#include <geometry/Geom3BezierCurve.hpp>\n#include <modeling/MakeRevol.hpp>\n#include <geometry/Geom3CylindricalSurface.hpp>\n#include <topology/TopoTool.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"bug1: BoolBRepSection \", \"[boolean][BoolBRepSection][fixbug]\")\n{\n\tLine3 line(CartesianCoordinateSystem::OZ());\n\tTopoShape infinitePlane1 = MakePrism(MakeEdge(line, 0.0, 1.0), Direction3(-1.0, 0.0, 0.0), false);\n\tTopoShape infinitePlane2 = MakePrism(MakeEdge(line, 0.0, 1.0), Direction3(1.0, 0.0, 0.0), false);\n\tTopoShape infinitePlane3 = MakePrism(MakeEdge(line, 0.0, 1.0), Direction3(0.0, 1.0, 0.0), false);\n\tTopoShape infinitePlane4 = MakePrism(MakeEdge(line, 0.0, 1.0), Direction3(0.0, -1.0, 0.0), false);\n\tstd::vector<Point3> poles{ Point3(1.0, 0.0, 0.0), Point3(0.8, 0.0, 0.5), Point3(1.0, 0.0, 1.0) };\n\tauto bz = std::make_shared<Geom3BezierCurve>(poles);\n\tTopoEdge e2 = MakeEdge(bz);\n\tTopoShape revolshape = MakeRevol(e2, CartesianCoordinateSystem::OZ());\n\tauto surface1 = std::make_shared<Geom3CylindricalSurface>(Frame3(), 1.0);\n\tauto surface2 = TopoTool::Surface(TopoCast::Face(revolshape));\n\tTopoShape result1 = BoolBRepSection(infinitePlane1, surface2); \n\tTopoShape result2 = BoolBRepSection(infinitePlane2, surface2); \n\tTopoShape result3 = BoolBRepSection(infinitePlane3, surface2); \n\tTopoShape result4 = BoolBRepSection(infinitePlane4, surface2); \n\tGlobalProperty prop1, prop2, prop3, prop4 ;\n\tCHECK( GetLinearProperties(result1, prop1, true, false) == Approx(1.0260606301));\n\tCHECK( GetLinearProperties(result2, prop1, true, false) == Approx(1.0260606301));\n\tCHECK( GetLinearProperties(result3, prop1, true, false) == Approx(1.0260606301));\n\tCHECK( GetLinearProperties(result4, prop1, true, false) == Approx(1.0260606301));\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API BoolBRepFuse(const TopoShape& s1, const TopoShape& s2)\t @param s2 The tool shape\n\t @param s1 The argument shape\n\t @brief Compute the fuse of two shapes\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <boolean/BoolBRepFuse.hpp>\n#include <boolean/BoolBRepCut.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"bug1: BoolBRepFuse \", \"[boolean][BoolBRepFuse][fixbug]\")\n{\n\tTopoShape shape1, shape2;\n\tOCCTIO::OCCTTool::Read(shape1, INPUT_PATH_PREFIX\"boolean/part.brep\");\n\tOCCTIO::OCCTTool::Read(shape2, INPUT_PATH_PREFIX\"boolean/box.brep\");\n\tTopoShape result = BoolBRepFuse(shape1, shape2);\n\tCHECK(OCCTIO::OCCTTool::Write(result, OUTPUT_PATH_PREFIX\"testbug-view-556.brep\"));\n\tIndexSet<TopoShape> shapeFace, shapeEdge, shapeVertex ,shapeSolid;\n\tCHECK( GetTopoToolCount(result, AMCAX::ShapeType::Solid, shapeSolid)==1 );\n}\t\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API BoolBRepFuse()\t @details Only set the type of boolean operation to fuse\n\t @brief Default constructor\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <boolean/BoolBRepFuse.hpp>\n#include <boolean/BoolBRepCut.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"bug1: BoolBRepFuse \", \"[boolean][BoolBRepFuse][fixbug]\")\n{\n\tTopoShape shape1, shape2;\n\tOCCTIO::OCCTTool::Read(shape1, INPUT_PATH_PREFIX\"boolean/part.brep\");\n\tOCCTIO::OCCTTool::Read(shape2, INPUT_PATH_PREFIX\"boolean/box.brep\");\n\tTopoShape result = BoolBRepFuse(shape1, shape2);\n\tCHECK(OCCTIO::OCCTTool::Write(result, OUTPUT_PATH_PREFIX\"testbug-view-556.brep\"));\n\tIndexSet<TopoShape> shapeFace, shapeEdge, shapeVertex ,shapeSolid;\n\tCHECK( GetTopoToolCount(result, AMCAX::ShapeType::Solid, shapeSolid)==1 );\n}\t\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API BoolBRepCut(const TopoShape& s1, const TopoShape& s2, bool isForward = true)\t @param isForward Cut s1 by s2 if true, and cut s2 by s1 if false\n\t @param s2 The tool shape\n\t @param s1 The argument shape\n\t @brief Compute the cut operation of two shapes\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <boolean/BoolBRepCut.hpp>\n#include <modeling/MakeTorus.hpp>\n#include <modeling/MakeSphere.hpp>\n#include <modeling/MakeCone.hpp>\n#include <topology/TopoExplorer.hpp>\n#include <topology/TopoFace.hpp>\n#include <hatch/BRepClassificationTools.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"bug1: in Debug mode: BoolBuilder  \", \"[boolean][BoolBRepCut][P1][fixbug]\") {\n\tTopoShape torus = MakeTorus(Frame3(Point3(0.0, 0.0, 2.0), Direction3(1.0, 0.0, 0.0)), 4.0, 2.0);\n\tTopoShape sphere = MakeSphere(4.0);\n\tTopoShape result = BoolBRepCut(sphere, torus);\n\tAMCAX::GlobalProperty prop;\n\tAMCAX::BRepGlobalProperty::VolumeProperties(result, prop);\n\tCHECK(prop.Mass() == Approx(153.229)); \n\tbool isWriteSuccess = AMCAX::OCCTIO::OCCTTool::Write(result, OUTPUT_PATH_PREFIX\"BoolBRepCut_bug72.brep\", false);\n\tCHECK(isWriteSuccess == true);\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API BoolBRepCut()\t @details Only set the type of boolean operation to cut\n\t @brief Default constructor\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <boolean/BoolBRepCut.hpp>\n#include <modeling/MakeTorus.hpp>\n#include <modeling/MakeSphere.hpp>\n#include <modeling/MakeCone.hpp>\n#include <topology/TopoExplorer.hpp>\n#include <topology/TopoFace.hpp>\n#include <hatch/BRepClassificationTools.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"bug1: in Debug mode: BoolBuilder  \", \"[boolean][BoolBRepCut][P1][fixbug]\") {\n\tTopoShape torus = MakeTorus(Frame3(Point3(0.0, 0.0, 2.0), Direction3(1.0, 0.0, 0.0)), 4.0, 2.0);\n\tTopoShape sphere = MakeSphere(4.0);\n\tTopoShape result = BoolBRepCut(sphere, torus);\n\tAMCAX::GlobalProperty prop;\n\tAMCAX::BRepGlobalProperty::VolumeProperties(result, prop);\n\tCHECK(prop.Mass() == Approx(153.229)); \n\tbool isWriteSuccess = AMCAX::OCCTIO::OCCTTool::Write(result, OUTPUT_PATH_PREFIX\"BoolBRepCut_bug72.brep\", false);\n\tCHECK(isWriteSuccess == true);\n}\n}\n,{\n"
    }]
    