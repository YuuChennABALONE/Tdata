{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "void SetRadius(double r)	 @param r The radius
	 @brief Set the radius of the circle
",
 "output": "#include<catch.hpp>
#include<testHelper.h>
#include <geomAlgo/GccCircle3Tangent.hpp>
#include <geometry/Geom2Curve.hpp>
#include <geometry/MakeGeom2Line.hpp>
#include <geometry/MakeGeom2Circle.hpp>
#include <geomAlgo/GccEntity.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geomAlgo/GccQualifiedCurve.hpp>

TEST_CASE(\"SetRadius Test\") {
	CircleS circle;
	circle.SetRadius(5.0);
	CHECK(circle.Radius() == 5.0);
}"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[nodiscard]] double Radius()	 @return The radius
	 @brief Get the radius
",
 "output": "#include<catch.hpp>
#include<testHelper.h>
#include <geomAlgo/GccCircle3Tangent.hpp>
#include <geometry/Geom2Curve.hpp>
#include <geometry/MakeGeom2Line.hpp>
#include <geometry/MakeGeom2Circle.hpp>
#include <geomAlgo/GccEntity.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geomAlgo/GccQualifiedCurve.hpp>

TEST_CASE(\"Radius Test\") {
	CircleS circle;
	circle.SetRadius(3.0);
	CHECK(circle.Radius() == 3.0);
}"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] double Length()	 @return The length of the circle
	 @brief Get the length of the circle
",
 "output": "#include<catch.hpp>
#include<testHelper.h>
#include <geomAlgo/GccCircle3Tangent.hpp>
#include <geometry/Geom2Curve.hpp>
#include <geometry/MakeGeom2Line.hpp>
#include <geometry/MakeGeom2Circle.hpp>
#include <geomAlgo/GccEntity.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geomAlgo/GccQualifiedCurve.hpp>

TEST_CASE(\"Length Test\") {
	CircleS circle;
	circle.SetRadius(2.0);
	CHECK(circle.Length() == 2 * 3.14159);
}"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] double Distance(const PointT<double, DIM>& p)	 @return The distance from the point to the circle
	 @param p The point
	 @brief Compute the distance from a point to the circle
",
 "output": "#include<catch.hpp>
#include<testHelper.h>
#include <geomAlgo/GccCircle3Tangent.hpp>
#include <geometry/Geom2Curve.hpp>
#include <geometry/MakeGeom2Line.hpp>
#include <geometry/MakeGeom2Circle.hpp>
#include <geomAlgo/GccEntity.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geomAlgo/GccQualifiedCurve.hpp>

TEST_CASE(\"Distance Test\") {
	CircleS circle;
	circle.SetRadius(5.0);
	PointT<double, 2> point(0.0, 0.0);
	CHECK(circle.Distance(point) == 5.0);
}"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard] double SquaredDistance(const PointT<double, DIM>& p)	 @return The squared distance from the point to the circle
	 @param p The point
	 @brief Compute the squared distance from a point to the circle
",
 "output": "#include<catch.hpp>
#include<testHelper.h>
#include <geomAlgo/GccCircle3Tangent.hpp>
#include <geometry/Geom2Curve.hpp>
#include <geometry/MakeGeom2Line.hpp>
#include <geometry/MakeGeom2Circle.hpp>
#include <geomAlgo/GccEntity.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geomAlgo/GccQualifiedCurve.hpp>

TEST_CASE(\"SquaredDistance Test\") {
	CircleS circle;
	circle.SetRadius(3.0);
	PointT<double, 2> point(0.0, 0.0);
	CHECK(circle.SquaredDistance(point) == 9.0);
}"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "CircleS& Scale(const PointT<double, DIM>& p, double scale)	 @return The reference to self
	 @param scale The scale value
	 @param p The scaling center point
	 @brief Scale the circle by a center point
",
 "output": "#include<catch.hpp>
#include<testHelper.h>
#include <geomAlgo/GccCircle3Tangent.hpp>
#include <geometry/Geom2Curve.hpp>
#include <geometry/MakeGeom2Line.hpp>
#include <geometry/MakeGeom2Circle.hpp>
#include <geomAlgo/GccEntity.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geomAlgo/GccQualifiedCurve.hpp>

TEST_CASE(\"Scale Test\") {
	CircleS circle;
	circle.SetRadius(2.0);
	circle.Scale(PointT<double, 2>(1.0, 1.0), 2.0);
	CHECK(circle.Radius() == 4.0);
}"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "CircleS& Transform(const TransformationT<double, DIM>& tr)	 @return The reference to self
	 @param tr The transformation
	 @brief Transform the circle
",
 "output": "#include<catch.hpp>
#include<testHelper.h>
#include <geomAlgo/GccCircle3Tangent.hpp>
#include <geometry/Geom2Curve.hpp>
#include <geometry/MakeGeom2Line.hpp>
#include <geometry/MakeGeom2Circle.hpp>
#include <geomAlgo/GccEntity.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geomAlgo/GccQualifiedCurve.hpp>

TEST_CASE(\"Transform Test\") {
	CircleS circle;
	circle.SetRadius(2.0);
	TransformationT<double, 2> transformation; // assume this is defined
	circle.Transform(transformation);
	// Check some properties of the transformed circle
}"} {"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "void SetRadius(double r)	 @param r The radius
	 @brief Set the radius of the circle
",
 "output": "#include<catch.hpp>
#include<testHelper.h>

#include <common/VectorT.hpp>
#include <common/PointT.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/MakeArcOfCircle2d.hpp>
#include <sstream>

using namespace AMCAX;



TEST_CASE(\"bug1: MakeArcOfCircle2d http://192.168.2.72:8080/bug-view-63.html add 1 cases\", \"geomAlgo][MakeArcOfCircle2d][fixbug]\") 
	
	std::stringstream output;
	std::shared_ptr<Geom2TrimmedCurve> c = MakeArcOfCircle2d(Point2(0.0, 1.0), Vector2(1.0, 0.0), Point2(1.0, 0.0));
	std::cout << *c << std::endl;
	output << *c << std::endl;

	auto case1 = output.str();
	auto expect1 = \"8 4.71239 6.28319\";
	auto expect2 = \"2 0 -0 1 0 0 -1 1\";
	CHECK(case1.find(expect1) != std::string::npos);
	CHECK(case1.find(expect2) != std::string::npos);




"}
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] double Radius()	 @return The radius
	 @brief Get the radius
",
 "output": "#include<catch.hpp>
#include<testHelper.h>

#include <common/VectorT.hpp>
#include <common/PointT.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/MakeArcOfCircle2d.hpp>
#include <sstream>

using namespace AMCAX;



TEST_CASE(\"bug1: MakeArcOfCircle2d http://192.168.2.72:8080/bug-view-63.html add 1 cases\", \"[geomAlgo][MakeArcOfCircle2d][fixbug]\") 
	
	std::stringstream output;
	std::shared_ptr<Geom2TrimmedCurve> c = MakeArcOfCircle2d(Point2(0.0, 1.0), Vector2(1.0, 0.0), Point2(1.0, 0.0));
	std::cout << *c << std::endl;
	output << *c << std::endl;

	auto case1 = output.str();
	auto expect1 = \"8 4.71239 6.28319\";
	auto expect2 = \"2 0 -0 1 0 0 -1 1\";
	CHECK(case1.find(expect1) != std::string::npos);
	CHECK(case1.find(expect2) != std::string::npos);




"}
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] double Length()	 @return The length of the circle
	 @brief Get the length of the circle
",
 "output": "#include<catch.hpp>
#include<testHelper.h>

#include <common/VectorT.hpp>
#include <common/PointT.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/MakeArcOfCircle2d.hpp>
#include <sstream>

using namespace AMCAX;



TEST_CASE(\"bug1: MakeArcOfCircle2d http://192.168.2.72:8080/bug-view-63.html add 1 cases\", \"[geomAlgo][MakeArcOfCircle2d][fixbug]\") 
	
	std::stringstream output;
	std::shared_ptr<Geom2TrimmedCurve> c = MakeArcOfCircle2d(Point2(0.0, 1.0), Vector2(1.0, 0.0), Point2(1.0, 0.0));
	std::cout << *c << std::endl;
	output << *c << std::endl;

	auto case1 = output.str();
	auto expect1 = \"8 4.71239 6.28319\";
	auto expect2 = \"2 0 -0 1 0 0 -1 1\";
	CHECK(case1.find(expect1) != std::string::npos);
	CHECK(case1.find(expect2) != std::string::npos);




"}
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] double Distance(const PointT<double, DIM>& p)	 @return The distance from the point to the circle
	 @param p The point
	 @brief Compute the distance from a point to the circle
",
 "output": "#include<catch.hpp>
#include<testHelper.h>

#include <common/VectorT.hpp>
#include <common/PointT.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/MakeArcOfCircle2d.hpp>
#include <sstream>

using namespace AMCAX;



TEST_CASE(\"bug1: MakeArcOfCircle2d http://192.168.2.72:8080/bug-view-63.html add 1 cases\", \"[geomAlgo][MakeArcOfCircle2d][fixbug]\") 
	
	std::stringstream output;
	std::shared_ptr<Geom2TrimmedCurve> c = MakeArcOfCircle2d(Point2(0.0, 1.0), Vector2(1.0, 0.0), Point2(1.0, 0.0));
	std::cout << *c << std::endl;
	output << *c << std::endl;

	auto case1 = output.str();
	auto expect1 = \"8 4.71239 6.28319\";
	auto expect2 = \"2 0 -0 1 0 0 -1 1\";
	CHECK(case1.find(expect1) != std::string::npos);
	CHECK(case1.find(expect2) != std::string::npos);




"}
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] double SquaredDistance(const PointT<double, DIM>& p)	 @return The squared distance from the point to the circle
	 @param p The point
	 @brief Compute the squared distance from a point to the circle
",
 "output": "#include<catch.hpp>
#include<testHelper.h>

#include <common/VectorT.hpp>
#include <common/PointT.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/MakeArcOfCircle2d.hpp>
#include <sstream>

using namespace AMCAX;



TEST_CASE(\"bug1: MakeArcOfCircle2d http://192.168.2.72:8080/bug-view-63.html add 1 cases\", \"[geomAlgo][MakeArcOfCircle2d][fixbug]\") 
	
	std::stringstream output;
	std::shared_ptr<Geom2TrimmedCurve> c = MakeArcOfCircle2d(Point2(0.0, 1.0), Vector2(1.0, 0.0), Point2(1.0, 0.0));
	std::cout << *c << std::endl;
	output << *c << std::endl;

	auto case1 = output.str();
	auto expect1 = \"8 4.71239 6.28319\";
	auto expect2 = \"2 0 -0 1 0 0 -1 1\";
	CHECK(case1.find(expect1) != std::string::npos);
	CHECK(case1.find(expect2) != std::string::npos);




"}
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "CircleS& Scale(const PointT<double, DIM>& p, double scale)	 @return The reference to self
	 @param scale The scale value
	 @param p The scaling center point
	 @brief Scale the circle by a center point
",
 "output": "#include<catch.hpp>
#include<testHelper.h>

#include <common/VectorT.hpp>
#include <common/PointT.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/MakeArcOfCircle2d.hpp>
#include <sstream>

using namespace AMCAX;



TEST_CASE(\"bug1: MakeArcOfCircle2d http://192.168.2.72:8080/bug-view-63.html add 1 cases\", \"[geomAlgo][MakeArcOfCircle2d][fixbug]\") 
	
	std::stringstream output;
	std::shared_ptr<Geom2TrimmedCurve> c = MakeArcOfCircle2d(Point2(0.0, 1.0), Vector2(1.0, 0.0), Point2(1.0, 0.0));
	std::cout << *c << std::endl;
	output << *c << std::endl;

	auto case1 = output.str();
	auto expect1 = \"8 4.71239 6.28319\";
	auto expect2 = \"2 0 -0 1 0 0 -1 1\";
	CHECK(case1.find(expect1) != std::string::npos);
	CHECK(case1.find(expect2) != std::string::npos);




"}
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "CircleS& Transform(const TransformationT<double, DIM>& tr)	 @return The reference to self
	 @param tr The transformation
	 @brief Transform the circle
",
 "output": "#include<catch.hpp>
#include<testHelper.h>

#include <common/VectorT.hpp>
#include <common/PointT.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/MakeArcOfCircle2d.hpp>
#include <sstream>

using namespace AMCAX;



TEST_CASE(\"bug1: MakeArcOfCircle2d http://192.168.2.72:8080/bug-view-63.html add 1 cases\", \"[geomAlgo][MakeArcOfCircle2d][fixbug\") 
	
	std::stringstream output;
	std::shared_ptr<Geom2TrimmedCurve> c = MakeArcOfCircle2d(Point2(0.0, 1.0), Vector2(1.0, 0.0), Point2(1.0, 0.0));
	std::cout << *c << std::endl;
	output << *c << std::endl;

	auto case1 = output.str();
	auto expect1 = \"8 4.71239 6.28319\";
	auto expect2 = \"2 0 -0 1 0 0 -1 1\";
	CHECK(case1.find(expect1) != std::string::npos);
	CHECK(case1.find(expect2) != std::string::npos);




"}
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "void SetRadius(double r)	 @param r The radius
	 @brief Set the radius of the circle
",
 "output": "#include<catch.hpp>
#include \"testHelper.h\"
#include<iostream>
#include <math/CircleT.hpp>
#include <common/AxisT.hpp>
#include <common/PointT.hpp>

TEST_CASE(\"case1: create a Circle\", \"math][CircleT][P1]\") 

	AMCAX::Point2 P(0.0,0.0);
	AMCAX::Direction2 D(1.0,0.0);
	AMCAX::Axis2  axis2(P, D);
	float radius = 5.0f;
	AMCAX::Circle2 circle2(axis2, radius, true);
	CHECK(circle2.Area() == radius * radius * M_PI);
    double a, b, c, d, e, f;
    circle2.Coefficients(a, b, c, d, e, f);  //test Coefficients()
    ..."},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] double Radius()	 @return The radius
	 @brief Get the radius
",
 "output": "#include<catch.hpp>
#include \"testHelper.h\"
#include<iostream>
#include <math/CircleT.hpp>
#include <common/AxisT.hpp>
#include <common/PointT.hpp>

TEST_CASE(\"CircleT Constructor Test\", \"[math][CircleT][P1]\") 
    SECTION(\"2D Circle Construction\") 
        AMCAX::Circle2 circle2;
        constexpr double maxr = std::numeric_limits<double>::max();
        CHECK(circle2.Radius() == Approx(maxr).epsilon(1e-15));
        ..."},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] double Length()	 @return The length of the circle
	 @brief Get the length of the circle
",
 "output": "#include<catch.hpp>
#include \"testHelper.h\"
#include<iostream>
#include <math/CircleT.hpp>
#include <common/AxisT.hpp>
#include <common/PointT.hpp>

TEST_CASE(\"CircleT Area and Length Test\", \"[CircleT]\") 
    AMCAX::Circle2 circle2;
    circle2.SetRadius(5.0);
    CHECK(circle2.Area() == Approx(78.53982));
    CHECK(circle2.Length() == Approx(31.41593));
    ..."},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] double Distance(const PointT<double, DIM>& p)	 @return The distance from the point to the circle
	 @param p The point
	 @brief Compute the distance from a point to the circle
",
 "output": "#include<catch.hpp>
#include \"testHelper.h\"
#include<iostream>
#include <math/CircleT.hpp>
#include <common/AxisT.hpp>
#include <common/PointT.hpp>

TEST_CASE(\"case1: create a Circle with Distance\", \"[math][CircleT][P1]\") 
	AMCAX::Point2 P(0.0,0.0);
	AMCAX::Circle2 circle2;
	circle2.SetRadius(5.0);
	CHECK(circle2.Distance(P) == Approx(5.0).epsilon(1e-15));
    ..."},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] double SquaredDistance(const PointT<double, DIM>& p)	 @return The squared distance from the point to the circle
	 @param p The point
	 @brief Compute the squared distance from a point to the circle
",
 "output": "#include<catch.hpp>
#include \"testHelper.h\"
#include<iostream>
#include <math/CircleT.hpp>
#include <common/AxisT.hpp>
#include <common/PointT.hpp>

TEST_CASE(\"case1: create a Circle with Squared Distance\", \"[math][CircleT][P1]\") 
	AMCAX::Point2 P(0.0,0.0);
	AMCAX::Circle2 circle2;
	circle2.SetRadius(5.0);
	CHECK(circle2.SquaredDistance(P) == Approx(25.0).epsilon(1e-15));
    ..."},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "CircleS& Scale(const PointT<double, DIM>& p, double scale)	 @return The reference to self
	 @param scale The scale value
	 @param p The scaling center point
	 @brief Scale the circle by a center point
",
 "output": "#include<catch.hpp>
#include \"testHelper.h\"
#include<iostream>
#include <math/CircleT.hpp>
#include <common/AxisT.hpp>
#include <common/PointT.hpp>

TEST_CASE(\"case1: Scale Circle\", \"[math][CircleT][P1]\") 
	AMCAX::Circle2 circle;
	circle.SetRadius(5.0);
	AMCAX::Point2 center(0.0, 0.0);
	circle.Scale(center, 2.0);
	CHECK(circle.Radius() == Approx(10.0).epsilon(1e-15));
    ..."},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "CircleS& Transform(const TransformationT<double, DIM>& tr)	 @return The reference to self
	 @param tr The transformation
	 @brief Transform the circle
",
 "output": "#include<catch.hpp>
#include \"testHelper.h\"
#include<iostream>
#include <math/CircleT.hpp>
#include <common/AxisT.hpp>
#include <common/PointT.hpp>

TEST_CASE(\"case1: Transform Circle\", \"[math][CircleT][P1\") 
	AMCAX::Circle2 circle;
	circle.SetRadius(5.0);
	TransformationT<double, 2> transformation;
	circle.Transform(transformation);
	..."}
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "void SetRadius(double r)	 @param r The radius
	 @brief Set the radius of the circle
[nodiscard]] double Radius()	 @return The radius
	 @brief Get the radius
",
 "output": "#include <math/CircleT.hpp>
#include <common/CoordT.hpp>
#include <common/TransformationType.hpp>
#include <common/DirectionT.hpp>
#include <common/PointT.hpp>
#include <common/Precision.hpp>
#include <iostream>
#include \"catch.hpp\"

using namespace std;

TEST_CASE(\"TestCircle2D\", \"[math][Circle2D]\") {
	AMCAX::CircleT<double, 2> circle2D;
	circle2D.SetRadius(5.0);
	CHECK(circle2D.Radius() == 5.0);
}"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] double Length()	 @return The length of the circle
	 @brief Get the length of the circle
",
 "output": "#include <math/CircleT.hpp>
#include <common/CoordT.hpp>
#include <common/TransformationType.hpp>
#include <common/DirectionT.hpp>
#include <common/PointT.hpp>
#include <common/Precision.hpp>
#include <iostream>
#include \"catch.hpp\"

using namespace std;

TEST_CASE(\"TestCircleLength\", \"[math][Circle]\") {
	AMCAX::CircleT<double, 2> circle2D;
	circle2D.SetRadius(5.0);
	CHECK(circle2D.Length() == Approx(31.4159));
}"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] double Distance(const PointT<double, DIM>& p)	 @return The distance from the point to the circle
	 @param p The point
	 @brief Compute the distance from a point to the circle
",
 "output": "#include <math/CircleT.hpp>
#include <common/CoordT.hpp>
#include <common/TransformationType.hpp>
#include <common/DirectionT.hpp>
#include <common/PointT.hpp>
#include <common/Precision.hpp>
#include <iostream>
#include \"catch.hpp\"

using namespace std;

TEST_CASE(\"TestCircleDistance\", \"[math][Circle]\") {
	AMCAX::CircleT<double, 2> circle2D;
	AMCAX::PointT<double, 2> point(3.0, 4.0);
	circle2D.SetRadius(5.0);
	CHECK(circle2D.Distance(point) == Approx(1.0));
}"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] double SquaredDistance(const PointT<double, DIM>& p)	 @return The squared distance from the point to the circle
	 @param p The point
	 @brief Compute the squared distance from a point to the circle
",
 "output": "#include <math/CircleT.hpp>
#include <common/CoordT.hpp>
#include <common/TransformationType.hpp>
#include <common/DirectionT.hpp>
#include <common/PointT.hpp>
#include <common/Precision.hpp>
#include <iostream>
#include \"catch.hpp\"

using namespace std;

TEST_CASE(\"TestCircleSquaredDistance\", \"[math][Circle]\") {
	AMCAX::CircleT<double, 2> circle2D;
	AMCAX::PointT<double, 2> point(3.0, 4.0);
	circle2D.SetRadius(5.0);
	CHECK(circle2D.SquaredDistance(point) == Approx(1.0));
}"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "CircleS& Scale(const PointT<double, DIM>& p, double scale)	 @return The reference to self
	 @param scale The scale value
	 @param p The scaling center point
	 @brief Scale the circle by a center point
",
 "output": "#include <math/CircleT.hpp>
#include <common/CoordT.hpp>
#include <common/TransformationType.hpp>
#include <common/DirectionT.hpp>
#include <common/PointT.hpp>
#include <common/Precision.hpp>
#include <iostream>
#include \"catch.hpp\"

using namespace std;

TEST_CASE(\"TestCircleScale\", \"[math][Circle]\") {
	AMCAX::CircleT<double, 2> circle2D;
	AMCAX::PointT<double, 2> center(0.0, 0.0);
	circle2D.SetRadius(5.0);
	circle2D.Scale(center, 2.0);
	CHECK(circle2D.Radius() == Approx(10.0));
}"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "CircleS& Transform(const TransformationT<double, DIM>& tr)	 @return The reference to self
	 @param tr The transformation
	 @brief Transform the circle
",
 "output": "#include <math/CircleT.hpp>
#include <common/CoordT.hpp>
#include <common/TransformationType.hpp>
#include <common/DirectionT.hpp>
#include <common/PointT.hpp>
#include <common/Precision.hpp>
#include <iostream>
#include \"catch.hpp\"

using namespace std;

TEST_CASE(\"TestCircleTransform\", \"[math][Circle\") {
	AMCAX::CircleT<double, 2> circle2D;
	circle2D.SetRadius(5.0);
	TransformationT<double, 2> transform;
	circle2D.Transform(transform);
	// Add checks for transformed circle properties
}"}
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "AMCAX_API Classifier2d(const std::vector<Point2>& pts, double tolU, double tolV, double uMin, double vMin, double uMax, double vMax)	 @param vMax The upper bound of v
	 @param uMax The upper bound of u
	 @param vMin The lower bound of v
	 @param uMin The lower bound of u
	 @param tolV The tolerance of v bound
	 @param tolU The tolerance of u bound
	 @param pts The points of a 2D closed polygon, the last point does not required to repeat the first point
	 @details Require uMax > uMin, vMax > vMin, and at least 3 points
	 @brief Construct from a 2D polygon and uv-bounds",
 "output": "#include<catch.hpp>
#include<testHelper.h>

#include <common/PointT.hpp>
#include <math/Classifier2d.hpp>

using namespace AMCAX;

TEST_CASE(\"case1: Classifier2d \", \"math][Classifier2d][P1]\") 

    std::vector<Point2> pts = 
        Point2(2.0, 0.0),
        Point2(1.0, 1.0),
        Point2(2.0, 2.0),
        Point2(3.0, 2.0)
    ;

    double tolU = 0.1;
    double tolV = 0.1;
    double uMin = 0.0;
    double vMin = 0.0;
    double uMax = 2.5;
    double vMax = 1.5;

    Classifier2d classifier(pts, tolU, tolV, uMin, vMin, uMax, vMax);

    SECTION(\"IsInOut Point normal set\") 
        CHECK(classifier.IsInOut(Point2(0.0, 0.0)) == -1);
        CHECK(classifier.IsInOut(Point2(1.0, 1.0)) == 0);
        CHECK(classifier.IsInOut(Point2(2.0, 1.0)) == 1);
    

    SECTION(\"IsInOut Point normal set2 \") 
        CHECK(classifier.IsInOut(Point2(2.5, 1.9)) == -1);
        CHECK(classifier.IsInOut(Point2(1.5, 0.5)) == 0);
        CHECK(classifier.IsInOut(Point2(1.5, 1.0)) == 1);
        CHECK(classifier.IsInOut(Point2(2.0, 1.5)) == 1);
    

TEST_CASE(\"case2: Classifier2d \", \"[math][Classifier2d][P1]\") 

    std::vector<Point2> pts = 
        Point2(1.0, -2.0),
        Point2(1.0, 2.0),
        Point2(3.0, 1.0),
        Point2(3.0, -1.0)
    ;

    double tolU = 0.1;
    double tolV = 0.1;
    double uMin = 2.0;
    double vMin = -2.0;
    double uMax = 4.0;
    double vMax =  2.0;

    Classifier2d classifier(pts, tolU, tolV, uMin, vMin, uMax, vMax);

    SECTION(\"IsInOut Point normal set\") 
        CHECK(classifier.IsInOut(Point2(1.0, 2.0)) == -1);
        CHECK(classifier.IsInOut(Point2(1.5, 1.0)) == -1);
        CHECK(classifier.IsInOut(Point2(1.9, -1.6)) == 0);
        CHECK(classifier.IsInOut(Point2(2.5, -1.0)) == 1);
    

    SECTION(\"IsInOut Point normal set2 \") 
        CHECK(classifier.IsInOut(Point2(-0.5, -0.6)) == -1);
        CHECK(classifier.IsInOut(Point2(4.5, -0.4)) == -1);
        CHECK(classifier.IsInOut(Point2(3.0, -0.0)) == 0);
        CHECK(classifier.IsInOut(Point2(2.0,-0.0)) == 1);
        CHECK(classifier.IsInOut(Point2(2.8,-0.90)) == 1);
    

TEST_CASE(\"case3: Classifier2d \", \"[math][Classifier2d][P1\") 

    std::vector<Point2> pts = 
        Point2(2.0, 0.0),
        Point2(1.0, 1.0),
        Point2(2.0, 2.0),
        Point2(3.0, 2.0)
    ;

    double tolU = 0.1;
    double tolV = 0.1;
    double uMin = 0.0;
    double vMin = 0.0;
    double uMax = 2.5;
    double vMax = 1.5;

    Classifier2d classifier(pts, tolU, tolV, uMin, vMin, uMax, vMax);

    SECTION(\"IsInOutOn Point normal set\") 
        CHECK(classifier.IsInOutOn(Point2(0.0, 0.0), 0.0) == -1);
        CHECK(classifier.IsInOutOn(Point2(1.0, 1.0), 0.0) != 0);
        CHECK(classifier.IsInOutOn(Point2(1.0, 1.0), 1.0) == 0);
        CHECK(classifier.IsInOutOn(Point2(2.0, 1.0), 0.0) == 1);
    

    SECTION(\"IsInOutOn Point normal set2 \") 
        CHECK(classifier.IsInOutOn(Point2(2.5, 1.9), 0.3) == -1);
        CHECK(classifier.IsInOutOn(Point2(1.5, 0.5), 0.0) != 0);
        CHECK(classifier.IsInOutOn(Point2(1.5, 1.0), 1.0) == 1);
        CHECK(classifier.IsInOutOn(Point2(2.0, 1.5), 0.0) == 1);
    
"}
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[nodiscard]] AMCAX_API Point3 Apex()	 @return The apex point
	 @brief Get the apex of the cone",
 "output": "#include<iostream>
#include \"catch.hpp\"
#include <common/FrameT.hpp>
#include <modeling/MakeFace.hpp>
#include <common/AxisT.hpp>
#include <common/FrameT.hpp>
#include <common/VectorT.hpp>
#include <math/Cone.hpp>
using namespace AMCAX;
using namespace std;

TEST_CASE(\"TestCone\", \"[math][Cone]\")

	AMCAX::Frame3 frame;
	double radius = 5.0;
	double angle = M_PI / 4;
	AMCAX::Cone cone(frame, radius, angle);
	AMCAX::Point3 apex = cone.Apex();
	CHECK(apex.X() == 0.0);
	CHECK(apex.Y() == 0.0);
	CHECK(apex.Z() == Approx(-5.0));"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] AMCAX_API double SemiAngle()	 @return The semi-angle
	 @brief Get the semi-angle",
 "output": "#include<iostream>
#include \"catch.hpp\"
#include <common/FrameT.hpp>
#include <modeling/MakeFace.hpp>
#include <common/AxisT.hpp>
#include <common/FrameT.hpp>
#include <common/VectorT.hpp>
#include <math/Cone.hpp>
using namespace AMCAX;
using namespace std;

TEST_CASE(\"TestCone\", \"[math][Cone]\")

	AMCAX::Frame3 frame;
	double radius = 5.0;
	double angle = M_PI / 4;
	AMCAX::Cone cone(frame, radius, angle);
	double semiCone = cone.SemiAngle();
	CHECK(semiCone == Approx(0.785398));"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "Cone()	 @brief Default constructor",
 "output": "#include<iostream>
#include \"catch.hpp\"
#include <common/FrameT.hpp>
#include <modeling/MakeFace.hpp>
#include <common/AxisT.hpp>
#include <common/FrameT.hpp>
#include <common/VectorT.hpp>
#include <math/Cone.hpp>
using namespace AMCAX;
using namespace std;

TEST_CASE(\"TestCone\", \"[math][Cone]\")

	AMCAX::Frame3 frame;
	double radius = 5.0;
	double angle = M_PI / 4;
	AMCAX::Cone cone(frame, radius, angle);"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "AMCAX_API Cone(const Frame3& frame, double r, double angle)	 @param angle The semi-angle
	@param r The reference radius
	@param frame The local frame
	@brief Construct from a local frame, a reference radius and a semi-angle",
 "output": "#include<iostream>
#include \"catch.hpp\"
#include <common/FrameT.hpp>
#include <modeling/MakeFace.hpp>
#include <common/AxisT.hpp>
#include <common/FrameT.hpp>
#include <common/VectorT.hpp>
#include <math/Cone.hpp>
using namespace AMCAX;
using namespace std;

TEST_CASE(\"TestCone\", \"[math][Cone]\")

	AMCAX::Frame3 frame;
	double radius = 5.0;
	double angle = M_PI / 4;
	AMCAX::Cone cone(frame, radius, angle);"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "AMCAX_API Cone& Scale(const Point3& point, double scale)	 @return The reference to self
	@param scale The scale value
	@param point The scaling center point
	@brief Scale the cone by a point",
 "output": "#include<iostream>
#include \"catch.hpp\"
#include <common/FrameT.hpp>
#include <modeling/MakeFace.hpp>
#include <common/AxisT.hpp>
#include <common/FrameT.hpp>
#include <common/VectorT.hpp>
#include <math/Cone.hpp>
using namespace AMCAX;
using namespace std;

TEST_CASE(\"TestCone\", \"[math][Cone]\")

	AMCAX::Frame3 frame;
	double radius = 5.0;
	double angle = M_PI / 4;
	AMCAX::Cone cone(frame, radius, angle);
	double scaleCone = 2.0;
	cone.Scale(cone.Location(), scaleCone);"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "AMCAX_API Cone& Transform(const Transformation3& tr)	 @return The reference to self
	@param tr The transformation
	@brief Transform the cone",
 "output": "#include<iostream>
#include \"catch.hpp\"
#include <common/FrameT.hpp>
#include <modeling/MakeFace.hpp>
#include <common/AxisT.hpp>
#include <common/FrameT.hpp>
#include <common/VectorT.hpp>
#include <math/Cone.hpp>
using namespace AMCAX;
using namespace std;

TEST_CASE(\"TestCone\", \"[math][Cone\")

	AMCAX::Frame3 frame;
	double radius = 5.0;
	double angle = M_PI / 4;
	AMCAX::Cone cone(frame, radius, angle);
	AMCAX::Transformation3 tr;
	tr.SetTranslation(Vector3(1.0, 2.0, 3.0));
	cone.Transform(tr);"}    {
        "instruction": "Generate a test program based on the following method declarations and parameter parsing.",
        "input": "[[nodiscard]] AMCAX_API Point3 Apex()	 @return The apex point
	 @brief Get the apex of the cone",
        "output": "#include<catch.hpp>
#include<testHelperBase.h>

#include <polymeshAPI/MeshMakeCone.hpp>
#include <polymesh/PolyMeshIO.hpp>
#include <polymeshAPI/MeshSubdivideHE.hpp>

using namespace AMCAX;

TEST_CASE(\"case1:MeshMakeCone  \", \"[polymeshAPI][SubD][MeshMakeCone][P1]\") 
	double r = 1;
	double h = 1;
	SubD::MeshMakeCone meshmakeCone(r, h);
	AMCAX::SubD::PolyMesh* mesh = meshmakeCone.BuildMesh();
	CHECK(mesh != nullptr);
	AMCAX::SubD::MeshSubdivideHE::CatmullClark(mesh, 3);
	bool result = AMCAX::SubD::PolyMeshIO::WriteMesh(OUTPUT_PATH_PREFIX\"MeshMakeCone_case01.obj\", mesh);
	CHECK(result == true);"
    },
    {
        "instruction": "Generate a test program based on the following method declarations and parameter parsing.",
        "input": "[[nodiscard]] AMCAX_API double SemiAngle()	 @return The semi-angle
	 @brief Get the semi-angle",
        "output": "#include<catch.hpp>
#include<testHelperBase.h>

#include <polymeshAPI/MeshMakeCone.hpp>
#include <polymesh/PolyMeshIO.hpp>
#include <polymeshAPI/MeshSubdivideHE.hpp>

using namespace AMCAX;

TEST_CASE(\"case1:MeshMakeCone  \", \"[polymeshAPI][SubD][MeshMakeCone][P1]\") 
	double r = 1;
	double h = 1;
	SubD::MeshMakeCone meshmakeCone(r, h);
	AMCAX::SubD::PolyMesh* mesh = meshmakeCone.BuildMesh();
	CHECK(mesh != nullptr);
	AMCAX::SubD::MeshSubdivideHE::CatmullClark(mesh, 3);
	bool result = AMCAX::SubD::PolyMeshIO::WriteMesh(OUTPUT_PATH_PREFIX\"MeshMakeCone_case01.obj\", mesh);
	CHECK(result == true);"
    },
    {
        "instruction": "Generate a test program based on the following method declarations and parameter parsing.",
        "input": "Cone()	 @brief Default constructor",
        "output": "#include<catch.hpp>
#include<testHelperBase.h>

#include <polymeshAPI/MeshMakeCone.hpp>
#include <polymesh/PolyMeshIO.hpp>
#include <polymeshAPI/MeshSubdivideHE.hpp>

using namespace AMCAX;

TEST_CASE(\"case1:MeshMakeCone  \", \"[polymeshAPI][SubD][MeshMakeCone][P1]\") 
	double r = 1;
	double h = 1;
	SubD::MeshMakeCone meshmakeCone(r, h);
	AMCAX::SubD::PolyMesh* mesh = meshmakeCone.BuildMesh();
	CHECK(mesh != nullptr);
	AMCAX::SubD::MeshSubdivideHE::CatmullClark(mesh, 3);
	bool result = AMCAX::SubD::PolyMeshIO::WriteMesh(OUTPUT_PATH_PREFIX\"MeshMakeCone_case01.obj\", mesh);
	CHECK(result == true);"
    },
    {
        "instruction": "Generate a test program based on the following method declarations and parameter parsing.",
        "input": "AMCAX_API Cone(const Frame3& frame, double r, double angle)	 @param angle The semi-angle
	@param r The reference radius
	@param frame The local frame
	 @brief Construct from a local frame, a reference radius and a semi-angle",
        "output": "#include<catch.hpp>
#include<testHelperBase.h>

#include <polymeshAPI/MeshMakeCone.hpp>
#include <polymesh/PolyMeshIO.hpp>
#include <polymeshAPI/MeshSubdivideHE.hpp>

using namespace AMCAX;

TEST_CASE(\"case1:MeshMakeCone  \", \"[polymeshAPI][SubD][MeshMakeCone][P1]\") 
	double r = 1;
	double h = 1;
	SubD::MeshMakeCone meshmakeCone(r, h);
	AMCAX::SubD::PolyMesh* mesh = meshmakeCone.BuildMesh();
	CHECK(mesh != nullptr);
	AMCAX::SubD::MeshSubdivideHE::CatmullClark(mesh, 3);
	bool result = AMCAX::SubD::PolyMeshIO::WriteMesh(OUTPUT_PATH_PREFIX\"MeshMakeCone_case01.obj\", mesh);
	CHECK(result == true);"
    },
    {
        "instruction": "Generate a test program based on the following method declarations and parameter parsing.",
        "input": "AMCAX_API Cone& Scale(const Point3& point, double scale)	 @return The reference to self
	@param scale The scale value
	@param point The scaling center point
	 @brief Scale the cone by a point",
        "output": "#include<catch.hpp>
#include<testHelperBase.h>

#include <polymeshAPI/MeshMakeCone.hpp>
#include <polymesh/PolyMeshIO.hpp>
#include <polymeshAPI/MeshSubdivideHE.hpp>

using namespace AMCAX;

TEST_CASE(\"case1:MeshMakeCone  \", \"[polymeshAPI][SubD][MeshMakeCone][P1]\") 
	double r = 1;
	double h = 1;
	SubD::MeshMakeCone meshmakeCone(r, h);
	AMCAX::SubD::PolyMesh* mesh = meshmakeCone.BuildMesh();
	CHECK(mesh != nullptr);
	AMCAX::SubD::MeshSubdivideHE::CatmullClark(mesh, 3);
	bool result = AMCAX::SubD::PolyMeshIO::WriteMesh(OUTPUT_PATH_PREFIX\"MeshMakeCone_case01.obj\", mesh);
	CHECK(result == true);"
    },
    {
        "instruction": "Generate a test program based on the following method declarations and parameter parsing.",
        "input": "AMCAX_API Cone& Transform(const Transformation3& tr)	 @return The reference to self
	@param tr The transformation
	 @brief Transform the cone",
        "output": "#include<catch.hpp>
#include<testHelperBase.h>

#include <polymeshAPI/MeshMakeCone.hpp>
#include <polymesh/PolyMeshIO.hpp>
#include <polymeshAPI/MeshSubdivideHE.hpp>

using namespace AMCAX;

TEST_CASE(\"case1:MeshMakeCone  \", \"[polymeshAPI][SubD][MeshMakeCone][P1]\") 
	double r = 1;
	double h = 1;
	SubD::MeshMakeCone meshmakeCone(r, h);
	AMCAX::SubD::PolyMesh* mesh = meshmakeCone.BuildMesh();
	CHECK(mesh != nullptr);
	AMCAX::SubD::MeshSubdivideHE::CatmullClark(mesh, 3);
	bool result = AMCAX::SubD::PolyMeshIO::WriteMesh(OUTPUT_PATH_PREFIX\"MeshMakeCone_case01.obj\", mesh);
	CHECK(result == true);"
    }
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "AMCAX_API static void AdjustPeriodic(double ufirst, double ulast, double precision, double& u1, double& u2)	 @paramin,out] u2 The second parameter to be adjust
	 @param[in,out] u1 The first parameter to be adjust
	 @param[in] precision The precision to check equality
	 @param[in] ulast The upper bound of the period
	 @param[in] ufirst The lower bound of the period
	          The parameter u2 is set in the range [u1, u1 + ulast - ufirst]
	 @details The parameter u1 is set in the range [ufirst, ulast]
	 @brief Adjust u1 and u2 to be in the period range.",
 "output": "#include<catch.hpp>
#include<testHelper.h>


#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>


using namespace AMCAX;




TEST_CASE(\"case1: CurveCalculation::AdjustPeriodic \", \"[math][CurveCalculation][P1]\") 

	double u1 = 0.0;
	double u2 = 2 * M_PI;
	double ufirst = 0.0;
	double ulast = 2 * M_PI; // 假设周期为 2π
	double precision = 0.001; // 精度

	AMCAX::CurveCalculation::AdjustPeriodic(ufirst, ulast, precision, u1, u2);
	CHECK(u1 == 0);
	CHECK(u2 == 2 * M_PI);




TEST_CASE(\"case2: CurveCalculation::AdjustPeriodic \", \"[math][CurveCalculation][P1]\") 

	double u1 = 1.1;
	double u2 = 2.2;
	double ufirst = 0.0;
	double ulast = 2 * M_PI; // 假设周期为 2π
	double precision = 0.001; // 精度

	AMCAX::CurveCalculation::AdjustPeriodic(ufirst, ulast, precision, u1, u2);
	CHECK(u1 == 1.1);
	CHECK(u2 == 2.2);


TEST_CASE(\"case3: CurveCalculation::AdjustPeriodic \", \"[math][CurveCalculation][P1]\") 

	double u1 = 2 * M_PI;
	double u2 = 3 * M_PI;
	double ufirst = 0.0;
	double ulast = 2 * M_PI; // 假设周期为 2π
	double precision = 0.001; // 精度

	AMCAX::CurveCalculation::AdjustPeriodic(ufirst, ulast, precision, u1, u2);
	CHECK(u1 == 0);
	CHECK(u2 == M_PI);


TEST_CASE(\"case4: CurveCalculation::AdjustPeriodic \", \"[math][CurveCalculation][P1]\") 

	double u1 = 2 * M_PI + 0.3;
	double u2 = 3 * M_PI + 0.3;
	double ufirst = 0.0;
	double ulast = 2 * M_PI; // 假设周期为 2π
	double precision = 0.001; // 精度

	AMCAX::CurveCalculation::AdjustPeriodic(ufirst, ulast, precision, u1, u2);
	CHECK(u1 == Approx(0.3).epsilon(1e-2));
	CHECK(u2 ==  Approx(M_PI +0.3).epsilon(1e-2));


TEST_CASE(\"case5: CurveCalculation::AdjustPeriodic \", \"[math][CurveCalculation][P1]\") 

	double u1 = -0.5;
	double u2 = 2.5;
	double ufirst = 0.5;
	double ulast = 2.5; 
	double precision = 0.001; 

	AMCAX::CurveCalculation::AdjustPeriodic(ufirst, ulast, precision, u1, u2);
	CHECK(u1 == 1.5);
	CHECK(u2 == 2.5);


TEST_CASE(\"case6: CurveCalculation::AdjustPeriodic \", \"[math][CurveCalculation][P1]\") 

	double u1 = -0.0;
	double u2 = -0.0;
	double ufirst = 0.5;
	double ulast = 2.5;
	double precision = 0.001;

	AMCAX::CurveCalculation::AdjustPeriodic(ufirst, ulast, precision, u1, u2);
	CHECK(u1 == 2.0);
	CHECK(u2 == 4.0);"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] AMCAX_API static Point3 D0(double u, const Line3& line)	 @return The resulting point
	 @param line The line
	 @param u The parameter
	 @brief Compute the point on a 3D line at a parameter",
 "output": "#include<catch.hpp>
#include<testHelper.h>

#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>

using namespace AMCAX;

TEST_CASE(\"case1: CurveCalculation::D0 on Line3\", \"[math][CurveCalculation][P1]\") {
	double u = 0.5;
	Line3 line;
	Point3 result = AMCAX::CurveCalculation::D0(u, line);
	CHECK(result.X() == /* expected value */);
	CHECK(result.Y() == /* expected value */);
	CHECK(result.Z() == /* expected value */);
}

TEST_CASE(\"case2: CurveCalculation::D0 on Line3\", \"[math][CurveCalculation][P1]\") {
	double u = 1.0;
	Line3 line;
	Point3 result = AMCAX::CurveCalculation::D0(u, line);
	CHECK(result.X() == /* expected value */);
	CHECK(result.Y() == /* expected value */);
	CHECK(result.Z() == /* expected value */);
}"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] AMCAX_API static Point3 D0(double u, const Circle3& circle)	 @return The resulting point
	 @param circle The circle
	 @param u The parameter
	 @brief Compute the point on a 3D circle at a parameter",
 "output": "#include<catch.hpp>
#include<testHelper.h>

#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>

using namespace AMCAX;

TEST_CASE(\"case1: CurveCalculation::D0 on Circle3\", \"[math][CurveCalculation][P1]\") {
	double u = 0.5;
	Circle3 circle;
	Point3 result = AMCAX::CurveCalculation::D0(u, circle);
	CHECK(result.X() == /* expected value */);
	CHECK(result.Y() == /* expected value */);
	CHECK(result.Z() == /* expected value */);
}

TEST_CASE(\"case2: CurveCalculation::D0 on Circle3\", \"[math][CurveCalculation][P1]\") {
	double u = 1.0;
	Circle3 circle;
	Point3 result = AMCAX::CurveCalculation::D0(u, circle);
	CHECK(result.X() == /* expected value */);
	CHECK(result.Y() == /* expected value */);
	CHECK(result.Z() == /* expected value */);
}"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] AMCAX_API static Point3 D0(double u, const Ellipse3& ellipse)	 @return The resulting point
	 @param ellipse The ellipse
	 @param u The parameter
	 @brief Compute the point on a 3D ellipse at a parameter",
 "output": "#include<catch.hpp>
#include<testHelper.h>

#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>

using namespace AMCAX;

TEST_CASE(\"case1: CurveCalculation::D0 on Ellipse3\", \"[math][CurveCalculation][P1]\") {
	double u = 0.5;
	Ellipse3 ellipse;
	Point3 result = AMCAX::CurveCalculation::D0(u, ellipse);
	CHECK(result.X() == /* expected value */);
	CHECK(result.Y() == /* expected value */);
	CHECK(result.Z() == /* expected value */);
}

TEST_CASE(\"case2: CurveCalculation::D0 on Ellipse3\", \"[math][CurveCalculation][P1]\") {
	double u = 1.0;
	Ellipse3 ellipse;
	Point3 result = AMCAX::CurveCalculation::D0(u, ellipse);
	CHECK(result.X() == /* expected value */);
	CHECK(result.Y() == /* expected value */);
	CHECK(result.Z() == /* expected value */);
}"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] AMCAX_API static Point3 D0(double u, const Parabola3& parabola)	 @return The resulting point
	 @param parabola The parabola
	 @param u The parameter
	 @brief Compute the point on a 3D parabola at a parameter",
 "output": "#include<catch.hpp>
#include<testHelper.h>

#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>

using namespace AMCAX;

TEST_CASE(\"case1: CurveCalculation::D0 on Parabola3\", \"[math][CurveCalculation][P1]\") {
	double u = 0.5;
	Parabola3 parabola;
	Point3 result = AMCAX::CurveCalculation::D0(u, parabola);
	CHECK(result.X() == /* expected value */);
	CHECK(result.Y() == /* expected value */);
	CHECK(result.Z() == /* expected value */);
}

TEST_CASE(\"case2: CurveCalculation::D0 on Parabola3\", \"[math][CurveCalculation][P1]\") {
	double u = 1.0;
	Parabola3 parabola;
	Point3 result = AMCAX::CurveCalculation::D0(u, parabola);
	CHECK(result.X() == /* expected value */);
	CHECK(result.Y() == /* expected value */);
	CHECK(result.Z() == /* expected value */);
}"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] AMCAX_API static Point3 D0(double u, const Hyperbola3& hyperbola)	 @return The resulting point
	 @param hyperbola The hyperbola
	 @param u The parameter
	 @brief Compute the point on a 3D hyperbola at a parameter",
 "output": "#include<catch.hpp>
#include<testHelper.h>

#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>

using namespace AMCAX;

TEST_CASE(\"case1: CurveCalculation::D0 on Hyperbola3\", \"[math][CurveCalculation][P1]\") {
	double u = 0.5;
	Hyperbola3 hyperbola;
	Point3 result = AMCAX::CurveCalculation::D0(u, hyperbola);
	CHECK(result.X() == /* expected value */);
	CHECK(result.Y() == /* expected value */);
	CHECK(result.Z() == /* expected value */);
}

TEST_CASE(\"case2: CurveCalculation::D0 on Hyperbola3\", \"[math][CurveCalculation][P1]\") {
	double u = 1.0;
	Hyperbola3 hyperbola;
	Point3 result = AMCAX::CurveCalculation::D0(u, hyperbola);
	CHECK(result.X() == /* expected value */);
	CHECK(result.Y() == /* expected value */);
	CHECK(result.Z() == /* expected value */);
}"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] AMCAX_API static Point2 D0(double u, const Line2& line)	 @return The resulting point
	 @param line The line
	 @param u The parameter
	 @brief Compute the point on a 2D line at a parameter",
 "output": "#include<catch.hpp>
#include<testHelper.h>

#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>

using namespace AMCAX;

TEST_CASE(\"case1: CurveCalculation::D0 on Line2\", \"[math][CurveCalculation][P1]\") {
	double u = 0.5;
	Line2 line;
	Point2 result = AMCAX::CurveCalculation::D0(u, line);
	CHECK(result.X() == /* expected value */);
	CHECK(result.Y() == /* expected value */);
}

TEST_CASE(\"case2: CurveCalculation::D0 on Line2\", \"[math][CurveCalculation][P1]\") {
	double u = 1.0;
	Line2 line;
	Point2 result = AMCAX::CurveCalculation::D0(u, line);
	CHECK(result.X() == /* expected value */);
	CHECK(result.Y() == /* expected value */);
}"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] AMCAX_API static Point2 D0(double u, const Circle2& circle)	 @return The resulting point
	 @param circle The circle
	 @param u The parameter
	 @brief Compute the point on a 2D circle at a parameter",
 "output": "#include<catch.hpp>
#include<testHelper.h>

#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>

using namespace AMCAX;

TEST_CASE(\"case1: CurveCalculation::D0 on Circle2\", \"[math][CurveCalculation][P1]\") {
	double u = 0.5;
	Circle2 circle;
	Point2 result = AMCAX::CurveCalculation::D0(u, circle);
	CHECK(result.X() == /* expected value */);
	CHECK(result.Y() == /* expected value */);
}

TEST_CASE(\"case2: CurveCalculation::D0 on Circle2\", \"[math][CurveCalculation][P1]\") {
	double u = 1.0;
	Circle2 circle;
	Point2 result = AMCAX::CurveCalculation::D0(u, circle);
	CHECK(result.X() == /* expected value */);
	CHECK(result.Y() == /* expected value */);
}"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] AMCAX_API static Point2 D0(double u, const Ellipse2& ellipse)	 @return The resulting point
	 @param ellipse The ellipse
	 @param u The parameter
	 @brief Compute the point on a 2D ellipse at a parameter",
 "output": "#include<catch.hpp>
#include<testHelper.h>

#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>

using namespace AMCAX;

TEST_CASE(\"case1: CurveCalculation::D0 on Ellipse2\", \"[math][CurveCalculation][P1]\") {
	double u = 0.5;
	Ellipse2 ellipse;
	Point2 result = AMCAX::CurveCalculation::D0(u, ellipse);
	CHECK(result.X() == /* expected value */);
	CHECK(result.Y() == /* expected value */);
}

TEST_CASE(\"case2: CurveCalculation::D0 on Ellipse2\", \"[math][CurveCalculation][P1]\") {
	double u = 1.0;
	Ellipse2 ellipse;
	Point2 result = AMCAX::CurveCalculation::D0(u, ellipse);
	CHECK(result.X() == /* expected value */);
	CHECK(result.Y() == /* expected value */);
}"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] AMCAX_API static Point2 D0(double u, const Parabola2& parabola)	 @return The resulting point
	 @param parabola The parabola
	 @param u The parameter
	 @brief Compute the point on a 2D parabola at a parameter",
 "output": "#include<catch.hpp>
#include<testHelper.h>

#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>

using namespace AMCAX;

TEST_CASE(\"case1: CurveCalculation::D0 on Parabola2\", \"[math][CurveCalculation][P1]\") {
	double u = 0.5;
	Parabola2 parabola;
	Point2 result = AMCAX::CurveCalculation::D0(u, parabola);
	CHECK(result.X() == /* expected value */);
	CHECK(result.Y() == /* expected value */);
}

TEST_CASE(\"case2: CurveCalculation::D0 on Parabola2\", \"[math][CurveCalculation][P1]\") {
	double u = 1.0;
	Parabola2 parabola;
	Point2 result = AMCAX::CurveCalculation::D0(u, parabola);
	CHECK(result.X() == /* expected value */);
	CHECK(result.Y() == /* expected value */);
}"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] AMCAX_API static Point2 D0(double u, const Hyperbola2& hyperbola)	 @return The resulting point
	 @param hyperbola The hyperbola
	 @param u The parameter
	 @brief Compute the point on a 2D hyperbola at a parameter",
 "output": "#include<catch.hpp>
#include<testHelper.h>

#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>

using namespace AMCAX;

TEST_CASE(\"case1: CurveCalculation::D0 on Hyperbola2\", \"[math][CurveCalculation][P1]\") {
	double u = 0.5;
	Hyperbola2 hyperbola;
	Point2 result = AMCAX::CurveCalculation::D0(u, hyperbola);
	CHECK(result.X() == /* expected value */);
	CHECK(result.Y() == /* expected value */);
}

TEST_CASE(\"case2: CurveCalculation::D0 on Hyperbola2\", \"[math][CurveCalculation][P1]\") {
	double u = 1.0;
	Hyperbola2 hyperbola;
	Point2 result = AMCAX::CurveCalculation::D0(u, hyperbola);
	CHECK(result.X() == /* expected value */);
	CHECK(result.Y() == /* expected value */);
}"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] AMCAX_API static Vector3 D1(double u, const Line3& line)	 @return The first derivative vector
	 @param line The line
	 @param u The parameter
	 @brief Compute the first derivative on a 3D line at a parameter",
 "output": "#include<catch.hpp>
#include<testHelper.h>

#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>

using namespace AMCAX;

TEST_CASE(\"case1: CurveCalculation::D1 on Line3\", \"[math][CurveCalculation][P1]\") {
	double u = 0.5;
	Line3 line;
	Vector3 result = AMCAX::CurveCalculation::D1(u, line);
	CHECK(result.X() == /* expected value */);
	CHECK(result.Y() == /* expected value */);
	CHECK(result.Z() == /* expected value */);
}

TEST_CASE(\"case2: CurveCalculation::D1 on Line3\", \"[math][CurveCalculation][P1]\") {
	double u = 1.0;
	Line3 line;
	Vector3 result = AMCAX::CurveCalculation::D1(u, line);
	CHECK(result.X() == /* expected value */);
	CHECK(result.Y() == /* expected value */);
	CHECK(result.Z() == /* expected value */);
}"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "AMCAX_API static void D1(double u, const Line3& line, Point3& p, Vector3& v1)	 @param[out] v1 The first derivative
	 @param[out] p The point
	 @param[in] line The line
	 @param[in] u The parameter
	 @brief Compute the point and the first derivative on a 3D line at a parameter",
 "output": "#include<catch.hpp>
#include<testHelper.h>

#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>

using namespace AMCAX;

TEST_CASE(\"case1: CurveCalculation::D1 on Line3 with outputs\", \"[math][CurveCalculation][P1]\") {
	double u = 0.5;
	Line3 line;
	Point3 p;
	Vector3 v1;
	AMCAX::CurveCalculation::D1(u, line, p, v1);
	CHECK(p.X() == /* expected value */);
	CHECK(p.Y() == /* expected value */);
	CHECK(p.Z() == /* expected value */);
	CHECK(v1.X() == /* expected value */);
	CHECK(v1.Y() == /* expected value */);
	CHECK(v1.Z() == /* expected value */);
}

TEST_CASE(\"case2: CurveCalculation::D1 on Line3 with outputs\", \"[math][CurveCalculation][P1]\") {
	double u = 1.0;
	Line3 line;
	Point3 p;
	Vector3 v1;
	AMCAX::CurveCalculation::D1(u, line, p, v1);
	CHECK(p.X() == /* expected value */);
	CHECK(p.Y() == /* expected value */);
	CHECK(p.Z() == /* expected value */);
	CHECK(v1.X() == /* expected value */);
	CHECK(v1.Y() == /* expected value */);
	CHECK(v1.Z() == /* expected value */);
}"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] AMCAX_API static Vector3 D1(double u, const Circle3& circle)	 @return The first derivative vector
	 @param circle The circle
	 @param u The parameter
	 @brief Compute the first derivative on a 3D circle at a parameter",
 "output": "#include<catch.hpp>
#include<testHelper.h>

#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>

using namespace AMCAX;

TEST_CASE(\"case1: CurveCalculation::D1 on Circle3\", \"[math][CurveCalculation][P1]\") {
	double u = 0.5;
	Circle3 circle;
	Vector3 result = AMCAX::CurveCalculation::D1(u, circle);
	CHECK(result.X() == /* expected value */);
	CHECK(result.Y() == /* expected value */);
	CHECK(result.Z() == /* expected value */);
}

TEST_CASE(\"case2: CurveCalculation::D1 on Circle3\", \"[math][CurveCalculation][P1]\") {
	double u = 1.0;
	Circle3 circle;
	Vector3 result = AMCAX::CurveCalculation::D1(u, circle);
	CHECK(result.X() == /* expected value */);
	CHECK(result.Y() == /* expected value */);
	CHECK(result.Z() == /* expected value */);
}"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] AMCAX_API static Vector3 D1(double u, const Ellipse3& ellipse)	 @return The first derivative vector
	 @param ellipse The ellipse
	 @param u The parameter
	 @brief Compute the first derivative on a 3D ellipse at a parameter",
 "output": "#include<catch.hpp>
#include<testHelper.h>

#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>

using namespace AMCAX;

TEST_CASE(\"case1: CurveCalculation::D1 on Ellipse3\", \"[math][CurveCalculation][P1]\") {
	double u = 0.5;
	Ellipse3 ellipse;
	Vector3 result = AMCAX::CurveCalculation::D1(u, ellipse);
	CHECK(result.X() == /* expected value */);
	CHECK(result.Y() == /* expected value */);
	CHECK(result.Z() == /* expected value */);
}

TEST_CASE(\"case2: CurveCalculation::D1 on Ellipse3\", \"[math][CurveCalculation][P1]\") {
	double u = 1.0;
	Ellipse3 ellipse;
	Vector3 result = AMCAX::CurveCalculation::D1(u, ellipse);
	CHECK(result.X() == /* expected value */);
	CHECK(result.Y() == /* expected value */);
	CHECK(result.Z() == /* expected value */);
}"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] AMCAX_API static Vector3 D1(double u, const Parabola3& parabola)	 @return The first derivative vector
	 @param parabola The parabola
	 @param u The parameter
	 @brief Compute the first derivative on a 3D parabola at a parameter",
 "output": "#include<catch.hpp>
#include<testHelper.h>

#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>

using namespace AMCAX;

TEST_CASE(\"case1: CurveCalculation::D1 on Parabola3\", \"[math][CurveCalculation][P1]\") {
	double u = 0.5;
	Parabola3 parabola;
	Vector3 result = AMCAX::CurveCalculation::D1(u, parabola);
	CHECK(result.X() == /* expected value */);
	CHECK(result.Y() == /* expected value */);
	CHECK(result.Z() == /* expected value */);
}

TEST_CASE(\"case2: CurveCalculation::D1 on Parabola3\", \"[math][CurveCalculation][P1]\") {
	double u = 1.0;
	Parabola3 parabola;
	Vector3 result = AMCAX::CurveCalculation::D1(u, parabola);
	CHECK(result.X() == /* expected value */);
	CHECK(result.Y() == /* expected value */);
	CHECK(result.Z() == /* expected value */);
}"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] AMCAX_API static Vector3 D1(double u, const Hyperbola3& hyperbola)	 @return The first derivative vector
	 @param hyperbola The hyperbola
	 @param u The parameter
	 @brief Compute the first derivative on a 3D hyperbola at a parameter",
 "output": "#include<catch.hpp>
#include<testHelper.h>

#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>

using namespace AMCAX;

TEST_CASE(\"case1: CurveCalculation::D1 on Hyperbola3\", \"[math][CurveCalculation][P1]\") {
	double u = 0.5;
	Hyperbola3 hyperbola;
	Vector3 result = AMCAX::CurveCalculation::D1(u, hyperbola);
	CHECK(result.X() == /* expected value */);
	CHECK(result.Y() == /* expected value */);
	CHECK(result.Z() == /* expected value */);
}

TEST_CASE(\"case2: CurveCalculation::D1 on Hyperbola3\", \"[math][CurveCalculation][P1]\") {
	double u = 1.0;
	Hyperbola3 hyperbola;
	Vector3 result = AMCAX::CurveCalculation::D1(u, hyperbola);
	CHECK(result.X() == /* expected value */);
	CHECK(result.Y() == /* expected value */);
	CHECK(result.Z() == /* expected value */);
}"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] AMCAX_API static Vector2 D1(double u, const Line2& line)	 @return The first derivative vector
	 @param line The line
	 @param u The parameter
	 @brief Compute the first derivative on a 2D line at a parameter",
 "output": "#include<catch.hpp>
#include<testHelper.h>

#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>

using namespace AMCAX;

TEST_CASE(\"case1: CurveCalculation::D1 on Line2\", \"[math][CurveCalculation][P1]\") {
	double u = 0.5;
	Line2 line;
	Vector2 result = AMCAX::CurveCalculation::D1(u, line);
	CHECK(result.X() == /* expected value */);
	CHECK(result.Y() == /* expected value */);
}

TEST_CASE(\"case2: CurveCalculation::D1 on Line2\", \"[math][CurveCalculation][P1]\") {
	double u = 1.0;
	Line2 line;
	Vector2 result = AMCAX::CurveCalculation::D1(u, line);
	CHECK(result.X() == /* expected value */);
	CHECK(result.Y() == /* expected value */);
}"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] AMCAX_API static Vector2 D1(double u, const Circle2& circle)	 @return The first derivative vector
	 @param circle The circle
	 @param u The parameter
	 @brief Compute the first derivative on a 2D circle at a parameter",
 "output": "#include<catch.hpp>
#include<testHelper.h>

#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>

using namespace AMCAX;

TEST_CASE(\"case1: CurveCalculation::D1 on Circle2\", \"[math][CurveCalculation][P1]\") {
	double u = 0.5;
	Circle2 circle;
	Vector2 result = AMCAX::CurveCalculation::D1(u, circle);
	CHECK(result.X() == /* expected value */);
	CHECK(result.Y() == /* expected value */);
}

TEST_CASE(\"case2: CurveCalculation::D1 on Circle2\", \"[math][CurveCalculation][P1]\") {
	double u = 1.0;
	Circle2 circle;
	Vector2 result = AMCAX::CurveCalculation::D1(u, circle);
	CHECK(result.X() == /* expected value */);
	CHECK(result.Y() == /* expected value */);
}"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] AMCAX_API static Vector2 D1(double u, const Ellipse2& ellipse)	 @return The first derivative vector
	 @param ellipse The ellipse
	 @param u The parameter
	 @brief Compute the first derivative on a 2D ellipse at a parameter",
 "output": "#include<catch.hpp>
#include<testHelper.h>

#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>

using namespace AMCAX;

TEST_CASE(\"case1: CurveCalculation::D1 on Ellipse2\", \"[math][CurveCalculation][P1]\") {
	double u = 0.5;
	Ellipse2 ellipse;
	Vector2 result = AMCAX::CurveCalculation::D1(u, ellipse);
	CHECK(result.X() == /* expected value */);
	CHECK(result.Y() == /* expected value */);
}

TEST_CASE(\"case2: CurveCalculation::D1 on Ellipse2\", \"[math][CurveCalculation][P1]\") {
	double u = 1.0;
	Ellipse2 ellipse;
	Vector2 result = AMCAX::CurveCalculation::D1(u, ellipse);
	CHECK(result.X() == /* expected value */);
	CHECK(result.Y() == /* expected value */);
}"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] AMCAX_API static Vector2 D1(double u, const Parabola2& parabola)	 @return The first derivative vector
	 @param parabola The parabola
	 @param u The parameter
	 @brief Compute the first derivative on a 2D parabola at a parameter",
 "output": "#include<catch.hpp>
#include<testHelper.h>

#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>

using namespace AMCAX;

TEST_CASE(\"case1: CurveCalculation::D1 on Parabola2\", \"[math][CurveCalculation][P1]\") {
	double u = 0.5;
	Parabola2 parabola;
	Vector2 result = AMCAX::CurveCalculation::D1(u, parabola);
	CHECK(result.X() == /* expected value */);
	CHECK(result.Y() == /* expected value */);
}

TEST_CASE(\"case2: CurveCalculation::D1 on Parabola2\", \"[math][CurveCalculation][P1]\") {
	double u = 1.0;
	Parabola2 parabola;
	Vector2 result = AMCAX::CurveCalculation::D1(u, parabola);
	CHECK(result.X() == /* expected value */);
	CHECK(result.Y() == /* expected value */);
}"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] AMCAX_API static Vector2 D1(double u, const Hyperbola2& hyperbola)	 @return The first derivative vector
	 @param hyperbola The hyperbola
	 @param u The parameter
	 @brief Compute the first derivative on a 2D hyperbola at a parameter",
 "output": "#include<catch.hpp>
#include<testHelper.h>

#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>

using namespace AMCAX;

TEST_CASE(\"case1: CurveCalculation::D1 on Hyperbola2\", \"[math][CurveCalculation][P1]\") {
	double u = 0.5;
	Hyperbola2 hyperbola;
	Vector2 result = AMCAX::CurveCalculation::D1(u, hyperbola);
	CHECK(result.X() == /* expected value */);
	CHECK(result.Y() == /* expected value */);
}

TEST_CASE(\"case2: CurveCalculation::D1 on Hyperbola2\", \"[math][CurveCalculation][P1]\") {
	double u = 1.0;
	Hyperbola2 hyperbola;
	Vector2 result = AMCAX::CurveCalculation::D1(u, hyperbola);
	CHECK(result.X() == /* expected value */);
	CHECK(result.Y() == /* expected value */);
}"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] AMCAX_API static Vector3 D2(double u, const Line3& line)	 @return The second derivative vector
	 @param line The line
	 @param u The parameter
	 @brief Compute the second derivative on a 3D line at a parameter",
 "output": "#include<catch.hpp>
#include<testHelper.h>

#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>

using namespace AMCAX;

TEST_CASE(\"case1: CurveCalculation::D2 on Line3\", \"[math][CurveCalculation][P1]\") {
	double u = 0.5;
	Line3 line;
	Vector3 result = AMCAX::CurveCalculation::D2(u, line);
	CHECK(result.X() == /* expected value */);
	CHECK(result.Y() == /* expected value */);
	CHECK(result.Z() == /* expected value */);
}

TEST_CASE(\"case2: CurveCalculation::D2 on Line3\", \"[math][CurveCalculation][P1]\") {
	double u = 1.0;
	Line3 line;
	Vector3 result = AMCAX::CurveCalculation::D2(u, line);
	CHECK(result.X() == /* expected value */);
	CHECK(result.Y() == /* expected value */);
	CHECK(result.Z() == /* expected value */);
}"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "AMCAX_API static void D2(double u, const Line3& line, Point3& p, Vector3& v1, Vector3& v2)	 @param[out] v2 The second derivative
	 @param[out] v1 The first derivative
	 @param[out] p The point
	 @param[in] line The line
	 @param[in] u The parameter
	 @brief Compute the point and the first two derivatives on a 3D line at a parameter",
 "output": "#include<catch.hpp>
#include<testHelper.h>

#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>

using namespace AMCAX;

TEST_CASE(\"case1: CurveCalculation::D2 on Line3 with outputs\", \"[math][CurveCalculation][P1]\") {
	double u = 0.5;
	Line3 line;
	Point3 p;
	Vector3 v1;
	Vector3 v2;
	AMCAX::CurveCalculation::D2(u, line, p, v1, v2);
	CHECK(p.X() == /* expected value */);
	CHECK(p.Y() == /* expected value */);
	CHECK(p.Z() == /* expected value */);
	CHECK(v1.X() == /* expected value */);
	CHECK(v1.Y() == /* expected value */);
	CHECK(v1.Z() == /* expected value */);
	CHECK(v2.X() == /* expected value */);
	CHECK(v2.Y() == /* expected value */);
	CHECK(v2.Z() == /* expected value */);
}

TEST_CASE(\"case2: CurveCalculation::D2 on Line3 with outputs\", \"[math][CurveCalculation][P1]\") {
	double u = 1.0;
	Line3 line;
	Point3 p;
	Vector3 v1;
	Vector3 v2;
	AMCAX::CurveCalculation::D2(u, line, p, v1, v2);
	CHECK(p.X() == /* expected value */);
	CHECK(p.Y() == /* expected value */);
	CHECK(p.Z() == /* expected value */);
	CHECK(v1.X() == /* expected value */);
	CHECK(v1.Y() == /* expected value */);
	CHECK(v1.Z() == /* expected value */);
	CHECK(v2.X() == /* expected value */);
	CHECK(v2.Y() == /* expected value */);
	CHECK(v2.Z() == /* expected value */);
}"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] AMCAX_API static Vector3 D2(double u, const Circle3& circle)	 @return The second derivative vector
	 @param circle The circle
	 @param u The parameter
	 @brief Compute the second derivative on a 3D circle at a parameter",
 "output": "#include<catch.hpp>
#include<testHelper.h>

#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>

using namespace AMCAX;

TEST_CASE(\"case1: CurveCalculation::D2 on Circle3\", \"[math][CurveCalculation][P1]\") {
	double u = 0.5;
	Circle3 circle;
	Vector3 result = AMCAX::CurveCalculation::D2(u, circle);
	CHECK(result.X() == /* expected value */);
	CHECK(result.Y() == /* expected value */);
	CHECK(result.Z() == /* expected value */);
}

TEST_CASE(\"case2: CurveCalculation::D2 on Circle3\", \"[math][CurveCalculation][P1]\") {
	double u = 1.0;
	Circle3 circle;
	Vector3 result = AMCAX::CurveCalculation::D2(u, circle);
	CHECK(result.X() == /* expected value */);
	CHECK(result.Y() == /* expected value */);
	CHECK(result.Z() == /* expected value */);
}"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] AMCAX_API static Vector3 D2(double u, const Ellipse3& ellipse)	 @return The second derivative vector
	 @param ellipse The ellipse
	 @param u The parameter
	 @brief Compute the second derivative on a 3D ellipse at a parameter",
 "output": "#include<catch.hpp>
#include<testHelper.h>

#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>

using namespace AMCAX;

TEST_CASE(\"case1: CurveCalculation::D2 on Ellipse3\", \"[math][CurveCalculation][P1]\") {
	double u = 0.5;
	Ellipse3 ellipse;
	Vector3 result = AMCAX::CurveCalculation::D2(u, ellipse);
	CHECK(result.X() == /* expected value */);
	CHECK(result.Y() == /* expected value */);
	CHECK(result.Z() == /* expected value */);
}

TEST_CASE(\"case2: CurveCalculation::D2 on Ellipse3\", \"[math][CurveCalculation][P1]\") {
	double u = 1.0;
	Ellipse3 ellipse;
	Vector3 result = AMCAX::CurveCalculation::D2(u, ellipse);
	CHECK(result.X() == /* expected value */);
	CHECK(result.Y() == /* expected value */);
	CHECK(result.Z() == /* expected value */);
}"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] AMCAX_API static Vector3 D2(double u, const Parabola3& parabola)	 @return The second derivative vector
	 @param parabola The parabola
	 @param u The parameter
	 @brief Compute the second derivative on a 3D parabola at a parameter",
 "output": "#include<catch.hpp>
#include<testHelper.h>

#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>

using namespace AMCAX;

TEST_CASE(\"case1: CurveCalculation::D2 on Parabola3\", \"[math][CurveCalculation][P1]\") {
	double u = 0.5;
	Parabola3 parabola;
	Vector3 result = AMCAX::CurveCalculation::D2(u, parabola);
	CHECK(result.X() == /* expected value */);
	CHECK(result.Y() == /* expected value */);
	CHECK(result.Z() == /* expected value */);
}

TEST_CASE(\"case2: CurveCalculation::D2 on Parabola3\", \"[math][CurveCalculation][P1]\") {
	double u = 1.0;
	Parabola3 parabola;
	Vector3 result = AMCAX::CurveCalculation::D2(u, parabola);
	CHECK(result.X() == /* expected value */);
	CHECK(result.Y() == /* expected value */);
	CHECK(result.Z() == /* expected value */);
}"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] AMCAX_API static Vector3 D2(double u, const Hyperbola3& hyperbola)	 @return The second derivative vector
	 @param hyperbola The hyperbola
	 @param u The parameter
	 @brief Compute the second derivative on a 3D hyperbola at a parameter",
 "output": "#include<catch.hpp>
#include<testHelper.h>

#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>

using namespace AMCAX;

TEST_CASE(\"case1: CurveCalculation::D2 on Hyperbola3\", \"[math][CurveCalculation][P1]\") {
	double u = 0.5;
	Hyperbola3 hyperbola;
	Vector3 result = AMCAX::CurveCalculation::D2(u, hyperbola);
	CHECK(result.X() == /* expected value */);
	CHECK(result.Y() == /* expected value */);
	CHECK(result.Z() == /* expected value */);
}

TEST_CASE(\"case2: CurveCalculation::D2 on Hyperbola3\", \"[math][CurveCalculation][P1]\") {
	double u = 1.0;
	Hyperbola3 hyperbola;
	Vector3 result = AMCAX::CurveCalculation::D2(u, hyperbola);
	CHECK(result.X() == /* expected value */);
	CHECK(result.Y() == /* expected value */);
	CHECK(result.Z() == /* expected value */);
}"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] AMCAX_API static Vector2 D2(double u, const Line2& line)	 @return The second derivative vector
	 @param line The line
	 @param u The parameter
	 @brief Compute the second derivative on a 2D line at a parameter",
 "output": "#include<catch.hpp>
#include<testHelper.h>

#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>

using namespace AMCAX;

TEST_CASE(\"case1: CurveCalculation::D2 on Line2\", \"[math][CurveCalculation][P1]\") {
	double u = 0.5;
	Line2 line;
	Vector2 result = AMCAX::CurveCalculation::D2(u, line);
	CHECK(result.X() == /* expected value */);
	CHECK(result.Y() == /* expected value */);
}

TEST_CASE(\"case2: CurveCalculation::D2 on Line2\", \"[math][CurveCalculation][P1]\") {
	double u = 1.0;
	Line2 line;
	Vector2 result = AMCAX::CurveCalculation::D2(u, line);
	CHECK(result.X() == /* expected value */);
	CHECK(result.Y() == /* expected value */);
}"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] AMCAX_API static Vector2 D2(double u, const Circle2& circle)	 @return The second derivative vector
	 @param circle The circle
	 @param u The parameter
	 @brief Compute the second derivative on a 2D circle at a parameter",
 "output": "#include<catch.hpp>
#include<testHelper.h>

#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>

using namespace AMCAX;

TEST_CASE(\"case1: CurveCalculation::D2 on Circle2\", \"[math][CurveCalculation][P1]\") {
	double u = 0.5;
	Circle2 circle;
	Vector2 result = AMCAX::CurveCalculation::D2(u, circle);
	CHECK(result.X() == /* expected value */);
	CHECK(result.Y() == /* expected value */);
}

TEST_CASE(\"case2: CurveCalculation::D2 on Circle2\", \"[math][CurveCalculation][P1]\") {
	double u = 1.0;
	Circle2 circle;
	Vector2 result = AMCAX::CurveCalculation::D2(u, circle);
	CHECK(result.X() == /* expected value */);
	CHECK(result.Y() == /* expected value */);
}"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] AMCAX_API static Vector2 D2(double u, const Ellipse2& ellipse)	 @return The second derivative vector
	 @param ellipse The ellipse
	 @param u The parameter
	 @brief Compute the second derivative on a 2D ellipse at a parameter",
 "output": "#include<catch.hpp>
#include<testHelper.h>

#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>

using namespace AMCAX;

TEST_CASE(\"case1: CurveCalculation::D2 on Ellipse2\", \"[math][CurveCalculation][P1]\") {
	double u = 0.5;
	Ellipse2 ellipse;
	Vector2 result = AMCAX::CurveCalculation::D2(u, ellipse);
	CHECK(result.X() == /* expected value */);
	CHECK(result.Y() == /* expected value */);
}

TEST_CASE(\"case2: CurveCalculation::D2 on Ellipse2\", \"[math][CurveCalculation][P1]\") {
	double u = 1.0;
	Ellipse2 ellipse;
	Vector2 result = AMCAX::CurveCalculation::D2(u, ellipse);
	CHECK(result.X() == /* expected value */);
	CHECK(result.Y() == /* expected value */);
}"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] AMCAX_API static Vector2 D2(double u, const Parabola2& parabola)	 @return The second derivative vector
	 @param parabola The parabola
	 @param u The parameter
	 @brief Compute the second derivative on a 2D parabola at a parameter",
 "output": "#include<catch.hpp>
#include<testHelper.h>

#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>

using namespace AMCAX;

TEST_CASE(\"case1: CurveCalculation::D2 on Parabola2\", \"[math][CurveCalculation][P1]\") {
	double u = 0.5;
	Parabola2 parabola;
	Vector2 result = AMCAX::CurveCalculation::D2(u, parabola);
	CHECK(result.X() == /* expected value */);
	CHECK(result.Y() == /* expected value */);
}

TEST_CASE(\"case2: CurveCalculation::D2 on Parabola2\", \"[math][CurveCalculation][P1]\") {
	double u = 1.0;
	Parabola2 parabola;
	Vector2 result = AMCAX::CurveCalculation::D2(u, parabola);
	CHECK(result.X() == /* expected value */);
	CHECK(result.Y() == /* expected value */);
}"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] AMCAX_API static Vector2 D2(double u, const Hyperbola2& hyperbola)	 @return The second derivative vector
	 @param hyperbola The hyperbola
	 @param u The parameter
	 @brief Compute the second derivative on a 2D hyperbola at a parameter",
 "output": "#include<catch.hpp>
#include<testHelper.h>

#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>

using namespace AMCAX;

TEST_CASE(\"case1: CurveCalculation::D2 on Hyperbola2\", \"[math][CurveCalculation][P1]\") {
	double u = 0.5;
	Hyperbola2 hyperbola;
	Vector2 result = AMCAX::CurveCalculation::D2(u, hyperbola);
	CHECK(result.X() == /* expected value */);
	CHECK(result.Y() == /* expected value */);
}

TEST_CASE(\"case2: CurveCalculation::D2 on Hyperbola2\", \"[math][CurveCalculation][P1]\") {
	double u = 1.0;
	Hyperbola2 hyperbola;
	Vector2 result = AMCAX::CurveCalculation::D2(u, hyperbola);
	CHECK(result.X() == /* expected value */);
	CHECK(result.Y() == /* expected value */);
}"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] AMCAX_API static Vector3 D3(double u, const Line3& line)	 @return The third derivative vector
	 @param line The line
	 @param u The parameter
	 @brief Compute the third derivative on a 3D line at a parameter",
 "output": "#include<catch.hpp>
#include<testHelper.h>

#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>

using namespace AMCAX;

TEST_CASE(\"case1: CurveCalculation::D3 on Line3\", \"[math][CurveCalculation][P1]\") {
	double u = 0.5;
	Line3 line;
	Vector3 result = AMCAX::CurveCalculation::D3(u, line);
	CHECK(result.X() == /* expected value */);
	CHECK(result.Y() == /* expected value */);
	CHECK(result.Z() == /* expected value */);
}

TEST_CASE(\"case2: CurveCalculation::D3 on Line3\", \"[math][CurveCalculation][P1]\") {
	double u = 1.0;
	Line3 line;
	Vector3 result = AMCAX::CurveCalculation::D3(u, line);
	CHECK(result.X() == /* expected value */);
	CHECK(result.Y() == /* expected value */);
	CHECK(result.Z() == /* expected value */);
}"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "AMCAX_API static void D3(double u, const Line3& line, Point3& p, Vector3& v1, Vector3& v2, Vector3& v3)	 @param[out] v3 The third derivative
	 @param[out] v2 The second derivative
	 @param[out] v1 The first derivative
	 @param[out] p The point
	 @param[in] line The line
	 @param[in] u The parameter
	 @brief Compute the point and the first three derivatives on a 3D line at a parameter",
 "output": "#include<catch.hpp>
#include<testHelper.h>

#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>

using namespace AMCAX;

TEST_CASE(\"case1: CurveCalculation::D3 on Line3 with outputs\", \"[math][CurveCalculation][P1]\") {
	double u = 0.5;
	Line3 line;
	Point3 p;
	Vector3 v1;
	Vector3 v2;
	Vector3 v3;
	AMCAX::CurveCalculation::D3(u, line, p, v1, v2, v3);
	CHECK(p.X() == /* expected value */);
	CHECK(p.Y() == /* expected value */);
	CHECK(p.Z() == /* expected value */);
	CHECK(v1.X() == /* expected value */);
	CHECK(v1.Y() == /* expected value */);
	CHECK(v1.Z() == /* expected value */);
	CHECK(v2.X() == /* expected value */);
	CHECK(v2.Y() == /* expected value */);
	CHECK(v2.Z() == /* expected value */);
	CHECK(v3.X() == /* expected value */);
	CHECK(v3.Y() == /* expected value */);
	CHECK(v3.Z() == /* expected value */);
}

TEST_CASE(\"case2: CurveCalculation::D3 on Line3 with outputs\", \"[math][CurveCalculation][P1]\") {
	double u = 1.0;
	Line3 line;
	Point3 p;
	Vector3 v1;
	Vector3 v2;
	Vector3 v3;
	AMCAX::CurveCalculation::D3(u, line, p, v1, v2, v3);
	CHECK(p.X() == /* expected value */);
	CHECK(p.Y() == /* expected value */);
	CHECK(p.Z() == /* expected value */);
	CHECK(v1.X() == /* expected value */);
	CHECK(v1.Y() == /* expected value */);
	CHECK(v1.Z() == /* expected value */);
	CHECK(v2.X() == /* expected value */);
	CHECK(v2.Y() == /* expected value */);
	CHECK(v2.Z() == /* expected value */);
	CHECK(v3.X() == /* expected value */);
	CHECK(v3.Y() == /* expected value */);
	CHECK(v3.Z() == /* expected value */);
}"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] AMCAX_API static Vector3 D3(double u, const Circle3& circle)	 @return The third derivative vector
	 @param circle The circle
	 @param u The parameter
	 @brief Compute the third derivative on a 3D circle at a parameter",
 "output": "#include<catch.hpp>
#include<testHelper.h>

#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>

using namespace AMCAX;

TEST_CASE(\"case1: CurveCalculation::D3 on Circle3\", \"[math][CurveCalculation][P1]\") {
	double u = 0.5;
	Circle3 circle;
	Vector3 result = AMCAX::CurveCalculation::D3(u, circle);
	CHECK(result.X() == /* expected value */);
	CHECK(result.Y() == /* expected value */);
	CHECK(result.Z() == /* expected value */);
}

TEST_CASE(\"case2: CurveCalculation::D3 on Circle3\", \"[math][CurveCalculation][P1]\") {
	double u = 1.0;
	Circle3 circle;
	Vector3 result = AMCAX::CurveCalculation::D3(u, circle);
	CHECK(result.X() == /* expected value */);
	CHECK(result.Y() == /* expected value */);
	CHECK(result.Z() == /* expected value */);
}"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] AMCAX_API static Vector3 D3(double u, const Ellipse3& ellipse)	 @return The third derivative vector
	 @param ellipse The ellipse
	 @param u The parameter
	 @brief Compute the third derivative on a 3D ellipse at a parameter",
 "output": "#include<catch.hpp>
#include<testHelper.h>

#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>

using namespace AMCAX;

TEST_CASE(\"case1: CurveCalculation::D3 on Ellipse3\", \"[math][CurveCalculation][P1]\") {
	double u = 0.5;
	Ellipse3 ellipse;
	Vector3 result = AMCAX::CurveCalculation::D3(u, ellipse);
	CHECK(result.X() == /* expected value */);
	CHECK(result.Y() == /* expected value */);
	CHECK(result.Z() == /* expected value */);
}

TEST_CASE(\"case2: CurveCalculation::D3 on Ellipse3\", \"[math][CurveCalculation][P1]\") {
	double u = 1.0;
	Ellipse3 ellipse;
	Vector3 result = AMCAX::CurveCalculation::D3(u, ellipse);
	CHECK(result.X() == /* expected value */);
	CHECK(result.Y() == /* expected value */);
	CHECK(result.Z() == /* expected value */);
}"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] AMCAX_API static Vector3 D3(double u, const Parabola3& parabola)	 @return The third derivative vector
	 @param parabola The parabola
	 @param u The parameter
	 @brief Compute the third derivative on a 3D parabola at a parameter",
 "output": "#include<catch.hpp>
#include<testHelper.h>

#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>

using namespace AMCAX;

TEST_CASE(\"case1: CurveCalculation::D3 on Parabola3\", \"[math][CurveCalculation][P1]\") {
	double u = 0.5;
	Parabola3 parabola;
	Vector3 result = AMCAX::CurveCalculation::D3(u, parabola);
	CHECK(result.X() == /* expected value */);
	CHECK(result.Y() == /* expected value */);
	CHECK(result.Z() == /* expected value */);
}

TEST_CASE(\"case2: CurveCalculation::D3 on Parabola3\", \"[math][CurveCalculation][P1]\") {
	double u = 1.0;
	Parabola3 parabola;
	Vector3 result = AMCAX::CurveCalculation::D3(u, parabola);
	CHECK(result.X() == /* expected value */);
	CHECK(result.Y() == /* expected value */);
	CHECK(result.Z() == /* expected value */);
}"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] AMCAX_API static Vector3 D3(double u, const Hyperbola3& hyperbola)	 @return The third derivative vector
	 @param hyperbola The hyperbola
	 @param u The parameter
	 @brief Compute the third derivative on a 3D hyperbola at a parameter",
 "output": "#include<catch.hpp>
#include<testHelper.h>

#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>

using namespace AMCAX;

TEST_CASE(\"case1: CurveCalculation::D3 on Hyperbola3\", \"[math][CurveCalculation][P1]\") {
	double u = 0.5;
	Hyperbola3 hyperbola;
	Vector3 result = AMCAX::CurveCalculation::D3(u, hyperbola);
	CHECK(result.X() == /* expected value */);
	CHECK(result.Y() == /* expected value */);
	CHECK(result.Z() == /* expected value */);
}

TEST_CASE(\"case2: CurveCalculation::D3 on Hyperbola3\", \"[math][CurveCalculation][P1]\") {
	double u = 1.0;
	Hyperbola3 hyperbola;
	Vector3 result = AMCAX::CurveCalculation::D3(u, hyperbola);
	CHECK(result.X() == /* expected value */);
	CHECK(result.Y() == /* expected value */);
	CHECK(result.Z() == /* expected value */);
}"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] AMCAX_API static Vector2 D3(double u, const Line2& line)	 @return The third derivative vector
	 @param line The line
	 @param u The parameter
	 @brief Compute the third derivative on a 2D line at a parameter",
 "output": "#include<catch.hpp>
#include<testHelper.h>

#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>

using namespace AMCAX;

TEST_CASE(\"case1: CurveCalculation::D3 on Line2\", \"[math][CurveCalculation][P1]\") {
	double u = 0.5;
	Line2 line;
	Vector2 result = AMCAX::CurveCalculation::D3(u, line);
	CHECK(result.X() == /* expected value */);
	CHECK(result.Y() == /* expected value */);
}

TEST_CASE(\"case2: CurveCalculation::D3 on Line2\", \"[math][CurveCalculation][P1]\") {
	double u = 1.0;
	Line2 line;
	Vector2 result = AMCAX::CurveCalculation::D3(u, line);
	CHECK(result.X() == /* expected value */);
	CHECK(result.Y() == /* expected value */);
}"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] AMCAX_API static Vector2 D3(double u, const Circle2& circle)	 @return The third derivative vector
	 @param circle The circle
	 @param u The parameter
	 @brief Compute the third derivative on a 2D circle at a parameter",
 "output": "#include<catch.hpp>
#include<testHelper.h>

#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>

using namespace AMCAX;

TEST_CASE(\"case1: CurveCalculation::D3 on Circle2\", \"[math][CurveCalculation][P1]\") {
	double u = 0.5;
	Circle2 circle;
	Vector2 result = AMCAX::CurveCalculation::D3(u, circle);
	CHECK(result.X() == /* expected value */);
	CHECK(result.Y() == /* expected value */);
}

TEST_CASE(\"case2: CurveCalculation::D3 on Circle2\", \"[math][CurveCalculation][P1]\") {
	double u = 1.0;
	Circle2 circle;
	Vector2 result = AMCAX::CurveCalculation::D3(u, circle);
	CHECK(result.X() == /* expected value */);
	CHECK(result.Y() == /* expected value */);
}"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] AMCAX_API static Vector2 D3(double u, const Ellipse2& ellipse)	 @return The third derivative vector
	 @param ellipse The ellipse
	 @param u The parameter
	 @brief Compute the third derivative on a 2D ellipse at a parameter",
 "output": "#include<catch.hpp>
#include<testHelper.h>

#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>

using namespace AMCAX;

TEST_CASE(\"case1: CurveCalculation::D3 on Ellipse2\", \"[math][CurveCalculation][P1]\") {
	double u = 0.5;
	Ellipse2 ellipse;
	Vector2 result = AMCAX::CurveCalculation::D3(u, ellipse);
	CHECK(result.X() == /* expected value */);
	CHECK(result.Y() == /* expected value */);
}

TEST_CASE(\"case2: CurveCalculation::D3 on Ellipse2\", \"[math][CurveCalculation][P1]\") {
	double u = 1.0;
	Ellipse2 ellipse;
	Vector2 result = AMCAX::CurveCalculation::D3(u, ellipse);
	CHECK(result.X() == /* expected value */);
	CHECK(result.Y() == /* expected value */);
}"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] AMCAX_API static Vector2 D3(double u, const Parabola2& parabola)	 @return The third derivative vector
	 @param parabola The parabola
	 @param u The parameter
	 @brief Compute the third derivative on a 2D parabola at a parameter",
 "output": "#include<catch.hpp>
#include<testHelper.h>

#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>

using namespace AMCAX;

TEST_CASE(\"case1: CurveCalculation::D3 on Parabola2\", \"[math][CurveCalculation][P1]\") {
	double u = 0.5;
	Parabola2 parabola;
	Vector2 result = AMCAX::CurveCalculation::D3(u, parabola);
	CHECK(result.X() == /* expected value */);
	CHECK(result.Y() == /* expected value */);
}

TEST_CASE(\"case2: CurveCalculation::D3 on Parabola2\", \"[math][CurveCalculation][P1]\") {
	double u = 1.0;
	Parabola2 parabola;
	Vector2 result = AMCAX::CurveCalculation::D3(u, parabola);
	CHECK(result.X() == /* expected value */);
	CHECK(result.Y() == /* expected value */);
}"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] AMCAX_API static Vector2 D3(double u, const Hyperbola2& hyperbola)	 @return The third derivative vector
	 @param hyperbola The hyperbola
	 @param u The parameter
	 @brief Compute the third derivative on a 2D hyperbola at a parameter",
 "output": "#include<catch.hpp>
#include<testHelper.h>

#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>

using namespace AMCAX;

TEST_CASE(\"case1: CurveCalculation::D3 on Hyperbola2\", \"[math][CurveCalculation][P1]\") {
	double u = 0.5;
	Hyperbola2 hyperbola;
	Vector2 result = AMCAX::CurveCalculation::D3(u, hyperbola);
	CHECK(result.X() == /* expected value */);
	CHECK(result.Y() == /* expected value */);
}

TEST_CASE(\"case2: CurveCalculation::D3 on Hyperbola2\", \"[math][CurveCalculation][P1\") {
	double u = 1.0;
	Hyperbola2 hyperbola;
	Vector2 result = AMCAX::CurveCalculation::D3(u, hyperbola);
	CHECK(result.X() == /* expected value */);
	CHECK(result.Y() == /* expected value */);
}"}
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "AMCAX_API static void AdjustPeriodic(double ufirst, double ulast, double precision, double& u1, double& u2)
	 @paramin,out] u2 The second parameter to be adjust
	 @param[in,out] u1 The first parameter to be adjust
	 @param[in] precision The precision to check equality
	 @param[in] ulast The upper bound of the period
	 @param[in] ufirst The lower bound of the period
	          The parameter u2 is set in the range [u1, u1 + ulast - ufirst]
	 @details The parameter u1 is set in the range [ufirst, ulast]
	 @brief Adjust u1 and u2 to be in the period range.",
 "output": "#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
#include <occtio/OCCTTool.hpp>
#include <geometry/MakeArcOfHyperbola2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeEdge2d.hpp>

using namespace AMCAX;

TEST_CASE(\"AdjustPeriodic Test Case\", \"[AdjustPeriodic]\") {
	double u1, u2;
	AdjustPeriodic(0.0, 10.0, 0.01, u1, u2);
	CHECK(u1 >= 0.0);
	CHECK(u2 <= 10.0);
}"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] AMCAX_API static Point3 D0(double u, const Line3& line)
	 @return The resulting point
	 @param line The line
	 @param u The parameter
	 @brief Compute the point on a 3D line at a parameter",
 "output": "#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
#include <occtio/OCCTTool.hpp>

using namespace AMCAX;

TEST_CASE(\"D0 with Line3\", \"[D0]\") {
	Line3 line(...);
	Point3 result = D0(1.0, line);
	CHECK(result.X() == ...);
	CHECK(result.Y() == ...);
	CHECK(result.Z() == ...);
}"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] AMCAX_API static Point3 D0(double u, const Circle3& circle)
	 @return The resulting point
	 @param circle The circle
	 @param u The parameter
	 @brief Compute the point on a 3D circle at a parameter",
 "output": "#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
#include <occtio/OCCTTool.hpp>

using namespace AMCAX;

TEST_CASE(\"D0 with Circle3\", \"[D0]\") {
	Circle3 circle(...);
	Point3 result = D0(1.0, circle);
	CHECK(result.X() == ...);
	CHECK(result.Y() == ...);
	CHECK(result.Z() == ...);
}"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] AMCAX_API static Point3 D0(double u, const Ellipse3& ellipse)
	 @return The resulting point
	 @param ellipse The ellipse
	 @param u The parameter
	 @brief Compute the point on a 3D ellipse at a parameter",
 "output": "#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
#include <occtio/OCCTTool.hpp>

using namespace AMCAX;

TEST_CASE(\"D0 with Ellipse3\", \"[D0]\") {
	Ellipse3 ellipse(...);
	Point3 result = D0(1.0, ellipse);
	CHECK(result.X() == ...);
	CHECK(result.Y() == ...);
	CHECK(result.Z() == ...);
}"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] AMCAX_API static Point3 D0(double u, const Parabola3& parabola)
	 @return The resulting point
	 @param parabola The parabola
	 @param u The parameter
	 @brief Compute the point on a 3D parabola at a parameter",
 "output": "#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
#include <occtio/OCCTTool.hpp>

using namespace AMCAX;

TEST_CASE(\"D0 with Parabola3\", \"[D0]\") {
	Parabola3 parabola(...);
	Point3 result = D0(1.0, parabola);
	CHECK(result.X() == ...);
	CHECK(result.Y() == ...);
	CHECK(result.Z() == ...);
}"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] AMCAX_API static Point3 D0(double u, const Hyperbola3& hyperbola)
	 @return The resulting point
	 @param hyperbola The hyperbola
	 @param u The parameter
	 @brief Compute the point on a 3D hyperbola at a parameter",
 "output": "#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
#include <occtio/OCCTTool.hpp>

using namespace AMCAX;

TEST_CASE(\"D0 with Hyperbola3\", \"[D0]\") {
	Hyperbola3 hyperbola(...);
	Point3 result = D0(1.0, hyperbola);
	CHECK(result.X() == ...);
	CHECK(result.Y() == ...);
	CHECK(result.Z() == ...);
}"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] AMCAX_API static Point2 D0(double u, const Line2& line)
	 @return The resulting point
	 @param line The line
	 @param u The parameter
	 @brief Compute the point on a 2D line at a parameter",
 "output": "#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
#include <occtio/OCCTTool.hpp>

using namespace AMCAX;

TEST_CASE(\"D0 with Line2\", \"[D0]\") {
	Line2 line(...);
	Point2 result = D0(1.0, line);
	CHECK(result.X() == ...);
	CHECK(result.Y() == ...);
}"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] AMCAX_API static Point2 D0(double u, const Circle2& circle)
	 @return The resulting point
	 @param circle The circle
	 @param u The parameter
	 @brief Compute the point on a 2D circle at a parameter",
 "output": "#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
#include <occtio/OCCTTool.hpp>

using namespace AMCAX;

TEST_CASE(\"D0 with Circle2\", \"[D0]\") {
	Circle2 circle(...);
	Point2 result = D0(1.0, circle);
	CHECK(result.X() == ...);
	CHECK(result.Y() == ...);
}"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] AMCAX_API static Point2 D0(double u, const Ellipse2& ellipse)
	 @return The resulting point
	 @param ellipse The ellipse
	 @param u The parameter
	 @brief Compute the point on a 2D ellipse at a parameter",
 "output": "#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
#include <occtio/OCCTTool.hpp>

using namespace AMCAX;

TEST_CASE(\"D0 with Ellipse2\", \"[D0]\") {
	Ellipse2 ellipse(...);
	Point2 result = D0(1.0, ellipse);
	CHECK(result.X() == ...);
	CHECK(result.Y() == ...);
}"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] AMCAX_API static Point2 D0(double u, const Parabola2& parabola)
	 @return The resulting point
	 @param parabola The parabola
	 @param u The parameter
	 @brief Compute the point on a 2D parabola at a parameter",
 "output": "#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
#include <occtio/OCCTTool.hpp>

using namespace AMCAX;

TEST_CASE(\"D0 with Parabola2\", \"[D0]\") {
	Parabola2 parabola(...);
	Point2 result = D0(1.0, parabola);
	CHECK(result.X() == ...);
	CHECK(result.Y() == ...);
}"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] AMCAX_API static Point2 D0(double u, const Hyperbola2& hyperbola)
	 @return The resulting point
	 @param hyperbola The hyperbola
	 @param u The parameter
	 @brief Compute the point on a 2D hyperbola at a parameter",
 "output": "#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
#include <occtio/OCCTTool.hpp>

using namespace AMCAX;

TEST_CASE(\"D0 with Hyperbola2\", \"[D0]\") {
	Hyperbola2 hyperbola(...);
	Point2 result = D0(1.0, hyperbola);
	CHECK(result.X() == ...);
	CHECK(result.Y() == ...);
}"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] AMCAX_API static Vector3 D1(double u, const Line3& line)
	 @return The first derivative vector
	 @param line The line
	 @param u The parameter
	 @brief Compute the first derivative on a 3D line at a parameter",
 "output": "#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
#include <occtio/OCCTTool.hpp>

using namespace AMCAX;

TEST_CASE(\"D1 with Line3\", \"[D1]\") {
	Line3 line(...);
	Vector3 result = D1(1.0, line);
	CHECK(result.X() == ...);
	CHECK(result.Y() == ...);
	CHECK(result.Z() == ...);
}"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "AMCAX_API static void D1(double u, const Line3& line, Point3& p, Vector3& v1)
	 @param[out] v1 The first derivative
	 @param[out] p The point
	 @param[in] line The line
	 @param[in] u The parameter
	 @brief Compute the point and the first derivative on a 3D line at a parameter",
 "output": "#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
#include <occtio/OCCTTool.hpp>

using namespace AMCAX;

TEST_CASE(\"D1 with Line3\", \"[D1]\") {
	Line3 line(...);
	Point3 p;
	Vector3 v1;
	D1(1.0, line, p, v1);
	CHECK(p.X() == ...);
	CHECK(p.Y() == ...);
	CHECK(p.Z() == ...);
	CHECK(v1.X() == ...);
	CHECK(v1.Y() == ...);
	CHECK(v1.Z() == ...);
}"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] AMCAX_API static Vector3 D1(double u, const Circle3& circle)
	 @return The first derivative vector
	 @param circle The circle
	 @param u The parameter
	 @brief Compute the first derivative on a 3D circle at a parameter",
 "output": "#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
#include <occtio/OCCTTool.hpp>

using namespace AMCAX;

TEST_CASE(\"D1 with Circle3\", \"[D1]\") {
	Circle3 circle(...);
	Vector3 result = D1(1.0, circle);
	CHECK(result.X() == ...);
	CHECK(result.Y() == ...);
	CHECK(result.Z() == ...);
}"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "AMCAX_API static void D1(double u, const Circle3& circle, Point3& p, Vector3& v1)
	 @param[out] v1 The first derivative
	 @param[out] p The point
	 @param[in] circle The circle
	 @param[in] u The parameter
	 @brief Compute the point and the first derivative on a 3D circle at a parameter",
 "output": "#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
#include <occtio/OCCTTool.hpp>

using namespace AMCAX;

TEST_CASE(\"D1 with Circle3\", \"[D1]\") {
	Circle3 circle(...);
	Point3 p;
	Vector3 v1;
	D1(1.0, circle, p, v1);
	CHECK(p.X() == ...);
	CHECK(p.Y() == ...);
	CHECK(p.Z() == ...);
	CHECK(v1.X() == ...);
	CHECK(v1.Y() == ...);
	CHECK(v1.Z() == ...);
}"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] AMCAX_API static Vector3 D1(double u, const Ellipse3& ellipse)
	 @return The first derivative vector
	 @param ellipse The ellipse
	 @param u The parameter
	 @brief Compute the first derivative on a 3D ellipse at a parameter",
 "output": "#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
#include <occtio/OCCTTool.hpp>

using namespace AMCAX;

TEST_CASE(\"D1 with Ellipse3\", \"[D1]\") {
	Ellipse3 ellipse(...);
	Vector3 result = D1(1.0, ellipse);
	CHECK(result.X() == ...);
	CHECK(result.Y() == ...);
	CHECK(result.Z() == ...);
}"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "AMCAX_API static void D1(double u, const Ellipse3& ellipse, Point3& p, Vector3& v1)
	 @param[out] v1 The first derivative
	 @param[out] p The point
	 @param[in] ellipse The ellipse
	 @param[in] u The parameter
	 @brief Compute the point and the first derivative on a 3D ellipse at a parameter",
 "output": "#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
#include <occtio/OCCTTool.hpp>

using namespace AMCAX;

TEST_CASE(\"D1 with Ellipse3\", \"[D1]\") {
	Ellipse3 ellipse(...);
	Point3 p;
	Vector3 v1;
	D1(1.0, ellipse, p, v1);
	CHECK(p.X() == ...);
	CHECK(p.Y() == ...);
	CHECK(p.Z() == ...);
	CHECK(v1.X() == ...);
	CHECK(v1.Y() == ...);
	CHECK(v1.Z() == ...);
}"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] AMCAX_API static Vector3 D1(double u, const Parabola3& parabola)
	 @return The first derivative vector
	 @param parabola The parabola
	 @param u The parameter
	 @brief Compute the first derivative on a 3D parabola at a parameter",
 "output": "#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
#include <occtio/OCCTTool.hpp>

using namespace AMCAX;

TEST_CASE(\"D1 with Parabola3\", \"[D1]\") {
	Parabola3 parabola(...);
	Vector3 result = D1(1.0, parabola);
	CHECK(result.X() == ...);
	CHECK(result.Y() == ...);
	CHECK(result.Z() == ...);
}"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "AMCAX_API static void D1(double u, const Parabola3& parabola, Point3& p, Vector3& v1)
	 @param[out] v1 The first derivative
	 @param[out] p The point
	 @param[in] parabola The parabola
	 @param[in] u The parameter
	 @brief Compute the point and the first derivative on a 3D parabola at a parameter",
 "output": "#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
#include <occtio/OCCTTool.hpp>

using namespace AMCAX;

TEST_CASE(\"D1 with Parabola3\", \"[D1]\") {
	Parabola3 parabola(...);
	Point3 p;
	Vector3 v1;
	D1(1.0, parabola, p, v1);
	CHECK(p.X() == ...);
	CHECK(p.Y() == ...);
	CHECK(p.Z() == ...);
	CHECK(v1.X() == ...);
	CHECK(v1.Y() == ...);
	CHECK(v1.Z() == ...);
}"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] AMCAX_API static Vector3 D1(double u, const Hyperbola3& hyperbola)
	 @return The first derivative vector
	 @param hyperbola The hyperbola
	 @param u The parameter
	 @brief Compute the first derivative on a 3D hyperbola at a parameter",
 "output": "#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
#include <occtio/OCCTTool.hpp>

using namespace AMCAX;

TEST_CASE(\"D1 with Hyperbola3\", \"[D1]\") {
	Hyperbola3 hyperbola(...);
	Vector3 result = D1(1.0, hyperbola);
	CHECK(result.X() == ...);
	CHECK(result.Y() == ...);
	CHECK(result.Z() == ...);
}"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "AMCAX_API static void D1(double u, const Hyperbola3& hyperbola, Point3& p, Vector3& v1)
	 @param[out] v1 The first derivative
	 @param[out] p The point
	 @param[in] hyperbola The hyperbola
	 @param[in] u The parameter
	 @brief Compute the point and the first derivative on a 3D hyperbola at a parameter",
 "output": "#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
#include <occtio/OCCTTool.hpp>

using namespace AMCAX;

TEST_CASE(\"D1 with Hyperbola3\", \"[D1]\") {
	Hyperbola3 hyperbola(...);
	Point3 p;
	Vector3 v1;
	D1(1.0, hyperbola, p, v1);
	CHECK(p.X() == ...);
	CHECK(p.Y() == ...);
	CHECK(p.Z() == ...);
	CHECK(v1.X() == ...);
	CHECK(v1.Y() == ...);
	CHECK(v1.Z() == ...);
}"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] AMCAX_API static Vector2 D1(double u, const Line2& line)
	 @return The first derivative vector
	 @param line The line
	 @param u The parameter
	 @brief Compute the first derivative on a 2D line at a parameter",
 "output": "#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
#include <occtio/OCCTTool.hpp>

using namespace AMCAX;

TEST_CASE(\"D1 with Line2\", \"[D1\") {
	Line2 line(...);
	Vector2 result = D1(1.0, line);
	CHECK(result.X() == ...);
	CHECK(result.Y() == ...);
}"}
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "Cylinder()
 @brief Default constructor",
 "output": "#include <catch.hpp>
#include <testHelper.h>

#include <common/FrameT.hpp>
#include <modeling/MakeFace.hpp>
#include <common/AxisT.hpp>
#include <math/Cylinder.hpp>
#include <common/VectorT.hpp>
#include <occtio/OCCTTool.hpp>
#include <modeling/MakeCylinder.hpp>
#include <iostream>

using namespace AMCAX;
using namespace std;

TEST_CASE(\"case1:this is a case for Test Cylinder\", \"math][Cylinder][P1]\")

	Cylinder cylinder;
	CHECK(cylinder.Location().X() == Approx(0.0));
	CHECK(cylinder.Location().Y() == Approx(0.0));
	CHECK(cylinder.Location().Z() == Approx(0.0));"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "AMCAX_API Cylinder(const Frame3& frame, double r)
 @param r The radius
 @param frame The local frame
 @brief Construct from a local frame and a radius",
 "output": "#include <catch.hpp>
#include <testHelper.h>

#include <common/FrameT.hpp>
#include <modeling/MakeFace.hpp>
#include <common/AxisT.hpp>
#include <math/Cylinder.hpp>
#include <common/VectorT.hpp>
#include <occtio/OCCTTool.hpp>
#include <modeling/MakeCylinder.hpp>
#include <iostream>

using namespace AMCAX;
using namespace std;

TEST_CASE(\"case2:this is a case for Test Cylinder Constructor\", \"[math][Cylinder][P1]\")

	Frame3 frame;
	double radius = 5.0;
	Cylinder cylinder(frame, radius);
	CHECK(cylinder.Radius() == Approx(radius));
	CHECK(cylinder.Location().X() == Approx(0.0));
	CHECK(cylinder.Location().Y() == Approx(0.0));
	CHECK(cylinder.Location().Z() == Approx(0.0));"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "AMCAX_API Cylinder& Scale(const Point3& point, double scale)
 @return The reference to self
 @param scale The scale value
 @param point The scaling center point
 @brief Scale the cylinder by a point",
 "output": "#include <catch.hpp>
#include <testHelper.h>

#include <common/FrameT.hpp>
#include <modeling/MakeFace.hpp>
#include <common/AxisT.hpp>
#include <math/Cylinder.hpp>
#include <common/VectorT.hpp>
#include <occtio/OCCTTool.hpp>
#include <modeling/MakeCylinder.hpp>
#include <iostream>

using namespace AMCAX;
using namespace std;

TEST_CASE(\"case3:this is a case for Test Cylinder Scale\", \"[math][Cylinder][P1]\")

	Point3 point(6.0, 0.0, 0.0);
	double scaleValue = 2.0;
	Cylinder cylinder;
	cylinder.Scale(point, scaleValue);
	CHECK(cylinder.Radius() == Approx(10.0));"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "AMCAX_API Cylinder& Transform(const Transformation3& tr)
 @return The reference to self
 @param tr The transformation
 @brief Transform the cylinder",
 "output": "#include <catch.hpp>
#include <testHelper.h>

#include <common/FrameT.hpp>
#include <modeling/MakeFace.hpp>
#include <common/AxisT.hpp>
#include <math/Cylinder.hpp>
#include <common/VectorT.hpp>
#include <occtio/OCCTTool.hpp>
#include <modeling/MakeCylinder.hpp>
#include <iostream>

using namespace AMCAX;
using namespace std;

TEST_CASE(\"case4:this is a case for Test Cylinder Transform\", \"[math][Cylinder][P1\")

	Transformation3 tr;
	tr.SetTranslation(Vector3(1.0, 2.0, 3.0));
	Cylinder cylinder;
	cylinder.Transform(tr);
	CHECK(cylinder.Location().X() == Approx(1.0));
	CHECK(cylinder.Location().Y() == Approx(2.0));
	CHECK(cylinder.Location().Z() == Approx(3.0));"}
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[nodiscard]] double Area()	 @return The area of the ellipse
	 @brief Get the area of the ellipse
EllipseS& Scale(const PointT<double, DIM>& point, double scale)	 @return The reference to self
	 @param scale The scale value
	 @param point The scaling center point
	 @brief Scale the ellipse by a center point
EllipseS& Transform(const TransformationT<double, DIM>& tr)	 @return The reference to self
	 @param tr The transformation
	 @brief Transform the ellipse
",
 "output": "#include <catch.hpp>
#include <testHelper.h>

#include <math/EllipseT.hpp>
#include <geometry/Geom2Ellipse.hpp>

using namespace AMCAX;
using namespace std;

TEST_CASE(\"case1:this is a case for Test Geom2Ellipse\", \"[math][Geom2Ellipse][P1\")

	//Geom2Ellipse构造函数调用
	Axis2 axis;//默认二维坐标系中为X轴方向(1.0，0.0)
	double major = 5.0;
	double minor = 4.0;
	bool isRight = true;
	Ellipse2 ellipse(axis, major, minor, isRight);
	Geom2Ellipse g2e(ellipse);

	//FocalParameter()函数调用，获取焦点到圆锥曲线准线的距离
	SECTION(\"FocalParameter\")
	
		double FP = g2e.FocalParameter();
		double focal = 2 * sqrt(major * major - minor * minor);
		double fp = 2 * minor * minor / focal;;
		CHECK(FP == fp);
	

	//SemilatusRectum函数调用
	SECTION(\"SemilatusRectum\")
	
		double SR = g2e.SemilatusRectum();
		double sr = minor * minor / major;
		CHECK(SR == sr);
	


"}
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[nodiscard]] double Area()	 @return The area of the ellipse
	 @brief Get the area of the ellipse",
 "output": "#include <catch.hpp>
#include <testHelper.h>

#include <common/FrameT.hpp>
#include <math/EllipseT.hpp>
#include <geometry/Geom3Ellipse.hpp>

using namespace AMCAX;
using namespace std;

TEST_CASE(\"case1:this is a case for Test Geom3Ellipse\", \"[math][Geom3Ellipse][P1]\")

	//Geom3Ellipse构造函数调用
	Frame3 frame;
	double major = 5.0;
	double minor = 4.0;
	Ellipse3 ellipse(frame, major, minor);
	Geom3Ellipse g3e(ellipse);

	//FocalParameter()函数调用，获取焦点到圆锥曲线准线的距离
	SECTION(\"FocalParameter\")
	
		double FP = g3e.FocalParameter();
		double focal = 2 * sqrt(major * major - minor * minor);
		double fp = 2 * minor * minor / focal;;
		CHECK(FP == fp);
	

	//SemilatusRectum函数调用
	SECTION(\"SemilatusRectum\")
	
		double SR = g3e.SemilatusRectum();
		double sr = minor * minor / major;
		CHECK(SR == sr);
	

"}
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "EllipseS& Scale(const PointT<double, DIM>& point, double scale)	 @return The reference to self
	 @param scale The scale value
	 @param point The scaling center point
	 @brief Scale the ellipse by a center point",
 "output": "#include <catch.hpp>
#include <testHelper.h>

#include <common/FrameT.hpp>
#include <math/EllipseT.hpp>
#include <geometry/Geom3Ellipse.hpp>

using namespace AMCAX;
using namespace std;

TEST_CASE(\"case2: Test Scale method of Ellipse\", \"[math][Ellipse][Scale]\")

	Frame3 frame;
	EllipseS ellipse(frame);
	PointT<double, DIM> center(0.0, 0.0);
	double scale = 2.0;
	EllipseS& scaledEllipse = ellipse.Scale(center, scale);
	CHECK(&scaledEllipse == &ellipse);

"}
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "EllipseS& Transform(const TransformationT<double, DIM>& tr)	 @return The reference to self
	 @param tr The transformation
	 @brief Transform the ellipse",
 "output": "#include <catch.hpp>
#include <testHelper.h>

#include <common/FrameT.hpp>
#include <math/EllipseT.hpp>
#include <geometry/Geom3Ellipse.hpp>

using namespace AMCAX;
using namespace std;

TEST_CASE(\"case3: Test Transform method of Ellipse\", \"[math][Ellipse][Transform\")

	Frame3 frame;
	EllipseS ellipse(frame);
	TransformationT<double, DIM> transformation;
	EllipseS& transformedEllipse = ellipse.Transform(transformation);
	CHECK(&transformedEllipse == &ellipse);

"}
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[nodiscard]] double Area()	 @return The area of the ellipse
	 @brief Get the area of the ellipse",
 "output": "#include<catch.hpp>
#include<testHelper.h>
#include <geometry/MakeGeom3Ellipse.hpp>
#include <common/DirectionT.hpp>
#include <common/PointT.hpp>
#include <common/Precision.hpp>
#include <topology/TopoEdge.hpp>
#include <topology/TopoWire.hpp>
#include <topology/TopoFace.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeWire.hpp>
#include <modeling/MakeFace.hpp>
#include <modeling/MakePrism.hpp>
#include <topomesh/BRepMeshIncrementalMesh.hpp>
#include <topology/TopoExplorerTool.hpp>
#include <topology/TopoExplorer.hpp>
#include <topology/TopoCast.hpp>
#include <topology/TopoTool.hpp>
#include <math/TriangularMesh.hpp>

TEST_CASE(\"Calculate Area of Ellipse\", \"[geometry][MakeGeom3Ellipse]\")
{
	MakeGeom3Ellipse makeEllipse(Frame3(), 3.0, 1.0);
	double area = makeEllipse.Area();
	CHECK(area > 0);
}"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "EllipseS& Scale(const PointT<double, DIM>& point, double scale)	 @return The reference to self
	 @param scale The scale value
	 @param point The scaling center point
	 @brief Scale the ellipse by a center point",
 "output": "#include<catch.hpp>
#include<testHelper.h>
#include <geometry/MakeGeom3Ellipse.hpp>
#include <common/DirectionT.hpp>
#include <common/PointT.hpp>
#include <common/Precision.hpp>
#include <topology/TopoEdge.hpp>
#include <topology/TopoWire.hpp>
#include <topology/TopoFace.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeWire.hpp>
#include <modeling/MakeFace.hpp>
#include <modeling/MakePrism.hpp>
#include <topomesh/BRepMeshIncrementalMesh.hpp>
#include <topology/TopoExplorerTool.hpp>
#include <topology/TopoExplorer.hpp>
#include <topology/TopoCast.hpp>
#include <topology/TopoTool.hpp>
#include <math/TriangularMesh.hpp>

TEST_CASE(\"Scale Ellipse\", \"[geometry][MakeGeom3Ellipse]\")
{
	EllipseS ellipse;
	PointT<double, DIM> center(0.0, 0.0);
	double scale = 2.0;
	EllipseS& scaledEllipse = ellipse.Scale(center, scale);
	CHECK(&scaledEllipse == &ellipse);
}"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "EllipseS& Transform(const TransformationT<double, DIM>& tr)	 @return The reference to self
	 @param tr The transformation
	 @brief Transform the ellipse",
 "output": "#include<catch.hpp>
#include<testHelper.h>
#include <geometry/MakeGeom3Ellipse.hpp>
#include <common/DirectionT.hpp>
#include <common/PointT.hpp>
#include <common/Precision.hpp>
#include <topology/TopoEdge.hpp>
#include <topology/TopoWire.hpp>
#include <topology/TopoFace.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeWire.hpp>
#include <modeling/MakeFace.hpp>
#include <modeling/MakePrism.hpp>
#include <topomesh/BRepMeshIncrementalMesh.hpp>
#include <topology/TopoExplorerTool.hpp>
#include <topology/TopoExplorer.hpp>
#include <topology/TopoCast.hpp>
#include <topology/TopoTool.hpp>
#include <math/TriangularMesh.hpp>

TEST_CASE(\"Transform Ellipse\", \"[geometry][MakeGeom3Ellipse\")
{
	EllipseS ellipse;
	TransformationT<double, DIM> transformation;
	EllipseS& transformedEllipse = ellipse.Transform(transformation);
	CHECK(&transformedEllipse == &ellipse);
}"}
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[nodiscard]] double Area()
 @return The area of the ellipse
 @brief Get the area of the ellipse",
 "output": "#include <catch.hpp>
#include <testHelper.h>
#include <common/FrameT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <math/EllipseT.hpp>

TEST_CASE(\"case1:this is a case for Test Ellipse2\", \"[math][Ellipse2][P1]\")
	Axis2 axis;
	double major = 5.0;
	double minor = 4.0;
	Ellipse2 ellipse(axis, major, minor, true);
	CHECK(ellipse.Area() == Approx(M_PI * major * minor));"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "EllipseS& Scale(const PointT<double, DIM>& point, double scale)
 @return The reference to self
 @param scale The scale value
 @param point The scaling center point
 @brief Scale the ellipse by a center point",
 "output": "#include <catch.hpp>
#include <testHelper.h>
#include <common/FrameT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <math/EllipseT.hpp>

TEST_CASE(\"case3:this is a case for Test-Ellipse2-Scale\", \"[math][Ellipse2][P1]\")
	Point2 point(-1.0, -2.0);
	double scale = 0.5;
	Ellipse2 ellipse(axis, major, minor, true);
	Ellipse2 scale_ellipse = ellipse.Scale(point, scale);
	CHECK(scale_ellipse.Location() == Approx(Point2(2.5, -1.0)));
	CHECK(scale_ellipse.MajorRadius() == Approx(2.5));"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "EllipseS& Transform(const TransformationT<double, DIM>& tr)
 @return The reference to self
 @param tr The transformation
 @brief Transform the ellipse",
 "output": "#include <catch.hpp>
#include <testHelper.h>
#include <common/FrameT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <math/EllipseT.hpp>

TEST_CASE(\"case4:this is a case for Test-Ellipse2-Transform\", \"[math][Ellipse2][P1\")
	TransformationT<double, DIM> tr;
	tr.SetTranslation(Vector2(-1.0, -2.0));
	Ellipse2 ellipse(axis, major, minor, true);
	Ellipse2 transformed_ellipse = ellipse.Transform(tr);
	CHECK(transformed_ellipse.Location().X() == Approx(5.0));
	CHECK(transformed_ellipse.Location().Y() == Approx(-2.0));"}
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[nodiscard]] double Area()	 @return The area of the ellipse
	 @brief Get the area of the ellipse
",
 "output": "#include <catch.hpp>
#include <testHelper.h>

#include <common/FrameT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <math/EllipseT.hpp>

using namespace AMCAX;
using namespace std;

TEST_CASE(\"case1:this is a case for Test Ellipse3\", \"[math][Ellipse3][P1]\")
	Frame3 frame;
	double major = 5.0;
	double minor = 4.0;
	Ellipse3 ellipse(frame, major, minor);
	SECTION(\"Area\")
		double S = ellipse.Area();
		CHECK(S == Approx(M_PI * major * minor));
"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "EllipseS& Scale(const PointT<double, DIM>& point, double scale)	 @return The reference to self
	 @param scale The scale value
	 @param point The scaling center point
	 @brief Scale the ellipse by a center point
",
 "output": "#include <catch.hpp>
#include <testHelper.h>

#include <common/FrameT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <math/EllipseT.hpp>

using namespace AMCAX;
using namespace std;

TEST_CASE(\"case1:this is a case for Test Ellipse3 Scale\", \"[math][Ellipse3][P1]\")
	Point3 point(6.0, 6.0, 6.0);
	double scale = 0.5;
	Ellipse3 ellipse(frame, major, minor);
	SECTION(\"Scale\")
		Ellipse3 scale_ellipse = ellipse.Scale(point, scale);
		CHECK(ellipse.Location().X() == Approx(6.0));
		CHECK(ellipse.Location().Y() == Approx(0.0));
		CHECK(ellipse.Location().Z() == Approx(6.0));
		CHECK(ellipse.MajorRadius() == Approx(2.5));
		CHECK(ellipse.MinorRadius() == Approx(2.0));
"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "EllipseS& Transform(const TransformationT<double, DIM>& tr)	 @return The reference to self
	 @param tr The transformation
	 @brief Transform the ellipse
",
 "output": "#include <catch.hpp>
#include <testHelper.h>

#include <common/FrameT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <math/EllipseT.hpp>

using namespace AMCAX;
using namespace std;

TEST_CASE(\"case1:this is a case for Test Ellipse3 Transform\", \"[math][Ellipse3][P1\")
	Transformation3 tr;
	tr.SetTranslation(Vector3(-1.0, -2.0, -3.0));
	Ellipse3 Transfor_ellipse = ellipse.Transform(tr);
	CHECK(ellipse.Location().X() == Approx(5.0));
	CHECK(ellipse.Location().Y() == Approx(-2.0));
	CHECK(ellipse.Location().Z() == Approx(3.0));
	CHECK(Transfor_ellipse.Location().X() == Approx(5.0));
	CHECK(Transfor_ellipse.Location().Y() == Approx(-2.0));
	CHECK(Transfor_ellipse.Location().Z() == Approx(3.0));
"}
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "void SetMajorRadius(double r)	 @param r The new major radius
	 @brief Set the major radius
",
 "output": "#include <catch.hpp>
#include <testHelper.h>

#include <math/EllipseT.hpp>
#include <geometry/Geom2Hyperbola.hpp>

using namespace AMCAX;
using namespace std;

TEST_CASE(\"case1:this is a case for Test Geom2Hyperbola\", \"math][Geom2Hyperbola][P1]\")

	//Geom2Hyperbola构造函数调用
	Axis2 axis;//默认二维坐标系中为X轴方向(1.0，0.0)
	double major = 5.0;
	double minor = 4.0;
	bool isRight = true;
	Geom2Hyperbola g2h(axis, major, minor, isRight);

	//FocalParameter()函数调用，获取焦点到圆锥曲线准线的距离
	SECTION(\"FocalParameter\")
	
		double FP = g2h.FocalParameter();
		double focal = 2 * sqrt(major * major + minor * minor);
		double fp = 2 * minor * minor / focal;;
		CHECK(FP == fp);
	

	//SemilatusRectum函数调用
	SECTION(\"SemilatusRectum\")
	
		double SR = g2h.SemilatusRectum();
		double sr = minor * minor / major;
		CHECK(SR == sr);
	


"}
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "void SetMinorRadius(double r)	 @param r The new minor radius
	 @brief Set the minor radius
",
 "output": "#include <catch.hpp>
#include <testHelper.h>

#include <math/EllipseT.hpp>
#include <geometry/Geom2Hyperbola.hpp>

using namespace AMCAX;
using namespace std;

TEST_CASE(\"case1:this is a case for Test Geom2Hyperbola\", \"[math][Geom2Hyperbola][P1]\")

	//Geom2Hyperbola构造函数调用
	Axis2 axis;//默认二维坐标系中为X轴方向(1.0，0.0)
	double major = 5.0;
	double minor = 4.0;
	bool isRight = true;
	Geom2Hyperbola g2h(axis, major, minor, isRight);

	//FocalParameter()函数调用，获取焦点到圆锥曲线准线的距离
	SECTION(\"FocalParameter\")
	
		double FP = g2h.FocalParameter();
		double focal = 2 * sqrt(major * major + minor * minor);
		double fp = 2 * minor * minor / focal;;
		CHECK(FP == fp);
	

	//SemilatusRectum函数调用
	SECTION(\"SemilatusRectum\")
	
		double SR = g2h.SemilatusRectum();
		double sr = minor * minor / major;
		CHECK(SR == sr);
	


"}
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] AxisT<double, DIM> Directrix1()	 @return The positive directrix
	 @brief Get the directrix on the positive side of the major axis
",
 "output": "#include <catch.hpp>
#include <testHelper.h>

#include <math/EllipseT.hpp>
#include <geometry/Geom2Hyperbola.hpp>

using namespace AMCAX;
using namespace std;

TEST_CASE(\"case1:this is a case for Test Geom2Hyperbola\", \"[math][Geom2Hyperbola][P1]\")

	//Geom2Hyperbola构造函数调用
	Axis2 axis;//默认二维坐标系中为X轴方向(1.0，0.0)
	double major = 5.0;
	double minor = 4.0;
	bool isRight = true;
	Geom2Hyperbola g2h(axis, major, minor, isRight);

	//FocalParameter()函数调用，获取焦点到圆锥曲线准线的距离
	SECTION(\"FocalParameter\")
	
		double FP = g2h.FocalParameter();
		double focal = 2 * sqrt(major * major + minor * minor);
		double fp = 2 * minor * minor / focal;;
		CHECK(FP == fp);
	

	//SemilatusRectum函数调用
	SECTION(\"SemilatusRectum\")
	
		double SR = g2h.SemilatusRectum();
		double sr = minor * minor / major;
		CHECK(SR == sr);
	


"}
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] AxisT<double, DIM> Directrix2()	 @return The negative directrix
	 @brief Get the directrix on the negative side of the major axis
",
 "output": "#include <catch.hpp>
#include <testHelper.h>

#include <math/EllipseT.hpp>
#include <geometry/Geom2Hyperbola.hpp>

using namespace AMCAX;
using namespace std;

TEST_CASE(\"case1:this is a case for Test Geom2Hyperbola\", \"[math][Geom2Hyperbola][P1]\")

	//Geom2Hyperbola构造函数调用
	Axis2 axis;//默认二维坐标系中为X轴方向(1.0，0.0)
	double major = 5.0;
	double minor = 4.0;
	bool isRight = true;
	Geom2Hyperbola g2h(axis, major, minor, isRight);

	//FocalParameter()函数调用，获取焦点到圆锥曲线准线的距离
	SECTION(\"FocalParameter\")
	
		double FP = g2h.FocalParameter();
		double focal = 2 * sqrt(major * major + minor * minor);
		double fp = 2 * minor * minor / focal;;
		CHECK(FP == fp);
	

	//SemilatusRectum函数调用
	SECTION(\"SemilatusRectum\")
	
		double SR = g2h.SemilatusRectum();
		double sr = minor * minor / major;
		CHECK(SR == sr);
	


"}
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] double Eccentricity()	 @return The eccentricity
	 @brief Get the eccentricity of the ellipse
",
 "output": "#include <catch.hpp>
#include <testHelper.h>

#include <math/EllipseT.hpp>
#include <geometry/Geom2Hyperbola.hpp>

using namespace AMCAX;
using namespace std;

TEST_CASE(\"case1:this is a case for Test Geom2Hyperbola\", \"[math][Geom2Hyperbola][P1]\")

	//Geom2Hyperbola构造函数调用
	Axis2 axis;//默认二维坐标系中为X轴方向(1.0，0.0)
	double major = 5.0;
	double minor = 4.0;
	bool isRight = true;
	Geom2Hyperbola g2h(axis, major, minor, isRight);

	//FocalParameter()函数调用，获取焦点到圆锥曲线准线的距离
	SECTION(\"FocalParameter\")
	
		double FP = g2h.FocalParameter();
		double focal = 2 * sqrt(major * major + minor * minor);
		double fp = 2 * minor * minor / focal;;
		CHECK(FP == fp);
	

	//SemilatusRectum函数调用
	SECTION(\"SemilatusRectum\")
	
		double SR = g2h.SemilatusRectum();
		double sr = minor * minor / major;
		CHECK(SR == sr);
	


"}
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] PointT<double, DIM> Focus1()	 @return The positive focus
	 @brief Get the focus on the positive side of the major axis
",
 "output": "#include <catch.hpp>
#include <testHelper.h>

#include <math/EllipseT.hpp>
#include <geometry/Geom2Hyperbola.hpp>

using namespace AMCAX;
using namespace std;

TEST_CASE(\"case1:this is a case for Test Geom2Hyperbola\", \"[math][Geom2Hyperbola][P1]\")

	//Geom2Hyperbola构造函数调用
	Axis2 axis;//默认二维坐标系中为X轴方向(1.0，0.0)
	double major = 5.0;
	double minor = 4.0;
	bool isRight = true;
	Geom2Hyperbola g2h(axis, major, minor, isRight);

	//FocalParameter()函数调用，获取焦点到圆锥曲线准线的距离
	SECTION(\"FocalParameter\")
	
		double FP = g2h.FocalParameter();
		double focal = 2 * sqrt(major * major + minor * minor);
		double fp = 2 * minor * minor / focal;;
		CHECK(FP == fp);
	

	//SemilatusRectum函数调用
	SECTION(\"SemilatusRectum\")
	
		double SR = g2h.SemilatusRectum();
		double sr = minor * minor / major;
		CHECK(SR == sr);
	


"}
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] PointT<double, DIM> Focus2()	 @return The negative focus
	 @brief Get the focus on the negative side of the major axis
",
 "output": "#include <catch.hpp>
#include <testHelper.h>

#include <math/EllipseT.hpp>
#include <geometry/Geom2Hyperbola.hpp>

using namespace AMCAX;
using namespace std;

TEST_CASE(\"case1:this is a case for Test Geom2Hyperbola\", \"[math][Geom2Hyperbola][P1]\")

	//Geom2Hyperbola构造函数调用
	Axis2 axis;//默认二维坐标系中为X轴方向(1.0，0.0)
	double major = 5.0;
	double minor = 4.0;
	bool isRight = true;
	Geom2Hyperbola g2h(axis, major, minor, isRight);

	//FocalParameter()函数调用，获取焦点到圆锥曲线准线的距离
	SECTION(\"FocalParameter\")
	
		double FP = g2h.FocalParameter();
		double focal = 2 * sqrt(major * major + minor * minor);
		double fp = 2 * minor * minor / focal;;
		CHECK(FP == fp);
	

	//SemilatusRectum函数调用
	SECTION(\"SemilatusRectum\")
	
		double SR = g2h.SemilatusRectum();
		double sr = minor * minor / major;
		CHECK(SR == sr);
	


"}
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] double MajorRadius()	 @return The major radius
	 @brief Get the major radius
",
 "output": "#include <catch.hpp>
#include <testHelper.h>

#include <math/EllipseT.hpp>
#include <geometry/Geom2Hyperbola.hpp>

using namespace AMCAX;
using namespace std;

TEST_CASE(\"case1:this is a case for Test Geom2Hyperbola\", \"[math][Geom2Hyperbola][P1]\")

	//Geom2Hyperbola构造函数调用
	Axis2 axis;//默认二维坐标系中为X轴方向(1.0，0.0)
	double major = 5.0;
	double minor = 4.0;
	bool isRight = true;
	Geom2Hyperbola g2h(axis, major, minor, isRight);

	//FocalParameter()函数调用，获取焦点到圆锥曲线准线的距离
	SECTION(\"FocalParameter\")
	
		double FP = g2h.FocalParameter();
		double focal = 2 * sqrt(major * major + minor * minor);
		double fp = 2 * minor * minor / focal;;
		CHECK(FP == fp);
	

	//SemilatusRectum函数调用
	SECTION(\"SemilatusRectum\")
	
		double SR = g2h.SemilatusRectum();
		double sr = minor * minor / major;
		CHECK(SR == sr);
	


"}
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] double MinorRadius()	 @return The minor radius
	 @brief Get the minor radius
",
 "output": "#include <catch.hpp>
#include <testHelper.h>

#include <math/EllipseT.hpp>
#include <geometry/Geom2Hyperbola.hpp>

using namespace AMCAX;
using namespace std;

TEST_CASE(\"case1:this is a case for Test Geom2Hyperbola\", \"[math][Geom2Hyperbola][P1]\")

	//Geom2Hyperbola构造函数调用
	Axis2 axis;//默认二维坐标系中为X轴方向(1.0，0.0)
	double major = 5.0;
	double minor = 4.0;
	bool isRight = true;
	Geom2Hyperbola g2h(axis, major, minor, isRight);

	//FocalParameter()函数调用，获取焦点到圆锥曲线准线的距离
	SECTION(\"FocalParameter\")
	
		double FP = g2h.FocalParameter();
		double focal = 2 * sqrt(major * major + minor * minor);
		double fp = 2 * minor * minor / focal;;
		CHECK(FP == fp);
	

	//SemilatusRectum函数调用
	SECTION(\"SemilatusRectum\")
	
		double SR = g2h.SemilatusRectum();
		double sr = minor * minor / major;
		CHECK(SR == sr);
	


"}
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] AxisT<double, DIM> Asymptote1()	 @return The positive asymptote
	 @brief Get the asymptote of the hyperbola with positive slope
",
 "output": "#include <catch.hpp>
#include <testHelper.h>

#include <math/EllipseT.hpp>
#include <geometry/Geom2Hyperbola.hpp>

using namespace AMCAX;
using namespace std;

TEST_CASE(\"case1:this is a case for Test Geom2Hyperbola\", \"[math][Geom2Hyperbola][P1]\")

	//Geom2Hyperbola构造函数调用
	Axis2 axis;//默认二维坐标系中为X轴方向(1.0，0.0)
	double major = 5.0;
	double minor = 4.0;
	bool isRight = true;
	Geom2Hyperbola g2h(axis, major, minor, isRight);

	//FocalParameter()函数调用，获取焦点到圆锥曲线准线的距离
	SECTION(\"FocalParameter\")
	
		double FP = g2h.FocalParameter();
		double focal = 2 * sqrt(major * major + minor * minor);
		double fp = 2 * minor * minor / focal;;
		CHECK(FP == fp);
	

	//SemilatusRectum函数调用
	SECTION(\"SemilatusRectum\")
	
		double SR = g2h.SemilatusRectum();
		double sr = minor * minor / major;
		CHECK(SR == sr);
	


"}
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] AxisT<double, DIM> Asymptote2()	 @return The negative asymptote
	 @brief Get the asymptote of the hyperbola with negative slope
",
 "output": "#include <catch.hpp>
#include <testHelper.h>

#include <math/EllipseT.hpp>
#include <geometry/Geom2Hyperbola.hpp>

using namespace AMCAX;
using namespace std;

TEST_CASE(\"case1:this is a case for Test Geom2Hyperbola\", \"[math][Geom2Hyperbola][P1]\")

	//Geom2Hyperbola构造函数调用
	Axis2 axis;//默认二维坐标系中为X轴方向(1.0，0.0)
	double major = 5.0;
	double minor = 4.0;
	bool isRight = true;
	Geom2Hyperbola g2h(axis, major, minor, isRight);

	//FocalParameter()函数调用，获取焦点到圆锥曲线准线的距离
	SECTION(\"FocalParameter\")
	
		double FP = g2h.FocalParameter();
		double focal = 2 * sqrt(major * major + minor * minor);
		double fp = 2 * minor * minor / focal;;
		CHECK(FP == fp);
	

	//SemilatusRectum函数调用
	SECTION(\"SemilatusRectum\")
	
		double SR = g2h.SemilatusRectum();
		double sr = minor * minor / major;
		CHECK(SR == sr);
	


"}
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] HyperbolaS ConjugateBranch1()	 @return The positive conjugate hyperbola
	 @brief Get the conjugate hyperbola on the positive side of the minor axis
",
 "output": "#include <catch.hpp>
#include <testHelper.h>

#include <math/EllipseT.hpp>
#include <geometry/Geom2Hyperbola.hpp>

using namespace AMCAX;
using namespace std;

TEST_CASE(\"case1:this is a case for Test Geom2Hyperbola\", \"[math][Geom2Hyperbola][P1]\")

	//Geom2Hyperbola构造函数调用
	Axis2 axis;//默认二维坐标系中为X轴方向(1.0，0.0)
	double major = 5.0;
	double minor = 4.0;
	bool isRight = true;
	Geom2Hyperbola g2h(axis, major, minor, isRight);

	//FocalParameter()函数调用，获取焦点到圆锥曲线准线的距离
	SECTION(\"FocalParameter\")
	
		double FP = g2h.FocalParameter();
		double focal = 2 * sqrt(major * major + minor * minor);
		double fp = 2 * minor * minor / focal;;
		CHECK(FP == fp);
	

	//SemilatusRectum函数调用
	SECTION(\"SemilatusRectum\")
	
		double SR = g2h.SemilatusRectum();
		double sr = minor * minor / major;
		CHECK(SR == sr);
	


"}
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] HyperbolaS ConjugateBranch2()	 @return The negative conjugate hyperbola
	 @brief Get the conjugate hyperbola on the negative side of the minor axis
",
 "output": "#include <catch.hpp>
#include <testHelper.h>

#include <math/EllipseT.hpp>
#include <geometry/Geom2Hyperbola.hpp>

using namespace AMCAX;
using namespace std;

TEST_CASE(\"case1:this is a case for Test Geom2Hyperbola\", \"[math][Geom2Hyperbola][P1]\")

	//Geom2Hyperbola构造函数调用
	Axis2 axis;//默认二维坐标系中为X轴方向(1.0，0.0)
	double major = 5.0;
	double minor = 4.0;
	bool isRight = true;
	Geom2Hyperbola g2h(axis, major, minor, isRight);

	//FocalParameter()函数调用，获取焦点到圆锥曲线准线的距离
	SECTION(\"FocalParameter\")
	
		double FP = g2h.FocalParameter();
		double focal = 2 * sqrt(major * major + minor * minor);
		double fp = 2 * minor * minor / focal;;
		CHECK(FP == fp);
	

	//SemilatusRectum函数调用
	SECTION(\"SemilatusRectum\")
	
		double SR = g2h.SemilatusRectum();
		double sr = minor * minor / major;
		CHECK(SR == sr);
	


"}
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] HyperbolaS OtherBranch()	 @return The hyperbola of the other branch
	 @brief Get the other branch of the hyperbola
",
 "output": "#include <catch.hpp>
#include <testHelper.h>

#include <math/EllipseT.hpp>
#include <geometry/Geom2Hyperbola.hpp>

using namespace AMCAX;
using namespace std;

TEST_CASE(\"case1:this is a case for Test Geom2Hyperbola\", \"[math][Geom2Hyperbola][P1]\")

	//Geom2Hyperbola构造函数调用
	Axis2 axis;//默认二维坐标系中为X轴方向(1.0，0.0)
	double major = 5.0;
	double minor = 4.0;
	bool isRight = true;
	Geom2Hyperbola g2h(axis, major, minor, isRight);

	//FocalParameter()函数调用，获取焦点到圆锥曲线准线的距离
	SECTION(\"FocalParameter\")
	
		double FP = g2h.FocalParameter();
		double focal = 2 * sqrt(major * major + minor * minor);
		double fp = 2 * minor * minor / focal;;
		CHECK(FP == fp);
	

	//SemilatusRectum函数调用
	SECTION(\"SemilatusRectum\")
	
		double SR = g2h.SemilatusRectum();
		double sr = minor * minor / major;
		CHECK(SR == sr);
	


"}
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "HyperbolaS& Scale(const PointT<double, DIM>& point, double scale)	 @return The reference to self
	 @param scale The scale value
	 @param point The scaling center point
	 @brief Scale the hyperbola by a center point
",
 "output": "#include <catch.hpp>
#include <testHelper.h>

#include <math/EllipseT.hpp>
#include <geometry/Geom2Hyperbola.hpp>

using namespace AMCAX;
using namespace std;

TEST_CASE(\"case1:this is a case for Test Geom2Hyperbola\", \"[math][Geom2Hyperbola][P1]\")

	//Geom2Hyperbola构造函数调用
	Axis2 axis;//默认二维坐标系中为X轴方向(1.0，0.0)
	double major = 5.0;
	double minor = 4.0;
	bool isRight = true;
	Geom2Hyperbola g2h(axis, major, minor, isRight);

	//FocalParameter()函数调用，获取焦点到圆锥曲线准线的距离
	SECTION(\"FocalParameter\")
	
		double FP = g2h.FocalParameter();
		double focal = 2 * sqrt(major * major + minor * minor);
		double fp = 2 * minor * minor / focal;;
		CHECK(FP == fp);
	

	//SemilatusRectum函数调用
	SECTION(\"SemilatusRectum\")
	
		double SR = g2h.SemilatusRectum();
		double sr = minor * minor / major;
		CHECK(SR == sr);
	


"}
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "HyperbolaS& Transform(const TransformationT<double, DIM>& tr)	 @return The reference to self
	 @param tr The transformation
	 @brief Transform the hyperbola
",
 "output": "#include <catch.hpp>
#include <testHelper.h>

#include <math/EllipseT.hpp>
#include <geometry/Geom2Hyperbola.hpp>

using namespace AMCAX;
using namespace std;

TEST_CASE(\"case1:this is a case for Test Geom2Hyperbola\", \"[math][Geom2Hyperbola][P1\")

	//Geom2Hyperbola构造函数调用
	Axis2 axis;//默认二维坐标系中为X轴方向(1.0，0.0)
	double major = 5.0;
	double minor = 4.0;
	bool isRight = true;
	Geom2Hyperbola g2h(axis, major, minor, isRight);

	//FocalParameter()函数调用，获取焦点到圆锥曲线准线的距离
	SECTION(\"FocalParameter\")
	
		double FP = g2h.FocalParameter();
		double focal = 2 * sqrt(major * major + minor * minor);
		double fp = 2 * minor * minor / focal;;
		CHECK(FP == fp);
	

	//SemilatusRectum函数调用
	SECTION(\"SemilatusRectum\")
	
		double SR = g2h.SemilatusRectum();
		double sr = minor * minor / major;
		CHECK(SR == sr);
	


"}
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "void SetMajorRadius(double r)	 @param r The new major radius
	 @brief Set the major radius
void SetMinorRadius(double r)	 @param r The new minor radius
	 @brief Set the minor radius
",
 "output": "#include <catch.hpp>
#include <testHelper.h>

#include <math/EllipseT.hpp>
#include <geometry/Geom3Hyperbola.hpp>

using namespace AMCAX;
using namespace std;

TEST_CASE(\"case1:this is a case for Test Geom3Hyperbola\", \"math][Geom3Hyperbola][P1]\")

	Frame3 frame;
	double major = 5.0;
	double minor = 4.0;
	Geom3Hyperbola g3h(frame, major, minor);
"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] AxisT<double, DIM> Directrix1()	 @return The positive directrix
	 @brief Get the directrix on the positive side of the major axis
[[nodiscard]] AxisT<double, DIM> Directrix2()	 @return The negative directrix
	 @brief Get the directrix on the negative side of the major axis
",
 "output": "#include <catch.hpp>
#include <testHelper.h>

#include <math/EllipseT.hpp>
#include <geometry/Geom3Hyperbola.hpp>

using namespace AMCAX;
using namespace std;

TEST_CASE(\"case1:this is a case for Test Geom3Hyperbola\", \"[math][Geom3Hyperbola][P1]\")

	Frame3 frame;
	double major = 5.0;
	double minor = 4.0;
	Geom3Hyperbola g3h(frame, major, minor);
"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] double Eccentricity()	 @return The eccentricity
	 @brief Get the eccentricity of the ellipse
[[nodiscard]] PointT<double, DIM> Focus1()	 @return The positive focus
	 @brief Get the focus on the positive side of the major axis
",
 "output": "#include <catch.hpp>
#include <testHelper.h>

#include <math/EllipseT.hpp>
#include <geometry/Geom3Hyperbola.hpp>

using namespace AMCAX;
using namespace std;

TEST_CASE(\"case1:this is a case for Test Geom3Hyperbola\", \"[math][Geom3Hyperbola][P1]\")

	Frame3 frame;
	double major = 5.0;
	double minor = 4.0;
	Geom3Hyperbola g3h(frame, major, minor);
"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] double MajorRadius()	 @return The major radius
	 @brief Get the major radius
[[nodiscard]] double MinorRadius()	 @return The minor radius
	 @brief Get the minor radius
",
 "output": "#include <catch.hpp>
#include <testHelper.h>

#include <math/EllipseT.hpp>
#include <geometry/Geom3Hyperbola.hpp>

using namespace AMCAX;
using namespace std;

TEST_CASE(\"case1:this is a case for Test Geom3Hyperbola\", \"[math][Geom3Hyperbola][P1]\")

	Frame3 frame;
	double major = 5.0;
	double minor = 4.0;
	Geom3Hyperbola g3h(frame, major, minor);
"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] AxisT<double, DIM> Asymptote1()	 @return The positive asymptote
	 @brief Get the asymptote of the hyperbola with positive slope
[[nodiscard]] AxisT<double, DIM> Asymptote2()	 @return The negative asymptote
	 @brief Get the asymptote of the hyperbola with negative slope
",
 "output": "#include <catch.hpp>
#include <testHelper.h>

#include <math/EllipseT.hpp>
#include <geometry/Geom3Hyperbola.hpp>

using namespace AMCAX;
using namespace std;

TEST_CASE(\"case1:this is a case for Test Geom3Hyperbola\", \"[math][Geom3Hyperbola][P1]\")

	Frame3 frame;
	double major = 5.0;
	double minor = 4.0;
	Geom3Hyperbola g3h(frame, major, minor);
"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] HyperbolaS ConjugateBranch1()	 @return The positive conjugate hyperbola
	 @brief Get the conjugate hyperbola on the positive side of the minor axis
[[nodiscard]] HyperbolaS ConjugateBranch2()	 @return The negative conjugate hyperbola
	 @brief Get the conjugate hyperbola on the negative side of the minor axis
",
 "output": "#include <catch.hpp>
#include <testHelper.h>

#include <math/EllipseT.hpp>
#include <geometry/Geom3Hyperbola.hpp>

using namespace AMCAX;
using namespace std;

TEST_CASE(\"case1:this is a case for Test Geom3Hyperbola\", \"[math][Geom3Hyperbola][P1]\")

	Frame3 frame;
	double major = 5.0;
	double minor = 4.0;
	Geom3Hyperbola g3h(frame, major, minor);
"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] HyperbolaS OtherBranch()	 @return The hyperbola of the other branch
	 @brief Get the other branch of the hyperbola
HyperbolaS& Scale(const PointT<double, DIM>& point, double scale)	 @return The reference to self
	 @param scale The scale value
	 @param point The scaling center point
	 @brief Scale the hyperbola by a center point
",
 "output": "#include <catch.hpp>
#include <testHelper.h>

#include <math/EllipseT.hpp>
#include <geometry/Geom3Hyperbola.hpp>

using namespace AMCAX;
using namespace std;

TEST_CASE(\"case1:this is a case for Test Geom3Hyperbola\", \"[math][Geom3Hyperbola][P1]\")

	Frame3 frame;
	double major = 5.0;
	double minor = 4.0;
	Geom3Hyperbola g3h(frame, major, minor);
"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "HyperbolaS& Transform(const TransformationT<double, DIM>& tr)	 @return The reference to self
	 @param tr The transformation
	 @brief Transform the hyperbola
",
 "output": "#include <catch.hpp>
#include <testHelper.h>

#include <math/EllipseT.hpp>
#include <geometry/Geom3Hyperbola.hpp>

using namespace AMCAX;
using namespace std;

TEST_CASE(\"case1:this is a case for Test Geom3Hyperbola\", \"[math][Geom3Hyperbola][P1\")

	Frame3 frame;
	double major = 5.0;
	double minor = 4.0;
	Geom3Hyperbola g3h(frame, major, minor);
"}
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "void SetMajorRadius(double r)\	 @param r The new major radius\
\	 @brief Set the major radius\
",
 "output": "#include <catch.hpp>\
#include <testHelper.h>\
...\
\
TEST_CASE(\"case1:this is a case for Hyperbola2\", \"math][Hyperbola2][p1]\") \
\	//Construct hyperbola2d_ax\
\	Point2 point2_Hy(0.0, 0.0);\
\	Direction2 dir2_Hy(1.0, 0.0);\
\	Axis2 major2_Axis(point2_Hy, dir2_Hy);\
\	double major2 = 3.0, minor2 = 4.0;\
\	Hyperbola2 hyperbola2d_ax(major2_Axis, major2, minor2, true);\
\	hyperbola2d_ax.SetMajorRadius(4.0);\
\	CHECK(hyperbola2d_ax.MajorRadius() == Approx(4.0));"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "void SetMinorRadius(double r)\	 @param r The new minor radius\
\	 @brief Set the minor radius\
",
 "output": "#include <catch.hpp>\
#include <testHelper.h>\
...\
\
TEST_CASE(\"case1:this is a case for Hyperbola2\", \"[math][Hyperbola2][p1]\") \
\	//Construct hyperbola2d_ax\
\	Point2 point2_Hy(0.0, 0.0);\
\	Direction2 dir2_Hy(1.0, 0.0);\
\	Axis2 major2_Axis(point2_Hy, dir2_Hy);\
\	double major2 = 3.0, minor2 = 4.0;\
\	Hyperbola2 hyperbola2d_ax(major2_Axis, major2, minor2, true);\
\	hyperbola2d_ax.SetMinorRadius(3.0);\
\	CHECK(hyperbola2d_ax.MinorRadius() == Approx(3.0));"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] AxisT<double, DIM> Directrix1()\	 @return The positive directrix\
\	 @brief Get the directrix on the positive side of the major axis\
",
 "output": "#include <catch.hpp>\
#include <testHelper.h>\
...\
\
TEST_CASE(\"case1:this is a case for Hyperbola2\", \"[math][Hyperbola2][p1]\") \
\	//Construct hyperbola2d_ax\
\	Point2 point2_Hy(0.0, 0.0);\
\	Direction2 dir2_Hy(1.0, 0.0);\
\	Axis2 major2_Axis(point2_Hy, dir2_Hy);\
\	double major2 = 3.0, minor2 = 4.0;\
\	Hyperbola2 hyperbola2d_ax(major2_Axis, major2, minor2, true);\
\	AxisT<double, DIM> directrix = hyperbola2d_ax.Directrix1();\
\	CHECK(directrix.Direction().X() == Approx(0.0));"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] AxisT<double, DIM> Directrix2()\	 @return The negative directrix\
\	 @brief Get the directrix on the negative side of the major axis\
",
 "output": "#include <catch.hpp>\
#include <testHelper.h>\
...\
\
TEST_CASE(\"case1:this is a case for Hyperbola2\", \"[math][Hyperbola2][p1]\") \
\	//Construct hyperbola2d_ax\
\	Point2 point2_Hy(0.0, 0.0);\
\	Direction2 dir2_Hy(1.0, 0.0);\
\	Axis2 major2_Axis(point2_Hy, dir2_Hy);\
\	double major2 = 3.0, minor2 = 4.0;\
\	Hyperbola2 hyperbola2d_ax(major2_Axis, major2, minor2, true);\
\	AxisT<double, DIM> directrix = hyperbola2d_ax.Directrix2();\
\	CHECK(directrix.Direction().X() == Approx(0.0));"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] double Eccentricity()\	 @return The eccentricity\
\	 @brief Get the eccentricity of the ellipse\
",
 "output": "#include <catch.hpp>\
#include <testHelper.h>\
...\
\
TEST_CASE(\"case1:this is a case for Hyperbola2\", \"[math][Hyperbola2][p1]\") \
\	//Construct hyperbola2d_ax\
\	Point2 point2_Hy(0.0, 0.0);\
\	Direction2 dir2_Hy(1.0, 0.0);\
\	Axis2 major2_Axis(point2_Hy, dir2_Hy);\
\	double major2 = 3.0, minor2 = 4.0;\
\	Hyperbola2 hyperbola2d_ax(major2_Axis, major2, minor2, true);\
\	double eccentricity = hyperbola2d_ax.Eccentricity();\
\	CHECK(eccentricity == Approx(5.0 / 3.0));"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] PointT<double, DIM> Focus1()\	 @return The positive focus\
\	 @brief Get the focus on the positive side of the major axis\
",
 "output": "#include <catch.hpp>\
#include <testHelper.h>\
...\
\
TEST_CASE(\"case1:this is a case for Hyperbola2\", \"[math][Hyperbola2][p1]\") \
\	//Construct hyperbola2d_ax\
\	Point2 point2_Hy(0.0, 0.0);\
\	Direction2 dir2_Hy(1.0, 0.0);\
\	Axis2 major2_Axis(point2_Hy, dir2_Hy);\
\	double major2 = 3.0, minor2 = 4.0;\
\	Hyperbola2 hyperbola2d_ax(major2_Axis, major2, minor2, true);\
\	PointT<double, DIM> focus = hyperbola2d_ax.Focus1();\
\	CHECK(focus.X() == Approx(5.0));"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] PointT<double, DIM> Focus2()\	 @return The negative focus\
\	 @brief Get the focus on the negative side of the major axis\
",
 "output": "#include <catch.hpp>\
#include <testHelper.h>\
...\
\
TEST_CASE(\"case1:this is a case for Hyperbola2\", \"[math][Hyperbola2][p1]\") \
\	//Construct hyperbola2d_ax\
\	Point2 point2_Hy(0.0, 0.0);\
\	Direction2 dir2_Hy(1.0, 0.0);\
\	Axis2 major2_Axis(point2_Hy, dir2_Hy);\
\	double major2 = 3.0, minor2 = 4.0;\
\	Hyperbola2 hyperbola2d_ax(major2_Axis, major2, minor2, true);\
\	PointT<double, DIM> focus = hyperbola2d_ax.Focus2();\
\	CHECK(focus.X() == Approx(-5.0));"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] double MajorRadius()\	 @return The major radius\
\	 @brief Get the major radius\
",
 "output": "#include <catch.hpp>\
#include <testHelper.h>\
...\
\
TEST_CASE(\"case1:this is a case for Hyperbola2\", \"[math][Hyperbola2][p1]\") \
\	//Construct hyperbola2d_ax\
\	Point2 point2_Hy(0.0, 0.0);\
\	Direction2 dir2_Hy(1.0, 0.0);\
\	Axis2 major2_Axis(point2_Hy, dir2_Hy);\
\	double major2 = 3.0, minor2 = 4.0;\
\	Hyperbola2 hyperbola2d_ax(major2_Axis, major2, minor2, true);\
\	double majorRadius = hyperbola2d_ax.MajorRadius();\
\	CHECK(majorRadius == Approx(3.0));"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] double MinorRadius()\	 @return The minor radius\
\	 @brief Get the minor radius\
",
 "output": "#include <catch.hpp>\
#include <testHelper.h>\
...\
\
TEST_CASE(\"case1:this is a case for Hyperbola2\", \"[math][Hyperbola2][p1]\") \
\	//Construct hyperbola2d_ax\
\	Point2 point2_Hy(0.0, 0.0);\
\	Direction2 dir2_Hy(1.0, 0.0);\
\	Axis2 major2_Axis(point2_Hy, dir2_Hy);\
\	double major2 = 3.0, minor2 = 4.0;\
\	Hyperbola2 hyperbola2d_ax(major2_Axis, major2, minor2, true);\
\	double minorRadius = hyperbola2d_ax.MinorRadius();\
\	CHECK(minorRadius == Approx(4.0));"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] AxisT<double, DIM> Asymptote1()\	 @return The positive asymptote\
\	 @brief Get the asymptote of the hyperbola with positive slope\
",
 "output": "#include <catch.hpp>\
#include <testHelper.h>\
...\
\
TEST_CASE(\"case1:this is a case for Hyperbola2\", \"[math][Hyperbola2][p1]\") \
\	//Construct hyperbola2d_ax\
\	Point2 point2_Hy(0.0, 0.0);\
\	Direction2 dir2_Hy(1.0, 0.0);\
\	Axis2 major2_Axis(point2_Hy, dir2_Hy);\
\	double major2 = 3.0, minor2 = 4.0;\
\	Hyperbola2 hyperbola2d_ax(major2_Axis, major2, minor2, true);\
\	AxisT<double, DIM> asymptote = hyperbola2d_ax.Asymptote1();\
\	CHECK(asymptote.Direction().X() / asymptote.Direction().Y() == Approx(3.0/4.0));"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] AxisT<double, DIM> Asymptote2()\	 @return The negative asymptote\
\	 @brief Get the asymptote of the hyperbola with negative slope\
",
 "output": "#include <catch.hpp>\
#include <testHelper.h>\
...\
\
TEST_CASE(\"case1:this is a case for Hyperbola2\", \"[math][Hyperbola2][p1]\") \
\	//Construct hyperbola2d_ax\
\	Point2 point2_Hy(0.0, 0.0);\
\	Direction2 dir2_Hy(1.0, 0.0);\
\	Axis2 major2_Axis(point2_Hy, dir2_Hy);\
\	double major2 = 3.0, minor2 = 4.0;\
\	Hyperbola2 hyperbola2d_ax(major2_Axis, major2, minor2, true);\
\	AxisT<double, DIM> asymptote = hyperbola2d_ax.Asymptote2();\
\	CHECK(asymptote.Direction().X() / asymptote.Direction().Y() == Approx(-3.0/4.0));"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] HyperbolaS ConjugateBranch1()\	 @return The positive conjugate hyperbola\
\	 @brief Get the conjugate hyperbola on the positive side of the minor axis\
",
 "output": "#include <catch.hpp>\
#include <testHelper.h>\
...\
\
TEST_CASE(\"case1:this is a case for Hyperbola2\", \"[math][Hyperbola2][p1]\") \
\	//Construct hyperbola2d_ax\
\	Point2 point2_Hy(0.0, 0.0);\
\	Direction2 dir2_Hy(1.0, 0.0);\
\	Axis2 major2_Axis(point2_Hy, dir2_Hy);\
\	double major2 = 3.0, minor2 = 4.0;\
\	Hyperbola2 hyperbola2d_ax(major2_Axis, major2, minor2, true);\
\	HyperbolaS conjugateBranch = hyperbola2d_ax.ConjugateBranch1();\
\	double major2d_con = conjugateBranch.MajorRadius();\
\	CHECK(major2d_con == Approx(4.0));"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] HyperbolaS ConjugateBranch2()\	 @return The negative conjugate hyperbola\
\	 @brief Get the conjugate hyperbola on the negative side of the minor axis\
",
 "output": "#include <catch.hpp>\
#include <testHelper.h>\
...\
\
TEST_CASE(\"case1:this is a case for Hyperbola2\", \"[math][Hyperbola2][p1]\") \
\	//Construct hyperbola2d_ax\
\	Point2 point2_Hy(0.0, 0.0);\
\	Direction2 dir2_Hy(1.0, 0.0);\
\	Axis2 major2_Axis(point2_Hy, dir2_Hy);\
\	double major2 = 3.0, minor2 = 4.0;\
\	Hyperbola2 hyperbola2d_ax(major2_Axis, major2, minor2, true);\
\	HyperbolaS conjugateBranch = hyperbola2d_ax.ConjugateBranch2();\
\	double major2d_con = conjugateBranch.MajorRadius();\
\	CHECK(major2d_con == Approx(4.0));"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] HyperbolaS OtherBranch()\	 @return The hyperbola of the other branch\
\	 @brief Get the other branch of the hyperbola\
",
 "output": "#include <catch.hpp>\
#include <testHelper.h>\
...\
\
TEST_CASE(\"case1:this is a case for Hyperbola2\", \"[math][Hyperbola2][p1]\") \
\	//Construct hyperbola2d_ax\
\	Point2 point2_Hy(0.0, 0.0);\
\	Direction2 dir2_Hy(1.0, 0.0);\
\	Axis2 major2_Axis(point2_Hy, dir2_Hy);\
\	double major2 = 3.0, minor2 = 4.0;\
\	Hyperbola2 hyperbola2d_ax(major2_Axis, major2, minor2, true);\
\	HyperbolaS otherBranch = hyperbola2d_ax.OtherBranch();\
\	double major2d_con = otherBranch.MajorRadius();\
\	CHECK(major2d_con == Approx(3.0));"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "HyperbolaS& Scale(const PointT<double, DIM>& point, double scale)\	 @return The reference to self\
\	 @param scale The scale value\
\	 @param point The scaling center point\
\	 @brief Scale the hyperbola by a center point\
",
 "output": "#include <catch.hpp>\
#include <testHelper.h>\
...\
\
TEST_CASE(\"case1:this is a case for Hyperbola2\", \"[math][Hyperbola2][p1]\") \
\	//Construct hyperbola2d_ax\
\	Point2 point2_Hy(0.0, 0.0);\
\	Direction2 dir2_Hy(1.0, 0.0);\
\	Axis2 major2_Axis(point2_Hy, dir2_Hy);\
\	double major2 = 3.0, minor2 = 4.0;\
\	Hyperbola2 hyperbola2d_ax(major2_Axis, major2, minor2, true);\
\	PointT<double, DIM> center(0.0, 0.0);\
\	hyperbola2d_ax.Scale(center, 0.5);\
\	CHECK(hyperbola2d_ax.Location().X() == Approx(0.0));"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "HyperbolaS& Transform(const TransformationT<double, DIM>& tr)\	 @return The reference to self\
\	 @param tr The transformation\
\	 @brief Transform the hyperbola\
",
 "output": "#include <catch.hpp>\
#include <testHelper.h>\
...\
\
TEST_CASE(\"case1:this is a case for Hyperbola2\", \"[math][Hyperbola2][p1\") \
\	//Construct hyperbola2d_ax\
\	Point2 point2_Hy(0.0, 0.0);\
\	Direction2 dir2_Hy(1.0, 0.0);\
\	Axis2 major2_Axis(point2_Hy, dir2_Hy);\
\	double major2 = 3.0, minor2 = 4.0;\
\	Hyperbola2 hyperbola2d_ax(major2_Axis, major2, minor2, true);\
\	TransformationT<double, DIM> trans;\
\	hyperbola2d_ax.Transform(trans);\
\	CHECK(hyperbola2d_ax.Location().X() == Approx(0.0));"}
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "void SetMajorRadius(double r)	 @param r The new major radius
	 @brief Set the major radius
",
 "output": "#include <catch.hpp>
#include <testHelper.h>

// Test for SetMajorRadius
TEST_CASE(\"case1: SetMajorRadius test\") {
	Hyperbola3 hyperbola3d_fr;
	hyperbola3d_fr.SetMajorRadius(4.0);
	CHECK(hyperbola3d_fr.MajorRadius() == Approx(4.0));
}"}
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "void SetMinorRadius(double r)	 @param r The new minor radius
	 @brief Set the minor radius
",
 "output": "#include <catch.hpp>
#include <testHelper.h>

// Test for SetMinorRadius
TEST_CASE(\"case2: SetMinorRadius test\") {
	Hyperbola3 hyperbola3d_fr;
	hyperbola3d_fr.SetMinorRadius(3.0);
	CHECK(hyperbola3d_fr.MinorRadius() == Approx(3.0));
}"}
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[nodiscard]] AxisT<double, DIM> Directrix1()	 @return The positive directrix
	 @brief Get the directrix on the positive side of the major axis
",
 "output": "#include <catch.hpp>
#include <testHelper.h>

// Test for Directrix1
TEST_CASE(\"case3: Directrix1 test\") {
	Hyperbola3 hyperbola3d_fr;
	AxisT<double, DIM> dir = hyperbola3d_fr.Directrix1();
	CHECK(dir.Location().X() == Approx(0.0)); // example check
}"}
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] AxisT<double, DIM> Directrix2()	 @return The negative directrix
	 @brief Get the directrix on the negative side of the major axis
",
 "output": "#include <catch.hpp>
#include <testHelper.h>

// Test for Directrix2
TEST_CASE(\"case4: Directrix2 test\") {
	Hyperbola3 hyperbola3d_fr;
	AxisT<double, DIM> dir = hyperbola3d_fr.Directrix2();
	CHECK(dir.Location().X() == Approx(0.0)); // example check
}"}
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] double Eccentricity()	 @return The eccentricity
	 @brief Get the eccentricity of the ellipse
",
 "output": "#include <catch.hpp>
#include <testHelper.h>

// Test for Eccentricity
TEST_CASE(\"case5: Eccentricity test\") {
	Hyperbola3 hyperbola3d_fr;
	double e = hyperbola3d_fr.Eccentricity();
	CHECK(e == Approx(5.0 / 3.0)); // example check
}"}
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] PointT<double, DIM> Focus1()	 @return The positive focus
	 @brief Get the focus on the positive side of the major axis
",
 "output": "#include <catch.hpp>
#include <testHelper.h>

// Test for Focus1
TEST_CASE(\"case6: Focus1 test\") {
	Hyperbola3 hyperbola3d_fr;
	PointT<double, DIM> focus = hyperbola3d_fr.Focus1();
	CHECK(focus.X() == Approx(5.0)); // example check
}"}
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] PointT<double, DIM> Focus2()	 @return The negative focus
	 @brief Get the focus on the negative side of the major axis
",
 "output": "#include <catch.hpp>
#include <testHelper.h>

// Test for Focus2
TEST_CASE(\"case7: Focus2 test\") {
	Hyperbola3 hyperbola3d_fr;
	PointT<double, DIM> focus = hyperbola3d_fr.Focus2();
	CHECK(focus.X() == Approx(-5.0)); // example check
}"}
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] double MajorRadius()	 @return The major radius
	 @brief Get the major radius
",
 "output": "#include <catch.hpp>
#include <testHelper.h>

// Test for MajorRadius
TEST_CASE(\"case8: MajorRadius test\") {
	Hyperbola3 hyperbola3d_fr;
	CHECK(hyperbola3d_fr.MajorRadius() == Approx(3.0)); // example check
}"}
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] double MinorRadius()	 @return The minor radius
	 @brief Get the minor radius
",
 "output": "#include <catch.hpp>
#include <testHelper.h>

// Test for MinorRadius
TEST_CASE(\"case9: MinorRadius test\") {
	Hyperbola3 hyperbola3d_fr;
	CHECK(hyperbola3d_fr.MinorRadius() == Approx(4.0)); // example check
}"}
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] AxisT<double, DIM> Asymptote1()	 @return The positive asymptote
	 @brief Get the asymptote of the hyperbola with positive slope
",
 "output": "#include <catch.hpp>
#include <testHelper.h>

// Test for Asymptote1
TEST_CASE(\"case10: Asymptote1 test\") {
	Hyperbola3 hyperbola3d_fr;
	AxisT<double, DIM> asymptote = hyperbola3d_fr.Asymptote1();
	CHECK(asymptote.Direction().X() / asymptote.Direction().Y() == Approx(3.0 / 4.0));
}"}
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] AxisT<double, DIM> Asymptote2()	 @return The negative asymptote
	 @brief Get the asymptote of the hyperbola with negative slope
",
 "output": "#include <catch.hpp>
#include <testHelper.h>

// Test for Asymptote2
TEST_CASE(\"case11: Asymptote2 test\") {
	Hyperbola3 hyperbola3d_fr;
	AxisT<double, DIM> asymptote = hyperbola3d_fr.Asymptote2();
	CHECK(asymptote.Direction().X() / asymptote.Direction().Y() == Approx(-3.0 / 4.0));
}"}
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] HyperbolaS ConjugateBranch1()	 @return The positive conjugate hyperbola
	 @brief Get the conjugate hyperbola on the positive side of the minor axis
",
 "output": "#include <catch.hpp>
#include <testHelper.h>

// Test for ConjugateBranch1
TEST_CASE(\"case12: ConjugateBranch1 test\") {
	Hyperbola3 hyperbola3d_fr;
	HyperbolaS conjugate = hyperbola3d_fr.ConjugateBranch1();
	CHECK(conjugate.Location().X() == Approx(0.0)); // example check
}"}
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] HyperbolaS ConjugateBranch2()	 @return The negative conjugate hyperbola
	 @brief Get the conjugate hyperbola on the negative side of the minor axis
",
 "output": "#include <catch.hpp>
#include <testHelper.h>

// Test for ConjugateBranch2
TEST_CASE(\"case13: ConjugateBranch2 test\") {
	Hyperbola3 hyperbola3d_fr;
	HyperbolaS conjugate = hyperbola3d_fr.ConjugateBranch2();
	CHECK(conjugate.Location().X() == Approx(0.0)); // example check
}"}
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard] HyperbolaS OtherBranch()	 @return The hyperbola of the other branch
	 @brief Get the other branch of the hyperbola
",
 "output": "#include <catch.hpp>
#include <testHelper.h>

// Test for OtherBranch
TEST_CASE(\"case14: OtherBranch test\") {
	Hyperbola3 hyperbola3d_fr;
	HyperbolaS other = hyperbola3d_fr.OtherBranch();
	CHECK(other.Location().X() == Approx(0.0)); // example check
}"}
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "HyperbolaS& Scale(const PointT<double, DIM>& point, double scale)	 @return The reference to self
	 @param scale The scale value
	 @param point The scaling center point
	 @brief Scale the hyperbola by a center point
",
 "output": "#include <catch.hpp>
#include <testHelper.h>

// Test for Scale
TEST_CASE(\"case15: Scale test\") {
	Hyperbola3 hyperbola3d_fr;
	PointT<double, DIM> center(0.0, 0.0, 1.0);
	hyperbola3d_fr.Scale(center, 0.5);
	CHECK(hyperbola3d_fr.Location().X() == Approx(0.0));
}"}
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "HyperbolaS& Transform(const TransformationT<double, DIM>& tr)	 @return The reference to self
	 @param tr The transformation
	 @brief Transform the hyperbola
",
 "output": "#include <catch.hpp>
#include <testHelper.h>

// Test for Transform
TEST_CASE(\"case16: Transform test\") {
	Hyperbola3 hyperbola3d_fr;
	TransformationT<double, DIM> trans;
	trans.SetTranslation(Vector3(1.0, 1.0, 1.0));
	hyperbola3d_fr.Transform(trans);
	CHECK(hyperbola3d_fr.Location().X() == Approx(1.0));
}"}
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[nodiscard]] bool Contains(const PointT<double, DIM>& p, double tol)	 @return True if the point is on the line under the tolerance
	 @param tol The tolerance
	 @param p The point
	 @brief Does the line contain a point under a distance tolerance
",
 "output": "#include <catch.hpp>
#include <testHelper.h>

TEST_CASE(\"Contains Test\", \"[math][Line2][p1]\") {
	Line2 line;
	Point2 point1(2., 1.);
	Point2 point2(1., 1.);
	CHECK(line.Contains(point1, 1e-5));
	CHECK_FALSE(line.Contains(point2, 1e-5));
	CHECK(line.Contains(point2, 1.));
}
"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] const PointT<double, DIM>& Location()	 @return The location of the line
	 @brief Get the location point of the line
",
 "output": "#include <catch.hpp>
#include <testHelper.h>

TEST_CASE(\"Location Test\", \"[math][Line2][p1]\") {
	Line2 line;
	CHECK(line.Location().IsEqual(Point2(0., 0.), 1e-5));
}
"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "Derived& Mirror(const AxisT<double, DIM>& axis)	 @return The reference to self
	 @param axis The mirror axis
	 @brief Mirror the line by an axis
",
 "output": "#include <catch.hpp>
#include <testHelper.h>

TEST_CASE(\"Mirror Test\", \"[math][Line2][p1]\") {
	Line2 line;
	Axis2 axis(Point2(1., 1.), Direction2(1., 0.));
	line.Mirror(axis);
	CHECK(line.Direction().IsEqual(Direction2(-1., 0.), 1e-5));
}
"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] Derived Mirrored(const AxisT<double, DIM>& axis)	 @return The mirrored line
	 @param axis The mirror axis
	 @brief Get the line mirrored by an axis
",
 "output": "#include <catch.hpp>
#include <testHelper.h>

TEST_CASE(\"Mirrored Test\", \"[math][Line2][p1]\") {
	Line2 line;
	Axis2 axis(Point2(1., 1.), Direction2(1., 0.));
	Line2 mirroredLine = line.Mirrored(axis);
	CHECK(mirroredLine.Direction().IsEqual(Direction2(-1., 0.), 1e-5));
}
"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "Derived& Scale(const PointT<double, DIM>& point, double scale)	 @return The reference to self
	 @param scale The scale value
	 @param point The scaling center point
	 @brief Scale the line by a point
",
 "output": "#include <catch.hpp>
#include <testHelper.h>

TEST_CASE(\"Scale Test\", \"[math][Line2][p1]\") {
	Line2 line(Point2(0., -1.), Direction2());
	Point2 point(0., 0.);
	line.Scale(point, 1.1);
	CHECK(line.Distance(point) > 0);
}
"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] Derived Scaled(const PointT<double, DIM>& point, double scale)	 @return The scaled line
	 @param scale The scale value
	 @param point The scaling center point
	 @brief Get the line scaled by a point
",
 "output": "#include <catch.hpp>
#include <testHelper.h>

TEST_CASE(\"Scaled Test\", \"[math][Line2][p1]\") {
	Line2 line(Point2(0., -1.), Direction2());
	Point2 point(0., 0.);
	Line2 scaledLine = line.Scaled(point, 1.1);
	CHECK(scaledLine.Distance(point) > 0);
}
"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "Derived& Transform(const TransformationT<double, DIM>& tr)	 @return The reference to self
	 @param tr The transformation
	 @brief Transform the line
",
 "output": "#include <catch.hpp>
#include <testHelper.h>

TEST_CASE(\"Transform Test\", \"[math][Line2][p1]\") {
	Line2 line;
	Transformation2 tfObject;
	line.Transform(tfObject);
	CHECK(line.Location().IsEqual(Point2(0., 0.), 1e-5));
}
"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] Derived Transformed(const TransformationT<double, DIM>& tr)	 @return The transformed line
	 @param tr The transformation
	 @brief Get the transformed line
",
 "output": "#include <catch.hpp>
#include <testHelper.h>

TEST_CASE(\"Transformed Test\", \"[math][Line2][p1]\") {
	Line2 line;
	Transformation2 tfObject;
	Line2 transformedLine = line.Transformed(tfObject);
	CHECK(transformedLine.Location().IsEqual(Point2(0., 0.), 1e-5));
}
"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "Derived& Translate(const VectorT<double, DIM>& vec)	 @return The reference to self
	 @param vec The translation vector
	 @brief Translate the line by a vector
",
 "output": "#include <catch.hpp>
#include <testHelper.h>

TEST_CASE(\"Translate Test\", \"[math][Line2][p1]\") {
	Line2 line;
	line.Translate(Vector2(2., 0.));
	CHECK(line.Contains(Point2(2., 0.), 1e-5));
}
"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "Derived& Translate(const PointT<double, DIM>& p1, const PointT<double, DIM>& p2)	 @return The reference to self
	 @param p2 The target point
	 @param p1 The source point
	 @brief Translate the line by a vector from a point to another point
",
 "output": "#include <catch.hpp>
#include <testHelper.h>

TEST_CASE(\"Translate Points Test\", \"[math][Line2][p1]\") {
	Line2 line;
	Point2 p1(0., 0.), p2(2., 2.);
	line.Translate(p1, p2);
	CHECK(line.Contains(p2, 1e-5));
}
"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] Derived Translated(const VectorT<double, DIM>& vec)	 @return The translated line
	 @param vec The translation vector
	 @brief Get the line translated by a vector
",
 "output": "#include <catch.hpp>
#include <testHelper.h>

TEST_CASE(\"Translated Test\", \"[math][Line2][p1]\") {
	Line2 line;
	Line2 translatedLine = line.Translated(Vector2(2., 0.));
	CHECK(translatedLine.Contains(Point2(2., 0.), 1e-5));
}
"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] Derived Translated(const PointT<double, DIM>& p1, const PointT<double, DIM>& p2)	 @return The translated line
	 @param p2 The target point
	 @param p1 The source point
	 @brief Get the line translated by a vector from a point to another point
",
 "output": "#include <catch.hpp>
#include <testHelper.h>

TEST_CASE(\"Translated Points Test\", \"[math][Line2][p1]\") {
	Line2 line;
	Point2 p1(0., 0.), p2(2., 2.);
	Line2 translatedLine = line.Translated(p1, p2);
	CHECK(translatedLine.Contains(p2, 1e-5));
}
"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "void SetLocation(const PointT<double, DIM>& point)	 @param point The location point
	 @brief Set the location of the line
",
 "output": "#include <catch.hpp>
#include <testHelper.h>

TEST_CASE(\"SetLocation Test\", \"[math][Line2][p1]\") {
	Line2 line;
	line.SetLocation(Point2(2., 1.));
	CHECK(line.Location().IsEqual(Point2(2., 1.), 1e-5));
}
"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "void SetDirection(const DirectionT<double, DIM>& dir)	 @param dir The line direction
	 @brief Set the line direction
",
 "output": "#include <catch.hpp>
#include <testHelper.h>

TEST_CASE(\"SetDirection Test\", \"[math][Line2][p1]\") {
	Line2 line;
	line.SetDirection(Direction2(1., 1.));
	CHECK(line.Direction().IsEqual(Direction2(1., 1.), 1e-5));
}
"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "void SetPosition(const AxisT<double, DIM>& axis)	 @param axis The axis
	 @brief Set the axis of the line
",
 "output": "#include <catch.hpp>
#include <testHelper.h>

TEST_CASE(\"SetPosition Test\", \"[math][Line2][p1]\") {
	Line2 line;
	Axis2 axis(Point2(2., 1.), Direction2(1., 1.));
	line.SetPosition(axis);
	CHECK(line.Location().IsEqual(Point2(2., 1.), 1e-5));
}
"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] const DirectionT<double, DIM>& Direction()	 @return The direction of the line
	 @brief Get the direction of the line
",
 "output": "#include <catch.hpp>
#include <testHelper.h>

TEST_CASE(\"Direction Test\", \"[math][Line2][p1]\") {
	Line2 line;
	CHECK(line.Direction().IsEqual(Direction2(1., 0.), 1e-5));
}
"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] const AxisT<double, DIM>& Position()	 @return The axis of the line
	 @brief Get the axis of the line
",
 "output": "#include <catch.hpp>
#include <testHelper.h>

TEST_CASE(\"Position Test\", \"[math][Line2][p1]\") {
	Line2 line;
	CHECK(line.Position().IsEqual(Axis2(Point2(0., 0.), Direction2(1., 0.)), 1e-5));
}
"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] auto Angle(const LineBase& other)	 @return The angle between the line and the other line
	 @param other The other line
	 @brief Compute the angle between the line and the other line
",
 "output": "#include <catch.hpp>
#include <testHelper.h>

TEST_CASE(\"Angle Test\", \"[math][Line2][p1]\") {
	Line2 line1(Point2(0., 0.), Direction2(1., 0.));
	Line2 line2(Point2(0., 0.), Direction2(0., 1.));
	CHECK(line1.Angle(line2) == Approx(M_PI_2));
}
"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "Derived& Reverse()	 @return The reference to self
	 @brief Reverse the line direction
",
 "output": "#include <catch.hpp>
#include <testHelper.h>

TEST_CASE(\"Reverse Test\", \"[math][Line2][p1]\") {
	Line2 line;
	line.Reverse();
	CHECK(line.Direction().IsEqual(Direction2(-1., 0.), 1e-5));
}
"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] Derived Reversed()	 @return The line with reversed direction
	 @brief Get the line with reversed direction
",
 "output": "#include <catch.hpp>
#include <testHelper.h>

TEST_CASE(\"Reversed Test\", \"[math][Line2][p1]\") {
	Line2 line;
	Line2 reversedLine = line.Reversed();
	CHECK(reversedLine.Direction().IsEqual(Direction2(-1., 0.), 1e-5));
}
"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "Derived& Mirror(const PointT<double, DIM>& point)	 @return The reference to self
	 @param point The mirror center point
	 @brief Mirror the line by a point
",
 "output": "#include <catch.hpp>
#include <testHelper.h>

TEST_CASE(\"Mirror Point Test\", \"[math][Line2][p1]\") {
	Line2 line(Point2(2., 1.), Direction2(1., 1.));
	Point2 point(4., -6.);
	line.Mirror(point);
	CHECK(line.Distance(point) == Approx(0.).margin(1e-5));
}
"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] Derived Mirrored(const PointT<double, DIM>& point)	 @return The mirrored line
	 @param point The mirror center point
	 @brief Get the line mirrored by a point
",
 "output": "#include <catch.hpp>
#include <testHelper.h>

TEST_CASE(\"Mirrored Point Test\", \"[math][Line2][p1]\") {
	Line2 line(Point2(2., 1.), Direction2(1., 1.));
	Point2 point(4., -6.);
	Line2 mirroredLine = line.Mirrored(point);
	CHECK(mirroredLine.Distance(point) == Approx(0.).margin(1e-5));
}
"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "LineS(double a, double b, double c)	 @param a,b,c The coefficients
	 @brief Construct from the algebraic coefficients of 2D line
",
 "output": "#include <catch.hpp>
#include <testHelper.h>

TEST_CASE(\"Constructor Test\", \"[math][Line2][p1]\") {
	LineS line(1., -2., -1.);
	CHECK(line.Coefficients() == std::make_tuple(1., -2., -1.));
}
"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "void Coefficients(double& a, double& b, double& c)	 @param[out] a,b,c The coefficients
	 @brief The coefficients of the algebraic representation of the 2D line
",
 "output": "#include <catch.hpp>
#include <testHelper.h>

TEST_CASE(\"Coefficients Test\", \"[math][Line2][p1]\") {
	Line2 line(1., -2., -1.);
	double a, b, c;
	line.Coefficients(a, b, c);
	CHECK(a == 1.);
	CHECK(b == -2.);
	CHECK(c == -1.);
}
"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] auto Distance(const Point2& p)	 @return The distance between the point and the line
	 @param p The point
	 @brief Compute the distance from a point to the line
",
 "output": "#include <catch.hpp>
#include <testHelper.h>

TEST_CASE(\"Distance Test\", \"[math][Line2][p1]\") {
	Line2 line(1., -2., -1.);
	Point2 point(2., 2.);
	CHECK(line.Distance(point) == Approx(1.414));
}
"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] auto Distance(const LineS& l)	 @return The distance between two lines
	 @param l The other line
	 @brief Compute the distance between two lines
",
 "output": "#include <catch.hpp>
#include <testHelper.h>

TEST_CASE(\"Distance Between Lines Test\", \"[math][Line2][p1]\") {
	Line2 line1(1., -2., -1.);
	Line2 line2(1., 1., 1.);
	CHECK(line1.Distance(line2) == Approx(1.414));
}
"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] auto SquaredDistance(const Point2& p)	 @return The squared distance between the point and the line
	 @param p The point
	 @brief Compute the squared distance from a point to the line
",
 "output": "#include <catch.hpp>
#include <testHelper.h>

TEST_CASE(\"Squared Distance Test\", \"[math][Line2][p1]\") {
	Line2 line(1., -2., -1.);
	Point2 point(2., 2.);
	CHECK(line.SquaredDistance(point) == Approx(2.));
}
"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] auto SquaredDistance(const LineS& l)	 @return The squared distance between two lines
	 @param l The other line
	 @brief Compute the squared distance between two lines
",
 "output": "#include <catch.hpp>
#include <testHelper.h>

TEST_CASE(\"Squared Distance Between Lines Test\", \"[math][Line2][p1]\") {
	Line2 line1(1., -2., -1.);
	Line2 line2(1., 1., 1.);
	CHECK(line1.SquaredDistance(line2) == Approx(2.));
}
"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] LineS Normal(const Point2& p)	 @return The line passing through a point and perpendicular to the line
	 @param p The point
	 @brief Get a line passing through a point and perpendicular to the line
",
 "output": "#include <catch.hpp>
#include <testHelper.h>

TEST_CASE(\"Normal Test\", \"[math][Line2][p1]\") {
	Line2 line(1., -2., -1.);
	Point2 point(2., 2.);
	Line2 normalLine = line.Normal(point);
	CHECK(normalLine.Distance(point) == 0);
}
"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "LineS& Rotate(const Point2& point, double angle)	 @return The reference to self
	 @param angle The rotation angle
	 @param point The rotation center point
	 @brief Rotate the line around a point with an angle in 2D
",
 "output": "#include <catch.hpp>
#include <testHelper.h>

TEST_CASE(\"Rotate Test\", \"[math][Line2][p1]\") {
	Line2 line(Point2(0., 1.), Direction2(1., 0.));
	line.Rotate(Point2(0., 0.), M_PI / 4);
	CHECK(line.Direction().IsEqual(Direction2(0.7071, 0.7071), 1e-5));
}
"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] LineS Rotated(const Point2& point, double angle)	 @return The rotated line
	 @param angle The rotation angle
	 @param point The rotation center point
	 @brief Get the line rotated around a point with an angle in 2D
",
 "output": "#include <catch.hpp>
#include <testHelper.h>

TEST_CASE(\"Rotated Test\", \"[math][Line2][p1]\") {
	Line2 line(Point2(0., 1.), Direction2(1., 0.));
	Line2 rotatedLine = line.Rotated(Point2(0., 0.), M_PI / 4);
	CHECK(rotatedLine.Direction().IsEqual(Direction2(0.7071, 0.7071), 1e-5));
}
"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] auto Distance(const Point3& p)	 @return The distance between the point and the line
	 @param p The point
	 @brief Compute the distance from a point to the line
",
 "output": "#include <catch.hpp>
#include <testHelper.h>

TEST_CASE(\"Distance in 3D Test\", \"[math][Line2][p1]\") {
	Line2 line(1., -2., -1.);
	Point3 point(2., 2., 2.);
	CHECK(line.Distance(point) == Approx(1.414));
}
"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] auto SquaredDistance(const Point3& p)	 @return The squared distance between the point and the line
	 @param p The point
	 @brief Compute the squared distance from a point to the line
",
 "output": "#include <catch.hpp>
#include <testHelper.h>

TEST_CASE(\"Squared Distance in 3D Test\", \"[math][Line2][p1]\") {
	Line2 line(1., -2., -1.);
	Point3 point(2., 2., 2.);
	CHECK(line.SquaredDistance(point) == Approx(2.));
}
"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] LineS Normal(const Point3& p)	 @return The line passing through a point and perpendicular to the line
	 @param p The point
	 @brief Get a line passing through a point and perpendicular to the line
",
 "output": "#include <catch.hpp>
#include <testHelper.h>

TEST_CASE(\"Normal in 3D Test\", \"[math][Line2][p1]\") {
	Line2 line(1., -2., -1.);
	Point3 point(2., 2., 2.);
	Line2 normalLine = line.Normal(point);
	CHECK(normalLine.Distance(point) == 0);
}
"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "LineS& Mirror(const Frame3& frame)	 @return The reference to self
	 @param frame The mirror frame
	 @brief Mirror the line by a frame
",
 "output": "#include <catch.hpp>
#include <testHelper.h>

TEST_CASE(\"Mirror Frame Test\", \"[math][Line2][p1]\") {
	Line2 line;
	Frame3 frame;
	line.Mirror(frame);
	CHECK(line.Direction().IsEqual(Direction2(-1., 0.), 1e-5));
}
"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] LineS Mirrored(const Frame3& frame)	 @return The mirrored line
	 @param frame The mirror frame
	 @brief Get the line mirrored by a frame
",
 "output": "#include <catch.hpp>
#include <testHelper.h>

TEST_CASE(\"Mirrored Frame Test\", \"[math][Line2][p1]\") {
	Line2 line;
	Frame3 frame;
	Line2 mirroredLine = line.Mirrored(frame);
	CHECK(mirroredLine.Direction().IsEqual(Direction2(-1., 0.), 1e-5));
}
"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "LineS& Rotate(const Axis3& axis, double angle)	 @return The reference to self
	 @param angle The rotation angle
	 @param axis The rotation axis
	 @brief Rotate the line around an axis with an angle in 3D
",
 "output": "#include <catch.hpp>
#include <testHelper.h>

TEST_CASE(\"Rotate Axis Test\", \"[math][Line2][p1]\") {
	Line2 line;
	Axis3 axis;
	line.Rotate(axis, M_PI / 4);
	CHECK(line.Direction().IsEqual(Direction2(0.7071, 0.7071), 1e-5));
}
"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] LineS Rotated(const Axis3& axis, double angle)	 @return The rotated line
	 @param angle The rotation angle
	 @param axis The rotation axis
	 @brief Get the line rotated around an axis with an angle in 3D
",
 "output": "#include <catch.hpp>
#include <testHelper.h>

TEST_CASE(\"Rotated Axis Test\", \"[math][Line2][p1\") {
	Line2 line;
	Axis3 axis;
	Line2 rotatedLine = line.Rotated(axis, M_PI / 4);
	CHECK(rotatedLine.Direction().IsEqual(Direction2(0.7071, 0.7071), 1e-5));
}
"}
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[nodiscard]] bool Contains(const PointT<double, DIM>& p, double tol)	 @return True if the point is on the line under the tolerance
	 @param tol The tolerance
	 @param p The point
	 @brief Does the line contain a point under a distance tolerance",
 "output": "#include <catch.hpp>
#include <testHelper.h>

TEST_CASE(\"case1: Contains Method Test\", \"[math][Line3][Contains]\")
	Line3 line;
	CHECK(line.Contains(Point3(1., 1., 1.), 0.1) == true);
	CHECK(line.Contains(Point3(2., 2., 2.), 0.1) == false);
"}
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] const PointT<double, DIM>& Location()	 @return The location of the line
	 @brief Get the location point of the line",
 "output": "#include <catch.hpp>
#include <testHelper.h>

TEST_CASE(\"case2: Location Method Test\", \"[math][Line3][Location]\")
	Line3 line;
	CHECK(line.Location() == Point3(0., 0., 0.));
"}
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "Derived& Mirror(const AxisT<double, DIM>& axis)	 @return The reference to self
	 @param axis The mirror axis
	 @brief Mirror the line by an axis",
 "output": "#include <catch.hpp>
#include <testHelper.h>

TEST_CASE(\"case3: Mirror Method Test\", \"[math][Line3][Mirror]\")
	Axis3 axis(Point3(0., 0., 0.), Direction3(1., 0., 0.));
	Line3 line;
	line.Mirror(axis);
	CHECK(line.Location() == expectedLocation);
"}
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] Derived Mirrored(const AxisT<double, DIM>& axis)	 @return The mirrored line
	 @param axis The mirror axis
	 @brief Get the line mirrored by an axis",
 "output": "#include <catch.hpp>
#include <testHelper.h>

TEST_CASE(\"case4: Mirrored Method Test\", \"[math][Line3][Mirrored]\")
	Axis3 axis(Point3(0., 0., 0.), Direction3(1., 0., 0.));
	Line3 line;
	Line3 mirroredLine = line.Mirrored(axis);
	CHECK(mirroredLine.Location() == expectedMirroredLocation);
"}
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "Derived& Scale(const PointT<double, DIM>& point, double scale)	 @return The reference to self
	 @param scale The scale value
	 @param point The scaling center point
	 @brief Scale the line by a point",
 "output": "#include <catch.hpp>
#include <testHelper.h>

TEST_CASE(\"case5: Scale Method Test\", \"[math][Line3][Scale]\")
	Point3 center(1., 1., 1.);
	Line3 line;
	line.Scale(center, 2.0);
	CHECK(line.Location() == expectedScaledLocation);
"}
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] Derived Scaled(const PointT<double, DIM>& point, double scale)	 @return The scaled line
	 @param scale The scale value
	 @param point The scaling center point
	 @brief Get the line scaled by a point",
 "output": "#include <catch.hpp>
#include <testHelper.h>

TEST_CASE(\"case6: Scaled Method Test\", \"[math][Line3][Scaled]\")
	Point3 center(1., 1., 1.);
	Line3 line;
	Line3 scaledLine = line.Scaled(center, 2.0);
	CHECK(scaledLine.Location() == expectedScaledLocation);
"}
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "Derived& Transform(const TransformationT<double, DIM>& tr)	 @return The reference to self
	 @param tr The transformation
	 @brief Transform the line",
 "output": "#include <catch.hpp>
#include <testHelper.h>

TEST_CASE(\"case7: Transform Method Test\", \"[math][Line3][Transform]\")
	Transformation3 transform;
	Line3 line;
	line.Transform(transform);
	CHECK(line.Location() == expectedTransformedLocation);
"}
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] Derived Transformed(const TransformationT<double, DIM>& tr)	 @return The transformed line
	 @param tr The transformation
	 @brief Get the transformed line",
 "output": "#include <catch.hpp>
#include <testHelper.h>

TEST_CASE(\"case8: Transformed Method Test\", \"[math][Line3][Transformed]\")
	Transformation3 transform;
	Line3 line;
	Line3 transformedLine = line.Transformed(transform);
	CHECK(transformedLine.Location() == expectedTransformedLocation);
"}
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "Derived& Translate(const VectorT<double, DIM>& vec)	 @return The reference to self
	 @param vec The translation vector
	 @brief Translate the line by a vector",
 "output": "#include <catch.hpp>
#include <testHelper.h>

TEST_CASE(\"case9: Translate Method Test\", \"[math][Line3][Translate]\")
	Vector3 translation(1., 1., 1.);
	Line3 line;
	line.Translate(translation);
	CHECK(line.Location() == expectedTranslatedLocation);
"}
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "Derived& Translate(const PointT<double, DIM>& p1, const PointT<double, DIM>& p2)	 @return The reference to self
	 @param p2 The target point
	 @param p1 The source point
	 @brief Translate the line by a vector from a point to another point",
 "output": "#include <catch.hpp>
#include <testHelper.h>

TEST_CASE(\"case10: Translate Method with Points Test\", \"[math][Line3][TranslatePoints]\")
	Point3 from(0., 0., 0.), to(1., 1., 1.);
	Line3 line;
	line.Translate(from, to);
	CHECK(line.Location() == expectedTranslatedLocation);
"}
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] Derived Translated(const VectorT<double, DIM>& vec)	 @return The translated line
	 @param vec The translation vector
	 @brief Get the line translated by a vector",
 "output": "#include <catch.hpp>
#include <testHelper.h>

TEST_CASE(\"case11: Translated Method Test\", \"[math][Line3][Translated]\")
	Vector3 translation(1., 1., 1.);
	Line3 line;
	Line3 translatedLine = line.Translated(translation);
	CHECK(translatedLine.Location() == expectedTranslatedLocation);
"}
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] Derived Translated(const PointT<double, DIM>& p1, const PointT<double, DIM>& p2)	 @return The translated line
	 @param p2 The target point
	 @param p1 The source point
	 @brief Get the line translated by a vector from a point to another point",
 "output": "#include <catch.hpp>
#include <testHelper.h>

TEST_CASE(\"case12: Translated Method with Points Test\", \"[math][Line3][TranslatePoints]\")
	Point3 from(0., 0., 0.), to(1., 1., 1.);
	Line3 line;
	Line3 translatedLine = line.Translated(from, to);
	CHECK(translatedLine.Location() == expectedTranslatedLocation);
"}
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "void SetLocation(const PointT<double, DIM>& point)	 @param point The location point
	 @brief Set the location of the line",
 "output": "#include <catch.hpp>
#include <testHelper.h>

TEST_CASE(\"case13: SetLocation Method Test\", \"[math][Line3][SetLocation]\")
	Point3 point(1., 1., 1.);
	Line3 line;
	line.SetLocation(point);
	CHECK(line.Location() == point);
"}
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "void SetDirection(const DirectionT<double, DIM>& dir)	 @param dir The line direction
	 @brief Set the line direction",
 "output": "#include <catch.hpp>
#include <testHelper.h>

TEST_CASE(\"case14: SetDirection Method Test\", \"[math][Line3][SetDirection]\")
	Direction3 dir(1., 1., 1.);
	Line3 line;
	line.SetDirection(dir);
	CHECK(line.Direction() == dir);
"}
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "void SetPosition(const AxisT<double, DIM>& axis)	 @param axis The axis
	 @brief Set the axis of the line",
 "output": "#include <catch.hpp>
#include <testHelper.h>

TEST_CASE(\"case15: SetPosition Method Test\", \"[math][Line3][SetPosition]\")
	Axis3 axis(Point3(0., 0., 0.), Direction3(1., 0., 0.));
	Line3 line;
	line.SetPosition(axis);
	CHECK(line.Position() == axis);
"}
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] const DirectionT<double, DIM>& Direction()	 @return The direction of the line
	 @brief Get the direction of the line",
 "output": "#include <catch.hpp>
#include <testHelper.h>

TEST_CASE(\"case16: Direction Method Test\", \"[math][Line3][Direction]\")
	Line3 line;
	CHECK(line.Direction() == Direction3(0., 0., 1.));
"}
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] const AxisT<double, DIM>& Position()	 @return The axis of the line
	 @brief Get the axis of the line",
 "output": "#include <catch.hpp>
#include <testHelper.h>

TEST_CASE(\"case17: Position Method Test\", \"[math][Line3][Position]\")
	Line3 line;
	CHECK(line.Position() == Axis3(Point3(0., 0., 0.), Direction3(1., 0., 0.)));
"}
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] auto Angle(const LineBase& other)	 @return The angle between the line and the other line
	 @param other The other line
	 @brief Compute the angle between the line and the other line",
 "output": "#include <catch.hpp>
#include <testHelper.h>

TEST_CASE(\"case18: Angle Method Test\", \"[math][Line3][Angle]\")
	Line3 line1(Point3(0., 0., 0.), Direction3(1., 0., 0.));
	Line3 line2(Point3(0., 0., 0.), Direction3(0., 1., 0.));
	CHECK(line1.Angle(line2) == Approx(M_PI / 2));
"}
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "Derived& Reverse()	 @return The reference to self
	 @brief Reverse the line direction",
 "output": "#include <catch.hpp>
#include <testHelper.h>

TEST_CASE(\"case19: Reverse Method Test\", \"[math][Line3][Reverse]\")
	Line3 line;
	line.Reverse();
	CHECK(line.Direction() == Direction3(-1., -1., -1.));
"}
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] Derived Reversed()	 @return The line with reversed direction
	 @brief Get the line with reversed direction",
 "output": "#include <catch.hpp>
#include <testHelper.h>

TEST_CASE(\"case20: Reversed Method Test\", \"[math][Line3][Reversed]\")
	Line3 line;
	Line3 reversedLine = line.Reversed();
	CHECK(reversedLine.Direction() == Direction3(-1., -1., -1.));
"}
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "Derived& Mirror(const PointT<double, DIM>& point)	 @return The reference to self
	 @param point The mirror center point
	 @brief Mirror the line by a point",
 "output": "#include <catch.hpp>
#include <testHelper.h>

TEST_CASE(\"case21: Mirror Method with Point Test\", \"[math][Line3][MirrorPoint]\")
	Point3 point(0., 0., 0.);
	Line3 line;
	line.Mirror(point);
	CHECK(line.Location() == expectedLocation);
"}
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] Derived Mirrored(const PointT<double, DIM>& point)	 @return The mirrored line
	 @param point The mirror center point
	 @brief Get the line mirrored by a point",
 "output": "#include <catch.hpp>
#include <testHelper.h>

TEST_CASE(\"case22: Mirrored Method with Point Test\", \"[math][Line3][MirroredPoint]\")
	Point3 point(0., 0., 0.);
	Line3 line;
	Line3 mirroredLine = line.Mirrored(point);
	CHECK(mirroredLine.Location() == expectedMirroredLocation);
"}
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "LineS(double a, double b, double c)	 @param a,b,c The coefficients
	 @brief Construct from the algebraic coefficients of 2D line",
 "output": "#include <catch.hpp>
#include <testHelper.h>

TEST_CASE(\"case23: LineS Constructor Test\", \"[math][LineS][Constructor]\")
	LineS line(1.0, 2.0, 3.0);
	CHECK(line.Distance(Point2(0., 0.)) == expectedDistance);
"}
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "void Coefficients(double& a, double& b, double& c)	 @param[out] a,b,c The coefficients
	 @brief The coefficients of the algebraic representation of the 2D line",
 "output": "#include <catch.hpp>
#include <testHelper.h>

TEST_CASE(\"case24: Coefficients Method Test\", \"[math][LineS][Coefficients]\")
	LineS line;
	double a, b, c;
	line.Coefficients(a, b, c);
	CHECK(a == expectedA);
	CHECK(b == expectedB);
	CHECK(c == expectedC);
"}
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] auto Distance(const Point2& p)	 @return The distance between the point and the line
	 @param p The point
	 @brief Compute the distance from a point to the line",
 "output": "#include <catch.hpp>
#include <testHelper.h>

TEST_CASE(\"case25: Distance Method Test\", \"[math][LineS][Distance]\")
	LineS line;
	Point2 point(1., 1.);
	CHECK(line.Distance(point) == expectedDistance);
"}
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] auto Distance(const LineS& l)	 @return The distance between two lines
	 @param l The other line
	 @brief Compute the distance between two lines",
 "output": "#include <catch.hpp>
#include <testHelper.h>

TEST_CASE(\"case26: Distance Method with Line Test\", \"[math][LineS][DistanceLine]\")
	LineS line1(1.0, 2.0, 3.0);
	LineS line2(4.0, 5.0, 6.0);
	CHECK(line1.Distance(line2) == expectedDistance);
"}
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] auto SquaredDistance(const Point2& p)	 @return The squared distance between the point and the line
	 @param p The point
	 @brief Compute the squared distance from a point to the line",
 "output": "#include <catch.hpp>
#include <testHelper.h>

TEST_CASE(\"case27: SquaredDistance Method Test\", \"[math][LineS][SquaredDistance]\")
	LineS line;
	Point2 point(1., 1.);
	CHECK(line.SquaredDistance(point) == expectedSquaredDistance);
"}
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] auto SquaredDistance(const LineS& l)	 @return The squared distance between two lines
	 @param l The other line
	 @brief Compute the squared distance between two lines",
 "output": "#include <catch.hpp>
#include <testHelper.h>

TEST_CASE(\"case28: SquaredDistance Method with Line Test\", \"[math][LineS][SquaredDistanceLine]\")
	LineS line1(1.0, 2.0, 3.0);
	LineS line2(4.0, 5.0, 6.0);
	CHECK(line1.SquaredDistance(line2) == expectedSquaredDistance);
"}
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] LineS Normal(const Point2& p)	 @return The line passing through a point and perpendicular to the line
	 @param p The point
	 @brief Get a line passing through a point and perpendicular to the line",
 "output": "#include <catch.hpp>
#include <testHelper.h>

TEST_CASE(\"case29: Normal Method Test\", \"[math][LineS][Normal]\")
	Point2 point(1., 1.);
	LineS line;
	LineS normalLine = line.Normal(point);
	CHECK(normalLine.Direction().IsEqual(expectedDirection));
"}
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "LineS& Rotate(const Point2& point, double angle)	 @return The reference to self
	 @param angle The rotation angle
	 @param point The rotation center point
	 @brief Rotate the line around a point with an angle in 2D",
 "output": "#include <catch.hpp>
#include <testHelper.h>

TEST_CASE(\"case30: Rotate Method Test\", \"[math][LineS][Rotate]\")
	Point2 point(0., 0.);
	LineS line;
	line.Rotate(point, 90.0);
	CHECK(line.Location() == expectedLocation);
"}
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] LineS Rotated(const Point2& point, double angle)	 @return The rotated line
	 @param angle The rotation angle
	 @param point The rotation center point
	 @brief Get the line rotated around a point with an angle in 2D",
 "output": "#include <catch.hpp>
#include <testHelper.h>

TEST_CASE(\"case31: Rotated Method Test\", \"[math][LineS][Rotated]\")
	Point2 point(0., 0.);
	LineS line;
	LineS rotatedLine = line.Rotated(point, 90.0);
	CHECK(rotatedLine.Location() == expectedRotatedLocation);
"}
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] auto Distance(const Point3& p)	 @return The distance between the point and the line
	 @param p The point
	 @brief Compute the distance from a point to the line",
 "output": "#include <catch.hpp>
#include <testHelper.h>

TEST_CASE(\"case32: Distance Method with Point3 Test\", \"[math][Line3][DistancePoint3]\")
	Line3 line;
	Point3 point(1., 1., 1.);
	CHECK(line.Distance(point) == expectedDistance);
"}
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] auto SquaredDistance(const Point3& p)	 @return The squared distance between the point and the line
	 @param p The point
	 @brief Compute the squared distance from a point to the line",
 "output": "#include <catch.hpp>
#include <testHelper.h>

TEST_CASE(\"case33: SquaredDistance Method with Point3 Test\", \"[math][Line3][SquaredDistancePoint3]\")
	Line3 line;
	Point3 point(1., 1., 1.);
	CHECK(line.SquaredDistance(point) == expectedSquaredDistance);
"}
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] LineS Normal(const Point3& p)	 @return The line passing through a point and perpendicular to the line
	 @param p The point
	 @brief Get a line passing through a point and perpendicular to the line",
 "output": "#include <catch.hpp>
#include <testHelper.h>

TEST_CASE(\"case34: Normal Method with Point3 Test\", \"[math][LineS][NormalPoint3\")
	Point3 point(1., 1., 1.);
	LineS line;
	LineS normalLine = line.Normal(point);
	CHECK(normalLine.Direction().IsEqual(expectedDirection));
"}
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "LineS& Mirror(const Frame3& frame)	 @return The reference to self
	 @param frame The mirror frame
	 @brief Mirror the line by a frame",
 "output": "#include <catch.hpp>
#include <testHelper.h>

TEST_CASE(\"{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[nodiscard]] bool Contains(const PointT<double, DIM>& p, double tol)\	 @return True if the point is on the line under the tolerance\
\	 @param tol The tolerance\
\	 @param p The point\
\	 @brief Does the line contain a point under a distance tolerance\
",
 "output": "#include<catch.hpp>\
#include<testHelper.h>\
\
TEST_CASE(\"Test Contains Method\", \"[Contains]\") {\
\	PointT<double, DIM> point;\
\	double tolerance;\
\	bool result = Contains(point, tolerance);\
\	CHECK(result == expected);\
}"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] const PointT<double, DIM>& Location()\	 @return The location of the line\
\	 @brief Get the location point of the line\
",
 "output": "#include<catch.hpp>\
#include<testHelper.h>\
\
TEST_CASE(\"Test Location Method\", \"[Location]\") {\
\	const PointT<double, DIM>& loc = Location();\
\	CHECK(loc == expectedLocation);\
}"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "Derived& Mirror(const AxisT<double, DIM>& axis)\	 @return The reference to self\
\	 @param axis The mirror axis\
\	 @brief Mirror the line by an axis\
",
 "output": "#include<catch.hpp>\
#include<testHelper.h>\
\
TEST_CASE(\"Test Mirror Method\", \"[Mirror]\") {\
\	AxisT<double, DIM> axis;\
\	Derived& ref = Mirror(axis);\
\	CHECK(ref == expectedReference);\
}"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] Derived Mirrored(const AxisT<double, DIM>& axis)\	 @return The mirrored line\
\	 @param axis The mirror axis\
\	 @brief Get the line mirrored by an axis\
",
 "output": "#include<catch.hpp>\
#include<testHelper.h>\
\
TEST_CASE(\"Test Mirrored Method\", \"[Mirrored]\") {\
\	AxisT<double, DIM> axis;\
\	Derived mirroredLine = Mirrored(axis);\
\	CHECK(mirroredLine == expectedMirrored);\
}"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "Derived& Scale(const PointT<double, DIM>& point, double scale)\	 @return The reference to self\
\	 @param scale The scale value\
\	 @param point The scaling center point\
\	 @brief Scale the line by a point\
",
 "output": "#include<catch.hpp>\
#include<testHelper.h>\
\
TEST_CASE(\"Test Scale Method\", \"[Scale]\") {\
\	PointT<double, DIM> point;\
\	double scaleValue;\
\	Derived& ref = Scale(point, scaleValue);\
\	CHECK(ref == expectedScaled);\
}"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] Derived Scaled(const PointT<double, DIM>& point, double scale)\	 @return The scaled line\
\	 @param scale The scale value\
\	 @param point The scaling center point\
\	 @brief Get the line scaled by a point\
",
 "output": "#include<catch.hpp>\
#include<testHelper.h>\
\
TEST_CASE(\"Test Scaled Method\", \"[Scaled]\") {\
\	PointT<double, DIM> point;\
\	double scaleValue;\
\	Derived scaledLine = Scaled(point, scaleValue);\
\	CHECK(scaledLine == expectedScaledLine);\
}"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "Derived& Transform(const TransformationT<double, DIM>& tr)\	 @return The reference to self\
\	 @param tr The transformation\
\	 @brief Transform the line\
",
 "output": "#include<catch.hpp>\
#include<testHelper.h>\
\
TEST_CASE(\"Test Transform Method\", \"[Transform]\") {\
\	TransformationT<double, DIM> transformation;\
\	Derived& ref = Transform(transformation);\
\	CHECK(ref == expectedTransformed);\
}"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] Derived Transformed(const TransformationT<double, DIM>& tr)\	 @return The transformed line\
\	 @param tr The transformation\
\	 @brief Get the transformed line\
",
 "output": "#include<catch.hpp>\
#include<testHelper.h>\
\
TEST_CASE(\"Test Transformed Method\", \"[Transformed]\") {\
\	TransformationT<double, DIM> transformation;\
\	Derived transformedLine = Transformed(transformation);\
\	CHECK(transformedLine == expectedTransformedLine);\
}"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "Derived& Translate(const VectorT<double, DIM>& vec)\	 @return The reference to self\
\	 @param vec The translation vector\
\	 @brief Translate the line by a vector\
",
 "output": "#include<catch.hpp>\
#include<testHelper.h>\
\
TEST_CASE(\"Test Translate Method\", \"[Translate]\") {\
\	VectorT<double, DIM> vector;\
\	Derived& ref = Translate(vector);\
\	CHECK(ref == expectedTranslated);\
}"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "Derived& Translate(const PointT<double, DIM>& p1, const PointT<double, DIM>& p2)\	 @return The reference to self\
\	 @param p2 The target point\
\	 @param p1 The source point\
\	 @brief Translate the line by a vector from a point to another point\
",
 "output": "#include<catch.hpp>\
#include<testHelper.h>\
\
TEST_CASE(\"Test Translate with Points Method\", \"[Translate]\") {\
\	PointT<double, DIM> p1, p2;\
\	Derived& ref = Translate(p1, p2);\
\	CHECK(ref == expectedTranslatedWithPoints);\
}"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] Derived Translated(const VectorT<double, DIM>& vec)\	 @return The translated line\
\	 @param vec The translation vector\
\	 @brief Get the line translated by a vector\
",
 "output": "#include<catch.hpp>\
#include<testHelper.h>\
\
TEST_CASE(\"Test Translated Method\", \"[Translated]\") {\
\	VectorT<double, DIM> vector;\
\	Derived translatedLine = Translated(vector);\
\	CHECK(translatedLine == expectedTranslatedLine);\
}"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] Derived Translated(const PointT<double, DIM>& p1, const PointT<double, DIM>& p2)\	 @return The translated line\
\	 @param p2 The target point\
\	 @param p1 The source point\
\	 @brief Get the line translated by a vector from a point to another point\
",
 "output": "#include<catch.hpp>\
#include<testHelper.h>\
\
TEST_CASE(\"Test Translated with Points Method\", \"[Translated]\") {\
\	PointT<double, DIM> p1, p2;\
\	Derived translatedLine = Translated(p1, p2);\
\	CHECK(translatedLine == expectedTranslatedWithPoints);\
}"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "void SetLocation(const PointT<double, DIM>& point)\	 @param point The location point\
\	 @brief Set the location of the line\
",
 "output": "#include<catch.hpp>\
#include<testHelper.h>\
\
TEST_CASE(\"Test SetLocation Method\", \"[SetLocation]\") {\
\	PointT<double, DIM> point;\
\	SetLocation(point);\
\	// Add checks to validate location set\
}"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "void SetDirection(const DirectionT<double, DIM>& dir)\	 @param dir The line direction\
\	 @brief Set the line direction\
",
 "output": "#include<catch.hpp>\
#include<testHelper.h>\
\
TEST_CASE(\"Test SetDirection Method\", \"[SetDirection]\") {\
\	DirectionT<double, DIM> direction;\
\	SetDirection(direction);\
\	// Add checks to validate direction set\
}"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "void SetPosition(const AxisT<double, DIM>& axis)\	 @param axis The axis\
\	 @brief Set the axis of the line\
",
 "output": "#include<catch.hpp>\
#include<testHelper.h>\
\
TEST_CASE(\"Test SetPosition Method\", \"[SetPosition]\") {\
\	AxisT<double, DIM> axis;\
\	SetPosition(axis);\
\	// Add checks to validate position set\
}"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] const DirectionT<double, DIM>& Direction()\	 @return The direction of the line\
\	 @brief Get the direction of the line\
",
 "output": "#include<catch.hpp>\
#include<testHelper.h>\
\
TEST_CASE(\"Test Direction Method\", \"[Direction]\") {\
\	const DirectionT<double, DIM>& dir = Direction();\
\	CHECK(dir == expectedDirection);\
}"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] const AxisT<double, DIM>& Position()\	 @return The axis of the line\
\	 @brief Get the axis of the line\
",
 "output": "#include<catch.hpp>\
#include<testHelper.h>\
\
TEST_CASE(\"Test Position Method\", \"[Position]\") {\
\	const AxisT<double, DIM>& pos = Position();\
\	CHECK(pos == expectedPosition);\
}"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] auto Angle(const LineBase& other)\	 @return The angle between the line and the other line\
\	 @param other The other line\
\	 @brief Compute the angle between the line and the other line\
",
 "output": "#include<catch.hpp>\
#include<testHelper.h>\
\
TEST_CASE(\"Test Angle Method\", \"[Angle]\") {\
\	LineBase other;\
\	auto angle = Angle(other);\
\	CHECK(angle == expectedAngle);\
}"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "Derived& Reverse()\	 @return The reference to self\
\	 @brief Reverse the line direction\
",
 "output": "#include<catch.hpp>\
#include<testHelper.h>\
\
TEST_CASE(\"Test Reverse Method\", \"[Reverse]\") {\
\	Derived& ref = Reverse();\
\	CHECK(ref == expectedReverse);\
}"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] Derived Reversed()\	 @return The line with reversed direction\
\	 @brief Get the line with reversed direction\
",
 "output": "#include<catch.hpp>\
#include<testHelper.h>\
\
TEST_CASE(\"Test Reversed Method\", \"[Reversed]\") {\
\	Derived reversedLine = Reversed();\
\	CHECK(reversedLine == expectedReversed);\
}"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "Derived& Mirror(const PointT<double, DIM>& point)\	 @return The reference to self\
\	 @param point The mirror center point\
\	 @brief Mirror the line by a point\
",
 "output": "#include<catch.hpp>\
#include<testHelper.h>\
\
TEST_CASE(\"Test Mirror with Point Method\", \"[Mirror]\") {\
\	PointT<double, DIM> point;\
\	Derived& ref = Mirror(point);\
\	CHECK(ref == expectedMirrorWithPoint);\
}"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] Derived Mirrored(const PointT<double, DIM>& point)\	 @return The mirrored line\
\	 @param point The mirror center point\
\	 @brief Get the line mirrored by a point\
",
 "output": "#include<catch.hpp>\
#include<testHelper.h>\
\
TEST_CASE(\"Test Mirrored with Point Method\", \"[Mirrored]\") {\
\	PointT<double, DIM> point;\
\	Derived mirroredLine = Mirrored(point);\
\	CHECK(mirroredLine == expectedMirroredWithPoint);\
}"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "LineS(double a, double b, double c)\	 @param a,b,c The coefficients\
\	 @brief Construct from the algebraic coefficients of 2D line\
",
 "output": "#include<catch.hpp>\
#include<testHelper.h>\
\
TEST_CASE(\"Test LineS Constructor\", \"[LineS]\") {\
\	double a, b, c;\
\	LineS line(a, b, c);\
\	// Add checks to validate line construction\
}"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "void Coefficients(double& a, double& b, double& c)\	 @param[out] a,b,c The coefficients\
\	 @brief The coefficients of the algebraic representation of the 2D line\
",
 "output": "#include<catch.hpp>\
#include<testHelper.h>\
\
TEST_CASE(\"Test Coefficients Method\", \"[Coefficients]\") {\
\	double a, b, c;\
\	Coefficients(a, b, c);\
\	// Add checks to validate coefficients\
}"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] auto Distance(const Point2& p)\	 @return The distance between the point and the line\
\	 @param p The point\
\	 @brief Compute the distance from a point to the line\
",
 "output": "#include<catch.hpp>\
#include<testHelper.h>\
\
TEST_CASE(\"Test Distance Method with Point2\", \"[Distance]\") {\
\	Point2 point;\
\	auto distance = Distance(point);\
\	CHECK(distance == expectedDistance);\
}"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] auto Distance(const LineS& l)\	 @return The distance between two lines\
\	 @param l The other line\
\	 @brief Compute the distance between two lines\
",
 "output": "#include<catch.hpp>\
#include<testHelper.h>\
\
TEST_CASE(\"Test Distance Method with LineS\", \"[Distance]\") {\
\	LineS line;\
\	auto distance = Distance(line);\
\	CHECK(distance == expectedDistanceBetweenLines);\
}"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] auto SquaredDistance(const Point2& p)\	 @return The squared distance between the point and the line\
\	 @param p The point\
\	 @brief Compute the squared distance from a point to the line\
",
 "output": "#include<catch.hpp>\
#include<testHelper.h>\
\
TEST_CASE(\"Test SquaredDistance Method with Point2\", \"[SquaredDistance]\") {\
\	Point2 point;\
\	auto squaredDistance = SquaredDistance(point);\
\	CHECK(squaredDistance == expectedSquaredDistance);\
}"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] auto SquaredDistance(const LineS& l)\	 @return The squared distance between two lines\
\	 @param l The other line\
\	 @brief Compute the squared distance between two lines\
",
 "output": "#include<catch.hpp>\
#include<testHelper.h>\
\
TEST_CASE(\"Test SquaredDistance Method with LineS\", \"[SquaredDistance]\") {\
\	LineS line;\
\	auto squaredDistance = SquaredDistance(line);\
\	CHECK(squaredDistance == expectedSquaredDistanceBetweenLines);\
}"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] LineS Normal(const Point2& p)\	 @return The line passing through a point and perpendicular to the line\
\	 @param p The point\
\	 @brief Get a line passing through a point and perpendicular to the line\
",
 "output": "#include<catch.hpp>\
#include<testHelper.h>\
\
TEST_CASE(\"Test Normal Method with Point2\", \"[Normal]\") {\
\	Point2 point;\
\	LineS normalLine = Normal(point);\
\	CHECK(normalLine == expectedNormalLine);\
}"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "LineS& Rotate(const Point2& point, double angle)\	 @return The reference to self\
\	 @param angle The rotation angle\
\	 @param point The rotation center point\
\	 @brief Rotate the line around a point with an angle in 2D\
",
 "output": "#include<catch.hpp>\
#include<testHelper.h>\
\
TEST_CASE(\"Test Rotate Method\", \"[Rotate]\") {\
\	Point2 center;\
\	double angle;\
\	LineS& ref = Rotate(center, angle);\
\	CHECK(ref == expectedRotated);\
}"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] LineS Rotated(const Point2& point, double angle)\	 @return The rotated line\
\	 @param angle The rotation angle\
\	 @param point The rotation center point\
\	 @brief Get the line rotated around a point with an angle in 2D\
",
 "output": "#include<catch.hpp>\
#include<testHelper.h>\
\
TEST_CASE(\"Test Rotated Method\", \"[Rotated]\") {\
\	Point2 center;\
\	double angle;\
\	LineS rotatedLine = Rotated(center, angle);\
\	CHECK(rotatedLine == expectedRotatedLine);\
}"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] auto Distance(const Point3& p)\	 @return The distance between the point and the line\
\	 @param p The point\
\	 @brief Compute the distance from a point to the line\
",
 "output": "#include<catch.hpp>\
#include<testHelper.h>\
\
TEST_CASE(\"Test Distance Method with Point3\", \"[Distance]\") {\
\	Point3 point;\
\	auto distance = Distance(point);\
\	CHECK(distance == expectedDistance);\
}"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] auto SquaredDistance(const Point3& p)\	 @return The squared distance between the point and the line\
\	 @param p The point\
\	 @brief Compute the squared distance from a point to the line\
",
 "output": "#include<catch.hpp>\
#include<testHelper.h>\
\
TEST_CASE(\"Test SquaredDistance Method with Point3\", \"[SquaredDistance]\") {\
\	Point3 point;\
\	auto squaredDistance = SquaredDistance(point);\
\	CHECK(squaredDistance == expectedSquaredDistance);\
}"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] LineS Normal(const Point3& p)\	 @return The line passing through a point and perpendicular to the line\
\	 @param p The point\
\	 @brief Get a line passing through a point and perpendicular to the line\
",
 "output": "#include<catch.hpp>\
#include<testHelper.h>\
\
TEST_CASE(\"Test Normal Method with Point3\", \"[Normal]\") {\
\	Point3 point;\
\	LineS normalLine = Normal(point);\
\	CHECK(normalLine == expectedNormalLine);\
}"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "LineS& Mirror(const Frame3& frame)\	 @return The reference to self\
\	 @param frame The mirror frame\
\	 @brief Mirror the line by a frame\
",
 "output": "#include<catch.hpp>\
#include<testHelper.h>\
\
TEST_CASE(\"Test Mirror with Frame Method\", \"[Mirror]\") {\
\	Frame3 frame;\
\	LineS& ref = Mirror(frame);\
\	CHECK(ref == expectedMirrorWithFrame);\
}"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] LineS Mirrored(const Frame3& frame)\	 @return The mirrored line\
\	 @param frame The mirror frame\
\	 @brief Get the line mirrored by a frame\
",
 "output": "#include<catch.hpp>\
#include<testHelper.h>\
\
TEST_CASE(\"Test Mirrored with Frame Method\", \"[Mirrored]\") {\
\	Frame3 frame;\
\	LineS mirroredLine = Mirrored(frame);\
\	CHECK(mirroredLine == expectedMirroredWithFrame);\
}"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "LineS& Rotate(const Axis3& axis, double angle)\	 @return The reference to self\
\	 @param angle The rotation angle\
\	 @param axis The rotation axis\
\	 @brief Rotate the line around an axis with an angle in 3D\
",
 "output": "#include<catch.hpp>\
#include<testHelper.h>\
\
TEST_CASE(\"Test Rotate with Axis Method\", \"[Rotate]\") {\
\	Axis3 axis;\
\	double angle;\
\	LineS& ref = Rotate(axis, angle);\
\	CHECK(ref == expectedRotatedWithAxis);\
}"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] LineS Rotated(const Axis3& axis, double angle)\	 @return The rotated line\
\	 @param angle The rotation angle\
\	 @param axis The rotation axis\
\	 @brief Get the line rotated around an axis with an angle in 3D\
",
 "output": "#include<catch.hpp>\
#include<testHelper.h>\
\
TEST_CASE(\"Test Rotated with Axis Method\", \"[Rotated\") {\
\	Axis3 axis;\
\	double angle;\
\	LineS rotatedLine = Rotated(axis, angle);\
\	CHECK(rotatedLine == expectedRotatedLine);\
}"}
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "template<int DIM2 = DIM, std::enable_if_t<DIM2 == 2, int> = 0> void Coefficients(double& a, double& b, double& c, double& d, double& e, double& f
[nodiscard]] double Focal()	 @return The focal length
	 @brief Get the focal length
[[nodiscard]] double FocalParameter()	 @return The focal parameter
	          Focal parameter = 2 * focalLength.
	 @details The focal parameter of parabola is the distance from the focus to the directrix.
	 @brief Get the focal parameter of the parabola
[[nodiscard]] double SemilatusRectum()	 @return The semilatus rectum
	          Semilatus rectum = 2 * focalLength
	 @details The semilatus rectum of parabola is half of the length of the chord through a focus parallel to the directrix.
	 @brief Get the semilatus rectum of the parabola
[[nodiscard]] AxisT<double, DIM> Directrix()	 @return The directrix
	 @brief Get the directrix
ParabolaS& Scale(const PointT<double, DIM>& point, double scale)	 @return The reference to self
	 @param scale The scale value
	 @param point The scaling center point
	 @brief Scale the parabola by a center point
ParabolaS& Transform(const TransformationT<double, DIM>& tr)	 @return The reference to self
	 @param tr The transformation
	 @brief Transform the parabola",
 "output": "#include <catch.hpp>
#include <testHelper.h>
#include <geometry/Geom2Parabola.hpp>

using namespace AMCAX;
using namespace std;

TEST_CASE(\"case1:this is a case for Test Geom2Parabola\", \"[math][Geom2Parabola][P1\")

	//Geom2Parabola构造函数调用
	Axis2 axis;//默认二维坐标系中为X轴方向(1.0，0.0)
	double focal = 5.0;
	bool isRight = true;
	Geom2Parabola g2p(axis, focal, isRight);

	//FocalParameter()函数调用，获取焦点到圆锥曲线准线的距离
	SECTION(\"FocalParameter\")
	
		double FP = g2p.FocalParameter();
		double fp = 2 * focal;
		CHECK(FP == fp);
	

	//SemilatusRectum函数调用
	SECTION(\"SemilatusRectum\")
	
		double SR = g2p.SemilatusRectum();
		double sr = 2 * focal;
		CHECK(SR == sr);
	

"}
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "template<int DIM2 = DIM, std::enable_if_t<DIM2 == 2, int> = 0> void Coefficients(double& a, double& b, double& c, double& d, double& e, double& f
[nodiscard]] double Focal()	 @return The focal length
	 @brief Get the focal length
[[nodiscard]] double FocalParameter()	 @return The focal parameter
	          Focal parameter = 2 * focalLength.
	 @details The focal parameter of parabola is the distance from the focus to the directrix.
	 @brief Get the focal parameter of the parabola
[[nodiscard]] double SemilatusRectum()	 @return The semilatus rectum
	          Semilatus rectum = 2 * focalLength
	 @details The semilatus rectum of parabola is half of the length of the chord through a focus parallel to the directrix.
	 @brief Get the semilatus rectum of the parabola
[[nodiscard]] AxisT<double, DIM> Directrix()	 @return The directrix
	 @brief Get the directrix
ParabolaS& Scale(const PointT<double, DIM>& point, double scale)	 @return The reference to self
	 @param scale The scale value
	 @param point The scaling center point
	 @brief Scale the parabola by a center point
ParabolaS& Transform(const TransformationT<double, DIM>& tr)	 @return The reference to self
	 @param tr The transformation
	 @brief Transform the parabola",
 "output": "#include <catch.hpp>
#include <testHelper.h>
#include <geometry/Geom3Parabola.hpp>

using namespace AMCAX;
using namespace std;

TEST_CASE(\"case1:this is a case for Test Geom3Parabola\", \"[math][Geom3Parabola][P1\")

	//Geom3Parabola构造函数调用
	Frame3 frame;
	double focal = 5.0;
	Geom3Parabola g3p(frame, focal);

	//FocalParameter()函数调用，获取焦点到圆锥曲线准线的距离
	SECTION(\"FocalParameter\")
	
		double FP = g3p.FocalParameter();
		double fp = 2 * focal;
		CHECK(FP == fp);
	

	//SemilatusRectum函数调用
	SECTION(\"SemilatusRectum\")
	
		double SR = g3p.SemilatusRectum();
		double sr = 2 * focal;
		CHECK(SR == sr);
	


"}
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "template<int DIM2 = DIM, std::enable_if_t<DIM2 == 2, int> = 0> void Coefficients(double& a, double& b, double& c, double& d, double& e, double& f
[nodiscard]] double Focal()	 @return The focal length
	 @brief Get the focal length
[[nodiscard]] double FocalParameter()	 @return The focal parameter
	          Focal parameter = 2 * focalLength.
	 @details The focal parameter of parabola is the distance from the focus to the directrix.
	 @brief Get the focal parameter of the parabola
[[nodiscard]] double SemilatusRectum()	 @return The semilatus rectum
	          Semilatus rectum = 2 * focalLength
	 @details The semilatus rectum of parabola is half of the length of the chord through a focus parallel to the directrix.
	 @brief Get the semilatus rectum of the parabola
[[nodiscard]] AxisT<double, DIM> Directrix()	 @return The directrix
	 @brief Get the directrix
ParabolaS& Scale(const PointT<double, DIM>& point, double scale)	 @return The reference to self
	 @param scale The scale value
	 @param point The scaling center point
	 @brief Scale the parabola by a center point
ParabolaS& Transform(const TransformationT<double, DIM>& tr)	 @return The reference to self
	 @param tr The transformation
	 @brief Transform the parabola",
 "output": "#include <catch.hpp>
#include <testHelper.h>
#include <math/ParabolaT.hpp>

using namespace AMCAX;
using namespace std;

TEST_CASE(\"case1:this is a case for Test Parabola2\", \"[math][Parabola2][P1\")

	//Parabola2构造函数调用
	Axis2 axis;//默认二维坐标系中为X轴方向(1.0，0.0)
	double focal = 5.0;
	bool isRight = true;
	Parabola2 parabola(axis, focal, isRight);

	//FocalParameter()函数调用，获取焦点到圆锥曲线准线的距离
	SECTION(\"FocalParameter\")
	
		double FP = parabola.FocalParameter();
		double fp = 2 * focal;
		CHECK(FP == fp);
	

	//SemilatusRectum函数调用
	SECTION(\"SemilatusRectum\")
	
		double SR = parabola.SemilatusRectum();
		double sr = 2 * focal;
		CHECK(SR == sr);"}
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "template<int DIM2 = DIM, std::enable_if_t<DIM2 == 2, int> = 0> void Coefficients(double& a, double& b, double& c, double& d, double& e, double& f
[nodiscard]] double Focal()	 @return The focal length
	 @brief Get the focal length
[[nodiscard]] double FocalParameter()	 @return The focal parameter
	          Focal parameter = 2 * focalLength.
	 @details The focal parameter of parabola is the distance from the focus to the directrix.
	 @brief Get the focal parameter of the parabola
[[nodiscard]] double SemilatusRectum()	 @return The semilatus rectum
	          Semilatus rectum = 2 * focalLength
	 @details The semilatus rectum of parabola is half of the length of the chord through a focus parallel to the directrix.
	 @brief Get the semilatus rectum of the parabola
[[nodiscard]] AxisT<double, DIM> Directrix()	 @return The directrix
	 @brief Get the directrix
ParabolaS& Scale(const PointT<double, DIM>& point, double scale)	 @return The reference to self
	 @param scale The scale value
	 @param point The scaling center point
	 @brief Scale the parabola by a center point
ParabolaS& Transform(const TransformationT<double, DIM>& tr)	 @return The reference to self
	 @param tr The transformation
	 @brief Transform the parabola",
 "output": "#include <catch.hpp>
#include <testHelper.h>
#include <math/ParabolaT.hpp>

using namespace AMCAX;
using namespace std;

TEST_CASE(\"case1:this is a case for Test Parabola3\", \"[math][Parabola3][P1\")

	//Parabola3构造函数调用
	Frame3 frame;//默认二维坐标系中为X轴方向(1.0，0.0)
	double focal = 5.0;
	Parabola3 parabola(frame, focal);

	//FocalParameter()函数调用，获取焦点到圆锥曲线准线的距离
	SECTION(\"FocalParameter\")
	
		double FP = parabola.FocalParameter();
		double fp = 2 * focal;
		CHECK(FP == fp);
	

	//SemilatusRectum函数调用
	SECTION(\"SemilatusRectum\")
	
		double SR = parabola.SemilatusRectum();
		double sr = 2 * focal;
		CHECK(SR == sr);
	


"}
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[nodiscard]] AMCAX_API double Distance(const Point3& point)	 @return The point-plane distance
	 @param point The point
	 @brief Compute the distance from a point to the plane
AMCAX_API void Coefficients(double& a, double& b, double& c, double& d)	 @param[out] a,b,c,d The coefficients
	 @brief Get coefficients of algebraic representation: ax + by + cz + d = 0
Plane()	 Default constructor
AMCAX_API explicit Plane(const Frame3& frame)	 @param frame The local frame
	 @brief Construct from a local frame, XOY plane
AMCAX_API Plane(const Point3& point, const Direction3& dir)	 @param dir The direction
	 @param point The point
	 @brief Construct from a point and a direction
AMCAX_API Plane(double a, double b, double c, double d)	 @param a,b,c,d The coefficients
	 @brief Construct from an algebraic representation: ax + by + cz + d = 0
[[nodiscard]] AMCAX_API double Distance(const Line3& line)	 @return The line-plane distance
	 @param line The line
	 @brief Compute the distance from a line to the plane
[[nodiscard]] AMCAX_API double Distance(const Plane& plane)	 @return The plane-plane distance
	 @param plane The other plane
	 @brief Compute the distance from another plane to the plane
[[nodiscard]] AMCAX_API double SquaredDistance(const Point3& point)	 @return The squared point-plane distance
	 @param point The point
	 @brief Compute the squared distance from a point to the plane
[[nodiscard]] AMCAX_API double SquaredDistance(const Line3& line)	 @return The squared line-plane distance
	 @param line The line
	 @brief Compute the squared distance from a line to the plane
[[nodiscard]] AMCAX_API double SquaredDistance(const Plane& plane)	 @return The squared plane-plane distance
	 @param plane The other plane
	 @brief Compute the squared distance from another plane to the plane
[[nodiscard]] AMCAX_API bool Contains(const Point3& point, double tol)	 @return True if the distance between the point and the plane is under the distance tolerance
	 @param tol The distance tolerance
	 @param point The point
	 @brief Determines whether the plane contains a point under a tolerance or not
[[nodiscard]] AMCAX_API bool Contains(const Line3& line, double distol, double angtol)	 @return True if the distance from the location point of the line to the plane is under the distance tolerance and the direction of the line is perpendicular to the normal direction of the plane
	 @param angtol The angle tolerance
	 @param distol The distance tolerance
	 @param line The line
	 @brief Determines whether the plane contains a line under a distance tolerance and an angle tolerance",
 "output": "#include \"catch.hpp\"
#include <testHelper.h>
#include <math/Plane.hpp>

using namespace AMCAX;

TEST_CASE(\"case1: Plane construction and methods\", \"[math][Plane][p1]\") 
    SECTION(\"Default constructor\") 
        Plane plane;
        //z = 0
        double a, b, c, d;
        plane.Coefficients(a, b, c, d);
        REQUIRE(a == Approx(0));
        REQUIRE(b == Approx(0));
        REQUIRE(c == Approx(1));
        REQUIRE(d == Approx(0));
    

    SECTION(\"Construct from frame\") 
        Frame3 frame1(Point3(0.0, 0.0, 0.0), Direction3(0.0, 0.0, 1.0));
        Frame3 frame2(Point3(1.0, 0.0, 0.0), Direction3(2.0, 1.0, 1.0));
        Plane plane1(frame1);
        Plane plane2(frame2);  // 2x + y + z  -2 = 0
        double a1, b1, c1, d1;
        plane1.Coefficients(a1, b1, c1, d1);
        double a2, b2, c2, d2;
        plane2.Coefficients(a2, b2, c2, d2);

        // Direction3 is (0.0, 0.0, 1.0) z = 0
        REQUIRE(a1 == Approx(0));
        REQUIRE(b1 == Approx(0));
        REQUIRE(c1 == Approx(1));
        REQUIRE(d1 == Approx(0));

        REQUIRE(a2 == Approx(2. / std::sqrt(6)));
        REQUIRE(b2 == Approx(1. / std::sqrt(6)));
        REQUIRE(c2 == Approx(1. / std::sqrt(6)));
        REQUIRE(d2 == Approx(-2. / std::sqrt(6)));

    

    SECTION(\"Construct from point and direction\") 
        Point3 point(1., 1., 1.);
        Direction3 dir(0., 0., 1.);
        Plane plane(point, dir);  // z = 1

        Point3 point2(3., 4., 4.);
        Direction3 dir2(2., 2., 1.);
        Plane plane2(point2, dir2);  // 2x + 2y + z + d = 0 => d = -6-8-4 = -18 => 2x + 2y + z -18 = 0 => 2/3x + 2/3y + 1/3z - 6 = 0

        double a, b, c, d;
        plane.Coefficients(a, b, c, d);
        double a2, b2, c2, d2;
        plane2.Coefficients(a2, b2, c2, d2);

        REQUIRE(a == Approx(0));
        REQUIRE(b == Approx(0));
        REQUIRE(c == Approx(1));
        REQUIRE(d == Approx(-1));

        REQUIRE(a2 == Approx(2./3).margin(0.0001));
        REQUIRE(b2 == Approx(2./3).margin(0.0001));
        REQUIRE(c2 == Approx(1./3).margin(0.0001));
        REQUIRE(d2 == Approx(-6));
    

    SECTION(\"Construct from algebraic representation\") 
        Plane plane(1., 1., 1., -3.);  // Construct the plane directly using algebraic coefficients
        double a, b, c, d;
        plane.Coefficients(a, b, c, d);  // Here the output coefficients are normalized to turn the normal vector (a, b, c) of the plane into a unit vector
        REQUIRE(a == Approx(1./std::sqrt(3)).margin(0.001));
        REQUIRE(b == Approx(1. / std::sqrt(3)).margin(0.001));
        REQUIRE(c == Approx(1. / std::sqrt(3)).margin(0.001));
        REQUIRE(d == Approx(-3. / std::sqrt(3)).margin(0.001));
    

    SECTION(\"Distance methods\") 

        // Point-to-plane solving
        std::function<double(const Plane&, const Point3&)> pointToPlane = [](const Plane& plane, const Point3& point)->double 
            double a, b, c, d;
            plane.Coefficients(a, b, c, d);
            return std::fabs(a * point.X() + b * point.Y() + c * point.Z() + d);
        ;

        // Line-to-plane solving
        std::function<double(const Plane&, const Line3&)> lineToPlane = [](const Plane& plane, const Line3& line)->double 
            Point3 point = line.Location();
            double a, b, c, d;
            plane.Coefficients(a, b, c, d);
            if (line.Direction().Dot(Vector3(a, b, c)) != 0)  // The dot product of the vector is not equal to 0, indicating that the line is not parallel to the plane.
                return 0;
            return std::fabs(a * point.X() + b * point.Y() + c * point.Z() + d);
        ;

        //  plane-to-plane Solving
        std::function<double(const Plane&, const Plane&)> planeToPlane = [](const Plane& plane1, const Plane& plane2)->double 
            double a1, b1, c1, d1, a2, b2, c2, d2;
            plane1.Coefficients(a1, b1, c1, d1);
            plane2.Coefficients(a2, b2, c2, d2);
            if (a1 != a2 || b1 != b2 || c1 != c2) return 0;
            return std::fabs(d1 - d2);
        ;

        Plane plane(0., 0., 1., -1.); // z = 1
        Point3 point(1., 1., 2.);
        Line3 line(Point3(1., 1., 3.), Direction3(0., 0., 1.));
        Plane otherPlane1(0, 0, 1, -2); // z = 2
        Plane otherPlane2(1, 0, 1, -2); // x + z = 2  disparallel

        // The distance between a point and a plane
        REQUIRE(plane.Distance(point) == Approx(pointToPlane(plane, point)));
        REQUIRE(plane.SquaredDistance(point) == Approx(pointToPlane(plane, point) * pointToPlane(plane, point)));
        // The distance between a line and a plane
        REQUIRE(plane.Distance(line) == Approx(lineToPlane(plane, line)));
        REQUIRE(plane.SquaredDistance(line) == Approx(lineToPlane(plane, line) * lineToPlane(plane, line)));
        // The distance between the sides
        // parallel
        REQUIRE(plane.Distance(otherPlane1) == Approx(planeToPlane(plane, otherPlane1)));
        REQUIRE(plane.SquaredDistance(otherPlane1) == Approx(planeToPlane(plane, otherPlane1) * planeToPlane(plane, otherPlane1)));
        // disparallel
        REQUIRE(plane.Distance(otherPlane2) == Approx(planeToPlane(plane, otherPlane2)));
        REQUIRE(plane.SquaredDistance(otherPlane2) == Approx(planeToPlane(plane, otherPlane2) * planeToPlane(plane, otherPlane2)));
    

    SECTION(\"Contains methods\") 
        // Solving for point on plane
        std::function<bool(const Plane&, const Point3&)> pointInPlane = [(const Plane& plane, const Point3& point)->bool 
            Point3 planePoint = plane.Location();  // Return a point on the plane
            Vector3 planeVector(planePoint, point);  // Utilize a vector formed by the plane and the target point
            double a, b, c, d;
            plane.Coefficients(a, b, c, d);
            // Use the dot product with the normal vector to determine if it is zero; if it is zero, it means it is parallel and lies on the plane.
            return planeVector.Dot(Vector3(a, b, c)) == 0;
        ;

        Plane plane(0., 0., 1., -1.); // z = 1
        Point3 point(1., 1., 1.);
        Point3 point2(1., 1., 2.);
        Line3 line(Point3(1., 1., 1.), Direction3(1., 0., 0.));
        Line3 line2(Point3(1., 1., 1.), Direction3(0., 0., 1.));  // If the point is on the plane, the direction of the line is not perpendicular to the normal vector of the plane  = Plane do not contain lines
        Line3 line3(Point3(1., 1., 0.), Direction3(1., 0., 0.));

        // Points are contained in faces
        REQUIRE(plane.Contains(point, 1e-6) == pointInPlane(plane, point));
        REQUIRE(plane.Contains(point2, 1e-6) == pointInPlane(plane, point2));
        // Lines are contained in surfaces
        REQUIRE(plane.Contains(line, 1e-6, 1e-6));
        REQUIRE_FALSE(plane.Contains(line2, 1e-6, 1e-6 * (M_PI / 180)));
        REQUIRE_FALSE(plane.Contains(line3, 1e-6, 1e-6 * (M_PI / 180)));
    

    SECTION(\"Reverse methods\") 
        Frame3 frame1(Point3(0.0, 0.0, 0.0), Direction3(0.0, 0.0, 1.0));  // X(1.0, 0.0, 0.0) Y(0.0, 1.0, 0.0)
        Frame3 frame2(Point3(0.0, 0.0, 0.0), Direction3(1.0, 1.0, 1.0));
        Plane plane1(frame1);
        Plane plane2(frame2);

        Direction3 beforeXDir1 = plane1.XAxis().Direction();
        Direction3 beforeYDir1 = plane1.YAxis().Direction();
        Direction3 beforeXDir2 = plane2.XAxis().Direction();
        Direction3 beforeYDir2 = plane2.YAxis().Direction();
        //std::cout << \"beforeXDir1: \" << beforeXDir1.X() << \", \" << beforeXDir1.Y() << \", \" << beforeXDir1.Z() << std::endl;
        //std::cout << \"beforeYDir1: \" << beforeYDir1.X() << \", \" << beforeYDir1.Y() << \", \" << beforeYDir1.Z() << std::endl;
        //std::cout << \"beforeXDir2: \" << beforeXDir2.X() << \", \" << beforeXDir2.Y() << \", \" << beforeXDir2.Z() << std::endl;
        //std::cout << \"beforeYDir2: \" << beforeYDir2.X() << \", \" << beforeYDir2.Y() << \", \" << beforeYDir2.Z() << std::endl;

        plane1.UReverse();
        plane1.VReverse();
        plane2.UReverse();
        plane2.VReverse();
        Direction3 afterXDir1 = plane1.XAxis().Direction();
        Direction3 afterYDir1 = plane1.YAxis().Direction();
        Direction3 afterXDir2 = plane2.XAxis().Direction();
        Direction3 afterYDir2 = plane2.YAxis().Direction();
        //std::cout << \"afterXDir1: \" << afterXDir1.X() << \", \" << afterXDir1.Y() << \", \" << afterXDir1.Z() << std::endl;
        //std::cout << \"afterYDir1: \" << afterYDir1.X() << \", \" << afterYDir1.Y() << \", \" << afterYDir1.Z() << std::endl;
        //std::cout << \"afterXDir2: \" << afterXDir2.X() << \", \" << afterXDir2.Y() << \", \" << afterXDir2.Z() << std::endl;
        //std::cout << \"afterYDir2: \" << afterYDir2.X() << \", \" << afterYDir2.Y() << \", \" << afterYDir2.Z() << std::endl;

        REQUIRE(beforeXDir1.IsOpposite(afterXDir1, 1e-5 * (M_PI / 180)));  // IsOpposite: Determine whether two directions are opposite within a specified angular tolerance.
        REQUIRE(beforeYDir1.IsOpposite(afterYDir1, 1e-5 * (M_PI / 180)));
        REQUIRE(beforeXDir2.IsOpposite(afterXDir2, 1e-5 * (M_PI / 180)));
        REQUIRE(beforeYDir2.IsOpposite(afterYDir2, 1e-5 * (M_PI / 180)));
    
"}
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[nodiscard]] AMCAX_API double Distance(const Point3& point)	 @return The point-plane distance
	 @param point The point
	 @brief Compute the distance from a point to the plane",
 "output": "#include<catch.hpp>
#include<testHelper.h>

TEST_CASE(\"case1: this is a test for Distance with Point3\", \"[nurbs][ModifyEndToPlane][P1]\")
	Point3 testPoint(1.0, 2.0, 3.0);
	double result = Distance(testPoint);
	CHECK(result >= 0);"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "AMCAX_API void Coefficients(double& a, double& b, double& c, double& d)	 @param[out] a,b,c,d The coefficients
	 @brief Get coefficients of algebraic representation: ax + by + cz + d = 0",
 "output": "#include<catch.hpp>
#include<testHelper.h>

TEST_CASE(\"case1: this is a test for Coefficients\", \"[nurbs][ModifyEndToPlane][P1]\")
	double a, b, c, d;
	Coefficients(a, b, c, d);
	CHECK(a != 0);
	CHECK(b != 0);
	CHECK(c != 0);
	CHECK(d != 0);"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "AMCAX_API explicit Plane(const Frame3& frame)	 @param frame The local frame
	 @brief Construct from a local frame, XOY plane",
 "output": "#include<catch.hpp>
#include<testHelper.h>

TEST_CASE(\"case1: this is a test for Plane constructor with Frame3\", \"[nurbs][ModifyEndToPlane][P1]\")
	Frame3 frame;
	Plane myPlane(frame);
	CHECK(myPlane.IsValid());"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "AMCAX_API Plane(const Point3& point, const Direction3& dir)	 @param dir The direction
	 @param point The point
	 @brief Construct from a point and a direction",
 "output": "#include<catch.hpp>
#include<testHelper.h>

TEST_CASE(\"case1: this is a test for Plane constructor with Point3 and Direction3\", \"[nurbs][ModifyEndToPlane][P1]\")
	Point3 testPoint(1.0, 2.0, 3.0);
	Direction3 testDir(0.0, 1.0, 0.0);
	Plane myPlane(testPoint, testDir);
	CHECK(myPlane.IsValid());"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "AMCAX_API Plane(double a, double b, double c, double d)	 @param a,b,c,d The coefficients
	 @brief Construct from an algebraic representation: ax + by + cz + d = 0",
 "output": "#include<catch.hpp>
#include<testHelper.h>

TEST_CASE(\"case1: this is a test for Plane constructor with coefficients\", \"[nurbs][ModifyEndToPlane][P1]\")
	Plane myPlane(1.0, 2.0, 3.0, 4.0);
	CHECK(myPlane.IsValid());"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] AMCAX_API double Distance(const Line3& line)	 @return The line-plane distance
	 @param line The line
	 @brief Compute the distance from a line to the plane",
 "output": "#include<catch.hpp>
#include<testHelper.h>

TEST_CASE(\"case1: this is a test for Distance with Line3\", \"[nurbs][ModifyEndToPlane][P1]\")
	Line3 testLine;
	double result = Distance(testLine);
	CHECK(result >= 0);"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] AMCAX_API double Distance(const Plane& plane)	 @return The plane-plane distance
	 @param plane The other plane
	 @brief Compute the distance from another plane to the plane",
 "output": "#include<catch.hpp>
#include<testHelper.h>

TEST_CASE(\"case1: this is a test for Distance with Plane\", \"[nurbs][ModifyEndToPlane][P1]\")
	Plane otherPlane;
	double result = Distance(otherPlane);
	CHECK(result >= 0);"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] AMCAX_API double SquaredDistance(const Point3& point)	 @return The squared point-plane distance
	 @param point The point
	 @brief Compute the squared distance from a point to the plane",
 "output": "#include<catch.hpp>
#include<testHelper.h>

TEST_CASE(\"case1: this is a test for SquaredDistance with Point3\", \"[nurbs][ModifyEndToPlane][P1]\")
	Point3 testPoint(1.0, 2.0, 3.0);
	double result = SquaredDistance(testPoint);
	CHECK(result >= 0);"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] AMCAX_API double SquaredDistance(const Line3& line)	 @return The squared line-plane distance
	 @param line The line
	 @brief Compute the squared distance from a line to the plane",
 "output": "#include<catch.hpp>
#include<testHelper.h>

TEST_CASE(\"case1: this is a test for SquaredDistance with Line3\", \"[nurbs][ModifyEndToPlane][P1]\")
	Line3 testLine;
	double result = SquaredDistance(testLine);
	CHECK(result >= 0);"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] AMCAX_API double SquaredDistance(const Plane& plane)	 @return The squared plane-plane distance
	 @param plane The other plane
	 @brief Compute the squared distance from another plane to the plane",
 "output": "#include<catch.hpp>
#include<testHelper.h>

TEST_CASE(\"case1: this is a test for SquaredDistance with Plane\", \"[nurbs][ModifyEndToPlane][P1]\")
	Plane otherPlane;
	double result = SquaredDistance(otherPlane);
	CHECK(result >= 0);"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] AMCAX_API bool Contains(const Point3& point, double tol)	 @return True if the distance between the point and the plane is under the distance tolerance
	 @param tol The distance tolerance
	 @param point The point
	 @brief Determines whether the plane contains a point under a tolerance or not",
 "output": "#include<catch.hpp>
#include<testHelper.h>

TEST_CASE(\"case1: this is a test for Contains with Point3\", \"[nurbs][ModifyEndToPlane][P1]\")
	Point3 testPoint(1.0, 2.0, 3.0);
	double tolerance = 0.1;
	bool result = Contains(testPoint, tolerance);
	CHECK(result == true || result == false);"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] AMCAX_API bool Contains(const Line3& line, double distol, double angtol)	 @return True if the distance from the location point of the line to the plane is under the distance tolerance and the direction of the line is perpendicular to the normal direction of the plane
	 @param angtol The angle tolerance
	 @param distol The distance tolerance
	 @param line The line
	 @brief Determines whether the plane contains a line under a distance tolerance and an angle tolerance",
 "output": "#include<catch.hpp>
#include<testHelper.h>

TEST_CASE(\"case1: this is a test for Contains with Line3\", \"[nurbs][ModifyEndToPlane][P1\")
	Line3 testLine;
	double distanceTolerance = 0.1;
	double angleTolerance = 0.1;
	bool result = Contains(testLine, distanceTolerance, angleTolerance);
	CHECK(result == true || result == false);"}
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[nodiscard]] AMCAX_API double Radius()	 @return The radius
	 @brief Get the radius
AMCAX_API void SetRadius(double r)	 @param r The radius
	 @brief Set the radius
AMCAX_API void Coefficients(double& a1, double& a2, double& a3, double& b1, double& b2, double& b3, double& c1, double& c2, double& c3, double& d)	 @param[out] a1,a2,a3,b1,b2,b3,c1,c2,c3,d The coefficients
	 @details The algebraic representation of the sphere is a_1 x^2 + a_2 y^2 + a_3 z^2 + 2 (b_1 xy + b_2 xz + b_3 yz) + 2 (c_1 x + c_2 y + c_3 z) + d = 0
	 @brief Get the coefficients of the algebraic representation of the sphere
AMCAX_API Sphere& Scale(const Point3& point, double scale)	 @return The reference to self
	 @param scale The scale value
	 @param point The scaling center point
	 @brief Scale the sphere by a point
AMCAX_API Sphere& Transform(const Transformation3& tr)	 @return The reference to self
	 @param tr The transformation
	 @brief Transform the sphere",
 "output": "#include<catch.hpp>
#include<testHelperBase.h>
#include <polymeshAPI/MeshMakeSphere.hpp>
#include <polymesh/PolyMeshIO.hpp>
#include <polymeshAPI/MeshSubdivideHE.hpp>
using namespace AMCAX;

TEST_CASE(\"case1: MeshMakeSphere  \", \"[polymeshAPI][SubD][MeshMakeSphere][P1\") 
	double r = 2.1;
	AMCAX::SubD::MeshMakeSphere sphere(r);
	AMCAX::SubD::PolyMesh* mesh = sphere.BuildMesh();
	CHECK(mesh != nullptr);
	AMCAX::SubD::MeshSubdivideHE::CatmullClark(mesh, 3);
	bool result = AMCAX::SubD::PolyMeshIO::WriteMesh(OUTPUT_PATH_PREFIX\"MeshMakeSphere_case01.obj\", mesh);
	CHECK(result == true);
"}
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[nodiscard]] AMCAX_API double MajorRadius()	 @return The major radius
	 @brief Get the major radius",
 "output": "#include<catch.hpp>
#include<testHelper.h>

#include <modeling/MakeTorus.hpp>
#include <common/CartesianCoordinateSystem.hpp>
#include <topology/TopoBuilder.hpp>

TEST_CASE(\"bug1: MakeTorus  https://qa.amcax.net/bug-view-445.html \", \"[modeling][MakeTorus][P1][fixbug]\")

	// Test for MajorRadius
"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] AMCAX_API double MinorRadius()	 @return The minor radius
	 @brief Get the minor radius",
 "output": "#include<catch.hpp>
#include<testHelper.h>

#include <modeling/MakeTorus.hpp>
#include <common/CartesianCoordinateSystem.hpp>
#include <topology/TopoBuilder.hpp>

TEST_CASE(\"bug2: MakeTorus  https://qa.amcax.net/bug-view-445.html \", \"[modeling][MakeTorus][P1][fixbug]\")

	// Test for MinorRadius
"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "[[nodiscard]] AMCAX_API double Area()	 @return The area of the torus
	 @brief Get the area of the torus",
 "output": "#include<catch.hpp>
#include<testHelper.h>

#include <modeling/MakeTorus.hpp>
#include <common/CartesianCoordinateSystem.hpp>
#include <topology/TopoBuilder.hpp>

TEST_CASE(\"bug3: MakeTorus  https://qa.amcax.net/bug-view-445.html \", \"[modeling][MakeTorus][P1][fixbug]\")

	// Test for Area
"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "AMCAX_API void UReverse()	 @brief Reverse the u parameter",
 "output": "#include<catch.hpp>
#include<testHelper.h>

#include <modeling/MakeTorus.hpp>
#include <common/CartesianCoordinateSystem.hpp>
#include <topology/TopoBuilder.hpp>

TEST_CASE(\"bug4: MakeTorus  https://qa.amcax.net/bug-view-445.html \", \"[modeling][MakeTorus][P1][fixbug]\")

	// Test for UReverse
"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "AMCAX_API void VReverse()	 @brief Reverse the v parameter",
 "output": "#include<catch.hpp>
#include<testHelper.h>

#include <modeling/MakeTorus.hpp>
#include <common/CartesianCoordinateSystem.hpp>
#include <topology/TopoBuilder.hpp>

TEST_CASE(\"bug5: MakeTorus  https://qa.amcax.net/bug-view-445.html \", \"[modeling][MakeTorus][P1][fixbug]\")

	// Test for VReverse
"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "AMCAX_API void SetMajorRadius(double r)	 @param r The major radius
	 @brief Set the major radius",
 "output": "#include<catch.hpp>
#include<testHelper.h>

#include <modeling/MakeTorus.hpp>
#include <common/CartesianCoordinateSystem.hpp>
#include <topology/TopoBuilder.hpp>

TEST_CASE(\"bug6: MakeTorus  https://qa.amcax.net/bug-view-445.html \", \"[modeling][MakeTorus][P1][fixbug]\")

	// Test for SetMajorRadius
"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "AMCAX_API void SetMinorRadius(double r)	 @param r The minor radius
	 @brief Set the minor radius",
 "output": "#include<catch.hpp>
#include<testHelper.h>

#include <modeling/MakeTorus.hpp>
#include <common/CartesianCoordinateSystem.hpp>
#include <topology/TopoBuilder.hpp>

TEST_CASE(\"bug7: MakeTorus  https://qa.amcax.net/bug-view-445.html \", \"[modeling][MakeTorus][P1][fixbug]\")

	// Test for SetMinorRadius
"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "AMCAX_API void Coefficients(std::array<double, 35>& coeff)	 @param[out] coeff The coefficients
	 @brief Get the coefficients of the algebraic representation of the torus",
 "output": "#include<catch.hpp>
#include<testHelper.h>

#include <modeling/MakeTorus.hpp>
#include <common/CartesianCoordinateSystem.hpp>
#include <topology/TopoBuilder.hpp>

TEST_CASE(\"bug8: MakeTorus  https://qa.amcax.net/bug-view-445.html \", \"[modeling][MakeTorus][P1][fixbug]\")

	// Test for Coefficients
"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "AMCAX_API Torus& Scale(const Point3& point, double scale)	 @return The reference to self
	 @param scale The scale value
	 @param point The scaling center point
	 @brief Scale the torus by a point",
 "output": "#include<catch.hpp>
#include<testHelper.h>

#include <modeling/MakeTorus.hpp>
#include <common/CartesianCoordinateSystem.hpp>
#include <topology/TopoBuilder.hpp>

TEST_CASE(\"bug9: MakeTorus  https://qa.amcax.net/bug-view-445.html \", \"[modeling][MakeTorus][P1][fixbug]\")

	// Test for Scale
"},
{"instruction": "Generate a test program based on the following method declarations and parameter parsing.",
 "input": "AMCAX_API Torus& Transform(const Transformation3& tr)	 @return The reference to self
	 @param tr The transformation
	 @brief Transform the torus",
 "output": "#include<catch.hpp>
#include<testHelper.h>

#include <modeling/MakeTorus.hpp>
#include <common/CartesianCoordinateSystem.hpp>
#include <topology/TopoBuilder.hpp>

TEST_CASE(\"bug10: MakeTorus  https://qa.amcax.net/bug-view-445.html \", \"[modeling][MakeTorus][P1][fixbug\")

	// Test for Transform
"}