{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API ComputePointsAbscissa(double tol, const Adaptor3Curve& c, double abscissa, double u0)	 @param u0 The starting parameter
	 @param abscissa The arc length
	 @param c The curve
	 @param tol The tolerance
	 @brief Compute the parameter of a point on a 3D curve with given arc length and a tolerance
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <geometry/MakeGeom2Circle.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/ComputePointsAbscissa.hpp>
#include <geometry/MakeGeom2Hyperbola.hpp>
#include <modeling/MakeEdge.hpp>
#include <geometry/GeometryTool.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/MakeGeom2Ellipse.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/AdaptorGeom3Curve.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <geometry/MakeGeom3Hyperbola.hpp>
#include <geometry/MakeGeom3Ellipse.hpp>
TEST_CASE("bug2: ComputePointsAbscissa ", "[geometry][ComputePointsAbscissa][fixbug]")
{
	SECTION("arc length and tolerance-3D")
{
    Frame3 frame;
    double major = 5.0;
    double minor = 4.0;
    bool isRight = true;
    std::shared_ptr< Geom3Hyperbola >h1 = MakeGeom3Hyperbola(frame, major, minor);
    AdaptorGeom3Curve hyperbola(h1);
    ComputePointsAbscissa cpa3(Precision::Confusion(), hyperbola, 1.0, 0.0);
    double param3 = cpa3.Parameter();
    Point3 point1(hyperbola.Value(param3));
    CHECK(cpa3.Parameter());
    MakeEdge edge1(h1, 0.0, param3);
    CHECK(BRepClassificationTools::IsPointInOnEdge(edge1, point1, 0.001) == true);
}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API ComputePointsAbscissa(double tol, const Adaptor2Curve& c, double abscissa, double u0)	 @param u0 The starting parameter
	 @param abscissa The arc length
	 @param c The curve
	 @param tol The tolerance
	 @brief Compute the parameter of a point on a 2D curve with given arc length and a tolerance
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <geometry/MakeGeom2Circle.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/ComputePointsAbscissa.hpp>
#include <geometry/MakeGeom2Hyperbola.hpp>
#include <modeling/MakeEdge.hpp>
#include <geometry/GeometryTool.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/MakeGeom2Ellipse.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/AdaptorGeom3Curve.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <geometry/MakeGeom3Hyperbola.hpp>
#include <geometry/MakeGeom3Ellipse.hpp>
TEST_CASE("bug2: ComputePointsAbscissa ", "[geometry][ComputePointsAbscissa][fixbug]")
{
	SECTION("arc length and tolerance-2D")
{
    Axis2 axis;
    double major = 5.0;
    double minor = 4.0;
    bool isRight = true;
    std::shared_ptr< Geom2Hyperbola >h1 = MakeGeom2Hyperbola(axis, major, minor, isRight);
    AdaptorGeom2Curve hyperbola(h1);
    ComputePointsAbscissa cpa3(Precision::Confusion(), hyperbola, 1.0, 0.0);
    double param3 = cpa3.Parameter();
    CHECK(cpa3.Parameter());
    Point2 s4 = hyperbola.Value(param3);
    shared_ptr<Geom3Curve> curve;
    curve = GeometryTool::To3d(Frame3(), h1);
    MakeEdge edge2(curve, 0.0, param3);
    Point3 point1(s4.X(), s4.Y(), 0.0);
    CHECK(BRepClassificationTools::IsPointInOnEdge(edge2, point1, 0.001) == true);
}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API ComputePointsAbscissa(const Adaptor3Curve& c, double abscissa, double u0)	 @param u0 The starting parameter
	 @param abscissa The arc length
	 @param c The curve
	 @brief Compute the parameter of a point on a 3D curve with given arc length
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <geometry/MakeGeom2Circle.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/ComputePointsAbscissa.hpp>
#include <geometry/MakeGeom2Hyperbola.hpp>
#include <modeling/MakeEdge.hpp>
#include <geometry/GeometryTool.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/MakeGeom2Ellipse.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/AdaptorGeom3Curve.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <geometry/MakeGeom3Hyperbola.hpp>
#include <geometry/MakeGeom3Ellipse.hpp>
TEST_CASE("bug1: ComputePointsAbscissa ", "[geometry][ComputePointsAbscissa][fixbug]")
{
    double r = 0.0;
    std::shared_ptr<Geom2Curve> c = MakeGeom2Circle(Point2(0.0, 0.0), 0.0).Value();
    AdaptorGeom2Curve circle(c);
    ComputePointsAbscissa cpa(circle, 0.0, 0.0);
    double angle1 = 0;
    double x = r * cos(angle1);
    double y = r * sin(angle1);
    double param = cpa.Parameter();
    Point2 s = circle.Value(param);
    Point2 s1(x, y);
    CHECK(angle1 == cpa.Parameter());
    CHECK(s.X() == s1.X());
    CHECK(s.Y() == s1.Y());
    CHECK(ComputePointsAbscissa::Length(circle) == 0.0);
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API ComputePointsAbscissa(const Adaptor2Curve& c, double abscissa, double u0)	 @param u0 The starting parameter
	 @param abscissa The arc length
	 @param c The curve
	 @brief Compute the parameter of a point on a 2D curve with given arc length
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <geometry/MakeGeom2Circle.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/ComputePointsAbscissa.hpp>
#include <geometry/MakeGeom2Hyperbola.hpp>
#include <modeling/MakeEdge.hpp>
#include <geometry/GeometryTool.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/MakeGeom2Ellipse.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/AdaptorGeom3Curve.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <geometry/MakeGeom3Hyperbola.hpp>
#include <geometry/MakeGeom3Ellipse.hpp>
TEST_CASE("bug1: ComputePointsAbscissa ", "[geometry][ComputePointsAbscissa][fixbug]")
{
    double r = 0.0;
    std::shared_ptr<Geom2Curve> c = MakeGeom2Circle(Point2(0.0, 0.0), 0.0).Value();
    AdaptorGeom2Curve circle(c);
    ComputePointsAbscissa cpa(circle, 0.0, 0.0);
    double angle1 = 0;
    double x = r * cos(angle1);
    double y = r * sin(angle1);
    double param = cpa.Parameter();
    Point2 s = circle.Value(param);
    Point2 s1(x, y);
    CHECK(angle1 == cpa.Parameter());
    CHECK(s.X() == s1.X());
    CHECK(s.Y() == s1.Y());
    CHECK(ComputePointsAbscissa::Length(circle) == 0.0);
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API ComputePointsAbscissa(const Adaptor3Curve& c, double abscissa, double u0, double ui)	 @param ui The initial guess of the parameter
	 @param u0 The starting parameter
	 @param abscissa The arc length
	 @param c The curve
	 @brief Compute the parameter of a point on a 3D curve with given arc length and an initial guess
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <geometry/MakeGeom2Circle.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/ComputePointsAbscissa.hpp>
#include <geometry/MakeGeom2Hyperbola.hpp>
#include <modeling/MakeEdge.hpp>
#include <geometry/GeometryTool.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/MakeGeom2Ellipse.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/AdaptorGeom3Curve.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <geometry/MakeGeom3Hyperbola.hpp>
#include <geometry/MakeGeom3Ellipse.hpp>
TEST_CASE("bug1: ComputePointsAbscissa ", "[geometry][ComputePointsAbscissa][fixbug]")
{
    double r = 0.0;
    std::shared_ptr<Geom2Curve> c = MakeGeom2Circle(Point2(0.0, 0.0), 0.0).Value();
    AdaptorGeom2Curve circle(c);
    ComputePointsAbscissa cpa(circle, 0.0, 0.0);
    double angle1 = 0;
    double x = r * cos(angle1);
    double y = r * sin(angle1);
    double param = cpa.Parameter();
    Point2 s = circle.Value(param);
    Point2 s1(x, y);
    CHECK(angle1 == cpa.Parameter());
    CHECK(s.X() == s1.X());
    CHECK(s.Y() == s1.Y());
    CHECK(ComputePointsAbscissa::Length(circle) == 0.0);
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API ComputePointsAbscissa(const Adaptor2Curve& c, double abscissa, double u0, double ui)	 @param ui The initial guess of the parameter
	 @param u0 The starting parameter
	 @param abscissa The arc length
	 @param c The curve
	 @brief Compute the parameter of a point on a 2D curve with given arc length and an initial guess
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <geometry/MakeGeom2Circle.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/ComputePointsAbscissa.hpp>
#include <geometry/MakeGeom2Hyperbola.hpp>
#include <modeling/MakeEdge.hpp>
#include <geometry/GeometryTool.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/MakeGeom2Ellipse.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/AdaptorGeom3Curve.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <geometry/MakeGeom3Hyperbola.hpp>
#include <geometry/MakeGeom3Ellipse.hpp>
TEST_CASE("bug1: ComputePointsAbscissa ", "[geometry][ComputePointsAbscissa][fixbug]")
{
    double r = 0.0;
    std::shared_ptr<Geom2Curve> c = MakeGeom2Circle(Point2(0.0, 0.0), 0.0).Value();
    AdaptorGeom2Curve circle(c);
    ComputePointsAbscissa cpa(circle, 0.0, 0.0);
    double angle1 = 0;
    double x = r * cos(angle1);
    double y = r * sin(angle1);
    double param = cpa.Parameter();
    Point2 s = circle.Value(param);
    Point2 s1(x, y);
    CHECK(angle1 == cpa.Parameter());
    CHECK(s.X() == s1.X());
    CHECK(s.Y() == s1.Y());
    CHECK(ComputePointsAbscissa::Length(circle) == 0.0);
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API ComputePointsAbscissa(const Adaptor3Curve& c, double abscissa, double u0, double ui, double tol)	 @param tol The tolerance
	 @param ui The initial guess of the parameter
	 @param u0 The starting parameter
	 @param abscissa The arc length
	 @param c The curve
	 @brief Compute the parameter of a point on a 3D curve with given arc length, an initial guess, and a tolerance
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <geometry/MakeGeom2Circle.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/ComputePointsAbscissa.hpp>
#include <geometry/MakeGeom2Hyperbola.hpp>
#include <modeling/MakeEdge.hpp>
#include <geometry/GeometryTool.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/MakeGeom2Ellipse.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/AdaptorGeom3Curve.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <geometry/MakeGeom3Hyperbola.hpp>
#include <geometry/MakeGeom3Ellipse.hpp>
TEST_CASE("bug2: ComputePointsAbscissa ", "[geometry][ComputePointsAbscissa][fixbug]")
{
	SECTION("arc length-3D")
{
    Frame3 frame;
    double major = 5.0;
    double minor = 4.0;
    bool isRight = true;
    std::shared_ptr< Geom3Hyperbola >h1 = MakeGeom3Hyperbola(frame, major, minor);
    AdaptorGeom3Curve hyperbola(h1);
    ComputePointsAbscissa cpa3(hyperbola, 1.0, 0.0);
    double param3 = cpa3.Parameter();
    Point3 point1 = hyperbola.Value(param3);
    CHECK(cpa3.Parameter());
    MakeEdge edge1(h1, 0.0, param3);
    CHECK(BRepClassificationTools::IsPointInOnEdge(edge1, point1, 0.001) == true);
}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API ComputePointsAbscissa(const Adaptor2Curve& c, double abscissa, double u0, double ui, double tol)	 @param tol The tolerance
	 @param ui The initial guess of the parameter
	 @param u0 The starting parameter
	 @param abscissa The arc length
	 @param c The curve
	 @brief Compute the parameter of a point on a 2D curve with given arc length, an initial guess, and a tolerance
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <geometry/MakeGeom2Circle.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/ComputePointsAbscissa.hpp>
#include <geometry/MakeGeom2Hyperbola.hpp>
#include <modeling/MakeEdge.hpp>
#include <geometry/GeometryTool.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/MakeGeom2Ellipse.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/AdaptorGeom3Curve.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <geometry/MakeGeom3Hyperbola.hpp>
#include <geometry/MakeGeom3Ellipse.hpp>
TEST_CASE("bug1: ComputePointsAbscissa ", "[geometry][ComputePointsAbscissa][fixbug]")
{
    double r = 0.0;
    std::shared_ptr<Geom2Curve> c = MakeGeom2Circle(Point2(0.0, 0.0), 0.0).Value();
    AdaptorGeom2Curve circle(c);
    ComputePointsAbscissa cpa(circle, 0.0, 0.0);
    double angle1 = 0;
    double x = r * cos(angle1);
    double y = r * sin(angle1);
    double param = cpa.Parameter();
    Point2 s = circle.Value(param);
    Point2 s1(x, y);
    CHECK(angle1 == cpa.Parameter());
    CHECK(s.X() == s1.X());
    CHECK(s.Y() == s1.Y());
    CHECK(ComputePointsAbscissa::Length(circle) == 0.0);
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API double Parameter()	 @return The parameter of the point
	 @brief Get the parameter of the point
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <geometry/MakeGeom2Circle.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/ComputePointsAbscissa.hpp>
#include <geometry/MakeGeom2Hyperbola.hpp>
#include <modeling/MakeEdge.hpp>
#include <geometry/GeometryTool.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/MakeGeom2Ellipse.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/AdaptorGeom3Curve.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <geometry/MakeGeom3Hyperbola.hpp>
#include <geometry/MakeGeom3Ellipse.hpp>
TEST_CASE("bug1: ComputePointsAbscissa ", "[geometry][ComputePointsAbscissa][fixbug]")
{
    double r = 0.0;
    std::shared_ptr<Geom2Curve> c = MakeGeom2Circle(Point2(0.0, 0.0), 0.0).Value();
    AdaptorGeom2Curve circle(c);
    ComputePointsAbscissa cpa(circle, 0.0, 0.0);
    double angle1 = 0;
    double x = r * cos(angle1);
    double y = r * sin(angle1);
    double param = cpa.Parameter();
    Point2 s = circle.Value(param);
    Point2 s1(x, y);
    CHECK(angle1 == cpa.Parameter());
    CHECK(s.X() == s1.X());
    CHECK(s.Y() == s1.Y());
    CHECK(ComputePointsAbscissa::Length(circle) == 0.0);
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":Geom2Ellipse()	 @brief Default constructor
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <math/EllipseT.hpp>
#include <geometry/Geom2Ellipse.hpp>
using namespace AMCAX;
using namespace std;
TEST_CASE("case1:this is a case for Test Geom2Ellipse", "[math][Geom2Ellipse][P1]")
{
	Axis2 axis;
	double major = 5.0;
	double minor = 4.0;
	bool isRight = true;
	Ellipse2 ellipse(axis, major, minor, isRight);
	Geom2Ellipse g2e(ellipse);
	SECTION("FocalParameter")
	{
		double FP = g2e.FocalParameter();
		double focal = 2 * sqrt(major * major - minor * minor);
		double fp = 2 * minor * minor / focal;;
		CHECK(FP == fp);
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API explicit Geom2Ellipse(const Ellipse2& e)	 @param e The ellipse
	 @brief Construct from an ellipse
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <math/EllipseT.hpp>
#include <geometry/Geom2Ellipse.hpp>
using namespace AMCAX;
using namespace std;
TEST_CASE("case1:this is a case for Test Geom2Ellipse", "[math][Geom2Ellipse][P1]")
{
	Axis2 axis;
	double major = 5.0;
	double minor = 4.0;
	bool isRight = true;
	Ellipse2 ellipse(axis, major, minor, isRight);
	Geom2Ellipse g2e(ellipse);
	SECTION("FocalParameter")
	{
		double FP = g2e.FocalParameter();
		double focal = 2 * sqrt(major * major - minor * minor);
		double fp = 2 * minor * minor / focal;;
		CHECK(FP == fp);
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API Geom2Ellipse(const Axis2& majorAxis, double major, double minor, bool isRight)	 @param isRight Is the local frame right-handed
	 @param minor The minor radius
	 @param major The major radius
	 @param majorAxis The axis
	 @brief Construct from an axis, a major radius and a minor radius
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <math/EllipseT.hpp>
#include <geometry/Geom2Ellipse.hpp>
using namespace AMCAX;
using namespace std;
TEST_CASE("case1:this is a case for Test Geom2Ellipse", "[math][Geom2Ellipse][P1]")
{
	Axis2 axis;
	double major = 5.0;
	double minor = 4.0;
	bool isRight = true;
	Ellipse2 ellipse(axis, major, minor, isRight);
	Geom2Ellipse g2e(ellipse);
	SECTION("FocalParameter")
	{
		double FP = g2e.FocalParameter();
		double focal = 2 * sqrt(major * major - minor * minor);
		double fp = 2 * minor * minor / focal;;
		CHECK(FP == fp);
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API Geom2Ellipse(const Frame2& frame, double major, double minor)	 @param minor The minor radius
	 @param major The major radius
	 @param frame The local frame
	 @brief Construct from a local frame, a major radius and a minor radius
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <math/EllipseT.hpp>
#include <geometry/Geom2Ellipse.hpp>
using namespace AMCAX;
using namespace std;
TEST_CASE("case1:this is a case for Test Geom2Ellipse", "[math][Geom2Ellipse][P1]")
{
	Axis2 axis;
	double major = 5.0;
	double minor = 4.0;
	bool isRight = true;
	Ellipse2 ellipse(axis, major, minor, isRight);
	Geom2Ellipse g2e(ellipse);
	SECTION("FocalParameter")
	{
		double FP = g2e.FocalParameter();
		double focal = 2 * sqrt(major * major - minor * minor);
		double fp = 2 * minor * minor / focal;;
		CHECK(FP == fp);
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] AMCAX_API double FocalParameter()	 @return The focal parameter
	          Focal parameter = 2 * focalLength.
	 @details The focal parameter of parabola is the distance from the focus to the directrix.
	 @brief Get the focal parameter of the parabola
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <geometry/Geom3Parabola.hpp>
using namespace AMCAX;
using namespace std;
TEST_CASE("case1:this is a case for Test Geom3Parabola", "[math][Geom3Parabola][P1]")
{
	Frame3 frame;
	double focal = 5.0;
	Geom3Parabola g3p(frame, focal);
	SECTION("FocalParameter")
	{
		double FP = g3p.FocalParameter();
		double fp = 2 * focal;
		CHECK(FP == fp);
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] AMCAX_API double SemilatusRectum()	 @return The semilatus rectum
	          Semilatus rectum = 2 * focalLength
	 @details The semilatus rectum of parabola is half of the length of the chord through a focus parallel to the directrix.
	 @brief Get the semilatus rectum of the parabola
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <geometry/Geom3Parabola.hpp>
using namespace AMCAX;
using namespace std;
TEST_CASE("case1:this is a case for Test Geom3Parabola", "[math][Geom3Parabola][P1]")
{
	Frame3 frame;
	double focal = 5.0;
	Geom3Parabola g3p(frame, focal);
	SECTION("SemilatusRectum")
	{
		double SR = g3p.SemilatusRectum();
		double sr = 2 * focal;
		CHECK(SR == sr);
	}
}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API explicit Geom3Parabola(const Parabola3& p)	 @param p The parabola
	 @brief Construct from a parabola
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <geometry/Geom3Parabola.hpp>
using namespace AMCAX;
using namespace std;
TEST_CASE("case1:this is a case for Test Geom3Parabola", "[math][Geom3Parabola][P1]")
{
	Frame3 frame;
	double focal = 5.0;
	Geom3Parabola g3p(frame, focal);
	SECTION("FocalParameter")
	{
		double FP = g3p.FocalParameter();
		double fp = 2 * focal;
		CHECK(FP == fp);
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API Geom3Parabola(const Frame3& frame, double focal)	 @param focal The focal length
	 @param frame The local frame
	 @brief Construct from a local frame and a focal length
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <geometry/Geom3Parabola.hpp>
using namespace AMCAX;
using namespace std;
TEST_CASE("case1:this is a case for Test Geom3Parabola", "[math][Geom3Parabola][P1]")
{
	Frame3 frame;
	double focal = 5.0;
	Geom3Parabola g3p(frame, focal);
	SECTION("FocalParameter")
	{
		double FP = g3p.FocalParameter();
		double fp = 2 * focal;
		CHECK(FP == fp);
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API Geom3Parabola(const Axis3& directrix, const Point3& focus)	 @param focus The focus
	 @param directrix The directrix
	 @brief Construct from a directrix and a focus
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <geometry/Geom3Parabola.hpp>
using namespace AMCAX;
using namespace std;
TEST_CASE("case1:this is a case for Test Geom3Parabola", "[math][Geom3Parabola][P1]")
{
	Frame3 frame;
	double focal = 5.0;
	Geom3Parabola g3p(frame, focal);
	SECTION("FocalParameter")
	{
		double FP = g3p.FocalParameter();
		double fp = 2 * focal;
		CHECK(FP == fp);
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API Geom2Hyperbola(const Axis2& axis, double major, double minor, bool isRight = true)	 @param isRight Is the local frame right-handed
	 @param minor The minor radius
	 @param major The major radius
	 @param axis The axis
	 @brief Construct from an axis, a major radius and a minor radius
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <math/EllipseT.hpp>
#include <geometry/Geom2Hyperbola.hpp>
using namespace AMCAX;
using namespace std;
TEST_CASE("case1:this is a case for Test Geom2Hyperbola", "[math][Geom2Hyperbola][P1]")
{
	Axis2 axis;
	double major = 5.0;
	double minor = 4.0;
	bool isRight = true;
	Geom2Hyperbola g2h(axis, major, minor, isRight);
	SECTION("FocalParameter")
	{
		double FP = g2h.FocalParameter();
		double focal = 2 * sqrt(major * major + minor * minor);
		double fp = 2 * minor * minor / focal;;
		CHECK(FP == fp);
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API Geom2Hyperbola(const Frame2& frame, double major, double minor)	 @param minor The minor radius
	 @param major The major radius
	 @param frame The local frame
	 @brief Construct from a local frame, a major radius and a minor radius
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <math/EllipseT.hpp>
#include <geometry/Geom2Hyperbola.hpp>
using namespace AMCAX;
using namespace std;
TEST_CASE("case1:this is a case for Test Geom2Hyperbola", "[math][Geom2Hyperbola][P1]")
{
	Axis2 axis;
	double major = 5.0;
	double minor = 4.0;
	bool isRight = true;
	Geom2Hyperbola g2h(axis, major, minor, isRight);
	SECTION("FocalParameter")
	{
		double FP = g2h.FocalParameter();
		double focal = 2 * sqrt(major * major + minor * minor);
		double fp = 2 * minor * minor / focal;;
		CHECK(FP == fp);
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":Geom2Parabola()	 @brief Default constructor
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <geometry/Geom2Parabola.hpp>
using namespace AMCAX;
using namespace std;
TEST_CASE("case1:this is a case for Test Geom2Parabola", "[math][Geom2Parabola][P1]")
{
	Axis2 axis;
	double focal = 5.0;
	bool isRight = true;
	Geom2Parabola g2p(axis, focal, isRight);
	SECTION("SemilatusRectum")
	{
		double SR = g2p.SemilatusRectum();
		double sr = 2 * focal;
		CHECK(SR == sr);
	}
}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API Geom2Parabola(const Axis2& axis, double focal, bool isRight = true)	 @param isRight Is the local frame right-handed
	 @param focal The focal length
	 @param axis The axis
	 @brief Construct from an axis and a focal length
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <geometry/Geom2Parabola.hpp>
using namespace AMCAX;
using namespace std;
TEST_CASE("case1:this is a case for Test Geom2Parabola", "[math][Geom2Parabola][P1]")
{
	Axis2 axis;
	double focal = 5.0;
	bool isRight = true;
	Geom2Parabola g2p(axis, focal, isRight);
	SECTION("FocalParameter")
	{
		double FP = g2p.FocalParameter();
		double fp = 2 * focal;
		CHECK(FP == fp);
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API Geom2Parabola(const Frame2& frame, double focal)	 @param focal The focal length
	 @param frame The local frame
	 @brief Construct from a local frame and a focal length
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <geometry/Geom2Parabola.hpp>
using namespace AMCAX;
using namespace std;
TEST_CASE("case1:this is a case for Test Geom2Parabola", "[math][Geom2Parabola][P1]")
{
	Axis2 axis;
	double focal = 5.0;
	bool isRight = true;
	Geom2Parabola g2p(axis, focal, isRight);
	SECTION("FocalParameter")
	{
		double FP = g2p.FocalParameter();
		double fp = 2 * focal;
		CHECK(FP == fp);
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API Geom2Parabola(const Axis2& directrix, const Point2& focus, bool isRight = true)	 @param isRight Is the local frame right-handed
	 @param focus The focus
	 @param directrix The directrix
	 @brief Construct from a directrix and a focus
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <geometry/Geom2Parabola.hpp>
using namespace AMCAX;
using namespace std;
TEST_CASE("case1:this is a case for Test Geom2Parabola", "[math][Geom2Parabola][P1]")
{
	Axis2 axis;
	double focal = 5.0;
	bool isRight = true;
	Geom2Parabola g2p(axis, focal, isRight);
	SECTION("FocalParameter")
	{
		double FP = g2p.FocalParameter();
		double fp = 2 * focal;
		CHECK(FP == fp);
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API Geom3BSplineCurve(const std::vector<Point3>& pts, const std::vector<double>& weights, const std::vector<double>& knots, const std::vector<int>& multiplicities, int degree, bool isPeriodic = false, bool checkRational = true)	 @param checkRational To check whether the weights are rational
	 @param isPeriodic Set the curve is periodic or not
	 @param degree The degree of curve
	 @param multiplicities The multiplicities
	 @param knots The knots
	 @param weights The weights
	 @param pts The points
	 @brief Construct a rational B spline curve from point, weights, knots and multiplicities with a given degree
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <geometry/Geom3BSplineCurve.hpp>
#include <geometry/Geom3BSplineSurface.hpp>
#include <topology/TopoFace.hpp>
#include <topology/TopoTool.hpp>
using namespace AMCAX;
TEST_CASE("bug1: Geom3BSplineCurve ", "[geometry][Geom3BSplineCurve][fixbug]") {
	std::stringstream output1,output2;
	std::vector<Point3> poles{ Point3(0.0, 0.0, 0.0), Point3(0.0, 1.0, 0.0), Point3(0.0, 2.0, 0.0), Point3(0.0, 3.0, 0.0), Point3(0.0, 4.0, 0.0) };
	std::vector<double> knots{ 0.0, 1.0, 2.0, 3.0 };
	std::vector<int> mults{ 2, 2, 2, 2 };
	auto bc = std::make_shared<Geom3BSplineCurve>(poles, knots, mults, 2);
	double last = bc->LastParameter();
	std::cout << bc->Value(last) << '\n';
	std::cout << bc->DN(last, 0) << '\n';
	output1 << bc->Value(last) << '\n';
	output2 << bc->DN(last, 0) << '\n';
	auto case1 = output1.str();
	auto case2 = output2.str();
	auto expectValue = "0 3 0";
	auto expectDN = "0 3 0";
	CHECK(case1.find(expectValue) != std::string::npos);
	CHECK(case2.find(expectDN) != std::string::npos);
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API Geom3BSplineSurface()	 @details A default surface is a unit square
	 @brief Default constructor
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <modeling/MakeFace.hpp>
#include <geometry/Geom3BSplineSurface.hpp>
#include <topology/TopoFace.hpp>
#include <topology/TopoTool.hpp>
using namespace AMCAX;
TEST_CASE("case1: Geom3BSplineSurface::Geom3BSplineSurface() ", "[geometry][Geom3BSplineSurface][p1]") {
	Array2<Point3> poles(5, 4);
	poles(0, 0).SetCoord(0.0, 0.0, 0.0);
	poles(0, 1).SetCoord(0.0, 1.1, 2.0);
	poles(0, 2).SetCoord(0.0, 2.3, 1.0);
	poles(0, 3).SetCoord(0.0, 3.1, 1.5);
	poles(1, 0).SetCoord(1.1, 0.1, 2.0);
	poles(1, 1).SetCoord(1.2, 1.0, 0.0);
	poles(1, 2).SetCoord(1.3, 2.1, -1.0);
	poles(1, 3).SetCoord(1.23, 3.04, 1.32);
	poles(2, 0).SetCoord(2.3, 0.1, -2.0);
	poles(2, 1).SetCoord(2.1, 1.4, 2.0);
	poles(2, 2).SetCoord(2.2, 2.1, 1.0);
	poles(2, 3).SetCoord(2.23, 3.22, 1.26);
	poles(3, 0).SetCoord(3.13, 0.2, 0.0);
	poles(3, 1).SetCoord(3.12, 1.1, 0.0);
	poles(3, 2).SetCoord(3.21, 2.1, 1.0);
	poles(3, 3).SetCoord(3.33, 3.21, -1.2);
	poles(4, 0).SetCoord(4.9, 4.93, 0.31);
	poles(4, 1).SetCoord(5.3, 4.73, 0.33);
	poles(4, 2).SetCoord(5.1, 4.43, -1.31);
	poles(4, 3).SetCoord(9.2, 4.65, 3.31);
	std::vector<double> uknots = { 0.0, 0.5, 1.0 };
	std::vector<int> umults = { 4, 1, 4 };
	std::vector<double> vknots = { 0.0, 0.5, 1.0 };
	std::vector<int> vmults = { 3, 1, 3 };
	std::shared_ptr<Geom3BSplineSurface> s = std::make_shared<Geom3BSplineSurface>(poles, uknots, vknots, umults, vmults, 3, 2);
	TopoFace face = MakeFace(s,0.001);
	bool bWriteresult = OCCTIO::OCCTTool::Write(face, OUTPUT_PATH_PREFIX"Geom3BSplineSurface_case1.brep");
	CHECK(bWriteresult == true);
	AMCAX::GlobalProperty prop;
	AMCAX::BRepGlobalProperty::SurfaceProperties(face, prop);
	CHECK(prop.Mass() == Approx( 21.3633));
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API Geom3BSplineSurface(const Array2<Point3>& pts, const std::vector<double>& uKnots, const std::vector<double>& vKnots, const std::vector<int>& uMults, const std::vector<int>& vMults, int uDegree, int vDegree, bool uPeriodic = false, bool vPeriodic = false)	 @param vPeriodic Set whether the surface is periodic along the v direction
	 @param uPeriodic Set whether the surface is periodic along the u direction
	 @param vDegree The v degree
	 @param uDegree The u degree
	 @param vMults The v multiplicities
	 @param uMults The u multiplicities
	 @param vKnots The v knots
	 @param uKnots The u knots
	 @param pts The poles
	 @brief Construct a B spline surface from poles, knots and multiplicities
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <modeling/MakeFace.hpp>
#include <geometry/Geom3BSplineSurface.hpp>
#include <topology/TopoFace.hpp>
#include <topology/TopoTool.hpp>
using namespace AMCAX;
TEST_CASE("case1: Geom3BSplineSurface::Geom3BSplineSurface() ", "[geometry][Geom3BSplineSurface][p1]") {
	Array2<Point3> poles(5, 4);
	poles(0, 0).SetCoord(0.0, 0.0, 0.0);
	poles(0, 1).SetCoord(0.0, 1.1, 2.0);
	poles(0, 2).SetCoord(0.0, 2.3, 1.0);
	poles(0, 3).SetCoord(0.0, 3.1, 1.5);
	poles(1, 0).SetCoord(1.1, 0.1, 2.0);
	poles(1, 1).SetCoord(1.2, 1.0, 0.0);
	poles(1, 2).SetCoord(1.3, 2.1, -1.0);
	poles(1, 3).SetCoord(1.23, 3.04, 1.32);
	poles(2, 0).SetCoord(2.3, 0.1, -2.0);
	poles(2, 1).SetCoord(2.1, 1.4, 2.0);
	poles(2, 2).SetCoord(2.2, 2.1, 1.0);
	poles(2, 3).SetCoord(2.23, 3.22, 1.26);
	poles(3, 0).SetCoord(3.13, 0.2, 0.0);
	poles(3, 1).SetCoord(3.12, 1.1, 0.0);
	poles(3, 2).SetCoord(3.21, 2.1, 1.0);
	poles(3, 3).SetCoord(3.33, 3.21, -1.2);
	poles(4, 0).SetCoord(4.9, 4.93, 0.31);
	poles(4, 1).SetCoord(5.3, 4.73, 0.33);
	poles(4, 2).SetCoord(5.1, 4.43, -1.31);
	poles(4, 3).SetCoord(9.2, 4.65, 3.31);
	std::vector<double> uknots = { 0.0, 0.5, 1.0 };
	std::vector<int> umults = { 4, 1, 4 };
	std::vector<double> vknots = { 0.0, 0.5, 1.0 };
	std::vector<int> vmults = { 3, 1, 3 };
	std::shared_ptr<Geom3BSplineSurface> s = std::make_shared<Geom3BSplineSurface>(poles, uknots, vknots, umults, vmults, 3, 2);
	TopoFace face = MakeFace(s,0.001);
	bool bWriteresult = OCCTIO::OCCTTool::Write(face, OUTPUT_PATH_PREFIX"Geom3BSplineSurface_case1.brep");
	CHECK(bWriteresult == true);
	AMCAX::GlobalProperty prop;
	AMCAX::BRepGlobalProperty::SurfaceProperties(face, prop);
	CHECK(prop.Mass() == Approx( 21.3633));
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API Geom3BSplineSurface(const Array2<Point3>& pts, const Array2<double>& weights, const std::vector<double>& uKnots, const std::vector<double>& vKnots, const std::vector<int>& uMults, const std::vector<int>& vMults, int uDegree, int vDegree, bool uPeriodic = false, bool vPeriodic = false)	 @param vPeriodic Set whether the surface is periodic along the v direction
	 @param uPeriodic Set whether the surface is periodic along the u direction
	 @param vDegree The v degree
	 @param uDegree The u degree
	 @param vMults The v multiplicities
	 @param uMults The u multiplicities
	 @param vKnots The v knots
	 @param uKnots The u knots
	 @param weights The weights
	 @param pts The poles
	 @brief Construct a rational B spline surface from poles, knots and multiplicities
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <modeling/MakeFace.hpp>
#include <geometry/Geom3BSplineSurface.hpp>
#include <topology/TopoFace.hpp>
#include <topology/TopoTool.hpp>
using namespace AMCAX;
TEST_CASE("case1: Geom3BSplineSurface::Geom3BSplineSurface() ", "[geometry][Geom3BSplineSurface][p1]") {
	Array2<Point3> poles(5, 4);
	poles(0, 0).SetCoord(0.0, 0.0, 0.0);
	poles(0, 1).SetCoord(0.0, 1.1, 2.0);
	poles(0, 2).SetCoord(0.0, 2.3, 1.0);
	poles(0, 3).SetCoord(0.0, 3.1, 1.5);
	poles(1, 0).SetCoord(1.1, 0.1, 2.0);
	poles(1, 1).SetCoord(1.2, 1.0, 0.0);
	poles(1, 2).SetCoord(1.3, 2.1, -1.0);
	poles(1, 3).SetCoord(1.23, 3.04, 1.32);
	poles(2, 0).SetCoord(2.3, 0.1, -2.0);
	poles(2, 1).SetCoord(2.1, 1.4, 2.0);
	poles(2, 2).SetCoord(2.2, 2.1, 1.0);
	poles(2, 3).SetCoord(2.23, 3.22, 1.26);
	poles(3, 0).SetCoord(3.13, 0.2, 0.0);
	poles(3, 1).SetCoord(3.12, 1.1, 0.0);
	poles(3, 2).SetCoord(3.21, 2.1, 1.0);
	poles(3, 3).SetCoord(3.33, 3.21, -1.2);
	poles(4, 0).SetCoord(4.9, 4.93, 0.31);
	poles(4, 1).SetCoord(5.3, 4.73, 0.33);
	poles(4, 2).SetCoord(5.1, 4.43, -1.31);
	poles(4, 3).SetCoord(9.2, 4.65, 3.31);
	std::vector<double> uknots = { 0.0, 0.5, 1.0 };
	std::vector<int> umults = { 4, 1, 4 };
	std::vector<double> vknots = { 0.0, 0.5, 1.0 };
	std::vector<int> vmults = { 3, 1, 3 };
	std::shared_ptr<Geom3BSplineSurface> s = std::make_shared<Geom3BSplineSurface>(poles, uknots, vknots, umults, vmults, 3, 2);
	TopoFace face = MakeFace(s,0.001);
	bool bWriteresult = OCCTIO::OCCTTool::Write(face, OUTPUT_PATH_PREFIX"Geom3BSplineSurface_case1.brep");
	CHECK(bWriteresult == true);
	AMCAX::GlobalProperty prop;
	AMCAX::BRepGlobalProperty::SurfaceProperties(face, prop);
	CHECK(prop.Mass() == Approx( 21.3633));
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API void InsertUKnot(double u, int m, double parametricTolerance, bool add = true)	 @param add If true, the multiplicity is an incremental value; if false, the multiplicity is a final value
	 @param parametricTolerance The tolerance of parameters
	 @param m The multiplicity of the knot to be inserted
	 @param u The knot to be inserted
	 @brief Insert a u knot
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <modeling/MakeFace.hpp>
#include <geometry/Geom3BSplineSurface.hpp>
#include <topology/TopoFace.hpp>
#include <topology/TopoTool.hpp>
using namespace AMCAX;
TEST_CASE("bug1: Geom3BSplineSurface::InsertUKnot() ", "[geometry][Geom3BSplineSurface][fixbug]") {
	TopoFace face;
	OCCTIO::OCCTTool::Read(face, INPUT_PATH_PREFIX"face.brep");
	auto surf = TopoTool::Surface(face);
	auto bsp = std::dynamic_pointer_cast<Geom3BSplineSurface>(surf);
	bsp->InsertUKnot(0.23, 1, 0.0, true);
	bool bWriteresult = OCCTIO::OCCTTool::Write(face, OUTPUT_PATH_PREFIX"result.brep");
	CHECK(bWriteresult == true);
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API Geom3ConicalSurface(const Frame3& frame, double r, double angle)	 @param angle The semi-angle
	 @param r The reference radius
	 @param frame The local frame
	 @brief Construct from a local frame, a reference radius and a semi-angle
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
#include <geometry/Geom3ConicalSurface.hpp>
using namespace AMCAX;
TEST_CASE("case1: Geom3ConicalSurface::CircleD1 1/4 ", "[math][Geom3ConicalSurface][P1][CircleD1]") {
	Direction3 initialDir(0.0, 0.0, 1.0); 
	Frame3 defaultFrame3(Point3(1.0, 1.0, 0.0), initialDir);
	AMCAX::Geom3ConicalSurface suface(defaultFrame3, 5.0, 1);
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] AMCAX_API Point3 Apex()	 @return The apex point
	 @brief Get the apex of the cone
,
 "output":#include<iostream>
#include "catch.hpp"
#include <common/FrameT.hpp>
#include <modeling/MakeFace.hpp>
#include <common/AxisT.hpp>
#include <common/FrameT.hpp>
#include <common/VectorT.hpp>
#include <math/Cone.hpp>
using namespace AMCAX;
using namespace std;
TEST_CASE("TestCone", "[math][Cone]")
{
	AMCAX::Frame3 frame;
	double radius = 5.0;
	double angle = M_PI / 4;
	AMCAX::Cone cone(frame, radius, angle);
	AMCAX::Point3 apex = cone.Apex();
	CHECK(apex.X() == 0.0);
	CHECK(apex.Y() == 0.0);
	CHECK(apex.Z() == Approx(-5.0));
	AMCAX::Axis3 axis = cone.Axis();
	std::cout << axis.Direction().X() << std::endl;
	std::cout << axis.Direction().Y() << std::endl;
	std::cout << axis.Direction().Z() << std::endl;
	CHECK(axis.Direction().X() == 0.0);
	CHECK(axis.Direction().Y() == 0.0);
	CHECK(axis.Direction().Z() == 1.0);
	double a1, a2, a3, b1, b2, b3, c1, c2, c3, d;
	cone.Coefficients(a1, a2, a3, b1, b2, b3, c1, c2, c3, d);
	std::cout << "a1: " << a1 << ", a2: " << a2 << ", a3: " << a3 << std::endl;
	std::cout << "b1: " << b1 << ", b2: " << b2 << ", b3: " << b3 << std::endl;
	std::cout << "c1: " << c1 << ", c2: " << c2 << ", c3: " << c3 << std::endl;
	std::cout << "d: " << d << std::endl;
	CHECK(a1 == 1.0);
	CHECK(a2 == 1.0);
	CHECK(a3 == Approx(-1.0));
	CHECK(b1 == 0);
	CHECK(b2 == 0);
	CHECK(b3 == 0);
	CHECK(c1 == 0);
	CHECK(c2 == 0);
	CHECK(c3 == Approx(-5.0));
	CHECK(d == -25.0);
	CHECK(cone.IsDirect() == true);
	CHECK(cone.Location().X() == 0.0);
	CHECK(cone.Location().Y() == 0.0);
	CHECK(cone.Location().Z() == 0.0);
	AMCAX::PointT<double, 3>mirrorPoint(5.0, 0.0, 0.0);
	cone.Mirror(mirrorPoint);
	auto mirroredLocation = cone.Location();
	CHECK(mirroredLocation.X() == 10.0);
	CHECK(mirroredLocation.Y() == 0.0);
	CHECK(mirroredLocation.Z() == 0.0);
	AMCAX::Frame3 coneFrame = cone.Position();
	CHECK(frame.Location().X() == 0.0);
	CHECK(frame.Location().Y() == 0.0);
	CHECK(frame.Location().Z() == 0.0);
	CHECK(cone.Radius() == 5.0);
	double  scaleCone = 2.0;
	cone.Scale(cone.Location(), scaleCone);
	CHECK(cone.Radius() == radius * 2.0);
	double semiCone = cone.SemiAngle();
	CHECK(semiCone == Approx(0.785398));
	const  Frame3& position = cone.Position();
	std::cout << position.XAxis() << std::endl;
	std::cout << position.YAxis() << std::endl;
	Direction3 zDirection(0.0, 0.0, 1.0);
	AMCAX::Point3  centerCone(0.0, 0.0, 0.0);
	Axis3 zAxis(centerCone, zDirection);
	cone.Rotated(zAxis, angle);
	AMCAX::Frame3 coneFrame2 = cone.Position();
	CHECK(coneFrame.Location().X() == 10.0);
	CHECK(coneFrame.Location().Y() == 0.0);
	CHECK(coneFrame.Location().Z() == 0.0);
	double scale = 2.0;
	cone.Scale(centerCone, scale);
	CHECK(cone.Radius() == radius * 4.0);
	double semiAngle = cone.SemiAngle();
	std::cout << semiAngle << std::endl;
	CHECK(semiAngle == Approx(0.785398));
	VectorT<double, 3> translationVector(5.0, 5.0, 0.0);
	cone.Translate(translationVector);
	CHECK(cone.Location().X() == 25.0);
	CHECK(cone.Location().Y() == 5.0);
	CHECK(cone.Location().Z() == 0.0);
	auto xAxis = cone.XAxis();
	auto yAxis = cone.YAxis();
	CHECK(xAxis.Direction().X() == Approx(-1.0));
	CHECK(yAxis.Direction().Y() == Approx(-1.0));
	AMCAX::Transformation3 tr;
	tr.SetTranslation(Vector3(1.0, 2.0, 3.0));
	cone.Transform(tr);
	Axis3 newXAxis = cone.Position().XAxis();
	CHECK(newXAxis.Location().X() == 26.0);
	CHECK(newXAxis.Location().Y() == 7.0);
	CHECK(newXAxis.Location().Z() == 3.0);
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] AMCAX_API double SemiAngle()	 @return The semi-angle
	 @brief Get the semi-angle
,
 "output":#include<iostream>
#include "catch.hpp"
#include <common/FrameT.hpp>
#include <modeling/MakeFace.hpp>
#include <common/AxisT.hpp>
#include <common/FrameT.hpp>
#include <common/VectorT.hpp>
#include <math/Cone.hpp>
using namespace AMCAX;
using namespace std;
TEST_CASE("TestCone", "[math][Cone]")
{
	AMCAX::Frame3 frame;
	double radius = 5.0;
	double angle = M_PI / 4;
	AMCAX::Cone cone(frame, radius, angle);
	AMCAX::Point3 apex = cone.Apex();
	CHECK(apex.X() == 0.0);
	CHECK(apex.Y() == 0.0);
	CHECK(apex.Z() == Approx(-5.0));
	AMCAX::Axis3 axis = cone.Axis();
	std::cout << axis.Direction().X() << std::endl;
	std::cout << axis.Direction().Y() << std::endl;
	std::cout << axis.Direction().Z() << std::endl;
	CHECK(axis.Direction().X() == 0.0);
	CHECK(axis.Direction().Y() == 0.0);
	CHECK(axis.Direction().Z() == 1.0);
	double a1, a2, a3, b1, b2, b3, c1, c2, c3, d;
	cone.Coefficients(a1, a2, a3, b1, b2, b3, c1, c2, c3, d);
	std::cout << "a1: " << a1 << ", a2: " << a2 << ", a3: " << a3 << std::endl;
	std::cout << "b1: " << b1 << ", b2: " << b2 << ", b3: " << b3 << std::endl;
	std::cout << "c1: " << c1 << ", c2: " << c2 << ", c3: " << c3 << std::endl;
	std::cout << "d: " << d << std::endl;
	CHECK(a1 == 1.0);
	CHECK(a2 == 1.0);
	CHECK(a3 == Approx(-1.0));
	CHECK(b1 == 0);
	CHECK(b2 == 0);
	CHECK(b3 == 0);
	CHECK(c1 == 0);
	CHECK(c2 == 0);
	CHECK(c3 == Approx(-5.0));
	CHECK(d == -25.0);
	CHECK(cone.IsDirect() == true);
	CHECK(cone.Location().X() == 0.0);
	CHECK(cone.Location().Y() == 0.0);
	CHECK(cone.Location().Z() == 0.0);
	AMCAX::PointT<double, 3>mirrorPoint(5.0, 0.0, 0.0);
	cone.Mirror(mirrorPoint);
	auto mirroredLocation = cone.Location();
	CHECK(mirroredLocation.X() == 10.0);
	CHECK(mirroredLocation.Y() == 0.0);
	CHECK(mirroredLocation.Z() == 0.0);
	AMCAX::Frame3 coneFrame = cone.Position();
	CHECK(frame.Location().X() == 0.0);
	CHECK(frame.Location().Y() == 0.0);
	CHECK(frame.Location().Z() == 0.0);
	CHECK(cone.Radius() == 5.0);
	double  scaleCone = 2.0;
	cone.Scale(cone.Location(), scaleCone);
	CHECK(cone.Radius() == radius * 2.0);
	double semiCone = cone.SemiAngle();
	CHECK(semiCone == Approx(0.785398));
	const  Frame3& position = cone.Position();
	std::cout << position.XAxis() << std::endl;
	std::cout << position.YAxis() << std::endl;
	Direction3 zDirection(0.0, 0.0, 1.0);
	AMCAX::Point3  centerCone(0.0, 0.0, 0.0);
	Axis3 zAxis(centerCone, zDirection);
	cone.Rotated(zAxis, angle);
	AMCAX::Frame3 coneFrame2 = cone.Position();
	CHECK(coneFrame.Location().X() == 10.0);
	CHECK(coneFrame.Location().Y() == 0.0);
	CHECK(coneFrame.Location().Z() == 0.0);
	double scale = 2.0;
	cone.Scale(centerCone, scale);
	CHECK(cone.Radius() == radius * 4.0);
	double semiAngle = cone.SemiAngle();
	std::cout << semiAngle << std::endl;
	CHECK(semiAngle == Approx(0.785398));
	VectorT<double, 3> translationVector(5.0, 5.0, 0.0);
	cone.Translate(translationVector);
	CHECK(cone.Location().X() == 25.0);
	CHECK(cone.Location().Y() == 5.0);
	CHECK(cone.Location().Z() == 0.0);
	auto xAxis = cone.XAxis();
	auto yAxis = cone.YAxis();
	CHECK(xAxis.Direction().X() == Approx(-1.0));
	CHECK(yAxis.Direction().Y() == Approx(-1.0));
	AMCAX::Transformation3 tr;
	tr.SetTranslation(Vector3(1.0, 2.0, 3.0));
	cone.Transform(tr);
	Axis3 newXAxis = cone.Position().XAxis();
	CHECK(newXAxis.Location().X() == 26.0);
	CHECK(newXAxis.Location().Y() == 7.0);
	CHECK(newXAxis.Location().Z() == 3.0);
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API Cone(const Frame3& frame, double r, double angle)	 @param angle The semi-angle
	 @param r The reference radius
	 @param frame The local frame
	 @brief Construct from a local frame, a reference radius and a semi-angle
,
 "output":#include<iostream>
#include "catch.hpp"
#include <common/FrameT.hpp>
#include <modeling/MakeFace.hpp>
#include <common/AxisT.hpp>
#include <common/FrameT.hpp>
#include <common/VectorT.hpp>
#include <math/Cone.hpp>
using namespace AMCAX;
using namespace std;
TEST_CASE("TestCone", "[math][Cone]")
{
	AMCAX::Frame3 frame;
	double radius = 5.0;
	double angle = M_PI / 4;
	AMCAX::Cone cone(frame, radius, angle);
	AMCAX::Point3 apex = cone.Apex();
	CHECK(apex.X() == 0.0);
	CHECK(apex.Y() == 0.0);
	CHECK(apex.Z() == Approx(-5.0));
	AMCAX::Axis3 axis = cone.Axis();
	std::cout << axis.Direction().X() << std::endl;
	std::cout << axis.Direction().Y() << std::endl;
	std::cout << axis.Direction().Z() << std::endl;
	CHECK(axis.Direction().X() == 0.0);
	CHECK(axis.Direction().Y() == 0.0);
	CHECK(axis.Direction().Z() == 1.0);
	double a1, a2, a3, b1, b2, b3, c1, c2, c3, d;
	cone.Coefficients(a1, a2, a3, b1, b2, b3, c1, c2, c3, d);
	std::cout << "a1: " << a1 << ", a2: " << a2 << ", a3: " << a3 << std::endl;
	std::cout << "b1: " << b1 << ", b2: " << b2 << ", b3: " << b3 << std::endl;
	std::cout << "c1: " << c1 << ", c2: " << c2 << ", c3: " << c3 << std::endl;
	std::cout << "d: " << d << std::endl;
	CHECK(a1 == 1.0);
	CHECK(a2 == 1.0);
	CHECK(a3 == Approx(-1.0));
	CHECK(b1 == 0);
	CHECK(b2 == 0);
	CHECK(b3 == 0);
	CHECK(c1 == 0);
	CHECK(c2 == 0);
	CHECK(c3 == Approx(-5.0));
	CHECK(d == -25.0);
	CHECK(cone.IsDirect() == true);
	CHECK(cone.Location().X() == 0.0);
	CHECK(cone.Location().Y() == 0.0);
	CHECK(cone.Location().Z() == 0.0);
	AMCAX::PointT<double, 3>mirrorPoint(5.0, 0.0, 0.0);
	cone.Mirror(mirrorPoint);
	auto mirroredLocation = cone.Location();
	CHECK(mirroredLocation.X() == 10.0);
	CHECK(mirroredLocation.Y() == 0.0);
	CHECK(mirroredLocation.Z() == 0.0);
	AMCAX::Frame3 coneFrame = cone.Position();
	CHECK(frame.Location().X() == 0.0);
	CHECK(frame.Location().Y() == 0.0);
	CHECK(frame.Location().Z() == 0.0);
	CHECK(cone.Radius() == 5.0);
	double  scaleCone = 2.0;
	cone.Scale(cone.Location(), scaleCone);
	CHECK(cone.Radius() == radius * 2.0);
	double semiCone = cone.SemiAngle();
	CHECK(semiCone == Approx(0.785398));
	const  Frame3& position = cone.Position();
	std::cout << position.XAxis() << std::endl;
	std::cout << position.YAxis() << std::endl;
	Direction3 zDirection(0.0, 0.0, 1.0);
	AMCAX::Point3  centerCone(0.0, 0.0, 0.0);
	Axis3 zAxis(centerCone, zDirection);
	cone.Rotated(zAxis, angle);
	AMCAX::Frame3 coneFrame2 = cone.Position();
	CHECK(coneFrame.Location().X() == 10.0);
	CHECK(coneFrame.Location().Y() == 0.0);
	CHECK(coneFrame.Location().Z() == 0.0);
	double scale = 2.0;
	cone.Scale(centerCone, scale);
	CHECK(cone.Radius() == radius * 4.0);
	double semiAngle = cone.SemiAngle();
	std::cout << semiAngle << std::endl;
	CHECK(semiAngle == Approx(0.785398));
	VectorT<double, 3> translationVector(5.0, 5.0, 0.0);
	cone.Translate(translationVector);
	CHECK(cone.Location().X() == 25.0);
	CHECK(cone.Location().Y() == 5.0);
	CHECK(cone.Location().Z() == 0.0);
	auto xAxis = cone.XAxis();
	auto yAxis = cone.YAxis();
	CHECK(xAxis.Direction().X() == Approx(-1.0));
	CHECK(yAxis.Direction().Y() == Approx(-1.0));
	AMCAX::Transformation3 tr;
	tr.SetTranslation(Vector3(1.0, 2.0, 3.0));
	cone.Transform(tr);
	Axis3 newXAxis = cone.Position().XAxis();
	CHECK(newXAxis.Location().X() == 26.0);
	CHECK(newXAxis.Location().Y() == 7.0);
	CHECK(newXAxis.Location().Z() == 3.0);
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API Cone& Scale(const Point3& point, double scale)	 @return The reference to self
	 @param scale The scale value
	 @param point The scaling center point
	 @brief Scale the cone by a point
,
 "output":#include<iostream>
#include "catch.hpp"
#include <common/FrameT.hpp>
#include <modeling/MakeFace.hpp>
#include <common/AxisT.hpp>
#include <common/FrameT.hpp>
#include <common/VectorT.hpp>
#include <math/Cone.hpp>
using namespace AMCAX;
using namespace std;
TEST_CASE("TestCone", "[math][Cone]")
{
	AMCAX::Frame3 frame;
	double radius = 5.0;
	double angle = M_PI / 4;
	AMCAX::Cone cone(frame, radius, angle);
	AMCAX::Point3 apex = cone.Apex();
	CHECK(apex.X() == 0.0);
	CHECK(apex.Y() == 0.0);
	CHECK(apex.Z() == Approx(-5.0));
	AMCAX::Axis3 axis = cone.Axis();
	std::cout << axis.Direction().X() << std::endl;
	std::cout << axis.Direction().Y() << std::endl;
	std::cout << axis.Direction().Z() << std::endl;
	CHECK(axis.Direction().X() == 0.0);
	CHECK(axis.Direction().Y() == 0.0);
	CHECK(axis.Direction().Z() == 1.0);
	double a1, a2, a3, b1, b2, b3, c1, c2, c3, d;
	cone.Coefficients(a1, a2, a3, b1, b2, b3, c1, c2, c3, d);
	std::cout << "a1: " << a1 << ", a2: " << a2 << ", a3: " << a3 << std::endl;
	std::cout << "b1: " << b1 << ", b2: " << b2 << ", b3: " << b3 << std::endl;
	std::cout << "c1: " << c1 << ", c2: " << c2 << ", c3: " << c3 << std::endl;
	std::cout << "d: " << d << std::endl;
	CHECK(a1 == 1.0);
	CHECK(a2 == 1.0);
	CHECK(a3 == Approx(-1.0));
	CHECK(b1 == 0);
	CHECK(b2 == 0);
	CHECK(b3 == 0);
	CHECK(c1 == 0);
	CHECK(c2 == 0);
	CHECK(c3 == Approx(-5.0));
	CHECK(d == -25.0);
	CHECK(cone.IsDirect() == true);
	CHECK(cone.Location().X() == 0.0);
	CHECK(cone.Location().Y() == 0.0);
	CHECK(cone.Location().Z() == 0.0);
	AMCAX::PointT<double, 3>mirrorPoint(5.0, 0.0, 0.0);
	cone.Mirror(mirrorPoint);
	auto mirroredLocation = cone.Location();
	CHECK(mirroredLocation.X() == 10.0);
	CHECK(mirroredLocation.Y() == 0.0);
	CHECK(mirroredLocation.Z() == 0.0);
	AMCAX::Frame3 coneFrame = cone.Position();
	CHECK(frame.Location().X() == 0.0);
	CHECK(frame.Location().Y() == 0.0);
	CHECK(frame.Location().Z() == 0.0);
	CHECK(cone.Radius() == 5.0);
	double  scaleCone = 2.0;
	cone.Scale(cone.Location(), scaleCone);
	CHECK(cone.Radius() == radius * 2.0);
	double semiCone = cone.SemiAngle();
	CHECK(semiCone == Approx(0.785398));
	const  Frame3& position = cone.Position();
	std::cout << position.XAxis() << std::endl;
	std::cout << position.YAxis() << std::endl;
	Direction3 zDirection(0.0, 0.0, 1.0);
	AMCAX::Point3  centerCone(0.0, 0.0, 0.0);
	Axis3 zAxis(centerCone, zDirection);
	cone.Rotated(zAxis, angle);
	AMCAX::Frame3 coneFrame2 = cone.Position();
	CHECK(coneFrame.Location().X() == 10.0);
	CHECK(coneFrame.Location().Y() == 0.0);
	CHECK(coneFrame.Location().Z() == 0.0);
	double scale = 2.0;
	cone.Scale(centerCone, scale);
	CHECK(cone.Radius() == radius * 4.0);
	double semiAngle = cone.SemiAngle();
	std::cout << semiAngle << std::endl;
	CHECK(semiAngle == Approx(0.785398));
	VectorT<double, 3> translationVector(5.0, 5.0, 0.0);
	cone.Translate(translationVector);
	CHECK(cone.Location().X() == 25.0);
	CHECK(cone.Location().Y() == 5.0);
	CHECK(cone.Location().Z() == 0.0);
	auto xAxis = cone.XAxis();
	auto yAxis = cone.YAxis();
	CHECK(xAxis.Direction().X() == Approx(-1.0));
	CHECK(yAxis.Direction().Y() == Approx(-1.0));
	AMCAX::Transformation3 tr;
	tr.SetTranslation(Vector3(1.0, 2.0, 3.0));
	cone.Transform(tr);
	Axis3 newXAxis = cone.Position().XAxis();
	CHECK(newXAxis.Location().X() == 26.0);
	CHECK(newXAxis.Location().Y() == 7.0);
	CHECK(newXAxis.Location().Z() == 3.0);
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":Geom3Ellipse()	 @brief Default constructor
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <common/FrameT.hpp>
#include <math/EllipseT.hpp>
#include <geometry/Geom3Ellipse.hpp>
using namespace AMCAX;
using namespace std;
TEST_CASE("case1:this is a case for Test Geom3Ellipse", "[math][Geom3Ellipse][P1]")
{
	Frame3 frame;
	double major = 5.0;
	double minor = 4.0;
	Ellipse3 ellipse(frame, major, minor);
	Geom3Ellipse g3e(ellipse);
	SECTION("FocalParameter")
	{
		double FP = g3e.FocalParameter();
		double focal = 2 * sqrt(major * major - minor * minor);
		double fp = 2 * minor * minor / focal;;
		CHECK(FP == fp);
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API explicit Geom3Ellipse(const Ellipse3& e)	 @param e The ellipse
	 @brief Construct from an ellipse
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <common/FrameT.hpp>
#include <math/EllipseT.hpp>
#include <geometry/Geom3Ellipse.hpp>
using namespace AMCAX;
using namespace std;
TEST_CASE("case1:this is a case for Test Geom3Ellipse", "[math][Geom3Ellipse][P1]")
{
	Frame3 frame;
	double major = 5.0;
	double minor = 4.0;
	Ellipse3 ellipse(frame, major, minor);
	Geom3Ellipse g3e(ellipse);
	SECTION("FocalParameter")
	{
		double FP = g3e.FocalParameter();
		double focal = 2 * sqrt(major * major - minor * minor);
		double fp = 2 * minor * minor / focal;;
		CHECK(FP == fp);
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API Geom3Ellipse(const Frame3& frame, double major, double minor)	 @param minor The minor radius
	 @param major The major radius
	 @param frame The local frame
	 @brief Construct from a local frame, a major radius and a minor radius
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <common/FrameT.hpp>
#include <math/EllipseT.hpp>
#include <geometry/Geom3Ellipse.hpp>
using namespace AMCAX;
using namespace std;
TEST_CASE("case1:this is a case for Test Geom3Ellipse", "[math][Geom3Ellipse][P1]")
{
	Frame3 frame;
	double major = 5.0;
	double minor = 4.0;
	Ellipse3 ellipse(frame, major, minor);
	Geom3Ellipse g3e(ellipse);
	SECTION("FocalParameter")
	{
		double FP = g3e.FocalParameter();
		double focal = 2 * sqrt(major * major - minor * minor);
		double fp = 2 * minor * minor / focal;;
		CHECK(FP == fp);
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API Geom3Ellipse(const Frame3& frame, double major, double minor)	 @param minor The minor radius
	 @param major The major radius
	 @param frame The local frame
	 @brief Construct from a local frame, a major radius and a minor radius
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <geometry/MakeGeom3Ellipse.hpp>
#include <common/DirectionT.hpp>
#include <common/PointT.hpp>
#include <common/Precision.hpp>
#include <topology/TopoEdge.hpp>
#include <topology/TopoWire.hpp>
#include <topology/TopoFace.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeWire.hpp>
#include <modeling/MakeFace.hpp>
#include <modeling/MakePrism.hpp>
#include <topomesh/BRepMeshIncrementalMesh.hpp>
#include <topology/TopoExplorerTool.hpp>
#include <topology/TopoExplorer.hpp>
#include <topology/TopoCast.hpp>
#include <topology/TopoTool.hpp>
#include <math/TriangularMesh.hpp>
using namespace AMCAX;
TEST_CASE("bug1: MakeGeom3Ellipse ", "[geometry][MakeGeom3Ellipse][fixbug]") {
	MakeGeom3Ellipse makeEllipse(Frame3(), 3.0, 1.0);
	std::shared_ptr<Geom3Curve> curve = makeEllipse.Value();
	TopoEdge e = MakeEdge(curve);
	TopoWire w = MakeWire(e);
	TopoFace f = MakeFace(w);
	TopoShape s = MakePrism(f, Vector3(0.0, 0.0, 1.0));
	BRepMeshIncrementalMesh mesher(s, 0.005, true);
	int counttest = 0;
	for (TopoExplorer ex(s, ShapeType::Face); ex.More(); ex.Next())
	{
		const auto& face = TopoCast::Face(ex.Current());
		TopoLocation l;
		auto tri = TopoTool::Triangulation(face, l);
		CHECK(tri); 
		if (tri)
		{
			counttest = counttest + 1;
			if (counttest == 1)
			{
				CHECK(tri->NVertices() == 84);
				CHECK(tri->NTriangles() == 82);
			}
			if (counttest == 2)
			{
				CHECK(tri->NVertices() == 41);
				CHECK(tri->NTriangles() == 39);
			}
			if (counttest == 3)
			{
				CHECK(tri->NVertices() == 41);
				CHECK(tri->NTriangles() == 39);
			}
		}
	}
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API explicit Geom3Hyperbola(const Hyperbola3& h)	 @param h The hyperbola
	 @brief Construct from an hyperbola
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <math/EllipseT.hpp>
#include <geometry/Geom3Hyperbola.hpp>
using namespace AMCAX;
using namespace std;
TEST_CASE("case1:this is a case for Test Geom3Hyperbola", "[math][Geom3Hyperbola][P1]")
{
	Frame3 frame;
	double major = 5.0;
	double minor = 4.0;
	Geom3Hyperbola g3h(frame, major, minor);
	SECTION("SemilatusRectum")
	{
		double SR = g3h.SemilatusRectum();
		double sr = minor * minor / major;
		CHECK(SR == sr);
	}
}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API Geom3Hyperbola(const Frame3& frame, double major, double minor)	 @param minor The minor radius
	 @param major The major radius
	 @param frame The local frame
	 @brief Construct from a local frame, a major radius and a minor radius
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <math/EllipseT.hpp>
#include <geometry/Geom3Hyperbola.hpp>
using namespace AMCAX;
using namespace std;
TEST_CASE("case1:this is a case for Test Geom3Hyperbola", "[math][Geom3Hyperbola][P1]")
{
	Frame3 frame;
	double major = 5.0;
	double minor = 4.0;
	Geom3Hyperbola g3h(frame, major, minor);
	SECTION("FocalParameter")
	{
		double FP = g3h.FocalParameter();
		double focal = 2 * sqrt(major * major + minor * minor);
		double fp = 2 * minor * minor / focal;;
		CHECK(FP == fp);
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API void Coefficients(double& a, double& b, double& c, double& d)	 @param[out] a,b,c,d The coefficients
	 @brief Get coefficients of algebraic representation: ax + by + cz + d = 0
,
 "output":#include "catch.hpp"
#include <testHelper.h>
#include <math/Plane.hpp>
using namespace AMCAX;
TEST_CASE("case1: Plane construction and methods", "[math][Plane][p1]") {
	SECTION("Default constructor") {
        Plane plane;
        double a, b, c, d;
        plane.Coefficients(a, b, c, d);
        REQUIRE(a == Approx(0));
        REQUIRE(b == Approx(0));
        REQUIRE(c == Approx(1));
        REQUIRE(d == Approx(0));
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":Plane()	 Default constructor
,
 "output":#include "catch.hpp"
#include <testHelper.h>
#include <math/Plane.hpp>
using namespace AMCAX;
TEST_CASE("case1: Plane construction and methods", "[math][Plane][p1]") {
	SECTION("Default constructor") {
        Plane plane;
        double a, b, c, d;
        plane.Coefficients(a, b, c, d);
        REQUIRE(a == Approx(0));
        REQUIRE(b == Approx(0));
        REQUIRE(c == Approx(1));
        REQUIRE(d == Approx(0));
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API explicit Plane(const Frame3& frame)	 @param frame The local frame
	 @brief Construct from a local frame, XOY plane
,
 "output":#include "catch.hpp"
#include <testHelper.h>
#include <math/Plane.hpp>
using namespace AMCAX;
TEST_CASE("case1: Plane construction and methods", "[math][Plane][p1]") {
	SECTION("Construct from frame") {
        Frame3 frame1(Point3(0.0, 0.0, 0.0), Direction3(0.0, 0.0, 1.0));
        Frame3 frame2(Point3(1.0, 0.0, 0.0), Direction3(2.0, 1.0, 1.0));
        Plane plane1(frame1);
        Plane plane2(frame2);  
        double a1, b1, c1, d1;
        plane1.Coefficients(a1, b1, c1, d1);
        double a2, b2, c2, d2;
        plane2.Coefficients(a2, b2, c2, d2);
        REQUIRE(a1 == Approx(0));
        REQUIRE(b1 == Approx(0));
        REQUIRE(c1 == Approx(1));
        REQUIRE(d1 == Approx(0));
        REQUIRE(a2 == Approx(2. / std::sqrt(6)));
        REQUIRE(b2 == Approx(1. / std::sqrt(6)));
        REQUIRE(c2 == Approx(1. / std::sqrt(6)));
        REQUIRE(d2 == Approx(-2. / std::sqrt(6)));
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API Plane(const Point3& point, const Direction3& dir)	 @param dir The direction
	 @param point The point
	 @brief Construct from a point and a direction
,
 "output":#include "catch.hpp"
#include <testHelper.h>
#include <math/Plane.hpp>
using namespace AMCAX;
TEST_CASE("case1: Plane construction and methods", "[math][Plane][p1]") {
	SECTION("Construct from point and direction") {
        Point3 point(1., 1., 1.);
        Direction3 dir(0., 0., 1.);
        Plane plane(point, dir);  
        Point3 point2(3., 4., 4.);
        Direction3 dir2(2., 2., 1.);
        Plane plane2(point2, dir2);  
        double a, b, c, d;
        plane.Coefficients(a, b, c, d);
        double a2, b2, c2, d2;
        plane2.Coefficients(a2, b2, c2, d2);
        REQUIRE(a == Approx(0));
        REQUIRE(b == Approx(0));
        REQUIRE(c == Approx(1));
        REQUIRE(d == Approx(-1));
        REQUIRE(a2 == Approx(2./3).margin(0.0001));
        REQUIRE(b2 == Approx(2./3).margin(0.0001));
        REQUIRE(c2 == Approx(1./3).margin(0.0001));
        REQUIRE(d2 == Approx(-6));
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API Plane(double a, double b, double c, double d)	 @param a,b,c,d The coefficients
	 @brief Construct from an algebraic representation: ax + by + cz + d = 0
,
 "output":#include "catch.hpp"
#include <testHelper.h>
#include <math/Plane.hpp>
using namespace AMCAX;
TEST_CASE("case1: Plane construction and methods", "[math][Plane][p1]") {
	SECTION("Construct from algebraic representation") {
        Plane plane(1., 1., 1., -3.);  
        double a, b, c, d;
        plane.Coefficients(a, b, c, d);  
        REQUIRE(a == Approx(1./std::sqrt(3)).margin(0.001));
        REQUIRE(b == Approx(1. / std::sqrt(3)).margin(0.001));
        REQUIRE(c == Approx(1. / std::sqrt(3)).margin(0.001));
        REQUIRE(d == Approx(-3. / std::sqrt(3)).margin(0.001));
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] AMCAX_API bool Contains(const Point3& point, double tol)	 @return True if the distance between the point and the plane is under the distance tolerance
	 @param tol The distance tolerance
	 @param point The point
	 @brief Determines whether the plane contains a point under a tolerance or not
,
 "output":#include "catch.hpp"
#include <testHelper.h>
#include <math/Plane.hpp>
using namespace AMCAX;
TEST_CASE("case1: Plane construction and methods", "[math][Plane][p1]") {
	SECTION("Contains methods") {
        std::function<bool(const Plane&, const Point3&)> pointInPlane = [](const Plane& plane, const Point3& point)->bool {
            Point3 planePoint = plane.Location();  
            Vector3 planeVector(planePoint, point);  
            double a, b, c, d;
            plane.Coefficients(a, b, c, d);
            return planeVector.Dot(Vector3(a, b, c)) == 0;
        };
        Plane plane(0., 0., 1., -1.); 
        Point3 point(1., 1., 1.);
        Point3 point2(1., 1., 2.);
        Line3 line(Point3(1., 1., 1.), Direction3(1., 0., 0.));
        Line3 line2(Point3(1., 1., 1.), Direction3(0., 0., 1.));  
        Line3 line3(Point3(1., 1., 0.), Direction3(1., 0., 0.));
        REQUIRE(plane.Contains(point, 1e-6) == pointInPlane(plane, point));
        REQUIRE(plane.Contains(point2, 1e-6) == pointInPlane(plane, point2));
        REQUIRE(plane.Contains(line, 1e-6, 1e-6));
        REQUIRE_FALSE(plane.Contains(line2, 1e-6, 1e-6 * (M_PI / 180)));
        REQUIRE_FALSE(plane.Contains(line3, 1e-6, 1e-6 * (M_PI / 180)));
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API explicit GeomAPIIntCurveCurve2(const std::shared_ptr<Geom2Curve>& c1, double tol = 1.0e-6)	 @param tol The tolerance for computing self-intersection
	 @param c1 The curve
	 @brief Construct from one curve for finding self-intersections
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <sstream>
#include <geometry/GeomAPIIntCurveCurve2.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <common/PointT.hpp>
using namespace AMCAX;
TEST_CASE("bug1: GeomAPIIntCurveCurve2  add 1 cases", "[geometry][GeomAPIIntCurveCurve2][fixbug]") {
	std::shared_ptr<Geom2BSplineCurve> bs1 = std::make_shared<Geom2BSplineCurve>();
	std::shared_ptr<Geom2BSplineCurve> bs2 = std::make_shared<Geom2BSplineCurve>();
	std::string str1 = "7 0 0 3 118 116 0.32094859236148043 1.01737460557672743 0.32206087674542322 1.01734745284654182 0.32382938579023346 1.01745552974970388 0.32622057752030481 1.01788932455950976 0.32814024437537276 1.01839643017089987 0.33002743385020250 1.01906060903165452 0.33185490242395432 1.01986927403602690 0.33356030574937923 1.02078382513330879 0.33505523022905437 1.02172426942215600 0.33630356053380972 1.02261635998227951 0.33727879099865676 1.02338700329485177 0.33824387261988464 1.02421002336103761 0.33987143181385676 1.02571995716873454 0.34214827935107528 1.02826048315421636 0.34461603767621785 1.03183954355064644 0.34665036808905569 1.03570920433382874 0.34820760193471290 1.03964073803085988 0.34933771881337422 1.04355887677937265 0.35009685624211401 1.04745091431990089 0.35052967495496640 1.05132419100513896 0.35066857936404372 1.05518894219017056 0.35052557522962369 1.05904245911643380 0.35008366013718967 1.06287636600114777 0.34929841370764381 1.06667869354746858 0.34813822094610908 1.07042299939338448 0.34675750395147792 1.07412664136932645 0.34534310541281921 1.07786690172476352 0.34358161112094421 1.08147777823012681 0.34192774635989071 1.08514486567176727 0.34024883979957521 1.08877932697709046 0.33856258005747963 1.09239630776272234 0.33684922584157972 1.09599070530577980 0.33511401239025801 1.09956576491048708 0.33335775759028152 1.10312101734871382 0.33158157690922768 1.10665621463276231 0.32978475270252700 1.11017051339371275 0.32796684236813672 1.11366345386663435 0.32612725706778090 1.11713471339148707 0.32426602655273468 1.12058421069008607 0.32238317488364737 1.12401188835076016 0.32047891905305792 1.12741748347385329 0.31855350786840358 1.13080068581386772 0.31660697714151498 1.13416123619352938 0.31463922025518198 1.13749923563291944 0.31264987984545162 1.14081514934997053 0.31063848196500760 1.14410959402646872 0.30860463164217128 1.14738321401338195 0.30654793927361806 1.15063653610177630 0.30446802732993405 1.15386990664646771 0.30236451953097970 1.15708359051903131 0.30023708628717172 1.16027763956461594 0.29808538476977109 1.16345202237806822 0.29590934129126883 1.16660648017917135 0.29370889405197392 1.16974079885919968 0.29148391413490155 1.17285470277829651 0.28923416621699150 1.17594813233618023 0.28695938621068906 1.17902112690429606 0.28465933895561080 1.18207371247860404 0.28233386645185193 1.18510589143436862 0.27998289479713001 1.18811761370470093 0.27760632123816548 1.19110879993250829 0.27520390350264767 1.19407947381928281 0.27277523052158237 1.19702979458848002 0.27031974327907626 1.19995999134850062 0.26783696716142708 1.20287004707951173 0.26532688195672521 1.20575953789980805 0.26278972678816304 1.20862781671414088 0.26022529469643624 1.21147474893699236 0.25763217763048496 1.21430150477218790 0.25500825126397131 1.21710994249041904 0.25235292985377017 1.21990005059103868 0.24966926670272568 1.22266796329330352 0.24696150391975732 1.22540882939352413 0.24423004526152650 1.22812190210150329 0.24146125706394184 1.23081996151861128 0.23861784080316129 1.23353765899792966 0.23566141121739081 1.23630795850379083 0.23313267974624646 1.23863075403103817 0.23108077081313610 1.24048682151979905 0.22951564660225790 1.24188808346222479 0.22785243018268259 1.24336238482365724 0.22603998536410663 1.24495322387069107 0.22406854105345719 1.24666425686480453 0.22194392374121000 1.24848570059305053 0.21966929759239204 1.25041206987825992 0.21725182330646176 1.25242961584586521 0.21469769930661789 1.25453321201678158 0.21201305169290471 1.25670455099802481 0.20919423964305814 1.25892740388225111 0.20624946264626334 1.26119206481064094 0.20318480037069683 1.26348679862854585 0.20000837020587425 1.26579929017010295 0.19672786860887337 1.26811801505294564 0.19336384906039994 1.27045063232052602 0.18992974310269095 1.27279484301208434 0.18643645229630731 1.27514361933883413 0.18288284026026952 1.27747988214753017 0.17926432420455884 1.27979154638979287 0.17557650128119320 1.28206361390544510 0.17182058886568480 1.28428512148975549 0.16804984196678602 1.28645557821983747 0.16432856924206579 1.28857394891545374 0.16070988708733733 1.29064090195652370 0.15717518220101778 1.29262871928824441 0.15369583278895632 1.29452720045016001 0.15026398879500619 1.29632707889676935 0.14689767435611573 1.29803910611286755 0.14368667318979397 1.29963940415365520 0.14066793270237543 1.30110806215344477 0.13786588940702740 1.30241800503027294 0.13522308508227587 1.30359724798135068 0.13268958893136670 1.30462396744174369 0.13022457745464813 1.30549794019590903 0.12782549497702861 1.30621459673763263 0.12551678736811231 1.30677267551026310 0.12264034969535306 1.30729452653584777 0.12051776185100731 1.30747541630908004 0.11912669923861925 1.30748468412943986 0.00000000000000000 4 0.00332678777314067 1 0.00530015559541836 1 0.00728182036673812 1 0.00927733380420748 1 0.01129573787307914 1 0.01327102124276026 1 0.01507750651120846 1 0.01659037664031113 1 0.01787187841143642 1 0.01880519345805253 1 0.02039488120903255 1 0.02452963651417061 1 0.02900897063209700 1 0.03340295596517878 1 0.03761684169382203 1 0.04167362563339645 1 0.04561938121714045 1 0.04949884613367380 1 0.05335394957604591 1 0.05721079085185987 1 0.06105670932975029 1 0.06491896046411526 1 0.06884011522460366 1 0.07280266881291077 1 0.07677853454115921 1 0.08082727159450992 1 0.08484703393156430 1 0.08884800850224144 1 0.09283736315162679 1 0.09681928451811667 1 0.10079344442245329 1 0.10475903456581770 1 0.10871533221895527 1 0.11266230101625047 1 0.11659995734938959 1 0.12052830686968952 1 0.12444792190998373 1 0.12835862681996368 1 0.13226049935437312 1 0.13615329767464079 1 0.14003667398886835 1 0.14391115976349200 1 0.14777767334262687 1 0.15163719748113480 1 0.15549084375107922 1 0.15933948557025243 1 0.16318380109489106 1 0.16702443368061037 1 0.17086206197732215 1 0.17469676853931951 1 0.17852903287965541 1 0.18235853795986209 1 0.18618547107174704 1 0.19001029311391093 1 0.19383342115543040 1 0.19765535049879729 1 0.20147647336026475 1 0.20529702393677510 1 0.20911722784810613 1 0.21293746918119616 1 0.21675849605951392 1 0.22058118324198547 1 0.22440637655431431 1 0.22823412013034025 1 0.23206350223258385 1 0.23589437276278422 1 0.23972883230279066 1 0.24357130772232163 1 0.24742464110863499 1 0.25128370603023881 1 0.25513705909052109 1 0.25898297113943686 1 0.26283319300761221 1 0.26673478756179048 1 0.27078270046115210 1 0.27498764230925066 1 0.27703550353465400 1 0.27908314380440813 1 0.28128986356810332 1 0.28370321223532124 1 0.28631785618959721 1 0.28912103899968400 1 0.29209869219406109 1 0.29526001444575162 1 0.29856723628509552 1 0.30202524340776099 1 0.30561830049238314 1 0.30933640124059564 1 0.31316962603536763 1 0.31710368845632919 1 0.32112310784334058 1 0.32522104893482329 1 0.32938444032265624 1 0.33359681084096160 1 0.33784938027078792 1 0.34214253792603233 1 0.34647801531348960 1 0.35084331838884097 1 0.35523312810758656 1 0.35953028089402317 1 0.36368926465670970 1 0.36773529430744634 1 0.37169603595072809 1 0.37557957415417503 1 0.37936041511409840 1 0.38302581855344769 1 0.38634253837102683 1 0.38943124796238249 1 0.39230486518080748 1 0.39502350628500010 1 0.39762992993310575 1 0.40014797436892702 1 0.40253156052235123 1 0.40475213727501114 1 0.40891189273334161 4";
	std::string str2 = "7 0 0 3 118 116 0.44698587761425512 1.01737460557672743 0.44586770461012754 1.01734792256404072 0.44408669680926910 1.01745649198371058 0.44167433575859827 1.01788973448550668 0.43973012306214176 1.01839676158274872 0.43781512528503469 1.01906078430998237 0.43595772107855257 1.01986941991017832 0.43422167753434071 1.02078367982801188 0.43270019179331992 1.02172276730688871 0.43143529102668837 1.02260881639260637 0.43047395316133663 1.02337915724656336 0.42956918011417972 1.02417518983407696 0.42818486699350283 1.02596609318184684 0.42535867595845256 1.02808829688484948 0.42284370487027889 1.03193726498772675 0.42029420450207700 1.03578860458891087 0.41779215915839102 1.03971518009696795 0.41524996629274769 1.04360952276868124 0.41268259846706867 1.04748256529635642 0.41009244215779894 1.05134004607881448 0.40748344575385259 1.05519270420095079 0.40486605902395167 1.05904184662506151 0.40221826431976609 1.06286057810161427 0.39954731386633807 1.06664354970287856 0.39685998643058945 1.07039722937908555 0.39415205518567858 1.07412233241535748 0.39142459506816268 1.07782095032413006 0.38867831705369166 1.08149595009323263 0.38591346143208760 1.08514964980580220 0.38313020259072789 1.08878346979564511 0.38032844124366111 1.09239780218286464 0.37750825751929029 1.09599269297900204 0.37466975732311525 1.09956803650327561 0.37181298113969291 1.10312349001628252 0.36893792871143949 1.10665859650325404 0.36604460396156768 1.11017278012274700 0.36313313466979064 1.11366550770546358 0.36020385654578302 1.11713665503127646 0.35725711512561398 1.12058603617284369 0.35429324377611354 1.12401373368655166 0.35131230158758986 1.12741939957610104 0.34831421468687968 1.13080262402140796 0.34529890614255510 1.13416313676223202 0.34226629246633017 1.13750078799254517 0.33921704684458587 1.14081632451049253 0.33615179652790328 1.14411040925898311 0.33307117902797256 1.14738370759211961 0.32997572188237095 1.15063676015840910 0.32686583766548316 1.15386986351118148 0.32374192911050353 1.15708326206532552 0.32060452465855971 1.16027718535470581 0.31745360371300196 1.16345153388182476 0.31428913900094868 1.16660594252951411 0.31111112410899561 1.16974020701489989 0.30791955045097874 1.17285394667146026 0.30471460628308072 1.17594719675858417 0.30149648916692096 1.17901999285247383 0.29826547554743049 1.18207244366664344 0.29502169193428479 1.18510458595828827 0.29176503889034477 1.18811625270052801 0.28849545711393992 1.19110735246150123 0.28521287446926513 1.19407776448826497 0.28191760121088905 1.19702778959143030 0.27860991172799571 1.19995767798350750 0.27529017147185769 1.20286775332443230 0.27195821134041676 1.20575742910935957 0.26861365400632170 1.20862591999664737 0.26525581006410243 1.21147208574228693 0.26188571532285843 1.21429744804454320 0.25850537979441068 1.21710464921168948 0.25511712957007160 1.21989678109210420 0.25171762413613974 1.22266823849310202 0.24830072265899519 1.22540963473078257 0.24486605329372579 1.22811942696225307 0.24141572018592131 1.23080424790172627 0.23796057988059283 1.23349025995382422 0.23455481289528443 1.23625809731511249 0.23178384866187560 1.23861884218329443 0.22958637070091326 1.24049429822100898 0.22792095077852323 1.24183892665189632 0.22633085712869647 1.24330474335321250 0.22482706539293790 1.24489950308425112 0.22341229813088337 1.24661390687506479 0.22209453169097026 1.24843902517094874 0.22087888937927413 1.25036828651214238 0.21977124333451431 1.25238938953827761 0.21877814583739183 1.25449449573067429 0.21790282053379528 1.25666553458695951 0.21714464814126716 1.25889056843647418 0.21650897231276728 1.26115706505645897 0.21599821380382661 1.26345359947659142 0.21561431786668875 1.26576891766763566 0.21535790133274418 1.26809712034575073 0.21523156999800702 1.27043621478677027 0.21523493789335055 1.27278382859372918 0.21536761702246404 1.27513094567987695 0.21562960091705158 1.27746540211106607 0.21601986302685286 1.27977480962963663 0.21653701136757098 1.28204820066314440 0.21718164535537912 1.28428355977126407 0.21795318927362628 1.28647141444648527 0.21885182671844836 1.28860254299760535 0.21987018385314080 1.29066214545958857 0.22100473503305496 1.29264388729952517 0.22225426990375063 1.29454179066819441 0.22361918358992602 1.29635228361390098 0.22510542017288909 1.29807648877092108 0.22668582626421535 1.29967791748795536 0.22833572049978873 1.30113992652563426 0.23002054288496601 1.30245118636949164 0.23175614453859494 1.30361712921158590 0.23353904515484103 1.30463669825309792 0.23536790944712538 1.30550821214031298 0.23723013129137352 1.30622515706156905 0.23909802022459714 1.30677963590280544 0.24158931746901185 1.30731428646199599 0.24348144169383945 1.30748511863814065 0.24475247407226391 1.30748468412943986 0.00000000000000000 4 0.00334434293035562 1 0.00533825930397336 1 0.00734412586267121 1 0.00936623440575543 1 0.01141256205459959 1 0.01341573096600146 1 0.01524709020284723 1 0.01677336277701813 1 0.01804490068923616 1 0.01894326352103789 1 0.02037993823386658 1 0.02480566898074880 1 0.02939205655814846 1 0.03404043378943207 1 0.03869805978018042 1 0.04334980332413108 1 0.04799487443159717 1 0.05263737365801836 1 0.05728913631958347 1 0.06195364423015201 1 0.06660152728460191 1 0.07122956329812886 1 0.07584610283920201 1 0.08045084571229059 1 0.08504550471877484 1 0.08963256787874113 1 0.09421407873103112 1 0.09879117107574811 1 0.10336422781387057 1 0.10793330889559200 1 0.11249839490034602 1 0.11705945929549585 1 0.12161613091223618 1 0.12616821278487000 1 0.13071541215010135 1 0.13525724181627602 1 0.13979405378099050 1 0.14432538686178745 1 0.14885137954117900 1 0.15337193703905613 1 0.15788673904588241 1 0.16239626042792893 1 0.16690070771036525 1 0.17140021344792761 1 0.17589510396468730 1 0.18038552504431565 1 0.18487151865902063 1 0.18935308684053462 1 0.19383026236900400 1 0.19830276789454376 1 0.20277103974370816 1 0.20723457084840083 1 0.21169339151646616 1 0.21614758290681596 1 0.22059709488399620 1 0.22504193032631326 1 0.22948214264998190 1 0.23391784916535033 1 0.23834913245589026 1 0.24277612072013041 1 0.24719890919114179 1 0.25161757662768108 1 0.25603221057958453 1 0.26044282613505232 1 0.26484890217770901 1 0.26925063819864326 1 0.27364813118187725 1 0.27804209715833189 1 0.28243253716855193 1 0.28681951085634216 1 0.29120020890283443 1 0.29557446914500052 1 0.29994411461100146 1 0.30431579875993647 1 0.30870332268475420 1 0.31310853612917888 1 0.31523624508228770 1 0.31737014111002310 1 0.31952856178681960 1 0.32171830465981011 1 0.32394102970905830 1 0.32619217521253946 1 0.32846706602101300 1 0.33077763413829298 1 0.33310205916533187 1 0.33544576479270716 1 0.33779655322040053 1 0.34015052354015518 1 0.34250407705161767 1 0.34485099381932000 1 0.34718783135835085 1 0.34952735554083242 1 0.35187486439618521 1 0.35422711580943594 1 0.35657637606518838 1 0.35891858548088795 1 0.36124990679045155 1 0.36356703547085450 1 0.36589411785453302 1 0.36820554269186456 1 0.37050138589761700 1 0.37278277874756854 1 0.37505181955993466 1 0.37731379776658153 1 0.37958010527703534 1 0.38187591368213569 1 0.38405827564667433 1 0.38618898795548318 1 0.38827607822097537 1 0.39032555279796965 1 0.39234499730597777 1 0.39434796008648582 1 0.39630575790533801 1 0.39818438284552959 1 0.40198436891082029 4";
	std::istringstream iss1(str1);
	std::istringstream iss2(str2);
	iss1 >> *bs1;
	iss2 >> *bs2;
	GeomAPIIntCurveCurve2 icc(bs1, bs2, 1e-12);
	CHECK(icc.NPoints() == 2);
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static bool IsPlanarCurve(const std::shared_ptr<Geom3Curve>& c, Plane& plane, double tol = 1.0e-7)	 @return True if the curve is a planar curve
	 @param tol The tolerance
	 @param plane The plane found when the curve is planar curve
	 @param c The input curve
	 @details If the input curve, such as a line, is on more than one plane, it will return the plane in which any one is located
	 @brief Check if a 3D curve is a planar curve, and if it is planar, find the plane
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <geometry/GeometryTool.hpp>
#include <geometry/Geom2BezierCurve.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/MakeArcOfCircle2d.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <modeling/MakeEdge.hpp>
#include<modeling/MakeEdge2d.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
#include <geometry/Geom3Circle.hpp>
using namespace AMCAX;
std::shared_ptr<Geom2BezierCurve> MakeBezierCurve2d()
{
	std::vector<Point2> poles(4);
	poles[0].SetCoord(1.0, 0.0);
	poles[1].SetCoord(2.0, 1.0);
	poles[2].SetCoord(3.0, -1.0);
	poles[3].SetCoord(4.0, 0.0);
	return std::make_shared<Geom2BezierCurve>(poles);
}
std::shared_ptr<Geom2BSplineCurve> MakeBSplineCurve2d()
{
	std::vector<Point2> poles(7);
	poles[0].SetCoord(0.5, 0.5);
	poles[1].SetCoord(1.0, 3.0);
	poles[2].SetCoord(3.0, 1.0);
	poles[3].SetCoord(3.8, 2.0);
	poles[4].SetCoord(2.5, 3.5);
	poles[5].SetCoord(1.0, 0.5);
	poles[6].SetCoord(0.3, 2.0);
	std::vector<double> knots = { 0.0, 0.25, 0.5, 0.75, 1.0 };
	std::vector<int> mults = { 4, 1, 1, 1, 4 };
	return std::make_shared<Geom2BSplineCurve>(poles, knots, mults, 3);
}
std::shared_ptr<Geom3BSplineCurve> MakeBSplineCurve3d(int degree, bool rational)
{
	if (degree == 3)
	{
		std::vector<Point3> poles(7);
		poles[0].SetCoord(0.5, 0.5, 0.3);
		poles[1].SetCoord(1.0, 3.0, 0.4);
		poles[2].SetCoord(3.0, 1.0, 0.1);
		poles[3].SetCoord(3.8, 2.0, 0.6);
		poles[4].SetCoord(2.5, 3.5, 0.8);
		poles[5].SetCoord(1.0, 0.5, 0.9);
		poles[6].SetCoord(0.3, 2.0, 0.5);
		std::vector<double> weights = { 1.0, 2.0, 3.0, 4.0, 3.0, 2.0, 1.0 };
		std::vector<double> knots = { 0.0, 0.25, 0.5, 1.0 };
		std::vector<int> mults = { 4, 1, 2, 4 };
		return rational ? std::make_shared<Geom3BSplineCurve>(poles, weights, knots, mults, 3)
			: std::make_shared<Geom3BSplineCurve>(poles, knots, mults, 3);
	}
	else if (degree == 2)
	{
		std::vector<Point3> poles(6);
		poles[0].SetCoord(0.5, 0.5, 0.3);
		poles[1].SetCoord(1.0, 3.0, 0.4);
		poles[2].SetCoord(3.0, 1.0, 0.1);
		poles[3].SetCoord(3.8, 2.0, 0.6);
		poles[4].SetCoord(2.5, 3.5, 0.8);
		poles[5].SetCoord(1.0, 0.5, 0.9);
		std::vector<double> weights = { 1.0, 2.0, 3.0, 4.0, 3.0, 2.0 };
		std::vector<double> knots = { 0.0, 0.25, 0.5, 1.0 };
		std::vector<int> mults = { 3, 1, 2, 3 };
		return rational ? std::make_shared<Geom3BSplineCurve>(poles, weights, knots, mults, 2)
			: std::make_shared<Geom3BSplineCurve>(poles, knots, mults, 2);
	}
	return nullptr;
}
TEST_CASE("case2: IsPlanarCurve dev case ", "[geometry][IsPlanarCurve][P1]")
{
	shared_ptr<Geom3BSplineCurve> curve3 = MakeBSplineCurve3d(3,true) ;
	Plane plane;
	CHECK(GeometryTool::IsPlanarCurve(curve3, plane) == false);
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API MakeArcOfCircle2d(const Point2& p1, const Vector2& v, const Point2& p2)	 @param p2 The end point
	 @param v The tangent vector at p1
	 @param p1 The start point
	 @brief Construct an arc of circle from two points p1, p2 and a tangent vector v at p1
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/VectorT.hpp>
#include <common/PointT.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/MakeArcOfCircle2d.hpp>
#include <sstream>
using namespace AMCAX;
TEST_CASE("bug1: MakeArcOfCircle2d  add 1 cases", "[geomAlgo][MakeArcOfCircle2d][fixbug]") {
	std::stringstream output;
	std::shared_ptr<Geom2TrimmedCurve> c = MakeArcOfCircle2d(Point2(0.0, 1.0), Vector2(1.0, 0.0), Point2(1.0, 0.0));
	std::cout << *c << std::endl;
	output << *c << std::endl;
	auto case1 = output.str();
	auto expect1 = "8 4.71239 6.28319";
	auto expect2 = "2 0 -0 1 0 0 -1 1";
	CHECK(case1.find(expect1) != std::string::npos);
	CHECK(case1.find(expect2) != std::string::npos);
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API MakeGeom3Ellipse(const Frame3& frame, double majorRadius, double minorRadius)	 @param minorRadius The minor radius
	 @param majorRadius The major radius
	 @param frame The local frame
	 @brief Construct an ellipse from a local frame, a major radius and a minor radius
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <geometry/MakeGeom3Ellipse.hpp>
#include <common/DirectionT.hpp>
#include <common/PointT.hpp>
#include <common/Precision.hpp>
#include <topology/TopoEdge.hpp>
#include <topology/TopoWire.hpp>
#include <topology/TopoFace.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeWire.hpp>
#include <modeling/MakeFace.hpp>
#include <modeling/MakePrism.hpp>
#include <topomesh/BRepMeshIncrementalMesh.hpp>
#include <topology/TopoExplorerTool.hpp>
#include <topology/TopoExplorer.hpp>
#include <topology/TopoCast.hpp>
#include <topology/TopoTool.hpp>
#include <math/TriangularMesh.hpp>
using namespace AMCAX;
TEST_CASE("bug1: MakeGeom3Ellipse ", "[geometry][MakeGeom3Ellipse][fixbug]") {
	MakeGeom3Ellipse makeEllipse(Frame3(), 3.0, 1.0);
	std::shared_ptr<Geom3Curve> curve = makeEllipse.Value();
	TopoEdge e = MakeEdge(curve);
	TopoWire w = MakeWire(e);
	TopoFace f = MakeFace(w);
	TopoShape s = MakePrism(f, Vector3(0.0, 0.0, 1.0));
	BRepMeshIncrementalMesh mesher(s, 0.005, true);
	int counttest = 0;
	for (TopoExplorer ex(s, ShapeType::Face); ex.More(); ex.Next())
	{
		const auto& face = TopoCast::Face(ex.Current());
		TopoLocation l;
		auto tri = TopoTool::Triangulation(face, l);
		CHECK(tri); 
		if (tri)
		{
			counttest = counttest + 1;
			if (counttest == 1)
			{
				CHECK(tri->NVertices() == 84);
				CHECK(tri->NTriangles() == 82);
			}
			if (counttest == 2)
			{
				CHECK(tri->NVertices() == 41);
				CHECK(tri->NTriangles() == 39);
			}
			if (counttest == 3)
			{
				CHECK(tri->NVertices() == 41);
				CHECK(tri->NTriangles() == 39);
			}
		}
	}
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API MakeGeom3Ellipse(const Point3& s1, const Point3& s2, const Point3& center)	 @param center The center point
	 @param s2 The point on the minor axis
	 @param s1 The point on the major axis
	 @brief Construct an ellipse from two points on the major and minor axis, and a center point
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <geometry/MakeGeom3Ellipse.hpp>
#include <common/DirectionT.hpp>
#include <common/PointT.hpp>
#include <common/Precision.hpp>
#include <topology/TopoEdge.hpp>
#include <topology/TopoWire.hpp>
#include <topology/TopoFace.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeWire.hpp>
#include <modeling/MakeFace.hpp>
#include <modeling/MakePrism.hpp>
#include <topomesh/BRepMeshIncrementalMesh.hpp>
#include <topology/TopoExplorerTool.hpp>
#include <topology/TopoExplorer.hpp>
#include <topology/TopoCast.hpp>
#include <topology/TopoTool.hpp>
#include <math/TriangularMesh.hpp>
using namespace AMCAX;
TEST_CASE("bug1: MakeGeom3Ellipse ", "[geometry][MakeGeom3Ellipse][fixbug]") {
	MakeGeom3Ellipse makeEllipse(Frame3(), 3.0, 1.0);
	std::shared_ptr<Geom3Curve> curve = makeEllipse.Value();
	TopoEdge e = MakeEdge(curve);
	TopoWire w = MakeWire(e);
	TopoFace f = MakeFace(w);
	TopoShape s = MakePrism(f, Vector3(0.0, 0.0, 1.0));
	BRepMeshIncrementalMesh mesher(s, 0.005, true);
	int counttest = 0;
	for (TopoExplorer ex(s, ShapeType::Face); ex.More(); ex.Next())
	{
		const auto& face = TopoCast::Face(ex.Current());
		TopoLocation l;
		auto tri = TopoTool::Triangulation(face, l);
		CHECK(tri); 
		if (tri)
		{
			counttest = counttest + 1;
			if (counttest == 1)
			{
				CHECK(tri->NVertices() == 84);
				CHECK(tri->NTriangles() == 82);
			}
			if (counttest == 2)
			{
				CHECK(tri->NVertices() == 41);
				CHECK(tri->NTriangles() == 39);
			}
			if (counttest == 3)
			{
				CHECK(tri->NVertices() == 41);
				CHECK(tri->NTriangles() == 39);
			}
		}
	}
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static bool IsSolidBounded(const TopoSolid& s)	 @return True if the solid and the solid is bounded (The infinite point is outside);
	 @param s The solid
	 @brief Classify whether the solid is bounded (The infinite point is outside)
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <io/ShapeTool.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <occtio/OCCTTool.hpp>
#include <topology/TopoShape.hpp>
#include <topology/TopoSolid.hpp>
#include <modeling/MakeSolid.hpp>
#include <modeling/MakeCylinder.hpp>
#include <boolean/BoolBRepFuse.hpp>
#include <boolean/BoolBRepCut.hpp>
#include <topomesh/BRepMeshIncrementalMesh.hpp>
#include <io/OBJTool.hpp>
#include <hatch/BRepSolidClassifier.hpp>
#include <healing/ShapeFixTool.hpp>
using namespace AMCAX;
bool ImpInSolid1(const Point3& pt)
{
	Point3 pc1(849.32865292949998, -105.60711735517, 528.53715478963011);
	Coord3 cs1 = pt.Coord() - pc1.Coord();
	bool isSolidIn1 = pt.Y() < 29.654882644830003 && pt.Y() > -105.60711735517 && (cs1.X() * cs1.X() + cs1.Z() * cs1.Z()) < 5.415 * 5.415;
	Point3 pc2(849.32865292763006, 12.992882644829002, 528.53715479109997);
	Coord3 cs2 = pt.Coord() - pc2.Coord();
	bool isSolidIn2 = pt.Z() < 543.83715479110003 && pt.Z() > 528.53715479109997 && (cs2.X() * cs2.X() + cs2.Y() * cs2.Y()) < 5.415 * 5.415;
	return isSolidIn1 || isSolidIn2;
}
Point3 SampleMethodCircle1()
{
	double u = (double)rand() / RAND_MAX * 4 - 0.5;
	double r = (double)rand() / RAND_MAX * 0.00002 + 5.41499;
	double x = 849.32865292949998 + r * std::cos(u);
	double z = 528.53715478963011 + r * std::sin(u);
	double y = (double)rand() / RAND_MAX * 136 - 106;
	return Point3(x, y, z);
}
TEST_CASE("bug: BRepClassificationTools::IsSolidBounded  related :", "[hatch][BRepClassificationTools][fixbug]") {
	AMCAX::TopoShape readshape;
	bool readstatus = AMCAX::OCCTIO::OCCTTool::Read(readshape, INPUT_PATH_PREFIX"0000-beforeFixShape.brep");
	CHECK(readstatus == true);
	readshape = AMCAX::ShapeFixTool::FixShape(readshape, AMCAX::Precision::Confusion(), 1E-1);
	AMCAX::TopoSolid readsolid = AMCAX::MakeSolid(AMCAX::TopoCast::Shell(readshape));
	CHECK(AMCAX::BRepClassificationTools::IsSolidBounded(readsolid) == true);
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API explicit BRepFaceClassifier(const TopoFace& f)	 @param f The input face
	 @brief Construct from the face to be processed
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <hatch/BRepFaceClassifier.hpp>
#include <common/FrameT.hpp>
#include <math/CircleT.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeWire.hpp>
#include <modeling/MakeFace.hpp>
#include <boolean/BoolBRepFuse.hpp>
#include <common/IndexSet.hpp>
#include <topology/TopoExplorerTool.hpp>
using namespace AMCAX;
TopoFace WrenchFace()
{
	Frame3 fm1(Point3(0., 0., 0.), Direction3(0., 0., 1.0));
	Circle3 c1 = Circle3(fm1, 2.);
	TopoEdge ec1 = MakeEdge(c1);
	TopoWire wc1 = MakeWire(ec1);
	TopoFace F1 = MakeFace(wc1);
	TopoEdge edge1 = MakeEdge(Point3(-4., -1.0, 0.0), Point3(4., -1.0, 0.0));
	TopoEdge edge2 = MakeEdge(Point3(4., -1.0, 0.0), Point3(4., 1.0, 0.0));
	TopoEdge edge3 = MakeEdge(Point3(4., 1.0, 0.0), Point3(-4., 1.0, 0.0));
	TopoEdge edge4 = MakeEdge(Point3(-4., 1.0, 0.0), Point3(-4., -1.0, 0.0));
	TopoWire wireR = MakeWire(edge1, edge2, edge3, edge4);
	TopoFace F3 = MakeFace(wireR);
	BoolBRepFuse fuse(F1, F3);
	fuse.Build();
	fuse.SimplifyResult();
	TopoShape res = fuse.Shape();
	IndexSet<TopoShape> resFaces;
	TopoExplorerTool::MapShapes(res, ShapeType::Face, resFaces);
	std::cout << resFaces.size() << std::endl;
	TopoFace face = static_cast<const TopoFace&>(resFaces[0]);
	return face;
}
bool ImpInWrenchFace(const Point2& pt)
{
	bool isFaceIn1 = pt.X() * pt.X() + pt.Y() * pt.Y() < 2 * 2;
	bool isFaceIn2 = pt.X() > -4 && pt.X() < 4 && pt.Y() > -1 && pt.Y() < 1;
	return isFaceIn1 || isFaceIn2;
}
Point2 SampleMethodFace()
{
	double x = (double)rand() / RAND_MAX * 10 - 5;
	double y = (double)rand() / RAND_MAX * 5 - 2.0;
	return Point2(x, y);
}
TEST_CASE("case1: BRepFaceClassifier 3.6.0 added API. ", "[hatch][BRepFaceClassifier][P1]") {
		TopoFace face = WrenchFace();
		BRepFaceClassifier classify(face);
		int n = 10000;
		int inSize = 0, intime = 0, ontime = 0;
		for (int i = 0; i < n; ++i)
		{
			Point2 pt = SampleMethodFace();
			bool isIn = ImpInWrenchFace(pt);
			classify.Perform(pt, Precision::Confusion());
			bool isCIn = classify.State() == StateType::In;
			bool isCon = classify.State() == StateType::On;
			if (isIn)
			{
				inSize++;
				if (isCIn)
				{
					intime++;
				}
				if (isCon)
				{
					ontime++;
				}
			}
		}
		std::cout << inSize << " " << intime << " " << ontime << std::endl;
		CHECK(inSize == (intime + ontime));
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API void Perform(const Point2& p, double tol)	 @param tol The tolerance
	 @param p The uv point
	 @brief Classify a UV point on face with tolerance
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <hatch/BRepFaceClassifier.hpp>
#include <common/FrameT.hpp>
#include <math/CircleT.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeWire.hpp>
#include <modeling/MakeFace.hpp>
#include <boolean/BoolBRepFuse.hpp>
#include <common/IndexSet.hpp>
#include <topology/TopoExplorerTool.hpp>
using namespace AMCAX;
TopoFace WrenchFace()
{
	Frame3 fm1(Point3(0., 0., 0.), Direction3(0., 0., 1.0));
	Circle3 c1 = Circle3(fm1, 2.);
	TopoEdge ec1 = MakeEdge(c1);
	TopoWire wc1 = MakeWire(ec1);
	TopoFace F1 = MakeFace(wc1);
	TopoEdge edge1 = MakeEdge(Point3(-4., -1.0, 0.0), Point3(4., -1.0, 0.0));
	TopoEdge edge2 = MakeEdge(Point3(4., -1.0, 0.0), Point3(4., 1.0, 0.0));
	TopoEdge edge3 = MakeEdge(Point3(4., 1.0, 0.0), Point3(-4., 1.0, 0.0));
	TopoEdge edge4 = MakeEdge(Point3(-4., 1.0, 0.0), Point3(-4., -1.0, 0.0));
	TopoWire wireR = MakeWire(edge1, edge2, edge3, edge4);
	TopoFace F3 = MakeFace(wireR);
	BoolBRepFuse fuse(F1, F3);
	fuse.Build();
	fuse.SimplifyResult();
	TopoShape res = fuse.Shape();
	IndexSet<TopoShape> resFaces;
	TopoExplorerTool::MapShapes(res, ShapeType::Face, resFaces);
	std::cout << resFaces.size() << std::endl;
	TopoFace face = static_cast<const TopoFace&>(resFaces[0]);
	return face;
}
bool ImpInWrenchFace(const Point2& pt)
{
	bool isFaceIn1 = pt.X() * pt.X() + pt.Y() * pt.Y() < 2 * 2;
	bool isFaceIn2 = pt.X() > -4 && pt.X() < 4 && pt.Y() > -1 && pt.Y() < 1;
	return isFaceIn1 || isFaceIn2;
}
Point2 SampleMethodFace()
{
	double x = (double)rand() / RAND_MAX * 10 - 5;
	double y = (double)rand() / RAND_MAX * 5 - 2.0;
	return Point2(x, y);
}
TEST_CASE("case1: BRepFaceClassifier 3.6.0 added API. ", "[hatch][BRepFaceClassifier][P1]") {
		TopoFace face = WrenchFace();
		BRepFaceClassifier classify(face);
		int n = 10000;
		int inSize = 0, intime = 0, ontime = 0;
		for (int i = 0; i < n; ++i)
		{
			Point2 pt = SampleMethodFace();
			bool isIn = ImpInWrenchFace(pt);
			classify.Perform(pt, Precision::Confusion());
			bool isCIn = classify.State() == StateType::In;
			bool isCon = classify.State() == StateType::On;
			if (isIn)
			{
				inSize++;
				if (isCIn)
				{
					intime++;
				}
				if (isCon)
				{
					ontime++;
				}
			}
		}
		std::cout << inSize << " " << intime << " " << ontime << std::endl;
		CHECK(inSize == (intime + ontime));
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static TopoShape FixShape(const TopoShape& shape, double prec, double maxTol)	 @return Fixed Shape
	 @param maxTol The global max tolerance used when the algorithm needs to check the tolerance
	 @param prec The global precision used when the algorithm needs to check the precision
	 @param shape Input shape
	 @brief Try to repair the shape to a valid shape
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <healing/ShapeFixTool.hpp>
#include <common/Precision.hpp>
using namespace AMCAX;
TEST_CASE("bug1: ShapeFixTool ", "[healing][ShapeFixTool][fixbug]") {
	AMCAX::TopoShape readshape;
	AMCAX::OCCTIO::OCCTTool::Read(readshape, INPUT_PATH_PREFIX"FixShape-Crash.brep");
	readshape = AMCAX::ShapeFixTool::FixShape(readshape, AMCAX::Precision::Confusion(), 1E-1);
	AMCAX::OCCTIO::OCCTTool::Write(readshape, OUTPUT_PATH_PREFIX"ShapeFixTool_O_FixedShape.brep");
	GlobalProperty prop;
	BRepGlobalProperty::VolumeProperties(readshape, prop);
	CHECK(prop.Mass() == Approx(16486799.3305680156).epsilon(1e-2));
	Point3 vP = prop.CenterOfMass();
	CHECK(vP.X() == Approx(-260.8706721039).epsilon(1e-2));
	CHECK(vP.Y() == Approx(-154.6717940115).epsilon(1e-2));
	CHECK(vP.Z() == Approx(-0.1139512307).epsilon(1e-2));
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static bool Read(TopoShape& s, const std::string& file)	 @return True if the input process is succeed
	 @param file The input file
	 @param s The shape
	 @brief Read a shape from a file
,
 "output":#include <catch.hpp>
#include<testHelper.h>
#include <topology/TopoShape.hpp>
#include <occtio/OCCTTool.hpp>
static bool ComparisonFields(const std::string& file1, const std::string& file2, const std::string& fields)
{
	ifstream file1Stream(file1);
	ifstream file2Stream(file2);
	if (file1Stream.is_open() == false || file2Stream.is_open() == false)
	{
		file1Stream.close();
		file2Stream.close();
		return false;
	}
	std::string line1, line2;
	while (std::getline(file1Stream, line1))
	{
		if (line1.find(fields) != std::string::npos) break;
	}
	while (std::getline(file2Stream, line2))
	{
		if (line2.find(fields) != std::string::npos) break;
	}
	file1Stream.close();
	file2Stream.close();
	return line1 == line2;
}
TEST_CASE("CASE3:Check occio read not exist file ", "[occtio][OCCTTool][p2]") {
	AMCAX::TopoShape shape;
	SECTION("OCCTIO::OCCTTool::Read") {
		bool isReadSuccess = AMCAX::OCCTIO::OCCTTool::Read(shape, INPUT_PATH_PREFIX"NOTEXIST.brep");
		CHECK(isReadSuccess == false);
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static bool Write(const TopoShape& s, std::ostream& os, int format = 3)	 @return True if the output process is succeed
	 @param[in] format The format version
	 @param[in,out] os The output stream
	 @param[in] s The shape
	 @brief Write a shape to a stream
,
 "output":#include <catch.hpp>
#include<testHelper.h>
#include <topology/TopoShape.hpp>
#include <occtio/OCCTTool.hpp>
static bool ComparisonFields(const std::string& file1, const std::string& file2, const std::string& fields)
{
	ifstream file1Stream(file1);
	ifstream file2Stream(file2);
	if (file1Stream.is_open() == false || file2Stream.is_open() == false)
	{
		file1Stream.close();
		file2Stream.close();
		return false;
	}
	std::string line1, line2;
	while (std::getline(file1Stream, line1))
	{
		if (line1.find(fields) != std::string::npos) break;
	}
	while (std::getline(file2Stream, line2))
	{
		if (line2.find(fields) != std::string::npos) break;
	}
	file1Stream.close();
	file2Stream.close();
	return line1 == line2;
}
TEST_CASE("CASE1:Check occtio read and write normal brep file function with different param ", "[occtio][OCCTTool][p1][XXX]") {
	AMCAX::TopoShape shape;
	bool isReadSuccess = AMCAX::OCCTIO::OCCTTool::Read(shape, INPUT_PATH_PREFIX"occtio/occtio_read_I_brephaveMesh-case1.brep");
	bool isWriteSuccess1f = AMCAX::OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f1-f-case1.brep", false, 1);
	bool isWriteSuccess2f = AMCAX::OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f2-f-case1.brep", false, 2);
	bool isWriteSuccess3f = AMCAX::OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f3-f-case1.brep", false, 3);
	bool isWriteSuccess1t = AMCAX::OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f1-t-case1.brep", true, 1);
	bool isWriteSuccess2t = AMCAX::OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f2-t-case1.brep", true, 2);
	bool isWriteSuccess3t = AMCAX::OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f3-t-case1.brep", true, 3);
	CHECK(isReadSuccess == true);
	CHECK(isWriteSuccess1f == true);
	CHECK(isWriteSuccess2f == true);
	CHECK(isWriteSuccess3f == true);
	CHECK(containsStringInFile(OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f1-f-case1.brep", "Triangulations 0") == true);
	CHECK(containsStringInFile(OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f1-f-case1.brep", "CASCADE Topology V1, (c) Matra-Datavision") == true);
	CHECK(containsStringInFile(OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f2-f-case1.brep", "Triangulations 0") == true);
	CHECK(containsStringInFile(OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f2-f-case1.brep", "CASCADE Topology V2, (c) Matra-Datavision") == true);
	CHECK(containsStringInFile(OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f3-f-case1.brep", "Triangulations 0") == true);
	CHECK(containsStringInFile(OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f3-f-case1.brep", "CASCADE Topology V3, (c) Open Cascade") == true);
	CHECK(isWriteSuccess1t == true);
	CHECK(isWriteSuccess2t == true);
	CHECK(isWriteSuccess3t == true);
	CHECK(containsStringInFile(OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f1-t-case1.brep", "Triangulations 0") == false);
	CHECK(containsStringInFile(OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f1-t-case1.brep", "CASCADE Topology V1, (c) Matra-Datavision") == true);
	CHECK(containsStringInFile(OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f2-t-case1.brep", "Triangulations 0") == false);
	CHECK(containsStringInFile(OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f2-t-case1.brep", "CASCADE Topology V2, (c) Matra-Datavision") == true);
	CHECK(containsStringInFile(OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f3-t-case1.brep", "Triangulations 0") == false);
	CHECK(containsStringInFile(OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f3-t-case1.brep", "CASCADE Topology V3, (c) Open Cascade") == true);
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static bool Write(const TopoShape& s, std::ostream& os, bool withTriangles, int format = 3)	 @return True if the output process is succeed
	 @param[in] format The format version
	 @param[in] withTriangles Determine whether writing the triangular mesh of the shape
	 @param[in,out] os The output stream
	 @param[in] s The shape
	 @brief Wrtie a shape to a stream
,
 "output":#include <catch.hpp>
#include<testHelper.h>
#include <topology/TopoShape.hpp>
#include <occtio/OCCTTool.hpp>
static bool ComparisonFields(const std::string& file1, const std::string& file2, const std::string& fields)
{
	ifstream file1Stream(file1);
	ifstream file2Stream(file2);
	if (file1Stream.is_open() == false || file2Stream.is_open() == false)
	{
		file1Stream.close();
		file2Stream.close();
		return false;
	}
	std::string line1, line2;
	while (std::getline(file1Stream, line1))
	{
		if (line1.find(fields) != std::string::npos) break;
	}
	while (std::getline(file2Stream, line2))
	{
		if (line2.find(fields) != std::string::npos) break;
	}
	file1Stream.close();
	file2Stream.close();
	return line1 == line2;
}
TEST_CASE("CASE1:Check occtio read and write normal brep file function with different param ", "[occtio][OCCTTool][p1][XXX]") {
	AMCAX::TopoShape shape;
	bool isReadSuccess = AMCAX::OCCTIO::OCCTTool::Read(shape, INPUT_PATH_PREFIX"occtio/occtio_read_I_brephaveMesh-case1.brep");
	bool isWriteSuccess1f = AMCAX::OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f1-f-case1.brep", false, 1);
	bool isWriteSuccess2f = AMCAX::OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f2-f-case1.brep", false, 2);
	bool isWriteSuccess3f = AMCAX::OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f3-f-case1.brep", false, 3);
	bool isWriteSuccess1t = AMCAX::OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f1-t-case1.brep", true, 1);
	bool isWriteSuccess2t = AMCAX::OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f2-t-case1.brep", true, 2);
	bool isWriteSuccess3t = AMCAX::OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f3-t-case1.brep", true, 3);
	CHECK(isReadSuccess == true);
	CHECK(isWriteSuccess1f == true);
	CHECK(isWriteSuccess2f == true);
	CHECK(isWriteSuccess3f == true);
	CHECK(containsStringInFile(OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f1-f-case1.brep", "Triangulations 0") == true);
	CHECK(containsStringInFile(OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f1-f-case1.brep", "CASCADE Topology V1, (c) Matra-Datavision") == true);
	CHECK(containsStringInFile(OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f2-f-case1.brep", "Triangulations 0") == true);
	CHECK(containsStringInFile(OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f2-f-case1.brep", "CASCADE Topology V2, (c) Matra-Datavision") == true);
	CHECK(containsStringInFile(OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f3-f-case1.brep", "Triangulations 0") == true);
	CHECK(containsStringInFile(OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f3-f-case1.brep", "CASCADE Topology V3, (c) Open Cascade") == true);
	CHECK(isWriteSuccess1t == true);
	CHECK(isWriteSuccess2t == true);
	CHECK(isWriteSuccess3t == true);
	CHECK(containsStringInFile(OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f1-t-case1.brep", "Triangulations 0") == false);
	CHECK(containsStringInFile(OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f1-t-case1.brep", "CASCADE Topology V1, (c) Matra-Datavision") == true);
	CHECK(containsStringInFile(OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f2-t-case1.brep", "Triangulations 0") == false);
	CHECK(containsStringInFile(OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f2-t-case1.brep", "CASCADE Topology V2, (c) Matra-Datavision") == true);
	CHECK(containsStringInFile(OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f3-t-case1.brep", "Triangulations 0") == false);
	CHECK(containsStringInFile(OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f3-t-case1.brep", "CASCADE Topology V3, (c) Open Cascade") == true);
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static bool Write(const TopoShape& s, const std::string& file, int format = 3)	 @return True if the output process is succeed
	 @param format The format version
	 @param file The output file
	 @param s The shape
	 @brief Write a shape to a file
,
 "output":#include <catch.hpp>
#include<testHelper.h>
#include <topology/TopoShape.hpp>
#include <occtio/OCCTTool.hpp>
static bool ComparisonFields(const std::string& file1, const std::string& file2, const std::string& fields)
{
	ifstream file1Stream(file1);
	ifstream file2Stream(file2);
	if (file1Stream.is_open() == false || file2Stream.is_open() == false)
	{
		file1Stream.close();
		file2Stream.close();
		return false;
	}
	std::string line1, line2;
	while (std::getline(file1Stream, line1))
	{
		if (line1.find(fields) != std::string::npos) break;
	}
	while (std::getline(file2Stream, line2))
	{
		if (line2.find(fields) != std::string::npos) break;
	}
	file1Stream.close();
	file2Stream.close();
	return line1 == line2;
}
TEST_CASE("CASE1:Check occtio read and write normal brep file function with different param ", "[occtio][OCCTTool][p1][XXX]") {
	AMCAX::TopoShape shape;
	bool isReadSuccess = AMCAX::OCCTIO::OCCTTool::Read(shape, INPUT_PATH_PREFIX"occtio/occtio_read_I_brephaveMesh-case1.brep");
	bool isWriteSuccess1f = AMCAX::OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f1-f-case1.brep", false, 1);
	bool isWriteSuccess2f = AMCAX::OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f2-f-case1.brep", false, 2);
	bool isWriteSuccess3f = AMCAX::OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f3-f-case1.brep", false, 3);
	bool isWriteSuccess1t = AMCAX::OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f1-t-case1.brep", true, 1);
	bool isWriteSuccess2t = AMCAX::OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f2-t-case1.brep", true, 2);
	bool isWriteSuccess3t = AMCAX::OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f3-t-case1.brep", true, 3);
	CHECK(isReadSuccess == true);
	CHECK(isWriteSuccess1f == true);
	CHECK(isWriteSuccess2f == true);
	CHECK(isWriteSuccess3f == true);
	CHECK(containsStringInFile(OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f1-f-case1.brep", "Triangulations 0") == true);
	CHECK(containsStringInFile(OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f1-f-case1.brep", "CASCADE Topology V1, (c) Matra-Datavision") == true);
	CHECK(containsStringInFile(OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f2-f-case1.brep", "Triangulations 0") == true);
	CHECK(containsStringInFile(OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f2-f-case1.brep", "CASCADE Topology V2, (c) Matra-Datavision") == true);
	CHECK(containsStringInFile(OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f3-f-case1.brep", "Triangulations 0") == true);
	CHECK(containsStringInFile(OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f3-f-case1.brep", "CASCADE Topology V3, (c) Open Cascade") == true);
	CHECK(isWriteSuccess1t == true);
	CHECK(isWriteSuccess2t == true);
	CHECK(isWriteSuccess3t == true);
	CHECK(containsStringInFile(OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f1-t-case1.brep", "Triangulations 0") == false);
	CHECK(containsStringInFile(OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f1-t-case1.brep", "CASCADE Topology V1, (c) Matra-Datavision") == true);
	CHECK(containsStringInFile(OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f2-t-case1.brep", "Triangulations 0") == false);
	CHECK(containsStringInFile(OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f2-t-case1.brep", "CASCADE Topology V2, (c) Matra-Datavision") == true);
	CHECK(containsStringInFile(OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f3-t-case1.brep", "Triangulations 0") == false);
	CHECK(containsStringInFile(OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f3-t-case1.brep", "CASCADE Topology V3, (c) Open Cascade") == true);
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static bool Write(const TopoShape& s, const std::string& file, bool withTriangles, int format = 3)	 @return True if the output process is succeed
	 @param format The format version
	 @param withTriangles Determine whether writing the triangular mesh of the shape
	 @param file The output file
	 @param s The shape
	 @brief Write a shape to a file
,
 "output":#include <catch.hpp>
#include<testHelper.h>
#include <topology/TopoShape.hpp>
#include <occtio/OCCTTool.hpp>
static bool ComparisonFields(const std::string& file1, const std::string& file2, const std::string& fields)
{
	ifstream file1Stream(file1);
	ifstream file2Stream(file2);
	if (file1Stream.is_open() == false || file2Stream.is_open() == false)
	{
		file1Stream.close();
		file2Stream.close();
		return false;
	}
	std::string line1, line2;
	while (std::getline(file1Stream, line1))
	{
		if (line1.find(fields) != std::string::npos) break;
	}
	while (std::getline(file2Stream, line2))
	{
		if (line2.find(fields) != std::string::npos) break;
	}
	file1Stream.close();
	file2Stream.close();
	return line1 == line2;
}
TEST_CASE("CASE1:Check occtio read and write normal brep file function with different param ", "[occtio][OCCTTool][p1][XXX]") {
	AMCAX::TopoShape shape;
	bool isReadSuccess = AMCAX::OCCTIO::OCCTTool::Read(shape, INPUT_PATH_PREFIX"occtio/occtio_read_I_brephaveMesh-case1.brep");
	bool isWriteSuccess1f = AMCAX::OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f1-f-case1.brep", false, 1);
	bool isWriteSuccess2f = AMCAX::OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f2-f-case1.brep", false, 2);
	bool isWriteSuccess3f = AMCAX::OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f3-f-case1.brep", false, 3);
	bool isWriteSuccess1t = AMCAX::OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f1-t-case1.brep", true, 1);
	bool isWriteSuccess2t = AMCAX::OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f2-t-case1.brep", true, 2);
	bool isWriteSuccess3t = AMCAX::OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f3-t-case1.brep", true, 3);
	CHECK(isReadSuccess == true);
	CHECK(isWriteSuccess1f == true);
	CHECK(isWriteSuccess2f == true);
	CHECK(isWriteSuccess3f == true);
	CHECK(containsStringInFile(OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f1-f-case1.brep", "Triangulations 0") == true);
	CHECK(containsStringInFile(OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f1-f-case1.brep", "CASCADE Topology V1, (c) Matra-Datavision") == true);
	CHECK(containsStringInFile(OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f2-f-case1.brep", "Triangulations 0") == true);
	CHECK(containsStringInFile(OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f2-f-case1.brep", "CASCADE Topology V2, (c) Matra-Datavision") == true);
	CHECK(containsStringInFile(OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f3-f-case1.brep", "Triangulations 0") == true);
	CHECK(containsStringInFile(OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f3-f-case1.brep", "CASCADE Topology V3, (c) Open Cascade") == true);
	CHECK(isWriteSuccess1t == true);
	CHECK(isWriteSuccess2t == true);
	CHECK(isWriteSuccess3t == true);
	CHECK(containsStringInFile(OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f1-t-case1.brep", "Triangulations 0") == false);
	CHECK(containsStringInFile(OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f1-t-case1.brep", "CASCADE Topology V1, (c) Matra-Datavision") == true);
	CHECK(containsStringInFile(OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f2-t-case1.brep", "Triangulations 0") == false);
	CHECK(containsStringInFile(OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f2-t-case1.brep", "CASCADE Topology V2, (c) Matra-Datavision") == true);
	CHECK(containsStringInFile(OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f3-t-case1.brep", "Triangulations 0") == false);
	CHECK(containsStringInFile(OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f3-t-case1.brep", "CASCADE Topology V3, (c) Open Cascade") == true);
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static bool Read(TopoShape& s, std::istream& is)	 @return True if the input process is succeed
	 @param[in,out] is The input stream
	 @param[out] s The shape
	 @brief Read a shape from a stream
,
 "output":#include <catch.hpp>
#include<testHelper.h>
#include <topology/TopoShape.hpp>
#include <occtio/OCCTTool.hpp>
static bool ComparisonFields(const std::string& file1, const std::string& file2, const std::string& fields)
{
	ifstream file1Stream(file1);
	ifstream file2Stream(file2);
	if (file1Stream.is_open() == false || file2Stream.is_open() == false)
	{
		file1Stream.close();
		file2Stream.close();
		return false;
	}
	std::string line1, line2;
	while (std::getline(file1Stream, line1))
	{
		if (line1.find(fields) != std::string::npos) break;
	}
	while (std::getline(file2Stream, line2))
	{
		if (line2.find(fields) != std::string::npos) break;
	}
	file1Stream.close();
	file2Stream.close();
	return line1 == line2;
}
TEST_CASE("CASE3:Check occio read not exist file ", "[occtio][OCCTTool][p2]") {
	AMCAX::TopoShape shape;
	SECTION("OCCTIO::OCCTTool::Read") {
		bool isReadSuccess = AMCAX::OCCTIO::OCCTTool::Read(shape, INPUT_PATH_PREFIX"NOTEXIST.brep");
		CHECK(isReadSuccess == false);
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":void SetRadius(double r)	 @param r The radius
	 @brief Set the radius of the circle
,
 "output":#include<catch.hpp>
#include "testHelper.h"
#include<iostream>
#include <math/CircleT.hpp>
#include <common/AxisT.hpp>
#include <common/PointT.hpp>
TEST_CASE("CircleT Area and Length Test", "[CircleT]") {
    AMCAX::Circle2 circle2;
    circle2.SetRadius(5.0);
    CHECK(circle2.Area() == Approx(78.53982));
    CHECK(circle2.Length() == Approx(31.41593));
    AMCAX::Circle3 circle3;
    circle3.SetRadius(10.0);
    CHECK(circle3.Area() == Approx(314.15927));
    CHECK(circle3.Length() == Approx(62.83185));
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] double Radius()	 @return The radius
	 @brief Get the radius
,
 "output":#include<catch.hpp>
#include "testHelper.h"
#include<iostream>
#include <math/CircleT.hpp>
#include <common/AxisT.hpp>
#include <common/PointT.hpp>
TEST_CASE("CircleT Constructor Test", "[math][CircleT][P1]") {
	SECTION("2D Circle Construction") {
        AMCAX::Circle2 circle2;
        constexpr double maxr = std::numeric_limits<double>::max();
        CHECK(circle2.Radius() == Approx(maxr).epsilon(1e-15));
        CHECK(circle2.Area() == Approx(maxr * maxr * M_PI).epsilon(1e-15));
        double a, b, c, d, e, f;
        circle2.Coefficients(a, b, c, d, e, f);
        std::cout << a << std::endl;
        std::cout << b << std::endl;
        std::cout << c << std::endl;
        std::cout << d << std::endl;
        std::cout << e << std::endl;
        std::cout << f << std::endl;
        AMCAX::Point2 P(0.0, 1.0);
        double tolerance = 0.1;
        CHECK(circle2.Contains(P, tolerance)==false);
        CHECK(circle2.Distance(P) == Approx(maxr).epsilon(1e-15));
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] double Length()	 @return The length of the circle
	 @brief Get the length of the circle
,
 "output":#include<catch.hpp>
#include "testHelper.h"
#include<iostream>
#include <math/CircleT.hpp>
#include <common/AxisT.hpp>
#include <common/PointT.hpp>
TEST_CASE("case1: create a Cirecle", "[math][CircleT][P1]") {
	AMCAX::Point2 P(0.0,0.0);
	AMCAX::Direction2 D(1.0,0.0);
	AMCAX::Axis2  axis2(P, D);
	float radius = 5.0f;
	AMCAX::Circle2 circle2(axis2, radius, true);
	CHECK(circle2.Area() == radius * radius * M_PI); 
    double a, b, c, d, e, f;
    circle2.Coefficients(a, b, c, d, e, f);  
    double x = 0, y = 5;
    CHECK(a * x * x + b * y * y + c * x * y + d * x + e * y + f == Approx(0.0).epsilon(1e-15));
    double x1 = 5 * sqrt(2) / 2;
    double y1 = 5 * sqrt(2) / 2;
    double x2 = 6;
    double y2 = 0;
    double x3 = 5.5;
    double y3 = 6.1;
    AMCAX::Point2 P1(x1,y1);
    AMCAX::Point2 P2(x2, y2);
    AMCAX::Point2 P3(x3, y3);
    double tolerance1 = 0.1;
    double tolerance2 = 1.0;
    CHECK(circle2.Contains(P1, tolerance1) == true);
    CHECK(circle2.Contains(P2, tolerance2) == true);
    CHECK(circle2.Contains(P3, tolerance2) == false);
    CHECK(circle2.Distance(P1) == Approx(0.0).epsilon(1e-15));
    CHECK(circle2.Distance(P2) == Approx(1.0).epsilon(1e-15));
    CHECK(circle2.Length() == Approx(2*M_PI*radius).epsilon(1e-15));
    AMCAX::Point2 locationP = circle2.Location();
    CHECK(locationP.X() == Approx(0.0).epsilon(1e-15));
    CHECK(locationP.Y() == Approx(0.0).epsilon(1e-15));
    AMCAX::Point2 mirrorAxisPoint(1.0, 0.0);
    AMCAX::Direction2 mirrorAxisDirection(0.0, 1.0);
    AMCAX::Axis2 mirrorAxis(mirrorAxisPoint, mirrorAxisDirection);
    circle2.Mirror(mirrorAxis);
    CHECK(circle2.Length() == Approx(2 * M_PI * radius).epsilon(1e-15));
    AMCAX::Point2 locationPmirror = circle2.Location();
    CHECK(locationPmirror.X() == Approx(2.0).epsilon(1e-15));
    CHECK(locationPmirror.Y() == Approx(0.0).epsilon(1e-15));
    AMCAX::Point2 P4(7.0, 0.0);  
    CHECK(circle2.Contains(P4, tolerance2) == true);
    AMCAX::Point2 mirroredAxisPoint(1.0, 0.0);
    AMCAX::Direction2 mirroredAxisDirection(0.0, 1.0);
    AMCAX::Axis2 mirroedrAxis(mirroredAxisPoint, mirroredAxisDirection);
    AMCAX::Circle2 circle2mirrored = circle2.Mirrored(mirroedrAxis);
    CHECK(circle2mirrored.Length() == Approx(2 * M_PI * radius).epsilon(1e-15));
    AMCAX::Point2 locationPmirrored = circle2mirrored.Location();
    CHECK(locationPmirrored.X() == Approx(0.0).epsilon(1e-15));
    CHECK(locationPmirrored.Y() == Approx(0.0).epsilon(1e-15));
    AMCAX::Frame2 frame2mirrored = circle2mirrored.Position(); 
    CHECK(frame2mirrored.Location().X() == Approx(0.0).epsilon(1e-15));
    CHECK(frame2mirrored.Location().Y() == Approx(0.0).epsilon(1e-15));
    const double& radiusmirrored = circle2mirrored.Radius(); 
    CHECK(radiusmirrored == Approx(radius).epsilon(1e-15));
    circle2mirrored.Scale(P,0.5); 
    AMCAX::Point2 scaleP1(0.0,-2.5);
    CHECK(circle2mirrored.Contains(scaleP1, 0) == true);
    AMCAX::Circle2 circle2Scaled = circle2mirrored.Scale(P, 2); 
    AMCAX::Point2 scaledP1(0.0, 5.0);
    CHECK(circle2Scaled.Contains(scaledP1, 0) == true);
    AMCAX::Point2 rotateP(0.0,0.0);
    double angle = 90.0 * (2 * M_PI / 360.0);
    circle2.Rotate(rotateP, angle); 
    AMCAX::Point2 P5(0.0, -3.0);
    CHECK(circle2.Contains(P5, 0) == true);
    double angle2 = -180.0 * (2 * M_PI / 360.0);
    AMCAX::Circle2 rotatedCircle2 = circle2.Rotated(rotateP, angle2); 
    AMCAX::Point2 P6(0.0, 3.0);
    CHECK(rotatedCircle2.Contains(P6, 0) == true); 
    AMCAX::Point2 newP(0.0, 0.0);
    rotatedCircle2.SetLocation(newP);
    CHECK(rotatedCircle2.Contains(P1, 0) == true);
    std::cout << circle2.Length() << std::endl;
};
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] double Distance(const PointT<double, DIM>& p)	 @return The distance from the point to the circle
	 @param p The point
	 @brief Compute the distance from a point to the circle
,
 "output":#include<catch.hpp>
#include "testHelper.h"
#include<iostream>
#include <math/CircleT.hpp>
#include <common/AxisT.hpp>
#include <common/PointT.hpp>
TEST_CASE("case1: create a Cirecle", "[math][CircleT][P1]") {
	AMCAX::Point2 P(0.0,0.0);
	AMCAX::Direction2 D(1.0,0.0);
	AMCAX::Axis2  axis2(P, D);
	float radius = 5.0f;
	AMCAX::Circle2 circle2(axis2, radius, true);
	CHECK(circle2.Area() == radius * radius * M_PI); 
    double a, b, c, d, e, f;
    circle2.Coefficients(a, b, c, d, e, f);  
    double x = 0, y = 5;
    CHECK(a * x * x + b * y * y + c * x * y + d * x + e * y + f == Approx(0.0).epsilon(1e-15));
    double x1 = 5 * sqrt(2) / 2;
    double y1 = 5 * sqrt(2) / 2;
    double x2 = 6;
    double y2 = 0;
    double x3 = 5.5;
    double y3 = 6.1;
    AMCAX::Point2 P1(x1,y1);
    AMCAX::Point2 P2(x2, y2);
    AMCAX::Point2 P3(x3, y3);
    double tolerance1 = 0.1;
    double tolerance2 = 1.0;
    CHECK(circle2.Contains(P1, tolerance1) == true);
    CHECK(circle2.Contains(P2, tolerance2) == true);
    CHECK(circle2.Contains(P3, tolerance2) == false);
    CHECK(circle2.Distance(P1) == Approx(0.0).epsilon(1e-15));
    CHECK(circle2.Distance(P2) == Approx(1.0).epsilon(1e-15));
    CHECK(circle2.Length() == Approx(2*M_PI*radius).epsilon(1e-15));
    AMCAX::Point2 locationP = circle2.Location();
    CHECK(locationP.X() == Approx(0.0).epsilon(1e-15));
    CHECK(locationP.Y() == Approx(0.0).epsilon(1e-15));
    AMCAX::Point2 mirrorAxisPoint(1.0, 0.0);
    AMCAX::Direction2 mirrorAxisDirection(0.0, 1.0);
    AMCAX::Axis2 mirrorAxis(mirrorAxisPoint, mirrorAxisDirection);
    circle2.Mirror(mirrorAxis);
    CHECK(circle2.Length() == Approx(2 * M_PI * radius).epsilon(1e-15));
    AMCAX::Point2 locationPmirror = circle2.Location();
    CHECK(locationPmirror.X() == Approx(2.0).epsilon(1e-15));
    CHECK(locationPmirror.Y() == Approx(0.0).epsilon(1e-15));
    AMCAX::Point2 P4(7.0, 0.0);  
    CHECK(circle2.Contains(P4, tolerance2) == true);
    AMCAX::Point2 mirroredAxisPoint(1.0, 0.0);
    AMCAX::Direction2 mirroredAxisDirection(0.0, 1.0);
    AMCAX::Axis2 mirroedrAxis(mirroredAxisPoint, mirroredAxisDirection);
    AMCAX::Circle2 circle2mirrored = circle2.Mirrored(mirroedrAxis);
    CHECK(circle2mirrored.Length() == Approx(2 * M_PI * radius).epsilon(1e-15));
    AMCAX::Point2 locationPmirrored = circle2mirrored.Location();
    CHECK(locationPmirrored.X() == Approx(0.0).epsilon(1e-15));
    CHECK(locationPmirrored.Y() == Approx(0.0).epsilon(1e-15));
    AMCAX::Frame2 frame2mirrored = circle2mirrored.Position(); 
    CHECK(frame2mirrored.Location().X() == Approx(0.0).epsilon(1e-15));
    CHECK(frame2mirrored.Location().Y() == Approx(0.0).epsilon(1e-15));
    const double& radiusmirrored = circle2mirrored.Radius(); 
    CHECK(radiusmirrored == Approx(radius).epsilon(1e-15));
    circle2mirrored.Scale(P,0.5); 
    AMCAX::Point2 scaleP1(0.0,-2.5);
    CHECK(circle2mirrored.Contains(scaleP1, 0) == true);
    AMCAX::Circle2 circle2Scaled = circle2mirrored.Scale(P, 2); 
    AMCAX::Point2 scaledP1(0.0, 5.0);
    CHECK(circle2Scaled.Contains(scaledP1, 0) == true);
    AMCAX::Point2 rotateP(0.0,0.0);
    double angle = 90.0 * (2 * M_PI / 360.0);
    circle2.Rotate(rotateP, angle); 
    AMCAX::Point2 P5(0.0, -3.0);
    CHECK(circle2.Contains(P5, 0) == true);
    double angle2 = -180.0 * (2 * M_PI / 360.0);
    AMCAX::Circle2 rotatedCircle2 = circle2.Rotated(rotateP, angle2); 
    AMCAX::Point2 P6(0.0, 3.0);
    CHECK(rotatedCircle2.Contains(P6, 0) == true); 
    AMCAX::Point2 newP(0.0, 0.0);
    rotatedCircle2.SetLocation(newP);
    CHECK(rotatedCircle2.Contains(P1, 0) == true);
    std::cout << circle2.Length() << std::endl;
};
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":void SetRadius(double r)	 @param r The radius
	 @brief Set the radius of the circle
,
 "output":#include <math/CircleT.hpp>
#include <common/CoordT.hpp>
#include <common/TransformationType.hpp>
#include <common/DirectionT.hpp>
#include <common/PointT.hpp>
#include <common/Precision.hpp>
#include <common/CoordT.hpp>
#include <common/TransformationType.hpp>
#include <topology/TopoEdge.hpp>
#include <modeling/MakeEdge.hpp>
#include <topology/TopoWire.hpp>
#include <modeling/MakeWire.hpp>
#include <geometry/GlobalProperty.hpp>
#include <topology/BRepGlobalProperty.hpp>
#include<iostream>
#include "catch.hpp" 
using namespace std;
using namespace AMCAX;
TEST_CASE("TestCircle2D", "[math][Circle2D]")
{
	AMCAX::CircleT<double, 2> circle2D;
	AMCAX::Point2 center2D(0.0, 0.0);
	double redius2D = 5.0;
	double tol = 0.1;
	circle2D.SetLocation(center2D);
	circle2D.SetRadius(redius2D);
	double area2D = circle2D.Area();
	double length2D = circle2D.Length();
	AMCAX::Point2 retcenter2D = circle2D.Location();
	double retarea2D = M_PI * redius2D * redius2D;
	double retlength2D = 2 * M_PI * redius2D;
	std::cout << area2D << std::endl;
	std::cout << length2D << std::endl;
	std::cout << retcenter2D.X() << std::endl;
	std::cout << retcenter2D.Y() << std::endl;
	CHECK(area2D == retarea2D);
	CHECK(length2D == retlength2D);
	CHECK(retcenter2D.X() == center2D.X());
	CHECK(retcenter2D.Y() == center2D.Y());
	double a, b, c, d, e, f;
	circle2D.Coefficients(a, b, c, d, e, f);
	std::cout << a << std::endl;
	std::cout << b << std::endl;
	std::cout << c << std::endl;
	std::cout << d << std::endl;
	std::cout << e << std::endl;
	std::cout << f << std::endl;
	CHECK(a == 1);
	CHECK(b == 1);
	CHECK(c == 0);
	CHECK(d == 0);
	CHECK(e == 0);
	CHECK(f == -25);
	std::vector < AMCAX::Point2> testPoints = {
		AMCAX::Point2(3.0, 4.0),
		AMCAX::Point2(5.0, 0.0),
		AMCAX::Point2(4.9, 0.0),
		AMCAX::Point2(5.1, 0.0),
		AMCAX::Point2(6.0, 0.0)
	};
	for (const auto& point : testPoints)
	{
		double distanceToCenter = std::sqrt(point.X() * point.X() + point.Y() * point.Y());
		bool expectedIsInCircle = distanceToCenter <= 5.0 + tol;
		bool isInCircle = circle2D.Contains(point, tol);
		CHECK(isInCircle == expectedIsInCircle);
	}
	for (const auto& point : testPoints)
	{
		double distance = circle2D.Distance(point);
		double expectedDistance = std::abs(std::sqrt(std::pow(point.X() - center2D.X(), 2) + std::pow(point.Y() - center2D.Y(), 2)) - redius2D);
		CHECK(distance == expectedDistance);
	}
	AMCAX::AxisT<double, 2> mirrorAxis(AMCAX::Point2(0.0, 0.0), AMCAX::Direction2(0.0, 1.0));
	circle2D.Mirror(mirrorAxis);
	AMCAX::Point2 mirroredCenter = circle2D.Location();
	std::cout << "Mirrored circle center: (" << mirroredCenter.X() << ", " << mirroredCenter.Y() << ")" << std::endl;
	CHECK(mirroredCenter.X() == center2D.X());
	CHECK(mirroredCenter.Y() == center2D.Y());
	const AMCAX::FrameT<double, 2>& frame = circle2D.Position();
	AMCAX::Point2 rotationPoint(0.0, 0.0);
	double  rotationAngle = M_PI / 4;
	auto rotatedCircle = circle2D.Rotated(rotationPoint, rotationAngle);
	double cosAngle = cos(rotationAngle);
	double sinAngle = sin(rotationAngle);
	double newX = cosAngle * (center2D.X() - rotationPoint.X()) - sinAngle * (center2D.Y() - rotationPoint.Y()) + rotationPoint.X();
	double newY = sinAngle * (center2D.X() - rotationPoint.X()) + cosAngle * (center2D.Y() - rotationPoint.Y()) + rotationPoint.Y();
	auto rotatedCenter = rotatedCircle.Location();
	CHECK(newX == center2D.X());
	CHECK(newY == center2D.Y());
	AMCAX::Point2 scalingCenter(0.0, 0.0);
	double scalingFactor = 2.0;
	auto scaledCircle = circle2D.Scale(scalingCenter, scalingFactor);
	double scaledRadius = scaledCircle.Radius();
	double expectedScaledRadius = redius2D * scalingFactor;
	CHECK(std::abs(scaledRadius - expectedScaledRadius) < 1e-6);
	AMCAX::VectorT<double, 2> translationVector(2.0, 3.0);
	auto translatedCircle = circle2D.Translated(translationVector);
	auto translatedCenter = translatedCircle.Location();
	double translatedX = center2D.X() + translationVector.X();
	CHECK(translatedX == translatedCenter.X());
	auto xAxis = circle2D.XAxis();
	auto directionAxis = xAxis.Direction();
	CHECK(directionAxis.X() == -1.0);
	CHECK(directionAxis.Y() == 0.0);
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] double Radius()	 @return The radius
	 @brief Get the radius
,
 "output":#include <math/CircleT.hpp>
#include <common/CoordT.hpp>
#include <common/TransformationType.hpp>
#include <common/DirectionT.hpp>
#include <common/PointT.hpp>
#include <common/Precision.hpp>
#include <common/CoordT.hpp>
#include <common/TransformationType.hpp>
#include <topology/TopoEdge.hpp>
#include <modeling/MakeEdge.hpp>
#include <topology/TopoWire.hpp>
#include <modeling/MakeWire.hpp>
#include <geometry/GlobalProperty.hpp>
#include <topology/BRepGlobalProperty.hpp>
#include<iostream>
#include "catch.hpp" 
using namespace std;
using namespace AMCAX;
TEST_CASE("TestCircle3D", "[math][Circle3D]")
{
	AMCAX::Circle3 circle3D;
	AMCAX::Point3  center3D(0.0, 0.0, 0.0);
	double radius3D = 5.0;
	double tol = 0.1;
	circle3D.SetLocation(center3D);
	circle3D.SetRadius(radius3D);
	double area = circle3D.Area();
	auto axis = circle3D.Axis();
	AMCAX::Point3 expectedDirection(0.0, 0.0, 1.0);
	auto direction = axis.Direction();
	CHECK(area == Approx(78.5398));
	CHECK(direction.X() == Approx(expectedDirection.X()).margin(tol));
	CHECK(direction.Y() == Approx(expectedDirection.Y()).margin(tol));
	CHECK(direction.Z() == Approx(expectedDirection.Z()).margin(tol));
	std::vector <AMCAX::Point3> test3DPoints = {
		AMCAX::Point3(0.0, 0.0, 0.0),
		AMCAX::Point3(4.0, 0.0, 0.0),
	};
	for (const auto& point : test3DPoints)
	{
		double distanceToCenter = std::sqrt(std::pow(point.X() - center3D.X(), 2) + std::pow(point.Y() - center3D.Y(), 2) + std::pow(point.Z() - center3D.Z(), 2));
		bool expectedIsCircle = distanceToCenter <= 5.0 + tol;
		bool isInCircle = circle3D.Contains(point, tol);
		CHECK(!isInCircle == expectedIsCircle);
	}
	AMCAX::PointT<double, 3>  pointOutside(10.0, 0.0, 0.0);
	double expectedDistance = 5.0;
	CHECK(circle3D.Distance(pointOutside) == Approx(expectedDistance));
	double length = circle3D.Length();
	CHECK(length == Approx(31.4159));
	auto location = circle3D.Location();
	CHECK(location.X() == Approx(0.0));
	CHECK(location.Y() == Approx(0.0));
	CHECK(location.Z() == Approx(0.0));
	AMCAX::PointT<double, 3> mirrorPoint(1.0, 0.0, 0.0);
	circle3D.Mirror(mirrorPoint);
	auto mirroredLocation = circle3D.Location();
	CHECK(mirroredLocation.X() == Approx(2.0));
	CHECK(mirroredLocation.Y() == Approx(0.0));
	CHECK(mirroredLocation.Z() == Approx(0.0));
	auto position = circle3D.Position();   
	double r = circle3D.Radius();
	CHECK(r == 5.0);
	Direction3 zDirection(0.0, 0.0, 1.0);
	Axis3 zAxis(center3D, zDirection);
	Transformation3 rotation;
	rotation.SetRotation(zAxis, M_PI / 2);  
	Point3 newCenter1 = center3D.Transformed(rotation);
	CHECK(newCenter1.X() == 0.0);
	CHECK(newCenter1.Y() == 0.0);
	CHECK(newCenter1.Z() == 0.0);
	double angle = M_PI / 2;
	circle3D.Rotated(zAxis, angle);
	AMCAX::Frame3 frame = circle3D.Position();
	CHECK(frame.Location().X() == 2.0);
	CHECK(frame.Location().Y() == 0.0);
	CHECK(frame.Location().Z() == 0.0);
	double scale = 2.0;
	circle3D.Scale(center3D, scale);
	CHECK(circle3D.Radius() == radius3D * 2.0);
	AMCAX::PointT<double, 3> insidePoint(3.0, 4.0, 0.0);
	AMCAX::PointT<double, 3> onCirclePoint(5.0, 0.0, 0.0);
	AMCAX::PointT<double, 3> outsidePoint(8.0, 6.0, 0.0);
	double insideSquaredDistance = circle3D.SquaredDistance(insidePoint);
	double onCircleSquaredDistance = circle3D.SquaredDistance(onCirclePoint);
	double outsideSquaredDistance = circle3D.SquaredDistance(outsidePoint);
	CHECK(insideSquaredDistance == Approx(34.5378));
	CHECK(onCircleSquaredDistance == 81.0);
	CHECK(outsideSquaredDistance == Approx(7.7779));
	VectorT<double, 3> translationVector(5.0, 5.0, 0.0);
	circle3D.Translate(translationVector);
	CHECK(circle3D.Location().X() == 9.0);
	CHECK(circle3D.Location().Y() == 5.0);
	CHECK(circle3D.Location().Z() == 0.0);
	auto xAxis = circle3D.XAxis();
	auto yAxis = circle3D.YAxis();
	CHECK(xAxis.Direction().X() == Approx(-1.0));
	CHECK(yAxis.Direction().Y() == Approx(-1.0));
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] double Distance(const PointT<double, DIM>& p)	 @return The distance from the point to the circle
	 @param p The point
	 @brief Compute the distance from a point to the circle
,
 "output":#include <math/CircleT.hpp>
#include <common/CoordT.hpp>
#include <common/TransformationType.hpp>
#include <common/DirectionT.hpp>
#include <common/PointT.hpp>
#include <common/Precision.hpp>
#include <common/CoordT.hpp>
#include <common/TransformationType.hpp>
#include <topology/TopoEdge.hpp>
#include <modeling/MakeEdge.hpp>
#include <topology/TopoWire.hpp>
#include <modeling/MakeWire.hpp>
#include <geometry/GlobalProperty.hpp>
#include <topology/BRepGlobalProperty.hpp>
#include<iostream>
#include "catch.hpp" 
using namespace std;
using namespace AMCAX;
TEST_CASE("TestCircle3D", "[math][Circle3D]")
{
	AMCAX::Circle3 circle3D;
	AMCAX::Point3  center3D(0.0, 0.0, 0.0);
	double radius3D = 5.0;
	double tol = 0.1;
	circle3D.SetLocation(center3D);
	circle3D.SetRadius(radius3D);
	double area = circle3D.Area();
	auto axis = circle3D.Axis();
	AMCAX::Point3 expectedDirection(0.0, 0.0, 1.0);
	auto direction = axis.Direction();
	CHECK(area == Approx(78.5398));
	CHECK(direction.X() == Approx(expectedDirection.X()).margin(tol));
	CHECK(direction.Y() == Approx(expectedDirection.Y()).margin(tol));
	CHECK(direction.Z() == Approx(expectedDirection.Z()).margin(tol));
	std::vector <AMCAX::Point3> test3DPoints = {
		AMCAX::Point3(0.0, 0.0, 0.0),
		AMCAX::Point3(4.0, 0.0, 0.0),
	};
	for (const auto& point : test3DPoints)
	{
		double distanceToCenter = std::sqrt(std::pow(point.X() - center3D.X(), 2) + std::pow(point.Y() - center3D.Y(), 2) + std::pow(point.Z() - center3D.Z(), 2));
		bool expectedIsCircle = distanceToCenter <= 5.0 + tol;
		bool isInCircle = circle3D.Contains(point, tol);
		CHECK(!isInCircle == expectedIsCircle);
	}
	AMCAX::PointT<double, 3>  pointOutside(10.0, 0.0, 0.0);
	double expectedDistance = 5.0;
	CHECK(circle3D.Distance(pointOutside) == Approx(expectedDistance));
	double length = circle3D.Length();
	CHECK(length == Approx(31.4159));
	auto location = circle3D.Location();
	CHECK(location.X() == Approx(0.0));
	CHECK(location.Y() == Approx(0.0));
	CHECK(location.Z() == Approx(0.0));
	AMCAX::PointT<double, 3> mirrorPoint(1.0, 0.0, 0.0);
	circle3D.Mirror(mirrorPoint);
	auto mirroredLocation = circle3D.Location();
	CHECK(mirroredLocation.X() == Approx(2.0));
	CHECK(mirroredLocation.Y() == Approx(0.0));
	CHECK(mirroredLocation.Z() == Approx(0.0));
	auto position = circle3D.Position();   
	double r = circle3D.Radius();
	CHECK(r == 5.0);
	Direction3 zDirection(0.0, 0.0, 1.0);
	Axis3 zAxis(center3D, zDirection);
	Transformation3 rotation;
	rotation.SetRotation(zAxis, M_PI / 2);  
	Point3 newCenter1 = center3D.Transformed(rotation);
	CHECK(newCenter1.X() == 0.0);
	CHECK(newCenter1.Y() == 0.0);
	CHECK(newCenter1.Z() == 0.0);
	double angle = M_PI / 2;
	circle3D.Rotated(zAxis, angle);
	AMCAX::Frame3 frame = circle3D.Position();
	CHECK(frame.Location().X() == 2.0);
	CHECK(frame.Location().Y() == 0.0);
	CHECK(frame.Location().Z() == 0.0);
	double scale = 2.0;
	circle3D.Scale(center3D, scale);
	CHECK(circle3D.Radius() == radius3D * 2.0);
	AMCAX::PointT<double, 3> insidePoint(3.0, 4.0, 0.0);
	AMCAX::PointT<double, 3> onCirclePoint(5.0, 0.0, 0.0);
	AMCAX::PointT<double, 3> outsidePoint(8.0, 6.0, 0.0);
	double insideSquaredDistance = circle3D.SquaredDistance(insidePoint);
	double onCircleSquaredDistance = circle3D.SquaredDistance(onCirclePoint);
	double outsideSquaredDistance = circle3D.SquaredDistance(outsidePoint);
	CHECK(insideSquaredDistance == Approx(34.5378));
	CHECK(onCircleSquaredDistance == 81.0);
	CHECK(outsideSquaredDistance == Approx(7.7779));
	VectorT<double, 3> translationVector(5.0, 5.0, 0.0);
	circle3D.Translate(translationVector);
	CHECK(circle3D.Location().X() == 9.0);
	CHECK(circle3D.Location().Y() == 5.0);
	CHECK(circle3D.Location().Z() == 0.0);
	auto xAxis = circle3D.XAxis();
	auto yAxis = circle3D.YAxis();
	CHECK(xAxis.Direction().X() == Approx(-1.0));
	CHECK(yAxis.Direction().Y() == Approx(-1.0));
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] double SquaredDistance(const PointT<double, DIM>& p)	 @return The squared distance from the point to the circle
	 @param p The point
	 @brief Compute the squared distance from a point to the circle
,
 "output":#include <math/CircleT.hpp>
#include <common/CoordT.hpp>
#include <common/TransformationType.hpp>
#include <common/DirectionT.hpp>
#include <common/PointT.hpp>
#include <common/Precision.hpp>
#include <common/CoordT.hpp>
#include <common/TransformationType.hpp>
#include <topology/TopoEdge.hpp>
#include <modeling/MakeEdge.hpp>
#include <topology/TopoWire.hpp>
#include <modeling/MakeWire.hpp>
#include <geometry/GlobalProperty.hpp>
#include <topology/BRepGlobalProperty.hpp>
#include<iostream>
#include "catch.hpp" 
using namespace std;
using namespace AMCAX;
TEST_CASE("TestCircle3D", "[math][Circle3D]")
{
	AMCAX::Circle3 circle3D;
	AMCAX::Point3  center3D(0.0, 0.0, 0.0);
	double radius3D = 5.0;
	double tol = 0.1;
	circle3D.SetLocation(center3D);
	circle3D.SetRadius(radius3D);
	double area = circle3D.Area();
	auto axis = circle3D.Axis();
	AMCAX::Point3 expectedDirection(0.0, 0.0, 1.0);
	auto direction = axis.Direction();
	CHECK(area == Approx(78.5398));
	CHECK(direction.X() == Approx(expectedDirection.X()).margin(tol));
	CHECK(direction.Y() == Approx(expectedDirection.Y()).margin(tol));
	CHECK(direction.Z() == Approx(expectedDirection.Z()).margin(tol));
	std::vector <AMCAX::Point3> test3DPoints = {
		AMCAX::Point3(0.0, 0.0, 0.0),
		AMCAX::Point3(4.0, 0.0, 0.0),
	};
	for (const auto& point : test3DPoints)
	{
		double distanceToCenter = std::sqrt(std::pow(point.X() - center3D.X(), 2) + std::pow(point.Y() - center3D.Y(), 2) + std::pow(point.Z() - center3D.Z(), 2));
		bool expectedIsCircle = distanceToCenter <= 5.0 + tol;
		bool isInCircle = circle3D.Contains(point, tol);
		CHECK(!isInCircle == expectedIsCircle);
	}
	AMCAX::PointT<double, 3>  pointOutside(10.0, 0.0, 0.0);
	double expectedDistance = 5.0;
	CHECK(circle3D.Distance(pointOutside) == Approx(expectedDistance));
	double length = circle3D.Length();
	CHECK(length == Approx(31.4159));
	auto location = circle3D.Location();
	CHECK(location.X() == Approx(0.0));
	CHECK(location.Y() == Approx(0.0));
	CHECK(location.Z() == Approx(0.0));
	AMCAX::PointT<double, 3> mirrorPoint(1.0, 0.0, 0.0);
	circle3D.Mirror(mirrorPoint);
	auto mirroredLocation = circle3D.Location();
	CHECK(mirroredLocation.X() == Approx(2.0));
	CHECK(mirroredLocation.Y() == Approx(0.0));
	CHECK(mirroredLocation.Z() == Approx(0.0));
	auto position = circle3D.Position();   
	double r = circle3D.Radius();
	CHECK(r == 5.0);
	Direction3 zDirection(0.0, 0.0, 1.0);
	Axis3 zAxis(center3D, zDirection);
	Transformation3 rotation;
	rotation.SetRotation(zAxis, M_PI / 2);  
	Point3 newCenter1 = center3D.Transformed(rotation);
	CHECK(newCenter1.X() == 0.0);
	CHECK(newCenter1.Y() == 0.0);
	CHECK(newCenter1.Z() == 0.0);
	double angle = M_PI / 2;
	circle3D.Rotated(zAxis, angle);
	AMCAX::Frame3 frame = circle3D.Position();
	CHECK(frame.Location().X() == 2.0);
	CHECK(frame.Location().Y() == 0.0);
	CHECK(frame.Location().Z() == 0.0);
	double scale = 2.0;
	circle3D.Scale(center3D, scale);
	CHECK(circle3D.Radius() == radius3D * 2.0);
	AMCAX::PointT<double, 3> insidePoint(3.0, 4.0, 0.0);
	AMCAX::PointT<double, 3> onCirclePoint(5.0, 0.0, 0.0);
	AMCAX::PointT<double, 3> outsidePoint(8.0, 6.0, 0.0);
	double insideSquaredDistance = circle3D.SquaredDistance(insidePoint);
	double onCircleSquaredDistance = circle3D.SquaredDistance(onCirclePoint);
	double outsideSquaredDistance = circle3D.SquaredDistance(outsidePoint);
	CHECK(insideSquaredDistance == Approx(34.5378));
	CHECK(onCircleSquaredDistance == 81.0);
	CHECK(outsideSquaredDistance == Approx(7.7779));
	VectorT<double, 3> translationVector(5.0, 5.0, 0.0);
	circle3D.Translate(translationVector);
	CHECK(circle3D.Location().X() == 9.0);
	CHECK(circle3D.Location().Y() == 5.0);
	CHECK(circle3D.Location().Z() == 0.0);
	auto xAxis = circle3D.XAxis();
	auto yAxis = circle3D.YAxis();
	CHECK(xAxis.Direction().X() == Approx(-1.0));
	CHECK(yAxis.Direction().Y() == Approx(-1.0));
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":CircleS& Scale(const PointT<double, DIM>& p, double scale)	 @return The reference to self
	 @param scale The scale value
	 @param p The scaling center point
	 @brief Scale the circle by a center point
,
 "output":#include <math/CircleT.hpp>
#include <common/CoordT.hpp>
#include <common/TransformationType.hpp>
#include <common/DirectionT.hpp>
#include <common/PointT.hpp>
#include <common/Precision.hpp>
#include <common/CoordT.hpp>
#include <common/TransformationType.hpp>
#include <topology/TopoEdge.hpp>
#include <modeling/MakeEdge.hpp>
#include <topology/TopoWire.hpp>
#include <modeling/MakeWire.hpp>
#include <geometry/GlobalProperty.hpp>
#include <topology/BRepGlobalProperty.hpp>
#include<iostream>
#include "catch.hpp" 
using namespace std;
using namespace AMCAX;
TEST_CASE("TestCircle2D", "[math][Circle2D]")
{
	AMCAX::CircleT<double, 2> circle2D;
	AMCAX::Point2 center2D(0.0, 0.0);
	double redius2D = 5.0;
	double tol = 0.1;
	circle2D.SetLocation(center2D);
	circle2D.SetRadius(redius2D);
	double area2D = circle2D.Area();
	double length2D = circle2D.Length();
	AMCAX::Point2 retcenter2D = circle2D.Location();
	double retarea2D = M_PI * redius2D * redius2D;
	double retlength2D = 2 * M_PI * redius2D;
	std::cout << area2D << std::endl;
	std::cout << length2D << std::endl;
	std::cout << retcenter2D.X() << std::endl;
	std::cout << retcenter2D.Y() << std::endl;
	CHECK(area2D == retarea2D);
	CHECK(length2D == retlength2D);
	CHECK(retcenter2D.X() == center2D.X());
	CHECK(retcenter2D.Y() == center2D.Y());
	double a, b, c, d, e, f;
	circle2D.Coefficients(a, b, c, d, e, f);
	std::cout << a << std::endl;
	std::cout << b << std::endl;
	std::cout << c << std::endl;
	std::cout << d << std::endl;
	std::cout << e << std::endl;
	std::cout << f << std::endl;
	CHECK(a == 1);
	CHECK(b == 1);
	CHECK(c == 0);
	CHECK(d == 0);
	CHECK(e == 0);
	CHECK(f == -25);
	std::vector < AMCAX::Point2> testPoints = {
		AMCAX::Point2(3.0, 4.0),
		AMCAX::Point2(5.0, 0.0),
		AMCAX::Point2(4.9, 0.0),
		AMCAX::Point2(5.1, 0.0),
		AMCAX::Point2(6.0, 0.0)
	};
	for (const auto& point : testPoints)
	{
		double distanceToCenter = std::sqrt(point.X() * point.X() + point.Y() * point.Y());
		bool expectedIsInCircle = distanceToCenter <= 5.0 + tol;
		bool isInCircle = circle2D.Contains(point, tol);
		CHECK(isInCircle == expectedIsInCircle);
	}
	for (const auto& point : testPoints)
	{
		double distance = circle2D.Distance(point);
		double expectedDistance = std::abs(std::sqrt(std::pow(point.X() - center2D.X(), 2) + std::pow(point.Y() - center2D.Y(), 2)) - redius2D);
		CHECK(distance == expectedDistance);
	}
	AMCAX::AxisT<double, 2> mirrorAxis(AMCAX::Point2(0.0, 0.0), AMCAX::Direction2(0.0, 1.0));
	circle2D.Mirror(mirrorAxis);
	AMCAX::Point2 mirroredCenter = circle2D.Location();
	std::cout << "Mirrored circle center: (" << mirroredCenter.X() << ", " << mirroredCenter.Y() << ")" << std::endl;
	CHECK(mirroredCenter.X() == center2D.X());
	CHECK(mirroredCenter.Y() == center2D.Y());
	const AMCAX::FrameT<double, 2>& frame = circle2D.Position();
	AMCAX::Point2 rotationPoint(0.0, 0.0);
	double  rotationAngle = M_PI / 4;
	auto rotatedCircle = circle2D.Rotated(rotationPoint, rotationAngle);
	double cosAngle = cos(rotationAngle);
	double sinAngle = sin(rotationAngle);
	double newX = cosAngle * (center2D.X() - rotationPoint.X()) - sinAngle * (center2D.Y() - rotationPoint.Y()) + rotationPoint.X();
	double newY = sinAngle * (center2D.X() - rotationPoint.X()) + cosAngle * (center2D.Y() - rotationPoint.Y()) + rotationPoint.Y();
	auto rotatedCenter = rotatedCircle.Location();
	CHECK(newX == center2D.X());
	CHECK(newY == center2D.Y());
	AMCAX::Point2 scalingCenter(0.0, 0.0);
	double scalingFactor = 2.0;
	auto scaledCircle = circle2D.Scale(scalingCenter, scalingFactor);
	double scaledRadius = scaledCircle.Radius();
	double expectedScaledRadius = redius2D * scalingFactor;
	CHECK(std::abs(scaledRadius - expectedScaledRadius) < 1e-6);
	AMCAX::VectorT<double, 2> translationVector(2.0, 3.0);
	auto translatedCircle = circle2D.Translated(translationVector);
	auto translatedCenter = translatedCircle.Location();
	double translatedX = center2D.X() + translationVector.X();
	CHECK(translatedX == translatedCenter.X());
	auto xAxis = circle2D.XAxis();
	auto directionAxis = xAxis.Direction();
	CHECK(directionAxis.X() == -1.0);
	CHECK(directionAxis.Y() == 0.0);
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] double Area()	 @return The area of the ellipse
	 @brief Get the area of the ellipse
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <common/FrameT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <math/EllipseT.hpp>
using namespace AMCAX;
using namespace std;
TEST_CASE("case1:this is a case for Test Ellipse2", "[math][Ellipse2][P1]")
{
	Axis2 axis;
	double major = 5.0;
	double minor = 4.0;
	bool isRight = true;
	Ellipse2 ellipse(axis, major, minor, isRight);
	SECTION("Area")
	{
		double S = ellipse.Area();
		CHECK(S == Approx(M_PI * major * minor));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":EllipseS& Scale(const PointT<double, DIM>& point, double scale)	 @return The reference to self
	 @param scale The scale value
	 @param point The scaling center point
	 @brief Scale the ellipse by a center point
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <common/FrameT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <math/EllipseT.hpp>
using namespace AMCAX;
using namespace std;
TEST_CASE("case3:this is a case for Test-Ellipse2-Rotate", "[math][Ellipse2][P1]")
{
	Point2 point1(6.0, 0.0);
	Direction2 dir1(0.0, 1.0);
	Axis2 axis1(point1, dir1);
	double major = 5.0;
	double minor = 4.0;
	bool isRight = true;
	Ellipse2 ellipse(axis1, major, minor, isRight);
	double angle = M_PI_2;
	Point2 point_temp(0.0, 0.0);
	SECTION("Scale")
	{
		Ellipse2 scale_ellipse = ellipse.Scale(point, scale);
		CHECK(ellipse.Location().X() == Approx(2.5));
		CHECK(ellipse.Location().Y() == Approx(-1.0));
		CHECK(ellipse.MajorRadius() == Approx(2.5));
		CHECK(ellipse.MinorRadius() == Approx(2.0));
		CHECK(scale_ellipse.Location().X() == Approx(2.5));
		CHECK(scale_ellipse.Location().Y() == Approx(-1.0));
		CHECK(scale_ellipse.MajorRadius() == Approx(2.5));
		CHECK(scale_ellipse.MinorRadius() == Approx(2.0));
	}
	scale = -2.0;}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":EllipseS& Transform(const TransformationT<double, DIM>& tr)	 @return The reference to self
	 @param tr The transformation
	 @brief Transform the ellipse
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <common/FrameT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <math/EllipseT.hpp>
using namespace AMCAX;
using namespace std;
TEST_CASE("case3:this is a case for Test-Ellipse2-Rotate", "[math][Ellipse2][P1]")
{
	Point2 point1(6.0, 0.0);
	Direction2 dir1(0.0, 1.0);
	Axis2 axis1(point1, dir1);
	double major = 5.0;
	double minor = 4.0;
	bool isRight = true;
	Ellipse2 ellipse(axis1, major, minor, isRight);
	double angle = M_PI_2;
	Point2 point_temp(0.0, 0.0);
	SECTION("Transform")
	{
		Ellipse2 Transfor_ellipse = ellipse.Transform(tr);
		CHECK(ellipse.Location().X() == Approx(5.0));
		CHECK(ellipse.Location().Y() == Approx(-2.0));
		CHECK(ellipse.MajorRadius() == Approx(5.0));
		CHECK(ellipse.MinorRadius() == Approx(4.0));
		CHECK(Transfor_ellipse.Location().X() == Approx(5.0));
		CHECK(Transfor_ellipse.Location().Y() == Approx(-2.0));
		CHECK(Transfor_ellipse.MajorRadius() == Approx(5.0));
		CHECK(Transfor_ellipse.MinorRadius() == Approx(4.0));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] double Area()	 @return The area of the ellipse
	 @brief Get the area of the ellipse
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <common/FrameT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <math/EllipseT.hpp>
using namespace AMCAX;
using namespace std;
TEST_CASE("case1:this is a case for Test Ellipse3", "[math][Ellipse3][P1]")
{
	Frame3 frame;
	double major = 5.0;
	double minor = 4.0;
	Ellipse3 ellipse(frame, major, minor);
	SECTION("Area")
	{
		double S = ellipse.Area();
		CHECK(S == Approx(M_PI * major * minor));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] double FocalParameter()	 @return The focal parameter
	          Focal parameter = 2 * focalLength.
	 @details The focal parameter of parabola is the distance from the focus to the directrix.
	 @brief Get the focal parameter of the parabola
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <geometry/Geom2Parabola.hpp>
using namespace AMCAX;
using namespace std;
TEST_CASE("case1:this is a case for Test Geom2Parabola", "[math][Geom2Parabola][P1]")
{
	Axis2 axis;
	double focal = 5.0;
	bool isRight = true;
	Geom2Parabola g2p(axis, focal, isRight);
	SECTION("FocalParameter")
	{
		double FP = g2p.FocalParameter();
		double fp = 2 * focal;
		CHECK(FP == fp);
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] double SemilatusRectum()	 @return The semilatus rectum
	          Semilatus rectum = 2 * focalLength
	 @details The semilatus rectum of parabola is half of the length of the chord through a focus parallel to the directrix.
	 @brief Get the semilatus rectum of the parabola
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <geometry/Geom2Parabola.hpp>
using namespace AMCAX;
using namespace std;
TEST_CASE("case1:this is a case for Test Geom2Parabola", "[math][Geom2Parabola][P1]")
{
	Axis2 axis;
	double focal = 5.0;
	bool isRight = true;
	Geom2Parabola g2p(axis, focal, isRight);
	SECTION("SemilatusRectum")
	{
		double SR = g2p.SemilatusRectum();
		double sr = 2 * focal;
		CHECK(SR == sr);
	}
}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] double FocalParameter()	 @return The focal parameter
	          Focal parameter = 2 * focalLength.
	 @details The focal parameter of parabola is the distance from the focus to the directrix.
	 @brief Get the focal parameter of the parabola
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <geometry/Geom3Parabola.hpp>
using namespace AMCAX;
using namespace std;
TEST_CASE("case1:this is a case for Test Geom3Parabola", "[math][Geom3Parabola][P1]")
{
	Frame3 frame;
	double focal = 5.0;
	Geom3Parabola g3p(frame, focal);
	SECTION("FocalParameter")
	{
		double FP = g3p.FocalParameter();
		double fp = 2 * focal;
		CHECK(FP == fp);
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] double SemilatusRectum()	 @return The semilatus rectum
	          Semilatus rectum = 2 * focalLength
	 @details The semilatus rectum of parabola is half of the length of the chord through a focus parallel to the directrix.
	 @brief Get the semilatus rectum of the parabola
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <geometry/Geom3Parabola.hpp>
using namespace AMCAX;
using namespace std;
TEST_CASE("case1:this is a case for Test Geom3Parabola", "[math][Geom3Parabola][P1]")
{
	Frame3 frame;
	double focal = 5.0;
	Geom3Parabola g3p(frame, focal);
	SECTION("SemilatusRectum")
	{
		double SR = g3p.SemilatusRectum();
		double sr = 2 * focal;
		CHECK(SR == sr);
	}
}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] double FocalParameter()	 @return The focal parameter
	          Focal parameter = 2 * focalLength.
	 @details The focal parameter of parabola is the distance from the focus to the directrix.
	 @brief Get the focal parameter of the parabola
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <math/ParabolaT.hpp>
using namespace AMCAX;
using namespace std;
TEST_CASE("case1:this is a case for Test Parabola2", "[math][Parabola2][P1]")
{
	Axis2 axis;
	double focal = 5.0;
	bool isRight = true;
	Parabola2 parabola(axis, focal, isRight);
	SECTION("FocalParameter")
	{
		double FP = parabola.FocalParameter();
		double fp = 2 * focal;
		CHECK(FP == fp);
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] double SemilatusRectum()	 @return The semilatus rectum
	          Semilatus rectum = 2 * focalLength
	 @details The semilatus rectum of parabola is half of the length of the chord through a focus parallel to the directrix.
	 @brief Get the semilatus rectum of the parabola
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <math/ParabolaT.hpp>
using namespace AMCAX;
using namespace std;
TEST_CASE("case1:this is a case for Test Parabola2", "[math][Parabola2][P1]")
{
	Axis2 axis;
	double focal = 5.0;
	bool isRight = true;
	Parabola2 parabola(axis, focal, isRight);
	SECTION("SemilatusRectum")
	{
		double SR = parabola.SemilatusRectum();
		double sr = 2 * focal;
		CHECK(SR == sr);
	}
}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] double FocalParameter()	 @return The focal parameter
	          Focal parameter = 2 * focalLength.
	 @details The focal parameter of parabola is the distance from the focus to the directrix.
	 @brief Get the focal parameter of the parabola
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <math/ParabolaT.hpp>
using namespace AMCAX;
using namespace std;
TEST_CASE("case1:this is a case for Test Parabola3", "[math][Parabola3][P1]")
{
	Frame3 frame;
	double focal = 5.0;
	Parabola3 parabola(frame, focal);
	SECTION("FocalParameter")
	{
		double FP = parabola.FocalParameter();
		double fp = 2 * focal;
		CHECK(FP == fp);
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] double SemilatusRectum()	 @return The semilatus rectum
	          Semilatus rectum = 2 * focalLength
	 @details The semilatus rectum of parabola is half of the length of the chord through a focus parallel to the directrix.
	 @brief Get the semilatus rectum of the parabola
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <math/ParabolaT.hpp>
using namespace AMCAX;
using namespace std;
TEST_CASE("case1:this is a case for Test Parabola3", "[math][Parabola3][P1]")
{
	Frame3 frame;
	double focal = 5.0;
	Parabola3 parabola(frame, focal);
	SECTION("SemilatusRectum")
	{
		double SR = parabola.SemilatusRectum();
		double sr = 2 * focal;
		CHECK(SR == sr);
	}
}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] bool Contains(const PointT<double, DIM>& p, double tol)	 @return True if the point is on the line under the tolerance
	 @param tol The tolerance
	 @param p The point
	 @brief Does the line contain a point under a distance tolerance
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <math/LineT.hpp>
#include <modeling/MakeEdge2d.hpp>
using AMCAX::Line2;
#define ONE_RADIAN (M_PI / 180.)
TEST_CASE("case2: Line base method Test", "[math][Line2][p1]")
{
	SECTION("Contains")
	{
		Line2 line(Axis2(Point2(2., 1.), Direction2(1., 1.)));  
		Point2 point1(2., 1.);  
		Point2 point2(1., 1.);  
		CHECK(line.Contains(point1, 1e-5));
		CHECK_FALSE(line.Contains(point2, 1e-5));
		CHECK(line.Contains(point2, 1.));  
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] const PointT<double, DIM>& Location()	 @return The location of the line
	 @brief Get the location point of the line
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <math/LineT.hpp>
#include <modeling/MakeEdge2d.hpp>
using AMCAX::Line2;
#define ONE_RADIAN (M_PI / 180.)
TEST_CASE("case1: Line basic interface test", "[math][Line2][p1]")
{
	SECTION("Parameterless constructor test")
	{
		Line2 line;  
		CHECK(line.Location().IsEqual(Axis2().Location(), 0.001));
		CHECK(line.Direction().IsEqual(Axis2().Direction(), 1e-5 * ONE_RADIAN));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] Derived Scaled(const PointT<double, DIM>& point, double scale)	 @return The scaled line
	 @param scale The scale value
	 @param point The scaling center point
	 @brief Get the line scaled by a point
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <math/LineT.hpp>
#include <modeling/MakeEdge2d.hpp>
using AMCAX::Line2;
#define ONE_RADIAN (M_PI / 180.)
TEST_CASE("case2: Line base method Test", "[math][Line2][p1]")
{
	SECTION("Scale")
	{
		Line2 line(Point2(0., -1.), Direction2());
		Point2 point;
		double distance = line.Distance(point);
		Line2 lineScale1 = line.Scaled(point, 1.1);
		CHECK(lineScale1.Distance(point) > distance);
		CHECK(lineScale1.Contains(Point2(0., -1.1), 1e-5));
		Line2 lineScale2 = line.Scaled(point, 1.);
		CHECK(lineScale2.Distance(point) == Approx(distance).margin(1e-5));
		CHECK(lineScale2.Contains(Point2(0., -1.), 1e-5));
		Line2 lineScale3 = line.Scaled(point, 0.8);
		CHECK(lineScale3.Distance(point) < distance);
		CHECK(lineScale3.Contains(Point2(0., -0.8), 1e-5));
		Line2 lineScale4 = line.Scaled(point, 0.);
		line.SetDirection(Direction2(-1.0, 4.0));
		Line2 lineScale5 = line.Scaled(Point2(-1., 2.), 0.);
		CHECK(lineScale4.Contains(Point2(0., 0.), 1e-5));
		CHECK(lineScale4.Direction().IsEqual(Direction2(), 1e-6 * ONE_RADIAN));
		CHECK(lineScale5.Contains(Point2(-1., 2.), 1e-5));
		CHECK(lineScale5.Direction().IsEqual(Direction2(-1., 4.), 1e-6 * ONE_RADIAN));
		Line2 lineScale6 = line.Scaled(point, -1.);
		CHECK(lineScale6.Direction().IsEqual(Direction2(1., -4.), 1e-5 * ONE_RADIAN));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":Derived& Translate(const VectorT<double, DIM>& vec)	 @return The reference to self
	 @param vec The translation vector
	 @brief Translate the line by a vector
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <math/LineT.hpp>
#include <modeling/MakeEdge2d.hpp>
using AMCAX::Line2;
#define ONE_RADIAN (M_PI / 180.)
TEST_CASE("case2: Line base method Test", "[math][Line2][p1]")
{
	SECTION("Translate Test")
	{
		Line2 line;
		line.Translate(Vector2(2., 0.));  
		CHECK(line.Direction().IsEqual(Direction2(), 1e-5 * ONE_RADIAN));
		CHECK(line.Contains(Point2(2., 0.), 1e-5));
		Line2 translateLine = line.Translated(Point2(2., 0.), Point2(-10., 0.));
		CHECK(translateLine.Contains(Point2(-10., 0.), 1e-5));
	}
}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] Derived Translated(const PointT<double, DIM>& p1, const PointT<double, DIM>& p2)	 @return The translated line
	 @param p2 The target point
	 @param p1 The source point
	 @brief Get the line translated by a vector from a point to another point
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <math/LineT.hpp>
#include <modeling/MakeEdge2d.hpp>
using AMCAX::Line2;
#define ONE_RADIAN (M_PI / 180.)
TEST_CASE("case2: Line base method Test", "[math][Line2][p1]")
{
	SECTION("Translate Test")
	{
		Line2 line;
		line.Translate(Vector2(2., 0.));  
		CHECK(line.Direction().IsEqual(Direction2(), 1e-5 * ONE_RADIAN));
		CHECK(line.Contains(Point2(2., 0.), 1e-5));
		Line2 translateLine = line.Translated(Point2(2., 0.), Point2(-10., 0.));
		CHECK(translateLine.Contains(Point2(-10., 0.), 1e-5));
	}
}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":void SetLocation(const PointT<double, DIM>& point)	 @param point The location point
	 @brief Set the location of the line
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <math/LineT.hpp>
#include <modeling/MakeEdge2d.hpp>
using AMCAX::Line2;
#define ONE_RADIAN (M_PI / 180.)
TEST_CASE("case2: Line base method Test", "[math][Line2][p1]")
{
	SECTION("SetLocation")
	{
		Line2 line(Point2(0., 0.), Direction2(1., 1.));  
		CHECK(line.Location().IsEqual(Point2(), 1e-5));
		line.SetLocation(Point2(2., 1.));  
		CHECK(line.Location().IsEqual(Point2(2., 1.), 1e-5));
		double a, b, c;
		line.Coefficients(a, b, c);
		CHECK(a == Approx(1. / std::sqrt(2)).margin(1e-5));
		CHECK(b == Approx(-1. / std::sqrt(2)).margin(1e-5));
		CHECK(c == Approx(-1. / std::sqrt(2)).margin(1e-5));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":void SetDirection(const DirectionT<double, DIM>& dir)	 @param dir The line direction
	 @brief Set the line direction
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <math/LineT.hpp>
#include <modeling/MakeEdge2d.hpp>
using AMCAX::Line2;
#define ONE_RADIAN (M_PI / 180.)
TEST_CASE("case2: Line base method Test", "[math][Line2][p1]")
{
	SECTION("SetDirection")
	{
		Line2 line(Point2(), Direction2(1., 1.));  
		CHECK(line.Direction().IsEqual(Direction2(1., 1.), 1e-5 * ONE_RADIAN));
		CHECK(line.Distance(Point2(1., 2.)) > 0.);
		line.SetDirection(Direction2(1., 2.));  
		CHECK(line.Direction().IsEqual(Direction2(1., 2.), 1e-5 * ONE_RADIAN));
		CHECK(line.Distance(Point2(1., 2.)) == Approx(0.).margin(1e-5));
		double a, b, c;
		line.Coefficients(a, b, c);
		CHECK(a == Approx(2. / std::sqrt(5)).margin(1e-5));
		CHECK(b == Approx(-1. / std::sqrt(5)).margin(1e-5));
		CHECK(c == Approx(0. / std::sqrt(5)).margin(1e-5));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":void SetPosition(const AxisT<double, DIM>& axis)	 @param axis The axis
	 @brief Set the axis of the line
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <math/LineT.hpp>
#include <modeling/MakeEdge2d.hpp>
using AMCAX::Line2;
#define ONE_RADIAN (M_PI / 180.)
TEST_CASE("case2: Line base method Test", "[math][Line2][p1]")
{
	SECTION("SetPosition")
	{
		Line2 line;
		CHECK(line.Location().IsEqual(Point2(0., 0.), 1e-5));
		CHECK(line.Direction().IsEqual(Direction2(1., 0.), 1e-5 * ONE_RADIAN));
		Axis2 axis(Point2(2., 1.), Direction2(1., 1.));
		line.SetPosition(axis);  
		double a, b, c;
		line.Coefficients(a, b, c);
		CHECK(a == Approx(1. / std::sqrt(2)).margin(1e-5));
		CHECK(b == Approx(-1. / std::sqrt(2)).margin(1e-5));
		CHECK(c == Approx(-1. / std::sqrt(2)).margin(1e-5));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] const DirectionT<double, DIM>& Direction()	 @return The direction of the line
	 @brief Get the direction of the line
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <math/LineT.hpp>
#include <modeling/MakeEdge2d.hpp>
using AMCAX::Line2;
#define ONE_RADIAN (M_PI / 180.)
TEST_CASE("case2: Line base method Test", "[math][Line2][p1]")
{
	SECTION("Translate Test")
	{
		Line2 line;
		line.Translate(Vector2(2., 0.));  
		CHECK(line.Direction().IsEqual(Direction2(), 1e-5 * ONE_RADIAN));
		CHECK(line.Contains(Point2(2., 0.), 1e-5));
		Line2 translateLine = line.Translated(Point2(2., 0.), Point2(-10., 0.));
		CHECK(translateLine.Contains(Point2(-10., 0.), 1e-5));
	}
}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] auto Angle(const LineBase& other)	 @return The angle between the line and the other line
	 @param other The other line
	 @brief Compute the angle between the line and the other line
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <math/LineT.hpp>
#include <modeling/MakeEdge2d.hpp>
using AMCAX::Line2;
#define ONE_RADIAN (M_PI / 180.)
TEST_CASE("case2: Line base method Test", "[math][Line2][p1]")
{
	SECTION("Angle")
	{
		Line2 line;
		Line2 line2(Point2(), Direction2(0., 1.));
		CHECK(line.Angle(line2) == Approx(M_PI_2));
		CHECK(line2.Angle(line) == Approx(-M_PI_2));
		Line2 line3(Point2(), Direction2(2., 3.));
		Line2 line4(Point2(), Direction2(5., -8.));
		CHECK(line4.Angle(line3) == Approx(
			std::acos((2. * 5. + 3. * (-8.)) / (std::sqrt(4. + 9.) * std::sqrt(25. + 64.)))
		).margin(1e-5 * ONE_RADIAN));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":Derived& Reverse()	 @return The reference to self
	 @brief Reverse the line direction
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <math/LineT.hpp>
#include <modeling/MakeEdge2d.hpp>
using AMCAX::Line2;
#define ONE_RADIAN (M_PI / 180.)
TEST_CASE("case2: Line base method Test", "[math][Line2][p1]")
{
	SECTION("Reverse")
	{
		Line2 line;
		line.Reverse();
		CHECK(line.Direction().IsEqual(Direction2(-1., 0.), 1e-5 * ONE_RADIAN));
		Line2 line2(Point2(), Direction2(-3., 98.));
		line2.Reverse();
		CHECK(line2.Direction().IsEqual(Direction2(3., -98.), 1e-5 * ONE_RADIAN));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":LineS(double a, double b, double c)	 @param a,b,c The coefficients
	 @brief Construct from the algebraic coefficients of 2D line
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <math/LineT.hpp>
#include <modeling/MakeEdge2d.hpp>
using AMCAX::Line2;
#define ONE_RADIAN (M_PI / 180.)
TEST_CASE("case1: Line basic interface test", "[math][Line2][p1]")
{
	SECTION("Parameterized constructor test")
	{
		Line2 line1(Axis2(Point2(1., 0.), Direction2(2., 1.)));
		Line2 line2(Point2(1., 0.), Direction2(2., 1.));  
		Line2 line3(1, -2, -1);
		double a, b, c;
		line1.Coefficients(a, b, c);
		CHECK(a == Approx(1.0 / std::sqrt(5)));
		CHECK(b == Approx(-2.0 / std::sqrt(5)));
		CHECK(c == Approx(-1.0 / std::sqrt(5)));
		line2.Coefficients(a, b, c);
		CHECK(a == Approx(1.0 / std::sqrt(5)));
		CHECK(b == Approx(-2.0 / std::sqrt(5)));
		CHECK(c == Approx(-1.0 / std::sqrt(5)));
		line3.Coefficients(a, b, c);
		CHECK(a == Approx(1.0 / std::sqrt(5)));
		CHECK(b == Approx(-2.0 / std::sqrt(5)));
		CHECK(c == Approx(-1.0 / std::sqrt(5)));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":void Coefficients(double& a, double& b, double& c)	 @param[out] a,b,c The coefficients
	 @brief The coefficients of the algebraic representation of the 2D line
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <math/LineT.hpp>
#include <modeling/MakeEdge2d.hpp>
using AMCAX::Line2;
#define ONE_RADIAN (M_PI / 180.)
TEST_CASE("case1: Line basic interface test", "[math][Line2][p1]")
{
	SECTION("Parameterized constructor test")
	{
		Line2 line1(Axis2(Point2(1., 0.), Direction2(2., 1.)));
		Line2 line2(Point2(1., 0.), Direction2(2., 1.));  
		Line2 line3(1, -2, -1);
		double a, b, c;
		line1.Coefficients(a, b, c);
		CHECK(a == Approx(1.0 / std::sqrt(5)));
		CHECK(b == Approx(-2.0 / std::sqrt(5)));
		CHECK(c == Approx(-1.0 / std::sqrt(5)));
		line2.Coefficients(a, b, c);
		CHECK(a == Approx(1.0 / std::sqrt(5)));
		CHECK(b == Approx(-2.0 / std::sqrt(5)));
		CHECK(c == Approx(-1.0 / std::sqrt(5)));
		line3.Coefficients(a, b, c);
		CHECK(a == Approx(1.0 / std::sqrt(5)));
		CHECK(b == Approx(-2.0 / std::sqrt(5)));
		CHECK(c == Approx(-1.0 / std::sqrt(5)));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] auto Distance(const Point2& p)	 @return The distance between the point and the line
	 @param p The point
	 @brief Compute the distance from a point to the line
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <math/LineT.hpp>
#include <modeling/MakeEdge2d.hpp>
using AMCAX::Line2;
#define ONE_RADIAN (M_PI / 180.)
TEST_CASE("case2: Line base method Test", "[math][Line2][p1]")
{
	SECTION("SetDirection")
	{
		Line2 line(Point2(), Direction2(1., 1.));  
		CHECK(line.Direction().IsEqual(Direction2(1., 1.), 1e-5 * ONE_RADIAN));
		CHECK(line.Distance(Point2(1., 2.)) > 0.);
		line.SetDirection(Direction2(1., 2.));  
		CHECK(line.Direction().IsEqual(Direction2(1., 2.), 1e-5 * ONE_RADIAN));
		CHECK(line.Distance(Point2(1., 2.)) == Approx(0.).margin(1e-5));
		double a, b, c;
		line.Coefficients(a, b, c);
		CHECK(a == Approx(2. / std::sqrt(5)).margin(1e-5));
		CHECK(b == Approx(-1. / std::sqrt(5)).margin(1e-5));
		CHECK(c == Approx(0. / std::sqrt(5)).margin(1e-5));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] auto SquaredDistance(const Point2& p)	 @return The squared distance between the point and the line
	 @param p The point
	 @brief Compute the squared distance from a point to the line
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <math/LineT.hpp>
#include <modeling/MakeEdge2d.hpp>
using AMCAX::Line2;
#define ONE_RADIAN (M_PI / 180.)
TEST_CASE("case1: Line basic interface test", "[math][Line2][p1]")
{
	SECTION("Distance and SquaredDistance test")
	{
		auto pointToLine = [](const Point2& point, const Line2& line) {
			double a, b, c;
			line.Coefficients(a, b, c);
			return std::fabs(a * point.X() + b * point.Y() + c);
		};
		auto lineToLine = [](const Line2& line1, const Line2& line2) {
			double a1, b1, c1, a2, b2, c2;
			line1.Coefficients(a1, b1, c1);
			line2.Coefficients(a2, b2, c2);
			if (a1 != a2 || b1 != b2) return 0.;
			return std::fabs(c1 - c2);
		};
		Line2 line(3., 4., -30.);
		Point2 point1(6., 3.);
		Point2 point2(6., 2.);
		Line2 line2(3., 4., -29.);
		Line2 line3(2., 1., -99.);
		CHECK(line.Distance(point1) == Approx(pointToLine(point1, line)).margin(0.01));
		CHECK(line.SquaredDistance(point1) == Approx(pointToLine(point1, line) * pointToLine(point1, line)).margin(0.01));
		CHECK(line.Distance(point2) == Approx(pointToLine(point2, line)));
		CHECK(line.SquaredDistance(point2) == Approx(pointToLine(point2, line) * pointToLine(point2, line)).margin(0.01));
		CHECK(line.Distance(line2) == Approx(lineToLine(line, line2)));
		CHECK(line.SquaredDistance(line2) == Approx(lineToLine(line2, line) * lineToLine(line2, line)).margin(0.01));
		CHECK(line.Distance(line3) == Approx(lineToLine(line, line3)));
		CHECK(line.SquaredDistance(line3) == Approx(lineToLine(line3, line) * lineToLine(line3, line)).margin(0.01));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] auto SquaredDistance(const LineS& l)	 @return The squared distance between two lines
	 @param l The other line
	 @brief Compute the squared distance between two lines
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <math/LineT.hpp>
#include <modeling/MakeEdge2d.hpp>
using AMCAX::Line2;
#define ONE_RADIAN (M_PI / 180.)
TEST_CASE("case1: Line basic interface test", "[math][Line2][p1]")
{
	SECTION("Distance and SquaredDistance test")
	{
		auto pointToLine = [](const Point2& point, const Line2& line) {
			double a, b, c;
			line.Coefficients(a, b, c);
			return std::fabs(a * point.X() + b * point.Y() + c);
		};
		auto lineToLine = [](const Line2& line1, const Line2& line2) {
			double a1, b1, c1, a2, b2, c2;
			line1.Coefficients(a1, b1, c1);
			line2.Coefficients(a2, b2, c2);
			if (a1 != a2 || b1 != b2) return 0.;
			return std::fabs(c1 - c2);
		};
		Line2 line(3., 4., -30.);
		Point2 point1(6., 3.);
		Point2 point2(6., 2.);
		Line2 line2(3., 4., -29.);
		Line2 line3(2., 1., -99.);
		CHECK(line.Distance(point1) == Approx(pointToLine(point1, line)).margin(0.01));
		CHECK(line.SquaredDistance(point1) == Approx(pointToLine(point1, line) * pointToLine(point1, line)).margin(0.01));
		CHECK(line.Distance(point2) == Approx(pointToLine(point2, line)));
		CHECK(line.SquaredDistance(point2) == Approx(pointToLine(point2, line) * pointToLine(point2, line)).margin(0.01));
		CHECK(line.Distance(line2) == Approx(lineToLine(line, line2)));
		CHECK(line.SquaredDistance(line2) == Approx(lineToLine(line2, line) * lineToLine(line2, line)).margin(0.01));
		CHECK(line.Distance(line3) == Approx(lineToLine(line, line3)));
		CHECK(line.SquaredDistance(line3) == Approx(lineToLine(line3, line) * lineToLine(line3, line)).margin(0.01));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] LineS Normal(const Point2& p)	 @return The line passing through a point and perpendicular to the line
	 @param p The point
	 @brief Get a line passing through a point and perpendicular to the line
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <math/LineT.hpp>
#include <modeling/MakeEdge2d.hpp>
using AMCAX::Line2;
#define ONE_RADIAN (M_PI / 180.)
TEST_CASE("case1: Line basic interface test", "[math][Line2][p1]")
{
	SECTION("Normal Test")
	{
		Line2 line(3., 4., 5.);  
		Line2 normalLine = line.Normal(Point2(1., 5.));
		double a, b, c;
		normalLine.Coefficients(a, b, c);
		CHECK((a * 3 + b * 4) == Approx(0.0).margin(0.1));
		CHECK((a * 1 + b * 5 + c) == Approx(0.0).margin(0.1));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":LineS& Rotate(const Point2& point, double angle)	 @return The reference to self
	 @param angle The rotation angle
	 @param point The rotation center point
	 @brief Rotate the line around a point with an angle in 2D
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <math/LineT.hpp>
#include <modeling/MakeEdge2d.hpp>
using AMCAX::Line2;
#define ONE_RADIAN (M_PI / 180.)
TEST_CASE("case1: Line basic interface test", "[math][Line2][p1]")
{
	SECTION("Rotate Test")
	{
		Line2 line(Point2(0., 1.), Direction2(1., 1.));  
		Line2 line2(Point2(0., 1.), Direction2(1., 1.));  
		line.Rotate(Point2(), (5. / 4) * M_PI);  
		CHECK(line.Direction().X() == Approx(0.).margin(1e-5));
		CHECK(line.Direction().Y() == Approx(-1.).margin(1e-5));
		double a, b, c;
		line.Coefficients(a, b, c);
		CHECK((a + c) == Approx(0.).margin(0.5));
		CHECK(line2.Distance(Point2()) == line.Distance(Point2()));  
		CHECK(line.Contains(Point2(std::sqrt(2.) / 2., 0.), 1e-6) == true);
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] LineS Rotated(const Point2& point, double angle)	 @return The rotated line
	 @param angle The rotation angle
	 @param point The rotation center point
	 @brief Get the line rotated around a point with an angle in 2D
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <math/LineT.hpp>
#include <modeling/MakeEdge2d.hpp>
using AMCAX::Line2;
#define ONE_RADIAN (M_PI / 180.)
TEST_CASE("case1: Line basic interface test", "[math][Line2][p1]")
{
	SECTION("Rotated Test")
	{
		Line2 line(Point2(0., 1.), Direction2(1., 1.));  
		Line2 rotateLine = line.Rotated(Point2(), (3. / 4) * M_PI);  
		CHECK(rotateLine.Direction().X() == Approx(-1.).margin(1e-5));
		CHECK(rotateLine.Direction().Y() == Approx(0.).margin(1e-5));
		double a, b, c;
		rotateLine.Coefficients(a, b, c);
		CHECK((c - b) == Approx(0.).margin(0.5));
		CHECK(line.Distance(Point2()) == rotateLine.Distance(Point2()));  
		TopoShape lineShape1 = MakeEdge2d(line);
		TopoShape lineShape2 = MakeEdge2d(rotateLine);
		REQUIRE(OCCTIO::OCCTTool::Write(lineShape1, OUTPUT_PATH_PREFIX"Line2_Rotated_before_p1.brep"));
		REQUIRE(OCCTIO::OCCTTool::Write(lineShape2, OUTPUT_PATH_PREFIX"Line2_Rotated_later_p1.brep"));
	}
}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] auto Distance(const Point3& p)	 @return The distance between the point and the line
	 @param p The point
	 @brief Compute the distance from a point to the line
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <math/LineT.hpp>
#include <modeling/MakeEdge2d.hpp>
using AMCAX::Line2;
#define ONE_RADIAN (M_PI / 180.)
TEST_CASE("case2: Line base method Test", "[math][Line2][p1]")
{
	SECTION("Scale")
	{
		Line2 line(Point2(0., -1.), Direction2());
		Point2 point;
		double distance = line.Distance(point);
		Line2 lineScale1 = line.Scaled(point, 1.1);
		CHECK(lineScale1.Distance(point) > distance);
		CHECK(lineScale1.Contains(Point2(0., -1.1), 1e-5));
		Line2 lineScale2 = line.Scaled(point, 1.);
		CHECK(lineScale2.Distance(point) == Approx(distance).margin(1e-5));
		CHECK(lineScale2.Contains(Point2(0., -1.), 1e-5));
		Line2 lineScale3 = line.Scaled(point, 0.8);
		CHECK(lineScale3.Distance(point) < distance);
		CHECK(lineScale3.Contains(Point2(0., -0.8), 1e-5));
		Line2 lineScale4 = line.Scaled(point, 0.);
		line.SetDirection(Direction2(-1.0, 4.0));
		Line2 lineScale5 = line.Scaled(Point2(-1., 2.), 0.);
		CHECK(lineScale4.Contains(Point2(0., 0.), 1e-5));
		CHECK(lineScale4.Direction().IsEqual(Direction2(), 1e-6 * ONE_RADIAN));
		CHECK(lineScale5.Contains(Point2(-1., 2.), 1e-5));
		CHECK(lineScale5.Direction().IsEqual(Direction2(-1., 4.), 1e-6 * ONE_RADIAN));
		Line2 lineScale6 = line.Scaled(point, -1.);
		CHECK(lineScale6.Direction().IsEqual(Direction2(1., -4.), 1e-5 * ONE_RADIAN));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] auto SquaredDistance(const Point3& p)	 @return The squared distance between the point and the line
	 @param p The point
	 @brief Compute the squared distance from a point to the line
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <math/LineT.hpp>
#include <modeling/MakeEdge2d.hpp>
using AMCAX::Line2;
#define ONE_RADIAN (M_PI / 180.)
TEST_CASE("case1: Line basic interface test", "[math][Line2][p1]")
{
	SECTION("Distance and SquaredDistance test")
	{
		auto pointToLine = [](const Point2& point, const Line2& line) {
			double a, b, c;
			line.Coefficients(a, b, c);
			return std::fabs(a * point.X() + b * point.Y() + c);
		};
		auto lineToLine = [](const Line2& line1, const Line2& line2) {
			double a1, b1, c1, a2, b2, c2;
			line1.Coefficients(a1, b1, c1);
			line2.Coefficients(a2, b2, c2);
			if (a1 != a2 || b1 != b2) return 0.;
			return std::fabs(c1 - c2);
		};
		Line2 line(3., 4., -30.);
		Point2 point1(6., 3.);
		Point2 point2(6., 2.);
		Line2 line2(3., 4., -29.);
		Line2 line3(2., 1., -99.);
		CHECK(line.Distance(point1) == Approx(pointToLine(point1, line)).margin(0.01));
		CHECK(line.SquaredDistance(point1) == Approx(pointToLine(point1, line) * pointToLine(point1, line)).margin(0.01));
		CHECK(line.Distance(point2) == Approx(pointToLine(point2, line)));
		CHECK(line.SquaredDistance(point2) == Approx(pointToLine(point2, line) * pointToLine(point2, line)).margin(0.01));
		CHECK(line.Distance(line2) == Approx(lineToLine(line, line2)));
		CHECK(line.SquaredDistance(line2) == Approx(lineToLine(line2, line) * lineToLine(line2, line)).margin(0.01));
		CHECK(line.Distance(line3) == Approx(lineToLine(line, line3)));
		CHECK(line.SquaredDistance(line3) == Approx(lineToLine(line3, line) * lineToLine(line3, line)).margin(0.01));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API ComputePointsAbscissa(double tol, const Adaptor3Curve& c, double abscissa, double u0)	 @param u0 The starting parameter
	 @param abscissa The arc length
	 @param c The curve
	 @param tol The tolerance
	 @brief Compute the parameter of a point on a 3D curve with given arc length and a tolerance
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <geometry/MakeGeom2Circle.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/ComputePointsAbscissa.hpp>
#include <geometry/MakeGeom2Hyperbola.hpp>
#include <modeling/MakeEdge.hpp>
#include <geometry/GeometryTool.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/MakeGeom2Ellipse.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/AdaptorGeom3Curve.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <geometry/MakeGeom3Hyperbola.hpp>
#include <geometry/MakeGeom3Ellipse.hpp>
TEST_CASE("bug2: ComputePointsAbscissa ", "[geometry][ComputePointsAbscissa][fixbug]")
{
	SECTION("arc length and tolerance-3D")
{
    Frame3 frame;
    double major = 5.0;
    double minor = 4.0;
    bool isRight = true;
    std::shared_ptr< Geom3Hyperbola >h1 = MakeGeom3Hyperbola(frame, major, minor);
    AdaptorGeom3Curve hyperbola(h1);
    ComputePointsAbscissa cpa3(Precision::Confusion(), hyperbola, 1.0, 0.0);
    double param3 = cpa3.Parameter();
    Point3 point1(hyperbola.Value(param3));
    CHECK(cpa3.Parameter());
    MakeEdge edge1(h1, 0.0, param3);
    CHECK(BRepClassificationTools::IsPointInOnEdge(edge1, point1, 0.001) == true);
}}
}
,