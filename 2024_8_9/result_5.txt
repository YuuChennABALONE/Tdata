{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API MakeFace(const std::shared_ptr<Geom3Surface>& s, double tolDegen)	 @param tolDegen The tolerance
	 @param s The surface
	 @brief Construct from a surface with tolerance for degenerated edges
,
 "output":#include <catch.hpp>
#include "testHelper.h"
#include<iostream>
#include <common/PointT.hpp>
#include <topology/TopoEdge.hpp>
#include <modeling/MakeWire.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <topology/TopoWire.hpp>
#include <topology/TopoShape.hpp>
#include <topology/TopoFace.hpp>
#include <modeling/MakeFace.hpp>
AMCAX::TopoFace crashbug1() {
    double h1 = 7., h2 = 3.;
    AMCAX::Point2 p1(0., h1 / 2.0), p2(30., h2 / 2.0), p3(30., -h2 / 2.0), p4(0., -h1 / 2.0);
    std::vector<AMCAX::Point2> v_p;
    v_p.push_back(p1);
    v_p.push_back(p2);
    v_p.push_back(p3);
    v_p.push_back(p4);
    AMCAX::TopoEdge e;
    std::list<AMCAX::TopoShape> edges_polygon;
    for (int i = 1; i < v_p.size(); i++) {
        e = AMCAX::MakeEdge2d(v_p[i - 1], v_p[i]);
        edges_polygon.push_back(e);
    }
    e = AMCAX::MakeEdge2d(v_p[3], v_p[0]);
    edges_polygon.push_back(e);
    AMCAX::MakeWire mkw;
    mkw.Add(edges_polygon);
    AMCAX::TopoWire w_poly = mkw;
    AMCAX::TopoFace f_poly = AMCAX::MakeFace(w_poly, true);
    return f_poly;
}
#include <catch.hpp>
#include "testHelper.h"
#include<iostream>
#include <common/PointT.hpp>
#include <topology/TopoEdge.hpp>
#include <modeling/MakeWire.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <topology/TopoWire.hpp>
#include <topology/TopoShape.hpp>
#include <topology/TopoFace.hpp>
#include <modeling/MakeFace.hpp>
AMCAX::TopoFace crashbug1() {
    double h1 = 7., h2 = 3.;
    AMCAX::Point2 p1(0., h1 / 2.0), p2(30., h2 / 2.0), p3(30., -h2 / 2.0), p4(0., -h1 / 2.0);
    std::vector<AMCAX::Point2> v_p;
    v_p.push_back(p1);
    v_p.push_back(p2);
    v_p.push_back(p3);
    v_p.push_back(p4);
    AMCAX::TopoEdge e;
    std::list<AMCAX::TopoShape> edges_polygon;
    for (int i = 1; i < v_p.size(); i++) {
        e = AMCAX::MakeEdge2d(v_p[i - 1], v_p[i]);
        edges_polygon.push_back(e);
    }
    e = AMCAX::MakeEdge2d(v_p[3], v_p[0]);
    edges_polygon.push_back(e);
    AMCAX::MakeWire mkw;
    mkw.Add(edges_polygon);
    AMCAX::TopoWire w_poly = mkw;
    AMCAX::TopoFace f_poly = AMCAX::MakeFace(w_poly, true);
    return f_poly;
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API explicit MakeFace(const TopoWire& w, bool onlyPlane = false)	 @param onlyPlane If true, the surface will be a plane
	 @param w The wire
	 @brief Construct from a wire
,
 "output":#include <catch.hpp>
#include "testHelper.h"
#include<iostream>
#include <common/PointT.hpp>
#include <topology/TopoEdge.hpp>
#include <modeling/MakeWire.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <topology/TopoWire.hpp>
#include <topology/TopoShape.hpp>
#include <topology/TopoFace.hpp>
#include <modeling/MakeFace.hpp>
AMCAX::TopoFace crashbug1() {
    double h1 = 7., h2 = 3.;
    AMCAX::Point2 p1(0., h1 / 2.0), p2(30., h2 / 2.0), p3(30., -h2 / 2.0), p4(0., -h1 / 2.0);
    std::vector<AMCAX::Point2> v_p;
    v_p.push_back(p1);
    v_p.push_back(p2);
    v_p.push_back(p3);
    v_p.push_back(p4);
    AMCAX::TopoEdge e;
    std::list<AMCAX::TopoShape> edges_polygon;
    for (int i = 1; i < v_p.size(); i++) {
        e = AMCAX::MakeEdge2d(v_p[i - 1], v_p[i]);
        edges_polygon.push_back(e);
    }
    e = AMCAX::MakeEdge2d(v_p[3], v_p[0]);
    edges_polygon.push_back(e);
    AMCAX::MakeWire mkw;
    mkw.Add(edges_polygon);
    AMCAX::TopoWire w_poly = mkw;
    AMCAX::TopoFace f_poly = AMCAX::MakeFace(w_poly, true);
    return f_poly;
}
#include <catch.hpp>
#include "testHelper.h"
#include<iostream>
#include <common/PointT.hpp>
#include <topology/TopoEdge.hpp>
#include <modeling/MakeWire.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <topology/TopoWire.hpp>
#include <topology/TopoShape.hpp>
#include <topology/TopoFace.hpp>
#include <modeling/MakeFace.hpp>
AMCAX::TopoFace crashbug1() {
    double h1 = 7., h2 = 3.;
    AMCAX::Point2 p1(0., h1 / 2.0), p2(30., h2 / 2.0), p3(30., -h2 / 2.0), p4(0., -h1 / 2.0);
    std::vector<AMCAX::Point2> v_p;
    v_p.push_back(p1);
    v_p.push_back(p2);
    v_p.push_back(p3);
    v_p.push_back(p4);
    AMCAX::TopoEdge e;
    std::list<AMCAX::TopoShape> edges_polygon;
    for (int i = 1; i < v_p.size(); i++) {
        e = AMCAX::MakeEdge2d(v_p[i - 1], v_p[i]);
        edges_polygon.push_back(e);
    }
    e = AMCAX::MakeEdge2d(v_p[3], v_p[0]);
    edges_polygon.push_back(e);
    AMCAX::MakeWire mkw;
    mkw.Add(edges_polygon);
    AMCAX::TopoWire w_poly = mkw;
    AMCAX::TopoFace f_poly = AMCAX::MakeFace(w_poly, true);
    return f_poly;
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API MakeFace(const Plane& p, const TopoWire& w, bool inside = true)	 @param inside Whether the face is inside the wire
	 @param w The wire
	 @param p The plane
	 @brief Construct from a plane and a wire
,
 "output":#include <catch.hpp>
#include "testHelper.h"
#include<iostream>
#include <common/PointT.hpp>
#include <topology/TopoEdge.hpp>
#include <modeling/MakeWire.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <topology/TopoWire.hpp>
#include <topology/TopoShape.hpp>
#include <topology/TopoFace.hpp>
#include <modeling/MakeFace.hpp>
AMCAX::TopoFace crashbug1() {
    double h1 = 7., h2 = 3.;
    AMCAX::Point2 p1(0., h1 / 2.0), p2(30., h2 / 2.0), p3(30., -h2 / 2.0), p4(0., -h1 / 2.0);
    std::vector<AMCAX::Point2> v_p;
    v_p.push_back(p1);
    v_p.push_back(p2);
    v_p.push_back(p3);
    v_p.push_back(p4);
    AMCAX::TopoEdge e;
    std::list<AMCAX::TopoShape> edges_polygon;
    for (int i = 1; i < v_p.size(); i++) {
        e = AMCAX::MakeEdge2d(v_p[i - 1], v_p[i]);
        edges_polygon.push_back(e);
    }
    e = AMCAX::MakeEdge2d(v_p[3], v_p[0]);
    edges_polygon.push_back(e);
    AMCAX::MakeWire mkw;
    mkw.Add(edges_polygon);
    AMCAX::TopoWire w_poly = mkw;
    AMCAX::TopoFace f_poly = AMCAX::MakeFace(w_poly, true);
    return f_poly;
}
#include <catch.hpp>
#include "testHelper.h"
#include<iostream>
#include <common/PointT.hpp>
#include <topology/TopoEdge.hpp>
#include <modeling/MakeWire.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <topology/TopoWire.hpp>
#include <topology/TopoShape.hpp>
#include <topology/TopoFace.hpp>
#include <modeling/MakeFace.hpp>
AMCAX::TopoFace crashbug1() {
    double h1 = 7., h2 = 3.;
    AMCAX::Point2 p1(0., h1 / 2.0), p2(30., h2 / 2.0), p3(30., -h2 / 2.0), p4(0., -h1 / 2.0);
    std::vector<AMCAX::Point2> v_p;
    v_p.push_back(p1);
    v_p.push_back(p2);
    v_p.push_back(p3);
    v_p.push_back(p4);
    AMCAX::TopoEdge e;
    std::list<AMCAX::TopoShape> edges_polygon;
    for (int i = 1; i < v_p.size(); i++) {
        e = AMCAX::MakeEdge2d(v_p[i - 1], v_p[i]);
        edges_polygon.push_back(e);
    }
    e = AMCAX::MakeEdge2d(v_p[3], v_p[0]);
    edges_polygon.push_back(e);
    AMCAX::MakeWire mkw;
    mkw.Add(edges_polygon);
    AMCAX::TopoWire w_poly = mkw;
    AMCAX::TopoFace f_poly = AMCAX::MakeFace(w_poly, true);
    return f_poly;
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API MakeFace(const Cylinder& c, const TopoWire& w, bool inside = true)	 @param inside Whether the face is inside the wire
	 @param w The wire
	 @param c The cylinder
	 @brief Construct from a cylinder and a wire
,
 "output":#include <catch.hpp>
#include "testHelper.h"
#include<iostream>
#include <common/PointT.hpp>
#include <topology/TopoEdge.hpp>
#include <modeling/MakeWire.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <topology/TopoWire.hpp>
#include <topology/TopoShape.hpp>
#include <topology/TopoFace.hpp>
#include <modeling/MakeFace.hpp>
AMCAX::TopoFace crashbug1() {
    double h1 = 7., h2 = 3.;
    AMCAX::Point2 p1(0., h1 / 2.0), p2(30., h2 / 2.0), p3(30., -h2 / 2.0), p4(0., -h1 / 2.0);
    std::vector<AMCAX::Point2> v_p;
    v_p.push_back(p1);
    v_p.push_back(p2);
    v_p.push_back(p3);
    v_p.push_back(p4);
    AMCAX::TopoEdge e;
    std::list<AMCAX::TopoShape> edges_polygon;
    for (int i = 1; i < v_p.size(); i++) {
        e = AMCAX::MakeEdge2d(v_p[i - 1], v_p[i]);
        edges_polygon.push_back(e);
    }
    e = AMCAX::MakeEdge2d(v_p[3], v_p[0]);
    edges_polygon.push_back(e);
    AMCAX::MakeWire mkw;
    mkw.Add(edges_polygon);
    AMCAX::TopoWire w_poly = mkw;
    AMCAX::TopoFace f_poly = AMCAX::MakeFace(w_poly, true);
    return f_poly;
}
#include <catch.hpp>
#include "testHelper.h"
#include<iostream>
#include <common/PointT.hpp>
#include <topology/TopoEdge.hpp>
#include <modeling/MakeWire.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <topology/TopoWire.hpp>
#include <topology/TopoShape.hpp>
#include <topology/TopoFace.hpp>
#include <modeling/MakeFace.hpp>
AMCAX::TopoFace crashbug1() {
    double h1 = 7., h2 = 3.;
    AMCAX::Point2 p1(0., h1 / 2.0), p2(30., h2 / 2.0), p3(30., -h2 / 2.0), p4(0., -h1 / 2.0);
    std::vector<AMCAX::Point2> v_p;
    v_p.push_back(p1);
    v_p.push_back(p2);
    v_p.push_back(p3);
    v_p.push_back(p4);
    AMCAX::TopoEdge e;
    std::list<AMCAX::TopoShape> edges_polygon;
    for (int i = 1; i < v_p.size(); i++) {
        e = AMCAX::MakeEdge2d(v_p[i - 1], v_p[i]);
        edges_polygon.push_back(e);
    }
    e = AMCAX::MakeEdge2d(v_p[3], v_p[0]);
    edges_polygon.push_back(e);
    AMCAX::MakeWire mkw;
    mkw.Add(edges_polygon);
    AMCAX::TopoWire w_poly = mkw;
    AMCAX::TopoFace f_poly = AMCAX::MakeFace(w_poly, true);
    return f_poly;
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API MakeFace(const Cone& c, const TopoWire& w, bool inside = true)	 @param inside Whether the face is inside the wire
	 @param w The wire
	 @param c The cone
	 @brief Construct from a cone and a wire
,
 "output":#include <catch.hpp>
#include "testHelper.h"
#include<iostream>
#include <common/PointT.hpp>
#include <topology/TopoEdge.hpp>
#include <modeling/MakeWire.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <topology/TopoWire.hpp>
#include <topology/TopoShape.hpp>
#include <topology/TopoFace.hpp>
#include <modeling/MakeFace.hpp>
AMCAX::TopoFace crashbug1() {
    double h1 = 7., h2 = 3.;
    AMCAX::Point2 p1(0., h1 / 2.0), p2(30., h2 / 2.0), p3(30., -h2 / 2.0), p4(0., -h1 / 2.0);
    std::vector<AMCAX::Point2> v_p;
    v_p.push_back(p1);
    v_p.push_back(p2);
    v_p.push_back(p3);
    v_p.push_back(p4);
    AMCAX::TopoEdge e;
    std::list<AMCAX::TopoShape> edges_polygon;
    for (int i = 1; i < v_p.size(); i++) {
        e = AMCAX::MakeEdge2d(v_p[i - 1], v_p[i]);
        edges_polygon.push_back(e);
    }
    e = AMCAX::MakeEdge2d(v_p[3], v_p[0]);
    edges_polygon.push_back(e);
    AMCAX::MakeWire mkw;
    mkw.Add(edges_polygon);
    AMCAX::TopoWire w_poly = mkw;
    AMCAX::TopoFace f_poly = AMCAX::MakeFace(w_poly, true);
    return f_poly;
}
#include <catch.hpp>
#include "testHelper.h"
#include<iostream>
#include <common/PointT.hpp>
#include <topology/TopoEdge.hpp>
#include <modeling/MakeWire.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <topology/TopoWire.hpp>
#include <topology/TopoShape.hpp>
#include <topology/TopoFace.hpp>
#include <modeling/MakeFace.hpp>
AMCAX::TopoFace crashbug1() {
    double h1 = 7., h2 = 3.;
    AMCAX::Point2 p1(0., h1 / 2.0), p2(30., h2 / 2.0), p3(30., -h2 / 2.0), p4(0., -h1 / 2.0);
    std::vector<AMCAX::Point2> v_p;
    v_p.push_back(p1);
    v_p.push_back(p2);
    v_p.push_back(p3);
    v_p.push_back(p4);
    AMCAX::TopoEdge e;
    std::list<AMCAX::TopoShape> edges_polygon;
    for (int i = 1; i < v_p.size(); i++) {
        e = AMCAX::MakeEdge2d(v_p[i - 1], v_p[i]);
        edges_polygon.push_back(e);
    }
    e = AMCAX::MakeEdge2d(v_p[3], v_p[0]);
    edges_polygon.push_back(e);
    AMCAX::MakeWire mkw;
    mkw.Add(edges_polygon);
    AMCAX::TopoWire w_poly = mkw;
    AMCAX::TopoFace f_poly = AMCAX::MakeFace(w_poly, true);
    return f_poly;
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API MakeFace(const Sphere& s, const TopoWire& w, bool inside = true)	 @param inside Whether the face is inside the wire
	 @param w The wire
	 @param s The sphere
	 @brief Construct from a sphere and a wire
,
 "output":#include <catch.hpp>
#include "testHelper.h"
#include<iostream>
#include <common/PointT.hpp>
#include <topology/TopoEdge.hpp>
#include <modeling/MakeWire.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <topology/TopoWire.hpp>
#include <topology/TopoShape.hpp>
#include <topology/TopoFace.hpp>
#include <modeling/MakeFace.hpp>
AMCAX::TopoFace crashbug1() {
    double h1 = 7., h2 = 3.;
    AMCAX::Point2 p1(0., h1 / 2.0), p2(30., h2 / 2.0), p3(30., -h2 / 2.0), p4(0., -h1 / 2.0);
    std::vector<AMCAX::Point2> v_p;
    v_p.push_back(p1);
    v_p.push_back(p2);
    v_p.push_back(p3);
    v_p.push_back(p4);
    AMCAX::TopoEdge e;
    std::list<AMCAX::TopoShape> edges_polygon;
    for (int i = 1; i < v_p.size(); i++) {
        e = AMCAX::MakeEdge2d(v_p[i - 1], v_p[i]);
        edges_polygon.push_back(e);
    }
    e = AMCAX::MakeEdge2d(v_p[3], v_p[0]);
    edges_polygon.push_back(e);
    AMCAX::MakeWire mkw;
    mkw.Add(edges_polygon);
    AMCAX::TopoWire w_poly = mkw;
    AMCAX::TopoFace f_poly = AMCAX::MakeFace(w_poly, true);
    return f_poly;
}
#include <catch.hpp>
#include "testHelper.h"
#include<iostream>
#include <common/PointT.hpp>
#include <topology/TopoEdge.hpp>
#include <modeling/MakeWire.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <topology/TopoWire.hpp>
#include <topology/TopoShape.hpp>
#include <topology/TopoFace.hpp>
#include <modeling/MakeFace.hpp>
AMCAX::TopoFace crashbug1() {
    double h1 = 7., h2 = 3.;
    AMCAX::Point2 p1(0., h1 / 2.0), p2(30., h2 / 2.0), p3(30., -h2 / 2.0), p4(0., -h1 / 2.0);
    std::vector<AMCAX::Point2> v_p;
    v_p.push_back(p1);
    v_p.push_back(p2);
    v_p.push_back(p3);
    v_p.push_back(p4);
    AMCAX::TopoEdge e;
    std::list<AMCAX::TopoShape> edges_polygon;
    for (int i = 1; i < v_p.size(); i++) {
        e = AMCAX::MakeEdge2d(v_p[i - 1], v_p[i]);
        edges_polygon.push_back(e);
    }
    e = AMCAX::MakeEdge2d(v_p[3], v_p[0]);
    edges_polygon.push_back(e);
    AMCAX::MakeWire mkw;
    mkw.Add(edges_polygon);
    AMCAX::TopoWire w_poly = mkw;
    AMCAX::TopoFace f_poly = AMCAX::MakeFace(w_poly, true);
    return f_poly;
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API MakeFace(const Torus& t, const TopoWire& w, bool inside = true)	 @param inside Whether the face is inside the wire
	 @param w The wire
	 @param t The torus
	 @brief Construct from a torus and a wire
,
 "output":#include <catch.hpp>
#include "testHelper.h"
#include<iostream>
#include <common/PointT.hpp>
#include <topology/TopoEdge.hpp>
#include <modeling/MakeWire.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <topology/TopoWire.hpp>
#include <topology/TopoShape.hpp>
#include <topology/TopoFace.hpp>
#include <modeling/MakeFace.hpp>
AMCAX::TopoFace crashbug1() {
    double h1 = 7., h2 = 3.;
    AMCAX::Point2 p1(0., h1 / 2.0), p2(30., h2 / 2.0), p3(30., -h2 / 2.0), p4(0., -h1 / 2.0);
    std::vector<AMCAX::Point2> v_p;
    v_p.push_back(p1);
    v_p.push_back(p2);
    v_p.push_back(p3);
    v_p.push_back(p4);
    AMCAX::TopoEdge e;
    std::list<AMCAX::TopoShape> edges_polygon;
    for (int i = 1; i < v_p.size(); i++) {
        e = AMCAX::MakeEdge2d(v_p[i - 1], v_p[i]);
        edges_polygon.push_back(e);
    }
    e = AMCAX::MakeEdge2d(v_p[3], v_p[0]);
    edges_polygon.push_back(e);
    AMCAX::MakeWire mkw;
    mkw.Add(edges_polygon);
    AMCAX::TopoWire w_poly = mkw;
    AMCAX::TopoFace f_poly = AMCAX::MakeFace(w_poly, true);
    return f_poly;
}
#include <catch.hpp>
#include "testHelper.h"
#include<iostream>
#include <common/PointT.hpp>
#include <topology/TopoEdge.hpp>
#include <modeling/MakeWire.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <topology/TopoWire.hpp>
#include <topology/TopoShape.hpp>
#include <topology/TopoFace.hpp>
#include <modeling/MakeFace.hpp>
AMCAX::TopoFace crashbug1() {
    double h1 = 7., h2 = 3.;
    AMCAX::Point2 p1(0., h1 / 2.0), p2(30., h2 / 2.0), p3(30., -h2 / 2.0), p4(0., -h1 / 2.0);
    std::vector<AMCAX::Point2> v_p;
    v_p.push_back(p1);
    v_p.push_back(p2);
    v_p.push_back(p3);
    v_p.push_back(p4);
    AMCAX::TopoEdge e;
    std::list<AMCAX::TopoShape> edges_polygon;
    for (int i = 1; i < v_p.size(); i++) {
        e = AMCAX::MakeEdge2d(v_p[i - 1], v_p[i]);
        edges_polygon.push_back(e);
    }
    e = AMCAX::MakeEdge2d(v_p[3], v_p[0]);
    edges_polygon.push_back(e);
    AMCAX::MakeWire mkw;
    mkw.Add(edges_polygon);
    AMCAX::TopoWire w_poly = mkw;
    AMCAX::TopoFace f_poly = AMCAX::MakeFace(w_poly, true);
    return f_poly;
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API MakeFace(const std::shared_ptr<Geom3Surface>& s, const TopoWire& w, bool inside = true)	 @param inside Whether the face is inside the wire
	 @param w The wire
	 @param s The surface
	 @brief Construct from a surface and a wire
,
 "output":#include <catch.hpp>
#include "testHelper.h"
#include<iostream>
#include <common/PointT.hpp>
#include <topology/TopoEdge.hpp>
#include <modeling/MakeWire.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <topology/TopoWire.hpp>
#include <topology/TopoShape.hpp>
#include <topology/TopoFace.hpp>
#include <modeling/MakeFace.hpp>
AMCAX::TopoFace crashbug1() {
    double h1 = 7., h2 = 3.;
    AMCAX::Point2 p1(0., h1 / 2.0), p2(30., h2 / 2.0), p3(30., -h2 / 2.0), p4(0., -h1 / 2.0);
    std::vector<AMCAX::Point2> v_p;
    v_p.push_back(p1);
    v_p.push_back(p2);
    v_p.push_back(p3);
    v_p.push_back(p4);
    AMCAX::TopoEdge e;
    std::list<AMCAX::TopoShape> edges_polygon;
    for (int i = 1; i < v_p.size(); i++) {
        e = AMCAX::MakeEdge2d(v_p[i - 1], v_p[i]);
        edges_polygon.push_back(e);
    }
    e = AMCAX::MakeEdge2d(v_p[3], v_p[0]);
    edges_polygon.push_back(e);
    AMCAX::MakeWire mkw;
    mkw.Add(edges_polygon);
    AMCAX::TopoWire w_poly = mkw;
    AMCAX::TopoFace f_poly = AMCAX::MakeFace(w_poly, true);
    return f_poly;
}
#include <catch.hpp>
#include "testHelper.h"
#include<iostream>
#include <common/PointT.hpp>
#include <topology/TopoEdge.hpp>
#include <modeling/MakeWire.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <topology/TopoWire.hpp>
#include <topology/TopoShape.hpp>
#include <topology/TopoFace.hpp>
#include <modeling/MakeFace.hpp>
AMCAX::TopoFace crashbug1() {
    double h1 = 7., h2 = 3.;
    AMCAX::Point2 p1(0., h1 / 2.0), p2(30., h2 / 2.0), p3(30., -h2 / 2.0), p4(0., -h1 / 2.0);
    std::vector<AMCAX::Point2> v_p;
    v_p.push_back(p1);
    v_p.push_back(p2);
    v_p.push_back(p3);
    v_p.push_back(p4);
    AMCAX::TopoEdge e;
    std::list<AMCAX::TopoShape> edges_polygon;
    for (int i = 1; i < v_p.size(); i++) {
        e = AMCAX::MakeEdge2d(v_p[i - 1], v_p[i]);
        edges_polygon.push_back(e);
    }
    e = AMCAX::MakeEdge2d(v_p[3], v_p[0]);
    edges_polygon.push_back(e);
    AMCAX::MakeWire mkw;
    mkw.Add(edges_polygon);
    AMCAX::TopoWire w_poly = mkw;
    AMCAX::TopoFace f_poly = AMCAX::MakeFace(w_poly, true);
    return f_poly;
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API explicit MakeFace(const TopoWire& w, bool onlyPlane = false)	 @param onlyPlane If true, the surface will be a plane
	 @param w The wire
	 @brief Construct from a wire
,
 "output":﻿#include<catch.hpp>
#include<testHelper.h>
#include <topology/TopoExplorerTool.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeWire.hpp>
#include <modeling/MakeFace.hpp>
#include <offset/MakeFaceExtension.hpp>
#include <topomesh/BRepMeshIncrementalMesh.hpp>
#include <io/OBJTool.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <topology/TopoTool.hpp>
#include <topology/TopoVertex.hpp>
using namespace AMCAX;
TEST_CASE("Not fix bug:case2:PerformWithEdgeAndLength  ", "[offset][PerformWithEdgeAndLength][P1][bug]") {
	Circle3 c1(Frame3(), 10.);
	Circle3 c2(Frame3(), 4.);
	TopoEdge e1 = MakeEdge(c1);
	TopoWire w1 = MakeWire(e1);
	TopoEdge e2 = MakeEdge(c2);
	TopoWire w2 = MakeWire(e2);
	w2.Reverse();
	MakeFace mkF(w1);
	mkF.Add(w2);
	mkF.Build();
	TopoFace face = mkF.Face();
	BRepMeshIncrementalMesh meshF(face, 0.01);
	IndexSet<TopoShape> fedge;
	TopoExplorerTool::MapShapes(face, ShapeType::Edge, fedge);
	MakeFaceExtension mkExt;
	mkExt.SetFace(face);
	SECTION("PerformWithEdgeAndLength 5.0 内径到圆心超过") {
			TopoEdge edge = static_cast<const TopoEdge&>(fedge[1]);
			mkExt.PerformWithEdgeAndLength(edge, 5.0);
			CHECK(mkExt.IsDone() == false);
		}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API GccCircle3Tangent(const GccQualifiedCurve& qualified1, const GccQualifiedCurve& qualified2, const GccQualifiedCurve& qualified3, double tolerance, double parameter1, double parameter2, double parameter3)	 @param parameter3 The initial guess of the parameter on the third curve
	 @param parameter2 The initial guess of the parameter on the second curve
	 @param parameter1 The initial guess of the parameter on the first curve
	 @param tolerance The tolerance
	 @param qualified3 The third curve
	 @param qualified2 The second curve
	 @param qualified1 The first curve
	 @brief Construct a circle tangent to three curves
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <geomAlgo/GccCircle3Tangent.hpp>
#include <geometry/Geom2Curve.hpp>
#include <geometry/MakeGeom2Line.hpp>
#include <geometry/MakeGeom2Circle.hpp>
#include <geomAlgo/GccEntity.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geomAlgo/GccEntity.hpp>
#include <geomAlgo/GccQualifiedCurve.hpp>
#include <sstream>
using namespace AMCAX;
TEST_CASE("bug1: GccCircle3Tangent  add 48 cases", "[geomAlgo][GccCircle3Tangent][fixbug]") {
	std::shared_ptr<Geom2Curve> l = MakeGeom2Line(Point2(0.0, 0.0), Point2(1.0, 0.0)).Value();
	std::shared_ptr<Geom2Curve> c1 = MakeGeom2Circle(Point2(0.0, 3.0), 2.0).Value();
	std::shared_ptr<Geom2Curve> c2 = MakeGeom2Circle(Point2(4.0, 3.0), 2.0).Value();
	AdaptorGeom2Curve line(l);
	AdaptorGeom2Curve circle1(c1);
	AdaptorGeom2Curve circle2(c2);
	auto lineEnclosed = GccEntity::Enclosed(line);
	auto lineOutside = GccEntity::Outside(line);
	auto lineUnqualified = GccEntity::Unqualified(line);
	auto circle1Enclosed = GccEntity::Enclosed(circle1);
	auto circle1Enclosing = GccEntity::Enclosing(circle1);
	auto circle1Outside = GccEntity::Outside(circle1);
	auto circle1Unqualified = GccEntity::Unqualified(circle1);
	auto circle2Enclosed = GccEntity::Enclosed(circle2);
	auto circle2Enclosing = GccEntity::Enclosing(circle2);
	auto circle2Outside = GccEntity::Outside(circle2);
	auto circle2Unqualified = GccEntity::Unqualified(circle2);
	auto gccl = GccEntity::Enclosed(AdaptorGeom2Curve(l));
	auto gccc1 = GccEntity::Enclosing(AdaptorGeom2Curve(c1));
	auto gccc2 = GccEntity::Outside(AdaptorGeom2Curve(c2));
	auto c3t = [](const GccQualifiedCurve& gccc1, const GccQualifiedCurve& gccc2, const GccQualifiedCurve& gccl)
	{
		std::stringstream output;
		GccCircle3Tangent gcc(gccc1, gccc2, gccl, Precision::Confusion(), 0.0, 0.0, 0.0);
		std::cout << "Test case: " << GccEntity::PositionToString(gccc1.Qualifier()) << ' ' << GccEntity::PositionToString(gccc2.Qualifier()) << ' ' << GccEntity::PositionToString(gccl.Qualifier()) << std::endl;
		std::cout << "Solution: " << gcc.NSolutions() << std::endl;
		output << "Test case: " << GccEntity::PositionToString(gccc1.Qualifier()) << ' ' << GccEntity::PositionToString(gccc2.Qualifier()) << ' ' << GccEntity::PositionToString(gccl.Qualifier()) << std::endl;
		output << "Solution: " << gcc.NSolutions() << std::endl;
		if (gcc.IsDone())
		{
			for (int i = 0; i < gcc.NSolutions(); i++)
			{
				GccPosition q1, q2, q3;
				gcc.Qualifier(i, q1, q2, q3);
				output << i << ": " << *MakeGeom2Circle(gcc.Solution(i)).Value() << std::endl;
				output << "  " << GccEntity::PositionToString(q1) << ' ' << GccEntity::PositionToString(q2) << ' ' << GccEntity::PositionToString(q3) << std::endl;
			}
		}
		else
		{
			std::cout << "gcc.IsDone is False" << std::endl;
			output << "gcc.IsDone is False" << std::endl;
		}
		return output.str();
	};
	auto case1 = c3t(circle1Enclosed, circle2Enclosed, lineEnclosed);
	auto expect1 = "Test case: Enclosed Enclosed Enclosed\nSolution: 0\n";
	CHECK(case1.find(expect1) != std::string::npos);
	auto case2 = c3t(circle1Enclosed, circle2Enclosed, lineOutside);
	auto expect2 = "Test case: Enclosed Enclosed Outside\nSolution: 0\n";
	CHECK(case2.find(expect2) != std::string::npos);
	auto case3 = c3t(circle1Enclosed, circle2Enclosed, lineUnqualified);
	auto expect3 = "Test case: Enclosed Enclosed Unqualified\nSolution: 0\n";
	CHECK(case3.find(expect3) != std::string::npos);
	auto case4 = c3t(circle1Enclosed, circle2Enclosing, lineEnclosed);
	auto expect4 = "Test case: Enclosed Enclosing Enclosed\nSolution: 0\n";
	CHECK(case4.find(expect4) != std::string::npos);
	auto case5 = c3t(circle1Enclosed, circle2Enclosing, lineOutside);
	auto expect5 = "Test case: Enclosed Enclosing Outside\nSolution: 0\n";
	CHECK(case5.find(expect5) != std::string::npos);
	auto case6 = c3t(circle1Enclosed, circle2Enclosing, lineUnqualified);
	auto expect6 = "Test case: Enclosed Enclosing Unqualified\nSolution: 0\n";
	CHECK(case6.find(expect6) != std::string::npos);
	auto case7 = c3t(circle1Enclosed, circle2Outside, lineEnclosed);
	auto expect7 = "Test case: Enclosed Outside Enclosed\nSolution: 0\n";
	CHECK(case7.find(expect7) != std::string::npos);
	auto case8 = c3t(circle1Enclosed, circle2Outside, lineOutside);
	auto expect8 = "Test case: Enclosed Outside Outside\nSolution: 0\n";
	CHECK(case8.find(expect8) != std::string::npos);
	auto case9 = c3t(circle1Enclosed, circle2Outside, lineUnqualified);
	auto expect9 = "Test case: Enclosed Outside Unqualified\nSolution: 0\n";
	CHECK(case9.find(expect9) != std::string::npos);
	auto case10 = c3t(circle1Enclosed, circle2Unqualified, lineEnclosed);
	auto expect10 = "Test case: Enclosed Unqualified Enclosed\nSolution: 0\n";
	CHECK(case10.find(expect10) != std::string::npos);
	auto case11 = c3t(circle1Enclosed, circle2Unqualified, lineOutside);
	auto expect11 = "Test case: Enclosed Unqualified Outside\nSolution: 0\n";
	CHECK(case11.find(expect11) != std::string::npos);
	auto case12 = c3t(circle1Enclosed, circle2Unqualified, lineUnqualified);
	auto expect12 = "Test case: Enclosed Unqualified Unqualified\nSolution: 0\n";
	CHECK(case12.find(expect12) != std::string::npos);
	auto case13 = c3t(circle1Enclosing, circle2Enclosed, lineEnclosed);
	auto expect13 = "Test case: Enclosing Enclosed Enclosed\nSolution: 0\n";
	CHECK(case13.find(expect13) != std::string::npos);
	auto case14 = c3t(circle1Enclosing, circle2Enclosed, lineOutside);
	auto expect14 = "Test case: Enclosing Enclosed Outside\nSolution: 0\n";
	CHECK(case14.find(expect14) != std::string::npos);
	auto case15 = c3t(circle1Enclosing, circle2Enclosed, lineUnqualified);
	auto expect15 = "Test case: Enclosing Enclosed Unqualified\nSolution: 0\n";
	CHECK(case15.find(expect15) != std::string::npos);
	auto case16 = c3t(circle1Enclosing, circle2Enclosing, lineEnclosed);
	auto expect16 = "Test case: Enclosing Enclosing Enclosed\nSolution: 1\n0: 2 2 4.5 1 0 -0 1 4.5\n  Enclosing Enclosing Enclosed\n";
	CHECK(case16.find(expect16) != std::string::npos);
	auto case17 = c3t(circle1Enclosing, circle2Enclosing, lineOutside);
	auto expect17 = "Test case: Enclosing Enclosing Outside\nSolution: 0\n";
	CHECK(case17.find(expect17) != std::string::npos);
	auto case18 = c3t(circle1Enclosing, circle2Enclosing, lineUnqualified);
	auto expect18 = "Test case: Enclosing Enclosing Unqualified\nSolution: 1\n0: 2 2 4.5 1 0 -0 1 4.5\n  Enclosing Enclosing Enclosed\n";
	CHECK(case18.find(expect18) != std::string::npos);
	auto case19 = c3t(circle1Enclosing, circle2Outside, lineEnclosed);
	auto expect19 = "Test case: Enclosing Outside Enclosed\nSolution: 1\n0: 2 -1 3 1 0 -0 1 3\n  Enclosing Outside Enclosed\n";
	CHECK(case19.find(expect19) != std::string::npos);
	auto case20 = c3t(circle1Enclosing, circle2Outside, lineOutside);
	auto expect20 = "Test case: Enclosing Outside Outside\nSolution: 0\n";
	CHECK(case20.find(expect20) != std::string::npos);
	auto case21 = c3t(circle1Enclosing, circle2Outside, lineUnqualified);
	auto expect21 = "Test case: Enclosing Outside Unqualified\nSolution: 1\n0: 2 -1 3 1 0 -0 1 3\n  Enclosing Outside Enclosed\n";
	CHECK(case21.find(expect21) != std::string::npos);
	auto case22 = c3t(circle1Enclosing, circle2Unqualified, lineEnclosed);
	auto expect22 = "Test case: Enclosing Unqualified Enclosed\nSolution: 2\n0: 2 -1 3 1 0 -0 1 3\n  Enclosing Outside Enclosed\n1: 2 2 4.5 1 0 -0 1 4.5\n  Enclosing Enclosing Enclosed\n";
	CHECK(case22.find(expect22) != std::string::npos);
	auto case23 = c3t(circle1Enclosing, circle2Unqualified, lineOutside);
	auto expect23 = "Test case: Enclosing Unqualified Outside\nSolution: 0\n";
	CHECK(case23.find(expect23) != std::string::npos);
	auto case24 = c3t(circle1Enclosing, circle2Unqualified, lineUnqualified);
	auto expect24 = "Test case: Enclosing Unqualified Unqualified\nSolution: 2\n0: 2 -1 3 1 0 -0 1 3\n  Enclosing Outside Enclosed\n1: 2 2 4.5 1 0 -0 1 4.5\n  Enclosing Enclosing Enclosed\n";
	CHECK(case24.find(expect24) != std::string::npos);
	auto case25 = c3t(circle1Outside, circle2Enclosed, lineEnclosed);
	auto expect25 = "Test case: Outside Enclosed Enclosed\nSolution: 0\n";
	CHECK(case25.find(expect25) != std::string::npos);
	auto case26 = c3t(circle1Outside, circle2Enclosed, lineOutside);
	auto expect26 = "Test case: Outside Enclosed Outside\nSolution: 0\n";
	CHECK(case26.find(expect26) != std::string::npos);
	auto case27 = c3t(circle1Outside, circle2Enclosed, lineUnqualified);
	auto expect27 = "Test case: Outside Enclosed Unqualified\nSolution: 0\n";
	CHECK(case27.find(expect27) != std::string::npos);
	auto case28 = c3t(circle1Outside, circle2Enclosing, lineEnclosed);
	auto expect28 = "Test case: Outside Enclosing Enclosed\nSolution: 1\n0: 2 5 3 1 0 -0 1 3\n  Outside Enclosing Enclosed\n";
	CHECK(case28.find(expect28) != std::string::npos);
	auto case29 = c3t(circle1Outside, circle2Enclosing, lineOutside);
	auto expect29 = "Test case: Outside Enclosing Outside\nSolution: 0\n";
	CHECK(case29.find(expect29) != std::string::npos);
	auto case30 = c3t(circle1Outside, circle2Enclosing, lineUnqualified);
	auto expect30 = "Test case: Outside Enclosing Unqualified\nSolution: 1\n0: 2 5 3 1 0 -0 1 3\n  Outside Enclosing Enclosed\n";
	CHECK(case30.find(expect30) != std::string::npos);
	auto case31 = c3t(circle1Outside, circle2Outside, lineEnclosed);
	auto expect31 = "Test case: Outside Outside Enclosed\nSolution: 1\n0: 2 2 0.9 1 0 -0 1 0.9\n  Outside Outside Enclosed\n";
	CHECK(case31.find(expect31) != std::string::npos);
	auto case32 = c3t(circle1Outside, circle2Outside, lineOutside);
	auto expect32 = "Test case: Outside Outside Outside\nSolution: 0\n";
	CHECK(case32.find(expect32) != std::string::npos);
	auto case33 = c3t(circle1Outside, circle2Outside, lineUnqualified);
	auto expect33 = "Test case: Outside Outside Unqualified\nSolution: 1\n0: 2 2 0.9 1 0 -0 1 0.9\n  Outside Outside Enclosed\n";
	CHECK(case33.find(expect33) != std::string::npos);
	auto case34 = c3t(circle1Outside, circle2Unqualified, lineEnclosed);
	auto expect34 = "Test case: Outside Unqualified Enclosed\nSolution: 2\n0: 2 2 0.9 1 0 -0 1 0.9\n  Outside Outside Enclosed\n1: 2 5 3 1 0 -0 1 3\n  Outside Enclosing Enclosed\n";
	CHECK(case34.find(expect34) != std::string::npos);
	auto case35 = c3t(circle1Outside, circle2Unqualified, lineOutside);
	auto expect35 = "Test case: Outside Unqualified Outside\nSolution: 0\n";
	CHECK(case35.find(expect35) != std::string::npos);
	auto case36 = c3t(circle1Outside, circle2Unqualified, lineUnqualified);
	auto expect36 = "Test case: Outside Unqualified Unqualified\nSolution: 2\n0: 2 2 0.9 1 0 -0 1 0.9\n  Outside Outside Enclosed\n1: 2 5 3 1 0 -0 1 3\n  Outside Enclosing Enclosed\n";
	CHECK(case36.find(expect36) != std::string::npos);
	auto case37 = c3t(circle1Unqualified, circle2Enclosed, lineEnclosed);
	auto expect37 = "Test case: Unqualified Enclosed Enclosed\nSolution: 0\n";
	CHECK(case37.find(expect37) != std::string::npos);
	auto case38 = c3t(circle1Unqualified, circle2Enclosed, lineOutside);
	auto expect38 = "Test case: Unqualified Enclosed Outside\nSolution: 0\n";
	CHECK(case38.find(expect38) != std::string::npos);
	auto case39 = c3t(circle1Unqualified, circle2Enclosed, lineUnqualified);
	auto expect39 = "Test case: Unqualified Enclosed Unqualified\nSolution: 0\n";
	CHECK(case39.find(expect39) != std::string::npos);
	auto case40 = c3t(circle1Unqualified, circle2Enclosing, lineEnclosed);
	auto expect40 = "Test case: Unqualified Enclosing Enclosed\nSolution: 2\n0: 2 5 3 1 0 -0 1 3\n  Outside Enclosing Enclosed\n1: 2 2 4.5 1 0 -0 1 4.5\n  Enclosing Enclosing Enclosed\n";
	CHECK(case40.find(expect40) != std::string::npos);
	auto case41 = c3t(circle1Unqualified, circle2Enclosing, lineOutside);
	auto expect41 = "Test case: Unqualified Enclosing Outside\nSolution: 0\n";
	CHECK(case41.find(expect41) != std::string::npos);
	auto case42 = c3t(circle1Unqualified, circle2Enclosing, lineUnqualified);
	auto expect42 = "Test case: Unqualified Enclosing Unqualified\nSolution: 2\n0: 2 5 3 1 0 -0 1 3\n  Outside Enclosing Enclosed\n1: 2 2 4.5 1 0 -0 1 4.5\n  Enclosing Enclosing Enclosed\n";
	CHECK(case42.find(expect42) != std::string::npos);
	auto case43 = c3t(circle1Unqualified, circle2Outside, lineEnclosed);
	auto expect43 = "Test case: Unqualified Outside Enclosed\nSolution: 2\n0: 2 2 0.9 1 0 -0 1 0.9\n  Outside Outside Enclosed\n1: 2 -1 3 1 0 -0 1 3\n  Enclosing Outside Enclosed\n";
	CHECK(case43.find(expect43) != std::string::npos);
	auto case44 = c3t(circle1Unqualified, circle2Outside, lineOutside);
	auto expect44 = "Test case: Unqualified Outside Outside\nSolution: 0\n";
	CHECK(case44.find(expect44) != std::string::npos);
	auto case45 = c3t(circle1Unqualified, circle2Outside, lineUnqualified);
	auto expect45 = "Test case: Unqualified Outside Unqualified\nSolution: 2\n0: 2 2 0.9 1 0 -0 1 0.9\n  Outside Outside Enclosed\n1: 2 -1 3 1 0 -0 1 3\n  Enclosing Outside Enclosed\n";
	CHECK(case45.find(expect45) != std::string::npos);
	auto case46 = c3t(circle1Unqualified, circle2Unqualified, lineEnclosed);
	auto expect46 = "Test case: Unqualified Unqualified Enclosed\nSolution: 4\n0: 2 2 0.9 1 0 -0 1 0.9\n  Outside Outside Enclosed\n1: 2 5 3 1 0 -0 1 3\n  Outside Enclosing Enclosed\n2: 2 -1 3 1 0 -0 1 3\n  Enclosing Outside Enclosed\n3: 2 2 4.5 1 0 -0 1 4.5\n  Enclosing Enclosing Enclosed\n";
	CHECK(case46.find(expect46) != std::string::npos);
	auto case47 = c3t(circle1Unqualified, circle2Unqualified, lineOutside);
	auto expect47 = "Test case: Unqualified Unqualified Outside\nSolution: 0\n";
	CHECK(case47.find(expect47) != std::string::npos);
	auto case48 = c3t(circle1Unqualified, circle2Unqualified, lineUnqualified);
	auto expect48 = "Test case: Unqualified Unqualified Unqualified\nSolution: 4\n0: 2 2 0.9 1 0 -0 1 0.9\n  Outside Outside Enclosed\n1: 2 5 3 1 0 -0 1 3\n  Outside Enclosing Enclosed\n2: 2 -1 3 1 0 -0 1 3\n  Enclosing Outside Enclosed\n3: 2 2 4.5 1 0 -0 1 4.5\n  Enclosing Enclosing Enclosed";
	CHECK(case48.find(expect48) != std::string::npos);
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API GccCircle3Tangent(const GccQualifiedCurve& qualified1, const GccQualifiedCurve& qualified2, const Point2& point, double tolerance, double parameter1, double parameter2)	 @param parameter2 The initial guess of the parameter on the second curve
	 @param parameter1 The initial guess of the parameter on the first curve
	 @param tolerance The tolerance
	 @param point The point that the circle passes through
	 @param qualified2 The second curve
	 @param qualified1 The first curve
	 @brief Construct a circle tangent to two curves and passing through a point
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <geomAlgo/GccCircle3Tangent.hpp>
#include <geometry/Geom2Curve.hpp>
#include <geometry/MakeGeom2Line.hpp>
#include <geometry/MakeGeom2Circle.hpp>
#include <geomAlgo/GccEntity.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geomAlgo/GccEntity.hpp>
#include <geomAlgo/GccQualifiedCurve.hpp>
#include <sstream>
using namespace AMCAX;
TEST_CASE("bug1: GccCircle3Tangent  add 48 cases", "[geomAlgo][GccCircle3Tangent][fixbug]") {
	std::shared_ptr<Geom2Curve> l = MakeGeom2Line(Point2(0.0, 0.0), Point2(1.0, 0.0)).Value();
	std::shared_ptr<Geom2Curve> c1 = MakeGeom2Circle(Point2(0.0, 3.0), 2.0).Value();
	std::shared_ptr<Geom2Curve> c2 = MakeGeom2Circle(Point2(4.0, 3.0), 2.0).Value();
	AdaptorGeom2Curve line(l);
	AdaptorGeom2Curve circle1(c1);
	AdaptorGeom2Curve circle2(c2);
	auto lineEnclosed = GccEntity::Enclosed(line);
	auto lineOutside = GccEntity::Outside(line);
	auto lineUnqualified = GccEntity::Unqualified(line);
	auto circle1Enclosed = GccEntity::Enclosed(circle1);
	auto circle1Enclosing = GccEntity::Enclosing(circle1);
	auto circle1Outside = GccEntity::Outside(circle1);
	auto circle1Unqualified = GccEntity::Unqualified(circle1);
	auto circle2Enclosed = GccEntity::Enclosed(circle2);
	auto circle2Enclosing = GccEntity::Enclosing(circle2);
	auto circle2Outside = GccEntity::Outside(circle2);
	auto circle2Unqualified = GccEntity::Unqualified(circle2);
	auto gccl = GccEntity::Enclosed(AdaptorGeom2Curve(l));
	auto gccc1 = GccEntity::Enclosing(AdaptorGeom2Curve(c1));
	auto gccc2 = GccEntity::Outside(AdaptorGeom2Curve(c2));
	auto c3t = [](const GccQualifiedCurve& gccc1, const GccQualifiedCurve& gccc2, const GccQualifiedCurve& gccl)
	{
		std::stringstream output;
		GccCircle3Tangent gcc(gccc1, gccc2, gccl, Precision::Confusion(), 0.0, 0.0, 0.0);
		std::cout << "Test case: " << GccEntity::PositionToString(gccc1.Qualifier()) << ' ' << GccEntity::PositionToString(gccc2.Qualifier()) << ' ' << GccEntity::PositionToString(gccl.Qualifier()) << std::endl;
		std::cout << "Solution: " << gcc.NSolutions() << std::endl;
		output << "Test case: " << GccEntity::PositionToString(gccc1.Qualifier()) << ' ' << GccEntity::PositionToString(gccc2.Qualifier()) << ' ' << GccEntity::PositionToString(gccl.Qualifier()) << std::endl;
		output << "Solution: " << gcc.NSolutions() << std::endl;
		if (gcc.IsDone())
		{
			for (int i = 0; i < gcc.NSolutions(); i++)
			{
				GccPosition q1, q2, q3;
				gcc.Qualifier(i, q1, q2, q3);
				output << i << ": " << *MakeGeom2Circle(gcc.Solution(i)).Value() << std::endl;
				output << "  " << GccEntity::PositionToString(q1) << ' ' << GccEntity::PositionToString(q2) << ' ' << GccEntity::PositionToString(q3) << std::endl;
			}
		}
		else
		{
			std::cout << "gcc.IsDone is False" << std::endl;
			output << "gcc.IsDone is False" << std::endl;
		}
		return output.str();
	};
	auto case1 = c3t(circle1Enclosed, circle2Enclosed, lineEnclosed);
	auto expect1 = "Test case: Enclosed Enclosed Enclosed\nSolution: 0\n";
	CHECK(case1.find(expect1) != std::string::npos);
	auto case2 = c3t(circle1Enclosed, circle2Enclosed, lineOutside);
	auto expect2 = "Test case: Enclosed Enclosed Outside\nSolution: 0\n";
	CHECK(case2.find(expect2) != std::string::npos);
	auto case3 = c3t(circle1Enclosed, circle2Enclosed, lineUnqualified);
	auto expect3 = "Test case: Enclosed Enclosed Unqualified\nSolution: 0\n";
	CHECK(case3.find(expect3) != std::string::npos);
	auto case4 = c3t(circle1Enclosed, circle2Enclosing, lineEnclosed);
	auto expect4 = "Test case: Enclosed Enclosing Enclosed\nSolution: 0\n";
	CHECK(case4.find(expect4) != std::string::npos);
	auto case5 = c3t(circle1Enclosed, circle2Enclosing, lineOutside);
	auto expect5 = "Test case: Enclosed Enclosing Outside\nSolution: 0\n";
	CHECK(case5.find(expect5) != std::string::npos);
	auto case6 = c3t(circle1Enclosed, circle2Enclosing, lineUnqualified);
	auto expect6 = "Test case: Enclosed Enclosing Unqualified\nSolution: 0\n";
	CHECK(case6.find(expect6) != std::string::npos);
	auto case7 = c3t(circle1Enclosed, circle2Outside, lineEnclosed);
	auto expect7 = "Test case: Enclosed Outside Enclosed\nSolution: 0\n";
	CHECK(case7.find(expect7) != std::string::npos);
	auto case8 = c3t(circle1Enclosed, circle2Outside, lineOutside);
	auto expect8 = "Test case: Enclosed Outside Outside\nSolution: 0\n";
	CHECK(case8.find(expect8) != std::string::npos);
	auto case9 = c3t(circle1Enclosed, circle2Outside, lineUnqualified);
	auto expect9 = "Test case: Enclosed Outside Unqualified\nSolution: 0\n";
	CHECK(case9.find(expect9) != std::string::npos);
	auto case10 = c3t(circle1Enclosed, circle2Unqualified, lineEnclosed);
	auto expect10 = "Test case: Enclosed Unqualified Enclosed\nSolution: 0\n";
	CHECK(case10.find(expect10) != std::string::npos);
	auto case11 = c3t(circle1Enclosed, circle2Unqualified, lineOutside);
	auto expect11 = "Test case: Enclosed Unqualified Outside\nSolution: 0\n";
	CHECK(case11.find(expect11) != std::string::npos);
	auto case12 = c3t(circle1Enclosed, circle2Unqualified, lineUnqualified);
	auto expect12 = "Test case: Enclosed Unqualified Unqualified\nSolution: 0\n";
	CHECK(case12.find(expect12) != std::string::npos);
	auto case13 = c3t(circle1Enclosing, circle2Enclosed, lineEnclosed);
	auto expect13 = "Test case: Enclosing Enclosed Enclosed\nSolution: 0\n";
	CHECK(case13.find(expect13) != std::string::npos);
	auto case14 = c3t(circle1Enclosing, circle2Enclosed, lineOutside);
	auto expect14 = "Test case: Enclosing Enclosed Outside\nSolution: 0\n";
	CHECK(case14.find(expect14) != std::string::npos);
	auto case15 = c3t(circle1Enclosing, circle2Enclosed, lineUnqualified);
	auto expect15 = "Test case: Enclosing Enclosed Unqualified\nSolution: 0\n";
	CHECK(case15.find(expect15) != std::string::npos);
	auto case16 = c3t(circle1Enclosing, circle2Enclosing, lineEnclosed);
	auto expect16 = "Test case: Enclosing Enclosing Enclosed\nSolution: 1\n0: 2 2 4.5 1 0 -0 1 4.5\n  Enclosing Enclosing Enclosed\n";
	CHECK(case16.find(expect16) != std::string::npos);
	auto case17 = c3t(circle1Enclosing, circle2Enclosing, lineOutside);
	auto expect17 = "Test case: Enclosing Enclosing Outside\nSolution: 0\n";
	CHECK(case17.find(expect17) != std::string::npos);
	auto case18 = c3t(circle1Enclosing, circle2Enclosing, lineUnqualified);
	auto expect18 = "Test case: Enclosing Enclosing Unqualified\nSolution: 1\n0: 2 2 4.5 1 0 -0 1 4.5\n  Enclosing Enclosing Enclosed\n";
	CHECK(case18.find(expect18) != std::string::npos);
	auto case19 = c3t(circle1Enclosing, circle2Outside, lineEnclosed);
	auto expect19 = "Test case: Enclosing Outside Enclosed\nSolution: 1\n0: 2 -1 3 1 0 -0 1 3\n  Enclosing Outside Enclosed\n";
	CHECK(case19.find(expect19) != std::string::npos);
	auto case20 = c3t(circle1Enclosing, circle2Outside, lineOutside);
	auto expect20 = "Test case: Enclosing Outside Outside\nSolution: 0\n";
	CHECK(case20.find(expect20) != std::string::npos);
	auto case21 = c3t(circle1Enclosing, circle2Outside, lineUnqualified);
	auto expect21 = "Test case: Enclosing Outside Unqualified\nSolution: 1\n0: 2 -1 3 1 0 -0 1 3\n  Enclosing Outside Enclosed\n";
	CHECK(case21.find(expect21) != std::string::npos);
	auto case22 = c3t(circle1Enclosing, circle2Unqualified, lineEnclosed);
	auto expect22 = "Test case: Enclosing Unqualified Enclosed\nSolution: 2\n0: 2 -1 3 1 0 -0 1 3\n  Enclosing Outside Enclosed\n1: 2 2 4.5 1 0 -0 1 4.5\n  Enclosing Enclosing Enclosed\n";
	CHECK(case22.find(expect22) != std::string::npos);
	auto case23 = c3t(circle1Enclosing, circle2Unqualified, lineOutside);
	auto expect23 = "Test case: Enclosing Unqualified Outside\nSolution: 0\n";
	CHECK(case23.find(expect23) != std::string::npos);
	auto case24 = c3t(circle1Enclosing, circle2Unqualified, lineUnqualified);
	auto expect24 = "Test case: Enclosing Unqualified Unqualified\nSolution: 2\n0: 2 -1 3 1 0 -0 1 3\n  Enclosing Outside Enclosed\n1: 2 2 4.5 1 0 -0 1 4.5\n  Enclosing Enclosing Enclosed\n";
	CHECK(case24.find(expect24) != std::string::npos);
	auto case25 = c3t(circle1Outside, circle2Enclosed, lineEnclosed);
	auto expect25 = "Test case: Outside Enclosed Enclosed\nSolution: 0\n";
	CHECK(case25.find(expect25) != std::string::npos);
	auto case26 = c3t(circle1Outside, circle2Enclosed, lineOutside);
	auto expect26 = "Test case: Outside Enclosed Outside\nSolution: 0\n";
	CHECK(case26.find(expect26) != std::string::npos);
	auto case27 = c3t(circle1Outside, circle2Enclosed, lineUnqualified);
	auto expect27 = "Test case: Outside Enclosed Unqualified\nSolution: 0\n";
	CHECK(case27.find(expect27) != std::string::npos);
	auto case28 = c3t(circle1Outside, circle2Enclosing, lineEnclosed);
	auto expect28 = "Test case: Outside Enclosing Enclosed\nSolution: 1\n0: 2 5 3 1 0 -0 1 3\n  Outside Enclosing Enclosed\n";
	CHECK(case28.find(expect28) != std::string::npos);
	auto case29 = c3t(circle1Outside, circle2Enclosing, lineOutside);
	auto expect29 = "Test case: Outside Enclosing Outside\nSolution: 0\n";
	CHECK(case29.find(expect29) != std::string::npos);
	auto case30 = c3t(circle1Outside, circle2Enclosing, lineUnqualified);
	auto expect30 = "Test case: Outside Enclosing Unqualified\nSolution: 1\n0: 2 5 3 1 0 -0 1 3\n  Outside Enclosing Enclosed\n";
	CHECK(case30.find(expect30) != std::string::npos);
	auto case31 = c3t(circle1Outside, circle2Outside, lineEnclosed);
	auto expect31 = "Test case: Outside Outside Enclosed\nSolution: 1\n0: 2 2 0.9 1 0 -0 1 0.9\n  Outside Outside Enclosed\n";
	CHECK(case31.find(expect31) != std::string::npos);
	auto case32 = c3t(circle1Outside, circle2Outside, lineOutside);
	auto expect32 = "Test case: Outside Outside Outside\nSolution: 0\n";
	CHECK(case32.find(expect32) != std::string::npos);
	auto case33 = c3t(circle1Outside, circle2Outside, lineUnqualified);
	auto expect33 = "Test case: Outside Outside Unqualified\nSolution: 1\n0: 2 2 0.9 1 0 -0 1 0.9\n  Outside Outside Enclosed\n";
	CHECK(case33.find(expect33) != std::string::npos);
	auto case34 = c3t(circle1Outside, circle2Unqualified, lineEnclosed);
	auto expect34 = "Test case: Outside Unqualified Enclosed\nSolution: 2\n0: 2 2 0.9 1 0 -0 1 0.9\n  Outside Outside Enclosed\n1: 2 5 3 1 0 -0 1 3\n  Outside Enclosing Enclosed\n";
	CHECK(case34.find(expect34) != std::string::npos);
	auto case35 = c3t(circle1Outside, circle2Unqualified, lineOutside);
	auto expect35 = "Test case: Outside Unqualified Outside\nSolution: 0\n";
	CHECK(case35.find(expect35) != std::string::npos);
	auto case36 = c3t(circle1Outside, circle2Unqualified, lineUnqualified);
	auto expect36 = "Test case: Outside Unqualified Unqualified\nSolution: 2\n0: 2 2 0.9 1 0 -0 1 0.9\n  Outside Outside Enclosed\n1: 2 5 3 1 0 -0 1 3\n  Outside Enclosing Enclosed\n";
	CHECK(case36.find(expect36) != std::string::npos);
	auto case37 = c3t(circle1Unqualified, circle2Enclosed, lineEnclosed);
	auto expect37 = "Test case: Unqualified Enclosed Enclosed\nSolution: 0\n";
	CHECK(case37.find(expect37) != std::string::npos);
	auto case38 = c3t(circle1Unqualified, circle2Enclosed, lineOutside);
	auto expect38 = "Test case: Unqualified Enclosed Outside\nSolution: 0\n";
	CHECK(case38.find(expect38) != std::string::npos);
	auto case39 = c3t(circle1Unqualified, circle2Enclosed, lineUnqualified);
	auto expect39 = "Test case: Unqualified Enclosed Unqualified\nSolution: 0\n";
	CHECK(case39.find(expect39) != std::string::npos);
	auto case40 = c3t(circle1Unqualified, circle2Enclosing, lineEnclosed);
	auto expect40 = "Test case: Unqualified Enclosing Enclosed\nSolution: 2\n0: 2 5 3 1 0 -0 1 3\n  Outside Enclosing Enclosed\n1: 2 2 4.5 1 0 -0 1 4.5\n  Enclosing Enclosing Enclosed\n";
	CHECK(case40.find(expect40) != std::string::npos);
	auto case41 = c3t(circle1Unqualified, circle2Enclosing, lineOutside);
	auto expect41 = "Test case: Unqualified Enclosing Outside\nSolution: 0\n";
	CHECK(case41.find(expect41) != std::string::npos);
	auto case42 = c3t(circle1Unqualified, circle2Enclosing, lineUnqualified);
	auto expect42 = "Test case: Unqualified Enclosing Unqualified\nSolution: 2\n0: 2 5 3 1 0 -0 1 3\n  Outside Enclosing Enclosed\n1: 2 2 4.5 1 0 -0 1 4.5\n  Enclosing Enclosing Enclosed\n";
	CHECK(case42.find(expect42) != std::string::npos);
	auto case43 = c3t(circle1Unqualified, circle2Outside, lineEnclosed);
	auto expect43 = "Test case: Unqualified Outside Enclosed\nSolution: 2\n0: 2 2 0.9 1 0 -0 1 0.9\n  Outside Outside Enclosed\n1: 2 -1 3 1 0 -0 1 3\n  Enclosing Outside Enclosed\n";
	CHECK(case43.find(expect43) != std::string::npos);
	auto case44 = c3t(circle1Unqualified, circle2Outside, lineOutside);
	auto expect44 = "Test case: Unqualified Outside Outside\nSolution: 0\n";
	CHECK(case44.find(expect44) != std::string::npos);
	auto case45 = c3t(circle1Unqualified, circle2Outside, lineUnqualified);
	auto expect45 = "Test case: Unqualified Outside Unqualified\nSolution: 2\n0: 2 2 0.9 1 0 -0 1 0.9\n  Outside Outside Enclosed\n1: 2 -1 3 1 0 -0 1 3\n  Enclosing Outside Enclosed\n";
	CHECK(case45.find(expect45) != std::string::npos);
	auto case46 = c3t(circle1Unqualified, circle2Unqualified, lineEnclosed);
	auto expect46 = "Test case: Unqualified Unqualified Enclosed\nSolution: 4\n0: 2 2 0.9 1 0 -0 1 0.9\n  Outside Outside Enclosed\n1: 2 5 3 1 0 -0 1 3\n  Outside Enclosing Enclosed\n2: 2 -1 3 1 0 -0 1 3\n  Enclosing Outside Enclosed\n3: 2 2 4.5 1 0 -0 1 4.5\n  Enclosing Enclosing Enclosed\n";
	CHECK(case46.find(expect46) != std::string::npos);
	auto case47 = c3t(circle1Unqualified, circle2Unqualified, lineOutside);
	auto expect47 = "Test case: Unqualified Unqualified Outside\nSolution: 0\n";
	CHECK(case47.find(expect47) != std::string::npos);
	auto case48 = c3t(circle1Unqualified, circle2Unqualified, lineUnqualified);
	auto expect48 = "Test case: Unqualified Unqualified Unqualified\nSolution: 4\n0: 2 2 0.9 1 0 -0 1 0.9\n  Outside Outside Enclosed\n1: 2 5 3 1 0 -0 1 3\n  Outside Enclosing Enclosed\n2: 2 -1 3 1 0 -0 1 3\n  Enclosing Outside Enclosed\n3: 2 2 4.5 1 0 -0 1 4.5\n  Enclosing Enclosing Enclosed";
	CHECK(case48.find(expect48) != std::string::npos);
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API GccCircle3Tangent(const GccQualifiedCurve& qualified1, const Point2& point1, const Point2& point2, double tolerance, double parameter1)	 @param parameter1 The initial guess of the parameter on the curve
	 @param tolerance The tolerance
	 @param point2 The second point
	 @param point1 The first point
	 @param qualified1 The tangent curve
	 @brief Construct a circle tangent to a curve and passing throught two points
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <geomAlgo/GccCircle3Tangent.hpp>
#include <geometry/Geom2Curve.hpp>
#include <geometry/MakeGeom2Line.hpp>
#include <geometry/MakeGeom2Circle.hpp>
#include <geomAlgo/GccEntity.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geomAlgo/GccEntity.hpp>
#include <geomAlgo/GccQualifiedCurve.hpp>
#include <sstream>
using namespace AMCAX;
TEST_CASE("bug1: GccCircle3Tangent  add 48 cases", "[geomAlgo][GccCircle3Tangent][fixbug]") {
	std::shared_ptr<Geom2Curve> l = MakeGeom2Line(Point2(0.0, 0.0), Point2(1.0, 0.0)).Value();
	std::shared_ptr<Geom2Curve> c1 = MakeGeom2Circle(Point2(0.0, 3.0), 2.0).Value();
	std::shared_ptr<Geom2Curve> c2 = MakeGeom2Circle(Point2(4.0, 3.0), 2.0).Value();
	AdaptorGeom2Curve line(l);
	AdaptorGeom2Curve circle1(c1);
	AdaptorGeom2Curve circle2(c2);
	auto lineEnclosed = GccEntity::Enclosed(line);
	auto lineOutside = GccEntity::Outside(line);
	auto lineUnqualified = GccEntity::Unqualified(line);
	auto circle1Enclosed = GccEntity::Enclosed(circle1);
	auto circle1Enclosing = GccEntity::Enclosing(circle1);
	auto circle1Outside = GccEntity::Outside(circle1);
	auto circle1Unqualified = GccEntity::Unqualified(circle1);
	auto circle2Enclosed = GccEntity::Enclosed(circle2);
	auto circle2Enclosing = GccEntity::Enclosing(circle2);
	auto circle2Outside = GccEntity::Outside(circle2);
	auto circle2Unqualified = GccEntity::Unqualified(circle2);
	auto gccl = GccEntity::Enclosed(AdaptorGeom2Curve(l));
	auto gccc1 = GccEntity::Enclosing(AdaptorGeom2Curve(c1));
	auto gccc2 = GccEntity::Outside(AdaptorGeom2Curve(c2));
	auto c3t = [](const GccQualifiedCurve& gccc1, const GccQualifiedCurve& gccc2, const GccQualifiedCurve& gccl)
	{
		std::stringstream output;
		GccCircle3Tangent gcc(gccc1, gccc2, gccl, Precision::Confusion(), 0.0, 0.0, 0.0);
		std::cout << "Test case: " << GccEntity::PositionToString(gccc1.Qualifier()) << ' ' << GccEntity::PositionToString(gccc2.Qualifier()) << ' ' << GccEntity::PositionToString(gccl.Qualifier()) << std::endl;
		std::cout << "Solution: " << gcc.NSolutions() << std::endl;
		output << "Test case: " << GccEntity::PositionToString(gccc1.Qualifier()) << ' ' << GccEntity::PositionToString(gccc2.Qualifier()) << ' ' << GccEntity::PositionToString(gccl.Qualifier()) << std::endl;
		output << "Solution: " << gcc.NSolutions() << std::endl;
		if (gcc.IsDone())
		{
			for (int i = 0; i < gcc.NSolutions(); i++)
			{
				GccPosition q1, q2, q3;
				gcc.Qualifier(i, q1, q2, q3);
				output << i << ": " << *MakeGeom2Circle(gcc.Solution(i)).Value() << std::endl;
				output << "  " << GccEntity::PositionToString(q1) << ' ' << GccEntity::PositionToString(q2) << ' ' << GccEntity::PositionToString(q3) << std::endl;
			}
		}
		else
		{
			std::cout << "gcc.IsDone is False" << std::endl;
			output << "gcc.IsDone is False" << std::endl;
		}
		return output.str();
	};
	auto case1 = c3t(circle1Enclosed, circle2Enclosed, lineEnclosed);
	auto expect1 = "Test case: Enclosed Enclosed Enclosed\nSolution: 0\n";
	CHECK(case1.find(expect1) != std::string::npos);
	auto case2 = c3t(circle1Enclosed, circle2Enclosed, lineOutside);
	auto expect2 = "Test case: Enclosed Enclosed Outside\nSolution: 0\n";
	CHECK(case2.find(expect2) != std::string::npos);
	auto case3 = c3t(circle1Enclosed, circle2Enclosed, lineUnqualified);
	auto expect3 = "Test case: Enclosed Enclosed Unqualified\nSolution: 0\n";
	CHECK(case3.find(expect3) != std::string::npos);
	auto case4 = c3t(circle1Enclosed, circle2Enclosing, lineEnclosed);
	auto expect4 = "Test case: Enclosed Enclosing Enclosed\nSolution: 0\n";
	CHECK(case4.find(expect4) != std::string::npos);
	auto case5 = c3t(circle1Enclosed, circle2Enclosing, lineOutside);
	auto expect5 = "Test case: Enclosed Enclosing Outside\nSolution: 0\n";
	CHECK(case5.find(expect5) != std::string::npos);
	auto case6 = c3t(circle1Enclosed, circle2Enclosing, lineUnqualified);
	auto expect6 = "Test case: Enclosed Enclosing Unqualified\nSolution: 0\n";
	CHECK(case6.find(expect6) != std::string::npos);
	auto case7 = c3t(circle1Enclosed, circle2Outside, lineEnclosed);
	auto expect7 = "Test case: Enclosed Outside Enclosed\nSolution: 0\n";
	CHECK(case7.find(expect7) != std::string::npos);
	auto case8 = c3t(circle1Enclosed, circle2Outside, lineOutside);
	auto expect8 = "Test case: Enclosed Outside Outside\nSolution: 0\n";
	CHECK(case8.find(expect8) != std::string::npos);
	auto case9 = c3t(circle1Enclosed, circle2Outside, lineUnqualified);
	auto expect9 = "Test case: Enclosed Outside Unqualified\nSolution: 0\n";
	CHECK(case9.find(expect9) != std::string::npos);
	auto case10 = c3t(circle1Enclosed, circle2Unqualified, lineEnclosed);
	auto expect10 = "Test case: Enclosed Unqualified Enclosed\nSolution: 0\n";
	CHECK(case10.find(expect10) != std::string::npos);
	auto case11 = c3t(circle1Enclosed, circle2Unqualified, lineOutside);
	auto expect11 = "Test case: Enclosed Unqualified Outside\nSolution: 0\n";
	CHECK(case11.find(expect11) != std::string::npos);
	auto case12 = c3t(circle1Enclosed, circle2Unqualified, lineUnqualified);
	auto expect12 = "Test case: Enclosed Unqualified Unqualified\nSolution: 0\n";
	CHECK(case12.find(expect12) != std::string::npos);
	auto case13 = c3t(circle1Enclosing, circle2Enclosed, lineEnclosed);
	auto expect13 = "Test case: Enclosing Enclosed Enclosed\nSolution: 0\n";
	CHECK(case13.find(expect13) != std::string::npos);
	auto case14 = c3t(circle1Enclosing, circle2Enclosed, lineOutside);
	auto expect14 = "Test case: Enclosing Enclosed Outside\nSolution: 0\n";
	CHECK(case14.find(expect14) != std::string::npos);
	auto case15 = c3t(circle1Enclosing, circle2Enclosed, lineUnqualified);
	auto expect15 = "Test case: Enclosing Enclosed Unqualified\nSolution: 0\n";
	CHECK(case15.find(expect15) != std::string::npos);
	auto case16 = c3t(circle1Enclosing, circle2Enclosing, lineEnclosed);
	auto expect16 = "Test case: Enclosing Enclosing Enclosed\nSolution: 1\n0: 2 2 4.5 1 0 -0 1 4.5\n  Enclosing Enclosing Enclosed\n";
	CHECK(case16.find(expect16) != std::string::npos);
	auto case17 = c3t(circle1Enclosing, circle2Enclosing, lineOutside);
	auto expect17 = "Test case: Enclosing Enclosing Outside\nSolution: 0\n";
	CHECK(case17.find(expect17) != std::string::npos);
	auto case18 = c3t(circle1Enclosing, circle2Enclosing, lineUnqualified);
	auto expect18 = "Test case: Enclosing Enclosing Unqualified\nSolution: 1\n0: 2 2 4.5 1 0 -0 1 4.5\n  Enclosing Enclosing Enclosed\n";
	CHECK(case18.find(expect18) != std::string::npos);
	auto case19 = c3t(circle1Enclosing, circle2Outside, lineEnclosed);
	auto expect19 = "Test case: Enclosing Outside Enclosed\nSolution: 1\n0: 2 -1 3 1 0 -0 1 3\n  Enclosing Outside Enclosed\n";
	CHECK(case19.find(expect19) != std::string::npos);
	auto case20 = c3t(circle1Enclosing, circle2Outside, lineOutside);
	auto expect20 = "Test case: Enclosing Outside Outside\nSolution: 0\n";
	CHECK(case20.find(expect20) != std::string::npos);
	auto case21 = c3t(circle1Enclosing, circle2Outside, lineUnqualified);
	auto expect21 = "Test case: Enclosing Outside Unqualified\nSolution: 1\n0: 2 -1 3 1 0 -0 1 3\n  Enclosing Outside Enclosed\n";
	CHECK(case21.find(expect21) != std::string::npos);
	auto case22 = c3t(circle1Enclosing, circle2Unqualified, lineEnclosed);
	auto expect22 = "Test case: Enclosing Unqualified Enclosed\nSolution: 2\n0: 2 -1 3 1 0 -0 1 3\n  Enclosing Outside Enclosed\n1: 2 2 4.5 1 0 -0 1 4.5\n  Enclosing Enclosing Enclosed\n";
	CHECK(case22.find(expect22) != std::string::npos);
	auto case23 = c3t(circle1Enclosing, circle2Unqualified, lineOutside);
	auto expect23 = "Test case: Enclosing Unqualified Outside\nSolution: 0\n";
	CHECK(case23.find(expect23) != std::string::npos);
	auto case24 = c3t(circle1Enclosing, circle2Unqualified, lineUnqualified);
	auto expect24 = "Test case: Enclosing Unqualified Unqualified\nSolution: 2\n0: 2 -1 3 1 0 -0 1 3\n  Enclosing Outside Enclosed\n1: 2 2 4.5 1 0 -0 1 4.5\n  Enclosing Enclosing Enclosed\n";
	CHECK(case24.find(expect24) != std::string::npos);
	auto case25 = c3t(circle1Outside, circle2Enclosed, lineEnclosed);
	auto expect25 = "Test case: Outside Enclosed Enclosed\nSolution: 0\n";
	CHECK(case25.find(expect25) != std::string::npos);
	auto case26 = c3t(circle1Outside, circle2Enclosed, lineOutside);
	auto expect26 = "Test case: Outside Enclosed Outside\nSolution: 0\n";
	CHECK(case26.find(expect26) != std::string::npos);
	auto case27 = c3t(circle1Outside, circle2Enclosed, lineUnqualified);
	auto expect27 = "Test case: Outside Enclosed Unqualified\nSolution: 0\n";
	CHECK(case27.find(expect27) != std::string::npos);
	auto case28 = c3t(circle1Outside, circle2Enclosing, lineEnclosed);
	auto expect28 = "Test case: Outside Enclosing Enclosed\nSolution: 1\n0: 2 5 3 1 0 -0 1 3\n  Outside Enclosing Enclosed\n";
	CHECK(case28.find(expect28) != std::string::npos);
	auto case29 = c3t(circle1Outside, circle2Enclosing, lineOutside);
	auto expect29 = "Test case: Outside Enclosing Outside\nSolution: 0\n";
	CHECK(case29.find(expect29) != std::string::npos);
	auto case30 = c3t(circle1Outside, circle2Enclosing, lineUnqualified);
	auto expect30 = "Test case: Outside Enclosing Unqualified\nSolution: 1\n0: 2 5 3 1 0 -0 1 3\n  Outside Enclosing Enclosed\n";
	CHECK(case30.find(expect30) != std::string::npos);
	auto case31 = c3t(circle1Outside, circle2Outside, lineEnclosed);
	auto expect31 = "Test case: Outside Outside Enclosed\nSolution: 1\n0: 2 2 0.9 1 0 -0 1 0.9\n  Outside Outside Enclosed\n";
	CHECK(case31.find(expect31) != std::string::npos);
	auto case32 = c3t(circle1Outside, circle2Outside, lineOutside);
	auto expect32 = "Test case: Outside Outside Outside\nSolution: 0\n";
	CHECK(case32.find(expect32) != std::string::npos);
	auto case33 = c3t(circle1Outside, circle2Outside, lineUnqualified);
	auto expect33 = "Test case: Outside Outside Unqualified\nSolution: 1\n0: 2 2 0.9 1 0 -0 1 0.9\n  Outside Outside Enclosed\n";
	CHECK(case33.find(expect33) != std::string::npos);
	auto case34 = c3t(circle1Outside, circle2Unqualified, lineEnclosed);
	auto expect34 = "Test case: Outside Unqualified Enclosed\nSolution: 2\n0: 2 2 0.9 1 0 -0 1 0.9\n  Outside Outside Enclosed\n1: 2 5 3 1 0 -0 1 3\n  Outside Enclosing Enclosed\n";
	CHECK(case34.find(expect34) != std::string::npos);
	auto case35 = c3t(circle1Outside, circle2Unqualified, lineOutside);
	auto expect35 = "Test case: Outside Unqualified Outside\nSolution: 0\n";
	CHECK(case35.find(expect35) != std::string::npos);
	auto case36 = c3t(circle1Outside, circle2Unqualified, lineUnqualified);
	auto expect36 = "Test case: Outside Unqualified Unqualified\nSolution: 2\n0: 2 2 0.9 1 0 -0 1 0.9\n  Outside Outside Enclosed\n1: 2 5 3 1 0 -0 1 3\n  Outside Enclosing Enclosed\n";
	CHECK(case36.find(expect36) != std::string::npos);
	auto case37 = c3t(circle1Unqualified, circle2Enclosed, lineEnclosed);
	auto expect37 = "Test case: Unqualified Enclosed Enclosed\nSolution: 0\n";
	CHECK(case37.find(expect37) != std::string::npos);
	auto case38 = c3t(circle1Unqualified, circle2Enclosed, lineOutside);
	auto expect38 = "Test case: Unqualified Enclosed Outside\nSolution: 0\n";
	CHECK(case38.find(expect38) != std::string::npos);
	auto case39 = c3t(circle1Unqualified, circle2Enclosed, lineUnqualified);
	auto expect39 = "Test case: Unqualified Enclosed Unqualified\nSolution: 0\n";
	CHECK(case39.find(expect39) != std::string::npos);
	auto case40 = c3t(circle1Unqualified, circle2Enclosing, lineEnclosed);
	auto expect40 = "Test case: Unqualified Enclosing Enclosed\nSolution: 2\n0: 2 5 3 1 0 -0 1 3\n  Outside Enclosing Enclosed\n1: 2 2 4.5 1 0 -0 1 4.5\n  Enclosing Enclosing Enclosed\n";
	CHECK(case40.find(expect40) != std::string::npos);
	auto case41 = c3t(circle1Unqualified, circle2Enclosing, lineOutside);
	auto expect41 = "Test case: Unqualified Enclosing Outside\nSolution: 0\n";
	CHECK(case41.find(expect41) != std::string::npos);
	auto case42 = c3t(circle1Unqualified, circle2Enclosing, lineUnqualified);
	auto expect42 = "Test case: Unqualified Enclosing Unqualified\nSolution: 2\n0: 2 5 3 1 0 -0 1 3\n  Outside Enclosing Enclosed\n1: 2 2 4.5 1 0 -0 1 4.5\n  Enclosing Enclosing Enclosed\n";
	CHECK(case42.find(expect42) != std::string::npos);
	auto case43 = c3t(circle1Unqualified, circle2Outside, lineEnclosed);
	auto expect43 = "Test case: Unqualified Outside Enclosed\nSolution: 2\n0: 2 2 0.9 1 0 -0 1 0.9\n  Outside Outside Enclosed\n1: 2 -1 3 1 0 -0 1 3\n  Enclosing Outside Enclosed\n";
	CHECK(case43.find(expect43) != std::string::npos);
	auto case44 = c3t(circle1Unqualified, circle2Outside, lineOutside);
	auto expect44 = "Test case: Unqualified Outside Outside\nSolution: 0\n";
	CHECK(case44.find(expect44) != std::string::npos);
	auto case45 = c3t(circle1Unqualified, circle2Outside, lineUnqualified);
	auto expect45 = "Test case: Unqualified Outside Unqualified\nSolution: 2\n0: 2 2 0.9 1 0 -0 1 0.9\n  Outside Outside Enclosed\n1: 2 -1 3 1 0 -0 1 3\n  Enclosing Outside Enclosed\n";
	CHECK(case45.find(expect45) != std::string::npos);
	auto case46 = c3t(circle1Unqualified, circle2Unqualified, lineEnclosed);
	auto expect46 = "Test case: Unqualified Unqualified Enclosed\nSolution: 4\n0: 2 2 0.9 1 0 -0 1 0.9\n  Outside Outside Enclosed\n1: 2 5 3 1 0 -0 1 3\n  Outside Enclosing Enclosed\n2: 2 -1 3 1 0 -0 1 3\n  Enclosing Outside Enclosed\n3: 2 2 4.5 1 0 -0 1 4.5\n  Enclosing Enclosing Enclosed\n";
	CHECK(case46.find(expect46) != std::string::npos);
	auto case47 = c3t(circle1Unqualified, circle2Unqualified, lineOutside);
	auto expect47 = "Test case: Unqualified Unqualified Outside\nSolution: 0\n";
	CHECK(case47.find(expect47) != std::string::npos);
	auto case48 = c3t(circle1Unqualified, circle2Unqualified, lineUnqualified);
	auto expect48 = "Test case: Unqualified Unqualified Unqualified\nSolution: 4\n0: 2 2 0.9 1 0 -0 1 0.9\n  Outside Outside Enclosed\n1: 2 5 3 1 0 -0 1 3\n  Outside Enclosing Enclosed\n2: 2 -1 3 1 0 -0 1 3\n  Enclosing Outside Enclosed\n3: 2 2 4.5 1 0 -0 1 4.5\n  Enclosing Enclosing Enclosed";
	CHECK(case48.find(expect48) != std::string::npos);
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API GccCircle3Tangent(const Point2& point1, const Point2& point2, const Point2& point3, double tolerance)	 @param tolerance The tolerance
	 @param point3 The third point
	 @param point2 The second point
	 @param point1 The first point
	 @brief Construct a circle passing through three points
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <geomAlgo/GccCircle3Tangent.hpp>
#include <geometry/Geom2Curve.hpp>
#include <geometry/MakeGeom2Line.hpp>
#include <geometry/MakeGeom2Circle.hpp>
#include <geomAlgo/GccEntity.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geomAlgo/GccEntity.hpp>
#include <geomAlgo/GccQualifiedCurve.hpp>
#include <sstream>
using namespace AMCAX;
TEST_CASE("bug1: GccCircle3Tangent  add 48 cases", "[geomAlgo][GccCircle3Tangent][fixbug]") {
	std::shared_ptr<Geom2Curve> l = MakeGeom2Line(Point2(0.0, 0.0), Point2(1.0, 0.0)).Value();
	std::shared_ptr<Geom2Curve> c1 = MakeGeom2Circle(Point2(0.0, 3.0), 2.0).Value();
	std::shared_ptr<Geom2Curve> c2 = MakeGeom2Circle(Point2(4.0, 3.0), 2.0).Value();
	AdaptorGeom2Curve line(l);
	AdaptorGeom2Curve circle1(c1);
	AdaptorGeom2Curve circle2(c2);
	auto lineEnclosed = GccEntity::Enclosed(line);
	auto lineOutside = GccEntity::Outside(line);
	auto lineUnqualified = GccEntity::Unqualified(line);
	auto circle1Enclosed = GccEntity::Enclosed(circle1);
	auto circle1Enclosing = GccEntity::Enclosing(circle1);
	auto circle1Outside = GccEntity::Outside(circle1);
	auto circle1Unqualified = GccEntity::Unqualified(circle1);
	auto circle2Enclosed = GccEntity::Enclosed(circle2);
	auto circle2Enclosing = GccEntity::Enclosing(circle2);
	auto circle2Outside = GccEntity::Outside(circle2);
	auto circle2Unqualified = GccEntity::Unqualified(circle2);
	auto gccl = GccEntity::Enclosed(AdaptorGeom2Curve(l));
	auto gccc1 = GccEntity::Enclosing(AdaptorGeom2Curve(c1));
	auto gccc2 = GccEntity::Outside(AdaptorGeom2Curve(c2));
	auto c3t = [](const GccQualifiedCurve& gccc1, const GccQualifiedCurve& gccc2, const GccQualifiedCurve& gccl)
	{
		std::stringstream output;
		GccCircle3Tangent gcc(gccc1, gccc2, gccl, Precision::Confusion(), 0.0, 0.0, 0.0);
		std::cout << "Test case: " << GccEntity::PositionToString(gccc1.Qualifier()) << ' ' << GccEntity::PositionToString(gccc2.Qualifier()) << ' ' << GccEntity::PositionToString(gccl.Qualifier()) << std::endl;
		std::cout << "Solution: " << gcc.NSolutions() << std::endl;
		output << "Test case: " << GccEntity::PositionToString(gccc1.Qualifier()) << ' ' << GccEntity::PositionToString(gccc2.Qualifier()) << ' ' << GccEntity::PositionToString(gccl.Qualifier()) << std::endl;
		output << "Solution: " << gcc.NSolutions() << std::endl;
		if (gcc.IsDone())
		{
			for (int i = 0; i < gcc.NSolutions(); i++)
			{
				GccPosition q1, q2, q3;
				gcc.Qualifier(i, q1, q2, q3);
				output << i << ": " << *MakeGeom2Circle(gcc.Solution(i)).Value() << std::endl;
				output << "  " << GccEntity::PositionToString(q1) << ' ' << GccEntity::PositionToString(q2) << ' ' << GccEntity::PositionToString(q3) << std::endl;
			}
		}
		else
		{
			std::cout << "gcc.IsDone is False" << std::endl;
			output << "gcc.IsDone is False" << std::endl;
		}
		return output.str();
	};
	auto case1 = c3t(circle1Enclosed, circle2Enclosed, lineEnclosed);
	auto expect1 = "Test case: Enclosed Enclosed Enclosed\nSolution: 0\n";
	CHECK(case1.find(expect1) != std::string::npos);
	auto case2 = c3t(circle1Enclosed, circle2Enclosed, lineOutside);
	auto expect2 = "Test case: Enclosed Enclosed Outside\nSolution: 0\n";
	CHECK(case2.find(expect2) != std::string::npos);
	auto case3 = c3t(circle1Enclosed, circle2Enclosed, lineUnqualified);
	auto expect3 = "Test case: Enclosed Enclosed Unqualified\nSolution: 0\n";
	CHECK(case3.find(expect3) != std::string::npos);
	auto case4 = c3t(circle1Enclosed, circle2Enclosing, lineEnclosed);
	auto expect4 = "Test case: Enclosed Enclosing Enclosed\nSolution: 0\n";
	CHECK(case4.find(expect4) != std::string::npos);
	auto case5 = c3t(circle1Enclosed, circle2Enclosing, lineOutside);
	auto expect5 = "Test case: Enclosed Enclosing Outside\nSolution: 0\n";
	CHECK(case5.find(expect5) != std::string::npos);
	auto case6 = c3t(circle1Enclosed, circle2Enclosing, lineUnqualified);
	auto expect6 = "Test case: Enclosed Enclosing Unqualified\nSolution: 0\n";
	CHECK(case6.find(expect6) != std::string::npos);
	auto case7 = c3t(circle1Enclosed, circle2Outside, lineEnclosed);
	auto expect7 = "Test case: Enclosed Outside Enclosed\nSolution: 0\n";
	CHECK(case7.find(expect7) != std::string::npos);
	auto case8 = c3t(circle1Enclosed, circle2Outside, lineOutside);
	auto expect8 = "Test case: Enclosed Outside Outside\nSolution: 0\n";
	CHECK(case8.find(expect8) != std::string::npos);
	auto case9 = c3t(circle1Enclosed, circle2Outside, lineUnqualified);
	auto expect9 = "Test case: Enclosed Outside Unqualified\nSolution: 0\n";
	CHECK(case9.find(expect9) != std::string::npos);
	auto case10 = c3t(circle1Enclosed, circle2Unqualified, lineEnclosed);
	auto expect10 = "Test case: Enclosed Unqualified Enclosed\nSolution: 0\n";
	CHECK(case10.find(expect10) != std::string::npos);
	auto case11 = c3t(circle1Enclosed, circle2Unqualified, lineOutside);
	auto expect11 = "Test case: Enclosed Unqualified Outside\nSolution: 0\n";
	CHECK(case11.find(expect11) != std::string::npos);
	auto case12 = c3t(circle1Enclosed, circle2Unqualified, lineUnqualified);
	auto expect12 = "Test case: Enclosed Unqualified Unqualified\nSolution: 0\n";
	CHECK(case12.find(expect12) != std::string::npos);
	auto case13 = c3t(circle1Enclosing, circle2Enclosed, lineEnclosed);
	auto expect13 = "Test case: Enclosing Enclosed Enclosed\nSolution: 0\n";
	CHECK(case13.find(expect13) != std::string::npos);
	auto case14 = c3t(circle1Enclosing, circle2Enclosed, lineOutside);
	auto expect14 = "Test case: Enclosing Enclosed Outside\nSolution: 0\n";
	CHECK(case14.find(expect14) != std::string::npos);
	auto case15 = c3t(circle1Enclosing, circle2Enclosed, lineUnqualified);
	auto expect15 = "Test case: Enclosing Enclosed Unqualified\nSolution: 0\n";
	CHECK(case15.find(expect15) != std::string::npos);
	auto case16 = c3t(circle1Enclosing, circle2Enclosing, lineEnclosed);
	auto expect16 = "Test case: Enclosing Enclosing Enclosed\nSolution: 1\n0: 2 2 4.5 1 0 -0 1 4.5\n  Enclosing Enclosing Enclosed\n";
	CHECK(case16.find(expect16) != std::string::npos);
	auto case17 = c3t(circle1Enclosing, circle2Enclosing, lineOutside);
	auto expect17 = "Test case: Enclosing Enclosing Outside\nSolution: 0\n";
	CHECK(case17.find(expect17) != std::string::npos);
	auto case18 = c3t(circle1Enclosing, circle2Enclosing, lineUnqualified);
	auto expect18 = "Test case: Enclosing Enclosing Unqualified\nSolution: 1\n0: 2 2 4.5 1 0 -0 1 4.5\n  Enclosing Enclosing Enclosed\n";
	CHECK(case18.find(expect18) != std::string::npos);
	auto case19 = c3t(circle1Enclosing, circle2Outside, lineEnclosed);
	auto expect19 = "Test case: Enclosing Outside Enclosed\nSolution: 1\n0: 2 -1 3 1 0 -0 1 3\n  Enclosing Outside Enclosed\n";
	CHECK(case19.find(expect19) != std::string::npos);
	auto case20 = c3t(circle1Enclosing, circle2Outside, lineOutside);
	auto expect20 = "Test case: Enclosing Outside Outside\nSolution: 0\n";
	CHECK(case20.find(expect20) != std::string::npos);
	auto case21 = c3t(circle1Enclosing, circle2Outside, lineUnqualified);
	auto expect21 = "Test case: Enclosing Outside Unqualified\nSolution: 1\n0: 2 -1 3 1 0 -0 1 3\n  Enclosing Outside Enclosed\n";
	CHECK(case21.find(expect21) != std::string::npos);
	auto case22 = c3t(circle1Enclosing, circle2Unqualified, lineEnclosed);
	auto expect22 = "Test case: Enclosing Unqualified Enclosed\nSolution: 2\n0: 2 -1 3 1 0 -0 1 3\n  Enclosing Outside Enclosed\n1: 2 2 4.5 1 0 -0 1 4.5\n  Enclosing Enclosing Enclosed\n";
	CHECK(case22.find(expect22) != std::string::npos);
	auto case23 = c3t(circle1Enclosing, circle2Unqualified, lineOutside);
	auto expect23 = "Test case: Enclosing Unqualified Outside\nSolution: 0\n";
	CHECK(case23.find(expect23) != std::string::npos);
	auto case24 = c3t(circle1Enclosing, circle2Unqualified, lineUnqualified);
	auto expect24 = "Test case: Enclosing Unqualified Unqualified\nSolution: 2\n0: 2 -1 3 1 0 -0 1 3\n  Enclosing Outside Enclosed\n1: 2 2 4.5 1 0 -0 1 4.5\n  Enclosing Enclosing Enclosed\n";
	CHECK(case24.find(expect24) != std::string::npos);
	auto case25 = c3t(circle1Outside, circle2Enclosed, lineEnclosed);
	auto expect25 = "Test case: Outside Enclosed Enclosed\nSolution: 0\n";
	CHECK(case25.find(expect25) != std::string::npos);
	auto case26 = c3t(circle1Outside, circle2Enclosed, lineOutside);
	auto expect26 = "Test case: Outside Enclosed Outside\nSolution: 0\n";
	CHECK(case26.find(expect26) != std::string::npos);
	auto case27 = c3t(circle1Outside, circle2Enclosed, lineUnqualified);
	auto expect27 = "Test case: Outside Enclosed Unqualified\nSolution: 0\n";
	CHECK(case27.find(expect27) != std::string::npos);
	auto case28 = c3t(circle1Outside, circle2Enclosing, lineEnclosed);
	auto expect28 = "Test case: Outside Enclosing Enclosed\nSolution: 1\n0: 2 5 3 1 0 -0 1 3\n  Outside Enclosing Enclosed\n";
	CHECK(case28.find(expect28) != std::string::npos);
	auto case29 = c3t(circle1Outside, circle2Enclosing, lineOutside);
	auto expect29 = "Test case: Outside Enclosing Outside\nSolution: 0\n";
	CHECK(case29.find(expect29) != std::string::npos);
	auto case30 = c3t(circle1Outside, circle2Enclosing, lineUnqualified);
	auto expect30 = "Test case: Outside Enclosing Unqualified\nSolution: 1\n0: 2 5 3 1 0 -0 1 3\n  Outside Enclosing Enclosed\n";
	CHECK(case30.find(expect30) != std::string::npos);
	auto case31 = c3t(circle1Outside, circle2Outside, lineEnclosed);
	auto expect31 = "Test case: Outside Outside Enclosed\nSolution: 1\n0: 2 2 0.9 1 0 -0 1 0.9\n  Outside Outside Enclosed\n";
	CHECK(case31.find(expect31) != std::string::npos);
	auto case32 = c3t(circle1Outside, circle2Outside, lineOutside);
	auto expect32 = "Test case: Outside Outside Outside\nSolution: 0\n";
	CHECK(case32.find(expect32) != std::string::npos);
	auto case33 = c3t(circle1Outside, circle2Outside, lineUnqualified);
	auto expect33 = "Test case: Outside Outside Unqualified\nSolution: 1\n0: 2 2 0.9 1 0 -0 1 0.9\n  Outside Outside Enclosed\n";
	CHECK(case33.find(expect33) != std::string::npos);
	auto case34 = c3t(circle1Outside, circle2Unqualified, lineEnclosed);
	auto expect34 = "Test case: Outside Unqualified Enclosed\nSolution: 2\n0: 2 2 0.9 1 0 -0 1 0.9\n  Outside Outside Enclosed\n1: 2 5 3 1 0 -0 1 3\n  Outside Enclosing Enclosed\n";
	CHECK(case34.find(expect34) != std::string::npos);
	auto case35 = c3t(circle1Outside, circle2Unqualified, lineOutside);
	auto expect35 = "Test case: Outside Unqualified Outside\nSolution: 0\n";
	CHECK(case35.find(expect35) != std::string::npos);
	auto case36 = c3t(circle1Outside, circle2Unqualified, lineUnqualified);
	auto expect36 = "Test case: Outside Unqualified Unqualified\nSolution: 2\n0: 2 2 0.9 1 0 -0 1 0.9\n  Outside Outside Enclosed\n1: 2 5 3 1 0 -0 1 3\n  Outside Enclosing Enclosed\n";
	CHECK(case36.find(expect36) != std::string::npos);
	auto case37 = c3t(circle1Unqualified, circle2Enclosed, lineEnclosed);
	auto expect37 = "Test case: Unqualified Enclosed Enclosed\nSolution: 0\n";
	CHECK(case37.find(expect37) != std::string::npos);
	auto case38 = c3t(circle1Unqualified, circle2Enclosed, lineOutside);
	auto expect38 = "Test case: Unqualified Enclosed Outside\nSolution: 0\n";
	CHECK(case38.find(expect38) != std::string::npos);
	auto case39 = c3t(circle1Unqualified, circle2Enclosed, lineUnqualified);
	auto expect39 = "Test case: Unqualified Enclosed Unqualified\nSolution: 0\n";
	CHECK(case39.find(expect39) != std::string::npos);
	auto case40 = c3t(circle1Unqualified, circle2Enclosing, lineEnclosed);
	auto expect40 = "Test case: Unqualified Enclosing Enclosed\nSolution: 2\n0: 2 5 3 1 0 -0 1 3\n  Outside Enclosing Enclosed\n1: 2 2 4.5 1 0 -0 1 4.5\n  Enclosing Enclosing Enclosed\n";
	CHECK(case40.find(expect40) != std::string::npos);
	auto case41 = c3t(circle1Unqualified, circle2Enclosing, lineOutside);
	auto expect41 = "Test case: Unqualified Enclosing Outside\nSolution: 0\n";
	CHECK(case41.find(expect41) != std::string::npos);
	auto case42 = c3t(circle1Unqualified, circle2Enclosing, lineUnqualified);
	auto expect42 = "Test case: Unqualified Enclosing Unqualified\nSolution: 2\n0: 2 5 3 1 0 -0 1 3\n  Outside Enclosing Enclosed\n1: 2 2 4.5 1 0 -0 1 4.5\n  Enclosing Enclosing Enclosed\n";
	CHECK(case42.find(expect42) != std::string::npos);
	auto case43 = c3t(circle1Unqualified, circle2Outside, lineEnclosed);
	auto expect43 = "Test case: Unqualified Outside Enclosed\nSolution: 2\n0: 2 2 0.9 1 0 -0 1 0.9\n  Outside Outside Enclosed\n1: 2 -1 3 1 0 -0 1 3\n  Enclosing Outside Enclosed\n";
	CHECK(case43.find(expect43) != std::string::npos);
	auto case44 = c3t(circle1Unqualified, circle2Outside, lineOutside);
	auto expect44 = "Test case: Unqualified Outside Outside\nSolution: 0\n";
	CHECK(case44.find(expect44) != std::string::npos);
	auto case45 = c3t(circle1Unqualified, circle2Outside, lineUnqualified);
	auto expect45 = "Test case: Unqualified Outside Unqualified\nSolution: 2\n0: 2 2 0.9 1 0 -0 1 0.9\n  Outside Outside Enclosed\n1: 2 -1 3 1 0 -0 1 3\n  Enclosing Outside Enclosed\n";
	CHECK(case45.find(expect45) != std::string::npos);
	auto case46 = c3t(circle1Unqualified, circle2Unqualified, lineEnclosed);
	auto expect46 = "Test case: Unqualified Unqualified Enclosed\nSolution: 4\n0: 2 2 0.9 1 0 -0 1 0.9\n  Outside Outside Enclosed\n1: 2 5 3 1 0 -0 1 3\n  Outside Enclosing Enclosed\n2: 2 -1 3 1 0 -0 1 3\n  Enclosing Outside Enclosed\n3: 2 2 4.5 1 0 -0 1 4.5\n  Enclosing Enclosing Enclosed\n";
	CHECK(case46.find(expect46) != std::string::npos);
	auto case47 = c3t(circle1Unqualified, circle2Unqualified, lineOutside);
	auto expect47 = "Test case: Unqualified Unqualified Outside\nSolution: 0\n";
	CHECK(case47.find(expect47) != std::string::npos);
	auto case48 = c3t(circle1Unqualified, circle2Unqualified, lineUnqualified);
	auto expect48 = "Test case: Unqualified Unqualified Unqualified\nSolution: 4\n0: 2 2 0.9 1 0 -0 1 0.9\n  Outside Outside Enclosed\n1: 2 5 3 1 0 -0 1 3\n  Outside Enclosing Enclosed\n2: 2 -1 3 1 0 -0 1 3\n  Enclosing Outside Enclosed\n3: 2 2 4.5 1 0 -0 1 4.5\n  Enclosing Enclosing Enclosed";
	CHECK(case48.find(expect48) != std::string::npos);
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API virtual void D1(double x, double& f, double& d)	 @param[out] d The function first derivative
	 @param[out] f The function value
	 @param[in] x The given parameter
	 @brief Get the function first derivative at the given parameter
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include<geomAlgo/LawConstant.hpp>
#include<geomAlgo/LawFunction.hpp>
using namespace std;
TEST_CASE("case1: this is a test case for LawConstant", "[geomAlgo][LawFunction][P1]")
{
	LawConstant cons;
	cons.Set(2.0, 4.0, 10.0);
	SECTION("D1")
	{
		double x = 1.0;
		double f = 0.0; 
		double d = 0.0;
		cons.D1(x, f, d);
		CHECK(f == Approx(2.0));
		CHECK(d == Approx(0.0));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API virtual std::shared_ptr<LawFunction> Trim(double fp, double lp, double tol)	 @return The new law
	 @param tol The given tolerance, not all laws use this parameter
	 @param lp The second parameter
	 @param fp The first parameter
	 @brief Get the trimmed law of this
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include<geomAlgo/LawConstant.hpp>
#include<geomAlgo/LawFunction.hpp>
using namespace std;
TEST_CASE("case1: this is a test case for LawConstant", "[geomAlgo][LawFunction][P1]")
{
	LawConstant cons;
	cons.Set(2.0, 4.0, 10.0);
	SECTION("Trim")
	{
		shared_ptr<LawFunction>tr;
		double fp = 1.0;
		double lp = 5.0;
		double tol = 0.1;
		double fp1 = 0.0;
		double lp1 = 0.0;
		tr = cons.Trim(fp, lp, tol);
		tr->Bounds(fp1, lp1);
		CHECK(fp1 == fp);
		CHECK(lp1 == lp);
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":explicit Conic2Constraint(const Point2& point)	 @param point The point constraint
	 @brief Construct from a point constraint
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <geomAlgo/MakeConic2FromConstraints.hpp>
#include <geometry/GeometryTool.hpp>
#include <math/HyperbolaT.hpp>
#include <geometry/Geom2Hyperbola.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <modeling/MakeEdge.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/Geom2Circle.hpp>
#include <geometry/GeomAPIProjectPointOnCurve3.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeEdge.hpp>
TEST_CASE("bug1: MakeConic2FromConstraints ", "[geomAlgo][MakeConic2FromConstraints][fixbug]")
{
	Point2 a(0.0, 0.0);
	Point2 b(1.0, 1.0);
	Vector2 da(-0.5, 0.5);
	Vector2 db(1.0, -0.2);
	Point3 a1(a.X(), a.Y(), 0.0);
	Point3 b1(b.X(), b.Y(), 0.0);
	Vector3 da1(da.X(), da.Y(), 0.0);
	Vector3 db1(db.X(), db.Y(), 0.0);
	Conic2Constraint ca(a, da);
	Conic2Constraint cb(b, db);
	MakeConic2FromConstraints mc2fc(ca, cb, 0.0);
	shared_ptr<Geom3Curve> curve;
	curve = GeometryTool::To3d(Frame3(), mc2fc.Curve2d());
	CHECK(mc2fc.Curve2d() == nullptr);
	CHECK(curve == nullptr);
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API MakeConic2FromConstraints(const Conic2Constraint& startConstraint, const Conic2Constraint& endConstraint, double parameter)	 @param parameter The parameter to determine type and shape of the conic, valid range is (0.0, 1.0): ellipse if (0.0, 0.5), parabola if {0.5}, hyperbola if (0.5, 1.0)
	 @param endConstraint The end point and tangent
	 @param startConstraint The start point and tangent
	 @brief Build by ending points and tangents and a parameter
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <geomAlgo/MakeConic2FromConstraints.hpp>
#include <geometry/GeometryTool.hpp>
#include <math/HyperbolaT.hpp>
#include <geometry/Geom2Hyperbola.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <modeling/MakeEdge.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/Geom2Circle.hpp>
#include <geometry/GeomAPIProjectPointOnCurve3.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeEdge.hpp>
TEST_CASE("bug1: MakeConic2FromConstraints ", "[geomAlgo][MakeConic2FromConstraints][fixbug]")
{
	Point2 a(0.0, 0.0);
	Point2 b(1.0, 1.0);
	Vector2 da(-0.5, 0.5);
	Vector2 db(1.0, -0.2);
	Point3 a1(a.X(), a.Y(), 0.0);
	Point3 b1(b.X(), b.Y(), 0.0);
	Vector3 da1(da.X(), da.Y(), 0.0);
	Vector3 db1(db.X(), db.Y(), 0.0);
	Conic2Constraint ca(a, da);
	Conic2Constraint cb(b, db);
	MakeConic2FromConstraints mc2fc(ca, cb, 0.0);
	shared_ptr<Geom3Curve> curve;
	curve = GeometryTool::To3d(Frame3(), mc2fc.Curve2d());
	CHECK(mc2fc.Curve2d() == nullptr);
	CHECK(curve == nullptr);
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API explicit MakeConic2FromConstraints(const std::vector<Conic2Constraint>& constraints)	 @param constraints The constraints of the conic. It is supported that the constraints contain 5 points, 4 points and 1 tangent, 3 points and 2 tangent
	 @brief Build by point and tangent constraints. The number of constraints must be 5 in total and the start and the end point constraints are required
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <geomAlgo/MakeConic2FromConstraints.hpp>
#include <geometry/GeometryTool.hpp>
#include <math/HyperbolaT.hpp>
#include <geometry/Geom2Hyperbola.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <modeling/MakeEdge.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/Geom2Circle.hpp>
#include <geometry/GeomAPIProjectPointOnCurve3.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeEdge.hpp>
TEST_CASE("bug1: MakeConic2FromConstraints ", "[geomAlgo][MakeConic2FromConstraints][fixbug]")
{
	Point2 a(0.0, 0.0);
	Point2 b(1.0, 1.0);
	Vector2 da(-0.5, 0.5);
	Vector2 db(1.0, -0.2);
	Point3 a1(a.X(), a.Y(), 0.0);
	Point3 b1(b.X(), b.Y(), 0.0);
	Vector3 da1(da.X(), da.Y(), 0.0);
	Vector3 db1(db.X(), db.Y(), 0.0);
	Conic2Constraint ca(a, da);
	Conic2Constraint cb(b, db);
	MakeConic2FromConstraints mc2fc(ca, cb, 0.0);
	shared_ptr<Geom3Curve> curve;
	curve = GeometryTool::To3d(Frame3(), mc2fc.Curve2d());
	CHECK(mc2fc.Curve2d() == nullptr);
	CHECK(curve == nullptr);
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API ComputePointsAbscissa(double tol, const Adaptor3Curve& c, double abscissa, double u0)	 @param u0 The starting parameter
	 @param abscissa The arc length
	 @param c The curve
	 @param tol The tolerance
	 @brief Compute the parameter of a point on a 3D curve with given arc length and a tolerance
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <geometry/MakeGeom2Circle.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/ComputePointsAbscissa.hpp>
#include <geometry/MakeGeom3Circle.hpp>
#include <geometry/AdaptorGeom3Curve.hpp>
#include <geometry/MakeGeom2Hyperbola.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/MakeGeom2Ellipse.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <geometry/MakeGeom3Ellipse.hpp>
#include <geometry/MakeGeom3Hyperbola.hpp>
#include <geometry/Geom2Line.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom3Line.hpp>
#include <geometry/Geom3TrimmedCurve.hpp>
#include<modeling/MakeEdge.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/GeometryTool.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <geometry/MakeGeom2Parabola.hpp>
#include <geometry/MakeGeom3Parabola.hpp>
#include <geometry/Geom2BezierCurve.hpp>
#include <geometry/Geom3BezierCurve.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/Geom2OffsetCurve.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
TEST_CASE("tset the parameters for calculating a point on a 3D curve of a given arc length and the length of the 3D curve.", "[geometry][ComputePointsAbscissa][case5]")
{
	SECTION("circle")
    {
        Frame3 frame;
        double r = 2.0;
        double l = 1.0;
        std::shared_ptr<Geom3Curve> c = MakeGeom3Circle(frame, r).Value();
        AdaptorGeom3Curve circle(c);
        ComputePointsAbscissa cpa(circle, 1.0, 0.0);
        double angle1 = l / r;
        std::cout << "ԲĽǵĻֵΪ" << ": " << angle1 << '\n';
        double x = r * cos(angle1);
        double y = r * sin(angle1);
        double z = 0;
        std::cout << "xֵΪ" << ": " << x << '\n';
        std::cout << "yֵΪ" << ": " << y << '\n';
        std::cout << "zֵΪ" << ": " << z << '\n';
        double param = cpa.Parameter();
        if (cpa.IsDone())
        {
            std::cout << param << ": " << circle.Value(param) << '\n';
        }
        double p = 2 * M_PI * r;
        std::cout << "߳Ϊ" << ComputePointsAbscissa::Length(circle) << '\n';
        Point3 s = circle.Value(param);
        Point3 s1(x, y, z);
        std::cout << s << std::endl;
        CHECK(p == ComputePointsAbscissa::Length(circle));
        CHECK(angle1 == cpa.Parameter());
        CHECK(s.X() == s1.X());
        CHECK(s.Y() == s1.Y());
        CHECK(s.Z() == s1.Z());
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API ComputePointsAbscissa(double tol, const Adaptor2Curve& c, double abscissa, double u0)	 @param u0 The starting parameter
	 @param abscissa The arc length
	 @param c The curve
	 @param tol The tolerance
	 @brief Compute the parameter of a point on a 2D curve with given arc length and a tolerance
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <geometry/MakeGeom2Circle.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/ComputePointsAbscissa.hpp>
#include <geometry/MakeGeom3Circle.hpp>
#include <geometry/AdaptorGeom3Curve.hpp>
#include <geometry/MakeGeom2Hyperbola.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/MakeGeom2Ellipse.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <geometry/MakeGeom3Ellipse.hpp>
#include <geometry/MakeGeom3Hyperbola.hpp>
#include <geometry/Geom2Line.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom3Line.hpp>
#include <geometry/Geom3TrimmedCurve.hpp>
#include<modeling/MakeEdge.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/GeometryTool.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <geometry/MakeGeom2Parabola.hpp>
#include <geometry/MakeGeom3Parabola.hpp>
#include <geometry/Geom2BezierCurve.hpp>
#include <geometry/Geom3BezierCurve.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/Geom2OffsetCurve.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
TEST_CASE("test the parameters for calculating a point on a 2D curve with a given arc length and the length of the 2D curve.", "[geometry][ComputePointsAbscissa][case1]")
{
	SECTION("circle")
    {
        double r = 2.0;
        double l = 1.0;
        std::shared_ptr<Geom2Curve> c = MakeGeom2Circle(Point2(0.0, 0.0), 2.0).Value();
        AdaptorGeom2Curve circle(c);
        ComputePointsAbscissa cpa(circle, 1.0, 0.0);
        double angle1 = l / r;
        std::cout << "ԲĽǵĻֵΪ" << ": " << angle1 << '\n';
        double x = r * cos(angle1);
        double y = r * sin(angle1);
        std::cout << "xֵΪ" << ": " << x << '\n';
        std::cout << "yֵΪ" << ": " << y << '\n';
        double param = cpa.Parameter();
        if (cpa.IsDone())
        {
            std::cout << param << ": " << circle.Value(param) << '\n';
        }
        double p = 2 * M_PI * r;
        std::cout << "߳Ϊ" << ComputePointsAbscissa::Length(circle) << '\n';
        Point2 s = circle.Value(param);
        Point2 s1(x, y);
        std::cout << s << std::endl;
        CHECK(p == ComputePointsAbscissa::Length(circle));
        CHECK(angle1 == cpa.Parameter());
        CHECK(s.X() == s1.X());
        CHECK(s.Y() == s1.Y());
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API ComputePointsAbscissa(const Adaptor3Curve& c, double abscissa, double u0)	 @param u0 The starting parameter
	 @param abscissa The arc length
	 @param c The curve
	 @brief Compute the parameter of a point on a 3D curve with given arc length
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <geometry/MakeGeom2Circle.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/ComputePointsAbscissa.hpp>
#include <geometry/MakeGeom3Circle.hpp>
#include <geometry/AdaptorGeom3Curve.hpp>
#include <geometry/MakeGeom2Hyperbola.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/MakeGeom2Ellipse.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <geometry/MakeGeom3Ellipse.hpp>
#include <geometry/MakeGeom3Hyperbola.hpp>
#include <geometry/Geom2Line.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom3Line.hpp>
#include <geometry/Geom3TrimmedCurve.hpp>
#include<modeling/MakeEdge.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/GeometryTool.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <geometry/MakeGeom2Parabola.hpp>
#include <geometry/MakeGeom3Parabola.hpp>
#include <geometry/Geom2BezierCurve.hpp>
#include <geometry/Geom3BezierCurve.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/Geom2OffsetCurve.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
TEST_CASE("tset the parameters for calculating a point on a 3D curve of a given arc length and the length of the 3D curve.", "[geometry][ComputePointsAbscissa][case5]")
{
	SECTION("circle")
    {
        Frame3 frame;
        double r = 2.0;
        double l = 1.0;
        std::shared_ptr<Geom3Curve> c = MakeGeom3Circle(frame, r).Value();
        AdaptorGeom3Curve circle(c);
        ComputePointsAbscissa cpa(circle, 1.0, 0.0);
        double angle1 = l / r;
        std::cout << "ԲĽǵĻֵΪ" << ": " << angle1 << '\n';
        double x = r * cos(angle1);
        double y = r * sin(angle1);
        double z = 0;
        std::cout << "xֵΪ" << ": " << x << '\n';
        std::cout << "yֵΪ" << ": " << y << '\n';
        std::cout << "zֵΪ" << ": " << z << '\n';
        double param = cpa.Parameter();
        if (cpa.IsDone())
        {
            std::cout << param << ": " << circle.Value(param) << '\n';
        }
        double p = 2 * M_PI * r;
        std::cout << "߳Ϊ" << ComputePointsAbscissa::Length(circle) << '\n';
        Point3 s = circle.Value(param);
        Point3 s1(x, y, z);
        std::cout << s << std::endl;
        CHECK(p == ComputePointsAbscissa::Length(circle));
        CHECK(angle1 == cpa.Parameter());
        CHECK(s.X() == s1.X());
        CHECK(s.Y() == s1.Y());
        CHECK(s.Z() == s1.Z());
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API ComputePointsAbscissa(const Adaptor2Curve& c, double abscissa, double u0)	 @param u0 The starting parameter
	 @param abscissa The arc length
	 @param c The curve
	 @brief Compute the parameter of a point on a 2D curve with given arc length
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <geometry/MakeGeom2Circle.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/ComputePointsAbscissa.hpp>
#include <geometry/MakeGeom3Circle.hpp>
#include <geometry/AdaptorGeom3Curve.hpp>
#include <geometry/MakeGeom2Hyperbola.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/MakeGeom2Ellipse.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <geometry/MakeGeom3Ellipse.hpp>
#include <geometry/MakeGeom3Hyperbola.hpp>
#include <geometry/Geom2Line.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom3Line.hpp>
#include <geometry/Geom3TrimmedCurve.hpp>
#include<modeling/MakeEdge.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/GeometryTool.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <geometry/MakeGeom2Parabola.hpp>
#include <geometry/MakeGeom3Parabola.hpp>
#include <geometry/Geom2BezierCurve.hpp>
#include <geometry/Geom3BezierCurve.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/Geom2OffsetCurve.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
TEST_CASE("test the parameters for calculating a point on a 2D curve with a given arc length and the length of the 2D curve.", "[geometry][ComputePointsAbscissa][case1]")
{
	SECTION("circle")
    {
        double r = 2.0;
        double l = 1.0;
        std::shared_ptr<Geom2Curve> c = MakeGeom2Circle(Point2(0.0, 0.0), 2.0).Value();
        AdaptorGeom2Curve circle(c);
        ComputePointsAbscissa cpa(circle, 1.0, 0.0);
        double angle1 = l / r;
        std::cout << "ԲĽǵĻֵΪ" << ": " << angle1 << '\n';
        double x = r * cos(angle1);
        double y = r * sin(angle1);
        std::cout << "xֵΪ" << ": " << x << '\n';
        std::cout << "yֵΪ" << ": " << y << '\n';
        double param = cpa.Parameter();
        if (cpa.IsDone())
        {
            std::cout << param << ": " << circle.Value(param) << '\n';
        }
        double p = 2 * M_PI * r;
        std::cout << "߳Ϊ" << ComputePointsAbscissa::Length(circle) << '\n';
        Point2 s = circle.Value(param);
        Point2 s1(x, y);
        std::cout << s << std::endl;
        CHECK(p == ComputePointsAbscissa::Length(circle));
        CHECK(angle1 == cpa.Parameter());
        CHECK(s.X() == s1.X());
        CHECK(s.Y() == s1.Y());
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API ComputePointsAbscissa(const Adaptor3Curve& c, double abscissa, double u0, double ui)	 @param ui The initial guess of the parameter
	 @param u0 The starting parameter
	 @param abscissa The arc length
	 @param c The curve
	 @brief Compute the parameter of a point on a 3D curve with given arc length and an initial guess
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <geometry/MakeGeom2Circle.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/ComputePointsAbscissa.hpp>
#include <geometry/MakeGeom3Circle.hpp>
#include <geometry/AdaptorGeom3Curve.hpp>
#include <geometry/MakeGeom2Hyperbola.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/MakeGeom2Ellipse.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <geometry/MakeGeom3Ellipse.hpp>
#include <geometry/MakeGeom3Hyperbola.hpp>
#include <geometry/Geom2Line.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom3Line.hpp>
#include <geometry/Geom3TrimmedCurve.hpp>
#include<modeling/MakeEdge.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/GeometryTool.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <geometry/MakeGeom2Parabola.hpp>
#include <geometry/MakeGeom3Parabola.hpp>
#include <geometry/Geom2BezierCurve.hpp>
#include <geometry/Geom3BezierCurve.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/Geom2OffsetCurve.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
TEST_CASE("tset the parameters for calculating a point on a 3D curve of a given arc length and the length of the 3D curve.", "[geometry][ComputePointsAbscissa][case5]")
{
	SECTION("circle")
    {
        Frame3 frame;
        double r = 2.0;
        double l = 1.0;
        std::shared_ptr<Geom3Curve> c = MakeGeom3Circle(frame, r).Value();
        AdaptorGeom3Curve circle(c);
        ComputePointsAbscissa cpa(circle, 1.0, 0.0);
        double angle1 = l / r;
        std::cout << "ԲĽǵĻֵΪ" << ": " << angle1 << '\n';
        double x = r * cos(angle1);
        double y = r * sin(angle1);
        double z = 0;
        std::cout << "xֵΪ" << ": " << x << '\n';
        std::cout << "yֵΪ" << ": " << y << '\n';
        std::cout << "zֵΪ" << ": " << z << '\n';
        double param = cpa.Parameter();
        if (cpa.IsDone())
        {
            std::cout << param << ": " << circle.Value(param) << '\n';
        }
        double p = 2 * M_PI * r;
        std::cout << "߳Ϊ" << ComputePointsAbscissa::Length(circle) << '\n';
        Point3 s = circle.Value(param);
        Point3 s1(x, y, z);
        std::cout << s << std::endl;
        CHECK(p == ComputePointsAbscissa::Length(circle));
        CHECK(angle1 == cpa.Parameter());
        CHECK(s.X() == s1.X());
        CHECK(s.Y() == s1.Y());
        CHECK(s.Z() == s1.Z());
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API ComputePointsAbscissa(const Adaptor2Curve& c, double abscissa, double u0, double ui)	 @param ui The initial guess of the parameter
	 @param u0 The starting parameter
	 @param abscissa The arc length
	 @param c The curve
	 @brief Compute the parameter of a point on a 2D curve with given arc length and an initial guess
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <geometry/MakeGeom2Circle.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/ComputePointsAbscissa.hpp>
#include <geometry/MakeGeom3Circle.hpp>
#include <geometry/AdaptorGeom3Curve.hpp>
#include <geometry/MakeGeom2Hyperbola.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/MakeGeom2Ellipse.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <geometry/MakeGeom3Ellipse.hpp>
#include <geometry/MakeGeom3Hyperbola.hpp>
#include <geometry/Geom2Line.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom3Line.hpp>
#include <geometry/Geom3TrimmedCurve.hpp>
#include<modeling/MakeEdge.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/GeometryTool.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <geometry/MakeGeom2Parabola.hpp>
#include <geometry/MakeGeom3Parabola.hpp>
#include <geometry/Geom2BezierCurve.hpp>
#include <geometry/Geom3BezierCurve.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/Geom2OffsetCurve.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
TEST_CASE("test the parameters for calculating a point on a 2D curve with a given arc length and the length of the 2D curve.", "[geometry][ComputePointsAbscissa][case1]")
{
	SECTION("circle")
    {
        double r = 2.0;
        double l = 1.0;
        std::shared_ptr<Geom2Curve> c = MakeGeom2Circle(Point2(0.0, 0.0), 2.0).Value();
        AdaptorGeom2Curve circle(c);
        ComputePointsAbscissa cpa(circle, 1.0, 0.0);
        double angle1 = l / r;
        std::cout << "ԲĽǵĻֵΪ" << ": " << angle1 << '\n';
        double x = r * cos(angle1);
        double y = r * sin(angle1);
        std::cout << "xֵΪ" << ": " << x << '\n';
        std::cout << "yֵΪ" << ": " << y << '\n';
        double param = cpa.Parameter();
        if (cpa.IsDone())
        {
            std::cout << param << ": " << circle.Value(param) << '\n';
        }
        double p = 2 * M_PI * r;
        std::cout << "߳Ϊ" << ComputePointsAbscissa::Length(circle) << '\n';
        Point2 s = circle.Value(param);
        Point2 s1(x, y);
        std::cout << s << std::endl;
        CHECK(p == ComputePointsAbscissa::Length(circle));
        CHECK(angle1 == cpa.Parameter());
        CHECK(s.X() == s1.X());
        CHECK(s.Y() == s1.Y());
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API ComputePointsAbscissa(const Adaptor3Curve& c, double abscissa, double u0, double ui, double tol)	 @param tol The tolerance
	 @param ui The initial guess of the parameter
	 @param u0 The starting parameter
	 @param abscissa The arc length
	 @param c The curve
	 @brief Compute the parameter of a point on a 3D curve with given arc length, an initial guess, and a tolerance
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <geometry/MakeGeom2Circle.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/ComputePointsAbscissa.hpp>
#include <geometry/MakeGeom3Circle.hpp>
#include <geometry/AdaptorGeom3Curve.hpp>
#include <geometry/MakeGeom2Hyperbola.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/MakeGeom2Ellipse.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <geometry/MakeGeom3Ellipse.hpp>
#include <geometry/MakeGeom3Hyperbola.hpp>
#include <geometry/Geom2Line.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom3Line.hpp>
#include <geometry/Geom3TrimmedCurve.hpp>
#include<modeling/MakeEdge.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/GeometryTool.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <geometry/MakeGeom2Parabola.hpp>
#include <geometry/MakeGeom3Parabola.hpp>
#include <geometry/Geom2BezierCurve.hpp>
#include <geometry/Geom3BezierCurve.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/Geom2OffsetCurve.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
TEST_CASE("tset the parameters for calculating a point on a 3D curve of a given arc length and the length of the 3D curve.", "[geometry][ComputePointsAbscissa][case5]")
{
	SECTION("offset curve")
    {
        Frame3 frame;
        double r = 2.0;
        std::shared_ptr<Geom3Curve> c = MakeGeom3Circle(frame, r).Value();
        shared_ptr<Geom3OffsetCurve> curve;
        double offset = -1.0;
        Direction3 direction(0.0, 0.0, 1.0);
        curve = make_shared<Geom3OffsetCurve>(c, offset, direction);
        double r2 = r + offset;
        double p = 2 * M_PI * r2;
        double l = 2.0;
        AdaptorGeom3Curve offs(curve);
        ComputePointsAbscissa cpa8(offs, 2.0, 0.0);
        double angle1 = l / r2;
        std::cout << "ԲĽǵĻֵΪ" << ": " << angle1 << '\n';
        double x = r2 * cos(angle1);
        double y = r2 * sin(angle1);
        double z = 0.0;
        std::cout << "xֵΪ" << ": " << x << '\n';
        std::cout << "yֵΪ" << ": " << y << '\n';
        double param8 = cpa8.Parameter();
        if (cpa8.IsDone())
        {
            std::cout << param8 << ": " << offs.Value(param8) << '\n';
        }
        Point3 s = offs.Value(param8);
        Point3 s1(x, y, z);
        std::cout << s << std::endl;
        CHECK(s.X() == Approx(s1.X()).margin(1e-2));
        CHECK(s.Y() == Approx(s1.Y()).margin(1e-2));
        CHECK(s.Z() == Approx(s1.Z()).margin(1e-2));
        std::cout << "߳Ϊ" << ComputePointsAbscissa::Length(offs) << '\n';
        CHECK(ComputePointsAbscissa::Length(offs) == Approx(p).margin(1e-2));
    }
}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API ComputePointsAbscissa(const Adaptor2Curve& c, double abscissa, double u0, double ui, double tol)	 @param tol The tolerance
	 @param ui The initial guess of the parameter
	 @param u0 The starting parameter
	 @param abscissa The arc length
	 @param c The curve
	 @brief Compute the parameter of a point on a 2D curve with given arc length, an initial guess, and a tolerance
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <geometry/MakeGeom2Circle.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/ComputePointsAbscissa.hpp>
#include <geometry/MakeGeom3Circle.hpp>
#include <geometry/AdaptorGeom3Curve.hpp>
#include <geometry/MakeGeom2Hyperbola.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/MakeGeom2Ellipse.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <geometry/MakeGeom3Ellipse.hpp>
#include <geometry/MakeGeom3Hyperbola.hpp>
#include <geometry/Geom2Line.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom3Line.hpp>
#include <geometry/Geom3TrimmedCurve.hpp>
#include<modeling/MakeEdge.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/GeometryTool.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <geometry/MakeGeom2Parabola.hpp>
#include <geometry/MakeGeom3Parabola.hpp>
#include <geometry/Geom2BezierCurve.hpp>
#include <geometry/Geom3BezierCurve.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/Geom2OffsetCurve.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
TEST_CASE("test the parameters for calculating a point on a 2D curve with a given arc length and the length of the 2D curve.", "[geometry][ComputePointsAbscissa][case1]")
{
	SECTION("circle")
    {
        double r = 2.0;
        double l = 1.0;
        std::shared_ptr<Geom2Curve> c = MakeGeom2Circle(Point2(0.0, 0.0), 2.0).Value();
        AdaptorGeom2Curve circle(c);
        ComputePointsAbscissa cpa(circle, 1.0, 0.0);
        double angle1 = l / r;
        std::cout << "ԲĽǵĻֵΪ" << ": " << angle1 << '\n';
        double x = r * cos(angle1);
        double y = r * sin(angle1);
        std::cout << "xֵΪ" << ": " << x << '\n';
        std::cout << "yֵΪ" << ": " << y << '\n';
        double param = cpa.Parameter();
        if (cpa.IsDone())
        {
            std::cout << param << ": " << circle.Value(param) << '\n';
        }
        double p = 2 * M_PI * r;
        std::cout << "߳Ϊ" << ComputePointsAbscissa::Length(circle) << '\n';
        Point2 s = circle.Value(param);
        Point2 s1(x, y);
        std::cout << s << std::endl;
        CHECK(p == ComputePointsAbscissa::Length(circle));
        CHECK(angle1 == cpa.Parameter());
        CHECK(s.X() == s1.X());
        CHECK(s.Y() == s1.Y());
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API double Parameter()	 @return The parameter of the point
	 @brief Get the parameter of the point
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <geometry/MakeGeom2Circle.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/ComputePointsAbscissa.hpp>
#include <geometry/MakeGeom3Circle.hpp>
#include <geometry/AdaptorGeom3Curve.hpp>
#include <geometry/MakeGeom2Hyperbola.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/MakeGeom2Ellipse.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <geometry/MakeGeom3Ellipse.hpp>
#include <geometry/MakeGeom3Hyperbola.hpp>
#include <geometry/Geom2Line.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom3Line.hpp>
#include <geometry/Geom3TrimmedCurve.hpp>
#include<modeling/MakeEdge.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/GeometryTool.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <geometry/MakeGeom2Parabola.hpp>
#include <geometry/MakeGeom3Parabola.hpp>
#include <geometry/Geom2BezierCurve.hpp>
#include <geometry/Geom3BezierCurve.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/Geom2OffsetCurve.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
TEST_CASE("test the parameters for calculating a point on a 3D curve with a given arc length and tolerance, and the length of the 3D curve with tolerance.", "[geometry][ComputePointsAbscissa][case6]")
{
	SECTION("bezier")
    {
        std::vector<Point3> pts3 = {
       Point3(0.0, 0.0,0.0),
       Point3(2.0, 2.0,2.0),
       Point3(4.0, 3.0,5.0),
       Point3(6.0,2.0,4.0)
        };
        std::shared_ptr<Geom3BezierCurve> bez3 = make_shared<Geom3BezierCurve>(pts3);
        AdaptorGeom3Curve b2(bez3);
        ComputePointsAbscissa cpa6(Precision::Confusion(), b2, 2.0, 0.0);
        double param6 = cpa6.Parameter();
        if (cpa6.IsDone())
        {
            std::cout << param6 << ": " << b2.Value(param6) << '\n';
        }
        Point3 s7 = b2.Value(param6);
        std::cout << s7 << std::endl;
        CHECK(cpa6.Parameter() != 0);
        MakeEdge edge2(bez3);
        CHECK(BRepClassificationTools::IsPointInOnEdge(edge2, s7, 0.001) == true);
        std::cout << "߳Ϊ" << ComputePointsAbscissa::Length(b2, Precision::Confusion()) << '\n';
        GlobalProperty props1;
        TopoShape result1 = MakeEdge(bez3);
        CHECK(GetLinearProperties(result1, props1, true, true) == Approx(ComputePointsAbscissa::Length(b2, Precision::Confusion())).margin(0.1));
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static double Length(const Adaptor3Curve& c, double tol)	 @return The length of a curve
	 @param tol The tolerance
	 @param c The curve
	 @brief Compute the length of a 3D curve with a tolerance
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <geometry/MakeGeom2Circle.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/ComputePointsAbscissa.hpp>
#include <geometry/MakeGeom3Circle.hpp>
#include <geometry/AdaptorGeom3Curve.hpp>
#include <geometry/MakeGeom2Hyperbola.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/MakeGeom2Ellipse.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <geometry/MakeGeom3Ellipse.hpp>
#include <geometry/MakeGeom3Hyperbola.hpp>
#include <geometry/Geom2Line.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom3Line.hpp>
#include <geometry/Geom3TrimmedCurve.hpp>
#include<modeling/MakeEdge.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/GeometryTool.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <geometry/MakeGeom2Parabola.hpp>
#include <geometry/MakeGeom3Parabola.hpp>
#include <geometry/Geom2BezierCurve.hpp>
#include <geometry/Geom3BezierCurve.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/Geom2OffsetCurve.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
TEST_CASE("test the parameters for calculating a point on a 3D curve with a given arc length and tolerance, and the length of the 3D curve with tolerance.", "[geometry][ComputePointsAbscissa][case6]")
{
	SECTION("ellipse")
    {
        Frame3 frame;
        double major = 5.0;
        double minor = 4.0;
        bool isRight = true;
        std::shared_ptr< Geom3Ellipse >g2e = MakeGeom3Ellipse(frame, major, minor);
        AdaptorGeom3Curve ellipse(g2e);
        double t = minor / major;
        std::cout << "t" << t << '\n';
        double T = 3.15129643210828;
        double L = T * (minor + major);
        std::cout << "L" << L << '\n';
        ComputePointsAbscissa cpa2(Precision::Confusion(), ellipse, L, 0.0);
        double param2 = cpa2.Parameter();
        if (cpa2.IsDone())
        {
            std::cout << param2 << ": " << ellipse.Value(param2) << '\n';
        }
        Point3 s2 = ellipse.Value(param2);
        Point3 s3(5.0, 0.0, 0.0);
        std::cout << s2 << std::endl;
        CHECK(s2.X() == Approx(s3.X()).margin(1e-2));
        CHECK(s2.Y() == Approx(s3.Y()).margin(1e-2));
        CHECK(s2.Z() == Approx(s3.Z()).margin(1e-2));
        std::cout << "߳Ϊ" << ComputePointsAbscissa::Length(ellipse, Precision::Confusion()) << '\n';
        CHECK(ComputePointsAbscissa::Length(ellipse,Precision::Confusion()) == Approx(L).margin(1e-2));
        CHECK(cpa2.Parameter() == Approx(2 * M_PI).margin(1e-2));
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static double Length(const Adaptor2Curve& c, double tol)	 @return The length of a curve
	 @param tol The tolerance
	 @param c The curve
	 @brief Compute the length of a 2D curve with a tolerance
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <geometry/MakeGeom2Circle.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/ComputePointsAbscissa.hpp>
#include <geometry/MakeGeom3Circle.hpp>
#include <geometry/AdaptorGeom3Curve.hpp>
#include <geometry/MakeGeom2Hyperbola.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/MakeGeom2Ellipse.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <geometry/MakeGeom3Ellipse.hpp>
#include <geometry/MakeGeom3Hyperbola.hpp>
#include <geometry/Geom2Line.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom3Line.hpp>
#include <geometry/Geom3TrimmedCurve.hpp>
#include<modeling/MakeEdge.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/GeometryTool.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <geometry/MakeGeom2Parabola.hpp>
#include <geometry/MakeGeom3Parabola.hpp>
#include <geometry/Geom2BezierCurve.hpp>
#include <geometry/Geom3BezierCurve.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/Geom2OffsetCurve.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
TEST_CASE("test the calculation of the parameters of a point on a 2D curve for a given arc length, initial guess parameters and tolerances and the length of the 2D curve in a given interval, as well as the length of the 2D curve for a given interval and tolerances", "[geometry][ComputePointsAbscissa][case4]")
{
	SECTION("circle")
    {
        double r = 3.0;
        double l = 2.0;
        std::shared_ptr<Geom2Curve> c = MakeGeom2Circle(Point2(0.0, 0.0), 3.0).Value();
        AdaptorGeom2Curve circle(c);
        ComputePointsAbscissa cpa(circle, 2.0, 0.0, 1.5, Precision::Confusion());
        double angle1 = l / r;
        std::cout << "ԲĽǵĻֵΪ" << ": " << angle1 << '\n';
        double x = r * cos(angle1);
        double y = r * sin(angle1);
        std::cout << "xֵΪ" << ": " << x << '\n';
        std::cout << "yֵΪ" << ": " << y << '\n';
        double param = cpa.Parameter();
        if (cpa.IsDone())
        {
            std::cout << param << ": " << circle.Value(param) << '\n';
        }
        Point2 s = circle.Value(param);
        Point2 s1(x, y);
        std::cout << s << std::endl;
        CHECK(s.X() == s1.X());
        CHECK(s.Y() == s1.Y());
        std::cout << "ڶά߳Ϊ" << ComputePointsAbscissa::Length(circle, 0.0, 0.666667) << '\n';
        std::cout << "ݲĶά߳Ϊ" << ComputePointsAbscissa::Length(circle, 0.0, 0.666667, Precision::Confusion()) << '\n';
        CHECK(angle1 == cpa.Parameter());
        CHECK(ComputePointsAbscissa::Length(circle, 0.0, 0.6666666667) == Approx(l).margin(1e-2));
        CHECK(ComputePointsAbscissa::Length(circle, 0.0, 0.6666666667, Precision::Confusion()) == Approx(l).margin(1e-2));
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static double Length(const Adaptor3Curve& c, double u1, double u2)	 @return The length of a curve in a given interval
	 @param u2 The last parameter
	 @param u1 The first parameter
	 @param c The curve
	 @brief Compute the length of a 3D curve in a given interval
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <geometry/MakeGeom2Circle.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/ComputePointsAbscissa.hpp>
#include <geometry/MakeGeom3Circle.hpp>
#include <geometry/AdaptorGeom3Curve.hpp>
#include <geometry/MakeGeom2Hyperbola.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/MakeGeom2Ellipse.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <geometry/MakeGeom3Ellipse.hpp>
#include <geometry/MakeGeom3Hyperbola.hpp>
#include <geometry/Geom2Line.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom3Line.hpp>
#include <geometry/Geom3TrimmedCurve.hpp>
#include<modeling/MakeEdge.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/GeometryTool.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <geometry/MakeGeom2Parabola.hpp>
#include <geometry/MakeGeom3Parabola.hpp>
#include <geometry/Geom2BezierCurve.hpp>
#include <geometry/Geom3BezierCurve.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/Geom2OffsetCurve.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
TEST_CASE("tset the calculation of the parameters of a point on a 3D curve for a given arc length, initial guess parameters and tolerances and the length of the 3D curve within a given interval, as well as the length of the 3D curve for a given interval and tolerances", "[geometry][ComputePointsAbscissa][case8]")
{
	SECTION("line")
    {
        double t = 2.0;
        shared_ptr<Geom3Line> line;
        line = make_shared<Geom3Line>(Point3(0.0, 0.0, 0.0), Direction3(1.0, 2.0, 3.0));
        shared_ptr<Geom3TrimmedCurve> TrimmedCurve = make_shared<Geom3TrimmedCurve>(line, 0.0, 6.0);
        AdaptorGeom3Curve line1(TrimmedCurve);
        ComputePointsAbscissa cpa4(line1, 2.0, 0.0, 2.0, Precision::Confusion());
        double param4 = cpa4.Parameter();
        if (cpa4.IsDone())
        {
            std::cout << param4 << ": " << line1.Value(param4) << '\n';
        }
        Point3 start(0.0, 0.0, 0.0);
        Direction3 direction(1.0, 2.0, 3.0);
        double x = start.X() + t * direction.X();
        double y = start.Y() + t * direction.Y();
        double z = start.Z() + t * direction.Z();
        Point3 s5 = line1.Value(param4);
        Point3 s6(x, y, z);
        std::cout << s5 << std::endl;
        CHECK(cpa4.Parameter() == 2.0);
        CHECK(s5.X() == s6.X());
        CHECK(s5.Y() == s6.Y());
        CHECK(s5.Z() == s6.Z());
        std::cout << "ڶά߳Ϊ" << ComputePointsAbscissa::Length(line1, 0.0, 2.0) << '\n';
        std::cout << "ݲĶά߳Ϊ" << ComputePointsAbscissa::Length(line1, 0.0, 2.0, Precision::Confusion()) << '\n';
        CHECK(ComputePointsAbscissa::Length(line1, 0.0, 2.0) == 2.0);
        CHECK(ComputePointsAbscissa::Length(line1, 0.0, 2.0, Precision::Confusion()) == 2.0);
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static double Length(const Adaptor2Curve& c, double u1, double u2)	 @return The length of a curve in a given interval
	 @param u2 The last parameter
	 @param u1 The first parameter
	 @param c The curve
	 @brief Compute the length of a 2D curve in a given interval
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <geometry/MakeGeom2Circle.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/ComputePointsAbscissa.hpp>
#include <geometry/MakeGeom3Circle.hpp>
#include <geometry/AdaptorGeom3Curve.hpp>
#include <geometry/MakeGeom2Hyperbola.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/MakeGeom2Ellipse.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <geometry/MakeGeom3Ellipse.hpp>
#include <geometry/MakeGeom3Hyperbola.hpp>
#include <geometry/Geom2Line.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom3Line.hpp>
#include <geometry/Geom3TrimmedCurve.hpp>
#include<modeling/MakeEdge.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/GeometryTool.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <geometry/MakeGeom2Parabola.hpp>
#include <geometry/MakeGeom3Parabola.hpp>
#include <geometry/Geom2BezierCurve.hpp>
#include <geometry/Geom3BezierCurve.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/Geom2OffsetCurve.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
TEST_CASE("tset the calculation of the parameters of a point on a 3D curve for a given arc length, initial guess parameters and tolerances and the length of the 3D curve within a given interval, as well as the length of the 3D curve for a given interval and tolerances", "[geometry][ComputePointsAbscissa][case8]")
{
	SECTION("line")
    {
        double t = 2.0;
        shared_ptr<Geom3Line> line;
        line = make_shared<Geom3Line>(Point3(0.0, 0.0, 0.0), Direction3(1.0, 2.0, 3.0));
        shared_ptr<Geom3TrimmedCurve> TrimmedCurve = make_shared<Geom3TrimmedCurve>(line, 0.0, 6.0);
        AdaptorGeom3Curve line1(TrimmedCurve);
        ComputePointsAbscissa cpa4(line1, 2.0, 0.0, 2.0, Precision::Confusion());
        double param4 = cpa4.Parameter();
        if (cpa4.IsDone())
        {
            std::cout << param4 << ": " << line1.Value(param4) << '\n';
        }
        Point3 start(0.0, 0.0, 0.0);
        Direction3 direction(1.0, 2.0, 3.0);
        double x = start.X() + t * direction.X();
        double y = start.Y() + t * direction.Y();
        double z = start.Z() + t * direction.Z();
        Point3 s5 = line1.Value(param4);
        Point3 s6(x, y, z);
        std::cout << s5 << std::endl;
        CHECK(cpa4.Parameter() == 2.0);
        CHECK(s5.X() == s6.X());
        CHECK(s5.Y() == s6.Y());
        CHECK(s5.Z() == s6.Z());
        std::cout << "ڶά߳Ϊ" << ComputePointsAbscissa::Length(line1, 0.0, 2.0) << '\n';
        std::cout << "ݲĶά߳Ϊ" << ComputePointsAbscissa::Length(line1, 0.0, 2.0, Precision::Confusion()) << '\n';
        CHECK(ComputePointsAbscissa::Length(line1, 0.0, 2.0) == 2.0);
        CHECK(ComputePointsAbscissa::Length(line1, 0.0, 2.0, Precision::Confusion()) == 2.0);
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static double Length(const Adaptor3Curve& c, double u1, double u2, double tol)	 @return The length of a curve in a given interval
	 @param tol The tolerance
	 @param u2 The last parameter
	 @param u1 The first parameter
	 @param c The curve
	 @brief Compute the length of a 3D curve in a given interval with a tolerance
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <geometry/MakeGeom2Circle.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/ComputePointsAbscissa.hpp>
#include <geometry/MakeGeom3Circle.hpp>
#include <geometry/AdaptorGeom3Curve.hpp>
#include <geometry/MakeGeom2Hyperbola.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/MakeGeom2Ellipse.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <geometry/MakeGeom3Ellipse.hpp>
#include <geometry/MakeGeom3Hyperbola.hpp>
#include <geometry/Geom2Line.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom3Line.hpp>
#include <geometry/Geom3TrimmedCurve.hpp>
#include<modeling/MakeEdge.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/GeometryTool.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <geometry/MakeGeom2Parabola.hpp>
#include <geometry/MakeGeom3Parabola.hpp>
#include <geometry/Geom2BezierCurve.hpp>
#include <geometry/Geom3BezierCurve.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/Geom2OffsetCurve.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
TEST_CASE("test the calculation of the parameters of a point on a 2D curve for a given arc length, initial guess parameters and tolerances and the length of the 2D curve in a given interval, as well as the length of the 2D curve for a given interval and tolerances", "[geometry][ComputePointsAbscissa][case4]")
{
	SECTION("line")
    {
        shared_ptr<Geom2Line> line;
        line = make_shared<Geom2Line>(Point2(0.0, 0.0), Direction2(1.0, 0.0));
        shared_ptr<Geom2TrimmedCurve> TrimmedCurve = make_shared<Geom2TrimmedCurve>(line, 0.0, 6.0);
        AdaptorGeom2Curve line1(TrimmedCurve);
        ComputePointsAbscissa cpa4(line1, 2.0, 0.0, 2.0, Precision::Confusion());
        double param4 = cpa4.Parameter();
        if (cpa4.IsDone())
        {
            std::cout << param4 << ": " << line1.Value(param4) << '\n';
        }
        double x = 2.0;
        double y = 0.0;
        Point2 s5 = line1.Value(param4);
        Point2 s6(x, y);
        std::cout << s5 << std::endl;
        CHECK(cpa4.Parameter() == 2.0);
        CHECK(s5.X() == s6.X());
        CHECK(s5.Y() == s6.Y());
        std::cout << "ڶά߳Ϊ" << ComputePointsAbscissa::Length(line1, 0.0, 2.0) << '\n';
        std::cout << "ݲĶά߳Ϊ" << ComputePointsAbscissa::Length(line1, 0.0, 3.0, Precision::Confusion()) << '\n';
        CHECK(ComputePointsAbscissa::Length(line1, 0.0, 2.0) == 2.0);
        CHECK(ComputePointsAbscissa::Length(line1, 0.0, 3.0, Precision::Confusion()) == 3.0);
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static double Length(const Adaptor2Curve& c, double u1, double u2, double tol)	 @return The length of a curve in a given interval
	 @param tol The tolerance
	 @param u2 The last parameter
	 @param u1 The first parameter
	 @param c The curve
	 @brief Compute the length of a 2D curve in a given interval with a tolerance
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <geometry/MakeGeom2Circle.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/ComputePointsAbscissa.hpp>
#include <geometry/MakeGeom3Circle.hpp>
#include <geometry/AdaptorGeom3Curve.hpp>
#include <geometry/MakeGeom2Hyperbola.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/MakeGeom2Ellipse.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <geometry/MakeGeom3Ellipse.hpp>
#include <geometry/MakeGeom3Hyperbola.hpp>
#include <geometry/Geom2Line.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom3Line.hpp>
#include <geometry/Geom3TrimmedCurve.hpp>
#include<modeling/MakeEdge.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/GeometryTool.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <geometry/MakeGeom2Parabola.hpp>
#include <geometry/MakeGeom3Parabola.hpp>
#include <geometry/Geom2BezierCurve.hpp>
#include <geometry/Geom3BezierCurve.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/Geom2OffsetCurve.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
TEST_CASE("test the calculation of the parameters of a point on a 2D curve for a given arc length, initial guess parameters and tolerances and the length of the 2D curve in a given interval, as well as the length of the 2D curve for a given interval and tolerances", "[geometry][ComputePointsAbscissa][case4]")
{
	SECTION("circle")
    {
        double r = 3.0;
        double l = 2.0;
        std::shared_ptr<Geom2Curve> c = MakeGeom2Circle(Point2(0.0, 0.0), 3.0).Value();
        AdaptorGeom2Curve circle(c);
        ComputePointsAbscissa cpa(circle, 2.0, 0.0, 1.5, Precision::Confusion());
        double angle1 = l / r;
        std::cout << "ԲĽǵĻֵΪ" << ": " << angle1 << '\n';
        double x = r * cos(angle1);
        double y = r * sin(angle1);
        std::cout << "xֵΪ" << ": " << x << '\n';
        std::cout << "yֵΪ" << ": " << y << '\n';
        double param = cpa.Parameter();
        if (cpa.IsDone())
        {
            std::cout << param << ": " << circle.Value(param) << '\n';
        }
        Point2 s = circle.Value(param);
        Point2 s1(x, y);
        std::cout << s << std::endl;
        CHECK(s.X() == s1.X());
        CHECK(s.Y() == s1.Y());
        std::cout << "ڶά߳Ϊ" << ComputePointsAbscissa::Length(circle, 0.0, 0.666667) << '\n';
        std::cout << "ݲĶά߳Ϊ" << ComputePointsAbscissa::Length(circle, 0.0, 0.666667, Precision::Confusion()) << '\n';
        CHECK(angle1 == cpa.Parameter());
        CHECK(ComputePointsAbscissa::Length(circle, 0.0, 0.6666666667) == Approx(l).margin(1e-2));
        CHECK(ComputePointsAbscissa::Length(circle, 0.0, 0.6666666667, Precision::Confusion()) == Approx(l).margin(1e-2));
    }}
}
,