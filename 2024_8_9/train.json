[
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "void SetMajorRadius(double r)\t @param r The new major radius\n\t @brief Set the major radius\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <modeling/MakeFace.hpp>\n#include <common/AxisT.hpp>\n#include <math/HyperbolaT.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <common/VectorT.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <topology/TopoEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <iostream>\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Hyperbola3\", \"[math][Hyperbola3][p1]\") {\n\tPoint3 point3_fr(0.0, 0.0, 1.0);\n\tDirection3 dir3_fr(0.0, 0.0, 1.0);\n\tFrame3 frame3(point3_fr, dir3_fr);\n\tdouble major3 = 3.0, minor3 = 4.0;\n\tHyperbola3 hyperbola3d_fr(frame3, major3, minor3);\n\tSECTION(\"Default()\") {\n\t\tHyperbola3 hyperbola3d_de;\t\n\t\tCHECK(hyperbola3d_de.Location().X() == Approx(0.0));\n\t\tCHECK(hyperbola3d_de.Location().Y() == Approx(0.0));\n\t\tCHECK(hyperbola3d_de.Location().Z() == Approx(0.0));\n\t\thyperbola3d_de.SetMajorRadius(3.0);\n\t\thyperbola3d_de.SetMinorRadius(4.0);\n\t\tCHECK(hyperbola3d_de.MajorRadius() == Approx(3.0));\n\t\tCHECK(hyperbola3d_de.MinorRadius() == Approx(4.0));\n\t\tCHECK(hyperbola3d_de.Focal() == Approx(10.0));\n\t\tCHECK(hyperbola3d_de.Focus1().X() == Approx(5.0));\n\t\tCHECK(hyperbola3d_de.Focus1().Y() == Approx(0.0));\n\t\tCHECK(hyperbola3d_de.Focus1().Z() == Approx(0.0));\n\t}}\n}\n,"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static Array2<std::shared_ptr<Geom3BSplineSurface>> ExplodeSurface(const std::shared_ptr<Geom3BSplineSurface>& surface)\t @return The result surfaces\n\t @param surface The given surface\n\t @brief Explode a surface into patches at C0 isocurves\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <nurbs/NURBSAPIExplode.hpp>\n#include <topology/TopoEdge.hpp>\n#include <topology/TopoTool.hpp>\n#include <nurbs/NURBSAPIJoin.hpp>\n#include <nurbs/NURBSAPIExplode.hpp>\n#include <geometry/Geom3BSplineCurve.hpp>\n#include <geometry/Geom3BSplineSurface.hpp>\n#include <topology/TopoFace.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeFace.hpp>\nTEST_CASE(\"case1: this is a test for Explode-ExplodeSurface\", \"[nurbs][Explode][P1]\")\n{\n\tint num = 1000;\n\tdouble sTol = DEFAULT_TOLERANCE;\n\tdouble ratio = 0.1;\n\tdouble linTol = DEFAULT_TOLERANCE;\n\tSECTION(\"isUPeriodic+nonVPeriodic\")\n\t{\n\t\tOUTPUT_DIRECTORY(nurbs, Explode/ExplodeSurface3);\n\t\tstring filedir = INPUT_PATH_PREFIX\"./TestNURBS/TestJoinSurface/\";\n\t\tstd::vector<std::shared_ptr<Geom3BSplineSurface>> surfaces;\n\t\tsurfaces.push_back(ReadBRepSurface(filedir + \"surface0.brep\"));\n\t\tsurfaces.push_back(ReadBRepSurface(filedir + \"surface1.brep\"));\n\t\tsurfaces.push_back(ReadBRepSurface(filedir + \"surface2.brep\"));\n\t\tsurfaces.push_back(ReadBRepSurface(filedir + \"surface3.brep\"));\n\t\tauto [sortedSurfaces, isUIso, isFrontBackReverse, isIsoReverse, isLocalUPeriodic, isLocalVPeriodic] = NURBSAPIJoin::JoinSurfacesPrepare(surfaces, 0.0001);\n\t\tauto [isSucceed, result] = NURBSAPIJoin::JoinSurfaces(sortedSurfaces, isUIso, isFrontBackReverse, isIsoReverse, isLocalUPeriodic, isLocalVPeriodic);\n\t\tThrow_Construction_Error_if(!isSucceed, \"failed\");\n\t\tCHECK(isSucceed == true);\n\t\tauto explodeResult = NURBSAPIExplode::ExplodeSurface(result);\n\t\tint row = explodeResult.NRow();\n\t\tint col = explodeResult.NCol();\n\t\tfor (int i = 0; i < row; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < col; j++)\n\t\t\t{\n\t\t\t\tOCCTIO::OCCTTool::Write(MakeFace(explodeResult(i, j), 0.0), outdir +  \"expSurface\" + to_string(i) + to_string(j) +\".brep\");\n\t\t\t}\n\t\t}\n\t\tCHECK(row*col == 4);\n\t\tTopoShape f1 = MakeFace(surfaces[0],0.0);\n\t\tTopoShape f2 = MakeFace(surfaces[1], 0.0);\n\t\tTopoShape f3 = MakeFace(surfaces[2], 0.0);\n\t\tTopoShape f4 = MakeFace(surfaces[3], 0.0);\n\t\tTopoShape f = MakeFace(result,0.0);\n\t\tTopoShape exp1 = MakeFace(explodeResult(0, 0), 0.0);\n\t\tTopoShape exp2 = MakeFace(explodeResult(1, 0), 0.0);\n\t\tTopoShape exp3 = MakeFace(explodeResult(2, 0), 0.0);\n\t\tTopoShape exp4 = MakeFace(explodeResult(3, 0), 0.0);\n\t\tGlobalProperty props1, props2, props3, props4, props5, props6, props7, props8;\n\t\tdouble surf1 = GetSurfaceProperties(f1, props1, true, false);\n\t\tdouble surf2 = GetSurfaceProperties(f2, props2, true, false);\n\t\tdouble surf3 = GetSurfaceProperties(f3, props3, true, false);\n\t\tdouble surf4 = GetSurfaceProperties(f4, props4, true, false);\n\t\tdouble surface = GetSurfaceProperties(f, props5, true, false);\n\t\tdouble exSurf1 = GetSurfaceProperties(exp1, props5, true, false);\n\t\tdouble exSurf2 = GetSurfaceProperties(exp2, props6, true, false);\n\t\tdouble exSurf3 = GetSurfaceProperties(exp3, props7, true, false);\n\t\tdouble exSurf4 = GetSurfaceProperties(exp4, props8, true, false);\n\t\tdouble surf = surf1 + surf2 + surf3 + surf4;\n\t\tdouble dif = abs(surface - surf);\n\t\tdouble dif1 = abs(surf1 - exSurf1);\n\t\tdouble dif2 = abs(surf2 - exSurf2);\n\t\tdouble dif3 = abs(surf3 - exSurf3);\n\t\tdouble dif4 = abs(surf4 - exSurf4);\n\t\tCHECK(dif1 < 0.1);\n\t\tCHECK(dif2 < 0.1);\n\t\tCHECK(dif3 < 0.1);\n\t\tCHECK(dif4 < 0.1);\n\t\tdouble res1 = NurbsSampleSurface(num, sTol, surfaces[0], explodeResult(0, 0));\n\t\tdouble res2 = NurbsSampleSurface(num, sTol, surfaces[1], explodeResult(1, 0));\n\t\tdouble res3 = NurbsSampleSurface(num, sTol, surfaces[2], explodeResult(2, 0));\n\t\tdouble res4 = NurbsSampleSurface(num, sTol, surfaces[3], explodeResult(3, 0));\n\t\tCHECK(res1 <= ratio);\n\t\tCHECK(res2 <= ratio);\n\t\tCHECK(res3 <= ratio);\n\t\tCHECK(res4 <= ratio);\n\t\tOCCTIO::OCCTTool::Write(MakeFace(surfaces[0], 0.0), outdir + \"surf1.brep\");\n\t\tOCCTIO::OCCTTool::Write(MakeFace(surfaces[1], 0.0), outdir + \"surf2.brep\");\n\t\tOCCTIO::OCCTTool::Write(MakeFace(surfaces[2], 0.0), outdir + \"surf3.brep\");\n\t\tOCCTIO::OCCTTool::Write(MakeFace(surfaces[3], 0.0), outdir + \"surf4.brep\");\n\t\tOCCTIO::OCCTTool::Write(MakeFace(result, 0.0), outdir + \"joinSurface.brep\");\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static std::vector<std::shared_ptr<Geom3BSplineCurve>> ExplodeCurve(const std::shared_ptr<Geom3BSplineCurve>& curve)\t @return The result curves\n\t @param curve The given curve\n\t @brief Explode a curve into curves at C0 points\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <nurbs/NURBSAPIExplode.hpp>\n#include <topology/TopoEdge.hpp>\n#include <topology/TopoTool.hpp>\n#include <nurbs/NURBSAPIJoin.hpp>\n#include <nurbs/NURBSAPIExplode.hpp>\n#include <geometry/Geom3BSplineCurve.hpp>\n#include <geometry/Geom3BSplineSurface.hpp>\n#include <topology/TopoFace.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeFace.hpp>\nTEST_CASE(\"case1: this is a test for Explode-ExplodeCurve\", \"[nurbs][Explode][P1]\")\n{\n\tint num = 1000;\n\tdouble sTol = DEFAULT_TOLERANCE;\n\tdouble ratio = 0.1;\n\tdouble linTol = DEFAULT_TOLERANCE;\n    string filename;\n\tstring filedir = INPUT_PATH_PREFIX\"./TestNURBS/TestJoinCurve/\";\n\tSECTION(\"isPeriodic\")\n\t{\n\t\tOUTPUT_DIRECTORY(nurbs, Explode/ExplodeCurve1);\n\t\tfilename = \"periodicCurve\";\n\t\tstd::vector<std::shared_ptr<Geom3BSplineCurve>> curves;\n\t\tfor (int i = 0; i < 3; i++)\n\t\t{\n\t\t\tcurves.push_back(ReadBRepCurve(filedir + filename + std::to_string(i) + \".brep\"));\n\t\t}\n\t\tauto [sortedCurves, isReverse, isResultPeriodic] = NURBSAPIJoin::JoinCurvePrepare(curves, 0.0001);\n\t\tauto results = NURBSAPIJoin::JoinCurves(sortedCurves, isReverse, isResultPeriodic);\n\t\tint nresults = static_cast<int>(results.size());\n\t\tfor (int i = 0; i < nresults; i++)\n\t\t{\n\t\t\tOCCTIO::OCCTTool::Write(MakeEdge(results[i]), outdir + \"joinCurve\" + to_string(i) + \".brep\");\n\t\t}\n\t\tauto explodeResult = NURBSAPIExplode::ExplodeCurve(results.front());\n\t\tint expResults = static_cast<int>(explodeResult.size());\n\t\tfor (int j = 0; j < expResults; j++)\n\t\t{\n\t\t\tOCCTIO::OCCTTool::Write(MakeEdge(explodeResult[j]), outdir + \"expCurve\" + to_string(j) + \".brep\");\n\t\t}\n\t\tCHECK(results.size() == 1);\n\t\tCHECK(explodeResult.size() == 3);\n\t\tPoint3 p1, p2, p3, p4;\n\t\tp1 = curves[0]->StartPoint();\n\t\tp2 = curves[2]->EndPoint();\n\t\tp3 = results[0]->StartPoint();\n\t\tp4 = results[0]->EndPoint();\n\t\tCHECK(p1.X() == Approx(p3.X()));\n\t\tCHECK(p1.Y() == Approx(p3.Y()));\n\t\tCHECK(p1.Z() == Approx(p3.Z()));\n\t\tCHECK(p2.X() == Approx(p4.X()));\n\t\tCHECK(p2.Y() == Approx(p4.Y()));\n\t\tCHECK(p2.Z() == Approx(p4.Z()));\n\t\tTopoShape c1 = MakeEdge(curves[0]);\n\t\tTopoShape c2 = MakeEdge(curves[1]);\n\t\tTopoShape c3 = MakeEdge(curves[2]);\n\t\tTopoShape c = MakeEdge(results[0]);\n\t\tTopoShape e1 = MakeEdge(explodeResult[0]);\n\t\tTopoShape e2 = MakeEdge(explodeResult[1]);\n\t\tTopoShape e3 = MakeEdge(explodeResult[2]);\n\t\tGlobalProperty props1, props2, props3, props4, props5, props6, props7;\n\t\tdouble len1 = GetLinearProperties(c1, props1, true, false);\n\t\tdouble len2 = GetLinearProperties(c2, props2, true, false);\n\t\tdouble len3 = GetLinearProperties(c3, props3, true, false);\n\t\tdouble joinLen = GetLinearProperties(c, props4, true, false);\n\t\tdouble exLen1 = GetLinearProperties(e1, props5, true, false);\n\t\tdouble exLen2 = GetLinearProperties(e2, props6, true, false);\n\t\tdouble exLen3 = GetLinearProperties(e3, props7, true, false);\n\t\tdouble cuvLen = len1 + len2 + len3;\n\t\tdouble len = abs(cuvLen - joinLen);\n\t\tdouble len11 = abs(len1 - exLen1);\n\t\tdouble len22 = abs(len2 - exLen2);\n\t\tdouble len33 = abs(len3 - exLen3);\n\t\tCHECK(len < 0.1);\n\t\tCHECK(len11 < 0.1);\n\t\tCHECK(len22 < 0.1);\n\t\tCHECK(len33 < 0.1);\n\t\tdouble res1 = NurbsSampleCurve(num, sTol, curves[0], explodeResult[0]);\n\t\tdouble res2 = NurbsSampleCurve(num, sTol, curves[1], explodeResult[1]);\n\t\tdouble res3 = NurbsSampleCurve(num, sTol, curves[2], explodeResult[2]);\n\t\tCHECK(res1 <= ratio);\n\t\tCHECK(res2 <= ratio);\n\t\tCHECK(res3 <= ratio);\n\t\tOCCTIO::OCCTTool::Write(MakeEdge(curves[0]), outdir + \"curve0.brep\");\n\t\tOCCTIO::OCCTTool::Write(MakeEdge(curves[1]), outdir + \"curve1.brep\");\n\t\tOCCTIO::OCCTTool::Write(MakeEdge(curves[2]), outdir + \"curve2.brep\");\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static std::pair<NURBSSweepStatus, std::vector<std::shared_ptr<Geom3BSplineSurface>>> SweepWithPullingDirection( const std::shared_ptr<Geom3BSplineCurve>& profile, const std::shared_ptr<Geom3BSplineCurve>& guide, const Direction3& direction, const LawFunction& angleLawFunc, const std::shared_ptr<Geom3BSplineCurve>& spine, double spineLeftBound, double spineRightBound),\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <filesystem>\n#include <fstream>\n#include <random>\n#include <sstream>\n#include <nurbs/NURBSAPIGetGeometry.hpp>\n#include <nurbs/NURBSAPIConicalSweep.hpp>\n#include <boolean/BoolBRepCut.hpp>\n#include <common/CartesianCoordinateSystem.hpp>\n#include <common/IndexMap.hpp>\n#include <common/QuaternionT.hpp>\n#include <geomAlgo/LawBSpline.hpp>\n#include <geomAlgo/LawConstant.hpp>\n#include <nurbs/NURBSAPISmooth.hpp>\n#include <geomAlgo/MakeConic2FromConstraints.hpp>\n#include <geometry/Adaptor3CurveOnSurface.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/AdaptorGeom3Surface.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2Circle.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/Geom2Hyperbola.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3BSplineCurve.hpp>\n#include <geometry/Geom3BSplineSurface.hpp>\n#include <geometry/Geom3Circle.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\n#include <geometry/Geom3Plane.hpp>\n#include <geometry/Geom3SphericalSurface.hpp>\n#include <geometry/Geom3Surface.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include <geometry/Geom3TrimmedSurface.hpp>\n#include <geometry/GeomAPIExtremaCurveCurve3.hpp>\n#include <geometry/GeomAPIProjectPointOnCurve2.hpp>\n#include <geometry/GeomAPIProjectPointOnCurve3.hpp>\n#include <geometry/GeomAPIProjectPointOnSurface.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/GlobalProperty.hpp>\n#include <healing/ShapeFixTool.hpp>\n#include <io/STLTool.hpp>\n#include <math/Sphere.hpp>\n#include <math/TriangularMesh.hpp>\n#include <modeling/CopyShape.hpp>\n#include <modeling/MakeBox.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeFace.hpp>\n#include <modeling/MakePrism.hpp>\n#include <modeling/MakeRevol.hpp>\n#include <modeling/MakeShapeTool.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <modeling/MakeWire.hpp>\n#include <modeling/TransformShape.hpp>\n#include <nurbs/NURBSAPIApprox.hpp>\n#include <nurbs/NURBSAPIBuildCurve.hpp>\n#include <nurbs/NURBSAPICircularSweep.hpp>\n#include <nurbs/NURBSAPIConvert.hpp>\n#include <nurbs/NURBSAPICurveNetworkSurface.hpp>\n#include <nurbs/NURBSAPIExplicitSweep.hpp>\n#include <nurbs/NURBSAPIExplode.hpp>\n#include <nurbs/NURBSAPIExtend.hpp>\n#include <nurbs/NURBSAPIInterpolate.hpp>\n#include <nurbs/NURBSAPIJoin.hpp>\n#include <nurbs/NURBSAPILinearSweep.hpp>\n#include <nurbs/NURBSAPILoft.hpp>\n#include <nurbs/NURBSAPIMakeNURBSFromBoundaries.hpp>\n#include <nurbs/NURBSAPIMatch.hpp>\n#include <nurbs/NURBSAPIModifyEndToPlane.hpp>\n#include <nurbs/NURBSAPIOffsetCurveOnSurface.hpp>\n#include <nurbs/NURBSAPIProject.hpp>\n#include <nurbs/NURBSAPIRebuild.hpp>\n#include <nurbs/NURBSAPIReplaceEdge.hpp>\n#include <nurbs/NURBSAPISweep.hpp>\n#include <nurbs/NURBSAPISweep2.hpp>\n#include <nurbs/NURBSAPISweepRotation.hpp>\n#include <nurbs/NURBSAPITrim.hpp>\n#include <nurbs/NURBSAPIUntrim.hpp>\n#include <nurbs/NURBSLinearSweepWithDraftDirectionLength.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <offset/MakePipe.hpp>\n#include <offset/MakePipeShell.hpp>\n#include <topology/BRepAdaptorCurve2.hpp>\n#include <topology/BRepAdaptorCurve3.hpp>\n#include <topology/BRepAdaptorSurface.hpp>\n#include <topology/BRepGlobalProperty.hpp>\n#include <topology/BRepTool.hpp>\n#include <topology/TopoBuilder.hpp>\n#include <topology/TopoCompound.hpp>\n#include <topology/TopoEdge.hpp>\n#include <topology/TopoExplorer.hpp>\n#include <topology/TopoExplorerTool.hpp>\n#include <topology/TopoFace.hpp>\n#include <topology/TopoShape.hpp>\n#include <topology/TopoShell.hpp>\n#include <topology/TopoTool.hpp>\n#include <topology/TopoVertex.hpp>\n#include <topology/TopoWire.hpp>\n#include <topology/WireExplorer.hpp>\n#include <topomesh/BRepMeshIncrementalMesh.hpp>\n#include <nurbs/NURBSAPIBlend.hpp>\n#include <topology/BRepExtremaDistShapeShape.hpp>\n#include <math/LineT.hpp>\n#include <hatch/BRepClassificationTools.hpp>\nusing namespace AMCAX;\nnamespace\n{\n\tstd::shared_ptr<Geom3BSplineCurve> CurveChooser(const int id, const std::shared_ptr<Geom3BSplineCurve>& curve0, const std::shared_ptr<Geom3BSplineCurve>& curve1, const std::shared_ptr<Geom3BSplineCurve>& curve2)\n\t{\n\t\tstd::shared_ptr<Geom3BSplineCurve> result;\n\t\tswitch (id)\n\t\t{\n\t\tcase 0:\n\t\t{\n\t\t\tresult = curve0;\n\t\t\tbreak;\n\t\t}\n\t\tcase 1:\n\t\t{\n\t\t\tresult = curve1;\n\t\t\tbreak;\n\t\t}\n\t\tcase 2:\n\t\t{\n\t\t\tresult = curve2;\n\t\t\tbreak;\n\t\t}\n\t\t}\n\t\treturn result;\n\t}\n} \nTEST_CASE(\"case1:this is a case for ExplicitSweep\", \"[nurbs][forcase1][Explicit]\") {\n\tGlobalProperty g;\n\tSECTION(\"TestExplicitSweepWithPullingDirection()\")\n\t{\n\t\tstd::string filedir = INPUT_PATH_PREFIX \"/TestNURBS/TestExplicitSweepWithPullingDirection/\";\n\t\tauto guide = ReadBRepCurve(filedir + \"guide.brep\");\n\t\tCHECK(OCCTIO::OCCTTool::Write(MakeEdge(guide), OUTPUT_PATH_PREFIX \"TestExplicitSweepWithPullingDirection_guide.brep\"));\n\t\tauto profile = ReadBRepCurve(filedir + \"profile.brep\");\n\t\tCHECK(OCCTIO::OCCTTool::Write(MakeEdge(profile), OUTPUT_PATH_PREFIX \"TestExplicitSweepWithPullingDirection_profile.brep\"));\n\t\tauto spineLineEdge = ReadBRepEdge(filedir + \"spine.brep\");\n\t\tdouble fp, lp;\n\t\tauto spineLine = TopoTool::Curve(spineLineEdge, fp, lp);\n\t\tauto spine = NURBSAPIConvert::ToBSpline(std::make_shared<Geom3TrimmedCurve>(spineLine, 0, 3));\n\t\tCHECK(OCCTIO::OCCTTool::Write(MakeEdge(spine), OUTPUT_PATH_PREFIX \"TestExplicitSweepWithPullingDirection_spine.brep\"));\n\t\tauto pullingDirectionEdge = ReadBRepEdge(filedir + \"pullingDirection.brep\");\n\t\tauto dirCurve = TopoTool::Curve(pullingDirectionEdge, fp, lp);\n\t\tPoint3 p1, p2;\n\t\tVector3 d1, d2;\n\t\tdirCurve->D1(0.0, p1, d1);\n\t\tdirCurve->D1(1.0, p2, d2);\n\t\tDirection3 pullingDirection(d1);\n\t\tLawConstant law;\n\t\tlaw.Set(0.0, 0.0, 1.0);\n\t\tauto [status, surfaces] = NURBSAPIExplicitSweep::SweepWithPullingDirection(profile, guide, pullingDirection, law, spine, spine->FirstParameter(), spine->LastParameter());\n\t\tCHECK(status == NURBSSweepStatus::Success);\n\t\tif (status == NURBSSweepStatus::Success)\n\t\t{\n\t\t\tfor (int i = 0; i < surfaces.size(); i++)\n\t\t\t{\n\t\t\t\tCHECK(OCCTIO::OCCTTool::Write(MakeFace(surfaces[i], 0.0), OUTPUT_PATH_PREFIX \"TestExplicitSweepWithPullingDirection_result\" + std::to_string(i) + \".brep\"));\n\t\t\t\tCHECK(IsCurveOnSurf(1000, 0.3, guide, surfaces[i], 0.1));\n\t\t\t\tAMCAX::BRepExtremaDistShapeShape len1(MakeFace(surfaces[i], 0.0), MakeEdge(guide));\n\t\t\t\tAMCAX::BRepExtremaDistShapeShape len2(MakeFace(surfaces[i], 0.0), MakeEdge(profile));\n\t\t\t\tCHECK(len1.Value() == Approx(0.0).margin(0.1));\n\t\t\t\tCHECK(len2.Value() == Approx(0.0).margin(0.1));\n\t\t\t\tif (i < 2) {\n\t\t\t\t\tCHECK(IsCurveOnSurf(1000, 0.1, profile, surfaces[i], 0.1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprofile->IncreaseDegree(5);\n\t\tguide->IncreaseDegree(5);\n\t\tspine->IncreaseDegree(5);\n\t\tauto [status1, surfaces1] = NURBSAPIExplicitSweep::SweepWithPullingDirection(profile, guide, pullingDirection, law, spine, spine->FirstParameter(), spine->LastParameter());\n\t\tCHECK(status1 == NURBSSweepStatus::Success);\n\t\tif (status1 == NURBSSweepStatus::Success)\n\t\t{\n\t\t\tfor (int i = 0; i < surfaces1.size(); i++)\n\t\t\t{\n\t\t\t\tCHECK(OCCTIO::OCCTTool::Write(MakeFace(surfaces1[i], 0.0), OUTPUT_PATH_PREFIX \"TestExplicitSweepWithPullingDirection_degree5result\" + std::to_string(i) + \".brep\"));\n\t\t\t\tCHECK(IsCurveOnSurf(1000, 0.3, guide, surfaces1[i], 0.1));\n\t\t\t\tAMCAX::BRepExtremaDistShapeShape len1(MakeFace(surfaces1[i], 0.0), MakeEdge(guide));\n\t\t\t\tAMCAX::BRepExtremaDistShapeShape len2(MakeFace(surfaces1[i], 0.0), MakeEdge(profile));\n\t\t\t\tCHECK(len1.Value() == Approx(0.0).margin(0.1));\n\t\t\t\tCHECK(len2.Value() == Approx(0.0).margin(0.1));\n\t\t\t\tif (i < 2) {\n\t\t\t\t\tCHECK(IsCurveOnSurf(1000, 0.1, profile, surfaces1[i], 0.1));\n\t\t\t\t\tdouble bsp3s = GetSurfaceProperties(MakeFace(surfaces1[i], 0.0), g, true, true);\n\t\t\t\t\tdouble bsp4s = GetSurfaceProperties(MakeFace(surfaces[i], 0.0), g, true, true);\n\t\t\t\t\tCHECK(bsp3s == Approx(bsp4s).margin(0.02));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static std::pair<NURBSSweepStatus, std::shared_ptr<Geom3BSplineSurface>> SweepWithTwoGuideCurves( const std::shared_ptr<Geom3BSplineCurve>& profile, const std::shared_ptr<Geom3BSplineCurve>& guide1, const std::shared_ptr<Geom3BSplineCurve>& guide2, Point3 anchorPoint, const Direction3& anchorDirection, const std::shared_ptr<Geom3BSplineCurve>& spine, double spineLeftBound, double spineRightBound),\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <filesystem>\n#include <fstream>\n#include <random>\n#include <sstream>\n#include <nurbs/NURBSAPIGetGeometry.hpp>\n#include <nurbs/NURBSAPIConicalSweep.hpp>\n#include <boolean/BoolBRepCut.hpp>\n#include <common/CartesianCoordinateSystem.hpp>\n#include <common/IndexMap.hpp>\n#include <common/QuaternionT.hpp>\n#include <geomAlgo/LawBSpline.hpp>\n#include <geomAlgo/LawConstant.hpp>\n#include <nurbs/NURBSAPISmooth.hpp>\n#include <geomAlgo/MakeConic2FromConstraints.hpp>\n#include <geometry/Adaptor3CurveOnSurface.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/AdaptorGeom3Surface.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2Circle.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/Geom2Hyperbola.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3BSplineCurve.hpp>\n#include <geometry/Geom3BSplineSurface.hpp>\n#include <geometry/Geom3Circle.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\n#include <geometry/Geom3Plane.hpp>\n#include <geometry/Geom3SphericalSurface.hpp>\n#include <geometry/Geom3Surface.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include <geometry/Geom3TrimmedSurface.hpp>\n#include <geometry/GeomAPIExtremaCurveCurve3.hpp>\n#include <geometry/GeomAPIProjectPointOnCurve2.hpp>\n#include <geometry/GeomAPIProjectPointOnCurve3.hpp>\n#include <geometry/GeomAPIProjectPointOnSurface.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/GlobalProperty.hpp>\n#include <healing/ShapeFixTool.hpp>\n#include <io/STLTool.hpp>\n#include <math/Sphere.hpp>\n#include <math/TriangularMesh.hpp>\n#include <modeling/CopyShape.hpp>\n#include <modeling/MakeBox.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeFace.hpp>\n#include <modeling/MakePrism.hpp>\n#include <modeling/MakeRevol.hpp>\n#include <modeling/MakeShapeTool.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <modeling/MakeWire.hpp>\n#include <modeling/TransformShape.hpp>\n#include <nurbs/NURBSAPIApprox.hpp>\n#include <nurbs/NURBSAPIBuildCurve.hpp>\n#include <nurbs/NURBSAPICircularSweep.hpp>\n#include <nurbs/NURBSAPIConvert.hpp>\n#include <nurbs/NURBSAPICurveNetworkSurface.hpp>\n#include <nurbs/NURBSAPIExplicitSweep.hpp>\n#include <nurbs/NURBSAPIExplode.hpp>\n#include <nurbs/NURBSAPIExtend.hpp>\n#include <nurbs/NURBSAPIInterpolate.hpp>\n#include <nurbs/NURBSAPIJoin.hpp>\n#include <nurbs/NURBSAPILinearSweep.hpp>\n#include <nurbs/NURBSAPILoft.hpp>\n#include <nurbs/NURBSAPIMakeNURBSFromBoundaries.hpp>\n#include <nurbs/NURBSAPIMatch.hpp>\n#include <nurbs/NURBSAPIModifyEndToPlane.hpp>\n#include <nurbs/NURBSAPIOffsetCurveOnSurface.hpp>\n#include <nurbs/NURBSAPIProject.hpp>\n#include <nurbs/NURBSAPIRebuild.hpp>\n#include <nurbs/NURBSAPIReplaceEdge.hpp>\n#include <nurbs/NURBSAPISweep.hpp>\n#include <nurbs/NURBSAPISweep2.hpp>\n#include <nurbs/NURBSAPISweepRotation.hpp>\n#include <nurbs/NURBSAPITrim.hpp>\n#include <nurbs/NURBSAPIUntrim.hpp>\n#include <nurbs/NURBSLinearSweepWithDraftDirectionLength.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <offset/MakePipe.hpp>\n#include <offset/MakePipeShell.hpp>\n#include <topology/BRepAdaptorCurve2.hpp>\n#include <topology/BRepAdaptorCurve3.hpp>\n#include <topology/BRepAdaptorSurface.hpp>\n#include <topology/BRepGlobalProperty.hpp>\n#include <topology/BRepTool.hpp>\n#include <topology/TopoBuilder.hpp>\n#include <topology/TopoCompound.hpp>\n#include <topology/TopoEdge.hpp>\n#include <topology/TopoExplorer.hpp>\n#include <topology/TopoExplorerTool.hpp>\n#include <topology/TopoFace.hpp>\n#include <topology/TopoShape.hpp>\n#include <topology/TopoShell.hpp>\n#include <topology/TopoTool.hpp>\n#include <topology/TopoVertex.hpp>\n#include <topology/TopoWire.hpp>\n#include <topology/WireExplorer.hpp>\n#include <topomesh/BRepMeshIncrementalMesh.hpp>\n#include <nurbs/NURBSAPIBlend.hpp>\n#include <topology/BRepExtremaDistShapeShape.hpp>\n#include <math/LineT.hpp>\n#include <hatch/BRepClassificationTools.hpp>\nusing namespace AMCAX;\nnamespace\n{\n\tstd::shared_ptr<Geom3BSplineCurve> CurveChooser(const int id, const std::shared_ptr<Geom3BSplineCurve>& curve0, const std::shared_ptr<Geom3BSplineCurve>& curve1, const std::shared_ptr<Geom3BSplineCurve>& curve2)\n\t{\n\t\tstd::shared_ptr<Geom3BSplineCurve> result;\n\t\tswitch (id)\n\t\t{\n\t\tcase 0:\n\t\t{\n\t\t\tresult = curve0;\n\t\t\tbreak;\n\t\t}\n\t\tcase 1:\n\t\t{\n\t\t\tresult = curve1;\n\t\t\tbreak;\n\t\t}\n\t\tcase 2:\n\t\t{\n\t\t\tresult = curve2;\n\t\t\tbreak;\n\t\t}\n\t\t}\n\t\treturn result;\n\t}\n} \nTEST_CASE(\"case1:this is a case for ExplicitSweep\", \"[nurbs][forcase1][Explicit]\") {\n\tGlobalProperty g;\n\tSECTION(\"TestExplicitSweepWithTwoGuideCurvesTwoPoints()\")\n\t{\n\t\tstd::string filedir = INPUT_PATH_PREFIX \"/TestNURBS/TestExplicitSweepWithTwoGuideCurvesTwoPoints/\";\n\t\tauto profile = ReadBRepCurve(filedir + \"profile.brep\");\n\t\tCHECK(OCCTIO::OCCTTool::Write(MakeEdge(profile), OUTPUT_PATH_PREFIX \"TestExplicitSweepWithTwoGuideCurvesTwoPoints_profile.brep\"));\n\t\tauto guide1 = ReadBRepCurve(filedir + \"guide1.brep\");\n\t\tCHECK(OCCTIO::OCCTTool::Write(MakeEdge(guide1), OUTPUT_PATH_PREFIX \"TestExplicitSweepWithTwoGuideCurvesTwoPoints_guide1.brep\"));\n\t\tauto guide2 = ReadBRepCurve(filedir + \"guide2.brep\");\n\t\tCHECK(OCCTIO::OCCTTool::Write(MakeEdge(guide2), OUTPUT_PATH_PREFIX \"TestExplicitSweepWithTwoGuideCurvesTwoPoints_guide2.brep\"));\n\t\tauto anchorPoint1 = ReadBRepPoint(filedir + \"point1.brep\");\n\t\tauto anchorPoint2 = ReadBRepPoint(filedir + \"point2.brep\");\n\t\tCHECK(OCCTIO::OCCTTool::Write(MakeVertex(anchorPoint1), OUTPUT_PATH_PREFIX \"TestExplicitSweepWithTwoGuideCurvesTwoPoints_point1.brep\"));\n\t\tCHECK(OCCTIO::OCCTTool::Write(MakeVertex(anchorPoint2), OUTPUT_PATH_PREFIX \"TestExplicitSweepWithTwoGuideCurvesTwoPoints_point2.brep\"));\n\t\tauto [status, surface] = NURBSAPIExplicitSweep::SweepWithTwoGuideCurves(profile, guide1, guide2, anchorPoint1, anchorPoint2, guide1, guide1->FirstParameter(), guide1->LastParameter());\n\t\tCHECK(status == NURBSSweepStatus::Success);\n\t\tif (status == NURBSSweepStatus::Success)\n\t\t{\n\t\t\tCHECK(OCCTIO::OCCTTool::Write(MakeFace(surface, 0.0), OUTPUT_PATH_PREFIX \"TestExplicitSweepWithTwoGuideCurvesTwoPoints_result.brep\"));\n\t\t\tAMCAX::BRepExtremaDistShapeShape len1(MakeFace(surface, 0.0), MakeEdge(guide1));\n\t\t\tAMCAX::BRepExtremaDistShapeShape len2(MakeFace(surface, 0.0), MakeEdge(guide2));\n\t\t\tAMCAX::BRepExtremaDistShapeShape len3(MakeFace(surface, 0.0), MakeEdge(profile));\n\t\t\tCHECK(len1.Value() == Approx(0.0).margin(0.1));\n\t\t\tCHECK(len2.Value() == Approx(0.0).margin(0.1));\n\t\t\tCHECK(len3.Value() == Approx(0.0).margin(0.1));\n\t\t}\n\t\tprofile->IncreaseDegree(11);\n\t\tguide1->IncreaseDegree(11);\n\t\tguide2->IncreaseDegree(11);\n\t\tauto [status1, surface1] = NURBSAPIExplicitSweep::SweepWithTwoGuideCurves(profile, guide1, guide2, anchorPoint1, anchorPoint2, guide1, guide1->FirstParameter(), guide1->LastParameter());\n\t\tCHECK(status1 == NURBSSweepStatus::Success);\n\t\tif (status1 == NURBSSweepStatus::Success)\n\t\t{\n\t\t\tCHECK(OCCTIO::OCCTTool::Write(MakeFace(surface1, 0.0), OUTPUT_PATH_PREFIX \"TestExplicitSweepWithTwoGuideCurvesTwoPoints_degree11result.brep\"));\n\t\t\tAMCAX::BRepExtremaDistShapeShape len1(MakeFace(surface1, 0.0), MakeEdge(guide1));\n\t\t\tAMCAX::BRepExtremaDistShapeShape len2(MakeFace(surface1, 0.0), MakeEdge(guide2));\n\t\t\tAMCAX::BRepExtremaDistShapeShape len3(MakeFace(surface1, 0.0), MakeEdge(profile));\n\t\t\tCHECK(len1.Value() == Approx(0.0).margin(0.1));\n\t\t\tCHECK(len2.Value() == Approx(0.0).margin(0.1));\n\t\t\tCHECK(len3.Value() == Approx(0.0).margin(0.1));\n\t\t\tdouble bsp3s = GetSurfaceProperties(MakeFace(surface1, 0.0), g, true, true);\n\t\t\tdouble bsp4s = GetSurfaceProperties(MakeFace(surface, 0.0), g, true, true);\n\t\t\tCHECK(bsp3s == Approx(bsp4s).margin(0.04));\n\t\t}\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static std::pair<NURBSSweepStatus, std::shared_ptr<Geom3BSplineSurface>> SweepWithTwoGuideCurves( const std::shared_ptr<Geom3BSplineCurve>& profile, const std::shared_ptr<Geom3BSplineCurve>& guide1, const std::shared_ptr<Geom3BSplineCurve>& guide2, Point3 anchorPoint1, Point3 anchorPoint2, const std::shared_ptr<Geom3BSplineCurve>& spine, double spineLeftBound, double spineRightBound),\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <filesystem>\n#include <fstream>\n#include <random>\n#include <sstream>\n#include <nurbs/NURBSAPIGetGeometry.hpp>\n#include <nurbs/NURBSAPIConicalSweep.hpp>\n#include <boolean/BoolBRepCut.hpp>\n#include <common/CartesianCoordinateSystem.hpp>\n#include <common/IndexMap.hpp>\n#include <common/QuaternionT.hpp>\n#include <geomAlgo/LawBSpline.hpp>\n#include <geomAlgo/LawConstant.hpp>\n#include <nurbs/NURBSAPISmooth.hpp>\n#include <geomAlgo/MakeConic2FromConstraints.hpp>\n#include <geometry/Adaptor3CurveOnSurface.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/AdaptorGeom3Surface.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2Circle.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/Geom2Hyperbola.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3BSplineCurve.hpp>\n#include <geometry/Geom3BSplineSurface.hpp>\n#include <geometry/Geom3Circle.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\n#include <geometry/Geom3Plane.hpp>\n#include <geometry/Geom3SphericalSurface.hpp>\n#include <geometry/Geom3Surface.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include <geometry/Geom3TrimmedSurface.hpp>\n#include <geometry/GeomAPIExtremaCurveCurve3.hpp>\n#include <geometry/GeomAPIProjectPointOnCurve2.hpp>\n#include <geometry/GeomAPIProjectPointOnCurve3.hpp>\n#include <geometry/GeomAPIProjectPointOnSurface.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/GlobalProperty.hpp>\n#include <healing/ShapeFixTool.hpp>\n#include <io/STLTool.hpp>\n#include <math/Sphere.hpp>\n#include <math/TriangularMesh.hpp>\n#include <modeling/CopyShape.hpp>\n#include <modeling/MakeBox.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeFace.hpp>\n#include <modeling/MakePrism.hpp>\n#include <modeling/MakeRevol.hpp>\n#include <modeling/MakeShapeTool.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <modeling/MakeWire.hpp>\n#include <modeling/TransformShape.hpp>\n#include <nurbs/NURBSAPIApprox.hpp>\n#include <nurbs/NURBSAPIBuildCurve.hpp>\n#include <nurbs/NURBSAPICircularSweep.hpp>\n#include <nurbs/NURBSAPIConvert.hpp>\n#include <nurbs/NURBSAPICurveNetworkSurface.hpp>\n#include <nurbs/NURBSAPIExplicitSweep.hpp>\n#include <nurbs/NURBSAPIExplode.hpp>\n#include <nurbs/NURBSAPIExtend.hpp>\n#include <nurbs/NURBSAPIInterpolate.hpp>\n#include <nurbs/NURBSAPIJoin.hpp>\n#include <nurbs/NURBSAPILinearSweep.hpp>\n#include <nurbs/NURBSAPILoft.hpp>\n#include <nurbs/NURBSAPIMakeNURBSFromBoundaries.hpp>\n#include <nurbs/NURBSAPIMatch.hpp>\n#include <nurbs/NURBSAPIModifyEndToPlane.hpp>\n#include <nurbs/NURBSAPIOffsetCurveOnSurface.hpp>\n#include <nurbs/NURBSAPIProject.hpp>\n#include <nurbs/NURBSAPIRebuild.hpp>\n#include <nurbs/NURBSAPIReplaceEdge.hpp>\n#include <nurbs/NURBSAPISweep.hpp>\n#include <nurbs/NURBSAPISweep2.hpp>\n#include <nurbs/NURBSAPISweepRotation.hpp>\n#include <nurbs/NURBSAPITrim.hpp>\n#include <nurbs/NURBSAPIUntrim.hpp>\n#include <nurbs/NURBSLinearSweepWithDraftDirectionLength.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <offset/MakePipe.hpp>\n#include <offset/MakePipeShell.hpp>\n#include <topology/BRepAdaptorCurve2.hpp>\n#include <topology/BRepAdaptorCurve3.hpp>\n#include <topology/BRepAdaptorSurface.hpp>\n#include <topology/BRepGlobalProperty.hpp>\n#include <topology/BRepTool.hpp>\n#include <topology/TopoBuilder.hpp>\n#include <topology/TopoCompound.hpp>\n#include <topology/TopoEdge.hpp>\n#include <topology/TopoExplorer.hpp>\n#include <topology/TopoExplorerTool.hpp>\n#include <topology/TopoFace.hpp>\n#include <topology/TopoShape.hpp>\n#include <topology/TopoShell.hpp>\n#include <topology/TopoTool.hpp>\n#include <topology/TopoVertex.hpp>\n#include <topology/TopoWire.hpp>\n#include <topology/WireExplorer.hpp>\n#include <topomesh/BRepMeshIncrementalMesh.hpp>\n#include <nurbs/NURBSAPIBlend.hpp>\n#include <topology/BRepExtremaDistShapeShape.hpp>\n#include <math/LineT.hpp>\n#include <hatch/BRepClassificationTools.hpp>\nusing namespace AMCAX;\nnamespace\n{\n\tstd::shared_ptr<Geom3BSplineCurve> CurveChooser(const int id, const std::shared_ptr<Geom3BSplineCurve>& curve0, const std::shared_ptr<Geom3BSplineCurve>& curve1, const std::shared_ptr<Geom3BSplineCurve>& curve2)\n\t{\n\t\tstd::shared_ptr<Geom3BSplineCurve> result;\n\t\tswitch (id)\n\t\t{\n\t\tcase 0:\n\t\t{\n\t\t\tresult = curve0;\n\t\t\tbreak;\n\t\t}\n\t\tcase 1:\n\t\t{\n\t\t\tresult = curve1;\n\t\t\tbreak;\n\t\t}\n\t\tcase 2:\n\t\t{\n\t\t\tresult = curve2;\n\t\t\tbreak;\n\t\t}\n\t\t}\n\t\treturn result;\n\t}\n} \nTEST_CASE(\"case1:this is a case for ExplicitSweep\", \"[nurbs][forcase1][Explicit]\") {\n\tGlobalProperty g;\n\tSECTION(\"TestExplicitSweepWithTwoGuideCurvesTwoPoints()\")\n\t{\n\t\tstd::string filedir = INPUT_PATH_PREFIX \"/TestNURBS/TestExplicitSweepWithTwoGuideCurvesTwoPoints/\";\n\t\tauto profile = ReadBRepCurve(filedir + \"profile.brep\");\n\t\tCHECK(OCCTIO::OCCTTool::Write(MakeEdge(profile), OUTPUT_PATH_PREFIX \"TestExplicitSweepWithTwoGuideCurvesTwoPoints_profile.brep\"));\n\t\tauto guide1 = ReadBRepCurve(filedir + \"guide1.brep\");\n\t\tCHECK(OCCTIO::OCCTTool::Write(MakeEdge(guide1), OUTPUT_PATH_PREFIX \"TestExplicitSweepWithTwoGuideCurvesTwoPoints_guide1.brep\"));\n\t\tauto guide2 = ReadBRepCurve(filedir + \"guide2.brep\");\n\t\tCHECK(OCCTIO::OCCTTool::Write(MakeEdge(guide2), OUTPUT_PATH_PREFIX \"TestExplicitSweepWithTwoGuideCurvesTwoPoints_guide2.brep\"));\n\t\tauto anchorPoint1 = ReadBRepPoint(filedir + \"point1.brep\");\n\t\tauto anchorPoint2 = ReadBRepPoint(filedir + \"point2.brep\");\n\t\tCHECK(OCCTIO::OCCTTool::Write(MakeVertex(anchorPoint1), OUTPUT_PATH_PREFIX \"TestExplicitSweepWithTwoGuideCurvesTwoPoints_point1.brep\"));\n\t\tCHECK(OCCTIO::OCCTTool::Write(MakeVertex(anchorPoint2), OUTPUT_PATH_PREFIX \"TestExplicitSweepWithTwoGuideCurvesTwoPoints_point2.brep\"));\n\t\tauto [status, surface] = NURBSAPIExplicitSweep::SweepWithTwoGuideCurves(profile, guide1, guide2, anchorPoint1, anchorPoint2, guide1, guide1->FirstParameter(), guide1->LastParameter());\n\t\tCHECK(status == NURBSSweepStatus::Success);\n\t\tif (status == NURBSSweepStatus::Success)\n\t\t{\n\t\t\tCHECK(OCCTIO::OCCTTool::Write(MakeFace(surface, 0.0), OUTPUT_PATH_PREFIX \"TestExplicitSweepWithTwoGuideCurvesTwoPoints_result.brep\"));\n\t\t\tAMCAX::BRepExtremaDistShapeShape len1(MakeFace(surface, 0.0), MakeEdge(guide1));\n\t\t\tAMCAX::BRepExtremaDistShapeShape len2(MakeFace(surface, 0.0), MakeEdge(guide2));\n\t\t\tAMCAX::BRepExtremaDistShapeShape len3(MakeFace(surface, 0.0), MakeEdge(profile));\n\t\t\tCHECK(len1.Value() == Approx(0.0).margin(0.1));\n\t\t\tCHECK(len2.Value() == Approx(0.0).margin(0.1));\n\t\t\tCHECK(len3.Value() == Approx(0.0).margin(0.1));\n\t\t}\n\t\tprofile->IncreaseDegree(11);\n\t\tguide1->IncreaseDegree(11);\n\t\tguide2->IncreaseDegree(11);\n\t\tauto [status1, surface1] = NURBSAPIExplicitSweep::SweepWithTwoGuideCurves(profile, guide1, guide2, anchorPoint1, anchorPoint2, guide1, guide1->FirstParameter(), guide1->LastParameter());\n\t\tCHECK(status1 == NURBSSweepStatus::Success);\n\t\tif (status1 == NURBSSweepStatus::Success)\n\t\t{\n\t\t\tCHECK(OCCTIO::OCCTTool::Write(MakeFace(surface1, 0.0), OUTPUT_PATH_PREFIX \"TestExplicitSweepWithTwoGuideCurvesTwoPoints_degree11result.brep\"));\n\t\t\tAMCAX::BRepExtremaDistShapeShape len1(MakeFace(surface1, 0.0), MakeEdge(guide1));\n\t\t\tAMCAX::BRepExtremaDistShapeShape len2(MakeFace(surface1, 0.0), MakeEdge(guide2));\n\t\t\tAMCAX::BRepExtremaDistShapeShape len3(MakeFace(surface1, 0.0), MakeEdge(profile));\n\t\t\tCHECK(len1.Value() == Approx(0.0).margin(0.1));\n\t\t\tCHECK(len2.Value() == Approx(0.0).margin(0.1));\n\t\t\tCHECK(len3.Value() == Approx(0.0).margin(0.1));\n\t\t\tdouble bsp3s = GetSurfaceProperties(MakeFace(surface1, 0.0), g, true, true);\n\t\t\tdouble bsp4s = GetSurfaceProperties(MakeFace(surface, 0.0), g, true, true);\n\t\t\tCHECK(bsp3s == Approx(bsp4s).margin(0.04));\n\t\t}\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static std::shared_ptr<Geom3BSplineSurface> CurveNetworkSurfaceGordon(const std::vector<std::shared_ptr<Geom3BSplineCurve>>& verticalCurves, const std::vector<std::shared_ptr<Geom3BSplineCurve>>& horizontalCurves)\t @return The Gordon surface which go through the curves\n\t @param horizontalCurves Horizontal network curves\n\t @param verticalCurves Vertical network curves\n\t @brief Coons-Gordon surface\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <nurbs/NURBSAPICurveNetworkSurface.hpp>\n#include <topology/TopoEdge.hpp>\n#include <topology/TopoTool.hpp>\n#include <modeling/MakeFace.hpp>\n#include <nurbs/NURBSAPILoft.hpp>\n#include <common/Precision.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <geometry/Geom3BSplineCurve.hpp>\n#include <geometry/Geom3BSplineSurface.hpp>\n#include <topology/BRepExtremaDistShapeShape.hpp>\n#include <topology/TopoExplorerTool.hpp>\n#include <geometry/GeomAPIProjectPointOnSurface.hpp>\nusing namespace std;\nusing namespace AMCAX;\ndouble NurbsSampleCurveOnSurface(int num, double tol, const shared_ptr<Geom3Curve>& curve, const shared_ptr<Geom3Surface>& surf)\n{\n\tconst int nsample = num;\n\tdouble fp1 = curve->FirstParameter();\n\tdouble lp1 = curve->LastParameter();\n\tdouble delta1 = (lp1 - fp1) / nsample;\n\tPoint3 p;\n\tint n = 0;\n\tfor (int i = 0; i < nsample; i++)\n\t{\n\t\tdouble t1 = fp1 + i * delta1;\n\t\tcurve->D0(t1, p);\n\t\tGeomAPIProjectPointOnSurface projector(p, surf);\n\t\tdouble dis = projector.LowerDistance();\n\t\tif (dis <= tol)\n\t\t{\n\t\t\tn++;\n\t\t}\n\t}\n\tdouble res = 1.0 * (num - n) / num;\n\treturn res;\n}\nvector< shared_ptr<Geom3BSplineCurve>> ConstructBSplineCurve()\n{\n\tvector<shared_ptr<Geom3BSplineCurve>> vec;\n\tshared_ptr<Geom3BSplineCurve> vbsp1, vbsp2, vbsp3, vbsp4, hbsp1, hbsp2, hbsp3;\n\t{\n\t\tint deg = 3;\n\t\tstd::vector<Point3> poles;\n\t\tpoles.push_back(Point3(0.0, -1.0, 0.1));\n\t\tpoles.push_back(Point3(0.07, -0.7, 0.2));\n\t\tpoles.push_back(Point3(0.1, -0.3, 0.1));\n\t\tpoles.push_back(Point3(0.12, 0.0, -0.1));\n\t\tpoles.push_back(Point3(0.20, 0.3, -0.2));\n\t\tpoles.push_back(Point3(0.07, 0.7, -0.3));\n\t\tpoles.push_back(Point3(0.0, 1.0, 0.0));\n\t\tint nknots = static_cast<int>(poles.size()) - deg + 1;\n\t\tstd::vector<double> knots(nknots);\n\t\tfor (int i = 0; i < nknots; i++)\n\t\t{\n\t\t\tknots[i] = (double)i / (double)(nknots - 1.0);\n\t\t}\n\t\tstd::vector<int> mults(nknots, 1);\n\t\tmults.front() = deg + 1;\n\t\tmults.back() = deg + 1;\n\t\tvbsp1 = std::make_shared<Geom3BSplineCurve>(poles, knots, mults, deg);\n\t}\n\t{\n\t\tint deg = 3;\n\t\tstd::vector<Point3> poles;\n\t\tpoles.push_back(Point3(2.0, -2.0, -0.1));\n\t\tpoles.push_back(Point3(2.1, -1.3, -0.2));\n\t\tpoles.push_back(Point3(2.15, -0.8, -0.1));\n\t\tpoles.push_back(Point3(1.83, -0.2, 0.1));\n\t\tpoles.push_back(Point3(1.48, 0.1, 0.2));\n\t\tpoles.push_back(Point3(1.0, 1.0, 0.1));\n\t\tint nknots = static_cast<int>(poles.size()) - deg + 1;\n\t\tstd::vector<double> knots(nknots);\n\t\tfor (int i = 0; i < nknots; i++)\n\t\t{\n\t\t\tknots[i] = (double)i / (double)(nknots - 1.0);\n\t\t}\n\t\tstd::vector<int> mults(nknots, 1);\n\t\tmults.front() = deg + 1;\n\t\tmults.back() = deg + 1;\n\t\tvbsp2 = std::make_shared<Geom3BSplineCurve>(poles, knots, mults, deg);\n\t}\n\t{\n\t\tint deg = 3;\n\t\tstd::vector<Point3> poles;\n\t\tpoles.push_back(Point3(3.0, -2.0, 0.1));\n\t\tpoles.push_back(Point3(3.07, -1.3, 0.2));\n\t\tpoles.push_back(Point3(3.1, -0.3, 0.1));\n\t\tpoles.push_back(Point3(3.12, 0.0, -0.1));\n\t\tpoles.push_back(Point3(3.0, 0.3, -0.2));\n\t\tpoles.push_back(Point3(2.57, 0.7, -0.3));\n\t\tpoles.push_back(Point3(2.2, 1.0, 0.0));\n\t\tint nknots = static_cast<int>(poles.size()) - deg + 1;\n\t\tstd::vector<double> knots(nknots);\n\t\tfor (int i = 0; i < nknots; i++)\n\t\t{\n\t\t\tknots[i] = (double)i / (double)(nknots - 1.0);\n\t\t}\n\t\tstd::vector<int> mults(nknots, 1);\n\t\tmults.front() = deg + 1;\n\t\tmults.back() = deg + 1;\n\t\tvbsp3 = std::make_shared<Geom3BSplineCurve>(poles, knots, mults, deg);\n\t}\n\t{\n\t\tint deg = 3;\n\t\tstd::vector<Point3> poles;\n\t\tpoles.push_back(Point3(4.0, -1.5, -0.1));\n\t\tpoles.push_back(Point3(4.1, -1.3, -0.2));\n\t\tpoles.push_back(Point3(4.15, -0.8, -0.1));\n\t\tpoles.push_back(Point3(3.83, -0.2, 0.1));\n\t\tpoles.push_back(Point3(3.48, 0.1, 0.2));\n\t\tpoles.push_back(Point3(3.0, 1.0, 0.1));\n\t\tint nknots = static_cast<int>(poles.size()) - deg + 1;\n\t\tstd::vector<double> knots(nknots);\n\t\tfor (int i = 0; i < nknots; i++)\n\t\t{\n\t\t\tknots[i] = (double)i / (double)(nknots - 1.0);\n\t\t}\n\t\tstd::vector<int> mults(nknots, 1);\n\t\tmults.front() = deg + 1;\n\t\tmults.back() = deg + 1;\n\t\tvbsp4 = std::make_shared<Geom3BSplineCurve>(poles, knots, mults, deg);\n\t}\n\t{\n\t\tint deg = 3;\n\t\tstd::vector<Point3> poles;\n\t\tpoles.push_back(Point3(0.0, -1.0, 0.1));\n\t\tpoles.push_back(Point3(0.9, -1.5, -0.1));\n\t\tpoles.push_back(Point3(3.0, -1.8, 0.1));\n\t\tpoles.push_back(Point3(4.0, -1.5, -0.1));\n\t\tint nknots = static_cast<int>(poles.size()) - deg + 1;\n\t\tstd::vector<double> knots(nknots);\n\t\tfor (int i = 0; i < nknots; i++)\n\t\t{\n\t\t\tknots[i] = (double)i / (double)(nknots - 1.0);\n\t\t}\n\t\tstd::vector<int> mults(nknots, 1);\n\t\tmults.front() = deg + 1;\n\t\tmults.back() = deg + 1;\n\t\thbsp1 = std::make_shared<Geom3BSplineCurve>(poles, knots, mults, deg);\n\t}\n\t{\n\t\tint deg = 3;\n\t\tstd::vector<Point3> poles;\n\t\tpoles.push_back(Point3(0.0, 0.0, 0.0));\n\t\tpoles.push_back(Point3(1.2, -1.15, -0.1));\n\t\tpoles.push_back(Point3(2.7, -1.05, 0.1));\n\t\tpoles.push_back(Point3(3.7, -1.3, -0.1));\n\t\tpoles.push_back(Point3(5.0, -1.0, 0.1));\n\t\tint nknots = static_cast<int>(poles.size()) - deg + 1;\n\t\tstd::vector<double> knots(nknots);\n\t\tfor (int i = 0; i < nknots; i++)\n\t\t{\n\t\t\tknots[i] = (double)i / (double)(nknots - 1.0);\n\t\t}\n\t\tstd::vector<int> mults(nknots, 1);\n\t\tmults.front() = deg + 1;\n\t\tmults.back() = deg + 1;\n\t\thbsp2 = std::make_shared<Geom3BSplineCurve>(poles, knots, mults, deg);\n\t}\n\t{\n\t\tint deg = 3;\n\t\tvector<Point3> poles;\n\t\tpoles.push_back(Point3(0.0, 1.0, 0.0));\n\t\tpoles.push_back(Point3(0.9, 0.15, -0.1));\n\t\tpoles.push_back(Point3(1.7, 0.05, 0.1));\n\t\tpoles.push_back(Point3(2.7, 0.3, -0.1));\n\t\tpoles.push_back(Point3(3.0, 1.0, 0.1));\n\t\tint nknots = static_cast<int>(poles.size()) - deg + 1;\n\t\tvector<double> knots(nknots);\n\t\tfor (int i = 0; i < nknots; i++)\n\t\t{\n\t\t\tknots[i] = (double)i / (double)(nknots - 1.0);\n\t\t}\n\t\tvector<int> mults(nknots, 1);\n\t\tmults.front() = deg + 1;\n\t\tmults.back() = deg + 1;\n\t\thbsp3 = make_shared<Geom3BSplineCurve>(poles, knots, mults, deg);\n\t}\n\tvec.push_back(vbsp1);\n\tvec.push_back(vbsp2);\n\tvec.push_back(vbsp3);\n\tvec.push_back(vbsp4);\n\tvec.push_back(hbsp1);\n\tvec.push_back(hbsp2);\n\tvec.push_back(hbsp3);\n\treturn vec;\n}\nTEST_CASE(\"bug1: CurveNetworkSurface \", \"[nurbs][CurveNetworkSurface][fixbug]\")\n{\n\tOUTPUT_DIRECTORY(nurbs, CurveNetworkSurface/bug464);\n\tdouble refTol = 0.1;\n\tvector< shared_ptr<Geom3BSplineCurve>> vec = ConstructBSplineCurve();\n\tTopoEdge edge1 = MakeEdge(vec[0]);\n\tTopoEdge edge2 = MakeEdge(vec[1]);\n\tTopoEdge edge3 = MakeEdge(vec[2]);\n\tTopoEdge edge4 = MakeEdge(vec[3]);\n\tTopoEdge edge5 = MakeEdge(vec[4]);\n\tTopoEdge edge6 = MakeEdge(vec[5]);\n\tTopoEdge edge7 = MakeEdge(vec[6]);\n\tvector<shared_ptr<Geom3BSplineCurve>> horizontalCurves, verticalCurves;\n\tverticalCurves.push_back(vec[0]);\n\tverticalCurves.push_back(vec[1]);\n\tverticalCurves.push_back(vec[2]);\n\tverticalCurves.push_back(vec[3]);\n\thorizontalCurves.push_back(vec[4]);\n\thorizontalCurves.push_back(vec[5]);\n\thorizontalCurves.push_back(vec[6]);\n\tshared_ptr<Geom3BSplineSurface> surf = NURBSAPICurveNetworkSurface::CurveNetworkSurfaceGordon(verticalCurves, horizontalCurves);\n\tTopoShape surface = MakeFace(surf, 0.0);\n\tBRepExtremaDistShapeShape dist1(edge1, surface);\n\tBRepExtremaDistShapeShape dist2(edge2, surface);\n\tBRepExtremaDistShapeShape dist3(edge3, surface);\n\tBRepExtremaDistShapeShape dist4(edge4, surface);\n\tBRepExtremaDistShapeShape dist5(edge5, surface);\n\tBRepExtremaDistShapeShape dist6(edge6, surface);\n\tBRepExtremaDistShapeShape dist7(edge7, surface);\n\tCHECK(dist3.Value() <= Approx(refTol));\n\tCHECK(dist4.Value() <= Approx(refTol));\n\tCHECK(dist7.Value() <= Approx(refTol));\n\tOCCTIO::OCCTTool::Write(MakeEdge(vec[0]), outdir + \"vbsp1.brep\");\n\tOCCTIO::OCCTTool::Write(MakeEdge(vec[1]), outdir + \"vbsp2.brep\");\n\tOCCTIO::OCCTTool::Write(MakeEdge(vec[2]), outdir + \"vbsp3.brep\");\n\tOCCTIO::OCCTTool::Write(MakeEdge(vec[3]), outdir + \"vbsp4.brep\");\n\tOCCTIO::OCCTTool::Write(MakeEdge(vec[4]), outdir + \"hbsp1.brep\");\n\tOCCTIO::OCCTTool::Write(MakeEdge(vec[5]), outdir + \"hbsp2.brep\");\n\tOCCTIO::OCCTTool::Write(MakeEdge(vec[6]), outdir + \"hbsp3.brep\");\n\tOCCTIO::OCCTTool::Write(surface, outdir + \"surfResult.brep\");\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static std::vector<std::pair<double, bool>> CalcParamCorrespondece( const std::vector<std::shared_ptr<Geom3Curve>>& curves, bool isPeriodic, bool isConsiderReverse),\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <nurbs/NURBSAPICorrespondence.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <topology/TopoExplorerTool.hpp>\n#include <nurbs/NURBSAPIConvert.hpp>\nusing namespace std;\nTEST_CASE(\"case1: this is a test for CalcParamCorrespondece\", \"[nurbs][Correspondence][P1]\")\n{\n\tOUTPUT_DIRECTORY(nurbs, Correspondence);\n\tvector<shared_ptr<Geom3Curve>> curves;\n\tshared_ptr<Geom3BSplineCurve> vbsp1, vbsp2, vbsp3, vbsp4, hbsp1, hbsp2, hbsp3;\n\t{\n\t\tint deg = 3;\n\t\tstd::vector<Point3> poles;\n\t\tpoles.push_back(Point3(0.0, -1.0, 0.1));\n\t\tpoles.push_back(Point3(0.07, -0.7, 0.2));\n\t\tpoles.push_back(Point3(0.1, -0.3, 0.1));\n\t\tpoles.push_back(Point3(0.12, 0.0, -0.1));\n\t\tpoles.push_back(Point3(0.20, 0.3, -0.2));\n\t\tpoles.push_back(Point3(0.07, 0.7, -0.3));\n\t\tpoles.push_back(Point3(0.0, 1.0, 0.0));\n\t\tint nknots = static_cast<int>(poles.size()) - deg + 1;\n\t\tstd::vector<double> knots(nknots);\n\t\tfor (int i = 0; i < nknots; i++)\n\t\t{\n\t\t\tknots[i] = (double)i / (double)(nknots - 1.0);\n\t\t}\n\t\tstd::vector<int> mults(nknots, 1);\n\t\tmults.front() = deg + 1;\n\t\tmults.back() = deg + 1;\n\t\tvbsp1 = std::make_shared<Geom3BSplineCurve>(poles, knots, mults, deg);\n\t\tOCCTIO::OCCTTool::Write(MakeEdge(vbsp1), outdir + \"vbsp1.brep\");\n\t}\n\t{\n\t\tint deg = 3;\n\t\tstd::vector<Point3> poles;\n\t\tpoles.push_back(Point3(2.0, -2.0, -0.1));\n\t\tpoles.push_back(Point3(2.1, -1.3, -0.2));\n\t\tpoles.push_back(Point3(2.15, -0.8, -0.1));\n\t\tpoles.push_back(Point3(1.83, -0.2, 0.1));\n\t\tpoles.push_back(Point3(1.48, 0.1, 0.2));\n\t\tpoles.push_back(Point3(1.0, 1.0, 0.1));\n\t\tint nknots = static_cast<int>(poles.size()) - deg + 1;\n\t\tstd::vector<double> knots(nknots);\n\t\tfor (int i = 0; i < nknots; i++)\n\t\t{\n\t\t\tknots[i] = (double)i / (double)(nknots - 1.0);\n\t\t}\n\t\tstd::vector<int> mults(nknots, 1);\n\t\tmults.front() = deg + 1;\n\t\tmults.back() = deg + 1;\n\t\tvbsp2 = std::make_shared<Geom3BSplineCurve>(poles, knots, mults, deg);\n\t\tOCCTIO::OCCTTool::Write(MakeEdge(vbsp2), outdir + \"vbsp2.brep\");\n\t}\n\t{\n\t\tint deg = 3;\n\t\tstd::vector<Point3> poles;\n\t\tpoles.push_back(Point3(3.0, -2.0, 0.1));\n\t\tpoles.push_back(Point3(3.07, -1.3, 0.2));\n\t\tpoles.push_back(Point3(3.1, -0.3, 0.1));\n\t\tpoles.push_back(Point3(3.12, 0.0, -0.1));\n\t\tpoles.push_back(Point3(3.0, 0.3, -0.2));\n\t\tpoles.push_back(Point3(2.57, 0.7, -0.3));\n\t\tpoles.push_back(Point3(2.2, 1.0, 0.0));\n\t\tint nknots = static_cast<int>(poles.size()) - deg + 1;\n\t\tstd::vector<double> knots(nknots);\n\t\tfor (int i = 0; i < nknots; i++)\n\t\t{\n\t\t\tknots[i] = (double)i / (double)(nknots - 1.0);\n\t\t}\n\t\tstd::vector<int> mults(nknots, 1);\n\t\tmults.front() = deg + 1;\n\t\tmults.back() = deg + 1;\n\t\tvbsp3 = std::make_shared<Geom3BSplineCurve>(poles, knots, mults, deg);\n\t\tOCCTIO::OCCTTool::Write(MakeEdge(vbsp3), outdir + \"vbsp3.brep\");\n\t}\n\t{\n\t\tint deg = 3;\n\t\tstd::vector<Point3> poles;\n\t\tpoles.push_back(Point3(4.0, -1.5, -0.1));\n\t\tpoles.push_back(Point3(4.1, -1.3, -0.2));\n\t\tpoles.push_back(Point3(4.15, -0.8, -0.1));\n\t\tpoles.push_back(Point3(3.83, -0.2, 0.1));\n\t\tpoles.push_back(Point3(3.48, 0.1, 0.2));\n\t\tpoles.push_back(Point3(3.0, 1.0, 0.1));\n\t\tint nknots = static_cast<int>(poles.size()) - deg + 1;\n\t\tstd::vector<double> knots(nknots);\n\t\tfor (int i = 0; i < nknots; i++)\n\t\t{\n\t\t\tknots[i] = (double)i / (double)(nknots - 1.0);\n\t\t}\n\t\tstd::vector<int> mults(nknots, 1);\n\t\tmults.front() = deg + 1;\n\t\tmults.back() = deg + 1;\n\t\tvbsp4 = std::make_shared<Geom3BSplineCurve>(poles, knots, mults, deg);\n\t\tOCCTIO::OCCTTool::Write(MakeEdge(vbsp4), outdir + \"vbsp4.brep\");\n\t}\n\t{\n\t\tint deg = 3;\n\t\tstd::vector<Point3> poles;\n\t\tpoles.push_back(Point3(0.0, -1.0, 0.1));\n\t\tpoles.push_back(Point3(0.9, -1.5, -0.1));\n\t\tpoles.push_back(Point3(3.0, -1.8, 0.1));\n\t\tpoles.push_back(Point3(4.0, -1.5, -0.1));\n\t\tint nknots = static_cast<int>(poles.size()) - deg + 1;\n\t\tstd::vector<double> knots(nknots);\n\t\tfor (int i = 0; i < nknots; i++)\n\t\t{\n\t\t\tknots[i] = (double)i / (double)(nknots - 1.0);\n\t\t}\n\t\tstd::vector<int> mults(nknots, 1);\n\t\tmults.front() = deg + 1;\n\t\tmults.back() = deg + 1;\n\t\thbsp1 = std::make_shared<Geom3BSplineCurve>(poles, knots, mults, deg);\n\t\tOCCTIO::OCCTTool::Write(MakeEdge(hbsp1), outdir + \"hbsp1.brep\");\n\t}\n\t{\n\t\tint deg = 3;\n\t\tstd::vector<Point3> poles;\n\t\tpoles.push_back(Point3(0.0, 0.0, 0.0));\n\t\tpoles.push_back(Point3(1.2, -1.15, -0.1));\n\t\tpoles.push_back(Point3(2.7, -1.05, 0.1));\n\t\tpoles.push_back(Point3(3.7, -1.3, -0.1));\n\t\tpoles.push_back(Point3(5.0, -1.0, 0.1));\n\t\tint nknots = static_cast<int>(poles.size()) - deg + 1;\n\t\tstd::vector<double> knots(nknots);\n\t\tfor (int i = 0; i < nknots; i++)\n\t\t{\n\t\t\tknots[i] = (double)i / (double)(nknots - 1.0);\n\t\t}\n\t\tstd::vector<int> mults(nknots, 1);\n\t\tmults.front() = deg + 1;\n\t\tmults.back() = deg + 1;\n\t\thbsp2 = std::make_shared<Geom3BSplineCurve>(poles, knots, mults, deg);\n\t\tOCCTIO::OCCTTool::Write(MakeEdge(hbsp2), outdir + \"hbsp2.brep\");\n\t}\n\t{\n\t\tint deg = 3;\n\t\tvector<Point3> poles;\n\t\tpoles.push_back(Point3(0.0, 1.0, 0.0));\n\t\tpoles.push_back(Point3(0.9, 0.15, -0.1));\n\t\tpoles.push_back(Point3(1.7, 0.05, 0.1));\n\t\tpoles.push_back(Point3(2.7, 0.3, -0.1));\n\t\tpoles.push_back(Point3(3.0, 1.0, 0.1));\n\t\tint nknots = static_cast<int>(poles.size()) - deg + 1;\n\t\tvector<double> knots(nknots);\n\t\tfor (int i = 0; i < nknots; i++)\n\t\t{\n\t\t\tknots[i] = (double)i / (double)(nknots - 1.0);\n\t\t}\n\t\tvector<int> mults(nknots, 1);\n\t\tmults.front() = deg + 1;\n\t\tmults.back() = deg + 1;\n\t\thbsp3 = make_shared<Geom3BSplineCurve>(poles, knots, mults, deg);\n\t\tOCCTIO::OCCTTool::Write(MakeEdge(hbsp3), outdir + \"hbsp3.brep\");\n\t}\n\tcurves.push_back(vbsp1);\n\tcurves.push_back(vbsp2);\n\tcurves.push_back(vbsp3);\n\tcurves.push_back(vbsp4);\n\tcurves.push_back(hbsp1);\n\tcurves.push_back(hbsp2);\n\tcurves.push_back(hbsp3);\n\tSECTION(\"isPeriodic+isConsiderReverse\")\n\t{\n\t\tbool isPeriodic = true;\n\t\tbool isConsiderReverse = true;\n\t\tvector<pair<double, bool>> corrs = NURBSAPICorrespondence::CalcParamCorrespondece(curves, isPeriodic, isConsiderReverse);\n\t\tCHECK(corrs[0].first == 0.0);\n\t\tCHECK(corrs[0].second == false);\n\t\tCHECK(corrs[1].first > 0.0);\n\t\tCHECK(corrs[1].second == true);\n\t\tCHECK(corrs[2].first > 0.0);\n\t\tCHECK(corrs[2].second == true);\n\t\tCHECK(corrs[3].first > 0.0);\n\t\tCHECK(corrs[3].second == true);\n\t\tCHECK(corrs[4].first > 0.0);\n\t\tCHECK(corrs[4].second == true);\n\t\tCHECK(corrs[5].first > 0.0);\n\t\tCHECK(corrs[5].second == true);\n\t\tCHECK(corrs[6].first > 0.0);\n\t\tCHECK(corrs[6].second == true);\n\t\tCHECK(corrs.size() == 7);\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static std::shared_ptr<Geom3BSplineSurface> ToBSpline(const std::shared_ptr<Geom3Surface>& surface)\t @return BSpline surface\n\t @param surface The given surface\n\t @brief Convert a common surface to a BSpline surface\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include<common/Exception.hpp>\n#include <nurbs/NURBSAPIConvert.hpp>\n#include <topology/TopoEdge.hpp>\n#include <topology/TopoTool.hpp>\n#include <topology/TopoVertex.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include <geometry/Geom3BSplineCurve.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeFace.hpp>\n#include <geometry/Geom3Circle.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3BezierCurve.hpp>\n#include <geometry/Geom3Ellipse.hpp>\n#include <geometry/Geom3Hyperbola.hpp>\n#include <geometry/Geom3Parabola.hpp>\n#include <geometry/Geom3SphericalSurface.hpp>\n#include <math/Sphere.hpp>\n#include <geometry/Geom3Surface.hpp>\n#include <geometry/Geom3BSplineSurface.hpp>\n#include <geometry/Geom3TrimmedSurface.hpp>\n#include <geometry/Geom3ElementarySurface.hpp>\n#include <geometry/Geom3OffsetSurface.hpp>\n#include <geometry/Geom3SweptSurface.hpp>\n#include <geometry/Geom3SurfaceOfExtrusion.hpp>\n#include <geometry/Geom3BezierSurface.hpp>\n#include <math/Cone.hpp>\n#include <geometry/Geom3ConicalSurface.hpp>\n#include <geometry/Geom3CylindricalSurface.hpp>\n#include <geometry/Geom3Plane.hpp>\n#include <geometry/Geom3ToroidalSurface.hpp>\n#include <geometry/Geom3SurfaceOfExtrusion.hpp>\n#include <geometry/Geom3SurfaceOfRevolution.hpp>\nusing namespace std;\nusing namespace AMCAX;\ndouble NurbsLinearCurve(const shared_ptr<Geom3Curve>& curve1, const shared_ptr<Geom3BSplineCurve>& curve2)\n{\n    TopoShape edge1 = MakeEdge(curve1);\n    TopoShape edge2 = MakeEdge(curve2);\n    GlobalProperty props1, props2;\n    double len1 = GetLinearProperties(edge1, props1, true, false);\n    double len2 = GetLinearProperties(edge2, props2, true, false);\n    double len = abs(len1 - len2);\n    return len;\n}\ndouble NurbsSurfaceResult(const shared_ptr<Geom3Surface>& surface1, const shared_ptr<Geom3BSplineSurface>& surface2)\n{\n    TopoFace f1 = MakeFace(surface1, 0.0);\n    TopoFace f2 = MakeFace(surface2, 0.0);\n    GlobalProperty props1, props2;\n    double s1 = GetSurfaceProperties(f1, props1, true, false);\n    double s2 = GetSurfaceProperties(f2, props2, true, false);\n    double res = abs(s1 - s2);\n    return res;\n}\nTEST_CASE(\"bug5: ConvertToBSplineCurve \", \"[nurbs][convert][fixbug]\")\n{\n\tSECTION(\"Geom3BSplineSurface\")\n    {\n        shared_ptr<Geom3BSplineSurface> surf;\n        surf = make_shared<Geom3BSplineSurface>();\n        shared_ptr<Geom3BSplineSurface> bspSurf= NURBSAPIConvert::ToBSpline(surf);\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static std::shared_ptr<Geom3BSplineCurve> ToBSpline(const std::shared_ptr<Geom3Curve>& curve)\t @return Result BSpline curve\n\t @param curve The given curve\n\t @brief Convert a common curve to a BSpline curve\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include<common/Exception.hpp>\n#include <nurbs/NURBSAPIConvert.hpp>\n#include <topology/TopoEdge.hpp>\n#include <topology/TopoTool.hpp>\n#include <topology/TopoVertex.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include <geometry/Geom3BSplineCurve.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeFace.hpp>\n#include <geometry/Geom3Circle.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3BezierCurve.hpp>\n#include <geometry/Geom3Ellipse.hpp>\n#include <geometry/Geom3Hyperbola.hpp>\n#include <geometry/Geom3Parabola.hpp>\n#include <geometry/Geom3SphericalSurface.hpp>\n#include <math/Sphere.hpp>\n#include <geometry/Geom3Surface.hpp>\n#include <geometry/Geom3BSplineSurface.hpp>\n#include <geometry/Geom3TrimmedSurface.hpp>\n#include <geometry/Geom3ElementarySurface.hpp>\n#include <geometry/Geom3OffsetSurface.hpp>\n#include <geometry/Geom3SweptSurface.hpp>\n#include <geometry/Geom3SurfaceOfExtrusion.hpp>\n#include <geometry/Geom3BezierSurface.hpp>\n#include <math/Cone.hpp>\n#include <geometry/Geom3ConicalSurface.hpp>\n#include <geometry/Geom3CylindricalSurface.hpp>\n#include <geometry/Geom3Plane.hpp>\n#include <geometry/Geom3ToroidalSurface.hpp>\n#include <geometry/Geom3SurfaceOfExtrusion.hpp>\n#include <geometry/Geom3SurfaceOfRevolution.hpp>\nusing namespace std;\nusing namespace AMCAX;\ndouble NurbsLinearCurve(const shared_ptr<Geom3Curve>& curve1, const shared_ptr<Geom3BSplineCurve>& curve2)\n{\n    TopoShape edge1 = MakeEdge(curve1);\n    TopoShape edge2 = MakeEdge(curve2);\n    GlobalProperty props1, props2;\n    double len1 = GetLinearProperties(edge1, props1, true, false);\n    double len2 = GetLinearProperties(edge2, props2, true, false);\n    double len = abs(len1 - len2);\n    return len;\n}\ndouble NurbsSurfaceResult(const shared_ptr<Geom3Surface>& surface1, const shared_ptr<Geom3BSplineSurface>& surface2)\n{\n    TopoFace f1 = MakeFace(surface1, 0.0);\n    TopoFace f2 = MakeFace(surface2, 0.0);\n    GlobalProperty props1, props2;\n    double s1 = GetSurfaceProperties(f1, props1, true, false);\n    double s2 = GetSurfaceProperties(f2, props2, true, false);\n    double res = abs(s1 - s2);\n    return res;\n}\nTEST_CASE(\"bug1: ConvertToBSplineCurve \", \"[nurbs][convert][fixbug]\")\n{\n    double res;\n    double tol = 0.1;\n    Point3 p(0.0, 0.0, 0.0);\n    Direction3 dir(0.0, 0.0, 1.0);\n    Direction3 dir1(1.0, 0.0, 0.0);\n    shared_ptr<Geom3Curve> curve;\n    curve = make_shared<Geom3Circle>(Frame3(p, dir), 1.0);\n\tSECTION(\"TrimmedCurve = M_PI\")\n    {\n        shared_ptr<Geom3TrimmedCurve> TrimmedCurve = make_shared<Geom3TrimmedCurve>(curve, 0.0, M_PI);\n        Axis3 axis(p, dir1);\n        shared_ptr<Geom3SweptSurface> surf;\n        surf = make_shared<Geom3SurfaceOfRevolution>(TrimmedCurve, axis);\n        shared_ptr<Geom3BSplineSurface> bspSurf = NURBSAPIConvert::ToBSpline(surf);\n        res = NurbsSurfaceResult(surf, bspSurf);\n        CHECK(res <= tol);\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static std::pair<NURBSSweepStatus, std::vector<std::shared_ptr<Geom3BSplineSurface>>> SweepWithCurveOnTangencySurface(const std::shared_ptr<Geom3BSplineCurve>& guide, const std::shared_ptr<Geom3BSplineSurface>& tangencySurface, const LawFunction& radiusLaw, const LawFunction& angleLaw1, const LawFunction& angleLaw2, const std::shared_ptr<Geom3BSplineCurve>& spine, double spineLeftBound, double spineRightBound),\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <filesystem>\n#include <fstream>\n#include <random>\n#include <sstream>\n#include <nurbs/NURBSAPIGetGeometry.hpp>\n#include <nurbs/NURBSAPIConicalSweep.hpp>\n#include <boolean/BoolBRepCut.hpp>\n#include <common/CartesianCoordinateSystem.hpp>\n#include <common/IndexMap.hpp>\n#include <common/QuaternionT.hpp>\n#include <geomAlgo/LawBSpline.hpp>\n#include <geomAlgo/LawConstant.hpp>\n#include <nurbs/NURBSAPISmooth.hpp>\n#include <geomAlgo/MakeConic2FromConstraints.hpp>\n#include <geometry/Adaptor3CurveOnSurface.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/AdaptorGeom3Surface.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2Circle.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/Geom2Hyperbola.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3BSplineCurve.hpp>\n#include <geometry/Geom3BSplineSurface.hpp>\n#include <geometry/Geom3Circle.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\n#include <geometry/Geom3Plane.hpp>\n#include <geometry/Geom3SphericalSurface.hpp>\n#include <geometry/Geom3Surface.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include <geometry/Geom3TrimmedSurface.hpp>\n#include <geometry/GeomAPIExtremaCurveCurve3.hpp>\n#include <geometry/GeomAPIProjectPointOnCurve2.hpp>\n#include <geometry/GeomAPIProjectPointOnCurve3.hpp>\n#include <geometry/GeomAPIProjectPointOnSurface.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/GlobalProperty.hpp>\n#include <healing/ShapeFixTool.hpp>\n#include <io/STLTool.hpp>\n#include <math/Sphere.hpp>\n#include <math/TriangularMesh.hpp>\n#include <modeling/CopyShape.hpp>\n#include <modeling/MakeBox.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeFace.hpp>\n#include <modeling/MakePrism.hpp>\n#include <modeling/MakeRevol.hpp>\n#include <modeling/MakeShapeTool.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <modeling/MakeWire.hpp>\n#include <modeling/TransformShape.hpp>\n#include <nurbs/NURBSAPIApprox.hpp>\n#include <nurbs/NURBSAPIBuildCurve.hpp>\n#include <nurbs/NURBSAPICircularSweep.hpp>\n#include <nurbs/NURBSAPIConvert.hpp>\n#include <nurbs/NURBSAPICurveNetworkSurface.hpp>\n#include <nurbs/NURBSAPIExplicitSweep.hpp>\n#include <nurbs/NURBSAPIExplode.hpp>\n#include <nurbs/NURBSAPIExtend.hpp>\n#include <nurbs/NURBSAPIInterpolate.hpp>\n#include <nurbs/NURBSAPIJoin.hpp>\n#include <nurbs/NURBSAPILinearSweep.hpp>\n#include <nurbs/NURBSAPILoft.hpp>\n#include <nurbs/NURBSAPIMakeNURBSFromBoundaries.hpp>\n#include <nurbs/NURBSAPIMatch.hpp>\n#include <nurbs/NURBSAPIModifyEndToPlane.hpp>\n#include <nurbs/NURBSAPIOffsetCurveOnSurface.hpp>\n#include <nurbs/NURBSAPIProject.hpp>\n#include <nurbs/NURBSAPIRebuild.hpp>\n#include <nurbs/NURBSAPIReplaceEdge.hpp>\n#include <nurbs/NURBSAPISweep.hpp>\n#include <nurbs/NURBSAPISweep2.hpp>\n#include <nurbs/NURBSAPISweepRotation.hpp>\n#include <nurbs/NURBSAPITrim.hpp>\n#include <nurbs/NURBSAPIUntrim.hpp>\n#include <nurbs/NURBSLinearSweepWithDraftDirectionLength.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <offset/MakePipe.hpp>\n#include <offset/MakePipeShell.hpp>\n#include <topology/BRepAdaptorCurve2.hpp>\n#include <topology/BRepAdaptorCurve3.hpp>\n#include <topology/BRepAdaptorSurface.hpp>\n#include <topology/BRepGlobalProperty.hpp>\n#include <topology/BRepTool.hpp>\n#include <topology/TopoBuilder.hpp>\n#include <topology/TopoCompound.hpp>\n#include <topology/TopoEdge.hpp>\n#include <topology/TopoExplorer.hpp>\n#include <topology/TopoExplorerTool.hpp>\n#include <topology/TopoFace.hpp>\n#include <topology/TopoShape.hpp>\n#include <topology/TopoShell.hpp>\n#include <topology/TopoTool.hpp>\n#include <topology/TopoVertex.hpp>\n#include <topology/TopoWire.hpp>\n#include <topology/WireExplorer.hpp>\n#include <topomesh/BRepMeshIncrementalMesh.hpp>\n#include <nurbs/NURBSAPIBlend.hpp>\n#include <topology/BRepExtremaDistShapeShape.hpp>\n#include <math/LineT.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/GeomAPIIntSurfaceSurface.hpp>\nusing namespace AMCAX;\nnamespace\n{\n\tstd::shared_ptr<Geom3BSplineCurve> CurveChooser(const int id, const std::shared_ptr<Geom3BSplineCurve>& curve0, const std::shared_ptr<Geom3BSplineCurve>& curve1, const std::shared_ptr<Geom3BSplineCurve>& curve2)\n\t{\n\t\tstd::shared_ptr<Geom3BSplineCurve> result;\n\t\tswitch (id)\n\t\t{\n\t\tcase 0:\n\t\t{\n\t\t\tresult = curve0;\n\t\t\tbreak;\n\t\t}\n\t\tcase 1:\n\t\t{\n\t\t\tresult = curve1;\n\t\t\tbreak;\n\t\t}\n\t\tcase 2:\n\t\t{\n\t\t\tresult = curve2;\n\t\t\tbreak;\n\t\t}\n\t\t}\n\t\treturn result;\n\t}\n} \nTEST_CASE(\"case1:this is a case for CircularSweep\", \"[nurbs][forcase1][Circular]\")\n{\n\tGlobalProperty g;\n\tSECTION(\"TestCircularSweepWithCurveOnTangencySurface()\")\t\n\t\t{\n\t\t\tstd::string filedir(INPUT_PATH_PREFIX \"/TestNURBS/TestCircularSweepWithCurveOnTangencySurface/\");\n\t\t\tauto guide = ReadBRepCurve(filedir + \"guide.brep\");\n\t\t\tauto surface = ReadBRepSurface(filedir + \"surface.brep\");\n\t\t\tauto spine = ReadBRepCurve(filedir + \"spine.brep\");\n\t\t\tCHECK(OCCTIO::OCCTTool::Write(MakeEdge(guide), OUTPUT_PATH_PREFIX \"TestCircularSweepWithCurveOnTangencySurface_guide.brep\"));\n\t\t\tCHECK(OCCTIO::OCCTTool::Write(MakeEdge(spine), OUTPUT_PATH_PREFIX \"TestCircularSweepWithCurveOnTangencySurface_spine.brep\"));\n\t\t\tCHECK(OCCTIO::OCCTTool::Write(MakeFace(surface, 0.0), OUTPUT_PATH_PREFIX \"TestCircularSweepWithCurveOnTangencySurface_surface.brep\"));\n\t\t\tLawConstant radiusLaw, angleLaw1, angleLaw2;\n\t\t\tradiusLaw.Set(10.0, 0.0, 1.0);\n\t\t\tangleLaw1.Set(0.0, 0.0, 1.0);\n\t\t\tangleLaw2.Set(M_PI_2, 0.0, 1.0);\n\t\t\tauto [status, surfaces] = NURBSAPICircularSweep::SweepWithCurveOnTangencySurface(guide, surface, radiusLaw, angleLaw1, angleLaw2, spine, spine->FirstParameter(), spine->LastParameter());\n\t\t\tCHECK(status == NURBSSweepStatus::Success);\n\t\t\tif (status == NURBSSweepStatus::Success && !surfaces.empty())\n\t\t\t{\n\t\t\t\tint nsurfaces = static_cast<int>(surfaces.size());\n\t\t\t\tfor (int i = 0; i < nsurfaces; i++)\n\t\t\t\t{\n\t\t\t\t\tCHECK(OCCTIO::OCCTTool::Write(MakeFace(surfaces[i], 0.0), OUTPUT_PATH_PREFIX \"TestCircularSweepWithCurveOnTangencySurface_result\" + std::to_string(i) + \".brep\"));\n\t\t\t\t\tCHECK(IsCurveOnSurf(1000, 0.1, guide, surfaces[i], 0.5));\n\t\t\t\t\tAMCAX::BRepExtremaDistShapeShape len(MakeFace(surface, 0.0), MakeFace(surfaces[i], 0.0));\n\t\t\t\t\tAMCAX::BRepExtremaDistShapeShape len1(MakeFace(surfaces[i], 0.0), MakeEdge(guide));\n\t\t\t\t\tCHECK(len1.Value() < 1.0);\n\t\t\t\t\tCHECK(len.Value() < 0.1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tstd::string filedir1 = OUTPUT_PATH_PREFIX;\n\t\t\tIndexSet<TopoShape> newshapeEdge1;\n\t\t\tIndexSet<TopoShape> newshapeEdge2;\n\t\t\tTopoExplorerTool::MapShapes(MakeFace(surfaces[0], 0.0), ShapeType::Edge, newshapeEdge1);\n\t\t\tTopoExplorerTool::MapShapes(MakeFace(surfaces[1], 0.0), ShapeType::Edge, newshapeEdge2);\n\t\t\tstd::cout << \"newshapedege.size\" << newshapeEdge1.size() << endl;\n\t\t\tCHECK(OCCTIO::OCCTTool::Write(newshapeEdge1[0], OUTPUT_PATH_PREFIX \"TestCircularSweepWithCurveOnTangencySurface_newshapeEdge1[0].brep\"));\n\t\t\tCHECK(OCCTIO::OCCTTool::Write(newshapeEdge2[1], OUTPUT_PATH_PREFIX \"TestCircularSweepWithCurveOnTangencySurface_newshapeEdge2[1].brep\"));\n\t\t\tCHECK(OCCTIO::OCCTTool::Write(newshapeEdge2[2], OUTPUT_PATH_PREFIX \"TestCircularSweepWithCurveOnTangencySurface_newshapeEdge2[2].brep\"));\n\t\t\tCHECK(OCCTIO::OCCTTool::Write(newshapeEdge2[0], OUTPUT_PATH_PREFIX \"TestCircularSweepWithCurveOnTangencySurface_newshapeEdge2[0].brep\"));\n\t\t\tCHECK(OCCTIO::OCCTTool::Write(newshapeEdge2[3], OUTPUT_PATH_PREFIX \"TestCircularSweepWithCurveOnTangencySurface_newshapeEdge2[3].brep\"));\n\t\t\tauto edge0 = ReadBRepCurve(filedir1 + \"TestCircularSweepWithCurveOnTangencySurface_newshapeEdge1[0].brep\");\n\t\t\tauto edge1 = ReadBRepCurve(filedir1 + \"TestCircularSweepWithCurveOnTangencySurface_newshapeEdge2[0].brep\");\n\t\t\tCHECK(IsSurfTangent(100, 0.6, edge0, surface, surfaces[0], 20, 0));\n\t\t\tCHECK(IsSurfTangent(100, 0.6, edge1, surface, surfaces[0], 20, 0));\n\t\t\tguide->IncreaseDegree(5);\n\t\t\tspine->IncreaseDegree(5);\n\t\t\tsurface->IncreaseDegree(5, 5);\n\t\t\tauto [status1, surfaces1] = NURBSAPICircularSweep::SweepWithCurveOnTangencySurface(guide, surface, radiusLaw, angleLaw1, angleLaw2, spine, spine->FirstParameter(), spine->LastParameter());\n\t\t\tCHECK(status1 == NURBSSweepStatus::Success);\n\t\t\tif (status1 == NURBSSweepStatus::Success && !surfaces.empty())\n\t\t\t{\n\t\t\t\tint nsurfaces = static_cast<int>(surfaces.size());\n\t\t\t\tfor (int i = 0; i < nsurfaces; i++)\n\t\t\t\t{\n\t\t\t\t\tCHECK(OCCTIO::OCCTTool::Write(MakeFace(surfaces1[i], 0.0), OUTPUT_PATH_PREFIX \"TestCircularSweepWithCurveOnTangencySurface_degree5result\" + std::to_string(i) + \".brep\"));\n\t\t\t\t\tCHECK(IsCurveOnSurf(1000, 0.1, guide, surfaces1[i], 0.5));\n\t\t\t\t\tdouble bsp3s = GetSurfaceProperties(MakeFace(surfaces1[i], 0.0), g, true, true);\n\t\t\t\t\tdouble bsp4s = GetSurfaceProperties(MakeFace(surfaces[i], 0.0), g, true, true);\n\t\t\t\t\tCHECK(bsp3s == Approx(bsp4s).margin(0.02));\n\t\t\t\t}\n\t\t\t}\n\t\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static std::pair<NURBSSweepStatus, std::vector<std::shared_ptr<Geom3BSplineSurface>>> SweepWithOneGuideAndTangencySurface(const std::shared_ptr<Geom3BSplineCurve>& guide, const std::shared_ptr<Geom3BSplineSurface>& tangencySurface, const LawFunction& radiusLaw, const std::shared_ptr<Geom3BSplineCurve>& spine, double spineLeftBound, double spineRightBound),\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <filesystem>\n#include <fstream>\n#include <random>\n#include <sstream>\n#include <nurbs/NURBSAPIGetGeometry.hpp>\n#include <nurbs/NURBSAPIConicalSweep.hpp>\n#include <boolean/BoolBRepCut.hpp>\n#include <common/CartesianCoordinateSystem.hpp>\n#include <common/IndexMap.hpp>\n#include <common/QuaternionT.hpp>\n#include <geomAlgo/LawBSpline.hpp>\n#include <geomAlgo/LawConstant.hpp>\n#include <nurbs/NURBSAPISmooth.hpp>\n#include <geomAlgo/MakeConic2FromConstraints.hpp>\n#include <geometry/Adaptor3CurveOnSurface.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/AdaptorGeom3Surface.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2Circle.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/Geom2Hyperbola.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3BSplineCurve.hpp>\n#include <geometry/Geom3BSplineSurface.hpp>\n#include <geometry/Geom3Circle.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\n#include <geometry/Geom3Plane.hpp>\n#include <geometry/Geom3SphericalSurface.hpp>\n#include <geometry/Geom3Surface.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include <geometry/Geom3TrimmedSurface.hpp>\n#include <geometry/GeomAPIExtremaCurveCurve3.hpp>\n#include <geometry/GeomAPIProjectPointOnCurve2.hpp>\n#include <geometry/GeomAPIProjectPointOnCurve3.hpp>\n#include <geometry/GeomAPIProjectPointOnSurface.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/GlobalProperty.hpp>\n#include <healing/ShapeFixTool.hpp>\n#include <io/STLTool.hpp>\n#include <math/Sphere.hpp>\n#include <math/TriangularMesh.hpp>\n#include <modeling/CopyShape.hpp>\n#include <modeling/MakeBox.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeFace.hpp>\n#include <modeling/MakePrism.hpp>\n#include <modeling/MakeRevol.hpp>\n#include <modeling/MakeShapeTool.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <modeling/MakeWire.hpp>\n#include <modeling/TransformShape.hpp>\n#include <nurbs/NURBSAPIApprox.hpp>\n#include <nurbs/NURBSAPIBuildCurve.hpp>\n#include <nurbs/NURBSAPICircularSweep.hpp>\n#include <nurbs/NURBSAPIConvert.hpp>\n#include <nurbs/NURBSAPICurveNetworkSurface.hpp>\n#include <nurbs/NURBSAPIExplicitSweep.hpp>\n#include <nurbs/NURBSAPIExplode.hpp>\n#include <nurbs/NURBSAPIExtend.hpp>\n#include <nurbs/NURBSAPIInterpolate.hpp>\n#include <nurbs/NURBSAPIJoin.hpp>\n#include <nurbs/NURBSAPILinearSweep.hpp>\n#include <nurbs/NURBSAPILoft.hpp>\n#include <nurbs/NURBSAPIMakeNURBSFromBoundaries.hpp>\n#include <nurbs/NURBSAPIMatch.hpp>\n#include <nurbs/NURBSAPIModifyEndToPlane.hpp>\n#include <nurbs/NURBSAPIOffsetCurveOnSurface.hpp>\n#include <nurbs/NURBSAPIProject.hpp>\n#include <nurbs/NURBSAPIRebuild.hpp>\n#include <nurbs/NURBSAPIReplaceEdge.hpp>\n#include <nurbs/NURBSAPISweep.hpp>\n#include <nurbs/NURBSAPISweep2.hpp>\n#include <nurbs/NURBSAPISweepRotation.hpp>\n#include <nurbs/NURBSAPITrim.hpp>\n#include <nurbs/NURBSAPIUntrim.hpp>\n#include <nurbs/NURBSLinearSweepWithDraftDirectionLength.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <offset/MakePipe.hpp>\n#include <offset/MakePipeShell.hpp>\n#include <topology/BRepAdaptorCurve2.hpp>\n#include <topology/BRepAdaptorCurve3.hpp>\n#include <topology/BRepAdaptorSurface.hpp>\n#include <topology/BRepGlobalProperty.hpp>\n#include <topology/BRepTool.hpp>\n#include <topology/TopoBuilder.hpp>\n#include <topology/TopoCompound.hpp>\n#include <topology/TopoEdge.hpp>\n#include <topology/TopoExplorer.hpp>\n#include <topology/TopoExplorerTool.hpp>\n#include <topology/TopoFace.hpp>\n#include <topology/TopoShape.hpp>\n#include <topology/TopoShell.hpp>\n#include <topology/TopoTool.hpp>\n#include <topology/TopoVertex.hpp>\n#include <topology/TopoWire.hpp>\n#include <topology/WireExplorer.hpp>\n#include <topomesh/BRepMeshIncrementalMesh.hpp>\n#include <nurbs/NURBSAPIBlend.hpp>\n#include <topology/BRepExtremaDistShapeShape.hpp>\n#include <math/LineT.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/GeomAPIIntSurfaceSurface.hpp>\nusing namespace AMCAX;\nnamespace\n{\n\tstd::shared_ptr<Geom3BSplineCurve> CurveChooser(const int id, const std::shared_ptr<Geom3BSplineCurve>& curve0, const std::shared_ptr<Geom3BSplineCurve>& curve1, const std::shared_ptr<Geom3BSplineCurve>& curve2)\n\t{\n\t\tstd::shared_ptr<Geom3BSplineCurve> result;\n\t\tswitch (id)\n\t\t{\n\t\tcase 0:\n\t\t{\n\t\t\tresult = curve0;\n\t\t\tbreak;\n\t\t}\n\t\tcase 1:\n\t\t{\n\t\t\tresult = curve1;\n\t\t\tbreak;\n\t\t}\n\t\tcase 2:\n\t\t{\n\t\t\tresult = curve2;\n\t\t\tbreak;\n\t\t}\n\t\t}\n\t\treturn result;\n\t}\n} \nTEST_CASE(\"case1:this is a case for CircularSweep\", \"[nurbs][forcase1][Circular]\")\n{\n\tGlobalProperty g;\n\tSECTION(\"TestCircularSweepWithOneGuideAndTangencySurface()\")\n\t\t{\n\t\t\tstd::string filedir(INPUT_PATH_PREFIX \"/TestNURBS/TestCircularSweepWithOneGuideAndTangencySurface/\");\n\t\t\tauto guide = ReadBRepCurve(filedir + \"guide.brep\");\n\t\t\tauto surface = ReadBRepSurface(filedir + \"surface.brep\");\n\t\t\tauto spine = ReadBRepCurve(filedir + \"spine.brep\");\n\t\t\tCHECK(OCCTIO::OCCTTool::Write(MakeEdge(guide), OUTPUT_PATH_PREFIX \"TestCircularSweepWithOneGuideAndTangencySurface_guide.brep\"));\n\t\t\tCHECK(OCCTIO::OCCTTool::Write(MakeEdge(spine), OUTPUT_PATH_PREFIX \"TestCircularSweepWithOneGuideAndTangencySurface_spine.brep\"));\n\t\t\tCHECK(OCCTIO::OCCTTool::Write(MakeFace(surface, 0.0), OUTPUT_PATH_PREFIX \"TestCircularSweepWithOneGuideAndTangencySurface_surface.brep\"));\n\t\t\tLawConstant radiusLaw;\n\t\t\tradiusLaw.Set(10.0, 0.0, 1.0);\n\t\t\tclock_t bg = clock();\n\t\t\tauto [status, surfaces] = NURBSAPICircularSweep::SweepWithOneGuideAndTangencySurface(guide, surface, radiusLaw, spine, spine->FirstParameter(), spine->LastParameter());\n\t\t\tGlobalProperty g;\n\t\t\tclock_t ed = clock();\n\t\t\tstd::cout << \"time = \" << ed - bg << \"ms\" << std::endl;\n\t\t\tCHECK(status == NURBSSweepStatus::Success);\n\t\t\tif (status == NURBSSweepStatus::Success && !surfaces.empty())\n\t\t\t{\n\t\t\t\tint nsurfaces = static_cast<int>(surfaces.size());\n\t\t\t\tfor (int i = 0; i < nsurfaces; i++)\n\t\t\t\t{\n\t\t\t\t\tAMCAX::BRepExtremaDistShapeShape len(MakeFace(surface, 0.0), MakeFace(surfaces[i], 0.0));\n\t\t\t\t\tAMCAX::BRepExtremaDistShapeShape len1(MakeFace(surfaces[i], 0.0), MakeEdge(guide));\n\t\t\t\t\tCHECK(len.Value() < 0.1);\n\t\t\t\t\tCHECK(len1.Value() < 0.1);\n\t\t\t\t\tCHECK(OCCTIO::OCCTTool::Write(MakeFace(surfaces[i], 0.0), OUTPUT_PATH_PREFIX \"TestCircularSweepWithOneGuideAndTangencySurface_result\" + std::to_string(i) + \".brep\"));\n\t\t\t\t}\n\t\t\t}\n\t\t\tstd::string filedir1 = OUTPUT_PATH_PREFIX;\n\t\t\tIndexSet<TopoShape> newshapeEdge0;\n\t\t\tIndexSet<TopoShape> newshapeEdge1;\n\t\t\tIndexSet<TopoShape> newshapeEdge2;\n\t\t\tIndexSet<TopoShape> newshapeEdge3;\n\t\t\tTopoExplorerTool::MapShapes(MakeFace(surfaces[0], 0.0), ShapeType::Edge, newshapeEdge0);\n\t\t\tTopoExplorerTool::MapShapes(MakeFace(surfaces[1], 0.0), ShapeType::Edge, newshapeEdge1);\n\t\t\tTopoExplorerTool::MapShapes(MakeFace(surfaces[2], 0.0), ShapeType::Edge, newshapeEdge2);\n\t\t\tTopoExplorerTool::MapShapes(MakeFace(surfaces[3], 0.0), ShapeType::Edge, newshapeEdge3);\n\t\t\tstd::cout << \"newshapedege.size\" << newshapeEdge1.size() << endl;\n\t\t\tCHECK(OCCTIO::OCCTTool::Write(newshapeEdge0[0], OUTPUT_PATH_PREFIX \"TestCircularSweepWithOneGuideAndTangencySurface_newshapeEdge0[0].brep\"));\n\t\t\tCHECK(OCCTIO::OCCTTool::Write(newshapeEdge1[2], OUTPUT_PATH_PREFIX \"TestCircularSweepWithOneGuideAndTangencySurface_newshapeEdge1[2].brep\"));\n\t\t\tCHECK(OCCTIO::OCCTTool::Write(newshapeEdge2[0], OUTPUT_PATH_PREFIX \"TestCircularSweepWithOneGuideAndTangencySurface_newshapeEdge2[0].brep\"));\n\t\t\tCHECK(OCCTIO::OCCTTool::Write(newshapeEdge3[0], OUTPUT_PATH_PREFIX \"TestCircularSweepWithOneGuideAndTangencySurface_newshapeEdge3[0].brep\"));\n\t\t\tauto edge0 = ReadBRepCurve(filedir1 + \"TestCircularSweepWithOneGuideAndTangencySurface_newshapeEdge0[0].brep\");\n\t\t\tauto edge1 = ReadBRepCurve(filedir1 + \"TestCircularSweepWithOneGuideAndTangencySurface_newshapeEdge1[2].brep\");\n\t\t\tauto edge2 = ReadBRepCurve(filedir1 + \"TestCircularSweepWithOneGuideAndTangencySurface_newshapeEdge2[0].brep\");\n\t\t\tauto edge3 = ReadBRepCurve(filedir1 + \"TestCircularSweepWithOneGuideAndTangencySurface_newshapeEdge3[0].brep\");\n\t\t\tCHECK(IsSurfTangent(100, 0.6, edge0, surface, surfaces[0], 20, 0));\n\t\t\tCHECK(IsSurfTangent(100, 0.6, edge1, surface, surfaces[1], 20, 180));\n\t\t\tCHECK(IsSurfTangent(100, 0.6, edge2, surface, surfaces[2], 20, 180));\n\t\t\tCHECK(IsSurfTangent(100, 0.6, edge3, surface, surfaces[3], 20, 0));\n\t\t\tguide->IncreaseDegree(11);\n\t\t\tspine->IncreaseDegree(11);\n\t\t\tsurface->IncreaseDegree(11, 11);\n\t\t\tauto [status1, surfaces1] = NURBSAPICircularSweep::SweepWithOneGuideAndTangencySurface(guide, surface, radiusLaw, spine, spine->FirstParameter(), spine->LastParameter());\n\t\t\tCHECK(status1 == NURBSSweepStatus::Success);\n\t\t\tif (status1 == NURBSSweepStatus::Success && !surfaces.empty())\n\t\t\t{\n\t\t\t\tint nsurfaces = static_cast<int>(surfaces.size());\n\t\t\t\tfor (int i = 0; i < nsurfaces; i++)\n\t\t\t\t{\n\t\t\t\t\tCHECK(OCCTIO::OCCTTool::Write(MakeFace(surfaces1[i], 0.0), OUTPUT_PATH_PREFIX \"TestCircularSweepWithOneGuideAndTangencySurface_degree11result\" + std::to_string(i) + \".brep\"));\n\t\t\t\t\tdouble bsp3s = GetSurfaceProperties(MakeFace(surfaces1[i], 0.0), g, true, true);\n\t\t\t\t\tdouble bsp4s = GetSurfaceProperties(MakeFace(surfaces[i], 0.0), g, true, true);\n\t\t\t\t\tCHECK(bsp3s == Approx(bsp4s).margin(0.02));\n\t\t\t\t}\n\t\t\t}\n\t\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static std::pair<NURBSSweepStatus, std::vector<std::shared_ptr<Geom3BSplineSurface>>> SweepWithTwoGuidesAndTangencySurface(const std::shared_ptr<Geom3BSplineCurve>& limitCurveWithTangency, const std::shared_ptr<Geom3BSplineSurface>& tangencySurface, const std::shared_ptr<Geom3BSplineCurve>& limitCurve, const std::shared_ptr<Geom3BSplineCurve>& spine, double spineLeftBound, double spineRightBound),\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <filesystem>\n#include <fstream>\n#include <random>\n#include <sstream>\n#include <nurbs/NURBSAPIGetGeometry.hpp>\n#include <nurbs/NURBSAPIConicalSweep.hpp>\n#include <boolean/BoolBRepCut.hpp>\n#include <common/CartesianCoordinateSystem.hpp>\n#include <common/IndexMap.hpp>\n#include <common/QuaternionT.hpp>\n#include <geomAlgo/LawBSpline.hpp>\n#include <geomAlgo/LawConstant.hpp>\n#include <nurbs/NURBSAPISmooth.hpp>\n#include <geomAlgo/MakeConic2FromConstraints.hpp>\n#include <geometry/Adaptor3CurveOnSurface.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/AdaptorGeom3Surface.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2Circle.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/Geom2Hyperbola.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3BSplineCurve.hpp>\n#include <geometry/Geom3BSplineSurface.hpp>\n#include <geometry/Geom3Circle.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\n#include <geometry/Geom3Plane.hpp>\n#include <geometry/Geom3SphericalSurface.hpp>\n#include <geometry/Geom3Surface.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include <geometry/Geom3TrimmedSurface.hpp>\n#include <geometry/GeomAPIExtremaCurveCurve3.hpp>\n#include <geometry/GeomAPIProjectPointOnCurve2.hpp>\n#include <geometry/GeomAPIProjectPointOnCurve3.hpp>\n#include <geometry/GeomAPIProjectPointOnSurface.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/GlobalProperty.hpp>\n#include <healing/ShapeFixTool.hpp>\n#include <io/STLTool.hpp>\n#include <math/Sphere.hpp>\n#include <math/TriangularMesh.hpp>\n#include <modeling/CopyShape.hpp>\n#include <modeling/MakeBox.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeFace.hpp>\n#include <modeling/MakePrism.hpp>\n#include <modeling/MakeRevol.hpp>\n#include <modeling/MakeShapeTool.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <modeling/MakeWire.hpp>\n#include <modeling/TransformShape.hpp>\n#include <nurbs/NURBSAPIApprox.hpp>\n#include <nurbs/NURBSAPIBuildCurve.hpp>\n#include <nurbs/NURBSAPICircularSweep.hpp>\n#include <nurbs/NURBSAPIConvert.hpp>\n#include <nurbs/NURBSAPICurveNetworkSurface.hpp>\n#include <nurbs/NURBSAPIExplicitSweep.hpp>\n#include <nurbs/NURBSAPIExplode.hpp>\n#include <nurbs/NURBSAPIExtend.hpp>\n#include <nurbs/NURBSAPIInterpolate.hpp>\n#include <nurbs/NURBSAPIJoin.hpp>\n#include <nurbs/NURBSAPILinearSweep.hpp>\n#include <nurbs/NURBSAPILoft.hpp>\n#include <nurbs/NURBSAPIMakeNURBSFromBoundaries.hpp>\n#include <nurbs/NURBSAPIMatch.hpp>\n#include <nurbs/NURBSAPIModifyEndToPlane.hpp>\n#include <nurbs/NURBSAPIOffsetCurveOnSurface.hpp>\n#include <nurbs/NURBSAPIProject.hpp>\n#include <nurbs/NURBSAPIRebuild.hpp>\n#include <nurbs/NURBSAPIReplaceEdge.hpp>\n#include <nurbs/NURBSAPISweep.hpp>\n#include <nurbs/NURBSAPISweep2.hpp>\n#include <nurbs/NURBSAPISweepRotation.hpp>\n#include <nurbs/NURBSAPITrim.hpp>\n#include <nurbs/NURBSAPIUntrim.hpp>\n#include <nurbs/NURBSLinearSweepWithDraftDirectionLength.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <offset/MakePipe.hpp>\n#include <offset/MakePipeShell.hpp>\n#include <topology/BRepAdaptorCurve2.hpp>\n#include <topology/BRepAdaptorCurve3.hpp>\n#include <topology/BRepAdaptorSurface.hpp>\n#include <topology/BRepGlobalProperty.hpp>\n#include <topology/BRepTool.hpp>\n#include <topology/TopoBuilder.hpp>\n#include <topology/TopoCompound.hpp>\n#include <topology/TopoEdge.hpp>\n#include <topology/TopoExplorer.hpp>\n#include <topology/TopoExplorerTool.hpp>\n#include <topology/TopoFace.hpp>\n#include <topology/TopoShape.hpp>\n#include <topology/TopoShell.hpp>\n#include <topology/TopoTool.hpp>\n#include <topology/TopoVertex.hpp>\n#include <topology/TopoWire.hpp>\n#include <topology/WireExplorer.hpp>\n#include <topomesh/BRepMeshIncrementalMesh.hpp>\n#include <nurbs/NURBSAPIBlend.hpp>\n#include <topology/BRepExtremaDistShapeShape.hpp>\n#include <math/LineT.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/GeomAPIIntSurfaceSurface.hpp>\nusing namespace AMCAX;\nnamespace\n{\n\tstd::shared_ptr<Geom3BSplineCurve> CurveChooser(const int id, const std::shared_ptr<Geom3BSplineCurve>& curve0, const std::shared_ptr<Geom3BSplineCurve>& curve1, const std::shared_ptr<Geom3BSplineCurve>& curve2)\n\t{\n\t\tstd::shared_ptr<Geom3BSplineCurve> result;\n\t\tswitch (id)\n\t\t{\n\t\tcase 0:\n\t\t{\n\t\t\tresult = curve0;\n\t\t\tbreak;\n\t\t}\n\t\tcase 1:\n\t\t{\n\t\t\tresult = curve1;\n\t\t\tbreak;\n\t\t}\n\t\tcase 2:\n\t\t{\n\t\t\tresult = curve2;\n\t\t\tbreak;\n\t\t}\n\t\t}\n\t\treturn result;\n\t}\n} \nTEST_CASE(\"case1:this is a case for CircularSweep\", \"[nurbs][forcase1][Circular]\")\n{\n\tGlobalProperty g;\n\tSECTION(\"TestCircularSweepWithTwoGuidesAndTangencySurface()\")\n\t{\n\t\tstd::string filedir(INPUT_PATH_PREFIX \"/TestNURBS/TestCircularSweepWithTwoGuidesAndTangencySurface/\");\n\t\tauto guide1 = ReadBRepCurve(filedir + \"guide1.brep\");\n\t\tauto guide2 = ReadBRepCurve(filedir + \"guide2.brep\");\n\t\tauto surface = ReadBRepSurface(filedir + \"surface.brep\");\n\t\tauto spine = ReadBRepCurve(filedir + \"spine.brep\");\n\t\tCHECK(OCCTIO::OCCTTool::Write(MakeEdge(guide1), OUTPUT_PATH_PREFIX \"TestCircularSweepWithTwoGuidesAndTangencySurface_guide1.brep\"));\n\t\tCHECK(OCCTIO::OCCTTool::Write(MakeEdge(guide2), OUTPUT_PATH_PREFIX \"TestCircularSweepWithTwoGuidesAndTangencySurface_guide2.brep\"));\n\t\tCHECK(OCCTIO::OCCTTool::Write(MakeEdge(spine), OUTPUT_PATH_PREFIX \"TestCircularSweepWithTwoGuidesAndTangencySurface_spine.brep\"));\n\t\tCHECK(OCCTIO::OCCTTool::Write(MakeFace(surface, 0.0), OUTPUT_PATH_PREFIX \"TestCircularSweepWithTwoGuidesAndTangencySurface_surface.brep\"));\n\t\tauto [status, surfaces] = NURBSAPICircularSweep::SweepWithTwoGuidesAndTangencySurface(guide1, surface, guide2, spine, spine->FirstParameter(), spine->LastParameter());\n\t\tCHECK(status == NURBSSweepStatus::Success);\n\t\tif (status == NURBSSweepStatus::Success && !surfaces.empty())\n\t\t{\n\t\t\tCHECK(surfaces.size() == Approx(2.0));\n\t\t\tfor (int i = 0; i < surfaces.size(); i++) {\n\t\t\t\tCHECK(OCCTIO::OCCTTool::Write(MakeFace(surfaces[i], 0.0), OUTPUT_PATH_PREFIX \"TestCircularSweepWithTwoGuidesAndTangencySurface_result\" + std::to_string(i) + \".brep\"));\n\t\t\t\tAMCAX::BRepExtremaDistShapeShape len1(MakeEdge(guide1), MakeFace(surfaces[i], 0.0));\n\t\t\t\tAMCAX::BRepExtremaDistShapeShape len2(MakeEdge(guide2), MakeFace(surfaces[i], 0.0));\n\t\t\t\tAMCAX::BRepExtremaDistShapeShape len3(MakeFace(surface, 0.0), MakeFace(surfaces[i], 0.0));\n\t\t\t\tCHECK(len1.Value() < 0.1);\n\t\t\t\tCHECK(len2.Value() < 0.1);\n\t\t\t\tCHECK(len3.Value() < 0.1);\n\t\t\t\tCHECK(IsCurveOnSurf(100, 0.3, guide1, surfaces[i], 0.1));\n\t\t\t\tCHECK(IsCurveOnSurf(100, 0.3, guide2, surfaces[i], 0.1));\n\t\t\t}\n\t\t}\n\t\t\tCHECK(IsSurfTangent(100, 0.6, guide1, surface, surfaces[0], 20, 180));\n\t\t\tCHECK(IsSurfTangent(100, 0.6, guide1, surface, surfaces[1], 20, 180));\n\t\t\tguide1->IncreaseDegree(11);\n\t\t\tguide2->IncreaseDegree(11);\n\t\t\tspine->IncreaseDegree(11);\n\t\t\tsurface->IncreaseDegree(11, 11);\n\t\t\tauto [status1, surfaces1] = NURBSAPICircularSweep::SweepWithTwoGuidesAndTangencySurface(guide1, surface, guide2, spine, spine->FirstParameter(), spine->LastParameter());\n\t\t\tCHECK(status1 == NURBSSweepStatus::Success);\n\t\t\tif (status1 == NURBSSweepStatus::Success && !surfaces1.empty())\n\t\t\t{\n\t\t\t\tCHECK(surfaces1.size() == Approx(2.0));\n\t\t\t\tfor (int i = 0; i < surfaces1.size(); i++) {\n\t\t\t\t\tCHECK(OCCTIO::OCCTTool::Write(MakeFace(surfaces1[i], 0.0), OUTPUT_PATH_PREFIX \"TestCircularSweepWithTwoGuidesAndTangencySurface_result\" + std::to_string(i) + \".brep\"));\n\t\t\t\t\tAMCAX::BRepExtremaDistShapeShape len1(MakeEdge(guide1), MakeFace(surfaces1[i], 0.0));\n\t\t\t\t\tAMCAX::BRepExtremaDistShapeShape len2(MakeEdge(guide2), MakeFace(surfaces1[i], 0.0));\n\t\t\t\t\tAMCAX::BRepExtremaDistShapeShape len3(MakeFace(surface, 0.0), MakeFace(surfaces1[i], 0.0));\n\t\t\t\t\tCHECK(len1.Value() < 0.1);\n\t\t\t\t\tCHECK(len2.Value() < 0.1);\n\t\t\t\t\tCHECK(len3.Value() < 0.1);\n\t\t\t\t\tCHECK(IsCurveOnSurf(100, 0.3, guide1, surfaces1[i], 0.1));\n\t\t\t\t\tCHECK(IsCurveOnSurf(100, 0.3, guide2, surfaces1[i], 0.1));\n\t\t\t\t\tdouble bsp3s = GetSurfaceProperties(MakeFace(surfaces1[i], 0.0), g, true, true);\n\t\t\t\t\tdouble bsp4s = GetSurfaceProperties(MakeFace(surfaces[i], 0.0), g, true, true);\n\t\t\t\t\tCHECK(bsp3s == Approx(bsp4s).margin(0.02));\n\t\t\t\t}\n\t\t\t}\n\t\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static std::pair<NURBSSweepStatus, std::shared_ptr<Geom3BSplineSurface>> SweepWithCenterAndRadius(const std::shared_ptr<Geom3BSplineCurve>& centerCurve, const LawFunction& radiusLaw, const std::shared_ptr<Geom3BSplineCurve>& spine, double spineLeftBound, double spineRightBound),\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <filesystem>\n#include <fstream>\n#include <random>\n#include <sstream>\n#include <nurbs/NURBSAPIGetGeometry.hpp>\n#include <nurbs/NURBSAPIConicalSweep.hpp>\n#include <boolean/BoolBRepCut.hpp>\n#include <common/CartesianCoordinateSystem.hpp>\n#include <common/IndexMap.hpp>\n#include <common/QuaternionT.hpp>\n#include <geomAlgo/LawBSpline.hpp>\n#include <geomAlgo/LawConstant.hpp>\n#include <nurbs/NURBSAPISmooth.hpp>\n#include <geomAlgo/MakeConic2FromConstraints.hpp>\n#include <geometry/Adaptor3CurveOnSurface.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/AdaptorGeom3Surface.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2Circle.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/Geom2Hyperbola.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3BSplineCurve.hpp>\n#include <geometry/Geom3BSplineSurface.hpp>\n#include <geometry/Geom3Circle.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\n#include <geometry/Geom3Plane.hpp>\n#include <geometry/Geom3SphericalSurface.hpp>\n#include <geometry/Geom3Surface.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include <geometry/Geom3TrimmedSurface.hpp>\n#include <geometry/GeomAPIExtremaCurveCurve3.hpp>\n#include <geometry/GeomAPIProjectPointOnCurve2.hpp>\n#include <geometry/GeomAPIProjectPointOnCurve3.hpp>\n#include <geometry/GeomAPIProjectPointOnSurface.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/GlobalProperty.hpp>\n#include <healing/ShapeFixTool.hpp>\n#include <io/STLTool.hpp>\n#include <math/Sphere.hpp>\n#include <math/TriangularMesh.hpp>\n#include <modeling/CopyShape.hpp>\n#include <modeling/MakeBox.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeFace.hpp>\n#include <modeling/MakePrism.hpp>\n#include <modeling/MakeRevol.hpp>\n#include <modeling/MakeShapeTool.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <modeling/MakeWire.hpp>\n#include <modeling/TransformShape.hpp>\n#include <nurbs/NURBSAPIApprox.hpp>\n#include <nurbs/NURBSAPIBuildCurve.hpp>\n#include <nurbs/NURBSAPICircularSweep.hpp>\n#include <nurbs/NURBSAPIConvert.hpp>\n#include <nurbs/NURBSAPICurveNetworkSurface.hpp>\n#include <nurbs/NURBSAPIExplicitSweep.hpp>\n#include <nurbs/NURBSAPIExplode.hpp>\n#include <nurbs/NURBSAPIExtend.hpp>\n#include <nurbs/NURBSAPIInterpolate.hpp>\n#include <nurbs/NURBSAPIJoin.hpp>\n#include <nurbs/NURBSAPILinearSweep.hpp>\n#include <nurbs/NURBSAPILoft.hpp>\n#include <nurbs/NURBSAPIMakeNURBSFromBoundaries.hpp>\n#include <nurbs/NURBSAPIMatch.hpp>\n#include <nurbs/NURBSAPIModifyEndToPlane.hpp>\n#include <nurbs/NURBSAPIOffsetCurveOnSurface.hpp>\n#include <nurbs/NURBSAPIProject.hpp>\n#include <nurbs/NURBSAPIRebuild.hpp>\n#include <nurbs/NURBSAPIReplaceEdge.hpp>\n#include <nurbs/NURBSAPISweep.hpp>\n#include <nurbs/NURBSAPISweep2.hpp>\n#include <nurbs/NURBSAPISweepRotation.hpp>\n#include <nurbs/NURBSAPITrim.hpp>\n#include <nurbs/NURBSAPIUntrim.hpp>\n#include <nurbs/NURBSLinearSweepWithDraftDirectionLength.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <offset/MakePipe.hpp>\n#include <offset/MakePipeShell.hpp>\n#include <topology/BRepAdaptorCurve2.hpp>\n#include <topology/BRepAdaptorCurve3.hpp>\n#include <topology/BRepAdaptorSurface.hpp>\n#include <topology/BRepGlobalProperty.hpp>\n#include <topology/BRepTool.hpp>\n#include <topology/TopoBuilder.hpp>\n#include <topology/TopoCompound.hpp>\n#include <topology/TopoEdge.hpp>\n#include <topology/TopoExplorer.hpp>\n#include <topology/TopoExplorerTool.hpp>\n#include <topology/TopoFace.hpp>\n#include <topology/TopoShape.hpp>\n#include <topology/TopoShell.hpp>\n#include <topology/TopoTool.hpp>\n#include <topology/TopoVertex.hpp>\n#include <topology/TopoWire.hpp>\n#include <topology/WireExplorer.hpp>\n#include <topomesh/BRepMeshIncrementalMesh.hpp>\n#include <nurbs/NURBSAPIBlend.hpp>\n#include <topology/BRepExtremaDistShapeShape.hpp>\n#include <math/LineT.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/GeomAPIIntSurfaceSurface.hpp>\nusing namespace AMCAX;\nnamespace\n{\n\tstd::shared_ptr<Geom3BSplineCurve> CurveChooser(const int id, const std::shared_ptr<Geom3BSplineCurve>& curve0, const std::shared_ptr<Geom3BSplineCurve>& curve1, const std::shared_ptr<Geom3BSplineCurve>& curve2)\n\t{\n\t\tstd::shared_ptr<Geom3BSplineCurve> result;\n\t\tswitch (id)\n\t\t{\n\t\tcase 0:\n\t\t{\n\t\t\tresult = curve0;\n\t\t\tbreak;\n\t\t}\n\t\tcase 1:\n\t\t{\n\t\t\tresult = curve1;\n\t\t\tbreak;\n\t\t}\n\t\tcase 2:\n\t\t{\n\t\t\tresult = curve2;\n\t\t\tbreak;\n\t\t}\n\t\t}\n\t\treturn result;\n\t}\n} \nTEST_CASE(\"case1:this is a case for CircularSweep\", \"[nurbs][forcase1][Circular]\")\n{\n\tGlobalProperty g;\n\tSECTION(\"TestCircularSweepWithCenterAndRadius()\")\t\n\t{\n\t\tstd::string filedir(INPUT_PATH_PREFIX \"/TestNURBS/TestCircularSweepWithCenterAndRadius/\");\n\t\tauto center = ReadBRepCurve(filedir + \"center.brep\");\n\t\tauto spine = ReadBRepCurve(filedir + \"spine.brep\");\n\t\tCHECK(OCCTIO::OCCTTool::Write(MakeEdge(center), OUTPUT_PATH_PREFIX \"TestCircularSweepWithCenterAndRadius_center.brep\"));\n\t\tCHECK(OCCTIO::OCCTTool::Write(MakeEdge(spine), OUTPUT_PATH_PREFIX \"TestCircularSweepWithCenterAndRadius_spine.brep\"));\n\t\tLawConstant radiusLaw;\n\t\tradiusLaw.Set(2.0, 0.0, 1.0);\n\t\tauto [status, surface] = NURBSAPICircularSweep::SweepWithCenterAndRadius(center, radiusLaw, spine, spine->FirstParameter(), spine->LastParameter());\n\t\tCHECK(status == NURBSSweepStatus::Success);\n\t\tif (status == NURBSSweepStatus::Success && surface)\n\t\t{\n\t\t\tCHECK(OCCTIO::OCCTTool::Write(MakeFace(surface, 0.0), OUTPUT_PATH_PREFIX \"TestCircularSweepWithCenterAndRadius_result.brep\"));\n\t\t\tAMCAX::BRepExtremaDistShapeShape len1(MakeEdge(spine), MakeFace(surface, 0.0));\n\t\t\tCHECK(len1.Value() < 1.);\n\t\t}\n\t\tcenter->IncreaseDegree(11);\n\t\tspine->IncreaseDegree(11);\n\t\tcout << \"center.degree\" << center->Degree() << endl;\n\t\tauto [status1, surface1] = NURBSAPICircularSweep::SweepWithCenterAndRadius(center, radiusLaw, spine, spine->FirstParameter(), spine->LastParameter());\n\t\tCHECK(status1 == NURBSSweepStatus::Success);\n\t\tif (status1 == NURBSSweepStatus::Success && surface1)\n\t\t{\n\t\t\tCHECK(OCCTIO::OCCTTool::Write(MakeFace(surface1, 0.0), OUTPUT_PATH_PREFIX \"TestCircularSweepWithCenterAndRadius_degree11result.brep\"));\n\t\t\tAMCAX::BRepExtremaDistShapeShape len1(MakeEdge(spine), MakeFace(surface1, 0.0));\n\t\t\tCHECK(len1.Value() < 1.);\n\t\t\tdouble bsp3s = GetSurfaceProperties(MakeFace(surface1, 0.0), g, true, true);\n\t\t\tdouble bsp4s = GetSurfaceProperties(MakeFace(surface, 0.0), g, true, true);\n\t\t\tCHECK(bsp3s == Approx(bsp4s).margin(0.02));\n\t\t}\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static std::pair<NURBSSweepStatus, std::shared_ptr<Geom3BSplineSurface>> SweepWithCenterAndTwoAngles(const std::shared_ptr<Geom3BSplineCurve>& centerCurve, const std::shared_ptr<Geom3BSplineCurve>& referenceCurve, const LawFunction& angleLaw1, const LawFunction& angleLaw2, const std::shared_ptr<Geom3BSplineCurve>& spine, double spineLeftBound, double spineRightBound),\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <filesystem>\n#include <fstream>\n#include <random>\n#include <sstream>\n#include <nurbs/NURBSAPIGetGeometry.hpp>\n#include <nurbs/NURBSAPIConicalSweep.hpp>\n#include <boolean/BoolBRepCut.hpp>\n#include <common/CartesianCoordinateSystem.hpp>\n#include <common/IndexMap.hpp>\n#include <common/QuaternionT.hpp>\n#include <geomAlgo/LawBSpline.hpp>\n#include <geomAlgo/LawConstant.hpp>\n#include <nurbs/NURBSAPISmooth.hpp>\n#include <geomAlgo/MakeConic2FromConstraints.hpp>\n#include <geometry/Adaptor3CurveOnSurface.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/AdaptorGeom3Surface.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2Circle.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/Geom2Hyperbola.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3BSplineCurve.hpp>\n#include <geometry/Geom3BSplineSurface.hpp>\n#include <geometry/Geom3Circle.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\n#include <geometry/Geom3Plane.hpp>\n#include <geometry/Geom3SphericalSurface.hpp>\n#include <geometry/Geom3Surface.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include <geometry/Geom3TrimmedSurface.hpp>\n#include <geometry/GeomAPIExtremaCurveCurve3.hpp>\n#include <geometry/GeomAPIProjectPointOnCurve2.hpp>\n#include <geometry/GeomAPIProjectPointOnCurve3.hpp>\n#include <geometry/GeomAPIProjectPointOnSurface.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/GlobalProperty.hpp>\n#include <healing/ShapeFixTool.hpp>\n#include <io/STLTool.hpp>\n#include <math/Sphere.hpp>\n#include <math/TriangularMesh.hpp>\n#include <modeling/CopyShape.hpp>\n#include <modeling/MakeBox.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeFace.hpp>\n#include <modeling/MakePrism.hpp>\n#include <modeling/MakeRevol.hpp>\n#include <modeling/MakeShapeTool.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <modeling/MakeWire.hpp>\n#include <modeling/TransformShape.hpp>\n#include <nurbs/NURBSAPIApprox.hpp>\n#include <nurbs/NURBSAPIBuildCurve.hpp>\n#include <nurbs/NURBSAPICircularSweep.hpp>\n#include <nurbs/NURBSAPIConvert.hpp>\n#include <nurbs/NURBSAPICurveNetworkSurface.hpp>\n#include <nurbs/NURBSAPIExplicitSweep.hpp>\n#include <nurbs/NURBSAPIExplode.hpp>\n#include <nurbs/NURBSAPIExtend.hpp>\n#include <nurbs/NURBSAPIInterpolate.hpp>\n#include <nurbs/NURBSAPIJoin.hpp>\n#include <nurbs/NURBSAPILinearSweep.hpp>\n#include <nurbs/NURBSAPILoft.hpp>\n#include <nurbs/NURBSAPIMakeNURBSFromBoundaries.hpp>\n#include <nurbs/NURBSAPIMatch.hpp>\n#include <nurbs/NURBSAPIModifyEndToPlane.hpp>\n#include <nurbs/NURBSAPIOffsetCurveOnSurface.hpp>\n#include <nurbs/NURBSAPIProject.hpp>\n#include <nurbs/NURBSAPIRebuild.hpp>\n#include <nurbs/NURBSAPIReplaceEdge.hpp>\n#include <nurbs/NURBSAPISweep.hpp>\n#include <nurbs/NURBSAPISweep2.hpp>\n#include <nurbs/NURBSAPISweepRotation.hpp>\n#include <nurbs/NURBSAPITrim.hpp>\n#include <nurbs/NURBSAPIUntrim.hpp>\n#include <nurbs/NURBSLinearSweepWithDraftDirectionLength.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <offset/MakePipe.hpp>\n#include <offset/MakePipeShell.hpp>\n#include <topology/BRepAdaptorCurve2.hpp>\n#include <topology/BRepAdaptorCurve3.hpp>\n#include <topology/BRepAdaptorSurface.hpp>\n#include <topology/BRepGlobalProperty.hpp>\n#include <topology/BRepTool.hpp>\n#include <topology/TopoBuilder.hpp>\n#include <topology/TopoCompound.hpp>\n#include <topology/TopoEdge.hpp>\n#include <topology/TopoExplorer.hpp>\n#include <topology/TopoExplorerTool.hpp>\n#include <topology/TopoFace.hpp>\n#include <topology/TopoShape.hpp>\n#include <topology/TopoShell.hpp>\n#include <topology/TopoTool.hpp>\n#include <topology/TopoVertex.hpp>\n#include <topology/TopoWire.hpp>\n#include <topology/WireExplorer.hpp>\n#include <topomesh/BRepMeshIncrementalMesh.hpp>\n#include <nurbs/NURBSAPIBlend.hpp>\n#include <topology/BRepExtremaDistShapeShape.hpp>\n#include <math/LineT.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/GeomAPIIntSurfaceSurface.hpp>\nusing namespace AMCAX;\nnamespace\n{\n\tstd::shared_ptr<Geom3BSplineCurve> CurveChooser(const int id, const std::shared_ptr<Geom3BSplineCurve>& curve0, const std::shared_ptr<Geom3BSplineCurve>& curve1, const std::shared_ptr<Geom3BSplineCurve>& curve2)\n\t{\n\t\tstd::shared_ptr<Geom3BSplineCurve> result;\n\t\tswitch (id)\n\t\t{\n\t\tcase 0:\n\t\t{\n\t\t\tresult = curve0;\n\t\t\tbreak;\n\t\t}\n\t\tcase 1:\n\t\t{\n\t\t\tresult = curve1;\n\t\t\tbreak;\n\t\t}\n\t\tcase 2:\n\t\t{\n\t\t\tresult = curve2;\n\t\t\tbreak;\n\t\t}\n\t\t}\n\t\treturn result;\n\t}\n} \nTEST_CASE(\"case1:this is a case for CircularSweep\", \"[nurbs][forcase1][Circular]\")\n{\n\tGlobalProperty g;\n\tSECTION(\"TestCircularSweepWithCenterAndTwoAngles2()\")\n\t{\n\t\tstd::string filedir(INPUT_PATH_PREFIX \"/TestNURBS/TestCircularSweepWithCenterAndTwoAngles2/\");\n\t\tauto center = ReadBRepCurve(filedir + \"center.brep\");\n\t\tauto ref = ReadBRepCurve(filedir + \"ref.brep\");\n\t\tauto spine = center;\n\t\tCHECK(OCCTIO::OCCTTool::Write(MakeEdge(center), OUTPUT_PATH_PREFIX \"TestCircularSweepWithCenterAndTwoAngles2_center.brep\"));\n\t\tCHECK(OCCTIO::OCCTTool::Write(MakeEdge(ref), OUTPUT_PATH_PREFIX \"TestCircularSweepWithCenterAndTwoAngles2_ref.brep\"));\n\t\tCHECK(OCCTIO::OCCTTool::Write(MakeEdge(spine), OUTPUT_PATH_PREFIX \"TestCircularSweepWithCenterAndTwoAngles2_spine.brep\"));\n\t\tLawConstant angleLaw1;\n\t\tangleLaw1.Set(-M_PI_4, 0.0, 1.0);\n\t\tLawConstant angleLaw2;\n\t\tangleLaw2.Set(M_PI_4, 0.0, 1.0);\n\t\tauto [status, surface] = NURBSAPICircularSweep::SweepWithCenterAndTwoAngles(center, ref, angleLaw1, angleLaw2, spine, spine->FirstParameter(), spine->LastParameter());\n\t\tCHECK(status == NURBSSweepStatus::Success);\n\t\tif (status == NURBSSweepStatus::Success && surface)\n\t\t{\n\t\t\tCHECK(OCCTIO::OCCTTool::Write(MakeFace(surface, 0.0), OUTPUT_PATH_PREFIX \"TestCircularSweepWithCenterAndTwoAngles2_result.brep\"));\n\t\t\tAMCAX::BRepExtremaDistShapeShape len1(MakeEdge(ref), MakeFace(surface, 0.0));\n\t\t\tCHECK(len1.Value() < 0.1);\n\t\t\tCHECK(IsCurveOnSurf(1000, 0.3, ref, surface, 0.1));\n\t\t}\n\t\tcenter->IncreaseDegree(11);\n\t\tref->IncreaseDegree(11);\n\t\tspine->IncreaseDegree(11);\n\t\tauto [status1, surface1] = NURBSAPICircularSweep::SweepWithCenterAndTwoAngles(center, ref, angleLaw1, angleLaw2, spine, spine->FirstParameter(), spine->LastParameter());\n\t\tCHECK(status1 == NURBSSweepStatus::Success);\n\t\tif (status1 == NURBSSweepStatus::Success && surface)\n\t\t{\n\t\t\tCHECK(OCCTIO::OCCTTool::Write(MakeFace(surface, 0.0), OUTPUT_PATH_PREFIX \"TestCircularSweepWithCenterAndTwoAngles2_degree11result.brep\"));\n\t\t\tAMCAX::BRepExtremaDistShapeShape len1(MakeEdge(ref), MakeFace(surface1, 0.0));\n\t\t\tCHECK(len1.Value() < 0.1);\n\t\t\tCHECK(IsCurveOnSurf(1000, 0.3, ref, surface, 0.1));\n\t\t\tdouble bsp3s = GetSurfaceProperties(MakeFace(surface1, 0.0), g, true, true);\n\t\t\tdouble bsp4s = GetSurfaceProperties(MakeFace(surface, 0.0), g, true, true);\n\t\t\tCHECK(bsp3s == Approx(bsp4s).margin(0.02));\n\t\t}\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static std::pair<NURBSSweepStatus, std::vector<std::shared_ptr<Geom3BSplineSurface>>> SweepWithTwoGuidesAndRadius(const std::shared_ptr<Geom3BSplineCurve>& guide1, const std::shared_ptr<Geom3BSplineCurve>& guide2, const LawFunction& radiusLaw, const std::shared_ptr<Geom3BSplineCurve>& spine, double spineLeftBound, double spineRightBound),\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <filesystem>\n#include <fstream>\n#include <random>\n#include <sstream>\n#include <nurbs/NURBSAPIGetGeometry.hpp>\n#include <nurbs/NURBSAPIConicalSweep.hpp>\n#include <boolean/BoolBRepCut.hpp>\n#include <common/CartesianCoordinateSystem.hpp>\n#include <common/IndexMap.hpp>\n#include <common/QuaternionT.hpp>\n#include <geomAlgo/LawBSpline.hpp>\n#include <geomAlgo/LawConstant.hpp>\n#include <nurbs/NURBSAPISmooth.hpp>\n#include <geomAlgo/MakeConic2FromConstraints.hpp>\n#include <geometry/Adaptor3CurveOnSurface.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/AdaptorGeom3Surface.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2Circle.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/Geom2Hyperbola.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3BSplineCurve.hpp>\n#include <geometry/Geom3BSplineSurface.hpp>\n#include <geometry/Geom3Circle.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\n#include <geometry/Geom3Plane.hpp>\n#include <geometry/Geom3SphericalSurface.hpp>\n#include <geometry/Geom3Surface.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include <geometry/Geom3TrimmedSurface.hpp>\n#include <geometry/GeomAPIExtremaCurveCurve3.hpp>\n#include <geometry/GeomAPIProjectPointOnCurve2.hpp>\n#include <geometry/GeomAPIProjectPointOnCurve3.hpp>\n#include <geometry/GeomAPIProjectPointOnSurface.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/GlobalProperty.hpp>\n#include <healing/ShapeFixTool.hpp>\n#include <io/STLTool.hpp>\n#include <math/Sphere.hpp>\n#include <math/TriangularMesh.hpp>\n#include <modeling/CopyShape.hpp>\n#include <modeling/MakeBox.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeFace.hpp>\n#include <modeling/MakePrism.hpp>\n#include <modeling/MakeRevol.hpp>\n#include <modeling/MakeShapeTool.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <modeling/MakeWire.hpp>\n#include <modeling/TransformShape.hpp>\n#include <nurbs/NURBSAPIApprox.hpp>\n#include <nurbs/NURBSAPIBuildCurve.hpp>\n#include <nurbs/NURBSAPICircularSweep.hpp>\n#include <nurbs/NURBSAPIConvert.hpp>\n#include <nurbs/NURBSAPICurveNetworkSurface.hpp>\n#include <nurbs/NURBSAPIExplicitSweep.hpp>\n#include <nurbs/NURBSAPIExplode.hpp>\n#include <nurbs/NURBSAPIExtend.hpp>\n#include <nurbs/NURBSAPIInterpolate.hpp>\n#include <nurbs/NURBSAPIJoin.hpp>\n#include <nurbs/NURBSAPILinearSweep.hpp>\n#include <nurbs/NURBSAPILoft.hpp>\n#include <nurbs/NURBSAPIMakeNURBSFromBoundaries.hpp>\n#include <nurbs/NURBSAPIMatch.hpp>\n#include <nurbs/NURBSAPIModifyEndToPlane.hpp>\n#include <nurbs/NURBSAPIOffsetCurveOnSurface.hpp>\n#include <nurbs/NURBSAPIProject.hpp>\n#include <nurbs/NURBSAPIRebuild.hpp>\n#include <nurbs/NURBSAPIReplaceEdge.hpp>\n#include <nurbs/NURBSAPISweep.hpp>\n#include <nurbs/NURBSAPISweep2.hpp>\n#include <nurbs/NURBSAPISweepRotation.hpp>\n#include <nurbs/NURBSAPITrim.hpp>\n#include <nurbs/NURBSAPIUntrim.hpp>\n#include <nurbs/NURBSLinearSweepWithDraftDirectionLength.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <offset/MakePipe.hpp>\n#include <offset/MakePipeShell.hpp>\n#include <topology/BRepAdaptorCurve2.hpp>\n#include <topology/BRepAdaptorCurve3.hpp>\n#include <topology/BRepAdaptorSurface.hpp>\n#include <topology/BRepGlobalProperty.hpp>\n#include <topology/BRepTool.hpp>\n#include <topology/TopoBuilder.hpp>\n#include <topology/TopoCompound.hpp>\n#include <topology/TopoEdge.hpp>\n#include <topology/TopoExplorer.hpp>\n#include <topology/TopoExplorerTool.hpp>\n#include <topology/TopoFace.hpp>\n#include <topology/TopoShape.hpp>\n#include <topology/TopoShell.hpp>\n#include <topology/TopoTool.hpp>\n#include <topology/TopoVertex.hpp>\n#include <topology/TopoWire.hpp>\n#include <topology/WireExplorer.hpp>\n#include <topomesh/BRepMeshIncrementalMesh.hpp>\n#include <nurbs/NURBSAPIBlend.hpp>\n#include <topology/BRepExtremaDistShapeShape.hpp>\n#include <math/LineT.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/GeomAPIIntSurfaceSurface.hpp>\nusing namespace AMCAX;\nnamespace\n{\n\tstd::shared_ptr<Geom3BSplineCurve> CurveChooser(const int id, const std::shared_ptr<Geom3BSplineCurve>& curve0, const std::shared_ptr<Geom3BSplineCurve>& curve1, const std::shared_ptr<Geom3BSplineCurve>& curve2)\n\t{\n\t\tstd::shared_ptr<Geom3BSplineCurve> result;\n\t\tswitch (id)\n\t\t{\n\t\tcase 0:\n\t\t{\n\t\t\tresult = curve0;\n\t\t\tbreak;\n\t\t}\n\t\tcase 1:\n\t\t{\n\t\t\tresult = curve1;\n\t\t\tbreak;\n\t\t}\n\t\tcase 2:\n\t\t{\n\t\t\tresult = curve2;\n\t\t\tbreak;\n\t\t}\n\t\t}\n\t\treturn result;\n\t}\n} \nTEST_CASE(\"case1:this is a case for CircularSweep\", \"[nurbs][forcase1][Circular]\")\n{\n\tGlobalProperty g;\n\tSECTION(\"TestCircularSweepWithTwoGuidesAndRadius()\")\n\t{\n\t\tstd::string filedir(INPUT_PATH_PREFIX \"/TestNURBS/TestCircularSweepWithTwoGuidesAndRadius/\");\n\t\tauto guide1 = ReadBRepCurve(filedir + \"guide1.brep\");\n\t\tauto guide2 = ReadBRepCurve(filedir + \"guide2.brep\");\n\t\tauto spine = ReadBRepCurve(filedir + \"spine.brep\");\n\t\tCHECK(OCCTIO::OCCTTool::Write(MakeEdge(guide1), OUTPUT_PATH_PREFIX \"TestCircularSweepWithTwoGuidesAndRadius_guide1.brep\"));\n\t\tCHECK(OCCTIO::OCCTTool::Write(MakeEdge(guide2), OUTPUT_PATH_PREFIX \"TestCircularSweepWithTwoGuidesAndRadius_guide2.brep\"));\n\t\tCHECK(OCCTIO::OCCTTool::Write(MakeEdge(spine), OUTPUT_PATH_PREFIX \"TestCircularSweepWithTwoGuidesAndRadius_spine.brep\"));\n\t\tLawConstant radiusLaw;\n\t\tradiusLaw.Set(10.0, 0.0, 1.0);\n\t\tauto [status, surfaces] = NURBSAPICircularSweep::SweepWithTwoGuidesAndRadius(guide1, guide2, radiusLaw, spine, spine->FirstParameter(), spine->LastParameter());\n\t\tCHECK(status == NURBSSweepStatus::Success);\n\t\tif (status == NURBSSweepStatus::Success && !surfaces.empty())\n\t\t{\n\t\t\tCHECK(OCCTIO::OCCTTool::Write(MakeFace(surfaces.front(), 0.0), OUTPUT_PATH_PREFIX \"TestCircularSweepWithTwoGuidesAndRadius_result.brep\"));\n\t\t\tfor (int i = 0; i < surfaces.size(); i++)\n\t\t\t{\n\t\t\t\tCHECK(OCCTIO::OCCTTool::Write(MakeFace(surfaces[i], 0.0), OUTPUT_PATH_PREFIX \"TestCircularSweepWithTwoGuidesAndRadius_result\" + std::to_string(i) + \".brep\"));\n\t\t\t\tAMCAX::BRepExtremaDistShapeShape len1(MakeEdge(guide1), MakeFace(surfaces[i], 0.0));\n\t\t\t\tAMCAX::BRepExtremaDistShapeShape len2(MakeFace(surfaces[i], 0.0), MakeEdge(guide2));\n\t\t\t\tAMCAX::BRepExtremaDistShapeShape len3(MakeFace(surfaces[i], 0.0), MakeEdge(spine));\n\t\t\t\tCHECK(len1.Value() < 0.1);\n\t\t\t\tCHECK(len2.Value() < 0.1);\n\t\t\t\tCHECK(IsCurveOnSurf(1000, 0.1, guide1, surfaces[i], 0.1));\n\t\t\t\tCHECK(IsCurveOnSurf(1000, 0.1, guide2, surfaces[i], 0.1));\n\t\t\t}\n\t\t}\n\t\tspine->IncreaseDegree(11);\n\t\tguide1->IncreaseDegree(11);\n\t\tguide2->IncreaseDegree(11);\n\t\tauto [status1, surfaces1] = NURBSAPICircularSweep::SweepWithTwoGuidesAndRadius(guide1, guide2, radiusLaw, spine, spine->FirstParameter(), spine->LastParameter());\n\t\tCHECK(status1 == NURBSSweepStatus::Success);\n\t\tfor (int i = 0; i < surfaces.size(); i++)\n\t\t{\n\t\t\tCHECK(OCCTIO::OCCTTool::Write(MakeFace(surfaces[i], 0.0), OUTPUT_PATH_PREFIX \"TestCircularSweepWithTwoGuidesAndRadius_degree11result\" + std::to_string(i) + \".brep\"));\n\t\t\tdouble bsp3s = GetSurfaceProperties(MakeFace(surfaces1[i], 0.0), g, true, true);\n\t\t\tdouble bsp4s = GetSurfaceProperties(MakeFace(surfaces[i], 0.0), g, true, true);\n\t\t\tCHECK(bsp3s == Approx(bsp4s).margin(0.02));\n\t\t}\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static std::pair<NURBSSweepStatus, std::shared_ptr<Geom3BSplineSurface>> SweepWithThreeGuides(const std::shared_ptr<Geom3BSplineCurve>& guide1, const std::shared_ptr<Geom3BSplineCurve>& guide2, const std::shared_ptr<Geom3BSplineCurve>& guide3, const std::shared_ptr<Geom3BSplineCurve>& spine, double spineLeftBound, double spineRightBound),\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <filesystem>\n#include <fstream>\n#include <random>\n#include <sstream>\n#include <nurbs/NURBSAPIGetGeometry.hpp>\n#include <nurbs/NURBSAPIConicalSweep.hpp>\n#include <boolean/BoolBRepCut.hpp>\n#include <common/CartesianCoordinateSystem.hpp>\n#include <common/IndexMap.hpp>\n#include <common/QuaternionT.hpp>\n#include <geomAlgo/LawBSpline.hpp>\n#include <geomAlgo/LawConstant.hpp>\n#include <nurbs/NURBSAPISmooth.hpp>\n#include <geomAlgo/MakeConic2FromConstraints.hpp>\n#include <geometry/Adaptor3CurveOnSurface.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/AdaptorGeom3Surface.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2Circle.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/Geom2Hyperbola.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3BSplineCurve.hpp>\n#include <geometry/Geom3BSplineSurface.hpp>\n#include <geometry/Geom3Circle.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\n#include <geometry/Geom3Plane.hpp>\n#include <geometry/Geom3SphericalSurface.hpp>\n#include <geometry/Geom3Surface.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include <geometry/Geom3TrimmedSurface.hpp>\n#include <geometry/GeomAPIExtremaCurveCurve3.hpp>\n#include <geometry/GeomAPIProjectPointOnCurve2.hpp>\n#include <geometry/GeomAPIProjectPointOnCurve3.hpp>\n#include <geometry/GeomAPIProjectPointOnSurface.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/GlobalProperty.hpp>\n#include <healing/ShapeFixTool.hpp>\n#include <io/STLTool.hpp>\n#include <math/Sphere.hpp>\n#include <math/TriangularMesh.hpp>\n#include <modeling/CopyShape.hpp>\n#include <modeling/MakeBox.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeFace.hpp>\n#include <modeling/MakePrism.hpp>\n#include <modeling/MakeRevol.hpp>\n#include <modeling/MakeShapeTool.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <modeling/MakeWire.hpp>\n#include <modeling/TransformShape.hpp>\n#include <nurbs/NURBSAPIApprox.hpp>\n#include <nurbs/NURBSAPIBuildCurve.hpp>\n#include <nurbs/NURBSAPICircularSweep.hpp>\n#include <nurbs/NURBSAPIConvert.hpp>\n#include <nurbs/NURBSAPICurveNetworkSurface.hpp>\n#include <nurbs/NURBSAPIExplicitSweep.hpp>\n#include <nurbs/NURBSAPIExplode.hpp>\n#include <nurbs/NURBSAPIExtend.hpp>\n#include <nurbs/NURBSAPIInterpolate.hpp>\n#include <nurbs/NURBSAPIJoin.hpp>\n#include <nurbs/NURBSAPILinearSweep.hpp>\n#include <nurbs/NURBSAPILoft.hpp>\n#include <nurbs/NURBSAPIMakeNURBSFromBoundaries.hpp>\n#include <nurbs/NURBSAPIMatch.hpp>\n#include <nurbs/NURBSAPIModifyEndToPlane.hpp>\n#include <nurbs/NURBSAPIOffsetCurveOnSurface.hpp>\n#include <nurbs/NURBSAPIProject.hpp>\n#include <nurbs/NURBSAPIRebuild.hpp>\n#include <nurbs/NURBSAPIReplaceEdge.hpp>\n#include <nurbs/NURBSAPISweep.hpp>\n#include <nurbs/NURBSAPISweep2.hpp>\n#include <nurbs/NURBSAPISweepRotation.hpp>\n#include <nurbs/NURBSAPITrim.hpp>\n#include <nurbs/NURBSAPIUntrim.hpp>\n#include <nurbs/NURBSLinearSweepWithDraftDirectionLength.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <offset/MakePipe.hpp>\n#include <offset/MakePipeShell.hpp>\n#include <topology/BRepAdaptorCurve2.hpp>\n#include <topology/BRepAdaptorCurve3.hpp>\n#include <topology/BRepAdaptorSurface.hpp>\n#include <topology/BRepGlobalProperty.hpp>\n#include <topology/BRepTool.hpp>\n#include <topology/TopoBuilder.hpp>\n#include <topology/TopoCompound.hpp>\n#include <topology/TopoEdge.hpp>\n#include <topology/TopoExplorer.hpp>\n#include <topology/TopoExplorerTool.hpp>\n#include <topology/TopoFace.hpp>\n#include <topology/TopoShape.hpp>\n#include <topology/TopoShell.hpp>\n#include <topology/TopoTool.hpp>\n#include <topology/TopoVertex.hpp>\n#include <topology/TopoWire.hpp>\n#include <topology/WireExplorer.hpp>\n#include <topomesh/BRepMeshIncrementalMesh.hpp>\n#include <nurbs/NURBSAPIBlend.hpp>\n#include <topology/BRepExtremaDistShapeShape.hpp>\n#include <math/LineT.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/GeomAPIIntSurfaceSurface.hpp>\nusing namespace AMCAX;\nnamespace\n{\n\tstd::shared_ptr<Geom3BSplineCurve> CurveChooser(const int id, const std::shared_ptr<Geom3BSplineCurve>& curve0, const std::shared_ptr<Geom3BSplineCurve>& curve1, const std::shared_ptr<Geom3BSplineCurve>& curve2)\n\t{\n\t\tstd::shared_ptr<Geom3BSplineCurve> result;\n\t\tswitch (id)\n\t\t{\n\t\tcase 0:\n\t\t{\n\t\t\tresult = curve0;\n\t\t\tbreak;\n\t\t}\n\t\tcase 1:\n\t\t{\n\t\t\tresult = curve1;\n\t\t\tbreak;\n\t\t}\n\t\tcase 2:\n\t\t{\n\t\t\tresult = curve2;\n\t\t\tbreak;\n\t\t}\n\t\t}\n\t\treturn result;\n\t}\n} \nTEST_CASE(\"case1:this is a case for CircularSweep\", \"[nurbs][forcase1][Circular]\")\n{\n\tGlobalProperty g;\n\tSECTION(\"TestCircularSweepWithThreeGuides2()\")\n\t{\n\t\tstd::string filedir(INPUT_PATH_PREFIX \"/TestNURBS/TestCircularSweepWithThreeGuides2/\");\n\t\tauto guide1 = ReadBRepCurve(filedir + \"guide1.brep\");\n\t\tauto guide2 = ReadBRepCurve(filedir + \"guide2.brep\");\n\t\tauto guide3 = ReadBRepCurve(filedir + \"guide3.brep\");\n\t\tauto spine = guide1;\n\t\tCHECK(OCCTIO::OCCTTool::Write(MakeEdge(guide1), OUTPUT_PATH_PREFIX \"TestCircularSweepWithThreeGuides2_guide1.brep\"));\n\t\tCHECK(OCCTIO::OCCTTool::Write(MakeEdge(guide2), OUTPUT_PATH_PREFIX \"TestCircularSweepWithThreeGuides2_guide2.brep\"));\n\t\tCHECK(OCCTIO::OCCTTool::Write(MakeEdge(guide3), OUTPUT_PATH_PREFIX \"TestCircularSweepWithThreeGuides2_guide3.brep\"));\n\t\tCHECK(OCCTIO::OCCTTool::Write(MakeEdge(spine), OUTPUT_PATH_PREFIX \"TestCircularSweepWithThreeGuides2_spine.brep\"));\n\t\tauto [status, surface] = NURBSAPICircularSweep::SweepWithThreeGuides(guide1, guide2, guide3, spine, spine->FirstParameter(), spine->LastParameter());\n\t\tCHECK(status == NURBSSweepStatus::Success);\n\t\tif (status == NURBSSweepStatus::Success && surface)\n\t\t{\n\t\t\tCHECK(OCCTIO::OCCTTool::Write(MakeFace(surface, 0.0), OUTPUT_PATH_PREFIX \"TestCircularSweepWithThreeGuides2_result.brep\"));\n\t\t\tAMCAX::BRepExtremaDistShapeShape len1(MakeEdge(guide1), MakeFace(surface, 0.0));\n\t\t\tAMCAX::BRepExtremaDistShapeShape len2(MakeFace(surface, 0.0), MakeEdge(guide2));\n\t\t\tAMCAX::BRepExtremaDistShapeShape len3(MakeFace(surface, 0.0), MakeEdge(spine));\n\t\t\tCHECK(len1.Value() < 0.1);\n\t\t\tCHECK(len2.Value() < 0.1);\n\t\t\tCHECK(len3.Value() < 0.1);\n\t\t\tCHECK(IsCurveOnSurf(1000, 0.1, guide1, surface, 0.1));\n\t\t\tCHECK(IsCurveOnSurf(1000, 0.1, guide2, surface, 0.2));\n\t\t\tCHECK(IsCurveOnSurf(1000, 0.1, spine, surface, 0.1));\n\t\t\tIndexSet<TopoShape> newshapeEdge1;\n\t\t\tTopoExplorerTool::MapShapes(MakeFace(surface, 0.0), ShapeType::Edge, newshapeEdge1);\n\t\t\tTopoExplorer ex0(newshapeEdge1[0], ShapeType::Edge);\n\t\t\tTopoExplorer ex1(newshapeEdge1[2], ShapeType::Edge);\n\t\t\tTopoEdge e0 = static_cast<const TopoEdge&>(ex0.Value());\n\t\t\tTopoEdge e1 = static_cast<const TopoEdge&>(ex1.Value());\n\t\t\tauto edge0 = NURBSAPIGetGeometry::GetCurve(e0);\n\t\t\tauto edge1 = NURBSAPIGetGeometry::GetCurve(e1);\n\t\t\tdouble n0 = NurbsSampleCurve(100, 0.1, edge0, spine);\n\t\t\tdouble n1 = NurbsSampleCurve(100, 0.3, edge1, guide3);\n\t\t\tCHECK(n0 < 0.2);\n\t\t\tCHECK(n1 < 0.3);\n\t\t}\n\t\tspine->IncreaseDegree(5);\n\t\tguide1->IncreaseDegree(5);\n\t\tguide2->IncreaseDegree(5);\n\t\tguide3->IncreaseDegree(5);\n\t\tauto [status1, surface1] = NURBSAPICircularSweep::SweepWithThreeGuides(guide1, guide2, guide3, spine, spine->FirstParameter(), spine->LastParameter());\n\t\tCHECK(status1 == NURBSSweepStatus::Success);\n\t\tdouble bsp3s = GetSurfaceProperties(MakeFace(surface1, 0.0), g, true, true);\n\t\tdouble bsp4s = GetSurfaceProperties(MakeFace(surface, 0.0), g, true, true);\n\t\tCHECK(bsp3s == Approx(bsp4s).margin(0.1));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static int ValidMaxDegree(int npoles, bool isPeriodic)\t @return The maximum valid degree\n\t @param isPeriodic Whether the curve is periodic\n\t @param npoles The number of control points\n\t @brief Given the number of the control points, calculate the maximum valide degree of a BSpline curve\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <nurbs/NURBSAPIBuildCurve.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <nurbs/NURBSAPIExtend.hpp>\n#include <geomAlgo/LawConstant.hpp>\n#include <nurbs/NURBSAPILinearSweep.hpp>\n#include <modeling/MakeFace.hpp>\nstd::shared_ptr<AMCAX::Geom3BSplineCurve> BuildBSpCurve(const std::vector<AMCAX::Point3>& poles, int degree, bool isPeriodic)\n{\n\tint npoles = static_cast<int>(poles.size());\n\tif (isPeriodic)\n\t{\n\t\treturn AMCAX::NURBSAPIBuildCurve::BuildCurve(poles, std::min(degree, npoles), true);\n\t}\n\telse\n\t{\n\t\treturn AMCAX::NURBSAPIBuildCurve::BuildCurve(poles, std::min(degree, npoles - 1), false);\n\t}\n}\nTEST_CASE(\"case1: this is a test for testBuildCurve-IncreaseDegree\", \"[nurbs][BuildCurve][P2]\")\n{\n\tint num = 1000;\n\tdouble ratio = 0.1;\n\tdouble refTol = DEFAULT_TOLERANCE;\n\tSECTION(\"TestExtendFourPointsDynamic\")\n\t{\n\t\tOUTPUT_DIRECTORY(nurbs,BuildCurve/ExtendFourPointsDynamic);\n\t\tstd::vector<Point3> poles;\n\t\tPoint3 p1(0.0, 0.0, 0.0);\n\t\tPoint3 p2(0.0, 1.0, 0.0);\n\t\tPoint3 p3(1.0, 1.0, 0.0);\n\t\tPoint3 p4(1.0, 0.0, 0.0);\n\t\tpoles.push_back(p1);\n\t\tpoles.push_back(p2);\n\t\tpoles.push_back(p3);\n\t\tpoles.push_back(p4);\n\t\tstd::vector<double> weights;\n\t\tweights.push_back(1.0);\n\t\tweights.push_back(1.2);\n\t\tweights.push_back(1.1);\n\t\tweights.push_back(1.0);\n\t\tauto oldcurve = NURBSAPIBuildCurve::BuildCurve(poles, weights, 3, false);\n\t\tint maxDeg = NURBSAPIBuildCurve::ValidMaxDegree(static_cast<int>(poles.size()), false);\n\t\tauto curve = NURBSAPIBuildCurve::BuildCurve(poles, weights, maxDeg, false);\n\t\tCHECK(curve->Degree() == maxDeg);\n\t\tdouble res33 = NurbsSampleCurve(num, ratio, oldcurve, curve);\n\t\tCHECK(res33 <= refTol);\n\t\tPoint3 sp1 = curve->StartPoint();\n\t\tPoint3 ep1 = curve->EndPoint();\n\t\tCHECK(sp1.X() == Approx(p1.X()));\n\t\tCHECK(sp1.Y() == Approx(p1.Y()));\n\t\tCHECK(sp1.Z() == Approx(p1.Z()));\n\t\tCHECK(ep1.X() == Approx(p4.X()));\n\t\tCHECK(ep1.Y() == Approx(p4.Y()));\n\t\tCHECK(ep1.Z() == Approx(p4.Z()));\n\t\tCHECK(curve->IsPeriodic() == false);\n\t\tOCCTIO::OCCTTool::Write(MakeVertex(p1), outdir + \"p1.brep\");\n\t\tOCCTIO::OCCTTool::Write(MakeVertex(p2), outdir + \"p2.brep\");\n\t\tOCCTIO::OCCTTool::Write(MakeVertex(p3), outdir + \"p3.brep\");\n\t\tOCCTIO::OCCTTool::Write(MakeVertex(p4), outdir + \"p4.brep\");\n\t\tOCCTIO::OCCTTool::Write(MakeEdge(curve), outdir + \"result.brep\");\n\t\tPoint3 p(-1.0, -1.0, 0.0);\n\t\tauto extendedCurve = NURBSAPIExtend::ExtendCurveToDynamicPoint(curve, false, p);\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static std::shared_ptr<Geom3BSplineCurve> BuildCurve(const std::vector<Point3>& poles, const std::vector<double>& weights, int degree, bool isPeriodic)\t @return The built curve. If building curve is failed, return nullptr\n\t @param isPeriodic Whether the curve is periodic or not\n\t @param degree The curve degree\n\t @param weights Curve weights\n\t @param poles Curve poles. If it is a periodic curve, don't include the point at the end that repeats the first point\n\t @brief Build NURBS curve\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <nurbs/NURBSAPIBuildCurve.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <nurbs/NURBSAPIExtend.hpp>\n#include <geomAlgo/LawConstant.hpp>\n#include <nurbs/NURBSAPILinearSweep.hpp>\n#include <modeling/MakeFace.hpp>\nstd::shared_ptr<AMCAX::Geom3BSplineCurve> BuildBSpCurve(const std::vector<AMCAX::Point3>& poles, int degree, bool isPeriodic)\n{\n\tint npoles = static_cast<int>(poles.size());\n\tif (isPeriodic)\n\t{\n\t\treturn AMCAX::NURBSAPIBuildCurve::BuildCurve(poles, std::min(degree, npoles), true);\n\t}\n\telse\n\t{\n\t\treturn AMCAX::NURBSAPIBuildCurve::BuildCurve(poles, std::min(degree, npoles - 1), false);\n\t}\n}\nTEST_CASE(\"case1: this is a test for testBuildCurve\", \"[nurbs][BuildCurve][P1]\")\n{\n\tSECTION(\"TestBuildCurve()\")\n\t{\n\t\tOUTPUT_DIRECTORY(nurbs, BuildCurve/BuildCurve);\n\t\tstd::vector<Point3> poles;\n\t\tPoint3 p1(0.0, 0.0, 0.0);\n\t\tPoint3 p2(-0.1, 1.0, -0.2);\n\t\tPoint3 p3(0.1, 2.0, -0.1);\n\t\tPoint3 p4(0.2, 3.0, 0.1);\n\t\tPoint3 p5(0.1, 4.0, 0.0);\n\t\tPoint3 p6(0.0, 5.0, -0.1);\n\t\tpoles.push_back(p1);\n\t\tpoles.push_back(p2);\n\t\tpoles.push_back(p3);\n\t\tpoles.push_back(p4);\n\t\tpoles.push_back(p5);\n\t\tpoles.push_back(p6);\n\t\tbool isPeriodic = false;\n\t\tint degree = NURBSAPIBuildCurve::ValidMaxDegree(static_cast<int>(poles.size()), isPeriodic);\n\t\tdegree = std::min(3, degree);\n\t\tauto curve = NURBSAPIBuildCurve::BuildCurve(poles, degree, isPeriodic);\n\t\tPoint3 sp1 = curve->StartPoint();\n\t\tPoint3 ep1 = curve->EndPoint();\n\t\tCHECK(sp1.X() == Approx(p1.X()));\n\t\tCHECK(sp1.Y() == Approx(p1.Y()));\n\t\tCHECK(sp1.Z() == Approx(p1.Z()));\n\t\tCHECK(ep1.X() == Approx(p6.X()).margin(1e-7));\n\t\tCHECK(ep1.Y() == Approx(p6.Y()).margin(1e-7));\n\t\tCHECK(ep1.Z() == Approx(p6.Z()).margin(1e-7));\n\t\tCHECK(curve->Degree() == degree);\n\t\tCHECK(curve->NPoles() == 6);\n\t\tCHECK(curve->IsPeriodic() == false);\n\t\tvector<Point3> vec = curve->Poles();\n\t\tCHECK(vec.size() == 6);\n\t\tCHECK(vec[0].X() == Approx(p1.X()));\n\t\tCHECK(vec[0].Y() == Approx(p1.Y()));\n\t\tCHECK(vec[0].Z() == Approx(p1.Z()));\n\t\tCHECK(vec[1].X() == Approx(p2.X()));\n\t\tCHECK(vec[1].Y() == Approx(p2.Y()));\n\t\tCHECK(vec[1].Z() == Approx(p2.Z()));\n\t\tCHECK(vec[2].X() == Approx(p3.X()));\n\t\tCHECK(vec[2].Y() == Approx(p3.Y()));\n\t\tCHECK(vec[2].Z() == Approx(p3.Z()));\n\t\tCHECK(vec[3].X() == Approx(p4.X()));\n\t\tCHECK(vec[3].Y() == Approx(p4.Y()));\n\t\tCHECK(vec[3].Z() == Approx(p4.Z()));\n\t\tCHECK(vec[4].X() == Approx(p5.X()));\n\t\tCHECK(vec[4].Y() == Approx(p5.Y()));\n\t\tCHECK(vec[4].Z() == Approx(p5.Z()));\n\t\tCHECK(vec[5].X() == Approx(p6.X()));\n\t\tCHECK(vec[5].Y() == Approx(p6.Y()));\n\t\tCHECK(vec[5].Z() == Approx(p6.Z()));\n\t\tOCCTIO::OCCTTool::Write(MakeVertex(p1), outdir + \"p1.brep\");\n\t\tOCCTIO::OCCTTool::Write(MakeVertex(p2), outdir + \"p2.brep\");\n\t\tOCCTIO::OCCTTool::Write(MakeVertex(p3), outdir + \"p3.brep\");\n\t\tOCCTIO::OCCTTool::Write(MakeVertex(p4), outdir + \"p4.brep\");\n\t\tOCCTIO::OCCTTool::Write(MakeVertex(p5), outdir + \"p5.brep\");\n\t\tOCCTIO::OCCTTool::Write(MakeVertex(p6), outdir + \"p6.brep\");\n\t\tOCCTIO::OCCTTool::Write(MakeEdge(curve), outdir + \"result.brep\");\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static std::shared_ptr<Geom3BSplineCurve> BuildCurve(const std::vector<Point3>& poles, int degree, bool isPeriodic)\t @return The built curve. If building curve is failed, return nullptr\n\t @param isPeriodic Whether the curve is periodic or not\n\t @param degree The curve degree\n\t @param poles Curve poles. If it is a periodic curve, don't include the point at the end that repeats the first point\n\t @brief Build BSpline curve\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <nurbs/NURBSAPIBuildCurve.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <nurbs/NURBSAPIExtend.hpp>\n#include <geomAlgo/LawConstant.hpp>\n#include <nurbs/NURBSAPILinearSweep.hpp>\n#include <modeling/MakeFace.hpp>\nstd::shared_ptr<AMCAX::Geom3BSplineCurve> BuildBSpCurve(const std::vector<AMCAX::Point3>& poles, int degree, bool isPeriodic)\n{\n\tint npoles = static_cast<int>(poles.size());\n\tif (isPeriodic)\n\t{\n\t\treturn AMCAX::NURBSAPIBuildCurve::BuildCurve(poles, std::min(degree, npoles), true);\n\t}\n\telse\n\t{\n\t\treturn AMCAX::NURBSAPIBuildCurve::BuildCurve(poles, std::min(degree, npoles - 1), false);\n\t}\n}\nTEST_CASE(\"case1: this is a test for testBuildCurve\", \"[nurbs][BuildCurve][P1]\")\n{\n\tSECTION(\"TestBuildCurve()\")\n\t{\n\t\tOUTPUT_DIRECTORY(nurbs, BuildCurve/BuildCurve);\n\t\tstd::vector<Point3> poles;\n\t\tPoint3 p1(0.0, 0.0, 0.0);\n\t\tPoint3 p2(-0.1, 1.0, -0.2);\n\t\tPoint3 p3(0.1, 2.0, -0.1);\n\t\tPoint3 p4(0.2, 3.0, 0.1);\n\t\tPoint3 p5(0.1, 4.0, 0.0);\n\t\tPoint3 p6(0.0, 5.0, -0.1);\n\t\tpoles.push_back(p1);\n\t\tpoles.push_back(p2);\n\t\tpoles.push_back(p3);\n\t\tpoles.push_back(p4);\n\t\tpoles.push_back(p5);\n\t\tpoles.push_back(p6);\n\t\tbool isPeriodic = false;\n\t\tint degree = NURBSAPIBuildCurve::ValidMaxDegree(static_cast<int>(poles.size()), isPeriodic);\n\t\tdegree = std::min(3, degree);\n\t\tauto curve = NURBSAPIBuildCurve::BuildCurve(poles, degree, isPeriodic);\n\t\tPoint3 sp1 = curve->StartPoint();\n\t\tPoint3 ep1 = curve->EndPoint();\n\t\tCHECK(sp1.X() == Approx(p1.X()));\n\t\tCHECK(sp1.Y() == Approx(p1.Y()));\n\t\tCHECK(sp1.Z() == Approx(p1.Z()));\n\t\tCHECK(ep1.X() == Approx(p6.X()).margin(1e-7));\n\t\tCHECK(ep1.Y() == Approx(p6.Y()).margin(1e-7));\n\t\tCHECK(ep1.Z() == Approx(p6.Z()).margin(1e-7));\n\t\tCHECK(curve->Degree() == degree);\n\t\tCHECK(curve->NPoles() == 6);\n\t\tCHECK(curve->IsPeriodic() == false);\n\t\tvector<Point3> vec = curve->Poles();\n\t\tCHECK(vec.size() == 6);\n\t\tCHECK(vec[0].X() == Approx(p1.X()));\n\t\tCHECK(vec[0].Y() == Approx(p1.Y()));\n\t\tCHECK(vec[0].Z() == Approx(p1.Z()));\n\t\tCHECK(vec[1].X() == Approx(p2.X()));\n\t\tCHECK(vec[1].Y() == Approx(p2.Y()));\n\t\tCHECK(vec[1].Z() == Approx(p2.Z()));\n\t\tCHECK(vec[2].X() == Approx(p3.X()));\n\t\tCHECK(vec[2].Y() == Approx(p3.Y()));\n\t\tCHECK(vec[2].Z() == Approx(p3.Z()));\n\t\tCHECK(vec[3].X() == Approx(p4.X()));\n\t\tCHECK(vec[3].Y() == Approx(p4.Y()));\n\t\tCHECK(vec[3].Z() == Approx(p4.Z()));\n\t\tCHECK(vec[4].X() == Approx(p5.X()));\n\t\tCHECK(vec[4].Y() == Approx(p5.Y()));\n\t\tCHECK(vec[4].Z() == Approx(p5.Z()));\n\t\tCHECK(vec[5].X() == Approx(p6.X()));\n\t\tCHECK(vec[5].Y() == Approx(p6.Y()));\n\t\tCHECK(vec[5].Z() == Approx(p6.Z()));\n\t\tOCCTIO::OCCTTool::Write(MakeVertex(p1), outdir + \"p1.brep\");\n\t\tOCCTIO::OCCTTool::Write(MakeVertex(p2), outdir + \"p2.brep\");\n\t\tOCCTIO::OCCTTool::Write(MakeVertex(p3), outdir + \"p3.brep\");\n\t\tOCCTIO::OCCTTool::Write(MakeVertex(p4), outdir + \"p4.brep\");\n\t\tOCCTIO::OCCTTool::Write(MakeVertex(p5), outdir + \"p5.brep\");\n\t\tOCCTIO::OCCTTool::Write(MakeVertex(p6), outdir + \"p6.brep\");\n\t\tOCCTIO::OCCTTool::Write(MakeEdge(curve), outdir + \"result.brep\");\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static std::shared_ptr<Geom3BSplineSurface> BlendFaces( const TopoFace& face1, const TopoEdge& edge1, ContinuityType cont1, std::vector<double>& parameters1, const TopoFace& face2, const TopoEdge& edge2, ContinuityType cont2, std::vector<double>& parameters2, bool autoReverse, bool isPrecise, const std::vector<double>& tol),\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <nurbs/NURBSAPIBlend.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <topology/BRepExtremaDistShapeShape.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <modeling/MakeFace.hpp>\n#include <topology/BRepAdaptorCurve3.hpp>\n#include <topology/TopoTool.hpp>\n#include <io/ShapeTool.hpp>\n#include <topology/TopoTool.hpp>\n#include <topology/TopoCast.hpp>\n#include <geometry/Geom3Surface.hpp>\n#include <geometry/Geom3BSplineSurface.hpp>\n#include <nurbs/NURBSAPIConvert.hpp>\n#include <nurbs/NURBSAPIGetGeometry.hpp>\n#include <topology/TopoExplorer.hpp>\n#include <topology/TopoExplorerTool.hpp>\n#include <geometry/Geom3CurveLocalProperty.hpp>\n#include <geometry/GeomAPIProjectPointOnCurve3.hpp>\ndouble NURBSSampleEdge1(int num, double tol, const shared_ptr<Geom3Curve>& curve, const TopoEdge& edge)\n{\n\tdouble fpu1 = curve->FirstParameter();\n\tdouble lpu1 = curve->LastParameter();\n\tdouble delta = (lpu1 - fpu1) / num;\n\tPoint3 p;\n\tint n = 0;\n\tfor (int i = 0; i < num; i++) {\n\t\tdouble t = fpu1 + i * delta;\n\t\tcurve->D0(t, p);\n\t\tif (BRepClassificationTools::IsPointInOnEdge(edge, p, tol))\n\t\t{\n\t\t\tn++;\n\t\t}\n\t}\n\tdouble r1 = 1.0 * (num - n) / num;\n\treturn r1;\n}\nTopoEdge ChooseSimilarEdge1(const TopoShape& shape, const TopoEdge& edge)\n{\n\tint nsample = 1000;\n\tPoint3 p1, p2;\n\tBRepAdaptorCurve3 refC(edge);\n\tdouble refFp = refC.FirstParameter();\n\tdouble refLp = refC.LastParameter();\n\tfor (TopoExplorer ex(shape, ShapeType::Edge); ex.More(); ex.Next())\n\t{\n\t\tconst TopoEdge& cre = static_cast<const TopoEdge&>((ex.Current()));\n\t\tBRepAdaptorCurve3 crC(edge);\n\t\tdouble crFp = crC.FirstParameter();\n\t\tdouble crLp = crC.LastParameter();\n\t\tif (std::abs(refFp - crFp) < 0.001 && std::abs(refLp - crLp) < 0.001)\n\t\t{\n\t\t\tbool isOK = true;\n\t\t\tfor (int i = 0; i < nsample; i++)\n\t\t\t{\n\t\t\t\tdouble t1 = refFp + i * (refLp - refFp) / (nsample - 1);\n\t\t\t\tdouble t2 = crFp + i * (crLp - crFp) / (nsample - 1);\n\t\t\t\trefC.D0(t1, p1);\n\t\t\t\tcrC.D0(t2, p2);\n\t\t\t\tif (p1.Distance(p2) > 0.001)\n\t\t\t\t{\n\t\t\t\t\tisOK = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (isOK)\n\t\t\t{\n\t\t\t\treturn cre;\n\t\t\t}\n\t\t}\n\t}\n\tTopoEdge e;\n\treturn e;\n}\nTEST_CASE(\"case1: this is a test for testBlendSurfaces-Extend\", \"[nurbs][Blend][P1]\")\n{\n\tint num = 1000;\n\tdouble ratio = 0.1;\n\tdouble refTol = DEFAULT_TOLERANCE;\n\tbool isAutoReverse = true;\n\tbool isPrecise = true;\n\tstd::vector<double> tol;\n\ttol.push_back(0.001);\n\ttol.push_back(M_PI / 180.0);\n\ttol.push_back(0.0005);\n\tstd::vector<double> params1, params2;\n\tauto surf1 = ReadBRepSurface(INPUT_PATH_PREFIX \"/TestNURBS/TestBridgeSurf/surface1.brep\");\n\tauto surf2 = ReadBRepSurface(INPUT_PATH_PREFIX \"/TestNURBS/TestBridgeSurf/surface2.brep\");\n\tdouble fup1 = surf1->FirstUParameter();\n\tdouble lup1 = surf1->LastUParameter();\n\tdouble fvp1 = surf1->FirstVParameter();\n\tdouble lvp1 = surf1->LastVParameter();\n\tshared_ptr<Geom3Curve> fuc1 = surf1->UIso(fup1);\n\tshared_ptr<Geom3Curve> luc1 = surf1->UIso(lup1);\n\tshared_ptr<Geom3Curve> fvc1 = surf1->VIso(fvp1);\n\tshared_ptr<Geom3Curve> lvc1 = surf1->VIso(lvp1);\n\tdouble uf1 = fuc1->FirstParameter();\n\tdouble ul1 = luc1->FirstParameter();\n\tdouble vf1 = fvc1->FirstParameter();\n\tdouble vl1 = lvc1->FirstParameter();\n\tPoint3 p1, p2 , p3, p4;\n\tVector3 fuv1, luv1, fvv1, lvv1;\n\tfuc1->D1(uf1, p1, fuv1);\n\tluc1->D1(ul1, p2, luv1);\n\tfvc1->D1(vf1, p3, fvv1);\n\tlvc1->D1(vl1, p4, lvv1);\n\tdouble fup2 = surf2->FirstUParameter();\n\tdouble lup2 = surf2->LastUParameter();\n\tdouble fvp2 = surf2->FirstVParameter();\n\tdouble lvp2 = surf2->LastVParameter();\n\tshared_ptr<Geom3Curve> fuc2 = surf2->UIso(fup2);\n\tshared_ptr<Geom3Curve> luc2 = surf2->UIso(lup2);\n\tshared_ptr<Geom3Curve> fvc2 = surf2->VIso(fvp2);\n\tshared_ptr<Geom3Curve> lvc2 = surf2->VIso(lvp2);\n\tdouble uf2 = fuc2->FirstParameter();\n\tdouble ul2 = luc2->FirstParameter();\n\tdouble vf2 = fvc2->FirstParameter();\n\tdouble vl2 = lvc2->FirstParameter();\n\tPoint3 p5, p6, p7, p8;\n\tVector3 fuv2, luv2, fvv2, lvv2;\n\tfuc2->D1(uf2, p5, fuv2);\n\tluc2->D1(ul2, p6, luv2);\n\tfvc2->D1(vf2, p7, fvv2);\n\tlvc2->D1(vl2, p8, lvv2);\n\tSECTION(\"isFront:true+true\")\n\t\t\t{\n\t\t\t\tOUTPUT_DIRECTORY(nurbs, Blend/Extend/BlendSurfaces/G2/tt/tt);\n\t\t\t\tbool isFront1 = true;\n\t\t\t\tbool isFront2 = true;\n\t\t\t\tshared_ptr<Geom3BSplineSurface> bspSurf3 = NURBSAPIBlend::BlendSurfaces(surf1, isU1, isFront1, cont1, params1, surf2, isU2, isFront2, cont2, params2, isAutoReverse, isPrecise, tol);\n\t\t\t\tdouble fpu3 = bspSurf3->FirstUParameter();\n\t\t\t\tdouble lpu3 = bspSurf3->LastUParameter();\n\t\t\t\tshared_ptr<Geom3Curve> fuc3 = bspSurf3->UIso(fpu3);\n\t\t\t\tshared_ptr<Geom3Curve> luc3 = bspSurf3->UIso(lpu3);\n\t\t\t\tdouble res1 = NurbsSampleCurve(num, refTol, fuc3, fuc1);\n\t\t\t\tdouble res2 = NurbsSampleCurve(num, refTol, luc3, fuc2);\n\t\t\t\tCHECK(res1 <= ratio);\n\t\t\t\tCHECK(res2 <= ratio);\n\t\t\t\tpair<double, double> res3 = NurbsContinousSample(num, fuc3, fuc1);\n\t\t\t\tpair<double, double> res4 = NurbsContinousSample(num, luc3, fuc2);\n\t\t\t\tCHECK(res3.first == 0.0);\n\t\t\t\tCHECK(res3.second == 0.0);\n\t\t\t\tCHECK(res4.first == 0.0);\n\t\t\t\tCHECK(res4.second == 0.0);\n\t\t\t\tOCCTIO::OCCTTool::Write(MakeEdge(fuc1), outdir + \"fuc1.brep\");\n\t\t\t\tOCCTIO::OCCTTool::Write(MakeEdge(fvc1), outdir + \"fvc1.brep\");\n\t\t\t\tOCCTIO::OCCTTool::Write(MakeEdge(fuc2), outdir + \"fuc2.brep\");\n\t\t\t\tOCCTIO::OCCTTool::Write(MakeEdge(fvc2), outdir + \"fvc2.brep\");\n\t\t\t\tOCCTIO::OCCTTool::Write(MakeEdge(fuc3), outdir + \"fuc3.brep\");\n\t\t\t\tOCCTIO::OCCTTool::Write(MakeFace(surf1, 0.0), outdir + \"src1.brep\");\n\t\t\t\tOCCTIO::OCCTTool::Write(MakeFace(surf2, 0.0), outdir + \"src2.brep\");\n\t\t\t\tOCCTIO::OCCTTool::Write(MakeFace(bspSurf3, 0.0), outdir + \"result.brep\");\n\t\t\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static std::shared_ptr<Geom3BSplineSurface> BlendSurfaces( const std::shared_ptr<Geom3BSplineSurface>& surf1, bool isUIso1, bool isFront1, ContinuityType cont1, std::vector<double>& parameters1, const std::shared_ptr<Geom3BSplineSurface>& surf2, bool isUIso2, bool isFront2, ContinuityType cont2, std::vector<double>& parameters2, bool autoReverse, bool isPrecise, const std::vector<double>& tol),\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <nurbs/NURBSAPIBlend.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <topology/BRepExtremaDistShapeShape.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <modeling/MakeFace.hpp>\n#include <topology/BRepAdaptorCurve3.hpp>\n#include <topology/TopoTool.hpp>\n#include <io/ShapeTool.hpp>\n#include <topology/TopoTool.hpp>\n#include <topology/TopoCast.hpp>\n#include <geometry/Geom3Surface.hpp>\n#include <geometry/Geom3BSplineSurface.hpp>\n#include <nurbs/NURBSAPIConvert.hpp>\n#include <nurbs/NURBSAPIGetGeometry.hpp>\n#include <topology/TopoExplorer.hpp>\n#include <topology/TopoExplorerTool.hpp>\n#include <geometry/Geom3CurveLocalProperty.hpp>\n#include <geometry/GeomAPIProjectPointOnCurve3.hpp>\ndouble NURBSSampleEdge1(int num, double tol, const shared_ptr<Geom3Curve>& curve, const TopoEdge& edge)\n{\n\tdouble fpu1 = curve->FirstParameter();\n\tdouble lpu1 = curve->LastParameter();\n\tdouble delta = (lpu1 - fpu1) / num;\n\tPoint3 p;\n\tint n = 0;\n\tfor (int i = 0; i < num; i++) {\n\t\tdouble t = fpu1 + i * delta;\n\t\tcurve->D0(t, p);\n\t\tif (BRepClassificationTools::IsPointInOnEdge(edge, p, tol))\n\t\t{\n\t\t\tn++;\n\t\t}\n\t}\n\tdouble r1 = 1.0 * (num - n) / num;\n\treturn r1;\n}\nTopoEdge ChooseSimilarEdge1(const TopoShape& shape, const TopoEdge& edge)\n{\n\tint nsample = 1000;\n\tPoint3 p1, p2;\n\tBRepAdaptorCurve3 refC(edge);\n\tdouble refFp = refC.FirstParameter();\n\tdouble refLp = refC.LastParameter();\n\tfor (TopoExplorer ex(shape, ShapeType::Edge); ex.More(); ex.Next())\n\t{\n\t\tconst TopoEdge& cre = static_cast<const TopoEdge&>((ex.Current()));\n\t\tBRepAdaptorCurve3 crC(edge);\n\t\tdouble crFp = crC.FirstParameter();\n\t\tdouble crLp = crC.LastParameter();\n\t\tif (std::abs(refFp - crFp) < 0.001 && std::abs(refLp - crLp) < 0.001)\n\t\t{\n\t\t\tbool isOK = true;\n\t\t\tfor (int i = 0; i < nsample; i++)\n\t\t\t{\n\t\t\t\tdouble t1 = refFp + i * (refLp - refFp) / (nsample - 1);\n\t\t\t\tdouble t2 = crFp + i * (crLp - crFp) / (nsample - 1);\n\t\t\t\trefC.D0(t1, p1);\n\t\t\t\tcrC.D0(t2, p2);\n\t\t\t\tif (p1.Distance(p2) > 0.001)\n\t\t\t\t{\n\t\t\t\t\tisOK = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (isOK)\n\t\t\t{\n\t\t\t\treturn cre;\n\t\t\t}\n\t\t}\n\t}\n\tTopoEdge e;\n\treturn e;\n}\nTEST_CASE(\"Not Fix bug1: testBlendSurfaces-Extend \", \"[nurbs][Blend][bug]\")\n{\n\tbool isAutoReverse = true;\n\tbool isPrecise = true;\n\tstd::vector<double> tol;\n\ttol.push_back(0.001);\n\ttol.push_back(M_PI / 180.0);\n\ttol.push_back(0.0005);\n\tstd::vector<double> params1, params2;\n\tauto surf1 = ReadBRepSurface(INPUT_PATH_PREFIX \"/TestNURBS/TestBridgeSurf/surface1.brep\");\n\tauto surf2 = ReadBRepSurface(INPUT_PATH_PREFIX \"/TestNURBS/TestBridgeSurf/surface2.brep\");\n\tSECTION(\"ContinuityType::C0\")\n\t{\n\t\tContinuityType cont1 = ContinuityType::C0;\n\t\tContinuityType cont2 = ContinuityType::C0;\n\t\tbool isU1 = false;\n\t\tbool isU2 = false;}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static std::shared_ptr<Geom3BSplineCurve> BlendCurves( const std::shared_ptr<Geom3BSplineCurve>& curve1, bool isFront1, ContinuityType cont1, std::vector<double>& parameters1, const std::shared_ptr<Geom3BSplineCurve>& curve2, bool isFront2, ContinuityType cont2, std::vector<double>& parameters2),\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <nurbs/NURBSAPIBlend.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <topology/BRepExtremaDistShapeShape.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <modeling/MakeFace.hpp>\n#include <topology/BRepAdaptorCurve3.hpp>\n#include <topology/TopoTool.hpp>\n#include <io/ShapeTool.hpp>\n#include <topology/TopoTool.hpp>\n#include <topology/TopoCast.hpp>\n#include <geometry/Geom3Surface.hpp>\n#include <geometry/Geom3BSplineSurface.hpp>\n#include <nurbs/NURBSAPIConvert.hpp>\n#include <nurbs/NURBSAPIGetGeometry.hpp>\n#include <topology/TopoExplorer.hpp>\n#include <topology/TopoExplorerTool.hpp>\n#include <geometry/Geom3CurveLocalProperty.hpp>\nTEST_CASE(\"Not Fix bug1: testBlendCurves2-Extend \", \"[nurbs][Blend][bug]\")\n{\n\tstd::shared_ptr<Geom3BSplineCurve> bsp1, bsp2;\n\t{\n\t\tstd::vector<Point3> poles;\n\t\tpoles.push_back(Point3(0., -1., 0.));\n\t\tpoles.push_back(Point3(.7, -.7, 0.));\n\t\tpoles.push_back(Point3(1., -.3, 0.));\n\t\tpoles.push_back(Point3(1.2, 0., 0.));\n\t\tpoles.push_back(Point3(2., .3, 0.));\n\t\tpoles.push_back(Point3(.7, 1.7, 0.));\n\t\tpoles.push_back(Point3(0., 1., 0.));\n\t\tstd::vector<double> weights;\n\t\tweights.push_back(1.0);\n\t\tweights.push_back(1.3);\n\t\tweights.push_back(1.2);\n\t\tweights.push_back(0.7);\n\t\tweights.push_back(1.3);\n\t\tweights.push_back(1.0);\n\t\tweights.push_back(1.2);\n\t\tstd::vector<double> knots;\n\t\tknots.push_back(0.);\n\t\tknots.push_back(.25);\n\t\tknots.push_back(.5);\n\t\tknots.push_back(.75);\n\t\tknots.push_back(1.);\n\t\tstd::vector<int> mults(5, 1);\n\t\tmults.front() = 4;\n\t\tmults.back() = 4;\n\t\tbsp1 = std::make_shared<Geom3BSplineCurve>(poles, weights, knots, mults, 3);\n\t}\n\t{\n\t\tstd::vector<Point3> spinePoles;\n\t\tstd::vector<double> spineKnots(4);\n\t\tstd::vector<int> spineMults(4, 1);\n\t\tspinePoles.push_back(Point3(0.0, 0.0, 0.0));\n\t\tspinePoles.push_back(Point3(-0.1, 1.0, -0.2));\n\t\tspinePoles.push_back(Point3(0.1, 2.0, -0.1));\n\t\tspinePoles.push_back(Point3(0.2, 3.0, 0.1));\n\t\tspinePoles.push_back(Point3(0.1, 4.0, 0.0));\n\t\tspinePoles.push_back(Point3(0.0, 5.0, -0.1));\n\t\tstd::vector<double> weights;\n\t\tweights.push_back(1.0);\n\t\tweights.push_back(1.3);\n\t\tweights.push_back(1.2);\n\t\tweights.push_back(0.7);\n\t\tweights.push_back(1.3);\n\t\tweights.push_back(1.0);\n\t\tspineKnots[0] = 0;\n\t\tspineKnots[1] = 1.0 / 3.0;\n\t\tspineKnots[2] = 2.0 / 3.0;\n\t\tspineKnots[3] = 1;\n\t\tspineMults.front() = 4;\n\t\tspineMults.back() = 4;\n\t\tbsp2 = std::make_shared<Geom3BSplineCurve>(spinePoles, weights, spineKnots, spineMults, 3);\n\t}\n\tdouble lp1 = bsp1->LastParameter();\n\tPoint3 p1, pp1, p2, pp2;\n\tVector3 ev1;\n\tbsp1->D1(lp1, pp1, ev1);\n\tstd::vector<double> params1, params2;\n\tauto cont1 = ContinuityType::G2;\n\tauto cont2 = ContinuityType::G2;\n\tSECTION(\"false+true\")\n\t{\n\t\tOUTPUT_DIRECTORY(nurbs, Blend/Extend/bug792);\n\t\tbool isFront1 = false;\n\t\tbool isFront2 = true;\n\t\tauto bsp3 = NURBSAPIBlend::BlendCurves(bsp1, isFront1, cont1, params1, bsp2, isFront2, cont2, params2);\n\t\tdouble fp3 = bsp3->FirstParameter();\n\t\tPoint3 p3;\n\t\tVector3 sv3;\n\t\tbsp3->D1(fp3, p3, sv3);\n\t\tbool res1 = Direction3(sv3).IsParallel(Direction3(ev1), Precision::Angular());\n\t\tCHECK(res1 == true);\n\t\tOCCTIO::OCCTTool::Write(MakeVertex(p3), outdir + \"p3.brep\");\n\t\tOCCTIO::OCCTTool::Write(MakeVertex(pp1), outdir + \"pp1.brep\");\n\t\tOCCTIO::OCCTTool::Write(MakeEdge(bsp1), outdir + \"src1.brep\");\n\t\tOCCTIO::OCCTTool::Write(MakeEdge(bsp2), outdir + \"src2.brep\");\n\t\tOCCTIO::OCCTTool::Write(MakeEdge(bsp3), outdir + \"result.brep\");\n\t}\n}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static std::shared_ptr<Geom3BSplineCurve> BlendCurves( const std::shared_ptr<Geom3BSplineCurve>& curve1, bool isFront1, ContinuityType cont1, const std::shared_ptr<Geom3BSplineCurve>& curve2, bool isFront2, ContinuityType cont2),\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <nurbs/NURBSAPIBlend.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <topology/BRepExtremaDistShapeShape.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <modeling/MakeFace.hpp>\n#include <topology/BRepAdaptorCurve3.hpp>\n#include <topology/TopoTool.hpp>\n#include <io/ShapeTool.hpp>\n#include <topology/TopoTool.hpp>\n#include <topology/TopoCast.hpp>\n#include <geometry/Geom3Surface.hpp>\n#include <geometry/Geom3BSplineSurface.hpp>\n#include <nurbs/NURBSAPIConvert.hpp>\n#include <nurbs/NURBSAPIGetGeometry.hpp>\n#include <topology/TopoExplorer.hpp>\n#include <topology/TopoExplorerTool.hpp>\n#include <geometry/Geom3CurveLocalProperty.hpp>\nTEST_CASE(\"Not Fix bug1: testBlendCurves2-Extend \", \"[nurbs][Blend][bug]\")\n{\n\tstd::shared_ptr<Geom3BSplineCurve> bsp1, bsp2;\n\t{\n\t\tstd::vector<Point3> poles;\n\t\tpoles.push_back(Point3(0., -1., 0.));\n\t\tpoles.push_back(Point3(.7, -.7, 0.));\n\t\tpoles.push_back(Point3(1., -.3, 0.));\n\t\tpoles.push_back(Point3(1.2, 0., 0.));\n\t\tpoles.push_back(Point3(2., .3, 0.));\n\t\tpoles.push_back(Point3(.7, 1.7, 0.));\n\t\tpoles.push_back(Point3(0., 1., 0.));\n\t\tstd::vector<double> weights;\n\t\tweights.push_back(1.0);\n\t\tweights.push_back(1.3);\n\t\tweights.push_back(1.2);\n\t\tweights.push_back(0.7);\n\t\tweights.push_back(1.3);\n\t\tweights.push_back(1.0);\n\t\tweights.push_back(1.2);\n\t\tstd::vector<double> knots;\n\t\tknots.push_back(0.);\n\t\tknots.push_back(.25);\n\t\tknots.push_back(.5);\n\t\tknots.push_back(.75);\n\t\tknots.push_back(1.);\n\t\tstd::vector<int> mults(5, 1);\n\t\tmults.front() = 4;\n\t\tmults.back() = 4;\n\t\tbsp1 = std::make_shared<Geom3BSplineCurve>(poles, weights, knots, mults, 3);\n\t}\n\t{\n\t\tstd::vector<Point3> spinePoles;\n\t\tstd::vector<double> spineKnots(4);\n\t\tstd::vector<int> spineMults(4, 1);\n\t\tspinePoles.push_back(Point3(0.0, 0.0, 0.0));\n\t\tspinePoles.push_back(Point3(-0.1, 1.0, -0.2));\n\t\tspinePoles.push_back(Point3(0.1, 2.0, -0.1));\n\t\tspinePoles.push_back(Point3(0.2, 3.0, 0.1));\n\t\tspinePoles.push_back(Point3(0.1, 4.0, 0.0));\n\t\tspinePoles.push_back(Point3(0.0, 5.0, -0.1));\n\t\tstd::vector<double> weights;\n\t\tweights.push_back(1.0);\n\t\tweights.push_back(1.3);\n\t\tweights.push_back(1.2);\n\t\tweights.push_back(0.7);\n\t\tweights.push_back(1.3);\n\t\tweights.push_back(1.0);\n\t\tspineKnots[0] = 0;\n\t\tspineKnots[1] = 1.0 / 3.0;\n\t\tspineKnots[2] = 2.0 / 3.0;\n\t\tspineKnots[3] = 1;\n\t\tspineMults.front() = 4;\n\t\tspineMults.back() = 4;\n\t\tbsp2 = std::make_shared<Geom3BSplineCurve>(spinePoles, weights, spineKnots, spineMults, 3);\n\t}\n\tdouble lp1 = bsp1->LastParameter();\n\tPoint3 p1, pp1, p2, pp2;\n\tVector3 ev1;\n\tbsp1->D1(lp1, pp1, ev1);\n\tstd::vector<double> params1, params2;\n\tauto cont1 = ContinuityType::G2;\n\tauto cont2 = ContinuityType::G2;\n\tSECTION(\"false+true\")\n\t{\n\t\tOUTPUT_DIRECTORY(nurbs, Blend/Extend/bug792);\n\t\tbool isFront1 = false;\n\t\tbool isFront2 = true;\n\t\tauto bsp3 = NURBSAPIBlend::BlendCurves(bsp1, isFront1, cont1, params1, bsp2, isFront2, cont2, params2);\n\t\tdouble fp3 = bsp3->FirstParameter();\n\t\tPoint3 p3;\n\t\tVector3 sv3;\n\t\tbsp3->D1(fp3, p3, sv3);\n\t\tbool res1 = Direction3(sv3).IsParallel(Direction3(ev1), Precision::Angular());\n\t\tCHECK(res1 == true);\n\t\tOCCTIO::OCCTTool::Write(MakeVertex(p3), outdir + \"p3.brep\");\n\t\tOCCTIO::OCCTTool::Write(MakeVertex(pp1), outdir + \"pp1.brep\");\n\t\tOCCTIO::OCCTTool::Write(MakeEdge(bsp1), outdir + \"src1.brep\");\n\t\tOCCTIO::OCCTTool::Write(MakeEdge(bsp2), outdir + \"src2.brep\");\n\t\tOCCTIO::OCCTTool::Write(MakeEdge(bsp3), outdir + \"result.brep\");\n\t}\n}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static std::shared_ptr<Geom3BSplineSurface> BlendFaces( const TopoFace& face1, const TopoEdge& edge1, ContinuityType cont1, std::vector<double>& parameters1, const TopoFace& face2, const TopoEdge& edge2, ContinuityType cont2, std::vector<double>& parameters2, bool autoReverse, bool isPrecise, const std::vector<double>& tol),\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <nurbs/NURBSAPIBlend.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <topology/BRepExtremaDistShapeShape.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <modeling/MakeFace.hpp>\n#include <topology/BRepAdaptorCurve3.hpp>\n#include <topology/TopoTool.hpp>\n#include <io/ShapeTool.hpp>\n#include <topology/TopoTool.hpp>\n#include <topology/TopoCast.hpp>\n#include <geometry/Geom3Surface.hpp>\n#include <geometry/Geom3BSplineSurface.hpp>\n#include <nurbs/NURBSAPIConvert.hpp>\n#include <nurbs/NURBSAPIGetGeometry.hpp>\n#include <topology/TopoExplorer.hpp>\n#include <topology/TopoExplorerTool.hpp>\ndouble NURBSSampleEdge(int num, double tol, const shared_ptr<Geom3Curve>& curve, const TopoEdge& edge)\n{\n\tdouble fpu1 = curve->FirstParameter();\n\tdouble lpu1 = curve->LastParameter();\n\tdouble delta = (lpu1 - fpu1) / num;\n\tPoint3 p;\n\tint n = 0;\n\tfor (int i = 0; i < num; i++) {\n\t\tdouble t = fpu1 + i * delta;\n\t\tcurve->D0(t, p);\n\t\tif (BRepClassificationTools::IsPointInOnEdge(edge, p, tol))\n\t\t{\n\t\t\tn++;\n\t\t}\n\t}\n\tdouble r1 = 1.0 * (num - n) / num;\n\treturn r1;\n}\nTopoEdge ChooseSimilarEdge(const TopoShape& shape, const TopoEdge& edge)\n{\n\tint nsample = 1000;\n\tPoint3 p1, p2;\n\tBRepAdaptorCurve3 refC(edge);\n\tdouble refFp = refC.FirstParameter();\n\tdouble refLp = refC.LastParameter();\n\tfor (TopoExplorer ex(shape, ShapeType::Edge); ex.More(); ex.Next())\n\t{\n\t\tconst TopoEdge& cre = static_cast<const TopoEdge&>((ex.Current()));\n\t\tBRepAdaptorCurve3 crC(edge);\n\t\tdouble crFp = crC.FirstParameter();\n\t\tdouble crLp = crC.LastParameter();\n\t\tif (std::abs(refFp - crFp) < 0.001 && std::abs(refLp - crLp) < 0.001)\n\t\t{\n\t\t\tbool isOK = true;\n\t\t\tfor (int i = 0; i < nsample; i++)\n\t\t\t{\n\t\t\t\tdouble t1 = refFp + i * (refLp - refFp) / (nsample - 1);\n\t\t\t\tdouble t2 = crFp + i * (crLp - crFp) / (nsample - 1);\n\t\t\t\trefC.D0(t1, p1);\n\t\t\t\tcrC.D0(t2, p2);\n\t\t\t\tif (p1.Distance(p2) > 0.001)\n\t\t\t\t{\n\t\t\t\t\tisOK = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (isOK)\n\t\t\t{\n\t\t\t\treturn cre;\n\t\t\t}\n\t\t}\n\t}\n\tTopoEdge e;\n\treturn e;\n}\nTEST_CASE(\"bug3: TestBridgeTrimmedPeriodicFace \", \"[nurbs][Blend][fixbug]\")\n{\n\tOUTPUT_DIRECTORY(nurbs, Blend/bug684/testBlendFaces);\n\tstd::string filedir = INPUT_PATH_PREFIX \"/TestNURBS/TestBlendFaces/\";\n\tTopoFace f1 = ReadBRepFace(filedir + \"surfaceShapeFrom1.brep\");\n\tTopoFace f2 = ReadBRepFace(filedir + \"surfaceShapeFrom2.brep\");\n\tvector<TopoEdge>vec1;\n\tvector<TopoEdge>vec2;\n\tfor (TopoExplorer exp(f1, ShapeType::Edge); exp.More(); exp.Next())\n\t{\n\t\tTopoEdge c1 = static_cast<const TopoEdge&>(exp.Current());\n\t\tvec1.push_back(c1);\n\t}\n\tfor (TopoExplorer expE(f2, ShapeType::Edge); expE.More(); expE.Next())\n\t{\n\t\tTopoEdge c2 = static_cast<const TopoEdge&>(expE.Current());\n\t\tvec2.push_back(c2);\n\t}\n\tvector<double>parameters1 = { 1.0, 1.0 };\n\tvector<double>parameters2 = { 1.0, 1.0 };\n\tvector<double>tol = { 0.001, 0.1 * M_PI / 180.0, 0.05 };\n\tfor (int i = 0; i < vec1.size(); i++)\n\t{\n\t\tfor (int j = 0; j < vec2.size(); j++)\n\t\t{\n\t\t\tshared_ptr<Geom3BSplineSurface> blendSurface = NURBSAPIBlend::BlendFaces(f1, vec1[i], ContinuityType::G2, parameters1, f2, vec2[j], ContinuityType::G2, parameters2, true, true, tol);\n\t\t\tOCCTIO::OCCTTool::Write(MakeFace(blendSurface, 0.0), outdir + \"G2-result\" + to_string(i + 1) + to_string(j + 1) + \".brep\");\n\t\t}\n\t}\n\tOCCTIO::OCCTTool::Write(f1, outdir + \"f1.brep\");\n\tOCCTIO::OCCTTool::Write(f2, outdir + \"f2.brep\");\n\tOCCTIO::OCCTTool::Write(vec1[0], outdir + \"e1.brep\");\n\tOCCTIO::OCCTTool::Write(vec1[1], outdir + \"e2.brep\");\n\tOCCTIO::OCCTTool::Write(vec1[2], outdir + \"e3.brep\");\n\tOCCTIO::OCCTTool::Write(vec1[3], outdir + \"e4.brep\");\n\tOCCTIO::OCCTTool::Write(vec2[0], outdir + \"e11.brep\");\n\tOCCTIO::OCCTTool::Write(vec2[1], outdir + \"e22.brep\");\n\tOCCTIO::OCCTTool::Write(vec2[2], outdir + \"e33.brep\");\n\tOCCTIO::OCCTTool::Write(vec2[3], outdir + \"e44.brep\");\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static std::shared_ptr<Geom3BSplineSurface> BlendSurfaces( const std::shared_ptr<Geom3BSplineSurface>& surf1, bool isUIso1, bool isFront1, ContinuityType cont1, std::vector<double>& parameters1, const std::shared_ptr<Geom3BSplineSurface>& surf2, bool isUIso2, bool isFront2, ContinuityType cont2, std::vector<double>& parameters2, bool autoReverse, bool isPrecise, const std::vector<double>& tol),\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <nurbs/NURBSAPIBlend.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <topology/BRepExtremaDistShapeShape.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <modeling/MakeFace.hpp>\n#include <topology/BRepAdaptorCurve3.hpp>\n#include <topology/TopoTool.hpp>\n#include <io/ShapeTool.hpp>\n#include <topology/TopoTool.hpp>\n#include <topology/TopoCast.hpp>\n#include <geometry/Geom3Surface.hpp>\n#include <geometry/Geom3BSplineSurface.hpp>\n#include <nurbs/NURBSAPIConvert.hpp>\n#include <nurbs/NURBSAPIGetGeometry.hpp>\n#include <topology/TopoExplorer.hpp>\n#include <topology/TopoExplorerTool.hpp>\ndouble NURBSSampleEdge(int num, double tol, const shared_ptr<Geom3Curve>& curve, const TopoEdge& edge)\n{\n\tdouble fpu1 = curve->FirstParameter();\n\tdouble lpu1 = curve->LastParameter();\n\tdouble delta = (lpu1 - fpu1) / num;\n\tPoint3 p;\n\tint n = 0;\n\tfor (int i = 0; i < num; i++) {\n\t\tdouble t = fpu1 + i * delta;\n\t\tcurve->D0(t, p);\n\t\tif (BRepClassificationTools::IsPointInOnEdge(edge, p, tol))\n\t\t{\n\t\t\tn++;\n\t\t}\n\t}\n\tdouble r1 = 1.0 * (num - n) / num;\n\treturn r1;\n}\nTopoEdge ChooseSimilarEdge(const TopoShape& shape, const TopoEdge& edge)\n{\n\tint nsample = 1000;\n\tPoint3 p1, p2;\n\tBRepAdaptorCurve3 refC(edge);\n\tdouble refFp = refC.FirstParameter();\n\tdouble refLp = refC.LastParameter();\n\tfor (TopoExplorer ex(shape, ShapeType::Edge); ex.More(); ex.Next())\n\t{\n\t\tconst TopoEdge& cre = static_cast<const TopoEdge&>((ex.Current()));\n\t\tBRepAdaptorCurve3 crC(edge);\n\t\tdouble crFp = crC.FirstParameter();\n\t\tdouble crLp = crC.LastParameter();\n\t\tif (std::abs(refFp - crFp) < 0.001 && std::abs(refLp - crLp) < 0.001)\n\t\t{\n\t\t\tbool isOK = true;\n\t\t\tfor (int i = 0; i < nsample; i++)\n\t\t\t{\n\t\t\t\tdouble t1 = refFp + i * (refLp - refFp) / (nsample - 1);\n\t\t\t\tdouble t2 = crFp + i * (crLp - crFp) / (nsample - 1);\n\t\t\t\trefC.D0(t1, p1);\n\t\t\t\tcrC.D0(t2, p2);\n\t\t\t\tif (p1.Distance(p2) > 0.001)\n\t\t\t\t{\n\t\t\t\t\tisOK = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (isOK)\n\t\t\t{\n\t\t\t\treturn cre;\n\t\t\t}\n\t\t}\n\t}\n\tTopoEdge e;\n\treturn e;\n}\nTEST_CASE(\"case1: this is a test for testBlendSurf\", \"[nurbs][Blend][P1]\")\n{\n\tint num = 1000;\n\tdouble ratio = 0.1;\n\tdouble refTol = DEFAULT_TOLERANCE;\n\tSECTION(\"testBridgeSurf\")\n\t{\n\t\tOUTPUT_DIRECTORY(nurbs, Blend/BridgeSurf);\n\t\tauto surf1 = ReadBRepSurface(INPUT_PATH_PREFIX \"/TestNURBS/TestBridgeSurf/surface1.brep\");\n\t\tauto surf2 = ReadBRepSurface(INPUT_PATH_PREFIX \"/TestNURBS/TestBridgeSurf/surface2.brep\");\n\t\tbool isU1 = true, isFront1 = true, isU2 = true, isFront2 = true;\n\t\tContinuityType cont1 = ContinuityType::G2;\n\t\tContinuityType cont2 = ContinuityType::G2;\n\t\tbool isAutoReverse = true;\n\t\tbool isPrecise = true;\n\t\tstd::vector<double> tol;\n\t\ttol.push_back(0.001);\n\t\ttol.push_back(M_PI / 180.0);\n\t\ttol.push_back(0.0005);\n\t\tstd::vector<double> params1, params2;\n\t\tshared_ptr<Geom3BSplineSurface> bspSurf3 = NURBSAPIBlend::BlendSurfaces(surf1, isU2, isFront2, cont1, params1, surf2, isU1, isFront1, cont2, params2, isAutoReverse, isPrecise, tol);\n\t\tBRepExtremaDistShapeShape dist1(MakeFace(surf1, 0.0), MakeFace(bspSurf3, 0.0));\n\t\tBRepExtremaDistShapeShape dist2(MakeFace(surf2, 0.0), MakeFace(bspSurf3, 0.0));\n\t\tCHECK(dist1.Value() == Approx(0.0).margin(0.1));\n\t\tCHECK(dist2.Value() == Approx(0.0).margin(0.1));\n\t\tdouble fpu1 = bspSurf3->FirstUParameter();\n\t\tdouble lpu1 = bspSurf3->LastUParameter();\n\t\tshared_ptr<Geom3Curve> u1 = bspSurf3->UIso(fpu1);\n\t\tshared_ptr<Geom3Curve> u2 = bspSurf3->UIso(lpu1);\n\t\tdouble f1 = surf1->FirstUParameter();\n\t\tdouble f2 = surf2->FirstUParameter();\n\t\tshared_ptr<Geom3Curve> c1 = surf1->UIso(f1);\n\t\tshared_ptr<Geom3Curve> c2 = surf2->UIso(f2);\n\t\tbool res1 = IsCurveOnSurf(num, ratio, u1, surf1);\n\t\tbool res2 = IsCurveOnSurf(num, ratio, u2, surf2);\n\t\tCHECK(res1 == true);\n\t\tCHECK(res2 == true);\n\t\tdouble res3 = NurbsSampleCurve(num, refTol, c1, u1);\n\t\tdouble res4 = NurbsSampleCurve(num, refTol, c2, u2);\n\t\tCHECK(res3 <= ratio);\n\t\tCHECK(res4 <= ratio);\n\t\tOCCTIO::OCCTTool::Write(MakeEdge(u1), outdir + \"u1.brep\");\n\t\tOCCTIO::OCCTTool::Write(MakeEdge(u2), outdir + \"u2.brep\");\n\t\tOCCTIO::OCCTTool::Write(MakeEdge(c1), outdir + \"c1.brep\");\n\t\tOCCTIO::OCCTTool::Write(MakeEdge(c2), outdir + \"c2.brep\");\n\t\tOCCTIO::OCCTTool::Write(MakeFace(surf1, 0.0), outdir + \"src1.brep\");\n\t\tOCCTIO::OCCTTool::Write(MakeFace(surf2, 0.0), outdir + \"src2.brep\");\n\t\tOCCTIO::OCCTTool::Write(MakeFace(bspSurf3, 0.0), outdir + \"result.brep\");\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static std::shared_ptr<Geom3BSplineCurve> BlendCurves( const std::shared_ptr<Geom3BSplineCurve>& curve1, bool isFront1, ContinuityType cont1, std::vector<double>& parameters1, const std::shared_ptr<Geom3BSplineCurve>& curve2, bool isFront2, ContinuityType cont2, std::vector<double>& parameters2),\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <nurbs/NURBSAPIBlend.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <topology/BRepExtremaDistShapeShape.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <modeling/MakeFace.hpp>\n#include <topology/BRepAdaptorCurve3.hpp>\n#include <topology/TopoTool.hpp>\n#include <io/ShapeTool.hpp>\n#include <topology/TopoTool.hpp>\n#include <topology/TopoCast.hpp>\n#include <geometry/Geom3Surface.hpp>\n#include <geometry/Geom3BSplineSurface.hpp>\n#include <nurbs/NURBSAPIConvert.hpp>\n#include <nurbs/NURBSAPIGetGeometry.hpp>\n#include <topology/TopoExplorer.hpp>\n#include <topology/TopoExplorerTool.hpp>\ndouble NURBSSampleEdge(int num, double tol, const shared_ptr<Geom3Curve>& curve, const TopoEdge& edge)\n{\n\tdouble fpu1 = curve->FirstParameter();\n\tdouble lpu1 = curve->LastParameter();\n\tdouble delta = (lpu1 - fpu1) / num;\n\tPoint3 p;\n\tint n = 0;\n\tfor (int i = 0; i < num; i++) {\n\t\tdouble t = fpu1 + i * delta;\n\t\tcurve->D0(t, p);\n\t\tif (BRepClassificationTools::IsPointInOnEdge(edge, p, tol))\n\t\t{\n\t\t\tn++;\n\t\t}\n\t}\n\tdouble r1 = 1.0 * (num - n) / num;\n\treturn r1;\n}\nTopoEdge ChooseSimilarEdge(const TopoShape& shape, const TopoEdge& edge)\n{\n\tint nsample = 1000;\n\tPoint3 p1, p2;\n\tBRepAdaptorCurve3 refC(edge);\n\tdouble refFp = refC.FirstParameter();\n\tdouble refLp = refC.LastParameter();\n\tfor (TopoExplorer ex(shape, ShapeType::Edge); ex.More(); ex.Next())\n\t{\n\t\tconst TopoEdge& cre = static_cast<const TopoEdge&>((ex.Current()));\n\t\tBRepAdaptorCurve3 crC(edge);\n\t\tdouble crFp = crC.FirstParameter();\n\t\tdouble crLp = crC.LastParameter();\n\t\tif (std::abs(refFp - crFp) < 0.001 && std::abs(refLp - crLp) < 0.001)\n\t\t{\n\t\t\tbool isOK = true;\n\t\t\tfor (int i = 0; i < nsample; i++)\n\t\t\t{\n\t\t\t\tdouble t1 = refFp + i * (refLp - refFp) / (nsample - 1);\n\t\t\t\tdouble t2 = crFp + i * (crLp - crFp) / (nsample - 1);\n\t\t\t\trefC.D0(t1, p1);\n\t\t\t\tcrC.D0(t2, p2);\n\t\t\t\tif (p1.Distance(p2) > 0.001)\n\t\t\t\t{\n\t\t\t\t\tisOK = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (isOK)\n\t\t\t{\n\t\t\t\treturn cre;\n\t\t\t}\n\t\t}\n\t}\n\tTopoEdge e;\n\treturn e;\n}\nTEST_CASE(\"bug2: TestBridgeTrimmedPeriodicFace \", \"[nurbs][Blend][fixbug]\")\n{\n\tint num = 1000;\n\tdouble ratio = 0.1;\n\tdouble refTol = DEFAULT_TOLERANCE;\n\tSECTION(\"TestBridgeCurve2\")\n\t{\n\t\tOUTPUT_DIRECTORY(nurbs, Blend/bug680/BridgeCurve2);\n\t\tstd::string filedir = INPUT_PATH_PREFIX \"/TestNURBS/TestBridgeCurve2/\";\n\t\tauto curve1 = ReadBRepCurve(filedir + \"curve1.brep\");\n\t\tauto curve2 = ReadBRepCurve(filedir + \"curve2.brep\");\n\t\tauto bridge = NURBSAPIBlend::BlendCurves(curve1, false, ContinuityType::G2, curve2, true, ContinuityType::G2);\n\t\tPoint3 sp1 = curve1->StartPoint();\n\t\tPoint3 ep1 = curve1->EndPoint();\n\t\tPoint3 sp2 = curve2->StartPoint();\n\t\tPoint3 ep2 = curve2->EndPoint();\n\t\tPoint3 sp3 = bridge->StartPoint();\n\t\tPoint3 ep3 = bridge->EndPoint();\n\t\tCHECK(sp3.X() == Approx(ep1.X()).margin(1e-7));\n\t\tCHECK(sp3.Y() == Approx(ep1.Y()));\n\t\tCHECK(sp3.Z() == Approx(ep1.Z()));\n\t\tCHECK(ep3.X() == Approx(sp2.X()).margin(1e-7));\n\t\tCHECK(ep3.Y() == Approx(sp2.Y()).margin(1e-7));\n\t\tCHECK(ep3.Z() == Approx(sp2.Z()).margin(1e-7));\n\t\tauto curve = ReadBRepCurve(filedir + \"Rhino/rhinoResult.brep\");\n\t\tdouble res = NurbsSampleCurve(num, refTol, bridge, curve);\n\t\tOCCTIO::OCCTTool::Write(MakeEdge(curve1), outdir + \"src1.brep\");\n\t\tOCCTIO::OCCTTool::Write(MakeEdge(curve2), outdir + \"src2.brep\");\n\t\tOCCTIO::OCCTTool::Write(MakeEdge(bridge), outdir + \"result.brep\");\n\t\tOCCTIO::OCCTTool::Write(MakeEdge(curve), outdir + \"rhinoResult.brep\");\n\t}\n}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static std::shared_ptr<Geom3BSplineCurve> BlendCurves( const std::shared_ptr<Geom3BSplineCurve>& curve1, bool isFront1, ContinuityType cont1, const std::shared_ptr<Geom3BSplineCurve>& curve2, bool isFront2, ContinuityType cont2),\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <nurbs/NURBSAPIBlend.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <topology/BRepExtremaDistShapeShape.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <modeling/MakeFace.hpp>\n#include <topology/BRepAdaptorCurve3.hpp>\n#include <topology/TopoTool.hpp>\n#include <io/ShapeTool.hpp>\n#include <topology/TopoTool.hpp>\n#include <topology/TopoCast.hpp>\n#include <geometry/Geom3Surface.hpp>\n#include <geometry/Geom3BSplineSurface.hpp>\n#include <nurbs/NURBSAPIConvert.hpp>\n#include <nurbs/NURBSAPIGetGeometry.hpp>\n#include <topology/TopoExplorer.hpp>\n#include <topology/TopoExplorerTool.hpp>\ndouble NURBSSampleEdge(int num, double tol, const shared_ptr<Geom3Curve>& curve, const TopoEdge& edge)\n{\n\tdouble fpu1 = curve->FirstParameter();\n\tdouble lpu1 = curve->LastParameter();\n\tdouble delta = (lpu1 - fpu1) / num;\n\tPoint3 p;\n\tint n = 0;\n\tfor (int i = 0; i < num; i++) {\n\t\tdouble t = fpu1 + i * delta;\n\t\tcurve->D0(t, p);\n\t\tif (BRepClassificationTools::IsPointInOnEdge(edge, p, tol))\n\t\t{\n\t\t\tn++;\n\t\t}\n\t}\n\tdouble r1 = 1.0 * (num - n) / num;\n\treturn r1;\n}\nTopoEdge ChooseSimilarEdge(const TopoShape& shape, const TopoEdge& edge)\n{\n\tint nsample = 1000;\n\tPoint3 p1, p2;\n\tBRepAdaptorCurve3 refC(edge);\n\tdouble refFp = refC.FirstParameter();\n\tdouble refLp = refC.LastParameter();\n\tfor (TopoExplorer ex(shape, ShapeType::Edge); ex.More(); ex.Next())\n\t{\n\t\tconst TopoEdge& cre = static_cast<const TopoEdge&>((ex.Current()));\n\t\tBRepAdaptorCurve3 crC(edge);\n\t\tdouble crFp = crC.FirstParameter();\n\t\tdouble crLp = crC.LastParameter();\n\t\tif (std::abs(refFp - crFp) < 0.001 && std::abs(refLp - crLp) < 0.001)\n\t\t{\n\t\t\tbool isOK = true;\n\t\t\tfor (int i = 0; i < nsample; i++)\n\t\t\t{\n\t\t\t\tdouble t1 = refFp + i * (refLp - refFp) / (nsample - 1);\n\t\t\t\tdouble t2 = crFp + i * (crLp - crFp) / (nsample - 1);\n\t\t\t\trefC.D0(t1, p1);\n\t\t\t\tcrC.D0(t2, p2);\n\t\t\t\tif (p1.Distance(p2) > 0.001)\n\t\t\t\t{\n\t\t\t\t\tisOK = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (isOK)\n\t\t\t{\n\t\t\t\treturn cre;\n\t\t\t}\n\t\t}\n\t}\n\tTopoEdge e;\n\treturn e;\n}\nTEST_CASE(\"case1: this is a test for testBlendCurves\", \"[nurbs][Blend][P1]\")\n{\n\tint num = 1000;\t\n\tdouble ratio = 0.1;\n\tdouble refTol = DEFAULT_TOLERANCE;\n\tSECTION(\"testBlendCurves\")\n\t{\n\t\tOUTPUT_DIRECTORY(nurbs, Blend/BlendCurves);\n\t\tauto cont1 = ContinuityType::G2;\n\t\tauto cont2 = ContinuityType::G2;\n\t\tbool isFront1 = true;\n\t\tbool isFront2 = true;\n\t\tstd::shared_ptr<Geom3BSplineCurve> bsp1, bsp2;\n\t\t{\n\t\t\tstd::vector<Point3> poles;\n\t\t\tpoles.push_back(Point3(0., -1., 0.));\n\t\t\tpoles.push_back(Point3(.7, -.7, 0.));\n\t\t\tpoles.push_back(Point3(1., -.3, 0.));\n\t\t\tpoles.push_back(Point3(1.2, 0., 0.));\n\t\t\tpoles.push_back(Point3(2., .3, 0.));\n\t\t\tpoles.push_back(Point3(.7, 1.7, 0.));\n\t\t\tpoles.push_back(Point3(0., 1., 0.));\n\t\t\tstd::vector<double> weights;\n\t\t\tweights.push_back(1.0);\n\t\t\tweights.push_back(1.3);\n\t\t\tweights.push_back(1.2);\n\t\t\tweights.push_back(0.7);\n\t\t\tweights.push_back(1.3);\n\t\t\tweights.push_back(1.0);\n\t\t\tweights.push_back(1.2);\n\t\t\tstd::vector<double> knots;\n\t\t\tknots.push_back(0.);\n\t\t\tknots.push_back(.25);\n\t\t\tknots.push_back(.5);\n\t\t\tknots.push_back(.75);\n\t\t\tknots.push_back(1.);\n\t\t\tstd::vector<int> mults(5, 1);\n\t\t\tmults.front() = 4;\n\t\t\tmults.back() = 4;\n\t\t\tbsp1 = std::make_shared<Geom3BSplineCurve>(poles, weights, knots, mults, 3);\n\t\t}\n\t\t{\n\t\t\tstd::vector<Point3> spinePoles;\n\t\t\tstd::vector<double> spineKnots(4);\n\t\t\tstd::vector<int> spineMults(4, 1);\n\t\t\tspinePoles.push_back(Point3(0.0, 0.0, 0.0));\n\t\t\tspinePoles.push_back(Point3(-0.1, 1.0, -0.2));\n\t\t\tspinePoles.push_back(Point3(0.1, 2.0, -0.1));\n\t\t\tspinePoles.push_back(Point3(0.2, 3.0, 0.1));\n\t\t\tspinePoles.push_back(Point3(0.1, 4.0, 0.0));\n\t\t\tspinePoles.push_back(Point3(0.0, 5.0, -0.1));\n\t\t\tstd::vector<double> weights;\n\t\t\tweights.push_back(1.0);\n\t\t\tweights.push_back(1.3);\n\t\t\tweights.push_back(1.2);\n\t\t\tweights.push_back(0.7);\n\t\t\tweights.push_back(1.3);\n\t\t\tweights.push_back(1.0);\n\t\t\tspineKnots[0] = 0;\n\t\t\tspineKnots[1] = 1.0 / 3.0;\n\t\t\tspineKnots[2] = 2.0 / 3.0;\n\t\t\tspineKnots[3] = 1;\n\t\t\tspineMults.front() = 4;\n\t\t\tspineMults.back() = 4;\n\t\t\tbsp2 = std::make_shared<Geom3BSplineCurve>(spinePoles, weights, spineKnots, spineMults, 3);\n\t\t}\n\t\tstd::vector<double> params1, params2;\n\t\tauto bsp3 = NURBSAPIBlend::BlendCurves(bsp1, isFront1, cont1, params1, bsp2, isFront2, cont2, params2);\n\t\tPoint3 sp1 = bsp1->StartPoint();\n\t\tPoint3 ep1 = bsp1->EndPoint();\n\t\tPoint3 sp2 = bsp2->StartPoint();\n\t\tPoint3 ep2 = bsp2->EndPoint();\n\t\tPoint3 sp3 = bsp3->StartPoint();\n\t\tPoint3 ep3 = bsp3->EndPoint();\n\t\tCHECK(sp3.X() == Approx(sp1.X()).margin(1e-7));\n\t\tCHECK(sp3.Y() == Approx(sp1.Y()));\n\t\tCHECK(sp3.Z() == Approx(sp1.Z()));\n\t\tCHECK(ep3.X() == Approx(sp2.X()).margin(1e-7));\n\t\tCHECK(ep3.Y() == Approx(sp2.Y()).margin(1e-7));\n\t\tCHECK(ep3.Z() == Approx(sp2.Z()).margin(1e-7));\n\t\tshared_ptr<Geom3BSplineCurve> bspCurve = ReadBRepCurve(INPUT_PATH_PREFIX \"/TestNURBS/TestBlendCurves/Rhino/rhinoResult.brep\");\n\t\tdouble res = NurbsSampleCurve(num, refTol, bsp3, bspCurve);\n\t\tCHECK(res <= ratio);\n\t\tOCCTIO::OCCTTool::Write(MakeEdge(bsp1), outdir + \"src1.brep\");\n\t\tOCCTIO::OCCTTool::Write(MakeEdge(bsp2), outdir + \"src2.brep\");\n\t\tOCCTIO::OCCTTool::Write(MakeEdge(bsp3), outdir + \"result.brep\");\n\t\tOCCTIO::OCCTTool::Write(MakeEdge(bspCurve), outdir + \"rhinoResult.brep\");\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static std::shared_ptr<Geom3BSplineCurve> ApproxPoints(const std::vector<Point3>& points, int degree, int npoles, bool isClosed = false, ApproxParameterizationType ptype = ApproxParameterizationType::ChordLength)\t @return curve\n\t @param ptype parameterization type\n\t @param isClosed Is curve closed\n\t @param npoles Target number of poles\n\t @param degree Target degree\n\t @param points Data points to be approximated\n\t @brief Approx points to a curve\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <nurbs/NURBSAPIApprox.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <nurbs/NURBSAPIInterpolate.hpp>\n#include <topology/BRepExtremaDistShapeShape.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <nurbs/NURBSAPIBuildCurve.hpp>\nTEST_CASE(\"case1: this is a test for Approx\", \"[nurbs][Approx][P1]\")\n{\n\tdouble refTol = DEFAULT_TOLERANCE;\n\tSECTION(\"TestApproxPoints\")\n\t{\n\t\tOUTPUT_DIRECTORY(nurbs, Approxs/ApproxPoints);\n\t\tstd::vector<Point3> points;\n\t\tPoint3 p1(0.0, 0.0, 0.0);\n\t\tPoint3 p2(-0.1, 1.0, -0.2);\n\t\tPoint3 p3(0.1, 2.0, -0.1);\n\t\tPoint3 p4(0.2, 3.0, 0.1);\n\t\tPoint3 p5(0.1, 4.0, 0.0);\n\t\tPoint3 p6(0.0, 5.0, -0.1);\n\t\tpoints.push_back(p1);\n\t\tpoints.push_back(p2);\n\t\tpoints.push_back(p3);\n\t\tpoints.push_back(p4);\n\t\tpoints.push_back(p5);\n\t\tpoints.push_back(p6);\n\t\tint degree = 3;\n\t\tint npoles = 5;\n\t\tauto curve = NURBSAPIApprox::ApproxPoints(points, degree, npoles);\n\t\tTopoVertex v1 = MakeVertex(p1);\n\t\tTopoVertex v2 = MakeVertex(p2);\n\t\tTopoVertex v3 = MakeVertex(p3);\n\t\tTopoVertex v4 = MakeVertex(p4);\n\t\tTopoVertex v5 = MakeVertex(p5);\n\t\tTopoVertex v6 = MakeVertex(p6);\n\t\tTopoEdge edge = MakeEdge(curve);\n\t\tBRepExtremaDistShapeShape dist1(v1, edge);\n\t\tBRepExtremaDistShapeShape dist2(v2, edge);\n\t\tBRepExtremaDistShapeShape dist3(v3, edge);\n\t\tBRepExtremaDistShapeShape dist4(v4, edge);\n\t\tBRepExtremaDistShapeShape dist5(v5, edge);\n\t\tBRepExtremaDistShapeShape dist6(v6, edge);\n\t\tCHECK(dist1.Value() <= Approx(refTol));\n\t\tCHECK(dist2.Value() <= Approx(refTol));\n\t\tCHECK(dist3.Value() <= Approx(refTol));\n\t\tCHECK(dist4.Value() <= Approx(refTol));\n\t\tCHECK(dist5.Value() <= Approx(refTol));\n\t\tCHECK(dist6.Value() <= Approx(refTol));\n\t\tPoint3 sp = curve->StartPoint();\n\t\tPoint3 ep = curve->EndPoint();\n\t\tCHECK(sp.X() == p1.X());\n\t\tCHECK(sp.Y() == p1.Y());\n\t\tCHECK(sp.Z() == p1.Z());\n\t\tCHECK(ep.X() == p6.X());\n\t\tCHECK(ep.Y() == p6.Y());\n\t\tCHECK(ep.Z() == p6.Z());\n\t\tCHECK(curve->Degree() == 3);\n\t\tCHECK(curve->NPoles() == 5);\n\t\tCHECK(curve->IsClosed() == false);\n\t\tCHECK(curve->IsPeriodic() == false);\n\t\tOCCTIO::OCCTTool::Write(v1, outdir + \"v1.brep\");\n\t\tOCCTIO::OCCTTool::Write(v2, outdir + \"v2.brep\");\n\t\tOCCTIO::OCCTTool::Write(v3, outdir + \"v3.brep\");\n\t\tOCCTIO::OCCTTool::Write(v4, outdir + \"v4.brep\");\n\t\tOCCTIO::OCCTTool::Write(v5, outdir + \"v5.brep\");\n\t\tOCCTIO::OCCTTool::Write(v6, outdir + \"v6.brep\");\n\t\tOCCTIO::OCCTTool::Write(edge, outdir + \"result.brep\");\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API TransformShape(const TopoShape& s, const Transformation3& tr, bool copyGeom = false, bool copyMesh = false)\t @param copyMesh Whether the mesh of the shape is copied\n\t @param copyGeom Whether the geometry of the shape is copied\n\t @param tr The transformation\n\t @param s The shape\n\t @brief Construct from a shape with a transformation\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <common/PointT.hpp>\n#include <modeling/MakeSphere.hpp>\n#include <modeling/TransformShape.hpp>\n#include <topomesh/BRepMeshIncrementalMesh.hpp>\n#include <modeling/MakeShapeTool.hpp>\n#include <common/TransformationT.hpp>\n#include <common/CartesianCoordinateSystem.hpp>\n#include <common/GeneralTransformationT.hpp>\n#include <modeling/GeneralTransformShape.hpp>\n#include <geometry/GlobalProperty.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <topology/BRepGlobalProperty.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"bug1: TransformShape  \", \"[modeling][TransformShape][fixbug]\") {\n\tTopoShape s = MakeSphere(1.0);\n\tBRepMeshIncrementalMesh mesher(s, 0.005, true);\n\tMakeShapeTool::EnsureNormalConsistency(s);\n\tTransformation3 tr;\n\ttr.SetRotation(CartesianCoordinateSystem::OZ(), M_PI_2);\n\ts = TransformShape(s, tr, true, true);\n\tCHECK(s.IsNull() == false);\n\tCHECK(s.Type() == AMCAX::ShapeType::Solid);\n\tGlobalProperty prop;\n\tBRepGlobalProperty::VolumeProperties(s, prop);\n\tCHECK(prop.Mass() == Approx(4.1887902048).epsilon(1e-11));\n\tPoint3 vP = prop.CenterOfMass();\n#ifndef WIN_CASE\n\tCHECK(vP.X() == Approx(0.0).margin(1e-12));\n\tCHECK(vP.Y() == Approx(0.0).margin(1e-12));\n\tCHECK(vP.Z() == Approx(0.0).margin(1e-12));\n#else\n\tCHECK(vP.X() == Approx(-4.0938241231662633e-18).epsilon(1e-12));\n\tCHECK(vP.Y() == Approx(-6.1820277995281757e-17).epsilon(1e-12));\n\tCHECK(vP.Z() == Approx(-3.1794228708137405e-17).epsilon(1e-12)); \n#endif\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API TransformShape(const TopoShape& s, const Transformation3& tr, bool copyGeom = false, bool copyMesh = false)\t @param copyMesh Whether the mesh of the shape is copied\n\t @param copyGeom Whether the geometry of the shape is copied\n\t @param tr The transformation\n\t @param s The shape\n\t @brief Construct from a shape with a transformation\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <common/PointT.hpp>\n#include <modeling/MakeSphere.hpp>\n#include <modeling/TransformShape.hpp>\n#include <topomesh/BRepMeshIncrementalMesh.hpp>\n#include <modeling/MakeShapeTool.hpp>\n#include <common/TransformationT.hpp>\n#include <common/CartesianCoordinateSystem.hpp>\n#include <common/GeneralTransformationT.hpp>\n#include <modeling/GeneralTransformShape.hpp>\n#include <geometry/GlobalProperty.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <topology/BRepGlobalProperty.hpp>\n#include <geometry/Geom3BSplineCurve.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <topology/TopoTool.hpp>\n#include <topology/BRepAdaptorCurve3.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"bug1: GeneralTransformShape  \", \"[modeling][GeneralTransformShape][fixbug]\") {\n\tTopoShape s = MakeSphere(1.0);\n\tBRepMeshIncrementalMesh mesher(s, 0.005, true);\n\tMakeShapeTool::EnsureNormalConsistency(s);\n\tGeneralTransformation3 tr;\n\ttr.SetAffinity(Frame3(), 5.0);\n\ts = GeneralTransformShape(s, tr);\n\tCHECK(s.Type() == AMCAX::ShapeType::Solid);\n\tCHECK(s.IsNull() == false);\n\tGlobalProperty prop;\n\tBRepGlobalProperty::VolumeProperties(s, prop);\n\tCHECK(prop.Mass() == Approx(20.934791259).epsilon(1e-11));\n\tPoint3 vP = prop.CenterOfMass();\n#ifndef WIN_CASE\n\tCHECK(vP.X() == Approx(0.0).margin(1e-3));\n\tCHECK(vP.Y() == Approx(0.0).margin(1e-12));\n\tCHECK(vP.Z() == Approx(0.0).margin(1e-12));\n#else\n\tCHECK(vP.X() == Approx(-2.2218808037914858e-04).epsilon(1e-12));\n\tCHECK(vP.Y() == Approx(-1.0782779568197278e-16).epsilon(1e-12));\n\tCHECK(vP.Z() == Approx(-1.6920954211916623e-16).epsilon(1e-12));\n#endif\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static TopoShape SewShape(const std::list<TopoShape>& shapes, double tolerance)\t @return The sewed shape\n\t @param tolerance The tolerance\n\t @param shapes The shapes to be sewed\n\t          If some edges do not coincide, the related faces remain unsewed.\n\t @details The border edges are merged to common edges under a given tolerance.\n\t @brief Sew faces to a shell\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <modeling/MakeShapeTool.hpp>\n#include<modeling/MakeFace.hpp>\n#include<math/Plane.hpp>\n#include <common/CartesianCoordinateSystem.hpp>\n#include <topology/TopoExplorerTool.hpp>\nTEST_CASE(\"case1-1: MakeShapeTool::SewShape \", \"[modeling][MakeShapeTool][SewShape][P1]\")\n{\n\tstd::list<TopoShape> shapes;\n\tshapes.push_back(MakeFace(Plane(), 0.0, 1.0, 0.0, 1.0));\n\tshapes.push_back(MakeFace(Plane(Frame3(Point3(1.0, 0.0, 0.0), CartesianCoordinateSystem::DX(), -CartesianCoordinateSystem::DZ())), 0.0, 1.0, 0.0, 1.0));\n\tTopoShape result = MakeShapeTool::SewShape(shapes, Precision::Confusion());\n\tCHECK(OCCTIO::OCCTTool::Write(result, OUTPUT_PATH_PREFIX\"SewShapetest1-0.brep\"));\n\tIndexSet<TopoShape> sf1, sf2, sf3;\n\tCHECK(GetTopoToolCount(result, AMCAX::ShapeType::Shell, sf1) == 1);\n\tCHECK(GetTopoToolCount(result, AMCAX::ShapeType::Compound, sf2) == 0);\n\tCHECK(GetTopoToolCount(result, AMCAX::ShapeType::Face, sf3) == 2);\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API MakeRightPrism(const Point3& baseLocation, const std::vector<Point3>& basepoints, const Point3& apex)\t @param apex A point on the top plane\n\t @param basepoints The base points that are projected onto the base plane\n\t @param baseLocation The location of the base plane\n\t @details The base plane are determined by the location point and the first two base points\n\t @brief Construct a right prism with a given location on the base plane\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include<common/Exception.hpp>\n#include <modeling/MakeRightPrism.hpp>\n#include <hatch/BRepClassificationTools.hpp>\nTEST_CASE(\"case2 MakeRightPrism(p1, p2, p3, p4, apex)  \", \"[modeling][MakeRightPrism][P1]\")\n{\n\tSECTION(\"4 points on same line\") {\n        Point3 p1(-1.0, 0.0, 0.0);\n        Point3 p2(0.0, 0.0, 0.0);\n        Point3 p3(2.0, 0.0, 0.0);\n        Point3 p4(4.0, 0.0, 0.0);\n        Point3 apex(2.0, 2.0, -4.5);\n        std::vector<Point3> points = { p1, p2, p3,p4 };\n        CHECK_THROWS_AS(AMCAX::MakeRightPrism(p1, p2, p3, p4, apex), AMCAX::_ConstructionError);\n    }\n}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API MakeRightPrism(const Frame3& frame, const std::vector<Point3>& basepoints, const Point3& apex)\t @param apex A point on the top plane\n\t @param basepoints Points that are projected onto the base plane\n\t @param frame The frame of base plane\n\t @brief Construct a right prism with a given base plane frame\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include<common/Exception.hpp>\n#include <modeling/MakeRightPrism.hpp>\n#include <hatch/BRepClassificationTools.hpp>\nTEST_CASE(\"case1 MakeRightPrism(p1, p2, p3, apex)  \", \"[modeling][MakeRightPrism][P1]\")\n{\n    Point3 p1(0.0, 0.0, 0.0);\n    Point3 p2(4.0, 0.0, 0.0);\n    Point3 p3(2.0, 4.0, 0.0);\n    Point3 apex(0.0, 0.0, 4.5);\n    std::vector<Point3> points = { p1, p2, p3, apex };\n    TopoShape shape = AMCAX::MakeRightPrism(p1, p2, p3, apex);\n    AMCAX::GlobalProperty props;\n    CHECK( GetSurfaceProperties(shape, props, true, false) == Approx( 74.249223595));\n    CHECK( GetVolumeProperties(shape, props, true, false) == 36.0);\n    CHECK(shape.Type() == ShapeType::Solid);\n    OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX\"MakeRightPrism_01.brep\");\n    TopoSolid solid = AMCAX::TopoCast::Solid(shape);\n    for (const Point3& p : points) {\n        bool isPointOnSolid = AMCAX::BRepClassificationTools::IsPointInOnSolid(solid, p);\n        CHECK(isPointOnSolid == true);\n    }\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API MakeRightPrism(const Frame3& frame, const Point3& p1, const Point3& p2, const Point3& p3, const Point3& p4, const Point3& apex)\t @param apex A point on the top plane\n\t @param p1,p2,p3,p4 Points that are projected onto the base plane\n\t @param frame The frame of base plane\n\t @brief Construct a right quadrilateral prism with a given plane frame\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include<common/Exception.hpp>\n#include <modeling/MakeRightPrism.hpp>\n#include <hatch/BRepClassificationTools.hpp>\nTEST_CASE(\"case2 MakeRightPrism(p1, p2, p3, apex)  \", \"[modeling][MakeRightPrism][P1]\")\n{\n    Point3 p1(-2.0, 0.0, -2.0);\n    Point3 p2(2.0, 0.0, -2.0);\n    Point3 p3(0.0, 4.0, -2.0);\n    Point3 apex(-5.0, 999.0, 2.5);\n    std::vector<Point3> points = { p1, p2, p3 };\n    TopoShape shape = AMCAX::MakeRightPrism(p1, p2, p3, apex);\n    AMCAX::GlobalProperty props;\n    CHECK(GetSurfaceProperties(shape, props, true, false) == Approx(74.249223595));\n    CHECK(GetVolumeProperties(shape, props, true, false) == 36.0);\n    CHECK(shape.Type() == ShapeType::Solid);\n    OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX\"MakeRightPrism_02.brep\");\n    TopoSolid solid = AMCAX::TopoCast::Solid(shape);\n    for (const Point3& p : points) {\n        bool isPointOnSolid = AMCAX::BRepClassificationTools::IsPointInOnSolid(solid, p);\n        CHECK(isPointOnSolid == true);\n    }\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API MakeRightPrism(const Frame3& frame, const Point3& p1, const Point3& p2, const Point3& p3, const Point3& apex)\t @param apex A point on the top plane\n\t @param p1,p2,p3 Points that are projected onto the base plane\n\t @param frame The frame of base plane\n\t @brief Construct a right triangular prism with a given plane frame\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include<common/Exception.hpp>\n#include <modeling/MakeRightPrism.hpp>\n#include <hatch/BRepClassificationTools.hpp>\nTEST_CASE(\"case1 MakeRightPrism(p1, p2, p3, apex)  \", \"[modeling][MakeRightPrism][P1]\")\n{\n    Point3 p1(0.0, 0.0, 0.0);\n    Point3 p2(4.0, 0.0, 0.0);\n    Point3 p3(2.0, 4.0, 0.0);\n    Point3 apex(0.0, 0.0, 4.5);\n    std::vector<Point3> points = { p1, p2, p3, apex };\n    TopoShape shape = AMCAX::MakeRightPrism(p1, p2, p3, apex);\n    AMCAX::GlobalProperty props;\n    CHECK( GetSurfaceProperties(shape, props, true, false) == Approx( 74.249223595));\n    CHECK( GetVolumeProperties(shape, props, true, false) == 36.0);\n    CHECK(shape.Type() == ShapeType::Solid);\n    OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX\"MakeRightPrism_01.brep\");\n    TopoSolid solid = AMCAX::TopoCast::Solid(shape);\n    for (const Point3& p : points) {\n        bool isPointOnSolid = AMCAX::BRepClassificationTools::IsPointInOnSolid(solid, p);\n        CHECK(isPointOnSolid == true);\n    }\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API MakeRightPrism(const Frame3& frame, double radius, int nside, double height)\t @param height Height of the polygon\n\t @param nside Number of sides of the base polygon\n\t @param radius Radius of the circumcircle of the base polygon\n\t @param frame The local coordinate system\n\t @brief Construct a right regular prism\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include<common/Exception.hpp>\n#include <modeling/MakeRightPrism.hpp>\n#include <hatch/BRepClassificationTools.hpp>\nTEST_CASE(\"bug:case5 MakeRightPrism(p1, p2, p3, apex)  \", \"[modeling][MakeRightPrism][P1][fixbug]\")\n{\n    Point3 p1(0.0, 0.0, 0.0);\n    Point3 p2(4.0, 0.0, 0.0);\n    Point3 p3(6.0, 0.0, 0.0);\n    Point3 apex(2.0, 2.0, -4.5);\n    std::vector<Point3> points = { p1, p2, p3, apex };\n    CHECK_THROWS_AS(AMCAX::MakeRightPrism(p1, p2, p3, apex), AMCAX::_ConstructionError);\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API MakeRightPrism(const std::vector<Point3>& basepoints, const Point3& apex)\t @param apex A point on the top plane\n\t @param basepoints Points on the base plane\n\t @brief Construct a right prism with base points and a point on the top plane\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include<common/Exception.hpp>\n#include <modeling/MakeRightPrism.hpp>\n#include <hatch/BRepClassificationTools.hpp>\nTEST_CASE(\"case3 MakeRightPrism(p1, p2, p3, apex)  \", \"[modeling][MakeRightPrism][P1]\")\n{\n    Point3 p1(0.0, 0.0, 0.0);\n    Point3 p2(4.0, 0.0, 0.0);\n    Point3 p3(2.0, 4.0, -2.0);\n    Point3 apex(4.0, 0.0, -4.5);\n    std::vector<Point3> points = { p1, p2, p3 };\n    TopoShape shape = AMCAX::MakeRightPrism(p1, p2, p3, apex);\n    AMCAX::GlobalProperty props;\n    CHECK(GetSurfaceProperties(shape, props, true, false) == Approx(73.4242573984));\n    CHECK(GetVolumeProperties(shape, props, true, false) == 36.0);\n    CHECK(shape.Type() == ShapeType::Solid);\n    OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX\"MakeRightPrism_03.brep\");\n    TopoSolid solid = AMCAX::TopoCast::Solid(shape);\n    for (const Point3& p : points) {\n        bool isPointOnSolid = AMCAX::BRepClassificationTools::IsPointInOnSolid(solid, p);\n        CHECK(isPointOnSolid == true);\n    }\n    Point3 p4(2.0, 2.2, -5.6);\n    bool isPointOnSolid = AMCAX::BRepClassificationTools::IsPointInOnSolid(solid, p4);\n    CHECK(isPointOnSolid == true);\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API MakeRightPrism(const Point3& p1, const Point3& p2, const Point3& p3, const Point3& p4, const Point3& apex)\t @param apex A point on the top plane\n\t @param p1,p2,p3,p4 Points on the base plane\n\t @brief Construct a right quadrilateral prism\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include<common/Exception.hpp>\n#include <modeling/MakeRightPrism.hpp>\n#include <hatch/BRepClassificationTools.hpp>\nTEST_CASE(\"case1 MakeRightPrism(p1, p2, p3, apex)  \", \"[modeling][MakeRightPrism][P1]\")\n{\n    Point3 p1(0.0, 0.0, 0.0);\n    Point3 p2(4.0, 0.0, 0.0);\n    Point3 p3(2.0, 4.0, 0.0);\n    Point3 apex(0.0, 0.0, 4.5);\n    std::vector<Point3> points = { p1, p2, p3, apex };\n    TopoShape shape = AMCAX::MakeRightPrism(p1, p2, p3, apex);\n    AMCAX::GlobalProperty props;\n    CHECK( GetSurfaceProperties(shape, props, true, false) == Approx( 74.249223595));\n    CHECK( GetVolumeProperties(shape, props, true, false) == 36.0);\n    CHECK(shape.Type() == ShapeType::Solid);\n    OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX\"MakeRightPrism_01.brep\");\n    TopoSolid solid = AMCAX::TopoCast::Solid(shape);\n    for (const Point3& p : points) {\n        bool isPointOnSolid = AMCAX::BRepClassificationTools::IsPointInOnSolid(solid, p);\n        CHECK(isPointOnSolid == true);\n    }\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API MakeRightPrism(const Point3& p1, const Point3& p2, const Point3& p3, const Point3& apex)\t @param apex A point on the top plane\n\t @param p1,p2,p3 Points on the base plane\n\t @brief Construct a right triangular prism\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include<common/Exception.hpp>\n#include <modeling/MakeRightPrism.hpp>\n#include <hatch/BRepClassificationTools.hpp>\nTEST_CASE(\"case1 MakeRightPrism(p1, p2, p3, apex)  \", \"[modeling][MakeRightPrism][P1]\")\n{\n    Point3 p1(0.0, 0.0, 0.0);\n    Point3 p2(4.0, 0.0, 0.0);\n    Point3 p3(2.0, 4.0, 0.0);\n    Point3 apex(0.0, 0.0, 4.5);\n    std::vector<Point3> points = { p1, p2, p3, apex };\n    TopoShape shape = AMCAX::MakeRightPrism(p1, p2, p3, apex);\n    AMCAX::GlobalProperty props;\n    CHECK( GetSurfaceProperties(shape, props, true, false) == Approx( 74.249223595));\n    CHECK( GetVolumeProperties(shape, props, true, false) == 36.0);\n    CHECK(shape.Type() == ShapeType::Solid);\n    OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX\"MakeRightPrism_01.brep\");\n    TopoSolid solid = AMCAX::TopoCast::Solid(shape);\n    for (const Point3& p : points) {\n        bool isPointOnSolid = AMCAX::BRepClassificationTools::IsPointInOnSolid(solid, p);\n        CHECK(isPointOnSolid == true);\n    }\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API MakeRevol(const TopoShape& s, const Axis3& a, bool copy = false)\t @param copy Whether copy the base shape\n\t @param a The rotation axis\n\t @param s The base shape\n\t @brief Construct from a base shape and a rotation axis\n,\n",
      "output": "#include <catch.hpp>\n#include<testHelper.h>\n#include <modeling/MakeRevol.hpp>\n#include <common/PointT.hpp>\n#include <topology/TopoVertex.hpp>\n#include <common/CartesianCoordinateSystem.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <topology/TopoBuilder.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <common/IndexSet.hpp>\n#include <topology/TopoExplorerTool.hpp>\n#include <topology/TopoTool.hpp>\n#include <topology/TopoCast.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"BUG1:create MakeRevol bug   \", \"[modeling][MakeRevol][fixbug][P1]\") {\n\tPoint3 p(1.0, 0.0, 0.0);\n\tTopoVertex v0 = MakeVertex(p);\n\tTopoShape e = MakeRevol(v0, CartesianCoordinateSystem::OZ(), M_PI_2);\n\tTopoShape f = MakeRevol(e, CartesianCoordinateSystem::OX(), M_PI_2);\n\tIndexSet<TopoShape> vertices;\n\tTopoExplorerTool::MapShapes(f, ShapeType::Vertex, vertices);\n\tstd::cout << TopoTool::Tolerance(TopoCast::Vertex(vertices[0])) << std::endl;\n\tCHECK(TopoTool::Tolerance(TopoCast::Vertex(vertices[0])) == 1e-07);\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API MakeRevol(const TopoShape& s, const Axis3& a, double d, bool copy = false)\t @param copy Whether copy the base shape\n\t @param d The rotation angle\n\t @param a The rotation axis\n\t @param s The base shape\n\t @brief Construct from a base shape, a rotation axis and a rotation angle\n,\n",
      "output": "#include <catch.hpp>\n#include<testHelper.h>\n#include <modeling/MakeRevol.hpp>\n#include <common/PointT.hpp>\n#include <topology/TopoVertex.hpp>\n#include <common/CartesianCoordinateSystem.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <topology/TopoBuilder.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <common/IndexSet.hpp>\n#include <topology/TopoExplorerTool.hpp>\n#include <topology/TopoTool.hpp>\n#include <topology/TopoCast.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"BUG1:create MakeRevol bug   \", \"[modeling][MakeRevol][fixbug][P1]\") {\n\tPoint3 p(1.0, 0.0, 0.0);\n\tTopoVertex v0 = MakeVertex(p);\n\tTopoShape e = MakeRevol(v0, CartesianCoordinateSystem::OZ(), M_PI_2);\n\tTopoShape f = MakeRevol(e, CartesianCoordinateSystem::OX(), M_PI_2);\n\tIndexSet<TopoShape> vertices;\n\tTopoExplorerTool::MapShapes(f, ShapeType::Vertex, vertices);\n\tstd::cout << TopoTool::Tolerance(TopoCast::Vertex(vertices[0])) << std::endl;\n\tCHECK(TopoTool::Tolerance(TopoCast::Vertex(vertices[0])) == 1e-07);\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API MakePyramid(const Point3& baseLocation, const std::vector<Point3>& basepoints, const Point3& apex)\t @param apex Apex point\n\t @param basepoints The base points that are projected onto the base plane\n\t @param baseLocation The location of the base plane\n\t @details The base plane are determined by the location point and the first two base points\n\t @brief Construct a pyramid with a given location on the base plane\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <modeling/MakePyramid.hpp>\n#include <hatch/BRepClassificationTools.hpp>\nTEST_CASE(\"case1: MakePyramid(basepoints, apex)  \", \"[modeling][MakePyramid][P1]\")\n{\n    Point3 p1(-2.0, 1.0, 0.0);\n    Point3 p2(1.0, -3.0, 0.0);\n    Point3 p3(-1.0, -2.5, 0.0);\n    Point3 apex(5.0, 3.0, 4.5);\n    std::vector<Point3> points = { p1, p2, p3};\n    TopoShape shape = AMCAX::MakePyramid(points, apex);\n    AMCAX::GlobalProperty props;\n    CHECK(GetSurfaceProperties(shape, props, true, false) == Approx(47.6096343921));\n    CHECK(GetVolumeProperties(shape, props, true, false) == Approx(4.875));\n    CHECK(shape.Type() == ShapeType::Solid);\n    CHECK(OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX\"MakePyramid3_case01.brep\"));\n    TopoSolid solid = AMCAX::TopoCast::Solid(shape);\n    CHECK(AMCAX::BRepClassificationTools::IsPointInOnSolid(solid, apex));\n    for (const Point3& p : points) {\n        bool isPointOnSolid = AMCAX::BRepClassificationTools::IsPointInOnSolid(solid, p);\n        CHECK(isPointOnSolid == true);\n    }\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API MakePyramid(const Frame3& frame, const std::vector<Point3>& basepoints, const Point3& apex)\t @param apex Apex point\n\t @param basepoints Points that are projected onto the base plane\n\t @param frame The frame of base plane\n\t @brief Construct a pyramid with a given base plane frame\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <modeling/MakePyramid.hpp>\n#include <hatch/BRepClassificationTools.hpp>\nTEST_CASE(\"case2: MakePyramid(p1, p2, p3, p4, apex) \", \"[modeling][MakePyramid][P1]\")\n{ \n    Point3 p1(-2.0, 1.0, -1.0);\n    Point3 p2(1.0, 3.0, 0.0);\n    Point3 p3(4.0, -1.0, 1.0);\n    Point3 p4(-1.0, -2.0, 0.0);\n    Point3 apex(1.0, -1.0, -4.5);\n    CHECK_THROWS_AS( AMCAX::MakePyramid(p1, p2, p3, p4, apex), AMCAX::_ConstructionError );\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API MakePyramid(const Frame3& frame, const Point3& p1, const Point3& p2, const Point3& p3, const Point3& p4, const Point3& apex)\t @param apex Apex point\n\t @param p1,p2,p3,p4 Points that are projected onto the base plane\n\t @param frame The frame of base plane\n\t @brief Construct a quadrilateral pyramid with a given plane frame\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <modeling/MakePyramid.hpp>\n#include <hatch/BRepClassificationTools.hpp>\nTEST_CASE(\"case2 MakePyramid(p1, p2, p3, apex)  \", \"[modeling][MakePyramid][P1]\")\n{\n    Point3 p1(-2.0, 0.0, -2.0);\n    Point3 p2(2.0, 0.0, -2.0);\n    Point3 p3(0.0, 4.0, -2.0);\n    Point3 apex(-5.0, 0.0, 2.5);\n    std::vector<Point3> points = { p1, p2, p3, apex };\n    TopoShape shape = AMCAX::MakePyramid(p1, p2, p3, apex);\n    AMCAX::GlobalProperty props;\n    CHECK(GetSurfaceProperties(shape, props, true, false) == Approx(45.9563141634));\n    CHECK(GetVolumeProperties(shape, props, true, false) == Approx(12.0));\n    CHECK(shape.Type() == ShapeType::Solid);\n    OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX\"MakePyramid_case02.brep\");\n    TopoSolid solid = AMCAX::TopoCast::Solid(shape);\n    for (const Point3& p : points) {\n        bool isPointOnSolid = AMCAX::BRepClassificationTools::IsPointInOnSolid(solid, p);\n        CHECK(isPointOnSolid == true);\n    }\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API MakePyramid(const Frame3& frame, const Point3& p1, const Point3& p2, const Point3& p3, const Point3& apex)\t @param apex Apex point\n\t @param p1,p2,p3 Points that are projected onto the base plane\n\t @param frame The frame of base plane\n\t @brief Construct a tetrahedron with a given plane frame\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <modeling/MakePyramid.hpp>\n#include <hatch/BRepClassificationTools.hpp>\nTEST_CASE(\"case1 MakePyramid(p1, p2, p3, apex)  \", \"[modeling][MakePyramid][P1]\")\n{\n    Point3 p1(0.0, 0.0, 0.0);\n    Point3 p2(4.0, 0.0, 0.0);\n    Point3 p3(2.0, 4.0, 0.0);\n    Point3 apex(0.0, 0.0, 4.5);\n    std::vector<Point3> points = { p1, p2, p3, apex };\n    TopoShape shape = AMCAX::MakePyramid(p1, p2, p3, apex);\n    AMCAX::GlobalProperty props;\n    CHECK(GetSurfaceProperties(shape, props, true, false) == Approx(39.9172660309));\n    CHECK(GetVolumeProperties(shape, props, true, false) == Approx(12.0));\n    CHECK(shape.Type() == ShapeType::Solid);\n    OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX\"MakePyramid_case01.brep\");\n    TopoSolid solid = AMCAX::TopoCast::Solid(shape);\n    for (const Point3& p : points) {\n        bool isPointOnSolid = AMCAX::BRepClassificationTools::IsPointInOnSolid(solid, p);\n        CHECK(isPointOnSolid == true);\n    }\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API MakePyramid(const Frame3& frame, double radius, int nside, double height)\t @param height Height of the polygon\n\t @param nside Number of sides of the base polygon\n\t @param radius Radius of the circumcircle of the base polygon\n\t @param frame The local coordinate system\n\t @brief Construct a regular pyramid\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <modeling/MakePyramid.hpp>\n#include <hatch/BRepClassificationTools.hpp>\nTEST_CASE(\"case2: MakePyramid(p1, p2, p3, p4, apex) \", \"[modeling][MakePyramid][P1]\")\n{ \n    Point3 p1(-2.0, 1.0, -1.0);\n    Point3 p2(1.0, 3.0, 0.0);\n    Point3 p3(4.0, -1.0, 1.0);\n    Point3 p4(-1.0, -2.0, 0.0);\n    Point3 apex(1.0, -1.0, -4.5);\n    CHECK_THROWS_AS( AMCAX::MakePyramid(p1, p2, p3, p4, apex), AMCAX::_ConstructionError );\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API MakePyramid(const std::vector<Point3>& basepoints, const Point3& apex)\t @param apex Apex point\n\t @param basepoints Points on the base plane\n\t @brief Construct a pyramid with base points and an apex point\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <modeling/MakePyramid.hpp>\n#include <hatch/BRepClassificationTools.hpp>\nTEST_CASE(\"case1: MakePyramid(basepoints, apex)  \", \"[modeling][MakePyramid][P1]\")\n{\n    Point3 p1(-2.0, 1.0, 0.0);\n    Point3 p2(1.0, -3.0, 0.0);\n    Point3 p3(-1.0, -2.5, 0.0);\n    Point3 apex(5.0, 3.0, 4.5);\n    std::vector<Point3> points = { p1, p2, p3};\n    TopoShape shape = AMCAX::MakePyramid(points, apex);\n    AMCAX::GlobalProperty props;\n    CHECK(GetSurfaceProperties(shape, props, true, false) == Approx(47.6096343921));\n    CHECK(GetVolumeProperties(shape, props, true, false) == Approx(4.875));\n    CHECK(shape.Type() == ShapeType::Solid);\n    CHECK(OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX\"MakePyramid3_case01.brep\"));\n    TopoSolid solid = AMCAX::TopoCast::Solid(shape);\n    CHECK(AMCAX::BRepClassificationTools::IsPointInOnSolid(solid, apex));\n    for (const Point3& p : points) {\n        bool isPointOnSolid = AMCAX::BRepClassificationTools::IsPointInOnSolid(solid, p);\n        CHECK(isPointOnSolid == true);\n    }\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API MakePyramid(const Point3& p1, const Point3& p2, const Point3& p3, const Point3& p4, const Point3& apex)\t @param apex Apex point\n\t @param p1,p2,p3,p4 Points on the base plane\n\t @brief Construct a quadrilateral pyramid\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <modeling/MakePyramid.hpp>\n#include <hatch/BRepClassificationTools.hpp>\nTEST_CASE(\"case2 MakePyramid(p1, p2, p3, apex)  \", \"[modeling][MakePyramid][P1]\")\n{\n    Point3 p1(-2.0, 0.0, -2.0);\n    Point3 p2(2.0, 0.0, -2.0);\n    Point3 p3(0.0, 4.0, -2.0);\n    Point3 apex(-5.0, 0.0, 2.5);\n    std::vector<Point3> points = { p1, p2, p3, apex };\n    TopoShape shape = AMCAX::MakePyramid(p1, p2, p3, apex);\n    AMCAX::GlobalProperty props;\n    CHECK(GetSurfaceProperties(shape, props, true, false) == Approx(45.9563141634));\n    CHECK(GetVolumeProperties(shape, props, true, false) == Approx(12.0));\n    CHECK(shape.Type() == ShapeType::Solid);\n    OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX\"MakePyramid_case02.brep\");\n    TopoSolid solid = AMCAX::TopoCast::Solid(shape);\n    for (const Point3& p : points) {\n        bool isPointOnSolid = AMCAX::BRepClassificationTools::IsPointInOnSolid(solid, p);\n        CHECK(isPointOnSolid == true);\n    }\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API MakePyramid(const Point3& p1, const Point3& p2, const Point3& p3, const Point3& apex)\t @param apex Apex point\n\t @param p1,p2,p3 Points on the base plane\n\t @brief Construct a tetrahedron\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <modeling/MakePyramid.hpp>\n#include <hatch/BRepClassificationTools.hpp>\nTEST_CASE(\"case1 MakePyramid(p1, p2, p3, apex)  \", \"[modeling][MakePyramid][P1]\")\n{\n    Point3 p1(0.0, 0.0, 0.0);\n    Point3 p2(4.0, 0.0, 0.0);\n    Point3 p3(2.0, 4.0, 0.0);\n    Point3 apex(0.0, 0.0, 4.5);\n    std::vector<Point3> points = { p1, p2, p3, apex };\n    TopoShape shape = AMCAX::MakePyramid(p1, p2, p3, apex);\n    AMCAX::GlobalProperty props;\n    CHECK(GetSurfaceProperties(shape, props, true, false) == Approx(39.9172660309));\n    CHECK(GetVolumeProperties(shape, props, true, false) == Approx(12.0));\n    CHECK(shape.Type() == ShapeType::Solid);\n    OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX\"MakePyramid_case01.brep\");\n    TopoSolid solid = AMCAX::TopoCast::Solid(shape);\n    for (const Point3& p : points) {\n        bool isPointOnSolid = AMCAX::BRepClassificationTools::IsPointInOnSolid(solid, p);\n        CHECK(isPointOnSolid == true);\n    }\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API void Add(const Point3& p)\t @param p The point\n\t @brief Add a new point to the polygon\n,\n",
      "output": "#include<catch.hpp>\n#include<iostream>\n#include <modeling/MakePolygon.hpp>\n#include <topology/TopoVertex.hpp>\n#include <topology/TopoEdge.hpp>\n#include <topology/TopoExplorerTool.hpp>\n#include <topology/TopoShape.hpp>\n#include <topology/TopoTool.hpp>\nTEST_CASE(\"void AMCAX::MakePolygon::Add(const Point3 & p) - case1 add valid 3D point\", \"[modeling][MakePolygon][P1]\") {\n        AMCAX::Point3 p1(1.0, 2.0, 3.0);\n        AMCAX::Point3 p2(4.1, 5.1, 6.1);\n        AMCAX::MakePolygon polygon(p1, p2);\n        bool lastAdded1 = polygon.Added();\n        CHECK(lastAdded1 == true);\n        const AMCAX::TopoEdge &lastEdge = polygon.Edge();\n        CHECK(lastEdge.IsNull() == false);\n        CHECK(lastEdge.NChildren() == 2);\n        CHECK(lastEdge.Type() == AMCAX::ShapeType::Edge);\n        AMCAX::TopoVertex v1,v2;\n        AMCAX::TopoExplorerTool::Vertices(lastEdge, v1, v2,false);\n        CHECK_FALSE(v1.IsNull());\n        CHECK_FALSE(v2.IsNull());\n        CHECK(v1.Type() == AMCAX::ShapeType::Vertex);\n        CHECK(v2.Type() == AMCAX::ShapeType::Vertex);\n        AMCAX::Point3 vpoint1;\n        vpoint1 = AMCAX::TopoTool::Point(v1);\n        CHECK(vpoint1.X() == 1.0);\n        CHECK(vpoint1.Y() == 2.0);\n        CHECK(vpoint1.Z() == 3.0);\n        AMCAX::Point3 p3(4.1, 5.1, 6.1);\n        polygon.Add(p3);\n        bool lastAdded2 = polygon.Added();\n        CHECK(lastAdded2 == false);\n        AMCAX::Point3 p4(7.0, 8.0, 9.0);\n        polygon.Add(p4);\n        bool lastAdded3 = polygon.Added();\n        CHECK(lastAdded3 == true);\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API MakePolygon(const Point3& p1, const Point3& p2)\t @param p2 The second point\n\t @param p1 The first point\n\t @brief Construct from two points\n,\n",
      "output": "#include<catch.hpp>\n#include<iostream>\n#include <modeling/MakePolygon.hpp>\n#include <topology/TopoVertex.hpp>\n#include <topology/TopoEdge.hpp>\n#include <topology/TopoExplorerTool.hpp>\n#include <topology/TopoShape.hpp>\n#include <topology/TopoTool.hpp>\nTEST_CASE(\"MakePolygon Invalid input points\", \"[modeling][MakePolygon][P3]\") {\n        AMCAX::Point3 p1(0.0, 0.0, 0.0);\n        AMCAX::MakePolygon polygon(p1, p1);\n        bool lastAdded = polygon.Added();\n        CHECK(lastAdded == false);\n    }\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API MakeTorus(const Frame3& frame, double r1, double r2, double angle1, double angle2, double angle)\t @param angle The rotation angle\n\t @param angle2 The end angle\n\t @param angle1 The start angle\n\t @param r2 The minor radius\n\t @param r1 The major radius\n\t @param frame The local coordinate system\n\t @brief Construct from a local coordinate system, a major radius, a minor radius, two angles that forms an arc of the section circle and a rotation angle\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <modeling/MakeTorus.hpp>\n#include <common/CartesianCoordinateSystem.hpp>\n#include <topology/TopoBuilder.hpp>\nTEST_CASE(\"bug1: MakeTorus   \", \"[modeling][MakeTorus][P1][fixbug]\")\n{\n\tstd::vector<TopoShape> shapes;\n\tconstexpr double major = 3.0;\n\tconstexpr double minor = 1.0;\n\tauto addshape = [&](double angle1, double angle2, double angle)\n\t{\n\t\tFrame3 frame(Point3(0.0, 0.0, static_cast<double>(shapes.size()) * 3.0), CartesianCoordinateSystem::DZ());\n\t\tshapes.push_back(MakeTorus(frame, major, minor, angle1, angle2, angle));\n\t};\n\taddshape(0.0, 2.0 * M_PI, 2.0 * M_PI);\n\taddshape(0.0, 2.0 * M_PI, M_PI_2);\n\taddshape(0.0, M_PI, 2.0 * M_PI);\n\taddshape(M_PI_2, 3.0 * M_PI_2, 2.0 * M_PI);\n\taddshape(M_PI, 2.0 * M_PI, 2.0 * M_PI);\n\taddshape(-M_PI_2, M_PI_2, 2.0 * M_PI);\n\taddshape(M_PI_4, M_PI_4 * 3, 2.0 * M_PI);\n\taddshape(M_PI_4 * 3, M_PI_4 * 5, 2.0 * M_PI);\n\taddshape(M_PI_4 * 5, M_PI_4 * 7, 2.0 * M_PI);\n\taddshape(-M_PI_4, M_PI_4, 2.0 * M_PI);\n\taddshape(0.0, M_PI_2, M_PI_2);\n\tTopoShape result;\n\tTopoBuilder b;\n\tb.MakeCompound(TopoCast::Compound(result));\n\tfor (const auto& s : shapes)\n\t{\n\t\tb.Add(result, s);\n\t}\n\tCHECK( OCCTIO::OCCTTool::Write(result, OUTPUT_PATH_PREFIX\"MakeTorus_bug445.brep\"));\n\tAMCAX::GlobalProperty props1, props2;\n\tCHECK(GetSurfaceProperties(result, props1, true, false) == Approx(831.9798765859));\n\tCHECK(GetVolumeProperties(result, props2, true, false) == Approx(255.8996));\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API MakeTorus(const Frame3& frame, double r1, double r2, double angle1, double angle2)\t @param angle2 The end angle\n\t @param angle1 The start angle\n\t @param r2 The minor radius\n\t @param r1 The major radius\n\t @param frame The local coordinate system\n\t @brief Construct from a local coordinate system, a major radius, a minor radius and two angles that forms an arc of the section circle\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <modeling/MakeTorus.hpp>\n#include <common/CartesianCoordinateSystem.hpp>\n#include <topology/TopoBuilder.hpp>\nTEST_CASE(\"bug1: MakeTorus   \", \"[modeling][MakeTorus][P1][fixbug]\")\n{\n\tstd::vector<TopoShape> shapes;\n\tconstexpr double major = 3.0;\n\tconstexpr double minor = 1.0;\n\tauto addshape = [&](double angle1, double angle2, double angle)\n\t{\n\t\tFrame3 frame(Point3(0.0, 0.0, static_cast<double>(shapes.size()) * 3.0), CartesianCoordinateSystem::DZ());\n\t\tshapes.push_back(MakeTorus(frame, major, minor, angle1, angle2, angle));\n\t};\n\taddshape(0.0, 2.0 * M_PI, 2.0 * M_PI);\n\taddshape(0.0, 2.0 * M_PI, M_PI_2);\n\taddshape(0.0, M_PI, 2.0 * M_PI);\n\taddshape(M_PI_2, 3.0 * M_PI_2, 2.0 * M_PI);\n\taddshape(M_PI, 2.0 * M_PI, 2.0 * M_PI);\n\taddshape(-M_PI_2, M_PI_2, 2.0 * M_PI);\n\taddshape(M_PI_4, M_PI_4 * 3, 2.0 * M_PI);\n\taddshape(M_PI_4 * 3, M_PI_4 * 5, 2.0 * M_PI);\n\taddshape(M_PI_4 * 5, M_PI_4 * 7, 2.0 * M_PI);\n\taddshape(-M_PI_4, M_PI_4, 2.0 * M_PI);\n\taddshape(0.0, M_PI_2, M_PI_2);\n\tTopoShape result;\n\tTopoBuilder b;\n\tb.MakeCompound(TopoCast::Compound(result));\n\tfor (const auto& s : shapes)\n\t{\n\t\tb.Add(result, s);\n\t}\n\tCHECK( OCCTIO::OCCTTool::Write(result, OUTPUT_PATH_PREFIX\"MakeTorus_bug445.brep\"));\n\tAMCAX::GlobalProperty props1, props2;\n\tCHECK(GetSurfaceProperties(result, props1, true, false) == Approx(831.9798765859));\n\tCHECK(GetVolumeProperties(result, props2, true, false) == Approx(255.8996));\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API MakeTorus(double r1, double r2, double angle1, double angle2, double angle)\t @param angle The rotation angle\n\t @param angle2 The end angle\n\t @param angle1 The start angle\n\t @param r2 The minor radius\n\t @param r1 The major radius\n\t @brief Construct from a major radius, a minor radius, two angles that forms an arc of the section circle and a rotation angle\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <modeling/MakeTorus.hpp>\n#include <common/CartesianCoordinateSystem.hpp>\n#include <topology/TopoBuilder.hpp>\nTEST_CASE(\"bug1: MakeTorus   \", \"[modeling][MakeTorus][P1][fixbug]\")\n{\n\tstd::vector<TopoShape> shapes;\n\tconstexpr double major = 3.0;\n\tconstexpr double minor = 1.0;\n\tauto addshape = [&](double angle1, double angle2, double angle)\n\t{\n\t\tFrame3 frame(Point3(0.0, 0.0, static_cast<double>(shapes.size()) * 3.0), CartesianCoordinateSystem::DZ());\n\t\tshapes.push_back(MakeTorus(frame, major, minor, angle1, angle2, angle));\n\t};\n\taddshape(0.0, 2.0 * M_PI, 2.0 * M_PI);\n\taddshape(0.0, 2.0 * M_PI, M_PI_2);\n\taddshape(0.0, M_PI, 2.0 * M_PI);\n\taddshape(M_PI_2, 3.0 * M_PI_2, 2.0 * M_PI);\n\taddshape(M_PI, 2.0 * M_PI, 2.0 * M_PI);\n\taddshape(-M_PI_2, M_PI_2, 2.0 * M_PI);\n\taddshape(M_PI_4, M_PI_4 * 3, 2.0 * M_PI);\n\taddshape(M_PI_4 * 3, M_PI_4 * 5, 2.0 * M_PI);\n\taddshape(M_PI_4 * 5, M_PI_4 * 7, 2.0 * M_PI);\n\taddshape(-M_PI_4, M_PI_4, 2.0 * M_PI);\n\taddshape(0.0, M_PI_2, M_PI_2);\n\tTopoShape result;\n\tTopoBuilder b;\n\tb.MakeCompound(TopoCast::Compound(result));\n\tfor (const auto& s : shapes)\n\t{\n\t\tb.Add(result, s);\n\t}\n\tCHECK( OCCTIO::OCCTTool::Write(result, OUTPUT_PATH_PREFIX\"MakeTorus_bug445.brep\"));\n\tAMCAX::GlobalProperty props1, props2;\n\tCHECK(GetSurfaceProperties(result, props1, true, false) == Approx(831.9798765859));\n\tCHECK(GetVolumeProperties(result, props2, true, false) == Approx(255.8996));\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API MakeTorus(double r1, double r2, double angle1, double angle2)\t @param angle2 The end angle\n\t @param angle1 The start angle\n\t @param r2 The minor radius\n\t @param r1 The major radius\n\t @brief Construct from a major radius, a minor radius and two angles that forms an arc of the section circle\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <modeling/MakeTorus.hpp>\n#include <common/CartesianCoordinateSystem.hpp>\n#include <topology/TopoBuilder.hpp>\nTEST_CASE(\"bug1: MakeTorus   \", \"[modeling][MakeTorus][P1][fixbug]\")\n{\n\tstd::vector<TopoShape> shapes;\n\tconstexpr double major = 3.0;\n\tconstexpr double minor = 1.0;\n\tauto addshape = [&](double angle1, double angle2, double angle)\n\t{\n\t\tFrame3 frame(Point3(0.0, 0.0, static_cast<double>(shapes.size()) * 3.0), CartesianCoordinateSystem::DZ());\n\t\tshapes.push_back(MakeTorus(frame, major, minor, angle1, angle2, angle));\n\t};\n\taddshape(0.0, 2.0 * M_PI, 2.0 * M_PI);\n\taddshape(0.0, 2.0 * M_PI, M_PI_2);\n\taddshape(0.0, M_PI, 2.0 * M_PI);\n\taddshape(M_PI_2, 3.0 * M_PI_2, 2.0 * M_PI);\n\taddshape(M_PI, 2.0 * M_PI, 2.0 * M_PI);\n\taddshape(-M_PI_2, M_PI_2, 2.0 * M_PI);\n\taddshape(M_PI_4, M_PI_4 * 3, 2.0 * M_PI);\n\taddshape(M_PI_4 * 3, M_PI_4 * 5, 2.0 * M_PI);\n\taddshape(M_PI_4 * 5, M_PI_4 * 7, 2.0 * M_PI);\n\taddshape(-M_PI_4, M_PI_4, 2.0 * M_PI);\n\taddshape(0.0, M_PI_2, M_PI_2);\n\tTopoShape result;\n\tTopoBuilder b;\n\tb.MakeCompound(TopoCast::Compound(result));\n\tfor (const auto& s : shapes)\n\t{\n\t\tb.Add(result, s);\n\t}\n\tCHECK( OCCTIO::OCCTTool::Write(result, OUTPUT_PATH_PREFIX\"MakeTorus_bug445.brep\"));\n\tAMCAX::GlobalProperty props1, props2;\n\tCHECK(GetSurfaceProperties(result, props1, true, false) == Approx(831.9798765859));\n\tCHECK(GetVolumeProperties(result, props2, true, false) == Approx(255.8996));\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API const TopoFace& ZMinFace()\t @return The Z-min face\n\t @brief Get the face on Z minimum\n,\n",
      "output": "#include <modeling/MakeBox.hpp>\n#include<catch.hpp>\n#include<testHelper.h>\n#include <modeling/MakeBox.hpp>\n#include <modeling/MakeCylinder.hpp>\n#include <topology/BRepExtremaProximityTool.hpp>\n#include <io/OBJTool.hpp>\n#include <topology/TopoFace.hpp>\n#include <modeling/TransformShape.hpp>\n#include <topology/TopoExplorerTool.hpp>\n#include <modeling/MakeTorus.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <topology/BRepExtremaDistShapeShape.hpp>\nusing namespace AMCAX;\nTEST_CASE(\" bug1:  \",\"[MakeBox][p1][fixbug]\")\n{\n\t\tOUTPUT_DIRECTORY(topology, OverlapFaces);\n\t\tMakeBox box(3.0, 2.0, 2.0);\n\t\tTopoShape box2 = box.Shape();\n\t\tbox.Init(4.0, 5.0, 6.0);\n\t\tTopoFace shape = box.XMinFace();\n\t\tTopoFace shape1 = box.ZMinFace();\n\t\tTopoShape shape2 = box;\n\t\tTopoShape shapeV = box;\n\t\tAMCAX::GlobalProperty prop1;\n\t\tdouble s_sahpe = GetSurfaceProperties(shape, prop1, true, false);\n\t\tdouble s_sahpe1 = GetSurfaceProperties(shape1, prop1, true, false);\n\t\tdouble s_sahpe2 = GetSurfaceProperties(shape2, prop1, true, false);\n\t\tdouble v_sahpe = GetVolumeProperties(shapeV, prop1, true, false);\n\t\tCHECK(s_sahpe == Approx(30.0).margin(1e-12));\n\t\tCHECK(s_sahpe1 == Approx(20.0).margin(1e-12));\n\t\tCHECK(s_sahpe2 == Approx(148.0).margin(1e-12));\n\t\tCHECK(v_sahpe == Approx(120.0).margin(1e-12));\n\t\tCHECK(OCCTIO::OCCTTool::Write(box, outdir + \"MakeBox.brep\"));\n\t}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API const TopoFace& XMinFace()\t @return The X-min face\n\t @brief Get the face on X minimum\n,\n",
      "output": "#include <modeling/MakeBox.hpp>\n#include<catch.hpp>\n#include<testHelper.h>\n#include <modeling/MakeBox.hpp>\n#include <modeling/MakeCylinder.hpp>\n#include <topology/BRepExtremaProximityTool.hpp>\n#include <io/OBJTool.hpp>\n#include <topology/TopoFace.hpp>\n#include <modeling/TransformShape.hpp>\n#include <topology/TopoExplorerTool.hpp>\n#include <modeling/MakeTorus.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <topology/BRepExtremaDistShapeShape.hpp>\nusing namespace AMCAX;\nTEST_CASE(\" bug1:  \",\"[MakeBox][p1][fixbug]\")\n{\n\t\tOUTPUT_DIRECTORY(topology, OverlapFaces);\n\t\tMakeBox box(3.0, 2.0, 2.0);\n\t\tTopoShape box2 = box.Shape();\n\t\tbox.Init(4.0, 5.0, 6.0);\n\t\tTopoFace shape = box.XMinFace();\n\t\tTopoFace shape1 = box.ZMinFace();\n\t\tTopoShape shape2 = box;\n\t\tTopoShape shapeV = box;\n\t\tAMCAX::GlobalProperty prop1;\n\t\tdouble s_sahpe = GetSurfaceProperties(shape, prop1, true, false);\n\t\tdouble s_sahpe1 = GetSurfaceProperties(shape1, prop1, true, false);\n\t\tdouble s_sahpe2 = GetSurfaceProperties(shape2, prop1, true, false);\n\t\tdouble v_sahpe = GetVolumeProperties(shapeV, prop1, true, false);\n\t\tCHECK(s_sahpe == Approx(30.0).margin(1e-12));\n\t\tCHECK(s_sahpe1 == Approx(20.0).margin(1e-12));\n\t\tCHECK(s_sahpe2 == Approx(148.0).margin(1e-12));\n\t\tCHECK(v_sahpe == Approx(120.0).margin(1e-12));\n\t\tCHECK(OCCTIO::OCCTTool::Write(box, outdir + \"MakeBox.brep\"));\n\t}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API MakeBox(const Frame3& frame, double dx, double dy, double dz)\t @param dx,dy,dz The size\n\t @param frame The local coordinate system\n\t @brief Construct from a local coordinate system and size\n,\n",
      "output": "#include <modeling/MakeBox.hpp>\n#include<catch.hpp>\n#include<testHelper.h>\n#include <modeling/MakeBox.hpp>\n#include <modeling/MakeCylinder.hpp>\n#include <topology/BRepExtremaProximityTool.hpp>\n#include <io/OBJTool.hpp>\n#include <topology/TopoFace.hpp>\n#include <modeling/TransformShape.hpp>\n#include <topology/TopoExplorerTool.hpp>\n#include <modeling/MakeTorus.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <topology/BRepExtremaDistShapeShape.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"case1:this is a case for MakeBox\", \"[MakeBox1]\")\n{\n\tSECTION(\"Box3\")\n\t{\n\t\tOUTPUT_DIRECTORY(topology, OverlapFaces);\n\t\tMakeBox box2(Point3(-2.0, -2.0, -2.0), Point3(2.0,2.0,2.0));\n\t\tMakeBox box3;\n\t\tbox3.Init(Point3(-2.0, -2.0, -2.0), Point3(2.0, 2.0, 2.0));\n\t\tTopoFace shape1 = box2.XMinFace();\n\t\tTopoFace shape2 = box2.XMaxFace();\n\t\tTopoFace shape3 = box2.YMinFace();\n\t\tTopoFace shape4 = box2.YMaxFace();\n\t\tTopoFace shape5 = box2.ZMinFace();\n\t\tTopoFace shape6 = box2.ZMaxFace();\n\t\tTopoShape shape = box2;\n\t\tTopoFace shape_1 = box3.XMinFace();\n\t\tTopoFace shape_2 = box3.XMaxFace();\n\t\tTopoFace shape_3 = box3.YMinFace();\n\t\tTopoFace shape_4 = box3.YMaxFace();\n\t\tTopoFace shape_5 = box3.ZMinFace();\n\t\tTopoFace shape_6 = box3.ZMaxFace();\n\t\tAMCAX::GlobalProperty prop1;\n\t\tdouble s_sahpe1 = GetSurfaceProperties(shape1, prop1, true, false);\n\t\tdouble s_sahpe2 = GetSurfaceProperties(shape2, prop1, true, false);\n\t\tdouble s_sahpe3 = GetSurfaceProperties(shape3, prop1, true, false);\n\t\tdouble s_sahpe4 = GetSurfaceProperties(shape4, prop1, true, false);\n\t\tdouble s_sahpe5 = GetSurfaceProperties(shape5, prop1, true, false);\n\t\tdouble s_sahpe6 = GetSurfaceProperties(shape6, prop1, true, false);\n\t\tdouble s_sahpe = GetSurfaceProperties(shape, prop1, true, false);\n\t\tdouble v_sahpe = GetVolumeProperties(shape, prop1, true, false);\n\t\tBRepClassificationTools brep;\n\t\tbool r1 = brep.IsPointInOnFace(shape1, Point3(-2.0, 0.0, 0.0), -1.0);\n\t\tbool r2 = brep.IsPointInOnFace(shape2, Point3(2.0, 0.0, 0.0), -1.0);\n\t\tbool r3 = brep.IsPointInOnFace(shape3, Point3(0.0, -2.0, 0.0), -1.0);\n\t\tbool r33 = brep.IsPointInOnFace(shape3, Point3(1.0, 0.5, 3.0), -1.0);\n\t\tbool r4 = brep.IsPointInOnFace(shape4, Point3(0.0, 2.0, 0.0), -1.0);\n\t\tbool r5 = brep.IsPointInOnFace(shape5, Point3(0.0, 0.0, -2.0), -1.0);\n\t\tbool r6 = brep.IsPointInOnFace(shape6, Point3(0.0, 0.0, 2.0), -1.0);\n\t\tdouble s_shape_1 = GetSurfaceProperties(shape_1, prop1, true, false);\n\t\tdouble s_shape_2 = GetSurfaceProperties(shape_2, prop1, true, false);\n\t\tdouble s_shape_3 = GetSurfaceProperties(shape_3, prop1, true, false);\n\t\tdouble s_shape_4 = GetSurfaceProperties(shape_4, prop1, true, false);\n\t\tdouble s_shape_5 = GetSurfaceProperties(shape_5, prop1, true, false);\n\t\tdouble s_shape_6 = GetSurfaceProperties(shape_6, prop1, true, false);\n\t\tbool r_1 = brep.IsPointInOnFace(shape_1, Point3(-2.0, 0.0, 0.0), -1.0);\n\t\tbool r_2 = brep.IsPointInOnFace(shape_2, Point3(2.0, 0.0, 0.0), -1.0);\n\t\tbool r_3 = brep.IsPointInOnFace(shape_3, Point3(0.0, -2.0, 0.0), -1.0);\n\t\tbool r_33 = brep.IsPointInOnFace(shape_3, Point3(1.0, 0.5, 3.0), -1.0);\n\t\tbool r_4 = brep.IsPointInOnFace(shape_4, Point3(0.0, 2.0, 0.0), -1.0);\n\t\tbool r_5 = brep.IsPointInOnFace(shape_5, Point3(0.0, 0.0, -2.0), -1.0);\n\t\tbool r_6 = brep.IsPointInOnFace(shape_6, Point3(0.0, 0.0, 2.0), -1.0);\n\t\tCHECK(s_sahpe1 == Approx(16.0).margin(1e-12));\n\t\tCHECK(s_sahpe2 == Approx(16.0).margin(1e-12));\n\t\tCHECK(s_sahpe3 == Approx(16.0).margin(1e-12));\n\t\tCHECK(s_sahpe4 == Approx(16.0).margin(1e-12));\n\t\tCHECK(s_sahpe5 == Approx(16.0).margin(1e-12));\n\t\tCHECK(s_sahpe6 == Approx(16.0).margin(1e-12));\n\t\tCHECK(v_sahpe == Approx(64.0).margin(1e-12));\n\t\tCHECK(s_sahpe == s_sahpe1 + s_sahpe2 + s_sahpe3 + s_sahpe4 + s_sahpe5 + s_sahpe6);\n\t\tCHECK(s_sahpe1 == s_shape_1);\n\t\tCHECK(s_sahpe2 == s_shape_2);\n\t\tCHECK(s_sahpe3 == s_shape_3);\n\t\tCHECK(s_sahpe4 == s_shape_4);\n\t\tCHECK(s_sahpe5 == s_shape_5);\n\t\tCHECK(s_sahpe6 == s_shape_6);\n\t\tCHECK(r1 == true);\n\t\tCHECK(r2 == true);\n\t\tCHECK(r3 == true);\n\t\tCHECK(r33 == false);\n\t\tCHECK(r4 == true);\n\t\tCHECK(r5 == true);\n\t\tCHECK(r6 == true);\n\t\tCHECK(r_1 == true);\n\t\tCHECK(r_2 == true);\n\t\tCHECK(r_3 == true);\n\t\tCHECK(r_33 == false);\n\t\tCHECK(r_4 == true);\n\t\tCHECK(r_5 == true);\n\t\tCHECK(r_6 == true);\n\t\tCHECK(OCCTIO::OCCTTool::Write(box2, outdir + \"MakeBox3.brep\"));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API MakeBox(const Point3& p1, const Point3& p2)\t @param p2 The second point\n\t @param p1 The first point\n\t @brief Construct from two diagonal corner points\n,\n",
      "output": "#include <modeling/MakeBox.hpp>\n#include<catch.hpp>\n#include<testHelper.h>\n#include <modeling/MakeBox.hpp>\n#include <modeling/MakeCylinder.hpp>\n#include <topology/BRepExtremaProximityTool.hpp>\n#include <io/OBJTool.hpp>\n#include <topology/TopoFace.hpp>\n#include <modeling/TransformShape.hpp>\n#include <topology/TopoExplorerTool.hpp>\n#include <modeling/MakeTorus.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <topology/BRepExtremaDistShapeShape.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"case1:this is a case for MakeBox\", \"[MakeBox1]\")\n{\n\tSECTION(\"Box3\")\n\t{\n\t\tOUTPUT_DIRECTORY(topology, OverlapFaces);\n\t\tMakeBox box2(Point3(-2.0, -2.0, -2.0), Point3(2.0,2.0,2.0));\n\t\tMakeBox box3;\n\t\tbox3.Init(Point3(-2.0, -2.0, -2.0), Point3(2.0, 2.0, 2.0));\n\t\tTopoFace shape1 = box2.XMinFace();\n\t\tTopoFace shape2 = box2.XMaxFace();\n\t\tTopoFace shape3 = box2.YMinFace();\n\t\tTopoFace shape4 = box2.YMaxFace();\n\t\tTopoFace shape5 = box2.ZMinFace();\n\t\tTopoFace shape6 = box2.ZMaxFace();\n\t\tTopoShape shape = box2;\n\t\tTopoFace shape_1 = box3.XMinFace();\n\t\tTopoFace shape_2 = box3.XMaxFace();\n\t\tTopoFace shape_3 = box3.YMinFace();\n\t\tTopoFace shape_4 = box3.YMaxFace();\n\t\tTopoFace shape_5 = box3.ZMinFace();\n\t\tTopoFace shape_6 = box3.ZMaxFace();\n\t\tAMCAX::GlobalProperty prop1;\n\t\tdouble s_sahpe1 = GetSurfaceProperties(shape1, prop1, true, false);\n\t\tdouble s_sahpe2 = GetSurfaceProperties(shape2, prop1, true, false);\n\t\tdouble s_sahpe3 = GetSurfaceProperties(shape3, prop1, true, false);\n\t\tdouble s_sahpe4 = GetSurfaceProperties(shape4, prop1, true, false);\n\t\tdouble s_sahpe5 = GetSurfaceProperties(shape5, prop1, true, false);\n\t\tdouble s_sahpe6 = GetSurfaceProperties(shape6, prop1, true, false);\n\t\tdouble s_sahpe = GetSurfaceProperties(shape, prop1, true, false);\n\t\tdouble v_sahpe = GetVolumeProperties(shape, prop1, true, false);\n\t\tBRepClassificationTools brep;\n\t\tbool r1 = brep.IsPointInOnFace(shape1, Point3(-2.0, 0.0, 0.0), -1.0);\n\t\tbool r2 = brep.IsPointInOnFace(shape2, Point3(2.0, 0.0, 0.0), -1.0);\n\t\tbool r3 = brep.IsPointInOnFace(shape3, Point3(0.0, -2.0, 0.0), -1.0);\n\t\tbool r33 = brep.IsPointInOnFace(shape3, Point3(1.0, 0.5, 3.0), -1.0);\n\t\tbool r4 = brep.IsPointInOnFace(shape4, Point3(0.0, 2.0, 0.0), -1.0);\n\t\tbool r5 = brep.IsPointInOnFace(shape5, Point3(0.0, 0.0, -2.0), -1.0);\n\t\tbool r6 = brep.IsPointInOnFace(shape6, Point3(0.0, 0.0, 2.0), -1.0);\n\t\tdouble s_shape_1 = GetSurfaceProperties(shape_1, prop1, true, false);\n\t\tdouble s_shape_2 = GetSurfaceProperties(shape_2, prop1, true, false);\n\t\tdouble s_shape_3 = GetSurfaceProperties(shape_3, prop1, true, false);\n\t\tdouble s_shape_4 = GetSurfaceProperties(shape_4, prop1, true, false);\n\t\tdouble s_shape_5 = GetSurfaceProperties(shape_5, prop1, true, false);\n\t\tdouble s_shape_6 = GetSurfaceProperties(shape_6, prop1, true, false);\n\t\tbool r_1 = brep.IsPointInOnFace(shape_1, Point3(-2.0, 0.0, 0.0), -1.0);\n\t\tbool r_2 = brep.IsPointInOnFace(shape_2, Point3(2.0, 0.0, 0.0), -1.0);\n\t\tbool r_3 = brep.IsPointInOnFace(shape_3, Point3(0.0, -2.0, 0.0), -1.0);\n\t\tbool r_33 = brep.IsPointInOnFace(shape_3, Point3(1.0, 0.5, 3.0), -1.0);\n\t\tbool r_4 = brep.IsPointInOnFace(shape_4, Point3(0.0, 2.0, 0.0), -1.0);\n\t\tbool r_5 = brep.IsPointInOnFace(shape_5, Point3(0.0, 0.0, -2.0), -1.0);\n\t\tbool r_6 = brep.IsPointInOnFace(shape_6, Point3(0.0, 0.0, 2.0), -1.0);\n\t\tCHECK(s_sahpe1 == Approx(16.0).margin(1e-12));\n\t\tCHECK(s_sahpe2 == Approx(16.0).margin(1e-12));\n\t\tCHECK(s_sahpe3 == Approx(16.0).margin(1e-12));\n\t\tCHECK(s_sahpe4 == Approx(16.0).margin(1e-12));\n\t\tCHECK(s_sahpe5 == Approx(16.0).margin(1e-12));\n\t\tCHECK(s_sahpe6 == Approx(16.0).margin(1e-12));\n\t\tCHECK(v_sahpe == Approx(64.0).margin(1e-12));\n\t\tCHECK(s_sahpe == s_sahpe1 + s_sahpe2 + s_sahpe3 + s_sahpe4 + s_sahpe5 + s_sahpe6);\n\t\tCHECK(s_sahpe1 == s_shape_1);\n\t\tCHECK(s_sahpe2 == s_shape_2);\n\t\tCHECK(s_sahpe3 == s_shape_3);\n\t\tCHECK(s_sahpe4 == s_shape_4);\n\t\tCHECK(s_sahpe5 == s_shape_5);\n\t\tCHECK(s_sahpe6 == s_shape_6);\n\t\tCHECK(r1 == true);\n\t\tCHECK(r2 == true);\n\t\tCHECK(r3 == true);\n\t\tCHECK(r33 == false);\n\t\tCHECK(r4 == true);\n\t\tCHECK(r5 == true);\n\t\tCHECK(r6 == true);\n\t\tCHECK(r_1 == true);\n\t\tCHECK(r_2 == true);\n\t\tCHECK(r_3 == true);\n\t\tCHECK(r_33 == false);\n\t\tCHECK(r_4 == true);\n\t\tCHECK(r_5 == true);\n\t\tCHECK(r_6 == true);\n\t\tCHECK(OCCTIO::OCCTTool::Write(box2, outdir + \"MakeBox3.brep\"));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API MakeBox(const Point3& p, double dx, double dy, double dz)\t @param dx,dy,dz The size\n\t @param p The corner point\n\t @brief Construct from a corner point and its size\n,\n",
      "output": "#include <modeling/MakeBox.hpp>\n#include<catch.hpp>\n#include<testHelper.h>\n#include <modeling/MakeBox.hpp>\n#include <modeling/MakeCylinder.hpp>\n#include <topology/BRepExtremaProximityTool.hpp>\n#include <io/OBJTool.hpp>\n#include <topology/TopoFace.hpp>\n#include <modeling/TransformShape.hpp>\n#include <topology/TopoExplorerTool.hpp>\n#include <modeling/MakeTorus.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <topology/BRepExtremaDistShapeShape.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"case1:this is a case for MakeBox\", \"[MakeBox1]\")\n{\n\tSECTION(\"Box3\")\n\t{\n\t\tOUTPUT_DIRECTORY(topology, OverlapFaces);\n\t\tMakeBox box2(Point3(-2.0, -2.0, -2.0), Point3(2.0,2.0,2.0));\n\t\tMakeBox box3;\n\t\tbox3.Init(Point3(-2.0, -2.0, -2.0), Point3(2.0, 2.0, 2.0));\n\t\tTopoFace shape1 = box2.XMinFace();\n\t\tTopoFace shape2 = box2.XMaxFace();\n\t\tTopoFace shape3 = box2.YMinFace();\n\t\tTopoFace shape4 = box2.YMaxFace();\n\t\tTopoFace shape5 = box2.ZMinFace();\n\t\tTopoFace shape6 = box2.ZMaxFace();\n\t\tTopoShape shape = box2;\n\t\tTopoFace shape_1 = box3.XMinFace();\n\t\tTopoFace shape_2 = box3.XMaxFace();\n\t\tTopoFace shape_3 = box3.YMinFace();\n\t\tTopoFace shape_4 = box3.YMaxFace();\n\t\tTopoFace shape_5 = box3.ZMinFace();\n\t\tTopoFace shape_6 = box3.ZMaxFace();\n\t\tAMCAX::GlobalProperty prop1;\n\t\tdouble s_sahpe1 = GetSurfaceProperties(shape1, prop1, true, false);\n\t\tdouble s_sahpe2 = GetSurfaceProperties(shape2, prop1, true, false);\n\t\tdouble s_sahpe3 = GetSurfaceProperties(shape3, prop1, true, false);\n\t\tdouble s_sahpe4 = GetSurfaceProperties(shape4, prop1, true, false);\n\t\tdouble s_sahpe5 = GetSurfaceProperties(shape5, prop1, true, false);\n\t\tdouble s_sahpe6 = GetSurfaceProperties(shape6, prop1, true, false);\n\t\tdouble s_sahpe = GetSurfaceProperties(shape, prop1, true, false);\n\t\tdouble v_sahpe = GetVolumeProperties(shape, prop1, true, false);\n\t\tBRepClassificationTools brep;\n\t\tbool r1 = brep.IsPointInOnFace(shape1, Point3(-2.0, 0.0, 0.0), -1.0);\n\t\tbool r2 = brep.IsPointInOnFace(shape2, Point3(2.0, 0.0, 0.0), -1.0);\n\t\tbool r3 = brep.IsPointInOnFace(shape3, Point3(0.0, -2.0, 0.0), -1.0);\n\t\tbool r33 = brep.IsPointInOnFace(shape3, Point3(1.0, 0.5, 3.0), -1.0);\n\t\tbool r4 = brep.IsPointInOnFace(shape4, Point3(0.0, 2.0, 0.0), -1.0);\n\t\tbool r5 = brep.IsPointInOnFace(shape5, Point3(0.0, 0.0, -2.0), -1.0);\n\t\tbool r6 = brep.IsPointInOnFace(shape6, Point3(0.0, 0.0, 2.0), -1.0);\n\t\tdouble s_shape_1 = GetSurfaceProperties(shape_1, prop1, true, false);\n\t\tdouble s_shape_2 = GetSurfaceProperties(shape_2, prop1, true, false);\n\t\tdouble s_shape_3 = GetSurfaceProperties(shape_3, prop1, true, false);\n\t\tdouble s_shape_4 = GetSurfaceProperties(shape_4, prop1, true, false);\n\t\tdouble s_shape_5 = GetSurfaceProperties(shape_5, prop1, true, false);\n\t\tdouble s_shape_6 = GetSurfaceProperties(shape_6, prop1, true, false);\n\t\tbool r_1 = brep.IsPointInOnFace(shape_1, Point3(-2.0, 0.0, 0.0), -1.0);\n\t\tbool r_2 = brep.IsPointInOnFace(shape_2, Point3(2.0, 0.0, 0.0), -1.0);\n\t\tbool r_3 = brep.IsPointInOnFace(shape_3, Point3(0.0, -2.0, 0.0), -1.0);\n\t\tbool r_33 = brep.IsPointInOnFace(shape_3, Point3(1.0, 0.5, 3.0), -1.0);\n\t\tbool r_4 = brep.IsPointInOnFace(shape_4, Point3(0.0, 2.0, 0.0), -1.0);\n\t\tbool r_5 = brep.IsPointInOnFace(shape_5, Point3(0.0, 0.0, -2.0), -1.0);\n\t\tbool r_6 = brep.IsPointInOnFace(shape_6, Point3(0.0, 0.0, 2.0), -1.0);\n\t\tCHECK(s_sahpe1 == Approx(16.0).margin(1e-12));\n\t\tCHECK(s_sahpe2 == Approx(16.0).margin(1e-12));\n\t\tCHECK(s_sahpe3 == Approx(16.0).margin(1e-12));\n\t\tCHECK(s_sahpe4 == Approx(16.0).margin(1e-12));\n\t\tCHECK(s_sahpe5 == Approx(16.0).margin(1e-12));\n\t\tCHECK(s_sahpe6 == Approx(16.0).margin(1e-12));\n\t\tCHECK(v_sahpe == Approx(64.0).margin(1e-12));\n\t\tCHECK(s_sahpe == s_sahpe1 + s_sahpe2 + s_sahpe3 + s_sahpe4 + s_sahpe5 + s_sahpe6);\n\t\tCHECK(s_sahpe1 == s_shape_1);\n\t\tCHECK(s_sahpe2 == s_shape_2);\n\t\tCHECK(s_sahpe3 == s_shape_3);\n\t\tCHECK(s_sahpe4 == s_shape_4);\n\t\tCHECK(s_sahpe5 == s_shape_5);\n\t\tCHECK(s_sahpe6 == s_shape_6);\n\t\tCHECK(r1 == true);\n\t\tCHECK(r2 == true);\n\t\tCHECK(r3 == true);\n\t\tCHECK(r33 == false);\n\t\tCHECK(r4 == true);\n\t\tCHECK(r5 == true);\n\t\tCHECK(r6 == true);\n\t\tCHECK(r_1 == true);\n\t\tCHECK(r_2 == true);\n\t\tCHECK(r_3 == true);\n\t\tCHECK(r_33 == false);\n\t\tCHECK(r_4 == true);\n\t\tCHECK(r_5 == true);\n\t\tCHECK(r_6 == true);\n\t\tCHECK(OCCTIO::OCCTTool::Write(box2, outdir + \"MakeBox3.brep\"));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API MakeBox(double dx, double dy, double dz)\t @param dx,dy,dz The size\n\t @brief Construct from its size in x, y, z directions\n,\n",
      "output": "#include <modeling/MakeBox.hpp>\n#include<catch.hpp>\n#include<testHelper.h>\n#include <modeling/MakeBox.hpp>\n#include <modeling/MakeCylinder.hpp>\n#include <topology/BRepExtremaProximityTool.hpp>\n#include <io/OBJTool.hpp>\n#include <topology/TopoFace.hpp>\n#include <modeling/TransformShape.hpp>\n#include <topology/TopoExplorerTool.hpp>\n#include <modeling/MakeTorus.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <topology/BRepExtremaDistShapeShape.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"case1:this is a case for MakeBox\", \"[MakeBox1]\")\n{\n\tSECTION(\"Box1\") {\n\t\tOUTPUT_DIRECTORY(topology, OverlapFaces);\n\t\tMakeBox box(3.0, 2.0,2.0);\n\t\tTopoShape box2= box.Shape();\n\t\tbox.Init(4.0, 5.0, 6.0);\n\t\tTopoFace shape = box.XMinFace(); \n\t\tTopoFace shape1 = box.ZMinFace(); \n\t\tTopoShape shape2 = box; \n\t\tTopoShape shapeV = box;\n\t\tAMCAX::GlobalProperty prop1;\n\t\tdouble s_sahpe = GetSurfaceProperties(shape, prop1, true, false);\n\t\tdouble s_sahpe1 = GetSurfaceProperties(shape1, prop1, true, false);\n\t\tdouble s_sahpe2 = GetSurfaceProperties(shape2, prop1, true, false);\n\t\tdouble v_sahpe = GetVolumeProperties(shapeV, prop1, true, false);\n\t\tCHECK(s_sahpe == Approx(30.0).margin(1e-12));\n\t\tCHECK(s_sahpe1 == Approx(20.0).margin(1e-12));\n\t\tCHECK(s_sahpe2 == Approx(148.0).margin(1e-12));\n\t\tCHECK(v_sahpe == Approx(120.0).margin(1e-12));\n\t\tCHECK( OCCTIO::OCCTTool::Write(box, outdir + \"MakeBox1.brep\"));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API GeneralTransformShape(const TopoShape& s, const GeneralTransformation3& t, bool copy = false)\t @param copy Whether the geometry of the shape is copied\n\t @param t The general transformation\n\t @param s The shape\n\t @brief Transform a shape by a general transformation\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <common/PointT.hpp>\n#include <modeling/MakeSphere.hpp>\n#include <modeling/TransformShape.hpp>\n#include <topomesh/BRepMeshIncrementalMesh.hpp>\n#include <modeling/MakeShapeTool.hpp>\n#include <common/TransformationT.hpp>\n#include <common/CartesianCoordinateSystem.hpp>\n#include <common/GeneralTransformationT.hpp>\n#include <modeling/GeneralTransformShape.hpp>\n#include <geometry/GlobalProperty.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <topology/BRepGlobalProperty.hpp>\n#include <geometry/Geom3BSplineCurve.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <topology/TopoTool.hpp>\n#include <topology/BRepAdaptorCurve3.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"bug1: GeneralTransformShape  \", \"[modeling][GeneralTransformShape][fixbug]\") {\n\tTopoShape s = MakeSphere(1.0);\n\tBRepMeshIncrementalMesh mesher(s, 0.005, true);\n\tMakeShapeTool::EnsureNormalConsistency(s);\n\tGeneralTransformation3 tr;\n\ttr.SetAffinity(Frame3(), 5.0);\n\ts = GeneralTransformShape(s, tr);\n\tCHECK(s.Type() == AMCAX::ShapeType::Solid);\n\tCHECK(s.IsNull() == false);\n\tGlobalProperty prop;\n\tBRepGlobalProperty::VolumeProperties(s, prop);\n\tCHECK(prop.Mass() == Approx(20.934791259).epsilon(1e-11));\n\tPoint3 vP = prop.CenterOfMass();\n#ifndef WIN_CASE\n\tCHECK(vP.X() == Approx(0.0).margin(1e-3));\n\tCHECK(vP.Y() == Approx(0.0).margin(1e-12));\n\tCHECK(vP.Z() == Approx(0.0).margin(1e-12));\n#else\n\tCHECK(vP.X() == Approx(-2.2218808037914858e-04).epsilon(1e-12));\n\tCHECK(vP.Y() == Approx(-1.0782779568197278e-16).epsilon(1e-12));\n\tCHECK(vP.Z() == Approx(-1.6920954211916623e-16).epsilon(1e-12));\n#endif\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API explicit GeneralTransformShape(const GeneralTransformation3& t)\t @param t The general transformation\n\t @brief Construct from a general transformation\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <common/PointT.hpp>\n#include <modeling/MakeSphere.hpp>\n#include <modeling/TransformShape.hpp>\n#include <topomesh/BRepMeshIncrementalMesh.hpp>\n#include <modeling/MakeShapeTool.hpp>\n#include <common/TransformationT.hpp>\n#include <common/CartesianCoordinateSystem.hpp>\n#include <common/GeneralTransformationT.hpp>\n#include <modeling/GeneralTransformShape.hpp>\n#include <geometry/GlobalProperty.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <topology/BRepGlobalProperty.hpp>\n#include <geometry/Geom3BSplineCurve.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <topology/TopoTool.hpp>\n#include <topology/BRepAdaptorCurve3.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"bug1: GeneralTransformShape  \", \"[modeling][GeneralTransformShape][fixbug]\") {\n\tTopoShape s = MakeSphere(1.0);\n\tBRepMeshIncrementalMesh mesher(s, 0.005, true);\n\tMakeShapeTool::EnsureNormalConsistency(s);\n\tGeneralTransformation3 tr;\n\ttr.SetAffinity(Frame3(), 5.0);\n\ts = GeneralTransformShape(s, tr);\n\tCHECK(s.Type() == AMCAX::ShapeType::Solid);\n\tCHECK(s.IsNull() == false);\n\tGlobalProperty prop;\n\tBRepGlobalProperty::VolumeProperties(s, prop);\n\tCHECK(prop.Mass() == Approx(20.934791259).epsilon(1e-11));\n\tPoint3 vP = prop.CenterOfMass();\n#ifndef WIN_CASE\n\tCHECK(vP.X() == Approx(0.0).margin(1e-3));\n\tCHECK(vP.Y() == Approx(0.0).margin(1e-12));\n\tCHECK(vP.Z() == Approx(0.0).margin(1e-12));\n#else\n\tCHECK(vP.X() == Approx(-2.2218808037914858e-04).epsilon(1e-12));\n\tCHECK(vP.Y() == Approx(-1.0782779568197278e-16).epsilon(1e-12));\n\tCHECK(vP.Z() == Approx(-1.6920954211916623e-16).epsilon(1e-12));\n#endif\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAXMeshing_API std::vector<InterSegments> & getInterSegments(),\n",
      "output": "#include<catch.hpp>\n#include<testHelperBase.h>\n#define AMCAXMeshing_Enable_EigenTraits\n#define AMCAXMeshing_Enable_CommonTraits\n#define AMCAXMeshing_Disable_StandardTraits\n#include \"mesh/TriSoup.hpp\"\n#include \"meshModeling/MeshBoolean.hpp\"\n#include \"mesh/io/OBJReader.hpp\"\n#include \"mesh/io/OBJWriter.hpp\"\n#include \"mesh/io/STLReader.hpp\"\n#include \"mesh/io/STLWriter.hpp\"\n#ifdef AMCAXMeshing_Enable_CommonTraits\nusing TriSoupTraits = AMCAX::Meshing::Mesh::TriSoupTraits_Coord;\n#endif\nusing EIAC = AMCAX::Meshing::Geometry::EIAC;\nusing Points = typename TriSoupTraits::Points;\nusing Triangles = typename TriSoupTraits::Triangles;\nusing OBJReader = AMCAX::Meshing::Mesh::OBJReader<TriSoupTraits>;\nusing OBJWriter = AMCAX::Meshing::Mesh::OBJWriter<TriSoupTraits>;\nusing STLReader = AMCAX::Meshing::Mesh::STLReader<TriSoupTraits>;\nusing STLWriter = AMCAX::Meshing::Mesh::STLWriter<TriSoupTraits>;\nusing IOOptions = AMCAX::Meshing::Mesh::IOOptions;\nusing MeshBoolean = AMCAX::Meshing::Boolean::MeshBoolean<EIAC, TriSoupTraits>;\ntemplate <typename TriIndexT>\nstruct InterSegments\n{\n    using ti_t = TriIndexT;\n    std::vector<ti_t> vertex_ids;\n    bool closed;\n};\nvoid read_mesh2(const std::string& filename, Points& points,\n    Triangles& triangles, IOOptions& io_options)\n{\n    if (AMCAX::Meshing::ends_with(filename, \".obj\"))\n    {\n        OBJReader reader;\n        reader.read(filename, io_options);\n        points = std::move(reader.m_points);\n        triangles = std::move(reader.m_triangles);\n    }\n    else if (AMCAX::Meshing::ends_with(filename, \".stl\"))\n    {\n        STLReader reader;\n        reader.read(filename, io_options);\n        points = std::move(reader.m_points);\n        triangles = std::move(reader.m_triangles);\n    }\n}\nvoid write_mesh2(const std::string& filename, const Points& points,\n    const Triangles& triangles, IOOptions& io_options)\n{\n    if (AMCAX::Meshing::ends_with(filename, \".obj\"))\n    {\n        OBJWriter writer;\n        writer.m_points = std::move(points);\n        writer.m_triangles = std::move(triangles);\n        writer.write(filename, io_options, 10);\n    }\n    else if (AMCAX::Meshing::ends_with(filename, \".stl\"))\n    {\n        STLWriter writer;\n        writer.m_points = std::move(points);\n        writer.m_triangles = std::move(triangles);\n        writer.write(filename, io_options, 10);\n    }\n};\nTEST_CASE(\"bug1: MeshBoolean_InterSegments \", \"[meshModeling][MeshBoolean_InterSegments][bug]\")\n{\n    OUTPUT_DIRECTORY(MeshBoolean, InterSegments_bug);\n    IOOptions io_options;\n    io_options.vertex_has_point = true;\n    Points      points1, points2, points3, points11, points22, points33, result_points, result_points11;\n    Triangles   triangles1, triangles2, triangles3, triangles11, triangles22, triangles33, result_triangles, result_triangles11;\n    read_mesh2(INPUT_PATH_PREFIX\"./meshModeling_data/MeshBoolean_data/cow1.stl\", points1, triangles1, io_options);\n    read_mesh2(INPUT_PATH_PREFIX\"./meshModeling_data/MeshBoolean_data/bunny1.stl\", points2, triangles2, io_options);\n    read_mesh2(INPUT_PATH_PREFIX\"./meshModeling_data/MeshBoolean_data/cow1.stl\", points3, triangles3, io_options);\n    read_mesh2(INPUT_PATH_PREFIX\"./meshModeling_data/MeshBoolean_data/cow1.obj\", points11, triangles11, io_options);\n    read_mesh2(INPUT_PATH_PREFIX\"./meshModeling_data/MeshBoolean_data/bunny1.obj\", points22, triangles22, io_options);\n    read_mesh2(INPUT_PATH_PREFIX\"./meshModeling_data/MeshBoolean_data/cow1.obj\", points33, triangles33, io_options);\n    MeshBoolean boolean(true);\n    MeshBoolean boolean11(true);\n    boolean.addTriMeshAsInput(points1, triangles1);\n    boolean.addTriMeshAsInput(points2, triangles2);\n    boolean.addTriMeshAsInput(points3, triangles3);\n    boolean.setTriMeshAsOutput(result_points, result_triangles);\n    boolean.computeLabels();\n    boolean.computeInterSegments();\n    boolean.Subtraction();\n    boolean11.addTriMeshAsInput(points11, triangles11);\n    boolean11.addTriMeshAsInput(points22, triangles22);\n    boolean11.addTriMeshAsInput(points33, triangles33);\n    boolean11.setTriMeshAsOutput(result_points11, result_triangles11);\n    boolean11.computeLabels();\n    boolean11.computeInterSegments();\n    boolean11.Subtraction();\n    const auto& inter_segs = boolean.getInterSegments();\n    const auto& inter_segs11 = boolean11.getInterSegments();\n    for (size_t s_id = 0; s_id < inter_segs.size(); ++s_id)\n    {\n        std::ofstream ofs(outdir + \"stl_\"+std::to_string(s_id) + \".obj\");\n        size_t v_num = inter_segs[s_id].vertex_ids.size();\n        ofs << \"# v_num: \" << v_num << std::endl;\n        size_t l_num = inter_segs[s_id].closed ? inter_segs[s_id].vertex_ids.size() : inter_segs[s_id].vertex_ids.size() - 1;\n        ofs << \"# l_num: \" << l_num << std::endl;\n        ofs << std::endl;\n        for (auto v_id : inter_segs[s_id].vertex_ids)\n        {\n            ofs << \"v \" << result_points[v_id].x() << \" \" << result_points[v_id].y() << \" \" << result_points[v_id].z() << std::endl;\n        }\n        ofs << std::endl;\n        for (size_t i = 0; i < inter_segs[s_id].vertex_ids.size() - 1; ++i)\n        {\n            ofs << \"l \" << i + 1 << \" \" << i + 2 << std::endl;\n        }\n        if (inter_segs[s_id].closed)\n        {\n            ofs << \"l \" << inter_segs[s_id].vertex_ids.size() << \" \" << 1 << std::endl;\n        }\n        ofs.close();\n        write_mesh2(outdir + \"InterSubtraction.stl\", result_points, result_triangles, io_options);\n    }\n    for (size_t s_id = 0; s_id < inter_segs11.size(); ++s_id)\n    {\n        std::ofstream ofs(outdir + \"obj_\"+std::to_string(s_id) + \".obj\");\n        size_t v_num = inter_segs11[s_id].vertex_ids.size();\n        ofs << \"# v_num: \" << v_num << std::endl;\n        size_t l_num = inter_segs11[s_id].closed ? inter_segs11[s_id].vertex_ids.size() : inter_segs11[s_id].vertex_ids.size() - 1;\n        ofs << \"# l_num: \" << l_num << std::endl;\n        ofs << std::endl;\n        for (auto v_id : inter_segs11[s_id].vertex_ids)\n        {\n            ofs << \"v \" << result_points11[v_id].x() << \" \" << result_points11[v_id].y() << \" \" << result_points11[v_id].z() << std::endl;\n        }\n        ofs << std::endl;\n        for (size_t i = 0; i < inter_segs11[s_id].vertex_ids.size() - 1; ++i)\n        {\n            ofs << \"l \" << i + 1 << \" \" << i + 2 << std::endl;\n        }\n        if (inter_segs11[s_id].closed)\n        {\n            ofs << \"l \" << inter_segs11[s_id].vertex_ids.size() << \" \" << 1 << std::endl;\n        }\n        ofs.close();\n        write_mesh2(outdir + \"InterSubtraction.obj\", result_points11, result_triangles11, io_options);\n    }\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAXMeshing_API void computeInterSegments()\t after computing labels.\n\t @brief In order to obtain the intersection segments, we need call this\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelperBase.h>\n#define AMCAXMeshing_Enable_EigenTraits\n#define AMCAXMeshing_Enable_CommonTraits\n#define AMCAXMeshing_Disable_StandardTraits\n#include \"mesh/TriSoup.hpp\"\n#include \"meshModeling/MeshBoolean.hpp\"\n#include \"mesh/io/OBJReader.hpp\"\n#include \"mesh/io/OBJWriter.hpp\"\n#include \"mesh/io/STLReader.hpp\"\n#include \"mesh/io/STLWriter.hpp\"\n#ifdef AMCAXMeshing_Enable_CommonTraits\nusing TriSoupTraits = AMCAX::Meshing::Mesh::TriSoupTraits_Coord;\n#endif\nusing EIAC = AMCAX::Meshing::Geometry::EIAC;\nusing Points = typename TriSoupTraits::Points;\nusing Triangles = typename TriSoupTraits::Triangles;\nusing OBJReader = AMCAX::Meshing::Mesh::OBJReader<TriSoupTraits>;\nusing OBJWriter = AMCAX::Meshing::Mesh::OBJWriter<TriSoupTraits>;\nusing STLReader = AMCAX::Meshing::Mesh::STLReader<TriSoupTraits>;\nusing STLWriter = AMCAX::Meshing::Mesh::STLWriter<TriSoupTraits>;\nusing IOOptions = AMCAX::Meshing::Mesh::IOOptions;\nusing MeshBoolean = AMCAX::Meshing::Boolean::MeshBoolean<EIAC, TriSoupTraits>;\ntemplate <typename TriIndexT>\nstruct InterSegments\n{\n    using ti_t = TriIndexT;\n    std::vector<ti_t> vertex_ids;\n    bool closed;\n};\nvoid read_mesh2(const std::string& filename, Points& points,\n    Triangles& triangles, IOOptions& io_options)\n{\n    if (AMCAX::Meshing::ends_with(filename, \".obj\"))\n    {\n        OBJReader reader;\n        reader.read(filename, io_options);\n        points = std::move(reader.m_points);\n        triangles = std::move(reader.m_triangles);\n    }\n    else if (AMCAX::Meshing::ends_with(filename, \".stl\"))\n    {\n        STLReader reader;\n        reader.read(filename, io_options);\n        points = std::move(reader.m_points);\n        triangles = std::move(reader.m_triangles);\n    }\n}\nvoid write_mesh2(const std::string& filename, const Points& points,\n    const Triangles& triangles, IOOptions& io_options)\n{\n    if (AMCAX::Meshing::ends_with(filename, \".obj\"))\n    {\n        OBJWriter writer;\n        writer.m_points = std::move(points);\n        writer.m_triangles = std::move(triangles);\n        writer.write(filename, io_options, 10);\n    }\n    else if (AMCAX::Meshing::ends_with(filename, \".stl\"))\n    {\n        STLWriter writer;\n        writer.m_points = std::move(points);\n        writer.m_triangles = std::move(triangles);\n        writer.write(filename, io_options, 10);\n    }\n};\nTEST_CASE(\"bug2: MeshBoolean_InterSegments \", \"[meshModeling][MeshBoolean_InterSegments][bug]\")\n{\n    IOOptions io_options;\n    io_options.vertex_has_point = true;\n    Points      points1, points2, points3, result_points;\n    Triangles   triangles1, triangles2, triangles3, result_triangles;\n\tSECTION(\"stl-stl-obj\")\n    {\n        OUTPUT_DIRECTORY(MeshBoolean, InterSegments_stl);\n        read_mesh2(INPUT_PATH_PREFIX\"./meshModeling_data/MeshBoolean_data/cow1.stl\", points1, triangles1, io_options);\n        read_mesh2(INPUT_PATH_PREFIX\"./meshModeling_data/MeshBoolean_data/bunny1.stl\", points2, triangles2, io_options);\n        read_mesh2(INPUT_PATH_PREFIX\"./meshModeling_data/MeshBoolean_data/bunny1.obj\", points3, triangles3, io_options);\n        MeshBoolean boolean(true);\n        boolean.addTriMeshAsInput(points1, triangles1);\n        boolean.addTriMeshAsInput(points2, triangles2);\n        boolean.addTriMeshAsInput(points3, triangles3);\n        boolean.setTriMeshAsOutput(result_points, result_triangles);\n        boolean.computeLabels();\n        boolean.computeInterSegments();\n        boolean.Subtraction();\n        const auto& inter_segs = boolean.getInterSegments();\n        for (size_t s_id = 0; s_id < inter_segs.size(); ++s_id)\n        {\n            std::ofstream ofs(outdir + \"stl_\" + std::to_string(s_id) + \".obj\");\n            size_t v_num = inter_segs[s_id].vertex_ids.size();\n            ofs << \"# v_num: \" << v_num << std::endl;\n            size_t l_num = inter_segs[s_id].closed ? inter_segs[s_id].vertex_ids.size() : inter_segs[s_id].vertex_ids.size() - 1;\n            ofs << \"# l_num: \" << l_num << std::endl;\n            ofs << std::endl;\n            for (auto v_id : inter_segs[s_id].vertex_ids)\n            {\n                ofs << \"v \" << result_points[v_id].x() << \" \" << result_points[v_id].y() << \" \" << result_points[v_id].z() << std::endl;\n            }\n            ofs << std::endl;\n            for (size_t i = 0; i < inter_segs[s_id].vertex_ids.size() - 1; ++i)\n            {\n                ofs << \"l \" << i + 1 << \" \" << i + 2 << std::endl;\n            }\n            if (inter_segs[s_id].closed)\n            {\n                ofs << \"l \" << inter_segs[s_id].vertex_ids.size() << \" \" << 1 << std::endl;\n            }\n            ofs.close();\n            write_mesh2(outdir + \"InterSubtraction.stl\", result_points, result_triangles, io_options);\n        }\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAXMeshing_API void Union()\t @brief apply (3)UNION and (4)put result to output mesh.\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelperBase.h>\n#define AMCAXMeshing_Enable_CommonTraits\n#define AMCAXMeshing_Disable_StandardTraits\n#define AMCAXMeshing_Enable_EigenTraits\n#include \"mesh/io/OBJReader.hpp\"\n#include \"mesh/io/OBJWriter.hpp\"\n#include \"mesh/io/STLReader.hpp\"\n#include \"mesh/io/STLWriter.hpp\"\n#include \"meshModeling/MeshBoolean.hpp\"\n#include \"meshModeling/TriMeshRepair.hpp\"\n#include \"meshModeling/MeshParameterization.hpp\"\nusing EIAC = AMCAX::Meshing::Geometry::EIAC;\nusing TriSoupTraits = AMCAX::Meshing::Mesh::TriSoupTraits_Coord;\nusing Points = typename TriSoupTraits::Points;\nusing Triangles = typename TriSoupTraits::Triangles;\nusing OBJReader = AMCAX::Meshing::Mesh::OBJReader<TriSoupTraits>;\nusing OBJWriter = AMCAX::Meshing::Mesh::OBJWriter<TriSoupTraits>;\nusing STLReader = AMCAX::Meshing::Mesh::STLReader<TriSoupTraits>;\nusing STLWriter = AMCAX::Meshing::Mesh::STLWriter<TriSoupTraits>;\nusing IOOptions = AMCAX::Meshing::Mesh::IOOptions;\nusing MeshBoolean = AMCAX::Meshing::Boolean::MeshBoolean<EIAC, TriSoupTraits>;\nvoid read_mesh11(const std::string& filename, Points& points,Triangles& triangles, IOOptions& io_options)\n{\n\tif (AMCAX::Meshing::ends_with(filename, \".obj\"))\n\t{\n\t\tOBJReader reader;\n\t\treader.read(filename, io_options);\n\t\tpoints = std::move(reader.m_points);\n\t\ttriangles = std::move(reader.m_triangles);\n\t}\n\telse if (AMCAX::Meshing::ends_with(filename, \".stl\"))\n\t{\n\t\tSTLReader reader;\n\t\treader.read(filename, io_options);\n\t\tpoints = std::move(reader.m_points);\n\t\ttriangles = std::move(reader.m_triangles);\n\t}\n}\nvoid write_mesh11(const std::string& filename, const Points& points,const Triangles& triangles, IOOptions& io_options)\n{\n\tOBJWriter writer;\n\twriter.m_points = std::move(points);\n\twriter.m_triangles = std::move(triangles);\n\tbool bWriteObj = writer.write(filename, io_options, 10);\n\tCHECK(bWriteObj == true);\n};\nTEST_CASE(\"case1: MeshBoolean_MeshBoolean  \", \"[meshModeling][MeshBoolean][P1]\")\n{\n\tOUTPUT_DIRECTORY(Boolean, Boolean);\n\tIOOptions io_options;\n\tio_options.vertex_has_point = true;\n\tPoints    points1, points2, result_points;\n\tTriangles triangles1, triangles2, result_triangles;\n\tread_mesh11(INPUT_PATH_PREFIX\"./meshModeling_data/MeshBoolean_data/bunny25k.obj\", points1, triangles1, io_options);\n\tread_mesh11(INPUT_PATH_PREFIX\"./meshModeling_data/MeshBoolean_data/cow.obj\", points2, triangles2, io_options);\n\tMeshBoolean boolean( true);\n\tboolean.addTriMeshAsInput(points1, triangles1);\n\tboolean.addTriMeshAsInput(points2, triangles2);\n\tboolean.setTriMeshAsOutput(result_points, result_triangles);\n\tboolean.computeLabels();\n\t{\n\t\tboolean.Union();\n\t\tmake_file_writable(outdir + \"AMCAXMeshing_Union.obj\");\n\t\twrite_mesh11(outdir + \"AMCAXMeshing_Union.obj\", result_points,\n\t\t\tresult_triangles, io_options);\n\t}\n\t{\n\t\tboolean.Intersection();\n\t\tmake_file_writable(outdir + \"AMCAXMeshing_Intersection.obj\");\n\t\twrite_mesh11(outdir + \"AMCAXMeshing_Intersection.obj\", result_points,\n\t\t\tresult_triangles, io_options);\n\t}\n\t{\n\t\tboolean.Xor();\n\t\tmake_file_writable(outdir + \"AMCAXMeshing_Xor.obj\");\n\t\twrite_mesh11(outdir + \"AMCAXMeshing_Xor.obj\", result_points, result_triangles,\n\t\t\tio_options);\n\t}\n\t{\n\t\tboolean.Subtraction();\n\t\tmake_file_writable(outdir + \"AMCAXMeshing_Subtraction.obj\");\n\t\twrite_mesh11(outdir + \"AMCAXMeshing_Subtraction.obj\", result_points,\n\t\t\tresult_triangles, io_options);\n\t}\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAXMeshing_API void setTriMeshAsOutput(iPoints    &points, iTriangles &triangles),\n",
      "output": "#include<catch.hpp>\n#include<testHelperBase.h>\n#define AMCAXMeshing_Enable_CommonTraits\n#define AMCAXMeshing_Disable_StandardTraits\n#define AMCAXMeshing_Enable_EigenTraits\n#include \"mesh/io/OBJReader.hpp\"\n#include \"mesh/io/OBJWriter.hpp\"\n#include \"mesh/io/STLReader.hpp\"\n#include \"mesh/io/STLWriter.hpp\"\n#include \"meshModeling/MeshBoolean.hpp\"\n#include \"meshModeling/TriMeshRepair.hpp\"\n#include \"meshModeling/MeshParameterization.hpp\"\nusing EIAC = AMCAX::Meshing::Geometry::EIAC;\nusing TriSoupTraits = AMCAX::Meshing::Mesh::TriSoupTraits_Coord;\nusing Points = typename TriSoupTraits::Points;\nusing Triangles = typename TriSoupTraits::Triangles;\nusing OBJReader = AMCAX::Meshing::Mesh::OBJReader<TriSoupTraits>;\nusing OBJWriter = AMCAX::Meshing::Mesh::OBJWriter<TriSoupTraits>;\nusing STLReader = AMCAX::Meshing::Mesh::STLReader<TriSoupTraits>;\nusing STLWriter = AMCAX::Meshing::Mesh::STLWriter<TriSoupTraits>;\nusing IOOptions = AMCAX::Meshing::Mesh::IOOptions;\nusing MeshBoolean = AMCAX::Meshing::Boolean::MeshBoolean<EIAC, TriSoupTraits>;\nvoid read_mesh11(const std::string& filename, Points& points,Triangles& triangles, IOOptions& io_options)\n{\n\tif (AMCAX::Meshing::ends_with(filename, \".obj\"))\n\t{\n\t\tOBJReader reader;\n\t\treader.read(filename, io_options);\n\t\tpoints = std::move(reader.m_points);\n\t\ttriangles = std::move(reader.m_triangles);\n\t}\n\telse if (AMCAX::Meshing::ends_with(filename, \".stl\"))\n\t{\n\t\tSTLReader reader;\n\t\treader.read(filename, io_options);\n\t\tpoints = std::move(reader.m_points);\n\t\ttriangles = std::move(reader.m_triangles);\n\t}\n}\nvoid write_mesh11(const std::string& filename, const Points& points,const Triangles& triangles, IOOptions& io_options)\n{\n\tOBJWriter writer;\n\twriter.m_points = std::move(points);\n\twriter.m_triangles = std::move(triangles);\n\tbool bWriteObj = writer.write(filename, io_options, 10);\n\tCHECK(bWriteObj == true);\n};\nTEST_CASE(\"case1: MeshBoolean_MeshBoolean  \", \"[meshModeling][MeshBoolean][P1]\")\n{\n\tOUTPUT_DIRECTORY(Boolean, Boolean);\n\tIOOptions io_options;\n\tio_options.vertex_has_point = true;\n\tPoints    points1, points2, result_points;\n\tTriangles triangles1, triangles2, result_triangles;\n\tread_mesh11(INPUT_PATH_PREFIX\"./meshModeling_data/MeshBoolean_data/bunny25k.obj\", points1, triangles1, io_options);\n\tread_mesh11(INPUT_PATH_PREFIX\"./meshModeling_data/MeshBoolean_data/cow.obj\", points2, triangles2, io_options);\n\tMeshBoolean boolean( true);\n\tboolean.addTriMeshAsInput(points1, triangles1);\n\tboolean.addTriMeshAsInput(points2, triangles2);\n\tboolean.setTriMeshAsOutput(result_points, result_triangles);\n\tboolean.computeLabels();\n\t{\n\t\tboolean.Union();\n\t\tmake_file_writable(outdir + \"AMCAXMeshing_Union.obj\");\n\t\twrite_mesh11(outdir + \"AMCAXMeshing_Union.obj\", result_points,\n\t\t\tresult_triangles, io_options);\n\t}\n\t{\n\t\tboolean.Intersection();\n\t\tmake_file_writable(outdir + \"AMCAXMeshing_Intersection.obj\");\n\t\twrite_mesh11(outdir + \"AMCAXMeshing_Intersection.obj\", result_points,\n\t\t\tresult_triangles, io_options);\n\t}\n\t{\n\t\tboolean.Xor();\n\t\tmake_file_writable(outdir + \"AMCAXMeshing_Xor.obj\");\n\t\twrite_mesh11(outdir + \"AMCAXMeshing_Xor.obj\", result_points, result_triangles,\n\t\t\tio_options);\n\t}\n\t{\n\t\tboolean.Subtraction();\n\t\tmake_file_writable(outdir + \"AMCAXMeshing_Subtraction.obj\");\n\t\twrite_mesh11(outdir + \"AMCAXMeshing_Subtraction.obj\", result_points,\n\t\t\tresult_triangles, io_options);\n\t}\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "HyperbolaS& Scale(const PointT<double, DIM>& point, double scale)\t @return The reference to self\n\t @param scale The scale value\n\t @param point The scaling center point\n\t @brief Scale the hyperbola by a center point\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <modeling/MakeFace.hpp>\n#include <common/AxisT.hpp>\n#include <math/HyperbolaT.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <common/VectorT.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <topology/TopoEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <iostream>\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Hyperbola3\", \"[math][Hyperbola3][p1]\") {\n\tPoint3 point3_fr(0.0, 0.0, 1.0);\n\tDirection3 dir3_fr(0.0, 0.0, 1.0);\n\tFrame3 frame3(point3_fr, dir3_fr);\n\tdouble major3 = 3.0, minor3 = 4.0;\n\tHyperbola3 hyperbola3d_fr(frame3, major3, minor3);\n\tSECTION(\"Scale()\") {\t\t\n\t\tPoint3 point1(0.0, 0.0, 1.0);\n\t\thyperbola3d_fr.Scale(point1, 0.5);\n\t\tCHECK(hyperbola3d_fr.Location().X() == Approx(0.0));\n\t\tCHECK(hyperbola3d_fr.Location().Y() == Approx(0.0));\n\t\tCHECK(hyperbola3d_fr.Location().Z() == Approx(1.0));\n\t\tPoint3 point2(1.5, 0.0, 1.0);\n\t\tMakeEdge edge1(hyperbola3d_fr);\n\t\tCHECK(BRepClassificationTools::IsPointInOnEdge(edge1, point2, 0.001) == true);\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] HyperbolaS ConjugateBranch2()\t @return The negative conjugate hyperbola\n\t @brief Get the conjugate hyperbola on the negative side of the minor axis\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <modeling/MakeFace.hpp>\n#include <common/AxisT.hpp>\n#include <math/HyperbolaT.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <common/VectorT.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <topology/TopoEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <iostream>\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Hyperbola3\", \"[math][Hyperbola3][p1]\") {\n\tPoint3 point3_fr(0.0, 0.0, 1.0);\n\tDirection3 dir3_fr(0.0, 0.0, 1.0);\n\tFrame3 frame3(point3_fr, dir3_fr);\n\tdouble major3 = 3.0, minor3 = 4.0;\n\tHyperbola3 hyperbola3d_fr(frame3, major3, minor3);\n\tSECTION(\"ConjugateBranch2()\") {\t\t\n\t\tHyperbola3 hyperbola3d_con = hyperbola3d_fr.ConjugateBranch2();\n\t\tCHECK(hyperbola3d_con.Location().X() == Approx(0.0));\n\t\tCHECK(hyperbola3d_con.Location().Y() == Approx(0.0));\n\t\tCHECK(hyperbola3d_con.Location().Z() == Approx(1.0));\n\t\tPoint3 point1(0.0, -4.0, 1.0);\n\t\tPoint3 point2(9.0 / 4.0, -5.0, 1.0);\n\t\tMakeEdge edge2(hyperbola3d_con);\n\t\tCHECK(BRepClassificationTools::IsPointInOnEdge(edge2, point1, 0.001) == true);\n\t\tCHECK(BRepClassificationTools::IsPointInOnEdge(edge2, point2, 0.001) == true);\n\t\tdouble major3d_con = hyperbola3d_con.MajorRadius();\n\t\tdouble minor3d_con = hyperbola3d_con.MinorRadius();\n\t\tCHECK(major3d_con == Approx(4.0));\n\t\tCHECK(minor3d_con == Approx(3.0));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] HyperbolaS ConjugateBranch1()\t @return The positive conjugate hyperbola\n\t @brief Get the conjugate hyperbola on the positive side of the minor axis\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <modeling/MakeFace.hpp>\n#include <common/AxisT.hpp>\n#include <math/HyperbolaT.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <common/VectorT.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <topology/TopoEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <iostream>\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Hyperbola3\", \"[math][Hyperbola3][p1]\") {\n\tPoint3 point3_fr(0.0, 0.0, 1.0);\n\tDirection3 dir3_fr(0.0, 0.0, 1.0);\n\tFrame3 frame3(point3_fr, dir3_fr);\n\tdouble major3 = 3.0, minor3 = 4.0;\n\tHyperbola3 hyperbola3d_fr(frame3, major3, minor3);\n\tSECTION(\"ConjugateBranch1()\") {\n\t\tHyperbola3 hyperbola3d_con = hyperbola3d_fr.ConjugateBranch1();\n\t\tCHECK(hyperbola3d_con.Location().X() == Approx(0.0));\n\t\tCHECK(hyperbola3d_con.Location().Y() == Approx(0.0));\n\t\tCHECK(hyperbola3d_con.Location().Z() == Approx(1.0));\n\t\tPoint3 point1(0.0, 4.0, 1.0);\n\t\tPoint3 point2(9.0 / 4.0, 5.0, 1.0);\n\t\tMakeEdge edge1(hyperbola3d_con);\n\t\tCHECK(BRepClassificationTools::IsPointInOnEdge(edge1, point1, 0.001) == true);\n\t\tCHECK(BRepClassificationTools::IsPointInOnEdge(edge1, point2, 0.001) == true);\n\t\tdouble major3d_con = hyperbola3d_con.MajorRadius();\n\t\tdouble minor3d_con = hyperbola3d_con.MinorRadius();\n\t\tCHECK(major3d_con == Approx(4.0));\n\t\tCHECK(minor3d_con == Approx(3.0));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] AxisT<double, DIM> Asymptote2()\t @return The negative asymptote\n\t @brief Get the asymptote of the hyperbola with negative slope\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <modeling/MakeFace.hpp>\n#include <common/AxisT.hpp>\n#include <math/HyperbolaT.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <common/VectorT.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <topology/TopoEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <iostream>\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Hyperbola3\", \"[math][Hyperbola3][p1]\") {\n\tPoint3 point3_fr(0.0, 0.0, 1.0);\n\tDirection3 dir3_fr(0.0, 0.0, 1.0);\n\tFrame3 frame3(point3_fr, dir3_fr);\n\tdouble major3 = 3.0, minor3 = 4.0;\n\tHyperbola3 hyperbola3d_fr(frame3, major3, minor3);\n\tSECTION(\"Asymptote2()\") {\n\t\tAxis3 axis3d_asy = hyperbola3d_fr.Asymptote2();\n\t\tCHECK(axis3d_asy.Direction().X() / axis3d_asy.Direction().Y() == Approx(-3.0 / 4.0));\n\t\tCHECK(axis3d_asy.Direction().Z() == Approx(0.0));\n\t\tPoint3 point1(0.0, 0.0, 1.0);\n\t\tLine3 line3d_asy(axis3d_asy);\n\t\tMakeEdge edge1(line3d_asy);\n\t\tCHECK(BRepClassificationTools::IsPointInOnEdge(edge1, point1, 0.001) == true);\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] AxisT<double, DIM> Asymptote1()\t @return The positive asymptote\n\t @brief Get the asymptote of the hyperbola with positive slope\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <modeling/MakeFace.hpp>\n#include <common/AxisT.hpp>\n#include <math/HyperbolaT.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <common/VectorT.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <topology/TopoEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <iostream>\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Hyperbola3\", \"[math][Hyperbola3][p1]\") {\n\tPoint3 point3_fr(0.0, 0.0, 1.0);\n\tDirection3 dir3_fr(0.0, 0.0, 1.0);\n\tFrame3 frame3(point3_fr, dir3_fr);\n\tdouble major3 = 3.0, minor3 = 4.0;\n\tHyperbola3 hyperbola3d_fr(frame3, major3, minor3);\n\tSECTION(\"Asymptote1()\") {\n\t\tAxis3 axis3d_asy = hyperbola3d_fr.Asymptote1();\n\t\tCHECK(axis3d_asy.Direction().X() / axis3d_asy.Direction().Y() == Approx(3.0 / 4.0));\n\t\tCHECK(axis3d_asy.Direction().Z() == Approx(0.0));\n\t\tPoint3 point1(0.0, 0.0, 1.0);\n\t\tLine3 line3d_asy(axis3d_asy);\n\t\tMakeEdge edge1(line3d_asy);\n\t\tCHECK(BRepClassificationTools::IsPointInOnEdge(edge1, point1, 0.001) == true);\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] double MinorRadius()\t @return The minor radius\n\t @brief Get the minor radius\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <modeling/MakeFace.hpp>\n#include <common/AxisT.hpp>\n#include <math/HyperbolaT.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <common/VectorT.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <topology/TopoEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <iostream>\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Hyperbola3\", \"[math][Hyperbola3][p1]\") {\n\tPoint3 point3_fr(0.0, 0.0, 1.0);\n\tDirection3 dir3_fr(0.0, 0.0, 1.0);\n\tFrame3 frame3(point3_fr, dir3_fr);\n\tdouble major3 = 3.0, minor3 = 4.0;\n\tHyperbola3 hyperbola3d_fr(frame3, major3, minor3);\n\tSECTION(\"ConjugateBranch2()\") {\t\t\n\t\tHyperbola3 hyperbola3d_con = hyperbola3d_fr.ConjugateBranch2();\n\t\tCHECK(hyperbola3d_con.Location().X() == Approx(0.0));\n\t\tCHECK(hyperbola3d_con.Location().Y() == Approx(0.0));\n\t\tCHECK(hyperbola3d_con.Location().Z() == Approx(1.0));\n\t\tPoint3 point1(0.0, -4.0, 1.0);\n\t\tPoint3 point2(9.0 / 4.0, -5.0, 1.0);\n\t\tMakeEdge edge2(hyperbola3d_con);\n\t\tCHECK(BRepClassificationTools::IsPointInOnEdge(edge2, point1, 0.001) == true);\n\t\tCHECK(BRepClassificationTools::IsPointInOnEdge(edge2, point2, 0.001) == true);\n\t\tdouble major3d_con = hyperbola3d_con.MajorRadius();\n\t\tdouble minor3d_con = hyperbola3d_con.MinorRadius();\n\t\tCHECK(major3d_con == Approx(4.0));\n\t\tCHECK(minor3d_con == Approx(3.0));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] double MajorRadius()\t @return The major radius\n\t @brief Get the major radius\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <modeling/MakeFace.hpp>\n#include <common/AxisT.hpp>\n#include <math/HyperbolaT.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <common/VectorT.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <topology/TopoEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <iostream>\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Hyperbola3\", \"[math][Hyperbola3][p1]\") {\n\tPoint3 point3_fr(0.0, 0.0, 1.0);\n\tDirection3 dir3_fr(0.0, 0.0, 1.0);\n\tFrame3 frame3(point3_fr, dir3_fr);\n\tdouble major3 = 3.0, minor3 = 4.0;\n\tHyperbola3 hyperbola3d_fr(frame3, major3, minor3);\n\tSECTION(\"ConjugateBranch1()\") {\n\t\tHyperbola3 hyperbola3d_con = hyperbola3d_fr.ConjugateBranch1();\n\t\tCHECK(hyperbola3d_con.Location().X() == Approx(0.0));\n\t\tCHECK(hyperbola3d_con.Location().Y() == Approx(0.0));\n\t\tCHECK(hyperbola3d_con.Location().Z() == Approx(1.0));\n\t\tPoint3 point1(0.0, 4.0, 1.0);\n\t\tPoint3 point2(9.0 / 4.0, 5.0, 1.0);\n\t\tMakeEdge edge1(hyperbola3d_con);\n\t\tCHECK(BRepClassificationTools::IsPointInOnEdge(edge1, point1, 0.001) == true);\n\t\tCHECK(BRepClassificationTools::IsPointInOnEdge(edge1, point2, 0.001) == true);\n\t\tdouble major3d_con = hyperbola3d_con.MajorRadius();\n\t\tdouble minor3d_con = hyperbola3d_con.MinorRadius();\n\t\tCHECK(major3d_con == Approx(4.0));\n\t\tCHECK(minor3d_con == Approx(3.0));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] PointT<double, DIM> Focus2()\t @return The negative focus\n\t @brief Get the focus on the negative side of the major axis\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <modeling/MakeFace.hpp>\n#include <common/AxisT.hpp>\n#include <math/HyperbolaT.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <common/VectorT.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <topology/TopoEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <iostream>\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Hyperbola3\", \"[math][Hyperbola3][p1]\") {\n\tPoint3 point3_fr(0.0, 0.0, 1.0);\n\tDirection3 dir3_fr(0.0, 0.0, 1.0);\n\tFrame3 frame3(point3_fr, dir3_fr);\n\tdouble major3 = 3.0, minor3 = 4.0;\n\tHyperbola3 hyperbola3d_fr(frame3, major3, minor3);\n\tSECTION(\"Focus2\") {\n\t\tPoint3 point3d_f1 = hyperbola3d_fr.Focus2();\n\t\tCHECK(point3d_f1.X() == Approx(-5.0));\n\t\tCHECK(point3d_f1.Y() == Approx(0.0));\n\t\tCHECK(point3d_f1.Z() == Approx(1.0));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] PointT<double, DIM> Focus1()\t @return The positive focus\n\t @brief Get the focus on the positive side of the major axis\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <modeling/MakeFace.hpp>\n#include <common/AxisT.hpp>\n#include <math/HyperbolaT.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <common/VectorT.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <topology/TopoEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <iostream>\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Hyperbola3\", \"[math][Hyperbola3][p1]\") {\n\tPoint3 point3_fr(0.0, 0.0, 1.0);\n\tDirection3 dir3_fr(0.0, 0.0, 1.0);\n\tFrame3 frame3(point3_fr, dir3_fr);\n\tdouble major3 = 3.0, minor3 = 4.0;\n\tHyperbola3 hyperbola3d_fr(frame3, major3, minor3);\n\tSECTION(\"Default()\") {\n\t\tHyperbola3 hyperbola3d_de;\t\n\t\tCHECK(hyperbola3d_de.Location().X() == Approx(0.0));\n\t\tCHECK(hyperbola3d_de.Location().Y() == Approx(0.0));\n\t\tCHECK(hyperbola3d_de.Location().Z() == Approx(0.0));\n\t\thyperbola3d_de.SetMajorRadius(3.0);\n\t\thyperbola3d_de.SetMinorRadius(4.0);\n\t\tCHECK(hyperbola3d_de.MajorRadius() == Approx(3.0));\n\t\tCHECK(hyperbola3d_de.MinorRadius() == Approx(4.0));\n\t\tCHECK(hyperbola3d_de.Focal() == Approx(10.0));\n\t\tCHECK(hyperbola3d_de.Focus1().X() == Approx(5.0));\n\t\tCHECK(hyperbola3d_de.Focus1().Y() == Approx(0.0));\n\t\tCHECK(hyperbola3d_de.Focus1().Z() == Approx(0.0));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] AxisT<double, DIM> Directrix2()\t @return The negative directrix\n\t @brief Get the directrix on the negative side of the major axis\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <modeling/MakeFace.hpp>\n#include <common/AxisT.hpp>\n#include <math/HyperbolaT.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <common/VectorT.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <topology/TopoEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <iostream>\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Hyperbola3\", \"[math][Hyperbola3][p1]\") {\n\tPoint3 point3_fr(0.0, 0.0, 1.0);\n\tDirection3 dir3_fr(0.0, 0.0, 1.0);\n\tFrame3 frame3(point3_fr, dir3_fr);\n\tdouble major3 = 3.0, minor3 = 4.0;\n\tHyperbola3 hyperbola3d_fr(frame3, major3, minor3);\n\tSECTION(\"Directrix2()\") {\n\t\tAxis3 axis3d_dir = hyperbola3d_fr.Directrix2();\n\t\tCHECK(axis3d_dir.Direction().X() == Approx(0.0));\n\t\tCHECK(axis3d_dir.Direction().Y() == Approx(1.0));\n\t\tCHECK(axis3d_dir.Direction().Z() == Approx(0.0));\n\t\tCHECK(axis3d_dir.Location().X() == Approx(-9.0 / 5.0));\n\t\tCHECK(axis3d_dir.Location().Y() == Approx(0.0));\n\t\tCHECK(axis3d_dir.Location().Z() == Approx(1.0));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] AxisT<double, DIM> Directrix1()\t @return The positive directrix\n\t @brief Get the directrix on the positive side of the major axis\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <modeling/MakeFace.hpp>\n#include <common/AxisT.hpp>\n#include <math/HyperbolaT.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <common/VectorT.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <topology/TopoEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <iostream>\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Hyperbola3\", \"[math][Hyperbola3][p1]\") {\n\tPoint3 point3_fr(0.0, 0.0, 1.0);\n\tDirection3 dir3_fr(0.0, 0.0, 1.0);\n\tFrame3 frame3(point3_fr, dir3_fr);\n\tdouble major3 = 3.0, minor3 = 4.0;\n\tHyperbola3 hyperbola3d_fr(frame3, major3, minor3);\n\tSECTION(\"Directrix1()\") {\n\t\tAxis3 axis3d_dir = hyperbola3d_fr.Directrix1();\n\t\tCHECK(axis3d_dir.Direction().X() == Approx(0.0));\n\t\tCHECK(axis3d_dir.Direction().Y() == Approx(1.0));\n\t\tCHECK(axis3d_dir.Direction().Z() == Approx(0.0));\n\t\tCHECK(axis3d_dir.Location().X() == Approx(9.0 / 5.0));\n\t\tCHECK(axis3d_dir.Location().Y() == Approx(0.0));\n\t\tCHECK(axis3d_dir.Location().Z() == Approx(1.0));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "void SetMinorRadius(double r)\t @param r The new minor radius\n\t @brief Set the minor radius\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <modeling/MakeFace.hpp>\n#include <common/AxisT.hpp>\n#include <math/HyperbolaT.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <common/VectorT.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <topology/TopoEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <iostream>\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Hyperbola3\", \"[math][Hyperbola3][p1]\") {\n\tPoint3 point3_fr(0.0, 0.0, 1.0);\n\tDirection3 dir3_fr(0.0, 0.0, 1.0);\n\tFrame3 frame3(point3_fr, dir3_fr);\n\tdouble major3 = 3.0, minor3 = 4.0;\n\tHyperbola3 hyperbola3d_fr(frame3, major3, minor3);\n\tSECTION(\"SetMinorRadius()\") {\n\t\thyperbola3d_fr.SetMinorRadius(3.0);\n\t\tCHECK(hyperbola3d_fr.Location().X() == Approx(0.0));\n\t\tCHECK(hyperbola3d_fr.Location().Y() == Approx(0.0));\n\t\tCHECK(hyperbola3d_fr.MajorRadius() == Approx(3.0));\n\t\tCHECK(hyperbola3d_fr.MinorRadius() == Approx(3.0));\n\t\tPoint3 point1(3.0, 0.0, 1.0);\n\t\tMakeEdge edge1(hyperbola3d_fr);\n\t\tCHECK(BRepClassificationTools::IsPointInOnEdge(edge1, point1, 0.001) == true);\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "void SetMajorRadius(double r)\t @param r The new major radius\n\t @brief Set the major radius\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <modeling/MakeFace.hpp>\n#include <common/AxisT.hpp>\n#include <math/HyperbolaT.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <common/VectorT.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <topology/TopoEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <iostream>\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Hyperbola3\", \"[math][Hyperbola3][p1]\") {\n\tPoint3 point3_fr(0.0, 0.0, 1.0);\n\tDirection3 dir3_fr(0.0, 0.0, 1.0);\n\tFrame3 frame3(point3_fr, dir3_fr);\n\tdouble major3 = 3.0, minor3 = 4.0;\n\tHyperbola3 hyperbola3d_fr(frame3, major3, minor3);\n\tSECTION(\"Default()\") {\n\t\tHyperbola3 hyperbola3d_de;\t\n\t\tCHECK(hyperbola3d_de.Location().X() == Approx(0.0));\n\t\tCHECK(hyperbola3d_de.Location().Y() == Approx(0.0));\n\t\tCHECK(hyperbola3d_de.Location().Z() == Approx(0.0));\n\t\thyperbola3d_de.SetMajorRadius(3.0);\n\t\thyperbola3d_de.SetMinorRadius(4.0);\n\t\tCHECK(hyperbola3d_de.MajorRadius() == Approx(3.0));\n\t\tCHECK(hyperbola3d_de.MinorRadius() == Approx(4.0));\n\t\tCHECK(hyperbola3d_de.Focal() == Approx(10.0));\n\t\tCHECK(hyperbola3d_de.Focus1().X() == Approx(5.0));\n\t\tCHECK(hyperbola3d_de.Focus1().Y() == Approx(0.0));\n\t\tCHECK(hyperbola3d_de.Focus1().Z() == Approx(0.0));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "HyperbolaS& Scale(const PointT<double, DIM>& point, double scale)\t @return The reference to self\n\t @param scale The scale value\n\t @param point The scaling center point\n\t @brief Scale the hyperbola by a center point\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <modeling/MakeFace.hpp>\n#include <common/AxisT.hpp>\n#include <math/HyperbolaT.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <common/VectorT.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <topology/TopoEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <common/TransformationT.hpp>\n#include <iostream>\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Hyperbola2\", \"[math][Hyperbola2][p1]\") {\n\tPoint2 point2_Hy(0.0, 0.0);\t\n\tDirection2 dir2_Hy(1.0, 0.0);\n\tAxis2 major2_Axis(point2_Hy, dir2_Hy);\n\tdouble major2 = 3.0, minor2 = 4.0;\n\tHyperbola2 hyperbola2d_ax(major2_Axis, major2, minor2, true);\n\tPoint2 point2_fr(1.0, 1.0);\n\tDirection2 dir2_fr(0.0, 1.0);\n\tFrame2 frame2(point2_fr, dir2_fr);\n\tHyperbola2 hyperbola2d_fr(frame2, major2, minor2);\n\tSECTION(\"Scale()\") {\t\t\n\t\tPoint2 point2(1.0, 1.0);\n\t\thyperbola2d_ax.Scale(point2, 0.5);\n\t\tCHECK(hyperbola2d_ax.Location().X() == Approx(0.5));\n\t\tCHECK(hyperbola2d_ax.Location().Y() == Approx(0.5));\n\t\tPoint3 point3(2.0, 0.5, 0.0);\n\t\tMakeEdge2d edge1(hyperbola2d_ax);\n\t\tCHECK(BRepClassificationTools::IsPointInOnEdge(edge1, point3, 0.001) == true);\n\t}}\n}\n,\n{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] HyperbolaS ConjugateBranch2()\t @return The negative conjugate hyperbola\n\t @brief Get the conjugate hyperbola on the negative side of the minor axis\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <modeling/MakeFace.hpp>\n#include <common/AxisT.hpp>\n#include <math/HyperbolaT.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <common/VectorT.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <topology/TopoEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <common/TransformationT.hpp>\n#include <iostream>\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Hyperbola2\", \"[math][Hyperbola2][p1]\") {\n\tPoint2 point2_Hy(0.0, 0.0);\t\n\tDirection2 dir2_Hy(1.0, 0.0);\n\tAxis2 major2_Axis(point2_Hy, dir2_Hy);\n\tdouble major2 = 3.0, minor2 = 4.0;\n\tHyperbola2 hyperbola2d_ax(major2_Axis, major2, minor2, true);\n\tPoint2 point2_fr(1.0, 1.0);\n\tDirection2 dir2_fr(0.0, 1.0);\n\tFrame2 frame2(point2_fr, dir2_fr);\n\tHyperbola2 hyperbola2d_fr(frame2, major2, minor2);\n\tSECTION(\"ConjugateBranch2()\") {\n\t\tPoint3 point1(0.0, -4.0, 0.0);\n\t\tPoint3 point2(9.0 / 4.0, -5.0, 0.0);\n\t\tHyperbola2 hyperbola2d_con = hyperbola2d_ax.ConjugateBranch2();\n\t\tMakeEdge2d edge1(hyperbola2d_con);\n\t\tCHECK(BRepClassificationTools::IsPointInOnEdge(edge1, point1, 0.001) == true);\n\t\tCHECK(BRepClassificationTools::IsPointInOnEdge(edge1, point2, 0.001) == true);\n\t\tdouble major2d_con = hyperbola2d_con.MajorRadius();\n\t\tdouble minor2d_con = hyperbola2d_con.MinorRadius();\n\t\tCHECK(major2d_con == Approx(4.0));\n\t\tCHECK(minor2d_con == Approx(3.0));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] AxisT<double, DIM> Asymptote2()\t @return The negative asymptote\n\t @brief Get the asymptote of the hyperbola with negative slope\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <modeling/MakeFace.hpp>\n#include <common/AxisT.hpp>\n#include <math/HyperbolaT.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <common/VectorT.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <topology/TopoEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <common/TransformationT.hpp>\n#include <iostream>\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Hyperbola2\", \"[math][Hyperbola2][p1]\") {\n\tPoint2 point2_Hy(0.0, 0.0);\t\n\tDirection2 dir2_Hy(1.0, 0.0);\n\tAxis2 major2_Axis(point2_Hy, dir2_Hy);\n\tdouble major2 = 3.0, minor2 = 4.0;\n\tHyperbola2 hyperbola2d_ax(major2_Axis, major2, minor2, true);\n\tPoint2 point2_fr(1.0, 1.0);\n\tDirection2 dir2_fr(0.0, 1.0);\n\tFrame2 frame2(point2_fr, dir2_fr);\n\tHyperbola2 hyperbola2d_fr(frame2, major2, minor2);\n\tSECTION(\"Asymptote2()\") {\t\n\t\tAxis2 axis2d_asy = hyperbola2d_ax.Asymptote2();\n\t\tCHECK(axis2d_asy.Direction().X() / axis2d_asy.Direction().Y() == Approx(-3.0 / 4.0));\n\t\tPoint3 point1(0.0, 0.0, 0.0);\n\t\tLine2 line2d_asy(axis2d_asy);\n\t\tMakeEdge2d edge1(line2d_asy);\n\t\tCHECK(BRepClassificationTools::IsPointInOnEdge(edge1, point1, 0.001) == true);\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] AxisT<double, DIM> Asymptote1()\t @return The positive asymptote\n\t @brief Get the asymptote of the hyperbola with positive slope\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <modeling/MakeFace.hpp>\n#include <common/AxisT.hpp>\n#include <math/HyperbolaT.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <common/VectorT.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <topology/TopoEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <common/TransformationT.hpp>\n#include <iostream>\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Hyperbola2\", \"[math][Hyperbola2][p1]\") {\n\tPoint2 point2_Hy(0.0, 0.0);\t\n\tDirection2 dir2_Hy(1.0, 0.0);\n\tAxis2 major2_Axis(point2_Hy, dir2_Hy);\n\tdouble major2 = 3.0, minor2 = 4.0;\n\tHyperbola2 hyperbola2d_ax(major2_Axis, major2, minor2, true);\n\tPoint2 point2_fr(1.0, 1.0);\n\tDirection2 dir2_fr(0.0, 1.0);\n\tFrame2 frame2(point2_fr, dir2_fr);\n\tHyperbola2 hyperbola2d_fr(frame2, major2, minor2);\n\tSECTION(\"Asymptote1()\") {\n\t\tAxis2 axis2d_asy = hyperbola2d_ax.Asymptote1();\n\t\tCHECK(axis2d_asy.Direction().X()/ axis2d_asy.Direction().Y() == Approx(3.0/4.0));\n\t\tPoint3 point1(0.0, 0.0, 0.0);\n\t\tLine2 line2d_asy(axis2d_asy);\n\t\tMakeEdge2d edge1(line2d_asy);\n\t\tCHECK(BRepClassificationTools::IsPointInOnEdge(edge1, point1, 0.001) == true);\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] double MinorRadius()\t @return The minor radius\n\t @brief Get the minor radius\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <modeling/MakeFace.hpp>\n#include <common/AxisT.hpp>\n#include <math/HyperbolaT.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <common/VectorT.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <topology/TopoEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <common/TransformationT.hpp>\n#include <iostream>\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Hyperbola2\", \"[math][Hyperbola2][p1]\") {\n\tPoint2 point2_Hy(0.0, 0.0);\t\n\tDirection2 dir2_Hy(1.0, 0.0);\n\tAxis2 major2_Axis(point2_Hy, dir2_Hy);\n\tdouble major2 = 3.0, minor2 = 4.0;\n\tHyperbola2 hyperbola2d_ax(major2_Axis, major2, minor2, true);\n\tPoint2 point2_fr(1.0, 1.0);\n\tDirection2 dir2_fr(0.0, 1.0);\n\tFrame2 frame2(point2_fr, dir2_fr);\n\tHyperbola2 hyperbola2d_fr(frame2, major2, minor2);\n\tSECTION(\"ConjugateBranch1()\") {\n\t\tPoint3 point1(0.0, 4.0, 0.0);\n\t\tPoint3 point2(9.0 / 4.0, 5.0, 0.0);\n\t\tHyperbola2 hyperbola2d_con = hyperbola2d_ax.ConjugateBranch1();\n\t\tMakeEdge2d edge1(hyperbola2d_con);\n\t\tCHECK(BRepClassificationTools::IsPointInOnEdge(edge1, point1, 0.001) == true);\n\t\tCHECK(BRepClassificationTools::IsPointInOnEdge(edge1, point2, 0.001) == true);\n\t\tdouble major2d_con = hyperbola2d_con.MajorRadius();\n\t\tdouble minor2d_con = hyperbola2d_con.MinorRadius();\n\t\tCHECK( major2d_con== Approx(4.0));\n\t\tCHECK(minor2d_con == Approx(3.0));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] double MajorRadius()\t @return The major radius\n\t @brief Get the major radius\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <modeling/MakeFace.hpp>\n#include <common/AxisT.hpp>\n#include <math/HyperbolaT.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <common/VectorT.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <topology/TopoEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <common/TransformationT.hpp>\n#include <iostream>\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Hyperbola2\", \"[math][Hyperbola2][p1]\") {\n\tPoint2 point2_Hy(0.0, 0.0);\t\n\tDirection2 dir2_Hy(1.0, 0.0);\n\tAxis2 major2_Axis(point2_Hy, dir2_Hy);\n\tdouble major2 = 3.0, minor2 = 4.0;\n\tHyperbola2 hyperbola2d_ax(major2_Axis, major2, minor2, true);\n\tPoint2 point2_fr(1.0, 1.0);\n\tDirection2 dir2_fr(0.0, 1.0);\n\tFrame2 frame2(point2_fr, dir2_fr);\n\tHyperbola2 hyperbola2d_fr(frame2, major2, minor2);\n\tSECTION(\"Default()\") {\n\t\tHyperbola2 hyperbola2d_de;\t\n\t\tCHECK(hyperbola2d_de.Location().X() == Approx(0.0));\n\t\tCHECK(hyperbola2d_de.Location().Y() == Approx(0.0));\n\t\thyperbola2d_de.SetMajorRadius(3.0);\n\t\thyperbola2d_de.SetMinorRadius(4.0);\n\t\tCHECK(hyperbola2d_de.MajorRadius() == Approx(3.0));\n\t\tCHECK(hyperbola2d_de.MinorRadius() == Approx(4.0));\n\t\tCHECK(hyperbola2d_de.Focal() == Approx(10.0));\n\t\tCHECK(hyperbola2d_de.Focus1().X() == Approx(5.0));\n\t\tCHECK(hyperbola2d_de.Focus1().Y() == Approx(0.0));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] PointT<double, DIM> Focus1()\t @return The positive focus\n\t @brief Get the focus on the positive side of the major axis\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <modeling/MakeFace.hpp>\n#include <common/AxisT.hpp>\n#include <math/HyperbolaT.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <common/VectorT.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <topology/TopoEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <common/TransformationT.hpp>\n#include <iostream>\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Hyperbola2\", \"[math][Hyperbola2][p1]\") {\n\tPoint2 point2_Hy(0.0, 0.0);\t\n\tDirection2 dir2_Hy(1.0, 0.0);\n\tAxis2 major2_Axis(point2_Hy, dir2_Hy);\n\tdouble major2 = 3.0, minor2 = 4.0;\n\tHyperbola2 hyperbola2d_ax(major2_Axis, major2, minor2, true);\n\tPoint2 point2_fr(1.0, 1.0);\n\tDirection2 dir2_fr(0.0, 1.0);\n\tFrame2 frame2(point2_fr, dir2_fr);\n\tHyperbola2 hyperbola2d_fr(frame2, major2, minor2);\n\tSECTION(\"Default()\") {\n\t\tHyperbola2 hyperbola2d_de;\t\n\t\tCHECK(hyperbola2d_de.Location().X() == Approx(0.0));\n\t\tCHECK(hyperbola2d_de.Location().Y() == Approx(0.0));\n\t\thyperbola2d_de.SetMajorRadius(3.0);\n\t\thyperbola2d_de.SetMinorRadius(4.0);\n\t\tCHECK(hyperbola2d_de.MajorRadius() == Approx(3.0));\n\t\tCHECK(hyperbola2d_de.MinorRadius() == Approx(4.0));\n\t\tCHECK(hyperbola2d_de.Focal() == Approx(10.0));\n\t\tCHECK(hyperbola2d_de.Focus1().X() == Approx(5.0));\n\t\tCHECK(hyperbola2d_de.Focus1().Y() == Approx(0.0));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] AxisT<double, DIM> Directrix2()\t @return The negative directrix\n\t @brief Get the directrix on the negative side of the major axis\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <modeling/MakeFace.hpp>\n#include <common/AxisT.hpp>\n#include <math/HyperbolaT.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <common/VectorT.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <topology/TopoEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <common/TransformationT.hpp>\n#include <iostream>\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Hyperbola2\", \"[math][Hyperbola2][p1]\") {\n\tPoint2 point2_Hy(0.0, 0.0);\t\n\tDirection2 dir2_Hy(1.0, 0.0);\n\tAxis2 major2_Axis(point2_Hy, dir2_Hy);\n\tdouble major2 = 3.0, minor2 = 4.0;\n\tHyperbola2 hyperbola2d_ax(major2_Axis, major2, minor2, true);\n\tPoint2 point2_fr(1.0, 1.0);\n\tDirection2 dir2_fr(0.0, 1.0);\n\tFrame2 frame2(point2_fr, dir2_fr);\n\tHyperbola2 hyperbola2d_fr(frame2, major2, minor2);\n\tSECTION(\"Directrix()\") {\n\t\tAxis2 axis2d_dir = hyperbola2d_ax.Directrix2();\n\t\tCHECK(axis2d_dir.Direction().X() == Approx(0.0));\n\t\tCHECK(axis2d_dir.Direction().Y() == Approx(1.0));\n\t\tCHECK(axis2d_dir.Location().X() == Approx(-9.0 / 5.0));\n\t\tCHECK(axis2d_dir.Location().Y() == Approx(0.0));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "void SetMinorRadius(double r)\t @param r The new minor radius\n\t @brief Set the minor radius\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <modeling/MakeFace.hpp>\n#include <common/AxisT.hpp>\n#include <math/HyperbolaT.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <common/VectorT.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <topology/TopoEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <common/TransformationT.hpp>\n#include <iostream>\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Hyperbola2\", \"[math][Hyperbola2][p1]\") {\n\tPoint2 point2_Hy(0.0, 0.0);\t\n\tDirection2 dir2_Hy(1.0, 0.0);\n\tAxis2 major2_Axis(point2_Hy, dir2_Hy);\n\tdouble major2 = 3.0, minor2 = 4.0;\n\tHyperbola2 hyperbola2d_ax(major2_Axis, major2, minor2, true);\n\tPoint2 point2_fr(1.0, 1.0);\n\tDirection2 dir2_fr(0.0, 1.0);\n\tFrame2 frame2(point2_fr, dir2_fr);\n\tHyperbola2 hyperbola2d_fr(frame2, major2, minor2);\n\tSECTION(\"SetMinorRadius()\") {\n\t\thyperbola2d_ax.SetMinorRadius(3.0);\n\t\tCHECK(hyperbola2d_ax.Location().X() == Approx(0.0));\n\t\tCHECK(hyperbola2d_ax.Location().Y() == Approx(0.0));\n\t\tCHECK(hyperbola2d_ax.MajorRadius() == Approx(3.0));\n\t\tCHECK(hyperbola2d_ax.MinorRadius() == Approx(3.0));\n\t\tPoint3 point1(3.0, 0.0, 0.0);\n\t\tMakeEdge2d edge1(hyperbola2d_ax);\n\t\tCHECK(BRepClassificationTools::IsPointInOnEdge(edge1, point1, 0.001) == true);\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "void SetMajorRadius(double r)\t @param r The new major radius\n\t @brief Set the major radius\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <modeling/MakeFace.hpp>\n#include <common/AxisT.hpp>\n#include <math/HyperbolaT.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <common/VectorT.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <topology/TopoEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <common/TransformationT.hpp>\n#include <iostream>\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Hyperbola2\", \"[math][Hyperbola2][p1]\") {\n\tPoint2 point2_Hy(0.0, 0.0);\t\n\tDirection2 dir2_Hy(1.0, 0.0);\n\tAxis2 major2_Axis(point2_Hy, dir2_Hy);\n\tdouble major2 = 3.0, minor2 = 4.0;\n\tHyperbola2 hyperbola2d_ax(major2_Axis, major2, minor2, true);\n\tPoint2 point2_fr(1.0, 1.0);\n\tDirection2 dir2_fr(0.0, 1.0);\n\tFrame2 frame2(point2_fr, dir2_fr);\n\tHyperbola2 hyperbola2d_fr(frame2, major2, minor2);\n\tSECTION(\"Default()\") {\n\t\tHyperbola2 hyperbola2d_de;\t\n\t\tCHECK(hyperbola2d_de.Location().X() == Approx(0.0));\n\t\tCHECK(hyperbola2d_de.Location().Y() == Approx(0.0));\n\t\thyperbola2d_de.SetMajorRadius(3.0);\n\t\thyperbola2d_de.SetMinorRadius(4.0);\n\t\tCHECK(hyperbola2d_de.MajorRadius() == Approx(3.0));\n\t\tCHECK(hyperbola2d_de.MinorRadius() == Approx(4.0));\n\t\tCHECK(hyperbola2d_de.Focal() == Approx(10.0));\n\t\tCHECK(hyperbola2d_de.Focus1().X() == Approx(5.0));\n\t\tCHECK(hyperbola2d_de.Focus1().Y() == Approx(0.0));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API Cylinder& Scale(const Point3& point, double scale)\t @return The reference to self\n\t @param scale The scale value\n\t @param point The scaling center point\n\t @brief Scale the cylinder by a point\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <common/FrameT.hpp>\n#include <modeling/MakeFace.hpp>\n#include <common/AxisT.hpp>\n#include <math/Cylinder.hpp>\n#include <common/VectorT.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <modeling/MakeCylinder.hpp>\n#include <iostream>\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case2:this is a case for Test Cylinder_Mirror&Mirrored/Rotate&Rotated/Scale&Scaled\", \"[math][Cylinder][P1]\")\n{\n\tPoint3 point_cy(6.0, 0.0, 0.0);\n\tDirection3 dir_cy(0.0, 0.0, 1.0);\n\tFrame3 frame_cy(point_cy, dir_cy);\n\tdouble radius_cy = 5.0;\n\tCylinder cylinder(frame_cy, radius_cy);\n\tSECTION(\"Scale\")\n\t{\n\t\tCylinder scale_cylinder = cylinder.Scale(point_cy, scale);\n\t\tCHECK(cylinder.Radius() == Approx(2.5));\n\t\tCHECK(cylinder.Location().X() == Approx(6.0));\n\t\tCHECK(cylinder.Location().Y() == Approx(0.0));\n\t\tCHECK(cylinder.Location().Z() == Approx(0.0));\n\t\tCHECK(cylinder.Axis().Direction().X() == 0.0);\n\t\tCHECK(cylinder.Axis().Direction().Y() == 0.0);\n\t\tCHECK(cylinder.Axis().Direction().Z() == 1.0);\n\t\tCHECK(scale_cylinder.Radius() == Approx(2.5));\n\t\tCHECK(scale_cylinder.Location().X() == Approx(6.0));\n\t\tCHECK(scale_cylinder.Location().Y() == Approx(0.0));\n\t\tCHECK(scale_cylinder.Location().Z() == Approx(0.0));\n\t\tCHECK(scale_cylinder.Axis().Direction().X() == 0.0);\n\t\tCHECK(scale_cylinder.Axis().Direction().Y() == 0.0);\n\t\tCHECK(scale_cylinder.Axis().Direction().Z() == 1.0);\n\t}\n\tscale = 2.0;}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API Cylinder(const Frame3& frame, double r)\t @param r The radius\n\t @param frame The local frame\n\t @brief Construct from a local frame and a radius\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <common/FrameT.hpp>\n#include <modeling/MakeFace.hpp>\n#include <common/AxisT.hpp>\n#include <math/Cylinder.hpp>\n#include <common/VectorT.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <modeling/MakeCylinder.hpp>\n#include <iostream>\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"bug1:Cylinder \", \"[math][Cylinder][fixbug]\")\n{\n\tPoint3 point_cy(6.0, 0.0, 0.0);\n\tDirection3 dir_cy(0.0, 0.0, 1.0);\n\tFrame3 frame_cy(point_cy, dir_cy);\n\tdouble radius_cy = 5.0;\n\tCylinder cylinder(frame_cy, radius_cy);\n\tdouble r = 0.0;\n\tSECTION(\"SetRadius1\")\n\t{\n\t\tcylinder.SetRadius(r);\n\t\tCHECK(cylinder.Radius() == Approx(0.0));\n\t}\n\tr = -1.0;\n\tstring str1;\n\tstring str2 = \"[_DomainError]\";}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "Cylinder()\t @brief Default constructor\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <common/FrameT.hpp>\n#include <modeling/MakeFace.hpp>\n#include <common/AxisT.hpp>\n#include <math/Cylinder.hpp>\n#include <common/VectorT.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <modeling/MakeCylinder.hpp>\n#include <iostream>\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Test Cylinder\", \"[math][Cylinder][P1]\")\n{\n\tFrame3 frame;\n\tdouble radius = 5.0;\n\tCylinder cylinder(frame, radius);\n\tSECTION(\"Cylinder\")\n\t{\n\t\tCHECK(cylinder.Radius() == Approx(radius));\n\t\tCHECK(cylinder.Location().X() == Approx(0.0));\n\t\tCHECK(cylinder.Location().Y() == Approx(0.0));\n\t\tCHECK(cylinder.Location().Z() == Approx(0.0));\n\t\tCylinder cylinder1;\n\t\tCHECK(cylinder1.Location().X() == Approx(0.0));\n\t\tCHECK(cylinder1.Location().Y() == Approx(0.0));\n\t\tCHECK(cylinder1.Location().Z() == Approx(0.0));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static void D3(double u, const Parabola2& parabola, Point2& p, Vector2& v1, Vector2& v2, Vector2& v3)\t @param[out] v3 The third derivative\n\t @param[out] v2 The second derivative\n\t @param[out] v1 The first derivative\n\t @param[out] p The point\n\t @param[in] parabola The parabola\n\t @param[in] u The parameter\n\t @brief Compute the point and the first three derivatives on a 2D parabola at a parameter\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <common/PointT.hpp>\n#include <math/CurveCalculation.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <geometry/MakeArcOfHyperbola2d.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <modeling/MakeEdge2d.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"case1: CurveCalculation::D3() circle2[2/20] \", \"[math][CurveCalculation][P1][D2]\") {\n\tDirection2 initialDir(1.0, 0.0); \n\tFrame2 defaultFrame2(Point2(1.0, 1.0), initialDir); \n\tdouble radius = 2.0;\n\tAMCAX::Circle2 circle2(defaultFrame2, radius);\n\tPoint2 p;\n\tVector2 v1, v2,v3;\n\tSECTION(\"u = M_PI\") {\n\t\tCurveCalculation::D3(M_PI, circle2, p, v1, v2,v3);\n\t\tCHECK(p.X() == -1.0);\n\t\tCHECK(p.Y() == Approx(1.0));\n\t\tCHECK(v1.X() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v1.Y() == -2.0);\n\t\tCHECK(v2.X() == 2.0);\n\t\tCHECK(v2.Y() == Approx(0.0).margin(1e-11));\n\t\tCHECK(v3.X() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v3.Y() == 2.0);\n\t}\n}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static void D3(double u, const Ellipse2& ellipse, Point2& p, Vector2& v1, Vector2& v2, Vector2& v3)\t @param[out] v3 The third derivative\n\t @param[out] v2 The second derivative\n\t @param[out] v1 The first derivative\n\t @param[out] p The point\n\t @param[in] ellipse The ellipse\n\t @param[in] u The parameter\n\t @brief Compute the point and the first three derivatives on a 2D ellipse at a parameter\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <common/PointT.hpp>\n#include <math/CurveCalculation.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <geometry/MakeArcOfHyperbola2d.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <modeling/MakeEdge2d.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"case1: CurveCalculation::D3() circle2[2/20] \", \"[math][CurveCalculation][P1][D2]\") {\n\tDirection2 initialDir(1.0, 0.0); \n\tFrame2 defaultFrame2(Point2(1.0, 1.0), initialDir); \n\tdouble radius = 2.0;\n\tAMCAX::Circle2 circle2(defaultFrame2, radius);\n\tPoint2 p;\n\tVector2 v1, v2,v3;\n\tSECTION(\"u = M_PI\") {\n\t\tCurveCalculation::D3(M_PI, circle2, p, v1, v2,v3);\n\t\tCHECK(p.X() == -1.0);\n\t\tCHECK(p.Y() == Approx(1.0));\n\t\tCHECK(v1.X() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v1.Y() == -2.0);\n\t\tCHECK(v2.X() == 2.0);\n\t\tCHECK(v2.Y() == Approx(0.0).margin(1e-11));\n\t\tCHECK(v3.X() == Approx(0.0).margin(1e-12));\n\t\tCHECK(v3.Y() == 2.0);\n\t}\n}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static void D3(double u, const Circle2& circle, Point2& p, Vector2& v1, Vector2& v2, Vector2& v3)\t @param[out] v3 The third derivative\n\t @param[out] v2 The second derivative\n\t @param[out] v1 The first derivative\n\t @param[out] p The point\n\t @param[in] circle The circle\n\t @param[in] u The parameter\n\t @brief Compute the point and the first three derivatives on a 2D circle at a parameter\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <common/PointT.hpp>\n#include <math/CurveCalculation.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <geometry/MakeArcOfHyperbola2d.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <modeling/MakeEdge2d.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"case1: CurveCalculation::D3() circle2[2/20] \", \"[math][CurveCalculation][P1][D2]\") {\n\tDirection2 initialDir(1.0, 0.0); \n\tFrame2 defaultFrame2(Point2(1.0, 1.0), initialDir); \n\tdouble radius = 2.0;\n\tAMCAX::Circle2 circle2(defaultFrame2, radius);\n\tPoint2 p;\n\tVector2 v1, v2,v3;\n\tSECTION(\"u =0\") {\n\t\tCurveCalculation::D3(0.0, circle2, p, v1, v2,v3);\n\t\tCHECK(p.X() == 3.0);\n\t\tCHECK(p.Y() == 1.0);\n\t\tCHECK(v1.X() == 0.0);\n\t\tCHECK(v1.Y() == 2.0);\n\t\tCHECK(v2.X() == -2.0);\n\t\tCHECK(v2.Y() == 0.0);\n\t\tCHECK(v3.X() == 0.0);\n\t\tCHECK(v3.Y() == -2.0);\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] AMCAX_API static Vector2 D3(double u, const Circle2& circle)\t @return The third derivative vector\n\t @param circle The circle\n\t @param u The parameter\n\t @brief Compute the third derivative on a 2D circle at a parameter\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <common/PointT.hpp>\n#include <math/CurveCalculation.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <geometry/MakeArcOfHyperbola2d.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <modeling/MakeEdge2d.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"case1: CurveCalculation::D3() circle2[1/20] \", \"[math][CurveCalculation][P1][D2]\") {\n\tDirection2 initialDir(1.0, 0.0); \n\tFrame2 defaultFrame2(Point2(0.0, 0.0), initialDir); \n\tdouble radius = 2.0;\n\tAMCAX::Circle2 circle2(defaultFrame2, radius);\n\tSECTION(\"u =0\") {\n\t\tVector2 vector2 = CurveCalculation::D3(0.0, circle2);\n\t\tCHECK(vector2.X() == 0.0);\n\t\tCHECK(vector2.Y() == -2.0);\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static void D3(double u, const Line2& line, Point2& p, Vector2& v1, Vector2& v2, Vector2& v3)\t @param[out] v3 The third derivative\n\t @param[out] v2 The second derivative\n\t @param[out] v1 The first derivative\n\t @param[out] p The point\n\t @param[in] line The line\n\t @param[in] u The parameter\n\t @brief Compute the point and the first three derivatives on a 2D line at a parameter\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <common/PointT.hpp>\n#include <math/CurveCalculation.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <geometry/MakeArcOfHyperbola2d.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <modeling/MakeEdge2d.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"case1: CurveCalculation::D3() circle2[2/20] \", \"[math][CurveCalculation][P1][D2]\") {\n\tDirection2 initialDir(1.0, 0.0); \n\tFrame2 defaultFrame2(Point2(1.0, 1.0), initialDir); \n\tdouble radius = 2.0;\n\tAMCAX::Circle2 circle2(defaultFrame2, radius);\n\tPoint2 p;\n\tVector2 v1, v2,v3;\n\tSECTION(\"u =0\") {\n\t\tCurveCalculation::D3(0.0, circle2, p, v1, v2,v3);\n\t\tCHECK(p.X() == 3.0);\n\t\tCHECK(p.Y() == 1.0);\n\t\tCHECK(v1.X() == 0.0);\n\t\tCHECK(v1.Y() == 2.0);\n\t\tCHECK(v2.X() == -2.0);\n\t\tCHECK(v2.Y() == 0.0);\n\t\tCHECK(v3.X() == 0.0);\n\t\tCHECK(v3.Y() == -2.0);\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] AMCAX_API static Vector2 D3(double u, const Line2& line)\t @return The third derivative vector\n\t @param line The line\n\t @param u The parameter\n\t @brief Compute the third derivative on a 2D line at a parameter\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <common/PointT.hpp>\n#include <math/CurveCalculation.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <geometry/MakeArcOfHyperbola2d.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <modeling/MakeEdge2d.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"case1: CurveCalculation::D3() circle2[1/20] \", \"[math][CurveCalculation][P1][D2]\") {\n\tDirection2 initialDir(1.0, 0.0); \n\tFrame2 defaultFrame2(Point2(0.0, 0.0), initialDir); \n\tdouble radius = 2.0;\n\tAMCAX::Circle2 circle2(defaultFrame2, radius);\n\tSECTION(\"u =0\") {\n\t\tVector2 vector2 = CurveCalculation::D3(0.0, circle2);\n\t\tCHECK(vector2.X() == 0.0);\n\t\tCHECK(vector2.Y() == -2.0);\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static void D3(double u, const Ellipse3& ellipse, Point3& p, Vector3& v1, Vector3& v2, Vector3& v3)\t @param[out] v3 The third derivative\n\t @param[out] v2 The second derivative\n\t @param[out] v1 The first derivative\n\t @param[out] p The point\n\t @param[in] ellipse The ellipse\n\t @param[in] u The parameter\n\t @brief Compute the point and the first three derivatives on a 3D ellipse at a parameter\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <common/PointT.hpp>\n#include <math/CurveCalculation.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <geometry/MakeArcOfHyperbola2d.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <modeling/MakeEdge2d.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"case1: CurveCalculation::D3() circle3[4/20] \", \"[math][CurveCalculation][P1][D3]\") {\n\tDirection3 initialDir(0.0, 0.0, 1.0);\n\tFrame3 defaultFrame3(Point3(1.0, 1.0, 0.0), initialDir);\n\tdouble radius = 2.0; \n\tAMCAX::Circle3 circle3(defaultFrame3, radius);\n\tPoint3 p;\n\tVector3 v1, v2,v3;\n\tSECTION(\"u =0\") {\n\t\tCurveCalculation::D3(0.0, circle3, p, v1, v2,v3);\n\t\tCHECK(p.X() == 3.0);\n\t\tCHECK(p.Y() == 1.0);\n\t\tCHECK(p.Z() == 0.0);\n\t\tCHECK(v1.X() == Approx(0.0));\n\t\tCHECK(v1.Y() == Approx(2.0));\n\t\tCHECK(v1.Z() == Approx(0.0));\n\t\tCHECK(v2.X() == Approx(-2.0));\n\t\tCHECK(v2.Y() == Approx(0.0));\n\t\tCHECK(v2.Z() == Approx(0.0));\n\t\tCHECK(v3.X() == Approx(0.0));\n\t\tCHECK(v3.Y() == Approx(-2.0));\n\t\tCHECK(v3.Z() == Approx(0.0));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static void D3(double u, const Circle3& circle, Point3& p, Vector3& v1, Vector3& v2, Vector3& v3)\t @param[out] v3 The third derivative\n\t @param[out] v2 The second derivative\n\t @param[out] v1 The first derivative\n\t @param[out] p The point\n\t @param[in] circle The circle\n\t @param[in] u The parameter\n\t @brief Compute the point and the first three derivatives on a 3D circle at a parameter\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <common/PointT.hpp>\n#include <math/CurveCalculation.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <geometry/MakeArcOfHyperbola2d.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <modeling/MakeEdge2d.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"case1: CurveCalculation::D3() circle3[4/20] \", \"[math][CurveCalculation][P1][D3]\") {\n\tDirection3 initialDir(0.0, 0.0, 1.0);\n\tFrame3 defaultFrame3(Point3(1.0, 1.0, 0.0), initialDir);\n\tdouble radius = 2.0; \n\tAMCAX::Circle3 circle3(defaultFrame3, radius);\n\tPoint3 p;\n\tVector3 v1, v2,v3;\n\tSECTION(\"u =0\") {\n\t\tCurveCalculation::D3(0.0, circle3, p, v1, v2,v3);\n\t\tCHECK(p.X() == 3.0);\n\t\tCHECK(p.Y() == 1.0);\n\t\tCHECK(p.Z() == 0.0);\n\t\tCHECK(v1.X() == Approx(0.0));\n\t\tCHECK(v1.Y() == Approx(2.0));\n\t\tCHECK(v1.Z() == Approx(0.0));\n\t\tCHECK(v2.X() == Approx(-2.0));\n\t\tCHECK(v2.Y() == Approx(0.0));\n\t\tCHECK(v2.Z() == Approx(0.0));\n\t\tCHECK(v3.X() == Approx(0.0));\n\t\tCHECK(v3.Y() == Approx(-2.0));\n\t\tCHECK(v3.Z() == Approx(0.0));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] AMCAX_API static Vector3 D3(double u, const Circle3& circle)\t @return The third derivative vector\n\t @param circle The circle\n\t @param u The parameter\n\t @brief Compute the third derivative on a 3D circle at a parameter\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <common/PointT.hpp>\n#include <math/CurveCalculation.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <geometry/MakeArcOfHyperbola2d.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <modeling/MakeEdge2d.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"case1: CurveCalculation::D3() circle3[3/20] \", \"[math][CurveCalculation][P1][D3]\") {\n\tDirection3 initialDir(0.0, 0.0, 1.0); \n\tFrame3 defaultFrame3(Point3(1.0, 0.0, 0.0), initialDir); \n\tdouble radius = 2.0; \n\tAMCAX::Circle3 circle3(defaultFrame3, radius);\n\tSECTION(\"u =0\") {\n\t\tVector3 vector3 = CurveCalculation::D3(0.0, circle3);\n\t\tCHECK(vector3.X() == 0.0);\n\t\tCHECK(vector3.Y() == -2.0);\n\t\tCHECK(vector3.Z() == 0.0);\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static void D3(double u, const Line3& line, Point3& p, Vector3& v1, Vector3& v2, Vector3& v3)\t @param[out] v3 The third derivative\n\t @param[out] v2 The second derivative\n\t @param[out] v1 The first derivative\n\t @param[out] p The point\n\t @param[in] line The line\n\t @param[in] u The parameter\n\t @brief Compute the point and the first three derivatives on a 3D line at a parameter\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <common/PointT.hpp>\n#include <math/CurveCalculation.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <geometry/MakeArcOfHyperbola2d.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <modeling/MakeEdge2d.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"case1: CurveCalculation::D3() circle3[4/20] \", \"[math][CurveCalculation][P1][D3]\") {\n\tDirection3 initialDir(0.0, 0.0, 1.0);\n\tFrame3 defaultFrame3(Point3(1.0, 1.0, 0.0), initialDir);\n\tdouble radius = 2.0; \n\tAMCAX::Circle3 circle3(defaultFrame3, radius);\n\tPoint3 p;\n\tVector3 v1, v2,v3;\n\tSECTION(\"u =0\") {\n\t\tCurveCalculation::D3(0.0, circle3, p, v1, v2,v3);\n\t\tCHECK(p.X() == 3.0);\n\t\tCHECK(p.Y() == 1.0);\n\t\tCHECK(p.Z() == 0.0);\n\t\tCHECK(v1.X() == Approx(0.0));\n\t\tCHECK(v1.Y() == Approx(2.0));\n\t\tCHECK(v1.Z() == Approx(0.0));\n\t\tCHECK(v2.X() == Approx(-2.0));\n\t\tCHECK(v2.Y() == Approx(0.0));\n\t\tCHECK(v2.Z() == Approx(0.0));\n\t\tCHECK(v3.X() == Approx(0.0));\n\t\tCHECK(v3.Y() == Approx(-2.0));\n\t\tCHECK(v3.Z() == Approx(0.0));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] AMCAX_API static Vector3 D3(double u, const Line3& line)\t @return The third derivative vector\n\t @param line The line\n\t @param u The parameter\n\t @brief Compute the third derivative on a 3D line at a parameter\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <common/PointT.hpp>\n#include <math/CurveCalculation.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <geometry/MakeArcOfHyperbola2d.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <modeling/MakeEdge2d.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"case1: CurveCalculation::D3() circle3[3/20] \", \"[math][CurveCalculation][P1][D3]\") {\n\tDirection3 initialDir(0.0, 0.0, 1.0); \n\tFrame3 defaultFrame3(Point3(1.0, 0.0, 0.0), initialDir); \n\tdouble radius = 2.0; \n\tAMCAX::Circle3 circle3(defaultFrame3, radius);\n\tSECTION(\"u =0\") {\n\t\tVector3 vector3 = CurveCalculation::D3(0.0, circle3);\n\t\tCHECK(vector3.X() == 0.0);\n\t\tCHECK(vector3.Y() == -2.0);\n\t\tCHECK(vector3.Z() == 0.0);\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static void D2(double u, const Hyperbola2& hyperbola, Point2& p, Vector2& v1, Vector2& v2)\t @param[out] v2 The second derivative\n\t @param[out] v1 The first derivative\n\t @param[out] p The point\n\t @param[in] hyperbola The hyperbola\n\t @param[in] u The parameter\n\t @brief Compute the point and the first two derivatives on a 2D hyperbola at a parameter\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <common/PointT.hpp>\n#include <math/CurveCalculation.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <geometry/MakeArcOfHyperbola2d.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <modeling/MakeEdge2d.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"case1: CurveCalculation::D2() hyperbola2[10/20] \", \"[math][CurveCalculation][P1][D2]\") {\n\tAxis2 majorAxis;\n\tdouble major_radius = 5;\n\tdouble minor_radius = 3;\n\tHyperbola2 hyperbola2(majorAxis, major_radius, minor_radius); \n\tPoint2 p;\n\tVector2 v1,v2;\n\tCurveCalculation::D2(0.0, hyperbola2, p, v1,v2); \n\tCHECK(p.X() == 5.0);\n\tCHECK(p.Y() == 0.0);\n\tCHECK(v1.X() == 0.0);\n\tCHECK(v1.Y() == 3.0);\n\tCHECK(v2.X() == 5.0);\n\tCHECK(v2.Y() == 0.0);\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] AMCAX_API static Vector2 D2(double u, const Hyperbola2& hyperbola)\t @return The second derivative vector\n\t @param hyperbola The hyperbola\n\t @param u The parameter\n\t @brief Compute the second derivative on a 2D hyperbola at a parameter\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <common/PointT.hpp>\n#include <math/CurveCalculation.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <geometry/MakeArcOfHyperbola2d.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <modeling/MakeEdge2d.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"case1: CurveCalculation::D2() hyperbola2[9/20] \", \"[math][CurveCalculation][P1][D2]\") {\n\tAxis2 majorAxis;\n\tdouble major_radius = 5;\n\tdouble minor_radius = 3;\n\tHyperbola2 hyperbola2(majorAxis, major_radius, minor_radius); \n\tVector2 vector2 = CurveCalculation::D2(0.0, hyperbola2); \n\tCHECK(vector2.X() == 5.0);\n\tCHECK(vector2.Y() == 0.0);\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static void D2(double u, const Parabola2& parabola, Point2& p, Vector2& v1, Vector2& v2)\t @param[out] v2 The second derivative\n\t @param[out] v1 The first derivative\n\t @param[out] p The point\n\t @param[in] parabola The parabola\n\t @param[in] u The parameter\n\t @brief Compute the point and the first two derivatives on a 2D parabola at a parameter\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <common/PointT.hpp>\n#include <math/CurveCalculation.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <geometry/MakeArcOfHyperbola2d.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <modeling/MakeEdge2d.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"case1: CurveCalculation::D2() parabola2 [18/20] \", \"[math][CurveCalculation][P1][D2][kk]\") {\n\tAMCAX::Point2 P(0.0, 0.0);\n\tAMCAX::Direction2 D(1.0, 0.0); \n\tAMCAX::Axis2  axis2(P, D);\n\tdouble focal = 2.0;\n\tAMCAX::Parabola2 parabola2(axis2, focal);\n\tPoint2 p;\n\tVector2 v1,v2;\n\tSECTION(\"u =0\") {\n\t\tCurveCalculation::D2(0.0, parabola2, p, v1,v2);\n\t\tCHECK(p.X() == 0.0);\n\t\tCHECK(p.Y() == 0.0);\n\t\tCHECK(v1.X() == 0.0);\n\t\tCHECK(v1.Y() == 1.0);\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] AMCAX_API static Vector2 D2(double u, const Parabola2& parabola)\t @return The second derivative vector\n\t @param parabola The parabola\n\t @param u The parameter\n\t @brief Compute the second derivative on a 2D parabola at a parameter\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <common/PointT.hpp>\n#include <math/CurveCalculation.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <geometry/MakeArcOfHyperbola2d.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <modeling/MakeEdge2d.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"case1: CurveCalculation::D2() circle2[1/20] \", \"[math][CurveCalculation][P1][D2]\") {\n\tDirection2 initialDir(1.0, 0.0); \n\tFrame2 defaultFrame2(Point2(1.0, 1.0), initialDir); \n\tdouble radius = 2.0;\n\tAMCAX::Circle2 circle2(defaultFrame2, radius);\n\tSECTION(\"u =0\") {\n\t\tVector2 vector2 = CurveCalculation::D2(0.0, circle2);\n\t\tCHECK(vector2.X() == -2.0);\n\t\tCHECK(vector2.Y() == 0.0);\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static void D2(double u, const Ellipse2& ellipse, Point2& p, Vector2& v1, Vector2& v2)\t @param[out] v2 The second derivative\n\t @param[out] v1 The first derivative\n\t @param[out] p The point\n\t @param[in] ellipse The ellipse\n\t @param[in] u The parameter\n\t @brief Compute the point and the first two derivatives on a 2D ellipse at a parameter\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <common/PointT.hpp>\n#include <math/CurveCalculation.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <geometry/MakeArcOfHyperbola2d.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <modeling/MakeEdge2d.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"case1: CurveCalculation::D2() circle2[2/20] \", \"[math][CurveCalculation][P1][D2]\") {\n\tDirection2 initialDir(1.0, 0.0); \n\tFrame2 defaultFrame2(Point2(1.0, 1.0), initialDir); \n\tdouble radius = 2.0;\n\tAMCAX::Circle2 circle2(defaultFrame2, radius);\n\tPoint2 p;\n\tVector2 v1,v2;\n\tSECTION(\"u =0\") {\n\t\tCurveCalculation::D2(0.0, circle2, p, v1,v2);\n\t\tCHECK(p.X() == 3.0);\n\t\tCHECK(p.Y() == 1.0);\n\t\tCHECK(v1.X() == 0.0);\n\t\tCHECK(v1.Y() == 2.0);\n\t\tCHECK(v2.X() == -2.0);\n\t\tCHECK(v2.Y() == 0.0);\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] AMCAX_API static Vector2 D2(double u, const Ellipse2& ellipse)\t @return The second derivative vector\n\t @param ellipse The ellipse\n\t @param u The parameter\n\t @brief Compute the second derivative on a 2D ellipse at a parameter\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <common/PointT.hpp>\n#include <math/CurveCalculation.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <geometry/MakeArcOfHyperbola2d.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <modeling/MakeEdge2d.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"case1: CurveCalculation::D2() circle2[1/20] \", \"[math][CurveCalculation][P1][D2]\") {\n\tDirection2 initialDir(1.0, 0.0); \n\tFrame2 defaultFrame2(Point2(1.0, 1.0), initialDir); \n\tdouble radius = 2.0;\n\tAMCAX::Circle2 circle2(defaultFrame2, radius);\n\tSECTION(\"u =0\") {\n\t\tVector2 vector2 = CurveCalculation::D2(0.0, circle2);\n\t\tCHECK(vector2.X() == -2.0);\n\t\tCHECK(vector2.Y() == 0.0);\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static void D2(double u, const Circle2& circle, Point2& p, Vector2& v1, Vector2& v2)\t @param[out] v2 The second derivative\n\t @param[out] v1 The first derivative\n\t @param[out] p The point\n\t @param[in] circle The circle\n\t @param[in] u The parameter\n\t @brief Compute the point and the first two derivatives on a 2D circle at a parameter\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <common/PointT.hpp>\n#include <math/CurveCalculation.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <geometry/MakeArcOfHyperbola2d.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <modeling/MakeEdge2d.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"case1: CurveCalculation::D2() circle2[1/20] \", \"[math][CurveCalculation][P1][D2]\") {\n\tDirection2 initialDir(1.0, 0.0); \n\tFrame2 defaultFrame2(Point2(1.0, 1.0), initialDir); \n\tdouble radius = 2.0;\n\tAMCAX::Circle2 circle2(defaultFrame2, radius);\n\tSECTION(\"u =0\") {\n\t\tVector2 vector2 = CurveCalculation::D2(0.0, circle2);\n\t\tCHECK(vector2.X() == -2.0);\n\t\tCHECK(vector2.Y() == 0.0);\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] AMCAX_API static Vector2 D2(double u, const Circle2& circle)\t @return The second derivative vector\n\t @param circle The circle\n\t @param u The parameter\n\t @brief Compute the second derivative on a 2D circle at a parameter\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <common/PointT.hpp>\n#include <math/CurveCalculation.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <geometry/MakeArcOfHyperbola2d.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <modeling/MakeEdge2d.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"case1: CurveCalculation::D2() circle2[1/20] \", \"[math][CurveCalculation][P1][D2]\") {\n\tDirection2 initialDir(1.0, 0.0); \n\tFrame2 defaultFrame2(Point2(1.0, 1.0), initialDir); \n\tdouble radius = 2.0;\n\tAMCAX::Circle2 circle2(defaultFrame2, radius);\n\tSECTION(\"u =0\") {\n\t\tVector2 vector2 = CurveCalculation::D2(0.0, circle2);\n\t\tCHECK(vector2.X() == -2.0);\n\t\tCHECK(vector2.Y() == 0.0);\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static void D2(double u, const Line2& line, Point2& p, Vector2& v1, Vector2& v2)\t @param[out] v2 The second derivative\n\t @param[out] v1 The first derivative\n\t @param[out] p The point\n\t @param[in] line The line\n\t @param[in] u The parameter\n\t @brief Compute the point and the first two derivatives on a 2D line at a parameter\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <common/PointT.hpp>\n#include <math/CurveCalculation.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <geometry/MakeArcOfHyperbola2d.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <modeling/MakeEdge2d.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"case1: CurveCalculation::D2() circle2[2/20] \", \"[math][CurveCalculation][P1][D2]\") {\n\tDirection2 initialDir(1.0, 0.0); \n\tFrame2 defaultFrame2(Point2(1.0, 1.0), initialDir); \n\tdouble radius = 2.0;\n\tAMCAX::Circle2 circle2(defaultFrame2, radius);\n\tPoint2 p;\n\tVector2 v1,v2;\n\tSECTION(\"u =0\") {\n\t\tCurveCalculation::D2(0.0, circle2, p, v1,v2);\n\t\tCHECK(p.X() == 3.0);\n\t\tCHECK(p.Y() == 1.0);\n\t\tCHECK(v1.X() == 0.0);\n\t\tCHECK(v1.Y() == 2.0);\n\t\tCHECK(v2.X() == -2.0);\n\t\tCHECK(v2.Y() == 0.0);\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] AMCAX_API static Vector2 D2(double u, const Line2& line)\t @return The second derivative vector\n\t @param line The line\n\t @param u The parameter\n\t @brief Compute the second derivative on a 2D line at a parameter\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <common/PointT.hpp>\n#include <math/CurveCalculation.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <geometry/MakeArcOfHyperbola2d.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <modeling/MakeEdge2d.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"case1: CurveCalculation::D2() circle2[1/20] \", \"[math][CurveCalculation][P1][D2]\") {\n\tDirection2 initialDir(1.0, 0.0); \n\tFrame2 defaultFrame2(Point2(1.0, 1.0), initialDir); \n\tdouble radius = 2.0;\n\tAMCAX::Circle2 circle2(defaultFrame2, radius);\n\tSECTION(\"u =0\") {\n\t\tVector2 vector2 = CurveCalculation::D2(0.0, circle2);\n\t\tCHECK(vector2.X() == -2.0);\n\t\tCHECK(vector2.Y() == 0.0);\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static void D2(double u, const Hyperbola3& hyperbola, Point3& p, Vector3& v1, Vector3& v2)\t @param[out] v2 The second derivative\n\t @param[out] v1 The first derivative\n\t @param[out] p The point\n\t @param[in] hyperbola The hyperbola\n\t @param[in] u The parameter\n\t @brief Compute the point and the first two derivatives on a 3D hyperbola at a parameter\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <common/PointT.hpp>\n#include <math/CurveCalculation.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <geometry/MakeArcOfHyperbola2d.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <modeling/MakeEdge2d.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"case1: CurveCalculation::D2() hyperbola3[11/20] \", \"[math][CurveCalculation][P1][D2]\") {\n\tDirection3 dir3(0.0, 0.0, 1.0);\n\tPoint3 point3(0.0, 0.0, 0.0);\n\tFrame3 frame3(point3, dir3);\n\tHyperbola3 hyperbola3(frame3, 5.0, 3.0); \n\tVector3 vector3 = CurveCalculation::D2(0.0, hyperbola3); \n\tCHECK(vector3.X() == 5.0);\n\tCHECK(vector3.Y() == 0.0);\n\tCHECK(vector3.Z() == 0.0);\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] AMCAX_API static Vector3 D2(double u, const Hyperbola3& hyperbola)\t @return The second derivative vector\n\t @param hyperbola The hyperbola\n\t @param u The parameter\n\t @brief Compute the second derivative on a 3D hyperbola at a parameter\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <common/PointT.hpp>\n#include <math/CurveCalculation.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <geometry/MakeArcOfHyperbola2d.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <modeling/MakeEdge2d.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"case1: CurveCalculation::D2() hyperbola3[11/20] \", \"[math][CurveCalculation][P1][D2]\") {\n\tDirection3 dir3(0.0, 0.0, 1.0);\n\tPoint3 point3(0.0, 0.0, 0.0);\n\tFrame3 frame3(point3, dir3);\n\tHyperbola3 hyperbola3(frame3, 5.0, 3.0); \n\tVector3 vector3 = CurveCalculation::D2(0.0, hyperbola3); \n\tCHECK(vector3.X() == 5.0);\n\tCHECK(vector3.Y() == 0.0);\n\tCHECK(vector3.Z() == 0.0);\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static void D2(double u, const Parabola3& parabola, Point3& p, Vector3& v1, Vector3& v2)\t @param[out] v2 The second derivative\n\t @param[out] v1 The first derivative\n\t @param[out] p The point\n\t @param[in] parabola The parabola\n\t @param[in] u The parameter\n\t @brief Compute the point and the first two derivatives on a 3D parabola at a parameter\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <common/PointT.hpp>\n#include <math/CurveCalculation.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <geometry/MakeArcOfHyperbola2d.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <modeling/MakeEdge2d.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"case1: CurveCalculation::D2() parabola2 [19/20] \", \"[math][CurveCalculation][P1][D2]\") {\n\tPoint3 point3(0.0, 0.0, 0.0);\n\tDirection3 dir3(0.0, 0.0, 1.0);\n\tFrame3 fram3(point3, dir3);\n\tdouble focal = 2.0;\n\tParabola3 parabola3(fram3, focal);\n\tSECTION(\"u =0\") {\n\t\tVector3 vector3 = CurveCalculation::D2(0.0, parabola3);\n\t\tCHECK(vector3.X() == 0.25);\n\t\tCHECK(vector3.Y() == 0.0);\n\t\tCHECK(vector3.Z() == 0.0);\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] AMCAX_API static Vector3 D2(double u, const Parabola3& parabola)\t @return The second derivative vector\n\t @param parabola The parabola\n\t @param u The parameter\n\t @brief Compute the second derivative on a 3D parabola at a parameter\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <common/PointT.hpp>\n#include <math/CurveCalculation.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <geometry/MakeArcOfHyperbola2d.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <modeling/MakeEdge2d.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"case1: CurveCalculation::D2() parabola2 [19/20] \", \"[math][CurveCalculation][P1][D2]\") {\n\tPoint3 point3(0.0, 0.0, 0.0);\n\tDirection3 dir3(0.0, 0.0, 1.0);\n\tFrame3 fram3(point3, dir3);\n\tdouble focal = 2.0;\n\tParabola3 parabola3(fram3, focal);\n\tSECTION(\"u =0\") {\n\t\tVector3 vector3 = CurveCalculation::D2(0.0, parabola3);\n\t\tCHECK(vector3.X() == 0.25);\n\t\tCHECK(vector3.Y() == 0.0);\n\t\tCHECK(vector3.Z() == 0.0);\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static void D2(double u, const Ellipse3& ellipse, Point3& p, Vector3& v1, Vector3& v2)\t @param[out] v2 The second derivative\n\t @param[out] v1 The first derivative\n\t @param[out] p The point\n\t @param[in] ellipse The ellipse\n\t @param[in] u The parameter\n\t @brief Compute the point and the first two derivatives on a 3D ellipse at a parameter\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <common/PointT.hpp>\n#include <math/CurveCalculation.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <geometry/MakeArcOfHyperbola2d.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <modeling/MakeEdge2d.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"case1: CurveCalculation::D2() circle3[4/20] \", \"[math][CurveCalculation][P1][D2]\") {\n\tDirection3 initialDir(0.0, 0.0, 1.0);\n\tFrame3 defaultFrame3(Point3(1.0, 1.0, 0.0), initialDir);\n\tdouble radius = 2.0; \n\tAMCAX::Circle3 circle3(defaultFrame3, radius);\n\tPoint3 p;\n\tVector3 v1, v2;\n\tSECTION(\"u =0\") {\n\t\tCurveCalculation::D2(0.0, circle3, p, v1,v2);\n\t\tCHECK(p.X() == 3.0);\n\t\tCHECK(p.Y() == 1.0);\n\t\tCHECK(p.Z() == 0.0);\n\t\tCHECK(v1.X() == Approx(0.0));\n\t\tCHECK(v1.Y() == Approx(2.0));\n\t\tCHECK(v1.Z() == Approx(0.0));\n\t\tCHECK(v2.X() == Approx(-2.0));\n\t\tCHECK(v2.Y() == Approx(0.0));\n\t\tCHECK(v2.Z() == Approx(0.0));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] AMCAX_API static Vector3 D2(double u, const Ellipse3& ellipse)\t @return The second derivative vector\n\t @param ellipse The ellipse\n\t @param u The parameter\n\t @brief Compute the second derivative on a 3D ellipse at a parameter\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <common/PointT.hpp>\n#include <math/CurveCalculation.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <geometry/MakeArcOfHyperbola2d.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <modeling/MakeEdge2d.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"case1: CurveCalculation::D2() ellipse3[7/20] \", \"[math][CurveCalculation][P1][D2]\") {\n\tDirection3 initialDir(0.0, 0.0, 1.0); \n\tFrame3 defaultFrame3(Point3(0.0, 0.0, 0.0), initialDir); \n\tEllipse3 ellipse3(defaultFrame3, 5.0, 3.0);\n\tSECTION(\"u =0\") {\n\t\tVector3 vector3 = CurveCalculation::D2(0.0, ellipse3);\n\t\tCHECK(vector3.X() == Approx(-5.0));\n\t\tCHECK(vector3.Y() == Approx(0.0));\n\t\tCHECK(vector3.Z() == Approx(0.0));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static void D2(double u, const Circle3& circle, Point3& p, Vector3& v1, Vector3& v2)\t @param[out] v2 The second derivative\n\t @param[out] v1 The first derivative\n\t @param[out] p The point\n\t @param[in] circle The circle\n\t @param[in] u The parameter\n\t @brief Compute the point and the first two derivatives on a 3D circle at a parameter\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <common/PointT.hpp>\n#include <math/CurveCalculation.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <geometry/MakeArcOfHyperbola2d.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <modeling/MakeEdge2d.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"case1: CurveCalculation::D2() circle3[4/20] \", \"[math][CurveCalculation][P1][D2]\") {\n\tDirection3 initialDir(0.0, 0.0, 1.0);\n\tFrame3 defaultFrame3(Point3(1.0, 1.0, 0.0), initialDir);\n\tdouble radius = 2.0; \n\tAMCAX::Circle3 circle3(defaultFrame3, radius);\n\tPoint3 p;\n\tVector3 v1, v2;\n\tSECTION(\"u =0\") {\n\t\tCurveCalculation::D2(0.0, circle3, p, v1,v2);\n\t\tCHECK(p.X() == 3.0);\n\t\tCHECK(p.Y() == 1.0);\n\t\tCHECK(p.Z() == 0.0);\n\t\tCHECK(v1.X() == Approx(0.0));\n\t\tCHECK(v1.Y() == Approx(2.0));\n\t\tCHECK(v1.Z() == Approx(0.0));\n\t\tCHECK(v2.X() == Approx(-2.0));\n\t\tCHECK(v2.Y() == Approx(0.0));\n\t\tCHECK(v2.Z() == Approx(0.0));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] AMCAX_API static Vector3 D2(double u, const Circle3& circle)\t @return The second derivative vector\n\t @param circle The circle\n\t @param u The parameter\n\t @brief Compute the second derivative on a 3D circle at a parameter\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <common/PointT.hpp>\n#include <math/CurveCalculation.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <geometry/MakeArcOfHyperbola2d.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <modeling/MakeEdge2d.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"case1: CurveCalculation::D2() circle3[3/20] \", \"[math][CurveCalculation][P1][D2]\") {\n\tDirection3 initialDir(0.0, 0.0, 1.0); \n\tFrame3 defaultFrame3(Point3(1.0, 0.0, 0.0), initialDir); \n\tdouble radius = 2.0; \n\tAMCAX::Circle3 circle3(defaultFrame3, radius);\n\tSECTION(\"u =0\") {\n\t\tVector3 vector3 = CurveCalculation::D2(0.0, circle3);\n\t\tCHECK(vector3.X() == -2.0 );\n\t\tCHECK(vector3.Y() == 0.0 );\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static void D2(double u, const Line3& line, Point3& p, Vector3& v1, Vector3& v2)\t @param[out] v2 The second derivative\n\t @param[out] v1 The first derivative\n\t @param[out] p The point\n\t @param[in] line The line\n\t @param[in] u The parameter\n\t @brief Compute the point and the first two derivatives on a 3D line at a parameter\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <common/PointT.hpp>\n#include <math/CurveCalculation.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <geometry/MakeArcOfHyperbola2d.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <modeling/MakeEdge2d.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"case1: CurveCalculation::D2() circle3[4/20] \", \"[math][CurveCalculation][P1][D2]\") {\n\tDirection3 initialDir(0.0, 0.0, 1.0);\n\tFrame3 defaultFrame3(Point3(1.0, 1.0, 0.0), initialDir);\n\tdouble radius = 2.0; \n\tAMCAX::Circle3 circle3(defaultFrame3, radius);\n\tPoint3 p;\n\tVector3 v1, v2;\n\tSECTION(\"u =0\") {\n\t\tCurveCalculation::D2(0.0, circle3, p, v1,v2);\n\t\tCHECK(p.X() == 3.0);\n\t\tCHECK(p.Y() == 1.0);\n\t\tCHECK(p.Z() == 0.0);\n\t\tCHECK(v1.X() == Approx(0.0));\n\t\tCHECK(v1.Y() == Approx(2.0));\n\t\tCHECK(v1.Z() == Approx(0.0));\n\t\tCHECK(v2.X() == Approx(-2.0));\n\t\tCHECK(v2.Y() == Approx(0.0));\n\t\tCHECK(v2.Z() == Approx(0.0));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] AMCAX_API static Vector3 D2(double u, const Line3& line)\t @return The second derivative vector\n\t @param line The line\n\t @param u The parameter\n\t @brief Compute the second derivative on a 3D line at a parameter\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <common/PointT.hpp>\n#include <math/CurveCalculation.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <geometry/MakeArcOfHyperbola2d.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <modeling/MakeEdge2d.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"case1: CurveCalculation::D2() circle3[3/20] \", \"[math][CurveCalculation][P1][D2]\") {\n\tDirection3 initialDir(0.0, 0.0, 1.0); \n\tFrame3 defaultFrame3(Point3(1.0, 0.0, 0.0), initialDir); \n\tdouble radius = 2.0; \n\tAMCAX::Circle3 circle3(defaultFrame3, radius);\n\tSECTION(\"u =0\") {\n\t\tVector3 vector3 = CurveCalculation::D2(0.0, circle3);\n\t\tCHECK(vector3.X() == -2.0 );\n\t\tCHECK(vector3.Y() == 0.0 );\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static void D1(double u, const Hyperbola2& hyperbola, Point2& p, Vector2& v1)\t @param[out] v1 The first derivative\n\t @param[out] p The point\n\t @param[in] hyperbola The hyperbola\n\t @param[in] u The parameter\n\t @brief Compute the point and the first derivative on a 2D hyperbola at a parameter\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <common/PointT.hpp>\n#include <math/CurveCalculation.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <geometry/MakeArcOfHyperbola2d.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <modeling/MakeEdge2d.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"case1: CurveCalculation::D1() Hyperbola2 [10/20] \", \"[math][CurveCalculation][P1][D1]\") {\n\tAxis2 majorAxis;\n\tdouble major_radius = 5;\n\tdouble minor_radius = 3;\n\tHyperbola2 hyperbola2(majorAxis, major_radius, minor_radius); \n\tPoint2 p;\n\tVector2 v;\n\tCurveCalculation::D1(0.0, hyperbola2,p,v); \n\tCHECK(p.X() == 5.0);\n\tCHECK(p.Y() == 0.0);\n\tCHECK(v.X() == 0.0);\n\tCHECK(v.Y() == 3.0);\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] AMCAX_API static Vector2 D1(double u, const Hyperbola2& hyperbola)\t @return The first derivative vector\n\t @param hyperbola The hyperbola\n\t @param u The parameter\n\t @brief Compute the first derivative on a 2D hyperbola at a parameter\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <common/PointT.hpp>\n#include <math/CurveCalculation.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <geometry/MakeArcOfHyperbola2d.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <modeling/MakeEdge2d.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"case1: CurveCalculation::D1() Hyperbola2 [9/20] \", \"[math][CurveCalculation][P1][D1]\") {\n\tAxis2 majorAxis;\n\tdouble major_radius = 5;\n\tdouble minor_radius = 3;\n\tHyperbola2 hyperbola2(majorAxis, major_radius, minor_radius); \n\t Vector2 vector2 = CurveCalculation::D1(0.0, hyperbola2); \n\tCHECK(vector2.X() == 0.0);\n\tCHECK(vector2.Y() == 3.0);\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static void D1(double u, const Parabola2& parabola, Point2& p, Vector2& v1)\t @param[out] v1 The first derivative\n\t @param[out] p The point\n\t @param[in] parabola The parabola\n\t @param[in] u The parameter\n\t @brief Compute the point and the first derivative on a 2D parabola at a parameter\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <common/PointT.hpp>\n#include <math/CurveCalculation.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <geometry/MakeArcOfHyperbola2d.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <modeling/MakeEdge2d.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"case1: CurveCalculation::D1() ellipse3 [8/20] \", \"[math][CurveCalculation][P1][D1]\") {\n\tDirection3 initialDir(0.0, 0.0, 1.0); \n\tFrame3 defaultFrame3(Point3(0.0, 0.0, 0.0), initialDir); \n\tEllipse3 ellipse3(defaultFrame3, 5.0, 3.0);\n\tPoint3 p;\n\tVector3 v;\n\tMakeEdge edge = MakeEdge(ellipse3);\n\tbool bWriteresult = OCCTIO::OCCTTool::Write(edge, OUTPUT_PATH_PREFIX\"ellipse3CurveCalculation_case1.brep\", true, 3);\n\tSECTION(\"u = M_PI_2\") {\n\t\tCurveCalculation::D1(M_PI_2, ellipse3,p,v);\n\t\tCHECK(p.X() == Approx(0.0).margin(1e-12));\n\t\tCHECK(p.Y() == 3.0);\n\t\tCHECK(p.Z() == 0.0);\n\t\tCHECK(v.X() == Approx(-5.0));\n\t\tCHECK(v.Y() == Approx(0.0).margin(1e-14));\n\t\tCHECK(v.Z() == Approx(0.0));\n\t}\n}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] AMCAX_API static Vector2 D1(double u, const Parabola2& parabola)\t @return The first derivative vector\n\t @param parabola The parabola\n\t @param u The parameter\n\t @brief Compute the first derivative on a 2D parabola at a parameter\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <common/PointT.hpp>\n#include <math/CurveCalculation.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <geometry/MakeArcOfHyperbola2d.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <modeling/MakeEdge2d.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"case1: CurveCalculation::D1() circle2[1/20] \", \"[math][CurveCalculation][P1][D1]\") {\n\tDirection2 initialDir(1.0, 0.0); \n\tFrame2 defaultFrame2(Point2(1.0, 1.0), initialDir); \n    double radius = 2.0;\n    AMCAX::Circle2 circle2(defaultFrame2,radius);\n\tSECTION(\"u = M_PI\") {\n\t\tVector2 vector2 = CurveCalculation::D1(M_PI, circle2);\n\t\tCHECK(vector2.X() == Approx(-0.0).margin(1e-12));\n\t\tCHECK(vector2.Y() == -2.0);\n\t}\n}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static void D1(double u, const Ellipse2& ellipse, Point2& p, Vector2& v1)\t @param[out] v1 The first derivative\n\t @param[out] p The point\n\t @param[in] ellipse The ellipse\n\t @param[in] u The parameter\n\t @brief Compute the point and the first derivative on a 2D ellipse at a parameter\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <common/PointT.hpp>\n#include <math/CurveCalculation.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <geometry/MakeArcOfHyperbola2d.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <modeling/MakeEdge2d.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"case1: CurveCalculation::D1() circle2[2/20] \", \"[math][CurveCalculation][P1][D1]\") {\n\tDirection2 initialDir(1.0, 0.0); \n\tFrame2 defaultFrame2(Point2(1.0, 1.0), initialDir); \n\tdouble radius = 2.0;\n\tAMCAX::Circle2 circle2(defaultFrame2, radius);\n\tPoint2 p;\n\tVector2 v;\n\tSECTION(\"u =0\") {\n\t\tCurveCalculation::D1(0.0, circle2,p,v);\n\t\tCHECK(p.X() == 3.0);\n\t\tCHECK(p.Y() == 1.0);\n\t\tCHECK(v.X() == Approx(0.0));\n\t\tCHECK(v.Y() == Approx(2.0));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] AMCAX_API static Vector2 D1(double u, const Ellipse2& ellipse)\t @return The first derivative vector\n\t @param ellipse The ellipse\n\t @param u The parameter\n\t @brief Compute the first derivative on a 2D ellipse at a parameter\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <common/PointT.hpp>\n#include <math/CurveCalculation.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <geometry/MakeArcOfHyperbola2d.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <modeling/MakeEdge2d.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"case1: CurveCalculation::D1() circle2[1/20] \", \"[math][CurveCalculation][P1][D1]\") {\n\tDirection2 initialDir(1.0, 0.0); \n\tFrame2 defaultFrame2(Point2(1.0, 1.0), initialDir); \n    double radius = 2.0;\n    AMCAX::Circle2 circle2(defaultFrame2,radius);\n\tSECTION(\"u = M_PI\") {\n\t\tVector2 vector2 = CurveCalculation::D1(M_PI, circle2);\n\t\tCHECK(vector2.X() == Approx(-0.0).margin(1e-12));\n\t\tCHECK(vector2.Y() == -2.0);\n\t}\n}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static void D1(double u, const Circle2& circle, Point2& p, Vector2& v1)\t @param[out] v1 The first derivative\n\t @param[out] p The point\n\t @param[in] circle The circle\n\t @param[in] u The parameter\n\t @brief Compute the point and the first derivative on a 2D circle at a parameter\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <common/PointT.hpp>\n#include <math/CurveCalculation.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <geometry/MakeArcOfHyperbola2d.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <modeling/MakeEdge2d.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"case1: CurveCalculation::D1() circle2[1/20] \", \"[math][CurveCalculation][P1][D1]\") {\n\tDirection2 initialDir(1.0, 0.0); \n\tFrame2 defaultFrame2(Point2(1.0, 1.0), initialDir); \n    double radius = 2.0;\n    AMCAX::Circle2 circle2(defaultFrame2,radius);\n\tSECTION(\"u = M_PI\") {\n\t\tVector2 vector2 = CurveCalculation::D1(M_PI, circle2);\n\t\tCHECK(vector2.X() == Approx(-0.0).margin(1e-12));\n\t\tCHECK(vector2.Y() == -2.0);\n\t}\n}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] AMCAX_API static Vector2 D1(double u, const Circle2& circle)\t @return The first derivative vector\n\t @param circle The circle\n\t @param u The parameter\n\t @brief Compute the first derivative on a 2D circle at a parameter\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <common/PointT.hpp>\n#include <math/CurveCalculation.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <geometry/MakeArcOfHyperbola2d.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <modeling/MakeEdge2d.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"case1: CurveCalculation::D1() circle2[1/20] \", \"[math][CurveCalculation][P1][D1]\") {\n\tDirection2 initialDir(1.0, 0.0); \n\tFrame2 defaultFrame2(Point2(1.0, 1.0), initialDir); \n    double radius = 2.0;\n    AMCAX::Circle2 circle2(defaultFrame2,radius);\n\tSECTION(\"u =0\") {\n\t\tVector2 vector2 = CurveCalculation::D1(0.0, circle2);\n\t\tCHECK(vector2.X() == Approx(-0.0));\n\t\tCHECK(vector2.Y() == 2.0);\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static void D1(double u, const Line2& line, Point2& p, Vector2& v1)\t @param[out] v1 The first derivative\n\t @param[out] p The point\n\t @param[in] line The line\n\t @param[in] u The parameter\n\t @brief Compute the point and the first derivative on a 2D line at a parameter\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <common/PointT.hpp>\n#include <math/CurveCalculation.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <geometry/MakeArcOfHyperbola2d.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <modeling/MakeEdge2d.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"case1: CurveCalculation::D1() circle2[2/20] \", \"[math][CurveCalculation][P1][D1]\") {\n\tDirection2 initialDir(1.0, 0.0); \n\tFrame2 defaultFrame2(Point2(1.0, 1.0), initialDir); \n\tdouble radius = 2.0;\n\tAMCAX::Circle2 circle2(defaultFrame2, radius);\n\tPoint2 p;\n\tVector2 v;\n\tSECTION(\"u =0\") {\n\t\tCurveCalculation::D1(0.0, circle2,p,v);\n\t\tCHECK(p.X() == 3.0);\n\t\tCHECK(p.Y() == 1.0);\n\t\tCHECK(v.X() == Approx(0.0));\n\t\tCHECK(v.Y() == Approx(2.0));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] AMCAX_API static Vector2 D1(double u, const Line2& line)\t @return The first derivative vector\n\t @param line The line\n\t @param u The parameter\n\t @brief Compute the first derivative on a 2D line at a parameter\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <common/PointT.hpp>\n#include <math/CurveCalculation.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <geometry/MakeArcOfHyperbola2d.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <modeling/MakeEdge2d.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"case1: CurveCalculation::D1() circle2[1/20] \", \"[math][CurveCalculation][P1][D1]\") {\n\tDirection2 initialDir(1.0, 0.0); \n\tFrame2 defaultFrame2(Point2(1.0, 1.0), initialDir); \n    double radius = 2.0;\n    AMCAX::Circle2 circle2(defaultFrame2,radius);\n\tSECTION(\"u =0\") {\n\t\tVector2 vector2 = CurveCalculation::D1(0.0, circle2);\n\t\tCHECK(vector2.X() == Approx(-0.0));\n\t\tCHECK(vector2.Y() == 2.0);\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static void D1(double u, const Hyperbola3& hyperbola, Point3& p, Vector3& v1)\t @param[out] v1 The first derivative\n\t @param[out] p The point\n\t @param[in] hyperbola The hyperbola\n\t @param[in] u The parameter\n\t @brief Compute the point and the first derivative on a 3D hyperbola at a parameter\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <common/PointT.hpp>\n#include <math/CurveCalculation.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <geometry/MakeArcOfHyperbola2d.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <modeling/MakeEdge2d.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"case1: CurveCalculation::D1() Hyperbola3 [12/20] \", \"[math][CurveCalculation][P1][D1]\") {\n\tDirection3 dir3(0.0, 0.0, 1.0);\n\tPoint3 point3(0.0, 0.0, 0.0);\n\tFrame3 frame3(point3, dir3);\n\tHyperbola3 hyperbola3(frame3, 5.0, 3.0); \n\tPoint3 p;\n\tVector3 v;\n\tCurveCalculation::D1(0.0, hyperbola3,p,v); \n\tCHECK(p.X() == 5.0);\n\tCHECK(p.Y() == 0.0);\n\tCHECK(p.Z() == 0.0);\n\tCHECK(v.X() == 0.0);\n\tCHECK(v.Y() == 3.0);\n\tCHECK(v.Z() == 0.0);\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] AMCAX_API static Vector3 D1(double u, const Hyperbola3& hyperbola)\t @return The first derivative vector\n\t @param hyperbola The hyperbola\n\t @param u The parameter\n\t @brief Compute the first derivative on a 3D hyperbola at a parameter\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <common/PointT.hpp>\n#include <math/CurveCalculation.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <geometry/MakeArcOfHyperbola2d.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <modeling/MakeEdge2d.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"case1: CurveCalculation::D1() Hyperbola3 [11/20] \", \"[math][CurveCalculation][P1][D1]\") {\n\tDirection3 dir3(0.0, 0.0, 1.0);\n\tPoint3 point3(0.0, 0.0, 0.0);\n\tFrame3 frame3(point3, dir3);\n\tHyperbola3 hyperbola3(frame3, 5.0, 3.0); \n\tVector3 vector3 = CurveCalculation::D1(0.0, hyperbola3); \n\tCHECK(vector3.X() == 0.0);\n\tCHECK(vector3.Y() == 3.0);\n\tCHECK(vector3.Z() == 0.0);\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static void D1(double u, const Parabola3& parabola, Point3& p, Vector3& v1)\t @param[out] v1 The first derivative\n\t @param[out] p The point\n\t @param[in] parabola The parabola\n\t @param[in] u The parameter\n\t @brief Compute the point and the first derivative on a 3D parabola at a parameter\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <common/PointT.hpp>\n#include <math/CurveCalculation.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <geometry/MakeArcOfHyperbola2d.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <modeling/MakeEdge2d.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"case1: CurveCalculation::D1() ellipse3 [8/20] \", \"[math][CurveCalculation][P1][D1]\") {\n\tDirection3 initialDir(0.0, 0.0, 1.0); \n\tFrame3 defaultFrame3(Point3(0.0, 0.0, 0.0), initialDir); \n\tEllipse3 ellipse3(defaultFrame3, 5.0, 3.0);\n\tPoint3 p;\n\tVector3 v;\n\tMakeEdge edge = MakeEdge(ellipse3);\n\tbool bWriteresult = OCCTIO::OCCTTool::Write(edge, OUTPUT_PATH_PREFIX\"ellipse3CurveCalculation_case1.brep\", true, 3);\n\tSECTION(\"u =0\") {\n\t\tCurveCalculation::D1(0.0, ellipse3,p,v);\n\t\tCHECK(p.X() == 5.0);\n\t\tCHECK(p.Y() == 0.0);\n\t\tCHECK(p.Z() == 0.0);\n\t\tCHECK(v.X() == Approx(0.0));\n\t\tCHECK(v.Y() == Approx(3.0));\n\t\tCHECK(v.Z() == Approx(0.0));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] AMCAX_API static Vector3 D1(double u, const Parabola3& parabola)\t @return The first derivative vector\n\t @param parabola The parabola\n\t @param u The parameter\n\t @brief Compute the first derivative on a 3D parabola at a parameter\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <common/PointT.hpp>\n#include <math/CurveCalculation.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <geometry/MakeArcOfHyperbola2d.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <modeling/MakeEdge2d.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"case1: CurveCalculation::D1() ellipse3 [7/20] \", \"[math][CurveCalculation][P1][D1]\") {\n\tDirection3 initialDir(0.0, 0.0, 1.0); \n\tFrame3 defaultFrame3(Point3(0.0, 0.0, 0.0), initialDir); \n\tEllipse3 ellipse3(defaultFrame3,5.0,3.0 );\n\tMakeEdge edge= MakeEdge(ellipse3);\n\tbool bWriteresult = OCCTIO::OCCTTool::Write(edge, OUTPUT_PATH_PREFIX\"ellipse3CurveCalculation_case1.brep\",true,3);\n\tSECTION(\"u = M_PI_2\") {\n\t\tVector3 vector3 = CurveCalculation::D1(M_PI_2, ellipse3);\n\t\tCHECK(vector3.X() == Approx(-5.0));\n\t\tCHECK(vector3.Y() == Approx(0.0).margin(1e-14));\n\t\tCHECK(vector3.Z() == Approx(0.0));\n\t}\n}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static void D1(double u, const Ellipse3& ellipse, Point3& p, Vector3& v1)\t @param[out] v1 The first derivative\n\t @param[out] p The point\n\t @param[in] ellipse The ellipse\n\t @param[in] u The parameter\n\t @brief Compute the point and the first derivative on a 3D ellipse at a parameter\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <common/PointT.hpp>\n#include <math/CurveCalculation.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <geometry/MakeArcOfHyperbola2d.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <modeling/MakeEdge2d.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"case1: CurveCalculation::D1() ellipse3 [7/20] \", \"[math][CurveCalculation][P1][D1]\") {\n\tDirection3 initialDir(0.0, 0.0, 1.0); \n\tFrame3 defaultFrame3(Point3(0.0, 0.0, 0.0), initialDir); \n\tEllipse3 ellipse3(defaultFrame3,5.0,3.0 );\n\tMakeEdge edge= MakeEdge(ellipse3);\n\tbool bWriteresult = OCCTIO::OCCTTool::Write(edge, OUTPUT_PATH_PREFIX\"ellipse3CurveCalculation_case1.brep\",true,3);\n\tSECTION(\"u =0\") {\n\t\tVector3 vector3 = CurveCalculation::D1(0.0, ellipse3);\n\t\tCHECK(vector3.X() == Approx(0.0));\n\t\tCHECK(vector3.Y() == Approx(3.0));\n\t\tCHECK(vector3.Z() == Approx(0.0));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] AMCAX_API static Vector3 D1(double u, const Ellipse3& ellipse)\t @return The first derivative vector\n\t @param ellipse The ellipse\n\t @param u The parameter\n\t @brief Compute the first derivative on a 3D ellipse at a parameter\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <common/PointT.hpp>\n#include <math/CurveCalculation.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <geometry/MakeArcOfHyperbola2d.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <modeling/MakeEdge2d.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"case1: CurveCalculation::D1() circle3[3/20] \", \"[math][CurveCalculation][P1][D1]\") {\n\tDirection3 initialDir(0.0, 0.0, 1.0); \n\tFrame3 defaultFrame3(Point3(1.0, 0.0, 0.0), initialDir); \n\tdouble radius = 2.0; \n\tAMCAX::Circle3 circle3(defaultFrame3, radius);\n\tSECTION(\"u =0\") {\n\t\tVector3 vector3 = CurveCalculation::D1(0.0, circle3);\n\t\tCHECK(vector3.X() == Approx(0.0));\n\t\tCHECK(vector3.Y() == Approx(2.0));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static void D1(double u, const Circle3& circle, Point3& p, Vector3& v1)\t @param[out] v1 The first derivative\n\t @param[out] p The point\n\t @param[in] circle The circle\n\t @param[in] u The parameter\n\t @brief Compute the point and the first derivative on a 3D circle at a parameter\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <common/PointT.hpp>\n#include <math/CurveCalculation.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <geometry/MakeArcOfHyperbola2d.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <modeling/MakeEdge2d.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"case1: CurveCalculation::D1() circle3[4/20] \", \"[math][CurveCalculation][P1][D1]\") {\n\tDirection3 initialDir(0.0, 0.0, 1.0);\n\tFrame3 defaultFrame3(Point3(1.0, 1.0, 0.0), initialDir);\n\tPoint3 p;\n\tVector3 v;\n\tdouble radius = 2.0; \n\tAMCAX::Circle3 circle3(defaultFrame3, radius);\n\tSECTION(\"u =0\") {\n\t\tCurveCalculation::D1(0.0, circle3,p,v);\n\t\tCHECK(p.X() == 3.0);\n\t\tCHECK(p.Y() == 1.0);\n\t\tCHECK(p.Z() == 0.0);\n\t\tCHECK(v.X() == Approx(0.0));\n\t\tCHECK(v.Y() == Approx(2.0));\n\t\tCHECK(v.Z() == Approx(0.0));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] AMCAX_API static Vector3 D1(double u, const Circle3& circle)\t @return The first derivative vector\n\t @param circle The circle\n\t @param u The parameter\n\t @brief Compute the first derivative on a 3D circle at a parameter\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <common/PointT.hpp>\n#include <math/CurveCalculation.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <geometry/MakeArcOfHyperbola2d.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <modeling/MakeEdge2d.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"case1: CurveCalculation::D1() circle3[3/20] \", \"[math][CurveCalculation][P1][D1]\") {\n\tDirection3 initialDir(0.0, 0.0, 1.0); \n\tFrame3 defaultFrame3(Point3(1.0, 0.0, 0.0), initialDir); \n\tdouble radius = 2.0; \n\tAMCAX::Circle3 circle3(defaultFrame3, radius);\n\tSECTION(\"u =0\") {\n\t\tVector3 vector3 = CurveCalculation::D1(0.0, circle3);\n\t\tCHECK(vector3.X() == Approx(0.0));\n\t\tCHECK(vector3.Y() == Approx(2.0));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static void D1(double u, const Line3& line, Point3& p, Vector3& v1)\t @param[out] v1 The first derivative\n\t @param[out] p The point\n\t @param[in] line The line\n\t @param[in] u The parameter\n\t @brief Compute the point and the first derivative on a 3D line at a parameter\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <common/PointT.hpp>\n#include <math/CurveCalculation.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <geometry/MakeArcOfHyperbola2d.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <modeling/MakeEdge2d.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"case1: CurveCalculation::D1() circle3[4/20] \", \"[math][CurveCalculation][P1][D1]\") {\n\tDirection3 initialDir(0.0, 0.0, 1.0);\n\tFrame3 defaultFrame3(Point3(1.0, 1.0, 0.0), initialDir);\n\tPoint3 p;\n\tVector3 v;\n\tdouble radius = 2.0; \n\tAMCAX::Circle3 circle3(defaultFrame3, radius);\n\tSECTION(\"u =0\") {\n\t\tCurveCalculation::D1(0.0, circle3,p,v);\n\t\tCHECK(p.X() == 3.0);\n\t\tCHECK(p.Y() == 1.0);\n\t\tCHECK(p.Z() == 0.0);\n\t\tCHECK(v.X() == Approx(0.0));\n\t\tCHECK(v.Y() == Approx(2.0));\n\t\tCHECK(v.Z() == Approx(0.0));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] AMCAX_API static Vector3 D1(double u, const Line3& line)\t @return The first derivative vector\n\t @param line The line\n\t @param u The parameter\n\t @brief Compute the first derivative on a 3D line at a parameter\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <common/PointT.hpp>\n#include <math/CurveCalculation.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <geometry/MakeArcOfHyperbola2d.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <modeling/MakeEdge2d.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"case1: CurveCalculation::D1() circle3[3/20] \", \"[math][CurveCalculation][P1][D1]\") {\n\tDirection3 initialDir(0.0, 0.0, 1.0); \n\tFrame3 defaultFrame3(Point3(1.0, 0.0, 0.0), initialDir); \n\tdouble radius = 2.0; \n\tAMCAX::Circle3 circle3(defaultFrame3, radius);\n\tSECTION(\"u =0\") {\n\t\tVector3 vector3 = CurveCalculation::D1(0.0, circle3);\n\t\tCHECK(vector3.X() == Approx(0.0));\n\t\tCHECK(vector3.Y() == Approx(2.0));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] AMCAX_API static Point2 D0(double u, const Hyperbola2& hyperbola)\t @return The resulting point\n\t @param hyperbola The hyperbola\n\t @param u The parameter\n\t @brief Compute the point on a 2D hyperbola at a parameter\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <common/PointT.hpp>\n#include <math/CurveCalculation.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <geometry/MakeArcOfHyperbola2d.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <modeling/MakeEdge2d.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"case1: CurveCalculation::D0() [5/10] \", \"[math][CurveCalculation][P1][D0]\") {\n\tAxis2 majorAxis;\n\tdouble major_radius = 5;\n\tdouble minor_radius = 3;\n\tHyperbola2 hyperbola(majorAxis, major_radius, minor_radius);\n\tPoint2 point2 = CurveCalculation::D0(0.0, hyperbola);\n\tCHECK(point2.X() == 5.0);\n\tCHECK(point2.Y() == 0.0);\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] AMCAX_API static Point2 D0(double u, const Parabola2& parabola)\t @return The resulting point\n\t @param parabola The parabola\n\t @param u The parameter\n\t @brief Compute the point on a 2D parabola at a parameter\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <common/PointT.hpp>\n#include <math/CurveCalculation.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <geometry/MakeArcOfHyperbola2d.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <modeling/MakeEdge2d.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"case1: CurveCalculation::D0() [9/10] \", \"[math][CurveCalculation][P1][D0]\") {\n\tAMCAX::Point2 P(0.0, 0.0);\n\tAMCAX::Direction2 D(1.0, 0.0);\n\tAMCAX::Axis2  axis2(P, D);\n\tdouble focal = 2.0;\n\tAMCAX::Parabola2 parabola2(axis2,focal );\n\tSECTION(\"u =0\") {  \n\t\tPoint2 point2 = CurveCalculation::D0(0.0, parabola2); \n\t\tCHECK(point2.X() == 0.0);\n\t\tCHECK(point2.Y() == 0.0);\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] AMCAX_API static Point2 D0(double u, const Ellipse2& ellipse)\t @return The resulting point\n\t @param ellipse The ellipse\n\t @param u The parameter\n\t @brief Compute the point on a 2D ellipse at a parameter\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <common/PointT.hpp>\n#include <math/CurveCalculation.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <geometry/MakeArcOfHyperbola2d.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <modeling/MakeEdge2d.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"case1: CurveCalculation::D0() [3/10] \", \"[math][CurveCalculation][P1][D0]\") {\n\tAMCAX::Ellipse2 ellipse2(AMCAX::Axis2(AMCAX::Point2(0.0, 0.0), AMCAX::Direction2(1.0, 0.0)), 5.0, 3.0);\n\tPoint2 point2 = AMCAX::CurveCalculation::D0(M_PI_2, ellipse2);\n\tCHECK(point2.X() == Approx(0.0).margin(1e-12));\n\tCHECK(point2.Y() == 3.0);\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] AMCAX_API static Point2 D0(double u, const Circle2& circle)\t @return The resulting point\n\t @param circle The circle\n\t @param u The parameter\n\t @brief Compute the point on a 2D circle at a parameter\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <common/PointT.hpp>\n#include <math/CurveCalculation.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <geometry/MakeArcOfHyperbola2d.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <modeling/MakeEdge2d.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"case1: CurveCalculation::D0() [1/10] \", \"[math][CurveCalculation][P1][D0]\") {\n\tAMCAX::Point2 P(0.0, 0.0);\n\tAMCAX::Direction2 D(1.0, 0.0);\n\tAMCAX::Axis2  axis2(P, D);\n\tfloat radius = 2.0f;\n\tAMCAX::Circle2 circle2(axis2, radius, true);\n\tPoint2 point2 = AMCAX::CurveCalculation::D0(0.0, circle2);\n\tCHECK(point2.X() == 2.0);\n\tCHECK(point2.Y() == 0.0);\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] AMCAX_API static Point2 D0(double u, const Line2& line)\t @return The resulting point\n\t @param line The line\n\t @param u The parameter\n\t @brief Compute the point on a 2D line at a parameter\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <common/PointT.hpp>\n#include <math/CurveCalculation.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <geometry/MakeArcOfHyperbola2d.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <modeling/MakeEdge2d.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"case1: CurveCalculation::D0() [1/10] \", \"[math][CurveCalculation][P1][D0]\") {\n\tAMCAX::Point2 P(0.0, 0.0);\n\tAMCAX::Direction2 D(1.0, 0.0);\n\tAMCAX::Axis2  axis2(P, D);\n\tfloat radius = 2.0f;\n\tAMCAX::Circle2 circle2(axis2, radius, true);\n\tPoint2 point2 = AMCAX::CurveCalculation::D0(0.0, circle2);\n\tCHECK(point2.X() == 2.0);\n\tCHECK(point2.Y() == 0.0);\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] AMCAX_API static Point3 D0(double u, const Hyperbola3& hyperbola)\t @return The resulting point\n\t @param hyperbola The hyperbola\n\t @param u The parameter\n\t @brief Compute the point on a 3D hyperbola at a parameter\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <common/PointT.hpp>\n#include <math/CurveCalculation.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <geometry/MakeArcOfHyperbola2d.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <modeling/MakeEdge2d.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"case1: CurveCalculation::D0() [6/10] \", \"[math][CurveCalculation][P1][D0]\") {\n\tFrame3 fram3;\n\tdouble major_radius = 1000.0;\n\tdouble minor_radius = 10.0;\n\tHyperbola3 hyperbola(fram3, major_radius, minor_radius);\n\tPoint3 point3 = CurveCalculation::D0(0.0, hyperbola);\n\tCHECK(point3.X() == 1000.0);\n\tCHECK(point3.Y() == 0.0);\n\tCHECK(point3.Z() == 0.0);\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] AMCAX_API static Point3 D0(double u, const Parabola3& parabola)\t @return The resulting point\n\t @param parabola The parabola\n\t @param u The parameter\n\t @brief Compute the point on a 3D parabola at a parameter\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <common/PointT.hpp>\n#include <math/CurveCalculation.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <geometry/MakeArcOfHyperbola2d.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <modeling/MakeEdge2d.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"case1: CurveCalculation::D0() [10/10] \", \"[math][CurveCalculation][P1][D0]\") {\n\tPoint3 point3(0.0, 0.0, 0.0);\n\tDirection3 dir3(0.0, 0.0, 1.0);\n\tFrame3 fram3(point3, dir3);\n\tdouble focal = 2.0;\n\tParabola3 parabola3(fram3, focal);\n\tSECTION(\"u =0\") {\n\t\tPoint3 point3 = CurveCalculation::D0(0.0, parabola3);\n\t\tCHECK(point3.X() == 0.0);\n\t\tCHECK(point3.Y() == 0.0);\n\t\tCHECK(point3.Z() == 0.0);\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] AMCAX_API static Point3 D0(double u, const Ellipse3& ellipse)\t @return The resulting point\n\t @param ellipse The ellipse\n\t @param u The parameter\n\t @brief Compute the point on a 3D ellipse at a parameter\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <common/PointT.hpp>\n#include <math/CurveCalculation.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <geometry/MakeArcOfHyperbola2d.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <modeling/MakeEdge2d.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"case1: CurveCalculation::D0() [4/10] \", \"[math][CurveCalculation][P1][D0]\") {\n\tFrame3 fram3 = Frame3(Point3(0.0, 0.0, 1.0), Direction3(0.0, 0.0, 1.0));\n\tAMCAX::Ellipse3 ellipse3(fram3, 5.0, 3.0);\n\tPoint3 point3 = AMCAX::CurveCalculation::D0(M_PI_2, ellipse3);\n\tCHECK(point3.X() == Approx(0.0).margin(1e-12));\n\tCHECK(point3.Y() == 3.0);\n\tCHECK(point3.Z() == 1.0);\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] AMCAX_API static Point3 D0(double u, const Circle3& circle)\t @return The resulting point\n\t @param circle The circle\n\t @param u The parameter\n\t @brief Compute the point on a 3D circle at a parameter\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <common/PointT.hpp>\n#include <math/CurveCalculation.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <geometry/MakeArcOfHyperbola2d.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <modeling/MakeEdge2d.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"case1: CurveCalculation::D0() [2/10] \", \"[math][CurveCalculation][P1][D0]\") {\n\tAMCAX::Circle3 circle3D;\n\tAMCAX::Point3  center3D(1.0, 1.0, 1.0);\n\tdouble radius3D = 5.0;\n\tdouble tol = 0.1;\n\tcircle3D.SetLocation(center3D);\n\tcircle3D.SetRadius(radius3D);\n\tPoint3 point3 = AMCAX::CurveCalculation::D0(M_PI_2, circle3D);\n\tCHECK(point3.X() == Approx(1.0));\n\tCHECK(point3.Y() == 6.0);\n\tCHECK(point3.Z() == 1.0);\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] AMCAX_API static Point3 D0(double u, const Line3& line)\t @return The resulting point\n\t @param line The line\n\t @param u The parameter\n\t @brief Compute the point on a 3D line at a parameter\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <common/PointT.hpp>\n#include <math/CurveCalculation.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <geometry/MakeArcOfHyperbola2d.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <modeling/MakeEdge2d.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"case1: CurveCalculation::D0() [6/10] \", \"[math][CurveCalculation][P1][D0]\") {\n\tFrame3 fram3;\n\tdouble major_radius = 1000.0;\n\tdouble minor_radius = 10.0;\n\tHyperbola3 hyperbola(fram3, major_radius, minor_radius);\n\tPoint3 point3 = CurveCalculation::D0(0.0, hyperbola);\n\tCHECK(point3.X() == 1000.0);\n\tCHECK(point3.Y() == 0.0);\n\tCHECK(point3.Z() == 0.0);\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] AMCAX_API static double CircleParameter(const Frame2& pos, const Point2& p)\t @return The parameter of point\n\t @param p The given point\n\t @param pos The local frame where the circle lies\n\t @brief Compute the parameter of a given point on a 2D circle represented by a local frame\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <common/PointT.hpp>\n#include <math/CurveCalculation.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"case1: CurveCalculation::CircleParameter() [1/2] \", \"[math][CurveCalculation][P1][CircleParameter]\") {\n\tDirection2 defaultDirection(1.0, 0.0); \n\tFrame2 defaultFrame2(Point2(0.0, 0.0), defaultDirection);\n\tdouble u1 = AMCAX::CurveCalculation::CircleParameter(defaultFrame2, Point2(0.0, 1.0)); \n\tCHECK(u1 == M_PI_2);\n\tdouble u2 = AMCAX::CurveCalculation::CircleParameter(defaultFrame2, Point2(0.0, 0.0));\n\tCHECK(u2 == 0.0);\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] AMCAX_API static double CircleParameter(const Frame3& pos, const Point3& p)\t @return The parameter of point\n\t @param p The given point\n\t @param pos The local frame where the circle lies\n\t @brief Compute the parameter of a given point on a 3D circle represented by a local frame\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <common/PointT.hpp>\n#include <math/CurveCalculation.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"case1: CurveCalculation::CircleParameter() [1/2] \", \"[math][CurveCalculation][P1][CircleParameter]\") {\n\tDirection2 defaultDirection(1.0, 0.0); \n\tFrame2 defaultFrame2(Point2(0.0, 0.0), defaultDirection);\n\tdouble u1 = AMCAX::CurveCalculation::CircleParameter(defaultFrame2, Point2(0.0, 1.0)); \n\tCHECK(u1 == M_PI_2);\n\tdouble u2 = AMCAX::CurveCalculation::CircleParameter(defaultFrame2, Point2(0.0, 0.0));\n\tCHECK(u2 == 0.0);\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] AMCAX_API static Vector2 CircleDN(double u, const Frame2& pos, double radius, int n)\t @return The n-th derivative vector\n\t @param n The order of derivative\n\t @param radius The radius\n\t @param pos The local frame where the circle lies\n\t @param u The parameter\n\t @brief Compute the n-th derivative on a 2D circle represented by a local frame and a radius at a parameter\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <common/PointT.hpp>\n#include <math/CurveCalculation.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"case1: CurveCalculation::CircleDN 1/2 \", \"[math][CurveCalculation][P1][CircleDN]\") {\n\tDirection2 defaultDirection(1.0, 0.0); \n\tFrame2 defaultFrame2(Point2(0.0, 0.0), defaultDirection);\n\tdouble \tr = 2.0;\n\tdouble u = 0.0;\n\tSECTION(\"2 derivative vector\") {\n\t\tVector2  vector2 = CurveCalculation::CircleDN(u, defaultFrame2, r, 2); \n\t\tstd::cout << vector2.X() << \" \" << vector2.Y() << \" \" << std::endl;\n\t\tCHECK(vector2.X() == -2.0);\n\t\tCHECK(vector2.Y() == Approx(0.0).margin(1e-14));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] AMCAX_API static Vector3 CircleDN(double u, const Frame3& pos, double radius, int n)\t @return The n-th derivative vector\n\t @param n The order of derivative\n\t @param radius The radius\n\t @param pos The local frame where the circle lies\n\t @param u The parameter\n\t @brief Compute the n-th derivative on a 3D circle represented by a local frame and a radius at a parameter\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <common/PointT.hpp>\n#include <math/CurveCalculation.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"case1: CurveCalculation::CircleDN 2/2 \", \"[math][CurveCalculation][P1][CircleDN]\") {\n\tDirection3 initialDir(0.0, 0.0, 1.0); \n\tFrame3 defaultFrame3(Point3(1.0, 1.0, 0.0), initialDir); \n\tdouble radius = 2.0; \n\tdouble u = 0.0;\n\tSECTION(\"2 derivative vector\") {\n\t\tVector3  vector3 = CurveCalculation::CircleDN(u, defaultFrame3, radius, 2); \n\t\tstd::cout << vector3.X() << \" \" << vector3.Y() << \" \" << std::endl;\n\t\tCHECK(vector3.X() == -2.0);\n\t\tCHECK(vector3.Y() == Approx(0.0).margin(1e-14));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static void CircleD3(double u, const Frame2& pos, double radius, Point2& p, Vector2& v1, Vector2& v2, Vector2& v3)\t @param[out] v3 The third derivative\n\t @param[out] v2 The second derivative\n\t @param[out] v1 The first derivative\n\t @param[out] p The point\n\t @param[in] radius The radius\n\t @param[in] pos The local frame where the circle lies\n\t @param[in] u The parameter\n\t @brief Compute the point and the first three derivatives on a 2D circle represented by a local frame and a radius at a parameter\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <common/PointT.hpp>\n#include <math/CurveCalculation.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"case1: CurveCalculation::CircleD3 1/4 \", \"[math][CurveCalculation][P1][CircleD3]\") {\n\tDirection2 defaultDir2(1.0, 0.0);\n\tFrame2 defaultFrame2(Point2(1.0, 1.0), defaultDir2);\n\tdouble radius = 2.0;\n\tVector2 tangentAt0 = AMCAX::CurveCalculation::CircleD3(0.0, defaultFrame2, radius);\n\tVector2 tangentAt180 = AMCAX::CurveCalculation::CircleD3(M_PI, defaultFrame2, radius);\n\tVector2 tangentAt360 = AMCAX::CurveCalculation::CircleD3(2 * M_PI, defaultFrame2, radius);\n\tCHECK(tangentAt0.X() == 0.0);\n\tCHECK(tangentAt0.Y() == -2.0);\n\tCHECK(tangentAt180.X() == Approx(0.0).margin(1e-14));\n\tCHECK(tangentAt180.Y() == 2.0 );\n\tCHECK(tangentAt360.X() == Approx(0.0).margin(1e-14));\n\tCHECK(tangentAt360.Y() == -2.0 );\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] AMCAX_API static Vector2 CircleD3(double u, const Frame2& pos, double radius)\t @return The third derivative vector\n\t @param radius The radius\n\t @param pos The local frame where the circle lies\n\t @param u The parameter\n\t @brief Compute the third derivative on a 2D circle represented by a local frame and a radius at a parameter\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <common/PointT.hpp>\n#include <math/CurveCalculation.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"case1: CurveCalculation::CircleD3 1/4 \", \"[math][CurveCalculation][P1][CircleD3]\") {\n\tDirection2 defaultDir2(1.0, 0.0);\n\tFrame2 defaultFrame2(Point2(1.0, 1.0), defaultDir2);\n\tdouble radius = 2.0;\n\tVector2 tangentAt0 = AMCAX::CurveCalculation::CircleD3(0.0, defaultFrame2, radius);\n\tVector2 tangentAt180 = AMCAX::CurveCalculation::CircleD3(M_PI, defaultFrame2, radius);\n\tVector2 tangentAt360 = AMCAX::CurveCalculation::CircleD3(2 * M_PI, defaultFrame2, radius);\n\tCHECK(tangentAt0.X() == 0.0);\n\tCHECK(tangentAt0.Y() == -2.0);\n\tCHECK(tangentAt180.X() == Approx(0.0).margin(1e-14));\n\tCHECK(tangentAt180.Y() == 2.0 );\n\tCHECK(tangentAt360.X() == Approx(0.0).margin(1e-14));\n\tCHECK(tangentAt360.Y() == -2.0 );\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static void CircleD3(double u, const Frame3& pos, double radius, Point3& p, Vector3& v1, Vector3& v2, Vector3& v3)\t @param[out] v3 The third derivative\n\t @param[out] v2 The second derivative\n\t @param[out] v1 The first derivative\n\t @param[out] p The point\n\t @param[in] radius The radius\n\t @param[in] pos The local frame where the circle lies\n\t @param[in] u The parameter\n\t @brief Compute the point and the first three derivatives on a 3D circle represented by a local frame and a radius at a parameter\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <common/PointT.hpp>\n#include <math/CurveCalculation.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"case1: CurveCalculation::CircleD3 3/4 \", \"[math][CurveCalculation][P1][CircleD3]\") {\n\tDirection3 initialDir(0.0, 0.0, 1.0); \n\tFrame3 defaultFrame3(Point3(1.0, 1.0, 0.0), initialDir); \n\tdouble radius = 2.0; \n\tVector3 tangentAt0 = AMCAX::CurveCalculation::CircleD3(0.0, defaultFrame3, radius);\n\tVector3 tangentAt90Deg = AMCAX::CurveCalculation::CircleD3(M_PI_2, defaultFrame3, radius);\n\tVector3 tangentAt180Deg = AMCAX::CurveCalculation::CircleD3(M_PI, defaultFrame3, radius);\n\tVector3 tangentAt270Deg = AMCAX::CurveCalculation::CircleD3(3 * M_PI_2, defaultFrame3, radius);\n\tVector3 tangentAt360Deg = AMCAX::CurveCalculation::CircleD3(2 * M_PI, defaultFrame3, radius);\n\tCHECK(tangentAt0.X() == Approx(0.0));\n\tCHECK(tangentAt0.Y() == Approx(-2.0));\n\tCHECK(tangentAt0.Z() == Approx(-0.0));\n\tCHECK(tangentAt90Deg.X() == Approx(2.0).margin(1e-14));\n\tCHECK(tangentAt90Deg.Y() == Approx(-0.0).margin(1e-14));\n\tCHECK(tangentAt90Deg.Z() == Approx(0.0).margin(1e-14));\n\tCHECK(tangentAt180Deg.X() == Approx(0.0).margin(1e-14));\n\tCHECK(tangentAt180Deg.Y() == Approx(2.0).margin(1e-14));\n\tCHECK(tangentAt180Deg.Z() == Approx(0.0));\n\tCHECK(tangentAt270Deg.X() == Approx(-2.0).margin(1e-14));\n\tCHECK(tangentAt270Deg.Y() == Approx(0.0).margin(1e-14));\n\tCHECK(tangentAt270Deg.Z() == Approx(0.0).margin(1e-14));\n\tCHECK(tangentAt360Deg.X() == Approx(-0.0).margin(1e-14));\n\tCHECK(tangentAt360Deg.Y() == Approx(-2.0).margin(1e-14));\n\tCHECK(tangentAt360Deg.Z() == Approx(0.0).margin(1e-14));\n\tstd::cout << \"Tangent at 0 deg: \" << tangentAt0 << std::endl;\n\tstd::cout << \"Tangent at 90 deg: \" << tangentAt90Deg << std::endl;\n\tstd::cout << \"Tangent at 180 deg: \" << tangentAt180Deg << std::endl;\n\tstd::cout << \"Tangent at 270 deg: \" << tangentAt270Deg << std::endl;\n\tstd::cout << \"Tangent at 360 deg: \" << tangentAt360Deg << std::endl;\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] AMCAX_API static Vector3 CircleD3(double u, const Frame3& pos, double radius)\t @return The third derivative vector\n\t @param radius The radius\n\t @param pos The local frame where the circle lies\n\t @param u The parameter\n\t @brief Compute the third derivative on a 3D circle represented by a local frame and a radius at a parameter\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <common/PointT.hpp>\n#include <math/CurveCalculation.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"case1: CurveCalculation::CircleD3 3/4 \", \"[math][CurveCalculation][P1][CircleD3]\") {\n\tDirection3 initialDir(0.0, 0.0, 1.0); \n\tFrame3 defaultFrame3(Point3(1.0, 1.0, 0.0), initialDir); \n\tdouble radius = 2.0; \n\tVector3 tangentAt0 = AMCAX::CurveCalculation::CircleD3(0.0, defaultFrame3, radius);\n\tVector3 tangentAt90Deg = AMCAX::CurveCalculation::CircleD3(M_PI_2, defaultFrame3, radius);\n\tVector3 tangentAt180Deg = AMCAX::CurveCalculation::CircleD3(M_PI, defaultFrame3, radius);\n\tVector3 tangentAt270Deg = AMCAX::CurveCalculation::CircleD3(3 * M_PI_2, defaultFrame3, radius);\n\tVector3 tangentAt360Deg = AMCAX::CurveCalculation::CircleD3(2 * M_PI, defaultFrame3, radius);\n\tCHECK(tangentAt0.X() == Approx(0.0));\n\tCHECK(tangentAt0.Y() == Approx(-2.0));\n\tCHECK(tangentAt0.Z() == Approx(-0.0));\n\tCHECK(tangentAt90Deg.X() == Approx(2.0).margin(1e-14));\n\tCHECK(tangentAt90Deg.Y() == Approx(-0.0).margin(1e-14));\n\tCHECK(tangentAt90Deg.Z() == Approx(0.0).margin(1e-14));\n\tCHECK(tangentAt180Deg.X() == Approx(0.0).margin(1e-14));\n\tCHECK(tangentAt180Deg.Y() == Approx(2.0).margin(1e-14));\n\tCHECK(tangentAt180Deg.Z() == Approx(0.0));\n\tCHECK(tangentAt270Deg.X() == Approx(-2.0).margin(1e-14));\n\tCHECK(tangentAt270Deg.Y() == Approx(0.0).margin(1e-14));\n\tCHECK(tangentAt270Deg.Z() == Approx(0.0).margin(1e-14));\n\tCHECK(tangentAt360Deg.X() == Approx(-0.0).margin(1e-14));\n\tCHECK(tangentAt360Deg.Y() == Approx(-2.0).margin(1e-14));\n\tCHECK(tangentAt360Deg.Z() == Approx(0.0).margin(1e-14));\n\tstd::cout << \"Tangent at 0 deg: \" << tangentAt0 << std::endl;\n\tstd::cout << \"Tangent at 90 deg: \" << tangentAt90Deg << std::endl;\n\tstd::cout << \"Tangent at 180 deg: \" << tangentAt180Deg << std::endl;\n\tstd::cout << \"Tangent at 270 deg: \" << tangentAt270Deg << std::endl;\n\tstd::cout << \"Tangent at 360 deg: \" << tangentAt360Deg << std::endl;\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static void CircleD2(double u, const Frame2& pos, double radius, Point2& p, Vector2& v1, Vector2& v2)\t @param[out] v2 The second derivative\n\t @param[out] v1 The first derivative\n\t @param[out] p The point\n\t @param[in] radius The radius\n\t @param[in] pos The local frame where the circle lies\n\t @param[in] u The parameter\n\t @brief Compute the point and the first two derivatives on a 2D circle represented by a local frame and a radius at a parameter\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <common/PointT.hpp>\n#include <math/CurveCalculation.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"case1: CurveCalculation::CircleD2 1/4 \", \"[math][CurveCalculation][P1][CircleD2]\") {\n\tDirection2 defaultDirection(1.0, 0.0); \n\tFrame2 defaultFrame2(Point2(0.0, 0.0), defaultDirection);\n\tdouble \tr = 2.0;\n\tdouble u = 0.0; \n\tVector2  vector2 = CurveCalculation::CircleD2(u, defaultFrame2, r); \n\tstd::cout << vector2.X() << \" \" << vector2.Y() << \" \" << std::endl;\n\tCHECK(vector2.X() == -2.0);\n\tCHECK(vector2.Y() == Approx(0.0).margin(1e-14));\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] AMCAX_API static Vector2 CircleD2(double u, const Frame2& pos, double radius)\t @return The second derivative vector\n\t @param radius The radius\n\t @param pos The local frame where the circle lies\n\t @param u The parameter\n\t @brief Compute the second derivative on a 2D circle represented by a local frame and a radius at a parameter\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <common/PointT.hpp>\n#include <math/CurveCalculation.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"case1: CurveCalculation::CircleD2 1/4 \", \"[math][CurveCalculation][P1][CircleD2]\") {\n\tDirection2 defaultDirection(1.0, 0.0); \n\tFrame2 defaultFrame2(Point2(0.0, 0.0), defaultDirection);\n\tdouble \tr = 2.0;\n\tdouble u = 0.0; \n\tVector2  vector2 = CurveCalculation::CircleD2(u, defaultFrame2, r); \n\tstd::cout << vector2.X() << \" \" << vector2.Y() << \" \" << std::endl;\n\tCHECK(vector2.X() == -2.0);\n\tCHECK(vector2.Y() == Approx(0.0).margin(1e-14));\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static void CircleD2(double u, const Frame3& pos, double radius, Point3& p, Vector3& v1, Vector3& v2)\t @param[out] v2 The second derivative\n\t @param[out] v1 The first derivative\n\t @param[out] p The point\n\t @param[in] radius The radius\n\t @param[in] pos The local frame where the circle lies\n\t @param[in] u The parameter\n\t @brief Compute the point and the first two derivatives on a 3D circle represented by a local frame and a radius at a parameter\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <common/PointT.hpp>\n#include <math/CurveCalculation.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"case1: CurveCalculation::CircleD2 3/4 \", \"[math][CurveCalculation][P1][CircleD2]\") {\n\tDirection3 initialDir(0.0, 0.0, 1.0); \n\tFrame3 defaultFrame3(Point3(1.0, 1.0, 0.0), initialDir); \n\tdouble radius = 2.0; \n\tVector3 tangentAt0 = AMCAX::CurveCalculation::CircleD2(0.0, defaultFrame3, radius);\n\tVector3 tangentAt90Deg = AMCAX::CurveCalculation::CircleD2(M_PI_2, defaultFrame3, radius);\n\tVector3 tangentAt180Deg = AMCAX::CurveCalculation::CircleD2(M_PI, defaultFrame3, radius);\n\tVector3 tangentAt270Deg = AMCAX::CurveCalculation::CircleD2(3 * M_PI_2, defaultFrame3, radius);\n\tVector3 tangentAt360Deg = AMCAX::CurveCalculation::CircleD2(2 * M_PI, defaultFrame3, radius);\n\tCHECK(tangentAt0.X() == Approx(-2.0));\n\tCHECK(tangentAt0.Y() == Approx(-0.0));\n\tCHECK(tangentAt0.Z() == Approx(0.0));\n\tCHECK(tangentAt90Deg.X() == Approx(-0.0).margin(1e-14));\n\tCHECK(tangentAt90Deg.Y() == Approx(-2.0).margin(1e-14));\n\tCHECK(tangentAt90Deg.Z() == Approx(0.0).margin(1e-14));\n\tCHECK(tangentAt180Deg.X() == Approx(2.0).margin(1e-14));\n\tCHECK(tangentAt180Deg.Y() == Approx(-0.0).margin(1e-14));\n\tCHECK(tangentAt180Deg.Z() == Approx(-0.0));\n\tCHECK(tangentAt270Deg.X() == Approx(0.0).margin(1e-14));\n\tCHECK(tangentAt270Deg.Y() == Approx(2.0).margin(1e-14));\n\tCHECK(tangentAt270Deg.Z() == Approx(0.0).margin(1e-14));\n\tCHECK(tangentAt360Deg.X() == Approx(-2.0).margin(1e-14));\n\tCHECK(tangentAt360Deg.Y() == Approx(0.0).margin(1e-14));\n\tCHECK(tangentAt360Deg.Z() == Approx(0.0).margin(1e-14));\n\tstd::cout << \"Tangent at 0 deg: \" << tangentAt0 << std::endl;\n\tstd::cout << \"Tangent at 90 deg: \" << tangentAt90Deg << std::endl;\n\tstd::cout << \"Tangent at 180 deg: \" << tangentAt180Deg << std::endl;\n\tstd::cout << \"Tangent at 270 deg: \" << tangentAt270Deg << std::endl;\n\tstd::cout << \"Tangent at 360 deg: \" << tangentAt360Deg << std::endl;\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] AMCAX_API static Vector3 CircleD2(double u, const Frame3& pos, double radius)\t @return The second derivative vector\n\t @param radius The radius\n\t @param pos The local frame where the circle lies\n\t @param u The parameter\n\t @brief Compute the second derivative on a 3D circle represented by a local frame and a radius at a parameter\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <common/PointT.hpp>\n#include <math/CurveCalculation.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"case1: CurveCalculation::CircleD2 3/4 \", \"[math][CurveCalculation][P1][CircleD2]\") {\n\tDirection3 initialDir(0.0, 0.0, 1.0); \n\tFrame3 defaultFrame3(Point3(1.0, 1.0, 0.0), initialDir); \n\tdouble radius = 2.0; \n\tVector3 tangentAt0 = AMCAX::CurveCalculation::CircleD2(0.0, defaultFrame3, radius);\n\tVector3 tangentAt90Deg = AMCAX::CurveCalculation::CircleD2(M_PI_2, defaultFrame3, radius);\n\tVector3 tangentAt180Deg = AMCAX::CurveCalculation::CircleD2(M_PI, defaultFrame3, radius);\n\tVector3 tangentAt270Deg = AMCAX::CurveCalculation::CircleD2(3 * M_PI_2, defaultFrame3, radius);\n\tVector3 tangentAt360Deg = AMCAX::CurveCalculation::CircleD2(2 * M_PI, defaultFrame3, radius);\n\tCHECK(tangentAt0.X() == Approx(-2.0));\n\tCHECK(tangentAt0.Y() == Approx(-0.0));\n\tCHECK(tangentAt0.Z() == Approx(0.0));\n\tCHECK(tangentAt90Deg.X() == Approx(-0.0).margin(1e-14));\n\tCHECK(tangentAt90Deg.Y() == Approx(-2.0).margin(1e-14));\n\tCHECK(tangentAt90Deg.Z() == Approx(0.0).margin(1e-14));\n\tCHECK(tangentAt180Deg.X() == Approx(2.0).margin(1e-14));\n\tCHECK(tangentAt180Deg.Y() == Approx(-0.0).margin(1e-14));\n\tCHECK(tangentAt180Deg.Z() == Approx(-0.0));\n\tCHECK(tangentAt270Deg.X() == Approx(0.0).margin(1e-14));\n\tCHECK(tangentAt270Deg.Y() == Approx(2.0).margin(1e-14));\n\tCHECK(tangentAt270Deg.Z() == Approx(0.0).margin(1e-14));\n\tCHECK(tangentAt360Deg.X() == Approx(-2.0).margin(1e-14));\n\tCHECK(tangentAt360Deg.Y() == Approx(0.0).margin(1e-14));\n\tCHECK(tangentAt360Deg.Z() == Approx(0.0).margin(1e-14));\n\tstd::cout << \"Tangent at 0 deg: \" << tangentAt0 << std::endl;\n\tstd::cout << \"Tangent at 90 deg: \" << tangentAt90Deg << std::endl;\n\tstd::cout << \"Tangent at 180 deg: \" << tangentAt180Deg << std::endl;\n\tstd::cout << \"Tangent at 270 deg: \" << tangentAt270Deg << std::endl;\n\tstd::cout << \"Tangent at 360 deg: \" << tangentAt360Deg << std::endl;\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static void CircleD1(double u, const Frame2& pos, double radius, Point2& p, Vector2& v1)\t @param[out] v1 The first derivative\n\t @param[out] p The point\n\t @param[in] radius The radius\n\t @param[in] pos The local frame where the circle lies\n\t @param[in] u The parameter\n\t @brief Compute the point and the first derivative on a 2D circle represented by a local frame and a radius at a parameter\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <common/PointT.hpp>\n#include <math/CurveCalculation.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"case1: CurveCalculation::CircleD1 1/4 \", \"[math][CurveCalculation][P1][CircleD1]\") {\n\tDirection2 initialDir(1.0, 0.0); \n\tFrame2 defaultFrame2(Point2(1.0, 1.0), initialDir); \n\tdouble radius = 2.0; \n\tVector2 tangentAt0 = AMCAX::CurveCalculation::CircleD1(0.0, defaultFrame2, radius);\n\tVector2 tangentAt90Deg = AMCAX::CurveCalculation::CircleD1(M_PI_2, defaultFrame2, radius);\n\tVector2 tangentAt180Deg = AMCAX::CurveCalculation::CircleD1(M_PI, defaultFrame2, radius);\n\tVector2 tangentAt270Deg = AMCAX::CurveCalculation::CircleD1(3 * M_PI_2, defaultFrame2, radius);\n\tVector2 tangentAt360Deg = AMCAX::CurveCalculation::CircleD1(2 * M_PI, defaultFrame2, radius);\n\tCHECK(tangentAt0.X() == Approx(-0.0));\n\tCHECK(tangentAt0.Y() == Approx(2.0));\n\tCHECK(tangentAt90Deg.X() == Approx(-2.0));\n\tCHECK(tangentAt90Deg.Y() == Approx(0.0).margin(1e-14));\n\tCHECK(tangentAt180Deg.X() == Approx(-0.0).margin(1e-14));\n\tCHECK(tangentAt180Deg.Y() == Approx(-2.0));\n\tCHECK(tangentAt270Deg.X() == Approx(2.0));\n\tCHECK(tangentAt270Deg.Y() == Approx(-0.0).margin(1e-14));\n\tCHECK(tangentAt360Deg.X() == Approx(0.0).margin(1e-14));\n\tCHECK(tangentAt360Deg.Y() == Approx(2.0));\n\tstd::cout << \"Tangent at 0 deg: \" << tangentAt0 << std::endl;\n\tstd::cout << \"Tangent at 90 deg: \" << tangentAt90Deg << std::endl;\n\tstd::cout << \"Tangent at 180 deg: \" << tangentAt180Deg << std::endl;\n\tstd::cout << \"Tangent at 270 deg: \" << tangentAt270Deg << std::endl;\n\tstd::cout << \"Tangent at 360 deg: \" << tangentAt360Deg << std::endl;\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] AMCAX_API static Vector2 CircleD1(double u, const Frame2& pos, double radius)\t @return The first derivative vector\n\t @param radius The radius\n\t @param pos The local frame where the circle lies\n\t @param u The parameter\n\t @brief Compute the first derivative on a 2D circle represented by a local frame and a radius at a parameter\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <common/PointT.hpp>\n#include <math/CurveCalculation.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"case1: CurveCalculation::CircleD1 1/4 \", \"[math][CurveCalculation][P1][CircleD1]\") {\n\tDirection2 initialDir(1.0, 0.0); \n\tFrame2 defaultFrame2(Point2(1.0, 1.0), initialDir); \n\tdouble radius = 2.0; \n\tVector2 tangentAt0 = AMCAX::CurveCalculation::CircleD1(0.0, defaultFrame2, radius);\n\tVector2 tangentAt90Deg = AMCAX::CurveCalculation::CircleD1(M_PI_2, defaultFrame2, radius);\n\tVector2 tangentAt180Deg = AMCAX::CurveCalculation::CircleD1(M_PI, defaultFrame2, radius);\n\tVector2 tangentAt270Deg = AMCAX::CurveCalculation::CircleD1(3 * M_PI_2, defaultFrame2, radius);\n\tVector2 tangentAt360Deg = AMCAX::CurveCalculation::CircleD1(2 * M_PI, defaultFrame2, radius);\n\tCHECK(tangentAt0.X() == Approx(-0.0));\n\tCHECK(tangentAt0.Y() == Approx(2.0));\n\tCHECK(tangentAt90Deg.X() == Approx(-2.0));\n\tCHECK(tangentAt90Deg.Y() == Approx(0.0).margin(1e-14));\n\tCHECK(tangentAt180Deg.X() == Approx(-0.0).margin(1e-14));\n\tCHECK(tangentAt180Deg.Y() == Approx(-2.0));\n\tCHECK(tangentAt270Deg.X() == Approx(2.0));\n\tCHECK(tangentAt270Deg.Y() == Approx(-0.0).margin(1e-14));\n\tCHECK(tangentAt360Deg.X() == Approx(0.0).margin(1e-14));\n\tCHECK(tangentAt360Deg.Y() == Approx(2.0));\n\tstd::cout << \"Tangent at 0 deg: \" << tangentAt0 << std::endl;\n\tstd::cout << \"Tangent at 90 deg: \" << tangentAt90Deg << std::endl;\n\tstd::cout << \"Tangent at 180 deg: \" << tangentAt180Deg << std::endl;\n\tstd::cout << \"Tangent at 270 deg: \" << tangentAt270Deg << std::endl;\n\tstd::cout << \"Tangent at 360 deg: \" << tangentAt360Deg << std::endl;\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static void CircleD1(double u, const Frame3& pos, double radius, Point3& p, Vector3& v1)\t @param[out] v1 The first derivative\n\t @param[out] p The point\n\t @param[in] radius The radius\n\t @param[in] pos The local frame where the circle lies\n\t @param[in] u The parameter\n\t @brief Compute the point and the first derivative on a 3D circle represented by a local frame and a radius at a parameter\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <common/PointT.hpp>\n#include <math/CurveCalculation.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"case1: CurveCalculation::CircleD1 4/4 \", \"[math][CurveCalculation][P1][CircleD1]\") {\n\tDirection3 initialDir(0.0, 0.0,1.0);\n\tFrame3 defaultFrame3(Point3(1.0, 1.0,0.0), initialDir);\n\tdouble radius = 2.0;\n\tPoint3 p;\n\tVector3 v;\n\tSECTION(\"0 deg case\") {\n\t\tAMCAX::CurveCalculation::CircleD1(0.0, defaultFrame3, radius, p, v);\n\t\tCHECK(p.X() == 3.0);\n\t\tCHECK(p.Y() == 1.0);\n\t\tCHECK(p.Z() == 0.0);\n\t\tCHECK(v.X() == Approx(0.0));\n\t\tCHECK(v.Y() == Approx(2.0));\n\t\tCHECK(v.Z() == Approx(0.0));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] AMCAX_API static Vector3 CircleD1(double u, const Frame3& pos, double radius)\t @return The first derivative vector\n\t @param radius The radius\n\t @param pos The local frame where the circle lies\n\t @param u The parameter\n\t @brief Compute the first derivative on a 3D circle represented by a local frame and a radius at a parameter\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <common/PointT.hpp>\n#include <math/CurveCalculation.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"case1: CurveCalculation::CircleD1 3/4 \", \"[math][CurveCalculation][P1][CircleD1]\") {\n\tDirection3 initialDir(0.0, 0.0,1.0); \n\tFrame3 defaultFrame3(Point3(1.0, 0.0,0.0), initialDir); \n\tdouble radius = 2.0; \n\tVector3 tangentAt0 = AMCAX::CurveCalculation::CircleD1(0.0, defaultFrame3, radius);\n\tVector3 tangentAt90Deg = AMCAX::CurveCalculation::CircleD1(M_PI_2, defaultFrame3, radius);\n\tVector3 tangentAt180Deg = AMCAX::CurveCalculation::CircleD1(M_PI, defaultFrame3, radius);\n\tVector3 tangentAt270Deg = AMCAX::CurveCalculation::CircleD1(3 * M_PI_2, defaultFrame3, radius);\n\tVector3 tangentAt360Deg = AMCAX::CurveCalculation::CircleD1(2 * M_PI, defaultFrame3, radius);\n\tCHECK(tangentAt0.X() == Approx(0.0));\n\tCHECK(tangentAt0.Y() == Approx(2.0));\n\tCHECK(tangentAt90Deg.X() == Approx(-2.0));\n\tCHECK(tangentAt90Deg.Y() == Approx(0.0).margin(1e-14));\n\tCHECK(tangentAt180Deg.X() == Approx(0.0).margin(1e-14));\n\tCHECK(tangentAt180Deg.Y() == Approx(-2.0));\n\tCHECK(tangentAt270Deg.X() == Approx(2.0));\n\tCHECK(tangentAt270Deg.Y() == Approx(-0.0).margin(1e-14));\n\tCHECK(tangentAt360Deg.X() == Approx(0.0).margin(1e-14));\n\tCHECK(tangentAt360Deg.Y() == Approx(2.0));\n\tstd::cout << \"Tangent at 0 deg: \" << tangentAt0 << std::endl;\n\tstd::cout << \"Tangent at 90 deg: \" << tangentAt90Deg << std::endl;\n\tstd::cout << \"Tangent at 180 deg: \" << tangentAt180Deg << std::endl;\n\tstd::cout << \"Tangent at 270 deg: \" << tangentAt270Deg << std::endl;\n\tstd::cout << \"Tangent at 360 deg: \" << tangentAt360Deg << std::endl;\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] AMCAX_API static Point2 CircleD0(double u, const Frame2& pos, double radius)\t @return The point\n\t @param radius The radius\n\t @param pos The local frame where the circle lies\n\t @param u The parameter\n\t @brief Compute the point on a 2D circle represented by a local frame and a radius at a parameter\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <common/PointT.hpp>\n#include <math/CurveCalculation.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"case1: CurveCalculation::CircleD0 1/2 \", \"[math][CurveCalculation][P1]\") {\n\tDirection2 defaultDirection(1.0,0.0); \n\tFrame2 defaultFrame2(Point2(0.0, 0.0), defaultDirection);\n\tdouble \tr = 3.0;\n\tdouble u = 4 * M_PI ; \n\tPoint2  pointOnCirecle = CurveCalculation::CircleD0(u, defaultFrame2, r);\n\tstd::cout << pointOnCirecle.X() << \" \" << pointOnCirecle.Y() << \" \"  << std::endl;\n\tCHECK(pointOnCirecle.X() == 3.0);\n\tCHECK(pointOnCirecle.Y() == Approx(0.0).margin(1e-14));\n\tCHECK(pointOnCirecle.X() * pointOnCirecle.X() + pointOnCirecle.Y() * pointOnCirecle.Y() == r * r);\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] AMCAX_API static Point3 CircleD0(double u, const Frame3& pos, double radius)\t @return The point\n\t @param radius The radius\n\t @param pos The local frame where the circle lies\n\t @param u The parameter\n\t @brief Compute the point on a 3D circle represented by a local frame and a radius at a parameter\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <common/PointT.hpp>\n#include <math/CurveCalculation.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"case1: CurveCalculation::CircleD0 2/2 \", \"[math][CurveCalculation][P1]\") {\n\tDirection3 defaultDirection(-1.0, 0.0,0.0); \n\tFrame3 defaultFrame3(Point3(1.0, 0.0,0.0), defaultDirection);\n\tdouble \tr = 3.0;\n\tdouble u = 2 * M_PI / 4; \n\tPoint3  pointOnCirecle = CurveCalculation::CircleD0(u, defaultFrame3, r);\n\tstd::cout << pointOnCirecle.X() << \" \" << pointOnCirecle.Y() << \" \" << pointOnCirecle.Y() << std::endl;\n\tCHECK(pointOnCirecle.X() == Approx(1.0).epsilon(1e-12));\n\tCHECK(pointOnCirecle.Y() == -3.0);\n\tCHECK((pointOnCirecle.X() - 1.0) * (pointOnCirecle.X() - 1.0) + pointOnCirecle.Y() * pointOnCirecle.Y() == r * r);\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] AMCAX_API static Point2 CircleValue(double u, const Frame2& pos, double radius)\t @return The point\n\t @param radius The radius\n\t @param pos The local frame where the circle lies\n\t @param u The parameter\n\t @brief Compute the point on a 2D circle represented by a local frame and a radius at a parameter\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <common/PointT.hpp>\n#include <math/CurveCalculation.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"case1: CurveCalculation::CircleValue()[1 / 2] \", \"[math][CurveCalculation][P1][CircleValue]\") {\n\tDirection2 defaultDirection(1.0, 0.0); \n\tFrame2 defaultFrame2(Point2(1.0, 1.0), defaultDirection);\n\tPoint2 point2 = AMCAX::CurveCalculation::CircleValue(0.0, defaultFrame2, 3.0);\n\tCHECK(point2.X() == 4.0);\n\tCHECK(point2.Y() == 1.0);\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] AMCAX_API static Point3 CircleValue(double u, const Frame3& pos, double radius)\t @return The point\n\t @param radius The radius\n\t @param pos The local frame where the circle lies\n\t @param u The parameter\n\t @brief Compute the point on a 3D circle represented by a local frame and a radius at a parameter\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <common/PointT.hpp>\n#include <math/CurveCalculation.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"case1: CurveCalculation::CircleD3 3/4 \", \"[math][CurveCalculation][P1][CircleD3]\") {\n\tDirection3 initialDir(0.0, 0.0, 1.0); \n\tFrame3 defaultFrame3(Point3(1.0, 1.0, 0.0), initialDir); \n\tdouble radius = 2.0; \n\tVector3 tangentAt0 = AMCAX::CurveCalculation::CircleD3(0.0, defaultFrame3, radius);\n\tVector3 tangentAt90Deg = AMCAX::CurveCalculation::CircleD3(M_PI_2, defaultFrame3, radius);\n\tVector3 tangentAt180Deg = AMCAX::CurveCalculation::CircleD3(M_PI, defaultFrame3, radius);\n\tVector3 tangentAt270Deg = AMCAX::CurveCalculation::CircleD3(3 * M_PI_2, defaultFrame3, radius);\n\tVector3 tangentAt360Deg = AMCAX::CurveCalculation::CircleD3(2 * M_PI, defaultFrame3, radius);\n\tCHECK(tangentAt0.X() == Approx(0.0));\n\tCHECK(tangentAt0.Y() == Approx(-2.0));\n\tCHECK(tangentAt0.Z() == Approx(-0.0));\n\tCHECK(tangentAt90Deg.X() == Approx(2.0).margin(1e-14));\n\tCHECK(tangentAt90Deg.Y() == Approx(-0.0).margin(1e-14));\n\tCHECK(tangentAt90Deg.Z() == Approx(0.0).margin(1e-14));\n\tCHECK(tangentAt180Deg.X() == Approx(0.0).margin(1e-14));\n\tCHECK(tangentAt180Deg.Y() == Approx(2.0).margin(1e-14));\n\tCHECK(tangentAt180Deg.Z() == Approx(0.0));\n\tCHECK(tangentAt270Deg.X() == Approx(-2.0).margin(1e-14));\n\tCHECK(tangentAt270Deg.Y() == Approx(0.0).margin(1e-14));\n\tCHECK(tangentAt270Deg.Z() == Approx(0.0).margin(1e-14));\n\tCHECK(tangentAt360Deg.X() == Approx(-0.0).margin(1e-14));\n\tCHECK(tangentAt360Deg.Y() == Approx(-2.0).margin(1e-14));\n\tCHECK(tangentAt360Deg.Z() == Approx(0.0).margin(1e-14));\n\tstd::cout << \"Tangent at 0 deg: \" << tangentAt0 << std::endl;\n\tstd::cout << \"Tangent at 90 deg: \" << tangentAt90Deg << std::endl;\n\tstd::cout << \"Tangent at 180 deg: \" << tangentAt180Deg << std::endl;\n\tstd::cout << \"Tangent at 270 deg: \" << tangentAt270Deg << std::endl;\n\tstd::cout << \"Tangent at 360 deg: \" << tangentAt360Deg << std::endl;\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static void AdjustPeriodic(double ufirst, double ulast, double precision, double& u1, double& u2)\t @param[in,out] u2 The second parameter to be adjust\n\t @param[in,out] u1 The first parameter to be adjust\n\t @param[in] precision The precision to check equality\n\t @param[in] ulast The upper bound of the period\n\t @param[in] ufirst The lower bound of the period\n\t          The parameter u2 is set in the range [u1, u1 + ulast - ufirst]\n\t @details The parameter u1 is set in the range [ufirst, ulast]\n\t @brief Adjust u1 and u2 to be in the period range.\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <common/PointT.hpp>\n#include <math/CurveCalculation.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"case1: CurveCalculation::AdjustPeriodic \", \"[math][CurveCalculation][P1]\") {\n\tdouble u1 = 0.0;\n\tdouble u2 = 2 * M_PI;\n\tdouble ufirst = 0.0;\n\tdouble ulast = 2 * M_PI; \n\tdouble precision = 0.001; \n\tAMCAX::CurveCalculation::AdjustPeriodic(ufirst, ulast, precision, u1, u2);\n\tCHECK(u1 == 0);\n\tCHECK(u2 == 2 * M_PI);\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] AMCAX_API static Vector2 D1(double u, const Circle2& circle)\t @return The first derivative vector\n\t @param circle The circle\n\t @param u The parameter\n\t @brief Compute the first derivative on a 2D circle at a parameter\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <common/PointT.hpp>\n#include <math/CurveCalculation.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"case1: CurveCalculation::CircleD1 1/4 \", \"[math][CurveCalculation][P1][CircleD1]\") {\n\tDirection2 initialDir(1.0, 0.0); \n\tFrame2 defaultFrame2(Point2(1.0, 1.0), initialDir); \n\tdouble radius = 2.0; \n\tVector2 tangentAt0 = AMCAX::CurveCalculation::CircleD1(0.0, defaultFrame2, radius);\n\tVector2 tangentAt90Deg = AMCAX::CurveCalculation::CircleD1(M_PI_2, defaultFrame2, radius);\n\tVector2 tangentAt180Deg = AMCAX::CurveCalculation::CircleD1(M_PI, defaultFrame2, radius);\n\tVector2 tangentAt270Deg = AMCAX::CurveCalculation::CircleD1(3 * M_PI_2, defaultFrame2, radius);\n\tVector2 tangentAt360Deg = AMCAX::CurveCalculation::CircleD1(2 * M_PI, defaultFrame2, radius);\n\tCHECK(tangentAt0.X() == Approx(-0.0));\n\tCHECK(tangentAt0.Y() == Approx(2.0));\n\tCHECK(tangentAt90Deg.X() == Approx(-2.0));\n\tCHECK(tangentAt90Deg.Y() == Approx(0.0).margin(1e-14));\n\tCHECK(tangentAt180Deg.X() == Approx(-0.0).margin(1e-14));\n\tCHECK(tangentAt180Deg.Y() == Approx(-2.0));\n\tCHECK(tangentAt270Deg.X() == Approx(2.0));\n\tCHECK(tangentAt270Deg.Y() == Approx(-0.0).margin(1e-14));\n\tCHECK(tangentAt360Deg.X() == Approx(0.0).margin(1e-14));\n\tCHECK(tangentAt360Deg.Y() == Approx(2.0));\n\tstd::cout << \"Tangent at 0 deg: \" << tangentAt0 << std::endl;\n\tstd::cout << \"Tangent at 90 deg: \" << tangentAt90Deg << std::endl;\n\tstd::cout << \"Tangent at 180 deg: \" << tangentAt180Deg << std::endl;\n\tstd::cout << \"Tangent at 270 deg: \" << tangentAt270Deg << std::endl;\n\tstd::cout << \"Tangent at 360 deg: \" << tangentAt360Deg << std::endl;\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static void AdjustPeriodic(double ufirst, double ulast, double precision, double& u1, double& u2)\t @param[in,out] u2 The second parameter to be adjust\n\t @param[in,out] u1 The first parameter to be adjust\n\t @param[in] precision The precision to check equality\n\t @param[in] ulast The upper bound of the period\n\t @param[in] ufirst The lower bound of the period\n\t          The parameter u2 is set in the range [u1, u1 + ulast - ufirst]\n\t @details The parameter u1 is set in the range [ufirst, ulast]\n\t @brief Adjust u1 and u2 to be in the period range.\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <common/PointT.hpp>\n#include <math/CurveCalculation.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"case1: CurveCalculation::AdjustPeriodic \", \"[math][CurveCalculation][P1]\") {\n\tdouble u1 = 0.0;\n\tdouble u2 = 2 * M_PI;\n\tdouble ufirst = 0.0;\n\tdouble ulast = 2 * M_PI; \n\tdouble precision = 0.001; \n\tAMCAX::CurveCalculation::AdjustPeriodic(ufirst, ulast, precision, u1, u2);\n\tCHECK(u1 == 0);\n\tCHECK(u2 == 2 * M_PI);\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API int IsInOutOn(const Point2& p, double tol)\t @return 1: in; 0: on; -1: out\n\t @param tol The tolerance of the point\n\t @param p The test point\n\t @brief Check a point is in or out of the polygon\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <common/PointT.hpp>\n#include <math/Classifier2d.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"case3: Classifier2d \", \"[math][Classifier2d][P1]\") {\n    std::vector<Point2> pts = {\n        Point2(2.0, 0.0),\n        Point2(1.0, 1.0),\n        Point2(2.0, 2.0),\n        Point2(3.0, 2.0)\n    }; \n    double tolU = 0.1;\n    double tolV = 0.1;\n    double uMin = 0.0;\n    double vMin = 0.0;\n    double uMax = 2.5;\n    double vMax = 1.5;\n    Classifier2d classifier(pts, tolU, tolV, uMin, vMin, uMax, vMax);\n\tSECTION(\"IsInOutOn Point normal set\") {\n        Point2 OutPoint(0.0, 0.0);\n        Point2 OnPoint(1.0, 1.0);\n        Point2 AnothOnPoint(2.0, 2.0);\n        Point2 InPoint(2.0, 1.0);\n        CHECK(classifier.IsInOutOn(OutPoint,0.0) == -1);\n        CHECK(classifier.IsInOutOn(OnPoint,0.0) != 0);\n        CHECK(classifier.IsInOutOn(OnPoint, 1.0) == 0);\n        CHECK(classifier.IsInOutOn(AnothOnPoint, 1.0) == 0); \n        CHECK(classifier.IsInOutOn(InPoint,0.0) == 1);\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API int IsInOut(const Point2& p)\t @return 1: in; 0: on; -1: out\n\t @param p The test point\n\t @brief Check a point is in or out of the polygon\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <common/PointT.hpp>\n#include <math/Classifier2d.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"case1: Classifier2d \", \"[math][Classifier2d][P1]\") {\n    std::vector<Point2> pts = {\n        Point2(2.0, 0.0),\n        Point2(1.0, 1.0),\n        Point2(2.0, 2.0),\n        Point2(3.0, 2.0)\n    }; \n    double tolU = 0.1;\n    double tolV = 0.1;\n    double uMin = 0.0;\n    double vMin = 0.0;\n    double uMax = 2.5;\n    double vMax = 1.5;\n    Classifier2d classifier(pts, tolU, tolV, uMin, vMin, uMax, vMax);\n\tSECTION(\"IsInOut Point normal set\") {\n        Point2 OutPoint(0.0, 0.0);\n        Point2 OnPoint(1.0, 1.0);\n        Point2 InPoint(2.0, 1.0);\n        CHECK(classifier.IsInOut(OutPoint) == -1);\n        CHECK(classifier.IsInOut(OnPoint) == 0);\n        CHECK(classifier.IsInOut(InPoint) == 1);\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API Classifier2d(const std::vector<Point2>& pts, double tolU, double tolV, double uMin, double vMin, double uMax, double vMax)\t @param vMax The upper bound of v\n\t @param uMax The upper bound of u\n\t @param vMin The lower bound of v\n\t @param uMin The lower bound of u\n\t @param tolV The tolerance of v bound\n\t @param tolU The tolerance of u bound\n\t @param pts The points of a 2D closed polygon, the last point does not required to repeat the first point\n\t @details Require uMax > uMin, vMax > vMin, and at least 3 points\n\t @brief Construct from a 2D polygon and uv-bounds\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <common/PointT.hpp>\n#include <math/Classifier2d.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"case1: Classifier2d \", \"[math][Classifier2d][P1]\") {\n    std::vector<Point2> pts = {\n        Point2(2.0, 0.0),\n        Point2(1.0, 1.0),\n        Point2(2.0, 2.0),\n        Point2(3.0, 2.0)\n    }; \n    double tolU = 0.1;\n    double tolV = 0.1;\n    double uMin = 0.0;\n    double vMin = 0.0;\n    double uMax = 2.5;\n    double vMax = 1.5;\n    Classifier2d classifier(pts, tolU, tolV, uMin, vMin, uMax, vMax);\n\tSECTION(\"IsInOut Point normal set\") {\n        Point2 OutPoint(0.0, 0.0);\n        Point2 OnPoint(1.0, 1.0);\n        Point2 InPoint(2.0, 1.0);\n        CHECK(classifier.IsInOut(OutPoint) == -1);\n        CHECK(classifier.IsInOut(OnPoint) == 0);\n        CHECK(classifier.IsInOut(InPoint) == 1);\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] LineS Rotated(const Axis3& axis, double angle)\t @return The rotated line\n\t @param angle The rotation angle\n\t @param axis The rotation axis\n\t @brief Get the line rotated around an axis with an angle in 3D\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <math/LineT.hpp>\n#include <math/Plane.hpp>\n#include <modeling/MakeFace.hpp>\n#include <modeling/MakeEdge.hpp>\nusing AMCAX::Line3;\nusing AMCAX::MakeEdge;\nusing AMCAX::MakeFace;\n#define ONE_RADIAN (M_PI / 180.)\n#define SQUARE(x) ((x) * (x))\nTEST_CASE(\"case1: Derived class interface unit testing\", \"[math][Line3][p1]\")\n{\n\tSECTION(\"Rotate\")\n\t{\n\t\tAxis3 axis(Point3(0., 0., 0.), Direction3(0., 1., 0.));\n\t\tLine3 line(Point3(0., 0., 0.), Direction3(1., 1., -1.));\n\t\tLine3 rotateLine = line.Rotated(axis, 90. * ONE_RADIAN);  \n\t\tTopoEdge edge1 = MakeEdge(line);\n\t\tTopoEdge edge2 = MakeEdge(rotateLine);\n\t\tTopoEdge edge3 = MakeEdge(Line3(axis));\n\t\tbool isWriteSuccess1 = AMCAX::OCCTIO::OCCTTool::Write(edge1, OUTPUT_PATH_PREFIX\"Line3_Rotate_line.brep\");\n\t\tbool isWriteSuccess2 = AMCAX::OCCTIO::OCCTTool::Write(edge2, OUTPUT_PATH_PREFIX\"Line3_Rotate_lineRotate.brep\");\n\t\tbool isWriteSuccess3 = AMCAX::OCCTIO::OCCTTool::Write(edge3, OUTPUT_PATH_PREFIX\"Line3_Rotate_axis.brep\");\n\t\tREQUIRE(isWriteSuccess1);\n\t\tREQUIRE(isWriteSuccess2);\n\t\tREQUIRE(isWriteSuccess3);\n\t\tauto pointToPoint = [](const Point3& p1, const Point3& p2) {\n\t\t\treturn std::sqrt(\n\t\t\t\tSQUARE(p1.X() - p2.X()) +\n\t\t\t\tSQUARE(p1.Y() - p2.Y()) +\n\t\t\t\tSQUARE(p1.Z() - p2.Z())\n\t\t\t);\n\t\t};\n\t\tCHECK(line.Distance(Line3(axis)) == Approx(rotateLine.Distance(Line3(axis))).margin(std::numeric_limits<double>::min()));\n\t\tCHECK(pointToPoint(line.Location(), Point3()) == Approx(pointToPoint(rotateLine.Location(), Point3())).margin(std::numeric_limits<double>::min()));\n\t\tPoint3 p(-1., 1., -1.);\n\t\tCHECK(rotateLine.Contains(p, 1e-6) == true);\n\t}\n}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "LineS& Mirror(const Frame3& frame)\t @return The reference to self\n\t @param frame The mirror frame\n\t @brief Mirror the line by a frame\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <math/LineT.hpp>\n#include <math/Plane.hpp>\n#include <modeling/MakeFace.hpp>\n#include <modeling/MakeEdge.hpp>\nusing AMCAX::Line3;\nusing AMCAX::MakeEdge;\nusing AMCAX::MakeFace;\n#define ONE_RADIAN (M_PI / 180.)\n#define SQUARE(x) ((x) * (x))\nTEST_CASE(\"case1: Derived class interface unit testing\", \"[math][Line3][p1]\")\n{\n\tSECTION(\"Mirror\")\n\t{\n\t\tLine3 line(Point3(1.0, 2.0, 3.0), Direction3(1.0, 0.0, 0.0));\n\t\tLine3 originalLine(Point3(1.0, 2.0, 3.0), Direction3(1.0, 0.0, 0.0));\n\t\tFrame3 frame(Point3(0.0, 0.0, 0.0), Direction3(0.0, 1.0, 0.0));\n\t\tline.Mirror(frame);\n\t\tCHECK(line.Distance(Point3(0.0, 0.0, 0.0)) == Approx(originalLine.Distance(Point3(0., 0., 0.))).margin(std::numeric_limits<double>::min()));\n\t\tDirection3 dir(originalLine.Location().X() - line.Location().X(),\n\t\t\t\t\t   originalLine.Location().Y() - line.Location().Y(),\n\t\t\t\t\t   originalLine.Location().Z() - line.Location().Z());\n\t\tCHECK(dir.IsParallel(Direction3(0.0, 1.0, 0.0), 1e-5 * ONE_RADIAN));\n\t\tLine3 line2(Point3(1.2, -4.6, 2.3), Direction3(1.8, 97.4, -12.8));\n\t\tFrame3 frame2(Point3(87.0, 2.3, 10.14), Direction3(-92.3, 2.6, 1.0));\n\t\tLine3 mirrorLine2 = line2.Mirrored(frame2);\n\t\tCHECK(line2.Distance(Point3(87.0, 2.3, 10.14)) == Approx(mirrorLine2.Distance(Point3(87.0, 2.3, 10.14))).margin(std::numeric_limits<double>::min()));\n\t\tDirection3 dir2(line2.Location().X() - mirrorLine2.Location().X(),\n\t\t\t\t\t    line2.Location().Y() - mirrorLine2.Location().Y(),\n\t\t\t\t\t    line2.Location().Z() - mirrorLine2.Location().Z());\n\t\tCHECK(dir2.IsParallel(Direction3(-92.3, 2.6, 1.0), 1e-5 * ONE_RADIAN));\n\t\tTopoFace face = MakeFace(Plane(frame2), 0., 4., 0., 4.);\n\t\tTopoEdge edgeLine2 = MakeEdge(line2, 0., 1.);\n\t\tTopoEdge edgeMirrorLine2 = MakeEdge(mirrorLine2, 0., 1.);\n\t\tAMCAX::OCCTIO::OCCTTool::Write(face, OUTPUT_PATH_PREFIX\"Line3_Mirror_face2.brep\");\n\t\tAMCAX::OCCTIO::OCCTTool::Write(edgeLine2, OUTPUT_PATH_PREFIX\"Line3_Mirror_edge.brep\");\n\t\tAMCAX::OCCTIO::OCCTTool::Write(edgeMirrorLine2, OUTPUT_PATH_PREFIX\"Line3_Mirror_Mirroredge.brep\");\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] LineS Normal(const Point3& p)\t @return The line passing through a point and perpendicular to the line\n\t @param p The point\n\t @brief Get a line passing through a point and perpendicular to the line\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <math/LineT.hpp>\n#include <math/Plane.hpp>\n#include <modeling/MakeFace.hpp>\n#include <modeling/MakeEdge.hpp>\nusing AMCAX::Line3;\nusing AMCAX::MakeEdge;\nusing AMCAX::MakeFace;\n#define ONE_RADIAN (M_PI / 180.)\n#define SQUARE(x) ((x) * (x))\nTEST_CASE(\"case1: Derived class interface unit testing\", \"[math][Line3][p1]\")\n{\n\tSECTION(\"Normal\")\n\t{\n\t\tLine3 line(Point3(94., 32., 4.8), Direction3(2.65, 3.28, 5.14));\n\t\tLine3 line2 = line.Normal(Point3(2.1, 3.4, 11.2));\n\t\tCHECK(line.Direction().Dot(line2.Direction()) == Approx(0.).margin(1e-6));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] auto Distance(const Point3& p)\t @return The distance between the point and the line\n\t @param p The point\n\t @brief Compute the distance from a point to the line\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <math/LineT.hpp>\n#include <math/Plane.hpp>\n#include <modeling/MakeFace.hpp>\n#include <modeling/MakeEdge.hpp>\nusing AMCAX::Line3;\nusing AMCAX::MakeEdge;\nusing AMCAX::MakeFace;\n#define ONE_RADIAN (M_PI / 180.)\n#define SQUARE(x) ((x) * (x))\nTEST_CASE(\"case2: Line3 base method Test\", \"[math][Line3][p1]\")\n{\n\tSECTION(\"Scale\")\n\t{\n\t\tLine3 line(Point3(), Direction3(0., 1., 0.));\n\t\tPoint3 point(1., 1., 0.);\n\t\tdouble originalDistance = line.Distance(point);\n\t\tLine3 line1 = line.Scaled(point, 1.1);\n\t\tCHECK(line1.Distance(point) > originalDistance);\n\t\tLine3 line2 = line.Scaled(point, 1.);\n\t\tCHECK(line2.Distance(point) == originalDistance);\n\t\tLine3 line3 = line.Scaled(point, 0.8);\n\t\tCHECK(line3.Distance(point) < originalDistance);\n\t\tLine3 line4 = line.Scaled(point, 0.);\n\t\tCHECK(line4.Contains(point, 1e-6));\n\t\tLine3 line5 = line.Scaled(point, -1.);\n\t\tCHECK(line5.Direction().IsEqual(Direction3(0., -1., 0.), 1e-6 * ONE_RADIAN));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] auto SquaredDistance(const LineS& l)\t @return The squared distance between two lines\n\t @param l The other line\n\t @brief Compute the squared distance between two lines\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <math/LineT.hpp>\n#include <math/Plane.hpp>\n#include <modeling/MakeFace.hpp>\n#include <modeling/MakeEdge.hpp>\nusing AMCAX::Line3;\nusing AMCAX::MakeEdge;\nusing AMCAX::MakeFace;\n#define ONE_RADIAN (M_PI / 180.)\n#define SQUARE(x) ((x) * (x))\nTEST_CASE(\"case1: Derived class interface unit testing\", \"[math][Line3][p1]\")\n{\n\tSECTION(\"Distance and SquaredDistance\")\n\t{\n\t\tauto pointToLine = [](const Point3& p, const Line3& line) {\n\t\t\tconst Point3& p1 = line.Location();\n\t\t\tdouble dX = p1.X() - p.X();\n\t\t\tdouble dY = p1.Y() - p.Y();\n\t\t\tdouble dZ = p1.Z() - p.Z();\n\t\t\tdouble pp1Square = SQUARE(dX) + SQUARE(dY) + SQUARE(dZ);\n\t\t\tDirection3 dir(dX, dY, dZ);\n\t\t\tdouble cos = std::fabs(dir.Dot(line.Direction()));\n\t\t\treturn std::sqrt(pp1Square - SQUARE(cos*std::sqrt(pp1Square)));\n\t\t};\n\t\tauto lineToLine = [&pointToLine](const Line3& line1, const Line3& line2) {\n\t\t\tif (line1.Direction().IsParallel(line2.Direction(), std::numeric_limits<double>::min()))\n\t\t\t\treturn pointToLine(line1.Location(), line2);\n\t\t\tDirection3 line1Dir = line1.Direction();\n\t\t\tDirection3 line2Dir = line2.Direction();\n\t\t\tdouble x3 = line1Dir.Y() * line2Dir.Z() - line2Dir.Y() * line1Dir.Z();\n\t\t\tdouble y3 = -(line1Dir.X() * line2Dir.Z() - line2Dir.X() * line1Dir.Z());\n\t\t\tdouble z3 = line1Dir.X() * line2Dir.Y() - line2Dir.X() * line1Dir.Y();\n\t\t\tDirection3 line3Dir(x3, y3, z3);\n\t\t\tDirection3 line12Dir(line1.Location().X() - line2.Location().X(), \n\t\t\t\t\t\t\t\t line1.Location().Y() - line2.Location().Y(), line1.Location().Z() - line2.Location().Z());\n\t\t\treturn std::fabs(line3Dir.Dot(line12Dir));\n\t\t};\n\t\tLine3 line(Point3(99., 2., 33.), Direction3(2.3, 4.6, 9.8));\n\t\tCHECK(line.Distance(Point3(0., 1., 0.)) == Approx(pointToLine(Point3(0., 1., 0.), line)).margin(1e-5));\n\t\tLine3 line2(Point3(0., 0., 0.), Direction3(1., 0., 0.));\n\t\tLine3 line3(Point3(0., 1., 0.), Direction3(1., 0., 0.));\n\t\tCHECK(line2.Distance(line3) == Approx(lineToLine(line2, line3)).margin(std::numeric_limits<double>::min()));\n\t\tCHECK(line2.SquaredDistance(line3) == Approx(SQUARE(lineToLine(line2, line3))).margin(std::numeric_limits<double>::min()));\n\t\tLine3 line4(Point3(0., 0., 0.), Direction3(1., 0., 0.));\n\t\tLine3 line5(Point3(0., 1., 0.), Direction3(1., 1., 0.));\n\t\tCHECK(line4.Distance(line5) == Approx(lineToLine(line4, line5)).margin(std::numeric_limits<double>::min()));\n\t\tLine3 line6(Point3(0., 0., 0.), Direction3(0., 0., 1.));\n\t\tLine3 line7(Point3(0., 1., 0.), Direction3(1., 1., 0.));\n\t\tCHECK(line6.Distance(line7) == Approx(lineToLine(line6, line7)).margin(std::numeric_limits<double>::min()));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] Derived Reversed()\t @return The line with reversed direction\n\t @brief Get the line with reversed direction\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <math/LineT.hpp>\n#include <math/Plane.hpp>\n#include <modeling/MakeFace.hpp>\n#include <modeling/MakeEdge.hpp>\nusing AMCAX::Line3;\nusing AMCAX::MakeEdge;\nusing AMCAX::MakeFace;\n#define ONE_RADIAN (M_PI / 180.)\n#define SQUARE(x) ((x) * (x))\nTEST_CASE(\"case2: Line3 base method Test\", \"[math][Line3][p1]\")\n{\n\tSECTION(\"Reverse\")\n\t{\n\t\tLine3 line(Point3(), Direction3(1., 1., 1.));\n\t\tLine3 reverseLine = line.Reversed();\n\t\tCHECK(reverseLine.Direction().IsEqual(Direction3(-1., -1., -1.), 1e-6 * ONE_RADIAN));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] auto Angle(const LineBase& other)\t @return The angle between the line and the other line\n\t @param other The other line\n\t @brief Compute the angle between the line and the other line\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <math/LineT.hpp>\n#include <math/Plane.hpp>\n#include <modeling/MakeFace.hpp>\n#include <modeling/MakeEdge.hpp>\nusing AMCAX::Line3;\nusing AMCAX::MakeEdge;\nusing AMCAX::MakeFace;\n#define ONE_RADIAN (M_PI / 180.)\n#define SQUARE(x) ((x) * (x))\nTEST_CASE(\"case2: Line3 base method Test\", \"[math][Line3][p1]\")\n{\n\tSECTION(\"Angle\")\n\t{\n\t\tLine3 line(Point3(0., 1., 0.), Direction3(1., 1., 1.));\n\t\tLine3 line2(Point3(0., 3.4, 0.), Direction3(2., -1., -1.5));\n\t\tCHECK(line.Angle(line2) == Approx(std::acos(line.Direction().Dot(line2.Direction()))).margin(1e-6 * ONE_RADIAN));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] const AxisT<double, DIM>& Position()\t @return The axis of the line\n\t @brief Get the axis of the line\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <math/LineT.hpp>\n#include <math/Plane.hpp>\n#include <modeling/MakeFace.hpp>\n#include <modeling/MakeEdge.hpp>\nusing AMCAX::Line3;\nusing AMCAX::MakeEdge;\nusing AMCAX::MakeFace;\n#define ONE_RADIAN (M_PI / 180.)\n#define SQUARE(x) ((x) * (x))\nTEST_CASE(\"case1: Derived class interface unit testing\", \"[math][Line3][p1]\")\n{\n\tSECTION(\"constructor\")\n\t{\n\t\tLine3 line;  \n\t\tCHECK(line.Location().IsEqual(Point3(0., 0., 0.), 1e-5));\n\t\tCHECK(line.Direction().IsEqual(Direction3(0., 0., 1.), 1e-5 * ONE_RADIAN));\n\t\tAxis3 axis(Point3(1., 1., 1.), Direction3(3., 3., 4.));\n\t\tLine3 line2(axis);\n\t\tCHECK(line2.Position().IsCoaxial(axis, 1e-5 * ONE_RADIAN, 1e-5));  \n\t\tLine3 line3(Point3(1., 2., 3.), Direction3(3., 2., 1.));\n\t\tCHECK(line3.Location().IsEqual(Point3(1., 2., 3.), 1e-5));\n\t\tCHECK(line3.Direction().IsEqual(Direction3(3., 2., 1.), 1e-5 * ONE_RADIAN));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] const DirectionT<double, DIM>& Direction()\t @return The direction of the line\n\t @brief Get the direction of the line\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <math/LineT.hpp>\n#include <math/Plane.hpp>\n#include <modeling/MakeFace.hpp>\n#include <modeling/MakeEdge.hpp>\nusing AMCAX::Line3;\nusing AMCAX::MakeEdge;\nusing AMCAX::MakeFace;\n#define ONE_RADIAN (M_PI / 180.)\n#define SQUARE(x) ((x) * (x))\nTEST_CASE(\"case1: Derived class interface unit testing\", \"[math][Line3][p1]\")\n{\n\tSECTION(\"constructor\")\n\t{\n\t\tLine3 line;  \n\t\tCHECK(line.Location().IsEqual(Point3(0., 0., 0.), 1e-5));\n\t\tCHECK(line.Direction().IsEqual(Direction3(0., 0., 1.), 1e-5 * ONE_RADIAN));\n\t\tAxis3 axis(Point3(1., 1., 1.), Direction3(3., 3., 4.));\n\t\tLine3 line2(axis);\n\t\tCHECK(line2.Position().IsCoaxial(axis, 1e-5 * ONE_RADIAN, 1e-5));  \n\t\tLine3 line3(Point3(1., 2., 3.), Direction3(3., 2., 1.));\n\t\tCHECK(line3.Location().IsEqual(Point3(1., 2., 3.), 1e-5));\n\t\tCHECK(line3.Direction().IsEqual(Direction3(3., 2., 1.), 1e-5 * ONE_RADIAN));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "void SetPosition(const AxisT<double, DIM>& axis)\t @param axis The axis\n\t @brief Set the axis of the line\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <math/LineT.hpp>\n#include <math/Plane.hpp>\n#include <modeling/MakeFace.hpp>\n#include <modeling/MakeEdge.hpp>\nusing AMCAX::Line3;\nusing AMCAX::MakeEdge;\nusing AMCAX::MakeFace;\n#define ONE_RADIAN (M_PI / 180.)\n#define SQUARE(x) ((x) * (x))\nTEST_CASE(\"case2: Line3 base method Test\", \"[math][Line3][p1]\")\n{\n\tSECTION(\"SetPosition\")\n\t{\n\t\tAxis3 axis(Point3(0.1, -2.3, 0.3), Direction3(1.2, -8.9, 3.));\n\t\tLine3 line;\n\t\tline.SetPosition(axis);\n\t\tCHECK(line.Location().IsEqual(axis.Location(), std::numeric_limits<double>::min()));\n\t\tCHECK(line.Direction().IsEqual(axis.Direction(), std::numeric_limits<double>::min()));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "void SetDirection(const DirectionT<double, DIM>& dir)\t @param dir The line direction\n\t @brief Set the line direction\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <math/LineT.hpp>\n#include <math/Plane.hpp>\n#include <modeling/MakeFace.hpp>\n#include <modeling/MakeEdge.hpp>\nusing AMCAX::Line3;\nusing AMCAX::MakeEdge;\nusing AMCAX::MakeFace;\n#define ONE_RADIAN (M_PI / 180.)\n#define SQUARE(x) ((x) * (x))\nTEST_CASE(\"case2: Line3 base method Test\", \"[math][Line3][p1]\")\n{\n\tSECTION(\"SetDirection\")\n\t{\n\t\tDirection3 dir(1., 1., 1.);\n\t\tLine3 line;\n\t\tline.SetDirection(dir);\n\t\tCHECK(line.Direction().IsEqual(dir, std::numeric_limits<double>::min()));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "void SetLocation(const PointT<double, DIM>& point)\t @param point The location point\n\t @brief Set the location of the line\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <math/LineT.hpp>\n#include <math/Plane.hpp>\n#include <modeling/MakeFace.hpp>\n#include <modeling/MakeEdge.hpp>\nusing AMCAX::Line3;\nusing AMCAX::MakeEdge;\nusing AMCAX::MakeFace;\n#define ONE_RADIAN (M_PI / 180.)\n#define SQUARE(x) ((x) * (x))\nTEST_CASE(\"case2: Line3 base method Test\", \"[math][Line3][p1]\")\n{\n\tSECTION(\"SetLocation\")\n\t{\n\t\tLine3 line(Point3(2., 3., 2.), Direction3(2., 3.4, -2.));\n\t\tline.SetLocation(Point3(1., -2., 8.));\n\t\tCHECK(line.Location().IsEqual(Point3(1., -2., 8.), std::numeric_limits<double>::min()));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] Derived Translated(const VectorT<double, DIM>& vec)\t @return The translated line\n\t @param vec The translation vector\n\t @brief Get the line translated by a vector\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <math/LineT.hpp>\n#include <math/Plane.hpp>\n#include <modeling/MakeFace.hpp>\n#include <modeling/MakeEdge.hpp>\nusing AMCAX::Line3;\nusing AMCAX::MakeEdge;\nusing AMCAX::MakeFace;\n#define ONE_RADIAN (M_PI / 180.)\n#define SQUARE(x) ((x) * (x))\nTEST_CASE(\"case2: Line3 base method Test\", \"[math][Line3][p1]\")\n{\n\tSECTION(\"Translate\")\n\t{\n\t\tLine3 line(Point3(), Direction3(1., 1., 1.));\n\t\tLine3 originalLine(Point3(), Direction3(1., 1., 1.));\n\t\tline.Translate(Point3(), Point3(0., 1., 0.));\n\t\tCHECK(originalLine.Direction().IsEqual(line.Direction(), 1e-6 * ONE_RADIAN));\n\t\tCHECK(line.Contains(Point3(0., 1., 0.), 1e-6));\n\t\tLine3 line2 = line.Translated(Vector3(Direction3(1., -1., 1.)));\n\t\tCHECK(line.Direction().IsEqual(line2.Direction(), 1e-6 * ONE_RADIAN));\n\t\tCHECK(line2.Contains(Point3(0. + 1. / std::sqrt(3.), 1 - 1. / std::sqrt(3.), 0. + 1. / std::sqrt(3.)), 1e-6));\n\t}\n}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "Derived& Translate(const PointT<double, DIM>& p1, const PointT<double, DIM>& p2)\t @return The reference to self\n\t @param p2 The target point\n\t @param p1 The source point\n\t @brief Translate the line by a vector from a point to another point\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <math/LineT.hpp>\n#include <math/Plane.hpp>\n#include <modeling/MakeFace.hpp>\n#include <modeling/MakeEdge.hpp>\nusing AMCAX::Line3;\nusing AMCAX::MakeEdge;\nusing AMCAX::MakeFace;\n#define ONE_RADIAN (M_PI / 180.)\n#define SQUARE(x) ((x) * (x))\nTEST_CASE(\"case2: Line3 base method Test\", \"[math][Line3][p1]\")\n{\n\tSECTION(\"Translate\")\n\t{\n\t\tLine3 line(Point3(), Direction3(1., 1., 1.));\n\t\tLine3 originalLine(Point3(), Direction3(1., 1., 1.));\n\t\tline.Translate(Point3(), Point3(0., 1., 0.));\n\t\tCHECK(originalLine.Direction().IsEqual(line.Direction(), 1e-6 * ONE_RADIAN));\n\t\tCHECK(line.Contains(Point3(0., 1., 0.), 1e-6));\n\t\tLine3 line2 = line.Translated(Vector3(Direction3(1., -1., 1.)));\n\t\tCHECK(line.Direction().IsEqual(line2.Direction(), 1e-6 * ONE_RADIAN));\n\t\tCHECK(line2.Contains(Point3(0. + 1. / std::sqrt(3.), 1 - 1. / std::sqrt(3.), 0. + 1. / std::sqrt(3.)), 1e-6));\n\t}\n}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] Derived Transformed(const TransformationT<double, DIM>& tr)\t @return The transformed line\n\t @param tr The transformation\n\t @brief Get the transformed line\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <math/LineT.hpp>\n#include <math/Plane.hpp>\n#include <modeling/MakeFace.hpp>\n#include <modeling/MakeEdge.hpp>\nusing AMCAX::Line3;\nusing AMCAX::MakeEdge;\nusing AMCAX::MakeFace;\n#define ONE_RADIAN (M_PI / 180.)\n#define SQUARE(x) ((x) * (x))\nTEST_CASE(\"case2: Line3 base method Test\", \"[math][Line3][p1]\")\n{\n\tSECTION(\"Transform\")\n\t{\n\t\tLine3 line(Point3(), Direction3(0., 1., 0.));\n\t\tTransformation3 translationTransform;\n\t\ttranslationTransform.SetTranslation(Point3(0., 0., 0.), Point3(1., 1., 1.));  \n\t\tLine3 translationLine = line.Transformed(translationTransform);\n\t\tCHECK(translationLine.Direction().IsEqual(line.Direction(), 1e-6 * ONE_RADIAN));\n\t\tCHECK(translationLine.Contains(Point3(1., 1., 1.), 1e-6));\n\t\tTransformation3 rotationTransfrom;\n\t\trotationTransfrom.SetRotation(Axis3(Point3(), Direction3(1., 0., 0.)), 90. * ONE_RADIAN);  \n\t\tLine3 rotationLine = line.Transformed(rotationTransfrom);\n\t\tCHECK(rotationLine.Direction().IsEqual(Direction3(0., 0., 1.), 1e-6 * ONE_RADIAN));\n\t\tCHECK(rotationLine.Contains(Point3(0., 0., 3.), 1e-6) == true);\n\t\tTransformation3 scaleTransfrom;\n\t\tscaleTransfrom.SetScale(Point3(1., 0., 1.), -1.); \n\t\tLine3 scaleLine = line.Transformed(scaleTransfrom);\n\t\tCHECK(line.Distance(Point3(1., 0., 1.)) == scaleLine.Distance(Point3(1., 0., 1.)));\n\t\tCHECK(scaleLine.Direction().IsEqual(Direction3(0., -1., 0.), 1e-6*ONE_RADIAN));\n\t\tTransformation3 mirrorTransfrom;\n\t\tmirrorTransfrom.SetMirror(Frame3(Point3(0., 0., 0.), Direction3(1., 0., 0.)));\n\t\tLine3 mirrorLine = line.Transformed(mirrorTransfrom);\n\t\tCHECK(line.Distance(Point3(0., 0., 0.)) == mirrorLine.Distance(Point3(0., 0., 0.)));\n\t\tAMCAX::OCCTIO::OCCTTool::Write(MakeEdge(line), OUTPUT_PATH_PREFIX\"Line3_Transform_InitialLine.brep\");\n\t\tTransformation3 CombinedTransfrom = scaleTransfrom * mirrorTransfrom* translationTransform * rotationTransfrom;  \n\t\tline.Transform(CombinedTransfrom);\n\t\tAMCAX::OCCTIO::OCCTTool::Write(MakeEdge(line), OUTPUT_PATH_PREFIX\"Line3_Transform_transformLine.brep\");\n\t\tCHECK(line.Contains(Point3(3., -1., 1.), 1e-6) == true);\n\t\tCHECK(line.Direction().IsEqual(Direction3(0., 0., -1.), 1e-6 * ONE_RADIAN));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] Derived Scaled(const PointT<double, DIM>& point, double scale)\t @return The scaled line\n\t @param scale The scale value\n\t @param point The scaling center point\n\t @brief Get the line scaled by a point\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <math/LineT.hpp>\n#include <math/Plane.hpp>\n#include <modeling/MakeFace.hpp>\n#include <modeling/MakeEdge.hpp>\nusing AMCAX::Line3;\nusing AMCAX::MakeEdge;\nusing AMCAX::MakeFace;\n#define ONE_RADIAN (M_PI / 180.)\n#define SQUARE(x) ((x) * (x))\nTEST_CASE(\"case2: Line3 base method Test\", \"[math][Line3][p1]\")\n{\n\tSECTION(\"Scale\")\n\t{\n\t\tLine3 line(Point3(), Direction3(0., 1., 0.));\n\t\tPoint3 point(1., 1., 0.);\n\t\tdouble originalDistance = line.Distance(point);\n\t\tLine3 line1 = line.Scaled(point, 1.1);\n\t\tCHECK(line1.Distance(point) > originalDistance);\n\t\tLine3 line2 = line.Scaled(point, 1.);\n\t\tCHECK(line2.Distance(point) == originalDistance);\n\t\tLine3 line3 = line.Scaled(point, 0.8);\n\t\tCHECK(line3.Distance(point) < originalDistance);\n\t\tLine3 line4 = line.Scaled(point, 0.);\n\t\tCHECK(line4.Contains(point, 1e-6));\n\t\tLine3 line5 = line.Scaled(point, -1.);\n\t\tCHECK(line5.Direction().IsEqual(Direction3(0., -1., 0.), 1e-6 * ONE_RADIAN));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] const PointT<double, DIM>& Location()\t @return The location of the line\n\t @brief Get the location point of the line\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <math/LineT.hpp>\n#include <math/Plane.hpp>\n#include <modeling/MakeFace.hpp>\n#include <modeling/MakeEdge.hpp>\nusing AMCAX::Line3;\nusing AMCAX::MakeEdge;\nusing AMCAX::MakeFace;\n#define ONE_RADIAN (M_PI / 180.)\n#define SQUARE(x) ((x) * (x))\nTEST_CASE(\"case1: Derived class interface unit testing\", \"[math][Line3][p1]\")\n{\n\tSECTION(\"constructor\")\n\t{\n\t\tLine3 line;  \n\t\tCHECK(line.Location().IsEqual(Point3(0., 0., 0.), 1e-5));\n\t\tCHECK(line.Direction().IsEqual(Direction3(0., 0., 1.), 1e-5 * ONE_RADIAN));\n\t\tAxis3 axis(Point3(1., 1., 1.), Direction3(3., 3., 4.));\n\t\tLine3 line2(axis);\n\t\tCHECK(line2.Position().IsCoaxial(axis, 1e-5 * ONE_RADIAN, 1e-5));  \n\t\tLine3 line3(Point3(1., 2., 3.), Direction3(3., 2., 1.));\n\t\tCHECK(line3.Location().IsEqual(Point3(1., 2., 3.), 1e-5));\n\t\tCHECK(line3.Direction().IsEqual(Direction3(3., 2., 1.), 1e-5 * ONE_RADIAN));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] bool Contains(const PointT<double, DIM>& p, double tol)\t @return True if the point is on the line under the tolerance\n\t @param tol The tolerance\n\t @param p The point\n\t @brief Does the line contain a point under a distance tolerance\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <math/LineT.hpp>\n#include <math/Plane.hpp>\n#include <modeling/MakeFace.hpp>\n#include <modeling/MakeEdge.hpp>\nusing AMCAX::Line3;\nusing AMCAX::MakeEdge;\nusing AMCAX::MakeFace;\n#define ONE_RADIAN (M_PI / 180.)\n#define SQUARE(x) ((x) * (x))\nTEST_CASE(\"case2: Line3 base method Test\", \"[math][Line3][p1]\")\n{\n\tSECTION(\"Contains\")\n\t{\n\t\tLine3 line(Point3(), Direction3(1., 1., 1.));\n\t\tPoint3 point1(2., 2., 2.);\n\t\tPoint3 point2(2., 1., 2.);\n\t\tauto isContains = [](const Line3& line, const Point3& point) {\n\t\t\tDirection3 dir(line.Location().X() - point.X(), line.Location().Y() - point.Y(), line.Location().Z() - point.Z());\n\t\t\treturn line.Direction().IsParallel(dir, 1e-5);\n\t\t};\n\t\tCHECK(line.Contains(point1, 1e-5) == isContains(line, point1));\n\t\tCHECK(line.Contains(point2, 1e-5) == isContains(line, point2));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API ComputePointsAbscissa(double tol, const Adaptor3Curve& c, double abscissa, double u0)\t @param u0 The starting parameter\n\t @param abscissa The arc length\n\t @param c The curve\n\t @param tol The tolerance\n\t @brief Compute the parameter of a point on a 3D curve with given arc length and a tolerance\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/MakeGeom2Circle.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/ComputePointsAbscissa.hpp>\n#include <geometry/MakeGeom2Hyperbola.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/MakeGeom2Ellipse.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/AdaptorGeom3Curve.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <geometry/MakeGeom3Hyperbola.hpp>\n#include <geometry/MakeGeom3Ellipse.hpp>\nTEST_CASE(\"bug2: ComputePointsAbscissa \", \"[geometry][ComputePointsAbscissa][fixbug]\")\n{\n\tSECTION(\"arc length and tolerance-3D\")\n{\n    Frame3 frame;\n    double major = 5.0;\n    double minor = 4.0;\n    bool isRight = true;\n    std::shared_ptr< Geom3Hyperbola >h1 = MakeGeom3Hyperbola(frame, major, minor);\n    AdaptorGeom3Curve hyperbola(h1);\n    ComputePointsAbscissa cpa3(Precision::Confusion(), hyperbola, 1.0, 0.0);\n    double param3 = cpa3.Parameter();\n    Point3 point1(hyperbola.Value(param3));\n    CHECK(cpa3.Parameter());\n    MakeEdge edge1(h1, 0.0, param3);\n    CHECK(BRepClassificationTools::IsPointInOnEdge(edge1, point1, 0.001) == true);\n}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] auto SquaredDistance(const Point3& p)\t @return The squared distance between the point and the line\n\t @param p The point\n\t @brief Compute the squared distance from a point to the line\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <math/LineT.hpp>\n#include <modeling/MakeEdge2d.hpp>\nusing AMCAX::Line2;\n#define ONE_RADIAN (M_PI / 180.)\nTEST_CASE(\"case1: Line basic interface test\", \"[math][Line2][p1]\")\n{\n\tSECTION(\"Distance and SquaredDistance test\")\n\t{\n\t\tauto pointToLine = [](const Point2& point, const Line2& line) {\n\t\t\tdouble a, b, c;\n\t\t\tline.Coefficients(a, b, c);\n\t\t\treturn std::fabs(a * point.X() + b * point.Y() + c);\n\t\t};\n\t\tauto lineToLine = [](const Line2& line1, const Line2& line2) {\n\t\t\tdouble a1, b1, c1, a2, b2, c2;\n\t\t\tline1.Coefficients(a1, b1, c1);\n\t\t\tline2.Coefficients(a2, b2, c2);\n\t\t\tif (a1 != a2 || b1 != b2) return 0.;\n\t\t\treturn std::fabs(c1 - c2);\n\t\t};\n\t\tLine2 line(3., 4., -30.);\n\t\tPoint2 point1(6., 3.);\n\t\tPoint2 point2(6., 2.);\n\t\tLine2 line2(3., 4., -29.);\n\t\tLine2 line3(2., 1., -99.);\n\t\tCHECK(line.Distance(point1) == Approx(pointToLine(point1, line)).margin(0.01));\n\t\tCHECK(line.SquaredDistance(point1) == Approx(pointToLine(point1, line) * pointToLine(point1, line)).margin(0.01));\n\t\tCHECK(line.Distance(point2) == Approx(pointToLine(point2, line)));\n\t\tCHECK(line.SquaredDistance(point2) == Approx(pointToLine(point2, line) * pointToLine(point2, line)).margin(0.01));\n\t\tCHECK(line.Distance(line2) == Approx(lineToLine(line, line2)));\n\t\tCHECK(line.SquaredDistance(line2) == Approx(lineToLine(line2, line) * lineToLine(line2, line)).margin(0.01));\n\t\tCHECK(line.Distance(line3) == Approx(lineToLine(line, line3)));\n\t\tCHECK(line.SquaredDistance(line3) == Approx(lineToLine(line3, line) * lineToLine(line3, line)).margin(0.01));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] auto Distance(const Point3& p)\t @return The distance between the point and the line\n\t @param p The point\n\t @brief Compute the distance from a point to the line\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <math/LineT.hpp>\n#include <modeling/MakeEdge2d.hpp>\nusing AMCAX::Line2;\n#define ONE_RADIAN (M_PI / 180.)\nTEST_CASE(\"case2: Line base method Test\", \"[math][Line2][p1]\")\n{\n\tSECTION(\"Scale\")\n\t{\n\t\tLine2 line(Point2(0., -1.), Direction2());\n\t\tPoint2 point;\n\t\tdouble distance = line.Distance(point);\n\t\tLine2 lineScale1 = line.Scaled(point, 1.1);\n\t\tCHECK(lineScale1.Distance(point) > distance);\n\t\tCHECK(lineScale1.Contains(Point2(0., -1.1), 1e-5));\n\t\tLine2 lineScale2 = line.Scaled(point, 1.);\n\t\tCHECK(lineScale2.Distance(point) == Approx(distance).margin(1e-5));\n\t\tCHECK(lineScale2.Contains(Point2(0., -1.), 1e-5));\n\t\tLine2 lineScale3 = line.Scaled(point, 0.8);\n\t\tCHECK(lineScale3.Distance(point) < distance);\n\t\tCHECK(lineScale3.Contains(Point2(0., -0.8), 1e-5));\n\t\tLine2 lineScale4 = line.Scaled(point, 0.);\n\t\tline.SetDirection(Direction2(-1.0, 4.0));\n\t\tLine2 lineScale5 = line.Scaled(Point2(-1., 2.), 0.);\n\t\tCHECK(lineScale4.Contains(Point2(0., 0.), 1e-5));\n\t\tCHECK(lineScale4.Direction().IsEqual(Direction2(), 1e-6 * ONE_RADIAN));\n\t\tCHECK(lineScale5.Contains(Point2(-1., 2.), 1e-5));\n\t\tCHECK(lineScale5.Direction().IsEqual(Direction2(-1., 4.), 1e-6 * ONE_RADIAN));\n\t\tLine2 lineScale6 = line.Scaled(point, -1.);\n\t\tCHECK(lineScale6.Direction().IsEqual(Direction2(1., -4.), 1e-5 * ONE_RADIAN));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] LineS Rotated(const Point2& point, double angle)\t @return The rotated line\n\t @param angle The rotation angle\n\t @param point The rotation center point\n\t @brief Get the line rotated around a point with an angle in 2D\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <math/LineT.hpp>\n#include <modeling/MakeEdge2d.hpp>\nusing AMCAX::Line2;\n#define ONE_RADIAN (M_PI / 180.)\nTEST_CASE(\"case1: Line basic interface test\", \"[math][Line2][p1]\")\n{\n\tSECTION(\"Rotated Test\")\n\t{\n\t\tLine2 line(Point2(0., 1.), Direction2(1., 1.));  \n\t\tLine2 rotateLine = line.Rotated(Point2(), (3. / 4) * M_PI);  \n\t\tCHECK(rotateLine.Direction().X() == Approx(-1.).margin(1e-5));\n\t\tCHECK(rotateLine.Direction().Y() == Approx(0.).margin(1e-5));\n\t\tdouble a, b, c;\n\t\trotateLine.Coefficients(a, b, c);\n\t\tCHECK((c - b) == Approx(0.).margin(0.5));\n\t\tCHECK(line.Distance(Point2()) == rotateLine.Distance(Point2()));  \n\t\tTopoShape lineShape1 = MakeEdge2d(line);\n\t\tTopoShape lineShape2 = MakeEdge2d(rotateLine);\n\t\tREQUIRE(OCCTIO::OCCTTool::Write(lineShape1, OUTPUT_PATH_PREFIX\"Line2_Rotated_before_p1.brep\"));\n\t\tREQUIRE(OCCTIO::OCCTTool::Write(lineShape2, OUTPUT_PATH_PREFIX\"Line2_Rotated_later_p1.brep\"));\n\t}\n}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "LineS& Rotate(const Point2& point, double angle)\t @return The reference to self\n\t @param angle The rotation angle\n\t @param point The rotation center point\n\t @brief Rotate the line around a point with an angle in 2D\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <math/LineT.hpp>\n#include <modeling/MakeEdge2d.hpp>\nusing AMCAX::Line2;\n#define ONE_RADIAN (M_PI / 180.)\nTEST_CASE(\"case1: Line basic interface test\", \"[math][Line2][p1]\")\n{\n\tSECTION(\"Rotate Test\")\n\t{\n\t\tLine2 line(Point2(0., 1.), Direction2(1., 1.));  \n\t\tLine2 line2(Point2(0., 1.), Direction2(1., 1.));  \n\t\tline.Rotate(Point2(), (5. / 4) * M_PI);  \n\t\tCHECK(line.Direction().X() == Approx(0.).margin(1e-5));\n\t\tCHECK(line.Direction().Y() == Approx(-1.).margin(1e-5));\n\t\tdouble a, b, c;\n\t\tline.Coefficients(a, b, c);\n\t\tCHECK((a + c) == Approx(0.).margin(0.5));\n\t\tCHECK(line2.Distance(Point2()) == line.Distance(Point2()));  \n\t\tCHECK(line.Contains(Point2(std::sqrt(2.) / 2., 0.), 1e-6) == true);\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] LineS Normal(const Point2& p)\t @return The line passing through a point and perpendicular to the line\n\t @param p The point\n\t @brief Get a line passing through a point and perpendicular to the line\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <math/LineT.hpp>\n#include <modeling/MakeEdge2d.hpp>\nusing AMCAX::Line2;\n#define ONE_RADIAN (M_PI / 180.)\nTEST_CASE(\"case1: Line basic interface test\", \"[math][Line2][p1]\")\n{\n\tSECTION(\"Normal Test\")\n\t{\n\t\tLine2 line(3., 4., 5.);  \n\t\tLine2 normalLine = line.Normal(Point2(1., 5.));\n\t\tdouble a, b, c;\n\t\tnormalLine.Coefficients(a, b, c);\n\t\tCHECK((a * 3 + b * 4) == Approx(0.0).margin(0.1));\n\t\tCHECK((a * 1 + b * 5 + c) == Approx(0.0).margin(0.1));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] auto SquaredDistance(const LineS& l)\t @return The squared distance between two lines\n\t @param l The other line\n\t @brief Compute the squared distance between two lines\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <math/LineT.hpp>\n#include <modeling/MakeEdge2d.hpp>\nusing AMCAX::Line2;\n#define ONE_RADIAN (M_PI / 180.)\nTEST_CASE(\"case1: Line basic interface test\", \"[math][Line2][p1]\")\n{\n\tSECTION(\"Distance and SquaredDistance test\")\n\t{\n\t\tauto pointToLine = [](const Point2& point, const Line2& line) {\n\t\t\tdouble a, b, c;\n\t\t\tline.Coefficients(a, b, c);\n\t\t\treturn std::fabs(a * point.X() + b * point.Y() + c);\n\t\t};\n\t\tauto lineToLine = [](const Line2& line1, const Line2& line2) {\n\t\t\tdouble a1, b1, c1, a2, b2, c2;\n\t\t\tline1.Coefficients(a1, b1, c1);\n\t\t\tline2.Coefficients(a2, b2, c2);\n\t\t\tif (a1 != a2 || b1 != b2) return 0.;\n\t\t\treturn std::fabs(c1 - c2);\n\t\t};\n\t\tLine2 line(3., 4., -30.);\n\t\tPoint2 point1(6., 3.);\n\t\tPoint2 point2(6., 2.);\n\t\tLine2 line2(3., 4., -29.);\n\t\tLine2 line3(2., 1., -99.);\n\t\tCHECK(line.Distance(point1) == Approx(pointToLine(point1, line)).margin(0.01));\n\t\tCHECK(line.SquaredDistance(point1) == Approx(pointToLine(point1, line) * pointToLine(point1, line)).margin(0.01));\n\t\tCHECK(line.Distance(point2) == Approx(pointToLine(point2, line)));\n\t\tCHECK(line.SquaredDistance(point2) == Approx(pointToLine(point2, line) * pointToLine(point2, line)).margin(0.01));\n\t\tCHECK(line.Distance(line2) == Approx(lineToLine(line, line2)));\n\t\tCHECK(line.SquaredDistance(line2) == Approx(lineToLine(line2, line) * lineToLine(line2, line)).margin(0.01));\n\t\tCHECK(line.Distance(line3) == Approx(lineToLine(line, line3)));\n\t\tCHECK(line.SquaredDistance(line3) == Approx(lineToLine(line3, line) * lineToLine(line3, line)).margin(0.01));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] auto SquaredDistance(const Point2& p)\t @return The squared distance between the point and the line\n\t @param p The point\n\t @brief Compute the squared distance from a point to the line\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <math/LineT.hpp>\n#include <modeling/MakeEdge2d.hpp>\nusing AMCAX::Line2;\n#define ONE_RADIAN (M_PI / 180.)\nTEST_CASE(\"case1: Line basic interface test\", \"[math][Line2][p1]\")\n{\n\tSECTION(\"Distance and SquaredDistance test\")\n\t{\n\t\tauto pointToLine = [](const Point2& point, const Line2& line) {\n\t\t\tdouble a, b, c;\n\t\t\tline.Coefficients(a, b, c);\n\t\t\treturn std::fabs(a * point.X() + b * point.Y() + c);\n\t\t};\n\t\tauto lineToLine = [](const Line2& line1, const Line2& line2) {\n\t\t\tdouble a1, b1, c1, a2, b2, c2;\n\t\t\tline1.Coefficients(a1, b1, c1);\n\t\t\tline2.Coefficients(a2, b2, c2);\n\t\t\tif (a1 != a2 || b1 != b2) return 0.;\n\t\t\treturn std::fabs(c1 - c2);\n\t\t};\n\t\tLine2 line(3., 4., -30.);\n\t\tPoint2 point1(6., 3.);\n\t\tPoint2 point2(6., 2.);\n\t\tLine2 line2(3., 4., -29.);\n\t\tLine2 line3(2., 1., -99.);\n\t\tCHECK(line.Distance(point1) == Approx(pointToLine(point1, line)).margin(0.01));\n\t\tCHECK(line.SquaredDistance(point1) == Approx(pointToLine(point1, line) * pointToLine(point1, line)).margin(0.01));\n\t\tCHECK(line.Distance(point2) == Approx(pointToLine(point2, line)));\n\t\tCHECK(line.SquaredDistance(point2) == Approx(pointToLine(point2, line) * pointToLine(point2, line)).margin(0.01));\n\t\tCHECK(line.Distance(line2) == Approx(lineToLine(line, line2)));\n\t\tCHECK(line.SquaredDistance(line2) == Approx(lineToLine(line2, line) * lineToLine(line2, line)).margin(0.01));\n\t\tCHECK(line.Distance(line3) == Approx(lineToLine(line, line3)));\n\t\tCHECK(line.SquaredDistance(line3) == Approx(lineToLine(line3, line) * lineToLine(line3, line)).margin(0.01));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] auto Distance(const Point2& p)\t @return The distance between the point and the line\n\t @param p The point\n\t @brief Compute the distance from a point to the line\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <math/LineT.hpp>\n#include <modeling/MakeEdge2d.hpp>\nusing AMCAX::Line2;\n#define ONE_RADIAN (M_PI / 180.)\nTEST_CASE(\"case2: Line base method Test\", \"[math][Line2][p1]\")\n{\n\tSECTION(\"SetDirection\")\n\t{\n\t\tLine2 line(Point2(), Direction2(1., 1.));  \n\t\tCHECK(line.Direction().IsEqual(Direction2(1., 1.), 1e-5 * ONE_RADIAN));\n\t\tCHECK(line.Distance(Point2(1., 2.)) > 0.);\n\t\tline.SetDirection(Direction2(1., 2.));  \n\t\tCHECK(line.Direction().IsEqual(Direction2(1., 2.), 1e-5 * ONE_RADIAN));\n\t\tCHECK(line.Distance(Point2(1., 2.)) == Approx(0.).margin(1e-5));\n\t\tdouble a, b, c;\n\t\tline.Coefficients(a, b, c);\n\t\tCHECK(a == Approx(2. / std::sqrt(5)).margin(1e-5));\n\t\tCHECK(b == Approx(-1. / std::sqrt(5)).margin(1e-5));\n\t\tCHECK(c == Approx(0. / std::sqrt(5)).margin(1e-5));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "void Coefficients(double& a, double& b, double& c)\t @param[out] a,b,c The coefficients\n\t @brief The coefficients of the algebraic representation of the 2D line\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <math/LineT.hpp>\n#include <modeling/MakeEdge2d.hpp>\nusing AMCAX::Line2;\n#define ONE_RADIAN (M_PI / 180.)\nTEST_CASE(\"case1: Line basic interface test\", \"[math][Line2][p1]\")\n{\n\tSECTION(\"Parameterized constructor test\")\n\t{\n\t\tLine2 line1(Axis2(Point2(1., 0.), Direction2(2., 1.)));\n\t\tLine2 line2(Point2(1., 0.), Direction2(2., 1.));  \n\t\tLine2 line3(1, -2, -1);\n\t\tdouble a, b, c;\n\t\tline1.Coefficients(a, b, c);\n\t\tCHECK(a == Approx(1.0 / std::sqrt(5)));\n\t\tCHECK(b == Approx(-2.0 / std::sqrt(5)));\n\t\tCHECK(c == Approx(-1.0 / std::sqrt(5)));\n\t\tline2.Coefficients(a, b, c);\n\t\tCHECK(a == Approx(1.0 / std::sqrt(5)));\n\t\tCHECK(b == Approx(-2.0 / std::sqrt(5)));\n\t\tCHECK(c == Approx(-1.0 / std::sqrt(5)));\n\t\tline3.Coefficients(a, b, c);\n\t\tCHECK(a == Approx(1.0 / std::sqrt(5)));\n\t\tCHECK(b == Approx(-2.0 / std::sqrt(5)));\n\t\tCHECK(c == Approx(-1.0 / std::sqrt(5)));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "LineS(double a, double b, double c)\t @param a,b,c The coefficients\n\t @brief Construct from the algebraic coefficients of 2D line\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <math/LineT.hpp>\n#include <modeling/MakeEdge2d.hpp>\nusing AMCAX::Line2;\n#define ONE_RADIAN (M_PI / 180.)\nTEST_CASE(\"case1: Line basic interface test\", \"[math][Line2][p1]\")\n{\n\tSECTION(\"Parameterized constructor test\")\n\t{\n\t\tLine2 line1(Axis2(Point2(1., 0.), Direction2(2., 1.)));\n\t\tLine2 line2(Point2(1., 0.), Direction2(2., 1.));  \n\t\tLine2 line3(1, -2, -1);\n\t\tdouble a, b, c;\n\t\tline1.Coefficients(a, b, c);\n\t\tCHECK(a == Approx(1.0 / std::sqrt(5)));\n\t\tCHECK(b == Approx(-2.0 / std::sqrt(5)));\n\t\tCHECK(c == Approx(-1.0 / std::sqrt(5)));\n\t\tline2.Coefficients(a, b, c);\n\t\tCHECK(a == Approx(1.0 / std::sqrt(5)));\n\t\tCHECK(b == Approx(-2.0 / std::sqrt(5)));\n\t\tCHECK(c == Approx(-1.0 / std::sqrt(5)));\n\t\tline3.Coefficients(a, b, c);\n\t\tCHECK(a == Approx(1.0 / std::sqrt(5)));\n\t\tCHECK(b == Approx(-2.0 / std::sqrt(5)));\n\t\tCHECK(c == Approx(-1.0 / std::sqrt(5)));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "Derived& Reverse()\t @return The reference to self\n\t @brief Reverse the line direction\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <math/LineT.hpp>\n#include <modeling/MakeEdge2d.hpp>\nusing AMCAX::Line2;\n#define ONE_RADIAN (M_PI / 180.)\nTEST_CASE(\"case2: Line base method Test\", \"[math][Line2][p1]\")\n{\n\tSECTION(\"Reverse\")\n\t{\n\t\tLine2 line;\n\t\tline.Reverse();\n\t\tCHECK(line.Direction().IsEqual(Direction2(-1., 0.), 1e-5 * ONE_RADIAN));\n\t\tLine2 line2(Point2(), Direction2(-3., 98.));\n\t\tline2.Reverse();\n\t\tCHECK(line2.Direction().IsEqual(Direction2(3., -98.), 1e-5 * ONE_RADIAN));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] auto Angle(const LineBase& other)\t @return The angle between the line and the other line\n\t @param other The other line\n\t @brief Compute the angle between the line and the other line\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <math/LineT.hpp>\n#include <modeling/MakeEdge2d.hpp>\nusing AMCAX::Line2;\n#define ONE_RADIAN (M_PI / 180.)\nTEST_CASE(\"case2: Line base method Test\", \"[math][Line2][p1]\")\n{\n\tSECTION(\"Angle\")\n\t{\n\t\tLine2 line;\n\t\tLine2 line2(Point2(), Direction2(0., 1.));\n\t\tCHECK(line.Angle(line2) == Approx(M_PI_2));\n\t\tCHECK(line2.Angle(line) == Approx(-M_PI_2));\n\t\tLine2 line3(Point2(), Direction2(2., 3.));\n\t\tLine2 line4(Point2(), Direction2(5., -8.));\n\t\tCHECK(line4.Angle(line3) == Approx(\n\t\t\tstd::acos((2. * 5. + 3. * (-8.)) / (std::sqrt(4. + 9.) * std::sqrt(25. + 64.)))\n\t\t).margin(1e-5 * ONE_RADIAN));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] const DirectionT<double, DIM>& Direction()\t @return The direction of the line\n\t @brief Get the direction of the line\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <math/LineT.hpp>\n#include <modeling/MakeEdge2d.hpp>\nusing AMCAX::Line2;\n#define ONE_RADIAN (M_PI / 180.)\nTEST_CASE(\"case2: Line base method Test\", \"[math][Line2][p1]\")\n{\n\tSECTION(\"Translate Test\")\n\t{\n\t\tLine2 line;\n\t\tline.Translate(Vector2(2., 0.));  \n\t\tCHECK(line.Direction().IsEqual(Direction2(), 1e-5 * ONE_RADIAN));\n\t\tCHECK(line.Contains(Point2(2., 0.), 1e-5));\n\t\tLine2 translateLine = line.Translated(Point2(2., 0.), Point2(-10., 0.));\n\t\tCHECK(translateLine.Contains(Point2(-10., 0.), 1e-5));\n\t}\n}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "void SetPosition(const AxisT<double, DIM>& axis)\t @param axis The axis\n\t @brief Set the axis of the line\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <math/LineT.hpp>\n#include <modeling/MakeEdge2d.hpp>\nusing AMCAX::Line2;\n#define ONE_RADIAN (M_PI / 180.)\nTEST_CASE(\"case2: Line base method Test\", \"[math][Line2][p1]\")\n{\n\tSECTION(\"SetPosition\")\n\t{\n\t\tLine2 line;\n\t\tCHECK(line.Location().IsEqual(Point2(0., 0.), 1e-5));\n\t\tCHECK(line.Direction().IsEqual(Direction2(1., 0.), 1e-5 * ONE_RADIAN));\n\t\tAxis2 axis(Point2(2., 1.), Direction2(1., 1.));\n\t\tline.SetPosition(axis);  \n\t\tdouble a, b, c;\n\t\tline.Coefficients(a, b, c);\n\t\tCHECK(a == Approx(1. / std::sqrt(2)).margin(1e-5));\n\t\tCHECK(b == Approx(-1. / std::sqrt(2)).margin(1e-5));\n\t\tCHECK(c == Approx(-1. / std::sqrt(2)).margin(1e-5));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "void SetDirection(const DirectionT<double, DIM>& dir)\t @param dir The line direction\n\t @brief Set the line direction\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <math/LineT.hpp>\n#include <modeling/MakeEdge2d.hpp>\nusing AMCAX::Line2;\n#define ONE_RADIAN (M_PI / 180.)\nTEST_CASE(\"case2: Line base method Test\", \"[math][Line2][p1]\")\n{\n\tSECTION(\"SetDirection\")\n\t{\n\t\tLine2 line(Point2(), Direction2(1., 1.));  \n\t\tCHECK(line.Direction().IsEqual(Direction2(1., 1.), 1e-5 * ONE_RADIAN));\n\t\tCHECK(line.Distance(Point2(1., 2.)) > 0.);\n\t\tline.SetDirection(Direction2(1., 2.));  \n\t\tCHECK(line.Direction().IsEqual(Direction2(1., 2.), 1e-5 * ONE_RADIAN));\n\t\tCHECK(line.Distance(Point2(1., 2.)) == Approx(0.).margin(1e-5));\n\t\tdouble a, b, c;\n\t\tline.Coefficients(a, b, c);\n\t\tCHECK(a == Approx(2. / std::sqrt(5)).margin(1e-5));\n\t\tCHECK(b == Approx(-1. / std::sqrt(5)).margin(1e-5));\n\t\tCHECK(c == Approx(0. / std::sqrt(5)).margin(1e-5));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "void SetLocation(const PointT<double, DIM>& point)\t @param point The location point\n\t @brief Set the location of the line\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <math/LineT.hpp>\n#include <modeling/MakeEdge2d.hpp>\nusing AMCAX::Line2;\n#define ONE_RADIAN (M_PI / 180.)\nTEST_CASE(\"case2: Line base method Test\", \"[math][Line2][p1]\")\n{\n\tSECTION(\"SetLocation\")\n\t{\n\t\tLine2 line(Point2(0., 0.), Direction2(1., 1.));  \n\t\tCHECK(line.Location().IsEqual(Point2(), 1e-5));\n\t\tline.SetLocation(Point2(2., 1.));  \n\t\tCHECK(line.Location().IsEqual(Point2(2., 1.), 1e-5));\n\t\tdouble a, b, c;\n\t\tline.Coefficients(a, b, c);\n\t\tCHECK(a == Approx(1. / std::sqrt(2)).margin(1e-5));\n\t\tCHECK(b == Approx(-1. / std::sqrt(2)).margin(1e-5));\n\t\tCHECK(c == Approx(-1. / std::sqrt(2)).margin(1e-5));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] Derived Translated(const PointT<double, DIM>& p1, const PointT<double, DIM>& p2)\t @return The translated line\n\t @param p2 The target point\n\t @param p1 The source point\n\t @brief Get the line translated by a vector from a point to another point\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <math/LineT.hpp>\n#include <modeling/MakeEdge2d.hpp>\nusing AMCAX::Line2;\n#define ONE_RADIAN (M_PI / 180.)\nTEST_CASE(\"case2: Line base method Test\", \"[math][Line2][p1]\")\n{\n\tSECTION(\"Translate Test\")\n\t{\n\t\tLine2 line;\n\t\tline.Translate(Vector2(2., 0.));  \n\t\tCHECK(line.Direction().IsEqual(Direction2(), 1e-5 * ONE_RADIAN));\n\t\tCHECK(line.Contains(Point2(2., 0.), 1e-5));\n\t\tLine2 translateLine = line.Translated(Point2(2., 0.), Point2(-10., 0.));\n\t\tCHECK(translateLine.Contains(Point2(-10., 0.), 1e-5));\n\t}\n}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "Derived& Translate(const VectorT<double, DIM>& vec)\t @return The reference to self\n\t @param vec The translation vector\n\t @brief Translate the line by a vector\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <math/LineT.hpp>\n#include <modeling/MakeEdge2d.hpp>\nusing AMCAX::Line2;\n#define ONE_RADIAN (M_PI / 180.)\nTEST_CASE(\"case2: Line base method Test\", \"[math][Line2][p1]\")\n{\n\tSECTION(\"Translate Test\")\n\t{\n\t\tLine2 line;\n\t\tline.Translate(Vector2(2., 0.));  \n\t\tCHECK(line.Direction().IsEqual(Direction2(), 1e-5 * ONE_RADIAN));\n\t\tCHECK(line.Contains(Point2(2., 0.), 1e-5));\n\t\tLine2 translateLine = line.Translated(Point2(2., 0.), Point2(-10., 0.));\n\t\tCHECK(translateLine.Contains(Point2(-10., 0.), 1e-5));\n\t}\n}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] Derived Scaled(const PointT<double, DIM>& point, double scale)\t @return The scaled line\n\t @param scale The scale value\n\t @param point The scaling center point\n\t @brief Get the line scaled by a point\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <math/LineT.hpp>\n#include <modeling/MakeEdge2d.hpp>\nusing AMCAX::Line2;\n#define ONE_RADIAN (M_PI / 180.)\nTEST_CASE(\"case2: Line base method Test\", \"[math][Line2][p1]\")\n{\n\tSECTION(\"Scale\")\n\t{\n\t\tLine2 line(Point2(0., -1.), Direction2());\n\t\tPoint2 point;\n\t\tdouble distance = line.Distance(point);\n\t\tLine2 lineScale1 = line.Scaled(point, 1.1);\n\t\tCHECK(lineScale1.Distance(point) > distance);\n\t\tCHECK(lineScale1.Contains(Point2(0., -1.1), 1e-5));\n\t\tLine2 lineScale2 = line.Scaled(point, 1.);\n\t\tCHECK(lineScale2.Distance(point) == Approx(distance).margin(1e-5));\n\t\tCHECK(lineScale2.Contains(Point2(0., -1.), 1e-5));\n\t\tLine2 lineScale3 = line.Scaled(point, 0.8);\n\t\tCHECK(lineScale3.Distance(point) < distance);\n\t\tCHECK(lineScale3.Contains(Point2(0., -0.8), 1e-5));\n\t\tLine2 lineScale4 = line.Scaled(point, 0.);\n\t\tline.SetDirection(Direction2(-1.0, 4.0));\n\t\tLine2 lineScale5 = line.Scaled(Point2(-1., 2.), 0.);\n\t\tCHECK(lineScale4.Contains(Point2(0., 0.), 1e-5));\n\t\tCHECK(lineScale4.Direction().IsEqual(Direction2(), 1e-6 * ONE_RADIAN));\n\t\tCHECK(lineScale5.Contains(Point2(-1., 2.), 1e-5));\n\t\tCHECK(lineScale5.Direction().IsEqual(Direction2(-1., 4.), 1e-6 * ONE_RADIAN));\n\t\tLine2 lineScale6 = line.Scaled(point, -1.);\n\t\tCHECK(lineScale6.Direction().IsEqual(Direction2(1., -4.), 1e-5 * ONE_RADIAN));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] const PointT<double, DIM>& Location()\t @return The location of the line\n\t @brief Get the location point of the line\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <math/LineT.hpp>\n#include <modeling/MakeEdge2d.hpp>\nusing AMCAX::Line2;\n#define ONE_RADIAN (M_PI / 180.)\nTEST_CASE(\"case1: Line basic interface test\", \"[math][Line2][p1]\")\n{\n\tSECTION(\"Parameterless constructor test\")\n\t{\n\t\tLine2 line;  \n\t\tCHECK(line.Location().IsEqual(Axis2().Location(), 0.001));\n\t\tCHECK(line.Direction().IsEqual(Axis2().Direction(), 1e-5 * ONE_RADIAN));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] bool Contains(const PointT<double, DIM>& p, double tol)\t @return True if the point is on the line under the tolerance\n\t @param tol The tolerance\n\t @param p The point\n\t @brief Does the line contain a point under a distance tolerance\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <math/LineT.hpp>\n#include <modeling/MakeEdge2d.hpp>\nusing AMCAX::Line2;\n#define ONE_RADIAN (M_PI / 180.)\nTEST_CASE(\"case2: Line base method Test\", \"[math][Line2][p1]\")\n{\n\tSECTION(\"Contains\")\n\t{\n\t\tLine2 line(Axis2(Point2(2., 1.), Direction2(1., 1.)));  \n\t\tPoint2 point1(2., 1.);  \n\t\tPoint2 point2(1., 1.);  \n\t\tCHECK(line.Contains(point1, 1e-5));\n\t\tCHECK_FALSE(line.Contains(point2, 1e-5));\n\t\tCHECK(line.Contains(point2, 1.));  \n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] double SemilatusRectum()\t @return The semilatus rectum\n\t          Semilatus rectum = 2 * focalLength\n\t @details The semilatus rectum of parabola is half of the length of the chord through a focus parallel to the directrix.\n\t @brief Get the semilatus rectum of the parabola\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <math/ParabolaT.hpp>\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Test Parabola3\", \"[math][Parabola3][P1]\")\n{\n\tFrame3 frame;\n\tdouble focal = 5.0;\n\tParabola3 parabola(frame, focal);\n\tSECTION(\"SemilatusRectum\")\n\t{\n\t\tdouble SR = parabola.SemilatusRectum();\n\t\tdouble sr = 2 * focal;\n\t\tCHECK(SR == sr);\n\t}\n}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] double FocalParameter()\t @return The focal parameter\n\t          Focal parameter = 2 * focalLength.\n\t @details The focal parameter of parabola is the distance from the focus to the directrix.\n\t @brief Get the focal parameter of the parabola\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <math/ParabolaT.hpp>\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Test Parabola3\", \"[math][Parabola3][P1]\")\n{\n\tFrame3 frame;\n\tdouble focal = 5.0;\n\tParabola3 parabola(frame, focal);\n\tSECTION(\"FocalParameter\")\n\t{\n\t\tdouble FP = parabola.FocalParameter();\n\t\tdouble fp = 2 * focal;\n\t\tCHECK(FP == fp);\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] double SemilatusRectum()\t @return The semilatus rectum\n\t          Semilatus rectum = 2 * focalLength\n\t @details The semilatus rectum of parabola is half of the length of the chord through a focus parallel to the directrix.\n\t @brief Get the semilatus rectum of the parabola\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <math/ParabolaT.hpp>\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Test Parabola2\", \"[math][Parabola2][P1]\")\n{\n\tAxis2 axis;\n\tdouble focal = 5.0;\n\tbool isRight = true;\n\tParabola2 parabola(axis, focal, isRight);\n\tSECTION(\"SemilatusRectum\")\n\t{\n\t\tdouble SR = parabola.SemilatusRectum();\n\t\tdouble sr = 2 * focal;\n\t\tCHECK(SR == sr);\n\t}\n}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] double FocalParameter()\t @return The focal parameter\n\t          Focal parameter = 2 * focalLength.\n\t @details The focal parameter of parabola is the distance from the focus to the directrix.\n\t @brief Get the focal parameter of the parabola\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <math/ParabolaT.hpp>\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Test Parabola2\", \"[math][Parabola2][P1]\")\n{\n\tAxis2 axis;\n\tdouble focal = 5.0;\n\tbool isRight = true;\n\tParabola2 parabola(axis, focal, isRight);\n\tSECTION(\"FocalParameter\")\n\t{\n\t\tdouble FP = parabola.FocalParameter();\n\t\tdouble fp = 2 * focal;\n\t\tCHECK(FP == fp);\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] double SemilatusRectum()\t @return The semilatus rectum\n\t          Semilatus rectum = 2 * focalLength\n\t @details The semilatus rectum of parabola is half of the length of the chord through a focus parallel to the directrix.\n\t @brief Get the semilatus rectum of the parabola\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <geometry/Geom3Parabola.hpp>\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Test Geom3Parabola\", \"[math][Geom3Parabola][P1]\")\n{\n\tFrame3 frame;\n\tdouble focal = 5.0;\n\tGeom3Parabola g3p(frame, focal);\n\tSECTION(\"SemilatusRectum\")\n\t{\n\t\tdouble SR = g3p.SemilatusRectum();\n\t\tdouble sr = 2 * focal;\n\t\tCHECK(SR == sr);\n\t}\n}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] double FocalParameter()\t @return The focal parameter\n\t          Focal parameter = 2 * focalLength.\n\t @details The focal parameter of parabola is the distance from the focus to the directrix.\n\t @brief Get the focal parameter of the parabola\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <geometry/Geom3Parabola.hpp>\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Test Geom3Parabola\", \"[math][Geom3Parabola][P1]\")\n{\n\tFrame3 frame;\n\tdouble focal = 5.0;\n\tGeom3Parabola g3p(frame, focal);\n\tSECTION(\"FocalParameter\")\n\t{\n\t\tdouble FP = g3p.FocalParameter();\n\t\tdouble fp = 2 * focal;\n\t\tCHECK(FP == fp);\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] double SemilatusRectum()\t @return The semilatus rectum\n\t          Semilatus rectum = 2 * focalLength\n\t @details The semilatus rectum of parabola is half of the length of the chord through a focus parallel to the directrix.\n\t @brief Get the semilatus rectum of the parabola\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <geometry/Geom2Parabola.hpp>\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Test Geom2Parabola\", \"[math][Geom2Parabola][P1]\")\n{\n\tAxis2 axis;\n\tdouble focal = 5.0;\n\tbool isRight = true;\n\tGeom2Parabola g2p(axis, focal, isRight);\n\tSECTION(\"SemilatusRectum\")\n\t{\n\t\tdouble SR = g2p.SemilatusRectum();\n\t\tdouble sr = 2 * focal;\n\t\tCHECK(SR == sr);\n\t}\n}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] double FocalParameter()\t @return The focal parameter\n\t          Focal parameter = 2 * focalLength.\n\t @details The focal parameter of parabola is the distance from the focus to the directrix.\n\t @brief Get the focal parameter of the parabola\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <geometry/Geom2Parabola.hpp>\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Test Geom2Parabola\", \"[math][Geom2Parabola][P1]\")\n{\n\tAxis2 axis;\n\tdouble focal = 5.0;\n\tbool isRight = true;\n\tGeom2Parabola g2p(axis, focal, isRight);\n\tSECTION(\"FocalParameter\")\n\t{\n\t\tdouble FP = g2p.FocalParameter();\n\t\tdouble fp = 2 * focal;\n\t\tCHECK(FP == fp);\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] double Area()\t @return The area of the ellipse\n\t @brief Get the area of the ellipse\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <common/FrameT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <math/EllipseT.hpp>\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Test Ellipse3\", \"[math][Ellipse3][P1]\")\n{\n\tFrame3 frame;\n\tdouble major = 5.0;\n\tdouble minor = 4.0;\n\tEllipse3 ellipse(frame, major, minor);\n\tSECTION(\"Area\")\n\t{\n\t\tdouble S = ellipse.Area();\n\t\tCHECK(S == Approx(M_PI * major * minor));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "EllipseS& Transform(const TransformationT<double, DIM>& tr)\t @return The reference to self\n\t @param tr The transformation\n\t @brief Transform the ellipse\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <common/FrameT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <math/EllipseT.hpp>\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case3:this is a case for Test-Ellipse2-Rotate\", \"[math][Ellipse2][P1]\")\n{\n\tPoint2 point1(6.0, 0.0);\n\tDirection2 dir1(0.0, 1.0);\n\tAxis2 axis1(point1, dir1);\n\tdouble major = 5.0;\n\tdouble minor = 4.0;\n\tbool isRight = true;\n\tEllipse2 ellipse(axis1, major, minor, isRight);\n\tdouble angle = M_PI_2;\n\tPoint2 point_temp(0.0, 0.0);\n\tSECTION(\"Transform\")\n\t{\n\t\tEllipse2 Transfor_ellipse = ellipse.Transform(tr);\n\t\tCHECK(ellipse.Location().X() == Approx(5.0));\n\t\tCHECK(ellipse.Location().Y() == Approx(-2.0));\n\t\tCHECK(ellipse.MajorRadius() == Approx(5.0));\n\t\tCHECK(ellipse.MinorRadius() == Approx(4.0));\n\t\tCHECK(Transfor_ellipse.Location().X() == Approx(5.0));\n\t\tCHECK(Transfor_ellipse.Location().Y() == Approx(-2.0));\n\t\tCHECK(Transfor_ellipse.MajorRadius() == Approx(5.0));\n\t\tCHECK(Transfor_ellipse.MinorRadius() == Approx(4.0));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "EllipseS& Scale(const PointT<double, DIM>& point, double scale)\t @return The reference to self\n\t @param scale The scale value\n\t @param point The scaling center point\n\t @brief Scale the ellipse by a center point\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <common/FrameT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <math/EllipseT.hpp>\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case3:this is a case for Test-Ellipse2-Rotate\", \"[math][Ellipse2][P1]\")\n{\n\tPoint2 point1(6.0, 0.0);\n\tDirection2 dir1(0.0, 1.0);\n\tAxis2 axis1(point1, dir1);\n\tdouble major = 5.0;\n\tdouble minor = 4.0;\n\tbool isRight = true;\n\tEllipse2 ellipse(axis1, major, minor, isRight);\n\tdouble angle = M_PI_2;\n\tPoint2 point_temp(0.0, 0.0);\n\tSECTION(\"Scale\")\n\t{\n\t\tEllipse2 scale_ellipse = ellipse.Scale(point, scale);\n\t\tCHECK(ellipse.Location().X() == Approx(2.5));\n\t\tCHECK(ellipse.Location().Y() == Approx(-1.0));\n\t\tCHECK(ellipse.MajorRadius() == Approx(2.5));\n\t\tCHECK(ellipse.MinorRadius() == Approx(2.0));\n\t\tCHECK(scale_ellipse.Location().X() == Approx(2.5));\n\t\tCHECK(scale_ellipse.Location().Y() == Approx(-1.0));\n\t\tCHECK(scale_ellipse.MajorRadius() == Approx(2.5));\n\t\tCHECK(scale_ellipse.MinorRadius() == Approx(2.0));\n\t}\n\tscale = -2.0;}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] double Area()\t @return The area of the ellipse\n\t @brief Get the area of the ellipse\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <common/FrameT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <math/EllipseT.hpp>\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Test Ellipse2\", \"[math][Ellipse2][P1]\")\n{\n\tAxis2 axis;\n\tdouble major = 5.0;\n\tdouble minor = 4.0;\n\tbool isRight = true;\n\tEllipse2 ellipse(axis, major, minor, isRight);\n\tSECTION(\"Area\")\n\t{\n\t\tdouble S = ellipse.Area();\n\t\tCHECK(S == Approx(M_PI * major * minor));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "CircleS& Scale(const PointT<double, DIM>& p, double scale)\t @return The reference to self\n\t @param scale The scale value\n\t @param p The scaling center point\n\t @brief Scale the circle by a center point\n,\n",
      "output": "#include <math/CircleT.hpp>\n#include <common/CoordT.hpp>\n#include <common/TransformationType.hpp>\n#include <common/DirectionT.hpp>\n#include <common/PointT.hpp>\n#include <common/Precision.hpp>\n#include <common/CoordT.hpp>\n#include <common/TransformationType.hpp>\n#include <topology/TopoEdge.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <topology/TopoWire.hpp>\n#include <modeling/MakeWire.hpp>\n#include <geometry/GlobalProperty.hpp>\n#include <topology/BRepGlobalProperty.hpp>\n#include<iostream>\n#include \"catch.hpp\" \nusing namespace std;\nusing namespace AMCAX;\nTEST_CASE(\"TestCircle2D\", \"[math][Circle2D]\")\n{\n\tAMCAX::CircleT<double, 2> circle2D;\n\tAMCAX::Point2 center2D(0.0, 0.0);\n\tdouble redius2D = 5.0;\n\tdouble tol = 0.1;\n\tcircle2D.SetLocation(center2D);\n\tcircle2D.SetRadius(redius2D);\n\tdouble area2D = circle2D.Area();\n\tdouble length2D = circle2D.Length();\n\tAMCAX::Point2 retcenter2D = circle2D.Location();\n\tdouble retarea2D = M_PI * redius2D * redius2D;\n\tdouble retlength2D = 2 * M_PI * redius2D;\n\tstd::cout << area2D << std::endl;\n\tstd::cout << length2D << std::endl;\n\tstd::cout << retcenter2D.X() << std::endl;\n\tstd::cout << retcenter2D.Y() << std::endl;\n\tCHECK(area2D == retarea2D);\n\tCHECK(length2D == retlength2D);\n\tCHECK(retcenter2D.X() == center2D.X());\n\tCHECK(retcenter2D.Y() == center2D.Y());\n\tdouble a, b, c, d, e, f;\n\tcircle2D.Coefficients(a, b, c, d, e, f);\n\tstd::cout << a << std::endl;\n\tstd::cout << b << std::endl;\n\tstd::cout << c << std::endl;\n\tstd::cout << d << std::endl;\n\tstd::cout << e << std::endl;\n\tstd::cout << f << std::endl;\n\tCHECK(a == 1);\n\tCHECK(b == 1);\n\tCHECK(c == 0);\n\tCHECK(d == 0);\n\tCHECK(e == 0);\n\tCHECK(f == -25);\n\tstd::vector < AMCAX::Point2> testPoints = {\n\t\tAMCAX::Point2(3.0, 4.0),\n\t\tAMCAX::Point2(5.0, 0.0),\n\t\tAMCAX::Point2(4.9, 0.0),\n\t\tAMCAX::Point2(5.1, 0.0),\n\t\tAMCAX::Point2(6.0, 0.0)\n\t};\n\tfor (const auto& point : testPoints)\n\t{\n\t\tdouble distanceToCenter = std::sqrt(point.X() * point.X() + point.Y() * point.Y());\n\t\tbool expectedIsInCircle = distanceToCenter <= 5.0 + tol;\n\t\tbool isInCircle = circle2D.Contains(point, tol);\n\t\tCHECK(isInCircle == expectedIsInCircle);\n\t}\n\tfor (const auto& point : testPoints)\n\t{\n\t\tdouble distance = circle2D.Distance(point);\n\t\tdouble expectedDistance = std::abs(std::sqrt(std::pow(point.X() - center2D.X(), 2) + std::pow(point.Y() - center2D.Y(), 2)) - redius2D);\n\t\tCHECK(distance == expectedDistance);\n\t}\n\tAMCAX::AxisT<double, 2> mirrorAxis(AMCAX::Point2(0.0, 0.0), AMCAX::Direction2(0.0, 1.0));\n\tcircle2D.Mirror(mirrorAxis);\n\tAMCAX::Point2 mirroredCenter = circle2D.Location();\n\tstd::cout << \"Mirrored circle center: (\" << mirroredCenter.X() << \", \" << mirroredCenter.Y() << \")\" << std::endl;\n\tCHECK(mirroredCenter.X() == center2D.X());\n\tCHECK(mirroredCenter.Y() == center2D.Y());\n\tconst AMCAX::FrameT<double, 2>& frame = circle2D.Position();\n\tAMCAX::Point2 rotationPoint(0.0, 0.0);\n\tdouble  rotationAngle = M_PI / 4;\n\tauto rotatedCircle = circle2D.Rotated(rotationPoint, rotationAngle);\n\tdouble cosAngle = cos(rotationAngle);\n\tdouble sinAngle = sin(rotationAngle);\n\tdouble newX = cosAngle * (center2D.X() - rotationPoint.X()) - sinAngle * (center2D.Y() - rotationPoint.Y()) + rotationPoint.X();\n\tdouble newY = sinAngle * (center2D.X() - rotationPoint.X()) + cosAngle * (center2D.Y() - rotationPoint.Y()) + rotationPoint.Y();\n\tauto rotatedCenter = rotatedCircle.Location();\n\tCHECK(newX == center2D.X());\n\tCHECK(newY == center2D.Y());\n\tAMCAX::Point2 scalingCenter(0.0, 0.0);\n\tdouble scalingFactor = 2.0;\n\tauto scaledCircle = circle2D.Scale(scalingCenter, scalingFactor);\n\tdouble scaledRadius = scaledCircle.Radius();\n\tdouble expectedScaledRadius = redius2D * scalingFactor;\n\tCHECK(std::abs(scaledRadius - expectedScaledRadius) < 1e-6);\n\tAMCAX::VectorT<double, 2> translationVector(2.0, 3.0);\n\tauto translatedCircle = circle2D.Translated(translationVector);\n\tauto translatedCenter = translatedCircle.Location();\n\tdouble translatedX = center2D.X() + translationVector.X();\n\tCHECK(translatedX == translatedCenter.X());\n\tauto xAxis = circle2D.XAxis();\n\tauto directionAxis = xAxis.Direction();\n\tCHECK(directionAxis.X() == -1.0);\n\tCHECK(directionAxis.Y() == 0.0);\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] double SquaredDistance(const PointT<double, DIM>& p)\t @return The squared distance from the point to the circle\n\t @param p The point\n\t @brief Compute the squared distance from a point to the circle\n,\n",
      "output": "#include <math/CircleT.hpp>\n#include <common/CoordT.hpp>\n#include <common/TransformationType.hpp>\n#include <common/DirectionT.hpp>\n#include <common/PointT.hpp>\n#include <common/Precision.hpp>\n#include <common/CoordT.hpp>\n#include <common/TransformationType.hpp>\n#include <topology/TopoEdge.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <topology/TopoWire.hpp>\n#include <modeling/MakeWire.hpp>\n#include <geometry/GlobalProperty.hpp>\n#include <topology/BRepGlobalProperty.hpp>\n#include<iostream>\n#include \"catch.hpp\" \nusing namespace std;\nusing namespace AMCAX;\nTEST_CASE(\"TestCircle3D\", \"[math][Circle3D]\")\n{\n\tAMCAX::Circle3 circle3D;\n\tAMCAX::Point3  center3D(0.0, 0.0, 0.0);\n\tdouble radius3D = 5.0;\n\tdouble tol = 0.1;\n\tcircle3D.SetLocation(center3D);\n\tcircle3D.SetRadius(radius3D);\n\tdouble area = circle3D.Area();\n\tauto axis = circle3D.Axis();\n\tAMCAX::Point3 expectedDirection(0.0, 0.0, 1.0);\n\tauto direction = axis.Direction();\n\tCHECK(area == Approx(78.5398));\n\tCHECK(direction.X() == Approx(expectedDirection.X()).margin(tol));\n\tCHECK(direction.Y() == Approx(expectedDirection.Y()).margin(tol));\n\tCHECK(direction.Z() == Approx(expectedDirection.Z()).margin(tol));\n\tstd::vector <AMCAX::Point3> test3DPoints = {\n\t\tAMCAX::Point3(0.0, 0.0, 0.0),\n\t\tAMCAX::Point3(4.0, 0.0, 0.0),\n\t};\n\tfor (const auto& point : test3DPoints)\n\t{\n\t\tdouble distanceToCenter = std::sqrt(std::pow(point.X() - center3D.X(), 2) + std::pow(point.Y() - center3D.Y(), 2) + std::pow(point.Z() - center3D.Z(), 2));\n\t\tbool expectedIsCircle = distanceToCenter <= 5.0 + tol;\n\t\tbool isInCircle = circle3D.Contains(point, tol);\n\t\tCHECK(!isInCircle == expectedIsCircle);\n\t}\n\tAMCAX::PointT<double, 3>  pointOutside(10.0, 0.0, 0.0);\n\tdouble expectedDistance = 5.0;\n\tCHECK(circle3D.Distance(pointOutside) == Approx(expectedDistance));\n\tdouble length = circle3D.Length();\n\tCHECK(length == Approx(31.4159));\n\tauto location = circle3D.Location();\n\tCHECK(location.X() == Approx(0.0));\n\tCHECK(location.Y() == Approx(0.0));\n\tCHECK(location.Z() == Approx(0.0));\n\tAMCAX::PointT<double, 3> mirrorPoint(1.0, 0.0, 0.0);\n\tcircle3D.Mirror(mirrorPoint);\n\tauto mirroredLocation = circle3D.Location();\n\tCHECK(mirroredLocation.X() == Approx(2.0));\n\tCHECK(mirroredLocation.Y() == Approx(0.0));\n\tCHECK(mirroredLocation.Z() == Approx(0.0));\n\tauto position = circle3D.Position();   \n\tdouble r = circle3D.Radius();\n\tCHECK(r == 5.0);\n\tDirection3 zDirection(0.0, 0.0, 1.0);\n\tAxis3 zAxis(center3D, zDirection);\n\tTransformation3 rotation;\n\trotation.SetRotation(zAxis, M_PI / 2);  \n\tPoint3 newCenter1 = center3D.Transformed(rotation);\n\tCHECK(newCenter1.X() == 0.0);\n\tCHECK(newCenter1.Y() == 0.0);\n\tCHECK(newCenter1.Z() == 0.0);\n\tdouble angle = M_PI / 2;\n\tcircle3D.Rotated(zAxis, angle);\n\tAMCAX::Frame3 frame = circle3D.Position();\n\tCHECK(frame.Location().X() == 2.0);\n\tCHECK(frame.Location().Y() == 0.0);\n\tCHECK(frame.Location().Z() == 0.0);\n\tdouble scale = 2.0;\n\tcircle3D.Scale(center3D, scale);\n\tCHECK(circle3D.Radius() == radius3D * 2.0);\n\tAMCAX::PointT<double, 3> insidePoint(3.0, 4.0, 0.0);\n\tAMCAX::PointT<double, 3> onCirclePoint(5.0, 0.0, 0.0);\n\tAMCAX::PointT<double, 3> outsidePoint(8.0, 6.0, 0.0);\n\tdouble insideSquaredDistance = circle3D.SquaredDistance(insidePoint);\n\tdouble onCircleSquaredDistance = circle3D.SquaredDistance(onCirclePoint);\n\tdouble outsideSquaredDistance = circle3D.SquaredDistance(outsidePoint);\n\tCHECK(insideSquaredDistance == Approx(34.5378));\n\tCHECK(onCircleSquaredDistance == 81.0);\n\tCHECK(outsideSquaredDistance == Approx(7.7779));\n\tVectorT<double, 3> translationVector(5.0, 5.0, 0.0);\n\tcircle3D.Translate(translationVector);\n\tCHECK(circle3D.Location().X() == 9.0);\n\tCHECK(circle3D.Location().Y() == 5.0);\n\tCHECK(circle3D.Location().Z() == 0.0);\n\tauto xAxis = circle3D.XAxis();\n\tauto yAxis = circle3D.YAxis();\n\tCHECK(xAxis.Direction().X() == Approx(-1.0));\n\tCHECK(yAxis.Direction().Y() == Approx(-1.0));\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] double Distance(const PointT<double, DIM>& p)\t @return The distance from the point to the circle\n\t @param p The point\n\t @brief Compute the distance from a point to the circle\n,\n",
      "output": "#include <math/CircleT.hpp>\n#include <common/CoordT.hpp>\n#include <common/TransformationType.hpp>\n#include <common/DirectionT.hpp>\n#include <common/PointT.hpp>\n#include <common/Precision.hpp>\n#include <common/CoordT.hpp>\n#include <common/TransformationType.hpp>\n#include <topology/TopoEdge.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <topology/TopoWire.hpp>\n#include <modeling/MakeWire.hpp>\n#include <geometry/GlobalProperty.hpp>\n#include <topology/BRepGlobalProperty.hpp>\n#include<iostream>\n#include \"catch.hpp\" \nusing namespace std;\nusing namespace AMCAX;\nTEST_CASE(\"TestCircle3D\", \"[math][Circle3D]\")\n{\n\tAMCAX::Circle3 circle3D;\n\tAMCAX::Point3  center3D(0.0, 0.0, 0.0);\n\tdouble radius3D = 5.0;\n\tdouble tol = 0.1;\n\tcircle3D.SetLocation(center3D);\n\tcircle3D.SetRadius(radius3D);\n\tdouble area = circle3D.Area();\n\tauto axis = circle3D.Axis();\n\tAMCAX::Point3 expectedDirection(0.0, 0.0, 1.0);\n\tauto direction = axis.Direction();\n\tCHECK(area == Approx(78.5398));\n\tCHECK(direction.X() == Approx(expectedDirection.X()).margin(tol));\n\tCHECK(direction.Y() == Approx(expectedDirection.Y()).margin(tol));\n\tCHECK(direction.Z() == Approx(expectedDirection.Z()).margin(tol));\n\tstd::vector <AMCAX::Point3> test3DPoints = {\n\t\tAMCAX::Point3(0.0, 0.0, 0.0),\n\t\tAMCAX::Point3(4.0, 0.0, 0.0),\n\t};\n\tfor (const auto& point : test3DPoints)\n\t{\n\t\tdouble distanceToCenter = std::sqrt(std::pow(point.X() - center3D.X(), 2) + std::pow(point.Y() - center3D.Y(), 2) + std::pow(point.Z() - center3D.Z(), 2));\n\t\tbool expectedIsCircle = distanceToCenter <= 5.0 + tol;\n\t\tbool isInCircle = circle3D.Contains(point, tol);\n\t\tCHECK(!isInCircle == expectedIsCircle);\n\t}\n\tAMCAX::PointT<double, 3>  pointOutside(10.0, 0.0, 0.0);\n\tdouble expectedDistance = 5.0;\n\tCHECK(circle3D.Distance(pointOutside) == Approx(expectedDistance));\n\tdouble length = circle3D.Length();\n\tCHECK(length == Approx(31.4159));\n\tauto location = circle3D.Location();\n\tCHECK(location.X() == Approx(0.0));\n\tCHECK(location.Y() == Approx(0.0));\n\tCHECK(location.Z() == Approx(0.0));\n\tAMCAX::PointT<double, 3> mirrorPoint(1.0, 0.0, 0.0);\n\tcircle3D.Mirror(mirrorPoint);\n\tauto mirroredLocation = circle3D.Location();\n\tCHECK(mirroredLocation.X() == Approx(2.0));\n\tCHECK(mirroredLocation.Y() == Approx(0.0));\n\tCHECK(mirroredLocation.Z() == Approx(0.0));\n\tauto position = circle3D.Position();   \n\tdouble r = circle3D.Radius();\n\tCHECK(r == 5.0);\n\tDirection3 zDirection(0.0, 0.0, 1.0);\n\tAxis3 zAxis(center3D, zDirection);\n\tTransformation3 rotation;\n\trotation.SetRotation(zAxis, M_PI / 2);  \n\tPoint3 newCenter1 = center3D.Transformed(rotation);\n\tCHECK(newCenter1.X() == 0.0);\n\tCHECK(newCenter1.Y() == 0.0);\n\tCHECK(newCenter1.Z() == 0.0);\n\tdouble angle = M_PI / 2;\n\tcircle3D.Rotated(zAxis, angle);\n\tAMCAX::Frame3 frame = circle3D.Position();\n\tCHECK(frame.Location().X() == 2.0);\n\tCHECK(frame.Location().Y() == 0.0);\n\tCHECK(frame.Location().Z() == 0.0);\n\tdouble scale = 2.0;\n\tcircle3D.Scale(center3D, scale);\n\tCHECK(circle3D.Radius() == radius3D * 2.0);\n\tAMCAX::PointT<double, 3> insidePoint(3.0, 4.0, 0.0);\n\tAMCAX::PointT<double, 3> onCirclePoint(5.0, 0.0, 0.0);\n\tAMCAX::PointT<double, 3> outsidePoint(8.0, 6.0, 0.0);\n\tdouble insideSquaredDistance = circle3D.SquaredDistance(insidePoint);\n\tdouble onCircleSquaredDistance = circle3D.SquaredDistance(onCirclePoint);\n\tdouble outsideSquaredDistance = circle3D.SquaredDistance(outsidePoint);\n\tCHECK(insideSquaredDistance == Approx(34.5378));\n\tCHECK(onCircleSquaredDistance == 81.0);\n\tCHECK(outsideSquaredDistance == Approx(7.7779));\n\tVectorT<double, 3> translationVector(5.0, 5.0, 0.0);\n\tcircle3D.Translate(translationVector);\n\tCHECK(circle3D.Location().X() == 9.0);\n\tCHECK(circle3D.Location().Y() == 5.0);\n\tCHECK(circle3D.Location().Z() == 0.0);\n\tauto xAxis = circle3D.XAxis();\n\tauto yAxis = circle3D.YAxis();\n\tCHECK(xAxis.Direction().X() == Approx(-1.0));\n\tCHECK(yAxis.Direction().Y() == Approx(-1.0));\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] double Radius()\t @return The radius\n\t @brief Get the radius\n,\n",
      "output": "#include <math/CircleT.hpp>\n#include <common/CoordT.hpp>\n#include <common/TransformationType.hpp>\n#include <common/DirectionT.hpp>\n#include <common/PointT.hpp>\n#include <common/Precision.hpp>\n#include <common/CoordT.hpp>\n#include <common/TransformationType.hpp>\n#include <topology/TopoEdge.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <topology/TopoWire.hpp>\n#include <modeling/MakeWire.hpp>\n#include <geometry/GlobalProperty.hpp>\n#include <topology/BRepGlobalProperty.hpp>\n#include<iostream>\n#include \"catch.hpp\" \nusing namespace std;\nusing namespace AMCAX;\nTEST_CASE(\"TestCircle3D\", \"[math][Circle3D]\")\n{\n\tAMCAX::Circle3 circle3D;\n\tAMCAX::Point3  center3D(0.0, 0.0, 0.0);\n\tdouble radius3D = 5.0;\n\tdouble tol = 0.1;\n\tcircle3D.SetLocation(center3D);\n\tcircle3D.SetRadius(radius3D);\n\tdouble area = circle3D.Area();\n\tauto axis = circle3D.Axis();\n\tAMCAX::Point3 expectedDirection(0.0, 0.0, 1.0);\n\tauto direction = axis.Direction();\n\tCHECK(area == Approx(78.5398));\n\tCHECK(direction.X() == Approx(expectedDirection.X()).margin(tol));\n\tCHECK(direction.Y() == Approx(expectedDirection.Y()).margin(tol));\n\tCHECK(direction.Z() == Approx(expectedDirection.Z()).margin(tol));\n\tstd::vector <AMCAX::Point3> test3DPoints = {\n\t\tAMCAX::Point3(0.0, 0.0, 0.0),\n\t\tAMCAX::Point3(4.0, 0.0, 0.0),\n\t};\n\tfor (const auto& point : test3DPoints)\n\t{\n\t\tdouble distanceToCenter = std::sqrt(std::pow(point.X() - center3D.X(), 2) + std::pow(point.Y() - center3D.Y(), 2) + std::pow(point.Z() - center3D.Z(), 2));\n\t\tbool expectedIsCircle = distanceToCenter <= 5.0 + tol;\n\t\tbool isInCircle = circle3D.Contains(point, tol);\n\t\tCHECK(!isInCircle == expectedIsCircle);\n\t}\n\tAMCAX::PointT<double, 3>  pointOutside(10.0, 0.0, 0.0);\n\tdouble expectedDistance = 5.0;\n\tCHECK(circle3D.Distance(pointOutside) == Approx(expectedDistance));\n\tdouble length = circle3D.Length();\n\tCHECK(length == Approx(31.4159));\n\tauto location = circle3D.Location();\n\tCHECK(location.X() == Approx(0.0));\n\tCHECK(location.Y() == Approx(0.0));\n\tCHECK(location.Z() == Approx(0.0));\n\tAMCAX::PointT<double, 3> mirrorPoint(1.0, 0.0, 0.0);\n\tcircle3D.Mirror(mirrorPoint);\n\tauto mirroredLocation = circle3D.Location();\n\tCHECK(mirroredLocation.X() == Approx(2.0));\n\tCHECK(mirroredLocation.Y() == Approx(0.0));\n\tCHECK(mirroredLocation.Z() == Approx(0.0));\n\tauto position = circle3D.Position();   \n\tdouble r = circle3D.Radius();\n\tCHECK(r == 5.0);\n\tDirection3 zDirection(0.0, 0.0, 1.0);\n\tAxis3 zAxis(center3D, zDirection);\n\tTransformation3 rotation;\n\trotation.SetRotation(zAxis, M_PI / 2);  \n\tPoint3 newCenter1 = center3D.Transformed(rotation);\n\tCHECK(newCenter1.X() == 0.0);\n\tCHECK(newCenter1.Y() == 0.0);\n\tCHECK(newCenter1.Z() == 0.0);\n\tdouble angle = M_PI / 2;\n\tcircle3D.Rotated(zAxis, angle);\n\tAMCAX::Frame3 frame = circle3D.Position();\n\tCHECK(frame.Location().X() == 2.0);\n\tCHECK(frame.Location().Y() == 0.0);\n\tCHECK(frame.Location().Z() == 0.0);\n\tdouble scale = 2.0;\n\tcircle3D.Scale(center3D, scale);\n\tCHECK(circle3D.Radius() == radius3D * 2.0);\n\tAMCAX::PointT<double, 3> insidePoint(3.0, 4.0, 0.0);\n\tAMCAX::PointT<double, 3> onCirclePoint(5.0, 0.0, 0.0);\n\tAMCAX::PointT<double, 3> outsidePoint(8.0, 6.0, 0.0);\n\tdouble insideSquaredDistance = circle3D.SquaredDistance(insidePoint);\n\tdouble onCircleSquaredDistance = circle3D.SquaredDistance(onCirclePoint);\n\tdouble outsideSquaredDistance = circle3D.SquaredDistance(outsidePoint);\n\tCHECK(insideSquaredDistance == Approx(34.5378));\n\tCHECK(onCircleSquaredDistance == 81.0);\n\tCHECK(outsideSquaredDistance == Approx(7.7779));\n\tVectorT<double, 3> translationVector(5.0, 5.0, 0.0);\n\tcircle3D.Translate(translationVector);\n\tCHECK(circle3D.Location().X() == 9.0);\n\tCHECK(circle3D.Location().Y() == 5.0);\n\tCHECK(circle3D.Location().Z() == 0.0);\n\tauto xAxis = circle3D.XAxis();\n\tauto yAxis = circle3D.YAxis();\n\tCHECK(xAxis.Direction().X() == Approx(-1.0));\n\tCHECK(yAxis.Direction().Y() == Approx(-1.0));\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "void SetRadius(double r)\t @param r The radius\n\t @brief Set the radius of the circle\n,\n",
      "output": "#include <math/CircleT.hpp>\n#include <common/CoordT.hpp>\n#include <common/TransformationType.hpp>\n#include <common/DirectionT.hpp>\n#include <common/PointT.hpp>\n#include <common/Precision.hpp>\n#include <common/CoordT.hpp>\n#include <common/TransformationType.hpp>\n#include <topology/TopoEdge.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <topology/TopoWire.hpp>\n#include <modeling/MakeWire.hpp>\n#include <geometry/GlobalProperty.hpp>\n#include <topology/BRepGlobalProperty.hpp>\n#include<iostream>\n#include \"catch.hpp\" \nusing namespace std;\nusing namespace AMCAX;\nTEST_CASE(\"TestCircle2D\", \"[math][Circle2D]\")\n{\n\tAMCAX::CircleT<double, 2> circle2D;\n\tAMCAX::Point2 center2D(0.0, 0.0);\n\tdouble redius2D = 5.0;\n\tdouble tol = 0.1;\n\tcircle2D.SetLocation(center2D);\n\tcircle2D.SetRadius(redius2D);\n\tdouble area2D = circle2D.Area();\n\tdouble length2D = circle2D.Length();\n\tAMCAX::Point2 retcenter2D = circle2D.Location();\n\tdouble retarea2D = M_PI * redius2D * redius2D;\n\tdouble retlength2D = 2 * M_PI * redius2D;\n\tstd::cout << area2D << std::endl;\n\tstd::cout << length2D << std::endl;\n\tstd::cout << retcenter2D.X() << std::endl;\n\tstd::cout << retcenter2D.Y() << std::endl;\n\tCHECK(area2D == retarea2D);\n\tCHECK(length2D == retlength2D);\n\tCHECK(retcenter2D.X() == center2D.X());\n\tCHECK(retcenter2D.Y() == center2D.Y());\n\tdouble a, b, c, d, e, f;\n\tcircle2D.Coefficients(a, b, c, d, e, f);\n\tstd::cout << a << std::endl;\n\tstd::cout << b << std::endl;\n\tstd::cout << c << std::endl;\n\tstd::cout << d << std::endl;\n\tstd::cout << e << std::endl;\n\tstd::cout << f << std::endl;\n\tCHECK(a == 1);\n\tCHECK(b == 1);\n\tCHECK(c == 0);\n\tCHECK(d == 0);\n\tCHECK(e == 0);\n\tCHECK(f == -25);\n\tstd::vector < AMCAX::Point2> testPoints = {\n\t\tAMCAX::Point2(3.0, 4.0),\n\t\tAMCAX::Point2(5.0, 0.0),\n\t\tAMCAX::Point2(4.9, 0.0),\n\t\tAMCAX::Point2(5.1, 0.0),\n\t\tAMCAX::Point2(6.0, 0.0)\n\t};\n\tfor (const auto& point : testPoints)\n\t{\n\t\tdouble distanceToCenter = std::sqrt(point.X() * point.X() + point.Y() * point.Y());\n\t\tbool expectedIsInCircle = distanceToCenter <= 5.0 + tol;\n\t\tbool isInCircle = circle2D.Contains(point, tol);\n\t\tCHECK(isInCircle == expectedIsInCircle);\n\t}\n\tfor (const auto& point : testPoints)\n\t{\n\t\tdouble distance = circle2D.Distance(point);\n\t\tdouble expectedDistance = std::abs(std::sqrt(std::pow(point.X() - center2D.X(), 2) + std::pow(point.Y() - center2D.Y(), 2)) - redius2D);\n\t\tCHECK(distance == expectedDistance);\n\t}\n\tAMCAX::AxisT<double, 2> mirrorAxis(AMCAX::Point2(0.0, 0.0), AMCAX::Direction2(0.0, 1.0));\n\tcircle2D.Mirror(mirrorAxis);\n\tAMCAX::Point2 mirroredCenter = circle2D.Location();\n\tstd::cout << \"Mirrored circle center: (\" << mirroredCenter.X() << \", \" << mirroredCenter.Y() << \")\" << std::endl;\n\tCHECK(mirroredCenter.X() == center2D.X());\n\tCHECK(mirroredCenter.Y() == center2D.Y());\n\tconst AMCAX::FrameT<double, 2>& frame = circle2D.Position();\n\tAMCAX::Point2 rotationPoint(0.0, 0.0);\n\tdouble  rotationAngle = M_PI / 4;\n\tauto rotatedCircle = circle2D.Rotated(rotationPoint, rotationAngle);\n\tdouble cosAngle = cos(rotationAngle);\n\tdouble sinAngle = sin(rotationAngle);\n\tdouble newX = cosAngle * (center2D.X() - rotationPoint.X()) - sinAngle * (center2D.Y() - rotationPoint.Y()) + rotationPoint.X();\n\tdouble newY = sinAngle * (center2D.X() - rotationPoint.X()) + cosAngle * (center2D.Y() - rotationPoint.Y()) + rotationPoint.Y();\n\tauto rotatedCenter = rotatedCircle.Location();\n\tCHECK(newX == center2D.X());\n\tCHECK(newY == center2D.Y());\n\tAMCAX::Point2 scalingCenter(0.0, 0.0);\n\tdouble scalingFactor = 2.0;\n\tauto scaledCircle = circle2D.Scale(scalingCenter, scalingFactor);\n\tdouble scaledRadius = scaledCircle.Radius();\n\tdouble expectedScaledRadius = redius2D * scalingFactor;\n\tCHECK(std::abs(scaledRadius - expectedScaledRadius) < 1e-6);\n\tAMCAX::VectorT<double, 2> translationVector(2.0, 3.0);\n\tauto translatedCircle = circle2D.Translated(translationVector);\n\tauto translatedCenter = translatedCircle.Location();\n\tdouble translatedX = center2D.X() + translationVector.X();\n\tCHECK(translatedX == translatedCenter.X());\n\tauto xAxis = circle2D.XAxis();\n\tauto directionAxis = xAxis.Direction();\n\tCHECK(directionAxis.X() == -1.0);\n\tCHECK(directionAxis.Y() == 0.0);\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] double Distance(const PointT<double, DIM>& p)\t @return The distance from the point to the circle\n\t @param p The point\n\t @brief Compute the distance from a point to the circle\n,\n",
      "output": "#include<catch.hpp>\n#include \"testHelper.h\"\n#include<iostream>\n#include <math/CircleT.hpp>\n#include <common/AxisT.hpp>\n#include <common/PointT.hpp>\nTEST_CASE(\"case1: create a Cirecle\", \"[math][CircleT][P1]\") {\n\tAMCAX::Point2 P(0.0,0.0);\n\tAMCAX::Direction2 D(1.0,0.0);\n\tAMCAX::Axis2  axis2(P, D);\n\tfloat radius = 5.0f;\n\tAMCAX::Circle2 circle2(axis2, radius, true);\n\tCHECK(circle2.Area() == radius * radius * M_PI); \n    double a, b, c, d, e, f;\n    circle2.Coefficients(a, b, c, d, e, f);  \n    double x = 0, y = 5;\n    CHECK(a * x * x + b * y * y + c * x * y + d * x + e * y + f == Approx(0.0).epsilon(1e-15));\n    double x1 = 5 * sqrt(2) / 2;\n    double y1 = 5 * sqrt(2) / 2;\n    double x2 = 6;\n    double y2 = 0;\n    double x3 = 5.5;\n    double y3 = 6.1;\n    AMCAX::Point2 P1(x1,y1);\n    AMCAX::Point2 P2(x2, y2);\n    AMCAX::Point2 P3(x3, y3);\n    double tolerance1 = 0.1;\n    double tolerance2 = 1.0;\n    CHECK(circle2.Contains(P1, tolerance1) == true);\n    CHECK(circle2.Contains(P2, tolerance2) == true);\n    CHECK(circle2.Contains(P3, tolerance2) == false);\n    CHECK(circle2.Distance(P1) == Approx(0.0).epsilon(1e-15));\n    CHECK(circle2.Distance(P2) == Approx(1.0).epsilon(1e-15));\n    CHECK(circle2.Length() == Approx(2*M_PI*radius).epsilon(1e-15));\n    AMCAX::Point2 locationP = circle2.Location();\n    CHECK(locationP.X() == Approx(0.0).epsilon(1e-15));\n    CHECK(locationP.Y() == Approx(0.0).epsilon(1e-15));\n    AMCAX::Point2 mirrorAxisPoint(1.0, 0.0);\n    AMCAX::Direction2 mirrorAxisDirection(0.0, 1.0);\n    AMCAX::Axis2 mirrorAxis(mirrorAxisPoint, mirrorAxisDirection);\n    circle2.Mirror(mirrorAxis);\n    CHECK(circle2.Length() == Approx(2 * M_PI * radius).epsilon(1e-15));\n    AMCAX::Point2 locationPmirror = circle2.Location();\n    CHECK(locationPmirror.X() == Approx(2.0).epsilon(1e-15));\n    CHECK(locationPmirror.Y() == Approx(0.0).epsilon(1e-15));\n    AMCAX::Point2 P4(7.0, 0.0);  \n    CHECK(circle2.Contains(P4, tolerance2) == true);\n    AMCAX::Point2 mirroredAxisPoint(1.0, 0.0);\n    AMCAX::Direction2 mirroredAxisDirection(0.0, 1.0);\n    AMCAX::Axis2 mirroedrAxis(mirroredAxisPoint, mirroredAxisDirection);\n    AMCAX::Circle2 circle2mirrored = circle2.Mirrored(mirroedrAxis);\n    CHECK(circle2mirrored.Length() == Approx(2 * M_PI * radius).epsilon(1e-15));\n    AMCAX::Point2 locationPmirrored = circle2mirrored.Location();\n    CHECK(locationPmirrored.X() == Approx(0.0).epsilon(1e-15));\n    CHECK(locationPmirrored.Y() == Approx(0.0).epsilon(1e-15));\n    AMCAX::Frame2 frame2mirrored = circle2mirrored.Position(); \n    CHECK(frame2mirrored.Location().X() == Approx(0.0).epsilon(1e-15));\n    CHECK(frame2mirrored.Location().Y() == Approx(0.0).epsilon(1e-15));\n    const double& radiusmirrored = circle2mirrored.Radius(); \n    CHECK(radiusmirrored == Approx(radius).epsilon(1e-15));\n    circle2mirrored.Scale(P,0.5); \n    AMCAX::Point2 scaleP1(0.0,-2.5);\n    CHECK(circle2mirrored.Contains(scaleP1, 0) == true);\n    AMCAX::Circle2 circle2Scaled = circle2mirrored.Scale(P, 2); \n    AMCAX::Point2 scaledP1(0.0, 5.0);\n    CHECK(circle2Scaled.Contains(scaledP1, 0) == true);\n    AMCAX::Point2 rotateP(0.0,0.0);\n    double angle = 90.0 * (2 * M_PI / 360.0);\n    circle2.Rotate(rotateP, angle); \n    AMCAX::Point2 P5(0.0, -3.0);\n    CHECK(circle2.Contains(P5, 0) == true);\n    double angle2 = -180.0 * (2 * M_PI / 360.0);\n    AMCAX::Circle2 rotatedCircle2 = circle2.Rotated(rotateP, angle2); \n    AMCAX::Point2 P6(0.0, 3.0);\n    CHECK(rotatedCircle2.Contains(P6, 0) == true); \n    AMCAX::Point2 newP(0.0, 0.0);\n    rotatedCircle2.SetLocation(newP);\n    CHECK(rotatedCircle2.Contains(P1, 0) == true);\n    std::cout << circle2.Length() << std::endl;\n};\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] double Length()\t @return The length of the circle\n\t @brief Get the length of the circle\n,\n",
      "output": "#include<catch.hpp>\n#include \"testHelper.h\"\n#include<iostream>\n#include <math/CircleT.hpp>\n#include <common/AxisT.hpp>\n#include <common/PointT.hpp>\nTEST_CASE(\"case1: create a Cirecle\", \"[math][CircleT][P1]\") {\n\tAMCAX::Point2 P(0.0,0.0);\n\tAMCAX::Direction2 D(1.0,0.0);\n\tAMCAX::Axis2  axis2(P, D);\n\tfloat radius = 5.0f;\n\tAMCAX::Circle2 circle2(axis2, radius, true);\n\tCHECK(circle2.Area() == radius * radius * M_PI); \n    double a, b, c, d, e, f;\n    circle2.Coefficients(a, b, c, d, e, f);  \n    double x = 0, y = 5;\n    CHECK(a * x * x + b * y * y + c * x * y + d * x + e * y + f == Approx(0.0).epsilon(1e-15));\n    double x1 = 5 * sqrt(2) / 2;\n    double y1 = 5 * sqrt(2) / 2;\n    double x2 = 6;\n    double y2 = 0;\n    double x3 = 5.5;\n    double y3 = 6.1;\n    AMCAX::Point2 P1(x1,y1);\n    AMCAX::Point2 P2(x2, y2);\n    AMCAX::Point2 P3(x3, y3);\n    double tolerance1 = 0.1;\n    double tolerance2 = 1.0;\n    CHECK(circle2.Contains(P1, tolerance1) == true);\n    CHECK(circle2.Contains(P2, tolerance2) == true);\n    CHECK(circle2.Contains(P3, tolerance2) == false);\n    CHECK(circle2.Distance(P1) == Approx(0.0).epsilon(1e-15));\n    CHECK(circle2.Distance(P2) == Approx(1.0).epsilon(1e-15));\n    CHECK(circle2.Length() == Approx(2*M_PI*radius).epsilon(1e-15));\n    AMCAX::Point2 locationP = circle2.Location();\n    CHECK(locationP.X() == Approx(0.0).epsilon(1e-15));\n    CHECK(locationP.Y() == Approx(0.0).epsilon(1e-15));\n    AMCAX::Point2 mirrorAxisPoint(1.0, 0.0);\n    AMCAX::Direction2 mirrorAxisDirection(0.0, 1.0);\n    AMCAX::Axis2 mirrorAxis(mirrorAxisPoint, mirrorAxisDirection);\n    circle2.Mirror(mirrorAxis);\n    CHECK(circle2.Length() == Approx(2 * M_PI * radius).epsilon(1e-15));\n    AMCAX::Point2 locationPmirror = circle2.Location();\n    CHECK(locationPmirror.X() == Approx(2.0).epsilon(1e-15));\n    CHECK(locationPmirror.Y() == Approx(0.0).epsilon(1e-15));\n    AMCAX::Point2 P4(7.0, 0.0);  \n    CHECK(circle2.Contains(P4, tolerance2) == true);\n    AMCAX::Point2 mirroredAxisPoint(1.0, 0.0);\n    AMCAX::Direction2 mirroredAxisDirection(0.0, 1.0);\n    AMCAX::Axis2 mirroedrAxis(mirroredAxisPoint, mirroredAxisDirection);\n    AMCAX::Circle2 circle2mirrored = circle2.Mirrored(mirroedrAxis);\n    CHECK(circle2mirrored.Length() == Approx(2 * M_PI * radius).epsilon(1e-15));\n    AMCAX::Point2 locationPmirrored = circle2mirrored.Location();\n    CHECK(locationPmirrored.X() == Approx(0.0).epsilon(1e-15));\n    CHECK(locationPmirrored.Y() == Approx(0.0).epsilon(1e-15));\n    AMCAX::Frame2 frame2mirrored = circle2mirrored.Position(); \n    CHECK(frame2mirrored.Location().X() == Approx(0.0).epsilon(1e-15));\n    CHECK(frame2mirrored.Location().Y() == Approx(0.0).epsilon(1e-15));\n    const double& radiusmirrored = circle2mirrored.Radius(); \n    CHECK(radiusmirrored == Approx(radius).epsilon(1e-15));\n    circle2mirrored.Scale(P,0.5); \n    AMCAX::Point2 scaleP1(0.0,-2.5);\n    CHECK(circle2mirrored.Contains(scaleP1, 0) == true);\n    AMCAX::Circle2 circle2Scaled = circle2mirrored.Scale(P, 2); \n    AMCAX::Point2 scaledP1(0.0, 5.0);\n    CHECK(circle2Scaled.Contains(scaledP1, 0) == true);\n    AMCAX::Point2 rotateP(0.0,0.0);\n    double angle = 90.0 * (2 * M_PI / 360.0);\n    circle2.Rotate(rotateP, angle); \n    AMCAX::Point2 P5(0.0, -3.0);\n    CHECK(circle2.Contains(P5, 0) == true);\n    double angle2 = -180.0 * (2 * M_PI / 360.0);\n    AMCAX::Circle2 rotatedCircle2 = circle2.Rotated(rotateP, angle2); \n    AMCAX::Point2 P6(0.0, 3.0);\n    CHECK(rotatedCircle2.Contains(P6, 0) == true); \n    AMCAX::Point2 newP(0.0, 0.0);\n    rotatedCircle2.SetLocation(newP);\n    CHECK(rotatedCircle2.Contains(P1, 0) == true);\n    std::cout << circle2.Length() << std::endl;\n};\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] double Radius()\t @return The radius\n\t @brief Get the radius\n,\n",
      "output": "#include<catch.hpp>\n#include \"testHelper.h\"\n#include<iostream>\n#include <math/CircleT.hpp>\n#include <common/AxisT.hpp>\n#include <common/PointT.hpp>\nTEST_CASE(\"CircleT Constructor Test\", \"[math][CircleT][P1]\") {\n\tSECTION(\"2D Circle Construction\") {\n        AMCAX::Circle2 circle2;\n        constexpr double maxr = std::numeric_limits<double>::max();\n        CHECK(circle2.Radius() == Approx(maxr).epsilon(1e-15));\n        CHECK(circle2.Area() == Approx(maxr * maxr * M_PI).epsilon(1e-15));\n        double a, b, c, d, e, f;\n        circle2.Coefficients(a, b, c, d, e, f);\n        std::cout << a << std::endl;\n        std::cout << b << std::endl;\n        std::cout << c << std::endl;\n        std::cout << d << std::endl;\n        std::cout << e << std::endl;\n        std::cout << f << std::endl;\n        AMCAX::Point2 P(0.0, 1.0);\n        double tolerance = 0.1;\n        CHECK(circle2.Contains(P, tolerance)==false);\n        CHECK(circle2.Distance(P) == Approx(maxr).epsilon(1e-15));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "void SetRadius(double r)\t @param r The radius\n\t @brief Set the radius of the circle\n,\n",
      "output": "#include<catch.hpp>\n#include \"testHelper.h\"\n#include<iostream>\n#include <math/CircleT.hpp>\n#include <common/AxisT.hpp>\n#include <common/PointT.hpp>\nTEST_CASE(\"CircleT Area and Length Test\", \"[CircleT]\") {\n    AMCAX::Circle2 circle2;\n    circle2.SetRadius(5.0);\n    CHECK(circle2.Area() == Approx(78.53982));\n    CHECK(circle2.Length() == Approx(31.41593));\n    AMCAX::Circle3 circle3;\n    circle3.SetRadius(10.0);\n    CHECK(circle3.Area() == Approx(314.15927));\n    CHECK(circle3.Length() == Approx(62.83185));\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static bool Read(TopoShape& s, std::istream& is)\t @return True if the input process is succeed\n\t @param[in,out] is The input stream\n\t @param[out] s The shape\n\t @brief Read a shape from a stream\n,\n",
      "output": "#include <catch.hpp>\n#include<testHelper.h>\n#include <topology/TopoShape.hpp>\n#include <occtio/OCCTTool.hpp>\nstatic bool ComparisonFields(const std::string& file1, const std::string& file2, const std::string& fields)\n{\n\tifstream file1Stream(file1);\n\tifstream file2Stream(file2);\n\tif (file1Stream.is_open() == false || file2Stream.is_open() == false)\n\t{\n\t\tfile1Stream.close();\n\t\tfile2Stream.close();\n\t\treturn false;\n\t}\n\tstd::string line1, line2;\n\twhile (std::getline(file1Stream, line1))\n\t{\n\t\tif (line1.find(fields) != std::string::npos) break;\n\t}\n\twhile (std::getline(file2Stream, line2))\n\t{\n\t\tif (line2.find(fields) != std::string::npos) break;\n\t}\n\tfile1Stream.close();\n\tfile2Stream.close();\n\treturn line1 == line2;\n}\nTEST_CASE(\"CASE3:Check occio read not exist file \", \"[occtio][OCCTTool][p2]\") {\n\tAMCAX::TopoShape shape;\n\tSECTION(\"OCCTIO::OCCTTool::Read\") {\n\t\tbool isReadSuccess = AMCAX::OCCTIO::OCCTTool::Read(shape, INPUT_PATH_PREFIX\"NOTEXIST.brep\");\n\t\tCHECK(isReadSuccess == false);\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static bool Write(const TopoShape& s, const std::string& file, bool withTriangles, int format = 3)\t @return True if the output process is succeed\n\t @param format The format version\n\t @param withTriangles Determine whether writing the triangular mesh of the shape\n\t @param file The output file\n\t @param s The shape\n\t @brief Write a shape to a file\n,\n",
      "output": "#include <catch.hpp>\n#include<testHelper.h>\n#include <topology/TopoShape.hpp>\n#include <occtio/OCCTTool.hpp>\nstatic bool ComparisonFields(const std::string& file1, const std::string& file2, const std::string& fields)\n{\n\tifstream file1Stream(file1);\n\tifstream file2Stream(file2);\n\tif (file1Stream.is_open() == false || file2Stream.is_open() == false)\n\t{\n\t\tfile1Stream.close();\n\t\tfile2Stream.close();\n\t\treturn false;\n\t}\n\tstd::string line1, line2;\n\twhile (std::getline(file1Stream, line1))\n\t{\n\t\tif (line1.find(fields) != std::string::npos) break;\n\t}\n\twhile (std::getline(file2Stream, line2))\n\t{\n\t\tif (line2.find(fields) != std::string::npos) break;\n\t}\n\tfile1Stream.close();\n\tfile2Stream.close();\n\treturn line1 == line2;\n}\nTEST_CASE(\"CASE1:Check occtio read and write normal brep file function with different param \", \"[occtio][OCCTTool][p1][XXX]\") {\n\tAMCAX::TopoShape shape;\n\tbool isReadSuccess = AMCAX::OCCTIO::OCCTTool::Read(shape, INPUT_PATH_PREFIX\"occtio/occtio_read_I_brephaveMesh-case1.brep\");\n\tbool isWriteSuccess1f = AMCAX::OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f1-f-case1.brep\", false, 1);\n\tbool isWriteSuccess2f = AMCAX::OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f2-f-case1.brep\", false, 2);\n\tbool isWriteSuccess3f = AMCAX::OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f3-f-case1.brep\", false, 3);\n\tbool isWriteSuccess1t = AMCAX::OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f1-t-case1.brep\", true, 1);\n\tbool isWriteSuccess2t = AMCAX::OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f2-t-case1.brep\", true, 2);\n\tbool isWriteSuccess3t = AMCAX::OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f3-t-case1.brep\", true, 3);\n\tCHECK(isReadSuccess == true);\n\tCHECK(isWriteSuccess1f == true);\n\tCHECK(isWriteSuccess2f == true);\n\tCHECK(isWriteSuccess3f == true);\n\tCHECK(containsStringInFile(OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f1-f-case1.brep\", \"Triangulations 0\") == true);\n\tCHECK(containsStringInFile(OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f1-f-case1.brep\", \"CASCADE Topology V1, (c) Matra-Datavision\") == true);\n\tCHECK(containsStringInFile(OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f2-f-case1.brep\", \"Triangulations 0\") == true);\n\tCHECK(containsStringInFile(OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f2-f-case1.brep\", \"CASCADE Topology V2, (c) Matra-Datavision\") == true);\n\tCHECK(containsStringInFile(OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f3-f-case1.brep\", \"Triangulations 0\") == true);\n\tCHECK(containsStringInFile(OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f3-f-case1.brep\", \"CASCADE Topology V3, (c) Open Cascade\") == true);\n\tCHECK(isWriteSuccess1t == true);\n\tCHECK(isWriteSuccess2t == true);\n\tCHECK(isWriteSuccess3t == true);\n\tCHECK(containsStringInFile(OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f1-t-case1.brep\", \"Triangulations 0\") == false);\n\tCHECK(containsStringInFile(OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f1-t-case1.brep\", \"CASCADE Topology V1, (c) Matra-Datavision\") == true);\n\tCHECK(containsStringInFile(OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f2-t-case1.brep\", \"Triangulations 0\") == false);\n\tCHECK(containsStringInFile(OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f2-t-case1.brep\", \"CASCADE Topology V2, (c) Matra-Datavision\") == true);\n\tCHECK(containsStringInFile(OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f3-t-case1.brep\", \"Triangulations 0\") == false);\n\tCHECK(containsStringInFile(OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f3-t-case1.brep\", \"CASCADE Topology V3, (c) Open Cascade\") == true);\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static bool Write(const TopoShape& s, const std::string& file, int format = 3)\t @return True if the output process is succeed\n\t @param format The format version\n\t @param file The output file\n\t @param s The shape\n\t @brief Write a shape to a file\n,\n",
      "output": "#include <catch.hpp>\n#include<testHelper.h>\n#include <topology/TopoShape.hpp>\n#include <occtio/OCCTTool.hpp>\nstatic bool ComparisonFields(const std::string& file1, const std::string& file2, const std::string& fields)\n{\n\tifstream file1Stream(file1);\n\tifstream file2Stream(file2);\n\tif (file1Stream.is_open() == false || file2Stream.is_open() == false)\n\t{\n\t\tfile1Stream.close();\n\t\tfile2Stream.close();\n\t\treturn false;\n\t}\n\tstd::string line1, line2;\n\twhile (std::getline(file1Stream, line1))\n\t{\n\t\tif (line1.find(fields) != std::string::npos) break;\n\t}\n\twhile (std::getline(file2Stream, line2))\n\t{\n\t\tif (line2.find(fields) != std::string::npos) break;\n\t}\n\tfile1Stream.close();\n\tfile2Stream.close();\n\treturn line1 == line2;\n}\nTEST_CASE(\"CASE1:Check occtio read and write normal brep file function with different param \", \"[occtio][OCCTTool][p1][XXX]\") {\n\tAMCAX::TopoShape shape;\n\tbool isReadSuccess = AMCAX::OCCTIO::OCCTTool::Read(shape, INPUT_PATH_PREFIX\"occtio/occtio_read_I_brephaveMesh-case1.brep\");\n\tbool isWriteSuccess1f = AMCAX::OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f1-f-case1.brep\", false, 1);\n\tbool isWriteSuccess2f = AMCAX::OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f2-f-case1.brep\", false, 2);\n\tbool isWriteSuccess3f = AMCAX::OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f3-f-case1.brep\", false, 3);\n\tbool isWriteSuccess1t = AMCAX::OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f1-t-case1.brep\", true, 1);\n\tbool isWriteSuccess2t = AMCAX::OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f2-t-case1.brep\", true, 2);\n\tbool isWriteSuccess3t = AMCAX::OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f3-t-case1.brep\", true, 3);\n\tCHECK(isReadSuccess == true);\n\tCHECK(isWriteSuccess1f == true);\n\tCHECK(isWriteSuccess2f == true);\n\tCHECK(isWriteSuccess3f == true);\n\tCHECK(containsStringInFile(OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f1-f-case1.brep\", \"Triangulations 0\") == true);\n\tCHECK(containsStringInFile(OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f1-f-case1.brep\", \"CASCADE Topology V1, (c) Matra-Datavision\") == true);\n\tCHECK(containsStringInFile(OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f2-f-case1.brep\", \"Triangulations 0\") == true);\n\tCHECK(containsStringInFile(OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f2-f-case1.brep\", \"CASCADE Topology V2, (c) Matra-Datavision\") == true);\n\tCHECK(containsStringInFile(OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f3-f-case1.brep\", \"Triangulations 0\") == true);\n\tCHECK(containsStringInFile(OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f3-f-case1.brep\", \"CASCADE Topology V3, (c) Open Cascade\") == true);\n\tCHECK(isWriteSuccess1t == true);\n\tCHECK(isWriteSuccess2t == true);\n\tCHECK(isWriteSuccess3t == true);\n\tCHECK(containsStringInFile(OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f1-t-case1.brep\", \"Triangulations 0\") == false);\n\tCHECK(containsStringInFile(OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f1-t-case1.brep\", \"CASCADE Topology V1, (c) Matra-Datavision\") == true);\n\tCHECK(containsStringInFile(OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f2-t-case1.brep\", \"Triangulations 0\") == false);\n\tCHECK(containsStringInFile(OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f2-t-case1.brep\", \"CASCADE Topology V2, (c) Matra-Datavision\") == true);\n\tCHECK(containsStringInFile(OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f3-t-case1.brep\", \"Triangulations 0\") == false);\n\tCHECK(containsStringInFile(OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f3-t-case1.brep\", \"CASCADE Topology V3, (c) Open Cascade\") == true);\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static bool Write(const TopoShape& s, std::ostream& os, bool withTriangles, int format = 3)\t @return True if the output process is succeed\n\t @param[in] format The format version\n\t @param[in] withTriangles Determine whether writing the triangular mesh of the shape\n\t @param[in,out] os The output stream\n\t @param[in] s The shape\n\t @brief Wrtie a shape to a stream\n,\n",
      "output": "#include <catch.hpp>\n#include<testHelper.h>\n#include <topology/TopoShape.hpp>\n#include <occtio/OCCTTool.hpp>\nstatic bool ComparisonFields(const std::string& file1, const std::string& file2, const std::string& fields)\n{\n\tifstream file1Stream(file1);\n\tifstream file2Stream(file2);\n\tif (file1Stream.is_open() == false || file2Stream.is_open() == false)\n\t{\n\t\tfile1Stream.close();\n\t\tfile2Stream.close();\n\t\treturn false;\n\t}\n\tstd::string line1, line2;\n\twhile (std::getline(file1Stream, line1))\n\t{\n\t\tif (line1.find(fields) != std::string::npos) break;\n\t}\n\twhile (std::getline(file2Stream, line2))\n\t{\n\t\tif (line2.find(fields) != std::string::npos) break;\n\t}\n\tfile1Stream.close();\n\tfile2Stream.close();\n\treturn line1 == line2;\n}\nTEST_CASE(\"CASE1:Check occtio read and write normal brep file function with different param \", \"[occtio][OCCTTool][p1][XXX]\") {\n\tAMCAX::TopoShape shape;\n\tbool isReadSuccess = AMCAX::OCCTIO::OCCTTool::Read(shape, INPUT_PATH_PREFIX\"occtio/occtio_read_I_brephaveMesh-case1.brep\");\n\tbool isWriteSuccess1f = AMCAX::OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f1-f-case1.brep\", false, 1);\n\tbool isWriteSuccess2f = AMCAX::OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f2-f-case1.brep\", false, 2);\n\tbool isWriteSuccess3f = AMCAX::OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f3-f-case1.brep\", false, 3);\n\tbool isWriteSuccess1t = AMCAX::OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f1-t-case1.brep\", true, 1);\n\tbool isWriteSuccess2t = AMCAX::OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f2-t-case1.brep\", true, 2);\n\tbool isWriteSuccess3t = AMCAX::OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f3-t-case1.brep\", true, 3);\n\tCHECK(isReadSuccess == true);\n\tCHECK(isWriteSuccess1f == true);\n\tCHECK(isWriteSuccess2f == true);\n\tCHECK(isWriteSuccess3f == true);\n\tCHECK(containsStringInFile(OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f1-f-case1.brep\", \"Triangulations 0\") == true);\n\tCHECK(containsStringInFile(OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f1-f-case1.brep\", \"CASCADE Topology V1, (c) Matra-Datavision\") == true);\n\tCHECK(containsStringInFile(OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f2-f-case1.brep\", \"Triangulations 0\") == true);\n\tCHECK(containsStringInFile(OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f2-f-case1.brep\", \"CASCADE Topology V2, (c) Matra-Datavision\") == true);\n\tCHECK(containsStringInFile(OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f3-f-case1.brep\", \"Triangulations 0\") == true);\n\tCHECK(containsStringInFile(OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f3-f-case1.brep\", \"CASCADE Topology V3, (c) Open Cascade\") == true);\n\tCHECK(isWriteSuccess1t == true);\n\tCHECK(isWriteSuccess2t == true);\n\tCHECK(isWriteSuccess3t == true);\n\tCHECK(containsStringInFile(OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f1-t-case1.brep\", \"Triangulations 0\") == false);\n\tCHECK(containsStringInFile(OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f1-t-case1.brep\", \"CASCADE Topology V1, (c) Matra-Datavision\") == true);\n\tCHECK(containsStringInFile(OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f2-t-case1.brep\", \"Triangulations 0\") == false);\n\tCHECK(containsStringInFile(OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f2-t-case1.brep\", \"CASCADE Topology V2, (c) Matra-Datavision\") == true);\n\tCHECK(containsStringInFile(OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f3-t-case1.brep\", \"Triangulations 0\") == false);\n\tCHECK(containsStringInFile(OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f3-t-case1.brep\", \"CASCADE Topology V3, (c) Open Cascade\") == true);\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static bool Write(const TopoShape& s, std::ostream& os, int format = 3)\t @return True if the output process is succeed\n\t @param[in] format The format version\n\t @param[in,out] os The output stream\n\t @param[in] s The shape\n\t @brief Write a shape to a stream\n,\n",
      "output": "#include <catch.hpp>\n#include<testHelper.h>\n#include <topology/TopoShape.hpp>\n#include <occtio/OCCTTool.hpp>\nstatic bool ComparisonFields(const std::string& file1, const std::string& file2, const std::string& fields)\n{\n\tifstream file1Stream(file1);\n\tifstream file2Stream(file2);\n\tif (file1Stream.is_open() == false || file2Stream.is_open() == false)\n\t{\n\t\tfile1Stream.close();\n\t\tfile2Stream.close();\n\t\treturn false;\n\t}\n\tstd::string line1, line2;\n\twhile (std::getline(file1Stream, line1))\n\t{\n\t\tif (line1.find(fields) != std::string::npos) break;\n\t}\n\twhile (std::getline(file2Stream, line2))\n\t{\n\t\tif (line2.find(fields) != std::string::npos) break;\n\t}\n\tfile1Stream.close();\n\tfile2Stream.close();\n\treturn line1 == line2;\n}\nTEST_CASE(\"CASE1:Check occtio read and write normal brep file function with different param \", \"[occtio][OCCTTool][p1][XXX]\") {\n\tAMCAX::TopoShape shape;\n\tbool isReadSuccess = AMCAX::OCCTIO::OCCTTool::Read(shape, INPUT_PATH_PREFIX\"occtio/occtio_read_I_brephaveMesh-case1.brep\");\n\tbool isWriteSuccess1f = AMCAX::OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f1-f-case1.brep\", false, 1);\n\tbool isWriteSuccess2f = AMCAX::OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f2-f-case1.brep\", false, 2);\n\tbool isWriteSuccess3f = AMCAX::OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f3-f-case1.brep\", false, 3);\n\tbool isWriteSuccess1t = AMCAX::OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f1-t-case1.brep\", true, 1);\n\tbool isWriteSuccess2t = AMCAX::OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f2-t-case1.brep\", true, 2);\n\tbool isWriteSuccess3t = AMCAX::OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f3-t-case1.brep\", true, 3);\n\tCHECK(isReadSuccess == true);\n\tCHECK(isWriteSuccess1f == true);\n\tCHECK(isWriteSuccess2f == true);\n\tCHECK(isWriteSuccess3f == true);\n\tCHECK(containsStringInFile(OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f1-f-case1.brep\", \"Triangulations 0\") == true);\n\tCHECK(containsStringInFile(OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f1-f-case1.brep\", \"CASCADE Topology V1, (c) Matra-Datavision\") == true);\n\tCHECK(containsStringInFile(OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f2-f-case1.brep\", \"Triangulations 0\") == true);\n\tCHECK(containsStringInFile(OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f2-f-case1.brep\", \"CASCADE Topology V2, (c) Matra-Datavision\") == true);\n\tCHECK(containsStringInFile(OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f3-f-case1.brep\", \"Triangulations 0\") == true);\n\tCHECK(containsStringInFile(OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f3-f-case1.brep\", \"CASCADE Topology V3, (c) Open Cascade\") == true);\n\tCHECK(isWriteSuccess1t == true);\n\tCHECK(isWriteSuccess2t == true);\n\tCHECK(isWriteSuccess3t == true);\n\tCHECK(containsStringInFile(OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f1-t-case1.brep\", \"Triangulations 0\") == false);\n\tCHECK(containsStringInFile(OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f1-t-case1.brep\", \"CASCADE Topology V1, (c) Matra-Datavision\") == true);\n\tCHECK(containsStringInFile(OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f2-t-case1.brep\", \"Triangulations 0\") == false);\n\tCHECK(containsStringInFile(OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f2-t-case1.brep\", \"CASCADE Topology V2, (c) Matra-Datavision\") == true);\n\tCHECK(containsStringInFile(OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f3-t-case1.brep\", \"Triangulations 0\") == false);\n\tCHECK(containsStringInFile(OUTPUT_PATH_PREFIX\"occtio_write_O_brephaveMesh-f3-t-case1.brep\", \"CASCADE Topology V3, (c) Open Cascade\") == true);\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static bool Read(TopoShape& s, const std::string& file)\t @return True if the input process is succeed\n\t @param file The input file\n\t @param s The shape\n\t @brief Read a shape from a file\n,\n",
      "output": "#include <catch.hpp>\n#include<testHelper.h>\n#include <topology/TopoShape.hpp>\n#include <occtio/OCCTTool.hpp>\nstatic bool ComparisonFields(const std::string& file1, const std::string& file2, const std::string& fields)\n{\n\tifstream file1Stream(file1);\n\tifstream file2Stream(file2);\n\tif (file1Stream.is_open() == false || file2Stream.is_open() == false)\n\t{\n\t\tfile1Stream.close();\n\t\tfile2Stream.close();\n\t\treturn false;\n\t}\n\tstd::string line1, line2;\n\twhile (std::getline(file1Stream, line1))\n\t{\n\t\tif (line1.find(fields) != std::string::npos) break;\n\t}\n\twhile (std::getline(file2Stream, line2))\n\t{\n\t\tif (line2.find(fields) != std::string::npos) break;\n\t}\n\tfile1Stream.close();\n\tfile2Stream.close();\n\treturn line1 == line2;\n}\nTEST_CASE(\"CASE3:Check occio read not exist file \", \"[occtio][OCCTTool][p2]\") {\n\tAMCAX::TopoShape shape;\n\tSECTION(\"OCCTIO::OCCTTool::Read\") {\n\t\tbool isReadSuccess = AMCAX::OCCTIO::OCCTTool::Read(shape, INPUT_PATH_PREFIX\"NOTEXIST.brep\");\n\t\tCHECK(isReadSuccess == false);\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static TopoShape FixShape(const TopoShape& shape, double prec, double maxTol)\t @return Fixed Shape\n\t @param maxTol The global max tolerance used when the algorithm needs to check the tolerance\n\t @param prec The global precision used when the algorithm needs to check the precision\n\t @param shape Input shape\n\t @brief Try to repair the shape to a valid shape\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <healing/ShapeFixTool.hpp>\n#include <common/Precision.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"bug1: ShapeFixTool \", \"[healing][ShapeFixTool][fixbug]\") {\n\tAMCAX::TopoShape readshape;\n\tAMCAX::OCCTIO::OCCTTool::Read(readshape, INPUT_PATH_PREFIX\"FixShape-Crash.brep\");\n\treadshape = AMCAX::ShapeFixTool::FixShape(readshape, AMCAX::Precision::Confusion(), 1E-1);\n\tAMCAX::OCCTIO::OCCTTool::Write(readshape, OUTPUT_PATH_PREFIX\"ShapeFixTool_O_FixedShape.brep\");\n\tGlobalProperty prop;\n\tBRepGlobalProperty::VolumeProperties(readshape, prop);\n\tCHECK(prop.Mass() == Approx(16486799.3305680156).epsilon(1e-2));\n\tPoint3 vP = prop.CenterOfMass();\n\tCHECK(vP.X() == Approx(-260.8706721039).epsilon(1e-2));\n\tCHECK(vP.Y() == Approx(-154.6717940115).epsilon(1e-2));\n\tCHECK(vP.Z() == Approx(-0.1139512307).epsilon(1e-2));\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API void Perform(const Point2& p, double tol)\t @param tol The tolerance\n\t @param p The uv point\n\t @brief Classify a UV point on face with tolerance\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <hatch/BRepFaceClassifier.hpp>\n#include <common/FrameT.hpp>\n#include <math/CircleT.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeWire.hpp>\n#include <modeling/MakeFace.hpp>\n#include <boolean/BoolBRepFuse.hpp>\n#include <common/IndexSet.hpp>\n#include <topology/TopoExplorerTool.hpp>\nusing namespace AMCAX;\nTopoFace WrenchFace()\n{\n\tFrame3 fm1(Point3(0., 0., 0.), Direction3(0., 0., 1.0));\n\tCircle3 c1 = Circle3(fm1, 2.);\n\tTopoEdge ec1 = MakeEdge(c1);\n\tTopoWire wc1 = MakeWire(ec1);\n\tTopoFace F1 = MakeFace(wc1);\n\tTopoEdge edge1 = MakeEdge(Point3(-4., -1.0, 0.0), Point3(4., -1.0, 0.0));\n\tTopoEdge edge2 = MakeEdge(Point3(4., -1.0, 0.0), Point3(4., 1.0, 0.0));\n\tTopoEdge edge3 = MakeEdge(Point3(4., 1.0, 0.0), Point3(-4., 1.0, 0.0));\n\tTopoEdge edge4 = MakeEdge(Point3(-4., 1.0, 0.0), Point3(-4., -1.0, 0.0));\n\tTopoWire wireR = MakeWire(edge1, edge2, edge3, edge4);\n\tTopoFace F3 = MakeFace(wireR);\n\tBoolBRepFuse fuse(F1, F3);\n\tfuse.Build();\n\tfuse.SimplifyResult();\n\tTopoShape res = fuse.Shape();\n\tIndexSet<TopoShape> resFaces;\n\tTopoExplorerTool::MapShapes(res, ShapeType::Face, resFaces);\n\tstd::cout << resFaces.size() << std::endl;\n\tTopoFace face = static_cast<const TopoFace&>(resFaces[0]);\n\treturn face;\n}\nbool ImpInWrenchFace(const Point2& pt)\n{\n\tbool isFaceIn1 = pt.X() * pt.X() + pt.Y() * pt.Y() < 2 * 2;\n\tbool isFaceIn2 = pt.X() > -4 && pt.X() < 4 && pt.Y() > -1 && pt.Y() < 1;\n\treturn isFaceIn1 || isFaceIn2;\n}\nPoint2 SampleMethodFace()\n{\n\tdouble x = (double)rand() / RAND_MAX * 10 - 5;\n\tdouble y = (double)rand() / RAND_MAX * 5 - 2.0;\n\treturn Point2(x, y);\n}\nTEST_CASE(\"case1: BRepFaceClassifier 3.6.0 added API. \", \"[hatch][BRepFaceClassifier][P1]\") {\n\t\tTopoFace face = WrenchFace();\n\t\tBRepFaceClassifier classify(face);\n\t\tint n = 10000;\n\t\tint inSize = 0, intime = 0, ontime = 0;\n\t\tfor (int i = 0; i < n; ++i)\n\t\t{\n\t\t\tPoint2 pt = SampleMethodFace();\n\t\t\tbool isIn = ImpInWrenchFace(pt);\n\t\t\tclassify.Perform(pt, Precision::Confusion());\n\t\t\tbool isCIn = classify.State() == StateType::In;\n\t\t\tbool isCon = classify.State() == StateType::On;\n\t\t\tif (isIn)\n\t\t\t{\n\t\t\t\tinSize++;\n\t\t\t\tif (isCIn)\n\t\t\t\t{\n\t\t\t\t\tintime++;\n\t\t\t\t}\n\t\t\t\tif (isCon)\n\t\t\t\t{\n\t\t\t\t\tontime++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tstd::cout << inSize << \" \" << intime << \" \" << ontime << std::endl;\n\t\tCHECK(inSize == (intime + ontime));\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API explicit BRepFaceClassifier(const TopoFace& f)\t @param f The input face\n\t @brief Construct from the face to be processed\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <hatch/BRepFaceClassifier.hpp>\n#include <common/FrameT.hpp>\n#include <math/CircleT.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeWire.hpp>\n#include <modeling/MakeFace.hpp>\n#include <boolean/BoolBRepFuse.hpp>\n#include <common/IndexSet.hpp>\n#include <topology/TopoExplorerTool.hpp>\nusing namespace AMCAX;\nTopoFace WrenchFace()\n{\n\tFrame3 fm1(Point3(0., 0., 0.), Direction3(0., 0., 1.0));\n\tCircle3 c1 = Circle3(fm1, 2.);\n\tTopoEdge ec1 = MakeEdge(c1);\n\tTopoWire wc1 = MakeWire(ec1);\n\tTopoFace F1 = MakeFace(wc1);\n\tTopoEdge edge1 = MakeEdge(Point3(-4., -1.0, 0.0), Point3(4., -1.0, 0.0));\n\tTopoEdge edge2 = MakeEdge(Point3(4., -1.0, 0.0), Point3(4., 1.0, 0.0));\n\tTopoEdge edge3 = MakeEdge(Point3(4., 1.0, 0.0), Point3(-4., 1.0, 0.0));\n\tTopoEdge edge4 = MakeEdge(Point3(-4., 1.0, 0.0), Point3(-4., -1.0, 0.0));\n\tTopoWire wireR = MakeWire(edge1, edge2, edge3, edge4);\n\tTopoFace F3 = MakeFace(wireR);\n\tBoolBRepFuse fuse(F1, F3);\n\tfuse.Build();\n\tfuse.SimplifyResult();\n\tTopoShape res = fuse.Shape();\n\tIndexSet<TopoShape> resFaces;\n\tTopoExplorerTool::MapShapes(res, ShapeType::Face, resFaces);\n\tstd::cout << resFaces.size() << std::endl;\n\tTopoFace face = static_cast<const TopoFace&>(resFaces[0]);\n\treturn face;\n}\nbool ImpInWrenchFace(const Point2& pt)\n{\n\tbool isFaceIn1 = pt.X() * pt.X() + pt.Y() * pt.Y() < 2 * 2;\n\tbool isFaceIn2 = pt.X() > -4 && pt.X() < 4 && pt.Y() > -1 && pt.Y() < 1;\n\treturn isFaceIn1 || isFaceIn2;\n}\nPoint2 SampleMethodFace()\n{\n\tdouble x = (double)rand() / RAND_MAX * 10 - 5;\n\tdouble y = (double)rand() / RAND_MAX * 5 - 2.0;\n\treturn Point2(x, y);\n}\nTEST_CASE(\"case1: BRepFaceClassifier 3.6.0 added API. \", \"[hatch][BRepFaceClassifier][P1]\") {\n\t\tTopoFace face = WrenchFace();\n\t\tBRepFaceClassifier classify(face);\n\t\tint n = 10000;\n\t\tint inSize = 0, intime = 0, ontime = 0;\n\t\tfor (int i = 0; i < n; ++i)\n\t\t{\n\t\t\tPoint2 pt = SampleMethodFace();\n\t\t\tbool isIn = ImpInWrenchFace(pt);\n\t\t\tclassify.Perform(pt, Precision::Confusion());\n\t\t\tbool isCIn = classify.State() == StateType::In;\n\t\t\tbool isCon = classify.State() == StateType::On;\n\t\t\tif (isIn)\n\t\t\t{\n\t\t\t\tinSize++;\n\t\t\t\tif (isCIn)\n\t\t\t\t{\n\t\t\t\t\tintime++;\n\t\t\t\t}\n\t\t\t\tif (isCon)\n\t\t\t\t{\n\t\t\t\t\tontime++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tstd::cout << inSize << \" \" << intime << \" \" << ontime << std::endl;\n\t\tCHECK(inSize == (intime + ontime));\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static bool IsSolidBounded(const TopoSolid& s)\t @return True if the solid and the solid is bounded (The infinite point is outside);\n\t @param s The solid\n\t @brief Classify whether the solid is bounded (The infinite point is outside)\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <io/ShapeTool.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <occtio/OCCTTool.hpp>\n#include <topology/TopoShape.hpp>\n#include <topology/TopoSolid.hpp>\n#include <modeling/MakeSolid.hpp>\n#include <modeling/MakeCylinder.hpp>\n#include <boolean/BoolBRepFuse.hpp>\n#include <boolean/BoolBRepCut.hpp>\n#include <topomesh/BRepMeshIncrementalMesh.hpp>\n#include <io/OBJTool.hpp>\n#include <hatch/BRepSolidClassifier.hpp>\n#include <healing/ShapeFixTool.hpp>\nusing namespace AMCAX;\nbool ImpInSolid1(const Point3& pt)\n{\n\tPoint3 pc1(849.32865292949998, -105.60711735517, 528.53715478963011);\n\tCoord3 cs1 = pt.Coord() - pc1.Coord();\n\tbool isSolidIn1 = pt.Y() < 29.654882644830003 && pt.Y() > -105.60711735517 && (cs1.X() * cs1.X() + cs1.Z() * cs1.Z()) < 5.415 * 5.415;\n\tPoint3 pc2(849.32865292763006, 12.992882644829002, 528.53715479109997);\n\tCoord3 cs2 = pt.Coord() - pc2.Coord();\n\tbool isSolidIn2 = pt.Z() < 543.83715479110003 && pt.Z() > 528.53715479109997 && (cs2.X() * cs2.X() + cs2.Y() * cs2.Y()) < 5.415 * 5.415;\n\treturn isSolidIn1 || isSolidIn2;\n}\nPoint3 SampleMethodCircle1()\n{\n\tdouble u = (double)rand() / RAND_MAX * 4 - 0.5;\n\tdouble r = (double)rand() / RAND_MAX * 0.00002 + 5.41499;\n\tdouble x = 849.32865292949998 + r * std::cos(u);\n\tdouble z = 528.53715478963011 + r * std::sin(u);\n\tdouble y = (double)rand() / RAND_MAX * 136 - 106;\n\treturn Point3(x, y, z);\n}\nTEST_CASE(\"bug: BRepClassificationTools::IsSolidBounded  related :\", \"[hatch][BRepClassificationTools][fixbug]\") {\n\tAMCAX::TopoShape readshape;\n\tbool readstatus = AMCAX::OCCTIO::OCCTTool::Read(readshape, INPUT_PATH_PREFIX\"0000-beforeFixShape.brep\");\n\tCHECK(readstatus == true);\n\treadshape = AMCAX::ShapeFixTool::FixShape(readshape, AMCAX::Precision::Confusion(), 1E-1);\n\tAMCAX::TopoSolid readsolid = AMCAX::MakeSolid(AMCAX::TopoCast::Shell(readshape));\n\tCHECK(AMCAX::BRepClassificationTools::IsSolidBounded(readsolid) == true);\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API MakeGeom3Ellipse(const Point3& s1, const Point3& s2, const Point3& center)\t @param center The center point\n\t @param s2 The point on the minor axis\n\t @param s1 The point on the major axis\n\t @brief Construct an ellipse from two points on the major and minor axis, and a center point\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/MakeGeom3Ellipse.hpp>\n#include <common/DirectionT.hpp>\n#include <common/PointT.hpp>\n#include <common/Precision.hpp>\n#include <topology/TopoEdge.hpp>\n#include <topology/TopoWire.hpp>\n#include <topology/TopoFace.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeWire.hpp>\n#include <modeling/MakeFace.hpp>\n#include <modeling/MakePrism.hpp>\n#include <topomesh/BRepMeshIncrementalMesh.hpp>\n#include <topology/TopoExplorerTool.hpp>\n#include <topology/TopoExplorer.hpp>\n#include <topology/TopoCast.hpp>\n#include <topology/TopoTool.hpp>\n#include <math/TriangularMesh.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"bug1: MakeGeom3Ellipse \", \"[geometry][MakeGeom3Ellipse][fixbug]\") {\n\tMakeGeom3Ellipse makeEllipse(Frame3(), 3.0, 1.0);\n\tstd::shared_ptr<Geom3Curve> curve = makeEllipse.Value();\n\tTopoEdge e = MakeEdge(curve);\n\tTopoWire w = MakeWire(e);\n\tTopoFace f = MakeFace(w);\n\tTopoShape s = MakePrism(f, Vector3(0.0, 0.0, 1.0));\n\tBRepMeshIncrementalMesh mesher(s, 0.005, true);\n\tint counttest = 0;\n\tfor (TopoExplorer ex(s, ShapeType::Face); ex.More(); ex.Next())\n\t{\n\t\tconst auto& face = TopoCast::Face(ex.Current());\n\t\tTopoLocation l;\n\t\tauto tri = TopoTool::Triangulation(face, l);\n\t\tCHECK(tri); \n\t\tif (tri)\n\t\t{\n\t\t\tcounttest = counttest + 1;\n\t\t\tif (counttest == 1)\n\t\t\t{\n\t\t\t\tCHECK(tri->NVertices() == 84);\n\t\t\t\tCHECK(tri->NTriangles() == 82);\n\t\t\t}\n\t\t\tif (counttest == 2)\n\t\t\t{\n\t\t\t\tCHECK(tri->NVertices() == 41);\n\t\t\t\tCHECK(tri->NTriangles() == 39);\n\t\t\t}\n\t\t\tif (counttest == 3)\n\t\t\t{\n\t\t\t\tCHECK(tri->NVertices() == 41);\n\t\t\t\tCHECK(tri->NTriangles() == 39);\n\t\t\t}\n\t\t}\n\t}\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API MakeGeom3Ellipse(const Frame3& frame, double majorRadius, double minorRadius)\t @param minorRadius The minor radius\n\t @param majorRadius The major radius\n\t @param frame The local frame\n\t @brief Construct an ellipse from a local frame, a major radius and a minor radius\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/MakeGeom3Ellipse.hpp>\n#include <common/DirectionT.hpp>\n#include <common/PointT.hpp>\n#include <common/Precision.hpp>\n#include <topology/TopoEdge.hpp>\n#include <topology/TopoWire.hpp>\n#include <topology/TopoFace.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeWire.hpp>\n#include <modeling/MakeFace.hpp>\n#include <modeling/MakePrism.hpp>\n#include <topomesh/BRepMeshIncrementalMesh.hpp>\n#include <topology/TopoExplorerTool.hpp>\n#include <topology/TopoExplorer.hpp>\n#include <topology/TopoCast.hpp>\n#include <topology/TopoTool.hpp>\n#include <math/TriangularMesh.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"bug1: MakeGeom3Ellipse \", \"[geometry][MakeGeom3Ellipse][fixbug]\") {\n\tMakeGeom3Ellipse makeEllipse(Frame3(), 3.0, 1.0);\n\tstd::shared_ptr<Geom3Curve> curve = makeEllipse.Value();\n\tTopoEdge e = MakeEdge(curve);\n\tTopoWire w = MakeWire(e);\n\tTopoFace f = MakeFace(w);\n\tTopoShape s = MakePrism(f, Vector3(0.0, 0.0, 1.0));\n\tBRepMeshIncrementalMesh mesher(s, 0.005, true);\n\tint counttest = 0;\n\tfor (TopoExplorer ex(s, ShapeType::Face); ex.More(); ex.Next())\n\t{\n\t\tconst auto& face = TopoCast::Face(ex.Current());\n\t\tTopoLocation l;\n\t\tauto tri = TopoTool::Triangulation(face, l);\n\t\tCHECK(tri); \n\t\tif (tri)\n\t\t{\n\t\t\tcounttest = counttest + 1;\n\t\t\tif (counttest == 1)\n\t\t\t{\n\t\t\t\tCHECK(tri->NVertices() == 84);\n\t\t\t\tCHECK(tri->NTriangles() == 82);\n\t\t\t}\n\t\t\tif (counttest == 2)\n\t\t\t{\n\t\t\t\tCHECK(tri->NVertices() == 41);\n\t\t\t\tCHECK(tri->NTriangles() == 39);\n\t\t\t}\n\t\t\tif (counttest == 3)\n\t\t\t{\n\t\t\t\tCHECK(tri->NVertices() == 41);\n\t\t\t\tCHECK(tri->NTriangles() == 39);\n\t\t\t}\n\t\t}\n\t}\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API MakeArcOfCircle2d(const Point2& p1, const Vector2& v, const Point2& p2)\t @param p2 The end point\n\t @param v The tangent vector at p1\n\t @param p1 The start point\n\t @brief Construct an arc of circle from two points p1, p2 and a tangent vector v at p1\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <common/VectorT.hpp>\n#include <common/PointT.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/MakeArcOfCircle2d.hpp>\n#include <sstream>\nusing namespace AMCAX;\nTEST_CASE(\"bug1: MakeArcOfCircle2d  add 1 cases\", \"[geomAlgo][MakeArcOfCircle2d][fixbug]\") {\n\tstd::stringstream output;\n\tstd::shared_ptr<Geom2TrimmedCurve> c = MakeArcOfCircle2d(Point2(0.0, 1.0), Vector2(1.0, 0.0), Point2(1.0, 0.0));\n\tstd::cout << *c << std::endl;\n\toutput << *c << std::endl;\n\tauto case1 = output.str();\n\tauto expect1 = \"8 4.71239 6.28319\";\n\tauto expect2 = \"2 0 -0 1 0 0 -1 1\";\n\tCHECK(case1.find(expect1) != std::string::npos);\n\tCHECK(case1.find(expect2) != std::string::npos);\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static bool IsPlanarCurve(const std::shared_ptr<Geom3Curve>& c, Plane& plane, double tol = 1.0e-7)\t @return True if the curve is a planar curve\n\t @param tol The tolerance\n\t @param plane The plane found when the curve is planar curve\n\t @param c The input curve\n\t @details If the input curve, such as a line, is on more than one plane, it will return the plane in which any one is located\n\t @brief Check if a 3D curve is a planar curve, and if it is planar, find the plane\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/Geom2BezierCurve.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/MakeArcOfCircle2d.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <modeling/MakeEdge.hpp>\n#include<modeling/MakeEdge2d.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\n#include <geometry/Geom3Circle.hpp>\nusing namespace AMCAX;\nstd::shared_ptr<Geom2BezierCurve> MakeBezierCurve2d()\n{\n\tstd::vector<Point2> poles(4);\n\tpoles[0].SetCoord(1.0, 0.0);\n\tpoles[1].SetCoord(2.0, 1.0);\n\tpoles[2].SetCoord(3.0, -1.0);\n\tpoles[3].SetCoord(4.0, 0.0);\n\treturn std::make_shared<Geom2BezierCurve>(poles);\n}\nstd::shared_ptr<Geom2BSplineCurve> MakeBSplineCurve2d()\n{\n\tstd::vector<Point2> poles(7);\n\tpoles[0].SetCoord(0.5, 0.5);\n\tpoles[1].SetCoord(1.0, 3.0);\n\tpoles[2].SetCoord(3.0, 1.0);\n\tpoles[3].SetCoord(3.8, 2.0);\n\tpoles[4].SetCoord(2.5, 3.5);\n\tpoles[5].SetCoord(1.0, 0.5);\n\tpoles[6].SetCoord(0.3, 2.0);\n\tstd::vector<double> knots = { 0.0, 0.25, 0.5, 0.75, 1.0 };\n\tstd::vector<int> mults = { 4, 1, 1, 1, 4 };\n\treturn std::make_shared<Geom2BSplineCurve>(poles, knots, mults, 3);\n}\nstd::shared_ptr<Geom3BSplineCurve> MakeBSplineCurve3d(int degree, bool rational)\n{\n\tif (degree == 3)\n\t{\n\t\tstd::vector<Point3> poles(7);\n\t\tpoles[0].SetCoord(0.5, 0.5, 0.3);\n\t\tpoles[1].SetCoord(1.0, 3.0, 0.4);\n\t\tpoles[2].SetCoord(3.0, 1.0, 0.1);\n\t\tpoles[3].SetCoord(3.8, 2.0, 0.6);\n\t\tpoles[4].SetCoord(2.5, 3.5, 0.8);\n\t\tpoles[5].SetCoord(1.0, 0.5, 0.9);\n\t\tpoles[6].SetCoord(0.3, 2.0, 0.5);\n\t\tstd::vector<double> weights = { 1.0, 2.0, 3.0, 4.0, 3.0, 2.0, 1.0 };\n\t\tstd::vector<double> knots = { 0.0, 0.25, 0.5, 1.0 };\n\t\tstd::vector<int> mults = { 4, 1, 2, 4 };\n\t\treturn rational ? std::make_shared<Geom3BSplineCurve>(poles, weights, knots, mults, 3)\n\t\t\t: std::make_shared<Geom3BSplineCurve>(poles, knots, mults, 3);\n\t}\n\telse if (degree == 2)\n\t{\n\t\tstd::vector<Point3> poles(6);\n\t\tpoles[0].SetCoord(0.5, 0.5, 0.3);\n\t\tpoles[1].SetCoord(1.0, 3.0, 0.4);\n\t\tpoles[2].SetCoord(3.0, 1.0, 0.1);\n\t\tpoles[3].SetCoord(3.8, 2.0, 0.6);\n\t\tpoles[4].SetCoord(2.5, 3.5, 0.8);\n\t\tpoles[5].SetCoord(1.0, 0.5, 0.9);\n\t\tstd::vector<double> weights = { 1.0, 2.0, 3.0, 4.0, 3.0, 2.0 };\n\t\tstd::vector<double> knots = { 0.0, 0.25, 0.5, 1.0 };\n\t\tstd::vector<int> mults = { 3, 1, 2, 3 };\n\t\treturn rational ? std::make_shared<Geom3BSplineCurve>(poles, weights, knots, mults, 2)\n\t\t\t: std::make_shared<Geom3BSplineCurve>(poles, knots, mults, 2);\n\t}\n\treturn nullptr;\n}\nTEST_CASE(\"case2: IsPlanarCurve dev case \", \"[geometry][IsPlanarCurve][P1]\")\n{\n\tshared_ptr<Geom3BSplineCurve> curve3 = MakeBSplineCurve3d(3,true) ;\n\tPlane plane;\n\tCHECK(GeometryTool::IsPlanarCurve(curve3, plane) == false);\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API explicit GeomAPIIntCurveCurve2(const std::shared_ptr<Geom2Curve>& c1, double tol = 1.0e-6)\t @param tol The tolerance for computing self-intersection\n\t @param c1 The curve\n\t @brief Construct from one curve for finding self-intersections\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <sstream>\n#include <geometry/GeomAPIIntCurveCurve2.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <common/PointT.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"bug1: GeomAPIIntCurveCurve2  add 1 cases\", \"[geometry][GeomAPIIntCurveCurve2][fixbug]\") {\n\tstd::shared_ptr<Geom2BSplineCurve> bs1 = std::make_shared<Geom2BSplineCurve>();\n\tstd::shared_ptr<Geom2BSplineCurve> bs2 = std::make_shared<Geom2BSplineCurve>();\n\tstd::string str1 = \"7 0 0 3 118 116 0.32094859236148043 1.01737460557672743 0.32206087674542322 1.01734745284654182 0.32382938579023346 1.01745552974970388 0.32622057752030481 1.01788932455950976 0.32814024437537276 1.01839643017089987 0.33002743385020250 1.01906060903165452 0.33185490242395432 1.01986927403602690 0.33356030574937923 1.02078382513330879 0.33505523022905437 1.02172426942215600 0.33630356053380972 1.02261635998227951 0.33727879099865676 1.02338700329485177 0.33824387261988464 1.02421002336103761 0.33987143181385676 1.02571995716873454 0.34214827935107528 1.02826048315421636 0.34461603767621785 1.03183954355064644 0.34665036808905569 1.03570920433382874 0.34820760193471290 1.03964073803085988 0.34933771881337422 1.04355887677937265 0.35009685624211401 1.04745091431990089 0.35052967495496640 1.05132419100513896 0.35066857936404372 1.05518894219017056 0.35052557522962369 1.05904245911643380 0.35008366013718967 1.06287636600114777 0.34929841370764381 1.06667869354746858 0.34813822094610908 1.07042299939338448 0.34675750395147792 1.07412664136932645 0.34534310541281921 1.07786690172476352 0.34358161112094421 1.08147777823012681 0.34192774635989071 1.08514486567176727 0.34024883979957521 1.08877932697709046 0.33856258005747963 1.09239630776272234 0.33684922584157972 1.09599070530577980 0.33511401239025801 1.09956576491048708 0.33335775759028152 1.10312101734871382 0.33158157690922768 1.10665621463276231 0.32978475270252700 1.11017051339371275 0.32796684236813672 1.11366345386663435 0.32612725706778090 1.11713471339148707 0.32426602655273468 1.12058421069008607 0.32238317488364737 1.12401188835076016 0.32047891905305792 1.12741748347385329 0.31855350786840358 1.13080068581386772 0.31660697714151498 1.13416123619352938 0.31463922025518198 1.13749923563291944 0.31264987984545162 1.14081514934997053 0.31063848196500760 1.14410959402646872 0.30860463164217128 1.14738321401338195 0.30654793927361806 1.15063653610177630 0.30446802732993405 1.15386990664646771 0.30236451953097970 1.15708359051903131 0.30023708628717172 1.16027763956461594 0.29808538476977109 1.16345202237806822 0.29590934129126883 1.16660648017917135 0.29370889405197392 1.16974079885919968 0.29148391413490155 1.17285470277829651 0.28923416621699150 1.17594813233618023 0.28695938621068906 1.17902112690429606 0.28465933895561080 1.18207371247860404 0.28233386645185193 1.18510589143436862 0.27998289479713001 1.18811761370470093 0.27760632123816548 1.19110879993250829 0.27520390350264767 1.19407947381928281 0.27277523052158237 1.19702979458848002 0.27031974327907626 1.19995999134850062 0.26783696716142708 1.20287004707951173 0.26532688195672521 1.20575953789980805 0.26278972678816304 1.20862781671414088 0.26022529469643624 1.21147474893699236 0.25763217763048496 1.21430150477218790 0.25500825126397131 1.21710994249041904 0.25235292985377017 1.21990005059103868 0.24966926670272568 1.22266796329330352 0.24696150391975732 1.22540882939352413 0.24423004526152650 1.22812190210150329 0.24146125706394184 1.23081996151861128 0.23861784080316129 1.23353765899792966 0.23566141121739081 1.23630795850379083 0.23313267974624646 1.23863075403103817 0.23108077081313610 1.24048682151979905 0.22951564660225790 1.24188808346222479 0.22785243018268259 1.24336238482365724 0.22603998536410663 1.24495322387069107 0.22406854105345719 1.24666425686480453 0.22194392374121000 1.24848570059305053 0.21966929759239204 1.25041206987825992 0.21725182330646176 1.25242961584586521 0.21469769930661789 1.25453321201678158 0.21201305169290471 1.25670455099802481 0.20919423964305814 1.25892740388225111 0.20624946264626334 1.26119206481064094 0.20318480037069683 1.26348679862854585 0.20000837020587425 1.26579929017010295 0.19672786860887337 1.26811801505294564 0.19336384906039994 1.27045063232052602 0.18992974310269095 1.27279484301208434 0.18643645229630731 1.27514361933883413 0.18288284026026952 1.27747988214753017 0.17926432420455884 1.27979154638979287 0.17557650128119320 1.28206361390544510 0.17182058886568480 1.28428512148975549 0.16804984196678602 1.28645557821983747 0.16432856924206579 1.28857394891545374 0.16070988708733733 1.29064090195652370 0.15717518220101778 1.29262871928824441 0.15369583278895632 1.29452720045016001 0.15026398879500619 1.29632707889676935 0.14689767435611573 1.29803910611286755 0.14368667318979397 1.29963940415365520 0.14066793270237543 1.30110806215344477 0.13786588940702740 1.30241800503027294 0.13522308508227587 1.30359724798135068 0.13268958893136670 1.30462396744174369 0.13022457745464813 1.30549794019590903 0.12782549497702861 1.30621459673763263 0.12551678736811231 1.30677267551026310 0.12264034969535306 1.30729452653584777 0.12051776185100731 1.30747541630908004 0.11912669923861925 1.30748468412943986 0.00000000000000000 4 0.00332678777314067 1 0.00530015559541836 1 0.00728182036673812 1 0.00927733380420748 1 0.01129573787307914 1 0.01327102124276026 1 0.01507750651120846 1 0.01659037664031113 1 0.01787187841143642 1 0.01880519345805253 1 0.02039488120903255 1 0.02452963651417061 1 0.02900897063209700 1 0.03340295596517878 1 0.03761684169382203 1 0.04167362563339645 1 0.04561938121714045 1 0.04949884613367380 1 0.05335394957604591 1 0.05721079085185987 1 0.06105670932975029 1 0.06491896046411526 1 0.06884011522460366 1 0.07280266881291077 1 0.07677853454115921 1 0.08082727159450992 1 0.08484703393156430 1 0.08884800850224144 1 0.09283736315162679 1 0.09681928451811667 1 0.10079344442245329 1 0.10475903456581770 1 0.10871533221895527 1 0.11266230101625047 1 0.11659995734938959 1 0.12052830686968952 1 0.12444792190998373 1 0.12835862681996368 1 0.13226049935437312 1 0.13615329767464079 1 0.14003667398886835 1 0.14391115976349200 1 0.14777767334262687 1 0.15163719748113480 1 0.15549084375107922 1 0.15933948557025243 1 0.16318380109489106 1 0.16702443368061037 1 0.17086206197732215 1 0.17469676853931951 1 0.17852903287965541 1 0.18235853795986209 1 0.18618547107174704 1 0.19001029311391093 1 0.19383342115543040 1 0.19765535049879729 1 0.20147647336026475 1 0.20529702393677510 1 0.20911722784810613 1 0.21293746918119616 1 0.21675849605951392 1 0.22058118324198547 1 0.22440637655431431 1 0.22823412013034025 1 0.23206350223258385 1 0.23589437276278422 1 0.23972883230279066 1 0.24357130772232163 1 0.24742464110863499 1 0.25128370603023881 1 0.25513705909052109 1 0.25898297113943686 1 0.26283319300761221 1 0.26673478756179048 1 0.27078270046115210 1 0.27498764230925066 1 0.27703550353465400 1 0.27908314380440813 1 0.28128986356810332 1 0.28370321223532124 1 0.28631785618959721 1 0.28912103899968400 1 0.29209869219406109 1 0.29526001444575162 1 0.29856723628509552 1 0.30202524340776099 1 0.30561830049238314 1 0.30933640124059564 1 0.31316962603536763 1 0.31710368845632919 1 0.32112310784334058 1 0.32522104893482329 1 0.32938444032265624 1 0.33359681084096160 1 0.33784938027078792 1 0.34214253792603233 1 0.34647801531348960 1 0.35084331838884097 1 0.35523312810758656 1 0.35953028089402317 1 0.36368926465670970 1 0.36773529430744634 1 0.37169603595072809 1 0.37557957415417503 1 0.37936041511409840 1 0.38302581855344769 1 0.38634253837102683 1 0.38943124796238249 1 0.39230486518080748 1 0.39502350628500010 1 0.39762992993310575 1 0.40014797436892702 1 0.40253156052235123 1 0.40475213727501114 1 0.40891189273334161 4\";\n\tstd::string str2 = \"7 0 0 3 118 116 0.44698587761425512 1.01737460557672743 0.44586770461012754 1.01734792256404072 0.44408669680926910 1.01745649198371058 0.44167433575859827 1.01788973448550668 0.43973012306214176 1.01839676158274872 0.43781512528503469 1.01906078430998237 0.43595772107855257 1.01986941991017832 0.43422167753434071 1.02078367982801188 0.43270019179331992 1.02172276730688871 0.43143529102668837 1.02260881639260637 0.43047395316133663 1.02337915724656336 0.42956918011417972 1.02417518983407696 0.42818486699350283 1.02596609318184684 0.42535867595845256 1.02808829688484948 0.42284370487027889 1.03193726498772675 0.42029420450207700 1.03578860458891087 0.41779215915839102 1.03971518009696795 0.41524996629274769 1.04360952276868124 0.41268259846706867 1.04748256529635642 0.41009244215779894 1.05134004607881448 0.40748344575385259 1.05519270420095079 0.40486605902395167 1.05904184662506151 0.40221826431976609 1.06286057810161427 0.39954731386633807 1.06664354970287856 0.39685998643058945 1.07039722937908555 0.39415205518567858 1.07412233241535748 0.39142459506816268 1.07782095032413006 0.38867831705369166 1.08149595009323263 0.38591346143208760 1.08514964980580220 0.38313020259072789 1.08878346979564511 0.38032844124366111 1.09239780218286464 0.37750825751929029 1.09599269297900204 0.37466975732311525 1.09956803650327561 0.37181298113969291 1.10312349001628252 0.36893792871143949 1.10665859650325404 0.36604460396156768 1.11017278012274700 0.36313313466979064 1.11366550770546358 0.36020385654578302 1.11713665503127646 0.35725711512561398 1.12058603617284369 0.35429324377611354 1.12401373368655166 0.35131230158758986 1.12741939957610104 0.34831421468687968 1.13080262402140796 0.34529890614255510 1.13416313676223202 0.34226629246633017 1.13750078799254517 0.33921704684458587 1.14081632451049253 0.33615179652790328 1.14411040925898311 0.33307117902797256 1.14738370759211961 0.32997572188237095 1.15063676015840910 0.32686583766548316 1.15386986351118148 0.32374192911050353 1.15708326206532552 0.32060452465855971 1.16027718535470581 0.31745360371300196 1.16345153388182476 0.31428913900094868 1.16660594252951411 0.31111112410899561 1.16974020701489989 0.30791955045097874 1.17285394667146026 0.30471460628308072 1.17594719675858417 0.30149648916692096 1.17901999285247383 0.29826547554743049 1.18207244366664344 0.29502169193428479 1.18510458595828827 0.29176503889034477 1.18811625270052801 0.28849545711393992 1.19110735246150123 0.28521287446926513 1.19407776448826497 0.28191760121088905 1.19702778959143030 0.27860991172799571 1.19995767798350750 0.27529017147185769 1.20286775332443230 0.27195821134041676 1.20575742910935957 0.26861365400632170 1.20862591999664737 0.26525581006410243 1.21147208574228693 0.26188571532285843 1.21429744804454320 0.25850537979441068 1.21710464921168948 0.25511712957007160 1.21989678109210420 0.25171762413613974 1.22266823849310202 0.24830072265899519 1.22540963473078257 0.24486605329372579 1.22811942696225307 0.24141572018592131 1.23080424790172627 0.23796057988059283 1.23349025995382422 0.23455481289528443 1.23625809731511249 0.23178384866187560 1.23861884218329443 0.22958637070091326 1.24049429822100898 0.22792095077852323 1.24183892665189632 0.22633085712869647 1.24330474335321250 0.22482706539293790 1.24489950308425112 0.22341229813088337 1.24661390687506479 0.22209453169097026 1.24843902517094874 0.22087888937927413 1.25036828651214238 0.21977124333451431 1.25238938953827761 0.21877814583739183 1.25449449573067429 0.21790282053379528 1.25666553458695951 0.21714464814126716 1.25889056843647418 0.21650897231276728 1.26115706505645897 0.21599821380382661 1.26345359947659142 0.21561431786668875 1.26576891766763566 0.21535790133274418 1.26809712034575073 0.21523156999800702 1.27043621478677027 0.21523493789335055 1.27278382859372918 0.21536761702246404 1.27513094567987695 0.21562960091705158 1.27746540211106607 0.21601986302685286 1.27977480962963663 0.21653701136757098 1.28204820066314440 0.21718164535537912 1.28428355977126407 0.21795318927362628 1.28647141444648527 0.21885182671844836 1.28860254299760535 0.21987018385314080 1.29066214545958857 0.22100473503305496 1.29264388729952517 0.22225426990375063 1.29454179066819441 0.22361918358992602 1.29635228361390098 0.22510542017288909 1.29807648877092108 0.22668582626421535 1.29967791748795536 0.22833572049978873 1.30113992652563426 0.23002054288496601 1.30245118636949164 0.23175614453859494 1.30361712921158590 0.23353904515484103 1.30463669825309792 0.23536790944712538 1.30550821214031298 0.23723013129137352 1.30622515706156905 0.23909802022459714 1.30677963590280544 0.24158931746901185 1.30731428646199599 0.24348144169383945 1.30748511863814065 0.24475247407226391 1.30748468412943986 0.00000000000000000 4 0.00334434293035562 1 0.00533825930397336 1 0.00734412586267121 1 0.00936623440575543 1 0.01141256205459959 1 0.01341573096600146 1 0.01524709020284723 1 0.01677336277701813 1 0.01804490068923616 1 0.01894326352103789 1 0.02037993823386658 1 0.02480566898074880 1 0.02939205655814846 1 0.03404043378943207 1 0.03869805978018042 1 0.04334980332413108 1 0.04799487443159717 1 0.05263737365801836 1 0.05728913631958347 1 0.06195364423015201 1 0.06660152728460191 1 0.07122956329812886 1 0.07584610283920201 1 0.08045084571229059 1 0.08504550471877484 1 0.08963256787874113 1 0.09421407873103112 1 0.09879117107574811 1 0.10336422781387057 1 0.10793330889559200 1 0.11249839490034602 1 0.11705945929549585 1 0.12161613091223618 1 0.12616821278487000 1 0.13071541215010135 1 0.13525724181627602 1 0.13979405378099050 1 0.14432538686178745 1 0.14885137954117900 1 0.15337193703905613 1 0.15788673904588241 1 0.16239626042792893 1 0.16690070771036525 1 0.17140021344792761 1 0.17589510396468730 1 0.18038552504431565 1 0.18487151865902063 1 0.18935308684053462 1 0.19383026236900400 1 0.19830276789454376 1 0.20277103974370816 1 0.20723457084840083 1 0.21169339151646616 1 0.21614758290681596 1 0.22059709488399620 1 0.22504193032631326 1 0.22948214264998190 1 0.23391784916535033 1 0.23834913245589026 1 0.24277612072013041 1 0.24719890919114179 1 0.25161757662768108 1 0.25603221057958453 1 0.26044282613505232 1 0.26484890217770901 1 0.26925063819864326 1 0.27364813118187725 1 0.27804209715833189 1 0.28243253716855193 1 0.28681951085634216 1 0.29120020890283443 1 0.29557446914500052 1 0.29994411461100146 1 0.30431579875993647 1 0.30870332268475420 1 0.31310853612917888 1 0.31523624508228770 1 0.31737014111002310 1 0.31952856178681960 1 0.32171830465981011 1 0.32394102970905830 1 0.32619217521253946 1 0.32846706602101300 1 0.33077763413829298 1 0.33310205916533187 1 0.33544576479270716 1 0.33779655322040053 1 0.34015052354015518 1 0.34250407705161767 1 0.34485099381932000 1 0.34718783135835085 1 0.34952735554083242 1 0.35187486439618521 1 0.35422711580943594 1 0.35657637606518838 1 0.35891858548088795 1 0.36124990679045155 1 0.36356703547085450 1 0.36589411785453302 1 0.36820554269186456 1 0.37050138589761700 1 0.37278277874756854 1 0.37505181955993466 1 0.37731379776658153 1 0.37958010527703534 1 0.38187591368213569 1 0.38405827564667433 1 0.38618898795548318 1 0.38827607822097537 1 0.39032555279796965 1 0.39234499730597777 1 0.39434796008648582 1 0.39630575790533801 1 0.39818438284552959 1 0.40198436891082029 4\";\n\tstd::istringstream iss1(str1);\n\tstd::istringstream iss2(str2);\n\tiss1 >> *bs1;\n\tiss2 >> *bs2;\n\tGeomAPIIntCurveCurve2 icc(bs1, bs2, 1e-12);\n\tCHECK(icc.NPoints() == 2);\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] AMCAX_API bool Contains(const Point3& point, double tol)\t @return True if the distance between the point and the plane is under the distance tolerance\n\t @param tol The distance tolerance\n\t @param point The point\n\t @brief Determines whether the plane contains a point under a tolerance or not\n,\n",
      "output": "#include \"catch.hpp\"\n#include <testHelper.h>\n#include <math/Plane.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"case1: Plane construction and methods\", \"[math][Plane][p1]\") {\n\tSECTION(\"Contains methods\") {\n        std::function<bool(const Plane&, const Point3&)> pointInPlane = [](const Plane& plane, const Point3& point)->bool {\n            Point3 planePoint = plane.Location();  \n            Vector3 planeVector(planePoint, point);  \n            double a, b, c, d;\n            plane.Coefficients(a, b, c, d);\n            return planeVector.Dot(Vector3(a, b, c)) == 0;\n        };\n        Plane plane(0., 0., 1., -1.); \n        Point3 point(1., 1., 1.);\n        Point3 point2(1., 1., 2.);\n        Line3 line(Point3(1., 1., 1.), Direction3(1., 0., 0.));\n        Line3 line2(Point3(1., 1., 1.), Direction3(0., 0., 1.));  \n        Line3 line3(Point3(1., 1., 0.), Direction3(1., 0., 0.));\n        REQUIRE(plane.Contains(point, 1e-6) == pointInPlane(plane, point));\n        REQUIRE(plane.Contains(point2, 1e-6) == pointInPlane(plane, point2));\n        REQUIRE(plane.Contains(line, 1e-6, 1e-6));\n        REQUIRE_FALSE(plane.Contains(line2, 1e-6, 1e-6 * (M_PI / 180)));\n        REQUIRE_FALSE(plane.Contains(line3, 1e-6, 1e-6 * (M_PI / 180)));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API Plane(double a, double b, double c, double d)\t @param a,b,c,d The coefficients\n\t @brief Construct from an algebraic representation: ax + by + cz + d = 0\n,\n",
      "output": "#include \"catch.hpp\"\n#include <testHelper.h>\n#include <math/Plane.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"case1: Plane construction and methods\", \"[math][Plane][p1]\") {\n\tSECTION(\"Construct from algebraic representation\") {\n        Plane plane(1., 1., 1., -3.);  \n        double a, b, c, d;\n        plane.Coefficients(a, b, c, d);  \n        REQUIRE(a == Approx(1./std::sqrt(3)).margin(0.001));\n        REQUIRE(b == Approx(1. / std::sqrt(3)).margin(0.001));\n        REQUIRE(c == Approx(1. / std::sqrt(3)).margin(0.001));\n        REQUIRE(d == Approx(-3. / std::sqrt(3)).margin(0.001));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API Plane(const Point3& point, const Direction3& dir)\t @param dir The direction\n\t @param point The point\n\t @brief Construct from a point and a direction\n,\n",
      "output": "#include \"catch.hpp\"\n#include <testHelper.h>\n#include <math/Plane.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"case1: Plane construction and methods\", \"[math][Plane][p1]\") {\n\tSECTION(\"Construct from point and direction\") {\n        Point3 point(1., 1., 1.);\n        Direction3 dir(0., 0., 1.);\n        Plane plane(point, dir);  \n        Point3 point2(3., 4., 4.);\n        Direction3 dir2(2., 2., 1.);\n        Plane plane2(point2, dir2);  \n        double a, b, c, d;\n        plane.Coefficients(a, b, c, d);\n        double a2, b2, c2, d2;\n        plane2.Coefficients(a2, b2, c2, d2);\n        REQUIRE(a == Approx(0));\n        REQUIRE(b == Approx(0));\n        REQUIRE(c == Approx(1));\n        REQUIRE(d == Approx(-1));\n        REQUIRE(a2 == Approx(2./3).margin(0.0001));\n        REQUIRE(b2 == Approx(2./3).margin(0.0001));\n        REQUIRE(c2 == Approx(1./3).margin(0.0001));\n        REQUIRE(d2 == Approx(-6));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API explicit Plane(const Frame3& frame)\t @param frame The local frame\n\t @brief Construct from a local frame, XOY plane\n,\n",
      "output": "#include \"catch.hpp\"\n#include <testHelper.h>\n#include <math/Plane.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"case1: Plane construction and methods\", \"[math][Plane][p1]\") {\n\tSECTION(\"Construct from frame\") {\n        Frame3 frame1(Point3(0.0, 0.0, 0.0), Direction3(0.0, 0.0, 1.0));\n        Frame3 frame2(Point3(1.0, 0.0, 0.0), Direction3(2.0, 1.0, 1.0));\n        Plane plane1(frame1);\n        Plane plane2(frame2);  \n        double a1, b1, c1, d1;\n        plane1.Coefficients(a1, b1, c1, d1);\n        double a2, b2, c2, d2;\n        plane2.Coefficients(a2, b2, c2, d2);\n        REQUIRE(a1 == Approx(0));\n        REQUIRE(b1 == Approx(0));\n        REQUIRE(c1 == Approx(1));\n        REQUIRE(d1 == Approx(0));\n        REQUIRE(a2 == Approx(2. / std::sqrt(6)));\n        REQUIRE(b2 == Approx(1. / std::sqrt(6)));\n        REQUIRE(c2 == Approx(1. / std::sqrt(6)));\n        REQUIRE(d2 == Approx(-2. / std::sqrt(6)));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "Plane()\t Default constructor\n,\n",
      "output": "#include \"catch.hpp\"\n#include <testHelper.h>\n#include <math/Plane.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"case1: Plane construction and methods\", \"[math][Plane][p1]\") {\n\tSECTION(\"Default constructor\") {\n        Plane plane;\n        double a, b, c, d;\n        plane.Coefficients(a, b, c, d);\n        REQUIRE(a == Approx(0));\n        REQUIRE(b == Approx(0));\n        REQUIRE(c == Approx(1));\n        REQUIRE(d == Approx(0));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API void Coefficients(double& a, double& b, double& c, double& d)\t @param[out] a,b,c,d The coefficients\n\t @brief Get coefficients of algebraic representation: ax + by + cz + d = 0\n,\n",
      "output": "#include \"catch.hpp\"\n#include <testHelper.h>\n#include <math/Plane.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"case1: Plane construction and methods\", \"[math][Plane][p1]\") {\n\tSECTION(\"Default constructor\") {\n        Plane plane;\n        double a, b, c, d;\n        plane.Coefficients(a, b, c, d);\n        REQUIRE(a == Approx(0));\n        REQUIRE(b == Approx(0));\n        REQUIRE(c == Approx(1));\n        REQUIRE(d == Approx(0));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API Geom3Hyperbola(const Frame3& frame, double major, double minor)\t @param minor The minor radius\n\t @param major The major radius\n\t @param frame The local frame\n\t @brief Construct from a local frame, a major radius and a minor radius\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <math/EllipseT.hpp>\n#include <geometry/Geom3Hyperbola.hpp>\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Test Geom3Hyperbola\", \"[math][Geom3Hyperbola][P1]\")\n{\n\tFrame3 frame;\n\tdouble major = 5.0;\n\tdouble minor = 4.0;\n\tGeom3Hyperbola g3h(frame, major, minor);\n\tSECTION(\"FocalParameter\")\n\t{\n\t\tdouble FP = g3h.FocalParameter();\n\t\tdouble focal = 2 * sqrt(major * major + minor * minor);\n\t\tdouble fp = 2 * minor * minor / focal;;\n\t\tCHECK(FP == fp);\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API explicit Geom3Hyperbola(const Hyperbola3& h)\t @param h The hyperbola\n\t @brief Construct from an hyperbola\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <math/EllipseT.hpp>\n#include <geometry/Geom3Hyperbola.hpp>\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Test Geom3Hyperbola\", \"[math][Geom3Hyperbola][P1]\")\n{\n\tFrame3 frame;\n\tdouble major = 5.0;\n\tdouble minor = 4.0;\n\tGeom3Hyperbola g3h(frame, major, minor);\n\tSECTION(\"SemilatusRectum\")\n\t{\n\t\tdouble SR = g3h.SemilatusRectum();\n\t\tdouble sr = minor * minor / major;\n\t\tCHECK(SR == sr);\n\t}\n}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API Geom3Ellipse(const Frame3& frame, double major, double minor)\t @param minor The minor radius\n\t @param major The major radius\n\t @param frame The local frame\n\t @brief Construct from a local frame, a major radius and a minor radius\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/MakeGeom3Ellipse.hpp>\n#include <common/DirectionT.hpp>\n#include <common/PointT.hpp>\n#include <common/Precision.hpp>\n#include <topology/TopoEdge.hpp>\n#include <topology/TopoWire.hpp>\n#include <topology/TopoFace.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeWire.hpp>\n#include <modeling/MakeFace.hpp>\n#include <modeling/MakePrism.hpp>\n#include <topomesh/BRepMeshIncrementalMesh.hpp>\n#include <topology/TopoExplorerTool.hpp>\n#include <topology/TopoExplorer.hpp>\n#include <topology/TopoCast.hpp>\n#include <topology/TopoTool.hpp>\n#include <math/TriangularMesh.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"bug1: MakeGeom3Ellipse \", \"[geometry][MakeGeom3Ellipse][fixbug]\") {\n\tMakeGeom3Ellipse makeEllipse(Frame3(), 3.0, 1.0);\n\tstd::shared_ptr<Geom3Curve> curve = makeEllipse.Value();\n\tTopoEdge e = MakeEdge(curve);\n\tTopoWire w = MakeWire(e);\n\tTopoFace f = MakeFace(w);\n\tTopoShape s = MakePrism(f, Vector3(0.0, 0.0, 1.0));\n\tBRepMeshIncrementalMesh mesher(s, 0.005, true);\n\tint counttest = 0;\n\tfor (TopoExplorer ex(s, ShapeType::Face); ex.More(); ex.Next())\n\t{\n\t\tconst auto& face = TopoCast::Face(ex.Current());\n\t\tTopoLocation l;\n\t\tauto tri = TopoTool::Triangulation(face, l);\n\t\tCHECK(tri); \n\t\tif (tri)\n\t\t{\n\t\t\tcounttest = counttest + 1;\n\t\t\tif (counttest == 1)\n\t\t\t{\n\t\t\t\tCHECK(tri->NVertices() == 84);\n\t\t\t\tCHECK(tri->NTriangles() == 82);\n\t\t\t}\n\t\t\tif (counttest == 2)\n\t\t\t{\n\t\t\t\tCHECK(tri->NVertices() == 41);\n\t\t\t\tCHECK(tri->NTriangles() == 39);\n\t\t\t}\n\t\t\tif (counttest == 3)\n\t\t\t{\n\t\t\t\tCHECK(tri->NVertices() == 41);\n\t\t\t\tCHECK(tri->NTriangles() == 39);\n\t\t\t}\n\t\t}\n\t}\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API Geom3Ellipse(const Frame3& frame, double major, double minor)\t @param minor The minor radius\n\t @param major The major radius\n\t @param frame The local frame\n\t @brief Construct from a local frame, a major radius and a minor radius\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <common/FrameT.hpp>\n#include <math/EllipseT.hpp>\n#include <geometry/Geom3Ellipse.hpp>\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Test Geom3Ellipse\", \"[math][Geom3Ellipse][P1]\")\n{\n\tFrame3 frame;\n\tdouble major = 5.0;\n\tdouble minor = 4.0;\n\tEllipse3 ellipse(frame, major, minor);\n\tGeom3Ellipse g3e(ellipse);\n\tSECTION(\"FocalParameter\")\n\t{\n\t\tdouble FP = g3e.FocalParameter();\n\t\tdouble focal = 2 * sqrt(major * major - minor * minor);\n\t\tdouble fp = 2 * minor * minor / focal;;\n\t\tCHECK(FP == fp);\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API explicit Geom3Ellipse(const Ellipse3& e)\t @param e The ellipse\n\t @brief Construct from an ellipse\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <common/FrameT.hpp>\n#include <math/EllipseT.hpp>\n#include <geometry/Geom3Ellipse.hpp>\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Test Geom3Ellipse\", \"[math][Geom3Ellipse][P1]\")\n{\n\tFrame3 frame;\n\tdouble major = 5.0;\n\tdouble minor = 4.0;\n\tEllipse3 ellipse(frame, major, minor);\n\tGeom3Ellipse g3e(ellipse);\n\tSECTION(\"FocalParameter\")\n\t{\n\t\tdouble FP = g3e.FocalParameter();\n\t\tdouble focal = 2 * sqrt(major * major - minor * minor);\n\t\tdouble fp = 2 * minor * minor / focal;;\n\t\tCHECK(FP == fp);\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "Geom3Ellipse()\t @brief Default constructor\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <common/FrameT.hpp>\n#include <math/EllipseT.hpp>\n#include <geometry/Geom3Ellipse.hpp>\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Test Geom3Ellipse\", \"[math][Geom3Ellipse][P1]\")\n{\n\tFrame3 frame;\n\tdouble major = 5.0;\n\tdouble minor = 4.0;\n\tEllipse3 ellipse(frame, major, minor);\n\tGeom3Ellipse g3e(ellipse);\n\tSECTION(\"FocalParameter\")\n\t{\n\t\tdouble FP = g3e.FocalParameter();\n\t\tdouble focal = 2 * sqrt(major * major - minor * minor);\n\t\tdouble fp = 2 * minor * minor / focal;;\n\t\tCHECK(FP == fp);\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API Cone& Scale(const Point3& point, double scale)\t @return The reference to self\n\t @param scale The scale value\n\t @param point The scaling center point\n\t @brief Scale the cone by a point\n,\n",
      "output": "#include<iostream>\n#include \"catch.hpp\"\n#include <common/FrameT.hpp>\n#include <modeling/MakeFace.hpp>\n#include <common/AxisT.hpp>\n#include <common/FrameT.hpp>\n#include <common/VectorT.hpp>\n#include <math/Cone.hpp>\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"TestCone\", \"[math][Cone]\")\n{\n\tAMCAX::Frame3 frame;\n\tdouble radius = 5.0;\n\tdouble angle = M_PI / 4;\n\tAMCAX::Cone cone(frame, radius, angle);\n\tAMCAX::Point3 apex = cone.Apex();\n\tCHECK(apex.X() == 0.0);\n\tCHECK(apex.Y() == 0.0);\n\tCHECK(apex.Z() == Approx(-5.0));\n\tAMCAX::Axis3 axis = cone.Axis();\n\tstd::cout << axis.Direction().X() << std::endl;\n\tstd::cout << axis.Direction().Y() << std::endl;\n\tstd::cout << axis.Direction().Z() << std::endl;\n\tCHECK(axis.Direction().X() == 0.0);\n\tCHECK(axis.Direction().Y() == 0.0);\n\tCHECK(axis.Direction().Z() == 1.0);\n\tdouble a1, a2, a3, b1, b2, b3, c1, c2, c3, d;\n\tcone.Coefficients(a1, a2, a3, b1, b2, b3, c1, c2, c3, d);\n\tstd::cout << \"a1: \" << a1 << \", a2: \" << a2 << \", a3: \" << a3 << std::endl;\n\tstd::cout << \"b1: \" << b1 << \", b2: \" << b2 << \", b3: \" << b3 << std::endl;\n\tstd::cout << \"c1: \" << c1 << \", c2: \" << c2 << \", c3: \" << c3 << std::endl;\n\tstd::cout << \"d: \" << d << std::endl;\n\tCHECK(a1 == 1.0);\n\tCHECK(a2 == 1.0);\n\tCHECK(a3 == Approx(-1.0));\n\tCHECK(b1 == 0);\n\tCHECK(b2 == 0);\n\tCHECK(b3 == 0);\n\tCHECK(c1 == 0);\n\tCHECK(c2 == 0);\n\tCHECK(c3 == Approx(-5.0));\n\tCHECK(d == -25.0);\n\tCHECK(cone.IsDirect() == true);\n\tCHECK(cone.Location().X() == 0.0);\n\tCHECK(cone.Location().Y() == 0.0);\n\tCHECK(cone.Location().Z() == 0.0);\n\tAMCAX::PointT<double, 3>mirrorPoint(5.0, 0.0, 0.0);\n\tcone.Mirror(mirrorPoint);\n\tauto mirroredLocation = cone.Location();\n\tCHECK(mirroredLocation.X() == 10.0);\n\tCHECK(mirroredLocation.Y() == 0.0);\n\tCHECK(mirroredLocation.Z() == 0.0);\n\tAMCAX::Frame3 coneFrame = cone.Position();\n\tCHECK(frame.Location().X() == 0.0);\n\tCHECK(frame.Location().Y() == 0.0);\n\tCHECK(frame.Location().Z() == 0.0);\n\tCHECK(cone.Radius() == 5.0);\n\tdouble  scaleCone = 2.0;\n\tcone.Scale(cone.Location(), scaleCone);\n\tCHECK(cone.Radius() == radius * 2.0);\n\tdouble semiCone = cone.SemiAngle();\n\tCHECK(semiCone == Approx(0.785398));\n\tconst  Frame3& position = cone.Position();\n\tstd::cout << position.XAxis() << std::endl;\n\tstd::cout << position.YAxis() << std::endl;\n\tDirection3 zDirection(0.0, 0.0, 1.0);\n\tAMCAX::Point3  centerCone(0.0, 0.0, 0.0);\n\tAxis3 zAxis(centerCone, zDirection);\n\tcone.Rotated(zAxis, angle);\n\tAMCAX::Frame3 coneFrame2 = cone.Position();\n\tCHECK(coneFrame.Location().X() == 10.0);\n\tCHECK(coneFrame.Location().Y() == 0.0);\n\tCHECK(coneFrame.Location().Z() == 0.0);\n\tdouble scale = 2.0;\n\tcone.Scale(centerCone, scale);\n\tCHECK(cone.Radius() == radius * 4.0);\n\tdouble semiAngle = cone.SemiAngle();\n\tstd::cout << semiAngle << std::endl;\n\tCHECK(semiAngle == Approx(0.785398));\n\tVectorT<double, 3> translationVector(5.0, 5.0, 0.0);\n\tcone.Translate(translationVector);\n\tCHECK(cone.Location().X() == 25.0);\n\tCHECK(cone.Location().Y() == 5.0);\n\tCHECK(cone.Location().Z() == 0.0);\n\tauto xAxis = cone.XAxis();\n\tauto yAxis = cone.YAxis();\n\tCHECK(xAxis.Direction().X() == Approx(-1.0));\n\tCHECK(yAxis.Direction().Y() == Approx(-1.0));\n\tAMCAX::Transformation3 tr;\n\ttr.SetTranslation(Vector3(1.0, 2.0, 3.0));\n\tcone.Transform(tr);\n\tAxis3 newXAxis = cone.Position().XAxis();\n\tCHECK(newXAxis.Location().X() == 26.0);\n\tCHECK(newXAxis.Location().Y() == 7.0);\n\tCHECK(newXAxis.Location().Z() == 3.0);\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API Cone(const Frame3& frame, double r, double angle)\t @param angle The semi-angle\n\t @param r The reference radius\n\t @param frame The local frame\n\t @brief Construct from a local frame, a reference radius and a semi-angle\n,\n",
      "output": "#include<iostream>\n#include \"catch.hpp\"\n#include <common/FrameT.hpp>\n#include <modeling/MakeFace.hpp>\n#include <common/AxisT.hpp>\n#include <common/FrameT.hpp>\n#include <common/VectorT.hpp>\n#include <math/Cone.hpp>\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"TestCone\", \"[math][Cone]\")\n{\n\tAMCAX::Frame3 frame;\n\tdouble radius = 5.0;\n\tdouble angle = M_PI / 4;\n\tAMCAX::Cone cone(frame, radius, angle);\n\tAMCAX::Point3 apex = cone.Apex();\n\tCHECK(apex.X() == 0.0);\n\tCHECK(apex.Y() == 0.0);\n\tCHECK(apex.Z() == Approx(-5.0));\n\tAMCAX::Axis3 axis = cone.Axis();\n\tstd::cout << axis.Direction().X() << std::endl;\n\tstd::cout << axis.Direction().Y() << std::endl;\n\tstd::cout << axis.Direction().Z() << std::endl;\n\tCHECK(axis.Direction().X() == 0.0);\n\tCHECK(axis.Direction().Y() == 0.0);\n\tCHECK(axis.Direction().Z() == 1.0);\n\tdouble a1, a2, a3, b1, b2, b3, c1, c2, c3, d;\n\tcone.Coefficients(a1, a2, a3, b1, b2, b3, c1, c2, c3, d);\n\tstd::cout << \"a1: \" << a1 << \", a2: \" << a2 << \", a3: \" << a3 << std::endl;\n\tstd::cout << \"b1: \" << b1 << \", b2: \" << b2 << \", b3: \" << b3 << std::endl;\n\tstd::cout << \"c1: \" << c1 << \", c2: \" << c2 << \", c3: \" << c3 << std::endl;\n\tstd::cout << \"d: \" << d << std::endl;\n\tCHECK(a1 == 1.0);\n\tCHECK(a2 == 1.0);\n\tCHECK(a3 == Approx(-1.0));\n\tCHECK(b1 == 0);\n\tCHECK(b2 == 0);\n\tCHECK(b3 == 0);\n\tCHECK(c1 == 0);\n\tCHECK(c2 == 0);\n\tCHECK(c3 == Approx(-5.0));\n\tCHECK(d == -25.0);\n\tCHECK(cone.IsDirect() == true);\n\tCHECK(cone.Location().X() == 0.0);\n\tCHECK(cone.Location().Y() == 0.0);\n\tCHECK(cone.Location().Z() == 0.0);\n\tAMCAX::PointT<double, 3>mirrorPoint(5.0, 0.0, 0.0);\n\tcone.Mirror(mirrorPoint);\n\tauto mirroredLocation = cone.Location();\n\tCHECK(mirroredLocation.X() == 10.0);\n\tCHECK(mirroredLocation.Y() == 0.0);\n\tCHECK(mirroredLocation.Z() == 0.0);\n\tAMCAX::Frame3 coneFrame = cone.Position();\n\tCHECK(frame.Location().X() == 0.0);\n\tCHECK(frame.Location().Y() == 0.0);\n\tCHECK(frame.Location().Z() == 0.0);\n\tCHECK(cone.Radius() == 5.0);\n\tdouble  scaleCone = 2.0;\n\tcone.Scale(cone.Location(), scaleCone);\n\tCHECK(cone.Radius() == radius * 2.0);\n\tdouble semiCone = cone.SemiAngle();\n\tCHECK(semiCone == Approx(0.785398));\n\tconst  Frame3& position = cone.Position();\n\tstd::cout << position.XAxis() << std::endl;\n\tstd::cout << position.YAxis() << std::endl;\n\tDirection3 zDirection(0.0, 0.0, 1.0);\n\tAMCAX::Point3  centerCone(0.0, 0.0, 0.0);\n\tAxis3 zAxis(centerCone, zDirection);\n\tcone.Rotated(zAxis, angle);\n\tAMCAX::Frame3 coneFrame2 = cone.Position();\n\tCHECK(coneFrame.Location().X() == 10.0);\n\tCHECK(coneFrame.Location().Y() == 0.0);\n\tCHECK(coneFrame.Location().Z() == 0.0);\n\tdouble scale = 2.0;\n\tcone.Scale(centerCone, scale);\n\tCHECK(cone.Radius() == radius * 4.0);\n\tdouble semiAngle = cone.SemiAngle();\n\tstd::cout << semiAngle << std::endl;\n\tCHECK(semiAngle == Approx(0.785398));\n\tVectorT<double, 3> translationVector(5.0, 5.0, 0.0);\n\tcone.Translate(translationVector);\n\tCHECK(cone.Location().X() == 25.0);\n\tCHECK(cone.Location().Y() == 5.0);\n\tCHECK(cone.Location().Z() == 0.0);\n\tauto xAxis = cone.XAxis();\n\tauto yAxis = cone.YAxis();\n\tCHECK(xAxis.Direction().X() == Approx(-1.0));\n\tCHECK(yAxis.Direction().Y() == Approx(-1.0));\n\tAMCAX::Transformation3 tr;\n\ttr.SetTranslation(Vector3(1.0, 2.0, 3.0));\n\tcone.Transform(tr);\n\tAxis3 newXAxis = cone.Position().XAxis();\n\tCHECK(newXAxis.Location().X() == 26.0);\n\tCHECK(newXAxis.Location().Y() == 7.0);\n\tCHECK(newXAxis.Location().Z() == 3.0);\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] AMCAX_API double SemiAngle()\t @return The semi-angle\n\t @brief Get the semi-angle\n,\n",
      "output": "#include<iostream>\n#include \"catch.hpp\"\n#include <common/FrameT.hpp>\n#include <modeling/MakeFace.hpp>\n#include <common/AxisT.hpp>\n#include <common/FrameT.hpp>\n#include <common/VectorT.hpp>\n#include <math/Cone.hpp>\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"TestCone\", \"[math][Cone]\")\n{\n\tAMCAX::Frame3 frame;\n\tdouble radius = 5.0;\n\tdouble angle = M_PI / 4;\n\tAMCAX::Cone cone(frame, radius, angle);\n\tAMCAX::Point3 apex = cone.Apex();\n\tCHECK(apex.X() == 0.0);\n\tCHECK(apex.Y() == 0.0);\n\tCHECK(apex.Z() == Approx(-5.0));\n\tAMCAX::Axis3 axis = cone.Axis();\n\tstd::cout << axis.Direction().X() << std::endl;\n\tstd::cout << axis.Direction().Y() << std::endl;\n\tstd::cout << axis.Direction().Z() << std::endl;\n\tCHECK(axis.Direction().X() == 0.0);\n\tCHECK(axis.Direction().Y() == 0.0);\n\tCHECK(axis.Direction().Z() == 1.0);\n\tdouble a1, a2, a3, b1, b2, b3, c1, c2, c3, d;\n\tcone.Coefficients(a1, a2, a3, b1, b2, b3, c1, c2, c3, d);\n\tstd::cout << \"a1: \" << a1 << \", a2: \" << a2 << \", a3: \" << a3 << std::endl;\n\tstd::cout << \"b1: \" << b1 << \", b2: \" << b2 << \", b3: \" << b3 << std::endl;\n\tstd::cout << \"c1: \" << c1 << \", c2: \" << c2 << \", c3: \" << c3 << std::endl;\n\tstd::cout << \"d: \" << d << std::endl;\n\tCHECK(a1 == 1.0);\n\tCHECK(a2 == 1.0);\n\tCHECK(a3 == Approx(-1.0));\n\tCHECK(b1 == 0);\n\tCHECK(b2 == 0);\n\tCHECK(b3 == 0);\n\tCHECK(c1 == 0);\n\tCHECK(c2 == 0);\n\tCHECK(c3 == Approx(-5.0));\n\tCHECK(d == -25.0);\n\tCHECK(cone.IsDirect() == true);\n\tCHECK(cone.Location().X() == 0.0);\n\tCHECK(cone.Location().Y() == 0.0);\n\tCHECK(cone.Location().Z() == 0.0);\n\tAMCAX::PointT<double, 3>mirrorPoint(5.0, 0.0, 0.0);\n\tcone.Mirror(mirrorPoint);\n\tauto mirroredLocation = cone.Location();\n\tCHECK(mirroredLocation.X() == 10.0);\n\tCHECK(mirroredLocation.Y() == 0.0);\n\tCHECK(mirroredLocation.Z() == 0.0);\n\tAMCAX::Frame3 coneFrame = cone.Position();\n\tCHECK(frame.Location().X() == 0.0);\n\tCHECK(frame.Location().Y() == 0.0);\n\tCHECK(frame.Location().Z() == 0.0);\n\tCHECK(cone.Radius() == 5.0);\n\tdouble  scaleCone = 2.0;\n\tcone.Scale(cone.Location(), scaleCone);\n\tCHECK(cone.Radius() == radius * 2.0);\n\tdouble semiCone = cone.SemiAngle();\n\tCHECK(semiCone == Approx(0.785398));\n\tconst  Frame3& position = cone.Position();\n\tstd::cout << position.XAxis() << std::endl;\n\tstd::cout << position.YAxis() << std::endl;\n\tDirection3 zDirection(0.0, 0.0, 1.0);\n\tAMCAX::Point3  centerCone(0.0, 0.0, 0.0);\n\tAxis3 zAxis(centerCone, zDirection);\n\tcone.Rotated(zAxis, angle);\n\tAMCAX::Frame3 coneFrame2 = cone.Position();\n\tCHECK(coneFrame.Location().X() == 10.0);\n\tCHECK(coneFrame.Location().Y() == 0.0);\n\tCHECK(coneFrame.Location().Z() == 0.0);\n\tdouble scale = 2.0;\n\tcone.Scale(centerCone, scale);\n\tCHECK(cone.Radius() == radius * 4.0);\n\tdouble semiAngle = cone.SemiAngle();\n\tstd::cout << semiAngle << std::endl;\n\tCHECK(semiAngle == Approx(0.785398));\n\tVectorT<double, 3> translationVector(5.0, 5.0, 0.0);\n\tcone.Translate(translationVector);\n\tCHECK(cone.Location().X() == 25.0);\n\tCHECK(cone.Location().Y() == 5.0);\n\tCHECK(cone.Location().Z() == 0.0);\n\tauto xAxis = cone.XAxis();\n\tauto yAxis = cone.YAxis();\n\tCHECK(xAxis.Direction().X() == Approx(-1.0));\n\tCHECK(yAxis.Direction().Y() == Approx(-1.0));\n\tAMCAX::Transformation3 tr;\n\ttr.SetTranslation(Vector3(1.0, 2.0, 3.0));\n\tcone.Transform(tr);\n\tAxis3 newXAxis = cone.Position().XAxis();\n\tCHECK(newXAxis.Location().X() == 26.0);\n\tCHECK(newXAxis.Location().Y() == 7.0);\n\tCHECK(newXAxis.Location().Z() == 3.0);\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] AMCAX_API Point3 Apex()\t @return The apex point\n\t @brief Get the apex of the cone\n,\n",
      "output": "#include<iostream>\n#include \"catch.hpp\"\n#include <common/FrameT.hpp>\n#include <modeling/MakeFace.hpp>\n#include <common/AxisT.hpp>\n#include <common/FrameT.hpp>\n#include <common/VectorT.hpp>\n#include <math/Cone.hpp>\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"TestCone\", \"[math][Cone]\")\n{\n\tAMCAX::Frame3 frame;\n\tdouble radius = 5.0;\n\tdouble angle = M_PI / 4;\n\tAMCAX::Cone cone(frame, radius, angle);\n\tAMCAX::Point3 apex = cone.Apex();\n\tCHECK(apex.X() == 0.0);\n\tCHECK(apex.Y() == 0.0);\n\tCHECK(apex.Z() == Approx(-5.0));\n\tAMCAX::Axis3 axis = cone.Axis();\n\tstd::cout << axis.Direction().X() << std::endl;\n\tstd::cout << axis.Direction().Y() << std::endl;\n\tstd::cout << axis.Direction().Z() << std::endl;\n\tCHECK(axis.Direction().X() == 0.0);\n\tCHECK(axis.Direction().Y() == 0.0);\n\tCHECK(axis.Direction().Z() == 1.0);\n\tdouble a1, a2, a3, b1, b2, b3, c1, c2, c3, d;\n\tcone.Coefficients(a1, a2, a3, b1, b2, b3, c1, c2, c3, d);\n\tstd::cout << \"a1: \" << a1 << \", a2: \" << a2 << \", a3: \" << a3 << std::endl;\n\tstd::cout << \"b1: \" << b1 << \", b2: \" << b2 << \", b3: \" << b3 << std::endl;\n\tstd::cout << \"c1: \" << c1 << \", c2: \" << c2 << \", c3: \" << c3 << std::endl;\n\tstd::cout << \"d: \" << d << std::endl;\n\tCHECK(a1 == 1.0);\n\tCHECK(a2 == 1.0);\n\tCHECK(a3 == Approx(-1.0));\n\tCHECK(b1 == 0);\n\tCHECK(b2 == 0);\n\tCHECK(b3 == 0);\n\tCHECK(c1 == 0);\n\tCHECK(c2 == 0);\n\tCHECK(c3 == Approx(-5.0));\n\tCHECK(d == -25.0);\n\tCHECK(cone.IsDirect() == true);\n\tCHECK(cone.Location().X() == 0.0);\n\tCHECK(cone.Location().Y() == 0.0);\n\tCHECK(cone.Location().Z() == 0.0);\n\tAMCAX::PointT<double, 3>mirrorPoint(5.0, 0.0, 0.0);\n\tcone.Mirror(mirrorPoint);\n\tauto mirroredLocation = cone.Location();\n\tCHECK(mirroredLocation.X() == 10.0);\n\tCHECK(mirroredLocation.Y() == 0.0);\n\tCHECK(mirroredLocation.Z() == 0.0);\n\tAMCAX::Frame3 coneFrame = cone.Position();\n\tCHECK(frame.Location().X() == 0.0);\n\tCHECK(frame.Location().Y() == 0.0);\n\tCHECK(frame.Location().Z() == 0.0);\n\tCHECK(cone.Radius() == 5.0);\n\tdouble  scaleCone = 2.0;\n\tcone.Scale(cone.Location(), scaleCone);\n\tCHECK(cone.Radius() == radius * 2.0);\n\tdouble semiCone = cone.SemiAngle();\n\tCHECK(semiCone == Approx(0.785398));\n\tconst  Frame3& position = cone.Position();\n\tstd::cout << position.XAxis() << std::endl;\n\tstd::cout << position.YAxis() << std::endl;\n\tDirection3 zDirection(0.0, 0.0, 1.0);\n\tAMCAX::Point3  centerCone(0.0, 0.0, 0.0);\n\tAxis3 zAxis(centerCone, zDirection);\n\tcone.Rotated(zAxis, angle);\n\tAMCAX::Frame3 coneFrame2 = cone.Position();\n\tCHECK(coneFrame.Location().X() == 10.0);\n\tCHECK(coneFrame.Location().Y() == 0.0);\n\tCHECK(coneFrame.Location().Z() == 0.0);\n\tdouble scale = 2.0;\n\tcone.Scale(centerCone, scale);\n\tCHECK(cone.Radius() == radius * 4.0);\n\tdouble semiAngle = cone.SemiAngle();\n\tstd::cout << semiAngle << std::endl;\n\tCHECK(semiAngle == Approx(0.785398));\n\tVectorT<double, 3> translationVector(5.0, 5.0, 0.0);\n\tcone.Translate(translationVector);\n\tCHECK(cone.Location().X() == 25.0);\n\tCHECK(cone.Location().Y() == 5.0);\n\tCHECK(cone.Location().Z() == 0.0);\n\tauto xAxis = cone.XAxis();\n\tauto yAxis = cone.YAxis();\n\tCHECK(xAxis.Direction().X() == Approx(-1.0));\n\tCHECK(yAxis.Direction().Y() == Approx(-1.0));\n\tAMCAX::Transformation3 tr;\n\ttr.SetTranslation(Vector3(1.0, 2.0, 3.0));\n\tcone.Transform(tr);\n\tAxis3 newXAxis = cone.Position().XAxis();\n\tCHECK(newXAxis.Location().X() == 26.0);\n\tCHECK(newXAxis.Location().Y() == 7.0);\n\tCHECK(newXAxis.Location().Z() == 3.0);\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API Geom3ConicalSurface(const Frame3& frame, double r, double angle)\t @param angle The semi-angle\n\t @param r The reference radius\n\t @param frame The local frame\n\t @brief Construct from a local frame, a reference radius and a semi-angle\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <common/PointT.hpp>\n#include <math/CurveCalculation.hpp>\n#include <geometry/Geom3ConicalSurface.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"case1: Geom3ConicalSurface::CircleD1 1/4 \", \"[math][Geom3ConicalSurface][P1][CircleD1]\") {\n\tDirection3 initialDir(0.0, 0.0, 1.0); \n\tFrame3 defaultFrame3(Point3(1.0, 1.0, 0.0), initialDir);\n\tAMCAX::Geom3ConicalSurface suface(defaultFrame3, 5.0, 1);\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API void InsertUKnot(double u, int m, double parametricTolerance, bool add = true)\t @param add If true, the multiplicity is an incremental value; if false, the multiplicity is a final value\n\t @param parametricTolerance The tolerance of parameters\n\t @param m The multiplicity of the knot to be inserted\n\t @param u The knot to be inserted\n\t @brief Insert a u knot\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <modeling/MakeFace.hpp>\n#include <geometry/Geom3BSplineSurface.hpp>\n#include <topology/TopoFace.hpp>\n#include <topology/TopoTool.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"bug1: Geom3BSplineSurface::InsertUKnot() \", \"[geometry][Geom3BSplineSurface][fixbug]\") {\n\tTopoFace face;\n\tOCCTIO::OCCTTool::Read(face, INPUT_PATH_PREFIX\"face.brep\");\n\tauto surf = TopoTool::Surface(face);\n\tauto bsp = std::dynamic_pointer_cast<Geom3BSplineSurface>(surf);\n\tbsp->InsertUKnot(0.23, 1, 0.0, true);\n\tbool bWriteresult = OCCTIO::OCCTTool::Write(face, OUTPUT_PATH_PREFIX\"result.brep\");\n\tCHECK(bWriteresult == true);\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API Geom3BSplineSurface(const Array2<Point3>& pts, const Array2<double>& weights, const std::vector<double>& uKnots, const std::vector<double>& vKnots, const std::vector<int>& uMults, const std::vector<int>& vMults, int uDegree, int vDegree, bool uPeriodic = false, bool vPeriodic = false)\t @param vPeriodic Set whether the surface is periodic along the v direction\n\t @param uPeriodic Set whether the surface is periodic along the u direction\n\t @param vDegree The v degree\n\t @param uDegree The u degree\n\t @param vMults The v multiplicities\n\t @param uMults The u multiplicities\n\t @param vKnots The v knots\n\t @param uKnots The u knots\n\t @param weights The weights\n\t @param pts The poles\n\t @brief Construct a rational B spline surface from poles, knots and multiplicities\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <modeling/MakeFace.hpp>\n#include <geometry/Geom3BSplineSurface.hpp>\n#include <topology/TopoFace.hpp>\n#include <topology/TopoTool.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"case1: Geom3BSplineSurface::Geom3BSplineSurface() \", \"[geometry][Geom3BSplineSurface][p1]\") {\n\tArray2<Point3> poles(5, 4);\n\tpoles(0, 0).SetCoord(0.0, 0.0, 0.0);\n\tpoles(0, 1).SetCoord(0.0, 1.1, 2.0);\n\tpoles(0, 2).SetCoord(0.0, 2.3, 1.0);\n\tpoles(0, 3).SetCoord(0.0, 3.1, 1.5);\n\tpoles(1, 0).SetCoord(1.1, 0.1, 2.0);\n\tpoles(1, 1).SetCoord(1.2, 1.0, 0.0);\n\tpoles(1, 2).SetCoord(1.3, 2.1, -1.0);\n\tpoles(1, 3).SetCoord(1.23, 3.04, 1.32);\n\tpoles(2, 0).SetCoord(2.3, 0.1, -2.0);\n\tpoles(2, 1).SetCoord(2.1, 1.4, 2.0);\n\tpoles(2, 2).SetCoord(2.2, 2.1, 1.0);\n\tpoles(2, 3).SetCoord(2.23, 3.22, 1.26);\n\tpoles(3, 0).SetCoord(3.13, 0.2, 0.0);\n\tpoles(3, 1).SetCoord(3.12, 1.1, 0.0);\n\tpoles(3, 2).SetCoord(3.21, 2.1, 1.0);\n\tpoles(3, 3).SetCoord(3.33, 3.21, -1.2);\n\tpoles(4, 0).SetCoord(4.9, 4.93, 0.31);\n\tpoles(4, 1).SetCoord(5.3, 4.73, 0.33);\n\tpoles(4, 2).SetCoord(5.1, 4.43, -1.31);\n\tpoles(4, 3).SetCoord(9.2, 4.65, 3.31);\n\tstd::vector<double> uknots = { 0.0, 0.5, 1.0 };\n\tstd::vector<int> umults = { 4, 1, 4 };\n\tstd::vector<double> vknots = { 0.0, 0.5, 1.0 };\n\tstd::vector<int> vmults = { 3, 1, 3 };\n\tstd::shared_ptr<Geom3BSplineSurface> s = std::make_shared<Geom3BSplineSurface>(poles, uknots, vknots, umults, vmults, 3, 2);\n\tTopoFace face = MakeFace(s,0.001);\n\tbool bWriteresult = OCCTIO::OCCTTool::Write(face, OUTPUT_PATH_PREFIX\"Geom3BSplineSurface_case1.brep\");\n\tCHECK(bWriteresult == true);\n\tAMCAX::GlobalProperty prop;\n\tAMCAX::BRepGlobalProperty::SurfaceProperties(face, prop);\n\tCHECK(prop.Mass() == Approx( 21.3633));\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API Geom3BSplineSurface(const Array2<Point3>& pts, const std::vector<double>& uKnots, const std::vector<double>& vKnots, const std::vector<int>& uMults, const std::vector<int>& vMults, int uDegree, int vDegree, bool uPeriodic = false, bool vPeriodic = false)\t @param vPeriodic Set whether the surface is periodic along the v direction\n\t @param uPeriodic Set whether the surface is periodic along the u direction\n\t @param vDegree The v degree\n\t @param uDegree The u degree\n\t @param vMults The v multiplicities\n\t @param uMults The u multiplicities\n\t @param vKnots The v knots\n\t @param uKnots The u knots\n\t @param pts The poles\n\t @brief Construct a B spline surface from poles, knots and multiplicities\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <modeling/MakeFace.hpp>\n#include <geometry/Geom3BSplineSurface.hpp>\n#include <topology/TopoFace.hpp>\n#include <topology/TopoTool.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"case1: Geom3BSplineSurface::Geom3BSplineSurface() \", \"[geometry][Geom3BSplineSurface][p1]\") {\n\tArray2<Point3> poles(5, 4);\n\tpoles(0, 0).SetCoord(0.0, 0.0, 0.0);\n\tpoles(0, 1).SetCoord(0.0, 1.1, 2.0);\n\tpoles(0, 2).SetCoord(0.0, 2.3, 1.0);\n\tpoles(0, 3).SetCoord(0.0, 3.1, 1.5);\n\tpoles(1, 0).SetCoord(1.1, 0.1, 2.0);\n\tpoles(1, 1).SetCoord(1.2, 1.0, 0.0);\n\tpoles(1, 2).SetCoord(1.3, 2.1, -1.0);\n\tpoles(1, 3).SetCoord(1.23, 3.04, 1.32);\n\tpoles(2, 0).SetCoord(2.3, 0.1, -2.0);\n\tpoles(2, 1).SetCoord(2.1, 1.4, 2.0);\n\tpoles(2, 2).SetCoord(2.2, 2.1, 1.0);\n\tpoles(2, 3).SetCoord(2.23, 3.22, 1.26);\n\tpoles(3, 0).SetCoord(3.13, 0.2, 0.0);\n\tpoles(3, 1).SetCoord(3.12, 1.1, 0.0);\n\tpoles(3, 2).SetCoord(3.21, 2.1, 1.0);\n\tpoles(3, 3).SetCoord(3.33, 3.21, -1.2);\n\tpoles(4, 0).SetCoord(4.9, 4.93, 0.31);\n\tpoles(4, 1).SetCoord(5.3, 4.73, 0.33);\n\tpoles(4, 2).SetCoord(5.1, 4.43, -1.31);\n\tpoles(4, 3).SetCoord(9.2, 4.65, 3.31);\n\tstd::vector<double> uknots = { 0.0, 0.5, 1.0 };\n\tstd::vector<int> umults = { 4, 1, 4 };\n\tstd::vector<double> vknots = { 0.0, 0.5, 1.0 };\n\tstd::vector<int> vmults = { 3, 1, 3 };\n\tstd::shared_ptr<Geom3BSplineSurface> s = std::make_shared<Geom3BSplineSurface>(poles, uknots, vknots, umults, vmults, 3, 2);\n\tTopoFace face = MakeFace(s,0.001);\n\tbool bWriteresult = OCCTIO::OCCTTool::Write(face, OUTPUT_PATH_PREFIX\"Geom3BSplineSurface_case1.brep\");\n\tCHECK(bWriteresult == true);\n\tAMCAX::GlobalProperty prop;\n\tAMCAX::BRepGlobalProperty::SurfaceProperties(face, prop);\n\tCHECK(prop.Mass() == Approx( 21.3633));\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API Geom3BSplineSurface()\t @details A default surface is a unit square\n\t @brief Default constructor\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <modeling/MakeFace.hpp>\n#include <geometry/Geom3BSplineSurface.hpp>\n#include <topology/TopoFace.hpp>\n#include <topology/TopoTool.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"case1: Geom3BSplineSurface::Geom3BSplineSurface() \", \"[geometry][Geom3BSplineSurface][p1]\") {\n\tArray2<Point3> poles(5, 4);\n\tpoles(0, 0).SetCoord(0.0, 0.0, 0.0);\n\tpoles(0, 1).SetCoord(0.0, 1.1, 2.0);\n\tpoles(0, 2).SetCoord(0.0, 2.3, 1.0);\n\tpoles(0, 3).SetCoord(0.0, 3.1, 1.5);\n\tpoles(1, 0).SetCoord(1.1, 0.1, 2.0);\n\tpoles(1, 1).SetCoord(1.2, 1.0, 0.0);\n\tpoles(1, 2).SetCoord(1.3, 2.1, -1.0);\n\tpoles(1, 3).SetCoord(1.23, 3.04, 1.32);\n\tpoles(2, 0).SetCoord(2.3, 0.1, -2.0);\n\tpoles(2, 1).SetCoord(2.1, 1.4, 2.0);\n\tpoles(2, 2).SetCoord(2.2, 2.1, 1.0);\n\tpoles(2, 3).SetCoord(2.23, 3.22, 1.26);\n\tpoles(3, 0).SetCoord(3.13, 0.2, 0.0);\n\tpoles(3, 1).SetCoord(3.12, 1.1, 0.0);\n\tpoles(3, 2).SetCoord(3.21, 2.1, 1.0);\n\tpoles(3, 3).SetCoord(3.33, 3.21, -1.2);\n\tpoles(4, 0).SetCoord(4.9, 4.93, 0.31);\n\tpoles(4, 1).SetCoord(5.3, 4.73, 0.33);\n\tpoles(4, 2).SetCoord(5.1, 4.43, -1.31);\n\tpoles(4, 3).SetCoord(9.2, 4.65, 3.31);\n\tstd::vector<double> uknots = { 0.0, 0.5, 1.0 };\n\tstd::vector<int> umults = { 4, 1, 4 };\n\tstd::vector<double> vknots = { 0.0, 0.5, 1.0 };\n\tstd::vector<int> vmults = { 3, 1, 3 };\n\tstd::shared_ptr<Geom3BSplineSurface> s = std::make_shared<Geom3BSplineSurface>(poles, uknots, vknots, umults, vmults, 3, 2);\n\tTopoFace face = MakeFace(s,0.001);\n\tbool bWriteresult = OCCTIO::OCCTTool::Write(face, OUTPUT_PATH_PREFIX\"Geom3BSplineSurface_case1.brep\");\n\tCHECK(bWriteresult == true);\n\tAMCAX::GlobalProperty prop;\n\tAMCAX::BRepGlobalProperty::SurfaceProperties(face, prop);\n\tCHECK(prop.Mass() == Approx( 21.3633));\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API Geom3BSplineCurve(const std::vector<Point3>& pts, const std::vector<double>& weights, const std::vector<double>& knots, const std::vector<int>& multiplicities, int degree, bool isPeriodic = false, bool checkRational = true)\t @param checkRational To check whether the weights are rational\n\t @param isPeriodic Set the curve is periodic or not\n\t @param degree The degree of curve\n\t @param multiplicities The multiplicities\n\t @param knots The knots\n\t @param weights The weights\n\t @param pts The points\n\t @brief Construct a rational B spline curve from point, weights, knots and multiplicities with a given degree\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/Geom3BSplineCurve.hpp>\n#include <geometry/Geom3BSplineSurface.hpp>\n#include <topology/TopoFace.hpp>\n#include <topology/TopoTool.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"bug1: Geom3BSplineCurve \", \"[geometry][Geom3BSplineCurve][fixbug]\") {\n\tstd::stringstream output1,output2;\n\tstd::vector<Point3> poles{ Point3(0.0, 0.0, 0.0), Point3(0.0, 1.0, 0.0), Point3(0.0, 2.0, 0.0), Point3(0.0, 3.0, 0.0), Point3(0.0, 4.0, 0.0) };\n\tstd::vector<double> knots{ 0.0, 1.0, 2.0, 3.0 };\n\tstd::vector<int> mults{ 2, 2, 2, 2 };\n\tauto bc = std::make_shared<Geom3BSplineCurve>(poles, knots, mults, 2);\n\tdouble last = bc->LastParameter();\n\tstd::cout << bc->Value(last) << '\n';\n\tstd::cout << bc->DN(last, 0) << '\n';\n\toutput1 << bc->Value(last) << '\n';\n\toutput2 << bc->DN(last, 0) << '\n';\n\tauto case1 = output1.str();\n\tauto case2 = output2.str();\n\tauto expectValue = \"0 3 0\";\n\tauto expectDN = \"0 3 0\";\n\tCHECK(case1.find(expectValue) != std::string::npos);\n\tCHECK(case2.find(expectDN) != std::string::npos);\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API Geom2Parabola(const Axis2& directrix, const Point2& focus, bool isRight = true)\t @param isRight Is the local frame right-handed\n\t @param focus The focus\n\t @param directrix The directrix\n\t @brief Construct from a directrix and a focus\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <geometry/Geom2Parabola.hpp>\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Test Geom2Parabola\", \"[math][Geom2Parabola][P1]\")\n{\n\tAxis2 axis;\n\tdouble focal = 5.0;\n\tbool isRight = true;\n\tGeom2Parabola g2p(axis, focal, isRight);\n\tSECTION(\"FocalParameter\")\n\t{\n\t\tdouble FP = g2p.FocalParameter();\n\t\tdouble fp = 2 * focal;\n\t\tCHECK(FP == fp);\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API Geom2Parabola(const Frame2& frame, double focal)\t @param focal The focal length\n\t @param frame The local frame\n\t @brief Construct from a local frame and a focal length\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <geometry/Geom2Parabola.hpp>\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Test Geom2Parabola\", \"[math][Geom2Parabola][P1]\")\n{\n\tAxis2 axis;\n\tdouble focal = 5.0;\n\tbool isRight = true;\n\tGeom2Parabola g2p(axis, focal, isRight);\n\tSECTION(\"FocalParameter\")\n\t{\n\t\tdouble FP = g2p.FocalParameter();\n\t\tdouble fp = 2 * focal;\n\t\tCHECK(FP == fp);\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API Geom2Parabola(const Axis2& axis, double focal, bool isRight = true)\t @param isRight Is the local frame right-handed\n\t @param focal The focal length\n\t @param axis The axis\n\t @brief Construct from an axis and a focal length\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <geometry/Geom2Parabola.hpp>\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Test Geom2Parabola\", \"[math][Geom2Parabola][P1]\")\n{\n\tAxis2 axis;\n\tdouble focal = 5.0;\n\tbool isRight = true;\n\tGeom2Parabola g2p(axis, focal, isRight);\n\tSECTION(\"FocalParameter\")\n\t{\n\t\tdouble FP = g2p.FocalParameter();\n\t\tdouble fp = 2 * focal;\n\t\tCHECK(FP == fp);\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "Geom2Parabola()\t @brief Default constructor\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <geometry/Geom2Parabola.hpp>\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Test Geom2Parabola\", \"[math][Geom2Parabola][P1]\")\n{\n\tAxis2 axis;\n\tdouble focal = 5.0;\n\tbool isRight = true;\n\tGeom2Parabola g2p(axis, focal, isRight);\n\tSECTION(\"SemilatusRectum\")\n\t{\n\t\tdouble SR = g2p.SemilatusRectum();\n\t\tdouble sr = 2 * focal;\n\t\tCHECK(SR == sr);\n\t}\n}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API Geom2Hyperbola(const Frame2& frame, double major, double minor)\t @param minor The minor radius\n\t @param major The major radius\n\t @param frame The local frame\n\t @brief Construct from a local frame, a major radius and a minor radius\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <math/EllipseT.hpp>\n#include <geometry/Geom2Hyperbola.hpp>\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Test Geom2Hyperbola\", \"[math][Geom2Hyperbola][P1]\")\n{\n\tAxis2 axis;\n\tdouble major = 5.0;\n\tdouble minor = 4.0;\n\tbool isRight = true;\n\tGeom2Hyperbola g2h(axis, major, minor, isRight);\n\tSECTION(\"FocalParameter\")\n\t{\n\t\tdouble FP = g2h.FocalParameter();\n\t\tdouble focal = 2 * sqrt(major * major + minor * minor);\n\t\tdouble fp = 2 * minor * minor / focal;;\n\t\tCHECK(FP == fp);\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API Geom2Hyperbola(const Axis2& axis, double major, double minor, bool isRight = true)\t @param isRight Is the local frame right-handed\n\t @param minor The minor radius\n\t @param major The major radius\n\t @param axis The axis\n\t @brief Construct from an axis, a major radius and a minor radius\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <math/EllipseT.hpp>\n#include <geometry/Geom2Hyperbola.hpp>\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Test Geom2Hyperbola\", \"[math][Geom2Hyperbola][P1]\")\n{\n\tAxis2 axis;\n\tdouble major = 5.0;\n\tdouble minor = 4.0;\n\tbool isRight = true;\n\tGeom2Hyperbola g2h(axis, major, minor, isRight);\n\tSECTION(\"FocalParameter\")\n\t{\n\t\tdouble FP = g2h.FocalParameter();\n\t\tdouble focal = 2 * sqrt(major * major + minor * minor);\n\t\tdouble fp = 2 * minor * minor / focal;;\n\t\tCHECK(FP == fp);\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API Geom3Parabola(const Axis3& directrix, const Point3& focus)\t @param focus The focus\n\t @param directrix The directrix\n\t @brief Construct from a directrix and a focus\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <geometry/Geom3Parabola.hpp>\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Test Geom3Parabola\", \"[math][Geom3Parabola][P1]\")\n{\n\tFrame3 frame;\n\tdouble focal = 5.0;\n\tGeom3Parabola g3p(frame, focal);\n\tSECTION(\"FocalParameter\")\n\t{\n\t\tdouble FP = g3p.FocalParameter();\n\t\tdouble fp = 2 * focal;\n\t\tCHECK(FP == fp);\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API Geom3Parabola(const Frame3& frame, double focal)\t @param focal The focal length\n\t @param frame The local frame\n\t @brief Construct from a local frame and a focal length\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <geometry/Geom3Parabola.hpp>\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Test Geom3Parabola\", \"[math][Geom3Parabola][P1]\")\n{\n\tFrame3 frame;\n\tdouble focal = 5.0;\n\tGeom3Parabola g3p(frame, focal);\n\tSECTION(\"FocalParameter\")\n\t{\n\t\tdouble FP = g3p.FocalParameter();\n\t\tdouble fp = 2 * focal;\n\t\tCHECK(FP == fp);\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API explicit Geom3Parabola(const Parabola3& p)\t @param p The parabola\n\t @brief Construct from a parabola\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <geometry/Geom3Parabola.hpp>\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Test Geom3Parabola\", \"[math][Geom3Parabola][P1]\")\n{\n\tFrame3 frame;\n\tdouble focal = 5.0;\n\tGeom3Parabola g3p(frame, focal);\n\tSECTION(\"FocalParameter\")\n\t{\n\t\tdouble FP = g3p.FocalParameter();\n\t\tdouble fp = 2 * focal;\n\t\tCHECK(FP == fp);\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] AMCAX_API double SemilatusRectum()\t @return The semilatus rectum\n\t          Semilatus rectum = 2 * focalLength\n\t @details The semilatus rectum of parabola is half of the length of the chord through a focus parallel to the directrix.\n\t @brief Get the semilatus rectum of the parabola\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <geometry/Geom3Parabola.hpp>\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Test Geom3Parabola\", \"[math][Geom3Parabola][P1]\")\n{\n\tFrame3 frame;\n\tdouble focal = 5.0;\n\tGeom3Parabola g3p(frame, focal);\n\tSECTION(\"SemilatusRectum\")\n\t{\n\t\tdouble SR = g3p.SemilatusRectum();\n\t\tdouble sr = 2 * focal;\n\t\tCHECK(SR == sr);\n\t}\n}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] AMCAX_API double FocalParameter()\t @return The focal parameter\n\t          Focal parameter = 2 * focalLength.\n\t @details The focal parameter of parabola is the distance from the focus to the directrix.\n\t @brief Get the focal parameter of the parabola\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <geometry/Geom3Parabola.hpp>\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Test Geom3Parabola\", \"[math][Geom3Parabola][P1]\")\n{\n\tFrame3 frame;\n\tdouble focal = 5.0;\n\tGeom3Parabola g3p(frame, focal);\n\tSECTION(\"FocalParameter\")\n\t{\n\t\tdouble FP = g3p.FocalParameter();\n\t\tdouble fp = 2 * focal;\n\t\tCHECK(FP == fp);\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API Geom2Ellipse(const Frame2& frame, double major, double minor)\t @param minor The minor radius\n\t @param major The major radius\n\t @param frame The local frame\n\t @brief Construct from a local frame, a major radius and a minor radius\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <math/EllipseT.hpp>\n#include <geometry/Geom2Ellipse.hpp>\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Test Geom2Ellipse\", \"[math][Geom2Ellipse][P1]\")\n{\n\tAxis2 axis;\n\tdouble major = 5.0;\n\tdouble minor = 4.0;\n\tbool isRight = true;\n\tEllipse2 ellipse(axis, major, minor, isRight);\n\tGeom2Ellipse g2e(ellipse);\n\tSECTION(\"FocalParameter\")\n\t{\n\t\tdouble FP = g2e.FocalParameter();\n\t\tdouble focal = 2 * sqrt(major * major - minor * minor);\n\t\tdouble fp = 2 * minor * minor / focal;;\n\t\tCHECK(FP == fp);\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API Geom2Ellipse(const Axis2& majorAxis, double major, double minor, bool isRight)\t @param isRight Is the local frame right-handed\n\t @param minor The minor radius\n\t @param major The major radius\n\t @param majorAxis The axis\n\t @brief Construct from an axis, a major radius and a minor radius\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <math/EllipseT.hpp>\n#include <geometry/Geom2Ellipse.hpp>\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Test Geom2Ellipse\", \"[math][Geom2Ellipse][P1]\")\n{\n\tAxis2 axis;\n\tdouble major = 5.0;\n\tdouble minor = 4.0;\n\tbool isRight = true;\n\tEllipse2 ellipse(axis, major, minor, isRight);\n\tGeom2Ellipse g2e(ellipse);\n\tSECTION(\"FocalParameter\")\n\t{\n\t\tdouble FP = g2e.FocalParameter();\n\t\tdouble focal = 2 * sqrt(major * major - minor * minor);\n\t\tdouble fp = 2 * minor * minor / focal;;\n\t\tCHECK(FP == fp);\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API explicit Geom2Ellipse(const Ellipse2& e)\t @param e The ellipse\n\t @brief Construct from an ellipse\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <math/EllipseT.hpp>\n#include <geometry/Geom2Ellipse.hpp>\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Test Geom2Ellipse\", \"[math][Geom2Ellipse][P1]\")\n{\n\tAxis2 axis;\n\tdouble major = 5.0;\n\tdouble minor = 4.0;\n\tbool isRight = true;\n\tEllipse2 ellipse(axis, major, minor, isRight);\n\tGeom2Ellipse g2e(ellipse);\n\tSECTION(\"FocalParameter\")\n\t{\n\t\tdouble FP = g2e.FocalParameter();\n\t\tdouble focal = 2 * sqrt(major * major - minor * minor);\n\t\tdouble fp = 2 * minor * minor / focal;;\n\t\tCHECK(FP == fp);\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "Geom2Ellipse()\t @brief Default constructor\n,\n",
      "output": "#include <catch.hpp>\n#include <testHelper.h>\n#include <math/EllipseT.hpp>\n#include <geometry/Geom2Ellipse.hpp>\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Test Geom2Ellipse\", \"[math][Geom2Ellipse][P1]\")\n{\n\tAxis2 axis;\n\tdouble major = 5.0;\n\tdouble minor = 4.0;\n\tbool isRight = true;\n\tEllipse2 ellipse(axis, major, minor, isRight);\n\tGeom2Ellipse g2e(ellipse);\n\tSECTION(\"FocalParameter\")\n\t{\n\t\tdouble FP = g2e.FocalParameter();\n\t\tdouble focal = 2 * sqrt(major * major - minor * minor);\n\t\tdouble fp = 2 * minor * minor / focal;;\n\t\tCHECK(FP == fp);\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API double Parameter()\t @return The parameter of the point\n\t @brief Get the parameter of the point\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/MakeGeom2Circle.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/ComputePointsAbscissa.hpp>\n#include <geometry/MakeGeom2Hyperbola.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/MakeGeom2Ellipse.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/AdaptorGeom3Curve.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <geometry/MakeGeom3Hyperbola.hpp>\n#include <geometry/MakeGeom3Ellipse.hpp>\nTEST_CASE(\"bug1: ComputePointsAbscissa \", \"[geometry][ComputePointsAbscissa][fixbug]\")\n{\n    double r = 0.0;\n    std::shared_ptr<Geom2Curve> c = MakeGeom2Circle(Point2(0.0, 0.0), 0.0).Value();\n    AdaptorGeom2Curve circle(c);\n    ComputePointsAbscissa cpa(circle, 0.0, 0.0);\n    double angle1 = 0;\n    double x = r * cos(angle1);\n    double y = r * sin(angle1);\n    double param = cpa.Parameter();\n    Point2 s = circle.Value(param);\n    Point2 s1(x, y);\n    CHECK(angle1 == cpa.Parameter());\n    CHECK(s.X() == s1.X());\n    CHECK(s.Y() == s1.Y());\n    CHECK(ComputePointsAbscissa::Length(circle) == 0.0);\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API ComputePointsAbscissa(const Adaptor2Curve& c, double abscissa, double u0, double ui, double tol)\t @param tol The tolerance\n\t @param ui The initial guess of the parameter\n\t @param u0 The starting parameter\n\t @param abscissa The arc length\n\t @param c The curve\n\t @brief Compute the parameter of a point on a 2D curve with given arc length, an initial guess, and a tolerance\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/MakeGeom2Circle.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/ComputePointsAbscissa.hpp>\n#include <geometry/MakeGeom2Hyperbola.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/MakeGeom2Ellipse.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/AdaptorGeom3Curve.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <geometry/MakeGeom3Hyperbola.hpp>\n#include <geometry/MakeGeom3Ellipse.hpp>\nTEST_CASE(\"bug1: ComputePointsAbscissa \", \"[geometry][ComputePointsAbscissa][fixbug]\")\n{\n    double r = 0.0;\n    std::shared_ptr<Geom2Curve> c = MakeGeom2Circle(Point2(0.0, 0.0), 0.0).Value();\n    AdaptorGeom2Curve circle(c);\n    ComputePointsAbscissa cpa(circle, 0.0, 0.0);\n    double angle1 = 0;\n    double x = r * cos(angle1);\n    double y = r * sin(angle1);\n    double param = cpa.Parameter();\n    Point2 s = circle.Value(param);\n    Point2 s1(x, y);\n    CHECK(angle1 == cpa.Parameter());\n    CHECK(s.X() == s1.X());\n    CHECK(s.Y() == s1.Y());\n    CHECK(ComputePointsAbscissa::Length(circle) == 0.0);\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API ComputePointsAbscissa(const Adaptor3Curve& c, double abscissa, double u0, double ui, double tol)\t @param tol The tolerance\n\t @param ui The initial guess of the parameter\n\t @param u0 The starting parameter\n\t @param abscissa The arc length\n\t @param c The curve\n\t @brief Compute the parameter of a point on a 3D curve with given arc length, an initial guess, and a tolerance\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/MakeGeom2Circle.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/ComputePointsAbscissa.hpp>\n#include <geometry/MakeGeom2Hyperbola.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/MakeGeom2Ellipse.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/AdaptorGeom3Curve.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <geometry/MakeGeom3Hyperbola.hpp>\n#include <geometry/MakeGeom3Ellipse.hpp>\nTEST_CASE(\"bug2: ComputePointsAbscissa \", \"[geometry][ComputePointsAbscissa][fixbug]\")\n{\n\tSECTION(\"arc length-3D\")\n{\n    Frame3 frame;\n    double major = 5.0;\n    double minor = 4.0;\n    bool isRight = true;\n    std::shared_ptr< Geom3Hyperbola >h1 = MakeGeom3Hyperbola(frame, major, minor);\n    AdaptorGeom3Curve hyperbola(h1);\n    ComputePointsAbscissa cpa3(hyperbola, 1.0, 0.0);\n    double param3 = cpa3.Parameter();\n    Point3 point1 = hyperbola.Value(param3);\n    CHECK(cpa3.Parameter());\n    MakeEdge edge1(h1, 0.0, param3);\n    CHECK(BRepClassificationTools::IsPointInOnEdge(edge1, point1, 0.001) == true);\n}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API ComputePointsAbscissa(const Adaptor2Curve& c, double abscissa, double u0, double ui)\t @param ui The initial guess of the parameter\n\t @param u0 The starting parameter\n\t @param abscissa The arc length\n\t @param c The curve\n\t @brief Compute the parameter of a point on a 2D curve with given arc length and an initial guess\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/MakeGeom2Circle.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/ComputePointsAbscissa.hpp>\n#include <geometry/MakeGeom2Hyperbola.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/MakeGeom2Ellipse.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/AdaptorGeom3Curve.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <geometry/MakeGeom3Hyperbola.hpp>\n#include <geometry/MakeGeom3Ellipse.hpp>\nTEST_CASE(\"bug1: ComputePointsAbscissa \", \"[geometry][ComputePointsAbscissa][fixbug]\")\n{\n    double r = 0.0;\n    std::shared_ptr<Geom2Curve> c = MakeGeom2Circle(Point2(0.0, 0.0), 0.0).Value();\n    AdaptorGeom2Curve circle(c);\n    ComputePointsAbscissa cpa(circle, 0.0, 0.0);\n    double angle1 = 0;\n    double x = r * cos(angle1);\n    double y = r * sin(angle1);\n    double param = cpa.Parameter();\n    Point2 s = circle.Value(param);\n    Point2 s1(x, y);\n    CHECK(angle1 == cpa.Parameter());\n    CHECK(s.X() == s1.X());\n    CHECK(s.Y() == s1.Y());\n    CHECK(ComputePointsAbscissa::Length(circle) == 0.0);\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API ComputePointsAbscissa(const Adaptor3Curve& c, double abscissa, double u0, double ui)\t @param ui The initial guess of the parameter\n\t @param u0 The starting parameter\n\t @param abscissa The arc length\n\t @param c The curve\n\t @brief Compute the parameter of a point on a 3D curve with given arc length and an initial guess\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/MakeGeom2Circle.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/ComputePointsAbscissa.hpp>\n#include <geometry/MakeGeom2Hyperbola.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/MakeGeom2Ellipse.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/AdaptorGeom3Curve.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <geometry/MakeGeom3Hyperbola.hpp>\n#include <geometry/MakeGeom3Ellipse.hpp>\nTEST_CASE(\"bug1: ComputePointsAbscissa \", \"[geometry][ComputePointsAbscissa][fixbug]\")\n{\n    double r = 0.0;\n    std::shared_ptr<Geom2Curve> c = MakeGeom2Circle(Point2(0.0, 0.0), 0.0).Value();\n    AdaptorGeom2Curve circle(c);\n    ComputePointsAbscissa cpa(circle, 0.0, 0.0);\n    double angle1 = 0;\n    double x = r * cos(angle1);\n    double y = r * sin(angle1);\n    double param = cpa.Parameter();\n    Point2 s = circle.Value(param);\n    Point2 s1(x, y);\n    CHECK(angle1 == cpa.Parameter());\n    CHECK(s.X() == s1.X());\n    CHECK(s.Y() == s1.Y());\n    CHECK(ComputePointsAbscissa::Length(circle) == 0.0);\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API ComputePointsAbscissa(const Adaptor2Curve& c, double abscissa, double u0)\t @param u0 The starting parameter\n\t @param abscissa The arc length\n\t @param c The curve\n\t @brief Compute the parameter of a point on a 2D curve with given arc length\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/MakeGeom2Circle.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/ComputePointsAbscissa.hpp>\n#include <geometry/MakeGeom2Hyperbola.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/MakeGeom2Ellipse.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/AdaptorGeom3Curve.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <geometry/MakeGeom3Hyperbola.hpp>\n#include <geometry/MakeGeom3Ellipse.hpp>\nTEST_CASE(\"bug1: ComputePointsAbscissa \", \"[geometry][ComputePointsAbscissa][fixbug]\")\n{\n    double r = 0.0;\n    std::shared_ptr<Geom2Curve> c = MakeGeom2Circle(Point2(0.0, 0.0), 0.0).Value();\n    AdaptorGeom2Curve circle(c);\n    ComputePointsAbscissa cpa(circle, 0.0, 0.0);\n    double angle1 = 0;\n    double x = r * cos(angle1);\n    double y = r * sin(angle1);\n    double param = cpa.Parameter();\n    Point2 s = circle.Value(param);\n    Point2 s1(x, y);\n    CHECK(angle1 == cpa.Parameter());\n    CHECK(s.X() == s1.X());\n    CHECK(s.Y() == s1.Y());\n    CHECK(ComputePointsAbscissa::Length(circle) == 0.0);\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API ComputePointsAbscissa(const Adaptor3Curve& c, double abscissa, double u0)\t @param u0 The starting parameter\n\t @param abscissa The arc length\n\t @param c The curve\n\t @brief Compute the parameter of a point on a 3D curve with given arc length\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/MakeGeom2Circle.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/ComputePointsAbscissa.hpp>\n#include <geometry/MakeGeom2Hyperbola.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/MakeGeom2Ellipse.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/AdaptorGeom3Curve.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <geometry/MakeGeom3Hyperbola.hpp>\n#include <geometry/MakeGeom3Ellipse.hpp>\nTEST_CASE(\"bug1: ComputePointsAbscissa \", \"[geometry][ComputePointsAbscissa][fixbug]\")\n{\n    double r = 0.0;\n    std::shared_ptr<Geom2Curve> c = MakeGeom2Circle(Point2(0.0, 0.0), 0.0).Value();\n    AdaptorGeom2Curve circle(c);\n    ComputePointsAbscissa cpa(circle, 0.0, 0.0);\n    double angle1 = 0;\n    double x = r * cos(angle1);\n    double y = r * sin(angle1);\n    double param = cpa.Parameter();\n    Point2 s = circle.Value(param);\n    Point2 s1(x, y);\n    CHECK(angle1 == cpa.Parameter());\n    CHECK(s.X() == s1.X());\n    CHECK(s.Y() == s1.Y());\n    CHECK(ComputePointsAbscissa::Length(circle) == 0.0);\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API ComputePointsAbscissa(double tol, const Adaptor2Curve& c, double abscissa, double u0)\t @param u0 The starting parameter\n\t @param abscissa The arc length\n\t @param c The curve\n\t @param tol The tolerance\n\t @brief Compute the parameter of a point on a 2D curve with given arc length and a tolerance\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/MakeGeom2Circle.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/ComputePointsAbscissa.hpp>\n#include <geometry/MakeGeom2Hyperbola.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/MakeGeom2Ellipse.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/AdaptorGeom3Curve.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <geometry/MakeGeom3Hyperbola.hpp>\n#include <geometry/MakeGeom3Ellipse.hpp>\nTEST_CASE(\"bug2: ComputePointsAbscissa \", \"[geometry][ComputePointsAbscissa][fixbug]\")\n{\n\tSECTION(\"arc length and tolerance-2D\")\n{\n    Axis2 axis;\n    double major = 5.0;\n    double minor = 4.0;\n    bool isRight = true;\n    std::shared_ptr< Geom2Hyperbola >h1 = MakeGeom2Hyperbola(axis, major, minor, isRight);\n    AdaptorGeom2Curve hyperbola(h1);\n    ComputePointsAbscissa cpa3(Precision::Confusion(), hyperbola, 1.0, 0.0);\n    double param3 = cpa3.Parameter();\n    CHECK(cpa3.Parameter());\n    Point2 s4 = hyperbola.Value(param3);\n    shared_ptr<Geom3Curve> curve;\n    curve = GeometryTool::To3d(Frame3(), h1);\n    MakeEdge edge2(curve, 0.0, param3);\n    Point3 point1(s4.X(), s4.Y(), 0.0);\n    CHECK(BRepClassificationTools::IsPointInOnEdge(edge2, point1, 0.001) == true);\n}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API ComputePointsAbscissa(double tol, const Adaptor3Curve& c, double abscissa, double u0)\t @param u0 The starting parameter\n\t @param abscissa The arc length\n\t @param c The curve\n\t @param tol The tolerance\n\t @brief Compute the parameter of a point on a 3D curve with given arc length and a tolerance\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/MakeGeom2Circle.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/ComputePointsAbscissa.hpp>\n#include <geometry/MakeGeom2Hyperbola.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/MakeGeom2Ellipse.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/AdaptorGeom3Curve.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <geometry/MakeGeom3Hyperbola.hpp>\n#include <geometry/MakeGeom3Ellipse.hpp>\nTEST_CASE(\"bug2: ComputePointsAbscissa \", \"[geometry][ComputePointsAbscissa][fixbug]\")\n{\n\tSECTION(\"arc length and tolerance-3D\")\n{\n    Frame3 frame;\n    double major = 5.0;\n    double minor = 4.0;\n    bool isRight = true;\n    std::shared_ptr< Geom3Hyperbola >h1 = MakeGeom3Hyperbola(frame, major, minor);\n    AdaptorGeom3Curve hyperbola(h1);\n    ComputePointsAbscissa cpa3(Precision::Confusion(), hyperbola, 1.0, 0.0);\n    double param3 = cpa3.Parameter();\n    Point3 point1(hyperbola.Value(param3));\n    CHECK(cpa3.Parameter());\n    MakeEdge edge1(h1, 0.0, param3);\n    CHECK(BRepClassificationTools::IsPointInOnEdge(edge1, point1, 0.001) == true);\n}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API ComputePointsAbscissa(double tol, const Adaptor3Curve& c, double abscissa, double u0)\t @param u0 The starting parameter\n\t @param abscissa The arc length\n\t @param c The curve\n\t @param tol The tolerance\n\t @brief Compute the parameter of a point on a 3D curve with given arc length and a tolerance\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/MakeGeom2Circle.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/ComputePointsAbscissa.hpp>\n#include <geometry/MakeGeom3Circle.hpp>\n#include <geometry/AdaptorGeom3Curve.hpp>\n#include <geometry/MakeGeom2Hyperbola.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/MakeGeom2Ellipse.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <geometry/MakeGeom3Ellipse.hpp>\n#include <geometry/MakeGeom3Hyperbola.hpp>\n#include <geometry/Geom2Line.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include<modeling/MakeEdge.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/MakeGeom2Parabola.hpp>\n#include <geometry/MakeGeom3Parabola.hpp>\n#include <geometry/Geom2BezierCurve.hpp>\n#include <geometry/Geom3BezierCurve.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2OffsetCurve.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\nTEST_CASE(\"test the arc length is negative - given arc length - 3D\", \"[geometry][ComputePointsAbscissa][case10]\")\n{\n\tSECTION(\"circle\")\n    {\n        Frame3 frame;\n        double r = 2.0;\n        double l = -1.0;\n        std::shared_ptr<Geom3Curve> c = MakeGeom3Circle(frame, r).Value();\n        AdaptorGeom3Curve circle(c);\n        ComputePointsAbscissa cpa(circle, -1.0, 0.0);\n        double angle1 = l / r;\n        double x = r * cos(angle1);\n        double y = r * sin(angle1);\n        double z = 0;\n        double param = cpa.Parameter();\n        Point3 s = circle.Value(param);\n        Point3 s1(x, y, z);\n        CHECK(angle1 == cpa.Parameter());\n        CHECK(s.X() == s1.X());\n        CHECK(s.Y() == s1.Y());\n        CHECK(s.Z() == s1.Z());\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API double Parameter()\t @return The parameter of the point\n\t @brief Get the parameter of the point\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/MakeGeom2Circle.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/ComputePointsAbscissa.hpp>\n#include <geometry/MakeGeom3Circle.hpp>\n#include <geometry/AdaptorGeom3Curve.hpp>\n#include <geometry/MakeGeom2Hyperbola.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/MakeGeom2Ellipse.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <geometry/MakeGeom3Ellipse.hpp>\n#include <geometry/MakeGeom3Hyperbola.hpp>\n#include <geometry/Geom2Line.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include<modeling/MakeEdge.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/MakeGeom2Parabola.hpp>\n#include <geometry/MakeGeom3Parabola.hpp>\n#include <geometry/Geom2BezierCurve.hpp>\n#include <geometry/Geom3BezierCurve.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2OffsetCurve.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\nTEST_CASE(\"test that the arc length is 0 - given arc length - 2D\", \"[geometry][ComputePointsAbscissa][case26]\")\n{\n\tSECTION(\"circle\")\n    {\n        double r = 2.0;\n        double l = 0.0;\n        std::shared_ptr<Geom2Curve> c = MakeGeom2Circle(Point2(0.0, 0.0), 2.0).Value();\n        AdaptorGeom2Curve circle(c);\n        ComputePointsAbscissa cpa(circle, 0.0, 0.0);\n        double angle1 = l / r;\n        double x = r * cos(angle1);\n        double y = r * sin(angle1);\n        double param = cpa.Parameter();\n        Point2 s = circle.Value(param);\n        Point2 s1(x, y);\n        CHECK(angle1 == cpa.Parameter());\n        CHECK(s.X() == s1.X());\n        CHECK(s.Y() == s1.Y());\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API ComputePointsAbscissa(const Adaptor2Curve& c, double abscissa, double u0, double ui, double tol)\t @param tol The tolerance\n\t @param ui The initial guess of the parameter\n\t @param u0 The starting parameter\n\t @param abscissa The arc length\n\t @param c The curve\n\t @brief Compute the parameter of a point on a 2D curve with given arc length, an initial guess, and a tolerance\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/MakeGeom2Circle.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/ComputePointsAbscissa.hpp>\n#include <geometry/MakeGeom3Circle.hpp>\n#include <geometry/AdaptorGeom3Curve.hpp>\n#include <geometry/MakeGeom2Hyperbola.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/MakeGeom2Ellipse.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <geometry/MakeGeom3Ellipse.hpp>\n#include <geometry/MakeGeom3Hyperbola.hpp>\n#include <geometry/Geom2Line.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include<modeling/MakeEdge.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/MakeGeom2Parabola.hpp>\n#include <geometry/MakeGeom3Parabola.hpp>\n#include <geometry/Geom2BezierCurve.hpp>\n#include <geometry/Geom3BezierCurve.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2OffsetCurve.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\nTEST_CASE(\"test that the arc length is 0 - given arc length - 2D\", \"[geometry][ComputePointsAbscissa][case26]\")\n{\n\tSECTION(\"circle\")\n    {\n        double r = 2.0;\n        double l = 0.0;\n        std::shared_ptr<Geom2Curve> c = MakeGeom2Circle(Point2(0.0, 0.0), 2.0).Value();\n        AdaptorGeom2Curve circle(c);\n        ComputePointsAbscissa cpa(circle, 0.0, 0.0);\n        double angle1 = l / r;\n        double x = r * cos(angle1);\n        double y = r * sin(angle1);\n        double param = cpa.Parameter();\n        Point2 s = circle.Value(param);\n        Point2 s1(x, y);\n        CHECK(angle1 == cpa.Parameter());\n        CHECK(s.X() == s1.X());\n        CHECK(s.Y() == s1.Y());\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API ComputePointsAbscissa(const Adaptor3Curve& c, double abscissa, double u0, double ui, double tol)\t @param tol The tolerance\n\t @param ui The initial guess of the parameter\n\t @param u0 The starting parameter\n\t @param abscissa The arc length\n\t @param c The curve\n\t @brief Compute the parameter of a point on a 3D curve with given arc length, an initial guess, and a tolerance\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/MakeGeom2Circle.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/ComputePointsAbscissa.hpp>\n#include <geometry/MakeGeom3Circle.hpp>\n#include <geometry/AdaptorGeom3Curve.hpp>\n#include <geometry/MakeGeom2Hyperbola.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/MakeGeom2Ellipse.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <geometry/MakeGeom3Ellipse.hpp>\n#include <geometry/MakeGeom3Hyperbola.hpp>\n#include <geometry/Geom2Line.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include<modeling/MakeEdge.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/MakeGeom2Parabola.hpp>\n#include <geometry/MakeGeom3Parabola.hpp>\n#include <geometry/Geom2BezierCurve.hpp>\n#include <geometry/Geom3BezierCurve.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2OffsetCurve.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\nTEST_CASE(\"test that the arc length is 0 - given arc length - 3D\", \"[geometry][ComputePointsAbscissa][case27]\")\n{\n\tSECTION(\"circle\")\n    {\n        Frame3 frame;\n        double r = 2.0;\n        double l = 0.0;\n        std::shared_ptr<Geom3Curve> c = MakeGeom3Circle(frame, r).Value();\n        AdaptorGeom3Curve circle(c);\n        ComputePointsAbscissa cpa(circle, 0.0, 0.0);\n        double angle1 = l / r;\n        double x = r * cos(angle1);\n        double y = r * sin(angle1);\n        double z = 0;\n        double param = cpa.Parameter();\n        Point3 s = circle.Value(param);\n        Point3 s1(x, y, z);\n        CHECK(angle1 == cpa.Parameter());\n        CHECK(s.X() == s1.X());\n        CHECK(s.Y() == s1.Y());\n        CHECK(s.Z() == s1.Z());\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API ComputePointsAbscissa(const Adaptor2Curve& c, double abscissa, double u0, double ui)\t @param ui The initial guess of the parameter\n\t @param u0 The starting parameter\n\t @param abscissa The arc length\n\t @param c The curve\n\t @brief Compute the parameter of a point on a 2D curve with given arc length and an initial guess\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/MakeGeom2Circle.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/ComputePointsAbscissa.hpp>\n#include <geometry/MakeGeom3Circle.hpp>\n#include <geometry/AdaptorGeom3Curve.hpp>\n#include <geometry/MakeGeom2Hyperbola.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/MakeGeom2Ellipse.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <geometry/MakeGeom3Ellipse.hpp>\n#include <geometry/MakeGeom3Hyperbola.hpp>\n#include <geometry/Geom2Line.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include<modeling/MakeEdge.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/MakeGeom2Parabola.hpp>\n#include <geometry/MakeGeom3Parabola.hpp>\n#include <geometry/Geom2BezierCurve.hpp>\n#include <geometry/Geom3BezierCurve.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2OffsetCurve.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\nTEST_CASE(\"test that the arc length is 0 - given arc length - 2D\", \"[geometry][ComputePointsAbscissa][case26]\")\n{\n\tSECTION(\"circle\")\n    {\n        double r = 2.0;\n        double l = 0.0;\n        std::shared_ptr<Geom2Curve> c = MakeGeom2Circle(Point2(0.0, 0.0), 2.0).Value();\n        AdaptorGeom2Curve circle(c);\n        ComputePointsAbscissa cpa(circle, 0.0, 0.0);\n        double angle1 = l / r;\n        double x = r * cos(angle1);\n        double y = r * sin(angle1);\n        double param = cpa.Parameter();\n        Point2 s = circle.Value(param);\n        Point2 s1(x, y);\n        CHECK(angle1 == cpa.Parameter());\n        CHECK(s.X() == s1.X());\n        CHECK(s.Y() == s1.Y());\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API ComputePointsAbscissa(const Adaptor3Curve& c, double abscissa, double u0, double ui)\t @param ui The initial guess of the parameter\n\t @param u0 The starting parameter\n\t @param abscissa The arc length\n\t @param c The curve\n\t @brief Compute the parameter of a point on a 3D curve with given arc length and an initial guess\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/MakeGeom2Circle.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/ComputePointsAbscissa.hpp>\n#include <geometry/MakeGeom3Circle.hpp>\n#include <geometry/AdaptorGeom3Curve.hpp>\n#include <geometry/MakeGeom2Hyperbola.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/MakeGeom2Ellipse.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <geometry/MakeGeom3Ellipse.hpp>\n#include <geometry/MakeGeom3Hyperbola.hpp>\n#include <geometry/Geom2Line.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include<modeling/MakeEdge.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/MakeGeom2Parabola.hpp>\n#include <geometry/MakeGeom3Parabola.hpp>\n#include <geometry/Geom2BezierCurve.hpp>\n#include <geometry/Geom3BezierCurve.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2OffsetCurve.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\nTEST_CASE(\"test that the arc length is 0 - given arc length - 3D\", \"[geometry][ComputePointsAbscissa][case27]\")\n{\n\tSECTION(\"circle\")\n    {\n        Frame3 frame;\n        double r = 2.0;\n        double l = 0.0;\n        std::shared_ptr<Geom3Curve> c = MakeGeom3Circle(frame, r).Value();\n        AdaptorGeom3Curve circle(c);\n        ComputePointsAbscissa cpa(circle, 0.0, 0.0);\n        double angle1 = l / r;\n        double x = r * cos(angle1);\n        double y = r * sin(angle1);\n        double z = 0;\n        double param = cpa.Parameter();\n        Point3 s = circle.Value(param);\n        Point3 s1(x, y, z);\n        CHECK(angle1 == cpa.Parameter());\n        CHECK(s.X() == s1.X());\n        CHECK(s.Y() == s1.Y());\n        CHECK(s.Z() == s1.Z());\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API ComputePointsAbscissa(const Adaptor2Curve& c, double abscissa, double u0)\t @param u0 The starting parameter\n\t @param abscissa The arc length\n\t @param c The curve\n\t @brief Compute the parameter of a point on a 2D curve with given arc length\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/MakeGeom2Circle.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/ComputePointsAbscissa.hpp>\n#include <geometry/MakeGeom3Circle.hpp>\n#include <geometry/AdaptorGeom3Curve.hpp>\n#include <geometry/MakeGeom2Hyperbola.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/MakeGeom2Ellipse.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <geometry/MakeGeom3Ellipse.hpp>\n#include <geometry/MakeGeom3Hyperbola.hpp>\n#include <geometry/Geom2Line.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include<modeling/MakeEdge.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/MakeGeom2Parabola.hpp>\n#include <geometry/MakeGeom3Parabola.hpp>\n#include <geometry/Geom2BezierCurve.hpp>\n#include <geometry/Geom3BezierCurve.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2OffsetCurve.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\nTEST_CASE(\"test that the arc length is 0 - given arc length - 2D\", \"[geometry][ComputePointsAbscissa][case26]\")\n{\n\tSECTION(\"circle\")\n    {\n        double r = 2.0;\n        double l = 0.0;\n        std::shared_ptr<Geom2Curve> c = MakeGeom2Circle(Point2(0.0, 0.0), 2.0).Value();\n        AdaptorGeom2Curve circle(c);\n        ComputePointsAbscissa cpa(circle, 0.0, 0.0);\n        double angle1 = l / r;\n        double x = r * cos(angle1);\n        double y = r * sin(angle1);\n        double param = cpa.Parameter();\n        Point2 s = circle.Value(param);\n        Point2 s1(x, y);\n        CHECK(angle1 == cpa.Parameter());\n        CHECK(s.X() == s1.X());\n        CHECK(s.Y() == s1.Y());\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API ComputePointsAbscissa(const Adaptor3Curve& c, double abscissa, double u0)\t @param u0 The starting parameter\n\t @param abscissa The arc length\n\t @param c The curve\n\t @brief Compute the parameter of a point on a 3D curve with given arc length\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/MakeGeom2Circle.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/ComputePointsAbscissa.hpp>\n#include <geometry/MakeGeom3Circle.hpp>\n#include <geometry/AdaptorGeom3Curve.hpp>\n#include <geometry/MakeGeom2Hyperbola.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/MakeGeom2Ellipse.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <geometry/MakeGeom3Ellipse.hpp>\n#include <geometry/MakeGeom3Hyperbola.hpp>\n#include <geometry/Geom2Line.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include<modeling/MakeEdge.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/MakeGeom2Parabola.hpp>\n#include <geometry/MakeGeom3Parabola.hpp>\n#include <geometry/Geom2BezierCurve.hpp>\n#include <geometry/Geom3BezierCurve.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2OffsetCurve.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\nTEST_CASE(\"test that the arc length is 0 - given arc length - 3D\", \"[geometry][ComputePointsAbscissa][case27]\")\n{\n\tSECTION(\"circle\")\n    {\n        Frame3 frame;\n        double r = 2.0;\n        double l = 0.0;\n        std::shared_ptr<Geom3Curve> c = MakeGeom3Circle(frame, r).Value();\n        AdaptorGeom3Curve circle(c);\n        ComputePointsAbscissa cpa(circle, 0.0, 0.0);\n        double angle1 = l / r;\n        double x = r * cos(angle1);\n        double y = r * sin(angle1);\n        double z = 0;\n        double param = cpa.Parameter();\n        Point3 s = circle.Value(param);\n        Point3 s1(x, y, z);\n        CHECK(angle1 == cpa.Parameter());\n        CHECK(s.X() == s1.X());\n        CHECK(s.Y() == s1.Y());\n        CHECK(s.Z() == s1.Z());\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API ComputePointsAbscissa(double tol, const Adaptor2Curve& c, double abscissa, double u0)\t @param u0 The starting parameter\n\t @param abscissa The arc length\n\t @param c The curve\n\t @param tol The tolerance\n\t @brief Compute the parameter of a point on a 2D curve with given arc length and a tolerance\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/MakeGeom2Circle.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/ComputePointsAbscissa.hpp>\n#include <geometry/MakeGeom3Circle.hpp>\n#include <geometry/AdaptorGeom3Curve.hpp>\n#include <geometry/MakeGeom2Hyperbola.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/MakeGeom2Ellipse.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <geometry/MakeGeom3Ellipse.hpp>\n#include <geometry/MakeGeom3Hyperbola.hpp>\n#include <geometry/Geom2Line.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include<modeling/MakeEdge.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/MakeGeom2Parabola.hpp>\n#include <geometry/MakeGeom3Parabola.hpp>\n#include <geometry/Geom2BezierCurve.hpp>\n#include <geometry/Geom3BezierCurve.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2OffsetCurve.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\nTEST_CASE(\"test that the arc length is 0 - given arc length - 2D\", \"[geometry][ComputePointsAbscissa][case26]\")\n{\n\tSECTION(\"circle\")\n    {\n        double r = 2.0;\n        double l = 0.0;\n        std::shared_ptr<Geom2Curve> c = MakeGeom2Circle(Point2(0.0, 0.0), 2.0).Value();\n        AdaptorGeom2Curve circle(c);\n        ComputePointsAbscissa cpa(circle, 0.0, 0.0);\n        double angle1 = l / r;\n        double x = r * cos(angle1);\n        double y = r * sin(angle1);\n        double param = cpa.Parameter();\n        Point2 s = circle.Value(param);\n        Point2 s1(x, y);\n        CHECK(angle1 == cpa.Parameter());\n        CHECK(s.X() == s1.X());\n        CHECK(s.Y() == s1.Y());\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API ComputePointsAbscissa(double tol, const Adaptor3Curve& c, double abscissa, double u0)\t @param u0 The starting parameter\n\t @param abscissa The arc length\n\t @param c The curve\n\t @param tol The tolerance\n\t @brief Compute the parameter of a point on a 3D curve with given arc length and a tolerance\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/MakeGeom2Circle.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/ComputePointsAbscissa.hpp>\n#include <geometry/MakeGeom3Circle.hpp>\n#include <geometry/AdaptorGeom3Curve.hpp>\n#include <geometry/MakeGeom2Hyperbola.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/MakeGeom2Ellipse.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <geometry/MakeGeom3Ellipse.hpp>\n#include <geometry/MakeGeom3Hyperbola.hpp>\n#include <geometry/Geom2Line.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include<modeling/MakeEdge.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/MakeGeom2Parabola.hpp>\n#include <geometry/MakeGeom3Parabola.hpp>\n#include <geometry/Geom2BezierCurve.hpp>\n#include <geometry/Geom3BezierCurve.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2OffsetCurve.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\nTEST_CASE(\"test that the arc length is 0 - given arc length - 3D\", \"[geometry][ComputePointsAbscissa][case27]\")\n{\n\tSECTION(\"circle\")\n    {\n        Frame3 frame;\n        double r = 2.0;\n        double l = 0.0;\n        std::shared_ptr<Geom3Curve> c = MakeGeom3Circle(frame, r).Value();\n        AdaptorGeom3Curve circle(c);\n        ComputePointsAbscissa cpa(circle, 0.0, 0.0);\n        double angle1 = l / r;\n        double x = r * cos(angle1);\n        double y = r * sin(angle1);\n        double z = 0;\n        double param = cpa.Parameter();\n        Point3 s = circle.Value(param);\n        Point3 s1(x, y, z);\n        CHECK(angle1 == cpa.Parameter());\n        CHECK(s.X() == s1.X());\n        CHECK(s.Y() == s1.Y());\n        CHECK(s.Z() == s1.Z());\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static double Length(const Adaptor3Curve& c, double u1, double u2, double tol)\t @return The length of a curve in a given interval\n\t @param tol The tolerance\n\t @param u2 The last parameter\n\t @param u1 The first parameter\n\t @param c The curve\n\t @brief Compute the length of a 3D curve in a given interval with a tolerance\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/MakeGeom2Circle.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/ComputePointsAbscissa.hpp>\n#include <geometry/MakeGeom3Circle.hpp>\n#include <geometry/AdaptorGeom3Curve.hpp>\n#include <geometry/MakeGeom2Hyperbola.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/MakeGeom2Ellipse.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <geometry/MakeGeom3Ellipse.hpp>\n#include <geometry/MakeGeom3Hyperbola.hpp>\n#include <geometry/Geom2Line.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include<modeling/MakeEdge.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/MakeGeom2Parabola.hpp>\n#include <geometry/MakeGeom3Parabola.hpp>\n#include <geometry/Geom2BezierCurve.hpp>\n#include <geometry/Geom3BezierCurve.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2OffsetCurve.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\nTEST_CASE(\"test the arc length parameter over the total length of the curve - given arc length - 3D\", \"[geometry][ComputePointsAbscissa][case19]\")\n{\n\tSECTION(\"circle\")\n    {\n        Frame3 frame;\n        double r = 2.0;\n        double l = 13;\n        std::shared_ptr<Geom3Curve> c = MakeGeom3Circle(frame, r).Value();\n        AdaptorGeom3Curve circle(c);\n        ComputePointsAbscissa cpa(circle, 13, 0.0);\n        double angle1 = l / r;\n        double x = r * cos(angle1);\n        double y = r * sin(angle1);\n        double z = 0;\n        double param = cpa.Parameter();\n        Point3 s = circle.Value(param);\n        Point3 s1(x, y, z);\n        CHECK(angle1 == cpa.Parameter());\n        CHECK(s.X() == s1.X());\n        CHECK(s.Y() == s1.Y());\n        CHECK(s.Z() == s1.Z());\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API double Parameter()\t @return The parameter of the point\n\t @brief Get the parameter of the point\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/MakeGeom2Circle.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/ComputePointsAbscissa.hpp>\n#include <geometry/MakeGeom3Circle.hpp>\n#include <geometry/AdaptorGeom3Curve.hpp>\n#include <geometry/MakeGeom2Hyperbola.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/MakeGeom2Ellipse.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <geometry/MakeGeom3Ellipse.hpp>\n#include <geometry/MakeGeom3Hyperbola.hpp>\n#include <geometry/Geom2Line.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include<modeling/MakeEdge.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/MakeGeom2Parabola.hpp>\n#include <geometry/MakeGeom3Parabola.hpp>\n#include <geometry/Geom2BezierCurve.hpp>\n#include <geometry/Geom3BezierCurve.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2OffsetCurve.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\nTEST_CASE(\"test the arc length parameter over the total length of the curve - given arc length - 2D\", \"[geometry][ComputePointsAbscissa][case18]\")\n{\n\tSECTION(\"circle\")\n    {\n        double r = 2.0;\n        double l = 19;\n        std::shared_ptr<Geom2Curve> c = MakeGeom2Circle(Point2(0.0, 0.0), 2.0).Value();\n        AdaptorGeom2Curve circle(c);\n        ComputePointsAbscissa cpa(circle, l, 0.0);\n        double angle1 = l / r;\n        double x = r * cos(angle1);\n        double y = r * sin(angle1);\n        double param = cpa.Parameter();\n        Point2 s = circle.Value(param);\n        Point2 s1(x, y);\n        CHECK(angle1 == cpa.Parameter());\n        CHECK(s.X() == s1.X());\n        CHECK(s.Y() == s1.Y());\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API ComputePointsAbscissa(const Adaptor2Curve& c, double abscissa, double u0, double ui, double tol)\t @param tol The tolerance\n\t @param ui The initial guess of the parameter\n\t @param u0 The starting parameter\n\t @param abscissa The arc length\n\t @param c The curve\n\t @brief Compute the parameter of a point on a 2D curve with given arc length, an initial guess, and a tolerance\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/MakeGeom2Circle.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/ComputePointsAbscissa.hpp>\n#include <geometry/MakeGeom3Circle.hpp>\n#include <geometry/AdaptorGeom3Curve.hpp>\n#include <geometry/MakeGeom2Hyperbola.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/MakeGeom2Ellipse.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <geometry/MakeGeom3Ellipse.hpp>\n#include <geometry/MakeGeom3Hyperbola.hpp>\n#include <geometry/Geom2Line.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include<modeling/MakeEdge.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/MakeGeom2Parabola.hpp>\n#include <geometry/MakeGeom3Parabola.hpp>\n#include <geometry/Geom2BezierCurve.hpp>\n#include <geometry/Geom3BezierCurve.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2OffsetCurve.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\nTEST_CASE(\"test the arc length parameter over the total length of the curve - given arc length - 2D\", \"[geometry][ComputePointsAbscissa][case18]\")\n{\n\tSECTION(\"circle\")\n    {\n        double r = 2.0;\n        double l = 19;\n        std::shared_ptr<Geom2Curve> c = MakeGeom2Circle(Point2(0.0, 0.0), 2.0).Value();\n        AdaptorGeom2Curve circle(c);\n        ComputePointsAbscissa cpa(circle, l, 0.0);\n        double angle1 = l / r;\n        double x = r * cos(angle1);\n        double y = r * sin(angle1);\n        double param = cpa.Parameter();\n        Point2 s = circle.Value(param);\n        Point2 s1(x, y);\n        CHECK(angle1 == cpa.Parameter());\n        CHECK(s.X() == s1.X());\n        CHECK(s.Y() == s1.Y());\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API ComputePointsAbscissa(const Adaptor3Curve& c, double abscissa, double u0, double ui, double tol)\t @param tol The tolerance\n\t @param ui The initial guess of the parameter\n\t @param u0 The starting parameter\n\t @param abscissa The arc length\n\t @param c The curve\n\t @brief Compute the parameter of a point on a 3D curve with given arc length, an initial guess, and a tolerance\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/MakeGeom2Circle.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/ComputePointsAbscissa.hpp>\n#include <geometry/MakeGeom3Circle.hpp>\n#include <geometry/AdaptorGeom3Curve.hpp>\n#include <geometry/MakeGeom2Hyperbola.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/MakeGeom2Ellipse.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <geometry/MakeGeom3Ellipse.hpp>\n#include <geometry/MakeGeom3Hyperbola.hpp>\n#include <geometry/Geom2Line.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include<modeling/MakeEdge.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/MakeGeom2Parabola.hpp>\n#include <geometry/MakeGeom3Parabola.hpp>\n#include <geometry/Geom2BezierCurve.hpp>\n#include <geometry/Geom3BezierCurve.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2OffsetCurve.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\nTEST_CASE(\"test the arc length parameter over the total length of the curve - given arc length - 3D\", \"[geometry][ComputePointsAbscissa][case19]\")\n{\n\tSECTION(\"circle\")\n    {\n        Frame3 frame;\n        double r = 2.0;\n        double l = 13;\n        std::shared_ptr<Geom3Curve> c = MakeGeom3Circle(frame, r).Value();\n        AdaptorGeom3Curve circle(c);\n        ComputePointsAbscissa cpa(circle, 13, 0.0);\n        double angle1 = l / r;\n        double x = r * cos(angle1);\n        double y = r * sin(angle1);\n        double z = 0;\n        double param = cpa.Parameter();\n        Point3 s = circle.Value(param);\n        Point3 s1(x, y, z);\n        CHECK(angle1 == cpa.Parameter());\n        CHECK(s.X() == s1.X());\n        CHECK(s.Y() == s1.Y());\n        CHECK(s.Z() == s1.Z());\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API ComputePointsAbscissa(const Adaptor2Curve& c, double abscissa, double u0, double ui)\t @param ui The initial guess of the parameter\n\t @param u0 The starting parameter\n\t @param abscissa The arc length\n\t @param c The curve\n\t @brief Compute the parameter of a point on a 2D curve with given arc length and an initial guess\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/MakeGeom2Circle.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/ComputePointsAbscissa.hpp>\n#include <geometry/MakeGeom3Circle.hpp>\n#include <geometry/AdaptorGeom3Curve.hpp>\n#include <geometry/MakeGeom2Hyperbola.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/MakeGeom2Ellipse.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <geometry/MakeGeom3Ellipse.hpp>\n#include <geometry/MakeGeom3Hyperbola.hpp>\n#include <geometry/Geom2Line.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include<modeling/MakeEdge.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/MakeGeom2Parabola.hpp>\n#include <geometry/MakeGeom3Parabola.hpp>\n#include <geometry/Geom2BezierCurve.hpp>\n#include <geometry/Geom3BezierCurve.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2OffsetCurve.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\nTEST_CASE(\"test the arc length parameter over the total length of the curve - given arc length - 2D\", \"[geometry][ComputePointsAbscissa][case18]\")\n{\n\tSECTION(\"circle\")\n    {\n        double r = 2.0;\n        double l = 19;\n        std::shared_ptr<Geom2Curve> c = MakeGeom2Circle(Point2(0.0, 0.0), 2.0).Value();\n        AdaptorGeom2Curve circle(c);\n        ComputePointsAbscissa cpa(circle, l, 0.0);\n        double angle1 = l / r;\n        double x = r * cos(angle1);\n        double y = r * sin(angle1);\n        double param = cpa.Parameter();\n        Point2 s = circle.Value(param);\n        Point2 s1(x, y);\n        CHECK(angle1 == cpa.Parameter());\n        CHECK(s.X() == s1.X());\n        CHECK(s.Y() == s1.Y());\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API ComputePointsAbscissa(const Adaptor3Curve& c, double abscissa, double u0, double ui)\t @param ui The initial guess of the parameter\n\t @param u0 The starting parameter\n\t @param abscissa The arc length\n\t @param c The curve\n\t @brief Compute the parameter of a point on a 3D curve with given arc length and an initial guess\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/MakeGeom2Circle.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/ComputePointsAbscissa.hpp>\n#include <geometry/MakeGeom3Circle.hpp>\n#include <geometry/AdaptorGeom3Curve.hpp>\n#include <geometry/MakeGeom2Hyperbola.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/MakeGeom2Ellipse.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <geometry/MakeGeom3Ellipse.hpp>\n#include <geometry/MakeGeom3Hyperbola.hpp>\n#include <geometry/Geom2Line.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include<modeling/MakeEdge.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/MakeGeom2Parabola.hpp>\n#include <geometry/MakeGeom3Parabola.hpp>\n#include <geometry/Geom2BezierCurve.hpp>\n#include <geometry/Geom3BezierCurve.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2OffsetCurve.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\nTEST_CASE(\"test the arc length parameter over the total length of the curve - given arc length - 2D\", \"[geometry][ComputePointsAbscissa][case18]\")\n{\n\tSECTION(\"line\")\n    {\n        shared_ptr<Geom2Line> line;\n        line = make_shared<Geom2Line>(Point2(0.0, 0.0), Direction2(1.0, 0.0));\n        shared_ptr<Geom2TrimmedCurve> TrimmedCurve = make_shared<Geom2TrimmedCurve>(line, 0.0, 6.0);\n        AdaptorGeom2Curve line1(TrimmedCurve);\n        ComputePointsAbscissa cpa4(line1, 8.0, 0.0);\n        double param4 = cpa4.Parameter();\n        double x = 8.0;\n        double y = 0.0;\n        Point2 s5 = line1.Value(param4);\n        Point2 s6(x, y);\n        CHECK(cpa4.Parameter() == 8.0);\n        CHECK(s5.X() == s6.X());\n        CHECK(s5.Y() == s6.Y());\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API ComputePointsAbscissa(const Adaptor2Curve& c, double abscissa, double u0)\t @param u0 The starting parameter\n\t @param abscissa The arc length\n\t @param c The curve\n\t @brief Compute the parameter of a point on a 2D curve with given arc length\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/MakeGeom2Circle.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/ComputePointsAbscissa.hpp>\n#include <geometry/MakeGeom3Circle.hpp>\n#include <geometry/AdaptorGeom3Curve.hpp>\n#include <geometry/MakeGeom2Hyperbola.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/MakeGeom2Ellipse.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <geometry/MakeGeom3Ellipse.hpp>\n#include <geometry/MakeGeom3Hyperbola.hpp>\n#include <geometry/Geom2Line.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include<modeling/MakeEdge.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/MakeGeom2Parabola.hpp>\n#include <geometry/MakeGeom3Parabola.hpp>\n#include <geometry/Geom2BezierCurve.hpp>\n#include <geometry/Geom3BezierCurve.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2OffsetCurve.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\nTEST_CASE(\"test the arc length parameter over the total length of the curve - given arc length - 2D\", \"[geometry][ComputePointsAbscissa][case18]\")\n{\n\tSECTION(\"circle\")\n    {\n        double r = 2.0;\n        double l = 19;\n        std::shared_ptr<Geom2Curve> c = MakeGeom2Circle(Point2(0.0, 0.0), 2.0).Value();\n        AdaptorGeom2Curve circle(c);\n        ComputePointsAbscissa cpa(circle, l, 0.0);\n        double angle1 = l / r;\n        double x = r * cos(angle1);\n        double y = r * sin(angle1);\n        double param = cpa.Parameter();\n        Point2 s = circle.Value(param);\n        Point2 s1(x, y);\n        CHECK(angle1 == cpa.Parameter());\n        CHECK(s.X() == s1.X());\n        CHECK(s.Y() == s1.Y());\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API ComputePointsAbscissa(const Adaptor3Curve& c, double abscissa, double u0)\t @param u0 The starting parameter\n\t @param abscissa The arc length\n\t @param c The curve\n\t @brief Compute the parameter of a point on a 3D curve with given arc length\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/MakeGeom2Circle.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/ComputePointsAbscissa.hpp>\n#include <geometry/MakeGeom3Circle.hpp>\n#include <geometry/AdaptorGeom3Curve.hpp>\n#include <geometry/MakeGeom2Hyperbola.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/MakeGeom2Ellipse.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <geometry/MakeGeom3Ellipse.hpp>\n#include <geometry/MakeGeom3Hyperbola.hpp>\n#include <geometry/Geom2Line.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include<modeling/MakeEdge.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/MakeGeom2Parabola.hpp>\n#include <geometry/MakeGeom3Parabola.hpp>\n#include <geometry/Geom2BezierCurve.hpp>\n#include <geometry/Geom3BezierCurve.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2OffsetCurve.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\nTEST_CASE(\"test the arc length parameter over the total length of the curve - given arc length - 3D\", \"[geometry][ComputePointsAbscissa][case19]\")\n{\n\tSECTION(\"circle\")\n    {\n        Frame3 frame;\n        double r = 2.0;\n        double l = 13;\n        std::shared_ptr<Geom3Curve> c = MakeGeom3Circle(frame, r).Value();\n        AdaptorGeom3Curve circle(c);\n        ComputePointsAbscissa cpa(circle, 13, 0.0);\n        double angle1 = l / r;\n        double x = r * cos(angle1);\n        double y = r * sin(angle1);\n        double z = 0;\n        double param = cpa.Parameter();\n        Point3 s = circle.Value(param);\n        Point3 s1(x, y, z);\n        CHECK(angle1 == cpa.Parameter());\n        CHECK(s.X() == s1.X());\n        CHECK(s.Y() == s1.Y());\n        CHECK(s.Z() == s1.Z());\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API ComputePointsAbscissa(double tol, const Adaptor2Curve& c, double abscissa, double u0)\t @param u0 The starting parameter\n\t @param abscissa The arc length\n\t @param c The curve\n\t @param tol The tolerance\n\t @brief Compute the parameter of a point on a 2D curve with given arc length and a tolerance\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/MakeGeom2Circle.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/ComputePointsAbscissa.hpp>\n#include <geometry/MakeGeom3Circle.hpp>\n#include <geometry/AdaptorGeom3Curve.hpp>\n#include <geometry/MakeGeom2Hyperbola.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/MakeGeom2Ellipse.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <geometry/MakeGeom3Ellipse.hpp>\n#include <geometry/MakeGeom3Hyperbola.hpp>\n#include <geometry/Geom2Line.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include<modeling/MakeEdge.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/MakeGeom2Parabola.hpp>\n#include <geometry/MakeGeom3Parabola.hpp>\n#include <geometry/Geom2BezierCurve.hpp>\n#include <geometry/Geom3BezierCurve.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2OffsetCurve.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\nTEST_CASE(\"test the arc length parameter over the total length of the curve - given arc length - 2D\", \"[geometry][ComputePointsAbscissa][case18]\")\n{\n\tSECTION(\"circle\")\n    {\n        double r = 2.0;\n        double l = 19;\n        std::shared_ptr<Geom2Curve> c = MakeGeom2Circle(Point2(0.0, 0.0), 2.0).Value();\n        AdaptorGeom2Curve circle(c);\n        ComputePointsAbscissa cpa(circle, l, 0.0);\n        double angle1 = l / r;\n        double x = r * cos(angle1);\n        double y = r * sin(angle1);\n        double param = cpa.Parameter();\n        Point2 s = circle.Value(param);\n        Point2 s1(x, y);\n        CHECK(angle1 == cpa.Parameter());\n        CHECK(s.X() == s1.X());\n        CHECK(s.Y() == s1.Y());\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API ComputePointsAbscissa(double tol, const Adaptor3Curve& c, double abscissa, double u0)\t @param u0 The starting parameter\n\t @param abscissa The arc length\n\t @param c The curve\n\t @param tol The tolerance\n\t @brief Compute the parameter of a point on a 3D curve with given arc length and a tolerance\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/MakeGeom2Circle.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/ComputePointsAbscissa.hpp>\n#include <geometry/MakeGeom3Circle.hpp>\n#include <geometry/AdaptorGeom3Curve.hpp>\n#include <geometry/MakeGeom2Hyperbola.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/MakeGeom2Ellipse.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <geometry/MakeGeom3Ellipse.hpp>\n#include <geometry/MakeGeom3Hyperbola.hpp>\n#include <geometry/Geom2Line.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include<modeling/MakeEdge.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/MakeGeom2Parabola.hpp>\n#include <geometry/MakeGeom3Parabola.hpp>\n#include <geometry/Geom2BezierCurve.hpp>\n#include <geometry/Geom3BezierCurve.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2OffsetCurve.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\nTEST_CASE(\"test the arc length parameter over the total length of the curve - given arc length - 2D\", \"[geometry][ComputePointsAbscissa][case18]\")\n{\n\tSECTION(\"line\")\n    {\n        shared_ptr<Geom2Line> line;\n        line = make_shared<Geom2Line>(Point2(0.0, 0.0), Direction2(1.0, 0.0));\n        shared_ptr<Geom2TrimmedCurve> TrimmedCurve = make_shared<Geom2TrimmedCurve>(line, 0.0, 6.0);\n        AdaptorGeom2Curve line1(TrimmedCurve);\n        ComputePointsAbscissa cpa4(line1, 8.0, 0.0);\n        double param4 = cpa4.Parameter();\n        double x = 8.0;\n        double y = 0.0;\n        Point2 s5 = line1.Value(param4);\n        Point2 s6(x, y);\n        CHECK(cpa4.Parameter() == 8.0);\n        CHECK(s5.X() == s6.X());\n        CHECK(s5.Y() == s6.Y());\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API double Parameter()\t @return The parameter of the point\n\t @brief Get the parameter of the point\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/MakeGeom2Circle.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/ComputePointsAbscissa.hpp>\n#include <geometry/MakeGeom3Circle.hpp>\n#include <geometry/AdaptorGeom3Curve.hpp>\n#include <geometry/MakeGeom2Hyperbola.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/MakeGeom2Ellipse.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <geometry/MakeGeom3Ellipse.hpp>\n#include <geometry/MakeGeom3Hyperbola.hpp>\n#include <geometry/Geom2Line.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include<modeling/MakeEdge.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/MakeGeom2Parabola.hpp>\n#include <geometry/MakeGeom3Parabola.hpp>\n#include <geometry/Geom2BezierCurve.hpp>\n#include <geometry/Geom3BezierCurve.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2OffsetCurve.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\nTEST_CASE(\"test the arc length is negative - given arc length - 2D\", \"[geometry][ComputePointsAbscissa][case9]\")\n{\n\tSECTION(\"circle\")\n    {\n        double r = 2.0;\n        double l = -1.0;\n        std::shared_ptr<Geom2Curve> c = MakeGeom2Circle(Point2(0.0, 0.0), 2.0).Value();\n        AdaptorGeom2Curve circle(c);\n        ComputePointsAbscissa cpa(circle, -1.0, 0.0);\n        double angle1 = l / r;\n        double x = r * cos(angle1);\n        double y = r * sin(angle1);\n        double param = cpa.Parameter();\n        Point2 s = circle.Value(param);\n        Point2 s1(x, y);\n        CHECK(angle1 == cpa.Parameter());\n        CHECK(s.X() == s1.X());\n        CHECK(s.Y() == s1.Y());\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API ComputePointsAbscissa(const Adaptor2Curve& c, double abscissa, double u0, double ui, double tol)\t @param tol The tolerance\n\t @param ui The initial guess of the parameter\n\t @param u0 The starting parameter\n\t @param abscissa The arc length\n\t @param c The curve\n\t @brief Compute the parameter of a point on a 2D curve with given arc length, an initial guess, and a tolerance\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/MakeGeom2Circle.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/ComputePointsAbscissa.hpp>\n#include <geometry/MakeGeom3Circle.hpp>\n#include <geometry/AdaptorGeom3Curve.hpp>\n#include <geometry/MakeGeom2Hyperbola.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/MakeGeom2Ellipse.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <geometry/MakeGeom3Ellipse.hpp>\n#include <geometry/MakeGeom3Hyperbola.hpp>\n#include <geometry/Geom2Line.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include<modeling/MakeEdge.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/MakeGeom2Parabola.hpp>\n#include <geometry/MakeGeom3Parabola.hpp>\n#include <geometry/Geom2BezierCurve.hpp>\n#include <geometry/Geom3BezierCurve.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2OffsetCurve.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\nTEST_CASE(\"test the arc length is negative - given arc length - 2D\", \"[geometry][ComputePointsAbscissa][case9]\")\n{\n\tSECTION(\"circle\")\n    {\n        double r = 2.0;\n        double l = -1.0;\n        std::shared_ptr<Geom2Curve> c = MakeGeom2Circle(Point2(0.0, 0.0), 2.0).Value();\n        AdaptorGeom2Curve circle(c);\n        ComputePointsAbscissa cpa(circle, -1.0, 0.0);\n        double angle1 = l / r;\n        double x = r * cos(angle1);\n        double y = r * sin(angle1);\n        double param = cpa.Parameter();\n        Point2 s = circle.Value(param);\n        Point2 s1(x, y);\n        CHECK(angle1 == cpa.Parameter());\n        CHECK(s.X() == s1.X());\n        CHECK(s.Y() == s1.Y());\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API ComputePointsAbscissa(const Adaptor3Curve& c, double abscissa, double u0, double ui, double tol)\t @param tol The tolerance\n\t @param ui The initial guess of the parameter\n\t @param u0 The starting parameter\n\t @param abscissa The arc length\n\t @param c The curve\n\t @brief Compute the parameter of a point on a 3D curve with given arc length, an initial guess, and a tolerance\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/MakeGeom2Circle.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/ComputePointsAbscissa.hpp>\n#include <geometry/MakeGeom3Circle.hpp>\n#include <geometry/AdaptorGeom3Curve.hpp>\n#include <geometry/MakeGeom2Hyperbola.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/MakeGeom2Ellipse.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <geometry/MakeGeom3Ellipse.hpp>\n#include <geometry/MakeGeom3Hyperbola.hpp>\n#include <geometry/Geom2Line.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include<modeling/MakeEdge.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/MakeGeom2Parabola.hpp>\n#include <geometry/MakeGeom3Parabola.hpp>\n#include <geometry/Geom2BezierCurve.hpp>\n#include <geometry/Geom3BezierCurve.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2OffsetCurve.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\nTEST_CASE(\"test the arc length is negative - given arc length - 3D\", \"[geometry][ComputePointsAbscissa][case10]\")\n{\n\tSECTION(\"line\")\n    {\n        double t = -2.0;\n        shared_ptr<Geom3Line> line;\n        line = make_shared<Geom3Line>(Point3(0.0, 0.0, 0.0), Direction3(1.0, 2.0, 3.0));\n        shared_ptr<Geom3TrimmedCurve> TrimmedCurve = make_shared<Geom3TrimmedCurve>(line, 0.0, 6.0);\n        AdaptorGeom3Curve line1(TrimmedCurve);\n        ComputePointsAbscissa cpa4(line1, -2.0, 0.0);\n        double param4 = cpa4.Parameter();\n        Point3 start(0.0, 0.0, 0.0);\n        Direction3 direction(1.0, 2.0, 3.0);\n        double x = start.X() + t * direction.X();\n        double y = start.Y() + t * direction.Y();\n        double z = start.Z() + t * direction.Z();\n        Point3 s5 = line1.Value(param4);\n        Point3 s6(x, y, z);\n        CHECK(cpa4.Parameter() == -2.0);\n        CHECK(s5.X() == s6.X());\n        CHECK(s5.Y() == s6.Y());\n        CHECK(s5.Z() == s6.Z());\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API ComputePointsAbscissa(const Adaptor2Curve& c, double abscissa, double u0, double ui)\t @param ui The initial guess of the parameter\n\t @param u0 The starting parameter\n\t @param abscissa The arc length\n\t @param c The curve\n\t @brief Compute the parameter of a point on a 2D curve with given arc length and an initial guess\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/MakeGeom2Circle.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/ComputePointsAbscissa.hpp>\n#include <geometry/MakeGeom3Circle.hpp>\n#include <geometry/AdaptorGeom3Curve.hpp>\n#include <geometry/MakeGeom2Hyperbola.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/MakeGeom2Ellipse.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <geometry/MakeGeom3Ellipse.hpp>\n#include <geometry/MakeGeom3Hyperbola.hpp>\n#include <geometry/Geom2Line.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include<modeling/MakeEdge.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/MakeGeom2Parabola.hpp>\n#include <geometry/MakeGeom3Parabola.hpp>\n#include <geometry/Geom2BezierCurve.hpp>\n#include <geometry/Geom3BezierCurve.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2OffsetCurve.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\nTEST_CASE(\"test the arc length is negative - given arc length - 2D\", \"[geometry][ComputePointsAbscissa][case9]\")\n{\n\tSECTION(\"circle\")\n    {\n        double r = 2.0;\n        double l = -1.0;\n        std::shared_ptr<Geom2Curve> c = MakeGeom2Circle(Point2(0.0, 0.0), 2.0).Value();\n        AdaptorGeom2Curve circle(c);\n        ComputePointsAbscissa cpa(circle, -1.0, 0.0);\n        double angle1 = l / r;\n        double x = r * cos(angle1);\n        double y = r * sin(angle1);\n        double param = cpa.Parameter();\n        Point2 s = circle.Value(param);\n        Point2 s1(x, y);\n        CHECK(angle1 == cpa.Parameter());\n        CHECK(s.X() == s1.X());\n        CHECK(s.Y() == s1.Y());\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API ComputePointsAbscissa(const Adaptor3Curve& c, double abscissa, double u0, double ui)\t @param ui The initial guess of the parameter\n\t @param u0 The starting parameter\n\t @param abscissa The arc length\n\t @param c The curve\n\t @brief Compute the parameter of a point on a 3D curve with given arc length and an initial guess\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/MakeGeom2Circle.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/ComputePointsAbscissa.hpp>\n#include <geometry/MakeGeom3Circle.hpp>\n#include <geometry/AdaptorGeom3Curve.hpp>\n#include <geometry/MakeGeom2Hyperbola.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/MakeGeom2Ellipse.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <geometry/MakeGeom3Ellipse.hpp>\n#include <geometry/MakeGeom3Hyperbola.hpp>\n#include <geometry/Geom2Line.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include<modeling/MakeEdge.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/MakeGeom2Parabola.hpp>\n#include <geometry/MakeGeom3Parabola.hpp>\n#include <geometry/Geom2BezierCurve.hpp>\n#include <geometry/Geom3BezierCurve.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2OffsetCurve.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\nTEST_CASE(\"test the arc length is negative - given arc length - 3D\", \"[geometry][ComputePointsAbscissa][case10]\")\n{\n\tSECTION(\"circle\")\n    {\n        Frame3 frame;\n        double r = 2.0;\n        double l = -1.0;\n        std::shared_ptr<Geom3Curve> c = MakeGeom3Circle(frame, r).Value();\n        AdaptorGeom3Curve circle(c);\n        ComputePointsAbscissa cpa(circle, -1.0, 0.0);\n        double angle1 = l / r;\n        double x = r * cos(angle1);\n        double y = r * sin(angle1);\n        double z = 0;\n        double param = cpa.Parameter();\n        Point3 s = circle.Value(param);\n        Point3 s1(x, y, z);\n        CHECK(angle1 == cpa.Parameter());\n        CHECK(s.X() == s1.X());\n        CHECK(s.Y() == s1.Y());\n        CHECK(s.Z() == s1.Z());\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API ComputePointsAbscissa(const Adaptor2Curve& c, double abscissa, double u0)\t @param u0 The starting parameter\n\t @param abscissa The arc length\n\t @param c The curve\n\t @brief Compute the parameter of a point on a 2D curve with given arc length\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/MakeGeom2Circle.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/ComputePointsAbscissa.hpp>\n#include <geometry/MakeGeom3Circle.hpp>\n#include <geometry/AdaptorGeom3Curve.hpp>\n#include <geometry/MakeGeom2Hyperbola.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/MakeGeom2Ellipse.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <geometry/MakeGeom3Ellipse.hpp>\n#include <geometry/MakeGeom3Hyperbola.hpp>\n#include <geometry/Geom2Line.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include<modeling/MakeEdge.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/MakeGeom2Parabola.hpp>\n#include <geometry/MakeGeom3Parabola.hpp>\n#include <geometry/Geom2BezierCurve.hpp>\n#include <geometry/Geom3BezierCurve.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2OffsetCurve.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\nTEST_CASE(\"test the arc length is negative - given arc length - 2D\", \"[geometry][ComputePointsAbscissa][case9]\")\n{\n\tSECTION(\"circle\")\n    {\n        double r = 2.0;\n        double l = -1.0;\n        std::shared_ptr<Geom2Curve> c = MakeGeom2Circle(Point2(0.0, 0.0), 2.0).Value();\n        AdaptorGeom2Curve circle(c);\n        ComputePointsAbscissa cpa(circle, -1.0, 0.0);\n        double angle1 = l / r;\n        double x = r * cos(angle1);\n        double y = r * sin(angle1);\n        double param = cpa.Parameter();\n        Point2 s = circle.Value(param);\n        Point2 s1(x, y);\n        CHECK(angle1 == cpa.Parameter());\n        CHECK(s.X() == s1.X());\n        CHECK(s.Y() == s1.Y());\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API ComputePointsAbscissa(const Adaptor3Curve& c, double abscissa, double u0)\t @param u0 The starting parameter\n\t @param abscissa The arc length\n\t @param c The curve\n\t @brief Compute the parameter of a point on a 3D curve with given arc length\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/MakeGeom2Circle.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/ComputePointsAbscissa.hpp>\n#include <geometry/MakeGeom3Circle.hpp>\n#include <geometry/AdaptorGeom3Curve.hpp>\n#include <geometry/MakeGeom2Hyperbola.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/MakeGeom2Ellipse.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <geometry/MakeGeom3Ellipse.hpp>\n#include <geometry/MakeGeom3Hyperbola.hpp>\n#include <geometry/Geom2Line.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include<modeling/MakeEdge.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/MakeGeom2Parabola.hpp>\n#include <geometry/MakeGeom3Parabola.hpp>\n#include <geometry/Geom2BezierCurve.hpp>\n#include <geometry/Geom3BezierCurve.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2OffsetCurve.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\nTEST_CASE(\"test the arc length is negative - given arc length - 2D\", \"[geometry][ComputePointsAbscissa][case9]\")\n{\n\tSECTION(\"circle\")\n    {\n        double r = 2.0;\n        double l = -1.0;\n        std::shared_ptr<Geom2Curve> c = MakeGeom2Circle(Point2(0.0, 0.0), 2.0).Value();\n        AdaptorGeom2Curve circle(c);\n        ComputePointsAbscissa cpa(circle, -1.0, 0.0);\n        double angle1 = l / r;\n        double x = r * cos(angle1);\n        double y = r * sin(angle1);\n        double param = cpa.Parameter();\n        Point2 s = circle.Value(param);\n        Point2 s1(x, y);\n        CHECK(angle1 == cpa.Parameter());\n        CHECK(s.X() == s1.X());\n        CHECK(s.Y() == s1.Y());\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API ComputePointsAbscissa(double tol, const Adaptor2Curve& c, double abscissa, double u0)\t @param u0 The starting parameter\n\t @param abscissa The arc length\n\t @param c The curve\n\t @param tol The tolerance\n\t @brief Compute the parameter of a point on a 2D curve with given arc length and a tolerance\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/MakeGeom2Circle.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/ComputePointsAbscissa.hpp>\n#include <geometry/MakeGeom3Circle.hpp>\n#include <geometry/AdaptorGeom3Curve.hpp>\n#include <geometry/MakeGeom2Hyperbola.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/MakeGeom2Ellipse.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <geometry/MakeGeom3Ellipse.hpp>\n#include <geometry/MakeGeom3Hyperbola.hpp>\n#include <geometry/Geom2Line.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include<modeling/MakeEdge.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/MakeGeom2Parabola.hpp>\n#include <geometry/MakeGeom3Parabola.hpp>\n#include <geometry/Geom2BezierCurve.hpp>\n#include <geometry/Geom3BezierCurve.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2OffsetCurve.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\nTEST_CASE(\"test the arc length is negative - given arc length - 2D\", \"[geometry][ComputePointsAbscissa][case9]\")\n{\n\tSECTION(\"circle\")\n    {\n        double r = 2.0;\n        double l = -1.0;\n        std::shared_ptr<Geom2Curve> c = MakeGeom2Circle(Point2(0.0, 0.0), 2.0).Value();\n        AdaptorGeom2Curve circle(c);\n        ComputePointsAbscissa cpa(circle, -1.0, 0.0);\n        double angle1 = l / r;\n        double x = r * cos(angle1);\n        double y = r * sin(angle1);\n        double param = cpa.Parameter();\n        Point2 s = circle.Value(param);\n        Point2 s1(x, y);\n        CHECK(angle1 == cpa.Parameter());\n        CHECK(s.X() == s1.X());\n        CHECK(s.Y() == s1.Y());\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API ComputePointsAbscissa(double tol, const Adaptor3Curve& c, double abscissa, double u0)\t @param u0 The starting parameter\n\t @param abscissa The arc length\n\t @param c The curve\n\t @param tol The tolerance\n\t @brief Compute the parameter of a point on a 3D curve with given arc length and a tolerance\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/MakeGeom2Circle.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/ComputePointsAbscissa.hpp>\n#include <geometry/MakeGeom3Circle.hpp>\n#include <geometry/AdaptorGeom3Curve.hpp>\n#include <geometry/MakeGeom2Hyperbola.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/MakeGeom2Ellipse.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <geometry/MakeGeom3Ellipse.hpp>\n#include <geometry/MakeGeom3Hyperbola.hpp>\n#include <geometry/Geom2Line.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include<modeling/MakeEdge.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/MakeGeom2Parabola.hpp>\n#include <geometry/MakeGeom3Parabola.hpp>\n#include <geometry/Geom2BezierCurve.hpp>\n#include <geometry/Geom3BezierCurve.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2OffsetCurve.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\nTEST_CASE(\"test the arc length is negative - given arc length - 2D\", \"[geometry][ComputePointsAbscissa][case9]\")\n{\n\tSECTION(\"circle\")\n    {\n        double r = 2.0;\n        double l = -1.0;\n        std::shared_ptr<Geom2Curve> c = MakeGeom2Circle(Point2(0.0, 0.0), 2.0).Value();\n        AdaptorGeom2Curve circle(c);\n        ComputePointsAbscissa cpa(circle, -1.0, 0.0);\n        double angle1 = l / r;\n        double x = r * cos(angle1);\n        double y = r * sin(angle1);\n        double param = cpa.Parameter();\n        Point2 s = circle.Value(param);\n        Point2 s1(x, y);\n        CHECK(angle1 == cpa.Parameter());\n        CHECK(s.X() == s1.X());\n        CHECK(s.Y() == s1.Y());\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static double Length(const Adaptor2Curve& c, double u1, double u2, double tol)\t @return The length of a curve in a given interval\n\t @param tol The tolerance\n\t @param u2 The last parameter\n\t @param u1 The first parameter\n\t @param c The curve\n\t @brief Compute the length of a 2D curve in a given interval with a tolerance\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/MakeGeom2Circle.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/ComputePointsAbscissa.hpp>\n#include <geometry/MakeGeom3Circle.hpp>\n#include <geometry/AdaptorGeom3Curve.hpp>\n#include <geometry/MakeGeom2Hyperbola.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/MakeGeom2Ellipse.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <geometry/MakeGeom3Ellipse.hpp>\n#include <geometry/MakeGeom3Hyperbola.hpp>\n#include <geometry/Geom2Line.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include<modeling/MakeEdge.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/MakeGeom2Parabola.hpp>\n#include <geometry/MakeGeom3Parabola.hpp>\n#include <geometry/Geom2BezierCurve.hpp>\n#include <geometry/Geom3BezierCurve.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2OffsetCurve.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\nTEST_CASE(\"test the calculation of the parameters of a point on a 2D curve for a given arc length, initial guess parameters and tolerances and the length of the 2D curve in a given interval, as well as the length of the 2D curve for a given interval and tolerances\", \"[geometry][ComputePointsAbscissa][case4]\")\n{\n\tSECTION(\"circle\")\n    {\n        double r = 3.0;\n        double l = 2.0;\n        std::shared_ptr<Geom2Curve> c = MakeGeom2Circle(Point2(0.0, 0.0), 3.0).Value();\n        AdaptorGeom2Curve circle(c);\n        ComputePointsAbscissa cpa(circle, 2.0, 0.0, 1.5, Precision::Confusion());\n        double angle1 = l / r;\n        std::cout << \"??????\" << \": \" << angle1 << '\n';\n        double x = r * cos(angle1);\n        double y = r * sin(angle1);\n        std::cout << \"x??\" << \": \" << x << '\n';\n        std::cout << \"y??\" << \": \" << y << '\n';\n        double param = cpa.Parameter();\n        if (cpa.IsDone())\n        {\n            std::cout << param << \": \" << circle.Value(param) << '\n';\n        }\n        Point2 s = circle.Value(param);\n        Point2 s1(x, y);\n        std::cout << s << std::endl;\n        CHECK(s.X() == s1.X());\n        CHECK(s.Y() == s1.Y());\n        std::cout << \"????\" << ComputePointsAbscissa::Length(circle, 0.0, 0.666667) << '\n';\n        std::cout << \"?????\" << ComputePointsAbscissa::Length(circle, 0.0, 0.666667, Precision::Confusion()) << '\n';\n        CHECK(angle1 == cpa.Parameter());\n        CHECK(ComputePointsAbscissa::Length(circle, 0.0, 0.6666666667) == Approx(l).margin(1e-2));\n        CHECK(ComputePointsAbscissa::Length(circle, 0.0, 0.6666666667, Precision::Confusion()) == Approx(l).margin(1e-2));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static double Length(const Adaptor3Curve& c, double u1, double u2, double tol)\t @return The length of a curve in a given interval\n\t @param tol The tolerance\n\t @param u2 The last parameter\n\t @param u1 The first parameter\n\t @param c The curve\n\t @brief Compute the length of a 3D curve in a given interval with a tolerance\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/MakeGeom2Circle.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/ComputePointsAbscissa.hpp>\n#include <geometry/MakeGeom3Circle.hpp>\n#include <geometry/AdaptorGeom3Curve.hpp>\n#include <geometry/MakeGeom2Hyperbola.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/MakeGeom2Ellipse.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <geometry/MakeGeom3Ellipse.hpp>\n#include <geometry/MakeGeom3Hyperbola.hpp>\n#include <geometry/Geom2Line.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include<modeling/MakeEdge.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/MakeGeom2Parabola.hpp>\n#include <geometry/MakeGeom3Parabola.hpp>\n#include <geometry/Geom2BezierCurve.hpp>\n#include <geometry/Geom3BezierCurve.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2OffsetCurve.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\nTEST_CASE(\"test the calculation of the parameters of a point on a 2D curve for a given arc length, initial guess parameters and tolerances and the length of the 2D curve in a given interval, as well as the length of the 2D curve for a given interval and tolerances\", \"[geometry][ComputePointsAbscissa][case4]\")\n{\n\tSECTION(\"line\")\n    {\n        shared_ptr<Geom2Line> line;\n        line = make_shared<Geom2Line>(Point2(0.0, 0.0), Direction2(1.0, 0.0));\n        shared_ptr<Geom2TrimmedCurve> TrimmedCurve = make_shared<Geom2TrimmedCurve>(line, 0.0, 6.0);\n        AdaptorGeom2Curve line1(TrimmedCurve);\n        ComputePointsAbscissa cpa4(line1, 2.0, 0.0, 2.0, Precision::Confusion());\n        double param4 = cpa4.Parameter();\n        if (cpa4.IsDone())\n        {\n            std::cout << param4 << \": \" << line1.Value(param4) << '\n';\n        }\n        double x = 2.0;\n        double y = 0.0;\n        Point2 s5 = line1.Value(param4);\n        Point2 s6(x, y);\n        std::cout << s5 << std::endl;\n        CHECK(cpa4.Parameter() == 2.0);\n        CHECK(s5.X() == s6.X());\n        CHECK(s5.Y() == s6.Y());\n        std::cout << \"????\" << ComputePointsAbscissa::Length(line1, 0.0, 2.0) << '\n';\n        std::cout << \"?????\" << ComputePointsAbscissa::Length(line1, 0.0, 3.0, Precision::Confusion()) << '\n';\n        CHECK(ComputePointsAbscissa::Length(line1, 0.0, 2.0) == 2.0);\n        CHECK(ComputePointsAbscissa::Length(line1, 0.0, 3.0, Precision::Confusion()) == 3.0);\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static double Length(const Adaptor2Curve& c, double u1, double u2)\t @return The length of a curve in a given interval\n\t @param u2 The last parameter\n\t @param u1 The first parameter\n\t @param c The curve\n\t @brief Compute the length of a 2D curve in a given interval\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/MakeGeom2Circle.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/ComputePointsAbscissa.hpp>\n#include <geometry/MakeGeom3Circle.hpp>\n#include <geometry/AdaptorGeom3Curve.hpp>\n#include <geometry/MakeGeom2Hyperbola.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/MakeGeom2Ellipse.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <geometry/MakeGeom3Ellipse.hpp>\n#include <geometry/MakeGeom3Hyperbola.hpp>\n#include <geometry/Geom2Line.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include<modeling/MakeEdge.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/MakeGeom2Parabola.hpp>\n#include <geometry/MakeGeom3Parabola.hpp>\n#include <geometry/Geom2BezierCurve.hpp>\n#include <geometry/Geom3BezierCurve.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2OffsetCurve.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\nTEST_CASE(\"tset the calculation of the parameters of a point on a 3D curve for a given arc length, initial guess parameters and tolerances and the length of the 3D curve within a given interval, as well as the length of the 3D curve for a given interval and tolerances\", \"[geometry][ComputePointsAbscissa][case8]\")\n{\n\tSECTION(\"line\")\n    {\n        double t = 2.0;\n        shared_ptr<Geom3Line> line;\n        line = make_shared<Geom3Line>(Point3(0.0, 0.0, 0.0), Direction3(1.0, 2.0, 3.0));\n        shared_ptr<Geom3TrimmedCurve> TrimmedCurve = make_shared<Geom3TrimmedCurve>(line, 0.0, 6.0);\n        AdaptorGeom3Curve line1(TrimmedCurve);\n        ComputePointsAbscissa cpa4(line1, 2.0, 0.0, 2.0, Precision::Confusion());\n        double param4 = cpa4.Parameter();\n        if (cpa4.IsDone())\n        {\n            std::cout << param4 << \": \" << line1.Value(param4) << '\n';\n        }\n        Point3 start(0.0, 0.0, 0.0);\n        Direction3 direction(1.0, 2.0, 3.0);\n        double x = start.X() + t * direction.X();\n        double y = start.Y() + t * direction.Y();\n        double z = start.Z() + t * direction.Z();\n        Point3 s5 = line1.Value(param4);\n        Point3 s6(x, y, z);\n        std::cout << s5 << std::endl;\n        CHECK(cpa4.Parameter() == 2.0);\n        CHECK(s5.X() == s6.X());\n        CHECK(s5.Y() == s6.Y());\n        CHECK(s5.Z() == s6.Z());\n        std::cout << \"????\" << ComputePointsAbscissa::Length(line1, 0.0, 2.0) << '\n';\n        std::cout << \"?????\" << ComputePointsAbscissa::Length(line1, 0.0, 2.0, Precision::Confusion()) << '\n';\n        CHECK(ComputePointsAbscissa::Length(line1, 0.0, 2.0) == 2.0);\n        CHECK(ComputePointsAbscissa::Length(line1, 0.0, 2.0, Precision::Confusion()) == 2.0);\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static double Length(const Adaptor3Curve& c, double u1, double u2)\t @return The length of a curve in a given interval\n\t @param u2 The last parameter\n\t @param u1 The first parameter\n\t @param c The curve\n\t @brief Compute the length of a 3D curve in a given interval\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/MakeGeom2Circle.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/ComputePointsAbscissa.hpp>\n#include <geometry/MakeGeom3Circle.hpp>\n#include <geometry/AdaptorGeom3Curve.hpp>\n#include <geometry/MakeGeom2Hyperbola.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/MakeGeom2Ellipse.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <geometry/MakeGeom3Ellipse.hpp>\n#include <geometry/MakeGeom3Hyperbola.hpp>\n#include <geometry/Geom2Line.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include<modeling/MakeEdge.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/MakeGeom2Parabola.hpp>\n#include <geometry/MakeGeom3Parabola.hpp>\n#include <geometry/Geom2BezierCurve.hpp>\n#include <geometry/Geom3BezierCurve.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2OffsetCurve.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\nTEST_CASE(\"tset the calculation of the parameters of a point on a 3D curve for a given arc length, initial guess parameters and tolerances and the length of the 3D curve within a given interval, as well as the length of the 3D curve for a given interval and tolerances\", \"[geometry][ComputePointsAbscissa][case8]\")\n{\n\tSECTION(\"line\")\n    {\n        double t = 2.0;\n        shared_ptr<Geom3Line> line;\n        line = make_shared<Geom3Line>(Point3(0.0, 0.0, 0.0), Direction3(1.0, 2.0, 3.0));\n        shared_ptr<Geom3TrimmedCurve> TrimmedCurve = make_shared<Geom3TrimmedCurve>(line, 0.0, 6.0);\n        AdaptorGeom3Curve line1(TrimmedCurve);\n        ComputePointsAbscissa cpa4(line1, 2.0, 0.0, 2.0, Precision::Confusion());\n        double param4 = cpa4.Parameter();\n        if (cpa4.IsDone())\n        {\n            std::cout << param4 << \": \" << line1.Value(param4) << '\n';\n        }\n        Point3 start(0.0, 0.0, 0.0);\n        Direction3 direction(1.0, 2.0, 3.0);\n        double x = start.X() + t * direction.X();\n        double y = start.Y() + t * direction.Y();\n        double z = start.Z() + t * direction.Z();\n        Point3 s5 = line1.Value(param4);\n        Point3 s6(x, y, z);\n        std::cout << s5 << std::endl;\n        CHECK(cpa4.Parameter() == 2.0);\n        CHECK(s5.X() == s6.X());\n        CHECK(s5.Y() == s6.Y());\n        CHECK(s5.Z() == s6.Z());\n        std::cout << \"????\" << ComputePointsAbscissa::Length(line1, 0.0, 2.0) << '\n';\n        std::cout << \"?????\" << ComputePointsAbscissa::Length(line1, 0.0, 2.0, Precision::Confusion()) << '\n';\n        CHECK(ComputePointsAbscissa::Length(line1, 0.0, 2.0) == 2.0);\n        CHECK(ComputePointsAbscissa::Length(line1, 0.0, 2.0, Precision::Confusion()) == 2.0);\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static double Length(const Adaptor2Curve& c, double tol)\t @return The length of a curve\n\t @param tol The tolerance\n\t @param c The curve\n\t @brief Compute the length of a 2D curve with a tolerance\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/MakeGeom2Circle.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/ComputePointsAbscissa.hpp>\n#include <geometry/MakeGeom3Circle.hpp>\n#include <geometry/AdaptorGeom3Curve.hpp>\n#include <geometry/MakeGeom2Hyperbola.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/MakeGeom2Ellipse.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <geometry/MakeGeom3Ellipse.hpp>\n#include <geometry/MakeGeom3Hyperbola.hpp>\n#include <geometry/Geom2Line.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include<modeling/MakeEdge.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/MakeGeom2Parabola.hpp>\n#include <geometry/MakeGeom3Parabola.hpp>\n#include <geometry/Geom2BezierCurve.hpp>\n#include <geometry/Geom3BezierCurve.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2OffsetCurve.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\nTEST_CASE(\"test the calculation of the parameters of a point on a 2D curve for a given arc length, initial guess parameters and tolerances and the length of the 2D curve in a given interval, as well as the length of the 2D curve for a given interval and tolerances\", \"[geometry][ComputePointsAbscissa][case4]\")\n{\n\tSECTION(\"circle\")\n    {\n        double r = 3.0;\n        double l = 2.0;\n        std::shared_ptr<Geom2Curve> c = MakeGeom2Circle(Point2(0.0, 0.0), 3.0).Value();\n        AdaptorGeom2Curve circle(c);\n        ComputePointsAbscissa cpa(circle, 2.0, 0.0, 1.5, Precision::Confusion());\n        double angle1 = l / r;\n        std::cout << \"??????\" << \": \" << angle1 << '\n';\n        double x = r * cos(angle1);\n        double y = r * sin(angle1);\n        std::cout << \"x??\" << \": \" << x << '\n';\n        std::cout << \"y??\" << \": \" << y << '\n';\n        double param = cpa.Parameter();\n        if (cpa.IsDone())\n        {\n            std::cout << param << \": \" << circle.Value(param) << '\n';\n        }\n        Point2 s = circle.Value(param);\n        Point2 s1(x, y);\n        std::cout << s << std::endl;\n        CHECK(s.X() == s1.X());\n        CHECK(s.Y() == s1.Y());\n        std::cout << \"????\" << ComputePointsAbscissa::Length(circle, 0.0, 0.666667) << '\n';\n        std::cout << \"?????\" << ComputePointsAbscissa::Length(circle, 0.0, 0.666667, Precision::Confusion()) << '\n';\n        CHECK(angle1 == cpa.Parameter());\n        CHECK(ComputePointsAbscissa::Length(circle, 0.0, 0.6666666667) == Approx(l).margin(1e-2));\n        CHECK(ComputePointsAbscissa::Length(circle, 0.0, 0.6666666667, Precision::Confusion()) == Approx(l).margin(1e-2));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API static double Length(const Adaptor3Curve& c, double tol)\t @return The length of a curve\n\t @param tol The tolerance\n\t @param c The curve\n\t @brief Compute the length of a 3D curve with a tolerance\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/MakeGeom2Circle.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/ComputePointsAbscissa.hpp>\n#include <geometry/MakeGeom3Circle.hpp>\n#include <geometry/AdaptorGeom3Curve.hpp>\n#include <geometry/MakeGeom2Hyperbola.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/MakeGeom2Ellipse.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <geometry/MakeGeom3Ellipse.hpp>\n#include <geometry/MakeGeom3Hyperbola.hpp>\n#include <geometry/Geom2Line.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include<modeling/MakeEdge.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/MakeGeom2Parabola.hpp>\n#include <geometry/MakeGeom3Parabola.hpp>\n#include <geometry/Geom2BezierCurve.hpp>\n#include <geometry/Geom3BezierCurve.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2OffsetCurve.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\nTEST_CASE(\"test the parameters for calculating a point on a 3D curve with a given arc length and tolerance, and the length of the 3D curve with tolerance.\", \"[geometry][ComputePointsAbscissa][case6]\")\n{\n\tSECTION(\"ellipse\")\n    {\n        Frame3 frame;\n        double major = 5.0;\n        double minor = 4.0;\n        bool isRight = true;\n        std::shared_ptr< Geom3Ellipse >g2e = MakeGeom3Ellipse(frame, major, minor);\n        AdaptorGeom3Curve ellipse(g2e);\n        double t = minor / major;\n        std::cout << \"t\" << t << '\n';\n        double T = 3.15129643210828;\n        double L = T * (minor + major);\n        std::cout << \"L\" << L << '\n';\n        ComputePointsAbscissa cpa2(Precision::Confusion(), ellipse, L, 0.0);\n        double param2 = cpa2.Parameter();\n        if (cpa2.IsDone())\n        {\n            std::cout << param2 << \": \" << ellipse.Value(param2) << '\n';\n        }\n        Point3 s2 = ellipse.Value(param2);\n        Point3 s3(5.0, 0.0, 0.0);\n        std::cout << s2 << std::endl;\n        CHECK(s2.X() == Approx(s3.X()).margin(1e-2));\n        CHECK(s2.Y() == Approx(s3.Y()).margin(1e-2));\n        CHECK(s2.Z() == Approx(s3.Z()).margin(1e-2));\n        std::cout << \"??\" << ComputePointsAbscissa::Length(ellipse, Precision::Confusion()) << '\n';\n        CHECK(ComputePointsAbscissa::Length(ellipse,Precision::Confusion()) == Approx(L).margin(1e-2));\n        CHECK(cpa2.Parameter() == Approx(2 * M_PI).margin(1e-2));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API double Parameter()\t @return The parameter of the point\n\t @brief Get the parameter of the point\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/MakeGeom2Circle.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/ComputePointsAbscissa.hpp>\n#include <geometry/MakeGeom3Circle.hpp>\n#include <geometry/AdaptorGeom3Curve.hpp>\n#include <geometry/MakeGeom2Hyperbola.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/MakeGeom2Ellipse.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <geometry/MakeGeom3Ellipse.hpp>\n#include <geometry/MakeGeom3Hyperbola.hpp>\n#include <geometry/Geom2Line.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include<modeling/MakeEdge.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/MakeGeom2Parabola.hpp>\n#include <geometry/MakeGeom3Parabola.hpp>\n#include <geometry/Geom2BezierCurve.hpp>\n#include <geometry/Geom3BezierCurve.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2OffsetCurve.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\nTEST_CASE(\"test the parameters for calculating a point on a 3D curve with a given arc length and tolerance, and the length of the 3D curve with tolerance.\", \"[geometry][ComputePointsAbscissa][case6]\")\n{\n\tSECTION(\"bezier\")\n    {\n        std::vector<Point3> pts3 = {\n       Point3(0.0, 0.0,0.0),\n       Point3(2.0, 2.0,2.0),\n       Point3(4.0, 3.0,5.0),\n       Point3(6.0,2.0,4.0)\n        };\n        std::shared_ptr<Geom3BezierCurve> bez3 = make_shared<Geom3BezierCurve>(pts3);\n        AdaptorGeom3Curve b2(bez3);\n        ComputePointsAbscissa cpa6(Precision::Confusion(), b2, 2.0, 0.0);\n        double param6 = cpa6.Parameter();\n        if (cpa6.IsDone())\n        {\n            std::cout << param6 << \": \" << b2.Value(param6) << '\n';\n        }\n        Point3 s7 = b2.Value(param6);\n        std::cout << s7 << std::endl;\n        CHECK(cpa6.Parameter() != 0);\n        MakeEdge edge2(bez3);\n        CHECK(BRepClassificationTools::IsPointInOnEdge(edge2, s7, 0.001) == true);\n        std::cout << \"??\" << ComputePointsAbscissa::Length(b2, Precision::Confusion()) << '\n';\n        GlobalProperty props1;\n        TopoShape result1 = MakeEdge(bez3);\n        CHECK(GetLinearProperties(result1, props1, true, true) == Approx(ComputePointsAbscissa::Length(b2, Precision::Confusion())).margin(0.1));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API ComputePointsAbscissa(const Adaptor2Curve& c, double abscissa, double u0, double ui, double tol)\t @param tol The tolerance\n\t @param ui The initial guess of the parameter\n\t @param u0 The starting parameter\n\t @param abscissa The arc length\n\t @param c The curve\n\t @brief Compute the parameter of a point on a 2D curve with given arc length, an initial guess, and a tolerance\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/MakeGeom2Circle.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/ComputePointsAbscissa.hpp>\n#include <geometry/MakeGeom3Circle.hpp>\n#include <geometry/AdaptorGeom3Curve.hpp>\n#include <geometry/MakeGeom2Hyperbola.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/MakeGeom2Ellipse.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <geometry/MakeGeom3Ellipse.hpp>\n#include <geometry/MakeGeom3Hyperbola.hpp>\n#include <geometry/Geom2Line.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include<modeling/MakeEdge.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/MakeGeom2Parabola.hpp>\n#include <geometry/MakeGeom3Parabola.hpp>\n#include <geometry/Geom2BezierCurve.hpp>\n#include <geometry/Geom3BezierCurve.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2OffsetCurve.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\nTEST_CASE(\"test the parameters for calculating a point on a 2D curve with a given arc length and the length of the 2D curve.\", \"[geometry][ComputePointsAbscissa][case1]\")\n{\n\tSECTION(\"circle\")\n    {\n        double r = 2.0;\n        double l = 1.0;\n        std::shared_ptr<Geom2Curve> c = MakeGeom2Circle(Point2(0.0, 0.0), 2.0).Value();\n        AdaptorGeom2Curve circle(c);\n        ComputePointsAbscissa cpa(circle, 1.0, 0.0);\n        double angle1 = l / r;\n        std::cout << \"??????\" << \": \" << angle1 << '\n';\n        double x = r * cos(angle1);\n        double y = r * sin(angle1);\n        std::cout << \"x??\" << \": \" << x << '\n';\n        std::cout << \"y??\" << \": \" << y << '\n';\n        double param = cpa.Parameter();\n        if (cpa.IsDone())\n        {\n            std::cout << param << \": \" << circle.Value(param) << '\n';\n        }\n        double p = 2 * M_PI * r;\n        std::cout << \"??\" << ComputePointsAbscissa::Length(circle) << '\n';\n        Point2 s = circle.Value(param);\n        Point2 s1(x, y);\n        std::cout << s << std::endl;\n        CHECK(p == ComputePointsAbscissa::Length(circle));\n        CHECK(angle1 == cpa.Parameter());\n        CHECK(s.X() == s1.X());\n        CHECK(s.Y() == s1.Y());\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API ComputePointsAbscissa(const Adaptor3Curve& c, double abscissa, double u0, double ui, double tol)\t @param tol The tolerance\n\t @param ui The initial guess of the parameter\n\t @param u0 The starting parameter\n\t @param abscissa The arc length\n\t @param c The curve\n\t @brief Compute the parameter of a point on a 3D curve with given arc length, an initial guess, and a tolerance\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/MakeGeom2Circle.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/ComputePointsAbscissa.hpp>\n#include <geometry/MakeGeom3Circle.hpp>\n#include <geometry/AdaptorGeom3Curve.hpp>\n#include <geometry/MakeGeom2Hyperbola.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/MakeGeom2Ellipse.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <geometry/MakeGeom3Ellipse.hpp>\n#include <geometry/MakeGeom3Hyperbola.hpp>\n#include <geometry/Geom2Line.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include<modeling/MakeEdge.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/MakeGeom2Parabola.hpp>\n#include <geometry/MakeGeom3Parabola.hpp>\n#include <geometry/Geom2BezierCurve.hpp>\n#include <geometry/Geom3BezierCurve.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2OffsetCurve.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\nTEST_CASE(\"tset the parameters for calculating a point on a 3D curve of a given arc length and the length of the 3D curve.\", \"[geometry][ComputePointsAbscissa][case5]\")\n{\n\tSECTION(\"offset curve\")\n    {\n        Frame3 frame;\n        double r = 2.0;\n        std::shared_ptr<Geom3Curve> c = MakeGeom3Circle(frame, r).Value();\n        shared_ptr<Geom3OffsetCurve> curve;\n        double offset = -1.0;\n        Direction3 direction(0.0, 0.0, 1.0);\n        curve = make_shared<Geom3OffsetCurve>(c, offset, direction);\n        double r2 = r + offset;\n        double p = 2 * M_PI * r2;\n        double l = 2.0;\n        AdaptorGeom3Curve offs(curve);\n        ComputePointsAbscissa cpa8(offs, 2.0, 0.0);\n        double angle1 = l / r2;\n        std::cout << \"??????\" << \": \" << angle1 << '\n';\n        double x = r2 * cos(angle1);\n        double y = r2 * sin(angle1);\n        double z = 0.0;\n        std::cout << \"x??\" << \": \" << x << '\n';\n        std::cout << \"y??\" << \": \" << y << '\n';\n        double param8 = cpa8.Parameter();\n        if (cpa8.IsDone())\n        {\n            std::cout << param8 << \": \" << offs.Value(param8) << '\n';\n        }\n        Point3 s = offs.Value(param8);\n        Point3 s1(x, y, z);\n        std::cout << s << std::endl;\n        CHECK(s.X() == Approx(s1.X()).margin(1e-2));\n        CHECK(s.Y() == Approx(s1.Y()).margin(1e-2));\n        CHECK(s.Z() == Approx(s1.Z()).margin(1e-2));\n        std::cout << \"??\" << ComputePointsAbscissa::Length(offs) << '\n';\n        CHECK(ComputePointsAbscissa::Length(offs) == Approx(p).margin(1e-2));\n    }\n}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API ComputePointsAbscissa(const Adaptor2Curve& c, double abscissa, double u0, double ui)\t @param ui The initial guess of the parameter\n\t @param u0 The starting parameter\n\t @param abscissa The arc length\n\t @param c The curve\n\t @brief Compute the parameter of a point on a 2D curve with given arc length and an initial guess\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/MakeGeom2Circle.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/ComputePointsAbscissa.hpp>\n#include <geometry/MakeGeom3Circle.hpp>\n#include <geometry/AdaptorGeom3Curve.hpp>\n#include <geometry/MakeGeom2Hyperbola.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/MakeGeom2Ellipse.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <geometry/MakeGeom3Ellipse.hpp>\n#include <geometry/MakeGeom3Hyperbola.hpp>\n#include <geometry/Geom2Line.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include<modeling/MakeEdge.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/MakeGeom2Parabola.hpp>\n#include <geometry/MakeGeom3Parabola.hpp>\n#include <geometry/Geom2BezierCurve.hpp>\n#include <geometry/Geom3BezierCurve.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2OffsetCurve.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\nTEST_CASE(\"test the parameters for calculating a point on a 2D curve with a given arc length and the length of the 2D curve.\", \"[geometry][ComputePointsAbscissa][case1]\")\n{\n\tSECTION(\"circle\")\n    {\n        double r = 2.0;\n        double l = 1.0;\n        std::shared_ptr<Geom2Curve> c = MakeGeom2Circle(Point2(0.0, 0.0), 2.0).Value();\n        AdaptorGeom2Curve circle(c);\n        ComputePointsAbscissa cpa(circle, 1.0, 0.0);\n        double angle1 = l / r;\n        std::cout << \"??????\" << \": \" << angle1 << '\n';\n        double x = r * cos(angle1);\n        double y = r * sin(angle1);\n        std::cout << \"x??\" << \": \" << x << '\n';\n        std::cout << \"y??\" << \": \" << y << '\n';\n        double param = cpa.Parameter();\n        if (cpa.IsDone())\n        {\n            std::cout << param << \": \" << circle.Value(param) << '\n';\n        }\n        double p = 2 * M_PI * r;\n        std::cout << \"??\" << ComputePointsAbscissa::Length(circle) << '\n';\n        Point2 s = circle.Value(param);\n        Point2 s1(x, y);\n        std::cout << s << std::endl;\n        CHECK(p == ComputePointsAbscissa::Length(circle));\n        CHECK(angle1 == cpa.Parameter());\n        CHECK(s.X() == s1.X());\n        CHECK(s.Y() == s1.Y());\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API ComputePointsAbscissa(const Adaptor3Curve& c, double abscissa, double u0, double ui)\t @param ui The initial guess of the parameter\n\t @param u0 The starting parameter\n\t @param abscissa The arc length\n\t @param c The curve\n\t @brief Compute the parameter of a point on a 3D curve with given arc length and an initial guess\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/MakeGeom2Circle.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/ComputePointsAbscissa.hpp>\n#include <geometry/MakeGeom3Circle.hpp>\n#include <geometry/AdaptorGeom3Curve.hpp>\n#include <geometry/MakeGeom2Hyperbola.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/MakeGeom2Ellipse.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <geometry/MakeGeom3Ellipse.hpp>\n#include <geometry/MakeGeom3Hyperbola.hpp>\n#include <geometry/Geom2Line.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include<modeling/MakeEdge.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/MakeGeom2Parabola.hpp>\n#include <geometry/MakeGeom3Parabola.hpp>\n#include <geometry/Geom2BezierCurve.hpp>\n#include <geometry/Geom3BezierCurve.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2OffsetCurve.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\nTEST_CASE(\"tset the parameters for calculating a point on a 3D curve of a given arc length and the length of the 3D curve.\", \"[geometry][ComputePointsAbscissa][case5]\")\n{\n\tSECTION(\"circle\")\n    {\n        Frame3 frame;\n        double r = 2.0;\n        double l = 1.0;\n        std::shared_ptr<Geom3Curve> c = MakeGeom3Circle(frame, r).Value();\n        AdaptorGeom3Curve circle(c);\n        ComputePointsAbscissa cpa(circle, 1.0, 0.0);\n        double angle1 = l / r;\n        std::cout << \"??????\" << \": \" << angle1 << '\n';\n        double x = r * cos(angle1);\n        double y = r * sin(angle1);\n        double z = 0;\n        std::cout << \"x??\" << \": \" << x << '\n';\n        std::cout << \"y??\" << \": \" << y << '\n';\n        std::cout << \"z??\" << \": \" << z << '\n';\n        double param = cpa.Parameter();\n        if (cpa.IsDone())\n        {\n            std::cout << param << \": \" << circle.Value(param) << '\n';\n        }\n        double p = 2 * M_PI * r;\n        std::cout << \"??\" << ComputePointsAbscissa::Length(circle) << '\n';\n        Point3 s = circle.Value(param);\n        Point3 s1(x, y, z);\n        std::cout << s << std::endl;\n        CHECK(p == ComputePointsAbscissa::Length(circle));\n        CHECK(angle1 == cpa.Parameter());\n        CHECK(s.X() == s1.X());\n        CHECK(s.Y() == s1.Y());\n        CHECK(s.Z() == s1.Z());\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API ComputePointsAbscissa(const Adaptor2Curve& c, double abscissa, double u0)\t @param u0 The starting parameter\n\t @param abscissa The arc length\n\t @param c The curve\n\t @brief Compute the parameter of a point on a 2D curve with given arc length\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/MakeGeom2Circle.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/ComputePointsAbscissa.hpp>\n#include <geometry/MakeGeom3Circle.hpp>\n#include <geometry/AdaptorGeom3Curve.hpp>\n#include <geometry/MakeGeom2Hyperbola.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/MakeGeom2Ellipse.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <geometry/MakeGeom3Ellipse.hpp>\n#include <geometry/MakeGeom3Hyperbola.hpp>\n#include <geometry/Geom2Line.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include<modeling/MakeEdge.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/MakeGeom2Parabola.hpp>\n#include <geometry/MakeGeom3Parabola.hpp>\n#include <geometry/Geom2BezierCurve.hpp>\n#include <geometry/Geom3BezierCurve.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2OffsetCurve.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\nTEST_CASE(\"test the parameters for calculating a point on a 2D curve with a given arc length and the length of the 2D curve.\", \"[geometry][ComputePointsAbscissa][case1]\")\n{\n\tSECTION(\"circle\")\n    {\n        double r = 2.0;\n        double l = 1.0;\n        std::shared_ptr<Geom2Curve> c = MakeGeom2Circle(Point2(0.0, 0.0), 2.0).Value();\n        AdaptorGeom2Curve circle(c);\n        ComputePointsAbscissa cpa(circle, 1.0, 0.0);\n        double angle1 = l / r;\n        std::cout << \"??????\" << \": \" << angle1 << '\n';\n        double x = r * cos(angle1);\n        double y = r * sin(angle1);\n        std::cout << \"x??\" << \": \" << x << '\n';\n        std::cout << \"y??\" << \": \" << y << '\n';\n        double param = cpa.Parameter();\n        if (cpa.IsDone())\n        {\n            std::cout << param << \": \" << circle.Value(param) << '\n';\n        }\n        double p = 2 * M_PI * r;\n        std::cout << \"??\" << ComputePointsAbscissa::Length(circle) << '\n';\n        Point2 s = circle.Value(param);\n        Point2 s1(x, y);\n        std::cout << s << std::endl;\n        CHECK(p == ComputePointsAbscissa::Length(circle));\n        CHECK(angle1 == cpa.Parameter());\n        CHECK(s.X() == s1.X());\n        CHECK(s.Y() == s1.Y());\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API ComputePointsAbscissa(const Adaptor3Curve& c, double abscissa, double u0)\t @param u0 The starting parameter\n\t @param abscissa The arc length\n\t @param c The curve\n\t @brief Compute the parameter of a point on a 3D curve with given arc length\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/MakeGeom2Circle.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/ComputePointsAbscissa.hpp>\n#include <geometry/MakeGeom3Circle.hpp>\n#include <geometry/AdaptorGeom3Curve.hpp>\n#include <geometry/MakeGeom2Hyperbola.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/MakeGeom2Ellipse.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <geometry/MakeGeom3Ellipse.hpp>\n#include <geometry/MakeGeom3Hyperbola.hpp>\n#include <geometry/Geom2Line.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include<modeling/MakeEdge.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/MakeGeom2Parabola.hpp>\n#include <geometry/MakeGeom3Parabola.hpp>\n#include <geometry/Geom2BezierCurve.hpp>\n#include <geometry/Geom3BezierCurve.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2OffsetCurve.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\nTEST_CASE(\"tset the parameters for calculating a point on a 3D curve of a given arc length and the length of the 3D curve.\", \"[geometry][ComputePointsAbscissa][case5]\")\n{\n\tSECTION(\"circle\")\n    {\n        Frame3 frame;\n        double r = 2.0;\n        double l = 1.0;\n        std::shared_ptr<Geom3Curve> c = MakeGeom3Circle(frame, r).Value();\n        AdaptorGeom3Curve circle(c);\n        ComputePointsAbscissa cpa(circle, 1.0, 0.0);\n        double angle1 = l / r;\n        std::cout << \"??????\" << \": \" << angle1 << '\n';\n        double x = r * cos(angle1);\n        double y = r * sin(angle1);\n        double z = 0;\n        std::cout << \"x??\" << \": \" << x << '\n';\n        std::cout << \"y??\" << \": \" << y << '\n';\n        std::cout << \"z??\" << \": \" << z << '\n';\n        double param = cpa.Parameter();\n        if (cpa.IsDone())\n        {\n            std::cout << param << \": \" << circle.Value(param) << '\n';\n        }\n        double p = 2 * M_PI * r;\n        std::cout << \"??\" << ComputePointsAbscissa::Length(circle) << '\n';\n        Point3 s = circle.Value(param);\n        Point3 s1(x, y, z);\n        std::cout << s << std::endl;\n        CHECK(p == ComputePointsAbscissa::Length(circle));\n        CHECK(angle1 == cpa.Parameter());\n        CHECK(s.X() == s1.X());\n        CHECK(s.Y() == s1.Y());\n        CHECK(s.Z() == s1.Z());\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API ComputePointsAbscissa(double tol, const Adaptor2Curve& c, double abscissa, double u0)\t @param u0 The starting parameter\n\t @param abscissa The arc length\n\t @param c The curve\n\t @param tol The tolerance\n\t @brief Compute the parameter of a point on a 2D curve with given arc length and a tolerance\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/MakeGeom2Circle.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/ComputePointsAbscissa.hpp>\n#include <geometry/MakeGeom3Circle.hpp>\n#include <geometry/AdaptorGeom3Curve.hpp>\n#include <geometry/MakeGeom2Hyperbola.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/MakeGeom2Ellipse.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <geometry/MakeGeom3Ellipse.hpp>\n#include <geometry/MakeGeom3Hyperbola.hpp>\n#include <geometry/Geom2Line.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include<modeling/MakeEdge.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/MakeGeom2Parabola.hpp>\n#include <geometry/MakeGeom3Parabola.hpp>\n#include <geometry/Geom2BezierCurve.hpp>\n#include <geometry/Geom3BezierCurve.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2OffsetCurve.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\nTEST_CASE(\"test the parameters for calculating a point on a 2D curve with a given arc length and the length of the 2D curve.\", \"[geometry][ComputePointsAbscissa][case1]\")\n{\n\tSECTION(\"circle\")\n    {\n        double r = 2.0;\n        double l = 1.0;\n        std::shared_ptr<Geom2Curve> c = MakeGeom2Circle(Point2(0.0, 0.0), 2.0).Value();\n        AdaptorGeom2Curve circle(c);\n        ComputePointsAbscissa cpa(circle, 1.0, 0.0);\n        double angle1 = l / r;\n        std::cout << \"??????\" << \": \" << angle1 << '\n';\n        double x = r * cos(angle1);\n        double y = r * sin(angle1);\n        std::cout << \"x??\" << \": \" << x << '\n';\n        std::cout << \"y??\" << \": \" << y << '\n';\n        double param = cpa.Parameter();\n        if (cpa.IsDone())\n        {\n            std::cout << param << \": \" << circle.Value(param) << '\n';\n        }\n        double p = 2 * M_PI * r;\n        std::cout << \"??\" << ComputePointsAbscissa::Length(circle) << '\n';\n        Point2 s = circle.Value(param);\n        Point2 s1(x, y);\n        std::cout << s << std::endl;\n        CHECK(p == ComputePointsAbscissa::Length(circle));\n        CHECK(angle1 == cpa.Parameter());\n        CHECK(s.X() == s1.X());\n        CHECK(s.Y() == s1.Y());\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API ComputePointsAbscissa(double tol, const Adaptor3Curve& c, double abscissa, double u0)\t @param u0 The starting parameter\n\t @param abscissa The arc length\n\t @param c The curve\n\t @param tol The tolerance\n\t @brief Compute the parameter of a point on a 3D curve with given arc length and a tolerance\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <geometry/MakeGeom2Circle.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geometry/ComputePointsAbscissa.hpp>\n#include <geometry/MakeGeom3Circle.hpp>\n#include <geometry/AdaptorGeom3Curve.hpp>\n#include <geometry/MakeGeom2Hyperbola.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/MakeGeom2Ellipse.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <geometry/MakeGeom3Ellipse.hpp>\n#include <geometry/MakeGeom3Hyperbola.hpp>\n#include <geometry/Geom2Line.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom3Line.hpp>\n#include <geometry/Geom3TrimmedCurve.hpp>\n#include<modeling/MakeEdge.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <geometry/MakeGeom2Parabola.hpp>\n#include <geometry/MakeGeom3Parabola.hpp>\n#include <geometry/Geom2BezierCurve.hpp>\n#include <geometry/Geom3BezierCurve.hpp>\n#include <geometry/Geom2BSplineCurve.hpp>\n#include <geometry/Geom2OffsetCurve.hpp>\n#include <geometry/Geom3OffsetCurve.hpp>\nTEST_CASE(\"tset the parameters for calculating a point on a 3D curve of a given arc length and the length of the 3D curve.\", \"[geometry][ComputePointsAbscissa][case5]\")\n{\n\tSECTION(\"circle\")\n    {\n        Frame3 frame;\n        double r = 2.0;\n        double l = 1.0;\n        std::shared_ptr<Geom3Curve> c = MakeGeom3Circle(frame, r).Value();\n        AdaptorGeom3Curve circle(c);\n        ComputePointsAbscissa cpa(circle, 1.0, 0.0);\n        double angle1 = l / r;\n        std::cout << \"??????\" << \": \" << angle1 << '\n';\n        double x = r * cos(angle1);\n        double y = r * sin(angle1);\n        double z = 0;\n        std::cout << \"x??\" << \": \" << x << '\n';\n        std::cout << \"y??\" << \": \" << y << '\n';\n        std::cout << \"z??\" << \": \" << z << '\n';\n        double param = cpa.Parameter();\n        if (cpa.IsDone())\n        {\n            std::cout << param << \": \" << circle.Value(param) << '\n';\n        }\n        double p = 2 * M_PI * r;\n        std::cout << \"??\" << ComputePointsAbscissa::Length(circle) << '\n';\n        Point3 s = circle.Value(param);\n        Point3 s1(x, y, z);\n        std::cout << s << std::endl;\n        CHECK(p == ComputePointsAbscissa::Length(circle));\n        CHECK(angle1 == cpa.Parameter());\n        CHECK(s.X() == s1.X());\n        CHECK(s.Y() == s1.Y());\n        CHECK(s.Z() == s1.Z());\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API explicit MakeConic2FromConstraints(const std::vector<Conic2Constraint>& constraints)\t @param constraints The constraints of the conic. It is supported that the constraints contain 5 points, 4 points and 1 tangent, 3 points and 2 tangent\n\t @brief Build by point and tangent constraints. The number of constraints must be 5 in total and the start and the end point constraints are required\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <geomAlgo/MakeConic2FromConstraints.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <math/HyperbolaT.hpp>\n#include <geometry/Geom2Hyperbola.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/Geom2Circle.hpp>\n#include <geometry/GeomAPIProjectPointOnCurve3.hpp>\n#include <topology/BRepExtremaDistShapeShape.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <modeling/MakeEdge.hpp>\nTEST_CASE(\"bug1: MakeConic2FromConstraints \", \"[geomAlgo][MakeConic2FromConstraints][fixbug]\")\n{\n\tPoint2 a(0.0, 0.0);\n\tPoint2 b(1.0, 1.0);\n\tVector2 da(-0.5, 0.5);\n\tVector2 db(1.0, -0.2);\n\tPoint3 a1(a.X(), a.Y(), 0.0);\n\tPoint3 b1(b.X(), b.Y(), 0.0);\n\tVector3 da1(da.X(), da.Y(), 0.0);\n\tVector3 db1(db.X(), db.Y(), 0.0);\n\tConic2Constraint ca(a, da);\n\tConic2Constraint cb(b, db);\n\tMakeConic2FromConstraints mc2fc(ca, cb, 0.0);\n\tshared_ptr<Geom3Curve> curve;\n\tcurve = GeometryTool::To3d(Frame3(), mc2fc.Curve2d());\n\tCHECK(mc2fc.Curve2d() == nullptr);\n\tCHECK(curve == nullptr);\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API MakeConic2FromConstraints(const Conic2Constraint& startConstraint, const Conic2Constraint& endConstraint, double parameter)\t @param parameter The parameter to determine type and shape of the conic, valid range is (0.0, 1.0): ellipse if (0.0, 0.5), parabola if {0.5}, hyperbola if (0.5, 1.0)\n\t @param endConstraint The end point and tangent\n\t @param startConstraint The start point and tangent\n\t @brief Build by ending points and tangents and a parameter\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <geomAlgo/MakeConic2FromConstraints.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <math/HyperbolaT.hpp>\n#include <geometry/Geom2Hyperbola.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/Geom2Circle.hpp>\n#include <geometry/GeomAPIProjectPointOnCurve3.hpp>\n#include <topology/BRepExtremaDistShapeShape.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <modeling/MakeEdge.hpp>\nTEST_CASE(\"bug1: MakeConic2FromConstraints \", \"[geomAlgo][MakeConic2FromConstraints][fixbug]\")\n{\n\tPoint2 a(0.0, 0.0);\n\tPoint2 b(1.0, 1.0);\n\tVector2 da(-0.5, 0.5);\n\tVector2 db(1.0, -0.2);\n\tPoint3 a1(a.X(), a.Y(), 0.0);\n\tPoint3 b1(b.X(), b.Y(), 0.0);\n\tVector3 da1(da.X(), da.Y(), 0.0);\n\tVector3 db1(db.X(), db.Y(), 0.0);\n\tConic2Constraint ca(a, da);\n\tConic2Constraint cb(b, db);\n\tMakeConic2FromConstraints mc2fc(ca, cb, 0.0);\n\tshared_ptr<Geom3Curve> curve;\n\tcurve = GeometryTool::To3d(Frame3(), mc2fc.Curve2d());\n\tCHECK(mc2fc.Curve2d() == nullptr);\n\tCHECK(curve == nullptr);\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "explicit Conic2Constraint(const Point2& point)\t @param point The point constraint\n\t @brief Construct from a point constraint\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <geomAlgo/MakeConic2FromConstraints.hpp>\n#include <geometry/GeometryTool.hpp>\n#include <math/HyperbolaT.hpp>\n#include <geometry/Geom2Hyperbola.hpp>\n#include <geometry/Geom2TrimmedCurve.hpp>\n#include <geometry/Geom2Ellipse.hpp>\n#include <geometry/Geom2Parabola.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <geometry/Geom2Circle.hpp>\n#include <geometry/GeomAPIProjectPointOnCurve3.hpp>\n#include <topology/BRepExtremaDistShapeShape.hpp>\n#include <modeling/MakeVertex.hpp>\n#include <modeling/MakeEdge.hpp>\nTEST_CASE(\"bug1: MakeConic2FromConstraints \", \"[geomAlgo][MakeConic2FromConstraints][fixbug]\")\n{\n\tPoint2 a(0.0, 0.0);\n\tPoint2 b(1.0, 1.0);\n\tVector2 da(-0.5, 0.5);\n\tVector2 db(1.0, -0.2);\n\tPoint3 a1(a.X(), a.Y(), 0.0);\n\tPoint3 b1(b.X(), b.Y(), 0.0);\n\tVector3 da1(da.X(), da.Y(), 0.0);\n\tVector3 db1(db.X(), db.Y(), 0.0);\n\tConic2Constraint ca(a, da);\n\tConic2Constraint cb(b, db);\n\tMakeConic2FromConstraints mc2fc(ca, cb, 0.0);\n\tshared_ptr<Geom3Curve> curve;\n\tcurve = GeometryTool::To3d(Frame3(), mc2fc.Curve2d());\n\tCHECK(mc2fc.Curve2d() == nullptr);\n\tCHECK(curve == nullptr);\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API virtual std::shared_ptr<LawFunction> Trim(double fp, double lp, double tol)\t @return The new law\n\t @param tol The given tolerance, not all laws use this parameter\n\t @param lp The second parameter\n\t @param fp The first parameter\n\t @brief Get the trimmed law of this\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include<geomAlgo/LawConstant.hpp>\n#include<geomAlgo/LawFunction.hpp>\nusing namespace std;\nTEST_CASE(\"case1: this is a test case for LawConstant\", \"[geomAlgo][LawFunction][P1]\")\n{\n\tLawConstant cons;\n\tcons.Set(2.0, 4.0, 10.0);\n\tSECTION(\"Trim\")\n\t{\n\t\tshared_ptr<LawFunction>tr;\n\t\tdouble fp = 1.0;\n\t\tdouble lp = 5.0;\n\t\tdouble tol = 0.1;\n\t\tdouble fp1 = 0.0;\n\t\tdouble lp1 = 0.0;\n\t\ttr = cons.Trim(fp, lp, tol);\n\t\ttr->Bounds(fp1, lp1);\n\t\tCHECK(fp1 == fp);\n\t\tCHECK(lp1 == lp);\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API virtual void D1(double x, double& f, double& d)\t @param[out] d The function first derivative\n\t @param[out] f The function value\n\t @param[in] x The given parameter\n\t @brief Get the function first derivative at the given parameter\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include<geomAlgo/LawConstant.hpp>\n#include<geomAlgo/LawFunction.hpp>\nusing namespace std;\nTEST_CASE(\"case1: this is a test case for LawConstant\", \"[geomAlgo][LawFunction][P1]\")\n{\n\tLawConstant cons;\n\tcons.Set(2.0, 4.0, 10.0);\n\tSECTION(\"D1\")\n\t{\n\t\tdouble x = 1.0;\n\t\tdouble f = 0.0; \n\t\tdouble d = 0.0;\n\t\tcons.D1(x, f, d);\n\t\tCHECK(f == Approx(2.0));\n\t\tCHECK(d == Approx(0.0));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API GccCircle3Tangent(const Point2& point1, const Point2& point2, const Point2& point3, double tolerance)\t @param tolerance The tolerance\n\t @param point3 The third point\n\t @param point2 The second point\n\t @param point1 The first point\n\t @brief Construct a circle passing through three points\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <geomAlgo/GccCircle3Tangent.hpp>\n#include <geometry/Geom2Curve.hpp>\n#include <geometry/MakeGeom2Line.hpp>\n#include <geometry/MakeGeom2Circle.hpp>\n#include <geomAlgo/GccEntity.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geomAlgo/GccEntity.hpp>\n#include <geomAlgo/GccQualifiedCurve.hpp>\n#include <sstream>\nusing namespace AMCAX;\nTEST_CASE(\"bug1: GccCircle3Tangent  add 48 cases\", \"[geomAlgo][GccCircle3Tangent][fixbug]\") {\n\tstd::shared_ptr<Geom2Curve> l = MakeGeom2Line(Point2(0.0, 0.0), Point2(1.0, 0.0)).Value();\n\tstd::shared_ptr<Geom2Curve> c1 = MakeGeom2Circle(Point2(0.0, 3.0), 2.0).Value();\n\tstd::shared_ptr<Geom2Curve> c2 = MakeGeom2Circle(Point2(4.0, 3.0), 2.0).Value();\n\tAdaptorGeom2Curve line(l);\n\tAdaptorGeom2Curve circle1(c1);\n\tAdaptorGeom2Curve circle2(c2);\n\tauto lineEnclosed = GccEntity::Enclosed(line);\n\tauto lineOutside = GccEntity::Outside(line);\n\tauto lineUnqualified = GccEntity::Unqualified(line);\n\tauto circle1Enclosed = GccEntity::Enclosed(circle1);\n\tauto circle1Enclosing = GccEntity::Enclosing(circle1);\n\tauto circle1Outside = GccEntity::Outside(circle1);\n\tauto circle1Unqualified = GccEntity::Unqualified(circle1);\n\tauto circle2Enclosed = GccEntity::Enclosed(circle2);\n\tauto circle2Enclosing = GccEntity::Enclosing(circle2);\n\tauto circle2Outside = GccEntity::Outside(circle2);\n\tauto circle2Unqualified = GccEntity::Unqualified(circle2);\n\tauto gccl = GccEntity::Enclosed(AdaptorGeom2Curve(l));\n\tauto gccc1 = GccEntity::Enclosing(AdaptorGeom2Curve(c1));\n\tauto gccc2 = GccEntity::Outside(AdaptorGeom2Curve(c2));\n\tauto c3t = [](const GccQualifiedCurve& gccc1, const GccQualifiedCurve& gccc2, const GccQualifiedCurve& gccl)\n\t{\n\t\tstd::stringstream output;\n\t\tGccCircle3Tangent gcc(gccc1, gccc2, gccl, Precision::Confusion(), 0.0, 0.0, 0.0);\n\t\tstd::cout << \"Test case: \" << GccEntity::PositionToString(gccc1.Qualifier()) << ' ' << GccEntity::PositionToString(gccc2.Qualifier()) << ' ' << GccEntity::PositionToString(gccl.Qualifier()) << std::endl;\n\t\tstd::cout << \"Solution: \" << gcc.NSolutions() << std::endl;\n\t\toutput << \"Test case: \" << GccEntity::PositionToString(gccc1.Qualifier()) << ' ' << GccEntity::PositionToString(gccc2.Qualifier()) << ' ' << GccEntity::PositionToString(gccl.Qualifier()) << std::endl;\n\t\toutput << \"Solution: \" << gcc.NSolutions() << std::endl;\n\t\tif (gcc.IsDone())\n\t\t{\n\t\t\tfor (int i = 0; i < gcc.NSolutions(); i++)\n\t\t\t{\n\t\t\t\tGccPosition q1, q2, q3;\n\t\t\t\tgcc.Qualifier(i, q1, q2, q3);\n\t\t\t\toutput << i << \": \" << *MakeGeom2Circle(gcc.Solution(i)).Value() << std::endl;\n\t\t\t\toutput << \"  \" << GccEntity::PositionToString(q1) << ' ' << GccEntity::PositionToString(q2) << ' ' << GccEntity::PositionToString(q3) << std::endl;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tstd::cout << \"gcc.IsDone is False\" << std::endl;\n\t\t\toutput << \"gcc.IsDone is False\" << std::endl;\n\t\t}\n\t\treturn output.str();\n\t};\n\tauto case1 = c3t(circle1Enclosed, circle2Enclosed, lineEnclosed);\n\tauto expect1 = \"Test case: Enclosed Enclosed Enclosed\nSolution: 0\n\";\n\tCHECK(case1.find(expect1) != std::string::npos);\n\tauto case2 = c3t(circle1Enclosed, circle2Enclosed, lineOutside);\n\tauto expect2 = \"Test case: Enclosed Enclosed Outside\nSolution: 0\n\";\n\tCHECK(case2.find(expect2) != std::string::npos);\n\tauto case3 = c3t(circle1Enclosed, circle2Enclosed, lineUnqualified);\n\tauto expect3 = \"Test case: Enclosed Enclosed Unqualified\nSolution: 0\n\";\n\tCHECK(case3.find(expect3) != std::string::npos);\n\tauto case4 = c3t(circle1Enclosed, circle2Enclosing, lineEnclosed);\n\tauto expect4 = \"Test case: Enclosed Enclosing Enclosed\nSolution: 0\n\";\n\tCHECK(case4.find(expect4) != std::string::npos);\n\tauto case5 = c3t(circle1Enclosed, circle2Enclosing, lineOutside);\n\tauto expect5 = \"Test case: Enclosed Enclosing Outside\nSolution: 0\n\";\n\tCHECK(case5.find(expect5) != std::string::npos);\n\tauto case6 = c3t(circle1Enclosed, circle2Enclosing, lineUnqualified);\n\tauto expect6 = \"Test case: Enclosed Enclosing Unqualified\nSolution: 0\n\";\n\tCHECK(case6.find(expect6) != std::string::npos);\n\tauto case7 = c3t(circle1Enclosed, circle2Outside, lineEnclosed);\n\tauto expect7 = \"Test case: Enclosed Outside Enclosed\nSolution: 0\n\";\n\tCHECK(case7.find(expect7) != std::string::npos);\n\tauto case8 = c3t(circle1Enclosed, circle2Outside, lineOutside);\n\tauto expect8 = \"Test case: Enclosed Outside Outside\nSolution: 0\n\";\n\tCHECK(case8.find(expect8) != std::string::npos);\n\tauto case9 = c3t(circle1Enclosed, circle2Outside, lineUnqualified);\n\tauto expect9 = \"Test case: Enclosed Outside Unqualified\nSolution: 0\n\";\n\tCHECK(case9.find(expect9) != std::string::npos);\n\tauto case10 = c3t(circle1Enclosed, circle2Unqualified, lineEnclosed);\n\tauto expect10 = \"Test case: Enclosed Unqualified Enclosed\nSolution: 0\n\";\n\tCHECK(case10.find(expect10) != std::string::npos);\n\tauto case11 = c3t(circle1Enclosed, circle2Unqualified, lineOutside);\n\tauto expect11 = \"Test case: Enclosed Unqualified Outside\nSolution: 0\n\";\n\tCHECK(case11.find(expect11) != std::string::npos);\n\tauto case12 = c3t(circle1Enclosed, circle2Unqualified, lineUnqualified);\n\tauto expect12 = \"Test case: Enclosed Unqualified Unqualified\nSolution: 0\n\";\n\tCHECK(case12.find(expect12) != std::string::npos);\n\tauto case13 = c3t(circle1Enclosing, circle2Enclosed, lineEnclosed);\n\tauto expect13 = \"Test case: Enclosing Enclosed Enclosed\nSolution: 0\n\";\n\tCHECK(case13.find(expect13) != std::string::npos);\n\tauto case14 = c3t(circle1Enclosing, circle2Enclosed, lineOutside);\n\tauto expect14 = \"Test case: Enclosing Enclosed Outside\nSolution: 0\n\";\n\tCHECK(case14.find(expect14) != std::string::npos);\n\tauto case15 = c3t(circle1Enclosing, circle2Enclosed, lineUnqualified);\n\tauto expect15 = \"Test case: Enclosing Enclosed Unqualified\nSolution: 0\n\";\n\tCHECK(case15.find(expect15) != std::string::npos);\n\tauto case16 = c3t(circle1Enclosing, circle2Enclosing, lineEnclosed);\n\tauto expect16 = \"Test case: Enclosing Enclosing Enclosed\nSolution: 1\n0: 2 2 4.5 1 0 -0 1 4.5\n  Enclosing Enclosing Enclosed\n\";\n\tCHECK(case16.find(expect16) != std::string::npos);\n\tauto case17 = c3t(circle1Enclosing, circle2Enclosing, lineOutside);\n\tauto expect17 = \"Test case: Enclosing Enclosing Outside\nSolution: 0\n\";\n\tCHECK(case17.find(expect17) != std::string::npos);\n\tauto case18 = c3t(circle1Enclosing, circle2Enclosing, lineUnqualified);\n\tauto expect18 = \"Test case: Enclosing Enclosing Unqualified\nSolution: 1\n0: 2 2 4.5 1 0 -0 1 4.5\n  Enclosing Enclosing Enclosed\n\";\n\tCHECK(case18.find(expect18) != std::string::npos);\n\tauto case19 = c3t(circle1Enclosing, circle2Outside, lineEnclosed);\n\tauto expect19 = \"Test case: Enclosing Outside Enclosed\nSolution: 1\n0: 2 -1 3 1 0 -0 1 3\n  Enclosing Outside Enclosed\n\";\n\tCHECK(case19.find(expect19) != std::string::npos);\n\tauto case20 = c3t(circle1Enclosing, circle2Outside, lineOutside);\n\tauto expect20 = \"Test case: Enclosing Outside Outside\nSolution: 0\n\";\n\tCHECK(case20.find(expect20) != std::string::npos);\n\tauto case21 = c3t(circle1Enclosing, circle2Outside, lineUnqualified);\n\tauto expect21 = \"Test case: Enclosing Outside Unqualified\nSolution: 1\n0: 2 -1 3 1 0 -0 1 3\n  Enclosing Outside Enclosed\n\";\n\tCHECK(case21.find(expect21) != std::string::npos);\n\tauto case22 = c3t(circle1Enclosing, circle2Unqualified, lineEnclosed);\n\tauto expect22 = \"Test case: Enclosing Unqualified Enclosed\nSolution: 2\n0: 2 -1 3 1 0 -0 1 3\n  Enclosing Outside Enclosed\n1: 2 2 4.5 1 0 -0 1 4.5\n  Enclosing Enclosing Enclosed\n\";\n\tCHECK(case22.find(expect22) != std::string::npos);\n\tauto case23 = c3t(circle1Enclosing, circle2Unqualified, lineOutside);\n\tauto expect23 = \"Test case: Enclosing Unqualified Outside\nSolution: 0\n\";\n\tCHECK(case23.find(expect23) != std::string::npos);\n\tauto case24 = c3t(circle1Enclosing, circle2Unqualified, lineUnqualified);\n\tauto expect24 = \"Test case: Enclosing Unqualified Unqualified\nSolution: 2\n0: 2 -1 3 1 0 -0 1 3\n  Enclosing Outside Enclosed\n1: 2 2 4.5 1 0 -0 1 4.5\n  Enclosing Enclosing Enclosed\n\";\n\tCHECK(case24.find(expect24) != std::string::npos);\n\tauto case25 = c3t(circle1Outside, circle2Enclosed, lineEnclosed);\n\tauto expect25 = \"Test case: Outside Enclosed Enclosed\nSolution: 0\n\";\n\tCHECK(case25.find(expect25) != std::string::npos);\n\tauto case26 = c3t(circle1Outside, circle2Enclosed, lineOutside);\n\tauto expect26 = \"Test case: Outside Enclosed Outside\nSolution: 0\n\";\n\tCHECK(case26.find(expect26) != std::string::npos);\n\tauto case27 = c3t(circle1Outside, circle2Enclosed, lineUnqualified);\n\tauto expect27 = \"Test case: Outside Enclosed Unqualified\nSolution: 0\n\";\n\tCHECK(case27.find(expect27) != std::string::npos);\n\tauto case28 = c3t(circle1Outside, circle2Enclosing, lineEnclosed);\n\tauto expect28 = \"Test case: Outside Enclosing Enclosed\nSolution: 1\n0: 2 5 3 1 0 -0 1 3\n  Outside Enclosing Enclosed\n\";\n\tCHECK(case28.find(expect28) != std::string::npos);\n\tauto case29 = c3t(circle1Outside, circle2Enclosing, lineOutside);\n\tauto expect29 = \"Test case: Outside Enclosing Outside\nSolution: 0\n\";\n\tCHECK(case29.find(expect29) != std::string::npos);\n\tauto case30 = c3t(circle1Outside, circle2Enclosing, lineUnqualified);\n\tauto expect30 = \"Test case: Outside Enclosing Unqualified\nSolution: 1\n0: 2 5 3 1 0 -0 1 3\n  Outside Enclosing Enclosed\n\";\n\tCHECK(case30.find(expect30) != std::string::npos);\n\tauto case31 = c3t(circle1Outside, circle2Outside, lineEnclosed);\n\tauto expect31 = \"Test case: Outside Outside Enclosed\nSolution: 1\n0: 2 2 0.9 1 0 -0 1 0.9\n  Outside Outside Enclosed\n\";\n\tCHECK(case31.find(expect31) != std::string::npos);\n\tauto case32 = c3t(circle1Outside, circle2Outside, lineOutside);\n\tauto expect32 = \"Test case: Outside Outside Outside\nSolution: 0\n\";\n\tCHECK(case32.find(expect32) != std::string::npos);\n\tauto case33 = c3t(circle1Outside, circle2Outside, lineUnqualified);\n\tauto expect33 = \"Test case: Outside Outside Unqualified\nSolution: 1\n0: 2 2 0.9 1 0 -0 1 0.9\n  Outside Outside Enclosed\n\";\n\tCHECK(case33.find(expect33) != std::string::npos);\n\tauto case34 = c3t(circle1Outside, circle2Unqualified, lineEnclosed);\n\tauto expect34 = \"Test case: Outside Unqualified Enclosed\nSolution: 2\n0: 2 2 0.9 1 0 -0 1 0.9\n  Outside Outside Enclosed\n1: 2 5 3 1 0 -0 1 3\n  Outside Enclosing Enclosed\n\";\n\tCHECK(case34.find(expect34) != std::string::npos);\n\tauto case35 = c3t(circle1Outside, circle2Unqualified, lineOutside);\n\tauto expect35 = \"Test case: Outside Unqualified Outside\nSolution: 0\n\";\n\tCHECK(case35.find(expect35) != std::string::npos);\n\tauto case36 = c3t(circle1Outside, circle2Unqualified, lineUnqualified);\n\tauto expect36 = \"Test case: Outside Unqualified Unqualified\nSolution: 2\n0: 2 2 0.9 1 0 -0 1 0.9\n  Outside Outside Enclosed\n1: 2 5 3 1 0 -0 1 3\n  Outside Enclosing Enclosed\n\";\n\tCHECK(case36.find(expect36) != std::string::npos);\n\tauto case37 = c3t(circle1Unqualified, circle2Enclosed, lineEnclosed);\n\tauto expect37 = \"Test case: Unqualified Enclosed Enclosed\nSolution: 0\n\";\n\tCHECK(case37.find(expect37) != std::string::npos);\n\tauto case38 = c3t(circle1Unqualified, circle2Enclosed, lineOutside);\n\tauto expect38 = \"Test case: Unqualified Enclosed Outside\nSolution: 0\n\";\n\tCHECK(case38.find(expect38) != std::string::npos);\n\tauto case39 = c3t(circle1Unqualified, circle2Enclosed, lineUnqualified);\n\tauto expect39 = \"Test case: Unqualified Enclosed Unqualified\nSolution: 0\n\";\n\tCHECK(case39.find(expect39) != std::string::npos);\n\tauto case40 = c3t(circle1Unqualified, circle2Enclosing, lineEnclosed);\n\tauto expect40 = \"Test case: Unqualified Enclosing Enclosed\nSolution: 2\n0: 2 5 3 1 0 -0 1 3\n  Outside Enclosing Enclosed\n1: 2 2 4.5 1 0 -0 1 4.5\n  Enclosing Enclosing Enclosed\n\";\n\tCHECK(case40.find(expect40) != std::string::npos);\n\tauto case41 = c3t(circle1Unqualified, circle2Enclosing, lineOutside);\n\tauto expect41 = \"Test case: Unqualified Enclosing Outside\nSolution: 0\n\";\n\tCHECK(case41.find(expect41) != std::string::npos);\n\tauto case42 = c3t(circle1Unqualified, circle2Enclosing, lineUnqualified);\n\tauto expect42 = \"Test case: Unqualified Enclosing Unqualified\nSolution: 2\n0: 2 5 3 1 0 -0 1 3\n  Outside Enclosing Enclosed\n1: 2 2 4.5 1 0 -0 1 4.5\n  Enclosing Enclosing Enclosed\n\";\n\tCHECK(case42.find(expect42) != std::string::npos);\n\tauto case43 = c3t(circle1Unqualified, circle2Outside, lineEnclosed);\n\tauto expect43 = \"Test case: Unqualified Outside Enclosed\nSolution: 2\n0: 2 2 0.9 1 0 -0 1 0.9\n  Outside Outside Enclosed\n1: 2 -1 3 1 0 -0 1 3\n  Enclosing Outside Enclosed\n\";\n\tCHECK(case43.find(expect43) != std::string::npos);\n\tauto case44 = c3t(circle1Unqualified, circle2Outside, lineOutside);\n\tauto expect44 = \"Test case: Unqualified Outside Outside\nSolution: 0\n\";\n\tCHECK(case44.find(expect44) != std::string::npos);\n\tauto case45 = c3t(circle1Unqualified, circle2Outside, lineUnqualified);\n\tauto expect45 = \"Test case: Unqualified Outside Unqualified\nSolution: 2\n0: 2 2 0.9 1 0 -0 1 0.9\n  Outside Outside Enclosed\n1: 2 -1 3 1 0 -0 1 3\n  Enclosing Outside Enclosed\n\";\n\tCHECK(case45.find(expect45) != std::string::npos);\n\tauto case46 = c3t(circle1Unqualified, circle2Unqualified, lineEnclosed);\n\tauto expect46 = \"Test case: Unqualified Unqualified Enclosed\nSolution: 4\n0: 2 2 0.9 1 0 -0 1 0.9\n  Outside Outside Enclosed\n1: 2 5 3 1 0 -0 1 3\n  Outside Enclosing Enclosed\n2: 2 -1 3 1 0 -0 1 3\n  Enclosing Outside Enclosed\n3: 2 2 4.5 1 0 -0 1 4.5\n  Enclosing Enclosing Enclosed\n\";\n\tCHECK(case46.find(expect46) != std::string::npos);\n\tauto case47 = c3t(circle1Unqualified, circle2Unqualified, lineOutside);\n\tauto expect47 = \"Test case: Unqualified Unqualified Outside\nSolution: 0\n\";\n\tCHECK(case47.find(expect47) != std::string::npos);\n\tauto case48 = c3t(circle1Unqualified, circle2Unqualified, lineUnqualified);\n\tauto expect48 = \"Test case: Unqualified Unqualified Unqualified\nSolution: 4\n0: 2 2 0.9 1 0 -0 1 0.9\n  Outside Outside Enclosed\n1: 2 5 3 1 0 -0 1 3\n  Outside Enclosing Enclosed\n2: 2 -1 3 1 0 -0 1 3\n  Enclosing Outside Enclosed\n3: 2 2 4.5 1 0 -0 1 4.5\n  Enclosing Enclosing Enclosed\";\n\tCHECK(case48.find(expect48) != std::string::npos);\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API GccCircle3Tangent(const GccQualifiedCurve& qualified1, const Point2& point1, const Point2& point2, double tolerance, double parameter1)\t @param parameter1 The initial guess of the parameter on the curve\n\t @param tolerance The tolerance\n\t @param point2 The second point\n\t @param point1 The first point\n\t @param qualified1 The tangent curve\n\t @brief Construct a circle tangent to a curve and passing throught two points\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <geomAlgo/GccCircle3Tangent.hpp>\n#include <geometry/Geom2Curve.hpp>\n#include <geometry/MakeGeom2Line.hpp>\n#include <geometry/MakeGeom2Circle.hpp>\n#include <geomAlgo/GccEntity.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geomAlgo/GccEntity.hpp>\n#include <geomAlgo/GccQualifiedCurve.hpp>\n#include <sstream>\nusing namespace AMCAX;\nTEST_CASE(\"bug1: GccCircle3Tangent  add 48 cases\", \"[geomAlgo][GccCircle3Tangent][fixbug]\") {\n\tstd::shared_ptr<Geom2Curve> l = MakeGeom2Line(Point2(0.0, 0.0), Point2(1.0, 0.0)).Value();\n\tstd::shared_ptr<Geom2Curve> c1 = MakeGeom2Circle(Point2(0.0, 3.0), 2.0).Value();\n\tstd::shared_ptr<Geom2Curve> c2 = MakeGeom2Circle(Point2(4.0, 3.0), 2.0).Value();\n\tAdaptorGeom2Curve line(l);\n\tAdaptorGeom2Curve circle1(c1);\n\tAdaptorGeom2Curve circle2(c2);\n\tauto lineEnclosed = GccEntity::Enclosed(line);\n\tauto lineOutside = GccEntity::Outside(line);\n\tauto lineUnqualified = GccEntity::Unqualified(line);\n\tauto circle1Enclosed = GccEntity::Enclosed(circle1);\n\tauto circle1Enclosing = GccEntity::Enclosing(circle1);\n\tauto circle1Outside = GccEntity::Outside(circle1);\n\tauto circle1Unqualified = GccEntity::Unqualified(circle1);\n\tauto circle2Enclosed = GccEntity::Enclosed(circle2);\n\tauto circle2Enclosing = GccEntity::Enclosing(circle2);\n\tauto circle2Outside = GccEntity::Outside(circle2);\n\tauto circle2Unqualified = GccEntity::Unqualified(circle2);\n\tauto gccl = GccEntity::Enclosed(AdaptorGeom2Curve(l));\n\tauto gccc1 = GccEntity::Enclosing(AdaptorGeom2Curve(c1));\n\tauto gccc2 = GccEntity::Outside(AdaptorGeom2Curve(c2));\n\tauto c3t = [](const GccQualifiedCurve& gccc1, const GccQualifiedCurve& gccc2, const GccQualifiedCurve& gccl)\n\t{\n\t\tstd::stringstream output;\n\t\tGccCircle3Tangent gcc(gccc1, gccc2, gccl, Precision::Confusion(), 0.0, 0.0, 0.0);\n\t\tstd::cout << \"Test case: \" << GccEntity::PositionToString(gccc1.Qualifier()) << ' ' << GccEntity::PositionToString(gccc2.Qualifier()) << ' ' << GccEntity::PositionToString(gccl.Qualifier()) << std::endl;\n\t\tstd::cout << \"Solution: \" << gcc.NSolutions() << std::endl;\n\t\toutput << \"Test case: \" << GccEntity::PositionToString(gccc1.Qualifier()) << ' ' << GccEntity::PositionToString(gccc2.Qualifier()) << ' ' << GccEntity::PositionToString(gccl.Qualifier()) << std::endl;\n\t\toutput << \"Solution: \" << gcc.NSolutions() << std::endl;\n\t\tif (gcc.IsDone())\n\t\t{\n\t\t\tfor (int i = 0; i < gcc.NSolutions(); i++)\n\t\t\t{\n\t\t\t\tGccPosition q1, q2, q3;\n\t\t\t\tgcc.Qualifier(i, q1, q2, q3);\n\t\t\t\toutput << i << \": \" << *MakeGeom2Circle(gcc.Solution(i)).Value() << std::endl;\n\t\t\t\toutput << \"  \" << GccEntity::PositionToString(q1) << ' ' << GccEntity::PositionToString(q2) << ' ' << GccEntity::PositionToString(q3) << std::endl;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tstd::cout << \"gcc.IsDone is False\" << std::endl;\n\t\t\toutput << \"gcc.IsDone is False\" << std::endl;\n\t\t}\n\t\treturn output.str();\n\t};\n\tauto case1 = c3t(circle1Enclosed, circle2Enclosed, lineEnclosed);\n\tauto expect1 = \"Test case: Enclosed Enclosed Enclosed\nSolution: 0\n\";\n\tCHECK(case1.find(expect1) != std::string::npos);\n\tauto case2 = c3t(circle1Enclosed, circle2Enclosed, lineOutside);\n\tauto expect2 = \"Test case: Enclosed Enclosed Outside\nSolution: 0\n\";\n\tCHECK(case2.find(expect2) != std::string::npos);\n\tauto case3 = c3t(circle1Enclosed, circle2Enclosed, lineUnqualified);\n\tauto expect3 = \"Test case: Enclosed Enclosed Unqualified\nSolution: 0\n\";\n\tCHECK(case3.find(expect3) != std::string::npos);\n\tauto case4 = c3t(circle1Enclosed, circle2Enclosing, lineEnclosed);\n\tauto expect4 = \"Test case: Enclosed Enclosing Enclosed\nSolution: 0\n\";\n\tCHECK(case4.find(expect4) != std::string::npos);\n\tauto case5 = c3t(circle1Enclosed, circle2Enclosing, lineOutside);\n\tauto expect5 = \"Test case: Enclosed Enclosing Outside\nSolution: 0\n\";\n\tCHECK(case5.find(expect5) != std::string::npos);\n\tauto case6 = c3t(circle1Enclosed, circle2Enclosing, lineUnqualified);\n\tauto expect6 = \"Test case: Enclosed Enclosing Unqualified\nSolution: 0\n\";\n\tCHECK(case6.find(expect6) != std::string::npos);\n\tauto case7 = c3t(circle1Enclosed, circle2Outside, lineEnclosed);\n\tauto expect7 = \"Test case: Enclosed Outside Enclosed\nSolution: 0\n\";\n\tCHECK(case7.find(expect7) != std::string::npos);\n\tauto case8 = c3t(circle1Enclosed, circle2Outside, lineOutside);\n\tauto expect8 = \"Test case: Enclosed Outside Outside\nSolution: 0\n\";\n\tCHECK(case8.find(expect8) != std::string::npos);\n\tauto case9 = c3t(circle1Enclosed, circle2Outside, lineUnqualified);\n\tauto expect9 = \"Test case: Enclosed Outside Unqualified\nSolution: 0\n\";\n\tCHECK(case9.find(expect9) != std::string::npos);\n\tauto case10 = c3t(circle1Enclosed, circle2Unqualified, lineEnclosed);\n\tauto expect10 = \"Test case: Enclosed Unqualified Enclosed\nSolution: 0\n\";\n\tCHECK(case10.find(expect10) != std::string::npos);\n\tauto case11 = c3t(circle1Enclosed, circle2Unqualified, lineOutside);\n\tauto expect11 = \"Test case: Enclosed Unqualified Outside\nSolution: 0\n\";\n\tCHECK(case11.find(expect11) != std::string::npos);\n\tauto case12 = c3t(circle1Enclosed, circle2Unqualified, lineUnqualified);\n\tauto expect12 = \"Test case: Enclosed Unqualified Unqualified\nSolution: 0\n\";\n\tCHECK(case12.find(expect12) != std::string::npos);\n\tauto case13 = c3t(circle1Enclosing, circle2Enclosed, lineEnclosed);\n\tauto expect13 = \"Test case: Enclosing Enclosed Enclosed\nSolution: 0\n\";\n\tCHECK(case13.find(expect13) != std::string::npos);\n\tauto case14 = c3t(circle1Enclosing, circle2Enclosed, lineOutside);\n\tauto expect14 = \"Test case: Enclosing Enclosed Outside\nSolution: 0\n\";\n\tCHECK(case14.find(expect14) != std::string::npos);\n\tauto case15 = c3t(circle1Enclosing, circle2Enclosed, lineUnqualified);\n\tauto expect15 = \"Test case: Enclosing Enclosed Unqualified\nSolution: 0\n\";\n\tCHECK(case15.find(expect15) != std::string::npos);\n\tauto case16 = c3t(circle1Enclosing, circle2Enclosing, lineEnclosed);\n\tauto expect16 = \"Test case: Enclosing Enclosing Enclosed\nSolution: 1\n0: 2 2 4.5 1 0 -0 1 4.5\n  Enclosing Enclosing Enclosed\n\";\n\tCHECK(case16.find(expect16) != std::string::npos);\n\tauto case17 = c3t(circle1Enclosing, circle2Enclosing, lineOutside);\n\tauto expect17 = \"Test case: Enclosing Enclosing Outside\nSolution: 0\n\";\n\tCHECK(case17.find(expect17) != std::string::npos);\n\tauto case18 = c3t(circle1Enclosing, circle2Enclosing, lineUnqualified);\n\tauto expect18 = \"Test case: Enclosing Enclosing Unqualified\nSolution: 1\n0: 2 2 4.5 1 0 -0 1 4.5\n  Enclosing Enclosing Enclosed\n\";\n\tCHECK(case18.find(expect18) != std::string::npos);\n\tauto case19 = c3t(circle1Enclosing, circle2Outside, lineEnclosed);\n\tauto expect19 = \"Test case: Enclosing Outside Enclosed\nSolution: 1\n0: 2 -1 3 1 0 -0 1 3\n  Enclosing Outside Enclosed\n\";\n\tCHECK(case19.find(expect19) != std::string::npos);\n\tauto case20 = c3t(circle1Enclosing, circle2Outside, lineOutside);\n\tauto expect20 = \"Test case: Enclosing Outside Outside\nSolution: 0\n\";\n\tCHECK(case20.find(expect20) != std::string::npos);\n\tauto case21 = c3t(circle1Enclosing, circle2Outside, lineUnqualified);\n\tauto expect21 = \"Test case: Enclosing Outside Unqualified\nSolution: 1\n0: 2 -1 3 1 0 -0 1 3\n  Enclosing Outside Enclosed\n\";\n\tCHECK(case21.find(expect21) != std::string::npos);\n\tauto case22 = c3t(circle1Enclosing, circle2Unqualified, lineEnclosed);\n\tauto expect22 = \"Test case: Enclosing Unqualified Enclosed\nSolution: 2\n0: 2 -1 3 1 0 -0 1 3\n  Enclosing Outside Enclosed\n1: 2 2 4.5 1 0 -0 1 4.5\n  Enclosing Enclosing Enclosed\n\";\n\tCHECK(case22.find(expect22) != std::string::npos);\n\tauto case23 = c3t(circle1Enclosing, circle2Unqualified, lineOutside);\n\tauto expect23 = \"Test case: Enclosing Unqualified Outside\nSolution: 0\n\";\n\tCHECK(case23.find(expect23) != std::string::npos);\n\tauto case24 = c3t(circle1Enclosing, circle2Unqualified, lineUnqualified);\n\tauto expect24 = \"Test case: Enclosing Unqualified Unqualified\nSolution: 2\n0: 2 -1 3 1 0 -0 1 3\n  Enclosing Outside Enclosed\n1: 2 2 4.5 1 0 -0 1 4.5\n  Enclosing Enclosing Enclosed\n\";\n\tCHECK(case24.find(expect24) != std::string::npos);\n\tauto case25 = c3t(circle1Outside, circle2Enclosed, lineEnclosed);\n\tauto expect25 = \"Test case: Outside Enclosed Enclosed\nSolution: 0\n\";\n\tCHECK(case25.find(expect25) != std::string::npos);\n\tauto case26 = c3t(circle1Outside, circle2Enclosed, lineOutside);\n\tauto expect26 = \"Test case: Outside Enclosed Outside\nSolution: 0\n\";\n\tCHECK(case26.find(expect26) != std::string::npos);\n\tauto case27 = c3t(circle1Outside, circle2Enclosed, lineUnqualified);\n\tauto expect27 = \"Test case: Outside Enclosed Unqualified\nSolution: 0\n\";\n\tCHECK(case27.find(expect27) != std::string::npos);\n\tauto case28 = c3t(circle1Outside, circle2Enclosing, lineEnclosed);\n\tauto expect28 = \"Test case: Outside Enclosing Enclosed\nSolution: 1\n0: 2 5 3 1 0 -0 1 3\n  Outside Enclosing Enclosed\n\";\n\tCHECK(case28.find(expect28) != std::string::npos);\n\tauto case29 = c3t(circle1Outside, circle2Enclosing, lineOutside);\n\tauto expect29 = \"Test case: Outside Enclosing Outside\nSolution: 0\n\";\n\tCHECK(case29.find(expect29) != std::string::npos);\n\tauto case30 = c3t(circle1Outside, circle2Enclosing, lineUnqualified);\n\tauto expect30 = \"Test case: Outside Enclosing Unqualified\nSolution: 1\n0: 2 5 3 1 0 -0 1 3\n  Outside Enclosing Enclosed\n\";\n\tCHECK(case30.find(expect30) != std::string::npos);\n\tauto case31 = c3t(circle1Outside, circle2Outside, lineEnclosed);\n\tauto expect31 = \"Test case: Outside Outside Enclosed\nSolution: 1\n0: 2 2 0.9 1 0 -0 1 0.9\n  Outside Outside Enclosed\n\";\n\tCHECK(case31.find(expect31) != std::string::npos);\n\tauto case32 = c3t(circle1Outside, circle2Outside, lineOutside);\n\tauto expect32 = \"Test case: Outside Outside Outside\nSolution: 0\n\";\n\tCHECK(case32.find(expect32) != std::string::npos);\n\tauto case33 = c3t(circle1Outside, circle2Outside, lineUnqualified);\n\tauto expect33 = \"Test case: Outside Outside Unqualified\nSolution: 1\n0: 2 2 0.9 1 0 -0 1 0.9\n  Outside Outside Enclosed\n\";\n\tCHECK(case33.find(expect33) != std::string::npos);\n\tauto case34 = c3t(circle1Outside, circle2Unqualified, lineEnclosed);\n\tauto expect34 = \"Test case: Outside Unqualified Enclosed\nSolution: 2\n0: 2 2 0.9 1 0 -0 1 0.9\n  Outside Outside Enclosed\n1: 2 5 3 1 0 -0 1 3\n  Outside Enclosing Enclosed\n\";\n\tCHECK(case34.find(expect34) != std::string::npos);\n\tauto case35 = c3t(circle1Outside, circle2Unqualified, lineOutside);\n\tauto expect35 = \"Test case: Outside Unqualified Outside\nSolution: 0\n\";\n\tCHECK(case35.find(expect35) != std::string::npos);\n\tauto case36 = c3t(circle1Outside, circle2Unqualified, lineUnqualified);\n\tauto expect36 = \"Test case: Outside Unqualified Unqualified\nSolution: 2\n0: 2 2 0.9 1 0 -0 1 0.9\n  Outside Outside Enclosed\n1: 2 5 3 1 0 -0 1 3\n  Outside Enclosing Enclosed\n\";\n\tCHECK(case36.find(expect36) != std::string::npos);\n\tauto case37 = c3t(circle1Unqualified, circle2Enclosed, lineEnclosed);\n\tauto expect37 = \"Test case: Unqualified Enclosed Enclosed\nSolution: 0\n\";\n\tCHECK(case37.find(expect37) != std::string::npos);\n\tauto case38 = c3t(circle1Unqualified, circle2Enclosed, lineOutside);\n\tauto expect38 = \"Test case: Unqualified Enclosed Outside\nSolution: 0\n\";\n\tCHECK(case38.find(expect38) != std::string::npos);\n\tauto case39 = c3t(circle1Unqualified, circle2Enclosed, lineUnqualified);\n\tauto expect39 = \"Test case: Unqualified Enclosed Unqualified\nSolution: 0\n\";\n\tCHECK(case39.find(expect39) != std::string::npos);\n\tauto case40 = c3t(circle1Unqualified, circle2Enclosing, lineEnclosed);\n\tauto expect40 = \"Test case: Unqualified Enclosing Enclosed\nSolution: 2\n0: 2 5 3 1 0 -0 1 3\n  Outside Enclosing Enclosed\n1: 2 2 4.5 1 0 -0 1 4.5\n  Enclosing Enclosing Enclosed\n\";\n\tCHECK(case40.find(expect40) != std::string::npos);\n\tauto case41 = c3t(circle1Unqualified, circle2Enclosing, lineOutside);\n\tauto expect41 = \"Test case: Unqualified Enclosing Outside\nSolution: 0\n\";\n\tCHECK(case41.find(expect41) != std::string::npos);\n\tauto case42 = c3t(circle1Unqualified, circle2Enclosing, lineUnqualified);\n\tauto expect42 = \"Test case: Unqualified Enclosing Unqualified\nSolution: 2\n0: 2 5 3 1 0 -0 1 3\n  Outside Enclosing Enclosed\n1: 2 2 4.5 1 0 -0 1 4.5\n  Enclosing Enclosing Enclosed\n\";\n\tCHECK(case42.find(expect42) != std::string::npos);\n\tauto case43 = c3t(circle1Unqualified, circle2Outside, lineEnclosed);\n\tauto expect43 = \"Test case: Unqualified Outside Enclosed\nSolution: 2\n0: 2 2 0.9 1 0 -0 1 0.9\n  Outside Outside Enclosed\n1: 2 -1 3 1 0 -0 1 3\n  Enclosing Outside Enclosed\n\";\n\tCHECK(case43.find(expect43) != std::string::npos);\n\tauto case44 = c3t(circle1Unqualified, circle2Outside, lineOutside);\n\tauto expect44 = \"Test case: Unqualified Outside Outside\nSolution: 0\n\";\n\tCHECK(case44.find(expect44) != std::string::npos);\n\tauto case45 = c3t(circle1Unqualified, circle2Outside, lineUnqualified);\n\tauto expect45 = \"Test case: Unqualified Outside Unqualified\nSolution: 2\n0: 2 2 0.9 1 0 -0 1 0.9\n  Outside Outside Enclosed\n1: 2 -1 3 1 0 -0 1 3\n  Enclosing Outside Enclosed\n\";\n\tCHECK(case45.find(expect45) != std::string::npos);\n\tauto case46 = c3t(circle1Unqualified, circle2Unqualified, lineEnclosed);\n\tauto expect46 = \"Test case: Unqualified Unqualified Enclosed\nSolution: 4\n0: 2 2 0.9 1 0 -0 1 0.9\n  Outside Outside Enclosed\n1: 2 5 3 1 0 -0 1 3\n  Outside Enclosing Enclosed\n2: 2 -1 3 1 0 -0 1 3\n  Enclosing Outside Enclosed\n3: 2 2 4.5 1 0 -0 1 4.5\n  Enclosing Enclosing Enclosed\n\";\n\tCHECK(case46.find(expect46) != std::string::npos);\n\tauto case47 = c3t(circle1Unqualified, circle2Unqualified, lineOutside);\n\tauto expect47 = \"Test case: Unqualified Unqualified Outside\nSolution: 0\n\";\n\tCHECK(case47.find(expect47) != std::string::npos);\n\tauto case48 = c3t(circle1Unqualified, circle2Unqualified, lineUnqualified);\n\tauto expect48 = \"Test case: Unqualified Unqualified Unqualified\nSolution: 4\n0: 2 2 0.9 1 0 -0 1 0.9\n  Outside Outside Enclosed\n1: 2 5 3 1 0 -0 1 3\n  Outside Enclosing Enclosed\n2: 2 -1 3 1 0 -0 1 3\n  Enclosing Outside Enclosed\n3: 2 2 4.5 1 0 -0 1 4.5\n  Enclosing Enclosing Enclosed\";\n\tCHECK(case48.find(expect48) != std::string::npos);\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API GccCircle3Tangent(const GccQualifiedCurve& qualified1, const GccQualifiedCurve& qualified2, const Point2& point, double tolerance, double parameter1, double parameter2)\t @param parameter2 The initial guess of the parameter on the second curve\n\t @param parameter1 The initial guess of the parameter on the first curve\n\t @param tolerance The tolerance\n\t @param point The point that the circle passes through\n\t @param qualified2 The second curve\n\t @param qualified1 The first curve\n\t @brief Construct a circle tangent to two curves and passing through a point\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <geomAlgo/GccCircle3Tangent.hpp>\n#include <geometry/Geom2Curve.hpp>\n#include <geometry/MakeGeom2Line.hpp>\n#include <geometry/MakeGeom2Circle.hpp>\n#include <geomAlgo/GccEntity.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geomAlgo/GccEntity.hpp>\n#include <geomAlgo/GccQualifiedCurve.hpp>\n#include <sstream>\nusing namespace AMCAX;\nTEST_CASE(\"bug1: GccCircle3Tangent  add 48 cases\", \"[geomAlgo][GccCircle3Tangent][fixbug]\") {\n\tstd::shared_ptr<Geom2Curve> l = MakeGeom2Line(Point2(0.0, 0.0), Point2(1.0, 0.0)).Value();\n\tstd::shared_ptr<Geom2Curve> c1 = MakeGeom2Circle(Point2(0.0, 3.0), 2.0).Value();\n\tstd::shared_ptr<Geom2Curve> c2 = MakeGeom2Circle(Point2(4.0, 3.0), 2.0).Value();\n\tAdaptorGeom2Curve line(l);\n\tAdaptorGeom2Curve circle1(c1);\n\tAdaptorGeom2Curve circle2(c2);\n\tauto lineEnclosed = GccEntity::Enclosed(line);\n\tauto lineOutside = GccEntity::Outside(line);\n\tauto lineUnqualified = GccEntity::Unqualified(line);\n\tauto circle1Enclosed = GccEntity::Enclosed(circle1);\n\tauto circle1Enclosing = GccEntity::Enclosing(circle1);\n\tauto circle1Outside = GccEntity::Outside(circle1);\n\tauto circle1Unqualified = GccEntity::Unqualified(circle1);\n\tauto circle2Enclosed = GccEntity::Enclosed(circle2);\n\tauto circle2Enclosing = GccEntity::Enclosing(circle2);\n\tauto circle2Outside = GccEntity::Outside(circle2);\n\tauto circle2Unqualified = GccEntity::Unqualified(circle2);\n\tauto gccl = GccEntity::Enclosed(AdaptorGeom2Curve(l));\n\tauto gccc1 = GccEntity::Enclosing(AdaptorGeom2Curve(c1));\n\tauto gccc2 = GccEntity::Outside(AdaptorGeom2Curve(c2));\n\tauto c3t = [](const GccQualifiedCurve& gccc1, const GccQualifiedCurve& gccc2, const GccQualifiedCurve& gccl)\n\t{\n\t\tstd::stringstream output;\n\t\tGccCircle3Tangent gcc(gccc1, gccc2, gccl, Precision::Confusion(), 0.0, 0.0, 0.0);\n\t\tstd::cout << \"Test case: \" << GccEntity::PositionToString(gccc1.Qualifier()) << ' ' << GccEntity::PositionToString(gccc2.Qualifier()) << ' ' << GccEntity::PositionToString(gccl.Qualifier()) << std::endl;\n\t\tstd::cout << \"Solution: \" << gcc.NSolutions() << std::endl;\n\t\toutput << \"Test case: \" << GccEntity::PositionToString(gccc1.Qualifier()) << ' ' << GccEntity::PositionToString(gccc2.Qualifier()) << ' ' << GccEntity::PositionToString(gccl.Qualifier()) << std::endl;\n\t\toutput << \"Solution: \" << gcc.NSolutions() << std::endl;\n\t\tif (gcc.IsDone())\n\t\t{\n\t\t\tfor (int i = 0; i < gcc.NSolutions(); i++)\n\t\t\t{\n\t\t\t\tGccPosition q1, q2, q3;\n\t\t\t\tgcc.Qualifier(i, q1, q2, q3);\n\t\t\t\toutput << i << \": \" << *MakeGeom2Circle(gcc.Solution(i)).Value() << std::endl;\n\t\t\t\toutput << \"  \" << GccEntity::PositionToString(q1) << ' ' << GccEntity::PositionToString(q2) << ' ' << GccEntity::PositionToString(q3) << std::endl;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tstd::cout << \"gcc.IsDone is False\" << std::endl;\n\t\t\toutput << \"gcc.IsDone is False\" << std::endl;\n\t\t}\n\t\treturn output.str();\n\t};\n\tauto case1 = c3t(circle1Enclosed, circle2Enclosed, lineEnclosed);\n\tauto expect1 = \"Test case: Enclosed Enclosed Enclosed\nSolution: 0\n\";\n\tCHECK(case1.find(expect1) != std::string::npos);\n\tauto case2 = c3t(circle1Enclosed, circle2Enclosed, lineOutside);\n\tauto expect2 = \"Test case: Enclosed Enclosed Outside\nSolution: 0\n\";\n\tCHECK(case2.find(expect2) != std::string::npos);\n\tauto case3 = c3t(circle1Enclosed, circle2Enclosed, lineUnqualified);\n\tauto expect3 = \"Test case: Enclosed Enclosed Unqualified\nSolution: 0\n\";\n\tCHECK(case3.find(expect3) != std::string::npos);\n\tauto case4 = c3t(circle1Enclosed, circle2Enclosing, lineEnclosed);\n\tauto expect4 = \"Test case: Enclosed Enclosing Enclosed\nSolution: 0\n\";\n\tCHECK(case4.find(expect4) != std::string::npos);\n\tauto case5 = c3t(circle1Enclosed, circle2Enclosing, lineOutside);\n\tauto expect5 = \"Test case: Enclosed Enclosing Outside\nSolution: 0\n\";\n\tCHECK(case5.find(expect5) != std::string::npos);\n\tauto case6 = c3t(circle1Enclosed, circle2Enclosing, lineUnqualified);\n\tauto expect6 = \"Test case: Enclosed Enclosing Unqualified\nSolution: 0\n\";\n\tCHECK(case6.find(expect6) != std::string::npos);\n\tauto case7 = c3t(circle1Enclosed, circle2Outside, lineEnclosed);\n\tauto expect7 = \"Test case: Enclosed Outside Enclosed\nSolution: 0\n\";\n\tCHECK(case7.find(expect7) != std::string::npos);\n\tauto case8 = c3t(circle1Enclosed, circle2Outside, lineOutside);\n\tauto expect8 = \"Test case: Enclosed Outside Outside\nSolution: 0\n\";\n\tCHECK(case8.find(expect8) != std::string::npos);\n\tauto case9 = c3t(circle1Enclosed, circle2Outside, lineUnqualified);\n\tauto expect9 = \"Test case: Enclosed Outside Unqualified\nSolution: 0\n\";\n\tCHECK(case9.find(expect9) != std::string::npos);\n\tauto case10 = c3t(circle1Enclosed, circle2Unqualified, lineEnclosed);\n\tauto expect10 = \"Test case: Enclosed Unqualified Enclosed\nSolution: 0\n\";\n\tCHECK(case10.find(expect10) != std::string::npos);\n\tauto case11 = c3t(circle1Enclosed, circle2Unqualified, lineOutside);\n\tauto expect11 = \"Test case: Enclosed Unqualified Outside\nSolution: 0\n\";\n\tCHECK(case11.find(expect11) != std::string::npos);\n\tauto case12 = c3t(circle1Enclosed, circle2Unqualified, lineUnqualified);\n\tauto expect12 = \"Test case: Enclosed Unqualified Unqualified\nSolution: 0\n\";\n\tCHECK(case12.find(expect12) != std::string::npos);\n\tauto case13 = c3t(circle1Enclosing, circle2Enclosed, lineEnclosed);\n\tauto expect13 = \"Test case: Enclosing Enclosed Enclosed\nSolution: 0\n\";\n\tCHECK(case13.find(expect13) != std::string::npos);\n\tauto case14 = c3t(circle1Enclosing, circle2Enclosed, lineOutside);\n\tauto expect14 = \"Test case: Enclosing Enclosed Outside\nSolution: 0\n\";\n\tCHECK(case14.find(expect14) != std::string::npos);\n\tauto case15 = c3t(circle1Enclosing, circle2Enclosed, lineUnqualified);\n\tauto expect15 = \"Test case: Enclosing Enclosed Unqualified\nSolution: 0\n\";\n\tCHECK(case15.find(expect15) != std::string::npos);\n\tauto case16 = c3t(circle1Enclosing, circle2Enclosing, lineEnclosed);\n\tauto expect16 = \"Test case: Enclosing Enclosing Enclosed\nSolution: 1\n0: 2 2 4.5 1 0 -0 1 4.5\n  Enclosing Enclosing Enclosed\n\";\n\tCHECK(case16.find(expect16) != std::string::npos);\n\tauto case17 = c3t(circle1Enclosing, circle2Enclosing, lineOutside);\n\tauto expect17 = \"Test case: Enclosing Enclosing Outside\nSolution: 0\n\";\n\tCHECK(case17.find(expect17) != std::string::npos);\n\tauto case18 = c3t(circle1Enclosing, circle2Enclosing, lineUnqualified);\n\tauto expect18 = \"Test case: Enclosing Enclosing Unqualified\nSolution: 1\n0: 2 2 4.5 1 0 -0 1 4.5\n  Enclosing Enclosing Enclosed\n\";\n\tCHECK(case18.find(expect18) != std::string::npos);\n\tauto case19 = c3t(circle1Enclosing, circle2Outside, lineEnclosed);\n\tauto expect19 = \"Test case: Enclosing Outside Enclosed\nSolution: 1\n0: 2 -1 3 1 0 -0 1 3\n  Enclosing Outside Enclosed\n\";\n\tCHECK(case19.find(expect19) != std::string::npos);\n\tauto case20 = c3t(circle1Enclosing, circle2Outside, lineOutside);\n\tauto expect20 = \"Test case: Enclosing Outside Outside\nSolution: 0\n\";\n\tCHECK(case20.find(expect20) != std::string::npos);\n\tauto case21 = c3t(circle1Enclosing, circle2Outside, lineUnqualified);\n\tauto expect21 = \"Test case: Enclosing Outside Unqualified\nSolution: 1\n0: 2 -1 3 1 0 -0 1 3\n  Enclosing Outside Enclosed\n\";\n\tCHECK(case21.find(expect21) != std::string::npos);\n\tauto case22 = c3t(circle1Enclosing, circle2Unqualified, lineEnclosed);\n\tauto expect22 = \"Test case: Enclosing Unqualified Enclosed\nSolution: 2\n0: 2 -1 3 1 0 -0 1 3\n  Enclosing Outside Enclosed\n1: 2 2 4.5 1 0 -0 1 4.5\n  Enclosing Enclosing Enclosed\n\";\n\tCHECK(case22.find(expect22) != std::string::npos);\n\tauto case23 = c3t(circle1Enclosing, circle2Unqualified, lineOutside);\n\tauto expect23 = \"Test case: Enclosing Unqualified Outside\nSolution: 0\n\";\n\tCHECK(case23.find(expect23) != std::string::npos);\n\tauto case24 = c3t(circle1Enclosing, circle2Unqualified, lineUnqualified);\n\tauto expect24 = \"Test case: Enclosing Unqualified Unqualified\nSolution: 2\n0: 2 -1 3 1 0 -0 1 3\n  Enclosing Outside Enclosed\n1: 2 2 4.5 1 0 -0 1 4.5\n  Enclosing Enclosing Enclosed\n\";\n\tCHECK(case24.find(expect24) != std::string::npos);\n\tauto case25 = c3t(circle1Outside, circle2Enclosed, lineEnclosed);\n\tauto expect25 = \"Test case: Outside Enclosed Enclosed\nSolution: 0\n\";\n\tCHECK(case25.find(expect25) != std::string::npos);\n\tauto case26 = c3t(circle1Outside, circle2Enclosed, lineOutside);\n\tauto expect26 = \"Test case: Outside Enclosed Outside\nSolution: 0\n\";\n\tCHECK(case26.find(expect26) != std::string::npos);\n\tauto case27 = c3t(circle1Outside, circle2Enclosed, lineUnqualified);\n\tauto expect27 = \"Test case: Outside Enclosed Unqualified\nSolution: 0\n\";\n\tCHECK(case27.find(expect27) != std::string::npos);\n\tauto case28 = c3t(circle1Outside, circle2Enclosing, lineEnclosed);\n\tauto expect28 = \"Test case: Outside Enclosing Enclosed\nSolution: 1\n0: 2 5 3 1 0 -0 1 3\n  Outside Enclosing Enclosed\n\";\n\tCHECK(case28.find(expect28) != std::string::npos);\n\tauto case29 = c3t(circle1Outside, circle2Enclosing, lineOutside);\n\tauto expect29 = \"Test case: Outside Enclosing Outside\nSolution: 0\n\";\n\tCHECK(case29.find(expect29) != std::string::npos);\n\tauto case30 = c3t(circle1Outside, circle2Enclosing, lineUnqualified);\n\tauto expect30 = \"Test case: Outside Enclosing Unqualified\nSolution: 1\n0: 2 5 3 1 0 -0 1 3\n  Outside Enclosing Enclosed\n\";\n\tCHECK(case30.find(expect30) != std::string::npos);\n\tauto case31 = c3t(circle1Outside, circle2Outside, lineEnclosed);\n\tauto expect31 = \"Test case: Outside Outside Enclosed\nSolution: 1\n0: 2 2 0.9 1 0 -0 1 0.9\n  Outside Outside Enclosed\n\";\n\tCHECK(case31.find(expect31) != std::string::npos);\n\tauto case32 = c3t(circle1Outside, circle2Outside, lineOutside);\n\tauto expect32 = \"Test case: Outside Outside Outside\nSolution: 0\n\";\n\tCHECK(case32.find(expect32) != std::string::npos);\n\tauto case33 = c3t(circle1Outside, circle2Outside, lineUnqualified);\n\tauto expect33 = \"Test case: Outside Outside Unqualified\nSolution: 1\n0: 2 2 0.9 1 0 -0 1 0.9\n  Outside Outside Enclosed\n\";\n\tCHECK(case33.find(expect33) != std::string::npos);\n\tauto case34 = c3t(circle1Outside, circle2Unqualified, lineEnclosed);\n\tauto expect34 = \"Test case: Outside Unqualified Enclosed\nSolution: 2\n0: 2 2 0.9 1 0 -0 1 0.9\n  Outside Outside Enclosed\n1: 2 5 3 1 0 -0 1 3\n  Outside Enclosing Enclosed\n\";\n\tCHECK(case34.find(expect34) != std::string::npos);\n\tauto case35 = c3t(circle1Outside, circle2Unqualified, lineOutside);\n\tauto expect35 = \"Test case: Outside Unqualified Outside\nSolution: 0\n\";\n\tCHECK(case35.find(expect35) != std::string::npos);\n\tauto case36 = c3t(circle1Outside, circle2Unqualified, lineUnqualified);\n\tauto expect36 = \"Test case: Outside Unqualified Unqualified\nSolution: 2\n0: 2 2 0.9 1 0 -0 1 0.9\n  Outside Outside Enclosed\n1: 2 5 3 1 0 -0 1 3\n  Outside Enclosing Enclosed\n\";\n\tCHECK(case36.find(expect36) != std::string::npos);\n\tauto case37 = c3t(circle1Unqualified, circle2Enclosed, lineEnclosed);\n\tauto expect37 = \"Test case: Unqualified Enclosed Enclosed\nSolution: 0\n\";\n\tCHECK(case37.find(expect37) != std::string::npos);\n\tauto case38 = c3t(circle1Unqualified, circle2Enclosed, lineOutside);\n\tauto expect38 = \"Test case: Unqualified Enclosed Outside\nSolution: 0\n\";\n\tCHECK(case38.find(expect38) != std::string::npos);\n\tauto case39 = c3t(circle1Unqualified, circle2Enclosed, lineUnqualified);\n\tauto expect39 = \"Test case: Unqualified Enclosed Unqualified\nSolution: 0\n\";\n\tCHECK(case39.find(expect39) != std::string::npos);\n\tauto case40 = c3t(circle1Unqualified, circle2Enclosing, lineEnclosed);\n\tauto expect40 = \"Test case: Unqualified Enclosing Enclosed\nSolution: 2\n0: 2 5 3 1 0 -0 1 3\n  Outside Enclosing Enclosed\n1: 2 2 4.5 1 0 -0 1 4.5\n  Enclosing Enclosing Enclosed\n\";\n\tCHECK(case40.find(expect40) != std::string::npos);\n\tauto case41 = c3t(circle1Unqualified, circle2Enclosing, lineOutside);\n\tauto expect41 = \"Test case: Unqualified Enclosing Outside\nSolution: 0\n\";\n\tCHECK(case41.find(expect41) != std::string::npos);\n\tauto case42 = c3t(circle1Unqualified, circle2Enclosing, lineUnqualified);\n\tauto expect42 = \"Test case: Unqualified Enclosing Unqualified\nSolution: 2\n0: 2 5 3 1 0 -0 1 3\n  Outside Enclosing Enclosed\n1: 2 2 4.5 1 0 -0 1 4.5\n  Enclosing Enclosing Enclosed\n\";\n\tCHECK(case42.find(expect42) != std::string::npos);\n\tauto case43 = c3t(circle1Unqualified, circle2Outside, lineEnclosed);\n\tauto expect43 = \"Test case: Unqualified Outside Enclosed\nSolution: 2\n0: 2 2 0.9 1 0 -0 1 0.9\n  Outside Outside Enclosed\n1: 2 -1 3 1 0 -0 1 3\n  Enclosing Outside Enclosed\n\";\n\tCHECK(case43.find(expect43) != std::string::npos);\n\tauto case44 = c3t(circle1Unqualified, circle2Outside, lineOutside);\n\tauto expect44 = \"Test case: Unqualified Outside Outside\nSolution: 0\n\";\n\tCHECK(case44.find(expect44) != std::string::npos);\n\tauto case45 = c3t(circle1Unqualified, circle2Outside, lineUnqualified);\n\tauto expect45 = \"Test case: Unqualified Outside Unqualified\nSolution: 2\n0: 2 2 0.9 1 0 -0 1 0.9\n  Outside Outside Enclosed\n1: 2 -1 3 1 0 -0 1 3\n  Enclosing Outside Enclosed\n\";\n\tCHECK(case45.find(expect45) != std::string::npos);\n\tauto case46 = c3t(circle1Unqualified, circle2Unqualified, lineEnclosed);\n\tauto expect46 = \"Test case: Unqualified Unqualified Enclosed\nSolution: 4\n0: 2 2 0.9 1 0 -0 1 0.9\n  Outside Outside Enclosed\n1: 2 5 3 1 0 -0 1 3\n  Outside Enclosing Enclosed\n2: 2 -1 3 1 0 -0 1 3\n  Enclosing Outside Enclosed\n3: 2 2 4.5 1 0 -0 1 4.5\n  Enclosing Enclosing Enclosed\n\";\n\tCHECK(case46.find(expect46) != std::string::npos);\n\tauto case47 = c3t(circle1Unqualified, circle2Unqualified, lineOutside);\n\tauto expect47 = \"Test case: Unqualified Unqualified Outside\nSolution: 0\n\";\n\tCHECK(case47.find(expect47) != std::string::npos);\n\tauto case48 = c3t(circle1Unqualified, circle2Unqualified, lineUnqualified);\n\tauto expect48 = \"Test case: Unqualified Unqualified Unqualified\nSolution: 4\n0: 2 2 0.9 1 0 -0 1 0.9\n  Outside Outside Enclosed\n1: 2 5 3 1 0 -0 1 3\n  Outside Enclosing Enclosed\n2: 2 -1 3 1 0 -0 1 3\n  Enclosing Outside Enclosed\n3: 2 2 4.5 1 0 -0 1 4.5\n  Enclosing Enclosing Enclosed\";\n\tCHECK(case48.find(expect48) != std::string::npos);\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API GccCircle3Tangent(const GccQualifiedCurve& qualified1, const GccQualifiedCurve& qualified2, const GccQualifiedCurve& qualified3, double tolerance, double parameter1, double parameter2, double parameter3)\t @param parameter3 The initial guess of the parameter on the third curve\n\t @param parameter2 The initial guess of the parameter on the second curve\n\t @param parameter1 The initial guess of the parameter on the first curve\n\t @param tolerance The tolerance\n\t @param qualified3 The third curve\n\t @param qualified2 The second curve\n\t @param qualified1 The first curve\n\t @brief Construct a circle tangent to three curves\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <geomAlgo/GccCircle3Tangent.hpp>\n#include <geometry/Geom2Curve.hpp>\n#include <geometry/MakeGeom2Line.hpp>\n#include <geometry/MakeGeom2Circle.hpp>\n#include <geomAlgo/GccEntity.hpp>\n#include <geometry/AdaptorGeom2Curve.hpp>\n#include <geomAlgo/GccEntity.hpp>\n#include <geomAlgo/GccQualifiedCurve.hpp>\n#include <sstream>\nusing namespace AMCAX;\nTEST_CASE(\"bug1: GccCircle3Tangent  add 48 cases\", \"[geomAlgo][GccCircle3Tangent][fixbug]\") {\n\tstd::shared_ptr<Geom2Curve> l = MakeGeom2Line(Point2(0.0, 0.0), Point2(1.0, 0.0)).Value();\n\tstd::shared_ptr<Geom2Curve> c1 = MakeGeom2Circle(Point2(0.0, 3.0), 2.0).Value();\n\tstd::shared_ptr<Geom2Curve> c2 = MakeGeom2Circle(Point2(4.0, 3.0), 2.0).Value();\n\tAdaptorGeom2Curve line(l);\n\tAdaptorGeom2Curve circle1(c1);\n\tAdaptorGeom2Curve circle2(c2);\n\tauto lineEnclosed = GccEntity::Enclosed(line);\n\tauto lineOutside = GccEntity::Outside(line);\n\tauto lineUnqualified = GccEntity::Unqualified(line);\n\tauto circle1Enclosed = GccEntity::Enclosed(circle1);\n\tauto circle1Enclosing = GccEntity::Enclosing(circle1);\n\tauto circle1Outside = GccEntity::Outside(circle1);\n\tauto circle1Unqualified = GccEntity::Unqualified(circle1);\n\tauto circle2Enclosed = GccEntity::Enclosed(circle2);\n\tauto circle2Enclosing = GccEntity::Enclosing(circle2);\n\tauto circle2Outside = GccEntity::Outside(circle2);\n\tauto circle2Unqualified = GccEntity::Unqualified(circle2);\n\tauto gccl = GccEntity::Enclosed(AdaptorGeom2Curve(l));\n\tauto gccc1 = GccEntity::Enclosing(AdaptorGeom2Curve(c1));\n\tauto gccc2 = GccEntity::Outside(AdaptorGeom2Curve(c2));\n\tauto c3t = [](const GccQualifiedCurve& gccc1, const GccQualifiedCurve& gccc2, const GccQualifiedCurve& gccl)\n\t{\n\t\tstd::stringstream output;\n\t\tGccCircle3Tangent gcc(gccc1, gccc2, gccl, Precision::Confusion(), 0.0, 0.0, 0.0);\n\t\tstd::cout << \"Test case: \" << GccEntity::PositionToString(gccc1.Qualifier()) << ' ' << GccEntity::PositionToString(gccc2.Qualifier()) << ' ' << GccEntity::PositionToString(gccl.Qualifier()) << std::endl;\n\t\tstd::cout << \"Solution: \" << gcc.NSolutions() << std::endl;\n\t\toutput << \"Test case: \" << GccEntity::PositionToString(gccc1.Qualifier()) << ' ' << GccEntity::PositionToString(gccc2.Qualifier()) << ' ' << GccEntity::PositionToString(gccl.Qualifier()) << std::endl;\n\t\toutput << \"Solution: \" << gcc.NSolutions() << std::endl;\n\t\tif (gcc.IsDone())\n\t\t{\n\t\t\tfor (int i = 0; i < gcc.NSolutions(); i++)\n\t\t\t{\n\t\t\t\tGccPosition q1, q2, q3;\n\t\t\t\tgcc.Qualifier(i, q1, q2, q3);\n\t\t\t\toutput << i << \": \" << *MakeGeom2Circle(gcc.Solution(i)).Value() << std::endl;\n\t\t\t\toutput << \"  \" << GccEntity::PositionToString(q1) << ' ' << GccEntity::PositionToString(q2) << ' ' << GccEntity::PositionToString(q3) << std::endl;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tstd::cout << \"gcc.IsDone is False\" << std::endl;\n\t\t\toutput << \"gcc.IsDone is False\" << std::endl;\n\t\t}\n\t\treturn output.str();\n\t};\n\tauto case1 = c3t(circle1Enclosed, circle2Enclosed, lineEnclosed);\n\tauto expect1 = \"Test case: Enclosed Enclosed Enclosed\nSolution: 0\n\";\n\tCHECK(case1.find(expect1) != std::string::npos);\n\tauto case2 = c3t(circle1Enclosed, circle2Enclosed, lineOutside);\n\tauto expect2 = \"Test case: Enclosed Enclosed Outside\nSolution: 0\n\";\n\tCHECK(case2.find(expect2) != std::string::npos);\n\tauto case3 = c3t(circle1Enclosed, circle2Enclosed, lineUnqualified);\n\tauto expect3 = \"Test case: Enclosed Enclosed Unqualified\nSolution: 0\n\";\n\tCHECK(case3.find(expect3) != std::string::npos);\n\tauto case4 = c3t(circle1Enclosed, circle2Enclosing, lineEnclosed);\n\tauto expect4 = \"Test case: Enclosed Enclosing Enclosed\nSolution: 0\n\";\n\tCHECK(case4.find(expect4) != std::string::npos);\n\tauto case5 = c3t(circle1Enclosed, circle2Enclosing, lineOutside);\n\tauto expect5 = \"Test case: Enclosed Enclosing Outside\nSolution: 0\n\";\n\tCHECK(case5.find(expect5) != std::string::npos);\n\tauto case6 = c3t(circle1Enclosed, circle2Enclosing, lineUnqualified);\n\tauto expect6 = \"Test case: Enclosed Enclosing Unqualified\nSolution: 0\n\";\n\tCHECK(case6.find(expect6) != std::string::npos);\n\tauto case7 = c3t(circle1Enclosed, circle2Outside, lineEnclosed);\n\tauto expect7 = \"Test case: Enclosed Outside Enclosed\nSolution: 0\n\";\n\tCHECK(case7.find(expect7) != std::string::npos);\n\tauto case8 = c3t(circle1Enclosed, circle2Outside, lineOutside);\n\tauto expect8 = \"Test case: Enclosed Outside Outside\nSolution: 0\n\";\n\tCHECK(case8.find(expect8) != std::string::npos);\n\tauto case9 = c3t(circle1Enclosed, circle2Outside, lineUnqualified);\n\tauto expect9 = \"Test case: Enclosed Outside Unqualified\nSolution: 0\n\";\n\tCHECK(case9.find(expect9) != std::string::npos);\n\tauto case10 = c3t(circle1Enclosed, circle2Unqualified, lineEnclosed);\n\tauto expect10 = \"Test case: Enclosed Unqualified Enclosed\nSolution: 0\n\";\n\tCHECK(case10.find(expect10) != std::string::npos);\n\tauto case11 = c3t(circle1Enclosed, circle2Unqualified, lineOutside);\n\tauto expect11 = \"Test case: Enclosed Unqualified Outside\nSolution: 0\n\";\n\tCHECK(case11.find(expect11) != std::string::npos);\n\tauto case12 = c3t(circle1Enclosed, circle2Unqualified, lineUnqualified);\n\tauto expect12 = \"Test case: Enclosed Unqualified Unqualified\nSolution: 0\n\";\n\tCHECK(case12.find(expect12) != std::string::npos);\n\tauto case13 = c3t(circle1Enclosing, circle2Enclosed, lineEnclosed);\n\tauto expect13 = \"Test case: Enclosing Enclosed Enclosed\nSolution: 0\n\";\n\tCHECK(case13.find(expect13) != std::string::npos);\n\tauto case14 = c3t(circle1Enclosing, circle2Enclosed, lineOutside);\n\tauto expect14 = \"Test case: Enclosing Enclosed Outside\nSolution: 0\n\";\n\tCHECK(case14.find(expect14) != std::string::npos);\n\tauto case15 = c3t(circle1Enclosing, circle2Enclosed, lineUnqualified);\n\tauto expect15 = \"Test case: Enclosing Enclosed Unqualified\nSolution: 0\n\";\n\tCHECK(case15.find(expect15) != std::string::npos);\n\tauto case16 = c3t(circle1Enclosing, circle2Enclosing, lineEnclosed);\n\tauto expect16 = \"Test case: Enclosing Enclosing Enclosed\nSolution: 1\n0: 2 2 4.5 1 0 -0 1 4.5\n  Enclosing Enclosing Enclosed\n\";\n\tCHECK(case16.find(expect16) != std::string::npos);\n\tauto case17 = c3t(circle1Enclosing, circle2Enclosing, lineOutside);\n\tauto expect17 = \"Test case: Enclosing Enclosing Outside\nSolution: 0\n\";\n\tCHECK(case17.find(expect17) != std::string::npos);\n\tauto case18 = c3t(circle1Enclosing, circle2Enclosing, lineUnqualified);\n\tauto expect18 = \"Test case: Enclosing Enclosing Unqualified\nSolution: 1\n0: 2 2 4.5 1 0 -0 1 4.5\n  Enclosing Enclosing Enclosed\n\";\n\tCHECK(case18.find(expect18) != std::string::npos);\n\tauto case19 = c3t(circle1Enclosing, circle2Outside, lineEnclosed);\n\tauto expect19 = \"Test case: Enclosing Outside Enclosed\nSolution: 1\n0: 2 -1 3 1 0 -0 1 3\n  Enclosing Outside Enclosed\n\";\n\tCHECK(case19.find(expect19) != std::string::npos);\n\tauto case20 = c3t(circle1Enclosing, circle2Outside, lineOutside);\n\tauto expect20 = \"Test case: Enclosing Outside Outside\nSolution: 0\n\";\n\tCHECK(case20.find(expect20) != std::string::npos);\n\tauto case21 = c3t(circle1Enclosing, circle2Outside, lineUnqualified);\n\tauto expect21 = \"Test case: Enclosing Outside Unqualified\nSolution: 1\n0: 2 -1 3 1 0 -0 1 3\n  Enclosing Outside Enclosed\n\";\n\tCHECK(case21.find(expect21) != std::string::npos);\n\tauto case22 = c3t(circle1Enclosing, circle2Unqualified, lineEnclosed);\n\tauto expect22 = \"Test case: Enclosing Unqualified Enclosed\nSolution: 2\n0: 2 -1 3 1 0 -0 1 3\n  Enclosing Outside Enclosed\n1: 2 2 4.5 1 0 -0 1 4.5\n  Enclosing Enclosing Enclosed\n\";\n\tCHECK(case22.find(expect22) != std::string::npos);\n\tauto case23 = c3t(circle1Enclosing, circle2Unqualified, lineOutside);\n\tauto expect23 = \"Test case: Enclosing Unqualified Outside\nSolution: 0\n\";\n\tCHECK(case23.find(expect23) != std::string::npos);\n\tauto case24 = c3t(circle1Enclosing, circle2Unqualified, lineUnqualified);\n\tauto expect24 = \"Test case: Enclosing Unqualified Unqualified\nSolution: 2\n0: 2 -1 3 1 0 -0 1 3\n  Enclosing Outside Enclosed\n1: 2 2 4.5 1 0 -0 1 4.5\n  Enclosing Enclosing Enclosed\n\";\n\tCHECK(case24.find(expect24) != std::string::npos);\n\tauto case25 = c3t(circle1Outside, circle2Enclosed, lineEnclosed);\n\tauto expect25 = \"Test case: Outside Enclosed Enclosed\nSolution: 0\n\";\n\tCHECK(case25.find(expect25) != std::string::npos);\n\tauto case26 = c3t(circle1Outside, circle2Enclosed, lineOutside);\n\tauto expect26 = \"Test case: Outside Enclosed Outside\nSolution: 0\n\";\n\tCHECK(case26.find(expect26) != std::string::npos);\n\tauto case27 = c3t(circle1Outside, circle2Enclosed, lineUnqualified);\n\tauto expect27 = \"Test case: Outside Enclosed Unqualified\nSolution: 0\n\";\n\tCHECK(case27.find(expect27) != std::string::npos);\n\tauto case28 = c3t(circle1Outside, circle2Enclosing, lineEnclosed);\n\tauto expect28 = \"Test case: Outside Enclosing Enclosed\nSolution: 1\n0: 2 5 3 1 0 -0 1 3\n  Outside Enclosing Enclosed\n\";\n\tCHECK(case28.find(expect28) != std::string::npos);\n\tauto case29 = c3t(circle1Outside, circle2Enclosing, lineOutside);\n\tauto expect29 = \"Test case: Outside Enclosing Outside\nSolution: 0\n\";\n\tCHECK(case29.find(expect29) != std::string::npos);\n\tauto case30 = c3t(circle1Outside, circle2Enclosing, lineUnqualified);\n\tauto expect30 = \"Test case: Outside Enclosing Unqualified\nSolution: 1\n0: 2 5 3 1 0 -0 1 3\n  Outside Enclosing Enclosed\n\";\n\tCHECK(case30.find(expect30) != std::string::npos);\n\tauto case31 = c3t(circle1Outside, circle2Outside, lineEnclosed);\n\tauto expect31 = \"Test case: Outside Outside Enclosed\nSolution: 1\n0: 2 2 0.9 1 0 -0 1 0.9\n  Outside Outside Enclosed\n\";\n\tCHECK(case31.find(expect31) != std::string::npos);\n\tauto case32 = c3t(circle1Outside, circle2Outside, lineOutside);\n\tauto expect32 = \"Test case: Outside Outside Outside\nSolution: 0\n\";\n\tCHECK(case32.find(expect32) != std::string::npos);\n\tauto case33 = c3t(circle1Outside, circle2Outside, lineUnqualified);\n\tauto expect33 = \"Test case: Outside Outside Unqualified\nSolution: 1\n0: 2 2 0.9 1 0 -0 1 0.9\n  Outside Outside Enclosed\n\";\n\tCHECK(case33.find(expect33) != std::string::npos);\n\tauto case34 = c3t(circle1Outside, circle2Unqualified, lineEnclosed);\n\tauto expect34 = \"Test case: Outside Unqualified Enclosed\nSolution: 2\n0: 2 2 0.9 1 0 -0 1 0.9\n  Outside Outside Enclosed\n1: 2 5 3 1 0 -0 1 3\n  Outside Enclosing Enclosed\n\";\n\tCHECK(case34.find(expect34) != std::string::npos);\n\tauto case35 = c3t(circle1Outside, circle2Unqualified, lineOutside);\n\tauto expect35 = \"Test case: Outside Unqualified Outside\nSolution: 0\n\";\n\tCHECK(case35.find(expect35) != std::string::npos);\n\tauto case36 = c3t(circle1Outside, circle2Unqualified, lineUnqualified);\n\tauto expect36 = \"Test case: Outside Unqualified Unqualified\nSolution: 2\n0: 2 2 0.9 1 0 -0 1 0.9\n  Outside Outside Enclosed\n1: 2 5 3 1 0 -0 1 3\n  Outside Enclosing Enclosed\n\";\n\tCHECK(case36.find(expect36) != std::string::npos);\n\tauto case37 = c3t(circle1Unqualified, circle2Enclosed, lineEnclosed);\n\tauto expect37 = \"Test case: Unqualified Enclosed Enclosed\nSolution: 0\n\";\n\tCHECK(case37.find(expect37) != std::string::npos);\n\tauto case38 = c3t(circle1Unqualified, circle2Enclosed, lineOutside);\n\tauto expect38 = \"Test case: Unqualified Enclosed Outside\nSolution: 0\n\";\n\tCHECK(case38.find(expect38) != std::string::npos);\n\tauto case39 = c3t(circle1Unqualified, circle2Enclosed, lineUnqualified);\n\tauto expect39 = \"Test case: Unqualified Enclosed Unqualified\nSolution: 0\n\";\n\tCHECK(case39.find(expect39) != std::string::npos);\n\tauto case40 = c3t(circle1Unqualified, circle2Enclosing, lineEnclosed);\n\tauto expect40 = \"Test case: Unqualified Enclosing Enclosed\nSolution: 2\n0: 2 5 3 1 0 -0 1 3\n  Outside Enclosing Enclosed\n1: 2 2 4.5 1 0 -0 1 4.5\n  Enclosing Enclosing Enclosed\n\";\n\tCHECK(case40.find(expect40) != std::string::npos);\n\tauto case41 = c3t(circle1Unqualified, circle2Enclosing, lineOutside);\n\tauto expect41 = \"Test case: Unqualified Enclosing Outside\nSolution: 0\n\";\n\tCHECK(case41.find(expect41) != std::string::npos);\n\tauto case42 = c3t(circle1Unqualified, circle2Enclosing, lineUnqualified);\n\tauto expect42 = \"Test case: Unqualified Enclosing Unqualified\nSolution: 2\n0: 2 5 3 1 0 -0 1 3\n  Outside Enclosing Enclosed\n1: 2 2 4.5 1 0 -0 1 4.5\n  Enclosing Enclosing Enclosed\n\";\n\tCHECK(case42.find(expect42) != std::string::npos);\n\tauto case43 = c3t(circle1Unqualified, circle2Outside, lineEnclosed);\n\tauto expect43 = \"Test case: Unqualified Outside Enclosed\nSolution: 2\n0: 2 2 0.9 1 0 -0 1 0.9\n  Outside Outside Enclosed\n1: 2 -1 3 1 0 -0 1 3\n  Enclosing Outside Enclosed\n\";\n\tCHECK(case43.find(expect43) != std::string::npos);\n\tauto case44 = c3t(circle1Unqualified, circle2Outside, lineOutside);\n\tauto expect44 = \"Test case: Unqualified Outside Outside\nSolution: 0\n\";\n\tCHECK(case44.find(expect44) != std::string::npos);\n\tauto case45 = c3t(circle1Unqualified, circle2Outside, lineUnqualified);\n\tauto expect45 = \"Test case: Unqualified Outside Unqualified\nSolution: 2\n0: 2 2 0.9 1 0 -0 1 0.9\n  Outside Outside Enclosed\n1: 2 -1 3 1 0 -0 1 3\n  Enclosing Outside Enclosed\n\";\n\tCHECK(case45.find(expect45) != std::string::npos);\n\tauto case46 = c3t(circle1Unqualified, circle2Unqualified, lineEnclosed);\n\tauto expect46 = \"Test case: Unqualified Unqualified Enclosed\nSolution: 4\n0: 2 2 0.9 1 0 -0 1 0.9\n  Outside Outside Enclosed\n1: 2 5 3 1 0 -0 1 3\n  Outside Enclosing Enclosed\n2: 2 -1 3 1 0 -0 1 3\n  Enclosing Outside Enclosed\n3: 2 2 4.5 1 0 -0 1 4.5\n  Enclosing Enclosing Enclosed\n\";\n\tCHECK(case46.find(expect46) != std::string::npos);\n\tauto case47 = c3t(circle1Unqualified, circle2Unqualified, lineOutside);\n\tauto expect47 = \"Test case: Unqualified Unqualified Outside\nSolution: 0\n\";\n\tCHECK(case47.find(expect47) != std::string::npos);\n\tauto case48 = c3t(circle1Unqualified, circle2Unqualified, lineUnqualified);\n\tauto expect48 = \"Test case: Unqualified Unqualified Unqualified\nSolution: 4\n0: 2 2 0.9 1 0 -0 1 0.9\n  Outside Outside Enclosed\n1: 2 5 3 1 0 -0 1 3\n  Outside Enclosing Enclosed\n2: 2 -1 3 1 0 -0 1 3\n  Enclosing Outside Enclosed\n3: 2 2 4.5 1 0 -0 1 4.5\n  Enclosing Enclosing Enclosed\";\n\tCHECK(case48.find(expect48) != std::string::npos);\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API explicit MakeFace(const TopoWire& w, bool onlyPlane = false)\t @param onlyPlane If true, the surface will be a plane\n\t @param w The wire\n\t @brief Construct from a wire\n,\n",
      "output": "?#include<catch.hpp>\n#include<testHelper.h>\n#include <topology/TopoExplorerTool.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeWire.hpp>\n#include <modeling/MakeFace.hpp>\n#include <offset/MakeFaceExtension.hpp>\n#include <topomesh/BRepMeshIncrementalMesh.hpp>\n#include <io/OBJTool.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <topology/TopoTool.hpp>\n#include <topology/TopoVertex.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"Not fix bug:case2:PerformWithEdgeAndLength  \", \"[offset][PerformWithEdgeAndLength][P1][bug]\") {\n\tCircle3 c1(Frame3(), 10.);\n\tCircle3 c2(Frame3(), 4.);\n\tTopoEdge e1 = MakeEdge(c1);\n\tTopoWire w1 = MakeWire(e1);\n\tTopoEdge e2 = MakeEdge(c2);\n\tTopoWire w2 = MakeWire(e2);\n\tw2.Reverse();\n\tMakeFace mkF(w1);\n\tmkF.Add(w2);\n\tmkF.Build();\n\tTopoFace face = mkF.Face();\n\tBRepMeshIncrementalMesh meshF(face, 0.01);\n\tIndexSet<TopoShape> fedge;\n\tTopoExplorerTool::MapShapes(face, ShapeType::Edge, fedge);\n\tMakeFaceExtension mkExt;\n\tmkExt.SetFace(face);\n\tSECTION(\"PerformWithEdgeAndLength 5.0 \") {\n\t\t\tTopoEdge edge = static_cast<const TopoEdge&>(fedge[1]);\n\t\t\tmkExt.PerformWithEdgeAndLength(edge, 5.0);\n\t\t\tCHECK(mkExt.IsDone() == false);\n\t\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API MakeFace(const std::shared_ptr<Geom3Surface>& s, const TopoWire& w, bool inside = true)\t @param inside Whether the face is inside the wire\n\t @param w The wire\n\t @param s The surface\n\t @brief Construct from a surface and a wire\n,\n",
      "output": "#include <catch.hpp>\n#include \"testHelper.h\"\n#include<iostream>\n#include <common/PointT.hpp>\n#include <topology/TopoEdge.hpp>\n#include <modeling/MakeWire.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <topology/TopoWire.hpp>\n#include <topology/TopoShape.hpp>\n#include <topology/TopoFace.hpp>\n#include <modeling/MakeFace.hpp>\nAMCAX::TopoFace crashbug1() {\n    double h1 = 7., h2 = 3.;\n    AMCAX::Point2 p1(0., h1 / 2.0), p2(30., h2 / 2.0), p3(30., -h2 / 2.0), p4(0., -h1 / 2.0);\n    std::vector<AMCAX::Point2> v_p;\n    v_p.push_back(p1);\n    v_p.push_back(p2);\n    v_p.push_back(p3);\n    v_p.push_back(p4);\n    AMCAX::TopoEdge e;\n    std::list<AMCAX::TopoShape> edges_polygon;\n    for (int i = 1; i < v_p.size(); i++) {\n        e = AMCAX::MakeEdge2d(v_p[i - 1], v_p[i]);\n        edges_polygon.push_back(e);\n    }\n    e = AMCAX::MakeEdge2d(v_p[3], v_p[0]);\n    edges_polygon.push_back(e);\n    AMCAX::MakeWire mkw;\n    mkw.Add(edges_polygon);\n    AMCAX::TopoWire w_poly = mkw;\n    AMCAX::TopoFace f_poly = AMCAX::MakeFace(w_poly, true);\n    return f_poly;\n}\n#include <catch.hpp>\n#include \"testHelper.h\"\n#include<iostream>\n#include <common/PointT.hpp>\n#include <topology/TopoEdge.hpp>\n#include <modeling/MakeWire.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <topology/TopoWire.hpp>\n#include <topology/TopoShape.hpp>\n#include <topology/TopoFace.hpp>\n#include <modeling/MakeFace.hpp>\nAMCAX::TopoFace crashbug1() {\n    double h1 = 7., h2 = 3.;\n    AMCAX::Point2 p1(0., h1 / 2.0), p2(30., h2 / 2.0), p3(30., -h2 / 2.0), p4(0., -h1 / 2.0);\n    std::vector<AMCAX::Point2> v_p;\n    v_p.push_back(p1);\n    v_p.push_back(p2);\n    v_p.push_back(p3);\n    v_p.push_back(p4);\n    AMCAX::TopoEdge e;\n    std::list<AMCAX::TopoShape> edges_polygon;\n    for (int i = 1; i < v_p.size(); i++) {\n        e = AMCAX::MakeEdge2d(v_p[i - 1], v_p[i]);\n        edges_polygon.push_back(e);\n    }\n    e = AMCAX::MakeEdge2d(v_p[3], v_p[0]);\n    edges_polygon.push_back(e);\n    AMCAX::MakeWire mkw;\n    mkw.Add(edges_polygon);\n    AMCAX::TopoWire w_poly = mkw;\n    AMCAX::TopoFace f_poly = AMCAX::MakeFace(w_poly, true);\n    return f_poly;\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API MakeFace(const Torus& t, const TopoWire& w, bool inside = true)\t @param inside Whether the face is inside the wire\n\t @param w The wire\n\t @param t The torus\n\t @brief Construct from a torus and a wire\n,\n",
      "output": "#include <catch.hpp>\n#include \"testHelper.h\"\n#include<iostream>\n#include <common/PointT.hpp>\n#include <topology/TopoEdge.hpp>\n#include <modeling/MakeWire.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <topology/TopoWire.hpp>\n#include <topology/TopoShape.hpp>\n#include <topology/TopoFace.hpp>\n#include <modeling/MakeFace.hpp>\nAMCAX::TopoFace crashbug1() {\n    double h1 = 7., h2 = 3.;\n    AMCAX::Point2 p1(0., h1 / 2.0), p2(30., h2 / 2.0), p3(30., -h2 / 2.0), p4(0., -h1 / 2.0);\n    std::vector<AMCAX::Point2> v_p;\n    v_p.push_back(p1);\n    v_p.push_back(p2);\n    v_p.push_back(p3);\n    v_p.push_back(p4);\n    AMCAX::TopoEdge e;\n    std::list<AMCAX::TopoShape> edges_polygon;\n    for (int i = 1; i < v_p.size(); i++) {\n        e = AMCAX::MakeEdge2d(v_p[i - 1], v_p[i]);\n        edges_polygon.push_back(e);\n    }\n    e = AMCAX::MakeEdge2d(v_p[3], v_p[0]);\n    edges_polygon.push_back(e);\n    AMCAX::MakeWire mkw;\n    mkw.Add(edges_polygon);\n    AMCAX::TopoWire w_poly = mkw;\n    AMCAX::TopoFace f_poly = AMCAX::MakeFace(w_poly, true);\n    return f_poly;\n}\n#include <catch.hpp>\n#include \"testHelper.h\"\n#include<iostream>\n#include <common/PointT.hpp>\n#include <topology/TopoEdge.hpp>\n#include <modeling/MakeWire.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <topology/TopoWire.hpp>\n#include <topology/TopoShape.hpp>\n#include <topology/TopoFace.hpp>\n#include <modeling/MakeFace.hpp>\nAMCAX::TopoFace crashbug1() {\n    double h1 = 7., h2 = 3.;\n    AMCAX::Point2 p1(0., h1 / 2.0), p2(30., h2 / 2.0), p3(30., -h2 / 2.0), p4(0., -h1 / 2.0);\n    std::vector<AMCAX::Point2> v_p;\n    v_p.push_back(p1);\n    v_p.push_back(p2);\n    v_p.push_back(p3);\n    v_p.push_back(p4);\n    AMCAX::TopoEdge e;\n    std::list<AMCAX::TopoShape> edges_polygon;\n    for (int i = 1; i < v_p.size(); i++) {\n        e = AMCAX::MakeEdge2d(v_p[i - 1], v_p[i]);\n        edges_polygon.push_back(e);\n    }\n    e = AMCAX::MakeEdge2d(v_p[3], v_p[0]);\n    edges_polygon.push_back(e);\n    AMCAX::MakeWire mkw;\n    mkw.Add(edges_polygon);\n    AMCAX::TopoWire w_poly = mkw;\n    AMCAX::TopoFace f_poly = AMCAX::MakeFace(w_poly, true);\n    return f_poly;\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API MakeFace(const Sphere& s, const TopoWire& w, bool inside = true)\t @param inside Whether the face is inside the wire\n\t @param w The wire\n\t @param s The sphere\n\t @brief Construct from a sphere and a wire\n,\n",
      "output": "#include <catch.hpp>\n#include \"testHelper.h\"\n#include<iostream>\n#include <common/PointT.hpp>\n#include <topology/TopoEdge.hpp>\n#include <modeling/MakeWire.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <topology/TopoWire.hpp>\n#include <topology/TopoShape.hpp>\n#include <topology/TopoFace.hpp>\n#include <modeling/MakeFace.hpp>\nAMCAX::TopoFace crashbug1() {\n    double h1 = 7., h2 = 3.;\n    AMCAX::Point2 p1(0., h1 / 2.0), p2(30., h2 / 2.0), p3(30., -h2 / 2.0), p4(0., -h1 / 2.0);\n    std::vector<AMCAX::Point2> v_p;\n    v_p.push_back(p1);\n    v_p.push_back(p2);\n    v_p.push_back(p3);\n    v_p.push_back(p4);\n    AMCAX::TopoEdge e;\n    std::list<AMCAX::TopoShape> edges_polygon;\n    for (int i = 1; i < v_p.size(); i++) {\n        e = AMCAX::MakeEdge2d(v_p[i - 1], v_p[i]);\n        edges_polygon.push_back(e);\n    }\n    e = AMCAX::MakeEdge2d(v_p[3], v_p[0]);\n    edges_polygon.push_back(e);\n    AMCAX::MakeWire mkw;\n    mkw.Add(edges_polygon);\n    AMCAX::TopoWire w_poly = mkw;\n    AMCAX::TopoFace f_poly = AMCAX::MakeFace(w_poly, true);\n    return f_poly;\n}\n#include <catch.hpp>\n#include \"testHelper.h\"\n#include<iostream>\n#include <common/PointT.hpp>\n#include <topology/TopoEdge.hpp>\n#include <modeling/MakeWire.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <topology/TopoWire.hpp>\n#include <topology/TopoShape.hpp>\n#include <topology/TopoFace.hpp>\n#include <modeling/MakeFace.hpp>\nAMCAX::TopoFace crashbug1() {\n    double h1 = 7., h2 = 3.;\n    AMCAX::Point2 p1(0., h1 / 2.0), p2(30., h2 / 2.0), p3(30., -h2 / 2.0), p4(0., -h1 / 2.0);\n    std::vector<AMCAX::Point2> v_p;\n    v_p.push_back(p1);\n    v_p.push_back(p2);\n    v_p.push_back(p3);\n    v_p.push_back(p4);\n    AMCAX::TopoEdge e;\n    std::list<AMCAX::TopoShape> edges_polygon;\n    for (int i = 1; i < v_p.size(); i++) {\n        e = AMCAX::MakeEdge2d(v_p[i - 1], v_p[i]);\n        edges_polygon.push_back(e);\n    }\n    e = AMCAX::MakeEdge2d(v_p[3], v_p[0]);\n    edges_polygon.push_back(e);\n    AMCAX::MakeWire mkw;\n    mkw.Add(edges_polygon);\n    AMCAX::TopoWire w_poly = mkw;\n    AMCAX::TopoFace f_poly = AMCAX::MakeFace(w_poly, true);\n    return f_poly;\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API MakeFace(const Cone& c, const TopoWire& w, bool inside = true)\t @param inside Whether the face is inside the wire\n\t @param w The wire\n\t @param c The cone\n\t @brief Construct from a cone and a wire\n,\n",
      "output": "#include <catch.hpp>\n#include \"testHelper.h\"\n#include<iostream>\n#include <common/PointT.hpp>\n#include <topology/TopoEdge.hpp>\n#include <modeling/MakeWire.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <topology/TopoWire.hpp>\n#include <topology/TopoShape.hpp>\n#include <topology/TopoFace.hpp>\n#include <modeling/MakeFace.hpp>\nAMCAX::TopoFace crashbug1() {\n    double h1 = 7., h2 = 3.;\n    AMCAX::Point2 p1(0., h1 / 2.0), p2(30., h2 / 2.0), p3(30., -h2 / 2.0), p4(0., -h1 / 2.0);\n    std::vector<AMCAX::Point2> v_p;\n    v_p.push_back(p1);\n    v_p.push_back(p2);\n    v_p.push_back(p3);\n    v_p.push_back(p4);\n    AMCAX::TopoEdge e;\n    std::list<AMCAX::TopoShape> edges_polygon;\n    for (int i = 1; i < v_p.size(); i++) {\n        e = AMCAX::MakeEdge2d(v_p[i - 1], v_p[i]);\n        edges_polygon.push_back(e);\n    }\n    e = AMCAX::MakeEdge2d(v_p[3], v_p[0]);\n    edges_polygon.push_back(e);\n    AMCAX::MakeWire mkw;\n    mkw.Add(edges_polygon);\n    AMCAX::TopoWire w_poly = mkw;\n    AMCAX::TopoFace f_poly = AMCAX::MakeFace(w_poly, true);\n    return f_poly;\n}\n#include <catch.hpp>\n#include \"testHelper.h\"\n#include<iostream>\n#include <common/PointT.hpp>\n#include <topology/TopoEdge.hpp>\n#include <modeling/MakeWire.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <topology/TopoWire.hpp>\n#include <topology/TopoShape.hpp>\n#include <topology/TopoFace.hpp>\n#include <modeling/MakeFace.hpp>\nAMCAX::TopoFace crashbug1() {\n    double h1 = 7., h2 = 3.;\n    AMCAX::Point2 p1(0., h1 / 2.0), p2(30., h2 / 2.0), p3(30., -h2 / 2.0), p4(0., -h1 / 2.0);\n    std::vector<AMCAX::Point2> v_p;\n    v_p.push_back(p1);\n    v_p.push_back(p2);\n    v_p.push_back(p3);\n    v_p.push_back(p4);\n    AMCAX::TopoEdge e;\n    std::list<AMCAX::TopoShape> edges_polygon;\n    for (int i = 1; i < v_p.size(); i++) {\n        e = AMCAX::MakeEdge2d(v_p[i - 1], v_p[i]);\n        edges_polygon.push_back(e);\n    }\n    e = AMCAX::MakeEdge2d(v_p[3], v_p[0]);\n    edges_polygon.push_back(e);\n    AMCAX::MakeWire mkw;\n    mkw.Add(edges_polygon);\n    AMCAX::TopoWire w_poly = mkw;\n    AMCAX::TopoFace f_poly = AMCAX::MakeFace(w_poly, true);\n    return f_poly;\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API MakeFace(const Cylinder& c, const TopoWire& w, bool inside = true)\t @param inside Whether the face is inside the wire\n\t @param w The wire\n\t @param c The cylinder\n\t @brief Construct from a cylinder and a wire\n,\n",
      "output": "#include <catch.hpp>\n#include \"testHelper.h\"\n#include<iostream>\n#include <common/PointT.hpp>\n#include <topology/TopoEdge.hpp>\n#include <modeling/MakeWire.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <topology/TopoWire.hpp>\n#include <topology/TopoShape.hpp>\n#include <topology/TopoFace.hpp>\n#include <modeling/MakeFace.hpp>\nAMCAX::TopoFace crashbug1() {\n    double h1 = 7., h2 = 3.;\n    AMCAX::Point2 p1(0., h1 / 2.0), p2(30., h2 / 2.0), p3(30., -h2 / 2.0), p4(0., -h1 / 2.0);\n    std::vector<AMCAX::Point2> v_p;\n    v_p.push_back(p1);\n    v_p.push_back(p2);\n    v_p.push_back(p3);\n    v_p.push_back(p4);\n    AMCAX::TopoEdge e;\n    std::list<AMCAX::TopoShape> edges_polygon;\n    for (int i = 1; i < v_p.size(); i++) {\n        e = AMCAX::MakeEdge2d(v_p[i - 1], v_p[i]);\n        edges_polygon.push_back(e);\n    }\n    e = AMCAX::MakeEdge2d(v_p[3], v_p[0]);\n    edges_polygon.push_back(e);\n    AMCAX::MakeWire mkw;\n    mkw.Add(edges_polygon);\n    AMCAX::TopoWire w_poly = mkw;\n    AMCAX::TopoFace f_poly = AMCAX::MakeFace(w_poly, true);\n    return f_poly;\n}\n#include <catch.hpp>\n#include \"testHelper.h\"\n#include<iostream>\n#include <common/PointT.hpp>\n#include <topology/TopoEdge.hpp>\n#include <modeling/MakeWire.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <topology/TopoWire.hpp>\n#include <topology/TopoShape.hpp>\n#include <topology/TopoFace.hpp>\n#include <modeling/MakeFace.hpp>\nAMCAX::TopoFace crashbug1() {\n    double h1 = 7., h2 = 3.;\n    AMCAX::Point2 p1(0., h1 / 2.0), p2(30., h2 / 2.0), p3(30., -h2 / 2.0), p4(0., -h1 / 2.0);\n    std::vector<AMCAX::Point2> v_p;\n    v_p.push_back(p1);\n    v_p.push_back(p2);\n    v_p.push_back(p3);\n    v_p.push_back(p4);\n    AMCAX::TopoEdge e;\n    std::list<AMCAX::TopoShape> edges_polygon;\n    for (int i = 1; i < v_p.size(); i++) {\n        e = AMCAX::MakeEdge2d(v_p[i - 1], v_p[i]);\n        edges_polygon.push_back(e);\n    }\n    e = AMCAX::MakeEdge2d(v_p[3], v_p[0]);\n    edges_polygon.push_back(e);\n    AMCAX::MakeWire mkw;\n    mkw.Add(edges_polygon);\n    AMCAX::TopoWire w_poly = mkw;\n    AMCAX::TopoFace f_poly = AMCAX::MakeFace(w_poly, true);\n    return f_poly;\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API MakeFace(const Plane& p, const TopoWire& w, bool inside = true)\t @param inside Whether the face is inside the wire\n\t @param w The wire\n\t @param p The plane\n\t @brief Construct from a plane and a wire\n,\n",
      "output": "#include <catch.hpp>\n#include \"testHelper.h\"\n#include<iostream>\n#include <common/PointT.hpp>\n#include <topology/TopoEdge.hpp>\n#include <modeling/MakeWire.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <topology/TopoWire.hpp>\n#include <topology/TopoShape.hpp>\n#include <topology/TopoFace.hpp>\n#include <modeling/MakeFace.hpp>\nAMCAX::TopoFace crashbug1() {\n    double h1 = 7., h2 = 3.;\n    AMCAX::Point2 p1(0., h1 / 2.0), p2(30., h2 / 2.0), p3(30., -h2 / 2.0), p4(0., -h1 / 2.0);\n    std::vector<AMCAX::Point2> v_p;\n    v_p.push_back(p1);\n    v_p.push_back(p2);\n    v_p.push_back(p3);\n    v_p.push_back(p4);\n    AMCAX::TopoEdge e;\n    std::list<AMCAX::TopoShape> edges_polygon;\n    for (int i = 1; i < v_p.size(); i++) {\n        e = AMCAX::MakeEdge2d(v_p[i - 1], v_p[i]);\n        edges_polygon.push_back(e);\n    }\n    e = AMCAX::MakeEdge2d(v_p[3], v_p[0]);\n    edges_polygon.push_back(e);\n    AMCAX::MakeWire mkw;\n    mkw.Add(edges_polygon);\n    AMCAX::TopoWire w_poly = mkw;\n    AMCAX::TopoFace f_poly = AMCAX::MakeFace(w_poly, true);\n    return f_poly;\n}\n#include <catch.hpp>\n#include \"testHelper.h\"\n#include<iostream>\n#include <common/PointT.hpp>\n#include <topology/TopoEdge.hpp>\n#include <modeling/MakeWire.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <topology/TopoWire.hpp>\n#include <topology/TopoShape.hpp>\n#include <topology/TopoFace.hpp>\n#include <modeling/MakeFace.hpp>\nAMCAX::TopoFace crashbug1() {\n    double h1 = 7., h2 = 3.;\n    AMCAX::Point2 p1(0., h1 / 2.0), p2(30., h2 / 2.0), p3(30., -h2 / 2.0), p4(0., -h1 / 2.0);\n    std::vector<AMCAX::Point2> v_p;\n    v_p.push_back(p1);\n    v_p.push_back(p2);\n    v_p.push_back(p3);\n    v_p.push_back(p4);\n    AMCAX::TopoEdge e;\n    std::list<AMCAX::TopoShape> edges_polygon;\n    for (int i = 1; i < v_p.size(); i++) {\n        e = AMCAX::MakeEdge2d(v_p[i - 1], v_p[i]);\n        edges_polygon.push_back(e);\n    }\n    e = AMCAX::MakeEdge2d(v_p[3], v_p[0]);\n    edges_polygon.push_back(e);\n    AMCAX::MakeWire mkw;\n    mkw.Add(edges_polygon);\n    AMCAX::TopoWire w_poly = mkw;\n    AMCAX::TopoFace f_poly = AMCAX::MakeFace(w_poly, true);\n    return f_poly;\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API explicit MakeFace(const TopoWire& w, bool onlyPlane = false)\t @param onlyPlane If true, the surface will be a plane\n\t @param w The wire\n\t @brief Construct from a wire\n,\n",
      "output": "#include <catch.hpp>\n#include \"testHelper.h\"\n#include<iostream>\n#include <common/PointT.hpp>\n#include <topology/TopoEdge.hpp>\n#include <modeling/MakeWire.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <topology/TopoWire.hpp>\n#include <topology/TopoShape.hpp>\n#include <topology/TopoFace.hpp>\n#include <modeling/MakeFace.hpp>\nAMCAX::TopoFace crashbug1() {\n    double h1 = 7., h2 = 3.;\n    AMCAX::Point2 p1(0., h1 / 2.0), p2(30., h2 / 2.0), p3(30., -h2 / 2.0), p4(0., -h1 / 2.0);\n    std::vector<AMCAX::Point2> v_p;\n    v_p.push_back(p1);\n    v_p.push_back(p2);\n    v_p.push_back(p3);\n    v_p.push_back(p4);\n    AMCAX::TopoEdge e;\n    std::list<AMCAX::TopoShape> edges_polygon;\n    for (int i = 1; i < v_p.size(); i++) {\n        e = AMCAX::MakeEdge2d(v_p[i - 1], v_p[i]);\n        edges_polygon.push_back(e);\n    }\n    e = AMCAX::MakeEdge2d(v_p[3], v_p[0]);\n    edges_polygon.push_back(e);\n    AMCAX::MakeWire mkw;\n    mkw.Add(edges_polygon);\n    AMCAX::TopoWire w_poly = mkw;\n    AMCAX::TopoFace f_poly = AMCAX::MakeFace(w_poly, true);\n    return f_poly;\n}\n#include <catch.hpp>\n#include \"testHelper.h\"\n#include<iostream>\n#include <common/PointT.hpp>\n#include <topology/TopoEdge.hpp>\n#include <modeling/MakeWire.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <topology/TopoWire.hpp>\n#include <topology/TopoShape.hpp>\n#include <topology/TopoFace.hpp>\n#include <modeling/MakeFace.hpp>\nAMCAX::TopoFace crashbug1() {\n    double h1 = 7., h2 = 3.;\n    AMCAX::Point2 p1(0., h1 / 2.0), p2(30., h2 / 2.0), p3(30., -h2 / 2.0), p4(0., -h1 / 2.0);\n    std::vector<AMCAX::Point2> v_p;\n    v_p.push_back(p1);\n    v_p.push_back(p2);\n    v_p.push_back(p3);\n    v_p.push_back(p4);\n    AMCAX::TopoEdge e;\n    std::list<AMCAX::TopoShape> edges_polygon;\n    for (int i = 1; i < v_p.size(); i++) {\n        e = AMCAX::MakeEdge2d(v_p[i - 1], v_p[i]);\n        edges_polygon.push_back(e);\n    }\n    e = AMCAX::MakeEdge2d(v_p[3], v_p[0]);\n    edges_polygon.push_back(e);\n    AMCAX::MakeWire mkw;\n    mkw.Add(edges_polygon);\n    AMCAX::TopoWire w_poly = mkw;\n    AMCAX::TopoFace f_poly = AMCAX::MakeFace(w_poly, true);\n    return f_poly;\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API MakeFace(const std::shared_ptr<Geom3Surface>& s, double tolDegen)\t @param tolDegen The tolerance\n\t @param s The surface\n\t @brief Construct from a surface with tolerance for degenerated edges\n,\n",
      "output": "#include <catch.hpp>\n#include \"testHelper.h\"\n#include<iostream>\n#include <common/PointT.hpp>\n#include <topology/TopoEdge.hpp>\n#include <modeling/MakeWire.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <topology/TopoWire.hpp>\n#include <topology/TopoShape.hpp>\n#include <topology/TopoFace.hpp>\n#include <modeling/MakeFace.hpp>\nAMCAX::TopoFace crashbug1() {\n    double h1 = 7., h2 = 3.;\n    AMCAX::Point2 p1(0., h1 / 2.0), p2(30., h2 / 2.0), p3(30., -h2 / 2.0), p4(0., -h1 / 2.0);\n    std::vector<AMCAX::Point2> v_p;\n    v_p.push_back(p1);\n    v_p.push_back(p2);\n    v_p.push_back(p3);\n    v_p.push_back(p4);\n    AMCAX::TopoEdge e;\n    std::list<AMCAX::TopoShape> edges_polygon;\n    for (int i = 1; i < v_p.size(); i++) {\n        e = AMCAX::MakeEdge2d(v_p[i - 1], v_p[i]);\n        edges_polygon.push_back(e);\n    }\n    e = AMCAX::MakeEdge2d(v_p[3], v_p[0]);\n    edges_polygon.push_back(e);\n    AMCAX::MakeWire mkw;\n    mkw.Add(edges_polygon);\n    AMCAX::TopoWire w_poly = mkw;\n    AMCAX::TopoFace f_poly = AMCAX::MakeFace(w_poly, true);\n    return f_poly;\n}\n#include <catch.hpp>\n#include \"testHelper.h\"\n#include<iostream>\n#include <common/PointT.hpp>\n#include <topology/TopoEdge.hpp>\n#include <modeling/MakeWire.hpp>\n#include <modeling/MakeEdge2d.hpp>\n#include <topology/TopoWire.hpp>\n#include <topology/TopoShape.hpp>\n#include <topology/TopoFace.hpp>\n#include <modeling/MakeFace.hpp>\nAMCAX::TopoFace crashbug1() {\n    double h1 = 7., h2 = 3.;\n    AMCAX::Point2 p1(0., h1 / 2.0), p2(30., h2 / 2.0), p3(30., -h2 / 2.0), p4(0., -h1 / 2.0);\n    std::vector<AMCAX::Point2> v_p;\n    v_p.push_back(p1);\n    v_p.push_back(p2);\n    v_p.push_back(p3);\n    v_p.push_back(p4);\n    AMCAX::TopoEdge e;\n    std::list<AMCAX::TopoShape> edges_polygon;\n    for (int i = 1; i < v_p.size(); i++) {\n        e = AMCAX::MakeEdge2d(v_p[i - 1], v_p[i]);\n        edges_polygon.push_back(e);\n    }\n    e = AMCAX::MakeEdge2d(v_p[3], v_p[0]);\n    edges_polygon.push_back(e);\n    AMCAX::MakeWire mkw;\n    mkw.Add(edges_polygon);\n    AMCAX::TopoWire w_poly = mkw;\n    AMCAX::TopoFace f_poly = AMCAX::MakeFace(w_poly, true);\n    return f_poly;\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar> [[nodiscard]] PointT Translated(const VectorT<OtherScalar, DIM>& vec),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.1\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Point3\", \"[Common][Point3]\") {\n\tSECTION(\"Translate(vec)\") {\n        PointT<double, 3> p1(1.0, 2.0, 3.0);\n        VectorT<double, 3> v1(2.0, 3.0, 4.0);\n        PointT<double, 3> p2(3.0, 5.0, 7.0);\n        CHECK(p1.Translated(v1).IsEqual(p2, tol));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, typename OtherScalar2, int DIM2 = DIM, typename = typename std::enable_if_t<DIM2 == 3>> [[nodiscard]] PointT Rotated(const AxisT<OtherScalar, DIM>& axis, const OtherScalar2& angle),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.1\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Point3\", \"[Common][Point3]\") {\n\tSECTION(\"Rotate 3D\") {\n        PointT<double, 3> p1(1.0, 2.0, 3.0);\n        PointT<double, 3> p2(2.0, 3.0, 4.0);\n        DirectionT<double, 3> d(1.0, 1.0, 2.0);\n        AxisT<double, 3> a(p2, d);\n        PointT<double, 3> p3((8.0 + std::sqrt(6.0)) / 6.0, (14.0 - std::sqrt(6.0)) / 6.0, 8.0 / 3.0);\n        CHECK(p1.Rotated(a, M_PI_2).IsEqual(p3, tol));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, typename OtherScalar2, int DIM2 = DIM, typename = typename std::enable_if_t<DIM2 == 3>> PointT& Rotate(const AxisT<OtherScalar, DIM>& axis, const OtherScalar2& angle),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.1\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Point3\", \"[Common][Point3]\") {\n\tSECTION(\"Rotate 3D\") {\n        PointT<double, 3> p1(1.0, 2.0, 3.0);\n        PointT<double, 3> p2(2.0, 3.0, 4.0);\n        DirectionT<double, 3> d(1.0, 1.0, 2.0);\n        AxisT<double, 3> a(p2, d);\n        PointT<double, 3> p3((8.0 + std::sqrt(6.0)) / 6.0, (14.0 - std::sqrt(6.0)) / 6.0, 8.0 / 3.0);\n        CHECK(p1.Rotated(a, M_PI_2).IsEqual(p3, tol));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, int DIM2 = DIM, std::enable_if_t<DIM2 == 3, int> = 0> [[nodiscard]] PointT Mirrored(const FrameT<OtherScalar, DIM>& frame),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.1\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Point3\", \"[Common][Point3]\") {\n\tSECTION(\"Mirror(point) 3D\") {\n        PointT<double, 3> p1(1.0, 2.0, 3.0);\n        PointT<double, 3> p2(2.0, 4.0, 5.0);\n        PointT<double, 3> p3(3.0, 6.0, 7.0);\n        CHECK(p1.Mirrored(p2).IsEqual(p3, tol));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar> [[nodiscard]] PointT Mirrored(const AxisT<OtherScalar, DIM>& axis),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.1\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Point3\", \"[Common][Point3]\") {\n\tSECTION(\"Mirror(axis) 3D\") {\n        PointT<double, 3> p1(1.0, 2.0, 3.0);\n        PointT<double, 3> p2(2.0, 3.0, 4.0);\n        DirectionT<double, 3> d(7.0, 3.0, 2.0);\n        AxisT<double, 3> a(p2, d);\n        PointT<double, 3> p3(9.0 / 31.0, 88.0 / 31.0, 131.0 / 31.0);\n        CHECK(p1.Mirrored(a).IsEqual(p3, tol));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, int DIM2 = DIM, std::enable_if_t<DIM2 == 3, int> = 0> PointT& Mirror(const FrameT<OtherScalar, DIM>& frame),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.1\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Point3\", \"[Common][Point3]\") {\n\tSECTION(\"Mirror(axis) 3D\") {\n        PointT<double, 3> p1(1.0, 2.0, 3.0);\n        PointT<double, 3> p2(2.0, 3.0, 4.0);\n        DirectionT<double, 3> d(7.0, 3.0, 2.0);\n        AxisT<double, 3> a(p2, d);\n        PointT<double, 3> p3(9.0 / 31.0, 88.0 / 31.0, 131.0 / 31.0);\n        CHECK(p1.Mirrored(a).IsEqual(p3, tol));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar> PointT& Mirror(const AxisT<OtherScalar, DIM>& axis),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.1\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Point3\", \"[Common][Point3]\") {\n\tSECTION(\"Mirror(axis) 3D\") {\n        PointT<double, 3> p1(1.0, 2.0, 3.0);\n        PointT<double, 3> p2(2.0, 3.0, 4.0);\n        DirectionT<double, 3> d(7.0, 3.0, 2.0);\n        AxisT<double, 3> a(p2, d);\n        PointT<double, 3> p3(9.0 / 31.0, 88.0 / 31.0, 131.0 / 31.0);\n        CHECK(p1.Mirrored(a).IsEqual(p3, tol));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar> PointT& Mirror(const PointT<OtherScalar, DIM>& p),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.1\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Point3\", \"[Common][Point3]\") {\n\tSECTION(\"Mirror(axis) 3D\") {\n        PointT<double, 3> p1(1.0, 2.0, 3.0);\n        PointT<double, 3> p2(2.0, 3.0, 4.0);\n        DirectionT<double, 3> d(7.0, 3.0, 2.0);\n        AxisT<double, 3> a(p2, d);\n        PointT<double, 3> p3(9.0 / 31.0, 88.0 / 31.0, 131.0 / 31.0);\n        CHECK(p1.Mirrored(a).IsEqual(p3, tol));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar> [[nodiscard]] auto SquaredDistance(const PointT<OtherScalar, DIM>& other),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.1\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Point3\", \"[Common][Point3]\") {\n\tSECTION(\"SquaredDistance\") {\n        PointT<double, 3> p1(1.0, 2.0, 3.0);\n        PointT<double, 3> p2(1.1, 2.2, 3.3);\n        CHECK(p1.SquaredDistance(p2) == Approx(0.14));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar> [[nodiscard]] auto Distance(const PointT<OtherScalar, DIM>& other),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.1\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Point3\", \"[Common][Point3]\") {\n\tSECTION(\"Distance\") {\n        PointT<double, 3> p1(1.0, 2.0, 3.0);\n        PointT<double, 3> p2(1.4, 2.5, 3.6);\n        CHECK(p1.Distance(p2) == sqrt(0.77));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, typename OtherScalar2> [[nodiscard]] bool IsEqual(const PointT<OtherScalar, DIM>& other, const OtherScalar2& tol),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.1\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Point3\", \"[Common][Point3]\") {\n\tSECTION(\"SetZ\") {\n        PointT<double, 3> result;\n        result.SetZ(1);\n        PointT<double, 3> expected(0.0, 0.0, 1.0);\n        CHECK(result.IsEqual(expected, tol));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, typename OtherScalar2, int DIM2 = DIM, typename = typename std::enable_if_t<DIM2 == 2>> [[nodiscard]] PointT Rotated(const PointT<OtherScalar, DIM>& point, const OtherScalar2& angle),\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <iostream>\n#define tol 0.001\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Point2\", \"[Common][Point2]\") {\n\tSECTION(\"Rotate 2D\") {\n        PointT<double, 2> p1(1.0, 2.0);\n        PointT<double, 2> p2(2.0, 3.0);\n        PointT<double, 2> p3(3.0, 2.0);\n        CHECK(p1.Rotated(p2, M_PI_2).IsEqual(p3, tol));\n    }\n}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar> [[nodiscard]] PointT Mirrored(const AxisT<OtherScalar, DIM>& axis),\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <iostream>\n#define tol 0.001\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Point2\", \"[Common][Point2]\") {\n\tSECTION(\"Mirror(axis) 2D\") {\n        PointT<double, 2> p1(1.0, 2.0);\n        PointT<double, 2> p2(2.0, 3.0);\n        DirectionT<double, 2> d(7.0, 3.0);\n        AxisT<double, 2> a(p2, d);\n        PointT<double, 2> p3(17.0 / 29.0, 86.0 / 29.0);\n        CHECK(p1.Mirrored(a).IsEqual(p3, tol));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar> [[nodiscard]] PointT Mirrored(const PointT<OtherScalar, DIM>& p),\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <iostream>\n#define tol 0.001\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Point2\", \"[Common][Point2]\") {\n\tSECTION(\"Mirror(point) 2D\") {\n        PointT<double, 2> p1(1.0, 2.0);\n        PointT<double, 2> p2(2.0, 4.0);\n        PointT<double, 2> p3(3.0, 6.0);\n        CHECK(p1.Mirrored(p2).IsEqual(p3, tol));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar> PointT& Mirror(const AxisT<OtherScalar, DIM>& axis),\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <iostream>\n#define tol 0.001\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Point2\", \"[Common][Point2]\") {\n\tSECTION(\"Mirror(axis) 2D\") {\n        PointT<double, 2> p1(1.0, 2.0);\n        PointT<double, 2> p2(2.0, 3.0);\n        DirectionT<double, 2> d(7.0, 3.0);\n        AxisT<double, 2> a(p2, d);\n        PointT<double, 2> p3(17.0 / 29.0, 86.0 / 29.0);\n        CHECK(p1.Mirrored(a).IsEqual(p3, tol));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar> PointT& Mirror(const PointT<OtherScalar, DIM>& p),\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <iostream>\n#define tol 0.001\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Point2\", \"[Common][Point2]\") {\n\tSECTION(\"Mirror(axis) 2D\") {\n        PointT<double, 2> p1(1.0, 2.0);\n        PointT<double, 2> p2(2.0, 3.0);\n        DirectionT<double, 2> d(7.0, 3.0);\n        AxisT<double, 2> a(p2, d);\n        PointT<double, 2> p3(17.0 / 29.0, 86.0 / 29.0);\n        CHECK(p1.Mirrored(a).IsEqual(p3, tol));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar> void Transform(CoordT<OtherScalar, DIM>& coord),\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T>\nbool IsEqual(const T& result, const T& expected)\n{\n\treturn result == expected;\n}\nbool IsEqual(const double& result, const double& expected)\n{\n\treturn std::fabs(result - expected) <= 1e-6;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)\n{\n\tfor (int i = 0; i < DIM; i++)\n\t{\n\t\tif (!IsEqual(result[i], expected[i]))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int ROW, int COL>\nbool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)\n{\n\tfor (int i = 0; i < ROW; i++)\n\t{\n\t\tfor (int j = 0; j < COL; j++)\n\t\t{\n\t\t\tif (!IsEqual(result(i, j), expected(i, j)))\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)\n{\n\treturn IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());\n}\nTEST_CASE(\"case1:this is a case for Transformation3\",\"[Common][Transformation3]\")\n{\n\tSECTION(\"SetMirror point 3D\") {\n\t\tTransformationT<double, 3> tr;\n\t\tPointT<double, 3> p(1.0, 2.0, 3.0);\n\t\ttr.SetMirror(p);\n\t\tCoordT<double, 3> p2(0.0, 1.0, 2.0);\n\t\ttr.Transform(p2);\n\t\tCoordT<double, 3> p3(2.0, 3.0, 4.0);\n\t\tCHECK(IsEqual(p2, p3));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] TransformationT Powered(int power)\t @return The power of transformation\n\t @param power The exponential\n\t @brief Get the power of transformation\n,\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T>\nbool IsEqual(const T& result, const T& expected)\n{\n\treturn result == expected;\n}\nbool IsEqual(const double& result, const double& expected)\n{\n\treturn std::fabs(result - expected) <= 1e-6;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)\n{\n\tfor (int i = 0; i < DIM; i++)\n\t{\n\t\tif (!IsEqual(result[i], expected[i]))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int ROW, int COL>\nbool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)\n{\n\tfor (int i = 0; i < ROW; i++)\n\t{\n\t\tfor (int j = 0; j < COL; j++)\n\t\t{\n\t\t\tif (!IsEqual(result(i, j), expected(i, j)))\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)\n{\n\treturn IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());\n}\nTEST_CASE(\"case1:this is a case for Transformation3\",\"[Common][Transformation3]\")\n{\n\tSECTION(\"Power\") {\n\t\tTransformationT<double, 3> tr;\n\t\ttr.SetRotation(Axis3(Point3(1.0, 2.0, 3.0), Direction3(1.0, 1.0, 1.0)), M_PI_2);\n\t\tTransformationT<double, 3> tr2;\n\t\ttr2.SetRotation(Axis3(Point3(1.0, 2.0, 3.0), Direction3(1.0, 1.0, 1.0)), M_PI);\n\t\tCHECK(IsEqual(tr.Powered(2), tr2));\n\t}\n}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar> [[nodiscard]] TransformationT LeftMultiplied(const TransformationT<OtherScalar, DIM>& other),\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T>\nbool IsEqual(const T& result, const T& expected)\n{\n\treturn result == expected;\n}\nbool IsEqual(const double& result, const double& expected)\n{\n\treturn std::fabs(result - expected) <= 1e-6;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)\n{\n\tfor (int i = 0; i < DIM; i++)\n\t{\n\t\tif (!IsEqual(result[i], expected[i]))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int ROW, int COL>\nbool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)\n{\n\tfor (int i = 0; i < ROW; i++)\n\t{\n\t\tfor (int j = 0; j < COL; j++)\n\t\t{\n\t\t\tif (!IsEqual(result(i, j), expected(i, j)))\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)\n{\n\treturn IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());\n}\nTEST_CASE(\"case1:this is a case for Transformation3\",\"[Common][Transformation3]\")\n{\n\tSECTION(\"LeftMultiply\") {\n\t\tTransformationT<double, 3> tr;\n\t\ttr.SetRotation(Axis3(Point3(1.0, 2.0, 3.0), Direction3(1.0, 1.0, 1.0)), M_PI_2);\n\t\tTransformationT<double, 3> tr2;\n\t\ttr2.SetRotation(Axis3(Point3(2.0, 3.0, 4.0), Direction3(1.0, 1.0, 2.0)), M_PI_2);\n\t\tCHECK(IsEqual(tr * tr2, tr2.LeftMultiplied(tr)));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar> TransformationT& LeftMultiply(const TransformationT<OtherScalar, DIM>& other),\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T>\nbool IsEqual(const T& result, const T& expected)\n{\n\treturn result == expected;\n}\nbool IsEqual(const double& result, const double& expected)\n{\n\treturn std::fabs(result - expected) <= 1e-6;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)\n{\n\tfor (int i = 0; i < DIM; i++)\n\t{\n\t\tif (!IsEqual(result[i], expected[i]))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int ROW, int COL>\nbool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)\n{\n\tfor (int i = 0; i < ROW; i++)\n\t{\n\t\tfor (int j = 0; j < COL; j++)\n\t\t{\n\t\t\tif (!IsEqual(result(i, j), expected(i, j)))\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)\n{\n\treturn IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());\n}\nTEST_CASE(\"case1:this is a case for Transformation3\",\"[Common][Transformation3]\")\n{\n\tSECTION(\"LeftMultiply\") {\n\t\tTransformationT<double, 3> tr;\n\t\ttr.SetRotation(Axis3(Point3(1.0, 2.0, 3.0), Direction3(1.0, 1.0, 1.0)), M_PI_2);\n\t\tTransformationT<double, 3> tr2;\n\t\ttr2.SetRotation(Axis3(Point3(2.0, 3.0, 4.0), Direction3(1.0, 1.0, 2.0)), M_PI_2);\n\t\tCHECK(IsEqual(tr * tr2, tr2.LeftMultiplied(tr)));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "TransformationT& Invert()\t @return The reference to self\n\t @brief Invert the transformation\n,\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T>\nbool IsEqual(const T& result, const T& expected)\n{\n\treturn result == expected;\n}\nbool IsEqual(const double& result, const double& expected)\n{\n\treturn std::fabs(result - expected) <= 1e-6;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)\n{\n\tfor (int i = 0; i < DIM; i++)\n\t{\n\t\tif (!IsEqual(result[i], expected[i]))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int ROW, int COL>\nbool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)\n{\n\tfor (int i = 0; i < ROW; i++)\n\t{\n\t\tfor (int j = 0; j < COL; j++)\n\t\t{\n\t\t\tif (!IsEqual(result(i, j), expected(i, j)))\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)\n{\n\treturn IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());\n}\nTEST_CASE(\"case1:this is a case for Transformation3\",\"[Common][Transformation3]\")\n{\n\tSECTION(\"Invert\") {\n\t\tTransformationT<double, 3> tr;\n\t\ttr.SetRotation(Axis3(Point3(1.0, 2.0, 3.0), Direction3(1.0, 1.0, 1.0)), M_PI_2);\n\t\ttr.Invert();\n\t\tTransformationT<double, 3> tr2;\n\t\ttr2.SetRotation(Axis3(Point3(1.0, 2.0, 3.0), Direction3(1.0, 1.0, 1.0)), -M_PI_2);\n\t\tCHECK(IsEqual(tr, tr2));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] const MatrixT<Scalar, DIM, DIM>& HVectorialPart()\t @return The homogeneous matrix\n\t @brief Get the homogeneous vectorial part of the transformation, i.e. the rotation matrix\n,\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T>\nbool IsEqual(const T& result, const T& expected)\n{\n\treturn result == expected;\n}\nbool IsEqual(const double& result, const double& expected)\n{\n\treturn std::fabs(result - expected) <= 1e-6;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)\n{\n\tfor (int i = 0; i < DIM; i++)\n\t{\n\t\tif (!IsEqual(result[i], expected[i]))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int ROW, int COL>\nbool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)\n{\n\tfor (int i = 0; i < ROW; i++)\n\t{\n\t\tfor (int j = 0; j < COL; j++)\n\t\t{\n\t\t\tif (!IsEqual(result(i, j), expected(i, j)))\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)\n{\n\treturn IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());\n}\nTEST_CASE(\"case1:this is a case for Transformation3\",\"[Common][Transformation3]\")\n{\n\tSECTION(\"default constructor 3D\") {\n\t\tTransformationT<double, 3> tr;\n\t\tMatrixT<double, 3, 3> mat;\n\t\tmat.SetIdentity();\n\t\tCoordT<double, 3> c;\n\t\tdouble scale = 1.0;\n\t\tCHECK(IsEqual(tr.ScaleFactor(), scale));\n\t\tCHECK(IsEqual(tr.Type(), TransformationType::Identity));\n\t\tCHECK(IsEqual(tr.HVectorialPart(), mat));\n\t\tCHECK(IsEqual(tr.TranslationPart(), c));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, typename OtherScalar2, int DIM2 = DIM, typename = typename std::enable_if_t<DIM2 == 3>> void GetRotation(CoordT<OtherScalar, DIM>& axis, OtherScalar2& angle),\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T>\nbool IsEqual(const T& result, const T& expected)\n{\n\treturn result == expected;\n}\nbool IsEqual(const double& result, const double& expected)\n{\n\treturn std::fabs(result - expected) <= 1e-6;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)\n{\n\tfor (int i = 0; i < DIM; i++)\n\t{\n\t\tif (!IsEqual(result[i], expected[i]))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int ROW, int COL>\nbool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)\n{\n\tfor (int i = 0; i < ROW; i++)\n\t{\n\t\tfor (int j = 0; j < COL; j++)\n\t\t{\n\t\t\tif (!IsEqual(result(i, j), expected(i, j)))\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)\n{\n\treturn IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());\n}\nTEST_CASE(\"case1:this is a case for Transformation3\",\"[Common][Transformation3]\")\n{\n\tSECTION(\"GetRotation\") {\n\t\tTransformationT<double, 3> tr;\n\t\ttr.SetRotation(Axis3(Point3(1.0, 2.0, 3.0), Direction3(1.0, 1.0, 1.0)), M_PI_2);\n\t\tCoordT<double, 3> axis;\n\t\tdouble angle;\n\t\ttr.GetRotation(axis, angle);\n\t\tCoordT<double, 3> axis2(1.0 / std::sqrt(3.0));\n\t\tdouble angle2 = M_PI_2;\n\t\tCHECK(IsEqual(axis, axis2));\n\t\tCHECK(IsEqual(angle, angle2));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] Scalar ScaleFactor()\t @return The scale factor\n\t @brief Get the scale factor of the transformation\n,\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T>\nbool IsEqual(const T& result, const T& expected)\n{\n\treturn result == expected;\n}\nbool IsEqual(const double& result, const double& expected)\n{\n\treturn std::fabs(result - expected) <= 1e-6;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)\n{\n\tfor (int i = 0; i < DIM; i++)\n\t{\n\t\tif (!IsEqual(result[i], expected[i]))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int ROW, int COL>\nbool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)\n{\n\tfor (int i = 0; i < ROW; i++)\n\t{\n\t\tfor (int j = 0; j < COL; j++)\n\t\t{\n\t\t\tif (!IsEqual(result(i, j), expected(i, j)))\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)\n{\n\treturn IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());\n}\nTEST_CASE(\"case1:this is a case for Transformation3\",\"[Common][Transformation3]\")\n{\n\tSECTION(\"default constructor 3D\") {\n\t\tTransformationT<double, 3> tr;\n\t\tMatrixT<double, 3, 3> mat;\n\t\tmat.SetIdentity();\n\t\tCoordT<double, 3> c;\n\t\tdouble scale = 1.0;\n\t\tCHECK(IsEqual(tr.ScaleFactor(), scale));\n\t\tCHECK(IsEqual(tr.Type(), TransformationType::Identity));\n\t\tCHECK(IsEqual(tr.HVectorialPart(), mat));\n\t\tCHECK(IsEqual(tr.TranslationPart(), c));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "void SetType(const TransformationType& t)\t @param t The new type of transformation\n\t @brief Set the type of transformation\n,\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T>\nbool IsEqual(const T& result, const T& expected)\n{\n\treturn result == expected;\n}\nbool IsEqual(const double& result, const double& expected)\n{\n\treturn std::fabs(result - expected) <= 1e-6;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)\n{\n\tfor (int i = 0; i < DIM; i++)\n\t{\n\t\tif (!IsEqual(result[i], expected[i]))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int ROW, int COL>\nbool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)\n{\n\tfor (int i = 0; i < ROW; i++)\n\t{\n\t\tfor (int j = 0; j < COL; j++)\n\t\t{\n\t\t\tif (!IsEqual(result(i, j), expected(i, j)))\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)\n{\n\treturn IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());\n}\nTEST_CASE(\"case1:this is a case for Transformation3\",\"[Common][Transformation3]\")\n{\n\tSECTION(\"SetValues 3D\") {\n\t\tTransformationT<double, 3> tr;\n\t\tdouble a = 1.0 / 3.0;\n\t\tdouble b = 1.0 / 3.0 - 1.0 / std::sqrt(3.0);\n\t\tdouble c = 1.0 / 3.0 + 1.0 / std::sqrt(3.0);\n\t\ttr.SetValues(a, b, c, -1.0 - 1.0 / std::sqrt(3.0), c, a, b, 2.0 / std::sqrt(3.0), b, c, a, 1.0 - 1.0 / std::sqrt(3.0));\n\t\ttr.SetType(TransformationType::Rotation);\n\t\tTransformationT<double, 3> tr2;\n\t\ttr2.SetRotation(Axis3(Point3(1.0, 2.0, 3.0), Direction3(1.0, 1.0, 1.0)), M_PI_2);\n\t\tCHECK(IsEqual(tr, tr2));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar> void SetTranslationPart(const VectorT<OtherScalar, DIM>& vec),\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T>\nbool IsEqual(const T& result, const T& expected)\n{\n\treturn result == expected;\n}\nbool IsEqual(const double& result, const double& expected)\n{\n\treturn std::fabs(result - expected) <= 1e-6;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)\n{\n\tfor (int i = 0; i < DIM; i++)\n\t{\n\t\tif (!IsEqual(result[i], expected[i]))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int ROW, int COL>\nbool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)\n{\n\tfor (int i = 0; i < ROW; i++)\n\t{\n\t\tfor (int j = 0; j < COL; j++)\n\t\t{\n\t\t\tif (!IsEqual(result(i, j), expected(i, j)))\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)\n{\n\treturn IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());\n}\nTEST_CASE(\"case1:this is a case for Transformation3\",\"[Common][Transformation3]\")\n{\n\tSECTION(\"SetTranslationPart 2D\") {\n\t\tTransformationT<double, 2> tr;\n\t\ttr.SetRotation(PointT<double, 2>(2.0, 3.0), M_PI_2);\n\t\ttr.SetTranslationPart(VectorT<double, 2>(1.0, 2.0));\n\t\tCoordT<double, 2> p(1.0, 2.0);\n\t\ttr.Transform(p);\n\t\tCoordT<double, 2> p2(-1.0, 3.0);\n\t\tCHECK(IsEqual(p, p2));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, typename OtherScalar2> void SetTranslation(const PointT<OtherScalar, DIM>& p1, const PointT<OtherScalar2, DIM>& p2),\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T>\nbool IsEqual(const T& result, const T& expected)\n{\n\treturn result == expected;\n}\nbool IsEqual(const double& result, const double& expected)\n{\n\treturn std::fabs(result - expected) <= 1e-6;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)\n{\n\tfor (int i = 0; i < DIM; i++)\n\t{\n\t\tif (!IsEqual(result[i], expected[i]))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int ROW, int COL>\nbool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)\n{\n\tfor (int i = 0; i < ROW; i++)\n\t{\n\t\tfor (int j = 0; j < COL; j++)\n\t\t{\n\t\t\tif (!IsEqual(result(i, j), expected(i, j)))\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)\n{\n\treturn IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());\n}\nTEST_CASE(\"case1:this is a case for Transformation3\",\"[Common][Transformation3]\")\n{\n\tSECTION(\"SetTranslation point 2D\") {\n\t\tTransformationT<double, 2> tr;\n\t\ttr.SetTranslation(PointT<double, 2>(1.0, 2.0), PointT<double, 2>(3.0, 4.0));\n\t\tCoordT<double, 2> p(3.0, -1.0);\n\t\ttr.Transform(p);\n\t\tCoordT<double, 2> p2(5.0, 1.0);\n\t\tCHECK(IsEqual(p, p2));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar> void SetTranslation(const VectorT<OtherScalar, DIM>& vec),\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T>\nbool IsEqual(const T& result, const T& expected)\n{\n\treturn result == expected;\n}\nbool IsEqual(const double& result, const double& expected)\n{\n\treturn std::fabs(result - expected) <= 1e-6;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)\n{\n\tfor (int i = 0; i < DIM; i++)\n\t{\n\t\tif (!IsEqual(result[i], expected[i]))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int ROW, int COL>\nbool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)\n{\n\tfor (int i = 0; i < ROW; i++)\n\t{\n\t\tfor (int j = 0; j < COL; j++)\n\t\t{\n\t\t\tif (!IsEqual(result(i, j), expected(i, j)))\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)\n{\n\treturn IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());\n}\nTEST_CASE(\"case1:this is a case for Transformation3\",\"[Common][Transformation3]\")\n{\n\tSECTION(\"SetRotationPart quaternion\") {\n\t\tTransformationT<double, 3> tr;\n\t\ttr.SetTranslation(VectorT<double, 3>(2.0 / 3.0, 2.0 / 3.0, 4.0 / 3.0));\n\t\tQuaternionT<double> q(std::sqrt(3.0) / 6.0, std::sqrt(3.0) / 6.0, std::sqrt(3.0) / 3.0, std::sqrt(2.0) / 2.0);\n\t\ttr.SetRotationPart(q);\n\t\tCoordT<double, 3> p(-1.0, -1.0, -1.0);\n\t\ttr.Transform(p);\n\t\tCoordT<double, 3> p2(std::sqrt(6.0) / 6.0, -std::sqrt(6.0) / 6.0, 0.0);\n\t\tCHECK(IsEqual(p, p2));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, int DIM2 = DIM, typename = typename std::enable_if_t<DIM2 == 3>> void SetTransformation(const FrameT<OtherScalar, DIM>& frameTo),\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T>\nbool IsEqual(const T& result, const T& expected)\n{\n\treturn result == expected;\n}\nbool IsEqual(const double& result, const double& expected)\n{\n\treturn std::fabs(result - expected) <= 1e-6;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)\n{\n\tfor (int i = 0; i < DIM; i++)\n\t{\n\t\tif (!IsEqual(result[i], expected[i]))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int ROW, int COL>\nbool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)\n{\n\tfor (int i = 0; i < ROW; i++)\n\t{\n\t\tfor (int j = 0; j < COL; j++)\n\t\t{\n\t\t\tif (!IsEqual(result(i, j), expected(i, j)))\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)\n{\n\treturn IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());\n}\nTEST_CASE(\"case1:this is a case for Transformation3\",\"[Common][Transformation3]\")\n{\n\tSECTION(\"SetTransformation 3D\") {\n\t\tFrameT<double, 3> f1(PointT<double, 3>(1.0, 2.0, 3.0), DirectionT<double, 3>(4.0, 5.0, 6.0), DirectionT<double, 3>(-3.0, -5.0, 1.0));\n\t\tTransformationT<double, 3> tr;\n\t\ttr.SetTransformation(f1);\n\t\tCoordT<double, 3> p(4.0, 1.0, 3.0);\n\t\ttr.Transform(p);\n\t\tCoordT<double, 3> p2(-91.0 / (17.0 * std::sqrt(462.0)), 127.0 / (17.0 * std::sqrt(6.0)), 7.0 / std::sqrt(77.0));\n\t\tCHECK(IsEqual(p, p2));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, typename OtherScalar2, int DIM2 = DIM, typename = typename std::enable_if_t<DIM2 == 3>> void SetTransformation(const FrameT<OtherScalar, DIM>& frameFrom, const FrameT<OtherScalar2, DIM>& frameTo),\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T>\nbool IsEqual(const T& result, const T& expected)\n{\n\treturn result == expected;\n}\nbool IsEqual(const double& result, const double& expected)\n{\n\treturn std::fabs(result - expected) <= 1e-6;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)\n{\n\tfor (int i = 0; i < DIM; i++)\n\t{\n\t\tif (!IsEqual(result[i], expected[i]))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int ROW, int COL>\nbool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)\n{\n\tfor (int i = 0; i < ROW; i++)\n\t{\n\t\tfor (int j = 0; j < COL; j++)\n\t\t{\n\t\t\tif (!IsEqual(result(i, j), expected(i, j)))\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)\n{\n\treturn IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());\n}\nTEST_CASE(\"case1:this is a case for Transformation3\",\"[Common][Transformation3]\")\n{\n\tSECTION(\"SetTransformation 3D\") {\t\n\t\tFrameT<double, 3> f1(PointT<double, 3>(1.0, 2.0, 3.0), DirectionT<double, 3>(4.0, 5.0, 6.0), DirectionT<double, 3>(-3.0, -5.0, 1.0));\n\t\tFrameT<double, 3> f2(PointT<double, 3>(3.0, 1.0, -1.0), DirectionT<double, 3>(1.0, 5.0, -3.0), DirectionT<double, 3>(2.0, -2.0, 2.0));\n\t\tTransformationT<double, 3> tr;\n\t\ttr.SetTransformation(f1, f2);\n\t\tCoordT<double, 3> p(4.0, 1.0, 3.0);\n\t\ttr.Transform(p);\n\t\tCoordT<double, 3> p2(54.0 / std::sqrt(770.0) - 232.0 / (34.0 * std::sqrt(1155.0)) + 100.0 / (34.0 * std::sqrt(15.0)) - 2.0 / std::sqrt(10.0),\n\t\t\t-72.0 / (7.0 * std::sqrt(22.0)) - 1744.0 / (238.0 * std::sqrt(33.0)) + 94.0 / (34.0 * std::sqrt(21.0)) - 16.0 / std::sqrt(14.0),\n\t\t\t33.0 / (7.0 * std::sqrt(55.0)) - 8184.0 / (119.0 * std::sqrt(330.0)) - 60.0 / (17.0 * std::sqrt(210.0)) - 9.0 / std::sqrt(35.0));\n\t\tCHECK(IsEqual(p, p2));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, typename OtherScalar2, int DIM2 = DIM, typename = typename std::enable_if_t<DIM2 == 3>> void SetDisplacement(const FrameT<OtherScalar, DIM>& frameFrom, const FrameT<OtherScalar2, DIM>& frameTo),\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T>\nbool IsEqual(const T& result, const T& expected)\n{\n\treturn result == expected;\n}\nbool IsEqual(const double& result, const double& expected)\n{\n\treturn std::fabs(result - expected) <= 1e-6;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)\n{\n\tfor (int i = 0; i < DIM; i++)\n\t{\n\t\tif (!IsEqual(result[i], expected[i]))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int ROW, int COL>\nbool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)\n{\n\tfor (int i = 0; i < ROW; i++)\n\t{\n\t\tfor (int j = 0; j < COL; j++)\n\t\t{\n\t\t\tif (!IsEqual(result(i, j), expected(i, j)))\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)\n{\n\treturn IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());\n}\nTEST_CASE(\"case1:this is a case for Transformation3\",\"[Common][Transformation3]\")\n{\n\tSECTION(\"SetDisplacement\") {\n\t\tFrameT<double, 3> f1(PointT<double, 3>(1.0, 2.0, 3.0), DirectionT<double, 3>(4.0, 5.0, 6.0), DirectionT<double, 3>(-3.0, -5.0, 1.0));\n\t\tFrameT<double, 3> f2(PointT<double, 3>(3.0, 1.0, -1.0), DirectionT<double, 3>(1.0, 5.0, -3.0), DirectionT<double, 3>(2.0, -2.0, 2.0));\n\t\tTransformationT<double, 3> tr;\n\t\ttr.SetDisplacement(f1, f2);\n\t\tCoordT<double, 3> p(4.0, 1.0, 3.0);\n\t\ttr.Transform(p);\n\t\tCoordT<double, 3> p2(7.0 / (7.0 * std::sqrt(55.0)) - 273.0 / (34.0 * std::sqrt(1155.0)) + 127.0 / (34.0 * std::sqrt(21.0)) + 3.0,\n\t\t\t35.0 / (7.0 * std::sqrt(55.0)) - 254.0 / (34.0 * std::sqrt(21.0)) + 1.0,\n\t\t\t-21.0 / (7.0 * std::sqrt(55.0)) - 91.0 / (34.0 * std::sqrt(1155.0)) - 381.0 / (34.0 * std::sqrt(21.0)) - 1.0);\n\t\tCHECK(IsEqual(p, p2));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, typename OtherScalar2> void SetScale(const PointT<OtherScalar, DIM>& point, const OtherScalar2& s),\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T>\nbool IsEqual(const T& result, const T& expected)\n{\n\treturn result == expected;\n}\nbool IsEqual(const double& result, const double& expected)\n{\n\treturn std::fabs(result - expected) <= 1e-6;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)\n{\n\tfor (int i = 0; i < DIM; i++)\n\t{\n\t\tif (!IsEqual(result[i], expected[i]))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int ROW, int COL>\nbool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)\n{\n\tfor (int i = 0; i < ROW; i++)\n\t{\n\t\tfor (int j = 0; j < COL; j++)\n\t\t{\n\t\t\tif (!IsEqual(result(i, j), expected(i, j)))\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)\n{\n\treturn IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());\n}\nTEST_CASE(\"case1:this is a case for Transformation3\",\"[Common][Transformation3]\")\n{\n\tSECTION(\"SetScale 3D\") {\n\t\tTransformationT<double, 3> tr;\n\t\ttr.SetScale(PointT<double, 3>(2.0, 3.0, 4.0), 1.5);\n\t\tCoordT<double, 3> p(1.0, 2.0, 3.0);\n\t\ttr.Transform(p);\n\t\tCoordT<double, 3> p2(0.5, 1.5, 2.5);\n\t\tCHECK(IsEqual(p, p2));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, int DIM2 = DIM, typename = typename std::enable_if_t<DIM2 == 3>> void SetRotationPart(const QuaternionT<OtherScalar>& q),\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T>\nbool IsEqual(const T& result, const T& expected)\n{\n\treturn result == expected;\n}\nbool IsEqual(const double& result, const double& expected)\n{\n\treturn std::fabs(result - expected) <= 1e-6;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)\n{\n\tfor (int i = 0; i < DIM; i++)\n\t{\n\t\tif (!IsEqual(result[i], expected[i]))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int ROW, int COL>\nbool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)\n{\n\tfor (int i = 0; i < ROW; i++)\n\t{\n\t\tfor (int j = 0; j < COL; j++)\n\t\t{\n\t\t\tif (!IsEqual(result(i, j), expected(i, j)))\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)\n{\n\treturn IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());\n}\nTEST_CASE(\"case1:this is a case for Transformation3\",\"[Common][Transformation3]\")\n{\n\tSECTION(\"SetRotationPart quaternion\") {\n\t\tTransformationT<double, 3> tr;\n\t\ttr.SetTranslation(VectorT<double, 3>(2.0 / 3.0, 2.0 / 3.0, 4.0 / 3.0));\n\t\tQuaternionT<double> q(std::sqrt(3.0) / 6.0, std::sqrt(3.0) / 6.0, std::sqrt(3.0) / 3.0, std::sqrt(2.0) / 2.0);\n\t\ttr.SetRotationPart(q);\n\t\tCoordT<double, 3> p(-1.0, -1.0, -1.0);\n\t\ttr.Transform(p);\n\t\tCoordT<double, 3> p2(std::sqrt(6.0) / 6.0, -std::sqrt(6.0) / 6.0, 0.0);\n\t\tCHECK(IsEqual(p, p2));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, int DIM2 = DIM, typename = typename std::enable_if_t<DIM2 == 3>> void SetRotation(const QuaternionT<OtherScalar>& q),\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T>\nbool IsEqual(const T& result, const T& expected)\n{\n\treturn result == expected;\n}\nbool IsEqual(const double& result, const double& expected)\n{\n\treturn std::fabs(result - expected) <= 1e-6;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)\n{\n\tfor (int i = 0; i < DIM; i++)\n\t{\n\t\tif (!IsEqual(result[i], expected[i]))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int ROW, int COL>\nbool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)\n{\n\tfor (int i = 0; i < ROW; i++)\n\t{\n\t\tfor (int j = 0; j < COL; j++)\n\t\t{\n\t\t\tif (!IsEqual(result(i, j), expected(i, j)))\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)\n{\n\treturn IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());\n}\nTEST_CASE(\"case1:this is a case for Transformation3\",\"[Common][Transformation3]\")\n{\n\tSECTION(\"SetRotation quaternion\") {\n\t\tTransformationT<double, 3> tr;\n\t\tQuaternionT<double> q(std::sqrt(3.0) / 6.0, std::sqrt(3.0) / 6.0, std::sqrt(3.0) / 3.0, std::sqrt(2.0) / 2.0);\n\t\ttr.SetRotation(q);\n\t\tCoordT<double, 3> p(-1.0, -1.0, -1.0);\n\t\ttr.Transform(p);\n\t\tCoordT<double, 3> p2((-4.0 + std::sqrt(6.0)) / 6.0, (-4.0 - std::sqrt(6.0)) / 6.0, -4.0 / 3.0);\n\t\tCHECK(IsEqual(p, p2));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, typename OtherScalar2, int DIM2 = DIM, typename = typename std::enable_if_t<DIM2 == 3>> void SetRotation(const AxisT<OtherScalar, DIM>& axis, const OtherScalar2& angle),\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T>\nbool IsEqual(const T& result, const T& expected)\n{\n\treturn result == expected;\n}\nbool IsEqual(const double& result, const double& expected)\n{\n\treturn std::fabs(result - expected) <= 1e-6;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)\n{\n\tfor (int i = 0; i < DIM; i++)\n\t{\n\t\tif (!IsEqual(result[i], expected[i]))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int ROW, int COL>\nbool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)\n{\n\tfor (int i = 0; i < ROW; i++)\n\t{\n\t\tfor (int j = 0; j < COL; j++)\n\t\t{\n\t\t\tif (!IsEqual(result(i, j), expected(i, j)))\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)\n{\n\treturn IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());\n}\nTEST_CASE(\"case1:this is a case for Transformation3\",\"[Common][Transformation3]\")\n{\n\tSECTION(\"SetRotation axis\") {\n\t\tTransformationT<double, 3> tr;\n\t\tAxisT<double, 3> a(PointT<double, 3>(2.0, 3.0, 4.0), DirectionT<double, 3>(1.0, 1.0, 2.0));\n\t\ttr.SetRotation(a, M_PI_2);\n\t\tCoordT<double, 3> p(1.0, 2.0, 3.0);\n\t\ttr.Transform(p);\n\t\tCoordT<double, 3> p2((8.0 + std::sqrt(6.0)) / 6.0, (14.0 - std::sqrt(6.0)) / 6.0, 8.0 / 3.0);\n\t\tCHECK(IsEqual(p, p2));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, typename OtherScalar2, int DIM2 = DIM, typename = typename std::enable_if_t<DIM2 == 2>> void SetRotation(const PointT<OtherScalar, DIM>& point, const OtherScalar2& angle),\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T>\nbool IsEqual(const T& result, const T& expected)\n{\n\treturn result == expected;\n}\nbool IsEqual(const double& result, const double& expected)\n{\n\treturn std::fabs(result - expected) <= 1e-6;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)\n{\n\tfor (int i = 0; i < DIM; i++)\n\t{\n\t\tif (!IsEqual(result[i], expected[i]))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int ROW, int COL>\nbool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)\n{\n\tfor (int i = 0; i < ROW; i++)\n\t{\n\t\tfor (int j = 0; j < COL; j++)\n\t\t{\n\t\t\tif (!IsEqual(result(i, j), expected(i, j)))\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)\n{\n\treturn IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());\n}\nTEST_CASE(\"case1:this is a case for Transformation3\",\"[Common][Transformation3]\")\n{\n\tSECTION(\"SetRotation point\") {\n\t\tTransformationT<double, 2> tr;\n\t\ttr.SetRotation(PointT<double, 2>(2.0, 3.0), M_PI_2);\n\t\tCoordT<double, 2> p(1.0, 2.0);\n\t\ttr.Transform(p);\n\t\tCoordT<double, 2> p2(3.0, 2.0);\n\t\tCHECK(IsEqual(p, p2));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, int DIM2 = DIM, std::enable_if_t<DIM2 == 3, int> = 0> void SetMirror(const FrameT<OtherScalar, DIM>& frame),\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T>\nbool IsEqual(const T& result, const T& expected)\n{\n\treturn result == expected;\n}\nbool IsEqual(const double& result, const double& expected)\n{\n\treturn std::fabs(result - expected) <= 1e-6;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)\n{\n\tfor (int i = 0; i < DIM; i++)\n\t{\n\t\tif (!IsEqual(result[i], expected[i]))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int ROW, int COL>\nbool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)\n{\n\tfor (int i = 0; i < ROW; i++)\n\t{\n\t\tfor (int j = 0; j < COL; j++)\n\t\t{\n\t\t\tif (!IsEqual(result(i, j), expected(i, j)))\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)\n{\n\treturn IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());\n}\nTEST_CASE(\"case1:this is a case for Transformation3\",\"[Common][Transformation3]\")\n{\n\tSECTION(\"SetMirror axis 3D\") {\n\t\tTransformationT<double, 3> tr;\n\t\tAxisT<double, 3> axis(PointT<double, 3>(2.0, 3.0, 4.0), DirectionT<double, 3>(7.0, 3.0, 2.0));\n\t\ttr.SetMirror(axis);\n\t\tCoordT<double, 3> p(1.0, 2.0, 3.0);\n\t\ttr.Transform(p);\n\t\tCoordT<double, 3> p2(9.0 / 31.0, 88.0 / 31.0, 131.0 / 31.0);\n\t\tCHECK(IsEqual(p, p2));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar> void SetMirror(const AxisT<OtherScalar, DIM>& axis),\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T>\nbool IsEqual(const T& result, const T& expected)\n{\n\treturn result == expected;\n}\nbool IsEqual(const double& result, const double& expected)\n{\n\treturn std::fabs(result - expected) <= 1e-6;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)\n{\n\tfor (int i = 0; i < DIM; i++)\n\t{\n\t\tif (!IsEqual(result[i], expected[i]))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int ROW, int COL>\nbool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)\n{\n\tfor (int i = 0; i < ROW; i++)\n\t{\n\t\tfor (int j = 0; j < COL; j++)\n\t\t{\n\t\t\tif (!IsEqual(result(i, j), expected(i, j)))\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)\n{\n\treturn IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());\n}\nTEST_CASE(\"case1:this is a case for Transformation3\",\"[Common][Transformation3]\")\n{\n\tSECTION(\"SetMirror axis 3D\") {\n\t\tTransformationT<double, 3> tr;\n\t\tAxisT<double, 3> axis(PointT<double, 3>(2.0, 3.0, 4.0), DirectionT<double, 3>(7.0, 3.0, 2.0));\n\t\ttr.SetMirror(axis);\n\t\tCoordT<double, 3> p(1.0, 2.0, 3.0);\n\t\ttr.Transform(p);\n\t\tCoordT<double, 3> p2(9.0 / 31.0, 88.0 / 31.0, 131.0 / 31.0);\n\t\tCHECK(IsEqual(p, p2));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar> void SetMirror(const PointT<OtherScalar, DIM>& point),\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T>\nbool IsEqual(const T& result, const T& expected)\n{\n\treturn result == expected;\n}\nbool IsEqual(const double& result, const double& expected)\n{\n\treturn std::fabs(result - expected) <= 1e-6;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)\n{\n\tfor (int i = 0; i < DIM; i++)\n\t{\n\t\tif (!IsEqual(result[i], expected[i]))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int ROW, int COL>\nbool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)\n{\n\tfor (int i = 0; i < ROW; i++)\n\t{\n\t\tfor (int j = 0; j < COL; j++)\n\t\t{\n\t\t\tif (!IsEqual(result(i, j), expected(i, j)))\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)\n{\n\treturn IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());\n}\nTEST_CASE(\"case1:this is a case for Transformation3\",\"[Common][Transformation3]\")\n{\n\tSECTION(\"SetMirror point 3D\") {\n\t\tTransformationT<double, 3> tr;\n\t\tPointT<double, 3> p(1.0, 2.0, 3.0);\n\t\ttr.SetMirror(p);\n\t\tCoordT<double, 3> p2(0.0, 1.0, 2.0);\n\t\ttr.Transform(p2);\n\t\tCoordT<double, 3> p3(2.0, 3.0, 4.0);\n\t\tCHECK(IsEqual(p2, p3));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, int OtherDIM> explicit TransformationT(const TransformationT<OtherScalar, OtherDIM>& trans),\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T>\nbool IsEqual(const T& result, const T& expected)\n{\n\treturn result == expected;\n}\nbool IsEqual(const double& result, const double& expected)\n{\n\treturn std::fabs(result - expected) <= 1e-6;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)\n{\n\tfor (int i = 0; i < DIM; i++)\n\t{\n\t\tif (!IsEqual(result[i], expected[i]))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int ROW, int COL>\nbool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)\n{\n\tfor (int i = 0; i < ROW; i++)\n\t{\n\t\tfor (int j = 0; j < COL; j++)\n\t\t{\n\t\t\tif (!IsEqual(result(i, j), expected(i, j)))\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)\n{\n\treturn IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());\n}\nTEST_CASE(\"case1:this is a case for Transformation3\",\"[Common][Transformation3]\")\n{\n\tSECTION(\"default constructor 3D\") {\n\t\tTransformationT<double, 3> tr;\n\t\tMatrixT<double, 3, 3> mat;\n\t\tmat.SetIdentity();\n\t\tCoordT<double, 3> c;\n\t\tdouble scale = 1.0;\n\t\tCHECK(IsEqual(tr.ScaleFactor(), scale));\n\t\tCHECK(IsEqual(tr.Type(), TransformationType::Identity));\n\t\tCHECK(IsEqual(tr.HVectorialPart(), mat));\n\t\tCHECK(IsEqual(tr.TranslationPart(), c));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "constexpr TransformationT()\t @details The default transformation is the identity transformation\n\t @brief Default constructor\n,\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T>\nbool IsEqual(const T& result, const T& expected)\n{\n\treturn result == expected;\n}\nbool IsEqual(const double& result, const double& expected)\n{\n\treturn std::fabs(result - expected) <= 1e-6;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)\n{\n\tfor (int i = 0; i < DIM; i++)\n\t{\n\t\tif (!IsEqual(result[i], expected[i]))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int ROW, int COL>\nbool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)\n{\n\tfor (int i = 0; i < ROW; i++)\n\t{\n\t\tfor (int j = 0; j < COL; j++)\n\t\t{\n\t\t\tif (!IsEqual(result(i, j), expected(i, j)))\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)\n{\n\treturn IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());\n}\nTEST_CASE(\"case1:this is a case for Transformation3\",\"[Common][Transformation3]\")\n{\n\tSECTION(\"default constructor 3D\") {\n\t\tTransformationT<double, 3> tr;\n\t\tMatrixT<double, 3, 3> mat;\n\t\tmat.SetIdentity();\n\t\tCoordT<double, 3> c;\n\t\tdouble scale = 1.0;\n\t\tCHECK(IsEqual(tr.ScaleFactor(), scale));\n\t\tCHECK(IsEqual(tr.Type(), TransformationType::Identity));\n\t\tCHECK(IsEqual(tr.HVectorialPart(), mat));\n\t\tCHECK(IsEqual(tr.TranslationPart(), c));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] const CoordT<Scalar, DIM>& TranslationPart()\t @return The translation part\n\t @brief Get the translation part of the transformation\n,\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T>\nbool IsEqual(const T& result, const T& expected)\n{\n\treturn result == expected;\n}\nbool IsEqual(const double& result, const double& expected)\n{\n\treturn std::fabs(result - expected) <= 1e-6;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)\n{\n\tfor (int i = 0; i < DIM; i++)\n\t{\n\t\tif (!IsEqual(result[i], expected[i]))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int ROW, int COL>\nbool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)\n{\n\tfor (int i = 0; i < ROW; i++)\n\t{\n\t\tfor (int j = 0; j < COL; j++)\n\t\t{\n\t\t\tif (!IsEqual(result(i, j), expected(i, j)))\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)\n{\n\treturn IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());\n}\nTEST_CASE(\"case1:this is a case for Transformation3\",\"[Common][Transformation3]\")\n{\n\tSECTION(\"default constructor 3D\") {\n\t\tTransformationT<double, 3> tr;\n\t\tMatrixT<double, 3, 3> mat;\n\t\tmat.SetIdentity();\n\t\tCoordT<double, 3> c;\n\t\tdouble scale = 1.0;\n\t\tCHECK(IsEqual(tr.ScaleFactor(), scale));\n\t\tCHECK(IsEqual(tr.Type(), TransformationType::Identity));\n\t\tCHECK(IsEqual(tr.HVectorialPart(), mat));\n\t\tCHECK(IsEqual(tr.TranslationPart(), c));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] TransformationType Type()\t @return The transformation type\n\t @brief Get the type of the transformation\n,\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T>\nbool IsEqual(const T& result, const T& expected)\n{\n\treturn result == expected;\n}\nbool IsEqual(const double& result, const double& expected)\n{\n\treturn std::fabs(result - expected) <= 1e-6;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)\n{\n\tfor (int i = 0; i < DIM; i++)\n\t{\n\t\tif (!IsEqual(result[i], expected[i]))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int ROW, int COL>\nbool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)\n{\n\tfor (int i = 0; i < ROW; i++)\n\t{\n\t\tfor (int j = 0; j < COL; j++)\n\t\t{\n\t\t\tif (!IsEqual(result(i, j), expected(i, j)))\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)\n{\n\treturn IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());\n}\nTEST_CASE(\"case1:this is a case for Transformation3\",\"[Common][Transformation3]\")\n{\n\tSECTION(\"default constructor 3D\") {\n\t\tTransformationT<double, 3> tr;\n\t\tMatrixT<double, 3, 3> mat;\n\t\tmat.SetIdentity();\n\t\tCoordT<double, 3> c;\n\t\tdouble scale = 1.0;\n\t\tCHECK(IsEqual(tr.ScaleFactor(), scale));\n\t\tCHECK(IsEqual(tr.Type(), TransformationType::Identity));\n\t\tCHECK(IsEqual(tr.HVectorialPart(), mat));\n\t\tCHECK(IsEqual(tr.TranslationPart(), c));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] Scalar ScaleFactor()\t @return The scale factor\n\t @brief Get the scale factor of the transformation\n,\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T>\nstatic bool IsEqual(const T& result, const T& expected)\n{\n\treturn result == expected;\n}\nstatic bool IsEqual(const double& result, const double& expected)\n{\n\treturn std::fabs(result - expected) <= 1e-15;\n}\ntemplate<typename T, int DIM>\nstatic bool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)\n{\n\tfor (int i = 0; i < DIM; i++)\n\t{\n\t\tif (!IsEqual(result[i], expected[i]))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int ROW, int COL>\nstatic bool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)\n{\n\tfor (int i = 0; i < ROW; i++)\n\t{\n\t\tfor (int j = 0; j < COL; j++)\n\t\t{\n\t\t\tif (!IsEqual(result(i, j), expected(i, j)))\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)\n{\n\treturn IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());\n}\n#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T>\nstatic bool IsEqual(const T& result, const T& expected)\n{\n\treturn result == expected;\n}\nstatic bool IsEqual(const double& result, const double& expected)\n{\n\treturn std::fabs(result - expected) <= 1e-15;\n}\ntemplate<typename T, int DIM>\nstatic bool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)\n{\n\tfor (int i = 0; i < DIM; i++)\n\t{\n\t\tif (!IsEqual(result[i], expected[i]))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int ROW, int COL>\nstatic bool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)\n{\n\tfor (int i = 0; i < ROW; i++)\n\t{\n\t\tfor (int j = 0; j < COL; j++)\n\t\t{\n\t\t\tif (!IsEqual(result(i, j), expected(i, j)))\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)\n{\n\treturn IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, int DIM2 = DIM, typename = typename std::enable_if_t<DIM2 == 2>> void SetTransformation(const AxisT<OtherScalar, DIM>& axisTo),\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T>\nstatic bool IsEqual(const T& result, const T& expected)\n{\n\treturn result == expected;\n}\nstatic bool IsEqual(const double& result, const double& expected)\n{\n\treturn std::fabs(result - expected) <= 1e-15;\n}\ntemplate<typename T, int DIM>\nstatic bool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)\n{\n\tfor (int i = 0; i < DIM; i++)\n\t{\n\t\tif (!IsEqual(result[i], expected[i]))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int ROW, int COL>\nstatic bool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)\n{\n\tfor (int i = 0; i < ROW; i++)\n\t{\n\t\tfor (int j = 0; j < COL; j++)\n\t\t{\n\t\t\tif (!IsEqual(result(i, j), expected(i, j)))\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)\n{\n\treturn IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());\n}\nTEST_CASE(\"case1:this is a case for Transformation2\", \"[Common][Transformation2]\") {\n\tSECTION(\"SetTransformation 2D\") {\n\t\tAxis2 a1(PointT<double, 2>(1.0, 2.0), DirectionT<double, 2>(3.0, 4.0));\n\t\tTransformationT<double, 2> tr;\n\t\ttr.SetTransformation(a1);\n\t\tCoordT<double, 2> p(4.0, 1.0);\n\t\ttr.Transform(p);\n\t\tCoordT<double, 2> p2(1.0, -3.0);\n\t\tCHECK(IsEqual(p, p2));\n\t}\n}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, typename OtherScalar2, int DIM2 = DIM, typename = typename std::enable_if_t<DIM2 == 2>> void SetTransformation(const AxisT<OtherScalar, DIM>& axisFrom, const AxisT<OtherScalar2, DIM>& axisTo),\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T>\nstatic bool IsEqual(const T& result, const T& expected)\n{\n\treturn result == expected;\n}\nstatic bool IsEqual(const double& result, const double& expected)\n{\n\treturn std::fabs(result - expected) <= 1e-15;\n}\ntemplate<typename T, int DIM>\nstatic bool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)\n{\n\tfor (int i = 0; i < DIM; i++)\n\t{\n\t\tif (!IsEqual(result[i], expected[i]))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int ROW, int COL>\nstatic bool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)\n{\n\tfor (int i = 0; i < ROW; i++)\n\t{\n\t\tfor (int j = 0; j < COL; j++)\n\t\t{\n\t\t\tif (!IsEqual(result(i, j), expected(i, j)))\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)\n{\n\treturn IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());\n}\nTEST_CASE(\"case1:this is a case for Transformation2\", \"[Common][Transformation2]\") {\n\tSECTION(\"SetTransformation 2D\") {\n\t\tAxis2 a1(PointT<double, 2>(1.0, 2.0), DirectionT<double, 2>(3.0, 4.0));\n\t\tAxis2 a2(PointT<double, 2>(3.0, 1.0), DirectionT<double, 2>(1.0, 5.0));\n\t\tTransformationT<double, 2> tr;\n\t\ttr.SetTransformation(a1, a2);\n\t\tCoordT<double, 2> p(4.0, 1.0);\n\t\ttr.Transform(p);\n\t\tCoordT<double, 2> p2(118.0 / (5.0 * std::sqrt(26.0)), 34.0 / (5.0 * std::sqrt(26.0)));\n\t\tCHECK(IsEqual(p, p2));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, typename OtherScalar2> void SetScale(const PointT<OtherScalar, DIM>& point, const OtherScalar2& s),\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T>\nstatic bool IsEqual(const T& result, const T& expected)\n{\n\treturn result == expected;\n}\nstatic bool IsEqual(const double& result, const double& expected)\n{\n\treturn std::fabs(result - expected) <= 1e-15;\n}\ntemplate<typename T, int DIM>\nstatic bool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)\n{\n\tfor (int i = 0; i < DIM; i++)\n\t{\n\t\tif (!IsEqual(result[i], expected[i]))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int ROW, int COL>\nstatic bool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)\n{\n\tfor (int i = 0; i < ROW; i++)\n\t{\n\t\tfor (int j = 0; j < COL; j++)\n\t\t{\n\t\t\tif (!IsEqual(result(i, j), expected(i, j)))\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)\n{\n\treturn IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());\n}\nTEST_CASE(\"case1:this is a case for Transformation2\", \"[Common][Transformation2]\") {\n\tSECTION(\"SetScale 2D\") {\n\t\tTransformationT<double, 2> tr;\n\t\ttr.SetScale(PointT<double, 2>(2.0, 3.0), 1.5);\n\t\tCoordT<double, 2> p(1.0, 2.0);\n\t\ttr.Transform(p);\n\t\tCoordT<double, 2> p2(0.5, 1.5);\n\t\tCHECK(IsEqual(p, p2));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar> void SetMirror(const AxisT<OtherScalar, DIM>& axis),\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T>\nstatic bool IsEqual(const T& result, const T& expected)\n{\n\treturn result == expected;\n}\nstatic bool IsEqual(const double& result, const double& expected)\n{\n\treturn std::fabs(result - expected) <= 1e-15;\n}\ntemplate<typename T, int DIM>\nstatic bool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)\n{\n\tfor (int i = 0; i < DIM; i++)\n\t{\n\t\tif (!IsEqual(result[i], expected[i]))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int ROW, int COL>\nstatic bool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)\n{\n\tfor (int i = 0; i < ROW; i++)\n\t{\n\t\tfor (int j = 0; j < COL; j++)\n\t\t{\n\t\t\tif (!IsEqual(result(i, j), expected(i, j)))\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)\n{\n\treturn IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());\n}\nTEST_CASE(\"case1:this is a case for Transformation2\", \"[Common][Transformation2]\") {\n\tSECTION(\"SetMirror axis 2D\") {\n\t\tTransformationT<double, 2> tr;\n\t\tAxisT<double, 2> axis(PointT<double, 2>(2.0, 3.0), DirectionT<double, 2>(7.0, 3.0));\n\t\ttr.SetMirror(axis);\n\t\tCoordT<double, 2> p(1.0, 2.0);\n\t\ttr.Transform(p);\n\t\tCoordT<double, 2> p2(17.0 / 29.0, 86.0 / 29.0);\n\t\tCHECK(IsEqual(p, p2));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar> void SetMirror(const PointT<OtherScalar, DIM>& point),\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T>\nstatic bool IsEqual(const T& result, const T& expected)\n{\n\treturn result == expected;\n}\nstatic bool IsEqual(const double& result, const double& expected)\n{\n\treturn std::fabs(result - expected) <= 1e-15;\n}\ntemplate<typename T, int DIM>\nstatic bool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)\n{\n\tfor (int i = 0; i < DIM; i++)\n\t{\n\t\tif (!IsEqual(result[i], expected[i]))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int ROW, int COL>\nstatic bool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)\n{\n\tfor (int i = 0; i < ROW; i++)\n\t{\n\t\tfor (int j = 0; j < COL; j++)\n\t\t{\n\t\t\tif (!IsEqual(result(i, j), expected(i, j)))\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)\n{\n\treturn IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());\n}\nTEST_CASE(\"case1:this is a case for Transformation2\", \"[Common][Transformation2]\") {\n\tSECTION(\"SetMirror point 2D\") {\n\t\tTransformationT<double, 2> tr;\n\t\tPointT<double, 2> p(2.0, 4.0);\n\t\ttr.SetMirror(p);\n\t\tCoordT<double, 2> p2(1.0, 2.0);\n\t\ttr.Transform(p2);\n\t\tCoordT<double, 2> p3(3.0, 6.0);\n\t\tCHECK(IsEqual(p2, p3));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] const CoordT<Scalar, DIM>& TranslationPart()\t @return The translation part\n\t @brief Get the translation part of the transformation\n,\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T>\nstatic bool IsEqual(const T& result, const T& expected)\n{\n\treturn result == expected;\n}\nstatic bool IsEqual(const double& result, const double& expected)\n{\n\treturn std::fabs(result - expected) <= 1e-15;\n}\ntemplate<typename T, int DIM>\nstatic bool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)\n{\n\tfor (int i = 0; i < DIM; i++)\n\t{\n\t\tif (!IsEqual(result[i], expected[i]))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int ROW, int COL>\nstatic bool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)\n{\n\tfor (int i = 0; i < ROW; i++)\n\t{\n\t\tfor (int j = 0; j < COL; j++)\n\t\t{\n\t\t\tif (!IsEqual(result(i, j), expected(i, j)))\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Coord(), expected.Coord());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)\n{\n\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)\n{\n\treturn IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());\n}\nTEST_CASE(\"case1:this is a case for Transformation2\", \"[Common][Transformation2]\") {\n\tSECTION(\"default constructor 2D\") {\n\t\tTransformationT<double, 2> tr;\n\t\tMatrixT<double, 2, 2> mat;\n\t\tmat.SetIdentity();\n\t\tCoordT<double, 2> c;\n\t\tdouble scale = 1.0;\n\t\tCHECK(IsEqual(tr.ScaleFactor(), scale));\n\t\tCHECK(IsEqual(tr.Type(), TransformationType::Identity));\n\t\tCHECK(IsEqual(tr.HVectorialPart(), mat));\n\t\tCHECK(IsEqual(tr.TranslationPart(), c));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar> [[nodiscard]] VectorT Scaled(const OtherScalar& scale),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Vector3\", \"[Common][Vector3]\"){\n\tSECTION(\"Scale\") {\n        VectorT<double, 3> p1(1.0, 2.0, 3.0);\n        VectorT<double, 3> p3(1.5, 3.0, 4.5);\n        CHECK(p1.Scaled(1.5).IsEqual(p3, tolDis, tolAng));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, typename OtherScalar2, int DIM2 = DIM, typename = typename std::enable_if_t<DIM2 == 3>> [[nodiscard]] VectorT Rotated(const AxisT<OtherScalar, DIM>& axis, const OtherScalar2& angle),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Vector3\", \"[Common][Vector3]\"){\n\tSECTION(\"Rotate 3D\") {\n        VectorT<double, 3> p1(1.0, 2.0, 3.0);\n        PointT<double, 3> p2(2.0, 3.0, 4.0);\n        DirectionT<double, 3> d(1.0, 1.0, 2.0);\n        AxisT<double, 3> a(p2, d);\n        VectorT<double, 3> p3((9.0 - std::sqrt(6.0)) / 6.0, (9.0 - std::sqrt(6.0)) / 6.0, 3.0 + 1.0 / std::sqrt(6.0));\n        CHECK(p1.Rotated(a, M_PI_2).IsEqual(p3, tolDis, tolAng));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, typename OtherScalar2, int DIM2 = DIM, typename = typename std::enable_if_t<DIM2 == 3>> VectorT& Rotate(const AxisT<OtherScalar, DIM>& axis, const OtherScalar2& angle),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Vector3\", \"[Common][Vector3]\"){\n\tSECTION(\"Rotate 3D\") {\n        VectorT<double, 3> p1(1.0, 2.0, 3.0);\n        PointT<double, 3> p2(2.0, 3.0, 4.0);\n        DirectionT<double, 3> d(1.0, 1.0, 2.0);\n        AxisT<double, 3> a(p2, d);\n        VectorT<double, 3> p3((9.0 - std::sqrt(6.0)) / 6.0, (9.0 - std::sqrt(6.0)) / 6.0, 3.0 + 1.0 / std::sqrt(6.0));\n        CHECK(p1.Rotated(a, M_PI_2).IsEqual(p3, tolDis, tolAng));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, int DIM2 = DIM, std::enable_if_t<DIM2 == 3, int> = 0> [[nodiscard]] VectorT Mirrored(const FrameT<OtherScalar, DIM>& frame),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Vector3\", \"[Common][Vector3]\"){\n\tSECTION(\"Mirror(axis) 3D\") {\n        VectorT<double, 3> p1(1.0, 2.0, 3.0);\n        PointT<double, 3> p2(2.0, 3.0, 4.0);\n        DirectionT<double, 3> d(7.0, 3.0, 2.0);\n        AxisT<double, 3> a(p2, d);\n        VectorT<double, 3> p3(102.0 / 31.0, -5.0 / 31.0, -55.0 / 31.0);\n        CHECK(p1.Mirrored(a).IsEqual(p3, tolDis, tolAng));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar> [[nodiscard]] VectorT Mirrored(const AxisT<OtherScalar, DIM>& axis),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Vector3\", \"[Common][Vector3]\"){\n\tSECTION(\"Mirror(axis) 3D\") {\n        VectorT<double, 3> p1(1.0, 2.0, 3.0);\n        PointT<double, 3> p2(2.0, 3.0, 4.0);\n        DirectionT<double, 3> d(7.0, 3.0, 2.0);\n        AxisT<double, 3> a(p2, d);\n        VectorT<double, 3> p3(102.0 / 31.0, -5.0 / 31.0, -55.0 / 31.0);\n        CHECK(p1.Mirrored(a).IsEqual(p3, tolDis, tolAng));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar> [[nodiscard]] VectorT Mirrored(const VectorT<OtherScalar, DIM>& p),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Vector3\", \"[Common][Vector3]\"){\n\tSECTION(\"Mirror(axis) 3D\") {\n        VectorT<double, 3> p1(1.0, 2.0, 3.0);\n        PointT<double, 3> p2(2.0, 3.0, 4.0);\n        DirectionT<double, 3> d(7.0, 3.0, 2.0);\n        AxisT<double, 3> a(p2, d);\n        VectorT<double, 3> p3(102.0 / 31.0, -5.0 / 31.0, -55.0 / 31.0);\n        CHECK(p1.Mirrored(a).IsEqual(p3, tolDis, tolAng));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, int DIM2 = DIM, std::enable_if_t<DIM2 == 3, int> = 0> VectorT& Mirror(const FrameT<OtherScalar, DIM>& frame),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Vector3\", \"[Common][Vector3]\"){\n\tSECTION(\"Mirror(axis) 3D\") {\n        VectorT<double, 3> p1(1.0, 2.0, 3.0);\n        PointT<double, 3> p2(2.0, 3.0, 4.0);\n        DirectionT<double, 3> d(7.0, 3.0, 2.0);\n        AxisT<double, 3> a(p2, d);\n        VectorT<double, 3> p3(102.0 / 31.0, -5.0 / 31.0, -55.0 / 31.0);\n        CHECK(p1.Mirrored(a).IsEqual(p3, tolDis, tolAng));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar> VectorT& Mirror(const AxisT<OtherScalar, DIM>& axis),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Vector3\", \"[Common][Vector3]\"){\n\tSECTION(\"Mirror(axis) 3D\") {\n        VectorT<double, 3> p1(1.0, 2.0, 3.0);\n        PointT<double, 3> p2(2.0, 3.0, 4.0);\n        DirectionT<double, 3> d(7.0, 3.0, 2.0);\n        AxisT<double, 3> a(p2, d);\n        VectorT<double, 3> p3(102.0 / 31.0, -5.0 / 31.0, -55.0 / 31.0);\n        CHECK(p1.Mirrored(a).IsEqual(p3, tolDis, tolAng));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar> VectorT& Mirror(const VectorT<OtherScalar, DIM>& p),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Vector3\", \"[Common][Vector3]\"){\n\tSECTION(\"Mirror(frame) 3D\") {\n        VectorT<double, 3> p1(1.0, 2.0, 3.0);\n        PointT<double, 3> p2(2.0, 3.0, 4.0);\n        DirectionT<double, 3> d(7.0, 3.0, 2.0);\n        FrameT<double, 3> f(p2, d);\n        VectorT<double, 3> p3(-102.0 / 31.0, 5.0 / 31.0, 55.0 / 31.0);\n        CHECK(p1.Mirror(f).IsEqual(p3, tolDis, tolAng));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] VectorT Normalized()\t @return The normalized vector\n\t @brief Get the normalized vector\n,\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Vector3\", \"[Common][Vector3]\"){\n\tSECTION(\"Normalize\") {\n        VectorT<double, 3> v1(1.0, 2.0, 2.0);\n        VectorT<double, 3> v2(1.0 / 3.0, 2.0 / 3.0, 2.0 / 3.0);\n        CHECK(v1.Normalized().IsEqual(v2, tolDis, tolAng));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "VectorT& Normalize()\t @return The reference to self\n\t @brief Normalize the vector\n,\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Vector3\", \"[Common][Vector3]\"){\n\tSECTION(\"Normalize\") {\n        VectorT<double, 3> v1(1.0, 2.0, 2.0);\n        VectorT<double, 3> v2(1.0 / 3.0, 2.0 / 3.0, 2.0 / 3.0);\n        CHECK(v1.Normalized().IsEqual(v2, tolDis, tolAng));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar> [[nodiscard]] auto Cross(const VectorT<OtherScalar, DIM>& other),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Vector3\", \"[Common][Vector3]\"){\n\tSECTION(\"Cross 3D\") {\n        VectorT<double, 3> v1(1.0, 2.0, 3.0);\n        VectorT<double, 3> v2(2.0, 3.0, 4.0);\n        VectorT<double, 3> v3(-1.0, 2.0, -1.0);\n        CHECK(v1.Cross(v2).IsEqual(v3, tolDis, tolAng));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] double SquaredNorm()\t @return The squared norm of vector\n\t @brief Get the squared norm of vector\n,\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Vector3\", \"[Common][Vector3]\"){\n\tSECTION(\"SquaredNorm\") {\n        VectorT<double, 3> v1(1.0, 2.0, 3.0);\n        CHECK(v1.SquaredNorm() == Approx(14.0));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, typename OtherScalar2, int DIM2 = DIM, typename = typename std::enable_if_t<DIM2 == 3>> [[nodiscard]] Scalar AngleWithRef(const VectorT<OtherScalar, DIM>& other, const VectorT<OtherScalar2, DIM>& ref),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Vector3\", \"[Common][Vector3]\"){\n\tSECTION(\"AngleWithRef\") {\n        VectorT<double, 3> v1(1.0, 2.0, 3.0);\n        VectorT<double, 3> v2(-3.0, 2.0, -1.0);\n        VectorT<double, 3> v3(1.0, 1.0, 1.0);\n        CHECK(v1.AngleWithRef(v2, v3) == -acos(-1.0 / 7.0));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, int DIM2 = DIM, std::enable_if_t<DIM2 == 3, int> = 0> [[nodiscard]] auto Angle(const VectorT<OtherScalar, DIM>& other),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Vector3\", \"[Common][Vector3]\"){\n\tSECTION(\"Angle 3D\") {\n        VectorT<double, 3> v1(1.0, 2.0, 3.0);\n        VectorT<double, 3> v2(-3.0, 2.0, -1.0);\n        CHECK(v1.Angle(v2) == acos(-1.0 / 7.0));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, typename OtherScalar2> [[nodiscard]] bool IsParallel(const VectorT<OtherScalar, DIM>& other, const OtherScalar2& tol),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Vector3\", \"[Common][Vector3]\"){\n\tSECTION(\"IsParallel\") {\n        VectorT<double, 3> v1(1.0, 2.0, 3.0);\n        VectorT<double, 3> v2(-1.0, -2.0, -3.01);\n        CHECK(v1.IsParallel(v2, tolDis) == false);\n        CHECK(v1.IsParallel(v2, 0.1) == true);\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, typename OtherScalar2> [[nodiscard]] bool IsOpposite(const VectorT<OtherScalar, DIM>& other, const OtherScalar2& tol),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Vector3\", \"[Common][Vector3]\"){\n\tSECTION(\"IsOpposite\") {\n        VectorT<double, 3> v1(1.0, 2.0, 3.0);\n        VectorT<double, 3> v2(-1.0, -2.0, -3.01);\n        CHECK(v1.IsOpposite(v2, tolDis) == false);\n        CHECK(v1.IsOpposite(v2, 0.1) == true);\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, typename OtherScalar2> [[nodiscard]] bool IsNormal(const VectorT<OtherScalar, DIM>& other, const OtherScalar2& tol),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Vector3\", \"[Common][Vector3]\"){\n\tSECTION(\"IsNormal\") {\n        VectorT<double, 3> v1(1.0, 2.0, 3.0);\n        VectorT<double, 3> v2(-4.0, -1.0, 2.01);\n        CHECK(v1.IsNormal(v2, 0.001) == false);\n        CHECK(v1.IsNormal(v2, 0.1) == true);\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, typename OtherScalar2, typename OtherScalar3> [[nodiscard]] bool IsEqual(const VectorT<OtherScalar, DIM>& other, const OtherScalar2& tolDis, const OtherScalar3& tolAng),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Vector3\", \"[Common][Vector3]\"){\n\tSECTION(\"IsEqual\") {\n        VectorT<double, 3> v1(1.0, 2.0, 3.0);\n        VectorT<double, 3> v2(1.01, 2.0, 3.0);\n        CHECK(v1.IsEqual(v2, tolDis, tolAng) == false);\n        CHECK(v1.IsEqual(v2, 0.1, tolAng) == true);\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar> void SetCoord(const CoordT<OtherScalar, DIM>& v),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Vector3\", \"[Common][Vector3]\"){\n\tSECTION(\"SetCoord(v)\") {\n        VectorT<double, 3> result;\n        result.SetCoord(CoordT<double, 3>(1.0, 2.0, 3.0));\n        VectorT<double, 3> expected(1.0, 2.0, 3.0);\n        CHECK(result.IsEqual(expected, tolDis, tolAng));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename... T> void SetCoord(T... vs),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Vector3\", \"[Common][Vector3]\"){\n\tSECTION(\"SetCoord(x, y, z)\") {\n        VectorT<double, 3> result;\n        result.SetCoord(1.0, 2.0, 3.0);\n        VectorT<double, 3> expected(1.0, 2.0, 3.0);\n        CHECK(result.IsEqual(expected, tolDis, tolAng));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, typename OtherScalar2> VectorT(const PointT<OtherScalar, DIM>& p1, const PointT<OtherScalar2, DIM>& p2),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Vector3\", \"[Common][Vector3]\"){\n\tSECTION(\"Constructor from two points\") {\n        PointT<double, 3> p1(1.0, 2.0, 3.0);\n        PointT<double, 3> p2(2.0, 3.0, 4.0);\n        VectorT<double, 3> result(p1, p2);\n        VectorT<double, 3> expected(1.0, 1.0, 1.0);\n        CHECK(result.IsEqual(expected, tolDis, tolAng));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename... T> explicit VectorT(T... vs),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Vector3\", \"[Common][Vector3]\"){\n\tSECTION(\"Default constructor\") {\n        VectorT<double, 3> p1;\n        VectorT<double, 3> p2(0.0, 0.0, 0.0);\n        CHECK(p1.IsEqual(p2, tolDis, tolAng));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar> explicit VectorT(const CoordT<OtherScalar, DIM>& v),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Vector3\", \"[Common][Vector3]\"){\n\tSECTION(\"Constructor from direction\") {\n        DirectionT<double, 3> v(1.0, 2.0, 3.0);\n        VectorT<double, 3> result(v);\n        VectorT<double, 3> expected(1.0 / sqrt(14.0), 2.0 / sqrt(14.0), 3.0 / sqrt(14.0));\n        CHECK(result.IsEqual(expected, tolDis, tolAng));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar> explicit VectorT(const DirectionT<OtherScalar, DIM>& dir),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Vector3\", \"[Common][Vector3]\"){\n\tSECTION(\"Constructor from direction\") {\n        DirectionT<double, 3> v(1.0, 2.0, 3.0);\n        VectorT<double, 3> result(v);\n        VectorT<double, 3> expected(1.0 / sqrt(14.0), 2.0 / sqrt(14.0), 3.0 / sqrt(14.0));\n        CHECK(result.IsEqual(expected, tolDis, tolAng));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "VectorT()\t @details The default vector is (0, 0, ..., 0)\n\t @brief The default constructor\n,\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Vector3\", \"[Common][Vector3]\"){\n\tSECTION(\"Default constructor\") {\n        VectorT<double, 3> p1;\n        VectorT<double, 3> p2(0.0, 0.0, 0.0);\n        CHECK(p1.IsEqual(p2, tolDis, tolAng));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] auto Norm()\t @return The norm of vector\n\t @brief Get the norm of vector\n,\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Vector3\", \"[Common][Vector3]\"){\n\tSECTION(\"Norm\") {\n        VectorT<double, 3> v1(1.0, 2.0, 3.0);\n        CHECK(v1.Norm() == sqrt(14.0));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, int DIM2 = DIM, typename = typename std::enable_if_t<DIM2 == 2>> [[nodiscard]] VectorT Rotated(const OtherScalar& angle),\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Vector2\", \"[Common][Vector2]\"){\n\tSECTION(\"Rotate 2D\") {\n        VectorT<double, 2> p1(1.0, 2.0);\n        VectorT<double, 2> p3(-2.0, 1.0);\n        CHECK(p1.Rotated(M_PI_2).IsEqual(p3, tolDis, tolAng));\n    }\n}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, int DIM2 = DIM, typename = typename std::enable_if_t<DIM2 == 2>> VectorT& Rotate(const OtherScalar& angle),\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Vector2\", \"[Common][Vector2]\"){\n\tSECTION(\"Rotate 2D\") {\n        VectorT<double, 2> p1(1.0, 2.0);\n        VectorT<double, 2> p3(-2.0, 1.0);\n        CHECK(p1.Rotated(M_PI_2).IsEqual(p3, tolDis, tolAng));\n    }\n}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar> [[nodiscard]] VectorT Mirrored(const AxisT<OtherScalar, DIM>& axis),\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Vector2\", \"[Common][Vector2]\"){\n\tSECTION(\"Mirror(axis) 2D\") {\n        VectorT<double, 2> p1(1.0, 2.0);\n        PointT<double, 2> p2(2.0, 3.0);\n        DirectionT<double, 2> d(7.0, 3.0);\n        AxisT<double, 2> a(p2, d);\n        VectorT<double, 2> p3(62.0 / 29.0, -19.0 / 29.0);\n        CHECK(p1.Mirrored(a).IsEqual(p3, tolDis, tolAng));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar> [[nodiscard]] VectorT Mirrored(const VectorT<OtherScalar, DIM>& p),\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Vector2\", \"[Common][Vector2]\"){\n\tSECTION(\"Mirror(point) 2D\") {\n        VectorT<double, 2> p1(1.0, 2.0);\n        VectorT<double, 2> p2(2.0, 3.0);\n        VectorT<double, 2> p3(19.0 / 13.0, 22.0 / 13.0);\n        CHECK(p1.Mirrored(p2).IsEqual(p3, tolDis, tolAng));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar> VectorT& Mirror(const AxisT<OtherScalar, DIM>& axis),\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Vector2\", \"[Common][Vector2]\"){\n\tSECTION(\"Mirror(axis) 2D\") {\n        VectorT<double, 2> p1(1.0, 2.0);\n        PointT<double, 2> p2(2.0, 3.0);\n        DirectionT<double, 2> d(7.0, 3.0);\n        AxisT<double, 2> a(p2, d);\n        VectorT<double, 2> p3(62.0 / 29.0, -19.0 / 29.0);\n        CHECK(p1.Mirrored(a).IsEqual(p3, tolDis, tolAng));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar> VectorT& Mirror(const VectorT<OtherScalar, DIM>& p),\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Vector2\", \"[Common][Vector2]\"){\n\tSECTION(\"Mirror(axis) 2D\") {\n        VectorT<double, 2> p1(1.0, 2.0);\n        PointT<double, 2> p2(2.0, 3.0);\n        DirectionT<double, 2> d(7.0, 3.0);\n        AxisT<double, 2> a(p2, d);\n        VectorT<double, 2> p3(62.0 / 29.0, -19.0 / 29.0);\n        CHECK(p1.Mirrored(a).IsEqual(p3, tolDis, tolAng));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar> [[nodiscard]] auto Cross(const VectorT<OtherScalar, DIM>& other),\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Vector2\", \"[Common][Vector2]\"){\n\tSECTION(\"Cross 2D\") {\n        VectorT<double, 2> v1(1.0, 2.0);\n        VectorT<double, 2> v2(2.0, 3.0);\n        CHECK(v1.Cross(v2) == -1.0);\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, int DIM2 = DIM, std::enable_if_t<DIM2 == 2, int> = 0> [[nodiscard]] auto Angle(const VectorT<OtherScalar, DIM>& other),\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Vector2\", \"[Common][Vector2]\"){\n\tSECTION(\"Angle 2D\") {\n        VectorT<double, 2> v1(1.0, 3.0);\n        VectorT<double, 2> v2(-1.0, 2.0);\n        CHECK(v1.Angle(v2) == Approx(acos(M_SQRT1_2)));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, typename OtherScalar2> VectorT(const PointT<OtherScalar, DIM>& p1, const PointT<OtherScalar2, DIM>& p2),\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Vector2\", \"[Common][Vector2]\"){\n\tSECTION(\"Angle 2D\") {\n        VectorT<double, 2> v1(1.0, 3.0);\n        VectorT<double, 2> v2(-1.0, 2.0);\n        CHECK(v1.Angle(v2) == Approx(acos(M_SQRT1_2)));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename... T> explicit VectorT(T... vs),\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Vector2\", \"[Common][Vector2]\"){\n\tSECTION(\"Angle 2D\") {\n        VectorT<double, 2> v1(1.0, 3.0);\n        VectorT<double, 2> v2(-1.0, 2.0);\n        CHECK(v1.Angle(v2) == Approx(acos(M_SQRT1_2)));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, typename OtherScalar2, int DIM2 = DIM, typename = typename std::enable_if_t<DIM2 == 3>> [[nodiscard]] DirectionT Rotated(const AxisT<OtherScalar, DIM>& axis, const OtherScalar2& angle),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Direction3\", \"[Common][Direction3]\") {\n\tSECTION(\"IsParallel\"){\n        DirectionT<double, 3> v1(1.0, 2.0, 3.0);\n        DirectionT<double, 3> v2(-1.0, -2.0, -3.01);\n        CHECK(v1.IsParallel(v2, tol) == false);\n        CHECK(v1.IsParallel(v2, 0.1));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, int DIM2 = DIM, std::enable_if_t<DIM2 == 3, int> = 0> [[nodiscard]] DirectionT Mirrored(const FrameT<OtherScalar, DIM>& frame),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Direction3\", \"[Common][Direction3]\") {\n\tSECTION(\"Default constructor\") {\n        DirectionT<double, 3> p1;\n        DirectionT<double, 3> p2(1.0, 0.0, 0.0);\n        CHECK(p1.IsEqual(p2, tol));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar> [[nodiscard]] DirectionT Mirrored(const AxisT<OtherScalar, DIM>& axis),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Direction3\", \"[Common][Direction3]\") {\n\tSECTION(\"Mirror(axis) 3D\") {\n        DirectionT<double, 3> p1(1.0, 2.0, 3.0);\n        PointT<double, 3> p2(2.0, 3.0, 4.0);\n        DirectionT<double, 3> d(7.0, 3.0, 2.0);\n        AxisT<double, 3> a(p2, d);\n        DirectionT<double, 3> p3(102.0 / 31.0, -5.0 / 31.0, -55.0 / 31.0);\n        CHECK(p1.Mirrored(a).IsEqual(p3, tol));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, int DIM2 = DIM, std::enable_if_t<DIM2 == 3, int> = 0> DirectionT& Mirror(const FrameT<OtherScalar, DIM>& frame),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Direction3\", \"[Common][Direction3]\") {\n\tSECTION(\"Default constructor\") {\n        DirectionT<double, 3> p1;\n        DirectionT<double, 3> p2(1.0, 0.0, 0.0);\n        CHECK(p1.IsEqual(p2, tol));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar> DirectionT& Mirror(const AxisT<OtherScalar, DIM>& axis),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Direction3\", \"[Common][Direction3]\") {\n\tSECTION(\"Mirror(axis) 3D\") {\n        DirectionT<double, 3> p1(1.0, 2.0, 3.0);\n        PointT<double, 3> p2(2.0, 3.0, 4.0);\n        DirectionT<double, 3> d(7.0, 3.0, 2.0);\n        AxisT<double, 3> a(p2, d);\n        DirectionT<double, 3> p3(102.0 / 31.0, -5.0 / 31.0, -55.0 / 31.0);\n        CHECK(p1.Mirrored(a).IsEqual(p3, tol));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar> DirectionT& Mirror(const DirectionT<OtherScalar, DIM>& dir),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Direction3\", \"[Common][Direction3]\") {\n\tSECTION(\"Mirror(frame) 3D\") {\n        DirectionT<double, 3> p1(1.0, 2.0, 3.0);\n        PointT<double, 3> p2(2.0, 3.0, 4.0);\n        DirectionT<double, 3> d(7.0, 3.0, 2.0);\n        FrameT<double, 3> f(p2, d);\n        DirectionT<double, 3> p3(-102.0 / 31.0, 5.0 / 31.0, 55.0 / 31.0);\n        CHECK(p1.Mirrored(f).IsEqual(p3, tol));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar> [[nodiscard]] auto Cross(const DirectionT<OtherScalar, DIM>& other),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Direction3\", \"[Common][Direction3]\") {\n\tSECTION(\"Cross 3D\") {\n        DirectionT<double, 3> v1(1.0, 2.0, 3.0);\n        DirectionT<double, 3> v2(2.0, 3.0, 4.0);\n        CoordT<double, 3> v3(-1.0 / std::sqrt(6.0), 2.0 / std::sqrt(6.0), -1.0 / std::sqrt(6.0));\n        CHECK(v1.Cross(v2).Coord().IsEqual(v3, tol));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, typename OtherScalar2, int DIM2 = DIM, typename = typename std::enable_if_t<DIM2 == 3>> [[nodiscard]] auto AngleWithRef(const DirectionT<OtherScalar, DIM>& other, const DirectionT<OtherScalar2, DIM>& ref),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Direction3\", \"[Common][Direction3]\") {\n\tSECTION(\"AngleWithRef\") {\n        DirectionT<double, 3> v1(1.0, 2.0, 3.0);\n        DirectionT<double, 3> v2(-3.0, 2.0, -1.0);\n        DirectionT<double, 3> v3(1.0, 1.0, 1.0);\n        CHECK(v1.AngleWithRef(v2, v3) == Approx(-acos(-1.0 / 7.0)));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, int DIM2 = DIM, std::enable_if_t<DIM2 == 3, int> = 0> [[nodiscard]] auto Angle(const DirectionT<OtherScalar, DIM>& other),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Direction3\", \"[Common][Direction3]\") {\n\tSECTION(\"Angle 3D\") {\n        DirectionT<double, 3> v1(1.0, 2.0, 3.0);\n        DirectionT<double, 3> v2(-3.0, 2.0, -1.0);\n        CHECK(v1.Angle(v2) == acos(-1.0 / 7.0));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, typename OtherScalar2> [[nodiscard]] bool IsParallel(const DirectionT<OtherScalar, DIM>& other, const OtherScalar2& tol),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Direction3\", \"[Common][Direction3]\") {\n\tSECTION(\"IsParallel\"){\n        DirectionT<double, 3> v1(1.0, 2.0, 3.0);\n        DirectionT<double, 3> v2(-1.0, -2.0, -3.01);\n        CHECK(v1.IsParallel(v2, tol) == false);\n        CHECK(v1.IsParallel(v2, 0.1));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, typename OtherScalar2> [[nodiscard]] bool IsOpposite(const DirectionT<OtherScalar, DIM>& other, const OtherScalar2& tol),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Direction3\", \"[Common][Direction3]\") {\n\tSECTION(\"IsOpposite\") {\n        DirectionT<double, 3> v1(1.0, 2.0, 3.0);\n        DirectionT<double, 3> v2(-1.0, -2.0, -3.01);\n        CHECK(v1.IsOpposite(v2, 0.1));\n        CHECK(v1.IsOpposite(v2, tol) == false);\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, typename OtherScalar2> [[nodiscard]] bool IsNormal(const DirectionT<OtherScalar, DIM>& other, const OtherScalar2& tol),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Direction3\", \"[Common][Direction3]\") {\n\tSECTION(\"IsNormal\") {\n        DirectionT<double, 3> v1(1.0, 2.0, 3.0);\n        DirectionT<double, 3> v2(-4.0, -1.0, 2.01);\n        CHECK(v1.IsNormal(v2, tol) == false);\n        CHECK(v1.IsNormal(v2, 0.1));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, typename OtherScalar2> [[nodiscard]] bool IsEqual(const DirectionT<OtherScalar, DIM>& other, const OtherScalar2& tol),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Direction3\", \"[Common][Direction3]\") {\n\tSECTION(\"Constructor from vector\") {\n        VectorT<double, 3> v(1.0, 2.0, 3.0);\n        DirectionT<double, 3> result(v);\n        CoordT<double, 3> expected(1.0 / sqrt(14.0), 2.0 / sqrt(14.0), 3.0 / sqrt(14.0));\n        CHECK(result.Coord().IsEqual(expected, tol));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, typename = typename std::enable_if_t<DIM >= 4 && std::is_convertible_v<OtherScalar, Scalar>>> void SetW(const OtherScalar& w),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Direction3\", \"[Common][Direction3]\") {\n\tSECTION(\"SetX, SetY, SetZ, SetW\"){\n        DirectionT<double, 4> result;\n        result.SetX(1);\n        result.SetY(2);\n        result.SetZ(3);\n        result.SetW(4);\n        CoordT<double, 4> expected(1.0 / sqrt(850.0), 2.0 / sqrt(850.0), 3.0 / sqrt(170), 4.0 / sqrt(17));\n        CHECK(result.X() == Approx(1.0 / sqrt(850.0)));\n        CHECK(result.Y() == Approx(2.0 / sqrt(850.0)));\n        CHECK(result.Z() == Approx(3.0 / sqrt(170.0)));\n        CHECK(result.W() == Approx(4.0 / sqrt(17.0)));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename... T> void SetCoord(T... vs),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Direction3\", \"[Common][Direction3]\") {\n\tSECTION(\"SetCoord(x, y, z)\") {\n        DirectionT<double, 3> result;\n        result.SetCoord(1.0, 2.0, 3.0);\n        CoordT<double, 3> expected(1.0 / sqrt(14.0), 2.0 / sqrt(14.0), 3.0 / sqrt(14.0));\n        CHECK(result.Coord().IsEqual(expected, tol));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename... T> explicit DirectionT(T... vs),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Direction3\", \"[Common][Direction3]\") {\n\tSECTION(\"Default constructor\") {\n        DirectionT<double, 3> p1;\n        DirectionT<double, 3> p2(1.0, 0.0, 0.0);\n        CHECK(p1.IsEqual(p2, tol));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar> explicit DirectionT(const CoordT<OtherScalar, DIM>& v),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Direction3\", \"[Common][Direction3]\") {\n\tSECTION(\"Constructor from vector\") {\n        VectorT<double, 3> v(1.0, 2.0, 3.0);\n        DirectionT<double, 3> result(v);\n        CoordT<double, 3> expected(1.0 / sqrt(14.0), 2.0 / sqrt(14.0), 3.0 / sqrt(14.0));\n        CHECK(result.Coord().IsEqual(expected, tol));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar> explicit DirectionT(const VectorT<OtherScalar, DIM>& vec),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Direction3\", \"[Common][Direction3]\") {\n\tSECTION(\"Constructor from vector\") {\n        VectorT<double, 3> v(1.0, 2.0, 3.0);\n        DirectionT<double, 3> result(v);\n        CoordT<double, 3> expected(1.0 / sqrt(14.0), 2.0 / sqrt(14.0), 3.0 / sqrt(14.0));\n        CHECK(result.Coord().IsEqual(expected, tol));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "DirectionT()\t @details Default direction is (1, 0, ... , 0)\n\t @brief Default constructor\n,\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Direction3\", \"[Common][Direction3]\") {\n\tSECTION(\"Default constructor\") {\n        DirectionT<double, 3> p1;\n        DirectionT<double, 3> p2(1.0, 0.0, 0.0);\n        CHECK(p1.IsEqual(p2, tol));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, int DIM2 = DIM, typename = typename std::enable_if_t<DIM2 == 2>> [[nodiscard]] DirectionT Rotated(const OtherScalar& angle),\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Direction2\", \"[Common][Direction2]\") {\n\tSECTION(\"Angle 2D\") {\n        DirectionT<double, 2> v1(1.0, 3.0);\n        DirectionT<double, 2> v2(-1.0, 2.0);\n        CHECK(v1.Angle(v2) == Approx(acos(M_SQRT1_2)));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, int DIM2 = DIM, typename = typename std::enable_if_t<DIM2 == 2>> DirectionT& Rotate(const OtherScalar& angle),\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Direction2\", \"[Common][Direction2]\") {\n\tSECTION(\"Mirror(axis) 2D\") {\n        DirectionT<double, 2> p1(1.0, 2.0);\n        PointT<double, 2> p2(2.0, 3.0);\n        DirectionT<double, 2> d(7.0, 3.0);\n        AxisT<double, 2> a(p2, d);\n        DirectionT<double, 2> p3(62.0 / 29.0, -19.0 / 29.0);\n        CHECK(p1.Mirrored(a).IsEqual(p3, tol));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar> [[nodiscard]] DirectionT Mirrored(const AxisT<OtherScalar, DIM>& axis),\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Direction2\", \"[Common][Direction2]\") {\n\tSECTION(\"Mirror(axis) 2D\") {\n        DirectionT<double, 2> p1(1.0, 2.0);\n        PointT<double, 2> p2(2.0, 3.0);\n        DirectionT<double, 2> d(7.0, 3.0);\n        AxisT<double, 2> a(p2, d);\n        DirectionT<double, 2> p3(62.0 / 29.0, -19.0 / 29.0);\n        CHECK(p1.Mirrored(a).IsEqual(p3, tol));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar> [[nodiscard]] DirectionT Mirrored(const DirectionT<OtherScalar, DIM>& dir),\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Direction2\", \"[Common][Direction2]\") {\n\tSECTION(\"Mirror(axis) 2D\") {\n        DirectionT<double, 2> p1(1.0, 2.0);\n        PointT<double, 2> p2(2.0, 3.0);\n        DirectionT<double, 2> d(7.0, 3.0);\n        AxisT<double, 2> a(p2, d);\n        DirectionT<double, 2> p3(62.0 / 29.0, -19.0 / 29.0);\n        CHECK(p1.Mirrored(a).IsEqual(p3, tol));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar> DirectionT& Mirror(const AxisT<OtherScalar, DIM>& axis),\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Direction2\", \"[Common][Direction2]\") {\n\tSECTION(\"Mirror(axis) 2D\") {\n        DirectionT<double, 2> p1(1.0, 2.0);\n        PointT<double, 2> p2(2.0, 3.0);\n        DirectionT<double, 2> d(7.0, 3.0);\n        AxisT<double, 2> a(p2, d);\n        DirectionT<double, 2> p3(62.0 / 29.0, -19.0 / 29.0);\n        CHECK(p1.Mirrored(a).IsEqual(p3, tol));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar> DirectionT& Mirror(const DirectionT<OtherScalar, DIM>& dir),\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Direction2\", \"[Common][Direction2]\") {\n\tSECTION(\"Mirror(axis) 2D\") {\n        DirectionT<double, 2> p1(1.0, 2.0);\n        PointT<double, 2> p2(2.0, 3.0);\n        DirectionT<double, 2> d(7.0, 3.0);\n        AxisT<double, 2> a(p2, d);\n        DirectionT<double, 2> p3(62.0 / 29.0, -19.0 / 29.0);\n        CHECK(p1.Mirrored(a).IsEqual(p3, tol));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar> [[nodiscard]] auto Cross(const DirectionT<OtherScalar, DIM>& other),\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Direction2\", \"[Common][Direction2]\") {\n\tSECTION(\"Cross 2D\") {\n        DirectionT<double, 2> v1(1.0, 2.0);\n        DirectionT<double, 2> v2(2.0, 3.0);\n        CHECK(v1.Cross(v2) == Approx(-1.0/sqrt(65.0)));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, int DIM2 = DIM, std::enable_if_t<DIM2 == 2, int> = 0> [[nodiscard]] auto Angle(const DirectionT<OtherScalar, DIM>& other),\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Direction2\", \"[Common][Direction2]\") {\n\tSECTION(\"Angle 2D\") {\n        DirectionT<double, 2> v1(1.0, 3.0);\n        DirectionT<double, 2> v2(-1.0, 2.0);\n        CHECK(v1.Angle(v2) == Approx(acos(M_SQRT1_2)));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, typename OtherScalar2> [[nodiscard]] bool IsEqual(const DirectionT<OtherScalar, DIM>& other, const OtherScalar2& tol),\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Direction2\", \"[Common][Direction2]\") {\n\tSECTION(\"Mirror(axis) 2D\") {\n        DirectionT<double, 2> p1(1.0, 2.0);\n        PointT<double, 2> p2(2.0, 3.0);\n        DirectionT<double, 2> d(7.0, 3.0);\n        AxisT<double, 2> a(p2, d);\n        DirectionT<double, 2> p3(62.0 / 29.0, -19.0 / 29.0);\n        CHECK(p1.Mirrored(a).IsEqual(p3, tol));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename... T> explicit DirectionT(T... vs),\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Direction2\", \"[Common][Direction2]\") {\n\tSECTION(\"Angle 2D\") {\n        DirectionT<double, 2> v1(1.0, 3.0);\n        DirectionT<double, 2> v2(-1.0, 2.0);\n        CHECK(v1.Angle(v2) == Approx(acos(M_SQRT1_2)));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar> explicit DirectionT(const CoordT<OtherScalar, DIM>& v),\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Direction2\", \"[Common][Direction2]\") {\n\tSECTION(\"Mirror(point) 2D\") {\n        DirectionT<double, 2> p1(1.0, 2.0);\n        DirectionT<double, 2> p2(2.0, 3.0);\n        DirectionT<double, 2> p3(19.0 / 13.0, 22.0 / 13.0);\n        CHECK(p1.Mirrored(p2).IsEqual(p3, tol));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar> explicit DirectionT(const VectorT<OtherScalar, DIM>& vec),\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\nTEST_CASE(\"case1:this is a case for Direction2\", \"[Common][Direction2]\") {\n\tSECTION(\"Angle 2D\") {\n        DirectionT<double, 2> v1(1.0, 3.0);\n        DirectionT<double, 2> v2(-1.0, 2.0);\n        CHECK(v1.Angle(v2) == Approx(acos(M_SQRT1_2)));\n    }}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar> FrameT& Translate(const VectorT<OtherScalar, DIM>& vec),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {\n\treturn result.Location().IsEqual(expected.Location(), tol) &&\n\t\tresult.Direction().IsEqual(expected.Direction(), tol);\n}\nTEST_CASE(\"case1:this is a case for Frame3\",\"[Common][Frame3]\")\n{\n\tSECTION(\"Translate vector 3D\"){\n\t\tPointT<double, 3> p(1.0, -1.0, 0.0);\n\t\tDirectionT<double, 3> dz(1.0, 2.0, 3.0);\n\t\tFrameT<double, 3> f1(p, dz);\n\t\tVectorT<double, 3> v(2.0, 3.0, -1.0);\n\t\tPointT<double, 3> p2(3.0, 2.0, -1.0);\n\t\tFrameT<double, 3> f2(p2, dz);\n\t\tCHECK(IsEqual(f1.Translated(v), f2));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, typename OtherScalar2> [[nodiscard]] FrameT Scaled(const PointT<OtherScalar, DIM>& point, const OtherScalar2& scale),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {\n\treturn result.Location().IsEqual(expected.Location(), tol) &&\n\t\tresult.Direction().IsEqual(expected.Direction(), tol);\n}\nTEST_CASE(\"case1:this is a case for Frame3\",\"[Common][Frame3]\")\n{\n\tSECTION(\"Scale 3D\"){\n\t\tPointT<double, 3> p(1.0, -1.0, 0.0);\n\t\tDirectionT<double, 3> dz(1.0, 2.0, 3.0);\n\t\tFrameT<double, 3> f1(p, dz);\n\t\tPointT<double, 3> p2(1.0, 2.0, 3.0);\n\t\tPointT<double, 3> p3(1.0, -2.5, -1.5);\n\t\tFrameT<double, 3> f2(p3, dz);\n\t\tCHECK(IsEqual(f1.Scaled(p2, 1.5), f2));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, typename OtherScalar2> FrameT& Scale(const PointT<OtherScalar, DIM>& point, const OtherScalar2& scale),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {\n\treturn result.Location().IsEqual(expected.Location(), tol) &&\n\t\tresult.Direction().IsEqual(expected.Direction(), tol);\n}\nTEST_CASE(\"case1:this is a case for Frame3\",\"[Common][Frame3]\")\n{\n\tSECTION(\"Scale 3D\"){\n\t\tPointT<double, 3> p(1.0, -1.0, 0.0);\n\t\tDirectionT<double, 3> dz(1.0, 2.0, 3.0);\n\t\tFrameT<double, 3> f1(p, dz);\n\t\tPointT<double, 3> p2(1.0, 2.0, 3.0);\n\t\tPointT<double, 3> p3(1.0, -2.5, -1.5);\n\t\tFrameT<double, 3> f2(p3, dz);\n\t\tCHECK(IsEqual(f1.Scaled(p2, 1.5), f2));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, typename OtherScalar2, int DIM2 = DIM, typename = typename std::enable_if_t<DIM2 == 3>> [[nodiscard]] FrameT Rotated(const AxisT<OtherScalar, DIM>& a, const OtherScalar2& angle),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {\n\treturn result.Location().IsEqual(expected.Location(), tol) &&\n\t\tresult.Direction().IsEqual(expected.Direction(), tol);\n}\nTEST_CASE(\"case1:this is a case for Frame3\",\"[Common][Frame3]\")\n{\n\tSECTION(\"Rotate 3D\"){\n\t\tPointT<double, 3> p(1.0, -1.0, 0.0);\n\t\tDirectionT<double, 3> dz(1.0, 2.0, 3.0);\n\t\tFrameT<double, 3> f1(p, dz);\n\t\tPointT<double, 3> p2(1.0, 2.0, 3.0);\n\t\tDirectionT<double, 3> dz2(3.0, 2.0, 1.0);\n\t\tAxisT<double, 3> axis(p2, dz2);\n\t\tPointT<double, 3> p3(-3.0 / sqrt(14.0) - 13.0 / 14.0, 9.0 / std::sqrt(14.0) + 10.0 / 14.0, -9.0 / std::sqrt(14.0) + 33.0 / 14.0);\n\t\tDirectionT<double, 3> dz3(4.0 / sqrt(14.0) + 15.0 / 7.0, -8.0 / sqrt(14.0) + 10.0 / 7.0, 4.0 / sqrt(14.0) + 5.0 / 7.0);\n\t\tDirectionT<double, 3> dx3(-7.0 / sqrt(14.0) + 6.0 / 7.0, 6.0 / sqrt(14.0) + 4.0 / 7.0, 9.0 / sqrt(14.0) + 2.0 / 7.0);\n\t\tFrameT<double, 3> f2(p3, dz3, dx3);\n\t\tFrameT<double, 3> f3 = f1.Rotated(axis, M_PI_2);\n\t\tCHECK(IsEqual(f3, f2));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, typename OtherScalar2, int DIM2 = DIM, typename = typename std::enable_if_t<DIM2 == 2>> [[nodiscard]] FrameT Rotated(const PointT<OtherScalar, DIM>& point, const OtherScalar2& angle),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {\n\treturn result.Location().IsEqual(expected.Location(), tol) &&\n\t\tresult.Direction().IsEqual(expected.Direction(), tol);\n}\nTEST_CASE(\"case1:this is a case for Frame3\",\"[Common][Frame3]\")\n{\n\tSECTION(\"Rotate 3D\"){\n\t\tPointT<double, 3> p(1.0, -1.0, 0.0);\n\t\tDirectionT<double, 3> dz(1.0, 2.0, 3.0);\n\t\tFrameT<double, 3> f1(p, dz);\n\t\tPointT<double, 3> p2(1.0, 2.0, 3.0);\n\t\tDirectionT<double, 3> dz2(3.0, 2.0, 1.0);\n\t\tAxisT<double, 3> axis(p2, dz2);\n\t\tPointT<double, 3> p3(-3.0 / sqrt(14.0) - 13.0 / 14.0, 9.0 / std::sqrt(14.0) + 10.0 / 14.0, -9.0 / std::sqrt(14.0) + 33.0 / 14.0);\n\t\tDirectionT<double, 3> dz3(4.0 / sqrt(14.0) + 15.0 / 7.0, -8.0 / sqrt(14.0) + 10.0 / 7.0, 4.0 / sqrt(14.0) + 5.0 / 7.0);\n\t\tDirectionT<double, 3> dx3(-7.0 / sqrt(14.0) + 6.0 / 7.0, 6.0 / sqrt(14.0) + 4.0 / 7.0, 9.0 / sqrt(14.0) + 2.0 / 7.0);\n\t\tFrameT<double, 3> f2(p3, dz3, dx3);\n\t\tFrameT<double, 3> f3 = f1.Rotated(axis, M_PI_2);\n\t\tCHECK(IsEqual(f3, f2));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, typename OtherScalar2, int DIM2 = DIM, typename = typename std::enable_if_t<DIM2 == 3>> FrameT& Rotate(const AxisT<OtherScalar, DIM>& a, const OtherScalar2& angle),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {\n\treturn result.Location().IsEqual(expected.Location(), tol) &&\n\t\tresult.Direction().IsEqual(expected.Direction(), tol);\n}\nTEST_CASE(\"case1:this is a case for Frame3\",\"[Common][Frame3]\")\n{\n\tSECTION(\"Rotate 3D\"){\n\t\tPointT<double, 3> p(1.0, -1.0, 0.0);\n\t\tDirectionT<double, 3> dz(1.0, 2.0, 3.0);\n\t\tFrameT<double, 3> f1(p, dz);\n\t\tPointT<double, 3> p2(1.0, 2.0, 3.0);\n\t\tDirectionT<double, 3> dz2(3.0, 2.0, 1.0);\n\t\tAxisT<double, 3> axis(p2, dz2);\n\t\tPointT<double, 3> p3(-3.0 / sqrt(14.0) - 13.0 / 14.0, 9.0 / std::sqrt(14.0) + 10.0 / 14.0, -9.0 / std::sqrt(14.0) + 33.0 / 14.0);\n\t\tDirectionT<double, 3> dz3(4.0 / sqrt(14.0) + 15.0 / 7.0, -8.0 / sqrt(14.0) + 10.0 / 7.0, 4.0 / sqrt(14.0) + 5.0 / 7.0);\n\t\tDirectionT<double, 3> dx3(-7.0 / sqrt(14.0) + 6.0 / 7.0, 6.0 / sqrt(14.0) + 4.0 / 7.0, 9.0 / sqrt(14.0) + 2.0 / 7.0);\n\t\tFrameT<double, 3> f2(p3, dz3, dx3);\n\t\tFrameT<double, 3> f3 = f1.Rotated(axis, M_PI_2);\n\t\tCHECK(IsEqual(f3, f2));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, int DIM2 = DIM, std::enable_if_t<DIM2 == 3, int> = 0> [[nodiscard]] FrameT Mirrored(const FrameT<OtherScalar, DIM>& frame),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {\n\treturn result.Location().IsEqual(expected.Location(), tol) &&\n\t\tresult.Direction().IsEqual(expected.Direction(), tol);\n}\nTEST_CASE(\"case1:this is a case for Frame3\",\"[Common][Frame3]\")\n{\n\tSECTION(\"XDirection\"){\n\t\tPointT<double, 3> p(1.0, 2.0, 3.0);\n\t\tDirectionT<double, 3> dz(1.0, 2.0, 3.0);\n\t\tDirectionT<double, 3> dx(0.0, 3.0, -2.0);\n\t\tFrameT<double, 3> f1(p, dz);\n\t\tCHECK(f1.XDirection().IsEqual(dx, tol));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar> [[nodiscard]] FrameT Mirrored(const AxisT<OtherScalar, DIM>& a),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {\n\treturn result.Location().IsEqual(expected.Location(), tol) &&\n\t\tresult.Direction().IsEqual(expected.Direction(), tol);\n}\nTEST_CASE(\"case1:this is a case for Frame3\",\"[Common][Frame3]\")\n{\n\tSECTION(\"Mirror axis 3D\"){\n\t\tPointT<double, 3> p(1.0, -1.0, 0.0);\n\t\tDirectionT<double, 3> dz(1.0, 2.0, 3.0);\n\t\tFrameT<double, 3> f1(p, dz);\n\t\tPointT<double, 3> p2(1.0, 2.0, -2.0);\n\t\tDirectionT<double, 3> d(1.0, 1.0, 1.0);\n\t\tAxisT<double, 3> axis(p2, d);\n\t\tPointT<double, 3> p3(1.0 / 3.0, 13.0 / 3.0, -14.0 / 3.0);\n\t\tDirectionT<double, 3> dz2(3.0, 2.0, 1.0);\n\t\tDirectionT<double, 3> dx2(2.0, -7.0, 8.0);\n\t\tFrameT<double, 3> f2(p3, dz2, dx2);\n\t\tFrameT<double, 3> f3 = f1.Mirrored(axis);\n\t\tCHECK(IsEqual(f2, f3));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar> [[nodiscard]] FrameT Mirrored(const PointT<OtherScalar, DIM>& point),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {\n\treturn result.Location().IsEqual(expected.Location(), tol) &&\n\t\tresult.Direction().IsEqual(expected.Direction(), tol);\n}\nTEST_CASE(\"case1:this is a case for Frame3\",\"[Common][Frame3]\")\n{\n\tSECTION(\"Mirror point 3D\"){\n\t\tPointT<double, 3> p(1.0, -1.0, 0.0);\n\t\tPointT<double, 3> p2(1.0, 2.0, -2.0);\n\t\tPointT<double, 3> p3(1.0, 5.0, -4.0);\n\t\tDirectionT<double, 3> dz(1.0, 2.0, 3.0);\n\t\tFrameT<double, 3> f1(p, dz);\n\t\tDirectionT<double, 3> dz2(-1.0, -2.0, -3.0);\n\t\tDirectionT<double, 3> dx2(0.0, -3.0, 2.0);\n\t\tFrameT<double, 3> f2(p3, dz2, dx2);\n\t\tFrameT<double, 3> f3 = f1.Mirrored(p2);\n\t\tCHECK(f3.Location().IsEqual(p3, tol));\n\t\tCHECK(f3.Direction().IsEqual(dz2, tol));\n\t\tCHECK(f3.XDirection().IsEqual(dx2, tol));\n\t\tCHECK(f3.YDirection().IsEqual(dx2.Cross(dz2), tol));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, int DIM2 = DIM, std::enable_if_t<DIM2 == 3, int> = 0> FrameT& Mirror(const FrameT<OtherScalar, DIM>& frame),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {\n\treturn result.Location().IsEqual(expected.Location(), tol) &&\n\t\tresult.Direction().IsEqual(expected.Direction(), tol);\n}\nTEST_CASE(\"case1:this is a case for Frame3\",\"[Common][Frame3]\")\n{\n\tSECTION(\"Mirror axis 3D\"){\n\t\tPointT<double, 3> p(1.0, -1.0, 0.0);\n\t\tDirectionT<double, 3> dz(1.0, 2.0, 3.0);\n\t\tFrameT<double, 3> f1(p, dz);\n\t\tPointT<double, 3> p2(1.0, 2.0, -2.0);\n\t\tDirectionT<double, 3> d(1.0, 1.0, 1.0);\n\t\tAxisT<double, 3> axis(p2, d);\n\t\tPointT<double, 3> p3(1.0 / 3.0, 13.0 / 3.0, -14.0 / 3.0);\n\t\tDirectionT<double, 3> dz2(3.0, 2.0, 1.0);\n\t\tDirectionT<double, 3> dx2(2.0, -7.0, 8.0);\n\t\tFrameT<double, 3> f2(p3, dz2, dx2);\n\t\tFrameT<double, 3> f3 = f1.Mirrored(axis);\n\t\tCHECK(IsEqual(f2, f3));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar> FrameT& Mirror(const AxisT<OtherScalar, DIM>& a),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {\n\treturn result.Location().IsEqual(expected.Location(), tol) &&\n\t\tresult.Direction().IsEqual(expected.Direction(), tol);\n}\nTEST_CASE(\"case1:this is a case for Frame3\",\"[Common][Frame3]\")\n{\n\tSECTION(\"Mirror axis 3D\"){\n\t\tPointT<double, 3> p(1.0, -1.0, 0.0);\n\t\tDirectionT<double, 3> dz(1.0, 2.0, 3.0);\n\t\tFrameT<double, 3> f1(p, dz);\n\t\tPointT<double, 3> p2(1.0, 2.0, -2.0);\n\t\tDirectionT<double, 3> d(1.0, 1.0, 1.0);\n\t\tAxisT<double, 3> axis(p2, d);\n\t\tPointT<double, 3> p3(1.0 / 3.0, 13.0 / 3.0, -14.0 / 3.0);\n\t\tDirectionT<double, 3> dz2(3.0, 2.0, 1.0);\n\t\tDirectionT<double, 3> dx2(2.0, -7.0, 8.0);\n\t\tFrameT<double, 3> f2(p3, dz2, dx2);\n\t\tFrameT<double, 3> f3 = f1.Mirrored(axis);\n\t\tCHECK(IsEqual(f2, f3));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar> FrameT& Mirror(const PointT<OtherScalar, DIM>& point),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {\n\treturn result.Location().IsEqual(expected.Location(), tol) &&\n\t\tresult.Direction().IsEqual(expected.Direction(), tol);\n}\nTEST_CASE(\"case1:this is a case for Frame3\",\"[Common][Frame3]\")\n{\n\tSECTION(\"Mirror point 3D\"){\n\t\tPointT<double, 3> p(1.0, -1.0, 0.0);\n\t\tPointT<double, 3> p2(1.0, 2.0, -2.0);\n\t\tPointT<double, 3> p3(1.0, 5.0, -4.0);\n\t\tDirectionT<double, 3> dz(1.0, 2.0, 3.0);\n\t\tFrameT<double, 3> f1(p, dz);\n\t\tDirectionT<double, 3> dz2(-1.0, -2.0, -3.0);\n\t\tDirectionT<double, 3> dx2(0.0, -3.0, 2.0);\n\t\tFrameT<double, 3> f2(p3, dz2, dx2);\n\t\tFrameT<double, 3> f3 = f1.Mirrored(p2);\n\t\tCHECK(f3.Location().IsEqual(p3, tol));\n\t\tCHECK(f3.Direction().IsEqual(dz2, tol));\n\t\tCHECK(f3.XDirection().IsEqual(dx2, tol));\n\t\tCHECK(f3.YDirection().IsEqual(dx2.Cross(dz2), tol));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, typename OtherScalar2, typename OtherScalar3, int DIM2 = DIM, typename = typename std::enable_if_t<DIM2 == 3>> [[nodiscard]] bool IsCoplanar(const AxisT<OtherScalar, DIM>& a, const OtherScalar2& distol, const OtherScalar3& angtol),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {\n\treturn result.Location().IsEqual(expected.Location(), tol) &&\n\t\tresult.Direction().IsEqual(expected.Direction(), tol);\n}\nTEST_CASE(\"case1:this is a case for Frame3\",\"[Common][Frame3]\")\n{\n\tSECTION(\"IsCoplanar frame\"){\n\t\tPointT<double, 3> p(1.0, -1.0, 0.0);\n\t\tPointT<double, 3> p2(1.0, 2.0, -2.0);\n\t\tPointT<double, 3> p3(1.0, 2.0, -1.0);\n\t\tDirectionT<double, 3> dz(1.0, 2.0, 3.0);\n\t\tDirectionT<double, 3> dz2(1.0, 2.0, 3.1);\n\t\tFrameT<double, 3> f1(p, dz);\n\t\tFrameT<double, 3> f2(p2, dz);\n\t\tFrameT<double, 3> f3(p3, dz);\n\t\tFrameT<double, 3> f4(p2, dz2);\n\t\tCHECK(f1.IsCoplanar(f2, 1e-6, 1e-6) == true);\n\t\tCHECK(f1.IsCoplanar(f3, 1e-6, 1e-6) == false);\n\t\tCHECK(f1.IsCoplanar(f4, 1e-6, 1e-6) == false);\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, typename OtherScalar2, typename OtherScalar3, int DIM2 = DIM, typename = typename std::enable_if_t<DIM2 == 3>> [[nodiscard]] bool IsCoplanar(const FrameT<OtherScalar, DIM>& other, const OtherScalar2& distol, const OtherScalar3& angtol),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {\n\treturn result.Location().IsEqual(expected.Location(), tol) &&\n\t\tresult.Direction().IsEqual(expected.Direction(), tol);\n}\nTEST_CASE(\"case1:this is a case for Frame3\",\"[Common][Frame3]\")\n{\n\tSECTION(\"IsCoplanar frame\"){\n\t\tPointT<double, 3> p(1.0, -1.0, 0.0);\n\t\tPointT<double, 3> p2(1.0, 2.0, -2.0);\n\t\tPointT<double, 3> p3(1.0, 2.0, -1.0);\n\t\tDirectionT<double, 3> dz(1.0, 2.0, 3.0);\n\t\tDirectionT<double, 3> dz2(1.0, 2.0, 3.1);\n\t\tFrameT<double, 3> f1(p, dz);\n\t\tFrameT<double, 3> f2(p2, dz);\n\t\tFrameT<double, 3> f3(p3, dz);\n\t\tFrameT<double, 3> f4(p2, dz2);\n\t\tCHECK(f1.IsCoplanar(f2, 1e-6, 1e-6) == true);\n\t\tCHECK(f1.IsCoplanar(f3, 1e-6, 1e-6) == false);\n\t\tCHECK(f1.IsCoplanar(f4, 1e-6, 1e-6) == false);\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<int DIM2 = DIM, typename = typename std::enable_if_t<DIM2 >= 1>> [[nodiscard]] const DirectionT<Scalar, DIM>& XDirection(),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {\n\treturn result.Location().IsEqual(expected.Location(), tol) &&\n\t\tresult.Direction().IsEqual(expected.Direction(), tol);\n}\nTEST_CASE(\"case1:this is a case for Frame3\",\"[Common][Frame3]\")\n{\n\tSECTION(\"XDirection\"){\n\t\tPointT<double, 3> p(1.0, 2.0, 3.0);\n\t\tDirectionT<double, 3> dz(1.0, 2.0, 3.0);\n\t\tDirectionT<double, 3> dx(0.0, 3.0, -2.0);\n\t\tFrameT<double, 3> f1(p, dz);\n\t\tCHECK(f1.XDirection().IsEqual(dx, tol));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<int DIM2 = DIM, typename = typename std::enable_if_t<DIM2 == 3>> [[nodiscard]] const DirectionT<Scalar, DIM>& Direction(),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {\n\treturn result.Location().IsEqual(expected.Location(), tol) &&\n\t\tresult.Direction().IsEqual(expected.Direction(), tol);\n}\nTEST_CASE(\"case1:this is a case for Frame3\",\"[Common][Frame3]\")\n{\n\tSECTION(\"Direction\"){\n\t\tPointT<double, 3> p(1.0, 2.0, 3.0);\n\t\tDirectionT<double, 3> dz(1.0, 2.0, 3.0);\n\t\tFrameT<double, 3> f1(p, dz);\n\t\tCHECK(f1.Direction().IsEqual(dz, tol));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<int DIM2 = DIM, typename = typename std::enable_if_t<DIM2 == 3>> [[nodiscard]] AxisT<Scalar, DIM> Axis(),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {\n\treturn result.Location().IsEqual(expected.Location(), tol) &&\n\t\tresult.Direction().IsEqual(expected.Direction(), tol);\n}\nTEST_CASE(\"case1:this is a case for Frame3\",\"[Common][Frame3]\")\n{\n\tSECTION(\"Axis\"){\n\t\tPointT<double, 3> p(1.0, 2.0, 3.0);\n\t\tDirectionT<double, 3> dz(1.0, 2.0, 3.0);\n\t\tFrameT<double, 3> f1(p, dz);\n\t\tCHECK(IsEqual(f1.Axis(), AxisT<double, 3>(p, dz)));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, int DIM2 = DIM, std::enable_if_t<DIM2 == 3, int> = 0> void SetYDirection(const DirectionT<OtherScalar, DIM>& y),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {\n\treturn result.Location().IsEqual(expected.Location(), tol) &&\n\t\tresult.Direction().IsEqual(expected.Direction(), tol);\n}\nTEST_CASE(\"case1:this is a case for Frame3\",\"[Common][Frame3]\")\n{\n\tSECTION(\"SetYDirection 3D\"){\n\t\tPointT<double, 3> p(0.0, 1.0, 2.0);\n\t\tDirectionT<double, 3> dz(1.0, 2.0, 3.0);\n\t\tDirectionT<double, 3> dx(-1.0, -1.0, 1.0);\n\t\tDirectionT<double, 3> dy2(-13.0, 2.0, 3.0);\n\t\tFrameT<double, 3> f1(p, dz);\n\t\tFrameT<double, 3> f2(p, dz, dx);\n\t\tf2.SetYDirection(dy2);\n\t\tCHECK(IsEqual(f1, f2));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, int DIM2 = DIM, std::enable_if_t<DIM2 == 3, int> = 0> void SetXDirection(const DirectionT<OtherScalar, DIM>& x),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {\n\treturn result.Location().IsEqual(expected.Location(), tol) &&\n\t\tresult.Direction().IsEqual(expected.Direction(), tol);\n}\nTEST_CASE(\"case1:this is a case for Frame3\",\"[Common][Frame3]\")\n{\n\tSECTION(\"SetXDirection 3D\"){\n\t\tPointT<double, 3> p(0.0, 1.0, 2.0);\n\t\tDirectionT<double, 3> dz(1.0, 2.0, 3.0);\n\t\tDirectionT<double, 3> dx(-1.0, -1.0, 1.0);\n\t\tDirectionT<double, 3> dx2(0.0, 3.0, -2.0);\n\t\tFrameT<double, 3> f1(p, dz);\n\t\tFrameT<double, 3> f2(p, dz, dx);\n\t\tf2.SetXDirection(dx2);\n\t\tCHECK(IsEqual(f1, f2));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, int DIM2 = DIM, typename = typename std::enable_if_t<DIM2 == 3>> void SetDirection(const DirectionT<OtherScalar, DIM>& dir),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {\n\treturn result.Location().IsEqual(expected.Location(), tol) &&\n\t\tresult.Direction().IsEqual(expected.Direction(), tol);\n}\nTEST_CASE(\"case1:this is a case for Frame3\",\"[Common][Frame3]\")\n{\n\tSECTION(\"SetDirection 3D\"){\n\t\tPointT<double, 3> p(0.0, 1.0, 2.0);\n\t\tDirectionT<double, 3> dz(1.0, 2.0, 3.0);\n\t\tDirectionT<double, 3> dz2(2.3, 2.6, 3.3);\n\t\tDirectionT<double, 3> dx(0.0, 3.0, -2.0);\n\t\tFrameT<double, 3> f1(p, dz);\n\t\tFrameT<double, 3> f2(p, dz2);\n\t\tf2.SetDirection(dz);\n\t\tf2.SetXDirection(dx);\n\t\tCHECK(IsEqual(f1, f2));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, typename OtherScalar2, int DIM2 = DIM, std::enable_if_t<DIM2 == 3, int> = 0> FrameT(const PointT<OtherScalar, DIM>& point, const DirectionT<OtherScalar2, DIM>& dir),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {\n\treturn result.Location().IsEqual(expected.Location(), tol) &&\n\t\tresult.Direction().IsEqual(expected.Direction(), tol);\n}\nTEST_CASE(\"case1:this is a case for Frame3\",\"[Common][Frame3]\")\n{\n\tSECTION(\"Default constructor\"){\n\t\tFrameT<double, 3> f1;\n\t\tPointT<double, 3> p(0.0, 0.0, 0.0);\n\t\tDirectionT<double, 3> dz(0.0, 0.0, 1.0);\n\t\tDirectionT<double, 3> dx(1.0, 0.0, 0.0);\n\t\tFrameT<double, 3> f2(p, dz, dx);\n\t\tCHECK(IsEqual(f1, f2));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, typename OtherScalar2, typename OtherScalar3, int DIM2 = DIM, std::enable_if_t<DIM2 == 3, int> = 0> FrameT(const PointT<OtherScalar, DIM>& point, const DirectionT<OtherScalar2, DIM>& normal, const DirectionT<OtherScalar3, DIM>& x),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {\n\treturn result.Location().IsEqual(expected.Location(), tol) &&\n\t\tresult.Direction().IsEqual(expected.Direction(), tol);\n}\nTEST_CASE(\"case1:this is a case for Frame3\",\"[Common][Frame3]\")\n{\n\tSECTION(\"Default constructor\"){\n\t\tFrameT<double, 3> f1;\n\t\tPointT<double, 3> p(0.0, 0.0, 0.0);\n\t\tDirectionT<double, 3> dz(0.0, 0.0, 1.0);\n\t\tDirectionT<double, 3> dx(1.0, 0.0, 0.0);\n\t\tFrameT<double, 3> f2(p, dz, dx);\n\t\tCHECK(IsEqual(f1, f2));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, int DIM2 = DIM, std::enable_if_t<DIM2 == 2, int> = 0> explicit FrameT(const AxisT<OtherScalar, DIM>& axis, bool isright = true),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {\n\treturn result.Location().IsEqual(expected.Location(), tol) &&\n\t\tresult.Direction().IsEqual(expected.Direction(), tol);\n}\nTEST_CASE(\"case1:this is a case for Frame3\",\"[Common][Frame3]\")\n{\n\tSECTION(\"Location\"){\n\t\tPointT<double, 3> p(1.0, 2.0, 3.0);\n\t\tDirectionT<double, 3> dz(1.0, 2.0, 3.0);\n\t\tFrameT<double, 3> f1(p, dz);\n\t\tCHECK(f1.Location().IsEqual(p, tol));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, typename OtherScalar2, int DIM2 = DIM, std::enable_if_t<DIM2 == 2, int> = 0> FrameT(const PointT<OtherScalar, DIM>& point, const DirectionT<OtherScalar2, DIM>& xdir, bool isright = true),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {\n\treturn result.Location().IsEqual(expected.Location(), tol) &&\n\t\tresult.Direction().IsEqual(expected.Direction(), tol);\n}\nTEST_CASE(\"case1:this is a case for Frame3\",\"[Common][Frame3]\")\n{\n\tSECTION(\"IsCoplanar frame\"){\n\t\tPointT<double, 3> p(1.0, -1.0, 0.0);\n\t\tPointT<double, 3> p2(1.0, 2.0, -2.0);\n\t\tPointT<double, 3> p3(1.0, 2.0, -1.0);\n\t\tDirectionT<double, 3> dz(1.0, 2.0, 3.0);\n\t\tDirectionT<double, 3> dz2(1.0, 2.0, 3.1);\n\t\tFrameT<double, 3> f1(p, dz);\n\t\tFrameT<double, 3> f2(p2, dz);\n\t\tFrameT<double, 3> f3(p3, dz);\n\t\tFrameT<double, 3> f4(p2, dz2);\n\t\tCHECK(f1.IsCoplanar(f2, 1e-6, 1e-6) == true);\n\t\tCHECK(f1.IsCoplanar(f3, 1e-6, 1e-6) == false);\n\t\tCHECK(f1.IsCoplanar(f4, 1e-6, 1e-6) == false);\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, typename OtherScalar2, typename OtherScalar3, int DIM2 = DIM, std::enable_if_t<DIM2 == 2, int> = 0> FrameT(const PointT<OtherScalar, DIM>& point, const DirectionT<OtherScalar2, DIM>& xdir, const DirectionT<OtherScalar3, DIM>& ydir),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {\n\treturn result.Location().IsEqual(expected.Location(), tol) &&\n\t\tresult.Direction().IsEqual(expected.Direction(), tol);\n}\nTEST_CASE(\"case1:this is a case for Frame3\",\"[Common][Frame3]\")\n{\n\tSECTION(\"YDirection\"){\n\t\tPointT<double, 3> p(1.0, 2.0, 3.0);\n\t\tDirectionT<double, 3> dz(1.0, 2.0, 3.0);\n\t\tDirectionT<double, 3> dy(-13.0, 2.0, 3.0);\n\t\tFrameT<double, 3> f1(p, dz);\n\t\tCHECK(f1.YDirection().IsEqual(dy, tol));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "FrameT()\t @details The default frame is the standard orthogonal frame\n\t @brief Default constructor\n,\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {\n\treturn result.Location().IsEqual(expected.Location(), tol) &&\n\t\tresult.Direction().IsEqual(expected.Direction(), tol);\n}\nTEST_CASE(\"case1:this is a case for Frame3\",\"[Common][Frame3]\")\n{\n\tSECTION(\"SetXDirection 3D\"){\n\t\tPointT<double, 3> p(0.0, 1.0, 2.0);\n\t\tDirectionT<double, 3> dz(1.0, 2.0, 3.0);\n\t\tDirectionT<double, 3> dx(-1.0, -1.0, 1.0);\n\t\tDirectionT<double, 3> dx2(0.0, 3.0, -2.0);\n\t\tFrameT<double, 3> f1(p, dz);\n\t\tFrameT<double, 3> f2(p, dz, dx);\n\t\tf2.SetXDirection(dx2);\n\t\tCHECK(IsEqual(f1, f2));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] const PointT<Scalar, DIM>& Location()\t @return The location\n\t @brief Get the location\n,\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {\n\treturn result.Location().IsEqual(expected.Location(), tol) &&\n\t\tresult.Direction().IsEqual(expected.Direction(), tol);\n}\nTEST_CASE(\"case1:this is a case for Frame3\",\"[Common][Frame3]\")\n{\n\tSECTION(\"Location\"){\n\t\tPointT<double, 3> p(1.0, 2.0, 3.0);\n\t\tDirectionT<double, 3> dz(1.0, 2.0, 3.0);\n\t\tFrameT<double, 3> f1(p, dz);\n\t\tCHECK(f1.Location().IsEqual(p, tol));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API BoolBRepFuse(const TopoShape& s1, const TopoShape& s2)\t @param s2 The tool shape\n\t @param s1 The argument shape\n\t @brief Compute the fuse of two shapes\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <boolean/BoolBRepFuse.hpp>\n#include <boolean/BoolBRepCut.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"bug1: BoolBRepFuse \", \"[boolean][BoolBRepFuse][fixbug]\")\n{\n\tTopoShape shape1, shape2;\n\tOCCTIO::OCCTTool::Read(shape1, INPUT_PATH_PREFIX\"boolean/part.brep\");\n\tOCCTIO::OCCTTool::Read(shape2, INPUT_PATH_PREFIX\"boolean/box.brep\");\n\tTopoShape result = BoolBRepFuse(shape1, shape2);\n\tCHECK(OCCTIO::OCCTTool::Write(result, OUTPUT_PATH_PREFIX\"testbug-view-556.brep\"));\n\tIndexSet<TopoShape> shapeFace, shapeEdge, shapeVertex ,shapeSolid;\n\tCHECK( GetTopoToolCount(result, AMCAX::ShapeType::Solid, shapeSolid)==1 );\n}\t\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API BoolBRepFuse()\t @details Only set the type of boolean operation to fuse\n\t @brief Default constructor\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <boolean/BoolBRepFuse.hpp>\n#include <boolean/BoolBRepCut.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"bug1: BoolBRepFuse \", \"[boolean][BoolBRepFuse][fixbug]\")\n{\n\tTopoShape shape1, shape2;\n\tOCCTIO::OCCTTool::Read(shape1, INPUT_PATH_PREFIX\"boolean/part.brep\");\n\tOCCTIO::OCCTTool::Read(shape2, INPUT_PATH_PREFIX\"boolean/box.brep\");\n\tTopoShape result = BoolBRepFuse(shape1, shape2);\n\tCHECK(OCCTIO::OCCTTool::Write(result, OUTPUT_PATH_PREFIX\"testbug-view-556.brep\"));\n\tIndexSet<TopoShape> shapeFace, shapeEdge, shapeVertex ,shapeSolid;\n\tCHECK( GetTopoToolCount(result, AMCAX::ShapeType::Solid, shapeSolid)==1 );\n}\t\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API explicit BoolBRepDefeaturing(const TopoShape& shape)\t @param shape The shape that require remove feature\n\t @brief Construct from a shape.\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <modeling/MakeBox.hpp>\n#include <modeling/MakeCylinder.hpp>\n#include <boolean/BoolBRepCut.hpp>\n#include <topomesh/BRepMeshIncrementalMesh.hpp>\n#include <io/OBJTool.hpp>\n#include <topology/TopoFace.hpp>\n#include <geometry/Geom3Surface.hpp>\n#include <topology/TopoTool.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <boolean/BoolBRepDefeaturing.hpp>\n#include <topology/TopoEdge.hpp>\n#include <common/IndexSet.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"case1: test BoolBRepDefeaturing Algorithm\", \"[boolean][BRepDefeaturing]\")\n{\n\tOUTPUT_DIRECTORY(Boolean, BRepDefeaturing);\n\tTopoShape box = MakeBox(Point3(-5.0, -5.0, 0.0), Point3(5.0, 5.0, 3.0));\n\tTopoShape cyl = MakeCylinder(Frame3(Point3(0.0, 0.0, 0.0), Direction3(0.0, 0.0, 1.0)), 3.0, 5.0);\n\tTopoShape shape = BoolBRepCut(box, cyl);\n\tOCCTIO::OCCTTool::Write(shape, outdir + \"testResultTemp.brep\");\n\tBRepMeshIncrementalMesh meshT(shape, 0.01, true);\n\tOBJTool::WriteShape(shape, outdir + \"testResultTemp.obj\");\n\tIndexSet<TopoShape> shapeFace, shapeEdge, shapeVertex;\n\tCHECK(GetTopoToolCount(shape, ShapeType::Face, shapeFace) == 7);\n\tCHECK(GetTopoToolCount(shape, ShapeType::Edge, shapeEdge) == 15);\n\tCHECK(GetTopoToolCount(shape, ShapeType::Vertex, shapeVertex) == 10);\n\tTopoFace cy;\n\tstd::list<TopoShape> faceToRemove;\n\tfor (TopoExplorer expF(shape, ShapeType::Face); expF.More(); expF.Next())\n\t{\n\t\tTopoFace f = static_cast<const TopoFace&>(expF.Current());\n\t\tstd::shared_ptr<Geom3Surface> surface = TopoTool::Surface(f);\n\t\tif (surface->Type() == SurfaceType::Cylinder)\n\t\t{\n\t\t\tcy = f;\n\t\t\tOCCTIO::OCCTTool::Write(f, outdir + \"RemoveFace.brep\");\n\t\t\tfaceToRemove.push_back(f);\n\t\t}\n\t}\n\tBoolBRepDefeaturing defeature(shape);\n\tdefeature.AddFaceToRemove(faceToRemove);\n\tdefeature.Build();\n\tTopoShape newShape = defeature.Shape();\n\tPoint3 p(-3.0, 0.0, 1.0);\n\tdouble tol = -1.0;\n\tbool isIn = BRepClassificationTools::IsPointInFace(cy, p, tol);\n\tCHECK(isIn == true);\n\tfor (TopoExplorer expF(newShape, ShapeType::Face); expF.More(); expF.Next())\n\t{\n\t\tTopoFace newFace = static_cast<const TopoFace&>(expF.Current());\n\t\tbool isIn1 = BRepClassificationTools::IsPointInFace(newFace, p, tol);\n\t\tCHECK(isIn1 == false);\n\t}\n\tfor (TopoExplorer expF1(newShape, ShapeType::Face); expF1.More(); expF1.Next())\n\t{\n\t\tbool result;\n\t\tTopoFace f1 = static_cast<const TopoFace&>(expF1.Current());\n\t\tstd::shared_ptr<Geom3Surface> surface1 = TopoTool::Surface(f1);\n\t\tif (surface1->Type() == SurfaceType::Cylinder)\n\t\t{\n\t\t\tresult = false;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tresult = true;\n\t\t}\n\t\tCHECK(result == true);\n\t}\n\tAMCAX::GlobalProperty props1, props2, props3;\n\tIndexSet<TopoShape> newshapeFace, newshapeEdge, newshapeVertex;\n\tCHECK(newShape.Type() == ShapeType::Compound);\n\tCHECK(GetTopoToolCount(newShape, ShapeType::Face, newshapeFace) == 6);\n\tCHECK(GetTopoToolCount(newShape, ShapeType::Edge, newshapeEdge) == 12);\n\tCHECK(GetTopoToolCount(newShape, ShapeType::Vertex, newshapeVertex) == 8);\n\tCHECK(GetLinearProperties(newShape,props1,true,false)== Approx(10 * 8 + 3 * 4));\n\tCHECK(GetSurfaceProperties(newShape, props2, true, false) == Approx(2 * (10 * 10) + 4*(10 * 3)));\n\tCHECK(GetVolumeProperties(newShape, props3, true, false) == Approx(10*10*3));\n\tPoint3 point = props3.CenterOfMass();\n\tCHECK(point.X() == Approx(0.0).margin(1e-12));\n\tCHECK(point.Y() == Approx(0.0).margin(1e-12));\n\tCHECK(point.Z() == Approx(1.5).margin(1e-12));\n\tstd::cout << \"defeature ok \" << std::endl;\n\tOCCTIO::OCCTTool::Write(newShape, outdir + \"testResult.brep\");\n\tBRepMeshIncrementalMesh meshR(newShape, 0.01, true);\n\tOBJTool::WriteShape(newShape, outdir + \"testResult.obj\");\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API BoolBRepDefeaturing()\t @brief Default constructor\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <modeling/MakeBox.hpp>\n#include <modeling/MakeCylinder.hpp>\n#include <boolean/BoolBRepCut.hpp>\n#include <topomesh/BRepMeshIncrementalMesh.hpp>\n#include <io/OBJTool.hpp>\n#include <topology/TopoFace.hpp>\n#include <geometry/Geom3Surface.hpp>\n#include <topology/TopoTool.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <boolean/BoolBRepDefeaturing.hpp>\n#include <topology/TopoEdge.hpp>\n#include <common/IndexSet.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"bug1: BoolBRepDefeaturing \", \"[boolean][BRepDefeaturing]\")\n{\n\tTopoShape box = MakeBox(Point3(-5.0, -5.0, 0.0), Point3(5.0, 5.0, 3.0));\n\tTopoShape cyl = MakeCylinder(Frame3(Point3(0.0, 0.0, 0.0), Direction3(0.0, 0.0, 1.0)), 3.0, 5.0);\n\tTopoShape shape = BoolBRepCut(box, cyl);\n\tAMCAX::GlobalProperty prop1, prop2, prop3, prop4, prop5, prop6;\n\tBRepGlobalProperty::LinearProperties(box, prop1, true, true);\n\tBRepGlobalProperty::LinearProperties(box, prop2, true, false);\n\tdouble result1 = prop1.Mass();\n\tdouble result2 = prop2.Mass();\n\tCHECK(result1 == Approx(10 * 8 + 3 * 4));\n\tCHECK(result2 == Approx(10 * 8 + 3 * 4));\n\tBRepGlobalProperty::SurfaceProperties(box, prop3, true, true);\n\tBRepGlobalProperty::SurfaceProperties(box, prop4, true, false);\n\tdouble result3 = prop3.Mass();\n\tdouble result4 = prop4.Mass();\n\tCHECK(result3 == Approx(2 * (10 * 10) + 4 * (10 * 3)));\n\tCHECK(result4 == Approx(2 * (10 * 10) + 4 * (10 * 3)));\n\tBRepGlobalProperty::VolumeProperties(box, prop5, true, true);\n\tBRepGlobalProperty::VolumeProperties(box, prop6, true, false);\n\tdouble result5 = prop5.Mass();\n\tdouble result6 = prop6.Mass();\n\tCHECK(result5 == Approx(10 * 10 * 3));\n\tCHECK(result6 == Approx(10 * 10 * 3));\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API BoolBRepCut(const TopoShape& s1, const TopoShape& s2, bool isForward = true)\t @param isForward Cut s1 by s2 if true, and cut s2 by s1 if false\n\t @param s2 The tool shape\n\t @param s1 The argument shape\n\t @brief Compute the cut operation of two shapes\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <boolean/BoolBRepCut.hpp>\n#include <modeling/MakeTorus.hpp>\n#include <modeling/MakeSphere.hpp>\n#include <modeling/MakeCone.hpp>\n#include <topology/TopoExplorer.hpp>\n#include <topology/TopoFace.hpp>\n#include <hatch/BRepClassificationTools.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"bug1: in Debug mode: BoolBuilder  \", \"[boolean][BoolBRepCut][P1][fixbug]\") {\n\tTopoShape torus = MakeTorus(Frame3(Point3(0.0, 0.0, 2.0), Direction3(1.0, 0.0, 0.0)), 4.0, 2.0);\n\tTopoShape sphere = MakeSphere(4.0);\n\tTopoShape result = BoolBRepCut(sphere, torus);\n\tAMCAX::GlobalProperty prop;\n\tAMCAX::BRepGlobalProperty::VolumeProperties(result, prop);\n\tCHECK(prop.Mass() == Approx(153.229)); \n\tbool isWriteSuccess = AMCAX::OCCTIO::OCCTTool::Write(result, OUTPUT_PATH_PREFIX\"BoolBRepCut_bug72.brep\", false);\n\tCHECK(isWriteSuccess == true);\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API BoolBRepCut()\t @details Only set the type of boolean operation to cut\n\t @brief Default constructor\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <boolean/BoolBRepCut.hpp>\n#include <modeling/MakeTorus.hpp>\n#include <modeling/MakeSphere.hpp>\n#include <modeling/MakeCone.hpp>\n#include <topology/TopoExplorer.hpp>\n#include <topology/TopoFace.hpp>\n#include <hatch/BRepClassificationTools.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"bug1: in Debug mode: BoolBuilder  \", \"[boolean][BoolBRepCut][P1][fixbug]\") {\n\tTopoShape torus = MakeTorus(Frame3(Point3(0.0, 0.0, 2.0), Direction3(1.0, 0.0, 0.0)), 4.0, 2.0);\n\tTopoShape sphere = MakeSphere(4.0);\n\tTopoShape result = BoolBRepCut(sphere, torus);\n\tAMCAX::GlobalProperty prop;\n\tAMCAX::BRepGlobalProperty::VolumeProperties(result, prop);\n\tCHECK(prop.Mass() == Approx(153.229)); \n\tbool isWriteSuccess = AMCAX::OCCTIO::OCCTTool::Write(result, OUTPUT_PATH_PREFIX\"BoolBRepCut_bug72.brep\", false);\n\tCHECK(isWriteSuccess == true);\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, typename OtherScalar2> [[nodiscard]] FrameT Translated(const PointT<OtherScalar, DIM>& p1, const PointT<OtherScalar2, DIM>& p2),\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\nTEST_CASE(\"case1:this is a case for Frame2\", \"[Common][Frame2]\") {\n\tSECTION(\"Translate vector 2D\") {\n\t\tPointT<double, 2> p(1.0, 2.0);\n\t\tDirectionT<double, 2> d(1.0, 3.0);\n\t\tFrameT<double, 2> f1(p, d);\n\t\tVectorT<double, 2> v(2.0, 3.0);\n\t\tPointT<double, 2> p2(3.0, 5.0);\n\t\tFrameT<double, 2> f2(p2, d);\n\t\tCHECK(IsEqual(f1.Translated(v), f2));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar> [[nodiscard]] FrameT Translated(const VectorT<OtherScalar, DIM>& vec),\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\nTEST_CASE(\"case1:this is a case for Frame2\", \"[Common][Frame2]\") {\n\tSECTION(\"Translate vector 2D\") {\n\t\tPointT<double, 2> p(1.0, 2.0);\n\t\tDirectionT<double, 2> d(1.0, 3.0);\n\t\tFrameT<double, 2> f1(p, d);\n\t\tVectorT<double, 2> v(2.0, 3.0);\n\t\tPointT<double, 2> p2(3.0, 5.0);\n\t\tFrameT<double, 2> f2(p2, d);\n\t\tCHECK(IsEqual(f1.Translated(v), f2));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, typename OtherScalar2> [[nodiscard]] FrameT Scaled(const PointT<OtherScalar, DIM>& point, const OtherScalar2& scale),\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\nTEST_CASE(\"case1:this is a case for Frame2\", \"[Common][Frame2]\") {\n\tSECTION(\"Scale 2D\") {\n\t\tPointT<double, 2> p(1.0, 2.0);\n\t\tDirectionT<double, 2> d(1.0, 3.0);\n\t\tFrameT<double, 2> f1(p, d);\n\t\tPointT<double, 2> p2(2.0, 3.0);\n\t\tPointT<double, 2> p3(0.5, 1.5);\n\t\tFrameT<double, 2> f2(p3, d);\n\t\tCHECK(IsEqual(f1.Scaled(p2, 1.5), f2));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, typename OtherScalar2, int DIM2 = DIM, typename = typename std::enable_if_t<DIM2 == 2>> [[nodiscard]] FrameT Rotated(const PointT<OtherScalar, DIM>& point, const OtherScalar2& angle),\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\nTEST_CASE(\"case1:this is a case for Frame2\", \"[Common][Frame2]\") {\n\tSECTION(\"Construction 2D\") {\n\t\tPointT<double, 2> p(0.0, 0.0);\n\t\tDirectionT<double, 2> dx(1.0, 0.0);\n\t\tDirectionT<double, 2> dy(0.0, 1.0);\n\t\tFrameT<double, 2> f1;\n\t\tFrameT<double, 2> f2(p, dx, dy);\n\t\tCHECK(IsEqual(f1, f2));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, typename OtherScalar2, int DIM2 = DIM, typename = typename std::enable_if_t<DIM2 == 2>> FrameT& Rotate(const PointT<OtherScalar, DIM>& point, const OtherScalar2& angle),\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\nTEST_CASE(\"case1:this is a case for Frame2\", \"[Common][Frame2]\") {\n\tSECTION(\"Construction 2D\") {\n\t\tPointT<double, 2> p(1.0, 2.0);\n\t\tDirectionT<double, 2> dx(1.0, 3.0);\n\t\tDirectionT<double, 2> dy(-3.0, 1.0);\n\t\tFrameT<double, 2> f1(p, dx);\n\t\tFrameT<double, 2> f2(p, dx, dy);\n\t\tCHECK(IsEqual(f1, f2));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar> [[nodiscard]] FrameT Mirrored(const AxisT<OtherScalar, DIM>& a),\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\nTEST_CASE(\"case1:this is a case for Frame2\", \"[Common][Frame2]\") {\n\tSECTION(\"Mirror axis 2D\") {\n\t\tPointT<double, 2> p(1.0, 2.0);\n\t\tDirectionT<double, 2> d(1.0, 3.0);\n\t\tFrameT<double, 2> f1(p, d);\n\t\tPointT<double, 2> p2(2.0, 3.0);\n\t\tDirectionT<double, 2> d2(1.0, 4.0);\n\t\tAxisT<double, 2> axis(p2, d2);\n\t\tPointT<double, 2> p3(41.0 / 17.0, 28.0 / 17.0);\n\t\tDirectionT<double, 2> d3(9.0, 53.0);\n\t\tDirectionT<double, 2> d4(53.0, -9.0);\n\t\tFrameT<double, 2> f2 = f1.Mirrored(axis);\n\t\tCHECK(f2.Location().IsEqual(p3, tol));\n\t\tCHECK(f2.XDirection().IsEqual(d3, tol));\n\t\tCHECK(f2.YDirection().IsEqual(d4, tol));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar> [[nodiscard]] FrameT Mirrored(const PointT<OtherScalar, DIM>& point),\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\nTEST_CASE(\"case1:this is a case for Frame2\", \"[Common][Frame2]\") {\n\tSECTION(\"Mirror point 2D\") {\n\t\tPointT<double, 2> p(1.0, 2.0);\n\t\tDirectionT<double, 2> d(1.0, 3.0);\n\t\tFrameT<double, 2> f1(p, d);\n\t\tPointT<double, 2> p2(2.0, 3.0);\n\t\tPointT<double, 2> p3(3.0, 4.0);\n\t\tDirectionT<double, 2> d2(-1.0, -3.0);\n\t\tFrameT<double, 2> f2(p3, d2);\n\t\tCHECK(IsEqual(f1.Mirrored(p2), f2));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar> FrameT& Mirror(const PointT<OtherScalar, DIM>& point),\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\nTEST_CASE(\"case1:this is a case for Frame2\", \"[Common][Frame2]\") {\n\tSECTION(\"Mirror point 2D\") {\n\t\tPointT<double, 2> p(1.0, 2.0);\n\t\tDirectionT<double, 2> d(1.0, 3.0);\n\t\tFrameT<double, 2> f1(p, d);\n\t\tPointT<double, 2> p2(2.0, 3.0);\n\t\tPointT<double, 2> p3(3.0, 4.0);\n\t\tDirectionT<double, 2> d2(-1.0, -3.0);\n\t\tFrameT<double, 2> f2(p3, d2);\n\t\tCHECK(IsEqual(f1.Mirrored(p2), f2));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<int DIM2 = DIM, typename = typename std::enable_if_t<DIM2 >= 2>> [[nodiscard]] const DirectionT<Scalar, DIM>& YDirection(),\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\n#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<int DIM2 = DIM, typename = typename std::enable_if_t<DIM2 >= 1>> [[nodiscard]] const DirectionT<Scalar, DIM>& XDirection(),\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\nTEST_CASE(\"case1:this is a case for Frame2\", \"[Common][Frame2]\") {\n\tSECTION(\"Mirror axis 2D\") {\n\t\tPointT<double, 2> p(1.0, 2.0);\n\t\tDirectionT<double, 2> d(1.0, 3.0);\n\t\tFrameT<double, 2> f1(p, d);\n\t\tPointT<double, 2> p2(2.0, 3.0);\n\t\tDirectionT<double, 2> d2(1.0, 4.0);\n\t\tAxisT<double, 2> axis(p2, d2);\n\t\tPointT<double, 2> p3(41.0 / 17.0, 28.0 / 17.0);\n\t\tDirectionT<double, 2> d3(9.0, 53.0);\n\t\tDirectionT<double, 2> d4(53.0, -9.0);\n\t\tFrameT<double, 2> f2 = f1.Mirrored(axis);\n\t\tCHECK(f2.Location().IsEqual(p3, tol));\n\t\tCHECK(f2.XDirection().IsEqual(d3, tol));\n\t\tCHECK(f2.YDirection().IsEqual(d4, tol));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, int DIM2 = DIM, std::enable_if_t<DIM2 == 2, int> = 0> void SetYDirection(const DirectionT<OtherScalar, DIM>& y),\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\nTEST_CASE(\"case1:this is a case for Frame2\", \"[Common][Frame2]\") {\n\tSECTION(\"SetYDirection 2D\") {\n\t\tPointT<double, 2> p(1.0, 2.0);\n\t\tDirectionT<double, 2> dx(1.0, 3.0);\n\t\tDirectionT<double, 2> dy(-3.0, 1.0);\n\t\tFrameT<double, 2> f1(p, dx);\n\t\tDirectionT<double, 2> dx2(-1.0, -2.0);\n\t\tFrameT<double, 2> f2(p, dx2);\n\t\tf2.SetYDirection(dy);\n\t\tCHECK(IsEqual(f1, f2));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, int DIM2 = DIM, std::enable_if_t<DIM2 == 2, int> = 0> void SetXDirection(const DirectionT<OtherScalar, DIM>& x),\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\nTEST_CASE(\"case1:this is a case for Frame2\", \"[Common][Frame2]\") {\n\tSECTION(\"SetXDirection 2D\") {\n\t\tPointT<double, 2> p(1.0, 2.0);\n\t\tDirectionT<double, 2> dx(1.0, 3.0);\n\t\tFrameT<double, 2> f1(p, dx);\n\t\tDirectionT<double, 2> dx2(-1.0, -2.0);\n\t\tFrameT<double, 2> f2(p, dx2);\n\t\tf2.SetXDirection(dx);\n\t\tCHECK(IsEqual(f1, f2));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, int DIM2 = DIM, std::enable_if_t<DIM2 == 2, int> = 0> void SetYAxis(const AxisT<OtherScalar, DIM>& axis),\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\nTEST_CASE(\"case1:this is a case for Frame2\", \"[Common][Frame2]\") {\n\tSECTION(\"SetYAxis 2D\") {\n\t\tPointT<double, 2> p(1.0, 2.0);\n\t\tPointT<double, 2> p2(3.0, 1.0);\n\t\tDirectionT<double, 2> dx(1.0, 3.0);\n\t\tDirectionT<double, 2> dy(-3.0, 1.0);\n\t\tFrameT<double, 2> f1(p, dx);\n\t\tDirectionT<double, 2> dx2(-1.0, -2.0);\n\t\tFrameT<double, 2> f2(p2, dx2);\n\t\tAxisT<double, 2> axis(p, dy);\n\t\tf2.SetYAxis(axis);\n\t\tCHECK(IsEqual(f1, f2));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, int DIM2 = DIM, std::enable_if_t<DIM2 == 2, int> = 0> void SetXAxis(const AxisT<OtherScalar, DIM>& axis),\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\nTEST_CASE(\"case1:this is a case for Frame2\", \"[Common][Frame2]\") {\n\tSECTION(\"SetXAxis 2D\") {\n\t\tPointT<double, 2> p(1.0, 2.0);\n\t\tPointT<double, 2> p2(3.0, 1.0);\n\t\tDirectionT<double, 2> dx(1.0, 3.0);\n\t\tFrameT<double, 2> f1(p, dx);\n\t\tDirectionT<double, 2> dx2(-1.0, -2.0);\n\t\tFrameT<double, 2> f2(p2, dx2);\n\t\tAxisT<double, 2> axis(p, dx);\n\t\tf2.SetXAxis(axis);\n\t\tCHECK(IsEqual(f1, f2));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, int DIM2 = DIM, std::enable_if_t<DIM2 == 2, int> = 0> explicit FrameT(const AxisT<OtherScalar, DIM>& axis, bool isright = true),\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\nTEST_CASE(\"case1:this is a case for Frame2\", \"[Common][Frame2]\") {\n\tSECTION(\"Construction 2D\") {\n\t\tPointT<double, 2> p(0.0, 0.0);\n\t\tDirectionT<double, 2> dx(1.0, 0.0);\n\t\tDirectionT<double, 2> dy(0.0, 1.0);\n\t\tFrameT<double, 2> f1;\n\t\tFrameT<double, 2> f2(p, dx, dy);\n\t\tCHECK(IsEqual(f1, f2));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, typename OtherScalar2, int DIM2 = DIM, std::enable_if_t<DIM2 == 2, int> = 0> FrameT(const PointT<OtherScalar, DIM>& point, const DirectionT<OtherScalar2, DIM>& xdir, bool isright = true),\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\nTEST_CASE(\"case1:this is a case for Frame2\", \"[Common][Frame2]\") {\n\tSECTION(\"Construction 2D\") {\n\t\tPointT<double, 2> p(0.0, 0.0);\n\t\tDirectionT<double, 2> dx(1.0, 0.0);\n\t\tDirectionT<double, 2> dy(0.0, 1.0);\n\t\tFrameT<double, 2> f1;\n\t\tFrameT<double, 2> f2(p, dx, dy);\n\t\tCHECK(IsEqual(f1, f2));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, typename OtherScalar2, typename OtherScalar3, int DIM2 = DIM, std::enable_if_t<DIM2 == 2, int> = 0> FrameT(const PointT<OtherScalar, DIM>& point, const DirectionT<OtherScalar2, DIM>& xdir, const DirectionT<OtherScalar3, DIM>& ydir),\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\nTEST_CASE(\"case1:this is a case for Frame2\", \"[Common][Frame2]\") {\n\tSECTION(\"Construction 2D\") {\n\t\tPointT<double, 2> p(0.0, 0.0);\n\t\tDirectionT<double, 2> dx(1.0, 0.0);\n\t\tDirectionT<double, 2> dy(0.0, 1.0);\n\t\tFrameT<double, 2> f1;\n\t\tFrameT<double, 2> f2(p, dx, dy);\n\t\tCHECK(IsEqual(f1, f2));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "[[nodiscard]] const PointT<Scalar, DIM>& Location()\t @return The location\n\t @brief Get the location\n,\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)\n{\n\tif constexpr (DIM == 1)\n\t{\n\t\treturn result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);\n\t}\n\telse if constexpr (DIM == 2)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse if constexpr (DIM == 3)\n\t{\n\t\treturn result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\nTEST_CASE(\"case1:this is a case for Frame2\", \"[Common][Frame2]\") {\n\tSECTION(\"Mirror axis 2D\") {\n\t\tPointT<double, 2> p(1.0, 2.0);\n\t\tDirectionT<double, 2> d(1.0, 3.0);\n\t\tFrameT<double, 2> f1(p, d);\n\t\tPointT<double, 2> p2(2.0, 3.0);\n\t\tDirectionT<double, 2> d2(1.0, 4.0);\n\t\tAxisT<double, 2> axis(p2, d2);\n\t\tPointT<double, 2> p3(41.0 / 17.0, 28.0 / 17.0);\n\t\tDirectionT<double, 2> d3(9.0, 53.0);\n\t\tDirectionT<double, 2> d4(53.0, -9.0);\n\t\tFrameT<double, 2> f2 = f1.Mirrored(axis);\n\t\tCHECK(f2.Location().IsEqual(p3, tol));\n\t\tCHECK(f2.XDirection().IsEqual(d3, tol));\n\t\tCHECK(f2.YDirection().IsEqual(d4, tol));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, typename OtherScalar2> [[nodiscard]] AxisT Scaled(const PointT<OtherScalar, DIM> point, const OtherScalar2& scale),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected){\n\treturn result.Location().IsEqual(expected.Location(), tol) &&\n\t\tresult.Direction().IsEqual(expected.Direction(), tol);\n}\nTEST_CASE(\"case1:this is a case for Axis3\",\"[Common][Axis3]\")\n{\n\tint i = 1;\n\tSECTION(\"Scale 3D\"){\n\t\tAxisT<double, 3> a1(PointT<double, 3>{1.0, 2.0, 3.0}, DirectionT<double, 3>{1.0, 2.0, 3.0});\n\t\tPointT<double, 3> p(2.0, 3.0, 4.0);\n\t\tAxisT<double, 3> a2(PointT<double, 3>{0.5, 1.5, 2.5}, DirectionT<double, 3>{1.0, 2.0, 3.0});\n\t\tCHECK(IsEqual(a1.Scaled(p, 1.5), a2));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, typename OtherScalar2, int DIM2 = DIM, typename = typename std::enable_if_t<DIM2 == 3>> AxisT& Rotate(const AxisT<OtherScalar, DIM>& axis, const OtherScalar2& angle),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected){\n\treturn result.Location().IsEqual(expected.Location(), tol) &&\n\t\tresult.Direction().IsEqual(expected.Direction(), tol);\n}\nTEST_CASE(\"case1:this is a case for Axis3\",\"[Common][Axis3]\")\n{\n\tint i = 1;\n\tSECTION(\"Rotate 3D\"){\n\t\tAxisT<double, 3> a1(PointT<double, 3>{1.0, 2.0, 3.0}, DirectionT<double, 3>{1.0, 2.0, 3.0});\n\t\tAxisT<double, 3> a2(PointT<double, 3>{2.0, 3.0, 4.0}, DirectionT<double, 3>{1.0, 1.0, 2.0});\n\t\tAxisT<double, 3> a3(PointT<double, 3>{(8.0 + std::sqrt(6.0)) / 6.0, (14.0 - std::sqrt(6.0)) / 6.0, 8.0 / 3.0}, DirectionT<double, 3>{(9.0 - std::sqrt(6.0)) / 6.0, (9.0 - std::sqrt(6.0)) / 6.0, 3.0 + 1.0 / std::sqrt(6.0)});\n\t\tCHECK(IsEqual(a1.Rotated(a2, M_PI_2), a3));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, int DIM2 = DIM, std::enable_if_t<DIM2 == 3, int> = 0> [[nodiscard]] AxisT Mirrored(const FrameT<OtherScalar, DIM>& frame),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected){\n\treturn result.Location().IsEqual(expected.Location(), tol) &&\n\t\tresult.Direction().IsEqual(expected.Direction(), tol);\n}\nTEST_CASE(\"case1:this is a case for Axis3\",\"[Common][Axis3]\")\n{\n\tint i = 1;\n\tSECTION(\"Mirror(axis) 3D\"){\n\t\tAxisT<double, 3> a1(PointT<double, 3>{1.0, 2.0, 3.0}, DirectionT<double, 3>{1.0, 2.0, 3.0});\n\t\tAxisT<double, 3> a2(PointT<double, 3>{2.0, 3.0, 4.0}, DirectionT<double, 3>{7.0, 3.0, 2.0});\n\t\tAxisT<double, 3> a3(PointT<double, 3>{9.0 / 31.0, 88.0 / 31.0, 131.0 / 31.0}, DirectionT<double, 3>{102.0 / 31.0, -5.0 / 31.0, -55.0 / 31.0});\n\t\tCHECK(IsEqual(a1.Mirrored(a2), a3));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar> [[nodiscard]] AxisT Mirrored(const AxisT<OtherScalar, DIM>& axis),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected){\n\treturn result.Location().IsEqual(expected.Location(), tol) &&\n\t\tresult.Direction().IsEqual(expected.Direction(), tol);\n}\nTEST_CASE(\"case1:this is a case for Axis3\",\"[Common][Axis3]\")\n{\n\tint i = 1;\n\tSECTION(\"Mirror(axis) 3D\"){\n\t\tAxisT<double, 3> a1(PointT<double, 3>{1.0, 2.0, 3.0}, DirectionT<double, 3>{1.0, 2.0, 3.0});\n\t\tAxisT<double, 3> a2(PointT<double, 3>{2.0, 3.0, 4.0}, DirectionT<double, 3>{7.0, 3.0, 2.0});\n\t\tAxisT<double, 3> a3(PointT<double, 3>{9.0 / 31.0, 88.0 / 31.0, 131.0 / 31.0}, DirectionT<double, 3>{102.0 / 31.0, -5.0 / 31.0, -55.0 / 31.0});\n\t\tCHECK(IsEqual(a1.Mirrored(a2), a3));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, int DIM2 = DIM, std::enable_if_t<DIM2 == 3, int> = 0> AxisT& Mirror(const FrameT<OtherScalar, DIM>& frame),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected){\n\treturn result.Location().IsEqual(expected.Location(), tol) &&\n\t\tresult.Direction().IsEqual(expected.Direction(), tol);\n}\nTEST_CASE(\"case1:this is a case for Axis3\",\"[Common][Axis3]\")\n{\n\tint i = 1;\n\tSECTION(\"Mirror(frame) 3D\"){\n\t\tAxisT<double, 3> a1(PointT<double, 3>{1.0, 2.0, 3.0}, DirectionT<double, 3>{1.0, 2.0, 3.0});\n\t\tFrameT<double, 3> f(PointT<double, 3>{2.0, 3.0, 4.0}, DirectionT<double, 3>{7.0, 3.0, 2.0});\n\t\tAxisT<double, 3> a2(PointT<double, 3>{115.0 / 31.0, 98.0 / 31.0, 117.0 / 31.0}, DirectionT<double, 3>{-102.0 / 31.0, 5.0 / 31.0, 55.0 / 31.0});\n\t\tCHECK(IsEqual(a1.Mirror(f), a2));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar> AxisT& Mirror(const AxisT<OtherScalar, DIM>& axis),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected){\n\treturn result.Location().IsEqual(expected.Location(), tol) &&\n\t\tresult.Direction().IsEqual(expected.Direction(), tol);\n}\nTEST_CASE(\"case1:this is a case for Axis3\",\"[Common][Axis3]\")\n{\n\tint i = 1;\n\tSECTION(\"Mirror(axis) 3D\"){\n\t\tAxisT<double, 3> a1(PointT<double, 3>{1.0, 2.0, 3.0}, DirectionT<double, 3>{1.0, 2.0, 3.0});\n\t\tAxisT<double, 3> a2(PointT<double, 3>{2.0, 3.0, 4.0}, DirectionT<double, 3>{7.0, 3.0, 2.0});\n\t\tAxisT<double, 3> a3(PointT<double, 3>{9.0 / 31.0, 88.0 / 31.0, 131.0 / 31.0}, DirectionT<double, 3>{102.0 / 31.0, -5.0 / 31.0, -55.0 / 31.0});\n\t\tCHECK(IsEqual(a1.Mirrored(a2), a3));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar> [[nodiscard]] double Angle(const AxisT<OtherScalar, DIM>& other),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected){\n\treturn result.Location().IsEqual(expected.Location(), tol) &&\n\t\tresult.Direction().IsEqual(expected.Direction(), tol);\n}\nTEST_CASE(\"case1:this is a case for Axis3\",\"[Common][Axis3]\")\n{\n\tint i = 1;\n\tSECTION(\"Angle\"){\n\t\tAxisT<double, 3> a1(PointT<double, 3>{0.0, 0.0, 0.0}, DirectionT<double, 3>{1.0, 2.0, 1.0});\n\t\tAxisT<double, 3> a2(PointT<double, 3>{2.0, 4.0, 3.0}, DirectionT<double, 3>{-1.0, 1.0, -1.0});\n\t\tCHECK(a1.Angle(a2) == M_PI_2);\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, typename OtherScalar2> [[nodiscard]] bool IsParallel(const AxisT<OtherScalar, DIM>& other, const OtherScalar2& tol),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected){\n\treturn result.Location().IsEqual(expected.Location(), tol) &&\n\t\tresult.Direction().IsEqual(expected.Direction(), tol);\n}\nTEST_CASE(\"case1:this is a case for Axis3\",\"[Common][Axis3]\")\n{\n\tint i = 1;\n\tSECTION(\"IsParallel\"){\n\t\tAxisT<double, 3> a1(PointT<double, 3>{0.0, 0.0, 0.0}, DirectionT<double, 3>{1.0, 2.0, 1.0});\n\t\tAxisT<double, 3> a2(PointT<double, 3>{2.0, 4.0, 3.0}, DirectionT<double, 3>{-1.0, -2.0, -1.0});\n\t\tCHECK(a1.IsParallel(a2, 1e-6) == true);\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, typename OtherScalar2> [[nodiscard]] bool IsOpposite(const AxisT<OtherScalar, DIM>& other, const OtherScalar2& tol),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected){\n\treturn result.Location().IsEqual(expected.Location(), tol) &&\n\t\tresult.Direction().IsEqual(expected.Direction(), tol);\n}\nTEST_CASE(\"case1:this is a case for Axis3\",\"[Common][Axis3]\")\n{\n\tint i = 1;\n\tSECTION(\"IsOpposite\"){\n\t\tAxisT<double, 3> a1(PointT<double, 3>{0.0, 0.0, 0.0}, DirectionT<double, 3>{1.0, 2.0, 1.0});\n\t\tAxisT<double, 3> a2(PointT<double, 3>{2.0, 4.0, 3.0}, DirectionT<double, 3>{-1.0, -2.0, -1.0});\n\t\tCHECK(a1.IsOpposite(a2, 1e-6) == true);\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, typename OtherScalar2> [[nodiscard]] bool IsNormal(const AxisT<OtherScalar, DIM>& other, const OtherScalar2& tol),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected){\n\treturn result.Location().IsEqual(expected.Location(), tol) &&\n\t\tresult.Direction().IsEqual(expected.Direction(), tol);\n}\nTEST_CASE(\"case1:this is a case for Axis3\",\"[Common][Axis3]\")\n{\n\tint i = 1;\n\tSECTION(\"IsNormal\"){\n\t\tAxisT<double, 3> a1(PointT<double, 3>{0.0, 0.0, 0.0}, DirectionT<double, 3>{1.0, 2.0, 1.0});\n\t\tAxisT<double, 3> a2(PointT<double, 3>{2.0, 4.0, 3.0}, DirectionT<double, 3>{-1.0, 1.0, -1.0});\n\t\tCHECK(a1.IsNormal(a2, 1e-6) == true);\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, typename OtherScalar2, typename OtherScalar3, int DIM2 = DIM, std::enable_if_t<DIM2 == 3, int> = 0> [[nodiscard]] bool IsCoaxial(const AxisT<OtherScalar, DIM>& other, const OtherScalar2& angtol, const OtherScalar3& distol),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected){\n\treturn result.Location().IsEqual(expected.Location(), tol) &&\n\t\tresult.Direction().IsEqual(expected.Direction(), tol);\n}\nTEST_CASE(\"case1:this is a case for Axis3\",\"[Common][Axis3]\")\n{\n\tint i = 1;\n\tSECTION(\"IsCoaxial 3D\"){\n\t\tAxisT<double, 3> a1(PointT<double, 3>{0.0, 0.0, 0.0}, DirectionT<double, 3>{1.0, 2.0, 3.0});\n\t\tAxisT<double, 3> a2(PointT<double, 3>{2.0, 4.0, 6.0}, DirectionT<double, 3>{1.0, 2.0, 3.0});\n\t\tAxisT<double, 3> a3(PointT<double, 3>{2.0, 4.0, 6.0}, DirectionT<double, 3>{2.0, 2.0, 3.0});\n\t\tAxisT<double, 3> a4(PointT<double, 3>{1.0, 4.0, 6.0}, DirectionT<double, 3>{1.0, 2.0, 3.0});\n\t\tCHECK(a1.IsCoaxial(a2, 1e-6, 1e-6) == true);\n\t\tCHECK(a1.IsCoaxial(a3, 1e-6, 1e-6) == false);\n\t\tCHECK(a1.IsCoaxial(a4, 1e-6, 1e-6) == false);\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, typename OtherScalar2, typename OtherScalar3, int DIM2 = DIM, std::enable_if_t<DIM2 == 2, int> = 0> [[nodiscard]] bool IsCoaxial(const AxisT<OtherScalar, DIM>& other, const OtherScalar2& angtol, const OtherScalar3& distol),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected){\n\treturn result.Location().IsEqual(expected.Location(), tol) &&\n\t\tresult.Direction().IsEqual(expected.Direction(), tol);\n}\nTEST_CASE(\"case1:this is a case for Axis3\",\"[Common][Axis3]\")\n{\n\tint i = 1;\n\tSECTION(\"IsCoaxial 3D\"){\n\t\tAxisT<double, 3> a1(PointT<double, 3>{0.0, 0.0, 0.0}, DirectionT<double, 3>{1.0, 2.0, 3.0});\n\t\tAxisT<double, 3> a2(PointT<double, 3>{2.0, 4.0, 6.0}, DirectionT<double, 3>{1.0, 2.0, 3.0});\n\t\tAxisT<double, 3> a3(PointT<double, 3>{2.0, 4.0, 6.0}, DirectionT<double, 3>{2.0, 2.0, 3.0});\n\t\tAxisT<double, 3> a4(PointT<double, 3>{1.0, 4.0, 6.0}, DirectionT<double, 3>{1.0, 2.0, 3.0});\n\t\tCHECK(a1.IsCoaxial(a2, 1e-6, 1e-6) == true);\n\t\tCHECK(a1.IsCoaxial(a3, 1e-6, 1e-6) == false);\n\t\tCHECK(a1.IsCoaxial(a4, 1e-6, 1e-6) == false);\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar> void SetDirection(const DirectionT<OtherScalar, DIM>& dir),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected){\n\treturn result.Location().IsEqual(expected.Location(), tol) &&\n\t\tresult.Direction().IsEqual(expected.Direction(), tol);\n}\nTEST_CASE(\"case1:this is a case for Axis3\",\"[Common][Axis3]\")\n{\n\tint i = 1;\n\tSECTION(\"SetDirection\"){\n\t\tAxisT<double, 3> a1;\n\t\tDirectionT<double, 3> d(1.0, 2.0, 3.0);\n\t\ta1.SetDirection(d);\n\t\tAxisT<double, 3> a2(PointT<double, 3>{0.0, 0.0, 0.0}, d);\n\t\tCHECK(IsEqual(a1, a2));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, typename OtherScalar2> AxisT(const PointT<OtherScalar, DIM>& point, const DirectionT<OtherScalar2, DIM>& dir),\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected){\n\treturn result.Location().IsEqual(expected.Location(), tol) &&\n\t\tresult.Direction().IsEqual(expected.Direction(), tol);\n}\nTEST_CASE(\"case1:this is a case for Axis3\",\"[Common][Axis3]\")\n{\n\tint i = 1;\n\tSECTION(\"Reverse\"){\n\t\tAxisT<double, 3> a1(PointT<double, 3>{1.0, 2.0, 3.0}, DirectionT<double, 3>{1.0, 2.0, 1.0});\n\t\tAxisT<double, 3> a2(PointT<double, 3>{1.0, 2.0, 3.0}, DirectionT<double, 3>{-1.0, -2.0, -1.0});\n\t\tCHECK(IsEqual(a1.Reversed(), a2));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AxisT()\t @details The default location is (0, 0, 0). In 2D, the default direction is (1, 0); in 3D, the default direction is (0, 0, 1).\n\t @brief Default constructor\n,\n",
      "output": "#include<catch.hpp>\n#include <sstream>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected){\n\treturn result.Location().IsEqual(expected.Location(), tol) &&\n\t\tresult.Direction().IsEqual(expected.Direction(), tol);\n}\nTEST_CASE(\"case1:this is a case for Axis3\",\"[Common][Axis3]\")\n{\n\tint i = 1;\n\tSECTION(\"default constructor 3D\"){\n\t\tAxisT<double, 3> a1;\n\t\tAxisT<double, 3> a2(PointT<double, 3>{0.0, 0.0, 0.0}, DirectionT<double, 3>{0.0, 0.0, 1.0});\n\t\tCHECK(IsEqual(a1, a2));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, typename OtherScalar2> AxisT& Translate(const PointT<OtherScalar, DIM>& p1, const PointT<OtherScalar2, DIM>& p2),\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {\n\treturn result.Location().IsEqual(expected.Location(), tol) &&\n\t\tresult.Direction().IsEqual(expected.Direction(), tol);\n}\nTEST_CASE(\"case1:this is a case for Axis2\", \"[Common][Axis2]\") {\n\tSECTION(\"Translate(p1, p2) 2D\") {\n\t\tAxisT<double, 2> a1(PointT<double, 2>(1.0, 2.0), DirectionT<double, 2>{1.0, 2.0});\n\t\tPointT<double, 2> p1(2.0, 3.0);\n\t\tPointT<double, 2> p2(4.0, 2.0);\n\t\tAxisT<double, 2> a2(PointT<double, 2>(3.0, 1.0), DirectionT<double, 2>{1.0, 2.0});\n\t\tCHECK(IsEqual(a1.Translated(p1, p2), a2));\n\t}\n}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, typename OtherScalar2> [[nodiscard]] AxisT Scaled(const PointT<OtherScalar, DIM> point, const OtherScalar2& scale),\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {\n\treturn result.Location().IsEqual(expected.Location(), tol) &&\n\t\tresult.Direction().IsEqual(expected.Direction(), tol);\n}\nTEST_CASE(\"case1:this is a case for Axis2\", \"[Common][Axis2]\") {\n\tSECTION(\"Scale 2D\") {\n\t\tAxisT<double, 2> a1(PointT<double, 2>{1.0, 2.0}, DirectionT<double, 2>{1.0, 2.0});\n\t\tPointT<double, 2> p(2.0, 3.0);\n\t\tAxisT<double, 2> a2(PointT<double, 2>{0.5, 1.5}, DirectionT<double, 2>{1.0, 2.0});\n\t\tCHECK(IsEqual(a1.Scaled(p, 1.5), a2));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar> [[nodiscard]] AxisT Mirrored(const PointT<OtherScalar, DIM>& point),\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {\n\treturn result.Location().IsEqual(expected.Location(), tol) &&\n\t\tresult.Direction().IsEqual(expected.Direction(), tol);\n}\nTEST_CASE(\"case1:this is a case for Axis2\", \"[Common][Axis2]\") {\n\tSECTION(\"Mirror(point) 2D\") {\n\t\tAxisT<double, 2> a1(PointT<double, 2>{1.0, 2.0}, DirectionT<double, 2>{1.0, 1.0});\n\t\tPointT<double, 2> p(3.0, 4.0);\n\t\tAxisT<double, 2> a2(PointT<double, 2>{5.0, 6.0}, DirectionT<double, 2>{-1.0, -1.0});\n\t\tCHECK(IsEqual(a1.Mirrored(p), a2));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar> AxisT& Mirror(const PointT<OtherScalar, DIM>& point),\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {\n\treturn result.Location().IsEqual(expected.Location(), tol) &&\n\t\tresult.Direction().IsEqual(expected.Direction(), tol);\n}\nTEST_CASE(\"case1:this is a case for Axis2\", \"[Common][Axis2]\") {\n\tSECTION(\"Mirror(point) 2D\") {\n\t\tAxisT<double, 2> a1(PointT<double, 2>{1.0, 2.0}, DirectionT<double, 2>{1.0, 1.0});\n\t\tPointT<double, 2> p(3.0, 4.0);\n\t\tAxisT<double, 2> a2(PointT<double, 2>{5.0, 6.0}, DirectionT<double, 2>{-1.0, -1.0});\n\t\tCHECK(IsEqual(a1.Mirrored(p), a2));\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, typename OtherScalar2, typename OtherScalar3, int DIM2 = DIM, std::enable_if_t<DIM2 == 2, int> = 0> [[nodiscard]] bool IsCoaxial(const AxisT<OtherScalar, DIM>& other, const OtherScalar2& angtol, const OtherScalar3& distol),\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {\n\treturn result.Location().IsEqual(expected.Location(), tol) &&\n\t\tresult.Direction().IsEqual(expected.Direction(), tol);\n}\nTEST_CASE(\"case1:this is a case for Axis2\", \"[Common][Axis2]\") {\n\tSECTION(\"IsCoaxial 2D\") {\n\t\tAxisT<double, 2> a1(PointT<double, 2>{0.0, 0.0}, DirectionT<double, 2>{1.0, 2.0});\n\t\tAxisT<double, 2> a2(PointT<double, 2>{2.0, 4.0}, DirectionT<double, 2>{1.0, 2.0});\n\t\tAxisT<double, 2> a3(PointT<double, 2>{2.0, 4.0}, DirectionT<double, 2>{2.0, 2.0});\n\t\tAxisT<double, 2> a4(PointT<double, 2>{1.0, 4.0}, DirectionT<double, 2>{1.0, 2.0});\n\t\tCHECK(a1.IsCoaxial(a2, 1e-6, 1e-6) == true);\n\t\tCHECK(a1.IsCoaxial(a3, 1e-6, 1e-6) == false);\n\t\tCHECK(a1.IsCoaxial(a4, 1e-6, 1e-6) == false);\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "template<typename OtherScalar, typename OtherScalar2> AxisT(const PointT<OtherScalar, DIM>& point, const DirectionT<OtherScalar2, DIM>& dir),\n",
      "output": "#include<catch.hpp>\n#include <common/AxisT.hpp>\n#include <common/DirectionT.hpp>\n#include <common/FrameT.hpp>\n#include <common/PointT.hpp>\n#include <common/TransformationT.hpp>\n#include <common/VectorT.hpp>\n#include <iostream>\n#define tol 0.001\n#define tolDis 0.001\n#define tolAng 0.01\nusing namespace AMCAX;\nusing namespace std;\ntemplate<typename T, int DIM>\nbool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {\n\treturn result.Location().IsEqual(expected.Location(), tol) &&\n\t\tresult.Direction().IsEqual(expected.Direction(), tol);\n}\nTEST_CASE(\"case1:this is a case for Axis2\", \"[Common][Axis2]\") {\n\tSECTION(\"IsCoaxial 2D\") {\n\t\tAxisT<double, 2> a1(PointT<double, 2>{0.0, 0.0}, DirectionT<double, 2>{1.0, 2.0});\n\t\tAxisT<double, 2> a2(PointT<double, 2>{2.0, 4.0}, DirectionT<double, 2>{1.0, 2.0});\n\t\tAxisT<double, 2> a3(PointT<double, 2>{2.0, 4.0}, DirectionT<double, 2>{2.0, 2.0});\n\t\tAxisT<double, 2> a4(PointT<double, 2>{1.0, 4.0}, DirectionT<double, 2>{1.0, 2.0});\n\t\tCHECK(a1.IsCoaxial(a2, 1e-6, 1e-6) == true);\n\t\tCHECK(a1.IsCoaxial(a3, 1e-6, 1e-6) == false);\n\t\tCHECK(a1.IsCoaxial(a4, 1e-6, 1e-6) == false);\n\t}}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API void SimplifyResult(bool isUnfiyEdges = true, bool isUnifyFaces = true, double angularTol = Precision::Angular()\t @param angularTol The angular tolerance for checking parallel\n\t @param isUnifyFaces Set whether unify faces\n\t @param isUnfiyEdges Set whether unify edges\n\t @brief Simplify the boolean result, remove redundant edges and faces\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <boolean/BoolBuilder.hpp>\n#include <modeling/MakeBox.hpp>\n#include <boolean/BoolBRepFuse.hpp>\n#include <common/IndexSet.hpp>\n#include <topology/TopoExplorerTool.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"case1: BoolBuilder added SimplifyResult() API at 3.6.0. \", \"[boolean][BoolBuilder][P1]\") {\n\tTopoShape box1 = MakeBox(Point3(0., 0., 0.), Point3(2., 2., 2.));\n\tTopoShape box2 = MakeBox(Point3(1., 1., 0.), Point3(3., 3., 2.));\n\tBoolBRepFuse fuse(box1, box2);\n\tTopoShape shape1 = fuse.Shape();\n\tfuse.SimplifyResult();\n\tTopoShape shape2 = fuse.Shape();\n\tIndexSet<TopoShape> shape1Faces, shape2Faces;\n\tTopoExplorerTool::MapShapes(shape1, ShapeType::Face, shape1Faces);\n\tTopoExplorerTool::MapShapes(shape2, ShapeType::Face, shape2Faces);\n\tstd::cout << shape1Faces.size() << \"  \" << shape2Faces.size() << std::endl;\n\tCHECK(shape1Faces.size() == 14);\n\tCHECK(shape2Faces.size() == 10);\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API BoolBRepSection(const std::shared_ptr<Geom3Surface>& s1, const std::shared_ptr<Geom3Surface>& s2, bool perfomNow = true)\t @param perfomNow If true, the operation is performed immediately; if false, the Build() function has to be called manually\n\t @param s2 The tool surface\n\t @param s1 The argument surface\n\t @brief Special case: compute the section of two surfaces\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <boolean/BoolBRepSection.hpp>\n#include <common/CartesianCoordinateSystem.hpp>\n#include <math/LineT.hpp>\n#include <modeling/MakePrism.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeFace.hpp>\n#include <geometry/Geom3BezierCurve.hpp>\n#include <modeling/MakeRevol.hpp>\n#include <geometry/Geom3CylindricalSurface.hpp>\n#include <topology/TopoTool.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"bug1: BoolBRepSection \", \"[boolean][BoolBRepSection][fixbug]\")\n{\n\tLine3 line(CartesianCoordinateSystem::OZ());\n\tTopoShape infinitePlane1 = MakePrism(MakeEdge(line, 0.0, 1.0), Direction3(-1.0, 0.0, 0.0), false);\n\tTopoShape infinitePlane2 = MakePrism(MakeEdge(line, 0.0, 1.0), Direction3(1.0, 0.0, 0.0), false);\n\tTopoShape infinitePlane3 = MakePrism(MakeEdge(line, 0.0, 1.0), Direction3(0.0, 1.0, 0.0), false);\n\tTopoShape infinitePlane4 = MakePrism(MakeEdge(line, 0.0, 1.0), Direction3(0.0, -1.0, 0.0), false);\n\tstd::vector<Point3> poles{ Point3(1.0, 0.0, 0.0), Point3(0.8, 0.0, 0.5), Point3(1.0, 0.0, 1.0) };\n\tauto bz = std::make_shared<Geom3BezierCurve>(poles);\n\tTopoEdge e2 = MakeEdge(bz);\n\tTopoShape revolshape = MakeRevol(e2, CartesianCoordinateSystem::OZ());\n\tauto surface1 = std::make_shared<Geom3CylindricalSurface>(Frame3(), 1.0);\n\tauto surface2 = TopoTool::Surface(TopoCast::Face(revolshape));\n\tTopoShape result1 = BoolBRepSection(infinitePlane1, surface2); \n\tTopoShape result2 = BoolBRepSection(infinitePlane2, surface2); \n\tTopoShape result3 = BoolBRepSection(infinitePlane3, surface2); \n\tTopoShape result4 = BoolBRepSection(infinitePlane4, surface2); \n\tGlobalProperty prop1, prop2, prop3, prop4 ;\n\tCHECK( GetLinearProperties(result1, prop1, true, false) == Approx(1.0260606301));\n\tCHECK( GetLinearProperties(result2, prop1, true, false) == Approx(1.0260606301));\n\tCHECK( GetLinearProperties(result3, prop1, true, false) == Approx(1.0260606301));\n\tCHECK( GetLinearProperties(result4, prop1, true, false) == Approx(1.0260606301));\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API BoolBRepSection(const std::shared_ptr<Geom3Surface>& surface, const TopoShape& s2, bool perfomNow = true)\t @param perfomNow If true, the operation is performed immediately; if false, the Build() function has to be called manually\n\t @param s2 The tool shape\n\t @param surface The argument surface\n\t @brief Special case: compute the section of a surface and a shape\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <boolean/BoolBRepSection.hpp>\n#include <common/CartesianCoordinateSystem.hpp>\n#include <math/LineT.hpp>\n#include <modeling/MakePrism.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeFace.hpp>\n#include <geometry/Geom3BezierCurve.hpp>\n#include <modeling/MakeRevol.hpp>\n#include <geometry/Geom3CylindricalSurface.hpp>\n#include <topology/TopoTool.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"bug1: BoolBRepSection \", \"[boolean][BoolBRepSection][fixbug]\")\n{\n\tLine3 line(CartesianCoordinateSystem::OZ());\n\tTopoShape infinitePlane1 = MakePrism(MakeEdge(line, 0.0, 1.0), Direction3(-1.0, 0.0, 0.0), false);\n\tTopoShape infinitePlane2 = MakePrism(MakeEdge(line, 0.0, 1.0), Direction3(1.0, 0.0, 0.0), false);\n\tTopoShape infinitePlane3 = MakePrism(MakeEdge(line, 0.0, 1.0), Direction3(0.0, 1.0, 0.0), false);\n\tTopoShape infinitePlane4 = MakePrism(MakeEdge(line, 0.0, 1.0), Direction3(0.0, -1.0, 0.0), false);\n\tstd::vector<Point3> poles{ Point3(1.0, 0.0, 0.0), Point3(0.8, 0.0, 0.5), Point3(1.0, 0.0, 1.0) };\n\tauto bz = std::make_shared<Geom3BezierCurve>(poles);\n\tTopoEdge e2 = MakeEdge(bz);\n\tTopoShape revolshape = MakeRevol(e2, CartesianCoordinateSystem::OZ());\n\tauto surface1 = std::make_shared<Geom3CylindricalSurface>(Frame3(), 1.0);\n\tauto surface2 = TopoTool::Surface(TopoCast::Face(revolshape));\n\tTopoShape result1 = BoolBRepSection(infinitePlane1, surface2); \n\tTopoShape result2 = BoolBRepSection(infinitePlane2, surface2); \n\tTopoShape result3 = BoolBRepSection(infinitePlane3, surface2); \n\tTopoShape result4 = BoolBRepSection(infinitePlane4, surface2); \n\tGlobalProperty prop1, prop2, prop3, prop4 ;\n\tCHECK( GetLinearProperties(result1, prop1, true, false) == Approx(1.0260606301));\n\tCHECK( GetLinearProperties(result2, prop1, true, false) == Approx(1.0260606301));\n\tCHECK( GetLinearProperties(result3, prop1, true, false) == Approx(1.0260606301));\n\tCHECK( GetLinearProperties(result4, prop1, true, false) == Approx(1.0260606301));\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API BoolBRepSection(const TopoShape& s1, const std::shared_ptr<Geom3Surface>& surface, bool perfomNow = true)\t @param perfomNow If true, the operation is performed immediately; if false, the Build() function has to be called manually\n\t @param surface The tool surface\n\t @param s1 The argument shape\n\t @brief Special case: compute the section of a shape and a surface\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <boolean/BoolBRepSection.hpp>\n#include <common/CartesianCoordinateSystem.hpp>\n#include <math/LineT.hpp>\n#include <modeling/MakePrism.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeFace.hpp>\n#include <geometry/Geom3BezierCurve.hpp>\n#include <modeling/MakeRevol.hpp>\n#include <geometry/Geom3CylindricalSurface.hpp>\n#include <topology/TopoTool.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"bug1: BoolBRepSection \", \"[boolean][BoolBRepSection][fixbug]\")\n{\n\tLine3 line(CartesianCoordinateSystem::OZ());\n\tTopoShape infinitePlane1 = MakePrism(MakeEdge(line, 0.0, 1.0), Direction3(-1.0, 0.0, 0.0), false);\n\tTopoShape infinitePlane2 = MakePrism(MakeEdge(line, 0.0, 1.0), Direction3(1.0, 0.0, 0.0), false);\n\tTopoShape infinitePlane3 = MakePrism(MakeEdge(line, 0.0, 1.0), Direction3(0.0, 1.0, 0.0), false);\n\tTopoShape infinitePlane4 = MakePrism(MakeEdge(line, 0.0, 1.0), Direction3(0.0, -1.0, 0.0), false);\n\tstd::vector<Point3> poles{ Point3(1.0, 0.0, 0.0), Point3(0.8, 0.0, 0.5), Point3(1.0, 0.0, 1.0) };\n\tauto bz = std::make_shared<Geom3BezierCurve>(poles);\n\tTopoEdge e2 = MakeEdge(bz);\n\tTopoShape revolshape = MakeRevol(e2, CartesianCoordinateSystem::OZ());\n\tauto surface1 = std::make_shared<Geom3CylindricalSurface>(Frame3(), 1.0);\n\tauto surface2 = TopoTool::Surface(TopoCast::Face(revolshape));\n\tTopoShape result1 = BoolBRepSection(infinitePlane1, surface2); \n\tTopoShape result2 = BoolBRepSection(infinitePlane2, surface2); \n\tTopoShape result3 = BoolBRepSection(infinitePlane3, surface2); \n\tTopoShape result4 = BoolBRepSection(infinitePlane4, surface2); \n\tGlobalProperty prop1, prop2, prop3, prop4 ;\n\tCHECK( GetLinearProperties(result1, prop1, true, false) == Approx(1.0260606301));\n\tCHECK( GetLinearProperties(result2, prop1, true, false) == Approx(1.0260606301));\n\tCHECK( GetLinearProperties(result3, prop1, true, false) == Approx(1.0260606301));\n\tCHECK( GetLinearProperties(result4, prop1, true, false) == Approx(1.0260606301));\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API BoolBRepSection(const TopoShape& s1, const Plane& p1, bool perfomNow = true)\t @param perfomNow If true, the operation is performed immediately; if false, the Build() function has to be called manually\n\t @param p1 The tool plane\n\t @param s1 The argument shape\n\t @brief Special case: compute the section of a shape and an infinite plane\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <boolean/BoolBRepSection.hpp>\n#include <common/CartesianCoordinateSystem.hpp>\n#include <math/LineT.hpp>\n#include <modeling/MakePrism.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeFace.hpp>\n#include <geometry/Geom3BezierCurve.hpp>\n#include <modeling/MakeRevol.hpp>\n#include <geometry/Geom3CylindricalSurface.hpp>\n#include <topology/TopoTool.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"bug1: BoolBRepSection \", \"[boolean][BoolBRepSection][fixbug]\")\n{\n\tLine3 line(CartesianCoordinateSystem::OZ());\n\tTopoShape infinitePlane1 = MakePrism(MakeEdge(line, 0.0, 1.0), Direction3(-1.0, 0.0, 0.0), false);\n\tTopoShape infinitePlane2 = MakePrism(MakeEdge(line, 0.0, 1.0), Direction3(1.0, 0.0, 0.0), false);\n\tTopoShape infinitePlane3 = MakePrism(MakeEdge(line, 0.0, 1.0), Direction3(0.0, 1.0, 0.0), false);\n\tTopoShape infinitePlane4 = MakePrism(MakeEdge(line, 0.0, 1.0), Direction3(0.0, -1.0, 0.0), false);\n\tstd::vector<Point3> poles{ Point3(1.0, 0.0, 0.0), Point3(0.8, 0.0, 0.5), Point3(1.0, 0.0, 1.0) };\n\tauto bz = std::make_shared<Geom3BezierCurve>(poles);\n\tTopoEdge e2 = MakeEdge(bz);\n\tTopoShape revolshape = MakeRevol(e2, CartesianCoordinateSystem::OZ());\n\tauto surface1 = std::make_shared<Geom3CylindricalSurface>(Frame3(), 1.0);\n\tauto surface2 = TopoTool::Surface(TopoCast::Face(revolshape));\n\tTopoShape result1 = BoolBRepSection(infinitePlane1, surface2); \n\tTopoShape result2 = BoolBRepSection(infinitePlane2, surface2); \n\tTopoShape result3 = BoolBRepSection(infinitePlane3, surface2); \n\tTopoShape result4 = BoolBRepSection(infinitePlane4, surface2); \n\tGlobalProperty prop1, prop2, prop3, prop4 ;\n\tCHECK( GetLinearProperties(result1, prop1, true, false) == Approx(1.0260606301));\n\tCHECK( GetLinearProperties(result2, prop1, true, false) == Approx(1.0260606301));\n\tCHECK( GetLinearProperties(result3, prop1, true, false) == Approx(1.0260606301));\n\tCHECK( GetLinearProperties(result4, prop1, true, false) == Approx(1.0260606301));\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API BoolBRepSection(const TopoShape& s1, const TopoShape& s2, bool perfomNow = true)\t @param perfomNow If true, the operation is performed immediately; if false, the Build() function has to be called manually\n\t @param s2 The tool shape\n\t @param s1 The argument shape\n\t @brief Compute the section of two shapes\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <boolean/BoolBRepSection.hpp>\n#include <common/CartesianCoordinateSystem.hpp>\n#include <math/LineT.hpp>\n#include <modeling/MakePrism.hpp>\n#include <modeling/MakeEdge.hpp>\n#include <modeling/MakeFace.hpp>\n#include <geometry/Geom3BezierCurve.hpp>\n#include <modeling/MakeRevol.hpp>\n#include <geometry/Geom3CylindricalSurface.hpp>\n#include <topology/TopoTool.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"bug1: BoolBRepSection \", \"[boolean][BoolBRepSection][fixbug]\")\n{\n\tLine3 line(CartesianCoordinateSystem::OZ());\n\tTopoShape infinitePlane1 = MakePrism(MakeEdge(line, 0.0, 1.0), Direction3(-1.0, 0.0, 0.0), false);\n\tTopoShape infinitePlane2 = MakePrism(MakeEdge(line, 0.0, 1.0), Direction3(1.0, 0.0, 0.0), false);\n\tTopoShape infinitePlane3 = MakePrism(MakeEdge(line, 0.0, 1.0), Direction3(0.0, 1.0, 0.0), false);\n\tTopoShape infinitePlane4 = MakePrism(MakeEdge(line, 0.0, 1.0), Direction3(0.0, -1.0, 0.0), false);\n\tstd::vector<Point3> poles{ Point3(1.0, 0.0, 0.0), Point3(0.8, 0.0, 0.5), Point3(1.0, 0.0, 1.0) };\n\tauto bz = std::make_shared<Geom3BezierCurve>(poles);\n\tTopoEdge e2 = MakeEdge(bz);\n\tTopoShape revolshape = MakeRevol(e2, CartesianCoordinateSystem::OZ());\n\tauto surface1 = std::make_shared<Geom3CylindricalSurface>(Frame3(), 1.0);\n\tauto surface2 = TopoTool::Surface(TopoCast::Face(revolshape));\n\tTopoShape result1 = BoolBRepSection(infinitePlane1, surface2); \n\tTopoShape result2 = BoolBRepSection(infinitePlane2, surface2); \n\tTopoShape result3 = BoolBRepSection(infinitePlane3, surface2); \n\tTopoShape result4 = BoolBRepSection(infinitePlane4, surface2); \n\tGlobalProperty prop1, prop2, prop3, prop4 ;\n\tCHECK( GetLinearProperties(result1, prop1, true, false) == Approx(1.0260606301));\n\tCHECK( GetLinearProperties(result2, prop1, true, false) == Approx(1.0260606301));\n\tCHECK( GetLinearProperties(result3, prop1, true, false) == Approx(1.0260606301));\n\tCHECK( GetLinearProperties(result4, prop1, true, false) == Approx(1.0260606301));\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API BoolBRepFuse(const TopoShape& s1, const TopoShape& s2)\t @param s2 The tool shape\n\t @param s1 The argument shape\n\t @brief Compute the fuse of two shapes\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <boolean/BoolBRepFuse.hpp>\n#include <boolean/BoolBRepCut.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"bug1: BoolBRepFuse \", \"[boolean][BoolBRepFuse][fixbug]\")\n{\n\tTopoShape shape1, shape2;\n\tOCCTIO::OCCTTool::Read(shape1, INPUT_PATH_PREFIX\"boolean/part.brep\");\n\tOCCTIO::OCCTTool::Read(shape2, INPUT_PATH_PREFIX\"boolean/box.brep\");\n\tTopoShape result = BoolBRepFuse(shape1, shape2);\n\tCHECK(OCCTIO::OCCTTool::Write(result, OUTPUT_PATH_PREFIX\"testbug-view-556.brep\"));\n\tIndexSet<TopoShape> shapeFace, shapeEdge, shapeVertex ,shapeSolid;\n\tCHECK( GetTopoToolCount(result, AMCAX::ShapeType::Solid, shapeSolid)==1 );\n}\t\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API BoolBRepFuse()\t @details Only set the type of boolean operation to fuse\n\t @brief Default constructor\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <boolean/BoolBRepFuse.hpp>\n#include <boolean/BoolBRepCut.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"bug1: BoolBRepFuse \", \"[boolean][BoolBRepFuse][fixbug]\")\n{\n\tTopoShape shape1, shape2;\n\tOCCTIO::OCCTTool::Read(shape1, INPUT_PATH_PREFIX\"boolean/part.brep\");\n\tOCCTIO::OCCTTool::Read(shape2, INPUT_PATH_PREFIX\"boolean/box.brep\");\n\tTopoShape result = BoolBRepFuse(shape1, shape2);\n\tCHECK(OCCTIO::OCCTTool::Write(result, OUTPUT_PATH_PREFIX\"testbug-view-556.brep\"));\n\tIndexSet<TopoShape> shapeFace, shapeEdge, shapeVertex ,shapeSolid;\n\tCHECK( GetTopoToolCount(result, AMCAX::ShapeType::Solid, shapeSolid)==1 );\n}\t\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API explicit BoolBRepDefeaturing(const TopoShape& shape)\t @param shape The shape that require remove feature\n\t @brief Construct from a shape.\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <modeling/MakeBox.hpp>\n#include <modeling/MakeCylinder.hpp>\n#include <boolean/BoolBRepCut.hpp>\n#include <topomesh/BRepMeshIncrementalMesh.hpp>\n#include <io/OBJTool.hpp>\n#include <topology/TopoFace.hpp>\n#include <geometry/Geom3Surface.hpp>\n#include <topology/TopoTool.hpp>\n#include <hatch/BRepClassificationTools.hpp>\n#include <boolean/BoolBRepDefeaturing.hpp>\n#include <topology/TopoEdge.hpp>\n#include <common/IndexSet.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"case1: test BoolBRepDefeaturing Algorithm\", \"[boolean][BRepDefeaturing]\")\n{\n\tOUTPUT_DIRECTORY(Boolean, BRepDefeaturing);\n\tTopoShape box = MakeBox(Point3(-5.0, -5.0, 0.0), Point3(5.0, 5.0, 3.0));\n\tTopoShape cyl = MakeCylinder(Frame3(Point3(0.0, 0.0, 0.0), Direction3(0.0, 0.0, 1.0)), 3.0, 5.0);\n\tTopoShape shape = BoolBRepCut(box, cyl);\n\tOCCTIO::OCCTTool::Write(shape, outdir + \"testResultTemp.brep\");\n\tBRepMeshIncrementalMesh meshT(shape, 0.01, true);\n\tOBJTool::WriteShape(shape, outdir + \"testResultTemp.obj\");\n\tIndexSet<TopoShape> shapeFace, shapeEdge, shapeVertex;\n\tCHECK(GetTopoToolCount(shape, ShapeType::Face, shapeFace) == 7);\n\tCHECK(GetTopoToolCount(shape, ShapeType::Edge, shapeEdge) == 15);\n\tCHECK(GetTopoToolCount(shape, ShapeType::Vertex, shapeVertex) == 10);\n\tTopoFace cy;\n\tstd::list<TopoShape> faceToRemove;\n\tfor (TopoExplorer expF(shape, ShapeType::Face); expF.More(); expF.Next())\n\t{\n\t\tTopoFace f = static_cast<const TopoFace&>(expF.Current());\n\t\tstd::shared_ptr<Geom3Surface> surface = TopoTool::Surface(f);\n\t\tif (surface->Type() == SurfaceType::Cylinder)\n\t\t{\n\t\t\tcy = f;\n\t\t\tOCCTIO::OCCTTool::Write(f, outdir + \"RemoveFace.brep\");\n\t\t\tfaceToRemove.push_back(f);\n\t\t}\n\t}\n\tBoolBRepDefeaturing defeature(shape);\n\tdefeature.AddFaceToRemove(faceToRemove);\n\tdefeature.Build();\n\tTopoShape newShape = defeature.Shape();\n\tPoint3 p(-3.0, 0.0, 1.0);\n\tdouble tol = -1.0;\n\tbool isIn = BRepClassificationTools::IsPointInFace(cy, p, tol);\n\tCHECK(isIn == true);\n\tfor (TopoExplorer expF(newShape, ShapeType::Face); expF.More(); expF.Next())\n\t{\n\t\tTopoFace newFace = static_cast<const TopoFace&>(expF.Current());\n\t\tbool isIn1 = BRepClassificationTools::IsPointInFace(newFace, p, tol);\n\t\tCHECK(isIn1 == false);\n\t}\n\tfor (TopoExplorer expF1(newShape, ShapeType::Face); expF1.More(); expF1.Next())\n\t{\n\t\tbool result;\n\t\tTopoFace f1 = static_cast<const TopoFace&>(expF1.Current());\n\t\tstd::shared_ptr<Geom3Surface> surface1 = TopoTool::Surface(f1);\n\t\tif (surface1->Type() == SurfaceType::Cylinder)\n\t\t{\n\t\t\tresult = false;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tresult = true;\n\t\t}\n\t\tCHECK(result == true);\n\t}\n\tAMCAX::GlobalProperty props1, props2, props3;\n\tIndexSet<TopoShape> newshapeFace, newshapeEdge, newshapeVertex;\n\tCHECK(newShape.Type() == ShapeType::Compound);\n\tCHECK(GetTopoToolCount(newShape, ShapeType::Face, newshapeFace) == 6);\n\tCHECK(GetTopoToolCount(newShape, ShapeType::Edge, newshapeEdge) == 12);\n\tCHECK(GetTopoToolCount(newShape, ShapeType::Vertex, newshapeVertex) == 8);\n\tCHECK(GetLinearProperties(newShape,props1,true,false)== Approx(10 * 8 + 3 * 4));\n\tCHECK(GetSurfaceProperties(newShape, props2, true, false) == Approx(2 * (10 * 10) + 4*(10 * 3)));\n\tCHECK(GetVolumeProperties(newShape, props3, true, false) == Approx(10*10*3));\n\tPoint3 point = props3.CenterOfMass();\n\tCHECK(point.X() == Approx(0.0).margin(1e-12));\n\tCHECK(point.Y() == Approx(0.0).margin(1e-12));\n\tCHECK(point.Z() == Approx(1.5).margin(1e-12));\n\tstd::cout << \"defeature ok \" << std::endl;\n\tOCCTIO::OCCTTool::Write(newShape, outdir + \"testResult.brep\");\n\tBRepMeshIncrementalMesh meshR(newShape, 0.01, true);\n\tOBJTool::WriteShape(newShape, outdir + \"testResult.obj\");\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API BoolBRepCut(const TopoShape& s1, const TopoShape& s2, bool isForward = true)\t @param isForward Cut s1 by s2 if true, and cut s2 by s1 if false\n\t @param s2 The tool shape\n\t @param s1 The argument shape\n\t @brief Compute the cut operation of two shapes\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <boolean/BoolBRepCut.hpp>\n#include <modeling/MakeTorus.hpp>\n#include <modeling/MakeSphere.hpp>\n#include <modeling/MakeCone.hpp>\n#include <topology/TopoExplorer.hpp>\n#include <topology/TopoFace.hpp>\n#include <hatch/BRepClassificationTools.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"bug1: in Debug mode: BoolBuilder  \", \"[boolean][BoolBRepCut][P1][fixbug]\") {\n\tTopoShape torus = MakeTorus(Frame3(Point3(0.0, 0.0, 2.0), Direction3(1.0, 0.0, 0.0)), 4.0, 2.0);\n\tTopoShape sphere = MakeSphere(4.0);\n\tTopoShape result = BoolBRepCut(sphere, torus);\n\tAMCAX::GlobalProperty prop;\n\tAMCAX::BRepGlobalProperty::VolumeProperties(result, prop);\n\tCHECK(prop.Mass() == Approx(153.229)); \n\tbool isWriteSuccess = AMCAX::OCCTIO::OCCTTool::Write(result, OUTPUT_PATH_PREFIX\"BoolBRepCut_bug72.brep\", false);\n\tCHECK(isWriteSuccess == true);\n}\n}\n,{\n"
    },
    
    {
      "instruction": "Generate a test program based on the following method declarations and parameter parsing ,\n",
      "input": "AMCAX_API BoolBRepCut()\t @details Only set the type of boolean operation to cut\n\t @brief Default constructor\n,\n",
      "output": "#include<catch.hpp>\n#include<testHelper.h>\n#include <boolean/BoolBRepCut.hpp>\n#include <modeling/MakeTorus.hpp>\n#include <modeling/MakeSphere.hpp>\n#include <modeling/MakeCone.hpp>\n#include <topology/TopoExplorer.hpp>\n#include <topology/TopoFace.hpp>\n#include <hatch/BRepClassificationTools.hpp>\nusing namespace AMCAX;\nTEST_CASE(\"bug1: in Debug mode: BoolBuilder  \", \"[boolean][BoolBRepCut][P1][fixbug]\") {\n\tTopoShape torus = MakeTorus(Frame3(Point3(0.0, 0.0, 2.0), Direction3(1.0, 0.0, 0.0)), 4.0, 2.0);\n\tTopoShape sphere = MakeSphere(4.0);\n\tTopoShape result = BoolBRepCut(sphere, torus);\n\tAMCAX::GlobalProperty prop;\n\tAMCAX::BRepGlobalProperty::VolumeProperties(result, prop);\n\tCHECK(prop.Mass() == Approx(153.229)); \n\tbool isWriteSuccess = AMCAX::OCCTIO::OCCTTool::Write(result, OUTPUT_PATH_PREFIX\"BoolBRepCut_bug72.brep\", false);\n\tCHECK(isWriteSuccess == true);\n}\n}\n,{\n"
    }
 ]
 