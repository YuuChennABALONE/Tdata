{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API BoolBRepCut()	 @details Only set the type of boolean operation to cut
	 @brief Default constructor
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <boolean/BoolBRepCut.hpp>
#include <modeling/MakeTorus.hpp>
#include <modeling/MakeSphere.hpp>
#include <modeling/MakeCone.hpp>
#include <topology/TopoExplorer.hpp>
#include <topology/TopoFace.hpp>
#include <hatch/BRepClassificationTools.hpp>
using namespace AMCAX;
TEST_CASE("bug1: in Debug mode: BoolBuilder  ", "[boolean][BoolBRepCut][P1][fixbug]") {
	TopoShape torus = MakeTorus(Frame3(Point3(0.0, 0.0, 2.0), Direction3(1.0, 0.0, 0.0)), 4.0, 2.0);
	TopoShape sphere = MakeSphere(4.0);
	TopoShape result = BoolBRepCut(sphere, torus);
	AMCAX::GlobalProperty prop;
	AMCAX::BRepGlobalProperty::VolumeProperties(result, prop);
	CHECK(prop.Mass() == Approx(153.229)); 
	bool isWriteSuccess = AMCAX::OCCTIO::OCCTTool::Write(result, OUTPUT_PATH_PREFIX"BoolBRepCut_bug72.brep", false);
	CHECK(isWriteSuccess == true);
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API BoolBRepCut(const TopoShape& s1, const TopoShape& s2, bool isForward = true)	 @param isForward Cut s1 by s2 if true, and cut s2 by s1 if false
	 @param s2 The tool shape
	 @param s1 The argument shape
	 @brief Compute the cut operation of two shapes
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <boolean/BoolBRepCut.hpp>
#include <modeling/MakeTorus.hpp>
#include <modeling/MakeSphere.hpp>
#include <modeling/MakeCone.hpp>
#include <topology/TopoExplorer.hpp>
#include <topology/TopoFace.hpp>
#include <hatch/BRepClassificationTools.hpp>
using namespace AMCAX;
TEST_CASE("bug1: in Debug mode: BoolBuilder  ", "[boolean][BoolBRepCut][P1][fixbug]") {
	TopoShape torus = MakeTorus(Frame3(Point3(0.0, 0.0, 2.0), Direction3(1.0, 0.0, 0.0)), 4.0, 2.0);
	TopoShape sphere = MakeSphere(4.0);
	TopoShape result = BoolBRepCut(sphere, torus);
	AMCAX::GlobalProperty prop;
	AMCAX::BRepGlobalProperty::VolumeProperties(result, prop);
	CHECK(prop.Mass() == Approx(153.229)); 
	bool isWriteSuccess = AMCAX::OCCTIO::OCCTTool::Write(result, OUTPUT_PATH_PREFIX"BoolBRepCut_bug72.brep", false);
	CHECK(isWriteSuccess == true);
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API explicit BoolBRepDefeaturing(const TopoShape& shape)	 @param shape The shape that require remove feature
	 @brief Construct from a shape.
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <modeling/MakeBox.hpp>
#include <modeling/MakeCylinder.hpp>
#include <boolean/BoolBRepCut.hpp>
#include <topomesh/BRepMeshIncrementalMesh.hpp>
#include <io/OBJTool.hpp>
#include <topology/TopoFace.hpp>
#include <geometry/Geom3Surface.hpp>
#include <topology/TopoTool.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <boolean/BoolBRepDefeaturing.hpp>
#include <topology/TopoEdge.hpp>
#include <common/IndexSet.hpp>
using namespace AMCAX;
TEST_CASE("case1: test BoolBRepDefeaturing Algorithm", "[boolean][BRepDefeaturing]")
{
	OUTPUT_DIRECTORY(Boolean, BRepDefeaturing);
	TopoShape box = MakeBox(Point3(-5.0, -5.0, 0.0), Point3(5.0, 5.0, 3.0));
	TopoShape cyl = MakeCylinder(Frame3(Point3(0.0, 0.0, 0.0), Direction3(0.0, 0.0, 1.0)), 3.0, 5.0);
	TopoShape shape = BoolBRepCut(box, cyl);
	OCCTIO::OCCTTool::Write(shape, outdir + "testResultTemp.brep");
	BRepMeshIncrementalMesh meshT(shape, 0.01, true);
	OBJTool::WriteShape(shape, outdir + "testResultTemp.obj");
	IndexSet<TopoShape> shapeFace, shapeEdge, shapeVertex;
	CHECK(GetTopoToolCount(shape, ShapeType::Face, shapeFace) == 7);
	CHECK(GetTopoToolCount(shape, ShapeType::Edge, shapeEdge) == 15);
	CHECK(GetTopoToolCount(shape, ShapeType::Vertex, shapeVertex) == 10);
	TopoFace cy;
	std::list<TopoShape> faceToRemove;
	for (TopoExplorer expF(shape, ShapeType::Face); expF.More(); expF.Next())
	{
		TopoFace f = static_cast<const TopoFace&>(expF.Current());
		std::shared_ptr<Geom3Surface> surface = TopoTool::Surface(f);
		if (surface->Type() == SurfaceType::Cylinder)
		{
			cy = f;
			OCCTIO::OCCTTool::Write(f, outdir + "RemoveFace.brep");
			faceToRemove.push_back(f);
		}
	}
	BoolBRepDefeaturing defeature(shape);
	defeature.AddFaceToRemove(faceToRemove);
	defeature.Build();
	TopoShape newShape = defeature.Shape();
	Point3 p(-3.0, 0.0, 1.0);
	double tol = -1.0;
	bool isIn = BRepClassificationTools::IsPointInFace(cy, p, tol);
	CHECK(isIn == true);
	for (TopoExplorer expF(newShape, ShapeType::Face); expF.More(); expF.Next())
	{
		TopoFace newFace = static_cast<const TopoFace&>(expF.Current());
		bool isIn1 = BRepClassificationTools::IsPointInFace(newFace, p, tol);
		CHECK(isIn1 == false);
	}
	for (TopoExplorer expF1(newShape, ShapeType::Face); expF1.More(); expF1.Next())
	{
		bool result;
		TopoFace f1 = static_cast<const TopoFace&>(expF1.Current());
		std::shared_ptr<Geom3Surface> surface1 = TopoTool::Surface(f1);
		if (surface1->Type() == SurfaceType::Cylinder)
		{
			result = false;
		}
		else
		{
			result = true;
		}
		CHECK(result == true);
	}
	AMCAX::GlobalProperty props1, props2, props3;
	IndexSet<TopoShape> newshapeFace, newshapeEdge, newshapeVertex;
	CHECK(newShape.Type() == ShapeType::Compound);
	CHECK(GetTopoToolCount(newShape, ShapeType::Face, newshapeFace) == 6);
	CHECK(GetTopoToolCount(newShape, ShapeType::Edge, newshapeEdge) == 12);
	CHECK(GetTopoToolCount(newShape, ShapeType::Vertex, newshapeVertex) == 8);
	CHECK(GetLinearProperties(newShape,props1,true,false)== Approx(10 * 8 + 3 * 4));
	CHECK(GetSurfaceProperties(newShape, props2, true, false) == Approx(2 * (10 * 10) + 4*(10 * 3)));
	CHECK(GetVolumeProperties(newShape, props3, true, false) == Approx(10*10*3));
	Point3 point = props3.CenterOfMass();
	CHECK(point.X() == Approx(0.0).margin(1e-12));
	CHECK(point.Y() == Approx(0.0).margin(1e-12));
	CHECK(point.Z() == Approx(1.5).margin(1e-12));
	std::cout << "defeature ok " << std::endl;
	OCCTIO::OCCTTool::Write(newShape, outdir + "testResult.brep");
	BRepMeshIncrementalMesh meshR(newShape, 0.01, true);
	OBJTool::WriteShape(newShape, outdir + "testResult.obj");
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API BoolBRepFuse()	 @details Only set the type of boolean operation to fuse
	 @brief Default constructor
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <boolean/BoolBRepFuse.hpp>
#include <boolean/BoolBRepCut.hpp>
using namespace AMCAX;
TEST_CASE("bug1: BoolBRepFuse ", "[boolean][BoolBRepFuse][fixbug]")
{
	TopoShape shape1, shape2;
	OCCTIO::OCCTTool::Read(shape1, INPUT_PATH_PREFIX"boolean/part.brep");
	OCCTIO::OCCTTool::Read(shape2, INPUT_PATH_PREFIX"boolean/box.brep");
	TopoShape result = BoolBRepFuse(shape1, shape2);
	CHECK(OCCTIO::OCCTTool::Write(result, OUTPUT_PATH_PREFIX"testbug-view-556.brep"));
	IndexSet<TopoShape> shapeFace, shapeEdge, shapeVertex ,shapeSolid;
	CHECK( GetTopoToolCount(result, AMCAX::ShapeType::Solid, shapeSolid)==1 );
}	
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API BoolBRepFuse(const TopoShape& s1, const TopoShape& s2)	 @param s2 The tool shape
	 @param s1 The argument shape
	 @brief Compute the fuse of two shapes
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <boolean/BoolBRepFuse.hpp>
#include <boolean/BoolBRepCut.hpp>
using namespace AMCAX;
TEST_CASE("bug1: BoolBRepFuse ", "[boolean][BoolBRepFuse][fixbug]")
{
	TopoShape shape1, shape2;
	OCCTIO::OCCTTool::Read(shape1, INPUT_PATH_PREFIX"boolean/part.brep");
	OCCTIO::OCCTTool::Read(shape2, INPUT_PATH_PREFIX"boolean/box.brep");
	TopoShape result = BoolBRepFuse(shape1, shape2);
	CHECK(OCCTIO::OCCTTool::Write(result, OUTPUT_PATH_PREFIX"testbug-view-556.brep"));
	IndexSet<TopoShape> shapeFace, shapeEdge, shapeVertex ,shapeSolid;
	CHECK( GetTopoToolCount(result, AMCAX::ShapeType::Solid, shapeSolid)==1 );
}	
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API BoolBRepSection(const TopoShape& s1, const TopoShape& s2, bool perfomNow = true)	 @param perfomNow If true, the operation is performed immediately; if false, the Build() function has to be called manually
	 @param s2 The tool shape
	 @param s1 The argument shape
	 @brief Compute the section of two shapes
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <boolean/BoolBRepSection.hpp>
#include <common/CartesianCoordinateSystem.hpp>
#include <math/LineT.hpp>
#include <modeling/MakePrism.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeFace.hpp>
#include <geometry/Geom3BezierCurve.hpp>
#include <modeling/MakeRevol.hpp>
#include <geometry/Geom3CylindricalSurface.hpp>
#include <topology/TopoTool.hpp>
using namespace AMCAX;
TEST_CASE("bug1: BoolBRepSection ", "[boolean][BoolBRepSection][fixbug]")
{
	Line3 line(CartesianCoordinateSystem::OZ());
	TopoShape infinitePlane1 = MakePrism(MakeEdge(line, 0.0, 1.0), Direction3(-1.0, 0.0, 0.0), false);
	TopoShape infinitePlane2 = MakePrism(MakeEdge(line, 0.0, 1.0), Direction3(1.0, 0.0, 0.0), false);
	TopoShape infinitePlane3 = MakePrism(MakeEdge(line, 0.0, 1.0), Direction3(0.0, 1.0, 0.0), false);
	TopoShape infinitePlane4 = MakePrism(MakeEdge(line, 0.0, 1.0), Direction3(0.0, -1.0, 0.0), false);
	std::vector<Point3> poles{ Point3(1.0, 0.0, 0.0), Point3(0.8, 0.0, 0.5), Point3(1.0, 0.0, 1.0) };
	auto bz = std::make_shared<Geom3BezierCurve>(poles);
	TopoEdge e2 = MakeEdge(bz);
	TopoShape revolshape = MakeRevol(e2, CartesianCoordinateSystem::OZ());
	auto surface1 = std::make_shared<Geom3CylindricalSurface>(Frame3(), 1.0);
	auto surface2 = TopoTool::Surface(TopoCast::Face(revolshape));
	TopoShape result1 = BoolBRepSection(infinitePlane1, surface2); 
	TopoShape result2 = BoolBRepSection(infinitePlane2, surface2); 
	TopoShape result3 = BoolBRepSection(infinitePlane3, surface2); 
	TopoShape result4 = BoolBRepSection(infinitePlane4, surface2); 
	GlobalProperty prop1, prop2, prop3, prop4 ;
	CHECK( GetLinearProperties(result1, prop1, true, false) == Approx(1.0260606301));
	CHECK( GetLinearProperties(result2, prop1, true, false) == Approx(1.0260606301));
	CHECK( GetLinearProperties(result3, prop1, true, false) == Approx(1.0260606301));
	CHECK( GetLinearProperties(result4, prop1, true, false) == Approx(1.0260606301));
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API BoolBRepSection(const TopoShape& s1, const Plane& p1, bool perfomNow = true)	 @param perfomNow If true, the operation is performed immediately; if false, the Build() function has to be called manually
	 @param p1 The tool plane
	 @param s1 The argument shape
	 @brief Special case: compute the section of a shape and an infinite plane
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <boolean/BoolBRepSection.hpp>
#include <common/CartesianCoordinateSystem.hpp>
#include <math/LineT.hpp>
#include <modeling/MakePrism.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeFace.hpp>
#include <geometry/Geom3BezierCurve.hpp>
#include <modeling/MakeRevol.hpp>
#include <geometry/Geom3CylindricalSurface.hpp>
#include <topology/TopoTool.hpp>
using namespace AMCAX;
TEST_CASE("bug1: BoolBRepSection ", "[boolean][BoolBRepSection][fixbug]")
{
	Line3 line(CartesianCoordinateSystem::OZ());
	TopoShape infinitePlane1 = MakePrism(MakeEdge(line, 0.0, 1.0), Direction3(-1.0, 0.0, 0.0), false);
	TopoShape infinitePlane2 = MakePrism(MakeEdge(line, 0.0, 1.0), Direction3(1.0, 0.0, 0.0), false);
	TopoShape infinitePlane3 = MakePrism(MakeEdge(line, 0.0, 1.0), Direction3(0.0, 1.0, 0.0), false);
	TopoShape infinitePlane4 = MakePrism(MakeEdge(line, 0.0, 1.0), Direction3(0.0, -1.0, 0.0), false);
	std::vector<Point3> poles{ Point3(1.0, 0.0, 0.0), Point3(0.8, 0.0, 0.5), Point3(1.0, 0.0, 1.0) };
	auto bz = std::make_shared<Geom3BezierCurve>(poles);
	TopoEdge e2 = MakeEdge(bz);
	TopoShape revolshape = MakeRevol(e2, CartesianCoordinateSystem::OZ());
	auto surface1 = std::make_shared<Geom3CylindricalSurface>(Frame3(), 1.0);
	auto surface2 = TopoTool::Surface(TopoCast::Face(revolshape));
	TopoShape result1 = BoolBRepSection(infinitePlane1, surface2); 
	TopoShape result2 = BoolBRepSection(infinitePlane2, surface2); 
	TopoShape result3 = BoolBRepSection(infinitePlane3, surface2); 
	TopoShape result4 = BoolBRepSection(infinitePlane4, surface2); 
	GlobalProperty prop1, prop2, prop3, prop4 ;
	CHECK( GetLinearProperties(result1, prop1, true, false) == Approx(1.0260606301));
	CHECK( GetLinearProperties(result2, prop1, true, false) == Approx(1.0260606301));
	CHECK( GetLinearProperties(result3, prop1, true, false) == Approx(1.0260606301));
	CHECK( GetLinearProperties(result4, prop1, true, false) == Approx(1.0260606301));
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API BoolBRepSection(const TopoShape& s1, const std::shared_ptr<Geom3Surface>& surface, bool perfomNow = true)	 @param perfomNow If true, the operation is performed immediately; if false, the Build() function has to be called manually
	 @param surface The tool surface
	 @param s1 The argument shape
	 @brief Special case: compute the section of a shape and a surface
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <boolean/BoolBRepSection.hpp>
#include <common/CartesianCoordinateSystem.hpp>
#include <math/LineT.hpp>
#include <modeling/MakePrism.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeFace.hpp>
#include <geometry/Geom3BezierCurve.hpp>
#include <modeling/MakeRevol.hpp>
#include <geometry/Geom3CylindricalSurface.hpp>
#include <topology/TopoTool.hpp>
using namespace AMCAX;
TEST_CASE("bug1: BoolBRepSection ", "[boolean][BoolBRepSection][fixbug]")
{
	Line3 line(CartesianCoordinateSystem::OZ());
	TopoShape infinitePlane1 = MakePrism(MakeEdge(line, 0.0, 1.0), Direction3(-1.0, 0.0, 0.0), false);
	TopoShape infinitePlane2 = MakePrism(MakeEdge(line, 0.0, 1.0), Direction3(1.0, 0.0, 0.0), false);
	TopoShape infinitePlane3 = MakePrism(MakeEdge(line, 0.0, 1.0), Direction3(0.0, 1.0, 0.0), false);
	TopoShape infinitePlane4 = MakePrism(MakeEdge(line, 0.0, 1.0), Direction3(0.0, -1.0, 0.0), false);
	std::vector<Point3> poles{ Point3(1.0, 0.0, 0.0), Point3(0.8, 0.0, 0.5), Point3(1.0, 0.0, 1.0) };
	auto bz = std::make_shared<Geom3BezierCurve>(poles);
	TopoEdge e2 = MakeEdge(bz);
	TopoShape revolshape = MakeRevol(e2, CartesianCoordinateSystem::OZ());
	auto surface1 = std::make_shared<Geom3CylindricalSurface>(Frame3(), 1.0);
	auto surface2 = TopoTool::Surface(TopoCast::Face(revolshape));
	TopoShape result1 = BoolBRepSection(infinitePlane1, surface2); 
	TopoShape result2 = BoolBRepSection(infinitePlane2, surface2); 
	TopoShape result3 = BoolBRepSection(infinitePlane3, surface2); 
	TopoShape result4 = BoolBRepSection(infinitePlane4, surface2); 
	GlobalProperty prop1, prop2, prop3, prop4 ;
	CHECK( GetLinearProperties(result1, prop1, true, false) == Approx(1.0260606301));
	CHECK( GetLinearProperties(result2, prop1, true, false) == Approx(1.0260606301));
	CHECK( GetLinearProperties(result3, prop1, true, false) == Approx(1.0260606301));
	CHECK( GetLinearProperties(result4, prop1, true, false) == Approx(1.0260606301));
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API BoolBRepSection(const std::shared_ptr<Geom3Surface>& surface, const TopoShape& s2, bool perfomNow = true)	 @param perfomNow If true, the operation is performed immediately; if false, the Build() function has to be called manually
	 @param s2 The tool shape
	 @param surface The argument surface
	 @brief Special case: compute the section of a surface and a shape
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <boolean/BoolBRepSection.hpp>
#include <common/CartesianCoordinateSystem.hpp>
#include <math/LineT.hpp>
#include <modeling/MakePrism.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeFace.hpp>
#include <geometry/Geom3BezierCurve.hpp>
#include <modeling/MakeRevol.hpp>
#include <geometry/Geom3CylindricalSurface.hpp>
#include <topology/TopoTool.hpp>
using namespace AMCAX;
TEST_CASE("bug1: BoolBRepSection ", "[boolean][BoolBRepSection][fixbug]")
{
	Line3 line(CartesianCoordinateSystem::OZ());
	TopoShape infinitePlane1 = MakePrism(MakeEdge(line, 0.0, 1.0), Direction3(-1.0, 0.0, 0.0), false);
	TopoShape infinitePlane2 = MakePrism(MakeEdge(line, 0.0, 1.0), Direction3(1.0, 0.0, 0.0), false);
	TopoShape infinitePlane3 = MakePrism(MakeEdge(line, 0.0, 1.0), Direction3(0.0, 1.0, 0.0), false);
	TopoShape infinitePlane4 = MakePrism(MakeEdge(line, 0.0, 1.0), Direction3(0.0, -1.0, 0.0), false);
	std::vector<Point3> poles{ Point3(1.0, 0.0, 0.0), Point3(0.8, 0.0, 0.5), Point3(1.0, 0.0, 1.0) };
	auto bz = std::make_shared<Geom3BezierCurve>(poles);
	TopoEdge e2 = MakeEdge(bz);
	TopoShape revolshape = MakeRevol(e2, CartesianCoordinateSystem::OZ());
	auto surface1 = std::make_shared<Geom3CylindricalSurface>(Frame3(), 1.0);
	auto surface2 = TopoTool::Surface(TopoCast::Face(revolshape));
	TopoShape result1 = BoolBRepSection(infinitePlane1, surface2); 
	TopoShape result2 = BoolBRepSection(infinitePlane2, surface2); 
	TopoShape result3 = BoolBRepSection(infinitePlane3, surface2); 
	TopoShape result4 = BoolBRepSection(infinitePlane4, surface2); 
	GlobalProperty prop1, prop2, prop3, prop4 ;
	CHECK( GetLinearProperties(result1, prop1, true, false) == Approx(1.0260606301));
	CHECK( GetLinearProperties(result2, prop1, true, false) == Approx(1.0260606301));
	CHECK( GetLinearProperties(result3, prop1, true, false) == Approx(1.0260606301));
	CHECK( GetLinearProperties(result4, prop1, true, false) == Approx(1.0260606301));
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API BoolBRepSection(const std::shared_ptr<Geom3Surface>& s1, const std::shared_ptr<Geom3Surface>& s2, bool perfomNow = true)	 @param perfomNow If true, the operation is performed immediately; if false, the Build() function has to be called manually
	 @param s2 The tool surface
	 @param s1 The argument surface
	 @brief Special case: compute the section of two surfaces
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <boolean/BoolBRepSection.hpp>
#include <common/CartesianCoordinateSystem.hpp>
#include <math/LineT.hpp>
#include <modeling/MakePrism.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeFace.hpp>
#include <geometry/Geom3BezierCurve.hpp>
#include <modeling/MakeRevol.hpp>
#include <geometry/Geom3CylindricalSurface.hpp>
#include <topology/TopoTool.hpp>
using namespace AMCAX;
TEST_CASE("bug1: BoolBRepSection ", "[boolean][BoolBRepSection][fixbug]")
{
	Line3 line(CartesianCoordinateSystem::OZ());
	TopoShape infinitePlane1 = MakePrism(MakeEdge(line, 0.0, 1.0), Direction3(-1.0, 0.0, 0.0), false);
	TopoShape infinitePlane2 = MakePrism(MakeEdge(line, 0.0, 1.0), Direction3(1.0, 0.0, 0.0), false);
	TopoShape infinitePlane3 = MakePrism(MakeEdge(line, 0.0, 1.0), Direction3(0.0, 1.0, 0.0), false);
	TopoShape infinitePlane4 = MakePrism(MakeEdge(line, 0.0, 1.0), Direction3(0.0, -1.0, 0.0), false);
	std::vector<Point3> poles{ Point3(1.0, 0.0, 0.0), Point3(0.8, 0.0, 0.5), Point3(1.0, 0.0, 1.0) };
	auto bz = std::make_shared<Geom3BezierCurve>(poles);
	TopoEdge e2 = MakeEdge(bz);
	TopoShape revolshape = MakeRevol(e2, CartesianCoordinateSystem::OZ());
	auto surface1 = std::make_shared<Geom3CylindricalSurface>(Frame3(), 1.0);
	auto surface2 = TopoTool::Surface(TopoCast::Face(revolshape));
	TopoShape result1 = BoolBRepSection(infinitePlane1, surface2); 
	TopoShape result2 = BoolBRepSection(infinitePlane2, surface2); 
	TopoShape result3 = BoolBRepSection(infinitePlane3, surface2); 
	TopoShape result4 = BoolBRepSection(infinitePlane4, surface2); 
	GlobalProperty prop1, prop2, prop3, prop4 ;
	CHECK( GetLinearProperties(result1, prop1, true, false) == Approx(1.0260606301));
	CHECK( GetLinearProperties(result2, prop1, true, false) == Approx(1.0260606301));
	CHECK( GetLinearProperties(result3, prop1, true, false) == Approx(1.0260606301));
	CHECK( GetLinearProperties(result4, prop1, true, false) == Approx(1.0260606301));
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API void SimplifyResult(bool isUnfiyEdges = true, bool isUnifyFaces = true, double angularTol = Precision::Angular()	 @param angularTol The angular tolerance for checking parallel
	 @param isUnifyFaces Set whether unify faces
	 @param isUnfiyEdges Set whether unify edges
	 @brief Simplify the boolean result, remove redundant edges and faces
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <boolean/BoolBuilder.hpp>
#include <modeling/MakeBox.hpp>
#include <boolean/BoolBRepFuse.hpp>
#include <common/IndexSet.hpp>
#include <topology/TopoExplorerTool.hpp>
using namespace AMCAX;
TEST_CASE("case1: BoolBuilder added SimplifyResult() API at 3.6.0. ", "[boolean][BoolBuilder][P1]") {
	TopoShape box1 = MakeBox(Point3(0., 0., 0.), Point3(2., 2., 2.));
	TopoShape box2 = MakeBox(Point3(1., 1., 0.), Point3(3., 3., 2.));
	BoolBRepFuse fuse(box1, box2);
	TopoShape shape1 = fuse.Shape();
	fuse.SimplifyResult();
	TopoShape shape2 = fuse.Shape();
	IndexSet<TopoShape> shape1Faces, shape2Faces;
	TopoExplorerTool::MapShapes(shape1, ShapeType::Face, shape1Faces);
	TopoExplorerTool::MapShapes(shape2, ShapeType::Face, shape2Faces);
	std::cout << shape1Faces.size() << "  " << shape2Faces.size() << std::endl;
	CHECK(shape1Faces.size() == 14);
	CHECK(shape2Faces.size() == 10);
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar, typename OtherScalar2> AxisT(const PointT<OtherScalar, DIM>& point, const DirectionT<OtherScalar2, DIM>& dir),
 "output":#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {
	return result.Location().IsEqual(expected.Location(), tol) &&
		result.Direction().IsEqual(expected.Direction(), tol);
}
TEST_CASE("case1:this is a case for Axis2", "[Common][Axis2]") {
	SECTION("IsCoaxial 2D") {
		AxisT<double, 2> a1(PointT<double, 2>{0.0, 0.0}, DirectionT<double, 2>{1.0, 2.0});
		AxisT<double, 2> a2(PointT<double, 2>{2.0, 4.0}, DirectionT<double, 2>{1.0, 2.0});
		AxisT<double, 2> a3(PointT<double, 2>{2.0, 4.0}, DirectionT<double, 2>{2.0, 2.0});
		AxisT<double, 2> a4(PointT<double, 2>{1.0, 4.0}, DirectionT<double, 2>{1.0, 2.0});
		CHECK(a1.IsCoaxial(a2, 1e-6, 1e-6) == true);
		CHECK(a1.IsCoaxial(a3, 1e-6, 1e-6) == false);
		CHECK(a1.IsCoaxial(a4, 1e-6, 1e-6) == false);
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar, typename OtherScalar2, typename OtherScalar3, int DIM2 = DIM, std::enable_if_t<DIM2 == 2, int> = 0> [[nodiscard]] bool IsCoaxial(const AxisT<OtherScalar, DIM>& other, const OtherScalar2& angtol, const OtherScalar3& distol),
 "output":#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {
	return result.Location().IsEqual(expected.Location(), tol) &&
		result.Direction().IsEqual(expected.Direction(), tol);
}
TEST_CASE("case1:this is a case for Axis2", "[Common][Axis2]") {
	SECTION("IsCoaxial 2D") {
		AxisT<double, 2> a1(PointT<double, 2>{0.0, 0.0}, DirectionT<double, 2>{1.0, 2.0});
		AxisT<double, 2> a2(PointT<double, 2>{2.0, 4.0}, DirectionT<double, 2>{1.0, 2.0});
		AxisT<double, 2> a3(PointT<double, 2>{2.0, 4.0}, DirectionT<double, 2>{2.0, 2.0});
		AxisT<double, 2> a4(PointT<double, 2>{1.0, 4.0}, DirectionT<double, 2>{1.0, 2.0});
		CHECK(a1.IsCoaxial(a2, 1e-6, 1e-6) == true);
		CHECK(a1.IsCoaxial(a3, 1e-6, 1e-6) == false);
		CHECK(a1.IsCoaxial(a4, 1e-6, 1e-6) == false);
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar> AxisT& Mirror(const PointT<OtherScalar, DIM>& point),
 "output":#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {
	return result.Location().IsEqual(expected.Location(), tol) &&
		result.Direction().IsEqual(expected.Direction(), tol);
}
TEST_CASE("case1:this is a case for Axis2", "[Common][Axis2]") {
	SECTION("Mirror(point) 2D") {
		AxisT<double, 2> a1(PointT<double, 2>{1.0, 2.0}, DirectionT<double, 2>{1.0, 1.0});
		PointT<double, 2> p(3.0, 4.0);
		AxisT<double, 2> a2(PointT<double, 2>{5.0, 6.0}, DirectionT<double, 2>{-1.0, -1.0});
		CHECK(IsEqual(a1.Mirrored(p), a2));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar> [[nodiscard]] AxisT Mirrored(const PointT<OtherScalar, DIM>& point),
 "output":#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {
	return result.Location().IsEqual(expected.Location(), tol) &&
		result.Direction().IsEqual(expected.Direction(), tol);
}
TEST_CASE("case1:this is a case for Axis2", "[Common][Axis2]") {
	SECTION("Mirror(point) 2D") {
		AxisT<double, 2> a1(PointT<double, 2>{1.0, 2.0}, DirectionT<double, 2>{1.0, 1.0});
		PointT<double, 2> p(3.0, 4.0);
		AxisT<double, 2> a2(PointT<double, 2>{5.0, 6.0}, DirectionT<double, 2>{-1.0, -1.0});
		CHECK(IsEqual(a1.Mirrored(p), a2));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar, typename OtherScalar2> [[nodiscard]] AxisT Scaled(const PointT<OtherScalar, DIM> point, const OtherScalar2& scale),
 "output":#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {
	return result.Location().IsEqual(expected.Location(), tol) &&
		result.Direction().IsEqual(expected.Direction(), tol);
}
TEST_CASE("case1:this is a case for Axis2", "[Common][Axis2]") {
	SECTION("Scale 2D") {
		AxisT<double, 2> a1(PointT<double, 2>{1.0, 2.0}, DirectionT<double, 2>{1.0, 2.0});
		PointT<double, 2> p(2.0, 3.0);
		AxisT<double, 2> a2(PointT<double, 2>{0.5, 1.5}, DirectionT<double, 2>{1.0, 2.0});
		CHECK(IsEqual(a1.Scaled(p, 1.5), a2));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar, typename OtherScalar2> AxisT& Translate(const PointT<OtherScalar, DIM>& p1, const PointT<OtherScalar2, DIM>& p2),
 "output":#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {
	return result.Location().IsEqual(expected.Location(), tol) &&
		result.Direction().IsEqual(expected.Direction(), tol);
}
TEST_CASE("case1:this is a case for Axis2", "[Common][Axis2]") {
	SECTION("Translate(p1, p2) 2D") {
		AxisT<double, 2> a1(PointT<double, 2>(1.0, 2.0), DirectionT<double, 2>{1.0, 2.0});
		PointT<double, 2> p1(2.0, 3.0);
		PointT<double, 2> p2(4.0, 2.0);
		AxisT<double, 2> a2(PointT<double, 2>(3.0, 1.0), DirectionT<double, 2>{1.0, 2.0});
		CHECK(IsEqual(a1.Translated(p1, p2), a2));
	}
}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AxisT()	 @details The default location is (0, 0, 0). In 2D, the default direction is (1, 0); in 3D, the default direction is (0, 0, 1).
	 @brief Default constructor
,
 "output":#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected){
	return result.Location().IsEqual(expected.Location(), tol) &&
		result.Direction().IsEqual(expected.Direction(), tol);
}
TEST_CASE("case1:this is a case for Axis3","[Common][Axis3]")
{
	int i = 1;
	SECTION("default constructor 3D"){
		AxisT<double, 3> a1;
		AxisT<double, 3> a2(PointT<double, 3>{0.0, 0.0, 0.0}, DirectionT<double, 3>{0.0, 0.0, 1.0});
		CHECK(IsEqual(a1, a2));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar, typename OtherScalar2> AxisT(const PointT<OtherScalar, DIM>& point, const DirectionT<OtherScalar2, DIM>& dir),
 "output":#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected){
	return result.Location().IsEqual(expected.Location(), tol) &&
		result.Direction().IsEqual(expected.Direction(), tol);
}
TEST_CASE("case1:this is a case for Axis3","[Common][Axis3]")
{
	int i = 1;
	SECTION("Reverse"){
		AxisT<double, 3> a1(PointT<double, 3>{1.0, 2.0, 3.0}, DirectionT<double, 3>{1.0, 2.0, 1.0});
		AxisT<double, 3> a2(PointT<double, 3>{1.0, 2.0, 3.0}, DirectionT<double, 3>{-1.0, -2.0, -1.0});
		CHECK(IsEqual(a1.Reversed(), a2));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar> void SetDirection(const DirectionT<OtherScalar, DIM>& dir),
 "output":#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected){
	return result.Location().IsEqual(expected.Location(), tol) &&
		result.Direction().IsEqual(expected.Direction(), tol);
}
TEST_CASE("case1:this is a case for Axis3","[Common][Axis3]")
{
	int i = 1;
	SECTION("SetDirection"){
		AxisT<double, 3> a1;
		DirectionT<double, 3> d(1.0, 2.0, 3.0);
		a1.SetDirection(d);
		AxisT<double, 3> a2(PointT<double, 3>{0.0, 0.0, 0.0}, d);
		CHECK(IsEqual(a1, a2));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar, typename OtherScalar2, typename OtherScalar3, int DIM2 = DIM, std::enable_if_t<DIM2 == 2, int> = 0> [[nodiscard]] bool IsCoaxial(const AxisT<OtherScalar, DIM>& other, const OtherScalar2& angtol, const OtherScalar3& distol),
 "output":#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected){
	return result.Location().IsEqual(expected.Location(), tol) &&
		result.Direction().IsEqual(expected.Direction(), tol);
}
TEST_CASE("case1:this is a case for Axis3","[Common][Axis3]")
{
	int i = 1;
	SECTION("IsCoaxial 3D"){
		AxisT<double, 3> a1(PointT<double, 3>{0.0, 0.0, 0.0}, DirectionT<double, 3>{1.0, 2.0, 3.0});
		AxisT<double, 3> a2(PointT<double, 3>{2.0, 4.0, 6.0}, DirectionT<double, 3>{1.0, 2.0, 3.0});
		AxisT<double, 3> a3(PointT<double, 3>{2.0, 4.0, 6.0}, DirectionT<double, 3>{2.0, 2.0, 3.0});
		AxisT<double, 3> a4(PointT<double, 3>{1.0, 4.0, 6.0}, DirectionT<double, 3>{1.0, 2.0, 3.0});
		CHECK(a1.IsCoaxial(a2, 1e-6, 1e-6) == true);
		CHECK(a1.IsCoaxial(a3, 1e-6, 1e-6) == false);
		CHECK(a1.IsCoaxial(a4, 1e-6, 1e-6) == false);
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar, typename OtherScalar2, typename OtherScalar3, int DIM2 = DIM, std::enable_if_t<DIM2 == 3, int> = 0> [[nodiscard]] bool IsCoaxial(const AxisT<OtherScalar, DIM>& other, const OtherScalar2& angtol, const OtherScalar3& distol),
 "output":#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected){
	return result.Location().IsEqual(expected.Location(), tol) &&
		result.Direction().IsEqual(expected.Direction(), tol);
}
TEST_CASE("case1:this is a case for Axis3","[Common][Axis3]")
{
	int i = 1;
	SECTION("IsCoaxial 3D"){
		AxisT<double, 3> a1(PointT<double, 3>{0.0, 0.0, 0.0}, DirectionT<double, 3>{1.0, 2.0, 3.0});
		AxisT<double, 3> a2(PointT<double, 3>{2.0, 4.0, 6.0}, DirectionT<double, 3>{1.0, 2.0, 3.0});
		AxisT<double, 3> a3(PointT<double, 3>{2.0, 4.0, 6.0}, DirectionT<double, 3>{2.0, 2.0, 3.0});
		AxisT<double, 3> a4(PointT<double, 3>{1.0, 4.0, 6.0}, DirectionT<double, 3>{1.0, 2.0, 3.0});
		CHECK(a1.IsCoaxial(a2, 1e-6, 1e-6) == true);
		CHECK(a1.IsCoaxial(a3, 1e-6, 1e-6) == false);
		CHECK(a1.IsCoaxial(a4, 1e-6, 1e-6) == false);
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar, typename OtherScalar2> [[nodiscard]] bool IsNormal(const AxisT<OtherScalar, DIM>& other, const OtherScalar2& tol),
 "output":#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected){
	return result.Location().IsEqual(expected.Location(), tol) &&
		result.Direction().IsEqual(expected.Direction(), tol);
}
TEST_CASE("case1:this is a case for Axis3","[Common][Axis3]")
{
	int i = 1;
	SECTION("IsNormal"){
		AxisT<double, 3> a1(PointT<double, 3>{0.0, 0.0, 0.0}, DirectionT<double, 3>{1.0, 2.0, 1.0});
		AxisT<double, 3> a2(PointT<double, 3>{2.0, 4.0, 3.0}, DirectionT<double, 3>{-1.0, 1.0, -1.0});
		CHECK(a1.IsNormal(a2, 1e-6) == true);
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar, typename OtherScalar2> [[nodiscard]] bool IsOpposite(const AxisT<OtherScalar, DIM>& other, const OtherScalar2& tol),
 "output":#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected){
	return result.Location().IsEqual(expected.Location(), tol) &&
		result.Direction().IsEqual(expected.Direction(), tol);
}
TEST_CASE("case1:this is a case for Axis3","[Common][Axis3]")
{
	int i = 1;
	SECTION("IsOpposite"){
		AxisT<double, 3> a1(PointT<double, 3>{0.0, 0.0, 0.0}, DirectionT<double, 3>{1.0, 2.0, 1.0});
		AxisT<double, 3> a2(PointT<double, 3>{2.0, 4.0, 3.0}, DirectionT<double, 3>{-1.0, -2.0, -1.0});
		CHECK(a1.IsOpposite(a2, 1e-6) == true);
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar, typename OtherScalar2> [[nodiscard]] bool IsParallel(const AxisT<OtherScalar, DIM>& other, const OtherScalar2& tol),
 "output":#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected){
	return result.Location().IsEqual(expected.Location(), tol) &&
		result.Direction().IsEqual(expected.Direction(), tol);
}
TEST_CASE("case1:this is a case for Axis3","[Common][Axis3]")
{
	int i = 1;
	SECTION("IsParallel"){
		AxisT<double, 3> a1(PointT<double, 3>{0.0, 0.0, 0.0}, DirectionT<double, 3>{1.0, 2.0, 1.0});
		AxisT<double, 3> a2(PointT<double, 3>{2.0, 4.0, 3.0}, DirectionT<double, 3>{-1.0, -2.0, -1.0});
		CHECK(a1.IsParallel(a2, 1e-6) == true);
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar> [[nodiscard]] double Angle(const AxisT<OtherScalar, DIM>& other),
 "output":#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected){
	return result.Location().IsEqual(expected.Location(), tol) &&
		result.Direction().IsEqual(expected.Direction(), tol);
}
TEST_CASE("case1:this is a case for Axis3","[Common][Axis3]")
{
	int i = 1;
	SECTION("Angle"){
		AxisT<double, 3> a1(PointT<double, 3>{0.0, 0.0, 0.0}, DirectionT<double, 3>{1.0, 2.0, 1.0});
		AxisT<double, 3> a2(PointT<double, 3>{2.0, 4.0, 3.0}, DirectionT<double, 3>{-1.0, 1.0, -1.0});
		CHECK(a1.Angle(a2) == M_PI_2);
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar> AxisT& Mirror(const AxisT<OtherScalar, DIM>& axis),
 "output":#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected){
	return result.Location().IsEqual(expected.Location(), tol) &&
		result.Direction().IsEqual(expected.Direction(), tol);
}
TEST_CASE("case1:this is a case for Axis3","[Common][Axis3]")
{
	int i = 1;
	SECTION("Mirror(axis) 3D"){
		AxisT<double, 3> a1(PointT<double, 3>{1.0, 2.0, 3.0}, DirectionT<double, 3>{1.0, 2.0, 3.0});
		AxisT<double, 3> a2(PointT<double, 3>{2.0, 3.0, 4.0}, DirectionT<double, 3>{7.0, 3.0, 2.0});
		AxisT<double, 3> a3(PointT<double, 3>{9.0 / 31.0, 88.0 / 31.0, 131.0 / 31.0}, DirectionT<double, 3>{102.0 / 31.0, -5.0 / 31.0, -55.0 / 31.0});
		CHECK(IsEqual(a1.Mirrored(a2), a3));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar, int DIM2 = DIM, std::enable_if_t<DIM2 == 3, int> = 0> AxisT& Mirror(const FrameT<OtherScalar, DIM>& frame),
 "output":#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected){
	return result.Location().IsEqual(expected.Location(), tol) &&
		result.Direction().IsEqual(expected.Direction(), tol);
}
TEST_CASE("case1:this is a case for Axis3","[Common][Axis3]")
{
	int i = 1;
	SECTION("Mirror(frame) 3D"){
		AxisT<double, 3> a1(PointT<double, 3>{1.0, 2.0, 3.0}, DirectionT<double, 3>{1.0, 2.0, 3.0});
		FrameT<double, 3> f(PointT<double, 3>{2.0, 3.0, 4.0}, DirectionT<double, 3>{7.0, 3.0, 2.0});
		AxisT<double, 3> a2(PointT<double, 3>{115.0 / 31.0, 98.0 / 31.0, 117.0 / 31.0}, DirectionT<double, 3>{-102.0 / 31.0, 5.0 / 31.0, 55.0 / 31.0});
		CHECK(IsEqual(a1.Mirror(f), a2));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar> [[nodiscard]] AxisT Mirrored(const AxisT<OtherScalar, DIM>& axis),
 "output":#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected){
	return result.Location().IsEqual(expected.Location(), tol) &&
		result.Direction().IsEqual(expected.Direction(), tol);
}
TEST_CASE("case1:this is a case for Axis3","[Common][Axis3]")
{
	int i = 1;
	SECTION("Mirror(axis) 3D"){
		AxisT<double, 3> a1(PointT<double, 3>{1.0, 2.0, 3.0}, DirectionT<double, 3>{1.0, 2.0, 3.0});
		AxisT<double, 3> a2(PointT<double, 3>{2.0, 3.0, 4.0}, DirectionT<double, 3>{7.0, 3.0, 2.0});
		AxisT<double, 3> a3(PointT<double, 3>{9.0 / 31.0, 88.0 / 31.0, 131.0 / 31.0}, DirectionT<double, 3>{102.0 / 31.0, -5.0 / 31.0, -55.0 / 31.0});
		CHECK(IsEqual(a1.Mirrored(a2), a3));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar, int DIM2 = DIM, std::enable_if_t<DIM2 == 3, int> = 0> [[nodiscard]] AxisT Mirrored(const FrameT<OtherScalar, DIM>& frame),
 "output":#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected){
	return result.Location().IsEqual(expected.Location(), tol) &&
		result.Direction().IsEqual(expected.Direction(), tol);
}
TEST_CASE("case1:this is a case for Axis3","[Common][Axis3]")
{
	int i = 1;
	SECTION("Mirror(axis) 3D"){
		AxisT<double, 3> a1(PointT<double, 3>{1.0, 2.0, 3.0}, DirectionT<double, 3>{1.0, 2.0, 3.0});
		AxisT<double, 3> a2(PointT<double, 3>{2.0, 3.0, 4.0}, DirectionT<double, 3>{7.0, 3.0, 2.0});
		AxisT<double, 3> a3(PointT<double, 3>{9.0 / 31.0, 88.0 / 31.0, 131.0 / 31.0}, DirectionT<double, 3>{102.0 / 31.0, -5.0 / 31.0, -55.0 / 31.0});
		CHECK(IsEqual(a1.Mirrored(a2), a3));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar, typename OtherScalar2, int DIM2 = DIM, typename = typename std::enable_if_t<DIM2 == 3>> AxisT& Rotate(const AxisT<OtherScalar, DIM>& axis, const OtherScalar2& angle),
 "output":#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected){
	return result.Location().IsEqual(expected.Location(), tol) &&
		result.Direction().IsEqual(expected.Direction(), tol);
}
TEST_CASE("case1:this is a case for Axis3","[Common][Axis3]")
{
	int i = 1;
	SECTION("Rotate 3D"){
		AxisT<double, 3> a1(PointT<double, 3>{1.0, 2.0, 3.0}, DirectionT<double, 3>{1.0, 2.0, 3.0});
		AxisT<double, 3> a2(PointT<double, 3>{2.0, 3.0, 4.0}, DirectionT<double, 3>{1.0, 1.0, 2.0});
		AxisT<double, 3> a3(PointT<double, 3>{(8.0 + std::sqrt(6.0)) / 6.0, (14.0 - std::sqrt(6.0)) / 6.0, 8.0 / 3.0}, DirectionT<double, 3>{(9.0 - std::sqrt(6.0)) / 6.0, (9.0 - std::sqrt(6.0)) / 6.0, 3.0 + 1.0 / std::sqrt(6.0)});
		CHECK(IsEqual(a1.Rotated(a2, M_PI_2), a3));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar, typename OtherScalar2> [[nodiscard]] AxisT Scaled(const PointT<OtherScalar, DIM> point, const OtherScalar2& scale),
 "output":#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected){
	return result.Location().IsEqual(expected.Location(), tol) &&
		result.Direction().IsEqual(expected.Direction(), tol);
}
TEST_CASE("case1:this is a case for Axis3","[Common][Axis3]")
{
	int i = 1;
	SECTION("Scale 3D"){
		AxisT<double, 3> a1(PointT<double, 3>{1.0, 2.0, 3.0}, DirectionT<double, 3>{1.0, 2.0, 3.0});
		PointT<double, 3> p(2.0, 3.0, 4.0);
		AxisT<double, 3> a2(PointT<double, 3>{0.5, 1.5, 2.5}, DirectionT<double, 3>{1.0, 2.0, 3.0});
		CHECK(IsEqual(a1.Scaled(p, 1.5), a2));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] const PointT<Scalar, DIM>& Location()	 @return The location
	 @brief Get the location
,
 "output":#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);
	}
	else if constexpr (DIM == 2)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else if constexpr (DIM == 3)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else
	{
		return false;
	}
}
TEST_CASE("case1:this is a case for Frame2", "[Common][Frame2]") {
	SECTION("Mirror axis 2D") {
		PointT<double, 2> p(1.0, 2.0);
		DirectionT<double, 2> d(1.0, 3.0);
		FrameT<double, 2> f1(p, d);
		PointT<double, 2> p2(2.0, 3.0);
		DirectionT<double, 2> d2(1.0, 4.0);
		AxisT<double, 2> axis(p2, d2);
		PointT<double, 2> p3(41.0 / 17.0, 28.0 / 17.0);
		DirectionT<double, 2> d3(9.0, 53.0);
		DirectionT<double, 2> d4(53.0, -9.0);
		FrameT<double, 2> f2 = f1.Mirrored(axis);
		CHECK(f2.Location().IsEqual(p3, tol));
		CHECK(f2.XDirection().IsEqual(d3, tol));
		CHECK(f2.YDirection().IsEqual(d4, tol));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar, typename OtherScalar2, typename OtherScalar3, int DIM2 = DIM, std::enable_if_t<DIM2 == 2, int> = 0> FrameT(const PointT<OtherScalar, DIM>& point, const DirectionT<OtherScalar2, DIM>& xdir, const DirectionT<OtherScalar3, DIM>& ydir),
 "output":#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);
	}
	else if constexpr (DIM == 2)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else if constexpr (DIM == 3)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else
	{
		return false;
	}
}
TEST_CASE("case1:this is a case for Frame2", "[Common][Frame2]") {
	SECTION("Construction 2D") {
		PointT<double, 2> p(0.0, 0.0);
		DirectionT<double, 2> dx(1.0, 0.0);
		DirectionT<double, 2> dy(0.0, 1.0);
		FrameT<double, 2> f1;
		FrameT<double, 2> f2(p, dx, dy);
		CHECK(IsEqual(f1, f2));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar, typename OtherScalar2, int DIM2 = DIM, std::enable_if_t<DIM2 == 2, int> = 0> FrameT(const PointT<OtherScalar, DIM>& point, const DirectionT<OtherScalar2, DIM>& xdir, bool isright = true),
 "output":#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);
	}
	else if constexpr (DIM == 2)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else if constexpr (DIM == 3)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else
	{
		return false;
	}
}
TEST_CASE("case1:this is a case for Frame2", "[Common][Frame2]") {
	SECTION("Construction 2D") {
		PointT<double, 2> p(0.0, 0.0);
		DirectionT<double, 2> dx(1.0, 0.0);
		DirectionT<double, 2> dy(0.0, 1.0);
		FrameT<double, 2> f1;
		FrameT<double, 2> f2(p, dx, dy);
		CHECK(IsEqual(f1, f2));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar, int DIM2 = DIM, std::enable_if_t<DIM2 == 2, int> = 0> explicit FrameT(const AxisT<OtherScalar, DIM>& axis, bool isright = true),
 "output":#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);
	}
	else if constexpr (DIM == 2)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else if constexpr (DIM == 3)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else
	{
		return false;
	}
}
TEST_CASE("case1:this is a case for Frame2", "[Common][Frame2]") {
	SECTION("Construction 2D") {
		PointT<double, 2> p(0.0, 0.0);
		DirectionT<double, 2> dx(1.0, 0.0);
		DirectionT<double, 2> dy(0.0, 1.0);
		FrameT<double, 2> f1;
		FrameT<double, 2> f2(p, dx, dy);
		CHECK(IsEqual(f1, f2));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar, int DIM2 = DIM, std::enable_if_t<DIM2 == 2, int> = 0> void SetXAxis(const AxisT<OtherScalar, DIM>& axis),
 "output":#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);
	}
	else if constexpr (DIM == 2)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else if constexpr (DIM == 3)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else
	{
		return false;
	}
}
TEST_CASE("case1:this is a case for Frame2", "[Common][Frame2]") {
	SECTION("SetXAxis 2D") {
		PointT<double, 2> p(1.0, 2.0);
		PointT<double, 2> p2(3.0, 1.0);
		DirectionT<double, 2> dx(1.0, 3.0);
		FrameT<double, 2> f1(p, dx);
		DirectionT<double, 2> dx2(-1.0, -2.0);
		FrameT<double, 2> f2(p2, dx2);
		AxisT<double, 2> axis(p, dx);
		f2.SetXAxis(axis);
		CHECK(IsEqual(f1, f2));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar, int DIM2 = DIM, std::enable_if_t<DIM2 == 2, int> = 0> void SetYAxis(const AxisT<OtherScalar, DIM>& axis),
 "output":#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);
	}
	else if constexpr (DIM == 2)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else if constexpr (DIM == 3)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else
	{
		return false;
	}
}
TEST_CASE("case1:this is a case for Frame2", "[Common][Frame2]") {
	SECTION("SetYAxis 2D") {
		PointT<double, 2> p(1.0, 2.0);
		PointT<double, 2> p2(3.0, 1.0);
		DirectionT<double, 2> dx(1.0, 3.0);
		DirectionT<double, 2> dy(-3.0, 1.0);
		FrameT<double, 2> f1(p, dx);
		DirectionT<double, 2> dx2(-1.0, -2.0);
		FrameT<double, 2> f2(p2, dx2);
		AxisT<double, 2> axis(p, dy);
		f2.SetYAxis(axis);
		CHECK(IsEqual(f1, f2));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar, int DIM2 = DIM, std::enable_if_t<DIM2 == 2, int> = 0> void SetXDirection(const DirectionT<OtherScalar, DIM>& x),
 "output":#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);
	}
	else if constexpr (DIM == 2)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else if constexpr (DIM == 3)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else
	{
		return false;
	}
}
TEST_CASE("case1:this is a case for Frame2", "[Common][Frame2]") {
	SECTION("SetXDirection 2D") {
		PointT<double, 2> p(1.0, 2.0);
		DirectionT<double, 2> dx(1.0, 3.0);
		FrameT<double, 2> f1(p, dx);
		DirectionT<double, 2> dx2(-1.0, -2.0);
		FrameT<double, 2> f2(p, dx2);
		f2.SetXDirection(dx);
		CHECK(IsEqual(f1, f2));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar, int DIM2 = DIM, std::enable_if_t<DIM2 == 2, int> = 0> void SetYDirection(const DirectionT<OtherScalar, DIM>& y),
 "output":#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);
	}
	else if constexpr (DIM == 2)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else if constexpr (DIM == 3)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else
	{
		return false;
	}
}
TEST_CASE("case1:this is a case for Frame2", "[Common][Frame2]") {
	SECTION("SetYDirection 2D") {
		PointT<double, 2> p(1.0, 2.0);
		DirectionT<double, 2> dx(1.0, 3.0);
		DirectionT<double, 2> dy(-3.0, 1.0);
		FrameT<double, 2> f1(p, dx);
		DirectionT<double, 2> dx2(-1.0, -2.0);
		FrameT<double, 2> f2(p, dx2);
		f2.SetYDirection(dy);
		CHECK(IsEqual(f1, f2));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<int DIM2 = DIM, typename = typename std::enable_if_t<DIM2 >= 1>> [[nodiscard]] const DirectionT<Scalar, DIM>& XDirection(),
 "output":#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);
	}
	else if constexpr (DIM == 2)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else if constexpr (DIM == 3)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else
	{
		return false;
	}
}
TEST_CASE("case1:this is a case for Frame2", "[Common][Frame2]") {
	SECTION("Mirror axis 2D") {
		PointT<double, 2> p(1.0, 2.0);
		DirectionT<double, 2> d(1.0, 3.0);
		FrameT<double, 2> f1(p, d);
		PointT<double, 2> p2(2.0, 3.0);
		DirectionT<double, 2> d2(1.0, 4.0);
		AxisT<double, 2> axis(p2, d2);
		PointT<double, 2> p3(41.0 / 17.0, 28.0 / 17.0);
		DirectionT<double, 2> d3(9.0, 53.0);
		DirectionT<double, 2> d4(53.0, -9.0);
		FrameT<double, 2> f2 = f1.Mirrored(axis);
		CHECK(f2.Location().IsEqual(p3, tol));
		CHECK(f2.XDirection().IsEqual(d3, tol));
		CHECK(f2.YDirection().IsEqual(d4, tol));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<int DIM2 = DIM, typename = typename std::enable_if_t<DIM2 >= 2>> [[nodiscard]] const DirectionT<Scalar, DIM>& YDirection(),
 "output":#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);
	}
	else if constexpr (DIM == 2)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else if constexpr (DIM == 3)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else
	{
		return false;
	}
}
#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);
	}
	else if constexpr (DIM == 2)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else if constexpr (DIM == 3)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else
	{
		return false;
	}
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar> FrameT& Mirror(const PointT<OtherScalar, DIM>& point),
 "output":#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);
	}
	else if constexpr (DIM == 2)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else if constexpr (DIM == 3)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else
	{
		return false;
	}
}
TEST_CASE("case1:this is a case for Frame2", "[Common][Frame2]") {
	SECTION("Mirror point 2D") {
		PointT<double, 2> p(1.0, 2.0);
		DirectionT<double, 2> d(1.0, 3.0);
		FrameT<double, 2> f1(p, d);
		PointT<double, 2> p2(2.0, 3.0);
		PointT<double, 2> p3(3.0, 4.0);
		DirectionT<double, 2> d2(-1.0, -3.0);
		FrameT<double, 2> f2(p3, d2);
		CHECK(IsEqual(f1.Mirrored(p2), f2));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar> [[nodiscard]] FrameT Mirrored(const PointT<OtherScalar, DIM>& point),
 "output":#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);
	}
	else if constexpr (DIM == 2)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else if constexpr (DIM == 3)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else
	{
		return false;
	}
}
TEST_CASE("case1:this is a case for Frame2", "[Common][Frame2]") {
	SECTION("Mirror point 2D") {
		PointT<double, 2> p(1.0, 2.0);
		DirectionT<double, 2> d(1.0, 3.0);
		FrameT<double, 2> f1(p, d);
		PointT<double, 2> p2(2.0, 3.0);
		PointT<double, 2> p3(3.0, 4.0);
		DirectionT<double, 2> d2(-1.0, -3.0);
		FrameT<double, 2> f2(p3, d2);
		CHECK(IsEqual(f1.Mirrored(p2), f2));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar> [[nodiscard]] FrameT Mirrored(const AxisT<OtherScalar, DIM>& a),
 "output":#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);
	}
	else if constexpr (DIM == 2)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else if constexpr (DIM == 3)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else
	{
		return false;
	}
}
TEST_CASE("case1:this is a case for Frame2", "[Common][Frame2]") {
	SECTION("Mirror axis 2D") {
		PointT<double, 2> p(1.0, 2.0);
		DirectionT<double, 2> d(1.0, 3.0);
		FrameT<double, 2> f1(p, d);
		PointT<double, 2> p2(2.0, 3.0);
		DirectionT<double, 2> d2(1.0, 4.0);
		AxisT<double, 2> axis(p2, d2);
		PointT<double, 2> p3(41.0 / 17.0, 28.0 / 17.0);
		DirectionT<double, 2> d3(9.0, 53.0);
		DirectionT<double, 2> d4(53.0, -9.0);
		FrameT<double, 2> f2 = f1.Mirrored(axis);
		CHECK(f2.Location().IsEqual(p3, tol));
		CHECK(f2.XDirection().IsEqual(d3, tol));
		CHECK(f2.YDirection().IsEqual(d4, tol));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar, typename OtherScalar2, int DIM2 = DIM, typename = typename std::enable_if_t<DIM2 == 2>> FrameT& Rotate(const PointT<OtherScalar, DIM>& point, const OtherScalar2& angle),
 "output":#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);
	}
	else if constexpr (DIM == 2)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else if constexpr (DIM == 3)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else
	{
		return false;
	}
}
TEST_CASE("case1:this is a case for Frame2", "[Common][Frame2]") {
	SECTION("Construction 2D") {
		PointT<double, 2> p(1.0, 2.0);
		DirectionT<double, 2> dx(1.0, 3.0);
		DirectionT<double, 2> dy(-3.0, 1.0);
		FrameT<double, 2> f1(p, dx);
		FrameT<double, 2> f2(p, dx, dy);
		CHECK(IsEqual(f1, f2));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar, typename OtherScalar2, int DIM2 = DIM, typename = typename std::enable_if_t<DIM2 == 2>> [[nodiscard]] FrameT Rotated(const PointT<OtherScalar, DIM>& point, const OtherScalar2& angle),
 "output":#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);
	}
	else if constexpr (DIM == 2)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else if constexpr (DIM == 3)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else
	{
		return false;
	}
}
TEST_CASE("case1:this is a case for Frame2", "[Common][Frame2]") {
	SECTION("Construction 2D") {
		PointT<double, 2> p(0.0, 0.0);
		DirectionT<double, 2> dx(1.0, 0.0);
		DirectionT<double, 2> dy(0.0, 1.0);
		FrameT<double, 2> f1;
		FrameT<double, 2> f2(p, dx, dy);
		CHECK(IsEqual(f1, f2));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar, typename OtherScalar2> [[nodiscard]] FrameT Scaled(const PointT<OtherScalar, DIM>& point, const OtherScalar2& scale),
 "output":#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);
	}
	else if constexpr (DIM == 2)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else if constexpr (DIM == 3)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else
	{
		return false;
	}
}
TEST_CASE("case1:this is a case for Frame2", "[Common][Frame2]") {
	SECTION("Scale 2D") {
		PointT<double, 2> p(1.0, 2.0);
		DirectionT<double, 2> d(1.0, 3.0);
		FrameT<double, 2> f1(p, d);
		PointT<double, 2> p2(2.0, 3.0);
		PointT<double, 2> p3(0.5, 1.5);
		FrameT<double, 2> f2(p3, d);
		CHECK(IsEqual(f1.Scaled(p2, 1.5), f2));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar> [[nodiscard]] FrameT Translated(const VectorT<OtherScalar, DIM>& vec),
 "output":#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);
	}
	else if constexpr (DIM == 2)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else if constexpr (DIM == 3)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else
	{
		return false;
	}
}
TEST_CASE("case1:this is a case for Frame2", "[Common][Frame2]") {
	SECTION("Translate vector 2D") {
		PointT<double, 2> p(1.0, 2.0);
		DirectionT<double, 2> d(1.0, 3.0);
		FrameT<double, 2> f1(p, d);
		VectorT<double, 2> v(2.0, 3.0);
		PointT<double, 2> p2(3.0, 5.0);
		FrameT<double, 2> f2(p2, d);
		CHECK(IsEqual(f1.Translated(v), f2));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar, typename OtherScalar2> [[nodiscard]] FrameT Translated(const PointT<OtherScalar, DIM>& p1, const PointT<OtherScalar2, DIM>& p2),
 "output":#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);
	}
	else if constexpr (DIM == 2)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else if constexpr (DIM == 3)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else
	{
		return false;
	}
}
TEST_CASE("case1:this is a case for Frame2", "[Common][Frame2]") {
	SECTION("Translate vector 2D") {
		PointT<double, 2> p(1.0, 2.0);
		DirectionT<double, 2> d(1.0, 3.0);
		FrameT<double, 2> f1(p, d);
		VectorT<double, 2> v(2.0, 3.0);
		PointT<double, 2> p2(3.0, 5.0);
		FrameT<double, 2> f2(p2, d);
		CHECK(IsEqual(f1.Translated(v), f2));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API BoolBRepCut()	 @details Only set the type of boolean operation to cut
	 @brief Default constructor
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <boolean/BoolBRepCut.hpp>
#include <modeling/MakeTorus.hpp>
#include <modeling/MakeSphere.hpp>
#include <modeling/MakeCone.hpp>
#include <topology/TopoExplorer.hpp>
#include <topology/TopoFace.hpp>
#include <hatch/BRepClassificationTools.hpp>
using namespace AMCAX;
TEST_CASE("bug1: in Debug mode: BoolBuilder  ", "[boolean][BoolBRepCut][P1][fixbug]") {
	TopoShape torus = MakeTorus(Frame3(Point3(0.0, 0.0, 2.0), Direction3(1.0, 0.0, 0.0)), 4.0, 2.0);
	TopoShape sphere = MakeSphere(4.0);
	TopoShape result = BoolBRepCut(sphere, torus);
	AMCAX::GlobalProperty prop;
	AMCAX::BRepGlobalProperty::VolumeProperties(result, prop);
	CHECK(prop.Mass() == Approx(153.229)); 
	bool isWriteSuccess = AMCAX::OCCTIO::OCCTTool::Write(result, OUTPUT_PATH_PREFIX"BoolBRepCut_bug72.brep", false);
	CHECK(isWriteSuccess == true);
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API BoolBRepCut(const TopoShape& s1, const TopoShape& s2, bool isForward = true)	 @param isForward Cut s1 by s2 if true, and cut s2 by s1 if false
	 @param s2 The tool shape
	 @param s1 The argument shape
	 @brief Compute the cut operation of two shapes
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <boolean/BoolBRepCut.hpp>
#include <modeling/MakeTorus.hpp>
#include <modeling/MakeSphere.hpp>
#include <modeling/MakeCone.hpp>
#include <topology/TopoExplorer.hpp>
#include <topology/TopoFace.hpp>
#include <hatch/BRepClassificationTools.hpp>
using namespace AMCAX;
TEST_CASE("bug1: in Debug mode: BoolBuilder  ", "[boolean][BoolBRepCut][P1][fixbug]") {
	TopoShape torus = MakeTorus(Frame3(Point3(0.0, 0.0, 2.0), Direction3(1.0, 0.0, 0.0)), 4.0, 2.0);
	TopoShape sphere = MakeSphere(4.0);
	TopoShape result = BoolBRepCut(sphere, torus);
	AMCAX::GlobalProperty prop;
	AMCAX::BRepGlobalProperty::VolumeProperties(result, prop);
	CHECK(prop.Mass() == Approx(153.229)); 
	bool isWriteSuccess = AMCAX::OCCTIO::OCCTTool::Write(result, OUTPUT_PATH_PREFIX"BoolBRepCut_bug72.brep", false);
	CHECK(isWriteSuccess == true);
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API BoolBRepDefeaturing()	 @brief Default constructor
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <modeling/MakeBox.hpp>
#include <modeling/MakeCylinder.hpp>
#include <boolean/BoolBRepCut.hpp>
#include <topomesh/BRepMeshIncrementalMesh.hpp>
#include <io/OBJTool.hpp>
#include <topology/TopoFace.hpp>
#include <geometry/Geom3Surface.hpp>
#include <topology/TopoTool.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <boolean/BoolBRepDefeaturing.hpp>
#include <topology/TopoEdge.hpp>
#include <common/IndexSet.hpp>
using namespace AMCAX;
TEST_CASE("bug1: BoolBRepDefeaturing ", "[boolean][BRepDefeaturing]")
{
	TopoShape box = MakeBox(Point3(-5.0, -5.0, 0.0), Point3(5.0, 5.0, 3.0));
	TopoShape cyl = MakeCylinder(Frame3(Point3(0.0, 0.0, 0.0), Direction3(0.0, 0.0, 1.0)), 3.0, 5.0);
	TopoShape shape = BoolBRepCut(box, cyl);
	AMCAX::GlobalProperty prop1, prop2, prop3, prop4, prop5, prop6;
	BRepGlobalProperty::LinearProperties(box, prop1, true, true);
	BRepGlobalProperty::LinearProperties(box, prop2, true, false);
	double result1 = prop1.Mass();
	double result2 = prop2.Mass();
	CHECK(result1 == Approx(10 * 8 + 3 * 4));
	CHECK(result2 == Approx(10 * 8 + 3 * 4));
	BRepGlobalProperty::SurfaceProperties(box, prop3, true, true);
	BRepGlobalProperty::SurfaceProperties(box, prop4, true, false);
	double result3 = prop3.Mass();
	double result4 = prop4.Mass();
	CHECK(result3 == Approx(2 * (10 * 10) + 4 * (10 * 3)));
	CHECK(result4 == Approx(2 * (10 * 10) + 4 * (10 * 3)));
	BRepGlobalProperty::VolumeProperties(box, prop5, true, true);
	BRepGlobalProperty::VolumeProperties(box, prop6, true, false);
	double result5 = prop5.Mass();
	double result6 = prop6.Mass();
	CHECK(result5 == Approx(10 * 10 * 3));
	CHECK(result6 == Approx(10 * 10 * 3));
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API explicit BoolBRepDefeaturing(const TopoShape& shape)	 @param shape The shape that require remove feature
	 @brief Construct from a shape.
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <modeling/MakeBox.hpp>
#include <modeling/MakeCylinder.hpp>
#include <boolean/BoolBRepCut.hpp>
#include <topomesh/BRepMeshIncrementalMesh.hpp>
#include <io/OBJTool.hpp>
#include <topology/TopoFace.hpp>
#include <geometry/Geom3Surface.hpp>
#include <topology/TopoTool.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <boolean/BoolBRepDefeaturing.hpp>
#include <topology/TopoEdge.hpp>
#include <common/IndexSet.hpp>
using namespace AMCAX;
TEST_CASE("case1: test BoolBRepDefeaturing Algorithm", "[boolean][BRepDefeaturing]")
{
	OUTPUT_DIRECTORY(Boolean, BRepDefeaturing);
	TopoShape box = MakeBox(Point3(-5.0, -5.0, 0.0), Point3(5.0, 5.0, 3.0));
	TopoShape cyl = MakeCylinder(Frame3(Point3(0.0, 0.0, 0.0), Direction3(0.0, 0.0, 1.0)), 3.0, 5.0);
	TopoShape shape = BoolBRepCut(box, cyl);
	OCCTIO::OCCTTool::Write(shape, outdir + "testResultTemp.brep");
	BRepMeshIncrementalMesh meshT(shape, 0.01, true);
	OBJTool::WriteShape(shape, outdir + "testResultTemp.obj");
	IndexSet<TopoShape> shapeFace, shapeEdge, shapeVertex;
	CHECK(GetTopoToolCount(shape, ShapeType::Face, shapeFace) == 7);
	CHECK(GetTopoToolCount(shape, ShapeType::Edge, shapeEdge) == 15);
	CHECK(GetTopoToolCount(shape, ShapeType::Vertex, shapeVertex) == 10);
	TopoFace cy;
	std::list<TopoShape> faceToRemove;
	for (TopoExplorer expF(shape, ShapeType::Face); expF.More(); expF.Next())
	{
		TopoFace f = static_cast<const TopoFace&>(expF.Current());
		std::shared_ptr<Geom3Surface> surface = TopoTool::Surface(f);
		if (surface->Type() == SurfaceType::Cylinder)
		{
			cy = f;
			OCCTIO::OCCTTool::Write(f, outdir + "RemoveFace.brep");
			faceToRemove.push_back(f);
		}
	}
	BoolBRepDefeaturing defeature(shape);
	defeature.AddFaceToRemove(faceToRemove);
	defeature.Build();
	TopoShape newShape = defeature.Shape();
	Point3 p(-3.0, 0.0, 1.0);
	double tol = -1.0;
	bool isIn = BRepClassificationTools::IsPointInFace(cy, p, tol);
	CHECK(isIn == true);
	for (TopoExplorer expF(newShape, ShapeType::Face); expF.More(); expF.Next())
	{
		TopoFace newFace = static_cast<const TopoFace&>(expF.Current());
		bool isIn1 = BRepClassificationTools::IsPointInFace(newFace, p, tol);
		CHECK(isIn1 == false);
	}
	for (TopoExplorer expF1(newShape, ShapeType::Face); expF1.More(); expF1.Next())
	{
		bool result;
		TopoFace f1 = static_cast<const TopoFace&>(expF1.Current());
		std::shared_ptr<Geom3Surface> surface1 = TopoTool::Surface(f1);
		if (surface1->Type() == SurfaceType::Cylinder)
		{
			result = false;
		}
		else
		{
			result = true;
		}
		CHECK(result == true);
	}
	AMCAX::GlobalProperty props1, props2, props3;
	IndexSet<TopoShape> newshapeFace, newshapeEdge, newshapeVertex;
	CHECK(newShape.Type() == ShapeType::Compound);
	CHECK(GetTopoToolCount(newShape, ShapeType::Face, newshapeFace) == 6);
	CHECK(GetTopoToolCount(newShape, ShapeType::Edge, newshapeEdge) == 12);
	CHECK(GetTopoToolCount(newShape, ShapeType::Vertex, newshapeVertex) == 8);
	CHECK(GetLinearProperties(newShape,props1,true,false)== Approx(10 * 8 + 3 * 4));
	CHECK(GetSurfaceProperties(newShape, props2, true, false) == Approx(2 * (10 * 10) + 4*(10 * 3)));
	CHECK(GetVolumeProperties(newShape, props3, true, false) == Approx(10*10*3));
	Point3 point = props3.CenterOfMass();
	CHECK(point.X() == Approx(0.0).margin(1e-12));
	CHECK(point.Y() == Approx(0.0).margin(1e-12));
	CHECK(point.Z() == Approx(1.5).margin(1e-12));
	std::cout << "defeature ok " << std::endl;
	OCCTIO::OCCTTool::Write(newShape, outdir + "testResult.brep");
	BRepMeshIncrementalMesh meshR(newShape, 0.01, true);
	OBJTool::WriteShape(newShape, outdir + "testResult.obj");
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API BoolBRepFuse()	 @details Only set the type of boolean operation to fuse
	 @brief Default constructor
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <boolean/BoolBRepFuse.hpp>
#include <boolean/BoolBRepCut.hpp>
using namespace AMCAX;
TEST_CASE("bug1: BoolBRepFuse ", "[boolean][BoolBRepFuse][fixbug]")
{
	TopoShape shape1, shape2;
	OCCTIO::OCCTTool::Read(shape1, INPUT_PATH_PREFIX"boolean/part.brep");
	OCCTIO::OCCTTool::Read(shape2, INPUT_PATH_PREFIX"boolean/box.brep");
	TopoShape result = BoolBRepFuse(shape1, shape2);
	CHECK(OCCTIO::OCCTTool::Write(result, OUTPUT_PATH_PREFIX"testbug-view-556.brep"));
	IndexSet<TopoShape> shapeFace, shapeEdge, shapeVertex ,shapeSolid;
	CHECK( GetTopoToolCount(result, AMCAX::ShapeType::Solid, shapeSolid)==1 );
}	
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API BoolBRepFuse(const TopoShape& s1, const TopoShape& s2)	 @param s2 The tool shape
	 @param s1 The argument shape
	 @brief Compute the fuse of two shapes
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <boolean/BoolBRepFuse.hpp>
#include <boolean/BoolBRepCut.hpp>
using namespace AMCAX;
TEST_CASE("bug1: BoolBRepFuse ", "[boolean][BoolBRepFuse][fixbug]")
{
	TopoShape shape1, shape2;
	OCCTIO::OCCTTool::Read(shape1, INPUT_PATH_PREFIX"boolean/part.brep");
	OCCTIO::OCCTTool::Read(shape2, INPUT_PATH_PREFIX"boolean/box.brep");
	TopoShape result = BoolBRepFuse(shape1, shape2);
	CHECK(OCCTIO::OCCTTool::Write(result, OUTPUT_PATH_PREFIX"testbug-view-556.brep"));
	IndexSet<TopoShape> shapeFace, shapeEdge, shapeVertex ,shapeSolid;
	CHECK( GetTopoToolCount(result, AMCAX::ShapeType::Solid, shapeSolid)==1 );
}	
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] const PointT<Scalar, DIM>& Location()	 @return The location
	 @brief Get the location
,
 "output":#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);
	}
	else if constexpr (DIM == 2)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else if constexpr (DIM == 3)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else
	{
		return false;
	}
}
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {
	return result.Location().IsEqual(expected.Location(), tol) &&
		result.Direction().IsEqual(expected.Direction(), tol);
}
TEST_CASE("case1:this is a case for Frame3","[Common][Frame3]")
{
	SECTION("Location"){
		PointT<double, 3> p(1.0, 2.0, 3.0);
		DirectionT<double, 3> dz(1.0, 2.0, 3.0);
		FrameT<double, 3> f1(p, dz);
		CHECK(f1.Location().IsEqual(p, tol));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":FrameT()	 @details The default frame is the standard orthogonal frame
	 @brief Default constructor
,
 "output":#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);
	}
	else if constexpr (DIM == 2)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else if constexpr (DIM == 3)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else
	{
		return false;
	}
}
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {
	return result.Location().IsEqual(expected.Location(), tol) &&
		result.Direction().IsEqual(expected.Direction(), tol);
}
TEST_CASE("case1:this is a case for Frame3","[Common][Frame3]")
{
	SECTION("SetXDirection 3D"){
		PointT<double, 3> p(0.0, 1.0, 2.0);
		DirectionT<double, 3> dz(1.0, 2.0, 3.0);
		DirectionT<double, 3> dx(-1.0, -1.0, 1.0);
		DirectionT<double, 3> dx2(0.0, 3.0, -2.0);
		FrameT<double, 3> f1(p, dz);
		FrameT<double, 3> f2(p, dz, dx);
		f2.SetXDirection(dx2);
		CHECK(IsEqual(f1, f2));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar, typename OtherScalar2, typename OtherScalar3, int DIM2 = DIM, std::enable_if_t<DIM2 == 2, int> = 0> FrameT(const PointT<OtherScalar, DIM>& point, const DirectionT<OtherScalar2, DIM>& xdir, const DirectionT<OtherScalar3, DIM>& ydir),
 "output":#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);
	}
	else if constexpr (DIM == 2)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else if constexpr (DIM == 3)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else
	{
		return false;
	}
}
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {
	return result.Location().IsEqual(expected.Location(), tol) &&
		result.Direction().IsEqual(expected.Direction(), tol);
}
TEST_CASE("case1:this is a case for Frame3","[Common][Frame3]")
{
	SECTION("YDirection"){
		PointT<double, 3> p(1.0, 2.0, 3.0);
		DirectionT<double, 3> dz(1.0, 2.0, 3.0);
		DirectionT<double, 3> dy(-13.0, 2.0, 3.0);
		FrameT<double, 3> f1(p, dz);
		CHECK(f1.YDirection().IsEqual(dy, tol));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar, typename OtherScalar2, int DIM2 = DIM, std::enable_if_t<DIM2 == 2, int> = 0> FrameT(const PointT<OtherScalar, DIM>& point, const DirectionT<OtherScalar2, DIM>& xdir, bool isright = true),
 "output":#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);
	}
	else if constexpr (DIM == 2)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else if constexpr (DIM == 3)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else
	{
		return false;
	}
}
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {
	return result.Location().IsEqual(expected.Location(), tol) &&
		result.Direction().IsEqual(expected.Direction(), tol);
}
TEST_CASE("case1:this is a case for Frame3","[Common][Frame3]")
{
	SECTION("IsCoplanar frame"){
		PointT<double, 3> p(1.0, -1.0, 0.0);
		PointT<double, 3> p2(1.0, 2.0, -2.0);
		PointT<double, 3> p3(1.0, 2.0, -1.0);
		DirectionT<double, 3> dz(1.0, 2.0, 3.0);
		DirectionT<double, 3> dz2(1.0, 2.0, 3.1);
		FrameT<double, 3> f1(p, dz);
		FrameT<double, 3> f2(p2, dz);
		FrameT<double, 3> f3(p3, dz);
		FrameT<double, 3> f4(p2, dz2);
		CHECK(f1.IsCoplanar(f2, 1e-6, 1e-6) == true);
		CHECK(f1.IsCoplanar(f3, 1e-6, 1e-6) == false);
		CHECK(f1.IsCoplanar(f4, 1e-6, 1e-6) == false);
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar, int DIM2 = DIM, std::enable_if_t<DIM2 == 2, int> = 0> explicit FrameT(const AxisT<OtherScalar, DIM>& axis, bool isright = true),
 "output":#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);
	}
	else if constexpr (DIM == 2)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else if constexpr (DIM == 3)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else
	{
		return false;
	}
}
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {
	return result.Location().IsEqual(expected.Location(), tol) &&
		result.Direction().IsEqual(expected.Direction(), tol);
}
TEST_CASE("case1:this is a case for Frame3","[Common][Frame3]")
{
	SECTION("Location"){
		PointT<double, 3> p(1.0, 2.0, 3.0);
		DirectionT<double, 3> dz(1.0, 2.0, 3.0);
		FrameT<double, 3> f1(p, dz);
		CHECK(f1.Location().IsEqual(p, tol));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar, typename OtherScalar2, typename OtherScalar3, int DIM2 = DIM, std::enable_if_t<DIM2 == 3, int> = 0> FrameT(const PointT<OtherScalar, DIM>& point, const DirectionT<OtherScalar2, DIM>& normal, const DirectionT<OtherScalar3, DIM>& x),
 "output":#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);
	}
	else if constexpr (DIM == 2)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else if constexpr (DIM == 3)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else
	{
		return false;
	}
}
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {
	return result.Location().IsEqual(expected.Location(), tol) &&
		result.Direction().IsEqual(expected.Direction(), tol);
}
TEST_CASE("case1:this is a case for Frame3","[Common][Frame3]")
{
	SECTION("Default constructor"){
		FrameT<double, 3> f1;
		PointT<double, 3> p(0.0, 0.0, 0.0);
		DirectionT<double, 3> dz(0.0, 0.0, 1.0);
		DirectionT<double, 3> dx(1.0, 0.0, 0.0);
		FrameT<double, 3> f2(p, dz, dx);
		CHECK(IsEqual(f1, f2));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar, typename OtherScalar2, int DIM2 = DIM, std::enable_if_t<DIM2 == 3, int> = 0> FrameT(const PointT<OtherScalar, DIM>& point, const DirectionT<OtherScalar2, DIM>& dir),
 "output":#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);
	}
	else if constexpr (DIM == 2)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else if constexpr (DIM == 3)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else
	{
		return false;
	}
}
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {
	return result.Location().IsEqual(expected.Location(), tol) &&
		result.Direction().IsEqual(expected.Direction(), tol);
}
TEST_CASE("case1:this is a case for Frame3","[Common][Frame3]")
{
	SECTION("Default constructor"){
		FrameT<double, 3> f1;
		PointT<double, 3> p(0.0, 0.0, 0.0);
		DirectionT<double, 3> dz(0.0, 0.0, 1.0);
		DirectionT<double, 3> dx(1.0, 0.0, 0.0);
		FrameT<double, 3> f2(p, dz, dx);
		CHECK(IsEqual(f1, f2));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar, int DIM2 = DIM, typename = typename std::enable_if_t<DIM2 == 3>> void SetDirection(const DirectionT<OtherScalar, DIM>& dir),
 "output":#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);
	}
	else if constexpr (DIM == 2)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else if constexpr (DIM == 3)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else
	{
		return false;
	}
}
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {
	return result.Location().IsEqual(expected.Location(), tol) &&
		result.Direction().IsEqual(expected.Direction(), tol);
}
TEST_CASE("case1:this is a case for Frame3","[Common][Frame3]")
{
	SECTION("SetDirection 3D"){
		PointT<double, 3> p(0.0, 1.0, 2.0);
		DirectionT<double, 3> dz(1.0, 2.0, 3.0);
		DirectionT<double, 3> dz2(2.3, 2.6, 3.3);
		DirectionT<double, 3> dx(0.0, 3.0, -2.0);
		FrameT<double, 3> f1(p, dz);
		FrameT<double, 3> f2(p, dz2);
		f2.SetDirection(dz);
		f2.SetXDirection(dx);
		CHECK(IsEqual(f1, f2));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar, int DIM2 = DIM, std::enable_if_t<DIM2 == 3, int> = 0> void SetXDirection(const DirectionT<OtherScalar, DIM>& x),
 "output":#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);
	}
	else if constexpr (DIM == 2)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else if constexpr (DIM == 3)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else
	{
		return false;
	}
}
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {
	return result.Location().IsEqual(expected.Location(), tol) &&
		result.Direction().IsEqual(expected.Direction(), tol);
}
TEST_CASE("case1:this is a case for Frame3","[Common][Frame3]")
{
	SECTION("SetXDirection 3D"){
		PointT<double, 3> p(0.0, 1.0, 2.0);
		DirectionT<double, 3> dz(1.0, 2.0, 3.0);
		DirectionT<double, 3> dx(-1.0, -1.0, 1.0);
		DirectionT<double, 3> dx2(0.0, 3.0, -2.0);
		FrameT<double, 3> f1(p, dz);
		FrameT<double, 3> f2(p, dz, dx);
		f2.SetXDirection(dx2);
		CHECK(IsEqual(f1, f2));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar, int DIM2 = DIM, std::enable_if_t<DIM2 == 3, int> = 0> void SetYDirection(const DirectionT<OtherScalar, DIM>& y),
 "output":#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);
	}
	else if constexpr (DIM == 2)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else if constexpr (DIM == 3)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else
	{
		return false;
	}
}
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {
	return result.Location().IsEqual(expected.Location(), tol) &&
		result.Direction().IsEqual(expected.Direction(), tol);
}
TEST_CASE("case1:this is a case for Frame3","[Common][Frame3]")
{
	SECTION("SetYDirection 3D"){
		PointT<double, 3> p(0.0, 1.0, 2.0);
		DirectionT<double, 3> dz(1.0, 2.0, 3.0);
		DirectionT<double, 3> dx(-1.0, -1.0, 1.0);
		DirectionT<double, 3> dy2(-13.0, 2.0, 3.0);
		FrameT<double, 3> f1(p, dz);
		FrameT<double, 3> f2(p, dz, dx);
		f2.SetYDirection(dy2);
		CHECK(IsEqual(f1, f2));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<int DIM2 = DIM, typename = typename std::enable_if_t<DIM2 == 3>> [[nodiscard]] AxisT<Scalar, DIM> Axis(),
 "output":#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);
	}
	else if constexpr (DIM == 2)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else if constexpr (DIM == 3)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else
	{
		return false;
	}
}
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {
	return result.Location().IsEqual(expected.Location(), tol) &&
		result.Direction().IsEqual(expected.Direction(), tol);
}
TEST_CASE("case1:this is a case for Frame3","[Common][Frame3]")
{
	SECTION("Axis"){
		PointT<double, 3> p(1.0, 2.0, 3.0);
		DirectionT<double, 3> dz(1.0, 2.0, 3.0);
		FrameT<double, 3> f1(p, dz);
		CHECK(IsEqual(f1.Axis(), AxisT<double, 3>(p, dz)));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<int DIM2 = DIM, typename = typename std::enable_if_t<DIM2 == 3>> [[nodiscard]] const DirectionT<Scalar, DIM>& Direction(),
 "output":#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);
	}
	else if constexpr (DIM == 2)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else if constexpr (DIM == 3)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else
	{
		return false;
	}
}
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {
	return result.Location().IsEqual(expected.Location(), tol) &&
		result.Direction().IsEqual(expected.Direction(), tol);
}
TEST_CASE("case1:this is a case for Frame3","[Common][Frame3]")
{
	SECTION("Direction"){
		PointT<double, 3> p(1.0, 2.0, 3.0);
		DirectionT<double, 3> dz(1.0, 2.0, 3.0);
		FrameT<double, 3> f1(p, dz);
		CHECK(f1.Direction().IsEqual(dz, tol));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<int DIM2 = DIM, typename = typename std::enable_if_t<DIM2 >= 1>> [[nodiscard]] const DirectionT<Scalar, DIM>& XDirection(),
 "output":#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);
	}
	else if constexpr (DIM == 2)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else if constexpr (DIM == 3)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else
	{
		return false;
	}
}
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {
	return result.Location().IsEqual(expected.Location(), tol) &&
		result.Direction().IsEqual(expected.Direction(), tol);
}
TEST_CASE("case1:this is a case for Frame3","[Common][Frame3]")
{
	SECTION("XDirection"){
		PointT<double, 3> p(1.0, 2.0, 3.0);
		DirectionT<double, 3> dz(1.0, 2.0, 3.0);
		DirectionT<double, 3> dx(0.0, 3.0, -2.0);
		FrameT<double, 3> f1(p, dz);
		CHECK(f1.XDirection().IsEqual(dx, tol));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar, typename OtherScalar2, typename OtherScalar3, int DIM2 = DIM, typename = typename std::enable_if_t<DIM2 == 3>> [[nodiscard]] bool IsCoplanar(const FrameT<OtherScalar, DIM>& other, const OtherScalar2& distol, const OtherScalar3& angtol),
 "output":#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);
	}
	else if constexpr (DIM == 2)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else if constexpr (DIM == 3)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else
	{
		return false;
	}
}
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {
	return result.Location().IsEqual(expected.Location(), tol) &&
		result.Direction().IsEqual(expected.Direction(), tol);
}
TEST_CASE("case1:this is a case for Frame3","[Common][Frame3]")
{
	SECTION("IsCoplanar frame"){
		PointT<double, 3> p(1.0, -1.0, 0.0);
		PointT<double, 3> p2(1.0, 2.0, -2.0);
		PointT<double, 3> p3(1.0, 2.0, -1.0);
		DirectionT<double, 3> dz(1.0, 2.0, 3.0);
		DirectionT<double, 3> dz2(1.0, 2.0, 3.1);
		FrameT<double, 3> f1(p, dz);
		FrameT<double, 3> f2(p2, dz);
		FrameT<double, 3> f3(p3, dz);
		FrameT<double, 3> f4(p2, dz2);
		CHECK(f1.IsCoplanar(f2, 1e-6, 1e-6) == true);
		CHECK(f1.IsCoplanar(f3, 1e-6, 1e-6) == false);
		CHECK(f1.IsCoplanar(f4, 1e-6, 1e-6) == false);
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar, typename OtherScalar2, typename OtherScalar3, int DIM2 = DIM, typename = typename std::enable_if_t<DIM2 == 3>> [[nodiscard]] bool IsCoplanar(const AxisT<OtherScalar, DIM>& a, const OtherScalar2& distol, const OtherScalar3& angtol),
 "output":#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);
	}
	else if constexpr (DIM == 2)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else if constexpr (DIM == 3)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else
	{
		return false;
	}
}
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {
	return result.Location().IsEqual(expected.Location(), tol) &&
		result.Direction().IsEqual(expected.Direction(), tol);
}
TEST_CASE("case1:this is a case for Frame3","[Common][Frame3]")
{
	SECTION("IsCoplanar frame"){
		PointT<double, 3> p(1.0, -1.0, 0.0);
		PointT<double, 3> p2(1.0, 2.0, -2.0);
		PointT<double, 3> p3(1.0, 2.0, -1.0);
		DirectionT<double, 3> dz(1.0, 2.0, 3.0);
		DirectionT<double, 3> dz2(1.0, 2.0, 3.1);
		FrameT<double, 3> f1(p, dz);
		FrameT<double, 3> f2(p2, dz);
		FrameT<double, 3> f3(p3, dz);
		FrameT<double, 3> f4(p2, dz2);
		CHECK(f1.IsCoplanar(f2, 1e-6, 1e-6) == true);
		CHECK(f1.IsCoplanar(f3, 1e-6, 1e-6) == false);
		CHECK(f1.IsCoplanar(f4, 1e-6, 1e-6) == false);
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar> FrameT& Mirror(const PointT<OtherScalar, DIM>& point),
 "output":#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);
	}
	else if constexpr (DIM == 2)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else if constexpr (DIM == 3)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else
	{
		return false;
	}
}
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {
	return result.Location().IsEqual(expected.Location(), tol) &&
		result.Direction().IsEqual(expected.Direction(), tol);
}
TEST_CASE("case1:this is a case for Frame3","[Common][Frame3]")
{
	SECTION("Mirror point 3D"){
		PointT<double, 3> p(1.0, -1.0, 0.0);
		PointT<double, 3> p2(1.0, 2.0, -2.0);
		PointT<double, 3> p3(1.0, 5.0, -4.0);
		DirectionT<double, 3> dz(1.0, 2.0, 3.0);
		FrameT<double, 3> f1(p, dz);
		DirectionT<double, 3> dz2(-1.0, -2.0, -3.0);
		DirectionT<double, 3> dx2(0.0, -3.0, 2.0);
		FrameT<double, 3> f2(p3, dz2, dx2);
		FrameT<double, 3> f3 = f1.Mirrored(p2);
		CHECK(f3.Location().IsEqual(p3, tol));
		CHECK(f3.Direction().IsEqual(dz2, tol));
		CHECK(f3.XDirection().IsEqual(dx2, tol));
		CHECK(f3.YDirection().IsEqual(dx2.Cross(dz2), tol));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar> FrameT& Mirror(const AxisT<OtherScalar, DIM>& a),
 "output":#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);
	}
	else if constexpr (DIM == 2)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else if constexpr (DIM == 3)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else
	{
		return false;
	}
}
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {
	return result.Location().IsEqual(expected.Location(), tol) &&
		result.Direction().IsEqual(expected.Direction(), tol);
}
TEST_CASE("case1:this is a case for Frame3","[Common][Frame3]")
{
	SECTION("Mirror axis 3D"){
		PointT<double, 3> p(1.0, -1.0, 0.0);
		DirectionT<double, 3> dz(1.0, 2.0, 3.0);
		FrameT<double, 3> f1(p, dz);
		PointT<double, 3> p2(1.0, 2.0, -2.0);
		DirectionT<double, 3> d(1.0, 1.0, 1.0);
		AxisT<double, 3> axis(p2, d);
		PointT<double, 3> p3(1.0 / 3.0, 13.0 / 3.0, -14.0 / 3.0);
		DirectionT<double, 3> dz2(3.0, 2.0, 1.0);
		DirectionT<double, 3> dx2(2.0, -7.0, 8.0);
		FrameT<double, 3> f2(p3, dz2, dx2);
		FrameT<double, 3> f3 = f1.Mirrored(axis);
		CHECK(IsEqual(f2, f3));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar, int DIM2 = DIM, std::enable_if_t<DIM2 == 3, int> = 0> FrameT& Mirror(const FrameT<OtherScalar, DIM>& frame),
 "output":#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);
	}
	else if constexpr (DIM == 2)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else if constexpr (DIM == 3)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else
	{
		return false;
	}
}
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {
	return result.Location().IsEqual(expected.Location(), tol) &&
		result.Direction().IsEqual(expected.Direction(), tol);
}
TEST_CASE("case1:this is a case for Frame3","[Common][Frame3]")
{
	SECTION("Mirror axis 3D"){
		PointT<double, 3> p(1.0, -1.0, 0.0);
		DirectionT<double, 3> dz(1.0, 2.0, 3.0);
		FrameT<double, 3> f1(p, dz);
		PointT<double, 3> p2(1.0, 2.0, -2.0);
		DirectionT<double, 3> d(1.0, 1.0, 1.0);
		AxisT<double, 3> axis(p2, d);
		PointT<double, 3> p3(1.0 / 3.0, 13.0 / 3.0, -14.0 / 3.0);
		DirectionT<double, 3> dz2(3.0, 2.0, 1.0);
		DirectionT<double, 3> dx2(2.0, -7.0, 8.0);
		FrameT<double, 3> f2(p3, dz2, dx2);
		FrameT<double, 3> f3 = f1.Mirrored(axis);
		CHECK(IsEqual(f2, f3));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar> [[nodiscard]] FrameT Mirrored(const PointT<OtherScalar, DIM>& point),
 "output":#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);
	}
	else if constexpr (DIM == 2)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else if constexpr (DIM == 3)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else
	{
		return false;
	}
}
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {
	return result.Location().IsEqual(expected.Location(), tol) &&
		result.Direction().IsEqual(expected.Direction(), tol);
}
TEST_CASE("case1:this is a case for Frame3","[Common][Frame3]")
{
	SECTION("Mirror point 3D"){
		PointT<double, 3> p(1.0, -1.0, 0.0);
		PointT<double, 3> p2(1.0, 2.0, -2.0);
		PointT<double, 3> p3(1.0, 5.0, -4.0);
		DirectionT<double, 3> dz(1.0, 2.0, 3.0);
		FrameT<double, 3> f1(p, dz);
		DirectionT<double, 3> dz2(-1.0, -2.0, -3.0);
		DirectionT<double, 3> dx2(0.0, -3.0, 2.0);
		FrameT<double, 3> f2(p3, dz2, dx2);
		FrameT<double, 3> f3 = f1.Mirrored(p2);
		CHECK(f3.Location().IsEqual(p3, tol));
		CHECK(f3.Direction().IsEqual(dz2, tol));
		CHECK(f3.XDirection().IsEqual(dx2, tol));
		CHECK(f3.YDirection().IsEqual(dx2.Cross(dz2), tol));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar> [[nodiscard]] FrameT Mirrored(const AxisT<OtherScalar, DIM>& a),
 "output":#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);
	}
	else if constexpr (DIM == 2)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else if constexpr (DIM == 3)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else
	{
		return false;
	}
}
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {
	return result.Location().IsEqual(expected.Location(), tol) &&
		result.Direction().IsEqual(expected.Direction(), tol);
}
TEST_CASE("case1:this is a case for Frame3","[Common][Frame3]")
{
	SECTION("Mirror axis 3D"){
		PointT<double, 3> p(1.0, -1.0, 0.0);
		DirectionT<double, 3> dz(1.0, 2.0, 3.0);
		FrameT<double, 3> f1(p, dz);
		PointT<double, 3> p2(1.0, 2.0, -2.0);
		DirectionT<double, 3> d(1.0, 1.0, 1.0);
		AxisT<double, 3> axis(p2, d);
		PointT<double, 3> p3(1.0 / 3.0, 13.0 / 3.0, -14.0 / 3.0);
		DirectionT<double, 3> dz2(3.0, 2.0, 1.0);
		DirectionT<double, 3> dx2(2.0, -7.0, 8.0);
		FrameT<double, 3> f2(p3, dz2, dx2);
		FrameT<double, 3> f3 = f1.Mirrored(axis);
		CHECK(IsEqual(f2, f3));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar, int DIM2 = DIM, std::enable_if_t<DIM2 == 3, int> = 0> [[nodiscard]] FrameT Mirrored(const FrameT<OtherScalar, DIM>& frame),
 "output":#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);
	}
	else if constexpr (DIM == 2)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else if constexpr (DIM == 3)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else
	{
		return false;
	}
}
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {
	return result.Location().IsEqual(expected.Location(), tol) &&
		result.Direction().IsEqual(expected.Direction(), tol);
}
TEST_CASE("case1:this is a case for Frame3","[Common][Frame3]")
{
	SECTION("XDirection"){
		PointT<double, 3> p(1.0, 2.0, 3.0);
		DirectionT<double, 3> dz(1.0, 2.0, 3.0);
		DirectionT<double, 3> dx(0.0, 3.0, -2.0);
		FrameT<double, 3> f1(p, dz);
		CHECK(f1.XDirection().IsEqual(dx, tol));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar, typename OtherScalar2, int DIM2 = DIM, typename = typename std::enable_if_t<DIM2 == 3>> FrameT& Rotate(const AxisT<OtherScalar, DIM>& a, const OtherScalar2& angle),
 "output":#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);
	}
	else if constexpr (DIM == 2)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else if constexpr (DIM == 3)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else
	{
		return false;
	}
}
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {
	return result.Location().IsEqual(expected.Location(), tol) &&
		result.Direction().IsEqual(expected.Direction(), tol);
}
TEST_CASE("case1:this is a case for Frame3","[Common][Frame3]")
{
	SECTION("Rotate 3D"){
		PointT<double, 3> p(1.0, -1.0, 0.0);
		DirectionT<double, 3> dz(1.0, 2.0, 3.0);
		FrameT<double, 3> f1(p, dz);
		PointT<double, 3> p2(1.0, 2.0, 3.0);
		DirectionT<double, 3> dz2(3.0, 2.0, 1.0);
		AxisT<double, 3> axis(p2, dz2);
		PointT<double, 3> p3(-3.0 / sqrt(14.0) - 13.0 / 14.0, 9.0 / std::sqrt(14.0) + 10.0 / 14.0, -9.0 / std::sqrt(14.0) + 33.0 / 14.0);
		DirectionT<double, 3> dz3(4.0 / sqrt(14.0) + 15.0 / 7.0, -8.0 / sqrt(14.0) + 10.0 / 7.0, 4.0 / sqrt(14.0) + 5.0 / 7.0);
		DirectionT<double, 3> dx3(-7.0 / sqrt(14.0) + 6.0 / 7.0, 6.0 / sqrt(14.0) + 4.0 / 7.0, 9.0 / sqrt(14.0) + 2.0 / 7.0);
		FrameT<double, 3> f2(p3, dz3, dx3);
		FrameT<double, 3> f3 = f1.Rotated(axis, M_PI_2);
		CHECK(IsEqual(f3, f2));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar, typename OtherScalar2, int DIM2 = DIM, typename = typename std::enable_if_t<DIM2 == 2>> [[nodiscard]] FrameT Rotated(const PointT<OtherScalar, DIM>& point, const OtherScalar2& angle),
 "output":#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);
	}
	else if constexpr (DIM == 2)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else if constexpr (DIM == 3)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else
	{
		return false;
	}
}
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {
	return result.Location().IsEqual(expected.Location(), tol) &&
		result.Direction().IsEqual(expected.Direction(), tol);
}
TEST_CASE("case1:this is a case for Frame3","[Common][Frame3]")
{
	SECTION("Rotate 3D"){
		PointT<double, 3> p(1.0, -1.0, 0.0);
		DirectionT<double, 3> dz(1.0, 2.0, 3.0);
		FrameT<double, 3> f1(p, dz);
		PointT<double, 3> p2(1.0, 2.0, 3.0);
		DirectionT<double, 3> dz2(3.0, 2.0, 1.0);
		AxisT<double, 3> axis(p2, dz2);
		PointT<double, 3> p3(-3.0 / sqrt(14.0) - 13.0 / 14.0, 9.0 / std::sqrt(14.0) + 10.0 / 14.0, -9.0 / std::sqrt(14.0) + 33.0 / 14.0);
		DirectionT<double, 3> dz3(4.0 / sqrt(14.0) + 15.0 / 7.0, -8.0 / sqrt(14.0) + 10.0 / 7.0, 4.0 / sqrt(14.0) + 5.0 / 7.0);
		DirectionT<double, 3> dx3(-7.0 / sqrt(14.0) + 6.0 / 7.0, 6.0 / sqrt(14.0) + 4.0 / 7.0, 9.0 / sqrt(14.0) + 2.0 / 7.0);
		FrameT<double, 3> f2(p3, dz3, dx3);
		FrameT<double, 3> f3 = f1.Rotated(axis, M_PI_2);
		CHECK(IsEqual(f3, f2));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar, typename OtherScalar2, int DIM2 = DIM, typename = typename std::enable_if_t<DIM2 == 3>> [[nodiscard]] FrameT Rotated(const AxisT<OtherScalar, DIM>& a, const OtherScalar2& angle),
 "output":#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);
	}
	else if constexpr (DIM == 2)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else if constexpr (DIM == 3)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else
	{
		return false;
	}
}
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {
	return result.Location().IsEqual(expected.Location(), tol) &&
		result.Direction().IsEqual(expected.Direction(), tol);
}
TEST_CASE("case1:this is a case for Frame3","[Common][Frame3]")
{
	SECTION("Rotate 3D"){
		PointT<double, 3> p(1.0, -1.0, 0.0);
		DirectionT<double, 3> dz(1.0, 2.0, 3.0);
		FrameT<double, 3> f1(p, dz);
		PointT<double, 3> p2(1.0, 2.0, 3.0);
		DirectionT<double, 3> dz2(3.0, 2.0, 1.0);
		AxisT<double, 3> axis(p2, dz2);
		PointT<double, 3> p3(-3.0 / sqrt(14.0) - 13.0 / 14.0, 9.0 / std::sqrt(14.0) + 10.0 / 14.0, -9.0 / std::sqrt(14.0) + 33.0 / 14.0);
		DirectionT<double, 3> dz3(4.0 / sqrt(14.0) + 15.0 / 7.0, -8.0 / sqrt(14.0) + 10.0 / 7.0, 4.0 / sqrt(14.0) + 5.0 / 7.0);
		DirectionT<double, 3> dx3(-7.0 / sqrt(14.0) + 6.0 / 7.0, 6.0 / sqrt(14.0) + 4.0 / 7.0, 9.0 / sqrt(14.0) + 2.0 / 7.0);
		FrameT<double, 3> f2(p3, dz3, dx3);
		FrameT<double, 3> f3 = f1.Rotated(axis, M_PI_2);
		CHECK(IsEqual(f3, f2));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar, typename OtherScalar2> FrameT& Scale(const PointT<OtherScalar, DIM>& point, const OtherScalar2& scale),
 "output":#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);
	}
	else if constexpr (DIM == 2)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else if constexpr (DIM == 3)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else
	{
		return false;
	}
}
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {
	return result.Location().IsEqual(expected.Location(), tol) &&
		result.Direction().IsEqual(expected.Direction(), tol);
}
TEST_CASE("case1:this is a case for Frame3","[Common][Frame3]")
{
	SECTION("Scale 3D"){
		PointT<double, 3> p(1.0, -1.0, 0.0);
		DirectionT<double, 3> dz(1.0, 2.0, 3.0);
		FrameT<double, 3> f1(p, dz);
		PointT<double, 3> p2(1.0, 2.0, 3.0);
		PointT<double, 3> p3(1.0, -2.5, -1.5);
		FrameT<double, 3> f2(p3, dz);
		CHECK(IsEqual(f1.Scaled(p2, 1.5), f2));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar, typename OtherScalar2> [[nodiscard]] FrameT Scaled(const PointT<OtherScalar, DIM>& point, const OtherScalar2& scale),
 "output":#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);
	}
	else if constexpr (DIM == 2)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else if constexpr (DIM == 3)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else
	{
		return false;
	}
}
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {
	return result.Location().IsEqual(expected.Location(), tol) &&
		result.Direction().IsEqual(expected.Direction(), tol);
}
TEST_CASE("case1:this is a case for Frame3","[Common][Frame3]")
{
	SECTION("Scale 3D"){
		PointT<double, 3> p(1.0, -1.0, 0.0);
		DirectionT<double, 3> dz(1.0, 2.0, 3.0);
		FrameT<double, 3> f1(p, dz);
		PointT<double, 3> p2(1.0, 2.0, 3.0);
		PointT<double, 3> p3(1.0, -2.5, -1.5);
		FrameT<double, 3> f2(p3, dz);
		CHECK(IsEqual(f1.Scaled(p2, 1.5), f2));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar> FrameT& Translate(const VectorT<OtherScalar, DIM>& vec),
 "output":#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return result.Location().IsEqual(expected, tol) && result.Direction().IsEqual(expected.Direction(), tol);
	}
	else if constexpr (DIM == 2)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else if constexpr (DIM == 3)
	{
		return result.Location().IsEqual(expected.Location(), tol) && result.Direction().IsEqual(expected.Direction(), tol) && result.YDirection().IsEqual(expected.YDirection(), tol) && result.XDirection().IsEqual(expected.XDirection(), tol);
	}
	else
	{
		return false;
	}
}
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected) {
	return result.Location().IsEqual(expected.Location(), tol) &&
		result.Direction().IsEqual(expected.Direction(), tol);
}
TEST_CASE("case1:this is a case for Frame3","[Common][Frame3]")
{
	SECTION("Translate vector 3D"){
		PointT<double, 3> p(1.0, -1.0, 0.0);
		DirectionT<double, 3> dz(1.0, 2.0, 3.0);
		FrameT<double, 3> f1(p, dz);
		VectorT<double, 3> v(2.0, 3.0, -1.0);
		PointT<double, 3> p2(3.0, 2.0, -1.0);
		FrameT<double, 3> f2(p2, dz);
		CHECK(IsEqual(f1.Translated(v), f2));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar> explicit DirectionT(const VectorT<OtherScalar, DIM>& vec),
 "output":#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
TEST_CASE("case1:this is a case for Direction2", "[Common][Direction2]") {
	SECTION("Angle 2D") {
        DirectionT<double, 2> v1(1.0, 3.0);
        DirectionT<double, 2> v2(-1.0, 2.0);
        CHECK(v1.Angle(v2) == Approx(acos(M_SQRT1_2)));
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar> explicit DirectionT(const CoordT<OtherScalar, DIM>& v),
 "output":#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
TEST_CASE("case1:this is a case for Direction2", "[Common][Direction2]") {
	SECTION("Mirror(point) 2D") {
        DirectionT<double, 2> p1(1.0, 2.0);
        DirectionT<double, 2> p2(2.0, 3.0);
        DirectionT<double, 2> p3(19.0 / 13.0, 22.0 / 13.0);
        CHECK(p1.Mirrored(p2).IsEqual(p3, tol));
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename... T> explicit DirectionT(T... vs),
 "output":#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
TEST_CASE("case1:this is a case for Direction2", "[Common][Direction2]") {
	SECTION("Angle 2D") {
        DirectionT<double, 2> v1(1.0, 3.0);
        DirectionT<double, 2> v2(-1.0, 2.0);
        CHECK(v1.Angle(v2) == Approx(acos(M_SQRT1_2)));
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar, typename OtherScalar2> [[nodiscard]] bool IsEqual(const DirectionT<OtherScalar, DIM>& other, const OtherScalar2& tol),
 "output":#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
TEST_CASE("case1:this is a case for Direction2", "[Common][Direction2]") {
	SECTION("Mirror(axis) 2D") {
        DirectionT<double, 2> p1(1.0, 2.0);
        PointT<double, 2> p2(2.0, 3.0);
        DirectionT<double, 2> d(7.0, 3.0);
        AxisT<double, 2> a(p2, d);
        DirectionT<double, 2> p3(62.0 / 29.0, -19.0 / 29.0);
        CHECK(p1.Mirrored(a).IsEqual(p3, tol));
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar, int DIM2 = DIM, std::enable_if_t<DIM2 == 2, int> = 0> [[nodiscard]] auto Angle(const DirectionT<OtherScalar, DIM>& other),
 "output":#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
TEST_CASE("case1:this is a case for Direction2", "[Common][Direction2]") {
	SECTION("Angle 2D") {
        DirectionT<double, 2> v1(1.0, 3.0);
        DirectionT<double, 2> v2(-1.0, 2.0);
        CHECK(v1.Angle(v2) == Approx(acos(M_SQRT1_2)));
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar> [[nodiscard]] auto Cross(const DirectionT<OtherScalar, DIM>& other),
 "output":#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
TEST_CASE("case1:this is a case for Direction2", "[Common][Direction2]") {
	SECTION("Cross 2D") {
        DirectionT<double, 2> v1(1.0, 2.0);
        DirectionT<double, 2> v2(2.0, 3.0);
        CHECK(v1.Cross(v2) == Approx(-1.0/sqrt(65.0)));
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar> DirectionT& Mirror(const DirectionT<OtherScalar, DIM>& dir),
 "output":#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
TEST_CASE("case1:this is a case for Direction2", "[Common][Direction2]") {
	SECTION("Mirror(axis) 2D") {
        DirectionT<double, 2> p1(1.0, 2.0);
        PointT<double, 2> p2(2.0, 3.0);
        DirectionT<double, 2> d(7.0, 3.0);
        AxisT<double, 2> a(p2, d);
        DirectionT<double, 2> p3(62.0 / 29.0, -19.0 / 29.0);
        CHECK(p1.Mirrored(a).IsEqual(p3, tol));
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar> DirectionT& Mirror(const AxisT<OtherScalar, DIM>& axis),
 "output":#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
TEST_CASE("case1:this is a case for Direction2", "[Common][Direction2]") {
	SECTION("Mirror(axis) 2D") {
        DirectionT<double, 2> p1(1.0, 2.0);
        PointT<double, 2> p2(2.0, 3.0);
        DirectionT<double, 2> d(7.0, 3.0);
        AxisT<double, 2> a(p2, d);
        DirectionT<double, 2> p3(62.0 / 29.0, -19.0 / 29.0);
        CHECK(p1.Mirrored(a).IsEqual(p3, tol));
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar> [[nodiscard]] DirectionT Mirrored(const DirectionT<OtherScalar, DIM>& dir),
 "output":#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
TEST_CASE("case1:this is a case for Direction2", "[Common][Direction2]") {
	SECTION("Mirror(axis) 2D") {
        DirectionT<double, 2> p1(1.0, 2.0);
        PointT<double, 2> p2(2.0, 3.0);
        DirectionT<double, 2> d(7.0, 3.0);
        AxisT<double, 2> a(p2, d);
        DirectionT<double, 2> p3(62.0 / 29.0, -19.0 / 29.0);
        CHECK(p1.Mirrored(a).IsEqual(p3, tol));
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar> [[nodiscard]] DirectionT Mirrored(const AxisT<OtherScalar, DIM>& axis),
 "output":#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
TEST_CASE("case1:this is a case for Direction2", "[Common][Direction2]") {
	SECTION("Mirror(axis) 2D") {
        DirectionT<double, 2> p1(1.0, 2.0);
        PointT<double, 2> p2(2.0, 3.0);
        DirectionT<double, 2> d(7.0, 3.0);
        AxisT<double, 2> a(p2, d);
        DirectionT<double, 2> p3(62.0 / 29.0, -19.0 / 29.0);
        CHECK(p1.Mirrored(a).IsEqual(p3, tol));
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar, int DIM2 = DIM, typename = typename std::enable_if_t<DIM2 == 2>> DirectionT& Rotate(const OtherScalar& angle),
 "output":#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
TEST_CASE("case1:this is a case for Direction2", "[Common][Direction2]") {
	SECTION("Mirror(axis) 2D") {
        DirectionT<double, 2> p1(1.0, 2.0);
        PointT<double, 2> p2(2.0, 3.0);
        DirectionT<double, 2> d(7.0, 3.0);
        AxisT<double, 2> a(p2, d);
        DirectionT<double, 2> p3(62.0 / 29.0, -19.0 / 29.0);
        CHECK(p1.Mirrored(a).IsEqual(p3, tol));
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar, int DIM2 = DIM, typename = typename std::enable_if_t<DIM2 == 2>> [[nodiscard]] DirectionT Rotated(const OtherScalar& angle),
 "output":#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
TEST_CASE("case1:this is a case for Direction2", "[Common][Direction2]") {
	SECTION("Angle 2D") {
        DirectionT<double, 2> v1(1.0, 3.0);
        DirectionT<double, 2> v2(-1.0, 2.0);
        CHECK(v1.Angle(v2) == Approx(acos(M_SQRT1_2)));
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":DirectionT()	 @details Default direction is (1, 0, ... , 0)
	 @brief Default constructor
,
 "output":#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
TEST_CASE("case1:this is a case for Direction3", "[Common][Direction3]") {
	SECTION("Default constructor") {
        DirectionT<double, 3> p1;
        DirectionT<double, 3> p2(1.0, 0.0, 0.0);
        CHECK(p1.IsEqual(p2, tol));
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar> explicit DirectionT(const VectorT<OtherScalar, DIM>& vec),
 "output":#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
TEST_CASE("case1:this is a case for Direction3", "[Common][Direction3]") {
	SECTION("Constructor from vector") {
        VectorT<double, 3> v(1.0, 2.0, 3.0);
        DirectionT<double, 3> result(v);
        CoordT<double, 3> expected(1.0 / sqrt(14.0), 2.0 / sqrt(14.0), 3.0 / sqrt(14.0));
        CHECK(result.Coord().IsEqual(expected, tol));
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar> explicit DirectionT(const CoordT<OtherScalar, DIM>& v),
 "output":#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
TEST_CASE("case1:this is a case for Direction3", "[Common][Direction3]") {
	SECTION("Constructor from vector") {
        VectorT<double, 3> v(1.0, 2.0, 3.0);
        DirectionT<double, 3> result(v);
        CoordT<double, 3> expected(1.0 / sqrt(14.0), 2.0 / sqrt(14.0), 3.0 / sqrt(14.0));
        CHECK(result.Coord().IsEqual(expected, tol));
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename... T> explicit DirectionT(T... vs),
 "output":#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
TEST_CASE("case1:this is a case for Direction3", "[Common][Direction3]") {
	SECTION("Default constructor") {
        DirectionT<double, 3> p1;
        DirectionT<double, 3> p2(1.0, 0.0, 0.0);
        CHECK(p1.IsEqual(p2, tol));
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename... T> void SetCoord(T... vs),
 "output":#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
TEST_CASE("case1:this is a case for Direction3", "[Common][Direction3]") {
	SECTION("SetCoord(x, y, z)") {
        DirectionT<double, 3> result;
        result.SetCoord(1.0, 2.0, 3.0);
        CoordT<double, 3> expected(1.0 / sqrt(14.0), 2.0 / sqrt(14.0), 3.0 / sqrt(14.0));
        CHECK(result.Coord().IsEqual(expected, tol));
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar, typename = typename std::enable_if_t<DIM >= 4 && std::is_convertible_v<OtherScalar, Scalar>>> void SetW(const OtherScalar& w),
 "output":#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
TEST_CASE("case1:this is a case for Direction3", "[Common][Direction3]") {
	SECTION("SetX, SetY, SetZ, SetW"){
        DirectionT<double, 4> result;
        result.SetX(1);
        result.SetY(2);
        result.SetZ(3);
        result.SetW(4);
        CoordT<double, 4> expected(1.0 / sqrt(850.0), 2.0 / sqrt(850.0), 3.0 / sqrt(170), 4.0 / sqrt(17));
        CHECK(result.X() == Approx(1.0 / sqrt(850.0)));
        CHECK(result.Y() == Approx(2.0 / sqrt(850.0)));
        CHECK(result.Z() == Approx(3.0 / sqrt(170.0)));
        CHECK(result.W() == Approx(4.0 / sqrt(17.0)));
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar, typename OtherScalar2> [[nodiscard]] bool IsEqual(const DirectionT<OtherScalar, DIM>& other, const OtherScalar2& tol),
 "output":#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
TEST_CASE("case1:this is a case for Direction3", "[Common][Direction3]") {
	SECTION("Constructor from vector") {
        VectorT<double, 3> v(1.0, 2.0, 3.0);
        DirectionT<double, 3> result(v);
        CoordT<double, 3> expected(1.0 / sqrt(14.0), 2.0 / sqrt(14.0), 3.0 / sqrt(14.0));
        CHECK(result.Coord().IsEqual(expected, tol));
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar, typename OtherScalar2> [[nodiscard]] bool IsNormal(const DirectionT<OtherScalar, DIM>& other, const OtherScalar2& tol),
 "output":#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
TEST_CASE("case1:this is a case for Direction3", "[Common][Direction3]") {
	SECTION("IsNormal") {
        DirectionT<double, 3> v1(1.0, 2.0, 3.0);
        DirectionT<double, 3> v2(-4.0, -1.0, 2.01);
        CHECK(v1.IsNormal(v2, tol) == false);
        CHECK(v1.IsNormal(v2, 0.1));
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar, typename OtherScalar2> [[nodiscard]] bool IsOpposite(const DirectionT<OtherScalar, DIM>& other, const OtherScalar2& tol),
 "output":#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
TEST_CASE("case1:this is a case for Direction3", "[Common][Direction3]") {
	SECTION("IsOpposite") {
        DirectionT<double, 3> v1(1.0, 2.0, 3.0);
        DirectionT<double, 3> v2(-1.0, -2.0, -3.01);
        CHECK(v1.IsOpposite(v2, 0.1));
        CHECK(v1.IsOpposite(v2, tol) == false);
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar, typename OtherScalar2> [[nodiscard]] bool IsParallel(const DirectionT<OtherScalar, DIM>& other, const OtherScalar2& tol),
 "output":#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
TEST_CASE("case1:this is a case for Direction3", "[Common][Direction3]") {
	SECTION("IsParallel"){
        DirectionT<double, 3> v1(1.0, 2.0, 3.0);
        DirectionT<double, 3> v2(-1.0, -2.0, -3.01);
        CHECK(v1.IsParallel(v2, tol) == false);
        CHECK(v1.IsParallel(v2, 0.1));
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar, int DIM2 = DIM, std::enable_if_t<DIM2 == 3, int> = 0> [[nodiscard]] auto Angle(const DirectionT<OtherScalar, DIM>& other),
 "output":#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
TEST_CASE("case1:this is a case for Direction3", "[Common][Direction3]") {
	SECTION("Angle 3D") {
        DirectionT<double, 3> v1(1.0, 2.0, 3.0);
        DirectionT<double, 3> v2(-3.0, 2.0, -1.0);
        CHECK(v1.Angle(v2) == acos(-1.0 / 7.0));
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar, typename OtherScalar2, int DIM2 = DIM, typename = typename std::enable_if_t<DIM2 == 3>> [[nodiscard]] auto AngleWithRef(const DirectionT<OtherScalar, DIM>& other, const DirectionT<OtherScalar2, DIM>& ref),
 "output":#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
TEST_CASE("case1:this is a case for Direction3", "[Common][Direction3]") {
	SECTION("AngleWithRef") {
        DirectionT<double, 3> v1(1.0, 2.0, 3.0);
        DirectionT<double, 3> v2(-3.0, 2.0, -1.0);
        DirectionT<double, 3> v3(1.0, 1.0, 1.0);
        CHECK(v1.AngleWithRef(v2, v3) == Approx(-acos(-1.0 / 7.0)));
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar> [[nodiscard]] auto Cross(const DirectionT<OtherScalar, DIM>& other),
 "output":#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
TEST_CASE("case1:this is a case for Direction3", "[Common][Direction3]") {
	SECTION("Cross 3D") {
        DirectionT<double, 3> v1(1.0, 2.0, 3.0);
        DirectionT<double, 3> v2(2.0, 3.0, 4.0);
        CoordT<double, 3> v3(-1.0 / std::sqrt(6.0), 2.0 / std::sqrt(6.0), -1.0 / std::sqrt(6.0));
        CHECK(v1.Cross(v2).Coord().IsEqual(v3, tol));
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar> DirectionT& Mirror(const DirectionT<OtherScalar, DIM>& dir),
 "output":#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
TEST_CASE("case1:this is a case for Direction3", "[Common][Direction3]") {
	SECTION("Mirror(frame) 3D") {
        DirectionT<double, 3> p1(1.0, 2.0, 3.0);
        PointT<double, 3> p2(2.0, 3.0, 4.0);
        DirectionT<double, 3> d(7.0, 3.0, 2.0);
        FrameT<double, 3> f(p2, d);
        DirectionT<double, 3> p3(-102.0 / 31.0, 5.0 / 31.0, 55.0 / 31.0);
        CHECK(p1.Mirrored(f).IsEqual(p3, tol));
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar> DirectionT& Mirror(const AxisT<OtherScalar, DIM>& axis),
 "output":#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
TEST_CASE("case1:this is a case for Direction3", "[Common][Direction3]") {
	SECTION("Mirror(axis) 3D") {
        DirectionT<double, 3> p1(1.0, 2.0, 3.0);
        PointT<double, 3> p2(2.0, 3.0, 4.0);
        DirectionT<double, 3> d(7.0, 3.0, 2.0);
        AxisT<double, 3> a(p2, d);
        DirectionT<double, 3> p3(102.0 / 31.0, -5.0 / 31.0, -55.0 / 31.0);
        CHECK(p1.Mirrored(a).IsEqual(p3, tol));
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar, int DIM2 = DIM, std::enable_if_t<DIM2 == 3, int> = 0> DirectionT& Mirror(const FrameT<OtherScalar, DIM>& frame),
 "output":#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
TEST_CASE("case1:this is a case for Direction3", "[Common][Direction3]") {
	SECTION("Default constructor") {
        DirectionT<double, 3> p1;
        DirectionT<double, 3> p2(1.0, 0.0, 0.0);
        CHECK(p1.IsEqual(p2, tol));
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar> [[nodiscard]] DirectionT Mirrored(const AxisT<OtherScalar, DIM>& axis),
 "output":#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
TEST_CASE("case1:this is a case for Direction3", "[Common][Direction3]") {
	SECTION("Mirror(axis) 3D") {
        DirectionT<double, 3> p1(1.0, 2.0, 3.0);
        PointT<double, 3> p2(2.0, 3.0, 4.0);
        DirectionT<double, 3> d(7.0, 3.0, 2.0);
        AxisT<double, 3> a(p2, d);
        DirectionT<double, 3> p3(102.0 / 31.0, -5.0 / 31.0, -55.0 / 31.0);
        CHECK(p1.Mirrored(a).IsEqual(p3, tol));
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar, int DIM2 = DIM, std::enable_if_t<DIM2 == 3, int> = 0> [[nodiscard]] DirectionT Mirrored(const FrameT<OtherScalar, DIM>& frame),
 "output":#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
TEST_CASE("case1:this is a case for Direction3", "[Common][Direction3]") {
	SECTION("Default constructor") {
        DirectionT<double, 3> p1;
        DirectionT<double, 3> p2(1.0, 0.0, 0.0);
        CHECK(p1.IsEqual(p2, tol));
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar, typename OtherScalar2, int DIM2 = DIM, typename = typename std::enable_if_t<DIM2 == 3>> [[nodiscard]] DirectionT Rotated(const AxisT<OtherScalar, DIM>& axis, const OtherScalar2& angle),
 "output":#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
TEST_CASE("case1:this is a case for Direction3", "[Common][Direction3]") {
	SECTION("IsParallel"){
        DirectionT<double, 3> v1(1.0, 2.0, 3.0);
        DirectionT<double, 3> v2(-1.0, -2.0, -3.01);
        CHECK(v1.IsParallel(v2, tol) == false);
        CHECK(v1.IsParallel(v2, 0.1));
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename... T> explicit VectorT(T... vs),
 "output":#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
TEST_CASE("case1:this is a case for Vector2", "[Common][Vector2]"){
	SECTION("Angle 2D") {
        VectorT<double, 2> v1(1.0, 3.0);
        VectorT<double, 2> v2(-1.0, 2.0);
        CHECK(v1.Angle(v2) == Approx(acos(M_SQRT1_2)));
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar, typename OtherScalar2> VectorT(const PointT<OtherScalar, DIM>& p1, const PointT<OtherScalar2, DIM>& p2),
 "output":#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
TEST_CASE("case1:this is a case for Vector2", "[Common][Vector2]"){
	SECTION("Angle 2D") {
        VectorT<double, 2> v1(1.0, 3.0);
        VectorT<double, 2> v2(-1.0, 2.0);
        CHECK(v1.Angle(v2) == Approx(acos(M_SQRT1_2)));
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar, int DIM2 = DIM, std::enable_if_t<DIM2 == 2, int> = 0> [[nodiscard]] auto Angle(const VectorT<OtherScalar, DIM>& other),
 "output":#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
TEST_CASE("case1:this is a case for Vector2", "[Common][Vector2]"){
	SECTION("Angle 2D") {
        VectorT<double, 2> v1(1.0, 3.0);
        VectorT<double, 2> v2(-1.0, 2.0);
        CHECK(v1.Angle(v2) == Approx(acos(M_SQRT1_2)));
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar> [[nodiscard]] auto Cross(const VectorT<OtherScalar, DIM>& other),
 "output":#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
TEST_CASE("case1:this is a case for Vector2", "[Common][Vector2]"){
	SECTION("Cross 2D") {
        VectorT<double, 2> v1(1.0, 2.0);
        VectorT<double, 2> v2(2.0, 3.0);
        CHECK(v1.Cross(v2) == -1.0);
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar> VectorT& Mirror(const VectorT<OtherScalar, DIM>& p),
 "output":#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
TEST_CASE("case1:this is a case for Vector2", "[Common][Vector2]"){
	SECTION("Mirror(axis) 2D") {
        VectorT<double, 2> p1(1.0, 2.0);
        PointT<double, 2> p2(2.0, 3.0);
        DirectionT<double, 2> d(7.0, 3.0);
        AxisT<double, 2> a(p2, d);
        VectorT<double, 2> p3(62.0 / 29.0, -19.0 / 29.0);
        CHECK(p1.Mirrored(a).IsEqual(p3, tolDis, tolAng));
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar> VectorT& Mirror(const AxisT<OtherScalar, DIM>& axis),
 "output":#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
TEST_CASE("case1:this is a case for Vector2", "[Common][Vector2]"){
	SECTION("Mirror(axis) 2D") {
        VectorT<double, 2> p1(1.0, 2.0);
        PointT<double, 2> p2(2.0, 3.0);
        DirectionT<double, 2> d(7.0, 3.0);
        AxisT<double, 2> a(p2, d);
        VectorT<double, 2> p3(62.0 / 29.0, -19.0 / 29.0);
        CHECK(p1.Mirrored(a).IsEqual(p3, tolDis, tolAng));
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar> [[nodiscard]] VectorT Mirrored(const VectorT<OtherScalar, DIM>& p),
 "output":#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
TEST_CASE("case1:this is a case for Vector2", "[Common][Vector2]"){
	SECTION("Mirror(point) 2D") {
        VectorT<double, 2> p1(1.0, 2.0);
        VectorT<double, 2> p2(2.0, 3.0);
        VectorT<double, 2> p3(19.0 / 13.0, 22.0 / 13.0);
        CHECK(p1.Mirrored(p2).IsEqual(p3, tolDis, tolAng));
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar> [[nodiscard]] VectorT Mirrored(const AxisT<OtherScalar, DIM>& axis),
 "output":#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
TEST_CASE("case1:this is a case for Vector2", "[Common][Vector2]"){
	SECTION("Mirror(axis) 2D") {
        VectorT<double, 2> p1(1.0, 2.0);
        PointT<double, 2> p2(2.0, 3.0);
        DirectionT<double, 2> d(7.0, 3.0);
        AxisT<double, 2> a(p2, d);
        VectorT<double, 2> p3(62.0 / 29.0, -19.0 / 29.0);
        CHECK(p1.Mirrored(a).IsEqual(p3, tolDis, tolAng));
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar, int DIM2 = DIM, typename = typename std::enable_if_t<DIM2 == 2>> VectorT& Rotate(const OtherScalar& angle),
 "output":#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
TEST_CASE("case1:this is a case for Vector2", "[Common][Vector2]"){
	SECTION("Rotate 2D") {
        VectorT<double, 2> p1(1.0, 2.0);
        VectorT<double, 2> p3(-2.0, 1.0);
        CHECK(p1.Rotated(M_PI_2).IsEqual(p3, tolDis, tolAng));
    }
}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar, int DIM2 = DIM, typename = typename std::enable_if_t<DIM2 == 2>> [[nodiscard]] VectorT Rotated(const OtherScalar& angle),
 "output":#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
TEST_CASE("case1:this is a case for Vector2", "[Common][Vector2]"){
	SECTION("Rotate 2D") {
        VectorT<double, 2> p1(1.0, 2.0);
        VectorT<double, 2> p3(-2.0, 1.0);
        CHECK(p1.Rotated(M_PI_2).IsEqual(p3, tolDis, tolAng));
    }
}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] auto Norm()	 @return The norm of vector
	 @brief Get the norm of vector
,
 "output":#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
TEST_CASE("case1:this is a case for Vector3", "[Common][Vector3]"){
	SECTION("Norm") {
        VectorT<double, 3> v1(1.0, 2.0, 3.0);
        CHECK(v1.Norm() == sqrt(14.0));
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":VectorT()	 @details The default vector is (0, 0, ..., 0)
	 @brief The default constructor
,
 "output":#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
TEST_CASE("case1:this is a case for Vector3", "[Common][Vector3]"){
	SECTION("Default constructor") {
        VectorT<double, 3> p1;
        VectorT<double, 3> p2(0.0, 0.0, 0.0);
        CHECK(p1.IsEqual(p2, tolDis, tolAng));
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar> explicit VectorT(const DirectionT<OtherScalar, DIM>& dir),
 "output":#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
TEST_CASE("case1:this is a case for Vector3", "[Common][Vector3]"){
	SECTION("Constructor from direction") {
        DirectionT<double, 3> v(1.0, 2.0, 3.0);
        VectorT<double, 3> result(v);
        VectorT<double, 3> expected(1.0 / sqrt(14.0), 2.0 / sqrt(14.0), 3.0 / sqrt(14.0));
        CHECK(result.IsEqual(expected, tolDis, tolAng));
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar> explicit VectorT(const CoordT<OtherScalar, DIM>& v),
 "output":#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
TEST_CASE("case1:this is a case for Vector3", "[Common][Vector3]"){
	SECTION("Constructor from direction") {
        DirectionT<double, 3> v(1.0, 2.0, 3.0);
        VectorT<double, 3> result(v);
        VectorT<double, 3> expected(1.0 / sqrt(14.0), 2.0 / sqrt(14.0), 3.0 / sqrt(14.0));
        CHECK(result.IsEqual(expected, tolDis, tolAng));
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename... T> explicit VectorT(T... vs),
 "output":#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
TEST_CASE("case1:this is a case for Vector3", "[Common][Vector3]"){
	SECTION("Default constructor") {
        VectorT<double, 3> p1;
        VectorT<double, 3> p2(0.0, 0.0, 0.0);
        CHECK(p1.IsEqual(p2, tolDis, tolAng));
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar, typename OtherScalar2> VectorT(const PointT<OtherScalar, DIM>& p1, const PointT<OtherScalar2, DIM>& p2),
 "output":#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
TEST_CASE("case1:this is a case for Vector3", "[Common][Vector3]"){
	SECTION("Constructor from two points") {
        PointT<double, 3> p1(1.0, 2.0, 3.0);
        PointT<double, 3> p2(2.0, 3.0, 4.0);
        VectorT<double, 3> result(p1, p2);
        VectorT<double, 3> expected(1.0, 1.0, 1.0);
        CHECK(result.IsEqual(expected, tolDis, tolAng));
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename... T> void SetCoord(T... vs),
 "output":#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
TEST_CASE("case1:this is a case for Vector3", "[Common][Vector3]"){
	SECTION("SetCoord(x, y, z)") {
        VectorT<double, 3> result;
        result.SetCoord(1.0, 2.0, 3.0);
        VectorT<double, 3> expected(1.0, 2.0, 3.0);
        CHECK(result.IsEqual(expected, tolDis, tolAng));
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar> void SetCoord(const CoordT<OtherScalar, DIM>& v),
 "output":#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
TEST_CASE("case1:this is a case for Vector3", "[Common][Vector3]"){
	SECTION("SetCoord(v)") {
        VectorT<double, 3> result;
        result.SetCoord(CoordT<double, 3>(1.0, 2.0, 3.0));
        VectorT<double, 3> expected(1.0, 2.0, 3.0);
        CHECK(result.IsEqual(expected, tolDis, tolAng));
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar, typename OtherScalar2, typename OtherScalar3> [[nodiscard]] bool IsEqual(const VectorT<OtherScalar, DIM>& other, const OtherScalar2& tolDis, const OtherScalar3& tolAng),
 "output":#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
TEST_CASE("case1:this is a case for Vector3", "[Common][Vector3]"){
	SECTION("IsEqual") {
        VectorT<double, 3> v1(1.0, 2.0, 3.0);
        VectorT<double, 3> v2(1.01, 2.0, 3.0);
        CHECK(v1.IsEqual(v2, tolDis, tolAng) == false);
        CHECK(v1.IsEqual(v2, 0.1, tolAng) == true);
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar, typename OtherScalar2> [[nodiscard]] bool IsNormal(const VectorT<OtherScalar, DIM>& other, const OtherScalar2& tol),
 "output":#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
TEST_CASE("case1:this is a case for Vector3", "[Common][Vector3]"){
	SECTION("IsNormal") {
        VectorT<double, 3> v1(1.0, 2.0, 3.0);
        VectorT<double, 3> v2(-4.0, -1.0, 2.01);
        CHECK(v1.IsNormal(v2, 0.001) == false);
        CHECK(v1.IsNormal(v2, 0.1) == true);
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar, typename OtherScalar2> [[nodiscard]] bool IsOpposite(const VectorT<OtherScalar, DIM>& other, const OtherScalar2& tol),
 "output":#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
TEST_CASE("case1:this is a case for Vector3", "[Common][Vector3]"){
	SECTION("IsOpposite") {
        VectorT<double, 3> v1(1.0, 2.0, 3.0);
        VectorT<double, 3> v2(-1.0, -2.0, -3.01);
        CHECK(v1.IsOpposite(v2, tolDis) == false);
        CHECK(v1.IsOpposite(v2, 0.1) == true);
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar, typename OtherScalar2> [[nodiscard]] bool IsParallel(const VectorT<OtherScalar, DIM>& other, const OtherScalar2& tol),
 "output":#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
TEST_CASE("case1:this is a case for Vector3", "[Common][Vector3]"){
	SECTION("IsParallel") {
        VectorT<double, 3> v1(1.0, 2.0, 3.0);
        VectorT<double, 3> v2(-1.0, -2.0, -3.01);
        CHECK(v1.IsParallel(v2, tolDis) == false);
        CHECK(v1.IsParallel(v2, 0.1) == true);
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar, int DIM2 = DIM, std::enable_if_t<DIM2 == 3, int> = 0> [[nodiscard]] auto Angle(const VectorT<OtherScalar, DIM>& other),
 "output":#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
TEST_CASE("case1:this is a case for Vector3", "[Common][Vector3]"){
	SECTION("Angle 3D") {
        VectorT<double, 3> v1(1.0, 2.0, 3.0);
        VectorT<double, 3> v2(-3.0, 2.0, -1.0);
        CHECK(v1.Angle(v2) == acos(-1.0 / 7.0));
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar, typename OtherScalar2, int DIM2 = DIM, typename = typename std::enable_if_t<DIM2 == 3>> [[nodiscard]] Scalar AngleWithRef(const VectorT<OtherScalar, DIM>& other, const VectorT<OtherScalar2, DIM>& ref),
 "output":#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
TEST_CASE("case1:this is a case for Vector3", "[Common][Vector3]"){
	SECTION("AngleWithRef") {
        VectorT<double, 3> v1(1.0, 2.0, 3.0);
        VectorT<double, 3> v2(-3.0, 2.0, -1.0);
        VectorT<double, 3> v3(1.0, 1.0, 1.0);
        CHECK(v1.AngleWithRef(v2, v3) == -acos(-1.0 / 7.0));
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] double SquaredNorm()	 @return The squared norm of vector
	 @brief Get the squared norm of vector
,
 "output":#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
TEST_CASE("case1:this is a case for Vector3", "[Common][Vector3]"){
	SECTION("SquaredNorm") {
        VectorT<double, 3> v1(1.0, 2.0, 3.0);
        CHECK(v1.SquaredNorm() == Approx(14.0));
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar> [[nodiscard]] auto Cross(const VectorT<OtherScalar, DIM>& other),
 "output":#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
TEST_CASE("case1:this is a case for Vector3", "[Common][Vector3]"){
	SECTION("Cross 3D") {
        VectorT<double, 3> v1(1.0, 2.0, 3.0);
        VectorT<double, 3> v2(2.0, 3.0, 4.0);
        VectorT<double, 3> v3(-1.0, 2.0, -1.0);
        CHECK(v1.Cross(v2).IsEqual(v3, tolDis, tolAng));
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":VectorT& Normalize()	 @return The reference to self
	 @brief Normalize the vector
,
 "output":#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
TEST_CASE("case1:this is a case for Vector3", "[Common][Vector3]"){
	SECTION("Normalize") {
        VectorT<double, 3> v1(1.0, 2.0, 2.0);
        VectorT<double, 3> v2(1.0 / 3.0, 2.0 / 3.0, 2.0 / 3.0);
        CHECK(v1.Normalized().IsEqual(v2, tolDis, tolAng));
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] VectorT Normalized()	 @return The normalized vector
	 @brief Get the normalized vector
,
 "output":#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
TEST_CASE("case1:this is a case for Vector3", "[Common][Vector3]"){
	SECTION("Normalize") {
        VectorT<double, 3> v1(1.0, 2.0, 2.0);
        VectorT<double, 3> v2(1.0 / 3.0, 2.0 / 3.0, 2.0 / 3.0);
        CHECK(v1.Normalized().IsEqual(v2, tolDis, tolAng));
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar> VectorT& Mirror(const VectorT<OtherScalar, DIM>& p),
 "output":#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
TEST_CASE("case1:this is a case for Vector3", "[Common][Vector3]"){
	SECTION("Mirror(frame) 3D") {
        VectorT<double, 3> p1(1.0, 2.0, 3.0);
        PointT<double, 3> p2(2.0, 3.0, 4.0);
        DirectionT<double, 3> d(7.0, 3.0, 2.0);
        FrameT<double, 3> f(p2, d);
        VectorT<double, 3> p3(-102.0 / 31.0, 5.0 / 31.0, 55.0 / 31.0);
        CHECK(p1.Mirror(f).IsEqual(p3, tolDis, tolAng));
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar> VectorT& Mirror(const AxisT<OtherScalar, DIM>& axis),
 "output":#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
TEST_CASE("case1:this is a case for Vector3", "[Common][Vector3]"){
	SECTION("Mirror(axis) 3D") {
        VectorT<double, 3> p1(1.0, 2.0, 3.0);
        PointT<double, 3> p2(2.0, 3.0, 4.0);
        DirectionT<double, 3> d(7.0, 3.0, 2.0);
        AxisT<double, 3> a(p2, d);
        VectorT<double, 3> p3(102.0 / 31.0, -5.0 / 31.0, -55.0 / 31.0);
        CHECK(p1.Mirrored(a).IsEqual(p3, tolDis, tolAng));
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar, int DIM2 = DIM, std::enable_if_t<DIM2 == 3, int> = 0> VectorT& Mirror(const FrameT<OtherScalar, DIM>& frame),
 "output":#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
TEST_CASE("case1:this is a case for Vector3", "[Common][Vector3]"){
	SECTION("Mirror(axis) 3D") {
        VectorT<double, 3> p1(1.0, 2.0, 3.0);
        PointT<double, 3> p2(2.0, 3.0, 4.0);
        DirectionT<double, 3> d(7.0, 3.0, 2.0);
        AxisT<double, 3> a(p2, d);
        VectorT<double, 3> p3(102.0 / 31.0, -5.0 / 31.0, -55.0 / 31.0);
        CHECK(p1.Mirrored(a).IsEqual(p3, tolDis, tolAng));
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar> [[nodiscard]] VectorT Mirrored(const VectorT<OtherScalar, DIM>& p),
 "output":#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
TEST_CASE("case1:this is a case for Vector3", "[Common][Vector3]"){
	SECTION("Mirror(axis) 3D") {
        VectorT<double, 3> p1(1.0, 2.0, 3.0);
        PointT<double, 3> p2(2.0, 3.0, 4.0);
        DirectionT<double, 3> d(7.0, 3.0, 2.0);
        AxisT<double, 3> a(p2, d);
        VectorT<double, 3> p3(102.0 / 31.0, -5.0 / 31.0, -55.0 / 31.0);
        CHECK(p1.Mirrored(a).IsEqual(p3, tolDis, tolAng));
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar> [[nodiscard]] VectorT Mirrored(const AxisT<OtherScalar, DIM>& axis),
 "output":#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
TEST_CASE("case1:this is a case for Vector3", "[Common][Vector3]"){
	SECTION("Mirror(axis) 3D") {
        VectorT<double, 3> p1(1.0, 2.0, 3.0);
        PointT<double, 3> p2(2.0, 3.0, 4.0);
        DirectionT<double, 3> d(7.0, 3.0, 2.0);
        AxisT<double, 3> a(p2, d);
        VectorT<double, 3> p3(102.0 / 31.0, -5.0 / 31.0, -55.0 / 31.0);
        CHECK(p1.Mirrored(a).IsEqual(p3, tolDis, tolAng));
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar, int DIM2 = DIM, std::enable_if_t<DIM2 == 3, int> = 0> [[nodiscard]] VectorT Mirrored(const FrameT<OtherScalar, DIM>& frame),
 "output":#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
TEST_CASE("case1:this is a case for Vector3", "[Common][Vector3]"){
	SECTION("Mirror(axis) 3D") {
        VectorT<double, 3> p1(1.0, 2.0, 3.0);
        PointT<double, 3> p2(2.0, 3.0, 4.0);
        DirectionT<double, 3> d(7.0, 3.0, 2.0);
        AxisT<double, 3> a(p2, d);
        VectorT<double, 3> p3(102.0 / 31.0, -5.0 / 31.0, -55.0 / 31.0);
        CHECK(p1.Mirrored(a).IsEqual(p3, tolDis, tolAng));
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar, typename OtherScalar2, int DIM2 = DIM, typename = typename std::enable_if_t<DIM2 == 3>> VectorT& Rotate(const AxisT<OtherScalar, DIM>& axis, const OtherScalar2& angle),
 "output":#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
TEST_CASE("case1:this is a case for Vector3", "[Common][Vector3]"){
	SECTION("Rotate 3D") {
        VectorT<double, 3> p1(1.0, 2.0, 3.0);
        PointT<double, 3> p2(2.0, 3.0, 4.0);
        DirectionT<double, 3> d(1.0, 1.0, 2.0);
        AxisT<double, 3> a(p2, d);
        VectorT<double, 3> p3((9.0 - std::sqrt(6.0)) / 6.0, (9.0 - std::sqrt(6.0)) / 6.0, 3.0 + 1.0 / std::sqrt(6.0));
        CHECK(p1.Rotated(a, M_PI_2).IsEqual(p3, tolDis, tolAng));
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar, typename OtherScalar2, int DIM2 = DIM, typename = typename std::enable_if_t<DIM2 == 3>> [[nodiscard]] VectorT Rotated(const AxisT<OtherScalar, DIM>& axis, const OtherScalar2& angle),
 "output":#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
TEST_CASE("case1:this is a case for Vector3", "[Common][Vector3]"){
	SECTION("Rotate 3D") {
        VectorT<double, 3> p1(1.0, 2.0, 3.0);
        PointT<double, 3> p2(2.0, 3.0, 4.0);
        DirectionT<double, 3> d(1.0, 1.0, 2.0);
        AxisT<double, 3> a(p2, d);
        VectorT<double, 3> p3((9.0 - std::sqrt(6.0)) / 6.0, (9.0 - std::sqrt(6.0)) / 6.0, 3.0 + 1.0 / std::sqrt(6.0));
        CHECK(p1.Rotated(a, M_PI_2).IsEqual(p3, tolDis, tolAng));
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar> [[nodiscard]] VectorT Scaled(const OtherScalar& scale),
 "output":#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
TEST_CASE("case1:this is a case for Vector3", "[Common][Vector3]"){
	SECTION("Scale") {
        VectorT<double, 3> p1(1.0, 2.0, 3.0);
        VectorT<double, 3> p3(1.5, 3.0, 4.5);
        CHECK(p1.Scaled(1.5).IsEqual(p3, tolDis, tolAng));
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] const CoordT<Scalar, DIM>& TranslationPart()	 @return The translation part
	 @brief Get the translation part of the transformation
,
 "output":#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T>
static bool IsEqual(const T& result, const T& expected)
{
	return result == expected;
}
static bool IsEqual(const double& result, const double& expected)
{
	return std::fabs(result - expected) <= 1e-15;
}
template<typename T, int DIM>
static bool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)
{
	for (int i = 0; i < DIM; i++)
	{
		if (!IsEqual(result[i], expected[i]))
		{
			return false;
		}
	}
	return true;
}
template<typename T, int ROW, int COL>
static bool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)
{
	for (int i = 0; i < ROW; i++)
	{
		for (int j = 0; j < COL; j++)
		{
			if (!IsEqual(result(i, j), expected(i, j)))
			{
				return false;
			}
		}
	}
	return true;
}
template<typename T, int DIM>
bool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)
{
	return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());
}
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());
	}
	else if constexpr (DIM == 2)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());
	}
	else if constexpr (DIM == 3)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());
	}
	else
	{
		return false;
	}
}
template<typename T, int DIM>
bool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)
{
	return IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());
}
TEST_CASE("case1:this is a case for Transformation2", "[Common][Transformation2]") {
	SECTION("default constructor 2D") {
		TransformationT<double, 2> tr;
		MatrixT<double, 2, 2> mat;
		mat.SetIdentity();
		CoordT<double, 2> c;
		double scale = 1.0;
		CHECK(IsEqual(tr.ScaleFactor(), scale));
		CHECK(IsEqual(tr.Type(), TransformationType::Identity));
		CHECK(IsEqual(tr.HVectorialPart(), mat));
		CHECK(IsEqual(tr.TranslationPart(), c));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar> void SetMirror(const PointT<OtherScalar, DIM>& point),
 "output":#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T>
static bool IsEqual(const T& result, const T& expected)
{
	return result == expected;
}
static bool IsEqual(const double& result, const double& expected)
{
	return std::fabs(result - expected) <= 1e-15;
}
template<typename T, int DIM>
static bool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)
{
	for (int i = 0; i < DIM; i++)
	{
		if (!IsEqual(result[i], expected[i]))
		{
			return false;
		}
	}
	return true;
}
template<typename T, int ROW, int COL>
static bool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)
{
	for (int i = 0; i < ROW; i++)
	{
		for (int j = 0; j < COL; j++)
		{
			if (!IsEqual(result(i, j), expected(i, j)))
			{
				return false;
			}
		}
	}
	return true;
}
template<typename T, int DIM>
bool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)
{
	return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());
}
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());
	}
	else if constexpr (DIM == 2)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());
	}
	else if constexpr (DIM == 3)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());
	}
	else
	{
		return false;
	}
}
template<typename T, int DIM>
bool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)
{
	return IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());
}
TEST_CASE("case1:this is a case for Transformation2", "[Common][Transformation2]") {
	SECTION("SetMirror point 2D") {
		TransformationT<double, 2> tr;
		PointT<double, 2> p(2.0, 4.0);
		tr.SetMirror(p);
		CoordT<double, 2> p2(1.0, 2.0);
		tr.Transform(p2);
		CoordT<double, 2> p3(3.0, 6.0);
		CHECK(IsEqual(p2, p3));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar> void SetMirror(const AxisT<OtherScalar, DIM>& axis),
 "output":#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T>
static bool IsEqual(const T& result, const T& expected)
{
	return result == expected;
}
static bool IsEqual(const double& result, const double& expected)
{
	return std::fabs(result - expected) <= 1e-15;
}
template<typename T, int DIM>
static bool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)
{
	for (int i = 0; i < DIM; i++)
	{
		if (!IsEqual(result[i], expected[i]))
		{
			return false;
		}
	}
	return true;
}
template<typename T, int ROW, int COL>
static bool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)
{
	for (int i = 0; i < ROW; i++)
	{
		for (int j = 0; j < COL; j++)
		{
			if (!IsEqual(result(i, j), expected(i, j)))
			{
				return false;
			}
		}
	}
	return true;
}
template<typename T, int DIM>
bool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)
{
	return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());
}
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());
	}
	else if constexpr (DIM == 2)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());
	}
	else if constexpr (DIM == 3)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());
	}
	else
	{
		return false;
	}
}
template<typename T, int DIM>
bool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)
{
	return IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());
}
TEST_CASE("case1:this is a case for Transformation2", "[Common][Transformation2]") {
	SECTION("SetMirror axis 2D") {
		TransformationT<double, 2> tr;
		AxisT<double, 2> axis(PointT<double, 2>(2.0, 3.0), DirectionT<double, 2>(7.0, 3.0));
		tr.SetMirror(axis);
		CoordT<double, 2> p(1.0, 2.0);
		tr.Transform(p);
		CoordT<double, 2> p2(17.0 / 29.0, 86.0 / 29.0);
		CHECK(IsEqual(p, p2));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar, typename OtherScalar2> void SetScale(const PointT<OtherScalar, DIM>& point, const OtherScalar2& s),
 "output":#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T>
static bool IsEqual(const T& result, const T& expected)
{
	return result == expected;
}
static bool IsEqual(const double& result, const double& expected)
{
	return std::fabs(result - expected) <= 1e-15;
}
template<typename T, int DIM>
static bool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)
{
	for (int i = 0; i < DIM; i++)
	{
		if (!IsEqual(result[i], expected[i]))
		{
			return false;
		}
	}
	return true;
}
template<typename T, int ROW, int COL>
static bool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)
{
	for (int i = 0; i < ROW; i++)
	{
		for (int j = 0; j < COL; j++)
		{
			if (!IsEqual(result(i, j), expected(i, j)))
			{
				return false;
			}
		}
	}
	return true;
}
template<typename T, int DIM>
bool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)
{
	return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());
}
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());
	}
	else if constexpr (DIM == 2)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());
	}
	else if constexpr (DIM == 3)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());
	}
	else
	{
		return false;
	}
}
template<typename T, int DIM>
bool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)
{
	return IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());
}
TEST_CASE("case1:this is a case for Transformation2", "[Common][Transformation2]") {
	SECTION("SetScale 2D") {
		TransformationT<double, 2> tr;
		tr.SetScale(PointT<double, 2>(2.0, 3.0), 1.5);
		CoordT<double, 2> p(1.0, 2.0);
		tr.Transform(p);
		CoordT<double, 2> p2(0.5, 1.5);
		CHECK(IsEqual(p, p2));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar, typename OtherScalar2, int DIM2 = DIM, typename = typename std::enable_if_t<DIM2 == 2>> void SetTransformation(const AxisT<OtherScalar, DIM>& axisFrom, const AxisT<OtherScalar2, DIM>& axisTo),
 "output":#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T>
static bool IsEqual(const T& result, const T& expected)
{
	return result == expected;
}
static bool IsEqual(const double& result, const double& expected)
{
	return std::fabs(result - expected) <= 1e-15;
}
template<typename T, int DIM>
static bool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)
{
	for (int i = 0; i < DIM; i++)
	{
		if (!IsEqual(result[i], expected[i]))
		{
			return false;
		}
	}
	return true;
}
template<typename T, int ROW, int COL>
static bool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)
{
	for (int i = 0; i < ROW; i++)
	{
		for (int j = 0; j < COL; j++)
		{
			if (!IsEqual(result(i, j), expected(i, j)))
			{
				return false;
			}
		}
	}
	return true;
}
template<typename T, int DIM>
bool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)
{
	return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());
}
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());
	}
	else if constexpr (DIM == 2)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());
	}
	else if constexpr (DIM == 3)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());
	}
	else
	{
		return false;
	}
}
template<typename T, int DIM>
bool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)
{
	return IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());
}
TEST_CASE("case1:this is a case for Transformation2", "[Common][Transformation2]") {
	SECTION("SetTransformation 2D") {
		Axis2 a1(PointT<double, 2>(1.0, 2.0), DirectionT<double, 2>(3.0, 4.0));
		Axis2 a2(PointT<double, 2>(3.0, 1.0), DirectionT<double, 2>(1.0, 5.0));
		TransformationT<double, 2> tr;
		tr.SetTransformation(a1, a2);
		CoordT<double, 2> p(4.0, 1.0);
		tr.Transform(p);
		CoordT<double, 2> p2(118.0 / (5.0 * std::sqrt(26.0)), 34.0 / (5.0 * std::sqrt(26.0)));
		CHECK(IsEqual(p, p2));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar, int DIM2 = DIM, typename = typename std::enable_if_t<DIM2 == 2>> void SetTransformation(const AxisT<OtherScalar, DIM>& axisTo),
 "output":#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T>
static bool IsEqual(const T& result, const T& expected)
{
	return result == expected;
}
static bool IsEqual(const double& result, const double& expected)
{
	return std::fabs(result - expected) <= 1e-15;
}
template<typename T, int DIM>
static bool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)
{
	for (int i = 0; i < DIM; i++)
	{
		if (!IsEqual(result[i], expected[i]))
		{
			return false;
		}
	}
	return true;
}
template<typename T, int ROW, int COL>
static bool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)
{
	for (int i = 0; i < ROW; i++)
	{
		for (int j = 0; j < COL; j++)
		{
			if (!IsEqual(result(i, j), expected(i, j)))
			{
				return false;
			}
		}
	}
	return true;
}
template<typename T, int DIM>
bool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)
{
	return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());
}
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());
	}
	else if constexpr (DIM == 2)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());
	}
	else if constexpr (DIM == 3)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());
	}
	else
	{
		return false;
	}
}
template<typename T, int DIM>
bool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)
{
	return IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());
}
TEST_CASE("case1:this is a case for Transformation2", "[Common][Transformation2]") {
	SECTION("SetTransformation 2D") {
		Axis2 a1(PointT<double, 2>(1.0, 2.0), DirectionT<double, 2>(3.0, 4.0));
		TransformationT<double, 2> tr;
		tr.SetTransformation(a1);
		CoordT<double, 2> p(4.0, 1.0);
		tr.Transform(p);
		CoordT<double, 2> p2(1.0, -3.0);
		CHECK(IsEqual(p, p2));
	}
}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] Scalar ScaleFactor()	 @return The scale factor
	 @brief Get the scale factor of the transformation
,
 "output":#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T>
static bool IsEqual(const T& result, const T& expected)
{
	return result == expected;
}
static bool IsEqual(const double& result, const double& expected)
{
	return std::fabs(result - expected) <= 1e-15;
}
template<typename T, int DIM>
static bool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)
{
	for (int i = 0; i < DIM; i++)
	{
		if (!IsEqual(result[i], expected[i]))
		{
			return false;
		}
	}
	return true;
}
template<typename T, int ROW, int COL>
static bool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)
{
	for (int i = 0; i < ROW; i++)
	{
		for (int j = 0; j < COL; j++)
		{
			if (!IsEqual(result(i, j), expected(i, j)))
			{
				return false;
			}
		}
	}
	return true;
}
template<typename T, int DIM>
bool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)
{
	return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());
}
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());
	}
	else if constexpr (DIM == 2)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());
	}
	else if constexpr (DIM == 3)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());
	}
	else
	{
		return false;
	}
}
template<typename T, int DIM>
bool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)
{
	return IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());
}
#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T>
static bool IsEqual(const T& result, const T& expected)
{
	return result == expected;
}
static bool IsEqual(const double& result, const double& expected)
{
	return std::fabs(result - expected) <= 1e-15;
}
template<typename T, int DIM>
static bool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)
{
	for (int i = 0; i < DIM; i++)
	{
		if (!IsEqual(result[i], expected[i]))
		{
			return false;
		}
	}
	return true;
}
template<typename T, int ROW, int COL>
static bool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)
{
	for (int i = 0; i < ROW; i++)
	{
		for (int j = 0; j < COL; j++)
		{
			if (!IsEqual(result(i, j), expected(i, j)))
			{
				return false;
			}
		}
	}
	return true;
}
template<typename T, int DIM>
bool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)
{
	return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());
}
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());
	}
	else if constexpr (DIM == 2)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());
	}
	else if constexpr (DIM == 3)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());
	}
	else
	{
		return false;
	}
}
template<typename T, int DIM>
bool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)
{
	return IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] TransformationType Type()	 @return The transformation type
	 @brief Get the type of the transformation
,
 "output":#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T>
bool IsEqual(const T& result, const T& expected)
{
	return result == expected;
}
bool IsEqual(const double& result, const double& expected)
{
	return std::fabs(result - expected) <= 1e-6;
}
template<typename T, int DIM>
bool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)
{
	for (int i = 0; i < DIM; i++)
	{
		if (!IsEqual(result[i], expected[i]))
		{
			return false;
		}
	}
	return true;
}
template<typename T, int ROW, int COL>
bool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)
{
	for (int i = 0; i < ROW; i++)
	{
		for (int j = 0; j < COL; j++)
		{
			if (!IsEqual(result(i, j), expected(i, j)))
			{
				return false;
			}
		}
	}
	return true;
}
template<typename T, int DIM>
bool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)
{
	return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());
}
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());
	}
	else if constexpr (DIM == 2)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());
	}
	else if constexpr (DIM == 3)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());
	}
	else
	{
		return false;
	}
}
template<typename T, int DIM>
bool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)
{
	return IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());
}
TEST_CASE("case1:this is a case for Transformation3","[Common][Transformation3]")
{
	SECTION("default constructor 3D") {
		TransformationT<double, 3> tr;
		MatrixT<double, 3, 3> mat;
		mat.SetIdentity();
		CoordT<double, 3> c;
		double scale = 1.0;
		CHECK(IsEqual(tr.ScaleFactor(), scale));
		CHECK(IsEqual(tr.Type(), TransformationType::Identity));
		CHECK(IsEqual(tr.HVectorialPart(), mat));
		CHECK(IsEqual(tr.TranslationPart(), c));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] const CoordT<Scalar, DIM>& TranslationPart()	 @return The translation part
	 @brief Get the translation part of the transformation
,
 "output":#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T>
bool IsEqual(const T& result, const T& expected)
{
	return result == expected;
}
bool IsEqual(const double& result, const double& expected)
{
	return std::fabs(result - expected) <= 1e-6;
}
template<typename T, int DIM>
bool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)
{
	for (int i = 0; i < DIM; i++)
	{
		if (!IsEqual(result[i], expected[i]))
		{
			return false;
		}
	}
	return true;
}
template<typename T, int ROW, int COL>
bool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)
{
	for (int i = 0; i < ROW; i++)
	{
		for (int j = 0; j < COL; j++)
		{
			if (!IsEqual(result(i, j), expected(i, j)))
			{
				return false;
			}
		}
	}
	return true;
}
template<typename T, int DIM>
bool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)
{
	return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());
}
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());
	}
	else if constexpr (DIM == 2)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());
	}
	else if constexpr (DIM == 3)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());
	}
	else
	{
		return false;
	}
}
template<typename T, int DIM>
bool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)
{
	return IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());
}
TEST_CASE("case1:this is a case for Transformation3","[Common][Transformation3]")
{
	SECTION("default constructor 3D") {
		TransformationT<double, 3> tr;
		MatrixT<double, 3, 3> mat;
		mat.SetIdentity();
		CoordT<double, 3> c;
		double scale = 1.0;
		CHECK(IsEqual(tr.ScaleFactor(), scale));
		CHECK(IsEqual(tr.Type(), TransformationType::Identity));
		CHECK(IsEqual(tr.HVectorialPart(), mat));
		CHECK(IsEqual(tr.TranslationPart(), c));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":constexpr TransformationT()	 @details The default transformation is the identity transformation
	 @brief Default constructor
,
 "output":#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T>
bool IsEqual(const T& result, const T& expected)
{
	return result == expected;
}
bool IsEqual(const double& result, const double& expected)
{
	return std::fabs(result - expected) <= 1e-6;
}
template<typename T, int DIM>
bool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)
{
	for (int i = 0; i < DIM; i++)
	{
		if (!IsEqual(result[i], expected[i]))
		{
			return false;
		}
	}
	return true;
}
template<typename T, int ROW, int COL>
bool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)
{
	for (int i = 0; i < ROW; i++)
	{
		for (int j = 0; j < COL; j++)
		{
			if (!IsEqual(result(i, j), expected(i, j)))
			{
				return false;
			}
		}
	}
	return true;
}
template<typename T, int DIM>
bool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)
{
	return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());
}
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());
	}
	else if constexpr (DIM == 2)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());
	}
	else if constexpr (DIM == 3)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());
	}
	else
	{
		return false;
	}
}
template<typename T, int DIM>
bool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)
{
	return IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());
}
TEST_CASE("case1:this is a case for Transformation3","[Common][Transformation3]")
{
	SECTION("default constructor 3D") {
		TransformationT<double, 3> tr;
		MatrixT<double, 3, 3> mat;
		mat.SetIdentity();
		CoordT<double, 3> c;
		double scale = 1.0;
		CHECK(IsEqual(tr.ScaleFactor(), scale));
		CHECK(IsEqual(tr.Type(), TransformationType::Identity));
		CHECK(IsEqual(tr.HVectorialPart(), mat));
		CHECK(IsEqual(tr.TranslationPart(), c));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar, int OtherDIM> explicit TransformationT(const TransformationT<OtherScalar, OtherDIM>& trans),
 "output":#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T>
bool IsEqual(const T& result, const T& expected)
{
	return result == expected;
}
bool IsEqual(const double& result, const double& expected)
{
	return std::fabs(result - expected) <= 1e-6;
}
template<typename T, int DIM>
bool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)
{
	for (int i = 0; i < DIM; i++)
	{
		if (!IsEqual(result[i], expected[i]))
		{
			return false;
		}
	}
	return true;
}
template<typename T, int ROW, int COL>
bool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)
{
	for (int i = 0; i < ROW; i++)
	{
		for (int j = 0; j < COL; j++)
		{
			if (!IsEqual(result(i, j), expected(i, j)))
			{
				return false;
			}
		}
	}
	return true;
}
template<typename T, int DIM>
bool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)
{
	return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());
}
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());
	}
	else if constexpr (DIM == 2)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());
	}
	else if constexpr (DIM == 3)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());
	}
	else
	{
		return false;
	}
}
template<typename T, int DIM>
bool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)
{
	return IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());
}
TEST_CASE("case1:this is a case for Transformation3","[Common][Transformation3]")
{
	SECTION("default constructor 3D") {
		TransformationT<double, 3> tr;
		MatrixT<double, 3, 3> mat;
		mat.SetIdentity();
		CoordT<double, 3> c;
		double scale = 1.0;
		CHECK(IsEqual(tr.ScaleFactor(), scale));
		CHECK(IsEqual(tr.Type(), TransformationType::Identity));
		CHECK(IsEqual(tr.HVectorialPart(), mat));
		CHECK(IsEqual(tr.TranslationPart(), c));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar> void SetMirror(const PointT<OtherScalar, DIM>& point),
 "output":#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T>
bool IsEqual(const T& result, const T& expected)
{
	return result == expected;
}
bool IsEqual(const double& result, const double& expected)
{
	return std::fabs(result - expected) <= 1e-6;
}
template<typename T, int DIM>
bool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)
{
	for (int i = 0; i < DIM; i++)
	{
		if (!IsEqual(result[i], expected[i]))
		{
			return false;
		}
	}
	return true;
}
template<typename T, int ROW, int COL>
bool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)
{
	for (int i = 0; i < ROW; i++)
	{
		for (int j = 0; j < COL; j++)
		{
			if (!IsEqual(result(i, j), expected(i, j)))
			{
				return false;
			}
		}
	}
	return true;
}
template<typename T, int DIM>
bool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)
{
	return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());
}
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());
	}
	else if constexpr (DIM == 2)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());
	}
	else if constexpr (DIM == 3)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());
	}
	else
	{
		return false;
	}
}
template<typename T, int DIM>
bool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)
{
	return IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());
}
TEST_CASE("case1:this is a case for Transformation3","[Common][Transformation3]")
{
	SECTION("SetMirror point 3D") {
		TransformationT<double, 3> tr;
		PointT<double, 3> p(1.0, 2.0, 3.0);
		tr.SetMirror(p);
		CoordT<double, 3> p2(0.0, 1.0, 2.0);
		tr.Transform(p2);
		CoordT<double, 3> p3(2.0, 3.0, 4.0);
		CHECK(IsEqual(p2, p3));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar> void SetMirror(const AxisT<OtherScalar, DIM>& axis),
 "output":#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T>
bool IsEqual(const T& result, const T& expected)
{
	return result == expected;
}
bool IsEqual(const double& result, const double& expected)
{
	return std::fabs(result - expected) <= 1e-6;
}
template<typename T, int DIM>
bool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)
{
	for (int i = 0; i < DIM; i++)
	{
		if (!IsEqual(result[i], expected[i]))
		{
			return false;
		}
	}
	return true;
}
template<typename T, int ROW, int COL>
bool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)
{
	for (int i = 0; i < ROW; i++)
	{
		for (int j = 0; j < COL; j++)
		{
			if (!IsEqual(result(i, j), expected(i, j)))
			{
				return false;
			}
		}
	}
	return true;
}
template<typename T, int DIM>
bool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)
{
	return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());
}
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());
	}
	else if constexpr (DIM == 2)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());
	}
	else if constexpr (DIM == 3)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());
	}
	else
	{
		return false;
	}
}
template<typename T, int DIM>
bool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)
{
	return IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());
}
TEST_CASE("case1:this is a case for Transformation3","[Common][Transformation3]")
{
	SECTION("SetMirror axis 3D") {
		TransformationT<double, 3> tr;
		AxisT<double, 3> axis(PointT<double, 3>(2.0, 3.0, 4.0), DirectionT<double, 3>(7.0, 3.0, 2.0));
		tr.SetMirror(axis);
		CoordT<double, 3> p(1.0, 2.0, 3.0);
		tr.Transform(p);
		CoordT<double, 3> p2(9.0 / 31.0, 88.0 / 31.0, 131.0 / 31.0);
		CHECK(IsEqual(p, p2));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar, int DIM2 = DIM, std::enable_if_t<DIM2 == 3, int> = 0> void SetMirror(const FrameT<OtherScalar, DIM>& frame),
 "output":#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T>
bool IsEqual(const T& result, const T& expected)
{
	return result == expected;
}
bool IsEqual(const double& result, const double& expected)
{
	return std::fabs(result - expected) <= 1e-6;
}
template<typename T, int DIM>
bool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)
{
	for (int i = 0; i < DIM; i++)
	{
		if (!IsEqual(result[i], expected[i]))
		{
			return false;
		}
	}
	return true;
}
template<typename T, int ROW, int COL>
bool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)
{
	for (int i = 0; i < ROW; i++)
	{
		for (int j = 0; j < COL; j++)
		{
			if (!IsEqual(result(i, j), expected(i, j)))
			{
				return false;
			}
		}
	}
	return true;
}
template<typename T, int DIM>
bool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)
{
	return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());
}
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());
	}
	else if constexpr (DIM == 2)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());
	}
	else if constexpr (DIM == 3)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());
	}
	else
	{
		return false;
	}
}
template<typename T, int DIM>
bool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)
{
	return IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());
}
TEST_CASE("case1:this is a case for Transformation3","[Common][Transformation3]")
{
	SECTION("SetMirror axis 3D") {
		TransformationT<double, 3> tr;
		AxisT<double, 3> axis(PointT<double, 3>(2.0, 3.0, 4.0), DirectionT<double, 3>(7.0, 3.0, 2.0));
		tr.SetMirror(axis);
		CoordT<double, 3> p(1.0, 2.0, 3.0);
		tr.Transform(p);
		CoordT<double, 3> p2(9.0 / 31.0, 88.0 / 31.0, 131.0 / 31.0);
		CHECK(IsEqual(p, p2));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar, typename OtherScalar2, int DIM2 = DIM, typename = typename std::enable_if_t<DIM2 == 2>> void SetRotation(const PointT<OtherScalar, DIM>& point, const OtherScalar2& angle),
 "output":#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T>
bool IsEqual(const T& result, const T& expected)
{
	return result == expected;
}
bool IsEqual(const double& result, const double& expected)
{
	return std::fabs(result - expected) <= 1e-6;
}
template<typename T, int DIM>
bool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)
{
	for (int i = 0; i < DIM; i++)
	{
		if (!IsEqual(result[i], expected[i]))
		{
			return false;
		}
	}
	return true;
}
template<typename T, int ROW, int COL>
bool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)
{
	for (int i = 0; i < ROW; i++)
	{
		for (int j = 0; j < COL; j++)
		{
			if (!IsEqual(result(i, j), expected(i, j)))
			{
				return false;
			}
		}
	}
	return true;
}
template<typename T, int DIM>
bool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)
{
	return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());
}
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());
	}
	else if constexpr (DIM == 2)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());
	}
	else if constexpr (DIM == 3)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());
	}
	else
	{
		return false;
	}
}
template<typename T, int DIM>
bool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)
{
	return IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());
}
TEST_CASE("case1:this is a case for Transformation3","[Common][Transformation3]")
{
	SECTION("SetRotation point") {
		TransformationT<double, 2> tr;
		tr.SetRotation(PointT<double, 2>(2.0, 3.0), M_PI_2);
		CoordT<double, 2> p(1.0, 2.0);
		tr.Transform(p);
		CoordT<double, 2> p2(3.0, 2.0);
		CHECK(IsEqual(p, p2));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar, typename OtherScalar2, int DIM2 = DIM, typename = typename std::enable_if_t<DIM2 == 3>> void SetRotation(const AxisT<OtherScalar, DIM>& axis, const OtherScalar2& angle),
 "output":#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T>
bool IsEqual(const T& result, const T& expected)
{
	return result == expected;
}
bool IsEqual(const double& result, const double& expected)
{
	return std::fabs(result - expected) <= 1e-6;
}
template<typename T, int DIM>
bool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)
{
	for (int i = 0; i < DIM; i++)
	{
		if (!IsEqual(result[i], expected[i]))
		{
			return false;
		}
	}
	return true;
}
template<typename T, int ROW, int COL>
bool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)
{
	for (int i = 0; i < ROW; i++)
	{
		for (int j = 0; j < COL; j++)
		{
			if (!IsEqual(result(i, j), expected(i, j)))
			{
				return false;
			}
		}
	}
	return true;
}
template<typename T, int DIM>
bool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)
{
	return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());
}
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());
	}
	else if constexpr (DIM == 2)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());
	}
	else if constexpr (DIM == 3)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());
	}
	else
	{
		return false;
	}
}
template<typename T, int DIM>
bool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)
{
	return IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());
}
TEST_CASE("case1:this is a case for Transformation3","[Common][Transformation3]")
{
	SECTION("SetRotation axis") {
		TransformationT<double, 3> tr;
		AxisT<double, 3> a(PointT<double, 3>(2.0, 3.0, 4.0), DirectionT<double, 3>(1.0, 1.0, 2.0));
		tr.SetRotation(a, M_PI_2);
		CoordT<double, 3> p(1.0, 2.0, 3.0);
		tr.Transform(p);
		CoordT<double, 3> p2((8.0 + std::sqrt(6.0)) / 6.0, (14.0 - std::sqrt(6.0)) / 6.0, 8.0 / 3.0);
		CHECK(IsEqual(p, p2));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar, int DIM2 = DIM, typename = typename std::enable_if_t<DIM2 == 3>> void SetRotation(const QuaternionT<OtherScalar>& q),
 "output":#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T>
bool IsEqual(const T& result, const T& expected)
{
	return result == expected;
}
bool IsEqual(const double& result, const double& expected)
{
	return std::fabs(result - expected) <= 1e-6;
}
template<typename T, int DIM>
bool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)
{
	for (int i = 0; i < DIM; i++)
	{
		if (!IsEqual(result[i], expected[i]))
		{
			return false;
		}
	}
	return true;
}
template<typename T, int ROW, int COL>
bool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)
{
	for (int i = 0; i < ROW; i++)
	{
		for (int j = 0; j < COL; j++)
		{
			if (!IsEqual(result(i, j), expected(i, j)))
			{
				return false;
			}
		}
	}
	return true;
}
template<typename T, int DIM>
bool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)
{
	return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());
}
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());
	}
	else if constexpr (DIM == 2)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());
	}
	else if constexpr (DIM == 3)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());
	}
	else
	{
		return false;
	}
}
template<typename T, int DIM>
bool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)
{
	return IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());
}
TEST_CASE("case1:this is a case for Transformation3","[Common][Transformation3]")
{
	SECTION("SetRotation quaternion") {
		TransformationT<double, 3> tr;
		QuaternionT<double> q(std::sqrt(3.0) / 6.0, std::sqrt(3.0) / 6.0, std::sqrt(3.0) / 3.0, std::sqrt(2.0) / 2.0);
		tr.SetRotation(q);
		CoordT<double, 3> p(-1.0, -1.0, -1.0);
		tr.Transform(p);
		CoordT<double, 3> p2((-4.0 + std::sqrt(6.0)) / 6.0, (-4.0 - std::sqrt(6.0)) / 6.0, -4.0 / 3.0);
		CHECK(IsEqual(p, p2));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar, int DIM2 = DIM, typename = typename std::enable_if_t<DIM2 == 3>> void SetRotationPart(const QuaternionT<OtherScalar>& q),
 "output":#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T>
bool IsEqual(const T& result, const T& expected)
{
	return result == expected;
}
bool IsEqual(const double& result, const double& expected)
{
	return std::fabs(result - expected) <= 1e-6;
}
template<typename T, int DIM>
bool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)
{
	for (int i = 0; i < DIM; i++)
	{
		if (!IsEqual(result[i], expected[i]))
		{
			return false;
		}
	}
	return true;
}
template<typename T, int ROW, int COL>
bool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)
{
	for (int i = 0; i < ROW; i++)
	{
		for (int j = 0; j < COL; j++)
		{
			if (!IsEqual(result(i, j), expected(i, j)))
			{
				return false;
			}
		}
	}
	return true;
}
template<typename T, int DIM>
bool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)
{
	return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());
}
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());
	}
	else if constexpr (DIM == 2)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());
	}
	else if constexpr (DIM == 3)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());
	}
	else
	{
		return false;
	}
}
template<typename T, int DIM>
bool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)
{
	return IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());
}
TEST_CASE("case1:this is a case for Transformation3","[Common][Transformation3]")
{
	SECTION("SetRotationPart quaternion") {
		TransformationT<double, 3> tr;
		tr.SetTranslation(VectorT<double, 3>(2.0 / 3.0, 2.0 / 3.0, 4.0 / 3.0));
		QuaternionT<double> q(std::sqrt(3.0) / 6.0, std::sqrt(3.0) / 6.0, std::sqrt(3.0) / 3.0, std::sqrt(2.0) / 2.0);
		tr.SetRotationPart(q);
		CoordT<double, 3> p(-1.0, -1.0, -1.0);
		tr.Transform(p);
		CoordT<double, 3> p2(std::sqrt(6.0) / 6.0, -std::sqrt(6.0) / 6.0, 0.0);
		CHECK(IsEqual(p, p2));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar, typename OtherScalar2> void SetScale(const PointT<OtherScalar, DIM>& point, const OtherScalar2& s),
 "output":#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T>
bool IsEqual(const T& result, const T& expected)
{
	return result == expected;
}
bool IsEqual(const double& result, const double& expected)
{
	return std::fabs(result - expected) <= 1e-6;
}
template<typename T, int DIM>
bool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)
{
	for (int i = 0; i < DIM; i++)
	{
		if (!IsEqual(result[i], expected[i]))
		{
			return false;
		}
	}
	return true;
}
template<typename T, int ROW, int COL>
bool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)
{
	for (int i = 0; i < ROW; i++)
	{
		for (int j = 0; j < COL; j++)
		{
			if (!IsEqual(result(i, j), expected(i, j)))
			{
				return false;
			}
		}
	}
	return true;
}
template<typename T, int DIM>
bool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)
{
	return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());
}
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());
	}
	else if constexpr (DIM == 2)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());
	}
	else if constexpr (DIM == 3)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());
	}
	else
	{
		return false;
	}
}
template<typename T, int DIM>
bool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)
{
	return IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());
}
TEST_CASE("case1:this is a case for Transformation3","[Common][Transformation3]")
{
	SECTION("SetScale 3D") {
		TransformationT<double, 3> tr;
		tr.SetScale(PointT<double, 3>(2.0, 3.0, 4.0), 1.5);
		CoordT<double, 3> p(1.0, 2.0, 3.0);
		tr.Transform(p);
		CoordT<double, 3> p2(0.5, 1.5, 2.5);
		CHECK(IsEqual(p, p2));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar, typename OtherScalar2, int DIM2 = DIM, typename = typename std::enable_if_t<DIM2 == 3>> void SetDisplacement(const FrameT<OtherScalar, DIM>& frameFrom, const FrameT<OtherScalar2, DIM>& frameTo),
 "output":#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T>
bool IsEqual(const T& result, const T& expected)
{
	return result == expected;
}
bool IsEqual(const double& result, const double& expected)
{
	return std::fabs(result - expected) <= 1e-6;
}
template<typename T, int DIM>
bool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)
{
	for (int i = 0; i < DIM; i++)
	{
		if (!IsEqual(result[i], expected[i]))
		{
			return false;
		}
	}
	return true;
}
template<typename T, int ROW, int COL>
bool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)
{
	for (int i = 0; i < ROW; i++)
	{
		for (int j = 0; j < COL; j++)
		{
			if (!IsEqual(result(i, j), expected(i, j)))
			{
				return false;
			}
		}
	}
	return true;
}
template<typename T, int DIM>
bool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)
{
	return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());
}
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());
	}
	else if constexpr (DIM == 2)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());
	}
	else if constexpr (DIM == 3)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());
	}
	else
	{
		return false;
	}
}
template<typename T, int DIM>
bool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)
{
	return IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());
}
TEST_CASE("case1:this is a case for Transformation3","[Common][Transformation3]")
{
	SECTION("SetDisplacement") {
		FrameT<double, 3> f1(PointT<double, 3>(1.0, 2.0, 3.0), DirectionT<double, 3>(4.0, 5.0, 6.0), DirectionT<double, 3>(-3.0, -5.0, 1.0));
		FrameT<double, 3> f2(PointT<double, 3>(3.0, 1.0, -1.0), DirectionT<double, 3>(1.0, 5.0, -3.0), DirectionT<double, 3>(2.0, -2.0, 2.0));
		TransformationT<double, 3> tr;
		tr.SetDisplacement(f1, f2);
		CoordT<double, 3> p(4.0, 1.0, 3.0);
		tr.Transform(p);
		CoordT<double, 3> p2(7.0 / (7.0 * std::sqrt(55.0)) - 273.0 / (34.0 * std::sqrt(1155.0)) + 127.0 / (34.0 * std::sqrt(21.0)) + 3.0,
			35.0 / (7.0 * std::sqrt(55.0)) - 254.0 / (34.0 * std::sqrt(21.0)) + 1.0,
			-21.0 / (7.0 * std::sqrt(55.0)) - 91.0 / (34.0 * std::sqrt(1155.0)) - 381.0 / (34.0 * std::sqrt(21.0)) - 1.0);
		CHECK(IsEqual(p, p2));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar, typename OtherScalar2, int DIM2 = DIM, typename = typename std::enable_if_t<DIM2 == 3>> void SetTransformation(const FrameT<OtherScalar, DIM>& frameFrom, const FrameT<OtherScalar2, DIM>& frameTo),
 "output":#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T>
bool IsEqual(const T& result, const T& expected)
{
	return result == expected;
}
bool IsEqual(const double& result, const double& expected)
{
	return std::fabs(result - expected) <= 1e-6;
}
template<typename T, int DIM>
bool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)
{
	for (int i = 0; i < DIM; i++)
	{
		if (!IsEqual(result[i], expected[i]))
		{
			return false;
		}
	}
	return true;
}
template<typename T, int ROW, int COL>
bool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)
{
	for (int i = 0; i < ROW; i++)
	{
		for (int j = 0; j < COL; j++)
		{
			if (!IsEqual(result(i, j), expected(i, j)))
			{
				return false;
			}
		}
	}
	return true;
}
template<typename T, int DIM>
bool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)
{
	return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());
}
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());
	}
	else if constexpr (DIM == 2)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());
	}
	else if constexpr (DIM == 3)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());
	}
	else
	{
		return false;
	}
}
template<typename T, int DIM>
bool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)
{
	return IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());
}
TEST_CASE("case1:this is a case for Transformation3","[Common][Transformation3]")
{
	SECTION("SetTransformation 3D") {	
		FrameT<double, 3> f1(PointT<double, 3>(1.0, 2.0, 3.0), DirectionT<double, 3>(4.0, 5.0, 6.0), DirectionT<double, 3>(-3.0, -5.0, 1.0));
		FrameT<double, 3> f2(PointT<double, 3>(3.0, 1.0, -1.0), DirectionT<double, 3>(1.0, 5.0, -3.0), DirectionT<double, 3>(2.0, -2.0, 2.0));
		TransformationT<double, 3> tr;
		tr.SetTransformation(f1, f2);
		CoordT<double, 3> p(4.0, 1.0, 3.0);
		tr.Transform(p);
		CoordT<double, 3> p2(54.0 / std::sqrt(770.0) - 232.0 / (34.0 * std::sqrt(1155.0)) + 100.0 / (34.0 * std::sqrt(15.0)) - 2.0 / std::sqrt(10.0),
			-72.0 / (7.0 * std::sqrt(22.0)) - 1744.0 / (238.0 * std::sqrt(33.0)) + 94.0 / (34.0 * std::sqrt(21.0)) - 16.0 / std::sqrt(14.0),
			33.0 / (7.0 * std::sqrt(55.0)) - 8184.0 / (119.0 * std::sqrt(330.0)) - 60.0 / (17.0 * std::sqrt(210.0)) - 9.0 / std::sqrt(35.0));
		CHECK(IsEqual(p, p2));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar, int DIM2 = DIM, typename = typename std::enable_if_t<DIM2 == 3>> void SetTransformation(const FrameT<OtherScalar, DIM>& frameTo),
 "output":#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T>
bool IsEqual(const T& result, const T& expected)
{
	return result == expected;
}
bool IsEqual(const double& result, const double& expected)
{
	return std::fabs(result - expected) <= 1e-6;
}
template<typename T, int DIM>
bool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)
{
	for (int i = 0; i < DIM; i++)
	{
		if (!IsEqual(result[i], expected[i]))
		{
			return false;
		}
	}
	return true;
}
template<typename T, int ROW, int COL>
bool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)
{
	for (int i = 0; i < ROW; i++)
	{
		for (int j = 0; j < COL; j++)
		{
			if (!IsEqual(result(i, j), expected(i, j)))
			{
				return false;
			}
		}
	}
	return true;
}
template<typename T, int DIM>
bool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)
{
	return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());
}
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());
	}
	else if constexpr (DIM == 2)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());
	}
	else if constexpr (DIM == 3)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());
	}
	else
	{
		return false;
	}
}
template<typename T, int DIM>
bool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)
{
	return IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());
}
TEST_CASE("case1:this is a case for Transformation3","[Common][Transformation3]")
{
	SECTION("SetTransformation 3D") {
		FrameT<double, 3> f1(PointT<double, 3>(1.0, 2.0, 3.0), DirectionT<double, 3>(4.0, 5.0, 6.0), DirectionT<double, 3>(-3.0, -5.0, 1.0));
		TransformationT<double, 3> tr;
		tr.SetTransformation(f1);
		CoordT<double, 3> p(4.0, 1.0, 3.0);
		tr.Transform(p);
		CoordT<double, 3> p2(-91.0 / (17.0 * std::sqrt(462.0)), 127.0 / (17.0 * std::sqrt(6.0)), 7.0 / std::sqrt(77.0));
		CHECK(IsEqual(p, p2));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar> void SetTranslation(const VectorT<OtherScalar, DIM>& vec),
 "output":#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T>
bool IsEqual(const T& result, const T& expected)
{
	return result == expected;
}
bool IsEqual(const double& result, const double& expected)
{
	return std::fabs(result - expected) <= 1e-6;
}
template<typename T, int DIM>
bool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)
{
	for (int i = 0; i < DIM; i++)
	{
		if (!IsEqual(result[i], expected[i]))
		{
			return false;
		}
	}
	return true;
}
template<typename T, int ROW, int COL>
bool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)
{
	for (int i = 0; i < ROW; i++)
	{
		for (int j = 0; j < COL; j++)
		{
			if (!IsEqual(result(i, j), expected(i, j)))
			{
				return false;
			}
		}
	}
	return true;
}
template<typename T, int DIM>
bool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)
{
	return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());
}
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());
	}
	else if constexpr (DIM == 2)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());
	}
	else if constexpr (DIM == 3)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());
	}
	else
	{
		return false;
	}
}
template<typename T, int DIM>
bool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)
{
	return IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());
}
TEST_CASE("case1:this is a case for Transformation3","[Common][Transformation3]")
{
	SECTION("SetRotationPart quaternion") {
		TransformationT<double, 3> tr;
		tr.SetTranslation(VectorT<double, 3>(2.0 / 3.0, 2.0 / 3.0, 4.0 / 3.0));
		QuaternionT<double> q(std::sqrt(3.0) / 6.0, std::sqrt(3.0) / 6.0, std::sqrt(3.0) / 3.0, std::sqrt(2.0) / 2.0);
		tr.SetRotationPart(q);
		CoordT<double, 3> p(-1.0, -1.0, -1.0);
		tr.Transform(p);
		CoordT<double, 3> p2(std::sqrt(6.0) / 6.0, -std::sqrt(6.0) / 6.0, 0.0);
		CHECK(IsEqual(p, p2));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar, typename OtherScalar2> void SetTranslation(const PointT<OtherScalar, DIM>& p1, const PointT<OtherScalar2, DIM>& p2),
 "output":#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T>
bool IsEqual(const T& result, const T& expected)
{
	return result == expected;
}
bool IsEqual(const double& result, const double& expected)
{
	return std::fabs(result - expected) <= 1e-6;
}
template<typename T, int DIM>
bool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)
{
	for (int i = 0; i < DIM; i++)
	{
		if (!IsEqual(result[i], expected[i]))
		{
			return false;
		}
	}
	return true;
}
template<typename T, int ROW, int COL>
bool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)
{
	for (int i = 0; i < ROW; i++)
	{
		for (int j = 0; j < COL; j++)
		{
			if (!IsEqual(result(i, j), expected(i, j)))
			{
				return false;
			}
		}
	}
	return true;
}
template<typename T, int DIM>
bool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)
{
	return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());
}
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());
	}
	else if constexpr (DIM == 2)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());
	}
	else if constexpr (DIM == 3)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());
	}
	else
	{
		return false;
	}
}
template<typename T, int DIM>
bool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)
{
	return IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());
}
TEST_CASE("case1:this is a case for Transformation3","[Common][Transformation3]")
{
	SECTION("SetTranslation point 2D") {
		TransformationT<double, 2> tr;
		tr.SetTranslation(PointT<double, 2>(1.0, 2.0), PointT<double, 2>(3.0, 4.0));
		CoordT<double, 2> p(3.0, -1.0);
		tr.Transform(p);
		CoordT<double, 2> p2(5.0, 1.0);
		CHECK(IsEqual(p, p2));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar> void SetTranslationPart(const VectorT<OtherScalar, DIM>& vec),
 "output":#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T>
bool IsEqual(const T& result, const T& expected)
{
	return result == expected;
}
bool IsEqual(const double& result, const double& expected)
{
	return std::fabs(result - expected) <= 1e-6;
}
template<typename T, int DIM>
bool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)
{
	for (int i = 0; i < DIM; i++)
	{
		if (!IsEqual(result[i], expected[i]))
		{
			return false;
		}
	}
	return true;
}
template<typename T, int ROW, int COL>
bool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)
{
	for (int i = 0; i < ROW; i++)
	{
		for (int j = 0; j < COL; j++)
		{
			if (!IsEqual(result(i, j), expected(i, j)))
			{
				return false;
			}
		}
	}
	return true;
}
template<typename T, int DIM>
bool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)
{
	return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());
}
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());
	}
	else if constexpr (DIM == 2)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());
	}
	else if constexpr (DIM == 3)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());
	}
	else
	{
		return false;
	}
}
template<typename T, int DIM>
bool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)
{
	return IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());
}
TEST_CASE("case1:this is a case for Transformation3","[Common][Transformation3]")
{
	SECTION("SetTranslationPart 2D") {
		TransformationT<double, 2> tr;
		tr.SetRotation(PointT<double, 2>(2.0, 3.0), M_PI_2);
		tr.SetTranslationPart(VectorT<double, 2>(1.0, 2.0));
		CoordT<double, 2> p(1.0, 2.0);
		tr.Transform(p);
		CoordT<double, 2> p2(-1.0, 3.0);
		CHECK(IsEqual(p, p2));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":void SetType(const TransformationType& t)	 @param t The new type of transformation
	 @brief Set the type of transformation
,
 "output":#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T>
bool IsEqual(const T& result, const T& expected)
{
	return result == expected;
}
bool IsEqual(const double& result, const double& expected)
{
	return std::fabs(result - expected) <= 1e-6;
}
template<typename T, int DIM>
bool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)
{
	for (int i = 0; i < DIM; i++)
	{
		if (!IsEqual(result[i], expected[i]))
		{
			return false;
		}
	}
	return true;
}
template<typename T, int ROW, int COL>
bool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)
{
	for (int i = 0; i < ROW; i++)
	{
		for (int j = 0; j < COL; j++)
		{
			if (!IsEqual(result(i, j), expected(i, j)))
			{
				return false;
			}
		}
	}
	return true;
}
template<typename T, int DIM>
bool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)
{
	return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());
}
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());
	}
	else if constexpr (DIM == 2)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());
	}
	else if constexpr (DIM == 3)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());
	}
	else
	{
		return false;
	}
}
template<typename T, int DIM>
bool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)
{
	return IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());
}
TEST_CASE("case1:this is a case for Transformation3","[Common][Transformation3]")
{
	SECTION("SetValues 3D") {
		TransformationT<double, 3> tr;
		double a = 1.0 / 3.0;
		double b = 1.0 / 3.0 - 1.0 / std::sqrt(3.0);
		double c = 1.0 / 3.0 + 1.0 / std::sqrt(3.0);
		tr.SetValues(a, b, c, -1.0 - 1.0 / std::sqrt(3.0), c, a, b, 2.0 / std::sqrt(3.0), b, c, a, 1.0 - 1.0 / std::sqrt(3.0));
		tr.SetType(TransformationType::Rotation);
		TransformationT<double, 3> tr2;
		tr2.SetRotation(Axis3(Point3(1.0, 2.0, 3.0), Direction3(1.0, 1.0, 1.0)), M_PI_2);
		CHECK(IsEqual(tr, tr2));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] Scalar ScaleFactor()	 @return The scale factor
	 @brief Get the scale factor of the transformation
,
 "output":#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T>
bool IsEqual(const T& result, const T& expected)
{
	return result == expected;
}
bool IsEqual(const double& result, const double& expected)
{
	return std::fabs(result - expected) <= 1e-6;
}
template<typename T, int DIM>
bool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)
{
	for (int i = 0; i < DIM; i++)
	{
		if (!IsEqual(result[i], expected[i]))
		{
			return false;
		}
	}
	return true;
}
template<typename T, int ROW, int COL>
bool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)
{
	for (int i = 0; i < ROW; i++)
	{
		for (int j = 0; j < COL; j++)
		{
			if (!IsEqual(result(i, j), expected(i, j)))
			{
				return false;
			}
		}
	}
	return true;
}
template<typename T, int DIM>
bool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)
{
	return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());
}
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());
	}
	else if constexpr (DIM == 2)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());
	}
	else if constexpr (DIM == 3)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());
	}
	else
	{
		return false;
	}
}
template<typename T, int DIM>
bool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)
{
	return IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());
}
TEST_CASE("case1:this is a case for Transformation3","[Common][Transformation3]")
{
	SECTION("default constructor 3D") {
		TransformationT<double, 3> tr;
		MatrixT<double, 3, 3> mat;
		mat.SetIdentity();
		CoordT<double, 3> c;
		double scale = 1.0;
		CHECK(IsEqual(tr.ScaleFactor(), scale));
		CHECK(IsEqual(tr.Type(), TransformationType::Identity));
		CHECK(IsEqual(tr.HVectorialPart(), mat));
		CHECK(IsEqual(tr.TranslationPart(), c));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar, typename OtherScalar2, int DIM2 = DIM, typename = typename std::enable_if_t<DIM2 == 3>> void GetRotation(CoordT<OtherScalar, DIM>& axis, OtherScalar2& angle),
 "output":#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T>
bool IsEqual(const T& result, const T& expected)
{
	return result == expected;
}
bool IsEqual(const double& result, const double& expected)
{
	return std::fabs(result - expected) <= 1e-6;
}
template<typename T, int DIM>
bool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)
{
	for (int i = 0; i < DIM; i++)
	{
		if (!IsEqual(result[i], expected[i]))
		{
			return false;
		}
	}
	return true;
}
template<typename T, int ROW, int COL>
bool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)
{
	for (int i = 0; i < ROW; i++)
	{
		for (int j = 0; j < COL; j++)
		{
			if (!IsEqual(result(i, j), expected(i, j)))
			{
				return false;
			}
		}
	}
	return true;
}
template<typename T, int DIM>
bool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)
{
	return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());
}
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());
	}
	else if constexpr (DIM == 2)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());
	}
	else if constexpr (DIM == 3)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());
	}
	else
	{
		return false;
	}
}
template<typename T, int DIM>
bool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)
{
	return IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());
}
TEST_CASE("case1:this is a case for Transformation3","[Common][Transformation3]")
{
	SECTION("GetRotation") {
		TransformationT<double, 3> tr;
		tr.SetRotation(Axis3(Point3(1.0, 2.0, 3.0), Direction3(1.0, 1.0, 1.0)), M_PI_2);
		CoordT<double, 3> axis;
		double angle;
		tr.GetRotation(axis, angle);
		CoordT<double, 3> axis2(1.0 / std::sqrt(3.0));
		double angle2 = M_PI_2;
		CHECK(IsEqual(axis, axis2));
		CHECK(IsEqual(angle, angle2));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] const MatrixT<Scalar, DIM, DIM>& HVectorialPart()	 @return The homogeneous matrix
	 @brief Get the homogeneous vectorial part of the transformation, i.e. the rotation matrix
,
 "output":#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T>
bool IsEqual(const T& result, const T& expected)
{
	return result == expected;
}
bool IsEqual(const double& result, const double& expected)
{
	return std::fabs(result - expected) <= 1e-6;
}
template<typename T, int DIM>
bool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)
{
	for (int i = 0; i < DIM; i++)
	{
		if (!IsEqual(result[i], expected[i]))
		{
			return false;
		}
	}
	return true;
}
template<typename T, int ROW, int COL>
bool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)
{
	for (int i = 0; i < ROW; i++)
	{
		for (int j = 0; j < COL; j++)
		{
			if (!IsEqual(result(i, j), expected(i, j)))
			{
				return false;
			}
		}
	}
	return true;
}
template<typename T, int DIM>
bool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)
{
	return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());
}
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());
	}
	else if constexpr (DIM == 2)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());
	}
	else if constexpr (DIM == 3)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());
	}
	else
	{
		return false;
	}
}
template<typename T, int DIM>
bool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)
{
	return IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());
}
TEST_CASE("case1:this is a case for Transformation3","[Common][Transformation3]")
{
	SECTION("default constructor 3D") {
		TransformationT<double, 3> tr;
		MatrixT<double, 3, 3> mat;
		mat.SetIdentity();
		CoordT<double, 3> c;
		double scale = 1.0;
		CHECK(IsEqual(tr.ScaleFactor(), scale));
		CHECK(IsEqual(tr.Type(), TransformationType::Identity));
		CHECK(IsEqual(tr.HVectorialPart(), mat));
		CHECK(IsEqual(tr.TranslationPart(), c));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":TransformationT& Invert()	 @return The reference to self
	 @brief Invert the transformation
,
 "output":#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T>
bool IsEqual(const T& result, const T& expected)
{
	return result == expected;
}
bool IsEqual(const double& result, const double& expected)
{
	return std::fabs(result - expected) <= 1e-6;
}
template<typename T, int DIM>
bool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)
{
	for (int i = 0; i < DIM; i++)
	{
		if (!IsEqual(result[i], expected[i]))
		{
			return false;
		}
	}
	return true;
}
template<typename T, int ROW, int COL>
bool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)
{
	for (int i = 0; i < ROW; i++)
	{
		for (int j = 0; j < COL; j++)
		{
			if (!IsEqual(result(i, j), expected(i, j)))
			{
				return false;
			}
		}
	}
	return true;
}
template<typename T, int DIM>
bool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)
{
	return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());
}
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());
	}
	else if constexpr (DIM == 2)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());
	}
	else if constexpr (DIM == 3)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());
	}
	else
	{
		return false;
	}
}
template<typename T, int DIM>
bool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)
{
	return IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());
}
TEST_CASE("case1:this is a case for Transformation3","[Common][Transformation3]")
{
	SECTION("Invert") {
		TransformationT<double, 3> tr;
		tr.SetRotation(Axis3(Point3(1.0, 2.0, 3.0), Direction3(1.0, 1.0, 1.0)), M_PI_2);
		tr.Invert();
		TransformationT<double, 3> tr2;
		tr2.SetRotation(Axis3(Point3(1.0, 2.0, 3.0), Direction3(1.0, 1.0, 1.0)), -M_PI_2);
		CHECK(IsEqual(tr, tr2));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar> TransformationT& LeftMultiply(const TransformationT<OtherScalar, DIM>& other),
 "output":#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T>
bool IsEqual(const T& result, const T& expected)
{
	return result == expected;
}
bool IsEqual(const double& result, const double& expected)
{
	return std::fabs(result - expected) <= 1e-6;
}
template<typename T, int DIM>
bool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)
{
	for (int i = 0; i < DIM; i++)
	{
		if (!IsEqual(result[i], expected[i]))
		{
			return false;
		}
	}
	return true;
}
template<typename T, int ROW, int COL>
bool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)
{
	for (int i = 0; i < ROW; i++)
	{
		for (int j = 0; j < COL; j++)
		{
			if (!IsEqual(result(i, j), expected(i, j)))
			{
				return false;
			}
		}
	}
	return true;
}
template<typename T, int DIM>
bool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)
{
	return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());
}
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());
	}
	else if constexpr (DIM == 2)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());
	}
	else if constexpr (DIM == 3)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());
	}
	else
	{
		return false;
	}
}
template<typename T, int DIM>
bool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)
{
	return IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());
}
TEST_CASE("case1:this is a case for Transformation3","[Common][Transformation3]")
{
	SECTION("LeftMultiply") {
		TransformationT<double, 3> tr;
		tr.SetRotation(Axis3(Point3(1.0, 2.0, 3.0), Direction3(1.0, 1.0, 1.0)), M_PI_2);
		TransformationT<double, 3> tr2;
		tr2.SetRotation(Axis3(Point3(2.0, 3.0, 4.0), Direction3(1.0, 1.0, 2.0)), M_PI_2);
		CHECK(IsEqual(tr * tr2, tr2.LeftMultiplied(tr)));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar> [[nodiscard]] TransformationT LeftMultiplied(const TransformationT<OtherScalar, DIM>& other),
 "output":#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T>
bool IsEqual(const T& result, const T& expected)
{
	return result == expected;
}
bool IsEqual(const double& result, const double& expected)
{
	return std::fabs(result - expected) <= 1e-6;
}
template<typename T, int DIM>
bool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)
{
	for (int i = 0; i < DIM; i++)
	{
		if (!IsEqual(result[i], expected[i]))
		{
			return false;
		}
	}
	return true;
}
template<typename T, int ROW, int COL>
bool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)
{
	for (int i = 0; i < ROW; i++)
	{
		for (int j = 0; j < COL; j++)
		{
			if (!IsEqual(result(i, j), expected(i, j)))
			{
				return false;
			}
		}
	}
	return true;
}
template<typename T, int DIM>
bool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)
{
	return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());
}
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());
	}
	else if constexpr (DIM == 2)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());
	}
	else if constexpr (DIM == 3)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());
	}
	else
	{
		return false;
	}
}
template<typename T, int DIM>
bool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)
{
	return IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());
}
TEST_CASE("case1:this is a case for Transformation3","[Common][Transformation3]")
{
	SECTION("LeftMultiply") {
		TransformationT<double, 3> tr;
		tr.SetRotation(Axis3(Point3(1.0, 2.0, 3.0), Direction3(1.0, 1.0, 1.0)), M_PI_2);
		TransformationT<double, 3> tr2;
		tr2.SetRotation(Axis3(Point3(2.0, 3.0, 4.0), Direction3(1.0, 1.0, 2.0)), M_PI_2);
		CHECK(IsEqual(tr * tr2, tr2.LeftMultiplied(tr)));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] TransformationT Powered(int power)	 @return The power of transformation
	 @param power The exponential
	 @brief Get the power of transformation
,
 "output":#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T>
bool IsEqual(const T& result, const T& expected)
{
	return result == expected;
}
bool IsEqual(const double& result, const double& expected)
{
	return std::fabs(result - expected) <= 1e-6;
}
template<typename T, int DIM>
bool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)
{
	for (int i = 0; i < DIM; i++)
	{
		if (!IsEqual(result[i], expected[i]))
		{
			return false;
		}
	}
	return true;
}
template<typename T, int ROW, int COL>
bool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)
{
	for (int i = 0; i < ROW; i++)
	{
		for (int j = 0; j < COL; j++)
		{
			if (!IsEqual(result(i, j), expected(i, j)))
			{
				return false;
			}
		}
	}
	return true;
}
template<typename T, int DIM>
bool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)
{
	return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());
}
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());
	}
	else if constexpr (DIM == 2)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());
	}
	else if constexpr (DIM == 3)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());
	}
	else
	{
		return false;
	}
}
template<typename T, int DIM>
bool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)
{
	return IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());
}
TEST_CASE("case1:this is a case for Transformation3","[Common][Transformation3]")
{
	SECTION("Power") {
		TransformationT<double, 3> tr;
		tr.SetRotation(Axis3(Point3(1.0, 2.0, 3.0), Direction3(1.0, 1.0, 1.0)), M_PI_2);
		TransformationT<double, 3> tr2;
		tr2.SetRotation(Axis3(Point3(1.0, 2.0, 3.0), Direction3(1.0, 1.0, 1.0)), M_PI);
		CHECK(IsEqual(tr.Powered(2), tr2));
	}
}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar> void Transform(CoordT<OtherScalar, DIM>& coord),
 "output":#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.01
using namespace AMCAX;
using namespace std;
template<typename T>
bool IsEqual(const T& result, const T& expected)
{
	return result == expected;
}
bool IsEqual(const double& result, const double& expected)
{
	return std::fabs(result - expected) <= 1e-6;
}
template<typename T, int DIM>
bool IsEqual(const CoordT<T, DIM>& result, const CoordT<T, DIM>& expected)
{
	for (int i = 0; i < DIM; i++)
	{
		if (!IsEqual(result[i], expected[i]))
		{
			return false;
		}
	}
	return true;
}
template<typename T, int ROW, int COL>
bool IsEqual(const MatrixT<T, ROW, COL>& result, const MatrixT<T, ROW, COL>& expected)
{
	for (int i = 0; i < ROW; i++)
	{
		for (int j = 0; j < COL; j++)
		{
			if (!IsEqual(result(i, j), expected(i, j)))
			{
				return false;
			}
		}
	}
	return true;
}
template<typename T, int DIM>
bool IsEqual(const PointT<T, DIM>& result, const PointT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const VectorT<T, DIM>& result, const VectorT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const DirectionT<T, DIM>& result, const DirectionT<T, DIM>& expected)
{
	return IsEqual(result.Coord(), expected.Coord());
}
template<typename T, int DIM>
bool IsEqual(const AxisT<T, DIM>& result, const AxisT<T, DIM>& expected)
{
	return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());
}
template<typename T, int DIM>
bool IsEqual(const FrameT<T, DIM>& result, const FrameT<T, DIM>& expected)
{
	if constexpr (DIM == 1)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction());
	}
	else if constexpr (DIM == 2)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.YDirection(), expected.YDirection()) && IsEqual(result.XDirection(), expected.XDirection());
	}
	else if constexpr (DIM == 3)
	{
		return IsEqual(result.Location(), expected.Location()) && IsEqual(result.Direction(), expected.Direction()) && IsEqual(result.XDirection(), expected.XDirection()) && IsEqual(result.YDirection(), expected.YDirection());
	}
	else
	{
		return false;
	}
}
template<typename T, int DIM>
bool IsEqual(const TransformationT<T, DIM>& result, const TransformationT<T, DIM>& expected)
{
	return IsEqual(result.ScaleFactor(), expected.ScaleFactor()) && IsEqual(result.Type(), expected.Type()) && IsEqual(result.HVectorialPart(), expected.HVectorialPart()) && IsEqual(result.TranslationPart(), expected.TranslationPart());
}
TEST_CASE("case1:this is a case for Transformation3","[Common][Transformation3]")
{
	SECTION("SetMirror point 3D") {
		TransformationT<double, 3> tr;
		PointT<double, 3> p(1.0, 2.0, 3.0);
		tr.SetMirror(p);
		CoordT<double, 3> p2(0.0, 1.0, 2.0);
		tr.Transform(p2);
		CoordT<double, 3> p3(2.0, 3.0, 4.0);
		CHECK(IsEqual(p2, p3));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar> PointT& Mirror(const PointT<OtherScalar, DIM>& p),
 "output":#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <iostream>
#define tol 0.001
using namespace AMCAX;
using namespace std;
TEST_CASE("case1:this is a case for Point2", "[Common][Point2]") {
	SECTION("Mirror(axis) 2D") {
        PointT<double, 2> p1(1.0, 2.0);
        PointT<double, 2> p2(2.0, 3.0);
        DirectionT<double, 2> d(7.0, 3.0);
        AxisT<double, 2> a(p2, d);
        PointT<double, 2> p3(17.0 / 29.0, 86.0 / 29.0);
        CHECK(p1.Mirrored(a).IsEqual(p3, tol));
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar> PointT& Mirror(const AxisT<OtherScalar, DIM>& axis),
 "output":#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <iostream>
#define tol 0.001
using namespace AMCAX;
using namespace std;
TEST_CASE("case1:this is a case for Point2", "[Common][Point2]") {
	SECTION("Mirror(axis) 2D") {
        PointT<double, 2> p1(1.0, 2.0);
        PointT<double, 2> p2(2.0, 3.0);
        DirectionT<double, 2> d(7.0, 3.0);
        AxisT<double, 2> a(p2, d);
        PointT<double, 2> p3(17.0 / 29.0, 86.0 / 29.0);
        CHECK(p1.Mirrored(a).IsEqual(p3, tol));
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar> [[nodiscard]] PointT Mirrored(const PointT<OtherScalar, DIM>& p),
 "output":#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <iostream>
#define tol 0.001
using namespace AMCAX;
using namespace std;
TEST_CASE("case1:this is a case for Point2", "[Common][Point2]") {
	SECTION("Mirror(point) 2D") {
        PointT<double, 2> p1(1.0, 2.0);
        PointT<double, 2> p2(2.0, 4.0);
        PointT<double, 2> p3(3.0, 6.0);
        CHECK(p1.Mirrored(p2).IsEqual(p3, tol));
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar> [[nodiscard]] PointT Mirrored(const AxisT<OtherScalar, DIM>& axis),
 "output":#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <iostream>
#define tol 0.001
using namespace AMCAX;
using namespace std;
TEST_CASE("case1:this is a case for Point2", "[Common][Point2]") {
	SECTION("Mirror(axis) 2D") {
        PointT<double, 2> p1(1.0, 2.0);
        PointT<double, 2> p2(2.0, 3.0);
        DirectionT<double, 2> d(7.0, 3.0);
        AxisT<double, 2> a(p2, d);
        PointT<double, 2> p3(17.0 / 29.0, 86.0 / 29.0);
        CHECK(p1.Mirrored(a).IsEqual(p3, tol));
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar, typename OtherScalar2, int DIM2 = DIM, typename = typename std::enable_if_t<DIM2 == 2>> [[nodiscard]] PointT Rotated(const PointT<OtherScalar, DIM>& point, const OtherScalar2& angle),
 "output":#include<catch.hpp>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <iostream>
#define tol 0.001
using namespace AMCAX;
using namespace std;
TEST_CASE("case1:this is a case for Point2", "[Common][Point2]") {
	SECTION("Rotate 2D") {
        PointT<double, 2> p1(1.0, 2.0);
        PointT<double, 2> p2(2.0, 3.0);
        PointT<double, 2> p3(3.0, 2.0);
        CHECK(p1.Rotated(p2, M_PI_2).IsEqual(p3, tol));
    }
}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar, typename OtherScalar2> [[nodiscard]] bool IsEqual(const PointT<OtherScalar, DIM>& other, const OtherScalar2& tol),
 "output":#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.1
using namespace AMCAX;
using namespace std;
TEST_CASE("case1:this is a case for Point3", "[Common][Point3]") {
	SECTION("SetZ") {
        PointT<double, 3> result;
        result.SetZ(1);
        PointT<double, 3> expected(0.0, 0.0, 1.0);
        CHECK(result.IsEqual(expected, tol));
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar> [[nodiscard]] auto Distance(const PointT<OtherScalar, DIM>& other),
 "output":#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.1
using namespace AMCAX;
using namespace std;
TEST_CASE("case1:this is a case for Point3", "[Common][Point3]") {
	SECTION("Distance") {
        PointT<double, 3> p1(1.0, 2.0, 3.0);
        PointT<double, 3> p2(1.4, 2.5, 3.6);
        CHECK(p1.Distance(p2) == sqrt(0.77));
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar> [[nodiscard]] auto SquaredDistance(const PointT<OtherScalar, DIM>& other),
 "output":#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.1
using namespace AMCAX;
using namespace std;
TEST_CASE("case1:this is a case for Point3", "[Common][Point3]") {
	SECTION("SquaredDistance") {
        PointT<double, 3> p1(1.0, 2.0, 3.0);
        PointT<double, 3> p2(1.1, 2.2, 3.3);
        CHECK(p1.SquaredDistance(p2) == Approx(0.14));
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar> PointT& Mirror(const PointT<OtherScalar, DIM>& p),
 "output":#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.1
using namespace AMCAX;
using namespace std;
TEST_CASE("case1:this is a case for Point3", "[Common][Point3]") {
	SECTION("Mirror(axis) 3D") {
        PointT<double, 3> p1(1.0, 2.0, 3.0);
        PointT<double, 3> p2(2.0, 3.0, 4.0);
        DirectionT<double, 3> d(7.0, 3.0, 2.0);
        AxisT<double, 3> a(p2, d);
        PointT<double, 3> p3(9.0 / 31.0, 88.0 / 31.0, 131.0 / 31.0);
        CHECK(p1.Mirrored(a).IsEqual(p3, tol));
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar> PointT& Mirror(const AxisT<OtherScalar, DIM>& axis),
 "output":#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.1
using namespace AMCAX;
using namespace std;
TEST_CASE("case1:this is a case for Point3", "[Common][Point3]") {
	SECTION("Mirror(axis) 3D") {
        PointT<double, 3> p1(1.0, 2.0, 3.0);
        PointT<double, 3> p2(2.0, 3.0, 4.0);
        DirectionT<double, 3> d(7.0, 3.0, 2.0);
        AxisT<double, 3> a(p2, d);
        PointT<double, 3> p3(9.0 / 31.0, 88.0 / 31.0, 131.0 / 31.0);
        CHECK(p1.Mirrored(a).IsEqual(p3, tol));
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar, int DIM2 = DIM, std::enable_if_t<DIM2 == 3, int> = 0> PointT& Mirror(const FrameT<OtherScalar, DIM>& frame),
 "output":#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.1
using namespace AMCAX;
using namespace std;
TEST_CASE("case1:this is a case for Point3", "[Common][Point3]") {
	SECTION("Mirror(axis) 3D") {
        PointT<double, 3> p1(1.0, 2.0, 3.0);
        PointT<double, 3> p2(2.0, 3.0, 4.0);
        DirectionT<double, 3> d(7.0, 3.0, 2.0);
        AxisT<double, 3> a(p2, d);
        PointT<double, 3> p3(9.0 / 31.0, 88.0 / 31.0, 131.0 / 31.0);
        CHECK(p1.Mirrored(a).IsEqual(p3, tol));
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar> [[nodiscard]] PointT Mirrored(const AxisT<OtherScalar, DIM>& axis),
 "output":#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.1
using namespace AMCAX;
using namespace std;
TEST_CASE("case1:this is a case for Point3", "[Common][Point3]") {
	SECTION("Mirror(axis) 3D") {
        PointT<double, 3> p1(1.0, 2.0, 3.0);
        PointT<double, 3> p2(2.0, 3.0, 4.0);
        DirectionT<double, 3> d(7.0, 3.0, 2.0);
        AxisT<double, 3> a(p2, d);
        PointT<double, 3> p3(9.0 / 31.0, 88.0 / 31.0, 131.0 / 31.0);
        CHECK(p1.Mirrored(a).IsEqual(p3, tol));
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar, int DIM2 = DIM, std::enable_if_t<DIM2 == 3, int> = 0> [[nodiscard]] PointT Mirrored(const FrameT<OtherScalar, DIM>& frame),
 "output":#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.1
using namespace AMCAX;
using namespace std;
TEST_CASE("case1:this is a case for Point3", "[Common][Point3]") {
	SECTION("Mirror(point) 3D") {
        PointT<double, 3> p1(1.0, 2.0, 3.0);
        PointT<double, 3> p2(2.0, 4.0, 5.0);
        PointT<double, 3> p3(3.0, 6.0, 7.0);
        CHECK(p1.Mirrored(p2).IsEqual(p3, tol));
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar, typename OtherScalar2, int DIM2 = DIM, typename = typename std::enable_if_t<DIM2 == 3>> PointT& Rotate(const AxisT<OtherScalar, DIM>& axis, const OtherScalar2& angle),
 "output":#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.1
using namespace AMCAX;
using namespace std;
TEST_CASE("case1:this is a case for Point3", "[Common][Point3]") {
	SECTION("Rotate 3D") {
        PointT<double, 3> p1(1.0, 2.0, 3.0);
        PointT<double, 3> p2(2.0, 3.0, 4.0);
        DirectionT<double, 3> d(1.0, 1.0, 2.0);
        AxisT<double, 3> a(p2, d);
        PointT<double, 3> p3((8.0 + std::sqrt(6.0)) / 6.0, (14.0 - std::sqrt(6.0)) / 6.0, 8.0 / 3.0);
        CHECK(p1.Rotated(a, M_PI_2).IsEqual(p3, tol));
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar, typename OtherScalar2, int DIM2 = DIM, typename = typename std::enable_if_t<DIM2 == 3>> [[nodiscard]] PointT Rotated(const AxisT<OtherScalar, DIM>& axis, const OtherScalar2& angle),
 "output":#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.1
using namespace AMCAX;
using namespace std;
TEST_CASE("case1:this is a case for Point3", "[Common][Point3]") {
	SECTION("Rotate 3D") {
        PointT<double, 3> p1(1.0, 2.0, 3.0);
        PointT<double, 3> p2(2.0, 3.0, 4.0);
        DirectionT<double, 3> d(1.0, 1.0, 2.0);
        AxisT<double, 3> a(p2, d);
        PointT<double, 3> p3((8.0 + std::sqrt(6.0)) / 6.0, (14.0 - std::sqrt(6.0)) / 6.0, 8.0 / 3.0);
        CHECK(p1.Rotated(a, M_PI_2).IsEqual(p3, tol));
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":template<typename OtherScalar> [[nodiscard]] PointT Translated(const VectorT<OtherScalar, DIM>& vec),
 "output":#include<catch.hpp>
#include <sstream>
#include <common/AxisT.hpp>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <common/PointT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <iostream>
#define tol 0.001
#define tolDis 0.001
#define tolAng 0.1
using namespace AMCAX;
using namespace std;
TEST_CASE("case1:this is a case for Point3", "[Common][Point3]") {
	SECTION("Translate(vec)") {
        PointT<double, 3> p1(1.0, 2.0, 3.0);
        VectorT<double, 3> v1(2.0, 3.0, 4.0);
        PointT<double, 3> p2(3.0, 5.0, 7.0);
        CHECK(p1.Translated(v1).IsEqual(p2, tol));
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API MakeFace(const std::shared_ptr<Geom3Surface>& s, double tolDegen)	 @param tolDegen The tolerance
	 @param s The surface
	 @brief Construct from a surface with tolerance for degenerated edges
,
 "output":#include <catch.hpp>
#include "testHelper.h"
#include<iostream>
#include <common/PointT.hpp>
#include <topology/TopoEdge.hpp>
#include <modeling/MakeWire.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <topology/TopoWire.hpp>
#include <topology/TopoShape.hpp>
#include <topology/TopoFace.hpp>
#include <modeling/MakeFace.hpp>
AMCAX::TopoFace crashbug1() {
    double h1 = 7., h2 = 3.;
    AMCAX::Point2 p1(0., h1 / 2.0), p2(30., h2 / 2.0), p3(30., -h2 / 2.0), p4(0., -h1 / 2.0);
    std::vector<AMCAX::Point2> v_p;
    v_p.push_back(p1);
    v_p.push_back(p2);
    v_p.push_back(p3);
    v_p.push_back(p4);
    AMCAX::TopoEdge e;
    std::list<AMCAX::TopoShape> edges_polygon;
    for (int i = 1; i < v_p.size(); i++) {
        e = AMCAX::MakeEdge2d(v_p[i - 1], v_p[i]);
        edges_polygon.push_back(e);
    }
    e = AMCAX::MakeEdge2d(v_p[3], v_p[0]);
    edges_polygon.push_back(e);
    AMCAX::MakeWire mkw;
    mkw.Add(edges_polygon);
    AMCAX::TopoWire w_poly = mkw;
    AMCAX::TopoFace f_poly = AMCAX::MakeFace(w_poly, true);
    return f_poly;
}
#include <catch.hpp>
#include "testHelper.h"
#include<iostream>
#include <common/PointT.hpp>
#include <topology/TopoEdge.hpp>
#include <modeling/MakeWire.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <topology/TopoWire.hpp>
#include <topology/TopoShape.hpp>
#include <topology/TopoFace.hpp>
#include <modeling/MakeFace.hpp>
AMCAX::TopoFace crashbug1() {
    double h1 = 7., h2 = 3.;
    AMCAX::Point2 p1(0., h1 / 2.0), p2(30., h2 / 2.0), p3(30., -h2 / 2.0), p4(0., -h1 / 2.0);
    std::vector<AMCAX::Point2> v_p;
    v_p.push_back(p1);
    v_p.push_back(p2);
    v_p.push_back(p3);
    v_p.push_back(p4);
    AMCAX::TopoEdge e;
    std::list<AMCAX::TopoShape> edges_polygon;
    for (int i = 1; i < v_p.size(); i++) {
        e = AMCAX::MakeEdge2d(v_p[i - 1], v_p[i]);
        edges_polygon.push_back(e);
    }
    e = AMCAX::MakeEdge2d(v_p[3], v_p[0]);
    edges_polygon.push_back(e);
    AMCAX::MakeWire mkw;
    mkw.Add(edges_polygon);
    AMCAX::TopoWire w_poly = mkw;
    AMCAX::TopoFace f_poly = AMCAX::MakeFace(w_poly, true);
    return f_poly;
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API explicit MakeFace(const TopoWire& w, bool onlyPlane = false)	 @param onlyPlane If true, the surface will be a plane
	 @param w The wire
	 @brief Construct from a wire
,
 "output":#include <catch.hpp>
#include "testHelper.h"
#include<iostream>
#include <common/PointT.hpp>
#include <topology/TopoEdge.hpp>
#include <modeling/MakeWire.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <topology/TopoWire.hpp>
#include <topology/TopoShape.hpp>
#include <topology/TopoFace.hpp>
#include <modeling/MakeFace.hpp>
AMCAX::TopoFace crashbug1() {
    double h1 = 7., h2 = 3.;
    AMCAX::Point2 p1(0., h1 / 2.0), p2(30., h2 / 2.0), p3(30., -h2 / 2.0), p4(0., -h1 / 2.0);
    std::vector<AMCAX::Point2> v_p;
    v_p.push_back(p1);
    v_p.push_back(p2);
    v_p.push_back(p3);
    v_p.push_back(p4);
    AMCAX::TopoEdge e;
    std::list<AMCAX::TopoShape> edges_polygon;
    for (int i = 1; i < v_p.size(); i++) {
        e = AMCAX::MakeEdge2d(v_p[i - 1], v_p[i]);
        edges_polygon.push_back(e);
    }
    e = AMCAX::MakeEdge2d(v_p[3], v_p[0]);
    edges_polygon.push_back(e);
    AMCAX::MakeWire mkw;
    mkw.Add(edges_polygon);
    AMCAX::TopoWire w_poly = mkw;
    AMCAX::TopoFace f_poly = AMCAX::MakeFace(w_poly, true);
    return f_poly;
}
#include <catch.hpp>
#include "testHelper.h"
#include<iostream>
#include <common/PointT.hpp>
#include <topology/TopoEdge.hpp>
#include <modeling/MakeWire.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <topology/TopoWire.hpp>
#include <topology/TopoShape.hpp>
#include <topology/TopoFace.hpp>
#include <modeling/MakeFace.hpp>
AMCAX::TopoFace crashbug1() {
    double h1 = 7., h2 = 3.;
    AMCAX::Point2 p1(0., h1 / 2.0), p2(30., h2 / 2.0), p3(30., -h2 / 2.0), p4(0., -h1 / 2.0);
    std::vector<AMCAX::Point2> v_p;
    v_p.push_back(p1);
    v_p.push_back(p2);
    v_p.push_back(p3);
    v_p.push_back(p4);
    AMCAX::TopoEdge e;
    std::list<AMCAX::TopoShape> edges_polygon;
    for (int i = 1; i < v_p.size(); i++) {
        e = AMCAX::MakeEdge2d(v_p[i - 1], v_p[i]);
        edges_polygon.push_back(e);
    }
    e = AMCAX::MakeEdge2d(v_p[3], v_p[0]);
    edges_polygon.push_back(e);
    AMCAX::MakeWire mkw;
    mkw.Add(edges_polygon);
    AMCAX::TopoWire w_poly = mkw;
    AMCAX::TopoFace f_poly = AMCAX::MakeFace(w_poly, true);
    return f_poly;
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API MakeFace(const Plane& p, const TopoWire& w, bool inside = true)	 @param inside Whether the face is inside the wire
	 @param w The wire
	 @param p The plane
	 @brief Construct from a plane and a wire
,
 "output":#include <catch.hpp>
#include "testHelper.h"
#include<iostream>
#include <common/PointT.hpp>
#include <topology/TopoEdge.hpp>
#include <modeling/MakeWire.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <topology/TopoWire.hpp>
#include <topology/TopoShape.hpp>
#include <topology/TopoFace.hpp>
#include <modeling/MakeFace.hpp>
AMCAX::TopoFace crashbug1() {
    double h1 = 7., h2 = 3.;
    AMCAX::Point2 p1(0., h1 / 2.0), p2(30., h2 / 2.0), p3(30., -h2 / 2.0), p4(0., -h1 / 2.0);
    std::vector<AMCAX::Point2> v_p;
    v_p.push_back(p1);
    v_p.push_back(p2);
    v_p.push_back(p3);
    v_p.push_back(p4);
    AMCAX::TopoEdge e;
    std::list<AMCAX::TopoShape> edges_polygon;
    for (int i = 1; i < v_p.size(); i++) {
        e = AMCAX::MakeEdge2d(v_p[i - 1], v_p[i]);
        edges_polygon.push_back(e);
    }
    e = AMCAX::MakeEdge2d(v_p[3], v_p[0]);
    edges_polygon.push_back(e);
    AMCAX::MakeWire mkw;
    mkw.Add(edges_polygon);
    AMCAX::TopoWire w_poly = mkw;
    AMCAX::TopoFace f_poly = AMCAX::MakeFace(w_poly, true);
    return f_poly;
}
#include <catch.hpp>
#include "testHelper.h"
#include<iostream>
#include <common/PointT.hpp>
#include <topology/TopoEdge.hpp>
#include <modeling/MakeWire.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <topology/TopoWire.hpp>
#include <topology/TopoShape.hpp>
#include <topology/TopoFace.hpp>
#include <modeling/MakeFace.hpp>
AMCAX::TopoFace crashbug1() {
    double h1 = 7., h2 = 3.;
    AMCAX::Point2 p1(0., h1 / 2.0), p2(30., h2 / 2.0), p3(30., -h2 / 2.0), p4(0., -h1 / 2.0);
    std::vector<AMCAX::Point2> v_p;
    v_p.push_back(p1);
    v_p.push_back(p2);
    v_p.push_back(p3);
    v_p.push_back(p4);
    AMCAX::TopoEdge e;
    std::list<AMCAX::TopoShape> edges_polygon;
    for (int i = 1; i < v_p.size(); i++) {
        e = AMCAX::MakeEdge2d(v_p[i - 1], v_p[i]);
        edges_polygon.push_back(e);
    }
    e = AMCAX::MakeEdge2d(v_p[3], v_p[0]);
    edges_polygon.push_back(e);
    AMCAX::MakeWire mkw;
    mkw.Add(edges_polygon);
    AMCAX::TopoWire w_poly = mkw;
    AMCAX::TopoFace f_poly = AMCAX::MakeFace(w_poly, true);
    return f_poly;
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API MakeFace(const Cylinder& c, const TopoWire& w, bool inside = true)	 @param inside Whether the face is inside the wire
	 @param w The wire
	 @param c The cylinder
	 @brief Construct from a cylinder and a wire
,
 "output":#include <catch.hpp>
#include "testHelper.h"
#include<iostream>
#include <common/PointT.hpp>
#include <topology/TopoEdge.hpp>
#include <modeling/MakeWire.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <topology/TopoWire.hpp>
#include <topology/TopoShape.hpp>
#include <topology/TopoFace.hpp>
#include <modeling/MakeFace.hpp>
AMCAX::TopoFace crashbug1() {
    double h1 = 7., h2 = 3.;
    AMCAX::Point2 p1(0., h1 / 2.0), p2(30., h2 / 2.0), p3(30., -h2 / 2.0), p4(0., -h1 / 2.0);
    std::vector<AMCAX::Point2> v_p;
    v_p.push_back(p1);
    v_p.push_back(p2);
    v_p.push_back(p3);
    v_p.push_back(p4);
    AMCAX::TopoEdge e;
    std::list<AMCAX::TopoShape> edges_polygon;
    for (int i = 1; i < v_p.size(); i++) {
        e = AMCAX::MakeEdge2d(v_p[i - 1], v_p[i]);
        edges_polygon.push_back(e);
    }
    e = AMCAX::MakeEdge2d(v_p[3], v_p[0]);
    edges_polygon.push_back(e);
    AMCAX::MakeWire mkw;
    mkw.Add(edges_polygon);
    AMCAX::TopoWire w_poly = mkw;
    AMCAX::TopoFace f_poly = AMCAX::MakeFace(w_poly, true);
    return f_poly;
}
#include <catch.hpp>
#include "testHelper.h"
#include<iostream>
#include <common/PointT.hpp>
#include <topology/TopoEdge.hpp>
#include <modeling/MakeWire.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <topology/TopoWire.hpp>
#include <topology/TopoShape.hpp>
#include <topology/TopoFace.hpp>
#include <modeling/MakeFace.hpp>
AMCAX::TopoFace crashbug1() {
    double h1 = 7., h2 = 3.;
    AMCAX::Point2 p1(0., h1 / 2.0), p2(30., h2 / 2.0), p3(30., -h2 / 2.0), p4(0., -h1 / 2.0);
    std::vector<AMCAX::Point2> v_p;
    v_p.push_back(p1);
    v_p.push_back(p2);
    v_p.push_back(p3);
    v_p.push_back(p4);
    AMCAX::TopoEdge e;
    std::list<AMCAX::TopoShape> edges_polygon;
    for (int i = 1; i < v_p.size(); i++) {
        e = AMCAX::MakeEdge2d(v_p[i - 1], v_p[i]);
        edges_polygon.push_back(e);
    }
    e = AMCAX::MakeEdge2d(v_p[3], v_p[0]);
    edges_polygon.push_back(e);
    AMCAX::MakeWire mkw;
    mkw.Add(edges_polygon);
    AMCAX::TopoWire w_poly = mkw;
    AMCAX::TopoFace f_poly = AMCAX::MakeFace(w_poly, true);
    return f_poly;
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API MakeFace(const Cone& c, const TopoWire& w, bool inside = true)	 @param inside Whether the face is inside the wire
	 @param w The wire
	 @param c The cone
	 @brief Construct from a cone and a wire
,
 "output":#include <catch.hpp>
#include "testHelper.h"
#include<iostream>
#include <common/PointT.hpp>
#include <topology/TopoEdge.hpp>
#include <modeling/MakeWire.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <topology/TopoWire.hpp>
#include <topology/TopoShape.hpp>
#include <topology/TopoFace.hpp>
#include <modeling/MakeFace.hpp>
AMCAX::TopoFace crashbug1() {
    double h1 = 7., h2 = 3.;
    AMCAX::Point2 p1(0., h1 / 2.0), p2(30., h2 / 2.0), p3(30., -h2 / 2.0), p4(0., -h1 / 2.0);
    std::vector<AMCAX::Point2> v_p;
    v_p.push_back(p1);
    v_p.push_back(p2);
    v_p.push_back(p3);
    v_p.push_back(p4);
    AMCAX::TopoEdge e;
    std::list<AMCAX::TopoShape> edges_polygon;
    for (int i = 1; i < v_p.size(); i++) {
        e = AMCAX::MakeEdge2d(v_p[i - 1], v_p[i]);
        edges_polygon.push_back(e);
    }
    e = AMCAX::MakeEdge2d(v_p[3], v_p[0]);
    edges_polygon.push_back(e);
    AMCAX::MakeWire mkw;
    mkw.Add(edges_polygon);
    AMCAX::TopoWire w_poly = mkw;
    AMCAX::TopoFace f_poly = AMCAX::MakeFace(w_poly, true);
    return f_poly;
}
#include <catch.hpp>
#include "testHelper.h"
#include<iostream>
#include <common/PointT.hpp>
#include <topology/TopoEdge.hpp>
#include <modeling/MakeWire.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <topology/TopoWire.hpp>
#include <topology/TopoShape.hpp>
#include <topology/TopoFace.hpp>
#include <modeling/MakeFace.hpp>
AMCAX::TopoFace crashbug1() {
    double h1 = 7., h2 = 3.;
    AMCAX::Point2 p1(0., h1 / 2.0), p2(30., h2 / 2.0), p3(30., -h2 / 2.0), p4(0., -h1 / 2.0);
    std::vector<AMCAX::Point2> v_p;
    v_p.push_back(p1);
    v_p.push_back(p2);
    v_p.push_back(p3);
    v_p.push_back(p4);
    AMCAX::TopoEdge e;
    std::list<AMCAX::TopoShape> edges_polygon;
    for (int i = 1; i < v_p.size(); i++) {
        e = AMCAX::MakeEdge2d(v_p[i - 1], v_p[i]);
        edges_polygon.push_back(e);
    }
    e = AMCAX::MakeEdge2d(v_p[3], v_p[0]);
    edges_polygon.push_back(e);
    AMCAX::MakeWire mkw;
    mkw.Add(edges_polygon);
    AMCAX::TopoWire w_poly = mkw;
    AMCAX::TopoFace f_poly = AMCAX::MakeFace(w_poly, true);
    return f_poly;
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API MakeFace(const Sphere& s, const TopoWire& w, bool inside = true)	 @param inside Whether the face is inside the wire
	 @param w The wire
	 @param s The sphere
	 @brief Construct from a sphere and a wire
,
 "output":#include <catch.hpp>
#include "testHelper.h"
#include<iostream>
#include <common/PointT.hpp>
#include <topology/TopoEdge.hpp>
#include <modeling/MakeWire.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <topology/TopoWire.hpp>
#include <topology/TopoShape.hpp>
#include <topology/TopoFace.hpp>
#include <modeling/MakeFace.hpp>
AMCAX::TopoFace crashbug1() {
    double h1 = 7., h2 = 3.;
    AMCAX::Point2 p1(0., h1 / 2.0), p2(30., h2 / 2.0), p3(30., -h2 / 2.0), p4(0., -h1 / 2.0);
    std::vector<AMCAX::Point2> v_p;
    v_p.push_back(p1);
    v_p.push_back(p2);
    v_p.push_back(p3);
    v_p.push_back(p4);
    AMCAX::TopoEdge e;
    std::list<AMCAX::TopoShape> edges_polygon;
    for (int i = 1; i < v_p.size(); i++) {
        e = AMCAX::MakeEdge2d(v_p[i - 1], v_p[i]);
        edges_polygon.push_back(e);
    }
    e = AMCAX::MakeEdge2d(v_p[3], v_p[0]);
    edges_polygon.push_back(e);
    AMCAX::MakeWire mkw;
    mkw.Add(edges_polygon);
    AMCAX::TopoWire w_poly = mkw;
    AMCAX::TopoFace f_poly = AMCAX::MakeFace(w_poly, true);
    return f_poly;
}
#include <catch.hpp>
#include "testHelper.h"
#include<iostream>
#include <common/PointT.hpp>
#include <topology/TopoEdge.hpp>
#include <modeling/MakeWire.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <topology/TopoWire.hpp>
#include <topology/TopoShape.hpp>
#include <topology/TopoFace.hpp>
#include <modeling/MakeFace.hpp>
AMCAX::TopoFace crashbug1() {
    double h1 = 7., h2 = 3.;
    AMCAX::Point2 p1(0., h1 / 2.0), p2(30., h2 / 2.0), p3(30., -h2 / 2.0), p4(0., -h1 / 2.0);
    std::vector<AMCAX::Point2> v_p;
    v_p.push_back(p1);
    v_p.push_back(p2);
    v_p.push_back(p3);
    v_p.push_back(p4);
    AMCAX::TopoEdge e;
    std::list<AMCAX::TopoShape> edges_polygon;
    for (int i = 1; i < v_p.size(); i++) {
        e = AMCAX::MakeEdge2d(v_p[i - 1], v_p[i]);
        edges_polygon.push_back(e);
    }
    e = AMCAX::MakeEdge2d(v_p[3], v_p[0]);
    edges_polygon.push_back(e);
    AMCAX::MakeWire mkw;
    mkw.Add(edges_polygon);
    AMCAX::TopoWire w_poly = mkw;
    AMCAX::TopoFace f_poly = AMCAX::MakeFace(w_poly, true);
    return f_poly;
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API MakeFace(const Torus& t, const TopoWire& w, bool inside = true)	 @param inside Whether the face is inside the wire
	 @param w The wire
	 @param t The torus
	 @brief Construct from a torus and a wire
,
 "output":#include <catch.hpp>
#include "testHelper.h"
#include<iostream>
#include <common/PointT.hpp>
#include <topology/TopoEdge.hpp>
#include <modeling/MakeWire.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <topology/TopoWire.hpp>
#include <topology/TopoShape.hpp>
#include <topology/TopoFace.hpp>
#include <modeling/MakeFace.hpp>
AMCAX::TopoFace crashbug1() {
    double h1 = 7., h2 = 3.;
    AMCAX::Point2 p1(0., h1 / 2.0), p2(30., h2 / 2.0), p3(30., -h2 / 2.0), p4(0., -h1 / 2.0);
    std::vector<AMCAX::Point2> v_p;
    v_p.push_back(p1);
    v_p.push_back(p2);
    v_p.push_back(p3);
    v_p.push_back(p4);
    AMCAX::TopoEdge e;
    std::list<AMCAX::TopoShape> edges_polygon;
    for (int i = 1; i < v_p.size(); i++) {
        e = AMCAX::MakeEdge2d(v_p[i - 1], v_p[i]);
        edges_polygon.push_back(e);
    }
    e = AMCAX::MakeEdge2d(v_p[3], v_p[0]);
    edges_polygon.push_back(e);
    AMCAX::MakeWire mkw;
    mkw.Add(edges_polygon);
    AMCAX::TopoWire w_poly = mkw;
    AMCAX::TopoFace f_poly = AMCAX::MakeFace(w_poly, true);
    return f_poly;
}
#include <catch.hpp>
#include "testHelper.h"
#include<iostream>
#include <common/PointT.hpp>
#include <topology/TopoEdge.hpp>
#include <modeling/MakeWire.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <topology/TopoWire.hpp>
#include <topology/TopoShape.hpp>
#include <topology/TopoFace.hpp>
#include <modeling/MakeFace.hpp>
AMCAX::TopoFace crashbug1() {
    double h1 = 7., h2 = 3.;
    AMCAX::Point2 p1(0., h1 / 2.0), p2(30., h2 / 2.0), p3(30., -h2 / 2.0), p4(0., -h1 / 2.0);
    std::vector<AMCAX::Point2> v_p;
    v_p.push_back(p1);
    v_p.push_back(p2);
    v_p.push_back(p3);
    v_p.push_back(p4);
    AMCAX::TopoEdge e;
    std::list<AMCAX::TopoShape> edges_polygon;
    for (int i = 1; i < v_p.size(); i++) {
        e = AMCAX::MakeEdge2d(v_p[i - 1], v_p[i]);
        edges_polygon.push_back(e);
    }
    e = AMCAX::MakeEdge2d(v_p[3], v_p[0]);
    edges_polygon.push_back(e);
    AMCAX::MakeWire mkw;
    mkw.Add(edges_polygon);
    AMCAX::TopoWire w_poly = mkw;
    AMCAX::TopoFace f_poly = AMCAX::MakeFace(w_poly, true);
    return f_poly;
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API MakeFace(const std::shared_ptr<Geom3Surface>& s, const TopoWire& w, bool inside = true)	 @param inside Whether the face is inside the wire
	 @param w The wire
	 @param s The surface
	 @brief Construct from a surface and a wire
,
 "output":#include <catch.hpp>
#include "testHelper.h"
#include<iostream>
#include <common/PointT.hpp>
#include <topology/TopoEdge.hpp>
#include <modeling/MakeWire.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <topology/TopoWire.hpp>
#include <topology/TopoShape.hpp>
#include <topology/TopoFace.hpp>
#include <modeling/MakeFace.hpp>
AMCAX::TopoFace crashbug1() {
    double h1 = 7., h2 = 3.;
    AMCAX::Point2 p1(0., h1 / 2.0), p2(30., h2 / 2.0), p3(30., -h2 / 2.0), p4(0., -h1 / 2.0);
    std::vector<AMCAX::Point2> v_p;
    v_p.push_back(p1);
    v_p.push_back(p2);
    v_p.push_back(p3);
    v_p.push_back(p4);
    AMCAX::TopoEdge e;
    std::list<AMCAX::TopoShape> edges_polygon;
    for (int i = 1; i < v_p.size(); i++) {
        e = AMCAX::MakeEdge2d(v_p[i - 1], v_p[i]);
        edges_polygon.push_back(e);
    }
    e = AMCAX::MakeEdge2d(v_p[3], v_p[0]);
    edges_polygon.push_back(e);
    AMCAX::MakeWire mkw;
    mkw.Add(edges_polygon);
    AMCAX::TopoWire w_poly = mkw;
    AMCAX::TopoFace f_poly = AMCAX::MakeFace(w_poly, true);
    return f_poly;
}
#include <catch.hpp>
#include "testHelper.h"
#include<iostream>
#include <common/PointT.hpp>
#include <topology/TopoEdge.hpp>
#include <modeling/MakeWire.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <topology/TopoWire.hpp>
#include <topology/TopoShape.hpp>
#include <topology/TopoFace.hpp>
#include <modeling/MakeFace.hpp>
AMCAX::TopoFace crashbug1() {
    double h1 = 7., h2 = 3.;
    AMCAX::Point2 p1(0., h1 / 2.0), p2(30., h2 / 2.0), p3(30., -h2 / 2.0), p4(0., -h1 / 2.0);
    std::vector<AMCAX::Point2> v_p;
    v_p.push_back(p1);
    v_p.push_back(p2);
    v_p.push_back(p3);
    v_p.push_back(p4);
    AMCAX::TopoEdge e;
    std::list<AMCAX::TopoShape> edges_polygon;
    for (int i = 1; i < v_p.size(); i++) {
        e = AMCAX::MakeEdge2d(v_p[i - 1], v_p[i]);
        edges_polygon.push_back(e);
    }
    e = AMCAX::MakeEdge2d(v_p[3], v_p[0]);
    edges_polygon.push_back(e);
    AMCAX::MakeWire mkw;
    mkw.Add(edges_polygon);
    AMCAX::TopoWire w_poly = mkw;
    AMCAX::TopoFace f_poly = AMCAX::MakeFace(w_poly, true);
    return f_poly;
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API explicit MakeFace(const TopoWire& w, bool onlyPlane = false)	 @param onlyPlane If true, the surface will be a plane
	 @param w The wire
	 @brief Construct from a wire
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <topology/TopoExplorerTool.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeWire.hpp>
#include <modeling/MakeFace.hpp>
#include <offset/MakeFaceExtension.hpp>
#include <topomesh/BRepMeshIncrementalMesh.hpp>
#include <io/OBJTool.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <topology/TopoTool.hpp>
#include <topology/TopoVertex.hpp>
using namespace AMCAX;
TEST_CASE("Not fix bug:case2:PerformWithEdgeAndLength  ", "[offset][PerformWithEdgeAndLength][P1][bug]") {
	Circle3 c1(Frame3(), 10.);
	Circle3 c2(Frame3(), 4.);
	TopoEdge e1 = MakeEdge(c1);
	TopoWire w1 = MakeWire(e1);
	TopoEdge e2 = MakeEdge(c2);
	TopoWire w2 = MakeWire(e2);
	w2.Reverse();
	MakeFace mkF(w1);
	mkF.Add(w2);
	mkF.Build();
	TopoFace face = mkF.Face();
	BRepMeshIncrementalMesh meshF(face, 0.01);
	IndexSet<TopoShape> fedge;
	TopoExplorerTool::MapShapes(face, ShapeType::Edge, fedge);
	MakeFaceExtension mkExt;
	mkExt.SetFace(face);
	SECTION("PerformWithEdgeAndLength 5.0 ") {
			TopoEdge edge = static_cast<const TopoEdge&>(fedge[1]);
			mkExt.PerformWithEdgeAndLength(edge, 5.0);
			CHECK(mkExt.IsDone() == false);
		}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API GccCircle3Tangent(const GccQualifiedCurve& qualified1, const GccQualifiedCurve& qualified2, const GccQualifiedCurve& qualified3, double tolerance, double parameter1, double parameter2, double parameter3)	 @param parameter3 The initial guess of the parameter on the third curve
	 @param parameter2 The initial guess of the parameter on the second curve
	 @param parameter1 The initial guess of the parameter on the first curve
	 @param tolerance The tolerance
	 @param qualified3 The third curve
	 @param qualified2 The second curve
	 @param qualified1 The first curve
	 @brief Construct a circle tangent to three curves
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <geomAlgo/GccCircle3Tangent.hpp>
#include <geometry/Geom2Curve.hpp>
#include <geometry/MakeGeom2Line.hpp>
#include <geometry/MakeGeom2Circle.hpp>
#include <geomAlgo/GccEntity.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geomAlgo/GccEntity.hpp>
#include <geomAlgo/GccQualifiedCurve.hpp>
#include <sstream>
using namespace AMCAX;
TEST_CASE("bug1: GccCircle3Tangent  add 48 cases", "[geomAlgo][GccCircle3Tangent][fixbug]") {
	std::shared_ptr<Geom2Curve> l = MakeGeom2Line(Point2(0.0, 0.0), Point2(1.0, 0.0)).Value();
	std::shared_ptr<Geom2Curve> c1 = MakeGeom2Circle(Point2(0.0, 3.0), 2.0).Value();
	std::shared_ptr<Geom2Curve> c2 = MakeGeom2Circle(Point2(4.0, 3.0), 2.0).Value();
	AdaptorGeom2Curve line(l);
	AdaptorGeom2Curve circle1(c1);
	AdaptorGeom2Curve circle2(c2);
	auto lineEnclosed = GccEntity::Enclosed(line);
	auto lineOutside = GccEntity::Outside(line);
	auto lineUnqualified = GccEntity::Unqualified(line);
	auto circle1Enclosed = GccEntity::Enclosed(circle1);
	auto circle1Enclosing = GccEntity::Enclosing(circle1);
	auto circle1Outside = GccEntity::Outside(circle1);
	auto circle1Unqualified = GccEntity::Unqualified(circle1);
	auto circle2Enclosed = GccEntity::Enclosed(circle2);
	auto circle2Enclosing = GccEntity::Enclosing(circle2);
	auto circle2Outside = GccEntity::Outside(circle2);
	auto circle2Unqualified = GccEntity::Unqualified(circle2);
	auto gccl = GccEntity::Enclosed(AdaptorGeom2Curve(l));
	auto gccc1 = GccEntity::Enclosing(AdaptorGeom2Curve(c1));
	auto gccc2 = GccEntity::Outside(AdaptorGeom2Curve(c2));
	auto c3t = [](const GccQualifiedCurve& gccc1, const GccQualifiedCurve& gccc2, const GccQualifiedCurve& gccl)
	{
		std::stringstream output;
		GccCircle3Tangent gcc(gccc1, gccc2, gccl, Precision::Confusion(), 0.0, 0.0, 0.0);
		std::cout << "Test case: " << GccEntity::PositionToString(gccc1.Qualifier()) << ' ' << GccEntity::PositionToString(gccc2.Qualifier()) << ' ' << GccEntity::PositionToString(gccl.Qualifier()) << std::endl;
		std::cout << "Solution: " << gcc.NSolutions() << std::endl;
		output << "Test case: " << GccEntity::PositionToString(gccc1.Qualifier()) << ' ' << GccEntity::PositionToString(gccc2.Qualifier()) << ' ' << GccEntity::PositionToString(gccl.Qualifier()) << std::endl;
		output << "Solution: " << gcc.NSolutions() << std::endl;
		if (gcc.IsDone())
		{
			for (int i = 0; i < gcc.NSolutions(); i++)
			{
				GccPosition q1, q2, q3;
				gcc.Qualifier(i, q1, q2, q3);
				output << i << ": " << *MakeGeom2Circle(gcc.Solution(i)).Value() << std::endl;
				output << "  " << GccEntity::PositionToString(q1) << ' ' << GccEntity::PositionToString(q2) << ' ' << GccEntity::PositionToString(q3) << std::endl;
			}
		}
		else
		{
			std::cout << "gcc.IsDone is False" << std::endl;
			output << "gcc.IsDone is False" << std::endl;
		}
		return output.str();
	};
	auto case1 = c3t(circle1Enclosed, circle2Enclosed, lineEnclosed);
	auto expect1 = "Test case: Enclosed Enclosed Enclosed\nSolution: 0\n";
	CHECK(case1.find(expect1) != std::string::npos);
	auto case2 = c3t(circle1Enclosed, circle2Enclosed, lineOutside);
	auto expect2 = "Test case: Enclosed Enclosed Outside\nSolution: 0\n";
	CHECK(case2.find(expect2) != std::string::npos);
	auto case3 = c3t(circle1Enclosed, circle2Enclosed, lineUnqualified);
	auto expect3 = "Test case: Enclosed Enclosed Unqualified\nSolution: 0\n";
	CHECK(case3.find(expect3) != std::string::npos);
	auto case4 = c3t(circle1Enclosed, circle2Enclosing, lineEnclosed);
	auto expect4 = "Test case: Enclosed Enclosing Enclosed\nSolution: 0\n";
	CHECK(case4.find(expect4) != std::string::npos);
	auto case5 = c3t(circle1Enclosed, circle2Enclosing, lineOutside);
	auto expect5 = "Test case: Enclosed Enclosing Outside\nSolution: 0\n";
	CHECK(case5.find(expect5) != std::string::npos);
	auto case6 = c3t(circle1Enclosed, circle2Enclosing, lineUnqualified);
	auto expect6 = "Test case: Enclosed Enclosing Unqualified\nSolution: 0\n";
	CHECK(case6.find(expect6) != std::string::npos);
	auto case7 = c3t(circle1Enclosed, circle2Outside, lineEnclosed);
	auto expect7 = "Test case: Enclosed Outside Enclosed\nSolution: 0\n";
	CHECK(case7.find(expect7) != std::string::npos);
	auto case8 = c3t(circle1Enclosed, circle2Outside, lineOutside);
	auto expect8 = "Test case: Enclosed Outside Outside\nSolution: 0\n";
	CHECK(case8.find(expect8) != std::string::npos);
	auto case9 = c3t(circle1Enclosed, circle2Outside, lineUnqualified);
	auto expect9 = "Test case: Enclosed Outside Unqualified\nSolution: 0\n";
	CHECK(case9.find(expect9) != std::string::npos);
	auto case10 = c3t(circle1Enclosed, circle2Unqualified, lineEnclosed);
	auto expect10 = "Test case: Enclosed Unqualified Enclosed\nSolution: 0\n";
	CHECK(case10.find(expect10) != std::string::npos);
	auto case11 = c3t(circle1Enclosed, circle2Unqualified, lineOutside);
	auto expect11 = "Test case: Enclosed Unqualified Outside\nSolution: 0\n";
	CHECK(case11.find(expect11) != std::string::npos);
	auto case12 = c3t(circle1Enclosed, circle2Unqualified, lineUnqualified);
	auto expect12 = "Test case: Enclosed Unqualified Unqualified\nSolution: 0\n";
	CHECK(case12.find(expect12) != std::string::npos);
	auto case13 = c3t(circle1Enclosing, circle2Enclosed, lineEnclosed);
	auto expect13 = "Test case: Enclosing Enclosed Enclosed\nSolution: 0\n";
	CHECK(case13.find(expect13) != std::string::npos);
	auto case14 = c3t(circle1Enclosing, circle2Enclosed, lineOutside);
	auto expect14 = "Test case: Enclosing Enclosed Outside\nSolution: 0\n";
	CHECK(case14.find(expect14) != std::string::npos);
	auto case15 = c3t(circle1Enclosing, circle2Enclosed, lineUnqualified);
	auto expect15 = "Test case: Enclosing Enclosed Unqualified\nSolution: 0\n";
	CHECK(case15.find(expect15) != std::string::npos);
	auto case16 = c3t(circle1Enclosing, circle2Enclosing, lineEnclosed);
	auto expect16 = "Test case: Enclosing Enclosing Enclosed\nSolution: 1\n0: 2 2 4.5 1 0 -0 1 4.5\n  Enclosing Enclosing Enclosed\n";
	CHECK(case16.find(expect16) != std::string::npos);
	auto case17 = c3t(circle1Enclosing, circle2Enclosing, lineOutside);
	auto expect17 = "Test case: Enclosing Enclosing Outside\nSolution: 0\n";
	CHECK(case17.find(expect17) != std::string::npos);
	auto case18 = c3t(circle1Enclosing, circle2Enclosing, lineUnqualified);
	auto expect18 = "Test case: Enclosing Enclosing Unqualified\nSolution: 1\n0: 2 2 4.5 1 0 -0 1 4.5\n  Enclosing Enclosing Enclosed\n";
	CHECK(case18.find(expect18) != std::string::npos);
	auto case19 = c3t(circle1Enclosing, circle2Outside, lineEnclosed);
	auto expect19 = "Test case: Enclosing Outside Enclosed\nSolution: 1\n0: 2 -1 3 1 0 -0 1 3\n  Enclosing Outside Enclosed\n";
	CHECK(case19.find(expect19) != std::string::npos);
	auto case20 = c3t(circle1Enclosing, circle2Outside, lineOutside);
	auto expect20 = "Test case: Enclosing Outside Outside\nSolution: 0\n";
	CHECK(case20.find(expect20) != std::string::npos);
	auto case21 = c3t(circle1Enclosing, circle2Outside, lineUnqualified);
	auto expect21 = "Test case: Enclosing Outside Unqualified\nSolution: 1\n0: 2 -1 3 1 0 -0 1 3\n  Enclosing Outside Enclosed\n";
	CHECK(case21.find(expect21) != std::string::npos);
	auto case22 = c3t(circle1Enclosing, circle2Unqualified, lineEnclosed);
	auto expect22 = "Test case: Enclosing Unqualified Enclosed\nSolution: 2\n0: 2 -1 3 1 0 -0 1 3\n  Enclosing Outside Enclosed\n1: 2 2 4.5 1 0 -0 1 4.5\n  Enclosing Enclosing Enclosed\n";
	CHECK(case22.find(expect22) != std::string::npos);
	auto case23 = c3t(circle1Enclosing, circle2Unqualified, lineOutside);
	auto expect23 = "Test case: Enclosing Unqualified Outside\nSolution: 0\n";
	CHECK(case23.find(expect23) != std::string::npos);
	auto case24 = c3t(circle1Enclosing, circle2Unqualified, lineUnqualified);
	auto expect24 = "Test case: Enclosing Unqualified Unqualified\nSolution: 2\n0: 2 -1 3 1 0 -0 1 3\n  Enclosing Outside Enclosed\n1: 2 2 4.5 1 0 -0 1 4.5\n  Enclosing Enclosing Enclosed\n";
	CHECK(case24.find(expect24) != std::string::npos);
	auto case25 = c3t(circle1Outside, circle2Enclosed, lineEnclosed);
	auto expect25 = "Test case: Outside Enclosed Enclosed\nSolution: 0\n";
	CHECK(case25.find(expect25) != std::string::npos);
	auto case26 = c3t(circle1Outside, circle2Enclosed, lineOutside);
	auto expect26 = "Test case: Outside Enclosed Outside\nSolution: 0\n";
	CHECK(case26.find(expect26) != std::string::npos);
	auto case27 = c3t(circle1Outside, circle2Enclosed, lineUnqualified);
	auto expect27 = "Test case: Outside Enclosed Unqualified\nSolution: 0\n";
	CHECK(case27.find(expect27) != std::string::npos);
	auto case28 = c3t(circle1Outside, circle2Enclosing, lineEnclosed);
	auto expect28 = "Test case: Outside Enclosing Enclosed\nSolution: 1\n0: 2 5 3 1 0 -0 1 3\n  Outside Enclosing Enclosed\n";
	CHECK(case28.find(expect28) != std::string::npos);
	auto case29 = c3t(circle1Outside, circle2Enclosing, lineOutside);
	auto expect29 = "Test case: Outside Enclosing Outside\nSolution: 0\n";
	CHECK(case29.find(expect29) != std::string::npos);
	auto case30 = c3t(circle1Outside, circle2Enclosing, lineUnqualified);
	auto expect30 = "Test case: Outside Enclosing Unqualified\nSolution: 1\n0: 2 5 3 1 0 -0 1 3\n  Outside Enclosing Enclosed\n";
	CHECK(case30.find(expect30) != std::string::npos);
	auto case31 = c3t(circle1Outside, circle2Outside, lineEnclosed);
	auto expect31 = "Test case: Outside Outside Enclosed\nSolution: 1\n0: 2 2 0.9 1 0 -0 1 0.9\n  Outside Outside Enclosed\n";
	CHECK(case31.find(expect31) != std::string::npos);
	auto case32 = c3t(circle1Outside, circle2Outside, lineOutside);
	auto expect32 = "Test case: Outside Outside Outside\nSolution: 0\n";
	CHECK(case32.find(expect32) != std::string::npos);
	auto case33 = c3t(circle1Outside, circle2Outside, lineUnqualified);
	auto expect33 = "Test case: Outside Outside Unqualified\nSolution: 1\n0: 2 2 0.9 1 0 -0 1 0.9\n  Outside Outside Enclosed\n";
	CHECK(case33.find(expect33) != std::string::npos);
	auto case34 = c3t(circle1Outside, circle2Unqualified, lineEnclosed);
	auto expect34 = "Test case: Outside Unqualified Enclosed\nSolution: 2\n0: 2 2 0.9 1 0 -0 1 0.9\n  Outside Outside Enclosed\n1: 2 5 3 1 0 -0 1 3\n  Outside Enclosing Enclosed\n";
	CHECK(case34.find(expect34) != std::string::npos);
	auto case35 = c3t(circle1Outside, circle2Unqualified, lineOutside);
	auto expect35 = "Test case: Outside Unqualified Outside\nSolution: 0\n";
	CHECK(case35.find(expect35) != std::string::npos);
	auto case36 = c3t(circle1Outside, circle2Unqualified, lineUnqualified);
	auto expect36 = "Test case: Outside Unqualified Unqualified\nSolution: 2\n0: 2 2 0.9 1 0 -0 1 0.9\n  Outside Outside Enclosed\n1: 2 5 3 1 0 -0 1 3\n  Outside Enclosing Enclosed\n";
	CHECK(case36.find(expect36) != std::string::npos);
	auto case37 = c3t(circle1Unqualified, circle2Enclosed, lineEnclosed);
	auto expect37 = "Test case: Unqualified Enclosed Enclosed\nSolution: 0\n";
	CHECK(case37.find(expect37) != std::string::npos);
	auto case38 = c3t(circle1Unqualified, circle2Enclosed, lineOutside);
	auto expect38 = "Test case: Unqualified Enclosed Outside\nSolution: 0\n";
	CHECK(case38.find(expect38) != std::string::npos);
	auto case39 = c3t(circle1Unqualified, circle2Enclosed, lineUnqualified);
	auto expect39 = "Test case: Unqualified Enclosed Unqualified\nSolution: 0\n";
	CHECK(case39.find(expect39) != std::string::npos);
	auto case40 = c3t(circle1Unqualified, circle2Enclosing, lineEnclosed);
	auto expect40 = "Test case: Unqualified Enclosing Enclosed\nSolution: 2\n0: 2 5 3 1 0 -0 1 3\n  Outside Enclosing Enclosed\n1: 2 2 4.5 1 0 -0 1 4.5\n  Enclosing Enclosing Enclosed\n";
	CHECK(case40.find(expect40) != std::string::npos);
	auto case41 = c3t(circle1Unqualified, circle2Enclosing, lineOutside);
	auto expect41 = "Test case: Unqualified Enclosing Outside\nSolution: 0\n";
	CHECK(case41.find(expect41) != std::string::npos);
	auto case42 = c3t(circle1Unqualified, circle2Enclosing, lineUnqualified);
	auto expect42 = "Test case: Unqualified Enclosing Unqualified\nSolution: 2\n0: 2 5 3 1 0 -0 1 3\n  Outside Enclosing Enclosed\n1: 2 2 4.5 1 0 -0 1 4.5\n  Enclosing Enclosing Enclosed\n";
	CHECK(case42.find(expect42) != std::string::npos);
	auto case43 = c3t(circle1Unqualified, circle2Outside, lineEnclosed);
	auto expect43 = "Test case: Unqualified Outside Enclosed\nSolution: 2\n0: 2 2 0.9 1 0 -0 1 0.9\n  Outside Outside Enclosed\n1: 2 -1 3 1 0 -0 1 3\n  Enclosing Outside Enclosed\n";
	CHECK(case43.find(expect43) != std::string::npos);
	auto case44 = c3t(circle1Unqualified, circle2Outside, lineOutside);
	auto expect44 = "Test case: Unqualified Outside Outside\nSolution: 0\n";
	CHECK(case44.find(expect44) != std::string::npos);
	auto case45 = c3t(circle1Unqualified, circle2Outside, lineUnqualified);
	auto expect45 = "Test case: Unqualified Outside Unqualified\nSolution: 2\n0: 2 2 0.9 1 0 -0 1 0.9\n  Outside Outside Enclosed\n1: 2 -1 3 1 0 -0 1 3\n  Enclosing Outside Enclosed\n";
	CHECK(case45.find(expect45) != std::string::npos);
	auto case46 = c3t(circle1Unqualified, circle2Unqualified, lineEnclosed);
	auto expect46 = "Test case: Unqualified Unqualified Enclosed\nSolution: 4\n0: 2 2 0.9 1 0 -0 1 0.9\n  Outside Outside Enclosed\n1: 2 5 3 1 0 -0 1 3\n  Outside Enclosing Enclosed\n2: 2 -1 3 1 0 -0 1 3\n  Enclosing Outside Enclosed\n3: 2 2 4.5 1 0 -0 1 4.5\n  Enclosing Enclosing Enclosed\n";
	CHECK(case46.find(expect46) != std::string::npos);
	auto case47 = c3t(circle1Unqualified, circle2Unqualified, lineOutside);
	auto expect47 = "Test case: Unqualified Unqualified Outside\nSolution: 0\n";
	CHECK(case47.find(expect47) != std::string::npos);
	auto case48 = c3t(circle1Unqualified, circle2Unqualified, lineUnqualified);
	auto expect48 = "Test case: Unqualified Unqualified Unqualified\nSolution: 4\n0: 2 2 0.9 1 0 -0 1 0.9\n  Outside Outside Enclosed\n1: 2 5 3 1 0 -0 1 3\n  Outside Enclosing Enclosed\n2: 2 -1 3 1 0 -0 1 3\n  Enclosing Outside Enclosed\n3: 2 2 4.5 1 0 -0 1 4.5\n  Enclosing Enclosing Enclosed";
	CHECK(case48.find(expect48) != std::string::npos);
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API GccCircle3Tangent(const GccQualifiedCurve& qualified1, const GccQualifiedCurve& qualified2, const Point2& point, double tolerance, double parameter1, double parameter2)	 @param parameter2 The initial guess of the parameter on the second curve
	 @param parameter1 The initial guess of the parameter on the first curve
	 @param tolerance The tolerance
	 @param point The point that the circle passes through
	 @param qualified2 The second curve
	 @param qualified1 The first curve
	 @brief Construct a circle tangent to two curves and passing through a point
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <geomAlgo/GccCircle3Tangent.hpp>
#include <geometry/Geom2Curve.hpp>
#include <geometry/MakeGeom2Line.hpp>
#include <geometry/MakeGeom2Circle.hpp>
#include <geomAlgo/GccEntity.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geomAlgo/GccEntity.hpp>
#include <geomAlgo/GccQualifiedCurve.hpp>
#include <sstream>
using namespace AMCAX;
TEST_CASE("bug1: GccCircle3Tangent  add 48 cases", "[geomAlgo][GccCircle3Tangent][fixbug]") {
	std::shared_ptr<Geom2Curve> l = MakeGeom2Line(Point2(0.0, 0.0), Point2(1.0, 0.0)).Value();
	std::shared_ptr<Geom2Curve> c1 = MakeGeom2Circle(Point2(0.0, 3.0), 2.0).Value();
	std::shared_ptr<Geom2Curve> c2 = MakeGeom2Circle(Point2(4.0, 3.0), 2.0).Value();
	AdaptorGeom2Curve line(l);
	AdaptorGeom2Curve circle1(c1);
	AdaptorGeom2Curve circle2(c2);
	auto lineEnclosed = GccEntity::Enclosed(line);
	auto lineOutside = GccEntity::Outside(line);
	auto lineUnqualified = GccEntity::Unqualified(line);
	auto circle1Enclosed = GccEntity::Enclosed(circle1);
	auto circle1Enclosing = GccEntity::Enclosing(circle1);
	auto circle1Outside = GccEntity::Outside(circle1);
	auto circle1Unqualified = GccEntity::Unqualified(circle1);
	auto circle2Enclosed = GccEntity::Enclosed(circle2);
	auto circle2Enclosing = GccEntity::Enclosing(circle2);
	auto circle2Outside = GccEntity::Outside(circle2);
	auto circle2Unqualified = GccEntity::Unqualified(circle2);
	auto gccl = GccEntity::Enclosed(AdaptorGeom2Curve(l));
	auto gccc1 = GccEntity::Enclosing(AdaptorGeom2Curve(c1));
	auto gccc2 = GccEntity::Outside(AdaptorGeom2Curve(c2));
	auto c3t = [](const GccQualifiedCurve& gccc1, const GccQualifiedCurve& gccc2, const GccQualifiedCurve& gccl)
	{
		std::stringstream output;
		GccCircle3Tangent gcc(gccc1, gccc2, gccl, Precision::Confusion(), 0.0, 0.0, 0.0);
		std::cout << "Test case: " << GccEntity::PositionToString(gccc1.Qualifier()) << ' ' << GccEntity::PositionToString(gccc2.Qualifier()) << ' ' << GccEntity::PositionToString(gccl.Qualifier()) << std::endl;
		std::cout << "Solution: " << gcc.NSolutions() << std::endl;
		output << "Test case: " << GccEntity::PositionToString(gccc1.Qualifier()) << ' ' << GccEntity::PositionToString(gccc2.Qualifier()) << ' ' << GccEntity::PositionToString(gccl.Qualifier()) << std::endl;
		output << "Solution: " << gcc.NSolutions() << std::endl;
		if (gcc.IsDone())
		{
			for (int i = 0; i < gcc.NSolutions(); i++)
			{
				GccPosition q1, q2, q3;
				gcc.Qualifier(i, q1, q2, q3);
				output << i << ": " << *MakeGeom2Circle(gcc.Solution(i)).Value() << std::endl;
				output << "  " << GccEntity::PositionToString(q1) << ' ' << GccEntity::PositionToString(q2) << ' ' << GccEntity::PositionToString(q3) << std::endl;
			}
		}
		else
		{
			std::cout << "gcc.IsDone is False" << std::endl;
			output << "gcc.IsDone is False" << std::endl;
		}
		return output.str();
	};
	auto case1 = c3t(circle1Enclosed, circle2Enclosed, lineEnclosed);
	auto expect1 = "Test case: Enclosed Enclosed Enclosed\nSolution: 0\n";
	CHECK(case1.find(expect1) != std::string::npos);
	auto case2 = c3t(circle1Enclosed, circle2Enclosed, lineOutside);
	auto expect2 = "Test case: Enclosed Enclosed Outside\nSolution: 0\n";
	CHECK(case2.find(expect2) != std::string::npos);
	auto case3 = c3t(circle1Enclosed, circle2Enclosed, lineUnqualified);
	auto expect3 = "Test case: Enclosed Enclosed Unqualified\nSolution: 0\n";
	CHECK(case3.find(expect3) != std::string::npos);
	auto case4 = c3t(circle1Enclosed, circle2Enclosing, lineEnclosed);
	auto expect4 = "Test case: Enclosed Enclosing Enclosed\nSolution: 0\n";
	CHECK(case4.find(expect4) != std::string::npos);
	auto case5 = c3t(circle1Enclosed, circle2Enclosing, lineOutside);
	auto expect5 = "Test case: Enclosed Enclosing Outside\nSolution: 0\n";
	CHECK(case5.find(expect5) != std::string::npos);
	auto case6 = c3t(circle1Enclosed, circle2Enclosing, lineUnqualified);
	auto expect6 = "Test case: Enclosed Enclosing Unqualified\nSolution: 0\n";
	CHECK(case6.find(expect6) != std::string::npos);
	auto case7 = c3t(circle1Enclosed, circle2Outside, lineEnclosed);
	auto expect7 = "Test case: Enclosed Outside Enclosed\nSolution: 0\n";
	CHECK(case7.find(expect7) != std::string::npos);
	auto case8 = c3t(circle1Enclosed, circle2Outside, lineOutside);
	auto expect8 = "Test case: Enclosed Outside Outside\nSolution: 0\n";
	CHECK(case8.find(expect8) != std::string::npos);
	auto case9 = c3t(circle1Enclosed, circle2Outside, lineUnqualified);
	auto expect9 = "Test case: Enclosed Outside Unqualified\nSolution: 0\n";
	CHECK(case9.find(expect9) != std::string::npos);
	auto case10 = c3t(circle1Enclosed, circle2Unqualified, lineEnclosed);
	auto expect10 = "Test case: Enclosed Unqualified Enclosed\nSolution: 0\n";
	CHECK(case10.find(expect10) != std::string::npos);
	auto case11 = c3t(circle1Enclosed, circle2Unqualified, lineOutside);
	auto expect11 = "Test case: Enclosed Unqualified Outside\nSolution: 0\n";
	CHECK(case11.find(expect11) != std::string::npos);
	auto case12 = c3t(circle1Enclosed, circle2Unqualified, lineUnqualified);
	auto expect12 = "Test case: Enclosed Unqualified Unqualified\nSolution: 0\n";
	CHECK(case12.find(expect12) != std::string::npos);
	auto case13 = c3t(circle1Enclosing, circle2Enclosed, lineEnclosed);
	auto expect13 = "Test case: Enclosing Enclosed Enclosed\nSolution: 0\n";
	CHECK(case13.find(expect13) != std::string::npos);
	auto case14 = c3t(circle1Enclosing, circle2Enclosed, lineOutside);
	auto expect14 = "Test case: Enclosing Enclosed Outside\nSolution: 0\n";
	CHECK(case14.find(expect14) != std::string::npos);
	auto case15 = c3t(circle1Enclosing, circle2Enclosed, lineUnqualified);
	auto expect15 = "Test case: Enclosing Enclosed Unqualified\nSolution: 0\n";
	CHECK(case15.find(expect15) != std::string::npos);
	auto case16 = c3t(circle1Enclosing, circle2Enclosing, lineEnclosed);
	auto expect16 = "Test case: Enclosing Enclosing Enclosed\nSolution: 1\n0: 2 2 4.5 1 0 -0 1 4.5\n  Enclosing Enclosing Enclosed\n";
	CHECK(case16.find(expect16) != std::string::npos);
	auto case17 = c3t(circle1Enclosing, circle2Enclosing, lineOutside);
	auto expect17 = "Test case: Enclosing Enclosing Outside\nSolution: 0\n";
	CHECK(case17.find(expect17) != std::string::npos);
	auto case18 = c3t(circle1Enclosing, circle2Enclosing, lineUnqualified);
	auto expect18 = "Test case: Enclosing Enclosing Unqualified\nSolution: 1\n0: 2 2 4.5 1 0 -0 1 4.5\n  Enclosing Enclosing Enclosed\n";
	CHECK(case18.find(expect18) != std::string::npos);
	auto case19 = c3t(circle1Enclosing, circle2Outside, lineEnclosed);
	auto expect19 = "Test case: Enclosing Outside Enclosed\nSolution: 1\n0: 2 -1 3 1 0 -0 1 3\n  Enclosing Outside Enclosed\n";
	CHECK(case19.find(expect19) != std::string::npos);
	auto case20 = c3t(circle1Enclosing, circle2Outside, lineOutside);
	auto expect20 = "Test case: Enclosing Outside Outside\nSolution: 0\n";
	CHECK(case20.find(expect20) != std::string::npos);
	auto case21 = c3t(circle1Enclosing, circle2Outside, lineUnqualified);
	auto expect21 = "Test case: Enclosing Outside Unqualified\nSolution: 1\n0: 2 -1 3 1 0 -0 1 3\n  Enclosing Outside Enclosed\n";
	CHECK(case21.find(expect21) != std::string::npos);
	auto case22 = c3t(circle1Enclosing, circle2Unqualified, lineEnclosed);
	auto expect22 = "Test case: Enclosing Unqualified Enclosed\nSolution: 2\n0: 2 -1 3 1 0 -0 1 3\n  Enclosing Outside Enclosed\n1: 2 2 4.5 1 0 -0 1 4.5\n  Enclosing Enclosing Enclosed\n";
	CHECK(case22.find(expect22) != std::string::npos);
	auto case23 = c3t(circle1Enclosing, circle2Unqualified, lineOutside);
	auto expect23 = "Test case: Enclosing Unqualified Outside\nSolution: 0\n";
	CHECK(case23.find(expect23) != std::string::npos);
	auto case24 = c3t(circle1Enclosing, circle2Unqualified, lineUnqualified);
	auto expect24 = "Test case: Enclosing Unqualified Unqualified\nSolution: 2\n0: 2 -1 3 1 0 -0 1 3\n  Enclosing Outside Enclosed\n1: 2 2 4.5 1 0 -0 1 4.5\n  Enclosing Enclosing Enclosed\n";
	CHECK(case24.find(expect24) != std::string::npos);
	auto case25 = c3t(circle1Outside, circle2Enclosed, lineEnclosed);
	auto expect25 = "Test case: Outside Enclosed Enclosed\nSolution: 0\n";
	CHECK(case25.find(expect25) != std::string::npos);
	auto case26 = c3t(circle1Outside, circle2Enclosed, lineOutside);
	auto expect26 = "Test case: Outside Enclosed Outside\nSolution: 0\n";
	CHECK(case26.find(expect26) != std::string::npos);
	auto case27 = c3t(circle1Outside, circle2Enclosed, lineUnqualified);
	auto expect27 = "Test case: Outside Enclosed Unqualified\nSolution: 0\n";
	CHECK(case27.find(expect27) != std::string::npos);
	auto case28 = c3t(circle1Outside, circle2Enclosing, lineEnclosed);
	auto expect28 = "Test case: Outside Enclosing Enclosed\nSolution: 1\n0: 2 5 3 1 0 -0 1 3\n  Outside Enclosing Enclosed\n";
	CHECK(case28.find(expect28) != std::string::npos);
	auto case29 = c3t(circle1Outside, circle2Enclosing, lineOutside);
	auto expect29 = "Test case: Outside Enclosing Outside\nSolution: 0\n";
	CHECK(case29.find(expect29) != std::string::npos);
	auto case30 = c3t(circle1Outside, circle2Enclosing, lineUnqualified);
	auto expect30 = "Test case: Outside Enclosing Unqualified\nSolution: 1\n0: 2 5 3 1 0 -0 1 3\n  Outside Enclosing Enclosed\n";
	CHECK(case30.find(expect30) != std::string::npos);
	auto case31 = c3t(circle1Outside, circle2Outside, lineEnclosed);
	auto expect31 = "Test case: Outside Outside Enclosed\nSolution: 1\n0: 2 2 0.9 1 0 -0 1 0.9\n  Outside Outside Enclosed\n";
	CHECK(case31.find(expect31) != std::string::npos);
	auto case32 = c3t(circle1Outside, circle2Outside, lineOutside);
	auto expect32 = "Test case: Outside Outside Outside\nSolution: 0\n";
	CHECK(case32.find(expect32) != std::string::npos);
	auto case33 = c3t(circle1Outside, circle2Outside, lineUnqualified);
	auto expect33 = "Test case: Outside Outside Unqualified\nSolution: 1\n0: 2 2 0.9 1 0 -0 1 0.9\n  Outside Outside Enclosed\n";
	CHECK(case33.find(expect33) != std::string::npos);
	auto case34 = c3t(circle1Outside, circle2Unqualified, lineEnclosed);
	auto expect34 = "Test case: Outside Unqualified Enclosed\nSolution: 2\n0: 2 2 0.9 1 0 -0 1 0.9\n  Outside Outside Enclosed\n1: 2 5 3 1 0 -0 1 3\n  Outside Enclosing Enclosed\n";
	CHECK(case34.find(expect34) != std::string::npos);
	auto case35 = c3t(circle1Outside, circle2Unqualified, lineOutside);
	auto expect35 = "Test case: Outside Unqualified Outside\nSolution: 0\n";
	CHECK(case35.find(expect35) != std::string::npos);
	auto case36 = c3t(circle1Outside, circle2Unqualified, lineUnqualified);
	auto expect36 = "Test case: Outside Unqualified Unqualified\nSolution: 2\n0: 2 2 0.9 1 0 -0 1 0.9\n  Outside Outside Enclosed\n1: 2 5 3 1 0 -0 1 3\n  Outside Enclosing Enclosed\n";
	CHECK(case36.find(expect36) != std::string::npos);
	auto case37 = c3t(circle1Unqualified, circle2Enclosed, lineEnclosed);
	auto expect37 = "Test case: Unqualified Enclosed Enclosed\nSolution: 0\n";
	CHECK(case37.find(expect37) != std::string::npos);
	auto case38 = c3t(circle1Unqualified, circle2Enclosed, lineOutside);
	auto expect38 = "Test case: Unqualified Enclosed Outside\nSolution: 0\n";
	CHECK(case38.find(expect38) != std::string::npos);
	auto case39 = c3t(circle1Unqualified, circle2Enclosed, lineUnqualified);
	auto expect39 = "Test case: Unqualified Enclosed Unqualified\nSolution: 0\n";
	CHECK(case39.find(expect39) != std::string::npos);
	auto case40 = c3t(circle1Unqualified, circle2Enclosing, lineEnclosed);
	auto expect40 = "Test case: Unqualified Enclosing Enclosed\nSolution: 2\n0: 2 5 3 1 0 -0 1 3\n  Outside Enclosing Enclosed\n1: 2 2 4.5 1 0 -0 1 4.5\n  Enclosing Enclosing Enclosed\n";
	CHECK(case40.find(expect40) != std::string::npos);
	auto case41 = c3t(circle1Unqualified, circle2Enclosing, lineOutside);
	auto expect41 = "Test case: Unqualified Enclosing Outside\nSolution: 0\n";
	CHECK(case41.find(expect41) != std::string::npos);
	auto case42 = c3t(circle1Unqualified, circle2Enclosing, lineUnqualified);
	auto expect42 = "Test case: Unqualified Enclosing Unqualified\nSolution: 2\n0: 2 5 3 1 0 -0 1 3\n  Outside Enclosing Enclosed\n1: 2 2 4.5 1 0 -0 1 4.5\n  Enclosing Enclosing Enclosed\n";
	CHECK(case42.find(expect42) != std::string::npos);
	auto case43 = c3t(circle1Unqualified, circle2Outside, lineEnclosed);
	auto expect43 = "Test case: Unqualified Outside Enclosed\nSolution: 2\n0: 2 2 0.9 1 0 -0 1 0.9\n  Outside Outside Enclosed\n1: 2 -1 3 1 0 -0 1 3\n  Enclosing Outside Enclosed\n";
	CHECK(case43.find(expect43) != std::string::npos);
	auto case44 = c3t(circle1Unqualified, circle2Outside, lineOutside);
	auto expect44 = "Test case: Unqualified Outside Outside\nSolution: 0\n";
	CHECK(case44.find(expect44) != std::string::npos);
	auto case45 = c3t(circle1Unqualified, circle2Outside, lineUnqualified);
	auto expect45 = "Test case: Unqualified Outside Unqualified\nSolution: 2\n0: 2 2 0.9 1 0 -0 1 0.9\n  Outside Outside Enclosed\n1: 2 -1 3 1 0 -0 1 3\n  Enclosing Outside Enclosed\n";
	CHECK(case45.find(expect45) != std::string::npos);
	auto case46 = c3t(circle1Unqualified, circle2Unqualified, lineEnclosed);
	auto expect46 = "Test case: Unqualified Unqualified Enclosed\nSolution: 4\n0: 2 2 0.9 1 0 -0 1 0.9\n  Outside Outside Enclosed\n1: 2 5 3 1 0 -0 1 3\n  Outside Enclosing Enclosed\n2: 2 -1 3 1 0 -0 1 3\n  Enclosing Outside Enclosed\n3: 2 2 4.5 1 0 -0 1 4.5\n  Enclosing Enclosing Enclosed\n";
	CHECK(case46.find(expect46) != std::string::npos);
	auto case47 = c3t(circle1Unqualified, circle2Unqualified, lineOutside);
	auto expect47 = "Test case: Unqualified Unqualified Outside\nSolution: 0\n";
	CHECK(case47.find(expect47) != std::string::npos);
	auto case48 = c3t(circle1Unqualified, circle2Unqualified, lineUnqualified);
	auto expect48 = "Test case: Unqualified Unqualified Unqualified\nSolution: 4\n0: 2 2 0.9 1 0 -0 1 0.9\n  Outside Outside Enclosed\n1: 2 5 3 1 0 -0 1 3\n  Outside Enclosing Enclosed\n2: 2 -1 3 1 0 -0 1 3\n  Enclosing Outside Enclosed\n3: 2 2 4.5 1 0 -0 1 4.5\n  Enclosing Enclosing Enclosed";
	CHECK(case48.find(expect48) != std::string::npos);
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API GccCircle3Tangent(const GccQualifiedCurve& qualified1, const Point2& point1, const Point2& point2, double tolerance, double parameter1)	 @param parameter1 The initial guess of the parameter on the curve
	 @param tolerance The tolerance
	 @param point2 The second point
	 @param point1 The first point
	 @param qualified1 The tangent curve
	 @brief Construct a circle tangent to a curve and passing throught two points
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <geomAlgo/GccCircle3Tangent.hpp>
#include <geometry/Geom2Curve.hpp>
#include <geometry/MakeGeom2Line.hpp>
#include <geometry/MakeGeom2Circle.hpp>
#include <geomAlgo/GccEntity.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geomAlgo/GccEntity.hpp>
#include <geomAlgo/GccQualifiedCurve.hpp>
#include <sstream>
using namespace AMCAX;
TEST_CASE("bug1: GccCircle3Tangent  add 48 cases", "[geomAlgo][GccCircle3Tangent][fixbug]") {
	std::shared_ptr<Geom2Curve> l = MakeGeom2Line(Point2(0.0, 0.0), Point2(1.0, 0.0)).Value();
	std::shared_ptr<Geom2Curve> c1 = MakeGeom2Circle(Point2(0.0, 3.0), 2.0).Value();
	std::shared_ptr<Geom2Curve> c2 = MakeGeom2Circle(Point2(4.0, 3.0), 2.0).Value();
	AdaptorGeom2Curve line(l);
	AdaptorGeom2Curve circle1(c1);
	AdaptorGeom2Curve circle2(c2);
	auto lineEnclosed = GccEntity::Enclosed(line);
	auto lineOutside = GccEntity::Outside(line);
	auto lineUnqualified = GccEntity::Unqualified(line);
	auto circle1Enclosed = GccEntity::Enclosed(circle1);
	auto circle1Enclosing = GccEntity::Enclosing(circle1);
	auto circle1Outside = GccEntity::Outside(circle1);
	auto circle1Unqualified = GccEntity::Unqualified(circle1);
	auto circle2Enclosed = GccEntity::Enclosed(circle2);
	auto circle2Enclosing = GccEntity::Enclosing(circle2);
	auto circle2Outside = GccEntity::Outside(circle2);
	auto circle2Unqualified = GccEntity::Unqualified(circle2);
	auto gccl = GccEntity::Enclosed(AdaptorGeom2Curve(l));
	auto gccc1 = GccEntity::Enclosing(AdaptorGeom2Curve(c1));
	auto gccc2 = GccEntity::Outside(AdaptorGeom2Curve(c2));
	auto c3t = [](const GccQualifiedCurve& gccc1, const GccQualifiedCurve& gccc2, const GccQualifiedCurve& gccl)
	{
		std::stringstream output;
		GccCircle3Tangent gcc(gccc1, gccc2, gccl, Precision::Confusion(), 0.0, 0.0, 0.0);
		std::cout << "Test case: " << GccEntity::PositionToString(gccc1.Qualifier()) << ' ' << GccEntity::PositionToString(gccc2.Qualifier()) << ' ' << GccEntity::PositionToString(gccl.Qualifier()) << std::endl;
		std::cout << "Solution: " << gcc.NSolutions() << std::endl;
		output << "Test case: " << GccEntity::PositionToString(gccc1.Qualifier()) << ' ' << GccEntity::PositionToString(gccc2.Qualifier()) << ' ' << GccEntity::PositionToString(gccl.Qualifier()) << std::endl;
		output << "Solution: " << gcc.NSolutions() << std::endl;
		if (gcc.IsDone())
		{
			for (int i = 0; i < gcc.NSolutions(); i++)
			{
				GccPosition q1, q2, q3;
				gcc.Qualifier(i, q1, q2, q3);
				output << i << ": " << *MakeGeom2Circle(gcc.Solution(i)).Value() << std::endl;
				output << "  " << GccEntity::PositionToString(q1) << ' ' << GccEntity::PositionToString(q2) << ' ' << GccEntity::PositionToString(q3) << std::endl;
			}
		}
		else
		{
			std::cout << "gcc.IsDone is False" << std::endl;
			output << "gcc.IsDone is False" << std::endl;
		}
		return output.str();
	};
	auto case1 = c3t(circle1Enclosed, circle2Enclosed, lineEnclosed);
	auto expect1 = "Test case: Enclosed Enclosed Enclosed\nSolution: 0\n";
	CHECK(case1.find(expect1) != std::string::npos);
	auto case2 = c3t(circle1Enclosed, circle2Enclosed, lineOutside);
	auto expect2 = "Test case: Enclosed Enclosed Outside\nSolution: 0\n";
	CHECK(case2.find(expect2) != std::string::npos);
	auto case3 = c3t(circle1Enclosed, circle2Enclosed, lineUnqualified);
	auto expect3 = "Test case: Enclosed Enclosed Unqualified\nSolution: 0\n";
	CHECK(case3.find(expect3) != std::string::npos);
	auto case4 = c3t(circle1Enclosed, circle2Enclosing, lineEnclosed);
	auto expect4 = "Test case: Enclosed Enclosing Enclosed\nSolution: 0\n";
	CHECK(case4.find(expect4) != std::string::npos);
	auto case5 = c3t(circle1Enclosed, circle2Enclosing, lineOutside);
	auto expect5 = "Test case: Enclosed Enclosing Outside\nSolution: 0\n";
	CHECK(case5.find(expect5) != std::string::npos);
	auto case6 = c3t(circle1Enclosed, circle2Enclosing, lineUnqualified);
	auto expect6 = "Test case: Enclosed Enclosing Unqualified\nSolution: 0\n";
	CHECK(case6.find(expect6) != std::string::npos);
	auto case7 = c3t(circle1Enclosed, circle2Outside, lineEnclosed);
	auto expect7 = "Test case: Enclosed Outside Enclosed\nSolution: 0\n";
	CHECK(case7.find(expect7) != std::string::npos);
	auto case8 = c3t(circle1Enclosed, circle2Outside, lineOutside);
	auto expect8 = "Test case: Enclosed Outside Outside\nSolution: 0\n";
	CHECK(case8.find(expect8) != std::string::npos);
	auto case9 = c3t(circle1Enclosed, circle2Outside, lineUnqualified);
	auto expect9 = "Test case: Enclosed Outside Unqualified\nSolution: 0\n";
	CHECK(case9.find(expect9) != std::string::npos);
	auto case10 = c3t(circle1Enclosed, circle2Unqualified, lineEnclosed);
	auto expect10 = "Test case: Enclosed Unqualified Enclosed\nSolution: 0\n";
	CHECK(case10.find(expect10) != std::string::npos);
	auto case11 = c3t(circle1Enclosed, circle2Unqualified, lineOutside);
	auto expect11 = "Test case: Enclosed Unqualified Outside\nSolution: 0\n";
	CHECK(case11.find(expect11) != std::string::npos);
	auto case12 = c3t(circle1Enclosed, circle2Unqualified, lineUnqualified);
	auto expect12 = "Test case: Enclosed Unqualified Unqualified\nSolution: 0\n";
	CHECK(case12.find(expect12) != std::string::npos);
	auto case13 = c3t(circle1Enclosing, circle2Enclosed, lineEnclosed);
	auto expect13 = "Test case: Enclosing Enclosed Enclosed\nSolution: 0\n";
	CHECK(case13.find(expect13) != std::string::npos);
	auto case14 = c3t(circle1Enclosing, circle2Enclosed, lineOutside);
	auto expect14 = "Test case: Enclosing Enclosed Outside\nSolution: 0\n";
	CHECK(case14.find(expect14) != std::string::npos);
	auto case15 = c3t(circle1Enclosing, circle2Enclosed, lineUnqualified);
	auto expect15 = "Test case: Enclosing Enclosed Unqualified\nSolution: 0\n";
	CHECK(case15.find(expect15) != std::string::npos);
	auto case16 = c3t(circle1Enclosing, circle2Enclosing, lineEnclosed);
	auto expect16 = "Test case: Enclosing Enclosing Enclosed\nSolution: 1\n0: 2 2 4.5 1 0 -0 1 4.5\n  Enclosing Enclosing Enclosed\n";
	CHECK(case16.find(expect16) != std::string::npos);
	auto case17 = c3t(circle1Enclosing, circle2Enclosing, lineOutside);
	auto expect17 = "Test case: Enclosing Enclosing Outside\nSolution: 0\n";
	CHECK(case17.find(expect17) != std::string::npos);
	auto case18 = c3t(circle1Enclosing, circle2Enclosing, lineUnqualified);
	auto expect18 = "Test case: Enclosing Enclosing Unqualified\nSolution: 1\n0: 2 2 4.5 1 0 -0 1 4.5\n  Enclosing Enclosing Enclosed\n";
	CHECK(case18.find(expect18) != std::string::npos);
	auto case19 = c3t(circle1Enclosing, circle2Outside, lineEnclosed);
	auto expect19 = "Test case: Enclosing Outside Enclosed\nSolution: 1\n0: 2 -1 3 1 0 -0 1 3\n  Enclosing Outside Enclosed\n";
	CHECK(case19.find(expect19) != std::string::npos);
	auto case20 = c3t(circle1Enclosing, circle2Outside, lineOutside);
	auto expect20 = "Test case: Enclosing Outside Outside\nSolution: 0\n";
	CHECK(case20.find(expect20) != std::string::npos);
	auto case21 = c3t(circle1Enclosing, circle2Outside, lineUnqualified);
	auto expect21 = "Test case: Enclosing Outside Unqualified\nSolution: 1\n0: 2 -1 3 1 0 -0 1 3\n  Enclosing Outside Enclosed\n";
	CHECK(case21.find(expect21) != std::string::npos);
	auto case22 = c3t(circle1Enclosing, circle2Unqualified, lineEnclosed);
	auto expect22 = "Test case: Enclosing Unqualified Enclosed\nSolution: 2\n0: 2 -1 3 1 0 -0 1 3\n  Enclosing Outside Enclosed\n1: 2 2 4.5 1 0 -0 1 4.5\n  Enclosing Enclosing Enclosed\n";
	CHECK(case22.find(expect22) != std::string::npos);
	auto case23 = c3t(circle1Enclosing, circle2Unqualified, lineOutside);
	auto expect23 = "Test case: Enclosing Unqualified Outside\nSolution: 0\n";
	CHECK(case23.find(expect23) != std::string::npos);
	auto case24 = c3t(circle1Enclosing, circle2Unqualified, lineUnqualified);
	auto expect24 = "Test case: Enclosing Unqualified Unqualified\nSolution: 2\n0: 2 -1 3 1 0 -0 1 3\n  Enclosing Outside Enclosed\n1: 2 2 4.5 1 0 -0 1 4.5\n  Enclosing Enclosing Enclosed\n";
	CHECK(case24.find(expect24) != std::string::npos);
	auto case25 = c3t(circle1Outside, circle2Enclosed, lineEnclosed);
	auto expect25 = "Test case: Outside Enclosed Enclosed\nSolution: 0\n";
	CHECK(case25.find(expect25) != std::string::npos);
	auto case26 = c3t(circle1Outside, circle2Enclosed, lineOutside);
	auto expect26 = "Test case: Outside Enclosed Outside\nSolution: 0\n";
	CHECK(case26.find(expect26) != std::string::npos);
	auto case27 = c3t(circle1Outside, circle2Enclosed, lineUnqualified);
	auto expect27 = "Test case: Outside Enclosed Unqualified\nSolution: 0\n";
	CHECK(case27.find(expect27) != std::string::npos);
	auto case28 = c3t(circle1Outside, circle2Enclosing, lineEnclosed);
	auto expect28 = "Test case: Outside Enclosing Enclosed\nSolution: 1\n0: 2 5 3 1 0 -0 1 3\n  Outside Enclosing Enclosed\n";
	CHECK(case28.find(expect28) != std::string::npos);
	auto case29 = c3t(circle1Outside, circle2Enclosing, lineOutside);
	auto expect29 = "Test case: Outside Enclosing Outside\nSolution: 0\n";
	CHECK(case29.find(expect29) != std::string::npos);
	auto case30 = c3t(circle1Outside, circle2Enclosing, lineUnqualified);
	auto expect30 = "Test case: Outside Enclosing Unqualified\nSolution: 1\n0: 2 5 3 1 0 -0 1 3\n  Outside Enclosing Enclosed\n";
	CHECK(case30.find(expect30) != std::string::npos);
	auto case31 = c3t(circle1Outside, circle2Outside, lineEnclosed);
	auto expect31 = "Test case: Outside Outside Enclosed\nSolution: 1\n0: 2 2 0.9 1 0 -0 1 0.9\n  Outside Outside Enclosed\n";
	CHECK(case31.find(expect31) != std::string::npos);
	auto case32 = c3t(circle1Outside, circle2Outside, lineOutside);
	auto expect32 = "Test case: Outside Outside Outside\nSolution: 0\n";
	CHECK(case32.find(expect32) != std::string::npos);
	auto case33 = c3t(circle1Outside, circle2Outside, lineUnqualified);
	auto expect33 = "Test case: Outside Outside Unqualified\nSolution: 1\n0: 2 2 0.9 1 0 -0 1 0.9\n  Outside Outside Enclosed\n";
	CHECK(case33.find(expect33) != std::string::npos);
	auto case34 = c3t(circle1Outside, circle2Unqualified, lineEnclosed);
	auto expect34 = "Test case: Outside Unqualified Enclosed\nSolution: 2\n0: 2 2 0.9 1 0 -0 1 0.9\n  Outside Outside Enclosed\n1: 2 5 3 1 0 -0 1 3\n  Outside Enclosing Enclosed\n";
	CHECK(case34.find(expect34) != std::string::npos);
	auto case35 = c3t(circle1Outside, circle2Unqualified, lineOutside);
	auto expect35 = "Test case: Outside Unqualified Outside\nSolution: 0\n";
	CHECK(case35.find(expect35) != std::string::npos);
	auto case36 = c3t(circle1Outside, circle2Unqualified, lineUnqualified);
	auto expect36 = "Test case: Outside Unqualified Unqualified\nSolution: 2\n0: 2 2 0.9 1 0 -0 1 0.9\n  Outside Outside Enclosed\n1: 2 5 3 1 0 -0 1 3\n  Outside Enclosing Enclosed\n";
	CHECK(case36.find(expect36) != std::string::npos);
	auto case37 = c3t(circle1Unqualified, circle2Enclosed, lineEnclosed);
	auto expect37 = "Test case: Unqualified Enclosed Enclosed\nSolution: 0\n";
	CHECK(case37.find(expect37) != std::string::npos);
	auto case38 = c3t(circle1Unqualified, circle2Enclosed, lineOutside);
	auto expect38 = "Test case: Unqualified Enclosed Outside\nSolution: 0\n";
	CHECK(case38.find(expect38) != std::string::npos);
	auto case39 = c3t(circle1Unqualified, circle2Enclosed, lineUnqualified);
	auto expect39 = "Test case: Unqualified Enclosed Unqualified\nSolution: 0\n";
	CHECK(case39.find(expect39) != std::string::npos);
	auto case40 = c3t(circle1Unqualified, circle2Enclosing, lineEnclosed);
	auto expect40 = "Test case: Unqualified Enclosing Enclosed\nSolution: 2\n0: 2 5 3 1 0 -0 1 3\n  Outside Enclosing Enclosed\n1: 2 2 4.5 1 0 -0 1 4.5\n  Enclosing Enclosing Enclosed\n";
	CHECK(case40.find(expect40) != std::string::npos);
	auto case41 = c3t(circle1Unqualified, circle2Enclosing, lineOutside);
	auto expect41 = "Test case: Unqualified Enclosing Outside\nSolution: 0\n";
	CHECK(case41.find(expect41) != std::string::npos);
	auto case42 = c3t(circle1Unqualified, circle2Enclosing, lineUnqualified);
	auto expect42 = "Test case: Unqualified Enclosing Unqualified\nSolution: 2\n0: 2 5 3 1 0 -0 1 3\n  Outside Enclosing Enclosed\n1: 2 2 4.5 1 0 -0 1 4.5\n  Enclosing Enclosing Enclosed\n";
	CHECK(case42.find(expect42) != std::string::npos);
	auto case43 = c3t(circle1Unqualified, circle2Outside, lineEnclosed);
	auto expect43 = "Test case: Unqualified Outside Enclosed\nSolution: 2\n0: 2 2 0.9 1 0 -0 1 0.9\n  Outside Outside Enclosed\n1: 2 -1 3 1 0 -0 1 3\n  Enclosing Outside Enclosed\n";
	CHECK(case43.find(expect43) != std::string::npos);
	auto case44 = c3t(circle1Unqualified, circle2Outside, lineOutside);
	auto expect44 = "Test case: Unqualified Outside Outside\nSolution: 0\n";
	CHECK(case44.find(expect44) != std::string::npos);
	auto case45 = c3t(circle1Unqualified, circle2Outside, lineUnqualified);
	auto expect45 = "Test case: Unqualified Outside Unqualified\nSolution: 2\n0: 2 2 0.9 1 0 -0 1 0.9\n  Outside Outside Enclosed\n1: 2 -1 3 1 0 -0 1 3\n  Enclosing Outside Enclosed\n";
	CHECK(case45.find(expect45) != std::string::npos);
	auto case46 = c3t(circle1Unqualified, circle2Unqualified, lineEnclosed);
	auto expect46 = "Test case: Unqualified Unqualified Enclosed\nSolution: 4\n0: 2 2 0.9 1 0 -0 1 0.9\n  Outside Outside Enclosed\n1: 2 5 3 1 0 -0 1 3\n  Outside Enclosing Enclosed\n2: 2 -1 3 1 0 -0 1 3\n  Enclosing Outside Enclosed\n3: 2 2 4.5 1 0 -0 1 4.5\n  Enclosing Enclosing Enclosed\n";
	CHECK(case46.find(expect46) != std::string::npos);
	auto case47 = c3t(circle1Unqualified, circle2Unqualified, lineOutside);
	auto expect47 = "Test case: Unqualified Unqualified Outside\nSolution: 0\n";
	CHECK(case47.find(expect47) != std::string::npos);
	auto case48 = c3t(circle1Unqualified, circle2Unqualified, lineUnqualified);
	auto expect48 = "Test case: Unqualified Unqualified Unqualified\nSolution: 4\n0: 2 2 0.9 1 0 -0 1 0.9\n  Outside Outside Enclosed\n1: 2 5 3 1 0 -0 1 3\n  Outside Enclosing Enclosed\n2: 2 -1 3 1 0 -0 1 3\n  Enclosing Outside Enclosed\n3: 2 2 4.5 1 0 -0 1 4.5\n  Enclosing Enclosing Enclosed";
	CHECK(case48.find(expect48) != std::string::npos);
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API GccCircle3Tangent(const Point2& point1, const Point2& point2, const Point2& point3, double tolerance)	 @param tolerance The tolerance
	 @param point3 The third point
	 @param point2 The second point
	 @param point1 The first point
	 @brief Construct a circle passing through three points
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <geomAlgo/GccCircle3Tangent.hpp>
#include <geometry/Geom2Curve.hpp>
#include <geometry/MakeGeom2Line.hpp>
#include <geometry/MakeGeom2Circle.hpp>
#include <geomAlgo/GccEntity.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geomAlgo/GccEntity.hpp>
#include <geomAlgo/GccQualifiedCurve.hpp>
#include <sstream>
using namespace AMCAX;
TEST_CASE("bug1: GccCircle3Tangent  add 48 cases", "[geomAlgo][GccCircle3Tangent][fixbug]") {
	std::shared_ptr<Geom2Curve> l = MakeGeom2Line(Point2(0.0, 0.0), Point2(1.0, 0.0)).Value();
	std::shared_ptr<Geom2Curve> c1 = MakeGeom2Circle(Point2(0.0, 3.0), 2.0).Value();
	std::shared_ptr<Geom2Curve> c2 = MakeGeom2Circle(Point2(4.0, 3.0), 2.0).Value();
	AdaptorGeom2Curve line(l);
	AdaptorGeom2Curve circle1(c1);
	AdaptorGeom2Curve circle2(c2);
	auto lineEnclosed = GccEntity::Enclosed(line);
	auto lineOutside = GccEntity::Outside(line);
	auto lineUnqualified = GccEntity::Unqualified(line);
	auto circle1Enclosed = GccEntity::Enclosed(circle1);
	auto circle1Enclosing = GccEntity::Enclosing(circle1);
	auto circle1Outside = GccEntity::Outside(circle1);
	auto circle1Unqualified = GccEntity::Unqualified(circle1);
	auto circle2Enclosed = GccEntity::Enclosed(circle2);
	auto circle2Enclosing = GccEntity::Enclosing(circle2);
	auto circle2Outside = GccEntity::Outside(circle2);
	auto circle2Unqualified = GccEntity::Unqualified(circle2);
	auto gccl = GccEntity::Enclosed(AdaptorGeom2Curve(l));
	auto gccc1 = GccEntity::Enclosing(AdaptorGeom2Curve(c1));
	auto gccc2 = GccEntity::Outside(AdaptorGeom2Curve(c2));
	auto c3t = [](const GccQualifiedCurve& gccc1, const GccQualifiedCurve& gccc2, const GccQualifiedCurve& gccl)
	{
		std::stringstream output;
		GccCircle3Tangent gcc(gccc1, gccc2, gccl, Precision::Confusion(), 0.0, 0.0, 0.0);
		std::cout << "Test case: " << GccEntity::PositionToString(gccc1.Qualifier()) << ' ' << GccEntity::PositionToString(gccc2.Qualifier()) << ' ' << GccEntity::PositionToString(gccl.Qualifier()) << std::endl;
		std::cout << "Solution: " << gcc.NSolutions() << std::endl;
		output << "Test case: " << GccEntity::PositionToString(gccc1.Qualifier()) << ' ' << GccEntity::PositionToString(gccc2.Qualifier()) << ' ' << GccEntity::PositionToString(gccl.Qualifier()) << std::endl;
		output << "Solution: " << gcc.NSolutions() << std::endl;
		if (gcc.IsDone())
		{
			for (int i = 0; i < gcc.NSolutions(); i++)
			{
				GccPosition q1, q2, q3;
				gcc.Qualifier(i, q1, q2, q3);
				output << i << ": " << *MakeGeom2Circle(gcc.Solution(i)).Value() << std::endl;
				output << "  " << GccEntity::PositionToString(q1) << ' ' << GccEntity::PositionToString(q2) << ' ' << GccEntity::PositionToString(q3) << std::endl;
			}
		}
		else
		{
			std::cout << "gcc.IsDone is False" << std::endl;
			output << "gcc.IsDone is False" << std::endl;
		}
		return output.str();
	};
	auto case1 = c3t(circle1Enclosed, circle2Enclosed, lineEnclosed);
	auto expect1 = "Test case: Enclosed Enclosed Enclosed\nSolution: 0\n";
	CHECK(case1.find(expect1) != std::string::npos);
	auto case2 = c3t(circle1Enclosed, circle2Enclosed, lineOutside);
	auto expect2 = "Test case: Enclosed Enclosed Outside\nSolution: 0\n";
	CHECK(case2.find(expect2) != std::string::npos);
	auto case3 = c3t(circle1Enclosed, circle2Enclosed, lineUnqualified);
	auto expect3 = "Test case: Enclosed Enclosed Unqualified\nSolution: 0\n";
	CHECK(case3.find(expect3) != std::string::npos);
	auto case4 = c3t(circle1Enclosed, circle2Enclosing, lineEnclosed);
	auto expect4 = "Test case: Enclosed Enclosing Enclosed\nSolution: 0\n";
	CHECK(case4.find(expect4) != std::string::npos);
	auto case5 = c3t(circle1Enclosed, circle2Enclosing, lineOutside);
	auto expect5 = "Test case: Enclosed Enclosing Outside\nSolution: 0\n";
	CHECK(case5.find(expect5) != std::string::npos);
	auto case6 = c3t(circle1Enclosed, circle2Enclosing, lineUnqualified);
	auto expect6 = "Test case: Enclosed Enclosing Unqualified\nSolution: 0\n";
	CHECK(case6.find(expect6) != std::string::npos);
	auto case7 = c3t(circle1Enclosed, circle2Outside, lineEnclosed);
	auto expect7 = "Test case: Enclosed Outside Enclosed\nSolution: 0\n";
	CHECK(case7.find(expect7) != std::string::npos);
	auto case8 = c3t(circle1Enclosed, circle2Outside, lineOutside);
	auto expect8 = "Test case: Enclosed Outside Outside\nSolution: 0\n";
	CHECK(case8.find(expect8) != std::string::npos);
	auto case9 = c3t(circle1Enclosed, circle2Outside, lineUnqualified);
	auto expect9 = "Test case: Enclosed Outside Unqualified\nSolution: 0\n";
	CHECK(case9.find(expect9) != std::string::npos);
	auto case10 = c3t(circle1Enclosed, circle2Unqualified, lineEnclosed);
	auto expect10 = "Test case: Enclosed Unqualified Enclosed\nSolution: 0\n";
	CHECK(case10.find(expect10) != std::string::npos);
	auto case11 = c3t(circle1Enclosed, circle2Unqualified, lineOutside);
	auto expect11 = "Test case: Enclosed Unqualified Outside\nSolution: 0\n";
	CHECK(case11.find(expect11) != std::string::npos);
	auto case12 = c3t(circle1Enclosed, circle2Unqualified, lineUnqualified);
	auto expect12 = "Test case: Enclosed Unqualified Unqualified\nSolution: 0\n";
	CHECK(case12.find(expect12) != std::string::npos);
	auto case13 = c3t(circle1Enclosing, circle2Enclosed, lineEnclosed);
	auto expect13 = "Test case: Enclosing Enclosed Enclosed\nSolution: 0\n";
	CHECK(case13.find(expect13) != std::string::npos);
	auto case14 = c3t(circle1Enclosing, circle2Enclosed, lineOutside);
	auto expect14 = "Test case: Enclosing Enclosed Outside\nSolution: 0\n";
	CHECK(case14.find(expect14) != std::string::npos);
	auto case15 = c3t(circle1Enclosing, circle2Enclosed, lineUnqualified);
	auto expect15 = "Test case: Enclosing Enclosed Unqualified\nSolution: 0\n";
	CHECK(case15.find(expect15) != std::string::npos);
	auto case16 = c3t(circle1Enclosing, circle2Enclosing, lineEnclosed);
	auto expect16 = "Test case: Enclosing Enclosing Enclosed\nSolution: 1\n0: 2 2 4.5 1 0 -0 1 4.5\n  Enclosing Enclosing Enclosed\n";
	CHECK(case16.find(expect16) != std::string::npos);
	auto case17 = c3t(circle1Enclosing, circle2Enclosing, lineOutside);
	auto expect17 = "Test case: Enclosing Enclosing Outside\nSolution: 0\n";
	CHECK(case17.find(expect17) != std::string::npos);
	auto case18 = c3t(circle1Enclosing, circle2Enclosing, lineUnqualified);
	auto expect18 = "Test case: Enclosing Enclosing Unqualified\nSolution: 1\n0: 2 2 4.5 1 0 -0 1 4.5\n  Enclosing Enclosing Enclosed\n";
	CHECK(case18.find(expect18) != std::string::npos);
	auto case19 = c3t(circle1Enclosing, circle2Outside, lineEnclosed);
	auto expect19 = "Test case: Enclosing Outside Enclosed\nSolution: 1\n0: 2 -1 3 1 0 -0 1 3\n  Enclosing Outside Enclosed\n";
	CHECK(case19.find(expect19) != std::string::npos);
	auto case20 = c3t(circle1Enclosing, circle2Outside, lineOutside);
	auto expect20 = "Test case: Enclosing Outside Outside\nSolution: 0\n";
	CHECK(case20.find(expect20) != std::string::npos);
	auto case21 = c3t(circle1Enclosing, circle2Outside, lineUnqualified);
	auto expect21 = "Test case: Enclosing Outside Unqualified\nSolution: 1\n0: 2 -1 3 1 0 -0 1 3\n  Enclosing Outside Enclosed\n";
	CHECK(case21.find(expect21) != std::string::npos);
	auto case22 = c3t(circle1Enclosing, circle2Unqualified, lineEnclosed);
	auto expect22 = "Test case: Enclosing Unqualified Enclosed\nSolution: 2\n0: 2 -1 3 1 0 -0 1 3\n  Enclosing Outside Enclosed\n1: 2 2 4.5 1 0 -0 1 4.5\n  Enclosing Enclosing Enclosed\n";
	CHECK(case22.find(expect22) != std::string::npos);
	auto case23 = c3t(circle1Enclosing, circle2Unqualified, lineOutside);
	auto expect23 = "Test case: Enclosing Unqualified Outside\nSolution: 0\n";
	CHECK(case23.find(expect23) != std::string::npos);
	auto case24 = c3t(circle1Enclosing, circle2Unqualified, lineUnqualified);
	auto expect24 = "Test case: Enclosing Unqualified Unqualified\nSolution: 2\n0: 2 -1 3 1 0 -0 1 3\n  Enclosing Outside Enclosed\n1: 2 2 4.5 1 0 -0 1 4.5\n  Enclosing Enclosing Enclosed\n";
	CHECK(case24.find(expect24) != std::string::npos);
	auto case25 = c3t(circle1Outside, circle2Enclosed, lineEnclosed);
	auto expect25 = "Test case: Outside Enclosed Enclosed\nSolution: 0\n";
	CHECK(case25.find(expect25) != std::string::npos);
	auto case26 = c3t(circle1Outside, circle2Enclosed, lineOutside);
	auto expect26 = "Test case: Outside Enclosed Outside\nSolution: 0\n";
	CHECK(case26.find(expect26) != std::string::npos);
	auto case27 = c3t(circle1Outside, circle2Enclosed, lineUnqualified);
	auto expect27 = "Test case: Outside Enclosed Unqualified\nSolution: 0\n";
	CHECK(case27.find(expect27) != std::string::npos);
	auto case28 = c3t(circle1Outside, circle2Enclosing, lineEnclosed);
	auto expect28 = "Test case: Outside Enclosing Enclosed\nSolution: 1\n0: 2 5 3 1 0 -0 1 3\n  Outside Enclosing Enclosed\n";
	CHECK(case28.find(expect28) != std::string::npos);
	auto case29 = c3t(circle1Outside, circle2Enclosing, lineOutside);
	auto expect29 = "Test case: Outside Enclosing Outside\nSolution: 0\n";
	CHECK(case29.find(expect29) != std::string::npos);
	auto case30 = c3t(circle1Outside, circle2Enclosing, lineUnqualified);
	auto expect30 = "Test case: Outside Enclosing Unqualified\nSolution: 1\n0: 2 5 3 1 0 -0 1 3\n  Outside Enclosing Enclosed\n";
	CHECK(case30.find(expect30) != std::string::npos);
	auto case31 = c3t(circle1Outside, circle2Outside, lineEnclosed);
	auto expect31 = "Test case: Outside Outside Enclosed\nSolution: 1\n0: 2 2 0.9 1 0 -0 1 0.9\n  Outside Outside Enclosed\n";
	CHECK(case31.find(expect31) != std::string::npos);
	auto case32 = c3t(circle1Outside, circle2Outside, lineOutside);
	auto expect32 = "Test case: Outside Outside Outside\nSolution: 0\n";
	CHECK(case32.find(expect32) != std::string::npos);
	auto case33 = c3t(circle1Outside, circle2Outside, lineUnqualified);
	auto expect33 = "Test case: Outside Outside Unqualified\nSolution: 1\n0: 2 2 0.9 1 0 -0 1 0.9\n  Outside Outside Enclosed\n";
	CHECK(case33.find(expect33) != std::string::npos);
	auto case34 = c3t(circle1Outside, circle2Unqualified, lineEnclosed);
	auto expect34 = "Test case: Outside Unqualified Enclosed\nSolution: 2\n0: 2 2 0.9 1 0 -0 1 0.9\n  Outside Outside Enclosed\n1: 2 5 3 1 0 -0 1 3\n  Outside Enclosing Enclosed\n";
	CHECK(case34.find(expect34) != std::string::npos);
	auto case35 = c3t(circle1Outside, circle2Unqualified, lineOutside);
	auto expect35 = "Test case: Outside Unqualified Outside\nSolution: 0\n";
	CHECK(case35.find(expect35) != std::string::npos);
	auto case36 = c3t(circle1Outside, circle2Unqualified, lineUnqualified);
	auto expect36 = "Test case: Outside Unqualified Unqualified\nSolution: 2\n0: 2 2 0.9 1 0 -0 1 0.9\n  Outside Outside Enclosed\n1: 2 5 3 1 0 -0 1 3\n  Outside Enclosing Enclosed\n";
	CHECK(case36.find(expect36) != std::string::npos);
	auto case37 = c3t(circle1Unqualified, circle2Enclosed, lineEnclosed);
	auto expect37 = "Test case: Unqualified Enclosed Enclosed\nSolution: 0\n";
	CHECK(case37.find(expect37) != std::string::npos);
	auto case38 = c3t(circle1Unqualified, circle2Enclosed, lineOutside);
	auto expect38 = "Test case: Unqualified Enclosed Outside\nSolution: 0\n";
	CHECK(case38.find(expect38) != std::string::npos);
	auto case39 = c3t(circle1Unqualified, circle2Enclosed, lineUnqualified);
	auto expect39 = "Test case: Unqualified Enclosed Unqualified\nSolution: 0\n";
	CHECK(case39.find(expect39) != std::string::npos);
	auto case40 = c3t(circle1Unqualified, circle2Enclosing, lineEnclosed);
	auto expect40 = "Test case: Unqualified Enclosing Enclosed\nSolution: 2\n0: 2 5 3 1 0 -0 1 3\n  Outside Enclosing Enclosed\n1: 2 2 4.5 1 0 -0 1 4.5\n  Enclosing Enclosing Enclosed\n";
	CHECK(case40.find(expect40) != std::string::npos);
	auto case41 = c3t(circle1Unqualified, circle2Enclosing, lineOutside);
	auto expect41 = "Test case: Unqualified Enclosing Outside\nSolution: 0\n";
	CHECK(case41.find(expect41) != std::string::npos);
	auto case42 = c3t(circle1Unqualified, circle2Enclosing, lineUnqualified);
	auto expect42 = "Test case: Unqualified Enclosing Unqualified\nSolution: 2\n0: 2 5 3 1 0 -0 1 3\n  Outside Enclosing Enclosed\n1: 2 2 4.5 1 0 -0 1 4.5\n  Enclosing Enclosing Enclosed\n";
	CHECK(case42.find(expect42) != std::string::npos);
	auto case43 = c3t(circle1Unqualified, circle2Outside, lineEnclosed);
	auto expect43 = "Test case: Unqualified Outside Enclosed\nSolution: 2\n0: 2 2 0.9 1 0 -0 1 0.9\n  Outside Outside Enclosed\n1: 2 -1 3 1 0 -0 1 3\n  Enclosing Outside Enclosed\n";
	CHECK(case43.find(expect43) != std::string::npos);
	auto case44 = c3t(circle1Unqualified, circle2Outside, lineOutside);
	auto expect44 = "Test case: Unqualified Outside Outside\nSolution: 0\n";
	CHECK(case44.find(expect44) != std::string::npos);
	auto case45 = c3t(circle1Unqualified, circle2Outside, lineUnqualified);
	auto expect45 = "Test case: Unqualified Outside Unqualified\nSolution: 2\n0: 2 2 0.9 1 0 -0 1 0.9\n  Outside Outside Enclosed\n1: 2 -1 3 1 0 -0 1 3\n  Enclosing Outside Enclosed\n";
	CHECK(case45.find(expect45) != std::string::npos);
	auto case46 = c3t(circle1Unqualified, circle2Unqualified, lineEnclosed);
	auto expect46 = "Test case: Unqualified Unqualified Enclosed\nSolution: 4\n0: 2 2 0.9 1 0 -0 1 0.9\n  Outside Outside Enclosed\n1: 2 5 3 1 0 -0 1 3\n  Outside Enclosing Enclosed\n2: 2 -1 3 1 0 -0 1 3\n  Enclosing Outside Enclosed\n3: 2 2 4.5 1 0 -0 1 4.5\n  Enclosing Enclosing Enclosed\n";
	CHECK(case46.find(expect46) != std::string::npos);
	auto case47 = c3t(circle1Unqualified, circle2Unqualified, lineOutside);
	auto expect47 = "Test case: Unqualified Unqualified Outside\nSolution: 0\n";
	CHECK(case47.find(expect47) != std::string::npos);
	auto case48 = c3t(circle1Unqualified, circle2Unqualified, lineUnqualified);
	auto expect48 = "Test case: Unqualified Unqualified Unqualified\nSolution: 4\n0: 2 2 0.9 1 0 -0 1 0.9\n  Outside Outside Enclosed\n1: 2 5 3 1 0 -0 1 3\n  Outside Enclosing Enclosed\n2: 2 -1 3 1 0 -0 1 3\n  Enclosing Outside Enclosed\n3: 2 2 4.5 1 0 -0 1 4.5\n  Enclosing Enclosing Enclosed";
	CHECK(case48.find(expect48) != std::string::npos);
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API virtual void D1(double x, double& f, double& d)	 @param[out] d The function first derivative
	 @param[out] f The function value
	 @param[in] x The given parameter
	 @brief Get the function first derivative at the given parameter
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include<geomAlgo/LawConstant.hpp>
#include<geomAlgo/LawFunction.hpp>
using namespace std;
TEST_CASE("case1: this is a test case for LawConstant", "[geomAlgo][LawFunction][P1]")
{
	LawConstant cons;
	cons.Set(2.0, 4.0, 10.0);
	SECTION("D1")
	{
		double x = 1.0;
		double f = 0.0; 
		double d = 0.0;
		cons.D1(x, f, d);
		CHECK(f == Approx(2.0));
		CHECK(d == Approx(0.0));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API virtual std::shared_ptr<LawFunction> Trim(double fp, double lp, double tol)	 @return The new law
	 @param tol The given tolerance, not all laws use this parameter
	 @param lp The second parameter
	 @param fp The first parameter
	 @brief Get the trimmed law of this
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include<geomAlgo/LawConstant.hpp>
#include<geomAlgo/LawFunction.hpp>
using namespace std;
TEST_CASE("case1: this is a test case for LawConstant", "[geomAlgo][LawFunction][P1]")
{
	LawConstant cons;
	cons.Set(2.0, 4.0, 10.0);
	SECTION("Trim")
	{
		shared_ptr<LawFunction>tr;
		double fp = 1.0;
		double lp = 5.0;
		double tol = 0.1;
		double fp1 = 0.0;
		double lp1 = 0.0;
		tr = cons.Trim(fp, lp, tol);
		tr->Bounds(fp1, lp1);
		CHECK(fp1 == fp);
		CHECK(lp1 == lp);
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":explicit Conic2Constraint(const Point2& point)	 @param point The point constraint
	 @brief Construct from a point constraint
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <geomAlgo/MakeConic2FromConstraints.hpp>
#include <geometry/GeometryTool.hpp>
#include <math/HyperbolaT.hpp>
#include <geometry/Geom2Hyperbola.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <modeling/MakeEdge.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/Geom2Circle.hpp>
#include <geometry/GeomAPIProjectPointOnCurve3.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeEdge.hpp>
TEST_CASE("bug1: MakeConic2FromConstraints ", "[geomAlgo][MakeConic2FromConstraints][fixbug]")
{
	Point2 a(0.0, 0.0);
	Point2 b(1.0, 1.0);
	Vector2 da(-0.5, 0.5);
	Vector2 db(1.0, -0.2);
	Point3 a1(a.X(), a.Y(), 0.0);
	Point3 b1(b.X(), b.Y(), 0.0);
	Vector3 da1(da.X(), da.Y(), 0.0);
	Vector3 db1(db.X(), db.Y(), 0.0);
	Conic2Constraint ca(a, da);
	Conic2Constraint cb(b, db);
	MakeConic2FromConstraints mc2fc(ca, cb, 0.0);
	shared_ptr<Geom3Curve> curve;
	curve = GeometryTool::To3d(Frame3(), mc2fc.Curve2d());
	CHECK(mc2fc.Curve2d() == nullptr);
	CHECK(curve == nullptr);
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API MakeConic2FromConstraints(const Conic2Constraint& startConstraint, const Conic2Constraint& endConstraint, double parameter)	 @param parameter The parameter to determine type and shape of the conic, valid range is (0.0, 1.0): ellipse if (0.0, 0.5), parabola if {0.5}, hyperbola if (0.5, 1.0)
	 @param endConstraint The end point and tangent
	 @param startConstraint The start point and tangent
	 @brief Build by ending points and tangents and a parameter
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <geomAlgo/MakeConic2FromConstraints.hpp>
#include <geometry/GeometryTool.hpp>
#include <math/HyperbolaT.hpp>
#include <geometry/Geom2Hyperbola.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <modeling/MakeEdge.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/Geom2Circle.hpp>
#include <geometry/GeomAPIProjectPointOnCurve3.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeEdge.hpp>
TEST_CASE("bug1: MakeConic2FromConstraints ", "[geomAlgo][MakeConic2FromConstraints][fixbug]")
{
	Point2 a(0.0, 0.0);
	Point2 b(1.0, 1.0);
	Vector2 da(-0.5, 0.5);
	Vector2 db(1.0, -0.2);
	Point3 a1(a.X(), a.Y(), 0.0);
	Point3 b1(b.X(), b.Y(), 0.0);
	Vector3 da1(da.X(), da.Y(), 0.0);
	Vector3 db1(db.X(), db.Y(), 0.0);
	Conic2Constraint ca(a, da);
	Conic2Constraint cb(b, db);
	MakeConic2FromConstraints mc2fc(ca, cb, 0.0);
	shared_ptr<Geom3Curve> curve;
	curve = GeometryTool::To3d(Frame3(), mc2fc.Curve2d());
	CHECK(mc2fc.Curve2d() == nullptr);
	CHECK(curve == nullptr);
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API explicit MakeConic2FromConstraints(const std::vector<Conic2Constraint>& constraints)	 @param constraints The constraints of the conic. It is supported that the constraints contain 5 points, 4 points and 1 tangent, 3 points and 2 tangent
	 @brief Build by point and tangent constraints. The number of constraints must be 5 in total and the start and the end point constraints are required
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <geomAlgo/MakeConic2FromConstraints.hpp>
#include <geometry/GeometryTool.hpp>
#include <math/HyperbolaT.hpp>
#include <geometry/Geom2Hyperbola.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <modeling/MakeEdge.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/Geom2Circle.hpp>
#include <geometry/GeomAPIProjectPointOnCurve3.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeEdge.hpp>
TEST_CASE("bug1: MakeConic2FromConstraints ", "[geomAlgo][MakeConic2FromConstraints][fixbug]")
{
	Point2 a(0.0, 0.0);
	Point2 b(1.0, 1.0);
	Vector2 da(-0.5, 0.5);
	Vector2 db(1.0, -0.2);
	Point3 a1(a.X(), a.Y(), 0.0);
	Point3 b1(b.X(), b.Y(), 0.0);
	Vector3 da1(da.X(), da.Y(), 0.0);
	Vector3 db1(db.X(), db.Y(), 0.0);
	Conic2Constraint ca(a, da);
	Conic2Constraint cb(b, db);
	MakeConic2FromConstraints mc2fc(ca, cb, 0.0);
	shared_ptr<Geom3Curve> curve;
	curve = GeometryTool::To3d(Frame3(), mc2fc.Curve2d());
	CHECK(mc2fc.Curve2d() == nullptr);
	CHECK(curve == nullptr);
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API ComputePointsAbscissa(double tol, const Adaptor3Curve& c, double abscissa, double u0)	 @param u0 The starting parameter
	 @param abscissa The arc length
	 @param c The curve
	 @param tol The tolerance
	 @brief Compute the parameter of a point on a 3D curve with given arc length and a tolerance
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <geometry/MakeGeom2Circle.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/ComputePointsAbscissa.hpp>
#include <geometry/MakeGeom3Circle.hpp>
#include <geometry/AdaptorGeom3Curve.hpp>
#include <geometry/MakeGeom2Hyperbola.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/MakeGeom2Ellipse.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <geometry/MakeGeom3Ellipse.hpp>
#include <geometry/MakeGeom3Hyperbola.hpp>
#include <geometry/Geom2Line.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom3Line.hpp>
#include <geometry/Geom3TrimmedCurve.hpp>
#include<modeling/MakeEdge.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/GeometryTool.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <geometry/MakeGeom2Parabola.hpp>
#include <geometry/MakeGeom3Parabola.hpp>
#include <geometry/Geom2BezierCurve.hpp>
#include <geometry/Geom3BezierCurve.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/Geom2OffsetCurve.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
TEST_CASE("tset the parameters for calculating a point on a 3D curve of a given arc length and the length of the 3D curve.", "[geometry][ComputePointsAbscissa][case5]")
{
	SECTION("circle")
    {
        Frame3 frame;
        double r = 2.0;
        double l = 1.0;
        std::shared_ptr<Geom3Curve> c = MakeGeom3Circle(frame, r).Value();
        AdaptorGeom3Curve circle(c);
        ComputePointsAbscissa cpa(circle, 1.0, 0.0);
        double angle1 = l / r;
        std::cout << "" << ": " << angle1 << '\n';
        double x = r * cos(angle1);
        double y = r * sin(angle1);
        double z = 0;
        std::cout << "x" << ": " << x << '\n';
        std::cout << "y" << ": " << y << '\n';
        std::cout << "z" << ": " << z << '\n';
        double param = cpa.Parameter();
        if (cpa.IsDone())
        {
            std::cout << param << ": " << circle.Value(param) << '\n';
        }
        double p = 2 * M_PI * r;
        std::cout << "" << ComputePointsAbscissa::Length(circle) << '\n';
        Point3 s = circle.Value(param);
        Point3 s1(x, y, z);
        std::cout << s << std::endl;
        CHECK(p == ComputePointsAbscissa::Length(circle));
        CHECK(angle1 == cpa.Parameter());
        CHECK(s.X() == s1.X());
        CHECK(s.Y() == s1.Y());
        CHECK(s.Z() == s1.Z());
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API ComputePointsAbscissa(double tol, const Adaptor2Curve& c, double abscissa, double u0)	 @param u0 The starting parameter
	 @param abscissa The arc length
	 @param c The curve
	 @param tol The tolerance
	 @brief Compute the parameter of a point on a 2D curve with given arc length and a tolerance
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <geometry/MakeGeom2Circle.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/ComputePointsAbscissa.hpp>
#include <geometry/MakeGeom3Circle.hpp>
#include <geometry/AdaptorGeom3Curve.hpp>
#include <geometry/MakeGeom2Hyperbola.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/MakeGeom2Ellipse.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <geometry/MakeGeom3Ellipse.hpp>
#include <geometry/MakeGeom3Hyperbola.hpp>
#include <geometry/Geom2Line.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom3Line.hpp>
#include <geometry/Geom3TrimmedCurve.hpp>
#include<modeling/MakeEdge.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/GeometryTool.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <geometry/MakeGeom2Parabola.hpp>
#include <geometry/MakeGeom3Parabola.hpp>
#include <geometry/Geom2BezierCurve.hpp>
#include <geometry/Geom3BezierCurve.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/Geom2OffsetCurve.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
TEST_CASE("test the parameters for calculating a point on a 2D curve with a given arc length and the length of the 2D curve.", "[geometry][ComputePointsAbscissa][case1]")
{
	SECTION("circle")
    {
        double r = 2.0;
        double l = 1.0;
        std::shared_ptr<Geom2Curve> c = MakeGeom2Circle(Point2(0.0, 0.0), 2.0).Value();
        AdaptorGeom2Curve circle(c);
        ComputePointsAbscissa cpa(circle, 1.0, 0.0);
        double angle1 = l / r;
        std::cout << "" << ": " << angle1 << '\n';
        double x = r * cos(angle1);
        double y = r * sin(angle1);
        std::cout << "x" << ": " << x << '\n';
        std::cout << "y" << ": " << y << '\n';
        double param = cpa.Parameter();
        if (cpa.IsDone())
        {
            std::cout << param << ": " << circle.Value(param) << '\n';
        }
        double p = 2 * M_PI * r;
        std::cout << "" << ComputePointsAbscissa::Length(circle) << '\n';
        Point2 s = circle.Value(param);
        Point2 s1(x, y);
        std::cout << s << std::endl;
        CHECK(p == ComputePointsAbscissa::Length(circle));
        CHECK(angle1 == cpa.Parameter());
        CHECK(s.X() == s1.X());
        CHECK(s.Y() == s1.Y());
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API ComputePointsAbscissa(const Adaptor3Curve& c, double abscissa, double u0)	 @param u0 The starting parameter
	 @param abscissa The arc length
	 @param c The curve
	 @brief Compute the parameter of a point on a 3D curve with given arc length
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <geometry/MakeGeom2Circle.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/ComputePointsAbscissa.hpp>
#include <geometry/MakeGeom3Circle.hpp>
#include <geometry/AdaptorGeom3Curve.hpp>
#include <geometry/MakeGeom2Hyperbola.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/MakeGeom2Ellipse.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <geometry/MakeGeom3Ellipse.hpp>
#include <geometry/MakeGeom3Hyperbola.hpp>
#include <geometry/Geom2Line.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom3Line.hpp>
#include <geometry/Geom3TrimmedCurve.hpp>
#include<modeling/MakeEdge.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/GeometryTool.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <geometry/MakeGeom2Parabola.hpp>
#include <geometry/MakeGeom3Parabola.hpp>
#include <geometry/Geom2BezierCurve.hpp>
#include <geometry/Geom3BezierCurve.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/Geom2OffsetCurve.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
TEST_CASE("tset the parameters for calculating a point on a 3D curve of a given arc length and the length of the 3D curve.", "[geometry][ComputePointsAbscissa][case5]")
{
	SECTION("circle")
    {
        Frame3 frame;
        double r = 2.0;
        double l = 1.0;
        std::shared_ptr<Geom3Curve> c = MakeGeom3Circle(frame, r).Value();
        AdaptorGeom3Curve circle(c);
        ComputePointsAbscissa cpa(circle, 1.0, 0.0);
        double angle1 = l / r;
        std::cout << "" << ": " << angle1 << '\n';
        double x = r * cos(angle1);
        double y = r * sin(angle1);
        double z = 0;
        std::cout << "x" << ": " << x << '\n';
        std::cout << "y" << ": " << y << '\n';
        std::cout << "z" << ": " << z << '\n';
        double param = cpa.Parameter();
        if (cpa.IsDone())
        {
            std::cout << param << ": " << circle.Value(param) << '\n';
        }
        double p = 2 * M_PI * r;
        std::cout << "" << ComputePointsAbscissa::Length(circle) << '\n';
        Point3 s = circle.Value(param);
        Point3 s1(x, y, z);
        std::cout << s << std::endl;
        CHECK(p == ComputePointsAbscissa::Length(circle));
        CHECK(angle1 == cpa.Parameter());
        CHECK(s.X() == s1.X());
        CHECK(s.Y() == s1.Y());
        CHECK(s.Z() == s1.Z());
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API ComputePointsAbscissa(const Adaptor2Curve& c, double abscissa, double u0)	 @param u0 The starting parameter
	 @param abscissa The arc length
	 @param c The curve
	 @brief Compute the parameter of a point on a 2D curve with given arc length
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <geometry/MakeGeom2Circle.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/ComputePointsAbscissa.hpp>
#include <geometry/MakeGeom3Circle.hpp>
#include <geometry/AdaptorGeom3Curve.hpp>
#include <geometry/MakeGeom2Hyperbola.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/MakeGeom2Ellipse.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <geometry/MakeGeom3Ellipse.hpp>
#include <geometry/MakeGeom3Hyperbola.hpp>
#include <geometry/Geom2Line.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom3Line.hpp>
#include <geometry/Geom3TrimmedCurve.hpp>
#include<modeling/MakeEdge.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/GeometryTool.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <geometry/MakeGeom2Parabola.hpp>
#include <geometry/MakeGeom3Parabola.hpp>
#include <geometry/Geom2BezierCurve.hpp>
#include <geometry/Geom3BezierCurve.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/Geom2OffsetCurve.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
TEST_CASE("test the parameters for calculating a point on a 2D curve with a given arc length and the length of the 2D curve.", "[geometry][ComputePointsAbscissa][case1]")
{
	SECTION("circle")
    {
        double r = 2.0;
        double l = 1.0;
        std::shared_ptr<Geom2Curve> c = MakeGeom2Circle(Point2(0.0, 0.0), 2.0).Value();
        AdaptorGeom2Curve circle(c);
        ComputePointsAbscissa cpa(circle, 1.0, 0.0);
        double angle1 = l / r;
        std::cout << "" << ": " << angle1 << '\n';
        double x = r * cos(angle1);
        double y = r * sin(angle1);
        std::cout << "x" << ": " << x << '\n';
        std::cout << "y" << ": " << y << '\n';
        double param = cpa.Parameter();
        if (cpa.IsDone())
        {
            std::cout << param << ": " << circle.Value(param) << '\n';
        }
        double p = 2 * M_PI * r;
        std::cout << "" << ComputePointsAbscissa::Length(circle) << '\n';
        Point2 s = circle.Value(param);
        Point2 s1(x, y);
        std::cout << s << std::endl;
        CHECK(p == ComputePointsAbscissa::Length(circle));
        CHECK(angle1 == cpa.Parameter());
        CHECK(s.X() == s1.X());
        CHECK(s.Y() == s1.Y());
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API ComputePointsAbscissa(const Adaptor3Curve& c, double abscissa, double u0, double ui)	 @param ui The initial guess of the parameter
	 @param u0 The starting parameter
	 @param abscissa The arc length
	 @param c The curve
	 @brief Compute the parameter of a point on a 3D curve with given arc length and an initial guess
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <geometry/MakeGeom2Circle.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/ComputePointsAbscissa.hpp>
#include <geometry/MakeGeom3Circle.hpp>
#include <geometry/AdaptorGeom3Curve.hpp>
#include <geometry/MakeGeom2Hyperbola.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/MakeGeom2Ellipse.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <geometry/MakeGeom3Ellipse.hpp>
#include <geometry/MakeGeom3Hyperbola.hpp>
#include <geometry/Geom2Line.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom3Line.hpp>
#include <geometry/Geom3TrimmedCurve.hpp>
#include<modeling/MakeEdge.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/GeometryTool.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <geometry/MakeGeom2Parabola.hpp>
#include <geometry/MakeGeom3Parabola.hpp>
#include <geometry/Geom2BezierCurve.hpp>
#include <geometry/Geom3BezierCurve.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/Geom2OffsetCurve.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
TEST_CASE("tset the parameters for calculating a point on a 3D curve of a given arc length and the length of the 3D curve.", "[geometry][ComputePointsAbscissa][case5]")
{
	SECTION("circle")
    {
        Frame3 frame;
        double r = 2.0;
        double l = 1.0;
        std::shared_ptr<Geom3Curve> c = MakeGeom3Circle(frame, r).Value();
        AdaptorGeom3Curve circle(c);
        ComputePointsAbscissa cpa(circle, 1.0, 0.0);
        double angle1 = l / r;
        std::cout << "" << ": " << angle1 << '\n';
        double x = r * cos(angle1);
        double y = r * sin(angle1);
        double z = 0;
        std::cout << "x" << ": " << x << '\n';
        std::cout << "y" << ": " << y << '\n';
        std::cout << "z" << ": " << z << '\n';
        double param = cpa.Parameter();
        if (cpa.IsDone())
        {
            std::cout << param << ": " << circle.Value(param) << '\n';
        }
        double p = 2 * M_PI * r;
        std::cout << "" << ComputePointsAbscissa::Length(circle) << '\n';
        Point3 s = circle.Value(param);
        Point3 s1(x, y, z);
        std::cout << s << std::endl;
        CHECK(p == ComputePointsAbscissa::Length(circle));
        CHECK(angle1 == cpa.Parameter());
        CHECK(s.X() == s1.X());
        CHECK(s.Y() == s1.Y());
        CHECK(s.Z() == s1.Z());
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API ComputePointsAbscissa(const Adaptor2Curve& c, double abscissa, double u0, double ui)	 @param ui The initial guess of the parameter
	 @param u0 The starting parameter
	 @param abscissa The arc length
	 @param c The curve
	 @brief Compute the parameter of a point on a 2D curve with given arc length and an initial guess
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <geometry/MakeGeom2Circle.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/ComputePointsAbscissa.hpp>
#include <geometry/MakeGeom3Circle.hpp>
#include <geometry/AdaptorGeom3Curve.hpp>
#include <geometry/MakeGeom2Hyperbola.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/MakeGeom2Ellipse.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <geometry/MakeGeom3Ellipse.hpp>
#include <geometry/MakeGeom3Hyperbola.hpp>
#include <geometry/Geom2Line.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom3Line.hpp>
#include <geometry/Geom3TrimmedCurve.hpp>
#include<modeling/MakeEdge.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/GeometryTool.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <geometry/MakeGeom2Parabola.hpp>
#include <geometry/MakeGeom3Parabola.hpp>
#include <geometry/Geom2BezierCurve.hpp>
#include <geometry/Geom3BezierCurve.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/Geom2OffsetCurve.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
TEST_CASE("test the parameters for calculating a point on a 2D curve with a given arc length and the length of the 2D curve.", "[geometry][ComputePointsAbscissa][case1]")
{
	SECTION("circle")
    {
        double r = 2.0;
        double l = 1.0;
        std::shared_ptr<Geom2Curve> c = MakeGeom2Circle(Point2(0.0, 0.0), 2.0).Value();
        AdaptorGeom2Curve circle(c);
        ComputePointsAbscissa cpa(circle, 1.0, 0.0);
        double angle1 = l / r;
        std::cout << "" << ": " << angle1 << '\n';
        double x = r * cos(angle1);
        double y = r * sin(angle1);
        std::cout << "x" << ": " << x << '\n';
        std::cout << "y" << ": " << y << '\n';
        double param = cpa.Parameter();
        if (cpa.IsDone())
        {
            std::cout << param << ": " << circle.Value(param) << '\n';
        }
        double p = 2 * M_PI * r;
        std::cout << "" << ComputePointsAbscissa::Length(circle) << '\n';
        Point2 s = circle.Value(param);
        Point2 s1(x, y);
        std::cout << s << std::endl;
        CHECK(p == ComputePointsAbscissa::Length(circle));
        CHECK(angle1 == cpa.Parameter());
        CHECK(s.X() == s1.X());
        CHECK(s.Y() == s1.Y());
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API ComputePointsAbscissa(const Adaptor3Curve& c, double abscissa, double u0, double ui, double tol)	 @param tol The tolerance
	 @param ui The initial guess of the parameter
	 @param u0 The starting parameter
	 @param abscissa The arc length
	 @param c The curve
	 @brief Compute the parameter of a point on a 3D curve with given arc length, an initial guess, and a tolerance
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <geometry/MakeGeom2Circle.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/ComputePointsAbscissa.hpp>
#include <geometry/MakeGeom3Circle.hpp>
#include <geometry/AdaptorGeom3Curve.hpp>
#include <geometry/MakeGeom2Hyperbola.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/MakeGeom2Ellipse.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <geometry/MakeGeom3Ellipse.hpp>
#include <geometry/MakeGeom3Hyperbola.hpp>
#include <geometry/Geom2Line.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom3Line.hpp>
#include <geometry/Geom3TrimmedCurve.hpp>
#include<modeling/MakeEdge.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/GeometryTool.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <geometry/MakeGeom2Parabola.hpp>
#include <geometry/MakeGeom3Parabola.hpp>
#include <geometry/Geom2BezierCurve.hpp>
#include <geometry/Geom3BezierCurve.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/Geom2OffsetCurve.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
TEST_CASE("tset the parameters for calculating a point on a 3D curve of a given arc length and the length of the 3D curve.", "[geometry][ComputePointsAbscissa][case5]")
{
	SECTION("offset curve")
    {
        Frame3 frame;
        double r = 2.0;
        std::shared_ptr<Geom3Curve> c = MakeGeom3Circle(frame, r).Value();
        shared_ptr<Geom3OffsetCurve> curve;
        double offset = -1.0;
        Direction3 direction(0.0, 0.0, 1.0);
        curve = make_shared<Geom3OffsetCurve>(c, offset, direction);
        double r2 = r + offset;
        double p = 2 * M_PI * r2;
        double l = 2.0;
        AdaptorGeom3Curve offs(curve);
        ComputePointsAbscissa cpa8(offs, 2.0, 0.0);
        double angle1 = l / r2;
        std::cout << "" << ": " << angle1 << '\n';
        double x = r2 * cos(angle1);
        double y = r2 * sin(angle1);
        double z = 0.0;
        std::cout << "x" << ": " << x << '\n';
        std::cout << "y" << ": " << y << '\n';
        double param8 = cpa8.Parameter();
        if (cpa8.IsDone())
        {
            std::cout << param8 << ": " << offs.Value(param8) << '\n';
        }
        Point3 s = offs.Value(param8);
        Point3 s1(x, y, z);
        std::cout << s << std::endl;
        CHECK(s.X() == Approx(s1.X()).margin(1e-2));
        CHECK(s.Y() == Approx(s1.Y()).margin(1e-2));
        CHECK(s.Z() == Approx(s1.Z()).margin(1e-2));
        std::cout << "" << ComputePointsAbscissa::Length(offs) << '\n';
        CHECK(ComputePointsAbscissa::Length(offs) == Approx(p).margin(1e-2));
    }
}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API ComputePointsAbscissa(const Adaptor2Curve& c, double abscissa, double u0, double ui, double tol)	 @param tol The tolerance
	 @param ui The initial guess of the parameter
	 @param u0 The starting parameter
	 @param abscissa The arc length
	 @param c The curve
	 @brief Compute the parameter of a point on a 2D curve with given arc length, an initial guess, and a tolerance
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <geometry/MakeGeom2Circle.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/ComputePointsAbscissa.hpp>
#include <geometry/MakeGeom3Circle.hpp>
#include <geometry/AdaptorGeom3Curve.hpp>
#include <geometry/MakeGeom2Hyperbola.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/MakeGeom2Ellipse.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <geometry/MakeGeom3Ellipse.hpp>
#include <geometry/MakeGeom3Hyperbola.hpp>
#include <geometry/Geom2Line.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom3Line.hpp>
#include <geometry/Geom3TrimmedCurve.hpp>
#include<modeling/MakeEdge.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/GeometryTool.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <geometry/MakeGeom2Parabola.hpp>
#include <geometry/MakeGeom3Parabola.hpp>
#include <geometry/Geom2BezierCurve.hpp>
#include <geometry/Geom3BezierCurve.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/Geom2OffsetCurve.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
TEST_CASE("test the parameters for calculating a point on a 2D curve with a given arc length and the length of the 2D curve.", "[geometry][ComputePointsAbscissa][case1]")
{
	SECTION("circle")
    {
        double r = 2.0;
        double l = 1.0;
        std::shared_ptr<Geom2Curve> c = MakeGeom2Circle(Point2(0.0, 0.0), 2.0).Value();
        AdaptorGeom2Curve circle(c);
        ComputePointsAbscissa cpa(circle, 1.0, 0.0);
        double angle1 = l / r;
        std::cout << "" << ": " << angle1 << '\n';
        double x = r * cos(angle1);
        double y = r * sin(angle1);
        std::cout << "x" << ": " << x << '\n';
        std::cout << "y" << ": " << y << '\n';
        double param = cpa.Parameter();
        if (cpa.IsDone())
        {
            std::cout << param << ": " << circle.Value(param) << '\n';
        }
        double p = 2 * M_PI * r;
        std::cout << "" << ComputePointsAbscissa::Length(circle) << '\n';
        Point2 s = circle.Value(param);
        Point2 s1(x, y);
        std::cout << s << std::endl;
        CHECK(p == ComputePointsAbscissa::Length(circle));
        CHECK(angle1 == cpa.Parameter());
        CHECK(s.X() == s1.X());
        CHECK(s.Y() == s1.Y());
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API double Parameter()	 @return The parameter of the point
	 @brief Get the parameter of the point
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <geometry/MakeGeom2Circle.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/ComputePointsAbscissa.hpp>
#include <geometry/MakeGeom3Circle.hpp>
#include <geometry/AdaptorGeom3Curve.hpp>
#include <geometry/MakeGeom2Hyperbola.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/MakeGeom2Ellipse.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <geometry/MakeGeom3Ellipse.hpp>
#include <geometry/MakeGeom3Hyperbola.hpp>
#include <geometry/Geom2Line.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom3Line.hpp>
#include <geometry/Geom3TrimmedCurve.hpp>
#include<modeling/MakeEdge.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/GeometryTool.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <geometry/MakeGeom2Parabola.hpp>
#include <geometry/MakeGeom3Parabola.hpp>
#include <geometry/Geom2BezierCurve.hpp>
#include <geometry/Geom3BezierCurve.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/Geom2OffsetCurve.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
TEST_CASE("test the parameters for calculating a point on a 3D curve with a given arc length and tolerance, and the length of the 3D curve with tolerance.", "[geometry][ComputePointsAbscissa][case6]")
{
	SECTION("bezier")
    {
        std::vector<Point3> pts3 = {
       Point3(0.0, 0.0,0.0),
       Point3(2.0, 2.0,2.0),
       Point3(4.0, 3.0,5.0),
       Point3(6.0,2.0,4.0)
        };
        std::shared_ptr<Geom3BezierCurve> bez3 = make_shared<Geom3BezierCurve>(pts3);
        AdaptorGeom3Curve b2(bez3);
        ComputePointsAbscissa cpa6(Precision::Confusion(), b2, 2.0, 0.0);
        double param6 = cpa6.Parameter();
        if (cpa6.IsDone())
        {
            std::cout << param6 << ": " << b2.Value(param6) << '\n';
        }
        Point3 s7 = b2.Value(param6);
        std::cout << s7 << std::endl;
        CHECK(cpa6.Parameter() != 0);
        MakeEdge edge2(bez3);
        CHECK(BRepClassificationTools::IsPointInOnEdge(edge2, s7, 0.001) == true);
        std::cout << "" << ComputePointsAbscissa::Length(b2, Precision::Confusion()) << '\n';
        GlobalProperty props1;
        TopoShape result1 = MakeEdge(bez3);
        CHECK(GetLinearProperties(result1, props1, true, true) == Approx(ComputePointsAbscissa::Length(b2, Precision::Confusion())).margin(0.1));
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static double Length(const Adaptor3Curve& c, double tol)	 @return The length of a curve
	 @param tol The tolerance
	 @param c The curve
	 @brief Compute the length of a 3D curve with a tolerance
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <geometry/MakeGeom2Circle.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/ComputePointsAbscissa.hpp>
#include <geometry/MakeGeom3Circle.hpp>
#include <geometry/AdaptorGeom3Curve.hpp>
#include <geometry/MakeGeom2Hyperbola.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/MakeGeom2Ellipse.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <geometry/MakeGeom3Ellipse.hpp>
#include <geometry/MakeGeom3Hyperbola.hpp>
#include <geometry/Geom2Line.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom3Line.hpp>
#include <geometry/Geom3TrimmedCurve.hpp>
#include<modeling/MakeEdge.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/GeometryTool.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <geometry/MakeGeom2Parabola.hpp>
#include <geometry/MakeGeom3Parabola.hpp>
#include <geometry/Geom2BezierCurve.hpp>
#include <geometry/Geom3BezierCurve.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/Geom2OffsetCurve.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
TEST_CASE("test the parameters for calculating a point on a 3D curve with a given arc length and tolerance, and the length of the 3D curve with tolerance.", "[geometry][ComputePointsAbscissa][case6]")
{
	SECTION("ellipse")
    {
        Frame3 frame;
        double major = 5.0;
        double minor = 4.0;
        bool isRight = true;
        std::shared_ptr< Geom3Ellipse >g2e = MakeGeom3Ellipse(frame, major, minor);
        AdaptorGeom3Curve ellipse(g2e);
        double t = minor / major;
        std::cout << "t" << t << '\n';
        double T = 3.15129643210828;
        double L = T * (minor + major);
        std::cout << "L" << L << '\n';
        ComputePointsAbscissa cpa2(Precision::Confusion(), ellipse, L, 0.0);
        double param2 = cpa2.Parameter();
        if (cpa2.IsDone())
        {
            std::cout << param2 << ": " << ellipse.Value(param2) << '\n';
        }
        Point3 s2 = ellipse.Value(param2);
        Point3 s3(5.0, 0.0, 0.0);
        std::cout << s2 << std::endl;
        CHECK(s2.X() == Approx(s3.X()).margin(1e-2));
        CHECK(s2.Y() == Approx(s3.Y()).margin(1e-2));
        CHECK(s2.Z() == Approx(s3.Z()).margin(1e-2));
        std::cout << "" << ComputePointsAbscissa::Length(ellipse, Precision::Confusion()) << '\n';
        CHECK(ComputePointsAbscissa::Length(ellipse,Precision::Confusion()) == Approx(L).margin(1e-2));
        CHECK(cpa2.Parameter() == Approx(2 * M_PI).margin(1e-2));
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static double Length(const Adaptor2Curve& c, double tol)	 @return The length of a curve
	 @param tol The tolerance
	 @param c The curve
	 @brief Compute the length of a 2D curve with a tolerance
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <geometry/MakeGeom2Circle.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/ComputePointsAbscissa.hpp>
#include <geometry/MakeGeom3Circle.hpp>
#include <geometry/AdaptorGeom3Curve.hpp>
#include <geometry/MakeGeom2Hyperbola.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/MakeGeom2Ellipse.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <geometry/MakeGeom3Ellipse.hpp>
#include <geometry/MakeGeom3Hyperbola.hpp>
#include <geometry/Geom2Line.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom3Line.hpp>
#include <geometry/Geom3TrimmedCurve.hpp>
#include<modeling/MakeEdge.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/GeometryTool.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <geometry/MakeGeom2Parabola.hpp>
#include <geometry/MakeGeom3Parabola.hpp>
#include <geometry/Geom2BezierCurve.hpp>
#include <geometry/Geom3BezierCurve.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/Geom2OffsetCurve.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
TEST_CASE("test the calculation of the parameters of a point on a 2D curve for a given arc length, initial guess parameters and tolerances and the length of the 2D curve in a given interval, as well as the length of the 2D curve for a given interval and tolerances", "[geometry][ComputePointsAbscissa][case4]")
{
	SECTION("circle")
    {
        double r = 3.0;
        double l = 2.0;
        std::shared_ptr<Geom2Curve> c = MakeGeom2Circle(Point2(0.0, 0.0), 3.0).Value();
        AdaptorGeom2Curve circle(c);
        ComputePointsAbscissa cpa(circle, 2.0, 0.0, 1.5, Precision::Confusion());
        double angle1 = l / r;
        std::cout << "" << ": " << angle1 << '\n';
        double x = r * cos(angle1);
        double y = r * sin(angle1);
        std::cout << "x" << ": " << x << '\n';
        std::cout << "y" << ": " << y << '\n';
        double param = cpa.Parameter();
        if (cpa.IsDone())
        {
            std::cout << param << ": " << circle.Value(param) << '\n';
        }
        Point2 s = circle.Value(param);
        Point2 s1(x, y);
        std::cout << s << std::endl;
        CHECK(s.X() == s1.X());
        CHECK(s.Y() == s1.Y());
        std::cout << "" << ComputePointsAbscissa::Length(circle, 0.0, 0.666667) << '\n';
        std::cout << "" << ComputePointsAbscissa::Length(circle, 0.0, 0.666667, Precision::Confusion()) << '\n';
        CHECK(angle1 == cpa.Parameter());
        CHECK(ComputePointsAbscissa::Length(circle, 0.0, 0.6666666667) == Approx(l).margin(1e-2));
        CHECK(ComputePointsAbscissa::Length(circle, 0.0, 0.6666666667, Precision::Confusion()) == Approx(l).margin(1e-2));
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static double Length(const Adaptor3Curve& c, double u1, double u2)	 @return The length of a curve in a given interval
	 @param u2 The last parameter
	 @param u1 The first parameter
	 @param c The curve
	 @brief Compute the length of a 3D curve in a given interval
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <geometry/MakeGeom2Circle.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/ComputePointsAbscissa.hpp>
#include <geometry/MakeGeom3Circle.hpp>
#include <geometry/AdaptorGeom3Curve.hpp>
#include <geometry/MakeGeom2Hyperbola.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/MakeGeom2Ellipse.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <geometry/MakeGeom3Ellipse.hpp>
#include <geometry/MakeGeom3Hyperbola.hpp>
#include <geometry/Geom2Line.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom3Line.hpp>
#include <geometry/Geom3TrimmedCurve.hpp>
#include<modeling/MakeEdge.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/GeometryTool.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <geometry/MakeGeom2Parabola.hpp>
#include <geometry/MakeGeom3Parabola.hpp>
#include <geometry/Geom2BezierCurve.hpp>
#include <geometry/Geom3BezierCurve.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/Geom2OffsetCurve.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
TEST_CASE("tset the calculation of the parameters of a point on a 3D curve for a given arc length, initial guess parameters and tolerances and the length of the 3D curve within a given interval, as well as the length of the 3D curve for a given interval and tolerances", "[geometry][ComputePointsAbscissa][case8]")
{
	SECTION("line")
    {
        double t = 2.0;
        shared_ptr<Geom3Line> line;
        line = make_shared<Geom3Line>(Point3(0.0, 0.0, 0.0), Direction3(1.0, 2.0, 3.0));
        shared_ptr<Geom3TrimmedCurve> TrimmedCurve = make_shared<Geom3TrimmedCurve>(line, 0.0, 6.0);
        AdaptorGeom3Curve line1(TrimmedCurve);
        ComputePointsAbscissa cpa4(line1, 2.0, 0.0, 2.0, Precision::Confusion());
        double param4 = cpa4.Parameter();
        if (cpa4.IsDone())
        {
            std::cout << param4 << ": " << line1.Value(param4) << '\n';
        }
        Point3 start(0.0, 0.0, 0.0);
        Direction3 direction(1.0, 2.0, 3.0);
        double x = start.X() + t * direction.X();
        double y = start.Y() + t * direction.Y();
        double z = start.Z() + t * direction.Z();
        Point3 s5 = line1.Value(param4);
        Point3 s6(x, y, z);
        std::cout << s5 << std::endl;
        CHECK(cpa4.Parameter() == 2.0);
        CHECK(s5.X() == s6.X());
        CHECK(s5.Y() == s6.Y());
        CHECK(s5.Z() == s6.Z());
        std::cout << "" << ComputePointsAbscissa::Length(line1, 0.0, 2.0) << '\n';
        std::cout << "" << ComputePointsAbscissa::Length(line1, 0.0, 2.0, Precision::Confusion()) << '\n';
        CHECK(ComputePointsAbscissa::Length(line1, 0.0, 2.0) == 2.0);
        CHECK(ComputePointsAbscissa::Length(line1, 0.0, 2.0, Precision::Confusion()) == 2.0);
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static double Length(const Adaptor2Curve& c, double u1, double u2)	 @return The length of a curve in a given interval
	 @param u2 The last parameter
	 @param u1 The first parameter
	 @param c The curve
	 @brief Compute the length of a 2D curve in a given interval
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <geometry/MakeGeom2Circle.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/ComputePointsAbscissa.hpp>
#include <geometry/MakeGeom3Circle.hpp>
#include <geometry/AdaptorGeom3Curve.hpp>
#include <geometry/MakeGeom2Hyperbola.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/MakeGeom2Ellipse.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <geometry/MakeGeom3Ellipse.hpp>
#include <geometry/MakeGeom3Hyperbola.hpp>
#include <geometry/Geom2Line.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom3Line.hpp>
#include <geometry/Geom3TrimmedCurve.hpp>
#include<modeling/MakeEdge.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/GeometryTool.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <geometry/MakeGeom2Parabola.hpp>
#include <geometry/MakeGeom3Parabola.hpp>
#include <geometry/Geom2BezierCurve.hpp>
#include <geometry/Geom3BezierCurve.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/Geom2OffsetCurve.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
TEST_CASE("tset the calculation of the parameters of a point on a 3D curve for a given arc length, initial guess parameters and tolerances and the length of the 3D curve within a given interval, as well as the length of the 3D curve for a given interval and tolerances", "[geometry][ComputePointsAbscissa][case8]")
{
	SECTION("line")
    {
        double t = 2.0;
        shared_ptr<Geom3Line> line;
        line = make_shared<Geom3Line>(Point3(0.0, 0.0, 0.0), Direction3(1.0, 2.0, 3.0));
        shared_ptr<Geom3TrimmedCurve> TrimmedCurve = make_shared<Geom3TrimmedCurve>(line, 0.0, 6.0);
        AdaptorGeom3Curve line1(TrimmedCurve);
        ComputePointsAbscissa cpa4(line1, 2.0, 0.0, 2.0, Precision::Confusion());
        double param4 = cpa4.Parameter();
        if (cpa4.IsDone())
        {
            std::cout << param4 << ": " << line1.Value(param4) << '\n';
        }
        Point3 start(0.0, 0.0, 0.0);
        Direction3 direction(1.0, 2.0, 3.0);
        double x = start.X() + t * direction.X();
        double y = start.Y() + t * direction.Y();
        double z = start.Z() + t * direction.Z();
        Point3 s5 = line1.Value(param4);
        Point3 s6(x, y, z);
        std::cout << s5 << std::endl;
        CHECK(cpa4.Parameter() == 2.0);
        CHECK(s5.X() == s6.X());
        CHECK(s5.Y() == s6.Y());
        CHECK(s5.Z() == s6.Z());
        std::cout << "" << ComputePointsAbscissa::Length(line1, 0.0, 2.0) << '\n';
        std::cout << "" << ComputePointsAbscissa::Length(line1, 0.0, 2.0, Precision::Confusion()) << '\n';
        CHECK(ComputePointsAbscissa::Length(line1, 0.0, 2.0) == 2.0);
        CHECK(ComputePointsAbscissa::Length(line1, 0.0, 2.0, Precision::Confusion()) == 2.0);
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static double Length(const Adaptor3Curve& c, double u1, double u2, double tol)	 @return The length of a curve in a given interval
	 @param tol The tolerance
	 @param u2 The last parameter
	 @param u1 The first parameter
	 @param c The curve
	 @brief Compute the length of a 3D curve in a given interval with a tolerance
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <geometry/MakeGeom2Circle.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/ComputePointsAbscissa.hpp>
#include <geometry/MakeGeom3Circle.hpp>
#include <geometry/AdaptorGeom3Curve.hpp>
#include <geometry/MakeGeom2Hyperbola.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/MakeGeom2Ellipse.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <geometry/MakeGeom3Ellipse.hpp>
#include <geometry/MakeGeom3Hyperbola.hpp>
#include <geometry/Geom2Line.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom3Line.hpp>
#include <geometry/Geom3TrimmedCurve.hpp>
#include<modeling/MakeEdge.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/GeometryTool.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <geometry/MakeGeom2Parabola.hpp>
#include <geometry/MakeGeom3Parabola.hpp>
#include <geometry/Geom2BezierCurve.hpp>
#include <geometry/Geom3BezierCurve.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/Geom2OffsetCurve.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
TEST_CASE("test the calculation of the parameters of a point on a 2D curve for a given arc length, initial guess parameters and tolerances and the length of the 2D curve in a given interval, as well as the length of the 2D curve for a given interval and tolerances", "[geometry][ComputePointsAbscissa][case4]")
{
	SECTION("line")
    {
        shared_ptr<Geom2Line> line;
        line = make_shared<Geom2Line>(Point2(0.0, 0.0), Direction2(1.0, 0.0));
        shared_ptr<Geom2TrimmedCurve> TrimmedCurve = make_shared<Geom2TrimmedCurve>(line, 0.0, 6.0);
        AdaptorGeom2Curve line1(TrimmedCurve);
        ComputePointsAbscissa cpa4(line1, 2.0, 0.0, 2.0, Precision::Confusion());
        double param4 = cpa4.Parameter();
        if (cpa4.IsDone())
        {
            std::cout << param4 << ": " << line1.Value(param4) << '\n';
        }
        double x = 2.0;
        double y = 0.0;
        Point2 s5 = line1.Value(param4);
        Point2 s6(x, y);
        std::cout << s5 << std::endl;
        CHECK(cpa4.Parameter() == 2.0);
        CHECK(s5.X() == s6.X());
        CHECK(s5.Y() == s6.Y());
        std::cout << "" << ComputePointsAbscissa::Length(line1, 0.0, 2.0) << '\n';
        std::cout << "" << ComputePointsAbscissa::Length(line1, 0.0, 3.0, Precision::Confusion()) << '\n';
        CHECK(ComputePointsAbscissa::Length(line1, 0.0, 2.0) == 2.0);
        CHECK(ComputePointsAbscissa::Length(line1, 0.0, 3.0, Precision::Confusion()) == 3.0);
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static double Length(const Adaptor2Curve& c, double u1, double u2, double tol)	 @return The length of a curve in a given interval
	 @param tol The tolerance
	 @param u2 The last parameter
	 @param u1 The first parameter
	 @param c The curve
	 @brief Compute the length of a 2D curve in a given interval with a tolerance
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <geometry/MakeGeom2Circle.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/ComputePointsAbscissa.hpp>
#include <geometry/MakeGeom3Circle.hpp>
#include <geometry/AdaptorGeom3Curve.hpp>
#include <geometry/MakeGeom2Hyperbola.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/MakeGeom2Ellipse.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <geometry/MakeGeom3Ellipse.hpp>
#include <geometry/MakeGeom3Hyperbola.hpp>
#include <geometry/Geom2Line.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom3Line.hpp>
#include <geometry/Geom3TrimmedCurve.hpp>
#include<modeling/MakeEdge.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/GeometryTool.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <geometry/MakeGeom2Parabola.hpp>
#include <geometry/MakeGeom3Parabola.hpp>
#include <geometry/Geom2BezierCurve.hpp>
#include <geometry/Geom3BezierCurve.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/Geom2OffsetCurve.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
TEST_CASE("test the calculation of the parameters of a point on a 2D curve for a given arc length, initial guess parameters and tolerances and the length of the 2D curve in a given interval, as well as the length of the 2D curve for a given interval and tolerances", "[geometry][ComputePointsAbscissa][case4]")
{
	SECTION("circle")
    {
        double r = 3.0;
        double l = 2.0;
        std::shared_ptr<Geom2Curve> c = MakeGeom2Circle(Point2(0.0, 0.0), 3.0).Value();
        AdaptorGeom2Curve circle(c);
        ComputePointsAbscissa cpa(circle, 2.0, 0.0, 1.5, Precision::Confusion());
        double angle1 = l / r;
        std::cout << "" << ": " << angle1 << '\n';
        double x = r * cos(angle1);
        double y = r * sin(angle1);
        std::cout << "x" << ": " << x << '\n';
        std::cout << "y" << ": " << y << '\n';
        double param = cpa.Parameter();
        if (cpa.IsDone())
        {
            std::cout << param << ": " << circle.Value(param) << '\n';
        }
        Point2 s = circle.Value(param);
        Point2 s1(x, y);
        std::cout << s << std::endl;
        CHECK(s.X() == s1.X());
        CHECK(s.Y() == s1.Y());
        std::cout << "" << ComputePointsAbscissa::Length(circle, 0.0, 0.666667) << '\n';
        std::cout << "" << ComputePointsAbscissa::Length(circle, 0.0, 0.666667, Precision::Confusion()) << '\n';
        CHECK(angle1 == cpa.Parameter());
        CHECK(ComputePointsAbscissa::Length(circle, 0.0, 0.6666666667) == Approx(l).margin(1e-2));
        CHECK(ComputePointsAbscissa::Length(circle, 0.0, 0.6666666667, Precision::Confusion()) == Approx(l).margin(1e-2));
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API ComputePointsAbscissa(double tol, const Adaptor3Curve& c, double abscissa, double u0)	 @param u0 The starting parameter
	 @param abscissa The arc length
	 @param c The curve
	 @param tol The tolerance
	 @brief Compute the parameter of a point on a 3D curve with given arc length and a tolerance
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <geometry/MakeGeom2Circle.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/ComputePointsAbscissa.hpp>
#include <geometry/MakeGeom3Circle.hpp>
#include <geometry/AdaptorGeom3Curve.hpp>
#include <geometry/MakeGeom2Hyperbola.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/MakeGeom2Ellipse.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <geometry/MakeGeom3Ellipse.hpp>
#include <geometry/MakeGeom3Hyperbola.hpp>
#include <geometry/Geom2Line.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom3Line.hpp>
#include <geometry/Geom3TrimmedCurve.hpp>
#include<modeling/MakeEdge.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/GeometryTool.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <geometry/MakeGeom2Parabola.hpp>
#include <geometry/MakeGeom3Parabola.hpp>
#include <geometry/Geom2BezierCurve.hpp>
#include <geometry/Geom3BezierCurve.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/Geom2OffsetCurve.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
TEST_CASE("test the arc length is negative - given arc length - 2D", "[geometry][ComputePointsAbscissa][case9]")
{
	SECTION("circle")
    {
        double r = 2.0;
        double l = -1.0;
        std::shared_ptr<Geom2Curve> c = MakeGeom2Circle(Point2(0.0, 0.0), 2.0).Value();
        AdaptorGeom2Curve circle(c);
        ComputePointsAbscissa cpa(circle, -1.0, 0.0);
        double angle1 = l / r;
        double x = r * cos(angle1);
        double y = r * sin(angle1);
        double param = cpa.Parameter();
        Point2 s = circle.Value(param);
        Point2 s1(x, y);
        CHECK(angle1 == cpa.Parameter());
        CHECK(s.X() == s1.X());
        CHECK(s.Y() == s1.Y());
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API ComputePointsAbscissa(double tol, const Adaptor2Curve& c, double abscissa, double u0)	 @param u0 The starting parameter
	 @param abscissa The arc length
	 @param c The curve
	 @param tol The tolerance
	 @brief Compute the parameter of a point on a 2D curve with given arc length and a tolerance
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <geometry/MakeGeom2Circle.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/ComputePointsAbscissa.hpp>
#include <geometry/MakeGeom3Circle.hpp>
#include <geometry/AdaptorGeom3Curve.hpp>
#include <geometry/MakeGeom2Hyperbola.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/MakeGeom2Ellipse.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <geometry/MakeGeom3Ellipse.hpp>
#include <geometry/MakeGeom3Hyperbola.hpp>
#include <geometry/Geom2Line.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom3Line.hpp>
#include <geometry/Geom3TrimmedCurve.hpp>
#include<modeling/MakeEdge.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/GeometryTool.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <geometry/MakeGeom2Parabola.hpp>
#include <geometry/MakeGeom3Parabola.hpp>
#include <geometry/Geom2BezierCurve.hpp>
#include <geometry/Geom3BezierCurve.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/Geom2OffsetCurve.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
TEST_CASE("test the arc length is negative - given arc length - 2D", "[geometry][ComputePointsAbscissa][case9]")
{
	SECTION("circle")
    {
        double r = 2.0;
        double l = -1.0;
        std::shared_ptr<Geom2Curve> c = MakeGeom2Circle(Point2(0.0, 0.0), 2.0).Value();
        AdaptorGeom2Curve circle(c);
        ComputePointsAbscissa cpa(circle, -1.0, 0.0);
        double angle1 = l / r;
        double x = r * cos(angle1);
        double y = r * sin(angle1);
        double param = cpa.Parameter();
        Point2 s = circle.Value(param);
        Point2 s1(x, y);
        CHECK(angle1 == cpa.Parameter());
        CHECK(s.X() == s1.X());
        CHECK(s.Y() == s1.Y());
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API ComputePointsAbscissa(const Adaptor3Curve& c, double abscissa, double u0)	 @param u0 The starting parameter
	 @param abscissa The arc length
	 @param c The curve
	 @brief Compute the parameter of a point on a 3D curve with given arc length
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <geometry/MakeGeom2Circle.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/ComputePointsAbscissa.hpp>
#include <geometry/MakeGeom3Circle.hpp>
#include <geometry/AdaptorGeom3Curve.hpp>
#include <geometry/MakeGeom2Hyperbola.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/MakeGeom2Ellipse.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <geometry/MakeGeom3Ellipse.hpp>
#include <geometry/MakeGeom3Hyperbola.hpp>
#include <geometry/Geom2Line.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom3Line.hpp>
#include <geometry/Geom3TrimmedCurve.hpp>
#include<modeling/MakeEdge.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/GeometryTool.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <geometry/MakeGeom2Parabola.hpp>
#include <geometry/MakeGeom3Parabola.hpp>
#include <geometry/Geom2BezierCurve.hpp>
#include <geometry/Geom3BezierCurve.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/Geom2OffsetCurve.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
TEST_CASE("test the arc length is negative - given arc length - 2D", "[geometry][ComputePointsAbscissa][case9]")
{
	SECTION("circle")
    {
        double r = 2.0;
        double l = -1.0;
        std::shared_ptr<Geom2Curve> c = MakeGeom2Circle(Point2(0.0, 0.0), 2.0).Value();
        AdaptorGeom2Curve circle(c);
        ComputePointsAbscissa cpa(circle, -1.0, 0.0);
        double angle1 = l / r;
        double x = r * cos(angle1);
        double y = r * sin(angle1);
        double param = cpa.Parameter();
        Point2 s = circle.Value(param);
        Point2 s1(x, y);
        CHECK(angle1 == cpa.Parameter());
        CHECK(s.X() == s1.X());
        CHECK(s.Y() == s1.Y());
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API ComputePointsAbscissa(const Adaptor2Curve& c, double abscissa, double u0)	 @param u0 The starting parameter
	 @param abscissa The arc length
	 @param c The curve
	 @brief Compute the parameter of a point on a 2D curve with given arc length
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <geometry/MakeGeom2Circle.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/ComputePointsAbscissa.hpp>
#include <geometry/MakeGeom3Circle.hpp>
#include <geometry/AdaptorGeom3Curve.hpp>
#include <geometry/MakeGeom2Hyperbola.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/MakeGeom2Ellipse.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <geometry/MakeGeom3Ellipse.hpp>
#include <geometry/MakeGeom3Hyperbola.hpp>
#include <geometry/Geom2Line.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom3Line.hpp>
#include <geometry/Geom3TrimmedCurve.hpp>
#include<modeling/MakeEdge.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/GeometryTool.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <geometry/MakeGeom2Parabola.hpp>
#include <geometry/MakeGeom3Parabola.hpp>
#include <geometry/Geom2BezierCurve.hpp>
#include <geometry/Geom3BezierCurve.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/Geom2OffsetCurve.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
TEST_CASE("test the arc length is negative - given arc length - 2D", "[geometry][ComputePointsAbscissa][case9]")
{
	SECTION("circle")
    {
        double r = 2.0;
        double l = -1.0;
        std::shared_ptr<Geom2Curve> c = MakeGeom2Circle(Point2(0.0, 0.0), 2.0).Value();
        AdaptorGeom2Curve circle(c);
        ComputePointsAbscissa cpa(circle, -1.0, 0.0);
        double angle1 = l / r;
        double x = r * cos(angle1);
        double y = r * sin(angle1);
        double param = cpa.Parameter();
        Point2 s = circle.Value(param);
        Point2 s1(x, y);
        CHECK(angle1 == cpa.Parameter());
        CHECK(s.X() == s1.X());
        CHECK(s.Y() == s1.Y());
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API ComputePointsAbscissa(const Adaptor3Curve& c, double abscissa, double u0, double ui)	 @param ui The initial guess of the parameter
	 @param u0 The starting parameter
	 @param abscissa The arc length
	 @param c The curve
	 @brief Compute the parameter of a point on a 3D curve with given arc length and an initial guess
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <geometry/MakeGeom2Circle.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/ComputePointsAbscissa.hpp>
#include <geometry/MakeGeom3Circle.hpp>
#include <geometry/AdaptorGeom3Curve.hpp>
#include <geometry/MakeGeom2Hyperbola.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/MakeGeom2Ellipse.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <geometry/MakeGeom3Ellipse.hpp>
#include <geometry/MakeGeom3Hyperbola.hpp>
#include <geometry/Geom2Line.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom3Line.hpp>
#include <geometry/Geom3TrimmedCurve.hpp>
#include<modeling/MakeEdge.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/GeometryTool.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <geometry/MakeGeom2Parabola.hpp>
#include <geometry/MakeGeom3Parabola.hpp>
#include <geometry/Geom2BezierCurve.hpp>
#include <geometry/Geom3BezierCurve.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/Geom2OffsetCurve.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
TEST_CASE("test the arc length is negative - given arc length - 3D", "[geometry][ComputePointsAbscissa][case10]")
{
	SECTION("circle")
    {
        Frame3 frame;
        double r = 2.0;
        double l = -1.0;
        std::shared_ptr<Geom3Curve> c = MakeGeom3Circle(frame, r).Value();
        AdaptorGeom3Curve circle(c);
        ComputePointsAbscissa cpa(circle, -1.0, 0.0);
        double angle1 = l / r;
        double x = r * cos(angle1);
        double y = r * sin(angle1);
        double z = 0;
        double param = cpa.Parameter();
        Point3 s = circle.Value(param);
        Point3 s1(x, y, z);
        CHECK(angle1 == cpa.Parameter());
        CHECK(s.X() == s1.X());
        CHECK(s.Y() == s1.Y());
        CHECK(s.Z() == s1.Z());
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API ComputePointsAbscissa(const Adaptor2Curve& c, double abscissa, double u0, double ui)	 @param ui The initial guess of the parameter
	 @param u0 The starting parameter
	 @param abscissa The arc length
	 @param c The curve
	 @brief Compute the parameter of a point on a 2D curve with given arc length and an initial guess
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <geometry/MakeGeom2Circle.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/ComputePointsAbscissa.hpp>
#include <geometry/MakeGeom3Circle.hpp>
#include <geometry/AdaptorGeom3Curve.hpp>
#include <geometry/MakeGeom2Hyperbola.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/MakeGeom2Ellipse.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <geometry/MakeGeom3Ellipse.hpp>
#include <geometry/MakeGeom3Hyperbola.hpp>
#include <geometry/Geom2Line.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom3Line.hpp>
#include <geometry/Geom3TrimmedCurve.hpp>
#include<modeling/MakeEdge.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/GeometryTool.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <geometry/MakeGeom2Parabola.hpp>
#include <geometry/MakeGeom3Parabola.hpp>
#include <geometry/Geom2BezierCurve.hpp>
#include <geometry/Geom3BezierCurve.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/Geom2OffsetCurve.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
TEST_CASE("test the arc length is negative - given arc length - 2D", "[geometry][ComputePointsAbscissa][case9]")
{
	SECTION("circle")
    {
        double r = 2.0;
        double l = -1.0;
        std::shared_ptr<Geom2Curve> c = MakeGeom2Circle(Point2(0.0, 0.0), 2.0).Value();
        AdaptorGeom2Curve circle(c);
        ComputePointsAbscissa cpa(circle, -1.0, 0.0);
        double angle1 = l / r;
        double x = r * cos(angle1);
        double y = r * sin(angle1);
        double param = cpa.Parameter();
        Point2 s = circle.Value(param);
        Point2 s1(x, y);
        CHECK(angle1 == cpa.Parameter());
        CHECK(s.X() == s1.X());
        CHECK(s.Y() == s1.Y());
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API ComputePointsAbscissa(const Adaptor3Curve& c, double abscissa, double u0, double ui, double tol)	 @param tol The tolerance
	 @param ui The initial guess of the parameter
	 @param u0 The starting parameter
	 @param abscissa The arc length
	 @param c The curve
	 @brief Compute the parameter of a point on a 3D curve with given arc length, an initial guess, and a tolerance
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <geometry/MakeGeom2Circle.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/ComputePointsAbscissa.hpp>
#include <geometry/MakeGeom3Circle.hpp>
#include <geometry/AdaptorGeom3Curve.hpp>
#include <geometry/MakeGeom2Hyperbola.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/MakeGeom2Ellipse.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <geometry/MakeGeom3Ellipse.hpp>
#include <geometry/MakeGeom3Hyperbola.hpp>
#include <geometry/Geom2Line.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom3Line.hpp>
#include <geometry/Geom3TrimmedCurve.hpp>
#include<modeling/MakeEdge.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/GeometryTool.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <geometry/MakeGeom2Parabola.hpp>
#include <geometry/MakeGeom3Parabola.hpp>
#include <geometry/Geom2BezierCurve.hpp>
#include <geometry/Geom3BezierCurve.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/Geom2OffsetCurve.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
TEST_CASE("test the arc length is negative - given arc length - 3D", "[geometry][ComputePointsAbscissa][case10]")
{
	SECTION("line")
    {
        double t = -2.0;
        shared_ptr<Geom3Line> line;
        line = make_shared<Geom3Line>(Point3(0.0, 0.0, 0.0), Direction3(1.0, 2.0, 3.0));
        shared_ptr<Geom3TrimmedCurve> TrimmedCurve = make_shared<Geom3TrimmedCurve>(line, 0.0, 6.0);
        AdaptorGeom3Curve line1(TrimmedCurve);
        ComputePointsAbscissa cpa4(line1, -2.0, 0.0);
        double param4 = cpa4.Parameter();
        Point3 start(0.0, 0.0, 0.0);
        Direction3 direction(1.0, 2.0, 3.0);
        double x = start.X() + t * direction.X();
        double y = start.Y() + t * direction.Y();
        double z = start.Z() + t * direction.Z();
        Point3 s5 = line1.Value(param4);
        Point3 s6(x, y, z);
        CHECK(cpa4.Parameter() == -2.0);
        CHECK(s5.X() == s6.X());
        CHECK(s5.Y() == s6.Y());
        CHECK(s5.Z() == s6.Z());
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API ComputePointsAbscissa(const Adaptor2Curve& c, double abscissa, double u0, double ui, double tol)	 @param tol The tolerance
	 @param ui The initial guess of the parameter
	 @param u0 The starting parameter
	 @param abscissa The arc length
	 @param c The curve
	 @brief Compute the parameter of a point on a 2D curve with given arc length, an initial guess, and a tolerance
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <geometry/MakeGeom2Circle.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/ComputePointsAbscissa.hpp>
#include <geometry/MakeGeom3Circle.hpp>
#include <geometry/AdaptorGeom3Curve.hpp>
#include <geometry/MakeGeom2Hyperbola.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/MakeGeom2Ellipse.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <geometry/MakeGeom3Ellipse.hpp>
#include <geometry/MakeGeom3Hyperbola.hpp>
#include <geometry/Geom2Line.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom3Line.hpp>
#include <geometry/Geom3TrimmedCurve.hpp>
#include<modeling/MakeEdge.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/GeometryTool.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <geometry/MakeGeom2Parabola.hpp>
#include <geometry/MakeGeom3Parabola.hpp>
#include <geometry/Geom2BezierCurve.hpp>
#include <geometry/Geom3BezierCurve.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/Geom2OffsetCurve.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
TEST_CASE("test the arc length is negative - given arc length - 2D", "[geometry][ComputePointsAbscissa][case9]")
{
	SECTION("circle")
    {
        double r = 2.0;
        double l = -1.0;
        std::shared_ptr<Geom2Curve> c = MakeGeom2Circle(Point2(0.0, 0.0), 2.0).Value();
        AdaptorGeom2Curve circle(c);
        ComputePointsAbscissa cpa(circle, -1.0, 0.0);
        double angle1 = l / r;
        double x = r * cos(angle1);
        double y = r * sin(angle1);
        double param = cpa.Parameter();
        Point2 s = circle.Value(param);
        Point2 s1(x, y);
        CHECK(angle1 == cpa.Parameter());
        CHECK(s.X() == s1.X());
        CHECK(s.Y() == s1.Y());
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API double Parameter()	 @return The parameter of the point
	 @brief Get the parameter of the point
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <geometry/MakeGeom2Circle.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/ComputePointsAbscissa.hpp>
#include <geometry/MakeGeom3Circle.hpp>
#include <geometry/AdaptorGeom3Curve.hpp>
#include <geometry/MakeGeom2Hyperbola.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/MakeGeom2Ellipse.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <geometry/MakeGeom3Ellipse.hpp>
#include <geometry/MakeGeom3Hyperbola.hpp>
#include <geometry/Geom2Line.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom3Line.hpp>
#include <geometry/Geom3TrimmedCurve.hpp>
#include<modeling/MakeEdge.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/GeometryTool.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <geometry/MakeGeom2Parabola.hpp>
#include <geometry/MakeGeom3Parabola.hpp>
#include <geometry/Geom2BezierCurve.hpp>
#include <geometry/Geom3BezierCurve.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/Geom2OffsetCurve.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
TEST_CASE("test the arc length is negative - given arc length - 2D", "[geometry][ComputePointsAbscissa][case9]")
{
	SECTION("circle")
    {
        double r = 2.0;
        double l = -1.0;
        std::shared_ptr<Geom2Curve> c = MakeGeom2Circle(Point2(0.0, 0.0), 2.0).Value();
        AdaptorGeom2Curve circle(c);
        ComputePointsAbscissa cpa(circle, -1.0, 0.0);
        double angle1 = l / r;
        double x = r * cos(angle1);
        double y = r * sin(angle1);
        double param = cpa.Parameter();
        Point2 s = circle.Value(param);
        Point2 s1(x, y);
        CHECK(angle1 == cpa.Parameter());
        CHECK(s.X() == s1.X());
        CHECK(s.Y() == s1.Y());
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API ComputePointsAbscissa(double tol, const Adaptor3Curve& c, double abscissa, double u0)	 @param u0 The starting parameter
	 @param abscissa The arc length
	 @param c The curve
	 @param tol The tolerance
	 @brief Compute the parameter of a point on a 3D curve with given arc length and a tolerance
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <geometry/MakeGeom2Circle.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/ComputePointsAbscissa.hpp>
#include <geometry/MakeGeom3Circle.hpp>
#include <geometry/AdaptorGeom3Curve.hpp>
#include <geometry/MakeGeom2Hyperbola.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/MakeGeom2Ellipse.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <geometry/MakeGeom3Ellipse.hpp>
#include <geometry/MakeGeom3Hyperbola.hpp>
#include <geometry/Geom2Line.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom3Line.hpp>
#include <geometry/Geom3TrimmedCurve.hpp>
#include<modeling/MakeEdge.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/GeometryTool.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <geometry/MakeGeom2Parabola.hpp>
#include <geometry/MakeGeom3Parabola.hpp>
#include <geometry/Geom2BezierCurve.hpp>
#include <geometry/Geom3BezierCurve.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/Geom2OffsetCurve.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
TEST_CASE("test the arc length parameter over the total length of the curve - given arc length - 2D", "[geometry][ComputePointsAbscissa][case18]")
{
	SECTION("line")
    {
        shared_ptr<Geom2Line> line;
        line = make_shared<Geom2Line>(Point2(0.0, 0.0), Direction2(1.0, 0.0));
        shared_ptr<Geom2TrimmedCurve> TrimmedCurve = make_shared<Geom2TrimmedCurve>(line, 0.0, 6.0);
        AdaptorGeom2Curve line1(TrimmedCurve);
        ComputePointsAbscissa cpa4(line1, 8.0, 0.0);
        double param4 = cpa4.Parameter();
        double x = 8.0;
        double y = 0.0;
        Point2 s5 = line1.Value(param4);
        Point2 s6(x, y);
        CHECK(cpa4.Parameter() == 8.0);
        CHECK(s5.X() == s6.X());
        CHECK(s5.Y() == s6.Y());
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API ComputePointsAbscissa(double tol, const Adaptor2Curve& c, double abscissa, double u0)	 @param u0 The starting parameter
	 @param abscissa The arc length
	 @param c The curve
	 @param tol The tolerance
	 @brief Compute the parameter of a point on a 2D curve with given arc length and a tolerance
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <geometry/MakeGeom2Circle.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/ComputePointsAbscissa.hpp>
#include <geometry/MakeGeom3Circle.hpp>
#include <geometry/AdaptorGeom3Curve.hpp>
#include <geometry/MakeGeom2Hyperbola.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/MakeGeom2Ellipse.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <geometry/MakeGeom3Ellipse.hpp>
#include <geometry/MakeGeom3Hyperbola.hpp>
#include <geometry/Geom2Line.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom3Line.hpp>
#include <geometry/Geom3TrimmedCurve.hpp>
#include<modeling/MakeEdge.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/GeometryTool.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <geometry/MakeGeom2Parabola.hpp>
#include <geometry/MakeGeom3Parabola.hpp>
#include <geometry/Geom2BezierCurve.hpp>
#include <geometry/Geom3BezierCurve.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/Geom2OffsetCurve.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
TEST_CASE("test the arc length parameter over the total length of the curve - given arc length - 2D", "[geometry][ComputePointsAbscissa][case18]")
{
	SECTION("circle")
    {
        double r = 2.0;
        double l = 19;
        std::shared_ptr<Geom2Curve> c = MakeGeom2Circle(Point2(0.0, 0.0), 2.0).Value();
        AdaptorGeom2Curve circle(c);
        ComputePointsAbscissa cpa(circle, l, 0.0);
        double angle1 = l / r;
        double x = r * cos(angle1);
        double y = r * sin(angle1);
        double param = cpa.Parameter();
        Point2 s = circle.Value(param);
        Point2 s1(x, y);
        CHECK(angle1 == cpa.Parameter());
        CHECK(s.X() == s1.X());
        CHECK(s.Y() == s1.Y());
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API ComputePointsAbscissa(const Adaptor3Curve& c, double abscissa, double u0)	 @param u0 The starting parameter
	 @param abscissa The arc length
	 @param c The curve
	 @brief Compute the parameter of a point on a 3D curve with given arc length
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <geometry/MakeGeom2Circle.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/ComputePointsAbscissa.hpp>
#include <geometry/MakeGeom3Circle.hpp>
#include <geometry/AdaptorGeom3Curve.hpp>
#include <geometry/MakeGeom2Hyperbola.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/MakeGeom2Ellipse.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <geometry/MakeGeom3Ellipse.hpp>
#include <geometry/MakeGeom3Hyperbola.hpp>
#include <geometry/Geom2Line.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom3Line.hpp>
#include <geometry/Geom3TrimmedCurve.hpp>
#include<modeling/MakeEdge.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/GeometryTool.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <geometry/MakeGeom2Parabola.hpp>
#include <geometry/MakeGeom3Parabola.hpp>
#include <geometry/Geom2BezierCurve.hpp>
#include <geometry/Geom3BezierCurve.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/Geom2OffsetCurve.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
TEST_CASE("test the arc length parameter over the total length of the curve - given arc length - 3D", "[geometry][ComputePointsAbscissa][case19]")
{
	SECTION("circle")
    {
        Frame3 frame;
        double r = 2.0;
        double l = 13;
        std::shared_ptr<Geom3Curve> c = MakeGeom3Circle(frame, r).Value();
        AdaptorGeom3Curve circle(c);
        ComputePointsAbscissa cpa(circle, 13, 0.0);
        double angle1 = l / r;
        double x = r * cos(angle1);
        double y = r * sin(angle1);
        double z = 0;
        double param = cpa.Parameter();
        Point3 s = circle.Value(param);
        Point3 s1(x, y, z);
        CHECK(angle1 == cpa.Parameter());
        CHECK(s.X() == s1.X());
        CHECK(s.Y() == s1.Y());
        CHECK(s.Z() == s1.Z());
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API ComputePointsAbscissa(const Adaptor2Curve& c, double abscissa, double u0)	 @param u0 The starting parameter
	 @param abscissa The arc length
	 @param c The curve
	 @brief Compute the parameter of a point on a 2D curve with given arc length
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <geometry/MakeGeom2Circle.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/ComputePointsAbscissa.hpp>
#include <geometry/MakeGeom3Circle.hpp>
#include <geometry/AdaptorGeom3Curve.hpp>
#include <geometry/MakeGeom2Hyperbola.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/MakeGeom2Ellipse.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <geometry/MakeGeom3Ellipse.hpp>
#include <geometry/MakeGeom3Hyperbola.hpp>
#include <geometry/Geom2Line.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom3Line.hpp>
#include <geometry/Geom3TrimmedCurve.hpp>
#include<modeling/MakeEdge.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/GeometryTool.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <geometry/MakeGeom2Parabola.hpp>
#include <geometry/MakeGeom3Parabola.hpp>
#include <geometry/Geom2BezierCurve.hpp>
#include <geometry/Geom3BezierCurve.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/Geom2OffsetCurve.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
TEST_CASE("test the arc length parameter over the total length of the curve - given arc length - 2D", "[geometry][ComputePointsAbscissa][case18]")
{
	SECTION("circle")
    {
        double r = 2.0;
        double l = 19;
        std::shared_ptr<Geom2Curve> c = MakeGeom2Circle(Point2(0.0, 0.0), 2.0).Value();
        AdaptorGeom2Curve circle(c);
        ComputePointsAbscissa cpa(circle, l, 0.0);
        double angle1 = l / r;
        double x = r * cos(angle1);
        double y = r * sin(angle1);
        double param = cpa.Parameter();
        Point2 s = circle.Value(param);
        Point2 s1(x, y);
        CHECK(angle1 == cpa.Parameter());
        CHECK(s.X() == s1.X());
        CHECK(s.Y() == s1.Y());
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API ComputePointsAbscissa(const Adaptor3Curve& c, double abscissa, double u0, double ui)	 @param ui The initial guess of the parameter
	 @param u0 The starting parameter
	 @param abscissa The arc length
	 @param c The curve
	 @brief Compute the parameter of a point on a 3D curve with given arc length and an initial guess
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <geometry/MakeGeom2Circle.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/ComputePointsAbscissa.hpp>
#include <geometry/MakeGeom3Circle.hpp>
#include <geometry/AdaptorGeom3Curve.hpp>
#include <geometry/MakeGeom2Hyperbola.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/MakeGeom2Ellipse.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <geometry/MakeGeom3Ellipse.hpp>
#include <geometry/MakeGeom3Hyperbola.hpp>
#include <geometry/Geom2Line.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom3Line.hpp>
#include <geometry/Geom3TrimmedCurve.hpp>
#include<modeling/MakeEdge.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/GeometryTool.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <geometry/MakeGeom2Parabola.hpp>
#include <geometry/MakeGeom3Parabola.hpp>
#include <geometry/Geom2BezierCurve.hpp>
#include <geometry/Geom3BezierCurve.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/Geom2OffsetCurve.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
TEST_CASE("test the arc length parameter over the total length of the curve - given arc length - 2D", "[geometry][ComputePointsAbscissa][case18]")
{
	SECTION("line")
    {
        shared_ptr<Geom2Line> line;
        line = make_shared<Geom2Line>(Point2(0.0, 0.0), Direction2(1.0, 0.0));
        shared_ptr<Geom2TrimmedCurve> TrimmedCurve = make_shared<Geom2TrimmedCurve>(line, 0.0, 6.0);
        AdaptorGeom2Curve line1(TrimmedCurve);
        ComputePointsAbscissa cpa4(line1, 8.0, 0.0);
        double param4 = cpa4.Parameter();
        double x = 8.0;
        double y = 0.0;
        Point2 s5 = line1.Value(param4);
        Point2 s6(x, y);
        CHECK(cpa4.Parameter() == 8.0);
        CHECK(s5.X() == s6.X());
        CHECK(s5.Y() == s6.Y());
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API ComputePointsAbscissa(const Adaptor2Curve& c, double abscissa, double u0, double ui)	 @param ui The initial guess of the parameter
	 @param u0 The starting parameter
	 @param abscissa The arc length
	 @param c The curve
	 @brief Compute the parameter of a point on a 2D curve with given arc length and an initial guess
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <geometry/MakeGeom2Circle.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/ComputePointsAbscissa.hpp>
#include <geometry/MakeGeom3Circle.hpp>
#include <geometry/AdaptorGeom3Curve.hpp>
#include <geometry/MakeGeom2Hyperbola.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/MakeGeom2Ellipse.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <geometry/MakeGeom3Ellipse.hpp>
#include <geometry/MakeGeom3Hyperbola.hpp>
#include <geometry/Geom2Line.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom3Line.hpp>
#include <geometry/Geom3TrimmedCurve.hpp>
#include<modeling/MakeEdge.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/GeometryTool.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <geometry/MakeGeom2Parabola.hpp>
#include <geometry/MakeGeom3Parabola.hpp>
#include <geometry/Geom2BezierCurve.hpp>
#include <geometry/Geom3BezierCurve.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/Geom2OffsetCurve.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
TEST_CASE("test the arc length parameter over the total length of the curve - given arc length - 2D", "[geometry][ComputePointsAbscissa][case18]")
{
	SECTION("circle")
    {
        double r = 2.0;
        double l = 19;
        std::shared_ptr<Geom2Curve> c = MakeGeom2Circle(Point2(0.0, 0.0), 2.0).Value();
        AdaptorGeom2Curve circle(c);
        ComputePointsAbscissa cpa(circle, l, 0.0);
        double angle1 = l / r;
        double x = r * cos(angle1);
        double y = r * sin(angle1);
        double param = cpa.Parameter();
        Point2 s = circle.Value(param);
        Point2 s1(x, y);
        CHECK(angle1 == cpa.Parameter());
        CHECK(s.X() == s1.X());
        CHECK(s.Y() == s1.Y());
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API ComputePointsAbscissa(const Adaptor3Curve& c, double abscissa, double u0, double ui, double tol)	 @param tol The tolerance
	 @param ui The initial guess of the parameter
	 @param u0 The starting parameter
	 @param abscissa The arc length
	 @param c The curve
	 @brief Compute the parameter of a point on a 3D curve with given arc length, an initial guess, and a tolerance
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <geometry/MakeGeom2Circle.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/ComputePointsAbscissa.hpp>
#include <geometry/MakeGeom3Circle.hpp>
#include <geometry/AdaptorGeom3Curve.hpp>
#include <geometry/MakeGeom2Hyperbola.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/MakeGeom2Ellipse.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <geometry/MakeGeom3Ellipse.hpp>
#include <geometry/MakeGeom3Hyperbola.hpp>
#include <geometry/Geom2Line.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom3Line.hpp>
#include <geometry/Geom3TrimmedCurve.hpp>
#include<modeling/MakeEdge.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/GeometryTool.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <geometry/MakeGeom2Parabola.hpp>
#include <geometry/MakeGeom3Parabola.hpp>
#include <geometry/Geom2BezierCurve.hpp>
#include <geometry/Geom3BezierCurve.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/Geom2OffsetCurve.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
TEST_CASE("test the arc length parameter over the total length of the curve - given arc length - 3D", "[geometry][ComputePointsAbscissa][case19]")
{
	SECTION("circle")
    {
        Frame3 frame;
        double r = 2.0;
        double l = 13;
        std::shared_ptr<Geom3Curve> c = MakeGeom3Circle(frame, r).Value();
        AdaptorGeom3Curve circle(c);
        ComputePointsAbscissa cpa(circle, 13, 0.0);
        double angle1 = l / r;
        double x = r * cos(angle1);
        double y = r * sin(angle1);
        double z = 0;
        double param = cpa.Parameter();
        Point3 s = circle.Value(param);
        Point3 s1(x, y, z);
        CHECK(angle1 == cpa.Parameter());
        CHECK(s.X() == s1.X());
        CHECK(s.Y() == s1.Y());
        CHECK(s.Z() == s1.Z());
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API ComputePointsAbscissa(const Adaptor2Curve& c, double abscissa, double u0, double ui, double tol)	 @param tol The tolerance
	 @param ui The initial guess of the parameter
	 @param u0 The starting parameter
	 @param abscissa The arc length
	 @param c The curve
	 @brief Compute the parameter of a point on a 2D curve with given arc length, an initial guess, and a tolerance
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <geometry/MakeGeom2Circle.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/ComputePointsAbscissa.hpp>
#include <geometry/MakeGeom3Circle.hpp>
#include <geometry/AdaptorGeom3Curve.hpp>
#include <geometry/MakeGeom2Hyperbola.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/MakeGeom2Ellipse.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <geometry/MakeGeom3Ellipse.hpp>
#include <geometry/MakeGeom3Hyperbola.hpp>
#include <geometry/Geom2Line.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom3Line.hpp>
#include <geometry/Geom3TrimmedCurve.hpp>
#include<modeling/MakeEdge.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/GeometryTool.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <geometry/MakeGeom2Parabola.hpp>
#include <geometry/MakeGeom3Parabola.hpp>
#include <geometry/Geom2BezierCurve.hpp>
#include <geometry/Geom3BezierCurve.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/Geom2OffsetCurve.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
TEST_CASE("test the arc length parameter over the total length of the curve - given arc length - 2D", "[geometry][ComputePointsAbscissa][case18]")
{
	SECTION("circle")
    {
        double r = 2.0;
        double l = 19;
        std::shared_ptr<Geom2Curve> c = MakeGeom2Circle(Point2(0.0, 0.0), 2.0).Value();
        AdaptorGeom2Curve circle(c);
        ComputePointsAbscissa cpa(circle, l, 0.0);
        double angle1 = l / r;
        double x = r * cos(angle1);
        double y = r * sin(angle1);
        double param = cpa.Parameter();
        Point2 s = circle.Value(param);
        Point2 s1(x, y);
        CHECK(angle1 == cpa.Parameter());
        CHECK(s.X() == s1.X());
        CHECK(s.Y() == s1.Y());
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API double Parameter()	 @return The parameter of the point
	 @brief Get the parameter of the point
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <geometry/MakeGeom2Circle.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/ComputePointsAbscissa.hpp>
#include <geometry/MakeGeom3Circle.hpp>
#include <geometry/AdaptorGeom3Curve.hpp>
#include <geometry/MakeGeom2Hyperbola.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/MakeGeom2Ellipse.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <geometry/MakeGeom3Ellipse.hpp>
#include <geometry/MakeGeom3Hyperbola.hpp>
#include <geometry/Geom2Line.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom3Line.hpp>
#include <geometry/Geom3TrimmedCurve.hpp>
#include<modeling/MakeEdge.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/GeometryTool.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <geometry/MakeGeom2Parabola.hpp>
#include <geometry/MakeGeom3Parabola.hpp>
#include <geometry/Geom2BezierCurve.hpp>
#include <geometry/Geom3BezierCurve.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/Geom2OffsetCurve.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
TEST_CASE("test the arc length parameter over the total length of the curve - given arc length - 2D", "[geometry][ComputePointsAbscissa][case18]")
{
	SECTION("circle")
    {
        double r = 2.0;
        double l = 19;
        std::shared_ptr<Geom2Curve> c = MakeGeom2Circle(Point2(0.0, 0.0), 2.0).Value();
        AdaptorGeom2Curve circle(c);
        ComputePointsAbscissa cpa(circle, l, 0.0);
        double angle1 = l / r;
        double x = r * cos(angle1);
        double y = r * sin(angle1);
        double param = cpa.Parameter();
        Point2 s = circle.Value(param);
        Point2 s1(x, y);
        CHECK(angle1 == cpa.Parameter());
        CHECK(s.X() == s1.X());
        CHECK(s.Y() == s1.Y());
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static double Length(const Adaptor3Curve& c, double u1, double u2, double tol)	 @return The length of a curve in a given interval
	 @param tol The tolerance
	 @param u2 The last parameter
	 @param u1 The first parameter
	 @param c The curve
	 @brief Compute the length of a 3D curve in a given interval with a tolerance
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <geometry/MakeGeom2Circle.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/ComputePointsAbscissa.hpp>
#include <geometry/MakeGeom3Circle.hpp>
#include <geometry/AdaptorGeom3Curve.hpp>
#include <geometry/MakeGeom2Hyperbola.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/MakeGeom2Ellipse.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <geometry/MakeGeom3Ellipse.hpp>
#include <geometry/MakeGeom3Hyperbola.hpp>
#include <geometry/Geom2Line.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom3Line.hpp>
#include <geometry/Geom3TrimmedCurve.hpp>
#include<modeling/MakeEdge.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/GeometryTool.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <geometry/MakeGeom2Parabola.hpp>
#include <geometry/MakeGeom3Parabola.hpp>
#include <geometry/Geom2BezierCurve.hpp>
#include <geometry/Geom3BezierCurve.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/Geom2OffsetCurve.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
TEST_CASE("test the arc length parameter over the total length of the curve - given arc length - 3D", "[geometry][ComputePointsAbscissa][case19]")
{
	SECTION("circle")
    {
        Frame3 frame;
        double r = 2.0;
        double l = 13;
        std::shared_ptr<Geom3Curve> c = MakeGeom3Circle(frame, r).Value();
        AdaptorGeom3Curve circle(c);
        ComputePointsAbscissa cpa(circle, 13, 0.0);
        double angle1 = l / r;
        double x = r * cos(angle1);
        double y = r * sin(angle1);
        double z = 0;
        double param = cpa.Parameter();
        Point3 s = circle.Value(param);
        Point3 s1(x, y, z);
        CHECK(angle1 == cpa.Parameter());
        CHECK(s.X() == s1.X());
        CHECK(s.Y() == s1.Y());
        CHECK(s.Z() == s1.Z());
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API ComputePointsAbscissa(double tol, const Adaptor3Curve& c, double abscissa, double u0)	 @param u0 The starting parameter
	 @param abscissa The arc length
	 @param c The curve
	 @param tol The tolerance
	 @brief Compute the parameter of a point on a 3D curve with given arc length and a tolerance
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <geometry/MakeGeom2Circle.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/ComputePointsAbscissa.hpp>
#include <geometry/MakeGeom3Circle.hpp>
#include <geometry/AdaptorGeom3Curve.hpp>
#include <geometry/MakeGeom2Hyperbola.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/MakeGeom2Ellipse.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <geometry/MakeGeom3Ellipse.hpp>
#include <geometry/MakeGeom3Hyperbola.hpp>
#include <geometry/Geom2Line.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom3Line.hpp>
#include <geometry/Geom3TrimmedCurve.hpp>
#include<modeling/MakeEdge.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/GeometryTool.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <geometry/MakeGeom2Parabola.hpp>
#include <geometry/MakeGeom3Parabola.hpp>
#include <geometry/Geom2BezierCurve.hpp>
#include <geometry/Geom3BezierCurve.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/Geom2OffsetCurve.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
TEST_CASE("test that the arc length is 0 - given arc length - 3D", "[geometry][ComputePointsAbscissa][case27]")
{
	SECTION("circle")
    {
        Frame3 frame;
        double r = 2.0;
        double l = 0.0;
        std::shared_ptr<Geom3Curve> c = MakeGeom3Circle(frame, r).Value();
        AdaptorGeom3Curve circle(c);
        ComputePointsAbscissa cpa(circle, 0.0, 0.0);
        double angle1 = l / r;
        double x = r * cos(angle1);
        double y = r * sin(angle1);
        double z = 0;
        double param = cpa.Parameter();
        Point3 s = circle.Value(param);
        Point3 s1(x, y, z);
        CHECK(angle1 == cpa.Parameter());
        CHECK(s.X() == s1.X());
        CHECK(s.Y() == s1.Y());
        CHECK(s.Z() == s1.Z());
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API ComputePointsAbscissa(double tol, const Adaptor2Curve& c, double abscissa, double u0)	 @param u0 The starting parameter
	 @param abscissa The arc length
	 @param c The curve
	 @param tol The tolerance
	 @brief Compute the parameter of a point on a 2D curve with given arc length and a tolerance
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <geometry/MakeGeom2Circle.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/ComputePointsAbscissa.hpp>
#include <geometry/MakeGeom3Circle.hpp>
#include <geometry/AdaptorGeom3Curve.hpp>
#include <geometry/MakeGeom2Hyperbola.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/MakeGeom2Ellipse.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <geometry/MakeGeom3Ellipse.hpp>
#include <geometry/MakeGeom3Hyperbola.hpp>
#include <geometry/Geom2Line.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom3Line.hpp>
#include <geometry/Geom3TrimmedCurve.hpp>
#include<modeling/MakeEdge.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/GeometryTool.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <geometry/MakeGeom2Parabola.hpp>
#include <geometry/MakeGeom3Parabola.hpp>
#include <geometry/Geom2BezierCurve.hpp>
#include <geometry/Geom3BezierCurve.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/Geom2OffsetCurve.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
TEST_CASE("test that the arc length is 0 - given arc length - 2D", "[geometry][ComputePointsAbscissa][case26]")
{
	SECTION("circle")
    {
        double r = 2.0;
        double l = 0.0;
        std::shared_ptr<Geom2Curve> c = MakeGeom2Circle(Point2(0.0, 0.0), 2.0).Value();
        AdaptorGeom2Curve circle(c);
        ComputePointsAbscissa cpa(circle, 0.0, 0.0);
        double angle1 = l / r;
        double x = r * cos(angle1);
        double y = r * sin(angle1);
        double param = cpa.Parameter();
        Point2 s = circle.Value(param);
        Point2 s1(x, y);
        CHECK(angle1 == cpa.Parameter());
        CHECK(s.X() == s1.X());
        CHECK(s.Y() == s1.Y());
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API ComputePointsAbscissa(const Adaptor3Curve& c, double abscissa, double u0)	 @param u0 The starting parameter
	 @param abscissa The arc length
	 @param c The curve
	 @brief Compute the parameter of a point on a 3D curve with given arc length
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <geometry/MakeGeom2Circle.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/ComputePointsAbscissa.hpp>
#include <geometry/MakeGeom3Circle.hpp>
#include <geometry/AdaptorGeom3Curve.hpp>
#include <geometry/MakeGeom2Hyperbola.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/MakeGeom2Ellipse.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <geometry/MakeGeom3Ellipse.hpp>
#include <geometry/MakeGeom3Hyperbola.hpp>
#include <geometry/Geom2Line.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom3Line.hpp>
#include <geometry/Geom3TrimmedCurve.hpp>
#include<modeling/MakeEdge.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/GeometryTool.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <geometry/MakeGeom2Parabola.hpp>
#include <geometry/MakeGeom3Parabola.hpp>
#include <geometry/Geom2BezierCurve.hpp>
#include <geometry/Geom3BezierCurve.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/Geom2OffsetCurve.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
TEST_CASE("test that the arc length is 0 - given arc length - 3D", "[geometry][ComputePointsAbscissa][case27]")
{
	SECTION("circle")
    {
        Frame3 frame;
        double r = 2.0;
        double l = 0.0;
        std::shared_ptr<Geom3Curve> c = MakeGeom3Circle(frame, r).Value();
        AdaptorGeom3Curve circle(c);
        ComputePointsAbscissa cpa(circle, 0.0, 0.0);
        double angle1 = l / r;
        double x = r * cos(angle1);
        double y = r * sin(angle1);
        double z = 0;
        double param = cpa.Parameter();
        Point3 s = circle.Value(param);
        Point3 s1(x, y, z);
        CHECK(angle1 == cpa.Parameter());
        CHECK(s.X() == s1.X());
        CHECK(s.Y() == s1.Y());
        CHECK(s.Z() == s1.Z());
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API ComputePointsAbscissa(const Adaptor2Curve& c, double abscissa, double u0)	 @param u0 The starting parameter
	 @param abscissa The arc length
	 @param c The curve
	 @brief Compute the parameter of a point on a 2D curve with given arc length
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <geometry/MakeGeom2Circle.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/ComputePointsAbscissa.hpp>
#include <geometry/MakeGeom3Circle.hpp>
#include <geometry/AdaptorGeom3Curve.hpp>
#include <geometry/MakeGeom2Hyperbola.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/MakeGeom2Ellipse.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <geometry/MakeGeom3Ellipse.hpp>
#include <geometry/MakeGeom3Hyperbola.hpp>
#include <geometry/Geom2Line.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom3Line.hpp>
#include <geometry/Geom3TrimmedCurve.hpp>
#include<modeling/MakeEdge.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/GeometryTool.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <geometry/MakeGeom2Parabola.hpp>
#include <geometry/MakeGeom3Parabola.hpp>
#include <geometry/Geom2BezierCurve.hpp>
#include <geometry/Geom3BezierCurve.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/Geom2OffsetCurve.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
TEST_CASE("test that the arc length is 0 - given arc length - 2D", "[geometry][ComputePointsAbscissa][case26]")
{
	SECTION("circle")
    {
        double r = 2.0;
        double l = 0.0;
        std::shared_ptr<Geom2Curve> c = MakeGeom2Circle(Point2(0.0, 0.0), 2.0).Value();
        AdaptorGeom2Curve circle(c);
        ComputePointsAbscissa cpa(circle, 0.0, 0.0);
        double angle1 = l / r;
        double x = r * cos(angle1);
        double y = r * sin(angle1);
        double param = cpa.Parameter();
        Point2 s = circle.Value(param);
        Point2 s1(x, y);
        CHECK(angle1 == cpa.Parameter());
        CHECK(s.X() == s1.X());
        CHECK(s.Y() == s1.Y());
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API ComputePointsAbscissa(const Adaptor3Curve& c, double abscissa, double u0, double ui)	 @param ui The initial guess of the parameter
	 @param u0 The starting parameter
	 @param abscissa The arc length
	 @param c The curve
	 @brief Compute the parameter of a point on a 3D curve with given arc length and an initial guess
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <geometry/MakeGeom2Circle.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/ComputePointsAbscissa.hpp>
#include <geometry/MakeGeom3Circle.hpp>
#include <geometry/AdaptorGeom3Curve.hpp>
#include <geometry/MakeGeom2Hyperbola.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/MakeGeom2Ellipse.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <geometry/MakeGeom3Ellipse.hpp>
#include <geometry/MakeGeom3Hyperbola.hpp>
#include <geometry/Geom2Line.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom3Line.hpp>
#include <geometry/Geom3TrimmedCurve.hpp>
#include<modeling/MakeEdge.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/GeometryTool.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <geometry/MakeGeom2Parabola.hpp>
#include <geometry/MakeGeom3Parabola.hpp>
#include <geometry/Geom2BezierCurve.hpp>
#include <geometry/Geom3BezierCurve.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/Geom2OffsetCurve.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
TEST_CASE("test that the arc length is 0 - given arc length - 3D", "[geometry][ComputePointsAbscissa][case27]")
{
	SECTION("circle")
    {
        Frame3 frame;
        double r = 2.0;
        double l = 0.0;
        std::shared_ptr<Geom3Curve> c = MakeGeom3Circle(frame, r).Value();
        AdaptorGeom3Curve circle(c);
        ComputePointsAbscissa cpa(circle, 0.0, 0.0);
        double angle1 = l / r;
        double x = r * cos(angle1);
        double y = r * sin(angle1);
        double z = 0;
        double param = cpa.Parameter();
        Point3 s = circle.Value(param);
        Point3 s1(x, y, z);
        CHECK(angle1 == cpa.Parameter());
        CHECK(s.X() == s1.X());
        CHECK(s.Y() == s1.Y());
        CHECK(s.Z() == s1.Z());
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API ComputePointsAbscissa(const Adaptor2Curve& c, double abscissa, double u0, double ui)	 @param ui The initial guess of the parameter
	 @param u0 The starting parameter
	 @param abscissa The arc length
	 @param c The curve
	 @brief Compute the parameter of a point on a 2D curve with given arc length and an initial guess
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <geometry/MakeGeom2Circle.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/ComputePointsAbscissa.hpp>
#include <geometry/MakeGeom3Circle.hpp>
#include <geometry/AdaptorGeom3Curve.hpp>
#include <geometry/MakeGeom2Hyperbola.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/MakeGeom2Ellipse.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <geometry/MakeGeom3Ellipse.hpp>
#include <geometry/MakeGeom3Hyperbola.hpp>
#include <geometry/Geom2Line.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom3Line.hpp>
#include <geometry/Geom3TrimmedCurve.hpp>
#include<modeling/MakeEdge.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/GeometryTool.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <geometry/MakeGeom2Parabola.hpp>
#include <geometry/MakeGeom3Parabola.hpp>
#include <geometry/Geom2BezierCurve.hpp>
#include <geometry/Geom3BezierCurve.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/Geom2OffsetCurve.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
TEST_CASE("test that the arc length is 0 - given arc length - 2D", "[geometry][ComputePointsAbscissa][case26]")
{
	SECTION("circle")
    {
        double r = 2.0;
        double l = 0.0;
        std::shared_ptr<Geom2Curve> c = MakeGeom2Circle(Point2(0.0, 0.0), 2.0).Value();
        AdaptorGeom2Curve circle(c);
        ComputePointsAbscissa cpa(circle, 0.0, 0.0);
        double angle1 = l / r;
        double x = r * cos(angle1);
        double y = r * sin(angle1);
        double param = cpa.Parameter();
        Point2 s = circle.Value(param);
        Point2 s1(x, y);
        CHECK(angle1 == cpa.Parameter());
        CHECK(s.X() == s1.X());
        CHECK(s.Y() == s1.Y());
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API ComputePointsAbscissa(const Adaptor3Curve& c, double abscissa, double u0, double ui, double tol)	 @param tol The tolerance
	 @param ui The initial guess of the parameter
	 @param u0 The starting parameter
	 @param abscissa The arc length
	 @param c The curve
	 @brief Compute the parameter of a point on a 3D curve with given arc length, an initial guess, and a tolerance
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <geometry/MakeGeom2Circle.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/ComputePointsAbscissa.hpp>
#include <geometry/MakeGeom3Circle.hpp>
#include <geometry/AdaptorGeom3Curve.hpp>
#include <geometry/MakeGeom2Hyperbola.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/MakeGeom2Ellipse.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <geometry/MakeGeom3Ellipse.hpp>
#include <geometry/MakeGeom3Hyperbola.hpp>
#include <geometry/Geom2Line.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom3Line.hpp>
#include <geometry/Geom3TrimmedCurve.hpp>
#include<modeling/MakeEdge.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/GeometryTool.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <geometry/MakeGeom2Parabola.hpp>
#include <geometry/MakeGeom3Parabola.hpp>
#include <geometry/Geom2BezierCurve.hpp>
#include <geometry/Geom3BezierCurve.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/Geom2OffsetCurve.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
TEST_CASE("test that the arc length is 0 - given arc length - 3D", "[geometry][ComputePointsAbscissa][case27]")
{
	SECTION("circle")
    {
        Frame3 frame;
        double r = 2.0;
        double l = 0.0;
        std::shared_ptr<Geom3Curve> c = MakeGeom3Circle(frame, r).Value();
        AdaptorGeom3Curve circle(c);
        ComputePointsAbscissa cpa(circle, 0.0, 0.0);
        double angle1 = l / r;
        double x = r * cos(angle1);
        double y = r * sin(angle1);
        double z = 0;
        double param = cpa.Parameter();
        Point3 s = circle.Value(param);
        Point3 s1(x, y, z);
        CHECK(angle1 == cpa.Parameter());
        CHECK(s.X() == s1.X());
        CHECK(s.Y() == s1.Y());
        CHECK(s.Z() == s1.Z());
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API ComputePointsAbscissa(const Adaptor2Curve& c, double abscissa, double u0, double ui, double tol)	 @param tol The tolerance
	 @param ui The initial guess of the parameter
	 @param u0 The starting parameter
	 @param abscissa The arc length
	 @param c The curve
	 @brief Compute the parameter of a point on a 2D curve with given arc length, an initial guess, and a tolerance
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <geometry/MakeGeom2Circle.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/ComputePointsAbscissa.hpp>
#include <geometry/MakeGeom3Circle.hpp>
#include <geometry/AdaptorGeom3Curve.hpp>
#include <geometry/MakeGeom2Hyperbola.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/MakeGeom2Ellipse.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <geometry/MakeGeom3Ellipse.hpp>
#include <geometry/MakeGeom3Hyperbola.hpp>
#include <geometry/Geom2Line.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom3Line.hpp>
#include <geometry/Geom3TrimmedCurve.hpp>
#include<modeling/MakeEdge.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/GeometryTool.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <geometry/MakeGeom2Parabola.hpp>
#include <geometry/MakeGeom3Parabola.hpp>
#include <geometry/Geom2BezierCurve.hpp>
#include <geometry/Geom3BezierCurve.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/Geom2OffsetCurve.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
TEST_CASE("test that the arc length is 0 - given arc length - 2D", "[geometry][ComputePointsAbscissa][case26]")
{
	SECTION("circle")
    {
        double r = 2.0;
        double l = 0.0;
        std::shared_ptr<Geom2Curve> c = MakeGeom2Circle(Point2(0.0, 0.0), 2.0).Value();
        AdaptorGeom2Curve circle(c);
        ComputePointsAbscissa cpa(circle, 0.0, 0.0);
        double angle1 = l / r;
        double x = r * cos(angle1);
        double y = r * sin(angle1);
        double param = cpa.Parameter();
        Point2 s = circle.Value(param);
        Point2 s1(x, y);
        CHECK(angle1 == cpa.Parameter());
        CHECK(s.X() == s1.X());
        CHECK(s.Y() == s1.Y());
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API double Parameter()	 @return The parameter of the point
	 @brief Get the parameter of the point
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <geometry/MakeGeom2Circle.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/ComputePointsAbscissa.hpp>
#include <geometry/MakeGeom3Circle.hpp>
#include <geometry/AdaptorGeom3Curve.hpp>
#include <geometry/MakeGeom2Hyperbola.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/MakeGeom2Ellipse.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <geometry/MakeGeom3Ellipse.hpp>
#include <geometry/MakeGeom3Hyperbola.hpp>
#include <geometry/Geom2Line.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom3Line.hpp>
#include <geometry/Geom3TrimmedCurve.hpp>
#include<modeling/MakeEdge.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/GeometryTool.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <geometry/MakeGeom2Parabola.hpp>
#include <geometry/MakeGeom3Parabola.hpp>
#include <geometry/Geom2BezierCurve.hpp>
#include <geometry/Geom3BezierCurve.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/Geom2OffsetCurve.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
TEST_CASE("test that the arc length is 0 - given arc length - 2D", "[geometry][ComputePointsAbscissa][case26]")
{
	SECTION("circle")
    {
        double r = 2.0;
        double l = 0.0;
        std::shared_ptr<Geom2Curve> c = MakeGeom2Circle(Point2(0.0, 0.0), 2.0).Value();
        AdaptorGeom2Curve circle(c);
        ComputePointsAbscissa cpa(circle, 0.0, 0.0);
        double angle1 = l / r;
        double x = r * cos(angle1);
        double y = r * sin(angle1);
        double param = cpa.Parameter();
        Point2 s = circle.Value(param);
        Point2 s1(x, y);
        CHECK(angle1 == cpa.Parameter());
        CHECK(s.X() == s1.X());
        CHECK(s.Y() == s1.Y());
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API ComputePointsAbscissa(double tol, const Adaptor3Curve& c, double abscissa, double u0)	 @param u0 The starting parameter
	 @param abscissa The arc length
	 @param c The curve
	 @param tol The tolerance
	 @brief Compute the parameter of a point on a 3D curve with given arc length and a tolerance
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <geometry/MakeGeom2Circle.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/ComputePointsAbscissa.hpp>
#include <geometry/MakeGeom3Circle.hpp>
#include <geometry/AdaptorGeom3Curve.hpp>
#include <geometry/MakeGeom2Hyperbola.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/MakeGeom2Ellipse.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <geometry/MakeGeom3Ellipse.hpp>
#include <geometry/MakeGeom3Hyperbola.hpp>
#include <geometry/Geom2Line.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom3Line.hpp>
#include <geometry/Geom3TrimmedCurve.hpp>
#include<modeling/MakeEdge.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/GeometryTool.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <geometry/MakeGeom2Parabola.hpp>
#include <geometry/MakeGeom3Parabola.hpp>
#include <geometry/Geom2BezierCurve.hpp>
#include <geometry/Geom3BezierCurve.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/Geom2OffsetCurve.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
TEST_CASE("test the arc length is negative - given arc length - 3D", "[geometry][ComputePointsAbscissa][case10]")
{
	SECTION("circle")
    {
        Frame3 frame;
        double r = 2.0;
        double l = -1.0;
        std::shared_ptr<Geom3Curve> c = MakeGeom3Circle(frame, r).Value();
        AdaptorGeom3Curve circle(c);
        ComputePointsAbscissa cpa(circle, -1.0, 0.0);
        double angle1 = l / r;
        double x = r * cos(angle1);
        double y = r * sin(angle1);
        double z = 0;
        double param = cpa.Parameter();
        Point3 s = circle.Value(param);
        Point3 s1(x, y, z);
        CHECK(angle1 == cpa.Parameter());
        CHECK(s.X() == s1.X());
        CHECK(s.Y() == s1.Y());
        CHECK(s.Z() == s1.Z());
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API ComputePointsAbscissa(double tol, const Adaptor3Curve& c, double abscissa, double u0)	 @param u0 The starting parameter
	 @param abscissa The arc length
	 @param c The curve
	 @param tol The tolerance
	 @brief Compute the parameter of a point on a 3D curve with given arc length and a tolerance
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <geometry/MakeGeom2Circle.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/ComputePointsAbscissa.hpp>
#include <geometry/MakeGeom2Hyperbola.hpp>
#include <modeling/MakeEdge.hpp>
#include <geometry/GeometryTool.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/MakeGeom2Ellipse.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/AdaptorGeom3Curve.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <geometry/MakeGeom3Hyperbola.hpp>
#include <geometry/MakeGeom3Ellipse.hpp>
TEST_CASE("bug2: ComputePointsAbscissa ", "[geometry][ComputePointsAbscissa][fixbug]")
{
	SECTION("arc length and tolerance-3D")
{
    Frame3 frame;
    double major = 5.0;
    double minor = 4.0;
    bool isRight = true;
    std::shared_ptr< Geom3Hyperbola >h1 = MakeGeom3Hyperbola(frame, major, minor);
    AdaptorGeom3Curve hyperbola(h1);
    ComputePointsAbscissa cpa3(Precision::Confusion(), hyperbola, 1.0, 0.0);
    double param3 = cpa3.Parameter();
    Point3 point1(hyperbola.Value(param3));
    CHECK(cpa3.Parameter());
    MakeEdge edge1(h1, 0.0, param3);
    CHECK(BRepClassificationTools::IsPointInOnEdge(edge1, point1, 0.001) == true);
}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API ComputePointsAbscissa(double tol, const Adaptor2Curve& c, double abscissa, double u0)	 @param u0 The starting parameter
	 @param abscissa The arc length
	 @param c The curve
	 @param tol The tolerance
	 @brief Compute the parameter of a point on a 2D curve with given arc length and a tolerance
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <geometry/MakeGeom2Circle.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/ComputePointsAbscissa.hpp>
#include <geometry/MakeGeom2Hyperbola.hpp>
#include <modeling/MakeEdge.hpp>
#include <geometry/GeometryTool.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/MakeGeom2Ellipse.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/AdaptorGeom3Curve.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <geometry/MakeGeom3Hyperbola.hpp>
#include <geometry/MakeGeom3Ellipse.hpp>
TEST_CASE("bug2: ComputePointsAbscissa ", "[geometry][ComputePointsAbscissa][fixbug]")
{
	SECTION("arc length and tolerance-2D")
{
    Axis2 axis;
    double major = 5.0;
    double minor = 4.0;
    bool isRight = true;
    std::shared_ptr< Geom2Hyperbola >h1 = MakeGeom2Hyperbola(axis, major, minor, isRight);
    AdaptorGeom2Curve hyperbola(h1);
    ComputePointsAbscissa cpa3(Precision::Confusion(), hyperbola, 1.0, 0.0);
    double param3 = cpa3.Parameter();
    CHECK(cpa3.Parameter());
    Point2 s4 = hyperbola.Value(param3);
    shared_ptr<Geom3Curve> curve;
    curve = GeometryTool::To3d(Frame3(), h1);
    MakeEdge edge2(curve, 0.0, param3);
    Point3 point1(s4.X(), s4.Y(), 0.0);
    CHECK(BRepClassificationTools::IsPointInOnEdge(edge2, point1, 0.001) == true);
}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API ComputePointsAbscissa(const Adaptor3Curve& c, double abscissa, double u0)	 @param u0 The starting parameter
	 @param abscissa The arc length
	 @param c The curve
	 @brief Compute the parameter of a point on a 3D curve with given arc length
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <geometry/MakeGeom2Circle.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/ComputePointsAbscissa.hpp>
#include <geometry/MakeGeom2Hyperbola.hpp>
#include <modeling/MakeEdge.hpp>
#include <geometry/GeometryTool.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/MakeGeom2Ellipse.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/AdaptorGeom3Curve.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <geometry/MakeGeom3Hyperbola.hpp>
#include <geometry/MakeGeom3Ellipse.hpp>
TEST_CASE("bug1: ComputePointsAbscissa ", "[geometry][ComputePointsAbscissa][fixbug]")
{
    double r = 0.0;
    std::shared_ptr<Geom2Curve> c = MakeGeom2Circle(Point2(0.0, 0.0), 0.0).Value();
    AdaptorGeom2Curve circle(c);
    ComputePointsAbscissa cpa(circle, 0.0, 0.0);
    double angle1 = 0;
    double x = r * cos(angle1);
    double y = r * sin(angle1);
    double param = cpa.Parameter();
    Point2 s = circle.Value(param);
    Point2 s1(x, y);
    CHECK(angle1 == cpa.Parameter());
    CHECK(s.X() == s1.X());
    CHECK(s.Y() == s1.Y());
    CHECK(ComputePointsAbscissa::Length(circle) == 0.0);
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API ComputePointsAbscissa(const Adaptor2Curve& c, double abscissa, double u0)	 @param u0 The starting parameter
	 @param abscissa The arc length
	 @param c The curve
	 @brief Compute the parameter of a point on a 2D curve with given arc length
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <geometry/MakeGeom2Circle.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/ComputePointsAbscissa.hpp>
#include <geometry/MakeGeom2Hyperbola.hpp>
#include <modeling/MakeEdge.hpp>
#include <geometry/GeometryTool.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/MakeGeom2Ellipse.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/AdaptorGeom3Curve.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <geometry/MakeGeom3Hyperbola.hpp>
#include <geometry/MakeGeom3Ellipse.hpp>
TEST_CASE("bug1: ComputePointsAbscissa ", "[geometry][ComputePointsAbscissa][fixbug]")
{
    double r = 0.0;
    std::shared_ptr<Geom2Curve> c = MakeGeom2Circle(Point2(0.0, 0.0), 0.0).Value();
    AdaptorGeom2Curve circle(c);
    ComputePointsAbscissa cpa(circle, 0.0, 0.0);
    double angle1 = 0;
    double x = r * cos(angle1);
    double y = r * sin(angle1);
    double param = cpa.Parameter();
    Point2 s = circle.Value(param);
    Point2 s1(x, y);
    CHECK(angle1 == cpa.Parameter());
    CHECK(s.X() == s1.X());
    CHECK(s.Y() == s1.Y());
    CHECK(ComputePointsAbscissa::Length(circle) == 0.0);
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API ComputePointsAbscissa(const Adaptor3Curve& c, double abscissa, double u0, double ui)	 @param ui The initial guess of the parameter
	 @param u0 The starting parameter
	 @param abscissa The arc length
	 @param c The curve
	 @brief Compute the parameter of a point on a 3D curve with given arc length and an initial guess
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <geometry/MakeGeom2Circle.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/ComputePointsAbscissa.hpp>
#include <geometry/MakeGeom2Hyperbola.hpp>
#include <modeling/MakeEdge.hpp>
#include <geometry/GeometryTool.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/MakeGeom2Ellipse.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/AdaptorGeom3Curve.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <geometry/MakeGeom3Hyperbola.hpp>
#include <geometry/MakeGeom3Ellipse.hpp>
TEST_CASE("bug1: ComputePointsAbscissa ", "[geometry][ComputePointsAbscissa][fixbug]")
{
    double r = 0.0;
    std::shared_ptr<Geom2Curve> c = MakeGeom2Circle(Point2(0.0, 0.0), 0.0).Value();
    AdaptorGeom2Curve circle(c);
    ComputePointsAbscissa cpa(circle, 0.0, 0.0);
    double angle1 = 0;
    double x = r * cos(angle1);
    double y = r * sin(angle1);
    double param = cpa.Parameter();
    Point2 s = circle.Value(param);
    Point2 s1(x, y);
    CHECK(angle1 == cpa.Parameter());
    CHECK(s.X() == s1.X());
    CHECK(s.Y() == s1.Y());
    CHECK(ComputePointsAbscissa::Length(circle) == 0.0);
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API ComputePointsAbscissa(const Adaptor2Curve& c, double abscissa, double u0, double ui)	 @param ui The initial guess of the parameter
	 @param u0 The starting parameter
	 @param abscissa The arc length
	 @param c The curve
	 @brief Compute the parameter of a point on a 2D curve with given arc length and an initial guess
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <geometry/MakeGeom2Circle.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/ComputePointsAbscissa.hpp>
#include <geometry/MakeGeom2Hyperbola.hpp>
#include <modeling/MakeEdge.hpp>
#include <geometry/GeometryTool.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/MakeGeom2Ellipse.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/AdaptorGeom3Curve.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <geometry/MakeGeom3Hyperbola.hpp>
#include <geometry/MakeGeom3Ellipse.hpp>
TEST_CASE("bug1: ComputePointsAbscissa ", "[geometry][ComputePointsAbscissa][fixbug]")
{
    double r = 0.0;
    std::shared_ptr<Geom2Curve> c = MakeGeom2Circle(Point2(0.0, 0.0), 0.0).Value();
    AdaptorGeom2Curve circle(c);
    ComputePointsAbscissa cpa(circle, 0.0, 0.0);
    double angle1 = 0;
    double x = r * cos(angle1);
    double y = r * sin(angle1);
    double param = cpa.Parameter();
    Point2 s = circle.Value(param);
    Point2 s1(x, y);
    CHECK(angle1 == cpa.Parameter());
    CHECK(s.X() == s1.X());
    CHECK(s.Y() == s1.Y());
    CHECK(ComputePointsAbscissa::Length(circle) == 0.0);
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API ComputePointsAbscissa(const Adaptor3Curve& c, double abscissa, double u0, double ui, double tol)	 @param tol The tolerance
	 @param ui The initial guess of the parameter
	 @param u0 The starting parameter
	 @param abscissa The arc length
	 @param c The curve
	 @brief Compute the parameter of a point on a 3D curve with given arc length, an initial guess, and a tolerance
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <geometry/MakeGeom2Circle.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/ComputePointsAbscissa.hpp>
#include <geometry/MakeGeom2Hyperbola.hpp>
#include <modeling/MakeEdge.hpp>
#include <geometry/GeometryTool.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/MakeGeom2Ellipse.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/AdaptorGeom3Curve.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <geometry/MakeGeom3Hyperbola.hpp>
#include <geometry/MakeGeom3Ellipse.hpp>
TEST_CASE("bug2: ComputePointsAbscissa ", "[geometry][ComputePointsAbscissa][fixbug]")
{
	SECTION("arc length-3D")
{
    Frame3 frame;
    double major = 5.0;
    double minor = 4.0;
    bool isRight = true;
    std::shared_ptr< Geom3Hyperbola >h1 = MakeGeom3Hyperbola(frame, major, minor);
    AdaptorGeom3Curve hyperbola(h1);
    ComputePointsAbscissa cpa3(hyperbola, 1.0, 0.0);
    double param3 = cpa3.Parameter();
    Point3 point1 = hyperbola.Value(param3);
    CHECK(cpa3.Parameter());
    MakeEdge edge1(h1, 0.0, param3);
    CHECK(BRepClassificationTools::IsPointInOnEdge(edge1, point1, 0.001) == true);
}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API ComputePointsAbscissa(const Adaptor2Curve& c, double abscissa, double u0, double ui, double tol)	 @param tol The tolerance
	 @param ui The initial guess of the parameter
	 @param u0 The starting parameter
	 @param abscissa The arc length
	 @param c The curve
	 @brief Compute the parameter of a point on a 2D curve with given arc length, an initial guess, and a tolerance
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <geometry/MakeGeom2Circle.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/ComputePointsAbscissa.hpp>
#include <geometry/MakeGeom2Hyperbola.hpp>
#include <modeling/MakeEdge.hpp>
#include <geometry/GeometryTool.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/MakeGeom2Ellipse.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/AdaptorGeom3Curve.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <geometry/MakeGeom3Hyperbola.hpp>
#include <geometry/MakeGeom3Ellipse.hpp>
TEST_CASE("bug1: ComputePointsAbscissa ", "[geometry][ComputePointsAbscissa][fixbug]")
{
    double r = 0.0;
    std::shared_ptr<Geom2Curve> c = MakeGeom2Circle(Point2(0.0, 0.0), 0.0).Value();
    AdaptorGeom2Curve circle(c);
    ComputePointsAbscissa cpa(circle, 0.0, 0.0);
    double angle1 = 0;
    double x = r * cos(angle1);
    double y = r * sin(angle1);
    double param = cpa.Parameter();
    Point2 s = circle.Value(param);
    Point2 s1(x, y);
    CHECK(angle1 == cpa.Parameter());
    CHECK(s.X() == s1.X());
    CHECK(s.Y() == s1.Y());
    CHECK(ComputePointsAbscissa::Length(circle) == 0.0);
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API double Parameter()	 @return The parameter of the point
	 @brief Get the parameter of the point
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <geometry/MakeGeom2Circle.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/ComputePointsAbscissa.hpp>
#include <geometry/MakeGeom2Hyperbola.hpp>
#include <modeling/MakeEdge.hpp>
#include <geometry/GeometryTool.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/MakeGeom2Ellipse.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/AdaptorGeom3Curve.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <geometry/MakeGeom3Hyperbola.hpp>
#include <geometry/MakeGeom3Ellipse.hpp>
TEST_CASE("bug1: ComputePointsAbscissa ", "[geometry][ComputePointsAbscissa][fixbug]")
{
    double r = 0.0;
    std::shared_ptr<Geom2Curve> c = MakeGeom2Circle(Point2(0.0, 0.0), 0.0).Value();
    AdaptorGeom2Curve circle(c);
    ComputePointsAbscissa cpa(circle, 0.0, 0.0);
    double angle1 = 0;
    double x = r * cos(angle1);
    double y = r * sin(angle1);
    double param = cpa.Parameter();
    Point2 s = circle.Value(param);
    Point2 s1(x, y);
    CHECK(angle1 == cpa.Parameter());
    CHECK(s.X() == s1.X());
    CHECK(s.Y() == s1.Y());
    CHECK(ComputePointsAbscissa::Length(circle) == 0.0);
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":Geom2Ellipse()	 @brief Default constructor
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <math/EllipseT.hpp>
#include <geometry/Geom2Ellipse.hpp>
using namespace AMCAX;
using namespace std;
TEST_CASE("case1:this is a case for Test Geom2Ellipse", "[math][Geom2Ellipse][P1]")
{
	Axis2 axis;
	double major = 5.0;
	double minor = 4.0;
	bool isRight = true;
	Ellipse2 ellipse(axis, major, minor, isRight);
	Geom2Ellipse g2e(ellipse);
	SECTION("FocalParameter")
	{
		double FP = g2e.FocalParameter();
		double focal = 2 * sqrt(major * major - minor * minor);
		double fp = 2 * minor * minor / focal;;
		CHECK(FP == fp);
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API explicit Geom2Ellipse(const Ellipse2& e)	 @param e The ellipse
	 @brief Construct from an ellipse
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <math/EllipseT.hpp>
#include <geometry/Geom2Ellipse.hpp>
using namespace AMCAX;
using namespace std;
TEST_CASE("case1:this is a case for Test Geom2Ellipse", "[math][Geom2Ellipse][P1]")
{
	Axis2 axis;
	double major = 5.0;
	double minor = 4.0;
	bool isRight = true;
	Ellipse2 ellipse(axis, major, minor, isRight);
	Geom2Ellipse g2e(ellipse);
	SECTION("FocalParameter")
	{
		double FP = g2e.FocalParameter();
		double focal = 2 * sqrt(major * major - minor * minor);
		double fp = 2 * minor * minor / focal;;
		CHECK(FP == fp);
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API Geom2Ellipse(const Axis2& majorAxis, double major, double minor, bool isRight)	 @param isRight Is the local frame right-handed
	 @param minor The minor radius
	 @param major The major radius
	 @param majorAxis The axis
	 @brief Construct from an axis, a major radius and a minor radius
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <math/EllipseT.hpp>
#include <geometry/Geom2Ellipse.hpp>
using namespace AMCAX;
using namespace std;
TEST_CASE("case1:this is a case for Test Geom2Ellipse", "[math][Geom2Ellipse][P1]")
{
	Axis2 axis;
	double major = 5.0;
	double minor = 4.0;
	bool isRight = true;
	Ellipse2 ellipse(axis, major, minor, isRight);
	Geom2Ellipse g2e(ellipse);
	SECTION("FocalParameter")
	{
		double FP = g2e.FocalParameter();
		double focal = 2 * sqrt(major * major - minor * minor);
		double fp = 2 * minor * minor / focal;;
		CHECK(FP == fp);
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API Geom2Ellipse(const Frame2& frame, double major, double minor)	 @param minor The minor radius
	 @param major The major radius
	 @param frame The local frame
	 @brief Construct from a local frame, a major radius and a minor radius
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <math/EllipseT.hpp>
#include <geometry/Geom2Ellipse.hpp>
using namespace AMCAX;
using namespace std;
TEST_CASE("case1:this is a case for Test Geom2Ellipse", "[math][Geom2Ellipse][P1]")
{
	Axis2 axis;
	double major = 5.0;
	double minor = 4.0;
	bool isRight = true;
	Ellipse2 ellipse(axis, major, minor, isRight);
	Geom2Ellipse g2e(ellipse);
	SECTION("FocalParameter")
	{
		double FP = g2e.FocalParameter();
		double focal = 2 * sqrt(major * major - minor * minor);
		double fp = 2 * minor * minor / focal;;
		CHECK(FP == fp);
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] AMCAX_API double FocalParameter()	 @return The focal parameter
	          Focal parameter = 2 * focalLength.
	 @details The focal parameter of parabola is the distance from the focus to the directrix.
	 @brief Get the focal parameter of the parabola
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <geometry/Geom3Parabola.hpp>
using namespace AMCAX;
using namespace std;
TEST_CASE("case1:this is a case for Test Geom3Parabola", "[math][Geom3Parabola][P1]")
{
	Frame3 frame;
	double focal = 5.0;
	Geom3Parabola g3p(frame, focal);
	SECTION("FocalParameter")
	{
		double FP = g3p.FocalParameter();
		double fp = 2 * focal;
		CHECK(FP == fp);
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] AMCAX_API double SemilatusRectum()	 @return The semilatus rectum
	          Semilatus rectum = 2 * focalLength
	 @details The semilatus rectum of parabola is half of the length of the chord through a focus parallel to the directrix.
	 @brief Get the semilatus rectum of the parabola
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <geometry/Geom3Parabola.hpp>
using namespace AMCAX;
using namespace std;
TEST_CASE("case1:this is a case for Test Geom3Parabola", "[math][Geom3Parabola][P1]")
{
	Frame3 frame;
	double focal = 5.0;
	Geom3Parabola g3p(frame, focal);
	SECTION("SemilatusRectum")
	{
		double SR = g3p.SemilatusRectum();
		double sr = 2 * focal;
		CHECK(SR == sr);
	}
}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API explicit Geom3Parabola(const Parabola3& p)	 @param p The parabola
	 @brief Construct from a parabola
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <geometry/Geom3Parabola.hpp>
using namespace AMCAX;
using namespace std;
TEST_CASE("case1:this is a case for Test Geom3Parabola", "[math][Geom3Parabola][P1]")
{
	Frame3 frame;
	double focal = 5.0;
	Geom3Parabola g3p(frame, focal);
	SECTION("FocalParameter")
	{
		double FP = g3p.FocalParameter();
		double fp = 2 * focal;
		CHECK(FP == fp);
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API Geom3Parabola(const Frame3& frame, double focal)	 @param focal The focal length
	 @param frame The local frame
	 @brief Construct from a local frame and a focal length
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <geometry/Geom3Parabola.hpp>
using namespace AMCAX;
using namespace std;
TEST_CASE("case1:this is a case for Test Geom3Parabola", "[math][Geom3Parabola][P1]")
{
	Frame3 frame;
	double focal = 5.0;
	Geom3Parabola g3p(frame, focal);
	SECTION("FocalParameter")
	{
		double FP = g3p.FocalParameter();
		double fp = 2 * focal;
		CHECK(FP == fp);
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API Geom3Parabola(const Axis3& directrix, const Point3& focus)	 @param focus The focus
	 @param directrix The directrix
	 @brief Construct from a directrix and a focus
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <geometry/Geom3Parabola.hpp>
using namespace AMCAX;
using namespace std;
TEST_CASE("case1:this is a case for Test Geom3Parabola", "[math][Geom3Parabola][P1]")
{
	Frame3 frame;
	double focal = 5.0;
	Geom3Parabola g3p(frame, focal);
	SECTION("FocalParameter")
	{
		double FP = g3p.FocalParameter();
		double fp = 2 * focal;
		CHECK(FP == fp);
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API Geom2Hyperbola(const Axis2& axis, double major, double minor, bool isRight = true)	 @param isRight Is the local frame right-handed
	 @param minor The minor radius
	 @param major The major radius
	 @param axis The axis
	 @brief Construct from an axis, a major radius and a minor radius
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <math/EllipseT.hpp>
#include <geometry/Geom2Hyperbola.hpp>
using namespace AMCAX;
using namespace std;
TEST_CASE("case1:this is a case for Test Geom2Hyperbola", "[math][Geom2Hyperbola][P1]")
{
	Axis2 axis;
	double major = 5.0;
	double minor = 4.0;
	bool isRight = true;
	Geom2Hyperbola g2h(axis, major, minor, isRight);
	SECTION("FocalParameter")
	{
		double FP = g2h.FocalParameter();
		double focal = 2 * sqrt(major * major + minor * minor);
		double fp = 2 * minor * minor / focal;;
		CHECK(FP == fp);
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API Geom2Hyperbola(const Frame2& frame, double major, double minor)	 @param minor The minor radius
	 @param major The major radius
	 @param frame The local frame
	 @brief Construct from a local frame, a major radius and a minor radius
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <math/EllipseT.hpp>
#include <geometry/Geom2Hyperbola.hpp>
using namespace AMCAX;
using namespace std;
TEST_CASE("case1:this is a case for Test Geom2Hyperbola", "[math][Geom2Hyperbola][P1]")
{
	Axis2 axis;
	double major = 5.0;
	double minor = 4.0;
	bool isRight = true;
	Geom2Hyperbola g2h(axis, major, minor, isRight);
	SECTION("FocalParameter")
	{
		double FP = g2h.FocalParameter();
		double focal = 2 * sqrt(major * major + minor * minor);
		double fp = 2 * minor * minor / focal;;
		CHECK(FP == fp);
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":Geom2Parabola()	 @brief Default constructor
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <geometry/Geom2Parabola.hpp>
using namespace AMCAX;
using namespace std;
TEST_CASE("case1:this is a case for Test Geom2Parabola", "[math][Geom2Parabola][P1]")
{
	Axis2 axis;
	double focal = 5.0;
	bool isRight = true;
	Geom2Parabola g2p(axis, focal, isRight);
	SECTION("SemilatusRectum")
	{
		double SR = g2p.SemilatusRectum();
		double sr = 2 * focal;
		CHECK(SR == sr);
	}
}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API Geom2Parabola(const Axis2& axis, double focal, bool isRight = true)	 @param isRight Is the local frame right-handed
	 @param focal The focal length
	 @param axis The axis
	 @brief Construct from an axis and a focal length
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <geometry/Geom2Parabola.hpp>
using namespace AMCAX;
using namespace std;
TEST_CASE("case1:this is a case for Test Geom2Parabola", "[math][Geom2Parabola][P1]")
{
	Axis2 axis;
	double focal = 5.0;
	bool isRight = true;
	Geom2Parabola g2p(axis, focal, isRight);
	SECTION("FocalParameter")
	{
		double FP = g2p.FocalParameter();
		double fp = 2 * focal;
		CHECK(FP == fp);
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API Geom2Parabola(const Frame2& frame, double focal)	 @param focal The focal length
	 @param frame The local frame
	 @brief Construct from a local frame and a focal length
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <geometry/Geom2Parabola.hpp>
using namespace AMCAX;
using namespace std;
TEST_CASE("case1:this is a case for Test Geom2Parabola", "[math][Geom2Parabola][P1]")
{
	Axis2 axis;
	double focal = 5.0;
	bool isRight = true;
	Geom2Parabola g2p(axis, focal, isRight);
	SECTION("FocalParameter")
	{
		double FP = g2p.FocalParameter();
		double fp = 2 * focal;
		CHECK(FP == fp);
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API Geom2Parabola(const Axis2& directrix, const Point2& focus, bool isRight = true)	 @param isRight Is the local frame right-handed
	 @param focus The focus
	 @param directrix The directrix
	 @brief Construct from a directrix and a focus
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <geometry/Geom2Parabola.hpp>
using namespace AMCAX;
using namespace std;
TEST_CASE("case1:this is a case for Test Geom2Parabola", "[math][Geom2Parabola][P1]")
{
	Axis2 axis;
	double focal = 5.0;
	bool isRight = true;
	Geom2Parabola g2p(axis, focal, isRight);
	SECTION("FocalParameter")
	{
		double FP = g2p.FocalParameter();
		double fp = 2 * focal;
		CHECK(FP == fp);
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API Geom3BSplineCurve(const std::vector<Point3>& pts, const std::vector<double>& weights, const std::vector<double>& knots, const std::vector<int>& multiplicities, int degree, bool isPeriodic = false, bool checkRational = true)	 @param checkRational To check whether the weights are rational
	 @param isPeriodic Set the curve is periodic or not
	 @param degree The degree of curve
	 @param multiplicities The multiplicities
	 @param knots The knots
	 @param weights The weights
	 @param pts The points
	 @brief Construct a rational B spline curve from point, weights, knots and multiplicities with a given degree
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <geometry/Geom3BSplineCurve.hpp>
#include <geometry/Geom3BSplineSurface.hpp>
#include <topology/TopoFace.hpp>
#include <topology/TopoTool.hpp>
using namespace AMCAX;
TEST_CASE("bug1: Geom3BSplineCurve ", "[geometry][Geom3BSplineCurve][fixbug]") {
	std::stringstream output1,output2;
	std::vector<Point3> poles{ Point3(0.0, 0.0, 0.0), Point3(0.0, 1.0, 0.0), Point3(0.0, 2.0, 0.0), Point3(0.0, 3.0, 0.0), Point3(0.0, 4.0, 0.0) };
	std::vector<double> knots{ 0.0, 1.0, 2.0, 3.0 };
	std::vector<int> mults{ 2, 2, 2, 2 };
	auto bc = std::make_shared<Geom3BSplineCurve>(poles, knots, mults, 2);
	double last = bc->LastParameter();
	std::cout << bc->Value(last) << '\n';
	std::cout << bc->DN(last, 0) << '\n';
	output1 << bc->Value(last) << '\n';
	output2 << bc->DN(last, 0) << '\n';
	auto case1 = output1.str();
	auto case2 = output2.str();
	auto expectValue = "0 3 0";
	auto expectDN = "0 3 0";
	CHECK(case1.find(expectValue) != std::string::npos);
	CHECK(case2.find(expectDN) != std::string::npos);
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API Geom3BSplineSurface()	 @details A default surface is a unit square
	 @brief Default constructor
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <modeling/MakeFace.hpp>
#include <geometry/Geom3BSplineSurface.hpp>
#include <topology/TopoFace.hpp>
#include <topology/TopoTool.hpp>
using namespace AMCAX;
TEST_CASE("case1: Geom3BSplineSurface::Geom3BSplineSurface() ", "[geometry][Geom3BSplineSurface][p1]") {
	Array2<Point3> poles(5, 4);
	poles(0, 0).SetCoord(0.0, 0.0, 0.0);
	poles(0, 1).SetCoord(0.0, 1.1, 2.0);
	poles(0, 2).SetCoord(0.0, 2.3, 1.0);
	poles(0, 3).SetCoord(0.0, 3.1, 1.5);
	poles(1, 0).SetCoord(1.1, 0.1, 2.0);
	poles(1, 1).SetCoord(1.2, 1.0, 0.0);
	poles(1, 2).SetCoord(1.3, 2.1, -1.0);
	poles(1, 3).SetCoord(1.23, 3.04, 1.32);
	poles(2, 0).SetCoord(2.3, 0.1, -2.0);
	poles(2, 1).SetCoord(2.1, 1.4, 2.0);
	poles(2, 2).SetCoord(2.2, 2.1, 1.0);
	poles(2, 3).SetCoord(2.23, 3.22, 1.26);
	poles(3, 0).SetCoord(3.13, 0.2, 0.0);
	poles(3, 1).SetCoord(3.12, 1.1, 0.0);
	poles(3, 2).SetCoord(3.21, 2.1, 1.0);
	poles(3, 3).SetCoord(3.33, 3.21, -1.2);
	poles(4, 0).SetCoord(4.9, 4.93, 0.31);
	poles(4, 1).SetCoord(5.3, 4.73, 0.33);
	poles(4, 2).SetCoord(5.1, 4.43, -1.31);
	poles(4, 3).SetCoord(9.2, 4.65, 3.31);
	std::vector<double> uknots = { 0.0, 0.5, 1.0 };
	std::vector<int> umults = { 4, 1, 4 };
	std::vector<double> vknots = { 0.0, 0.5, 1.0 };
	std::vector<int> vmults = { 3, 1, 3 };
	std::shared_ptr<Geom3BSplineSurface> s = std::make_shared<Geom3BSplineSurface>(poles, uknots, vknots, umults, vmults, 3, 2);
	TopoFace face = MakeFace(s,0.001);
	bool bWriteresult = OCCTIO::OCCTTool::Write(face, OUTPUT_PATH_PREFIX"Geom3BSplineSurface_case1.brep");
	CHECK(bWriteresult == true);
	AMCAX::GlobalProperty prop;
	AMCAX::BRepGlobalProperty::SurfaceProperties(face, prop);
	CHECK(prop.Mass() == Approx( 21.3633));
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API Geom3BSplineSurface(const Array2<Point3>& pts, const std::vector<double>& uKnots, const std::vector<double>& vKnots, const std::vector<int>& uMults, const std::vector<int>& vMults, int uDegree, int vDegree, bool uPeriodic = false, bool vPeriodic = false)	 @param vPeriodic Set whether the surface is periodic along the v direction
	 @param uPeriodic Set whether the surface is periodic along the u direction
	 @param vDegree The v degree
	 @param uDegree The u degree
	 @param vMults The v multiplicities
	 @param uMults The u multiplicities
	 @param vKnots The v knots
	 @param uKnots The u knots
	 @param pts The poles
	 @brief Construct a B spline surface from poles, knots and multiplicities
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <modeling/MakeFace.hpp>
#include <geometry/Geom3BSplineSurface.hpp>
#include <topology/TopoFace.hpp>
#include <topology/TopoTool.hpp>
using namespace AMCAX;
TEST_CASE("case1: Geom3BSplineSurface::Geom3BSplineSurface() ", "[geometry][Geom3BSplineSurface][p1]") {
	Array2<Point3> poles(5, 4);
	poles(0, 0).SetCoord(0.0, 0.0, 0.0);
	poles(0, 1).SetCoord(0.0, 1.1, 2.0);
	poles(0, 2).SetCoord(0.0, 2.3, 1.0);
	poles(0, 3).SetCoord(0.0, 3.1, 1.5);
	poles(1, 0).SetCoord(1.1, 0.1, 2.0);
	poles(1, 1).SetCoord(1.2, 1.0, 0.0);
	poles(1, 2).SetCoord(1.3, 2.1, -1.0);
	poles(1, 3).SetCoord(1.23, 3.04, 1.32);
	poles(2, 0).SetCoord(2.3, 0.1, -2.0);
	poles(2, 1).SetCoord(2.1, 1.4, 2.0);
	poles(2, 2).SetCoord(2.2, 2.1, 1.0);
	poles(2, 3).SetCoord(2.23, 3.22, 1.26);
	poles(3, 0).SetCoord(3.13, 0.2, 0.0);
	poles(3, 1).SetCoord(3.12, 1.1, 0.0);
	poles(3, 2).SetCoord(3.21, 2.1, 1.0);
	poles(3, 3).SetCoord(3.33, 3.21, -1.2);
	poles(4, 0).SetCoord(4.9, 4.93, 0.31);
	poles(4, 1).SetCoord(5.3, 4.73, 0.33);
	poles(4, 2).SetCoord(5.1, 4.43, -1.31);
	poles(4, 3).SetCoord(9.2, 4.65, 3.31);
	std::vector<double> uknots = { 0.0, 0.5, 1.0 };
	std::vector<int> umults = { 4, 1, 4 };
	std::vector<double> vknots = { 0.0, 0.5, 1.0 };
	std::vector<int> vmults = { 3, 1, 3 };
	std::shared_ptr<Geom3BSplineSurface> s = std::make_shared<Geom3BSplineSurface>(poles, uknots, vknots, umults, vmults, 3, 2);
	TopoFace face = MakeFace(s,0.001);
	bool bWriteresult = OCCTIO::OCCTTool::Write(face, OUTPUT_PATH_PREFIX"Geom3BSplineSurface_case1.brep");
	CHECK(bWriteresult == true);
	AMCAX::GlobalProperty prop;
	AMCAX::BRepGlobalProperty::SurfaceProperties(face, prop);
	CHECK(prop.Mass() == Approx( 21.3633));
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API Geom3BSplineSurface(const Array2<Point3>& pts, const Array2<double>& weights, const std::vector<double>& uKnots, const std::vector<double>& vKnots, const std::vector<int>& uMults, const std::vector<int>& vMults, int uDegree, int vDegree, bool uPeriodic = false, bool vPeriodic = false)	 @param vPeriodic Set whether the surface is periodic along the v direction
	 @param uPeriodic Set whether the surface is periodic along the u direction
	 @param vDegree The v degree
	 @param uDegree The u degree
	 @param vMults The v multiplicities
	 @param uMults The u multiplicities
	 @param vKnots The v knots
	 @param uKnots The u knots
	 @param weights The weights
	 @param pts The poles
	 @brief Construct a rational B spline surface from poles, knots and multiplicities
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <modeling/MakeFace.hpp>
#include <geometry/Geom3BSplineSurface.hpp>
#include <topology/TopoFace.hpp>
#include <topology/TopoTool.hpp>
using namespace AMCAX;
TEST_CASE("case1: Geom3BSplineSurface::Geom3BSplineSurface() ", "[geometry][Geom3BSplineSurface][p1]") {
	Array2<Point3> poles(5, 4);
	poles(0, 0).SetCoord(0.0, 0.0, 0.0);
	poles(0, 1).SetCoord(0.0, 1.1, 2.0);
	poles(0, 2).SetCoord(0.0, 2.3, 1.0);
	poles(0, 3).SetCoord(0.0, 3.1, 1.5);
	poles(1, 0).SetCoord(1.1, 0.1, 2.0);
	poles(1, 1).SetCoord(1.2, 1.0, 0.0);
	poles(1, 2).SetCoord(1.3, 2.1, -1.0);
	poles(1, 3).SetCoord(1.23, 3.04, 1.32);
	poles(2, 0).SetCoord(2.3, 0.1, -2.0);
	poles(2, 1).SetCoord(2.1, 1.4, 2.0);
	poles(2, 2).SetCoord(2.2, 2.1, 1.0);
	poles(2, 3).SetCoord(2.23, 3.22, 1.26);
	poles(3, 0).SetCoord(3.13, 0.2, 0.0);
	poles(3, 1).SetCoord(3.12, 1.1, 0.0);
	poles(3, 2).SetCoord(3.21, 2.1, 1.0);
	poles(3, 3).SetCoord(3.33, 3.21, -1.2);
	poles(4, 0).SetCoord(4.9, 4.93, 0.31);
	poles(4, 1).SetCoord(5.3, 4.73, 0.33);
	poles(4, 2).SetCoord(5.1, 4.43, -1.31);
	poles(4, 3).SetCoord(9.2, 4.65, 3.31);
	std::vector<double> uknots = { 0.0, 0.5, 1.0 };
	std::vector<int> umults = { 4, 1, 4 };
	std::vector<double> vknots = { 0.0, 0.5, 1.0 };
	std::vector<int> vmults = { 3, 1, 3 };
	std::shared_ptr<Geom3BSplineSurface> s = std::make_shared<Geom3BSplineSurface>(poles, uknots, vknots, umults, vmults, 3, 2);
	TopoFace face = MakeFace(s,0.001);
	bool bWriteresult = OCCTIO::OCCTTool::Write(face, OUTPUT_PATH_PREFIX"Geom3BSplineSurface_case1.brep");
	CHECK(bWriteresult == true);
	AMCAX::GlobalProperty prop;
	AMCAX::BRepGlobalProperty::SurfaceProperties(face, prop);
	CHECK(prop.Mass() == Approx( 21.3633));
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API void InsertUKnot(double u, int m, double parametricTolerance, bool add = true)	 @param add If true, the multiplicity is an incremental value; if false, the multiplicity is a final value
	 @param parametricTolerance The tolerance of parameters
	 @param m The multiplicity of the knot to be inserted
	 @param u The knot to be inserted
	 @brief Insert a u knot
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <modeling/MakeFace.hpp>
#include <geometry/Geom3BSplineSurface.hpp>
#include <topology/TopoFace.hpp>
#include <topology/TopoTool.hpp>
using namespace AMCAX;
TEST_CASE("bug1: Geom3BSplineSurface::InsertUKnot() ", "[geometry][Geom3BSplineSurface][fixbug]") {
	TopoFace face;
	OCCTIO::OCCTTool::Read(face, INPUT_PATH_PREFIX"face.brep");
	auto surf = TopoTool::Surface(face);
	auto bsp = std::dynamic_pointer_cast<Geom3BSplineSurface>(surf);
	bsp->InsertUKnot(0.23, 1, 0.0, true);
	bool bWriteresult = OCCTIO::OCCTTool::Write(face, OUTPUT_PATH_PREFIX"result.brep");
	CHECK(bWriteresult == true);
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API Geom3ConicalSurface(const Frame3& frame, double r, double angle)	 @param angle The semi-angle
	 @param r The reference radius
	 @param frame The local frame
	 @brief Construct from a local frame, a reference radius and a semi-angle
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
#include <geometry/Geom3ConicalSurface.hpp>
using namespace AMCAX;
TEST_CASE("case1: Geom3ConicalSurface::CircleD1 1/4 ", "[math][Geom3ConicalSurface][P1][CircleD1]") {
	Direction3 initialDir(0.0, 0.0, 1.0); 
	Frame3 defaultFrame3(Point3(1.0, 1.0, 0.0), initialDir);
	AMCAX::Geom3ConicalSurface suface(defaultFrame3, 5.0, 1);
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] AMCAX_API Point3 Apex()	 @return The apex point
	 @brief Get the apex of the cone
,
 "output":#include<iostream>
#include "catch.hpp"
#include <common/FrameT.hpp>
#include <modeling/MakeFace.hpp>
#include <common/AxisT.hpp>
#include <common/FrameT.hpp>
#include <common/VectorT.hpp>
#include <math/Cone.hpp>
using namespace AMCAX;
using namespace std;
TEST_CASE("TestCone", "[math][Cone]")
{
	AMCAX::Frame3 frame;
	double radius = 5.0;
	double angle = M_PI / 4;
	AMCAX::Cone cone(frame, radius, angle);
	AMCAX::Point3 apex = cone.Apex();
	CHECK(apex.X() == 0.0);
	CHECK(apex.Y() == 0.0);
	CHECK(apex.Z() == Approx(-5.0));
	AMCAX::Axis3 axis = cone.Axis();
	std::cout << axis.Direction().X() << std::endl;
	std::cout << axis.Direction().Y() << std::endl;
	std::cout << axis.Direction().Z() << std::endl;
	CHECK(axis.Direction().X() == 0.0);
	CHECK(axis.Direction().Y() == 0.0);
	CHECK(axis.Direction().Z() == 1.0);
	double a1, a2, a3, b1, b2, b3, c1, c2, c3, d;
	cone.Coefficients(a1, a2, a3, b1, b2, b3, c1, c2, c3, d);
	std::cout << "a1: " << a1 << ", a2: " << a2 << ", a3: " << a3 << std::endl;
	std::cout << "b1: " << b1 << ", b2: " << b2 << ", b3: " << b3 << std::endl;
	std::cout << "c1: " << c1 << ", c2: " << c2 << ", c3: " << c3 << std::endl;
	std::cout << "d: " << d << std::endl;
	CHECK(a1 == 1.0);
	CHECK(a2 == 1.0);
	CHECK(a3 == Approx(-1.0));
	CHECK(b1 == 0);
	CHECK(b2 == 0);
	CHECK(b3 == 0);
	CHECK(c1 == 0);
	CHECK(c2 == 0);
	CHECK(c3 == Approx(-5.0));
	CHECK(d == -25.0);
	CHECK(cone.IsDirect() == true);
	CHECK(cone.Location().X() == 0.0);
	CHECK(cone.Location().Y() == 0.0);
	CHECK(cone.Location().Z() == 0.0);
	AMCAX::PointT<double, 3>mirrorPoint(5.0, 0.0, 0.0);
	cone.Mirror(mirrorPoint);
	auto mirroredLocation = cone.Location();
	CHECK(mirroredLocation.X() == 10.0);
	CHECK(mirroredLocation.Y() == 0.0);
	CHECK(mirroredLocation.Z() == 0.0);
	AMCAX::Frame3 coneFrame = cone.Position();
	CHECK(frame.Location().X() == 0.0);
	CHECK(frame.Location().Y() == 0.0);
	CHECK(frame.Location().Z() == 0.0);
	CHECK(cone.Radius() == 5.0);
	double  scaleCone = 2.0;
	cone.Scale(cone.Location(), scaleCone);
	CHECK(cone.Radius() == radius * 2.0);
	double semiCone = cone.SemiAngle();
	CHECK(semiCone == Approx(0.785398));
	const  Frame3& position = cone.Position();
	std::cout << position.XAxis() << std::endl;
	std::cout << position.YAxis() << std::endl;
	Direction3 zDirection(0.0, 0.0, 1.0);
	AMCAX::Point3  centerCone(0.0, 0.0, 0.0);
	Axis3 zAxis(centerCone, zDirection);
	cone.Rotated(zAxis, angle);
	AMCAX::Frame3 coneFrame2 = cone.Position();
	CHECK(coneFrame.Location().X() == 10.0);
	CHECK(coneFrame.Location().Y() == 0.0);
	CHECK(coneFrame.Location().Z() == 0.0);
	double scale = 2.0;
	cone.Scale(centerCone, scale);
	CHECK(cone.Radius() == radius * 4.0);
	double semiAngle = cone.SemiAngle();
	std::cout << semiAngle << std::endl;
	CHECK(semiAngle == Approx(0.785398));
	VectorT<double, 3> translationVector(5.0, 5.0, 0.0);
	cone.Translate(translationVector);
	CHECK(cone.Location().X() == 25.0);
	CHECK(cone.Location().Y() == 5.0);
	CHECK(cone.Location().Z() == 0.0);
	auto xAxis = cone.XAxis();
	auto yAxis = cone.YAxis();
	CHECK(xAxis.Direction().X() == Approx(-1.0));
	CHECK(yAxis.Direction().Y() == Approx(-1.0));
	AMCAX::Transformation3 tr;
	tr.SetTranslation(Vector3(1.0, 2.0, 3.0));
	cone.Transform(tr);
	Axis3 newXAxis = cone.Position().XAxis();
	CHECK(newXAxis.Location().X() == 26.0);
	CHECK(newXAxis.Location().Y() == 7.0);
	CHECK(newXAxis.Location().Z() == 3.0);
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] AMCAX_API double SemiAngle()	 @return The semi-angle
	 @brief Get the semi-angle
,
 "output":#include<iostream>
#include "catch.hpp"
#include <common/FrameT.hpp>
#include <modeling/MakeFace.hpp>
#include <common/AxisT.hpp>
#include <common/FrameT.hpp>
#include <common/VectorT.hpp>
#include <math/Cone.hpp>
using namespace AMCAX;
using namespace std;
TEST_CASE("TestCone", "[math][Cone]")
{
	AMCAX::Frame3 frame;
	double radius = 5.0;
	double angle = M_PI / 4;
	AMCAX::Cone cone(frame, radius, angle);
	AMCAX::Point3 apex = cone.Apex();
	CHECK(apex.X() == 0.0);
	CHECK(apex.Y() == 0.0);
	CHECK(apex.Z() == Approx(-5.0));
	AMCAX::Axis3 axis = cone.Axis();
	std::cout << axis.Direction().X() << std::endl;
	std::cout << axis.Direction().Y() << std::endl;
	std::cout << axis.Direction().Z() << std::endl;
	CHECK(axis.Direction().X() == 0.0);
	CHECK(axis.Direction().Y() == 0.0);
	CHECK(axis.Direction().Z() == 1.0);
	double a1, a2, a3, b1, b2, b3, c1, c2, c3, d;
	cone.Coefficients(a1, a2, a3, b1, b2, b3, c1, c2, c3, d);
	std::cout << "a1: " << a1 << ", a2: " << a2 << ", a3: " << a3 << std::endl;
	std::cout << "b1: " << b1 << ", b2: " << b2 << ", b3: " << b3 << std::endl;
	std::cout << "c1: " << c1 << ", c2: " << c2 << ", c3: " << c3 << std::endl;
	std::cout << "d: " << d << std::endl;
	CHECK(a1 == 1.0);
	CHECK(a2 == 1.0);
	CHECK(a3 == Approx(-1.0));
	CHECK(b1 == 0);
	CHECK(b2 == 0);
	CHECK(b3 == 0);
	CHECK(c1 == 0);
	CHECK(c2 == 0);
	CHECK(c3 == Approx(-5.0));
	CHECK(d == -25.0);
	CHECK(cone.IsDirect() == true);
	CHECK(cone.Location().X() == 0.0);
	CHECK(cone.Location().Y() == 0.0);
	CHECK(cone.Location().Z() == 0.0);
	AMCAX::PointT<double, 3>mirrorPoint(5.0, 0.0, 0.0);
	cone.Mirror(mirrorPoint);
	auto mirroredLocation = cone.Location();
	CHECK(mirroredLocation.X() == 10.0);
	CHECK(mirroredLocation.Y() == 0.0);
	CHECK(mirroredLocation.Z() == 0.0);
	AMCAX::Frame3 coneFrame = cone.Position();
	CHECK(frame.Location().X() == 0.0);
	CHECK(frame.Location().Y() == 0.0);
	CHECK(frame.Location().Z() == 0.0);
	CHECK(cone.Radius() == 5.0);
	double  scaleCone = 2.0;
	cone.Scale(cone.Location(), scaleCone);
	CHECK(cone.Radius() == radius * 2.0);
	double semiCone = cone.SemiAngle();
	CHECK(semiCone == Approx(0.785398));
	const  Frame3& position = cone.Position();
	std::cout << position.XAxis() << std::endl;
	std::cout << position.YAxis() << std::endl;
	Direction3 zDirection(0.0, 0.0, 1.0);
	AMCAX::Point3  centerCone(0.0, 0.0, 0.0);
	Axis3 zAxis(centerCone, zDirection);
	cone.Rotated(zAxis, angle);
	AMCAX::Frame3 coneFrame2 = cone.Position();
	CHECK(coneFrame.Location().X() == 10.0);
	CHECK(coneFrame.Location().Y() == 0.0);
	CHECK(coneFrame.Location().Z() == 0.0);
	double scale = 2.0;
	cone.Scale(centerCone, scale);
	CHECK(cone.Radius() == radius * 4.0);
	double semiAngle = cone.SemiAngle();
	std::cout << semiAngle << std::endl;
	CHECK(semiAngle == Approx(0.785398));
	VectorT<double, 3> translationVector(5.0, 5.0, 0.0);
	cone.Translate(translationVector);
	CHECK(cone.Location().X() == 25.0);
	CHECK(cone.Location().Y() == 5.0);
	CHECK(cone.Location().Z() == 0.0);
	auto xAxis = cone.XAxis();
	auto yAxis = cone.YAxis();
	CHECK(xAxis.Direction().X() == Approx(-1.0));
	CHECK(yAxis.Direction().Y() == Approx(-1.0));
	AMCAX::Transformation3 tr;
	tr.SetTranslation(Vector3(1.0, 2.0, 3.0));
	cone.Transform(tr);
	Axis3 newXAxis = cone.Position().XAxis();
	CHECK(newXAxis.Location().X() == 26.0);
	CHECK(newXAxis.Location().Y() == 7.0);
	CHECK(newXAxis.Location().Z() == 3.0);
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API Cone(const Frame3& frame, double r, double angle)	 @param angle The semi-angle
	 @param r The reference radius
	 @param frame The local frame
	 @brief Construct from a local frame, a reference radius and a semi-angle
,
 "output":#include<iostream>
#include "catch.hpp"
#include <common/FrameT.hpp>
#include <modeling/MakeFace.hpp>
#include <common/AxisT.hpp>
#include <common/FrameT.hpp>
#include <common/VectorT.hpp>
#include <math/Cone.hpp>
using namespace AMCAX;
using namespace std;
TEST_CASE("TestCone", "[math][Cone]")
{
	AMCAX::Frame3 frame;
	double radius = 5.0;
	double angle = M_PI / 4;
	AMCAX::Cone cone(frame, radius, angle);
	AMCAX::Point3 apex = cone.Apex();
	CHECK(apex.X() == 0.0);
	CHECK(apex.Y() == 0.0);
	CHECK(apex.Z() == Approx(-5.0));
	AMCAX::Axis3 axis = cone.Axis();
	std::cout << axis.Direction().X() << std::endl;
	std::cout << axis.Direction().Y() << std::endl;
	std::cout << axis.Direction().Z() << std::endl;
	CHECK(axis.Direction().X() == 0.0);
	CHECK(axis.Direction().Y() == 0.0);
	CHECK(axis.Direction().Z() == 1.0);
	double a1, a2, a3, b1, b2, b3, c1, c2, c3, d;
	cone.Coefficients(a1, a2, a3, b1, b2, b3, c1, c2, c3, d);
	std::cout << "a1: " << a1 << ", a2: " << a2 << ", a3: " << a3 << std::endl;
	std::cout << "b1: " << b1 << ", b2: " << b2 << ", b3: " << b3 << std::endl;
	std::cout << "c1: " << c1 << ", c2: " << c2 << ", c3: " << c3 << std::endl;
	std::cout << "d: " << d << std::endl;
	CHECK(a1 == 1.0);
	CHECK(a2 == 1.0);
	CHECK(a3 == Approx(-1.0));
	CHECK(b1 == 0);
	CHECK(b2 == 0);
	CHECK(b3 == 0);
	CHECK(c1 == 0);
	CHECK(c2 == 0);
	CHECK(c3 == Approx(-5.0));
	CHECK(d == -25.0);
	CHECK(cone.IsDirect() == true);
	CHECK(cone.Location().X() == 0.0);
	CHECK(cone.Location().Y() == 0.0);
	CHECK(cone.Location().Z() == 0.0);
	AMCAX::PointT<double, 3>mirrorPoint(5.0, 0.0, 0.0);
	cone.Mirror(mirrorPoint);
	auto mirroredLocation = cone.Location();
	CHECK(mirroredLocation.X() == 10.0);
	CHECK(mirroredLocation.Y() == 0.0);
	CHECK(mirroredLocation.Z() == 0.0);
	AMCAX::Frame3 coneFrame = cone.Position();
	CHECK(frame.Location().X() == 0.0);
	CHECK(frame.Location().Y() == 0.0);
	CHECK(frame.Location().Z() == 0.0);
	CHECK(cone.Radius() == 5.0);
	double  scaleCone = 2.0;
	cone.Scale(cone.Location(), scaleCone);
	CHECK(cone.Radius() == radius * 2.0);
	double semiCone = cone.SemiAngle();
	CHECK(semiCone == Approx(0.785398));
	const  Frame3& position = cone.Position();
	std::cout << position.XAxis() << std::endl;
	std::cout << position.YAxis() << std::endl;
	Direction3 zDirection(0.0, 0.0, 1.0);
	AMCAX::Point3  centerCone(0.0, 0.0, 0.0);
	Axis3 zAxis(centerCone, zDirection);
	cone.Rotated(zAxis, angle);
	AMCAX::Frame3 coneFrame2 = cone.Position();
	CHECK(coneFrame.Location().X() == 10.0);
	CHECK(coneFrame.Location().Y() == 0.0);
	CHECK(coneFrame.Location().Z() == 0.0);
	double scale = 2.0;
	cone.Scale(centerCone, scale);
	CHECK(cone.Radius() == radius * 4.0);
	double semiAngle = cone.SemiAngle();
	std::cout << semiAngle << std::endl;
	CHECK(semiAngle == Approx(0.785398));
	VectorT<double, 3> translationVector(5.0, 5.0, 0.0);
	cone.Translate(translationVector);
	CHECK(cone.Location().X() == 25.0);
	CHECK(cone.Location().Y() == 5.0);
	CHECK(cone.Location().Z() == 0.0);
	auto xAxis = cone.XAxis();
	auto yAxis = cone.YAxis();
	CHECK(xAxis.Direction().X() == Approx(-1.0));
	CHECK(yAxis.Direction().Y() == Approx(-1.0));
	AMCAX::Transformation3 tr;
	tr.SetTranslation(Vector3(1.0, 2.0, 3.0));
	cone.Transform(tr);
	Axis3 newXAxis = cone.Position().XAxis();
	CHECK(newXAxis.Location().X() == 26.0);
	CHECK(newXAxis.Location().Y() == 7.0);
	CHECK(newXAxis.Location().Z() == 3.0);
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API Cone& Scale(const Point3& point, double scale)	 @return The reference to self
	 @param scale The scale value
	 @param point The scaling center point
	 @brief Scale the cone by a point
,
 "output":#include<iostream>
#include "catch.hpp"
#include <common/FrameT.hpp>
#include <modeling/MakeFace.hpp>
#include <common/AxisT.hpp>
#include <common/FrameT.hpp>
#include <common/VectorT.hpp>
#include <math/Cone.hpp>
using namespace AMCAX;
using namespace std;
TEST_CASE("TestCone", "[math][Cone]")
{
	AMCAX::Frame3 frame;
	double radius = 5.0;
	double angle = M_PI / 4;
	AMCAX::Cone cone(frame, radius, angle);
	AMCAX::Point3 apex = cone.Apex();
	CHECK(apex.X() == 0.0);
	CHECK(apex.Y() == 0.0);
	CHECK(apex.Z() == Approx(-5.0));
	AMCAX::Axis3 axis = cone.Axis();
	std::cout << axis.Direction().X() << std::endl;
	std::cout << axis.Direction().Y() << std::endl;
	std::cout << axis.Direction().Z() << std::endl;
	CHECK(axis.Direction().X() == 0.0);
	CHECK(axis.Direction().Y() == 0.0);
	CHECK(axis.Direction().Z() == 1.0);
	double a1, a2, a3, b1, b2, b3, c1, c2, c3, d;
	cone.Coefficients(a1, a2, a3, b1, b2, b3, c1, c2, c3, d);
	std::cout << "a1: " << a1 << ", a2: " << a2 << ", a3: " << a3 << std::endl;
	std::cout << "b1: " << b1 << ", b2: " << b2 << ", b3: " << b3 << std::endl;
	std::cout << "c1: " << c1 << ", c2: " << c2 << ", c3: " << c3 << std::endl;
	std::cout << "d: " << d << std::endl;
	CHECK(a1 == 1.0);
	CHECK(a2 == 1.0);
	CHECK(a3 == Approx(-1.0));
	CHECK(b1 == 0);
	CHECK(b2 == 0);
	CHECK(b3 == 0);
	CHECK(c1 == 0);
	CHECK(c2 == 0);
	CHECK(c3 == Approx(-5.0));
	CHECK(d == -25.0);
	CHECK(cone.IsDirect() == true);
	CHECK(cone.Location().X() == 0.0);
	CHECK(cone.Location().Y() == 0.0);
	CHECK(cone.Location().Z() == 0.0);
	AMCAX::PointT<double, 3>mirrorPoint(5.0, 0.0, 0.0);
	cone.Mirror(mirrorPoint);
	auto mirroredLocation = cone.Location();
	CHECK(mirroredLocation.X() == 10.0);
	CHECK(mirroredLocation.Y() == 0.0);
	CHECK(mirroredLocation.Z() == 0.0);
	AMCAX::Frame3 coneFrame = cone.Position();
	CHECK(frame.Location().X() == 0.0);
	CHECK(frame.Location().Y() == 0.0);
	CHECK(frame.Location().Z() == 0.0);
	CHECK(cone.Radius() == 5.0);
	double  scaleCone = 2.0;
	cone.Scale(cone.Location(), scaleCone);
	CHECK(cone.Radius() == radius * 2.0);
	double semiCone = cone.SemiAngle();
	CHECK(semiCone == Approx(0.785398));
	const  Frame3& position = cone.Position();
	std::cout << position.XAxis() << std::endl;
	std::cout << position.YAxis() << std::endl;
	Direction3 zDirection(0.0, 0.0, 1.0);
	AMCAX::Point3  centerCone(0.0, 0.0, 0.0);
	Axis3 zAxis(centerCone, zDirection);
	cone.Rotated(zAxis, angle);
	AMCAX::Frame3 coneFrame2 = cone.Position();
	CHECK(coneFrame.Location().X() == 10.0);
	CHECK(coneFrame.Location().Y() == 0.0);
	CHECK(coneFrame.Location().Z() == 0.0);
	double scale = 2.0;
	cone.Scale(centerCone, scale);
	CHECK(cone.Radius() == radius * 4.0);
	double semiAngle = cone.SemiAngle();
	std::cout << semiAngle << std::endl;
	CHECK(semiAngle == Approx(0.785398));
	VectorT<double, 3> translationVector(5.0, 5.0, 0.0);
	cone.Translate(translationVector);
	CHECK(cone.Location().X() == 25.0);
	CHECK(cone.Location().Y() == 5.0);
	CHECK(cone.Location().Z() == 0.0);
	auto xAxis = cone.XAxis();
	auto yAxis = cone.YAxis();
	CHECK(xAxis.Direction().X() == Approx(-1.0));
	CHECK(yAxis.Direction().Y() == Approx(-1.0));
	AMCAX::Transformation3 tr;
	tr.SetTranslation(Vector3(1.0, 2.0, 3.0));
	cone.Transform(tr);
	Axis3 newXAxis = cone.Position().XAxis();
	CHECK(newXAxis.Location().X() == 26.0);
	CHECK(newXAxis.Location().Y() == 7.0);
	CHECK(newXAxis.Location().Z() == 3.0);
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":Geom3Ellipse()	 @brief Default constructor
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <common/FrameT.hpp>
#include <math/EllipseT.hpp>
#include <geometry/Geom3Ellipse.hpp>
using namespace AMCAX;
using namespace std;
TEST_CASE("case1:this is a case for Test Geom3Ellipse", "[math][Geom3Ellipse][P1]")
{
	Frame3 frame;
	double major = 5.0;
	double minor = 4.0;
	Ellipse3 ellipse(frame, major, minor);
	Geom3Ellipse g3e(ellipse);
	SECTION("FocalParameter")
	{
		double FP = g3e.FocalParameter();
		double focal = 2 * sqrt(major * major - minor * minor);
		double fp = 2 * minor * minor / focal;;
		CHECK(FP == fp);
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API explicit Geom3Ellipse(const Ellipse3& e)	 @param e The ellipse
	 @brief Construct from an ellipse
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <common/FrameT.hpp>
#include <math/EllipseT.hpp>
#include <geometry/Geom3Ellipse.hpp>
using namespace AMCAX;
using namespace std;
TEST_CASE("case1:this is a case for Test Geom3Ellipse", "[math][Geom3Ellipse][P1]")
{
	Frame3 frame;
	double major = 5.0;
	double minor = 4.0;
	Ellipse3 ellipse(frame, major, minor);
	Geom3Ellipse g3e(ellipse);
	SECTION("FocalParameter")
	{
		double FP = g3e.FocalParameter();
		double focal = 2 * sqrt(major * major - minor * minor);
		double fp = 2 * minor * minor / focal;;
		CHECK(FP == fp);
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API Geom3Ellipse(const Frame3& frame, double major, double minor)	 @param minor The minor radius
	 @param major The major radius
	 @param frame The local frame
	 @brief Construct from a local frame, a major radius and a minor radius
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <common/FrameT.hpp>
#include <math/EllipseT.hpp>
#include <geometry/Geom3Ellipse.hpp>
using namespace AMCAX;
using namespace std;
TEST_CASE("case1:this is a case for Test Geom3Ellipse", "[math][Geom3Ellipse][P1]")
{
	Frame3 frame;
	double major = 5.0;
	double minor = 4.0;
	Ellipse3 ellipse(frame, major, minor);
	Geom3Ellipse g3e(ellipse);
	SECTION("FocalParameter")
	{
		double FP = g3e.FocalParameter();
		double focal = 2 * sqrt(major * major - minor * minor);
		double fp = 2 * minor * minor / focal;;
		CHECK(FP == fp);
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API Geom3Ellipse(const Frame3& frame, double major, double minor)	 @param minor The minor radius
	 @param major The major radius
	 @param frame The local frame
	 @brief Construct from a local frame, a major radius and a minor radius
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <geometry/MakeGeom3Ellipse.hpp>
#include <common/DirectionT.hpp>
#include <common/PointT.hpp>
#include <common/Precision.hpp>
#include <topology/TopoEdge.hpp>
#include <topology/TopoWire.hpp>
#include <topology/TopoFace.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeWire.hpp>
#include <modeling/MakeFace.hpp>
#include <modeling/MakePrism.hpp>
#include <topomesh/BRepMeshIncrementalMesh.hpp>
#include <topology/TopoExplorerTool.hpp>
#include <topology/TopoExplorer.hpp>
#include <topology/TopoCast.hpp>
#include <topology/TopoTool.hpp>
#include <math/TriangularMesh.hpp>
using namespace AMCAX;
TEST_CASE("bug1: MakeGeom3Ellipse ", "[geometry][MakeGeom3Ellipse][fixbug]") {
	MakeGeom3Ellipse makeEllipse(Frame3(), 3.0, 1.0);
	std::shared_ptr<Geom3Curve> curve = makeEllipse.Value();
	TopoEdge e = MakeEdge(curve);
	TopoWire w = MakeWire(e);
	TopoFace f = MakeFace(w);
	TopoShape s = MakePrism(f, Vector3(0.0, 0.0, 1.0));
	BRepMeshIncrementalMesh mesher(s, 0.005, true);
	int counttest = 0;
	for (TopoExplorer ex(s, ShapeType::Face); ex.More(); ex.Next())
	{
		const auto& face = TopoCast::Face(ex.Current());
		TopoLocation l;
		auto tri = TopoTool::Triangulation(face, l);
		CHECK(tri); 
		if (tri)
		{
			counttest = counttest + 1;
			if (counttest == 1)
			{
				CHECK(tri->NVertices() == 84);
				CHECK(tri->NTriangles() == 82);
			}
			if (counttest == 2)
			{
				CHECK(tri->NVertices() == 41);
				CHECK(tri->NTriangles() == 39);
			}
			if (counttest == 3)
			{
				CHECK(tri->NVertices() == 41);
				CHECK(tri->NTriangles() == 39);
			}
		}
	}
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API explicit Geom3Hyperbola(const Hyperbola3& h)	 @param h The hyperbola
	 @brief Construct from an hyperbola
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <math/EllipseT.hpp>
#include <geometry/Geom3Hyperbola.hpp>
using namespace AMCAX;
using namespace std;
TEST_CASE("case1:this is a case for Test Geom3Hyperbola", "[math][Geom3Hyperbola][P1]")
{
	Frame3 frame;
	double major = 5.0;
	double minor = 4.0;
	Geom3Hyperbola g3h(frame, major, minor);
	SECTION("SemilatusRectum")
	{
		double SR = g3h.SemilatusRectum();
		double sr = minor * minor / major;
		CHECK(SR == sr);
	}
}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API Geom3Hyperbola(const Frame3& frame, double major, double minor)	 @param minor The minor radius
	 @param major The major radius
	 @param frame The local frame
	 @brief Construct from a local frame, a major radius and a minor radius
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <math/EllipseT.hpp>
#include <geometry/Geom3Hyperbola.hpp>
using namespace AMCAX;
using namespace std;
TEST_CASE("case1:this is a case for Test Geom3Hyperbola", "[math][Geom3Hyperbola][P1]")
{
	Frame3 frame;
	double major = 5.0;
	double minor = 4.0;
	Geom3Hyperbola g3h(frame, major, minor);
	SECTION("FocalParameter")
	{
		double FP = g3h.FocalParameter();
		double focal = 2 * sqrt(major * major + minor * minor);
		double fp = 2 * minor * minor / focal;;
		CHECK(FP == fp);
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API void Coefficients(double& a, double& b, double& c, double& d)	 @param[out] a,b,c,d The coefficients
	 @brief Get coefficients of algebraic representation: ax + by + cz + d = 0
,
 "output":#include "catch.hpp"
#include <testHelper.h>
#include <math/Plane.hpp>
using namespace AMCAX;
TEST_CASE("case1: Plane construction and methods", "[math][Plane][p1]") {
	SECTION("Default constructor") {
        Plane plane;
        double a, b, c, d;
        plane.Coefficients(a, b, c, d);
        REQUIRE(a == Approx(0));
        REQUIRE(b == Approx(0));
        REQUIRE(c == Approx(1));
        REQUIRE(d == Approx(0));
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":Plane()	 Default constructor
,
 "output":#include "catch.hpp"
#include <testHelper.h>
#include <math/Plane.hpp>
using namespace AMCAX;
TEST_CASE("case1: Plane construction and methods", "[math][Plane][p1]") {
	SECTION("Default constructor") {
        Plane plane;
        double a, b, c, d;
        plane.Coefficients(a, b, c, d);
        REQUIRE(a == Approx(0));
        REQUIRE(b == Approx(0));
        REQUIRE(c == Approx(1));
        REQUIRE(d == Approx(0));
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API explicit Plane(const Frame3& frame)	 @param frame The local frame
	 @brief Construct from a local frame, XOY plane
,
 "output":#include "catch.hpp"
#include <testHelper.h>
#include <math/Plane.hpp>
using namespace AMCAX;
TEST_CASE("case1: Plane construction and methods", "[math][Plane][p1]") {
	SECTION("Construct from frame") {
        Frame3 frame1(Point3(0.0, 0.0, 0.0), Direction3(0.0, 0.0, 1.0));
        Frame3 frame2(Point3(1.0, 0.0, 0.0), Direction3(2.0, 1.0, 1.0));
        Plane plane1(frame1);
        Plane plane2(frame2);  
        double a1, b1, c1, d1;
        plane1.Coefficients(a1, b1, c1, d1);
        double a2, b2, c2, d2;
        plane2.Coefficients(a2, b2, c2, d2);
        REQUIRE(a1 == Approx(0));
        REQUIRE(b1 == Approx(0));
        REQUIRE(c1 == Approx(1));
        REQUIRE(d1 == Approx(0));
        REQUIRE(a2 == Approx(2. / std::sqrt(6)));
        REQUIRE(b2 == Approx(1. / std::sqrt(6)));
        REQUIRE(c2 == Approx(1. / std::sqrt(6)));
        REQUIRE(d2 == Approx(-2. / std::sqrt(6)));
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API Plane(const Point3& point, const Direction3& dir)	 @param dir The direction
	 @param point The point
	 @brief Construct from a point and a direction
,
 "output":#include "catch.hpp"
#include <testHelper.h>
#include <math/Plane.hpp>
using namespace AMCAX;
TEST_CASE("case1: Plane construction and methods", "[math][Plane][p1]") {
	SECTION("Construct from point and direction") {
        Point3 point(1., 1., 1.);
        Direction3 dir(0., 0., 1.);
        Plane plane(point, dir);  
        Point3 point2(3., 4., 4.);
        Direction3 dir2(2., 2., 1.);
        Plane plane2(point2, dir2);  
        double a, b, c, d;
        plane.Coefficients(a, b, c, d);
        double a2, b2, c2, d2;
        plane2.Coefficients(a2, b2, c2, d2);
        REQUIRE(a == Approx(0));
        REQUIRE(b == Approx(0));
        REQUIRE(c == Approx(1));
        REQUIRE(d == Approx(-1));
        REQUIRE(a2 == Approx(2./3).margin(0.0001));
        REQUIRE(b2 == Approx(2./3).margin(0.0001));
        REQUIRE(c2 == Approx(1./3).margin(0.0001));
        REQUIRE(d2 == Approx(-6));
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API Plane(double a, double b, double c, double d)	 @param a,b,c,d The coefficients
	 @brief Construct from an algebraic representation: ax + by + cz + d = 0
,
 "output":#include "catch.hpp"
#include <testHelper.h>
#include <math/Plane.hpp>
using namespace AMCAX;
TEST_CASE("case1: Plane construction and methods", "[math][Plane][p1]") {
	SECTION("Construct from algebraic representation") {
        Plane plane(1., 1., 1., -3.);  
        double a, b, c, d;
        plane.Coefficients(a, b, c, d);  
        REQUIRE(a == Approx(1./std::sqrt(3)).margin(0.001));
        REQUIRE(b == Approx(1. / std::sqrt(3)).margin(0.001));
        REQUIRE(c == Approx(1. / std::sqrt(3)).margin(0.001));
        REQUIRE(d == Approx(-3. / std::sqrt(3)).margin(0.001));
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] AMCAX_API bool Contains(const Point3& point, double tol)	 @return True if the distance between the point and the plane is under the distance tolerance
	 @param tol The distance tolerance
	 @param point The point
	 @brief Determines whether the plane contains a point under a tolerance or not
,
 "output":#include "catch.hpp"
#include <testHelper.h>
#include <math/Plane.hpp>
using namespace AMCAX;
TEST_CASE("case1: Plane construction and methods", "[math][Plane][p1]") {
	SECTION("Contains methods") {
        std::function<bool(const Plane&, const Point3&)> pointInPlane = [](const Plane& plane, const Point3& point)->bool {
            Point3 planePoint = plane.Location();  
            Vector3 planeVector(planePoint, point);  
            double a, b, c, d;
            plane.Coefficients(a, b, c, d);
            return planeVector.Dot(Vector3(a, b, c)) == 0;
        };
        Plane plane(0., 0., 1., -1.); 
        Point3 point(1., 1., 1.);
        Point3 point2(1., 1., 2.);
        Line3 line(Point3(1., 1., 1.), Direction3(1., 0., 0.));
        Line3 line2(Point3(1., 1., 1.), Direction3(0., 0., 1.));  
        Line3 line3(Point3(1., 1., 0.), Direction3(1., 0., 0.));
        REQUIRE(plane.Contains(point, 1e-6) == pointInPlane(plane, point));
        REQUIRE(plane.Contains(point2, 1e-6) == pointInPlane(plane, point2));
        REQUIRE(plane.Contains(line, 1e-6, 1e-6));
        REQUIRE_FALSE(plane.Contains(line2, 1e-6, 1e-6 * (M_PI / 180)));
        REQUIRE_FALSE(plane.Contains(line3, 1e-6, 1e-6 * (M_PI / 180)));
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API explicit GeomAPIIntCurveCurve2(const std::shared_ptr<Geom2Curve>& c1, double tol = 1.0e-6)	 @param tol The tolerance for computing self-intersection
	 @param c1 The curve
	 @brief Construct from one curve for finding self-intersections
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <sstream>
#include <geometry/GeomAPIIntCurveCurve2.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <common/PointT.hpp>
using namespace AMCAX;
TEST_CASE("bug1: GeomAPIIntCurveCurve2  add 1 cases", "[geometry][GeomAPIIntCurveCurve2][fixbug]") {
	std::shared_ptr<Geom2BSplineCurve> bs1 = std::make_shared<Geom2BSplineCurve>();
	std::shared_ptr<Geom2BSplineCurve> bs2 = std::make_shared<Geom2BSplineCurve>();
	std::string str1 = "7 0 0 3 118 116 0.32094859236148043 1.01737460557672743 0.32206087674542322 1.01734745284654182 0.32382938579023346 1.01745552974970388 0.32622057752030481 1.01788932455950976 0.32814024437537276 1.01839643017089987 0.33002743385020250 1.01906060903165452 0.33185490242395432 1.01986927403602690 0.33356030574937923 1.02078382513330879 0.33505523022905437 1.02172426942215600 0.33630356053380972 1.02261635998227951 0.33727879099865676 1.02338700329485177 0.33824387261988464 1.02421002336103761 0.33987143181385676 1.02571995716873454 0.34214827935107528 1.02826048315421636 0.34461603767621785 1.03183954355064644 0.34665036808905569 1.03570920433382874 0.34820760193471290 1.03964073803085988 0.34933771881337422 1.04355887677937265 0.35009685624211401 1.04745091431990089 0.35052967495496640 1.05132419100513896 0.35066857936404372 1.05518894219017056 0.35052557522962369 1.05904245911643380 0.35008366013718967 1.06287636600114777 0.34929841370764381 1.06667869354746858 0.34813822094610908 1.07042299939338448 0.34675750395147792 1.07412664136932645 0.34534310541281921 1.07786690172476352 0.34358161112094421 1.08147777823012681 0.34192774635989071 1.08514486567176727 0.34024883979957521 1.08877932697709046 0.33856258005747963 1.09239630776272234 0.33684922584157972 1.09599070530577980 0.33511401239025801 1.09956576491048708 0.33335775759028152 1.10312101734871382 0.33158157690922768 1.10665621463276231 0.32978475270252700 1.11017051339371275 0.32796684236813672 1.11366345386663435 0.32612725706778090 1.11713471339148707 0.32426602655273468 1.12058421069008607 0.32238317488364737 1.12401188835076016 0.32047891905305792 1.12741748347385329 0.31855350786840358 1.13080068581386772 0.31660697714151498 1.13416123619352938 0.31463922025518198 1.13749923563291944 0.31264987984545162 1.14081514934997053 0.31063848196500760 1.14410959402646872 0.30860463164217128 1.14738321401338195 0.30654793927361806 1.15063653610177630 0.30446802732993405 1.15386990664646771 0.30236451953097970 1.15708359051903131 0.30023708628717172 1.16027763956461594 0.29808538476977109 1.16345202237806822 0.29590934129126883 1.16660648017917135 0.29370889405197392 1.16974079885919968 0.29148391413490155 1.17285470277829651 0.28923416621699150 1.17594813233618023 0.28695938621068906 1.17902112690429606 0.28465933895561080 1.18207371247860404 0.28233386645185193 1.18510589143436862 0.27998289479713001 1.18811761370470093 0.27760632123816548 1.19110879993250829 0.27520390350264767 1.19407947381928281 0.27277523052158237 1.19702979458848002 0.27031974327907626 1.19995999134850062 0.26783696716142708 1.20287004707951173 0.26532688195672521 1.20575953789980805 0.26278972678816304 1.20862781671414088 0.26022529469643624 1.21147474893699236 0.25763217763048496 1.21430150477218790 0.25500825126397131 1.21710994249041904 0.25235292985377017 1.21990005059103868 0.24966926670272568 1.22266796329330352 0.24696150391975732 1.22540882939352413 0.24423004526152650 1.22812190210150329 0.24146125706394184 1.23081996151861128 0.23861784080316129 1.23353765899792966 0.23566141121739081 1.23630795850379083 0.23313267974624646 1.23863075403103817 0.23108077081313610 1.24048682151979905 0.22951564660225790 1.24188808346222479 0.22785243018268259 1.24336238482365724 0.22603998536410663 1.24495322387069107 0.22406854105345719 1.24666425686480453 0.22194392374121000 1.24848570059305053 0.21966929759239204 1.25041206987825992 0.21725182330646176 1.25242961584586521 0.21469769930661789 1.25453321201678158 0.21201305169290471 1.25670455099802481 0.20919423964305814 1.25892740388225111 0.20624946264626334 1.26119206481064094 0.20318480037069683 1.26348679862854585 0.20000837020587425 1.26579929017010295 0.19672786860887337 1.26811801505294564 0.19336384906039994 1.27045063232052602 0.18992974310269095 1.27279484301208434 0.18643645229630731 1.27514361933883413 0.18288284026026952 1.27747988214753017 0.17926432420455884 1.27979154638979287 0.17557650128119320 1.28206361390544510 0.17182058886568480 1.28428512148975549 0.16804984196678602 1.28645557821983747 0.16432856924206579 1.28857394891545374 0.16070988708733733 1.29064090195652370 0.15717518220101778 1.29262871928824441 0.15369583278895632 1.29452720045016001 0.15026398879500619 1.29632707889676935 0.14689767435611573 1.29803910611286755 0.14368667318979397 1.29963940415365520 0.14066793270237543 1.30110806215344477 0.13786588940702740 1.30241800503027294 0.13522308508227587 1.30359724798135068 0.13268958893136670 1.30462396744174369 0.13022457745464813 1.30549794019590903 0.12782549497702861 1.30621459673763263 0.12551678736811231 1.30677267551026310 0.12264034969535306 1.30729452653584777 0.12051776185100731 1.30747541630908004 0.11912669923861925 1.30748468412943986 0.00000000000000000 4 0.00332678777314067 1 0.00530015559541836 1 0.00728182036673812 1 0.00927733380420748 1 0.01129573787307914 1 0.01327102124276026 1 0.01507750651120846 1 0.01659037664031113 1 0.01787187841143642 1 0.01880519345805253 1 0.02039488120903255 1 0.02452963651417061 1 0.02900897063209700 1 0.03340295596517878 1 0.03761684169382203 1 0.04167362563339645 1 0.04561938121714045 1 0.04949884613367380 1 0.05335394957604591 1 0.05721079085185987 1 0.06105670932975029 1 0.06491896046411526 1 0.06884011522460366 1 0.07280266881291077 1 0.07677853454115921 1 0.08082727159450992 1 0.08484703393156430 1 0.08884800850224144 1 0.09283736315162679 1 0.09681928451811667 1 0.10079344442245329 1 0.10475903456581770 1 0.10871533221895527 1 0.11266230101625047 1 0.11659995734938959 1 0.12052830686968952 1 0.12444792190998373 1 0.12835862681996368 1 0.13226049935437312 1 0.13615329767464079 1 0.14003667398886835 1 0.14391115976349200 1 0.14777767334262687 1 0.15163719748113480 1 0.15549084375107922 1 0.15933948557025243 1 0.16318380109489106 1 0.16702443368061037 1 0.17086206197732215 1 0.17469676853931951 1 0.17852903287965541 1 0.18235853795986209 1 0.18618547107174704 1 0.19001029311391093 1 0.19383342115543040 1 0.19765535049879729 1 0.20147647336026475 1 0.20529702393677510 1 0.20911722784810613 1 0.21293746918119616 1 0.21675849605951392 1 0.22058118324198547 1 0.22440637655431431 1 0.22823412013034025 1 0.23206350223258385 1 0.23589437276278422 1 0.23972883230279066 1 0.24357130772232163 1 0.24742464110863499 1 0.25128370603023881 1 0.25513705909052109 1 0.25898297113943686 1 0.26283319300761221 1 0.26673478756179048 1 0.27078270046115210 1 0.27498764230925066 1 0.27703550353465400 1 0.27908314380440813 1 0.28128986356810332 1 0.28370321223532124 1 0.28631785618959721 1 0.28912103899968400 1 0.29209869219406109 1 0.29526001444575162 1 0.29856723628509552 1 0.30202524340776099 1 0.30561830049238314 1 0.30933640124059564 1 0.31316962603536763 1 0.31710368845632919 1 0.32112310784334058 1 0.32522104893482329 1 0.32938444032265624 1 0.33359681084096160 1 0.33784938027078792 1 0.34214253792603233 1 0.34647801531348960 1 0.35084331838884097 1 0.35523312810758656 1 0.35953028089402317 1 0.36368926465670970 1 0.36773529430744634 1 0.37169603595072809 1 0.37557957415417503 1 0.37936041511409840 1 0.38302581855344769 1 0.38634253837102683 1 0.38943124796238249 1 0.39230486518080748 1 0.39502350628500010 1 0.39762992993310575 1 0.40014797436892702 1 0.40253156052235123 1 0.40475213727501114 1 0.40891189273334161 4";
	std::string str2 = "7 0 0 3 118 116 0.44698587761425512 1.01737460557672743 0.44586770461012754 1.01734792256404072 0.44408669680926910 1.01745649198371058 0.44167433575859827 1.01788973448550668 0.43973012306214176 1.01839676158274872 0.43781512528503469 1.01906078430998237 0.43595772107855257 1.01986941991017832 0.43422167753434071 1.02078367982801188 0.43270019179331992 1.02172276730688871 0.43143529102668837 1.02260881639260637 0.43047395316133663 1.02337915724656336 0.42956918011417972 1.02417518983407696 0.42818486699350283 1.02596609318184684 0.42535867595845256 1.02808829688484948 0.42284370487027889 1.03193726498772675 0.42029420450207700 1.03578860458891087 0.41779215915839102 1.03971518009696795 0.41524996629274769 1.04360952276868124 0.41268259846706867 1.04748256529635642 0.41009244215779894 1.05134004607881448 0.40748344575385259 1.05519270420095079 0.40486605902395167 1.05904184662506151 0.40221826431976609 1.06286057810161427 0.39954731386633807 1.06664354970287856 0.39685998643058945 1.07039722937908555 0.39415205518567858 1.07412233241535748 0.39142459506816268 1.07782095032413006 0.38867831705369166 1.08149595009323263 0.38591346143208760 1.08514964980580220 0.38313020259072789 1.08878346979564511 0.38032844124366111 1.09239780218286464 0.37750825751929029 1.09599269297900204 0.37466975732311525 1.09956803650327561 0.37181298113969291 1.10312349001628252 0.36893792871143949 1.10665859650325404 0.36604460396156768 1.11017278012274700 0.36313313466979064 1.11366550770546358 0.36020385654578302 1.11713665503127646 0.35725711512561398 1.12058603617284369 0.35429324377611354 1.12401373368655166 0.35131230158758986 1.12741939957610104 0.34831421468687968 1.13080262402140796 0.34529890614255510 1.13416313676223202 0.34226629246633017 1.13750078799254517 0.33921704684458587 1.14081632451049253 0.33615179652790328 1.14411040925898311 0.33307117902797256 1.14738370759211961 0.32997572188237095 1.15063676015840910 0.32686583766548316 1.15386986351118148 0.32374192911050353 1.15708326206532552 0.32060452465855971 1.16027718535470581 0.31745360371300196 1.16345153388182476 0.31428913900094868 1.16660594252951411 0.31111112410899561 1.16974020701489989 0.30791955045097874 1.17285394667146026 0.30471460628308072 1.17594719675858417 0.30149648916692096 1.17901999285247383 0.29826547554743049 1.18207244366664344 0.29502169193428479 1.18510458595828827 0.29176503889034477 1.18811625270052801 0.28849545711393992 1.19110735246150123 0.28521287446926513 1.19407776448826497 0.28191760121088905 1.19702778959143030 0.27860991172799571 1.19995767798350750 0.27529017147185769 1.20286775332443230 0.27195821134041676 1.20575742910935957 0.26861365400632170 1.20862591999664737 0.26525581006410243 1.21147208574228693 0.26188571532285843 1.21429744804454320 0.25850537979441068 1.21710464921168948 0.25511712957007160 1.21989678109210420 0.25171762413613974 1.22266823849310202 0.24830072265899519 1.22540963473078257 0.24486605329372579 1.22811942696225307 0.24141572018592131 1.23080424790172627 0.23796057988059283 1.23349025995382422 0.23455481289528443 1.23625809731511249 0.23178384866187560 1.23861884218329443 0.22958637070091326 1.24049429822100898 0.22792095077852323 1.24183892665189632 0.22633085712869647 1.24330474335321250 0.22482706539293790 1.24489950308425112 0.22341229813088337 1.24661390687506479 0.22209453169097026 1.24843902517094874 0.22087888937927413 1.25036828651214238 0.21977124333451431 1.25238938953827761 0.21877814583739183 1.25449449573067429 0.21790282053379528 1.25666553458695951 0.21714464814126716 1.25889056843647418 0.21650897231276728 1.26115706505645897 0.21599821380382661 1.26345359947659142 0.21561431786668875 1.26576891766763566 0.21535790133274418 1.26809712034575073 0.21523156999800702 1.27043621478677027 0.21523493789335055 1.27278382859372918 0.21536761702246404 1.27513094567987695 0.21562960091705158 1.27746540211106607 0.21601986302685286 1.27977480962963663 0.21653701136757098 1.28204820066314440 0.21718164535537912 1.28428355977126407 0.21795318927362628 1.28647141444648527 0.21885182671844836 1.28860254299760535 0.21987018385314080 1.29066214545958857 0.22100473503305496 1.29264388729952517 0.22225426990375063 1.29454179066819441 0.22361918358992602 1.29635228361390098 0.22510542017288909 1.29807648877092108 0.22668582626421535 1.29967791748795536 0.22833572049978873 1.30113992652563426 0.23002054288496601 1.30245118636949164 0.23175614453859494 1.30361712921158590 0.23353904515484103 1.30463669825309792 0.23536790944712538 1.30550821214031298 0.23723013129137352 1.30622515706156905 0.23909802022459714 1.30677963590280544 0.24158931746901185 1.30731428646199599 0.24348144169383945 1.30748511863814065 0.24475247407226391 1.30748468412943986 0.00000000000000000 4 0.00334434293035562 1 0.00533825930397336 1 0.00734412586267121 1 0.00936623440575543 1 0.01141256205459959 1 0.01341573096600146 1 0.01524709020284723 1 0.01677336277701813 1 0.01804490068923616 1 0.01894326352103789 1 0.02037993823386658 1 0.02480566898074880 1 0.02939205655814846 1 0.03404043378943207 1 0.03869805978018042 1 0.04334980332413108 1 0.04799487443159717 1 0.05263737365801836 1 0.05728913631958347 1 0.06195364423015201 1 0.06660152728460191 1 0.07122956329812886 1 0.07584610283920201 1 0.08045084571229059 1 0.08504550471877484 1 0.08963256787874113 1 0.09421407873103112 1 0.09879117107574811 1 0.10336422781387057 1 0.10793330889559200 1 0.11249839490034602 1 0.11705945929549585 1 0.12161613091223618 1 0.12616821278487000 1 0.13071541215010135 1 0.13525724181627602 1 0.13979405378099050 1 0.14432538686178745 1 0.14885137954117900 1 0.15337193703905613 1 0.15788673904588241 1 0.16239626042792893 1 0.16690070771036525 1 0.17140021344792761 1 0.17589510396468730 1 0.18038552504431565 1 0.18487151865902063 1 0.18935308684053462 1 0.19383026236900400 1 0.19830276789454376 1 0.20277103974370816 1 0.20723457084840083 1 0.21169339151646616 1 0.21614758290681596 1 0.22059709488399620 1 0.22504193032631326 1 0.22948214264998190 1 0.23391784916535033 1 0.23834913245589026 1 0.24277612072013041 1 0.24719890919114179 1 0.25161757662768108 1 0.25603221057958453 1 0.26044282613505232 1 0.26484890217770901 1 0.26925063819864326 1 0.27364813118187725 1 0.27804209715833189 1 0.28243253716855193 1 0.28681951085634216 1 0.29120020890283443 1 0.29557446914500052 1 0.29994411461100146 1 0.30431579875993647 1 0.30870332268475420 1 0.31310853612917888 1 0.31523624508228770 1 0.31737014111002310 1 0.31952856178681960 1 0.32171830465981011 1 0.32394102970905830 1 0.32619217521253946 1 0.32846706602101300 1 0.33077763413829298 1 0.33310205916533187 1 0.33544576479270716 1 0.33779655322040053 1 0.34015052354015518 1 0.34250407705161767 1 0.34485099381932000 1 0.34718783135835085 1 0.34952735554083242 1 0.35187486439618521 1 0.35422711580943594 1 0.35657637606518838 1 0.35891858548088795 1 0.36124990679045155 1 0.36356703547085450 1 0.36589411785453302 1 0.36820554269186456 1 0.37050138589761700 1 0.37278277874756854 1 0.37505181955993466 1 0.37731379776658153 1 0.37958010527703534 1 0.38187591368213569 1 0.38405827564667433 1 0.38618898795548318 1 0.38827607822097537 1 0.39032555279796965 1 0.39234499730597777 1 0.39434796008648582 1 0.39630575790533801 1 0.39818438284552959 1 0.40198436891082029 4";
	std::istringstream iss1(str1);
	std::istringstream iss2(str2);
	iss1 >> *bs1;
	iss2 >> *bs2;
	GeomAPIIntCurveCurve2 icc(bs1, bs2, 1e-12);
	CHECK(icc.NPoints() == 2);
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static bool IsPlanarCurve(const std::shared_ptr<Geom3Curve>& c, Plane& plane, double tol = 1.0e-7)	 @return True if the curve is a planar curve
	 @param tol The tolerance
	 @param plane The plane found when the curve is planar curve
	 @param c The input curve
	 @details If the input curve, such as a line, is on more than one plane, it will return the plane in which any one is located
	 @brief Check if a 3D curve is a planar curve, and if it is planar, find the plane
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <geometry/GeometryTool.hpp>
#include <geometry/Geom2BezierCurve.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/MakeArcOfCircle2d.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <modeling/MakeEdge.hpp>
#include<modeling/MakeEdge2d.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
#include <geometry/Geom3Circle.hpp>
using namespace AMCAX;
std::shared_ptr<Geom2BezierCurve> MakeBezierCurve2d()
{
	std::vector<Point2> poles(4);
	poles[0].SetCoord(1.0, 0.0);
	poles[1].SetCoord(2.0, 1.0);
	poles[2].SetCoord(3.0, -1.0);
	poles[3].SetCoord(4.0, 0.0);
	return std::make_shared<Geom2BezierCurve>(poles);
}
std::shared_ptr<Geom2BSplineCurve> MakeBSplineCurve2d()
{
	std::vector<Point2> poles(7);
	poles[0].SetCoord(0.5, 0.5);
	poles[1].SetCoord(1.0, 3.0);
	poles[2].SetCoord(3.0, 1.0);
	poles[3].SetCoord(3.8, 2.0);
	poles[4].SetCoord(2.5, 3.5);
	poles[5].SetCoord(1.0, 0.5);
	poles[6].SetCoord(0.3, 2.0);
	std::vector<double> knots = { 0.0, 0.25, 0.5, 0.75, 1.0 };
	std::vector<int> mults = { 4, 1, 1, 1, 4 };
	return std::make_shared<Geom2BSplineCurve>(poles, knots, mults, 3);
}
std::shared_ptr<Geom3BSplineCurve> MakeBSplineCurve3d(int degree, bool rational)
{
	if (degree == 3)
	{
		std::vector<Point3> poles(7);
		poles[0].SetCoord(0.5, 0.5, 0.3);
		poles[1].SetCoord(1.0, 3.0, 0.4);
		poles[2].SetCoord(3.0, 1.0, 0.1);
		poles[3].SetCoord(3.8, 2.0, 0.6);
		poles[4].SetCoord(2.5, 3.5, 0.8);
		poles[5].SetCoord(1.0, 0.5, 0.9);
		poles[6].SetCoord(0.3, 2.0, 0.5);
		std::vector<double> weights = { 1.0, 2.0, 3.0, 4.0, 3.0, 2.0, 1.0 };
		std::vector<double> knots = { 0.0, 0.25, 0.5, 1.0 };
		std::vector<int> mults = { 4, 1, 2, 4 };
		return rational ? std::make_shared<Geom3BSplineCurve>(poles, weights, knots, mults, 3)
			: std::make_shared<Geom3BSplineCurve>(poles, knots, mults, 3);
	}
	else if (degree == 2)
	{
		std::vector<Point3> poles(6);
		poles[0].SetCoord(0.5, 0.5, 0.3);
		poles[1].SetCoord(1.0, 3.0, 0.4);
		poles[2].SetCoord(3.0, 1.0, 0.1);
		poles[3].SetCoord(3.8, 2.0, 0.6);
		poles[4].SetCoord(2.5, 3.5, 0.8);
		poles[5].SetCoord(1.0, 0.5, 0.9);
		std::vector<double> weights = { 1.0, 2.0, 3.0, 4.0, 3.0, 2.0 };
		std::vector<double> knots = { 0.0, 0.25, 0.5, 1.0 };
		std::vector<int> mults = { 3, 1, 2, 3 };
		return rational ? std::make_shared<Geom3BSplineCurve>(poles, weights, knots, mults, 2)
			: std::make_shared<Geom3BSplineCurve>(poles, knots, mults, 2);
	}
	return nullptr;
}
TEST_CASE("case2: IsPlanarCurve dev case ", "[geometry][IsPlanarCurve][P1]")
{
	shared_ptr<Geom3BSplineCurve> curve3 = MakeBSplineCurve3d(3,true) ;
	Plane plane;
	CHECK(GeometryTool::IsPlanarCurve(curve3, plane) == false);
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API MakeArcOfCircle2d(const Point2& p1, const Vector2& v, const Point2& p2)	 @param p2 The end point
	 @param v The tangent vector at p1
	 @param p1 The start point
	 @brief Construct an arc of circle from two points p1, p2 and a tangent vector v at p1
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/VectorT.hpp>
#include <common/PointT.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/MakeArcOfCircle2d.hpp>
#include <sstream>
using namespace AMCAX;
TEST_CASE("bug1: MakeArcOfCircle2d  add 1 cases", "[geomAlgo][MakeArcOfCircle2d][fixbug]") {
	std::stringstream output;
	std::shared_ptr<Geom2TrimmedCurve> c = MakeArcOfCircle2d(Point2(0.0, 1.0), Vector2(1.0, 0.0), Point2(1.0, 0.0));
	std::cout << *c << std::endl;
	output << *c << std::endl;
	auto case1 = output.str();
	auto expect1 = "8 4.71239 6.28319";
	auto expect2 = "2 0 -0 1 0 0 -1 1";
	CHECK(case1.find(expect1) != std::string::npos);
	CHECK(case1.find(expect2) != std::string::npos);
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API MakeGeom3Ellipse(const Frame3& frame, double majorRadius, double minorRadius)	 @param minorRadius The minor radius
	 @param majorRadius The major radius
	 @param frame The local frame
	 @brief Construct an ellipse from a local frame, a major radius and a minor radius
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <geometry/MakeGeom3Ellipse.hpp>
#include <common/DirectionT.hpp>
#include <common/PointT.hpp>
#include <common/Precision.hpp>
#include <topology/TopoEdge.hpp>
#include <topology/TopoWire.hpp>
#include <topology/TopoFace.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeWire.hpp>
#include <modeling/MakeFace.hpp>
#include <modeling/MakePrism.hpp>
#include <topomesh/BRepMeshIncrementalMesh.hpp>
#include <topology/TopoExplorerTool.hpp>
#include <topology/TopoExplorer.hpp>
#include <topology/TopoCast.hpp>
#include <topology/TopoTool.hpp>
#include <math/TriangularMesh.hpp>
using namespace AMCAX;
TEST_CASE("bug1: MakeGeom3Ellipse ", "[geometry][MakeGeom3Ellipse][fixbug]") {
	MakeGeom3Ellipse makeEllipse(Frame3(), 3.0, 1.0);
	std::shared_ptr<Geom3Curve> curve = makeEllipse.Value();
	TopoEdge e = MakeEdge(curve);
	TopoWire w = MakeWire(e);
	TopoFace f = MakeFace(w);
	TopoShape s = MakePrism(f, Vector3(0.0, 0.0, 1.0));
	BRepMeshIncrementalMesh mesher(s, 0.005, true);
	int counttest = 0;
	for (TopoExplorer ex(s, ShapeType::Face); ex.More(); ex.Next())
	{
		const auto& face = TopoCast::Face(ex.Current());
		TopoLocation l;
		auto tri = TopoTool::Triangulation(face, l);
		CHECK(tri); 
		if (tri)
		{
			counttest = counttest + 1;
			if (counttest == 1)
			{
				CHECK(tri->NVertices() == 84);
				CHECK(tri->NTriangles() == 82);
			}
			if (counttest == 2)
			{
				CHECK(tri->NVertices() == 41);
				CHECK(tri->NTriangles() == 39);
			}
			if (counttest == 3)
			{
				CHECK(tri->NVertices() == 41);
				CHECK(tri->NTriangles() == 39);
			}
		}
	}
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API MakeGeom3Ellipse(const Point3& s1, const Point3& s2, const Point3& center)	 @param center The center point
	 @param s2 The point on the minor axis
	 @param s1 The point on the major axis
	 @brief Construct an ellipse from two points on the major and minor axis, and a center point
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <geometry/MakeGeom3Ellipse.hpp>
#include <common/DirectionT.hpp>
#include <common/PointT.hpp>
#include <common/Precision.hpp>
#include <topology/TopoEdge.hpp>
#include <topology/TopoWire.hpp>
#include <topology/TopoFace.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeWire.hpp>
#include <modeling/MakeFace.hpp>
#include <modeling/MakePrism.hpp>
#include <topomesh/BRepMeshIncrementalMesh.hpp>
#include <topology/TopoExplorerTool.hpp>
#include <topology/TopoExplorer.hpp>
#include <topology/TopoCast.hpp>
#include <topology/TopoTool.hpp>
#include <math/TriangularMesh.hpp>
using namespace AMCAX;
TEST_CASE("bug1: MakeGeom3Ellipse ", "[geometry][MakeGeom3Ellipse][fixbug]") {
	MakeGeom3Ellipse makeEllipse(Frame3(), 3.0, 1.0);
	std::shared_ptr<Geom3Curve> curve = makeEllipse.Value();
	TopoEdge e = MakeEdge(curve);
	TopoWire w = MakeWire(e);
	TopoFace f = MakeFace(w);
	TopoShape s = MakePrism(f, Vector3(0.0, 0.0, 1.0));
	BRepMeshIncrementalMesh mesher(s, 0.005, true);
	int counttest = 0;
	for (TopoExplorer ex(s, ShapeType::Face); ex.More(); ex.Next())
	{
		const auto& face = TopoCast::Face(ex.Current());
		TopoLocation l;
		auto tri = TopoTool::Triangulation(face, l);
		CHECK(tri); 
		if (tri)
		{
			counttest = counttest + 1;
			if (counttest == 1)
			{
				CHECK(tri->NVertices() == 84);
				CHECK(tri->NTriangles() == 82);
			}
			if (counttest == 2)
			{
				CHECK(tri->NVertices() == 41);
				CHECK(tri->NTriangles() == 39);
			}
			if (counttest == 3)
			{
				CHECK(tri->NVertices() == 41);
				CHECK(tri->NTriangles() == 39);
			}
		}
	}
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static bool IsSolidBounded(const TopoSolid& s)	 @return True if the solid and the solid is bounded (The infinite point is outside);
	 @param s The solid
	 @brief Classify whether the solid is bounded (The infinite point is outside)
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <io/ShapeTool.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <occtio/OCCTTool.hpp>
#include <topology/TopoShape.hpp>
#include <topology/TopoSolid.hpp>
#include <modeling/MakeSolid.hpp>
#include <modeling/MakeCylinder.hpp>
#include <boolean/BoolBRepFuse.hpp>
#include <boolean/BoolBRepCut.hpp>
#include <topomesh/BRepMeshIncrementalMesh.hpp>
#include <io/OBJTool.hpp>
#include <hatch/BRepSolidClassifier.hpp>
#include <healing/ShapeFixTool.hpp>
using namespace AMCAX;
bool ImpInSolid1(const Point3& pt)
{
	Point3 pc1(849.32865292949998, -105.60711735517, 528.53715478963011);
	Coord3 cs1 = pt.Coord() - pc1.Coord();
	bool isSolidIn1 = pt.Y() < 29.654882644830003 && pt.Y() > -105.60711735517 && (cs1.X() * cs1.X() + cs1.Z() * cs1.Z()) < 5.415 * 5.415;
	Point3 pc2(849.32865292763006, 12.992882644829002, 528.53715479109997);
	Coord3 cs2 = pt.Coord() - pc2.Coord();
	bool isSolidIn2 = pt.Z() < 543.83715479110003 && pt.Z() > 528.53715479109997 && (cs2.X() * cs2.X() + cs2.Y() * cs2.Y()) < 5.415 * 5.415;
	return isSolidIn1 || isSolidIn2;
}
Point3 SampleMethodCircle1()
{
	double u = (double)rand() / RAND_MAX * 4 - 0.5;
	double r = (double)rand() / RAND_MAX * 0.00002 + 5.41499;
	double x = 849.32865292949998 + r * std::cos(u);
	double z = 528.53715478963011 + r * std::sin(u);
	double y = (double)rand() / RAND_MAX * 136 - 106;
	return Point3(x, y, z);
}
TEST_CASE("bug: BRepClassificationTools::IsSolidBounded  related :", "[hatch][BRepClassificationTools][fixbug]") {
	AMCAX::TopoShape readshape;
	bool readstatus = AMCAX::OCCTIO::OCCTTool::Read(readshape, INPUT_PATH_PREFIX"0000-beforeFixShape.brep");
	CHECK(readstatus == true);
	readshape = AMCAX::ShapeFixTool::FixShape(readshape, AMCAX::Precision::Confusion(), 1E-1);
	AMCAX::TopoSolid readsolid = AMCAX::MakeSolid(AMCAX::TopoCast::Shell(readshape));
	CHECK(AMCAX::BRepClassificationTools::IsSolidBounded(readsolid) == true);
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API explicit BRepFaceClassifier(const TopoFace& f)	 @param f The input face
	 @brief Construct from the face to be processed
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <hatch/BRepFaceClassifier.hpp>
#include <common/FrameT.hpp>
#include <math/CircleT.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeWire.hpp>
#include <modeling/MakeFace.hpp>
#include <boolean/BoolBRepFuse.hpp>
#include <common/IndexSet.hpp>
#include <topology/TopoExplorerTool.hpp>
using namespace AMCAX;
TopoFace WrenchFace()
{
	Frame3 fm1(Point3(0., 0., 0.), Direction3(0., 0., 1.0));
	Circle3 c1 = Circle3(fm1, 2.);
	TopoEdge ec1 = MakeEdge(c1);
	TopoWire wc1 = MakeWire(ec1);
	TopoFace F1 = MakeFace(wc1);
	TopoEdge edge1 = MakeEdge(Point3(-4., -1.0, 0.0), Point3(4., -1.0, 0.0));
	TopoEdge edge2 = MakeEdge(Point3(4., -1.0, 0.0), Point3(4., 1.0, 0.0));
	TopoEdge edge3 = MakeEdge(Point3(4., 1.0, 0.0), Point3(-4., 1.0, 0.0));
	TopoEdge edge4 = MakeEdge(Point3(-4., 1.0, 0.0), Point3(-4., -1.0, 0.0));
	TopoWire wireR = MakeWire(edge1, edge2, edge3, edge4);
	TopoFace F3 = MakeFace(wireR);
	BoolBRepFuse fuse(F1, F3);
	fuse.Build();
	fuse.SimplifyResult();
	TopoShape res = fuse.Shape();
	IndexSet<TopoShape> resFaces;
	TopoExplorerTool::MapShapes(res, ShapeType::Face, resFaces);
	std::cout << resFaces.size() << std::endl;
	TopoFace face = static_cast<const TopoFace&>(resFaces[0]);
	return face;
}
bool ImpInWrenchFace(const Point2& pt)
{
	bool isFaceIn1 = pt.X() * pt.X() + pt.Y() * pt.Y() < 2 * 2;
	bool isFaceIn2 = pt.X() > -4 && pt.X() < 4 && pt.Y() > -1 && pt.Y() < 1;
	return isFaceIn1 || isFaceIn2;
}
Point2 SampleMethodFace()
{
	double x = (double)rand() / RAND_MAX * 10 - 5;
	double y = (double)rand() / RAND_MAX * 5 - 2.0;
	return Point2(x, y);
}
TEST_CASE("case1: BRepFaceClassifier 3.6.0 added API. ", "[hatch][BRepFaceClassifier][P1]") {
		TopoFace face = WrenchFace();
		BRepFaceClassifier classify(face);
		int n = 10000;
		int inSize = 0, intime = 0, ontime = 0;
		for (int i = 0; i < n; ++i)
		{
			Point2 pt = SampleMethodFace();
			bool isIn = ImpInWrenchFace(pt);
			classify.Perform(pt, Precision::Confusion());
			bool isCIn = classify.State() == StateType::In;
			bool isCon = classify.State() == StateType::On;
			if (isIn)
			{
				inSize++;
				if (isCIn)
				{
					intime++;
				}
				if (isCon)
				{
					ontime++;
				}
			}
		}
		std::cout << inSize << " " << intime << " " << ontime << std::endl;
		CHECK(inSize == (intime + ontime));
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API void Perform(const Point2& p, double tol)	 @param tol The tolerance
	 @param p The uv point
	 @brief Classify a UV point on face with tolerance
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <hatch/BRepFaceClassifier.hpp>
#include <common/FrameT.hpp>
#include <math/CircleT.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeWire.hpp>
#include <modeling/MakeFace.hpp>
#include <boolean/BoolBRepFuse.hpp>
#include <common/IndexSet.hpp>
#include <topology/TopoExplorerTool.hpp>
using namespace AMCAX;
TopoFace WrenchFace()
{
	Frame3 fm1(Point3(0., 0., 0.), Direction3(0., 0., 1.0));
	Circle3 c1 = Circle3(fm1, 2.);
	TopoEdge ec1 = MakeEdge(c1);
	TopoWire wc1 = MakeWire(ec1);
	TopoFace F1 = MakeFace(wc1);
	TopoEdge edge1 = MakeEdge(Point3(-4., -1.0, 0.0), Point3(4., -1.0, 0.0));
	TopoEdge edge2 = MakeEdge(Point3(4., -1.0, 0.0), Point3(4., 1.0, 0.0));
	TopoEdge edge3 = MakeEdge(Point3(4., 1.0, 0.0), Point3(-4., 1.0, 0.0));
	TopoEdge edge4 = MakeEdge(Point3(-4., 1.0, 0.0), Point3(-4., -1.0, 0.0));
	TopoWire wireR = MakeWire(edge1, edge2, edge3, edge4);
	TopoFace F3 = MakeFace(wireR);
	BoolBRepFuse fuse(F1, F3);
	fuse.Build();
	fuse.SimplifyResult();
	TopoShape res = fuse.Shape();
	IndexSet<TopoShape> resFaces;
	TopoExplorerTool::MapShapes(res, ShapeType::Face, resFaces);
	std::cout << resFaces.size() << std::endl;
	TopoFace face = static_cast<const TopoFace&>(resFaces[0]);
	return face;
}
bool ImpInWrenchFace(const Point2& pt)
{
	bool isFaceIn1 = pt.X() * pt.X() + pt.Y() * pt.Y() < 2 * 2;
	bool isFaceIn2 = pt.X() > -4 && pt.X() < 4 && pt.Y() > -1 && pt.Y() < 1;
	return isFaceIn1 || isFaceIn2;
}
Point2 SampleMethodFace()
{
	double x = (double)rand() / RAND_MAX * 10 - 5;
	double y = (double)rand() / RAND_MAX * 5 - 2.0;
	return Point2(x, y);
}
TEST_CASE("case1: BRepFaceClassifier 3.6.0 added API. ", "[hatch][BRepFaceClassifier][P1]") {
		TopoFace face = WrenchFace();
		BRepFaceClassifier classify(face);
		int n = 10000;
		int inSize = 0, intime = 0, ontime = 0;
		for (int i = 0; i < n; ++i)
		{
			Point2 pt = SampleMethodFace();
			bool isIn = ImpInWrenchFace(pt);
			classify.Perform(pt, Precision::Confusion());
			bool isCIn = classify.State() == StateType::In;
			bool isCon = classify.State() == StateType::On;
			if (isIn)
			{
				inSize++;
				if (isCIn)
				{
					intime++;
				}
				if (isCon)
				{
					ontime++;
				}
			}
		}
		std::cout << inSize << " " << intime << " " << ontime << std::endl;
		CHECK(inSize == (intime + ontime));
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static TopoShape FixShape(const TopoShape& shape, double prec, double maxTol)	 @return Fixed Shape
	 @param maxTol The global max tolerance used when the algorithm needs to check the tolerance
	 @param prec The global precision used when the algorithm needs to check the precision
	 @param shape Input shape
	 @brief Try to repair the shape to a valid shape
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <healing/ShapeFixTool.hpp>
#include <common/Precision.hpp>
using namespace AMCAX;
TEST_CASE("bug1: ShapeFixTool ", "[healing][ShapeFixTool][fixbug]") {
	AMCAX::TopoShape readshape;
	AMCAX::OCCTIO::OCCTTool::Read(readshape, INPUT_PATH_PREFIX"FixShape-Crash.brep");
	readshape = AMCAX::ShapeFixTool::FixShape(readshape, AMCAX::Precision::Confusion(), 1E-1);
	AMCAX::OCCTIO::OCCTTool::Write(readshape, OUTPUT_PATH_PREFIX"ShapeFixTool_O_FixedShape.brep");
	GlobalProperty prop;
	BRepGlobalProperty::VolumeProperties(readshape, prop);
	CHECK(prop.Mass() == Approx(16486799.3305680156).epsilon(1e-2));
	Point3 vP = prop.CenterOfMass();
	CHECK(vP.X() == Approx(-260.8706721039).epsilon(1e-2));
	CHECK(vP.Y() == Approx(-154.6717940115).epsilon(1e-2));
	CHECK(vP.Z() == Approx(-0.1139512307).epsilon(1e-2));
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static bool Read(TopoShape& s, const std::string& file)	 @return True if the input process is succeed
	 @param file The input file
	 @param s The shape
	 @brief Read a shape from a file
,
 "output":#include <catch.hpp>
#include<testHelper.h>
#include <topology/TopoShape.hpp>
#include <occtio/OCCTTool.hpp>
static bool ComparisonFields(const std::string& file1, const std::string& file2, const std::string& fields)
{
	ifstream file1Stream(file1);
	ifstream file2Stream(file2);
	if (file1Stream.is_open() == false || file2Stream.is_open() == false)
	{
		file1Stream.close();
		file2Stream.close();
		return false;
	}
	std::string line1, line2;
	while (std::getline(file1Stream, line1))
	{
		if (line1.find(fields) != std::string::npos) break;
	}
	while (std::getline(file2Stream, line2))
	{
		if (line2.find(fields) != std::string::npos) break;
	}
	file1Stream.close();
	file2Stream.close();
	return line1 == line2;
}
TEST_CASE("CASE3:Check occio read not exist file ", "[occtio][OCCTTool][p2]") {
	AMCAX::TopoShape shape;
	SECTION("OCCTIO::OCCTTool::Read") {
		bool isReadSuccess = AMCAX::OCCTIO::OCCTTool::Read(shape, INPUT_PATH_PREFIX"NOTEXIST.brep");
		CHECK(isReadSuccess == false);
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static bool Write(const TopoShape& s, std::ostream& os, int format = 3)	 @return True if the output process is succeed
	 @param[in] format The format version
	 @param[in,out] os The output stream
	 @param[in] s The shape
	 @brief Write a shape to a stream
,
 "output":#include <catch.hpp>
#include<testHelper.h>
#include <topology/TopoShape.hpp>
#include <occtio/OCCTTool.hpp>
static bool ComparisonFields(const std::string& file1, const std::string& file2, const std::string& fields)
{
	ifstream file1Stream(file1);
	ifstream file2Stream(file2);
	if (file1Stream.is_open() == false || file2Stream.is_open() == false)
	{
		file1Stream.close();
		file2Stream.close();
		return false;
	}
	std::string line1, line2;
	while (std::getline(file1Stream, line1))
	{
		if (line1.find(fields) != std::string::npos) break;
	}
	while (std::getline(file2Stream, line2))
	{
		if (line2.find(fields) != std::string::npos) break;
	}
	file1Stream.close();
	file2Stream.close();
	return line1 == line2;
}
TEST_CASE("CASE1:Check occtio read and write normal brep file function with different param ", "[occtio][OCCTTool][p1][XXX]") {
	AMCAX::TopoShape shape;
	bool isReadSuccess = AMCAX::OCCTIO::OCCTTool::Read(shape, INPUT_PATH_PREFIX"occtio/occtio_read_I_brephaveMesh-case1.brep");
	bool isWriteSuccess1f = AMCAX::OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f1-f-case1.brep", false, 1);
	bool isWriteSuccess2f = AMCAX::OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f2-f-case1.brep", false, 2);
	bool isWriteSuccess3f = AMCAX::OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f3-f-case1.brep", false, 3);
	bool isWriteSuccess1t = AMCAX::OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f1-t-case1.brep", true, 1);
	bool isWriteSuccess2t = AMCAX::OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f2-t-case1.brep", true, 2);
	bool isWriteSuccess3t = AMCAX::OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f3-t-case1.brep", true, 3);
	CHECK(isReadSuccess == true);
	CHECK(isWriteSuccess1f == true);
	CHECK(isWriteSuccess2f == true);
	CHECK(isWriteSuccess3f == true);
	CHECK(containsStringInFile(OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f1-f-case1.brep", "Triangulations 0") == true);
	CHECK(containsStringInFile(OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f1-f-case1.brep", "CASCADE Topology V1, (c) Matra-Datavision") == true);
	CHECK(containsStringInFile(OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f2-f-case1.brep", "Triangulations 0") == true);
	CHECK(containsStringInFile(OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f2-f-case1.brep", "CASCADE Topology V2, (c) Matra-Datavision") == true);
	CHECK(containsStringInFile(OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f3-f-case1.brep", "Triangulations 0") == true);
	CHECK(containsStringInFile(OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f3-f-case1.brep", "CASCADE Topology V3, (c) Open Cascade") == true);
	CHECK(isWriteSuccess1t == true);
	CHECK(isWriteSuccess2t == true);
	CHECK(isWriteSuccess3t == true);
	CHECK(containsStringInFile(OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f1-t-case1.brep", "Triangulations 0") == false);
	CHECK(containsStringInFile(OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f1-t-case1.brep", "CASCADE Topology V1, (c) Matra-Datavision") == true);
	CHECK(containsStringInFile(OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f2-t-case1.brep", "Triangulations 0") == false);
	CHECK(containsStringInFile(OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f2-t-case1.brep", "CASCADE Topology V2, (c) Matra-Datavision") == true);
	CHECK(containsStringInFile(OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f3-t-case1.brep", "Triangulations 0") == false);
	CHECK(containsStringInFile(OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f3-t-case1.brep", "CASCADE Topology V3, (c) Open Cascade") == true);
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static bool Write(const TopoShape& s, std::ostream& os, bool withTriangles, int format = 3)	 @return True if the output process is succeed
	 @param[in] format The format version
	 @param[in] withTriangles Determine whether writing the triangular mesh of the shape
	 @param[in,out] os The output stream
	 @param[in] s The shape
	 @brief Wrtie a shape to a stream
,
 "output":#include <catch.hpp>
#include<testHelper.h>
#include <topology/TopoShape.hpp>
#include <occtio/OCCTTool.hpp>
static bool ComparisonFields(const std::string& file1, const std::string& file2, const std::string& fields)
{
	ifstream file1Stream(file1);
	ifstream file2Stream(file2);
	if (file1Stream.is_open() == false || file2Stream.is_open() == false)
	{
		file1Stream.close();
		file2Stream.close();
		return false;
	}
	std::string line1, line2;
	while (std::getline(file1Stream, line1))
	{
		if (line1.find(fields) != std::string::npos) break;
	}
	while (std::getline(file2Stream, line2))
	{
		if (line2.find(fields) != std::string::npos) break;
	}
	file1Stream.close();
	file2Stream.close();
	return line1 == line2;
}
TEST_CASE("CASE1:Check occtio read and write normal brep file function with different param ", "[occtio][OCCTTool][p1][XXX]") {
	AMCAX::TopoShape shape;
	bool isReadSuccess = AMCAX::OCCTIO::OCCTTool::Read(shape, INPUT_PATH_PREFIX"occtio/occtio_read_I_brephaveMesh-case1.brep");
	bool isWriteSuccess1f = AMCAX::OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f1-f-case1.brep", false, 1);
	bool isWriteSuccess2f = AMCAX::OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f2-f-case1.brep", false, 2);
	bool isWriteSuccess3f = AMCAX::OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f3-f-case1.brep", false, 3);
	bool isWriteSuccess1t = AMCAX::OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f1-t-case1.brep", true, 1);
	bool isWriteSuccess2t = AMCAX::OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f2-t-case1.brep", true, 2);
	bool isWriteSuccess3t = AMCAX::OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f3-t-case1.brep", true, 3);
	CHECK(isReadSuccess == true);
	CHECK(isWriteSuccess1f == true);
	CHECK(isWriteSuccess2f == true);
	CHECK(isWriteSuccess3f == true);
	CHECK(containsStringInFile(OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f1-f-case1.brep", "Triangulations 0") == true);
	CHECK(containsStringInFile(OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f1-f-case1.brep", "CASCADE Topology V1, (c) Matra-Datavision") == true);
	CHECK(containsStringInFile(OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f2-f-case1.brep", "Triangulations 0") == true);
	CHECK(containsStringInFile(OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f2-f-case1.brep", "CASCADE Topology V2, (c) Matra-Datavision") == true);
	CHECK(containsStringInFile(OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f3-f-case1.brep", "Triangulations 0") == true);
	CHECK(containsStringInFile(OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f3-f-case1.brep", "CASCADE Topology V3, (c) Open Cascade") == true);
	CHECK(isWriteSuccess1t == true);
	CHECK(isWriteSuccess2t == true);
	CHECK(isWriteSuccess3t == true);
	CHECK(containsStringInFile(OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f1-t-case1.brep", "Triangulations 0") == false);
	CHECK(containsStringInFile(OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f1-t-case1.brep", "CASCADE Topology V1, (c) Matra-Datavision") == true);
	CHECK(containsStringInFile(OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f2-t-case1.brep", "Triangulations 0") == false);
	CHECK(containsStringInFile(OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f2-t-case1.brep", "CASCADE Topology V2, (c) Matra-Datavision") == true);
	CHECK(containsStringInFile(OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f3-t-case1.brep", "Triangulations 0") == false);
	CHECK(containsStringInFile(OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f3-t-case1.brep", "CASCADE Topology V3, (c) Open Cascade") == true);
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static bool Write(const TopoShape& s, const std::string& file, int format = 3)	 @return True if the output process is succeed
	 @param format The format version
	 @param file The output file
	 @param s The shape
	 @brief Write a shape to a file
,
 "output":#include <catch.hpp>
#include<testHelper.h>
#include <topology/TopoShape.hpp>
#include <occtio/OCCTTool.hpp>
static bool ComparisonFields(const std::string& file1, const std::string& file2, const std::string& fields)
{
	ifstream file1Stream(file1);
	ifstream file2Stream(file2);
	if (file1Stream.is_open() == false || file2Stream.is_open() == false)
	{
		file1Stream.close();
		file2Stream.close();
		return false;
	}
	std::string line1, line2;
	while (std::getline(file1Stream, line1))
	{
		if (line1.find(fields) != std::string::npos) break;
	}
	while (std::getline(file2Stream, line2))
	{
		if (line2.find(fields) != std::string::npos) break;
	}
	file1Stream.close();
	file2Stream.close();
	return line1 == line2;
}
TEST_CASE("CASE1:Check occtio read and write normal brep file function with different param ", "[occtio][OCCTTool][p1][XXX]") {
	AMCAX::TopoShape shape;
	bool isReadSuccess = AMCAX::OCCTIO::OCCTTool::Read(shape, INPUT_PATH_PREFIX"occtio/occtio_read_I_brephaveMesh-case1.brep");
	bool isWriteSuccess1f = AMCAX::OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f1-f-case1.brep", false, 1);
	bool isWriteSuccess2f = AMCAX::OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f2-f-case1.brep", false, 2);
	bool isWriteSuccess3f = AMCAX::OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f3-f-case1.brep", false, 3);
	bool isWriteSuccess1t = AMCAX::OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f1-t-case1.brep", true, 1);
	bool isWriteSuccess2t = AMCAX::OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f2-t-case1.brep", true, 2);
	bool isWriteSuccess3t = AMCAX::OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f3-t-case1.brep", true, 3);
	CHECK(isReadSuccess == true);
	CHECK(isWriteSuccess1f == true);
	CHECK(isWriteSuccess2f == true);
	CHECK(isWriteSuccess3f == true);
	CHECK(containsStringInFile(OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f1-f-case1.brep", "Triangulations 0") == true);
	CHECK(containsStringInFile(OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f1-f-case1.brep", "CASCADE Topology V1, (c) Matra-Datavision") == true);
	CHECK(containsStringInFile(OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f2-f-case1.brep", "Triangulations 0") == true);
	CHECK(containsStringInFile(OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f2-f-case1.brep", "CASCADE Topology V2, (c) Matra-Datavision") == true);
	CHECK(containsStringInFile(OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f3-f-case1.brep", "Triangulations 0") == true);
	CHECK(containsStringInFile(OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f3-f-case1.brep", "CASCADE Topology V3, (c) Open Cascade") == true);
	CHECK(isWriteSuccess1t == true);
	CHECK(isWriteSuccess2t == true);
	CHECK(isWriteSuccess3t == true);
	CHECK(containsStringInFile(OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f1-t-case1.brep", "Triangulations 0") == false);
	CHECK(containsStringInFile(OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f1-t-case1.brep", "CASCADE Topology V1, (c) Matra-Datavision") == true);
	CHECK(containsStringInFile(OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f2-t-case1.brep", "Triangulations 0") == false);
	CHECK(containsStringInFile(OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f2-t-case1.brep", "CASCADE Topology V2, (c) Matra-Datavision") == true);
	CHECK(containsStringInFile(OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f3-t-case1.brep", "Triangulations 0") == false);
	CHECK(containsStringInFile(OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f3-t-case1.brep", "CASCADE Topology V3, (c) Open Cascade") == true);
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static bool Write(const TopoShape& s, const std::string& file, bool withTriangles, int format = 3)	 @return True if the output process is succeed
	 @param format The format version
	 @param withTriangles Determine whether writing the triangular mesh of the shape
	 @param file The output file
	 @param s The shape
	 @brief Write a shape to a file
,
 "output":#include <catch.hpp>
#include<testHelper.h>
#include <topology/TopoShape.hpp>
#include <occtio/OCCTTool.hpp>
static bool ComparisonFields(const std::string& file1, const std::string& file2, const std::string& fields)
{
	ifstream file1Stream(file1);
	ifstream file2Stream(file2);
	if (file1Stream.is_open() == false || file2Stream.is_open() == false)
	{
		file1Stream.close();
		file2Stream.close();
		return false;
	}
	std::string line1, line2;
	while (std::getline(file1Stream, line1))
	{
		if (line1.find(fields) != std::string::npos) break;
	}
	while (std::getline(file2Stream, line2))
	{
		if (line2.find(fields) != std::string::npos) break;
	}
	file1Stream.close();
	file2Stream.close();
	return line1 == line2;
}
TEST_CASE("CASE1:Check occtio read and write normal brep file function with different param ", "[occtio][OCCTTool][p1][XXX]") {
	AMCAX::TopoShape shape;
	bool isReadSuccess = AMCAX::OCCTIO::OCCTTool::Read(shape, INPUT_PATH_PREFIX"occtio/occtio_read_I_brephaveMesh-case1.brep");
	bool isWriteSuccess1f = AMCAX::OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f1-f-case1.brep", false, 1);
	bool isWriteSuccess2f = AMCAX::OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f2-f-case1.brep", false, 2);
	bool isWriteSuccess3f = AMCAX::OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f3-f-case1.brep", false, 3);
	bool isWriteSuccess1t = AMCAX::OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f1-t-case1.brep", true, 1);
	bool isWriteSuccess2t = AMCAX::OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f2-t-case1.brep", true, 2);
	bool isWriteSuccess3t = AMCAX::OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f3-t-case1.brep", true, 3);
	CHECK(isReadSuccess == true);
	CHECK(isWriteSuccess1f == true);
	CHECK(isWriteSuccess2f == true);
	CHECK(isWriteSuccess3f == true);
	CHECK(containsStringInFile(OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f1-f-case1.brep", "Triangulations 0") == true);
	CHECK(containsStringInFile(OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f1-f-case1.brep", "CASCADE Topology V1, (c) Matra-Datavision") == true);
	CHECK(containsStringInFile(OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f2-f-case1.brep", "Triangulations 0") == true);
	CHECK(containsStringInFile(OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f2-f-case1.brep", "CASCADE Topology V2, (c) Matra-Datavision") == true);
	CHECK(containsStringInFile(OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f3-f-case1.brep", "Triangulations 0") == true);
	CHECK(containsStringInFile(OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f3-f-case1.brep", "CASCADE Topology V3, (c) Open Cascade") == true);
	CHECK(isWriteSuccess1t == true);
	CHECK(isWriteSuccess2t == true);
	CHECK(isWriteSuccess3t == true);
	CHECK(containsStringInFile(OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f1-t-case1.brep", "Triangulations 0") == false);
	CHECK(containsStringInFile(OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f1-t-case1.brep", "CASCADE Topology V1, (c) Matra-Datavision") == true);
	CHECK(containsStringInFile(OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f2-t-case1.brep", "Triangulations 0") == false);
	CHECK(containsStringInFile(OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f2-t-case1.brep", "CASCADE Topology V2, (c) Matra-Datavision") == true);
	CHECK(containsStringInFile(OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f3-t-case1.brep", "Triangulations 0") == false);
	CHECK(containsStringInFile(OUTPUT_PATH_PREFIX"occtio_write_O_brephaveMesh-f3-t-case1.brep", "CASCADE Topology V3, (c) Open Cascade") == true);
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static bool Read(TopoShape& s, std::istream& is)	 @return True if the input process is succeed
	 @param[in,out] is The input stream
	 @param[out] s The shape
	 @brief Read a shape from a stream
,
 "output":#include <catch.hpp>
#include<testHelper.h>
#include <topology/TopoShape.hpp>
#include <occtio/OCCTTool.hpp>
static bool ComparisonFields(const std::string& file1, const std::string& file2, const std::string& fields)
{
	ifstream file1Stream(file1);
	ifstream file2Stream(file2);
	if (file1Stream.is_open() == false || file2Stream.is_open() == false)
	{
		file1Stream.close();
		file2Stream.close();
		return false;
	}
	std::string line1, line2;
	while (std::getline(file1Stream, line1))
	{
		if (line1.find(fields) != std::string::npos) break;
	}
	while (std::getline(file2Stream, line2))
	{
		if (line2.find(fields) != std::string::npos) break;
	}
	file1Stream.close();
	file2Stream.close();
	return line1 == line2;
}
TEST_CASE("CASE3:Check occio read not exist file ", "[occtio][OCCTTool][p2]") {
	AMCAX::TopoShape shape;
	SECTION("OCCTIO::OCCTTool::Read") {
		bool isReadSuccess = AMCAX::OCCTIO::OCCTTool::Read(shape, INPUT_PATH_PREFIX"NOTEXIST.brep");
		CHECK(isReadSuccess == false);
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":void SetRadius(double r)	 @param r The radius
	 @brief Set the radius of the circle
,
 "output":#include<catch.hpp>
#include "testHelper.h"
#include<iostream>
#include <math/CircleT.hpp>
#include <common/AxisT.hpp>
#include <common/PointT.hpp>
TEST_CASE("CircleT Area and Length Test", "[CircleT]") {
    AMCAX::Circle2 circle2;
    circle2.SetRadius(5.0);
    CHECK(circle2.Area() == Approx(78.53982));
    CHECK(circle2.Length() == Approx(31.41593));
    AMCAX::Circle3 circle3;
    circle3.SetRadius(10.0);
    CHECK(circle3.Area() == Approx(314.15927));
    CHECK(circle3.Length() == Approx(62.83185));
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] double Radius()	 @return The radius
	 @brief Get the radius
,
 "output":#include<catch.hpp>
#include "testHelper.h"
#include<iostream>
#include <math/CircleT.hpp>
#include <common/AxisT.hpp>
#include <common/PointT.hpp>
TEST_CASE("CircleT Constructor Test", "[math][CircleT][P1]") {
	SECTION("2D Circle Construction") {
        AMCAX::Circle2 circle2;
        constexpr double maxr = std::numeric_limits<double>::max();
        CHECK(circle2.Radius() == Approx(maxr).epsilon(1e-15));
        CHECK(circle2.Area() == Approx(maxr * maxr * M_PI).epsilon(1e-15));
        double a, b, c, d, e, f;
        circle2.Coefficients(a, b, c, d, e, f);
        std::cout << a << std::endl;
        std::cout << b << std::endl;
        std::cout << c << std::endl;
        std::cout << d << std::endl;
        std::cout << e << std::endl;
        std::cout << f << std::endl;
        AMCAX::Point2 P(0.0, 1.0);
        double tolerance = 0.1;
        CHECK(circle2.Contains(P, tolerance)==false);
        CHECK(circle2.Distance(P) == Approx(maxr).epsilon(1e-15));
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] double Length()	 @return The length of the circle
	 @brief Get the length of the circle
,
 "output":#include<catch.hpp>
#include "testHelper.h"
#include<iostream>
#include <math/CircleT.hpp>
#include <common/AxisT.hpp>
#include <common/PointT.hpp>
TEST_CASE("case1: create a Cirecle", "[math][CircleT][P1]") {
	AMCAX::Point2 P(0.0,0.0);
	AMCAX::Direction2 D(1.0,0.0);
	AMCAX::Axis2  axis2(P, D);
	float radius = 5.0f;
	AMCAX::Circle2 circle2(axis2, radius, true);
	CHECK(circle2.Area() == radius * radius * M_PI); 
    double a, b, c, d, e, f;
    circle2.Coefficients(a, b, c, d, e, f);  
    double x = 0, y = 5;
    CHECK(a * x * x + b * y * y + c * x * y + d * x + e * y + f == Approx(0.0).epsilon(1e-15));
    double x1 = 5 * sqrt(2) / 2;
    double y1 = 5 * sqrt(2) / 2;
    double x2 = 6;
    double y2 = 0;
    double x3 = 5.5;
    double y3 = 6.1;
    AMCAX::Point2 P1(x1,y1);
    AMCAX::Point2 P2(x2, y2);
    AMCAX::Point2 P3(x3, y3);
    double tolerance1 = 0.1;
    double tolerance2 = 1.0;
    CHECK(circle2.Contains(P1, tolerance1) == true);
    CHECK(circle2.Contains(P2, tolerance2) == true);
    CHECK(circle2.Contains(P3, tolerance2) == false);
    CHECK(circle2.Distance(P1) == Approx(0.0).epsilon(1e-15));
    CHECK(circle2.Distance(P2) == Approx(1.0).epsilon(1e-15));
    CHECK(circle2.Length() == Approx(2*M_PI*radius).epsilon(1e-15));
    AMCAX::Point2 locationP = circle2.Location();
    CHECK(locationP.X() == Approx(0.0).epsilon(1e-15));
    CHECK(locationP.Y() == Approx(0.0).epsilon(1e-15));
    AMCAX::Point2 mirrorAxisPoint(1.0, 0.0);
    AMCAX::Direction2 mirrorAxisDirection(0.0, 1.0);
    AMCAX::Axis2 mirrorAxis(mirrorAxisPoint, mirrorAxisDirection);
    circle2.Mirror(mirrorAxis);
    CHECK(circle2.Length() == Approx(2 * M_PI * radius).epsilon(1e-15));
    AMCAX::Point2 locationPmirror = circle2.Location();
    CHECK(locationPmirror.X() == Approx(2.0).epsilon(1e-15));
    CHECK(locationPmirror.Y() == Approx(0.0).epsilon(1e-15));
    AMCAX::Point2 P4(7.0, 0.0);  
    CHECK(circle2.Contains(P4, tolerance2) == true);
    AMCAX::Point2 mirroredAxisPoint(1.0, 0.0);
    AMCAX::Direction2 mirroredAxisDirection(0.0, 1.0);
    AMCAX::Axis2 mirroedrAxis(mirroredAxisPoint, mirroredAxisDirection);
    AMCAX::Circle2 circle2mirrored = circle2.Mirrored(mirroedrAxis);
    CHECK(circle2mirrored.Length() == Approx(2 * M_PI * radius).epsilon(1e-15));
    AMCAX::Point2 locationPmirrored = circle2mirrored.Location();
    CHECK(locationPmirrored.X() == Approx(0.0).epsilon(1e-15));
    CHECK(locationPmirrored.Y() == Approx(0.0).epsilon(1e-15));
    AMCAX::Frame2 frame2mirrored = circle2mirrored.Position(); 
    CHECK(frame2mirrored.Location().X() == Approx(0.0).epsilon(1e-15));
    CHECK(frame2mirrored.Location().Y() == Approx(0.0).epsilon(1e-15));
    const double& radiusmirrored = circle2mirrored.Radius(); 
    CHECK(radiusmirrored == Approx(radius).epsilon(1e-15));
    circle2mirrored.Scale(P,0.5); 
    AMCAX::Point2 scaleP1(0.0,-2.5);
    CHECK(circle2mirrored.Contains(scaleP1, 0) == true);
    AMCAX::Circle2 circle2Scaled = circle2mirrored.Scale(P, 2); 
    AMCAX::Point2 scaledP1(0.0, 5.0);
    CHECK(circle2Scaled.Contains(scaledP1, 0) == true);
    AMCAX::Point2 rotateP(0.0,0.0);
    double angle = 90.0 * (2 * M_PI / 360.0);
    circle2.Rotate(rotateP, angle); 
    AMCAX::Point2 P5(0.0, -3.0);
    CHECK(circle2.Contains(P5, 0) == true);
    double angle2 = -180.0 * (2 * M_PI / 360.0);
    AMCAX::Circle2 rotatedCircle2 = circle2.Rotated(rotateP, angle2); 
    AMCAX::Point2 P6(0.0, 3.0);
    CHECK(rotatedCircle2.Contains(P6, 0) == true); 
    AMCAX::Point2 newP(0.0, 0.0);
    rotatedCircle2.SetLocation(newP);
    CHECK(rotatedCircle2.Contains(P1, 0) == true);
    std::cout << circle2.Length() << std::endl;
};
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] double Distance(const PointT<double, DIM>& p)	 @return The distance from the point to the circle
	 @param p The point
	 @brief Compute the distance from a point to the circle
,
 "output":#include<catch.hpp>
#include "testHelper.h"
#include<iostream>
#include <math/CircleT.hpp>
#include <common/AxisT.hpp>
#include <common/PointT.hpp>
TEST_CASE("case1: create a Cirecle", "[math][CircleT][P1]") {
	AMCAX::Point2 P(0.0,0.0);
	AMCAX::Direction2 D(1.0,0.0);
	AMCAX::Axis2  axis2(P, D);
	float radius = 5.0f;
	AMCAX::Circle2 circle2(axis2, radius, true);
	CHECK(circle2.Area() == radius * radius * M_PI); 
    double a, b, c, d, e, f;
    circle2.Coefficients(a, b, c, d, e, f);  
    double x = 0, y = 5;
    CHECK(a * x * x + b * y * y + c * x * y + d * x + e * y + f == Approx(0.0).epsilon(1e-15));
    double x1 = 5 * sqrt(2) / 2;
    double y1 = 5 * sqrt(2) / 2;
    double x2 = 6;
    double y2 = 0;
    double x3 = 5.5;
    double y3 = 6.1;
    AMCAX::Point2 P1(x1,y1);
    AMCAX::Point2 P2(x2, y2);
    AMCAX::Point2 P3(x3, y3);
    double tolerance1 = 0.1;
    double tolerance2 = 1.0;
    CHECK(circle2.Contains(P1, tolerance1) == true);
    CHECK(circle2.Contains(P2, tolerance2) == true);
    CHECK(circle2.Contains(P3, tolerance2) == false);
    CHECK(circle2.Distance(P1) == Approx(0.0).epsilon(1e-15));
    CHECK(circle2.Distance(P2) == Approx(1.0).epsilon(1e-15));
    CHECK(circle2.Length() == Approx(2*M_PI*radius).epsilon(1e-15));
    AMCAX::Point2 locationP = circle2.Location();
    CHECK(locationP.X() == Approx(0.0).epsilon(1e-15));
    CHECK(locationP.Y() == Approx(0.0).epsilon(1e-15));
    AMCAX::Point2 mirrorAxisPoint(1.0, 0.0);
    AMCAX::Direction2 mirrorAxisDirection(0.0, 1.0);
    AMCAX::Axis2 mirrorAxis(mirrorAxisPoint, mirrorAxisDirection);
    circle2.Mirror(mirrorAxis);
    CHECK(circle2.Length() == Approx(2 * M_PI * radius).epsilon(1e-15));
    AMCAX::Point2 locationPmirror = circle2.Location();
    CHECK(locationPmirror.X() == Approx(2.0).epsilon(1e-15));
    CHECK(locationPmirror.Y() == Approx(0.0).epsilon(1e-15));
    AMCAX::Point2 P4(7.0, 0.0);  
    CHECK(circle2.Contains(P4, tolerance2) == true);
    AMCAX::Point2 mirroredAxisPoint(1.0, 0.0);
    AMCAX::Direction2 mirroredAxisDirection(0.0, 1.0);
    AMCAX::Axis2 mirroedrAxis(mirroredAxisPoint, mirroredAxisDirection);
    AMCAX::Circle2 circle2mirrored = circle2.Mirrored(mirroedrAxis);
    CHECK(circle2mirrored.Length() == Approx(2 * M_PI * radius).epsilon(1e-15));
    AMCAX::Point2 locationPmirrored = circle2mirrored.Location();
    CHECK(locationPmirrored.X() == Approx(0.0).epsilon(1e-15));
    CHECK(locationPmirrored.Y() == Approx(0.0).epsilon(1e-15));
    AMCAX::Frame2 frame2mirrored = circle2mirrored.Position(); 
    CHECK(frame2mirrored.Location().X() == Approx(0.0).epsilon(1e-15));
    CHECK(frame2mirrored.Location().Y() == Approx(0.0).epsilon(1e-15));
    const double& radiusmirrored = circle2mirrored.Radius(); 
    CHECK(radiusmirrored == Approx(radius).epsilon(1e-15));
    circle2mirrored.Scale(P,0.5); 
    AMCAX::Point2 scaleP1(0.0,-2.5);
    CHECK(circle2mirrored.Contains(scaleP1, 0) == true);
    AMCAX::Circle2 circle2Scaled = circle2mirrored.Scale(P, 2); 
    AMCAX::Point2 scaledP1(0.0, 5.0);
    CHECK(circle2Scaled.Contains(scaledP1, 0) == true);
    AMCAX::Point2 rotateP(0.0,0.0);
    double angle = 90.0 * (2 * M_PI / 360.0);
    circle2.Rotate(rotateP, angle); 
    AMCAX::Point2 P5(0.0, -3.0);
    CHECK(circle2.Contains(P5, 0) == true);
    double angle2 = -180.0 * (2 * M_PI / 360.0);
    AMCAX::Circle2 rotatedCircle2 = circle2.Rotated(rotateP, angle2); 
    AMCAX::Point2 P6(0.0, 3.0);
    CHECK(rotatedCircle2.Contains(P6, 0) == true); 
    AMCAX::Point2 newP(0.0, 0.0);
    rotatedCircle2.SetLocation(newP);
    CHECK(rotatedCircle2.Contains(P1, 0) == true);
    std::cout << circle2.Length() << std::endl;
};
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":void SetRadius(double r)	 @param r The radius
	 @brief Set the radius of the circle
,
 "output":#include <math/CircleT.hpp>
#include <common/CoordT.hpp>
#include <common/TransformationType.hpp>
#include <common/DirectionT.hpp>
#include <common/PointT.hpp>
#include <common/Precision.hpp>
#include <common/CoordT.hpp>
#include <common/TransformationType.hpp>
#include <topology/TopoEdge.hpp>
#include <modeling/MakeEdge.hpp>
#include <topology/TopoWire.hpp>
#include <modeling/MakeWire.hpp>
#include <geometry/GlobalProperty.hpp>
#include <topology/BRepGlobalProperty.hpp>
#include<iostream>
#include "catch.hpp" 
using namespace std;
using namespace AMCAX;
TEST_CASE("TestCircle2D", "[math][Circle2D]")
{
	AMCAX::CircleT<double, 2> circle2D;
	AMCAX::Point2 center2D(0.0, 0.0);
	double redius2D = 5.0;
	double tol = 0.1;
	circle2D.SetLocation(center2D);
	circle2D.SetRadius(redius2D);
	double area2D = circle2D.Area();
	double length2D = circle2D.Length();
	AMCAX::Point2 retcenter2D = circle2D.Location();
	double retarea2D = M_PI * redius2D * redius2D;
	double retlength2D = 2 * M_PI * redius2D;
	std::cout << area2D << std::endl;
	std::cout << length2D << std::endl;
	std::cout << retcenter2D.X() << std::endl;
	std::cout << retcenter2D.Y() << std::endl;
	CHECK(area2D == retarea2D);
	CHECK(length2D == retlength2D);
	CHECK(retcenter2D.X() == center2D.X());
	CHECK(retcenter2D.Y() == center2D.Y());
	double a, b, c, d, e, f;
	circle2D.Coefficients(a, b, c, d, e, f);
	std::cout << a << std::endl;
	std::cout << b << std::endl;
	std::cout << c << std::endl;
	std::cout << d << std::endl;
	std::cout << e << std::endl;
	std::cout << f << std::endl;
	CHECK(a == 1);
	CHECK(b == 1);
	CHECK(c == 0);
	CHECK(d == 0);
	CHECK(e == 0);
	CHECK(f == -25);
	std::vector < AMCAX::Point2> testPoints = {
		AMCAX::Point2(3.0, 4.0),
		AMCAX::Point2(5.0, 0.0),
		AMCAX::Point2(4.9, 0.0),
		AMCAX::Point2(5.1, 0.0),
		AMCAX::Point2(6.0, 0.0)
	};
	for (const auto& point : testPoints)
	{
		double distanceToCenter = std::sqrt(point.X() * point.X() + point.Y() * point.Y());
		bool expectedIsInCircle = distanceToCenter <= 5.0 + tol;
		bool isInCircle = circle2D.Contains(point, tol);
		CHECK(isInCircle == expectedIsInCircle);
	}
	for (const auto& point : testPoints)
	{
		double distance = circle2D.Distance(point);
		double expectedDistance = std::abs(std::sqrt(std::pow(point.X() - center2D.X(), 2) + std::pow(point.Y() - center2D.Y(), 2)) - redius2D);
		CHECK(distance == expectedDistance);
	}
	AMCAX::AxisT<double, 2> mirrorAxis(AMCAX::Point2(0.0, 0.0), AMCAX::Direction2(0.0, 1.0));
	circle2D.Mirror(mirrorAxis);
	AMCAX::Point2 mirroredCenter = circle2D.Location();
	std::cout << "Mirrored circle center: (" << mirroredCenter.X() << ", " << mirroredCenter.Y() << ")" << std::endl;
	CHECK(mirroredCenter.X() == center2D.X());
	CHECK(mirroredCenter.Y() == center2D.Y());
	const AMCAX::FrameT<double, 2>& frame = circle2D.Position();
	AMCAX::Point2 rotationPoint(0.0, 0.0);
	double  rotationAngle = M_PI / 4;
	auto rotatedCircle = circle2D.Rotated(rotationPoint, rotationAngle);
	double cosAngle = cos(rotationAngle);
	double sinAngle = sin(rotationAngle);
	double newX = cosAngle * (center2D.X() - rotationPoint.X()) - sinAngle * (center2D.Y() - rotationPoint.Y()) + rotationPoint.X();
	double newY = sinAngle * (center2D.X() - rotationPoint.X()) + cosAngle * (center2D.Y() - rotationPoint.Y()) + rotationPoint.Y();
	auto rotatedCenter = rotatedCircle.Location();
	CHECK(newX == center2D.X());
	CHECK(newY == center2D.Y());
	AMCAX::Point2 scalingCenter(0.0, 0.0);
	double scalingFactor = 2.0;
	auto scaledCircle = circle2D.Scale(scalingCenter, scalingFactor);
	double scaledRadius = scaledCircle.Radius();
	double expectedScaledRadius = redius2D * scalingFactor;
	CHECK(std::abs(scaledRadius - expectedScaledRadius) < 1e-6);
	AMCAX::VectorT<double, 2> translationVector(2.0, 3.0);
	auto translatedCircle = circle2D.Translated(translationVector);
	auto translatedCenter = translatedCircle.Location();
	double translatedX = center2D.X() + translationVector.X();
	CHECK(translatedX == translatedCenter.X());
	auto xAxis = circle2D.XAxis();
	auto directionAxis = xAxis.Direction();
	CHECK(directionAxis.X() == -1.0);
	CHECK(directionAxis.Y() == 0.0);
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] double Radius()	 @return The radius
	 @brief Get the radius
,
 "output":#include <math/CircleT.hpp>
#include <common/CoordT.hpp>
#include <common/TransformationType.hpp>
#include <common/DirectionT.hpp>
#include <common/PointT.hpp>
#include <common/Precision.hpp>
#include <common/CoordT.hpp>
#include <common/TransformationType.hpp>
#include <topology/TopoEdge.hpp>
#include <modeling/MakeEdge.hpp>
#include <topology/TopoWire.hpp>
#include <modeling/MakeWire.hpp>
#include <geometry/GlobalProperty.hpp>
#include <topology/BRepGlobalProperty.hpp>
#include<iostream>
#include "catch.hpp" 
using namespace std;
using namespace AMCAX;
TEST_CASE("TestCircle3D", "[math][Circle3D]")
{
	AMCAX::Circle3 circle3D;
	AMCAX::Point3  center3D(0.0, 0.0, 0.0);
	double radius3D = 5.0;
	double tol = 0.1;
	circle3D.SetLocation(center3D);
	circle3D.SetRadius(radius3D);
	double area = circle3D.Area();
	auto axis = circle3D.Axis();
	AMCAX::Point3 expectedDirection(0.0, 0.0, 1.0);
	auto direction = axis.Direction();
	CHECK(area == Approx(78.5398));
	CHECK(direction.X() == Approx(expectedDirection.X()).margin(tol));
	CHECK(direction.Y() == Approx(expectedDirection.Y()).margin(tol));
	CHECK(direction.Z() == Approx(expectedDirection.Z()).margin(tol));
	std::vector <AMCAX::Point3> test3DPoints = {
		AMCAX::Point3(0.0, 0.0, 0.0),
		AMCAX::Point3(4.0, 0.0, 0.0),
	};
	for (const auto& point : test3DPoints)
	{
		double distanceToCenter = std::sqrt(std::pow(point.X() - center3D.X(), 2) + std::pow(point.Y() - center3D.Y(), 2) + std::pow(point.Z() - center3D.Z(), 2));
		bool expectedIsCircle = distanceToCenter <= 5.0 + tol;
		bool isInCircle = circle3D.Contains(point, tol);
		CHECK(!isInCircle == expectedIsCircle);
	}
	AMCAX::PointT<double, 3>  pointOutside(10.0, 0.0, 0.0);
	double expectedDistance = 5.0;
	CHECK(circle3D.Distance(pointOutside) == Approx(expectedDistance));
	double length = circle3D.Length();
	CHECK(length == Approx(31.4159));
	auto location = circle3D.Location();
	CHECK(location.X() == Approx(0.0));
	CHECK(location.Y() == Approx(0.0));
	CHECK(location.Z() == Approx(0.0));
	AMCAX::PointT<double, 3> mirrorPoint(1.0, 0.0, 0.0);
	circle3D.Mirror(mirrorPoint);
	auto mirroredLocation = circle3D.Location();
	CHECK(mirroredLocation.X() == Approx(2.0));
	CHECK(mirroredLocation.Y() == Approx(0.0));
	CHECK(mirroredLocation.Z() == Approx(0.0));
	auto position = circle3D.Position();   
	double r = circle3D.Radius();
	CHECK(r == 5.0);
	Direction3 zDirection(0.0, 0.0, 1.0);
	Axis3 zAxis(center3D, zDirection);
	Transformation3 rotation;
	rotation.SetRotation(zAxis, M_PI / 2);  
	Point3 newCenter1 = center3D.Transformed(rotation);
	CHECK(newCenter1.X() == 0.0);
	CHECK(newCenter1.Y() == 0.0);
	CHECK(newCenter1.Z() == 0.0);
	double angle = M_PI / 2;
	circle3D.Rotated(zAxis, angle);
	AMCAX::Frame3 frame = circle3D.Position();
	CHECK(frame.Location().X() == 2.0);
	CHECK(frame.Location().Y() == 0.0);
	CHECK(frame.Location().Z() == 0.0);
	double scale = 2.0;
	circle3D.Scale(center3D, scale);
	CHECK(circle3D.Radius() == radius3D * 2.0);
	AMCAX::PointT<double, 3> insidePoint(3.0, 4.0, 0.0);
	AMCAX::PointT<double, 3> onCirclePoint(5.0, 0.0, 0.0);
	AMCAX::PointT<double, 3> outsidePoint(8.0, 6.0, 0.0);
	double insideSquaredDistance = circle3D.SquaredDistance(insidePoint);
	double onCircleSquaredDistance = circle3D.SquaredDistance(onCirclePoint);
	double outsideSquaredDistance = circle3D.SquaredDistance(outsidePoint);
	CHECK(insideSquaredDistance == Approx(34.5378));
	CHECK(onCircleSquaredDistance == 81.0);
	CHECK(outsideSquaredDistance == Approx(7.7779));
	VectorT<double, 3> translationVector(5.0, 5.0, 0.0);
	circle3D.Translate(translationVector);
	CHECK(circle3D.Location().X() == 9.0);
	CHECK(circle3D.Location().Y() == 5.0);
	CHECK(circle3D.Location().Z() == 0.0);
	auto xAxis = circle3D.XAxis();
	auto yAxis = circle3D.YAxis();
	CHECK(xAxis.Direction().X() == Approx(-1.0));
	CHECK(yAxis.Direction().Y() == Approx(-1.0));
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] double Distance(const PointT<double, DIM>& p)	 @return The distance from the point to the circle
	 @param p The point
	 @brief Compute the distance from a point to the circle
,
 "output":#include <math/CircleT.hpp>
#include <common/CoordT.hpp>
#include <common/TransformationType.hpp>
#include <common/DirectionT.hpp>
#include <common/PointT.hpp>
#include <common/Precision.hpp>
#include <common/CoordT.hpp>
#include <common/TransformationType.hpp>
#include <topology/TopoEdge.hpp>
#include <modeling/MakeEdge.hpp>
#include <topology/TopoWire.hpp>
#include <modeling/MakeWire.hpp>
#include <geometry/GlobalProperty.hpp>
#include <topology/BRepGlobalProperty.hpp>
#include<iostream>
#include "catch.hpp" 
using namespace std;
using namespace AMCAX;
TEST_CASE("TestCircle3D", "[math][Circle3D]")
{
	AMCAX::Circle3 circle3D;
	AMCAX::Point3  center3D(0.0, 0.0, 0.0);
	double radius3D = 5.0;
	double tol = 0.1;
	circle3D.SetLocation(center3D);
	circle3D.SetRadius(radius3D);
	double area = circle3D.Area();
	auto axis = circle3D.Axis();
	AMCAX::Point3 expectedDirection(0.0, 0.0, 1.0);
	auto direction = axis.Direction();
	CHECK(area == Approx(78.5398));
	CHECK(direction.X() == Approx(expectedDirection.X()).margin(tol));
	CHECK(direction.Y() == Approx(expectedDirection.Y()).margin(tol));
	CHECK(direction.Z() == Approx(expectedDirection.Z()).margin(tol));
	std::vector <AMCAX::Point3> test3DPoints = {
		AMCAX::Point3(0.0, 0.0, 0.0),
		AMCAX::Point3(4.0, 0.0, 0.0),
	};
	for (const auto& point : test3DPoints)
	{
		double distanceToCenter = std::sqrt(std::pow(point.X() - center3D.X(), 2) + std::pow(point.Y() - center3D.Y(), 2) + std::pow(point.Z() - center3D.Z(), 2));
		bool expectedIsCircle = distanceToCenter <= 5.0 + tol;
		bool isInCircle = circle3D.Contains(point, tol);
		CHECK(!isInCircle == expectedIsCircle);
	}
	AMCAX::PointT<double, 3>  pointOutside(10.0, 0.0, 0.0);
	double expectedDistance = 5.0;
	CHECK(circle3D.Distance(pointOutside) == Approx(expectedDistance));
	double length = circle3D.Length();
	CHECK(length == Approx(31.4159));
	auto location = circle3D.Location();
	CHECK(location.X() == Approx(0.0));
	CHECK(location.Y() == Approx(0.0));
	CHECK(location.Z() == Approx(0.0));
	AMCAX::PointT<double, 3> mirrorPoint(1.0, 0.0, 0.0);
	circle3D.Mirror(mirrorPoint);
	auto mirroredLocation = circle3D.Location();
	CHECK(mirroredLocation.X() == Approx(2.0));
	CHECK(mirroredLocation.Y() == Approx(0.0));
	CHECK(mirroredLocation.Z() == Approx(0.0));
	auto position = circle3D.Position();   
	double r = circle3D.Radius();
	CHECK(r == 5.0);
	Direction3 zDirection(0.0, 0.0, 1.0);
	Axis3 zAxis(center3D, zDirection);
	Transformation3 rotation;
	rotation.SetRotation(zAxis, M_PI / 2);  
	Point3 newCenter1 = center3D.Transformed(rotation);
	CHECK(newCenter1.X() == 0.0);
	CHECK(newCenter1.Y() == 0.0);
	CHECK(newCenter1.Z() == 0.0);
	double angle = M_PI / 2;
	circle3D.Rotated(zAxis, angle);
	AMCAX::Frame3 frame = circle3D.Position();
	CHECK(frame.Location().X() == 2.0);
	CHECK(frame.Location().Y() == 0.0);
	CHECK(frame.Location().Z() == 0.0);
	double scale = 2.0;
	circle3D.Scale(center3D, scale);
	CHECK(circle3D.Radius() == radius3D * 2.0);
	AMCAX::PointT<double, 3> insidePoint(3.0, 4.0, 0.0);
	AMCAX::PointT<double, 3> onCirclePoint(5.0, 0.0, 0.0);
	AMCAX::PointT<double, 3> outsidePoint(8.0, 6.0, 0.0);
	double insideSquaredDistance = circle3D.SquaredDistance(insidePoint);
	double onCircleSquaredDistance = circle3D.SquaredDistance(onCirclePoint);
	double outsideSquaredDistance = circle3D.SquaredDistance(outsidePoint);
	CHECK(insideSquaredDistance == Approx(34.5378));
	CHECK(onCircleSquaredDistance == 81.0);
	CHECK(outsideSquaredDistance == Approx(7.7779));
	VectorT<double, 3> translationVector(5.0, 5.0, 0.0);
	circle3D.Translate(translationVector);
	CHECK(circle3D.Location().X() == 9.0);
	CHECK(circle3D.Location().Y() == 5.0);
	CHECK(circle3D.Location().Z() == 0.0);
	auto xAxis = circle3D.XAxis();
	auto yAxis = circle3D.YAxis();
	CHECK(xAxis.Direction().X() == Approx(-1.0));
	CHECK(yAxis.Direction().Y() == Approx(-1.0));
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] double SquaredDistance(const PointT<double, DIM>& p)	 @return The squared distance from the point to the circle
	 @param p The point
	 @brief Compute the squared distance from a point to the circle
,
 "output":#include <math/CircleT.hpp>
#include <common/CoordT.hpp>
#include <common/TransformationType.hpp>
#include <common/DirectionT.hpp>
#include <common/PointT.hpp>
#include <common/Precision.hpp>
#include <common/CoordT.hpp>
#include <common/TransformationType.hpp>
#include <topology/TopoEdge.hpp>
#include <modeling/MakeEdge.hpp>
#include <topology/TopoWire.hpp>
#include <modeling/MakeWire.hpp>
#include <geometry/GlobalProperty.hpp>
#include <topology/BRepGlobalProperty.hpp>
#include<iostream>
#include "catch.hpp" 
using namespace std;
using namespace AMCAX;
TEST_CASE("TestCircle3D", "[math][Circle3D]")
{
	AMCAX::Circle3 circle3D;
	AMCAX::Point3  center3D(0.0, 0.0, 0.0);
	double radius3D = 5.0;
	double tol = 0.1;
	circle3D.SetLocation(center3D);
	circle3D.SetRadius(radius3D);
	double area = circle3D.Area();
	auto axis = circle3D.Axis();
	AMCAX::Point3 expectedDirection(0.0, 0.0, 1.0);
	auto direction = axis.Direction();
	CHECK(area == Approx(78.5398));
	CHECK(direction.X() == Approx(expectedDirection.X()).margin(tol));
	CHECK(direction.Y() == Approx(expectedDirection.Y()).margin(tol));
	CHECK(direction.Z() == Approx(expectedDirection.Z()).margin(tol));
	std::vector <AMCAX::Point3> test3DPoints = {
		AMCAX::Point3(0.0, 0.0, 0.0),
		AMCAX::Point3(4.0, 0.0, 0.0),
	};
	for (const auto& point : test3DPoints)
	{
		double distanceToCenter = std::sqrt(std::pow(point.X() - center3D.X(), 2) + std::pow(point.Y() - center3D.Y(), 2) + std::pow(point.Z() - center3D.Z(), 2));
		bool expectedIsCircle = distanceToCenter <= 5.0 + tol;
		bool isInCircle = circle3D.Contains(point, tol);
		CHECK(!isInCircle == expectedIsCircle);
	}
	AMCAX::PointT<double, 3>  pointOutside(10.0, 0.0, 0.0);
	double expectedDistance = 5.0;
	CHECK(circle3D.Distance(pointOutside) == Approx(expectedDistance));
	double length = circle3D.Length();
	CHECK(length == Approx(31.4159));
	auto location = circle3D.Location();
	CHECK(location.X() == Approx(0.0));
	CHECK(location.Y() == Approx(0.0));
	CHECK(location.Z() == Approx(0.0));
	AMCAX::PointT<double, 3> mirrorPoint(1.0, 0.0, 0.0);
	circle3D.Mirror(mirrorPoint);
	auto mirroredLocation = circle3D.Location();
	CHECK(mirroredLocation.X() == Approx(2.0));
	CHECK(mirroredLocation.Y() == Approx(0.0));
	CHECK(mirroredLocation.Z() == Approx(0.0));
	auto position = circle3D.Position();   
	double r = circle3D.Radius();
	CHECK(r == 5.0);
	Direction3 zDirection(0.0, 0.0, 1.0);
	Axis3 zAxis(center3D, zDirection);
	Transformation3 rotation;
	rotation.SetRotation(zAxis, M_PI / 2);  
	Point3 newCenter1 = center3D.Transformed(rotation);
	CHECK(newCenter1.X() == 0.0);
	CHECK(newCenter1.Y() == 0.0);
	CHECK(newCenter1.Z() == 0.0);
	double angle = M_PI / 2;
	circle3D.Rotated(zAxis, angle);
	AMCAX::Frame3 frame = circle3D.Position();
	CHECK(frame.Location().X() == 2.0);
	CHECK(frame.Location().Y() == 0.0);
	CHECK(frame.Location().Z() == 0.0);
	double scale = 2.0;
	circle3D.Scale(center3D, scale);
	CHECK(circle3D.Radius() == radius3D * 2.0);
	AMCAX::PointT<double, 3> insidePoint(3.0, 4.0, 0.0);
	AMCAX::PointT<double, 3> onCirclePoint(5.0, 0.0, 0.0);
	AMCAX::PointT<double, 3> outsidePoint(8.0, 6.0, 0.0);
	double insideSquaredDistance = circle3D.SquaredDistance(insidePoint);
	double onCircleSquaredDistance = circle3D.SquaredDistance(onCirclePoint);
	double outsideSquaredDistance = circle3D.SquaredDistance(outsidePoint);
	CHECK(insideSquaredDistance == Approx(34.5378));
	CHECK(onCircleSquaredDistance == 81.0);
	CHECK(outsideSquaredDistance == Approx(7.7779));
	VectorT<double, 3> translationVector(5.0, 5.0, 0.0);
	circle3D.Translate(translationVector);
	CHECK(circle3D.Location().X() == 9.0);
	CHECK(circle3D.Location().Y() == 5.0);
	CHECK(circle3D.Location().Z() == 0.0);
	auto xAxis = circle3D.XAxis();
	auto yAxis = circle3D.YAxis();
	CHECK(xAxis.Direction().X() == Approx(-1.0));
	CHECK(yAxis.Direction().Y() == Approx(-1.0));
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":CircleS& Scale(const PointT<double, DIM>& p, double scale)	 @return The reference to self
	 @param scale The scale value
	 @param p The scaling center point
	 @brief Scale the circle by a center point
,
 "output":#include <math/CircleT.hpp>
#include <common/CoordT.hpp>
#include <common/TransformationType.hpp>
#include <common/DirectionT.hpp>
#include <common/PointT.hpp>
#include <common/Precision.hpp>
#include <common/CoordT.hpp>
#include <common/TransformationType.hpp>
#include <topology/TopoEdge.hpp>
#include <modeling/MakeEdge.hpp>
#include <topology/TopoWire.hpp>
#include <modeling/MakeWire.hpp>
#include <geometry/GlobalProperty.hpp>
#include <topology/BRepGlobalProperty.hpp>
#include<iostream>
#include "catch.hpp" 
using namespace std;
using namespace AMCAX;
TEST_CASE("TestCircle2D", "[math][Circle2D]")
{
	AMCAX::CircleT<double, 2> circle2D;
	AMCAX::Point2 center2D(0.0, 0.0);
	double redius2D = 5.0;
	double tol = 0.1;
	circle2D.SetLocation(center2D);
	circle2D.SetRadius(redius2D);
	double area2D = circle2D.Area();
	double length2D = circle2D.Length();
	AMCAX::Point2 retcenter2D = circle2D.Location();
	double retarea2D = M_PI * redius2D * redius2D;
	double retlength2D = 2 * M_PI * redius2D;
	std::cout << area2D << std::endl;
	std::cout << length2D << std::endl;
	std::cout << retcenter2D.X() << std::endl;
	std::cout << retcenter2D.Y() << std::endl;
	CHECK(area2D == retarea2D);
	CHECK(length2D == retlength2D);
	CHECK(retcenter2D.X() == center2D.X());
	CHECK(retcenter2D.Y() == center2D.Y());
	double a, b, c, d, e, f;
	circle2D.Coefficients(a, b, c, d, e, f);
	std::cout << a << std::endl;
	std::cout << b << std::endl;
	std::cout << c << std::endl;
	std::cout << d << std::endl;
	std::cout << e << std::endl;
	std::cout << f << std::endl;
	CHECK(a == 1);
	CHECK(b == 1);
	CHECK(c == 0);
	CHECK(d == 0);
	CHECK(e == 0);
	CHECK(f == -25);
	std::vector < AMCAX::Point2> testPoints = {
		AMCAX::Point2(3.0, 4.0),
		AMCAX::Point2(5.0, 0.0),
		AMCAX::Point2(4.9, 0.0),
		AMCAX::Point2(5.1, 0.0),
		AMCAX::Point2(6.0, 0.0)
	};
	for (const auto& point : testPoints)
	{
		double distanceToCenter = std::sqrt(point.X() * point.X() + point.Y() * point.Y());
		bool expectedIsInCircle = distanceToCenter <= 5.0 + tol;
		bool isInCircle = circle2D.Contains(point, tol);
		CHECK(isInCircle == expectedIsInCircle);
	}
	for (const auto& point : testPoints)
	{
		double distance = circle2D.Distance(point);
		double expectedDistance = std::abs(std::sqrt(std::pow(point.X() - center2D.X(), 2) + std::pow(point.Y() - center2D.Y(), 2)) - redius2D);
		CHECK(distance == expectedDistance);
	}
	AMCAX::AxisT<double, 2> mirrorAxis(AMCAX::Point2(0.0, 0.0), AMCAX::Direction2(0.0, 1.0));
	circle2D.Mirror(mirrorAxis);
	AMCAX::Point2 mirroredCenter = circle2D.Location();
	std::cout << "Mirrored circle center: (" << mirroredCenter.X() << ", " << mirroredCenter.Y() << ")" << std::endl;
	CHECK(mirroredCenter.X() == center2D.X());
	CHECK(mirroredCenter.Y() == center2D.Y());
	const AMCAX::FrameT<double, 2>& frame = circle2D.Position();
	AMCAX::Point2 rotationPoint(0.0, 0.0);
	double  rotationAngle = M_PI / 4;
	auto rotatedCircle = circle2D.Rotated(rotationPoint, rotationAngle);
	double cosAngle = cos(rotationAngle);
	double sinAngle = sin(rotationAngle);
	double newX = cosAngle * (center2D.X() - rotationPoint.X()) - sinAngle * (center2D.Y() - rotationPoint.Y()) + rotationPoint.X();
	double newY = sinAngle * (center2D.X() - rotationPoint.X()) + cosAngle * (center2D.Y() - rotationPoint.Y()) + rotationPoint.Y();
	auto rotatedCenter = rotatedCircle.Location();
	CHECK(newX == center2D.X());
	CHECK(newY == center2D.Y());
	AMCAX::Point2 scalingCenter(0.0, 0.0);
	double scalingFactor = 2.0;
	auto scaledCircle = circle2D.Scale(scalingCenter, scalingFactor);
	double scaledRadius = scaledCircle.Radius();
	double expectedScaledRadius = redius2D * scalingFactor;
	CHECK(std::abs(scaledRadius - expectedScaledRadius) < 1e-6);
	AMCAX::VectorT<double, 2> translationVector(2.0, 3.0);
	auto translatedCircle = circle2D.Translated(translationVector);
	auto translatedCenter = translatedCircle.Location();
	double translatedX = center2D.X() + translationVector.X();
	CHECK(translatedX == translatedCenter.X());
	auto xAxis = circle2D.XAxis();
	auto directionAxis = xAxis.Direction();
	CHECK(directionAxis.X() == -1.0);
	CHECK(directionAxis.Y() == 0.0);
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] double Area()	 @return The area of the ellipse
	 @brief Get the area of the ellipse
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <common/FrameT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <math/EllipseT.hpp>
using namespace AMCAX;
using namespace std;
TEST_CASE("case1:this is a case for Test Ellipse2", "[math][Ellipse2][P1]")
{
	Axis2 axis;
	double major = 5.0;
	double minor = 4.0;
	bool isRight = true;
	Ellipse2 ellipse(axis, major, minor, isRight);
	SECTION("Area")
	{
		double S = ellipse.Area();
		CHECK(S == Approx(M_PI * major * minor));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":EllipseS& Scale(const PointT<double, DIM>& point, double scale)	 @return The reference to self
	 @param scale The scale value
	 @param point The scaling center point
	 @brief Scale the ellipse by a center point
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <common/FrameT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <math/EllipseT.hpp>
using namespace AMCAX;
using namespace std;
TEST_CASE("case3:this is a case for Test-Ellipse2-Rotate", "[math][Ellipse2][P1]")
{
	Point2 point1(6.0, 0.0);
	Direction2 dir1(0.0, 1.0);
	Axis2 axis1(point1, dir1);
	double major = 5.0;
	double minor = 4.0;
	bool isRight = true;
	Ellipse2 ellipse(axis1, major, minor, isRight);
	double angle = M_PI_2;
	Point2 point_temp(0.0, 0.0);
	SECTION("Scale")
	{
		Ellipse2 scale_ellipse = ellipse.Scale(point, scale);
		CHECK(ellipse.Location().X() == Approx(2.5));
		CHECK(ellipse.Location().Y() == Approx(-1.0));
		CHECK(ellipse.MajorRadius() == Approx(2.5));
		CHECK(ellipse.MinorRadius() == Approx(2.0));
		CHECK(scale_ellipse.Location().X() == Approx(2.5));
		CHECK(scale_ellipse.Location().Y() == Approx(-1.0));
		CHECK(scale_ellipse.MajorRadius() == Approx(2.5));
		CHECK(scale_ellipse.MinorRadius() == Approx(2.0));
	}
	scale = -2.0;}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":EllipseS& Transform(const TransformationT<double, DIM>& tr)	 @return The reference to self
	 @param tr The transformation
	 @brief Transform the ellipse
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <common/FrameT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <math/EllipseT.hpp>
using namespace AMCAX;
using namespace std;
TEST_CASE("case3:this is a case for Test-Ellipse2-Rotate", "[math][Ellipse2][P1]")
{
	Point2 point1(6.0, 0.0);
	Direction2 dir1(0.0, 1.0);
	Axis2 axis1(point1, dir1);
	double major = 5.0;
	double minor = 4.0;
	bool isRight = true;
	Ellipse2 ellipse(axis1, major, minor, isRight);
	double angle = M_PI_2;
	Point2 point_temp(0.0, 0.0);
	SECTION("Transform")
	{
		Ellipse2 Transfor_ellipse = ellipse.Transform(tr);
		CHECK(ellipse.Location().X() == Approx(5.0));
		CHECK(ellipse.Location().Y() == Approx(-2.0));
		CHECK(ellipse.MajorRadius() == Approx(5.0));
		CHECK(ellipse.MinorRadius() == Approx(4.0));
		CHECK(Transfor_ellipse.Location().X() == Approx(5.0));
		CHECK(Transfor_ellipse.Location().Y() == Approx(-2.0));
		CHECK(Transfor_ellipse.MajorRadius() == Approx(5.0));
		CHECK(Transfor_ellipse.MinorRadius() == Approx(4.0));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] double Area()	 @return The area of the ellipse
	 @brief Get the area of the ellipse
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <common/FrameT.hpp>
#include <common/TransformationT.hpp>
#include <common/VectorT.hpp>
#include <math/EllipseT.hpp>
using namespace AMCAX;
using namespace std;
TEST_CASE("case1:this is a case for Test Ellipse3", "[math][Ellipse3][P1]")
{
	Frame3 frame;
	double major = 5.0;
	double minor = 4.0;
	Ellipse3 ellipse(frame, major, minor);
	SECTION("Area")
	{
		double S = ellipse.Area();
		CHECK(S == Approx(M_PI * major * minor));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] double FocalParameter()	 @return The focal parameter
	          Focal parameter = 2 * focalLength.
	 @details The focal parameter of parabola is the distance from the focus to the directrix.
	 @brief Get the focal parameter of the parabola
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <geometry/Geom2Parabola.hpp>
using namespace AMCAX;
using namespace std;
TEST_CASE("case1:this is a case for Test Geom2Parabola", "[math][Geom2Parabola][P1]")
{
	Axis2 axis;
	double focal = 5.0;
	bool isRight = true;
	Geom2Parabola g2p(axis, focal, isRight);
	SECTION("FocalParameter")
	{
		double FP = g2p.FocalParameter();
		double fp = 2 * focal;
		CHECK(FP == fp);
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] double SemilatusRectum()	 @return The semilatus rectum
	          Semilatus rectum = 2 * focalLength
	 @details The semilatus rectum of parabola is half of the length of the chord through a focus parallel to the directrix.
	 @brief Get the semilatus rectum of the parabola
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <geometry/Geom2Parabola.hpp>
using namespace AMCAX;
using namespace std;
TEST_CASE("case1:this is a case for Test Geom2Parabola", "[math][Geom2Parabola][P1]")
{
	Axis2 axis;
	double focal = 5.0;
	bool isRight = true;
	Geom2Parabola g2p(axis, focal, isRight);
	SECTION("SemilatusRectum")
	{
		double SR = g2p.SemilatusRectum();
		double sr = 2 * focal;
		CHECK(SR == sr);
	}
}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] double FocalParameter()	 @return The focal parameter
	          Focal parameter = 2 * focalLength.
	 @details The focal parameter of parabola is the distance from the focus to the directrix.
	 @brief Get the focal parameter of the parabola
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <geometry/Geom3Parabola.hpp>
using namespace AMCAX;
using namespace std;
TEST_CASE("case1:this is a case for Test Geom3Parabola", "[math][Geom3Parabola][P1]")
{
	Frame3 frame;
	double focal = 5.0;
	Geom3Parabola g3p(frame, focal);
	SECTION("FocalParameter")
	{
		double FP = g3p.FocalParameter();
		double fp = 2 * focal;
		CHECK(FP == fp);
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] double SemilatusRectum()	 @return The semilatus rectum
	          Semilatus rectum = 2 * focalLength
	 @details The semilatus rectum of parabola is half of the length of the chord through a focus parallel to the directrix.
	 @brief Get the semilatus rectum of the parabola
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <geometry/Geom3Parabola.hpp>
using namespace AMCAX;
using namespace std;
TEST_CASE("case1:this is a case for Test Geom3Parabola", "[math][Geom3Parabola][P1]")
{
	Frame3 frame;
	double focal = 5.0;
	Geom3Parabola g3p(frame, focal);
	SECTION("SemilatusRectum")
	{
		double SR = g3p.SemilatusRectum();
		double sr = 2 * focal;
		CHECK(SR == sr);
	}
}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] double FocalParameter()	 @return The focal parameter
	          Focal parameter = 2 * focalLength.
	 @details The focal parameter of parabola is the distance from the focus to the directrix.
	 @brief Get the focal parameter of the parabola
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <math/ParabolaT.hpp>
using namespace AMCAX;
using namespace std;
TEST_CASE("case1:this is a case for Test Parabola2", "[math][Parabola2][P1]")
{
	Axis2 axis;
	double focal = 5.0;
	bool isRight = true;
	Parabola2 parabola(axis, focal, isRight);
	SECTION("FocalParameter")
	{
		double FP = parabola.FocalParameter();
		double fp = 2 * focal;
		CHECK(FP == fp);
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] double SemilatusRectum()	 @return The semilatus rectum
	          Semilatus rectum = 2 * focalLength
	 @details The semilatus rectum of parabola is half of the length of the chord through a focus parallel to the directrix.
	 @brief Get the semilatus rectum of the parabola
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <math/ParabolaT.hpp>
using namespace AMCAX;
using namespace std;
TEST_CASE("case1:this is a case for Test Parabola2", "[math][Parabola2][P1]")
{
	Axis2 axis;
	double focal = 5.0;
	bool isRight = true;
	Parabola2 parabola(axis, focal, isRight);
	SECTION("SemilatusRectum")
	{
		double SR = parabola.SemilatusRectum();
		double sr = 2 * focal;
		CHECK(SR == sr);
	}
}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] double FocalParameter()	 @return The focal parameter
	          Focal parameter = 2 * focalLength.
	 @details The focal parameter of parabola is the distance from the focus to the directrix.
	 @brief Get the focal parameter of the parabola
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <math/ParabolaT.hpp>
using namespace AMCAX;
using namespace std;
TEST_CASE("case1:this is a case for Test Parabola3", "[math][Parabola3][P1]")
{
	Frame3 frame;
	double focal = 5.0;
	Parabola3 parabola(frame, focal);
	SECTION("FocalParameter")
	{
		double FP = parabola.FocalParameter();
		double fp = 2 * focal;
		CHECK(FP == fp);
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] double SemilatusRectum()	 @return The semilatus rectum
	          Semilatus rectum = 2 * focalLength
	 @details The semilatus rectum of parabola is half of the length of the chord through a focus parallel to the directrix.
	 @brief Get the semilatus rectum of the parabola
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <math/ParabolaT.hpp>
using namespace AMCAX;
using namespace std;
TEST_CASE("case1:this is a case for Test Parabola3", "[math][Parabola3][P1]")
{
	Frame3 frame;
	double focal = 5.0;
	Parabola3 parabola(frame, focal);
	SECTION("SemilatusRectum")
	{
		double SR = parabola.SemilatusRectum();
		double sr = 2 * focal;
		CHECK(SR == sr);
	}
}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] bool Contains(const PointT<double, DIM>& p, double tol)	 @return True if the point is on the line under the tolerance
	 @param tol The tolerance
	 @param p The point
	 @brief Does the line contain a point under a distance tolerance
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <math/LineT.hpp>
#include <modeling/MakeEdge2d.hpp>
using AMCAX::Line2;
#define ONE_RADIAN (M_PI / 180.)
TEST_CASE("case2: Line base method Test", "[math][Line2][p1]")
{
	SECTION("Contains")
	{
		Line2 line(Axis2(Point2(2., 1.), Direction2(1., 1.)));  
		Point2 point1(2., 1.);  
		Point2 point2(1., 1.);  
		CHECK(line.Contains(point1, 1e-5));
		CHECK_FALSE(line.Contains(point2, 1e-5));
		CHECK(line.Contains(point2, 1.));  
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] const PointT<double, DIM>& Location()	 @return The location of the line
	 @brief Get the location point of the line
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <math/LineT.hpp>
#include <modeling/MakeEdge2d.hpp>
using AMCAX::Line2;
#define ONE_RADIAN (M_PI / 180.)
TEST_CASE("case1: Line basic interface test", "[math][Line2][p1]")
{
	SECTION("Parameterless constructor test")
	{
		Line2 line;  
		CHECK(line.Location().IsEqual(Axis2().Location(), 0.001));
		CHECK(line.Direction().IsEqual(Axis2().Direction(), 1e-5 * ONE_RADIAN));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] Derived Scaled(const PointT<double, DIM>& point, double scale)	 @return The scaled line
	 @param scale The scale value
	 @param point The scaling center point
	 @brief Get the line scaled by a point
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <math/LineT.hpp>
#include <modeling/MakeEdge2d.hpp>
using AMCAX::Line2;
#define ONE_RADIAN (M_PI / 180.)
TEST_CASE("case2: Line base method Test", "[math][Line2][p1]")
{
	SECTION("Scale")
	{
		Line2 line(Point2(0., -1.), Direction2());
		Point2 point;
		double distance = line.Distance(point);
		Line2 lineScale1 = line.Scaled(point, 1.1);
		CHECK(lineScale1.Distance(point) > distance);
		CHECK(lineScale1.Contains(Point2(0., -1.1), 1e-5));
		Line2 lineScale2 = line.Scaled(point, 1.);
		CHECK(lineScale2.Distance(point) == Approx(distance).margin(1e-5));
		CHECK(lineScale2.Contains(Point2(0., -1.), 1e-5));
		Line2 lineScale3 = line.Scaled(point, 0.8);
		CHECK(lineScale3.Distance(point) < distance);
		CHECK(lineScale3.Contains(Point2(0., -0.8), 1e-5));
		Line2 lineScale4 = line.Scaled(point, 0.);
		line.SetDirection(Direction2(-1.0, 4.0));
		Line2 lineScale5 = line.Scaled(Point2(-1., 2.), 0.);
		CHECK(lineScale4.Contains(Point2(0., 0.), 1e-5));
		CHECK(lineScale4.Direction().IsEqual(Direction2(), 1e-6 * ONE_RADIAN));
		CHECK(lineScale5.Contains(Point2(-1., 2.), 1e-5));
		CHECK(lineScale5.Direction().IsEqual(Direction2(-1., 4.), 1e-6 * ONE_RADIAN));
		Line2 lineScale6 = line.Scaled(point, -1.);
		CHECK(lineScale6.Direction().IsEqual(Direction2(1., -4.), 1e-5 * ONE_RADIAN));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":Derived& Translate(const VectorT<double, DIM>& vec)	 @return The reference to self
	 @param vec The translation vector
	 @brief Translate the line by a vector
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <math/LineT.hpp>
#include <modeling/MakeEdge2d.hpp>
using AMCAX::Line2;
#define ONE_RADIAN (M_PI / 180.)
TEST_CASE("case2: Line base method Test", "[math][Line2][p1]")
{
	SECTION("Translate Test")
	{
		Line2 line;
		line.Translate(Vector2(2., 0.));  
		CHECK(line.Direction().IsEqual(Direction2(), 1e-5 * ONE_RADIAN));
		CHECK(line.Contains(Point2(2., 0.), 1e-5));
		Line2 translateLine = line.Translated(Point2(2., 0.), Point2(-10., 0.));
		CHECK(translateLine.Contains(Point2(-10., 0.), 1e-5));
	}
}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] Derived Translated(const PointT<double, DIM>& p1, const PointT<double, DIM>& p2)	 @return The translated line
	 @param p2 The target point
	 @param p1 The source point
	 @brief Get the line translated by a vector from a point to another point
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <math/LineT.hpp>
#include <modeling/MakeEdge2d.hpp>
using AMCAX::Line2;
#define ONE_RADIAN (M_PI / 180.)
TEST_CASE("case2: Line base method Test", "[math][Line2][p1]")
{
	SECTION("Translate Test")
	{
		Line2 line;
		line.Translate(Vector2(2., 0.));  
		CHECK(line.Direction().IsEqual(Direction2(), 1e-5 * ONE_RADIAN));
		CHECK(line.Contains(Point2(2., 0.), 1e-5));
		Line2 translateLine = line.Translated(Point2(2., 0.), Point2(-10., 0.));
		CHECK(translateLine.Contains(Point2(-10., 0.), 1e-5));
	}
}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":void SetLocation(const PointT<double, DIM>& point)	 @param point The location point
	 @brief Set the location of the line
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <math/LineT.hpp>
#include <modeling/MakeEdge2d.hpp>
using AMCAX::Line2;
#define ONE_RADIAN (M_PI / 180.)
TEST_CASE("case2: Line base method Test", "[math][Line2][p1]")
{
	SECTION("SetLocation")
	{
		Line2 line(Point2(0., 0.), Direction2(1., 1.));  
		CHECK(line.Location().IsEqual(Point2(), 1e-5));
		line.SetLocation(Point2(2., 1.));  
		CHECK(line.Location().IsEqual(Point2(2., 1.), 1e-5));
		double a, b, c;
		line.Coefficients(a, b, c);
		CHECK(a == Approx(1. / std::sqrt(2)).margin(1e-5));
		CHECK(b == Approx(-1. / std::sqrt(2)).margin(1e-5));
		CHECK(c == Approx(-1. / std::sqrt(2)).margin(1e-5));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":void SetDirection(const DirectionT<double, DIM>& dir)	 @param dir The line direction
	 @brief Set the line direction
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <math/LineT.hpp>
#include <modeling/MakeEdge2d.hpp>
using AMCAX::Line2;
#define ONE_RADIAN (M_PI / 180.)
TEST_CASE("case2: Line base method Test", "[math][Line2][p1]")
{
	SECTION("SetDirection")
	{
		Line2 line(Point2(), Direction2(1., 1.));  
		CHECK(line.Direction().IsEqual(Direction2(1., 1.), 1e-5 * ONE_RADIAN));
		CHECK(line.Distance(Point2(1., 2.)) > 0.);
		line.SetDirection(Direction2(1., 2.));  
		CHECK(line.Direction().IsEqual(Direction2(1., 2.), 1e-5 * ONE_RADIAN));
		CHECK(line.Distance(Point2(1., 2.)) == Approx(0.).margin(1e-5));
		double a, b, c;
		line.Coefficients(a, b, c);
		CHECK(a == Approx(2. / std::sqrt(5)).margin(1e-5));
		CHECK(b == Approx(-1. / std::sqrt(5)).margin(1e-5));
		CHECK(c == Approx(0. / std::sqrt(5)).margin(1e-5));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":void SetPosition(const AxisT<double, DIM>& axis)	 @param axis The axis
	 @brief Set the axis of the line
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <math/LineT.hpp>
#include <modeling/MakeEdge2d.hpp>
using AMCAX::Line2;
#define ONE_RADIAN (M_PI / 180.)
TEST_CASE("case2: Line base method Test", "[math][Line2][p1]")
{
	SECTION("SetPosition")
	{
		Line2 line;
		CHECK(line.Location().IsEqual(Point2(0., 0.), 1e-5));
		CHECK(line.Direction().IsEqual(Direction2(1., 0.), 1e-5 * ONE_RADIAN));
		Axis2 axis(Point2(2., 1.), Direction2(1., 1.));
		line.SetPosition(axis);  
		double a, b, c;
		line.Coefficients(a, b, c);
		CHECK(a == Approx(1. / std::sqrt(2)).margin(1e-5));
		CHECK(b == Approx(-1. / std::sqrt(2)).margin(1e-5));
		CHECK(c == Approx(-1. / std::sqrt(2)).margin(1e-5));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] const DirectionT<double, DIM>& Direction()	 @return The direction of the line
	 @brief Get the direction of the line
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <math/LineT.hpp>
#include <modeling/MakeEdge2d.hpp>
using AMCAX::Line2;
#define ONE_RADIAN (M_PI / 180.)
TEST_CASE("case2: Line base method Test", "[math][Line2][p1]")
{
	SECTION("Translate Test")
	{
		Line2 line;
		line.Translate(Vector2(2., 0.));  
		CHECK(line.Direction().IsEqual(Direction2(), 1e-5 * ONE_RADIAN));
		CHECK(line.Contains(Point2(2., 0.), 1e-5));
		Line2 translateLine = line.Translated(Point2(2., 0.), Point2(-10., 0.));
		CHECK(translateLine.Contains(Point2(-10., 0.), 1e-5));
	}
}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] auto Angle(const LineBase& other)	 @return The angle between the line and the other line
	 @param other The other line
	 @brief Compute the angle between the line and the other line
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <math/LineT.hpp>
#include <modeling/MakeEdge2d.hpp>
using AMCAX::Line2;
#define ONE_RADIAN (M_PI / 180.)
TEST_CASE("case2: Line base method Test", "[math][Line2][p1]")
{
	SECTION("Angle")
	{
		Line2 line;
		Line2 line2(Point2(), Direction2(0., 1.));
		CHECK(line.Angle(line2) == Approx(M_PI_2));
		CHECK(line2.Angle(line) == Approx(-M_PI_2));
		Line2 line3(Point2(), Direction2(2., 3.));
		Line2 line4(Point2(), Direction2(5., -8.));
		CHECK(line4.Angle(line3) == Approx(
			std::acos((2. * 5. + 3. * (-8.)) / (std::sqrt(4. + 9.) * std::sqrt(25. + 64.)))
		).margin(1e-5 * ONE_RADIAN));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":Derived& Reverse()	 @return The reference to self
	 @brief Reverse the line direction
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <math/LineT.hpp>
#include <modeling/MakeEdge2d.hpp>
using AMCAX::Line2;
#define ONE_RADIAN (M_PI / 180.)
TEST_CASE("case2: Line base method Test", "[math][Line2][p1]")
{
	SECTION("Reverse")
	{
		Line2 line;
		line.Reverse();
		CHECK(line.Direction().IsEqual(Direction2(-1., 0.), 1e-5 * ONE_RADIAN));
		Line2 line2(Point2(), Direction2(-3., 98.));
		line2.Reverse();
		CHECK(line2.Direction().IsEqual(Direction2(3., -98.), 1e-5 * ONE_RADIAN));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":LineS(double a, double b, double c)	 @param a,b,c The coefficients
	 @brief Construct from the algebraic coefficients of 2D line
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <math/LineT.hpp>
#include <modeling/MakeEdge2d.hpp>
using AMCAX::Line2;
#define ONE_RADIAN (M_PI / 180.)
TEST_CASE("case1: Line basic interface test", "[math][Line2][p1]")
{
	SECTION("Parameterized constructor test")
	{
		Line2 line1(Axis2(Point2(1., 0.), Direction2(2., 1.)));
		Line2 line2(Point2(1., 0.), Direction2(2., 1.));  
		Line2 line3(1, -2, -1);
		double a, b, c;
		line1.Coefficients(a, b, c);
		CHECK(a == Approx(1.0 / std::sqrt(5)));
		CHECK(b == Approx(-2.0 / std::sqrt(5)));
		CHECK(c == Approx(-1.0 / std::sqrt(5)));
		line2.Coefficients(a, b, c);
		CHECK(a == Approx(1.0 / std::sqrt(5)));
		CHECK(b == Approx(-2.0 / std::sqrt(5)));
		CHECK(c == Approx(-1.0 / std::sqrt(5)));
		line3.Coefficients(a, b, c);
		CHECK(a == Approx(1.0 / std::sqrt(5)));
		CHECK(b == Approx(-2.0 / std::sqrt(5)));
		CHECK(c == Approx(-1.0 / std::sqrt(5)));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":void Coefficients(double& a, double& b, double& c)	 @param[out] a,b,c The coefficients
	 @brief The coefficients of the algebraic representation of the 2D line
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <math/LineT.hpp>
#include <modeling/MakeEdge2d.hpp>
using AMCAX::Line2;
#define ONE_RADIAN (M_PI / 180.)
TEST_CASE("case1: Line basic interface test", "[math][Line2][p1]")
{
	SECTION("Parameterized constructor test")
	{
		Line2 line1(Axis2(Point2(1., 0.), Direction2(2., 1.)));
		Line2 line2(Point2(1., 0.), Direction2(2., 1.));  
		Line2 line3(1, -2, -1);
		double a, b, c;
		line1.Coefficients(a, b, c);
		CHECK(a == Approx(1.0 / std::sqrt(5)));
		CHECK(b == Approx(-2.0 / std::sqrt(5)));
		CHECK(c == Approx(-1.0 / std::sqrt(5)));
		line2.Coefficients(a, b, c);
		CHECK(a == Approx(1.0 / std::sqrt(5)));
		CHECK(b == Approx(-2.0 / std::sqrt(5)));
		CHECK(c == Approx(-1.0 / std::sqrt(5)));
		line3.Coefficients(a, b, c);
		CHECK(a == Approx(1.0 / std::sqrt(5)));
		CHECK(b == Approx(-2.0 / std::sqrt(5)));
		CHECK(c == Approx(-1.0 / std::sqrt(5)));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] auto Distance(const Point2& p)	 @return The distance between the point and the line
	 @param p The point
	 @brief Compute the distance from a point to the line
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <math/LineT.hpp>
#include <modeling/MakeEdge2d.hpp>
using AMCAX::Line2;
#define ONE_RADIAN (M_PI / 180.)
TEST_CASE("case2: Line base method Test", "[math][Line2][p1]")
{
	SECTION("SetDirection")
	{
		Line2 line(Point2(), Direction2(1., 1.));  
		CHECK(line.Direction().IsEqual(Direction2(1., 1.), 1e-5 * ONE_RADIAN));
		CHECK(line.Distance(Point2(1., 2.)) > 0.);
		line.SetDirection(Direction2(1., 2.));  
		CHECK(line.Direction().IsEqual(Direction2(1., 2.), 1e-5 * ONE_RADIAN));
		CHECK(line.Distance(Point2(1., 2.)) == Approx(0.).margin(1e-5));
		double a, b, c;
		line.Coefficients(a, b, c);
		CHECK(a == Approx(2. / std::sqrt(5)).margin(1e-5));
		CHECK(b == Approx(-1. / std::sqrt(5)).margin(1e-5));
		CHECK(c == Approx(0. / std::sqrt(5)).margin(1e-5));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] auto SquaredDistance(const Point2& p)	 @return The squared distance between the point and the line
	 @param p The point
	 @brief Compute the squared distance from a point to the line
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <math/LineT.hpp>
#include <modeling/MakeEdge2d.hpp>
using AMCAX::Line2;
#define ONE_RADIAN (M_PI / 180.)
TEST_CASE("case1: Line basic interface test", "[math][Line2][p1]")
{
	SECTION("Distance and SquaredDistance test")
	{
		auto pointToLine = [](const Point2& point, const Line2& line) {
			double a, b, c;
			line.Coefficients(a, b, c);
			return std::fabs(a * point.X() + b * point.Y() + c);
		};
		auto lineToLine = [](const Line2& line1, const Line2& line2) {
			double a1, b1, c1, a2, b2, c2;
			line1.Coefficients(a1, b1, c1);
			line2.Coefficients(a2, b2, c2);
			if (a1 != a2 || b1 != b2) return 0.;
			return std::fabs(c1 - c2);
		};
		Line2 line(3., 4., -30.);
		Point2 point1(6., 3.);
		Point2 point2(6., 2.);
		Line2 line2(3., 4., -29.);
		Line2 line3(2., 1., -99.);
		CHECK(line.Distance(point1) == Approx(pointToLine(point1, line)).margin(0.01));
		CHECK(line.SquaredDistance(point1) == Approx(pointToLine(point1, line) * pointToLine(point1, line)).margin(0.01));
		CHECK(line.Distance(point2) == Approx(pointToLine(point2, line)));
		CHECK(line.SquaredDistance(point2) == Approx(pointToLine(point2, line) * pointToLine(point2, line)).margin(0.01));
		CHECK(line.Distance(line2) == Approx(lineToLine(line, line2)));
		CHECK(line.SquaredDistance(line2) == Approx(lineToLine(line2, line) * lineToLine(line2, line)).margin(0.01));
		CHECK(line.Distance(line3) == Approx(lineToLine(line, line3)));
		CHECK(line.SquaredDistance(line3) == Approx(lineToLine(line3, line) * lineToLine(line3, line)).margin(0.01));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] auto SquaredDistance(const LineS& l)	 @return The squared distance between two lines
	 @param l The other line
	 @brief Compute the squared distance between two lines
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <math/LineT.hpp>
#include <modeling/MakeEdge2d.hpp>
using AMCAX::Line2;
#define ONE_RADIAN (M_PI / 180.)
TEST_CASE("case1: Line basic interface test", "[math][Line2][p1]")
{
	SECTION("Distance and SquaredDistance test")
	{
		auto pointToLine = [](const Point2& point, const Line2& line) {
			double a, b, c;
			line.Coefficients(a, b, c);
			return std::fabs(a * point.X() + b * point.Y() + c);
		};
		auto lineToLine = [](const Line2& line1, const Line2& line2) {
			double a1, b1, c1, a2, b2, c2;
			line1.Coefficients(a1, b1, c1);
			line2.Coefficients(a2, b2, c2);
			if (a1 != a2 || b1 != b2) return 0.;
			return std::fabs(c1 - c2);
		};
		Line2 line(3., 4., -30.);
		Point2 point1(6., 3.);
		Point2 point2(6., 2.);
		Line2 line2(3., 4., -29.);
		Line2 line3(2., 1., -99.);
		CHECK(line.Distance(point1) == Approx(pointToLine(point1, line)).margin(0.01));
		CHECK(line.SquaredDistance(point1) == Approx(pointToLine(point1, line) * pointToLine(point1, line)).margin(0.01));
		CHECK(line.Distance(point2) == Approx(pointToLine(point2, line)));
		CHECK(line.SquaredDistance(point2) == Approx(pointToLine(point2, line) * pointToLine(point2, line)).margin(0.01));
		CHECK(line.Distance(line2) == Approx(lineToLine(line, line2)));
		CHECK(line.SquaredDistance(line2) == Approx(lineToLine(line2, line) * lineToLine(line2, line)).margin(0.01));
		CHECK(line.Distance(line3) == Approx(lineToLine(line, line3)));
		CHECK(line.SquaredDistance(line3) == Approx(lineToLine(line3, line) * lineToLine(line3, line)).margin(0.01));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] LineS Normal(const Point2& p)	 @return The line passing through a point and perpendicular to the line
	 @param p The point
	 @brief Get a line passing through a point and perpendicular to the line
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <math/LineT.hpp>
#include <modeling/MakeEdge2d.hpp>
using AMCAX::Line2;
#define ONE_RADIAN (M_PI / 180.)
TEST_CASE("case1: Line basic interface test", "[math][Line2][p1]")
{
	SECTION("Normal Test")
	{
		Line2 line(3., 4., 5.);  
		Line2 normalLine = line.Normal(Point2(1., 5.));
		double a, b, c;
		normalLine.Coefficients(a, b, c);
		CHECK((a * 3 + b * 4) == Approx(0.0).margin(0.1));
		CHECK((a * 1 + b * 5 + c) == Approx(0.0).margin(0.1));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":LineS& Rotate(const Point2& point, double angle)	 @return The reference to self
	 @param angle The rotation angle
	 @param point The rotation center point
	 @brief Rotate the line around a point with an angle in 2D
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <math/LineT.hpp>
#include <modeling/MakeEdge2d.hpp>
using AMCAX::Line2;
#define ONE_RADIAN (M_PI / 180.)
TEST_CASE("case1: Line basic interface test", "[math][Line2][p1]")
{
	SECTION("Rotate Test")
	{
		Line2 line(Point2(0., 1.), Direction2(1., 1.));  
		Line2 line2(Point2(0., 1.), Direction2(1., 1.));  
		line.Rotate(Point2(), (5. / 4) * M_PI);  
		CHECK(line.Direction().X() == Approx(0.).margin(1e-5));
		CHECK(line.Direction().Y() == Approx(-1.).margin(1e-5));
		double a, b, c;
		line.Coefficients(a, b, c);
		CHECK((a + c) == Approx(0.).margin(0.5));
		CHECK(line2.Distance(Point2()) == line.Distance(Point2()));  
		CHECK(line.Contains(Point2(std::sqrt(2.) / 2., 0.), 1e-6) == true);
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] LineS Rotated(const Point2& point, double angle)	 @return The rotated line
	 @param angle The rotation angle
	 @param point The rotation center point
	 @brief Get the line rotated around a point with an angle in 2D
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <math/LineT.hpp>
#include <modeling/MakeEdge2d.hpp>
using AMCAX::Line2;
#define ONE_RADIAN (M_PI / 180.)
TEST_CASE("case1: Line basic interface test", "[math][Line2][p1]")
{
	SECTION("Rotated Test")
	{
		Line2 line(Point2(0., 1.), Direction2(1., 1.));  
		Line2 rotateLine = line.Rotated(Point2(), (3. / 4) * M_PI);  
		CHECK(rotateLine.Direction().X() == Approx(-1.).margin(1e-5));
		CHECK(rotateLine.Direction().Y() == Approx(0.).margin(1e-5));
		double a, b, c;
		rotateLine.Coefficients(a, b, c);
		CHECK((c - b) == Approx(0.).margin(0.5));
		CHECK(line.Distance(Point2()) == rotateLine.Distance(Point2()));  
		TopoShape lineShape1 = MakeEdge2d(line);
		TopoShape lineShape2 = MakeEdge2d(rotateLine);
		REQUIRE(OCCTIO::OCCTTool::Write(lineShape1, OUTPUT_PATH_PREFIX"Line2_Rotated_before_p1.brep"));
		REQUIRE(OCCTIO::OCCTTool::Write(lineShape2, OUTPUT_PATH_PREFIX"Line2_Rotated_later_p1.brep"));
	}
}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] auto Distance(const Point3& p)	 @return The distance between the point and the line
	 @param p The point
	 @brief Compute the distance from a point to the line
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <math/LineT.hpp>
#include <modeling/MakeEdge2d.hpp>
using AMCAX::Line2;
#define ONE_RADIAN (M_PI / 180.)
TEST_CASE("case2: Line base method Test", "[math][Line2][p1]")
{
	SECTION("Scale")
	{
		Line2 line(Point2(0., -1.), Direction2());
		Point2 point;
		double distance = line.Distance(point);
		Line2 lineScale1 = line.Scaled(point, 1.1);
		CHECK(lineScale1.Distance(point) > distance);
		CHECK(lineScale1.Contains(Point2(0., -1.1), 1e-5));
		Line2 lineScale2 = line.Scaled(point, 1.);
		CHECK(lineScale2.Distance(point) == Approx(distance).margin(1e-5));
		CHECK(lineScale2.Contains(Point2(0., -1.), 1e-5));
		Line2 lineScale3 = line.Scaled(point, 0.8);
		CHECK(lineScale3.Distance(point) < distance);
		CHECK(lineScale3.Contains(Point2(0., -0.8), 1e-5));
		Line2 lineScale4 = line.Scaled(point, 0.);
		line.SetDirection(Direction2(-1.0, 4.0));
		Line2 lineScale5 = line.Scaled(Point2(-1., 2.), 0.);
		CHECK(lineScale4.Contains(Point2(0., 0.), 1e-5));
		CHECK(lineScale4.Direction().IsEqual(Direction2(), 1e-6 * ONE_RADIAN));
		CHECK(lineScale5.Contains(Point2(-1., 2.), 1e-5));
		CHECK(lineScale5.Direction().IsEqual(Direction2(-1., 4.), 1e-6 * ONE_RADIAN));
		Line2 lineScale6 = line.Scaled(point, -1.);
		CHECK(lineScale6.Direction().IsEqual(Direction2(1., -4.), 1e-5 * ONE_RADIAN));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] auto SquaredDistance(const Point3& p)	 @return The squared distance between the point and the line
	 @param p The point
	 @brief Compute the squared distance from a point to the line
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <math/LineT.hpp>
#include <modeling/MakeEdge2d.hpp>
using AMCAX::Line2;
#define ONE_RADIAN (M_PI / 180.)
TEST_CASE("case1: Line basic interface test", "[math][Line2][p1]")
{
	SECTION("Distance and SquaredDistance test")
	{
		auto pointToLine = [](const Point2& point, const Line2& line) {
			double a, b, c;
			line.Coefficients(a, b, c);
			return std::fabs(a * point.X() + b * point.Y() + c);
		};
		auto lineToLine = [](const Line2& line1, const Line2& line2) {
			double a1, b1, c1, a2, b2, c2;
			line1.Coefficients(a1, b1, c1);
			line2.Coefficients(a2, b2, c2);
			if (a1 != a2 || b1 != b2) return 0.;
			return std::fabs(c1 - c2);
		};
		Line2 line(3., 4., -30.);
		Point2 point1(6., 3.);
		Point2 point2(6., 2.);
		Line2 line2(3., 4., -29.);
		Line2 line3(2., 1., -99.);
		CHECK(line.Distance(point1) == Approx(pointToLine(point1, line)).margin(0.01));
		CHECK(line.SquaredDistance(point1) == Approx(pointToLine(point1, line) * pointToLine(point1, line)).margin(0.01));
		CHECK(line.Distance(point2) == Approx(pointToLine(point2, line)));
		CHECK(line.SquaredDistance(point2) == Approx(pointToLine(point2, line) * pointToLine(point2, line)).margin(0.01));
		CHECK(line.Distance(line2) == Approx(lineToLine(line, line2)));
		CHECK(line.SquaredDistance(line2) == Approx(lineToLine(line2, line) * lineToLine(line2, line)).margin(0.01));
		CHECK(line.Distance(line3) == Approx(lineToLine(line, line3)));
		CHECK(line.SquaredDistance(line3) == Approx(lineToLine(line3, line) * lineToLine(line3, line)).margin(0.01));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API ComputePointsAbscissa(double tol, const Adaptor3Curve& c, double abscissa, double u0)	 @param u0 The starting parameter
	 @param abscissa The arc length
	 @param c The curve
	 @param tol The tolerance
	 @brief Compute the parameter of a point on a 3D curve with given arc length and a tolerance
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <geometry/MakeGeom2Circle.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/ComputePointsAbscissa.hpp>
#include <geometry/MakeGeom2Hyperbola.hpp>
#include <modeling/MakeEdge.hpp>
#include <geometry/GeometryTool.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/MakeGeom2Ellipse.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/AdaptorGeom3Curve.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <geometry/MakeGeom3Hyperbola.hpp>
#include <geometry/MakeGeom3Ellipse.hpp>
TEST_CASE("bug2: ComputePointsAbscissa ", "[geometry][ComputePointsAbscissa][fixbug]")
{
	SECTION("arc length and tolerance-3D")
{
    Frame3 frame;
    double major = 5.0;
    double minor = 4.0;
    bool isRight = true;
    std::shared_ptr< Geom3Hyperbola >h1 = MakeGeom3Hyperbola(frame, major, minor);
    AdaptorGeom3Curve hyperbola(h1);
    ComputePointsAbscissa cpa3(Precision::Confusion(), hyperbola, 1.0, 0.0);
    double param3 = cpa3.Parameter();
    Point3 point1(hyperbola.Value(param3));
    CHECK(cpa3.Parameter());
    MakeEdge edge1(h1, 0.0, param3);
    CHECK(BRepClassificationTools::IsPointInOnEdge(edge1, point1, 0.001) == true);
}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] bool Contains(const PointT<double, DIM>& p, double tol)	 @return True if the point is on the line under the tolerance
	 @param tol The tolerance
	 @param p The point
	 @brief Does the line contain a point under a distance tolerance
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <math/LineT.hpp>
#include <math/Plane.hpp>
#include <modeling/MakeFace.hpp>
#include <modeling/MakeEdge.hpp>
using AMCAX::Line3;
using AMCAX::MakeEdge;
using AMCAX::MakeFace;
#define ONE_RADIAN (M_PI / 180.)
#define SQUARE(x) ((x) * (x))
TEST_CASE("case2: Line3 base method Test", "[math][Line3][p1]")
{
	SECTION("Contains")
	{
		Line3 line(Point3(), Direction3(1., 1., 1.));
		Point3 point1(2., 2., 2.);
		Point3 point2(2., 1., 2.);
		auto isContains = [](const Line3& line, const Point3& point) {
			Direction3 dir(line.Location().X() - point.X(), line.Location().Y() - point.Y(), line.Location().Z() - point.Z());
			return line.Direction().IsParallel(dir, 1e-5);
		};
		CHECK(line.Contains(point1, 1e-5) == isContains(line, point1));
		CHECK(line.Contains(point2, 1e-5) == isContains(line, point2));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] const PointT<double, DIM>& Location()	 @return The location of the line
	 @brief Get the location point of the line
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <math/LineT.hpp>
#include <math/Plane.hpp>
#include <modeling/MakeFace.hpp>
#include <modeling/MakeEdge.hpp>
using AMCAX::Line3;
using AMCAX::MakeEdge;
using AMCAX::MakeFace;
#define ONE_RADIAN (M_PI / 180.)
#define SQUARE(x) ((x) * (x))
TEST_CASE("case1: Derived class interface unit testing", "[math][Line3][p1]")
{
	SECTION("constructor")
	{
		Line3 line;  
		CHECK(line.Location().IsEqual(Point3(0., 0., 0.), 1e-5));
		CHECK(line.Direction().IsEqual(Direction3(0., 0., 1.), 1e-5 * ONE_RADIAN));
		Axis3 axis(Point3(1., 1., 1.), Direction3(3., 3., 4.));
		Line3 line2(axis);
		CHECK(line2.Position().IsCoaxial(axis, 1e-5 * ONE_RADIAN, 1e-5));  
		Line3 line3(Point3(1., 2., 3.), Direction3(3., 2., 1.));
		CHECK(line3.Location().IsEqual(Point3(1., 2., 3.), 1e-5));
		CHECK(line3.Direction().IsEqual(Direction3(3., 2., 1.), 1e-5 * ONE_RADIAN));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] Derived Scaled(const PointT<double, DIM>& point, double scale)	 @return The scaled line
	 @param scale The scale value
	 @param point The scaling center point
	 @brief Get the line scaled by a point
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <math/LineT.hpp>
#include <math/Plane.hpp>
#include <modeling/MakeFace.hpp>
#include <modeling/MakeEdge.hpp>
using AMCAX::Line3;
using AMCAX::MakeEdge;
using AMCAX::MakeFace;
#define ONE_RADIAN (M_PI / 180.)
#define SQUARE(x) ((x) * (x))
TEST_CASE("case2: Line3 base method Test", "[math][Line3][p1]")
{
	SECTION("Scale")
	{
		Line3 line(Point3(), Direction3(0., 1., 0.));
		Point3 point(1., 1., 0.);
		double originalDistance = line.Distance(point);
		Line3 line1 = line.Scaled(point, 1.1);
		CHECK(line1.Distance(point) > originalDistance);
		Line3 line2 = line.Scaled(point, 1.);
		CHECK(line2.Distance(point) == originalDistance);
		Line3 line3 = line.Scaled(point, 0.8);
		CHECK(line3.Distance(point) < originalDistance);
		Line3 line4 = line.Scaled(point, 0.);
		CHECK(line4.Contains(point, 1e-6));
		Line3 line5 = line.Scaled(point, -1.);
		CHECK(line5.Direction().IsEqual(Direction3(0., -1., 0.), 1e-6 * ONE_RADIAN));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] Derived Transformed(const TransformationT<double, DIM>& tr)	 @return The transformed line
	 @param tr The transformation
	 @brief Get the transformed line
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <math/LineT.hpp>
#include <math/Plane.hpp>
#include <modeling/MakeFace.hpp>
#include <modeling/MakeEdge.hpp>
using AMCAX::Line3;
using AMCAX::MakeEdge;
using AMCAX::MakeFace;
#define ONE_RADIAN (M_PI / 180.)
#define SQUARE(x) ((x) * (x))
TEST_CASE("case2: Line3 base method Test", "[math][Line3][p1]")
{
	SECTION("Transform")
	{
		Line3 line(Point3(), Direction3(0., 1., 0.));
		Transformation3 translationTransform;
		translationTransform.SetTranslation(Point3(0., 0., 0.), Point3(1., 1., 1.));  
		Line3 translationLine = line.Transformed(translationTransform);
		CHECK(translationLine.Direction().IsEqual(line.Direction(), 1e-6 * ONE_RADIAN));
		CHECK(translationLine.Contains(Point3(1., 1., 1.), 1e-6));
		Transformation3 rotationTransfrom;
		rotationTransfrom.SetRotation(Axis3(Point3(), Direction3(1., 0., 0.)), 90. * ONE_RADIAN);  
		Line3 rotationLine = line.Transformed(rotationTransfrom);
		CHECK(rotationLine.Direction().IsEqual(Direction3(0., 0., 1.), 1e-6 * ONE_RADIAN));
		CHECK(rotationLine.Contains(Point3(0., 0., 3.), 1e-6) == true);
		Transformation3 scaleTransfrom;
		scaleTransfrom.SetScale(Point3(1., 0., 1.), -1.); 
		Line3 scaleLine = line.Transformed(scaleTransfrom);
		CHECK(line.Distance(Point3(1., 0., 1.)) == scaleLine.Distance(Point3(1., 0., 1.)));
		CHECK(scaleLine.Direction().IsEqual(Direction3(0., -1., 0.), 1e-6*ONE_RADIAN));
		Transformation3 mirrorTransfrom;
		mirrorTransfrom.SetMirror(Frame3(Point3(0., 0., 0.), Direction3(1., 0., 0.)));
		Line3 mirrorLine = line.Transformed(mirrorTransfrom);
		CHECK(line.Distance(Point3(0., 0., 0.)) == mirrorLine.Distance(Point3(0., 0., 0.)));
		AMCAX::OCCTIO::OCCTTool::Write(MakeEdge(line), OUTPUT_PATH_PREFIX"Line3_Transform_InitialLine.brep");
		Transformation3 CombinedTransfrom = scaleTransfrom * mirrorTransfrom* translationTransform * rotationTransfrom;  
		line.Transform(CombinedTransfrom);
		AMCAX::OCCTIO::OCCTTool::Write(MakeEdge(line), OUTPUT_PATH_PREFIX"Line3_Transform_transformLine.brep");
		CHECK(line.Contains(Point3(3., -1., 1.), 1e-6) == true);
		CHECK(line.Direction().IsEqual(Direction3(0., 0., -1.), 1e-6 * ONE_RADIAN));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":Derived& Translate(const PointT<double, DIM>& p1, const PointT<double, DIM>& p2)	 @return The reference to self
	 @param p2 The target point
	 @param p1 The source point
	 @brief Translate the line by a vector from a point to another point
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <math/LineT.hpp>
#include <math/Plane.hpp>
#include <modeling/MakeFace.hpp>
#include <modeling/MakeEdge.hpp>
using AMCAX::Line3;
using AMCAX::MakeEdge;
using AMCAX::MakeFace;
#define ONE_RADIAN (M_PI / 180.)
#define SQUARE(x) ((x) * (x))
TEST_CASE("case2: Line3 base method Test", "[math][Line3][p1]")
{
	SECTION("Translate")
	{
		Line3 line(Point3(), Direction3(1., 1., 1.));
		Line3 originalLine(Point3(), Direction3(1., 1., 1.));
		line.Translate(Point3(), Point3(0., 1., 0.));
		CHECK(originalLine.Direction().IsEqual(line.Direction(), 1e-6 * ONE_RADIAN));
		CHECK(line.Contains(Point3(0., 1., 0.), 1e-6));
		Line3 line2 = line.Translated(Vector3(Direction3(1., -1., 1.)));
		CHECK(line.Direction().IsEqual(line2.Direction(), 1e-6 * ONE_RADIAN));
		CHECK(line2.Contains(Point3(0. + 1. / std::sqrt(3.), 1 - 1. / std::sqrt(3.), 0. + 1. / std::sqrt(3.)), 1e-6));
	}
}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] Derived Translated(const VectorT<double, DIM>& vec)	 @return The translated line
	 @param vec The translation vector
	 @brief Get the line translated by a vector
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <math/LineT.hpp>
#include <math/Plane.hpp>
#include <modeling/MakeFace.hpp>
#include <modeling/MakeEdge.hpp>
using AMCAX::Line3;
using AMCAX::MakeEdge;
using AMCAX::MakeFace;
#define ONE_RADIAN (M_PI / 180.)
#define SQUARE(x) ((x) * (x))
TEST_CASE("case2: Line3 base method Test", "[math][Line3][p1]")
{
	SECTION("Translate")
	{
		Line3 line(Point3(), Direction3(1., 1., 1.));
		Line3 originalLine(Point3(), Direction3(1., 1., 1.));
		line.Translate(Point3(), Point3(0., 1., 0.));
		CHECK(originalLine.Direction().IsEqual(line.Direction(), 1e-6 * ONE_RADIAN));
		CHECK(line.Contains(Point3(0., 1., 0.), 1e-6));
		Line3 line2 = line.Translated(Vector3(Direction3(1., -1., 1.)));
		CHECK(line.Direction().IsEqual(line2.Direction(), 1e-6 * ONE_RADIAN));
		CHECK(line2.Contains(Point3(0. + 1. / std::sqrt(3.), 1 - 1. / std::sqrt(3.), 0. + 1. / std::sqrt(3.)), 1e-6));
	}
}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":void SetLocation(const PointT<double, DIM>& point)	 @param point The location point
	 @brief Set the location of the line
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <math/LineT.hpp>
#include <math/Plane.hpp>
#include <modeling/MakeFace.hpp>
#include <modeling/MakeEdge.hpp>
using AMCAX::Line3;
using AMCAX::MakeEdge;
using AMCAX::MakeFace;
#define ONE_RADIAN (M_PI / 180.)
#define SQUARE(x) ((x) * (x))
TEST_CASE("case2: Line3 base method Test", "[math][Line3][p1]")
{
	SECTION("SetLocation")
	{
		Line3 line(Point3(2., 3., 2.), Direction3(2., 3.4, -2.));
		line.SetLocation(Point3(1., -2., 8.));
		CHECK(line.Location().IsEqual(Point3(1., -2., 8.), std::numeric_limits<double>::min()));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":void SetDirection(const DirectionT<double, DIM>& dir)	 @param dir The line direction
	 @brief Set the line direction
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <math/LineT.hpp>
#include <math/Plane.hpp>
#include <modeling/MakeFace.hpp>
#include <modeling/MakeEdge.hpp>
using AMCAX::Line3;
using AMCAX::MakeEdge;
using AMCAX::MakeFace;
#define ONE_RADIAN (M_PI / 180.)
#define SQUARE(x) ((x) * (x))
TEST_CASE("case2: Line3 base method Test", "[math][Line3][p1]")
{
	SECTION("SetDirection")
	{
		Direction3 dir(1., 1., 1.);
		Line3 line;
		line.SetDirection(dir);
		CHECK(line.Direction().IsEqual(dir, std::numeric_limits<double>::min()));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":void SetPosition(const AxisT<double, DIM>& axis)	 @param axis The axis
	 @brief Set the axis of the line
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <math/LineT.hpp>
#include <math/Plane.hpp>
#include <modeling/MakeFace.hpp>
#include <modeling/MakeEdge.hpp>
using AMCAX::Line3;
using AMCAX::MakeEdge;
using AMCAX::MakeFace;
#define ONE_RADIAN (M_PI / 180.)
#define SQUARE(x) ((x) * (x))
TEST_CASE("case2: Line3 base method Test", "[math][Line3][p1]")
{
	SECTION("SetPosition")
	{
		Axis3 axis(Point3(0.1, -2.3, 0.3), Direction3(1.2, -8.9, 3.));
		Line3 line;
		line.SetPosition(axis);
		CHECK(line.Location().IsEqual(axis.Location(), std::numeric_limits<double>::min()));
		CHECK(line.Direction().IsEqual(axis.Direction(), std::numeric_limits<double>::min()));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] const DirectionT<double, DIM>& Direction()	 @return The direction of the line
	 @brief Get the direction of the line
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <math/LineT.hpp>
#include <math/Plane.hpp>
#include <modeling/MakeFace.hpp>
#include <modeling/MakeEdge.hpp>
using AMCAX::Line3;
using AMCAX::MakeEdge;
using AMCAX::MakeFace;
#define ONE_RADIAN (M_PI / 180.)
#define SQUARE(x) ((x) * (x))
TEST_CASE("case1: Derived class interface unit testing", "[math][Line3][p1]")
{
	SECTION("constructor")
	{
		Line3 line;  
		CHECK(line.Location().IsEqual(Point3(0., 0., 0.), 1e-5));
		CHECK(line.Direction().IsEqual(Direction3(0., 0., 1.), 1e-5 * ONE_RADIAN));
		Axis3 axis(Point3(1., 1., 1.), Direction3(3., 3., 4.));
		Line3 line2(axis);
		CHECK(line2.Position().IsCoaxial(axis, 1e-5 * ONE_RADIAN, 1e-5));  
		Line3 line3(Point3(1., 2., 3.), Direction3(3., 2., 1.));
		CHECK(line3.Location().IsEqual(Point3(1., 2., 3.), 1e-5));
		CHECK(line3.Direction().IsEqual(Direction3(3., 2., 1.), 1e-5 * ONE_RADIAN));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] const AxisT<double, DIM>& Position()	 @return The axis of the line
	 @brief Get the axis of the line
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <math/LineT.hpp>
#include <math/Plane.hpp>
#include <modeling/MakeFace.hpp>
#include <modeling/MakeEdge.hpp>
using AMCAX::Line3;
using AMCAX::MakeEdge;
using AMCAX::MakeFace;
#define ONE_RADIAN (M_PI / 180.)
#define SQUARE(x) ((x) * (x))
TEST_CASE("case1: Derived class interface unit testing", "[math][Line3][p1]")
{
	SECTION("constructor")
	{
		Line3 line;  
		CHECK(line.Location().IsEqual(Point3(0., 0., 0.), 1e-5));
		CHECK(line.Direction().IsEqual(Direction3(0., 0., 1.), 1e-5 * ONE_RADIAN));
		Axis3 axis(Point3(1., 1., 1.), Direction3(3., 3., 4.));
		Line3 line2(axis);
		CHECK(line2.Position().IsCoaxial(axis, 1e-5 * ONE_RADIAN, 1e-5));  
		Line3 line3(Point3(1., 2., 3.), Direction3(3., 2., 1.));
		CHECK(line3.Location().IsEqual(Point3(1., 2., 3.), 1e-5));
		CHECK(line3.Direction().IsEqual(Direction3(3., 2., 1.), 1e-5 * ONE_RADIAN));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] auto Angle(const LineBase& other)	 @return The angle between the line and the other line
	 @param other The other line
	 @brief Compute the angle between the line and the other line
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <math/LineT.hpp>
#include <math/Plane.hpp>
#include <modeling/MakeFace.hpp>
#include <modeling/MakeEdge.hpp>
using AMCAX::Line3;
using AMCAX::MakeEdge;
using AMCAX::MakeFace;
#define ONE_RADIAN (M_PI / 180.)
#define SQUARE(x) ((x) * (x))
TEST_CASE("case2: Line3 base method Test", "[math][Line3][p1]")
{
	SECTION("Angle")
	{
		Line3 line(Point3(0., 1., 0.), Direction3(1., 1., 1.));
		Line3 line2(Point3(0., 3.4, 0.), Direction3(2., -1., -1.5));
		CHECK(line.Angle(line2) == Approx(std::acos(line.Direction().Dot(line2.Direction()))).margin(1e-6 * ONE_RADIAN));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] Derived Reversed()	 @return The line with reversed direction
	 @brief Get the line with reversed direction
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <math/LineT.hpp>
#include <math/Plane.hpp>
#include <modeling/MakeFace.hpp>
#include <modeling/MakeEdge.hpp>
using AMCAX::Line3;
using AMCAX::MakeEdge;
using AMCAX::MakeFace;
#define ONE_RADIAN (M_PI / 180.)
#define SQUARE(x) ((x) * (x))
TEST_CASE("case2: Line3 base method Test", "[math][Line3][p1]")
{
	SECTION("Reverse")
	{
		Line3 line(Point3(), Direction3(1., 1., 1.));
		Line3 reverseLine = line.Reversed();
		CHECK(reverseLine.Direction().IsEqual(Direction3(-1., -1., -1.), 1e-6 * ONE_RADIAN));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] auto SquaredDistance(const LineS& l)	 @return The squared distance between two lines
	 @param l The other line
	 @brief Compute the squared distance between two lines
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <math/LineT.hpp>
#include <math/Plane.hpp>
#include <modeling/MakeFace.hpp>
#include <modeling/MakeEdge.hpp>
using AMCAX::Line3;
using AMCAX::MakeEdge;
using AMCAX::MakeFace;
#define ONE_RADIAN (M_PI / 180.)
#define SQUARE(x) ((x) * (x))
TEST_CASE("case1: Derived class interface unit testing", "[math][Line3][p1]")
{
	SECTION("Distance and SquaredDistance")
	{
		auto pointToLine = [](const Point3& p, const Line3& line) {
			const Point3& p1 = line.Location();
			double dX = p1.X() - p.X();
			double dY = p1.Y() - p.Y();
			double dZ = p1.Z() - p.Z();
			double pp1Square = SQUARE(dX) + SQUARE(dY) + SQUARE(dZ);
			Direction3 dir(dX, dY, dZ);
			double cos = std::fabs(dir.Dot(line.Direction()));
			return std::sqrt(pp1Square - SQUARE(cos*std::sqrt(pp1Square)));
		};
		auto lineToLine = [&pointToLine](const Line3& line1, const Line3& line2) {
			if (line1.Direction().IsParallel(line2.Direction(), std::numeric_limits<double>::min()))
				return pointToLine(line1.Location(), line2);
			Direction3 line1Dir = line1.Direction();
			Direction3 line2Dir = line2.Direction();
			double x3 = line1Dir.Y() * line2Dir.Z() - line2Dir.Y() * line1Dir.Z();
			double y3 = -(line1Dir.X() * line2Dir.Z() - line2Dir.X() * line1Dir.Z());
			double z3 = line1Dir.X() * line2Dir.Y() - line2Dir.X() * line1Dir.Y();
			Direction3 line3Dir(x3, y3, z3);
			Direction3 line12Dir(line1.Location().X() - line2.Location().X(), 
								 line1.Location().Y() - line2.Location().Y(), line1.Location().Z() - line2.Location().Z());
			return std::fabs(line3Dir.Dot(line12Dir));
		};
		Line3 line(Point3(99., 2., 33.), Direction3(2.3, 4.6, 9.8));
		CHECK(line.Distance(Point3(0., 1., 0.)) == Approx(pointToLine(Point3(0., 1., 0.), line)).margin(1e-5));
		Line3 line2(Point3(0., 0., 0.), Direction3(1., 0., 0.));
		Line3 line3(Point3(0., 1., 0.), Direction3(1., 0., 0.));
		CHECK(line2.Distance(line3) == Approx(lineToLine(line2, line3)).margin(std::numeric_limits<double>::min()));
		CHECK(line2.SquaredDistance(line3) == Approx(SQUARE(lineToLine(line2, line3))).margin(std::numeric_limits<double>::min()));
		Line3 line4(Point3(0., 0., 0.), Direction3(1., 0., 0.));
		Line3 line5(Point3(0., 1., 0.), Direction3(1., 1., 0.));
		CHECK(line4.Distance(line5) == Approx(lineToLine(line4, line5)).margin(std::numeric_limits<double>::min()));
		Line3 line6(Point3(0., 0., 0.), Direction3(0., 0., 1.));
		Line3 line7(Point3(0., 1., 0.), Direction3(1., 1., 0.));
		CHECK(line6.Distance(line7) == Approx(lineToLine(line6, line7)).margin(std::numeric_limits<double>::min()));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] auto Distance(const Point3& p)	 @return The distance between the point and the line
	 @param p The point
	 @brief Compute the distance from a point to the line
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <math/LineT.hpp>
#include <math/Plane.hpp>
#include <modeling/MakeFace.hpp>
#include <modeling/MakeEdge.hpp>
using AMCAX::Line3;
using AMCAX::MakeEdge;
using AMCAX::MakeFace;
#define ONE_RADIAN (M_PI / 180.)
#define SQUARE(x) ((x) * (x))
TEST_CASE("case2: Line3 base method Test", "[math][Line3][p1]")
{
	SECTION("Scale")
	{
		Line3 line(Point3(), Direction3(0., 1., 0.));
		Point3 point(1., 1., 0.);
		double originalDistance = line.Distance(point);
		Line3 line1 = line.Scaled(point, 1.1);
		CHECK(line1.Distance(point) > originalDistance);
		Line3 line2 = line.Scaled(point, 1.);
		CHECK(line2.Distance(point) == originalDistance);
		Line3 line3 = line.Scaled(point, 0.8);
		CHECK(line3.Distance(point) < originalDistance);
		Line3 line4 = line.Scaled(point, 0.);
		CHECK(line4.Contains(point, 1e-6));
		Line3 line5 = line.Scaled(point, -1.);
		CHECK(line5.Direction().IsEqual(Direction3(0., -1., 0.), 1e-6 * ONE_RADIAN));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] LineS Normal(const Point3& p)	 @return The line passing through a point and perpendicular to the line
	 @param p The point
	 @brief Get a line passing through a point and perpendicular to the line
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <math/LineT.hpp>
#include <math/Plane.hpp>
#include <modeling/MakeFace.hpp>
#include <modeling/MakeEdge.hpp>
using AMCAX::Line3;
using AMCAX::MakeEdge;
using AMCAX::MakeFace;
#define ONE_RADIAN (M_PI / 180.)
#define SQUARE(x) ((x) * (x))
TEST_CASE("case1: Derived class interface unit testing", "[math][Line3][p1]")
{
	SECTION("Normal")
	{
		Line3 line(Point3(94., 32., 4.8), Direction3(2.65, 3.28, 5.14));
		Line3 line2 = line.Normal(Point3(2.1, 3.4, 11.2));
		CHECK(line.Direction().Dot(line2.Direction()) == Approx(0.).margin(1e-6));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":LineS& Mirror(const Frame3& frame)	 @return The reference to self
	 @param frame The mirror frame
	 @brief Mirror the line by a frame
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <math/LineT.hpp>
#include <math/Plane.hpp>
#include <modeling/MakeFace.hpp>
#include <modeling/MakeEdge.hpp>
using AMCAX::Line3;
using AMCAX::MakeEdge;
using AMCAX::MakeFace;
#define ONE_RADIAN (M_PI / 180.)
#define SQUARE(x) ((x) * (x))
TEST_CASE("case1: Derived class interface unit testing", "[math][Line3][p1]")
{
	SECTION("Mirror")
	{
		Line3 line(Point3(1.0, 2.0, 3.0), Direction3(1.0, 0.0, 0.0));
		Line3 originalLine(Point3(1.0, 2.0, 3.0), Direction3(1.0, 0.0, 0.0));
		Frame3 frame(Point3(0.0, 0.0, 0.0), Direction3(0.0, 1.0, 0.0));
		line.Mirror(frame);
		CHECK(line.Distance(Point3(0.0, 0.0, 0.0)) == Approx(originalLine.Distance(Point3(0., 0., 0.))).margin(std::numeric_limits<double>::min()));
		Direction3 dir(originalLine.Location().X() - line.Location().X(),
					   originalLine.Location().Y() - line.Location().Y(),
					   originalLine.Location().Z() - line.Location().Z());
		CHECK(dir.IsParallel(Direction3(0.0, 1.0, 0.0), 1e-5 * ONE_RADIAN));
		Line3 line2(Point3(1.2, -4.6, 2.3), Direction3(1.8, 97.4, -12.8));
		Frame3 frame2(Point3(87.0, 2.3, 10.14), Direction3(-92.3, 2.6, 1.0));
		Line3 mirrorLine2 = line2.Mirrored(frame2);
		CHECK(line2.Distance(Point3(87.0, 2.3, 10.14)) == Approx(mirrorLine2.Distance(Point3(87.0, 2.3, 10.14))).margin(std::numeric_limits<double>::min()));
		Direction3 dir2(line2.Location().X() - mirrorLine2.Location().X(),
					    line2.Location().Y() - mirrorLine2.Location().Y(),
					    line2.Location().Z() - mirrorLine2.Location().Z());
		CHECK(dir2.IsParallel(Direction3(-92.3, 2.6, 1.0), 1e-5 * ONE_RADIAN));
		TopoFace face = MakeFace(Plane(frame2), 0., 4., 0., 4.);
		TopoEdge edgeLine2 = MakeEdge(line2, 0., 1.);
		TopoEdge edgeMirrorLine2 = MakeEdge(mirrorLine2, 0., 1.);
		AMCAX::OCCTIO::OCCTTool::Write(face, OUTPUT_PATH_PREFIX"Line3_Mirror_face2.brep");
		AMCAX::OCCTIO::OCCTTool::Write(edgeLine2, OUTPUT_PATH_PREFIX"Line3_Mirror_edge.brep");
		AMCAX::OCCTIO::OCCTTool::Write(edgeMirrorLine2, OUTPUT_PATH_PREFIX"Line3_Mirror_Mirroredge.brep");
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] LineS Rotated(const Axis3& axis, double angle)	 @return The rotated line
	 @param angle The rotation angle
	 @param axis The rotation axis
	 @brief Get the line rotated around an axis with an angle in 3D
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <math/LineT.hpp>
#include <math/Plane.hpp>
#include <modeling/MakeFace.hpp>
#include <modeling/MakeEdge.hpp>
using AMCAX::Line3;
using AMCAX::MakeEdge;
using AMCAX::MakeFace;
#define ONE_RADIAN (M_PI / 180.)
#define SQUARE(x) ((x) * (x))
TEST_CASE("case1: Derived class interface unit testing", "[math][Line3][p1]")
{
	SECTION("Rotate")
	{
		Axis3 axis(Point3(0., 0., 0.), Direction3(0., 1., 0.));
		Line3 line(Point3(0., 0., 0.), Direction3(1., 1., -1.));
		Line3 rotateLine = line.Rotated(axis, 90. * ONE_RADIAN);  
		TopoEdge edge1 = MakeEdge(line);
		TopoEdge edge2 = MakeEdge(rotateLine);
		TopoEdge edge3 = MakeEdge(Line3(axis));
		bool isWriteSuccess1 = AMCAX::OCCTIO::OCCTTool::Write(edge1, OUTPUT_PATH_PREFIX"Line3_Rotate_line.brep");
		bool isWriteSuccess2 = AMCAX::OCCTIO::OCCTTool::Write(edge2, OUTPUT_PATH_PREFIX"Line3_Rotate_lineRotate.brep");
		bool isWriteSuccess3 = AMCAX::OCCTIO::OCCTTool::Write(edge3, OUTPUT_PATH_PREFIX"Line3_Rotate_axis.brep");
		REQUIRE(isWriteSuccess1);
		REQUIRE(isWriteSuccess2);
		REQUIRE(isWriteSuccess3);
		auto pointToPoint = [](const Point3& p1, const Point3& p2) {
			return std::sqrt(
				SQUARE(p1.X() - p2.X()) +
				SQUARE(p1.Y() - p2.Y()) +
				SQUARE(p1.Z() - p2.Z())
			);
		};
		CHECK(line.Distance(Line3(axis)) == Approx(rotateLine.Distance(Line3(axis))).margin(std::numeric_limits<double>::min()));
		CHECK(pointToPoint(line.Location(), Point3()) == Approx(pointToPoint(rotateLine.Location(), Point3())).margin(std::numeric_limits<double>::min()));
		Point3 p(-1., 1., -1.);
		CHECK(rotateLine.Contains(p, 1e-6) == true);
	}
}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API Classifier2d(const std::vector<Point2>& pts, double tolU, double tolV, double uMin, double vMin, double uMax, double vMax)	 @param vMax The upper bound of v
	 @param uMax The upper bound of u
	 @param vMin The lower bound of v
	 @param uMin The lower bound of u
	 @param tolV The tolerance of v bound
	 @param tolU The tolerance of u bound
	 @param pts The points of a 2D closed polygon, the last point does not required to repeat the first point
	 @details Require uMax > uMin, vMax > vMin, and at least 3 points
	 @brief Construct from a 2D polygon and uv-bounds
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/Classifier2d.hpp>
using namespace AMCAX;
TEST_CASE("case1: Classifier2d ", "[math][Classifier2d][P1]") {
    std::vector<Point2> pts = {
        Point2(2.0, 0.0),
        Point2(1.0, 1.0),
        Point2(2.0, 2.0),
        Point2(3.0, 2.0)
    }; 
    double tolU = 0.1;
    double tolV = 0.1;
    double uMin = 0.0;
    double vMin = 0.0;
    double uMax = 2.5;
    double vMax = 1.5;
    Classifier2d classifier(pts, tolU, tolV, uMin, vMin, uMax, vMax);
	SECTION("IsInOut Point normal set") {
        Point2 OutPoint(0.0, 0.0);
        Point2 OnPoint(1.0, 1.0);
        Point2 InPoint(2.0, 1.0);
        CHECK(classifier.IsInOut(OutPoint) == -1);
        CHECK(classifier.IsInOut(OnPoint) == 0);
        CHECK(classifier.IsInOut(InPoint) == 1);
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API int IsInOut(const Point2& p)	 @return 1: in; 0: on; -1: out
	 @param p The test point
	 @brief Check a point is in or out of the polygon
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/Classifier2d.hpp>
using namespace AMCAX;
TEST_CASE("case1: Classifier2d ", "[math][Classifier2d][P1]") {
    std::vector<Point2> pts = {
        Point2(2.0, 0.0),
        Point2(1.0, 1.0),
        Point2(2.0, 2.0),
        Point2(3.0, 2.0)
    }; 
    double tolU = 0.1;
    double tolV = 0.1;
    double uMin = 0.0;
    double vMin = 0.0;
    double uMax = 2.5;
    double vMax = 1.5;
    Classifier2d classifier(pts, tolU, tolV, uMin, vMin, uMax, vMax);
	SECTION("IsInOut Point normal set") {
        Point2 OutPoint(0.0, 0.0);
        Point2 OnPoint(1.0, 1.0);
        Point2 InPoint(2.0, 1.0);
        CHECK(classifier.IsInOut(OutPoint) == -1);
        CHECK(classifier.IsInOut(OnPoint) == 0);
        CHECK(classifier.IsInOut(InPoint) == 1);
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API int IsInOutOn(const Point2& p, double tol)	 @return 1: in; 0: on; -1: out
	 @param tol The tolerance of the point
	 @param p The test point
	 @brief Check a point is in or out of the polygon
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/Classifier2d.hpp>
using namespace AMCAX;
TEST_CASE("case3: Classifier2d ", "[math][Classifier2d][P1]") {
    std::vector<Point2> pts = {
        Point2(2.0, 0.0),
        Point2(1.0, 1.0),
        Point2(2.0, 2.0),
        Point2(3.0, 2.0)
    }; 
    double tolU = 0.1;
    double tolV = 0.1;
    double uMin = 0.0;
    double vMin = 0.0;
    double uMax = 2.5;
    double vMax = 1.5;
    Classifier2d classifier(pts, tolU, tolV, uMin, vMin, uMax, vMax);
	SECTION("IsInOutOn Point normal set") {
        Point2 OutPoint(0.0, 0.0);
        Point2 OnPoint(1.0, 1.0);
        Point2 AnothOnPoint(2.0, 2.0);
        Point2 InPoint(2.0, 1.0);
        CHECK(classifier.IsInOutOn(OutPoint,0.0) == -1);
        CHECK(classifier.IsInOutOn(OnPoint,0.0) != 0);
        CHECK(classifier.IsInOutOn(OnPoint, 1.0) == 0);
        CHECK(classifier.IsInOutOn(AnothOnPoint, 1.0) == 0); 
        CHECK(classifier.IsInOutOn(InPoint,0.0) == 1);
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static void AdjustPeriodic(double ufirst, double ulast, double precision, double& u1, double& u2)	 @param[in,out] u2 The second parameter to be adjust
	 @param[in,out] u1 The first parameter to be adjust
	 @param[in] precision The precision to check equality
	 @param[in] ulast The upper bound of the period
	 @param[in] ufirst The lower bound of the period
	          The parameter u2 is set in the range [u1, u1 + ulast - ufirst]
	 @details The parameter u1 is set in the range [ufirst, ulast]
	 @brief Adjust u1 and u2 to be in the period range.
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
using namespace AMCAX;
TEST_CASE("case1: CurveCalculation::AdjustPeriodic ", "[math][CurveCalculation][P1]") {
	double u1 = 0.0;
	double u2 = 2 * M_PI;
	double ufirst = 0.0;
	double ulast = 2 * M_PI; 
	double precision = 0.001; 
	AMCAX::CurveCalculation::AdjustPeriodic(ufirst, ulast, precision, u1, u2);
	CHECK(u1 == 0);
	CHECK(u2 == 2 * M_PI);
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] AMCAX_API static Vector2 D1(double u, const Circle2& circle)	 @return The first derivative vector
	 @param circle The circle
	 @param u The parameter
	 @brief Compute the first derivative on a 2D circle at a parameter
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
using namespace AMCAX;
TEST_CASE("case1: CurveCalculation::CircleD1 1/4 ", "[math][CurveCalculation][P1][CircleD1]") {
	Direction2 initialDir(1.0, 0.0); 
	Frame2 defaultFrame2(Point2(1.0, 1.0), initialDir); 
	double radius = 2.0; 
	Vector2 tangentAt0 = AMCAX::CurveCalculation::CircleD1(0.0, defaultFrame2, radius);
	Vector2 tangentAt90Deg = AMCAX::CurveCalculation::CircleD1(M_PI_2, defaultFrame2, radius);
	Vector2 tangentAt180Deg = AMCAX::CurveCalculation::CircleD1(M_PI, defaultFrame2, radius);
	Vector2 tangentAt270Deg = AMCAX::CurveCalculation::CircleD1(3 * M_PI_2, defaultFrame2, radius);
	Vector2 tangentAt360Deg = AMCAX::CurveCalculation::CircleD1(2 * M_PI, defaultFrame2, radius);
	CHECK(tangentAt0.X() == Approx(-0.0));
	CHECK(tangentAt0.Y() == Approx(2.0));
	CHECK(tangentAt90Deg.X() == Approx(-2.0));
	CHECK(tangentAt90Deg.Y() == Approx(0.0).margin(1e-14));
	CHECK(tangentAt180Deg.X() == Approx(-0.0).margin(1e-14));
	CHECK(tangentAt180Deg.Y() == Approx(-2.0));
	CHECK(tangentAt270Deg.X() == Approx(2.0));
	CHECK(tangentAt270Deg.Y() == Approx(-0.0).margin(1e-14));
	CHECK(tangentAt360Deg.X() == Approx(0.0).margin(1e-14));
	CHECK(tangentAt360Deg.Y() == Approx(2.0));
	std::cout << "Tangent at 0 deg: " << tangentAt0 << std::endl;
	std::cout << "Tangent at 90 deg: " << tangentAt90Deg << std::endl;
	std::cout << "Tangent at 180 deg: " << tangentAt180Deg << std::endl;
	std::cout << "Tangent at 270 deg: " << tangentAt270Deg << std::endl;
	std::cout << "Tangent at 360 deg: " << tangentAt360Deg << std::endl;
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static void AdjustPeriodic(double ufirst, double ulast, double precision, double& u1, double& u2)	 @param[in,out] u2 The second parameter to be adjust
	 @param[in,out] u1 The first parameter to be adjust
	 @param[in] precision The precision to check equality
	 @param[in] ulast The upper bound of the period
	 @param[in] ufirst The lower bound of the period
	          The parameter u2 is set in the range [u1, u1 + ulast - ufirst]
	 @details The parameter u1 is set in the range [ufirst, ulast]
	 @brief Adjust u1 and u2 to be in the period range.
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
using namespace AMCAX;
TEST_CASE("case1: CurveCalculation::AdjustPeriodic ", "[math][CurveCalculation][P1]") {
	double u1 = 0.0;
	double u2 = 2 * M_PI;
	double ufirst = 0.0;
	double ulast = 2 * M_PI; 
	double precision = 0.001; 
	AMCAX::CurveCalculation::AdjustPeriodic(ufirst, ulast, precision, u1, u2);
	CHECK(u1 == 0);
	CHECK(u2 == 2 * M_PI);
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] AMCAX_API static Point3 CircleValue(double u, const Frame3& pos, double radius)	 @return The point
	 @param radius The radius
	 @param pos The local frame where the circle lies
	 @param u The parameter
	 @brief Compute the point on a 3D circle represented by a local frame and a radius at a parameter
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
using namespace AMCAX;
TEST_CASE("case1: CurveCalculation::CircleD3 3/4 ", "[math][CurveCalculation][P1][CircleD3]") {
	Direction3 initialDir(0.0, 0.0, 1.0); 
	Frame3 defaultFrame3(Point3(1.0, 1.0, 0.0), initialDir); 
	double radius = 2.0; 
	Vector3 tangentAt0 = AMCAX::CurveCalculation::CircleD3(0.0, defaultFrame3, radius);
	Vector3 tangentAt90Deg = AMCAX::CurveCalculation::CircleD3(M_PI_2, defaultFrame3, radius);
	Vector3 tangentAt180Deg = AMCAX::CurveCalculation::CircleD3(M_PI, defaultFrame3, radius);
	Vector3 tangentAt270Deg = AMCAX::CurveCalculation::CircleD3(3 * M_PI_2, defaultFrame3, radius);
	Vector3 tangentAt360Deg = AMCAX::CurveCalculation::CircleD3(2 * M_PI, defaultFrame3, radius);
	CHECK(tangentAt0.X() == Approx(0.0));
	CHECK(tangentAt0.Y() == Approx(-2.0));
	CHECK(tangentAt0.Z() == Approx(-0.0));
	CHECK(tangentAt90Deg.X() == Approx(2.0).margin(1e-14));
	CHECK(tangentAt90Deg.Y() == Approx(-0.0).margin(1e-14));
	CHECK(tangentAt90Deg.Z() == Approx(0.0).margin(1e-14));
	CHECK(tangentAt180Deg.X() == Approx(0.0).margin(1e-14));
	CHECK(tangentAt180Deg.Y() == Approx(2.0).margin(1e-14));
	CHECK(tangentAt180Deg.Z() == Approx(0.0));
	CHECK(tangentAt270Deg.X() == Approx(-2.0).margin(1e-14));
	CHECK(tangentAt270Deg.Y() == Approx(0.0).margin(1e-14));
	CHECK(tangentAt270Deg.Z() == Approx(0.0).margin(1e-14));
	CHECK(tangentAt360Deg.X() == Approx(-0.0).margin(1e-14));
	CHECK(tangentAt360Deg.Y() == Approx(-2.0).margin(1e-14));
	CHECK(tangentAt360Deg.Z() == Approx(0.0).margin(1e-14));
	std::cout << "Tangent at 0 deg: " << tangentAt0 << std::endl;
	std::cout << "Tangent at 90 deg: " << tangentAt90Deg << std::endl;
	std::cout << "Tangent at 180 deg: " << tangentAt180Deg << std::endl;
	std::cout << "Tangent at 270 deg: " << tangentAt270Deg << std::endl;
	std::cout << "Tangent at 360 deg: " << tangentAt360Deg << std::endl;
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] AMCAX_API static Point2 CircleValue(double u, const Frame2& pos, double radius)	 @return The point
	 @param radius The radius
	 @param pos The local frame where the circle lies
	 @param u The parameter
	 @brief Compute the point on a 2D circle represented by a local frame and a radius at a parameter
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
using namespace AMCAX;
TEST_CASE("case1: CurveCalculation::CircleValue()[1 / 2] ", "[math][CurveCalculation][P1][CircleValue]") {
	Direction2 defaultDirection(1.0, 0.0); 
	Frame2 defaultFrame2(Point2(1.0, 1.0), defaultDirection);
	Point2 point2 = AMCAX::CurveCalculation::CircleValue(0.0, defaultFrame2, 3.0);
	CHECK(point2.X() == 4.0);
	CHECK(point2.Y() == 1.0);
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] AMCAX_API static Point3 CircleD0(double u, const Frame3& pos, double radius)	 @return The point
	 @param radius The radius
	 @param pos The local frame where the circle lies
	 @param u The parameter
	 @brief Compute the point on a 3D circle represented by a local frame and a radius at a parameter
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
using namespace AMCAX;
TEST_CASE("case1: CurveCalculation::CircleD0 2/2 ", "[math][CurveCalculation][P1]") {
	Direction3 defaultDirection(-1.0, 0.0,0.0); 
	Frame3 defaultFrame3(Point3(1.0, 0.0,0.0), defaultDirection);
	double 	r = 3.0;
	double u = 2 * M_PI / 4; 
	Point3  pointOnCirecle = CurveCalculation::CircleD0(u, defaultFrame3, r);
	std::cout << pointOnCirecle.X() << " " << pointOnCirecle.Y() << " " << pointOnCirecle.Y() << std::endl;
	CHECK(pointOnCirecle.X() == Approx(1.0).epsilon(1e-12));
	CHECK(pointOnCirecle.Y() == -3.0);
	CHECK((pointOnCirecle.X() - 1.0) * (pointOnCirecle.X() - 1.0) + pointOnCirecle.Y() * pointOnCirecle.Y() == r * r);
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] AMCAX_API static Point2 CircleD0(double u, const Frame2& pos, double radius)	 @return The point
	 @param radius The radius
	 @param pos The local frame where the circle lies
	 @param u The parameter
	 @brief Compute the point on a 2D circle represented by a local frame and a radius at a parameter
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
using namespace AMCAX;
TEST_CASE("case1: CurveCalculation::CircleD0 1/2 ", "[math][CurveCalculation][P1]") {
	Direction2 defaultDirection(1.0,0.0); 
	Frame2 defaultFrame2(Point2(0.0, 0.0), defaultDirection);
	double 	r = 3.0;
	double u = 4 * M_PI ; 
	Point2  pointOnCirecle = CurveCalculation::CircleD0(u, defaultFrame2, r);
	std::cout << pointOnCirecle.X() << " " << pointOnCirecle.Y() << " "  << std::endl;
	CHECK(pointOnCirecle.X() == 3.0);
	CHECK(pointOnCirecle.Y() == Approx(0.0).margin(1e-14));
	CHECK(pointOnCirecle.X() * pointOnCirecle.X() + pointOnCirecle.Y() * pointOnCirecle.Y() == r * r);
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] AMCAX_API static Vector3 CircleD1(double u, const Frame3& pos, double radius)	 @return The first derivative vector
	 @param radius The radius
	 @param pos The local frame where the circle lies
	 @param u The parameter
	 @brief Compute the first derivative on a 3D circle represented by a local frame and a radius at a parameter
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
using namespace AMCAX;
TEST_CASE("case1: CurveCalculation::CircleD1 3/4 ", "[math][CurveCalculation][P1][CircleD1]") {
	Direction3 initialDir(0.0, 0.0,1.0); 
	Frame3 defaultFrame3(Point3(1.0, 0.0,0.0), initialDir); 
	double radius = 2.0; 
	Vector3 tangentAt0 = AMCAX::CurveCalculation::CircleD1(0.0, defaultFrame3, radius);
	Vector3 tangentAt90Deg = AMCAX::CurveCalculation::CircleD1(M_PI_2, defaultFrame3, radius);
	Vector3 tangentAt180Deg = AMCAX::CurveCalculation::CircleD1(M_PI, defaultFrame3, radius);
	Vector3 tangentAt270Deg = AMCAX::CurveCalculation::CircleD1(3 * M_PI_2, defaultFrame3, radius);
	Vector3 tangentAt360Deg = AMCAX::CurveCalculation::CircleD1(2 * M_PI, defaultFrame3, radius);
	CHECK(tangentAt0.X() == Approx(0.0));
	CHECK(tangentAt0.Y() == Approx(2.0));
	CHECK(tangentAt90Deg.X() == Approx(-2.0));
	CHECK(tangentAt90Deg.Y() == Approx(0.0).margin(1e-14));
	CHECK(tangentAt180Deg.X() == Approx(0.0).margin(1e-14));
	CHECK(tangentAt180Deg.Y() == Approx(-2.0));
	CHECK(tangentAt270Deg.X() == Approx(2.0));
	CHECK(tangentAt270Deg.Y() == Approx(-0.0).margin(1e-14));
	CHECK(tangentAt360Deg.X() == Approx(0.0).margin(1e-14));
	CHECK(tangentAt360Deg.Y() == Approx(2.0));
	std::cout << "Tangent at 0 deg: " << tangentAt0 << std::endl;
	std::cout << "Tangent at 90 deg: " << tangentAt90Deg << std::endl;
	std::cout << "Tangent at 180 deg: " << tangentAt180Deg << std::endl;
	std::cout << "Tangent at 270 deg: " << tangentAt270Deg << std::endl;
	std::cout << "Tangent at 360 deg: " << tangentAt360Deg << std::endl;
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static void CircleD1(double u, const Frame3& pos, double radius, Point3& p, Vector3& v1)	 @param[out] v1 The first derivative
	 @param[out] p The point
	 @param[in] radius The radius
	 @param[in] pos The local frame where the circle lies
	 @param[in] u The parameter
	 @brief Compute the point and the first derivative on a 3D circle represented by a local frame and a radius at a parameter
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
using namespace AMCAX;
TEST_CASE("case1: CurveCalculation::CircleD1 4/4 ", "[math][CurveCalculation][P1][CircleD1]") {
	Direction3 initialDir(0.0, 0.0,1.0);
	Frame3 defaultFrame3(Point3(1.0, 1.0,0.0), initialDir);
	double radius = 2.0;
	Point3 p;
	Vector3 v;
	SECTION("0 deg case") {
		AMCAX::CurveCalculation::CircleD1(0.0, defaultFrame3, radius, p, v);
		CHECK(p.X() == 3.0);
		CHECK(p.Y() == 1.0);
		CHECK(p.Z() == 0.0);
		CHECK(v.X() == Approx(0.0));
		CHECK(v.Y() == Approx(2.0));
		CHECK(v.Z() == Approx(0.0));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] AMCAX_API static Vector2 CircleD1(double u, const Frame2& pos, double radius)	 @return The first derivative vector
	 @param radius The radius
	 @param pos The local frame where the circle lies
	 @param u The parameter
	 @brief Compute the first derivative on a 2D circle represented by a local frame and a radius at a parameter
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
using namespace AMCAX;
TEST_CASE("case1: CurveCalculation::CircleD1 1/4 ", "[math][CurveCalculation][P1][CircleD1]") {
	Direction2 initialDir(1.0, 0.0); 
	Frame2 defaultFrame2(Point2(1.0, 1.0), initialDir); 
	double radius = 2.0; 
	Vector2 tangentAt0 = AMCAX::CurveCalculation::CircleD1(0.0, defaultFrame2, radius);
	Vector2 tangentAt90Deg = AMCAX::CurveCalculation::CircleD1(M_PI_2, defaultFrame2, radius);
	Vector2 tangentAt180Deg = AMCAX::CurveCalculation::CircleD1(M_PI, defaultFrame2, radius);
	Vector2 tangentAt270Deg = AMCAX::CurveCalculation::CircleD1(3 * M_PI_2, defaultFrame2, radius);
	Vector2 tangentAt360Deg = AMCAX::CurveCalculation::CircleD1(2 * M_PI, defaultFrame2, radius);
	CHECK(tangentAt0.X() == Approx(-0.0));
	CHECK(tangentAt0.Y() == Approx(2.0));
	CHECK(tangentAt90Deg.X() == Approx(-2.0));
	CHECK(tangentAt90Deg.Y() == Approx(0.0).margin(1e-14));
	CHECK(tangentAt180Deg.X() == Approx(-0.0).margin(1e-14));
	CHECK(tangentAt180Deg.Y() == Approx(-2.0));
	CHECK(tangentAt270Deg.X() == Approx(2.0));
	CHECK(tangentAt270Deg.Y() == Approx(-0.0).margin(1e-14));
	CHECK(tangentAt360Deg.X() == Approx(0.0).margin(1e-14));
	CHECK(tangentAt360Deg.Y() == Approx(2.0));
	std::cout << "Tangent at 0 deg: " << tangentAt0 << std::endl;
	std::cout << "Tangent at 90 deg: " << tangentAt90Deg << std::endl;
	std::cout << "Tangent at 180 deg: " << tangentAt180Deg << std::endl;
	std::cout << "Tangent at 270 deg: " << tangentAt270Deg << std::endl;
	std::cout << "Tangent at 360 deg: " << tangentAt360Deg << std::endl;
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static void CircleD1(double u, const Frame2& pos, double radius, Point2& p, Vector2& v1)	 @param[out] v1 The first derivative
	 @param[out] p The point
	 @param[in] radius The radius
	 @param[in] pos The local frame where the circle lies
	 @param[in] u The parameter
	 @brief Compute the point and the first derivative on a 2D circle represented by a local frame and a radius at a parameter
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
using namespace AMCAX;
TEST_CASE("case1: CurveCalculation::CircleD1 1/4 ", "[math][CurveCalculation][P1][CircleD1]") {
	Direction2 initialDir(1.0, 0.0); 
	Frame2 defaultFrame2(Point2(1.0, 1.0), initialDir); 
	double radius = 2.0; 
	Vector2 tangentAt0 = AMCAX::CurveCalculation::CircleD1(0.0, defaultFrame2, radius);
	Vector2 tangentAt90Deg = AMCAX::CurveCalculation::CircleD1(M_PI_2, defaultFrame2, radius);
	Vector2 tangentAt180Deg = AMCAX::CurveCalculation::CircleD1(M_PI, defaultFrame2, radius);
	Vector2 tangentAt270Deg = AMCAX::CurveCalculation::CircleD1(3 * M_PI_2, defaultFrame2, radius);
	Vector2 tangentAt360Deg = AMCAX::CurveCalculation::CircleD1(2 * M_PI, defaultFrame2, radius);
	CHECK(tangentAt0.X() == Approx(-0.0));
	CHECK(tangentAt0.Y() == Approx(2.0));
	CHECK(tangentAt90Deg.X() == Approx(-2.0));
	CHECK(tangentAt90Deg.Y() == Approx(0.0).margin(1e-14));
	CHECK(tangentAt180Deg.X() == Approx(-0.0).margin(1e-14));
	CHECK(tangentAt180Deg.Y() == Approx(-2.0));
	CHECK(tangentAt270Deg.X() == Approx(2.0));
	CHECK(tangentAt270Deg.Y() == Approx(-0.0).margin(1e-14));
	CHECK(tangentAt360Deg.X() == Approx(0.0).margin(1e-14));
	CHECK(tangentAt360Deg.Y() == Approx(2.0));
	std::cout << "Tangent at 0 deg: " << tangentAt0 << std::endl;
	std::cout << "Tangent at 90 deg: " << tangentAt90Deg << std::endl;
	std::cout << "Tangent at 180 deg: " << tangentAt180Deg << std::endl;
	std::cout << "Tangent at 270 deg: " << tangentAt270Deg << std::endl;
	std::cout << "Tangent at 360 deg: " << tangentAt360Deg << std::endl;
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] AMCAX_API static Vector3 CircleD2(double u, const Frame3& pos, double radius)	 @return The second derivative vector
	 @param radius The radius
	 @param pos The local frame where the circle lies
	 @param u The parameter
	 @brief Compute the second derivative on a 3D circle represented by a local frame and a radius at a parameter
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
using namespace AMCAX;
TEST_CASE("case1: CurveCalculation::CircleD2 3/4 ", "[math][CurveCalculation][P1][CircleD2]") {
	Direction3 initialDir(0.0, 0.0, 1.0); 
	Frame3 defaultFrame3(Point3(1.0, 1.0, 0.0), initialDir); 
	double radius = 2.0; 
	Vector3 tangentAt0 = AMCAX::CurveCalculation::CircleD2(0.0, defaultFrame3, radius);
	Vector3 tangentAt90Deg = AMCAX::CurveCalculation::CircleD2(M_PI_2, defaultFrame3, radius);
	Vector3 tangentAt180Deg = AMCAX::CurveCalculation::CircleD2(M_PI, defaultFrame3, radius);
	Vector3 tangentAt270Deg = AMCAX::CurveCalculation::CircleD2(3 * M_PI_2, defaultFrame3, radius);
	Vector3 tangentAt360Deg = AMCAX::CurveCalculation::CircleD2(2 * M_PI, defaultFrame3, radius);
	CHECK(tangentAt0.X() == Approx(-2.0));
	CHECK(tangentAt0.Y() == Approx(-0.0));
	CHECK(tangentAt0.Z() == Approx(0.0));
	CHECK(tangentAt90Deg.X() == Approx(-0.0).margin(1e-14));
	CHECK(tangentAt90Deg.Y() == Approx(-2.0).margin(1e-14));
	CHECK(tangentAt90Deg.Z() == Approx(0.0).margin(1e-14));
	CHECK(tangentAt180Deg.X() == Approx(2.0).margin(1e-14));
	CHECK(tangentAt180Deg.Y() == Approx(-0.0).margin(1e-14));
	CHECK(tangentAt180Deg.Z() == Approx(-0.0));
	CHECK(tangentAt270Deg.X() == Approx(0.0).margin(1e-14));
	CHECK(tangentAt270Deg.Y() == Approx(2.0).margin(1e-14));
	CHECK(tangentAt270Deg.Z() == Approx(0.0).margin(1e-14));
	CHECK(tangentAt360Deg.X() == Approx(-2.0).margin(1e-14));
	CHECK(tangentAt360Deg.Y() == Approx(0.0).margin(1e-14));
	CHECK(tangentAt360Deg.Z() == Approx(0.0).margin(1e-14));
	std::cout << "Tangent at 0 deg: " << tangentAt0 << std::endl;
	std::cout << "Tangent at 90 deg: " << tangentAt90Deg << std::endl;
	std::cout << "Tangent at 180 deg: " << tangentAt180Deg << std::endl;
	std::cout << "Tangent at 270 deg: " << tangentAt270Deg << std::endl;
	std::cout << "Tangent at 360 deg: " << tangentAt360Deg << std::endl;
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static void CircleD2(double u, const Frame3& pos, double radius, Point3& p, Vector3& v1, Vector3& v2)	 @param[out] v2 The second derivative
	 @param[out] v1 The first derivative
	 @param[out] p The point
	 @param[in] radius The radius
	 @param[in] pos The local frame where the circle lies
	 @param[in] u The parameter
	 @brief Compute the point and the first two derivatives on a 3D circle represented by a local frame and a radius at a parameter
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
using namespace AMCAX;
TEST_CASE("case1: CurveCalculation::CircleD2 3/4 ", "[math][CurveCalculation][P1][CircleD2]") {
	Direction3 initialDir(0.0, 0.0, 1.0); 
	Frame3 defaultFrame3(Point3(1.0, 1.0, 0.0), initialDir); 
	double radius = 2.0; 
	Vector3 tangentAt0 = AMCAX::CurveCalculation::CircleD2(0.0, defaultFrame3, radius);
	Vector3 tangentAt90Deg = AMCAX::CurveCalculation::CircleD2(M_PI_2, defaultFrame3, radius);
	Vector3 tangentAt180Deg = AMCAX::CurveCalculation::CircleD2(M_PI, defaultFrame3, radius);
	Vector3 tangentAt270Deg = AMCAX::CurveCalculation::CircleD2(3 * M_PI_2, defaultFrame3, radius);
	Vector3 tangentAt360Deg = AMCAX::CurveCalculation::CircleD2(2 * M_PI, defaultFrame3, radius);
	CHECK(tangentAt0.X() == Approx(-2.0));
	CHECK(tangentAt0.Y() == Approx(-0.0));
	CHECK(tangentAt0.Z() == Approx(0.0));
	CHECK(tangentAt90Deg.X() == Approx(-0.0).margin(1e-14));
	CHECK(tangentAt90Deg.Y() == Approx(-2.0).margin(1e-14));
	CHECK(tangentAt90Deg.Z() == Approx(0.0).margin(1e-14));
	CHECK(tangentAt180Deg.X() == Approx(2.0).margin(1e-14));
	CHECK(tangentAt180Deg.Y() == Approx(-0.0).margin(1e-14));
	CHECK(tangentAt180Deg.Z() == Approx(-0.0));
	CHECK(tangentAt270Deg.X() == Approx(0.0).margin(1e-14));
	CHECK(tangentAt270Deg.Y() == Approx(2.0).margin(1e-14));
	CHECK(tangentAt270Deg.Z() == Approx(0.0).margin(1e-14));
	CHECK(tangentAt360Deg.X() == Approx(-2.0).margin(1e-14));
	CHECK(tangentAt360Deg.Y() == Approx(0.0).margin(1e-14));
	CHECK(tangentAt360Deg.Z() == Approx(0.0).margin(1e-14));
	std::cout << "Tangent at 0 deg: " << tangentAt0 << std::endl;
	std::cout << "Tangent at 90 deg: " << tangentAt90Deg << std::endl;
	std::cout << "Tangent at 180 deg: " << tangentAt180Deg << std::endl;
	std::cout << "Tangent at 270 deg: " << tangentAt270Deg << std::endl;
	std::cout << "Tangent at 360 deg: " << tangentAt360Deg << std::endl;
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] AMCAX_API static Vector2 CircleD2(double u, const Frame2& pos, double radius)	 @return The second derivative vector
	 @param radius The radius
	 @param pos The local frame where the circle lies
	 @param u The parameter
	 @brief Compute the second derivative on a 2D circle represented by a local frame and a radius at a parameter
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
using namespace AMCAX;
TEST_CASE("case1: CurveCalculation::CircleD2 1/4 ", "[math][CurveCalculation][P1][CircleD2]") {
	Direction2 defaultDirection(1.0, 0.0); 
	Frame2 defaultFrame2(Point2(0.0, 0.0), defaultDirection);
	double 	r = 2.0;
	double u = 0.0; 
	Vector2  vector2 = CurveCalculation::CircleD2(u, defaultFrame2, r); 
	std::cout << vector2.X() << " " << vector2.Y() << " " << std::endl;
	CHECK(vector2.X() == -2.0);
	CHECK(vector2.Y() == Approx(0.0).margin(1e-14));
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static void CircleD2(double u, const Frame2& pos, double radius, Point2& p, Vector2& v1, Vector2& v2)	 @param[out] v2 The second derivative
	 @param[out] v1 The first derivative
	 @param[out] p The point
	 @param[in] radius The radius
	 @param[in] pos The local frame where the circle lies
	 @param[in] u The parameter
	 @brief Compute the point and the first two derivatives on a 2D circle represented by a local frame and a radius at a parameter
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
using namespace AMCAX;
TEST_CASE("case1: CurveCalculation::CircleD2 1/4 ", "[math][CurveCalculation][P1][CircleD2]") {
	Direction2 defaultDirection(1.0, 0.0); 
	Frame2 defaultFrame2(Point2(0.0, 0.0), defaultDirection);
	double 	r = 2.0;
	double u = 0.0; 
	Vector2  vector2 = CurveCalculation::CircleD2(u, defaultFrame2, r); 
	std::cout << vector2.X() << " " << vector2.Y() << " " << std::endl;
	CHECK(vector2.X() == -2.0);
	CHECK(vector2.Y() == Approx(0.0).margin(1e-14));
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] AMCAX_API static Vector3 CircleD3(double u, const Frame3& pos, double radius)	 @return The third derivative vector
	 @param radius The radius
	 @param pos The local frame where the circle lies
	 @param u The parameter
	 @brief Compute the third derivative on a 3D circle represented by a local frame and a radius at a parameter
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
using namespace AMCAX;
TEST_CASE("case1: CurveCalculation::CircleD3 3/4 ", "[math][CurveCalculation][P1][CircleD3]") {
	Direction3 initialDir(0.0, 0.0, 1.0); 
	Frame3 defaultFrame3(Point3(1.0, 1.0, 0.0), initialDir); 
	double radius = 2.0; 
	Vector3 tangentAt0 = AMCAX::CurveCalculation::CircleD3(0.0, defaultFrame3, radius);
	Vector3 tangentAt90Deg = AMCAX::CurveCalculation::CircleD3(M_PI_2, defaultFrame3, radius);
	Vector3 tangentAt180Deg = AMCAX::CurveCalculation::CircleD3(M_PI, defaultFrame3, radius);
	Vector3 tangentAt270Deg = AMCAX::CurveCalculation::CircleD3(3 * M_PI_2, defaultFrame3, radius);
	Vector3 tangentAt360Deg = AMCAX::CurveCalculation::CircleD3(2 * M_PI, defaultFrame3, radius);
	CHECK(tangentAt0.X() == Approx(0.0));
	CHECK(tangentAt0.Y() == Approx(-2.0));
	CHECK(tangentAt0.Z() == Approx(-0.0));
	CHECK(tangentAt90Deg.X() == Approx(2.0).margin(1e-14));
	CHECK(tangentAt90Deg.Y() == Approx(-0.0).margin(1e-14));
	CHECK(tangentAt90Deg.Z() == Approx(0.0).margin(1e-14));
	CHECK(tangentAt180Deg.X() == Approx(0.0).margin(1e-14));
	CHECK(tangentAt180Deg.Y() == Approx(2.0).margin(1e-14));
	CHECK(tangentAt180Deg.Z() == Approx(0.0));
	CHECK(tangentAt270Deg.X() == Approx(-2.0).margin(1e-14));
	CHECK(tangentAt270Deg.Y() == Approx(0.0).margin(1e-14));
	CHECK(tangentAt270Deg.Z() == Approx(0.0).margin(1e-14));
	CHECK(tangentAt360Deg.X() == Approx(-0.0).margin(1e-14));
	CHECK(tangentAt360Deg.Y() == Approx(-2.0).margin(1e-14));
	CHECK(tangentAt360Deg.Z() == Approx(0.0).margin(1e-14));
	std::cout << "Tangent at 0 deg: " << tangentAt0 << std::endl;
	std::cout << "Tangent at 90 deg: " << tangentAt90Deg << std::endl;
	std::cout << "Tangent at 180 deg: " << tangentAt180Deg << std::endl;
	std::cout << "Tangent at 270 deg: " << tangentAt270Deg << std::endl;
	std::cout << "Tangent at 360 deg: " << tangentAt360Deg << std::endl;
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static void CircleD3(double u, const Frame3& pos, double radius, Point3& p, Vector3& v1, Vector3& v2, Vector3& v3)	 @param[out] v3 The third derivative
	 @param[out] v2 The second derivative
	 @param[out] v1 The first derivative
	 @param[out] p The point
	 @param[in] radius The radius
	 @param[in] pos The local frame where the circle lies
	 @param[in] u The parameter
	 @brief Compute the point and the first three derivatives on a 3D circle represented by a local frame and a radius at a parameter
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
using namespace AMCAX;
TEST_CASE("case1: CurveCalculation::CircleD3 3/4 ", "[math][CurveCalculation][P1][CircleD3]") {
	Direction3 initialDir(0.0, 0.0, 1.0); 
	Frame3 defaultFrame3(Point3(1.0, 1.0, 0.0), initialDir); 
	double radius = 2.0; 
	Vector3 tangentAt0 = AMCAX::CurveCalculation::CircleD3(0.0, defaultFrame3, radius);
	Vector3 tangentAt90Deg = AMCAX::CurveCalculation::CircleD3(M_PI_2, defaultFrame3, radius);
	Vector3 tangentAt180Deg = AMCAX::CurveCalculation::CircleD3(M_PI, defaultFrame3, radius);
	Vector3 tangentAt270Deg = AMCAX::CurveCalculation::CircleD3(3 * M_PI_2, defaultFrame3, radius);
	Vector3 tangentAt360Deg = AMCAX::CurveCalculation::CircleD3(2 * M_PI, defaultFrame3, radius);
	CHECK(tangentAt0.X() == Approx(0.0));
	CHECK(tangentAt0.Y() == Approx(-2.0));
	CHECK(tangentAt0.Z() == Approx(-0.0));
	CHECK(tangentAt90Deg.X() == Approx(2.0).margin(1e-14));
	CHECK(tangentAt90Deg.Y() == Approx(-0.0).margin(1e-14));
	CHECK(tangentAt90Deg.Z() == Approx(0.0).margin(1e-14));
	CHECK(tangentAt180Deg.X() == Approx(0.0).margin(1e-14));
	CHECK(tangentAt180Deg.Y() == Approx(2.0).margin(1e-14));
	CHECK(tangentAt180Deg.Z() == Approx(0.0));
	CHECK(tangentAt270Deg.X() == Approx(-2.0).margin(1e-14));
	CHECK(tangentAt270Deg.Y() == Approx(0.0).margin(1e-14));
	CHECK(tangentAt270Deg.Z() == Approx(0.0).margin(1e-14));
	CHECK(tangentAt360Deg.X() == Approx(-0.0).margin(1e-14));
	CHECK(tangentAt360Deg.Y() == Approx(-2.0).margin(1e-14));
	CHECK(tangentAt360Deg.Z() == Approx(0.0).margin(1e-14));
	std::cout << "Tangent at 0 deg: " << tangentAt0 << std::endl;
	std::cout << "Tangent at 90 deg: " << tangentAt90Deg << std::endl;
	std::cout << "Tangent at 180 deg: " << tangentAt180Deg << std::endl;
	std::cout << "Tangent at 270 deg: " << tangentAt270Deg << std::endl;
	std::cout << "Tangent at 360 deg: " << tangentAt360Deg << std::endl;
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] AMCAX_API static Vector2 CircleD3(double u, const Frame2& pos, double radius)	 @return The third derivative vector
	 @param radius The radius
	 @param pos The local frame where the circle lies
	 @param u The parameter
	 @brief Compute the third derivative on a 2D circle represented by a local frame and a radius at a parameter
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
using namespace AMCAX;
TEST_CASE("case1: CurveCalculation::CircleD3 1/4 ", "[math][CurveCalculation][P1][CircleD3]") {
	Direction2 defaultDir2(1.0, 0.0);
	Frame2 defaultFrame2(Point2(1.0, 1.0), defaultDir2);
	double radius = 2.0;
	Vector2 tangentAt0 = AMCAX::CurveCalculation::CircleD3(0.0, defaultFrame2, radius);
	Vector2 tangentAt180 = AMCAX::CurveCalculation::CircleD3(M_PI, defaultFrame2, radius);
	Vector2 tangentAt360 = AMCAX::CurveCalculation::CircleD3(2 * M_PI, defaultFrame2, radius);
	CHECK(tangentAt0.X() == 0.0);
	CHECK(tangentAt0.Y() == -2.0);
	CHECK(tangentAt180.X() == Approx(0.0).margin(1e-14));
	CHECK(tangentAt180.Y() == 2.0 );
	CHECK(tangentAt360.X() == Approx(0.0).margin(1e-14));
	CHECK(tangentAt360.Y() == -2.0 );
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static void CircleD3(double u, const Frame2& pos, double radius, Point2& p, Vector2& v1, Vector2& v2, Vector2& v3)	 @param[out] v3 The third derivative
	 @param[out] v2 The second derivative
	 @param[out] v1 The first derivative
	 @param[out] p The point
	 @param[in] radius The radius
	 @param[in] pos The local frame where the circle lies
	 @param[in] u The parameter
	 @brief Compute the point and the first three derivatives on a 2D circle represented by a local frame and a radius at a parameter
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
using namespace AMCAX;
TEST_CASE("case1: CurveCalculation::CircleD3 1/4 ", "[math][CurveCalculation][P1][CircleD3]") {
	Direction2 defaultDir2(1.0, 0.0);
	Frame2 defaultFrame2(Point2(1.0, 1.0), defaultDir2);
	double radius = 2.0;
	Vector2 tangentAt0 = AMCAX::CurveCalculation::CircleD3(0.0, defaultFrame2, radius);
	Vector2 tangentAt180 = AMCAX::CurveCalculation::CircleD3(M_PI, defaultFrame2, radius);
	Vector2 tangentAt360 = AMCAX::CurveCalculation::CircleD3(2 * M_PI, defaultFrame2, radius);
	CHECK(tangentAt0.X() == 0.0);
	CHECK(tangentAt0.Y() == -2.0);
	CHECK(tangentAt180.X() == Approx(0.0).margin(1e-14));
	CHECK(tangentAt180.Y() == 2.0 );
	CHECK(tangentAt360.X() == Approx(0.0).margin(1e-14));
	CHECK(tangentAt360.Y() == -2.0 );
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] AMCAX_API static Vector3 CircleDN(double u, const Frame3& pos, double radius, int n)	 @return The n-th derivative vector
	 @param n The order of derivative
	 @param radius The radius
	 @param pos The local frame where the circle lies
	 @param u The parameter
	 @brief Compute the n-th derivative on a 3D circle represented by a local frame and a radius at a parameter
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
using namespace AMCAX;
TEST_CASE("case1: CurveCalculation::CircleDN 2/2 ", "[math][CurveCalculation][P1][CircleDN]") {
	Direction3 initialDir(0.0, 0.0, 1.0); 
	Frame3 defaultFrame3(Point3(1.0, 1.0, 0.0), initialDir); 
	double radius = 2.0; 
	double u = 0.0;
	SECTION("2 derivative vector") {
		Vector3  vector3 = CurveCalculation::CircleDN(u, defaultFrame3, radius, 2); 
		std::cout << vector3.X() << " " << vector3.Y() << " " << std::endl;
		CHECK(vector3.X() == -2.0);
		CHECK(vector3.Y() == Approx(0.0).margin(1e-14));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] AMCAX_API static Vector2 CircleDN(double u, const Frame2& pos, double radius, int n)	 @return The n-th derivative vector
	 @param n The order of derivative
	 @param radius The radius
	 @param pos The local frame where the circle lies
	 @param u The parameter
	 @brief Compute the n-th derivative on a 2D circle represented by a local frame and a radius at a parameter
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
using namespace AMCAX;
TEST_CASE("case1: CurveCalculation::CircleDN 1/2 ", "[math][CurveCalculation][P1][CircleDN]") {
	Direction2 defaultDirection(1.0, 0.0); 
	Frame2 defaultFrame2(Point2(0.0, 0.0), defaultDirection);
	double 	r = 2.0;
	double u = 0.0;
	SECTION("2 derivative vector") {
		Vector2  vector2 = CurveCalculation::CircleDN(u, defaultFrame2, r, 2); 
		std::cout << vector2.X() << " " << vector2.Y() << " " << std::endl;
		CHECK(vector2.X() == -2.0);
		CHECK(vector2.Y() == Approx(0.0).margin(1e-14));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] AMCAX_API static double CircleParameter(const Frame3& pos, const Point3& p)	 @return The parameter of point
	 @param p The given point
	 @param pos The local frame where the circle lies
	 @brief Compute the parameter of a given point on a 3D circle represented by a local frame
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
using namespace AMCAX;
TEST_CASE("case1: CurveCalculation::CircleParameter() [1/2] ", "[math][CurveCalculation][P1][CircleParameter]") {
	Direction2 defaultDirection(1.0, 0.0); 
	Frame2 defaultFrame2(Point2(0.0, 0.0), defaultDirection);
	double u1 = AMCAX::CurveCalculation::CircleParameter(defaultFrame2, Point2(0.0, 1.0)); 
	CHECK(u1 == M_PI_2);
	double u2 = AMCAX::CurveCalculation::CircleParameter(defaultFrame2, Point2(0.0, 0.0));
	CHECK(u2 == 0.0);
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] AMCAX_API static double CircleParameter(const Frame2& pos, const Point2& p)	 @return The parameter of point
	 @param p The given point
	 @param pos The local frame where the circle lies
	 @brief Compute the parameter of a given point on a 2D circle represented by a local frame
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
using namespace AMCAX;
TEST_CASE("case1: CurveCalculation::CircleParameter() [1/2] ", "[math][CurveCalculation][P1][CircleParameter]") {
	Direction2 defaultDirection(1.0, 0.0); 
	Frame2 defaultFrame2(Point2(0.0, 0.0), defaultDirection);
	double u1 = AMCAX::CurveCalculation::CircleParameter(defaultFrame2, Point2(0.0, 1.0)); 
	CHECK(u1 == M_PI_2);
	double u2 = AMCAX::CurveCalculation::CircleParameter(defaultFrame2, Point2(0.0, 0.0));
	CHECK(u2 == 0.0);
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] AMCAX_API static Point3 D0(double u, const Line3& line)	 @return The resulting point
	 @param line The line
	 @param u The parameter
	 @brief Compute the point on a 3D line at a parameter
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
#include <occtio/OCCTTool.hpp>
#include <geometry/MakeArcOfHyperbola2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeEdge2d.hpp>
using namespace AMCAX;
TEST_CASE("case1: CurveCalculation::D0() [6/10] ", "[math][CurveCalculation][P1][D0]") {
	Frame3 fram3;
	double major_radius = 1000.0;
	double minor_radius = 10.0;
	Hyperbola3 hyperbola(fram3, major_radius, minor_radius);
	Point3 point3 = CurveCalculation::D0(0.0, hyperbola);
	CHECK(point3.X() == 1000.0);
	CHECK(point3.Y() == 0.0);
	CHECK(point3.Z() == 0.0);
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] AMCAX_API static Point3 D0(double u, const Circle3& circle)	 @return The resulting point
	 @param circle The circle
	 @param u The parameter
	 @brief Compute the point on a 3D circle at a parameter
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
#include <occtio/OCCTTool.hpp>
#include <geometry/MakeArcOfHyperbola2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeEdge2d.hpp>
using namespace AMCAX;
TEST_CASE("case1: CurveCalculation::D0() [2/10] ", "[math][CurveCalculation][P1][D0]") {
	AMCAX::Circle3 circle3D;
	AMCAX::Point3  center3D(1.0, 1.0, 1.0);
	double radius3D = 5.0;
	double tol = 0.1;
	circle3D.SetLocation(center3D);
	circle3D.SetRadius(radius3D);
	Point3 point3 = AMCAX::CurveCalculation::D0(M_PI_2, circle3D);
	CHECK(point3.X() == Approx(1.0));
	CHECK(point3.Y() == 6.0);
	CHECK(point3.Z() == 1.0);
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] AMCAX_API static Point3 D0(double u, const Ellipse3& ellipse)	 @return The resulting point
	 @param ellipse The ellipse
	 @param u The parameter
	 @brief Compute the point on a 3D ellipse at a parameter
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
#include <occtio/OCCTTool.hpp>
#include <geometry/MakeArcOfHyperbola2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeEdge2d.hpp>
using namespace AMCAX;
TEST_CASE("case1: CurveCalculation::D0() [4/10] ", "[math][CurveCalculation][P1][D0]") {
	Frame3 fram3 = Frame3(Point3(0.0, 0.0, 1.0), Direction3(0.0, 0.0, 1.0));
	AMCAX::Ellipse3 ellipse3(fram3, 5.0, 3.0);
	Point3 point3 = AMCAX::CurveCalculation::D0(M_PI_2, ellipse3);
	CHECK(point3.X() == Approx(0.0).margin(1e-12));
	CHECK(point3.Y() == 3.0);
	CHECK(point3.Z() == 1.0);
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] AMCAX_API static Point3 D0(double u, const Parabola3& parabola)	 @return The resulting point
	 @param parabola The parabola
	 @param u The parameter
	 @brief Compute the point on a 3D parabola at a parameter
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
#include <occtio/OCCTTool.hpp>
#include <geometry/MakeArcOfHyperbola2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeEdge2d.hpp>
using namespace AMCAX;
TEST_CASE("case1: CurveCalculation::D0() [10/10] ", "[math][CurveCalculation][P1][D0]") {
	Point3 point3(0.0, 0.0, 0.0);
	Direction3 dir3(0.0, 0.0, 1.0);
	Frame3 fram3(point3, dir3);
	double focal = 2.0;
	Parabola3 parabola3(fram3, focal);
	SECTION("u =0") {
		Point3 point3 = CurveCalculation::D0(0.0, parabola3);
		CHECK(point3.X() == 0.0);
		CHECK(point3.Y() == 0.0);
		CHECK(point3.Z() == 0.0);
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] AMCAX_API static Point3 D0(double u, const Hyperbola3& hyperbola)	 @return The resulting point
	 @param hyperbola The hyperbola
	 @param u The parameter
	 @brief Compute the point on a 3D hyperbola at a parameter
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
#include <occtio/OCCTTool.hpp>
#include <geometry/MakeArcOfHyperbola2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeEdge2d.hpp>
using namespace AMCAX;
TEST_CASE("case1: CurveCalculation::D0() [6/10] ", "[math][CurveCalculation][P1][D0]") {
	Frame3 fram3;
	double major_radius = 1000.0;
	double minor_radius = 10.0;
	Hyperbola3 hyperbola(fram3, major_radius, minor_radius);
	Point3 point3 = CurveCalculation::D0(0.0, hyperbola);
	CHECK(point3.X() == 1000.0);
	CHECK(point3.Y() == 0.0);
	CHECK(point3.Z() == 0.0);
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] AMCAX_API static Point2 D0(double u, const Line2& line)	 @return The resulting point
	 @param line The line
	 @param u The parameter
	 @brief Compute the point on a 2D line at a parameter
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
#include <occtio/OCCTTool.hpp>
#include <geometry/MakeArcOfHyperbola2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeEdge2d.hpp>
using namespace AMCAX;
TEST_CASE("case1: CurveCalculation::D0() [1/10] ", "[math][CurveCalculation][P1][D0]") {
	AMCAX::Point2 P(0.0, 0.0);
	AMCAX::Direction2 D(1.0, 0.0);
	AMCAX::Axis2  axis2(P, D);
	float radius = 2.0f;
	AMCAX::Circle2 circle2(axis2, radius, true);
	Point2 point2 = AMCAX::CurveCalculation::D0(0.0, circle2);
	CHECK(point2.X() == 2.0);
	CHECK(point2.Y() == 0.0);
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] AMCAX_API static Point2 D0(double u, const Circle2& circle)	 @return The resulting point
	 @param circle The circle
	 @param u The parameter
	 @brief Compute the point on a 2D circle at a parameter
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
#include <occtio/OCCTTool.hpp>
#include <geometry/MakeArcOfHyperbola2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeEdge2d.hpp>
using namespace AMCAX;
TEST_CASE("case1: CurveCalculation::D0() [1/10] ", "[math][CurveCalculation][P1][D0]") {
	AMCAX::Point2 P(0.0, 0.0);
	AMCAX::Direction2 D(1.0, 0.0);
	AMCAX::Axis2  axis2(P, D);
	float radius = 2.0f;
	AMCAX::Circle2 circle2(axis2, radius, true);
	Point2 point2 = AMCAX::CurveCalculation::D0(0.0, circle2);
	CHECK(point2.X() == 2.0);
	CHECK(point2.Y() == 0.0);
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] AMCAX_API static Point2 D0(double u, const Ellipse2& ellipse)	 @return The resulting point
	 @param ellipse The ellipse
	 @param u The parameter
	 @brief Compute the point on a 2D ellipse at a parameter
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
#include <occtio/OCCTTool.hpp>
#include <geometry/MakeArcOfHyperbola2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeEdge2d.hpp>
using namespace AMCAX;
TEST_CASE("case1: CurveCalculation::D0() [3/10] ", "[math][CurveCalculation][P1][D0]") {
	AMCAX::Ellipse2 ellipse2(AMCAX::Axis2(AMCAX::Point2(0.0, 0.0), AMCAX::Direction2(1.0, 0.0)), 5.0, 3.0);
	Point2 point2 = AMCAX::CurveCalculation::D0(M_PI_2, ellipse2);
	CHECK(point2.X() == Approx(0.0).margin(1e-12));
	CHECK(point2.Y() == 3.0);
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] AMCAX_API static Point2 D0(double u, const Parabola2& parabola)	 @return The resulting point
	 @param parabola The parabola
	 @param u The parameter
	 @brief Compute the point on a 2D parabola at a parameter
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
#include <occtio/OCCTTool.hpp>
#include <geometry/MakeArcOfHyperbola2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeEdge2d.hpp>
using namespace AMCAX;
TEST_CASE("case1: CurveCalculation::D0() [9/10] ", "[math][CurveCalculation][P1][D0]") {
	AMCAX::Point2 P(0.0, 0.0);
	AMCAX::Direction2 D(1.0, 0.0);
	AMCAX::Axis2  axis2(P, D);
	double focal = 2.0;
	AMCAX::Parabola2 parabola2(axis2,focal );
	SECTION("u =0") {  
		Point2 point2 = CurveCalculation::D0(0.0, parabola2); 
		CHECK(point2.X() == 0.0);
		CHECK(point2.Y() == 0.0);
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] AMCAX_API static Point2 D0(double u, const Hyperbola2& hyperbola)	 @return The resulting point
	 @param hyperbola The hyperbola
	 @param u The parameter
	 @brief Compute the point on a 2D hyperbola at a parameter
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
#include <occtio/OCCTTool.hpp>
#include <geometry/MakeArcOfHyperbola2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeEdge2d.hpp>
using namespace AMCAX;
TEST_CASE("case1: CurveCalculation::D0() [5/10] ", "[math][CurveCalculation][P1][D0]") {
	Axis2 majorAxis;
	double major_radius = 5;
	double minor_radius = 3;
	Hyperbola2 hyperbola(majorAxis, major_radius, minor_radius);
	Point2 point2 = CurveCalculation::D0(0.0, hyperbola);
	CHECK(point2.X() == 5.0);
	CHECK(point2.Y() == 0.0);
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] AMCAX_API static Vector3 D1(double u, const Line3& line)	 @return The first derivative vector
	 @param line The line
	 @param u The parameter
	 @brief Compute the first derivative on a 3D line at a parameter
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
#include <occtio/OCCTTool.hpp>
#include <geometry/MakeArcOfHyperbola2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeEdge2d.hpp>
using namespace AMCAX;
TEST_CASE("case1: CurveCalculation::D1() circle3[3/20] ", "[math][CurveCalculation][P1][D1]") {
	Direction3 initialDir(0.0, 0.0, 1.0); 
	Frame3 defaultFrame3(Point3(1.0, 0.0, 0.0), initialDir); 
	double radius = 2.0; 
	AMCAX::Circle3 circle3(defaultFrame3, radius);
	SECTION("u =0") {
		Vector3 vector3 = CurveCalculation::D1(0.0, circle3);
		CHECK(vector3.X() == Approx(0.0));
		CHECK(vector3.Y() == Approx(2.0));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static void D1(double u, const Line3& line, Point3& p, Vector3& v1)	 @param[out] v1 The first derivative
	 @param[out] p The point
	 @param[in] line The line
	 @param[in] u The parameter
	 @brief Compute the point and the first derivative on a 3D line at a parameter
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
#include <occtio/OCCTTool.hpp>
#include <geometry/MakeArcOfHyperbola2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeEdge2d.hpp>
using namespace AMCAX;
TEST_CASE("case1: CurveCalculation::D1() circle3[4/20] ", "[math][CurveCalculation][P1][D1]") {
	Direction3 initialDir(0.0, 0.0, 1.0);
	Frame3 defaultFrame3(Point3(1.0, 1.0, 0.0), initialDir);
	Point3 p;
	Vector3 v;
	double radius = 2.0; 
	AMCAX::Circle3 circle3(defaultFrame3, radius);
	SECTION("u =0") {
		CurveCalculation::D1(0.0, circle3,p,v);
		CHECK(p.X() == 3.0);
		CHECK(p.Y() == 1.0);
		CHECK(p.Z() == 0.0);
		CHECK(v.X() == Approx(0.0));
		CHECK(v.Y() == Approx(2.0));
		CHECK(v.Z() == Approx(0.0));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] AMCAX_API static Vector3 D1(double u, const Circle3& circle)	 @return The first derivative vector
	 @param circle The circle
	 @param u The parameter
	 @brief Compute the first derivative on a 3D circle at a parameter
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
#include <occtio/OCCTTool.hpp>
#include <geometry/MakeArcOfHyperbola2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeEdge2d.hpp>
using namespace AMCAX;
TEST_CASE("case1: CurveCalculation::D1() circle3[3/20] ", "[math][CurveCalculation][P1][D1]") {
	Direction3 initialDir(0.0, 0.0, 1.0); 
	Frame3 defaultFrame3(Point3(1.0, 0.0, 0.0), initialDir); 
	double radius = 2.0; 
	AMCAX::Circle3 circle3(defaultFrame3, radius);
	SECTION("u =0") {
		Vector3 vector3 = CurveCalculation::D1(0.0, circle3);
		CHECK(vector3.X() == Approx(0.0));
		CHECK(vector3.Y() == Approx(2.0));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static void D1(double u, const Circle3& circle, Point3& p, Vector3& v1)	 @param[out] v1 The first derivative
	 @param[out] p The point
	 @param[in] circle The circle
	 @param[in] u The parameter
	 @brief Compute the point and the first derivative on a 3D circle at a parameter
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
#include <occtio/OCCTTool.hpp>
#include <geometry/MakeArcOfHyperbola2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeEdge2d.hpp>
using namespace AMCAX;
TEST_CASE("case1: CurveCalculation::D1() circle3[4/20] ", "[math][CurveCalculation][P1][D1]") {
	Direction3 initialDir(0.0, 0.0, 1.0);
	Frame3 defaultFrame3(Point3(1.0, 1.0, 0.0), initialDir);
	Point3 p;
	Vector3 v;
	double radius = 2.0; 
	AMCAX::Circle3 circle3(defaultFrame3, radius);
	SECTION("u =0") {
		CurveCalculation::D1(0.0, circle3,p,v);
		CHECK(p.X() == 3.0);
		CHECK(p.Y() == 1.0);
		CHECK(p.Z() == 0.0);
		CHECK(v.X() == Approx(0.0));
		CHECK(v.Y() == Approx(2.0));
		CHECK(v.Z() == Approx(0.0));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] AMCAX_API static Vector3 D1(double u, const Ellipse3& ellipse)	 @return The first derivative vector
	 @param ellipse The ellipse
	 @param u The parameter
	 @brief Compute the first derivative on a 3D ellipse at a parameter
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
#include <occtio/OCCTTool.hpp>
#include <geometry/MakeArcOfHyperbola2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeEdge2d.hpp>
using namespace AMCAX;
TEST_CASE("case1: CurveCalculation::D1() circle3[3/20] ", "[math][CurveCalculation][P1][D1]") {
	Direction3 initialDir(0.0, 0.0, 1.0); 
	Frame3 defaultFrame3(Point3(1.0, 0.0, 0.0), initialDir); 
	double radius = 2.0; 
	AMCAX::Circle3 circle3(defaultFrame3, radius);
	SECTION("u =0") {
		Vector3 vector3 = CurveCalculation::D1(0.0, circle3);
		CHECK(vector3.X() == Approx(0.0));
		CHECK(vector3.Y() == Approx(2.0));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static void D1(double u, const Ellipse3& ellipse, Point3& p, Vector3& v1)	 @param[out] v1 The first derivative
	 @param[out] p The point
	 @param[in] ellipse The ellipse
	 @param[in] u The parameter
	 @brief Compute the point and the first derivative on a 3D ellipse at a parameter
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
#include <occtio/OCCTTool.hpp>
#include <geometry/MakeArcOfHyperbola2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeEdge2d.hpp>
using namespace AMCAX;
TEST_CASE("case1: CurveCalculation::D1() ellipse3 [7/20] ", "[math][CurveCalculation][P1][D1]") {
	Direction3 initialDir(0.0, 0.0, 1.0); 
	Frame3 defaultFrame3(Point3(0.0, 0.0, 0.0), initialDir); 
	Ellipse3 ellipse3(defaultFrame3,5.0,3.0 );
	MakeEdge edge= MakeEdge(ellipse3);
	bool bWriteresult = OCCTIO::OCCTTool::Write(edge, OUTPUT_PATH_PREFIX"ellipse3CurveCalculation_case1.brep",true,3);
	SECTION("u =0") {
		Vector3 vector3 = CurveCalculation::D1(0.0, ellipse3);
		CHECK(vector3.X() == Approx(0.0));
		CHECK(vector3.Y() == Approx(3.0));
		CHECK(vector3.Z() == Approx(0.0));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] AMCAX_API static Vector3 D1(double u, const Parabola3& parabola)	 @return The first derivative vector
	 @param parabola The parabola
	 @param u The parameter
	 @brief Compute the first derivative on a 3D parabola at a parameter
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
#include <occtio/OCCTTool.hpp>
#include <geometry/MakeArcOfHyperbola2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeEdge2d.hpp>
using namespace AMCAX;
TEST_CASE("case1: CurveCalculation::D1() ellipse3 [7/20] ", "[math][CurveCalculation][P1][D1]") {
	Direction3 initialDir(0.0, 0.0, 1.0); 
	Frame3 defaultFrame3(Point3(0.0, 0.0, 0.0), initialDir); 
	Ellipse3 ellipse3(defaultFrame3,5.0,3.0 );
	MakeEdge edge= MakeEdge(ellipse3);
	bool bWriteresult = OCCTIO::OCCTTool::Write(edge, OUTPUT_PATH_PREFIX"ellipse3CurveCalculation_case1.brep",true,3);
	SECTION("u = M_PI_2") {
		Vector3 vector3 = CurveCalculation::D1(M_PI_2, ellipse3);
		CHECK(vector3.X() == Approx(-5.0));
		CHECK(vector3.Y() == Approx(0.0).margin(1e-14));
		CHECK(vector3.Z() == Approx(0.0));
	}
}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static void D1(double u, const Parabola3& parabola, Point3& p, Vector3& v1)	 @param[out] v1 The first derivative
	 @param[out] p The point
	 @param[in] parabola The parabola
	 @param[in] u The parameter
	 @brief Compute the point and the first derivative on a 3D parabola at a parameter
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
#include <occtio/OCCTTool.hpp>
#include <geometry/MakeArcOfHyperbola2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeEdge2d.hpp>
using namespace AMCAX;
TEST_CASE("case1: CurveCalculation::D1() ellipse3 [8/20] ", "[math][CurveCalculation][P1][D1]") {
	Direction3 initialDir(0.0, 0.0, 1.0); 
	Frame3 defaultFrame3(Point3(0.0, 0.0, 0.0), initialDir); 
	Ellipse3 ellipse3(defaultFrame3, 5.0, 3.0);
	Point3 p;
	Vector3 v;
	MakeEdge edge = MakeEdge(ellipse3);
	bool bWriteresult = OCCTIO::OCCTTool::Write(edge, OUTPUT_PATH_PREFIX"ellipse3CurveCalculation_case1.brep", true, 3);
	SECTION("u =0") {
		CurveCalculation::D1(0.0, ellipse3,p,v);
		CHECK(p.X() == 5.0);
		CHECK(p.Y() == 0.0);
		CHECK(p.Z() == 0.0);
		CHECK(v.X() == Approx(0.0));
		CHECK(v.Y() == Approx(3.0));
		CHECK(v.Z() == Approx(0.0));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] AMCAX_API static Vector3 D1(double u, const Hyperbola3& hyperbola)	 @return The first derivative vector
	 @param hyperbola The hyperbola
	 @param u The parameter
	 @brief Compute the first derivative on a 3D hyperbola at a parameter
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
#include <occtio/OCCTTool.hpp>
#include <geometry/MakeArcOfHyperbola2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeEdge2d.hpp>
using namespace AMCAX;
TEST_CASE("case1: CurveCalculation::D1() Hyperbola3 [11/20] ", "[math][CurveCalculation][P1][D1]") {
	Direction3 dir3(0.0, 0.0, 1.0);
	Point3 point3(0.0, 0.0, 0.0);
	Frame3 frame3(point3, dir3);
	Hyperbola3 hyperbola3(frame3, 5.0, 3.0); 
	Vector3 vector3 = CurveCalculation::D1(0.0, hyperbola3); 
	CHECK(vector3.X() == 0.0);
	CHECK(vector3.Y() == 3.0);
	CHECK(vector3.Z() == 0.0);
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static void D1(double u, const Hyperbola3& hyperbola, Point3& p, Vector3& v1)	 @param[out] v1 The first derivative
	 @param[out] p The point
	 @param[in] hyperbola The hyperbola
	 @param[in] u The parameter
	 @brief Compute the point and the first derivative on a 3D hyperbola at a parameter
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
#include <occtio/OCCTTool.hpp>
#include <geometry/MakeArcOfHyperbola2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeEdge2d.hpp>
using namespace AMCAX;
TEST_CASE("case1: CurveCalculation::D1() Hyperbola3 [12/20] ", "[math][CurveCalculation][P1][D1]") {
	Direction3 dir3(0.0, 0.0, 1.0);
	Point3 point3(0.0, 0.0, 0.0);
	Frame3 frame3(point3, dir3);
	Hyperbola3 hyperbola3(frame3, 5.0, 3.0); 
	Point3 p;
	Vector3 v;
	CurveCalculation::D1(0.0, hyperbola3,p,v); 
	CHECK(p.X() == 5.0);
	CHECK(p.Y() == 0.0);
	CHECK(p.Z() == 0.0);
	CHECK(v.X() == 0.0);
	CHECK(v.Y() == 3.0);
	CHECK(v.Z() == 0.0);
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] AMCAX_API static Vector2 D1(double u, const Line2& line)	 @return The first derivative vector
	 @param line The line
	 @param u The parameter
	 @brief Compute the first derivative on a 2D line at a parameter
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
#include <occtio/OCCTTool.hpp>
#include <geometry/MakeArcOfHyperbola2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeEdge2d.hpp>
using namespace AMCAX;
TEST_CASE("case1: CurveCalculation::D1() circle2[1/20] ", "[math][CurveCalculation][P1][D1]") {
	Direction2 initialDir(1.0, 0.0); 
	Frame2 defaultFrame2(Point2(1.0, 1.0), initialDir); 
    double radius = 2.0;
    AMCAX::Circle2 circle2(defaultFrame2,radius);
	SECTION("u =0") {
		Vector2 vector2 = CurveCalculation::D1(0.0, circle2);
		CHECK(vector2.X() == Approx(-0.0));
		CHECK(vector2.Y() == 2.0);
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static void D1(double u, const Line2& line, Point2& p, Vector2& v1)	 @param[out] v1 The first derivative
	 @param[out] p The point
	 @param[in] line The line
	 @param[in] u The parameter
	 @brief Compute the point and the first derivative on a 2D line at a parameter
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
#include <occtio/OCCTTool.hpp>
#include <geometry/MakeArcOfHyperbola2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeEdge2d.hpp>
using namespace AMCAX;
TEST_CASE("case1: CurveCalculation::D1() circle2[2/20] ", "[math][CurveCalculation][P1][D1]") {
	Direction2 initialDir(1.0, 0.0); 
	Frame2 defaultFrame2(Point2(1.0, 1.0), initialDir); 
	double radius = 2.0;
	AMCAX::Circle2 circle2(defaultFrame2, radius);
	Point2 p;
	Vector2 v;
	SECTION("u =0") {
		CurveCalculation::D1(0.0, circle2,p,v);
		CHECK(p.X() == 3.0);
		CHECK(p.Y() == 1.0);
		CHECK(v.X() == Approx(0.0));
		CHECK(v.Y() == Approx(2.0));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] AMCAX_API static Vector2 D1(double u, const Circle2& circle)	 @return The first derivative vector
	 @param circle The circle
	 @param u The parameter
	 @brief Compute the first derivative on a 2D circle at a parameter
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
#include <occtio/OCCTTool.hpp>
#include <geometry/MakeArcOfHyperbola2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeEdge2d.hpp>
using namespace AMCAX;
TEST_CASE("case1: CurveCalculation::D1() circle2[1/20] ", "[math][CurveCalculation][P1][D1]") {
	Direction2 initialDir(1.0, 0.0); 
	Frame2 defaultFrame2(Point2(1.0, 1.0), initialDir); 
    double radius = 2.0;
    AMCAX::Circle2 circle2(defaultFrame2,radius);
	SECTION("u =0") {
		Vector2 vector2 = CurveCalculation::D1(0.0, circle2);
		CHECK(vector2.X() == Approx(-0.0));
		CHECK(vector2.Y() == 2.0);
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static void D1(double u, const Circle2& circle, Point2& p, Vector2& v1)	 @param[out] v1 The first derivative
	 @param[out] p The point
	 @param[in] circle The circle
	 @param[in] u The parameter
	 @brief Compute the point and the first derivative on a 2D circle at a parameter
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
#include <occtio/OCCTTool.hpp>
#include <geometry/MakeArcOfHyperbola2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeEdge2d.hpp>
using namespace AMCAX;
TEST_CASE("case1: CurveCalculation::D1() circle2[1/20] ", "[math][CurveCalculation][P1][D1]") {
	Direction2 initialDir(1.0, 0.0); 
	Frame2 defaultFrame2(Point2(1.0, 1.0), initialDir); 
    double radius = 2.0;
    AMCAX::Circle2 circle2(defaultFrame2,radius);
	SECTION("u = M_PI") {
		Vector2 vector2 = CurveCalculation::D1(M_PI, circle2);
		CHECK(vector2.X() == Approx(-0.0).margin(1e-12));
		CHECK(vector2.Y() == -2.0);
	}
}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] AMCAX_API static Vector2 D1(double u, const Ellipse2& ellipse)	 @return The first derivative vector
	 @param ellipse The ellipse
	 @param u The parameter
	 @brief Compute the first derivative on a 2D ellipse at a parameter
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
#include <occtio/OCCTTool.hpp>
#include <geometry/MakeArcOfHyperbola2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeEdge2d.hpp>
using namespace AMCAX;
TEST_CASE("case1: CurveCalculation::D1() circle2[1/20] ", "[math][CurveCalculation][P1][D1]") {
	Direction2 initialDir(1.0, 0.0); 
	Frame2 defaultFrame2(Point2(1.0, 1.0), initialDir); 
    double radius = 2.0;
    AMCAX::Circle2 circle2(defaultFrame2,radius);
	SECTION("u = M_PI") {
		Vector2 vector2 = CurveCalculation::D1(M_PI, circle2);
		CHECK(vector2.X() == Approx(-0.0).margin(1e-12));
		CHECK(vector2.Y() == -2.0);
	}
}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static void D1(double u, const Ellipse2& ellipse, Point2& p, Vector2& v1)	 @param[out] v1 The first derivative
	 @param[out] p The point
	 @param[in] ellipse The ellipse
	 @param[in] u The parameter
	 @brief Compute the point and the first derivative on a 2D ellipse at a parameter
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
#include <occtio/OCCTTool.hpp>
#include <geometry/MakeArcOfHyperbola2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeEdge2d.hpp>
using namespace AMCAX;
TEST_CASE("case1: CurveCalculation::D1() circle2[2/20] ", "[math][CurveCalculation][P1][D1]") {
	Direction2 initialDir(1.0, 0.0); 
	Frame2 defaultFrame2(Point2(1.0, 1.0), initialDir); 
	double radius = 2.0;
	AMCAX::Circle2 circle2(defaultFrame2, radius);
	Point2 p;
	Vector2 v;
	SECTION("u =0") {
		CurveCalculation::D1(0.0, circle2,p,v);
		CHECK(p.X() == 3.0);
		CHECK(p.Y() == 1.0);
		CHECK(v.X() == Approx(0.0));
		CHECK(v.Y() == Approx(2.0));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] AMCAX_API static Vector2 D1(double u, const Parabola2& parabola)	 @return The first derivative vector
	 @param parabola The parabola
	 @param u The parameter
	 @brief Compute the first derivative on a 2D parabola at a parameter
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
#include <occtio/OCCTTool.hpp>
#include <geometry/MakeArcOfHyperbola2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeEdge2d.hpp>
using namespace AMCAX;
TEST_CASE("case1: CurveCalculation::D1() circle2[1/20] ", "[math][CurveCalculation][P1][D1]") {
	Direction2 initialDir(1.0, 0.0); 
	Frame2 defaultFrame2(Point2(1.0, 1.0), initialDir); 
    double radius = 2.0;
    AMCAX::Circle2 circle2(defaultFrame2,radius);
	SECTION("u = M_PI") {
		Vector2 vector2 = CurveCalculation::D1(M_PI, circle2);
		CHECK(vector2.X() == Approx(-0.0).margin(1e-12));
		CHECK(vector2.Y() == -2.0);
	}
}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static void D1(double u, const Parabola2& parabola, Point2& p, Vector2& v1)	 @param[out] v1 The first derivative
	 @param[out] p The point
	 @param[in] parabola The parabola
	 @param[in] u The parameter
	 @brief Compute the point and the first derivative on a 2D parabola at a parameter
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
#include <occtio/OCCTTool.hpp>
#include <geometry/MakeArcOfHyperbola2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeEdge2d.hpp>
using namespace AMCAX;
TEST_CASE("case1: CurveCalculation::D1() ellipse3 [8/20] ", "[math][CurveCalculation][P1][D1]") {
	Direction3 initialDir(0.0, 0.0, 1.0); 
	Frame3 defaultFrame3(Point3(0.0, 0.0, 0.0), initialDir); 
	Ellipse3 ellipse3(defaultFrame3, 5.0, 3.0);
	Point3 p;
	Vector3 v;
	MakeEdge edge = MakeEdge(ellipse3);
	bool bWriteresult = OCCTIO::OCCTTool::Write(edge, OUTPUT_PATH_PREFIX"ellipse3CurveCalculation_case1.brep", true, 3);
	SECTION("u = M_PI_2") {
		CurveCalculation::D1(M_PI_2, ellipse3,p,v);
		CHECK(p.X() == Approx(0.0).margin(1e-12));
		CHECK(p.Y() == 3.0);
		CHECK(p.Z() == 0.0);
		CHECK(v.X() == Approx(-5.0));
		CHECK(v.Y() == Approx(0.0).margin(1e-14));
		CHECK(v.Z() == Approx(0.0));
	}
}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] AMCAX_API static Vector2 D1(double u, const Hyperbola2& hyperbola)	 @return The first derivative vector
	 @param hyperbola The hyperbola
	 @param u The parameter
	 @brief Compute the first derivative on a 2D hyperbola at a parameter
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
#include <occtio/OCCTTool.hpp>
#include <geometry/MakeArcOfHyperbola2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeEdge2d.hpp>
using namespace AMCAX;
TEST_CASE("case1: CurveCalculation::D1() Hyperbola2 [9/20] ", "[math][CurveCalculation][P1][D1]") {
	Axis2 majorAxis;
	double major_radius = 5;
	double minor_radius = 3;
	Hyperbola2 hyperbola2(majorAxis, major_radius, minor_radius); 
	 Vector2 vector2 = CurveCalculation::D1(0.0, hyperbola2); 
	CHECK(vector2.X() == 0.0);
	CHECK(vector2.Y() == 3.0);
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static void D1(double u, const Hyperbola2& hyperbola, Point2& p, Vector2& v1)	 @param[out] v1 The first derivative
	 @param[out] p The point
	 @param[in] hyperbola The hyperbola
	 @param[in] u The parameter
	 @brief Compute the point and the first derivative on a 2D hyperbola at a parameter
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
#include <occtio/OCCTTool.hpp>
#include <geometry/MakeArcOfHyperbola2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeEdge2d.hpp>
using namespace AMCAX;
TEST_CASE("case1: CurveCalculation::D1() Hyperbola2 [10/20] ", "[math][CurveCalculation][P1][D1]") {
	Axis2 majorAxis;
	double major_radius = 5;
	double minor_radius = 3;
	Hyperbola2 hyperbola2(majorAxis, major_radius, minor_radius); 
	Point2 p;
	Vector2 v;
	CurveCalculation::D1(0.0, hyperbola2,p,v); 
	CHECK(p.X() == 5.0);
	CHECK(p.Y() == 0.0);
	CHECK(v.X() == 0.0);
	CHECK(v.Y() == 3.0);
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] AMCAX_API static Vector3 D2(double u, const Line3& line)	 @return The second derivative vector
	 @param line The line
	 @param u The parameter
	 @brief Compute the second derivative on a 3D line at a parameter
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
#include <occtio/OCCTTool.hpp>
#include <geometry/MakeArcOfHyperbola2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeEdge2d.hpp>
using namespace AMCAX;
TEST_CASE("case1: CurveCalculation::D2() circle3[3/20] ", "[math][CurveCalculation][P1][D2]") {
	Direction3 initialDir(0.0, 0.0, 1.0); 
	Frame3 defaultFrame3(Point3(1.0, 0.0, 0.0), initialDir); 
	double radius = 2.0; 
	AMCAX::Circle3 circle3(defaultFrame3, radius);
	SECTION("u =0") {
		Vector3 vector3 = CurveCalculation::D2(0.0, circle3);
		CHECK(vector3.X() == -2.0 );
		CHECK(vector3.Y() == 0.0 );
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static void D2(double u, const Line3& line, Point3& p, Vector3& v1, Vector3& v2)	 @param[out] v2 The second derivative
	 @param[out] v1 The first derivative
	 @param[out] p The point
	 @param[in] line The line
	 @param[in] u The parameter
	 @brief Compute the point and the first two derivatives on a 3D line at a parameter
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
#include <occtio/OCCTTool.hpp>
#include <geometry/MakeArcOfHyperbola2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeEdge2d.hpp>
using namespace AMCAX;
TEST_CASE("case1: CurveCalculation::D2() circle3[4/20] ", "[math][CurveCalculation][P1][D2]") {
	Direction3 initialDir(0.0, 0.0, 1.0);
	Frame3 defaultFrame3(Point3(1.0, 1.0, 0.0), initialDir);
	double radius = 2.0; 
	AMCAX::Circle3 circle3(defaultFrame3, radius);
	Point3 p;
	Vector3 v1, v2;
	SECTION("u =0") {
		CurveCalculation::D2(0.0, circle3, p, v1,v2);
		CHECK(p.X() == 3.0);
		CHECK(p.Y() == 1.0);
		CHECK(p.Z() == 0.0);
		CHECK(v1.X() == Approx(0.0));
		CHECK(v1.Y() == Approx(2.0));
		CHECK(v1.Z() == Approx(0.0));
		CHECK(v2.X() == Approx(-2.0));
		CHECK(v2.Y() == Approx(0.0));
		CHECK(v2.Z() == Approx(0.0));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] AMCAX_API static Vector3 D2(double u, const Circle3& circle)	 @return The second derivative vector
	 @param circle The circle
	 @param u The parameter
	 @brief Compute the second derivative on a 3D circle at a parameter
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
#include <occtio/OCCTTool.hpp>
#include <geometry/MakeArcOfHyperbola2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeEdge2d.hpp>
using namespace AMCAX;
TEST_CASE("case1: CurveCalculation::D2() circle3[3/20] ", "[math][CurveCalculation][P1][D2]") {
	Direction3 initialDir(0.0, 0.0, 1.0); 
	Frame3 defaultFrame3(Point3(1.0, 0.0, 0.0), initialDir); 
	double radius = 2.0; 
	AMCAX::Circle3 circle3(defaultFrame3, radius);
	SECTION("u =0") {
		Vector3 vector3 = CurveCalculation::D2(0.0, circle3);
		CHECK(vector3.X() == -2.0 );
		CHECK(vector3.Y() == 0.0 );
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static void D2(double u, const Circle3& circle, Point3& p, Vector3& v1, Vector3& v2)	 @param[out] v2 The second derivative
	 @param[out] v1 The first derivative
	 @param[out] p The point
	 @param[in] circle The circle
	 @param[in] u The parameter
	 @brief Compute the point and the first two derivatives on a 3D circle at a parameter
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
#include <occtio/OCCTTool.hpp>
#include <geometry/MakeArcOfHyperbola2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeEdge2d.hpp>
using namespace AMCAX;
TEST_CASE("case1: CurveCalculation::D2() circle3[4/20] ", "[math][CurveCalculation][P1][D2]") {
	Direction3 initialDir(0.0, 0.0, 1.0);
	Frame3 defaultFrame3(Point3(1.0, 1.0, 0.0), initialDir);
	double radius = 2.0; 
	AMCAX::Circle3 circle3(defaultFrame3, radius);
	Point3 p;
	Vector3 v1, v2;
	SECTION("u =0") {
		CurveCalculation::D2(0.0, circle3, p, v1,v2);
		CHECK(p.X() == 3.0);
		CHECK(p.Y() == 1.0);
		CHECK(p.Z() == 0.0);
		CHECK(v1.X() == Approx(0.0));
		CHECK(v1.Y() == Approx(2.0));
		CHECK(v1.Z() == Approx(0.0));
		CHECK(v2.X() == Approx(-2.0));
		CHECK(v2.Y() == Approx(0.0));
		CHECK(v2.Z() == Approx(0.0));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] AMCAX_API static Vector3 D2(double u, const Ellipse3& ellipse)	 @return The second derivative vector
	 @param ellipse The ellipse
	 @param u The parameter
	 @brief Compute the second derivative on a 3D ellipse at a parameter
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
#include <occtio/OCCTTool.hpp>
#include <geometry/MakeArcOfHyperbola2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeEdge2d.hpp>
using namespace AMCAX;
TEST_CASE("case1: CurveCalculation::D2() ellipse3[7/20] ", "[math][CurveCalculation][P1][D2]") {
	Direction3 initialDir(0.0, 0.0, 1.0); 
	Frame3 defaultFrame3(Point3(0.0, 0.0, 0.0), initialDir); 
	Ellipse3 ellipse3(defaultFrame3, 5.0, 3.0);
	SECTION("u =0") {
		Vector3 vector3 = CurveCalculation::D2(0.0, ellipse3);
		CHECK(vector3.X() == Approx(-5.0));
		CHECK(vector3.Y() == Approx(0.0));
		CHECK(vector3.Z() == Approx(0.0));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static void D2(double u, const Ellipse3& ellipse, Point3& p, Vector3& v1, Vector3& v2)	 @param[out] v2 The second derivative
	 @param[out] v1 The first derivative
	 @param[out] p The point
	 @param[in] ellipse The ellipse
	 @param[in] u The parameter
	 @brief Compute the point and the first two derivatives on a 3D ellipse at a parameter
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
#include <occtio/OCCTTool.hpp>
#include <geometry/MakeArcOfHyperbola2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeEdge2d.hpp>
using namespace AMCAX;
TEST_CASE("case1: CurveCalculation::D2() circle3[4/20] ", "[math][CurveCalculation][P1][D2]") {
	Direction3 initialDir(0.0, 0.0, 1.0);
	Frame3 defaultFrame3(Point3(1.0, 1.0, 0.0), initialDir);
	double radius = 2.0; 
	AMCAX::Circle3 circle3(defaultFrame3, radius);
	Point3 p;
	Vector3 v1, v2;
	SECTION("u =0") {
		CurveCalculation::D2(0.0, circle3, p, v1,v2);
		CHECK(p.X() == 3.0);
		CHECK(p.Y() == 1.0);
		CHECK(p.Z() == 0.0);
		CHECK(v1.X() == Approx(0.0));
		CHECK(v1.Y() == Approx(2.0));
		CHECK(v1.Z() == Approx(0.0));
		CHECK(v2.X() == Approx(-2.0));
		CHECK(v2.Y() == Approx(0.0));
		CHECK(v2.Z() == Approx(0.0));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] AMCAX_API static Vector3 D2(double u, const Parabola3& parabola)	 @return The second derivative vector
	 @param parabola The parabola
	 @param u The parameter
	 @brief Compute the second derivative on a 3D parabola at a parameter
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
#include <occtio/OCCTTool.hpp>
#include <geometry/MakeArcOfHyperbola2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeEdge2d.hpp>
using namespace AMCAX;
TEST_CASE("case1: CurveCalculation::D2() parabola2 [19/20] ", "[math][CurveCalculation][P1][D2]") {
	Point3 point3(0.0, 0.0, 0.0);
	Direction3 dir3(0.0, 0.0, 1.0);
	Frame3 fram3(point3, dir3);
	double focal = 2.0;
	Parabola3 parabola3(fram3, focal);
	SECTION("u =0") {
		Vector3 vector3 = CurveCalculation::D2(0.0, parabola3);
		CHECK(vector3.X() == 0.25);
		CHECK(vector3.Y() == 0.0);
		CHECK(vector3.Z() == 0.0);
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static void D2(double u, const Parabola3& parabola, Point3& p, Vector3& v1, Vector3& v2)	 @param[out] v2 The second derivative
	 @param[out] v1 The first derivative
	 @param[out] p The point
	 @param[in] parabola The parabola
	 @param[in] u The parameter
	 @brief Compute the point and the first two derivatives on a 3D parabola at a parameter
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
#include <occtio/OCCTTool.hpp>
#include <geometry/MakeArcOfHyperbola2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeEdge2d.hpp>
using namespace AMCAX;
TEST_CASE("case1: CurveCalculation::D2() parabola2 [19/20] ", "[math][CurveCalculation][P1][D2]") {
	Point3 point3(0.0, 0.0, 0.0);
	Direction3 dir3(0.0, 0.0, 1.0);
	Frame3 fram3(point3, dir3);
	double focal = 2.0;
	Parabola3 parabola3(fram3, focal);
	SECTION("u =0") {
		Vector3 vector3 = CurveCalculation::D2(0.0, parabola3);
		CHECK(vector3.X() == 0.25);
		CHECK(vector3.Y() == 0.0);
		CHECK(vector3.Z() == 0.0);
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] AMCAX_API static Vector3 D2(double u, const Hyperbola3& hyperbola)	 @return The second derivative vector
	 @param hyperbola The hyperbola
	 @param u The parameter
	 @brief Compute the second derivative on a 3D hyperbola at a parameter
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
#include <occtio/OCCTTool.hpp>
#include <geometry/MakeArcOfHyperbola2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeEdge2d.hpp>
using namespace AMCAX;
TEST_CASE("case1: CurveCalculation::D2() hyperbola3[11/20] ", "[math][CurveCalculation][P1][D2]") {
	Direction3 dir3(0.0, 0.0, 1.0);
	Point3 point3(0.0, 0.0, 0.0);
	Frame3 frame3(point3, dir3);
	Hyperbola3 hyperbola3(frame3, 5.0, 3.0); 
	Vector3 vector3 = CurveCalculation::D2(0.0, hyperbola3); 
	CHECK(vector3.X() == 5.0);
	CHECK(vector3.Y() == 0.0);
	CHECK(vector3.Z() == 0.0);
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static void D2(double u, const Hyperbola3& hyperbola, Point3& p, Vector3& v1, Vector3& v2)	 @param[out] v2 The second derivative
	 @param[out] v1 The first derivative
	 @param[out] p The point
	 @param[in] hyperbola The hyperbola
	 @param[in] u The parameter
	 @brief Compute the point and the first two derivatives on a 3D hyperbola at a parameter
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
#include <occtio/OCCTTool.hpp>
#include <geometry/MakeArcOfHyperbola2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeEdge2d.hpp>
using namespace AMCAX;
TEST_CASE("case1: CurveCalculation::D2() hyperbola3[11/20] ", "[math][CurveCalculation][P1][D2]") {
	Direction3 dir3(0.0, 0.0, 1.0);
	Point3 point3(0.0, 0.0, 0.0);
	Frame3 frame3(point3, dir3);
	Hyperbola3 hyperbola3(frame3, 5.0, 3.0); 
	Vector3 vector3 = CurveCalculation::D2(0.0, hyperbola3); 
	CHECK(vector3.X() == 5.0);
	CHECK(vector3.Y() == 0.0);
	CHECK(vector3.Z() == 0.0);
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] AMCAX_API static Vector2 D2(double u, const Line2& line)	 @return The second derivative vector
	 @param line The line
	 @param u The parameter
	 @brief Compute the second derivative on a 2D line at a parameter
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
#include <occtio/OCCTTool.hpp>
#include <geometry/MakeArcOfHyperbola2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeEdge2d.hpp>
using namespace AMCAX;
TEST_CASE("case1: CurveCalculation::D2() circle2[1/20] ", "[math][CurveCalculation][P1][D2]") {
	Direction2 initialDir(1.0, 0.0); 
	Frame2 defaultFrame2(Point2(1.0, 1.0), initialDir); 
	double radius = 2.0;
	AMCAX::Circle2 circle2(defaultFrame2, radius);
	SECTION("u =0") {
		Vector2 vector2 = CurveCalculation::D2(0.0, circle2);
		CHECK(vector2.X() == -2.0);
		CHECK(vector2.Y() == 0.0);
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static void D2(double u, const Line2& line, Point2& p, Vector2& v1, Vector2& v2)	 @param[out] v2 The second derivative
	 @param[out] v1 The first derivative
	 @param[out] p The point
	 @param[in] line The line
	 @param[in] u The parameter
	 @brief Compute the point and the first two derivatives on a 2D line at a parameter
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
#include <occtio/OCCTTool.hpp>
#include <geometry/MakeArcOfHyperbola2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeEdge2d.hpp>
using namespace AMCAX;
TEST_CASE("case1: CurveCalculation::D2() circle2[2/20] ", "[math][CurveCalculation][P1][D2]") {
	Direction2 initialDir(1.0, 0.0); 
	Frame2 defaultFrame2(Point2(1.0, 1.0), initialDir); 
	double radius = 2.0;
	AMCAX::Circle2 circle2(defaultFrame2, radius);
	Point2 p;
	Vector2 v1,v2;
	SECTION("u =0") {
		CurveCalculation::D2(0.0, circle2, p, v1,v2);
		CHECK(p.X() == 3.0);
		CHECK(p.Y() == 1.0);
		CHECK(v1.X() == 0.0);
		CHECK(v1.Y() == 2.0);
		CHECK(v2.X() == -2.0);
		CHECK(v2.Y() == 0.0);
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] AMCAX_API static Vector2 D2(double u, const Circle2& circle)	 @return The second derivative vector
	 @param circle The circle
	 @param u The parameter
	 @brief Compute the second derivative on a 2D circle at a parameter
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
#include <occtio/OCCTTool.hpp>
#include <geometry/MakeArcOfHyperbola2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeEdge2d.hpp>
using namespace AMCAX;
TEST_CASE("case1: CurveCalculation::D2() circle2[1/20] ", "[math][CurveCalculation][P1][D2]") {
	Direction2 initialDir(1.0, 0.0); 
	Frame2 defaultFrame2(Point2(1.0, 1.0), initialDir); 
	double radius = 2.0;
	AMCAX::Circle2 circle2(defaultFrame2, radius);
	SECTION("u =0") {
		Vector2 vector2 = CurveCalculation::D2(0.0, circle2);
		CHECK(vector2.X() == -2.0);
		CHECK(vector2.Y() == 0.0);
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static void D2(double u, const Circle2& circle, Point2& p, Vector2& v1, Vector2& v2)	 @param[out] v2 The second derivative
	 @param[out] v1 The first derivative
	 @param[out] p The point
	 @param[in] circle The circle
	 @param[in] u The parameter
	 @brief Compute the point and the first two derivatives on a 2D circle at a parameter
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
#include <occtio/OCCTTool.hpp>
#include <geometry/MakeArcOfHyperbola2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeEdge2d.hpp>
using namespace AMCAX;
TEST_CASE("case1: CurveCalculation::D2() circle2[1/20] ", "[math][CurveCalculation][P1][D2]") {
	Direction2 initialDir(1.0, 0.0); 
	Frame2 defaultFrame2(Point2(1.0, 1.0), initialDir); 
	double radius = 2.0;
	AMCAX::Circle2 circle2(defaultFrame2, radius);
	SECTION("u =0") {
		Vector2 vector2 = CurveCalculation::D2(0.0, circle2);
		CHECK(vector2.X() == -2.0);
		CHECK(vector2.Y() == 0.0);
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] AMCAX_API static Vector2 D2(double u, const Ellipse2& ellipse)	 @return The second derivative vector
	 @param ellipse The ellipse
	 @param u The parameter
	 @brief Compute the second derivative on a 2D ellipse at a parameter
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
#include <occtio/OCCTTool.hpp>
#include <geometry/MakeArcOfHyperbola2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeEdge2d.hpp>
using namespace AMCAX;
TEST_CASE("case1: CurveCalculation::D2() circle2[1/20] ", "[math][CurveCalculation][P1][D2]") {
	Direction2 initialDir(1.0, 0.0); 
	Frame2 defaultFrame2(Point2(1.0, 1.0), initialDir); 
	double radius = 2.0;
	AMCAX::Circle2 circle2(defaultFrame2, radius);
	SECTION("u =0") {
		Vector2 vector2 = CurveCalculation::D2(0.0, circle2);
		CHECK(vector2.X() == -2.0);
		CHECK(vector2.Y() == 0.0);
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static void D2(double u, const Ellipse2& ellipse, Point2& p, Vector2& v1, Vector2& v2)	 @param[out] v2 The second derivative
	 @param[out] v1 The first derivative
	 @param[out] p The point
	 @param[in] ellipse The ellipse
	 @param[in] u The parameter
	 @brief Compute the point and the first two derivatives on a 2D ellipse at a parameter
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
#include <occtio/OCCTTool.hpp>
#include <geometry/MakeArcOfHyperbola2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeEdge2d.hpp>
using namespace AMCAX;
TEST_CASE("case1: CurveCalculation::D2() circle2[2/20] ", "[math][CurveCalculation][P1][D2]") {
	Direction2 initialDir(1.0, 0.0); 
	Frame2 defaultFrame2(Point2(1.0, 1.0), initialDir); 
	double radius = 2.0;
	AMCAX::Circle2 circle2(defaultFrame2, radius);
	Point2 p;
	Vector2 v1,v2;
	SECTION("u =0") {
		CurveCalculation::D2(0.0, circle2, p, v1,v2);
		CHECK(p.X() == 3.0);
		CHECK(p.Y() == 1.0);
		CHECK(v1.X() == 0.0);
		CHECK(v1.Y() == 2.0);
		CHECK(v2.X() == -2.0);
		CHECK(v2.Y() == 0.0);
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] AMCAX_API static Vector2 D2(double u, const Parabola2& parabola)	 @return The second derivative vector
	 @param parabola The parabola
	 @param u The parameter
	 @brief Compute the second derivative on a 2D parabola at a parameter
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
#include <occtio/OCCTTool.hpp>
#include <geometry/MakeArcOfHyperbola2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeEdge2d.hpp>
using namespace AMCAX;
TEST_CASE("case1: CurveCalculation::D2() circle2[1/20] ", "[math][CurveCalculation][P1][D2]") {
	Direction2 initialDir(1.0, 0.0); 
	Frame2 defaultFrame2(Point2(1.0, 1.0), initialDir); 
	double radius = 2.0;
	AMCAX::Circle2 circle2(defaultFrame2, radius);
	SECTION("u =0") {
		Vector2 vector2 = CurveCalculation::D2(0.0, circle2);
		CHECK(vector2.X() == -2.0);
		CHECK(vector2.Y() == 0.0);
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static void D2(double u, const Parabola2& parabola, Point2& p, Vector2& v1, Vector2& v2)	 @param[out] v2 The second derivative
	 @param[out] v1 The first derivative
	 @param[out] p The point
	 @param[in] parabola The parabola
	 @param[in] u The parameter
	 @brief Compute the point and the first two derivatives on a 2D parabola at a parameter
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
#include <occtio/OCCTTool.hpp>
#include <geometry/MakeArcOfHyperbola2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeEdge2d.hpp>
using namespace AMCAX;
TEST_CASE("case1: CurveCalculation::D2() parabola2 [18/20] ", "[math][CurveCalculation][P1][D2][kk]") {
	AMCAX::Point2 P(0.0, 0.0);
	AMCAX::Direction2 D(1.0, 0.0); 
	AMCAX::Axis2  axis2(P, D);
	double focal = 2.0;
	AMCAX::Parabola2 parabola2(axis2, focal);
	Point2 p;
	Vector2 v1,v2;
	SECTION("u =0") {
		CurveCalculation::D2(0.0, parabola2, p, v1,v2);
		CHECK(p.X() == 0.0);
		CHECK(p.Y() == 0.0);
		CHECK(v1.X() == 0.0);
		CHECK(v1.Y() == 1.0);
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] AMCAX_API static Vector2 D2(double u, const Hyperbola2& hyperbola)	 @return The second derivative vector
	 @param hyperbola The hyperbola
	 @param u The parameter
	 @brief Compute the second derivative on a 2D hyperbola at a parameter
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
#include <occtio/OCCTTool.hpp>
#include <geometry/MakeArcOfHyperbola2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeEdge2d.hpp>
using namespace AMCAX;
TEST_CASE("case1: CurveCalculation::D2() hyperbola2[9/20] ", "[math][CurveCalculation][P1][D2]") {
	Axis2 majorAxis;
	double major_radius = 5;
	double minor_radius = 3;
	Hyperbola2 hyperbola2(majorAxis, major_radius, minor_radius); 
	Vector2 vector2 = CurveCalculation::D2(0.0, hyperbola2); 
	CHECK(vector2.X() == 5.0);
	CHECK(vector2.Y() == 0.0);
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static void D2(double u, const Hyperbola2& hyperbola, Point2& p, Vector2& v1, Vector2& v2)	 @param[out] v2 The second derivative
	 @param[out] v1 The first derivative
	 @param[out] p The point
	 @param[in] hyperbola The hyperbola
	 @param[in] u The parameter
	 @brief Compute the point and the first two derivatives on a 2D hyperbola at a parameter
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
#include <occtio/OCCTTool.hpp>
#include <geometry/MakeArcOfHyperbola2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeEdge2d.hpp>
using namespace AMCAX;
TEST_CASE("case1: CurveCalculation::D2() hyperbola2[10/20] ", "[math][CurveCalculation][P1][D2]") {
	Axis2 majorAxis;
	double major_radius = 5;
	double minor_radius = 3;
	Hyperbola2 hyperbola2(majorAxis, major_radius, minor_radius); 
	Point2 p;
	Vector2 v1,v2;
	CurveCalculation::D2(0.0, hyperbola2, p, v1,v2); 
	CHECK(p.X() == 5.0);
	CHECK(p.Y() == 0.0);
	CHECK(v1.X() == 0.0);
	CHECK(v1.Y() == 3.0);
	CHECK(v2.X() == 5.0);
	CHECK(v2.Y() == 0.0);
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] AMCAX_API static Vector3 D3(double u, const Line3& line)	 @return The third derivative vector
	 @param line The line
	 @param u The parameter
	 @brief Compute the third derivative on a 3D line at a parameter
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
#include <occtio/OCCTTool.hpp>
#include <geometry/MakeArcOfHyperbola2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeEdge2d.hpp>
using namespace AMCAX;
TEST_CASE("case1: CurveCalculation::D3() circle3[3/20] ", "[math][CurveCalculation][P1][D3]") {
	Direction3 initialDir(0.0, 0.0, 1.0); 
	Frame3 defaultFrame3(Point3(1.0, 0.0, 0.0), initialDir); 
	double radius = 2.0; 
	AMCAX::Circle3 circle3(defaultFrame3, radius);
	SECTION("u =0") {
		Vector3 vector3 = CurveCalculation::D3(0.0, circle3);
		CHECK(vector3.X() == 0.0);
		CHECK(vector3.Y() == -2.0);
		CHECK(vector3.Z() == 0.0);
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static void D3(double u, const Line3& line, Point3& p, Vector3& v1, Vector3& v2, Vector3& v3)	 @param[out] v3 The third derivative
	 @param[out] v2 The second derivative
	 @param[out] v1 The first derivative
	 @param[out] p The point
	 @param[in] line The line
	 @param[in] u The parameter
	 @brief Compute the point and the first three derivatives on a 3D line at a parameter
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
#include <occtio/OCCTTool.hpp>
#include <geometry/MakeArcOfHyperbola2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeEdge2d.hpp>
using namespace AMCAX;
TEST_CASE("case1: CurveCalculation::D3() circle3[4/20] ", "[math][CurveCalculation][P1][D3]") {
	Direction3 initialDir(0.0, 0.0, 1.0);
	Frame3 defaultFrame3(Point3(1.0, 1.0, 0.0), initialDir);
	double radius = 2.0; 
	AMCAX::Circle3 circle3(defaultFrame3, radius);
	Point3 p;
	Vector3 v1, v2,v3;
	SECTION("u =0") {
		CurveCalculation::D3(0.0, circle3, p, v1, v2,v3);
		CHECK(p.X() == 3.0);
		CHECK(p.Y() == 1.0);
		CHECK(p.Z() == 0.0);
		CHECK(v1.X() == Approx(0.0));
		CHECK(v1.Y() == Approx(2.0));
		CHECK(v1.Z() == Approx(0.0));
		CHECK(v2.X() == Approx(-2.0));
		CHECK(v2.Y() == Approx(0.0));
		CHECK(v2.Z() == Approx(0.0));
		CHECK(v3.X() == Approx(0.0));
		CHECK(v3.Y() == Approx(-2.0));
		CHECK(v3.Z() == Approx(0.0));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] AMCAX_API static Vector3 D3(double u, const Circle3& circle)	 @return The third derivative vector
	 @param circle The circle
	 @param u The parameter
	 @brief Compute the third derivative on a 3D circle at a parameter
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
#include <occtio/OCCTTool.hpp>
#include <geometry/MakeArcOfHyperbola2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeEdge2d.hpp>
using namespace AMCAX;
TEST_CASE("case1: CurveCalculation::D3() circle3[3/20] ", "[math][CurveCalculation][P1][D3]") {
	Direction3 initialDir(0.0, 0.0, 1.0); 
	Frame3 defaultFrame3(Point3(1.0, 0.0, 0.0), initialDir); 
	double radius = 2.0; 
	AMCAX::Circle3 circle3(defaultFrame3, radius);
	SECTION("u =0") {
		Vector3 vector3 = CurveCalculation::D3(0.0, circle3);
		CHECK(vector3.X() == 0.0);
		CHECK(vector3.Y() == -2.0);
		CHECK(vector3.Z() == 0.0);
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static void D3(double u, const Circle3& circle, Point3& p, Vector3& v1, Vector3& v2, Vector3& v3)	 @param[out] v3 The third derivative
	 @param[out] v2 The second derivative
	 @param[out] v1 The first derivative
	 @param[out] p The point
	 @param[in] circle The circle
	 @param[in] u The parameter
	 @brief Compute the point and the first three derivatives on a 3D circle at a parameter
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
#include <occtio/OCCTTool.hpp>
#include <geometry/MakeArcOfHyperbola2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeEdge2d.hpp>
using namespace AMCAX;
TEST_CASE("case1: CurveCalculation::D3() circle3[4/20] ", "[math][CurveCalculation][P1][D3]") {
	Direction3 initialDir(0.0, 0.0, 1.0);
	Frame3 defaultFrame3(Point3(1.0, 1.0, 0.0), initialDir);
	double radius = 2.0; 
	AMCAX::Circle3 circle3(defaultFrame3, radius);
	Point3 p;
	Vector3 v1, v2,v3;
	SECTION("u =0") {
		CurveCalculation::D3(0.0, circle3, p, v1, v2,v3);
		CHECK(p.X() == 3.0);
		CHECK(p.Y() == 1.0);
		CHECK(p.Z() == 0.0);
		CHECK(v1.X() == Approx(0.0));
		CHECK(v1.Y() == Approx(2.0));
		CHECK(v1.Z() == Approx(0.0));
		CHECK(v2.X() == Approx(-2.0));
		CHECK(v2.Y() == Approx(0.0));
		CHECK(v2.Z() == Approx(0.0));
		CHECK(v3.X() == Approx(0.0));
		CHECK(v3.Y() == Approx(-2.0));
		CHECK(v3.Z() == Approx(0.0));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static void D3(double u, const Ellipse3& ellipse, Point3& p, Vector3& v1, Vector3& v2, Vector3& v3)	 @param[out] v3 The third derivative
	 @param[out] v2 The second derivative
	 @param[out] v1 The first derivative
	 @param[out] p The point
	 @param[in] ellipse The ellipse
	 @param[in] u The parameter
	 @brief Compute the point and the first three derivatives on a 3D ellipse at a parameter
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
#include <occtio/OCCTTool.hpp>
#include <geometry/MakeArcOfHyperbola2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeEdge2d.hpp>
using namespace AMCAX;
TEST_CASE("case1: CurveCalculation::D3() circle3[4/20] ", "[math][CurveCalculation][P1][D3]") {
	Direction3 initialDir(0.0, 0.0, 1.0);
	Frame3 defaultFrame3(Point3(1.0, 1.0, 0.0), initialDir);
	double radius = 2.0; 
	AMCAX::Circle3 circle3(defaultFrame3, radius);
	Point3 p;
	Vector3 v1, v2,v3;
	SECTION("u =0") {
		CurveCalculation::D3(0.0, circle3, p, v1, v2,v3);
		CHECK(p.X() == 3.0);
		CHECK(p.Y() == 1.0);
		CHECK(p.Z() == 0.0);
		CHECK(v1.X() == Approx(0.0));
		CHECK(v1.Y() == Approx(2.0));
		CHECK(v1.Z() == Approx(0.0));
		CHECK(v2.X() == Approx(-2.0));
		CHECK(v2.Y() == Approx(0.0));
		CHECK(v2.Z() == Approx(0.0));
		CHECK(v3.X() == Approx(0.0));
		CHECK(v3.Y() == Approx(-2.0));
		CHECK(v3.Z() == Approx(0.0));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] AMCAX_API static Vector2 D3(double u, const Line2& line)	 @return The third derivative vector
	 @param line The line
	 @param u The parameter
	 @brief Compute the third derivative on a 2D line at a parameter
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
#include <occtio/OCCTTool.hpp>
#include <geometry/MakeArcOfHyperbola2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeEdge2d.hpp>
using namespace AMCAX;
TEST_CASE("case1: CurveCalculation::D3() circle2[1/20] ", "[math][CurveCalculation][P1][D2]") {
	Direction2 initialDir(1.0, 0.0); 
	Frame2 defaultFrame2(Point2(0.0, 0.0), initialDir); 
	double radius = 2.0;
	AMCAX::Circle2 circle2(defaultFrame2, radius);
	SECTION("u =0") {
		Vector2 vector2 = CurveCalculation::D3(0.0, circle2);
		CHECK(vector2.X() == 0.0);
		CHECK(vector2.Y() == -2.0);
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static void D3(double u, const Line2& line, Point2& p, Vector2& v1, Vector2& v2, Vector2& v3)	 @param[out] v3 The third derivative
	 @param[out] v2 The second derivative
	 @param[out] v1 The first derivative
	 @param[out] p The point
	 @param[in] line The line
	 @param[in] u The parameter
	 @brief Compute the point and the first three derivatives on a 2D line at a parameter
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
#include <occtio/OCCTTool.hpp>
#include <geometry/MakeArcOfHyperbola2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeEdge2d.hpp>
using namespace AMCAX;
TEST_CASE("case1: CurveCalculation::D3() circle2[2/20] ", "[math][CurveCalculation][P1][D2]") {
	Direction2 initialDir(1.0, 0.0); 
	Frame2 defaultFrame2(Point2(1.0, 1.0), initialDir); 
	double radius = 2.0;
	AMCAX::Circle2 circle2(defaultFrame2, radius);
	Point2 p;
	Vector2 v1, v2,v3;
	SECTION("u =0") {
		CurveCalculation::D3(0.0, circle2, p, v1, v2,v3);
		CHECK(p.X() == 3.0);
		CHECK(p.Y() == 1.0);
		CHECK(v1.X() == 0.0);
		CHECK(v1.Y() == 2.0);
		CHECK(v2.X() == -2.0);
		CHECK(v2.Y() == 0.0);
		CHECK(v3.X() == 0.0);
		CHECK(v3.Y() == -2.0);
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] AMCAX_API static Vector2 D3(double u, const Circle2& circle)	 @return The third derivative vector
	 @param circle The circle
	 @param u The parameter
	 @brief Compute the third derivative on a 2D circle at a parameter
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
#include <occtio/OCCTTool.hpp>
#include <geometry/MakeArcOfHyperbola2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeEdge2d.hpp>
using namespace AMCAX;
TEST_CASE("case1: CurveCalculation::D3() circle2[1/20] ", "[math][CurveCalculation][P1][D2]") {
	Direction2 initialDir(1.0, 0.0); 
	Frame2 defaultFrame2(Point2(0.0, 0.0), initialDir); 
	double radius = 2.0;
	AMCAX::Circle2 circle2(defaultFrame2, radius);
	SECTION("u =0") {
		Vector2 vector2 = CurveCalculation::D3(0.0, circle2);
		CHECK(vector2.X() == 0.0);
		CHECK(vector2.Y() == -2.0);
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static void D3(double u, const Circle2& circle, Point2& p, Vector2& v1, Vector2& v2, Vector2& v3)	 @param[out] v3 The third derivative
	 @param[out] v2 The second derivative
	 @param[out] v1 The first derivative
	 @param[out] p The point
	 @param[in] circle The circle
	 @param[in] u The parameter
	 @brief Compute the point and the first three derivatives on a 2D circle at a parameter
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
#include <occtio/OCCTTool.hpp>
#include <geometry/MakeArcOfHyperbola2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeEdge2d.hpp>
using namespace AMCAX;
TEST_CASE("case1: CurveCalculation::D3() circle2[2/20] ", "[math][CurveCalculation][P1][D2]") {
	Direction2 initialDir(1.0, 0.0); 
	Frame2 defaultFrame2(Point2(1.0, 1.0), initialDir); 
	double radius = 2.0;
	AMCAX::Circle2 circle2(defaultFrame2, radius);
	Point2 p;
	Vector2 v1, v2,v3;
	SECTION("u =0") {
		CurveCalculation::D3(0.0, circle2, p, v1, v2,v3);
		CHECK(p.X() == 3.0);
		CHECK(p.Y() == 1.0);
		CHECK(v1.X() == 0.0);
		CHECK(v1.Y() == 2.0);
		CHECK(v2.X() == -2.0);
		CHECK(v2.Y() == 0.0);
		CHECK(v3.X() == 0.0);
		CHECK(v3.Y() == -2.0);
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static void D3(double u, const Ellipse2& ellipse, Point2& p, Vector2& v1, Vector2& v2, Vector2& v3)	 @param[out] v3 The third derivative
	 @param[out] v2 The second derivative
	 @param[out] v1 The first derivative
	 @param[out] p The point
	 @param[in] ellipse The ellipse
	 @param[in] u The parameter
	 @brief Compute the point and the first three derivatives on a 2D ellipse at a parameter
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
#include <occtio/OCCTTool.hpp>
#include <geometry/MakeArcOfHyperbola2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeEdge2d.hpp>
using namespace AMCAX;
TEST_CASE("case1: CurveCalculation::D3() circle2[2/20] ", "[math][CurveCalculation][P1][D2]") {
	Direction2 initialDir(1.0, 0.0); 
	Frame2 defaultFrame2(Point2(1.0, 1.0), initialDir); 
	double radius = 2.0;
	AMCAX::Circle2 circle2(defaultFrame2, radius);
	Point2 p;
	Vector2 v1, v2,v3;
	SECTION("u = M_PI") {
		CurveCalculation::D3(M_PI, circle2, p, v1, v2,v3);
		CHECK(p.X() == -1.0);
		CHECK(p.Y() == Approx(1.0));
		CHECK(v1.X() == Approx(0.0).margin(1e-12));
		CHECK(v1.Y() == -2.0);
		CHECK(v2.X() == 2.0);
		CHECK(v2.Y() == Approx(0.0).margin(1e-11));
		CHECK(v3.X() == Approx(0.0).margin(1e-12));
		CHECK(v3.Y() == 2.0);
	}
}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static void D3(double u, const Parabola2& parabola, Point2& p, Vector2& v1, Vector2& v2, Vector2& v3)	 @param[out] v3 The third derivative
	 @param[out] v2 The second derivative
	 @param[out] v1 The first derivative
	 @param[out] p The point
	 @param[in] parabola The parabola
	 @param[in] u The parameter
	 @brief Compute the point and the first three derivatives on a 2D parabola at a parameter
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
#include <occtio/OCCTTool.hpp>
#include <geometry/MakeArcOfHyperbola2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeEdge2d.hpp>
using namespace AMCAX;
TEST_CASE("case1: CurveCalculation::D3() circle2[2/20] ", "[math][CurveCalculation][P1][D2]") {
	Direction2 initialDir(1.0, 0.0); 
	Frame2 defaultFrame2(Point2(1.0, 1.0), initialDir); 
	double radius = 2.0;
	AMCAX::Circle2 circle2(defaultFrame2, radius);
	Point2 p;
	Vector2 v1, v2,v3;
	SECTION("u = M_PI") {
		CurveCalculation::D3(M_PI, circle2, p, v1, v2,v3);
		CHECK(p.X() == -1.0);
		CHECK(p.Y() == Approx(1.0));
		CHECK(v1.X() == Approx(0.0).margin(1e-12));
		CHECK(v1.Y() == -2.0);
		CHECK(v2.X() == 2.0);
		CHECK(v2.Y() == Approx(0.0).margin(1e-11));
		CHECK(v3.X() == Approx(0.0).margin(1e-12));
		CHECK(v3.Y() == 2.0);
	}
}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":Cylinder()	 @brief Default constructor
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <common/FrameT.hpp>
#include <modeling/MakeFace.hpp>
#include <common/AxisT.hpp>
#include <math/Cylinder.hpp>
#include <common/VectorT.hpp>
#include <occtio/OCCTTool.hpp>
#include <modeling/MakeCylinder.hpp>
#include <iostream>
using namespace AMCAX;
using namespace std;
TEST_CASE("case1:this is a case for Test Cylinder", "[math][Cylinder][P1]")
{
	Frame3 frame;
	double radius = 5.0;
	Cylinder cylinder(frame, radius);
	SECTION("Cylinder")
	{
		CHECK(cylinder.Radius() == Approx(radius));
		CHECK(cylinder.Location().X() == Approx(0.0));
		CHECK(cylinder.Location().Y() == Approx(0.0));
		CHECK(cylinder.Location().Z() == Approx(0.0));
		Cylinder cylinder1;
		CHECK(cylinder1.Location().X() == Approx(0.0));
		CHECK(cylinder1.Location().Y() == Approx(0.0));
		CHECK(cylinder1.Location().Z() == Approx(0.0));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API Cylinder(const Frame3& frame, double r)	 @param r The radius
	 @param frame The local frame
	 @brief Construct from a local frame and a radius
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <common/FrameT.hpp>
#include <modeling/MakeFace.hpp>
#include <common/AxisT.hpp>
#include <math/Cylinder.hpp>
#include <common/VectorT.hpp>
#include <occtio/OCCTTool.hpp>
#include <modeling/MakeCylinder.hpp>
#include <iostream>
using namespace AMCAX;
using namespace std;
TEST_CASE("bug1:Cylinder ", "[math][Cylinder][fixbug]")
{
	Point3 point_cy(6.0, 0.0, 0.0);
	Direction3 dir_cy(0.0, 0.0, 1.0);
	Frame3 frame_cy(point_cy, dir_cy);
	double radius_cy = 5.0;
	Cylinder cylinder(frame_cy, radius_cy);
	double r = 0.0;
	SECTION("SetRadius1")
	{
		cylinder.SetRadius(r);
		CHECK(cylinder.Radius() == Approx(0.0));
	}
	r = -1.0;
	string str1;
	string str2 = "[_DomainError]";}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API Cylinder& Scale(const Point3& point, double scale)	 @return The reference to self
	 @param scale The scale value
	 @param point The scaling center point
	 @brief Scale the cylinder by a point
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <common/FrameT.hpp>
#include <modeling/MakeFace.hpp>
#include <common/AxisT.hpp>
#include <math/Cylinder.hpp>
#include <common/VectorT.hpp>
#include <occtio/OCCTTool.hpp>
#include <modeling/MakeCylinder.hpp>
#include <iostream>
using namespace AMCAX;
using namespace std;
TEST_CASE("case2:this is a case for Test Cylinder_Mirror&Mirrored/Rotate&Rotated/Scale&Scaled", "[math][Cylinder][P1]")
{
	Point3 point_cy(6.0, 0.0, 0.0);
	Direction3 dir_cy(0.0, 0.0, 1.0);
	Frame3 frame_cy(point_cy, dir_cy);
	double radius_cy = 5.0;
	Cylinder cylinder(frame_cy, radius_cy);
	SECTION("Scale")
	{
		Cylinder scale_cylinder = cylinder.Scale(point_cy, scale);
		CHECK(cylinder.Radius() == Approx(2.5));
		CHECK(cylinder.Location().X() == Approx(6.0));
		CHECK(cylinder.Location().Y() == Approx(0.0));
		CHECK(cylinder.Location().Z() == Approx(0.0));
		CHECK(cylinder.Axis().Direction().X() == 0.0);
		CHECK(cylinder.Axis().Direction().Y() == 0.0);
		CHECK(cylinder.Axis().Direction().Z() == 1.0);
		CHECK(scale_cylinder.Radius() == Approx(2.5));
		CHECK(scale_cylinder.Location().X() == Approx(6.0));
		CHECK(scale_cylinder.Location().Y() == Approx(0.0));
		CHECK(scale_cylinder.Location().Z() == Approx(0.0));
		CHECK(scale_cylinder.Axis().Direction().X() == 0.0);
		CHECK(scale_cylinder.Axis().Direction().Y() == 0.0);
		CHECK(scale_cylinder.Axis().Direction().Z() == 1.0);
	}
	scale = 2.0;}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":void SetMajorRadius(double r)	 @param r The new major radius
	 @brief Set the major radius
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <modeling/MakeFace.hpp>
#include <common/AxisT.hpp>
#include <math/HyperbolaT.hpp>
#include <occtio/OCCTTool.hpp>
#include <common/VectorT.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <topology/TopoEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <common/TransformationT.hpp>
#include <iostream>
using namespace AMCAX;
using namespace std;
TEST_CASE("case1:this is a case for Hyperbola2", "[math][Hyperbola2][p1]") {
	Point2 point2_Hy(0.0, 0.0);	
	Direction2 dir2_Hy(1.0, 0.0);
	Axis2 major2_Axis(point2_Hy, dir2_Hy);
	double major2 = 3.0, minor2 = 4.0;
	Hyperbola2 hyperbola2d_ax(major2_Axis, major2, minor2, true);
	Point2 point2_fr(1.0, 1.0);
	Direction2 dir2_fr(0.0, 1.0);
	Frame2 frame2(point2_fr, dir2_fr);
	Hyperbola2 hyperbola2d_fr(frame2, major2, minor2);
	SECTION("Default()") {
		Hyperbola2 hyperbola2d_de;	
		CHECK(hyperbola2d_de.Location().X() == Approx(0.0));
		CHECK(hyperbola2d_de.Location().Y() == Approx(0.0));
		hyperbola2d_de.SetMajorRadius(3.0);
		hyperbola2d_de.SetMinorRadius(4.0);
		CHECK(hyperbola2d_de.MajorRadius() == Approx(3.0));
		CHECK(hyperbola2d_de.MinorRadius() == Approx(4.0));
		CHECK(hyperbola2d_de.Focal() == Approx(10.0));
		CHECK(hyperbola2d_de.Focus1().X() == Approx(5.0));
		CHECK(hyperbola2d_de.Focus1().Y() == Approx(0.0));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":void SetMinorRadius(double r)	 @param r The new minor radius
	 @brief Set the minor radius
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <modeling/MakeFace.hpp>
#include <common/AxisT.hpp>
#include <math/HyperbolaT.hpp>
#include <occtio/OCCTTool.hpp>
#include <common/VectorT.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <topology/TopoEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <common/TransformationT.hpp>
#include <iostream>
using namespace AMCAX;
using namespace std;
TEST_CASE("case1:this is a case for Hyperbola2", "[math][Hyperbola2][p1]") {
	Point2 point2_Hy(0.0, 0.0);	
	Direction2 dir2_Hy(1.0, 0.0);
	Axis2 major2_Axis(point2_Hy, dir2_Hy);
	double major2 = 3.0, minor2 = 4.0;
	Hyperbola2 hyperbola2d_ax(major2_Axis, major2, minor2, true);
	Point2 point2_fr(1.0, 1.0);
	Direction2 dir2_fr(0.0, 1.0);
	Frame2 frame2(point2_fr, dir2_fr);
	Hyperbola2 hyperbola2d_fr(frame2, major2, minor2);
	SECTION("SetMinorRadius()") {
		hyperbola2d_ax.SetMinorRadius(3.0);
		CHECK(hyperbola2d_ax.Location().X() == Approx(0.0));
		CHECK(hyperbola2d_ax.Location().Y() == Approx(0.0));
		CHECK(hyperbola2d_ax.MajorRadius() == Approx(3.0));
		CHECK(hyperbola2d_ax.MinorRadius() == Approx(3.0));
		Point3 point1(3.0, 0.0, 0.0);
		MakeEdge2d edge1(hyperbola2d_ax);
		CHECK(BRepClassificationTools::IsPointInOnEdge(edge1, point1, 0.001) == true);
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] AxisT<double, DIM> Directrix2()	 @return The negative directrix
	 @brief Get the directrix on the negative side of the major axis
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <modeling/MakeFace.hpp>
#include <common/AxisT.hpp>
#include <math/HyperbolaT.hpp>
#include <occtio/OCCTTool.hpp>
#include <common/VectorT.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <topology/TopoEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <common/TransformationT.hpp>
#include <iostream>
using namespace AMCAX;
using namespace std;
TEST_CASE("case1:this is a case for Hyperbola2", "[math][Hyperbola2][p1]") {
	Point2 point2_Hy(0.0, 0.0);	
	Direction2 dir2_Hy(1.0, 0.0);
	Axis2 major2_Axis(point2_Hy, dir2_Hy);
	double major2 = 3.0, minor2 = 4.0;
	Hyperbola2 hyperbola2d_ax(major2_Axis, major2, minor2, true);
	Point2 point2_fr(1.0, 1.0);
	Direction2 dir2_fr(0.0, 1.0);
	Frame2 frame2(point2_fr, dir2_fr);
	Hyperbola2 hyperbola2d_fr(frame2, major2, minor2);
	SECTION("Directrix()") {
		Axis2 axis2d_dir = hyperbola2d_ax.Directrix2();
		CHECK(axis2d_dir.Direction().X() == Approx(0.0));
		CHECK(axis2d_dir.Direction().Y() == Approx(1.0));
		CHECK(axis2d_dir.Location().X() == Approx(-9.0 / 5.0));
		CHECK(axis2d_dir.Location().Y() == Approx(0.0));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] PointT<double, DIM> Focus1()	 @return The positive focus
	 @brief Get the focus on the positive side of the major axis
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <modeling/MakeFace.hpp>
#include <common/AxisT.hpp>
#include <math/HyperbolaT.hpp>
#include <occtio/OCCTTool.hpp>
#include <common/VectorT.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <topology/TopoEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <common/TransformationT.hpp>
#include <iostream>
using namespace AMCAX;
using namespace std;
TEST_CASE("case1:this is a case for Hyperbola2", "[math][Hyperbola2][p1]") {
	Point2 point2_Hy(0.0, 0.0);	
	Direction2 dir2_Hy(1.0, 0.0);
	Axis2 major2_Axis(point2_Hy, dir2_Hy);
	double major2 = 3.0, minor2 = 4.0;
	Hyperbola2 hyperbola2d_ax(major2_Axis, major2, minor2, true);
	Point2 point2_fr(1.0, 1.0);
	Direction2 dir2_fr(0.0, 1.0);
	Frame2 frame2(point2_fr, dir2_fr);
	Hyperbola2 hyperbola2d_fr(frame2, major2, minor2);
	SECTION("Default()") {
		Hyperbola2 hyperbola2d_de;	
		CHECK(hyperbola2d_de.Location().X() == Approx(0.0));
		CHECK(hyperbola2d_de.Location().Y() == Approx(0.0));
		hyperbola2d_de.SetMajorRadius(3.0);
		hyperbola2d_de.SetMinorRadius(4.0);
		CHECK(hyperbola2d_de.MajorRadius() == Approx(3.0));
		CHECK(hyperbola2d_de.MinorRadius() == Approx(4.0));
		CHECK(hyperbola2d_de.Focal() == Approx(10.0));
		CHECK(hyperbola2d_de.Focus1().X() == Approx(5.0));
		CHECK(hyperbola2d_de.Focus1().Y() == Approx(0.0));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] double MajorRadius()	 @return The major radius
	 @brief Get the major radius
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <modeling/MakeFace.hpp>
#include <common/AxisT.hpp>
#include <math/HyperbolaT.hpp>
#include <occtio/OCCTTool.hpp>
#include <common/VectorT.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <topology/TopoEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <common/TransformationT.hpp>
#include <iostream>
using namespace AMCAX;
using namespace std;
TEST_CASE("case1:this is a case for Hyperbola2", "[math][Hyperbola2][p1]") {
	Point2 point2_Hy(0.0, 0.0);	
	Direction2 dir2_Hy(1.0, 0.0);
	Axis2 major2_Axis(point2_Hy, dir2_Hy);
	double major2 = 3.0, minor2 = 4.0;
	Hyperbola2 hyperbola2d_ax(major2_Axis, major2, minor2, true);
	Point2 point2_fr(1.0, 1.0);
	Direction2 dir2_fr(0.0, 1.0);
	Frame2 frame2(point2_fr, dir2_fr);
	Hyperbola2 hyperbola2d_fr(frame2, major2, minor2);
	SECTION("Default()") {
		Hyperbola2 hyperbola2d_de;	
		CHECK(hyperbola2d_de.Location().X() == Approx(0.0));
		CHECK(hyperbola2d_de.Location().Y() == Approx(0.0));
		hyperbola2d_de.SetMajorRadius(3.0);
		hyperbola2d_de.SetMinorRadius(4.0);
		CHECK(hyperbola2d_de.MajorRadius() == Approx(3.0));
		CHECK(hyperbola2d_de.MinorRadius() == Approx(4.0));
		CHECK(hyperbola2d_de.Focal() == Approx(10.0));
		CHECK(hyperbola2d_de.Focus1().X() == Approx(5.0));
		CHECK(hyperbola2d_de.Focus1().Y() == Approx(0.0));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] double MinorRadius()	 @return The minor radius
	 @brief Get the minor radius
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <modeling/MakeFace.hpp>
#include <common/AxisT.hpp>
#include <math/HyperbolaT.hpp>
#include <occtio/OCCTTool.hpp>
#include <common/VectorT.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <topology/TopoEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <common/TransformationT.hpp>
#include <iostream>
using namespace AMCAX;
using namespace std;
TEST_CASE("case1:this is a case for Hyperbola2", "[math][Hyperbola2][p1]") {
	Point2 point2_Hy(0.0, 0.0);	
	Direction2 dir2_Hy(1.0, 0.0);
	Axis2 major2_Axis(point2_Hy, dir2_Hy);
	double major2 = 3.0, minor2 = 4.0;
	Hyperbola2 hyperbola2d_ax(major2_Axis, major2, minor2, true);
	Point2 point2_fr(1.0, 1.0);
	Direction2 dir2_fr(0.0, 1.0);
	Frame2 frame2(point2_fr, dir2_fr);
	Hyperbola2 hyperbola2d_fr(frame2, major2, minor2);
	SECTION("ConjugateBranch1()") {
		Point3 point1(0.0, 4.0, 0.0);
		Point3 point2(9.0 / 4.0, 5.0, 0.0);
		Hyperbola2 hyperbola2d_con = hyperbola2d_ax.ConjugateBranch1();
		MakeEdge2d edge1(hyperbola2d_con);
		CHECK(BRepClassificationTools::IsPointInOnEdge(edge1, point1, 0.001) == true);
		CHECK(BRepClassificationTools::IsPointInOnEdge(edge1, point2, 0.001) == true);
		double major2d_con = hyperbola2d_con.MajorRadius();
		double minor2d_con = hyperbola2d_con.MinorRadius();
		CHECK( major2d_con== Approx(4.0));
		CHECK(minor2d_con == Approx(3.0));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] AxisT<double, DIM> Asymptote1()	 @return The positive asymptote
	 @brief Get the asymptote of the hyperbola with positive slope
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <modeling/MakeFace.hpp>
#include <common/AxisT.hpp>
#include <math/HyperbolaT.hpp>
#include <occtio/OCCTTool.hpp>
#include <common/VectorT.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <topology/TopoEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <common/TransformationT.hpp>
#include <iostream>
using namespace AMCAX;
using namespace std;
TEST_CASE("case1:this is a case for Hyperbola2", "[math][Hyperbola2][p1]") {
	Point2 point2_Hy(0.0, 0.0);	
	Direction2 dir2_Hy(1.0, 0.0);
	Axis2 major2_Axis(point2_Hy, dir2_Hy);
	double major2 = 3.0, minor2 = 4.0;
	Hyperbola2 hyperbola2d_ax(major2_Axis, major2, minor2, true);
	Point2 point2_fr(1.0, 1.0);
	Direction2 dir2_fr(0.0, 1.0);
	Frame2 frame2(point2_fr, dir2_fr);
	Hyperbola2 hyperbola2d_fr(frame2, major2, minor2);
	SECTION("Asymptote1()") {
		Axis2 axis2d_asy = hyperbola2d_ax.Asymptote1();
		CHECK(axis2d_asy.Direction().X()/ axis2d_asy.Direction().Y() == Approx(3.0/4.0));
		Point3 point1(0.0, 0.0, 0.0);
		Line2 line2d_asy(axis2d_asy);
		MakeEdge2d edge1(line2d_asy);
		CHECK(BRepClassificationTools::IsPointInOnEdge(edge1, point1, 0.001) == true);
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] AxisT<double, DIM> Asymptote2()	 @return The negative asymptote
	 @brief Get the asymptote of the hyperbola with negative slope
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <modeling/MakeFace.hpp>
#include <common/AxisT.hpp>
#include <math/HyperbolaT.hpp>
#include <occtio/OCCTTool.hpp>
#include <common/VectorT.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <topology/TopoEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <common/TransformationT.hpp>
#include <iostream>
using namespace AMCAX;
using namespace std;
TEST_CASE("case1:this is a case for Hyperbola2", "[math][Hyperbola2][p1]") {
	Point2 point2_Hy(0.0, 0.0);	
	Direction2 dir2_Hy(1.0, 0.0);
	Axis2 major2_Axis(point2_Hy, dir2_Hy);
	double major2 = 3.0, minor2 = 4.0;
	Hyperbola2 hyperbola2d_ax(major2_Axis, major2, minor2, true);
	Point2 point2_fr(1.0, 1.0);
	Direction2 dir2_fr(0.0, 1.0);
	Frame2 frame2(point2_fr, dir2_fr);
	Hyperbola2 hyperbola2d_fr(frame2, major2, minor2);
	SECTION("Asymptote2()") {	
		Axis2 axis2d_asy = hyperbola2d_ax.Asymptote2();
		CHECK(axis2d_asy.Direction().X() / axis2d_asy.Direction().Y() == Approx(-3.0 / 4.0));
		Point3 point1(0.0, 0.0, 0.0);
		Line2 line2d_asy(axis2d_asy);
		MakeEdge2d edge1(line2d_asy);
		CHECK(BRepClassificationTools::IsPointInOnEdge(edge1, point1, 0.001) == true);
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] HyperbolaS ConjugateBranch2()	 @return The negative conjugate hyperbola
	 @brief Get the conjugate hyperbola on the negative side of the minor axis
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <modeling/MakeFace.hpp>
#include <common/AxisT.hpp>
#include <math/HyperbolaT.hpp>
#include <occtio/OCCTTool.hpp>
#include <common/VectorT.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <topology/TopoEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <common/TransformationT.hpp>
#include <iostream>
using namespace AMCAX;
using namespace std;
TEST_CASE("case1:this is a case for Hyperbola2", "[math][Hyperbola2][p1]") {
	Point2 point2_Hy(0.0, 0.0);	
	Direction2 dir2_Hy(1.0, 0.0);
	Axis2 major2_Axis(point2_Hy, dir2_Hy);
	double major2 = 3.0, minor2 = 4.0;
	Hyperbola2 hyperbola2d_ax(major2_Axis, major2, minor2, true);
	Point2 point2_fr(1.0, 1.0);
	Direction2 dir2_fr(0.0, 1.0);
	Frame2 frame2(point2_fr, dir2_fr);
	Hyperbola2 hyperbola2d_fr(frame2, major2, minor2);
	SECTION("ConjugateBranch2()") {
		Point3 point1(0.0, -4.0, 0.0);
		Point3 point2(9.0 / 4.0, -5.0, 0.0);
		Hyperbola2 hyperbola2d_con = hyperbola2d_ax.ConjugateBranch2();
		MakeEdge2d edge1(hyperbola2d_con);
		CHECK(BRepClassificationTools::IsPointInOnEdge(edge1, point1, 0.001) == true);
		CHECK(BRepClassificationTools::IsPointInOnEdge(edge1, point2, 0.001) == true);
		double major2d_con = hyperbola2d_con.MajorRadius();
		double minor2d_con = hyperbola2d_con.MinorRadius();
		CHECK(major2d_con == Approx(4.0));
		CHECK(minor2d_con == Approx(3.0));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":HyperbolaS& Scale(const PointT<double, DIM>& point, double scale)	 @return The reference to self
	 @param scale The scale value
	 @param point The scaling center point
	 @brief Scale the hyperbola by a center point
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <modeling/MakeFace.hpp>
#include <common/AxisT.hpp>
#include <math/HyperbolaT.hpp>
#include <occtio/OCCTTool.hpp>
#include <common/VectorT.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <topology/TopoEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <common/TransformationT.hpp>
#include <iostream>
using namespace AMCAX;
using namespace std;
TEST_CASE("case1:this is a case for Hyperbola2", "[math][Hyperbola2][p1]") {
	Point2 point2_Hy(0.0, 0.0);	
	Direction2 dir2_Hy(1.0, 0.0);
	Axis2 major2_Axis(point2_Hy, dir2_Hy);
	double major2 = 3.0, minor2 = 4.0;
	Hyperbola2 hyperbola2d_ax(major2_Axis, major2, minor2, true);
	Point2 point2_fr(1.0, 1.0);
	Direction2 dir2_fr(0.0, 1.0);
	Frame2 frame2(point2_fr, dir2_fr);
	Hyperbola2 hyperbola2d_fr(frame2, major2, minor2);
	SECTION("Scale()") {		
		Point2 point2(1.0, 1.0);
		hyperbola2d_ax.Scale(point2, 0.5);
		CHECK(hyperbola2d_ax.Location().X() == Approx(0.5));
		CHECK(hyperbola2d_ax.Location().Y() == Approx(0.5));
		Point3 point3(2.0, 0.5, 0.0);
		MakeEdge2d edge1(hyperbola2d_ax);
		CHECK(BRepClassificationTools::IsPointInOnEdge(edge1, point3, 0.001) == true);
	}}
}
,
{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":void SetMajorRadius(double r)	 @param r The new major radius
	 @brief Set the major radius
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <modeling/MakeFace.hpp>
#include <common/AxisT.hpp>
#include <math/HyperbolaT.hpp>
#include <occtio/OCCTTool.hpp>
#include <common/VectorT.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <topology/TopoEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <iostream>
using namespace AMCAX;
using namespace std;
TEST_CASE("case1:this is a case for Hyperbola3", "[math][Hyperbola3][p1]") {
	Point3 point3_fr(0.0, 0.0, 1.0);
	Direction3 dir3_fr(0.0, 0.0, 1.0);
	Frame3 frame3(point3_fr, dir3_fr);
	double major3 = 3.0, minor3 = 4.0;
	Hyperbola3 hyperbola3d_fr(frame3, major3, minor3);
	SECTION("Default()") {
		Hyperbola3 hyperbola3d_de;	
		CHECK(hyperbola3d_de.Location().X() == Approx(0.0));
		CHECK(hyperbola3d_de.Location().Y() == Approx(0.0));
		CHECK(hyperbola3d_de.Location().Z() == Approx(0.0));
		hyperbola3d_de.SetMajorRadius(3.0);
		hyperbola3d_de.SetMinorRadius(4.0);
		CHECK(hyperbola3d_de.MajorRadius() == Approx(3.0));
		CHECK(hyperbola3d_de.MinorRadius() == Approx(4.0));
		CHECK(hyperbola3d_de.Focal() == Approx(10.0));
		CHECK(hyperbola3d_de.Focus1().X() == Approx(5.0));
		CHECK(hyperbola3d_de.Focus1().Y() == Approx(0.0));
		CHECK(hyperbola3d_de.Focus1().Z() == Approx(0.0));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":void SetMinorRadius(double r)	 @param r The new minor radius
	 @brief Set the minor radius
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <modeling/MakeFace.hpp>
#include <common/AxisT.hpp>
#include <math/HyperbolaT.hpp>
#include <occtio/OCCTTool.hpp>
#include <common/VectorT.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <topology/TopoEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <iostream>
using namespace AMCAX;
using namespace std;
TEST_CASE("case1:this is a case for Hyperbola3", "[math][Hyperbola3][p1]") {
	Point3 point3_fr(0.0, 0.0, 1.0);
	Direction3 dir3_fr(0.0, 0.0, 1.0);
	Frame3 frame3(point3_fr, dir3_fr);
	double major3 = 3.0, minor3 = 4.0;
	Hyperbola3 hyperbola3d_fr(frame3, major3, minor3);
	SECTION("SetMinorRadius()") {
		hyperbola3d_fr.SetMinorRadius(3.0);
		CHECK(hyperbola3d_fr.Location().X() == Approx(0.0));
		CHECK(hyperbola3d_fr.Location().Y() == Approx(0.0));
		CHECK(hyperbola3d_fr.MajorRadius() == Approx(3.0));
		CHECK(hyperbola3d_fr.MinorRadius() == Approx(3.0));
		Point3 point1(3.0, 0.0, 1.0);
		MakeEdge edge1(hyperbola3d_fr);
		CHECK(BRepClassificationTools::IsPointInOnEdge(edge1, point1, 0.001) == true);
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] AxisT<double, DIM> Directrix1()	 @return The positive directrix
	 @brief Get the directrix on the positive side of the major axis
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <modeling/MakeFace.hpp>
#include <common/AxisT.hpp>
#include <math/HyperbolaT.hpp>
#include <occtio/OCCTTool.hpp>
#include <common/VectorT.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <topology/TopoEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <iostream>
using namespace AMCAX;
using namespace std;
TEST_CASE("case1:this is a case for Hyperbola3", "[math][Hyperbola3][p1]") {
	Point3 point3_fr(0.0, 0.0, 1.0);
	Direction3 dir3_fr(0.0, 0.0, 1.0);
	Frame3 frame3(point3_fr, dir3_fr);
	double major3 = 3.0, minor3 = 4.0;
	Hyperbola3 hyperbola3d_fr(frame3, major3, minor3);
	SECTION("Directrix1()") {
		Axis3 axis3d_dir = hyperbola3d_fr.Directrix1();
		CHECK(axis3d_dir.Direction().X() == Approx(0.0));
		CHECK(axis3d_dir.Direction().Y() == Approx(1.0));
		CHECK(axis3d_dir.Direction().Z() == Approx(0.0));
		CHECK(axis3d_dir.Location().X() == Approx(9.0 / 5.0));
		CHECK(axis3d_dir.Location().Y() == Approx(0.0));
		CHECK(axis3d_dir.Location().Z() == Approx(1.0));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] AxisT<double, DIM> Directrix2()	 @return The negative directrix
	 @brief Get the directrix on the negative side of the major axis
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <modeling/MakeFace.hpp>
#include <common/AxisT.hpp>
#include <math/HyperbolaT.hpp>
#include <occtio/OCCTTool.hpp>
#include <common/VectorT.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <topology/TopoEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <iostream>
using namespace AMCAX;
using namespace std;
TEST_CASE("case1:this is a case for Hyperbola3", "[math][Hyperbola3][p1]") {
	Point3 point3_fr(0.0, 0.0, 1.0);
	Direction3 dir3_fr(0.0, 0.0, 1.0);
	Frame3 frame3(point3_fr, dir3_fr);
	double major3 = 3.0, minor3 = 4.0;
	Hyperbola3 hyperbola3d_fr(frame3, major3, minor3);
	SECTION("Directrix2()") {
		Axis3 axis3d_dir = hyperbola3d_fr.Directrix2();
		CHECK(axis3d_dir.Direction().X() == Approx(0.0));
		CHECK(axis3d_dir.Direction().Y() == Approx(1.0));
		CHECK(axis3d_dir.Direction().Z() == Approx(0.0));
		CHECK(axis3d_dir.Location().X() == Approx(-9.0 / 5.0));
		CHECK(axis3d_dir.Location().Y() == Approx(0.0));
		CHECK(axis3d_dir.Location().Z() == Approx(1.0));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] PointT<double, DIM> Focus1()	 @return The positive focus
	 @brief Get the focus on the positive side of the major axis
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <modeling/MakeFace.hpp>
#include <common/AxisT.hpp>
#include <math/HyperbolaT.hpp>
#include <occtio/OCCTTool.hpp>
#include <common/VectorT.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <topology/TopoEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <iostream>
using namespace AMCAX;
using namespace std;
TEST_CASE("case1:this is a case for Hyperbola3", "[math][Hyperbola3][p1]") {
	Point3 point3_fr(0.0, 0.0, 1.0);
	Direction3 dir3_fr(0.0, 0.0, 1.0);
	Frame3 frame3(point3_fr, dir3_fr);
	double major3 = 3.0, minor3 = 4.0;
	Hyperbola3 hyperbola3d_fr(frame3, major3, minor3);
	SECTION("Default()") {
		Hyperbola3 hyperbola3d_de;	
		CHECK(hyperbola3d_de.Location().X() == Approx(0.0));
		CHECK(hyperbola3d_de.Location().Y() == Approx(0.0));
		CHECK(hyperbola3d_de.Location().Z() == Approx(0.0));
		hyperbola3d_de.SetMajorRadius(3.0);
		hyperbola3d_de.SetMinorRadius(4.0);
		CHECK(hyperbola3d_de.MajorRadius() == Approx(3.0));
		CHECK(hyperbola3d_de.MinorRadius() == Approx(4.0));
		CHECK(hyperbola3d_de.Focal() == Approx(10.0));
		CHECK(hyperbola3d_de.Focus1().X() == Approx(5.0));
		CHECK(hyperbola3d_de.Focus1().Y() == Approx(0.0));
		CHECK(hyperbola3d_de.Focus1().Z() == Approx(0.0));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] PointT<double, DIM> Focus2()	 @return The negative focus
	 @brief Get the focus on the negative side of the major axis
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <modeling/MakeFace.hpp>
#include <common/AxisT.hpp>
#include <math/HyperbolaT.hpp>
#include <occtio/OCCTTool.hpp>
#include <common/VectorT.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <topology/TopoEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <iostream>
using namespace AMCAX;
using namespace std;
TEST_CASE("case1:this is a case for Hyperbola3", "[math][Hyperbola3][p1]") {
	Point3 point3_fr(0.0, 0.0, 1.0);
	Direction3 dir3_fr(0.0, 0.0, 1.0);
	Frame3 frame3(point3_fr, dir3_fr);
	double major3 = 3.0, minor3 = 4.0;
	Hyperbola3 hyperbola3d_fr(frame3, major3, minor3);
	SECTION("Focus2") {
		Point3 point3d_f1 = hyperbola3d_fr.Focus2();
		CHECK(point3d_f1.X() == Approx(-5.0));
		CHECK(point3d_f1.Y() == Approx(0.0));
		CHECK(point3d_f1.Z() == Approx(1.0));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] double MajorRadius()	 @return The major radius
	 @brief Get the major radius
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <modeling/MakeFace.hpp>
#include <common/AxisT.hpp>
#include <math/HyperbolaT.hpp>
#include <occtio/OCCTTool.hpp>
#include <common/VectorT.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <topology/TopoEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <iostream>
using namespace AMCAX;
using namespace std;
TEST_CASE("case1:this is a case for Hyperbola3", "[math][Hyperbola3][p1]") {
	Point3 point3_fr(0.0, 0.0, 1.0);
	Direction3 dir3_fr(0.0, 0.0, 1.0);
	Frame3 frame3(point3_fr, dir3_fr);
	double major3 = 3.0, minor3 = 4.0;
	Hyperbola3 hyperbola3d_fr(frame3, major3, minor3);
	SECTION("ConjugateBranch1()") {
		Hyperbola3 hyperbola3d_con = hyperbola3d_fr.ConjugateBranch1();
		CHECK(hyperbola3d_con.Location().X() == Approx(0.0));
		CHECK(hyperbola3d_con.Location().Y() == Approx(0.0));
		CHECK(hyperbola3d_con.Location().Z() == Approx(1.0));
		Point3 point1(0.0, 4.0, 1.0);
		Point3 point2(9.0 / 4.0, 5.0, 1.0);
		MakeEdge edge1(hyperbola3d_con);
		CHECK(BRepClassificationTools::IsPointInOnEdge(edge1, point1, 0.001) == true);
		CHECK(BRepClassificationTools::IsPointInOnEdge(edge1, point2, 0.001) == true);
		double major3d_con = hyperbola3d_con.MajorRadius();
		double minor3d_con = hyperbola3d_con.MinorRadius();
		CHECK(major3d_con == Approx(4.0));
		CHECK(minor3d_con == Approx(3.0));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] double MinorRadius()	 @return The minor radius
	 @brief Get the minor radius
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <modeling/MakeFace.hpp>
#include <common/AxisT.hpp>
#include <math/HyperbolaT.hpp>
#include <occtio/OCCTTool.hpp>
#include <common/VectorT.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <topology/TopoEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <iostream>
using namespace AMCAX;
using namespace std;
TEST_CASE("case1:this is a case for Hyperbola3", "[math][Hyperbola3][p1]") {
	Point3 point3_fr(0.0, 0.0, 1.0);
	Direction3 dir3_fr(0.0, 0.0, 1.0);
	Frame3 frame3(point3_fr, dir3_fr);
	double major3 = 3.0, minor3 = 4.0;
	Hyperbola3 hyperbola3d_fr(frame3, major3, minor3);
	SECTION("ConjugateBranch2()") {		
		Hyperbola3 hyperbola3d_con = hyperbola3d_fr.ConjugateBranch2();
		CHECK(hyperbola3d_con.Location().X() == Approx(0.0));
		CHECK(hyperbola3d_con.Location().Y() == Approx(0.0));
		CHECK(hyperbola3d_con.Location().Z() == Approx(1.0));
		Point3 point1(0.0, -4.0, 1.0);
		Point3 point2(9.0 / 4.0, -5.0, 1.0);
		MakeEdge edge2(hyperbola3d_con);
		CHECK(BRepClassificationTools::IsPointInOnEdge(edge2, point1, 0.001) == true);
		CHECK(BRepClassificationTools::IsPointInOnEdge(edge2, point2, 0.001) == true);
		double major3d_con = hyperbola3d_con.MajorRadius();
		double minor3d_con = hyperbola3d_con.MinorRadius();
		CHECK(major3d_con == Approx(4.0));
		CHECK(minor3d_con == Approx(3.0));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] AxisT<double, DIM> Asymptote1()	 @return The positive asymptote
	 @brief Get the asymptote of the hyperbola with positive slope
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <modeling/MakeFace.hpp>
#include <common/AxisT.hpp>
#include <math/HyperbolaT.hpp>
#include <occtio/OCCTTool.hpp>
#include <common/VectorT.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <topology/TopoEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <iostream>
using namespace AMCAX;
using namespace std;
TEST_CASE("case1:this is a case for Hyperbola3", "[math][Hyperbola3][p1]") {
	Point3 point3_fr(0.0, 0.0, 1.0);
	Direction3 dir3_fr(0.0, 0.0, 1.0);
	Frame3 frame3(point3_fr, dir3_fr);
	double major3 = 3.0, minor3 = 4.0;
	Hyperbola3 hyperbola3d_fr(frame3, major3, minor3);
	SECTION("Asymptote1()") {
		Axis3 axis3d_asy = hyperbola3d_fr.Asymptote1();
		CHECK(axis3d_asy.Direction().X() / axis3d_asy.Direction().Y() == Approx(3.0 / 4.0));
		CHECK(axis3d_asy.Direction().Z() == Approx(0.0));
		Point3 point1(0.0, 0.0, 1.0);
		Line3 line3d_asy(axis3d_asy);
		MakeEdge edge1(line3d_asy);
		CHECK(BRepClassificationTools::IsPointInOnEdge(edge1, point1, 0.001) == true);
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] AxisT<double, DIM> Asymptote2()	 @return The negative asymptote
	 @brief Get the asymptote of the hyperbola with negative slope
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <modeling/MakeFace.hpp>
#include <common/AxisT.hpp>
#include <math/HyperbolaT.hpp>
#include <occtio/OCCTTool.hpp>
#include <common/VectorT.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <topology/TopoEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <iostream>
using namespace AMCAX;
using namespace std;
TEST_CASE("case1:this is a case for Hyperbola3", "[math][Hyperbola3][p1]") {
	Point3 point3_fr(0.0, 0.0, 1.0);
	Direction3 dir3_fr(0.0, 0.0, 1.0);
	Frame3 frame3(point3_fr, dir3_fr);
	double major3 = 3.0, minor3 = 4.0;
	Hyperbola3 hyperbola3d_fr(frame3, major3, minor3);
	SECTION("Asymptote2()") {
		Axis3 axis3d_asy = hyperbola3d_fr.Asymptote2();
		CHECK(axis3d_asy.Direction().X() / axis3d_asy.Direction().Y() == Approx(-3.0 / 4.0));
		CHECK(axis3d_asy.Direction().Z() == Approx(0.0));
		Point3 point1(0.0, 0.0, 1.0);
		Line3 line3d_asy(axis3d_asy);
		MakeEdge edge1(line3d_asy);
		CHECK(BRepClassificationTools::IsPointInOnEdge(edge1, point1, 0.001) == true);
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] HyperbolaS ConjugateBranch1()	 @return The positive conjugate hyperbola
	 @brief Get the conjugate hyperbola on the positive side of the minor axis
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <modeling/MakeFace.hpp>
#include <common/AxisT.hpp>
#include <math/HyperbolaT.hpp>
#include <occtio/OCCTTool.hpp>
#include <common/VectorT.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <topology/TopoEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <iostream>
using namespace AMCAX;
using namespace std;
TEST_CASE("case1:this is a case for Hyperbola3", "[math][Hyperbola3][p1]") {
	Point3 point3_fr(0.0, 0.0, 1.0);
	Direction3 dir3_fr(0.0, 0.0, 1.0);
	Frame3 frame3(point3_fr, dir3_fr);
	double major3 = 3.0, minor3 = 4.0;
	Hyperbola3 hyperbola3d_fr(frame3, major3, minor3);
	SECTION("ConjugateBranch1()") {
		Hyperbola3 hyperbola3d_con = hyperbola3d_fr.ConjugateBranch1();
		CHECK(hyperbola3d_con.Location().X() == Approx(0.0));
		CHECK(hyperbola3d_con.Location().Y() == Approx(0.0));
		CHECK(hyperbola3d_con.Location().Z() == Approx(1.0));
		Point3 point1(0.0, 4.0, 1.0);
		Point3 point2(9.0 / 4.0, 5.0, 1.0);
		MakeEdge edge1(hyperbola3d_con);
		CHECK(BRepClassificationTools::IsPointInOnEdge(edge1, point1, 0.001) == true);
		CHECK(BRepClassificationTools::IsPointInOnEdge(edge1, point2, 0.001) == true);
		double major3d_con = hyperbola3d_con.MajorRadius();
		double minor3d_con = hyperbola3d_con.MinorRadius();
		CHECK(major3d_con == Approx(4.0));
		CHECK(minor3d_con == Approx(3.0));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] HyperbolaS ConjugateBranch2()	 @return The negative conjugate hyperbola
	 @brief Get the conjugate hyperbola on the negative side of the minor axis
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <modeling/MakeFace.hpp>
#include <common/AxisT.hpp>
#include <math/HyperbolaT.hpp>
#include <occtio/OCCTTool.hpp>
#include <common/VectorT.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <topology/TopoEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <iostream>
using namespace AMCAX;
using namespace std;
TEST_CASE("case1:this is a case for Hyperbola3", "[math][Hyperbola3][p1]") {
	Point3 point3_fr(0.0, 0.0, 1.0);
	Direction3 dir3_fr(0.0, 0.0, 1.0);
	Frame3 frame3(point3_fr, dir3_fr);
	double major3 = 3.0, minor3 = 4.0;
	Hyperbola3 hyperbola3d_fr(frame3, major3, minor3);
	SECTION("ConjugateBranch2()") {		
		Hyperbola3 hyperbola3d_con = hyperbola3d_fr.ConjugateBranch2();
		CHECK(hyperbola3d_con.Location().X() == Approx(0.0));
		CHECK(hyperbola3d_con.Location().Y() == Approx(0.0));
		CHECK(hyperbola3d_con.Location().Z() == Approx(1.0));
		Point3 point1(0.0, -4.0, 1.0);
		Point3 point2(9.0 / 4.0, -5.0, 1.0);
		MakeEdge edge2(hyperbola3d_con);
		CHECK(BRepClassificationTools::IsPointInOnEdge(edge2, point1, 0.001) == true);
		CHECK(BRepClassificationTools::IsPointInOnEdge(edge2, point2, 0.001) == true);
		double major3d_con = hyperbola3d_con.MajorRadius();
		double minor3d_con = hyperbola3d_con.MinorRadius();
		CHECK(major3d_con == Approx(4.0));
		CHECK(minor3d_con == Approx(3.0));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":HyperbolaS& Scale(const PointT<double, DIM>& point, double scale)	 @return The reference to self
	 @param scale The scale value
	 @param point The scaling center point
	 @brief Scale the hyperbola by a center point
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <modeling/MakeFace.hpp>
#include <common/AxisT.hpp>
#include <math/HyperbolaT.hpp>
#include <occtio/OCCTTool.hpp>
#include <common/VectorT.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <topology/TopoEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <iostream>
using namespace AMCAX;
using namespace std;
TEST_CASE("case1:this is a case for Hyperbola3", "[math][Hyperbola3][p1]") {
	Point3 point3_fr(0.0, 0.0, 1.0);
	Direction3 dir3_fr(0.0, 0.0, 1.0);
	Frame3 frame3(point3_fr, dir3_fr);
	double major3 = 3.0, minor3 = 4.0;
	Hyperbola3 hyperbola3d_fr(frame3, major3, minor3);
	SECTION("Scale()") {		
		Point3 point1(0.0, 0.0, 1.0);
		hyperbola3d_fr.Scale(point1, 0.5);
		CHECK(hyperbola3d_fr.Location().X() == Approx(0.0));
		CHECK(hyperbola3d_fr.Location().Y() == Approx(0.0));
		CHECK(hyperbola3d_fr.Location().Z() == Approx(1.0));
		Point3 point2(1.5, 0.0, 1.0);
		MakeEdge edge1(hyperbola3d_fr);
		CHECK(BRepClassificationTools::IsPointInOnEdge(edge1, point2, 0.001) == true);
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAXMeshing_API void setTriMeshAsOutput(iPoints    &points, iTriangles &triangles),
 "output":#include<catch.hpp>
#include<testHelperBase.h>
#define AMCAXMeshing_Enable_CommonTraits
#define AMCAXMeshing_Disable_StandardTraits
#define AMCAXMeshing_Enable_EigenTraits
#include "mesh/io/OBJReader.hpp"
#include "mesh/io/OBJWriter.hpp"
#include "mesh/io/STLReader.hpp"
#include "mesh/io/STLWriter.hpp"
#include "meshModeling/MeshBoolean.hpp"
#include "meshModeling/TriMeshRepair.hpp"
#include "meshModeling/MeshParameterization.hpp"
using EIAC = AMCAX::Meshing::Geometry::EIAC;
using TriSoupTraits = AMCAX::Meshing::Mesh::TriSoupTraits_Coord;
using Points = typename TriSoupTraits::Points;
using Triangles = typename TriSoupTraits::Triangles;
using OBJReader = AMCAX::Meshing::Mesh::OBJReader<TriSoupTraits>;
using OBJWriter = AMCAX::Meshing::Mesh::OBJWriter<TriSoupTraits>;
using STLReader = AMCAX::Meshing::Mesh::STLReader<TriSoupTraits>;
using STLWriter = AMCAX::Meshing::Mesh::STLWriter<TriSoupTraits>;
using IOOptions = AMCAX::Meshing::Mesh::IOOptions;
using MeshBoolean = AMCAX::Meshing::Boolean::MeshBoolean<EIAC, TriSoupTraits>;
void read_mesh11(const std::string& filename, Points& points,Triangles& triangles, IOOptions& io_options)
{
	if (AMCAX::Meshing::ends_with(filename, ".obj"))
	{
		OBJReader reader;
		reader.read(filename, io_options);
		points = std::move(reader.m_points);
		triangles = std::move(reader.m_triangles);
	}
	else if (AMCAX::Meshing::ends_with(filename, ".stl"))
	{
		STLReader reader;
		reader.read(filename, io_options);
		points = std::move(reader.m_points);
		triangles = std::move(reader.m_triangles);
	}
}
void write_mesh11(const std::string& filename, const Points& points,const Triangles& triangles, IOOptions& io_options)
{
	OBJWriter writer;
	writer.m_points = std::move(points);
	writer.m_triangles = std::move(triangles);
	bool bWriteObj = writer.write(filename, io_options, 10);
	CHECK(bWriteObj == true);
};
TEST_CASE("case1: MeshBoolean_MeshBoolean  ", "[meshModeling][MeshBoolean][P1]")
{
	OUTPUT_DIRECTORY(Boolean, Boolean);
	IOOptions io_options;
	io_options.vertex_has_point = true;
	Points    points1, points2, result_points;
	Triangles triangles1, triangles2, result_triangles;
	read_mesh11(INPUT_PATH_PREFIX"./meshModeling_data/MeshBoolean_data/bunny25k.obj", points1, triangles1, io_options);
	read_mesh11(INPUT_PATH_PREFIX"./meshModeling_data/MeshBoolean_data/cow.obj", points2, triangles2, io_options);
	MeshBoolean boolean( true);
	boolean.addTriMeshAsInput(points1, triangles1);
	boolean.addTriMeshAsInput(points2, triangles2);
	boolean.setTriMeshAsOutput(result_points, result_triangles);
	boolean.computeLabels();
	{
		boolean.Union();
		make_file_writable(outdir + "AMCAXMeshing_Union.obj");
		write_mesh11(outdir + "AMCAXMeshing_Union.obj", result_points,
			result_triangles, io_options);
	}
	{
		boolean.Intersection();
		make_file_writable(outdir + "AMCAXMeshing_Intersection.obj");
		write_mesh11(outdir + "AMCAXMeshing_Intersection.obj", result_points,
			result_triangles, io_options);
	}
	{
		boolean.Xor();
		make_file_writable(outdir + "AMCAXMeshing_Xor.obj");
		write_mesh11(outdir + "AMCAXMeshing_Xor.obj", result_points, result_triangles,
			io_options);
	}
	{
		boolean.Subtraction();
		make_file_writable(outdir + "AMCAXMeshing_Subtraction.obj");
		write_mesh11(outdir + "AMCAXMeshing_Subtraction.obj", result_points,
			result_triangles, io_options);
	}
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAXMeshing_API void Union()	 @brief apply (3)UNION and (4)put result to output mesh.
,
 "output":#include<catch.hpp>
#include<testHelperBase.h>
#define AMCAXMeshing_Enable_CommonTraits
#define AMCAXMeshing_Disable_StandardTraits
#define AMCAXMeshing_Enable_EigenTraits
#include "mesh/io/OBJReader.hpp"
#include "mesh/io/OBJWriter.hpp"
#include "mesh/io/STLReader.hpp"
#include "mesh/io/STLWriter.hpp"
#include "meshModeling/MeshBoolean.hpp"
#include "meshModeling/TriMeshRepair.hpp"
#include "meshModeling/MeshParameterization.hpp"
using EIAC = AMCAX::Meshing::Geometry::EIAC;
using TriSoupTraits = AMCAX::Meshing::Mesh::TriSoupTraits_Coord;
using Points = typename TriSoupTraits::Points;
using Triangles = typename TriSoupTraits::Triangles;
using OBJReader = AMCAX::Meshing::Mesh::OBJReader<TriSoupTraits>;
using OBJWriter = AMCAX::Meshing::Mesh::OBJWriter<TriSoupTraits>;
using STLReader = AMCAX::Meshing::Mesh::STLReader<TriSoupTraits>;
using STLWriter = AMCAX::Meshing::Mesh::STLWriter<TriSoupTraits>;
using IOOptions = AMCAX::Meshing::Mesh::IOOptions;
using MeshBoolean = AMCAX::Meshing::Boolean::MeshBoolean<EIAC, TriSoupTraits>;
void read_mesh11(const std::string& filename, Points& points,Triangles& triangles, IOOptions& io_options)
{
	if (AMCAX::Meshing::ends_with(filename, ".obj"))
	{
		OBJReader reader;
		reader.read(filename, io_options);
		points = std::move(reader.m_points);
		triangles = std::move(reader.m_triangles);
	}
	else if (AMCAX::Meshing::ends_with(filename, ".stl"))
	{
		STLReader reader;
		reader.read(filename, io_options);
		points = std::move(reader.m_points);
		triangles = std::move(reader.m_triangles);
	}
}
void write_mesh11(const std::string& filename, const Points& points,const Triangles& triangles, IOOptions& io_options)
{
	OBJWriter writer;
	writer.m_points = std::move(points);
	writer.m_triangles = std::move(triangles);
	bool bWriteObj = writer.write(filename, io_options, 10);
	CHECK(bWriteObj == true);
};
TEST_CASE("case1: MeshBoolean_MeshBoolean  ", "[meshModeling][MeshBoolean][P1]")
{
	OUTPUT_DIRECTORY(Boolean, Boolean);
	IOOptions io_options;
	io_options.vertex_has_point = true;
	Points    points1, points2, result_points;
	Triangles triangles1, triangles2, result_triangles;
	read_mesh11(INPUT_PATH_PREFIX"./meshModeling_data/MeshBoolean_data/bunny25k.obj", points1, triangles1, io_options);
	read_mesh11(INPUT_PATH_PREFIX"./meshModeling_data/MeshBoolean_data/cow.obj", points2, triangles2, io_options);
	MeshBoolean boolean( true);
	boolean.addTriMeshAsInput(points1, triangles1);
	boolean.addTriMeshAsInput(points2, triangles2);
	boolean.setTriMeshAsOutput(result_points, result_triangles);
	boolean.computeLabels();
	{
		boolean.Union();
		make_file_writable(outdir + "AMCAXMeshing_Union.obj");
		write_mesh11(outdir + "AMCAXMeshing_Union.obj", result_points,
			result_triangles, io_options);
	}
	{
		boolean.Intersection();
		make_file_writable(outdir + "AMCAXMeshing_Intersection.obj");
		write_mesh11(outdir + "AMCAXMeshing_Intersection.obj", result_points,
			result_triangles, io_options);
	}
	{
		boolean.Xor();
		make_file_writable(outdir + "AMCAXMeshing_Xor.obj");
		write_mesh11(outdir + "AMCAXMeshing_Xor.obj", result_points, result_triangles,
			io_options);
	}
	{
		boolean.Subtraction();
		make_file_writable(outdir + "AMCAXMeshing_Subtraction.obj");
		write_mesh11(outdir + "AMCAXMeshing_Subtraction.obj", result_points,
			result_triangles, io_options);
	}
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAXMeshing_API void computeInterSegments()	 after computing labels.
	 @brief In order to obtain the intersection segments, we need call this
,
 "output":#include<catch.hpp>
#include<testHelperBase.h>
#define AMCAXMeshing_Enable_EigenTraits
#define AMCAXMeshing_Enable_CommonTraits
#define AMCAXMeshing_Disable_StandardTraits
#include "mesh/TriSoup.hpp"
#include "meshModeling/MeshBoolean.hpp"
#include "mesh/io/OBJReader.hpp"
#include "mesh/io/OBJWriter.hpp"
#include "mesh/io/STLReader.hpp"
#include "mesh/io/STLWriter.hpp"
#ifdef AMCAXMeshing_Enable_CommonTraits
using TriSoupTraits = AMCAX::Meshing::Mesh::TriSoupTraits_Coord;
#endif
using EIAC = AMCAX::Meshing::Geometry::EIAC;
using Points = typename TriSoupTraits::Points;
using Triangles = typename TriSoupTraits::Triangles;
using OBJReader = AMCAX::Meshing::Mesh::OBJReader<TriSoupTraits>;
using OBJWriter = AMCAX::Meshing::Mesh::OBJWriter<TriSoupTraits>;
using STLReader = AMCAX::Meshing::Mesh::STLReader<TriSoupTraits>;
using STLWriter = AMCAX::Meshing::Mesh::STLWriter<TriSoupTraits>;
using IOOptions = AMCAX::Meshing::Mesh::IOOptions;
using MeshBoolean = AMCAX::Meshing::Boolean::MeshBoolean<EIAC, TriSoupTraits>;
template <typename TriIndexT>
struct InterSegments
{
    using ti_t = TriIndexT;
    std::vector<ti_t> vertex_ids;
    bool closed;
};
void read_mesh2(const std::string& filename, Points& points,
    Triangles& triangles, IOOptions& io_options)
{
    if (AMCAX::Meshing::ends_with(filename, ".obj"))
    {
        OBJReader reader;
        reader.read(filename, io_options);
        points = std::move(reader.m_points);
        triangles = std::move(reader.m_triangles);
    }
    else if (AMCAX::Meshing::ends_with(filename, ".stl"))
    {
        STLReader reader;
        reader.read(filename, io_options);
        points = std::move(reader.m_points);
        triangles = std::move(reader.m_triangles);
    }
}
void write_mesh2(const std::string& filename, const Points& points,
    const Triangles& triangles, IOOptions& io_options)
{
    if (AMCAX::Meshing::ends_with(filename, ".obj"))
    {
        OBJWriter writer;
        writer.m_points = std::move(points);
        writer.m_triangles = std::move(triangles);
        writer.write(filename, io_options, 10);
    }
    else if (AMCAX::Meshing::ends_with(filename, ".stl"))
    {
        STLWriter writer;
        writer.m_points = std::move(points);
        writer.m_triangles = std::move(triangles);
        writer.write(filename, io_options, 10);
    }
};
TEST_CASE("bug2: MeshBoolean_InterSegments ", "[meshModeling][MeshBoolean_InterSegments][bug]")
{
    IOOptions io_options;
    io_options.vertex_has_point = true;
    Points      points1, points2, points3, result_points;
    Triangles   triangles1, triangles2, triangles3, result_triangles;
	SECTION("stl-stl-obj")
    {
        OUTPUT_DIRECTORY(MeshBoolean, InterSegments_stl);
        read_mesh2(INPUT_PATH_PREFIX"./meshModeling_data/MeshBoolean_data/cow1.stl", points1, triangles1, io_options);
        read_mesh2(INPUT_PATH_PREFIX"./meshModeling_data/MeshBoolean_data/bunny1.stl", points2, triangles2, io_options);
        read_mesh2(INPUT_PATH_PREFIX"./meshModeling_data/MeshBoolean_data/bunny1.obj", points3, triangles3, io_options);
        MeshBoolean boolean(true);
        boolean.addTriMeshAsInput(points1, triangles1);
        boolean.addTriMeshAsInput(points2, triangles2);
        boolean.addTriMeshAsInput(points3, triangles3);
        boolean.setTriMeshAsOutput(result_points, result_triangles);
        boolean.computeLabels();
        boolean.computeInterSegments();
        boolean.Subtraction();
        const auto& inter_segs = boolean.getInterSegments();
        for (size_t s_id = 0; s_id < inter_segs.size(); ++s_id)
        {
            std::ofstream ofs(outdir + "stl_" + std::to_string(s_id) + ".obj");
            size_t v_num = inter_segs[s_id].vertex_ids.size();
            ofs << "# v_num: " << v_num << std::endl;
            size_t l_num = inter_segs[s_id].closed ? inter_segs[s_id].vertex_ids.size() : inter_segs[s_id].vertex_ids.size() - 1;
            ofs << "# l_num: " << l_num << std::endl;
            ofs << std::endl;
            for (auto v_id : inter_segs[s_id].vertex_ids)
            {
                ofs << "v " << result_points[v_id].x() << " " << result_points[v_id].y() << " " << result_points[v_id].z() << std::endl;
            }
            ofs << std::endl;
            for (size_t i = 0; i < inter_segs[s_id].vertex_ids.size() - 1; ++i)
            {
                ofs << "l " << i + 1 << " " << i + 2 << std::endl;
            }
            if (inter_segs[s_id].closed)
            {
                ofs << "l " << inter_segs[s_id].vertex_ids.size() << " " << 1 << std::endl;
            }
            ofs.close();
            write_mesh2(outdir + "InterSubtraction.stl", result_points, result_triangles, io_options);
        }
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAXMeshing_API std::vector<InterSegments> & getInterSegments(),
 "output":#include<catch.hpp>
#include<testHelperBase.h>
#define AMCAXMeshing_Enable_EigenTraits
#define AMCAXMeshing_Enable_CommonTraits
#define AMCAXMeshing_Disable_StandardTraits
#include "mesh/TriSoup.hpp"
#include "meshModeling/MeshBoolean.hpp"
#include "mesh/io/OBJReader.hpp"
#include "mesh/io/OBJWriter.hpp"
#include "mesh/io/STLReader.hpp"
#include "mesh/io/STLWriter.hpp"
#ifdef AMCAXMeshing_Enable_CommonTraits
using TriSoupTraits = AMCAX::Meshing::Mesh::TriSoupTraits_Coord;
#endif
using EIAC = AMCAX::Meshing::Geometry::EIAC;
using Points = typename TriSoupTraits::Points;
using Triangles = typename TriSoupTraits::Triangles;
using OBJReader = AMCAX::Meshing::Mesh::OBJReader<TriSoupTraits>;
using OBJWriter = AMCAX::Meshing::Mesh::OBJWriter<TriSoupTraits>;
using STLReader = AMCAX::Meshing::Mesh::STLReader<TriSoupTraits>;
using STLWriter = AMCAX::Meshing::Mesh::STLWriter<TriSoupTraits>;
using IOOptions = AMCAX::Meshing::Mesh::IOOptions;
using MeshBoolean = AMCAX::Meshing::Boolean::MeshBoolean<EIAC, TriSoupTraits>;
template <typename TriIndexT>
struct InterSegments
{
    using ti_t = TriIndexT;
    std::vector<ti_t> vertex_ids;
    bool closed;
};
void read_mesh2(const std::string& filename, Points& points,
    Triangles& triangles, IOOptions& io_options)
{
    if (AMCAX::Meshing::ends_with(filename, ".obj"))
    {
        OBJReader reader;
        reader.read(filename, io_options);
        points = std::move(reader.m_points);
        triangles = std::move(reader.m_triangles);
    }
    else if (AMCAX::Meshing::ends_with(filename, ".stl"))
    {
        STLReader reader;
        reader.read(filename, io_options);
        points = std::move(reader.m_points);
        triangles = std::move(reader.m_triangles);
    }
}
void write_mesh2(const std::string& filename, const Points& points,
    const Triangles& triangles, IOOptions& io_options)
{
    if (AMCAX::Meshing::ends_with(filename, ".obj"))
    {
        OBJWriter writer;
        writer.m_points = std::move(points);
        writer.m_triangles = std::move(triangles);
        writer.write(filename, io_options, 10);
    }
    else if (AMCAX::Meshing::ends_with(filename, ".stl"))
    {
        STLWriter writer;
        writer.m_points = std::move(points);
        writer.m_triangles = std::move(triangles);
        writer.write(filename, io_options, 10);
    }
};
TEST_CASE("bug1: MeshBoolean_InterSegments ", "[meshModeling][MeshBoolean_InterSegments][bug]")
{
    OUTPUT_DIRECTORY(MeshBoolean, InterSegments_bug);
    IOOptions io_options;
    io_options.vertex_has_point = true;
    Points      points1, points2, points3, points11, points22, points33, result_points, result_points11;
    Triangles   triangles1, triangles2, triangles3, triangles11, triangles22, triangles33, result_triangles, result_triangles11;
    read_mesh2(INPUT_PATH_PREFIX"./meshModeling_data/MeshBoolean_data/cow1.stl", points1, triangles1, io_options);
    read_mesh2(INPUT_PATH_PREFIX"./meshModeling_data/MeshBoolean_data/bunny1.stl", points2, triangles2, io_options);
    read_mesh2(INPUT_PATH_PREFIX"./meshModeling_data/MeshBoolean_data/cow1.stl", points3, triangles3, io_options);
    read_mesh2(INPUT_PATH_PREFIX"./meshModeling_data/MeshBoolean_data/cow1.obj", points11, triangles11, io_options);
    read_mesh2(INPUT_PATH_PREFIX"./meshModeling_data/MeshBoolean_data/bunny1.obj", points22, triangles22, io_options);
    read_mesh2(INPUT_PATH_PREFIX"./meshModeling_data/MeshBoolean_data/cow1.obj", points33, triangles33, io_options);
    MeshBoolean boolean(true);
    MeshBoolean boolean11(true);
    boolean.addTriMeshAsInput(points1, triangles1);
    boolean.addTriMeshAsInput(points2, triangles2);
    boolean.addTriMeshAsInput(points3, triangles3);
    boolean.setTriMeshAsOutput(result_points, result_triangles);
    boolean.computeLabels();
    boolean.computeInterSegments();
    boolean.Subtraction();
    boolean11.addTriMeshAsInput(points11, triangles11);
    boolean11.addTriMeshAsInput(points22, triangles22);
    boolean11.addTriMeshAsInput(points33, triangles33);
    boolean11.setTriMeshAsOutput(result_points11, result_triangles11);
    boolean11.computeLabels();
    boolean11.computeInterSegments();
    boolean11.Subtraction();
    const auto& inter_segs = boolean.getInterSegments();
    const auto& inter_segs11 = boolean11.getInterSegments();
    for (size_t s_id = 0; s_id < inter_segs.size(); ++s_id)
    {
        std::ofstream ofs(outdir + "stl_"+std::to_string(s_id) + ".obj");
        size_t v_num = inter_segs[s_id].vertex_ids.size();
        ofs << "# v_num: " << v_num << std::endl;
        size_t l_num = inter_segs[s_id].closed ? inter_segs[s_id].vertex_ids.size() : inter_segs[s_id].vertex_ids.size() - 1;
        ofs << "# l_num: " << l_num << std::endl;
        ofs << std::endl;
        for (auto v_id : inter_segs[s_id].vertex_ids)
        {
            ofs << "v " << result_points[v_id].x() << " " << result_points[v_id].y() << " " << result_points[v_id].z() << std::endl;
        }
        ofs << std::endl;
        for (size_t i = 0; i < inter_segs[s_id].vertex_ids.size() - 1; ++i)
        {
            ofs << "l " << i + 1 << " " << i + 2 << std::endl;
        }
        if (inter_segs[s_id].closed)
        {
            ofs << "l " << inter_segs[s_id].vertex_ids.size() << " " << 1 << std::endl;
        }
        ofs.close();
        write_mesh2(outdir + "InterSubtraction.stl", result_points, result_triangles, io_options);
    }
    for (size_t s_id = 0; s_id < inter_segs11.size(); ++s_id)
    {
        std::ofstream ofs(outdir + "obj_"+std::to_string(s_id) + ".obj");
        size_t v_num = inter_segs11[s_id].vertex_ids.size();
        ofs << "# v_num: " << v_num << std::endl;
        size_t l_num = inter_segs11[s_id].closed ? inter_segs11[s_id].vertex_ids.size() : inter_segs11[s_id].vertex_ids.size() - 1;
        ofs << "# l_num: " << l_num << std::endl;
        ofs << std::endl;
        for (auto v_id : inter_segs11[s_id].vertex_ids)
        {
            ofs << "v " << result_points11[v_id].x() << " " << result_points11[v_id].y() << " " << result_points11[v_id].z() << std::endl;
        }
        ofs << std::endl;
        for (size_t i = 0; i < inter_segs11[s_id].vertex_ids.size() - 1; ++i)
        {
            ofs << "l " << i + 1 << " " << i + 2 << std::endl;
        }
        if (inter_segs11[s_id].closed)
        {
            ofs << "l " << inter_segs11[s_id].vertex_ids.size() << " " << 1 << std::endl;
        }
        ofs.close();
        write_mesh2(outdir + "InterSubtraction.obj", result_points11, result_triangles11, io_options);
    }
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API explicit GeneralTransformShape(const GeneralTransformation3& t)	 @param t The general transformation
	 @brief Construct from a general transformation
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <modeling/MakeSphere.hpp>
#include <modeling/TransformShape.hpp>
#include <topomesh/BRepMeshIncrementalMesh.hpp>
#include <modeling/MakeShapeTool.hpp>
#include <common/TransformationT.hpp>
#include <common/CartesianCoordinateSystem.hpp>
#include <common/GeneralTransformationT.hpp>
#include <modeling/GeneralTransformShape.hpp>
#include <geometry/GlobalProperty.hpp>
#include <occtio/OCCTTool.hpp>
#include <topology/BRepGlobalProperty.hpp>
#include <geometry/Geom3BSplineCurve.hpp>
#include <modeling/MakeEdge.hpp>
#include <topology/TopoTool.hpp>
#include <topology/BRepAdaptorCurve3.hpp>
using namespace AMCAX;
TEST_CASE("bug1: GeneralTransformShape  ", "[modeling][GeneralTransformShape][fixbug]") {
	TopoShape s = MakeSphere(1.0);
	BRepMeshIncrementalMesh mesher(s, 0.005, true);
	MakeShapeTool::EnsureNormalConsistency(s);
	GeneralTransformation3 tr;
	tr.SetAffinity(Frame3(), 5.0);
	s = GeneralTransformShape(s, tr);
	CHECK(s.Type() == AMCAX::ShapeType::Solid);
	CHECK(s.IsNull() == false);
	GlobalProperty prop;
	BRepGlobalProperty::VolumeProperties(s, prop);
	CHECK(prop.Mass() == Approx(20.934791259).epsilon(1e-11));
	Point3 vP = prop.CenterOfMass();
#ifndef WIN_CASE
	CHECK(vP.X() == Approx(0.0).margin(1e-3));
	CHECK(vP.Y() == Approx(0.0).margin(1e-12));
	CHECK(vP.Z() == Approx(0.0).margin(1e-12));
#else
	CHECK(vP.X() == Approx(-2.2218808037914858e-04).epsilon(1e-12));
	CHECK(vP.Y() == Approx(-1.0782779568197278e-16).epsilon(1e-12));
	CHECK(vP.Z() == Approx(-1.6920954211916623e-16).epsilon(1e-12));
#endif
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API GeneralTransformShape(const TopoShape& s, const GeneralTransformation3& t, bool copy = false)	 @param copy Whether the geometry of the shape is copied
	 @param t The general transformation
	 @param s The shape
	 @brief Transform a shape by a general transformation
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <modeling/MakeSphere.hpp>
#include <modeling/TransformShape.hpp>
#include <topomesh/BRepMeshIncrementalMesh.hpp>
#include <modeling/MakeShapeTool.hpp>
#include <common/TransformationT.hpp>
#include <common/CartesianCoordinateSystem.hpp>
#include <common/GeneralTransformationT.hpp>
#include <modeling/GeneralTransformShape.hpp>
#include <geometry/GlobalProperty.hpp>
#include <occtio/OCCTTool.hpp>
#include <topology/BRepGlobalProperty.hpp>
#include <geometry/Geom3BSplineCurve.hpp>
#include <modeling/MakeEdge.hpp>
#include <topology/TopoTool.hpp>
#include <topology/BRepAdaptorCurve3.hpp>
using namespace AMCAX;
TEST_CASE("bug1: GeneralTransformShape  ", "[modeling][GeneralTransformShape][fixbug]") {
	TopoShape s = MakeSphere(1.0);
	BRepMeshIncrementalMesh mesher(s, 0.005, true);
	MakeShapeTool::EnsureNormalConsistency(s);
	GeneralTransformation3 tr;
	tr.SetAffinity(Frame3(), 5.0);
	s = GeneralTransformShape(s, tr);
	CHECK(s.Type() == AMCAX::ShapeType::Solid);
	CHECK(s.IsNull() == false);
	GlobalProperty prop;
	BRepGlobalProperty::VolumeProperties(s, prop);
	CHECK(prop.Mass() == Approx(20.934791259).epsilon(1e-11));
	Point3 vP = prop.CenterOfMass();
#ifndef WIN_CASE
	CHECK(vP.X() == Approx(0.0).margin(1e-3));
	CHECK(vP.Y() == Approx(0.0).margin(1e-12));
	CHECK(vP.Z() == Approx(0.0).margin(1e-12));
#else
	CHECK(vP.X() == Approx(-2.2218808037914858e-04).epsilon(1e-12));
	CHECK(vP.Y() == Approx(-1.0782779568197278e-16).epsilon(1e-12));
	CHECK(vP.Z() == Approx(-1.6920954211916623e-16).epsilon(1e-12));
#endif
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API MakeBox(double dx, double dy, double dz)	 @param dx,dy,dz The size
	 @brief Construct from its size in x, y, z directions
,
 "output":#include <modeling/MakeBox.hpp>
#include<catch.hpp>
#include<testHelper.h>
#include <modeling/MakeBox.hpp>
#include <modeling/MakeCylinder.hpp>
#include <topology/BRepExtremaProximityTool.hpp>
#include <io/OBJTool.hpp>
#include <topology/TopoFace.hpp>
#include <modeling/TransformShape.hpp>
#include <topology/TopoExplorerTool.hpp>
#include <modeling/MakeTorus.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
using namespace AMCAX;
TEST_CASE("case1:this is a case for MakeBox", "[MakeBox1]")
{
	SECTION("Box1") {
		OUTPUT_DIRECTORY(topology, OverlapFaces);
		MakeBox box(3.0, 2.0,2.0);
		TopoShape box2= box.Shape();
		box.Init(4.0, 5.0, 6.0);
		TopoFace shape = box.XMinFace(); 
		TopoFace shape1 = box.ZMinFace(); 
		TopoShape shape2 = box; 
		TopoShape shapeV = box;
		AMCAX::GlobalProperty prop1;
		double s_sahpe = GetSurfaceProperties(shape, prop1, true, false);
		double s_sahpe1 = GetSurfaceProperties(shape1, prop1, true, false);
		double s_sahpe2 = GetSurfaceProperties(shape2, prop1, true, false);
		double v_sahpe = GetVolumeProperties(shapeV, prop1, true, false);
		CHECK(s_sahpe == Approx(30.0).margin(1e-12));
		CHECK(s_sahpe1 == Approx(20.0).margin(1e-12));
		CHECK(s_sahpe2 == Approx(148.0).margin(1e-12));
		CHECK(v_sahpe == Approx(120.0).margin(1e-12));
		CHECK( OCCTIO::OCCTTool::Write(box, outdir + "MakeBox1.brep"));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API MakeBox(const Point3& p, double dx, double dy, double dz)	 @param dx,dy,dz The size
	 @param p The corner point
	 @brief Construct from a corner point and its size
,
 "output":#include <modeling/MakeBox.hpp>
#include<catch.hpp>
#include<testHelper.h>
#include <modeling/MakeBox.hpp>
#include <modeling/MakeCylinder.hpp>
#include <topology/BRepExtremaProximityTool.hpp>
#include <io/OBJTool.hpp>
#include <topology/TopoFace.hpp>
#include <modeling/TransformShape.hpp>
#include <topology/TopoExplorerTool.hpp>
#include <modeling/MakeTorus.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
using namespace AMCAX;
TEST_CASE("case1:this is a case for MakeBox", "[MakeBox1]")
{
	SECTION("Box3")
	{
		OUTPUT_DIRECTORY(topology, OverlapFaces);
		MakeBox box2(Point3(-2.0, -2.0, -2.0), Point3(2.0,2.0,2.0));
		MakeBox box3;
		box3.Init(Point3(-2.0, -2.0, -2.0), Point3(2.0, 2.0, 2.0));
		TopoFace shape1 = box2.XMinFace();
		TopoFace shape2 = box2.XMaxFace();
		TopoFace shape3 = box2.YMinFace();
		TopoFace shape4 = box2.YMaxFace();
		TopoFace shape5 = box2.ZMinFace();
		TopoFace shape6 = box2.ZMaxFace();
		TopoShape shape = box2;
		TopoFace shape_1 = box3.XMinFace();
		TopoFace shape_2 = box3.XMaxFace();
		TopoFace shape_3 = box3.YMinFace();
		TopoFace shape_4 = box3.YMaxFace();
		TopoFace shape_5 = box3.ZMinFace();
		TopoFace shape_6 = box3.ZMaxFace();
		AMCAX::GlobalProperty prop1;
		double s_sahpe1 = GetSurfaceProperties(shape1, prop1, true, false);
		double s_sahpe2 = GetSurfaceProperties(shape2, prop1, true, false);
		double s_sahpe3 = GetSurfaceProperties(shape3, prop1, true, false);
		double s_sahpe4 = GetSurfaceProperties(shape4, prop1, true, false);
		double s_sahpe5 = GetSurfaceProperties(shape5, prop1, true, false);
		double s_sahpe6 = GetSurfaceProperties(shape6, prop1, true, false);
		double s_sahpe = GetSurfaceProperties(shape, prop1, true, false);
		double v_sahpe = GetVolumeProperties(shape, prop1, true, false);
		BRepClassificationTools brep;
		bool r1 = brep.IsPointInOnFace(shape1, Point3(-2.0, 0.0, 0.0), -1.0);
		bool r2 = brep.IsPointInOnFace(shape2, Point3(2.0, 0.0, 0.0), -1.0);
		bool r3 = brep.IsPointInOnFace(shape3, Point3(0.0, -2.0, 0.0), -1.0);
		bool r33 = brep.IsPointInOnFace(shape3, Point3(1.0, 0.5, 3.0), -1.0);
		bool r4 = brep.IsPointInOnFace(shape4, Point3(0.0, 2.0, 0.0), -1.0);
		bool r5 = brep.IsPointInOnFace(shape5, Point3(0.0, 0.0, -2.0), -1.0);
		bool r6 = brep.IsPointInOnFace(shape6, Point3(0.0, 0.0, 2.0), -1.0);
		double s_shape_1 = GetSurfaceProperties(shape_1, prop1, true, false);
		double s_shape_2 = GetSurfaceProperties(shape_2, prop1, true, false);
		double s_shape_3 = GetSurfaceProperties(shape_3, prop1, true, false);
		double s_shape_4 = GetSurfaceProperties(shape_4, prop1, true, false);
		double s_shape_5 = GetSurfaceProperties(shape_5, prop1, true, false);
		double s_shape_6 = GetSurfaceProperties(shape_6, prop1, true, false);
		bool r_1 = brep.IsPointInOnFace(shape_1, Point3(-2.0, 0.0, 0.0), -1.0);
		bool r_2 = brep.IsPointInOnFace(shape_2, Point3(2.0, 0.0, 0.0), -1.0);
		bool r_3 = brep.IsPointInOnFace(shape_3, Point3(0.0, -2.0, 0.0), -1.0);
		bool r_33 = brep.IsPointInOnFace(shape_3, Point3(1.0, 0.5, 3.0), -1.0);
		bool r_4 = brep.IsPointInOnFace(shape_4, Point3(0.0, 2.0, 0.0), -1.0);
		bool r_5 = brep.IsPointInOnFace(shape_5, Point3(0.0, 0.0, -2.0), -1.0);
		bool r_6 = brep.IsPointInOnFace(shape_6, Point3(0.0, 0.0, 2.0), -1.0);
		CHECK(s_sahpe1 == Approx(16.0).margin(1e-12));
		CHECK(s_sahpe2 == Approx(16.0).margin(1e-12));
		CHECK(s_sahpe3 == Approx(16.0).margin(1e-12));
		CHECK(s_sahpe4 == Approx(16.0).margin(1e-12));
		CHECK(s_sahpe5 == Approx(16.0).margin(1e-12));
		CHECK(s_sahpe6 == Approx(16.0).margin(1e-12));
		CHECK(v_sahpe == Approx(64.0).margin(1e-12));
		CHECK(s_sahpe == s_sahpe1 + s_sahpe2 + s_sahpe3 + s_sahpe4 + s_sahpe5 + s_sahpe6);
		CHECK(s_sahpe1 == s_shape_1);
		CHECK(s_sahpe2 == s_shape_2);
		CHECK(s_sahpe3 == s_shape_3);
		CHECK(s_sahpe4 == s_shape_4);
		CHECK(s_sahpe5 == s_shape_5);
		CHECK(s_sahpe6 == s_shape_6);
		CHECK(r1 == true);
		CHECK(r2 == true);
		CHECK(r3 == true);
		CHECK(r33 == false);
		CHECK(r4 == true);
		CHECK(r5 == true);
		CHECK(r6 == true);
		CHECK(r_1 == true);
		CHECK(r_2 == true);
		CHECK(r_3 == true);
		CHECK(r_33 == false);
		CHECK(r_4 == true);
		CHECK(r_5 == true);
		CHECK(r_6 == true);
		CHECK(OCCTIO::OCCTTool::Write(box2, outdir + "MakeBox3.brep"));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API MakeBox(const Point3& p1, const Point3& p2)	 @param p2 The second point
	 @param p1 The first point
	 @brief Construct from two diagonal corner points
,
 "output":#include <modeling/MakeBox.hpp>
#include<catch.hpp>
#include<testHelper.h>
#include <modeling/MakeBox.hpp>
#include <modeling/MakeCylinder.hpp>
#include <topology/BRepExtremaProximityTool.hpp>
#include <io/OBJTool.hpp>
#include <topology/TopoFace.hpp>
#include <modeling/TransformShape.hpp>
#include <topology/TopoExplorerTool.hpp>
#include <modeling/MakeTorus.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
using namespace AMCAX;
TEST_CASE("case1:this is a case for MakeBox", "[MakeBox1]")
{
	SECTION("Box3")
	{
		OUTPUT_DIRECTORY(topology, OverlapFaces);
		MakeBox box2(Point3(-2.0, -2.0, -2.0), Point3(2.0,2.0,2.0));
		MakeBox box3;
		box3.Init(Point3(-2.0, -2.0, -2.0), Point3(2.0, 2.0, 2.0));
		TopoFace shape1 = box2.XMinFace();
		TopoFace shape2 = box2.XMaxFace();
		TopoFace shape3 = box2.YMinFace();
		TopoFace shape4 = box2.YMaxFace();
		TopoFace shape5 = box2.ZMinFace();
		TopoFace shape6 = box2.ZMaxFace();
		TopoShape shape = box2;
		TopoFace shape_1 = box3.XMinFace();
		TopoFace shape_2 = box3.XMaxFace();
		TopoFace shape_3 = box3.YMinFace();
		TopoFace shape_4 = box3.YMaxFace();
		TopoFace shape_5 = box3.ZMinFace();
		TopoFace shape_6 = box3.ZMaxFace();
		AMCAX::GlobalProperty prop1;
		double s_sahpe1 = GetSurfaceProperties(shape1, prop1, true, false);
		double s_sahpe2 = GetSurfaceProperties(shape2, prop1, true, false);
		double s_sahpe3 = GetSurfaceProperties(shape3, prop1, true, false);
		double s_sahpe4 = GetSurfaceProperties(shape4, prop1, true, false);
		double s_sahpe5 = GetSurfaceProperties(shape5, prop1, true, false);
		double s_sahpe6 = GetSurfaceProperties(shape6, prop1, true, false);
		double s_sahpe = GetSurfaceProperties(shape, prop1, true, false);
		double v_sahpe = GetVolumeProperties(shape, prop1, true, false);
		BRepClassificationTools brep;
		bool r1 = brep.IsPointInOnFace(shape1, Point3(-2.0, 0.0, 0.0), -1.0);
		bool r2 = brep.IsPointInOnFace(shape2, Point3(2.0, 0.0, 0.0), -1.0);
		bool r3 = brep.IsPointInOnFace(shape3, Point3(0.0, -2.0, 0.0), -1.0);
		bool r33 = brep.IsPointInOnFace(shape3, Point3(1.0, 0.5, 3.0), -1.0);
		bool r4 = brep.IsPointInOnFace(shape4, Point3(0.0, 2.0, 0.0), -1.0);
		bool r5 = brep.IsPointInOnFace(shape5, Point3(0.0, 0.0, -2.0), -1.0);
		bool r6 = brep.IsPointInOnFace(shape6, Point3(0.0, 0.0, 2.0), -1.0);
		double s_shape_1 = GetSurfaceProperties(shape_1, prop1, true, false);
		double s_shape_2 = GetSurfaceProperties(shape_2, prop1, true, false);
		double s_shape_3 = GetSurfaceProperties(shape_3, prop1, true, false);
		double s_shape_4 = GetSurfaceProperties(shape_4, prop1, true, false);
		double s_shape_5 = GetSurfaceProperties(shape_5, prop1, true, false);
		double s_shape_6 = GetSurfaceProperties(shape_6, prop1, true, false);
		bool r_1 = brep.IsPointInOnFace(shape_1, Point3(-2.0, 0.0, 0.0), -1.0);
		bool r_2 = brep.IsPointInOnFace(shape_2, Point3(2.0, 0.0, 0.0), -1.0);
		bool r_3 = brep.IsPointInOnFace(shape_3, Point3(0.0, -2.0, 0.0), -1.0);
		bool r_33 = brep.IsPointInOnFace(shape_3, Point3(1.0, 0.5, 3.0), -1.0);
		bool r_4 = brep.IsPointInOnFace(shape_4, Point3(0.0, 2.0, 0.0), -1.0);
		bool r_5 = brep.IsPointInOnFace(shape_5, Point3(0.0, 0.0, -2.0), -1.0);
		bool r_6 = brep.IsPointInOnFace(shape_6, Point3(0.0, 0.0, 2.0), -1.0);
		CHECK(s_sahpe1 == Approx(16.0).margin(1e-12));
		CHECK(s_sahpe2 == Approx(16.0).margin(1e-12));
		CHECK(s_sahpe3 == Approx(16.0).margin(1e-12));
		CHECK(s_sahpe4 == Approx(16.0).margin(1e-12));
		CHECK(s_sahpe5 == Approx(16.0).margin(1e-12));
		CHECK(s_sahpe6 == Approx(16.0).margin(1e-12));
		CHECK(v_sahpe == Approx(64.0).margin(1e-12));
		CHECK(s_sahpe == s_sahpe1 + s_sahpe2 + s_sahpe3 + s_sahpe4 + s_sahpe5 + s_sahpe6);
		CHECK(s_sahpe1 == s_shape_1);
		CHECK(s_sahpe2 == s_shape_2);
		CHECK(s_sahpe3 == s_shape_3);
		CHECK(s_sahpe4 == s_shape_4);
		CHECK(s_sahpe5 == s_shape_5);
		CHECK(s_sahpe6 == s_shape_6);
		CHECK(r1 == true);
		CHECK(r2 == true);
		CHECK(r3 == true);
		CHECK(r33 == false);
		CHECK(r4 == true);
		CHECK(r5 == true);
		CHECK(r6 == true);
		CHECK(r_1 == true);
		CHECK(r_2 == true);
		CHECK(r_3 == true);
		CHECK(r_33 == false);
		CHECK(r_4 == true);
		CHECK(r_5 == true);
		CHECK(r_6 == true);
		CHECK(OCCTIO::OCCTTool::Write(box2, outdir + "MakeBox3.brep"));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API MakeBox(const Frame3& frame, double dx, double dy, double dz)	 @param dx,dy,dz The size
	 @param frame The local coordinate system
	 @brief Construct from a local coordinate system and size
,
 "output":#include <modeling/MakeBox.hpp>
#include<catch.hpp>
#include<testHelper.h>
#include <modeling/MakeBox.hpp>
#include <modeling/MakeCylinder.hpp>
#include <topology/BRepExtremaProximityTool.hpp>
#include <io/OBJTool.hpp>
#include <topology/TopoFace.hpp>
#include <modeling/TransformShape.hpp>
#include <topology/TopoExplorerTool.hpp>
#include <modeling/MakeTorus.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
using namespace AMCAX;
TEST_CASE("case1:this is a case for MakeBox", "[MakeBox1]")
{
	SECTION("Box3")
	{
		OUTPUT_DIRECTORY(topology, OverlapFaces);
		MakeBox box2(Point3(-2.0, -2.0, -2.0), Point3(2.0,2.0,2.0));
		MakeBox box3;
		box3.Init(Point3(-2.0, -2.0, -2.0), Point3(2.0, 2.0, 2.0));
		TopoFace shape1 = box2.XMinFace();
		TopoFace shape2 = box2.XMaxFace();
		TopoFace shape3 = box2.YMinFace();
		TopoFace shape4 = box2.YMaxFace();
		TopoFace shape5 = box2.ZMinFace();
		TopoFace shape6 = box2.ZMaxFace();
		TopoShape shape = box2;
		TopoFace shape_1 = box3.XMinFace();
		TopoFace shape_2 = box3.XMaxFace();
		TopoFace shape_3 = box3.YMinFace();
		TopoFace shape_4 = box3.YMaxFace();
		TopoFace shape_5 = box3.ZMinFace();
		TopoFace shape_6 = box3.ZMaxFace();
		AMCAX::GlobalProperty prop1;
		double s_sahpe1 = GetSurfaceProperties(shape1, prop1, true, false);
		double s_sahpe2 = GetSurfaceProperties(shape2, prop1, true, false);
		double s_sahpe3 = GetSurfaceProperties(shape3, prop1, true, false);
		double s_sahpe4 = GetSurfaceProperties(shape4, prop1, true, false);
		double s_sahpe5 = GetSurfaceProperties(shape5, prop1, true, false);
		double s_sahpe6 = GetSurfaceProperties(shape6, prop1, true, false);
		double s_sahpe = GetSurfaceProperties(shape, prop1, true, false);
		double v_sahpe = GetVolumeProperties(shape, prop1, true, false);
		BRepClassificationTools brep;
		bool r1 = brep.IsPointInOnFace(shape1, Point3(-2.0, 0.0, 0.0), -1.0);
		bool r2 = brep.IsPointInOnFace(shape2, Point3(2.0, 0.0, 0.0), -1.0);
		bool r3 = brep.IsPointInOnFace(shape3, Point3(0.0, -2.0, 0.0), -1.0);
		bool r33 = brep.IsPointInOnFace(shape3, Point3(1.0, 0.5, 3.0), -1.0);
		bool r4 = brep.IsPointInOnFace(shape4, Point3(0.0, 2.0, 0.0), -1.0);
		bool r5 = brep.IsPointInOnFace(shape5, Point3(0.0, 0.0, -2.0), -1.0);
		bool r6 = brep.IsPointInOnFace(shape6, Point3(0.0, 0.0, 2.0), -1.0);
		double s_shape_1 = GetSurfaceProperties(shape_1, prop1, true, false);
		double s_shape_2 = GetSurfaceProperties(shape_2, prop1, true, false);
		double s_shape_3 = GetSurfaceProperties(shape_3, prop1, true, false);
		double s_shape_4 = GetSurfaceProperties(shape_4, prop1, true, false);
		double s_shape_5 = GetSurfaceProperties(shape_5, prop1, true, false);
		double s_shape_6 = GetSurfaceProperties(shape_6, prop1, true, false);
		bool r_1 = brep.IsPointInOnFace(shape_1, Point3(-2.0, 0.0, 0.0), -1.0);
		bool r_2 = brep.IsPointInOnFace(shape_2, Point3(2.0, 0.0, 0.0), -1.0);
		bool r_3 = brep.IsPointInOnFace(shape_3, Point3(0.0, -2.0, 0.0), -1.0);
		bool r_33 = brep.IsPointInOnFace(shape_3, Point3(1.0, 0.5, 3.0), -1.0);
		bool r_4 = brep.IsPointInOnFace(shape_4, Point3(0.0, 2.0, 0.0), -1.0);
		bool r_5 = brep.IsPointInOnFace(shape_5, Point3(0.0, 0.0, -2.0), -1.0);
		bool r_6 = brep.IsPointInOnFace(shape_6, Point3(0.0, 0.0, 2.0), -1.0);
		CHECK(s_sahpe1 == Approx(16.0).margin(1e-12));
		CHECK(s_sahpe2 == Approx(16.0).margin(1e-12));
		CHECK(s_sahpe3 == Approx(16.0).margin(1e-12));
		CHECK(s_sahpe4 == Approx(16.0).margin(1e-12));
		CHECK(s_sahpe5 == Approx(16.0).margin(1e-12));
		CHECK(s_sahpe6 == Approx(16.0).margin(1e-12));
		CHECK(v_sahpe == Approx(64.0).margin(1e-12));
		CHECK(s_sahpe == s_sahpe1 + s_sahpe2 + s_sahpe3 + s_sahpe4 + s_sahpe5 + s_sahpe6);
		CHECK(s_sahpe1 == s_shape_1);
		CHECK(s_sahpe2 == s_shape_2);
		CHECK(s_sahpe3 == s_shape_3);
		CHECK(s_sahpe4 == s_shape_4);
		CHECK(s_sahpe5 == s_shape_5);
		CHECK(s_sahpe6 == s_shape_6);
		CHECK(r1 == true);
		CHECK(r2 == true);
		CHECK(r3 == true);
		CHECK(r33 == false);
		CHECK(r4 == true);
		CHECK(r5 == true);
		CHECK(r6 == true);
		CHECK(r_1 == true);
		CHECK(r_2 == true);
		CHECK(r_3 == true);
		CHECK(r_33 == false);
		CHECK(r_4 == true);
		CHECK(r_5 == true);
		CHECK(r_6 == true);
		CHECK(OCCTIO::OCCTTool::Write(box2, outdir + "MakeBox3.brep"));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API const TopoFace& XMinFace()	 @return The X-min face
	 @brief Get the face on X minimum
,
 "output":#include <modeling/MakeBox.hpp>
#include<catch.hpp>
#include<testHelper.h>
#include <modeling/MakeBox.hpp>
#include <modeling/MakeCylinder.hpp>
#include <topology/BRepExtremaProximityTool.hpp>
#include <io/OBJTool.hpp>
#include <topology/TopoFace.hpp>
#include <modeling/TransformShape.hpp>
#include <topology/TopoExplorerTool.hpp>
#include <modeling/MakeTorus.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
using namespace AMCAX;
TEST_CASE(" bug1:  ","[MakeBox][p1][fixbug]")
{
		OUTPUT_DIRECTORY(topology, OverlapFaces);
		MakeBox box(3.0, 2.0, 2.0);
		TopoShape box2 = box.Shape();
		box.Init(4.0, 5.0, 6.0);
		TopoFace shape = box.XMinFace();
		TopoFace shape1 = box.ZMinFace();
		TopoShape shape2 = box;
		TopoShape shapeV = box;
		AMCAX::GlobalProperty prop1;
		double s_sahpe = GetSurfaceProperties(shape, prop1, true, false);
		double s_sahpe1 = GetSurfaceProperties(shape1, prop1, true, false);
		double s_sahpe2 = GetSurfaceProperties(shape2, prop1, true, false);
		double v_sahpe = GetVolumeProperties(shapeV, prop1, true, false);
		CHECK(s_sahpe == Approx(30.0).margin(1e-12));
		CHECK(s_sahpe1 == Approx(20.0).margin(1e-12));
		CHECK(s_sahpe2 == Approx(148.0).margin(1e-12));
		CHECK(v_sahpe == Approx(120.0).margin(1e-12));
		CHECK(OCCTIO::OCCTTool::Write(box, outdir + "MakeBox.brep"));
	}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API const TopoFace& ZMinFace()	 @return The Z-min face
	 @brief Get the face on Z minimum
,
 "output":#include <modeling/MakeBox.hpp>
#include<catch.hpp>
#include<testHelper.h>
#include <modeling/MakeBox.hpp>
#include <modeling/MakeCylinder.hpp>
#include <topology/BRepExtremaProximityTool.hpp>
#include <io/OBJTool.hpp>
#include <topology/TopoFace.hpp>
#include <modeling/TransformShape.hpp>
#include <topology/TopoExplorerTool.hpp>
#include <modeling/MakeTorus.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
using namespace AMCAX;
TEST_CASE(" bug1:  ","[MakeBox][p1][fixbug]")
{
		OUTPUT_DIRECTORY(topology, OverlapFaces);
		MakeBox box(3.0, 2.0, 2.0);
		TopoShape box2 = box.Shape();
		box.Init(4.0, 5.0, 6.0);
		TopoFace shape = box.XMinFace();
		TopoFace shape1 = box.ZMinFace();
		TopoShape shape2 = box;
		TopoShape shapeV = box;
		AMCAX::GlobalProperty prop1;
		double s_sahpe = GetSurfaceProperties(shape, prop1, true, false);
		double s_sahpe1 = GetSurfaceProperties(shape1, prop1, true, false);
		double s_sahpe2 = GetSurfaceProperties(shape2, prop1, true, false);
		double v_sahpe = GetVolumeProperties(shapeV, prop1, true, false);
		CHECK(s_sahpe == Approx(30.0).margin(1e-12));
		CHECK(s_sahpe1 == Approx(20.0).margin(1e-12));
		CHECK(s_sahpe2 == Approx(148.0).margin(1e-12));
		CHECK(v_sahpe == Approx(120.0).margin(1e-12));
		CHECK(OCCTIO::OCCTTool::Write(box, outdir + "MakeBox.brep"));
	}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API MakeTorus(double r1, double r2, double angle1, double angle2)	 @param angle2 The end angle
	 @param angle1 The start angle
	 @param r2 The minor radius
	 @param r1 The major radius
	 @brief Construct from a major radius, a minor radius and two angles that forms an arc of the section circle
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <modeling/MakeTorus.hpp>
#include <common/CartesianCoordinateSystem.hpp>
#include <topology/TopoBuilder.hpp>
TEST_CASE("bug1: MakeTorus   ", "[modeling][MakeTorus][P1][fixbug]")
{
	std::vector<TopoShape> shapes;
	constexpr double major = 3.0;
	constexpr double minor = 1.0;
	auto addshape = [&](double angle1, double angle2, double angle)
	{
		Frame3 frame(Point3(0.0, 0.0, static_cast<double>(shapes.size()) * 3.0), CartesianCoordinateSystem::DZ());
		shapes.push_back(MakeTorus(frame, major, minor, angle1, angle2, angle));
	};
	addshape(0.0, 2.0 * M_PI, 2.0 * M_PI);
	addshape(0.0, 2.0 * M_PI, M_PI_2);
	addshape(0.0, M_PI, 2.0 * M_PI);
	addshape(M_PI_2, 3.0 * M_PI_2, 2.0 * M_PI);
	addshape(M_PI, 2.0 * M_PI, 2.0 * M_PI);
	addshape(-M_PI_2, M_PI_2, 2.0 * M_PI);
	addshape(M_PI_4, M_PI_4 * 3, 2.0 * M_PI);
	addshape(M_PI_4 * 3, M_PI_4 * 5, 2.0 * M_PI);
	addshape(M_PI_4 * 5, M_PI_4 * 7, 2.0 * M_PI);
	addshape(-M_PI_4, M_PI_4, 2.0 * M_PI);
	addshape(0.0, M_PI_2, M_PI_2);
	TopoShape result;
	TopoBuilder b;
	b.MakeCompound(TopoCast::Compound(result));
	for (const auto& s : shapes)
	{
		b.Add(result, s);
	}
	CHECK( OCCTIO::OCCTTool::Write(result, OUTPUT_PATH_PREFIX"MakeTorus_bug445.brep"));
	AMCAX::GlobalProperty props1, props2;
	CHECK(GetSurfaceProperties(result, props1, true, false) == Approx(831.9798765859));
	CHECK(GetVolumeProperties(result, props2, true, false) == Approx(255.8996));
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API MakeTorus(double r1, double r2, double angle1, double angle2, double angle)	 @param angle The rotation angle
	 @param angle2 The end angle
	 @param angle1 The start angle
	 @param r2 The minor radius
	 @param r1 The major radius
	 @brief Construct from a major radius, a minor radius, two angles that forms an arc of the section circle and a rotation angle
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <modeling/MakeTorus.hpp>
#include <common/CartesianCoordinateSystem.hpp>
#include <topology/TopoBuilder.hpp>
TEST_CASE("bug1: MakeTorus   ", "[modeling][MakeTorus][P1][fixbug]")
{
	std::vector<TopoShape> shapes;
	constexpr double major = 3.0;
	constexpr double minor = 1.0;
	auto addshape = [&](double angle1, double angle2, double angle)
	{
		Frame3 frame(Point3(0.0, 0.0, static_cast<double>(shapes.size()) * 3.0), CartesianCoordinateSystem::DZ());
		shapes.push_back(MakeTorus(frame, major, minor, angle1, angle2, angle));
	};
	addshape(0.0, 2.0 * M_PI, 2.0 * M_PI);
	addshape(0.0, 2.0 * M_PI, M_PI_2);
	addshape(0.0, M_PI, 2.0 * M_PI);
	addshape(M_PI_2, 3.0 * M_PI_2, 2.0 * M_PI);
	addshape(M_PI, 2.0 * M_PI, 2.0 * M_PI);
	addshape(-M_PI_2, M_PI_2, 2.0 * M_PI);
	addshape(M_PI_4, M_PI_4 * 3, 2.0 * M_PI);
	addshape(M_PI_4 * 3, M_PI_4 * 5, 2.0 * M_PI);
	addshape(M_PI_4 * 5, M_PI_4 * 7, 2.0 * M_PI);
	addshape(-M_PI_4, M_PI_4, 2.0 * M_PI);
	addshape(0.0, M_PI_2, M_PI_2);
	TopoShape result;
	TopoBuilder b;
	b.MakeCompound(TopoCast::Compound(result));
	for (const auto& s : shapes)
	{
		b.Add(result, s);
	}
	CHECK( OCCTIO::OCCTTool::Write(result, OUTPUT_PATH_PREFIX"MakeTorus_bug445.brep"));
	AMCAX::GlobalProperty props1, props2;
	CHECK(GetSurfaceProperties(result, props1, true, false) == Approx(831.9798765859));
	CHECK(GetVolumeProperties(result, props2, true, false) == Approx(255.8996));
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API MakeTorus(const Frame3& frame, double r1, double r2, double angle1, double angle2)	 @param angle2 The end angle
	 @param angle1 The start angle
	 @param r2 The minor radius
	 @param r1 The major radius
	 @param frame The local coordinate system
	 @brief Construct from a local coordinate system, a major radius, a minor radius and two angles that forms an arc of the section circle
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <modeling/MakeTorus.hpp>
#include <common/CartesianCoordinateSystem.hpp>
#include <topology/TopoBuilder.hpp>
TEST_CASE("bug1: MakeTorus   ", "[modeling][MakeTorus][P1][fixbug]")
{
	std::vector<TopoShape> shapes;
	constexpr double major = 3.0;
	constexpr double minor = 1.0;
	auto addshape = [&](double angle1, double angle2, double angle)
	{
		Frame3 frame(Point3(0.0, 0.0, static_cast<double>(shapes.size()) * 3.0), CartesianCoordinateSystem::DZ());
		shapes.push_back(MakeTorus(frame, major, minor, angle1, angle2, angle));
	};
	addshape(0.0, 2.0 * M_PI, 2.0 * M_PI);
	addshape(0.0, 2.0 * M_PI, M_PI_2);
	addshape(0.0, M_PI, 2.0 * M_PI);
	addshape(M_PI_2, 3.0 * M_PI_2, 2.0 * M_PI);
	addshape(M_PI, 2.0 * M_PI, 2.0 * M_PI);
	addshape(-M_PI_2, M_PI_2, 2.0 * M_PI);
	addshape(M_PI_4, M_PI_4 * 3, 2.0 * M_PI);
	addshape(M_PI_4 * 3, M_PI_4 * 5, 2.0 * M_PI);
	addshape(M_PI_4 * 5, M_PI_4 * 7, 2.0 * M_PI);
	addshape(-M_PI_4, M_PI_4, 2.0 * M_PI);
	addshape(0.0, M_PI_2, M_PI_2);
	TopoShape result;
	TopoBuilder b;
	b.MakeCompound(TopoCast::Compound(result));
	for (const auto& s : shapes)
	{
		b.Add(result, s);
	}
	CHECK( OCCTIO::OCCTTool::Write(result, OUTPUT_PATH_PREFIX"MakeTorus_bug445.brep"));
	AMCAX::GlobalProperty props1, props2;
	CHECK(GetSurfaceProperties(result, props1, true, false) == Approx(831.9798765859));
	CHECK(GetVolumeProperties(result, props2, true, false) == Approx(255.8996));
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API MakeTorus(const Frame3& frame, double r1, double r2, double angle1, double angle2, double angle)	 @param angle The rotation angle
	 @param angle2 The end angle
	 @param angle1 The start angle
	 @param r2 The minor radius
	 @param r1 The major radius
	 @param frame The local coordinate system
	 @brief Construct from a local coordinate system, a major radius, a minor radius, two angles that forms an arc of the section circle and a rotation angle
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <modeling/MakeTorus.hpp>
#include <common/CartesianCoordinateSystem.hpp>
#include <topology/TopoBuilder.hpp>
TEST_CASE("bug1: MakeTorus   ", "[modeling][MakeTorus][P1][fixbug]")
{
	std::vector<TopoShape> shapes;
	constexpr double major = 3.0;
	constexpr double minor = 1.0;
	auto addshape = [&](double angle1, double angle2, double angle)
	{
		Frame3 frame(Point3(0.0, 0.0, static_cast<double>(shapes.size()) * 3.0), CartesianCoordinateSystem::DZ());
		shapes.push_back(MakeTorus(frame, major, minor, angle1, angle2, angle));
	};
	addshape(0.0, 2.0 * M_PI, 2.0 * M_PI);
	addshape(0.0, 2.0 * M_PI, M_PI_2);
	addshape(0.0, M_PI, 2.0 * M_PI);
	addshape(M_PI_2, 3.0 * M_PI_2, 2.0 * M_PI);
	addshape(M_PI, 2.0 * M_PI, 2.0 * M_PI);
	addshape(-M_PI_2, M_PI_2, 2.0 * M_PI);
	addshape(M_PI_4, M_PI_4 * 3, 2.0 * M_PI);
	addshape(M_PI_4 * 3, M_PI_4 * 5, 2.0 * M_PI);
	addshape(M_PI_4 * 5, M_PI_4 * 7, 2.0 * M_PI);
	addshape(-M_PI_4, M_PI_4, 2.0 * M_PI);
	addshape(0.0, M_PI_2, M_PI_2);
	TopoShape result;
	TopoBuilder b;
	b.MakeCompound(TopoCast::Compound(result));
	for (const auto& s : shapes)
	{
		b.Add(result, s);
	}
	CHECK( OCCTIO::OCCTTool::Write(result, OUTPUT_PATH_PREFIX"MakeTorus_bug445.brep"));
	AMCAX::GlobalProperty props1, props2;
	CHECK(GetSurfaceProperties(result, props1, true, false) == Approx(831.9798765859));
	CHECK(GetVolumeProperties(result, props2, true, false) == Approx(255.8996));
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API MakePolygon(const Point3& p1, const Point3& p2)	 @param p2 The second point
	 @param p1 The first point
	 @brief Construct from two points
,
 "output":#include<catch.hpp>
#include<iostream>
#include <modeling/MakePolygon.hpp>
#include <topology/TopoVertex.hpp>
#include <topology/TopoEdge.hpp>
#include <topology/TopoExplorerTool.hpp>
#include <topology/TopoShape.hpp>
#include <topology/TopoTool.hpp>
TEST_CASE("MakePolygon Invalid input points", "[modeling][MakePolygon][P3]") {
        AMCAX::Point3 p1(0.0, 0.0, 0.0);
        AMCAX::MakePolygon polygon(p1, p1);
        bool lastAdded = polygon.Added();
        CHECK(lastAdded == false);
    }
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API void Add(const Point3& p)	 @param p The point
	 @brief Add a new point to the polygon
,
 "output":#include<catch.hpp>
#include<iostream>
#include <modeling/MakePolygon.hpp>
#include <topology/TopoVertex.hpp>
#include <topology/TopoEdge.hpp>
#include <topology/TopoExplorerTool.hpp>
#include <topology/TopoShape.hpp>
#include <topology/TopoTool.hpp>
TEST_CASE("void AMCAX::MakePolygon::Add(const Point3 & p) - case1 add valid 3D point", "[modeling][MakePolygon][P1]") {
        AMCAX::Point3 p1(1.0, 2.0, 3.0);
        AMCAX::Point3 p2(4.1, 5.1, 6.1);
        AMCAX::MakePolygon polygon(p1, p2);
        bool lastAdded1 = polygon.Added();
        CHECK(lastAdded1 == true);
        const AMCAX::TopoEdge &lastEdge = polygon.Edge();
        CHECK(lastEdge.IsNull() == false);
        CHECK(lastEdge.NChildren() == 2);
        CHECK(lastEdge.Type() == AMCAX::ShapeType::Edge);
        AMCAX::TopoVertex v1,v2;
        AMCAX::TopoExplorerTool::Vertices(lastEdge, v1, v2,false);
        CHECK_FALSE(v1.IsNull());
        CHECK_FALSE(v2.IsNull());
        CHECK(v1.Type() == AMCAX::ShapeType::Vertex);
        CHECK(v2.Type() == AMCAX::ShapeType::Vertex);
        AMCAX::Point3 vpoint1;
        vpoint1 = AMCAX::TopoTool::Point(v1);
        CHECK(vpoint1.X() == 1.0);
        CHECK(vpoint1.Y() == 2.0);
        CHECK(vpoint1.Z() == 3.0);
        AMCAX::Point3 p3(4.1, 5.1, 6.1);
        polygon.Add(p3);
        bool lastAdded2 = polygon.Added();
        CHECK(lastAdded2 == false);
        AMCAX::Point3 p4(7.0, 8.0, 9.0);
        polygon.Add(p4);
        bool lastAdded3 = polygon.Added();
        CHECK(lastAdded3 == true);
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API MakePyramid(const Point3& p1, const Point3& p2, const Point3& p3, const Point3& apex)	 @param apex Apex point
	 @param p1,p2,p3 Points on the base plane
	 @brief Construct a tetrahedron
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <modeling/MakePyramid.hpp>
#include <hatch/BRepClassificationTools.hpp>
TEST_CASE("case1 MakePyramid(p1, p2, p3, apex)  ", "[modeling][MakePyramid][P1]")
{
    Point3 p1(0.0, 0.0, 0.0);
    Point3 p2(4.0, 0.0, 0.0);
    Point3 p3(2.0, 4.0, 0.0);
    Point3 apex(0.0, 0.0, 4.5);
    std::vector<Point3> points = { p1, p2, p3, apex };
    TopoShape shape = AMCAX::MakePyramid(p1, p2, p3, apex);
    AMCAX::GlobalProperty props;
    CHECK(GetSurfaceProperties(shape, props, true, false) == Approx(39.9172660309));
    CHECK(GetVolumeProperties(shape, props, true, false) == Approx(12.0));
    CHECK(shape.Type() == ShapeType::Solid);
    OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX"MakePyramid_case01.brep");
    TopoSolid solid = AMCAX::TopoCast::Solid(shape);
    for (const Point3& p : points) {
        bool isPointOnSolid = AMCAX::BRepClassificationTools::IsPointInOnSolid(solid, p);
        CHECK(isPointOnSolid == true);
    }
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API MakePyramid(const Point3& p1, const Point3& p2, const Point3& p3, const Point3& p4, const Point3& apex)	 @param apex Apex point
	 @param p1,p2,p3,p4 Points on the base plane
	 @brief Construct a quadrilateral pyramid
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <modeling/MakePyramid.hpp>
#include <hatch/BRepClassificationTools.hpp>
TEST_CASE("case2 MakePyramid(p1, p2, p3, apex)  ", "[modeling][MakePyramid][P1]")
{
    Point3 p1(-2.0, 0.0, -2.0);
    Point3 p2(2.0, 0.0, -2.0);
    Point3 p3(0.0, 4.0, -2.0);
    Point3 apex(-5.0, 0.0, 2.5);
    std::vector<Point3> points = { p1, p2, p3, apex };
    TopoShape shape = AMCAX::MakePyramid(p1, p2, p3, apex);
    AMCAX::GlobalProperty props;
    CHECK(GetSurfaceProperties(shape, props, true, false) == Approx(45.9563141634));
    CHECK(GetVolumeProperties(shape, props, true, false) == Approx(12.0));
    CHECK(shape.Type() == ShapeType::Solid);
    OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX"MakePyramid_case02.brep");
    TopoSolid solid = AMCAX::TopoCast::Solid(shape);
    for (const Point3& p : points) {
        bool isPointOnSolid = AMCAX::BRepClassificationTools::IsPointInOnSolid(solid, p);
        CHECK(isPointOnSolid == true);
    }
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API MakePyramid(const std::vector<Point3>& basepoints, const Point3& apex)	 @param apex Apex point
	 @param basepoints Points on the base plane
	 @brief Construct a pyramid with base points and an apex point
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <modeling/MakePyramid.hpp>
#include <hatch/BRepClassificationTools.hpp>
TEST_CASE("case1: MakePyramid(basepoints, apex)  ", "[modeling][MakePyramid][P1]")
{
    Point3 p1(-2.0, 1.0, 0.0);
    Point3 p2(1.0, -3.0, 0.0);
    Point3 p3(-1.0, -2.5, 0.0);
    Point3 apex(5.0, 3.0, 4.5);
    std::vector<Point3> points = { p1, p2, p3};
    TopoShape shape = AMCAX::MakePyramid(points, apex);
    AMCAX::GlobalProperty props;
    CHECK(GetSurfaceProperties(shape, props, true, false) == Approx(47.6096343921));
    CHECK(GetVolumeProperties(shape, props, true, false) == Approx(4.875));
    CHECK(shape.Type() == ShapeType::Solid);
    CHECK(OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX"MakePyramid3_case01.brep"));
    TopoSolid solid = AMCAX::TopoCast::Solid(shape);
    CHECK(AMCAX::BRepClassificationTools::IsPointInOnSolid(solid, apex));
    for (const Point3& p : points) {
        bool isPointOnSolid = AMCAX::BRepClassificationTools::IsPointInOnSolid(solid, p);
        CHECK(isPointOnSolid == true);
    }
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API MakePyramid(const Frame3& frame, double radius, int nside, double height)	 @param height Height of the polygon
	 @param nside Number of sides of the base polygon
	 @param radius Radius of the circumcircle of the base polygon
	 @param frame The local coordinate system
	 @brief Construct a regular pyramid
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <modeling/MakePyramid.hpp>
#include <hatch/BRepClassificationTools.hpp>
TEST_CASE("case2: MakePyramid(p1, p2, p3, p4, apex) ", "[modeling][MakePyramid][P1]")
{ 
    Point3 p1(-2.0, 1.0, -1.0);
    Point3 p2(1.0, 3.0, 0.0);
    Point3 p3(4.0, -1.0, 1.0);
    Point3 p4(-1.0, -2.0, 0.0);
    Point3 apex(1.0, -1.0, -4.5);
    CHECK_THROWS_AS( AMCAX::MakePyramid(p1, p2, p3, p4, apex), AMCAX::_ConstructionError );
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API MakePyramid(const Frame3& frame, const Point3& p1, const Point3& p2, const Point3& p3, const Point3& apex)	 @param apex Apex point
	 @param p1,p2,p3 Points that are projected onto the base plane
	 @param frame The frame of base plane
	 @brief Construct a tetrahedron with a given plane frame
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <modeling/MakePyramid.hpp>
#include <hatch/BRepClassificationTools.hpp>
TEST_CASE("case1 MakePyramid(p1, p2, p3, apex)  ", "[modeling][MakePyramid][P1]")
{
    Point3 p1(0.0, 0.0, 0.0);
    Point3 p2(4.0, 0.0, 0.0);
    Point3 p3(2.0, 4.0, 0.0);
    Point3 apex(0.0, 0.0, 4.5);
    std::vector<Point3> points = { p1, p2, p3, apex };
    TopoShape shape = AMCAX::MakePyramid(p1, p2, p3, apex);
    AMCAX::GlobalProperty props;
    CHECK(GetSurfaceProperties(shape, props, true, false) == Approx(39.9172660309));
    CHECK(GetVolumeProperties(shape, props, true, false) == Approx(12.0));
    CHECK(shape.Type() == ShapeType::Solid);
    OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX"MakePyramid_case01.brep");
    TopoSolid solid = AMCAX::TopoCast::Solid(shape);
    for (const Point3& p : points) {
        bool isPointOnSolid = AMCAX::BRepClassificationTools::IsPointInOnSolid(solid, p);
        CHECK(isPointOnSolid == true);
    }
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API MakePyramid(const Frame3& frame, const Point3& p1, const Point3& p2, const Point3& p3, const Point3& p4, const Point3& apex)	 @param apex Apex point
	 @param p1,p2,p3,p4 Points that are projected onto the base plane
	 @param frame The frame of base plane
	 @brief Construct a quadrilateral pyramid with a given plane frame
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <modeling/MakePyramid.hpp>
#include <hatch/BRepClassificationTools.hpp>
TEST_CASE("case2 MakePyramid(p1, p2, p3, apex)  ", "[modeling][MakePyramid][P1]")
{
    Point3 p1(-2.0, 0.0, -2.0);
    Point3 p2(2.0, 0.0, -2.0);
    Point3 p3(0.0, 4.0, -2.0);
    Point3 apex(-5.0, 0.0, 2.5);
    std::vector<Point3> points = { p1, p2, p3, apex };
    TopoShape shape = AMCAX::MakePyramid(p1, p2, p3, apex);
    AMCAX::GlobalProperty props;
    CHECK(GetSurfaceProperties(shape, props, true, false) == Approx(45.9563141634));
    CHECK(GetVolumeProperties(shape, props, true, false) == Approx(12.0));
    CHECK(shape.Type() == ShapeType::Solid);
    OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX"MakePyramid_case02.brep");
    TopoSolid solid = AMCAX::TopoCast::Solid(shape);
    for (const Point3& p : points) {
        bool isPointOnSolid = AMCAX::BRepClassificationTools::IsPointInOnSolid(solid, p);
        CHECK(isPointOnSolid == true);
    }
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API MakePyramid(const Frame3& frame, const std::vector<Point3>& basepoints, const Point3& apex)	 @param apex Apex point
	 @param basepoints Points that are projected onto the base plane
	 @param frame The frame of base plane
	 @brief Construct a pyramid with a given base plane frame
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <modeling/MakePyramid.hpp>
#include <hatch/BRepClassificationTools.hpp>
TEST_CASE("case2: MakePyramid(p1, p2, p3, p4, apex) ", "[modeling][MakePyramid][P1]")
{ 
    Point3 p1(-2.0, 1.0, -1.0);
    Point3 p2(1.0, 3.0, 0.0);
    Point3 p3(4.0, -1.0, 1.0);
    Point3 p4(-1.0, -2.0, 0.0);
    Point3 apex(1.0, -1.0, -4.5);
    CHECK_THROWS_AS( AMCAX::MakePyramid(p1, p2, p3, p4, apex), AMCAX::_ConstructionError );
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API MakePyramid(const Point3& baseLocation, const std::vector<Point3>& basepoints, const Point3& apex)	 @param apex Apex point
	 @param basepoints The base points that are projected onto the base plane
	 @param baseLocation The location of the base plane
	 @details The base plane are determined by the location point and the first two base points
	 @brief Construct a pyramid with a given location on the base plane
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <modeling/MakePyramid.hpp>
#include <hatch/BRepClassificationTools.hpp>
TEST_CASE("case1: MakePyramid(basepoints, apex)  ", "[modeling][MakePyramid][P1]")
{
    Point3 p1(-2.0, 1.0, 0.0);
    Point3 p2(1.0, -3.0, 0.0);
    Point3 p3(-1.0, -2.5, 0.0);
    Point3 apex(5.0, 3.0, 4.5);
    std::vector<Point3> points = { p1, p2, p3};
    TopoShape shape = AMCAX::MakePyramid(points, apex);
    AMCAX::GlobalProperty props;
    CHECK(GetSurfaceProperties(shape, props, true, false) == Approx(47.6096343921));
    CHECK(GetVolumeProperties(shape, props, true, false) == Approx(4.875));
    CHECK(shape.Type() == ShapeType::Solid);
    CHECK(OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX"MakePyramid3_case01.brep"));
    TopoSolid solid = AMCAX::TopoCast::Solid(shape);
    CHECK(AMCAX::BRepClassificationTools::IsPointInOnSolid(solid, apex));
    for (const Point3& p : points) {
        bool isPointOnSolid = AMCAX::BRepClassificationTools::IsPointInOnSolid(solid, p);
        CHECK(isPointOnSolid == true);
    }
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API MakeRevol(const TopoShape& s, const Axis3& a, double d, bool copy = false)	 @param copy Whether copy the base shape
	 @param d The rotation angle
	 @param a The rotation axis
	 @param s The base shape
	 @brief Construct from a base shape, a rotation axis and a rotation angle
,
 "output":#include <catch.hpp>
#include<testHelper.h>
#include <modeling/MakeRevol.hpp>
#include <common/PointT.hpp>
#include <topology/TopoVertex.hpp>
#include <common/CartesianCoordinateSystem.hpp>
#include <occtio/OCCTTool.hpp>
#include <topology/TopoBuilder.hpp>
#include <modeling/MakeVertex.hpp>
#include <common/IndexSet.hpp>
#include <topology/TopoExplorerTool.hpp>
#include <topology/TopoTool.hpp>
#include <topology/TopoCast.hpp>
using namespace AMCAX;
TEST_CASE("BUG1:create MakeRevol bug   ", "[modeling][MakeRevol][fixbug][P1]") {
	Point3 p(1.0, 0.0, 0.0);
	TopoVertex v0 = MakeVertex(p);
	TopoShape e = MakeRevol(v0, CartesianCoordinateSystem::OZ(), M_PI_2);
	TopoShape f = MakeRevol(e, CartesianCoordinateSystem::OX(), M_PI_2);
	IndexSet<TopoShape> vertices;
	TopoExplorerTool::MapShapes(f, ShapeType::Vertex, vertices);
	std::cout << TopoTool::Tolerance(TopoCast::Vertex(vertices[0])) << std::endl;
	CHECK(TopoTool::Tolerance(TopoCast::Vertex(vertices[0])) == 1e-07);
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API MakeRevol(const TopoShape& s, const Axis3& a, bool copy = false)	 @param copy Whether copy the base shape
	 @param a The rotation axis
	 @param s The base shape
	 @brief Construct from a base shape and a rotation axis
,
 "output":#include <catch.hpp>
#include<testHelper.h>
#include <modeling/MakeRevol.hpp>
#include <common/PointT.hpp>
#include <topology/TopoVertex.hpp>
#include <common/CartesianCoordinateSystem.hpp>
#include <occtio/OCCTTool.hpp>
#include <topology/TopoBuilder.hpp>
#include <modeling/MakeVertex.hpp>
#include <common/IndexSet.hpp>
#include <topology/TopoExplorerTool.hpp>
#include <topology/TopoTool.hpp>
#include <topology/TopoCast.hpp>
using namespace AMCAX;
TEST_CASE("BUG1:create MakeRevol bug   ", "[modeling][MakeRevol][fixbug][P1]") {
	Point3 p(1.0, 0.0, 0.0);
	TopoVertex v0 = MakeVertex(p);
	TopoShape e = MakeRevol(v0, CartesianCoordinateSystem::OZ(), M_PI_2);
	TopoShape f = MakeRevol(e, CartesianCoordinateSystem::OX(), M_PI_2);
	IndexSet<TopoShape> vertices;
	TopoExplorerTool::MapShapes(f, ShapeType::Vertex, vertices);
	std::cout << TopoTool::Tolerance(TopoCast::Vertex(vertices[0])) << std::endl;
	CHECK(TopoTool::Tolerance(TopoCast::Vertex(vertices[0])) == 1e-07);
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API MakeRightPrism(const Point3& p1, const Point3& p2, const Point3& p3, const Point3& apex)	 @param apex A point on the top plane
	 @param p1,p2,p3 Points on the base plane
	 @brief Construct a right triangular prism
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include<common/Exception.hpp>
#include <modeling/MakeRightPrism.hpp>
#include <hatch/BRepClassificationTools.hpp>
TEST_CASE("case1 MakeRightPrism(p1, p2, p3, apex)  ", "[modeling][MakeRightPrism][P1]")
{
    Point3 p1(0.0, 0.0, 0.0);
    Point3 p2(4.0, 0.0, 0.0);
    Point3 p3(2.0, 4.0, 0.0);
    Point3 apex(0.0, 0.0, 4.5);
    std::vector<Point3> points = { p1, p2, p3, apex };
    TopoShape shape = AMCAX::MakeRightPrism(p1, p2, p3, apex);
    AMCAX::GlobalProperty props;
    CHECK( GetSurfaceProperties(shape, props, true, false) == Approx( 74.249223595));
    CHECK( GetVolumeProperties(shape, props, true, false) == 36.0);
    CHECK(shape.Type() == ShapeType::Solid);
    OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX"MakeRightPrism_01.brep");
    TopoSolid solid = AMCAX::TopoCast::Solid(shape);
    for (const Point3& p : points) {
        bool isPointOnSolid = AMCAX::BRepClassificationTools::IsPointInOnSolid(solid, p);
        CHECK(isPointOnSolid == true);
    }
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API MakeRightPrism(const Point3& p1, const Point3& p2, const Point3& p3, const Point3& p4, const Point3& apex)	 @param apex A point on the top plane
	 @param p1,p2,p3,p4 Points on the base plane
	 @brief Construct a right quadrilateral prism
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include<common/Exception.hpp>
#include <modeling/MakeRightPrism.hpp>
#include <hatch/BRepClassificationTools.hpp>
TEST_CASE("case1 MakeRightPrism(p1, p2, p3, apex)  ", "[modeling][MakeRightPrism][P1]")
{
    Point3 p1(0.0, 0.0, 0.0);
    Point3 p2(4.0, 0.0, 0.0);
    Point3 p3(2.0, 4.0, 0.0);
    Point3 apex(0.0, 0.0, 4.5);
    std::vector<Point3> points = { p1, p2, p3, apex };
    TopoShape shape = AMCAX::MakeRightPrism(p1, p2, p3, apex);
    AMCAX::GlobalProperty props;
    CHECK( GetSurfaceProperties(shape, props, true, false) == Approx( 74.249223595));
    CHECK( GetVolumeProperties(shape, props, true, false) == 36.0);
    CHECK(shape.Type() == ShapeType::Solid);
    OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX"MakeRightPrism_01.brep");
    TopoSolid solid = AMCAX::TopoCast::Solid(shape);
    for (const Point3& p : points) {
        bool isPointOnSolid = AMCAX::BRepClassificationTools::IsPointInOnSolid(solid, p);
        CHECK(isPointOnSolid == true);
    }
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API MakeRightPrism(const std::vector<Point3>& basepoints, const Point3& apex)	 @param apex A point on the top plane
	 @param basepoints Points on the base plane
	 @brief Construct a right prism with base points and a point on the top plane
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include<common/Exception.hpp>
#include <modeling/MakeRightPrism.hpp>
#include <hatch/BRepClassificationTools.hpp>
TEST_CASE("case3 MakeRightPrism(p1, p2, p3, apex)  ", "[modeling][MakeRightPrism][P1]")
{
    Point3 p1(0.0, 0.0, 0.0);
    Point3 p2(4.0, 0.0, 0.0);
    Point3 p3(2.0, 4.0, -2.0);
    Point3 apex(4.0, 0.0, -4.5);
    std::vector<Point3> points = { p1, p2, p3 };
    TopoShape shape = AMCAX::MakeRightPrism(p1, p2, p3, apex);
    AMCAX::GlobalProperty props;
    CHECK(GetSurfaceProperties(shape, props, true, false) == Approx(73.4242573984));
    CHECK(GetVolumeProperties(shape, props, true, false) == 36.0);
    CHECK(shape.Type() == ShapeType::Solid);
    OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX"MakeRightPrism_03.brep");
    TopoSolid solid = AMCAX::TopoCast::Solid(shape);
    for (const Point3& p : points) {
        bool isPointOnSolid = AMCAX::BRepClassificationTools::IsPointInOnSolid(solid, p);
        CHECK(isPointOnSolid == true);
    }
    Point3 p4(2.0, 2.2, -5.6);
    bool isPointOnSolid = AMCAX::BRepClassificationTools::IsPointInOnSolid(solid, p4);
    CHECK(isPointOnSolid == true);
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API MakeRightPrism(const Frame3& frame, double radius, int nside, double height)	 @param height Height of the polygon
	 @param nside Number of sides of the base polygon
	 @param radius Radius of the circumcircle of the base polygon
	 @param frame The local coordinate system
	 @brief Construct a right regular prism
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include<common/Exception.hpp>
#include <modeling/MakeRightPrism.hpp>
#include <hatch/BRepClassificationTools.hpp>
TEST_CASE("bug:case5 MakeRightPrism(p1, p2, p3, apex)  ", "[modeling][MakeRightPrism][P1][fixbug]")
{
    Point3 p1(0.0, 0.0, 0.0);
    Point3 p2(4.0, 0.0, 0.0);
    Point3 p3(6.0, 0.0, 0.0);
    Point3 apex(2.0, 2.0, -4.5);
    std::vector<Point3> points = { p1, p2, p3, apex };
    CHECK_THROWS_AS(AMCAX::MakeRightPrism(p1, p2, p3, apex), AMCAX::_ConstructionError);
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API MakeRightPrism(const Frame3& frame, const Point3& p1, const Point3& p2, const Point3& p3, const Point3& apex)	 @param apex A point on the top plane
	 @param p1,p2,p3 Points that are projected onto the base plane
	 @param frame The frame of base plane
	 @brief Construct a right triangular prism with a given plane frame
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include<common/Exception.hpp>
#include <modeling/MakeRightPrism.hpp>
#include <hatch/BRepClassificationTools.hpp>
TEST_CASE("case1 MakeRightPrism(p1, p2, p3, apex)  ", "[modeling][MakeRightPrism][P1]")
{
    Point3 p1(0.0, 0.0, 0.0);
    Point3 p2(4.0, 0.0, 0.0);
    Point3 p3(2.0, 4.0, 0.0);
    Point3 apex(0.0, 0.0, 4.5);
    std::vector<Point3> points = { p1, p2, p3, apex };
    TopoShape shape = AMCAX::MakeRightPrism(p1, p2, p3, apex);
    AMCAX::GlobalProperty props;
    CHECK( GetSurfaceProperties(shape, props, true, false) == Approx( 74.249223595));
    CHECK( GetVolumeProperties(shape, props, true, false) == 36.0);
    CHECK(shape.Type() == ShapeType::Solid);
    OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX"MakeRightPrism_01.brep");
    TopoSolid solid = AMCAX::TopoCast::Solid(shape);
    for (const Point3& p : points) {
        bool isPointOnSolid = AMCAX::BRepClassificationTools::IsPointInOnSolid(solid, p);
        CHECK(isPointOnSolid == true);
    }
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API MakeRightPrism(const Frame3& frame, const Point3& p1, const Point3& p2, const Point3& p3, const Point3& p4, const Point3& apex)	 @param apex A point on the top plane
	 @param p1,p2,p3,p4 Points that are projected onto the base plane
	 @param frame The frame of base plane
	 @brief Construct a right quadrilateral prism with a given plane frame
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include<common/Exception.hpp>
#include <modeling/MakeRightPrism.hpp>
#include <hatch/BRepClassificationTools.hpp>
TEST_CASE("case2 MakeRightPrism(p1, p2, p3, apex)  ", "[modeling][MakeRightPrism][P1]")
{
    Point3 p1(-2.0, 0.0, -2.0);
    Point3 p2(2.0, 0.0, -2.0);
    Point3 p3(0.0, 4.0, -2.0);
    Point3 apex(-5.0, 999.0, 2.5);
    std::vector<Point3> points = { p1, p2, p3 };
    TopoShape shape = AMCAX::MakeRightPrism(p1, p2, p3, apex);
    AMCAX::GlobalProperty props;
    CHECK(GetSurfaceProperties(shape, props, true, false) == Approx(74.249223595));
    CHECK(GetVolumeProperties(shape, props, true, false) == 36.0);
    CHECK(shape.Type() == ShapeType::Solid);
    OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX"MakeRightPrism_02.brep");
    TopoSolid solid = AMCAX::TopoCast::Solid(shape);
    for (const Point3& p : points) {
        bool isPointOnSolid = AMCAX::BRepClassificationTools::IsPointInOnSolid(solid, p);
        CHECK(isPointOnSolid == true);
    }
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API MakeRightPrism(const Frame3& frame, const std::vector<Point3>& basepoints, const Point3& apex)	 @param apex A point on the top plane
	 @param basepoints Points that are projected onto the base plane
	 @param frame The frame of base plane
	 @brief Construct a right prism with a given base plane frame
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include<common/Exception.hpp>
#include <modeling/MakeRightPrism.hpp>
#include <hatch/BRepClassificationTools.hpp>
TEST_CASE("case1 MakeRightPrism(p1, p2, p3, apex)  ", "[modeling][MakeRightPrism][P1]")
{
    Point3 p1(0.0, 0.0, 0.0);
    Point3 p2(4.0, 0.0, 0.0);
    Point3 p3(2.0, 4.0, 0.0);
    Point3 apex(0.0, 0.0, 4.5);
    std::vector<Point3> points = { p1, p2, p3, apex };
    TopoShape shape = AMCAX::MakeRightPrism(p1, p2, p3, apex);
    AMCAX::GlobalProperty props;
    CHECK( GetSurfaceProperties(shape, props, true, false) == Approx( 74.249223595));
    CHECK( GetVolumeProperties(shape, props, true, false) == 36.0);
    CHECK(shape.Type() == ShapeType::Solid);
    OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX"MakeRightPrism_01.brep");
    TopoSolid solid = AMCAX::TopoCast::Solid(shape);
    for (const Point3& p : points) {
        bool isPointOnSolid = AMCAX::BRepClassificationTools::IsPointInOnSolid(solid, p);
        CHECK(isPointOnSolid == true);
    }
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API MakeRightPrism(const Point3& baseLocation, const std::vector<Point3>& basepoints, const Point3& apex)	 @param apex A point on the top plane
	 @param basepoints The base points that are projected onto the base plane
	 @param baseLocation The location of the base plane
	 @details The base plane are determined by the location point and the first two base points
	 @brief Construct a right prism with a given location on the base plane
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include<common/Exception.hpp>
#include <modeling/MakeRightPrism.hpp>
#include <hatch/BRepClassificationTools.hpp>
TEST_CASE("case2 MakeRightPrism(p1, p2, p3, p4, apex)  ", "[modeling][MakeRightPrism][P1]")
{
	SECTION("4 points on same line") {
        Point3 p1(-1.0, 0.0, 0.0);
        Point3 p2(0.0, 0.0, 0.0);
        Point3 p3(2.0, 0.0, 0.0);
        Point3 p4(4.0, 0.0, 0.0);
        Point3 apex(2.0, 2.0, -4.5);
        std::vector<Point3> points = { p1, p2, p3,p4 };
        CHECK_THROWS_AS(AMCAX::MakeRightPrism(p1, p2, p3, p4, apex), AMCAX::_ConstructionError);
    }
}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static TopoShape SewShape(const std::list<TopoShape>& shapes, double tolerance)	 @return The sewed shape
	 @param tolerance The tolerance
	 @param shapes The shapes to be sewed
	          If some edges do not coincide, the related faces remain unsewed.
	 @details The border edges are merged to common edges under a given tolerance.
	 @brief Sew faces to a shell
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <modeling/MakeShapeTool.hpp>
#include<modeling/MakeFace.hpp>
#include<math/Plane.hpp>
#include <common/CartesianCoordinateSystem.hpp>
#include <topology/TopoExplorerTool.hpp>
TEST_CASE("case1-1: MakeShapeTool::SewShape ", "[modeling][MakeShapeTool][SewShape][P1]")
{
	std::list<TopoShape> shapes;
	shapes.push_back(MakeFace(Plane(), 0.0, 1.0, 0.0, 1.0));
	shapes.push_back(MakeFace(Plane(Frame3(Point3(1.0, 0.0, 0.0), CartesianCoordinateSystem::DX(), -CartesianCoordinateSystem::DZ())), 0.0, 1.0, 0.0, 1.0));
	TopoShape result = MakeShapeTool::SewShape(shapes, Precision::Confusion());
	CHECK(OCCTIO::OCCTTool::Write(result, OUTPUT_PATH_PREFIX"SewShapetest1-0.brep"));
	IndexSet<TopoShape> sf1, sf2, sf3;
	CHECK(GetTopoToolCount(result, AMCAX::ShapeType::Shell, sf1) == 1);
	CHECK(GetTopoToolCount(result, AMCAX::ShapeType::Compound, sf2) == 0);
	CHECK(GetTopoToolCount(result, AMCAX::ShapeType::Face, sf3) == 2);
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API TransformShape(const TopoShape& s, const Transformation3& tr, bool copyGeom = false, bool copyMesh = false)	 @param copyMesh Whether the mesh of the shape is copied
	 @param copyGeom Whether the geometry of the shape is copied
	 @param tr The transformation
	 @param s The shape
	 @brief Construct from a shape with a transformation
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <modeling/MakeSphere.hpp>
#include <modeling/TransformShape.hpp>
#include <topomesh/BRepMeshIncrementalMesh.hpp>
#include <modeling/MakeShapeTool.hpp>
#include <common/TransformationT.hpp>
#include <common/CartesianCoordinateSystem.hpp>
#include <common/GeneralTransformationT.hpp>
#include <modeling/GeneralTransformShape.hpp>
#include <geometry/GlobalProperty.hpp>
#include <occtio/OCCTTool.hpp>
#include <topology/BRepGlobalProperty.hpp>
#include <geometry/Geom3BSplineCurve.hpp>
#include <modeling/MakeEdge.hpp>
#include <topology/TopoTool.hpp>
#include <topology/BRepAdaptorCurve3.hpp>
using namespace AMCAX;
TEST_CASE("bug1: GeneralTransformShape  ", "[modeling][GeneralTransformShape][fixbug]") {
	TopoShape s = MakeSphere(1.0);
	BRepMeshIncrementalMesh mesher(s, 0.005, true);
	MakeShapeTool::EnsureNormalConsistency(s);
	GeneralTransformation3 tr;
	tr.SetAffinity(Frame3(), 5.0);
	s = GeneralTransformShape(s, tr);
	CHECK(s.Type() == AMCAX::ShapeType::Solid);
	CHECK(s.IsNull() == false);
	GlobalProperty prop;
	BRepGlobalProperty::VolumeProperties(s, prop);
	CHECK(prop.Mass() == Approx(20.934791259).epsilon(1e-11));
	Point3 vP = prop.CenterOfMass();
#ifndef WIN_CASE
	CHECK(vP.X() == Approx(0.0).margin(1e-3));
	CHECK(vP.Y() == Approx(0.0).margin(1e-12));
	CHECK(vP.Z() == Approx(0.0).margin(1e-12));
#else
	CHECK(vP.X() == Approx(-2.2218808037914858e-04).epsilon(1e-12));
	CHECK(vP.Y() == Approx(-1.0782779568197278e-16).epsilon(1e-12));
	CHECK(vP.Z() == Approx(-1.6920954211916623e-16).epsilon(1e-12));
#endif
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API TransformShape(const TopoShape& s, const Transformation3& tr, bool copyGeom = false, bool copyMesh = false)	 @param copyMesh Whether the mesh of the shape is copied
	 @param copyGeom Whether the geometry of the shape is copied
	 @param tr The transformation
	 @param s The shape
	 @brief Construct from a shape with a transformation
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <modeling/MakeSphere.hpp>
#include <modeling/TransformShape.hpp>
#include <topomesh/BRepMeshIncrementalMesh.hpp>
#include <modeling/MakeShapeTool.hpp>
#include <common/TransformationT.hpp>
#include <common/CartesianCoordinateSystem.hpp>
#include <common/GeneralTransformationT.hpp>
#include <modeling/GeneralTransformShape.hpp>
#include <geometry/GlobalProperty.hpp>
#include <occtio/OCCTTool.hpp>
#include <topology/BRepGlobalProperty.hpp>
using namespace AMCAX;
TEST_CASE("bug1: TransformShape  ", "[modeling][TransformShape][fixbug]") {
	TopoShape s = MakeSphere(1.0);
	BRepMeshIncrementalMesh mesher(s, 0.005, true);
	MakeShapeTool::EnsureNormalConsistency(s);
	Transformation3 tr;
	tr.SetRotation(CartesianCoordinateSystem::OZ(), M_PI_2);
	s = TransformShape(s, tr, true, true);
	CHECK(s.IsNull() == false);
	CHECK(s.Type() == AMCAX::ShapeType::Solid);
	GlobalProperty prop;
	BRepGlobalProperty::VolumeProperties(s, prop);
	CHECK(prop.Mass() == Approx(4.1887902048).epsilon(1e-11));
	Point3 vP = prop.CenterOfMass();
#ifndef WIN_CASE
	CHECK(vP.X() == Approx(0.0).margin(1e-12));
	CHECK(vP.Y() == Approx(0.0).margin(1e-12));
	CHECK(vP.Z() == Approx(0.0).margin(1e-12));
#else
	CHECK(vP.X() == Approx(-4.0938241231662633e-18).epsilon(1e-12));
	CHECK(vP.Y() == Approx(-6.1820277995281757e-17).epsilon(1e-12));
	CHECK(vP.Z() == Approx(-3.1794228708137405e-17).epsilon(1e-12)); 
#endif
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static std::shared_ptr<Geom3BSplineCurve> ApproxPoints(const std::vector<Point3>& points, int degree, int npoles, bool isClosed = false, ApproxParameterizationType ptype = ApproxParameterizationType::ChordLength)	 @return curve
	 @param ptype parameterization type
	 @param isClosed Is curve closed
	 @param npoles Target number of poles
	 @param degree Target degree
	 @param points Data points to be approximated
	 @brief Approx points to a curve
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <nurbs/NURBSAPIApprox.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <modeling/MakeEdge.hpp>
#include <nurbs/NURBSAPIInterpolate.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
#include <modeling/MakeVertex.hpp>
#include <nurbs/NURBSAPIBuildCurve.hpp>
TEST_CASE("case1: this is a test for Approx", "[nurbs][Approx][P1]")
{
	double refTol = DEFAULT_TOLERANCE;
	SECTION("TestApproxPoints")
	{
		OUTPUT_DIRECTORY(nurbs, Approxs/ApproxPoints);
		std::vector<Point3> points;
		Point3 p1(0.0, 0.0, 0.0);
		Point3 p2(-0.1, 1.0, -0.2);
		Point3 p3(0.1, 2.0, -0.1);
		Point3 p4(0.2, 3.0, 0.1);
		Point3 p5(0.1, 4.0, 0.0);
		Point3 p6(0.0, 5.0, -0.1);
		points.push_back(p1);
		points.push_back(p2);
		points.push_back(p3);
		points.push_back(p4);
		points.push_back(p5);
		points.push_back(p6);
		int degree = 3;
		int npoles = 5;
		auto curve = NURBSAPIApprox::ApproxPoints(points, degree, npoles);
		TopoVertex v1 = MakeVertex(p1);
		TopoVertex v2 = MakeVertex(p2);
		TopoVertex v3 = MakeVertex(p3);
		TopoVertex v4 = MakeVertex(p4);
		TopoVertex v5 = MakeVertex(p5);
		TopoVertex v6 = MakeVertex(p6);
		TopoEdge edge = MakeEdge(curve);
		BRepExtremaDistShapeShape dist1(v1, edge);
		BRepExtremaDistShapeShape dist2(v2, edge);
		BRepExtremaDistShapeShape dist3(v3, edge);
		BRepExtremaDistShapeShape dist4(v4, edge);
		BRepExtremaDistShapeShape dist5(v5, edge);
		BRepExtremaDistShapeShape dist6(v6, edge);
		CHECK(dist1.Value() <= Approx(refTol));
		CHECK(dist2.Value() <= Approx(refTol));
		CHECK(dist3.Value() <= Approx(refTol));
		CHECK(dist4.Value() <= Approx(refTol));
		CHECK(dist5.Value() <= Approx(refTol));
		CHECK(dist6.Value() <= Approx(refTol));
		Point3 sp = curve->StartPoint();
		Point3 ep = curve->EndPoint();
		CHECK(sp.X() == p1.X());
		CHECK(sp.Y() == p1.Y());
		CHECK(sp.Z() == p1.Z());
		CHECK(ep.X() == p6.X());
		CHECK(ep.Y() == p6.Y());
		CHECK(ep.Z() == p6.Z());
		CHECK(curve->Degree() == 3);
		CHECK(curve->NPoles() == 5);
		CHECK(curve->IsClosed() == false);
		CHECK(curve->IsPeriodic() == false);
		OCCTIO::OCCTTool::Write(v1, outdir + "v1.brep");
		OCCTIO::OCCTTool::Write(v2, outdir + "v2.brep");
		OCCTIO::OCCTTool::Write(v3, outdir + "v3.brep");
		OCCTIO::OCCTTool::Write(v4, outdir + "v4.brep");
		OCCTIO::OCCTTool::Write(v5, outdir + "v5.brep");
		OCCTIO::OCCTTool::Write(v6, outdir + "v6.brep");
		OCCTIO::OCCTTool::Write(edge, outdir + "result.brep");
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static std::shared_ptr<Geom3BSplineCurve> BlendCurves( const std::shared_ptr<Geom3BSplineCurve>& curve1, bool isFront1, ContinuityType cont1, const std::shared_ptr<Geom3BSplineCurve>& curve2, bool isFront2, ContinuityType cont2),
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <nurbs/NURBSAPIBlend.hpp>
#include <modeling/MakeEdge.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
#include <modeling/MakeVertex.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <modeling/MakeFace.hpp>
#include <topology/BRepAdaptorCurve3.hpp>
#include <topology/TopoTool.hpp>
#include <io/ShapeTool.hpp>
#include <topology/TopoTool.hpp>
#include <topology/TopoCast.hpp>
#include <geometry/Geom3Surface.hpp>
#include <geometry/Geom3BSplineSurface.hpp>
#include <nurbs/NURBSAPIConvert.hpp>
#include <nurbs/NURBSAPIGetGeometry.hpp>
#include <topology/TopoExplorer.hpp>
#include <topology/TopoExplorerTool.hpp>
double NURBSSampleEdge(int num, double tol, const shared_ptr<Geom3Curve>& curve, const TopoEdge& edge)
{
	double fpu1 = curve->FirstParameter();
	double lpu1 = curve->LastParameter();
	double delta = (lpu1 - fpu1) / num;
	Point3 p;
	int n = 0;
	for (int i = 0; i < num; i++) {
		double t = fpu1 + i * delta;
		curve->D0(t, p);
		if (BRepClassificationTools::IsPointInOnEdge(edge, p, tol))
		{
			n++;
		}
	}
	double r1 = 1.0 * (num - n) / num;
	return r1;
}
TopoEdge ChooseSimilarEdge(const TopoShape& shape, const TopoEdge& edge)
{
	int nsample = 1000;
	Point3 p1, p2;
	BRepAdaptorCurve3 refC(edge);
	double refFp = refC.FirstParameter();
	double refLp = refC.LastParameter();
	for (TopoExplorer ex(shape, ShapeType::Edge); ex.More(); ex.Next())
	{
		const TopoEdge& cre = static_cast<const TopoEdge&>((ex.Current()));
		BRepAdaptorCurve3 crC(edge);
		double crFp = crC.FirstParameter();
		double crLp = crC.LastParameter();
		if (std::abs(refFp - crFp) < 0.001 && std::abs(refLp - crLp) < 0.001)
		{
			bool isOK = true;
			for (int i = 0; i < nsample; i++)
			{
				double t1 = refFp + i * (refLp - refFp) / (nsample - 1);
				double t2 = crFp + i * (crLp - crFp) / (nsample - 1);
				refC.D0(t1, p1);
				crC.D0(t2, p2);
				if (p1.Distance(p2) > 0.001)
				{
					isOK = false;
					break;
				}
			}
			if (isOK)
			{
				return cre;
			}
		}
	}
	TopoEdge e;
	return e;
}
TEST_CASE("case1: this is a test for testBlendCurves", "[nurbs][Blend][P1]")
{
	int num = 1000;	
	double ratio = 0.1;
	double refTol = DEFAULT_TOLERANCE;
	SECTION("testBlendCurves")
	{
		OUTPUT_DIRECTORY(nurbs, Blend/BlendCurves);
		auto cont1 = ContinuityType::G2;
		auto cont2 = ContinuityType::G2;
		bool isFront1 = true;
		bool isFront2 = true;
		std::shared_ptr<Geom3BSplineCurve> bsp1, bsp2;
		{
			std::vector<Point3> poles;
			poles.push_back(Point3(0., -1., 0.));
			poles.push_back(Point3(.7, -.7, 0.));
			poles.push_back(Point3(1., -.3, 0.));
			poles.push_back(Point3(1.2, 0., 0.));
			poles.push_back(Point3(2., .3, 0.));
			poles.push_back(Point3(.7, 1.7, 0.));
			poles.push_back(Point3(0., 1., 0.));
			std::vector<double> weights;
			weights.push_back(1.0);
			weights.push_back(1.3);
			weights.push_back(1.2);
			weights.push_back(0.7);
			weights.push_back(1.3);
			weights.push_back(1.0);
			weights.push_back(1.2);
			std::vector<double> knots;
			knots.push_back(0.);
			knots.push_back(.25);
			knots.push_back(.5);
			knots.push_back(.75);
			knots.push_back(1.);
			std::vector<int> mults(5, 1);
			mults.front() = 4;
			mults.back() = 4;
			bsp1 = std::make_shared<Geom3BSplineCurve>(poles, weights, knots, mults, 3);
		}
		{
			std::vector<Point3> spinePoles;
			std::vector<double> spineKnots(4);
			std::vector<int> spineMults(4, 1);
			spinePoles.push_back(Point3(0.0, 0.0, 0.0));
			spinePoles.push_back(Point3(-0.1, 1.0, -0.2));
			spinePoles.push_back(Point3(0.1, 2.0, -0.1));
			spinePoles.push_back(Point3(0.2, 3.0, 0.1));
			spinePoles.push_back(Point3(0.1, 4.0, 0.0));
			spinePoles.push_back(Point3(0.0, 5.0, -0.1));
			std::vector<double> weights;
			weights.push_back(1.0);
			weights.push_back(1.3);
			weights.push_back(1.2);
			weights.push_back(0.7);
			weights.push_back(1.3);
			weights.push_back(1.0);
			spineKnots[0] = 0;
			spineKnots[1] = 1.0 / 3.0;
			spineKnots[2] = 2.0 / 3.0;
			spineKnots[3] = 1;
			spineMults.front() = 4;
			spineMults.back() = 4;
			bsp2 = std::make_shared<Geom3BSplineCurve>(spinePoles, weights, spineKnots, spineMults, 3);
		}
		std::vector<double> params1, params2;
		auto bsp3 = NURBSAPIBlend::BlendCurves(bsp1, isFront1, cont1, params1, bsp2, isFront2, cont2, params2);
		Point3 sp1 = bsp1->StartPoint();
		Point3 ep1 = bsp1->EndPoint();
		Point3 sp2 = bsp2->StartPoint();
		Point3 ep2 = bsp2->EndPoint();
		Point3 sp3 = bsp3->StartPoint();
		Point3 ep3 = bsp3->EndPoint();
		CHECK(sp3.X() == Approx(sp1.X()).margin(1e-7));
		CHECK(sp3.Y() == Approx(sp1.Y()));
		CHECK(sp3.Z() == Approx(sp1.Z()));
		CHECK(ep3.X() == Approx(sp2.X()).margin(1e-7));
		CHECK(ep3.Y() == Approx(sp2.Y()).margin(1e-7));
		CHECK(ep3.Z() == Approx(sp2.Z()).margin(1e-7));
		shared_ptr<Geom3BSplineCurve> bspCurve = ReadBRepCurve(INPUT_PATH_PREFIX "/TestNURBS/TestBlendCurves/Rhino/rhinoResult.brep");
		double res = NurbsSampleCurve(num, refTol, bsp3, bspCurve);
		CHECK(res <= ratio);
		OCCTIO::OCCTTool::Write(MakeEdge(bsp1), outdir + "src1.brep");
		OCCTIO::OCCTTool::Write(MakeEdge(bsp2), outdir + "src2.brep");
		OCCTIO::OCCTTool::Write(MakeEdge(bsp3), outdir + "result.brep");
		OCCTIO::OCCTTool::Write(MakeEdge(bspCurve), outdir + "rhinoResult.brep");
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static std::shared_ptr<Geom3BSplineCurve> BlendCurves( const std::shared_ptr<Geom3BSplineCurve>& curve1, bool isFront1, ContinuityType cont1, std::vector<double>& parameters1, const std::shared_ptr<Geom3BSplineCurve>& curve2, bool isFront2, ContinuityType cont2, std::vector<double>& parameters2),
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <nurbs/NURBSAPIBlend.hpp>
#include <modeling/MakeEdge.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
#include <modeling/MakeVertex.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <modeling/MakeFace.hpp>
#include <topology/BRepAdaptorCurve3.hpp>
#include <topology/TopoTool.hpp>
#include <io/ShapeTool.hpp>
#include <topology/TopoTool.hpp>
#include <topology/TopoCast.hpp>
#include <geometry/Geom3Surface.hpp>
#include <geometry/Geom3BSplineSurface.hpp>
#include <nurbs/NURBSAPIConvert.hpp>
#include <nurbs/NURBSAPIGetGeometry.hpp>
#include <topology/TopoExplorer.hpp>
#include <topology/TopoExplorerTool.hpp>
double NURBSSampleEdge(int num, double tol, const shared_ptr<Geom3Curve>& curve, const TopoEdge& edge)
{
	double fpu1 = curve->FirstParameter();
	double lpu1 = curve->LastParameter();
	double delta = (lpu1 - fpu1) / num;
	Point3 p;
	int n = 0;
	for (int i = 0; i < num; i++) {
		double t = fpu1 + i * delta;
		curve->D0(t, p);
		if (BRepClassificationTools::IsPointInOnEdge(edge, p, tol))
		{
			n++;
		}
	}
	double r1 = 1.0 * (num - n) / num;
	return r1;
}
TopoEdge ChooseSimilarEdge(const TopoShape& shape, const TopoEdge& edge)
{
	int nsample = 1000;
	Point3 p1, p2;
	BRepAdaptorCurve3 refC(edge);
	double refFp = refC.FirstParameter();
	double refLp = refC.LastParameter();
	for (TopoExplorer ex(shape, ShapeType::Edge); ex.More(); ex.Next())
	{
		const TopoEdge& cre = static_cast<const TopoEdge&>((ex.Current()));
		BRepAdaptorCurve3 crC(edge);
		double crFp = crC.FirstParameter();
		double crLp = crC.LastParameter();
		if (std::abs(refFp - crFp) < 0.001 && std::abs(refLp - crLp) < 0.001)
		{
			bool isOK = true;
			for (int i = 0; i < nsample; i++)
			{
				double t1 = refFp + i * (refLp - refFp) / (nsample - 1);
				double t2 = crFp + i * (crLp - crFp) / (nsample - 1);
				refC.D0(t1, p1);
				crC.D0(t2, p2);
				if (p1.Distance(p2) > 0.001)
				{
					isOK = false;
					break;
				}
			}
			if (isOK)
			{
				return cre;
			}
		}
	}
	TopoEdge e;
	return e;
}
TEST_CASE("bug2: TestBridgeTrimmedPeriodicFace ", "[nurbs][Blend][fixbug]")
{
	int num = 1000;
	double ratio = 0.1;
	double refTol = DEFAULT_TOLERANCE;
	SECTION("TestBridgeCurve2")
	{
		OUTPUT_DIRECTORY(nurbs, Blend/bug680/BridgeCurve2);
		std::string filedir = INPUT_PATH_PREFIX "/TestNURBS/TestBridgeCurve2/";
		auto curve1 = ReadBRepCurve(filedir + "curve1.brep");
		auto curve2 = ReadBRepCurve(filedir + "curve2.brep");
		auto bridge = NURBSAPIBlend::BlendCurves(curve1, false, ContinuityType::G2, curve2, true, ContinuityType::G2);
		Point3 sp1 = curve1->StartPoint();
		Point3 ep1 = curve1->EndPoint();
		Point3 sp2 = curve2->StartPoint();
		Point3 ep2 = curve2->EndPoint();
		Point3 sp3 = bridge->StartPoint();
		Point3 ep3 = bridge->EndPoint();
		CHECK(sp3.X() == Approx(ep1.X()).margin(1e-7));
		CHECK(sp3.Y() == Approx(ep1.Y()));
		CHECK(sp3.Z() == Approx(ep1.Z()));
		CHECK(ep3.X() == Approx(sp2.X()).margin(1e-7));
		CHECK(ep3.Y() == Approx(sp2.Y()).margin(1e-7));
		CHECK(ep3.Z() == Approx(sp2.Z()).margin(1e-7));
		auto curve = ReadBRepCurve(filedir + "Rhino/rhinoResult.brep");
		double res = NurbsSampleCurve(num, refTol, bridge, curve);
		OCCTIO::OCCTTool::Write(MakeEdge(curve1), outdir + "src1.brep");
		OCCTIO::OCCTTool::Write(MakeEdge(curve2), outdir + "src2.brep");
		OCCTIO::OCCTTool::Write(MakeEdge(bridge), outdir + "result.brep");
		OCCTIO::OCCTTool::Write(MakeEdge(curve), outdir + "rhinoResult.brep");
	}
}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static std::shared_ptr<Geom3BSplineSurface> BlendSurfaces( const std::shared_ptr<Geom3BSplineSurface>& surf1, bool isUIso1, bool isFront1, ContinuityType cont1, std::vector<double>& parameters1, const std::shared_ptr<Geom3BSplineSurface>& surf2, bool isUIso2, bool isFront2, ContinuityType cont2, std::vector<double>& parameters2, bool autoReverse, bool isPrecise, const std::vector<double>& tol),
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <nurbs/NURBSAPIBlend.hpp>
#include <modeling/MakeEdge.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
#include <modeling/MakeVertex.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <modeling/MakeFace.hpp>
#include <topology/BRepAdaptorCurve3.hpp>
#include <topology/TopoTool.hpp>
#include <io/ShapeTool.hpp>
#include <topology/TopoTool.hpp>
#include <topology/TopoCast.hpp>
#include <geometry/Geom3Surface.hpp>
#include <geometry/Geom3BSplineSurface.hpp>
#include <nurbs/NURBSAPIConvert.hpp>
#include <nurbs/NURBSAPIGetGeometry.hpp>
#include <topology/TopoExplorer.hpp>
#include <topology/TopoExplorerTool.hpp>
double NURBSSampleEdge(int num, double tol, const shared_ptr<Geom3Curve>& curve, const TopoEdge& edge)
{
	double fpu1 = curve->FirstParameter();
	double lpu1 = curve->LastParameter();
	double delta = (lpu1 - fpu1) / num;
	Point3 p;
	int n = 0;
	for (int i = 0; i < num; i++) {
		double t = fpu1 + i * delta;
		curve->D0(t, p);
		if (BRepClassificationTools::IsPointInOnEdge(edge, p, tol))
		{
			n++;
		}
	}
	double r1 = 1.0 * (num - n) / num;
	return r1;
}
TopoEdge ChooseSimilarEdge(const TopoShape& shape, const TopoEdge& edge)
{
	int nsample = 1000;
	Point3 p1, p2;
	BRepAdaptorCurve3 refC(edge);
	double refFp = refC.FirstParameter();
	double refLp = refC.LastParameter();
	for (TopoExplorer ex(shape, ShapeType::Edge); ex.More(); ex.Next())
	{
		const TopoEdge& cre = static_cast<const TopoEdge&>((ex.Current()));
		BRepAdaptorCurve3 crC(edge);
		double crFp = crC.FirstParameter();
		double crLp = crC.LastParameter();
		if (std::abs(refFp - crFp) < 0.001 && std::abs(refLp - crLp) < 0.001)
		{
			bool isOK = true;
			for (int i = 0; i < nsample; i++)
			{
				double t1 = refFp + i * (refLp - refFp) / (nsample - 1);
				double t2 = crFp + i * (crLp - crFp) / (nsample - 1);
				refC.D0(t1, p1);
				crC.D0(t2, p2);
				if (p1.Distance(p2) > 0.001)
				{
					isOK = false;
					break;
				}
			}
			if (isOK)
			{
				return cre;
			}
		}
	}
	TopoEdge e;
	return e;
}
TEST_CASE("case1: this is a test for testBlendSurf", "[nurbs][Blend][P1]")
{
	int num = 1000;
	double ratio = 0.1;
	double refTol = DEFAULT_TOLERANCE;
	SECTION("testBridgeSurf")
	{
		OUTPUT_DIRECTORY(nurbs, Blend/BridgeSurf);
		auto surf1 = ReadBRepSurface(INPUT_PATH_PREFIX "/TestNURBS/TestBridgeSurf/surface1.brep");
		auto surf2 = ReadBRepSurface(INPUT_PATH_PREFIX "/TestNURBS/TestBridgeSurf/surface2.brep");
		bool isU1 = true, isFront1 = true, isU2 = true, isFront2 = true;
		ContinuityType cont1 = ContinuityType::G2;
		ContinuityType cont2 = ContinuityType::G2;
		bool isAutoReverse = true;
		bool isPrecise = true;
		std::vector<double> tol;
		tol.push_back(0.001);
		tol.push_back(M_PI / 180.0);
		tol.push_back(0.0005);
		std::vector<double> params1, params2;
		shared_ptr<Geom3BSplineSurface> bspSurf3 = NURBSAPIBlend::BlendSurfaces(surf1, isU2, isFront2, cont1, params1, surf2, isU1, isFront1, cont2, params2, isAutoReverse, isPrecise, tol);
		BRepExtremaDistShapeShape dist1(MakeFace(surf1, 0.0), MakeFace(bspSurf3, 0.0));
		BRepExtremaDistShapeShape dist2(MakeFace(surf2, 0.0), MakeFace(bspSurf3, 0.0));
		CHECK(dist1.Value() == Approx(0.0).margin(0.1));
		CHECK(dist2.Value() == Approx(0.0).margin(0.1));
		double fpu1 = bspSurf3->FirstUParameter();
		double lpu1 = bspSurf3->LastUParameter();
		shared_ptr<Geom3Curve> u1 = bspSurf3->UIso(fpu1);
		shared_ptr<Geom3Curve> u2 = bspSurf3->UIso(lpu1);
		double f1 = surf1->FirstUParameter();
		double f2 = surf2->FirstUParameter();
		shared_ptr<Geom3Curve> c1 = surf1->UIso(f1);
		shared_ptr<Geom3Curve> c2 = surf2->UIso(f2);
		bool res1 = IsCurveOnSurf(num, ratio, u1, surf1);
		bool res2 = IsCurveOnSurf(num, ratio, u2, surf2);
		CHECK(res1 == true);
		CHECK(res2 == true);
		double res3 = NurbsSampleCurve(num, refTol, c1, u1);
		double res4 = NurbsSampleCurve(num, refTol, c2, u2);
		CHECK(res3 <= ratio);
		CHECK(res4 <= ratio);
		OCCTIO::OCCTTool::Write(MakeEdge(u1), outdir + "u1.brep");
		OCCTIO::OCCTTool::Write(MakeEdge(u2), outdir + "u2.brep");
		OCCTIO::OCCTTool::Write(MakeEdge(c1), outdir + "c1.brep");
		OCCTIO::OCCTTool::Write(MakeEdge(c2), outdir + "c2.brep");
		OCCTIO::OCCTTool::Write(MakeFace(surf1, 0.0), outdir + "src1.brep");
		OCCTIO::OCCTTool::Write(MakeFace(surf2, 0.0), outdir + "src2.brep");
		OCCTIO::OCCTTool::Write(MakeFace(bspSurf3, 0.0), outdir + "result.brep");
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static std::shared_ptr<Geom3BSplineSurface> BlendFaces( const TopoFace& face1, const TopoEdge& edge1, ContinuityType cont1, std::vector<double>& parameters1, const TopoFace& face2, const TopoEdge& edge2, ContinuityType cont2, std::vector<double>& parameters2, bool autoReverse, bool isPrecise, const std::vector<double>& tol),
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <nurbs/NURBSAPIBlend.hpp>
#include <modeling/MakeEdge.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
#include <modeling/MakeVertex.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <modeling/MakeFace.hpp>
#include <topology/BRepAdaptorCurve3.hpp>
#include <topology/TopoTool.hpp>
#include <io/ShapeTool.hpp>
#include <topology/TopoTool.hpp>
#include <topology/TopoCast.hpp>
#include <geometry/Geom3Surface.hpp>
#include <geometry/Geom3BSplineSurface.hpp>
#include <nurbs/NURBSAPIConvert.hpp>
#include <nurbs/NURBSAPIGetGeometry.hpp>
#include <topology/TopoExplorer.hpp>
#include <topology/TopoExplorerTool.hpp>
double NURBSSampleEdge(int num, double tol, const shared_ptr<Geom3Curve>& curve, const TopoEdge& edge)
{
	double fpu1 = curve->FirstParameter();
	double lpu1 = curve->LastParameter();
	double delta = (lpu1 - fpu1) / num;
	Point3 p;
	int n = 0;
	for (int i = 0; i < num; i++) {
		double t = fpu1 + i * delta;
		curve->D0(t, p);
		if (BRepClassificationTools::IsPointInOnEdge(edge, p, tol))
		{
			n++;
		}
	}
	double r1 = 1.0 * (num - n) / num;
	return r1;
}
TopoEdge ChooseSimilarEdge(const TopoShape& shape, const TopoEdge& edge)
{
	int nsample = 1000;
	Point3 p1, p2;
	BRepAdaptorCurve3 refC(edge);
	double refFp = refC.FirstParameter();
	double refLp = refC.LastParameter();
	for (TopoExplorer ex(shape, ShapeType::Edge); ex.More(); ex.Next())
	{
		const TopoEdge& cre = static_cast<const TopoEdge&>((ex.Current()));
		BRepAdaptorCurve3 crC(edge);
		double crFp = crC.FirstParameter();
		double crLp = crC.LastParameter();
		if (std::abs(refFp - crFp) < 0.001 && std::abs(refLp - crLp) < 0.001)
		{
			bool isOK = true;
			for (int i = 0; i < nsample; i++)
			{
				double t1 = refFp + i * (refLp - refFp) / (nsample - 1);
				double t2 = crFp + i * (crLp - crFp) / (nsample - 1);
				refC.D0(t1, p1);
				crC.D0(t2, p2);
				if (p1.Distance(p2) > 0.001)
				{
					isOK = false;
					break;
				}
			}
			if (isOK)
			{
				return cre;
			}
		}
	}
	TopoEdge e;
	return e;
}
TEST_CASE("bug3: TestBridgeTrimmedPeriodicFace ", "[nurbs][Blend][fixbug]")
{
	OUTPUT_DIRECTORY(nurbs, Blend/bug684/testBlendFaces);
	std::string filedir = INPUT_PATH_PREFIX "/TestNURBS/TestBlendFaces/";
	TopoFace f1 = ReadBRepFace(filedir + "surfaceShapeFrom1.brep");
	TopoFace f2 = ReadBRepFace(filedir + "surfaceShapeFrom2.brep");
	vector<TopoEdge>vec1;
	vector<TopoEdge>vec2;
	for (TopoExplorer exp(f1, ShapeType::Edge); exp.More(); exp.Next())
	{
		TopoEdge c1 = static_cast<const TopoEdge&>(exp.Current());
		vec1.push_back(c1);
	}
	for (TopoExplorer expE(f2, ShapeType::Edge); expE.More(); expE.Next())
	{
		TopoEdge c2 = static_cast<const TopoEdge&>(expE.Current());
		vec2.push_back(c2);
	}
	vector<double>parameters1 = { 1.0, 1.0 };
	vector<double>parameters2 = { 1.0, 1.0 };
	vector<double>tol = { 0.001, 0.1 * M_PI / 180.0, 0.05 };
	for (int i = 0; i < vec1.size(); i++)
	{
		for (int j = 0; j < vec2.size(); j++)
		{
			shared_ptr<Geom3BSplineSurface> blendSurface = NURBSAPIBlend::BlendFaces(f1, vec1[i], ContinuityType::G2, parameters1, f2, vec2[j], ContinuityType::G2, parameters2, true, true, tol);
			OCCTIO::OCCTTool::Write(MakeFace(blendSurface, 0.0), outdir + "G2-result" + to_string(i + 1) + to_string(j + 1) + ".brep");
		}
	}
	OCCTIO::OCCTTool::Write(f1, outdir + "f1.brep");
	OCCTIO::OCCTTool::Write(f2, outdir + "f2.brep");
	OCCTIO::OCCTTool::Write(vec1[0], outdir + "e1.brep");
	OCCTIO::OCCTTool::Write(vec1[1], outdir + "e2.brep");
	OCCTIO::OCCTTool::Write(vec1[2], outdir + "e3.brep");
	OCCTIO::OCCTTool::Write(vec1[3], outdir + "e4.brep");
	OCCTIO::OCCTTool::Write(vec2[0], outdir + "e11.brep");
	OCCTIO::OCCTTool::Write(vec2[1], outdir + "e22.brep");
	OCCTIO::OCCTTool::Write(vec2[2], outdir + "e33.brep");
	OCCTIO::OCCTTool::Write(vec2[3], outdir + "e44.brep");
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static std::shared_ptr<Geom3BSplineCurve> BlendCurves( const std::shared_ptr<Geom3BSplineCurve>& curve1, bool isFront1, ContinuityType cont1, const std::shared_ptr<Geom3BSplineCurve>& curve2, bool isFront2, ContinuityType cont2),
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <nurbs/NURBSAPIBlend.hpp>
#include <modeling/MakeEdge.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
#include <modeling/MakeVertex.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <modeling/MakeFace.hpp>
#include <topology/BRepAdaptorCurve3.hpp>
#include <topology/TopoTool.hpp>
#include <io/ShapeTool.hpp>
#include <topology/TopoTool.hpp>
#include <topology/TopoCast.hpp>
#include <geometry/Geom3Surface.hpp>
#include <geometry/Geom3BSplineSurface.hpp>
#include <nurbs/NURBSAPIConvert.hpp>
#include <nurbs/NURBSAPIGetGeometry.hpp>
#include <topology/TopoExplorer.hpp>
#include <topology/TopoExplorerTool.hpp>
#include <geometry/Geom3CurveLocalProperty.hpp>
TEST_CASE("Not Fix bug1: testBlendCurves2-Extend ", "[nurbs][Blend][bug]")
{
	std::shared_ptr<Geom3BSplineCurve> bsp1, bsp2;
	{
		std::vector<Point3> poles;
		poles.push_back(Point3(0., -1., 0.));
		poles.push_back(Point3(.7, -.7, 0.));
		poles.push_back(Point3(1., -.3, 0.));
		poles.push_back(Point3(1.2, 0., 0.));
		poles.push_back(Point3(2., .3, 0.));
		poles.push_back(Point3(.7, 1.7, 0.));
		poles.push_back(Point3(0., 1., 0.));
		std::vector<double> weights;
		weights.push_back(1.0);
		weights.push_back(1.3);
		weights.push_back(1.2);
		weights.push_back(0.7);
		weights.push_back(1.3);
		weights.push_back(1.0);
		weights.push_back(1.2);
		std::vector<double> knots;
		knots.push_back(0.);
		knots.push_back(.25);
		knots.push_back(.5);
		knots.push_back(.75);
		knots.push_back(1.);
		std::vector<int> mults(5, 1);
		mults.front() = 4;
		mults.back() = 4;
		bsp1 = std::make_shared<Geom3BSplineCurve>(poles, weights, knots, mults, 3);
	}
	{
		std::vector<Point3> spinePoles;
		std::vector<double> spineKnots(4);
		std::vector<int> spineMults(4, 1);
		spinePoles.push_back(Point3(0.0, 0.0, 0.0));
		spinePoles.push_back(Point3(-0.1, 1.0, -0.2));
		spinePoles.push_back(Point3(0.1, 2.0, -0.1));
		spinePoles.push_back(Point3(0.2, 3.0, 0.1));
		spinePoles.push_back(Point3(0.1, 4.0, 0.0));
		spinePoles.push_back(Point3(0.0, 5.0, -0.1));
		std::vector<double> weights;
		weights.push_back(1.0);
		weights.push_back(1.3);
		weights.push_back(1.2);
		weights.push_back(0.7);
		weights.push_back(1.3);
		weights.push_back(1.0);
		spineKnots[0] = 0;
		spineKnots[1] = 1.0 / 3.0;
		spineKnots[2] = 2.0 / 3.0;
		spineKnots[3] = 1;
		spineMults.front() = 4;
		spineMults.back() = 4;
		bsp2 = std::make_shared<Geom3BSplineCurve>(spinePoles, weights, spineKnots, spineMults, 3);
	}
	double lp1 = bsp1->LastParameter();
	Point3 p1, pp1, p2, pp2;
	Vector3 ev1;
	bsp1->D1(lp1, pp1, ev1);
	std::vector<double> params1, params2;
	auto cont1 = ContinuityType::G2;
	auto cont2 = ContinuityType::G2;
	SECTION("false+true")
	{
		OUTPUT_DIRECTORY(nurbs, Blend/Extend/bug792);
		bool isFront1 = false;
		bool isFront2 = true;
		auto bsp3 = NURBSAPIBlend::BlendCurves(bsp1, isFront1, cont1, params1, bsp2, isFront2, cont2, params2);
		double fp3 = bsp3->FirstParameter();
		Point3 p3;
		Vector3 sv3;
		bsp3->D1(fp3, p3, sv3);
		bool res1 = Direction3(sv3).IsParallel(Direction3(ev1), Precision::Angular());
		CHECK(res1 == true);
		OCCTIO::OCCTTool::Write(MakeVertex(p3), outdir + "p3.brep");
		OCCTIO::OCCTTool::Write(MakeVertex(pp1), outdir + "pp1.brep");
		OCCTIO::OCCTTool::Write(MakeEdge(bsp1), outdir + "src1.brep");
		OCCTIO::OCCTTool::Write(MakeEdge(bsp2), outdir + "src2.brep");
		OCCTIO::OCCTTool::Write(MakeEdge(bsp3), outdir + "result.brep");
	}
}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static std::shared_ptr<Geom3BSplineCurve> BlendCurves( const std::shared_ptr<Geom3BSplineCurve>& curve1, bool isFront1, ContinuityType cont1, std::vector<double>& parameters1, const std::shared_ptr<Geom3BSplineCurve>& curve2, bool isFront2, ContinuityType cont2, std::vector<double>& parameters2),
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <nurbs/NURBSAPIBlend.hpp>
#include <modeling/MakeEdge.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
#include <modeling/MakeVertex.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <modeling/MakeFace.hpp>
#include <topology/BRepAdaptorCurve3.hpp>
#include <topology/TopoTool.hpp>
#include <io/ShapeTool.hpp>
#include <topology/TopoTool.hpp>
#include <topology/TopoCast.hpp>
#include <geometry/Geom3Surface.hpp>
#include <geometry/Geom3BSplineSurface.hpp>
#include <nurbs/NURBSAPIConvert.hpp>
#include <nurbs/NURBSAPIGetGeometry.hpp>
#include <topology/TopoExplorer.hpp>
#include <topology/TopoExplorerTool.hpp>
#include <geometry/Geom3CurveLocalProperty.hpp>
TEST_CASE("Not Fix bug1: testBlendCurves2-Extend ", "[nurbs][Blend][bug]")
{
	std::shared_ptr<Geom3BSplineCurve> bsp1, bsp2;
	{
		std::vector<Point3> poles;
		poles.push_back(Point3(0., -1., 0.));
		poles.push_back(Point3(.7, -.7, 0.));
		poles.push_back(Point3(1., -.3, 0.));
		poles.push_back(Point3(1.2, 0., 0.));
		poles.push_back(Point3(2., .3, 0.));
		poles.push_back(Point3(.7, 1.7, 0.));
		poles.push_back(Point3(0., 1., 0.));
		std::vector<double> weights;
		weights.push_back(1.0);
		weights.push_back(1.3);
		weights.push_back(1.2);
		weights.push_back(0.7);
		weights.push_back(1.3);
		weights.push_back(1.0);
		weights.push_back(1.2);
		std::vector<double> knots;
		knots.push_back(0.);
		knots.push_back(.25);
		knots.push_back(.5);
		knots.push_back(.75);
		knots.push_back(1.);
		std::vector<int> mults(5, 1);
		mults.front() = 4;
		mults.back() = 4;
		bsp1 = std::make_shared<Geom3BSplineCurve>(poles, weights, knots, mults, 3);
	}
	{
		std::vector<Point3> spinePoles;
		std::vector<double> spineKnots(4);
		std::vector<int> spineMults(4, 1);
		spinePoles.push_back(Point3(0.0, 0.0, 0.0));
		spinePoles.push_back(Point3(-0.1, 1.0, -0.2));
		spinePoles.push_back(Point3(0.1, 2.0, -0.1));
		spinePoles.push_back(Point3(0.2, 3.0, 0.1));
		spinePoles.push_back(Point3(0.1, 4.0, 0.0));
		spinePoles.push_back(Point3(0.0, 5.0, -0.1));
		std::vector<double> weights;
		weights.push_back(1.0);
		weights.push_back(1.3);
		weights.push_back(1.2);
		weights.push_back(0.7);
		weights.push_back(1.3);
		weights.push_back(1.0);
		spineKnots[0] = 0;
		spineKnots[1] = 1.0 / 3.0;
		spineKnots[2] = 2.0 / 3.0;
		spineKnots[3] = 1;
		spineMults.front() = 4;
		spineMults.back() = 4;
		bsp2 = std::make_shared<Geom3BSplineCurve>(spinePoles, weights, spineKnots, spineMults, 3);
	}
	double lp1 = bsp1->LastParameter();
	Point3 p1, pp1, p2, pp2;
	Vector3 ev1;
	bsp1->D1(lp1, pp1, ev1);
	std::vector<double> params1, params2;
	auto cont1 = ContinuityType::G2;
	auto cont2 = ContinuityType::G2;
	SECTION("false+true")
	{
		OUTPUT_DIRECTORY(nurbs, Blend/Extend/bug792);
		bool isFront1 = false;
		bool isFront2 = true;
		auto bsp3 = NURBSAPIBlend::BlendCurves(bsp1, isFront1, cont1, params1, bsp2, isFront2, cont2, params2);
		double fp3 = bsp3->FirstParameter();
		Point3 p3;
		Vector3 sv3;
		bsp3->D1(fp3, p3, sv3);
		bool res1 = Direction3(sv3).IsParallel(Direction3(ev1), Precision::Angular());
		CHECK(res1 == true);
		OCCTIO::OCCTTool::Write(MakeVertex(p3), outdir + "p3.brep");
		OCCTIO::OCCTTool::Write(MakeVertex(pp1), outdir + "pp1.brep");
		OCCTIO::OCCTTool::Write(MakeEdge(bsp1), outdir + "src1.brep");
		OCCTIO::OCCTTool::Write(MakeEdge(bsp2), outdir + "src2.brep");
		OCCTIO::OCCTTool::Write(MakeEdge(bsp3), outdir + "result.brep");
	}
}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static std::shared_ptr<Geom3BSplineSurface> BlendSurfaces( const std::shared_ptr<Geom3BSplineSurface>& surf1, bool isUIso1, bool isFront1, ContinuityType cont1, std::vector<double>& parameters1, const std::shared_ptr<Geom3BSplineSurface>& surf2, bool isUIso2, bool isFront2, ContinuityType cont2, std::vector<double>& parameters2, bool autoReverse, bool isPrecise, const std::vector<double>& tol),
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <nurbs/NURBSAPIBlend.hpp>
#include <modeling/MakeEdge.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
#include <modeling/MakeVertex.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <modeling/MakeFace.hpp>
#include <topology/BRepAdaptorCurve3.hpp>
#include <topology/TopoTool.hpp>
#include <io/ShapeTool.hpp>
#include <topology/TopoTool.hpp>
#include <topology/TopoCast.hpp>
#include <geometry/Geom3Surface.hpp>
#include <geometry/Geom3BSplineSurface.hpp>
#include <nurbs/NURBSAPIConvert.hpp>
#include <nurbs/NURBSAPIGetGeometry.hpp>
#include <topology/TopoExplorer.hpp>
#include <topology/TopoExplorerTool.hpp>
#include <geometry/Geom3CurveLocalProperty.hpp>
#include <geometry/GeomAPIProjectPointOnCurve3.hpp>
double NURBSSampleEdge1(int num, double tol, const shared_ptr<Geom3Curve>& curve, const TopoEdge& edge)
{
	double fpu1 = curve->FirstParameter();
	double lpu1 = curve->LastParameter();
	double delta = (lpu1 - fpu1) / num;
	Point3 p;
	int n = 0;
	for (int i = 0; i < num; i++) {
		double t = fpu1 + i * delta;
		curve->D0(t, p);
		if (BRepClassificationTools::IsPointInOnEdge(edge, p, tol))
		{
			n++;
		}
	}
	double r1 = 1.0 * (num - n) / num;
	return r1;
}
TopoEdge ChooseSimilarEdge1(const TopoShape& shape, const TopoEdge& edge)
{
	int nsample = 1000;
	Point3 p1, p2;
	BRepAdaptorCurve3 refC(edge);
	double refFp = refC.FirstParameter();
	double refLp = refC.LastParameter();
	for (TopoExplorer ex(shape, ShapeType::Edge); ex.More(); ex.Next())
	{
		const TopoEdge& cre = static_cast<const TopoEdge&>((ex.Current()));
		BRepAdaptorCurve3 crC(edge);
		double crFp = crC.FirstParameter();
		double crLp = crC.LastParameter();
		if (std::abs(refFp - crFp) < 0.001 && std::abs(refLp - crLp) < 0.001)
		{
			bool isOK = true;
			for (int i = 0; i < nsample; i++)
			{
				double t1 = refFp + i * (refLp - refFp) / (nsample - 1);
				double t2 = crFp + i * (crLp - crFp) / (nsample - 1);
				refC.D0(t1, p1);
				crC.D0(t2, p2);
				if (p1.Distance(p2) > 0.001)
				{
					isOK = false;
					break;
				}
			}
			if (isOK)
			{
				return cre;
			}
		}
	}
	TopoEdge e;
	return e;
}
TEST_CASE("Not Fix bug1: testBlendSurfaces-Extend ", "[nurbs][Blend][bug]")
{
	bool isAutoReverse = true;
	bool isPrecise = true;
	std::vector<double> tol;
	tol.push_back(0.001);
	tol.push_back(M_PI / 180.0);
	tol.push_back(0.0005);
	std::vector<double> params1, params2;
	auto surf1 = ReadBRepSurface(INPUT_PATH_PREFIX "/TestNURBS/TestBridgeSurf/surface1.brep");
	auto surf2 = ReadBRepSurface(INPUT_PATH_PREFIX "/TestNURBS/TestBridgeSurf/surface2.brep");
	SECTION("ContinuityType::C0")
	{
		ContinuityType cont1 = ContinuityType::C0;
		ContinuityType cont2 = ContinuityType::C0;
		bool isU1 = false;
		bool isU2 = false;}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static std::shared_ptr<Geom3BSplineSurface> BlendFaces( const TopoFace& face1, const TopoEdge& edge1, ContinuityType cont1, std::vector<double>& parameters1, const TopoFace& face2, const TopoEdge& edge2, ContinuityType cont2, std::vector<double>& parameters2, bool autoReverse, bool isPrecise, const std::vector<double>& tol),
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <nurbs/NURBSAPIBlend.hpp>
#include <modeling/MakeEdge.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
#include <modeling/MakeVertex.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <modeling/MakeFace.hpp>
#include <topology/BRepAdaptorCurve3.hpp>
#include <topology/TopoTool.hpp>
#include <io/ShapeTool.hpp>
#include <topology/TopoTool.hpp>
#include <topology/TopoCast.hpp>
#include <geometry/Geom3Surface.hpp>
#include <geometry/Geom3BSplineSurface.hpp>
#include <nurbs/NURBSAPIConvert.hpp>
#include <nurbs/NURBSAPIGetGeometry.hpp>
#include <topology/TopoExplorer.hpp>
#include <topology/TopoExplorerTool.hpp>
#include <geometry/Geom3CurveLocalProperty.hpp>
#include <geometry/GeomAPIProjectPointOnCurve3.hpp>
double NURBSSampleEdge1(int num, double tol, const shared_ptr<Geom3Curve>& curve, const TopoEdge& edge)
{
	double fpu1 = curve->FirstParameter();
	double lpu1 = curve->LastParameter();
	double delta = (lpu1 - fpu1) / num;
	Point3 p;
	int n = 0;
	for (int i = 0; i < num; i++) {
		double t = fpu1 + i * delta;
		curve->D0(t, p);
		if (BRepClassificationTools::IsPointInOnEdge(edge, p, tol))
		{
			n++;
		}
	}
	double r1 = 1.0 * (num - n) / num;
	return r1;
}
TopoEdge ChooseSimilarEdge1(const TopoShape& shape, const TopoEdge& edge)
{
	int nsample = 1000;
	Point3 p1, p2;
	BRepAdaptorCurve3 refC(edge);
	double refFp = refC.FirstParameter();
	double refLp = refC.LastParameter();
	for (TopoExplorer ex(shape, ShapeType::Edge); ex.More(); ex.Next())
	{
		const TopoEdge& cre = static_cast<const TopoEdge&>((ex.Current()));
		BRepAdaptorCurve3 crC(edge);
		double crFp = crC.FirstParameter();
		double crLp = crC.LastParameter();
		if (std::abs(refFp - crFp) < 0.001 && std::abs(refLp - crLp) < 0.001)
		{
			bool isOK = true;
			for (int i = 0; i < nsample; i++)
			{
				double t1 = refFp + i * (refLp - refFp) / (nsample - 1);
				double t2 = crFp + i * (crLp - crFp) / (nsample - 1);
				refC.D0(t1, p1);
				crC.D0(t2, p2);
				if (p1.Distance(p2) > 0.001)
				{
					isOK = false;
					break;
				}
			}
			if (isOK)
			{
				return cre;
			}
		}
	}
	TopoEdge e;
	return e;
}
TEST_CASE("case1: this is a test for testBlendSurfaces-Extend", "[nurbs][Blend][P1]")
{
	int num = 1000;
	double ratio = 0.1;
	double refTol = DEFAULT_TOLERANCE;
	bool isAutoReverse = true;
	bool isPrecise = true;
	std::vector<double> tol;
	tol.push_back(0.001);
	tol.push_back(M_PI / 180.0);
	tol.push_back(0.0005);
	std::vector<double> params1, params2;
	auto surf1 = ReadBRepSurface(INPUT_PATH_PREFIX "/TestNURBS/TestBridgeSurf/surface1.brep");
	auto surf2 = ReadBRepSurface(INPUT_PATH_PREFIX "/TestNURBS/TestBridgeSurf/surface2.brep");
	double fup1 = surf1->FirstUParameter();
	double lup1 = surf1->LastUParameter();
	double fvp1 = surf1->FirstVParameter();
	double lvp1 = surf1->LastVParameter();
	shared_ptr<Geom3Curve> fuc1 = surf1->UIso(fup1);
	shared_ptr<Geom3Curve> luc1 = surf1->UIso(lup1);
	shared_ptr<Geom3Curve> fvc1 = surf1->VIso(fvp1);
	shared_ptr<Geom3Curve> lvc1 = surf1->VIso(lvp1);
	double uf1 = fuc1->FirstParameter();
	double ul1 = luc1->FirstParameter();
	double vf1 = fvc1->FirstParameter();
	double vl1 = lvc1->FirstParameter();
	Point3 p1, p2 , p3, p4;
	Vector3 fuv1, luv1, fvv1, lvv1;
	fuc1->D1(uf1, p1, fuv1);
	luc1->D1(ul1, p2, luv1);
	fvc1->D1(vf1, p3, fvv1);
	lvc1->D1(vl1, p4, lvv1);
	double fup2 = surf2->FirstUParameter();
	double lup2 = surf2->LastUParameter();
	double fvp2 = surf2->FirstVParameter();
	double lvp2 = surf2->LastVParameter();
	shared_ptr<Geom3Curve> fuc2 = surf2->UIso(fup2);
	shared_ptr<Geom3Curve> luc2 = surf2->UIso(lup2);
	shared_ptr<Geom3Curve> fvc2 = surf2->VIso(fvp2);
	shared_ptr<Geom3Curve> lvc2 = surf2->VIso(lvp2);
	double uf2 = fuc2->FirstParameter();
	double ul2 = luc2->FirstParameter();
	double vf2 = fvc2->FirstParameter();
	double vl2 = lvc2->FirstParameter();
	Point3 p5, p6, p7, p8;
	Vector3 fuv2, luv2, fvv2, lvv2;
	fuc2->D1(uf2, p5, fuv2);
	luc2->D1(ul2, p6, luv2);
	fvc2->D1(vf2, p7, fvv2);
	lvc2->D1(vl2, p8, lvv2);
	SECTION("isFront:true+true")
			{
				OUTPUT_DIRECTORY(nurbs, Blend/Extend/BlendSurfaces/G2/tt/tt);
				bool isFront1 = true;
				bool isFront2 = true;
				shared_ptr<Geom3BSplineSurface> bspSurf3 = NURBSAPIBlend::BlendSurfaces(surf1, isU1, isFront1, cont1, params1, surf2, isU2, isFront2, cont2, params2, isAutoReverse, isPrecise, tol);
				double fpu3 = bspSurf3->FirstUParameter();
				double lpu3 = bspSurf3->LastUParameter();
				shared_ptr<Geom3Curve> fuc3 = bspSurf3->UIso(fpu3);
				shared_ptr<Geom3Curve> luc3 = bspSurf3->UIso(lpu3);
				double res1 = NurbsSampleCurve(num, refTol, fuc3, fuc1);
				double res2 = NurbsSampleCurve(num, refTol, luc3, fuc2);
				CHECK(res1 <= ratio);
				CHECK(res2 <= ratio);
				pair<double, double> res3 = NurbsContinousSample(num, fuc3, fuc1);
				pair<double, double> res4 = NurbsContinousSample(num, luc3, fuc2);
				CHECK(res3.first == 0.0);
				CHECK(res3.second == 0.0);
				CHECK(res4.first == 0.0);
				CHECK(res4.second == 0.0);
				OCCTIO::OCCTTool::Write(MakeEdge(fuc1), outdir + "fuc1.brep");
				OCCTIO::OCCTTool::Write(MakeEdge(fvc1), outdir + "fvc1.brep");
				OCCTIO::OCCTTool::Write(MakeEdge(fuc2), outdir + "fuc2.brep");
				OCCTIO::OCCTTool::Write(MakeEdge(fvc2), outdir + "fvc2.brep");
				OCCTIO::OCCTTool::Write(MakeEdge(fuc3), outdir + "fuc3.brep");
				OCCTIO::OCCTTool::Write(MakeFace(surf1, 0.0), outdir + "src1.brep");
				OCCTIO::OCCTTool::Write(MakeFace(surf2, 0.0), outdir + "src2.brep");
				OCCTIO::OCCTTool::Write(MakeFace(bspSurf3, 0.0), outdir + "result.brep");
			}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static std::shared_ptr<Geom3BSplineCurve> BuildCurve(const std::vector<Point3>& poles, int degree, bool isPeriodic)	 @return The built curve. If building curve is failed, return nullptr
	 @param isPeriodic Whether the curve is periodic or not
	 @param degree The curve degree
	 @param poles Curve poles. If it is a periodic curve, don't include the point at the end that repeats the first point
	 @brief Build BSpline curve
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <nurbs/NURBSAPIBuildCurve.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeVertex.hpp>
#include <nurbs/NURBSAPIExtend.hpp>
#include <geomAlgo/LawConstant.hpp>
#include <nurbs/NURBSAPILinearSweep.hpp>
#include <modeling/MakeFace.hpp>
std::shared_ptr<AMCAX::Geom3BSplineCurve> BuildBSpCurve(const std::vector<AMCAX::Point3>& poles, int degree, bool isPeriodic)
{
	int npoles = static_cast<int>(poles.size());
	if (isPeriodic)
	{
		return AMCAX::NURBSAPIBuildCurve::BuildCurve(poles, std::min(degree, npoles), true);
	}
	else
	{
		return AMCAX::NURBSAPIBuildCurve::BuildCurve(poles, std::min(degree, npoles - 1), false);
	}
}
TEST_CASE("case1: this is a test for testBuildCurve", "[nurbs][BuildCurve][P1]")
{
	SECTION("TestBuildCurve()")
	{
		OUTPUT_DIRECTORY(nurbs, BuildCurve/BuildCurve);
		std::vector<Point3> poles;
		Point3 p1(0.0, 0.0, 0.0);
		Point3 p2(-0.1, 1.0, -0.2);
		Point3 p3(0.1, 2.0, -0.1);
		Point3 p4(0.2, 3.0, 0.1);
		Point3 p5(0.1, 4.0, 0.0);
		Point3 p6(0.0, 5.0, -0.1);
		poles.push_back(p1);
		poles.push_back(p2);
		poles.push_back(p3);
		poles.push_back(p4);
		poles.push_back(p5);
		poles.push_back(p6);
		bool isPeriodic = false;
		int degree = NURBSAPIBuildCurve::ValidMaxDegree(static_cast<int>(poles.size()), isPeriodic);
		degree = std::min(3, degree);
		auto curve = NURBSAPIBuildCurve::BuildCurve(poles, degree, isPeriodic);
		Point3 sp1 = curve->StartPoint();
		Point3 ep1 = curve->EndPoint();
		CHECK(sp1.X() == Approx(p1.X()));
		CHECK(sp1.Y() == Approx(p1.Y()));
		CHECK(sp1.Z() == Approx(p1.Z()));
		CHECK(ep1.X() == Approx(p6.X()).margin(1e-7));
		CHECK(ep1.Y() == Approx(p6.Y()).margin(1e-7));
		CHECK(ep1.Z() == Approx(p6.Z()).margin(1e-7));
		CHECK(curve->Degree() == degree);
		CHECK(curve->NPoles() == 6);
		CHECK(curve->IsPeriodic() == false);
		vector<Point3> vec = curve->Poles();
		CHECK(vec.size() == 6);
		CHECK(vec[0].X() == Approx(p1.X()));
		CHECK(vec[0].Y() == Approx(p1.Y()));
		CHECK(vec[0].Z() == Approx(p1.Z()));
		CHECK(vec[1].X() == Approx(p2.X()));
		CHECK(vec[1].Y() == Approx(p2.Y()));
		CHECK(vec[1].Z() == Approx(p2.Z()));
		CHECK(vec[2].X() == Approx(p3.X()));
		CHECK(vec[2].Y() == Approx(p3.Y()));
		CHECK(vec[2].Z() == Approx(p3.Z()));
		CHECK(vec[3].X() == Approx(p4.X()));
		CHECK(vec[3].Y() == Approx(p4.Y()));
		CHECK(vec[3].Z() == Approx(p4.Z()));
		CHECK(vec[4].X() == Approx(p5.X()));
		CHECK(vec[4].Y() == Approx(p5.Y()));
		CHECK(vec[4].Z() == Approx(p5.Z()));
		CHECK(vec[5].X() == Approx(p6.X()));
		CHECK(vec[5].Y() == Approx(p6.Y()));
		CHECK(vec[5].Z() == Approx(p6.Z()));
		OCCTIO::OCCTTool::Write(MakeVertex(p1), outdir + "p1.brep");
		OCCTIO::OCCTTool::Write(MakeVertex(p2), outdir + "p2.brep");
		OCCTIO::OCCTTool::Write(MakeVertex(p3), outdir + "p3.brep");
		OCCTIO::OCCTTool::Write(MakeVertex(p4), outdir + "p4.brep");
		OCCTIO::OCCTTool::Write(MakeVertex(p5), outdir + "p5.brep");
		OCCTIO::OCCTTool::Write(MakeVertex(p6), outdir + "p6.brep");
		OCCTIO::OCCTTool::Write(MakeEdge(curve), outdir + "result.brep");
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static std::shared_ptr<Geom3BSplineCurve> BuildCurve(const std::vector<Point3>& poles, const std::vector<double>& weights, int degree, bool isPeriodic)	 @return The built curve. If building curve is failed, return nullptr
	 @param isPeriodic Whether the curve is periodic or not
	 @param degree The curve degree
	 @param weights Curve weights
	 @param poles Curve poles. If it is a periodic curve, don't include the point at the end that repeats the first point
	 @brief Build NURBS curve
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <nurbs/NURBSAPIBuildCurve.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeVertex.hpp>
#include <nurbs/NURBSAPIExtend.hpp>
#include <geomAlgo/LawConstant.hpp>
#include <nurbs/NURBSAPILinearSweep.hpp>
#include <modeling/MakeFace.hpp>
std::shared_ptr<AMCAX::Geom3BSplineCurve> BuildBSpCurve(const std::vector<AMCAX::Point3>& poles, int degree, bool isPeriodic)
{
	int npoles = static_cast<int>(poles.size());
	if (isPeriodic)
	{
		return AMCAX::NURBSAPIBuildCurve::BuildCurve(poles, std::min(degree, npoles), true);
	}
	else
	{
		return AMCAX::NURBSAPIBuildCurve::BuildCurve(poles, std::min(degree, npoles - 1), false);
	}
}
TEST_CASE("case1: this is a test for testBuildCurve", "[nurbs][BuildCurve][P1]")
{
	SECTION("TestBuildCurve()")
	{
		OUTPUT_DIRECTORY(nurbs, BuildCurve/BuildCurve);
		std::vector<Point3> poles;
		Point3 p1(0.0, 0.0, 0.0);
		Point3 p2(-0.1, 1.0, -0.2);
		Point3 p3(0.1, 2.0, -0.1);
		Point3 p4(0.2, 3.0, 0.1);
		Point3 p5(0.1, 4.0, 0.0);
		Point3 p6(0.0, 5.0, -0.1);
		poles.push_back(p1);
		poles.push_back(p2);
		poles.push_back(p3);
		poles.push_back(p4);
		poles.push_back(p5);
		poles.push_back(p6);
		bool isPeriodic = false;
		int degree = NURBSAPIBuildCurve::ValidMaxDegree(static_cast<int>(poles.size()), isPeriodic);
		degree = std::min(3, degree);
		auto curve = NURBSAPIBuildCurve::BuildCurve(poles, degree, isPeriodic);
		Point3 sp1 = curve->StartPoint();
		Point3 ep1 = curve->EndPoint();
		CHECK(sp1.X() == Approx(p1.X()));
		CHECK(sp1.Y() == Approx(p1.Y()));
		CHECK(sp1.Z() == Approx(p1.Z()));
		CHECK(ep1.X() == Approx(p6.X()).margin(1e-7));
		CHECK(ep1.Y() == Approx(p6.Y()).margin(1e-7));
		CHECK(ep1.Z() == Approx(p6.Z()).margin(1e-7));
		CHECK(curve->Degree() == degree);
		CHECK(curve->NPoles() == 6);
		CHECK(curve->IsPeriodic() == false);
		vector<Point3> vec = curve->Poles();
		CHECK(vec.size() == 6);
		CHECK(vec[0].X() == Approx(p1.X()));
		CHECK(vec[0].Y() == Approx(p1.Y()));
		CHECK(vec[0].Z() == Approx(p1.Z()));
		CHECK(vec[1].X() == Approx(p2.X()));
		CHECK(vec[1].Y() == Approx(p2.Y()));
		CHECK(vec[1].Z() == Approx(p2.Z()));
		CHECK(vec[2].X() == Approx(p3.X()));
		CHECK(vec[2].Y() == Approx(p3.Y()));
		CHECK(vec[2].Z() == Approx(p3.Z()));
		CHECK(vec[3].X() == Approx(p4.X()));
		CHECK(vec[3].Y() == Approx(p4.Y()));
		CHECK(vec[3].Z() == Approx(p4.Z()));
		CHECK(vec[4].X() == Approx(p5.X()));
		CHECK(vec[4].Y() == Approx(p5.Y()));
		CHECK(vec[4].Z() == Approx(p5.Z()));
		CHECK(vec[5].X() == Approx(p6.X()));
		CHECK(vec[5].Y() == Approx(p6.Y()));
		CHECK(vec[5].Z() == Approx(p6.Z()));
		OCCTIO::OCCTTool::Write(MakeVertex(p1), outdir + "p1.brep");
		OCCTIO::OCCTTool::Write(MakeVertex(p2), outdir + "p2.brep");
		OCCTIO::OCCTTool::Write(MakeVertex(p3), outdir + "p3.brep");
		OCCTIO::OCCTTool::Write(MakeVertex(p4), outdir + "p4.brep");
		OCCTIO::OCCTTool::Write(MakeVertex(p5), outdir + "p5.brep");
		OCCTIO::OCCTTool::Write(MakeVertex(p6), outdir + "p6.brep");
		OCCTIO::OCCTTool::Write(MakeEdge(curve), outdir + "result.brep");
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static int ValidMaxDegree(int npoles, bool isPeriodic)	 @return The maximum valid degree
	 @param isPeriodic Whether the curve is periodic
	 @param npoles The number of control points
	 @brief Given the number of the control points, calculate the maximum valide degree of a BSpline curve
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <nurbs/NURBSAPIBuildCurve.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeVertex.hpp>
#include <nurbs/NURBSAPIExtend.hpp>
#include <geomAlgo/LawConstant.hpp>
#include <nurbs/NURBSAPILinearSweep.hpp>
#include <modeling/MakeFace.hpp>
std::shared_ptr<AMCAX::Geom3BSplineCurve> BuildBSpCurve(const std::vector<AMCAX::Point3>& poles, int degree, bool isPeriodic)
{
	int npoles = static_cast<int>(poles.size());
	if (isPeriodic)
	{
		return AMCAX::NURBSAPIBuildCurve::BuildCurve(poles, std::min(degree, npoles), true);
	}
	else
	{
		return AMCAX::NURBSAPIBuildCurve::BuildCurve(poles, std::min(degree, npoles - 1), false);
	}
}
TEST_CASE("case1: this is a test for testBuildCurve-IncreaseDegree", "[nurbs][BuildCurve][P2]")
{
	int num = 1000;
	double ratio = 0.1;
	double refTol = DEFAULT_TOLERANCE;
	SECTION("TestExtendFourPointsDynamic")
	{
		OUTPUT_DIRECTORY(nurbs,BuildCurve/ExtendFourPointsDynamic);
		std::vector<Point3> poles;
		Point3 p1(0.0, 0.0, 0.0);
		Point3 p2(0.0, 1.0, 0.0);
		Point3 p3(1.0, 1.0, 0.0);
		Point3 p4(1.0, 0.0, 0.0);
		poles.push_back(p1);
		poles.push_back(p2);
		poles.push_back(p3);
		poles.push_back(p4);
		std::vector<double> weights;
		weights.push_back(1.0);
		weights.push_back(1.2);
		weights.push_back(1.1);
		weights.push_back(1.0);
		auto oldcurve = NURBSAPIBuildCurve::BuildCurve(poles, weights, 3, false);
		int maxDeg = NURBSAPIBuildCurve::ValidMaxDegree(static_cast<int>(poles.size()), false);
		auto curve = NURBSAPIBuildCurve::BuildCurve(poles, weights, maxDeg, false);
		CHECK(curve->Degree() == maxDeg);
		double res33 = NurbsSampleCurve(num, ratio, oldcurve, curve);
		CHECK(res33 <= refTol);
		Point3 sp1 = curve->StartPoint();
		Point3 ep1 = curve->EndPoint();
		CHECK(sp1.X() == Approx(p1.X()));
		CHECK(sp1.Y() == Approx(p1.Y()));
		CHECK(sp1.Z() == Approx(p1.Z()));
		CHECK(ep1.X() == Approx(p4.X()));
		CHECK(ep1.Y() == Approx(p4.Y()));
		CHECK(ep1.Z() == Approx(p4.Z()));
		CHECK(curve->IsPeriodic() == false);
		OCCTIO::OCCTTool::Write(MakeVertex(p1), outdir + "p1.brep");
		OCCTIO::OCCTTool::Write(MakeVertex(p2), outdir + "p2.brep");
		OCCTIO::OCCTTool::Write(MakeVertex(p3), outdir + "p3.brep");
		OCCTIO::OCCTTool::Write(MakeVertex(p4), outdir + "p4.brep");
		OCCTIO::OCCTTool::Write(MakeEdge(curve), outdir + "result.brep");
		Point3 p(-1.0, -1.0, 0.0);
		auto extendedCurve = NURBSAPIExtend::ExtendCurveToDynamicPoint(curve, false, p);
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static std::pair<NURBSSweepStatus, std::shared_ptr<Geom3BSplineSurface>> SweepWithThreeGuides(const std::shared_ptr<Geom3BSplineCurve>& guide1, const std::shared_ptr<Geom3BSplineCurve>& guide2, const std::shared_ptr<Geom3BSplineCurve>& guide3, const std::shared_ptr<Geom3BSplineCurve>& spine, double spineLeftBound, double spineRightBound),
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <filesystem>
#include <fstream>
#include <random>
#include <sstream>
#include <nurbs/NURBSAPIGetGeometry.hpp>
#include <nurbs/NURBSAPIConicalSweep.hpp>
#include <boolean/BoolBRepCut.hpp>
#include <common/CartesianCoordinateSystem.hpp>
#include <common/IndexMap.hpp>
#include <common/QuaternionT.hpp>
#include <geomAlgo/LawBSpline.hpp>
#include <geomAlgo/LawConstant.hpp>
#include <nurbs/NURBSAPISmooth.hpp>
#include <geomAlgo/MakeConic2FromConstraints.hpp>
#include <geometry/Adaptor3CurveOnSurface.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/AdaptorGeom3Surface.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/Geom2Circle.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/Geom2Hyperbola.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom3BSplineCurve.hpp>
#include <geometry/Geom3BSplineSurface.hpp>
#include <geometry/Geom3Circle.hpp>
#include <geometry/Geom3Line.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
#include <geometry/Geom3Plane.hpp>
#include <geometry/Geom3SphericalSurface.hpp>
#include <geometry/Geom3Surface.hpp>
#include <geometry/Geom3TrimmedCurve.hpp>
#include <geometry/Geom3TrimmedSurface.hpp>
#include <geometry/GeomAPIExtremaCurveCurve3.hpp>
#include <geometry/GeomAPIProjectPointOnCurve2.hpp>
#include <geometry/GeomAPIProjectPointOnCurve3.hpp>
#include <geometry/GeomAPIProjectPointOnSurface.hpp>
#include <geometry/GeometryTool.hpp>
#include <geometry/GlobalProperty.hpp>
#include <healing/ShapeFixTool.hpp>
#include <io/STLTool.hpp>
#include <math/Sphere.hpp>
#include <math/TriangularMesh.hpp>
#include <modeling/CopyShape.hpp>
#include <modeling/MakeBox.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeFace.hpp>
#include <modeling/MakePrism.hpp>
#include <modeling/MakeRevol.hpp>
#include <modeling/MakeShapeTool.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeWire.hpp>
#include <modeling/TransformShape.hpp>
#include <nurbs/NURBSAPIApprox.hpp>
#include <nurbs/NURBSAPIBuildCurve.hpp>
#include <nurbs/NURBSAPICircularSweep.hpp>
#include <nurbs/NURBSAPIConvert.hpp>
#include <nurbs/NURBSAPICurveNetworkSurface.hpp>
#include <nurbs/NURBSAPIExplicitSweep.hpp>
#include <nurbs/NURBSAPIExplode.hpp>
#include <nurbs/NURBSAPIExtend.hpp>
#include <nurbs/NURBSAPIInterpolate.hpp>
#include <nurbs/NURBSAPIJoin.hpp>
#include <nurbs/NURBSAPILinearSweep.hpp>
#include <nurbs/NURBSAPILoft.hpp>
#include <nurbs/NURBSAPIMakeNURBSFromBoundaries.hpp>
#include <nurbs/NURBSAPIMatch.hpp>
#include <nurbs/NURBSAPIModifyEndToPlane.hpp>
#include <nurbs/NURBSAPIOffsetCurveOnSurface.hpp>
#include <nurbs/NURBSAPIProject.hpp>
#include <nurbs/NURBSAPIRebuild.hpp>
#include <nurbs/NURBSAPIReplaceEdge.hpp>
#include <nurbs/NURBSAPISweep.hpp>
#include <nurbs/NURBSAPISweep2.hpp>
#include <nurbs/NURBSAPISweepRotation.hpp>
#include <nurbs/NURBSAPITrim.hpp>
#include <nurbs/NURBSAPIUntrim.hpp>
#include <nurbs/NURBSLinearSweepWithDraftDirectionLength.hpp>
#include <occtio/OCCTTool.hpp>
#include <offset/MakePipe.hpp>
#include <offset/MakePipeShell.hpp>
#include <topology/BRepAdaptorCurve2.hpp>
#include <topology/BRepAdaptorCurve3.hpp>
#include <topology/BRepAdaptorSurface.hpp>
#include <topology/BRepGlobalProperty.hpp>
#include <topology/BRepTool.hpp>
#include <topology/TopoBuilder.hpp>
#include <topology/TopoCompound.hpp>
#include <topology/TopoEdge.hpp>
#include <topology/TopoExplorer.hpp>
#include <topology/TopoExplorerTool.hpp>
#include <topology/TopoFace.hpp>
#include <topology/TopoShape.hpp>
#include <topology/TopoShell.hpp>
#include <topology/TopoTool.hpp>
#include <topology/TopoVertex.hpp>
#include <topology/TopoWire.hpp>
#include <topology/WireExplorer.hpp>
#include <topomesh/BRepMeshIncrementalMesh.hpp>
#include <nurbs/NURBSAPIBlend.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
#include <math/LineT.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/GeomAPIIntSurfaceSurface.hpp>
using namespace AMCAX;
namespace
{
	std::shared_ptr<Geom3BSplineCurve> CurveChooser(const int id, const std::shared_ptr<Geom3BSplineCurve>& curve0, const std::shared_ptr<Geom3BSplineCurve>& curve1, const std::shared_ptr<Geom3BSplineCurve>& curve2)
	{
		std::shared_ptr<Geom3BSplineCurve> result;
		switch (id)
		{
		case 0:
		{
			result = curve0;
			break;
		}
		case 1:
		{
			result = curve1;
			break;
		}
		case 2:
		{
			result = curve2;
			break;
		}
		}
		return result;
	}
} 
TEST_CASE("case1:this is a case for CircularSweep", "[nurbs][forcase1][Circular]")
{
	GlobalProperty g;
	SECTION("TestCircularSweepWithThreeGuides2()")
	{
		std::string filedir(INPUT_PATH_PREFIX "/TestNURBS/TestCircularSweepWithThreeGuides2/");
		auto guide1 = ReadBRepCurve(filedir + "guide1.brep");
		auto guide2 = ReadBRepCurve(filedir + "guide2.brep");
		auto guide3 = ReadBRepCurve(filedir + "guide3.brep");
		auto spine = guide1;
		CHECK(OCCTIO::OCCTTool::Write(MakeEdge(guide1), OUTPUT_PATH_PREFIX "TestCircularSweepWithThreeGuides2_guide1.brep"));
		CHECK(OCCTIO::OCCTTool::Write(MakeEdge(guide2), OUTPUT_PATH_PREFIX "TestCircularSweepWithThreeGuides2_guide2.brep"));
		CHECK(OCCTIO::OCCTTool::Write(MakeEdge(guide3), OUTPUT_PATH_PREFIX "TestCircularSweepWithThreeGuides2_guide3.brep"));
		CHECK(OCCTIO::OCCTTool::Write(MakeEdge(spine), OUTPUT_PATH_PREFIX "TestCircularSweepWithThreeGuides2_spine.brep"));
		auto [status, surface] = NURBSAPICircularSweep::SweepWithThreeGuides(guide1, guide2, guide3, spine, spine->FirstParameter(), spine->LastParameter());
		CHECK(status == NURBSSweepStatus::Success);
		if (status == NURBSSweepStatus::Success && surface)
		{
			CHECK(OCCTIO::OCCTTool::Write(MakeFace(surface, 0.0), OUTPUT_PATH_PREFIX "TestCircularSweepWithThreeGuides2_result.brep"));
			AMCAX::BRepExtremaDistShapeShape len1(MakeEdge(guide1), MakeFace(surface, 0.0));
			AMCAX::BRepExtremaDistShapeShape len2(MakeFace(surface, 0.0), MakeEdge(guide2));
			AMCAX::BRepExtremaDistShapeShape len3(MakeFace(surface, 0.0), MakeEdge(spine));
			CHECK(len1.Value() < 0.1);
			CHECK(len2.Value() < 0.1);
			CHECK(len3.Value() < 0.1);
			CHECK(IsCurveOnSurf(1000, 0.1, guide1, surface, 0.1));
			CHECK(IsCurveOnSurf(1000, 0.1, guide2, surface, 0.2));
			CHECK(IsCurveOnSurf(1000, 0.1, spine, surface, 0.1));
			IndexSet<TopoShape> newshapeEdge1;
			TopoExplorerTool::MapShapes(MakeFace(surface, 0.0), ShapeType::Edge, newshapeEdge1);
			TopoExplorer ex0(newshapeEdge1[0], ShapeType::Edge);
			TopoExplorer ex1(newshapeEdge1[2], ShapeType::Edge);
			TopoEdge e0 = static_cast<const TopoEdge&>(ex0.Value());
			TopoEdge e1 = static_cast<const TopoEdge&>(ex1.Value());
			auto edge0 = NURBSAPIGetGeometry::GetCurve(e0);
			auto edge1 = NURBSAPIGetGeometry::GetCurve(e1);
			double n0 = NurbsSampleCurve(100, 0.1, edge0, spine);
			double n1 = NurbsSampleCurve(100, 0.3, edge1, guide3);
			CHECK(n0 < 0.2);
			CHECK(n1 < 0.3);
		}
		spine->IncreaseDegree(5);
		guide1->IncreaseDegree(5);
		guide2->IncreaseDegree(5);
		guide3->IncreaseDegree(5);
		auto [status1, surface1] = NURBSAPICircularSweep::SweepWithThreeGuides(guide1, guide2, guide3, spine, spine->FirstParameter(), spine->LastParameter());
		CHECK(status1 == NURBSSweepStatus::Success);
		double bsp3s = GetSurfaceProperties(MakeFace(surface1, 0.0), g, true, true);
		double bsp4s = GetSurfaceProperties(MakeFace(surface, 0.0), g, true, true);
		CHECK(bsp3s == Approx(bsp4s).margin(0.1));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static std::pair<NURBSSweepStatus, std::vector<std::shared_ptr<Geom3BSplineSurface>>> SweepWithTwoGuidesAndRadius(const std::shared_ptr<Geom3BSplineCurve>& guide1, const std::shared_ptr<Geom3BSplineCurve>& guide2, const LawFunction& radiusLaw, const std::shared_ptr<Geom3BSplineCurve>& spine, double spineLeftBound, double spineRightBound),
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <filesystem>
#include <fstream>
#include <random>
#include <sstream>
#include <nurbs/NURBSAPIGetGeometry.hpp>
#include <nurbs/NURBSAPIConicalSweep.hpp>
#include <boolean/BoolBRepCut.hpp>
#include <common/CartesianCoordinateSystem.hpp>
#include <common/IndexMap.hpp>
#include <common/QuaternionT.hpp>
#include <geomAlgo/LawBSpline.hpp>
#include <geomAlgo/LawConstant.hpp>
#include <nurbs/NURBSAPISmooth.hpp>
#include <geomAlgo/MakeConic2FromConstraints.hpp>
#include <geometry/Adaptor3CurveOnSurface.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/AdaptorGeom3Surface.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/Geom2Circle.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/Geom2Hyperbola.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom3BSplineCurve.hpp>
#include <geometry/Geom3BSplineSurface.hpp>
#include <geometry/Geom3Circle.hpp>
#include <geometry/Geom3Line.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
#include <geometry/Geom3Plane.hpp>
#include <geometry/Geom3SphericalSurface.hpp>
#include <geometry/Geom3Surface.hpp>
#include <geometry/Geom3TrimmedCurve.hpp>
#include <geometry/Geom3TrimmedSurface.hpp>
#include <geometry/GeomAPIExtremaCurveCurve3.hpp>
#include <geometry/GeomAPIProjectPointOnCurve2.hpp>
#include <geometry/GeomAPIProjectPointOnCurve3.hpp>
#include <geometry/GeomAPIProjectPointOnSurface.hpp>
#include <geometry/GeometryTool.hpp>
#include <geometry/GlobalProperty.hpp>
#include <healing/ShapeFixTool.hpp>
#include <io/STLTool.hpp>
#include <math/Sphere.hpp>
#include <math/TriangularMesh.hpp>
#include <modeling/CopyShape.hpp>
#include <modeling/MakeBox.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeFace.hpp>
#include <modeling/MakePrism.hpp>
#include <modeling/MakeRevol.hpp>
#include <modeling/MakeShapeTool.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeWire.hpp>
#include <modeling/TransformShape.hpp>
#include <nurbs/NURBSAPIApprox.hpp>
#include <nurbs/NURBSAPIBuildCurve.hpp>
#include <nurbs/NURBSAPICircularSweep.hpp>
#include <nurbs/NURBSAPIConvert.hpp>
#include <nurbs/NURBSAPICurveNetworkSurface.hpp>
#include <nurbs/NURBSAPIExplicitSweep.hpp>
#include <nurbs/NURBSAPIExplode.hpp>
#include <nurbs/NURBSAPIExtend.hpp>
#include <nurbs/NURBSAPIInterpolate.hpp>
#include <nurbs/NURBSAPIJoin.hpp>
#include <nurbs/NURBSAPILinearSweep.hpp>
#include <nurbs/NURBSAPILoft.hpp>
#include <nurbs/NURBSAPIMakeNURBSFromBoundaries.hpp>
#include <nurbs/NURBSAPIMatch.hpp>
#include <nurbs/NURBSAPIModifyEndToPlane.hpp>
#include <nurbs/NURBSAPIOffsetCurveOnSurface.hpp>
#include <nurbs/NURBSAPIProject.hpp>
#include <nurbs/NURBSAPIRebuild.hpp>
#include <nurbs/NURBSAPIReplaceEdge.hpp>
#include <nurbs/NURBSAPISweep.hpp>
#include <nurbs/NURBSAPISweep2.hpp>
#include <nurbs/NURBSAPISweepRotation.hpp>
#include <nurbs/NURBSAPITrim.hpp>
#include <nurbs/NURBSAPIUntrim.hpp>
#include <nurbs/NURBSLinearSweepWithDraftDirectionLength.hpp>
#include <occtio/OCCTTool.hpp>
#include <offset/MakePipe.hpp>
#include <offset/MakePipeShell.hpp>
#include <topology/BRepAdaptorCurve2.hpp>
#include <topology/BRepAdaptorCurve3.hpp>
#include <topology/BRepAdaptorSurface.hpp>
#include <topology/BRepGlobalProperty.hpp>
#include <topology/BRepTool.hpp>
#include <topology/TopoBuilder.hpp>
#include <topology/TopoCompound.hpp>
#include <topology/TopoEdge.hpp>
#include <topology/TopoExplorer.hpp>
#include <topology/TopoExplorerTool.hpp>
#include <topology/TopoFace.hpp>
#include <topology/TopoShape.hpp>
#include <topology/TopoShell.hpp>
#include <topology/TopoTool.hpp>
#include <topology/TopoVertex.hpp>
#include <topology/TopoWire.hpp>
#include <topology/WireExplorer.hpp>
#include <topomesh/BRepMeshIncrementalMesh.hpp>
#include <nurbs/NURBSAPIBlend.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
#include <math/LineT.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/GeomAPIIntSurfaceSurface.hpp>
using namespace AMCAX;
namespace
{
	std::shared_ptr<Geom3BSplineCurve> CurveChooser(const int id, const std::shared_ptr<Geom3BSplineCurve>& curve0, const std::shared_ptr<Geom3BSplineCurve>& curve1, const std::shared_ptr<Geom3BSplineCurve>& curve2)
	{
		std::shared_ptr<Geom3BSplineCurve> result;
		switch (id)
		{
		case 0:
		{
			result = curve0;
			break;
		}
		case 1:
		{
			result = curve1;
			break;
		}
		case 2:
		{
			result = curve2;
			break;
		}
		}
		return result;
	}
} 
TEST_CASE("case1:this is a case for CircularSweep", "[nurbs][forcase1][Circular]")
{
	GlobalProperty g;
	SECTION("TestCircularSweepWithTwoGuidesAndRadius()")
	{
		std::string filedir(INPUT_PATH_PREFIX "/TestNURBS/TestCircularSweepWithTwoGuidesAndRadius/");
		auto guide1 = ReadBRepCurve(filedir + "guide1.brep");
		auto guide2 = ReadBRepCurve(filedir + "guide2.brep");
		auto spine = ReadBRepCurve(filedir + "spine.brep");
		CHECK(OCCTIO::OCCTTool::Write(MakeEdge(guide1), OUTPUT_PATH_PREFIX "TestCircularSweepWithTwoGuidesAndRadius_guide1.brep"));
		CHECK(OCCTIO::OCCTTool::Write(MakeEdge(guide2), OUTPUT_PATH_PREFIX "TestCircularSweepWithTwoGuidesAndRadius_guide2.brep"));
		CHECK(OCCTIO::OCCTTool::Write(MakeEdge(spine), OUTPUT_PATH_PREFIX "TestCircularSweepWithTwoGuidesAndRadius_spine.brep"));
		LawConstant radiusLaw;
		radiusLaw.Set(10.0, 0.0, 1.0);
		auto [status, surfaces] = NURBSAPICircularSweep::SweepWithTwoGuidesAndRadius(guide1, guide2, radiusLaw, spine, spine->FirstParameter(), spine->LastParameter());
		CHECK(status == NURBSSweepStatus::Success);
		if (status == NURBSSweepStatus::Success && !surfaces.empty())
		{
			CHECK(OCCTIO::OCCTTool::Write(MakeFace(surfaces.front(), 0.0), OUTPUT_PATH_PREFIX "TestCircularSweepWithTwoGuidesAndRadius_result.brep"));
			for (int i = 0; i < surfaces.size(); i++)
			{
				CHECK(OCCTIO::OCCTTool::Write(MakeFace(surfaces[i], 0.0), OUTPUT_PATH_PREFIX "TestCircularSweepWithTwoGuidesAndRadius_result" + std::to_string(i) + ".brep"));
				AMCAX::BRepExtremaDistShapeShape len1(MakeEdge(guide1), MakeFace(surfaces[i], 0.0));
				AMCAX::BRepExtremaDistShapeShape len2(MakeFace(surfaces[i], 0.0), MakeEdge(guide2));
				AMCAX::BRepExtremaDistShapeShape len3(MakeFace(surfaces[i], 0.0), MakeEdge(spine));
				CHECK(len1.Value() < 0.1);
				CHECK(len2.Value() < 0.1);
				CHECK(IsCurveOnSurf(1000, 0.1, guide1, surfaces[i], 0.1));
				CHECK(IsCurveOnSurf(1000, 0.1, guide2, surfaces[i], 0.1));
			}
		}
		spine->IncreaseDegree(11);
		guide1->IncreaseDegree(11);
		guide2->IncreaseDegree(11);
		auto [status1, surfaces1] = NURBSAPICircularSweep::SweepWithTwoGuidesAndRadius(guide1, guide2, radiusLaw, spine, spine->FirstParameter(), spine->LastParameter());
		CHECK(status1 == NURBSSweepStatus::Success);
		for (int i = 0; i < surfaces.size(); i++)
		{
			CHECK(OCCTIO::OCCTTool::Write(MakeFace(surfaces[i], 0.0), OUTPUT_PATH_PREFIX "TestCircularSweepWithTwoGuidesAndRadius_degree11result" + std::to_string(i) + ".brep"));
			double bsp3s = GetSurfaceProperties(MakeFace(surfaces1[i], 0.0), g, true, true);
			double bsp4s = GetSurfaceProperties(MakeFace(surfaces[i], 0.0), g, true, true);
			CHECK(bsp3s == Approx(bsp4s).margin(0.02));
		}
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static std::pair<NURBSSweepStatus, std::shared_ptr<Geom3BSplineSurface>> SweepWithCenterAndTwoAngles(const std::shared_ptr<Geom3BSplineCurve>& centerCurve, const std::shared_ptr<Geom3BSplineCurve>& referenceCurve, const LawFunction& angleLaw1, const LawFunction& angleLaw2, const std::shared_ptr<Geom3BSplineCurve>& spine, double spineLeftBound, double spineRightBound),
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <filesystem>
#include <fstream>
#include <random>
#include <sstream>
#include <nurbs/NURBSAPIGetGeometry.hpp>
#include <nurbs/NURBSAPIConicalSweep.hpp>
#include <boolean/BoolBRepCut.hpp>
#include <common/CartesianCoordinateSystem.hpp>
#include <common/IndexMap.hpp>
#include <common/QuaternionT.hpp>
#include <geomAlgo/LawBSpline.hpp>
#include <geomAlgo/LawConstant.hpp>
#include <nurbs/NURBSAPISmooth.hpp>
#include <geomAlgo/MakeConic2FromConstraints.hpp>
#include <geometry/Adaptor3CurveOnSurface.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/AdaptorGeom3Surface.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/Geom2Circle.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/Geom2Hyperbola.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom3BSplineCurve.hpp>
#include <geometry/Geom3BSplineSurface.hpp>
#include <geometry/Geom3Circle.hpp>
#include <geometry/Geom3Line.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
#include <geometry/Geom3Plane.hpp>
#include <geometry/Geom3SphericalSurface.hpp>
#include <geometry/Geom3Surface.hpp>
#include <geometry/Geom3TrimmedCurve.hpp>
#include <geometry/Geom3TrimmedSurface.hpp>
#include <geometry/GeomAPIExtremaCurveCurve3.hpp>
#include <geometry/GeomAPIProjectPointOnCurve2.hpp>
#include <geometry/GeomAPIProjectPointOnCurve3.hpp>
#include <geometry/GeomAPIProjectPointOnSurface.hpp>
#include <geometry/GeometryTool.hpp>
#include <geometry/GlobalProperty.hpp>
#include <healing/ShapeFixTool.hpp>
#include <io/STLTool.hpp>
#include <math/Sphere.hpp>
#include <math/TriangularMesh.hpp>
#include <modeling/CopyShape.hpp>
#include <modeling/MakeBox.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeFace.hpp>
#include <modeling/MakePrism.hpp>
#include <modeling/MakeRevol.hpp>
#include <modeling/MakeShapeTool.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeWire.hpp>
#include <modeling/TransformShape.hpp>
#include <nurbs/NURBSAPIApprox.hpp>
#include <nurbs/NURBSAPIBuildCurve.hpp>
#include <nurbs/NURBSAPICircularSweep.hpp>
#include <nurbs/NURBSAPIConvert.hpp>
#include <nurbs/NURBSAPICurveNetworkSurface.hpp>
#include <nurbs/NURBSAPIExplicitSweep.hpp>
#include <nurbs/NURBSAPIExplode.hpp>
#include <nurbs/NURBSAPIExtend.hpp>
#include <nurbs/NURBSAPIInterpolate.hpp>
#include <nurbs/NURBSAPIJoin.hpp>
#include <nurbs/NURBSAPILinearSweep.hpp>
#include <nurbs/NURBSAPILoft.hpp>
#include <nurbs/NURBSAPIMakeNURBSFromBoundaries.hpp>
#include <nurbs/NURBSAPIMatch.hpp>
#include <nurbs/NURBSAPIModifyEndToPlane.hpp>
#include <nurbs/NURBSAPIOffsetCurveOnSurface.hpp>
#include <nurbs/NURBSAPIProject.hpp>
#include <nurbs/NURBSAPIRebuild.hpp>
#include <nurbs/NURBSAPIReplaceEdge.hpp>
#include <nurbs/NURBSAPISweep.hpp>
#include <nurbs/NURBSAPISweep2.hpp>
#include <nurbs/NURBSAPISweepRotation.hpp>
#include <nurbs/NURBSAPITrim.hpp>
#include <nurbs/NURBSAPIUntrim.hpp>
#include <nurbs/NURBSLinearSweepWithDraftDirectionLength.hpp>
#include <occtio/OCCTTool.hpp>
#include <offset/MakePipe.hpp>
#include <offset/MakePipeShell.hpp>
#include <topology/BRepAdaptorCurve2.hpp>
#include <topology/BRepAdaptorCurve3.hpp>
#include <topology/BRepAdaptorSurface.hpp>
#include <topology/BRepGlobalProperty.hpp>
#include <topology/BRepTool.hpp>
#include <topology/TopoBuilder.hpp>
#include <topology/TopoCompound.hpp>
#include <topology/TopoEdge.hpp>
#include <topology/TopoExplorer.hpp>
#include <topology/TopoExplorerTool.hpp>
#include <topology/TopoFace.hpp>
#include <topology/TopoShape.hpp>
#include <topology/TopoShell.hpp>
#include <topology/TopoTool.hpp>
#include <topology/TopoVertex.hpp>
#include <topology/TopoWire.hpp>
#include <topology/WireExplorer.hpp>
#include <topomesh/BRepMeshIncrementalMesh.hpp>
#include <nurbs/NURBSAPIBlend.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
#include <math/LineT.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/GeomAPIIntSurfaceSurface.hpp>
using namespace AMCAX;
namespace
{
	std::shared_ptr<Geom3BSplineCurve> CurveChooser(const int id, const std::shared_ptr<Geom3BSplineCurve>& curve0, const std::shared_ptr<Geom3BSplineCurve>& curve1, const std::shared_ptr<Geom3BSplineCurve>& curve2)
	{
		std::shared_ptr<Geom3BSplineCurve> result;
		switch (id)
		{
		case 0:
		{
			result = curve0;
			break;
		}
		case 1:
		{
			result = curve1;
			break;
		}
		case 2:
		{
			result = curve2;
			break;
		}
		}
		return result;
	}
} 
TEST_CASE("case1:this is a case for CircularSweep", "[nurbs][forcase1][Circular]")
{
	GlobalProperty g;
	SECTION("TestCircularSweepWithCenterAndTwoAngles2()")
	{
		std::string filedir(INPUT_PATH_PREFIX "/TestNURBS/TestCircularSweepWithCenterAndTwoAngles2/");
		auto center = ReadBRepCurve(filedir + "center.brep");
		auto ref = ReadBRepCurve(filedir + "ref.brep");
		auto spine = center;
		CHECK(OCCTIO::OCCTTool::Write(MakeEdge(center), OUTPUT_PATH_PREFIX "TestCircularSweepWithCenterAndTwoAngles2_center.brep"));
		CHECK(OCCTIO::OCCTTool::Write(MakeEdge(ref), OUTPUT_PATH_PREFIX "TestCircularSweepWithCenterAndTwoAngles2_ref.brep"));
		CHECK(OCCTIO::OCCTTool::Write(MakeEdge(spine), OUTPUT_PATH_PREFIX "TestCircularSweepWithCenterAndTwoAngles2_spine.brep"));
		LawConstant angleLaw1;
		angleLaw1.Set(-M_PI_4, 0.0, 1.0);
		LawConstant angleLaw2;
		angleLaw2.Set(M_PI_4, 0.0, 1.0);
		auto [status, surface] = NURBSAPICircularSweep::SweepWithCenterAndTwoAngles(center, ref, angleLaw1, angleLaw2, spine, spine->FirstParameter(), spine->LastParameter());
		CHECK(status == NURBSSweepStatus::Success);
		if (status == NURBSSweepStatus::Success && surface)
		{
			CHECK(OCCTIO::OCCTTool::Write(MakeFace(surface, 0.0), OUTPUT_PATH_PREFIX "TestCircularSweepWithCenterAndTwoAngles2_result.brep"));
			AMCAX::BRepExtremaDistShapeShape len1(MakeEdge(ref), MakeFace(surface, 0.0));
			CHECK(len1.Value() < 0.1);
			CHECK(IsCurveOnSurf(1000, 0.3, ref, surface, 0.1));
		}
		center->IncreaseDegree(11);
		ref->IncreaseDegree(11);
		spine->IncreaseDegree(11);
		auto [status1, surface1] = NURBSAPICircularSweep::SweepWithCenterAndTwoAngles(center, ref, angleLaw1, angleLaw2, spine, spine->FirstParameter(), spine->LastParameter());
		CHECK(status1 == NURBSSweepStatus::Success);
		if (status1 == NURBSSweepStatus::Success && surface)
		{
			CHECK(OCCTIO::OCCTTool::Write(MakeFace(surface, 0.0), OUTPUT_PATH_PREFIX "TestCircularSweepWithCenterAndTwoAngles2_degree11result.brep"));
			AMCAX::BRepExtremaDistShapeShape len1(MakeEdge(ref), MakeFace(surface1, 0.0));
			CHECK(len1.Value() < 0.1);
			CHECK(IsCurveOnSurf(1000, 0.3, ref, surface, 0.1));
			double bsp3s = GetSurfaceProperties(MakeFace(surface1, 0.0), g, true, true);
			double bsp4s = GetSurfaceProperties(MakeFace(surface, 0.0), g, true, true);
			CHECK(bsp3s == Approx(bsp4s).margin(0.02));
		}
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static std::pair<NURBSSweepStatus, std::shared_ptr<Geom3BSplineSurface>> SweepWithCenterAndRadius(const std::shared_ptr<Geom3BSplineCurve>& centerCurve, const LawFunction& radiusLaw, const std::shared_ptr<Geom3BSplineCurve>& spine, double spineLeftBound, double spineRightBound),
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <filesystem>
#include <fstream>
#include <random>
#include <sstream>
#include <nurbs/NURBSAPIGetGeometry.hpp>
#include <nurbs/NURBSAPIConicalSweep.hpp>
#include <boolean/BoolBRepCut.hpp>
#include <common/CartesianCoordinateSystem.hpp>
#include <common/IndexMap.hpp>
#include <common/QuaternionT.hpp>
#include <geomAlgo/LawBSpline.hpp>
#include <geomAlgo/LawConstant.hpp>
#include <nurbs/NURBSAPISmooth.hpp>
#include <geomAlgo/MakeConic2FromConstraints.hpp>
#include <geometry/Adaptor3CurveOnSurface.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/AdaptorGeom3Surface.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/Geom2Circle.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/Geom2Hyperbola.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom3BSplineCurve.hpp>
#include <geometry/Geom3BSplineSurface.hpp>
#include <geometry/Geom3Circle.hpp>
#include <geometry/Geom3Line.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
#include <geometry/Geom3Plane.hpp>
#include <geometry/Geom3SphericalSurface.hpp>
#include <geometry/Geom3Surface.hpp>
#include <geometry/Geom3TrimmedCurve.hpp>
#include <geometry/Geom3TrimmedSurface.hpp>
#include <geometry/GeomAPIExtremaCurveCurve3.hpp>
#include <geometry/GeomAPIProjectPointOnCurve2.hpp>
#include <geometry/GeomAPIProjectPointOnCurve3.hpp>
#include <geometry/GeomAPIProjectPointOnSurface.hpp>
#include <geometry/GeometryTool.hpp>
#include <geometry/GlobalProperty.hpp>
#include <healing/ShapeFixTool.hpp>
#include <io/STLTool.hpp>
#include <math/Sphere.hpp>
#include <math/TriangularMesh.hpp>
#include <modeling/CopyShape.hpp>
#include <modeling/MakeBox.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeFace.hpp>
#include <modeling/MakePrism.hpp>
#include <modeling/MakeRevol.hpp>
#include <modeling/MakeShapeTool.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeWire.hpp>
#include <modeling/TransformShape.hpp>
#include <nurbs/NURBSAPIApprox.hpp>
#include <nurbs/NURBSAPIBuildCurve.hpp>
#include <nurbs/NURBSAPICircularSweep.hpp>
#include <nurbs/NURBSAPIConvert.hpp>
#include <nurbs/NURBSAPICurveNetworkSurface.hpp>
#include <nurbs/NURBSAPIExplicitSweep.hpp>
#include <nurbs/NURBSAPIExplode.hpp>
#include <nurbs/NURBSAPIExtend.hpp>
#include <nurbs/NURBSAPIInterpolate.hpp>
#include <nurbs/NURBSAPIJoin.hpp>
#include <nurbs/NURBSAPILinearSweep.hpp>
#include <nurbs/NURBSAPILoft.hpp>
#include <nurbs/NURBSAPIMakeNURBSFromBoundaries.hpp>
#include <nurbs/NURBSAPIMatch.hpp>
#include <nurbs/NURBSAPIModifyEndToPlane.hpp>
#include <nurbs/NURBSAPIOffsetCurveOnSurface.hpp>
#include <nurbs/NURBSAPIProject.hpp>
#include <nurbs/NURBSAPIRebuild.hpp>
#include <nurbs/NURBSAPIReplaceEdge.hpp>
#include <nurbs/NURBSAPISweep.hpp>
#include <nurbs/NURBSAPISweep2.hpp>
#include <nurbs/NURBSAPISweepRotation.hpp>
#include <nurbs/NURBSAPITrim.hpp>
#include <nurbs/NURBSAPIUntrim.hpp>
#include <nurbs/NURBSLinearSweepWithDraftDirectionLength.hpp>
#include <occtio/OCCTTool.hpp>
#include <offset/MakePipe.hpp>
#include <offset/MakePipeShell.hpp>
#include <topology/BRepAdaptorCurve2.hpp>
#include <topology/BRepAdaptorCurve3.hpp>
#include <topology/BRepAdaptorSurface.hpp>
#include <topology/BRepGlobalProperty.hpp>
#include <topology/BRepTool.hpp>
#include <topology/TopoBuilder.hpp>
#include <topology/TopoCompound.hpp>
#include <topology/TopoEdge.hpp>
#include <topology/TopoExplorer.hpp>
#include <topology/TopoExplorerTool.hpp>
#include <topology/TopoFace.hpp>
#include <topology/TopoShape.hpp>
#include <topology/TopoShell.hpp>
#include <topology/TopoTool.hpp>
#include <topology/TopoVertex.hpp>
#include <topology/TopoWire.hpp>
#include <topology/WireExplorer.hpp>
#include <topomesh/BRepMeshIncrementalMesh.hpp>
#include <nurbs/NURBSAPIBlend.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
#include <math/LineT.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/GeomAPIIntSurfaceSurface.hpp>
using namespace AMCAX;
namespace
{
	std::shared_ptr<Geom3BSplineCurve> CurveChooser(const int id, const std::shared_ptr<Geom3BSplineCurve>& curve0, const std::shared_ptr<Geom3BSplineCurve>& curve1, const std::shared_ptr<Geom3BSplineCurve>& curve2)
	{
		std::shared_ptr<Geom3BSplineCurve> result;
		switch (id)
		{
		case 0:
		{
			result = curve0;
			break;
		}
		case 1:
		{
			result = curve1;
			break;
		}
		case 2:
		{
			result = curve2;
			break;
		}
		}
		return result;
	}
} 
TEST_CASE("case1:this is a case for CircularSweep", "[nurbs][forcase1][Circular]")
{
	GlobalProperty g;
	SECTION("TestCircularSweepWithCenterAndRadius()")	
	{
		std::string filedir(INPUT_PATH_PREFIX "/TestNURBS/TestCircularSweepWithCenterAndRadius/");
		auto center = ReadBRepCurve(filedir + "center.brep");
		auto spine = ReadBRepCurve(filedir + "spine.brep");
		CHECK(OCCTIO::OCCTTool::Write(MakeEdge(center), OUTPUT_PATH_PREFIX "TestCircularSweepWithCenterAndRadius_center.brep"));
		CHECK(OCCTIO::OCCTTool::Write(MakeEdge(spine), OUTPUT_PATH_PREFIX "TestCircularSweepWithCenterAndRadius_spine.brep"));
		LawConstant radiusLaw;
		radiusLaw.Set(2.0, 0.0, 1.0);
		auto [status, surface] = NURBSAPICircularSweep::SweepWithCenterAndRadius(center, radiusLaw, spine, spine->FirstParameter(), spine->LastParameter());
		CHECK(status == NURBSSweepStatus::Success);
		if (status == NURBSSweepStatus::Success && surface)
		{
			CHECK(OCCTIO::OCCTTool::Write(MakeFace(surface, 0.0), OUTPUT_PATH_PREFIX "TestCircularSweepWithCenterAndRadius_result.brep"));
			AMCAX::BRepExtremaDistShapeShape len1(MakeEdge(spine), MakeFace(surface, 0.0));
			CHECK(len1.Value() < 1.);
		}
		center->IncreaseDegree(11);
		spine->IncreaseDegree(11);
		cout << "center.degree" << center->Degree() << endl;
		auto [status1, surface1] = NURBSAPICircularSweep::SweepWithCenterAndRadius(center, radiusLaw, spine, spine->FirstParameter(), spine->LastParameter());
		CHECK(status1 == NURBSSweepStatus::Success);
		if (status1 == NURBSSweepStatus::Success && surface1)
		{
			CHECK(OCCTIO::OCCTTool::Write(MakeFace(surface1, 0.0), OUTPUT_PATH_PREFIX "TestCircularSweepWithCenterAndRadius_degree11result.brep"));
			AMCAX::BRepExtremaDistShapeShape len1(MakeEdge(spine), MakeFace(surface1, 0.0));
			CHECK(len1.Value() < 1.);
			double bsp3s = GetSurfaceProperties(MakeFace(surface1, 0.0), g, true, true);
			double bsp4s = GetSurfaceProperties(MakeFace(surface, 0.0), g, true, true);
			CHECK(bsp3s == Approx(bsp4s).margin(0.02));
		}
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static std::pair<NURBSSweepStatus, std::vector<std::shared_ptr<Geom3BSplineSurface>>> SweepWithTwoGuidesAndTangencySurface(const std::shared_ptr<Geom3BSplineCurve>& limitCurveWithTangency, const std::shared_ptr<Geom3BSplineSurface>& tangencySurface, const std::shared_ptr<Geom3BSplineCurve>& limitCurve, const std::shared_ptr<Geom3BSplineCurve>& spine, double spineLeftBound, double spineRightBound),
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <filesystem>
#include <fstream>
#include <random>
#include <sstream>
#include <nurbs/NURBSAPIGetGeometry.hpp>
#include <nurbs/NURBSAPIConicalSweep.hpp>
#include <boolean/BoolBRepCut.hpp>
#include <common/CartesianCoordinateSystem.hpp>
#include <common/IndexMap.hpp>
#include <common/QuaternionT.hpp>
#include <geomAlgo/LawBSpline.hpp>
#include <geomAlgo/LawConstant.hpp>
#include <nurbs/NURBSAPISmooth.hpp>
#include <geomAlgo/MakeConic2FromConstraints.hpp>
#include <geometry/Adaptor3CurveOnSurface.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/AdaptorGeom3Surface.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/Geom2Circle.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/Geom2Hyperbola.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom3BSplineCurve.hpp>
#include <geometry/Geom3BSplineSurface.hpp>
#include <geometry/Geom3Circle.hpp>
#include <geometry/Geom3Line.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
#include <geometry/Geom3Plane.hpp>
#include <geometry/Geom3SphericalSurface.hpp>
#include <geometry/Geom3Surface.hpp>
#include <geometry/Geom3TrimmedCurve.hpp>
#include <geometry/Geom3TrimmedSurface.hpp>
#include <geometry/GeomAPIExtremaCurveCurve3.hpp>
#include <geometry/GeomAPIProjectPointOnCurve2.hpp>
#include <geometry/GeomAPIProjectPointOnCurve3.hpp>
#include <geometry/GeomAPIProjectPointOnSurface.hpp>
#include <geometry/GeometryTool.hpp>
#include <geometry/GlobalProperty.hpp>
#include <healing/ShapeFixTool.hpp>
#include <io/STLTool.hpp>
#include <math/Sphere.hpp>
#include <math/TriangularMesh.hpp>
#include <modeling/CopyShape.hpp>
#include <modeling/MakeBox.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeFace.hpp>
#include <modeling/MakePrism.hpp>
#include <modeling/MakeRevol.hpp>
#include <modeling/MakeShapeTool.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeWire.hpp>
#include <modeling/TransformShape.hpp>
#include <nurbs/NURBSAPIApprox.hpp>
#include <nurbs/NURBSAPIBuildCurve.hpp>
#include <nurbs/NURBSAPICircularSweep.hpp>
#include <nurbs/NURBSAPIConvert.hpp>
#include <nurbs/NURBSAPICurveNetworkSurface.hpp>
#include <nurbs/NURBSAPIExplicitSweep.hpp>
#include <nurbs/NURBSAPIExplode.hpp>
#include <nurbs/NURBSAPIExtend.hpp>
#include <nurbs/NURBSAPIInterpolate.hpp>
#include <nurbs/NURBSAPIJoin.hpp>
#include <nurbs/NURBSAPILinearSweep.hpp>
#include <nurbs/NURBSAPILoft.hpp>
#include <nurbs/NURBSAPIMakeNURBSFromBoundaries.hpp>
#include <nurbs/NURBSAPIMatch.hpp>
#include <nurbs/NURBSAPIModifyEndToPlane.hpp>
#include <nurbs/NURBSAPIOffsetCurveOnSurface.hpp>
#include <nurbs/NURBSAPIProject.hpp>
#include <nurbs/NURBSAPIRebuild.hpp>
#include <nurbs/NURBSAPIReplaceEdge.hpp>
#include <nurbs/NURBSAPISweep.hpp>
#include <nurbs/NURBSAPISweep2.hpp>
#include <nurbs/NURBSAPISweepRotation.hpp>
#include <nurbs/NURBSAPITrim.hpp>
#include <nurbs/NURBSAPIUntrim.hpp>
#include <nurbs/NURBSLinearSweepWithDraftDirectionLength.hpp>
#include <occtio/OCCTTool.hpp>
#include <offset/MakePipe.hpp>
#include <offset/MakePipeShell.hpp>
#include <topology/BRepAdaptorCurve2.hpp>
#include <topology/BRepAdaptorCurve3.hpp>
#include <topology/BRepAdaptorSurface.hpp>
#include <topology/BRepGlobalProperty.hpp>
#include <topology/BRepTool.hpp>
#include <topology/TopoBuilder.hpp>
#include <topology/TopoCompound.hpp>
#include <topology/TopoEdge.hpp>
#include <topology/TopoExplorer.hpp>
#include <topology/TopoExplorerTool.hpp>
#include <topology/TopoFace.hpp>
#include <topology/TopoShape.hpp>
#include <topology/TopoShell.hpp>
#include <topology/TopoTool.hpp>
#include <topology/TopoVertex.hpp>
#include <topology/TopoWire.hpp>
#include <topology/WireExplorer.hpp>
#include <topomesh/BRepMeshIncrementalMesh.hpp>
#include <nurbs/NURBSAPIBlend.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
#include <math/LineT.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/GeomAPIIntSurfaceSurface.hpp>
using namespace AMCAX;
namespace
{
	std::shared_ptr<Geom3BSplineCurve> CurveChooser(const int id, const std::shared_ptr<Geom3BSplineCurve>& curve0, const std::shared_ptr<Geom3BSplineCurve>& curve1, const std::shared_ptr<Geom3BSplineCurve>& curve2)
	{
		std::shared_ptr<Geom3BSplineCurve> result;
		switch (id)
		{
		case 0:
		{
			result = curve0;
			break;
		}
		case 1:
		{
			result = curve1;
			break;
		}
		case 2:
		{
			result = curve2;
			break;
		}
		}
		return result;
	}
} 
TEST_CASE("case1:this is a case for CircularSweep", "[nurbs][forcase1][Circular]")
{
	GlobalProperty g;
	SECTION("TestCircularSweepWithTwoGuidesAndTangencySurface()")
	{
		std::string filedir(INPUT_PATH_PREFIX "/TestNURBS/TestCircularSweepWithTwoGuidesAndTangencySurface/");
		auto guide1 = ReadBRepCurve(filedir + "guide1.brep");
		auto guide2 = ReadBRepCurve(filedir + "guide2.brep");
		auto surface = ReadBRepSurface(filedir + "surface.brep");
		auto spine = ReadBRepCurve(filedir + "spine.brep");
		CHECK(OCCTIO::OCCTTool::Write(MakeEdge(guide1), OUTPUT_PATH_PREFIX "TestCircularSweepWithTwoGuidesAndTangencySurface_guide1.brep"));
		CHECK(OCCTIO::OCCTTool::Write(MakeEdge(guide2), OUTPUT_PATH_PREFIX "TestCircularSweepWithTwoGuidesAndTangencySurface_guide2.brep"));
		CHECK(OCCTIO::OCCTTool::Write(MakeEdge(spine), OUTPUT_PATH_PREFIX "TestCircularSweepWithTwoGuidesAndTangencySurface_spine.brep"));
		CHECK(OCCTIO::OCCTTool::Write(MakeFace(surface, 0.0), OUTPUT_PATH_PREFIX "TestCircularSweepWithTwoGuidesAndTangencySurface_surface.brep"));
		auto [status, surfaces] = NURBSAPICircularSweep::SweepWithTwoGuidesAndTangencySurface(guide1, surface, guide2, spine, spine->FirstParameter(), spine->LastParameter());
		CHECK(status == NURBSSweepStatus::Success);
		if (status == NURBSSweepStatus::Success && !surfaces.empty())
		{
			CHECK(surfaces.size() == Approx(2.0));
			for (int i = 0; i < surfaces.size(); i++) {
				CHECK(OCCTIO::OCCTTool::Write(MakeFace(surfaces[i], 0.0), OUTPUT_PATH_PREFIX "TestCircularSweepWithTwoGuidesAndTangencySurface_result" + std::to_string(i) + ".brep"));
				AMCAX::BRepExtremaDistShapeShape len1(MakeEdge(guide1), MakeFace(surfaces[i], 0.0));
				AMCAX::BRepExtremaDistShapeShape len2(MakeEdge(guide2), MakeFace(surfaces[i], 0.0));
				AMCAX::BRepExtremaDistShapeShape len3(MakeFace(surface, 0.0), MakeFace(surfaces[i], 0.0));
				CHECK(len1.Value() < 0.1);
				CHECK(len2.Value() < 0.1);
				CHECK(len3.Value() < 0.1);
				CHECK(IsCurveOnSurf(100, 0.3, guide1, surfaces[i], 0.1));
				CHECK(IsCurveOnSurf(100, 0.3, guide2, surfaces[i], 0.1));
			}
		}
			CHECK(IsSurfTangent(100, 0.6, guide1, surface, surfaces[0], 20, 180));
			CHECK(IsSurfTangent(100, 0.6, guide1, surface, surfaces[1], 20, 180));
			guide1->IncreaseDegree(11);
			guide2->IncreaseDegree(11);
			spine->IncreaseDegree(11);
			surface->IncreaseDegree(11, 11);
			auto [status1, surfaces1] = NURBSAPICircularSweep::SweepWithTwoGuidesAndTangencySurface(guide1, surface, guide2, spine, spine->FirstParameter(), spine->LastParameter());
			CHECK(status1 == NURBSSweepStatus::Success);
			if (status1 == NURBSSweepStatus::Success && !surfaces1.empty())
			{
				CHECK(surfaces1.size() == Approx(2.0));
				for (int i = 0; i < surfaces1.size(); i++) {
					CHECK(OCCTIO::OCCTTool::Write(MakeFace(surfaces1[i], 0.0), OUTPUT_PATH_PREFIX "TestCircularSweepWithTwoGuidesAndTangencySurface_result" + std::to_string(i) + ".brep"));
					AMCAX::BRepExtremaDistShapeShape len1(MakeEdge(guide1), MakeFace(surfaces1[i], 0.0));
					AMCAX::BRepExtremaDistShapeShape len2(MakeEdge(guide2), MakeFace(surfaces1[i], 0.0));
					AMCAX::BRepExtremaDistShapeShape len3(MakeFace(surface, 0.0), MakeFace(surfaces1[i], 0.0));
					CHECK(len1.Value() < 0.1);
					CHECK(len2.Value() < 0.1);
					CHECK(len3.Value() < 0.1);
					CHECK(IsCurveOnSurf(100, 0.3, guide1, surfaces1[i], 0.1));
					CHECK(IsCurveOnSurf(100, 0.3, guide2, surfaces1[i], 0.1));
					double bsp3s = GetSurfaceProperties(MakeFace(surfaces1[i], 0.0), g, true, true);
					double bsp4s = GetSurfaceProperties(MakeFace(surfaces[i], 0.0), g, true, true);
					CHECK(bsp3s == Approx(bsp4s).margin(0.02));
				}
			}
		}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static std::pair<NURBSSweepStatus, std::vector<std::shared_ptr<Geom3BSplineSurface>>> SweepWithOneGuideAndTangencySurface(const std::shared_ptr<Geom3BSplineCurve>& guide, const std::shared_ptr<Geom3BSplineSurface>& tangencySurface, const LawFunction& radiusLaw, const std::shared_ptr<Geom3BSplineCurve>& spine, double spineLeftBound, double spineRightBound),
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <filesystem>
#include <fstream>
#include <random>
#include <sstream>
#include <nurbs/NURBSAPIGetGeometry.hpp>
#include <nurbs/NURBSAPIConicalSweep.hpp>
#include <boolean/BoolBRepCut.hpp>
#include <common/CartesianCoordinateSystem.hpp>
#include <common/IndexMap.hpp>
#include <common/QuaternionT.hpp>
#include <geomAlgo/LawBSpline.hpp>
#include <geomAlgo/LawConstant.hpp>
#include <nurbs/NURBSAPISmooth.hpp>
#include <geomAlgo/MakeConic2FromConstraints.hpp>
#include <geometry/Adaptor3CurveOnSurface.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/AdaptorGeom3Surface.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/Geom2Circle.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/Geom2Hyperbola.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom3BSplineCurve.hpp>
#include <geometry/Geom3BSplineSurface.hpp>
#include <geometry/Geom3Circle.hpp>
#include <geometry/Geom3Line.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
#include <geometry/Geom3Plane.hpp>
#include <geometry/Geom3SphericalSurface.hpp>
#include <geometry/Geom3Surface.hpp>
#include <geometry/Geom3TrimmedCurve.hpp>
#include <geometry/Geom3TrimmedSurface.hpp>
#include <geometry/GeomAPIExtremaCurveCurve3.hpp>
#include <geometry/GeomAPIProjectPointOnCurve2.hpp>
#include <geometry/GeomAPIProjectPointOnCurve3.hpp>
#include <geometry/GeomAPIProjectPointOnSurface.hpp>
#include <geometry/GeometryTool.hpp>
#include <geometry/GlobalProperty.hpp>
#include <healing/ShapeFixTool.hpp>
#include <io/STLTool.hpp>
#include <math/Sphere.hpp>
#include <math/TriangularMesh.hpp>
#include <modeling/CopyShape.hpp>
#include <modeling/MakeBox.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeFace.hpp>
#include <modeling/MakePrism.hpp>
#include <modeling/MakeRevol.hpp>
#include <modeling/MakeShapeTool.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeWire.hpp>
#include <modeling/TransformShape.hpp>
#include <nurbs/NURBSAPIApprox.hpp>
#include <nurbs/NURBSAPIBuildCurve.hpp>
#include <nurbs/NURBSAPICircularSweep.hpp>
#include <nurbs/NURBSAPIConvert.hpp>
#include <nurbs/NURBSAPICurveNetworkSurface.hpp>
#include <nurbs/NURBSAPIExplicitSweep.hpp>
#include <nurbs/NURBSAPIExplode.hpp>
#include <nurbs/NURBSAPIExtend.hpp>
#include <nurbs/NURBSAPIInterpolate.hpp>
#include <nurbs/NURBSAPIJoin.hpp>
#include <nurbs/NURBSAPILinearSweep.hpp>
#include <nurbs/NURBSAPILoft.hpp>
#include <nurbs/NURBSAPIMakeNURBSFromBoundaries.hpp>
#include <nurbs/NURBSAPIMatch.hpp>
#include <nurbs/NURBSAPIModifyEndToPlane.hpp>
#include <nurbs/NURBSAPIOffsetCurveOnSurface.hpp>
#include <nurbs/NURBSAPIProject.hpp>
#include <nurbs/NURBSAPIRebuild.hpp>
#include <nurbs/NURBSAPIReplaceEdge.hpp>
#include <nurbs/NURBSAPISweep.hpp>
#include <nurbs/NURBSAPISweep2.hpp>
#include <nurbs/NURBSAPISweepRotation.hpp>
#include <nurbs/NURBSAPITrim.hpp>
#include <nurbs/NURBSAPIUntrim.hpp>
#include <nurbs/NURBSLinearSweepWithDraftDirectionLength.hpp>
#include <occtio/OCCTTool.hpp>
#include <offset/MakePipe.hpp>
#include <offset/MakePipeShell.hpp>
#include <topology/BRepAdaptorCurve2.hpp>
#include <topology/BRepAdaptorCurve3.hpp>
#include <topology/BRepAdaptorSurface.hpp>
#include <topology/BRepGlobalProperty.hpp>
#include <topology/BRepTool.hpp>
#include <topology/TopoBuilder.hpp>
#include <topology/TopoCompound.hpp>
#include <topology/TopoEdge.hpp>
#include <topology/TopoExplorer.hpp>
#include <topology/TopoExplorerTool.hpp>
#include <topology/TopoFace.hpp>
#include <topology/TopoShape.hpp>
#include <topology/TopoShell.hpp>
#include <topology/TopoTool.hpp>
#include <topology/TopoVertex.hpp>
#include <topology/TopoWire.hpp>
#include <topology/WireExplorer.hpp>
#include <topomesh/BRepMeshIncrementalMesh.hpp>
#include <nurbs/NURBSAPIBlend.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
#include <math/LineT.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/GeomAPIIntSurfaceSurface.hpp>
using namespace AMCAX;
namespace
{
	std::shared_ptr<Geom3BSplineCurve> CurveChooser(const int id, const std::shared_ptr<Geom3BSplineCurve>& curve0, const std::shared_ptr<Geom3BSplineCurve>& curve1, const std::shared_ptr<Geom3BSplineCurve>& curve2)
	{
		std::shared_ptr<Geom3BSplineCurve> result;
		switch (id)
		{
		case 0:
		{
			result = curve0;
			break;
		}
		case 1:
		{
			result = curve1;
			break;
		}
		case 2:
		{
			result = curve2;
			break;
		}
		}
		return result;
	}
} 
TEST_CASE("case1:this is a case for CircularSweep", "[nurbs][forcase1][Circular]")
{
	GlobalProperty g;
	SECTION("TestCircularSweepWithOneGuideAndTangencySurface()")
		{
			std::string filedir(INPUT_PATH_PREFIX "/TestNURBS/TestCircularSweepWithOneGuideAndTangencySurface/");
			auto guide = ReadBRepCurve(filedir + "guide.brep");
			auto surface = ReadBRepSurface(filedir + "surface.brep");
			auto spine = ReadBRepCurve(filedir + "spine.brep");
			CHECK(OCCTIO::OCCTTool::Write(MakeEdge(guide), OUTPUT_PATH_PREFIX "TestCircularSweepWithOneGuideAndTangencySurface_guide.brep"));
			CHECK(OCCTIO::OCCTTool::Write(MakeEdge(spine), OUTPUT_PATH_PREFIX "TestCircularSweepWithOneGuideAndTangencySurface_spine.brep"));
			CHECK(OCCTIO::OCCTTool::Write(MakeFace(surface, 0.0), OUTPUT_PATH_PREFIX "TestCircularSweepWithOneGuideAndTangencySurface_surface.brep"));
			LawConstant radiusLaw;
			radiusLaw.Set(10.0, 0.0, 1.0);
			clock_t bg = clock();
			auto [status, surfaces] = NURBSAPICircularSweep::SweepWithOneGuideAndTangencySurface(guide, surface, radiusLaw, spine, spine->FirstParameter(), spine->LastParameter());
			GlobalProperty g;
			clock_t ed = clock();
			std::cout << "time = " << ed - bg << "ms" << std::endl;
			CHECK(status == NURBSSweepStatus::Success);
			if (status == NURBSSweepStatus::Success && !surfaces.empty())
			{
				int nsurfaces = static_cast<int>(surfaces.size());
				for (int i = 0; i < nsurfaces; i++)
				{
					AMCAX::BRepExtremaDistShapeShape len(MakeFace(surface, 0.0), MakeFace(surfaces[i], 0.0));
					AMCAX::BRepExtremaDistShapeShape len1(MakeFace(surfaces[i], 0.0), MakeEdge(guide));
					CHECK(len.Value() < 0.1);
					CHECK(len1.Value() < 0.1);
					CHECK(OCCTIO::OCCTTool::Write(MakeFace(surfaces[i], 0.0), OUTPUT_PATH_PREFIX "TestCircularSweepWithOneGuideAndTangencySurface_result" + std::to_string(i) + ".brep"));
				}
			}
			std::string filedir1 = OUTPUT_PATH_PREFIX;
			IndexSet<TopoShape> newshapeEdge0;
			IndexSet<TopoShape> newshapeEdge1;
			IndexSet<TopoShape> newshapeEdge2;
			IndexSet<TopoShape> newshapeEdge3;
			TopoExplorerTool::MapShapes(MakeFace(surfaces[0], 0.0), ShapeType::Edge, newshapeEdge0);
			TopoExplorerTool::MapShapes(MakeFace(surfaces[1], 0.0), ShapeType::Edge, newshapeEdge1);
			TopoExplorerTool::MapShapes(MakeFace(surfaces[2], 0.0), ShapeType::Edge, newshapeEdge2);
			TopoExplorerTool::MapShapes(MakeFace(surfaces[3], 0.0), ShapeType::Edge, newshapeEdge3);
			std::cout << "newshapedege.size" << newshapeEdge1.size() << endl;
			CHECK(OCCTIO::OCCTTool::Write(newshapeEdge0[0], OUTPUT_PATH_PREFIX "TestCircularSweepWithOneGuideAndTangencySurface_newshapeEdge0[0].brep"));
			CHECK(OCCTIO::OCCTTool::Write(newshapeEdge1[2], OUTPUT_PATH_PREFIX "TestCircularSweepWithOneGuideAndTangencySurface_newshapeEdge1[2].brep"));
			CHECK(OCCTIO::OCCTTool::Write(newshapeEdge2[0], OUTPUT_PATH_PREFIX "TestCircularSweepWithOneGuideAndTangencySurface_newshapeEdge2[0].brep"));
			CHECK(OCCTIO::OCCTTool::Write(newshapeEdge3[0], OUTPUT_PATH_PREFIX "TestCircularSweepWithOneGuideAndTangencySurface_newshapeEdge3[0].brep"));
			auto edge0 = ReadBRepCurve(filedir1 + "TestCircularSweepWithOneGuideAndTangencySurface_newshapeEdge0[0].brep");
			auto edge1 = ReadBRepCurve(filedir1 + "TestCircularSweepWithOneGuideAndTangencySurface_newshapeEdge1[2].brep");
			auto edge2 = ReadBRepCurve(filedir1 + "TestCircularSweepWithOneGuideAndTangencySurface_newshapeEdge2[0].brep");
			auto edge3 = ReadBRepCurve(filedir1 + "TestCircularSweepWithOneGuideAndTangencySurface_newshapeEdge3[0].brep");
			CHECK(IsSurfTangent(100, 0.6, edge0, surface, surfaces[0], 20, 0));
			CHECK(IsSurfTangent(100, 0.6, edge1, surface, surfaces[1], 20, 180));
			CHECK(IsSurfTangent(100, 0.6, edge2, surface, surfaces[2], 20, 180));
			CHECK(IsSurfTangent(100, 0.6, edge3, surface, surfaces[3], 20, 0));
			guide->IncreaseDegree(11);
			spine->IncreaseDegree(11);
			surface->IncreaseDegree(11, 11);
			auto [status1, surfaces1] = NURBSAPICircularSweep::SweepWithOneGuideAndTangencySurface(guide, surface, radiusLaw, spine, spine->FirstParameter(), spine->LastParameter());
			CHECK(status1 == NURBSSweepStatus::Success);
			if (status1 == NURBSSweepStatus::Success && !surfaces.empty())
			{
				int nsurfaces = static_cast<int>(surfaces.size());
				for (int i = 0; i < nsurfaces; i++)
				{
					CHECK(OCCTIO::OCCTTool::Write(MakeFace(surfaces1[i], 0.0), OUTPUT_PATH_PREFIX "TestCircularSweepWithOneGuideAndTangencySurface_degree11result" + std::to_string(i) + ".brep"));
					double bsp3s = GetSurfaceProperties(MakeFace(surfaces1[i], 0.0), g, true, true);
					double bsp4s = GetSurfaceProperties(MakeFace(surfaces[i], 0.0), g, true, true);
					CHECK(bsp3s == Approx(bsp4s).margin(0.02));
				}
			}
		}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static std::pair<NURBSSweepStatus, std::vector<std::shared_ptr<Geom3BSplineSurface>>> SweepWithCurveOnTangencySurface(const std::shared_ptr<Geom3BSplineCurve>& guide, const std::shared_ptr<Geom3BSplineSurface>& tangencySurface, const LawFunction& radiusLaw, const LawFunction& angleLaw1, const LawFunction& angleLaw2, const std::shared_ptr<Geom3BSplineCurve>& spine, double spineLeftBound, double spineRightBound),
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <filesystem>
#include <fstream>
#include <random>
#include <sstream>
#include <nurbs/NURBSAPIGetGeometry.hpp>
#include <nurbs/NURBSAPIConicalSweep.hpp>
#include <boolean/BoolBRepCut.hpp>
#include <common/CartesianCoordinateSystem.hpp>
#include <common/IndexMap.hpp>
#include <common/QuaternionT.hpp>
#include <geomAlgo/LawBSpline.hpp>
#include <geomAlgo/LawConstant.hpp>
#include <nurbs/NURBSAPISmooth.hpp>
#include <geomAlgo/MakeConic2FromConstraints.hpp>
#include <geometry/Adaptor3CurveOnSurface.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/AdaptorGeom3Surface.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/Geom2Circle.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/Geom2Hyperbola.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom3BSplineCurve.hpp>
#include <geometry/Geom3BSplineSurface.hpp>
#include <geometry/Geom3Circle.hpp>
#include <geometry/Geom3Line.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
#include <geometry/Geom3Plane.hpp>
#include <geometry/Geom3SphericalSurface.hpp>
#include <geometry/Geom3Surface.hpp>
#include <geometry/Geom3TrimmedCurve.hpp>
#include <geometry/Geom3TrimmedSurface.hpp>
#include <geometry/GeomAPIExtremaCurveCurve3.hpp>
#include <geometry/GeomAPIProjectPointOnCurve2.hpp>
#include <geometry/GeomAPIProjectPointOnCurve3.hpp>
#include <geometry/GeomAPIProjectPointOnSurface.hpp>
#include <geometry/GeometryTool.hpp>
#include <geometry/GlobalProperty.hpp>
#include <healing/ShapeFixTool.hpp>
#include <io/STLTool.hpp>
#include <math/Sphere.hpp>
#include <math/TriangularMesh.hpp>
#include <modeling/CopyShape.hpp>
#include <modeling/MakeBox.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeFace.hpp>
#include <modeling/MakePrism.hpp>
#include <modeling/MakeRevol.hpp>
#include <modeling/MakeShapeTool.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeWire.hpp>
#include <modeling/TransformShape.hpp>
#include <nurbs/NURBSAPIApprox.hpp>
#include <nurbs/NURBSAPIBuildCurve.hpp>
#include <nurbs/NURBSAPICircularSweep.hpp>
#include <nurbs/NURBSAPIConvert.hpp>
#include <nurbs/NURBSAPICurveNetworkSurface.hpp>
#include <nurbs/NURBSAPIExplicitSweep.hpp>
#include <nurbs/NURBSAPIExplode.hpp>
#include <nurbs/NURBSAPIExtend.hpp>
#include <nurbs/NURBSAPIInterpolate.hpp>
#include <nurbs/NURBSAPIJoin.hpp>
#include <nurbs/NURBSAPILinearSweep.hpp>
#include <nurbs/NURBSAPILoft.hpp>
#include <nurbs/NURBSAPIMakeNURBSFromBoundaries.hpp>
#include <nurbs/NURBSAPIMatch.hpp>
#include <nurbs/NURBSAPIModifyEndToPlane.hpp>
#include <nurbs/NURBSAPIOffsetCurveOnSurface.hpp>
#include <nurbs/NURBSAPIProject.hpp>
#include <nurbs/NURBSAPIRebuild.hpp>
#include <nurbs/NURBSAPIReplaceEdge.hpp>
#include <nurbs/NURBSAPISweep.hpp>
#include <nurbs/NURBSAPISweep2.hpp>
#include <nurbs/NURBSAPISweepRotation.hpp>
#include <nurbs/NURBSAPITrim.hpp>
#include <nurbs/NURBSAPIUntrim.hpp>
#include <nurbs/NURBSLinearSweepWithDraftDirectionLength.hpp>
#include <occtio/OCCTTool.hpp>
#include <offset/MakePipe.hpp>
#include <offset/MakePipeShell.hpp>
#include <topology/BRepAdaptorCurve2.hpp>
#include <topology/BRepAdaptorCurve3.hpp>
#include <topology/BRepAdaptorSurface.hpp>
#include <topology/BRepGlobalProperty.hpp>
#include <topology/BRepTool.hpp>
#include <topology/TopoBuilder.hpp>
#include <topology/TopoCompound.hpp>
#include <topology/TopoEdge.hpp>
#include <topology/TopoExplorer.hpp>
#include <topology/TopoExplorerTool.hpp>
#include <topology/TopoFace.hpp>
#include <topology/TopoShape.hpp>
#include <topology/TopoShell.hpp>
#include <topology/TopoTool.hpp>
#include <topology/TopoVertex.hpp>
#include <topology/TopoWire.hpp>
#include <topology/WireExplorer.hpp>
#include <topomesh/BRepMeshIncrementalMesh.hpp>
#include <nurbs/NURBSAPIBlend.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
#include <math/LineT.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/GeomAPIIntSurfaceSurface.hpp>
using namespace AMCAX;
namespace
{
	std::shared_ptr<Geom3BSplineCurve> CurveChooser(const int id, const std::shared_ptr<Geom3BSplineCurve>& curve0, const std::shared_ptr<Geom3BSplineCurve>& curve1, const std::shared_ptr<Geom3BSplineCurve>& curve2)
	{
		std::shared_ptr<Geom3BSplineCurve> result;
		switch (id)
		{
		case 0:
		{
			result = curve0;
			break;
		}
		case 1:
		{
			result = curve1;
			break;
		}
		case 2:
		{
			result = curve2;
			break;
		}
		}
		return result;
	}
} 
TEST_CASE("case1:this is a case for CircularSweep", "[nurbs][forcase1][Circular]")
{
	GlobalProperty g;
	SECTION("TestCircularSweepWithCurveOnTangencySurface()")	
		{
			std::string filedir(INPUT_PATH_PREFIX "/TestNURBS/TestCircularSweepWithCurveOnTangencySurface/");
			auto guide = ReadBRepCurve(filedir + "guide.brep");
			auto surface = ReadBRepSurface(filedir + "surface.brep");
			auto spine = ReadBRepCurve(filedir + "spine.brep");
			CHECK(OCCTIO::OCCTTool::Write(MakeEdge(guide), OUTPUT_PATH_PREFIX "TestCircularSweepWithCurveOnTangencySurface_guide.brep"));
			CHECK(OCCTIO::OCCTTool::Write(MakeEdge(spine), OUTPUT_PATH_PREFIX "TestCircularSweepWithCurveOnTangencySurface_spine.brep"));
			CHECK(OCCTIO::OCCTTool::Write(MakeFace(surface, 0.0), OUTPUT_PATH_PREFIX "TestCircularSweepWithCurveOnTangencySurface_surface.brep"));
			LawConstant radiusLaw, angleLaw1, angleLaw2;
			radiusLaw.Set(10.0, 0.0, 1.0);
			angleLaw1.Set(0.0, 0.0, 1.0);
			angleLaw2.Set(M_PI_2, 0.0, 1.0);
			auto [status, surfaces] = NURBSAPICircularSweep::SweepWithCurveOnTangencySurface(guide, surface, radiusLaw, angleLaw1, angleLaw2, spine, spine->FirstParameter(), spine->LastParameter());
			CHECK(status == NURBSSweepStatus::Success);
			if (status == NURBSSweepStatus::Success && !surfaces.empty())
			{
				int nsurfaces = static_cast<int>(surfaces.size());
				for (int i = 0; i < nsurfaces; i++)
				{
					CHECK(OCCTIO::OCCTTool::Write(MakeFace(surfaces[i], 0.0), OUTPUT_PATH_PREFIX "TestCircularSweepWithCurveOnTangencySurface_result" + std::to_string(i) + ".brep"));
					CHECK(IsCurveOnSurf(1000, 0.1, guide, surfaces[i], 0.5));
					AMCAX::BRepExtremaDistShapeShape len(MakeFace(surface, 0.0), MakeFace(surfaces[i], 0.0));
					AMCAX::BRepExtremaDistShapeShape len1(MakeFace(surfaces[i], 0.0), MakeEdge(guide));
					CHECK(len1.Value() < 1.0);
					CHECK(len.Value() < 0.1);
				}
			}
			std::string filedir1 = OUTPUT_PATH_PREFIX;
			IndexSet<TopoShape> newshapeEdge1;
			IndexSet<TopoShape> newshapeEdge2;
			TopoExplorerTool::MapShapes(MakeFace(surfaces[0], 0.0), ShapeType::Edge, newshapeEdge1);
			TopoExplorerTool::MapShapes(MakeFace(surfaces[1], 0.0), ShapeType::Edge, newshapeEdge2);
			std::cout << "newshapedege.size" << newshapeEdge1.size() << endl;
			CHECK(OCCTIO::OCCTTool::Write(newshapeEdge1[0], OUTPUT_PATH_PREFIX "TestCircularSweepWithCurveOnTangencySurface_newshapeEdge1[0].brep"));
			CHECK(OCCTIO::OCCTTool::Write(newshapeEdge2[1], OUTPUT_PATH_PREFIX "TestCircularSweepWithCurveOnTangencySurface_newshapeEdge2[1].brep"));
			CHECK(OCCTIO::OCCTTool::Write(newshapeEdge2[2], OUTPUT_PATH_PREFIX "TestCircularSweepWithCurveOnTangencySurface_newshapeEdge2[2].brep"));
			CHECK(OCCTIO::OCCTTool::Write(newshapeEdge2[0], OUTPUT_PATH_PREFIX "TestCircularSweepWithCurveOnTangencySurface_newshapeEdge2[0].brep"));
			CHECK(OCCTIO::OCCTTool::Write(newshapeEdge2[3], OUTPUT_PATH_PREFIX "TestCircularSweepWithCurveOnTangencySurface_newshapeEdge2[3].brep"));
			auto edge0 = ReadBRepCurve(filedir1 + "TestCircularSweepWithCurveOnTangencySurface_newshapeEdge1[0].brep");
			auto edge1 = ReadBRepCurve(filedir1 + "TestCircularSweepWithCurveOnTangencySurface_newshapeEdge2[0].brep");
			CHECK(IsSurfTangent(100, 0.6, edge0, surface, surfaces[0], 20, 0));
			CHECK(IsSurfTangent(100, 0.6, edge1, surface, surfaces[0], 20, 0));
			guide->IncreaseDegree(5);
			spine->IncreaseDegree(5);
			surface->IncreaseDegree(5, 5);
			auto [status1, surfaces1] = NURBSAPICircularSweep::SweepWithCurveOnTangencySurface(guide, surface, radiusLaw, angleLaw1, angleLaw2, spine, spine->FirstParameter(), spine->LastParameter());
			CHECK(status1 == NURBSSweepStatus::Success);
			if (status1 == NURBSSweepStatus::Success && !surfaces.empty())
			{
				int nsurfaces = static_cast<int>(surfaces.size());
				for (int i = 0; i < nsurfaces; i++)
				{
					CHECK(OCCTIO::OCCTTool::Write(MakeFace(surfaces1[i], 0.0), OUTPUT_PATH_PREFIX "TestCircularSweepWithCurveOnTangencySurface_degree5result" + std::to_string(i) + ".brep"));
					CHECK(IsCurveOnSurf(1000, 0.1, guide, surfaces1[i], 0.5));
					double bsp3s = GetSurfaceProperties(MakeFace(surfaces1[i], 0.0), g, true, true);
					double bsp4s = GetSurfaceProperties(MakeFace(surfaces[i], 0.0), g, true, true);
					CHECK(bsp3s == Approx(bsp4s).margin(0.02));
				}
			}
		}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static std::shared_ptr<Geom3BSplineCurve> ToBSpline(const std::shared_ptr<Geom3Curve>& curve)	 @return Result BSpline curve
	 @param curve The given curve
	 @brief Convert a common curve to a BSpline curve
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include<common/Exception.hpp>
#include <nurbs/NURBSAPIConvert.hpp>
#include <topology/TopoEdge.hpp>
#include <topology/TopoTool.hpp>
#include <topology/TopoVertex.hpp>
#include <geometry/Geom3TrimmedCurve.hpp>
#include <geometry/Geom3BSplineCurve.hpp>
#include <occtio/OCCTTool.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeFace.hpp>
#include <geometry/Geom3Circle.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
#include <geometry/Geom3Line.hpp>
#include <geometry/Geom3BezierCurve.hpp>
#include <geometry/Geom3Ellipse.hpp>
#include <geometry/Geom3Hyperbola.hpp>
#include <geometry/Geom3Parabola.hpp>
#include <geometry/Geom3SphericalSurface.hpp>
#include <math/Sphere.hpp>
#include <geometry/Geom3Surface.hpp>
#include <geometry/Geom3BSplineSurface.hpp>
#include <geometry/Geom3TrimmedSurface.hpp>
#include <geometry/Geom3ElementarySurface.hpp>
#include <geometry/Geom3OffsetSurface.hpp>
#include <geometry/Geom3SweptSurface.hpp>
#include <geometry/Geom3SurfaceOfExtrusion.hpp>
#include <geometry/Geom3BezierSurface.hpp>
#include <math/Cone.hpp>
#include <geometry/Geom3ConicalSurface.hpp>
#include <geometry/Geom3CylindricalSurface.hpp>
#include <geometry/Geom3Plane.hpp>
#include <geometry/Geom3ToroidalSurface.hpp>
#include <geometry/Geom3SurfaceOfExtrusion.hpp>
#include <geometry/Geom3SurfaceOfRevolution.hpp>
using namespace std;
using namespace AMCAX;
double NurbsLinearCurve(const shared_ptr<Geom3Curve>& curve1, const shared_ptr<Geom3BSplineCurve>& curve2)
{
    TopoShape edge1 = MakeEdge(curve1);
    TopoShape edge2 = MakeEdge(curve2);
    GlobalProperty props1, props2;
    double len1 = GetLinearProperties(edge1, props1, true, false);
    double len2 = GetLinearProperties(edge2, props2, true, false);
    double len = abs(len1 - len2);
    return len;
}
double NurbsSurfaceResult(const shared_ptr<Geom3Surface>& surface1, const shared_ptr<Geom3BSplineSurface>& surface2)
{
    TopoFace f1 = MakeFace(surface1, 0.0);
    TopoFace f2 = MakeFace(surface2, 0.0);
    GlobalProperty props1, props2;
    double s1 = GetSurfaceProperties(f1, props1, true, false);
    double s2 = GetSurfaceProperties(f2, props2, true, false);
    double res = abs(s1 - s2);
    return res;
}
TEST_CASE("bug1: ConvertToBSplineCurve ", "[nurbs][convert][fixbug]")
{
    double res;
    double tol = 0.1;
    Point3 p(0.0, 0.0, 0.0);
    Direction3 dir(0.0, 0.0, 1.0);
    Direction3 dir1(1.0, 0.0, 0.0);
    shared_ptr<Geom3Curve> curve;
    curve = make_shared<Geom3Circle>(Frame3(p, dir), 1.0);
	SECTION("TrimmedCurve = M_PI")
    {
        shared_ptr<Geom3TrimmedCurve> TrimmedCurve = make_shared<Geom3TrimmedCurve>(curve, 0.0, M_PI);
        Axis3 axis(p, dir1);
        shared_ptr<Geom3SweptSurface> surf;
        surf = make_shared<Geom3SurfaceOfRevolution>(TrimmedCurve, axis);
        shared_ptr<Geom3BSplineSurface> bspSurf = NURBSAPIConvert::ToBSpline(surf);
        res = NurbsSurfaceResult(surf, bspSurf);
        CHECK(res <= tol);
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static std::shared_ptr<Geom3BSplineSurface> ToBSpline(const std::shared_ptr<Geom3Surface>& surface)	 @return BSpline surface
	 @param surface The given surface
	 @brief Convert a common surface to a BSpline surface
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include<common/Exception.hpp>
#include <nurbs/NURBSAPIConvert.hpp>
#include <topology/TopoEdge.hpp>
#include <topology/TopoTool.hpp>
#include <topology/TopoVertex.hpp>
#include <geometry/Geom3TrimmedCurve.hpp>
#include <geometry/Geom3BSplineCurve.hpp>
#include <occtio/OCCTTool.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeFace.hpp>
#include <geometry/Geom3Circle.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
#include <geometry/Geom3Line.hpp>
#include <geometry/Geom3BezierCurve.hpp>
#include <geometry/Geom3Ellipse.hpp>
#include <geometry/Geom3Hyperbola.hpp>
#include <geometry/Geom3Parabola.hpp>
#include <geometry/Geom3SphericalSurface.hpp>
#include <math/Sphere.hpp>
#include <geometry/Geom3Surface.hpp>
#include <geometry/Geom3BSplineSurface.hpp>
#include <geometry/Geom3TrimmedSurface.hpp>
#include <geometry/Geom3ElementarySurface.hpp>
#include <geometry/Geom3OffsetSurface.hpp>
#include <geometry/Geom3SweptSurface.hpp>
#include <geometry/Geom3SurfaceOfExtrusion.hpp>
#include <geometry/Geom3BezierSurface.hpp>
#include <math/Cone.hpp>
#include <geometry/Geom3ConicalSurface.hpp>
#include <geometry/Geom3CylindricalSurface.hpp>
#include <geometry/Geom3Plane.hpp>
#include <geometry/Geom3ToroidalSurface.hpp>
#include <geometry/Geom3SurfaceOfExtrusion.hpp>
#include <geometry/Geom3SurfaceOfRevolution.hpp>
using namespace std;
using namespace AMCAX;
double NurbsLinearCurve(const shared_ptr<Geom3Curve>& curve1, const shared_ptr<Geom3BSplineCurve>& curve2)
{
    TopoShape edge1 = MakeEdge(curve1);
    TopoShape edge2 = MakeEdge(curve2);
    GlobalProperty props1, props2;
    double len1 = GetLinearProperties(edge1, props1, true, false);
    double len2 = GetLinearProperties(edge2, props2, true, false);
    double len = abs(len1 - len2);
    return len;
}
double NurbsSurfaceResult(const shared_ptr<Geom3Surface>& surface1, const shared_ptr<Geom3BSplineSurface>& surface2)
{
    TopoFace f1 = MakeFace(surface1, 0.0);
    TopoFace f2 = MakeFace(surface2, 0.0);
    GlobalProperty props1, props2;
    double s1 = GetSurfaceProperties(f1, props1, true, false);
    double s2 = GetSurfaceProperties(f2, props2, true, false);
    double res = abs(s1 - s2);
    return res;
}
TEST_CASE("bug5: ConvertToBSplineCurve ", "[nurbs][convert][fixbug]")
{
	SECTION("Geom3BSplineSurface")
    {
        shared_ptr<Geom3BSplineSurface> surf;
        surf = make_shared<Geom3BSplineSurface>();
        shared_ptr<Geom3BSplineSurface> bspSurf= NURBSAPIConvert::ToBSpline(surf);
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static std::vector<std::pair<double, bool>> CalcParamCorrespondece( const std::vector<std::shared_ptr<Geom3Curve>>& curves, bool isPeriodic, bool isConsiderReverse),
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <nurbs/NURBSAPICorrespondence.hpp>
#include <modeling/MakeEdge.hpp>
#include <topology/TopoExplorerTool.hpp>
#include <nurbs/NURBSAPIConvert.hpp>
using namespace std;
TEST_CASE("case1: this is a test for CalcParamCorrespondece", "[nurbs][Correspondence][P1]")
{
	OUTPUT_DIRECTORY(nurbs, Correspondence);
	vector<shared_ptr<Geom3Curve>> curves;
	shared_ptr<Geom3BSplineCurve> vbsp1, vbsp2, vbsp3, vbsp4, hbsp1, hbsp2, hbsp3;
	{
		int deg = 3;
		std::vector<Point3> poles;
		poles.push_back(Point3(0.0, -1.0, 0.1));
		poles.push_back(Point3(0.07, -0.7, 0.2));
		poles.push_back(Point3(0.1, -0.3, 0.1));
		poles.push_back(Point3(0.12, 0.0, -0.1));
		poles.push_back(Point3(0.20, 0.3, -0.2));
		poles.push_back(Point3(0.07, 0.7, -0.3));
		poles.push_back(Point3(0.0, 1.0, 0.0));
		int nknots = static_cast<int>(poles.size()) - deg + 1;
		std::vector<double> knots(nknots);
		for (int i = 0; i < nknots; i++)
		{
			knots[i] = (double)i / (double)(nknots - 1.0);
		}
		std::vector<int> mults(nknots, 1);
		mults.front() = deg + 1;
		mults.back() = deg + 1;
		vbsp1 = std::make_shared<Geom3BSplineCurve>(poles, knots, mults, deg);
		OCCTIO::OCCTTool::Write(MakeEdge(vbsp1), outdir + "vbsp1.brep");
	}
	{
		int deg = 3;
		std::vector<Point3> poles;
		poles.push_back(Point3(2.0, -2.0, -0.1));
		poles.push_back(Point3(2.1, -1.3, -0.2));
		poles.push_back(Point3(2.15, -0.8, -0.1));
		poles.push_back(Point3(1.83, -0.2, 0.1));
		poles.push_back(Point3(1.48, 0.1, 0.2));
		poles.push_back(Point3(1.0, 1.0, 0.1));
		int nknots = static_cast<int>(poles.size()) - deg + 1;
		std::vector<double> knots(nknots);
		for (int i = 0; i < nknots; i++)
		{
			knots[i] = (double)i / (double)(nknots - 1.0);
		}
		std::vector<int> mults(nknots, 1);
		mults.front() = deg + 1;
		mults.back() = deg + 1;
		vbsp2 = std::make_shared<Geom3BSplineCurve>(poles, knots, mults, deg);
		OCCTIO::OCCTTool::Write(MakeEdge(vbsp2), outdir + "vbsp2.brep");
	}
	{
		int deg = 3;
		std::vector<Point3> poles;
		poles.push_back(Point3(3.0, -2.0, 0.1));
		poles.push_back(Point3(3.07, -1.3, 0.2));
		poles.push_back(Point3(3.1, -0.3, 0.1));
		poles.push_back(Point3(3.12, 0.0, -0.1));
		poles.push_back(Point3(3.0, 0.3, -0.2));
		poles.push_back(Point3(2.57, 0.7, -0.3));
		poles.push_back(Point3(2.2, 1.0, 0.0));
		int nknots = static_cast<int>(poles.size()) - deg + 1;
		std::vector<double> knots(nknots);
		for (int i = 0; i < nknots; i++)
		{
			knots[i] = (double)i / (double)(nknots - 1.0);
		}
		std::vector<int> mults(nknots, 1);
		mults.front() = deg + 1;
		mults.back() = deg + 1;
		vbsp3 = std::make_shared<Geom3BSplineCurve>(poles, knots, mults, deg);
		OCCTIO::OCCTTool::Write(MakeEdge(vbsp3), outdir + "vbsp3.brep");
	}
	{
		int deg = 3;
		std::vector<Point3> poles;
		poles.push_back(Point3(4.0, -1.5, -0.1));
		poles.push_back(Point3(4.1, -1.3, -0.2));
		poles.push_back(Point3(4.15, -0.8, -0.1));
		poles.push_back(Point3(3.83, -0.2, 0.1));
		poles.push_back(Point3(3.48, 0.1, 0.2));
		poles.push_back(Point3(3.0, 1.0, 0.1));
		int nknots = static_cast<int>(poles.size()) - deg + 1;
		std::vector<double> knots(nknots);
		for (int i = 0; i < nknots; i++)
		{
			knots[i] = (double)i / (double)(nknots - 1.0);
		}
		std::vector<int> mults(nknots, 1);
		mults.front() = deg + 1;
		mults.back() = deg + 1;
		vbsp4 = std::make_shared<Geom3BSplineCurve>(poles, knots, mults, deg);
		OCCTIO::OCCTTool::Write(MakeEdge(vbsp4), outdir + "vbsp4.brep");
	}
	{
		int deg = 3;
		std::vector<Point3> poles;
		poles.push_back(Point3(0.0, -1.0, 0.1));
		poles.push_back(Point3(0.9, -1.5, -0.1));
		poles.push_back(Point3(3.0, -1.8, 0.1));
		poles.push_back(Point3(4.0, -1.5, -0.1));
		int nknots = static_cast<int>(poles.size()) - deg + 1;
		std::vector<double> knots(nknots);
		for (int i = 0; i < nknots; i++)
		{
			knots[i] = (double)i / (double)(nknots - 1.0);
		}
		std::vector<int> mults(nknots, 1);
		mults.front() = deg + 1;
		mults.back() = deg + 1;
		hbsp1 = std::make_shared<Geom3BSplineCurve>(poles, knots, mults, deg);
		OCCTIO::OCCTTool::Write(MakeEdge(hbsp1), outdir + "hbsp1.brep");
	}
	{
		int deg = 3;
		std::vector<Point3> poles;
		poles.push_back(Point3(0.0, 0.0, 0.0));
		poles.push_back(Point3(1.2, -1.15, -0.1));
		poles.push_back(Point3(2.7, -1.05, 0.1));
		poles.push_back(Point3(3.7, -1.3, -0.1));
		poles.push_back(Point3(5.0, -1.0, 0.1));
		int nknots = static_cast<int>(poles.size()) - deg + 1;
		std::vector<double> knots(nknots);
		for (int i = 0; i < nknots; i++)
		{
			knots[i] = (double)i / (double)(nknots - 1.0);
		}
		std::vector<int> mults(nknots, 1);
		mults.front() = deg + 1;
		mults.back() = deg + 1;
		hbsp2 = std::make_shared<Geom3BSplineCurve>(poles, knots, mults, deg);
		OCCTIO::OCCTTool::Write(MakeEdge(hbsp2), outdir + "hbsp2.brep");
	}
	{
		int deg = 3;
		vector<Point3> poles;
		poles.push_back(Point3(0.0, 1.0, 0.0));
		poles.push_back(Point3(0.9, 0.15, -0.1));
		poles.push_back(Point3(1.7, 0.05, 0.1));
		poles.push_back(Point3(2.7, 0.3, -0.1));
		poles.push_back(Point3(3.0, 1.0, 0.1));
		int nknots = static_cast<int>(poles.size()) - deg + 1;
		vector<double> knots(nknots);
		for (int i = 0; i < nknots; i++)
		{
			knots[i] = (double)i / (double)(nknots - 1.0);
		}
		vector<int> mults(nknots, 1);
		mults.front() = deg + 1;
		mults.back() = deg + 1;
		hbsp3 = make_shared<Geom3BSplineCurve>(poles, knots, mults, deg);
		OCCTIO::OCCTTool::Write(MakeEdge(hbsp3), outdir + "hbsp3.brep");
	}
	curves.push_back(vbsp1);
	curves.push_back(vbsp2);
	curves.push_back(vbsp3);
	curves.push_back(vbsp4);
	curves.push_back(hbsp1);
	curves.push_back(hbsp2);
	curves.push_back(hbsp3);
	SECTION("isPeriodic+isConsiderReverse")
	{
		bool isPeriodic = true;
		bool isConsiderReverse = true;
		vector<pair<double, bool>> corrs = NURBSAPICorrespondence::CalcParamCorrespondece(curves, isPeriodic, isConsiderReverse);
		CHECK(corrs[0].first == 0.0);
		CHECK(corrs[0].second == false);
		CHECK(corrs[1].first > 0.0);
		CHECK(corrs[1].second == true);
		CHECK(corrs[2].first > 0.0);
		CHECK(corrs[2].second == true);
		CHECK(corrs[3].first > 0.0);
		CHECK(corrs[3].second == true);
		CHECK(corrs[4].first > 0.0);
		CHECK(corrs[4].second == true);
		CHECK(corrs[5].first > 0.0);
		CHECK(corrs[5].second == true);
		CHECK(corrs[6].first > 0.0);
		CHECK(corrs[6].second == true);
		CHECK(corrs.size() == 7);
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static std::shared_ptr<Geom3BSplineSurface> CurveNetworkSurfaceGordon(const std::vector<std::shared_ptr<Geom3BSplineCurve>>& verticalCurves, const std::vector<std::shared_ptr<Geom3BSplineCurve>>& horizontalCurves)	 @return The Gordon surface which go through the curves
	 @param horizontalCurves Horizontal network curves
	 @param verticalCurves Vertical network curves
	 @brief Coons-Gordon surface
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <nurbs/NURBSAPICurveNetworkSurface.hpp>
#include <topology/TopoEdge.hpp>
#include <topology/TopoTool.hpp>
#include <modeling/MakeFace.hpp>
#include <nurbs/NURBSAPILoft.hpp>
#include <common/Precision.hpp>
#include <modeling/MakeEdge.hpp>
#include <occtio/OCCTTool.hpp>
#include <geometry/Geom3BSplineCurve.hpp>
#include <geometry/Geom3BSplineSurface.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
#include <topology/TopoExplorerTool.hpp>
#include <geometry/GeomAPIProjectPointOnSurface.hpp>
using namespace std;
using namespace AMCAX;
double NurbsSampleCurveOnSurface(int num, double tol, const shared_ptr<Geom3Curve>& curve, const shared_ptr<Geom3Surface>& surf)
{
	const int nsample = num;
	double fp1 = curve->FirstParameter();
	double lp1 = curve->LastParameter();
	double delta1 = (lp1 - fp1) / nsample;
	Point3 p;
	int n = 0;
	for (int i = 0; i < nsample; i++)
	{
		double t1 = fp1 + i * delta1;
		curve->D0(t1, p);
		GeomAPIProjectPointOnSurface projector(p, surf);
		double dis = projector.LowerDistance();
		if (dis <= tol)
		{
			n++;
		}
	}
	double res = 1.0 * (num - n) / num;
	return res;
}
vector< shared_ptr<Geom3BSplineCurve>> ConstructBSplineCurve()
{
	vector<shared_ptr<Geom3BSplineCurve>> vec;
	shared_ptr<Geom3BSplineCurve> vbsp1, vbsp2, vbsp3, vbsp4, hbsp1, hbsp2, hbsp3;
	{
		int deg = 3;
		std::vector<Point3> poles;
		poles.push_back(Point3(0.0, -1.0, 0.1));
		poles.push_back(Point3(0.07, -0.7, 0.2));
		poles.push_back(Point3(0.1, -0.3, 0.1));
		poles.push_back(Point3(0.12, 0.0, -0.1));
		poles.push_back(Point3(0.20, 0.3, -0.2));
		poles.push_back(Point3(0.07, 0.7, -0.3));
		poles.push_back(Point3(0.0, 1.0, 0.0));
		int nknots = static_cast<int>(poles.size()) - deg + 1;
		std::vector<double> knots(nknots);
		for (int i = 0; i < nknots; i++)
		{
			knots[i] = (double)i / (double)(nknots - 1.0);
		}
		std::vector<int> mults(nknots, 1);
		mults.front() = deg + 1;
		mults.back() = deg + 1;
		vbsp1 = std::make_shared<Geom3BSplineCurve>(poles, knots, mults, deg);
	}
	{
		int deg = 3;
		std::vector<Point3> poles;
		poles.push_back(Point3(2.0, -2.0, -0.1));
		poles.push_back(Point3(2.1, -1.3, -0.2));
		poles.push_back(Point3(2.15, -0.8, -0.1));
		poles.push_back(Point3(1.83, -0.2, 0.1));
		poles.push_back(Point3(1.48, 0.1, 0.2));
		poles.push_back(Point3(1.0, 1.0, 0.1));
		int nknots = static_cast<int>(poles.size()) - deg + 1;
		std::vector<double> knots(nknots);
		for (int i = 0; i < nknots; i++)
		{
			knots[i] = (double)i / (double)(nknots - 1.0);
		}
		std::vector<int> mults(nknots, 1);
		mults.front() = deg + 1;
		mults.back() = deg + 1;
		vbsp2 = std::make_shared<Geom3BSplineCurve>(poles, knots, mults, deg);
	}
	{
		int deg = 3;
		std::vector<Point3> poles;
		poles.push_back(Point3(3.0, -2.0, 0.1));
		poles.push_back(Point3(3.07, -1.3, 0.2));
		poles.push_back(Point3(3.1, -0.3, 0.1));
		poles.push_back(Point3(3.12, 0.0, -0.1));
		poles.push_back(Point3(3.0, 0.3, -0.2));
		poles.push_back(Point3(2.57, 0.7, -0.3));
		poles.push_back(Point3(2.2, 1.0, 0.0));
		int nknots = static_cast<int>(poles.size()) - deg + 1;
		std::vector<double> knots(nknots);
		for (int i = 0; i < nknots; i++)
		{
			knots[i] = (double)i / (double)(nknots - 1.0);
		}
		std::vector<int> mults(nknots, 1);
		mults.front() = deg + 1;
		mults.back() = deg + 1;
		vbsp3 = std::make_shared<Geom3BSplineCurve>(poles, knots, mults, deg);
	}
	{
		int deg = 3;
		std::vector<Point3> poles;
		poles.push_back(Point3(4.0, -1.5, -0.1));
		poles.push_back(Point3(4.1, -1.3, -0.2));
		poles.push_back(Point3(4.15, -0.8, -0.1));
		poles.push_back(Point3(3.83, -0.2, 0.1));
		poles.push_back(Point3(3.48, 0.1, 0.2));
		poles.push_back(Point3(3.0, 1.0, 0.1));
		int nknots = static_cast<int>(poles.size()) - deg + 1;
		std::vector<double> knots(nknots);
		for (int i = 0; i < nknots; i++)
		{
			knots[i] = (double)i / (double)(nknots - 1.0);
		}
		std::vector<int> mults(nknots, 1);
		mults.front() = deg + 1;
		mults.back() = deg + 1;
		vbsp4 = std::make_shared<Geom3BSplineCurve>(poles, knots, mults, deg);
	}
	{
		int deg = 3;
		std::vector<Point3> poles;
		poles.push_back(Point3(0.0, -1.0, 0.1));
		poles.push_back(Point3(0.9, -1.5, -0.1));
		poles.push_back(Point3(3.0, -1.8, 0.1));
		poles.push_back(Point3(4.0, -1.5, -0.1));
		int nknots = static_cast<int>(poles.size()) - deg + 1;
		std::vector<double> knots(nknots);
		for (int i = 0; i < nknots; i++)
		{
			knots[i] = (double)i / (double)(nknots - 1.0);
		}
		std::vector<int> mults(nknots, 1);
		mults.front() = deg + 1;
		mults.back() = deg + 1;
		hbsp1 = std::make_shared<Geom3BSplineCurve>(poles, knots, mults, deg);
	}
	{
		int deg = 3;
		std::vector<Point3> poles;
		poles.push_back(Point3(0.0, 0.0, 0.0));
		poles.push_back(Point3(1.2, -1.15, -0.1));
		poles.push_back(Point3(2.7, -1.05, 0.1));
		poles.push_back(Point3(3.7, -1.3, -0.1));
		poles.push_back(Point3(5.0, -1.0, 0.1));
		int nknots = static_cast<int>(poles.size()) - deg + 1;
		std::vector<double> knots(nknots);
		for (int i = 0; i < nknots; i++)
		{
			knots[i] = (double)i / (double)(nknots - 1.0);
		}
		std::vector<int> mults(nknots, 1);
		mults.front() = deg + 1;
		mults.back() = deg + 1;
		hbsp2 = std::make_shared<Geom3BSplineCurve>(poles, knots, mults, deg);
	}
	{
		int deg = 3;
		vector<Point3> poles;
		poles.push_back(Point3(0.0, 1.0, 0.0));
		poles.push_back(Point3(0.9, 0.15, -0.1));
		poles.push_back(Point3(1.7, 0.05, 0.1));
		poles.push_back(Point3(2.7, 0.3, -0.1));
		poles.push_back(Point3(3.0, 1.0, 0.1));
		int nknots = static_cast<int>(poles.size()) - deg + 1;
		vector<double> knots(nknots);
		for (int i = 0; i < nknots; i++)
		{
			knots[i] = (double)i / (double)(nknots - 1.0);
		}
		vector<int> mults(nknots, 1);
		mults.front() = deg + 1;
		mults.back() = deg + 1;
		hbsp3 = make_shared<Geom3BSplineCurve>(poles, knots, mults, deg);
	}
	vec.push_back(vbsp1);
	vec.push_back(vbsp2);
	vec.push_back(vbsp3);
	vec.push_back(vbsp4);
	vec.push_back(hbsp1);
	vec.push_back(hbsp2);
	vec.push_back(hbsp3);
	return vec;
}
TEST_CASE("bug1: CurveNetworkSurface ", "[nurbs][CurveNetworkSurface][fixbug]")
{
	OUTPUT_DIRECTORY(nurbs, CurveNetworkSurface/bug464);
	double refTol = 0.1;
	vector< shared_ptr<Geom3BSplineCurve>> vec = ConstructBSplineCurve();
	TopoEdge edge1 = MakeEdge(vec[0]);
	TopoEdge edge2 = MakeEdge(vec[1]);
	TopoEdge edge3 = MakeEdge(vec[2]);
	TopoEdge edge4 = MakeEdge(vec[3]);
	TopoEdge edge5 = MakeEdge(vec[4]);
	TopoEdge edge6 = MakeEdge(vec[5]);
	TopoEdge edge7 = MakeEdge(vec[6]);
	vector<shared_ptr<Geom3BSplineCurve>> horizontalCurves, verticalCurves;
	verticalCurves.push_back(vec[0]);
	verticalCurves.push_back(vec[1]);
	verticalCurves.push_back(vec[2]);
	verticalCurves.push_back(vec[3]);
	horizontalCurves.push_back(vec[4]);
	horizontalCurves.push_back(vec[5]);
	horizontalCurves.push_back(vec[6]);
	shared_ptr<Geom3BSplineSurface> surf = NURBSAPICurveNetworkSurface::CurveNetworkSurfaceGordon(verticalCurves, horizontalCurves);
	TopoShape surface = MakeFace(surf, 0.0);
	BRepExtremaDistShapeShape dist1(edge1, surface);
	BRepExtremaDistShapeShape dist2(edge2, surface);
	BRepExtremaDistShapeShape dist3(edge3, surface);
	BRepExtremaDistShapeShape dist4(edge4, surface);
	BRepExtremaDistShapeShape dist5(edge5, surface);
	BRepExtremaDistShapeShape dist6(edge6, surface);
	BRepExtremaDistShapeShape dist7(edge7, surface);
	CHECK(dist3.Value() <= Approx(refTol));
	CHECK(dist4.Value() <= Approx(refTol));
	CHECK(dist7.Value() <= Approx(refTol));
	OCCTIO::OCCTTool::Write(MakeEdge(vec[0]), outdir + "vbsp1.brep");
	OCCTIO::OCCTTool::Write(MakeEdge(vec[1]), outdir + "vbsp2.brep");
	OCCTIO::OCCTTool::Write(MakeEdge(vec[2]), outdir + "vbsp3.brep");
	OCCTIO::OCCTTool::Write(MakeEdge(vec[3]), outdir + "vbsp4.brep");
	OCCTIO::OCCTTool::Write(MakeEdge(vec[4]), outdir + "hbsp1.brep");
	OCCTIO::OCCTTool::Write(MakeEdge(vec[5]), outdir + "hbsp2.brep");
	OCCTIO::OCCTTool::Write(MakeEdge(vec[6]), outdir + "hbsp3.brep");
	OCCTIO::OCCTTool::Write(surface, outdir + "surfResult.brep");
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static std::pair<NURBSSweepStatus, std::shared_ptr<Geom3BSplineSurface>> SweepWithTwoGuideCurves( const std::shared_ptr<Geom3BSplineCurve>& profile, const std::shared_ptr<Geom3BSplineCurve>& guide1, const std::shared_ptr<Geom3BSplineCurve>& guide2, Point3 anchorPoint1, Point3 anchorPoint2, const std::shared_ptr<Geom3BSplineCurve>& spine, double spineLeftBound, double spineRightBound),
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <filesystem>
#include <fstream>
#include <random>
#include <sstream>
#include <nurbs/NURBSAPIGetGeometry.hpp>
#include <nurbs/NURBSAPIConicalSweep.hpp>
#include <boolean/BoolBRepCut.hpp>
#include <common/CartesianCoordinateSystem.hpp>
#include <common/IndexMap.hpp>
#include <common/QuaternionT.hpp>
#include <geomAlgo/LawBSpline.hpp>
#include <geomAlgo/LawConstant.hpp>
#include <nurbs/NURBSAPISmooth.hpp>
#include <geomAlgo/MakeConic2FromConstraints.hpp>
#include <geometry/Adaptor3CurveOnSurface.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/AdaptorGeom3Surface.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/Geom2Circle.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/Geom2Hyperbola.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom3BSplineCurve.hpp>
#include <geometry/Geom3BSplineSurface.hpp>
#include <geometry/Geom3Circle.hpp>
#include <geometry/Geom3Line.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
#include <geometry/Geom3Plane.hpp>
#include <geometry/Geom3SphericalSurface.hpp>
#include <geometry/Geom3Surface.hpp>
#include <geometry/Geom3TrimmedCurve.hpp>
#include <geometry/Geom3TrimmedSurface.hpp>
#include <geometry/GeomAPIExtremaCurveCurve3.hpp>
#include <geometry/GeomAPIProjectPointOnCurve2.hpp>
#include <geometry/GeomAPIProjectPointOnCurve3.hpp>
#include <geometry/GeomAPIProjectPointOnSurface.hpp>
#include <geometry/GeometryTool.hpp>
#include <geometry/GlobalProperty.hpp>
#include <healing/ShapeFixTool.hpp>
#include <io/STLTool.hpp>
#include <math/Sphere.hpp>
#include <math/TriangularMesh.hpp>
#include <modeling/CopyShape.hpp>
#include <modeling/MakeBox.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeFace.hpp>
#include <modeling/MakePrism.hpp>
#include <modeling/MakeRevol.hpp>
#include <modeling/MakeShapeTool.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeWire.hpp>
#include <modeling/TransformShape.hpp>
#include <nurbs/NURBSAPIApprox.hpp>
#include <nurbs/NURBSAPIBuildCurve.hpp>
#include <nurbs/NURBSAPICircularSweep.hpp>
#include <nurbs/NURBSAPIConvert.hpp>
#include <nurbs/NURBSAPICurveNetworkSurface.hpp>
#include <nurbs/NURBSAPIExplicitSweep.hpp>
#include <nurbs/NURBSAPIExplode.hpp>
#include <nurbs/NURBSAPIExtend.hpp>
#include <nurbs/NURBSAPIInterpolate.hpp>
#include <nurbs/NURBSAPIJoin.hpp>
#include <nurbs/NURBSAPILinearSweep.hpp>
#include <nurbs/NURBSAPILoft.hpp>
#include <nurbs/NURBSAPIMakeNURBSFromBoundaries.hpp>
#include <nurbs/NURBSAPIMatch.hpp>
#include <nurbs/NURBSAPIModifyEndToPlane.hpp>
#include <nurbs/NURBSAPIOffsetCurveOnSurface.hpp>
#include <nurbs/NURBSAPIProject.hpp>
#include <nurbs/NURBSAPIRebuild.hpp>
#include <nurbs/NURBSAPIReplaceEdge.hpp>
#include <nurbs/NURBSAPISweep.hpp>
#include <nurbs/NURBSAPISweep2.hpp>
#include <nurbs/NURBSAPISweepRotation.hpp>
#include <nurbs/NURBSAPITrim.hpp>
#include <nurbs/NURBSAPIUntrim.hpp>
#include <nurbs/NURBSLinearSweepWithDraftDirectionLength.hpp>
#include <occtio/OCCTTool.hpp>
#include <offset/MakePipe.hpp>
#include <offset/MakePipeShell.hpp>
#include <topology/BRepAdaptorCurve2.hpp>
#include <topology/BRepAdaptorCurve3.hpp>
#include <topology/BRepAdaptorSurface.hpp>
#include <topology/BRepGlobalProperty.hpp>
#include <topology/BRepTool.hpp>
#include <topology/TopoBuilder.hpp>
#include <topology/TopoCompound.hpp>
#include <topology/TopoEdge.hpp>
#include <topology/TopoExplorer.hpp>
#include <topology/TopoExplorerTool.hpp>
#include <topology/TopoFace.hpp>
#include <topology/TopoShape.hpp>
#include <topology/TopoShell.hpp>
#include <topology/TopoTool.hpp>
#include <topology/TopoVertex.hpp>
#include <topology/TopoWire.hpp>
#include <topology/WireExplorer.hpp>
#include <topomesh/BRepMeshIncrementalMesh.hpp>
#include <nurbs/NURBSAPIBlend.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
#include <math/LineT.hpp>
#include <hatch/BRepClassificationTools.hpp>
using namespace AMCAX;
namespace
{
	std::shared_ptr<Geom3BSplineCurve> CurveChooser(const int id, const std::shared_ptr<Geom3BSplineCurve>& curve0, const std::shared_ptr<Geom3BSplineCurve>& curve1, const std::shared_ptr<Geom3BSplineCurve>& curve2)
	{
		std::shared_ptr<Geom3BSplineCurve> result;
		switch (id)
		{
		case 0:
		{
			result = curve0;
			break;
		}
		case 1:
		{
			result = curve1;
			break;
		}
		case 2:
		{
			result = curve2;
			break;
		}
		}
		return result;
	}
} 
TEST_CASE("case1:this is a case for ExplicitSweep", "[nurbs][forcase1][Explicit]") {
	GlobalProperty g;
	SECTION("TestExplicitSweepWithTwoGuideCurvesTwoPoints()")
	{
		std::string filedir = INPUT_PATH_PREFIX "/TestNURBS/TestExplicitSweepWithTwoGuideCurvesTwoPoints/";
		auto profile = ReadBRepCurve(filedir + "profile.brep");
		CHECK(OCCTIO::OCCTTool::Write(MakeEdge(profile), OUTPUT_PATH_PREFIX "TestExplicitSweepWithTwoGuideCurvesTwoPoints_profile.brep"));
		auto guide1 = ReadBRepCurve(filedir + "guide1.brep");
		CHECK(OCCTIO::OCCTTool::Write(MakeEdge(guide1), OUTPUT_PATH_PREFIX "TestExplicitSweepWithTwoGuideCurvesTwoPoints_guide1.brep"));
		auto guide2 = ReadBRepCurve(filedir + "guide2.brep");
		CHECK(OCCTIO::OCCTTool::Write(MakeEdge(guide2), OUTPUT_PATH_PREFIX "TestExplicitSweepWithTwoGuideCurvesTwoPoints_guide2.brep"));
		auto anchorPoint1 = ReadBRepPoint(filedir + "point1.brep");
		auto anchorPoint2 = ReadBRepPoint(filedir + "point2.brep");
		CHECK(OCCTIO::OCCTTool::Write(MakeVertex(anchorPoint1), OUTPUT_PATH_PREFIX "TestExplicitSweepWithTwoGuideCurvesTwoPoints_point1.brep"));
		CHECK(OCCTIO::OCCTTool::Write(MakeVertex(anchorPoint2), OUTPUT_PATH_PREFIX "TestExplicitSweepWithTwoGuideCurvesTwoPoints_point2.brep"));
		auto [status, surface] = NURBSAPIExplicitSweep::SweepWithTwoGuideCurves(profile, guide1, guide2, anchorPoint1, anchorPoint2, guide1, guide1->FirstParameter(), guide1->LastParameter());
		CHECK(status == NURBSSweepStatus::Success);
		if (status == NURBSSweepStatus::Success)
		{
			CHECK(OCCTIO::OCCTTool::Write(MakeFace(surface, 0.0), OUTPUT_PATH_PREFIX "TestExplicitSweepWithTwoGuideCurvesTwoPoints_result.brep"));
			AMCAX::BRepExtremaDistShapeShape len1(MakeFace(surface, 0.0), MakeEdge(guide1));
			AMCAX::BRepExtremaDistShapeShape len2(MakeFace(surface, 0.0), MakeEdge(guide2));
			AMCAX::BRepExtremaDistShapeShape len3(MakeFace(surface, 0.0), MakeEdge(profile));
			CHECK(len1.Value() == Approx(0.0).margin(0.1));
			CHECK(len2.Value() == Approx(0.0).margin(0.1));
			CHECK(len3.Value() == Approx(0.0).margin(0.1));
		}
		profile->IncreaseDegree(11);
		guide1->IncreaseDegree(11);
		guide2->IncreaseDegree(11);
		auto [status1, surface1] = NURBSAPIExplicitSweep::SweepWithTwoGuideCurves(profile, guide1, guide2, anchorPoint1, anchorPoint2, guide1, guide1->FirstParameter(), guide1->LastParameter());
		CHECK(status1 == NURBSSweepStatus::Success);
		if (status1 == NURBSSweepStatus::Success)
		{
			CHECK(OCCTIO::OCCTTool::Write(MakeFace(surface1, 0.0), OUTPUT_PATH_PREFIX "TestExplicitSweepWithTwoGuideCurvesTwoPoints_degree11result.brep"));
			AMCAX::BRepExtremaDistShapeShape len1(MakeFace(surface1, 0.0), MakeEdge(guide1));
			AMCAX::BRepExtremaDistShapeShape len2(MakeFace(surface1, 0.0), MakeEdge(guide2));
			AMCAX::BRepExtremaDistShapeShape len3(MakeFace(surface1, 0.0), MakeEdge(profile));
			CHECK(len1.Value() == Approx(0.0).margin(0.1));
			CHECK(len2.Value() == Approx(0.0).margin(0.1));
			CHECK(len3.Value() == Approx(0.0).margin(0.1));
			double bsp3s = GetSurfaceProperties(MakeFace(surface1, 0.0), g, true, true);
			double bsp4s = GetSurfaceProperties(MakeFace(surface, 0.0), g, true, true);
			CHECK(bsp3s == Approx(bsp4s).margin(0.04));
		}
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static std::pair<NURBSSweepStatus, std::shared_ptr<Geom3BSplineSurface>> SweepWithTwoGuideCurves( const std::shared_ptr<Geom3BSplineCurve>& profile, const std::shared_ptr<Geom3BSplineCurve>& guide1, const std::shared_ptr<Geom3BSplineCurve>& guide2, Point3 anchorPoint, const Direction3& anchorDirection, const std::shared_ptr<Geom3BSplineCurve>& spine, double spineLeftBound, double spineRightBound),
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <filesystem>
#include <fstream>
#include <random>
#include <sstream>
#include <nurbs/NURBSAPIGetGeometry.hpp>
#include <nurbs/NURBSAPIConicalSweep.hpp>
#include <boolean/BoolBRepCut.hpp>
#include <common/CartesianCoordinateSystem.hpp>
#include <common/IndexMap.hpp>
#include <common/QuaternionT.hpp>
#include <geomAlgo/LawBSpline.hpp>
#include <geomAlgo/LawConstant.hpp>
#include <nurbs/NURBSAPISmooth.hpp>
#include <geomAlgo/MakeConic2FromConstraints.hpp>
#include <geometry/Adaptor3CurveOnSurface.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/AdaptorGeom3Surface.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/Geom2Circle.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/Geom2Hyperbola.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom3BSplineCurve.hpp>
#include <geometry/Geom3BSplineSurface.hpp>
#include <geometry/Geom3Circle.hpp>
#include <geometry/Geom3Line.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
#include <geometry/Geom3Plane.hpp>
#include <geometry/Geom3SphericalSurface.hpp>
#include <geometry/Geom3Surface.hpp>
#include <geometry/Geom3TrimmedCurve.hpp>
#include <geometry/Geom3TrimmedSurface.hpp>
#include <geometry/GeomAPIExtremaCurveCurve3.hpp>
#include <geometry/GeomAPIProjectPointOnCurve2.hpp>
#include <geometry/GeomAPIProjectPointOnCurve3.hpp>
#include <geometry/GeomAPIProjectPointOnSurface.hpp>
#include <geometry/GeometryTool.hpp>
#include <geometry/GlobalProperty.hpp>
#include <healing/ShapeFixTool.hpp>
#include <io/STLTool.hpp>
#include <math/Sphere.hpp>
#include <math/TriangularMesh.hpp>
#include <modeling/CopyShape.hpp>
#include <modeling/MakeBox.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeFace.hpp>
#include <modeling/MakePrism.hpp>
#include <modeling/MakeRevol.hpp>
#include <modeling/MakeShapeTool.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeWire.hpp>
#include <modeling/TransformShape.hpp>
#include <nurbs/NURBSAPIApprox.hpp>
#include <nurbs/NURBSAPIBuildCurve.hpp>
#include <nurbs/NURBSAPICircularSweep.hpp>
#include <nurbs/NURBSAPIConvert.hpp>
#include <nurbs/NURBSAPICurveNetworkSurface.hpp>
#include <nurbs/NURBSAPIExplicitSweep.hpp>
#include <nurbs/NURBSAPIExplode.hpp>
#include <nurbs/NURBSAPIExtend.hpp>
#include <nurbs/NURBSAPIInterpolate.hpp>
#include <nurbs/NURBSAPIJoin.hpp>
#include <nurbs/NURBSAPILinearSweep.hpp>
#include <nurbs/NURBSAPILoft.hpp>
#include <nurbs/NURBSAPIMakeNURBSFromBoundaries.hpp>
#include <nurbs/NURBSAPIMatch.hpp>
#include <nurbs/NURBSAPIModifyEndToPlane.hpp>
#include <nurbs/NURBSAPIOffsetCurveOnSurface.hpp>
#include <nurbs/NURBSAPIProject.hpp>
#include <nurbs/NURBSAPIRebuild.hpp>
#include <nurbs/NURBSAPIReplaceEdge.hpp>
#include <nurbs/NURBSAPISweep.hpp>
#include <nurbs/NURBSAPISweep2.hpp>
#include <nurbs/NURBSAPISweepRotation.hpp>
#include <nurbs/NURBSAPITrim.hpp>
#include <nurbs/NURBSAPIUntrim.hpp>
#include <nurbs/NURBSLinearSweepWithDraftDirectionLength.hpp>
#include <occtio/OCCTTool.hpp>
#include <offset/MakePipe.hpp>
#include <offset/MakePipeShell.hpp>
#include <topology/BRepAdaptorCurve2.hpp>
#include <topology/BRepAdaptorCurve3.hpp>
#include <topology/BRepAdaptorSurface.hpp>
#include <topology/BRepGlobalProperty.hpp>
#include <topology/BRepTool.hpp>
#include <topology/TopoBuilder.hpp>
#include <topology/TopoCompound.hpp>
#include <topology/TopoEdge.hpp>
#include <topology/TopoExplorer.hpp>
#include <topology/TopoExplorerTool.hpp>
#include <topology/TopoFace.hpp>
#include <topology/TopoShape.hpp>
#include <topology/TopoShell.hpp>
#include <topology/TopoTool.hpp>
#include <topology/TopoVertex.hpp>
#include <topology/TopoWire.hpp>
#include <topology/WireExplorer.hpp>
#include <topomesh/BRepMeshIncrementalMesh.hpp>
#include <nurbs/NURBSAPIBlend.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
#include <math/LineT.hpp>
#include <hatch/BRepClassificationTools.hpp>
using namespace AMCAX;
namespace
{
	std::shared_ptr<Geom3BSplineCurve> CurveChooser(const int id, const std::shared_ptr<Geom3BSplineCurve>& curve0, const std::shared_ptr<Geom3BSplineCurve>& curve1, const std::shared_ptr<Geom3BSplineCurve>& curve2)
	{
		std::shared_ptr<Geom3BSplineCurve> result;
		switch (id)
		{
		case 0:
		{
			result = curve0;
			break;
		}
		case 1:
		{
			result = curve1;
			break;
		}
		case 2:
		{
			result = curve2;
			break;
		}
		}
		return result;
	}
} 
TEST_CASE("case1:this is a case for ExplicitSweep", "[nurbs][forcase1][Explicit]") {
	GlobalProperty g;
	SECTION("TestExplicitSweepWithTwoGuideCurvesTwoPoints()")
	{
		std::string filedir = INPUT_PATH_PREFIX "/TestNURBS/TestExplicitSweepWithTwoGuideCurvesTwoPoints/";
		auto profile = ReadBRepCurve(filedir + "profile.brep");
		CHECK(OCCTIO::OCCTTool::Write(MakeEdge(profile), OUTPUT_PATH_PREFIX "TestExplicitSweepWithTwoGuideCurvesTwoPoints_profile.brep"));
		auto guide1 = ReadBRepCurve(filedir + "guide1.brep");
		CHECK(OCCTIO::OCCTTool::Write(MakeEdge(guide1), OUTPUT_PATH_PREFIX "TestExplicitSweepWithTwoGuideCurvesTwoPoints_guide1.brep"));
		auto guide2 = ReadBRepCurve(filedir + "guide2.brep");
		CHECK(OCCTIO::OCCTTool::Write(MakeEdge(guide2), OUTPUT_PATH_PREFIX "TestExplicitSweepWithTwoGuideCurvesTwoPoints_guide2.brep"));
		auto anchorPoint1 = ReadBRepPoint(filedir + "point1.brep");
		auto anchorPoint2 = ReadBRepPoint(filedir + "point2.brep");
		CHECK(OCCTIO::OCCTTool::Write(MakeVertex(anchorPoint1), OUTPUT_PATH_PREFIX "TestExplicitSweepWithTwoGuideCurvesTwoPoints_point1.brep"));
		CHECK(OCCTIO::OCCTTool::Write(MakeVertex(anchorPoint2), OUTPUT_PATH_PREFIX "TestExplicitSweepWithTwoGuideCurvesTwoPoints_point2.brep"));
		auto [status, surface] = NURBSAPIExplicitSweep::SweepWithTwoGuideCurves(profile, guide1, guide2, anchorPoint1, anchorPoint2, guide1, guide1->FirstParameter(), guide1->LastParameter());
		CHECK(status == NURBSSweepStatus::Success);
		if (status == NURBSSweepStatus::Success)
		{
			CHECK(OCCTIO::OCCTTool::Write(MakeFace(surface, 0.0), OUTPUT_PATH_PREFIX "TestExplicitSweepWithTwoGuideCurvesTwoPoints_result.brep"));
			AMCAX::BRepExtremaDistShapeShape len1(MakeFace(surface, 0.0), MakeEdge(guide1));
			AMCAX::BRepExtremaDistShapeShape len2(MakeFace(surface, 0.0), MakeEdge(guide2));
			AMCAX::BRepExtremaDistShapeShape len3(MakeFace(surface, 0.0), MakeEdge(profile));
			CHECK(len1.Value() == Approx(0.0).margin(0.1));
			CHECK(len2.Value() == Approx(0.0).margin(0.1));
			CHECK(len3.Value() == Approx(0.0).margin(0.1));
		}
		profile->IncreaseDegree(11);
		guide1->IncreaseDegree(11);
		guide2->IncreaseDegree(11);
		auto [status1, surface1] = NURBSAPIExplicitSweep::SweepWithTwoGuideCurves(profile, guide1, guide2, anchorPoint1, anchorPoint2, guide1, guide1->FirstParameter(), guide1->LastParameter());
		CHECK(status1 == NURBSSweepStatus::Success);
		if (status1 == NURBSSweepStatus::Success)
		{
			CHECK(OCCTIO::OCCTTool::Write(MakeFace(surface1, 0.0), OUTPUT_PATH_PREFIX "TestExplicitSweepWithTwoGuideCurvesTwoPoints_degree11result.brep"));
			AMCAX::BRepExtremaDistShapeShape len1(MakeFace(surface1, 0.0), MakeEdge(guide1));
			AMCAX::BRepExtremaDistShapeShape len2(MakeFace(surface1, 0.0), MakeEdge(guide2));
			AMCAX::BRepExtremaDistShapeShape len3(MakeFace(surface1, 0.0), MakeEdge(profile));
			CHECK(len1.Value() == Approx(0.0).margin(0.1));
			CHECK(len2.Value() == Approx(0.0).margin(0.1));
			CHECK(len3.Value() == Approx(0.0).margin(0.1));
			double bsp3s = GetSurfaceProperties(MakeFace(surface1, 0.0), g, true, true);
			double bsp4s = GetSurfaceProperties(MakeFace(surface, 0.0), g, true, true);
			CHECK(bsp3s == Approx(bsp4s).margin(0.04));
		}
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static std::pair<NURBSSweepStatus, std::vector<std::shared_ptr<Geom3BSplineSurface>>> SweepWithPullingDirection( const std::shared_ptr<Geom3BSplineCurve>& profile, const std::shared_ptr<Geom3BSplineCurve>& guide, const Direction3& direction, const LawFunction& angleLawFunc, const std::shared_ptr<Geom3BSplineCurve>& spine, double spineLeftBound, double spineRightBound),
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <filesystem>
#include <fstream>
#include <random>
#include <sstream>
#include <nurbs/NURBSAPIGetGeometry.hpp>
#include <nurbs/NURBSAPIConicalSweep.hpp>
#include <boolean/BoolBRepCut.hpp>
#include <common/CartesianCoordinateSystem.hpp>
#include <common/IndexMap.hpp>
#include <common/QuaternionT.hpp>
#include <geomAlgo/LawBSpline.hpp>
#include <geomAlgo/LawConstant.hpp>
#include <nurbs/NURBSAPISmooth.hpp>
#include <geomAlgo/MakeConic2FromConstraints.hpp>
#include <geometry/Adaptor3CurveOnSurface.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/AdaptorGeom3Surface.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/Geom2Circle.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/Geom2Hyperbola.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom3BSplineCurve.hpp>
#include <geometry/Geom3BSplineSurface.hpp>
#include <geometry/Geom3Circle.hpp>
#include <geometry/Geom3Line.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
#include <geometry/Geom3Plane.hpp>
#include <geometry/Geom3SphericalSurface.hpp>
#include <geometry/Geom3Surface.hpp>
#include <geometry/Geom3TrimmedCurve.hpp>
#include <geometry/Geom3TrimmedSurface.hpp>
#include <geometry/GeomAPIExtremaCurveCurve3.hpp>
#include <geometry/GeomAPIProjectPointOnCurve2.hpp>
#include <geometry/GeomAPIProjectPointOnCurve3.hpp>
#include <geometry/GeomAPIProjectPointOnSurface.hpp>
#include <geometry/GeometryTool.hpp>
#include <geometry/GlobalProperty.hpp>
#include <healing/ShapeFixTool.hpp>
#include <io/STLTool.hpp>
#include <math/Sphere.hpp>
#include <math/TriangularMesh.hpp>
#include <modeling/CopyShape.hpp>
#include <modeling/MakeBox.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeFace.hpp>
#include <modeling/MakePrism.hpp>
#include <modeling/MakeRevol.hpp>
#include <modeling/MakeShapeTool.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeWire.hpp>
#include <modeling/TransformShape.hpp>
#include <nurbs/NURBSAPIApprox.hpp>
#include <nurbs/NURBSAPIBuildCurve.hpp>
#include <nurbs/NURBSAPICircularSweep.hpp>
#include <nurbs/NURBSAPIConvert.hpp>
#include <nurbs/NURBSAPICurveNetworkSurface.hpp>
#include <nurbs/NURBSAPIExplicitSweep.hpp>
#include <nurbs/NURBSAPIExplode.hpp>
#include <nurbs/NURBSAPIExtend.hpp>
#include <nurbs/NURBSAPIInterpolate.hpp>
#include <nurbs/NURBSAPIJoin.hpp>
#include <nurbs/NURBSAPILinearSweep.hpp>
#include <nurbs/NURBSAPILoft.hpp>
#include <nurbs/NURBSAPIMakeNURBSFromBoundaries.hpp>
#include <nurbs/NURBSAPIMatch.hpp>
#include <nurbs/NURBSAPIModifyEndToPlane.hpp>
#include <nurbs/NURBSAPIOffsetCurveOnSurface.hpp>
#include <nurbs/NURBSAPIProject.hpp>
#include <nurbs/NURBSAPIRebuild.hpp>
#include <nurbs/NURBSAPIReplaceEdge.hpp>
#include <nurbs/NURBSAPISweep.hpp>
#include <nurbs/NURBSAPISweep2.hpp>
#include <nurbs/NURBSAPISweepRotation.hpp>
#include <nurbs/NURBSAPITrim.hpp>
#include <nurbs/NURBSAPIUntrim.hpp>
#include <nurbs/NURBSLinearSweepWithDraftDirectionLength.hpp>
#include <occtio/OCCTTool.hpp>
#include <offset/MakePipe.hpp>
#include <offset/MakePipeShell.hpp>
#include <topology/BRepAdaptorCurve2.hpp>
#include <topology/BRepAdaptorCurve3.hpp>
#include <topology/BRepAdaptorSurface.hpp>
#include <topology/BRepGlobalProperty.hpp>
#include <topology/BRepTool.hpp>
#include <topology/TopoBuilder.hpp>
#include <topology/TopoCompound.hpp>
#include <topology/TopoEdge.hpp>
#include <topology/TopoExplorer.hpp>
#include <topology/TopoExplorerTool.hpp>
#include <topology/TopoFace.hpp>
#include <topology/TopoShape.hpp>
#include <topology/TopoShell.hpp>
#include <topology/TopoTool.hpp>
#include <topology/TopoVertex.hpp>
#include <topology/TopoWire.hpp>
#include <topology/WireExplorer.hpp>
#include <topomesh/BRepMeshIncrementalMesh.hpp>
#include <nurbs/NURBSAPIBlend.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
#include <math/LineT.hpp>
#include <hatch/BRepClassificationTools.hpp>
using namespace AMCAX;
namespace
{
	std::shared_ptr<Geom3BSplineCurve> CurveChooser(const int id, const std::shared_ptr<Geom3BSplineCurve>& curve0, const std::shared_ptr<Geom3BSplineCurve>& curve1, const std::shared_ptr<Geom3BSplineCurve>& curve2)
	{
		std::shared_ptr<Geom3BSplineCurve> result;
		switch (id)
		{
		case 0:
		{
			result = curve0;
			break;
		}
		case 1:
		{
			result = curve1;
			break;
		}
		case 2:
		{
			result = curve2;
			break;
		}
		}
		return result;
	}
} 
TEST_CASE("case1:this is a case for ExplicitSweep", "[nurbs][forcase1][Explicit]") {
	GlobalProperty g;
	SECTION("TestExplicitSweepWithPullingDirection()")
	{
		std::string filedir = INPUT_PATH_PREFIX "/TestNURBS/TestExplicitSweepWithPullingDirection/";
		auto guide = ReadBRepCurve(filedir + "guide.brep");
		CHECK(OCCTIO::OCCTTool::Write(MakeEdge(guide), OUTPUT_PATH_PREFIX "TestExplicitSweepWithPullingDirection_guide.brep"));
		auto profile = ReadBRepCurve(filedir + "profile.brep");
		CHECK(OCCTIO::OCCTTool::Write(MakeEdge(profile), OUTPUT_PATH_PREFIX "TestExplicitSweepWithPullingDirection_profile.brep"));
		auto spineLineEdge = ReadBRepEdge(filedir + "spine.brep");
		double fp, lp;
		auto spineLine = TopoTool::Curve(spineLineEdge, fp, lp);
		auto spine = NURBSAPIConvert::ToBSpline(std::make_shared<Geom3TrimmedCurve>(spineLine, 0, 3));
		CHECK(OCCTIO::OCCTTool::Write(MakeEdge(spine), OUTPUT_PATH_PREFIX "TestExplicitSweepWithPullingDirection_spine.brep"));
		auto pullingDirectionEdge = ReadBRepEdge(filedir + "pullingDirection.brep");
		auto dirCurve = TopoTool::Curve(pullingDirectionEdge, fp, lp);
		Point3 p1, p2;
		Vector3 d1, d2;
		dirCurve->D1(0.0, p1, d1);
		dirCurve->D1(1.0, p2, d2);
		Direction3 pullingDirection(d1);
		LawConstant law;
		law.Set(0.0, 0.0, 1.0);
		auto [status, surfaces] = NURBSAPIExplicitSweep::SweepWithPullingDirection(profile, guide, pullingDirection, law, spine, spine->FirstParameter(), spine->LastParameter());
		CHECK(status == NURBSSweepStatus::Success);
		if (status == NURBSSweepStatus::Success)
		{
			for (int i = 0; i < surfaces.size(); i++)
			{
				CHECK(OCCTIO::OCCTTool::Write(MakeFace(surfaces[i], 0.0), OUTPUT_PATH_PREFIX "TestExplicitSweepWithPullingDirection_result" + std::to_string(i) + ".brep"));
				CHECK(IsCurveOnSurf(1000, 0.3, guide, surfaces[i], 0.1));
				AMCAX::BRepExtremaDistShapeShape len1(MakeFace(surfaces[i], 0.0), MakeEdge(guide));
				AMCAX::BRepExtremaDistShapeShape len2(MakeFace(surfaces[i], 0.0), MakeEdge(profile));
				CHECK(len1.Value() == Approx(0.0).margin(0.1));
				CHECK(len2.Value() == Approx(0.0).margin(0.1));
				if (i < 2) {
					CHECK(IsCurveOnSurf(1000, 0.1, profile, surfaces[i], 0.1));
				}
			}
		}
		profile->IncreaseDegree(5);
		guide->IncreaseDegree(5);
		spine->IncreaseDegree(5);
		auto [status1, surfaces1] = NURBSAPIExplicitSweep::SweepWithPullingDirection(profile, guide, pullingDirection, law, spine, spine->FirstParameter(), spine->LastParameter());
		CHECK(status1 == NURBSSweepStatus::Success);
		if (status1 == NURBSSweepStatus::Success)
		{
			for (int i = 0; i < surfaces1.size(); i++)
			{
				CHECK(OCCTIO::OCCTTool::Write(MakeFace(surfaces1[i], 0.0), OUTPUT_PATH_PREFIX "TestExplicitSweepWithPullingDirection_degree5result" + std::to_string(i) + ".brep"));
				CHECK(IsCurveOnSurf(1000, 0.3, guide, surfaces1[i], 0.1));
				AMCAX::BRepExtremaDistShapeShape len1(MakeFace(surfaces1[i], 0.0), MakeEdge(guide));
				AMCAX::BRepExtremaDistShapeShape len2(MakeFace(surfaces1[i], 0.0), MakeEdge(profile));
				CHECK(len1.Value() == Approx(0.0).margin(0.1));
				CHECK(len2.Value() == Approx(0.0).margin(0.1));
				if (i < 2) {
					CHECK(IsCurveOnSurf(1000, 0.1, profile, surfaces1[i], 0.1));
					double bsp3s = GetSurfaceProperties(MakeFace(surfaces1[i], 0.0), g, true, true);
					double bsp4s = GetSurfaceProperties(MakeFace(surfaces[i], 0.0), g, true, true);
					CHECK(bsp3s == Approx(bsp4s).margin(0.02));
				}
			}
		}
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static std::vector<std::shared_ptr<Geom3BSplineCurve>> ExplodeCurve(const std::shared_ptr<Geom3BSplineCurve>& curve)	 @return The result curves
	 @param curve The given curve
	 @brief Explode a curve into curves at C0 points
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <nurbs/NURBSAPIExplode.hpp>
#include <topology/TopoEdge.hpp>
#include <topology/TopoTool.hpp>
#include <nurbs/NURBSAPIJoin.hpp>
#include <nurbs/NURBSAPIExplode.hpp>
#include <geometry/Geom3BSplineCurve.hpp>
#include <geometry/Geom3BSplineSurface.hpp>
#include <topology/TopoFace.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeFace.hpp>
TEST_CASE("case1: this is a test for Explode-ExplodeCurve", "[nurbs][Explode][P1]")
{
	int num = 1000;
	double sTol = DEFAULT_TOLERANCE;
	double ratio = 0.1;
	double linTol = DEFAULT_TOLERANCE;
    string filename;
	string filedir = INPUT_PATH_PREFIX"./TestNURBS/TestJoinCurve/";
	SECTION("isPeriodic")
	{
		OUTPUT_DIRECTORY(nurbs, Explode/ExplodeCurve1);
		filename = "periodicCurve";
		std::vector<std::shared_ptr<Geom3BSplineCurve>> curves;
		for (int i = 0; i < 3; i++)
		{
			curves.push_back(ReadBRepCurve(filedir + filename + std::to_string(i) + ".brep"));
		}
		auto [sortedCurves, isReverse, isResultPeriodic] = NURBSAPIJoin::JoinCurvePrepare(curves, 0.0001);
		auto results = NURBSAPIJoin::JoinCurves(sortedCurves, isReverse, isResultPeriodic);
		int nresults = static_cast<int>(results.size());
		for (int i = 0; i < nresults; i++)
		{
			OCCTIO::OCCTTool::Write(MakeEdge(results[i]), outdir + "joinCurve" + to_string(i) + ".brep");
		}
		auto explodeResult = NURBSAPIExplode::ExplodeCurve(results.front());
		int expResults = static_cast<int>(explodeResult.size());
		for (int j = 0; j < expResults; j++)
		{
			OCCTIO::OCCTTool::Write(MakeEdge(explodeResult[j]), outdir + "expCurve" + to_string(j) + ".brep");
		}
		CHECK(results.size() == 1);
		CHECK(explodeResult.size() == 3);
		Point3 p1, p2, p3, p4;
		p1 = curves[0]->StartPoint();
		p2 = curves[2]->EndPoint();
		p3 = results[0]->StartPoint();
		p4 = results[0]->EndPoint();
		CHECK(p1.X() == Approx(p3.X()));
		CHECK(p1.Y() == Approx(p3.Y()));
		CHECK(p1.Z() == Approx(p3.Z()));
		CHECK(p2.X() == Approx(p4.X()));
		CHECK(p2.Y() == Approx(p4.Y()));
		CHECK(p2.Z() == Approx(p4.Z()));
		TopoShape c1 = MakeEdge(curves[0]);
		TopoShape c2 = MakeEdge(curves[1]);
		TopoShape c3 = MakeEdge(curves[2]);
		TopoShape c = MakeEdge(results[0]);
		TopoShape e1 = MakeEdge(explodeResult[0]);
		TopoShape e2 = MakeEdge(explodeResult[1]);
		TopoShape e3 = MakeEdge(explodeResult[2]);
		GlobalProperty props1, props2, props3, props4, props5, props6, props7;
		double len1 = GetLinearProperties(c1, props1, true, false);
		double len2 = GetLinearProperties(c2, props2, true, false);
		double len3 = GetLinearProperties(c3, props3, true, false);
		double joinLen = GetLinearProperties(c, props4, true, false);
		double exLen1 = GetLinearProperties(e1, props5, true, false);
		double exLen2 = GetLinearProperties(e2, props6, true, false);
		double exLen3 = GetLinearProperties(e3, props7, true, false);
		double cuvLen = len1 + len2 + len3;
		double len = abs(cuvLen - joinLen);
		double len11 = abs(len1 - exLen1);
		double len22 = abs(len2 - exLen2);
		double len33 = abs(len3 - exLen3);
		CHECK(len < 0.1);
		CHECK(len11 < 0.1);
		CHECK(len22 < 0.1);
		CHECK(len33 < 0.1);
		double res1 = NurbsSampleCurve(num, sTol, curves[0], explodeResult[0]);
		double res2 = NurbsSampleCurve(num, sTol, curves[1], explodeResult[1]);
		double res3 = NurbsSampleCurve(num, sTol, curves[2], explodeResult[2]);
		CHECK(res1 <= ratio);
		CHECK(res2 <= ratio);
		CHECK(res3 <= ratio);
		OCCTIO::OCCTTool::Write(MakeEdge(curves[0]), outdir + "curve0.brep");
		OCCTIO::OCCTTool::Write(MakeEdge(curves[1]), outdir + "curve1.brep");
		OCCTIO::OCCTTool::Write(MakeEdge(curves[2]), outdir + "curve2.brep");
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static Array2<std::shared_ptr<Geom3BSplineSurface>> ExplodeSurface(const std::shared_ptr<Geom3BSplineSurface>& surface)	 @return The result surfaces
	 @param surface The given surface
	 @brief Explode a surface into patches at C0 isocurves
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <nurbs/NURBSAPIExplode.hpp>
#include <topology/TopoEdge.hpp>
#include <topology/TopoTool.hpp>
#include <nurbs/NURBSAPIJoin.hpp>
#include <nurbs/NURBSAPIExplode.hpp>
#include <geometry/Geom3BSplineCurve.hpp>
#include <geometry/Geom3BSplineSurface.hpp>
#include <topology/TopoFace.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeFace.hpp>
TEST_CASE("case1: this is a test for Explode-ExplodeSurface", "[nurbs][Explode][P1]")
{
	int num = 1000;
	double sTol = DEFAULT_TOLERANCE;
	double ratio = 0.1;
	double linTol = DEFAULT_TOLERANCE;
	SECTION("isUPeriodic+nonVPeriodic")
	{
		OUTPUT_DIRECTORY(nurbs, Explode/ExplodeSurface3);
		string filedir = INPUT_PATH_PREFIX"./TestNURBS/TestJoinSurface/";
		std::vector<std::shared_ptr<Geom3BSplineSurface>> surfaces;
		surfaces.push_back(ReadBRepSurface(filedir + "surface0.brep"));
		surfaces.push_back(ReadBRepSurface(filedir + "surface1.brep"));
		surfaces.push_back(ReadBRepSurface(filedir + "surface2.brep"));
		surfaces.push_back(ReadBRepSurface(filedir + "surface3.brep"));
		auto [sortedSurfaces, isUIso, isFrontBackReverse, isIsoReverse, isLocalUPeriodic, isLocalVPeriodic] = NURBSAPIJoin::JoinSurfacesPrepare(surfaces, 0.0001);
		auto [isSucceed, result] = NURBSAPIJoin::JoinSurfaces(sortedSurfaces, isUIso, isFrontBackReverse, isIsoReverse, isLocalUPeriodic, isLocalVPeriodic);
		Throw_Construction_Error_if(!isSucceed, "failed");
		CHECK(isSucceed == true);
		auto explodeResult = NURBSAPIExplode::ExplodeSurface(result);
		int row = explodeResult.NRow();
		int col = explodeResult.NCol();
		for (int i = 0; i < row; i++)
		{
			for (int j = 0; j < col; j++)
			{
				OCCTIO::OCCTTool::Write(MakeFace(explodeResult(i, j), 0.0), outdir +  "expSurface" + to_string(i) + to_string(j) +".brep");
			}
		}
		CHECK(row*col == 4);
		TopoShape f1 = MakeFace(surfaces[0],0.0);
		TopoShape f2 = MakeFace(surfaces[1], 0.0);
		TopoShape f3 = MakeFace(surfaces[2], 0.0);
		TopoShape f4 = MakeFace(surfaces[3], 0.0);
		TopoShape f = MakeFace(result,0.0);
		TopoShape exp1 = MakeFace(explodeResult(0, 0), 0.0);
		TopoShape exp2 = MakeFace(explodeResult(1, 0), 0.0);
		TopoShape exp3 = MakeFace(explodeResult(2, 0), 0.0);
		TopoShape exp4 = MakeFace(explodeResult(3, 0), 0.0);
		GlobalProperty props1, props2, props3, props4, props5, props6, props7, props8;
		double surf1 = GetSurfaceProperties(f1, props1, true, false);
		double surf2 = GetSurfaceProperties(f2, props2, true, false);
		double surf3 = GetSurfaceProperties(f3, props3, true, false);
		double surf4 = GetSurfaceProperties(f4, props4, true, false);
		double surface = GetSurfaceProperties(f, props5, true, false);
		double exSurf1 = GetSurfaceProperties(exp1, props5, true, false);
		double exSurf2 = GetSurfaceProperties(exp2, props6, true, false);
		double exSurf3 = GetSurfaceProperties(exp3, props7, true, false);
		double exSurf4 = GetSurfaceProperties(exp4, props8, true, false);
		double surf = surf1 + surf2 + surf3 + surf4;
		double dif = abs(surface - surf);
		double dif1 = abs(surf1 - exSurf1);
		double dif2 = abs(surf2 - exSurf2);
		double dif3 = abs(surf3 - exSurf3);
		double dif4 = abs(surf4 - exSurf4);
		CHECK(dif1 < 0.1);
		CHECK(dif2 < 0.1);
		CHECK(dif3 < 0.1);
		CHECK(dif4 < 0.1);
		double res1 = NurbsSampleSurface(num, sTol, surfaces[0], explodeResult(0, 0));
		double res2 = NurbsSampleSurface(num, sTol, surfaces[1], explodeResult(1, 0));
		double res3 = NurbsSampleSurface(num, sTol, surfaces[2], explodeResult(2, 0));
		double res4 = NurbsSampleSurface(num, sTol, surfaces[3], explodeResult(3, 0));
		CHECK(res1 <= ratio);
		CHECK(res2 <= ratio);
		CHECK(res3 <= ratio);
		CHECK(res4 <= ratio);
		OCCTIO::OCCTTool::Write(MakeFace(surfaces[0], 0.0), outdir + "surf1.brep");
		OCCTIO::OCCTTool::Write(MakeFace(surfaces[1], 0.0), outdir + "surf2.brep");
		OCCTIO::OCCTTool::Write(MakeFace(surfaces[2], 0.0), outdir + "surf3.brep");
		OCCTIO::OCCTTool::Write(MakeFace(surfaces[3], 0.0), outdir + "surf4.brep");
		OCCTIO::OCCTTool::Write(MakeFace(result, 0.0), outdir + "joinSurface.brep");
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":void SetMajorRadius(double r)	 @param r The new major radius
	 @brief Set the major radius
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <modeling/MakeFace.hpp>
#include <common/AxisT.hpp>
#include <math/HyperbolaT.hpp>
#include <occtio/OCCTTool.hpp>
#include <common/VectorT.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <topology/TopoEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <iostream>
using namespace AMCAX;
using namespace std;
TEST_CASE("case1:this is a case for Hyperbola3", "[math][Hyperbola3][p1]") {
	Point3 point3_fr(0.0, 0.0, 1.0);
	Direction3 dir3_fr(0.0, 0.0, 1.0);
	Frame3 frame3(point3_fr, dir3_fr);
	double major3 = 3.0, minor3 = 4.0;
	Hyperbola3 hyperbola3d_fr(frame3, major3, minor3);
	SECTION("Default()") {
		Hyperbola3 hyperbola3d_de;	
		CHECK(hyperbola3d_de.Location().X() == Approx(0.0));
		CHECK(hyperbola3d_de.Location().Y() == Approx(0.0));
		CHECK(hyperbola3d_de.Location().Z() == Approx(0.0));
		hyperbola3d_de.SetMajorRadius(3.0);
		hyperbola3d_de.SetMinorRadius(4.0);
		CHECK(hyperbola3d_de.MajorRadius() == Approx(3.0));
		CHECK(hyperbola3d_de.MinorRadius() == Approx(4.0));
		CHECK(hyperbola3d_de.Focal() == Approx(10.0));
		CHECK(hyperbola3d_de.Focus1().X() == Approx(5.0));
		CHECK(hyperbola3d_de.Focus1().Y() == Approx(0.0));
		CHECK(hyperbola3d_de.Focus1().Z() == Approx(0.0));
	}}
}
,