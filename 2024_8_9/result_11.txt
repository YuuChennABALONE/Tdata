{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":void SetMajorRadius(double r)	 @param r The new major radius
	 @brief Set the major radius
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <modeling/MakeFace.hpp>
#include <common/AxisT.hpp>
#include <math/HyperbolaT.hpp>
#include <occtio/OCCTTool.hpp>
#include <common/VectorT.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <topology/TopoEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <iostream>
using namespace AMCAX;
using namespace std;
TEST_CASE("case1:this is a case for Hyperbola3", "[math][Hyperbola3][p1]") {
	Point3 point3_fr(0.0, 0.0, 1.0);
	Direction3 dir3_fr(0.0, 0.0, 1.0);
	Frame3 frame3(point3_fr, dir3_fr);
	double major3 = 3.0, minor3 = 4.0;
	Hyperbola3 hyperbola3d_fr(frame3, major3, minor3);
	SECTION("Default()") {
		Hyperbola3 hyperbola3d_de;	
		CHECK(hyperbola3d_de.Location().X() == Approx(0.0));
		CHECK(hyperbola3d_de.Location().Y() == Approx(0.0));
		CHECK(hyperbola3d_de.Location().Z() == Approx(0.0));
		hyperbola3d_de.SetMajorRadius(3.0);
		hyperbola3d_de.SetMinorRadius(4.0);
		CHECK(hyperbola3d_de.MajorRadius() == Approx(3.0));
		CHECK(hyperbola3d_de.MinorRadius() == Approx(4.0));
		CHECK(hyperbola3d_de.Focal() == Approx(10.0));
		CHECK(hyperbola3d_de.Focus1().X() == Approx(5.0));
		CHECK(hyperbola3d_de.Focus1().Y() == Approx(0.0));
		CHECK(hyperbola3d_de.Focus1().Z() == Approx(0.0));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":void SetMinorRadius(double r)	 @param r The new minor radius
	 @brief Set the minor radius
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <modeling/MakeFace.hpp>
#include <common/AxisT.hpp>
#include <math/HyperbolaT.hpp>
#include <occtio/OCCTTool.hpp>
#include <common/VectorT.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <topology/TopoEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <iostream>
using namespace AMCAX;
using namespace std;
TEST_CASE("case1:this is a case for Hyperbola3", "[math][Hyperbola3][p1]") {
	Point3 point3_fr(0.0, 0.0, 1.0);
	Direction3 dir3_fr(0.0, 0.0, 1.0);
	Frame3 frame3(point3_fr, dir3_fr);
	double major3 = 3.0, minor3 = 4.0;
	Hyperbola3 hyperbola3d_fr(frame3, major3, minor3);
	SECTION("SetMinorRadius()") {
		hyperbola3d_fr.SetMinorRadius(3.0);
		CHECK(hyperbola3d_fr.Location().X() == Approx(0.0));
		CHECK(hyperbola3d_fr.Location().Y() == Approx(0.0));
		CHECK(hyperbola3d_fr.MajorRadius() == Approx(3.0));
		CHECK(hyperbola3d_fr.MinorRadius() == Approx(3.0));
		Point3 point1(3.0, 0.0, 1.0);
		MakeEdge edge1(hyperbola3d_fr);
		CHECK(BRepClassificationTools::IsPointInOnEdge(edge1, point1, 0.001) == true);
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] AxisT<double, DIM> Directrix1()	 @return The positive directrix
	 @brief Get the directrix on the positive side of the major axis
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <modeling/MakeFace.hpp>
#include <common/AxisT.hpp>
#include <math/HyperbolaT.hpp>
#include <occtio/OCCTTool.hpp>
#include <common/VectorT.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <topology/TopoEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <iostream>
using namespace AMCAX;
using namespace std;
TEST_CASE("case1:this is a case for Hyperbola3", "[math][Hyperbola3][p1]") {
	Point3 point3_fr(0.0, 0.0, 1.0);
	Direction3 dir3_fr(0.0, 0.0, 1.0);
	Frame3 frame3(point3_fr, dir3_fr);
	double major3 = 3.0, minor3 = 4.0;
	Hyperbola3 hyperbola3d_fr(frame3, major3, minor3);
	SECTION("Directrix1()") {
		Axis3 axis3d_dir = hyperbola3d_fr.Directrix1();
		CHECK(axis3d_dir.Direction().X() == Approx(0.0));
		CHECK(axis3d_dir.Direction().Y() == Approx(1.0));
		CHECK(axis3d_dir.Direction().Z() == Approx(0.0));
		CHECK(axis3d_dir.Location().X() == Approx(9.0 / 5.0));
		CHECK(axis3d_dir.Location().Y() == Approx(0.0));
		CHECK(axis3d_dir.Location().Z() == Approx(1.0));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] AxisT<double, DIM> Directrix2()	 @return The negative directrix
	 @brief Get the directrix on the negative side of the major axis
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <modeling/MakeFace.hpp>
#include <common/AxisT.hpp>
#include <math/HyperbolaT.hpp>
#include <occtio/OCCTTool.hpp>
#include <common/VectorT.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <topology/TopoEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <iostream>
using namespace AMCAX;
using namespace std;
TEST_CASE("case1:this is a case for Hyperbola3", "[math][Hyperbola3][p1]") {
	Point3 point3_fr(0.0, 0.0, 1.0);
	Direction3 dir3_fr(0.0, 0.0, 1.0);
	Frame3 frame3(point3_fr, dir3_fr);
	double major3 = 3.0, minor3 = 4.0;
	Hyperbola3 hyperbola3d_fr(frame3, major3, minor3);
	SECTION("Directrix2()") {
		Axis3 axis3d_dir = hyperbola3d_fr.Directrix2();
		CHECK(axis3d_dir.Direction().X() == Approx(0.0));
		CHECK(axis3d_dir.Direction().Y() == Approx(1.0));
		CHECK(axis3d_dir.Direction().Z() == Approx(0.0));
		CHECK(axis3d_dir.Location().X() == Approx(-9.0 / 5.0));
		CHECK(axis3d_dir.Location().Y() == Approx(0.0));
		CHECK(axis3d_dir.Location().Z() == Approx(1.0));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] PointT<double, DIM> Focus1()	 @return The positive focus
	 @brief Get the focus on the positive side of the major axis
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <modeling/MakeFace.hpp>
#include <common/AxisT.hpp>
#include <math/HyperbolaT.hpp>
#include <occtio/OCCTTool.hpp>
#include <common/VectorT.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <topology/TopoEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <iostream>
using namespace AMCAX;
using namespace std;
TEST_CASE("case1:this is a case for Hyperbola3", "[math][Hyperbola3][p1]") {
	Point3 point3_fr(0.0, 0.0, 1.0);
	Direction3 dir3_fr(0.0, 0.0, 1.0);
	Frame3 frame3(point3_fr, dir3_fr);
	double major3 = 3.0, minor3 = 4.0;
	Hyperbola3 hyperbola3d_fr(frame3, major3, minor3);
	SECTION("Default()") {
		Hyperbola3 hyperbola3d_de;	
		CHECK(hyperbola3d_de.Location().X() == Approx(0.0));
		CHECK(hyperbola3d_de.Location().Y() == Approx(0.0));
		CHECK(hyperbola3d_de.Location().Z() == Approx(0.0));
		hyperbola3d_de.SetMajorRadius(3.0);
		hyperbola3d_de.SetMinorRadius(4.0);
		CHECK(hyperbola3d_de.MajorRadius() == Approx(3.0));
		CHECK(hyperbola3d_de.MinorRadius() == Approx(4.0));
		CHECK(hyperbola3d_de.Focal() == Approx(10.0));
		CHECK(hyperbola3d_de.Focus1().X() == Approx(5.0));
		CHECK(hyperbola3d_de.Focus1().Y() == Approx(0.0));
		CHECK(hyperbola3d_de.Focus1().Z() == Approx(0.0));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] PointT<double, DIM> Focus2()	 @return The negative focus
	 @brief Get the focus on the negative side of the major axis
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <modeling/MakeFace.hpp>
#include <common/AxisT.hpp>
#include <math/HyperbolaT.hpp>
#include <occtio/OCCTTool.hpp>
#include <common/VectorT.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <topology/TopoEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <iostream>
using namespace AMCAX;
using namespace std;
TEST_CASE("case1:this is a case for Hyperbola3", "[math][Hyperbola3][p1]") {
	Point3 point3_fr(0.0, 0.0, 1.0);
	Direction3 dir3_fr(0.0, 0.0, 1.0);
	Frame3 frame3(point3_fr, dir3_fr);
	double major3 = 3.0, minor3 = 4.0;
	Hyperbola3 hyperbola3d_fr(frame3, major3, minor3);
	SECTION("Focus2") {
		Point3 point3d_f1 = hyperbola3d_fr.Focus2();
		CHECK(point3d_f1.X() == Approx(-5.0));
		CHECK(point3d_f1.Y() == Approx(0.0));
		CHECK(point3d_f1.Z() == Approx(1.0));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] double MajorRadius()	 @return The major radius
	 @brief Get the major radius
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <modeling/MakeFace.hpp>
#include <common/AxisT.hpp>
#include <math/HyperbolaT.hpp>
#include <occtio/OCCTTool.hpp>
#include <common/VectorT.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <topology/TopoEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <iostream>
using namespace AMCAX;
using namespace std;
TEST_CASE("case1:this is a case for Hyperbola3", "[math][Hyperbola3][p1]") {
	Point3 point3_fr(0.0, 0.0, 1.0);
	Direction3 dir3_fr(0.0, 0.0, 1.0);
	Frame3 frame3(point3_fr, dir3_fr);
	double major3 = 3.0, minor3 = 4.0;
	Hyperbola3 hyperbola3d_fr(frame3, major3, minor3);
	SECTION("ConjugateBranch1()") {
		Hyperbola3 hyperbola3d_con = hyperbola3d_fr.ConjugateBranch1();
		CHECK(hyperbola3d_con.Location().X() == Approx(0.0));
		CHECK(hyperbola3d_con.Location().Y() == Approx(0.0));
		CHECK(hyperbola3d_con.Location().Z() == Approx(1.0));
		Point3 point1(0.0, 4.0, 1.0);
		Point3 point2(9.0 / 4.0, 5.0, 1.0);
		MakeEdge edge1(hyperbola3d_con);
		CHECK(BRepClassificationTools::IsPointInOnEdge(edge1, point1, 0.001) == true);
		CHECK(BRepClassificationTools::IsPointInOnEdge(edge1, point2, 0.001) == true);
		double major3d_con = hyperbola3d_con.MajorRadius();
		double minor3d_con = hyperbola3d_con.MinorRadius();
		CHECK(major3d_con == Approx(4.0));
		CHECK(minor3d_con == Approx(3.0));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] double MinorRadius()	 @return The minor radius
	 @brief Get the minor radius
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <modeling/MakeFace.hpp>
#include <common/AxisT.hpp>
#include <math/HyperbolaT.hpp>
#include <occtio/OCCTTool.hpp>
#include <common/VectorT.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <topology/TopoEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <iostream>
using namespace AMCAX;
using namespace std;
TEST_CASE("case1:this is a case for Hyperbola3", "[math][Hyperbola3][p1]") {
	Point3 point3_fr(0.0, 0.0, 1.0);
	Direction3 dir3_fr(0.0, 0.0, 1.0);
	Frame3 frame3(point3_fr, dir3_fr);
	double major3 = 3.0, minor3 = 4.0;
	Hyperbola3 hyperbola3d_fr(frame3, major3, minor3);
	SECTION("ConjugateBranch2()") {		
		Hyperbola3 hyperbola3d_con = hyperbola3d_fr.ConjugateBranch2();
		CHECK(hyperbola3d_con.Location().X() == Approx(0.0));
		CHECK(hyperbola3d_con.Location().Y() == Approx(0.0));
		CHECK(hyperbola3d_con.Location().Z() == Approx(1.0));
		Point3 point1(0.0, -4.0, 1.0);
		Point3 point2(9.0 / 4.0, -5.0, 1.0);
		MakeEdge edge2(hyperbola3d_con);
		CHECK(BRepClassificationTools::IsPointInOnEdge(edge2, point1, 0.001) == true);
		CHECK(BRepClassificationTools::IsPointInOnEdge(edge2, point2, 0.001) == true);
		double major3d_con = hyperbola3d_con.MajorRadius();
		double minor3d_con = hyperbola3d_con.MinorRadius();
		CHECK(major3d_con == Approx(4.0));
		CHECK(minor3d_con == Approx(3.0));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] AxisT<double, DIM> Asymptote1()	 @return The positive asymptote
	 @brief Get the asymptote of the hyperbola with positive slope
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <modeling/MakeFace.hpp>
#include <common/AxisT.hpp>
#include <math/HyperbolaT.hpp>
#include <occtio/OCCTTool.hpp>
#include <common/VectorT.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <topology/TopoEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <iostream>
using namespace AMCAX;
using namespace std;
TEST_CASE("case1:this is a case for Hyperbola3", "[math][Hyperbola3][p1]") {
	Point3 point3_fr(0.0, 0.0, 1.0);
	Direction3 dir3_fr(0.0, 0.0, 1.0);
	Frame3 frame3(point3_fr, dir3_fr);
	double major3 = 3.0, minor3 = 4.0;
	Hyperbola3 hyperbola3d_fr(frame3, major3, minor3);
	SECTION("Asymptote1()") {
		Axis3 axis3d_asy = hyperbola3d_fr.Asymptote1();
		CHECK(axis3d_asy.Direction().X() / axis3d_asy.Direction().Y() == Approx(3.0 / 4.0));
		CHECK(axis3d_asy.Direction().Z() == Approx(0.0));
		Point3 point1(0.0, 0.0, 1.0);
		Line3 line3d_asy(axis3d_asy);
		MakeEdge edge1(line3d_asy);
		CHECK(BRepClassificationTools::IsPointInOnEdge(edge1, point1, 0.001) == true);
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] AxisT<double, DIM> Asymptote2()	 @return The negative asymptote
	 @brief Get the asymptote of the hyperbola with negative slope
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <modeling/MakeFace.hpp>
#include <common/AxisT.hpp>
#include <math/HyperbolaT.hpp>
#include <occtio/OCCTTool.hpp>
#include <common/VectorT.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <topology/TopoEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <iostream>
using namespace AMCAX;
using namespace std;
TEST_CASE("case1:this is a case for Hyperbola3", "[math][Hyperbola3][p1]") {
	Point3 point3_fr(0.0, 0.0, 1.0);
	Direction3 dir3_fr(0.0, 0.0, 1.0);
	Frame3 frame3(point3_fr, dir3_fr);
	double major3 = 3.0, minor3 = 4.0;
	Hyperbola3 hyperbola3d_fr(frame3, major3, minor3);
	SECTION("Asymptote2()") {
		Axis3 axis3d_asy = hyperbola3d_fr.Asymptote2();
		CHECK(axis3d_asy.Direction().X() / axis3d_asy.Direction().Y() == Approx(-3.0 / 4.0));
		CHECK(axis3d_asy.Direction().Z() == Approx(0.0));
		Point3 point1(0.0, 0.0, 1.0);
		Line3 line3d_asy(axis3d_asy);
		MakeEdge edge1(line3d_asy);
		CHECK(BRepClassificationTools::IsPointInOnEdge(edge1, point1, 0.001) == true);
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] HyperbolaS ConjugateBranch1()	 @return The positive conjugate hyperbola
	 @brief Get the conjugate hyperbola on the positive side of the minor axis
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <modeling/MakeFace.hpp>
#include <common/AxisT.hpp>
#include <math/HyperbolaT.hpp>
#include <occtio/OCCTTool.hpp>
#include <common/VectorT.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <topology/TopoEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <iostream>
using namespace AMCAX;
using namespace std;
TEST_CASE("case1:this is a case for Hyperbola3", "[math][Hyperbola3][p1]") {
	Point3 point3_fr(0.0, 0.0, 1.0);
	Direction3 dir3_fr(0.0, 0.0, 1.0);
	Frame3 frame3(point3_fr, dir3_fr);
	double major3 = 3.0, minor3 = 4.0;
	Hyperbola3 hyperbola3d_fr(frame3, major3, minor3);
	SECTION("ConjugateBranch1()") {
		Hyperbola3 hyperbola3d_con = hyperbola3d_fr.ConjugateBranch1();
		CHECK(hyperbola3d_con.Location().X() == Approx(0.0));
		CHECK(hyperbola3d_con.Location().Y() == Approx(0.0));
		CHECK(hyperbola3d_con.Location().Z() == Approx(1.0));
		Point3 point1(0.0, 4.0, 1.0);
		Point3 point2(9.0 / 4.0, 5.0, 1.0);
		MakeEdge edge1(hyperbola3d_con);
		CHECK(BRepClassificationTools::IsPointInOnEdge(edge1, point1, 0.001) == true);
		CHECK(BRepClassificationTools::IsPointInOnEdge(edge1, point2, 0.001) == true);
		double major3d_con = hyperbola3d_con.MajorRadius();
		double minor3d_con = hyperbola3d_con.MinorRadius();
		CHECK(major3d_con == Approx(4.0));
		CHECK(minor3d_con == Approx(3.0));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] HyperbolaS ConjugateBranch2()	 @return The negative conjugate hyperbola
	 @brief Get the conjugate hyperbola on the negative side of the minor axis
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <modeling/MakeFace.hpp>
#include <common/AxisT.hpp>
#include <math/HyperbolaT.hpp>
#include <occtio/OCCTTool.hpp>
#include <common/VectorT.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <topology/TopoEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <iostream>
using namespace AMCAX;
using namespace std;
TEST_CASE("case1:this is a case for Hyperbola3", "[math][Hyperbola3][p1]") {
	Point3 point3_fr(0.0, 0.0, 1.0);
	Direction3 dir3_fr(0.0, 0.0, 1.0);
	Frame3 frame3(point3_fr, dir3_fr);
	double major3 = 3.0, minor3 = 4.0;
	Hyperbola3 hyperbola3d_fr(frame3, major3, minor3);
	SECTION("ConjugateBranch2()") {		
		Hyperbola3 hyperbola3d_con = hyperbola3d_fr.ConjugateBranch2();
		CHECK(hyperbola3d_con.Location().X() == Approx(0.0));
		CHECK(hyperbola3d_con.Location().Y() == Approx(0.0));
		CHECK(hyperbola3d_con.Location().Z() == Approx(1.0));
		Point3 point1(0.0, -4.0, 1.0);
		Point3 point2(9.0 / 4.0, -5.0, 1.0);
		MakeEdge edge2(hyperbola3d_con);
		CHECK(BRepClassificationTools::IsPointInOnEdge(edge2, point1, 0.001) == true);
		CHECK(BRepClassificationTools::IsPointInOnEdge(edge2, point2, 0.001) == true);
		double major3d_con = hyperbola3d_con.MajorRadius();
		double minor3d_con = hyperbola3d_con.MinorRadius();
		CHECK(major3d_con == Approx(4.0));
		CHECK(minor3d_con == Approx(3.0));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":HyperbolaS& Scale(const PointT<double, DIM>& point, double scale)	 @return The reference to self
	 @param scale The scale value
	 @param point The scaling center point
	 @brief Scale the hyperbola by a center point
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <modeling/MakeFace.hpp>
#include <common/AxisT.hpp>
#include <math/HyperbolaT.hpp>
#include <occtio/OCCTTool.hpp>
#include <common/VectorT.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <topology/TopoEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <iostream>
using namespace AMCAX;
using namespace std;
TEST_CASE("case1:this is a case for Hyperbola3", "[math][Hyperbola3][p1]") {
	Point3 point3_fr(0.0, 0.0, 1.0);
	Direction3 dir3_fr(0.0, 0.0, 1.0);
	Frame3 frame3(point3_fr, dir3_fr);
	double major3 = 3.0, minor3 = 4.0;
	Hyperbola3 hyperbola3d_fr(frame3, major3, minor3);
	SECTION("Scale()") {		
		Point3 point1(0.0, 0.0, 1.0);
		hyperbola3d_fr.Scale(point1, 0.5);
		CHECK(hyperbola3d_fr.Location().X() == Approx(0.0));
		CHECK(hyperbola3d_fr.Location().Y() == Approx(0.0));
		CHECK(hyperbola3d_fr.Location().Z() == Approx(1.0));
		Point3 point2(1.5, 0.0, 1.0);
		MakeEdge edge1(hyperbola3d_fr);
		CHECK(BRepClassificationTools::IsPointInOnEdge(edge1, point2, 0.001) == true);
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAXMeshing_API void setTriMeshAsOutput(iPoints    &points, iTriangles &triangles),
 "output":#include<catch.hpp>
#include<testHelperBase.h>
#define AMCAXMeshing_Enable_CommonTraits
#define AMCAXMeshing_Disable_StandardTraits
#define AMCAXMeshing_Enable_EigenTraits
#include "mesh/io/OBJReader.hpp"
#include "mesh/io/OBJWriter.hpp"
#include "mesh/io/STLReader.hpp"
#include "mesh/io/STLWriter.hpp"
#include "meshModeling/MeshBoolean.hpp"
#include "meshModeling/TriMeshRepair.hpp"
#include "meshModeling/MeshParameterization.hpp"
using EIAC = AMCAX::Meshing::Geometry::EIAC;
using TriSoupTraits = AMCAX::Meshing::Mesh::TriSoupTraits_Coord;
using Points = typename TriSoupTraits::Points;
using Triangles = typename TriSoupTraits::Triangles;
using OBJReader = AMCAX::Meshing::Mesh::OBJReader<TriSoupTraits>;
using OBJWriter = AMCAX::Meshing::Mesh::OBJWriter<TriSoupTraits>;
using STLReader = AMCAX::Meshing::Mesh::STLReader<TriSoupTraits>;
using STLWriter = AMCAX::Meshing::Mesh::STLWriter<TriSoupTraits>;
using IOOptions = AMCAX::Meshing::Mesh::IOOptions;
using MeshBoolean = AMCAX::Meshing::Boolean::MeshBoolean<EIAC, TriSoupTraits>;
void read_mesh11(const std::string& filename, Points& points,Triangles& triangles, IOOptions& io_options)
{
	if (AMCAX::Meshing::ends_with(filename, ".obj"))
	{
		OBJReader reader;
		reader.read(filename, io_options);
		points = std::move(reader.m_points);
		triangles = std::move(reader.m_triangles);
	}
	else if (AMCAX::Meshing::ends_with(filename, ".stl"))
	{
		STLReader reader;
		reader.read(filename, io_options);
		points = std::move(reader.m_points);
		triangles = std::move(reader.m_triangles);
	}
}
void write_mesh11(const std::string& filename, const Points& points,const Triangles& triangles, IOOptions& io_options)
{
	OBJWriter writer;
	writer.m_points = std::move(points);
	writer.m_triangles = std::move(triangles);
	bool bWriteObj = writer.write(filename, io_options, 10);
	CHECK(bWriteObj == true);
};
TEST_CASE("case1: MeshBoolean_MeshBoolean  ", "[meshModeling][MeshBoolean][P1]")
{
	OUTPUT_DIRECTORY(Boolean, Boolean);
	IOOptions io_options;
	io_options.vertex_has_point = true;
	Points    points1, points2, result_points;
	Triangles triangles1, triangles2, result_triangles;
	read_mesh11(INPUT_PATH_PREFIX"./meshModeling_data/MeshBoolean_data/bunny25k.obj", points1, triangles1, io_options);
	read_mesh11(INPUT_PATH_PREFIX"./meshModeling_data/MeshBoolean_data/cow.obj", points2, triangles2, io_options);
	MeshBoolean boolean( true);
	boolean.addTriMeshAsInput(points1, triangles1);
	boolean.addTriMeshAsInput(points2, triangles2);
	boolean.setTriMeshAsOutput(result_points, result_triangles);
	boolean.computeLabels();
	{
		boolean.Union();
		make_file_writable(outdir + "AMCAXMeshing_Union.obj");
		write_mesh11(outdir + "AMCAXMeshing_Union.obj", result_points,
			result_triangles, io_options);
	}
	{
		boolean.Intersection();
		make_file_writable(outdir + "AMCAXMeshing_Intersection.obj");
		write_mesh11(outdir + "AMCAXMeshing_Intersection.obj", result_points,
			result_triangles, io_options);
	}
	{
		boolean.Xor();
		make_file_writable(outdir + "AMCAXMeshing_Xor.obj");
		write_mesh11(outdir + "AMCAXMeshing_Xor.obj", result_points, result_triangles,
			io_options);
	}
	{
		boolean.Subtraction();
		make_file_writable(outdir + "AMCAXMeshing_Subtraction.obj");
		write_mesh11(outdir + "AMCAXMeshing_Subtraction.obj", result_points,
			result_triangles, io_options);
	}
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAXMeshing_API void Union()	 @brief apply (3)UNION and (4)put result to output mesh.
,
 "output":#include<catch.hpp>
#include<testHelperBase.h>
#define AMCAXMeshing_Enable_CommonTraits
#define AMCAXMeshing_Disable_StandardTraits
#define AMCAXMeshing_Enable_EigenTraits
#include "mesh/io/OBJReader.hpp"
#include "mesh/io/OBJWriter.hpp"
#include "mesh/io/STLReader.hpp"
#include "mesh/io/STLWriter.hpp"
#include "meshModeling/MeshBoolean.hpp"
#include "meshModeling/TriMeshRepair.hpp"
#include "meshModeling/MeshParameterization.hpp"
using EIAC = AMCAX::Meshing::Geometry::EIAC;
using TriSoupTraits = AMCAX::Meshing::Mesh::TriSoupTraits_Coord;
using Points = typename TriSoupTraits::Points;
using Triangles = typename TriSoupTraits::Triangles;
using OBJReader = AMCAX::Meshing::Mesh::OBJReader<TriSoupTraits>;
using OBJWriter = AMCAX::Meshing::Mesh::OBJWriter<TriSoupTraits>;
using STLReader = AMCAX::Meshing::Mesh::STLReader<TriSoupTraits>;
using STLWriter = AMCAX::Meshing::Mesh::STLWriter<TriSoupTraits>;
using IOOptions = AMCAX::Meshing::Mesh::IOOptions;
using MeshBoolean = AMCAX::Meshing::Boolean::MeshBoolean<EIAC, TriSoupTraits>;
void read_mesh11(const std::string& filename, Points& points,Triangles& triangles, IOOptions& io_options)
{
	if (AMCAX::Meshing::ends_with(filename, ".obj"))
	{
		OBJReader reader;
		reader.read(filename, io_options);
		points = std::move(reader.m_points);
		triangles = std::move(reader.m_triangles);
	}
	else if (AMCAX::Meshing::ends_with(filename, ".stl"))
	{
		STLReader reader;
		reader.read(filename, io_options);
		points = std::move(reader.m_points);
		triangles = std::move(reader.m_triangles);
	}
}
void write_mesh11(const std::string& filename, const Points& points,const Triangles& triangles, IOOptions& io_options)
{
	OBJWriter writer;
	writer.m_points = std::move(points);
	writer.m_triangles = std::move(triangles);
	bool bWriteObj = writer.write(filename, io_options, 10);
	CHECK(bWriteObj == true);
};
TEST_CASE("case1: MeshBoolean_MeshBoolean  ", "[meshModeling][MeshBoolean][P1]")
{
	OUTPUT_DIRECTORY(Boolean, Boolean);
	IOOptions io_options;
	io_options.vertex_has_point = true;
	Points    points1, points2, result_points;
	Triangles triangles1, triangles2, result_triangles;
	read_mesh11(INPUT_PATH_PREFIX"./meshModeling_data/MeshBoolean_data/bunny25k.obj", points1, triangles1, io_options);
	read_mesh11(INPUT_PATH_PREFIX"./meshModeling_data/MeshBoolean_data/cow.obj", points2, triangles2, io_options);
	MeshBoolean boolean( true);
	boolean.addTriMeshAsInput(points1, triangles1);
	boolean.addTriMeshAsInput(points2, triangles2);
	boolean.setTriMeshAsOutput(result_points, result_triangles);
	boolean.computeLabels();
	{
		boolean.Union();
		make_file_writable(outdir + "AMCAXMeshing_Union.obj");
		write_mesh11(outdir + "AMCAXMeshing_Union.obj", result_points,
			result_triangles, io_options);
	}
	{
		boolean.Intersection();
		make_file_writable(outdir + "AMCAXMeshing_Intersection.obj");
		write_mesh11(outdir + "AMCAXMeshing_Intersection.obj", result_points,
			result_triangles, io_options);
	}
	{
		boolean.Xor();
		make_file_writable(outdir + "AMCAXMeshing_Xor.obj");
		write_mesh11(outdir + "AMCAXMeshing_Xor.obj", result_points, result_triangles,
			io_options);
	}
	{
		boolean.Subtraction();
		make_file_writable(outdir + "AMCAXMeshing_Subtraction.obj");
		write_mesh11(outdir + "AMCAXMeshing_Subtraction.obj", result_points,
			result_triangles, io_options);
	}
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAXMeshing_API void computeInterSegments()	 after computing labels.
	 @brief In order to obtain the intersection segments, we need call this
,
 "output":#include<catch.hpp>
#include<testHelperBase.h>
#define AMCAXMeshing_Enable_EigenTraits
#define AMCAXMeshing_Enable_CommonTraits
#define AMCAXMeshing_Disable_StandardTraits
#include "mesh/TriSoup.hpp"
#include "meshModeling/MeshBoolean.hpp"
#include "mesh/io/OBJReader.hpp"
#include "mesh/io/OBJWriter.hpp"
#include "mesh/io/STLReader.hpp"
#include "mesh/io/STLWriter.hpp"
#ifdef AMCAXMeshing_Enable_CommonTraits
using TriSoupTraits = AMCAX::Meshing::Mesh::TriSoupTraits_Coord;
#endif
using EIAC = AMCAX::Meshing::Geometry::EIAC;
using Points = typename TriSoupTraits::Points;
using Triangles = typename TriSoupTraits::Triangles;
using OBJReader = AMCAX::Meshing::Mesh::OBJReader<TriSoupTraits>;
using OBJWriter = AMCAX::Meshing::Mesh::OBJWriter<TriSoupTraits>;
using STLReader = AMCAX::Meshing::Mesh::STLReader<TriSoupTraits>;
using STLWriter = AMCAX::Meshing::Mesh::STLWriter<TriSoupTraits>;
using IOOptions = AMCAX::Meshing::Mesh::IOOptions;
using MeshBoolean = AMCAX::Meshing::Boolean::MeshBoolean<EIAC, TriSoupTraits>;
template <typename TriIndexT>
struct InterSegments
{
    using ti_t = TriIndexT;
    std::vector<ti_t> vertex_ids;
    bool closed;
};
void read_mesh2(const std::string& filename, Points& points,
    Triangles& triangles, IOOptions& io_options)
{
    if (AMCAX::Meshing::ends_with(filename, ".obj"))
    {
        OBJReader reader;
        reader.read(filename, io_options);
        points = std::move(reader.m_points);
        triangles = std::move(reader.m_triangles);
    }
    else if (AMCAX::Meshing::ends_with(filename, ".stl"))
    {
        STLReader reader;
        reader.read(filename, io_options);
        points = std::move(reader.m_points);
        triangles = std::move(reader.m_triangles);
    }
}
void write_mesh2(const std::string& filename, const Points& points,
    const Triangles& triangles, IOOptions& io_options)
{
    if (AMCAX::Meshing::ends_with(filename, ".obj"))
    {
        OBJWriter writer;
        writer.m_points = std::move(points);
        writer.m_triangles = std::move(triangles);
        writer.write(filename, io_options, 10);
    }
    else if (AMCAX::Meshing::ends_with(filename, ".stl"))
    {
        STLWriter writer;
        writer.m_points = std::move(points);
        writer.m_triangles = std::move(triangles);
        writer.write(filename, io_options, 10);
    }
};
TEST_CASE("bug2: MeshBoolean_InterSegments ", "[meshModeling][MeshBoolean_InterSegments][bug]")
{
    IOOptions io_options;
    io_options.vertex_has_point = true;
    Points      points1, points2, points3, result_points;
    Triangles   triangles1, triangles2, triangles3, result_triangles;
	SECTION("stl-stl-obj")
    {
        OUTPUT_DIRECTORY(MeshBoolean, InterSegments_stl);
        read_mesh2(INPUT_PATH_PREFIX"./meshModeling_data/MeshBoolean_data/cow1.stl", points1, triangles1, io_options);
        read_mesh2(INPUT_PATH_PREFIX"./meshModeling_data/MeshBoolean_data/bunny1.stl", points2, triangles2, io_options);
        read_mesh2(INPUT_PATH_PREFIX"./meshModeling_data/MeshBoolean_data/bunny1.obj", points3, triangles3, io_options);
        MeshBoolean boolean(true);
        boolean.addTriMeshAsInput(points1, triangles1);
        boolean.addTriMeshAsInput(points2, triangles2);
        boolean.addTriMeshAsInput(points3, triangles3);
        boolean.setTriMeshAsOutput(result_points, result_triangles);
        boolean.computeLabels();
        boolean.computeInterSegments();
        boolean.Subtraction();
        const auto& inter_segs = boolean.getInterSegments();
        for (size_t s_id = 0; s_id < inter_segs.size(); ++s_id)
        {
            std::ofstream ofs(outdir + "stl_" + std::to_string(s_id) + ".obj");
            size_t v_num = inter_segs[s_id].vertex_ids.size();
            ofs << "# v_num: " << v_num << std::endl;
            size_t l_num = inter_segs[s_id].closed ? inter_segs[s_id].vertex_ids.size() : inter_segs[s_id].vertex_ids.size() - 1;
            ofs << "# l_num: " << l_num << std::endl;
            ofs << std::endl;
            for (auto v_id : inter_segs[s_id].vertex_ids)
            {
                ofs << "v " << result_points[v_id].x() << " " << result_points[v_id].y() << " " << result_points[v_id].z() << std::endl;
            }
            ofs << std::endl;
            for (size_t i = 0; i < inter_segs[s_id].vertex_ids.size() - 1; ++i)
            {
                ofs << "l " << i + 1 << " " << i + 2 << std::endl;
            }
            if (inter_segs[s_id].closed)
            {
                ofs << "l " << inter_segs[s_id].vertex_ids.size() << " " << 1 << std::endl;
            }
            ofs.close();
            write_mesh2(outdir + "InterSubtraction.stl", result_points, result_triangles, io_options);
        }
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAXMeshing_API std::vector<InterSegments> & getInterSegments(),
 "output":#include<catch.hpp>
#include<testHelperBase.h>
#define AMCAXMeshing_Enable_EigenTraits
#define AMCAXMeshing_Enable_CommonTraits
#define AMCAXMeshing_Disable_StandardTraits
#include "mesh/TriSoup.hpp"
#include "meshModeling/MeshBoolean.hpp"
#include "mesh/io/OBJReader.hpp"
#include "mesh/io/OBJWriter.hpp"
#include "mesh/io/STLReader.hpp"
#include "mesh/io/STLWriter.hpp"
#ifdef AMCAXMeshing_Enable_CommonTraits
using TriSoupTraits = AMCAX::Meshing::Mesh::TriSoupTraits_Coord;
#endif
using EIAC = AMCAX::Meshing::Geometry::EIAC;
using Points = typename TriSoupTraits::Points;
using Triangles = typename TriSoupTraits::Triangles;
using OBJReader = AMCAX::Meshing::Mesh::OBJReader<TriSoupTraits>;
using OBJWriter = AMCAX::Meshing::Mesh::OBJWriter<TriSoupTraits>;
using STLReader = AMCAX::Meshing::Mesh::STLReader<TriSoupTraits>;
using STLWriter = AMCAX::Meshing::Mesh::STLWriter<TriSoupTraits>;
using IOOptions = AMCAX::Meshing::Mesh::IOOptions;
using MeshBoolean = AMCAX::Meshing::Boolean::MeshBoolean<EIAC, TriSoupTraits>;
template <typename TriIndexT>
struct InterSegments
{
    using ti_t = TriIndexT;
    std::vector<ti_t> vertex_ids;
    bool closed;
};
void read_mesh2(const std::string& filename, Points& points,
    Triangles& triangles, IOOptions& io_options)
{
    if (AMCAX::Meshing::ends_with(filename, ".obj"))
    {
        OBJReader reader;
        reader.read(filename, io_options);
        points = std::move(reader.m_points);
        triangles = std::move(reader.m_triangles);
    }
    else if (AMCAX::Meshing::ends_with(filename, ".stl"))
    {
        STLReader reader;
        reader.read(filename, io_options);
        points = std::move(reader.m_points);
        triangles = std::move(reader.m_triangles);
    }
}
void write_mesh2(const std::string& filename, const Points& points,
    const Triangles& triangles, IOOptions& io_options)
{
    if (AMCAX::Meshing::ends_with(filename, ".obj"))
    {
        OBJWriter writer;
        writer.m_points = std::move(points);
        writer.m_triangles = std::move(triangles);
        writer.write(filename, io_options, 10);
    }
    else if (AMCAX::Meshing::ends_with(filename, ".stl"))
    {
        STLWriter writer;
        writer.m_points = std::move(points);
        writer.m_triangles = std::move(triangles);
        writer.write(filename, io_options, 10);
    }
};
TEST_CASE("bug1: MeshBoolean_InterSegments ", "[meshModeling][MeshBoolean_InterSegments][bug]")
{
    OUTPUT_DIRECTORY(MeshBoolean, InterSegments_bug);
    IOOptions io_options;
    io_options.vertex_has_point = true;
    Points      points1, points2, points3, points11, points22, points33, result_points, result_points11;
    Triangles   triangles1, triangles2, triangles3, triangles11, triangles22, triangles33, result_triangles, result_triangles11;
    read_mesh2(INPUT_PATH_PREFIX"./meshModeling_data/MeshBoolean_data/cow1.stl", points1, triangles1, io_options);
    read_mesh2(INPUT_PATH_PREFIX"./meshModeling_data/MeshBoolean_data/bunny1.stl", points2, triangles2, io_options);
    read_mesh2(INPUT_PATH_PREFIX"./meshModeling_data/MeshBoolean_data/cow1.stl", points3, triangles3, io_options);
    read_mesh2(INPUT_PATH_PREFIX"./meshModeling_data/MeshBoolean_data/cow1.obj", points11, triangles11, io_options);
    read_mesh2(INPUT_PATH_PREFIX"./meshModeling_data/MeshBoolean_data/bunny1.obj", points22, triangles22, io_options);
    read_mesh2(INPUT_PATH_PREFIX"./meshModeling_data/MeshBoolean_data/cow1.obj", points33, triangles33, io_options);
    MeshBoolean boolean(true);
    MeshBoolean boolean11(true);
    boolean.addTriMeshAsInput(points1, triangles1);
    boolean.addTriMeshAsInput(points2, triangles2);
    boolean.addTriMeshAsInput(points3, triangles3);
    boolean.setTriMeshAsOutput(result_points, result_triangles);
    boolean.computeLabels();
    boolean.computeInterSegments();
    boolean.Subtraction();
    boolean11.addTriMeshAsInput(points11, triangles11);
    boolean11.addTriMeshAsInput(points22, triangles22);
    boolean11.addTriMeshAsInput(points33, triangles33);
    boolean11.setTriMeshAsOutput(result_points11, result_triangles11);
    boolean11.computeLabels();
    boolean11.computeInterSegments();
    boolean11.Subtraction();
    const auto& inter_segs = boolean.getInterSegments();
    const auto& inter_segs11 = boolean11.getInterSegments();
    for (size_t s_id = 0; s_id < inter_segs.size(); ++s_id)
    {
        std::ofstream ofs(outdir + "stl_"+std::to_string(s_id) + ".obj");
        size_t v_num = inter_segs[s_id].vertex_ids.size();
        ofs << "# v_num: " << v_num << std::endl;
        size_t l_num = inter_segs[s_id].closed ? inter_segs[s_id].vertex_ids.size() : inter_segs[s_id].vertex_ids.size() - 1;
        ofs << "# l_num: " << l_num << std::endl;
        ofs << std::endl;
        for (auto v_id : inter_segs[s_id].vertex_ids)
        {
            ofs << "v " << result_points[v_id].x() << " " << result_points[v_id].y() << " " << result_points[v_id].z() << std::endl;
        }
        ofs << std::endl;
        for (size_t i = 0; i < inter_segs[s_id].vertex_ids.size() - 1; ++i)
        {
            ofs << "l " << i + 1 << " " << i + 2 << std::endl;
        }
        if (inter_segs[s_id].closed)
        {
            ofs << "l " << inter_segs[s_id].vertex_ids.size() << " " << 1 << std::endl;
        }
        ofs.close();
        write_mesh2(outdir + "InterSubtraction.stl", result_points, result_triangles, io_options);
    }
    for (size_t s_id = 0; s_id < inter_segs11.size(); ++s_id)
    {
        std::ofstream ofs(outdir + "obj_"+std::to_string(s_id) + ".obj");
        size_t v_num = inter_segs11[s_id].vertex_ids.size();
        ofs << "# v_num: " << v_num << std::endl;
        size_t l_num = inter_segs11[s_id].closed ? inter_segs11[s_id].vertex_ids.size() : inter_segs11[s_id].vertex_ids.size() - 1;
        ofs << "# l_num: " << l_num << std::endl;
        ofs << std::endl;
        for (auto v_id : inter_segs11[s_id].vertex_ids)
        {
            ofs << "v " << result_points11[v_id].x() << " " << result_points11[v_id].y() << " " << result_points11[v_id].z() << std::endl;
        }
        ofs << std::endl;
        for (size_t i = 0; i < inter_segs11[s_id].vertex_ids.size() - 1; ++i)
        {
            ofs << "l " << i + 1 << " " << i + 2 << std::endl;
        }
        if (inter_segs11[s_id].closed)
        {
            ofs << "l " << inter_segs11[s_id].vertex_ids.size() << " " << 1 << std::endl;
        }
        ofs.close();
        write_mesh2(outdir + "InterSubtraction.obj", result_points11, result_triangles11, io_options);
    }
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API explicit GeneralTransformShape(const GeneralTransformation3& t)	 @param t The general transformation
	 @brief Construct from a general transformation
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <modeling/MakeSphere.hpp>
#include <modeling/TransformShape.hpp>
#include <topomesh/BRepMeshIncrementalMesh.hpp>
#include <modeling/MakeShapeTool.hpp>
#include <common/TransformationT.hpp>
#include <common/CartesianCoordinateSystem.hpp>
#include <common/GeneralTransformationT.hpp>
#include <modeling/GeneralTransformShape.hpp>
#include <geometry/GlobalProperty.hpp>
#include <occtio/OCCTTool.hpp>
#include <topology/BRepGlobalProperty.hpp>
#include <geometry/Geom3BSplineCurve.hpp>
#include <modeling/MakeEdge.hpp>
#include <topology/TopoTool.hpp>
#include <topology/BRepAdaptorCurve3.hpp>
using namespace AMCAX;
TEST_CASE("bug1: GeneralTransformShape  ", "[modeling][GeneralTransformShape][fixbug]") {
	TopoShape s = MakeSphere(1.0);
	BRepMeshIncrementalMesh mesher(s, 0.005, true);
	MakeShapeTool::EnsureNormalConsistency(s);
	GeneralTransformation3 tr;
	tr.SetAffinity(Frame3(), 5.0);
	s = GeneralTransformShape(s, tr);
	CHECK(s.Type() == AMCAX::ShapeType::Solid);
	CHECK(s.IsNull() == false);
	GlobalProperty prop;
	BRepGlobalProperty::VolumeProperties(s, prop);
	CHECK(prop.Mass() == Approx(20.934791259).epsilon(1e-11));
	Point3 vP = prop.CenterOfMass();
#ifndef WIN_CASE
	CHECK(vP.X() == Approx(0.0).margin(1e-3));
	CHECK(vP.Y() == Approx(0.0).margin(1e-12));
	CHECK(vP.Z() == Approx(0.0).margin(1e-12));
#else
	CHECK(vP.X() == Approx(-2.2218808037914858e-04).epsilon(1e-12));
	CHECK(vP.Y() == Approx(-1.0782779568197278e-16).epsilon(1e-12));
	CHECK(vP.Z() == Approx(-1.6920954211916623e-16).epsilon(1e-12));
#endif
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API GeneralTransformShape(const TopoShape& s, const GeneralTransformation3& t, bool copy = false)	 @param copy Whether the geometry of the shape is copied
	 @param t The general transformation
	 @param s The shape
	 @brief Transform a shape by a general transformation
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <modeling/MakeSphere.hpp>
#include <modeling/TransformShape.hpp>
#include <topomesh/BRepMeshIncrementalMesh.hpp>
#include <modeling/MakeShapeTool.hpp>
#include <common/TransformationT.hpp>
#include <common/CartesianCoordinateSystem.hpp>
#include <common/GeneralTransformationT.hpp>
#include <modeling/GeneralTransformShape.hpp>
#include <geometry/GlobalProperty.hpp>
#include <occtio/OCCTTool.hpp>
#include <topology/BRepGlobalProperty.hpp>
#include <geometry/Geom3BSplineCurve.hpp>
#include <modeling/MakeEdge.hpp>
#include <topology/TopoTool.hpp>
#include <topology/BRepAdaptorCurve3.hpp>
using namespace AMCAX;
TEST_CASE("bug1: GeneralTransformShape  ", "[modeling][GeneralTransformShape][fixbug]") {
	TopoShape s = MakeSphere(1.0);
	BRepMeshIncrementalMesh mesher(s, 0.005, true);
	MakeShapeTool::EnsureNormalConsistency(s);
	GeneralTransformation3 tr;
	tr.SetAffinity(Frame3(), 5.0);
	s = GeneralTransformShape(s, tr);
	CHECK(s.Type() == AMCAX::ShapeType::Solid);
	CHECK(s.IsNull() == false);
	GlobalProperty prop;
	BRepGlobalProperty::VolumeProperties(s, prop);
	CHECK(prop.Mass() == Approx(20.934791259).epsilon(1e-11));
	Point3 vP = prop.CenterOfMass();
#ifndef WIN_CASE
	CHECK(vP.X() == Approx(0.0).margin(1e-3));
	CHECK(vP.Y() == Approx(0.0).margin(1e-12));
	CHECK(vP.Z() == Approx(0.0).margin(1e-12));
#else
	CHECK(vP.X() == Approx(-2.2218808037914858e-04).epsilon(1e-12));
	CHECK(vP.Y() == Approx(-1.0782779568197278e-16).epsilon(1e-12));
	CHECK(vP.Z() == Approx(-1.6920954211916623e-16).epsilon(1e-12));
#endif
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API MakeBox(double dx, double dy, double dz)	 @param dx,dy,dz The size
	 @brief Construct from its size in x, y, z directions
,
 "output":#include <modeling/MakeBox.hpp>
#include<catch.hpp>
#include<testHelper.h>
#include <modeling/MakeBox.hpp>
#include <modeling/MakeCylinder.hpp>
#include <topology/BRepExtremaProximityTool.hpp>
#include <io/OBJTool.hpp>
#include <topology/TopoFace.hpp>
#include <modeling/TransformShape.hpp>
#include <topology/TopoExplorerTool.hpp>
#include <modeling/MakeTorus.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
using namespace AMCAX;
TEST_CASE("case1:this is a case for MakeBox", "[MakeBox1]")
{
	SECTION("Box1") {
		OUTPUT_DIRECTORY(topology, OverlapFaces);
		MakeBox box(3.0, 2.0,2.0);
		TopoShape box2= box.Shape();
		box.Init(4.0, 5.0, 6.0);
		TopoFace shape = box.XMinFace(); 
		TopoFace shape1 = box.ZMinFace(); 
		TopoShape shape2 = box; 
		TopoShape shapeV = box;
		AMCAX::GlobalProperty prop1;
		double s_sahpe = GetSurfaceProperties(shape, prop1, true, false);
		double s_sahpe1 = GetSurfaceProperties(shape1, prop1, true, false);
		double s_sahpe2 = GetSurfaceProperties(shape2, prop1, true, false);
		double v_sahpe = GetVolumeProperties(shapeV, prop1, true, false);
		CHECK(s_sahpe == Approx(30.0).margin(1e-12));
		CHECK(s_sahpe1 == Approx(20.0).margin(1e-12));
		CHECK(s_sahpe2 == Approx(148.0).margin(1e-12));
		CHECK(v_sahpe == Approx(120.0).margin(1e-12));
		CHECK( OCCTIO::OCCTTool::Write(box, outdir + "MakeBox1.brep"));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API MakeBox(const Point3& p, double dx, double dy, double dz)	 @param dx,dy,dz The size
	 @param p The corner point
	 @brief Construct from a corner point and its size
,
 "output":#include <modeling/MakeBox.hpp>
#include<catch.hpp>
#include<testHelper.h>
#include <modeling/MakeBox.hpp>
#include <modeling/MakeCylinder.hpp>
#include <topology/BRepExtremaProximityTool.hpp>
#include <io/OBJTool.hpp>
#include <topology/TopoFace.hpp>
#include <modeling/TransformShape.hpp>
#include <topology/TopoExplorerTool.hpp>
#include <modeling/MakeTorus.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
using namespace AMCAX;
TEST_CASE("case1:this is a case for MakeBox", "[MakeBox1]")
{
	SECTION("Box3")
	{
		OUTPUT_DIRECTORY(topology, OverlapFaces);
		MakeBox box2(Point3(-2.0, -2.0, -2.0), Point3(2.0,2.0,2.0));
		MakeBox box3;
		box3.Init(Point3(-2.0, -2.0, -2.0), Point3(2.0, 2.0, 2.0));
		TopoFace shape1 = box2.XMinFace();
		TopoFace shape2 = box2.XMaxFace();
		TopoFace shape3 = box2.YMinFace();
		TopoFace shape4 = box2.YMaxFace();
		TopoFace shape5 = box2.ZMinFace();
		TopoFace shape6 = box2.ZMaxFace();
		TopoShape shape = box2;
		TopoFace shape_1 = box3.XMinFace();
		TopoFace shape_2 = box3.XMaxFace();
		TopoFace shape_3 = box3.YMinFace();
		TopoFace shape_4 = box3.YMaxFace();
		TopoFace shape_5 = box3.ZMinFace();
		TopoFace shape_6 = box3.ZMaxFace();
		AMCAX::GlobalProperty prop1;
		double s_sahpe1 = GetSurfaceProperties(shape1, prop1, true, false);
		double s_sahpe2 = GetSurfaceProperties(shape2, prop1, true, false);
		double s_sahpe3 = GetSurfaceProperties(shape3, prop1, true, false);
		double s_sahpe4 = GetSurfaceProperties(shape4, prop1, true, false);
		double s_sahpe5 = GetSurfaceProperties(shape5, prop1, true, false);
		double s_sahpe6 = GetSurfaceProperties(shape6, prop1, true, false);
		double s_sahpe = GetSurfaceProperties(shape, prop1, true, false);
		double v_sahpe = GetVolumeProperties(shape, prop1, true, false);
		BRepClassificationTools brep;
		bool r1 = brep.IsPointInOnFace(shape1, Point3(-2.0, 0.0, 0.0), -1.0);
		bool r2 = brep.IsPointInOnFace(shape2, Point3(2.0, 0.0, 0.0), -1.0);
		bool r3 = brep.IsPointInOnFace(shape3, Point3(0.0, -2.0, 0.0), -1.0);
		bool r33 = brep.IsPointInOnFace(shape3, Point3(1.0, 0.5, 3.0), -1.0);
		bool r4 = brep.IsPointInOnFace(shape4, Point3(0.0, 2.0, 0.0), -1.0);
		bool r5 = brep.IsPointInOnFace(shape5, Point3(0.0, 0.0, -2.0), -1.0);
		bool r6 = brep.IsPointInOnFace(shape6, Point3(0.0, 0.0, 2.0), -1.0);
		double s_shape_1 = GetSurfaceProperties(shape_1, prop1, true, false);
		double s_shape_2 = GetSurfaceProperties(shape_2, prop1, true, false);
		double s_shape_3 = GetSurfaceProperties(shape_3, prop1, true, false);
		double s_shape_4 = GetSurfaceProperties(shape_4, prop1, true, false);
		double s_shape_5 = GetSurfaceProperties(shape_5, prop1, true, false);
		double s_shape_6 = GetSurfaceProperties(shape_6, prop1, true, false);
		bool r_1 = brep.IsPointInOnFace(shape_1, Point3(-2.0, 0.0, 0.0), -1.0);
		bool r_2 = brep.IsPointInOnFace(shape_2, Point3(2.0, 0.0, 0.0), -1.0);
		bool r_3 = brep.IsPointInOnFace(shape_3, Point3(0.0, -2.0, 0.0), -1.0);
		bool r_33 = brep.IsPointInOnFace(shape_3, Point3(1.0, 0.5, 3.0), -1.0);
		bool r_4 = brep.IsPointInOnFace(shape_4, Point3(0.0, 2.0, 0.0), -1.0);
		bool r_5 = brep.IsPointInOnFace(shape_5, Point3(0.0, 0.0, -2.0), -1.0);
		bool r_6 = brep.IsPointInOnFace(shape_6, Point3(0.0, 0.0, 2.0), -1.0);
		CHECK(s_sahpe1 == Approx(16.0).margin(1e-12));
		CHECK(s_sahpe2 == Approx(16.0).margin(1e-12));
		CHECK(s_sahpe3 == Approx(16.0).margin(1e-12));
		CHECK(s_sahpe4 == Approx(16.0).margin(1e-12));
		CHECK(s_sahpe5 == Approx(16.0).margin(1e-12));
		CHECK(s_sahpe6 == Approx(16.0).margin(1e-12));
		CHECK(v_sahpe == Approx(64.0).margin(1e-12));
		CHECK(s_sahpe == s_sahpe1 + s_sahpe2 + s_sahpe3 + s_sahpe4 + s_sahpe5 + s_sahpe6);
		CHECK(s_sahpe1 == s_shape_1);
		CHECK(s_sahpe2 == s_shape_2);
		CHECK(s_sahpe3 == s_shape_3);
		CHECK(s_sahpe4 == s_shape_4);
		CHECK(s_sahpe5 == s_shape_5);
		CHECK(s_sahpe6 == s_shape_6);
		CHECK(r1 == true);
		CHECK(r2 == true);
		CHECK(r3 == true);
		CHECK(r33 == false);
		CHECK(r4 == true);
		CHECK(r5 == true);
		CHECK(r6 == true);
		CHECK(r_1 == true);
		CHECK(r_2 == true);
		CHECK(r_3 == true);
		CHECK(r_33 == false);
		CHECK(r_4 == true);
		CHECK(r_5 == true);
		CHECK(r_6 == true);
		CHECK(OCCTIO::OCCTTool::Write(box2, outdir + "MakeBox3.brep"));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API MakeBox(const Point3& p1, const Point3& p2)	 @param p2 The second point
	 @param p1 The first point
	 @brief Construct from two diagonal corner points
,
 "output":#include <modeling/MakeBox.hpp>
#include<catch.hpp>
#include<testHelper.h>
#include <modeling/MakeBox.hpp>
#include <modeling/MakeCylinder.hpp>
#include <topology/BRepExtremaProximityTool.hpp>
#include <io/OBJTool.hpp>
#include <topology/TopoFace.hpp>
#include <modeling/TransformShape.hpp>
#include <topology/TopoExplorerTool.hpp>
#include <modeling/MakeTorus.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
using namespace AMCAX;
TEST_CASE("case1:this is a case for MakeBox", "[MakeBox1]")
{
	SECTION("Box3")
	{
		OUTPUT_DIRECTORY(topology, OverlapFaces);
		MakeBox box2(Point3(-2.0, -2.0, -2.0), Point3(2.0,2.0,2.0));
		MakeBox box3;
		box3.Init(Point3(-2.0, -2.0, -2.0), Point3(2.0, 2.0, 2.0));
		TopoFace shape1 = box2.XMinFace();
		TopoFace shape2 = box2.XMaxFace();
		TopoFace shape3 = box2.YMinFace();
		TopoFace shape4 = box2.YMaxFace();
		TopoFace shape5 = box2.ZMinFace();
		TopoFace shape6 = box2.ZMaxFace();
		TopoShape shape = box2;
		TopoFace shape_1 = box3.XMinFace();
		TopoFace shape_2 = box3.XMaxFace();
		TopoFace shape_3 = box3.YMinFace();
		TopoFace shape_4 = box3.YMaxFace();
		TopoFace shape_5 = box3.ZMinFace();
		TopoFace shape_6 = box3.ZMaxFace();
		AMCAX::GlobalProperty prop1;
		double s_sahpe1 = GetSurfaceProperties(shape1, prop1, true, false);
		double s_sahpe2 = GetSurfaceProperties(shape2, prop1, true, false);
		double s_sahpe3 = GetSurfaceProperties(shape3, prop1, true, false);
		double s_sahpe4 = GetSurfaceProperties(shape4, prop1, true, false);
		double s_sahpe5 = GetSurfaceProperties(shape5, prop1, true, false);
		double s_sahpe6 = GetSurfaceProperties(shape6, prop1, true, false);
		double s_sahpe = GetSurfaceProperties(shape, prop1, true, false);
		double v_sahpe = GetVolumeProperties(shape, prop1, true, false);
		BRepClassificationTools brep;
		bool r1 = brep.IsPointInOnFace(shape1, Point3(-2.0, 0.0, 0.0), -1.0);
		bool r2 = brep.IsPointInOnFace(shape2, Point3(2.0, 0.0, 0.0), -1.0);
		bool r3 = brep.IsPointInOnFace(shape3, Point3(0.0, -2.0, 0.0), -1.0);
		bool r33 = brep.IsPointInOnFace(shape3, Point3(1.0, 0.5, 3.0), -1.0);
		bool r4 = brep.IsPointInOnFace(shape4, Point3(0.0, 2.0, 0.0), -1.0);
		bool r5 = brep.IsPointInOnFace(shape5, Point3(0.0, 0.0, -2.0), -1.0);
		bool r6 = brep.IsPointInOnFace(shape6, Point3(0.0, 0.0, 2.0), -1.0);
		double s_shape_1 = GetSurfaceProperties(shape_1, prop1, true, false);
		double s_shape_2 = GetSurfaceProperties(shape_2, prop1, true, false);
		double s_shape_3 = GetSurfaceProperties(shape_3, prop1, true, false);
		double s_shape_4 = GetSurfaceProperties(shape_4, prop1, true, false);
		double s_shape_5 = GetSurfaceProperties(shape_5, prop1, true, false);
		double s_shape_6 = GetSurfaceProperties(shape_6, prop1, true, false);
		bool r_1 = brep.IsPointInOnFace(shape_1, Point3(-2.0, 0.0, 0.0), -1.0);
		bool r_2 = brep.IsPointInOnFace(shape_2, Point3(2.0, 0.0, 0.0), -1.0);
		bool r_3 = brep.IsPointInOnFace(shape_3, Point3(0.0, -2.0, 0.0), -1.0);
		bool r_33 = brep.IsPointInOnFace(shape_3, Point3(1.0, 0.5, 3.0), -1.0);
		bool r_4 = brep.IsPointInOnFace(shape_4, Point3(0.0, 2.0, 0.0), -1.0);
		bool r_5 = brep.IsPointInOnFace(shape_5, Point3(0.0, 0.0, -2.0), -1.0);
		bool r_6 = brep.IsPointInOnFace(shape_6, Point3(0.0, 0.0, 2.0), -1.0);
		CHECK(s_sahpe1 == Approx(16.0).margin(1e-12));
		CHECK(s_sahpe2 == Approx(16.0).margin(1e-12));
		CHECK(s_sahpe3 == Approx(16.0).margin(1e-12));
		CHECK(s_sahpe4 == Approx(16.0).margin(1e-12));
		CHECK(s_sahpe5 == Approx(16.0).margin(1e-12));
		CHECK(s_sahpe6 == Approx(16.0).margin(1e-12));
		CHECK(v_sahpe == Approx(64.0).margin(1e-12));
		CHECK(s_sahpe == s_sahpe1 + s_sahpe2 + s_sahpe3 + s_sahpe4 + s_sahpe5 + s_sahpe6);
		CHECK(s_sahpe1 == s_shape_1);
		CHECK(s_sahpe2 == s_shape_2);
		CHECK(s_sahpe3 == s_shape_3);
		CHECK(s_sahpe4 == s_shape_4);
		CHECK(s_sahpe5 == s_shape_5);
		CHECK(s_sahpe6 == s_shape_6);
		CHECK(r1 == true);
		CHECK(r2 == true);
		CHECK(r3 == true);
		CHECK(r33 == false);
		CHECK(r4 == true);
		CHECK(r5 == true);
		CHECK(r6 == true);
		CHECK(r_1 == true);
		CHECK(r_2 == true);
		CHECK(r_3 == true);
		CHECK(r_33 == false);
		CHECK(r_4 == true);
		CHECK(r_5 == true);
		CHECK(r_6 == true);
		CHECK(OCCTIO::OCCTTool::Write(box2, outdir + "MakeBox3.brep"));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API MakeBox(const Frame3& frame, double dx, double dy, double dz)	 @param dx,dy,dz The size
	 @param frame The local coordinate system
	 @brief Construct from a local coordinate system and size
,
 "output":#include <modeling/MakeBox.hpp>
#include<catch.hpp>
#include<testHelper.h>
#include <modeling/MakeBox.hpp>
#include <modeling/MakeCylinder.hpp>
#include <topology/BRepExtremaProximityTool.hpp>
#include <io/OBJTool.hpp>
#include <topology/TopoFace.hpp>
#include <modeling/TransformShape.hpp>
#include <topology/TopoExplorerTool.hpp>
#include <modeling/MakeTorus.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
using namespace AMCAX;
TEST_CASE("case1:this is a case for MakeBox", "[MakeBox1]")
{
	SECTION("Box3")
	{
		OUTPUT_DIRECTORY(topology, OverlapFaces);
		MakeBox box2(Point3(-2.0, -2.0, -2.0), Point3(2.0,2.0,2.0));
		MakeBox box3;
		box3.Init(Point3(-2.0, -2.0, -2.0), Point3(2.0, 2.0, 2.0));
		TopoFace shape1 = box2.XMinFace();
		TopoFace shape2 = box2.XMaxFace();
		TopoFace shape3 = box2.YMinFace();
		TopoFace shape4 = box2.YMaxFace();
		TopoFace shape5 = box2.ZMinFace();
		TopoFace shape6 = box2.ZMaxFace();
		TopoShape shape = box2;
		TopoFace shape_1 = box3.XMinFace();
		TopoFace shape_2 = box3.XMaxFace();
		TopoFace shape_3 = box3.YMinFace();
		TopoFace shape_4 = box3.YMaxFace();
		TopoFace shape_5 = box3.ZMinFace();
		TopoFace shape_6 = box3.ZMaxFace();
		AMCAX::GlobalProperty prop1;
		double s_sahpe1 = GetSurfaceProperties(shape1, prop1, true, false);
		double s_sahpe2 = GetSurfaceProperties(shape2, prop1, true, false);
		double s_sahpe3 = GetSurfaceProperties(shape3, prop1, true, false);
		double s_sahpe4 = GetSurfaceProperties(shape4, prop1, true, false);
		double s_sahpe5 = GetSurfaceProperties(shape5, prop1, true, false);
		double s_sahpe6 = GetSurfaceProperties(shape6, prop1, true, false);
		double s_sahpe = GetSurfaceProperties(shape, prop1, true, false);
		double v_sahpe = GetVolumeProperties(shape, prop1, true, false);
		BRepClassificationTools brep;
		bool r1 = brep.IsPointInOnFace(shape1, Point3(-2.0, 0.0, 0.0), -1.0);
		bool r2 = brep.IsPointInOnFace(shape2, Point3(2.0, 0.0, 0.0), -1.0);
		bool r3 = brep.IsPointInOnFace(shape3, Point3(0.0, -2.0, 0.0), -1.0);
		bool r33 = brep.IsPointInOnFace(shape3, Point3(1.0, 0.5, 3.0), -1.0);
		bool r4 = brep.IsPointInOnFace(shape4, Point3(0.0, 2.0, 0.0), -1.0);
		bool r5 = brep.IsPointInOnFace(shape5, Point3(0.0, 0.0, -2.0), -1.0);
		bool r6 = brep.IsPointInOnFace(shape6, Point3(0.0, 0.0, 2.0), -1.0);
		double s_shape_1 = GetSurfaceProperties(shape_1, prop1, true, false);
		double s_shape_2 = GetSurfaceProperties(shape_2, prop1, true, false);
		double s_shape_3 = GetSurfaceProperties(shape_3, prop1, true, false);
		double s_shape_4 = GetSurfaceProperties(shape_4, prop1, true, false);
		double s_shape_5 = GetSurfaceProperties(shape_5, prop1, true, false);
		double s_shape_6 = GetSurfaceProperties(shape_6, prop1, true, false);
		bool r_1 = brep.IsPointInOnFace(shape_1, Point3(-2.0, 0.0, 0.0), -1.0);
		bool r_2 = brep.IsPointInOnFace(shape_2, Point3(2.0, 0.0, 0.0), -1.0);
		bool r_3 = brep.IsPointInOnFace(shape_3, Point3(0.0, -2.0, 0.0), -1.0);
		bool r_33 = brep.IsPointInOnFace(shape_3, Point3(1.0, 0.5, 3.0), -1.0);
		bool r_4 = brep.IsPointInOnFace(shape_4, Point3(0.0, 2.0, 0.0), -1.0);
		bool r_5 = brep.IsPointInOnFace(shape_5, Point3(0.0, 0.0, -2.0), -1.0);
		bool r_6 = brep.IsPointInOnFace(shape_6, Point3(0.0, 0.0, 2.0), -1.0);
		CHECK(s_sahpe1 == Approx(16.0).margin(1e-12));
		CHECK(s_sahpe2 == Approx(16.0).margin(1e-12));
		CHECK(s_sahpe3 == Approx(16.0).margin(1e-12));
		CHECK(s_sahpe4 == Approx(16.0).margin(1e-12));
		CHECK(s_sahpe5 == Approx(16.0).margin(1e-12));
		CHECK(s_sahpe6 == Approx(16.0).margin(1e-12));
		CHECK(v_sahpe == Approx(64.0).margin(1e-12));
		CHECK(s_sahpe == s_sahpe1 + s_sahpe2 + s_sahpe3 + s_sahpe4 + s_sahpe5 + s_sahpe6);
		CHECK(s_sahpe1 == s_shape_1);
		CHECK(s_sahpe2 == s_shape_2);
		CHECK(s_sahpe3 == s_shape_3);
		CHECK(s_sahpe4 == s_shape_4);
		CHECK(s_sahpe5 == s_shape_5);
		CHECK(s_sahpe6 == s_shape_6);
		CHECK(r1 == true);
		CHECK(r2 == true);
		CHECK(r3 == true);
		CHECK(r33 == false);
		CHECK(r4 == true);
		CHECK(r5 == true);
		CHECK(r6 == true);
		CHECK(r_1 == true);
		CHECK(r_2 == true);
		CHECK(r_3 == true);
		CHECK(r_33 == false);
		CHECK(r_4 == true);
		CHECK(r_5 == true);
		CHECK(r_6 == true);
		CHECK(OCCTIO::OCCTTool::Write(box2, outdir + "MakeBox3.brep"));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API const TopoFace& XMinFace()	 @return The X-min face
	 @brief Get the face on X minimum
,
 "output":#include <modeling/MakeBox.hpp>
#include<catch.hpp>
#include<testHelper.h>
#include <modeling/MakeBox.hpp>
#include <modeling/MakeCylinder.hpp>
#include <topology/BRepExtremaProximityTool.hpp>
#include <io/OBJTool.hpp>
#include <topology/TopoFace.hpp>
#include <modeling/TransformShape.hpp>
#include <topology/TopoExplorerTool.hpp>
#include <modeling/MakeTorus.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
using namespace AMCAX;
TEST_CASE(" bug1:  ","[MakeBox][p1][fixbug]")
{
		OUTPUT_DIRECTORY(topology, OverlapFaces);
		MakeBox box(3.0, 2.0, 2.0);
		TopoShape box2 = box.Shape();
		box.Init(4.0, 5.0, 6.0);
		TopoFace shape = box.XMinFace();
		TopoFace shape1 = box.ZMinFace();
		TopoShape shape2 = box;
		TopoShape shapeV = box;
		AMCAX::GlobalProperty prop1;
		double s_sahpe = GetSurfaceProperties(shape, prop1, true, false);
		double s_sahpe1 = GetSurfaceProperties(shape1, prop1, true, false);
		double s_sahpe2 = GetSurfaceProperties(shape2, prop1, true, false);
		double v_sahpe = GetVolumeProperties(shapeV, prop1, true, false);
		CHECK(s_sahpe == Approx(30.0).margin(1e-12));
		CHECK(s_sahpe1 == Approx(20.0).margin(1e-12));
		CHECK(s_sahpe2 == Approx(148.0).margin(1e-12));
		CHECK(v_sahpe == Approx(120.0).margin(1e-12));
		CHECK(OCCTIO::OCCTTool::Write(box, outdir + "MakeBox.brep"));
	}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API const TopoFace& ZMinFace()	 @return The Z-min face
	 @brief Get the face on Z minimum
,
 "output":#include <modeling/MakeBox.hpp>
#include<catch.hpp>
#include<testHelper.h>
#include <modeling/MakeBox.hpp>
#include <modeling/MakeCylinder.hpp>
#include <topology/BRepExtremaProximityTool.hpp>
#include <io/OBJTool.hpp>
#include <topology/TopoFace.hpp>
#include <modeling/TransformShape.hpp>
#include <topology/TopoExplorerTool.hpp>
#include <modeling/MakeTorus.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
using namespace AMCAX;
TEST_CASE(" bug1:  ","[MakeBox][p1][fixbug]")
{
		OUTPUT_DIRECTORY(topology, OverlapFaces);
		MakeBox box(3.0, 2.0, 2.0);
		TopoShape box2 = box.Shape();
		box.Init(4.0, 5.0, 6.0);
		TopoFace shape = box.XMinFace();
		TopoFace shape1 = box.ZMinFace();
		TopoShape shape2 = box;
		TopoShape shapeV = box;
		AMCAX::GlobalProperty prop1;
		double s_sahpe = GetSurfaceProperties(shape, prop1, true, false);
		double s_sahpe1 = GetSurfaceProperties(shape1, prop1, true, false);
		double s_sahpe2 = GetSurfaceProperties(shape2, prop1, true, false);
		double v_sahpe = GetVolumeProperties(shapeV, prop1, true, false);
		CHECK(s_sahpe == Approx(30.0).margin(1e-12));
		CHECK(s_sahpe1 == Approx(20.0).margin(1e-12));
		CHECK(s_sahpe2 == Approx(148.0).margin(1e-12));
		CHECK(v_sahpe == Approx(120.0).margin(1e-12));
		CHECK(OCCTIO::OCCTTool::Write(box, outdir + "MakeBox.brep"));
	}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API MakeTorus(double r1, double r2, double angle1, double angle2)	 @param angle2 The end angle
	 @param angle1 The start angle
	 @param r2 The minor radius
	 @param r1 The major radius
	 @brief Construct from a major radius, a minor radius and two angles that forms an arc of the section circle
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <modeling/MakeTorus.hpp>
#include <common/CartesianCoordinateSystem.hpp>
#include <topology/TopoBuilder.hpp>
TEST_CASE("bug1: MakeTorus   ", "[modeling][MakeTorus][P1][fixbug]")
{
	std::vector<TopoShape> shapes;
	constexpr double major = 3.0;
	constexpr double minor = 1.0;
	auto addshape = [&](double angle1, double angle2, double angle)
	{
		Frame3 frame(Point3(0.0, 0.0, static_cast<double>(shapes.size()) * 3.0), CartesianCoordinateSystem::DZ());
		shapes.push_back(MakeTorus(frame, major, minor, angle1, angle2, angle));
	};
	addshape(0.0, 2.0 * M_PI, 2.0 * M_PI);
	addshape(0.0, 2.0 * M_PI, M_PI_2);
	addshape(0.0, M_PI, 2.0 * M_PI);
	addshape(M_PI_2, 3.0 * M_PI_2, 2.0 * M_PI);
	addshape(M_PI, 2.0 * M_PI, 2.0 * M_PI);
	addshape(-M_PI_2, M_PI_2, 2.0 * M_PI);
	addshape(M_PI_4, M_PI_4 * 3, 2.0 * M_PI);
	addshape(M_PI_4 * 3, M_PI_4 * 5, 2.0 * M_PI);
	addshape(M_PI_4 * 5, M_PI_4 * 7, 2.0 * M_PI);
	addshape(-M_PI_4, M_PI_4, 2.0 * M_PI);
	addshape(0.0, M_PI_2, M_PI_2);
	TopoShape result;
	TopoBuilder b;
	b.MakeCompound(TopoCast::Compound(result));
	for (const auto& s : shapes)
	{
		b.Add(result, s);
	}
	CHECK( OCCTIO::OCCTTool::Write(result, OUTPUT_PATH_PREFIX"MakeTorus_bug445.brep"));
	AMCAX::GlobalProperty props1, props2;
	CHECK(GetSurfaceProperties(result, props1, true, false) == Approx(831.9798765859));
	CHECK(GetVolumeProperties(result, props2, true, false) == Approx(255.8996));
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API MakeTorus(double r1, double r2, double angle1, double angle2, double angle)	 @param angle The rotation angle
	 @param angle2 The end angle
	 @param angle1 The start angle
	 @param r2 The minor radius
	 @param r1 The major radius
	 @brief Construct from a major radius, a minor radius, two angles that forms an arc of the section circle and a rotation angle
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <modeling/MakeTorus.hpp>
#include <common/CartesianCoordinateSystem.hpp>
#include <topology/TopoBuilder.hpp>
TEST_CASE("bug1: MakeTorus   ", "[modeling][MakeTorus][P1][fixbug]")
{
	std::vector<TopoShape> shapes;
	constexpr double major = 3.0;
	constexpr double minor = 1.0;
	auto addshape = [&](double angle1, double angle2, double angle)
	{
		Frame3 frame(Point3(0.0, 0.0, static_cast<double>(shapes.size()) * 3.0), CartesianCoordinateSystem::DZ());
		shapes.push_back(MakeTorus(frame, major, minor, angle1, angle2, angle));
	};
	addshape(0.0, 2.0 * M_PI, 2.0 * M_PI);
	addshape(0.0, 2.0 * M_PI, M_PI_2);
	addshape(0.0, M_PI, 2.0 * M_PI);
	addshape(M_PI_2, 3.0 * M_PI_2, 2.0 * M_PI);
	addshape(M_PI, 2.0 * M_PI, 2.0 * M_PI);
	addshape(-M_PI_2, M_PI_2, 2.0 * M_PI);
	addshape(M_PI_4, M_PI_4 * 3, 2.0 * M_PI);
	addshape(M_PI_4 * 3, M_PI_4 * 5, 2.0 * M_PI);
	addshape(M_PI_4 * 5, M_PI_4 * 7, 2.0 * M_PI);
	addshape(-M_PI_4, M_PI_4, 2.0 * M_PI);
	addshape(0.0, M_PI_2, M_PI_2);
	TopoShape result;
	TopoBuilder b;
	b.MakeCompound(TopoCast::Compound(result));
	for (const auto& s : shapes)
	{
		b.Add(result, s);
	}
	CHECK( OCCTIO::OCCTTool::Write(result, OUTPUT_PATH_PREFIX"MakeTorus_bug445.brep"));
	AMCAX::GlobalProperty props1, props2;
	CHECK(GetSurfaceProperties(result, props1, true, false) == Approx(831.9798765859));
	CHECK(GetVolumeProperties(result, props2, true, false) == Approx(255.8996));
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API MakeTorus(const Frame3& frame, double r1, double r2, double angle1, double angle2)	 @param angle2 The end angle
	 @param angle1 The start angle
	 @param r2 The minor radius
	 @param r1 The major radius
	 @param frame The local coordinate system
	 @brief Construct from a local coordinate system, a major radius, a minor radius and two angles that forms an arc of the section circle
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <modeling/MakeTorus.hpp>
#include <common/CartesianCoordinateSystem.hpp>
#include <topology/TopoBuilder.hpp>
TEST_CASE("bug1: MakeTorus   ", "[modeling][MakeTorus][P1][fixbug]")
{
	std::vector<TopoShape> shapes;
	constexpr double major = 3.0;
	constexpr double minor = 1.0;
	auto addshape = [&](double angle1, double angle2, double angle)
	{
		Frame3 frame(Point3(0.0, 0.0, static_cast<double>(shapes.size()) * 3.0), CartesianCoordinateSystem::DZ());
		shapes.push_back(MakeTorus(frame, major, minor, angle1, angle2, angle));
	};
	addshape(0.0, 2.0 * M_PI, 2.0 * M_PI);
	addshape(0.0, 2.0 * M_PI, M_PI_2);
	addshape(0.0, M_PI, 2.0 * M_PI);
	addshape(M_PI_2, 3.0 * M_PI_2, 2.0 * M_PI);
	addshape(M_PI, 2.0 * M_PI, 2.0 * M_PI);
	addshape(-M_PI_2, M_PI_2, 2.0 * M_PI);
	addshape(M_PI_4, M_PI_4 * 3, 2.0 * M_PI);
	addshape(M_PI_4 * 3, M_PI_4 * 5, 2.0 * M_PI);
	addshape(M_PI_4 * 5, M_PI_4 * 7, 2.0 * M_PI);
	addshape(-M_PI_4, M_PI_4, 2.0 * M_PI);
	addshape(0.0, M_PI_2, M_PI_2);
	TopoShape result;
	TopoBuilder b;
	b.MakeCompound(TopoCast::Compound(result));
	for (const auto& s : shapes)
	{
		b.Add(result, s);
	}
	CHECK( OCCTIO::OCCTTool::Write(result, OUTPUT_PATH_PREFIX"MakeTorus_bug445.brep"));
	AMCAX::GlobalProperty props1, props2;
	CHECK(GetSurfaceProperties(result, props1, true, false) == Approx(831.9798765859));
	CHECK(GetVolumeProperties(result, props2, true, false) == Approx(255.8996));
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API MakeTorus(const Frame3& frame, double r1, double r2, double angle1, double angle2, double angle)	 @param angle The rotation angle
	 @param angle2 The end angle
	 @param angle1 The start angle
	 @param r2 The minor radius
	 @param r1 The major radius
	 @param frame The local coordinate system
	 @brief Construct from a local coordinate system, a major radius, a minor radius, two angles that forms an arc of the section circle and a rotation angle
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <modeling/MakeTorus.hpp>
#include <common/CartesianCoordinateSystem.hpp>
#include <topology/TopoBuilder.hpp>
TEST_CASE("bug1: MakeTorus   ", "[modeling][MakeTorus][P1][fixbug]")
{
	std::vector<TopoShape> shapes;
	constexpr double major = 3.0;
	constexpr double minor = 1.0;
	auto addshape = [&](double angle1, double angle2, double angle)
	{
		Frame3 frame(Point3(0.0, 0.0, static_cast<double>(shapes.size()) * 3.0), CartesianCoordinateSystem::DZ());
		shapes.push_back(MakeTorus(frame, major, minor, angle1, angle2, angle));
	};
	addshape(0.0, 2.0 * M_PI, 2.0 * M_PI);
	addshape(0.0, 2.0 * M_PI, M_PI_2);
	addshape(0.0, M_PI, 2.0 * M_PI);
	addshape(M_PI_2, 3.0 * M_PI_2, 2.0 * M_PI);
	addshape(M_PI, 2.0 * M_PI, 2.0 * M_PI);
	addshape(-M_PI_2, M_PI_2, 2.0 * M_PI);
	addshape(M_PI_4, M_PI_4 * 3, 2.0 * M_PI);
	addshape(M_PI_4 * 3, M_PI_4 * 5, 2.0 * M_PI);
	addshape(M_PI_4 * 5, M_PI_4 * 7, 2.0 * M_PI);
	addshape(-M_PI_4, M_PI_4, 2.0 * M_PI);
	addshape(0.0, M_PI_2, M_PI_2);
	TopoShape result;
	TopoBuilder b;
	b.MakeCompound(TopoCast::Compound(result));
	for (const auto& s : shapes)
	{
		b.Add(result, s);
	}
	CHECK( OCCTIO::OCCTTool::Write(result, OUTPUT_PATH_PREFIX"MakeTorus_bug445.brep"));
	AMCAX::GlobalProperty props1, props2;
	CHECK(GetSurfaceProperties(result, props1, true, false) == Approx(831.9798765859));
	CHECK(GetVolumeProperties(result, props2, true, false) == Approx(255.8996));
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API MakePolygon(const Point3& p1, const Point3& p2)	 @param p2 The second point
	 @param p1 The first point
	 @brief Construct from two points
,
 "output":#include<catch.hpp>
#include<iostream>
#include <modeling/MakePolygon.hpp>
#include <topology/TopoVertex.hpp>
#include <topology/TopoEdge.hpp>
#include <topology/TopoExplorerTool.hpp>
#include <topology/TopoShape.hpp>
#include <topology/TopoTool.hpp>
TEST_CASE("MakePolygon Invalid input points", "[modeling][MakePolygon][P3]") {
        AMCAX::Point3 p1(0.0, 0.0, 0.0);
        AMCAX::MakePolygon polygon(p1, p1);
        bool lastAdded = polygon.Added();
        CHECK(lastAdded == false);
    }
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API void Add(const Point3& p)	 @param p The point
	 @brief Add a new point to the polygon
,
 "output":#include<catch.hpp>
#include<iostream>
#include <modeling/MakePolygon.hpp>
#include <topology/TopoVertex.hpp>
#include <topology/TopoEdge.hpp>
#include <topology/TopoExplorerTool.hpp>
#include <topology/TopoShape.hpp>
#include <topology/TopoTool.hpp>
TEST_CASE("void AMCAX::MakePolygon::Add(const Point3 & p) - case1 add valid 3D point", "[modeling][MakePolygon][P1]") {
        AMCAX::Point3 p1(1.0, 2.0, 3.0);
        AMCAX::Point3 p2(4.1, 5.1, 6.1);
        AMCAX::MakePolygon polygon(p1, p2);
        bool lastAdded1 = polygon.Added();
        CHECK(lastAdded1 == true);
        const AMCAX::TopoEdge &lastEdge = polygon.Edge();
        CHECK(lastEdge.IsNull() == false);
        CHECK(lastEdge.NChildren() == 2);
        CHECK(lastEdge.Type() == AMCAX::ShapeType::Edge);
        AMCAX::TopoVertex v1,v2;
        AMCAX::TopoExplorerTool::Vertices(lastEdge, v1, v2,false);
        CHECK_FALSE(v1.IsNull());
        CHECK_FALSE(v2.IsNull());
        CHECK(v1.Type() == AMCAX::ShapeType::Vertex);
        CHECK(v2.Type() == AMCAX::ShapeType::Vertex);
        AMCAX::Point3 vpoint1;
        vpoint1 = AMCAX::TopoTool::Point(v1);
        CHECK(vpoint1.X() == 1.0);
        CHECK(vpoint1.Y() == 2.0);
        CHECK(vpoint1.Z() == 3.0);
        AMCAX::Point3 p3(4.1, 5.1, 6.1);
        polygon.Add(p3);
        bool lastAdded2 = polygon.Added();
        CHECK(lastAdded2 == false);
        AMCAX::Point3 p4(7.0, 8.0, 9.0);
        polygon.Add(p4);
        bool lastAdded3 = polygon.Added();
        CHECK(lastAdded3 == true);
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API MakePyramid(const Point3& p1, const Point3& p2, const Point3& p3, const Point3& apex)	 @param apex Apex point
	 @param p1,p2,p3 Points on the base plane
	 @brief Construct a tetrahedron
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <modeling/MakePyramid.hpp>
#include <hatch/BRepClassificationTools.hpp>
TEST_CASE("case1 MakePyramid(p1, p2, p3, apex)  ", "[modeling][MakePyramid][P1]")
{
    Point3 p1(0.0, 0.0, 0.0);
    Point3 p2(4.0, 0.0, 0.0);
    Point3 p3(2.0, 4.0, 0.0);
    Point3 apex(0.0, 0.0, 4.5);
    std::vector<Point3> points = { p1, p2, p3, apex };
    TopoShape shape = AMCAX::MakePyramid(p1, p2, p3, apex);
    AMCAX::GlobalProperty props;
    CHECK(GetSurfaceProperties(shape, props, true, false) == Approx(39.9172660309));
    CHECK(GetVolumeProperties(shape, props, true, false) == Approx(12.0));
    CHECK(shape.Type() == ShapeType::Solid);
    OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX"MakePyramid_case01.brep");
    TopoSolid solid = AMCAX::TopoCast::Solid(shape);
    for (const Point3& p : points) {
        bool isPointOnSolid = AMCAX::BRepClassificationTools::IsPointInOnSolid(solid, p);
        CHECK(isPointOnSolid == true);
    }
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API MakePyramid(const Point3& p1, const Point3& p2, const Point3& p3, const Point3& p4, const Point3& apex)	 @param apex Apex point
	 @param p1,p2,p3,p4 Points on the base plane
	 @brief Construct a quadrilateral pyramid
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <modeling/MakePyramid.hpp>
#include <hatch/BRepClassificationTools.hpp>
TEST_CASE("case2 MakePyramid(p1, p2, p3, apex)  ", "[modeling][MakePyramid][P1]")
{
    Point3 p1(-2.0, 0.0, -2.0);
    Point3 p2(2.0, 0.0, -2.0);
    Point3 p3(0.0, 4.0, -2.0);
    Point3 apex(-5.0, 0.0, 2.5);
    std::vector<Point3> points = { p1, p2, p3, apex };
    TopoShape shape = AMCAX::MakePyramid(p1, p2, p3, apex);
    AMCAX::GlobalProperty props;
    CHECK(GetSurfaceProperties(shape, props, true, false) == Approx(45.9563141634));
    CHECK(GetVolumeProperties(shape, props, true, false) == Approx(12.0));
    CHECK(shape.Type() == ShapeType::Solid);
    OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX"MakePyramid_case02.brep");
    TopoSolid solid = AMCAX::TopoCast::Solid(shape);
    for (const Point3& p : points) {
        bool isPointOnSolid = AMCAX::BRepClassificationTools::IsPointInOnSolid(solid, p);
        CHECK(isPointOnSolid == true);
    }
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API MakePyramid(const std::vector<Point3>& basepoints, const Point3& apex)	 @param apex Apex point
	 @param basepoints Points on the base plane
	 @brief Construct a pyramid with base points and an apex point
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <modeling/MakePyramid.hpp>
#include <hatch/BRepClassificationTools.hpp>
TEST_CASE("case1: MakePyramid(basepoints, apex)  ", "[modeling][MakePyramid][P1]")
{
    Point3 p1(-2.0, 1.0, 0.0);
    Point3 p2(1.0, -3.0, 0.0);
    Point3 p3(-1.0, -2.5, 0.0);
    Point3 apex(5.0, 3.0, 4.5);
    std::vector<Point3> points = { p1, p2, p3};
    TopoShape shape = AMCAX::MakePyramid(points, apex);
    AMCAX::GlobalProperty props;
    CHECK(GetSurfaceProperties(shape, props, true, false) == Approx(47.6096343921));
    CHECK(GetVolumeProperties(shape, props, true, false) == Approx(4.875));
    CHECK(shape.Type() == ShapeType::Solid);
    CHECK(OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX"MakePyramid3_case01.brep"));
    TopoSolid solid = AMCAX::TopoCast::Solid(shape);
    CHECK(AMCAX::BRepClassificationTools::IsPointInOnSolid(solid, apex));
    for (const Point3& p : points) {
        bool isPointOnSolid = AMCAX::BRepClassificationTools::IsPointInOnSolid(solid, p);
        CHECK(isPointOnSolid == true);
    }
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API MakePyramid(const Frame3& frame, double radius, int nside, double height)	 @param height Height of the polygon
	 @param nside Number of sides of the base polygon
	 @param radius Radius of the circumcircle of the base polygon
	 @param frame The local coordinate system
	 @brief Construct a regular pyramid
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <modeling/MakePyramid.hpp>
#include <hatch/BRepClassificationTools.hpp>
TEST_CASE("case2: MakePyramid(p1, p2, p3, p4, apex) ", "[modeling][MakePyramid][P1]")
{ 
    Point3 p1(-2.0, 1.0, -1.0);
    Point3 p2(1.0, 3.0, 0.0);
    Point3 p3(4.0, -1.0, 1.0);
    Point3 p4(-1.0, -2.0, 0.0);
    Point3 apex(1.0, -1.0, -4.5);
    CHECK_THROWS_AS( AMCAX::MakePyramid(p1, p2, p3, p4, apex), AMCAX::_ConstructionError );
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API MakePyramid(const Frame3& frame, const Point3& p1, const Point3& p2, const Point3& p3, const Point3& apex)	 @param apex Apex point
	 @param p1,p2,p3 Points that are projected onto the base plane
	 @param frame The frame of base plane
	 @brief Construct a tetrahedron with a given plane frame
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <modeling/MakePyramid.hpp>
#include <hatch/BRepClassificationTools.hpp>
TEST_CASE("case1 MakePyramid(p1, p2, p3, apex)  ", "[modeling][MakePyramid][P1]")
{
    Point3 p1(0.0, 0.0, 0.0);
    Point3 p2(4.0, 0.0, 0.0);
    Point3 p3(2.0, 4.0, 0.0);
    Point3 apex(0.0, 0.0, 4.5);
    std::vector<Point3> points = { p1, p2, p3, apex };
    TopoShape shape = AMCAX::MakePyramid(p1, p2, p3, apex);
    AMCAX::GlobalProperty props;
    CHECK(GetSurfaceProperties(shape, props, true, false) == Approx(39.9172660309));
    CHECK(GetVolumeProperties(shape, props, true, false) == Approx(12.0));
    CHECK(shape.Type() == ShapeType::Solid);
    OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX"MakePyramid_case01.brep");
    TopoSolid solid = AMCAX::TopoCast::Solid(shape);
    for (const Point3& p : points) {
        bool isPointOnSolid = AMCAX::BRepClassificationTools::IsPointInOnSolid(solid, p);
        CHECK(isPointOnSolid == true);
    }
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API MakePyramid(const Frame3& frame, const Point3& p1, const Point3& p2, const Point3& p3, const Point3& p4, const Point3& apex)	 @param apex Apex point
	 @param p1,p2,p3,p4 Points that are projected onto the base plane
	 @param frame The frame of base plane
	 @brief Construct a quadrilateral pyramid with a given plane frame
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <modeling/MakePyramid.hpp>
#include <hatch/BRepClassificationTools.hpp>
TEST_CASE("case2 MakePyramid(p1, p2, p3, apex)  ", "[modeling][MakePyramid][P1]")
{
    Point3 p1(-2.0, 0.0, -2.0);
    Point3 p2(2.0, 0.0, -2.0);
    Point3 p3(0.0, 4.0, -2.0);
    Point3 apex(-5.0, 0.0, 2.5);
    std::vector<Point3> points = { p1, p2, p3, apex };
    TopoShape shape = AMCAX::MakePyramid(p1, p2, p3, apex);
    AMCAX::GlobalProperty props;
    CHECK(GetSurfaceProperties(shape, props, true, false) == Approx(45.9563141634));
    CHECK(GetVolumeProperties(shape, props, true, false) == Approx(12.0));
    CHECK(shape.Type() == ShapeType::Solid);
    OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX"MakePyramid_case02.brep");
    TopoSolid solid = AMCAX::TopoCast::Solid(shape);
    for (const Point3& p : points) {
        bool isPointOnSolid = AMCAX::BRepClassificationTools::IsPointInOnSolid(solid, p);
        CHECK(isPointOnSolid == true);
    }
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API MakePyramid(const Frame3& frame, const std::vector<Point3>& basepoints, const Point3& apex)	 @param apex Apex point
	 @param basepoints Points that are projected onto the base plane
	 @param frame The frame of base plane
	 @brief Construct a pyramid with a given base plane frame
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <modeling/MakePyramid.hpp>
#include <hatch/BRepClassificationTools.hpp>
TEST_CASE("case2: MakePyramid(p1, p2, p3, p4, apex) ", "[modeling][MakePyramid][P1]")
{ 
    Point3 p1(-2.0, 1.0, -1.0);
    Point3 p2(1.0, 3.0, 0.0);
    Point3 p3(4.0, -1.0, 1.0);
    Point3 p4(-1.0, -2.0, 0.0);
    Point3 apex(1.0, -1.0, -4.5);
    CHECK_THROWS_AS( AMCAX::MakePyramid(p1, p2, p3, p4, apex), AMCAX::_ConstructionError );
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API MakePyramid(const Point3& baseLocation, const std::vector<Point3>& basepoints, const Point3& apex)	 @param apex Apex point
	 @param basepoints The base points that are projected onto the base plane
	 @param baseLocation The location of the base plane
	 @details The base plane are determined by the location point and the first two base points
	 @brief Construct a pyramid with a given location on the base plane
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <modeling/MakePyramid.hpp>
#include <hatch/BRepClassificationTools.hpp>
TEST_CASE("case1: MakePyramid(basepoints, apex)  ", "[modeling][MakePyramid][P1]")
{
    Point3 p1(-2.0, 1.0, 0.0);
    Point3 p2(1.0, -3.0, 0.0);
    Point3 p3(-1.0, -2.5, 0.0);
    Point3 apex(5.0, 3.0, 4.5);
    std::vector<Point3> points = { p1, p2, p3};
    TopoShape shape = AMCAX::MakePyramid(points, apex);
    AMCAX::GlobalProperty props;
    CHECK(GetSurfaceProperties(shape, props, true, false) == Approx(47.6096343921));
    CHECK(GetVolumeProperties(shape, props, true, false) == Approx(4.875));
    CHECK(shape.Type() == ShapeType::Solid);
    CHECK(OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX"MakePyramid3_case01.brep"));
    TopoSolid solid = AMCAX::TopoCast::Solid(shape);
    CHECK(AMCAX::BRepClassificationTools::IsPointInOnSolid(solid, apex));
    for (const Point3& p : points) {
        bool isPointOnSolid = AMCAX::BRepClassificationTools::IsPointInOnSolid(solid, p);
        CHECK(isPointOnSolid == true);
    }
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API MakeRevol(const TopoShape& s, const Axis3& a, double d, bool copy = false)	 @param copy Whether copy the base shape
	 @param d The rotation angle
	 @param a The rotation axis
	 @param s The base shape
	 @brief Construct from a base shape, a rotation axis and a rotation angle
,
 "output":#include <catch.hpp>
#include<testHelper.h>
#include <modeling/MakeRevol.hpp>
#include <common/PointT.hpp>
#include <topology/TopoVertex.hpp>
#include <common/CartesianCoordinateSystem.hpp>
#include <occtio/OCCTTool.hpp>
#include <topology/TopoBuilder.hpp>
#include <modeling/MakeVertex.hpp>
#include <common/IndexSet.hpp>
#include <topology/TopoExplorerTool.hpp>
#include <topology/TopoTool.hpp>
#include <topology/TopoCast.hpp>
using namespace AMCAX;
TEST_CASE("BUG1:create MakeRevol bug   ", "[modeling][MakeRevol][fixbug][P1]") {
	Point3 p(1.0, 0.0, 0.0);
	TopoVertex v0 = MakeVertex(p);
	TopoShape e = MakeRevol(v0, CartesianCoordinateSystem::OZ(), M_PI_2);
	TopoShape f = MakeRevol(e, CartesianCoordinateSystem::OX(), M_PI_2);
	IndexSet<TopoShape> vertices;
	TopoExplorerTool::MapShapes(f, ShapeType::Vertex, vertices);
	std::cout << TopoTool::Tolerance(TopoCast::Vertex(vertices[0])) << std::endl;
	CHECK(TopoTool::Tolerance(TopoCast::Vertex(vertices[0])) == 1e-07);
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API MakeRevol(const TopoShape& s, const Axis3& a, bool copy = false)	 @param copy Whether copy the base shape
	 @param a The rotation axis
	 @param s The base shape
	 @brief Construct from a base shape and a rotation axis
,
 "output":#include <catch.hpp>
#include<testHelper.h>
#include <modeling/MakeRevol.hpp>
#include <common/PointT.hpp>
#include <topology/TopoVertex.hpp>
#include <common/CartesianCoordinateSystem.hpp>
#include <occtio/OCCTTool.hpp>
#include <topology/TopoBuilder.hpp>
#include <modeling/MakeVertex.hpp>
#include <common/IndexSet.hpp>
#include <topology/TopoExplorerTool.hpp>
#include <topology/TopoTool.hpp>
#include <topology/TopoCast.hpp>
using namespace AMCAX;
TEST_CASE("BUG1:create MakeRevol bug   ", "[modeling][MakeRevol][fixbug][P1]") {
	Point3 p(1.0, 0.0, 0.0);
	TopoVertex v0 = MakeVertex(p);
	TopoShape e = MakeRevol(v0, CartesianCoordinateSystem::OZ(), M_PI_2);
	TopoShape f = MakeRevol(e, CartesianCoordinateSystem::OX(), M_PI_2);
	IndexSet<TopoShape> vertices;
	TopoExplorerTool::MapShapes(f, ShapeType::Vertex, vertices);
	std::cout << TopoTool::Tolerance(TopoCast::Vertex(vertices[0])) << std::endl;
	CHECK(TopoTool::Tolerance(TopoCast::Vertex(vertices[0])) == 1e-07);
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API MakeRightPrism(const Point3& p1, const Point3& p2, const Point3& p3, const Point3& apex)	 @param apex A point on the top plane
	 @param p1,p2,p3 Points on the base plane
	 @brief Construct a right triangular prism
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include<common/Exception.hpp>
#include <modeling/MakeRightPrism.hpp>
#include <hatch/BRepClassificationTools.hpp>
TEST_CASE("case1 MakeRightPrism(p1, p2, p3, apex)  ", "[modeling][MakeRightPrism][P1]")
{
    Point3 p1(0.0, 0.0, 0.0);
    Point3 p2(4.0, 0.0, 0.0);
    Point3 p3(2.0, 4.0, 0.0);
    Point3 apex(0.0, 0.0, 4.5);
    std::vector<Point3> points = { p1, p2, p3, apex };
    TopoShape shape = AMCAX::MakeRightPrism(p1, p2, p3, apex);
    AMCAX::GlobalProperty props;
    CHECK( GetSurfaceProperties(shape, props, true, false) == Approx( 74.249223595));
    CHECK( GetVolumeProperties(shape, props, true, false) == 36.0);
    CHECK(shape.Type() == ShapeType::Solid);
    OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX"MakeRightPrism_01.brep");
    TopoSolid solid = AMCAX::TopoCast::Solid(shape);
    for (const Point3& p : points) {
        bool isPointOnSolid = AMCAX::BRepClassificationTools::IsPointInOnSolid(solid, p);
        CHECK(isPointOnSolid == true);
    }
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API MakeRightPrism(const Point3& p1, const Point3& p2, const Point3& p3, const Point3& p4, const Point3& apex)	 @param apex A point on the top plane
	 @param p1,p2,p3,p4 Points on the base plane
	 @brief Construct a right quadrilateral prism
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include<common/Exception.hpp>
#include <modeling/MakeRightPrism.hpp>
#include <hatch/BRepClassificationTools.hpp>
TEST_CASE("case1 MakeRightPrism(p1, p2, p3, apex)  ", "[modeling][MakeRightPrism][P1]")
{
    Point3 p1(0.0, 0.0, 0.0);
    Point3 p2(4.0, 0.0, 0.0);
    Point3 p3(2.0, 4.0, 0.0);
    Point3 apex(0.0, 0.0, 4.5);
    std::vector<Point3> points = { p1, p2, p3, apex };
    TopoShape shape = AMCAX::MakeRightPrism(p1, p2, p3, apex);
    AMCAX::GlobalProperty props;
    CHECK( GetSurfaceProperties(shape, props, true, false) == Approx( 74.249223595));
    CHECK( GetVolumeProperties(shape, props, true, false) == 36.0);
    CHECK(shape.Type() == ShapeType::Solid);
    OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX"MakeRightPrism_01.brep");
    TopoSolid solid = AMCAX::TopoCast::Solid(shape);
    for (const Point3& p : points) {
        bool isPointOnSolid = AMCAX::BRepClassificationTools::IsPointInOnSolid(solid, p);
        CHECK(isPointOnSolid == true);
    }
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API MakeRightPrism(const std::vector<Point3>& basepoints, const Point3& apex)	 @param apex A point on the top plane
	 @param basepoints Points on the base plane
	 @brief Construct a right prism with base points and a point on the top plane
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include<common/Exception.hpp>
#include <modeling/MakeRightPrism.hpp>
#include <hatch/BRepClassificationTools.hpp>
TEST_CASE("case3 MakeRightPrism(p1, p2, p3, apex)  ", "[modeling][MakeRightPrism][P1]")
{
    Point3 p1(0.0, 0.0, 0.0);
    Point3 p2(4.0, 0.0, 0.0);
    Point3 p3(2.0, 4.0, -2.0);
    Point3 apex(4.0, 0.0, -4.5);
    std::vector<Point3> points = { p1, p2, p3 };
    TopoShape shape = AMCAX::MakeRightPrism(p1, p2, p3, apex);
    AMCAX::GlobalProperty props;
    CHECK(GetSurfaceProperties(shape, props, true, false) == Approx(73.4242573984));
    CHECK(GetVolumeProperties(shape, props, true, false) == 36.0);
    CHECK(shape.Type() == ShapeType::Solid);
    OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX"MakeRightPrism_03.brep");
    TopoSolid solid = AMCAX::TopoCast::Solid(shape);
    for (const Point3& p : points) {
        bool isPointOnSolid = AMCAX::BRepClassificationTools::IsPointInOnSolid(solid, p);
        CHECK(isPointOnSolid == true);
    }
    Point3 p4(2.0, 2.2, -5.6);
    bool isPointOnSolid = AMCAX::BRepClassificationTools::IsPointInOnSolid(solid, p4);
    CHECK(isPointOnSolid == true);
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API MakeRightPrism(const Frame3& frame, double radius, int nside, double height)	 @param height Height of the polygon
	 @param nside Number of sides of the base polygon
	 @param radius Radius of the circumcircle of the base polygon
	 @param frame The local coordinate system
	 @brief Construct a right regular prism
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include<common/Exception.hpp>
#include <modeling/MakeRightPrism.hpp>
#include <hatch/BRepClassificationTools.hpp>
TEST_CASE("bug:case5 MakeRightPrism(p1, p2, p3, apex)  ", "[modeling][MakeRightPrism][P1][fixbug]")
{
    Point3 p1(0.0, 0.0, 0.0);
    Point3 p2(4.0, 0.0, 0.0);
    Point3 p3(6.0, 0.0, 0.0);
    Point3 apex(2.0, 2.0, -4.5);
    std::vector<Point3> points = { p1, p2, p3, apex };
    CHECK_THROWS_AS(AMCAX::MakeRightPrism(p1, p2, p3, apex), AMCAX::_ConstructionError);
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API MakeRightPrism(const Frame3& frame, const Point3& p1, const Point3& p2, const Point3& p3, const Point3& apex)	 @param apex A point on the top plane
	 @param p1,p2,p3 Points that are projected onto the base plane
	 @param frame The frame of base plane
	 @brief Construct a right triangular prism with a given plane frame
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include<common/Exception.hpp>
#include <modeling/MakeRightPrism.hpp>
#include <hatch/BRepClassificationTools.hpp>
TEST_CASE("case1 MakeRightPrism(p1, p2, p3, apex)  ", "[modeling][MakeRightPrism][P1]")
{
    Point3 p1(0.0, 0.0, 0.0);
    Point3 p2(4.0, 0.0, 0.0);
    Point3 p3(2.0, 4.0, 0.0);
    Point3 apex(0.0, 0.0, 4.5);
    std::vector<Point3> points = { p1, p2, p3, apex };
    TopoShape shape = AMCAX::MakeRightPrism(p1, p2, p3, apex);
    AMCAX::GlobalProperty props;
    CHECK( GetSurfaceProperties(shape, props, true, false) == Approx( 74.249223595));
    CHECK( GetVolumeProperties(shape, props, true, false) == 36.0);
    CHECK(shape.Type() == ShapeType::Solid);
    OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX"MakeRightPrism_01.brep");
    TopoSolid solid = AMCAX::TopoCast::Solid(shape);
    for (const Point3& p : points) {
        bool isPointOnSolid = AMCAX::BRepClassificationTools::IsPointInOnSolid(solid, p);
        CHECK(isPointOnSolid == true);
    }
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API MakeRightPrism(const Frame3& frame, const Point3& p1, const Point3& p2, const Point3& p3, const Point3& p4, const Point3& apex)	 @param apex A point on the top plane
	 @param p1,p2,p3,p4 Points that are projected onto the base plane
	 @param frame The frame of base plane
	 @brief Construct a right quadrilateral prism with a given plane frame
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include<common/Exception.hpp>
#include <modeling/MakeRightPrism.hpp>
#include <hatch/BRepClassificationTools.hpp>
TEST_CASE("case2 MakeRightPrism(p1, p2, p3, apex)  ", "[modeling][MakeRightPrism][P1]")
{
    Point3 p1(-2.0, 0.0, -2.0);
    Point3 p2(2.0, 0.0, -2.0);
    Point3 p3(0.0, 4.0, -2.0);
    Point3 apex(-5.0, 999.0, 2.5);
    std::vector<Point3> points = { p1, p2, p3 };
    TopoShape shape = AMCAX::MakeRightPrism(p1, p2, p3, apex);
    AMCAX::GlobalProperty props;
    CHECK(GetSurfaceProperties(shape, props, true, false) == Approx(74.249223595));
    CHECK(GetVolumeProperties(shape, props, true, false) == 36.0);
    CHECK(shape.Type() == ShapeType::Solid);
    OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX"MakeRightPrism_02.brep");
    TopoSolid solid = AMCAX::TopoCast::Solid(shape);
    for (const Point3& p : points) {
        bool isPointOnSolid = AMCAX::BRepClassificationTools::IsPointInOnSolid(solid, p);
        CHECK(isPointOnSolid == true);
    }
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API MakeRightPrism(const Frame3& frame, const std::vector<Point3>& basepoints, const Point3& apex)	 @param apex A point on the top plane
	 @param basepoints Points that are projected onto the base plane
	 @param frame The frame of base plane
	 @brief Construct a right prism with a given base plane frame
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include<common/Exception.hpp>
#include <modeling/MakeRightPrism.hpp>
#include <hatch/BRepClassificationTools.hpp>
TEST_CASE("case1 MakeRightPrism(p1, p2, p3, apex)  ", "[modeling][MakeRightPrism][P1]")
{
    Point3 p1(0.0, 0.0, 0.0);
    Point3 p2(4.0, 0.0, 0.0);
    Point3 p3(2.0, 4.0, 0.0);
    Point3 apex(0.0, 0.0, 4.5);
    std::vector<Point3> points = { p1, p2, p3, apex };
    TopoShape shape = AMCAX::MakeRightPrism(p1, p2, p3, apex);
    AMCAX::GlobalProperty props;
    CHECK( GetSurfaceProperties(shape, props, true, false) == Approx( 74.249223595));
    CHECK( GetVolumeProperties(shape, props, true, false) == 36.0);
    CHECK(shape.Type() == ShapeType::Solid);
    OCCTIO::OCCTTool::Write(shape, OUTPUT_PATH_PREFIX"MakeRightPrism_01.brep");
    TopoSolid solid = AMCAX::TopoCast::Solid(shape);
    for (const Point3& p : points) {
        bool isPointOnSolid = AMCAX::BRepClassificationTools::IsPointInOnSolid(solid, p);
        CHECK(isPointOnSolid == true);
    }
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API MakeRightPrism(const Point3& baseLocation, const std::vector<Point3>& basepoints, const Point3& apex)	 @param apex A point on the top plane
	 @param basepoints The base points that are projected onto the base plane
	 @param baseLocation The location of the base plane
	 @details The base plane are determined by the location point and the first two base points
	 @brief Construct a right prism with a given location on the base plane
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include<common/Exception.hpp>
#include <modeling/MakeRightPrism.hpp>
#include <hatch/BRepClassificationTools.hpp>
TEST_CASE("case2 MakeRightPrism(p1, p2, p3, p4, apex)  ", "[modeling][MakeRightPrism][P1]")
{
	SECTION("4 points on same line") {
        Point3 p1(-1.0, 0.0, 0.0);
        Point3 p2(0.0, 0.0, 0.0);
        Point3 p3(2.0, 0.0, 0.0);
        Point3 p4(4.0, 0.0, 0.0);
        Point3 apex(2.0, 2.0, -4.5);
        std::vector<Point3> points = { p1, p2, p3,p4 };
        CHECK_THROWS_AS(AMCAX::MakeRightPrism(p1, p2, p3, p4, apex), AMCAX::_ConstructionError);
    }
}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static TopoShape SewShape(const std::list<TopoShape>& shapes, double tolerance)	 @return The sewed shape
	 @param tolerance The tolerance
	 @param shapes The shapes to be sewed
	          If some edges do not coincide, the related faces remain unsewed.
	 @details The border edges are merged to common edges under a given tolerance.
	 @brief Sew faces to a shell
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <modeling/MakeShapeTool.hpp>
#include<modeling/MakeFace.hpp>
#include<math/Plane.hpp>
#include <common/CartesianCoordinateSystem.hpp>
#include <topology/TopoExplorerTool.hpp>
TEST_CASE("case1-1: MakeShapeTool::SewShape ", "[modeling][MakeShapeTool][SewShape][P1]")
{
	std::list<TopoShape> shapes;
	shapes.push_back(MakeFace(Plane(), 0.0, 1.0, 0.0, 1.0));
	shapes.push_back(MakeFace(Plane(Frame3(Point3(1.0, 0.0, 0.0), CartesianCoordinateSystem::DX(), -CartesianCoordinateSystem::DZ())), 0.0, 1.0, 0.0, 1.0));
	TopoShape result = MakeShapeTool::SewShape(shapes, Precision::Confusion());
	CHECK(OCCTIO::OCCTTool::Write(result, OUTPUT_PATH_PREFIX"SewShapetest1-0.brep"));
	IndexSet<TopoShape> sf1, sf2, sf3;
	CHECK(GetTopoToolCount(result, AMCAX::ShapeType::Shell, sf1) == 1);
	CHECK(GetTopoToolCount(result, AMCAX::ShapeType::Compound, sf2) == 0);
	CHECK(GetTopoToolCount(result, AMCAX::ShapeType::Face, sf3) == 2);
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API TransformShape(const TopoShape& s, const Transformation3& tr, bool copyGeom = false, bool copyMesh = false)	 @param copyMesh Whether the mesh of the shape is copied
	 @param copyGeom Whether the geometry of the shape is copied
	 @param tr The transformation
	 @param s The shape
	 @brief Construct from a shape with a transformation
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <modeling/MakeSphere.hpp>
#include <modeling/TransformShape.hpp>
#include <topomesh/BRepMeshIncrementalMesh.hpp>
#include <modeling/MakeShapeTool.hpp>
#include <common/TransformationT.hpp>
#include <common/CartesianCoordinateSystem.hpp>
#include <common/GeneralTransformationT.hpp>
#include <modeling/GeneralTransformShape.hpp>
#include <geometry/GlobalProperty.hpp>
#include <occtio/OCCTTool.hpp>
#include <topology/BRepGlobalProperty.hpp>
#include <geometry/Geom3BSplineCurve.hpp>
#include <modeling/MakeEdge.hpp>
#include <topology/TopoTool.hpp>
#include <topology/BRepAdaptorCurve3.hpp>
using namespace AMCAX;
TEST_CASE("bug1: GeneralTransformShape  ", "[modeling][GeneralTransformShape][fixbug]") {
	TopoShape s = MakeSphere(1.0);
	BRepMeshIncrementalMesh mesher(s, 0.005, true);
	MakeShapeTool::EnsureNormalConsistency(s);
	GeneralTransformation3 tr;
	tr.SetAffinity(Frame3(), 5.0);
	s = GeneralTransformShape(s, tr);
	CHECK(s.Type() == AMCAX::ShapeType::Solid);
	CHECK(s.IsNull() == false);
	GlobalProperty prop;
	BRepGlobalProperty::VolumeProperties(s, prop);
	CHECK(prop.Mass() == Approx(20.934791259).epsilon(1e-11));
	Point3 vP = prop.CenterOfMass();
#ifndef WIN_CASE
	CHECK(vP.X() == Approx(0.0).margin(1e-3));
	CHECK(vP.Y() == Approx(0.0).margin(1e-12));
	CHECK(vP.Z() == Approx(0.0).margin(1e-12));
#else
	CHECK(vP.X() == Approx(-2.2218808037914858e-04).epsilon(1e-12));
	CHECK(vP.Y() == Approx(-1.0782779568197278e-16).epsilon(1e-12));
	CHECK(vP.Z() == Approx(-1.6920954211916623e-16).epsilon(1e-12));
#endif
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API TransformShape(const TopoShape& s, const Transformation3& tr, bool copyGeom = false, bool copyMesh = false)	 @param copyMesh Whether the mesh of the shape is copied
	 @param copyGeom Whether the geometry of the shape is copied
	 @param tr The transformation
	 @param s The shape
	 @brief Construct from a shape with a transformation
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <modeling/MakeSphere.hpp>
#include <modeling/TransformShape.hpp>
#include <topomesh/BRepMeshIncrementalMesh.hpp>
#include <modeling/MakeShapeTool.hpp>
#include <common/TransformationT.hpp>
#include <common/CartesianCoordinateSystem.hpp>
#include <common/GeneralTransformationT.hpp>
#include <modeling/GeneralTransformShape.hpp>
#include <geometry/GlobalProperty.hpp>
#include <occtio/OCCTTool.hpp>
#include <topology/BRepGlobalProperty.hpp>
using namespace AMCAX;
TEST_CASE("bug1: TransformShape  ", "[modeling][TransformShape][fixbug]") {
	TopoShape s = MakeSphere(1.0);
	BRepMeshIncrementalMesh mesher(s, 0.005, true);
	MakeShapeTool::EnsureNormalConsistency(s);
	Transformation3 tr;
	tr.SetRotation(CartesianCoordinateSystem::OZ(), M_PI_2);
	s = TransformShape(s, tr, true, true);
	CHECK(s.IsNull() == false);
	CHECK(s.Type() == AMCAX::ShapeType::Solid);
	GlobalProperty prop;
	BRepGlobalProperty::VolumeProperties(s, prop);
	CHECK(prop.Mass() == Approx(4.1887902048).epsilon(1e-11));
	Point3 vP = prop.CenterOfMass();
#ifndef WIN_CASE
	CHECK(vP.X() == Approx(0.0).margin(1e-12));
	CHECK(vP.Y() == Approx(0.0).margin(1e-12));
	CHECK(vP.Z() == Approx(0.0).margin(1e-12));
#else
	CHECK(vP.X() == Approx(-4.0938241231662633e-18).epsilon(1e-12));
	CHECK(vP.Y() == Approx(-6.1820277995281757e-17).epsilon(1e-12));
	CHECK(vP.Z() == Approx(-3.1794228708137405e-17).epsilon(1e-12)); 
#endif
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static std::shared_ptr<Geom3BSplineCurve> ApproxPoints(const std::vector<Point3>& points, int degree, int npoles, bool isClosed = false, ApproxParameterizationType ptype = ApproxParameterizationType::ChordLength)	 @return curve
	 @param ptype parameterization type
	 @param isClosed Is curve closed
	 @param npoles Target number of poles
	 @param degree Target degree
	 @param points Data points to be approximated
	 @brief Approx points to a curve
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <nurbs/NURBSAPIApprox.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <modeling/MakeEdge.hpp>
#include <nurbs/NURBSAPIInterpolate.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
#include <modeling/MakeVertex.hpp>
#include <nurbs/NURBSAPIBuildCurve.hpp>
TEST_CASE("case1: this is a test for Approx", "[nurbs][Approx][P1]")
{
	double refTol = DEFAULT_TOLERANCE;
	SECTION("TestApproxPoints")
	{
		OUTPUT_DIRECTORY(nurbs, Approxs/ApproxPoints);
		std::vector<Point3> points;
		Point3 p1(0.0, 0.0, 0.0);
		Point3 p2(-0.1, 1.0, -0.2);
		Point3 p3(0.1, 2.0, -0.1);
		Point3 p4(0.2, 3.0, 0.1);
		Point3 p5(0.1, 4.0, 0.0);
		Point3 p6(0.0, 5.0, -0.1);
		points.push_back(p1);
		points.push_back(p2);
		points.push_back(p3);
		points.push_back(p4);
		points.push_back(p5);
		points.push_back(p6);
		int degree = 3;
		int npoles = 5;
		auto curve = NURBSAPIApprox::ApproxPoints(points, degree, npoles);
		TopoVertex v1 = MakeVertex(p1);
		TopoVertex v2 = MakeVertex(p2);
		TopoVertex v3 = MakeVertex(p3);
		TopoVertex v4 = MakeVertex(p4);
		TopoVertex v5 = MakeVertex(p5);
		TopoVertex v6 = MakeVertex(p6);
		TopoEdge edge = MakeEdge(curve);
		BRepExtremaDistShapeShape dist1(v1, edge);
		BRepExtremaDistShapeShape dist2(v2, edge);
		BRepExtremaDistShapeShape dist3(v3, edge);
		BRepExtremaDistShapeShape dist4(v4, edge);
		BRepExtremaDistShapeShape dist5(v5, edge);
		BRepExtremaDistShapeShape dist6(v6, edge);
		CHECK(dist1.Value() <= Approx(refTol));
		CHECK(dist2.Value() <= Approx(refTol));
		CHECK(dist3.Value() <= Approx(refTol));
		CHECK(dist4.Value() <= Approx(refTol));
		CHECK(dist5.Value() <= Approx(refTol));
		CHECK(dist6.Value() <= Approx(refTol));
		Point3 sp = curve->StartPoint();
		Point3 ep = curve->EndPoint();
		CHECK(sp.X() == p1.X());
		CHECK(sp.Y() == p1.Y());
		CHECK(sp.Z() == p1.Z());
		CHECK(ep.X() == p6.X());
		CHECK(ep.Y() == p6.Y());
		CHECK(ep.Z() == p6.Z());
		CHECK(curve->Degree() == 3);
		CHECK(curve->NPoles() == 5);
		CHECK(curve->IsClosed() == false);
		CHECK(curve->IsPeriodic() == false);
		OCCTIO::OCCTTool::Write(v1, outdir + "v1.brep");
		OCCTIO::OCCTTool::Write(v2, outdir + "v2.brep");
		OCCTIO::OCCTTool::Write(v3, outdir + "v3.brep");
		OCCTIO::OCCTTool::Write(v4, outdir + "v4.brep");
		OCCTIO::OCCTTool::Write(v5, outdir + "v5.brep");
		OCCTIO::OCCTTool::Write(v6, outdir + "v6.brep");
		OCCTIO::OCCTTool::Write(edge, outdir + "result.brep");
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static std::shared_ptr<Geom3BSplineCurve> BlendCurves( const std::shared_ptr<Geom3BSplineCurve>& curve1, bool isFront1, ContinuityType cont1, const std::shared_ptr<Geom3BSplineCurve>& curve2, bool isFront2, ContinuityType cont2),
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <nurbs/NURBSAPIBlend.hpp>
#include <modeling/MakeEdge.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
#include <modeling/MakeVertex.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <modeling/MakeFace.hpp>
#include <topology/BRepAdaptorCurve3.hpp>
#include <topology/TopoTool.hpp>
#include <io/ShapeTool.hpp>
#include <topology/TopoTool.hpp>
#include <topology/TopoCast.hpp>
#include <geometry/Geom3Surface.hpp>
#include <geometry/Geom3BSplineSurface.hpp>
#include <nurbs/NURBSAPIConvert.hpp>
#include <nurbs/NURBSAPIGetGeometry.hpp>
#include <topology/TopoExplorer.hpp>
#include <topology/TopoExplorerTool.hpp>
double NURBSSampleEdge(int num, double tol, const shared_ptr<Geom3Curve>& curve, const TopoEdge& edge)
{
	double fpu1 = curve->FirstParameter();
	double lpu1 = curve->LastParameter();
	double delta = (lpu1 - fpu1) / num;
	Point3 p;
	int n = 0;
	for (int i = 0; i < num; i++) {
		double t = fpu1 + i * delta;
		curve->D0(t, p);
		if (BRepClassificationTools::IsPointInOnEdge(edge, p, tol))
		{
			n++;
		}
	}
	double r1 = 1.0 * (num - n) / num;
	return r1;
}
TopoEdge ChooseSimilarEdge(const TopoShape& shape, const TopoEdge& edge)
{
	int nsample = 1000;
	Point3 p1, p2;
	BRepAdaptorCurve3 refC(edge);
	double refFp = refC.FirstParameter();
	double refLp = refC.LastParameter();
	for (TopoExplorer ex(shape, ShapeType::Edge); ex.More(); ex.Next())
	{
		const TopoEdge& cre = static_cast<const TopoEdge&>((ex.Current()));
		BRepAdaptorCurve3 crC(edge);
		double crFp = crC.FirstParameter();
		double crLp = crC.LastParameter();
		if (std::abs(refFp - crFp) < 0.001 && std::abs(refLp - crLp) < 0.001)
		{
			bool isOK = true;
			for (int i = 0; i < nsample; i++)
			{
				double t1 = refFp + i * (refLp - refFp) / (nsample - 1);
				double t2 = crFp + i * (crLp - crFp) / (nsample - 1);
				refC.D0(t1, p1);
				crC.D0(t2, p2);
				if (p1.Distance(p2) > 0.001)
				{
					isOK = false;
					break;
				}
			}
			if (isOK)
			{
				return cre;
			}
		}
	}
	TopoEdge e;
	return e;
}
TEST_CASE("case1: this is a test for testBlendCurves", "[nurbs][Blend][P1]")
{
	int num = 1000;	
	double ratio = 0.1;
	double refTol = DEFAULT_TOLERANCE;
	SECTION("testBlendCurves")
	{
		OUTPUT_DIRECTORY(nurbs, Blend/BlendCurves);
		auto cont1 = ContinuityType::G2;
		auto cont2 = ContinuityType::G2;
		bool isFront1 = true;
		bool isFront2 = true;
		std::shared_ptr<Geom3BSplineCurve> bsp1, bsp2;
		{
			std::vector<Point3> poles;
			poles.push_back(Point3(0., -1., 0.));
			poles.push_back(Point3(.7, -.7, 0.));
			poles.push_back(Point3(1., -.3, 0.));
			poles.push_back(Point3(1.2, 0., 0.));
			poles.push_back(Point3(2., .3, 0.));
			poles.push_back(Point3(.7, 1.7, 0.));
			poles.push_back(Point3(0., 1., 0.));
			std::vector<double> weights;
			weights.push_back(1.0);
			weights.push_back(1.3);
			weights.push_back(1.2);
			weights.push_back(0.7);
			weights.push_back(1.3);
			weights.push_back(1.0);
			weights.push_back(1.2);
			std::vector<double> knots;
			knots.push_back(0.);
			knots.push_back(.25);
			knots.push_back(.5);
			knots.push_back(.75);
			knots.push_back(1.);
			std::vector<int> mults(5, 1);
			mults.front() = 4;
			mults.back() = 4;
			bsp1 = std::make_shared<Geom3BSplineCurve>(poles, weights, knots, mults, 3);
		}
		{
			std::vector<Point3> spinePoles;
			std::vector<double> spineKnots(4);
			std::vector<int> spineMults(4, 1);
			spinePoles.push_back(Point3(0.0, 0.0, 0.0));
			spinePoles.push_back(Point3(-0.1, 1.0, -0.2));
			spinePoles.push_back(Point3(0.1, 2.0, -0.1));
			spinePoles.push_back(Point3(0.2, 3.0, 0.1));
			spinePoles.push_back(Point3(0.1, 4.0, 0.0));
			spinePoles.push_back(Point3(0.0, 5.0, -0.1));
			std::vector<double> weights;
			weights.push_back(1.0);
			weights.push_back(1.3);
			weights.push_back(1.2);
			weights.push_back(0.7);
			weights.push_back(1.3);
			weights.push_back(1.0);
			spineKnots[0] = 0;
			spineKnots[1] = 1.0 / 3.0;
			spineKnots[2] = 2.0 / 3.0;
			spineKnots[3] = 1;
			spineMults.front() = 4;
			spineMults.back() = 4;
			bsp2 = std::make_shared<Geom3BSplineCurve>(spinePoles, weights, spineKnots, spineMults, 3);
		}
		std::vector<double> params1, params2;
		auto bsp3 = NURBSAPIBlend::BlendCurves(bsp1, isFront1, cont1, params1, bsp2, isFront2, cont2, params2);
		Point3 sp1 = bsp1->StartPoint();
		Point3 ep1 = bsp1->EndPoint();
		Point3 sp2 = bsp2->StartPoint();
		Point3 ep2 = bsp2->EndPoint();
		Point3 sp3 = bsp3->StartPoint();
		Point3 ep3 = bsp3->EndPoint();
		CHECK(sp3.X() == Approx(sp1.X()).margin(1e-7));
		CHECK(sp3.Y() == Approx(sp1.Y()));
		CHECK(sp3.Z() == Approx(sp1.Z()));
		CHECK(ep3.X() == Approx(sp2.X()).margin(1e-7));
		CHECK(ep3.Y() == Approx(sp2.Y()).margin(1e-7));
		CHECK(ep3.Z() == Approx(sp2.Z()).margin(1e-7));
		shared_ptr<Geom3BSplineCurve> bspCurve = ReadBRepCurve(INPUT_PATH_PREFIX "/TestNURBS/TestBlendCurves/Rhino/rhinoResult.brep");
		double res = NurbsSampleCurve(num, refTol, bsp3, bspCurve);
		CHECK(res <= ratio);
		OCCTIO::OCCTTool::Write(MakeEdge(bsp1), outdir + "src1.brep");
		OCCTIO::OCCTTool::Write(MakeEdge(bsp2), outdir + "src2.brep");
		OCCTIO::OCCTTool::Write(MakeEdge(bsp3), outdir + "result.brep");
		OCCTIO::OCCTTool::Write(MakeEdge(bspCurve), outdir + "rhinoResult.brep");
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static std::shared_ptr<Geom3BSplineCurve> BlendCurves( const std::shared_ptr<Geom3BSplineCurve>& curve1, bool isFront1, ContinuityType cont1, std::vector<double>& parameters1, const std::shared_ptr<Geom3BSplineCurve>& curve2, bool isFront2, ContinuityType cont2, std::vector<double>& parameters2),
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <nurbs/NURBSAPIBlend.hpp>
#include <modeling/MakeEdge.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
#include <modeling/MakeVertex.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <modeling/MakeFace.hpp>
#include <topology/BRepAdaptorCurve3.hpp>
#include <topology/TopoTool.hpp>
#include <io/ShapeTool.hpp>
#include <topology/TopoTool.hpp>
#include <topology/TopoCast.hpp>
#include <geometry/Geom3Surface.hpp>
#include <geometry/Geom3BSplineSurface.hpp>
#include <nurbs/NURBSAPIConvert.hpp>
#include <nurbs/NURBSAPIGetGeometry.hpp>
#include <topology/TopoExplorer.hpp>
#include <topology/TopoExplorerTool.hpp>
double NURBSSampleEdge(int num, double tol, const shared_ptr<Geom3Curve>& curve, const TopoEdge& edge)
{
	double fpu1 = curve->FirstParameter();
	double lpu1 = curve->LastParameter();
	double delta = (lpu1 - fpu1) / num;
	Point3 p;
	int n = 0;
	for (int i = 0; i < num; i++) {
		double t = fpu1 + i * delta;
		curve->D0(t, p);
		if (BRepClassificationTools::IsPointInOnEdge(edge, p, tol))
		{
			n++;
		}
	}
	double r1 = 1.0 * (num - n) / num;
	return r1;
}
TopoEdge ChooseSimilarEdge(const TopoShape& shape, const TopoEdge& edge)
{
	int nsample = 1000;
	Point3 p1, p2;
	BRepAdaptorCurve3 refC(edge);
	double refFp = refC.FirstParameter();
	double refLp = refC.LastParameter();
	for (TopoExplorer ex(shape, ShapeType::Edge); ex.More(); ex.Next())
	{
		const TopoEdge& cre = static_cast<const TopoEdge&>((ex.Current()));
		BRepAdaptorCurve3 crC(edge);
		double crFp = crC.FirstParameter();
		double crLp = crC.LastParameter();
		if (std::abs(refFp - crFp) < 0.001 && std::abs(refLp - crLp) < 0.001)
		{
			bool isOK = true;
			for (int i = 0; i < nsample; i++)
			{
				double t1 = refFp + i * (refLp - refFp) / (nsample - 1);
				double t2 = crFp + i * (crLp - crFp) / (nsample - 1);
				refC.D0(t1, p1);
				crC.D0(t2, p2);
				if (p1.Distance(p2) > 0.001)
				{
					isOK = false;
					break;
				}
			}
			if (isOK)
			{
				return cre;
			}
		}
	}
	TopoEdge e;
	return e;
}
TEST_CASE("bug2: TestBridgeTrimmedPeriodicFace ", "[nurbs][Blend][fixbug]")
{
	int num = 1000;
	double ratio = 0.1;
	double refTol = DEFAULT_TOLERANCE;
	SECTION("TestBridgeCurve2")
	{
		OUTPUT_DIRECTORY(nurbs, Blend/bug680/BridgeCurve2);
		std::string filedir = INPUT_PATH_PREFIX "/TestNURBS/TestBridgeCurve2/";
		auto curve1 = ReadBRepCurve(filedir + "curve1.brep");
		auto curve2 = ReadBRepCurve(filedir + "curve2.brep");
		auto bridge = NURBSAPIBlend::BlendCurves(curve1, false, ContinuityType::G2, curve2, true, ContinuityType::G2);
		Point3 sp1 = curve1->StartPoint();
		Point3 ep1 = curve1->EndPoint();
		Point3 sp2 = curve2->StartPoint();
		Point3 ep2 = curve2->EndPoint();
		Point3 sp3 = bridge->StartPoint();
		Point3 ep3 = bridge->EndPoint();
		CHECK(sp3.X() == Approx(ep1.X()).margin(1e-7));
		CHECK(sp3.Y() == Approx(ep1.Y()));
		CHECK(sp3.Z() == Approx(ep1.Z()));
		CHECK(ep3.X() == Approx(sp2.X()).margin(1e-7));
		CHECK(ep3.Y() == Approx(sp2.Y()).margin(1e-7));
		CHECK(ep3.Z() == Approx(sp2.Z()).margin(1e-7));
		auto curve = ReadBRepCurve(filedir + "Rhino/rhinoResult.brep");
		double res = NurbsSampleCurve(num, refTol, bridge, curve);
		OCCTIO::OCCTTool::Write(MakeEdge(curve1), outdir + "src1.brep");
		OCCTIO::OCCTTool::Write(MakeEdge(curve2), outdir + "src2.brep");
		OCCTIO::OCCTTool::Write(MakeEdge(bridge), outdir + "result.brep");
		OCCTIO::OCCTTool::Write(MakeEdge(curve), outdir + "rhinoResult.brep");
	}
}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static std::shared_ptr<Geom3BSplineSurface> BlendSurfaces( const std::shared_ptr<Geom3BSplineSurface>& surf1, bool isUIso1, bool isFront1, ContinuityType cont1, std::vector<double>& parameters1, const std::shared_ptr<Geom3BSplineSurface>& surf2, bool isUIso2, bool isFront2, ContinuityType cont2, std::vector<double>& parameters2, bool autoReverse, bool isPrecise, const std::vector<double>& tol),
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <nurbs/NURBSAPIBlend.hpp>
#include <modeling/MakeEdge.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
#include <modeling/MakeVertex.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <modeling/MakeFace.hpp>
#include <topology/BRepAdaptorCurve3.hpp>
#include <topology/TopoTool.hpp>
#include <io/ShapeTool.hpp>
#include <topology/TopoTool.hpp>
#include <topology/TopoCast.hpp>
#include <geometry/Geom3Surface.hpp>
#include <geometry/Geom3BSplineSurface.hpp>
#include <nurbs/NURBSAPIConvert.hpp>
#include <nurbs/NURBSAPIGetGeometry.hpp>
#include <topology/TopoExplorer.hpp>
#include <topology/TopoExplorerTool.hpp>
double NURBSSampleEdge(int num, double tol, const shared_ptr<Geom3Curve>& curve, const TopoEdge& edge)
{
	double fpu1 = curve->FirstParameter();
	double lpu1 = curve->LastParameter();
	double delta = (lpu1 - fpu1) / num;
	Point3 p;
	int n = 0;
	for (int i = 0; i < num; i++) {
		double t = fpu1 + i * delta;
		curve->D0(t, p);
		if (BRepClassificationTools::IsPointInOnEdge(edge, p, tol))
		{
			n++;
		}
	}
	double r1 = 1.0 * (num - n) / num;
	return r1;
}
TopoEdge ChooseSimilarEdge(const TopoShape& shape, const TopoEdge& edge)
{
	int nsample = 1000;
	Point3 p1, p2;
	BRepAdaptorCurve3 refC(edge);
	double refFp = refC.FirstParameter();
	double refLp = refC.LastParameter();
	for (TopoExplorer ex(shape, ShapeType::Edge); ex.More(); ex.Next())
	{
		const TopoEdge& cre = static_cast<const TopoEdge&>((ex.Current()));
		BRepAdaptorCurve3 crC(edge);
		double crFp = crC.FirstParameter();
		double crLp = crC.LastParameter();
		if (std::abs(refFp - crFp) < 0.001 && std::abs(refLp - crLp) < 0.001)
		{
			bool isOK = true;
			for (int i = 0; i < nsample; i++)
			{
				double t1 = refFp + i * (refLp - refFp) / (nsample - 1);
				double t2 = crFp + i * (crLp - crFp) / (nsample - 1);
				refC.D0(t1, p1);
				crC.D0(t2, p2);
				if (p1.Distance(p2) > 0.001)
				{
					isOK = false;
					break;
				}
			}
			if (isOK)
			{
				return cre;
			}
		}
	}
	TopoEdge e;
	return e;
}
TEST_CASE("case1: this is a test for testBlendSurf", "[nurbs][Blend][P1]")
{
	int num = 1000;
	double ratio = 0.1;
	double refTol = DEFAULT_TOLERANCE;
	SECTION("testBridgeSurf")
	{
		OUTPUT_DIRECTORY(nurbs, Blend/BridgeSurf);
		auto surf1 = ReadBRepSurface(INPUT_PATH_PREFIX "/TestNURBS/TestBridgeSurf/surface1.brep");
		auto surf2 = ReadBRepSurface(INPUT_PATH_PREFIX "/TestNURBS/TestBridgeSurf/surface2.brep");
		bool isU1 = true, isFront1 = true, isU2 = true, isFront2 = true;
		ContinuityType cont1 = ContinuityType::G2;
		ContinuityType cont2 = ContinuityType::G2;
		bool isAutoReverse = true;
		bool isPrecise = true;
		std::vector<double> tol;
		tol.push_back(0.001);
		tol.push_back(M_PI / 180.0);
		tol.push_back(0.0005);
		std::vector<double> params1, params2;
		shared_ptr<Geom3BSplineSurface> bspSurf3 = NURBSAPIBlend::BlendSurfaces(surf1, isU2, isFront2, cont1, params1, surf2, isU1, isFront1, cont2, params2, isAutoReverse, isPrecise, tol);
		BRepExtremaDistShapeShape dist1(MakeFace(surf1, 0.0), MakeFace(bspSurf3, 0.0));
		BRepExtremaDistShapeShape dist2(MakeFace(surf2, 0.0), MakeFace(bspSurf3, 0.0));
		CHECK(dist1.Value() == Approx(0.0).margin(0.1));
		CHECK(dist2.Value() == Approx(0.0).margin(0.1));
		double fpu1 = bspSurf3->FirstUParameter();
		double lpu1 = bspSurf3->LastUParameter();
		shared_ptr<Geom3Curve> u1 = bspSurf3->UIso(fpu1);
		shared_ptr<Geom3Curve> u2 = bspSurf3->UIso(lpu1);
		double f1 = surf1->FirstUParameter();
		double f2 = surf2->FirstUParameter();
		shared_ptr<Geom3Curve> c1 = surf1->UIso(f1);
		shared_ptr<Geom3Curve> c2 = surf2->UIso(f2);
		bool res1 = IsCurveOnSurf(num, ratio, u1, surf1);
		bool res2 = IsCurveOnSurf(num, ratio, u2, surf2);
		CHECK(res1 == true);
		CHECK(res2 == true);
		double res3 = NurbsSampleCurve(num, refTol, c1, u1);
		double res4 = NurbsSampleCurve(num, refTol, c2, u2);
		CHECK(res3 <= ratio);
		CHECK(res4 <= ratio);
		OCCTIO::OCCTTool::Write(MakeEdge(u1), outdir + "u1.brep");
		OCCTIO::OCCTTool::Write(MakeEdge(u2), outdir + "u2.brep");
		OCCTIO::OCCTTool::Write(MakeEdge(c1), outdir + "c1.brep");
		OCCTIO::OCCTTool::Write(MakeEdge(c2), outdir + "c2.brep");
		OCCTIO::OCCTTool::Write(MakeFace(surf1, 0.0), outdir + "src1.brep");
		OCCTIO::OCCTTool::Write(MakeFace(surf2, 0.0), outdir + "src2.brep");
		OCCTIO::OCCTTool::Write(MakeFace(bspSurf3, 0.0), outdir + "result.brep");
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static std::shared_ptr<Geom3BSplineSurface> BlendFaces( const TopoFace& face1, const TopoEdge& edge1, ContinuityType cont1, std::vector<double>& parameters1, const TopoFace& face2, const TopoEdge& edge2, ContinuityType cont2, std::vector<double>& parameters2, bool autoReverse, bool isPrecise, const std::vector<double>& tol),
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <nurbs/NURBSAPIBlend.hpp>
#include <modeling/MakeEdge.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
#include <modeling/MakeVertex.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <modeling/MakeFace.hpp>
#include <topology/BRepAdaptorCurve3.hpp>
#include <topology/TopoTool.hpp>
#include <io/ShapeTool.hpp>
#include <topology/TopoTool.hpp>
#include <topology/TopoCast.hpp>
#include <geometry/Geom3Surface.hpp>
#include <geometry/Geom3BSplineSurface.hpp>
#include <nurbs/NURBSAPIConvert.hpp>
#include <nurbs/NURBSAPIGetGeometry.hpp>
#include <topology/TopoExplorer.hpp>
#include <topology/TopoExplorerTool.hpp>
double NURBSSampleEdge(int num, double tol, const shared_ptr<Geom3Curve>& curve, const TopoEdge& edge)
{
	double fpu1 = curve->FirstParameter();
	double lpu1 = curve->LastParameter();
	double delta = (lpu1 - fpu1) / num;
	Point3 p;
	int n = 0;
	for (int i = 0; i < num; i++) {
		double t = fpu1 + i * delta;
		curve->D0(t, p);
		if (BRepClassificationTools::IsPointInOnEdge(edge, p, tol))
		{
			n++;
		}
	}
	double r1 = 1.0 * (num - n) / num;
	return r1;
}
TopoEdge ChooseSimilarEdge(const TopoShape& shape, const TopoEdge& edge)
{
	int nsample = 1000;
	Point3 p1, p2;
	BRepAdaptorCurve3 refC(edge);
	double refFp = refC.FirstParameter();
	double refLp = refC.LastParameter();
	for (TopoExplorer ex(shape, ShapeType::Edge); ex.More(); ex.Next())
	{
		const TopoEdge& cre = static_cast<const TopoEdge&>((ex.Current()));
		BRepAdaptorCurve3 crC(edge);
		double crFp = crC.FirstParameter();
		double crLp = crC.LastParameter();
		if (std::abs(refFp - crFp) < 0.001 && std::abs(refLp - crLp) < 0.001)
		{
			bool isOK = true;
			for (int i = 0; i < nsample; i++)
			{
				double t1 = refFp + i * (refLp - refFp) / (nsample - 1);
				double t2 = crFp + i * (crLp - crFp) / (nsample - 1);
				refC.D0(t1, p1);
				crC.D0(t2, p2);
				if (p1.Distance(p2) > 0.001)
				{
					isOK = false;
					break;
				}
			}
			if (isOK)
			{
				return cre;
			}
		}
	}
	TopoEdge e;
	return e;
}
TEST_CASE("bug3: TestBridgeTrimmedPeriodicFace ", "[nurbs][Blend][fixbug]")
{
	OUTPUT_DIRECTORY(nurbs, Blend/bug684/testBlendFaces);
	std::string filedir = INPUT_PATH_PREFIX "/TestNURBS/TestBlendFaces/";
	TopoFace f1 = ReadBRepFace(filedir + "surfaceShapeFrom1.brep");
	TopoFace f2 = ReadBRepFace(filedir + "surfaceShapeFrom2.brep");
	vector<TopoEdge>vec1;
	vector<TopoEdge>vec2;
	for (TopoExplorer exp(f1, ShapeType::Edge); exp.More(); exp.Next())
	{
		TopoEdge c1 = static_cast<const TopoEdge&>(exp.Current());
		vec1.push_back(c1);
	}
	for (TopoExplorer expE(f2, ShapeType::Edge); expE.More(); expE.Next())
	{
		TopoEdge c2 = static_cast<const TopoEdge&>(expE.Current());
		vec2.push_back(c2);
	}
	vector<double>parameters1 = { 1.0, 1.0 };
	vector<double>parameters2 = { 1.0, 1.0 };
	vector<double>tol = { 0.001, 0.1 * M_PI / 180.0, 0.05 };
	for (int i = 0; i < vec1.size(); i++)
	{
		for (int j = 0; j < vec2.size(); j++)
		{
			shared_ptr<Geom3BSplineSurface> blendSurface = NURBSAPIBlend::BlendFaces(f1, vec1[i], ContinuityType::G2, parameters1, f2, vec2[j], ContinuityType::G2, parameters2, true, true, tol);
			OCCTIO::OCCTTool::Write(MakeFace(blendSurface, 0.0), outdir + "G2-result" + to_string(i + 1) + to_string(j + 1) + ".brep");
		}
	}
	OCCTIO::OCCTTool::Write(f1, outdir + "f1.brep");
	OCCTIO::OCCTTool::Write(f2, outdir + "f2.brep");
	OCCTIO::OCCTTool::Write(vec1[0], outdir + "e1.brep");
	OCCTIO::OCCTTool::Write(vec1[1], outdir + "e2.brep");
	OCCTIO::OCCTTool::Write(vec1[2], outdir + "e3.brep");
	OCCTIO::OCCTTool::Write(vec1[3], outdir + "e4.brep");
	OCCTIO::OCCTTool::Write(vec2[0], outdir + "e11.brep");
	OCCTIO::OCCTTool::Write(vec2[1], outdir + "e22.brep");
	OCCTIO::OCCTTool::Write(vec2[2], outdir + "e33.brep");
	OCCTIO::OCCTTool::Write(vec2[3], outdir + "e44.brep");
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static std::shared_ptr<Geom3BSplineCurve> BlendCurves( const std::shared_ptr<Geom3BSplineCurve>& curve1, bool isFront1, ContinuityType cont1, const std::shared_ptr<Geom3BSplineCurve>& curve2, bool isFront2, ContinuityType cont2),
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <nurbs/NURBSAPIBlend.hpp>
#include <modeling/MakeEdge.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
#include <modeling/MakeVertex.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <modeling/MakeFace.hpp>
#include <topology/BRepAdaptorCurve3.hpp>
#include <topology/TopoTool.hpp>
#include <io/ShapeTool.hpp>
#include <topology/TopoTool.hpp>
#include <topology/TopoCast.hpp>
#include <geometry/Geom3Surface.hpp>
#include <geometry/Geom3BSplineSurface.hpp>
#include <nurbs/NURBSAPIConvert.hpp>
#include <nurbs/NURBSAPIGetGeometry.hpp>
#include <topology/TopoExplorer.hpp>
#include <topology/TopoExplorerTool.hpp>
#include <geometry/Geom3CurveLocalProperty.hpp>
TEST_CASE("Not Fix bug1: testBlendCurves2-Extend ", "[nurbs][Blend][bug]")
{
	std::shared_ptr<Geom3BSplineCurve> bsp1, bsp2;
	{
		std::vector<Point3> poles;
		poles.push_back(Point3(0., -1., 0.));
		poles.push_back(Point3(.7, -.7, 0.));
		poles.push_back(Point3(1., -.3, 0.));
		poles.push_back(Point3(1.2, 0., 0.));
		poles.push_back(Point3(2., .3, 0.));
		poles.push_back(Point3(.7, 1.7, 0.));
		poles.push_back(Point3(0., 1., 0.));
		std::vector<double> weights;
		weights.push_back(1.0);
		weights.push_back(1.3);
		weights.push_back(1.2);
		weights.push_back(0.7);
		weights.push_back(1.3);
		weights.push_back(1.0);
		weights.push_back(1.2);
		std::vector<double> knots;
		knots.push_back(0.);
		knots.push_back(.25);
		knots.push_back(.5);
		knots.push_back(.75);
		knots.push_back(1.);
		std::vector<int> mults(5, 1);
		mults.front() = 4;
		mults.back() = 4;
		bsp1 = std::make_shared<Geom3BSplineCurve>(poles, weights, knots, mults, 3);
	}
	{
		std::vector<Point3> spinePoles;
		std::vector<double> spineKnots(4);
		std::vector<int> spineMults(4, 1);
		spinePoles.push_back(Point3(0.0, 0.0, 0.0));
		spinePoles.push_back(Point3(-0.1, 1.0, -0.2));
		spinePoles.push_back(Point3(0.1, 2.0, -0.1));
		spinePoles.push_back(Point3(0.2, 3.0, 0.1));
		spinePoles.push_back(Point3(0.1, 4.0, 0.0));
		spinePoles.push_back(Point3(0.0, 5.0, -0.1));
		std::vector<double> weights;
		weights.push_back(1.0);
		weights.push_back(1.3);
		weights.push_back(1.2);
		weights.push_back(0.7);
		weights.push_back(1.3);
		weights.push_back(1.0);
		spineKnots[0] = 0;
		spineKnots[1] = 1.0 / 3.0;
		spineKnots[2] = 2.0 / 3.0;
		spineKnots[3] = 1;
		spineMults.front() = 4;
		spineMults.back() = 4;
		bsp2 = std::make_shared<Geom3BSplineCurve>(spinePoles, weights, spineKnots, spineMults, 3);
	}
	double lp1 = bsp1->LastParameter();
	Point3 p1, pp1, p2, pp2;
	Vector3 ev1;
	bsp1->D1(lp1, pp1, ev1);
	std::vector<double> params1, params2;
	auto cont1 = ContinuityType::G2;
	auto cont2 = ContinuityType::G2;
	SECTION("false+true")
	{
		OUTPUT_DIRECTORY(nurbs, Blend/Extend/bug792);
		bool isFront1 = false;
		bool isFront2 = true;
		auto bsp3 = NURBSAPIBlend::BlendCurves(bsp1, isFront1, cont1, params1, bsp2, isFront2, cont2, params2);
		double fp3 = bsp3->FirstParameter();
		Point3 p3;
		Vector3 sv3;
		bsp3->D1(fp3, p3, sv3);
		bool res1 = Direction3(sv3).IsParallel(Direction3(ev1), Precision::Angular());
		CHECK(res1 == true);
		OCCTIO::OCCTTool::Write(MakeVertex(p3), outdir + "p3.brep");
		OCCTIO::OCCTTool::Write(MakeVertex(pp1), outdir + "pp1.brep");
		OCCTIO::OCCTTool::Write(MakeEdge(bsp1), outdir + "src1.brep");
		OCCTIO::OCCTTool::Write(MakeEdge(bsp2), outdir + "src2.brep");
		OCCTIO::OCCTTool::Write(MakeEdge(bsp3), outdir + "result.brep");
	}
}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static std::shared_ptr<Geom3BSplineCurve> BlendCurves( const std::shared_ptr<Geom3BSplineCurve>& curve1, bool isFront1, ContinuityType cont1, std::vector<double>& parameters1, const std::shared_ptr<Geom3BSplineCurve>& curve2, bool isFront2, ContinuityType cont2, std::vector<double>& parameters2),
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <nurbs/NURBSAPIBlend.hpp>
#include <modeling/MakeEdge.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
#include <modeling/MakeVertex.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <modeling/MakeFace.hpp>
#include <topology/BRepAdaptorCurve3.hpp>
#include <topology/TopoTool.hpp>
#include <io/ShapeTool.hpp>
#include <topology/TopoTool.hpp>
#include <topology/TopoCast.hpp>
#include <geometry/Geom3Surface.hpp>
#include <geometry/Geom3BSplineSurface.hpp>
#include <nurbs/NURBSAPIConvert.hpp>
#include <nurbs/NURBSAPIGetGeometry.hpp>
#include <topology/TopoExplorer.hpp>
#include <topology/TopoExplorerTool.hpp>
#include <geometry/Geom3CurveLocalProperty.hpp>
TEST_CASE("Not Fix bug1: testBlendCurves2-Extend ", "[nurbs][Blend][bug]")
{
	std::shared_ptr<Geom3BSplineCurve> bsp1, bsp2;
	{
		std::vector<Point3> poles;
		poles.push_back(Point3(0., -1., 0.));
		poles.push_back(Point3(.7, -.7, 0.));
		poles.push_back(Point3(1., -.3, 0.));
		poles.push_back(Point3(1.2, 0., 0.));
		poles.push_back(Point3(2., .3, 0.));
		poles.push_back(Point3(.7, 1.7, 0.));
		poles.push_back(Point3(0., 1., 0.));
		std::vector<double> weights;
		weights.push_back(1.0);
		weights.push_back(1.3);
		weights.push_back(1.2);
		weights.push_back(0.7);
		weights.push_back(1.3);
		weights.push_back(1.0);
		weights.push_back(1.2);
		std::vector<double> knots;
		knots.push_back(0.);
		knots.push_back(.25);
		knots.push_back(.5);
		knots.push_back(.75);
		knots.push_back(1.);
		std::vector<int> mults(5, 1);
		mults.front() = 4;
		mults.back() = 4;
		bsp1 = std::make_shared<Geom3BSplineCurve>(poles, weights, knots, mults, 3);
	}
	{
		std::vector<Point3> spinePoles;
		std::vector<double> spineKnots(4);
		std::vector<int> spineMults(4, 1);
		spinePoles.push_back(Point3(0.0, 0.0, 0.0));
		spinePoles.push_back(Point3(-0.1, 1.0, -0.2));
		spinePoles.push_back(Point3(0.1, 2.0, -0.1));
		spinePoles.push_back(Point3(0.2, 3.0, 0.1));
		spinePoles.push_back(Point3(0.1, 4.0, 0.0));
		spinePoles.push_back(Point3(0.0, 5.0, -0.1));
		std::vector<double> weights;
		weights.push_back(1.0);
		weights.push_back(1.3);
		weights.push_back(1.2);
		weights.push_back(0.7);
		weights.push_back(1.3);
		weights.push_back(1.0);
		spineKnots[0] = 0;
		spineKnots[1] = 1.0 / 3.0;
		spineKnots[2] = 2.0 / 3.0;
		spineKnots[3] = 1;
		spineMults.front() = 4;
		spineMults.back() = 4;
		bsp2 = std::make_shared<Geom3BSplineCurve>(spinePoles, weights, spineKnots, spineMults, 3);
	}
	double lp1 = bsp1->LastParameter();
	Point3 p1, pp1, p2, pp2;
	Vector3 ev1;
	bsp1->D1(lp1, pp1, ev1);
	std::vector<double> params1, params2;
	auto cont1 = ContinuityType::G2;
	auto cont2 = ContinuityType::G2;
	SECTION("false+true")
	{
		OUTPUT_DIRECTORY(nurbs, Blend/Extend/bug792);
		bool isFront1 = false;
		bool isFront2 = true;
		auto bsp3 = NURBSAPIBlend::BlendCurves(bsp1, isFront1, cont1, params1, bsp2, isFront2, cont2, params2);
		double fp3 = bsp3->FirstParameter();
		Point3 p3;
		Vector3 sv3;
		bsp3->D1(fp3, p3, sv3);
		bool res1 = Direction3(sv3).IsParallel(Direction3(ev1), Precision::Angular());
		CHECK(res1 == true);
		OCCTIO::OCCTTool::Write(MakeVertex(p3), outdir + "p3.brep");
		OCCTIO::OCCTTool::Write(MakeVertex(pp1), outdir + "pp1.brep");
		OCCTIO::OCCTTool::Write(MakeEdge(bsp1), outdir + "src1.brep");
		OCCTIO::OCCTTool::Write(MakeEdge(bsp2), outdir + "src2.brep");
		OCCTIO::OCCTTool::Write(MakeEdge(bsp3), outdir + "result.brep");
	}
}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static std::shared_ptr<Geom3BSplineSurface> BlendSurfaces( const std::shared_ptr<Geom3BSplineSurface>& surf1, bool isUIso1, bool isFront1, ContinuityType cont1, std::vector<double>& parameters1, const std::shared_ptr<Geom3BSplineSurface>& surf2, bool isUIso2, bool isFront2, ContinuityType cont2, std::vector<double>& parameters2, bool autoReverse, bool isPrecise, const std::vector<double>& tol),
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <nurbs/NURBSAPIBlend.hpp>
#include <modeling/MakeEdge.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
#include <modeling/MakeVertex.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <modeling/MakeFace.hpp>
#include <topology/BRepAdaptorCurve3.hpp>
#include <topology/TopoTool.hpp>
#include <io/ShapeTool.hpp>
#include <topology/TopoTool.hpp>
#include <topology/TopoCast.hpp>
#include <geometry/Geom3Surface.hpp>
#include <geometry/Geom3BSplineSurface.hpp>
#include <nurbs/NURBSAPIConvert.hpp>
#include <nurbs/NURBSAPIGetGeometry.hpp>
#include <topology/TopoExplorer.hpp>
#include <topology/TopoExplorerTool.hpp>
#include <geometry/Geom3CurveLocalProperty.hpp>
#include <geometry/GeomAPIProjectPointOnCurve3.hpp>
double NURBSSampleEdge1(int num, double tol, const shared_ptr<Geom3Curve>& curve, const TopoEdge& edge)
{
	double fpu1 = curve->FirstParameter();
	double lpu1 = curve->LastParameter();
	double delta = (lpu1 - fpu1) / num;
	Point3 p;
	int n = 0;
	for (int i = 0; i < num; i++) {
		double t = fpu1 + i * delta;
		curve->D0(t, p);
		if (BRepClassificationTools::IsPointInOnEdge(edge, p, tol))
		{
			n++;
		}
	}
	double r1 = 1.0 * (num - n) / num;
	return r1;
}
TopoEdge ChooseSimilarEdge1(const TopoShape& shape, const TopoEdge& edge)
{
	int nsample = 1000;
	Point3 p1, p2;
	BRepAdaptorCurve3 refC(edge);
	double refFp = refC.FirstParameter();
	double refLp = refC.LastParameter();
	for (TopoExplorer ex(shape, ShapeType::Edge); ex.More(); ex.Next())
	{
		const TopoEdge& cre = static_cast<const TopoEdge&>((ex.Current()));
		BRepAdaptorCurve3 crC(edge);
		double crFp = crC.FirstParameter();
		double crLp = crC.LastParameter();
		if (std::abs(refFp - crFp) < 0.001 && std::abs(refLp - crLp) < 0.001)
		{
			bool isOK = true;
			for (int i = 0; i < nsample; i++)
			{
				double t1 = refFp + i * (refLp - refFp) / (nsample - 1);
				double t2 = crFp + i * (crLp - crFp) / (nsample - 1);
				refC.D0(t1, p1);
				crC.D0(t2, p2);
				if (p1.Distance(p2) > 0.001)
				{
					isOK = false;
					break;
				}
			}
			if (isOK)
			{
				return cre;
			}
		}
	}
	TopoEdge e;
	return e;
}
TEST_CASE("Not Fix bug1: testBlendSurfaces-Extend ", "[nurbs][Blend][bug]")
{
	bool isAutoReverse = true;
	bool isPrecise = true;
	std::vector<double> tol;
	tol.push_back(0.001);
	tol.push_back(M_PI / 180.0);
	tol.push_back(0.0005);
	std::vector<double> params1, params2;
	auto surf1 = ReadBRepSurface(INPUT_PATH_PREFIX "/TestNURBS/TestBridgeSurf/surface1.brep");
	auto surf2 = ReadBRepSurface(INPUT_PATH_PREFIX "/TestNURBS/TestBridgeSurf/surface2.brep");
	SECTION("ContinuityType::C0")
	{
		ContinuityType cont1 = ContinuityType::C0;
		ContinuityType cont2 = ContinuityType::C0;
		bool isU1 = false;
		bool isU2 = false;}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static std::shared_ptr<Geom3BSplineSurface> BlendFaces( const TopoFace& face1, const TopoEdge& edge1, ContinuityType cont1, std::vector<double>& parameters1, const TopoFace& face2, const TopoEdge& edge2, ContinuityType cont2, std::vector<double>& parameters2, bool autoReverse, bool isPrecise, const std::vector<double>& tol),
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <nurbs/NURBSAPIBlend.hpp>
#include <modeling/MakeEdge.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
#include <modeling/MakeVertex.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <modeling/MakeFace.hpp>
#include <topology/BRepAdaptorCurve3.hpp>
#include <topology/TopoTool.hpp>
#include <io/ShapeTool.hpp>
#include <topology/TopoTool.hpp>
#include <topology/TopoCast.hpp>
#include <geometry/Geom3Surface.hpp>
#include <geometry/Geom3BSplineSurface.hpp>
#include <nurbs/NURBSAPIConvert.hpp>
#include <nurbs/NURBSAPIGetGeometry.hpp>
#include <topology/TopoExplorer.hpp>
#include <topology/TopoExplorerTool.hpp>
#include <geometry/Geom3CurveLocalProperty.hpp>
#include <geometry/GeomAPIProjectPointOnCurve3.hpp>
double NURBSSampleEdge1(int num, double tol, const shared_ptr<Geom3Curve>& curve, const TopoEdge& edge)
{
	double fpu1 = curve->FirstParameter();
	double lpu1 = curve->LastParameter();
	double delta = (lpu1 - fpu1) / num;
	Point3 p;
	int n = 0;
	for (int i = 0; i < num; i++) {
		double t = fpu1 + i * delta;
		curve->D0(t, p);
		if (BRepClassificationTools::IsPointInOnEdge(edge, p, tol))
		{
			n++;
		}
	}
	double r1 = 1.0 * (num - n) / num;
	return r1;
}
TopoEdge ChooseSimilarEdge1(const TopoShape& shape, const TopoEdge& edge)
{
	int nsample = 1000;
	Point3 p1, p2;
	BRepAdaptorCurve3 refC(edge);
	double refFp = refC.FirstParameter();
	double refLp = refC.LastParameter();
	for (TopoExplorer ex(shape, ShapeType::Edge); ex.More(); ex.Next())
	{
		const TopoEdge& cre = static_cast<const TopoEdge&>((ex.Current()));
		BRepAdaptorCurve3 crC(edge);
		double crFp = crC.FirstParameter();
		double crLp = crC.LastParameter();
		if (std::abs(refFp - crFp) < 0.001 && std::abs(refLp - crLp) < 0.001)
		{
			bool isOK = true;
			for (int i = 0; i < nsample; i++)
			{
				double t1 = refFp + i * (refLp - refFp) / (nsample - 1);
				double t2 = crFp + i * (crLp - crFp) / (nsample - 1);
				refC.D0(t1, p1);
				crC.D0(t2, p2);
				if (p1.Distance(p2) > 0.001)
				{
					isOK = false;
					break;
				}
			}
			if (isOK)
			{
				return cre;
			}
		}
	}
	TopoEdge e;
	return e;
}
TEST_CASE("case1: this is a test for testBlendSurfaces-Extend", "[nurbs][Blend][P1]")
{
	int num = 1000;
	double ratio = 0.1;
	double refTol = DEFAULT_TOLERANCE;
	bool isAutoReverse = true;
	bool isPrecise = true;
	std::vector<double> tol;
	tol.push_back(0.001);
	tol.push_back(M_PI / 180.0);
	tol.push_back(0.0005);
	std::vector<double> params1, params2;
	auto surf1 = ReadBRepSurface(INPUT_PATH_PREFIX "/TestNURBS/TestBridgeSurf/surface1.brep");
	auto surf2 = ReadBRepSurface(INPUT_PATH_PREFIX "/TestNURBS/TestBridgeSurf/surface2.brep");
	double fup1 = surf1->FirstUParameter();
	double lup1 = surf1->LastUParameter();
	double fvp1 = surf1->FirstVParameter();
	double lvp1 = surf1->LastVParameter();
	shared_ptr<Geom3Curve> fuc1 = surf1->UIso(fup1);
	shared_ptr<Geom3Curve> luc1 = surf1->UIso(lup1);
	shared_ptr<Geom3Curve> fvc1 = surf1->VIso(fvp1);
	shared_ptr<Geom3Curve> lvc1 = surf1->VIso(lvp1);
	double uf1 = fuc1->FirstParameter();
	double ul1 = luc1->FirstParameter();
	double vf1 = fvc1->FirstParameter();
	double vl1 = lvc1->FirstParameter();
	Point3 p1, p2 , p3, p4;
	Vector3 fuv1, luv1, fvv1, lvv1;
	fuc1->D1(uf1, p1, fuv1);
	luc1->D1(ul1, p2, luv1);
	fvc1->D1(vf1, p3, fvv1);
	lvc1->D1(vl1, p4, lvv1);
	double fup2 = surf2->FirstUParameter();
	double lup2 = surf2->LastUParameter();
	double fvp2 = surf2->FirstVParameter();
	double lvp2 = surf2->LastVParameter();
	shared_ptr<Geom3Curve> fuc2 = surf2->UIso(fup2);
	shared_ptr<Geom3Curve> luc2 = surf2->UIso(lup2);
	shared_ptr<Geom3Curve> fvc2 = surf2->VIso(fvp2);
	shared_ptr<Geom3Curve> lvc2 = surf2->VIso(lvp2);
	double uf2 = fuc2->FirstParameter();
	double ul2 = luc2->FirstParameter();
	double vf2 = fvc2->FirstParameter();
	double vl2 = lvc2->FirstParameter();
	Point3 p5, p6, p7, p8;
	Vector3 fuv2, luv2, fvv2, lvv2;
	fuc2->D1(uf2, p5, fuv2);
	luc2->D1(ul2, p6, luv2);
	fvc2->D1(vf2, p7, fvv2);
	lvc2->D1(vl2, p8, lvv2);
	SECTION("isFront:true+true")
			{
				OUTPUT_DIRECTORY(nurbs, Blend/Extend/BlendSurfaces/G2/tt/tt);
				bool isFront1 = true;
				bool isFront2 = true;
				shared_ptr<Geom3BSplineSurface> bspSurf3 = NURBSAPIBlend::BlendSurfaces(surf1, isU1, isFront1, cont1, params1, surf2, isU2, isFront2, cont2, params2, isAutoReverse, isPrecise, tol);
				double fpu3 = bspSurf3->FirstUParameter();
				double lpu3 = bspSurf3->LastUParameter();
				shared_ptr<Geom3Curve> fuc3 = bspSurf3->UIso(fpu3);
				shared_ptr<Geom3Curve> luc3 = bspSurf3->UIso(lpu3);
				double res1 = NurbsSampleCurve(num, refTol, fuc3, fuc1);
				double res2 = NurbsSampleCurve(num, refTol, luc3, fuc2);
				CHECK(res1 <= ratio);
				CHECK(res2 <= ratio);
				pair<double, double> res3 = NurbsContinousSample(num, fuc3, fuc1);
				pair<double, double> res4 = NurbsContinousSample(num, luc3, fuc2);
				CHECK(res3.first == 0.0);
				CHECK(res3.second == 0.0);
				CHECK(res4.first == 0.0);
				CHECK(res4.second == 0.0);
				OCCTIO::OCCTTool::Write(MakeEdge(fuc1), outdir + "fuc1.brep");
				OCCTIO::OCCTTool::Write(MakeEdge(fvc1), outdir + "fvc1.brep");
				OCCTIO::OCCTTool::Write(MakeEdge(fuc2), outdir + "fuc2.brep");
				OCCTIO::OCCTTool::Write(MakeEdge(fvc2), outdir + "fvc2.brep");
				OCCTIO::OCCTTool::Write(MakeEdge(fuc3), outdir + "fuc3.brep");
				OCCTIO::OCCTTool::Write(MakeFace(surf1, 0.0), outdir + "src1.brep");
				OCCTIO::OCCTTool::Write(MakeFace(surf2, 0.0), outdir + "src2.brep");
				OCCTIO::OCCTTool::Write(MakeFace(bspSurf3, 0.0), outdir + "result.brep");
			}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static std::shared_ptr<Geom3BSplineCurve> BuildCurve(const std::vector<Point3>& poles, int degree, bool isPeriodic)	 @return The built curve. If building curve is failed, return nullptr
	 @param isPeriodic Whether the curve is periodic or not
	 @param degree The curve degree
	 @param poles Curve poles. If it is a periodic curve, don't include the point at the end that repeats the first point
	 @brief Build BSpline curve
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <nurbs/NURBSAPIBuildCurve.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeVertex.hpp>
#include <nurbs/NURBSAPIExtend.hpp>
#include <geomAlgo/LawConstant.hpp>
#include <nurbs/NURBSAPILinearSweep.hpp>
#include <modeling/MakeFace.hpp>
std::shared_ptr<AMCAX::Geom3BSplineCurve> BuildBSpCurve(const std::vector<AMCAX::Point3>& poles, int degree, bool isPeriodic)
{
	int npoles = static_cast<int>(poles.size());
	if (isPeriodic)
	{
		return AMCAX::NURBSAPIBuildCurve::BuildCurve(poles, std::min(degree, npoles), true);
	}
	else
	{
		return AMCAX::NURBSAPIBuildCurve::BuildCurve(poles, std::min(degree, npoles - 1), false);
	}
}
TEST_CASE("case1: this is a test for testBuildCurve", "[nurbs][BuildCurve][P1]")
{
	SECTION("TestBuildCurve()")
	{
		OUTPUT_DIRECTORY(nurbs, BuildCurve/BuildCurve);
		std::vector<Point3> poles;
		Point3 p1(0.0, 0.0, 0.0);
		Point3 p2(-0.1, 1.0, -0.2);
		Point3 p3(0.1, 2.0, -0.1);
		Point3 p4(0.2, 3.0, 0.1);
		Point3 p5(0.1, 4.0, 0.0);
		Point3 p6(0.0, 5.0, -0.1);
		poles.push_back(p1);
		poles.push_back(p2);
		poles.push_back(p3);
		poles.push_back(p4);
		poles.push_back(p5);
		poles.push_back(p6);
		bool isPeriodic = false;
		int degree = NURBSAPIBuildCurve::ValidMaxDegree(static_cast<int>(poles.size()), isPeriodic);
		degree = std::min(3, degree);
		auto curve = NURBSAPIBuildCurve::BuildCurve(poles, degree, isPeriodic);
		Point3 sp1 = curve->StartPoint();
		Point3 ep1 = curve->EndPoint();
		CHECK(sp1.X() == Approx(p1.X()));
		CHECK(sp1.Y() == Approx(p1.Y()));
		CHECK(sp1.Z() == Approx(p1.Z()));
		CHECK(ep1.X() == Approx(p6.X()).margin(1e-7));
		CHECK(ep1.Y() == Approx(p6.Y()).margin(1e-7));
		CHECK(ep1.Z() == Approx(p6.Z()).margin(1e-7));
		CHECK(curve->Degree() == degree);
		CHECK(curve->NPoles() == 6);
		CHECK(curve->IsPeriodic() == false);
		vector<Point3> vec = curve->Poles();
		CHECK(vec.size() == 6);
		CHECK(vec[0].X() == Approx(p1.X()));
		CHECK(vec[0].Y() == Approx(p1.Y()));
		CHECK(vec[0].Z() == Approx(p1.Z()));
		CHECK(vec[1].X() == Approx(p2.X()));
		CHECK(vec[1].Y() == Approx(p2.Y()));
		CHECK(vec[1].Z() == Approx(p2.Z()));
		CHECK(vec[2].X() == Approx(p3.X()));
		CHECK(vec[2].Y() == Approx(p3.Y()));
		CHECK(vec[2].Z() == Approx(p3.Z()));
		CHECK(vec[3].X() == Approx(p4.X()));
		CHECK(vec[3].Y() == Approx(p4.Y()));
		CHECK(vec[3].Z() == Approx(p4.Z()));
		CHECK(vec[4].X() == Approx(p5.X()));
		CHECK(vec[4].Y() == Approx(p5.Y()));
		CHECK(vec[4].Z() == Approx(p5.Z()));
		CHECK(vec[5].X() == Approx(p6.X()));
		CHECK(vec[5].Y() == Approx(p6.Y()));
		CHECK(vec[5].Z() == Approx(p6.Z()));
		OCCTIO::OCCTTool::Write(MakeVertex(p1), outdir + "p1.brep");
		OCCTIO::OCCTTool::Write(MakeVertex(p2), outdir + "p2.brep");
		OCCTIO::OCCTTool::Write(MakeVertex(p3), outdir + "p3.brep");
		OCCTIO::OCCTTool::Write(MakeVertex(p4), outdir + "p4.brep");
		OCCTIO::OCCTTool::Write(MakeVertex(p5), outdir + "p5.brep");
		OCCTIO::OCCTTool::Write(MakeVertex(p6), outdir + "p6.brep");
		OCCTIO::OCCTTool::Write(MakeEdge(curve), outdir + "result.brep");
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static std::shared_ptr<Geom3BSplineCurve> BuildCurve(const std::vector<Point3>& poles, const std::vector<double>& weights, int degree, bool isPeriodic)	 @return The built curve. If building curve is failed, return nullptr
	 @param isPeriodic Whether the curve is periodic or not
	 @param degree The curve degree
	 @param weights Curve weights
	 @param poles Curve poles. If it is a periodic curve, don't include the point at the end that repeats the first point
	 @brief Build NURBS curve
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <nurbs/NURBSAPIBuildCurve.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeVertex.hpp>
#include <nurbs/NURBSAPIExtend.hpp>
#include <geomAlgo/LawConstant.hpp>
#include <nurbs/NURBSAPILinearSweep.hpp>
#include <modeling/MakeFace.hpp>
std::shared_ptr<AMCAX::Geom3BSplineCurve> BuildBSpCurve(const std::vector<AMCAX::Point3>& poles, int degree, bool isPeriodic)
{
	int npoles = static_cast<int>(poles.size());
	if (isPeriodic)
	{
		return AMCAX::NURBSAPIBuildCurve::BuildCurve(poles, std::min(degree, npoles), true);
	}
	else
	{
		return AMCAX::NURBSAPIBuildCurve::BuildCurve(poles, std::min(degree, npoles - 1), false);
	}
}
TEST_CASE("case1: this is a test for testBuildCurve", "[nurbs][BuildCurve][P1]")
{
	SECTION("TestBuildCurve()")
	{
		OUTPUT_DIRECTORY(nurbs, BuildCurve/BuildCurve);
		std::vector<Point3> poles;
		Point3 p1(0.0, 0.0, 0.0);
		Point3 p2(-0.1, 1.0, -0.2);
		Point3 p3(0.1, 2.0, -0.1);
		Point3 p4(0.2, 3.0, 0.1);
		Point3 p5(0.1, 4.0, 0.0);
		Point3 p6(0.0, 5.0, -0.1);
		poles.push_back(p1);
		poles.push_back(p2);
		poles.push_back(p3);
		poles.push_back(p4);
		poles.push_back(p5);
		poles.push_back(p6);
		bool isPeriodic = false;
		int degree = NURBSAPIBuildCurve::ValidMaxDegree(static_cast<int>(poles.size()), isPeriodic);
		degree = std::min(3, degree);
		auto curve = NURBSAPIBuildCurve::BuildCurve(poles, degree, isPeriodic);
		Point3 sp1 = curve->StartPoint();
		Point3 ep1 = curve->EndPoint();
		CHECK(sp1.X() == Approx(p1.X()));
		CHECK(sp1.Y() == Approx(p1.Y()));
		CHECK(sp1.Z() == Approx(p1.Z()));
		CHECK(ep1.X() == Approx(p6.X()).margin(1e-7));
		CHECK(ep1.Y() == Approx(p6.Y()).margin(1e-7));
		CHECK(ep1.Z() == Approx(p6.Z()).margin(1e-7));
		CHECK(curve->Degree() == degree);
		CHECK(curve->NPoles() == 6);
		CHECK(curve->IsPeriodic() == false);
		vector<Point3> vec = curve->Poles();
		CHECK(vec.size() == 6);
		CHECK(vec[0].X() == Approx(p1.X()));
		CHECK(vec[0].Y() == Approx(p1.Y()));
		CHECK(vec[0].Z() == Approx(p1.Z()));
		CHECK(vec[1].X() == Approx(p2.X()));
		CHECK(vec[1].Y() == Approx(p2.Y()));
		CHECK(vec[1].Z() == Approx(p2.Z()));
		CHECK(vec[2].X() == Approx(p3.X()));
		CHECK(vec[2].Y() == Approx(p3.Y()));
		CHECK(vec[2].Z() == Approx(p3.Z()));
		CHECK(vec[3].X() == Approx(p4.X()));
		CHECK(vec[3].Y() == Approx(p4.Y()));
		CHECK(vec[3].Z() == Approx(p4.Z()));
		CHECK(vec[4].X() == Approx(p5.X()));
		CHECK(vec[4].Y() == Approx(p5.Y()));
		CHECK(vec[4].Z() == Approx(p5.Z()));
		CHECK(vec[5].X() == Approx(p6.X()));
		CHECK(vec[5].Y() == Approx(p6.Y()));
		CHECK(vec[5].Z() == Approx(p6.Z()));
		OCCTIO::OCCTTool::Write(MakeVertex(p1), outdir + "p1.brep");
		OCCTIO::OCCTTool::Write(MakeVertex(p2), outdir + "p2.brep");
		OCCTIO::OCCTTool::Write(MakeVertex(p3), outdir + "p3.brep");
		OCCTIO::OCCTTool::Write(MakeVertex(p4), outdir + "p4.brep");
		OCCTIO::OCCTTool::Write(MakeVertex(p5), outdir + "p5.brep");
		OCCTIO::OCCTTool::Write(MakeVertex(p6), outdir + "p6.brep");
		OCCTIO::OCCTTool::Write(MakeEdge(curve), outdir + "result.brep");
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static int ValidMaxDegree(int npoles, bool isPeriodic)	 @return The maximum valid degree
	 @param isPeriodic Whether the curve is periodic
	 @param npoles The number of control points
	 @brief Given the number of the control points, calculate the maximum valide degree of a BSpline curve
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <nurbs/NURBSAPIBuildCurve.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeVertex.hpp>
#include <nurbs/NURBSAPIExtend.hpp>
#include <geomAlgo/LawConstant.hpp>
#include <nurbs/NURBSAPILinearSweep.hpp>
#include <modeling/MakeFace.hpp>
std::shared_ptr<AMCAX::Geom3BSplineCurve> BuildBSpCurve(const std::vector<AMCAX::Point3>& poles, int degree, bool isPeriodic)
{
	int npoles = static_cast<int>(poles.size());
	if (isPeriodic)
	{
		return AMCAX::NURBSAPIBuildCurve::BuildCurve(poles, std::min(degree, npoles), true);
	}
	else
	{
		return AMCAX::NURBSAPIBuildCurve::BuildCurve(poles, std::min(degree, npoles - 1), false);
	}
}
TEST_CASE("case1: this is a test for testBuildCurve-IncreaseDegree", "[nurbs][BuildCurve][P2]")
{
	int num = 1000;
	double ratio = 0.1;
	double refTol = DEFAULT_TOLERANCE;
	SECTION("TestExtendFourPointsDynamic")
	{
		OUTPUT_DIRECTORY(nurbs,BuildCurve/ExtendFourPointsDynamic);
		std::vector<Point3> poles;
		Point3 p1(0.0, 0.0, 0.0);
		Point3 p2(0.0, 1.0, 0.0);
		Point3 p3(1.0, 1.0, 0.0);
		Point3 p4(1.0, 0.0, 0.0);
		poles.push_back(p1);
		poles.push_back(p2);
		poles.push_back(p3);
		poles.push_back(p4);
		std::vector<double> weights;
		weights.push_back(1.0);
		weights.push_back(1.2);
		weights.push_back(1.1);
		weights.push_back(1.0);
		auto oldcurve = NURBSAPIBuildCurve::BuildCurve(poles, weights, 3, false);
		int maxDeg = NURBSAPIBuildCurve::ValidMaxDegree(static_cast<int>(poles.size()), false);
		auto curve = NURBSAPIBuildCurve::BuildCurve(poles, weights, maxDeg, false);
		CHECK(curve->Degree() == maxDeg);
		double res33 = NurbsSampleCurve(num, ratio, oldcurve, curve);
		CHECK(res33 <= refTol);
		Point3 sp1 = curve->StartPoint();
		Point3 ep1 = curve->EndPoint();
		CHECK(sp1.X() == Approx(p1.X()));
		CHECK(sp1.Y() == Approx(p1.Y()));
		CHECK(sp1.Z() == Approx(p1.Z()));
		CHECK(ep1.X() == Approx(p4.X()));
		CHECK(ep1.Y() == Approx(p4.Y()));
		CHECK(ep1.Z() == Approx(p4.Z()));
		CHECK(curve->IsPeriodic() == false);
		OCCTIO::OCCTTool::Write(MakeVertex(p1), outdir + "p1.brep");
		OCCTIO::OCCTTool::Write(MakeVertex(p2), outdir + "p2.brep");
		OCCTIO::OCCTTool::Write(MakeVertex(p3), outdir + "p3.brep");
		OCCTIO::OCCTTool::Write(MakeVertex(p4), outdir + "p4.brep");
		OCCTIO::OCCTTool::Write(MakeEdge(curve), outdir + "result.brep");
		Point3 p(-1.0, -1.0, 0.0);
		auto extendedCurve = NURBSAPIExtend::ExtendCurveToDynamicPoint(curve, false, p);
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static std::pair<NURBSSweepStatus, std::shared_ptr<Geom3BSplineSurface>> SweepWithThreeGuides(const std::shared_ptr<Geom3BSplineCurve>& guide1, const std::shared_ptr<Geom3BSplineCurve>& guide2, const std::shared_ptr<Geom3BSplineCurve>& guide3, const std::shared_ptr<Geom3BSplineCurve>& spine, double spineLeftBound, double spineRightBound),
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <filesystem>
#include <fstream>
#include <random>
#include <sstream>
#include <nurbs/NURBSAPIGetGeometry.hpp>
#include <nurbs/NURBSAPIConicalSweep.hpp>
#include <boolean/BoolBRepCut.hpp>
#include <common/CartesianCoordinateSystem.hpp>
#include <common/IndexMap.hpp>
#include <common/QuaternionT.hpp>
#include <geomAlgo/LawBSpline.hpp>
#include <geomAlgo/LawConstant.hpp>
#include <nurbs/NURBSAPISmooth.hpp>
#include <geomAlgo/MakeConic2FromConstraints.hpp>
#include <geometry/Adaptor3CurveOnSurface.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/AdaptorGeom3Surface.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/Geom2Circle.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/Geom2Hyperbola.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom3BSplineCurve.hpp>
#include <geometry/Geom3BSplineSurface.hpp>
#include <geometry/Geom3Circle.hpp>
#include <geometry/Geom3Line.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
#include <geometry/Geom3Plane.hpp>
#include <geometry/Geom3SphericalSurface.hpp>
#include <geometry/Geom3Surface.hpp>
#include <geometry/Geom3TrimmedCurve.hpp>
#include <geometry/Geom3TrimmedSurface.hpp>
#include <geometry/GeomAPIExtremaCurveCurve3.hpp>
#include <geometry/GeomAPIProjectPointOnCurve2.hpp>
#include <geometry/GeomAPIProjectPointOnCurve3.hpp>
#include <geometry/GeomAPIProjectPointOnSurface.hpp>
#include <geometry/GeometryTool.hpp>
#include <geometry/GlobalProperty.hpp>
#include <healing/ShapeFixTool.hpp>
#include <io/STLTool.hpp>
#include <math/Sphere.hpp>
#include <math/TriangularMesh.hpp>
#include <modeling/CopyShape.hpp>
#include <modeling/MakeBox.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeFace.hpp>
#include <modeling/MakePrism.hpp>
#include <modeling/MakeRevol.hpp>
#include <modeling/MakeShapeTool.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeWire.hpp>
#include <modeling/TransformShape.hpp>
#include <nurbs/NURBSAPIApprox.hpp>
#include <nurbs/NURBSAPIBuildCurve.hpp>
#include <nurbs/NURBSAPICircularSweep.hpp>
#include <nurbs/NURBSAPIConvert.hpp>
#include <nurbs/NURBSAPICurveNetworkSurface.hpp>
#include <nurbs/NURBSAPIExplicitSweep.hpp>
#include <nurbs/NURBSAPIExplode.hpp>
#include <nurbs/NURBSAPIExtend.hpp>
#include <nurbs/NURBSAPIInterpolate.hpp>
#include <nurbs/NURBSAPIJoin.hpp>
#include <nurbs/NURBSAPILinearSweep.hpp>
#include <nurbs/NURBSAPILoft.hpp>
#include <nurbs/NURBSAPIMakeNURBSFromBoundaries.hpp>
#include <nurbs/NURBSAPIMatch.hpp>
#include <nurbs/NURBSAPIModifyEndToPlane.hpp>
#include <nurbs/NURBSAPIOffsetCurveOnSurface.hpp>
#include <nurbs/NURBSAPIProject.hpp>
#include <nurbs/NURBSAPIRebuild.hpp>
#include <nurbs/NURBSAPIReplaceEdge.hpp>
#include <nurbs/NURBSAPISweep.hpp>
#include <nurbs/NURBSAPISweep2.hpp>
#include <nurbs/NURBSAPISweepRotation.hpp>
#include <nurbs/NURBSAPITrim.hpp>
#include <nurbs/NURBSAPIUntrim.hpp>
#include <nurbs/NURBSLinearSweepWithDraftDirectionLength.hpp>
#include <occtio/OCCTTool.hpp>
#include <offset/MakePipe.hpp>
#include <offset/MakePipeShell.hpp>
#include <topology/BRepAdaptorCurve2.hpp>
#include <topology/BRepAdaptorCurve3.hpp>
#include <topology/BRepAdaptorSurface.hpp>
#include <topology/BRepGlobalProperty.hpp>
#include <topology/BRepTool.hpp>
#include <topology/TopoBuilder.hpp>
#include <topology/TopoCompound.hpp>
#include <topology/TopoEdge.hpp>
#include <topology/TopoExplorer.hpp>
#include <topology/TopoExplorerTool.hpp>
#include <topology/TopoFace.hpp>
#include <topology/TopoShape.hpp>
#include <topology/TopoShell.hpp>
#include <topology/TopoTool.hpp>
#include <topology/TopoVertex.hpp>
#include <topology/TopoWire.hpp>
#include <topology/WireExplorer.hpp>
#include <topomesh/BRepMeshIncrementalMesh.hpp>
#include <nurbs/NURBSAPIBlend.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
#include <math/LineT.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/GeomAPIIntSurfaceSurface.hpp>
using namespace AMCAX;
namespace
{
	std::shared_ptr<Geom3BSplineCurve> CurveChooser(const int id, const std::shared_ptr<Geom3BSplineCurve>& curve0, const std::shared_ptr<Geom3BSplineCurve>& curve1, const std::shared_ptr<Geom3BSplineCurve>& curve2)
	{
		std::shared_ptr<Geom3BSplineCurve> result;
		switch (id)
		{
		case 0:
		{
			result = curve0;
			break;
		}
		case 1:
		{
			result = curve1;
			break;
		}
		case 2:
		{
			result = curve2;
			break;
		}
		}
		return result;
	}
} 
TEST_CASE("case1:this is a case for CircularSweep", "[nurbs][forcase1][Circular]")
{
	GlobalProperty g;
	SECTION("TestCircularSweepWithThreeGuides2()")
	{
		std::string filedir(INPUT_PATH_PREFIX "/TestNURBS/TestCircularSweepWithThreeGuides2/");
		auto guide1 = ReadBRepCurve(filedir + "guide1.brep");
		auto guide2 = ReadBRepCurve(filedir + "guide2.brep");
		auto guide3 = ReadBRepCurve(filedir + "guide3.brep");
		auto spine = guide1;
		CHECK(OCCTIO::OCCTTool::Write(MakeEdge(guide1), OUTPUT_PATH_PREFIX "TestCircularSweepWithThreeGuides2_guide1.brep"));
		CHECK(OCCTIO::OCCTTool::Write(MakeEdge(guide2), OUTPUT_PATH_PREFIX "TestCircularSweepWithThreeGuides2_guide2.brep"));
		CHECK(OCCTIO::OCCTTool::Write(MakeEdge(guide3), OUTPUT_PATH_PREFIX "TestCircularSweepWithThreeGuides2_guide3.brep"));
		CHECK(OCCTIO::OCCTTool::Write(MakeEdge(spine), OUTPUT_PATH_PREFIX "TestCircularSweepWithThreeGuides2_spine.brep"));
		auto [status, surface] = NURBSAPICircularSweep::SweepWithThreeGuides(guide1, guide2, guide3, spine, spine->FirstParameter(), spine->LastParameter());
		CHECK(status == NURBSSweepStatus::Success);
		if (status == NURBSSweepStatus::Success && surface)
		{
			CHECK(OCCTIO::OCCTTool::Write(MakeFace(surface, 0.0), OUTPUT_PATH_PREFIX "TestCircularSweepWithThreeGuides2_result.brep"));
			AMCAX::BRepExtremaDistShapeShape len1(MakeEdge(guide1), MakeFace(surface, 0.0));
			AMCAX::BRepExtremaDistShapeShape len2(MakeFace(surface, 0.0), MakeEdge(guide2));
			AMCAX::BRepExtremaDistShapeShape len3(MakeFace(surface, 0.0), MakeEdge(spine));
			CHECK(len1.Value() < 0.1);
			CHECK(len2.Value() < 0.1);
			CHECK(len3.Value() < 0.1);
			CHECK(IsCurveOnSurf(1000, 0.1, guide1, surface, 0.1));
			CHECK(IsCurveOnSurf(1000, 0.1, guide2, surface, 0.2));
			CHECK(IsCurveOnSurf(1000, 0.1, spine, surface, 0.1));
			IndexSet<TopoShape> newshapeEdge1;
			TopoExplorerTool::MapShapes(MakeFace(surface, 0.0), ShapeType::Edge, newshapeEdge1);
			TopoExplorer ex0(newshapeEdge1[0], ShapeType::Edge);
			TopoExplorer ex1(newshapeEdge1[2], ShapeType::Edge);
			TopoEdge e0 = static_cast<const TopoEdge&>(ex0.Value());
			TopoEdge e1 = static_cast<const TopoEdge&>(ex1.Value());
			auto edge0 = NURBSAPIGetGeometry::GetCurve(e0);
			auto edge1 = NURBSAPIGetGeometry::GetCurve(e1);
			double n0 = NurbsSampleCurve(100, 0.1, edge0, spine);
			double n1 = NurbsSampleCurve(100, 0.3, edge1, guide3);
			CHECK(n0 < 0.2);
			CHECK(n1 < 0.3);
		}
		spine->IncreaseDegree(5);
		guide1->IncreaseDegree(5);
		guide2->IncreaseDegree(5);
		guide3->IncreaseDegree(5);
		auto [status1, surface1] = NURBSAPICircularSweep::SweepWithThreeGuides(guide1, guide2, guide3, spine, spine->FirstParameter(), spine->LastParameter());
		CHECK(status1 == NURBSSweepStatus::Success);
		double bsp3s = GetSurfaceProperties(MakeFace(surface1, 0.0), g, true, true);
		double bsp4s = GetSurfaceProperties(MakeFace(surface, 0.0), g, true, true);
		CHECK(bsp3s == Approx(bsp4s).margin(0.1));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static std::pair<NURBSSweepStatus, std::vector<std::shared_ptr<Geom3BSplineSurface>>> SweepWithTwoGuidesAndRadius(const std::shared_ptr<Geom3BSplineCurve>& guide1, const std::shared_ptr<Geom3BSplineCurve>& guide2, const LawFunction& radiusLaw, const std::shared_ptr<Geom3BSplineCurve>& spine, double spineLeftBound, double spineRightBound),
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <filesystem>
#include <fstream>
#include <random>
#include <sstream>
#include <nurbs/NURBSAPIGetGeometry.hpp>
#include <nurbs/NURBSAPIConicalSweep.hpp>
#include <boolean/BoolBRepCut.hpp>
#include <common/CartesianCoordinateSystem.hpp>
#include <common/IndexMap.hpp>
#include <common/QuaternionT.hpp>
#include <geomAlgo/LawBSpline.hpp>
#include <geomAlgo/LawConstant.hpp>
#include <nurbs/NURBSAPISmooth.hpp>
#include <geomAlgo/MakeConic2FromConstraints.hpp>
#include <geometry/Adaptor3CurveOnSurface.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/AdaptorGeom3Surface.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/Geom2Circle.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/Geom2Hyperbola.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom3BSplineCurve.hpp>
#include <geometry/Geom3BSplineSurface.hpp>
#include <geometry/Geom3Circle.hpp>
#include <geometry/Geom3Line.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
#include <geometry/Geom3Plane.hpp>
#include <geometry/Geom3SphericalSurface.hpp>
#include <geometry/Geom3Surface.hpp>
#include <geometry/Geom3TrimmedCurve.hpp>
#include <geometry/Geom3TrimmedSurface.hpp>
#include <geometry/GeomAPIExtremaCurveCurve3.hpp>
#include <geometry/GeomAPIProjectPointOnCurve2.hpp>
#include <geometry/GeomAPIProjectPointOnCurve3.hpp>
#include <geometry/GeomAPIProjectPointOnSurface.hpp>
#include <geometry/GeometryTool.hpp>
#include <geometry/GlobalProperty.hpp>
#include <healing/ShapeFixTool.hpp>
#include <io/STLTool.hpp>
#include <math/Sphere.hpp>
#include <math/TriangularMesh.hpp>
#include <modeling/CopyShape.hpp>
#include <modeling/MakeBox.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeFace.hpp>
#include <modeling/MakePrism.hpp>
#include <modeling/MakeRevol.hpp>
#include <modeling/MakeShapeTool.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeWire.hpp>
#include <modeling/TransformShape.hpp>
#include <nurbs/NURBSAPIApprox.hpp>
#include <nurbs/NURBSAPIBuildCurve.hpp>
#include <nurbs/NURBSAPICircularSweep.hpp>
#include <nurbs/NURBSAPIConvert.hpp>
#include <nurbs/NURBSAPICurveNetworkSurface.hpp>
#include <nurbs/NURBSAPIExplicitSweep.hpp>
#include <nurbs/NURBSAPIExplode.hpp>
#include <nurbs/NURBSAPIExtend.hpp>
#include <nurbs/NURBSAPIInterpolate.hpp>
#include <nurbs/NURBSAPIJoin.hpp>
#include <nurbs/NURBSAPILinearSweep.hpp>
#include <nurbs/NURBSAPILoft.hpp>
#include <nurbs/NURBSAPIMakeNURBSFromBoundaries.hpp>
#include <nurbs/NURBSAPIMatch.hpp>
#include <nurbs/NURBSAPIModifyEndToPlane.hpp>
#include <nurbs/NURBSAPIOffsetCurveOnSurface.hpp>
#include <nurbs/NURBSAPIProject.hpp>
#include <nurbs/NURBSAPIRebuild.hpp>
#include <nurbs/NURBSAPIReplaceEdge.hpp>
#include <nurbs/NURBSAPISweep.hpp>
#include <nurbs/NURBSAPISweep2.hpp>
#include <nurbs/NURBSAPISweepRotation.hpp>
#include <nurbs/NURBSAPITrim.hpp>
#include <nurbs/NURBSAPIUntrim.hpp>
#include <nurbs/NURBSLinearSweepWithDraftDirectionLength.hpp>
#include <occtio/OCCTTool.hpp>
#include <offset/MakePipe.hpp>
#include <offset/MakePipeShell.hpp>
#include <topology/BRepAdaptorCurve2.hpp>
#include <topology/BRepAdaptorCurve3.hpp>
#include <topology/BRepAdaptorSurface.hpp>
#include <topology/BRepGlobalProperty.hpp>
#include <topology/BRepTool.hpp>
#include <topology/TopoBuilder.hpp>
#include <topology/TopoCompound.hpp>
#include <topology/TopoEdge.hpp>
#include <topology/TopoExplorer.hpp>
#include <topology/TopoExplorerTool.hpp>
#include <topology/TopoFace.hpp>
#include <topology/TopoShape.hpp>
#include <topology/TopoShell.hpp>
#include <topology/TopoTool.hpp>
#include <topology/TopoVertex.hpp>
#include <topology/TopoWire.hpp>
#include <topology/WireExplorer.hpp>
#include <topomesh/BRepMeshIncrementalMesh.hpp>
#include <nurbs/NURBSAPIBlend.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
#include <math/LineT.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/GeomAPIIntSurfaceSurface.hpp>
using namespace AMCAX;
namespace
{
	std::shared_ptr<Geom3BSplineCurve> CurveChooser(const int id, const std::shared_ptr<Geom3BSplineCurve>& curve0, const std::shared_ptr<Geom3BSplineCurve>& curve1, const std::shared_ptr<Geom3BSplineCurve>& curve2)
	{
		std::shared_ptr<Geom3BSplineCurve> result;
		switch (id)
		{
		case 0:
		{
			result = curve0;
			break;
		}
		case 1:
		{
			result = curve1;
			break;
		}
		case 2:
		{
			result = curve2;
			break;
		}
		}
		return result;
	}
} 
TEST_CASE("case1:this is a case for CircularSweep", "[nurbs][forcase1][Circular]")
{
	GlobalProperty g;
	SECTION("TestCircularSweepWithTwoGuidesAndRadius()")
	{
		std::string filedir(INPUT_PATH_PREFIX "/TestNURBS/TestCircularSweepWithTwoGuidesAndRadius/");
		auto guide1 = ReadBRepCurve(filedir + "guide1.brep");
		auto guide2 = ReadBRepCurve(filedir + "guide2.brep");
		auto spine = ReadBRepCurve(filedir + "spine.brep");
		CHECK(OCCTIO::OCCTTool::Write(MakeEdge(guide1), OUTPUT_PATH_PREFIX "TestCircularSweepWithTwoGuidesAndRadius_guide1.brep"));
		CHECK(OCCTIO::OCCTTool::Write(MakeEdge(guide2), OUTPUT_PATH_PREFIX "TestCircularSweepWithTwoGuidesAndRadius_guide2.brep"));
		CHECK(OCCTIO::OCCTTool::Write(MakeEdge(spine), OUTPUT_PATH_PREFIX "TestCircularSweepWithTwoGuidesAndRadius_spine.brep"));
		LawConstant radiusLaw;
		radiusLaw.Set(10.0, 0.0, 1.0);
		auto [status, surfaces] = NURBSAPICircularSweep::SweepWithTwoGuidesAndRadius(guide1, guide2, radiusLaw, spine, spine->FirstParameter(), spine->LastParameter());
		CHECK(status == NURBSSweepStatus::Success);
		if (status == NURBSSweepStatus::Success && !surfaces.empty())
		{
			CHECK(OCCTIO::OCCTTool::Write(MakeFace(surfaces.front(), 0.0), OUTPUT_PATH_PREFIX "TestCircularSweepWithTwoGuidesAndRadius_result.brep"));
			for (int i = 0; i < surfaces.size(); i++)
			{
				CHECK(OCCTIO::OCCTTool::Write(MakeFace(surfaces[i], 0.0), OUTPUT_PATH_PREFIX "TestCircularSweepWithTwoGuidesAndRadius_result" + std::to_string(i) + ".brep"));
				AMCAX::BRepExtremaDistShapeShape len1(MakeEdge(guide1), MakeFace(surfaces[i], 0.0));
				AMCAX::BRepExtremaDistShapeShape len2(MakeFace(surfaces[i], 0.0), MakeEdge(guide2));
				AMCAX::BRepExtremaDistShapeShape len3(MakeFace(surfaces[i], 0.0), MakeEdge(spine));
				CHECK(len1.Value() < 0.1);
				CHECK(len2.Value() < 0.1);
				CHECK(IsCurveOnSurf(1000, 0.1, guide1, surfaces[i], 0.1));
				CHECK(IsCurveOnSurf(1000, 0.1, guide2, surfaces[i], 0.1));
			}
		}
		spine->IncreaseDegree(11);
		guide1->IncreaseDegree(11);
		guide2->IncreaseDegree(11);
		auto [status1, surfaces1] = NURBSAPICircularSweep::SweepWithTwoGuidesAndRadius(guide1, guide2, radiusLaw, spine, spine->FirstParameter(), spine->LastParameter());
		CHECK(status1 == NURBSSweepStatus::Success);
		for (int i = 0; i < surfaces.size(); i++)
		{
			CHECK(OCCTIO::OCCTTool::Write(MakeFace(surfaces[i], 0.0), OUTPUT_PATH_PREFIX "TestCircularSweepWithTwoGuidesAndRadius_degree11result" + std::to_string(i) + ".brep"));
			double bsp3s = GetSurfaceProperties(MakeFace(surfaces1[i], 0.0), g, true, true);
			double bsp4s = GetSurfaceProperties(MakeFace(surfaces[i], 0.0), g, true, true);
			CHECK(bsp3s == Approx(bsp4s).margin(0.02));
		}
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static std::pair<NURBSSweepStatus, std::shared_ptr<Geom3BSplineSurface>> SweepWithCenterAndTwoAngles(const std::shared_ptr<Geom3BSplineCurve>& centerCurve, const std::shared_ptr<Geom3BSplineCurve>& referenceCurve, const LawFunction& angleLaw1, const LawFunction& angleLaw2, const std::shared_ptr<Geom3BSplineCurve>& spine, double spineLeftBound, double spineRightBound),
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <filesystem>
#include <fstream>
#include <random>
#include <sstream>
#include <nurbs/NURBSAPIGetGeometry.hpp>
#include <nurbs/NURBSAPIConicalSweep.hpp>
#include <boolean/BoolBRepCut.hpp>
#include <common/CartesianCoordinateSystem.hpp>
#include <common/IndexMap.hpp>
#include <common/QuaternionT.hpp>
#include <geomAlgo/LawBSpline.hpp>
#include <geomAlgo/LawConstant.hpp>
#include <nurbs/NURBSAPISmooth.hpp>
#include <geomAlgo/MakeConic2FromConstraints.hpp>
#include <geometry/Adaptor3CurveOnSurface.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/AdaptorGeom3Surface.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/Geom2Circle.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/Geom2Hyperbola.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom3BSplineCurve.hpp>
#include <geometry/Geom3BSplineSurface.hpp>
#include <geometry/Geom3Circle.hpp>
#include <geometry/Geom3Line.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
#include <geometry/Geom3Plane.hpp>
#include <geometry/Geom3SphericalSurface.hpp>
#include <geometry/Geom3Surface.hpp>
#include <geometry/Geom3TrimmedCurve.hpp>
#include <geometry/Geom3TrimmedSurface.hpp>
#include <geometry/GeomAPIExtremaCurveCurve3.hpp>
#include <geometry/GeomAPIProjectPointOnCurve2.hpp>
#include <geometry/GeomAPIProjectPointOnCurve3.hpp>
#include <geometry/GeomAPIProjectPointOnSurface.hpp>
#include <geometry/GeometryTool.hpp>
#include <geometry/GlobalProperty.hpp>
#include <healing/ShapeFixTool.hpp>
#include <io/STLTool.hpp>
#include <math/Sphere.hpp>
#include <math/TriangularMesh.hpp>
#include <modeling/CopyShape.hpp>
#include <modeling/MakeBox.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeFace.hpp>
#include <modeling/MakePrism.hpp>
#include <modeling/MakeRevol.hpp>
#include <modeling/MakeShapeTool.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeWire.hpp>
#include <modeling/TransformShape.hpp>
#include <nurbs/NURBSAPIApprox.hpp>
#include <nurbs/NURBSAPIBuildCurve.hpp>
#include <nurbs/NURBSAPICircularSweep.hpp>
#include <nurbs/NURBSAPIConvert.hpp>
#include <nurbs/NURBSAPICurveNetworkSurface.hpp>
#include <nurbs/NURBSAPIExplicitSweep.hpp>
#include <nurbs/NURBSAPIExplode.hpp>
#include <nurbs/NURBSAPIExtend.hpp>
#include <nurbs/NURBSAPIInterpolate.hpp>
#include <nurbs/NURBSAPIJoin.hpp>
#include <nurbs/NURBSAPILinearSweep.hpp>
#include <nurbs/NURBSAPILoft.hpp>
#include <nurbs/NURBSAPIMakeNURBSFromBoundaries.hpp>
#include <nurbs/NURBSAPIMatch.hpp>
#include <nurbs/NURBSAPIModifyEndToPlane.hpp>
#include <nurbs/NURBSAPIOffsetCurveOnSurface.hpp>
#include <nurbs/NURBSAPIProject.hpp>
#include <nurbs/NURBSAPIRebuild.hpp>
#include <nurbs/NURBSAPIReplaceEdge.hpp>
#include <nurbs/NURBSAPISweep.hpp>
#include <nurbs/NURBSAPISweep2.hpp>
#include <nurbs/NURBSAPISweepRotation.hpp>
#include <nurbs/NURBSAPITrim.hpp>
#include <nurbs/NURBSAPIUntrim.hpp>
#include <nurbs/NURBSLinearSweepWithDraftDirectionLength.hpp>
#include <occtio/OCCTTool.hpp>
#include <offset/MakePipe.hpp>
#include <offset/MakePipeShell.hpp>
#include <topology/BRepAdaptorCurve2.hpp>
#include <topology/BRepAdaptorCurve3.hpp>
#include <topology/BRepAdaptorSurface.hpp>
#include <topology/BRepGlobalProperty.hpp>
#include <topology/BRepTool.hpp>
#include <topology/TopoBuilder.hpp>
#include <topology/TopoCompound.hpp>
#include <topology/TopoEdge.hpp>
#include <topology/TopoExplorer.hpp>
#include <topology/TopoExplorerTool.hpp>
#include <topology/TopoFace.hpp>
#include <topology/TopoShape.hpp>
#include <topology/TopoShell.hpp>
#include <topology/TopoTool.hpp>
#include <topology/TopoVertex.hpp>
#include <topology/TopoWire.hpp>
#include <topology/WireExplorer.hpp>
#include <topomesh/BRepMeshIncrementalMesh.hpp>
#include <nurbs/NURBSAPIBlend.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
#include <math/LineT.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/GeomAPIIntSurfaceSurface.hpp>
using namespace AMCAX;
namespace
{
	std::shared_ptr<Geom3BSplineCurve> CurveChooser(const int id, const std::shared_ptr<Geom3BSplineCurve>& curve0, const std::shared_ptr<Geom3BSplineCurve>& curve1, const std::shared_ptr<Geom3BSplineCurve>& curve2)
	{
		std::shared_ptr<Geom3BSplineCurve> result;
		switch (id)
		{
		case 0:
		{
			result = curve0;
			break;
		}
		case 1:
		{
			result = curve1;
			break;
		}
		case 2:
		{
			result = curve2;
			break;
		}
		}
		return result;
	}
} 
TEST_CASE("case1:this is a case for CircularSweep", "[nurbs][forcase1][Circular]")
{
	GlobalProperty g;
	SECTION("TestCircularSweepWithCenterAndTwoAngles2()")
	{
		std::string filedir(INPUT_PATH_PREFIX "/TestNURBS/TestCircularSweepWithCenterAndTwoAngles2/");
		auto center = ReadBRepCurve(filedir + "center.brep");
		auto ref = ReadBRepCurve(filedir + "ref.brep");
		auto spine = center;
		CHECK(OCCTIO::OCCTTool::Write(MakeEdge(center), OUTPUT_PATH_PREFIX "TestCircularSweepWithCenterAndTwoAngles2_center.brep"));
		CHECK(OCCTIO::OCCTTool::Write(MakeEdge(ref), OUTPUT_PATH_PREFIX "TestCircularSweepWithCenterAndTwoAngles2_ref.brep"));
		CHECK(OCCTIO::OCCTTool::Write(MakeEdge(spine), OUTPUT_PATH_PREFIX "TestCircularSweepWithCenterAndTwoAngles2_spine.brep"));
		LawConstant angleLaw1;
		angleLaw1.Set(-M_PI_4, 0.0, 1.0);
		LawConstant angleLaw2;
		angleLaw2.Set(M_PI_4, 0.0, 1.0);
		auto [status, surface] = NURBSAPICircularSweep::SweepWithCenterAndTwoAngles(center, ref, angleLaw1, angleLaw2, spine, spine->FirstParameter(), spine->LastParameter());
		CHECK(status == NURBSSweepStatus::Success);
		if (status == NURBSSweepStatus::Success && surface)
		{
			CHECK(OCCTIO::OCCTTool::Write(MakeFace(surface, 0.0), OUTPUT_PATH_PREFIX "TestCircularSweepWithCenterAndTwoAngles2_result.brep"));
			AMCAX::BRepExtremaDistShapeShape len1(MakeEdge(ref), MakeFace(surface, 0.0));
			CHECK(len1.Value() < 0.1);
			CHECK(IsCurveOnSurf(1000, 0.3, ref, surface, 0.1));
		}
		center->IncreaseDegree(11);
		ref->IncreaseDegree(11);
		spine->IncreaseDegree(11);
		auto [status1, surface1] = NURBSAPICircularSweep::SweepWithCenterAndTwoAngles(center, ref, angleLaw1, angleLaw2, spine, spine->FirstParameter(), spine->LastParameter());
		CHECK(status1 == NURBSSweepStatus::Success);
		if (status1 == NURBSSweepStatus::Success && surface)
		{
			CHECK(OCCTIO::OCCTTool::Write(MakeFace(surface, 0.0), OUTPUT_PATH_PREFIX "TestCircularSweepWithCenterAndTwoAngles2_degree11result.brep"));
			AMCAX::BRepExtremaDistShapeShape len1(MakeEdge(ref), MakeFace(surface1, 0.0));
			CHECK(len1.Value() < 0.1);
			CHECK(IsCurveOnSurf(1000, 0.3, ref, surface, 0.1));
			double bsp3s = GetSurfaceProperties(MakeFace(surface1, 0.0), g, true, true);
			double bsp4s = GetSurfaceProperties(MakeFace(surface, 0.0), g, true, true);
			CHECK(bsp3s == Approx(bsp4s).margin(0.02));
		}
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static std::pair<NURBSSweepStatus, std::shared_ptr<Geom3BSplineSurface>> SweepWithCenterAndRadius(const std::shared_ptr<Geom3BSplineCurve>& centerCurve, const LawFunction& radiusLaw, const std::shared_ptr<Geom3BSplineCurve>& spine, double spineLeftBound, double spineRightBound),
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <filesystem>
#include <fstream>
#include <random>
#include <sstream>
#include <nurbs/NURBSAPIGetGeometry.hpp>
#include <nurbs/NURBSAPIConicalSweep.hpp>
#include <boolean/BoolBRepCut.hpp>
#include <common/CartesianCoordinateSystem.hpp>
#include <common/IndexMap.hpp>
#include <common/QuaternionT.hpp>
#include <geomAlgo/LawBSpline.hpp>
#include <geomAlgo/LawConstant.hpp>
#include <nurbs/NURBSAPISmooth.hpp>
#include <geomAlgo/MakeConic2FromConstraints.hpp>
#include <geometry/Adaptor3CurveOnSurface.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/AdaptorGeom3Surface.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/Geom2Circle.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/Geom2Hyperbola.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom3BSplineCurve.hpp>
#include <geometry/Geom3BSplineSurface.hpp>
#include <geometry/Geom3Circle.hpp>
#include <geometry/Geom3Line.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
#include <geometry/Geom3Plane.hpp>
#include <geometry/Geom3SphericalSurface.hpp>
#include <geometry/Geom3Surface.hpp>
#include <geometry/Geom3TrimmedCurve.hpp>
#include <geometry/Geom3TrimmedSurface.hpp>
#include <geometry/GeomAPIExtremaCurveCurve3.hpp>
#include <geometry/GeomAPIProjectPointOnCurve2.hpp>
#include <geometry/GeomAPIProjectPointOnCurve3.hpp>
#include <geometry/GeomAPIProjectPointOnSurface.hpp>
#include <geometry/GeometryTool.hpp>
#include <geometry/GlobalProperty.hpp>
#include <healing/ShapeFixTool.hpp>
#include <io/STLTool.hpp>
#include <math/Sphere.hpp>
#include <math/TriangularMesh.hpp>
#include <modeling/CopyShape.hpp>
#include <modeling/MakeBox.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeFace.hpp>
#include <modeling/MakePrism.hpp>
#include <modeling/MakeRevol.hpp>
#include <modeling/MakeShapeTool.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeWire.hpp>
#include <modeling/TransformShape.hpp>
#include <nurbs/NURBSAPIApprox.hpp>
#include <nurbs/NURBSAPIBuildCurve.hpp>
#include <nurbs/NURBSAPICircularSweep.hpp>
#include <nurbs/NURBSAPIConvert.hpp>
#include <nurbs/NURBSAPICurveNetworkSurface.hpp>
#include <nurbs/NURBSAPIExplicitSweep.hpp>
#include <nurbs/NURBSAPIExplode.hpp>
#include <nurbs/NURBSAPIExtend.hpp>
#include <nurbs/NURBSAPIInterpolate.hpp>
#include <nurbs/NURBSAPIJoin.hpp>
#include <nurbs/NURBSAPILinearSweep.hpp>
#include <nurbs/NURBSAPILoft.hpp>
#include <nurbs/NURBSAPIMakeNURBSFromBoundaries.hpp>
#include <nurbs/NURBSAPIMatch.hpp>
#include <nurbs/NURBSAPIModifyEndToPlane.hpp>
#include <nurbs/NURBSAPIOffsetCurveOnSurface.hpp>
#include <nurbs/NURBSAPIProject.hpp>
#include <nurbs/NURBSAPIRebuild.hpp>
#include <nurbs/NURBSAPIReplaceEdge.hpp>
#include <nurbs/NURBSAPISweep.hpp>
#include <nurbs/NURBSAPISweep2.hpp>
#include <nurbs/NURBSAPISweepRotation.hpp>
#include <nurbs/NURBSAPITrim.hpp>
#include <nurbs/NURBSAPIUntrim.hpp>
#include <nurbs/NURBSLinearSweepWithDraftDirectionLength.hpp>
#include <occtio/OCCTTool.hpp>
#include <offset/MakePipe.hpp>
#include <offset/MakePipeShell.hpp>
#include <topology/BRepAdaptorCurve2.hpp>
#include <topology/BRepAdaptorCurve3.hpp>
#include <topology/BRepAdaptorSurface.hpp>
#include <topology/BRepGlobalProperty.hpp>
#include <topology/BRepTool.hpp>
#include <topology/TopoBuilder.hpp>
#include <topology/TopoCompound.hpp>
#include <topology/TopoEdge.hpp>
#include <topology/TopoExplorer.hpp>
#include <topology/TopoExplorerTool.hpp>
#include <topology/TopoFace.hpp>
#include <topology/TopoShape.hpp>
#include <topology/TopoShell.hpp>
#include <topology/TopoTool.hpp>
#include <topology/TopoVertex.hpp>
#include <topology/TopoWire.hpp>
#include <topology/WireExplorer.hpp>
#include <topomesh/BRepMeshIncrementalMesh.hpp>
#include <nurbs/NURBSAPIBlend.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
#include <math/LineT.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/GeomAPIIntSurfaceSurface.hpp>
using namespace AMCAX;
namespace
{
	std::shared_ptr<Geom3BSplineCurve> CurveChooser(const int id, const std::shared_ptr<Geom3BSplineCurve>& curve0, const std::shared_ptr<Geom3BSplineCurve>& curve1, const std::shared_ptr<Geom3BSplineCurve>& curve2)
	{
		std::shared_ptr<Geom3BSplineCurve> result;
		switch (id)
		{
		case 0:
		{
			result = curve0;
			break;
		}
		case 1:
		{
			result = curve1;
			break;
		}
		case 2:
		{
			result = curve2;
			break;
		}
		}
		return result;
	}
} 
TEST_CASE("case1:this is a case for CircularSweep", "[nurbs][forcase1][Circular]")
{
	GlobalProperty g;
	SECTION("TestCircularSweepWithCenterAndRadius()")	
	{
		std::string filedir(INPUT_PATH_PREFIX "/TestNURBS/TestCircularSweepWithCenterAndRadius/");
		auto center = ReadBRepCurve(filedir + "center.brep");
		auto spine = ReadBRepCurve(filedir + "spine.brep");
		CHECK(OCCTIO::OCCTTool::Write(MakeEdge(center), OUTPUT_PATH_PREFIX "TestCircularSweepWithCenterAndRadius_center.brep"));
		CHECK(OCCTIO::OCCTTool::Write(MakeEdge(spine), OUTPUT_PATH_PREFIX "TestCircularSweepWithCenterAndRadius_spine.brep"));
		LawConstant radiusLaw;
		radiusLaw.Set(2.0, 0.0, 1.0);
		auto [status, surface] = NURBSAPICircularSweep::SweepWithCenterAndRadius(center, radiusLaw, spine, spine->FirstParameter(), spine->LastParameter());
		CHECK(status == NURBSSweepStatus::Success);
		if (status == NURBSSweepStatus::Success && surface)
		{
			CHECK(OCCTIO::OCCTTool::Write(MakeFace(surface, 0.0), OUTPUT_PATH_PREFIX "TestCircularSweepWithCenterAndRadius_result.brep"));
			AMCAX::BRepExtremaDistShapeShape len1(MakeEdge(spine), MakeFace(surface, 0.0));
			CHECK(len1.Value() < 1.);
		}
		center->IncreaseDegree(11);
		spine->IncreaseDegree(11);
		cout << "center.degree" << center->Degree() << endl;
		auto [status1, surface1] = NURBSAPICircularSweep::SweepWithCenterAndRadius(center, radiusLaw, spine, spine->FirstParameter(), spine->LastParameter());
		CHECK(status1 == NURBSSweepStatus::Success);
		if (status1 == NURBSSweepStatus::Success && surface1)
		{
			CHECK(OCCTIO::OCCTTool::Write(MakeFace(surface1, 0.0), OUTPUT_PATH_PREFIX "TestCircularSweepWithCenterAndRadius_degree11result.brep"));
			AMCAX::BRepExtremaDistShapeShape len1(MakeEdge(spine), MakeFace(surface1, 0.0));
			CHECK(len1.Value() < 1.);
			double bsp3s = GetSurfaceProperties(MakeFace(surface1, 0.0), g, true, true);
			double bsp4s = GetSurfaceProperties(MakeFace(surface, 0.0), g, true, true);
			CHECK(bsp3s == Approx(bsp4s).margin(0.02));
		}
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static std::pair<NURBSSweepStatus, std::vector<std::shared_ptr<Geom3BSplineSurface>>> SweepWithTwoGuidesAndTangencySurface(const std::shared_ptr<Geom3BSplineCurve>& limitCurveWithTangency, const std::shared_ptr<Geom3BSplineSurface>& tangencySurface, const std::shared_ptr<Geom3BSplineCurve>& limitCurve, const std::shared_ptr<Geom3BSplineCurve>& spine, double spineLeftBound, double spineRightBound),
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <filesystem>
#include <fstream>
#include <random>
#include <sstream>
#include <nurbs/NURBSAPIGetGeometry.hpp>
#include <nurbs/NURBSAPIConicalSweep.hpp>
#include <boolean/BoolBRepCut.hpp>
#include <common/CartesianCoordinateSystem.hpp>
#include <common/IndexMap.hpp>
#include <common/QuaternionT.hpp>
#include <geomAlgo/LawBSpline.hpp>
#include <geomAlgo/LawConstant.hpp>
#include <nurbs/NURBSAPISmooth.hpp>
#include <geomAlgo/MakeConic2FromConstraints.hpp>
#include <geometry/Adaptor3CurveOnSurface.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/AdaptorGeom3Surface.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/Geom2Circle.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/Geom2Hyperbola.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom3BSplineCurve.hpp>
#include <geometry/Geom3BSplineSurface.hpp>
#include <geometry/Geom3Circle.hpp>
#include <geometry/Geom3Line.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
#include <geometry/Geom3Plane.hpp>
#include <geometry/Geom3SphericalSurface.hpp>
#include <geometry/Geom3Surface.hpp>
#include <geometry/Geom3TrimmedCurve.hpp>
#include <geometry/Geom3TrimmedSurface.hpp>
#include <geometry/GeomAPIExtremaCurveCurve3.hpp>
#include <geometry/GeomAPIProjectPointOnCurve2.hpp>
#include <geometry/GeomAPIProjectPointOnCurve3.hpp>
#include <geometry/GeomAPIProjectPointOnSurface.hpp>
#include <geometry/GeometryTool.hpp>
#include <geometry/GlobalProperty.hpp>
#include <healing/ShapeFixTool.hpp>
#include <io/STLTool.hpp>
#include <math/Sphere.hpp>
#include <math/TriangularMesh.hpp>
#include <modeling/CopyShape.hpp>
#include <modeling/MakeBox.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeFace.hpp>
#include <modeling/MakePrism.hpp>
#include <modeling/MakeRevol.hpp>
#include <modeling/MakeShapeTool.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeWire.hpp>
#include <modeling/TransformShape.hpp>
#include <nurbs/NURBSAPIApprox.hpp>
#include <nurbs/NURBSAPIBuildCurve.hpp>
#include <nurbs/NURBSAPICircularSweep.hpp>
#include <nurbs/NURBSAPIConvert.hpp>
#include <nurbs/NURBSAPICurveNetworkSurface.hpp>
#include <nurbs/NURBSAPIExplicitSweep.hpp>
#include <nurbs/NURBSAPIExplode.hpp>
#include <nurbs/NURBSAPIExtend.hpp>
#include <nurbs/NURBSAPIInterpolate.hpp>
#include <nurbs/NURBSAPIJoin.hpp>
#include <nurbs/NURBSAPILinearSweep.hpp>
#include <nurbs/NURBSAPILoft.hpp>
#include <nurbs/NURBSAPIMakeNURBSFromBoundaries.hpp>
#include <nurbs/NURBSAPIMatch.hpp>
#include <nurbs/NURBSAPIModifyEndToPlane.hpp>
#include <nurbs/NURBSAPIOffsetCurveOnSurface.hpp>
#include <nurbs/NURBSAPIProject.hpp>
#include <nurbs/NURBSAPIRebuild.hpp>
#include <nurbs/NURBSAPIReplaceEdge.hpp>
#include <nurbs/NURBSAPISweep.hpp>
#include <nurbs/NURBSAPISweep2.hpp>
#include <nurbs/NURBSAPISweepRotation.hpp>
#include <nurbs/NURBSAPITrim.hpp>
#include <nurbs/NURBSAPIUntrim.hpp>
#include <nurbs/NURBSLinearSweepWithDraftDirectionLength.hpp>
#include <occtio/OCCTTool.hpp>
#include <offset/MakePipe.hpp>
#include <offset/MakePipeShell.hpp>
#include <topology/BRepAdaptorCurve2.hpp>
#include <topology/BRepAdaptorCurve3.hpp>
#include <topology/BRepAdaptorSurface.hpp>
#include <topology/BRepGlobalProperty.hpp>
#include <topology/BRepTool.hpp>
#include <topology/TopoBuilder.hpp>
#include <topology/TopoCompound.hpp>
#include <topology/TopoEdge.hpp>
#include <topology/TopoExplorer.hpp>
#include <topology/TopoExplorerTool.hpp>
#include <topology/TopoFace.hpp>
#include <topology/TopoShape.hpp>
#include <topology/TopoShell.hpp>
#include <topology/TopoTool.hpp>
#include <topology/TopoVertex.hpp>
#include <topology/TopoWire.hpp>
#include <topology/WireExplorer.hpp>
#include <topomesh/BRepMeshIncrementalMesh.hpp>
#include <nurbs/NURBSAPIBlend.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
#include <math/LineT.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/GeomAPIIntSurfaceSurface.hpp>
using namespace AMCAX;
namespace
{
	std::shared_ptr<Geom3BSplineCurve> CurveChooser(const int id, const std::shared_ptr<Geom3BSplineCurve>& curve0, const std::shared_ptr<Geom3BSplineCurve>& curve1, const std::shared_ptr<Geom3BSplineCurve>& curve2)
	{
		std::shared_ptr<Geom3BSplineCurve> result;
		switch (id)
		{
		case 0:
		{
			result = curve0;
			break;
		}
		case 1:
		{
			result = curve1;
			break;
		}
		case 2:
		{
			result = curve2;
			break;
		}
		}
		return result;
	}
} 
TEST_CASE("case1:this is a case for CircularSweep", "[nurbs][forcase1][Circular]")
{
	GlobalProperty g;
	SECTION("TestCircularSweepWithTwoGuidesAndTangencySurface()")
	{
		std::string filedir(INPUT_PATH_PREFIX "/TestNURBS/TestCircularSweepWithTwoGuidesAndTangencySurface/");
		auto guide1 = ReadBRepCurve(filedir + "guide1.brep");
		auto guide2 = ReadBRepCurve(filedir + "guide2.brep");
		auto surface = ReadBRepSurface(filedir + "surface.brep");
		auto spine = ReadBRepCurve(filedir + "spine.brep");
		CHECK(OCCTIO::OCCTTool::Write(MakeEdge(guide1), OUTPUT_PATH_PREFIX "TestCircularSweepWithTwoGuidesAndTangencySurface_guide1.brep"));
		CHECK(OCCTIO::OCCTTool::Write(MakeEdge(guide2), OUTPUT_PATH_PREFIX "TestCircularSweepWithTwoGuidesAndTangencySurface_guide2.brep"));
		CHECK(OCCTIO::OCCTTool::Write(MakeEdge(spine), OUTPUT_PATH_PREFIX "TestCircularSweepWithTwoGuidesAndTangencySurface_spine.brep"));
		CHECK(OCCTIO::OCCTTool::Write(MakeFace(surface, 0.0), OUTPUT_PATH_PREFIX "TestCircularSweepWithTwoGuidesAndTangencySurface_surface.brep"));
		auto [status, surfaces] = NURBSAPICircularSweep::SweepWithTwoGuidesAndTangencySurface(guide1, surface, guide2, spine, spine->FirstParameter(), spine->LastParameter());
		CHECK(status == NURBSSweepStatus::Success);
		if (status == NURBSSweepStatus::Success && !surfaces.empty())
		{
			CHECK(surfaces.size() == Approx(2.0));
			for (int i = 0; i < surfaces.size(); i++) {
				CHECK(OCCTIO::OCCTTool::Write(MakeFace(surfaces[i], 0.0), OUTPUT_PATH_PREFIX "TestCircularSweepWithTwoGuidesAndTangencySurface_result" + std::to_string(i) + ".brep"));
				AMCAX::BRepExtremaDistShapeShape len1(MakeEdge(guide1), MakeFace(surfaces[i], 0.0));
				AMCAX::BRepExtremaDistShapeShape len2(MakeEdge(guide2), MakeFace(surfaces[i], 0.0));
				AMCAX::BRepExtremaDistShapeShape len3(MakeFace(surface, 0.0), MakeFace(surfaces[i], 0.0));
				CHECK(len1.Value() < 0.1);
				CHECK(len2.Value() < 0.1);
				CHECK(len3.Value() < 0.1);
				CHECK(IsCurveOnSurf(100, 0.3, guide1, surfaces[i], 0.1));
				CHECK(IsCurveOnSurf(100, 0.3, guide2, surfaces[i], 0.1));
			}
		}
			CHECK(IsSurfTangent(100, 0.6, guide1, surface, surfaces[0], 20, 180));
			CHECK(IsSurfTangent(100, 0.6, guide1, surface, surfaces[1], 20, 180));
			guide1->IncreaseDegree(11);
			guide2->IncreaseDegree(11);
			spine->IncreaseDegree(11);
			surface->IncreaseDegree(11, 11);
			auto [status1, surfaces1] = NURBSAPICircularSweep::SweepWithTwoGuidesAndTangencySurface(guide1, surface, guide2, spine, spine->FirstParameter(), spine->LastParameter());
			CHECK(status1 == NURBSSweepStatus::Success);
			if (status1 == NURBSSweepStatus::Success && !surfaces1.empty())
			{
				CHECK(surfaces1.size() == Approx(2.0));
				for (int i = 0; i < surfaces1.size(); i++) {
					CHECK(OCCTIO::OCCTTool::Write(MakeFace(surfaces1[i], 0.0), OUTPUT_PATH_PREFIX "TestCircularSweepWithTwoGuidesAndTangencySurface_result" + std::to_string(i) + ".brep"));
					AMCAX::BRepExtremaDistShapeShape len1(MakeEdge(guide1), MakeFace(surfaces1[i], 0.0));
					AMCAX::BRepExtremaDistShapeShape len2(MakeEdge(guide2), MakeFace(surfaces1[i], 0.0));
					AMCAX::BRepExtremaDistShapeShape len3(MakeFace(surface, 0.0), MakeFace(surfaces1[i], 0.0));
					CHECK(len1.Value() < 0.1);
					CHECK(len2.Value() < 0.1);
					CHECK(len3.Value() < 0.1);
					CHECK(IsCurveOnSurf(100, 0.3, guide1, surfaces1[i], 0.1));
					CHECK(IsCurveOnSurf(100, 0.3, guide2, surfaces1[i], 0.1));
					double bsp3s = GetSurfaceProperties(MakeFace(surfaces1[i], 0.0), g, true, true);
					double bsp4s = GetSurfaceProperties(MakeFace(surfaces[i], 0.0), g, true, true);
					CHECK(bsp3s == Approx(bsp4s).margin(0.02));
				}
			}
		}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static std::pair<NURBSSweepStatus, std::vector<std::shared_ptr<Geom3BSplineSurface>>> SweepWithOneGuideAndTangencySurface(const std::shared_ptr<Geom3BSplineCurve>& guide, const std::shared_ptr<Geom3BSplineSurface>& tangencySurface, const LawFunction& radiusLaw, const std::shared_ptr<Geom3BSplineCurve>& spine, double spineLeftBound, double spineRightBound),
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <filesystem>
#include <fstream>
#include <random>
#include <sstream>
#include <nurbs/NURBSAPIGetGeometry.hpp>
#include <nurbs/NURBSAPIConicalSweep.hpp>
#include <boolean/BoolBRepCut.hpp>
#include <common/CartesianCoordinateSystem.hpp>
#include <common/IndexMap.hpp>
#include <common/QuaternionT.hpp>
#include <geomAlgo/LawBSpline.hpp>
#include <geomAlgo/LawConstant.hpp>
#include <nurbs/NURBSAPISmooth.hpp>
#include <geomAlgo/MakeConic2FromConstraints.hpp>
#include <geometry/Adaptor3CurveOnSurface.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/AdaptorGeom3Surface.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/Geom2Circle.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/Geom2Hyperbola.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom3BSplineCurve.hpp>
#include <geometry/Geom3BSplineSurface.hpp>
#include <geometry/Geom3Circle.hpp>
#include <geometry/Geom3Line.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
#include <geometry/Geom3Plane.hpp>
#include <geometry/Geom3SphericalSurface.hpp>
#include <geometry/Geom3Surface.hpp>
#include <geometry/Geom3TrimmedCurve.hpp>
#include <geometry/Geom3TrimmedSurface.hpp>
#include <geometry/GeomAPIExtremaCurveCurve3.hpp>
#include <geometry/GeomAPIProjectPointOnCurve2.hpp>
#include <geometry/GeomAPIProjectPointOnCurve3.hpp>
#include <geometry/GeomAPIProjectPointOnSurface.hpp>
#include <geometry/GeometryTool.hpp>
#include <geometry/GlobalProperty.hpp>
#include <healing/ShapeFixTool.hpp>
#include <io/STLTool.hpp>
#include <math/Sphere.hpp>
#include <math/TriangularMesh.hpp>
#include <modeling/CopyShape.hpp>
#include <modeling/MakeBox.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeFace.hpp>
#include <modeling/MakePrism.hpp>
#include <modeling/MakeRevol.hpp>
#include <modeling/MakeShapeTool.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeWire.hpp>
#include <modeling/TransformShape.hpp>
#include <nurbs/NURBSAPIApprox.hpp>
#include <nurbs/NURBSAPIBuildCurve.hpp>
#include <nurbs/NURBSAPICircularSweep.hpp>
#include <nurbs/NURBSAPIConvert.hpp>
#include <nurbs/NURBSAPICurveNetworkSurface.hpp>
#include <nurbs/NURBSAPIExplicitSweep.hpp>
#include <nurbs/NURBSAPIExplode.hpp>
#include <nurbs/NURBSAPIExtend.hpp>
#include <nurbs/NURBSAPIInterpolate.hpp>
#include <nurbs/NURBSAPIJoin.hpp>
#include <nurbs/NURBSAPILinearSweep.hpp>
#include <nurbs/NURBSAPILoft.hpp>
#include <nurbs/NURBSAPIMakeNURBSFromBoundaries.hpp>
#include <nurbs/NURBSAPIMatch.hpp>
#include <nurbs/NURBSAPIModifyEndToPlane.hpp>
#include <nurbs/NURBSAPIOffsetCurveOnSurface.hpp>
#include <nurbs/NURBSAPIProject.hpp>
#include <nurbs/NURBSAPIRebuild.hpp>
#include <nurbs/NURBSAPIReplaceEdge.hpp>
#include <nurbs/NURBSAPISweep.hpp>
#include <nurbs/NURBSAPISweep2.hpp>
#include <nurbs/NURBSAPISweepRotation.hpp>
#include <nurbs/NURBSAPITrim.hpp>
#include <nurbs/NURBSAPIUntrim.hpp>
#include <nurbs/NURBSLinearSweepWithDraftDirectionLength.hpp>
#include <occtio/OCCTTool.hpp>
#include <offset/MakePipe.hpp>
#include <offset/MakePipeShell.hpp>
#include <topology/BRepAdaptorCurve2.hpp>
#include <topology/BRepAdaptorCurve3.hpp>
#include <topology/BRepAdaptorSurface.hpp>
#include <topology/BRepGlobalProperty.hpp>
#include <topology/BRepTool.hpp>
#include <topology/TopoBuilder.hpp>
#include <topology/TopoCompound.hpp>
#include <topology/TopoEdge.hpp>
#include <topology/TopoExplorer.hpp>
#include <topology/TopoExplorerTool.hpp>
#include <topology/TopoFace.hpp>
#include <topology/TopoShape.hpp>
#include <topology/TopoShell.hpp>
#include <topology/TopoTool.hpp>
#include <topology/TopoVertex.hpp>
#include <topology/TopoWire.hpp>
#include <topology/WireExplorer.hpp>
#include <topomesh/BRepMeshIncrementalMesh.hpp>
#include <nurbs/NURBSAPIBlend.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
#include <math/LineT.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/GeomAPIIntSurfaceSurface.hpp>
using namespace AMCAX;
namespace
{
	std::shared_ptr<Geom3BSplineCurve> CurveChooser(const int id, const std::shared_ptr<Geom3BSplineCurve>& curve0, const std::shared_ptr<Geom3BSplineCurve>& curve1, const std::shared_ptr<Geom3BSplineCurve>& curve2)
	{
		std::shared_ptr<Geom3BSplineCurve> result;
		switch (id)
		{
		case 0:
		{
			result = curve0;
			break;
		}
		case 1:
		{
			result = curve1;
			break;
		}
		case 2:
		{
			result = curve2;
			break;
		}
		}
		return result;
	}
} 
TEST_CASE("case1:this is a case for CircularSweep", "[nurbs][forcase1][Circular]")
{
	GlobalProperty g;
	SECTION("TestCircularSweepWithOneGuideAndTangencySurface()")
		{
			std::string filedir(INPUT_PATH_PREFIX "/TestNURBS/TestCircularSweepWithOneGuideAndTangencySurface/");
			auto guide = ReadBRepCurve(filedir + "guide.brep");
			auto surface = ReadBRepSurface(filedir + "surface.brep");
			auto spine = ReadBRepCurve(filedir + "spine.brep");
			CHECK(OCCTIO::OCCTTool::Write(MakeEdge(guide), OUTPUT_PATH_PREFIX "TestCircularSweepWithOneGuideAndTangencySurface_guide.brep"));
			CHECK(OCCTIO::OCCTTool::Write(MakeEdge(spine), OUTPUT_PATH_PREFIX "TestCircularSweepWithOneGuideAndTangencySurface_spine.brep"));
			CHECK(OCCTIO::OCCTTool::Write(MakeFace(surface, 0.0), OUTPUT_PATH_PREFIX "TestCircularSweepWithOneGuideAndTangencySurface_surface.brep"));
			LawConstant radiusLaw;
			radiusLaw.Set(10.0, 0.0, 1.0);
			clock_t bg = clock();
			auto [status, surfaces] = NURBSAPICircularSweep::SweepWithOneGuideAndTangencySurface(guide, surface, radiusLaw, spine, spine->FirstParameter(), spine->LastParameter());
			GlobalProperty g;
			clock_t ed = clock();
			std::cout << "time = " << ed - bg << "ms" << std::endl;
			CHECK(status == NURBSSweepStatus::Success);
			if (status == NURBSSweepStatus::Success && !surfaces.empty())
			{
				int nsurfaces = static_cast<int>(surfaces.size());
				for (int i = 0; i < nsurfaces; i++)
				{
					AMCAX::BRepExtremaDistShapeShape len(MakeFace(surface, 0.0), MakeFace(surfaces[i], 0.0));
					AMCAX::BRepExtremaDistShapeShape len1(MakeFace(surfaces[i], 0.0), MakeEdge(guide));
					CHECK(len.Value() < 0.1);
					CHECK(len1.Value() < 0.1);
					CHECK(OCCTIO::OCCTTool::Write(MakeFace(surfaces[i], 0.0), OUTPUT_PATH_PREFIX "TestCircularSweepWithOneGuideAndTangencySurface_result" + std::to_string(i) + ".brep"));
				}
			}
			std::string filedir1 = OUTPUT_PATH_PREFIX;
			IndexSet<TopoShape> newshapeEdge0;
			IndexSet<TopoShape> newshapeEdge1;
			IndexSet<TopoShape> newshapeEdge2;
			IndexSet<TopoShape> newshapeEdge3;
			TopoExplorerTool::MapShapes(MakeFace(surfaces[0], 0.0), ShapeType::Edge, newshapeEdge0);
			TopoExplorerTool::MapShapes(MakeFace(surfaces[1], 0.0), ShapeType::Edge, newshapeEdge1);
			TopoExplorerTool::MapShapes(MakeFace(surfaces[2], 0.0), ShapeType::Edge, newshapeEdge2);
			TopoExplorerTool::MapShapes(MakeFace(surfaces[3], 0.0), ShapeType::Edge, newshapeEdge3);
			std::cout << "newshapedege.size" << newshapeEdge1.size() << endl;
			CHECK(OCCTIO::OCCTTool::Write(newshapeEdge0[0], OUTPUT_PATH_PREFIX "TestCircularSweepWithOneGuideAndTangencySurface_newshapeEdge0[0].brep"));
			CHECK(OCCTIO::OCCTTool::Write(newshapeEdge1[2], OUTPUT_PATH_PREFIX "TestCircularSweepWithOneGuideAndTangencySurface_newshapeEdge1[2].brep"));
			CHECK(OCCTIO::OCCTTool::Write(newshapeEdge2[0], OUTPUT_PATH_PREFIX "TestCircularSweepWithOneGuideAndTangencySurface_newshapeEdge2[0].brep"));
			CHECK(OCCTIO::OCCTTool::Write(newshapeEdge3[0], OUTPUT_PATH_PREFIX "TestCircularSweepWithOneGuideAndTangencySurface_newshapeEdge3[0].brep"));
			auto edge0 = ReadBRepCurve(filedir1 + "TestCircularSweepWithOneGuideAndTangencySurface_newshapeEdge0[0].brep");
			auto edge1 = ReadBRepCurve(filedir1 + "TestCircularSweepWithOneGuideAndTangencySurface_newshapeEdge1[2].brep");
			auto edge2 = ReadBRepCurve(filedir1 + "TestCircularSweepWithOneGuideAndTangencySurface_newshapeEdge2[0].brep");
			auto edge3 = ReadBRepCurve(filedir1 + "TestCircularSweepWithOneGuideAndTangencySurface_newshapeEdge3[0].brep");
			CHECK(IsSurfTangent(100, 0.6, edge0, surface, surfaces[0], 20, 0));
			CHECK(IsSurfTangent(100, 0.6, edge1, surface, surfaces[1], 20, 180));
			CHECK(IsSurfTangent(100, 0.6, edge2, surface, surfaces[2], 20, 180));
			CHECK(IsSurfTangent(100, 0.6, edge3, surface, surfaces[3], 20, 0));
			guide->IncreaseDegree(11);
			spine->IncreaseDegree(11);
			surface->IncreaseDegree(11, 11);
			auto [status1, surfaces1] = NURBSAPICircularSweep::SweepWithOneGuideAndTangencySurface(guide, surface, radiusLaw, spine, spine->FirstParameter(), spine->LastParameter());
			CHECK(status1 == NURBSSweepStatus::Success);
			if (status1 == NURBSSweepStatus::Success && !surfaces.empty())
			{
				int nsurfaces = static_cast<int>(surfaces.size());
				for (int i = 0; i < nsurfaces; i++)
				{
					CHECK(OCCTIO::OCCTTool::Write(MakeFace(surfaces1[i], 0.0), OUTPUT_PATH_PREFIX "TestCircularSweepWithOneGuideAndTangencySurface_degree11result" + std::to_string(i) + ".brep"));
					double bsp3s = GetSurfaceProperties(MakeFace(surfaces1[i], 0.0), g, true, true);
					double bsp4s = GetSurfaceProperties(MakeFace(surfaces[i], 0.0), g, true, true);
					CHECK(bsp3s == Approx(bsp4s).margin(0.02));
				}
			}
		}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static std::pair<NURBSSweepStatus, std::vector<std::shared_ptr<Geom3BSplineSurface>>> SweepWithCurveOnTangencySurface(const std::shared_ptr<Geom3BSplineCurve>& guide, const std::shared_ptr<Geom3BSplineSurface>& tangencySurface, const LawFunction& radiusLaw, const LawFunction& angleLaw1, const LawFunction& angleLaw2, const std::shared_ptr<Geom3BSplineCurve>& spine, double spineLeftBound, double spineRightBound),
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <filesystem>
#include <fstream>
#include <random>
#include <sstream>
#include <nurbs/NURBSAPIGetGeometry.hpp>
#include <nurbs/NURBSAPIConicalSweep.hpp>
#include <boolean/BoolBRepCut.hpp>
#include <common/CartesianCoordinateSystem.hpp>
#include <common/IndexMap.hpp>
#include <common/QuaternionT.hpp>
#include <geomAlgo/LawBSpline.hpp>
#include <geomAlgo/LawConstant.hpp>
#include <nurbs/NURBSAPISmooth.hpp>
#include <geomAlgo/MakeConic2FromConstraints.hpp>
#include <geometry/Adaptor3CurveOnSurface.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/AdaptorGeom3Surface.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/Geom2Circle.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/Geom2Hyperbola.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom3BSplineCurve.hpp>
#include <geometry/Geom3BSplineSurface.hpp>
#include <geometry/Geom3Circle.hpp>
#include <geometry/Geom3Line.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
#include <geometry/Geom3Plane.hpp>
#include <geometry/Geom3SphericalSurface.hpp>
#include <geometry/Geom3Surface.hpp>
#include <geometry/Geom3TrimmedCurve.hpp>
#include <geometry/Geom3TrimmedSurface.hpp>
#include <geometry/GeomAPIExtremaCurveCurve3.hpp>
#include <geometry/GeomAPIProjectPointOnCurve2.hpp>
#include <geometry/GeomAPIProjectPointOnCurve3.hpp>
#include <geometry/GeomAPIProjectPointOnSurface.hpp>
#include <geometry/GeometryTool.hpp>
#include <geometry/GlobalProperty.hpp>
#include <healing/ShapeFixTool.hpp>
#include <io/STLTool.hpp>
#include <math/Sphere.hpp>
#include <math/TriangularMesh.hpp>
#include <modeling/CopyShape.hpp>
#include <modeling/MakeBox.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeFace.hpp>
#include <modeling/MakePrism.hpp>
#include <modeling/MakeRevol.hpp>
#include <modeling/MakeShapeTool.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeWire.hpp>
#include <modeling/TransformShape.hpp>
#include <nurbs/NURBSAPIApprox.hpp>
#include <nurbs/NURBSAPIBuildCurve.hpp>
#include <nurbs/NURBSAPICircularSweep.hpp>
#include <nurbs/NURBSAPIConvert.hpp>
#include <nurbs/NURBSAPICurveNetworkSurface.hpp>
#include <nurbs/NURBSAPIExplicitSweep.hpp>
#include <nurbs/NURBSAPIExplode.hpp>
#include <nurbs/NURBSAPIExtend.hpp>
#include <nurbs/NURBSAPIInterpolate.hpp>
#include <nurbs/NURBSAPIJoin.hpp>
#include <nurbs/NURBSAPILinearSweep.hpp>
#include <nurbs/NURBSAPILoft.hpp>
#include <nurbs/NURBSAPIMakeNURBSFromBoundaries.hpp>
#include <nurbs/NURBSAPIMatch.hpp>
#include <nurbs/NURBSAPIModifyEndToPlane.hpp>
#include <nurbs/NURBSAPIOffsetCurveOnSurface.hpp>
#include <nurbs/NURBSAPIProject.hpp>
#include <nurbs/NURBSAPIRebuild.hpp>
#include <nurbs/NURBSAPIReplaceEdge.hpp>
#include <nurbs/NURBSAPISweep.hpp>
#include <nurbs/NURBSAPISweep2.hpp>
#include <nurbs/NURBSAPISweepRotation.hpp>
#include <nurbs/NURBSAPITrim.hpp>
#include <nurbs/NURBSAPIUntrim.hpp>
#include <nurbs/NURBSLinearSweepWithDraftDirectionLength.hpp>
#include <occtio/OCCTTool.hpp>
#include <offset/MakePipe.hpp>
#include <offset/MakePipeShell.hpp>
#include <topology/BRepAdaptorCurve2.hpp>
#include <topology/BRepAdaptorCurve3.hpp>
#include <topology/BRepAdaptorSurface.hpp>
#include <topology/BRepGlobalProperty.hpp>
#include <topology/BRepTool.hpp>
#include <topology/TopoBuilder.hpp>
#include <topology/TopoCompound.hpp>
#include <topology/TopoEdge.hpp>
#include <topology/TopoExplorer.hpp>
#include <topology/TopoExplorerTool.hpp>
#include <topology/TopoFace.hpp>
#include <topology/TopoShape.hpp>
#include <topology/TopoShell.hpp>
#include <topology/TopoTool.hpp>
#include <topology/TopoVertex.hpp>
#include <topology/TopoWire.hpp>
#include <topology/WireExplorer.hpp>
#include <topomesh/BRepMeshIncrementalMesh.hpp>
#include <nurbs/NURBSAPIBlend.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
#include <math/LineT.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <geometry/GeomAPIIntSurfaceSurface.hpp>
using namespace AMCAX;
namespace
{
	std::shared_ptr<Geom3BSplineCurve> CurveChooser(const int id, const std::shared_ptr<Geom3BSplineCurve>& curve0, const std::shared_ptr<Geom3BSplineCurve>& curve1, const std::shared_ptr<Geom3BSplineCurve>& curve2)
	{
		std::shared_ptr<Geom3BSplineCurve> result;
		switch (id)
		{
		case 0:
		{
			result = curve0;
			break;
		}
		case 1:
		{
			result = curve1;
			break;
		}
		case 2:
		{
			result = curve2;
			break;
		}
		}
		return result;
	}
} 
TEST_CASE("case1:this is a case for CircularSweep", "[nurbs][forcase1][Circular]")
{
	GlobalProperty g;
	SECTION("TestCircularSweepWithCurveOnTangencySurface()")	
		{
			std::string filedir(INPUT_PATH_PREFIX "/TestNURBS/TestCircularSweepWithCurveOnTangencySurface/");
			auto guide = ReadBRepCurve(filedir + "guide.brep");
			auto surface = ReadBRepSurface(filedir + "surface.brep");
			auto spine = ReadBRepCurve(filedir + "spine.brep");
			CHECK(OCCTIO::OCCTTool::Write(MakeEdge(guide), OUTPUT_PATH_PREFIX "TestCircularSweepWithCurveOnTangencySurface_guide.brep"));
			CHECK(OCCTIO::OCCTTool::Write(MakeEdge(spine), OUTPUT_PATH_PREFIX "TestCircularSweepWithCurveOnTangencySurface_spine.brep"));
			CHECK(OCCTIO::OCCTTool::Write(MakeFace(surface, 0.0), OUTPUT_PATH_PREFIX "TestCircularSweepWithCurveOnTangencySurface_surface.brep"));
			LawConstant radiusLaw, angleLaw1, angleLaw2;
			radiusLaw.Set(10.0, 0.0, 1.0);
			angleLaw1.Set(0.0, 0.0, 1.0);
			angleLaw2.Set(M_PI_2, 0.0, 1.0);
			auto [status, surfaces] = NURBSAPICircularSweep::SweepWithCurveOnTangencySurface(guide, surface, radiusLaw, angleLaw1, angleLaw2, spine, spine->FirstParameter(), spine->LastParameter());
			CHECK(status == NURBSSweepStatus::Success);
			if (status == NURBSSweepStatus::Success && !surfaces.empty())
			{
				int nsurfaces = static_cast<int>(surfaces.size());
				for (int i = 0; i < nsurfaces; i++)
				{
					CHECK(OCCTIO::OCCTTool::Write(MakeFace(surfaces[i], 0.0), OUTPUT_PATH_PREFIX "TestCircularSweepWithCurveOnTangencySurface_result" + std::to_string(i) + ".brep"));
					CHECK(IsCurveOnSurf(1000, 0.1, guide, surfaces[i], 0.5));
					AMCAX::BRepExtremaDistShapeShape len(MakeFace(surface, 0.0), MakeFace(surfaces[i], 0.0));
					AMCAX::BRepExtremaDistShapeShape len1(MakeFace(surfaces[i], 0.0), MakeEdge(guide));
					CHECK(len1.Value() < 1.0);
					CHECK(len.Value() < 0.1);
				}
			}
			std::string filedir1 = OUTPUT_PATH_PREFIX;
			IndexSet<TopoShape> newshapeEdge1;
			IndexSet<TopoShape> newshapeEdge2;
			TopoExplorerTool::MapShapes(MakeFace(surfaces[0], 0.0), ShapeType::Edge, newshapeEdge1);
			TopoExplorerTool::MapShapes(MakeFace(surfaces[1], 0.0), ShapeType::Edge, newshapeEdge2);
			std::cout << "newshapedege.size" << newshapeEdge1.size() << endl;
			CHECK(OCCTIO::OCCTTool::Write(newshapeEdge1[0], OUTPUT_PATH_PREFIX "TestCircularSweepWithCurveOnTangencySurface_newshapeEdge1[0].brep"));
			CHECK(OCCTIO::OCCTTool::Write(newshapeEdge2[1], OUTPUT_PATH_PREFIX "TestCircularSweepWithCurveOnTangencySurface_newshapeEdge2[1].brep"));
			CHECK(OCCTIO::OCCTTool::Write(newshapeEdge2[2], OUTPUT_PATH_PREFIX "TestCircularSweepWithCurveOnTangencySurface_newshapeEdge2[2].brep"));
			CHECK(OCCTIO::OCCTTool::Write(newshapeEdge2[0], OUTPUT_PATH_PREFIX "TestCircularSweepWithCurveOnTangencySurface_newshapeEdge2[0].brep"));
			CHECK(OCCTIO::OCCTTool::Write(newshapeEdge2[3], OUTPUT_PATH_PREFIX "TestCircularSweepWithCurveOnTangencySurface_newshapeEdge2[3].brep"));
			auto edge0 = ReadBRepCurve(filedir1 + "TestCircularSweepWithCurveOnTangencySurface_newshapeEdge1[0].brep");
			auto edge1 = ReadBRepCurve(filedir1 + "TestCircularSweepWithCurveOnTangencySurface_newshapeEdge2[0].brep");
			CHECK(IsSurfTangent(100, 0.6, edge0, surface, surfaces[0], 20, 0));
			CHECK(IsSurfTangent(100, 0.6, edge1, surface, surfaces[0], 20, 0));
			guide->IncreaseDegree(5);
			spine->IncreaseDegree(5);
			surface->IncreaseDegree(5, 5);
			auto [status1, surfaces1] = NURBSAPICircularSweep::SweepWithCurveOnTangencySurface(guide, surface, radiusLaw, angleLaw1, angleLaw2, spine, spine->FirstParameter(), spine->LastParameter());
			CHECK(status1 == NURBSSweepStatus::Success);
			if (status1 == NURBSSweepStatus::Success && !surfaces.empty())
			{
				int nsurfaces = static_cast<int>(surfaces.size());
				for (int i = 0; i < nsurfaces; i++)
				{
					CHECK(OCCTIO::OCCTTool::Write(MakeFace(surfaces1[i], 0.0), OUTPUT_PATH_PREFIX "TestCircularSweepWithCurveOnTangencySurface_degree5result" + std::to_string(i) + ".brep"));
					CHECK(IsCurveOnSurf(1000, 0.1, guide, surfaces1[i], 0.5));
					double bsp3s = GetSurfaceProperties(MakeFace(surfaces1[i], 0.0), g, true, true);
					double bsp4s = GetSurfaceProperties(MakeFace(surfaces[i], 0.0), g, true, true);
					CHECK(bsp3s == Approx(bsp4s).margin(0.02));
				}
			}
		}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static std::shared_ptr<Geom3BSplineCurve> ToBSpline(const std::shared_ptr<Geom3Curve>& curve)	 @return Result BSpline curve
	 @param curve The given curve
	 @brief Convert a common curve to a BSpline curve
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include<common/Exception.hpp>
#include <nurbs/NURBSAPIConvert.hpp>
#include <topology/TopoEdge.hpp>
#include <topology/TopoTool.hpp>
#include <topology/TopoVertex.hpp>
#include <geometry/Geom3TrimmedCurve.hpp>
#include <geometry/Geom3BSplineCurve.hpp>
#include <occtio/OCCTTool.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeFace.hpp>
#include <geometry/Geom3Circle.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
#include <geometry/Geom3Line.hpp>
#include <geometry/Geom3BezierCurve.hpp>
#include <geometry/Geom3Ellipse.hpp>
#include <geometry/Geom3Hyperbola.hpp>
#include <geometry/Geom3Parabola.hpp>
#include <geometry/Geom3SphericalSurface.hpp>
#include <math/Sphere.hpp>
#include <geometry/Geom3Surface.hpp>
#include <geometry/Geom3BSplineSurface.hpp>
#include <geometry/Geom3TrimmedSurface.hpp>
#include <geometry/Geom3ElementarySurface.hpp>
#include <geometry/Geom3OffsetSurface.hpp>
#include <geometry/Geom3SweptSurface.hpp>
#include <geometry/Geom3SurfaceOfExtrusion.hpp>
#include <geometry/Geom3BezierSurface.hpp>
#include <math/Cone.hpp>
#include <geometry/Geom3ConicalSurface.hpp>
#include <geometry/Geom3CylindricalSurface.hpp>
#include <geometry/Geom3Plane.hpp>
#include <geometry/Geom3ToroidalSurface.hpp>
#include <geometry/Geom3SurfaceOfExtrusion.hpp>
#include <geometry/Geom3SurfaceOfRevolution.hpp>
using namespace std;
using namespace AMCAX;
double NurbsLinearCurve(const shared_ptr<Geom3Curve>& curve1, const shared_ptr<Geom3BSplineCurve>& curve2)
{
    TopoShape edge1 = MakeEdge(curve1);
    TopoShape edge2 = MakeEdge(curve2);
    GlobalProperty props1, props2;
    double len1 = GetLinearProperties(edge1, props1, true, false);
    double len2 = GetLinearProperties(edge2, props2, true, false);
    double len = abs(len1 - len2);
    return len;
}
double NurbsSurfaceResult(const shared_ptr<Geom3Surface>& surface1, const shared_ptr<Geom3BSplineSurface>& surface2)
{
    TopoFace f1 = MakeFace(surface1, 0.0);
    TopoFace f2 = MakeFace(surface2, 0.0);
    GlobalProperty props1, props2;
    double s1 = GetSurfaceProperties(f1, props1, true, false);
    double s2 = GetSurfaceProperties(f2, props2, true, false);
    double res = abs(s1 - s2);
    return res;
}
TEST_CASE("bug1: ConvertToBSplineCurve ", "[nurbs][convert][fixbug]")
{
    double res;
    double tol = 0.1;
    Point3 p(0.0, 0.0, 0.0);
    Direction3 dir(0.0, 0.0, 1.0);
    Direction3 dir1(1.0, 0.0, 0.0);
    shared_ptr<Geom3Curve> curve;
    curve = make_shared<Geom3Circle>(Frame3(p, dir), 1.0);
	SECTION("TrimmedCurve = M_PI")
    {
        shared_ptr<Geom3TrimmedCurve> TrimmedCurve = make_shared<Geom3TrimmedCurve>(curve, 0.0, M_PI);
        Axis3 axis(p, dir1);
        shared_ptr<Geom3SweptSurface> surf;
        surf = make_shared<Geom3SurfaceOfRevolution>(TrimmedCurve, axis);
        shared_ptr<Geom3BSplineSurface> bspSurf = NURBSAPIConvert::ToBSpline(surf);
        res = NurbsSurfaceResult(surf, bspSurf);
        CHECK(res <= tol);
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static std::shared_ptr<Geom3BSplineSurface> ToBSpline(const std::shared_ptr<Geom3Surface>& surface)	 @return BSpline surface
	 @param surface The given surface
	 @brief Convert a common surface to a BSpline surface
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include<common/Exception.hpp>
#include <nurbs/NURBSAPIConvert.hpp>
#include <topology/TopoEdge.hpp>
#include <topology/TopoTool.hpp>
#include <topology/TopoVertex.hpp>
#include <geometry/Geom3TrimmedCurve.hpp>
#include <geometry/Geom3BSplineCurve.hpp>
#include <occtio/OCCTTool.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeFace.hpp>
#include <geometry/Geom3Circle.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
#include <geometry/Geom3Line.hpp>
#include <geometry/Geom3BezierCurve.hpp>
#include <geometry/Geom3Ellipse.hpp>
#include <geometry/Geom3Hyperbola.hpp>
#include <geometry/Geom3Parabola.hpp>
#include <geometry/Geom3SphericalSurface.hpp>
#include <math/Sphere.hpp>
#include <geometry/Geom3Surface.hpp>
#include <geometry/Geom3BSplineSurface.hpp>
#include <geometry/Geom3TrimmedSurface.hpp>
#include <geometry/Geom3ElementarySurface.hpp>
#include <geometry/Geom3OffsetSurface.hpp>
#include <geometry/Geom3SweptSurface.hpp>
#include <geometry/Geom3SurfaceOfExtrusion.hpp>
#include <geometry/Geom3BezierSurface.hpp>
#include <math/Cone.hpp>
#include <geometry/Geom3ConicalSurface.hpp>
#include <geometry/Geom3CylindricalSurface.hpp>
#include <geometry/Geom3Plane.hpp>
#include <geometry/Geom3ToroidalSurface.hpp>
#include <geometry/Geom3SurfaceOfExtrusion.hpp>
#include <geometry/Geom3SurfaceOfRevolution.hpp>
using namespace std;
using namespace AMCAX;
double NurbsLinearCurve(const shared_ptr<Geom3Curve>& curve1, const shared_ptr<Geom3BSplineCurve>& curve2)
{
    TopoShape edge1 = MakeEdge(curve1);
    TopoShape edge2 = MakeEdge(curve2);
    GlobalProperty props1, props2;
    double len1 = GetLinearProperties(edge1, props1, true, false);
    double len2 = GetLinearProperties(edge2, props2, true, false);
    double len = abs(len1 - len2);
    return len;
}
double NurbsSurfaceResult(const shared_ptr<Geom3Surface>& surface1, const shared_ptr<Geom3BSplineSurface>& surface2)
{
    TopoFace f1 = MakeFace(surface1, 0.0);
    TopoFace f2 = MakeFace(surface2, 0.0);
    GlobalProperty props1, props2;
    double s1 = GetSurfaceProperties(f1, props1, true, false);
    double s2 = GetSurfaceProperties(f2, props2, true, false);
    double res = abs(s1 - s2);
    return res;
}
TEST_CASE("bug5: ConvertToBSplineCurve ", "[nurbs][convert][fixbug]")
{
	SECTION("Geom3BSplineSurface")
    {
        shared_ptr<Geom3BSplineSurface> surf;
        surf = make_shared<Geom3BSplineSurface>();
        shared_ptr<Geom3BSplineSurface> bspSurf= NURBSAPIConvert::ToBSpline(surf);
    }}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static std::vector<std::pair<double, bool>> CalcParamCorrespondece( const std::vector<std::shared_ptr<Geom3Curve>>& curves, bool isPeriodic, bool isConsiderReverse),
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <nurbs/NURBSAPICorrespondence.hpp>
#include <modeling/MakeEdge.hpp>
#include <topology/TopoExplorerTool.hpp>
#include <nurbs/NURBSAPIConvert.hpp>
using namespace std;
TEST_CASE("case1: this is a test for CalcParamCorrespondece", "[nurbs][Correspondence][P1]")
{
	OUTPUT_DIRECTORY(nurbs, Correspondence);
	vector<shared_ptr<Geom3Curve>> curves;
	shared_ptr<Geom3BSplineCurve> vbsp1, vbsp2, vbsp3, vbsp4, hbsp1, hbsp2, hbsp3;
	{
		int deg = 3;
		std::vector<Point3> poles;
		poles.push_back(Point3(0.0, -1.0, 0.1));
		poles.push_back(Point3(0.07, -0.7, 0.2));
		poles.push_back(Point3(0.1, -0.3, 0.1));
		poles.push_back(Point3(0.12, 0.0, -0.1));
		poles.push_back(Point3(0.20, 0.3, -0.2));
		poles.push_back(Point3(0.07, 0.7, -0.3));
		poles.push_back(Point3(0.0, 1.0, 0.0));
		int nknots = static_cast<int>(poles.size()) - deg + 1;
		std::vector<double> knots(nknots);
		for (int i = 0; i < nknots; i++)
		{
			knots[i] = (double)i / (double)(nknots - 1.0);
		}
		std::vector<int> mults(nknots, 1);
		mults.front() = deg + 1;
		mults.back() = deg + 1;
		vbsp1 = std::make_shared<Geom3BSplineCurve>(poles, knots, mults, deg);
		OCCTIO::OCCTTool::Write(MakeEdge(vbsp1), outdir + "vbsp1.brep");
	}
	{
		int deg = 3;
		std::vector<Point3> poles;
		poles.push_back(Point3(2.0, -2.0, -0.1));
		poles.push_back(Point3(2.1, -1.3, -0.2));
		poles.push_back(Point3(2.15, -0.8, -0.1));
		poles.push_back(Point3(1.83, -0.2, 0.1));
		poles.push_back(Point3(1.48, 0.1, 0.2));
		poles.push_back(Point3(1.0, 1.0, 0.1));
		int nknots = static_cast<int>(poles.size()) - deg + 1;
		std::vector<double> knots(nknots);
		for (int i = 0; i < nknots; i++)
		{
			knots[i] = (double)i / (double)(nknots - 1.0);
		}
		std::vector<int> mults(nknots, 1);
		mults.front() = deg + 1;
		mults.back() = deg + 1;
		vbsp2 = std::make_shared<Geom3BSplineCurve>(poles, knots, mults, deg);
		OCCTIO::OCCTTool::Write(MakeEdge(vbsp2), outdir + "vbsp2.brep");
	}
	{
		int deg = 3;
		std::vector<Point3> poles;
		poles.push_back(Point3(3.0, -2.0, 0.1));
		poles.push_back(Point3(3.07, -1.3, 0.2));
		poles.push_back(Point3(3.1, -0.3, 0.1));
		poles.push_back(Point3(3.12, 0.0, -0.1));
		poles.push_back(Point3(3.0, 0.3, -0.2));
		poles.push_back(Point3(2.57, 0.7, -0.3));
		poles.push_back(Point3(2.2, 1.0, 0.0));
		int nknots = static_cast<int>(poles.size()) - deg + 1;
		std::vector<double> knots(nknots);
		for (int i = 0; i < nknots; i++)
		{
			knots[i] = (double)i / (double)(nknots - 1.0);
		}
		std::vector<int> mults(nknots, 1);
		mults.front() = deg + 1;
		mults.back() = deg + 1;
		vbsp3 = std::make_shared<Geom3BSplineCurve>(poles, knots, mults, deg);
		OCCTIO::OCCTTool::Write(MakeEdge(vbsp3), outdir + "vbsp3.brep");
	}
	{
		int deg = 3;
		std::vector<Point3> poles;
		poles.push_back(Point3(4.0, -1.5, -0.1));
		poles.push_back(Point3(4.1, -1.3, -0.2));
		poles.push_back(Point3(4.15, -0.8, -0.1));
		poles.push_back(Point3(3.83, -0.2, 0.1));
		poles.push_back(Point3(3.48, 0.1, 0.2));
		poles.push_back(Point3(3.0, 1.0, 0.1));
		int nknots = static_cast<int>(poles.size()) - deg + 1;
		std::vector<double> knots(nknots);
		for (int i = 0; i < nknots; i++)
		{
			knots[i] = (double)i / (double)(nknots - 1.0);
		}
		std::vector<int> mults(nknots, 1);
		mults.front() = deg + 1;
		mults.back() = deg + 1;
		vbsp4 = std::make_shared<Geom3BSplineCurve>(poles, knots, mults, deg);
		OCCTIO::OCCTTool::Write(MakeEdge(vbsp4), outdir + "vbsp4.brep");
	}
	{
		int deg = 3;
		std::vector<Point3> poles;
		poles.push_back(Point3(0.0, -1.0, 0.1));
		poles.push_back(Point3(0.9, -1.5, -0.1));
		poles.push_back(Point3(3.0, -1.8, 0.1));
		poles.push_back(Point3(4.0, -1.5, -0.1));
		int nknots = static_cast<int>(poles.size()) - deg + 1;
		std::vector<double> knots(nknots);
		for (int i = 0; i < nknots; i++)
		{
			knots[i] = (double)i / (double)(nknots - 1.0);
		}
		std::vector<int> mults(nknots, 1);
		mults.front() = deg + 1;
		mults.back() = deg + 1;
		hbsp1 = std::make_shared<Geom3BSplineCurve>(poles, knots, mults, deg);
		OCCTIO::OCCTTool::Write(MakeEdge(hbsp1), outdir + "hbsp1.brep");
	}
	{
		int deg = 3;
		std::vector<Point3> poles;
		poles.push_back(Point3(0.0, 0.0, 0.0));
		poles.push_back(Point3(1.2, -1.15, -0.1));
		poles.push_back(Point3(2.7, -1.05, 0.1));
		poles.push_back(Point3(3.7, -1.3, -0.1));
		poles.push_back(Point3(5.0, -1.0, 0.1));
		int nknots = static_cast<int>(poles.size()) - deg + 1;
		std::vector<double> knots(nknots);
		for (int i = 0; i < nknots; i++)
		{
			knots[i] = (double)i / (double)(nknots - 1.0);
		}
		std::vector<int> mults(nknots, 1);
		mults.front() = deg + 1;
		mults.back() = deg + 1;
		hbsp2 = std::make_shared<Geom3BSplineCurve>(poles, knots, mults, deg);
		OCCTIO::OCCTTool::Write(MakeEdge(hbsp2), outdir + "hbsp2.brep");
	}
	{
		int deg = 3;
		vector<Point3> poles;
		poles.push_back(Point3(0.0, 1.0, 0.0));
		poles.push_back(Point3(0.9, 0.15, -0.1));
		poles.push_back(Point3(1.7, 0.05, 0.1));
		poles.push_back(Point3(2.7, 0.3, -0.1));
		poles.push_back(Point3(3.0, 1.0, 0.1));
		int nknots = static_cast<int>(poles.size()) - deg + 1;
		vector<double> knots(nknots);
		for (int i = 0; i < nknots; i++)
		{
			knots[i] = (double)i / (double)(nknots - 1.0);
		}
		vector<int> mults(nknots, 1);
		mults.front() = deg + 1;
		mults.back() = deg + 1;
		hbsp3 = make_shared<Geom3BSplineCurve>(poles, knots, mults, deg);
		OCCTIO::OCCTTool::Write(MakeEdge(hbsp3), outdir + "hbsp3.brep");
	}
	curves.push_back(vbsp1);
	curves.push_back(vbsp2);
	curves.push_back(vbsp3);
	curves.push_back(vbsp4);
	curves.push_back(hbsp1);
	curves.push_back(hbsp2);
	curves.push_back(hbsp3);
	SECTION("isPeriodic+isConsiderReverse")
	{
		bool isPeriodic = true;
		bool isConsiderReverse = true;
		vector<pair<double, bool>> corrs = NURBSAPICorrespondence::CalcParamCorrespondece(curves, isPeriodic, isConsiderReverse);
		CHECK(corrs[0].first == 0.0);
		CHECK(corrs[0].second == false);
		CHECK(corrs[1].first > 0.0);
		CHECK(corrs[1].second == true);
		CHECK(corrs[2].first > 0.0);
		CHECK(corrs[2].second == true);
		CHECK(corrs[3].first > 0.0);
		CHECK(corrs[3].second == true);
		CHECK(corrs[4].first > 0.0);
		CHECK(corrs[4].second == true);
		CHECK(corrs[5].first > 0.0);
		CHECK(corrs[5].second == true);
		CHECK(corrs[6].first > 0.0);
		CHECK(corrs[6].second == true);
		CHECK(corrs.size() == 7);
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static std::shared_ptr<Geom3BSplineSurface> CurveNetworkSurfaceGordon(const std::vector<std::shared_ptr<Geom3BSplineCurve>>& verticalCurves, const std::vector<std::shared_ptr<Geom3BSplineCurve>>& horizontalCurves)	 @return The Gordon surface which go through the curves
	 @param horizontalCurves Horizontal network curves
	 @param verticalCurves Vertical network curves
	 @brief Coons-Gordon surface
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <nurbs/NURBSAPICurveNetworkSurface.hpp>
#include <topology/TopoEdge.hpp>
#include <topology/TopoTool.hpp>
#include <modeling/MakeFace.hpp>
#include <nurbs/NURBSAPILoft.hpp>
#include <common/Precision.hpp>
#include <modeling/MakeEdge.hpp>
#include <occtio/OCCTTool.hpp>
#include <geometry/Geom3BSplineCurve.hpp>
#include <geometry/Geom3BSplineSurface.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
#include <topology/TopoExplorerTool.hpp>
#include <geometry/GeomAPIProjectPointOnSurface.hpp>
using namespace std;
using namespace AMCAX;
double NurbsSampleCurveOnSurface(int num, double tol, const shared_ptr<Geom3Curve>& curve, const shared_ptr<Geom3Surface>& surf)
{
	const int nsample = num;
	double fp1 = curve->FirstParameter();
	double lp1 = curve->LastParameter();
	double delta1 = (lp1 - fp1) / nsample;
	Point3 p;
	int n = 0;
	for (int i = 0; i < nsample; i++)
	{
		double t1 = fp1 + i * delta1;
		curve->D0(t1, p);
		GeomAPIProjectPointOnSurface projector(p, surf);
		double dis = projector.LowerDistance();
		if (dis <= tol)
		{
			n++;
		}
	}
	double res = 1.0 * (num - n) / num;
	return res;
}
vector< shared_ptr<Geom3BSplineCurve>> ConstructBSplineCurve()
{
	vector<shared_ptr<Geom3BSplineCurve>> vec;
	shared_ptr<Geom3BSplineCurve> vbsp1, vbsp2, vbsp3, vbsp4, hbsp1, hbsp2, hbsp3;
	{
		int deg = 3;
		std::vector<Point3> poles;
		poles.push_back(Point3(0.0, -1.0, 0.1));
		poles.push_back(Point3(0.07, -0.7, 0.2));
		poles.push_back(Point3(0.1, -0.3, 0.1));
		poles.push_back(Point3(0.12, 0.0, -0.1));
		poles.push_back(Point3(0.20, 0.3, -0.2));
		poles.push_back(Point3(0.07, 0.7, -0.3));
		poles.push_back(Point3(0.0, 1.0, 0.0));
		int nknots = static_cast<int>(poles.size()) - deg + 1;
		std::vector<double> knots(nknots);
		for (int i = 0; i < nknots; i++)
		{
			knots[i] = (double)i / (double)(nknots - 1.0);
		}
		std::vector<int> mults(nknots, 1);
		mults.front() = deg + 1;
		mults.back() = deg + 1;
		vbsp1 = std::make_shared<Geom3BSplineCurve>(poles, knots, mults, deg);
	}
	{
		int deg = 3;
		std::vector<Point3> poles;
		poles.push_back(Point3(2.0, -2.0, -0.1));
		poles.push_back(Point3(2.1, -1.3, -0.2));
		poles.push_back(Point3(2.15, -0.8, -0.1));
		poles.push_back(Point3(1.83, -0.2, 0.1));
		poles.push_back(Point3(1.48, 0.1, 0.2));
		poles.push_back(Point3(1.0, 1.0, 0.1));
		int nknots = static_cast<int>(poles.size()) - deg + 1;
		std::vector<double> knots(nknots);
		for (int i = 0; i < nknots; i++)
		{
			knots[i] = (double)i / (double)(nknots - 1.0);
		}
		std::vector<int> mults(nknots, 1);
		mults.front() = deg + 1;
		mults.back() = deg + 1;
		vbsp2 = std::make_shared<Geom3BSplineCurve>(poles, knots, mults, deg);
	}
	{
		int deg = 3;
		std::vector<Point3> poles;
		poles.push_back(Point3(3.0, -2.0, 0.1));
		poles.push_back(Point3(3.07, -1.3, 0.2));
		poles.push_back(Point3(3.1, -0.3, 0.1));
		poles.push_back(Point3(3.12, 0.0, -0.1));
		poles.push_back(Point3(3.0, 0.3, -0.2));
		poles.push_back(Point3(2.57, 0.7, -0.3));
		poles.push_back(Point3(2.2, 1.0, 0.0));
		int nknots = static_cast<int>(poles.size()) - deg + 1;
		std::vector<double> knots(nknots);
		for (int i = 0; i < nknots; i++)
		{
			knots[i] = (double)i / (double)(nknots - 1.0);
		}
		std::vector<int> mults(nknots, 1);
		mults.front() = deg + 1;
		mults.back() = deg + 1;
		vbsp3 = std::make_shared<Geom3BSplineCurve>(poles, knots, mults, deg);
	}
	{
		int deg = 3;
		std::vector<Point3> poles;
		poles.push_back(Point3(4.0, -1.5, -0.1));
		poles.push_back(Point3(4.1, -1.3, -0.2));
		poles.push_back(Point3(4.15, -0.8, -0.1));
		poles.push_back(Point3(3.83, -0.2, 0.1));
		poles.push_back(Point3(3.48, 0.1, 0.2));
		poles.push_back(Point3(3.0, 1.0, 0.1));
		int nknots = static_cast<int>(poles.size()) - deg + 1;
		std::vector<double> knots(nknots);
		for (int i = 0; i < nknots; i++)
		{
			knots[i] = (double)i / (double)(nknots - 1.0);
		}
		std::vector<int> mults(nknots, 1);
		mults.front() = deg + 1;
		mults.back() = deg + 1;
		vbsp4 = std::make_shared<Geom3BSplineCurve>(poles, knots, mults, deg);
	}
	{
		int deg = 3;
		std::vector<Point3> poles;
		poles.push_back(Point3(0.0, -1.0, 0.1));
		poles.push_back(Point3(0.9, -1.5, -0.1));
		poles.push_back(Point3(3.0, -1.8, 0.1));
		poles.push_back(Point3(4.0, -1.5, -0.1));
		int nknots = static_cast<int>(poles.size()) - deg + 1;
		std::vector<double> knots(nknots);
		for (int i = 0; i < nknots; i++)
		{
			knots[i] = (double)i / (double)(nknots - 1.0);
		}
		std::vector<int> mults(nknots, 1);
		mults.front() = deg + 1;
		mults.back() = deg + 1;
		hbsp1 = std::make_shared<Geom3BSplineCurve>(poles, knots, mults, deg);
	}
	{
		int deg = 3;
		std::vector<Point3> poles;
		poles.push_back(Point3(0.0, 0.0, 0.0));
		poles.push_back(Point3(1.2, -1.15, -0.1));
		poles.push_back(Point3(2.7, -1.05, 0.1));
		poles.push_back(Point3(3.7, -1.3, -0.1));
		poles.push_back(Point3(5.0, -1.0, 0.1));
		int nknots = static_cast<int>(poles.size()) - deg + 1;
		std::vector<double> knots(nknots);
		for (int i = 0; i < nknots; i++)
		{
			knots[i] = (double)i / (double)(nknots - 1.0);
		}
		std::vector<int> mults(nknots, 1);
		mults.front() = deg + 1;
		mults.back() = deg + 1;
		hbsp2 = std::make_shared<Geom3BSplineCurve>(poles, knots, mults, deg);
	}
	{
		int deg = 3;
		vector<Point3> poles;
		poles.push_back(Point3(0.0, 1.0, 0.0));
		poles.push_back(Point3(0.9, 0.15, -0.1));
		poles.push_back(Point3(1.7, 0.05, 0.1));
		poles.push_back(Point3(2.7, 0.3, -0.1));
		poles.push_back(Point3(3.0, 1.0, 0.1));
		int nknots = static_cast<int>(poles.size()) - deg + 1;
		vector<double> knots(nknots);
		for (int i = 0; i < nknots; i++)
		{
			knots[i] = (double)i / (double)(nknots - 1.0);
		}
		vector<int> mults(nknots, 1);
		mults.front() = deg + 1;
		mults.back() = deg + 1;
		hbsp3 = make_shared<Geom3BSplineCurve>(poles, knots, mults, deg);
	}
	vec.push_back(vbsp1);
	vec.push_back(vbsp2);
	vec.push_back(vbsp3);
	vec.push_back(vbsp4);
	vec.push_back(hbsp1);
	vec.push_back(hbsp2);
	vec.push_back(hbsp3);
	return vec;
}
TEST_CASE("bug1: CurveNetworkSurface ", "[nurbs][CurveNetworkSurface][fixbug]")
{
	OUTPUT_DIRECTORY(nurbs, CurveNetworkSurface/bug464);
	double refTol = 0.1;
	vector< shared_ptr<Geom3BSplineCurve>> vec = ConstructBSplineCurve();
	TopoEdge edge1 = MakeEdge(vec[0]);
	TopoEdge edge2 = MakeEdge(vec[1]);
	TopoEdge edge3 = MakeEdge(vec[2]);
	TopoEdge edge4 = MakeEdge(vec[3]);
	TopoEdge edge5 = MakeEdge(vec[4]);
	TopoEdge edge6 = MakeEdge(vec[5]);
	TopoEdge edge7 = MakeEdge(vec[6]);
	vector<shared_ptr<Geom3BSplineCurve>> horizontalCurves, verticalCurves;
	verticalCurves.push_back(vec[0]);
	verticalCurves.push_back(vec[1]);
	verticalCurves.push_back(vec[2]);
	verticalCurves.push_back(vec[3]);
	horizontalCurves.push_back(vec[4]);
	horizontalCurves.push_back(vec[5]);
	horizontalCurves.push_back(vec[6]);
	shared_ptr<Geom3BSplineSurface> surf = NURBSAPICurveNetworkSurface::CurveNetworkSurfaceGordon(verticalCurves, horizontalCurves);
	TopoShape surface = MakeFace(surf, 0.0);
	BRepExtremaDistShapeShape dist1(edge1, surface);
	BRepExtremaDistShapeShape dist2(edge2, surface);
	BRepExtremaDistShapeShape dist3(edge3, surface);
	BRepExtremaDistShapeShape dist4(edge4, surface);
	BRepExtremaDistShapeShape dist5(edge5, surface);
	BRepExtremaDistShapeShape dist6(edge6, surface);
	BRepExtremaDistShapeShape dist7(edge7, surface);
	CHECK(dist3.Value() <= Approx(refTol));
	CHECK(dist4.Value() <= Approx(refTol));
	CHECK(dist7.Value() <= Approx(refTol));
	OCCTIO::OCCTTool::Write(MakeEdge(vec[0]), outdir + "vbsp1.brep");
	OCCTIO::OCCTTool::Write(MakeEdge(vec[1]), outdir + "vbsp2.brep");
	OCCTIO::OCCTTool::Write(MakeEdge(vec[2]), outdir + "vbsp3.brep");
	OCCTIO::OCCTTool::Write(MakeEdge(vec[3]), outdir + "vbsp4.brep");
	OCCTIO::OCCTTool::Write(MakeEdge(vec[4]), outdir + "hbsp1.brep");
	OCCTIO::OCCTTool::Write(MakeEdge(vec[5]), outdir + "hbsp2.brep");
	OCCTIO::OCCTTool::Write(MakeEdge(vec[6]), outdir + "hbsp3.brep");
	OCCTIO::OCCTTool::Write(surface, outdir + "surfResult.brep");
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static std::pair<NURBSSweepStatus, std::shared_ptr<Geom3BSplineSurface>> SweepWithTwoGuideCurves( const std::shared_ptr<Geom3BSplineCurve>& profile, const std::shared_ptr<Geom3BSplineCurve>& guide1, const std::shared_ptr<Geom3BSplineCurve>& guide2, Point3 anchorPoint1, Point3 anchorPoint2, const std::shared_ptr<Geom3BSplineCurve>& spine, double spineLeftBound, double spineRightBound),
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <filesystem>
#include <fstream>
#include <random>
#include <sstream>
#include <nurbs/NURBSAPIGetGeometry.hpp>
#include <nurbs/NURBSAPIConicalSweep.hpp>
#include <boolean/BoolBRepCut.hpp>
#include <common/CartesianCoordinateSystem.hpp>
#include <common/IndexMap.hpp>
#include <common/QuaternionT.hpp>
#include <geomAlgo/LawBSpline.hpp>
#include <geomAlgo/LawConstant.hpp>
#include <nurbs/NURBSAPISmooth.hpp>
#include <geomAlgo/MakeConic2FromConstraints.hpp>
#include <geometry/Adaptor3CurveOnSurface.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/AdaptorGeom3Surface.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/Geom2Circle.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/Geom2Hyperbola.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom3BSplineCurve.hpp>
#include <geometry/Geom3BSplineSurface.hpp>
#include <geometry/Geom3Circle.hpp>
#include <geometry/Geom3Line.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
#include <geometry/Geom3Plane.hpp>
#include <geometry/Geom3SphericalSurface.hpp>
#include <geometry/Geom3Surface.hpp>
#include <geometry/Geom3TrimmedCurve.hpp>
#include <geometry/Geom3TrimmedSurface.hpp>
#include <geometry/GeomAPIExtremaCurveCurve3.hpp>
#include <geometry/GeomAPIProjectPointOnCurve2.hpp>
#include <geometry/GeomAPIProjectPointOnCurve3.hpp>
#include <geometry/GeomAPIProjectPointOnSurface.hpp>
#include <geometry/GeometryTool.hpp>
#include <geometry/GlobalProperty.hpp>
#include <healing/ShapeFixTool.hpp>
#include <io/STLTool.hpp>
#include <math/Sphere.hpp>
#include <math/TriangularMesh.hpp>
#include <modeling/CopyShape.hpp>
#include <modeling/MakeBox.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeFace.hpp>
#include <modeling/MakePrism.hpp>
#include <modeling/MakeRevol.hpp>
#include <modeling/MakeShapeTool.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeWire.hpp>
#include <modeling/TransformShape.hpp>
#include <nurbs/NURBSAPIApprox.hpp>
#include <nurbs/NURBSAPIBuildCurve.hpp>
#include <nurbs/NURBSAPICircularSweep.hpp>
#include <nurbs/NURBSAPIConvert.hpp>
#include <nurbs/NURBSAPICurveNetworkSurface.hpp>
#include <nurbs/NURBSAPIExplicitSweep.hpp>
#include <nurbs/NURBSAPIExplode.hpp>
#include <nurbs/NURBSAPIExtend.hpp>
#include <nurbs/NURBSAPIInterpolate.hpp>
#include <nurbs/NURBSAPIJoin.hpp>
#include <nurbs/NURBSAPILinearSweep.hpp>
#include <nurbs/NURBSAPILoft.hpp>
#include <nurbs/NURBSAPIMakeNURBSFromBoundaries.hpp>
#include <nurbs/NURBSAPIMatch.hpp>
#include <nurbs/NURBSAPIModifyEndToPlane.hpp>
#include <nurbs/NURBSAPIOffsetCurveOnSurface.hpp>
#include <nurbs/NURBSAPIProject.hpp>
#include <nurbs/NURBSAPIRebuild.hpp>
#include <nurbs/NURBSAPIReplaceEdge.hpp>
#include <nurbs/NURBSAPISweep.hpp>
#include <nurbs/NURBSAPISweep2.hpp>
#include <nurbs/NURBSAPISweepRotation.hpp>
#include <nurbs/NURBSAPITrim.hpp>
#include <nurbs/NURBSAPIUntrim.hpp>
#include <nurbs/NURBSLinearSweepWithDraftDirectionLength.hpp>
#include <occtio/OCCTTool.hpp>
#include <offset/MakePipe.hpp>
#include <offset/MakePipeShell.hpp>
#include <topology/BRepAdaptorCurve2.hpp>
#include <topology/BRepAdaptorCurve3.hpp>
#include <topology/BRepAdaptorSurface.hpp>
#include <topology/BRepGlobalProperty.hpp>
#include <topology/BRepTool.hpp>
#include <topology/TopoBuilder.hpp>
#include <topology/TopoCompound.hpp>
#include <topology/TopoEdge.hpp>
#include <topology/TopoExplorer.hpp>
#include <topology/TopoExplorerTool.hpp>
#include <topology/TopoFace.hpp>
#include <topology/TopoShape.hpp>
#include <topology/TopoShell.hpp>
#include <topology/TopoTool.hpp>
#include <topology/TopoVertex.hpp>
#include <topology/TopoWire.hpp>
#include <topology/WireExplorer.hpp>
#include <topomesh/BRepMeshIncrementalMesh.hpp>
#include <nurbs/NURBSAPIBlend.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
#include <math/LineT.hpp>
#include <hatch/BRepClassificationTools.hpp>
using namespace AMCAX;
namespace
{
	std::shared_ptr<Geom3BSplineCurve> CurveChooser(const int id, const std::shared_ptr<Geom3BSplineCurve>& curve0, const std::shared_ptr<Geom3BSplineCurve>& curve1, const std::shared_ptr<Geom3BSplineCurve>& curve2)
	{
		std::shared_ptr<Geom3BSplineCurve> result;
		switch (id)
		{
		case 0:
		{
			result = curve0;
			break;
		}
		case 1:
		{
			result = curve1;
			break;
		}
		case 2:
		{
			result = curve2;
			break;
		}
		}
		return result;
	}
} 
TEST_CASE("case1:this is a case for ExplicitSweep", "[nurbs][forcase1][Explicit]") {
	GlobalProperty g;
	SECTION("TestExplicitSweepWithTwoGuideCurvesTwoPoints()")
	{
		std::string filedir = INPUT_PATH_PREFIX "/TestNURBS/TestExplicitSweepWithTwoGuideCurvesTwoPoints/";
		auto profile = ReadBRepCurve(filedir + "profile.brep");
		CHECK(OCCTIO::OCCTTool::Write(MakeEdge(profile), OUTPUT_PATH_PREFIX "TestExplicitSweepWithTwoGuideCurvesTwoPoints_profile.brep"));
		auto guide1 = ReadBRepCurve(filedir + "guide1.brep");
		CHECK(OCCTIO::OCCTTool::Write(MakeEdge(guide1), OUTPUT_PATH_PREFIX "TestExplicitSweepWithTwoGuideCurvesTwoPoints_guide1.brep"));
		auto guide2 = ReadBRepCurve(filedir + "guide2.brep");
		CHECK(OCCTIO::OCCTTool::Write(MakeEdge(guide2), OUTPUT_PATH_PREFIX "TestExplicitSweepWithTwoGuideCurvesTwoPoints_guide2.brep"));
		auto anchorPoint1 = ReadBRepPoint(filedir + "point1.brep");
		auto anchorPoint2 = ReadBRepPoint(filedir + "point2.brep");
		CHECK(OCCTIO::OCCTTool::Write(MakeVertex(anchorPoint1), OUTPUT_PATH_PREFIX "TestExplicitSweepWithTwoGuideCurvesTwoPoints_point1.brep"));
		CHECK(OCCTIO::OCCTTool::Write(MakeVertex(anchorPoint2), OUTPUT_PATH_PREFIX "TestExplicitSweepWithTwoGuideCurvesTwoPoints_point2.brep"));
		auto [status, surface] = NURBSAPIExplicitSweep::SweepWithTwoGuideCurves(profile, guide1, guide2, anchorPoint1, anchorPoint2, guide1, guide1->FirstParameter(), guide1->LastParameter());
		CHECK(status == NURBSSweepStatus::Success);
		if (status == NURBSSweepStatus::Success)
		{
			CHECK(OCCTIO::OCCTTool::Write(MakeFace(surface, 0.0), OUTPUT_PATH_PREFIX "TestExplicitSweepWithTwoGuideCurvesTwoPoints_result.brep"));
			AMCAX::BRepExtremaDistShapeShape len1(MakeFace(surface, 0.0), MakeEdge(guide1));
			AMCAX::BRepExtremaDistShapeShape len2(MakeFace(surface, 0.0), MakeEdge(guide2));
			AMCAX::BRepExtremaDistShapeShape len3(MakeFace(surface, 0.0), MakeEdge(profile));
			CHECK(len1.Value() == Approx(0.0).margin(0.1));
			CHECK(len2.Value() == Approx(0.0).margin(0.1));
			CHECK(len3.Value() == Approx(0.0).margin(0.1));
		}
		profile->IncreaseDegree(11);
		guide1->IncreaseDegree(11);
		guide2->IncreaseDegree(11);
		auto [status1, surface1] = NURBSAPIExplicitSweep::SweepWithTwoGuideCurves(profile, guide1, guide2, anchorPoint1, anchorPoint2, guide1, guide1->FirstParameter(), guide1->LastParameter());
		CHECK(status1 == NURBSSweepStatus::Success);
		if (status1 == NURBSSweepStatus::Success)
		{
			CHECK(OCCTIO::OCCTTool::Write(MakeFace(surface1, 0.0), OUTPUT_PATH_PREFIX "TestExplicitSweepWithTwoGuideCurvesTwoPoints_degree11result.brep"));
			AMCAX::BRepExtremaDistShapeShape len1(MakeFace(surface1, 0.0), MakeEdge(guide1));
			AMCAX::BRepExtremaDistShapeShape len2(MakeFace(surface1, 0.0), MakeEdge(guide2));
			AMCAX::BRepExtremaDistShapeShape len3(MakeFace(surface1, 0.0), MakeEdge(profile));
			CHECK(len1.Value() == Approx(0.0).margin(0.1));
			CHECK(len2.Value() == Approx(0.0).margin(0.1));
			CHECK(len3.Value() == Approx(0.0).margin(0.1));
			double bsp3s = GetSurfaceProperties(MakeFace(surface1, 0.0), g, true, true);
			double bsp4s = GetSurfaceProperties(MakeFace(surface, 0.0), g, true, true);
			CHECK(bsp3s == Approx(bsp4s).margin(0.04));
		}
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static std::pair<NURBSSweepStatus, std::shared_ptr<Geom3BSplineSurface>> SweepWithTwoGuideCurves( const std::shared_ptr<Geom3BSplineCurve>& profile, const std::shared_ptr<Geom3BSplineCurve>& guide1, const std::shared_ptr<Geom3BSplineCurve>& guide2, Point3 anchorPoint, const Direction3& anchorDirection, const std::shared_ptr<Geom3BSplineCurve>& spine, double spineLeftBound, double spineRightBound),
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <filesystem>
#include <fstream>
#include <random>
#include <sstream>
#include <nurbs/NURBSAPIGetGeometry.hpp>
#include <nurbs/NURBSAPIConicalSweep.hpp>
#include <boolean/BoolBRepCut.hpp>
#include <common/CartesianCoordinateSystem.hpp>
#include <common/IndexMap.hpp>
#include <common/QuaternionT.hpp>
#include <geomAlgo/LawBSpline.hpp>
#include <geomAlgo/LawConstant.hpp>
#include <nurbs/NURBSAPISmooth.hpp>
#include <geomAlgo/MakeConic2FromConstraints.hpp>
#include <geometry/Adaptor3CurveOnSurface.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/AdaptorGeom3Surface.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/Geom2Circle.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/Geom2Hyperbola.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom3BSplineCurve.hpp>
#include <geometry/Geom3BSplineSurface.hpp>
#include <geometry/Geom3Circle.hpp>
#include <geometry/Geom3Line.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
#include <geometry/Geom3Plane.hpp>
#include <geometry/Geom3SphericalSurface.hpp>
#include <geometry/Geom3Surface.hpp>
#include <geometry/Geom3TrimmedCurve.hpp>
#include <geometry/Geom3TrimmedSurface.hpp>
#include <geometry/GeomAPIExtremaCurveCurve3.hpp>
#include <geometry/GeomAPIProjectPointOnCurve2.hpp>
#include <geometry/GeomAPIProjectPointOnCurve3.hpp>
#include <geometry/GeomAPIProjectPointOnSurface.hpp>
#include <geometry/GeometryTool.hpp>
#include <geometry/GlobalProperty.hpp>
#include <healing/ShapeFixTool.hpp>
#include <io/STLTool.hpp>
#include <math/Sphere.hpp>
#include <math/TriangularMesh.hpp>
#include <modeling/CopyShape.hpp>
#include <modeling/MakeBox.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeFace.hpp>
#include <modeling/MakePrism.hpp>
#include <modeling/MakeRevol.hpp>
#include <modeling/MakeShapeTool.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeWire.hpp>
#include <modeling/TransformShape.hpp>
#include <nurbs/NURBSAPIApprox.hpp>
#include <nurbs/NURBSAPIBuildCurve.hpp>
#include <nurbs/NURBSAPICircularSweep.hpp>
#include <nurbs/NURBSAPIConvert.hpp>
#include <nurbs/NURBSAPICurveNetworkSurface.hpp>
#include <nurbs/NURBSAPIExplicitSweep.hpp>
#include <nurbs/NURBSAPIExplode.hpp>
#include <nurbs/NURBSAPIExtend.hpp>
#include <nurbs/NURBSAPIInterpolate.hpp>
#include <nurbs/NURBSAPIJoin.hpp>
#include <nurbs/NURBSAPILinearSweep.hpp>
#include <nurbs/NURBSAPILoft.hpp>
#include <nurbs/NURBSAPIMakeNURBSFromBoundaries.hpp>
#include <nurbs/NURBSAPIMatch.hpp>
#include <nurbs/NURBSAPIModifyEndToPlane.hpp>
#include <nurbs/NURBSAPIOffsetCurveOnSurface.hpp>
#include <nurbs/NURBSAPIProject.hpp>
#include <nurbs/NURBSAPIRebuild.hpp>
#include <nurbs/NURBSAPIReplaceEdge.hpp>
#include <nurbs/NURBSAPISweep.hpp>
#include <nurbs/NURBSAPISweep2.hpp>
#include <nurbs/NURBSAPISweepRotation.hpp>
#include <nurbs/NURBSAPITrim.hpp>
#include <nurbs/NURBSAPIUntrim.hpp>
#include <nurbs/NURBSLinearSweepWithDraftDirectionLength.hpp>
#include <occtio/OCCTTool.hpp>
#include <offset/MakePipe.hpp>
#include <offset/MakePipeShell.hpp>
#include <topology/BRepAdaptorCurve2.hpp>
#include <topology/BRepAdaptorCurve3.hpp>
#include <topology/BRepAdaptorSurface.hpp>
#include <topology/BRepGlobalProperty.hpp>
#include <topology/BRepTool.hpp>
#include <topology/TopoBuilder.hpp>
#include <topology/TopoCompound.hpp>
#include <topology/TopoEdge.hpp>
#include <topology/TopoExplorer.hpp>
#include <topology/TopoExplorerTool.hpp>
#include <topology/TopoFace.hpp>
#include <topology/TopoShape.hpp>
#include <topology/TopoShell.hpp>
#include <topology/TopoTool.hpp>
#include <topology/TopoVertex.hpp>
#include <topology/TopoWire.hpp>
#include <topology/WireExplorer.hpp>
#include <topomesh/BRepMeshIncrementalMesh.hpp>
#include <nurbs/NURBSAPIBlend.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
#include <math/LineT.hpp>
#include <hatch/BRepClassificationTools.hpp>
using namespace AMCAX;
namespace
{
	std::shared_ptr<Geom3BSplineCurve> CurveChooser(const int id, const std::shared_ptr<Geom3BSplineCurve>& curve0, const std::shared_ptr<Geom3BSplineCurve>& curve1, const std::shared_ptr<Geom3BSplineCurve>& curve2)
	{
		std::shared_ptr<Geom3BSplineCurve> result;
		switch (id)
		{
		case 0:
		{
			result = curve0;
			break;
		}
		case 1:
		{
			result = curve1;
			break;
		}
		case 2:
		{
			result = curve2;
			break;
		}
		}
		return result;
	}
} 
TEST_CASE("case1:this is a case for ExplicitSweep", "[nurbs][forcase1][Explicit]") {
	GlobalProperty g;
	SECTION("TestExplicitSweepWithTwoGuideCurvesTwoPoints()")
	{
		std::string filedir = INPUT_PATH_PREFIX "/TestNURBS/TestExplicitSweepWithTwoGuideCurvesTwoPoints/";
		auto profile = ReadBRepCurve(filedir + "profile.brep");
		CHECK(OCCTIO::OCCTTool::Write(MakeEdge(profile), OUTPUT_PATH_PREFIX "TestExplicitSweepWithTwoGuideCurvesTwoPoints_profile.brep"));
		auto guide1 = ReadBRepCurve(filedir + "guide1.brep");
		CHECK(OCCTIO::OCCTTool::Write(MakeEdge(guide1), OUTPUT_PATH_PREFIX "TestExplicitSweepWithTwoGuideCurvesTwoPoints_guide1.brep"));
		auto guide2 = ReadBRepCurve(filedir + "guide2.brep");
		CHECK(OCCTIO::OCCTTool::Write(MakeEdge(guide2), OUTPUT_PATH_PREFIX "TestExplicitSweepWithTwoGuideCurvesTwoPoints_guide2.brep"));
		auto anchorPoint1 = ReadBRepPoint(filedir + "point1.brep");
		auto anchorPoint2 = ReadBRepPoint(filedir + "point2.brep");
		CHECK(OCCTIO::OCCTTool::Write(MakeVertex(anchorPoint1), OUTPUT_PATH_PREFIX "TestExplicitSweepWithTwoGuideCurvesTwoPoints_point1.brep"));
		CHECK(OCCTIO::OCCTTool::Write(MakeVertex(anchorPoint2), OUTPUT_PATH_PREFIX "TestExplicitSweepWithTwoGuideCurvesTwoPoints_point2.brep"));
		auto [status, surface] = NURBSAPIExplicitSweep::SweepWithTwoGuideCurves(profile, guide1, guide2, anchorPoint1, anchorPoint2, guide1, guide1->FirstParameter(), guide1->LastParameter());
		CHECK(status == NURBSSweepStatus::Success);
		if (status == NURBSSweepStatus::Success)
		{
			CHECK(OCCTIO::OCCTTool::Write(MakeFace(surface, 0.0), OUTPUT_PATH_PREFIX "TestExplicitSweepWithTwoGuideCurvesTwoPoints_result.brep"));
			AMCAX::BRepExtremaDistShapeShape len1(MakeFace(surface, 0.0), MakeEdge(guide1));
			AMCAX::BRepExtremaDistShapeShape len2(MakeFace(surface, 0.0), MakeEdge(guide2));
			AMCAX::BRepExtremaDistShapeShape len3(MakeFace(surface, 0.0), MakeEdge(profile));
			CHECK(len1.Value() == Approx(0.0).margin(0.1));
			CHECK(len2.Value() == Approx(0.0).margin(0.1));
			CHECK(len3.Value() == Approx(0.0).margin(0.1));
		}
		profile->IncreaseDegree(11);
		guide1->IncreaseDegree(11);
		guide2->IncreaseDegree(11);
		auto [status1, surface1] = NURBSAPIExplicitSweep::SweepWithTwoGuideCurves(profile, guide1, guide2, anchorPoint1, anchorPoint2, guide1, guide1->FirstParameter(), guide1->LastParameter());
		CHECK(status1 == NURBSSweepStatus::Success);
		if (status1 == NURBSSweepStatus::Success)
		{
			CHECK(OCCTIO::OCCTTool::Write(MakeFace(surface1, 0.0), OUTPUT_PATH_PREFIX "TestExplicitSweepWithTwoGuideCurvesTwoPoints_degree11result.brep"));
			AMCAX::BRepExtremaDistShapeShape len1(MakeFace(surface1, 0.0), MakeEdge(guide1));
			AMCAX::BRepExtremaDistShapeShape len2(MakeFace(surface1, 0.0), MakeEdge(guide2));
			AMCAX::BRepExtremaDistShapeShape len3(MakeFace(surface1, 0.0), MakeEdge(profile));
			CHECK(len1.Value() == Approx(0.0).margin(0.1));
			CHECK(len2.Value() == Approx(0.0).margin(0.1));
			CHECK(len3.Value() == Approx(0.0).margin(0.1));
			double bsp3s = GetSurfaceProperties(MakeFace(surface1, 0.0), g, true, true);
			double bsp4s = GetSurfaceProperties(MakeFace(surface, 0.0), g, true, true);
			CHECK(bsp3s == Approx(bsp4s).margin(0.04));
		}
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static std::pair<NURBSSweepStatus, std::vector<std::shared_ptr<Geom3BSplineSurface>>> SweepWithPullingDirection( const std::shared_ptr<Geom3BSplineCurve>& profile, const std::shared_ptr<Geom3BSplineCurve>& guide, const Direction3& direction, const LawFunction& angleLawFunc, const std::shared_ptr<Geom3BSplineCurve>& spine, double spineLeftBound, double spineRightBound),
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <filesystem>
#include <fstream>
#include <random>
#include <sstream>
#include <nurbs/NURBSAPIGetGeometry.hpp>
#include <nurbs/NURBSAPIConicalSweep.hpp>
#include <boolean/BoolBRepCut.hpp>
#include <common/CartesianCoordinateSystem.hpp>
#include <common/IndexMap.hpp>
#include <common/QuaternionT.hpp>
#include <geomAlgo/LawBSpline.hpp>
#include <geomAlgo/LawConstant.hpp>
#include <nurbs/NURBSAPISmooth.hpp>
#include <geomAlgo/MakeConic2FromConstraints.hpp>
#include <geometry/Adaptor3CurveOnSurface.hpp>
#include <geometry/AdaptorGeom2Curve.hpp>
#include <geometry/AdaptorGeom3Surface.hpp>
#include <geometry/Geom2BSplineCurve.hpp>
#include <geometry/Geom2Circle.hpp>
#include <geometry/Geom2Ellipse.hpp>
#include <geometry/Geom2Hyperbola.hpp>
#include <geometry/Geom2Parabola.hpp>
#include <geometry/Geom2TrimmedCurve.hpp>
#include <geometry/Geom3BSplineCurve.hpp>
#include <geometry/Geom3BSplineSurface.hpp>
#include <geometry/Geom3Circle.hpp>
#include <geometry/Geom3Line.hpp>
#include <geometry/Geom3OffsetCurve.hpp>
#include <geometry/Geom3Plane.hpp>
#include <geometry/Geom3SphericalSurface.hpp>
#include <geometry/Geom3Surface.hpp>
#include <geometry/Geom3TrimmedCurve.hpp>
#include <geometry/Geom3TrimmedSurface.hpp>
#include <geometry/GeomAPIExtremaCurveCurve3.hpp>
#include <geometry/GeomAPIProjectPointOnCurve2.hpp>
#include <geometry/GeomAPIProjectPointOnCurve3.hpp>
#include <geometry/GeomAPIProjectPointOnSurface.hpp>
#include <geometry/GeometryTool.hpp>
#include <geometry/GlobalProperty.hpp>
#include <healing/ShapeFixTool.hpp>
#include <io/STLTool.hpp>
#include <math/Sphere.hpp>
#include <math/TriangularMesh.hpp>
#include <modeling/CopyShape.hpp>
#include <modeling/MakeBox.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeFace.hpp>
#include <modeling/MakePrism.hpp>
#include <modeling/MakeRevol.hpp>
#include <modeling/MakeShapeTool.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeWire.hpp>
#include <modeling/TransformShape.hpp>
#include <nurbs/NURBSAPIApprox.hpp>
#include <nurbs/NURBSAPIBuildCurve.hpp>
#include <nurbs/NURBSAPICircularSweep.hpp>
#include <nurbs/NURBSAPIConvert.hpp>
#include <nurbs/NURBSAPICurveNetworkSurface.hpp>
#include <nurbs/NURBSAPIExplicitSweep.hpp>
#include <nurbs/NURBSAPIExplode.hpp>
#include <nurbs/NURBSAPIExtend.hpp>
#include <nurbs/NURBSAPIInterpolate.hpp>
#include <nurbs/NURBSAPIJoin.hpp>
#include <nurbs/NURBSAPILinearSweep.hpp>
#include <nurbs/NURBSAPILoft.hpp>
#include <nurbs/NURBSAPIMakeNURBSFromBoundaries.hpp>
#include <nurbs/NURBSAPIMatch.hpp>
#include <nurbs/NURBSAPIModifyEndToPlane.hpp>
#include <nurbs/NURBSAPIOffsetCurveOnSurface.hpp>
#include <nurbs/NURBSAPIProject.hpp>
#include <nurbs/NURBSAPIRebuild.hpp>
#include <nurbs/NURBSAPIReplaceEdge.hpp>
#include <nurbs/NURBSAPISweep.hpp>
#include <nurbs/NURBSAPISweep2.hpp>
#include <nurbs/NURBSAPISweepRotation.hpp>
#include <nurbs/NURBSAPITrim.hpp>
#include <nurbs/NURBSAPIUntrim.hpp>
#include <nurbs/NURBSLinearSweepWithDraftDirectionLength.hpp>
#include <occtio/OCCTTool.hpp>
#include <offset/MakePipe.hpp>
#include <offset/MakePipeShell.hpp>
#include <topology/BRepAdaptorCurve2.hpp>
#include <topology/BRepAdaptorCurve3.hpp>
#include <topology/BRepAdaptorSurface.hpp>
#include <topology/BRepGlobalProperty.hpp>
#include <topology/BRepTool.hpp>
#include <topology/TopoBuilder.hpp>
#include <topology/TopoCompound.hpp>
#include <topology/TopoEdge.hpp>
#include <topology/TopoExplorer.hpp>
#include <topology/TopoExplorerTool.hpp>
#include <topology/TopoFace.hpp>
#include <topology/TopoShape.hpp>
#include <topology/TopoShell.hpp>
#include <topology/TopoTool.hpp>
#include <topology/TopoVertex.hpp>
#include <topology/TopoWire.hpp>
#include <topology/WireExplorer.hpp>
#include <topomesh/BRepMeshIncrementalMesh.hpp>
#include <nurbs/NURBSAPIBlend.hpp>
#include <topology/BRepExtremaDistShapeShape.hpp>
#include <math/LineT.hpp>
#include <hatch/BRepClassificationTools.hpp>
using namespace AMCAX;
namespace
{
	std::shared_ptr<Geom3BSplineCurve> CurveChooser(const int id, const std::shared_ptr<Geom3BSplineCurve>& curve0, const std::shared_ptr<Geom3BSplineCurve>& curve1, const std::shared_ptr<Geom3BSplineCurve>& curve2)
	{
		std::shared_ptr<Geom3BSplineCurve> result;
		switch (id)
		{
		case 0:
		{
			result = curve0;
			break;
		}
		case 1:
		{
			result = curve1;
			break;
		}
		case 2:
		{
			result = curve2;
			break;
		}
		}
		return result;
	}
} 
TEST_CASE("case1:this is a case for ExplicitSweep", "[nurbs][forcase1][Explicit]") {
	GlobalProperty g;
	SECTION("TestExplicitSweepWithPullingDirection()")
	{
		std::string filedir = INPUT_PATH_PREFIX "/TestNURBS/TestExplicitSweepWithPullingDirection/";
		auto guide = ReadBRepCurve(filedir + "guide.brep");
		CHECK(OCCTIO::OCCTTool::Write(MakeEdge(guide), OUTPUT_PATH_PREFIX "TestExplicitSweepWithPullingDirection_guide.brep"));
		auto profile = ReadBRepCurve(filedir + "profile.brep");
		CHECK(OCCTIO::OCCTTool::Write(MakeEdge(profile), OUTPUT_PATH_PREFIX "TestExplicitSweepWithPullingDirection_profile.brep"));
		auto spineLineEdge = ReadBRepEdge(filedir + "spine.brep");
		double fp, lp;
		auto spineLine = TopoTool::Curve(spineLineEdge, fp, lp);
		auto spine = NURBSAPIConvert::ToBSpline(std::make_shared<Geom3TrimmedCurve>(spineLine, 0, 3));
		CHECK(OCCTIO::OCCTTool::Write(MakeEdge(spine), OUTPUT_PATH_PREFIX "TestExplicitSweepWithPullingDirection_spine.brep"));
		auto pullingDirectionEdge = ReadBRepEdge(filedir + "pullingDirection.brep");
		auto dirCurve = TopoTool::Curve(pullingDirectionEdge, fp, lp);
		Point3 p1, p2;
		Vector3 d1, d2;
		dirCurve->D1(0.0, p1, d1);
		dirCurve->D1(1.0, p2, d2);
		Direction3 pullingDirection(d1);
		LawConstant law;
		law.Set(0.0, 0.0, 1.0);
		auto [status, surfaces] = NURBSAPIExplicitSweep::SweepWithPullingDirection(profile, guide, pullingDirection, law, spine, spine->FirstParameter(), spine->LastParameter());
		CHECK(status == NURBSSweepStatus::Success);
		if (status == NURBSSweepStatus::Success)
		{
			for (int i = 0; i < surfaces.size(); i++)
			{
				CHECK(OCCTIO::OCCTTool::Write(MakeFace(surfaces[i], 0.0), OUTPUT_PATH_PREFIX "TestExplicitSweepWithPullingDirection_result" + std::to_string(i) + ".brep"));
				CHECK(IsCurveOnSurf(1000, 0.3, guide, surfaces[i], 0.1));
				AMCAX::BRepExtremaDistShapeShape len1(MakeFace(surfaces[i], 0.0), MakeEdge(guide));
				AMCAX::BRepExtremaDistShapeShape len2(MakeFace(surfaces[i], 0.0), MakeEdge(profile));
				CHECK(len1.Value() == Approx(0.0).margin(0.1));
				CHECK(len2.Value() == Approx(0.0).margin(0.1));
				if (i < 2) {
					CHECK(IsCurveOnSurf(1000, 0.1, profile, surfaces[i], 0.1));
				}
			}
		}
		profile->IncreaseDegree(5);
		guide->IncreaseDegree(5);
		spine->IncreaseDegree(5);
		auto [status1, surfaces1] = NURBSAPIExplicitSweep::SweepWithPullingDirection(profile, guide, pullingDirection, law, spine, spine->FirstParameter(), spine->LastParameter());
		CHECK(status1 == NURBSSweepStatus::Success);
		if (status1 == NURBSSweepStatus::Success)
		{
			for (int i = 0; i < surfaces1.size(); i++)
			{
				CHECK(OCCTIO::OCCTTool::Write(MakeFace(surfaces1[i], 0.0), OUTPUT_PATH_PREFIX "TestExplicitSweepWithPullingDirection_degree5result" + std::to_string(i) + ".brep"));
				CHECK(IsCurveOnSurf(1000, 0.3, guide, surfaces1[i], 0.1));
				AMCAX::BRepExtremaDistShapeShape len1(MakeFace(surfaces1[i], 0.0), MakeEdge(guide));
				AMCAX::BRepExtremaDistShapeShape len2(MakeFace(surfaces1[i], 0.0), MakeEdge(profile));
				CHECK(len1.Value() == Approx(0.0).margin(0.1));
				CHECK(len2.Value() == Approx(0.0).margin(0.1));
				if (i < 2) {
					CHECK(IsCurveOnSurf(1000, 0.1, profile, surfaces1[i], 0.1));
					double bsp3s = GetSurfaceProperties(MakeFace(surfaces1[i], 0.0), g, true, true);
					double bsp4s = GetSurfaceProperties(MakeFace(surfaces[i], 0.0), g, true, true);
					CHECK(bsp3s == Approx(bsp4s).margin(0.02));
				}
			}
		}
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static std::vector<std::shared_ptr<Geom3BSplineCurve>> ExplodeCurve(const std::shared_ptr<Geom3BSplineCurve>& curve)	 @return The result curves
	 @param curve The given curve
	 @brief Explode a curve into curves at C0 points
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <nurbs/NURBSAPIExplode.hpp>
#include <topology/TopoEdge.hpp>
#include <topology/TopoTool.hpp>
#include <nurbs/NURBSAPIJoin.hpp>
#include <nurbs/NURBSAPIExplode.hpp>
#include <geometry/Geom3BSplineCurve.hpp>
#include <geometry/Geom3BSplineSurface.hpp>
#include <topology/TopoFace.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeFace.hpp>
TEST_CASE("case1: this is a test for Explode-ExplodeCurve", "[nurbs][Explode][P1]")
{
	int num = 1000;
	double sTol = DEFAULT_TOLERANCE;
	double ratio = 0.1;
	double linTol = DEFAULT_TOLERANCE;
    string filename;
	string filedir = INPUT_PATH_PREFIX"./TestNURBS/TestJoinCurve/";
	SECTION("isPeriodic")
	{
		OUTPUT_DIRECTORY(nurbs, Explode/ExplodeCurve1);
		filename = "periodicCurve";
		std::vector<std::shared_ptr<Geom3BSplineCurve>> curves;
		for (int i = 0; i < 3; i++)
		{
			curves.push_back(ReadBRepCurve(filedir + filename + std::to_string(i) + ".brep"));
		}
		auto [sortedCurves, isReverse, isResultPeriodic] = NURBSAPIJoin::JoinCurvePrepare(curves, 0.0001);
		auto results = NURBSAPIJoin::JoinCurves(sortedCurves, isReverse, isResultPeriodic);
		int nresults = static_cast<int>(results.size());
		for (int i = 0; i < nresults; i++)
		{
			OCCTIO::OCCTTool::Write(MakeEdge(results[i]), outdir + "joinCurve" + to_string(i) + ".brep");
		}
		auto explodeResult = NURBSAPIExplode::ExplodeCurve(results.front());
		int expResults = static_cast<int>(explodeResult.size());
		for (int j = 0; j < expResults; j++)
		{
			OCCTIO::OCCTTool::Write(MakeEdge(explodeResult[j]), outdir + "expCurve" + to_string(j) + ".brep");
		}
		CHECK(results.size() == 1);
		CHECK(explodeResult.size() == 3);
		Point3 p1, p2, p3, p4;
		p1 = curves[0]->StartPoint();
		p2 = curves[2]->EndPoint();
		p3 = results[0]->StartPoint();
		p4 = results[0]->EndPoint();
		CHECK(p1.X() == Approx(p3.X()));
		CHECK(p1.Y() == Approx(p3.Y()));
		CHECK(p1.Z() == Approx(p3.Z()));
		CHECK(p2.X() == Approx(p4.X()));
		CHECK(p2.Y() == Approx(p4.Y()));
		CHECK(p2.Z() == Approx(p4.Z()));
		TopoShape c1 = MakeEdge(curves[0]);
		TopoShape c2 = MakeEdge(curves[1]);
		TopoShape c3 = MakeEdge(curves[2]);
		TopoShape c = MakeEdge(results[0]);
		TopoShape e1 = MakeEdge(explodeResult[0]);
		TopoShape e2 = MakeEdge(explodeResult[1]);
		TopoShape e3 = MakeEdge(explodeResult[2]);
		GlobalProperty props1, props2, props3, props4, props5, props6, props7;
		double len1 = GetLinearProperties(c1, props1, true, false);
		double len2 = GetLinearProperties(c2, props2, true, false);
		double len3 = GetLinearProperties(c3, props3, true, false);
		double joinLen = GetLinearProperties(c, props4, true, false);
		double exLen1 = GetLinearProperties(e1, props5, true, false);
		double exLen2 = GetLinearProperties(e2, props6, true, false);
		double exLen3 = GetLinearProperties(e3, props7, true, false);
		double cuvLen = len1 + len2 + len3;
		double len = abs(cuvLen - joinLen);
		double len11 = abs(len1 - exLen1);
		double len22 = abs(len2 - exLen2);
		double len33 = abs(len3 - exLen3);
		CHECK(len < 0.1);
		CHECK(len11 < 0.1);
		CHECK(len22 < 0.1);
		CHECK(len33 < 0.1);
		double res1 = NurbsSampleCurve(num, sTol, curves[0], explodeResult[0]);
		double res2 = NurbsSampleCurve(num, sTol, curves[1], explodeResult[1]);
		double res3 = NurbsSampleCurve(num, sTol, curves[2], explodeResult[2]);
		CHECK(res1 <= ratio);
		CHECK(res2 <= ratio);
		CHECK(res3 <= ratio);
		OCCTIO::OCCTTool::Write(MakeEdge(curves[0]), outdir + "curve0.brep");
		OCCTIO::OCCTTool::Write(MakeEdge(curves[1]), outdir + "curve1.brep");
		OCCTIO::OCCTTool::Write(MakeEdge(curves[2]), outdir + "curve2.brep");
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static Array2<std::shared_ptr<Geom3BSplineSurface>> ExplodeSurface(const std::shared_ptr<Geom3BSplineSurface>& surface)	 @return The result surfaces
	 @param surface The given surface
	 @brief Explode a surface into patches at C0 isocurves
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <nurbs/NURBSAPIExplode.hpp>
#include <topology/TopoEdge.hpp>
#include <topology/TopoTool.hpp>
#include <nurbs/NURBSAPIJoin.hpp>
#include <nurbs/NURBSAPIExplode.hpp>
#include <geometry/Geom3BSplineCurve.hpp>
#include <geometry/Geom3BSplineSurface.hpp>
#include <topology/TopoFace.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeFace.hpp>
TEST_CASE("case1: this is a test for Explode-ExplodeSurface", "[nurbs][Explode][P1]")
{
	int num = 1000;
	double sTol = DEFAULT_TOLERANCE;
	double ratio = 0.1;
	double linTol = DEFAULT_TOLERANCE;
	SECTION("isUPeriodic+nonVPeriodic")
	{
		OUTPUT_DIRECTORY(nurbs, Explode/ExplodeSurface3);
		string filedir = INPUT_PATH_PREFIX"./TestNURBS/TestJoinSurface/";
		std::vector<std::shared_ptr<Geom3BSplineSurface>> surfaces;
		surfaces.push_back(ReadBRepSurface(filedir + "surface0.brep"));
		surfaces.push_back(ReadBRepSurface(filedir + "surface1.brep"));
		surfaces.push_back(ReadBRepSurface(filedir + "surface2.brep"));
		surfaces.push_back(ReadBRepSurface(filedir + "surface3.brep"));
		auto [sortedSurfaces, isUIso, isFrontBackReverse, isIsoReverse, isLocalUPeriodic, isLocalVPeriodic] = NURBSAPIJoin::JoinSurfacesPrepare(surfaces, 0.0001);
		auto [isSucceed, result] = NURBSAPIJoin::JoinSurfaces(sortedSurfaces, isUIso, isFrontBackReverse, isIsoReverse, isLocalUPeriodic, isLocalVPeriodic);
		Throw_Construction_Error_if(!isSucceed, "failed");
		CHECK(isSucceed == true);
		auto explodeResult = NURBSAPIExplode::ExplodeSurface(result);
		int row = explodeResult.NRow();
		int col = explodeResult.NCol();
		for (int i = 0; i < row; i++)
		{
			for (int j = 0; j < col; j++)
			{
				OCCTIO::OCCTTool::Write(MakeFace(explodeResult(i, j), 0.0), outdir +  "expSurface" + to_string(i) + to_string(j) +".brep");
			}
		}
		CHECK(row*col == 4);
		TopoShape f1 = MakeFace(surfaces[0],0.0);
		TopoShape f2 = MakeFace(surfaces[1], 0.0);
		TopoShape f3 = MakeFace(surfaces[2], 0.0);
		TopoShape f4 = MakeFace(surfaces[3], 0.0);
		TopoShape f = MakeFace(result,0.0);
		TopoShape exp1 = MakeFace(explodeResult(0, 0), 0.0);
		TopoShape exp2 = MakeFace(explodeResult(1, 0), 0.0);
		TopoShape exp3 = MakeFace(explodeResult(2, 0), 0.0);
		TopoShape exp4 = MakeFace(explodeResult(3, 0), 0.0);
		GlobalProperty props1, props2, props3, props4, props5, props6, props7, props8;
		double surf1 = GetSurfaceProperties(f1, props1, true, false);
		double surf2 = GetSurfaceProperties(f2, props2, true, false);
		double surf3 = GetSurfaceProperties(f3, props3, true, false);
		double surf4 = GetSurfaceProperties(f4, props4, true, false);
		double surface = GetSurfaceProperties(f, props5, true, false);
		double exSurf1 = GetSurfaceProperties(exp1, props5, true, false);
		double exSurf2 = GetSurfaceProperties(exp2, props6, true, false);
		double exSurf3 = GetSurfaceProperties(exp3, props7, true, false);
		double exSurf4 = GetSurfaceProperties(exp4, props8, true, false);
		double surf = surf1 + surf2 + surf3 + surf4;
		double dif = abs(surface - surf);
		double dif1 = abs(surf1 - exSurf1);
		double dif2 = abs(surf2 - exSurf2);
		double dif3 = abs(surf3 - exSurf3);
		double dif4 = abs(surf4 - exSurf4);
		CHECK(dif1 < 0.1);
		CHECK(dif2 < 0.1);
		CHECK(dif3 < 0.1);
		CHECK(dif4 < 0.1);
		double res1 = NurbsSampleSurface(num, sTol, surfaces[0], explodeResult(0, 0));
		double res2 = NurbsSampleSurface(num, sTol, surfaces[1], explodeResult(1, 0));
		double res3 = NurbsSampleSurface(num, sTol, surfaces[2], explodeResult(2, 0));
		double res4 = NurbsSampleSurface(num, sTol, surfaces[3], explodeResult(3, 0));
		CHECK(res1 <= ratio);
		CHECK(res2 <= ratio);
		CHECK(res3 <= ratio);
		CHECK(res4 <= ratio);
		OCCTIO::OCCTTool::Write(MakeFace(surfaces[0], 0.0), outdir + "surf1.brep");
		OCCTIO::OCCTTool::Write(MakeFace(surfaces[1], 0.0), outdir + "surf2.brep");
		OCCTIO::OCCTTool::Write(MakeFace(surfaces[2], 0.0), outdir + "surf3.brep");
		OCCTIO::OCCTTool::Write(MakeFace(surfaces[3], 0.0), outdir + "surf4.brep");
		OCCTIO::OCCTTool::Write(MakeFace(result, 0.0), outdir + "joinSurface.brep");
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":void SetMajorRadius(double r)	 @param r The new major radius
	 @brief Set the major radius
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <modeling/MakeFace.hpp>
#include <common/AxisT.hpp>
#include <math/HyperbolaT.hpp>
#include <occtio/OCCTTool.hpp>
#include <common/VectorT.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <topology/TopoEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <iostream>
using namespace AMCAX;
using namespace std;
TEST_CASE("case1:this is a case for Hyperbola3", "[math][Hyperbola3][p1]") {
	Point3 point3_fr(0.0, 0.0, 1.0);
	Direction3 dir3_fr(0.0, 0.0, 1.0);
	Frame3 frame3(point3_fr, dir3_fr);
	double major3 = 3.0, minor3 = 4.0;
	Hyperbola3 hyperbola3d_fr(frame3, major3, minor3);
	SECTION("Default()") {
		Hyperbola3 hyperbola3d_de;	
		CHECK(hyperbola3d_de.Location().X() == Approx(0.0));
		CHECK(hyperbola3d_de.Location().Y() == Approx(0.0));
		CHECK(hyperbola3d_de.Location().Z() == Approx(0.0));
		hyperbola3d_de.SetMajorRadius(3.0);
		hyperbola3d_de.SetMinorRadius(4.0);
		CHECK(hyperbola3d_de.MajorRadius() == Approx(3.0));
		CHECK(hyperbola3d_de.MinorRadius() == Approx(4.0));
		CHECK(hyperbola3d_de.Focal() == Approx(10.0));
		CHECK(hyperbola3d_de.Focus1().X() == Approx(5.0));
		CHECK(hyperbola3d_de.Focus1().Y() == Approx(0.0));
		CHECK(hyperbola3d_de.Focus1().Z() == Approx(0.0));
	}}
}
,