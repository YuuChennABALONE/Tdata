{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] AMCAX_API static Point3 D0(double u, const Line3& line)	 @return The resulting point
	 @param line The line
	 @param u The parameter
	 @brief Compute the point on a 3D line at a parameter
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
#include <occtio/OCCTTool.hpp>
#include <geometry/MakeArcOfHyperbola2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeEdge2d.hpp>
using namespace AMCAX;
TEST_CASE("case1: CurveCalculation::D0() [6/10] ", "[math][CurveCalculation][P1][D0]") {
	Frame3 fram3;
	double major_radius = 1000.0;
	double minor_radius = 10.0;
	Hyperbola3 hyperbola(fram3, major_radius, minor_radius);
	Point3 point3 = CurveCalculation::D0(0.0, hyperbola);
	CHECK(point3.X() == 1000.0);
	CHECK(point3.Y() == 0.0);
	CHECK(point3.Z() == 0.0);
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] AMCAX_API static Point3 D0(double u, const Circle3& circle)	 @return The resulting point
	 @param circle The circle
	 @param u The parameter
	 @brief Compute the point on a 3D circle at a parameter
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
#include <occtio/OCCTTool.hpp>
#include <geometry/MakeArcOfHyperbola2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeEdge2d.hpp>
using namespace AMCAX;
TEST_CASE("case1: CurveCalculation::D0() [2/10] ", "[math][CurveCalculation][P1][D0]") {
	AMCAX::Circle3 circle3D;
	AMCAX::Point3  center3D(1.0, 1.0, 1.0);
	double radius3D = 5.0;
	double tol = 0.1;
	circle3D.SetLocation(center3D);
	circle3D.SetRadius(radius3D);
	Point3 point3 = AMCAX::CurveCalculation::D0(M_PI_2, circle3D);
	CHECK(point3.X() == Approx(1.0));
	CHECK(point3.Y() == 6.0);
	CHECK(point3.Z() == 1.0);
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] AMCAX_API static Point3 D0(double u, const Ellipse3& ellipse)	 @return The resulting point
	 @param ellipse The ellipse
	 @param u The parameter
	 @brief Compute the point on a 3D ellipse at a parameter
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
#include <occtio/OCCTTool.hpp>
#include <geometry/MakeArcOfHyperbola2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeEdge2d.hpp>
using namespace AMCAX;
TEST_CASE("case1: CurveCalculation::D0() [4/10] ", "[math][CurveCalculation][P1][D0]") {
	Frame3 fram3 = Frame3(Point3(0.0, 0.0, 1.0), Direction3(0.0, 0.0, 1.0));
	AMCAX::Ellipse3 ellipse3(fram3, 5.0, 3.0);
	Point3 point3 = AMCAX::CurveCalculation::D0(M_PI_2, ellipse3);
	CHECK(point3.X() == Approx(0.0).margin(1e-12));
	CHECK(point3.Y() == 3.0);
	CHECK(point3.Z() == 1.0);
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] AMCAX_API static Point3 D0(double u, const Parabola3& parabola)	 @return The resulting point
	 @param parabola The parabola
	 @param u The parameter
	 @brief Compute the point on a 3D parabola at a parameter
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
#include <occtio/OCCTTool.hpp>
#include <geometry/MakeArcOfHyperbola2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeEdge2d.hpp>
using namespace AMCAX;
TEST_CASE("case1: CurveCalculation::D0() [10/10] ", "[math][CurveCalculation][P1][D0]") {
	Point3 point3(0.0, 0.0, 0.0);
	Direction3 dir3(0.0, 0.0, 1.0);
	Frame3 fram3(point3, dir3);
	double focal = 2.0;
	Parabola3 parabola3(fram3, focal);
	SECTION("u =0") {
		Point3 point3 = CurveCalculation::D0(0.0, parabola3);
		CHECK(point3.X() == 0.0);
		CHECK(point3.Y() == 0.0);
		CHECK(point3.Z() == 0.0);
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] AMCAX_API static Point3 D0(double u, const Hyperbola3& hyperbola)	 @return The resulting point
	 @param hyperbola The hyperbola
	 @param u The parameter
	 @brief Compute the point on a 3D hyperbola at a parameter
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
#include <occtio/OCCTTool.hpp>
#include <geometry/MakeArcOfHyperbola2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeEdge2d.hpp>
using namespace AMCAX;
TEST_CASE("case1: CurveCalculation::D0() [6/10] ", "[math][CurveCalculation][P1][D0]") {
	Frame3 fram3;
	double major_radius = 1000.0;
	double minor_radius = 10.0;
	Hyperbola3 hyperbola(fram3, major_radius, minor_radius);
	Point3 point3 = CurveCalculation::D0(0.0, hyperbola);
	CHECK(point3.X() == 1000.0);
	CHECK(point3.Y() == 0.0);
	CHECK(point3.Z() == 0.0);
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] AMCAX_API static Point2 D0(double u, const Line2& line)	 @return The resulting point
	 @param line The line
	 @param u The parameter
	 @brief Compute the point on a 2D line at a parameter
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
#include <occtio/OCCTTool.hpp>
#include <geometry/MakeArcOfHyperbola2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeEdge2d.hpp>
using namespace AMCAX;
TEST_CASE("case1: CurveCalculation::D0() [1/10] ", "[math][CurveCalculation][P1][D0]") {
	AMCAX::Point2 P(0.0, 0.0);
	AMCAX::Direction2 D(1.0, 0.0);
	AMCAX::Axis2  axis2(P, D);
	float radius = 2.0f;
	AMCAX::Circle2 circle2(axis2, radius, true);
	Point2 point2 = AMCAX::CurveCalculation::D0(0.0, circle2);
	CHECK(point2.X() == 2.0);
	CHECK(point2.Y() == 0.0);
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] AMCAX_API static Point2 D0(double u, const Circle2& circle)	 @return The resulting point
	 @param circle The circle
	 @param u The parameter
	 @brief Compute the point on a 2D circle at a parameter
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
#include <occtio/OCCTTool.hpp>
#include <geometry/MakeArcOfHyperbola2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeEdge2d.hpp>
using namespace AMCAX;
TEST_CASE("case1: CurveCalculation::D0() [1/10] ", "[math][CurveCalculation][P1][D0]") {
	AMCAX::Point2 P(0.0, 0.0);
	AMCAX::Direction2 D(1.0, 0.0);
	AMCAX::Axis2  axis2(P, D);
	float radius = 2.0f;
	AMCAX::Circle2 circle2(axis2, radius, true);
	Point2 point2 = AMCAX::CurveCalculation::D0(0.0, circle2);
	CHECK(point2.X() == 2.0);
	CHECK(point2.Y() == 0.0);
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] AMCAX_API static Point2 D0(double u, const Ellipse2& ellipse)	 @return The resulting point
	 @param ellipse The ellipse
	 @param u The parameter
	 @brief Compute the point on a 2D ellipse at a parameter
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
#include <occtio/OCCTTool.hpp>
#include <geometry/MakeArcOfHyperbola2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeEdge2d.hpp>
using namespace AMCAX;
TEST_CASE("case1: CurveCalculation::D0() [3/10] ", "[math][CurveCalculation][P1][D0]") {
	AMCAX::Ellipse2 ellipse2(AMCAX::Axis2(AMCAX::Point2(0.0, 0.0), AMCAX::Direction2(1.0, 0.0)), 5.0, 3.0);
	Point2 point2 = AMCAX::CurveCalculation::D0(M_PI_2, ellipse2);
	CHECK(point2.X() == Approx(0.0).margin(1e-12));
	CHECK(point2.Y() == 3.0);
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] AMCAX_API static Point2 D0(double u, const Parabola2& parabola)	 @return The resulting point
	 @param parabola The parabola
	 @param u The parameter
	 @brief Compute the point on a 2D parabola at a parameter
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
#include <occtio/OCCTTool.hpp>
#include <geometry/MakeArcOfHyperbola2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeEdge2d.hpp>
using namespace AMCAX;
TEST_CASE("case1: CurveCalculation::D0() [9/10] ", "[math][CurveCalculation][P1][D0]") {
	AMCAX::Point2 P(0.0, 0.0);
	AMCAX::Direction2 D(1.0, 0.0);
	AMCAX::Axis2  axis2(P, D);
	double focal = 2.0;
	AMCAX::Parabola2 parabola2(axis2,focal );
	SECTION("u =0") {  
		Point2 point2 = CurveCalculation::D0(0.0, parabola2); 
		CHECK(point2.X() == 0.0);
		CHECK(point2.Y() == 0.0);
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] AMCAX_API static Point2 D0(double u, const Hyperbola2& hyperbola)	 @return The resulting point
	 @param hyperbola The hyperbola
	 @param u The parameter
	 @brief Compute the point on a 2D hyperbola at a parameter
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
#include <occtio/OCCTTool.hpp>
#include <geometry/MakeArcOfHyperbola2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeEdge2d.hpp>
using namespace AMCAX;
TEST_CASE("case1: CurveCalculation::D0() [5/10] ", "[math][CurveCalculation][P1][D0]") {
	Axis2 majorAxis;
	double major_radius = 5;
	double minor_radius = 3;
	Hyperbola2 hyperbola(majorAxis, major_radius, minor_radius);
	Point2 point2 = CurveCalculation::D0(0.0, hyperbola);
	CHECK(point2.X() == 5.0);
	CHECK(point2.Y() == 0.0);
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] AMCAX_API static Vector3 D1(double u, const Line3& line)	 @return The first derivative vector
	 @param line The line
	 @param u The parameter
	 @brief Compute the first derivative on a 3D line at a parameter
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
#include <occtio/OCCTTool.hpp>
#include <geometry/MakeArcOfHyperbola2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeEdge2d.hpp>
using namespace AMCAX;
TEST_CASE("case1: CurveCalculation::D1() circle3[3/20] ", "[math][CurveCalculation][P1][D1]") {
	Direction3 initialDir(0.0, 0.0, 1.0); 
	Frame3 defaultFrame3(Point3(1.0, 0.0, 0.0), initialDir); 
	double radius = 2.0; 
	AMCAX::Circle3 circle3(defaultFrame3, radius);
	SECTION("u =0") {
		Vector3 vector3 = CurveCalculation::D1(0.0, circle3);
		CHECK(vector3.X() == Approx(0.0));
		CHECK(vector3.Y() == Approx(2.0));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static void D1(double u, const Line3& line, Point3& p, Vector3& v1)	 @param[out] v1 The first derivative
	 @param[out] p The point
	 @param[in] line The line
	 @param[in] u The parameter
	 @brief Compute the point and the first derivative on a 3D line at a parameter
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
#include <occtio/OCCTTool.hpp>
#include <geometry/MakeArcOfHyperbola2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeEdge2d.hpp>
using namespace AMCAX;
TEST_CASE("case1: CurveCalculation::D1() circle3[4/20] ", "[math][CurveCalculation][P1][D1]") {
	Direction3 initialDir(0.0, 0.0, 1.0);
	Frame3 defaultFrame3(Point3(1.0, 1.0, 0.0), initialDir);
	Point3 p;
	Vector3 v;
	double radius = 2.0; 
	AMCAX::Circle3 circle3(defaultFrame3, radius);
	SECTION("u =0") {
		CurveCalculation::D1(0.0, circle3,p,v);
		CHECK(p.X() == 3.0);
		CHECK(p.Y() == 1.0);
		CHECK(p.Z() == 0.0);
		CHECK(v.X() == Approx(0.0));
		CHECK(v.Y() == Approx(2.0));
		CHECK(v.Z() == Approx(0.0));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] AMCAX_API static Vector3 D1(double u, const Circle3& circle)	 @return The first derivative vector
	 @param circle The circle
	 @param u The parameter
	 @brief Compute the first derivative on a 3D circle at a parameter
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
#include <occtio/OCCTTool.hpp>
#include <geometry/MakeArcOfHyperbola2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeEdge2d.hpp>
using namespace AMCAX;
TEST_CASE("case1: CurveCalculation::D1() circle3[3/20] ", "[math][CurveCalculation][P1][D1]") {
	Direction3 initialDir(0.0, 0.0, 1.0); 
	Frame3 defaultFrame3(Point3(1.0, 0.0, 0.0), initialDir); 
	double radius = 2.0; 
	AMCAX::Circle3 circle3(defaultFrame3, radius);
	SECTION("u =0") {
		Vector3 vector3 = CurveCalculation::D1(0.0, circle3);
		CHECK(vector3.X() == Approx(0.0));
		CHECK(vector3.Y() == Approx(2.0));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static void D1(double u, const Circle3& circle, Point3& p, Vector3& v1)	 @param[out] v1 The first derivative
	 @param[out] p The point
	 @param[in] circle The circle
	 @param[in] u The parameter
	 @brief Compute the point and the first derivative on a 3D circle at a parameter
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
#include <occtio/OCCTTool.hpp>
#include <geometry/MakeArcOfHyperbola2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeEdge2d.hpp>
using namespace AMCAX;
TEST_CASE("case1: CurveCalculation::D1() circle3[4/20] ", "[math][CurveCalculation][P1][D1]") {
	Direction3 initialDir(0.0, 0.0, 1.0);
	Frame3 defaultFrame3(Point3(1.0, 1.0, 0.0), initialDir);
	Point3 p;
	Vector3 v;
	double radius = 2.0; 
	AMCAX::Circle3 circle3(defaultFrame3, radius);
	SECTION("u =0") {
		CurveCalculation::D1(0.0, circle3,p,v);
		CHECK(p.X() == 3.0);
		CHECK(p.Y() == 1.0);
		CHECK(p.Z() == 0.0);
		CHECK(v.X() == Approx(0.0));
		CHECK(v.Y() == Approx(2.0));
		CHECK(v.Z() == Approx(0.0));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] AMCAX_API static Vector3 D1(double u, const Ellipse3& ellipse)	 @return The first derivative vector
	 @param ellipse The ellipse
	 @param u The parameter
	 @brief Compute the first derivative on a 3D ellipse at a parameter
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
#include <occtio/OCCTTool.hpp>
#include <geometry/MakeArcOfHyperbola2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeEdge2d.hpp>
using namespace AMCAX;
TEST_CASE("case1: CurveCalculation::D1() circle3[3/20] ", "[math][CurveCalculation][P1][D1]") {
	Direction3 initialDir(0.0, 0.0, 1.0); 
	Frame3 defaultFrame3(Point3(1.0, 0.0, 0.0), initialDir); 
	double radius = 2.0; 
	AMCAX::Circle3 circle3(defaultFrame3, radius);
	SECTION("u =0") {
		Vector3 vector3 = CurveCalculation::D1(0.0, circle3);
		CHECK(vector3.X() == Approx(0.0));
		CHECK(vector3.Y() == Approx(2.0));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static void D1(double u, const Ellipse3& ellipse, Point3& p, Vector3& v1)	 @param[out] v1 The first derivative
	 @param[out] p The point
	 @param[in] ellipse The ellipse
	 @param[in] u The parameter
	 @brief Compute the point and the first derivative on a 3D ellipse at a parameter
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
#include <occtio/OCCTTool.hpp>
#include <geometry/MakeArcOfHyperbola2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeEdge2d.hpp>
using namespace AMCAX;
TEST_CASE("case1: CurveCalculation::D1() ellipse3 [7/20] ", "[math][CurveCalculation][P1][D1]") {
	Direction3 initialDir(0.0, 0.0, 1.0); 
	Frame3 defaultFrame3(Point3(0.0, 0.0, 0.0), initialDir); 
	Ellipse3 ellipse3(defaultFrame3,5.0,3.0 );
	MakeEdge edge= MakeEdge(ellipse3);
	bool bWriteresult = OCCTIO::OCCTTool::Write(edge, OUTPUT_PATH_PREFIX"ellipse3CurveCalculation_case1.brep",true,3);
	SECTION("u =0") {
		Vector3 vector3 = CurveCalculation::D1(0.0, ellipse3);
		CHECK(vector3.X() == Approx(0.0));
		CHECK(vector3.Y() == Approx(3.0));
		CHECK(vector3.Z() == Approx(0.0));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] AMCAX_API static Vector3 D1(double u, const Parabola3& parabola)	 @return The first derivative vector
	 @param parabola The parabola
	 @param u The parameter
	 @brief Compute the first derivative on a 3D parabola at a parameter
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
#include <occtio/OCCTTool.hpp>
#include <geometry/MakeArcOfHyperbola2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeEdge2d.hpp>
using namespace AMCAX;
TEST_CASE("case1: CurveCalculation::D1() ellipse3 [7/20] ", "[math][CurveCalculation][P1][D1]") {
	Direction3 initialDir(0.0, 0.0, 1.0); 
	Frame3 defaultFrame3(Point3(0.0, 0.0, 0.0), initialDir); 
	Ellipse3 ellipse3(defaultFrame3,5.0,3.0 );
	MakeEdge edge= MakeEdge(ellipse3);
	bool bWriteresult = OCCTIO::OCCTTool::Write(edge, OUTPUT_PATH_PREFIX"ellipse3CurveCalculation_case1.brep",true,3);
	SECTION("u = M_PI_2") {
		Vector3 vector3 = CurveCalculation::D1(M_PI_2, ellipse3);
		CHECK(vector3.X() == Approx(-5.0));
		CHECK(vector3.Y() == Approx(0.0).margin(1e-14));
		CHECK(vector3.Z() == Approx(0.0));
	}
}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static void D1(double u, const Parabola3& parabola, Point3& p, Vector3& v1)	 @param[out] v1 The first derivative
	 @param[out] p The point
	 @param[in] parabola The parabola
	 @param[in] u The parameter
	 @brief Compute the point and the first derivative on a 3D parabola at a parameter
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
#include <occtio/OCCTTool.hpp>
#include <geometry/MakeArcOfHyperbola2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeEdge2d.hpp>
using namespace AMCAX;
TEST_CASE("case1: CurveCalculation::D1() ellipse3 [8/20] ", "[math][CurveCalculation][P1][D1]") {
	Direction3 initialDir(0.0, 0.0, 1.0); 
	Frame3 defaultFrame3(Point3(0.0, 0.0, 0.0), initialDir); 
	Ellipse3 ellipse3(defaultFrame3, 5.0, 3.0);
	Point3 p;
	Vector3 v;
	MakeEdge edge = MakeEdge(ellipse3);
	bool bWriteresult = OCCTIO::OCCTTool::Write(edge, OUTPUT_PATH_PREFIX"ellipse3CurveCalculation_case1.brep", true, 3);
	SECTION("u =0") {
		CurveCalculation::D1(0.0, ellipse3,p,v);
		CHECK(p.X() == 5.0);
		CHECK(p.Y() == 0.0);
		CHECK(p.Z() == 0.0);
		CHECK(v.X() == Approx(0.0));
		CHECK(v.Y() == Approx(3.0));
		CHECK(v.Z() == Approx(0.0));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] AMCAX_API static Vector3 D1(double u, const Hyperbola3& hyperbola)	 @return The first derivative vector
	 @param hyperbola The hyperbola
	 @param u The parameter
	 @brief Compute the first derivative on a 3D hyperbola at a parameter
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
#include <occtio/OCCTTool.hpp>
#include <geometry/MakeArcOfHyperbola2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeEdge2d.hpp>
using namespace AMCAX;
TEST_CASE("case1: CurveCalculation::D1() Hyperbola3 [11/20] ", "[math][CurveCalculation][P1][D1]") {
	Direction3 dir3(0.0, 0.0, 1.0);
	Point3 point3(0.0, 0.0, 0.0);
	Frame3 frame3(point3, dir3);
	Hyperbola3 hyperbola3(frame3, 5.0, 3.0); 
	Vector3 vector3 = CurveCalculation::D1(0.0, hyperbola3); 
	CHECK(vector3.X() == 0.0);
	CHECK(vector3.Y() == 3.0);
	CHECK(vector3.Z() == 0.0);
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static void D1(double u, const Hyperbola3& hyperbola, Point3& p, Vector3& v1)	 @param[out] v1 The first derivative
	 @param[out] p The point
	 @param[in] hyperbola The hyperbola
	 @param[in] u The parameter
	 @brief Compute the point and the first derivative on a 3D hyperbola at a parameter
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
#include <occtio/OCCTTool.hpp>
#include <geometry/MakeArcOfHyperbola2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeEdge2d.hpp>
using namespace AMCAX;
TEST_CASE("case1: CurveCalculation::D1() Hyperbola3 [12/20] ", "[math][CurveCalculation][P1][D1]") {
	Direction3 dir3(0.0, 0.0, 1.0);
	Point3 point3(0.0, 0.0, 0.0);
	Frame3 frame3(point3, dir3);
	Hyperbola3 hyperbola3(frame3, 5.0, 3.0); 
	Point3 p;
	Vector3 v;
	CurveCalculation::D1(0.0, hyperbola3,p,v); 
	CHECK(p.X() == 5.0);
	CHECK(p.Y() == 0.0);
	CHECK(p.Z() == 0.0);
	CHECK(v.X() == 0.0);
	CHECK(v.Y() == 3.0);
	CHECK(v.Z() == 0.0);
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] AMCAX_API static Vector2 D1(double u, const Line2& line)	 @return The first derivative vector
	 @param line The line
	 @param u The parameter
	 @brief Compute the first derivative on a 2D line at a parameter
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
#include <occtio/OCCTTool.hpp>
#include <geometry/MakeArcOfHyperbola2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeEdge2d.hpp>
using namespace AMCAX;
TEST_CASE("case1: CurveCalculation::D1() circle2[1/20] ", "[math][CurveCalculation][P1][D1]") {
	Direction2 initialDir(1.0, 0.0); 
	Frame2 defaultFrame2(Point2(1.0, 1.0), initialDir); 
    double radius = 2.0;
    AMCAX::Circle2 circle2(defaultFrame2,radius);
	SECTION("u =0") {
		Vector2 vector2 = CurveCalculation::D1(0.0, circle2);
		CHECK(vector2.X() == Approx(-0.0));
		CHECK(vector2.Y() == 2.0);
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static void D1(double u, const Line2& line, Point2& p, Vector2& v1)	 @param[out] v1 The first derivative
	 @param[out] p The point
	 @param[in] line The line
	 @param[in] u The parameter
	 @brief Compute the point and the first derivative on a 2D line at a parameter
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
#include <occtio/OCCTTool.hpp>
#include <geometry/MakeArcOfHyperbola2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeEdge2d.hpp>
using namespace AMCAX;
TEST_CASE("case1: CurveCalculation::D1() circle2[2/20] ", "[math][CurveCalculation][P1][D1]") {
	Direction2 initialDir(1.0, 0.0); 
	Frame2 defaultFrame2(Point2(1.0, 1.0), initialDir); 
	double radius = 2.0;
	AMCAX::Circle2 circle2(defaultFrame2, radius);
	Point2 p;
	Vector2 v;
	SECTION("u =0") {
		CurveCalculation::D1(0.0, circle2,p,v);
		CHECK(p.X() == 3.0);
		CHECK(p.Y() == 1.0);
		CHECK(v.X() == Approx(0.0));
		CHECK(v.Y() == Approx(2.0));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] AMCAX_API static Vector2 D1(double u, const Circle2& circle)	 @return The first derivative vector
	 @param circle The circle
	 @param u The parameter
	 @brief Compute the first derivative on a 2D circle at a parameter
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
#include <occtio/OCCTTool.hpp>
#include <geometry/MakeArcOfHyperbola2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeEdge2d.hpp>
using namespace AMCAX;
TEST_CASE("case1: CurveCalculation::D1() circle2[1/20] ", "[math][CurveCalculation][P1][D1]") {
	Direction2 initialDir(1.0, 0.0); 
	Frame2 defaultFrame2(Point2(1.0, 1.0), initialDir); 
    double radius = 2.0;
    AMCAX::Circle2 circle2(defaultFrame2,radius);
	SECTION("u =0") {
		Vector2 vector2 = CurveCalculation::D1(0.0, circle2);
		CHECK(vector2.X() == Approx(-0.0));
		CHECK(vector2.Y() == 2.0);
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static void D1(double u, const Circle2& circle, Point2& p, Vector2& v1)	 @param[out] v1 The first derivative
	 @param[out] p The point
	 @param[in] circle The circle
	 @param[in] u The parameter
	 @brief Compute the point and the first derivative on a 2D circle at a parameter
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
#include <occtio/OCCTTool.hpp>
#include <geometry/MakeArcOfHyperbola2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeEdge2d.hpp>
using namespace AMCAX;
TEST_CASE("case1: CurveCalculation::D1() circle2[1/20] ", "[math][CurveCalculation][P1][D1]") {
	Direction2 initialDir(1.0, 0.0); 
	Frame2 defaultFrame2(Point2(1.0, 1.0), initialDir); 
    double radius = 2.0;
    AMCAX::Circle2 circle2(defaultFrame2,radius);
	SECTION("u = M_PI") {
		Vector2 vector2 = CurveCalculation::D1(M_PI, circle2);
		CHECK(vector2.X() == Approx(-0.0).margin(1e-12));
		CHECK(vector2.Y() == -2.0);
	}
}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] AMCAX_API static Vector2 D1(double u, const Ellipse2& ellipse)	 @return The first derivative vector
	 @param ellipse The ellipse
	 @param u The parameter
	 @brief Compute the first derivative on a 2D ellipse at a parameter
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
#include <occtio/OCCTTool.hpp>
#include <geometry/MakeArcOfHyperbola2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeEdge2d.hpp>
using namespace AMCAX;
TEST_CASE("case1: CurveCalculation::D1() circle2[1/20] ", "[math][CurveCalculation][P1][D1]") {
	Direction2 initialDir(1.0, 0.0); 
	Frame2 defaultFrame2(Point2(1.0, 1.0), initialDir); 
    double radius = 2.0;
    AMCAX::Circle2 circle2(defaultFrame2,radius);
	SECTION("u = M_PI") {
		Vector2 vector2 = CurveCalculation::D1(M_PI, circle2);
		CHECK(vector2.X() == Approx(-0.0).margin(1e-12));
		CHECK(vector2.Y() == -2.0);
	}
}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static void D1(double u, const Ellipse2& ellipse, Point2& p, Vector2& v1)	 @param[out] v1 The first derivative
	 @param[out] p The point
	 @param[in] ellipse The ellipse
	 @param[in] u The parameter
	 @brief Compute the point and the first derivative on a 2D ellipse at a parameter
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
#include <occtio/OCCTTool.hpp>
#include <geometry/MakeArcOfHyperbola2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeEdge2d.hpp>
using namespace AMCAX;
TEST_CASE("case1: CurveCalculation::D1() circle2[2/20] ", "[math][CurveCalculation][P1][D1]") {
	Direction2 initialDir(1.0, 0.0); 
	Frame2 defaultFrame2(Point2(1.0, 1.0), initialDir); 
	double radius = 2.0;
	AMCAX::Circle2 circle2(defaultFrame2, radius);
	Point2 p;
	Vector2 v;
	SECTION("u =0") {
		CurveCalculation::D1(0.0, circle2,p,v);
		CHECK(p.X() == 3.0);
		CHECK(p.Y() == 1.0);
		CHECK(v.X() == Approx(0.0));
		CHECK(v.Y() == Approx(2.0));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] AMCAX_API static Vector2 D1(double u, const Parabola2& parabola)	 @return The first derivative vector
	 @param parabola The parabola
	 @param u The parameter
	 @brief Compute the first derivative on a 2D parabola at a parameter
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
#include <occtio/OCCTTool.hpp>
#include <geometry/MakeArcOfHyperbola2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeEdge2d.hpp>
using namespace AMCAX;
TEST_CASE("case1: CurveCalculation::D1() circle2[1/20] ", "[math][CurveCalculation][P1][D1]") {
	Direction2 initialDir(1.0, 0.0); 
	Frame2 defaultFrame2(Point2(1.0, 1.0), initialDir); 
    double radius = 2.0;
    AMCAX::Circle2 circle2(defaultFrame2,radius);
	SECTION("u = M_PI") {
		Vector2 vector2 = CurveCalculation::D1(M_PI, circle2);
		CHECK(vector2.X() == Approx(-0.0).margin(1e-12));
		CHECK(vector2.Y() == -2.0);
	}
}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static void D1(double u, const Parabola2& parabola, Point2& p, Vector2& v1)	 @param[out] v1 The first derivative
	 @param[out] p The point
	 @param[in] parabola The parabola
	 @param[in] u The parameter
	 @brief Compute the point and the first derivative on a 2D parabola at a parameter
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
#include <occtio/OCCTTool.hpp>
#include <geometry/MakeArcOfHyperbola2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeEdge2d.hpp>
using namespace AMCAX;
TEST_CASE("case1: CurveCalculation::D1() ellipse3 [8/20] ", "[math][CurveCalculation][P1][D1]") {
	Direction3 initialDir(0.0, 0.0, 1.0); 
	Frame3 defaultFrame3(Point3(0.0, 0.0, 0.0), initialDir); 
	Ellipse3 ellipse3(defaultFrame3, 5.0, 3.0);
	Point3 p;
	Vector3 v;
	MakeEdge edge = MakeEdge(ellipse3);
	bool bWriteresult = OCCTIO::OCCTTool::Write(edge, OUTPUT_PATH_PREFIX"ellipse3CurveCalculation_case1.brep", true, 3);
	SECTION("u = M_PI_2") {
		CurveCalculation::D1(M_PI_2, ellipse3,p,v);
		CHECK(p.X() == Approx(0.0).margin(1e-12));
		CHECK(p.Y() == 3.0);
		CHECK(p.Z() == 0.0);
		CHECK(v.X() == Approx(-5.0));
		CHECK(v.Y() == Approx(0.0).margin(1e-14));
		CHECK(v.Z() == Approx(0.0));
	}
}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] AMCAX_API static Vector2 D1(double u, const Hyperbola2& hyperbola)	 @return The first derivative vector
	 @param hyperbola The hyperbola
	 @param u The parameter
	 @brief Compute the first derivative on a 2D hyperbola at a parameter
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
#include <occtio/OCCTTool.hpp>
#include <geometry/MakeArcOfHyperbola2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeEdge2d.hpp>
using namespace AMCAX;
TEST_CASE("case1: CurveCalculation::D1() Hyperbola2 [9/20] ", "[math][CurveCalculation][P1][D1]") {
	Axis2 majorAxis;
	double major_radius = 5;
	double minor_radius = 3;
	Hyperbola2 hyperbola2(majorAxis, major_radius, minor_radius); 
	 Vector2 vector2 = CurveCalculation::D1(0.0, hyperbola2); 
	CHECK(vector2.X() == 0.0);
	CHECK(vector2.Y() == 3.0);
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static void D1(double u, const Hyperbola2& hyperbola, Point2& p, Vector2& v1)	 @param[out] v1 The first derivative
	 @param[out] p The point
	 @param[in] hyperbola The hyperbola
	 @param[in] u The parameter
	 @brief Compute the point and the first derivative on a 2D hyperbola at a parameter
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
#include <occtio/OCCTTool.hpp>
#include <geometry/MakeArcOfHyperbola2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeEdge2d.hpp>
using namespace AMCAX;
TEST_CASE("case1: CurveCalculation::D1() Hyperbola2 [10/20] ", "[math][CurveCalculation][P1][D1]") {
	Axis2 majorAxis;
	double major_radius = 5;
	double minor_radius = 3;
	Hyperbola2 hyperbola2(majorAxis, major_radius, minor_radius); 
	Point2 p;
	Vector2 v;
	CurveCalculation::D1(0.0, hyperbola2,p,v); 
	CHECK(p.X() == 5.0);
	CHECK(p.Y() == 0.0);
	CHECK(v.X() == 0.0);
	CHECK(v.Y() == 3.0);
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] AMCAX_API static Vector3 D2(double u, const Line3& line)	 @return The second derivative vector
	 @param line The line
	 @param u The parameter
	 @brief Compute the second derivative on a 3D line at a parameter
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
#include <occtio/OCCTTool.hpp>
#include <geometry/MakeArcOfHyperbola2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeEdge2d.hpp>
using namespace AMCAX;
TEST_CASE("case1: CurveCalculation::D2() circle3[3/20] ", "[math][CurveCalculation][P1][D2]") {
	Direction3 initialDir(0.0, 0.0, 1.0); 
	Frame3 defaultFrame3(Point3(1.0, 0.0, 0.0), initialDir); 
	double radius = 2.0; 
	AMCAX::Circle3 circle3(defaultFrame3, radius);
	SECTION("u =0") {
		Vector3 vector3 = CurveCalculation::D2(0.0, circle3);
		CHECK(vector3.X() == -2.0 );
		CHECK(vector3.Y() == 0.0 );
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static void D2(double u, const Line3& line, Point3& p, Vector3& v1, Vector3& v2)	 @param[out] v2 The second derivative
	 @param[out] v1 The first derivative
	 @param[out] p The point
	 @param[in] line The line
	 @param[in] u The parameter
	 @brief Compute the point and the first two derivatives on a 3D line at a parameter
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
#include <occtio/OCCTTool.hpp>
#include <geometry/MakeArcOfHyperbola2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeEdge2d.hpp>
using namespace AMCAX;
TEST_CASE("case1: CurveCalculation::D2() circle3[4/20] ", "[math][CurveCalculation][P1][D2]") {
	Direction3 initialDir(0.0, 0.0, 1.0);
	Frame3 defaultFrame3(Point3(1.0, 1.0, 0.0), initialDir);
	double radius = 2.0; 
	AMCAX::Circle3 circle3(defaultFrame3, radius);
	Point3 p;
	Vector3 v1, v2;
	SECTION("u =0") {
		CurveCalculation::D2(0.0, circle3, p, v1,v2);
		CHECK(p.X() == 3.0);
		CHECK(p.Y() == 1.0);
		CHECK(p.Z() == 0.0);
		CHECK(v1.X() == Approx(0.0));
		CHECK(v1.Y() == Approx(2.0));
		CHECK(v1.Z() == Approx(0.0));
		CHECK(v2.X() == Approx(-2.0));
		CHECK(v2.Y() == Approx(0.0));
		CHECK(v2.Z() == Approx(0.0));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] AMCAX_API static Vector3 D2(double u, const Circle3& circle)	 @return The second derivative vector
	 @param circle The circle
	 @param u The parameter
	 @brief Compute the second derivative on a 3D circle at a parameter
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
#include <occtio/OCCTTool.hpp>
#include <geometry/MakeArcOfHyperbola2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeEdge2d.hpp>
using namespace AMCAX;
TEST_CASE("case1: CurveCalculation::D2() circle3[3/20] ", "[math][CurveCalculation][P1][D2]") {
	Direction3 initialDir(0.0, 0.0, 1.0); 
	Frame3 defaultFrame3(Point3(1.0, 0.0, 0.0), initialDir); 
	double radius = 2.0; 
	AMCAX::Circle3 circle3(defaultFrame3, radius);
	SECTION("u =0") {
		Vector3 vector3 = CurveCalculation::D2(0.0, circle3);
		CHECK(vector3.X() == -2.0 );
		CHECK(vector3.Y() == 0.0 );
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static void D2(double u, const Circle3& circle, Point3& p, Vector3& v1, Vector3& v2)	 @param[out] v2 The second derivative
	 @param[out] v1 The first derivative
	 @param[out] p The point
	 @param[in] circle The circle
	 @param[in] u The parameter
	 @brief Compute the point and the first two derivatives on a 3D circle at a parameter
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
#include <occtio/OCCTTool.hpp>
#include <geometry/MakeArcOfHyperbola2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeEdge2d.hpp>
using namespace AMCAX;
TEST_CASE("case1: CurveCalculation::D2() circle3[4/20] ", "[math][CurveCalculation][P1][D2]") {
	Direction3 initialDir(0.0, 0.0, 1.0);
	Frame3 defaultFrame3(Point3(1.0, 1.0, 0.0), initialDir);
	double radius = 2.0; 
	AMCAX::Circle3 circle3(defaultFrame3, radius);
	Point3 p;
	Vector3 v1, v2;
	SECTION("u =0") {
		CurveCalculation::D2(0.0, circle3, p, v1,v2);
		CHECK(p.X() == 3.0);
		CHECK(p.Y() == 1.0);
		CHECK(p.Z() == 0.0);
		CHECK(v1.X() == Approx(0.0));
		CHECK(v1.Y() == Approx(2.0));
		CHECK(v1.Z() == Approx(0.0));
		CHECK(v2.X() == Approx(-2.0));
		CHECK(v2.Y() == Approx(0.0));
		CHECK(v2.Z() == Approx(0.0));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] AMCAX_API static Vector3 D2(double u, const Ellipse3& ellipse)	 @return The second derivative vector
	 @param ellipse The ellipse
	 @param u The parameter
	 @brief Compute the second derivative on a 3D ellipse at a parameter
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
#include <occtio/OCCTTool.hpp>
#include <geometry/MakeArcOfHyperbola2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeEdge2d.hpp>
using namespace AMCAX;
TEST_CASE("case1: CurveCalculation::D2() ellipse3[7/20] ", "[math][CurveCalculation][P1][D2]") {
	Direction3 initialDir(0.0, 0.0, 1.0); 
	Frame3 defaultFrame3(Point3(0.0, 0.0, 0.0), initialDir); 
	Ellipse3 ellipse3(defaultFrame3, 5.0, 3.0);
	SECTION("u =0") {
		Vector3 vector3 = CurveCalculation::D2(0.0, ellipse3);
		CHECK(vector3.X() == Approx(-5.0));
		CHECK(vector3.Y() == Approx(0.0));
		CHECK(vector3.Z() == Approx(0.0));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static void D2(double u, const Ellipse3& ellipse, Point3& p, Vector3& v1, Vector3& v2)	 @param[out] v2 The second derivative
	 @param[out] v1 The first derivative
	 @param[out] p The point
	 @param[in] ellipse The ellipse
	 @param[in] u The parameter
	 @brief Compute the point and the first two derivatives on a 3D ellipse at a parameter
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
#include <occtio/OCCTTool.hpp>
#include <geometry/MakeArcOfHyperbola2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeEdge2d.hpp>
using namespace AMCAX;
TEST_CASE("case1: CurveCalculation::D2() circle3[4/20] ", "[math][CurveCalculation][P1][D2]") {
	Direction3 initialDir(0.0, 0.0, 1.0);
	Frame3 defaultFrame3(Point3(1.0, 1.0, 0.0), initialDir);
	double radius = 2.0; 
	AMCAX::Circle3 circle3(defaultFrame3, radius);
	Point3 p;
	Vector3 v1, v2;
	SECTION("u =0") {
		CurveCalculation::D2(0.0, circle3, p, v1,v2);
		CHECK(p.X() == 3.0);
		CHECK(p.Y() == 1.0);
		CHECK(p.Z() == 0.0);
		CHECK(v1.X() == Approx(0.0));
		CHECK(v1.Y() == Approx(2.0));
		CHECK(v1.Z() == Approx(0.0));
		CHECK(v2.X() == Approx(-2.0));
		CHECK(v2.Y() == Approx(0.0));
		CHECK(v2.Z() == Approx(0.0));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] AMCAX_API static Vector3 D2(double u, const Parabola3& parabola)	 @return The second derivative vector
	 @param parabola The parabola
	 @param u The parameter
	 @brief Compute the second derivative on a 3D parabola at a parameter
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
#include <occtio/OCCTTool.hpp>
#include <geometry/MakeArcOfHyperbola2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeEdge2d.hpp>
using namespace AMCAX;
TEST_CASE("case1: CurveCalculation::D2() parabola2 [19/20] ", "[math][CurveCalculation][P1][D2]") {
	Point3 point3(0.0, 0.0, 0.0);
	Direction3 dir3(0.0, 0.0, 1.0);
	Frame3 fram3(point3, dir3);
	double focal = 2.0;
	Parabola3 parabola3(fram3, focal);
	SECTION("u =0") {
		Vector3 vector3 = CurveCalculation::D2(0.0, parabola3);
		CHECK(vector3.X() == 0.25);
		CHECK(vector3.Y() == 0.0);
		CHECK(vector3.Z() == 0.0);
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static void D2(double u, const Parabola3& parabola, Point3& p, Vector3& v1, Vector3& v2)	 @param[out] v2 The second derivative
	 @param[out] v1 The first derivative
	 @param[out] p The point
	 @param[in] parabola The parabola
	 @param[in] u The parameter
	 @brief Compute the point and the first two derivatives on a 3D parabola at a parameter
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
#include <occtio/OCCTTool.hpp>
#include <geometry/MakeArcOfHyperbola2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeEdge2d.hpp>
using namespace AMCAX;
TEST_CASE("case1: CurveCalculation::D2() parabola2 [19/20] ", "[math][CurveCalculation][P1][D2]") {
	Point3 point3(0.0, 0.0, 0.0);
	Direction3 dir3(0.0, 0.0, 1.0);
	Frame3 fram3(point3, dir3);
	double focal = 2.0;
	Parabola3 parabola3(fram3, focal);
	SECTION("u =0") {
		Vector3 vector3 = CurveCalculation::D2(0.0, parabola3);
		CHECK(vector3.X() == 0.25);
		CHECK(vector3.Y() == 0.0);
		CHECK(vector3.Z() == 0.0);
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] AMCAX_API static Vector3 D2(double u, const Hyperbola3& hyperbola)	 @return The second derivative vector
	 @param hyperbola The hyperbola
	 @param u The parameter
	 @brief Compute the second derivative on a 3D hyperbola at a parameter
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
#include <occtio/OCCTTool.hpp>
#include <geometry/MakeArcOfHyperbola2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeEdge2d.hpp>
using namespace AMCAX;
TEST_CASE("case1: CurveCalculation::D2() hyperbola3[11/20] ", "[math][CurveCalculation][P1][D2]") {
	Direction3 dir3(0.0, 0.0, 1.0);
	Point3 point3(0.0, 0.0, 0.0);
	Frame3 frame3(point3, dir3);
	Hyperbola3 hyperbola3(frame3, 5.0, 3.0); 
	Vector3 vector3 = CurveCalculation::D2(0.0, hyperbola3); 
	CHECK(vector3.X() == 5.0);
	CHECK(vector3.Y() == 0.0);
	CHECK(vector3.Z() == 0.0);
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static void D2(double u, const Hyperbola3& hyperbola, Point3& p, Vector3& v1, Vector3& v2)	 @param[out] v2 The second derivative
	 @param[out] v1 The first derivative
	 @param[out] p The point
	 @param[in] hyperbola The hyperbola
	 @param[in] u The parameter
	 @brief Compute the point and the first two derivatives on a 3D hyperbola at a parameter
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
#include <occtio/OCCTTool.hpp>
#include <geometry/MakeArcOfHyperbola2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeEdge2d.hpp>
using namespace AMCAX;
TEST_CASE("case1: CurveCalculation::D2() hyperbola3[11/20] ", "[math][CurveCalculation][P1][D2]") {
	Direction3 dir3(0.0, 0.0, 1.0);
	Point3 point3(0.0, 0.0, 0.0);
	Frame3 frame3(point3, dir3);
	Hyperbola3 hyperbola3(frame3, 5.0, 3.0); 
	Vector3 vector3 = CurveCalculation::D2(0.0, hyperbola3); 
	CHECK(vector3.X() == 5.0);
	CHECK(vector3.Y() == 0.0);
	CHECK(vector3.Z() == 0.0);
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] AMCAX_API static Vector2 D2(double u, const Line2& line)	 @return The second derivative vector
	 @param line The line
	 @param u The parameter
	 @brief Compute the second derivative on a 2D line at a parameter
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
#include <occtio/OCCTTool.hpp>
#include <geometry/MakeArcOfHyperbola2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeEdge2d.hpp>
using namespace AMCAX;
TEST_CASE("case1: CurveCalculation::D2() circle2[1/20] ", "[math][CurveCalculation][P1][D2]") {
	Direction2 initialDir(1.0, 0.0); 
	Frame2 defaultFrame2(Point2(1.0, 1.0), initialDir); 
	double radius = 2.0;
	AMCAX::Circle2 circle2(defaultFrame2, radius);
	SECTION("u =0") {
		Vector2 vector2 = CurveCalculation::D2(0.0, circle2);
		CHECK(vector2.X() == -2.0);
		CHECK(vector2.Y() == 0.0);
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static void D2(double u, const Line2& line, Point2& p, Vector2& v1, Vector2& v2)	 @param[out] v2 The second derivative
	 @param[out] v1 The first derivative
	 @param[out] p The point
	 @param[in] line The line
	 @param[in] u The parameter
	 @brief Compute the point and the first two derivatives on a 2D line at a parameter
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
#include <occtio/OCCTTool.hpp>
#include <geometry/MakeArcOfHyperbola2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeEdge2d.hpp>
using namespace AMCAX;
TEST_CASE("case1: CurveCalculation::D2() circle2[2/20] ", "[math][CurveCalculation][P1][D2]") {
	Direction2 initialDir(1.0, 0.0); 
	Frame2 defaultFrame2(Point2(1.0, 1.0), initialDir); 
	double radius = 2.0;
	AMCAX::Circle2 circle2(defaultFrame2, radius);
	Point2 p;
	Vector2 v1,v2;
	SECTION("u =0") {
		CurveCalculation::D2(0.0, circle2, p, v1,v2);
		CHECK(p.X() == 3.0);
		CHECK(p.Y() == 1.0);
		CHECK(v1.X() == 0.0);
		CHECK(v1.Y() == 2.0);
		CHECK(v2.X() == -2.0);
		CHECK(v2.Y() == 0.0);
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] AMCAX_API static Vector2 D2(double u, const Circle2& circle)	 @return The second derivative vector
	 @param circle The circle
	 @param u The parameter
	 @brief Compute the second derivative on a 2D circle at a parameter
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
#include <occtio/OCCTTool.hpp>
#include <geometry/MakeArcOfHyperbola2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeEdge2d.hpp>
using namespace AMCAX;
TEST_CASE("case1: CurveCalculation::D2() circle2[1/20] ", "[math][CurveCalculation][P1][D2]") {
	Direction2 initialDir(1.0, 0.0); 
	Frame2 defaultFrame2(Point2(1.0, 1.0), initialDir); 
	double radius = 2.0;
	AMCAX::Circle2 circle2(defaultFrame2, radius);
	SECTION("u =0") {
		Vector2 vector2 = CurveCalculation::D2(0.0, circle2);
		CHECK(vector2.X() == -2.0);
		CHECK(vector2.Y() == 0.0);
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static void D2(double u, const Circle2& circle, Point2& p, Vector2& v1, Vector2& v2)	 @param[out] v2 The second derivative
	 @param[out] v1 The first derivative
	 @param[out] p The point
	 @param[in] circle The circle
	 @param[in] u The parameter
	 @brief Compute the point and the first two derivatives on a 2D circle at a parameter
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
#include <occtio/OCCTTool.hpp>
#include <geometry/MakeArcOfHyperbola2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeEdge2d.hpp>
using namespace AMCAX;
TEST_CASE("case1: CurveCalculation::D2() circle2[1/20] ", "[math][CurveCalculation][P1][D2]") {
	Direction2 initialDir(1.0, 0.0); 
	Frame2 defaultFrame2(Point2(1.0, 1.0), initialDir); 
	double radius = 2.0;
	AMCAX::Circle2 circle2(defaultFrame2, radius);
	SECTION("u =0") {
		Vector2 vector2 = CurveCalculation::D2(0.0, circle2);
		CHECK(vector2.X() == -2.0);
		CHECK(vector2.Y() == 0.0);
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] AMCAX_API static Vector2 D2(double u, const Ellipse2& ellipse)	 @return The second derivative vector
	 @param ellipse The ellipse
	 @param u The parameter
	 @brief Compute the second derivative on a 2D ellipse at a parameter
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
#include <occtio/OCCTTool.hpp>
#include <geometry/MakeArcOfHyperbola2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeEdge2d.hpp>
using namespace AMCAX;
TEST_CASE("case1: CurveCalculation::D2() circle2[1/20] ", "[math][CurveCalculation][P1][D2]") {
	Direction2 initialDir(1.0, 0.0); 
	Frame2 defaultFrame2(Point2(1.0, 1.0), initialDir); 
	double radius = 2.0;
	AMCAX::Circle2 circle2(defaultFrame2, radius);
	SECTION("u =0") {
		Vector2 vector2 = CurveCalculation::D2(0.0, circle2);
		CHECK(vector2.X() == -2.0);
		CHECK(vector2.Y() == 0.0);
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static void D2(double u, const Ellipse2& ellipse, Point2& p, Vector2& v1, Vector2& v2)	 @param[out] v2 The second derivative
	 @param[out] v1 The first derivative
	 @param[out] p The point
	 @param[in] ellipse The ellipse
	 @param[in] u The parameter
	 @brief Compute the point and the first two derivatives on a 2D ellipse at a parameter
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
#include <occtio/OCCTTool.hpp>
#include <geometry/MakeArcOfHyperbola2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeEdge2d.hpp>
using namespace AMCAX;
TEST_CASE("case1: CurveCalculation::D2() circle2[2/20] ", "[math][CurveCalculation][P1][D2]") {
	Direction2 initialDir(1.0, 0.0); 
	Frame2 defaultFrame2(Point2(1.0, 1.0), initialDir); 
	double radius = 2.0;
	AMCAX::Circle2 circle2(defaultFrame2, radius);
	Point2 p;
	Vector2 v1,v2;
	SECTION("u =0") {
		CurveCalculation::D2(0.0, circle2, p, v1,v2);
		CHECK(p.X() == 3.0);
		CHECK(p.Y() == 1.0);
		CHECK(v1.X() == 0.0);
		CHECK(v1.Y() == 2.0);
		CHECK(v2.X() == -2.0);
		CHECK(v2.Y() == 0.0);
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] AMCAX_API static Vector2 D2(double u, const Parabola2& parabola)	 @return The second derivative vector
	 @param parabola The parabola
	 @param u The parameter
	 @brief Compute the second derivative on a 2D parabola at a parameter
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
#include <occtio/OCCTTool.hpp>
#include <geometry/MakeArcOfHyperbola2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeEdge2d.hpp>
using namespace AMCAX;
TEST_CASE("case1: CurveCalculation::D2() circle2[1/20] ", "[math][CurveCalculation][P1][D2]") {
	Direction2 initialDir(1.0, 0.0); 
	Frame2 defaultFrame2(Point2(1.0, 1.0), initialDir); 
	double radius = 2.0;
	AMCAX::Circle2 circle2(defaultFrame2, radius);
	SECTION("u =0") {
		Vector2 vector2 = CurveCalculation::D2(0.0, circle2);
		CHECK(vector2.X() == -2.0);
		CHECK(vector2.Y() == 0.0);
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static void D2(double u, const Parabola2& parabola, Point2& p, Vector2& v1, Vector2& v2)	 @param[out] v2 The second derivative
	 @param[out] v1 The first derivative
	 @param[out] p The point
	 @param[in] parabola The parabola
	 @param[in] u The parameter
	 @brief Compute the point and the first two derivatives on a 2D parabola at a parameter
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
#include <occtio/OCCTTool.hpp>
#include <geometry/MakeArcOfHyperbola2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeEdge2d.hpp>
using namespace AMCAX;
TEST_CASE("case1: CurveCalculation::D2() parabola2 [18/20] ", "[math][CurveCalculation][P1][D2][kk]") {
	AMCAX::Point2 P(0.0, 0.0);
	AMCAX::Direction2 D(1.0, 0.0); 
	AMCAX::Axis2  axis2(P, D);
	double focal = 2.0;
	AMCAX::Parabola2 parabola2(axis2, focal);
	Point2 p;
	Vector2 v1,v2;
	SECTION("u =0") {
		CurveCalculation::D2(0.0, parabola2, p, v1,v2);
		CHECK(p.X() == 0.0);
		CHECK(p.Y() == 0.0);
		CHECK(v1.X() == 0.0);
		CHECK(v1.Y() == 1.0);
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] AMCAX_API static Vector2 D2(double u, const Hyperbola2& hyperbola)	 @return The second derivative vector
	 @param hyperbola The hyperbola
	 @param u The parameter
	 @brief Compute the second derivative on a 2D hyperbola at a parameter
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
#include <occtio/OCCTTool.hpp>
#include <geometry/MakeArcOfHyperbola2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeEdge2d.hpp>
using namespace AMCAX;
TEST_CASE("case1: CurveCalculation::D2() hyperbola2[9/20] ", "[math][CurveCalculation][P1][D2]") {
	Axis2 majorAxis;
	double major_radius = 5;
	double minor_radius = 3;
	Hyperbola2 hyperbola2(majorAxis, major_radius, minor_radius); 
	Vector2 vector2 = CurveCalculation::D2(0.0, hyperbola2); 
	CHECK(vector2.X() == 5.0);
	CHECK(vector2.Y() == 0.0);
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static void D2(double u, const Hyperbola2& hyperbola, Point2& p, Vector2& v1, Vector2& v2)	 @param[out] v2 The second derivative
	 @param[out] v1 The first derivative
	 @param[out] p The point
	 @param[in] hyperbola The hyperbola
	 @param[in] u The parameter
	 @brief Compute the point and the first two derivatives on a 2D hyperbola at a parameter
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
#include <occtio/OCCTTool.hpp>
#include <geometry/MakeArcOfHyperbola2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeEdge2d.hpp>
using namespace AMCAX;
TEST_CASE("case1: CurveCalculation::D2() hyperbola2[10/20] ", "[math][CurveCalculation][P1][D2]") {
	Axis2 majorAxis;
	double major_radius = 5;
	double minor_radius = 3;
	Hyperbola2 hyperbola2(majorAxis, major_radius, minor_radius); 
	Point2 p;
	Vector2 v1,v2;
	CurveCalculation::D2(0.0, hyperbola2, p, v1,v2); 
	CHECK(p.X() == 5.0);
	CHECK(p.Y() == 0.0);
	CHECK(v1.X() == 0.0);
	CHECK(v1.Y() == 3.0);
	CHECK(v2.X() == 5.0);
	CHECK(v2.Y() == 0.0);
}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] AMCAX_API static Vector3 D3(double u, const Line3& line)	 @return The third derivative vector
	 @param line The line
	 @param u The parameter
	 @brief Compute the third derivative on a 3D line at a parameter
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
#include <occtio/OCCTTool.hpp>
#include <geometry/MakeArcOfHyperbola2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeEdge2d.hpp>
using namespace AMCAX;
TEST_CASE("case1: CurveCalculation::D3() circle3[3/20] ", "[math][CurveCalculation][P1][D3]") {
	Direction3 initialDir(0.0, 0.0, 1.0); 
	Frame3 defaultFrame3(Point3(1.0, 0.0, 0.0), initialDir); 
	double radius = 2.0; 
	AMCAX::Circle3 circle3(defaultFrame3, radius);
	SECTION("u =0") {
		Vector3 vector3 = CurveCalculation::D3(0.0, circle3);
		CHECK(vector3.X() == 0.0);
		CHECK(vector3.Y() == -2.0);
		CHECK(vector3.Z() == 0.0);
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static void D3(double u, const Line3& line, Point3& p, Vector3& v1, Vector3& v2, Vector3& v3)	 @param[out] v3 The third derivative
	 @param[out] v2 The second derivative
	 @param[out] v1 The first derivative
	 @param[out] p The point
	 @param[in] line The line
	 @param[in] u The parameter
	 @brief Compute the point and the first three derivatives on a 3D line at a parameter
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
#include <occtio/OCCTTool.hpp>
#include <geometry/MakeArcOfHyperbola2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeEdge2d.hpp>
using namespace AMCAX;
TEST_CASE("case1: CurveCalculation::D3() circle3[4/20] ", "[math][CurveCalculation][P1][D3]") {
	Direction3 initialDir(0.0, 0.0, 1.0);
	Frame3 defaultFrame3(Point3(1.0, 1.0, 0.0), initialDir);
	double radius = 2.0; 
	AMCAX::Circle3 circle3(defaultFrame3, radius);
	Point3 p;
	Vector3 v1, v2,v3;
	SECTION("u =0") {
		CurveCalculation::D3(0.0, circle3, p, v1, v2,v3);
		CHECK(p.X() == 3.0);
		CHECK(p.Y() == 1.0);
		CHECK(p.Z() == 0.0);
		CHECK(v1.X() == Approx(0.0));
		CHECK(v1.Y() == Approx(2.0));
		CHECK(v1.Z() == Approx(0.0));
		CHECK(v2.X() == Approx(-2.0));
		CHECK(v2.Y() == Approx(0.0));
		CHECK(v2.Z() == Approx(0.0));
		CHECK(v3.X() == Approx(0.0));
		CHECK(v3.Y() == Approx(-2.0));
		CHECK(v3.Z() == Approx(0.0));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] AMCAX_API static Vector3 D3(double u, const Circle3& circle)	 @return The third derivative vector
	 @param circle The circle
	 @param u The parameter
	 @brief Compute the third derivative on a 3D circle at a parameter
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
#include <occtio/OCCTTool.hpp>
#include <geometry/MakeArcOfHyperbola2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeEdge2d.hpp>
using namespace AMCAX;
TEST_CASE("case1: CurveCalculation::D3() circle3[3/20] ", "[math][CurveCalculation][P1][D3]") {
	Direction3 initialDir(0.0, 0.0, 1.0); 
	Frame3 defaultFrame3(Point3(1.0, 0.0, 0.0), initialDir); 
	double radius = 2.0; 
	AMCAX::Circle3 circle3(defaultFrame3, radius);
	SECTION("u =0") {
		Vector3 vector3 = CurveCalculation::D3(0.0, circle3);
		CHECK(vector3.X() == 0.0);
		CHECK(vector3.Y() == -2.0);
		CHECK(vector3.Z() == 0.0);
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static void D3(double u, const Circle3& circle, Point3& p, Vector3& v1, Vector3& v2, Vector3& v3)	 @param[out] v3 The third derivative
	 @param[out] v2 The second derivative
	 @param[out] v1 The first derivative
	 @param[out] p The point
	 @param[in] circle The circle
	 @param[in] u The parameter
	 @brief Compute the point and the first three derivatives on a 3D circle at a parameter
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
#include <occtio/OCCTTool.hpp>
#include <geometry/MakeArcOfHyperbola2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeEdge2d.hpp>
using namespace AMCAX;
TEST_CASE("case1: CurveCalculation::D3() circle3[4/20] ", "[math][CurveCalculation][P1][D3]") {
	Direction3 initialDir(0.0, 0.0, 1.0);
	Frame3 defaultFrame3(Point3(1.0, 1.0, 0.0), initialDir);
	double radius = 2.0; 
	AMCAX::Circle3 circle3(defaultFrame3, radius);
	Point3 p;
	Vector3 v1, v2,v3;
	SECTION("u =0") {
		CurveCalculation::D3(0.0, circle3, p, v1, v2,v3);
		CHECK(p.X() == 3.0);
		CHECK(p.Y() == 1.0);
		CHECK(p.Z() == 0.0);
		CHECK(v1.X() == Approx(0.0));
		CHECK(v1.Y() == Approx(2.0));
		CHECK(v1.Z() == Approx(0.0));
		CHECK(v2.X() == Approx(-2.0));
		CHECK(v2.Y() == Approx(0.0));
		CHECK(v2.Z() == Approx(0.0));
		CHECK(v3.X() == Approx(0.0));
		CHECK(v3.Y() == Approx(-2.0));
		CHECK(v3.Z() == Approx(0.0));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static void D3(double u, const Ellipse3& ellipse, Point3& p, Vector3& v1, Vector3& v2, Vector3& v3)	 @param[out] v3 The third derivative
	 @param[out] v2 The second derivative
	 @param[out] v1 The first derivative
	 @param[out] p The point
	 @param[in] ellipse The ellipse
	 @param[in] u The parameter
	 @brief Compute the point and the first three derivatives on a 3D ellipse at a parameter
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
#include <occtio/OCCTTool.hpp>
#include <geometry/MakeArcOfHyperbola2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeEdge2d.hpp>
using namespace AMCAX;
TEST_CASE("case1: CurveCalculation::D3() circle3[4/20] ", "[math][CurveCalculation][P1][D3]") {
	Direction3 initialDir(0.0, 0.0, 1.0);
	Frame3 defaultFrame3(Point3(1.0, 1.0, 0.0), initialDir);
	double radius = 2.0; 
	AMCAX::Circle3 circle3(defaultFrame3, radius);
	Point3 p;
	Vector3 v1, v2,v3;
	SECTION("u =0") {
		CurveCalculation::D3(0.0, circle3, p, v1, v2,v3);
		CHECK(p.X() == 3.0);
		CHECK(p.Y() == 1.0);
		CHECK(p.Z() == 0.0);
		CHECK(v1.X() == Approx(0.0));
		CHECK(v1.Y() == Approx(2.0));
		CHECK(v1.Z() == Approx(0.0));
		CHECK(v2.X() == Approx(-2.0));
		CHECK(v2.Y() == Approx(0.0));
		CHECK(v2.Z() == Approx(0.0));
		CHECK(v3.X() == Approx(0.0));
		CHECK(v3.Y() == Approx(-2.0));
		CHECK(v3.Z() == Approx(0.0));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] AMCAX_API static Vector2 D3(double u, const Line2& line)	 @return The third derivative vector
	 @param line The line
	 @param u The parameter
	 @brief Compute the third derivative on a 2D line at a parameter
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
#include <occtio/OCCTTool.hpp>
#include <geometry/MakeArcOfHyperbola2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeEdge2d.hpp>
using namespace AMCAX;
TEST_CASE("case1: CurveCalculation::D3() circle2[1/20] ", "[math][CurveCalculation][P1][D2]") {
	Direction2 initialDir(1.0, 0.0); 
	Frame2 defaultFrame2(Point2(0.0, 0.0), initialDir); 
	double radius = 2.0;
	AMCAX::Circle2 circle2(defaultFrame2, radius);
	SECTION("u =0") {
		Vector2 vector2 = CurveCalculation::D3(0.0, circle2);
		CHECK(vector2.X() == 0.0);
		CHECK(vector2.Y() == -2.0);
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static void D3(double u, const Line2& line, Point2& p, Vector2& v1, Vector2& v2, Vector2& v3)	 @param[out] v3 The third derivative
	 @param[out] v2 The second derivative
	 @param[out] v1 The first derivative
	 @param[out] p The point
	 @param[in] line The line
	 @param[in] u The parameter
	 @brief Compute the point and the first three derivatives on a 2D line at a parameter
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
#include <occtio/OCCTTool.hpp>
#include <geometry/MakeArcOfHyperbola2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeEdge2d.hpp>
using namespace AMCAX;
TEST_CASE("case1: CurveCalculation::D3() circle2[2/20] ", "[math][CurveCalculation][P1][D2]") {
	Direction2 initialDir(1.0, 0.0); 
	Frame2 defaultFrame2(Point2(1.0, 1.0), initialDir); 
	double radius = 2.0;
	AMCAX::Circle2 circle2(defaultFrame2, radius);
	Point2 p;
	Vector2 v1, v2,v3;
	SECTION("u =0") {
		CurveCalculation::D3(0.0, circle2, p, v1, v2,v3);
		CHECK(p.X() == 3.0);
		CHECK(p.Y() == 1.0);
		CHECK(v1.X() == 0.0);
		CHECK(v1.Y() == 2.0);
		CHECK(v2.X() == -2.0);
		CHECK(v2.Y() == 0.0);
		CHECK(v3.X() == 0.0);
		CHECK(v3.Y() == -2.0);
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] AMCAX_API static Vector2 D3(double u, const Circle2& circle)	 @return The third derivative vector
	 @param circle The circle
	 @param u The parameter
	 @brief Compute the third derivative on a 2D circle at a parameter
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
#include <occtio/OCCTTool.hpp>
#include <geometry/MakeArcOfHyperbola2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeEdge2d.hpp>
using namespace AMCAX;
TEST_CASE("case1: CurveCalculation::D3() circle2[1/20] ", "[math][CurveCalculation][P1][D2]") {
	Direction2 initialDir(1.0, 0.0); 
	Frame2 defaultFrame2(Point2(0.0, 0.0), initialDir); 
	double radius = 2.0;
	AMCAX::Circle2 circle2(defaultFrame2, radius);
	SECTION("u =0") {
		Vector2 vector2 = CurveCalculation::D3(0.0, circle2);
		CHECK(vector2.X() == 0.0);
		CHECK(vector2.Y() == -2.0);
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static void D3(double u, const Circle2& circle, Point2& p, Vector2& v1, Vector2& v2, Vector2& v3)	 @param[out] v3 The third derivative
	 @param[out] v2 The second derivative
	 @param[out] v1 The first derivative
	 @param[out] p The point
	 @param[in] circle The circle
	 @param[in] u The parameter
	 @brief Compute the point and the first three derivatives on a 2D circle at a parameter
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
#include <occtio/OCCTTool.hpp>
#include <geometry/MakeArcOfHyperbola2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeEdge2d.hpp>
using namespace AMCAX;
TEST_CASE("case1: CurveCalculation::D3() circle2[2/20] ", "[math][CurveCalculation][P1][D2]") {
	Direction2 initialDir(1.0, 0.0); 
	Frame2 defaultFrame2(Point2(1.0, 1.0), initialDir); 
	double radius = 2.0;
	AMCAX::Circle2 circle2(defaultFrame2, radius);
	Point2 p;
	Vector2 v1, v2,v3;
	SECTION("u =0") {
		CurveCalculation::D3(0.0, circle2, p, v1, v2,v3);
		CHECK(p.X() == 3.0);
		CHECK(p.Y() == 1.0);
		CHECK(v1.X() == 0.0);
		CHECK(v1.Y() == 2.0);
		CHECK(v2.X() == -2.0);
		CHECK(v2.Y() == 0.0);
		CHECK(v3.X() == 0.0);
		CHECK(v3.Y() == -2.0);
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static void D3(double u, const Ellipse2& ellipse, Point2& p, Vector2& v1, Vector2& v2, Vector2& v3)	 @param[out] v3 The third derivative
	 @param[out] v2 The second derivative
	 @param[out] v1 The first derivative
	 @param[out] p The point
	 @param[in] ellipse The ellipse
	 @param[in] u The parameter
	 @brief Compute the point and the first three derivatives on a 2D ellipse at a parameter
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
#include <occtio/OCCTTool.hpp>
#include <geometry/MakeArcOfHyperbola2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeEdge2d.hpp>
using namespace AMCAX;
TEST_CASE("case1: CurveCalculation::D3() circle2[2/20] ", "[math][CurveCalculation][P1][D2]") {
	Direction2 initialDir(1.0, 0.0); 
	Frame2 defaultFrame2(Point2(1.0, 1.0), initialDir); 
	double radius = 2.0;
	AMCAX::Circle2 circle2(defaultFrame2, radius);
	Point2 p;
	Vector2 v1, v2,v3;
	SECTION("u = M_PI") {
		CurveCalculation::D3(M_PI, circle2, p, v1, v2,v3);
		CHECK(p.X() == -1.0);
		CHECK(p.Y() == Approx(1.0));
		CHECK(v1.X() == Approx(0.0).margin(1e-12));
		CHECK(v1.Y() == -2.0);
		CHECK(v2.X() == 2.0);
		CHECK(v2.Y() == Approx(0.0).margin(1e-11));
		CHECK(v3.X() == Approx(0.0).margin(1e-12));
		CHECK(v3.Y() == 2.0);
	}
}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API static void D3(double u, const Parabola2& parabola, Point2& p, Vector2& v1, Vector2& v2, Vector2& v3)	 @param[out] v3 The third derivative
	 @param[out] v2 The second derivative
	 @param[out] v1 The first derivative
	 @param[out] p The point
	 @param[in] parabola The parabola
	 @param[in] u The parameter
	 @brief Compute the point and the first three derivatives on a 2D parabola at a parameter
,
 "output":#include<catch.hpp>
#include<testHelper.h>
#include <common/PointT.hpp>
#include <math/CurveCalculation.hpp>
#include <occtio/OCCTTool.hpp>
#include <geometry/MakeArcOfHyperbola2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <modeling/MakeVertex.hpp>
#include <modeling/MakeEdge2d.hpp>
using namespace AMCAX;
TEST_CASE("case1: CurveCalculation::D3() circle2[2/20] ", "[math][CurveCalculation][P1][D2]") {
	Direction2 initialDir(1.0, 0.0); 
	Frame2 defaultFrame2(Point2(1.0, 1.0), initialDir); 
	double radius = 2.0;
	AMCAX::Circle2 circle2(defaultFrame2, radius);
	Point2 p;
	Vector2 v1, v2,v3;
	SECTION("u = M_PI") {
		CurveCalculation::D3(M_PI, circle2, p, v1, v2,v3);
		CHECK(p.X() == -1.0);
		CHECK(p.Y() == Approx(1.0));
		CHECK(v1.X() == Approx(0.0).margin(1e-12));
		CHECK(v1.Y() == -2.0);
		CHECK(v2.X() == 2.0);
		CHECK(v2.Y() == Approx(0.0).margin(1e-11));
		CHECK(v3.X() == Approx(0.0).margin(1e-12));
		CHECK(v3.Y() == 2.0);
	}
}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":Cylinder()	 @brief Default constructor
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <common/FrameT.hpp>
#include <modeling/MakeFace.hpp>
#include <common/AxisT.hpp>
#include <math/Cylinder.hpp>
#include <common/VectorT.hpp>
#include <occtio/OCCTTool.hpp>
#include <modeling/MakeCylinder.hpp>
#include <iostream>
using namespace AMCAX;
using namespace std;
TEST_CASE("case1:this is a case for Test Cylinder", "[math][Cylinder][P1]")
{
	Frame3 frame;
	double radius = 5.0;
	Cylinder cylinder(frame, radius);
	SECTION("Cylinder")
	{
		CHECK(cylinder.Radius() == Approx(radius));
		CHECK(cylinder.Location().X() == Approx(0.0));
		CHECK(cylinder.Location().Y() == Approx(0.0));
		CHECK(cylinder.Location().Z() == Approx(0.0));
		Cylinder cylinder1;
		CHECK(cylinder1.Location().X() == Approx(0.0));
		CHECK(cylinder1.Location().Y() == Approx(0.0));
		CHECK(cylinder1.Location().Z() == Approx(0.0));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API Cylinder(const Frame3& frame, double r)	 @param r The radius
	 @param frame The local frame
	 @brief Construct from a local frame and a radius
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <common/FrameT.hpp>
#include <modeling/MakeFace.hpp>
#include <common/AxisT.hpp>
#include <math/Cylinder.hpp>
#include <common/VectorT.hpp>
#include <occtio/OCCTTool.hpp>
#include <modeling/MakeCylinder.hpp>
#include <iostream>
using namespace AMCAX;
using namespace std;
TEST_CASE("bug1:Cylinder ", "[math][Cylinder][fixbug]")
{
	Point3 point_cy(6.0, 0.0, 0.0);
	Direction3 dir_cy(0.0, 0.0, 1.0);
	Frame3 frame_cy(point_cy, dir_cy);
	double radius_cy = 5.0;
	Cylinder cylinder(frame_cy, radius_cy);
	double r = 0.0;
	SECTION("SetRadius1")
	{
		cylinder.SetRadius(r);
		CHECK(cylinder.Radius() == Approx(0.0));
	}
	r = -1.0;
	string str1;
	string str2 = "[_DomainError]";}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":AMCAX_API Cylinder& Scale(const Point3& point, double scale)	 @return The reference to self
	 @param scale The scale value
	 @param point The scaling center point
	 @brief Scale the cylinder by a point
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <common/FrameT.hpp>
#include <modeling/MakeFace.hpp>
#include <common/AxisT.hpp>
#include <math/Cylinder.hpp>
#include <common/VectorT.hpp>
#include <occtio/OCCTTool.hpp>
#include <modeling/MakeCylinder.hpp>
#include <iostream>
using namespace AMCAX;
using namespace std;
TEST_CASE("case2:this is a case for Test Cylinder_Mirror&Mirrored/Rotate&Rotated/Scale&Scaled", "[math][Cylinder][P1]")
{
	Point3 point_cy(6.0, 0.0, 0.0);
	Direction3 dir_cy(0.0, 0.0, 1.0);
	Frame3 frame_cy(point_cy, dir_cy);
	double radius_cy = 5.0;
	Cylinder cylinder(frame_cy, radius_cy);
	SECTION("Scale")
	{
		Cylinder scale_cylinder = cylinder.Scale(point_cy, scale);
		CHECK(cylinder.Radius() == Approx(2.5));
		CHECK(cylinder.Location().X() == Approx(6.0));
		CHECK(cylinder.Location().Y() == Approx(0.0));
		CHECK(cylinder.Location().Z() == Approx(0.0));
		CHECK(cylinder.Axis().Direction().X() == 0.0);
		CHECK(cylinder.Axis().Direction().Y() == 0.0);
		CHECK(cylinder.Axis().Direction().Z() == 1.0);
		CHECK(scale_cylinder.Radius() == Approx(2.5));
		CHECK(scale_cylinder.Location().X() == Approx(6.0));
		CHECK(scale_cylinder.Location().Y() == Approx(0.0));
		CHECK(scale_cylinder.Location().Z() == Approx(0.0));
		CHECK(scale_cylinder.Axis().Direction().X() == 0.0);
		CHECK(scale_cylinder.Axis().Direction().Y() == 0.0);
		CHECK(scale_cylinder.Axis().Direction().Z() == 1.0);
	}
	scale = 2.0;}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":void SetMajorRadius(double r)	 @param r The new major radius
	 @brief Set the major radius
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <modeling/MakeFace.hpp>
#include <common/AxisT.hpp>
#include <math/HyperbolaT.hpp>
#include <occtio/OCCTTool.hpp>
#include <common/VectorT.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <topology/TopoEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <common/TransformationT.hpp>
#include <iostream>
using namespace AMCAX;
using namespace std;
TEST_CASE("case1:this is a case for Hyperbola2", "[math][Hyperbola2][p1]") {
	Point2 point2_Hy(0.0, 0.0);	
	Direction2 dir2_Hy(1.0, 0.0);
	Axis2 major2_Axis(point2_Hy, dir2_Hy);
	double major2 = 3.0, minor2 = 4.0;
	Hyperbola2 hyperbola2d_ax(major2_Axis, major2, minor2, true);
	Point2 point2_fr(1.0, 1.0);
	Direction2 dir2_fr(0.0, 1.0);
	Frame2 frame2(point2_fr, dir2_fr);
	Hyperbola2 hyperbola2d_fr(frame2, major2, minor2);
	SECTION("Default()") {
		Hyperbola2 hyperbola2d_de;	
		CHECK(hyperbola2d_de.Location().X() == Approx(0.0));
		CHECK(hyperbola2d_de.Location().Y() == Approx(0.0));
		hyperbola2d_de.SetMajorRadius(3.0);
		hyperbola2d_de.SetMinorRadius(4.0);
		CHECK(hyperbola2d_de.MajorRadius() == Approx(3.0));
		CHECK(hyperbola2d_de.MinorRadius() == Approx(4.0));
		CHECK(hyperbola2d_de.Focal() == Approx(10.0));
		CHECK(hyperbola2d_de.Focus1().X() == Approx(5.0));
		CHECK(hyperbola2d_de.Focus1().Y() == Approx(0.0));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":void SetMinorRadius(double r)	 @param r The new minor radius
	 @brief Set the minor radius
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <modeling/MakeFace.hpp>
#include <common/AxisT.hpp>
#include <math/HyperbolaT.hpp>
#include <occtio/OCCTTool.hpp>
#include <common/VectorT.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <topology/TopoEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <common/TransformationT.hpp>
#include <iostream>
using namespace AMCAX;
using namespace std;
TEST_CASE("case1:this is a case for Hyperbola2", "[math][Hyperbola2][p1]") {
	Point2 point2_Hy(0.0, 0.0);	
	Direction2 dir2_Hy(1.0, 0.0);
	Axis2 major2_Axis(point2_Hy, dir2_Hy);
	double major2 = 3.0, minor2 = 4.0;
	Hyperbola2 hyperbola2d_ax(major2_Axis, major2, minor2, true);
	Point2 point2_fr(1.0, 1.0);
	Direction2 dir2_fr(0.0, 1.0);
	Frame2 frame2(point2_fr, dir2_fr);
	Hyperbola2 hyperbola2d_fr(frame2, major2, minor2);
	SECTION("SetMinorRadius()") {
		hyperbola2d_ax.SetMinorRadius(3.0);
		CHECK(hyperbola2d_ax.Location().X() == Approx(0.0));
		CHECK(hyperbola2d_ax.Location().Y() == Approx(0.0));
		CHECK(hyperbola2d_ax.MajorRadius() == Approx(3.0));
		CHECK(hyperbola2d_ax.MinorRadius() == Approx(3.0));
		Point3 point1(3.0, 0.0, 0.0);
		MakeEdge2d edge1(hyperbola2d_ax);
		CHECK(BRepClassificationTools::IsPointInOnEdge(edge1, point1, 0.001) == true);
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] AxisT<double, DIM> Directrix2()	 @return The negative directrix
	 @brief Get the directrix on the negative side of the major axis
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <modeling/MakeFace.hpp>
#include <common/AxisT.hpp>
#include <math/HyperbolaT.hpp>
#include <occtio/OCCTTool.hpp>
#include <common/VectorT.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <topology/TopoEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <common/TransformationT.hpp>
#include <iostream>
using namespace AMCAX;
using namespace std;
TEST_CASE("case1:this is a case for Hyperbola2", "[math][Hyperbola2][p1]") {
	Point2 point2_Hy(0.0, 0.0);	
	Direction2 dir2_Hy(1.0, 0.0);
	Axis2 major2_Axis(point2_Hy, dir2_Hy);
	double major2 = 3.0, minor2 = 4.0;
	Hyperbola2 hyperbola2d_ax(major2_Axis, major2, minor2, true);
	Point2 point2_fr(1.0, 1.0);
	Direction2 dir2_fr(0.0, 1.0);
	Frame2 frame2(point2_fr, dir2_fr);
	Hyperbola2 hyperbola2d_fr(frame2, major2, minor2);
	SECTION("Directrix()") {
		Axis2 axis2d_dir = hyperbola2d_ax.Directrix2();
		CHECK(axis2d_dir.Direction().X() == Approx(0.0));
		CHECK(axis2d_dir.Direction().Y() == Approx(1.0));
		CHECK(axis2d_dir.Location().X() == Approx(-9.0 / 5.0));
		CHECK(axis2d_dir.Location().Y() == Approx(0.0));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] PointT<double, DIM> Focus1()	 @return The positive focus
	 @brief Get the focus on the positive side of the major axis
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <modeling/MakeFace.hpp>
#include <common/AxisT.hpp>
#include <math/HyperbolaT.hpp>
#include <occtio/OCCTTool.hpp>
#include <common/VectorT.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <topology/TopoEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <common/TransformationT.hpp>
#include <iostream>
using namespace AMCAX;
using namespace std;
TEST_CASE("case1:this is a case for Hyperbola2", "[math][Hyperbola2][p1]") {
	Point2 point2_Hy(0.0, 0.0);	
	Direction2 dir2_Hy(1.0, 0.0);
	Axis2 major2_Axis(point2_Hy, dir2_Hy);
	double major2 = 3.0, minor2 = 4.0;
	Hyperbola2 hyperbola2d_ax(major2_Axis, major2, minor2, true);
	Point2 point2_fr(1.0, 1.0);
	Direction2 dir2_fr(0.0, 1.0);
	Frame2 frame2(point2_fr, dir2_fr);
	Hyperbola2 hyperbola2d_fr(frame2, major2, minor2);
	SECTION("Default()") {
		Hyperbola2 hyperbola2d_de;	
		CHECK(hyperbola2d_de.Location().X() == Approx(0.0));
		CHECK(hyperbola2d_de.Location().Y() == Approx(0.0));
		hyperbola2d_de.SetMajorRadius(3.0);
		hyperbola2d_de.SetMinorRadius(4.0);
		CHECK(hyperbola2d_de.MajorRadius() == Approx(3.0));
		CHECK(hyperbola2d_de.MinorRadius() == Approx(4.0));
		CHECK(hyperbola2d_de.Focal() == Approx(10.0));
		CHECK(hyperbola2d_de.Focus1().X() == Approx(5.0));
		CHECK(hyperbola2d_de.Focus1().Y() == Approx(0.0));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] double MajorRadius()	 @return The major radius
	 @brief Get the major radius
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <modeling/MakeFace.hpp>
#include <common/AxisT.hpp>
#include <math/HyperbolaT.hpp>
#include <occtio/OCCTTool.hpp>
#include <common/VectorT.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <topology/TopoEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <common/TransformationT.hpp>
#include <iostream>
using namespace AMCAX;
using namespace std;
TEST_CASE("case1:this is a case for Hyperbola2", "[math][Hyperbola2][p1]") {
	Point2 point2_Hy(0.0, 0.0);	
	Direction2 dir2_Hy(1.0, 0.0);
	Axis2 major2_Axis(point2_Hy, dir2_Hy);
	double major2 = 3.0, minor2 = 4.0;
	Hyperbola2 hyperbola2d_ax(major2_Axis, major2, minor2, true);
	Point2 point2_fr(1.0, 1.0);
	Direction2 dir2_fr(0.0, 1.0);
	Frame2 frame2(point2_fr, dir2_fr);
	Hyperbola2 hyperbola2d_fr(frame2, major2, minor2);
	SECTION("Default()") {
		Hyperbola2 hyperbola2d_de;	
		CHECK(hyperbola2d_de.Location().X() == Approx(0.0));
		CHECK(hyperbola2d_de.Location().Y() == Approx(0.0));
		hyperbola2d_de.SetMajorRadius(3.0);
		hyperbola2d_de.SetMinorRadius(4.0);
		CHECK(hyperbola2d_de.MajorRadius() == Approx(3.0));
		CHECK(hyperbola2d_de.MinorRadius() == Approx(4.0));
		CHECK(hyperbola2d_de.Focal() == Approx(10.0));
		CHECK(hyperbola2d_de.Focus1().X() == Approx(5.0));
		CHECK(hyperbola2d_de.Focus1().Y() == Approx(0.0));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] double MinorRadius()	 @return The minor radius
	 @brief Get the minor radius
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <modeling/MakeFace.hpp>
#include <common/AxisT.hpp>
#include <math/HyperbolaT.hpp>
#include <occtio/OCCTTool.hpp>
#include <common/VectorT.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <topology/TopoEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <common/TransformationT.hpp>
#include <iostream>
using namespace AMCAX;
using namespace std;
TEST_CASE("case1:this is a case for Hyperbola2", "[math][Hyperbola2][p1]") {
	Point2 point2_Hy(0.0, 0.0);	
	Direction2 dir2_Hy(1.0, 0.0);
	Axis2 major2_Axis(point2_Hy, dir2_Hy);
	double major2 = 3.0, minor2 = 4.0;
	Hyperbola2 hyperbola2d_ax(major2_Axis, major2, minor2, true);
	Point2 point2_fr(1.0, 1.0);
	Direction2 dir2_fr(0.0, 1.0);
	Frame2 frame2(point2_fr, dir2_fr);
	Hyperbola2 hyperbola2d_fr(frame2, major2, minor2);
	SECTION("ConjugateBranch1()") {
		Point3 point1(0.0, 4.0, 0.0);
		Point3 point2(9.0 / 4.0, 5.0, 0.0);
		Hyperbola2 hyperbola2d_con = hyperbola2d_ax.ConjugateBranch1();
		MakeEdge2d edge1(hyperbola2d_con);
		CHECK(BRepClassificationTools::IsPointInOnEdge(edge1, point1, 0.001) == true);
		CHECK(BRepClassificationTools::IsPointInOnEdge(edge1, point2, 0.001) == true);
		double major2d_con = hyperbola2d_con.MajorRadius();
		double minor2d_con = hyperbola2d_con.MinorRadius();
		CHECK( major2d_con== Approx(4.0));
		CHECK(minor2d_con == Approx(3.0));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] AxisT<double, DIM> Asymptote1()	 @return The positive asymptote
	 @brief Get the asymptote of the hyperbola with positive slope
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <modeling/MakeFace.hpp>
#include <common/AxisT.hpp>
#include <math/HyperbolaT.hpp>
#include <occtio/OCCTTool.hpp>
#include <common/VectorT.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <topology/TopoEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <common/TransformationT.hpp>
#include <iostream>
using namespace AMCAX;
using namespace std;
TEST_CASE("case1:this is a case for Hyperbola2", "[math][Hyperbola2][p1]") {
	Point2 point2_Hy(0.0, 0.0);	
	Direction2 dir2_Hy(1.0, 0.0);
	Axis2 major2_Axis(point2_Hy, dir2_Hy);
	double major2 = 3.0, minor2 = 4.0;
	Hyperbola2 hyperbola2d_ax(major2_Axis, major2, minor2, true);
	Point2 point2_fr(1.0, 1.0);
	Direction2 dir2_fr(0.0, 1.0);
	Frame2 frame2(point2_fr, dir2_fr);
	Hyperbola2 hyperbola2d_fr(frame2, major2, minor2);
	SECTION("Asymptote1()") {
		Axis2 axis2d_asy = hyperbola2d_ax.Asymptote1();
		CHECK(axis2d_asy.Direction().X()/ axis2d_asy.Direction().Y() == Approx(3.0/4.0));
		Point3 point1(0.0, 0.0, 0.0);
		Line2 line2d_asy(axis2d_asy);
		MakeEdge2d edge1(line2d_asy);
		CHECK(BRepClassificationTools::IsPointInOnEdge(edge1, point1, 0.001) == true);
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] AxisT<double, DIM> Asymptote2()	 @return The negative asymptote
	 @brief Get the asymptote of the hyperbola with negative slope
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <modeling/MakeFace.hpp>
#include <common/AxisT.hpp>
#include <math/HyperbolaT.hpp>
#include <occtio/OCCTTool.hpp>
#include <common/VectorT.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <topology/TopoEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <common/TransformationT.hpp>
#include <iostream>
using namespace AMCAX;
using namespace std;
TEST_CASE("case1:this is a case for Hyperbola2", "[math][Hyperbola2][p1]") {
	Point2 point2_Hy(0.0, 0.0);	
	Direction2 dir2_Hy(1.0, 0.0);
	Axis2 major2_Axis(point2_Hy, dir2_Hy);
	double major2 = 3.0, minor2 = 4.0;
	Hyperbola2 hyperbola2d_ax(major2_Axis, major2, minor2, true);
	Point2 point2_fr(1.0, 1.0);
	Direction2 dir2_fr(0.0, 1.0);
	Frame2 frame2(point2_fr, dir2_fr);
	Hyperbola2 hyperbola2d_fr(frame2, major2, minor2);
	SECTION("Asymptote2()") {	
		Axis2 axis2d_asy = hyperbola2d_ax.Asymptote2();
		CHECK(axis2d_asy.Direction().X() / axis2d_asy.Direction().Y() == Approx(-3.0 / 4.0));
		Point3 point1(0.0, 0.0, 0.0);
		Line2 line2d_asy(axis2d_asy);
		MakeEdge2d edge1(line2d_asy);
		CHECK(BRepClassificationTools::IsPointInOnEdge(edge1, point1, 0.001) == true);
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":[[nodiscard]] HyperbolaS ConjugateBranch2()	 @return The negative conjugate hyperbola
	 @brief Get the conjugate hyperbola on the negative side of the minor axis
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <modeling/MakeFace.hpp>
#include <common/AxisT.hpp>
#include <math/HyperbolaT.hpp>
#include <occtio/OCCTTool.hpp>
#include <common/VectorT.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <topology/TopoEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <common/TransformationT.hpp>
#include <iostream>
using namespace AMCAX;
using namespace std;
TEST_CASE("case1:this is a case for Hyperbola2", "[math][Hyperbola2][p1]") {
	Point2 point2_Hy(0.0, 0.0);	
	Direction2 dir2_Hy(1.0, 0.0);
	Axis2 major2_Axis(point2_Hy, dir2_Hy);
	double major2 = 3.0, minor2 = 4.0;
	Hyperbola2 hyperbola2d_ax(major2_Axis, major2, minor2, true);
	Point2 point2_fr(1.0, 1.0);
	Direction2 dir2_fr(0.0, 1.0);
	Frame2 frame2(point2_fr, dir2_fr);
	Hyperbola2 hyperbola2d_fr(frame2, major2, minor2);
	SECTION("ConjugateBranch2()") {
		Point3 point1(0.0, -4.0, 0.0);
		Point3 point2(9.0 / 4.0, -5.0, 0.0);
		Hyperbola2 hyperbola2d_con = hyperbola2d_ax.ConjugateBranch2();
		MakeEdge2d edge1(hyperbola2d_con);
		CHECK(BRepClassificationTools::IsPointInOnEdge(edge1, point1, 0.001) == true);
		CHECK(BRepClassificationTools::IsPointInOnEdge(edge1, point2, 0.001) == true);
		double major2d_con = hyperbola2d_con.MajorRadius();
		double minor2d_con = hyperbola2d_con.MinorRadius();
		CHECK(major2d_con == Approx(4.0));
		CHECK(minor2d_con == Approx(3.0));
	}}
}
,{
 "instruction":Generate a test program based on the following method declarations and parameter parsing ,
 "input":HyperbolaS& Scale(const PointT<double, DIM>& point, double scale)	 @return The reference to self
	 @param scale The scale value
	 @param point The scaling center point
	 @brief Scale the hyperbola by a center point
,
 "output":#include <catch.hpp>
#include <testHelper.h>
#include <common/DirectionT.hpp>
#include <common/FrameT.hpp>
#include <modeling/MakeFace.hpp>
#include <common/AxisT.hpp>
#include <math/HyperbolaT.hpp>
#include <occtio/OCCTTool.hpp>
#include <common/VectorT.hpp>
#include <hatch/BRepClassificationTools.hpp>
#include <topology/TopoEdge.hpp>
#include <modeling/MakeEdge2d.hpp>
#include <modeling/MakeEdge.hpp>
#include <common/TransformationT.hpp>
#include <iostream>
using namespace AMCAX;
using namespace std;
TEST_CASE("case1:this is a case for Hyperbola2", "[math][Hyperbola2][p1]") {
	Point2 point2_Hy(0.0, 0.0);	
	Direction2 dir2_Hy(1.0, 0.0);
	Axis2 major2_Axis(point2_Hy, dir2_Hy);
	double major2 = 3.0, minor2 = 4.0;
	Hyperbola2 hyperbola2d_ax(major2_Axis, major2, minor2, true);
	Point2 point2_fr(1.0, 1.0);
	Direction2 dir2_fr(0.0, 1.0);
	Frame2 frame2(point2_fr, dir2_fr);
	Hyperbola2 hyperbola2d_fr(frame2, major2, minor2);
	SECTION("Scale()") {		
		Point2 point2(1.0, 1.0);
		hyperbola2d_ax.Scale(point2, 0.5);
		CHECK(hyperbola2d_ax.Location().X() == Approx(0.5));
		CHECK(hyperbola2d_ax.Location().Y() == Approx(0.5));
		Point3 point3(2.0, 0.5, 0.0);
		MakeEdge2d edge1(hyperbola2d_ax);
		CHECK(BRepClassificationTools::IsPointInOnEdge(edge1, point3, 0.001) == true);
	}}
}
,